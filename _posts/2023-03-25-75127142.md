---
layout: post
title: "连接池一数据库连接关闭后为何还能共享"
date: 2023-03-25 14:20:36 +0800
description: "在数据库连接池的使用过程中，一直有一个疑问：  在数据库连接的使用过程中，必须要满足独占性要求(其他"
keywords: "impala.dbapi.connect close之后为什么还可以连接数据库"
categories: ['Java']
tags: ['数据库连接池', '关闭后共享', '共享原理', 'Dbc']
artid: "75127142"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=75127142
    alt: "连接池一数据库连接关闭后为何还能共享"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     连接池(一)：数据库连接关闭后为何还能共享？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在数据库连接池的使用过程中，一直有一个疑问：
    </p>
    <blockquote>
     <p>
      在数据库连接的使用过程中，必须要满足独占性要求(其他线程不能访问)，使用完成后关闭数据库连接，那么问题来了，数据库都已经连接关闭了，那其他线程又怎么使用呢？
     </p>
    </blockquote>
    <p>
     带着这样的疑问，我们一起阅读了“org.apache.commons.dbcp2.BasicDataSource”的实现源码，发现从数据源中获取连接的调用顺序依次如下：
     <br/>
     1. BasicDataSource.getConnection();
     <br/>
     2. PoolingDataSource.getConnection();
     <br/>
     3. GenericObjectPool.borrowObject();
     <br/>
     4. PoolableConnectionFactory.makeObject()
    </p>
    <p>
     现在连接的产生就在于PoolableConnectionFactory是如何产生数据连接的(makeObject)，源码如下(为省略篇幅，所以代码为节选)：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-comment">//  _connFactory为DriverConnectionFactory的实例，创建数据库连接的方法为Driver.connect()，所以这是真正的数据库连接</span>
Connection conn = _connFactory.createConnection();
<span class="hljs-comment">//  如果此连接创建失败，后面的连接也没用了</span>
<span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Connection factory returned null from createConnection"</span>);
}
<span class="hljs-comment">//  初始化配置代码略</span>
<span class="hljs-comment">//  返回连接的包装结果</span>
PoolableConnection pc = <span class="hljs-keyword">new</span> PoolableConnection(conn,_pool, connJmxName,
                          _disconnectionSqlCodes, _fastFailValidation);
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPooledObject&lt;&gt;(pc);</code></pre>
    <p>
     从这里可以看出，在项目的实际运行过程中，我们从数据库连接池获取的连接类型都是PoolableConnection，其类的声明如下：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolableConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingConnection</span>&lt;<span class="hljs-title">Connection</span>&gt;
        <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolableConnectionMXBean</span> {<!-- --></span>
}</code></pre>
    <p>
     而DelegatingConnection实现了Connection接口，所以PoolableConnection也实现了Connection接口。
    </p>
    <pre class="prettyprint"><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingConnection</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Connection</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbandonedTrace</span>
        <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> {<!-- --></span>

        }</code></pre>
    <p>
     现在，我们关注重点在于PoolableConnection的close()方法，如下：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span>() <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">//  只有这里才是真正的关闭，原生Connection.close()</span>
        <span class="hljs-keyword">if</span> (isClosedInternal()) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">boolean</span> isUnderlyingConectionClosed;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//  获取真正的数据库连接对象，判断原生数据库连接是否真的关闭了</span>
            isUnderlyingConectionClosed = getDelegateInternal().isClosed();
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            <span class="hljs-comment">//  销毁数据库连接池中的无效对象</span>
            <span class="hljs-keyword">try</span> {
                _pool.invalidateObject(<span class="hljs-keyword">this</span>);
            } <span class="hljs-keyword">catch</span>(IllegalStateException ise) {
                <span class="hljs-comment">// 如果连接池已关闭，则销毁对象</span>
                passivate();
                getInnermostDelegate().close();
            } <span class="hljs-keyword">catch</span> (Exception ie) {
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"Cannot close connection (isClosed check failed)"</span>, e);
        }

        <span class="hljs-comment">/* 在数据库连接校验完成之前，不能关闭连接
         * 数据库连接已归还到池中的时候，也不能关闭连接
         */</span>
        <span class="hljs-keyword">if</span> (isUnderlyingConectionClosed) {
             <span class="hljs-keyword">try</span> {
                _pool.invalidateObject(<span class="hljs-keyword">this</span>);
            } <span class="hljs-keyword">catch</span>(IllegalStateException e) {
                passivate();
                getInnermostDelegate().close();
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"Cannot close connection (invalidating pooled object failed)"</span>, e);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">try</span> {
                _pool.returnObject(<span class="hljs-keyword">this</span>);
            } <span class="hljs-keyword">catch</span>(IllegalStateException e) {
                passivate();
                getInnermostDelegate().close();
            } <span class="hljs-keyword">catch</span>(SQLException e) {
                <span class="hljs-keyword">throw</span> e;
            } <span class="hljs-keyword">catch</span>(RuntimeException e) {
                <span class="hljs-keyword">throw</span> e;
            } <span class="hljs-keyword">catch</span>(Exception e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(<span class="hljs-string">"Cannot close connection (return to pool failed)"</span>, e);
            }
        }
    }</code></pre>
    <p>
     从上面的代码可以看出，所谓的关闭只是把数据库连接还会给数据库连接池，并没有真正地关闭数据库连接(调用原生数据库连接的关闭方法)，大量的逻辑都在判断原生连接是否真的有效（未关闭状态）。
    </p>
    <h3 id="结论">
     结论
    </h3>
    <p>
     我们所使用的数据库连接执行的关闭，并不是真正意义上的断开数据库连接，而只是做了一个可用性标记(如额外添加一个boolean字段，用于判断状态)，从而利于连接池对有效连接的判断。
    </p>
    <p>
     也因为这样的原因，数据库连接池也有缺点，如在开发过程中，如果代码设置的初始化连接数量过大，开发服务器的真实连接数量可能不够用，从而出现没有可用数据库连接的错误。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f796969666161:2f61727469636c652f64657461696c732f3735313237313432" class_="artid" style="display:none">
 </p>
</div>


