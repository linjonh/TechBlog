---
layout: post
title: "翻格子游戏"
date: 2021-11-02 21:17:25 +0800
description: "前几天，朋友玩一个解谜类的游戏。中间有一个关卡，大概是这样的：有一个5*5的板子，初始时，每个格子都"
keywords: "5*5翻格子"
categories: ['其它']
tags: ['无标签']
artid: "18265333"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=18265333
    alt: "翻格子游戏"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     翻格子游戏
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="font-size:14px">
      前几天，朋友玩一个解谜类的游戏。中间有一个关卡，大概是这样的：
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      有一个5*5的板子，初始时，每个格子都是背面朝上。我们可以手动翻转任意一个格子，但其上下左右——如果有的话——的格子也会随之一起翻转，问怎么翻，可以将所有格子都翻到正面朝上。
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      <br/>
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      当时蛮无聊，那就写段代码试试看吧。
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      这里，手动翻我们定义为主动，而被动当然就很清楚了。
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      不难想到，对任意一个格子来说，我们主动翻N次和N+2次的结果是一样的。因此，任何一种解决方案都是将每个格子主动翻0或1次。而且，翻格子的先后顺序也是无所谓的。于是，想到一种简单粗暴的办法，穷举呗，一共2^25种情形。
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      不多说，直接上代码。
     </span>
    </p>
    <p>
     <span style="font-size:14px">
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int validate(int data, int index, int dimension)
{
	int ret;

	ret = (data &gt;&gt; index)&amp;0x01;
	//left
	if(index%dimension &gt; 0)
		ret ^= (data &gt;&gt; (index-1))&amp;0x01;
	//right
	if(index%dimension &lt; dimension-1)
		ret ^= (data &gt;&gt; (index+1))&amp;0x01;
	//up
	if(index/dimension &gt; 0)
		ret ^= (data &gt;&gt; (index-dimension))&amp;0x01;
	//down
	if(index/dimension &lt; dimension-1)
		ret ^= (data &gt;&gt; (index+dimension))&amp;0x01;

	return ret;
}

int resolve(int data, int d)
{
	int ret = 0;
	int i;
	for (i=0; i&lt;d*d; i++) {
		ret = validate(data, i, d);
		if (!ret)
			return 0;
	}
	return ret;
}

int main()
{
	int map=0;
	int ret = -1;
	int d = 5;

	for (map=0; map&lt;pow(2,d*d); map++) {
		ret = resolve(map, d);
		if (ret) {
			printf("%x\n", map);
		}
	}
	return 0;
}</code></pre>
    <br/>
    <span style="font-size:14px">
     解决方案采用25个bit来描述，每个bit，1表示主动翻，0表示不主动翻。采用位操作不仅节省了空间，而且提高了效率。
    </span>
    <p>
    </p>
    <p>
     <span style="font-size:14px">
      结果发现，解决方案不止一种。
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      <br/>
     </span>
    </p>
    <p>
     <span style="font-size:14px">
      当然，需要注意的是，如果6*6的格子，用32bit整型会导致溢出。
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f686a61736f6e32303432:2f61727469636c652f64657461696c732f3138323635333333" class_="artid" style="display:none">
 </p>
</div>


