---
layout: post
title: Operating-Systems-Three-Easy-Pieces操作系统三个简单方面4.3进程创建的更多细节
date: 2024-05-16 16:14:47 +0800
categories: ['操作系统']
tags: ['无标签']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=50914032
    alt: Operating-Systems-Three-Easy-Pieces操作系统三个简单方面4.3进程创建的更多细节
artid: 50914032
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Operating Systems: Three Easy Pieces(操作系统：三个简单方面)4.3进程创建的更多细节
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      4.3进程创建：更多的细节
     </strong>
    </p>
    <p>
     首先我们要揭秘的是，程序是怎样转换为进程的。尤其是，操作系统怎么得到一个程序并将之运行？进程创建实际上是怎么作用的？
    </p>
    <p>
     操作系统想要允许程序时，最先要做的事情就是将程序的代码段和数据段（比如初始化过的变量）载入进程的内存和地址空间。程序最初是以可执行格式存储在磁盘（或者在现代操作系统中还有基于闪存的固态硬盘）上的。因此，载入程序和静态数据进入内存的进程需要操作系统从磁盘读取数据并将它们存放在内存中的某处（见图4.1，图被本宝放上一节去了，大家可以顺着本宝宝的文章找过去，不过不看也没事，这张图百度哪哪都有）。
    </p>
    <p>
     在早期简单的操作系统中，装载进程很紧急，即在程序运行之前一次性全部完成；现代操作系统执行该进程就很慵懒了，在程序执行过程中只载入需要用的代码片段和数据。为了真正了解载入代码和数据片段有多懒，你需要了解机器中的分页机制和调度机制，这个专题我们将放在在后续有关内存虚拟化的讨论中。
    </p>
    <p>
     现在只要记得，在运行任何程序之前，操作系统必须做一些工作来从磁盘获取重要的程序数据放入内存。
    </p>
    <p>
     一旦代码段和静态数据被装入内存以后，操作系统在启动进程之前还需要做一些其他的事情。一部分的内存空间需要分配给程序的运行时堆栈(或者也就是堆栈)。或许你应该已经知道，C语言程序将堆栈用来存放局部变量，功能参数以及返回地址；操作系统将内存进行划分并将之交给进程。操作系统似乎也初始化了带参的堆栈；尤其是它会将这些参数传入main()函数中，即argc和argv数组。
    </p>
    <p>
     {
     <!-- -->
    </p>
    <p>
     ……常见int main(int argc,char **argv);
    </p>
    <p>
     这是本宝宝的常用写法，
    </p>
    <p>
     argc表示参数个数，
    </p>
    <p>
     argv数组中存放的是参数的具体内容 ，
    </p>
    <p>
     argc可用在main函数中作为参数个数的检查哦。
    </p>
    <p>
     }
    </p>
    <p>
     操作系统也会分配一些内存空间给程序的堆，在C语言中，堆空间用于需求明确的动态分配空间的数据；程序通过调用malloc()函数来申请一块大小明确的空间，然后通过调用free()函数再准确的释放掉该空间。堆空间通常被一些数据结构所使用，如链表，哈希表，树和其他一些很有趣的数据结构。首先堆空间会变小；随着程序的运行和malloc()库函数对空间的分配，操作系统可能会介入并分配更多的内存空间给进程来满足这些需求。
    </p>
    <p>
     操作系统还会做其他一些初始化的工作，尤其是I/O(input/output输入输出流，用于数据读取写入等)相关的 。比如，在UNIX系统中，每个默认进程都拥有三个文件描述符，标准输入(stdin)，标准输出(stdout)和标准错误(stderr)。这些描述符使得程序轻松的从终端读取输入的数据并将输出结果打印到显示器。我们将在本书的第三部分，持续性的部分学习I/O,文件描述符等。
    </p>
    <p>
     通过载入代码和静态数据进入内存，通过创建和初始化栈，通过执行与I/O相关的操作这些步骤，操作系统最终为程序的执行做好铺垫了。至此，它还有最后一个任务，在程序入口处启动程序，也就是main()函数处。通过跳转至main()函数的路线（通过一个特殊的机制，将在下一章讨论 ），操作系统将对CPU的控制权交给一个新建的进程，因此，程序开始执行。
     <br/>
    </p>
    <p>
     （下一节，4.4进程状态，跪求大家多多指教，虽然操作系统相关的数据看了不少，但是本宝宝也是第一次翻译全英文的，不管有没有中文版）
     <br/>
    </p>
   </div>
  </div>
 </article>
</div>


