---
layout: post
title: "python接口测试框架选择之pytestyamlAllure"
date: 2025-01-01 14:51:26 +0800
description: "为什么选择pytest+yaml+Allure作为python接口测试框架？他们各有什么优势？本文将"
keywords: "pytest+allure+yaml"
categories: ['Pytest']
tags: ['自动化', '测试工具', '开发语言', '单元测试', 'Python']
artid: "123463428"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=123463428
    alt: "python接口测试框架选择之pytestyamlAllure"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     python接口测试框架选择之pytest+yaml+Allure
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <h2 id="前言">
     前言
    </h2>
    <p>
     2021年，部门的测试组尝试着用jmeter做简单的接口测试，使用工具就需要遵守工具的很多规则，并且jmeter对需要写辅助测试代码的场景不友好。2022年,改为用python写接口测试。在经过一段时间的摸索，团队选择pytest+yaml+Allure搭建自动化接口框架。
    </p>
    <h3 id="为什么选择pytest">
     一、为什么选择pytest？
    </h3>
    <ul>
     <li>
      pytest完全兼容python自带的unittest
     </li>
     <li>
      pytest让单元测试更简单，能很好的管理测试用例。
     </li>
     <li>
      对于实现接口测试的复杂场景，pytest的fixture、PDB等高阶用法都能实现需求。
     </li>
     <li>
      入门简单，对于代码基础薄弱的团队人员，也可以用pytest实现较简单的单个接口测试。
     </li>
     <li>
      社区活跃，遇到问题可以在网上找到解决方法。
     </li>
    </ul>
    <p>
     pytest官方文档：
    </p>
    <p>
     <a href="https://docs.pytest.org/en/latest/" rel="nofollow" title="pytest: helps you write better programs — pytest documentation">
      pytest: helps you write better programs — pytest documentation
     </a>
    </p>
    <h4 id="举个例子pytest简单使用场景">
     pytest实战例子：修改用户信息
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：测试修改用户昵称是否成功
     <br/>
     <strong>
      涉及接口
     </strong>
     ：用户登录接口、用户信息修改接口、用户信息接口。用户信息修改接口和用户信息接口需要上传登录接口下发的token字段
     <br/>
     <strong>
      接口处理逻辑分析：
     </strong>
    </p>
    <ol>
     <li>
      用户登录后拿到token，将token设为全局变量。
     </li>
     <li>
      上传修改后的用户昵称到用户修改接口
     </li>
     <li>
      请求用户信息接口，拿到昵称字段，判断是否为修改后的的昵称。
     </li>
    </ol>
    <p>
     <strong>
      代码展示
     </strong>
    </p>
    <pre><code>import pytest
updata_name = "sunny"
expect_result = updata_name #期待修改后的昵称
class TestUpdataUserInfo:
    def setup_class(self):
        print("请求登录接口，获取到token")
        self.token = "token" #将token设为全局变量，这里暂时用"token"代替接口返回的token

    def teardown_class(self):
        # 此方法写请求获取用户信息接口，拿到用户昵称逻辑代码
        tokenStr = self.token  # 获取到token，用于请求修改用户信息接口
        print("请求用户信息接口，拿到昵称")
        nickName = "sunny"#假设接口拿到的昵称为"sunny"
        assert nickName==expect_result #校验是否为期待的昵称

    def test_update_userInfo(self):
        #此方法写上传修改后的用户昵称到用户修改接口的逻辑
        tokenStr = self.token #获取到token，用于请求修改用户信息接口
        print("token:"+tokenStr)
        print("上传需要修改的昵称")
if __name__ == '__main__':
    pytest.main(['-s', 'pytest-demo.py'])
</code></pre>
    <h3 id="为什么选择yaml">
     二、为什么选择yaml？
    </h3>
    <ul>
     <li>
      写法简洁易懂，视觉上也很舒适
     </li>
     <li>
      yaml支持python,yaml+pytest实现数据分离很简便。
     </li>
     <li>
      配置有序，支持数组写法，数组中的元素可以是基本数据类型也可以是对象
     </li>
    </ul>
    <h4 id="举个例子">
     实战例子：用yaml写测试数据
    </h4>
    <p>
     上文的pytest例子中，测试上传的昵称数据和期待修改后的昵称数据都是写在updataUserInfo.py文件，这种写法不方法管理，现在改为用yaml文件写测试数据。
    </p>
    <p>
     <strong>
      代码展示
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       创建yaml文件：updataUserInfo.yaml，将测试数据写入
      </strong>
     </li>
    </ol>
    <pre><code>test:
  name: test case1
  updateName: "sunny"
  result:
    expectName: "sunny"
</code></pre>
    <ol>
     <li>
      <strong>
       获取到yaml数据如下
      </strong>
     </li>
    </ol>
    <pre><code>{'test': {'name': 'test case1', 'updateName': 'sunny', 'result': {'expectName': 'sunny'}}}
</code></pre>
    <ol>
     <li>
      <strong>
       获取到yaml文件里的数据，进行请求和校验
      </strong>
     </li>
    </ol>
    <pre><code>import pytest
import yaml

# updata_name = "sunny"
# expect_result = updata_name #期待修改后的昵称
class TestUpdataUserInfo(object):

    def setup_class(self):
        ##获取yaml文件里面的数据,
        with open("./updataUserInfo.yaml", 'r') as f:
            content = yaml.safe_load(f)
            print(content)
        self.update_name = content['test']['updateName']
        self.expect_name = content['test']['result']['expectName']

        print("请求登录接口，获取到token")
        self.token = "token" #将token设为全局变量，这里暂时用"token"代替接口返回的token

    def teardown_class(self):
        # 此方法写请求获取用户信息接口，拿到用户昵称逻辑代码
        tokenStr = self.token  # 获取到token，用于请求修改用户信息接口
        print("请求用户信息接口，拿到昵称")
        nickName = "sunny"#假设接口拿到的昵称为"sunny"
        assert nickName==self.expect_name #校验是否为期待的昵称

    def test_update_userInfo(self):
        #此方法写上传修改后的用户昵称到用户修改接口的逻辑
        tokenStr = self.token #获取到token，用于请求修改用户信息接口
        print("token:"+tokenStr)
        print("需要修改的值为："+self.update_name)
        print("上传需要修改的昵称")


if __name__ == '__main__':
    pytest.main(['-s', 'pytest-demo.py'])

</code></pre>
    <h3 id="为什么选择allure">
     三、为什么选择Allure？
    </h3>
    <ul>
     <li>
      生成高大上的测试报告，展示测试结果直观明了，利于向领导展示自动化测试成果。
     </li>
     <li>
      有失败用例截图、测试步骤和测试说明信息。方便测试人员查看测试结果。
     </li>
    </ul>
    <p>
     pytest使用allure官方文档
    </p>
    <p>
     <a href="https://docs.qameta.io/allure-report/frameworks/python/pytest" rel="nofollow" title="Pytest">
      Pytest
     </a>
    </p>
    <p>
     Allure测试报告展示
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/955a8000b353547c5e2e491e209f53ac.png"/>
    </p>
    <h2>
     写在后面的话
    </h2>
    <p>
     pytest+yaml+Allure对于搭建接口测试框架，是一个很不错的选择。即使团队中有代码基础相对薄弱的同事，可以先帮忙写yaml文件，也可以通过在yaml文件中补充用例，来使用写好的测试脚本，而不需要完全掌握代码。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33363336333037392f:61727469636c652f64657461696c732f313233343633343238" class_="artid" style="display:none">
 </p>
</div>


