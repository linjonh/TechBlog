---
layout: post
title: "数据结构与算法BFS广度优先搜索"
date: 2025-01-23 20:22:53 +0800
description: "广度优先搜索（Breadth-First Search，简称BFS）是一种遍历或搜索树和图的算法，也"
keywords: "广度优先搜索"
categories: ["未分类"]
tags: ["算法", "广度优先搜索", "宽度优先", "C", "C", "Bfs", "Bfs"]
artid: "141162183"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=141162183
  alt: "数据结构与算法BFS广度优先搜索"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构与算法——BFS(广度优先搜索)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     算法介绍：
    </h3>
    <p>
     广度优先搜索（Breadth-First Search，简称BFS）是一种
     <strong>
      遍历或搜索树和图
     </strong>
     的算法，也称为宽度优先搜索，BFS算法从图的某个节点开始，依次对其所有相邻节点进行探索和遍历，然后再对这些相邻节点的相邻节点进行探索，直到遍历完所有的节点。BFS算法使用
     <strong>
      队列
     </strong>
     来辅助实现，将起始节点放入队列中，然后依次取出队列中的节点，访问其相邻节点，并将其加入队列。这样可以保证从起始节点出发，依次按照距离顺序遍历节点。
     <strong>
      BFS常用于寻找最短路径
     </strong>
     ，因为它按照从起点到每个节点的距离来探索节点。
    </p>
    <p>
     在ACM、蓝桥杯等著名竞赛中BFS算法是比较重要的，特别是在蓝桥杯中每一年几乎都要考
     <strong>
      DFS/BFS算法
     </strong>
     。BFS算法在OI赛中用处非常大，可以通过DFS/BFS暴力的方式可以拿到部分分数，蓝桥杯一般可以拿到20%的分数，有的甚至高达50%，是
     <strong>
      暴力得分
     </strong>
     的不二之选。
    </p>
    <p class="img-center">
     <img alt="" height="98" src="https://i-blog.csdnimg.cn/direct/541fb76cbe7541b8ab14fa085eb7c893.gif" width="781"/>
    </p>
    <h3>
     基本步骤：
    </h3>
    <p>
     BFS算法通常使用
     <strong>
      队列
     </strong>
     来实现，BFS算法的具体步骤如下：
    </p>
    <ol>
     <li>
      创建一个队列，将起始节点加入队列；
     </li>
     <li>
      创建一个集合，用于存储已经访问过的节点；
     </li>
     <li>
      从队列中取出一个节点，并将其标记为已访问；
     </li>
     <li>
      访问该节点的所有相邻节点，如果相邻节点未被访问，则将其加入队列；
     </li>
     <li>
      重复步骤3和步骤4，直到队列为空。
     </li>
    </ol>
    <p>
     BFS算法可以用来解决一些问题，例如
     <strong>
      图的遍历、最短路径搜索
     </strong>
     等。由于BFS算法保证了按照距离顺序遍历节点，因此可以用来寻找最短路径。另外，BFS算法还可以用来
     <strong>
      判断图是否连通
     </strong>
     ，即从一个节点是否可以到达另一个节点。
    </p>
    <hr/>
    <h3>
     图解算法：
    </h3>
    <p>
     下面放一张我们学校ACM在大一培训时使用的一张动态BFS/DFS步骤图。注：红色遍历为BFS、黄色遍历为DFS。（绿色为起点，紫色为终点，黑色为障碍物）
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2edfa08bd24b4d718088b53490b6bccb.gif"/>
    </p>
    <p>
     由上图中我们可以看出，BFS的遍历为
     <strong>
      四周扩散
     </strong>
     ，用我们学长的话说就是周围每个点都尝试一下，无脑走，直到找到终点。由此我们可以看出来，BFS这种无脑走必定会导致时间复杂度非常高，如果终点离起点非常远，那么几乎每个点都要遍历一下，这样的话BFS这种算法就不适合了，BFS适合于点少的图，求最短距离之类的。BFS一般通过队列来实现。
    </p>
    <p>
     下面我们将以5*5的网格，考虑{上、右上、右、右下、下、左下、左、左上}八个方向，遍历顺序为{上、右上、右、右下、下、左下、左、左上}由上开始顺时针方向，顺序可按照自己的想法，顺序不一定固定，给大家模拟实现一下过程。
    </p>
    <p>
     <strong>
      注
     </strong>
     ：为方便表示，对于下面的叫法特此说明，起点.上表示起点上面的格子，起点.上右表示起点右上方的格子，其他方向类似，起点.上.上右表示起点的上面格子的右上方格子。
    </p>
    <h5>
     第一步：
    </h5>
    <p>
     初始起点入队，标记起点vis[起点]==true，说明起点已经被访问了，判断起点是否为终点，起点出队，很明显不是那么从起点周围按照{上、右上、右、右下、下、左下、左、左上}的顺序八个方向遍历每一个格子，将它们一一入队，并且将它们标记为已经访问过了，即vis[八个方向]=true。
    </p>
    <p>
     <img alt="" height="431" src="https://i-blog.csdnimg.cn/direct/090a5f054bb44e1ea6d8e49241c5d7a2.png" width="1124"/>
    </p>
    <h5>
     第二步：
    </h5>
    <p>
     由于我们第一步按照{上、右上、右、右下、下、左下、左、左上}的顺序入队的，此时队中的顺序是起点的{上、右上、右、右下、下、左下、左、左上}方向，那么此时出队的第一个是{上}方向，我们去遍历{上}方向的八个方向，由于{上}方向的八个方向中{上、右上、左上}三个方向下标越界，其他的都已经被访问过了，不合法，直接continue忽略掉，{上}方向遍历完成，{上}方向出队。
    </p>
    <p>
     <img alt="" height="429" src="https://i-blog.csdnimg.cn/direct/2a3c45229fea4e279e88e754ed5cf3f1.png" width="1120"/>
    </p>
    <h5>
     第三步：
    </h5>
    <p>
     此时要出队的为{上右}方向，先标记{上右}方向，然后遍历{上右}方向的八个方向，我们发现只有{上右}方向的{右}方向跟{下右}方向是合法的，其他的方向要么下标越界，要么已经被访问了，那么把{上右}方向的{右}方向跟{上右}方向的{下右}方向入队，并且标记它们的vis为true。
    </p>
    <p class="img-center">
     <img alt="" height="431" src="https://i-blog.csdnimg.cn/direct/da33ac643bac4256a129ebbee7eff018.png" width="1127"/>
    </p>
    <h5>
     第四步：
    </h5>
    <p>
     此时队头的为起点的{右}方向，将它出队，判断它不是终点，那么遍历它的八个方向，发现只有它的{右下}方向是合法的，其他方向都已经被标记过了。那么将vis[右下]标记为true，将它的右下方向入队。
    </p>
    <p class="img-center">
     <img alt="" height="430" src="https://i-blog.csdnimg.cn/direct/7574ce1b89f74843ad6c0410ca83fe59.png" width="1134"/>
    </p>
    <h5>
     第五步：
    </h5>
    <p>
     此时队头的为起点的{下右}方向，将它出队，判断它不是终点，那么遍历它的八个方向，发现它的{右下、下、左下}方向是合法的，其他方向都已经被标记过了。那么将vis[右下、下、左下]标记为true，并且将其入队。此时我们发现它的右下方向是终点了，已经在栈队当中，再经过八次出队，那么就是这个出队的点就是终点了，判断完成后此时BFS搜索就结束了，由于下面都是相同的出队入队步骤，下面不再详解。
    </p>
    <p class="img-center">
     <img alt="" height="471" src="https://i-blog.csdnimg.cn/direct/e1461899e6fc42618417114be63d3049.png" width="1121"/>
    </p>
    <hr/>
    <h3>
     算法模板：
    </h3>
    <p>
     首先我们需要一个队列来辅助BFS实现，还需要一个初始化的输入数组，还有一个标记数组。先找到BFS的起点跟终点，确定好之后，先把起点vis==true，把起点入队，然后进入BFS函数，进入BFS函数一般先是一个大while循环，来管理队列的入队、出队。由于点都是二维的，我们一般都是用pair或者结构体来表示点，新建一个点来存储队头的信息，存完就可以让队头出队了。然后判断是否到达了目标结点，一个if判断，下面就是跟dfs一样，一个for循环遍历周围所有的点，不合法的直接continue掉，合法的标记完vis后入队，有的题目会有回溯，像在部分最短路搜索。
    </p>
    <pre><code class="language-cpp">queue&lt;node&gt; q;
void bfs(){
	while(!q.empty()){
		node tmp=q.top();//node为(x,y)结构体
		q.pop();//出队
		if(到达目标终点){
			更新
			return;
		}
		//有的会有剪枝
		for(int i=0;i&lt;m;i++){//m个方向
			int dx=tmp.x+bx[i];
			int dy=tmp.y+by[i];
			if(下标越界){
				continue;
			}
			if(已经被标记过了){
				continue;
			}
			//否则就是合法的
			vis[dx][dy]=1;//先标记
			q.push(node{dx,dy});//再新点入队
		}
	}
}</code></pre>
    <hr/>
    <h3>
     算法例题：
    </h3>
    <p>
     现在各大算法刷题网站上bfs题目非常的多，bfs题目的变化也比较多，现在各种各样的题目层出不穷，bfs考察的还是主要分为图的
     <strong>
      遍历问题、最短路问题、连通块搜索
     </strong>
     等，下面博主选取几个比较具有代表性的给大家讲解一下，加深理解一下bfs算法。
    </p>
    <hr/>
    <h4>
     一、图的遍历问题
    </h4>
    <h5>
     迷宫问题
    </h5>
    <h6>
     【题目描述】
    </h6>
    <p>
     一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由n×n的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。同时当Extense处在某个格点时，他只能移动到东南西北（或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷官的情况下能不能办到。如果起点或者终点有一个不能通行（为#），则看成无法办到。
    </p>
    <h6>
     【输入】
    </h6>
    <p>
     第1行是测试数据的组数k，后面跟着k组输入。每组测试数据的第1行是一个正整数n(1≤n≤ 100)，表示迷宫的规模是n×n的。接下来是一个n×n的矩阵，矩阵中的元素为.或者#。再接下来一行是4个整数ha,la,hb,lb，描述A处在第ha行，第la列，B处在第hb行，第lb列。注意到ha，la，hb，lb全部是从0开始计数的。
    </p>
    <h6>
     【输出】
    </h6>
    <p>
     k行，每行对应一个输出，如果能到达则输出"YES"，否则输出"NO"。
    </p>
    <h6>
     【样例】
    </h6>
    <pre><code class="language-bash">2
3
.##
..#
#..
0 0 2 2
5
.....
###.#
..#..
###..
...#.
0 0 4 0

YES
NO</code></pre>
<h5>
解题思路：
</h5>
<p>
这类问题属于图的遍历问题，属于 BFS 题里面最简单的问题，直接利用 BFS 的思想遍历即可，判断是否能到达。之所以选这个题，是先让刚入门的小萌新熟悉一下 BFS 的步骤、思想。大佬可跳过此题。
</p>
<h5>
AC 代码：
</h5>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
int n,t;
char ch[105][105];
bool flag=false,vis[105][105];
int sx,sy,fx,fy;
int bx[]={0,0,1,-1},by[]={1,-1,0,0};//方向数组
struct node{
int x,y;
};
queue&lt;node&gt; q;//队列
void bfs(){
while(!q.empty()){
node tmp=q.front();//取队头元素
q.pop();//出队
if(tmp.x==fx&amp;&amp;tmp.y==fy){//目标状态
flag=true;
return;
}
for(int i=0;i&lt;4;i++){//周围四个方向搜索
int dx=tmp.x+bx[i],dy=tmp.y+by[i];
if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=n){//下标越界
continue;
}
if(vis[dx][dy]){//已经被访问过
continue;
}
if(ch[dx][dy]=='#'){//墙壁
continue;
}
vis[dx][dy]=1;//先标记
q.push(node{dx,dy});//再入队
}
}
}
int main(){
cin&gt;&gt;t;
while(t--){
cin&gt;&gt;n;
for(int i=0;i&lt;n;i++){
for(int j=0;j&lt;n;j++){
cin&gt;&gt;ch[i][j];
}
}
cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;
flag=false;
memset(vis,0,sizeof(vis));
while(!q.empty()){//多次输入，防止上次队列的影响
q.pop();
}
vis[sx][sy]=1;
q.push(node{sx,sy});//起点入队
bfs();
cout&lt;&lt;(flag?"YES":"NO")&lt;&lt;endl;
}
return 0;
}</code></pre>
<hr/>
<h4>
二、最短路问题
</h4>
<h5>
<a class="link-info" href="https://www.acwing.com/problem/content/1104/" rel="nofollow" title="AcWing 1102. 移动骑士">
AcWing 1102. 移动骑士
</a>
</h5>
<p>
给定一个  n∗n 的棋盘，以及一个开始位置和终点位置。
</p>
<p>
棋盘的横纵坐标范围都是  0∼n−1。
</p>
<p>
将一个国际象棋中的骑士放置在开始位置上，请问将它移动至终点位置至少需要走多少步。
</p>
<p>
一个骑士在棋盘上可行的移动方式如下图所示：
</p>
<p class="img-center">
<img alt="QQ截图20191016061524.png" height="290" src="https://i-blog.csdnimg.cn/blog_migrate/aecedeefe93ef82262badf90aef6b4ae.png" width="316"/>
</p>
<h6>
输入格式
</h6>
<p>
第一行包含整数  T，表示共有  T  组测试数据。
</p>
<p>
每组测试数据第一行包含整数  n，表示棋盘大小。
</p>
<p>
第二行包含两个整数  x,y 用来表示骑士的开始位置坐标  (x,y)。
</p>
<p>
第三行包含两个整数  x,y 用来表示骑士的终点位置坐标  (x,y)。
</p>
<h6>
输出格式
</h6>
<p>
每组数据输出一个整数，表示骑士所需移动的最少步数，每个结果占一行。
</p>
<h6>
数据范围
</h6>
<p>
4≤n≤300
<br/>
0≤x,y≤n−1
</p>
<h6>
输入样例：
</h6>
<pre><code>3
8
0 0
7 0
100
0 0
30 50
10
1 1
1 1
</code></pre>
<h6>
输出样例：
</h6>
<pre><code>5
28
0</code></pre>
<h5>
解题思路：
</h5>
<p>
这道题跟马走日那一题几乎是一样的，但是不一样的是这道题是求的最小步数。这就是最短路问题了。还是跟之前的 BFS 步骤一样，就是在目标状态那里多了一个更新最小步数。这道题比前面的图的遍历问题难一点点，
<strong>
注意
</strong>
，BFS 是不需要回溯的，否则会陷入死循环。
</p>
<h5>
AC 代码：
</h5>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;
int t,n;
int sx,sy,fx,fy;//(sx,sy)起点,(fx,fy)终点
struct node{//点结构体
int x;
int y;
int dep;//步数
}Node;
int dx[]={1,1,2,2,-1,-1,-2,-2};//方向数组
int dy[]={2,-2,1,-1,2,-2,1,-1};
bool vis[305][305];//标记数组
int sum=0x3f3f3f;//最小步数
queue&lt;node&gt; q;

void bfs(){
while(!q.empty()){
auto tmp=q.front();
q.pop();
if(tmp.x==fx&amp;&amp;tmp.y==fy){//目标状态更新最小步数
sum=min(sum,tmp.dep);
return;
}
for(int i=0;i&lt;8;i++){//八个方向遍历
Node.x=tmp.x+dx[i];
Node.y=tmp.y+dy[i];
if(Node.x&lt;0||Node.y&lt;0||Node.x&gt;=n||Node.y&gt;=n){//下标越界
continue;
}
if(vis[Node.x][Node.y]==1){//已经被访问过
continue;
}
Node.dep=tmp.dep+1;//步数更新
vis[Node.x][Node.y]=1;//先标记
q.push(Node);//再入队
}
}
}

int main(){
cin&gt;&gt;t;
while(t--){
memset(vis,false,sizeof(vis));//多组输入置 0
sum=0x3f3f3f;//初始最大值
cin&gt;&gt;n&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;
vis[sx][sy]=1;//先标记起点
while(!q.empty()){//清空队列
q.pop();
}
q.push(node{sx,sy,0});//起点步数为 0
bfs();
cout&lt;&lt;sum&lt;&lt;endl;
}
return 0;
}</code></pre>
<hr/>
<h5>
<a class="link-info" href="https://www.luogu.com.cn/problem/P1379" rel="nofollow" title="洛谷 P1379 八数码难题">
洛谷  P1379 八数码难题
</a>
</h5>
<h6>
题目描述
</h6>
<p>
在  3×3  的棋盘上，摆有八个棋子，每个棋子上标有  1  至  8  的某一数字。棋盘中留有一个空格，空格用  0  来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为 123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。
</p>
<h6>
输入格式
</h6>
<p>
输入初始状态，一行九个数字，空格用  0  表示。
</p>
<h6>
输出格式
</h6>
<p>
只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数。保证测试数据中无特殊无法到达目标状态数据。
</p>
<p>
<strong>
输入
</strong>
</p>
<pre>283104765

</pre>
    <p>
     <strong>
      输出
     </strong>
    </p>
    <pre>4
</pre>
    <h6>
     样例解释
    </h6>
    <p class="img-center">
     <img alt="" height="196" src="https://i-blog.csdnimg.cn/blog_migrate/0dc93d89cf1932d350334142054c0ac5.png" width="938"/>
    </p>
    <p>
     图中标有 0 的是空格。绿色格子是空格所在位置，橙色格子是下一步可以移动到空格的位置。如图所示，用四步可以达到目标状态。并且可以证明，不存在更优的策略。
    </p>
    <h5>
     解题思路：
    </h5>
    <p>
     这道题在博主做题的感觉来说，题目质量是非常高的，思维也非常有高度，建议大家好好学一下。八数码非常类似于中国的数独游戏。在解决此题时一个布局对应一个字符串也就是一个状态，可以理解为一个布局转换为目标布局所需要的最小步数。
    </p>
    <p>
     下面讲解一下如何解决此题，我们发现每一个字符串就是一个状态，最短距离还需要记录步数，那么我们就想到了
     <strong>
      map键值映射
     </strong>
     ，由一个字符串对应初始状态到此状态的
     <strong>
      最小步数
     </strong>
     。例如：d["123048567"]=2表示由初始状态到目标状态最小步数为2步完成。其次是‘0’字符
     <strong>
      一维下标跟二维下标位置转换的技巧
     </strong>
     ，我们发现每一次都是‘0’字符（空格）与四个方向的数字进行交换，属于空格的BFS，对于一维下标可以通过除3为横坐标，模3为纵坐标（3*3棋盘），由二维转为一维坐标倒过来即可，即：3*横坐标+纵坐标。刚开始可以使用find()函数查找‘0’字符的下标，然后转化为布局中的二维坐标。每完成一步就要交换格子，交换完成就得到一种新的布局，那么我们可以用count()函数去map里面查找，如果有这种状态说明之前用更小的步数就已经到达过了，没必要更新了。如果没有这种状态，那么我们就为它赋值最小步数。最后还要还原，对于这个题来说是必要的，因为四个方向搜索都是以‘0’为基础的，for循环一次把他改变了，后面的3次循环就在它前一个状态的基础上。这样交换操作就乱了。
    </p>
    <p>
     <strong>
      视频讲解：
     </strong>
     请看B站up主董晓算法，—&gt;&gt;
     <a class="link-info" href="https://www.bilibili.com/video/BV1oa41157eB/?spm_id_from=333.999.0.0&amp;vd_source=fb68acc8676366210b38465a4a61ff28" rel="nofollow" title="点击直达">
      点击直达
     </a>
     &lt;&lt;—，博主感觉董晓老师讲的非常好，本题思路按照董晓老师讲解来写的。大家可以去看看，下面第二张图片来自董晓老师讲解。
    </p>
    <p style="text-align:center;">
     <img alt="" class="left" src="https://i-blog.csdnimg.cn/direct/938235c7ca8c49fb9c4a66984cf23da7.png"/>
     <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/af7060f95afb4a5781477c93e61d583d.png" width="355"/>
    </p>
    <h5>
     AC代码：
    </h5>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;unordered_map&gt;

using namespace std;

int dx[]={-1,0,1,0},dy[]={0,1,0,-1};//方向数组
unordered_map&lt;string,int&gt; d;//考虑 map 键值对映射,状态映射步数
queue&lt;string&gt; q;//棋盘状态布局

int bfs(string strat){
string end="123804765";//目标状态
q.push(strat);//初始状态
d[strat]=0;
while(q.size()){
auto s=q.front();
q.pop();
if(s==end){//目标状态
return d[s];
}
int k=s.find('0');//下标位置转化
int x=k/3;
int y=k%3;
for(int i=0;i&lt;4;i++){//四个方向搜索
int a=x+dx[i];
int b=y+dy[i];
if(a&lt;0||a&gt;=3||b&lt;0||b&gt;=3){//下标越界
continue;
}
int distance=d[s];//记录步数
swap(s[k],s[3*a+b]);//交换
if(!d.count(s)){//新的布局
d[s]=distance+1;
q.push(s);
}
swap(s[k],s[3*a+b]);//还原
}
}
return -1;//无法到达
}

int main(){
string strat;
for(int i=0;i&lt;9;i++){
char ch;
cin&gt;&gt;ch;
strat+=ch;
}
cout&lt;&lt;bfs(strat)&lt;&lt;endl;
return 0;
}</code></pre>
<hr/>
<h4>
三、连通块问题
</h4>
<h5 id="articleContentId">
第十四届省赛大学 B 组（C/C++）岛屿个数
</h5>
<p>
到目前为止我做过像连通块问题的题用 BFS 解的就这一个比较好，这一道题跟连通块有结合，博主才把它归到了连通块问题来。具体的讲解跟 AC 代码，请看我这一篇文章，文章单独讲解了这一道题，由于文章长度限制这里不再详解，请移步下面链接。
</p>
<p>
<a class="has-card" href="https://blog.csdn.net/m0_73633807/article/details/137248445?spm=1001.2014.3001.5501" title="第十四届省赛大学B组（C/C++）岛屿个数-CSDN博客">
<span class="link-card-box">
<span class="link-title">
第十四届省赛大学 B 组（C/C++）岛屿个数-CSDN 博客
</span>
<span class="link-desc">
文章浏览阅读 1.1k 次，点赞 30 次，收藏 14 次。这不是普通的 DFS/BFS 搜索题，看着很像最少连通块，但是题目中又有了新的定义就是在陆地环里面（被陆地包围）也算属于此外围岛屿，那么我们就也要判定这种环岛屿，博主的思路是先 BFS 也可 DFS 找出连通块的个数（四个方向），建一个 vector 把连通块的起点存进去，方便去找环岛屿，只要有一个起点（或者此连通块任意一个点），此连通块的点便可通过移动一网打尽，再 BFS（或者 DFS）判定该岛屿是否属于这种环岛屿，不属于就结果加一，属于就不用加。对于 100% 的评测用例，1≤T≤10，1≤M,N≤50。
</span>
<span class="link-link">
<img alt="" class="link-link-icon" src="https://i-blog.csdnimg.cn/blog_migrate/be19846480ab44ce477585fc567aeaa0.png"/>
https://blog.csdn.net/m0_73633807/article/details/137248445?spm=1001.2014.3001.5501
</span>
</span>
</a>
</p>
<hr/>
<p>
图形搜索算法还有一种是 DFS，请看博主上一篇文章
<a class="link-info" href="https://blog.csdn.net/m0_73633807/article/details/141037673?spm=1001.2014.3001.5501" title="数据结构与算法——DFS(深度优先搜索)">
数据结构与算法——DFS(深度优先搜索)
</a>
</p>
<p>
制作不易，如果对你有所帮助请三连支持博主持续创作，感谢各位大佬的支持。
</p>

   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333633333830372f:61727469636c652f64657461696c732f313431313632313833" class_="artid" style="display:none">
 </p>
</div>
