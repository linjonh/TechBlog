---
layout: post
title: "Java面试题整理一反射"
date: 2024-12-27 19:05:02 +0800
description: "简述Java中的反射1.作用：可以通过配置文件来动态配置和加载类，以实现软件工程理论里所提及的类与类"
keywords: "java反射面试题"
categories: ['未分类']
tags: ['面试题', 'Java']
artid: "53258551"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=53258551
  alt: "Java面试题整理一反射"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java面试题整理一（反射）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="font-size:18px">
      问题：简述Java中的反射使用
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      答：
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      1.作用：
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      <strong>
       可以通过配置文件来动态配置和加载类
      </strong>
      ，以实现
      <strong>
       软件工程理论
      </strong>
      里所提及的类与类，模块与模块之间的
      <strong>
       解耦
      </strong>
      。反射最经典的应用是spring框架。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      2. 定义
      <br/>
      反射简单来说，就是动态加载对象，并对对象进行剖析。在Java中的反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;
      <br/>
      <br/>
      对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制
     </span>
     <br/>
    </p>
    <p>
     <span style="font-size:18px">
      <br/>
      <span style="white-space:pre">
      </span>
      2.1 动态性质
      <br/>
      <span style="white-space:pre">
      </span>
      运行时生成对象实例;
      <br/>
      <span style="white-space:pre">
      </span>
      运行期间调用方法；
      <br/>
      <span style="white-space:pre">
      </span>
      运行时更改属性
      <br/>
      <span style="white-space:pre">
      </span>
      2.2 Java反射机制能实现的功能
      <br/>
      <span style="white-space:pre">
      </span>
      在运行时判断任意一个对象所属的类
      <br/>
      <span style="white-space:pre">
      </span>
      在运行时构造任意一个类的对象
      <br/>
      <span style="white-space:pre">
      </span>
      在运行时判断任意一个类所具有的方法和属性
      <br/>
      <span style="white-space:pre">
      </span>
      在运行时调用任意一个对象的方法
      <br/>
      <span style="white-space:pre">
      </span>
      生成动态代理
      <br/>
      <span style="white-space:pre">
      </span>
      2.3 Java反射应用场合
      <br/>
      <span style="white-space:pre">
      </span>
      在Java程序中许多对象在运行时都会出现两种类型：
      <strong>
       编译时类型
      </strong>
      和
      <strong>
       运行时类型
      </strong>
      <br/>
      <span style="white-space:pre">
      </span>
      编译时的类型由声明该对象时使用的类型决定，运行时的类型由实际赋给对象的类型决定
      <br/>
      <span style="white-space:pre">
      </span>
      如：Person p =new Student();
      <br/>
      <span style="white-space:pre">
      </span>
      编译时类型为Person，而运行时为Student
      <br/>
      <br/>
      <span style="white-space:pre">
      </span>
      除此之外，程序在运行时还可能接收到外部传入的一个对象，该对象的编译时类型为Object，但程序又需要调用该对象运行时类型的方法。为了这些问题程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，此时就
      <strong>
       <span style="color:#ff0000">
        必须
       </span>
      </strong>
      使用反射
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      3. JAVA反射API
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      <span style="white-space:pre">
      </span>
      反射API用来生成在当前JAVA虚拟机中的类、接口或者对象的信息。
      <br/>
      <span style="white-space:pre">
      </span>
      Class类:反射的核心类，可以获取类的属性，方法等内容信息。
      <br/>
      <span style="white-space:pre">
      </span>
      Field类:Java.lang.reflect.表示类的属性，可以获取和设置类的中属性值。
      <br/>
      <span style="white-space:pre">
      </span>
      Method类:Java.lang.reflect。表示类的方法，它可以用来获取类中方法的信息或者执行方法
      <br/>
      <span style="white-space:pre">
      </span>
      Construcor类:Java.lang.reflect。表示类的构造方法。
      <br/>
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      下面举例示意：
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      第一种方式通过类的全路径来实现
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      新建一个待反射的Person类
     </span>
    </p>
    <p>
     <span style="font-size:18px">
     </span>
    </p>
    <pre><code class="language-java">package com.test.Reflect;

public class Person {
private String name;
private String gender;
private int age;

    private Person() {
    //
    }
    public Person(String name, String gender, int age) {
        super();
        this.name = name;
        this.gender = gender;
        this.age = age;
    }
    //getter、和setter方法
    private String getName() {
        return name;
    }
    private void setName(String name) {
        this.name = name;
    }
    public String getGender() {
        return gender;
    }
    public void setGender(String gender) {
        this.gender = gender;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }

    public String toString(){
        return "姓名："+name+"年龄: "+age;
    }

}
</code></pre>
<p>
</p>
<p>
<span style="font-size:18px">
<br/>
</span>
</p>
第一个 Demo 查询类的信息并输出
<p>
<span style="font-size:18px">
</span>
</p>
<pre><code class="language-java">package com.test.Reflect;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import javax.swing.JOptionPane;

/\*\*

- 通过用户输入类的全路径，来获取该类的成员方法和属性
- Declared 获取全部不管是私有和公有
- 1.获取访问类的 Class 对象
- 2.调用 Class 对象的方法返回访问类的方法和属性信息
  \*\*/

public class ReflectDemo1 {

    /*
     * 构造方法
     */
    public ReflectDemo1(){
        //用户输入类的全路径径
        //使用String组件
        String classpsth=JOptionPane.showInputDialog(null,"输入类的全路径");
        //使用Class.forName方法根据输入的类的全路径 返回该类的Class对象
        try {
            Class cla = Class.forName(classpsth);
            //利用Class对象的cla的自审,返回方法对象集合
            Method [] method=cla.getDeclaredMethods(); //返回所有的方法
            System.out.println("========获取方法信息============");
            for (Method meth : method) {
                //遍历method数组，并输出方法信息
                System.out.println(meth.toString());
            }
            System.out.println("========获取出方法信息结束============");
            //获取属性利用Class对象的cla的自审,返回成员属性对象集合
             Field [] field=cla.getDeclaredFields();
                System.out.println("========获取成员属性信息============");
                for (Field f : field) {
                    System.out.println(f.toString());
                }
                System.out.println("========获取成员属性信息结束============");
            //获取属性利用Class对象的cla的自审,返回构造方法集合
                Constructor [] constructor=cla.getDeclaredConstructors();
                System.out.println("========获取成员构造方法信息============");
                for (Constructor constru : constructor) {
                    System.out.println(constru.toString());
                }
                System.out.println("========获取成员构造方法信息结束============");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            System.out.println("路径输入错误！");
        }
    }

}
</code></pre>
<br/>
最后是测试类
<p>
</p>
<p>
<span style="font-size:18px">
</span>
</p>
<pre><code class="language-java">package com.test.Reflect;
/\*\*

- 测试类
- @author Admin
- \*/
  public class TestReflection {
  public static void main(String[] args) {
  ReflectDemo1 rd=new ReflectDemo1();

      }

  }
  </code></pre>
  <br/>
  执行后会有一个简单的弹窗用来输入类的全路径：com.test.Reflect.Person
  <p>
  </p>
  <p>
  <span style="font-size:18px">
  输出结果为：
  <br/>
  ========获取方法信息============
  <br/>
  public java.lang.String com.test.Reflect.Person.toString()
  <br/>
  private java.lang.String com.test.Reflect.Person.getName()
  <br/>
  private void com.test.Reflect.Person.setName(java.lang.String)
  <br/>
  public java.lang.String com.test.Reflect.Person.getGender()
  <br/>
  public void com.test.Reflect.Person.setGender(java.lang.String)
  <br/>
  public void com.test.Reflect.Person.setAge(int)
  <br/>
  public int com.test.Reflect.Person.getAge()
  <br/>
  ========获取出方法信息结束============
  <br/>
  ========获取成员属性信息============
  <br/>
  private java.lang.String com.test.Reflect.Person.name
  <br/>
  private java.lang.String com.test.Reflect.Person.gender
  <br/>
  private int com.test.Reflect.Person.age
  <br/>
  ========获取成员属性信息结束============
  <br/>
  ========获取成员构造方法信息============
  <br/>
  private com.test.Reflect.Person()
  <br/>
  public com.test.Reflect.Person(java.lang.String,java.lang.String,int)
  <br/>
  ========获取成员构造方法信息结束============
  <br/>
  </span>
  </p>
  <p>
  <span style="font-size:18px">
  第二种方式 对象的 getClass()
  </span>
  </p>
  <p>
  <span style="font-size:18px">
  首先还是用上面的 Person 类，只不过把构造函数的属性修改为 default
  </span>
  </p>
  <p>
  <span style="font-size:18px">
  </span>
  </p>
  <pre><code class="language-java">public class Person {
  private String name;
  private String gender;
  private int age;

      Person() {
      //
      }
      public Person(String name, String gender, int age) {
          super();
          this.name = name;
          this.gender = gender;
          this.age = age;
      }
      //getter、和setter方法
      private String getName() {
          return name;
      }
      private void setName(String name) {
          this.name = name;
      }
      public String getGender() {
          return gender;
      }
      public void setGender(String gender) {
          this.gender = gender;
      }
      public int getAge() {
          return age;
      }
      public void setAge(int age) {
          this.age = age;
      }

      public String toString(){
          return "姓名："+name+"年龄: "+age;
      }</code></pre>
      <br/>
      <p>
      </p>
      <p>
       <span style="font-size:18px">
        ReflectDemo类基本上不变，只是cla的传值方式变了，改成
       </span>
       <span style="font-size:18px">
        Class cla=p.getClass();
       </span>
      </p>
      <p>
       <span style="font-size:18px">
       </span>
      </p>
      <pre><code class="language-java">public ReflectDemo2(Person p){
              Class cla=p.getClass();
              //利用Class对象的cla的自审,返回方法对象集合
              Method [] method=cla.getDeclaredMethods(); //返回所有的方法
              System.out.println("========获取方法信息============");
              for (Method meth : method) {
                  //遍历method数组，并输出方法信息
                  System.out.println(meth.toString());
              }
              System.out.println("========获取出方法信息结束============");
              //获取属性利用Class对象的cla的自审,返回成员属性对象集合
               Field [] field=cla.getDeclaredFields();
                  System.out.println("========获取成员属性信息============");
                  for (Field f : field) {
                      System.out.println(f.toString());
                  }
                  System.out.println("========获取成员属性信息结束============");
              //获取属性利用Class对象的cla的自审,返回构造方法集合
                  Constructor [] constructor=cla.getDeclaredConstructors();
                  System.out.println("========获取成员构造方法信息============");
                  for (Constructor constru : constructor) {
                      System.out.println(constru.toString());
                  }
                  System.out.println("========获取成员构造方法信息结束============");
          }</code></pre>
      <br/>
      测试类如下：
      <pre><code class="language-java">public class TestReflection {
      public static void main(String[] args) {

  // ReflectDemo1 rd=new ReflectDemo1();
  Person person = new Person();
  ReflectDemo2 reflectDemo2 = new ReflectDemo2(person);
  }
  }</code></pre>
  结果跟上面的输出结果一样
  <p>
  </p>
  <p>
  <span style="font-size:18px">
  ========获取方法信息============
  <br/>
  public java.lang.String com.test.Reflect.Person.toString()
  <br/>
  private java.lang.String com.test.Reflect.Person.getName()
  <br/>
  private void com.test.Reflect.Person.setName(java.lang.String)
  <br/>
  public java.lang.String com.test.Reflect.Person.getGender()
  <br/>
  public void com.test.Reflect.Person.setGender(java.lang.String)
  <br/>
  public int com.test.Reflect.Person.getAge()
  <br/>
  public void com.test.Reflect.Person.setAge(int)
  <br/>
  ========获取出方法信息结束============
  <br/>
  ========获取成员属性信息============
  <br/>
  private java.lang.String com.test.Reflect.Person.name
  <br/>
  private java.lang.String com.test.Reflect.Person.gender
  <br/>
  private int com.test.Reflect.Person.age
  <br/>
  ========获取成员属性信息结束============
  <br/>
  ========获取成员构造方法信息============
  <br/>
  com.test.Reflect.Person()
  <br/>
  public com.test.Reflect.Person(java.lang.String,java.lang.String,int)
  <br/>
  ========获取成员构造方法信息结束============
  <br/>
  </span>
  </p>
  <p>
  <span style="font-size:18px">
  第三种方式就是直接使用.class 属性
  </span>
  </p>
  <p>
  <span style="font-size:18px">
  只需要直接将类名.class 赋值给 Class cla,就可以继续向上面一样输出类的信息了。这里就不赘述了。
  </span>
  </p>
  <p>
  <span style="font-size:18px">
  </span>
  </p>
  <pre style='margin-top:0px; margin-bottom:0px; padding:0px; white-space:pre-wrap; word-wrap:break-word; line-height:18px; font-family:"Courier New"!important'><span style="margin:0px; padding:0px; line-height:1.5">Class cla</span>=Person.<span style="margin:0px; padding:0px; line-height:1.5; color:rgb(0,0,255)">class</span><span style="margin:0px; padding:0px; line-height:1.5">;</span></pre>
  <br/>
  <p>
  </p>
  <p>
  <span style="font-size:18px">
  毕竟会使用只是最简单的要求，理解其使用的环境才会是自己可以灵活的使用。之后如果有更深的体会再进行补充。
  </span>
  </p>
     </div>
    </div>
   </article>
   <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6d61697a6931303435:2f61727469636c652f64657461696c732f3533323538353531" class_="artid" style="display:none">
   </p>
  </div>
