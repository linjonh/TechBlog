---
title: 2023-12-28-操作系统原理复习1.2万字,全面覆盖
date: 2023-12-28 20:23:50 +0800
categories: ['未分类']
tags: [linux,windows,笔记]
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=135214640
  alt: 操作系统原理复习1.2万字,全面覆盖
artid: 135214640
render_with_liquid: false
---
</p>
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统原理复习（1.2万字，全面覆盖）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     第一章、操作系统概述
    </h2>
    <ul>
     <li>
      <strong>
       操作系统的特性
      </strong>
      ：
      <strong>
       并发性
      </strong>
      （
      <span style="color:#000000;">
       同时处理多个任务的能力
      </span>
      ），
      <span style="color:#000000;">
       <strong>
        共享性
       </strong>
       （为多个并发任务提供资源共享），
       <strong>
        不确定性
       </strong>
       （具有处理随机事件的能力）。
      </span>
     </li>
     <li>
      <strong>
       操作系统功能
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#6eaad7;">
       进程管理
      </span>
      <strong>
       ：
      </strong>
      处理机分配，处理机管理，CPU管理。具体为进程控制（
      <span style="color:#000000;">
       创建，暂停，唤醒，撤销
      </span>
      ），进程调度（调度策略，优先级），进程通信（进程间通信）。
     </li>
     <li>
      <span style="color:#6eaad7;">
       存储管理/内存管理
      </span>
      ：
      <span style="color:#000000;">
       为应用程序运行分配和管理所需的内存，支持多道程序设计。具体为内存分配，内存共享，内存保护，内存扩充，虚拟内存。
      </span>
     </li>
     <li>
      <span style="color:#6eaad7;">
       设备管理
      </span>
      ：设备的分配和回收，设备的驱动机制/传输机制，为应用提供统一接口访问设备，高效存取/设备缓冲机制。
     </li>
     <li>
      <span style="color:#6eaad7;">
       文件管理
      </span>
      ：为用户提供统一的文件存取接口，高效组织存储空间，提高存取效率，实现信息共享和存取控制。具体为文件用户接口，存储空间管理，文件的操作，目录的操作，存取权限管理。
      <strong>
       文件是设备的抽象
      </strong>
      。
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       操作系统性能/评价指标
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#6eaad7;">
       吞吐率
      </span>
      ：在单位时间内处理信息的能力。
     </li>
     <li>
      <span style="color:#6eaad7;">
       资源利用率
      </span>
      ：设备（CPU）使用的频度。
     </li>
     <li>
      <span style="color:#6eaad7;">
       响应能力
      </span>
      ：从接受数据到输出结果的时间间隔。
     </li>
     <li>
      <span style="color:#6eaad7;">
       可移植性
      </span>
      ：改变硬件环境仍能正常工作的能力，即代码修改量。
     </li>
     <li>
      <span style="color:#6eaad7;">
       可靠性
      </span>
      ：发现、诊断和恢复系统故障的能力。
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       操作系统发展的四个典型阶段
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      手工操作系统（40年代-50年代初）
     </li>
     <li>
      单道批处理系统（50年代）
     </li>
     <li>
      多道批处理系统（60年代初）
     </li>
     <li>
      分时操作系统（60年代-至今）
     </li>
    </ol>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_42192693/article/details/111083732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170355897416800192280132%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170355897416800192280132&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111083732-null-null.142%5Ev96%5Epc_search_result_base2&amp;utm_term=%E5%A4%9A%E6%89%B9%E9%81%93%E5%A4%84%E7%90%86&amp;spm=1018.2226.3001.4187" title="操作系统：操作系统引论">
       操作系统：操作系统引论
      </a>
      详细讲述了单道批处理系统，多道批处理系统和分时操作系统。
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_43606914/article/details/105836815" title="单道批处理系统，多道批处理系统，分时系统比较">
       单道批处理系统，多道批处理系统，分时系统比较
      </a>
     </li>
     <li>
      <strong>
       多道批处理系统和分时系统的比较
      </strong>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="438" src="https://i-blog.csdnimg.cn/blog_migrate/d34bb59efc250751018496c5f9f589b6.png" width="673"/>
    </p>
    <ul>
     <li>
      茶余饭后：
      <a class="link-info" href="https://zhuanlan.zhihu.com/p/624171208" rel="nofollow" title="计算机与云计算发展编年史 1725-2023">
       计算机与云计算发展编年史 1725-2023
      </a>
     </li>
     <li>
      <strong>
       操作系统的逻辑结构
      </strong>
      （OS的设计和实现思路）
     </li>
    </ul>
    <ol>
     <li>
      整体式结构
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#000000;">
       单体式结构，宏内核结构)：以
      </span>
      <span style="color:#0000ff;">
       模块
      </span>
      <span style="color:#000000;">
       为基本单位构建，每个模块具有特定的功能
      </span>
      <img alt="" height="858" src="https://i-blog.csdnimg.cn/blog_migrate/943ff966a5f181f7f5eaa09957d18ef2.png" width="1200"/>
     </li>
     <li>
      层次式结构：
      <span style="color:#000000;">
       功能模块按
      </span>
      <span style="color:#ff3300;">
       调用次序
      </span>
      <span style="color:#000000;">
       排若干层，各层
      </span>
      <span style="color:#ff3300;">
       单向
      </span>
      <span style="color:#000000;">
       依赖或
      </span>
      <span style="color:#ff3300;">
       单向
      </span>
      <span style="color:#000000;">
       调用。
      </span>
      <img alt="" height="777" src="https://i-blog.csdnimg.cn/blog_migrate/156b6dd5cc4fe14e1ae6a7649b01799e.png" width="1200"/>
     </li>
     <li>
      微内核结构（客户/服务器结构）：操作系统=微内核+核外服务器
     </li>
     <li>
      <img alt="" height="852" src="https://i-blog.csdnimg.cn/blog_migrate/a96effcd882746ea2b8a3e48c2007e4c.png" width="1200">
       <p class="img-center">
        <img alt="" height="344" src="https://i-blog.csdnimg.cn/blog_migrate/3598146c6e6c7e0dcff268ad3902ef01.png" width="336"/>
       </p>
       <img alt="" height="872" src="https://i-blog.csdnimg.cn/blog_migrate/84cecdaa4c2878cbf1a2f6ce1fa6cd6e.png" width="1200"/>
      </img>
     </li>
    </ol>
    <h2>
     第二章、
     <span style="color:#000000;">
      操作系统依赖的基础硬件
     </span>
    </h2>
    <ul>
     <li>
      <strong>
       计算机主要部件
      </strong>
      ：CPU，内设，外设
     </li>
     <li>
      <strong>
       三总线
      </strong>
      ：地址总线，数据总线，控制总线
     </li>
     <li>
      <strong>
       CPU结构
      </strong>
      ：控制单元，运算单元，寄存器组
     </li>
    </ul>
    <p>
     <img alt="" height="846" src="https://i-blog.csdnimg.cn/blog_migrate/8e345f70590da296cdf83d5c3dd3af4d.png" width="1200"/>
    </p>
    <ul>
     <li>
      <strong>
       CPU的态
      </strong>
      （CPU的工作模式，
      <span style="color:#000000;">
       对资源和指令使用权限的描述
      </span>
      ）：
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#ff0000;">
       核态
      </span>
      <span style="color:#000000;">
       (Kernel mode)：能够访问所有资源和执行指令，管理程序/OS内核
      </span>
     </li>
     <li>
      <span style="color:#ff0000;">
       用户态
      </span>
      <span style="color:#000000;">
       (User mode,
      </span>
      <span style="color:#0000ff;">
       目态
      </span>
      <span style="color:#000000;">
       )：仅能访问部分资源，其他资源受限
      </span>
     </li>
     <li>
      <div>
       <span style="color:#ff0000;">
        管态
       </span>
       <span style="color:#000000;">
        (Supervisor mode)：介于核态和用户态之间
       </span>
      </div>
     </li>
    </ol>
    <div>
     <p class="img-center">
      <img alt="" height="329" src="https://i-blog.csdnimg.cn/blog_migrate/b7a5b3d4404c5c5d8c288e2965a6fc57.png" width="555"/>
     </p>
    </div>
    <div>
    </div>
    <ul>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         操作系统依赖的最基本硬件
        </strong>
        ：CPU，内存，中断，时钟。
       </span>
      </div>
     </li>
     <li>
      <div>
       <strong>
        存储体系
       </strong>
       ：寄存器，高速缓存（cashe），主存，磁盘。
       <img alt="" height="531" src="https://i-blog.csdnimg.cn/blog_migrate/f3553a08f5cc1e78bd92a77e580937b1.png" width="1200"/>
      </div>
     </li>
     <li>
      <div>
       <strong>
        中断基本概念：
       </strong>
      </div>
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#6eaad7;">
       中断定义
      </span>
      ：
      <span style="color:#000000;">
       指CPU对突发的外部事件的反应过程或机制。
      </span>
      CPU收到
      <span style="color:#ff0000;">
       外部信号
      </span>
      （中断信号）后，停止当前工作，转去处理该
      <span style="color:#ff0000;">
       外部事件
      </span>
      ，处理完毕后回到原来工作的
      <span style="color:#ff0000;">
       中断处
      </span>
      （断点）继续原来的工作。
      <img alt="" height="537" src="https://i-blog.csdnimg.cn/blog_migrate/6e4b10e9b5db291f75bb4594d12885e6.png" width="999"/>
     </li>
     <li>
      <div>
       <span style="color:#6eaad7;">
        中断源
       </span>
       <span style="color:#000000;">
        ：引起系统中断的事件
       </span>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#6eaad7;">
        中断类型
       </span>
       ：
       <img alt="" height="661" src="https://i-blog.csdnimg.cn/blog_migrate/78077c9dd72a28c0291cbdf90abe7762.png" width="1200"/>
      </div>
     </li>
     <li>
      <span style="color:#6eaad7;">
       断点
      </span>
      ：
      <span style="color:#000000;">
       程序中断的地方（将要执行的下一条指令的地址）
      </span>
     </li>
     <li>
      <span style="color:#6eaad7;">
       现场
      </span>
      ：
      <span style="color:#000000;">
       程序正确运行所依赖的信息集合。（PSW
      </span>
      <span style="color:#000000;">
       （
      </span>
      <span style="color:#ff0000;">
       程序状态字
      </span>
      <span style="color:#000000;">
       ）、相关寄存器、
      </span>
      <span style="color:#0000ff;">
       断点
      </span>
      <span style="color:#000000;">
       ）
      </span>
     </li>
     <li>
      <div>
       <span style="color:#6eaad7;">
        现场的处理
       </span>
       <span style="color:#000000;">
        ：现场保护（进入
       </span>
       <span style="color:#990033;">
        中断服务程序
       </span>
       <span style="color:#000000;">
        之前：
       </span>
       <span style="color:#000000;">
        CPU→
       </span>
       <span style="color:#ff0066;">
        栈
       </span>
       <span style="color:#000000;">
        ），现场恢复（退出
       </span>
       <span style="color:#990033;">
        中断服务程序
       </span>
       <span style="color:#000000;">
        之后：
       </span>
       <span style="color:#ff0066;">
        栈
       </span>
       <span style="color:#000000;">
        →CPU）
       </span>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#6eaad7;">
        中断响应过程
       </span>
       ：识别中断源--保护断点--保护现场--进入中断服务程序--恢复现场--中断返回
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/weixin_51756720/article/details/122550393?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170357356316800227412076%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170357356316800227412076&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-122550393-null-null.142%5Ev96%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6&amp;spm=1018.2226.3001.4187" title="（操作系统）中断机制">
       （操作系统）中断机制
      </a>
     </li>
     <li>
      <strong>
       基本输入输出系统
      </strong>
      （
      <strong>
       BIOS
      </strong>
      ）。
     </li>
    </ul>
    <p>
     <img alt="" height="1000" src="https://i-blog.csdnimg.cn/blog_migrate/f330a6854cf5119e1186f26e81a7b50c.png" width="1200"/>
    </p>
    <ul>
     <li>
      <strong>
       实模式和保护模式
      </strong>
     </li>
    </ul>
    <p>
     <img alt="" height="908" src="https://i-blog.csdnimg.cn/blog_migrate/72d7f637bf34c5bac5093fbe430e5a4e.png" width="1200"/>
    </p>
    <ul>
     <li>
      <strong>
       操作系统的启动
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#1c7892;">
       初始引导
      </span>
      ：把
      <span style="color:#ff0000;">
       OS内核
      </span>
      装入内存并使之开始工作接管计算机系统，引导程序为MBR（Master Boot Record）
     </li>
     <li>
      <span style="color:#1c7892;">
       核心初始化
      </span>
      ：
      <span style="color:#000000;">
       OS内核初始化系统的核心数据。比如：各种寄存器的初始化，存储系统和页表初始化，核心进程构建。
      </span>
     </li>
     <li>
      <div>
       <span style="color:#1c7892;">
        系统初始化
       </span>
       <span style="color:#000000;">
        ：为用户使用系统作准备，使系统处于
       </span>
       <span style="color:#ff0000;">
        待命状态
       </span>
       <span style="color:#000000;">
        。主要工作：初始化文件系统，初始化网络系统，初始化控制台，初始化图形界面。
       </span>
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       MBR（主启动扇区）
      </strong>
      ，
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#0d0016;">
       存放引导代码。
      </span>
     </li>
     <li>
      <span style="color:#0d0016;">
       占用512个字节（510字节+AA55h），最后两个字节是MBR结束标志。
      </span>
     </li>
     <li>
      提供BootLoader或启动管理。
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       PBR
      </strong>
      ：分区/次引导记录
     </li>
     <li>
      <strong>
       Linux操作系统的生成
      </strong>
      ：获取内核源码--配置内核--重新编译新内核--编译和安装模块--配置启动选项
     </li>
    </ul>
    <h2>
     第三章、用户界面
    </h2>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/weixin_59913110/article/details/130451383?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170357564416800184136754%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170357564416800184136754&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130451383-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2&amp;spm=1018.2226.3001.4187" title="操作系统——操作系统用户界面">
       操作系统——操作系统用户界面
      </a>
     </li>
     <li>
      <strong>
       用户界面定义
      </strong>
      ：
      <span style="color:#000000;">
       操作系统提供给用户控制计算机的机制
      </span>
      <span style="color:#0000ff;">
       (用户接口)
      </span>
     </li>
     <li>
      <strong>
       用户界面类型
      </strong>
      ：操作界面和系统调用
      <span style="color:#000000;">
       (System Call，系统功能调用,
      </span>
      <span style="color:#ff0000;">
       程序界面
      </span>
      <span style="color:#000000;">
       )
      </span>
     </li>
     <li>
      <span style="color:#000000;">
       <strong>
        操作界面
       </strong>
       ：分为图形用户接口，操作命令，批处理与脚本程序
      </span>
     </li>
     <li>
      <strong>
       批处理与脚本程序
      </strong>
      ：
      <span style="color:#000000;">
       在控制台环境下自动处理一批
      </span>
      <span style="color:#c00000;">
       命令。
      </span>
      <span style="color:#0d0016;">
       Windows：批处理程序（bat/PowerShell）。Linux：Shell脚本程序。
      </span>
      <img alt="" height="1131" src="https://i-blog.csdnimg.cn/blog_migrate/2f25310caad0f248f240cf3ffeb36a36.png" width="1200"/>
      <img alt="" height="1102" src="https://i-blog.csdnimg.cn/blog_migrate/a7648e4f9c8073b9ac623ef98a40f87f.png" width="1200"/>
      <img alt="" height="1113" src="https://i-blog.csdnimg.cn/blog_migrate/aec35665e0287a49ed85f28f25facd9d.png" width="1200"/>
     </li>
     <li>
      Bash主要功能之
      <strong>
       重定向：
      </strong>
      主要是标准输入/输出的重定向，在linux虚拟机上实践一下会好很多
      <img alt="" height="677" src="https://i-blog.csdnimg.cn/blog_migrate/55675bbbbd2d27c17912c3d29ae0c708.png" width="1169"/>
      <img alt="" height="667" src="https://i-blog.csdnimg.cn/blog_migrate/5b584866739666fd00c7cd3145b0d1bb.png" width="1197"/>
     </li>
     <li>
      Bash主要功能之
      <strong>
       管道：
      </strong>
      <img alt="" height="610" src="https://i-blog.csdnimg.cn/blog_migrate/3cb7ae69e0356b47baf6adfcbe7ae13c.png" width="1156"/>
     </li>
    </ul>
    <p>
     在虚拟机里实践一下
    </p>
    <p>
     <img alt="" height="460" src="https://i-blog.csdnimg.cn/blog_migrate/651baad1a88c522f4142e19f2f849bc4.png" width="1049"/>
     因为这个学期第一次os实验有4个，第二次os实验有7个
    </p>
    <ul>
     <li>
      <strong>
       系统调用
      </strong>
      <span style="color:#000000;">
       <strong>
        (
       </strong>
      </span>
      <span style="color:#000000;">
       <strong>
        System Call，System Service Call)：
       </strong>
       操作系统
      </span>
      <span style="color:#ff0000;">
       内核
      </span>
      <span style="color:#000000;">
       为应用程序提供的
      </span>
      <span style="color:#ff3300;">
       服务/函数
      </span>
      <span style="color:#000000;">
       。
      </span>
      特点：内核实现，存取核心资源或硬件，调用过程产生中断
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="378" src="https://i-blog.csdnimg.cn/blog_migrate/cf721a4e9c135173b70f64f8167b42cb.png" width="575"/>
    </p>
    <p class="img-center">
     <img alt="" height="334" src="https://i-blog.csdnimg.cn/blog_migrate/a0272f902cc15a30033cadc10c2ac1d0.png" width="597"/>
    </p>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/IT_Financial/article/details/105084726?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105084726.142%5Ev98%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187" title="操作系统学习之系统调用">
       操作系统学习之系统调用
      </a>
     </li>
    </ul>
    <h2>
     第四章、进程管理
    </h2>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/weixin_43765321/article/details/123279800?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170358053116800213089699%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170358053116800213089699&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123279800-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86&amp;spm=1018.2226.3001.4187" title="操作系统——进程管理">
       操作系统——进程管理
      </a>
     </li>
     <li>
      <strong>
       进程定义
      </strong>
      ：
      <span style="color:#000000;">
       进程是程序在某个
      </span>
      <span style="color:#0000ff;">
       数据集合
      </span>
      <span style="color:#000000;">
       上的
      </span>
      <span style="color:#ff0000;">
       <strong>
        一次
       </strong>
      </span>
      <span style="color:#000000;">
       运行
      </span>
      <span style="color:#ff0000;">
       <strong>
        活动
       </strong>
      </span>
      <span style="color:#000000;">
       。
      </span>
     </li>
     <li>
      进程是系统中
      <strong>
       共享CPU的最小的并发单位
      </strong>
      ，是
      <strong>
       资源分配的基本单位。
      </strong>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         进程的特征
        </strong>
        ：
       </span>
      </div>
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        动态性：进程是程序的一次执行过程，动态产生/消亡
       </span>
      </div>
     </li>
     <li>
      <div>
       并发性：
       <span style="color:#000000;">
        进程可以同其他进程一起向前推进
       </span>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#ff0000;">
        异步性：
       </span>
       <span style="color:#000000;">
        进程按各自速度向前推进
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         独立性：进程是系统分配资源和调度CPU的单位
        </span>
       </div>
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       进程与程序的区别
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      动态与静态。
      <span style="color:#000000;">
       进程是动态的：程序的一次执行过程；程序是静态的：一组指令的有序集合
      </span>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        暂存与长存。进程是暂存的：在内存驻留。程序是长存的：在介质上长期保存。
       </span>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        程序和进程的对应。一个程序可能有多个进程。
       </span>
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       进程的状态
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        运行状态（Running）。进程已经占有CPU，在CPU上运行。
       </span>
      </div>
     </li>
     <li>
      <div>
       就绪状态
       <span style="color:#000000;">
        （Ready）。具备运行条件但由于无CPU，暂时不能运行
       </span>
      </div>
     </li>
     <li>
      <div>
       阻塞状态（Block）。
       <span style="color:#000000;">
        因为等待某项
       </span>
       <span style="color:#ff0000;">
        服务
       </span>
       <span style="color:#000000;">
        完成或
       </span>
       <span style="color:#ff0000;">
        信号
       </span>
       <span style="color:#000000;">
        来到而不能运行的状态。例如等待：系统调用，I/O操作，合作进程的服务或信号…
       </span>
       <img alt="" height="835" src="https://i-blog.csdnimg.cn/blog_migrate/45344b086df1f12049e276198270cb7e.png" width="1200"/>
      </div>
     </li>
    </ol>
    <p>
     <img alt="" height="520" src="https://i-blog.csdnimg.cn/blog_migrate/289c1d970dff4f050d5df4d54c06b766.png" width="1173"/>
    </p>
    <ul>
     <li>
      <strong>
       Linux进程状态
      </strong>
      ：可运行，睡眠，僵死，暂停。
     </li>
    </ul>
    <p>
     <img alt="" height="896" src="https://i-blog.csdnimg.cn/blog_migrate/a80caff6347aed76b8a6b45b53571d38.png" width="1200"/>
    </p>
    <p>
     <img alt="" height="1032" src="https://i-blog.csdnimg.cn/blog_migrate/ca07af8540d36be9bba517a578babb85.png" width="1200"/>
    </p>
    <ul>
     <li>
      <strong>
       进程控制块
      </strong>
      <span style="color:#000000;">
       <strong>
        (Process Control Block，PCB)
       </strong>
      </span>
      ：
      <span style="color:#000000;">
       描述进程的状态、资源、和相关进程的关系。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#000000;">
      PCB是进程的标志，创建进程时创建PCB，进程撤销后PCB同时撤销。
     </span>
    </p>
    <p>
     <img alt="" height="643" src="https://i-blog.csdnimg.cn/blog_migrate/71ff1afa099a7fec356e92b8957d4dd9.png" width="956"/>
    </p>
    <div>
    </div>
    <div>
     <img alt="" height="715" src="https://i-blog.csdnimg.cn/blog_migrate/c9399b143491e11e418e2fd6d530c6b1.png" width="1200"/>
    </div>
    <div>
    </div>
    <ul>
     <li>
      <strong>
       task_struct
      </strong>
      ：Linux 内核中表示进程和线程的关键数据结构，包含了各种信息，如状态、调度信息、文件描述符等。
      <img alt="" height="537" src="https://i-blog.csdnimg.cn/blog_migrate/3ca76cfcb6d9c57c413587f7d8acd0b0.png" width="1128"/>
     </li>
     <li>
      <strong>
       进程控制
      </strong>
      ：在进程生存期间，对其全部行为的控制。有以下四个典型的进程控制。
     </li>
    </ul>
    <ol>
     <li>
      进程创建：
      <span style="color:#000000;">
       创建一个具有指定标识（ID）的进程。
      </span>
      <img alt="" height="525" src="https://i-blog.csdnimg.cn/blog_migrate/a9846abdfa47c757825aa7375190848f.png" width="789"/>
      <img alt="" height="621" src="https://i-blog.csdnimg.cn/blog_migrate/a56bc90e572e28995201e1ecc0a22cce.png" width="1031"/>
     </li>
     <li>
      进程撤销：
      <span style="color:#000000;">
       撤销一个指定的进程，收回进程所占有的资源，撤销该进程的
      </span>
      <span style="color:#000000;">
       PCB。
      </span>
      进程撤销的时机/事件：正常结束，异常结束，外界干预。
      <img alt="" height="540" src="https://i-blog.csdnimg.cn/blog_migrate/72e7849b6a30ad03b49677d25ef7df50.png" width="1055"/>
     </li>
     <li>
      进程阻塞：
      <span style="color:#000000;">
       停止进程执行，变为阻塞。
      </span>
      阻塞进程的时机/事件：请求系统服务，启动某种操作，新数据尚未到达，无新工作可做。
      <img alt="" height="515" src="https://i-blog.csdnimg.cn/blog_migrate/c5842c3d9d65aa7abc1437abd5533a6b.png" width="1032"/>
     </li>
     <li>
      进程唤醒：
      <span style="color:#000000;">
       唤醒处于阻塞队列当中的某个进程。引起唤醒的时机/事件：系统服务由不满足到满足，I/O完成，新数据到达，提出新请求。
      </span>
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       原语
      </strong>
      ：
      <span style="color:#000000;">
       由若干指令构成的具有特定功能的函数。具有原子性，其操作不可分割。
      </span>
     </li>
     <li>
      <strong>
       Linux进程控制
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      创建进程--fork（）
      <a class="link-info" href="https://blog.csdn.net/Artisan_w/article/details/132334752?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170365509216800222885346%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170365509216800222885346&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-132334752-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=linux%20fork&amp;spm=1018.2226.3001.4187" title="linux--fork()详解">
       linux--fork()详解
      </a>
      <img alt="" height="556" src="https://i-blog.csdnimg.cn/blog_migrate/49fa1e2fa01033fc2cceb27b70818925.png" width="1064"/>
     </li>
    </ol>
    <p>
     关于fork的返回值：pid = 0（在子进程中），pid&gt;0（在父进程中，为子进程id），pid= -1（出错）
    </p>
    <p>
     <a class="link-info" href="https://www.zhihu.com/question/59296096/answer/1707711827" rel="nofollow" title="fork之后，父子进程的先后执行顺序如何反映？">
      fork之后，父子进程的先后执行顺序如何反映？
     </a>
    </p>
    <p>
     <a class="link-info" href="https://blog.csdn.net/qq_41687938/article/details/120478430" title="linux中fork函数及子进程父进程执行顺序">
      linux中fork函数及子进程父进程执行顺序
     </a>
    </p>
    <p>
     在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。可以通过fork返回的值来判断当前进程是子进程还是父进程。
    </p>
    <p>
     <img alt="" height="581" src="https://i-blog.csdnimg.cn/blog_migrate/f222b8dfc7569329c39d8153b15fdd29.png" width="1129"/>
    </p>
    <p>
     <img alt="" height="785" src="https://i-blog.csdnimg.cn/blog_migrate/0133d1fcdecdb959ec8f8d2ef89f789d.png" width="1129"/>
    </p>
    <p>
     2. exec函数族：
    </p>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        功能：在子进程空间运行指定的“
       </span>
       <span style="color:#0000ff;">
        可执行程序
       </span>
       <span style="color:#000000;">
        ”
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         步骤：根据
        </span>
        <span style="color:#0000ff;">
         文件名
        </span>
        <span style="color:#000000;">
         找到相应的
        </span>
        <span style="color:#0000ff;">
         可执行程序，
        </span>
        <span style="color:#000000;">
         可执行程序的内容填入子进程的地址空间。
        </span>
       </div>
      </div>
     </li>
     <li>
      <span style="color:#000000;">
       返回：exec调用成功：进入新进程且不再返回。exec调用失败：继续从调用点向下执行。
      </span>
     </li>
    </ol>
    <p>
     3. 进程的阻塞--wait（int &amp;status）函数
     <a class="link-info" href="https://blog.csdn.net/qq_33300585/article/details/128472278?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170365614616800215024965%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170365614616800215024965&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128472278-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=linux%20wait%EF%BC%88%EF%BC%89&amp;spm=1018.2226.3001.4187" title="Linux中wait()函数">
      Linux中wait()函数
     </a>
     <img alt="" height="492" src="https://i-blog.csdnimg.cn/blog_migrate/20a7b9b21ade4acb742d7684791f7e48.png" width="964"/>
    </p>
    <p>
     4. 进程的终结--exit（int &amp;status）函数
     <a class="link-info" href="https://blog.csdn.net/songshuai0223/article/details/120850739?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170365639516800188547321%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170365639516800188547321&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120850739-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=linux%20exit&amp;spm=1018.2226.3001.4187" title="Linux -- exit()函数、_exit()函数、return的说明与使用">
      Linux -- exit()函数、_exit()函数、return的说明与使用
     </a>
     <img alt="" height="535" src="https://i-blog.csdnimg.cn/blog_migrate/ae507de59772e207c17c78151a7e2c51.png" width="1138"/>
    </p>
    <div>
     5. 进程的休眠--sleep（int nSecond）
     <img alt="" height="208" src="https://i-blog.csdnimg.cn/blog_migrate/f6805a2ee03b5e1a159c66c63750513f.png" width="1073"/>
    </div>
    <ul>
     <li>
      <strong>
       线程的定义
      </strong>
      ：线程是进程内创建的
      <span style="color:#0000ff;">
       可运行模块
      </span>
      <span style="color:#0000ff;">
       /
      </span>
      <span style="color:#0000ff;">
       指令
      </span>
      序列，能执行
      <span style="color:#0000ff;">
       指定的任务
      </span>
      。
     </li>
    </ul>
    <p>
     进程内可以定义多个线程，线程和进程可以并发运行。
    </p>
    <p>
     线程是
     <strong>
      CPU调度和派发的基本单位。
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       线程的意义
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        线程提高了系统的并发性能。线程的并发粒度比进程更细，更充分地发挥
       </span>
       <span style="color:#000000;">
        CPU
       </span>
       <span style="color:#000000;">
        的性能。
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         线程的应用成本更低，更灵活 。进程为
        </span>
        <span style="color:#0000ff;">
         线程
        </span>
        <span style="color:#000000;">
         提供
        </span>
        <span style="color:#0000ff;">
         资源
        </span>
        <span style="color:#000000;">
         和
        </span>
        <span style="color:#0000ff;">
         地址空间
        </span>
        <span style="color:#000000;">
         。线程的创建，撤销和管理
        </span>
        <span style="color:#0000ff;">
         成本更低；
        </span>
        <span style="color:#000000;">
         线程间通信
        </span>
        <span style="color:#0000ff;">
         更容易，更灵活。
        </span>
       </div>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        大多数操作系统都采用了线程技术。Windows/Linux/
       </span>
       <span style="color:#000000;">
        鸿蒙
       </span>
       <span style="color:#000000;">
        /
       </span>
       <span style="color:#000000;">
        麒麟
       </span>
       <span style="color:#000000;">
        /…
       </span>
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       创建线程--CreateThread(TaskFunction)
      </strong>
      函数
      <img alt="" height="600" src="https://i-blog.csdnimg.cn/blog_migrate/69d72d4a7c8f0c6693717b66cc76e3e6.png" width="1142"/>
     </li>
     <li>
      <strong>
       线程的应用场景
      </strong>
      ：
     </li>
    </ul>
    <div>
     <div>
      <span style="color:#000000;">
       多个功能需要并发的地方
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       需要改善窗口交互性的地方
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       需要改善程序结构的地方
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       多核
      </span>
      <span style="color:#000000;">
       CPU
      </span>
      <span style="color:#000000;">
       上的应用，充分发挥多核性能
      </span>
     </div>
     <ul>
      <li>
       <div>
        <strong>
         <span style="color:#000000;">
          现代操作系统线程模型：
         </span>
        </strong>
       </div>
      </li>
     </ul>
     <div>
      <span style="color:#000000;">
       进程
      </span>
      <span style="color:#000000;">
       =
      </span>
      <span style="color:#000000;">
       资源集 + 线程组：
      </span>
      <img alt="" height="554" src="https://i-blog.csdnimg.cn/blog_migrate/6f243b275bfd6ceacf1df4e39bbbba2a.png" width="813"/>
     </div>
     <div>
      <div>
       <span style="color:#000000;">
        线程的状态变迁：
       </span>
      </div>
      <div>
       <img alt="" height="418" src="https://i-blog.csdnimg.cn/blog_migrate/1a2f3266dbb416582dffdd93a2ff9e52.png" width="1001"/>
      </div>
      <div>
      </div>
      <ul>
       <li>
        <strong>
         Linux线程和分类
        </strong>
       </li>
      </ul>
      <ol>
       <li>
        <div>
         <span style="color:#000000;">
          内核线程/Kernel Thread
         </span>
         <img alt="" height="256" src="https://i-blog.csdnimg.cn/blog_migrate/47df731020c58de1451e08153954d063.png" width="907"/>
        </div>
       </li>
       <li>
        <div>
         <div>
          <span style="color:#000000;">
           用户线程/User Thread
          </span>
          <img alt="" height="296" src="https://i-blog.csdnimg.cn/blog_migrate/10627b0e0c5d787a3f679360805784c8.png" width="1036"/>
         </div>
        </div>
       </li>
      </ol>
     </div>
     <ul>
      <li>
       进程VS线程
       <img alt="" height="708" src="https://i-blog.csdnimg.cn/blog_migrate/d4079c0d14b8613f0b2af167ad8d1cff.png" width="1188"/>
      </li>
      <li>
       <strong>
        进程互斥的定义：
       </strong>
       多哥进程共享具有独占性的资源时，必须确保各进程互斥地存取资源，即确保没有任何两个进程同时存取资源。进程内设定特定区域，所有进程互斥地访问这些区域。
      </li>
     </ul>
     <p>
      <img alt="" height="429" src="https://i-blog.csdnimg.cn/blog_migrate/1d6b105a08a9c738519730c84219e3fe.png" width="1170"/>
     </p>
     <ul>
      <li>
       <span style="color:#000000;">
        <strong>
         临界资源
        </strong>
        ：一次只允许一个进程独占访问（使用）的资源。比如上面的共享变量i
       </span>
      </li>
      <li>
       <div>
        <span style="color:#000000;">
         <strong>
          临界区：
         </strong>
         进程中访问临界资源的程序段。
        </span>
       </div>
      </li>
      <li>
       <div>
        <span style="color:#000000;">
         进程的同步关系：
         <a class="link-info" href="https://blog.csdn.net/weixin_45863060/article/details/128730280?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128730280.142%5Ev98%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187" title="操作系统进程同步">
          操作系统进程同步
         </a>
        </span>
        <img alt="" height="685" src="https://i-blog.csdnimg.cn/blog_migrate/1ecfe4863def85286fbe94d270269b10.png" width="1178"/>
        ‘’‘’
       </div>
      </li>
     </ul>
     <div>
      <img alt="" height="315" src="https://i-blog.csdnimg.cn/blog_migrate/ca8ccf1023f36c3387a0b4824951db5c.png" width="1167"/>
     </div>
     <ul>
      <li>
       <span style="color:#000000;">
        <strong>
         临界区和临界资源的共享特点
        </strong>
       </span>
       :
       <span style="color:#000000;">
        临界资源的访问具有排他性，并发进程不能同时进入“临界区”
       </span>
      </li>
      <li>
       <span style="color:#000000;">
        访问临界区的方法：
       </span>
      </li>
     </ul>
     <ol>
      <li>
       硬件方法：
       <a class="link-info" href="https://blog.csdn.net/weixin_45863060/article/details/128730280?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128730280.142%5Ev98%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187#t6" title="硬件同步机制">
        硬件同步机制
       </a>
      </li>
      <li>
       软件方法：锁机制和信号量机制。
       <img alt="" height="717" src="https://i-blog.csdnimg.cn/blog_migrate/496199c5192fc2050ce4e8cc2c821a00.png" width="1021"/>
       <img alt="" height="775" src="https://i-blog.csdnimg.cn/blog_migrate/e28a13022faef923013d239d87fde71e.png" width="1052"/>
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        临界区访问的四个原则
       </strong>
       ：
      </li>
     </ul>
     <ol>
      <li>
       <span style="color:#6eaad7;">
        空闲让进
       </span>
       ：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立刻进入自己的临界区，以有效利用临界资源。
      </li>
      <li>
       <span style="color:#6eaad7;">
        忙则等待
       </span>
       ：当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。
      </li>
      <li>
       <span style="color:#6eaad7;">
        有限等待
       </span>
       ：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入”死等“状态。
      </li>
      <li>
       <span style="color:#6eaad7;">
        让权等待
       </span>
       ：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入”忙等“状态。
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        信号灯机制
       </strong>
       ：
      </li>
     </ul>
     <p>
      <img alt="" height="647" src="https://i-blog.csdnimg.cn/blog_migrate/3b55e890d96c2a6600e3f8847ce30d34.png" width="1125"/>
     </p>
     <ol>
      <li>
       P操作（
       <span style="color:#000000;">
        荷兰语：
       </span>
       <span style="color:#ff0000;">
        P
       </span>
       <span style="color:#000000;">
        asseren
       </span>
       <span style="color:#0000ff;">
        通过
       </span>
       ）原理：
       <img alt="" height="707" src="https://i-blog.csdnimg.cn/blog_migrate/30f2d72215922b8e40abc23192c8119e.png" width="1200"/>
      </li>
      <li>
       V操作（荷兰语：
       <span style="color:#ff0000;">
        V
       </span>
       <span style="color:#000000;">
        rijgeven
       </span>
       <span style="color:#0000ff;">
        释放
       </span>
       ）
       <img alt="" height="714" src="https://i-blog.csdnimg.cn/blog_migrate/4533f91dc63c5096764556ea0b664f07.png" width="1173"/>
      </li>
     </ol>
    </div>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/weixin_51995229/article/details/125130678?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170366221216800211592230%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170366221216800211592230&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125130678-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E6%9C%BA%E5%88%B6&amp;spm=1018.2226.3001.4187" title="PV机制及应用/例题">
       PV机制及应用/例题
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_28409193/article/details/125970401?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170366248316800192269501%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170366248316800192269501&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125970401-null-null.142%5Ev98%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E6%9C%BA%E5%88%B6%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98&amp;spm=1018.2226.3001.4187" title="PV机制经典同步问题">
       PV机制经典同步问题
      </a>
     </li>
     <li>
      Windows同步机制：
      <img alt="" height="652" src="https://i-blog.csdnimg.cn/blog_migrate/1a51d2fe1eb9f5658607a5a762ada3a0.png" width="1161"/>
     </li>
    </ul>
    <h2>
     第五章、
     <span style="color:#000000;">
      资源分配与调度（
     </span>
     <span style="color:#c00000;">
      死锁
     </span>
     <span style="color:#000000;">
      ）
     </span>
    </h2>
    <ul>
     <li>
      <strong>
       死锁的定义
      </strong>
      ：
      <span style="color:#000000;">
       两个或多个进程
      </span>
      <span style="color:#0000ff;">
       无限期地
      </span>
      <span style="color:#000000;">
       等待永远不会发生的条件的一种系统
      </span>
      <span style="color:#0000ff;">
       状态。
      </span>
      <span style="color:#0d0016;">
       每个进程都永远阻塞。
      </span>
     </li>
     <li>
      <strong>
       死锁的另一个定义
      </strong>
      ：
      <span style="color:#000000;">
       在两个或多个进程中，
      </span>
      <span style="color:#ff0000;">
       <strong>
        每个
       </strong>
      </span>
      <span style="color:#000000;">
       进程都
      </span>
      <span style="color:#0000ff;">
       已持有
      </span>
      <span style="color:#000000;">
       某种资源，但又
      </span>
      <span style="color:#0000ff;">
       继续申请
      </span>
      <span style="color:#000000;">
       其它进程
      </span>
      <span style="color:#ff0000;">
       已持有的某种资源
      </span>
      <span style="color:#000000;">
       。
      </span>
     </li>
     <li>
      <span style="color:#000000;">
       <a class="link-info" href="https://blog.csdn.net/m0_58153897/article/details/128094990?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170366837616800180683561%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170366837616800180683561&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-128094990-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E7%9A%84%E7%BB%93%E8%AE%BA&amp;spm=1018.2226.3001.4187" title="操作系统学习（九）死锁">
        操作系统学习（九）死锁
       </a>
      </span>
     </li>
     <li>
      <strong>
       死锁的起因
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      系统资源有限。资源数目不足以满足所有进程的需要，引起进程对资源的竞争而产生死锁。
     </li>
     <li>
      并发进程的推进顺序不当。进程在运行过程中，请求和释放资源的顺序不当，导致进程产生死锁。
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       关于死锁的一些结论
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      陷入死锁的进程至少是2个（反证：若仅有一个进程死锁）
     </li>
     <li>
      参与死锁的进程至少有2个已经占有资源。
     </li>
     <li>
      参与死锁的所有进程都在等待资源
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        参与死锁的进程是当前系统中所有进程的子集
       </span>
      </div>
     </li>
     <li>
      <div>
       死锁会浪费大量系统资源，甚至导致系统崩溃。
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       死锁的必要条件
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      互斥条件：
      <span style="color:#000000;">
       资源具有独占性，进程
      </span>
      <span style="color:#ff0000;">
       互斥
      </span>
      <span style="color:#000000;">
       使用资源。
      </span>
     </li>
     <li>
      不剥夺条件：
      <span style="color:#000000;">
       资源被访问完之前
      </span>
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#000000;">
       即在
      </span>
      <span style="color:#ff0000;">
       释放
      </span>
      <span style="color:#000000;">
       前
      </span>
      <span style="color:#000000;">
       )
      </span>
      <span style="color:#000000;">
       不能被其他进程
      </span>
      <span style="color:#ff0000;">
       剥夺
      </span>
      <span style="color:#000000;">
       。
      </span>
     </li>
     <li>
      部分分配条件：
      <span style="color:#000000;">
       进程所需资源逐步分配，需要时临时申请（
      </span>
      <span style="color:#0000ff;">
       等待分配
      </span>
      <span style="color:#000000;">
       ）。
      </span>
     </li>
     <li>
      <span style="color:#000000;">
       环路条件：
      </span>
      多个进程构成环路：环中
      <span style="color:#ff0000;">
       每个进程
      </span>
      <span style="color:#0000ff;">
       已占用的资源
      </span>
      被
      <span style="color:#ff0000;">
       前一进
      </span>
      程申请，而自己所需
      <span style="color:#0000ff;">
       新资源
      </span>
      又被环中
      <span style="color:#ff0000;">
       后一进程
      </span>
      所占用。对于哲学家就餐问题来说，限定最多四个人同时吃饭，就是破坏环路条件。
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       解决死锁的策略
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      预防死锁：通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁。
      <img alt="" height="588" src="https://i-blog.csdnimg.cn/blog_migrate/92411c665978bea5d44bc4a8b0f23f72.png" width="1200"/>
     </li>
     <li>
      避免死锁：
      <span style="color:#000000;">
       在资源的分配过程中，用某种方法分析该次分配是否可能导致死锁？若会则不分配；若不会就分配。
      </span>
     </li>
     <li>
      检测和恢复死锁：
      <span style="color:#000000;">
       允许死锁发生，但可通过
      </span>
      <span style="color:#ff0000;">
       检测机制
      </span>
      <span style="color:#000000;">
       及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁
      </span>
      <span style="color:#ff0000;">
       清除
      </span>
      <span style="color:#000000;">
       ，将进程从死锁状态解脱出来。
      </span>
      <img alt="" height="497" src="https://i-blog.csdnimg.cn/blog_migrate/f3b037f107745bc06d8b3fecaa797162.png" width="1200"/>
     </li>
     <li>
      预先静态分配法：
      <span style="color:#000000;">
       进程运行前将所需全部资源
      </span>
      <span style="color:#ff0000;">
       一次性
      </span>
      <span style="color:#000000;">
       分配给它。因此进程在运行过程中不再提出资源请求，从而避免出现阻塞或者死锁。破坏了
      </span>
      <span style="color:#fe2c24;">
       部分分配条件
      </span>
      <span style="color:#000000;">
       。
      </span>
      <img alt="" height="619" src="https://i-blog.csdnimg.cn/blog_migrate/6bb7f0323d950a8c88f3ee60abfd43c1.png" width="1200"/>
     </li>
     <li>
      有序资源分配法：
      <img alt="" height="971" src="https://i-blog.csdnimg.cn/blog_migrate/86e1f3cabbef1a9dbef4f052025b9c3f.png" width="1200"/>
     </li>
    </ol>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/I_r_o_n_M_a_n/article/details/125802465?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170367008016800211578260%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170367008016800211578260&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-125802465-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5&amp;spm=1018.2226.3001.4187" title="鸵鸟策略、死锁检测与死锁恢复、死锁预防、死锁避免">
       鸵鸟策略、死锁检测与死锁恢复、死锁预防、死锁避免
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/Dustinthewine/article/details/125924551?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170391592916800226544442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170391592916800226544442&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125924551-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187" title="银行家算法( 详解 )">
       银行家算法( 详解 )
      </a>
     </li>
    </ul>
    <h2>
     第六章、
     <span style="color:#000000;">
      处理机调度（进程调度）
     </span>
    </h2>
    <ul>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         调度定义：
        </strong>
        在队列中按
       </span>
       <span style="color:#0000ff;">
        某种策略
       </span>
       <span style="color:#000000;">
        选择
       </span>
       <span style="color:#0000ff;">
        最合适的
       </span>
       <span style="color:#000000;">
        对象(执行相应操作）
       </span>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        <a class="link-info" href="https://blog.csdn.net/m0_56069910/article/details/131006608?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170368188016800213013039%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170368188016800213013039&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131006608-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B8%E5%9E%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187" title="《操作系统》—— 处理机调度算法">
         《操作系统》—— 处理机调度算法
        </a>
       </span>
       讲的非常详细。
      </div>
     </li>
     <li>
      <div>
       <strong>
        调度分类
       </strong>
       ：
      </div>
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        长程调度（宏观调度
       </span>
       <span style="color:#000000;">
        /
       </span>
       <span style="color:#000000;">
        作业调度）。作业：磁盘--&gt;内存。
       </span>
      </div>
     </li>
     <li>
      <div>
       中程调度（交换调度）。进程：就绪（内存）--&gt;交换空间。
      </div>
     </li>
     <li>
      <div>
       短程调度（进程调度）。进程：就绪（内存）--&gt;CPU。
      </div>
     </li>
     <li>
      <div>
       I/O调度（设备调度）。进程：阻塞（设备）--&gt;就绪。
      </div>
     </li>
    </ol>
    <div>
     <img alt="" height="922" src="https://i-blog.csdnimg.cn/blog_migrate/92a665561d8b70fbadc66a706be8fefe.png" width="1200"/>
    </div>
    <div>
    </div>
    <ul>
     <li>
      <span style="color:#000000;">
       进程调度的目标（两个量化的衡量指标）：
      </span>
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        周转时间
       </span>
       <span style="color:#000000;">
        /
       </span>
       <span style="color:#000000;">
        平均周转时间
       </span>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        带权周转时间
       </span>
       <span style="color:#000000;">
        /
       </span>
       <span style="color:#000000;">
        平均带权周转时间
       </span>
      </div>
     </li>
    </ol>
    <div>
     <img alt="" height="914" src="https://i-blog.csdnimg.cn/blog_migrate/04cb363f291fd4b6ad28331e0fedb0a2.png" width="1200"/>
     <img alt="" height="814" src="https://i-blog.csdnimg.cn/blog_migrate/620d904bd525190aceeb37f9cd1cc849.png" width="1200"/>
    </div>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/m0_56069910/article/details/131006608?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170368188016800213013039%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170368188016800213013039&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131006608-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B8%E5%9E%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187#t12" title="典型的调度算法">
       典型的调度算法
      </a>
     </li>
    </ul>
    <p>
     1.
     <span style="color:#ed7976;">
      先来先服务调度
     </span>
     <span style="color:#0d0016;">
      （First Come First Serve）：按照作业进入系统的时间先后次序来挑选作业。先进入系统的作业优先被运行。
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      特点：只考虑作业
     </span>
     <span style="color:#0000ff;">
      <strong>
       等候时间
      </strong>
     </span>
     <span style="color:#000000;">
      ，不考虑
     </span>
     <span style="color:#0000ff;">
      作业大小(
     </span>
     <span style="color:#0000ff;">
      <strong>
       运行时间)
      </strong>
     </span>
     <span style="color:#000000;">
      。晚来的作业会等待较长时间，
     </span>
     <span style="color:#ff0000;">
      不利于晚来但是很短的作业。
     </span>
    </p>
    <p>
     2.
     <span style="color:#ed7976;">
      短作业优先调度算法
     </span>
     <span style="color:#000000;">
      （
     </span>
     <span style="color:#000000;">
      Short Job First）：参考
     </span>
     <span style="color:#0000ff;">
      <strong>
       运行时间
      </strong>
     </span>
     <span style="color:#000000;">
      ，选取
     </span>
     <span style="color:#ff0000;">
      时间最短
     </span>
     <span style="color:#000000;">
      的作业投入运行。
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      特点：忽视了作业等待时间，早来的长作业会长时间等待(资源“饥饿”)。
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      3.
     </span>
     <span style="color:#ed7976;">
      响应比高者优先调度算法
     </span>
     <span style="color:#000000;">
      ：调度作业时计算
     </span>
     <span style="color:#0000ff;">
      作业列表
     </span>
     <span style="color:#000000;">
      中每个作业的
     </span>
     <span style="color:#0000ff;">
      响应比
     </span>
     <span style="color:#000000;">
      ，选择
     </span>
     <span style="color:#0000ff;">
      响应比最高的作业
     </span>
     <span style="color:#000000;">
      优先投入运行。
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      特点：
     </span>
     <span style="color:#ff3300;">
      响应比
     </span>
     <span style="color:#ff3300;">
      = 1 +
     </span>
     <span style="color:#ff3300;">
      等待时间
     </span>
     <span style="color:#ff3300;">
      /
     </span>
     <span style="color:#ff3300;">
      运行时间，
     </span>
     <span style="color:#0d0016;">
      有利于短作业，有利于等候已久的作业，兼顾长作业。每次调度时重新计算和比较剩余作业的响应比。
     </span>
    </p>
    <p>
     <span style="color:#0d0016;">
      4.
     </span>
     <span style="color:#ed7976;">
      优先数调度算法
     </span>
     <span style="color:#0d0016;">
      ：
     </span>
     <span style="color:#000000;">
      根据进程优先数，把
     </span>
     <span style="color:#000000;">
      CPU
     </span>
     <span style="color:#000000;">
      分配给最高的进程。
     </span>
    </p>
    <div>
     <span style="color:#000000;">
      进程优先数
     </span>
     <span style="color:#000000;">
      =
     </span>
     <span style="color:#000000;">
      静态优先数
     </span>
     <span style="color:#000000;">
      +
     </span>
     <span style="color:#000000;">
      动态优先数。
     </span>
    </div>
    <div>
     静态优先数：
     <span style="color:#000000;">
      进程创建时确定，在整个进程运行期间不再改变。
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      动态优先数：动态优先数在进程运行期间可以改变。
     </span>
    </div>
    <div>
     <img alt="" height="642" src="https://i-blog.csdnimg.cn/blog_migrate/ed207bc6df186091b36c434b7cd9112b.png" width="1200"/>
    </div>
    <div>
    </div>
    <div>
     5.
     <span style="color:#ed7976;">
      循环轮转调度法
     </span>
     <span style="color:#000000;">
      （ROUND-ROBIN）：
     </span>
     把所有就绪进程按
     <span style="color:#ff0000;">
      先进先出
     </span>
     的原则排成队列。
     <span style="color:#0000ff;">
      新来
     </span>
     <span style="color:#0000ff;">
      进程
     </span>
     加到队列
     <span style="color:#0000ff;">
      末尾
     </span>
     。进程以
     <span style="color:#0000ff;">
      时间片
     </span>
     q为单位轮流使用CPU。刚刚运行了一个
     <span style="color:#0000ff;">
      时间片
     </span>
     的进程排到队列
     <span style="color:#0000ff;">
      末尾
     </span>
     ，等候下一轮调度。
     <span style="color:#ff0000;">
      队列逻辑上是环形的。
     </span>
    </div>
    <div>
     <img alt="" height="302" src="https://i-blog.csdnimg.cn/blog_migrate/cd59d1e2e0f1c9a10a07e86418bf97cd.png" width="1200"/>
    </div>
    <div>
     <img alt="" height="855" src="https://i-blog.csdnimg.cn/blog_migrate/443dbc998e58c09d50bd79b41078f2c1.png" width="1200"/>
     <span style="color:#000000;">
     </span>
    </div>
    <ul>
     <li>
      <strong>
       调度方式：
      </strong>
      <span style="color:#000000;">
       当一进程正在
      </span>
      <span style="color:#000000;">
       CPU
      </span>
      <span style="color:#000000;">
       上运行时，若有
      </span>
      <span style="color:#0000ff;">
       更高优先级的进程
      </span>
      <span style="color:#000000;">
       进入
      </span>
      <span style="color:#ff0000;">
       就绪
      </span>
      <span style="color:#000000;">
       ，系统如何对待新进程（分配
      </span>
      <span style="color:#000000;">
       CPU
      </span>
      <span style="color:#000000;">
       ）？
      </span>
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#000000;">
       非抢占方式：让正在运行的进程
      </span>
      <span style="color:#ff0000;">
       继续运行
      </span>
      <span style="color:#000000;">
       ，直到该进程完成或发生某事件而进入“完成”或“阻塞”状态时，才把CPU
      </span>
      <span style="color:#000000;">
       分配给新来的更高优先级的进程。
      </span>
     </li>
     <li>
      抢占方式：
      <span style="color:#000000;">
       让正在运行的进程
      </span>
      <span style="color:#ff0000;">
       立即暂停
      </span>
      <span style="color:#000000;">
       ，立即把
      </span>
      <span style="color:#000000;">
       CPU分配给新来的优先级更高的进程。
      </span>
     </li>
    </ol>
    <p>
     二者对比：
     <img alt="" height="762" src="https://i-blog.csdnimg.cn/blog_migrate/361e0735b731c12433af8eb4d537b3d7.png" width="1200"/>
    </p>
    <ul>
     <li>
      Linux进程优先级
     </li>
    </ul>
    <p>
     <img alt="" height="390" src="https://i-blog.csdnimg.cn/blog_migrate/ac8265ed1d3dd2f767dfec1690d961bb.png" width="674"/>
    </p>
    <ul>
     <li>
      <strong>
       <span style="color:#000000;">
        task_struct-&gt;
       </span>
       counter
      </strong>
      ：
      <span style="color:#000000;">
       进程在
      </span>
      <span style="color:#0000ff;">
       当前一轮调度
      </span>
      <span style="color:#000000;">
       中还能连续运行的时间片数量。counter越大，优先级越高，可获得越多CPU时间
      </span>
     </li>
    </ul>
    <div>
     <span style="color:#000000;">
      新一轮调度开始时：counter = priority
     </span>
    </div>
    <div>
     <div>
      <span style="color:#000000;">
       时钟中断服务程序：counter - -
      </span>
     </div>
     <div>
      <div>
       <span style="color:#000000;">
        特定情形：counter = counter
       </span>
       <span style="color:#0d0016;">
        + △
       </span>
      </div>
      <div>
       <span style="color:#000000;">
        所有进程的counter都减到0后：重新开始新一轮调度
       </span>
      </div>
      <div>
       <img alt="" height="929" src="https://i-blog.csdnimg.cn/blog_migrate/c3d0c39e5e2400bd6b378be1b1aa3833.png" width="1200"/>
      </div>
     </div>
    </div>
    <ul>
     <li>
      <strong>
       <span style="color:#000000;">
        task_struct-&gt;rt_priority：
       </span>
      </strong>
      <span style="color:#000000;">
       实时进程特有的优先级: rt_priority+1000
      </span>
     </li>
     <li>
      <strong>
       <span style="color:#000000;">
        task_struct-&gt;policy：
       </span>
      </strong>
      <span style="color:#000000;">
       进程的调度策略，用来区分实时进程和普通进程SCHED_OTHER(
      </span>
      <span style="color:#0000ff;">
       0
      </span>
      <span style="color:#000000;">
       )
      </span>
      <span style="color:#ff3300;">
       <strong>
        ||
       </strong>
      </span>
      <span style="color:#000000;">
       SCHED_FIFO(
      </span>
      <span style="color:#0000ff;">
       1
      </span>
      <span style="color:#000000;">
       )
      </span>
      <span style="color:#ff3300;">
       <strong>
        ||
       </strong>
      </span>
      <span style="color:#000000;">
       SCHED_RR(
      </span>
      <span style="color:#0000ff;">
       2
      </span>
      <span style="color:#000000;">
       )
      </span>
     </li>
     <li>
      <span style="color:#000000;">
       <strong>
        schedule( )函数：
       </strong>
       在
      </span>
      <span style="color:#0000ff;">
       可运行队列中
      </span>
      <span style="color:#ff0000;">
       查找
      </span>
      <span style="color:#000000;">
       最高优先数进程并把
      </span>
      <span style="color:#000000;">
       CPU
      </span>
      <span style="color:#ff0000;">
       切换
      </span>
      <span style="color:#000000;">
       给它。
      </span>
     </li>
    </ul>
    <h2 style="background-color:transparent;">
     第七章、主存管理
    </h2>
    <ul>
     <li>
      <strong>
       存储器功能需求
      </strong>
      ：
      <span style="color:#000000;">
       容量足够大，速度足够快，信息永久保存
      </span>
     </li>
     <li>
      <span style="color:#000000;">
       <strong>
        三级存储体系
       </strong>
       ：内存--辅存--cache
      </span>
      。用辅存支援内存，提高容量。用cache支援内存，提升效率。
      <img alt="" height="816" src="https://i-blog.csdnimg.cn/blog_migrate/87a6f22e3a19b22c2826d4d9dea917ac.png" width="1168"/>
     </li>
     <li>
      <span style="color:#000000;">
       <strong>
        地址映射
       </strong>
       （地址重定位，地址重映射）：把程序中的地址
      </span>
      <span style="color:#ff3300;">
       （
      </span>
      <span style="color:#ff0000;">
       虚拟地址
      </span>
      <span style="color:#ff0000;">
       ,
      </span>
      <span style="color:#ff3300;">
       虚地址
      </span>
      <span style="color:#ff3300;">
       ,
      </span>
      <span style="color:#ff0000;">
       逻辑地址
      </span>
      <span style="color:#ff0000;">
       ,
      </span>
      <span style="color:#ff0000;">
       相对地址
      </span>
      <span style="color:#ff3300;">
       ）
      </span>
      <span style="color:#000000;">
       变换成真实的内存地址
      </span>
      <span style="color:#ff3300;">
       （实地址
      </span>
      <span style="color:#ff3300;">
       ,
      </span>
      <span style="color:#ff0000;">
       物理地址
      </span>
      <span style="color:#ff0000;">
       ,
      </span>
      <span style="color:#ff0000;">
       绝对地址
      </span>
      <span style="color:#ff3300;">
       ）
      </span>
      <span style="color:#000000;">
       的过程。
      </span>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/weixin_48524215/article/details/125589384" title="内存管理：物理地址、虚拟地址、逻辑地址">
       内存管理：物理地址、虚拟地址、逻辑地址
      </a>
     </li>
     <li>
      <strong>
       固定地址映射
      </strong>
      ：
      <span style="color:#ff0000;">
       编程或编译时
      </span>
      <span style="color:#000000;">
       确定逻辑地址和物理地址映射关系。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#000000;">
      特点：程序加载时必须加载到指定的内存区域。容易产生地址冲突，运行失败。
     </span>
     <span style="color:#000000;">
      不能适应多道程序环境
     </span>
    </p>
    <ul>
     <li>
      <strong>
       静态地址映射
      </strong>
      ：程序
      <span style="color:#fe2c24;">
       装入时
      </span>
      由操作系统完成逻辑地址到物理地址的映射。保证程序在
      <span style="color:#c00000;">
       运行之前
      </span>
      <span style="color:#000000;">
       所有地址都绑定到主存。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#000000;">
      映射方式：物理地址（MA）= 装入地址（BA）+ 虚拟地址（VA）
     </span>
    </p>
    <p>
     特点：
     <span style="color:#000000;">
      程序运行之前确定映射关系。程序占用
     </span>
     <span style="color:#0000ff;">
      连续的
     </span>
     <span style="color:#000000;">
      内存空间。程序装入后
     </span>
     <span style="color:#0000ff;">
      不能移动，
     </span>
     <span style="color:#000000;">
      如果移动必须放回原来位置。
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#000000;">
       <strong>
        动态地址映射
       </strong>
       ：在程序
      </span>
      <span style="color:#ff0000;">
       执行过程中
      </span>
      <span style="color:#000000;">
       把逻辑地址转换为物理地址。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#000000;">
      映射方式：物理地址
     </span>
     <span style="color:#000000;">
      MA =
     </span>
     <span style="color:#000000;">
      装入基址
     </span>
     <span style="color:#000000;">
      BA +
     </span>
     <span style="color:#000000;">
      虚拟地址
     </span>
     <span style="color:#000000;">
      VA
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      装入基址：基址寄存器
     </span>
     <span style="color:#c00000;">
      BAR
     </span>
    </p>
    <div>
     <span style="color:#000000;">
      <strong>
       实现动态地址映射的思路：
      </strong>
     </span>
     <img alt="" height="927" src="https://i-blog.csdnimg.cn/blog_migrate/679fc70e46a77fc371d6c16a0e4ab7a5.png" width="1200"/>
    </div>
    <div>
     <img alt="" height="1031" src="https://i-blog.csdnimg.cn/blog_migrate/2235c1dc32bcc0ff57a12d51de83883b.png" width="1200"/>
    </div>
    <div>
     特点：
     <span style="color:#000000;">
      程序占用的内存空间可动态变化（若程序移动及时更新
     </span>
     <span style="color:#ff0000;">
      基址
     </span>
     <span style="color:#ff0000;">
      BA
     </span>
     <span style="color:#000000;">
      ）
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      程序不要求占用连续的内存空间（需要记录每段放置的
     </span>
     <span style="color:#ff0000;">
      基址
     </span>
     <span style="color:#ff0000;">
      BA
     </span>
     <span style="color:#000000;">
      ）
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      便于多个进程共享代码（共享代码作为
     </span>
     <span style="color:#ff0000;">
      独立的一段
     </span>
     <span style="color:#000000;">
      存放）
     </span>
    </div>
    <div>
     缺点：
     <span style="color:#000000;">
      硬件支持（
     </span>
     <span style="color:#000000;">
      MMU
     </span>
     <span style="color:#000000;">
      ：内存管理单元）。软件复杂。
     </span>
    </div>
    <div>
     <ul>
      <li>
       <strong>
        存储扩充：
       </strong>
       <span style="color:#000000;">
        借助辅存在逻辑上扩充内存，解决内存不足
       </span>
       <img alt="" height="612" src="https://i-blog.csdnimg.cn/blog_migrate/d0e6725a39d70c53c1c20f96a41e583d.png" width="1048"/>
       <img alt="" height="525" src="https://i-blog.csdnimg.cn/blog_migrate/265acc337791f81aab0d74712a46e916.png" width="939"/>
      </li>
      <li>
       <strong>
        存储保护
       </strong>
       ：
       <span style="color:#000000;">
        保证内存中的多道程序只能在给定区域活动，并且互不干扰。防止访问越界，防止访问越权。
       </span>
       <img alt="" height="663" src="https://i-blog.csdnimg.cn/blog_migrate/c36b02cff43d70d32539564a53481813.png" width="1200"/>
      </li>
      <li>
       <span style="color:#000000;">
        <strong>
         单一存储管理
        </strong>
        ：用户区
       </span>
       <span style="color:#ff0000;">
        不分区
       </span>
       <span style="color:#000000;">
        ，完全被一个程序占用。
       </span>
       <img alt="" height="771" src="https://i-blog.csdnimg.cn/blog_migrate/1994d55fbe4e051beb2d89f43dd2bb0a.png" width="1200"/>
      </li>
      <li>
       <strong>
        分区存储管理
       </strong>
       ：
       <span style="color:#000000;">
        把
       </span>
       <span style="color:#fe2c24;">
        用户区
       </span>
       <span style="color:#000000;">
        分为
       </span>
       <span style="color:#ff0000;">
        若干
       </span>
       <span style="color:#000000;">
        大小不等的
       </span>
       <span style="color:#ff0000;">
        分区
       </span>
       <span style="color:#000000;">
        ，供不同程序使用。
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#000000;">
       有
      </span>
      <span style="color:#6eaad7;">
       固定分区
      </span>
      <span style="color:#000000;">
       （系统初始化时分区）和
      </span>
      <span style="color:#6eaad7;">
       动态分区
      </span>
      <span style="color:#000000;">
       （程序装入时临时分区）两种。
      </span>
     </p>
     <ul>
      <li>
       <span style="color:#000000;">
        <strong>
         固定分区
        </strong>
        ：
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#000000;">
       特点：运行时分区的
      </span>
      <span style="color:#ff0000;">
       大小
      </span>
      <span style="color:#000000;">
       和
      </span>
      <span style="color:#ff0000;">
       位置
      </span>
      <span style="color:#000000;">
       不变，分区大小不同，适应不同程序需求。
      </span>
     </p>
     <p class="img-center">
      <img alt="" height="342" src="https://i-blog.csdnimg.cn/blog_migrate/3622fde94d41c49a8348961178d221ba.png" width="250"/>
     </p>
     <div>
      <p class="img-center">
       <img alt="" height="292" src="https://i-blog.csdnimg.cn/blog_migrate/5d1ec32076ce5c3c9c325a3865d4aec9.png" width="430"/>
      </p>
     </div>
     <div>
      缺点：
      <span style="color:#000000;">
       浪费内存，大程序可能无法运行，程序过多无法运行。
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       因此 程序的
      </span>
      <span style="color:#0000ff;">
       装入数量和顺序要与
      </span>
      <span style="color:#000000;">
       分区的数量、大小顺序尽量保持一致。
      </span>
     </div>
    </div>
    <ul>
     <li>
      <strong>
       动态分区：
      </strong>
     </li>
     <li>
      <p class="img-center">
       <img alt="" height="369" src="https://i-blog.csdnimg.cn/blog_migrate/159eec39db080d710c0b84f2f9f4e1bb.png" width="602"/>
      </p>
      <p class="img-center">
       <img alt="" height="369" src="https://i-blog.csdnimg.cn/blog_migrate/4f06d549f41412f19064a24afaac6300.png" width="597"/>
      </p>
      <p class="img-center">
       <img alt="" height="349" src="https://i-blog.csdnimg.cn/blog_migrate/beb9c0c3e3e935c0fe724eef365e2443.png" width="585"/>
      </p>
     </li>
     <li>
      <strong>
       分区的选择（放置策略）
      </strong>
     </li>
    </ul>
    <p>
     空闲区表：
     <span style="color:#000000;">
      描述内存
     </span>
     <span style="color:#0000ff;">
      空闲区
     </span>
     <span style="color:#000000;">
      的位置和大小的数据结构
     </span>
    </p>
    <ol>
     <li>
      <span style="color:#000000;">
       <u>
        首次适应法
       </u>
       ：
      </span>
      <span style="color:#0000ff;">
       空闲区表
      </span>
      <span style="color:#000000;">
       按
      </span>
      <span style="color:#ff0000;">
       首址递增
      </span>
      <span style="color:#000000;">
       排序，尽可能先利用
      </span>
      <span style="color:#ff0000;">
       低地址空间
      </span>
      <p class="img-center">
       <img alt="" height="232" src="https://i-blog.csdnimg.cn/blog_migrate/8fe2aff77007eda44d337723e5c62d52.png" width="464"/>
      </p>
     </li>
     <li>
      <u>
       最佳适应法
      </u>
      ：
      <span style="color:#0000ff;">
       空闲区表
      </span>
      <span style="color:#000000;">
       按
      </span>
      <span style="color:#ff0000;">
       大小递增
      </span>
      <span style="color:#000000;">
       排序，尽量先选中满足要求的
      </span>
      <span style="color:#ff0000;">
       最小
      </span>
      <span style="color:#000000;">
       空闲区
      </span>
      <p class="img-center">
       <img alt="" height="244" src="https://i-blog.csdnimg.cn/blog_migrate/75b440a6cfdcf9db2f60e58003ee3fce.png" width="476"/>
      </p>
     </li>
     <li>
      <u>
       最坏适应法
      </u>
      ：
      <span style="color:#0000ff;">
       空闲区表
      </span>
      <span style="color:#000000;">
       按
      </span>
      <span style="color:#ff0000;">
       大小递减
      </span>
      <span style="color:#000000;">
       排序，尽量先使用
      </span>
      <span style="color:#ff0000;">
       最大的
      </span>
      <span style="color:#000000;">
       空闲区，仅作
      </span>
      <span style="color:#ff0000;">
       一次查找
      </span>
      <span style="color:#000000;">
       就可找到所要分区。
      </span>
      <p class="img-center">
       <img alt="" height="214" src="https://i-blog.csdnimg.cn/blog_migrate/dcc8fce6e0af4c70cd7cd709cdf5201c.png" width="433"/>
      </p>
     </li>
    </ol>
    <ul>
     <li>
      <span style="color:#000000;">
       <strong>
        碎片问题
       </strong>
       ：
      </span>
      <img alt="" height="436" src="https://i-blog.csdnimg.cn/blog_migrate/84ad38917fb3a6cb31416931af597902.png" width="1129"/>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="368" src="https://i-blog.csdnimg.cn/blog_migrate/c2bfd9c58d652858f10a1314e9adba0f.png" width="473"/>
    </p>
    <ul>
     <li>
      <strong>
       覆盖技术（overlay）
      </strong>
     </li>
    </ul>
    <p>
     目的：
     <span style="color:#000000;">
      在
     </span>
     <span style="color:#ff0000;">
      较小
     </span>
     <span style="color:#000000;">
      的内存空间中运行
     </span>
     <span style="color:#ff0000;">
      较大
     </span>
     <span style="color:#000000;">
      的程序
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="306" src="https://i-blog.csdnimg.cn/blog_migrate/71ca81fed6e7c0ffd191da83990861a0.png" width="517"/>
    </p>
    <div>
     <p class="img-center">
      <img alt="" height="292" src="https://i-blog.csdnimg.cn/blog_migrate/ae1a7e3da203ced2520e0ed055c73dc6.png" width="526"/>
     </p>
     <p class="img-center">
      <img alt="" height="339" src="https://i-blog.csdnimg.cn/blog_migrate/196ef1bf4568748d6afe29cf76c7ff5d.png" width="556"/>
     </p>
     覆盖的缺点：编程复杂（程序员划分程序模块并确定关系），程序执行时间长（从外存装入内存耗时）
    </div>
    <ul>
     <li>
      <strong>
       对换技术（Swapping）
      </strong>
     </li>
    </ul>
    <div>
     原理：
     <span style="color:#000000;">
      内存不够时把进程写到磁盘（
     </span>
     <span style="color:#ff0000;">
      换出
     </span>
     <span style="color:#ff0000;">
      /
     </span>
     <span style="color:#0000ff;">
      <strong>
       Swap Out
      </strong>
     </span>
     <span style="color:#000000;">
      ）。
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      当进程要运行时重新写回内存（
     </span>
     <span style="color:#ff0000;">
      换入
     </span>
     <span style="color:#ff0000;">
      /
     </span>
     <span style="color:#0000ff;">
      <strong>
       Swap In
      </strong>
     </span>
     <span style="color:#000000;">
      ）。
     </span>
    </div>
    <div>
     优点：
     <span style="color:#000000;">
      增加进程并发数；不考虑程序结构。
     </span>
    </div>
    <div>
     缺点：
     <span style="color:#000000;">
      换入和换出增加
     </span>
     <span style="color:#000000;">
      CPU开销；对换单位太大（整个进程）
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      需要考虑的问题：程序换入时的地址重定位，减少对换传送的信息量，外存对换空间的管理方法
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      采用交换技术的OS：UNIX，Linux，Windows
     </span>
    </div>
    <ul>
     <li>
      <span style="color:#000000;">
       页式内存管理，不罗列了，ppt没讲清，不如看
       <a class="link-info" href="https://blog.csdn.net/pipihan21/article/details/129809005?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170373054716800211545152%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170373054716800211545152&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-129809005-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86&amp;spm=1018.2226.3001.4187#t6" title="基本分页存储管理方式">
        基本分页存储管理方式
       </a>
      </span>
     </li>
    </ul>
    <div>
     关键摘要：
     <img alt="" height="374" src="https://i-blog.csdnimg.cn/blog_migrate/151329f85262bf194ff449dd79db0cfb.png" width="1065"/>
    </div>
    <div>
     <img alt="" height="631" src="https://i-blog.csdnimg.cn/blog_migrate/afc9a070d3e7f37e34488b20b2e907a7.png" width="1092"/>
    </div>
    <ul>
     <li>
      <strong>
       地址映射
      </strong>
      ：
      <span style="color:#000000;">
       虚拟地址（页式地址）
      </span>
      <span style="color:#ff0000;">
       →
      </span>
      <span style="color:#000000;">
       物理地址
      </span>
      <img alt="" height="618" src="https://i-blog.csdnimg.cn/blog_migrate/16f0db43ff5651bff656f725b8223c26.png" width="1163"/>
     </li>
     <li>
      页表的建立：
      <img alt="" height="706" src="https://i-blog.csdnimg.cn/blog_migrate/d95c7b74ca0ed6cc0131f0d1f16a948f.png" width="1127"/>
     </li>
     <li>
      <strong>
       缺页中断
      </strong>
      ：
      <span style="color:#000000;">
       当程序要访问的
      </span>
      <span style="color:#0000ff;">
       目标页面
      </span>
      <span style="color:#000000;">
       不在内存时，程序将被迫
      </span>
      <span style="color:#0000ff;">
       临时中断。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#0d0016;">
      缺页中断的处理：
     </span>
     <span style="color:#000000;">
      立即将所缺
     </span>
     <span style="color:#0000ff;">
      页面
     </span>
     <span style="color:#000000;">
      装入内存。页面从
     </span>
     <span style="color:#0000ff;">
      硬盘
     </span>
     <span style="color:#000000;">
      拷贝到内存，其中的I/O操作耗时较长。
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      因此，缺页中断降低了程序实时性。
     </span>
    </p>
    <p>
     <img alt="" height="626" src="https://i-blog.csdnimg.cn/blog_migrate/c94c3d78c303faac33a90a3f11a4ddf6.png" width="1079"/>
     <img alt="" height="672" src="https://i-blog.csdnimg.cn/blog_migrate/e23fad22f6c9d3324fa66771f3ad623e.png" width="1185"/>
    </p>
    <p>
     修改位即所谓的“
     <strong>
      脏位
     </strong>
     ”。
    </p>
    <p>
     <img alt="" height="573" src="https://i-blog.csdnimg.cn/blog_migrate/fde12751b6a65bfa5c0a5fdbc07ed4e8.png" width="1122"/>
    </p>
    <p>
     访问指令的执行过程：
    </p>
    <p>
     <img alt="" height="761" src="https://i-blog.csdnimg.cn/blog_migrate/3c2e0e45337b51ad775e658c15078719.png" width="1165"/>
    </p>
    <ul>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         缺页（中断）率f =
        </strong>
       </span>
       <span style="color:#0000ff;">
        缺页次数
       </span>
       <span style="color:#000000;">
        /
       </span>
       <span style="color:#0000ff;">
        访问页面总次数
       </span>
      </div>
     </li>
     <li>
      <div>
       <strong>
        命中率 = 1 - f
       </strong>
      </div>
     </li>
     <li>
      <div>
       <a class="link-info" href="https://blog.csdn.net/weixin_52008431/article/details/123919301?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170375490216800192292024%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170375490216800192292024&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123919301-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD&amp;spm=1018.2226.3001.4187" title="操作系统复习：12.缺页中断以及内存页面置换算法">
        操作系统复习：12.缺页中断以及内存页面置换算法
       </a>
      </div>
     </li>
     <li>
      <div>
       <strong>
        页面抖动
       </strong>
       ：
       <span style="color:#000000;">
        页面在内存和辅存间频繁交换的现象。“抖动”会导致系统效率下降。
       </span>
      </div>
     </li>
     <li>
      <div>
       <strong>
        淘汰策略
       </strong>
       ：
      </div>
     </li>
    </ul>
    <div>
     一个好的淘汰策略，
     <span style="color:#000000;">
      页面抖动较少，具有较低的缺页率（高命中率）
     </span>
    </div>
    <p>
     1. 最佳算法（OPT算法，Optimal）:
     <span style="color:#000000;">
      淘汰
     </span>
     <span style="color:#0000ff;">
      不再需要
     </span>
     <span style="color:#000000;">
      或
     </span>
     <span style="color:#0000ff;">
      最远将来
     </span>
     <span style="color:#000000;">
      才会用到的页面。
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      特点：理论上最佳，实践中该算法
     </span>
     <span style="color:#ff0000;">
      无法实现
     </span>
     <span style="color:#000000;">
      。
     </span>
     <img alt="" height="597" src="https://i-blog.csdnimg.cn/blog_migrate/b7a16e0f2e12600fa577092b4d58a0d2.png" width="1141"/>
    </p>
    <p>
     <span style="color:#000000;">
      2. 先进先出淘汰算法（FIFO算法）:淘汰在内存中
     </span>
     <span style="color:#0000ff;">
      停留时间最长
     </span>
     <span style="color:#000000;">
      的页面
     </span>
    </p>
    <p>
     优点：
     <span style="color:#000000;">
      实现简单：页面按进入内存的时间排序，淘汰队头页面。同时，进程按
     </span>
     <span style="color:#ff0000;">
      顺序访问
     </span>
     <span style="color:#000000;">
      地址空间时
     </span>
     <span style="color:#ff0000;">
      抖动较少，缺页率较低
     </span>
     <span style="color:#000000;">
      。
     </span>
     <img alt="" height="792" src="https://i-blog.csdnimg.cn/blog_migrate/6f5af5371167833bbae474f8b98db7dd.png" width="1200"/>
    </p>
    <p>
     <span style="color:#000000;">
      异常现象：对于一些特定的访问序列，分配页框越多，缺页率越高！
     </span>
     <img alt="" height="661" src="https://i-blog.csdnimg.cn/blog_migrate/754880e8e40f06723eecda6768680d0c.png" width="1117"/>
    </p>
    <div>
     3. 最久未使用淘汰算法（LRU，Least Recently Used）：
     <span style="color:#000000;">
      淘汰
     </span>
     <span style="color:#ff0000;">
      最长时间未被使用
     </span>
     <span style="color:#000000;">
      的页面。
     </span>
     <img alt="" height="597" src="https://i-blog.csdnimg.cn/blog_migrate/09a6d50ab159a1c368b6775601ea7a42.png" width="1173"/>
     <img alt="" height="679" src="https://i-blog.csdnimg.cn/blog_migrate/def99993fe74f63f48c08b8ba3ceb33b.png" width="1191"/>
    </div>
    <div>
    </div>
    <div>
     4. 最不经常使用算法（LFU，Least Frequently Used）：
     <span style="color:#000000;">
      选择到当前时间为止
     </span>
     <span style="color:#0000ff;">
      被访问次数最少
     </span>
     <span style="color:#000000;">
      的页面，
     </span>
     每页设置
     <span style="color:#ff0000;">
      访问计数器
     </span>
     ，每当页面被访问时，该页面的访问计数器加1；
     <span style="color:#000000;">
      发生缺页中断时，淘汰计数值最小的页面
     </span>
     <span style="color:#ff3300;">
      ，并将所有计数清零。
     </span>
    </div>
    <div>
    </div>
    <div>
     实现方式
     <strong>
      ：
     </strong>
     对每个⻚⾯设置⼀个访问计数器，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就 累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯
    </div>
    <div>
     <img alt="" height="233" src="https://i-blog.csdnimg.cn/blog_migrate/7c43432f792a12f6ae5d7fbbf0103fcb.png" width="1046"/>
    </div>
    <ul>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         影响缺页次数的因素：
        </strong>
       </span>
      </div>
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        淘汰算法
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         分配给进程的页框数：页框越少，越容易缺页
        </span>
       </div>
      </div>
     </li>
     <li>
      页本身的大小：页面越小，越容易缺页
     </li>
     <li>
      程序的编制方法：程序的局部性
     </li>
    </ol>
    <ul>
     <li>
      页面的大小选择：
      <p class="img-center">
       <img alt="" height="267" src="https://i-blog.csdnimg.cn/blog_migrate/314e9546ccbebb4a03c6154f918e0367.png" width="496"/>
      </p>
     </li>
     <li>
      <strong>
       快表机制（cache，联想存储器，TLB）
      </strong>
     </li>
    </ul>
    <div>
     特点：
     <span style="color:#000000;">
      快表是普通页表（慢表）的
     </span>
     <span style="color:#ff0000;">
      部分内容
     </span>
     <span style="color:#000000;">
      的
     </span>
     <span style="color:#0000ff;">
      复制
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      地址映射时
     </span>
     <span style="color:#0000ff;">
      优先
     </span>
     <span style="color:#000000;">
      访问快表，若在快表中找到所需数据，则称为“
     </span>
     <span style="color:#ff0000;">
      命中
     </span>
     <span style="color:#000000;">
      ” 没有命中时，需要访问慢表，同时
     </span>
     <span style="color:#55af84;">
      <strong>
       更新
      </strong>
     </span>
     <span style="color:#ff0000;">
      快表
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      合理的页面调度策略能使快表具有
     </span>
     <span style="color:#55af84;">
      <strong>
       较高
      </strong>
     </span>
     <span style="color:#ff0000;">
      命中率
     </span>
    </div>
    <div>
     <img alt="" height="681" src="https://i-blog.csdnimg.cn/blog_migrate/d2b5f9fe90c18b0a2328371c0d75ea65.png" width="1198"/>
    </div>
    <ul>
     <li>
      <strong>
       二级页表
      </strong>
      ，ppt讲的不够好，看
      <a class="link-info" href="https://blog.csdn.net/qq_41899026/article/details/117330742?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170375670916800211563204%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170375670916800211563204&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-117330742-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6&amp;spm=1018.2226.3001.4187" title="两级页表">
       两级页表
      </a>
     </li>
    </ul>
    <div>
     关键摘要：
    </div>
    <div>
     <img alt="" height="734" src="https://i-blog.csdnimg.cn/blog_migrate/5955966759454c1478ca81f605de5bbb.png" width="1196"/>
    </div>
    <div>
     <p class="img-center">
      <img alt="" height="195" src="https://i-blog.csdnimg.cn/blog_migrate/9d29dd6ae5e336cbaff7cff5929e99d4.png" width="413"/>
     </p>
     <ul>
      <li>
       <strong>
        段式存储管理
       </strong>
       ：把进程按
       <span style="color:#ff0000;">
        逻辑意义
       </span>
       划分为多个
       <span style="color:#ff0000;">
        段
       </span>
       ，每段有
       <span style="color:#ff0000;">
        段名
       </span>
       ，长度不定。进程由
       <span style="color:#0000ff;">
        多段
       </span>
       组成
      </li>
      <li>
       <strong>
        段表
       </strong>
       （SMT，Segment Memory Table）：记录每段在内存中映射的位置
       <img alt="" height="436" src="https://i-blog.csdnimg.cn/blog_migrate/d387aa750f325005e0dbce165dfcfa32.png" width="1140"/>
      </li>
      <li>
       <strong>
        段式系统的虚拟地址
       </strong>
       ：
       <span style="color:#000000;">
        段式虚拟地址
       </span>
       <span style="color:#000000;">
        VA
       </span>
       <span style="color:#000000;">
        包含
       </span>
       <span style="color:#ff0000;">
        段号
       </span>
       <span style="color:#ff0000;">
        S
       </span>
       <span style="color:#000000;">
        和
       </span>
       <span style="color:#ff0000;">
        段内偏移W
       </span>
       <img alt="" height="190" src="https://i-blog.csdnimg.cn/blog_migrate/8221d0cfc43efd01e419105a2a3dc699.png" width="1115"/>
      </li>
      <li>
       <strong>
        段式地址映射过程：
       </strong>
      </li>
     </ul>
     <ol>
      <li>
       <div>
        <span style="color:#000000;">
         逻辑地址
        </span>
        <span style="color:#000000;">
         VA
        </span>
        <span style="color:#000000;">
         分离出
        </span>
        <span style="color:#000000;">
         (
        </span>
        <span style="color:#ff0000;">
         S
        </span>
        <span style="color:#000000;">
         ,
        </span>
        <span style="color:#ff0000;">
         W
        </span>
        <span style="color:#000000;">
         );
        </span>
       </div>
      </li>
      <li>
       <div>
        <span style="color:#000000;">
         以
        </span>
        <span style="color:#000000;">
         S为索引查询段表，检索段号
        </span>
        <span style="color:#000000;">
         S
        </span>
        <span style="color:#000000;">
         ，查询该段
        </span>
        <span style="color:#ff0000;">
         基地址
        </span>
        <span style="color:#000000;">
         B
        </span>
        <span style="color:#000000;">
         和
        </span>
        <span style="color:#ff0000;">
         长度
        </span>
        <span style="color:#000000;">
         L
        </span>
        <span style="color:#000000;">
         。
        </span>
       </div>
      </li>
      <li>
       <div>
        物理地址MA = B + W
       </div>
      </li>
     </ol>
    </div>
    <div>
     <img alt="" height="674" src="https://i-blog.csdnimg.cn/blog_migrate/0ed8fe254d9aefa0ae98281217269cb1.png" width="1178"/>
     <img alt="" height="544" src="https://i-blog.csdnimg.cn/blog_migrate/e4b2ba0fafc2d4389c61bbca7a5bfe66.png" width="1178"/>
    </div>
    <ul>
     <li>
      <strong>
       段式管理与页式管理的对比
      </strong>
      ：
      <img alt="" height="535" src="https://i-blog.csdnimg.cn/blog_migrate/f2972d0effd705f38b6887c76254d95a.png" width="1154"/>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         段页式存储管理：
        </strong>
        在段式存储管理中结合页式存储管理技术
       </span>
      </div>
     </li>
     <li>
      <strong>
       段页式地址
      </strong>
      ：
      <span style="color:#000000;">
       段号
      </span>
      <span style="color:#0000ff;">
       S
      </span>
      <span style="color:#000000;">
       、页号
      </span>
      <span style="color:#0000ff;">
       P
      </span>
      <span style="color:#000000;">
       和页内位移
      </span>
      <span style="color:#0000ff;">
       W
      </span>
      <img alt="" height="637" src="https://i-blog.csdnimg.cn/blog_migrate/d5cf5dd95956bd83764d874f332d2254.png" width="1096"/>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         段页式地址的映射机构：
        </strong>
        同时采用
       </span>
       <span style="color:#ff3300;">
        段表
       </span>
       <span style="color:#000000;">
        和
       </span>
       <span style="color:#ff3300;">
        页表
       </span>
       <span style="color:#000000;">
        实现地址映射
       </span>
      </div>
     </li>
    </ul>
    <div>
     <span style="color:#000000;">
      系统为每个进程建立一个
     </span>
     <span style="color:#ff0000;">
      段表
     </span>
     <span style="color:#000000;">
      ,  每个段建立一个
     </span>
     <span style="color:#ff0000;">
      页表
     </span>
     <span style="color:#000000;">
      ；
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      段表给出每段的
     </span>
     <span style="color:#ff0000;">
      页表基地址
     </span>
     <span style="color:#000000;">
      及
     </span>
     <span style="color:#ff0000;">
      页表长度
     </span>
     <span style="color:#0d0016;">
      ，
     </span>
     <span style="color:#000000;">
      页表给出段内每页对应的
     </span>
     <span style="color:#ff0000;">
      页框
     </span>
     <span style="color:#000000;">
      。
     </span>
    </div>
    <div>
     <img alt="" height="802" src="https://i-blog.csdnimg.cn/blog_migrate/4951761e510bc318ba4f40979aa9c62b.png" width="1150"/>
    </div>
    <ul>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         实模式阶段：
        </strong>
        计算机加电前一段时间处于实模式。
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         <strong>
          实模式内存空间：
         </strong>
         20位物理地址，1MB内存空间。分段机制：段地址(16位) ：偏移地址(16位)
        </span>
       </div>
      </div>
     </li>
    </ul>
    <div>
     <img alt="" height="683" src="https://i-blog.csdnimg.cn/blog_migrate/e9f0ce9103ee6ec2ff9d6f9a31d33729.png" width="1118"/>
    </div>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_45577173/article/details/127430424?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170376552716800182798049%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170376552716800182798049&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-127430424-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%9E%E6%A8%A1%E5%BC%8F&amp;spm=1018.2226.3001.4187" title="X86实模式与保护模式简介">
       X86实模式与保护模式简介
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/ggh19/article/details/113705230?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170377095616800222822942%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170377095616800222822942&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-113705230-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E7%AC%A6&amp;spm=1018.2226.3001.4187" title="操作系统中的描述符和GDT">
       操作系统中的描述符和GDT
      </a>
     </li>
     <li>
     </li>
    </ul>
    <h2 style="background-color:transparent;">
     第八章、设备管理（输入/输出管理）
    </h2>
    <ul>
     <li>
      <strong>
       设备类型和特征
      </strong>
     </li>
    </ul>
    <p>
     按交互对象分类
    </p>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        人机交互：显示设备、键盘、鼠标、打印机
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         与
        </span>
        <span style="color:#000000;">
         CPU
        </span>
        <span style="color:#000000;">
         交互：磁盘、磁带、传感器、控制器
        </span>
       </div>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        计算机间交互：网卡、调制解调器
       </span>
      </div>
     </li>
    </ol>
    <div>
     <div>
      <span style="color:#000000;">
       按交互方向分类
      </span>
     </div>
     <ol>
      <li>
       <div>
        <span style="color:#000000;">
         输入设备：键盘、扫描仪
        </span>
       </div>
      </li>
      <li>
       <div>
        <span style="color:#000000;">
         输出设备：显示设备、打印机
        </span>
       </div>
      </li>
      <li>
       <div>
        <div>
         <span style="color:#000000;">
          双向设备：输入
         </span>
         <span style="color:#000000;">
          /
         </span>
         <span style="color:#000000;">
          输出：硬盘、软盘、网卡
         </span>
        </div>
       </div>
      </li>
     </ol>
    </div>
    <div>
     <span style="color:#000000;">
      按外设特性分类
     </span>
    </div>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        使用特征：存储设备、输入设备、输出设备
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         数据传输率：低速
        </span>
        <span style="color:#000000;">
         (
        </span>
        <span style="color:#000000;">
         键盘
        </span>
        <span style="color:#000000;">
         )
        </span>
        <span style="color:#000000;">
         、中速
        </span>
        <span style="color:#000000;">
         (
        </span>
        <span style="color:#000000;">
         打印机
        </span>
        <span style="color:#000000;">
         )
        </span>
        <span style="color:#000000;">
         、高速
        </span>
        <span style="color:#000000;">
         (
        </span>
        <span style="color:#000000;">
         网卡、磁盘
        </span>
        <span style="color:#000000;">
         )
        </span>
       </div>
      </div>
     </li>
    </ol>
    <div>
     <div>
      <span style="color:#000000;">
       按信息组织特征分类
      </span>
     </div>
     <ol>
      <li>
       <div>
        <span style="color:#000000;">
         字符设备：传输的基本单位是
        </span>
        <span style="color:#0000ff;">
         字符
        </span>
        <span style="color:#000000;">
         。例：键盘、串口
        </span>
       </div>
      </li>
      <li>
       <div>
        块设备：
        <span style="color:#000000;">
         传输的基本单位是
        </span>
        <span style="color:#0000ff;">
         块
        </span>
        <span style="color:#000000;">
         。例：硬盘，磁盘
        </span>
       </div>
      </li>
      <li>
       <div>
        <div>
         <span style="color:#000000;">
          网络设备：采用
         </span>
         <span style="color:#000000;">
          socket套接字接口访问，在全局空间有唯一名字，如
         </span>
         <span style="color:#000000;">
          eth0
         </span>
         <span style="color:#000000;">
          、
         </span>
         <span style="color:#000000;">
          eth1
         </span>
        </div>
       </div>
      </li>
     </ol>
    </div>
    <ul>
     <li>
      设备管理功能
     </li>
    </ul>
    <ol>
     <li>
      状态追踪：记录设备的基本属性
      <img alt="" height="766" src="https://i-blog.csdnimg.cn/blog_migrate/9285a4b64d458cb4ff0aace4a7c98e87.png" width="1200"/>
     </li>
     <li>
      设备分配：
      <span style="color:#000000;">
       按一定策略安全地分配和管理各种设备。
      </span>
      <img alt="" height="792" src="https://i-blog.csdnimg.cn/blog_migrate/10529fbe8f4ad476ced2e34599f087e1.png" width="1200"/>
     </li>
     <li>
      设备映射：
      <span style="color:#000000;">
       逻辑设备到物理设备的转换（逻辑名到物理名的转换）
      </span>
      <img alt="" height="265" src="https://i-blog.csdnimg.cn/blog_migrate/f97dcd4d0050d84d908c2776a165bf3d.png" width="1200"/>
      <img alt="" height="273" src="https://i-blog.csdnimg.cn/blog_migrate/20b1133516d96fcd7336a6aae5cc1c9b.png" width="1200"/>
     </li>
     <li>
      I/O缓冲区管理：
      <span style="color:#000000;">
       开辟和管理
      </span>
      <span style="color:#000000;">
       I/O
      </span>
      <span style="color:#000000;">
       缓冲区，提高读写效率。
      </span>
     </li>
     <li>
      设备驱动：对物理设备进行I/O操作，
      <span style="color:#000000;">
       把应用对设备的读/写请求转换为对设备I/O操作。
      </span>
      <p class="img-center">
       <img alt="" height="337" src="https://i-blog.csdnimg.cn/blog_migrate/63b7546eaaedcb3c1bca252d0ae4c68d.png" width="349"/>
      </p>
     </li>
    </ol>
    <div>
    </div>
    <ul>
     <li>
      <strong>
       缓冲技术作用
      </strong>
     </li>
    </ul>
    <ol>
     <li>
      <div>
       <span style="color:#4da8ee;">
        连接不同数据传输速度的设备
       </span>
       <span style="color:#000000;">
        。如CPU（设备驱动）与设备（控制器）之间传输数据，
       </span>
       <span style="color:#0000ff;">
        改进：内存中增加缓冲区
       </span>
       <img alt="" height="498" src="https://i-blog.csdnimg.cn/blog_migrate/d2ebf03916d2bd32ed0ef28f49858c20.png" width="1200"/>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#4da8ee;">
         协调数据记录大小的不一致。
        </span>
        <span style="color:#0000ff;">
         进程之间
        </span>
        <span style="color:#000000;">
         或
        </span>
        <span style="color:#0000ff;">
         CPU与设备之间
        </span>
        <span style="color:#000000;">
         的数据记录大小不一致
        </span>
        <img alt="" height="578" src="https://i-blog.csdnimg.cn/blog_migrate/a068471461bafede3b9ee4f0e9167692.png" width="1200"/>
        <img alt="" height="711" src="https://i-blog.csdnimg.cn/blog_migrate/a6ff14926949fe52792f2509b6abdd26.png" width="1200"/>
       </div>
      </div>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        正确执行应用程序的语义拷贝。
       </span>
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <span style="color:#000000;">
       Linux缓冲机制应用：
      </span>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="263" src="https://i-blog.csdnimg.cn/blog_migrate/635b888e808bb540a659cffb037cb77d.png" width="293"/>
    </p>
    <ol>
     <li>
      <div>
       <span style="color:#000000;">
        提前读：进程读时，其所需数据已被
       </span>
       <span style="color:#ff0000;">
        提前读
       </span>
       <span style="color:#000000;">
        到了
       </span>
       <span style="color:#0000ff;">
        缓冲区
       </span>
       <span style="color:#000000;">
        中，不需要启动外设去执行读操作。
       </span>
      </div>
     </li>
     <li>
      <div>
       <div>
        <span style="color:#000000;">
         延后写：进程写时，数据先存在缓冲区，等到
        </span>
        <span style="color:#0000ff;">
         特定事件发生
        </span>
        <span style="color:#000000;">
         或
        </span>
        <span style="color:#0000ff;">
         足够时间
        </span>
        <span style="color:#000000;">
         后（
        </span>
        <span style="color:#ff0000;">
         已延迟
        </span>
        <span style="color:#000000;">
         ），再启动外设完成写入。
        </span>
       </div>
      </div>
     </li>
    </ol>
    <div>
     <img alt="" height="618" src="https://i-blog.csdnimg.cn/blog_migrate/5c41d854f262b53c98ed5f1a8fe03b49.png" width="1200"/>
    </div>
    <ul>
     <li>
      <strong>
       缓冲的组成
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      Cache：
      <span style="color:#000000;">
       高速缓冲寄存器
      </span>
      <span style="color:#0000ff;">
       【
      </span>
      <span style="color:#0000ff;">
       CPU ↔
      </span>
      <span style="color:#0000ff;">
       内存】
      </span>
     </li>
     <li>
      <span style="color:#000000;">
       设备内部缓冲区：外设或
      </span>
      <span style="color:#000000;">
       I/O
      </span>
      <span style="color:#000000;">
       接口的内部缓冲区
      </span>
      <span style="color:#0000ff;">
       【端口】
      </span>
     </li>
     <li>
      <span style="color:#0d0016;">
       内存缓冲区：应用广泛，
      </span>
      <span style="color:#000000;">
       使用灵活
      </span>
      <span style="color:#0000ff;">
       【
      </span>
      <span style="color:#0000ff;">
       CPU ↔
      </span>
      <span style="color:#0000ff;">
       接口
      </span>
      <span style="color:#0000ff;">
       /外设】，
      </span>
      <span style="color:#000000;">
       应用开辟
      </span>
      <span style="color:#000000;">
       |
      </span>
      <span style="color:#c00000;">
       内核开辟
      </span>
     </li>
     <li>
      <span style="color:#0d0016;">
       辅存缓冲区：
      </span>
      <span style="color:#000000;">
       开辟在辅存上
      </span>
      <span style="color:#0000ff;">
       【 暂存内存数据，
      </span>
      <span style="color:#c00000;">
       SWAP
      </span>
      <span style="color:#0000ff;">
       】
      </span>
     </li>
    </ol>
    <ul>
     <li>
      <span style="color:#0d0016;">
       缓冲的实现
      </span>
     </li>
    </ul>
    <ol>
     <li>
      <span style="color:#0d0016;">
       单缓冲：缓冲区仅有1个单元
      </span>
      <img alt="" height="373" src="https://i-blog.csdnimg.cn/blog_migrate/0e930ce200fa0fccf747b1a65acb5819.png" width="1168"/>
     </li>
     <li>
      双缓冲：缓冲区有2个单元
      <img alt="" height="635" src="https://i-blog.csdnimg.cn/blog_migrate/e587b24d567e5d25904a0c50d1d872f5.png" width="1116"/>
     </li>
     <li>
      环形缓冲：
      <span style="color:#000000;">
       在双缓冲的基础上增加了更多的单元，并让首尾两个单元在逻辑上相连。
      </span>
      <img alt="" height="443" src="https://i-blog.csdnimg.cn/blog_migrate/f618a2d5414dadfdc49614c9473a40ea.png" width="1086"/>
     </li>
     <li>
      缓冲池：
      <span style="color:#000000;">
       多个缓冲区，可供若干个进程共享，可以支持输入，也可以支持输出，
      </span>
      <span style="color:#0000ff;">
       提高缓冲区利用率，减少内存浪费
      </span>
     </li>
    </ol>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/ChenGuiGan/article/details/84305576?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170385437816800180624019%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170385437816800180624019&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-84305576-null-null.142%5Ev99%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FLinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8&amp;spm=1018.2226.3001.4187" title="浅谈设备驱动的作用与本质，有无操作系统Linux设备驱动的区别">
       浅谈设备驱动的作用与本质，有无操作系统Linux设备驱动的区别
      </a>
     </li>
     <li>
      设备文件：
      <span style="color:#000000;">
       硬件设备作为
      </span>
      <span style="color:#ff0000;">
       文件
      </span>
      <span style="color:#000000;">
       看待，使用
      </span>
      <span style="color:#0000ff;">
       文件操作接口
      </span>
      <span style="color:#000000;">
       来完成设备的打开、关闭、读写和
      </span>
      <span style="color:#000000;">
       I/O控制等操作。仅字符设备和块设备通过
      </span>
      <span style="color:#ff0000;">
       设备文件
      </span>
      <span style="color:#000000;">
       访问，创建设备文件：
      </span>
      <span style="color:#ff0000;">
       mknod。
      </span>
     </li>
     <li>
      <span style="color:#0d0016;">
       <strong>
        主设备号：
       </strong>
      </span>
      <span style="color:#000000;">
       标识该设备种类，标识驱动程序主，设备号的范围：
      </span>
      <span style="color:#ff0000;">
       1-255，
      </span>
      <span style="color:#000000;">
       Linux
      </span>
      <span style="color:#000000;">
       内核支持
      </span>
      <span style="color:#ff0000;">
       动态分配主设备号
      </span>
     </li>
     <li>
      <span style="color:#0d0016;">
       <strong>
        次设备号
       </strong>
       ：
      </span>
      <span style="color:#000000;">
       标识同一设备驱动程序的不同硬件设备
      </span>
     </li>
     <li>
      <strong>
       设备分类：
      </strong>
     </li>
    </ul>
    <ol>
     <li>
      独占设备：
      <span style="color:#000000;">
       不可抢占设备
      </span>
      <span style="color:#0000ff;">
       （普通外设或资源），
      </span>
      <span style="color:#000000;">
       使用时
      </span>
      <span style="color:#0000ff;">
       独占
      </span>
      <span style="color:#000000;">
       ，
      </span>
      <span style="color:#0000ff;">
       释放后
      </span>
      <span style="color:#000000;">
       才能被其它进程申请到。先申请，后使用
      </span>
      <span style="color:#c00000;">
       （主动）
      </span>
     </li>
     <li>
      共享设备：
      <span style="color:#000000;">
       可抢占设备
      </span>
      <span style="color:#0000ff;">
       （
      </span>
      <span style="color:#0000ff;">
       CPU，内存，硬盘），
      </span>
      <span style="color:#000000;">
       允许多个作业或进程
      </span>
      <span style="color:#0000ff;">
       同时
      </span>
      <span style="color:#000000;">
       使用。不申请，直接用
      </span>
      <span style="color:#c00000;">
       （被动
      </span>
      <span style="color:#c00000;">
       +
      </span>
      <span style="color:#c00000;">
       主动）
      </span>
     </li>
     <li>
      虚拟设备：
      <span style="color:#000000;">
       借助虚拟技术，在共享设备上模拟独占设备。
      </span>
     </li>
    </ol>
    <ul>
     <li>
      <span style="color:#000000;">
       <strong>
        设备分配方法
       </strong>
       ：
      </span>
     </li>
    </ul>
    <ol>
     <li>
      独享分配：
      <span style="color:#000000;">
       针对独占设备。
      </span>
      <p class="img-center">
       <img alt="" height="129" src="https://i-blog.csdnimg.cn/blog_migrate/40a958b2786fe3272e0b2aba433b0c43.png" width="476"/>
      </p>
     </li>
     <li>
      共享分配：针对共享设备，
      <span style="color:#000000;">
       典型共享设备：硬盘。
      </span>
      <p class="img-center">
       <img alt="" height="136" src="https://i-blog.csdnimg.cn/blog_migrate/e2f14a0daf8e2a054777dd66d50b5e8d.png" width="478"/>
      </p>
     </li>
     <li>
      虚拟分配：
     </li>
    </ol>
    <p>
     虚拟技术：
     <span style="color:#000000;">
      在一类物理设备上模拟另一类物理设备的技术，通常借助
     </span>
     <span style="color:#0000ff;">
      辅存部分区域
     </span>
     <span style="color:#000000;">
      模拟独占设备，将独占设备转化为共享设备。
     </span>
    </p>
    <p>
     虚拟设备：
     <span style="color:#000000;">
      用来模拟独占设备的
     </span>
     <span style="color:#c00000;">
      辅存区域
     </span>
     <span style="color:#000000;">
      称为
     </span>
     <span style="color:#0000ff;">
      虚拟设备，
     </span>
     <span style="color:#000000;">
      具有独占设备的逻辑特点
     </span>
    </p>
    <p>
     输入井：
     <span style="color:#000000;">
      模拟输入设备的辅存区域
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      输出井：模拟输出设备的辅存区域
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="369" src="https://i-blog.csdnimg.cn/blog_migrate/1da4f351bea01be42fc6cebcc4c2a708.png" width="603"/>
    </p>
    <ul>
     <li>
      <div>
       <span style="color:#000000;">
        <strong>
         SPOOLing
        </strong>
       </span>
       <span style="color:#000000;">
        <strong>
         系统：
        </strong>
       </span>
      </div>
     </li>
    </ul>
    <div>
     <img alt="" height="546" src="https://i-blog.csdnimg.cn/blog_migrate/6125d25493e579e19dfea49bc1eb3334.png" width="1076"/>
    </div>
    <div>
    </div>
    <ol>
     <li>
      预输入程序：
      <span style="color:#000000;">
       控制信息从独占设备输入到辅存，模拟脱机输入的卫星机。
      </span>
     </li>
     <li>
      输入表：
      <span style="color:#000000;">
       独占设备
      </span>
      <span style="color:#000000;">
       ↔
      </span>
      <span style="color:#000000;">
       虚拟设备
      </span>
     </li>
     <li>
      缓输出程序：
      <span style="color:#000000;">
       控制信息从辅存输出到独占设备，模拟脱机输出的卫星机；
      </span>
     </li>
     <li>
      输出表：
      <span style="color:#000000;">
       独占设备
      </span>
      <span style="color:#000000;">
       ↔
      </span>
      <span style="color:#000000;">
       虚拟设备
      </span>
     </li>
     <li>
      井管理程序：
      <span style="color:#000000;">
       控制用户程序和辅存之间的信息交换
      </span>
      <img alt="" height="643" src="https://i-blog.csdnimg.cn/blog_migrate/34048d13b7be87e3c989b2cdf94db8f0.png" width="1076"/>
     </li>
    </ol>
    <h2>
     第九章、文件系统
    </h2>
    <ul>
     <li>
      <strong>
       文件
      </strong>
      ：文件是计算机系统存放信息的一种形式，由若干信息项有序构成。文件具有唯一的文件名，用户
      <span style="color:#000000;">
       通过
      </span>
      <span style="color:#0000ff;">
       读写指针
      </span>
      <span style="color:#000000;">
       来存取文件的信息项。
      </span>
      <img alt="" height="309" src="https://i-blog.csdnimg.cn/blog_migrate/3e0c9dab3d0755e6a9ece88a3cf1ca05.png" width="1200"/>
     </li>
     <li>
      <strong>
       文件分类：
      </strong>
     </li>
    </ul>
    <ol>
     <li>
      按文件的用途：系统文件，库文件，用户文件。
     </li>
     <li>
      按文件的操作权限：只读文件，只写文件，可执行文件，可读可写文件，不保护文件
     </li>
     <li>
      按文件的存储时间：临时文件，永久文件
     </li>
    </ol>
    <ul>
     <li>
      <strong>
       文件系统
      </strong>
      ：管理文件的机构。
     </li>
    </ul>
    <div>
     <span style="color:#000000;">
      实现文件的创建、撤消、读写、修改、复制和存取控制等，方便用户以
     </span>
     <span style="color:#0000ff;">
      文件名
     </span>
     <span style="color:#000000;">
      存取文件
     </span>
    </div>
    <div>
     <div>
      <span style="color:#000000;">
       管理文件
      </span>
      <span style="color:#0000ff;">
       存储设备
      </span>
      <span style="color:#000000;">
       的空间和存取。高效利用存储空间和高效存取文件
      </span>
     </div>
    </div>
    <ul>
     <li>
      <strong>
       文件的逻辑结构
      </strong>
      ：
     </li>
    </ul>
    <p>
     1.
     <span style="color:#000000;">
      记录式文件：信息项是
     </span>
     <span style="color:#0000ff;">
      记录
     </span>
     <span style="color:#000000;">
      ，记录包含若干成员。例如：学生花名册
     </span>
     <span style="color:#000000;">
      .txt，记录姓名，学号，性别，成绩。
     </span>
    </p>
    <p>
     特点：
     <span style="color:#000000;">
      文件头部保存
     </span>
     <span style="color:#0000ff;">
      记录长
     </span>
     <span style="color:#000000;">
      和
     </span>
     <span style="color:#0000ff;">
      记录数
     </span>
     <span style="color:#000000;">
      信息，浪费存储空间
     </span>
    </p>
    <p>
     分类：定长记录文件，不定长文件
    </p>
    <p>
     2. 流式文件：信息项是字节
    </p>
    <p>
     特点：
     <span style="color:#000000;">
      文件长度就是字节的数量，文件无需额外说明信息或控制信息
     </span>
    </p>
    <ul>
     <li>
      <strong>
       文件的存取方法
      </strong>
      ：
     </li>
    </ul>
    <ol>
     <li>
      顺序存取：
      <span style="color:#000000;">
       按从前到后的顺序
      </span>
      <span style="color:#0000ff;">
       依次
      </span>
      <span style="color:#000000;">
       对文件
      </span>
      <span style="color:#0000ff;">
       信息项
      </span>
      <span style="color:#000000;">
       进行读
      </span>
      <span style="color:#000000;">
       /写，直到定位到目标信息项为止。
      </span>
     </li>
     <li>
      <div>
       <span style="color:#000000;">
        随机存取
       </span>
       <span style="color:#000000;">
        /直接访问：直接
       </span>
       <span style="color:#0000ff;">
        定位
       </span>
       <span style="color:#000000;">
        到文件目标信息项进行读
       </span>
       <span style="color:#000000;">
        /写。适合
       </span>
       <span style="color:#0000ff;">
        流式文件
       </span>
       <span style="color:#000000;">
        或
       </span>
       <span style="color:#0000ff;">
        定长记录文件
       </span>
       <span style="color:#000000;">
        。
       </span>
      </div>
     </li>
    </ol>
    <ul>
     <li>
      <div>
       文件的物理结构：
       <span style="color:#000000;">
        文件在存储设备上的存储结构，
       </span>
       <span style="color:#0000ff;">
        强调合理利用储存空间，缩短I/O时间
       </span>
      </div>
     </li>
    </ul>
    <div>
     <span style="color:#0000ff;">
     </span>
     <span style="color:#0d0016;">
      1.
     </span>
     连续文件：
     <span style="color:#000000;">
      指文件存放在
     </span>
     <span style="color:#0000ff;">
      连续的存储块
     </span>
     <span style="color:#000000;">
      中。文件的存储块顺序与逻辑块顺序一致且连续。
     </span>
    </div>
    <div>
     <div>
      <span style="color:#000000;">
       文件目录记录
      </span>
      <span style="color:#0000ff;">
       文件长度
      </span>
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#000000;">
       块数
      </span>
      <span style="color:#000000;">
       )
      </span>
      <span style="color:#000000;">
       和
      </span>
      <span style="color:#0000ff;">
       首个存储块号
      </span>
     </div>
     <div>
      <img alt="" height="582" src="https://i-blog.csdnimg.cn/blog_migrate/1184dc67b19f20aa83f291073f219efb.png" width="1200"/>
     </div>
     <div>
      特点：
      <span style="color:#000000;">
       文件建立时给出文件
      </span>
      <span style="color:#0000ff;">
       最大长度
      </span>
      <span style="color:#000000;">
       和
      </span>
      <span style="color:#0000ff;">
       文件起始位置
      </span>
      <span style="color:#000000;">
       。支持顺序存取和随机存取。其中顺序存取速度快
      </span>
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#000000;">
       寻道次数和寻道时间最少
      </span>
      <span style="color:#000000;">
       )
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       缺点：文件不易动态增长，预留空间容易造成浪费，造成外部碎片问题
      </span>
     </div>
     <div>
     </div>
     <div>
      <span style="color:#000000;">
       2. 串联文件：存放在
      </span>
      <span style="color:#0000ff;">
       离散的存储块
      </span>
      <span style="color:#000000;">
       中，每个存储块包含一个
      </span>
      <span style="color:#0000ff;">
       链接指针
      </span>
      <span style="color:#000000;">
       记录下一个存储块位置。文件目录记录文件
      </span>
      <span style="color:#0000ff;">
       首个存储块号
      </span>
      <img alt="" height="567" src="https://i-blog.csdnimg.cn/blog_migrate/1f7abe787eea96a369881c570d71dedb.png" width="1200"/>
     </div>
     <div>
      特点：串联文件可以显著消除存储碎片，创建文件时无需知道文件长度，文件动态增长时可动态分配存储块，
      <span style="color:#000000;">
       支持文件增、删、改等操作。
      </span>
     </div>
    </div>
    <div>
     缺点：
     <span style="color:#000000;">
      随机访问效率极低
     </span>
     <span style="color:#000000;">
      (仅适合顺序访问方式），并且如果某个
     </span>
     <span style="color:#0000ff;">
      链接指针损坏
     </span>
     <span style="color:#000000;">
      ，文件后面将无法访问。
     </span>
     <img alt="" height="345" src="https://i-blog.csdnimg.cn/blog_migrate/be42ea216f7c6c442bfe509bce4ee1a0.png" width="1110"/>
    </div>
    <p>
     <strong>
      FAT文件系统：
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="337" src="https://i-blog.csdnimg.cn/blog_migrate/5f80ed2af19164f4842f0577b2bbcbeb.png" width="590"/>
    </p>
    <div>
     <p class="img-center">
      <img alt="" height="321" src="https://i-blog.csdnimg.cn/blog_migrate/24372e0522c0c53ef2d2d68053e6beb5.png" width="603"/>
     </p>
     3. 索引文件：文件存放在不连续的存储块中，系统建立
     <span style="color:#1a439c;">
      索引表
     </span>
     <span style="color:#0d0016;">
      记录文件
     </span>
     <span style="color:#0000ff;">
      逻辑块
     </span>
     和
     <span style="color:#0000ff;">
      存储块
     </span>
     的对应关系。
     <u>
      索引文件 = 索引表 + 数据区
     </u>
     <img alt="" height="638" src="https://i-blog.csdnimg.cn/blog_migrate/fb1afdd5ca36f9db24797aaed32cc6e4.png" width="1200"/>
     <p>
      特点：
      <span style="color:#000000;">
       读取索引文件时应先读取
      </span>
      <span style="color:#0000ff;">
       索引表，
      </span>
      <span style="color:#000000;">
       索引表本身占据额外的存储区域
      </span>
      <span style="color:#0000ff;">
       /缺点，
      </span>
      <span style="color:#000000;">
       支持顺序和随机存取，支持文件动态增长、插入、删除等。实例：
      </span>
      <span style="color:#000000;">
       ext
      </span>
      <span style="color:#000000;">
       系列文件系统
      </span>
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#0000ff;">
       inode
      </span>
      <span style="color:#0000ff;">
       索引节点文件
      </span>
      <span style="color:#000000;">
       )
      </span>
     </p>
     <ul>
      <li>
       <div>
        <span style="color:#000000;">
         <strong>
          磁盘空闲存储块管理方法：
         </strong>
        </span>
       </div>
      </li>
     </ul>
     <div>
      1. 空闲文件目录：
     </div>
     <div>
      空闲文件：
      <span style="color:#0000ff;">
       连续的空闲存储块
      </span>
      <span style="color:#000000;">
       组成的特殊文件。存储设备上所有的空闲文件就代表了存储设备上的全部空闲空间。
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       空闲文件目录：为所有空闲文件建立的目录，记录空闲文件的首块号和存储块数
      </span>
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#c00000;">
       或其他方式
      </span>
      <span style="color:#000000;">
       )
      </span>
      <img alt="" height="491" src="https://i-blog.csdnimg.cn/blog_migrate/270ce9a37e60592b39a7aaf122941128.png" width="1200"/>
     </div>
     <div>
     </div>
     <div>
      2. 空闲块链：
      <span style="color:#000000;">
       把所有空闲存储块用
      </span>
      <span style="color:#0000ff;">
       链表
      </span>
      <span style="color:#000000;">
       链接在一起。
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       当
      </span>
      <span style="color:#0000ff;">
       申请
      </span>
      <span style="color:#000000;">
       空闲块时，从链表
      </span>
      <span style="color:#0000ff;">
       头部
      </span>
      <span style="color:#000000;">
       摘取空闲块。
      </span>
     </div>
     <div>
      <span style="color:#000000;">
       当
      </span>
      <span style="color:#0000ff;">
       回收
      </span>
      <span style="color:#000000;">
       存储块时，把空闲块加在链表
      </span>
      <span style="color:#0000ff;">
       尾部。
      </span>
      <img alt="" height="459" src="https://i-blog.csdnimg.cn/blog_migrate/a204ccb0d369d1630d532fd0f5020d70.png" width="1180"/>
     </div>
     <div>
     </div>
     <div>
      3. 位示图：
      <span style="color:#000000;">
       一块特殊内存区域，
      </span>
      <span style="color:#0000ff;">
       每一位
      </span>
      <span style="color:#000000;">
       (bit)
      </span>
      <span style="color:#000000;">
       对应一个
      </span>
      <span style="color:#0000ff;">
       存储块
      </span>
      <span style="color:#000000;">
       ，值1
      </span>
      <span style="color:#000000;">
       表示存储块
      </span>
      <span style="color:#ff0000;">
       空闲
      </span>
      <span style="color:#000000;">
       ，
      </span>
      <span style="color:#000000;">
       0
      </span>
      <span style="color:#000000;">
       表示
      </span>
      <span style="color:#ff0000;">
       已占用。
      </span>
      <img alt="" height="592" src="https://i-blog.csdnimg.cn/blog_migrate/a0b9bf5c84f37e91e4380df6c655069f.png" width="1200"/>
     </div>
     <ul>
      <li>
       <strong>
        文件目录：
       </strong>
      </li>
     </ul>
     <p>
      文件目录功能：
      <span style="color:#000000;">
       实现“
      </span>
      <span style="color:#0000ff;">
       按名存取
      </span>
      <span style="color:#000000;">
       ” ：系统根据文件名能找到指定文件。文件目录记录文件的
      </span>
      <span style="color:#0000ff;">
       文件名
      </span>
      <span style="color:#000000;">
       、
      </span>
      <span style="color:#0000ff;">
       存放地址
      </span>
      <span style="color:#000000;">
       以及
      </span>
      <span style="color:#0000ff;">
       属性。
      </span>
     </p>
     <p>
      <span style="color:#0d0016;">
       目录文件：
      </span>
      <span style="color:#000000;">
       目录文件是文件目录的实现，由
      </span>
      <span style="color:#0000ff;">
       文件目录项
      </span>
      <span style="color:#000000;">
       构成
      </span>
     </p>
    </div>
    <div>
     文件目录项
     <span style="color:#000000;">
      （
     </span>
     <span style="color:#000000;">
      directory entry）：描述文件基本信息、使用信息和存取控制信息等。
     </span>
    </div>
    <div>
     <span style="color:#000000;">
      基本信息：文件名、存储位置
     </span>
     <span style="color:#0000ff;">
      (
     </span>
     <span style="color:#0000ff;">
      存储块号
     </span>
     <span style="color:#0000ff;">
      )
     </span>
     <span style="color:#000000;">
      等
     </span>
    </div>
    <div>
     使用信息：属性、大小、建立时间、修改时间等
    </div>
    <div>
     存取控制信息：文件存取权限
     <p class="img-center">
      <img alt="" height="254" src="https://i-blog.csdnimg.cn/blog_migrate/08cab551ec788f0783eae7a0937a7d2f.png" width="511"/>
     </p>
    </div>
    <div>
     <p class="img-center">
      <img alt="" height="312" src="https://i-blog.csdnimg.cn/blog_migrate/a8f416fdb821260b38eb04d848d080ec.png" width="535"/>
     </p>
     <ul>
      <li>
       <strong>
        目录结构
       </strong>
       ：
      </li>
     </ul>
     <p>
      1. 单机目录：
      <span style="color:#000000;">
       最简单的目录结构，全部文件都登记在同一目录中。
      </span>
     </p>
     <p>
      特点：简单、易于理解和实现
     </p>
     <p>
      缺点：查找速度慢，不允许重名，不便于文件共享
      <img alt="" height="501" src="https://i-blog.csdnimg.cn/blog_migrate/4bdce09b96dedf5bead23f477bd102f0.png" width="1200"/>
     </p>
     <p>
      2. 二级目录：
      <span style="color:#000000;">
       第一级称为主目录
      </span>
      <span style="color:#000000;">
       (MFD)
      </span>
      <span style="color:#000000;">
       ，第二级称为子目录或用户目
      </span>
      <span style="color:#000000;">
       (UFD)。每个用户有一个子目录
      </span>
      <span style="color:#000000;">
       (
      </span>
      <span style="color:#000000;">
       用户目录
      </span>
      <span style="color:#000000;">
       )
      </span>
     </p>
     <p>
      <span style="color:#000000;">
       优点：解决文件重名的问题，不同用户可以使用相同的名字
      </span>
     </p>
     <p class="img-center">
      <img alt="" height="242" src="https://i-blog.csdnimg.cn/blog_migrate/b7d29438eed4093bfdb13e314fb2c9e5.png" width="610"/>
     </p>
    </div>
    <div>
     <p class="img-center">
      <img alt="" height="278" src="https://i-blog.csdnimg.cn/blog_migrate/74d934753a866e22abec163f78a6fbb3.png" width="561"/>
     </p>
     <p>
      3. 树形目录：
      <span style="color:#000000;">
       多级目录结构，二级目录结构的扩充，目录结构如同倒置的树，树根是主目录
      </span>
      <span style="color:#000000;">
       (根目录)，枝结点是子目录，树叶描述文件。
      </span>
     </p>
     <p class="img-center">
      <img alt="" height="329" src="https://i-blog.csdnimg.cn/blog_migrate/dd8cf356c884f7f5d0caaebd06cd68f0.png" width="549"/>
     </p>
     <p class="img-center">
      <img alt="" height="293" src="https://i-blog.csdnimg.cn/blog_migrate/90e4d0375a93fec5d86ac5d406ede66a.png" width="517"/>
     </p>
     <ul>
      <li>
       <strong>
        文件全名
       </strong>
       ：
       <span style="color:#000000;">
        从根目录到文件为止整个通路上所有目录、子目录和文件的名字用
       </span>
       <span style="color:#000000;">
        ”/”
       </span>
       <span style="color:#000000;">
        顺序连接构成的字符串称为
       </span>
       <span style="color:#0000ff;">
        文件全名。
       </span>
      </li>
      <li>
       <strong>
        路径名
       </strong>
       ：文件全名中由目录和子目录组成的部分。每个文件都有唯一的路径名
      </li>
     </ul>
     <p>
      绝对路径名：
      <span style="color:#000000;">
       从
      </span>
      <span style="color:#0000ff;">
       根目录
      </span>
      <span style="color:#000000;">
       直到文件的路径
      </span>
     </p>
     <p>
      <span style="color:#000000;">
       相对路径名：从
      </span>
      <span style="color:#0000ff;">
       指定目录
      </span>
      <span style="color:#000000;">
       到文件的路径
      </span>
     </p>
    </div>
    <ul>
     <li>
      文件属性：
      <span style="color:#000000;">
       指定文件的类型、操作特性和存取保护等信息，一般存放在文件的（
      </span>
      <span style="color:#0000ff;">
       目录 /文件
      </span>
      <span style="color:#000000;">
       ）中。比如
      </span>
      MS-DOS的文件目录项，
      <span style="color:#0000ff;">
       文件属性
      </span>
      <span style="color:#c00000;">
       （特指读
      </span>
      写/隐藏等属性）占1个字节
     </li>
    </ul>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <h3>
     其他资料：
    </h3>
    <ul>
     <li>
      <a class="link-info" href="https://blog.csdn.net/m0_63222058/article/details/131341305?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-131341305.142%5Ev96%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187" title="【爆肝四万字！操作系统原理95+】期末考试知识点超超全总结">
       【爆肝四万字！操作系统原理95+】期末考试知识点超超全总结
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_44622401/article/details/119718780?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170355871616800215056326%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170355871616800215056326&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-119718780-null-null.142%5Ev96%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&amp;spm=1018.2226.3001.4187" title="操作系统期末考试重点总结【全】">
       操作系统期末考试重点总结【全】
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/guoxuying/article/details/112505662?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170355871616800215056326%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170355871616800215056326&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112505662-null-null.142%5Ev96%5Epc_search_result_base2&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&amp;spm=1018.2226.3001.4187" title="操作系统期末考试重点知识">
       操作系统期末考试重点知识
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_46106285/article/details/121588990" title="华中科技大学操作系统慕课答案-单元作业+第1~2章开放性思考题">
       华中科技大学操作系统慕课答案-单元作业+第1~2章开放性思考题
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_46106285/article/details/121127950" title="华中科技大学操作系统慕课答案-第1~3章单元测试">
       华中科技大学操作系统慕课答案-第1~3章单元测试
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_46106285/article/details/121599790?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170202524516800185852116%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170202524516800185852116&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-121599790-null-null.142%5Ev96%5Epc_search_result_base2&amp;utm_term=%E5%8D%8E%E4%B8%AD%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%85%95%E8%AF%BE&amp;spm=1018.2226.3001.4187" title="华中科技大学操作系统慕课答案-第4~6章+第7章单元测试">
       华中科技大学操作系统慕课答案-第4~6章+第7章单元测试
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_44861675/article/details/111609000?utm_source=app&amp;app_version=4.21.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen" title="第五、六、七章、线程+进程调度+存储管理">
       第五、六、七章、线程+进程调度+存储管理
      </a>
     </li>
     <li>
      <a class="link-info" href="https://blog.csdn.net/qq_46106285/article/details/121954487" title="华中科技大学操作系统慕课答案-期末测试题">
       华中科技大学操作系统慕课答案-期末测试题
      </a>
     </li>
    </ul>
   </div>
  </div>
 </article>
</div>


<p class="artid" style="display:none">68747470:733a2f2f626c6f672e6373646e2e6e65742f6b6a6e7364672f:61727469636c652f64657461696c732f313335323134363430
