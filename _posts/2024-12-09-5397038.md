---
layout: post
title: "协程三篇之一协程初接触"
date: 2024-12-09 08:22:22 +0800
description: "赖勇浩（http://laiyonghao.com）协程，又称微线程和纤程等，据说源于 Simula"
keywords: "qt协程"
categories: ['C']
tags: ['跨平台', '语言', '编程', '游戏', '数据结构', '多线程']
artid: "5397038"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=5397038
    alt: "协程三篇之一协程初接触"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     协程三篇之一（协程初接触）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     赖勇浩（http://laiyonghao.com）
    </p>
    <p>
     <img alt="" height="373" src="http://hi.csdn.net/attachment/201003/19/821_1268989808rAMY.png" width="548">
     </img>
    </p>
    <p>
     协程，又称微线程和纤程等，据说源于 Simula 和 Modula-2 语言（我没有深究，有错请指正），现代编程语言基本上都有支持，比如 Lua、ruby 和最新的 Google Go，当然也还有最近很让我惊艳的 falcon。协程是用户空间线程，操作系统其存在一无所知，所以需要用户自己去做调度，用来执行协作式多任务非常合适。其实用协程来做的东西，用线程或进程通常也是一样可以做的，但往往多了许多加锁和通信的操作。
    </p>
    <p>
    </p>
    <p>
     下面是生产者消费者模型的基于抢占式多线程编程实现（伪代码）：
     <br/>
     // 队列容器
     <br/>
     var q := new queue
     <br/>
     // 消费者线程
     <br/>
     loop
     <br/>
     lock(q)
     <br/>
     get item from q
     <br/>
     unlock(q)
     <br/>
     if item
     <br/>
     use this item
     <br/>
     else
     <br/>
     sleep
     <br/>
     // 生产者线程
     <br/>
     loop
     <br/>
     create some new items
     <br/>
     lock(q)
     <br/>
     add the items to q
     <br/>
     unlock(q)
    </p>
    <p>
    </p>
    <p>
     由以上代码可以看到线程实现至少有两点硬伤：
    </p>
    <p>
    </p>
    <p>
     1、对队列的操作需要有显式/隐式（使用线程安全的队列）的加锁操作。
    </p>
    <p>
    </p>
    <p>
     2、消费者线程还要通过 sleep 把 CPU 资源适时地“谦让”给生产者线程使用，其中的适时是多久，基本上只能静态地使用经验值，效果往往不由人意。
    </p>
    <p>
    </p>
    <p>
     而使用协程可以比较好的解决这个问题，下面来看一下基于协程的生产者消费者模型实现（伪代码）：
     <br/>
     // 队列容器
     <br/>
     var q := new queue
     <br/>
     // 生产者协程
     <br/>
     loop
     <br/>
     while q is not full
     <br/>
     create some new items
     <br/>
     add the items to q
     <br/>
     yield to consume
     <br/>
     // 消费者协程
     <br/>
     loop
     <br/>
     while q is not empty
     <br/>
     remove some items from q
     <br/>
     use the items
     <br/>
     yield to produce
    </p>
    <p>
    </p>
    <p>
     可以从以上代码看到之前的加锁和谦让 CPU 的硬伤不复存在，但也损失了利用多核 CPU 的能力。所以选择线程还是协程，就要看应用场合了。下面简单谈一下协程常见的用武之地，其中之一是状态机，能够产生更高可读性的代码；还有就是并行的角色模型，这在游戏开发中比较常见；以及产生器， 有助于对输入/输出和数据结构的通用遍历。
    </p>
    <p>
    </p>
    <p>
     协程虽然如此之好，看是很长时间以来，因为受到基于堆栈的子例程实现的限制，并没有多少语言在其实语言或库中支持协程，所以线程作为一个替代者（当然，线程也有其超越协程之处）被广泛接受了。但是在今天，很多语言都内建了协程的支持，甚至是 C/C++ 语言。MS Windows 2000 以后的版本，都支持所谓的 Fiber，即纤程，其实就是协程的别称；在开源平台，POSIX 标准也定义了协程相关的标准，GNU Portable Threads 实现了跨平台的用户空间线程，即协程的另一种别称。在这百花齐放的时节，正是我们好好学习和利用它的时机。
    </p>
    <p>
    </p>
    <p>
     接下来我将在第二篇中谈谈游戏中试用协程的三个场合。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6c616e7068616461:792f61727469636c652f64657461696c732f35333937303338" class_="artid" style="display:none">
 </p>
</div>


