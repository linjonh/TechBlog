---
layout: post
title: "操作系统-内存"
date: 2025-01-12 18:08:56 +0800
description: "本文详细探讨了程序的运行机制，指令识别，逻辑地址与实际地址，编译、"
keywords: "操作系统内存"
categories: ['操作系统']
tags: ['操作系统']
artid: "125156266"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=125156266
    alt: "操作系统-内存"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统---内存
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%BA%E5%88%B6-toc" style="margin-left:0px;">
     <a href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%BA%E5%88%B6" rel="nofollow">
      程序运行的机制
     </a>
    </p>
    <p id="%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95---%E6%8C%87%E4%BB%A4%E8%AF%86%E5%88%AB-toc" style="margin-left:40px;">
     <a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95---%E6%8C%87%E4%BB%A4%E8%AF%86%E5%88%AB" rel="nofollow">
      程序的运行方法---指令识别
     </a>
    </p>
    <p id="%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AE%9E%E9%99%85%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;">
     <a href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AE%9E%E9%99%85%E5%9C%B0%E5%9D%80" rel="nofollow">
      逻辑地址和实际地址
     </a>
    </p>
    <p id="%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C-toc" style="margin-left:40px;">
     <a href="#%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C" rel="nofollow">
      写程序到程序运行
     </a>
    </p>
    <p id="%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;">
     <a href="#%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" rel="nofollow">
      装入的三种方式，地址转换
     </a>
    </p>
    <p id="%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;">
     <a href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">
      链接的三种方式
     </a>
    </p>
    <p id="%C2%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;">
     <a href="#%C2%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" rel="nofollow">
      内存管理
     </a>
    </p>
    <p id="%C2%A0%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4-toc" style="margin-left:0px;">
     <a href="#%C2%A0%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4" rel="nofollow">
      内存保护
     </a>
    </p>
    <p id="%E8%AE%BE%E7%BD%AE%E4%B8%8A%E3%80%81%E4%B8%8B%E9%99%90%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:40px;">
     <a href="#%E8%AE%BE%E7%BD%AE%E4%B8%8A%E3%80%81%E4%B8%8B%E9%99%90%E5%AF%84%E5%AD%98%E5%99%A8" rel="nofollow">
      设置上、下限寄存器
     </a>
    </p>
    <p id="%E8%AE%BE%E7%BD%AE%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:40px;">
     <a href="#%E8%AE%BE%E7%BD%AE%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8" rel="nofollow">
      设置重定位寄存器和界地址寄存器
     </a>
    </p>
    <p id="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6-toc" style="margin-left:0px;">
     <a href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6" rel="nofollow">
      内存空间的分配与回收
     </a>
    </p>
    <p id="%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;">
     <a href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F" rel="nofollow">
      连续分配方式
     </a>
    </p>
    <p id="1%E3%80%81%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;">
     <a href="#1%E3%80%81%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F" rel="nofollow">
      1、单一连续分配方式
     </a>
    </p>
    <p id="2%E3%80%81%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-toc" style="margin-left:40px;">
     <a href="#2%E3%80%81%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D" rel="nofollow">
      2、固定分区分配
     </a>
    </p>
    <p id="%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-toc" style="margin-left:40px;">
     <a href="#%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D" rel="nofollow">
      3、动态分区分配
     </a>
    </p>
    <p id="%C2%A02%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%A9%BA%E9%97%B2%E5%8C%BA%E6%9D%A5%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4---%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#%C2%A02%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%A9%BA%E9%97%B2%E5%8C%BA%E6%9D%A5%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4---%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95" rel="nofollow">
      操作系统如何选择空闲区来给进程分配空间---动态分区分配算法
     </a>
    </p>
    <p id="1%E3%80%81%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#1%E3%80%81%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95" rel="nofollow">
      1、首次适应算法
     </a>
    </p>
    <p id="2%E3%80%81%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#2%E3%80%81%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95" rel="nofollow">
      2、最佳适应算法
     </a>
    </p>
    <p id="3%E3%80%81%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#3%E3%80%81%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95" rel="nofollow">
      3、最坏适应算法
     </a>
    </p>
    <p id="4%E3%80%81%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;">
     <a href="#4%E3%80%81%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89" rel="nofollow">
      4、邻近适应算法（循环首次适应算法）
     </a>
    </p>
    <p id="%C2%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;">
     <a href="#%C2%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">
      5、内部碎片和外部碎片的概念
     </a>
    </p>
    <p id="4%E3%80%81%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;">
     <a href="#4%E3%80%81%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86" rel="nofollow">
      4、基本分页存储管理
     </a>
    </p>
    <p id="%E9%A1%B5%E8%A1%A8-toc" style="margin-left:80px;">
     <a href="#%E9%A1%B5%E8%A1%A8" rel="nofollow">
      页表
     </a>
    </p>
    <p id="%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;">
     <a href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96%E6%9C%BA%E5%88%B6" rel="nofollow">
      基本地址变化机制
     </a>
    </p>
    <p id="%E5%85%B7%E6%9C%89%E5%9D%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;">
     <a href="#%E5%85%B7%E6%9C%89%E5%9D%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96%E6%9C%BA%E5%88%B6" rel="nofollow">
      具有块表的基本地址变化机制
     </a>
    </p>
    <p id="3%E3%80%81%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8-toc" style="margin-left:80px;">
     <a href="#3%E3%80%81%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8" rel="nofollow">
      两级页表
     </a>
    </p>
    <p id="5%E3%80%81%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;">
     <a href="#5%E3%80%81%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86" rel="nofollow">
      5、基本分段存储管理
     </a>
    </p>
    <p id="6%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;">
     <a href="#6%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86" rel="nofollow">
      6、段页式存储管理
     </a>
    </p>
    <p id="%C2%A0%C2%A0%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85-toc" style="margin-left:0px;">
     <a href="#%C2%A0%C2%A0%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85" rel="nofollow">
      内存扩充
     </a>
    </p>
    <p id="1%E3%80%81%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF-toc" style="margin-left:40px;">
     <a href="#1%E3%80%81%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF" rel="nofollow">
      1、覆盖技术
     </a>
    </p>
    <p id="2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF-toc" style="margin-left:40px;">
     <a href="#2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF" rel="nofollow">
      2、交换技术
     </a>
    </p>
    <p id="3%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF-toc" style="margin-left:40px;">
     <a href="#3%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF" rel="nofollow">
      3、虚拟内存技术
     </a>
    </p>
    <p id="%C2%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-toc" style="margin-left:80px;">
     <a href="#%C2%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" rel="nofollow">
      虚拟内存
     </a>
    </p>
    <p id="%C2%A0%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;">
     <a href="#%C2%A0%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">
      请求分页管理方式
     </a>
    </p>
    <p id="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95" rel="nofollow">
      页面置换算法
     </a>
    </p>
    <p id="%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89-toc" style="margin-left:80px;">
     <a href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89" rel="nofollow">
      最佳置换算法（OPT）
     </a>
    </p>
    <p id="%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FCFO)-toc" style="margin-left:80px;">
     <a href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FCFO%29" rel="nofollow">
      先进先出置换算法（FCFO)
     </a>
    </p>
    <p id="%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU)-toc" style="margin-left:80px;">
     <a href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU%29" rel="nofollow">
      最近最久未使用置换算法（LRU)
     </a>
    </p>
    <p id="%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK)-toc" style="margin-left:80px;">
     <a href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK%29" rel="nofollow">
      时钟置换算法（CLOCK)
     </a>
    </p>
    <p id="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK)-toc" style="margin-left:80px;">
     <a href="#%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK%29" rel="nofollow">
      改进后的时钟置换算法（CLOCK)
     </a>
    </p>
    <p id="%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-toc" style="margin-left:0px;">
     <a href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5" rel="nofollow">
      页面分配策略
     </a>
    </p>
    <p id="%E9%A9%BB%E7%95%99%E9%9B%86-toc" style="margin-left:40px;">
     <a href="#%E9%A9%BB%E7%95%99%E9%9B%86" rel="nofollow">
      驻留集
     </a>
    </p>
    <p id="%C2%A0%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA-toc" style="margin-left:40px;">
     <a href="#%C2%A0%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA" rel="nofollow">
      调入页面的时机
     </a>
    </p>
    <p id="%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2-toc" style="margin-left:40px;">
     <a href="#%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2" rel="nofollow">
      从何处调入页面
     </a>
    </p>
    <p id="%E9%A1%B5%E9%9D%A2%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89-toc" style="margin-left:40px;">
     <a href="#%E9%A1%B5%E9%9D%A2%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89" rel="nofollow">
      页面抖动（颠簸）
     </a>
    </p>
    <p id="%E5%B7%A5%E4%BD%9C%E9%9B%86-toc" style="margin-left:40px;">
     <a href="#%E5%B7%A5%E4%BD%9C%E9%9B%86" rel="nofollow">
      工作集
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <p>
     <strong>
      内存：
     </strong>
     是存放数据的硬件，所有程序运行时都是要加载进入内存，程序在内存中才可以被CPU处理
    </p>
    <p>
     内存有一个，但是程序不一定只有一个，多个程序的数据存储在一块内存中，如何确定这个程序的数据在内存的哪里存放呢？
    </p>
    <p>
     <strong>
      存储单元：
     </strong>
     类似于酒店的房间，我们可以给内存划分成一个个的房间，这些房间就是存储单元
    </p>
    <p>
     <strong>
      内存地址
     </strong>
     ：为了方便管理，酒店房间会有编号，相应的，内存的存储单元也可以有编号，这个编号就是地址
    </p>
    <p>
     <span style="color:#a2e043;">
      每一个地址对应一个存储单元
     </span>
    </p>
    <p>
     <img alt="" height="490" src="https://i-blog.csdnimg.cn/blog_migrate/be6d879c503512c4d4652157f02215e6.png" width="469"/>
    </p>
    <h2 id="%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%BA%E5%88%B6">
     程序运行的机制
    </h2>
    <h3 id="%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95---%E6%8C%87%E4%BB%A4%E8%AF%86%E5%88%AB">
     程序的运行方法---指令识别
    </h3>
    <p>
     <img alt="" height="733" src="https://i-blog.csdnimg.cn/blog_migrate/c74dbc9a8835b63810245ad76fbb18e6.png" width="1200"/>
    </p>
    <h3 id="%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AE%9E%E9%99%85%E5%9C%B0%E5%9D%80">
     逻辑地址和实际地址
    </h3>
    <p>
     编译时期，程序数据的实际存放地址是未知的，我们知道的只会是逻辑地址
    </p>
    <p>
     例如，逻辑上x的存放地址是0，但是实际存放中0的位置被占有了，那么x就要后移到1，地址1就是实际地址，0就是逻辑地址
    </p>
    <h3 id="%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C">
     写程序到程序运行
    </h3>
    <p>
     <img alt="" height="333" src="https://i-blog.csdnimg.cn/blog_migrate/52870499c5ac1666744a90c744ca5a28.png" width="1200"/>
    </p>
    <p>
     编译： 程序员写好的代码文件会经过编译，形成机器可以识别的二进制语言，这些二进制语言打包在目标文件里（c语言是.o文件，java就是.class文件），这些目标文件有自己独立的逻辑地址
    </p>
    <p>
     链接：链接就是将编译后形成的一组目标文件和其所需的库函数等资源打包到一起，形成一个完整的装入模块，这个装入模块有自己独立的逻辑地址
    </p>
    <p>
     装入：装入就是将链接形成的装入模块放入内存（逻辑地址到物理地址的转化）
    </p>
    <h4 id="%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">
     装入的三种方式，地址转换
    </h4>
    <p>
     <strong>
      1、绝对装入
     </strong>
    </p>
    <p>
     在装入之前，就已经知道程序要在内存中存放的绝对地址
    </p>
    <p>
     <img alt="" height="591" src="https://i-blog.csdnimg.cn/blog_migrate/ad8df23958071b5099ee4165605f9cb6.png" width="848"/>
    </p>
    <p>
     但是，
     <span style="color:#fe2c24;">
      绝对装入只有在单道程序环境下使用
     </span>
     ，因为这时内存只会有一个程序，从而可以知道内存可以装入代码的起始地址，才可以知道其实际地址
    </p>
    <p>
     <strong>
      2、静态重定位
     </strong>
    </p>
    <p>
     <span style="color:#a2e043;">
      装入时就会实现逻辑地址到物理地址的转化
     </span>
     ，装入模块会根据内存的实际情况，自动调整装入位置
    </p>
    <p>
     <img alt="" height="420" src="https://i-blog.csdnimg.cn/blog_migrate/562f1318a90cb56904ca4fa8358895a7.png" width="1168"/>
    </p>
    <p>
     <span style="color:#fe2c24;">
      静态重定位会让内存给作业分配全部空间，如果空间不够，就不能装入作业
     </span>
    </p>
    <p>
     <span style="color:#fe2c24;">
      作业在装入之后，地址空间就不会改变了
     </span>
    </p>
    <p>
     <strong>
      3、动态重定位（现代操作系统）
     </strong>
    </p>
    <p>
     只有
     <span style="color:#a2e043;">
      程序运行时，才会将逻辑地址转化为物理地址
     </span>
    </p>
    <p>
     需要一个重定位寄存器实现
    </p>
    <p>
     <img alt="" height="665" src="https://i-blog.csdnimg.cn/blog_migrate/d3cd6f701479d98bc17ac0bd44fe4966.png" width="1200">
      <span style="color:#fe2c24;">
       允许作业在内存中移动 （作业的重定位寄存器的值更改，那么作业的物理地址也会改变）
      </span>
     </img>
    </p>
    <h4 id="%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">
     链接的三种方式
    </h4>
    <p>
     <strong>
      1、静态链接
     </strong>
    </p>
    <p>
     将目标文件和所需的库函数连接称为一个完整的装入模块（形成一个完整的逻辑地址）之后不再拆开，装入程序将装入模块放入内存
    </p>
    <p>
     <img alt="" height="468" src="https://i-blog.csdnimg.cn/blog_migrate/47d958dabb1a89bf9e4b1ff6a26b014e.png" width="739"/>
    </p>
    <p>
     <strong>
      2、装入时动态链接
     </strong>
    </p>
    <p>
     将目标文件和所需的库函数一边装入内存，一边进行连接
    </p>
    <p>
     <img alt="" height="483" src="https://i-blog.csdnimg.cn/blog_migrate/9ec11012b8ff29d868068f0921d5d13e.png" width="666"/>
    </p>
    <p>
     <strong>
      3、运行时动态链接
     </strong>
    </p>
    <p>
     程序运行时需要哪一个目标文件，就选择这个目标文件放入内存并链接
    </p>
    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="462" src="https://i-blog.csdnimg.cn/blog_migrate/c7d39f773ac2bd80a4bc2b39b7cd6dfe.png" width="694"/>
    </h2>
    <h2 id="%C2%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">
     内存管理
    </h2>
    <p>
     操作系统肯定要管理内存，那么操作系统需要完成哪些工作呢?
    </p>
    <p>
     1、
     <strong>
      操作系统负责内存的分配与回收
     </strong>
     ：程序想要运行，就需要加载进入内存，那么操作系统如何知道给这个程序分配哪一块的空间呢？程序运行结束，要如何释放程序所占用的内存空间呢？
    </p>
    <p>
     2、
     <strong>
      操作系统需要提供技术来从逻辑上扩充内存空间
     </strong>
     ：一个游戏，内存可能有20G，电脑才有4G的内存，这个游戏要运行，肯定要加载进入内存，但是20G的大小是如何放入4G内存的呢？这就要涉及到虚拟技术
    </p>
    <p>
     <strong>
      3、操作系统要实现逻辑地址到物理地址的转换：
     </strong>
     三种装入方式
    </p>
    <p>
     4、
     <strong>
      操作系统要实现内存保护
     </strong>
     ：操作系统要保证一个进程不会访问到别的内存空间
     <img alt="" height="454" src="https://i-blog.csdnimg.cn/blog_migrate/385146bec369b6cd1a14e559068521a9.png" width="537"/>
    </p>
    <h2 id="%C2%A0%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4">
     内存保护
    </h2>
    <h3 id="%E8%AE%BE%E7%BD%AE%E4%B8%8A%E3%80%81%E4%B8%8B%E9%99%90%E5%AF%84%E5%AD%98%E5%99%A8">
     <strong>
      设置上、下限寄存器
     </strong>
    </h3>
    <p>
     1
     <strong>
      、设置上、下限寄存器
     </strong>
     存储进程物理地址的开始和结束位置（针对于物理地址的判断）
    </p>
    <p>
     <img alt="" height="498" src="https://i-blog.csdnimg.cn/blog_migrate/4726a4cb20d6a4f548c22f605c358e17.png" width="1200"/>
    </p>
    <h3 id="%E8%AE%BE%E7%BD%AE%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E7%95%8C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8">
     <strong>
      设置重定位寄存器和界地址寄存器
     </strong>
    </h3>
    <p>
     <strong>
      2、设置重定位寄存器和界地址寄存器
     </strong>
     （针对于逻辑地址的判断）
    </p>
    <p>
     重定位寄存器：存储物理地址的起始位置；界地址寄存器：存放最大的逻辑地址
    </p>
    <p>
     通过界地址寄存器，可以判断请求访问的逻辑地址是否越界，根据重定位寄存器可以从逻辑地址得到物理地址
    </p>
    <p>
     <img alt="" height="595" src="https://i-blog.csdnimg.cn/blog_migrate/fcbfa6ed8192d10cb86ed8092aad2818.png" width="1200"/>
    </p>
    <h2 id="%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6">
     内存空间的分配与回收
    </h2>
    <h3 id="%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">
     连续分配方式
    </h3>
    <p>
     产生连续的内存空间
    </p>
    <h3 id="1%E3%80%81%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F">
     <strong>
      1、单一连续分配方式
     </strong>
    </h3>
    <p>
     单一连续分配方式中，内存被分为系统区（低地址部分，存放操作系统相关数据）和用户区（高地址部分，存放用户进程数据）
    </p>
    <p>
     <span style="color:#fe2c24;">
      内存中同一时刻只能有一道用户程序，这个程序独占用户区
     </span>
    </p>
    <p>
     优点：实现简单；可以利用覆盖技术实现扩充内存
    </p>
    <p>
     缺点：空间浪费，只支持单道程序系统
    </p>
    <h3 id="2%E3%80%81%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">
     2、固定分区分配
    </h3>
    <p>
     <span style="color:#fe2c24;">
      将内存划分为固定大小的分区，每一个分区只能装入一道作业
     </span>
    </p>
    <p>
     根据分区大小是否相等，可以分为：分区大小相等和分区大小不相等
    </p>
    <p>
     <img alt="" height="552" src="https://i-blog.csdnimg.cn/blog_migrate/e04929123ea1b4d1d44930df14c0cb05.png" width="505"/>
    </p>
    <p>
     分区大小相等：那么如果占有空间很小的进程，会占用一个分区，每个分区的大小过大，会造成内存空间的浪费（内部碎片），每个分区的大小过小，大进程又装不下
    </p>
    <p>
     分区大小不相等：相比上一个，增加空间设置的灵活性
    </p>
    <p>
     <strong>
      操作系统如何管理这些分区呢?
     </strong>
    </p>
    <p>
     创建一个数据结构---分区说明表，如下所示：
    </p>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">
     <img alt="" height="275" src="https://i-blog.csdnimg.cn/blog_migrate/97fae7682f87198908866d96c87d2f00.png" width="671"/>
     3、动态分区分配
    </h3>
    <p>
     根据进程的空间要求，动态的划分内存空间
    </p>
    <p>
     <img alt="" height="461" src="https://i-blog.csdnimg.cn/blog_migrate/bdc6c7310ba772017e7bd4d96a1c902c.png" width="303"/>
    </p>
    <p>
     <strong>
      1、操作系统如何管理这些分区呢?
     </strong>
    </p>
    <p>
     <img alt="" height="502" src="https://i-blog.csdnimg.cn/blog_migrate/1f4a83de9a4bebd74328e186dce6feb8.png" width="897"/>
    </p>
    <h4 id="%C2%A02%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%A9%BA%E9%97%B2%E5%8C%BA%E6%9D%A5%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4---%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95">
     <strong>
      2、操作系统如何选择空闲区来给进程分配空间---
     </strong>
     动态分区分配算法
    </h4>
    <h4 id="1%E3%80%81%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95">
     <strong>
      1、首次适应算法
     </strong>
    </h4>
    <p>
     原则：按照
     <span style="color:#fe2c24;">
      地址递增
     </span>
     的顺序，找到
     <span style="color:#fe2c24;">
      第一个
     </span>
     可以满足空间要求的空闲分区
    </p>
    <p>
     实现：空闲分区表
     <span style="color:#fe2c24;">
      按照地址递增
     </span>
     的顺序存储
    </p>
    <p>
     <img alt="" height="636" src="https://i-blog.csdnimg.cn/blog_migrate/85797c9e61e547fcc73f5b9fab32f81b.png" width="1122"/>
    </p>
    <p>
     缺点：每次都要从第一个位置开始查找，查找效率低下，产生外部碎片
    </p>
    <h4 id="2%E3%80%81%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95">
     <strong>
      2、最佳适应算法
     </strong>
    </h4>
    <p>
     原则：找到满足空间要求且
     <span style="color:#fe2c24;">
      空闲分区大小最小
     </span>
     的空闲分区
    </p>
    <p>
     实现：空闲分区表按照
     <span style="color:#fe2c24;">
      容量递增
     </span>
     的顺序存储
    </p>
    <p>
     <img alt="" height="539" src="https://i-blog.csdnimg.cn/blog_migrate/a50a0b003a6dd985d5fd7f92d3e91ee8.png" width="1082"/>
    </p>
    <p>
     缺点：每次选择的都是最小的可以满足要求的空闲分区，
     <span style="color:#fe2c24;">
      产生外部碎片
     </span>
    </p>
    <h4 id="3%E3%80%81%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95">
     <strong>
      3、最坏适应算法
     </strong>
    </h4>
    <p>
     为了解决最佳适应算法的问题而提出了最坏适应算法
    </p>
    <p>
     原则：找到满足空间要求且空闲分区大小
     <span style="color:#fe2c24;">
      最大
     </span>
     的空闲分区
    </p>
    <p>
     实现：空闲分区表按照
     <span style="color:#fe2c24;">
      容量递减
     </span>
     的顺序存储
    </p>
    <p>
     <img alt="" height="494" src="https://i-blog.csdnimg.cn/blog_migrate/d8b7970fd96ee5e9bfb65dee7c67506c.png" width="1129"/>
    </p>
    <p>
     缺点：不断分裂大分区，导致大进程没有可以被存储的空间
    </p>
    <h4 id="4%E3%80%81%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89">
     <strong>
      4、邻近适应算法（循环首次适应算法）
     </strong>
    </h4>
    <p>
     为了解决首次适应算法查找速度慢的问题而提出
    </p>
    <p>
     原则：按照
     <span style="color:#fe2c24;">
      地址递增
     </span>
     的顺序，找到
     <span style="color:#fe2c24;">
      第一个
     </span>
     可以满足空间要求的空闲分区
    </p>
    <p>
     实现：空闲分区表
     <span style="color:#fe2c24;">
      按照地址递增
     </span>
     的顺序存储，
     <span style="color:#956fe7;">
      为了提高效率，可以从上一次查找结束之后的位置开始查找
     </span>
    </p>
    <p>
     <span style="color:#0d0016;">
      缺点：可能
     </span>
     分裂大分区，导致大进程没有可以被存储的空间
    </p>
    <h4 id="%C2%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E7%9A%84%E6%A6%82%E5%BF%B5">
     <strong>
      内部碎片和外部碎片的概念
     </strong>
    </h4>
    <blockquote>
     <p>
      内部碎片：一个分区内，分配给某一个进程的空间没有用完
     </p>
     <p>
      外部碎片：内存内，某些区间太小而无法使用
     </p>
    </blockquote>
    <p>
     <img alt="" height="660" src="https://i-blog.csdnimg.cn/blog_migrate/0b98f2fecfcbb65c2dca10ff0fddab00.png" width="1163"/>
    </p>
    <p>
     动态内存分配：没有内部碎片，但是会有外部碎片
    </p>
    <p>
     解决办法：紧凑法：移动进程空间，腾出大的空闲空间
    </p>
    <p>
     <img alt="" height="669" src="https://i-blog.csdnimg.cn/blog_migrate/c2d3e628a945d43bd1a4f745e20cb16e.png" width="1200"/>
    </p>
    <p>
     <strong>
      3、操作系统如何分配和回收空间
     </strong>
    </p>
    <p>
     将连续的空闲区合并，避免空间浪费
    </p>
    <hr/>
    <p>
     以上的3种方法分配的都是连续的内存空间，称之为连续分配管理方式，但是，固定区间分配会产生内部碎片，动态区间分配会产生外部碎片
    </p>
    <p>
     那我们是不是可以在内存中给作业申请非连续空间来解决碎片问题呢？这个称之为非连续分配管理方式，或者称为离散分配方式
    </p>
    <h3 id="4%E3%80%81%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">
     4、基本分页存储管理
    </h3>
    <p>
     <img alt="" height="640" src="https://i-blog.csdnimg.cn/blog_migrate/724f4c4caf99ddc2329b5130f9f4cc4a.png" width="1200"/>
    </p>
    <p>
     以上的这个思想就是基本分页存储管理的实现原理：
    </p>
    <p>
     将
     <span style="color:#a2e043;">
      内存划分为大小相等的分区
     </span>
     ，每一个分区称之为“
     <span style="color:#a2e043;">
      页框”
     </span>
     ，每一个页框会有一个编号（页框号），
     <span style="color:#fe2c24;">
      编号从0开始
     </span>
    </p>
    <p>
     将
     <span style="color:#a2e043;">
      用户进程划分为一个个大小和页框相等的区域
     </span>
     ，每一个区域称之为：
     <span style="color:#a2e043;">
      ”页“
     </span>
     ，每一个页会有一个编号（页号），
     <span style="color:#fe2c24;">
      编号从0开始
     </span>
    </p>
    <p>
     <span style="color:#fe2c24;">
      操作系统会以页框为单位给进程分配空间，用户进程的每一个页面进入内存的每一个页框中
     </span>
    </p>
    <p>
     <img alt="" height="625" src="https://i-blog.csdnimg.cn/blog_migrate/862139d7088fb59fb219ccec92f365db.png" width="1200"/>
    </p>
    <p>
     页框不能太大，否则会产生大的内部碎片
    </p>
    <p>
     <strong>
      如何装入：实现逻辑地址到物理地址的转化？
     </strong>
    </p>
    <p>
     <img alt="" height="666" src="https://i-blog.csdnimg.cn/blog_migrate/192f58f024cb9e546530a8145a733d8f.png" width="1200"/>
    </p>
    <p>
     <strong>
      为了计算机的方便，我们会将页面大小，设置为2的整数幂大小
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#a2e043;">
       使用32个二进制存储，那么前面20位（红色）部分对应的是页号，后12位（黑色）表示页内偏移量
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="553" src="https://i-blog.csdnimg.cn/blog_migrate/8b7be4a7367fe976b62976a9b7294cde.png" width="1200"/>
    </p>
    <p>
     也就是说，逻辑地址包括两部分：页号和页内偏移量；一个页面（页号固定）的大小由页内偏移量决定：一个页面包含的是n个逻辑地址，这个n=2^k（k是页内偏移量的二进制位数）；一个进程的页面个数由页号决定
    </p>
    <blockquote>
     <p>
      如果有k位表示页内偏移量（页地址数），那么系统的一个页面大小2^k
     </p>
     <p>
      如果有M位表示页号，那么一个进程最多有页面2^M个
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     <img alt="" height="416" src="https://i-blog.csdnimg.cn/blog_migrate/f59264c806a05490f7980637a4985050.png" width="893"/>
    </p>
    <p>
     1、页号：逻辑地址/页面长度（80/50=1)
    </p>
    <p>
     2、偏移量：逻辑地址%页面长度（80%50=30）
    </p>
    <p>
     3、起始物理地址：操作系统需要提供某一种数据结构来组织存储各个页面的起始物理地址
    </p>
    <p>
     4、物理地址=起始物理地址+偏移量
    </p>
    <h4 id="%E9%A1%B5%E8%A1%A8">
     页表
    </h4>
    <p>
     起始物理地址：操作系统需要提供某一种数据结构来组织存储各个页面的起始物理地址，这个数据结构是页表
    </p>
    <p>
     <img alt="" height="620" src="https://i-blog.csdnimg.cn/blog_migrate/736996d90ce4be8a4c826d363b2c2b1d.png" width="1200"/>
     先计算出逻辑空间对应的页号，在页表内查询到块号，这个块号对应着内存的页框号，根据页框号*内存给每个页框设置的固定长度，就可以得到起始物理地址
    </p>
    <h4 id="%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96%E6%9C%BA%E5%88%B6">
     <strong>
      基本地址变化机制
     </strong>
    </h4>
    <p>
     基本地址变化机制借助页表，实现逻辑地址到物理地址的转化
    </p>
    <p>
     设置页表寄存器这一个结构，用于存储页表在内存的起始地址和页表长度，在进程没有执行时，页表在内存的起始地址和页表长度（页表有多少页）存放在PCB中，进程一旦开始调度，页表在内存的起始地址和页表长度，就会存储在页表寄存器中
    </p>
    <p>
     1、进程没有被调度，PCB存储进程的信息，包括页表在内存的起始地址和页表长度
    </p>
    <p>
     2、进程被调度，PCB将内存的起始地址和页表长度信息交给页表寄存器
    </p>
    <p>
     3、根据逻辑地址计算得到页号（逻辑地址/页表内存大小）和页内偏移量（逻辑地址%页表内存大小）
    </p>
    <p>
     4、页表寄存器根据页表长（页表数目的多少）判断是否查询越界，没有越界，那么由于每一个页表的长度是固定的且页表号是递增的，根据页表在内存的起始地址和页号可以得到逻辑地址所在页面的起始物理地址，根据页内偏移量最终得到实际的物理地址
    </p>
    <p>
     5、
     <span style="color:#956fe7;">
      给定逻辑地址就可以决定物理地址，地址是一维的
     </span>
    </p>
    <p>
     <img alt="" height="629" src="https://i-blog.csdnimg.cn/blog_migrate/efcf497543483661f305132ae1cb9202.png" width="1157"/>
    </p>
    <p>
     <img alt="" height="329" src="https://i-blog.csdnimg.cn/blog_migrate/3687a4e9eb2b28d5aee1a4b8be2ed930.png" width="1020"/>
    </p>
    <h4 id="%E5%85%B7%E6%9C%89%E5%9D%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E5%8C%96%E6%9C%BA%E5%88%B6">
     具有块表的
     <strong>
      基本地址变化机制
     </strong>
    </h4>
    <p>
     <strong>
      1、局部性原理
     </strong>
    </p>
    <blockquote>
     <p>
      时间局部性：一个指令执行后，不久后被再次访问;一个数据被访问过，不久后这个数据被再次访问
     </p>
     <p>
      空间局部性：一个程序访问过某一个存储单元，不久后，这个存储单元的附近存储单元也被访问
     </p>
    </blockquote>
    <p>
     <img alt="" height="649" src="https://i-blog.csdnimg.cn/blog_migrate/f49276c93ed58d0eb9f57aabe8386f8e.png" width="1200"/>
    </p>
    <p>
     由于局部性原理，极有可能一直访问的都是同一个页面，那么就会造成页表的多次不必要的查询，那么如何增加效率呢？为了解决这个问题，引入了快表机制
    </p>
    <p>
     这就借助了高速缓冲的思想：将近期频繁使用的数据放到更高一级的存储器中
    </p>
    <p>
     <img alt="" height="317" src="https://i-blog.csdnimg.cn/blog_migrate/7c36650edbce4b3b5bdead2c715ffb47.png" width="485"/>
    </p>
    <p>
     <strong>
      2、快表
     </strong>
    </p>
    <blockquote>
     <p>
      快表，又可以称为联想寄存器，简称（TLB），是一种访问速度比内存快的高度缓冲存储器，用于存放当前访问的若干页表项，来加速地址转化的速度；与此对应，内存中页表的访问速度慢，称为慢表
     </p>
    </blockquote>
    <p>
     <img alt="" height="219" src="https://i-blog.csdnimg.cn/blog_migrate/6d1061e5ccc0f34aa235798efadc8fcd.png" width="1178"/>
    </p>
    <p>
     <img alt="" height="676" src="https://i-blog.csdnimg.cn/blog_migrate/ad3b503405e385f597120e6f27fcf1ff.png" width="1200"/>
    </p>
    <p>
     如果命中快表，可以不必对慢表进行访问，只需要计算出实际地址访问内存
    </p>
    <p>
     如果没命中快表，需要对慢表进行访问，同时将信息记入快表，计算出实际地址访问内存
    </p>
    <p>
     <img alt="" height="181" src="https://i-blog.csdnimg.cn/blog_migrate/542259958a6a329e302d63d05f845799.png" width="1044"/>
    </p>
    <p>
     <img alt="" height="465" src="https://i-blog.csdnimg.cn/blog_migrate/c29b316958199b0f5ef6c417d9abf72a.png" width="1114"/>
    </p>
    <h4 id="3%E3%80%81%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8">
     3、两级页表
    </h4>
    <p>
     对于上面提供的单级页表这一数据结构，有两个缺点：
     <strong>
      1、单级页表要在内存中连续存储
     </strong>
     ：根据页表号计算当前页表号对应的起始地址，就要求页表号是递增的，连续存储的；一旦这个页表内存申请过大，就不太容易在内存中找到连续且足够大的空间存储页表，况且这就失去了离散分配方式的意义
     <strong>
      2、单极页表的全部信息可能只需要那么几行，不需要全部存储在内存，浪费内存空间
     </strong>
    </p>
    <p>
     <img alt="" height="517" src="https://i-blog.csdnimg.cn/blog_migrate/1b5b9df2dae3bca3239a722ac5365bf1.png" width="1200"/>
    </p>
    <p>
     <img alt="" height="468" src="https://i-blog.csdnimg.cn/blog_migrate/b138a3247e1f2169191ecfc164598f05.png" width="1200"/>
    </p>
    <p>
     为了解决这两个问题，提出了两级页表
    </p>
    <p>
     <strong>
      如何解决问题一：
     </strong>
     参考解决进程连续分布的方法：将进程地址分页，建立页表，离散存储进程；那么可以将连续的页表分页，再次建立页表（称为页目录表或者外层页表），离散存储连续的页表
    </p>
    <p>
     1、将连续的页表分页
    </p>
    <p>
     <img alt="" height="733" src="https://i-blog.csdnimg.cn/blog_migrate/6834bfb6884d89bcb9b87b109f34e09e.png" width="1200"/>
    </p>
    <p>
     2、再次建立页表（称为页目录表或者外层页表），离散存储连续的页表
    </p>
    <p>
     <img alt="" height="479" src="https://i-blog.csdnimg.cn/blog_migrate/a7395568df7d6ff8c26325eb9328737e.png" width="837"/>
    </p>
    <p>
     <strong>
      如何解决问题二
     </strong>
     ：在需要访问页面时，才将这个页面其调入内存；在页表项中增加标志位，用于标志这个页面是否进入内存
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24;">
       1、
      </span>
     </strong>
     <strong>
      <span style="color:#fe2c24;">
       采用多级页表机制，每一级页表的大小不能超过一个页面
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="701" src="https://i-blog.csdnimg.cn/blog_migrate/f19f2921ff604817d27cb40682eedcc0.png" width="1200"/>
    </p>
    <h3 id="5%E3%80%81%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">
     5、基本分段存储管理
    </h3>
    <p>
     进程的地址空间：根据程序的自身逻辑关系划分为多个段，每段从0开始编址
    </p>
    <p>
     内存分配原则：根据段来分配，段之间连续分配，段和段之间离散分配
    </p>
    <p>
     <img alt="" height="614" src="https://i-blog.csdnimg.cn/blog_migrate/c42bf0f14ed0b0325552e21edc310be8.png" width="1200"/>
    </p>
    <p>
     分段系统的逻辑结构：由段号和段内偏移量构成
    </p>
    <blockquote>
     <p>
      如果有k位表示段内偏移量，那么系统的一个段大小2^k
     </p>
     <p>
      如果有M位表示段号，那么一个进程最多有段2^M个
     </p>
    </blockquote>
    <p>
     段表：记录段存入内存的信息
    </p>
    <p>
     和页表相比，页表中每一个页的长度是系统的，一个段的长度是不一定的，需要显示记录段长
    </p>
    <p>
     段表结构：
    </p>
    <p>
     <img alt="" height="422" src="https://i-blog.csdnimg.cn/blog_migrate/0775c4999fa5df4305965c1bb8ed8262.png" width="980"/>
    </p>
    <p>
     段表实现逻辑地址到物理地址的转化：
    </p>
    <p>
     <img alt="" height="728" src="https://i-blog.csdnimg.cn/blog_migrate/4173e17495e522601f1594694e3f809c.png" width="1200"/>
    </p>
    <p>
     <img alt="" height="550" src="https://i-blog.csdnimg.cn/blog_migrate/7cd4d39d4923be2ed9ce77a3d69b8fc8.png" width="1200"/>
    </p>
    <p>
     分页，分段管理的对比：
    </p>
    <p>
     1、页是信息在物理上的存储，实现分页管理，主要就是实现离散分配，提高内存利用率。对用户不可见
    </p>
    <p>
     2、段是信息的逻辑存储，实现分段管理，主要就是更好的服务用户，满足用户需求，一个段通常包含一个逻辑模块的信息，用户编程时要提供段名，对用户可见
    </p>
    <p>
     3、页的大小是固定的，由系统决定；段的大小不固定，取决于一个模块的信息，由用户编写的代码决定
    </p>
    <p>
     4、分页管理，用户只需要给定一个地址就可以，地址是一维的；分段管理，需要用户给定地址和段名，地址是二维的
    </p>
    <p>
     5、分页管理，产生内部碎片无外部碎片；分段管理，产生外部碎片无内部碎片
    </p>
    <p>
     6、分页比分段更容易实现对于信息的共享和保护
    </p>
    <p>
     <img alt="" height="515" src="https://i-blog.csdnimg.cn/blog_migrate/f2ca3496d789d9370fcf69eef20a299e.png" width="1200"/>
    </p>
    <h3 id="6%E3%80%81%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">
     6、段页式存储管理
    </h3>
    <p>
     <img alt="" height="198" src="https://i-blog.csdnimg.cn/blog_migrate/7010909757284a05d3545d47a02a37e3.png" width="1024"/>
    </p>
    <p>
     先将用户进程分段，后分页
    </p>
    <p>
     <img alt="" height="523" src="https://i-blog.csdnimg.cn/blog_migrate/751068b27d9ba649f7efca3bd89a66e4.png" width="1139"/>
    </p>
    <p>
     逻辑地址结构由段号，页号，页内偏移量组成
    </p>
    <p>
     段表、页表结构：
    </p>
    <p>
     <img alt="" height="589" src="https://i-blog.csdnimg.cn/blog_migrate/9462964cb7430c53c0ec327b47e686fe.png" width="1050"/>
    </p>
    <p>
     实现逻辑地址到物理地址的转化：
     <img alt="" height="638" src="https://i-blog.csdnimg.cn/blog_migrate/2f336607821ae628035f02ce6d385383.png" width="1136"/>
    </p>
    <p>
     <img alt="" height="501" src="https://i-blog.csdnimg.cn/blog_migrate/6b2a6a56bd7ef3cd133f6ebffdc0ba10.png" width="1200"/>
    </p>
    <h2 id="%C2%A0%C2%A0%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85">
     内存扩充
    </h2>
    <p>
     所谓的内存扩充，并不是指增加系统的物理内存，而是指在现有内存的基础上增加内存的使用率
    </p>
    <h3 id="1%E3%80%81%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF">
     <strong>
      1、覆盖技术
     </strong>
    </h3>
    <p>
     覆盖技术的思想：将程序分为多个段（模块），常用的段常驻内存，不常用的段就可以调出内存
    </p>
    <p>
     内存将分为“固定区”和“覆盖区”
    </p>
    <p>
     固定区：存放常用的段，程序运行期间内不会调出
    </p>
    <p>
     覆盖区：存放不常用的段，程序运行期间内需要的时候调入，不需要的时候调出
    </p>
    <p>
     <img alt="" height="555" src="https://i-blog.csdnimg.cn/blog_migrate/4f0a0bf63f2f258d9440de17cdf861e6.png" width="1200"/>
     缺点：程序的调用（覆盖）结构需要程序员自己声明，操作系统有了覆盖结构之后才能实现覆盖；对用户不透明，增加了用户的编程负担
    </p>
    <h3 id="2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF">
     <strong>
      2、交换技术
     </strong>
    </h3>
    <p>
     当系统的内存空间紧张的时候，系统可以将某些进程暂时调出内存，存入外存，也可以将外存中具备运行条件的进程换入内存（进程在内存和磁盘的交换）
    </p>
    <p>
     处理机调度中的中级调度！！！
    </p>
    <p>
     <span style="color:#fe2c24;">
      进程的PCB常驻内存
     </span>
    </p>
    <p>
     <span style="color:#0d0016;">
      1、外存的哪些地方存放被换出的进程
     </span>
    </p>
    <p>
     <span style="color:#0d0016;">
      具有对换功能的操作系统，会将外存（磁盘）分为两个区域：
     </span>
     <span style="color:#fe2c24;">
      对换区和文件区
     </span>
     <span style="color:#0d0016;">
      ；文件区用于存放文件，
     </span>
     <span style="color:#fe2c24;">
      要求提高存储空间的利用率，采用离散分配方式管理文件区
     </span>
     <span style="color:#0d0016;">
      ，对换区用于存放被内存换出的进程，
     </span>
     <span style="color:#fe2c24;">
      主要追求换入换出的速度，采用连续分配方式
     </span>
     <span style="color:#0d0016;">
      ；总之，
     </span>
     <span style="color:#956fe7;">
      对换区的I/O速度快于文件区
     </span>
    </p>
    <p>
     <img alt="" height="563" src="https://i-blog.csdnimg.cn/blog_migrate/69da5bee0d218029ee40eb1604b9540f.png" width="1109"/>
     <span style="color:#0d0016;">
      2、什么时候进程交换
     </span>
    </p>
    <p>
     <span style="color:#0d0016;">
      换出一般出现于内存不足时，换入发生在内存空间充足且
     </span>
     外存中具备运行条件的进程才可以换入
    </p>
    <p>
     <span style="color:#0d0016;">
      3、可以换出哪些进程
     </span>
    </p>
    <p>
     例如：优先级低的进程，阻塞的进程等
    </p>
    <h3 id="3%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF">
     <strong>
      3、虚拟内存技术
     </strong>
    </h3>
    <p>
     <img alt="" height="343" src="https://i-blog.csdnimg.cn/blog_migrate/cd4a614b1a6b114551da41587e944836.png" width="846"/>
    </p>
    <p>
     <img alt="" height="202" src="https://i-blog.csdnimg.cn/blog_migrate/93c5510c3c283469327110eb76bfc48d.png" width="1020"/>
    </p>
    <h4 id="%C2%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">
     <strong>
      虚拟内存
     </strong>
    </h4>
    <p>
     根据局部性原理，我们可以在装入程序时，内存装入很快需要的部分，暂时不用的数据就留在外存
    </p>
    <p>
     操作系统在程序运行期间，负责数据的换入换出，在用户看来，自己使用的内存很多，这就是虚拟内存
    </p>
    <p>
     <strong>
      虚拟内存的最大容量和实际容量
     </strong>
    </p>
    <blockquote>
     <p>
      虚拟内存的最大容量由计算机的地址结构决定
     </p>
     <p>
      虚拟内存的实际容量是（内存+外存）和最大容量的最小值
     </p>
    </blockquote>
    <p>
     <img alt="" height="205" src="https://i-blog.csdnimg.cn/blog_migrate/c900720a8f1ceabedd72f1df0605eb0a.png" width="1200"/>
     使用虚拟内存之后，呈现：1、多次性：一个作业可以被分为多次调入内存2、对换性：操作系统在程序运行期间，负责数据的换入换出3、虚拟性:在用户看来，自己使用的内存很多，这就是虚拟内存
    </p>
    <p>
     <span style="color:#fe2c24;">
      虚拟内存技术基于离散分配方式！！！
     </span>
    </p>
    <p>
     <img alt="" height="467" src="https://i-blog.csdnimg.cn/blog_migrate/dd64e40952fff65c6aab1d9b281b93fb.png" width="1133"/>
    </p>
    <h4 id="%C2%A0%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">
     请求分页管理方式
    </h4>
    <p>
     在基本分页管理方式上的拓展
    </p>
    <p>
     请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。
     <br/>
     <br/>
     在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。
    </p>
    <p>
     <br/>
     为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。
    </p>
    <p>
     <strong>
      页表结构
     </strong>
    </p>
    <p>
     <img alt="" height="557" src="https://i-blog.csdnimg.cn/blog_migrate/e3f7408ba9626150fdf90d4ee2b77013.png" width="1127"/>
    </p>
    <p>
     <strong>
      缺页中断机制
     </strong>
    </p>
    <p>
     当想要访问的页面不在内存时，需要请求将页面调入内存；这时会产生
     <strong>
      缺页中断
     </strong>
     ，将进程加入阻塞队列，直到缺页中断程序处理完成，将页面调入内存，进程才会被唤醒，进入就绪队列
    </p>
    <p>
     1、如果内存中有空闲位置，那么将页面加载进入内存
    </p>
    <p>
     2、如果内存中没有空闲位置，使用页面置换，淘汰一个页面（如果这个页面的数据被修改过，那么数据要写回外存），然后将页面调入内存
    </p>
    <p>
     缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：
    </p>
    <ul>
     <li>
      在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于内部中断。
     </li>
     <li>
      一条指令在执行期间，可能产生多次缺页中断。
     </li>
    </ul>
    <p>
     <img alt="" height="528" src="https://i-blog.csdnimg.cn/blog_migrate/c307c7809775788ff6df7123a282b9f9.png" width="1081"/>
    </p>
    <p>
     <strong>
      地址变换机构
     </strong>
    </p>
    <p>
     请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。
    </p>
    <p>
     <img alt="" height="658" src="https://i-blog.csdnimg.cn/blog_migrate/e2024cf5fa83f43d270c6290d8c127f7.png" width="777"/>
    </p>
    <p>
     在进行地址变换时，先检索快表：
    </p>
    <ul>
     <li>
      若找到要访问的页，便修改页表项中的访问位（写指令则还须重置修改位)，然后利用页表项中给出的物理块号和页内地址形成物理地址。
     </li>
     <li>
      若未找到该页的页表项，应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。
     </li>
    </ul>
    <h4 id="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">
     页面置换算法
    </h4>
    <p>
     页面置换算法决定将哪一个页面换出外存
    </p>
    <p>
     页面的换入换出需要磁盘I/O，好的页面算法应该减少磁盘I/O的次数
    </p>
    <blockquote>
     <p>
      缺页率=（缺页次数)/页面访问次数
     </p>
    </blockquote>
    <h4 id="%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89">
     最佳置换算法（OPT）
    </h4>
    <blockquote>
     <p>
      淘汰的页面是以后不可能使用或者长时间不再使用的页面
     </p>
    </blockquote>
    <p>
     <img alt="" height="693" src="https://i-blog.csdnimg.cn/blog_migrate/028e20113c61ba8ce2ca3221c43d1463.png" width="1200"/>
    </p>
    <p>
     缺页率：9/20=0.45
    </p>
    <p>
     <span style="color:#fe2c24;">
      系统无法知道并发情况下，进程的执行顺序，最佳置换算法无法实现！！！
     </span>
    </p>
    <h4 id="%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FCFO)">
     先进先出置换算法（FCFO)
    </h4>
    <blockquote>
     <p>
      每次淘汰最早进入内存的页面
     </p>
    </blockquote>
    <p>
     <img alt="" height="588" src="https://i-blog.csdnimg.cn/blog_migrate/f5c2a389f0cf4f0aa664162f50741a1a.png" width="1200"/>
    </p>
    <p>
     缺页率：9/12=0.75
    </p>
    <p>
     <strong>
      belady异常
     </strong>
    </p>
    <p>
     <img alt="" height="451" src="https://i-blog.csdnimg.cn/blog_migrate/397ab8b5a41eb6043229235c81c5b95d.png" width="1141"/>
    </p>
    <h4 id="%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU)">
     最近最久未使用置换算法（LRU)
    </h4>
    <p>
     淘汰最近最久未使用页面
    </p>
    <blockquote>
     <p>
      使用页表的访问字段记录从上一次访问到现在的时间
      <img alt="" height="75" src="https://i-blog.csdnimg.cn/blog_migrate/7f943fce5a1153e47d223d31596bca63.png" width="911"/>
     </p>
    </blockquote>
    <p>
     逆向观察
     <img alt="" height="496" src="https://i-blog.csdnimg.cn/blog_migrate/72455ba83e1c551f769cc97270316838.png" width="1200"/>
    </p>
    <p>
     缺页率：6/20=0.3
    </p>
    <p>
     效率好，但是实现困难
    </p>
    <h4 id="%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK)">
     时钟置换算法（CLOCK)
    </h4>
    <blockquote>
     <p>
      使用页面的访问位，访问位为1表示最近访问过，访问位为0表示最近没有访问过
     </p>
     <p>
      将内存的页面构造成循环队列
     </p>
    </blockquote>
    <p>
     1、一个页面被访问，访问位就要置为1
    </p>
    <p>
     2、需要淘汰一个页面，访问循环队列，找到访问位是0的页面换出，换入的页面的标志位是1；
    </p>
    <p>
     如果访问到的访问位是1，将其改为0，继续访问下一个页面
    </p>
    <p>
     <img alt="" height="764" src="https://i-blog.csdnimg.cn/blog_migrate/d29e419fc9bb27e98fd4485c5c4b3bde.png" width="1200"/>
    </p>
    <p>
     性能和开销相对均衡
    </p>
    <h4 id="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK)">
     改进后的时钟置换算法（CLOCK)
    </h4>
    <p>
     之前说的时钟置换算法，只关注是不是被访问过；然而，如果被淘汰的页面没有在内存中被修改过，是不需要写回外存的
    </p>
    <blockquote>
     <p>
      在其他条件相同时，优先淘汰没有修改过的页面
     </p>
    </blockquote>
    <p>
     访问位为1表示最近访问过，访问位为0表示最近没有访问过
    </p>
    <p>
     修改位是1，表示在内存中修改过，修改位是0，表示在内存中没修改过
    </p>
    <p>
     <img alt="" height="359" src="https://i-blog.csdnimg.cn/blog_migrate/f4fddef495f42d22f730ee1a07e4a973.png" width="882"/>
    </p>
    <p>
     <img alt="" height="555" src="https://i-blog.csdnimg.cn/blog_migrate/45e27f235cfbe6b9308635177d466d91.png" width="1044"/>
    </p>
    <h2 id="%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">
     页面分配策略
    </h2>
    <h3 id="%E9%A9%BB%E7%95%99%E9%9B%86">
     驻留集
    </h3>
    <p>
     请求分页管理系统中，给进程分配的物理块的集合
    </p>
    <p>
     采用了虚拟存储技术的系统，驻留集大小一般小于进程总大小
    </p>
    <p>
     <img alt="" height="321" src="https://i-blog.csdnimg.cn/blog_migrate/5418962985ee1b4a29424382366fac14.png" width="1085"/>
    </p>
    <p>
     固定分配：系统给每个进程分配固定数目的物理块，进程运行期间不会改变，也就是驻留集不变
    </p>
    <p>
     可变分配：系统给每个进程分配一定数目的物理块，进程运行期间可以增加或者减少，也就是驻留集可变
    </p>
    <p>
     局部置换：发生缺页，只可以选择进程自己的物理块进行置换
    </p>
    <p>
     全局置换：发生缺页，操作系统可以将空闲的物理块分配给进程，也可以将别的进程的物理块置换到外存后分配给进程
    </p>
    <p>
     现代操作系统通常釆用三种策略：
    </p>
    <ol>
     <li>
      <strong>
       固定分配局部置换
      </strong>
      。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。
     </li>
     <li>
      <strong>
       可变分配全局置换
      </strong>
      。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。
     </li>
     <li>
      <strong>
       可变分配局部置换
      </strong>
      。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。
     </li>
    </ol>
    <p>
     <strong>
      可变分配全局置换和可变分配局部置换的区别：
     </strong>
    </p>
    <p>
     可变分配局部置换，根据缺页频率动态调整物理块数目；可变分配全局置换，只要发生缺页就会增加物理块
    </p>
    <p>
     <img alt="" height="261" src="https://i-blog.csdnimg.cn/blog_migrate/cea2bbcf3fdce85378db942612275a43.png" width="901"/>
    </p>
    <h3 id="%C2%A0%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA">
     调入页面的时机
    </h3>
    <p>
     为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：
    </p>
    <ol>
     <li>
      <strong>
       预调页策略
      </strong>
      。根据局部性原理（空间局部性），一次调入若干个相邻的页可能会比一次调入一个页面更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。
     </li>
     <li>
      <strong>
       请求调页策略
      </strong>
      。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。
     </li>
    </ol>
    <h3 id="%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2">
     从何处调入页面
    </h3>
    <p>
     请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故
     <strong>
      对换区的磁盘I/O速度比文件区的更快
     </strong>
     。这样从何处调入页面有三种情况：
    </p>
    <ol>
     <li>
      <strong>
       系统拥有足够的对换区空间
      </strong>
      ：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。
     </li>
     <li>
      <strong>
       系统缺少足够的对换区空间
      </strong>
      ：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区（读写速度快），以后需要时再从对换区调入。
     </li>
     <li>
      <strong>
       UNIX方式
      </strong>
      ：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。
     </li>
    </ol>
    <h3 id="%E9%A1%B5%E9%9D%A2%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89">
     页面抖动（颠簸）
    </h3>
    <p>
     刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。
     <br/>
     页面抖动的主要原因是某个进程频繁访问的页面数目高于可用的物理块数目。
    </p>
    <h3 id="%E5%B7%A5%E4%BD%9C%E9%9B%86">
     工作集
    </h3>
    <blockquote>
     <p>
      工作集是指在某段时间间隔内，进程要访问的页面集合。
     </p>
     <p>
      驻留集是指在请求分页管理系统中给进程分配的内存块的集合
     </p>
    </blockquote>
    <p>
     经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。
    </p>
    <p>
     <img alt="" height="236" src="https://i-blog.csdnimg.cn/blog_migrate/b8d8d2a3dd97523b745fa254b38f9b0f.png" width="843"/>
     <br/>
    </p>
    <p>
     <span style="color:#fe2c24;">
      <strong>
       一般来说：驻留集大小&gt;=工作集大小，否则进程在运行中会频繁发生缺页
      </strong>
     </span>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35383334323739372f:61727469636c652f64657461696c732f313235313536323636" class_="artid" style="display:none">
 </p>
</div>


