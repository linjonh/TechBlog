---
layout: post
title: "微信小程序从入门到精通"
date: 2023-05-10 11:46:11 +0800
description: "文章浏览阅读3.1k次，点赞17次，本篇文章是我在学习微信小程序时写的一套笔记，比较全面，_小程序怎"
keywords: "小程序怎么开始学"
categories: ['微信小程序']
tags: ['微信小程序', '小程序', '前端']
artid: "130334646"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=130334646
    alt: "微信小程序从入门到精通"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微信小程序从入门到精通
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      目录
     </h4>
     <ul>
      <li>
       <a href="#_1" rel="nofollow">
        前言
       </a>
      </li>
      <li>
       <a href="#_11" rel="nofollow">
        一，初学小程序
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#11__12" rel="nofollow">
          1.1 小程序概述
         </a>
        </li>
        <li>
         <a href="#12__17" rel="nofollow">
          1.2 基础配置
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#121__18" rel="nofollow">
            1.2.1 注册开发账号
           </a>
          </li>
          <li>
           <a href="#122_AppID_22" rel="nofollow">
            1.2.2 获取AppID
           </a>
          </li>
          <li>
           <a href="#123__27" rel="nofollow">
            1.2.3 微信开发者工具
           </a>
          </li>
          <li>
           <a href="#124__39" rel="nofollow">
            1.2.4 修改代理模式
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#13__44" rel="nofollow">
          1.3 第一个小程序
         </a>
        </li>
        <li>
         <a href="#14__55" rel="nofollow">
          1.4 开发文档
         </a>
        </li>
        <li>
         <a href="#15__58" rel="nofollow">
          1.5 机型
         </a>
        </li>
        <li>
         <a href="#16__63" rel="nofollow">
          1.6 项目基本结构
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#161__75" rel="nofollow">
            1.6.1 页面内部文件
           </a>
          </li>
          <li>
           <a href="#162_appjson_84" rel="nofollow">
            1.6.2 app.json
           </a>
          </li>
          <li>
           <a href="#163_projectconfigjson_110" rel="nofollow">
            1.6.3 project.config.json
           </a>
          </li>
          <li>
           <a href="#164_sitemapjson_117" rel="nofollow">
            1.6.4 sitemap.json
           </a>
          </li>
          <li>
           <a href="#165_json_130" rel="nofollow">
            1.6.5 页面.json
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#17__138" rel="nofollow">
          1.7 新建小程序页面
         </a>
        </li>
        <li>
         <a href="#18_WXML_142" rel="nofollow">
          1.8 WXML模板
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#181_WXSSHTML_143" rel="nofollow">
            1.8.1 WXSS与HTML
           </a>
          </li>
          <li>
           <a href="#182_WXSSCSS_159" rel="nofollow">
            1.8.2 WXSS与CSS
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#19_js_171" rel="nofollow">
          1.9 js文件
         </a>
        </li>
        <li>
         <a href="#110__178" rel="nofollow">
          1.10 小程序的宿主环境
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1101__179" rel="nofollow">
            1.10.1 介绍宿主环境
           </a>
          </li>
          <li>
           <a href="#1102__186" rel="nofollow">
            1.10.2 执行原理
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_198" rel="nofollow">
        二，组件
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#21__204" rel="nofollow">
          2.1 组件类型
         </a>
        </li>
        <li>
         <a href="#22__208" rel="nofollow">
          2.2 模拟器展示固定页面
         </a>
        </li>
        <li>
         <a href="#23__214" rel="nofollow">
          2.3 视图组件
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#231_view_216" rel="nofollow">
            2.3.1 view
           </a>
          </li>
          <li>
           <a href="#232_scrollview_230" rel="nofollow">
            2.3.2 scroll-view
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#24__247" rel="nofollow">
          2.4 轮播图组件
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#241_swiperswiperitem_248" rel="nofollow">
            2.4.1 swiper与swiper-item
           </a>
          </li>
          <li>
           <a href="#242_swiper_271" rel="nofollow">
            2.4.2 swiper组件常用属性
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#25__280" rel="nofollow">
          2.5 常用基础内容组件
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#251_text_282" rel="nofollow">
            2.5.1 text
           </a>
          </li>
          <li>
           <a href="#252_richtext_295" rel="nofollow">
            2.5.2 rich-text
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#26__299" rel="nofollow">
          2.6 其他常用组件
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#261_button_300" rel="nofollow">
            2.6.1 button
           </a>
          </li>
          <li>
           <a href="#262_image_323" rel="nofollow">
            2.6.2 image
           </a>
          </li>
          <li>
           <a href="#263_navigator_337" rel="nofollow">
            2.6.3 navigator
           </a>
          </li>
          <li>
           <a href="#264__339" rel="nofollow">
            2.6.4 组件样式版本
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#WXML_346" rel="nofollow">
        三，WXML模板语法
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#31__347" rel="nofollow">
          3.1 数据绑定
         </a>
        </li>
        <li>
         <a href="#32_mustache_362" rel="nofollow">
          3.2 mustache语法的应用场景
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_379" rel="nofollow">
        四，事件绑定
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#41__380" rel="nofollow">
          4.1 事件介绍
         </a>
        </li>
        <li>
         <a href="#42__392" rel="nofollow">
          4.2 事件对象的属性列表
         </a>
        </li>
        <li>
         <a href="#43_bindtap_403" rel="nofollow">
          4.3 bindtap
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#431_bindtap_404" rel="nofollow">
            4.3.1 bindtap使用
           </a>
          </li>
          <li>
           <a href="#432__422" rel="nofollow">
            4.3.2 事件传参与数据同步
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#45__442" rel="nofollow">
          4.5 事件传参
         </a>
        </li>
        <li>
         <a href="#46_bindinput_461" rel="nofollow">
          4.6 bindinput的
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#461_bindinput_462" rel="nofollow">
            4.6.1 bindinput的使用
           </a>
          </li>
          <li>
           <a href="#462_data_478" rel="nofollow">
            4.6.2 文本框和data之间的数据同步
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_496" rel="nofollow">
        五，条件渲染与列表渲染
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#51_wxif_497" rel="nofollow">
          5.1 条件渲染wx:if
         </a>
        </li>
        <li>
         <a href="#52_hidden_515" rel="nofollow">
          5.2 hidden的使用
         </a>
        </li>
        <li>
         <a href="#53_wxifhidden_522" rel="nofollow">
          5.3 wx:if与hidden对比
         </a>
        </li>
        <li>
         <a href="#54_wxfor_529" rel="nofollow">
          5.4 列表渲染wx:for
         </a>
        </li>
        <li>
         <a href="#55_indexitem_538" rel="nofollow">
          5.5 给index和item取名字
         </a>
        </li>
        <li>
         <a href="#56_wxkey_541" rel="nofollow">
          5.6 wx:key
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#wxss_554" rel="nofollow">
        六，wxss模板样式
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#61_wxsscss_555" rel="nofollow">
          6.1 wxss与css的关系
         </a>
        </li>
        <li>
         <a href="#62_rpx_560" rel="nofollow">
          6.2 rpx尺寸单位
         </a>
        </li>
        <li>
         <a href="#63__575" rel="nofollow">
          6.3 样式导入
         </a>
        </li>
        <li>
         <a href="#64__589" rel="nofollow">
          6.4 全局样式与局部样式
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_598" rel="nofollow">
        七，全局配置
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#71_window_622" rel="nofollow">
          7.1 window
         </a>
        </li>
        <li>
         <a href="#72_tabBar_660" rel="nofollow">
          7.2 tabBar
         </a>
        </li>
        <li>
         <a href="#73__723" rel="nofollow">
          7.3 页面配置
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_729" rel="nofollow">
        八，网络数据请求
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#81__730" rel="nofollow">
          8.1 请求限制
         </a>
        </li>
        <li>
         <a href="#82__737" rel="nofollow">
          8.2 配置小程序接口
         </a>
        </li>
        <li>
         <a href="#83_requiregetpost_754" rel="nofollow">
          8.3 使用require发起get和post请求
         </a>
        </li>
        <li>
         <a href="#84__797" rel="nofollow">
          8.4 在页面刚加载时请求数据
         </a>
        </li>
        <li>
         <a href="#85_request_805" rel="nofollow">
          8.5 跳过request合法域名校验
         </a>
        </li>
        <li>
         <a href="#86_Ajax_813" rel="nofollow">
          8.6 关于跨域问题和Ajax的说明
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_817" rel="nofollow">
        九，页面导航
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#91__823" rel="nofollow">
          9.1 声明式导航
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#911_tabBar_827" rel="nofollow">
            9.1.1 导航到tabBar页面
           </a>
          </li>
          <li>
           <a href="#912_tabBar_836" rel="nofollow">
            9.1.2 导航到非tabBar页面
           </a>
          </li>
          <li>
           <a href="#913__845" rel="nofollow">
            9.1.3 实现后退效果
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#92__850" rel="nofollow">
          9.2 编程式导航
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#921_tabBar_852" rel="nofollow">
            9.2.1 导航到tabBar页面
           </a>
          </li>
          <li>
           <a href="#922_tabBar_867" rel="nofollow">
            9.2.2 导航到非tabBar页面
           </a>
          </li>
          <li>
           <a href="#923__879" rel="nofollow">
            9.2.3 编程式导航实现后退效果
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#93__887" rel="nofollow">
          9.3 导航传参
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#931__888" rel="nofollow">
            9.3.1 声明式导航传参
           </a>
          </li>
          <li>
           <a href="#932__901" rel="nofollow">
            9.3.2 编程式导航传参
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#94_onLoad_904" rel="nofollow">
          9.4 在onLoad中接收导航参数
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_915" rel="nofollow">
        十，页面事件
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#101__920" rel="nofollow">
          10.1 下拉刷新
         </a>
        </li>
        <li>
         <a href="#102__930" rel="nofollow">
          10.2 监听下拉刷新事件
         </a>
        </li>
        <li>
         <a href="#103__934" rel="nofollow">
          10.3 停止下拉刷新
         </a>
        </li>
        <li>
         <a href="#104__936" rel="nofollow">
          10.4 上拉触底以及监听
         </a>
        </li>
        <li>
         <a href="#105__945" rel="nofollow">
          10.5 配置上拉触底距离
         </a>
        </li>
        <li>
         <a href="#106__951" rel="nofollow">
          10.6 加载数据
         </a>
        </li>
        <li>
         <a href="#107__958" rel="nofollow">
          10.7 节流
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_978" rel="nofollow">
        十一，小程序的生命周期
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#111__979" rel="nofollow">
          11.1 生命周期概述
         </a>
        </li>
        <li>
         <a href="#112__987" rel="nofollow">
          11.2 生命周期函数
         </a>
        </li>
        <li>
         <a href="#113__998" rel="nofollow">
          11.3 应用的生命周期函数
         </a>
        </li>
        <li>
         <a href="#114__1012" rel="nofollow">
          11.4 页面的声明周期函数
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#WXS_1023" rel="nofollow">
        十二，WXS脚本
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#121_WXS_1024" rel="nofollow">
          12.1 WXS概述
         </a>
        </li>
        <li>
         <a href="#122_wxsJavaScript_1029" rel="nofollow">
          12.2 wxs和JavaScript的关系
         </a>
        </li>
        <li>
         <a href="#123_wxs_1042" rel="nofollow">
          12.3 内嵌的wxs脚本
         </a>
        </li>
        <li>
         <a href="#124_wxs_1062" rel="nofollow">
          12.4 定义外联的wxs脚本
         </a>
        </li>
        <li>
         <a href="#125__1083" rel="nofollow">
          12.5 总结
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_1099" rel="nofollow">
        十三，自定义组件
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#131__1100" rel="nofollow">
          13.1 创建组件
         </a>
        </li>
        <li>
         <a href="#132__1107" rel="nofollow">
          13.2 局部引入
         </a>
        </li>
        <li>
         <a href="#133__1121" rel="nofollow">
          13.3 全局引入
         </a>
        </li>
        <li>
         <a href="#134__1125" rel="nofollow">
          13.4 引用方式的选择
         </a>
        </li>
        <li>
         <a href="#135__1131" rel="nofollow">
          13.5 组件和页面的区别
         </a>
        </li>
        <li>
         <a href="#136__1138" rel="nofollow">
          13.6 组件样式隔离
         </a>
        </li>
        <li>
         <a href="#137_data_1156" rel="nofollow">
          13.7 data数据
         </a>
        </li>
        <li>
         <a href="#138_methods_1159" rel="nofollow">
          13.8 methods方法
         </a>
        </li>
        <li>
         <a href="#139_properties_1166" rel="nofollow">
          13.9 properties属性
         </a>
        </li>
        <li>
         <a href="#1310_dataproperties_1174" rel="nofollow">
          13.10 data和properties的区别
         </a>
        </li>
        <li>
         <a href="#1311__1176" rel="nofollow">
          13.11 数据监听器
         </a>
        </li>
        <li>
         <a href="#1312__1219" rel="nofollow">
          13.12 纯数据字段
         </a>
        </li>
        <li>
         <a href="#1313__1229" rel="nofollow">
          13.13 自定义组件的生命周期
         </a>
        </li>
        <li>
         <a href="#1314__1260" rel="nofollow">
          13.14 组件所在页面的生命周期
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_1272" rel="nofollow">
        十四，插槽
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#141__1273" rel="nofollow">
          14.1 什么是插槽
         </a>
        </li>
        <li>
         <a href="#142__1277" rel="nofollow">
          14.2 单个插槽
         </a>
        </li>
        <li>
         <a href="#143__1287" rel="nofollow">
          14.3 多个插槽
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_1298" rel="nofollow">
        十五，组件通信
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#151__1299" rel="nofollow">
          15.1 父子通信概述
         </a>
        </li>
        <li>
         <a href="#152__1312" rel="nofollow">
          15.2 父-&gt;子之属性绑定
         </a>
        </li>
        <li>
         <a href="#153__1323" rel="nofollow">
          15.3 子-&gt;父之事件绑定
         </a>
        </li>
        <li>
         <a href="#154__1355" rel="nofollow">
          15.4 获取组件实例
         </a>
        </li>
        <li>
         <a href="#155_behaviors_1372" rel="nofollow">
          15.5. behaviors
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#npm_1397" rel="nofollow">
        十六，使用npm包
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#161_npm_1398" rel="nofollow">
          16.1 使用npm包的限制
         </a>
        </li>
        <li>
         <a href="#162_Vant_Weapp_1407" rel="nofollow">
          16.2 Vant Weapp
         </a>
        </li>
        <li>
         <a href="#163_vant_1416" rel="nofollow">
          16.3 安装vant组件库
         </a>
        </li>
        <li>
         <a href="#164_Vant_1457" rel="nofollow">
          16.4 使用Vant组件
         </a>
        </li>
        <li>
         <a href="#165__1471" rel="nofollow">
          16.5 定制全局主题样式
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_API_Promise_1494" rel="nofollow">
        十七 API Promise化
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#171_Promise_1495" rel="nofollow">
          17.1 Promise概述
         </a>
        </li>
        <li>
         <a href="#172_API_Promise_1504" rel="nofollow">
          17.2 实现API Promise化
         </a>
        </li>
        <li>
         <a href="#173_API_Promise_1517" rel="nofollow">
          17.3 实现API Promise化
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_1524" rel="nofollow">
        十八，全局数据共享
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#181__1525" rel="nofollow">
          18.1 数据共享概述
         </a>
        </li>
        <li>
         <a href="#182_MobX_1535" rel="nofollow">
          18.2 安装MobX相关的包
         </a>
        </li>
        <li>
         <a href="#183_Store_1545" rel="nofollow">
          18.3 创建Store实例
         </a>
        </li>
        <li>
         <a href="#184_actionstore_1553" rel="nofollow">
          18.4 action方法修改store中的数据
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_1559" rel="nofollow">
        十九，小程序的分包
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#191__1560" rel="nofollow">
          19.1 分包的介绍
         </a>
        </li>
        <li>
         <a href="#192__1580" rel="nofollow">
          19.2 分包的加载规则
         </a>
        </li>
        <li>
         <a href="#193__1587" rel="nofollow">
          19.3 分包体积限制
         </a>
        </li>
        <li>
         <a href="#194__1596" rel="nofollow">
          19.4 分包
         </a>
        </li>
        <li>
         <a href="#195__1609" rel="nofollow">
          19.5 打包规则
         </a>
        </li>
        <li>
         <a href="#196__1618" rel="nofollow">
          19.6 引用原则
         </a>
        </li>
        <li>
         <a href="#197__1625" rel="nofollow">
          19.7 独立分包
         </a>
        </li>
        <li>
         <a href="#198__1653" rel="nofollow">
          19.8 分包预下载
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_1672" rel="nofollow">
        后记
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     前言
    </h2>
    <p>
     本篇文章是笔者在学习微信小程序的过程中写下的笔记，之所以写这篇是因为csdn上几乎没有一篇博客能够系统的记录小程序的学习，我希望这篇博客能给想要看文档学习小程序的同学提供一些帮助。
    </p>
    <p>
     另外，关于小程序的学习我强烈建议有vue操作的人来学习，因为小程序的思路和原理与vue及其稳和，所以如果大家在学习过程中需要复习vue，可以看我的这篇博客:
     <br/>
     <a href="https://blog.csdn.net/zxdznyy/article/details/130132096">
      万字复盘Vue2相关知识（适合学过但忘了然而需要上手的朋友）
     </a>
    </p>
    <p>
     如果学习中有问题也可也私信我交流或者评论区一起交流。私信一般会回！
    </p>
    <p>
     话不多说，码字不易，希望大家多点赞多关注收藏！！咱们开始学习！
    </p>
    <h2>
     <a id="_11">
     </a>
     一，初学小程序
    </h2>
    <h3>
     <a id="11__12">
     </a>
     1.1 小程序概述
    </h3>
    <p>
     小程序与普通网页开发：
     <br/>
     运行环境：网页运行在浏览器中，小程序用于微信中；
     <br/>
     API：小程序无法调用浏览器中的DOM和BOM的API，但是可以调用微信环境提供的API（地理定位、扫码、支付）；
     <br/>
     开发模式：网页的开发（浏览器+代码编辑器），小程序，申请开发账号，安装开发者工具，创建和配置小程序项目。
    </p>
    <h3>
     <a id="12__17">
     </a>
     1.2 基础配置
    </h3>
    <h4>
     <a id="121__18">
     </a>
     1.2.1 注册开发账号
    </h4>
    <p>
     注册开发账号：https://mp.weixin.qq.com/
    </p>
    <p>
     点击立即注册，选择小程序，接着走流程即可。
    </p>
    <h4>
     <a id="122_AppID_22">
     </a>
     1.2.2 获取AppID
    </h4>
    <p>
     在注册好之后，可以获取AppID。
    </p>
    <p>
     这个字符串日后开发会用到：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/84b6cc68bc68927ee1ea9d7a660da3ab.png"/>
    </p>
    <h4>
     <a id="123__27">
     </a>
     1.2.3 微信开发者工具
    </h4>
    <p>
     作用：创建项目、编辑调试代码、调试功能、小程序预览与发布。
    </p>
    <p>
     下载：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/75ad4752865788969648341a4622535f.png">
      <br/>
      点开之后可以下载稳定版本的。
     </img>
    </p>
    <p>
     下载安装包后安装即可。
    </p>
    <p>
     安装完成后，微信扫码打开登录
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ba31cad4b4e594c838558373897f48dd.png"/>
    </p>
    <h4>
     <a id="124__39">
     </a>
     1.2.4 修改代理模式
    </h4>
    <p>
     这属于一项配置，直接操作即可。
    </p>
    <p>
     点击右上角设置按钮，改成第一项：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5cb02b705947745d8ffbb8f1b17af722.png"/>
    </p>
    <h3>
     <a id="13__44">
     </a>
     1.3 第一个小程序
    </h3>
    <p>
     点击加号按钮：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5d0f0fe0928ae2a0e2a58b7f5130ba66.png">
      <br/>
      配置好一些信息，设置存放目录后，把之前的AppID复制过去，
      <mark>
       不使用云服务
      </mark>
      ，确保语言是js。
     </img>
    </p>
    <p>
     完成配置后，点开，页面如此：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/519b01dd494fa7988240ca8eeb6ea2b1.png">
      <br/>
      左侧是页面模拟器，右边有一个编译的按钮，点击后，就可解析代码到左侧的模拟器中。
     </img>
    </p>
    <p>
     如果想在手机查看，可点击编译按钮右侧的预览，扫码即可：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8759ec076961ad9727b0612664810083.png"/>
    </p>
    <h3>
     <a id="14__55">
     </a>
     1.4 开发文档
    </h3>
    <p>
     点击帮助，开发者文档即可打开：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6af4ffad68960b70d76a001b1cc921c1.png"/>
    </p>
    <h3>
     <a id="15__58">
     </a>
     1.5 机型
    </h3>
    <p>
     一般选择iPhone6、7、8版本：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ba98f1cf58468319136e950b32d6405c.png"/>
     <br/>
     缩放显示屏：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0b7526cd812d770acd408ad9da01d243.png"/>
    </p>
    <h3>
     <a id="16__63">
     </a>
     1.6 项目基本结构
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/63fa39ed7cbbd233b0c8104e5ca4847f.png"/>
    </p>
    <pre><code>pages：存放项目中所有小程序页面；
utils：所有工具性质的模块（如格式化时间）；
app.js：小程序项目入口文件；
app.json： 小程序项目的全局配置文件；
app.wxss：小程序项目的全局样式文件（全局）；
project.config.json：项目的配置文件；
sitemap.json：用来配置小程序及其页面是否允许被微信索引。
</code></pre>
    <h4>
     <a id="161__75">
     </a>
     1.6.1 页面内部文件
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/612711434c2e681c60d965ad9bb2ef98.png"/>
     <br/>
     <mark>
      一个页面由四个文件组成
     </mark>
    </p>
    <pre><code>.js：脚本文件，存放数据，事件处理函数等；
.json：配置文件，配置窗口外观，表现等；(json文件一般都是配置文件)
.wxml：页面模板结构摁键；
.wxss：当前页面的样式表文件。
</code></pre>
    <h4>
     <a id="162_appjson_84">
     </a>
     1.6.2 app.json
    </h4>
    <p>
     当前小程序的全职配置，包括：页面路径、窗口外观、界面表现、底部tab等。
    </p>
    <p>
     下面是初始化app.json文件的代码：
    </p>
    <pre><code class="prism language-javascript"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"pages"</span><span class="token operator">:</span><span class="token punctuation">[</span>
    <span class="token string">"pages/index/index"</span><span class="token punctuation">,</span>
    <span class="token string">"pages/logs/logs"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string-property property">"window"</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"backgroundTextStyle"</span><span class="token operator">:</span><span class="token string">"light"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"navigationBarBackgroundColor"</span><span class="token operator">:</span> <span class="token string">"#fff"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"navigationBarTitleText"</span><span class="token operator">:</span> <span class="token string">"Weixin"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"navigationBarTextStyle"</span><span class="token operator">:</span><span class="token string">"black"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">"style"</span><span class="token operator">:</span> <span class="token string">"v2"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"sitemapLocation"</span><span class="token operator">:</span> <span class="token string">"sitemap.json"</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     pages：用来记录当前小程序所有页面路径；
     <br/>
     window：全局定义小程序所有页面的背景色、文字颜色等；
     <br/>
     style：全局定义小程序组件所使用的样式版本；
     <br/>
     sitemapLocation：用来指明sitmap.json的位置。
    </p>
    <h4>
     <a id="163_projectconfigjson_110">
     </a>
     1.6.3 project.config.json
    </h4>
    <p>
     这个文件一般用于做一些自定义配置，本节看一下基本配置。
    </p>
    <p>
     appid：如果拿到一个别人的项目，可以把appid改成自己的，就可以在自己的电脑上运行：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/02d3ac48534b96ed3324807dffa979fd.png"/>
     <br/>
     projectname：项目名称，不等于小程序名称。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/074fb24b9aeaa19f66ed9532668e90f7.png"/>
    </p>
    <h4>
     <a id="164_sitemapjson_117">
     </a>
     1.6.4 sitemap.json
    </h4>
    <p>
     配置小程序页面是否允许微信索引：
    </p>
    <pre><code class="prism language-javascript"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"desc"</span><span class="token operator">:</span> <span class="token string">"关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"rules"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"action"</span><span class="token operator">:</span> <span class="token string">"allow"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"page"</span><span class="token operator">:</span> <span class="token string">"*"</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     上面这段代码，page后面是星号，表示所有页面，action后面是allow，表示所有页面都允许被索引。（不允许可以改成disallow）
    </p>
    <h4>
     <a id="165_json_130">
     </a>
     1.6.5 页面.json
    </h4>
    <p>
     对本页面的窗口外观进行配置，页面中的配置项会覆盖app.jsono的window中相同的配置项。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ae8a960287a38fe549e24b7941069593.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f3b1a26fad48857cff0aed85e32031a8.png"/>
     <br/>
     app.json是全局配置，如果页面配置与全局配置发生冲突，则依照页面配置来。
    </p>
    <p>
     <mark>
      注意，文章中只要更改了代码，都要ctrls保存一下，右边才会有显示。
     </mark>
    </p>
    <h3>
     <a id="17__138">
     </a>
     1.7 新建小程序页面
    </h3>
    <p>
     只需要在pages中新增页面存放路径，小程序开发者工具会自动帮我们创建页面文件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/02bcb7e85b5c7bbb594720f5927ddff5.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d3d7ac5f377ad844c8a63ea64df97503.png"/>
    </p>
    <h3>
     <a id="18_WXML_142">
     </a>
     1.8 WXML模板
    </h3>
    <h4>
     <a id="181_WXSSHTML_143">
     </a>
     1.8.1 WXSS与HTML
    </h4>
    <p>
     WXML是小程序框架设计的一套
     <mark>
      标签语言，用老构建小程序页面的结构
     </mark>
     ，类似网页开发中的HTML。
    </p>
    <p>
     WXML和HTML区别
    </p>
    <pre><code>标签名称不同：
HTML（div、span、img、a）
WXML（view、text、image、navigator）

属性节点不同：
&lt;a href="#"&gt;超链接&lt;/a&gt;
&lt;navigator url="/pages/home/home"&gt;&lt;/navigator&gt;

提供了类似Vue中的模板语法：
数据绑定、列表渲染、条件渲染
</code></pre>
    <h4>
     <a id="182_WXSSCSS_159">
     </a>
     1.8.2 WXSS与CSS
    </h4>
    <pre><code>新增了rpx尺寸单位:
CSS需要手动单位换算，如rem；
WXSS在底层支持新的尺寸单位rpx，在不同大小屏幕上自动换算

提供了全局样式和局部样式：
项目根据app.wxss设置全局页面，局部页面.wxss仅对自己的页面生效

WXSS仅支持部分CSS选择器。
类选择器、id选择器、元素选择器、并集选择器、后代选择器、伪类选择器
</code></pre>
    <h3>
     <a id="19_js_171">
     </a>
     1.9 js文件
    </h3>
    <pre><code>app.js：入口文件，可调用App()函数来启动整个小程序；
页面.js：页面入口文件，通过调用Page()函数来创建并运行页面；
普通.js： 用来封装公共函数或者属性供页面使用。
</code></pre>
    <h3>
     <a id="110__178">
     </a>
     1.10 小程序的宿主环境
    </h3>
    <h4>
     <a id="1101__179">
     </a>
     1.10.1 介绍宿主环境
    </h4>
    <p>
     宿主环境：程序运行所必须的依赖环境。
    </p>
    <p>
     安卓和IOS系统是两个不同的宿主环境，
     <mark>
      脱离了宿主环境的软件是没有任何意义的。
     </mark>
    </p>
    <p>
     这里以安卓为例。同样，IOS系统也有一套IOS系统的宿主环境（不放图了以此类推）。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0bb9bbb88ed9c8449d363e9cd92dda1b.png"/>
    </p>
    <h4>
     <a id="1102__186">
     </a>
     1.10.2 执行原理
    </h4>
    <p>
     1.通信模型
     <br/>
     通信主体：渲染层和逻辑层
     <br/>
     渲染层与逻辑层通过微信客户端进行通信。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/71b94cc78cc9eafae9a16941b1474c42.png"/>
     <br/>
     2.运行机制
     <br/>
     启动过程：
     <br/>
     下载包-&gt;解析app.json-&gt;执行app.js，通过App()-&gt;渲染小程序首页-&gt;启动完成
    </p>
    <p>
     页面渲染：
     <br/>
     加载.json-&gt;加载.wxml模板和.wxss样式-&gt;执行.js文件，调用Page()-&gt;渲染完成
    </p>
    <h2>
     <a id="_198">
     </a>
     二，组件
    </h2>
    <p>
     组件的存在，是为了代码的复用。系统封装好的导航，按钮，我们可以拿过来直接用，这就是组件。
    </p>
    <p>
     官方把小程序组件分为九大类：==视图容器、基本内容、表单组件、导航组件、==媒体组件、map地图组件、canvas画布组件、开放能力、无障碍访问。
    </p>
    <p>
     本节内容将带领读者了解小程序的常用组件。
    </p>
    <h3>
     <a id="21__204">
     </a>
     2.1 组件类型
    </h3>
    <p>
     本节讲一些微信小程序的常用组件。
    </p>
    <p>
     <mark>
      注意哦，wxss几乎与css一样，后文基于样式的，不详细讲，按照css来写即可。
     </mark>
    </p>
    <h3>
     <a id="22__208">
     </a>
     2.2 模拟器展示固定页面
    </h3>
    <p>
     一开始打开后：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c903c74dd7cf68b052b97f1d949c4763.png"/>
     <br/>
     但是如果我们要在其中一个页面中写样式，如何在模拟器中查看呢？
     <br/>
     在app.json中改变地址顺序即可：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d331a5f4dc412f0591384e7b3e4ab5f6.png"/>
    </p>
    <h3>
     <a id="23__214">
     </a>
     2.3 视图组件
    </h3>
    <h4>
     <a id="231_view_216">
     </a>
     2.3.1 view
    </h4>
    <p>
     先介绍view。view可以理解为div，也可也当div去用。在list中的wxml中的代码：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     可以在wxss中写样式，样式的写法和css一样。
    </p>
    <p>
     最后效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bab502635f46e15ced020c4e3341b7a8.png"/>
    </p>
    <h4>
     <a id="232_scrollview_230">
     </a>
     2.3.2 scroll-view
    </h4>
    <p>
     实现纵向滚动效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b9368bdf30f172a009f5497aad7b7a1f.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/52b9b15595313a3e9206ffc1731b5e1e.png"/>
     <br/>
     做法，在刚刚的基础上，把外面的标签改为scroll-view；如果纵向滚动，在外侧加一个强制属性：scr0ll-y，并且给scroll-view指定一个高度；如果是横向滚动，则强制属性为scroll-x，并且给scroll-view指定一个宽度。
     <br/>
     可以看下代码：
     <br/>
     .wxml:
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scroll-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container1<span class="token punctuation">"</span></span> <span class="token attr-name">scroll-y</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scroll-view</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     在之前的基础上指定高度：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bde4e43c05184d483591e9a2618c36f3.png"/>
    </p>
    <h3>
     <a id="24__247">
     </a>
     2.4 轮播图组件
    </h3>
    <h4>
     <a id="241_swiperswiperitem_248">
     </a>
     2.4.1 swiper与swiper-item
    </h4>
    <p>
     轮播图组件用swiper和swiper-item来做。
    </p>
    <p>
     外层用swiper包裹，内层用swiper-item来做。swiper-item内部可以自己写。看一下代码：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>swiper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>swiper-item</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>swiper-item</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>swiper-item</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>swiper-item</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>swiper-item</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>swiper-item</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>swiper</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     最后效果出来，就是个轮播
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2427f6412fd9c17014dac4156428b836.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/61d935767ff2e4aeffb2b777b50f5d4f.png"/>
     <br/>
     样式也可自己写，写完样式就很好看，下面这个是轮播过程截的图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a915748c0e7ff54e3196dc8a7d53b734.png"/>
    </p>
    <h4>
     <a id="242_swiper_271">
     </a>
     2.4.2 swiper组件常用属性
    </h4>
    <p>
     指示点：indicator-dots
     <br/>
     指示点颜色：indicator-color
     <br/>
     指示点选中颜色：indicator-active-color
     <br/>
     是否自动切换：autoplay
     <br/>
     自动切换时间间隔：interval
     <br/>
     是否采用衔接滑动：circular（到头了是否衔接到第一张）
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/09e02f079e6a228738d422cf0473c421.png"/>
    </p>
    <h3>
     <a id="25__280">
     </a>
     2.5 常用基础内容组件
    </h3>
    <p>
     本节讲解text与rich-text
    </p>
    <h4>
     <a id="251_text_282">
     </a>
     2.5.1 text
    </h4>
    <p>
     text：文本组件，类似于html中的span标签，是一个行内元素；
     <br/>
     rich-text：富文本组件，支持把html字符串渲染为wxml结构。
    </p>
    <p>
     先看text，只有text属性又selectable属性，这个属性出现之后可以长按选中：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">selectable</span><span class="token punctuation">&gt;</span></span>2092844344<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/45912a3e09c340f94a9ea3a8caec64ed.png"/>
     <br/>
     可以在真机上尝试一下。
    </p>
    <h4>
     <a id="252_richtext_295">
     </a>
     2.5.2 rich-text
    </h4>
    <p>
     通过rich-text组件的nodes属性节点，可以把html字符串渲染为对应的ui结构。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/14cdbe95edb32dab88b7e7a3da234727.png"/>
    </p>
    <h3>
     <a id="26__299">
     </a>
     2.6 其他常用组件
    </h3>
    <h4>
     <a id="261_button_300">
     </a>
     2.6.1 button
    </h4>
    <p>
     按钮组件，功能比html中的button更丰富，且通过
     <mark>
      open-type
     </mark>
     属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）
    </p>
    <p>
     默认button：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b9301d2d52d1b759f4872ceda6e919e7.png"/>
     <br/>
     指定不同类型可以使得按钮有不同颜色：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>默认按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>主色调按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>warn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>警告按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 小尺寸size="mini" --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mini<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mini<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>warn<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mini<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 镂空按钮 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">plain</span><span class="token punctuation">&gt;</span></span>默认按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mini<span class="token punctuation">"</span></span> <span class="token attr-name">plain</span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>warn<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mini<span class="token punctuation">"</span></span> <span class="token attr-name">plain</span><span class="token punctuation">&gt;</span></span>警告按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1a5a03aa14e85551aa18d927ea5b6fda.png"/>
     <br/>
     功能类后文会讲解。
    </p>
    <h4>
     <a id="262_image_323">
     </a>
     2.6.2 image
    </h4>
    <p>
     图片组件，image组件默认宽度约300px，高约240px。
    </p>
    <p>
     现在来渲染图片：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/27a4d774507e1e01ea46353e9ff45c53.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/91116892dc41b9ede62d1e0f3846c8fe.png"/>
     <br/>
     image中有一个mode属性，用来指定图片的
     <mark>
      裁剪和缩放模式
     </mark>
     ，常用的mode属性值如下：
     <br/>
     scaleToFill：默认值，缩放模式，不包吃纵横比缩放图片，使图片的宽高完全拉伸至填满image元素；
     <br/>
     aspectFit：缩放模式，保持纵横比缩放图片，使图片可以完整显示；
     <br/>
     aspectFill：缩放模式，只保证图片的短边可以完全显示出来；
     <br/>
     <mark>
      widthFix：缩放模式，宽度不变，高度自动变化（保持原图宽高比不变）；
      <br/>
      heightFix：缩放模式，高度不变，宽度自动变化（保持原图宽高比不变）。
     </mark>
     <br/>
     大家可以拿来试一下。
    </p>
    <h4>
     <a id="263_navigator_337">
     </a>
     2.6.3 navigator
    </h4>
    <p>
     页面导航组件，类似于html中的a链接。有机会单独出一篇博客。
    </p>
    <h4>
     <a id="264__339">
     </a>
     2.6.4 组件样式版本
    </h4>
    <p>
     在app.json文件中有一个样式版本：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6568dd3f24dc13b13a63c37fb9dbe71f.png"/>
     <br/>
     style后面是v2是目前最新版本的样式。如果删掉，样式会发生很大变化，以按钮为例吧：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ddd94cbf27bd2219061e646deae87a01.png"/>
     <br/>
     样式也是要基于需求的。
    </p>
    <h2>
     <a id="WXML_346">
     </a>
     三，WXML模板语法
    </h2>
    <h3>
     <a id="31__347">
     </a>
     3.1 数据绑定
    </h3>
    <p>
     基本原则：在当前页面对应的.js文件中有个data，在data中定义数据，在WXML中使用数据，与Vue非常类似。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b1f4a9b762d6c8012fd64de6b8bce19d.png"/>
     <br/>
     我们现在往里面写数据：
     <br/>
     <mark>
      Mustache语法：{
      <!-- -->
      {}}，两个大括号
     </mark>
     ，数据在data中定义好了，在页面中使用直接：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{<!-- -->{要绑定的数据名称}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     定义数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/04b42c07a060d5a7c3f8bdfe91e71c27.png"/>
     <br/>
     渲染数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b6f2c666317ffe830ffe7fd529e30321.png"/>
     <br/>
     最后效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0fbc2f13958dc7309a67b0ef0ca4e469.png"/>
    </p>
    <h3>
     <a id="32_mustache_362">
     </a>
     3.2 mustache语法的应用场景
    </h3>
    <p>
     绑定内容
     <br/>
     刚刚上面讲的就是动态绑定内容
    </p>
    <p>
     绑定属性
     <br/>
     比如我的wxml中有一个image，但是src不是固定的，那么我们可以动态绑定地址数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f7d1c8f909005eb91f2bd6aacebcd0b4.png"/>
     <br/>
     这里需要注意一下，写法与vue稍有差别。vue中img中的src可以采取单向绑定v-bind，但是这里直接用模板语法就好了。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c16efbb8adc2887411df99404508743a.png"/>
    </p>
    <p>
     绑定计算
     <br/>
     在模板语法中是可以对数据进行操作的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/cd2e7083a6591c669ece64a0583d1bd4.png"/>
     <br/>
     三元运算：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/726e9dfc299db83d4b39a9e4f22ebed9.png"/>
     <br/>
     <mark>
      在Appdata中可以查看到全部数据：
     </mark>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/14f0024942ed7e9aa9cb004580ab4a11.png"/>
    </p>
    <h2>
     <a id="_379">
     </a>
     四，事件绑定
    </h2>
    <h3>
     <a id="41__380">
     </a>
     4.1 事件介绍
    </h3>
    <p>
     事件是什么？==是渲染层到逻辑层的通讯方式。==渲染层（页面）-&gt;逻辑层（js代码），中间的方式是事件。
    </p>
    <p>
     事件有哪些？点击事件，鼠标移动事件等等。
    </p>
    <p>
     小程序中常用的事件：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        绑定方式
       </th>
       <th>
        事件描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        tap
       </td>
       <td>
        bindtap 或 bind:tap
       </td>
       <td>
        手指触摸后马上离开，类似于Html中的click事件
       </td>
      </tr>
      <tr>
       <td>
        input
       </td>
       <td>
        bindinput 或 bind:input
       </td>
       <td>
        文本框的输入事件
       </td>
      </tr>
      <tr>
       <td>
        change
       </td>
       <td>
        bindchange 或 bind:change
       </td>
       <td>
        状态改变时触发
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="42__392">
     </a>
     4.2 事件对象的属性列表
    </h3>
    <p>
     事件回调触发，会收到一个参数event（对象），对象有这些属性：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性
       </th>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        type
       </td>
       <td>
        String
       </td>
       <td>
        event.type获取，反应事件类型
       </td>
      </tr>
      <tr>
       <td>
        timestamp
       </td>
       <td>
        Integer
       </td>
       <td>
        页面打开到触发事件所经过的毫秒数
       </td>
      </tr>
      <tr>
       <td>
        <mark>
         target
        </mark>
       </td>
       <td>
        <mark>
         Object
        </mark>
       </td>
       <td>
        <mark>
         触发事件的组件（遇到冒泡就是源头组件）的一些属性集合
        </mark>
       </td>
      </tr>
      <tr>
       <td>
        currentTarget
       </td>
       <td>
        Object
       </td>
       <td>
        当前所绑定的组件的一些属性值集合
       </td>
      </tr>
      <tr>
       <td>
        <mark>
         detail
        </mark>
       </td>
       <td>
        <mark>
         Object
        </mark>
       </td>
       <td>
        <mark>
         额外的信息
        </mark>
       </td>
      </tr>
      <tr>
       <td>
        touches
       </td>
       <td>
        Array
       </td>
       <td>
        触摸事件，当前停留在屏幕中的触摸点信息的数组
       </td>
      </tr>
      <tr>
       <td>
        changedTouches
       </td>
       <td>
        Array
       </td>
       <td>
        触摸事件，当前变化的触摸点信息的数组
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="43_bindtap_403">
     </a>
     4.3 bindtap
    </h3>
    <h4>
     <a id="431_bindtap_404">
     </a>
     4.3.1 bindtap使用
    </h4>
    <p>
     在小程序中，通过tap事件来响应用户的触摸行为。现以bindtap为例讲解。
    </p>
    <p>
     现给按钮绑定触摸事件：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clickit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     接着在js中编写回调
    </p>
    <pre><code class="prism language-javascript">  <span class="token comment">// 回调</span>
  <span class="token function">clickit</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre>
    <p>
     效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c1bb39c21f3c59850fc1390f3794c486.png"/>
    </p>
    <h4>
     <a id="432__422">
     </a>
     4.3.2 事件传参与数据同步
    </h4>
    <p>
     通过调用this.setData(dataObject)方法，可以给页面data中的数据重新赋值。
    </p>
    <p>
     需求：在data中定义一个count，页面上有个按钮，点击后data自增。
    </p>
    <p>
     给按钮绑定事件：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addcount<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击后count值自增<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <p>
     定义count：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1e23359c5c89e5915c8af0b9f6f48460.png"/>
     <br/>
     自增代码：
    </p>
    <pre><code class="prism language-javascript">    <span class="token function">addcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
    <h3>
     <a id="45__442">
     </a>
     4.5 事件传参
    </h3>
    <p>
     在vue的事件中，可以直接在函数括号内传递参数，但是小程序中不行，小程序会默认把括号内的字符串当作事件名称来处理。
    </p>
    <p>
     传参方式：为组件提供 data-*自定义属性传参，其中
     <mark>
      星号代表的是参数的名字。
     </mark>
    </p>
    <p>
     传参方法：event.target.dataset.参数名可获取到具体的参数的值。
    </p>
    <p>
     点击按钮后，count+2：
    </p>
    <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span> <span class="token attr-name">bindtap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>canshu<span class="token punctuation">"</span></span> <span class="token attr-name">data-info</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{<!-- -->{2}}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>count+传参<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <pre><code class="prism language-javascript">    <span class="token function">canshu</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>count <span class="token operator">+</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>info
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
    <h3>
     <a id="46_bindinput_461">
     </a>
     4.6 bindinput的
    </h3>
    <h4>
     <a id="461_bindinput_462">
     </a>
     4.6.1 bindinput的使用
    </h4>
    <p>
     在小程序中，通过input事件来响应文本框输入事件。
    </p>
    <p>
     先定义文本框，注意，输入框默认是看不见的，但是鼠标过去光标会一闪一闪的。是存在的。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/cda8155886ac5caeb73750cc9468c754.png"/>
    </p>
    <p>
     在json文件中配置：
    </p>
    <pre><code class="prism language-javascript"><span class="token comment">// input的内容</span>
    <span class="token function">inputHandler</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
    <p>
     最后的效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/846e4198c9190d8b07677fc91101ce79.png"/>
    </p>
    <h4>
     <a id="462_data_478">
     </a>
     4.6.2 文本框和data之间的数据同步
    </h4>
    <p>
     实现步骤：
     <br/>
     定义数据
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/32d158fe6565679f7d4822ee502060fd.png"/>
    </p>
    <p>
     渲染结构
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/55f8d40e1453215c94028eb6455e1bed.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2bf8eb027adc5edca890f13a4116f0cf.png"/>
    </p>
    <p>
     美化样式
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1cca05c68bc1ce82323df0772d80580f.png"/>
    </p>
    <p>
     绑定input事件处理函数
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3c81603929207c605e431fbe8836c7ea.png"/>
     <br/>
     实现同步：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0010d88559cda41e358dd1741d563eb0.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b24ef7aae0e531bf0ca68fbda5f1cce9.png"/>
    </p>
    <h2>
     <a id="_496">
     </a>
     五，条件渲染与列表渲染
    </h2>
    <h3>
     <a id="51_wxif_497">
     </a>
     5.1 条件渲染wx:if
    </h3>
    <p>
     在小程序中，使用wx:if="{
     <!-- -->
     {}}"来判断是否需要渲染代码块
    </p>
    <p>
     定义一个判断调价type：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/424d283a16e4eac80f90aa9a6cd572dd.png"/>
     <br/>
     使用wx:if进行条件渲染，根据type的值来展示对应信息：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/72d1ed96b6076ef7d9168ffe4bb1c286.png"/>
     <br/>
     最后结果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3f2d5437d0892f0cea9ef79a7bdbe181.png"/>
     <br/>
     同样还可以由elif，else：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/39dbf4678e94989f58421521d9d8a3b3.png"/>
     <br/>
     上面这个就跟if的逻辑是一样的。但是要注意的是，else中什么都不用写。
    </p>
    <p>
     如果有多个wx:if可以使用包裹标签block进行包裹，一次性的控制内容显示或隐藏：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c81dd00261b23ba3e2554662447e1edf.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f63009573d6bc15b68069f340e846ee6.png"/>
     <br/>
     <mark>
      block类似于vue中的template，不参与页面结构，不会把block渲染出来，避免渲染出一些不必要的结点。
     </mark>
    </p>
    <h3>
     <a id="52_hidden_515">
     </a>
     5.2 hidden的使用
    </h3>
    <p>
     使用hidden也可也控制元素的显示和隐藏。
    </p>
    <p>
     设置一个flag，布尔类型：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/67084f6c19ab8e685c1a8d931cdf7bd2.png"/>
     <br/>
     在页面中使用：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ca1add1458cbc1898c25c1ae5b469242.png"/>
    </p>
    <h3>
     <a id="53_wxifhidden_522">
     </a>
     5.3 wx:if与hidden对比
    </h3>
    <p>
     wx:if以动态创建和移除元素的方式，控制元素的显示和隐藏；（移除后结构不存在）
    </p>
    <p>
     hidden以切换样式的方式，类似于display，控制元素的显示和隐藏。（结构存在但是隐藏）
    </p>
    <p>
     使用情况：
     <br/>
     频繁切换的时候，建议使用hidden；不频繁可以使用wx:if，目的在于提高性能。
    </p>
    <h3>
     <a id="54_wxfor_529">
     </a>
     5.4 列表渲染wx:for
    </h3>
    <p>
     可以根据指定的数组，循环渲染重复的组件结构。
    </p>
    <p>
     在data中定义一个数组arr：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/84bb34a28c78dea8260ef4b3f4e5d283.png"/>
     <br/>
     接着在页面中渲染，这个我觉得比vue要高级一点，小程序中数组的index和item都是内置的，index是索引，item是索引对应的项。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e0c8530f3b1c6fd67b7067aec33a013b.png"/>
     <br/>
     直接就可以渲染在页面中：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c9ecf71f282ed0687948088b9d0bc585.png"/>
    </p>
    <h3>
     <a id="55_indexitem_538">
     </a>
     5.5 给index和item取名字
    </h3>
    <p>
     给index和item重命名：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2affcbd5f0e31a82033f20914aa7ed1c.png"/>
    </p>
    <h3>
     <a id="56_wxkey_541">
     </a>
     5.6 wx:key
    </h3>
    <p>
     类似于vue中的：key，小程序在实现列表渲染，也建议为渲染出来的列表项指定唯一的key，从而提高渲染的效率。
    </p>
    <p>
     解释一下，这里的key是当前项的唯一标识(id)，但是最好不要用index作为key使用。
    </p>
    <p>
     设置一个数组username：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a2c3e2a2553cb495a68d8754f2df57f5.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3a47c931a8e4dc270f09964ff0fa9388.png"/>
    </p>
    <p>
     <mark>
      有个建议，每用一个数组都要带上这个wx:key，是为了提高渲染性能，否则在终端中会出现黄色警告
     </mark>
    </p>
    <hr/>
    <p>
     上面的内容讲了很多，都在围绕着wxml来讲解。因为内容很多，所以分了很多个大块。后面wxss的内容较少，所以一个块讲解就够了，也就是下面的这一个。
    </p>
    <h2>
     <a id="wxss_554">
     </a>
     六，wxss模板样式
    </h2>
    <h3>
     <a id="61_wxsscss_555">
     </a>
     6.1 wxss与css的关系
    </h3>
    <p>
     wxss是一套样式语言，类似于css。
    </p>
    <p>
     wxss具有大部分css特性，并且还对css进行了扩展——rpx尺寸单位于@import样式导入。
    </p>
    <h3>
     <a id="62_rpx_560">
     </a>
     6.2 rpx尺寸单位
    </h3>
    <p>
     rpx是微信小程序独有的，
     <mark>
      用来解决适配的尺寸单位。
     </mark>
    </p>
    <p>
     实现原理：把所有屏幕宽度上等分为
     <mark>
      750份
     </mark>
     。（当前屏幕的总宽度为750rpx）
    </p>
    <p>
     在
     <mark>
      较小
     </mark>
     的设备上，1rpx所代表的宽度较小；
     <br/>
     在
     <mark>
      较大
     </mark>
     的设备上，1rpx所代表的宽度较大。
    </p>
    <p>
     当小程序在不同设备上运行的时候，会自动把rpx的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配。
    </p>
    <p>
     那么，rpx与px怎么换算？
    </p>
    <p>
     在iphone6上（标准，标准设计稿），屏幕宽度为375px，共有750个物理像素，等分为750rpx，则1px = 2rpx，也就是说，1rpx = 0.5px；
    </p>
    <p>
     其他手机型号换算多少会有些不一样，但是这个不影响，实际开发都是用rpx，页面会在不同设备上进行自动缩放。
    </p>
    <h3>
     <a id="63__575">
     </a>
     6.3 样式导入
    </h3>
    <p>
     使用wxss提供的@import语法，可以导入外联的样式表。
    </p>
    <p>
     @import后面需要导入外联样式表的
     <mark>
      相对路径
     </mark>
     ，用；表示语句结束。
    </p>
    <p>
     举个例子，新建一个common作为公共样式表：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/51f6e076d048e44db29224a13975a919.png"/>
     <br/>
     在内部定义公共样式：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d1f1828c819623099ada01001de8e6db.png"/>
     <br/>
     在另一个模块导入这个样式表：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/be135884db4460d1595f5a3d38ca7068.png"/>
     <br/>
     于是在当前模块可以看到效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/13612068fe306e1a20b2738c88603a1c.png"/>
    </p>
    <h3>
     <a id="64__589">
     </a>
     6.4 全局样式与局部样式
    </h3>
    <p>
     全局样式可以理解为所有页面都遵循的样式；而局部央视只为所在页面服务。
    </p>
    <p>
     全局样式在app.wxss中编写，而局部样式在当前页面的文件夹内部的wxss文件中编写。
    </p>
    <p>
     注意，当局部样式和全局昂是冲突，根据就近原则，局部样式会
     <mark>
      覆盖
     </mark>
     全局样式
    </p>
    <p>
     当局部样式
     <mark>
      权重大于或等于
     </mark>
     全局样式的权重，才会覆盖全局样式。
    </p>
    <h2>
     <a id="_598">
     </a>
     七，全局配置
    </h2>
    <p>
     小程序根目录下的app.json文件是小程序的全局配置文件，常用配置：
    </p>
    <pre><code>pages：
记录当前小程序所有页面的存放路径；

window：
全局设置小程序窗口的外观；

tabBar：
设置小程序底部的tabBar效果；

style：
是否启用新版的组件样式。

</code></pre>
    <p>
     一个个说吧，pages之前讲过，但是唯一要注意的是pages中的页面顺序，第一个页面是展示页面，比如下面这个，展示的就是wcs页面：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ab5af47473638366d8c0bf62d4cd16da.png"/>
     <br/>
     style上文在讲按钮的时候也说过，style是组件的样式版本，如果改动，样式会有很大的改变。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/dc8befe124193ab4346658a0aa007885.png"/>
     <br/>
     比较重要的就是，window和tabBar。
    </p>
    <p>
     本节的重点也在这两个上面。
    </p>
    <h3>
     <a id="71_window_622">
     </a>
     7.1 window
    </h3>
    <p>
     window的几个部分：
     <br/>
     头部导航栏，有微信两字的栏目；
     <br/>
     背景区域，默认不展现，下拉展现：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9a47e38e421cef8cfb7583f787a51372.png"/>
     <br/>
     主体部分，除却导航栏下面的展示部分。
    </p>
    <p>
     下面是截取json中的window部分。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/207f13380fe07abaaf6a95e9a77ce76a.png"/>
    </p>
    <p>
     window中有很多常用配置项：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性名
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        navigationBarTitleText
       </td>
       <td>
        导航栏标题文字内容
       </td>
      </tr>
      <tr>
       <td>
        navigationBarBackgroundColor
       </td>
       <td>
        导航栏背景色
       </td>
      </tr>
      <tr>
       <td>
        navigationBarTextStyle
       </td>
       <td>
        导航栏标题颜色，仅支持black/white
       </td>
      </tr>
      <tr>
       <td>
        backgroundColor
       </td>
       <td>
        窗口背景色
       </td>
      </tr>
      <tr>
       <td>
        backgroundTextStyle
       </td>
       <td>
        下拉loading样式，仅支持dark/light
       </td>
      </tr>
      <tr>
       <td>
        enablePullDownRefresh
       </td>
       <td>
        布尔值，是否全局开启下拉刷新
       </td>
      </tr>
      <tr>
       <td>
        onReachBottomDistance
       </td>
       <td>
        数字类型，页面上拉触底事件触发时距页面底部距离（距离底部多少px刷新页面），单位px
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     以上颜色几乎都是十六进制代码。
    </p>
    <p>
     可以拿着下面这段代码去试试：
    </p>
    <pre><code class="prism language-css">  <span class="token string">"window"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"backgroundTextStyle"</span><span class="token punctuation">:</span> <span class="token string">"light"</span><span class="token punctuation">,</span>
    <span class="token string">"navigationBarBackgroundColor"</span><span class="token punctuation">:</span> <span class="token string">"#fc5531"</span><span class="token punctuation">,</span>
    <span class="token string">"navigationBarTitleText"</span><span class="token punctuation">:</span> <span class="token string">"巧克力小猫猿"</span><span class="token punctuation">,</span>
    <span class="token string">"navigationBarTextStyle"</span><span class="token punctuation">:</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    <span class="token string">"enablePullDownRefresh"</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
    <span class="token string">"backgroundColor"</span><span class="token punctuation">:</span> <span class="token string">"#efefef"</span><span class="token punctuation">,</span>
    <span class="token string">"onReachBottomDistance"</span><span class="token punctuation">:</span> 20
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
    <p>
     最后效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7bf7e61bb45c1d6a58bc8ab5d2049e10.png"/>
    </p>
    <h3>
     <a id="72_tabBar_660">
     </a>
     7.2 tabBar
    </h3>
    <p>
     用于实现多页面的快速切换。
    </p>
    <p>
     小程序中分为两类：底部tabBar，顶部tabBar，如下图所示：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ba9e4d23ca9361f55ff2600dc8f010da.png"/>
    </p>
    <p>
     注意：
     <br/>
     tabbar内部只能配置最少两个，最多五个tab页签；
     <br/>
     当渲染顶部tabBar，不显示icon，只显示文本。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性名
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        backgroundColor
       </td>
       <td>
        tabBar的背景色
       </td>
      </tr>
      <tr>
       <td>
        selectediconPath
       </td>
       <td>
        选中时的图片路径
       </td>
      </tr>
      <tr>
       <td>
        borderStyle
       </td>
       <td>
        tabBar上边框的颜色
       </td>
      </tr>
      <tr>
       <td>
        iconPath
       </td>
       <td>
        未选中时的图片路径
       </td>
      </tr>
      <tr>
       <td>
        selectedColor
       </td>
       <td>
        tab上的文字选中时的颜色
       </td>
      </tr>
      <tr>
       <td>
        color
       </td>
       <td>
        tab上文字的默认（未选中）颜色
       </td>
      </tr>
      <tr>
       <td>
        <mark>
         list（必填）
        </mark>
       </td>
       <td>
        tab页签的列表（最少2个最多5个）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     list中每个tab项的配置选项：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性名
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <mark>
         pagePath（必填）
        </mark>
       </td>
       <td>
        页面路径，页面必须在pages中预先定义
       </td>
      </tr>
      <tr>
       <td>
        <mark>
         text（必填）
        </mark>
       </td>
       <td>
        tab上显示文字
       </td>
      </tr>
      <tr>
       <td>
        iconPath
       </td>
       <td>
        <mark>
         未选中
        </mark>
        时候的图标路径
       </td>
      </tr>
      <tr>
       <td>
        selectedIconPath
       </td>
       <td>
        <mark>
         选中时
        </mark>
        图标路径
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     这里有个例子，可以拿去试一下：
    </p>
    <pre><code class="prism language-xml">"tabBar": {
    "selectedColor": "#00b26a",
    "list":[
      {
        "pagePath": "pages/wcs/wcs",
        "text": "样式",
        "iconPath": "/images/1.png",
        "selectedIconPath": "/images/1.png"
      }, 
      {
        "pagePath": "pages/model/model",
        "text": "模型",
        "iconPath": "/images/2.png",
        "selectedIconPath": "/images/2.png"
      },
      {
        "pagePath": "pages/list/list",
        "text": "列表",
        "iconPath": "/images/3.png",
        "selectedIconPath": "/images/3.png"
      },
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "/images/4.png",
        "selectedIconPath": "/images/4.png"
      }
    ]
  },
</code></pre>
    <p>
     <mark>
      需要注意的是，tabBar中的页面一定要在Page属性中的前面。
     </mark>
    </p>
    <h3>
     <a id="73__723">
     </a>
     7.3 页面配置
    </h3>
    <p>
     页面配置在页面的json文件中，配置内容几乎与全局配置一样。
    </p>
    <p>
     需要注意的是，当页面配置与全局配置产生冲突时，会覆盖相同的全局配置。
    </p>
    <p>
     还有一个注意点：一般情况下，页面不需要都配置下拉刷新，是根据需要来的。所以不建议在全局配置中配置这一项。
    </p>
    <h2>
     <a id="_729">
     </a>
     八，网络数据请求
    </h2>
    <h3>
     <a id="81__730">
     </a>
     8.1 请求限制
    </h3>
    <p>
     出于安全性考虑，小程序官方对数据接口的请求做出了如下两个限制：
     <br/>
     <mark>
      只能请求Https类型的接口；
     </mark>
     <br/>
     <mark>
      必须将接口的域名添加到信任列表中；
     </mark>
    </p>
    <p>
     所以做小程序，首先还是要进行接口的一些配置：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/38209be7781cdce618caa465e25a5a9d.png"/>
    </p>
    <h3>
     <a id="82__737">
     </a>
     8.2 配置小程序接口
    </h3>
    <p>
     需求：在自己的小程序中，希望请求https://www.escook.cn域名下的接口
    </p>
    <p>
     配置步骤：
     <br/>
     <mark>
      登录微信小程序管理后台–&gt;开发–&gt;开发设置–&gt;服务器域名–&gt;修改request合法域名。
     </mark>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/86c8cb1975c55099a944da965b4c4d2c.png"/>
     <br/>
     服务器域名设置：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6851efc293c74e07b18b5cffb78b8031.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7c788b0c02fb8e6f8009d4ea6ad78bd4.png"/>
     <br/>
     比如说，我们的项目想请求这个接口：https://www.escook.cn，就要把这个配置到request合法域名(填写request对应的表单即可，其他不用管）。配置完后，结果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/22366d31f768988c2f9dab44f2f5ce57.png"/>
     <br/>
     再打开开发者工具后，就自动有相关配置，我们的小程序就可以请求这个域名下的所有接口了：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0649d99fe8ac9d57d931a4e161442ecd.png"/>
     <br/>
     注意：域名只支持https协议，且不能使用IP地址或localhost，域名必须镜柜ICP备案，且服务器域名一个月内最多可申请5次修改。
    </p>
    <h3>
     <a id="83_requiregetpost_754">
     </a>
     8.3 使用require发起get和post请求
    </h3>
    <p>
     发起get请求：比如我在index中设置一个按钮，并绑定事件getInfo，点击发起get请求：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/cbe004a62891b14d6792a5acd56b6c1b.png"/>
     <br/>
     接着我们去配置getInfo，注意，这个函数与data平级：
    </p>
    <pre><code class="prism language-javascript"><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://www.escook.cn/api/get'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'zs'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
    <p>
     运行：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/dba974be48404919224afad57677ea1a.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3358c23f225bf626f1c20a968d5e60e3.png"/>
    </p>
    <hr/>
    <p>
     post请求：很类似，都是调用wx.request()：
    </p>
    <pre><code class="prism language-javascript">  <span class="token function">postInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
      <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://www.escook.cn/api/post'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'ls'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">23</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/eb7305e158fe218376d1baaf6c624180.png"/>
    </p>
    <h3>
     <a id="84__797">
     </a>
     8.4 在页面刚加载时请求数据
    </h3>
    <p>
     在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据：
     <mark>
      在onload事件中调用获取数据的函数
     </mark>
     。
    </p>
    <p>
     就类似于vue中的mounted生命周期函数。
     <mark>
      onload事件是微信小程序的生命周期函数，用于监听页面的加载。
     </mark>
    </p>
    <p>
     当页面一加载成功就调用get和post请求:
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e14c37e8c44a1df4d30189038caa4f8f.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2c6e4edc8e552a4e0444c6809ed4b662.png"/>
    </p>
    <h3>
     <a id="85_request_805">
     </a>
     8.5 跳过request合法域名校验
    </h3>
    <p>
     如果后端程序员
     <mark>
      仅仅提供了http协议的接口，暂时没有提供https协议的接口，该怎么办？
     </mark>
    </p>
    <p>
     为了不耽误开发进度，可以在微信开发者工具中，==临时开启“开发环境不校验请求域名，TLS版本及HTTPS证书”选项，跳过request合法域名的校验。
    </p>
    <p>
     在详情里面：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/051a2fae96c97627e61ad63566ec8563.png"/>
     <br/>
     注意哦，这个没办法上线，只供
     <mark>
      开发与调试阶段使用。
     </mark>
    </p>
    <h3>
     <a id="86_Ajax_813">
     </a>
     8.6 关于跨域问题和Ajax的说明
    </h3>
    <p>
     跨域问题
     <mark>
      只存在于
     </mark>
     基于浏览器的web开发中，由于
     <mark>
      小程序的宿主环境
     </mark>
     不是浏览器，而是
     <mark>
      微信客户端
     </mark>
     ，所以==小程序不存在跨域问题。
    </p>
    <p>
     另外，Ajax的核心是基于
     <mark>
      浏览器
     </mark>
     中的XMLHttpRequest对象，而小程序
     <mark>
      宿主环境是微信客户端
     </mark>
     ，所以小程序
     <mark>
      不能叫做
     </mark>
     发“发起Ajax请求”，而是叫做“
     <mark>
      发起网络数据请求
     </mark>
     ”。
    </p>
    <h2>
     <a id="_817">
     </a>
     九，页面导航
    </h2>
    <p>
     页面导航指的是页面之间的相互跳转。
    </p>
    <p>
     浏览器中，实现页面导航的方式：a连接和location.href。
    </p>
    <p>
     小程序中也有两种方式实现页面导航：声明式导航和编程式导航。
    </p>
    <h3>
     <a id="91__823">
     </a>
     9.1 声明式导航
    </h3>
    <p>
     声明式导航：
     <br/>
     在页面上声明一个navigator的导航组件，通过点击navigator组件实现页面跳转。
    </p>
    <h4>
     <a id="911_tabBar_827">
     </a>
     9.1.1 导航到tabBar页面
    </h4>
    <p>
     可以使用navigator组件跳转到指定的tabBar页面，需要指定url属性和open-type属性。
    </p>
    <p>
     url：表示要跳转的页面的地址，必须以/开头；
     <br/>
     open-type：表示跳转方式，必须为switchTab。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8bbdf2e7fe84aabd8e59b1e66d636aec.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c8743bdf5e2dc8cade467022a8c47890.png"/>
    </p>
    <h4>
     <a id="912_tabBar_836">
     </a>
     9.1.2 导航到非tabBar页面
    </h4>
    <p>
     非tabBar：没有配置到tabBar的页面
    </p>
    <p>
     创建一个新的info页面，但不配置在tabBar中：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fd55e306d50471424c53fa95e81d5d8b.png"/>
    </p>
    <p>
     跟上面的一样，我们在首页弄个链接：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9a4e26d3697d5d75d85b46e75497f31e.png"/>
     <br/>
     点击后就可导航到info页面。
    </p>
    <h4>
     <a id="913__845">
     </a>
     9.1.3 实现后退效果
    </h4>
    <p>
     open-type值必须是navigateBack；
    </p>
    <p>
     delta的值必须是数字，表示要后退的层级。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e4304068e13eed502d3b7e9999dab228.png"/>
    </p>
    <h3>
     <a id="92__850">
     </a>
     9.2 编程式导航
    </h3>
    <p>
     编程式导航是写代码进行跳转。
    </p>
    <h4>
     <a id="921_tabBar_852">
     </a>
     9.2.1 导航到tabBar页面
    </h4>
    <p>
     调用wx.switchTab(Object Object)方法，可以跳转到tabBar页面。其中Object参数对象的属性列表如下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性
       </th>
       <th>
        是否必选
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        url
       </td>
       <td>
        是
       </td>
       <td>
        需要跳转的tabBar页面的路径，路径后不能带参数
       </td>
      </tr>
      <tr>
       <td>
        sucess
       </td>
       <td>
        否
       </td>
       <td>
        接口调用成功后回调
       </td>
      </tr>
      <tr>
       <td>
        fail
       </td>
       <td>
        否
       </td>
       <td>
        接口调用失败后回调
       </td>
      </tr>
      <tr>
       <td>
        complete
       </td>
       <td>
        否
       </td>
       <td>
        接口调用结束的回调函数
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     编程式导航示例，先在首页写个按钮：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bbec11eba5b9198d810ea2ab359fcf51.png"/>
     <br/>
     接着写跳转的相关代码：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2f7da44876087d453e6d42c9a46aaedd.png"/>
     <br/>
     上面这个办法只适合tabBar页面。
    </p>
    <h4>
     <a id="922_tabBar_867">
     </a>
     9.2.2 导航到非tabBar页面
    </h4>
    <p>
     调用vx.navigateTo(Object, Object)方法，可以跳转非tabBar的页面，其中，Object参数对象属性列表：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性
       </th>
       <th>
        是否必选
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        url
       </td>
       <td>
        是
       </td>
       <td>
        需要跳转非tabBar页面的路径，路径后不能带参数
       </td>
      </tr>
      <tr>
       <td>
        sucess
       </td>
       <td>
        否
       </td>
       <td>
        接口调用成功后回调
       </td>
      </tr>
      <tr>
       <td>
        fail
       </td>
       <td>
        否
       </td>
       <td>
        接口调用失败后回调
       </td>
      </tr>
      <tr>
       <td>
        complete
       </td>
       <td>
        否
       </td>
       <td>
        接口调用结束的回调函数
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ec953d9113cd2275cf8a5dcb153b146f.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/795a8b180d0d9641f06c8dae47f29b4e.png"/>
    </p>
    <h4>
     <a id="923__879">
     </a>
     9.2.3 编程式导航实现后退效果
    </h4>
    <p>
     调用navigateBack(Object, Object)方法，参数对象可选属性列表：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        属性
       </th>
       <th>
        是否必选
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        delta
       </td>
       <td>
        否
       </td>
       <td>
        默认值为1，返回的页面数，如果delta大于现有页面数则返回到首页
       </td>
      </tr>
      <tr>
       <td>
        sucess
       </td>
       <td>
        否
       </td>
       <td>
        接口调用成功后回调
       </td>
      </tr>
      <tr>
       <td>
        fail
       </td>
       <td>
        否
       </td>
       <td>
        接口调用失败后回调
       </td>
      </tr>
      <tr>
       <td>
        complete
       </td>
       <td>
        否
       </td>
       <td>
        接口调用结束的回调函数
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="93__887">
     </a>
     9.3 导航传参
    </h3>
    <h4>
     <a id="931__888">
     </a>
     9.3.1 声明式导航传参
    </h4>
    <p>
     navigator组件的url属性用来指定将要跳转的页面路径，同时，页面路径后面可以携带参数，规则如下：
     <br/>
     参数与路径之间用？分割；
     <br/>
     参数键与参数值用=项链；
     <br/>
     不同参数用&amp;分隔
    </p>
    <p>
     代码示例如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/aee36525c5f5f38167720153810f461f.png"/>
     <br/>
     我们来看一下页面参数，点击左下角的页面路径-&gt;页面参数
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8f513617b51bfe639667ea6db0d1e2fe.png"/>
     <br/>
     即可看到：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fece1f544061621321c1e411f44a0712.png"/>
    </p>
    <h4>
     <a id="932__901">
     </a>
     9.3.2 编程式导航传参
    </h4>
    <p>
     与上面一样，依旧是在url中做工作
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/899c1453899216fc77f5975a6a0705bc.png"/>
    </p>
    <h3>
     <a id="94_onLoad_904">
     </a>
     9.4 在onLoad中接收导航参数
    </h3>
    <p>
     通过
     <mark>
      声明式导航传参或编程式导航传参
     </mark>
     所携带的参数，可以直接在onLoad事件中直接获取到。
    </p>
    <p>
     比如我刚刚从首页跳转到info过程中传递参数，我在info中的onLoad中打印options：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/306d64d1f41546c9ec812f4fec786287.png"/>
     <br/>
     当我们点击导航按钮，可以在控制台看到参数：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b0378f117ff4b286bc81fb73124b887a.png"/>
     <br/>
     一般情况下都会转存到data节点中，可以用赋值的方法，在data中设置一个query：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d5097a62a6cc259d617fc2813fbafeda.png"/>
     <br/>
     接收参数后给query赋值：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a6905ba4f2c5b9dfe967c8589f1854f5.png"/>
    </p>
    <h2>
     <a id="_915">
     </a>
     十，页面事件
    </h2>
    <p>
     页面事件类似于之前学到的按钮事件。
    </p>
    <p>
     还有一些其他的页面事件，如下拉刷新、上拉触底。本节内容主要介绍的就是下拉刷新与上拉触底。
    </p>
    <h3>
     <a id="101__920">
     </a>
     10.1 下拉刷新
    </h3>
    <p>
     下拉刷新指通过手指在屏幕上的下拉滑动操作，从而重新加载页面的数据的行为。
    </p>
    <p>
     小程序默认是没有下拉刷新这种效果的，启用下拉刷新有两种方式：
    </p>
    <p>
     全局开启下拉刷新：
     <br/>
     在app.json这个全局配置文件中，window节点，把enablePullDownRefresh设置为true。（不推荐）
    </p>
    <p>
     局部开启下拉刷新。
     <br/>
     为需要的页面，在该页面的json文件下的window节点中，将enablePullDownRefresh设置为true。
    </p>
    <h3>
     <a id="102__930">
     </a>
     10.2 监听下拉刷新事件
    </h3>
    <p>
     在页面的.js文件中，通过onPullDownRefresh()函数即可监听当前页面的下拉刷新事件。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6d2c11143389f911eb7831fad19c748f.png"/>
     <br/>
     这里面一般做一些重置操作。
    </p>
    <h3>
     <a id="103__934">
     </a>
     10.3 停止下拉刷新
    </h3>
    <p>
     在完成任务后（如重置），调用wx.stopPullDowwnRefresh()可停止当前页面的下拉刷新。
    </p>
    <h3>
     <a id="104__936">
     </a>
     10.4 上拉触底以及监听
    </h3>
    <p>
     上拉触底，是通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。
    </p>
    <p>
     更多用来实现分页功能。
    </p>
    <p>
     这个其实是默认开启的。所以我们要做的是监听这个事件，可以调用：onReachBottom()函数来监听。
    </p>
    <p>
     在页面的js文件中有这个函数：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f85cf0d5989656d0d71af26cd407c9b9.png"/>
    </p>
    <h3>
     <a id="105__945">
     </a>
     10.5 配置上拉触底距离
    </h3>
    <p>
     上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。
    </p>
    <p>
     配置方法，在json文件中：onReachBottomDistanse，后面是数字不需要带单位。
    </p>
    <p>
     <mark>
      注意，以上的所有，都要开启enablePullD··ownRefresh属性才可以有效果。
     </mark>
    </p>
    <h3>
     <a id="106__951">
     </a>
     10.6 加载数据
    </h3>
    <p>
     做出这样的效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6fdb05c6c8cbb041da5adfde56e2d36a.png"/>
     <br/>
     可以在帮助中点开微信小程序开发文档看到很多东西。这个的话，可以在数据的请求函数中加上：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b94d5ce8b6e3ecb9e39da1b9888ebca4.png"/>
     <br/>
     当数据请求完成手动取消，与success平级：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/55939858850c363c5c1b83130e5d4816.png"/>
    </p>
    <h3>
     <a id="107__958">
     </a>
     10.7 节流
    </h3>
    <p>
     节流，简单介绍下，就是在执行一个事情的时候给一个冷却时间，防止一次性执行多次该任务。就类比塔方类游戏，英雄技能需要冷却后才可以使用，不能一次性使用多次。
    </p>
    <p>
     这里有一篇文章，介绍了防抖与节流：
     <br/>
     <a href="https://blog.csdn.net/zxdznyy/article/details/126219837">
      一文理解防抖与节流
     </a>
    </p>
    <p>
     在刷新的时候，经常要做的就是节流处理，如何进行节流处理呢？有以下三个步骤：
    </p>
    <pre><code>-&gt;在data中定义isloading节流阀:
false表示当前没有进行任何数据请求；
true表示当前正在进行的数据请求；

-&gt;在getColors()方法中修改loading节流阀：
在刚调用getColors时将节流阀设置为true；
在网路请求的complete回调函数中，将节流阀重置为false；

-&gt;在onReachBottom中判断节流阀的值，从而对数据请求进行节流控制：
如果节流阀为true，则阻止当前你请求；
如果节流阀为false，则发起数据请求。
</code></pre>
    <h2>
     <a id="_978">
     </a>
     十一，小程序的生命周期
    </h2>
    <h3>
     <a id="111__979">
     </a>
     11.1 生命周期概述
    </h3>
    <p>
     生命周期（Life Cycle）是指一个对象从
     <mark>
      创建-&gt;运行-&gt;销毁
     </mark>
     的整个阶段，
     <mark>
      强调的是一个时间段。
     </mark>
    </p>
    <p>
     小程序生命周期分为两类，分别是应用生命周期与页面生命周期：
    </p>
    <p>
     应用生命周期，特指小程序从启动-&gt;运行-&gt;销毁的过程；
    </p>
    <p>
     页面生命周期，特指小程序中，每个页面的加载-&gt;渲染-&gt;销毁的过程。
    </p>
    <h3>
     <a id="112__987">
     </a>
     11.2 生命周期函数
    </h3>
    <p>
     是由小程序框架提供的
     <mark>
      内置函数
     </mark>
     ，会伴随着生命周期，
     <mark>
      自动按次序运行
     </mark>
     。
    </p>
    <p>
     生命周期函数：允许程序员在特点的时间点，执行某些特定的操作。例如我们在前面用到的onLoad（页面刚加载时），并且在onLoad中运行一些函数，如发起网络请求。
    </p>
    <p>
     生命周期强调的是一个时间段，生命周期函数是某个特别的时间点发生的事情。
    </p>
    <p>
     生命周期函数也分为两类：
     <br/>
     应用类生命周期函数，特指小程序从启动-&gt;运行-&gt;销毁期间依次调用的那些函数
    </p>
    <p>
     页面生命周期，特指小程序中，每个页面从加载-&gt;渲染-&gt;销毁期间一次调用的那些函数。
    </p>
    <h3>
     <a id="113__998">
     </a>
     11.3 应用的生命周期函数
    </h3>
    <p>
     小程序的应用生命周期函数需要在app.js中声明。
    </p>
    <p>
     onLaunch：小程序初始化完成，执行此函数，全局只触发一次，可以做一些初始化的工作；
    </p>
    <p>
     onShow：小程序启动，或者从后台进入前台显示时触发；
    </p>
    <p>
     onHide：小程序从前台进入后台时触发。
    </p>
    <p>
     这里介绍下前台和后台：当我们在小程序页面时，小程序是在运行的，可以理解为前台；接着说说后台，我们直接退出微信，小程序还没有被关闭，是在后台运行的一个状态，可以理解为后台。
    </p>
    <p>
     且后台可以点击右上角的小点：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/caaf89dfeeaef43960d96040b62fd32d.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a1fd2270feffe21016cf4bc48b309549.png"/>
    </p>
    <h3>
     <a id="114__1012">
     </a>
     11.4 页面的声明周期函数
    </h3>
    <p>
     小程序的页面生命周期函数有五个，需要在页面的js文件中进行声明，有以下几个：
     <br/>
     onLoad：监听页面加载，一个页面只调用一次；（初始化数据，转存参数）
    </p>
    <p>
     onShow：监听页面显示；
    </p>
    <p>
     onReady：监听页面初次渲染完成，一个页面只调用一次；（修改相关样式）
     <br/>
     onHide：监听页面隐藏；
    </p>
    <p>
     onUnload：监听页面卸载，一个页面只调用一次。
    </p>
    <h2>
     <a id="WXS_1023">
     </a>
     十二，WXS脚本
    </h2>
    <h3>
     <a id="121_WXS_1024">
     </a>
     12.1 WXS概述
    </h3>
    <p>
     WXS（WeiXin Script）
     <mark>
      是小程序独有的一套脚本语言
     </mark>
     ，结合WXML，可以构建出页面结构。
    </p>
    <p>
     应用场景：wxml中无法调用在页面.js中定义的函数，但是wxml中可以调用wxs中定义的函数，因此，小程序中的wxs的典型应用场景就是
     <mark>
      过滤器。
     </mark>
    </p>
    <h3>
     <a id="122_wxsJavaScript_1029">
     </a>
     12.2 wxs和JavaScript的关系
    </h3>
    <p>
     语法类似javaScript，看看区别：
    </p>
    <ol>
     <li>
      <p>
       wxs有自己的数据类型：
       <br/>
       number数值类型、string字符串类型、boolean布尔类型、object对象类型、function函数类型、array数组类型、date日期类型、regexp正则；
      </p>
     </li>
     <li>
      <p>
       wxs不支持类似于ES6及以上的语法格式：
       <br/>
       不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc；
       <br/>
       支持：var定义变量、普通function函数等类似于Es5的语法。
      </p>
     </li>
     <li>
      <p>
       wxs遵循CommonJS规范：
       <br/>
       module对象、require函数、module.exports对象
      </p>
     </li>
    </ol>
    <h3>
     <a id="123_wxs_1042">
     </a>
     12.3 内嵌的wxs脚本
    </h3>
    <p>
     wxs代码可以编写在wxml文件中的wxs标签内，就像javascript代码可以编写在html文件中的script标签内一样。
    </p>
    <p>
     <mark>
      每个wxs标签，必须提供module属性，用来指定当前的wxs的模块名称，方便再wxml中访问模块中的成员。
     </mark>
    </p>
    <p>
     这里来举个例子：
     <br/>
     给某个界面加一条数据，姓名是张三，小写的zs：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6d56ed1fde0c38e7a3eabec97da12424.png"/>
     <br/>
     现在我们想要的是，让zs由小写变为大写呈现在页面上。我们可以在页面中（wxml）嵌入一段wxs：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f1cbe697852d44492efe2d0673091104.png"/>
    </p>
    <p>
     在上面这段嵌入中，module是必不可少的，是模块的名称，下面必须用module.exports来暴露模块，tdUpper是模块中的函数，被暴露后外部可以调用。
    </p>
    <p>
     既然已经定义好了，那我们现在来调用即可：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7d48682ba32a75070cdc2ff990671c28.png"/>
     <br/>
     最后可以看到效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2491ae9c41bbde1abd4a750b44522298.png"/>
    </p>
    <p>
     由上面这个例子可以看出wxs的过滤器效果。
    </p>
    <h3>
     <a id="124_wxs_1062">
     </a>
     12.4 定义外联的wxs脚本
    </h3>
    <p>
     wxs代码还可以编写在
     <mark>
      以.wxs为后缀名的文件内
     </mark>
     ，就像javascript代码可以编写在以.js为后缀名的文件夹中一样。
    </p>
    <p>
     先创建一个wxs为后缀的文件，刚刚写的是大写，现在我们来写小写相关的文件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b0d1acb2bf46084aa71b00af8fbafc06.png"/>
     <br/>
     以上就是一个wxs文件，上面写函数并且return出去，下面把函数暴露出去。
     <mark>
      注意，wxs中不想js一样支持对象简写，所以下面的暴露需要写完整的键值对写法。
     </mark>
    </p>
    <p>
     定义完后，可以使用这个脚本。在wxml中，要引入外联的wxs脚本，也要有一个wxs标签，且标签需要由module属性和src属性。
    </p>
    <p>
     module是用来指定模块的名称；
     <br/>
     src用来指定要引入的脚本的路径，且必须是相对路径。
    </p>
    <p>
     给当前页面新增一条数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b376be71c94b1966d9108646040443fe.png"/>
     <br/>
     接着我们在页面上引入外联的脚本：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fb3124de1859f6e93af30784f4f6036f.png"/>
     <br/>
     接着就可以使用啦：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/0786b0c02970fe64ebe0dcdb61058524.png"/>
     <br/>
     效果如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4508c7fa441ed98ae5e9b8cb34c3817b.png"/>
    </p>
    <h3>
     <a id="125__1083">
     </a>
     12.5 总结
    </h3>
    <p>
     1.wxs与js的关系
     <br/>
     为了降低wxs的学习成本，wxs语言在设计时借鉴了大量js的语法，但本质上，
     <mark>
      wxs与javascript是两种语言。
     </mark>
    </p>
    <p>
     2.wxs不能作为组件的事件回调
     <br/>
     wxs典型的应用场景是过滤器，配合Mustache（模板语法）使用，但是不能作为组件的回调函数！如button中的bindtap后面就不能用到这个。
    </p>
    <p>
     3.隔离性
     <br/>
     wxs运行环境和其他javascript代码是隔离的，体现在：
     <br/>
     wxs不能调用js中定义的函数；
     <br/>
     wxs不能调用小程序所提供的API；
    </p>
    <p>
     4.性能好
     <br/>
     在IOS设备上，小程序内的WXS会比javaScriipt代码快2-20倍但；
     <br/>
     但是在android设备上，二者的运行效率无差异。
    </p>
    <h2>
     <a id="_1099">
     </a>
     十三，自定义组件
    </h2>
    <h3>
     <a id="131__1100">
     </a>
     13.1 创建组件
    </h3>
    <p>
     第一步，在项目的根目录中，鼠标右键，创建components-&gt;test文件夹
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/be0b5802193133b68ca3ea4aaac858fd.png"/>
     <br/>
     第二步，在新建的components-&gt;test文件夹上，鼠标右键，点击“新建Component”
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/765d1ab8e8cb8cd654d5e0ac31937021.png"/>
     <br/>
     第三步，键入组件的名称后回车，会自动生成组件对应的4个文件，后缀名分别为js、json、wxml、和wxss：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2106f71f1a4e663ef7f09b755f84d731.png"/>
    </p>
    <h3>
     <a id="132__1107">
     </a>
     13.2 局部引入
    </h3>
    <p>
     引用组件有两种方式，分别是
     <mark>
      局部引用
     </mark>
     与
     <mark>
      全局引用
     </mark>
     。
    </p>
    <p>
     在页面的json文件中，引入组件，这是局部引用。
    </p>
    <p>
     局部引用的方式：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/de7e9a4d4af135296cc203cde39cb279.png"/>
     <br/>
     这其实就把刚刚写的组件给局部引入了。
    </p>
    <p>
     用的时候直接以标签的形式，打个比方我要在home的页面上使用刚刚引入的组件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/22ece2698e3a1df9e5b3db55a7fad4e7.png"/>
     <br/>
     <mark>
      如果仅仅是局部引用，则组件只能在引入过该组件的页面使用。
     </mark>
    </p>
    <p>
     小程序的组件其实与vue组件十分类似。
    </p>
    <h3>
     <a id="133__1121">
     </a>
     13.3 全局引入
    </h3>
    <p>
     在全局配置文件app.json中引入：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/80f31c23081e41c42bbcfa17b03d5300.png"/>
     <br/>
     一旦全局配置，所有的页面都可以使用该组件。
    </p>
    <h3>
     <a id="134__1125">
     </a>
     13.4 引用方式的选择
    </h3>
    <p>
     根据组件的
     <mark>
      使用频率
     </mark>
     和
     <mark>
      范围
     </mark>
     。
    </p>
    <p>
     如果某组件在多个页面中经常被用到，建议进行”全局引用“
     <br/>
     如果某组件只在特定的页面中被用到，建议进行”局部引用"
    </p>
    <h3>
     <a id="135__1131">
     </a>
     13.5 组件和页面的区别
    </h3>
    <p>
     组件和页面都是由js，json，wxml四个文件组成的，但是，组件和页面的js与json文件有明显不同：
    </p>
    <p>
     组件的json文件中需要声明：“component” : true 属性；
     <br/>
     组件的js文件中调用的是Component()函数；
     <br/>
     组件的事件处理函数需要定义到methods节点中。
    </p>
    <h3>
     <a id="136__1138">
     </a>
     13.6 组件样式隔离
    </h3>
    <p>
     默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的UI结构，样式其实是有隔离的特性的。
    </p>
    <p>
     好处：防止外界样式影响组件内部的样式；防止组件的样式破坏外界的样式。
    </p>
    <p>
     这里说一下组件样式隔离的注意点：
     <br/>
     <mark>
      vx的wxss中的全局样式对组件没有影响。
     </mark>
     <br/>
     <mark>
      只有class选择器会有样式隔离，id、标签等都没有隔离效果，容易造成样式冲突问题。
     </mark>
    </p>
    <p>
     如何修改样式隔离：
     <br/>
     可以在json中通过stylesolation配置：
    </p>
    <pre><code class="prism language-xml">"stylesolation": "isolated"//样式隔离
"stylesolation": "apply-shared"//页面wxss样式影响在自定义组件，但自定义组件wxss中指定的样式不会影响界面
"stylesolation": "shared"//组件和页面互相影响
</code></pre>
    <h3>
     <a id="137_data_1156">
     </a>
     13.7 data数据
    </h3>
    <p>
     在组件中定义一个data：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8d3e792bfe275a01953411dd60ed8936.png"/>
    </p>
    <h3>
     <a id="138_methods_1159">
     </a>
     13.8 methods方法
    </h3>
    <p>
     事件处理函数和自定义方法需要定义到methods节点中。
    </p>
    <p>
     可以先设置一个按钮并给按钮绑定一个事件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9f48e756adaa45af3f64ebfa2d51de1a.png"/>
     <br/>
     然后再写add的回调：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d027e42d49a689fbd7e8582b189bf2c6.png"/>
    </p>
    <h3>
     <a id="139_properties_1166">
     </a>
     13.9 properties属性
    </h3>
    <p>
     在小程序组件中，properties是组件的对外属性，
     <mark>
      用来接收外界传递到组件中的数据。
     </mark>
    </p>
    <p>
     组件在接收页面传递过来的参数时，需要先对参数进行配置：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7d0c183d6fae6e50a0b24e1b4444df2f.png"/>
     <br/>
     有了这层配置，就可从页面传参到组件中了：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/721a275fad475e4ef954f7585d51aedf.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d4c48ed8a2a7c0b995f02597dabcd0ba.png"/>
    </p>
    <h3>
     <a id="1310_dataproperties_1174">
     </a>
     13.10 data和properties的区别
    </h3>
    <p>
     在小程序中，data和properties都是可读可写的，但是data更偏向于
     <mark>
      存储组件的私有数据
     </mark>
     ，properties更倾向于
     <mark>
      存储外界传递到组件中的数据。
     </mark>
    </p>
    <h3>
     <a id="1311__1176">
     </a>
     13.11 数据监听器
    </h3>
    <p>
     数据监听器：用于监听和响应任何属性和数据字段的变化，从而执行特定的操作，类似于vue中的watch。
    </p>
    <p>
     监听器：与data平级：observers。
    </p>
    <p>
     这里来放一段代码，需求是通过监听器获取sum的值：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/41346582c8d3b301775c10ce367afb58.png"/>
     <br/>
     接着看啊可能一下组件js的写法：
    </p>
    <pre><code class="prism language-javascript">  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">n1</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token literal-property property">n2</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token literal-property property">sum</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">observers</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">'n1, n2'</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newn1<span class="token punctuation">,</span> newn2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">sum</span><span class="token operator">:</span> newn1 <span class="token operator">+</span> newn2
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">/**
   * 组件的方法列表
   */</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">addn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">n1</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>n1 <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">addn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">n2</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>n2 <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
    <p>
     另外说一下监听对象与监听全部：rgb对象
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b9428f2195a49a63b15379a7d172570d.png"/>
     <br/>
     监听：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/054bd7879efb1eda7ef1a25fe5ad7fc1.png"/>
     <br/>
     全部：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ce636e5c3ba12467fb96cee4312f574e.png"/>
    </p>
    <h3>
     <a id="1312__1219">
     </a>
     13.12 纯数据字段
    </h3>
    <p>
     概念：纯数据字段指的是那些
     <mark>
      不用于界面渲染的data字段。
     </mark>
    </p>
    <p>
     好处：纯数据字段有助于提升页面更新的性能。
    </p>
    <p>
     使用：在Component构造器的options节点中，指定pureDataPattern为一个正则表达式，字段名符合正则表达式则是纯数据字段。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a15a2d05d00c710f4b04bb63febbae55.png"/>
     <br/>
     上面这个例子，凡是下划线开头都是纯数据字段：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/197f68b8599791d1b59d33fd6eb0016f.png"/>
     <br/>
     m是纯数据字段。如果要监听可以在前面加下划线。
    </p>
    <h3>
     <a id="1313__1229">
     </a>
     13.13 自定义组件的生命周期
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        生命周期函数
       </th>
       <th>
        描述说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <mark>
         created
        </mark>
       </td>
       <td>
        <mark>
         在组件实例刚刚被创建时执行
        </mark>
       </td>
      </tr>
      <tr>
       <td>
        <mark>
         attached
        </mark>
       </td>
       <td>
        <mark>
         在组件实例进入页面节点树时执行
        </mark>
       </td>
      </tr>
      <tr>
       <td>
        ready
       </td>
       <td>
        在组件在视图层布局完成后执行
       </td>
      </tr>
      <tr>
       <td>
        moved
       </td>
       <td>
        在组件实例被移动到节点树另一个位置时执行
       </td>
      </tr>
      <tr>
       <td>
        <mark>
         detached
        </mark>
       </td>
       <td>
        <mark>
         在组件实例被从页面节点树移除时执行
        </mark>
       </td>
      </tr>
      <tr>
       <td>
        error
       </td>
       <td>
        当组件方法抛出错误时执行
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     常用生命周期函数：
    </p>
    <pre><code>created
组件实例刚被创建好的时候，created生命周期函数会被触发；
此时还不能调用setData；
通常在这个生命周期函数中，只应该用于给组件的this添加一些自定义的属性字段


attached
在组件完全初始化完毕，进入页面节点树后，attached生命周期函数会被触发
此时，this.data已被初始化完毕
这个生命周期很欧用，绝大多数初始化的工作可以在这个时机执行（例如发起请求初始数据）

detached
当组件离开页面节点树后，detachedsmzq函数会被触发
退出一个页面时，会触发页面内每个自定义组件的detached生命周期函数
此时适合做一些清理性质的工作
</code></pre>
    <p>
     小程序的生命周期函数可以写在Component函数中，也可也再lifetimes字段内进行声明。
     <mark>
      这是推荐方式，优先级最高
     </mark>
     。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fb5d455ff6171b4afb6a4a112cb06968.png"/>
    </p>
    <h3>
     <a id="1314__1260">
     </a>
     13.14 组件所在页面的生命周期
    </h3>
    <p>
     自定义组件的行为依赖于页面状态的变化，此时就是需要用到组件所在页面的生命周期。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        生命周期函数
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        show
       </td>
       <td>
        组件所在的页面被展示时执行
       </td>
      </tr>
      <tr>
       <td>
        hide
       </td>
       <td>
        组件所在页面被隐藏时执行
       </td>
      </tr>
      <tr>
       <td>
        resize
       </td>
       <td>
        组件所在页面尺寸变化时执行
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     用法：
     <br/>
     需要定义在pageLifetimes节点中，接着可以调用以上三个生命周期函数。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2966f7568b2fb6bc0587db8a2a3ccc86.png"/>
    </p>
    <h2>
     <a id="_1272">
     </a>
     十四，插槽
    </h2>
    <h3>
     <a id="141__1273">
     </a>
     14.1 什么是插槽
    </h3>
    <p>
     自定义组件wxml中，可以提供一个slot节点，用于承载组件使用者提供的wxml结构。
    </p>
    <p>
     用白话讲一下，就是在组件中放一个坑，在使用组件的页面中去填这个坑。
    </p>
    <h3>
     <a id="142__1277">
     </a>
     14.2 单个插槽
    </h3>
    <p>
     单个插槽：小程序中，默认每个自定义组件中只允许使用一个slot进行占位，这种个数上的限制叫做单个插槽。
    </p>
    <p>
     举个例子，先在组件中设置一个坑：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3077d5d7f8c21539737ec58915176f1f.png"/>
     <br/>
     接着在页面中填上这个坑：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f931a6d6a01b4707eca86a7beef7791b.png"/>
     <br/>
     最后就可以展示了：
     <br/>
     <img alt="l" src="https://i-blog.csdnimg.cn/blog_migrate/4096aa5b0747b66da6e6fc34527289e3.png"/>
    </p>
    <h3>
     <a id="143__1287">
     </a>
     14.3 多个插槽
    </h3>
    <p>
     在options中，配置multipleSlots为true，则可以启用多个插槽。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/94e35dcd08e3376316829b41b8e38790.png"/>
    </p>
    <p>
     插槽多的时候可用具名插槽。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d03db4b1ebef3b24f2fd9f4e71b292d8.png"/>
     <br/>
     在页面中：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d9f0601af6e546252e450350add5a166.png"/>
     <br/>
     效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f4713b86916a573ce214724091043349.png"/>
    </p>
    <h2>
     <a id="_1298">
     </a>
     十五，组件通信
    </h2>
    <h3>
     <a id="151__1299">
     </a>
     15.1 父子通信概述
    </h3>
    <p>
     三种方式：
    </p>
    <pre><code>属性绑定：
用于父组件向子组件的指定属性设置数据，仅能设置JSON兼容的数据

事件绑定：
用于子组件向父组件传递数据，可以传递任意数据

获取组件实例：
父组件还可以通过this.selectComponent()获取子组件实例对象
这样就可以直接访问子组件任意数据和方法
</code></pre>
    <h3>
     <a id="152__1312">
     </a>
     15.2 父-&gt;子之属性绑定
    </h3>
    <p>
     属性绑定用于实现
     <mark>
      父向子传值
     </mark>
     ，而且只能传递普通类型的数据，无法将方法传给子组件。
     <br/>
     在父组件中设置要传给子组件的数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/55304a806bda998c1863527da0f3300f.png"/>
     <br/>
     在子组件的标签中传值：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6dab92bd745ae078ed03dc722d1ba101.png"/>
     <br/>
     子组件使用properties节点声明对应属性并使用：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4ffea88b4aae6fc62d72a76681052257.png"/>
    </p>
    <p>
     接着就可以在子组件中使用count了：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/051eccbf2be8471726aea4ba22cf2bde.png"/>
    </p>
    <h3>
     <a id="153__1323">
     </a>
     15.3 子-&gt;父之事件绑定
    </h3>
    <p>
     事件绑定
     <br/>
     顾名思义就是通过绑定事件来实现。
    </p>
    <p>
     在父组件的js中，定义一个函数。这个函数将通过自定义事件的形式，传给子组件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/10776e936e846757a023d1bbe2dbae4d.png"/>
    </p>
    <p>
     在父组件的wxml中，通过自定义事件的形式，将步骤1中定义的函数引用，传递给子组件（在这一步中要看清楚自定义事件是怎么定义的，前面是bind也就是绑定的意思，sync是自定义事件的名称）：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2ea44f0553e667eeb16d0a21d6ccb1e1.png"/>
    </p>
    <p>
     在子组件的js中，通过调用this.triggerEvent('自定义事件名称‘，{/
     <em>
      参数对象
     </em>
     /}，触发自定义事件（第二个事件是需要穿的参数）：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ed0159740b96a4f633c6087dad4f7d53.png"/>
    </p>
    <p>
     在父组件的js中，通过e.detail获取到子组件传递过来的数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/adcaaa382d4cf0446a156e7dc8a527bd.png"/>
    </p>
    <p>
     最后count是可以自增的：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4da7b46e16243742acf7dfb7a1f4abfc.png"/>
    </p>
    <p>
     下面我来给大家讲下逻辑。
    </p>
    <p>
     我们在父向子传值的时候，父组件把count通过properties声明将值传给了子组件。在父组件中引用子组件可以得到count。
    </p>
    <p>
     接着我们的目的是，在子组件中让count自增并把结果传给父组件。
    </p>
    <p>
     在js中可以设置自定义事件，当自定义事件被触发时，可以传递参数，并且自定义事件触发后会有一个回调函数，回调函数会用到之前传递的参数。
    </p>
    <p>
     结合以上我们分析，在父组件中设置一个自定义事件（注意，是给子组件设置了一个自定义的事件，给谁设置就找谁触发），所以在子组件中触发了该自定义事件，在触发的同时，传递一个参数（回调函数中会用到的参数）；当自定义事件被触发后，父组件中会有一个回调函数（意思是自定义事件已经被触发），在这个回调函数中可以接收到子组件传来的参数。于是收到了子组件传来的值，从而实现子向父传值的过程。
    </p>
    <h3>
     <a id="154__1355">
     </a>
     15.4 获取组件实例
    </h3>
    <p>
     可在父组件里调用this.selectComponent("id或class选择器”)，获取子组件的实例对象，从而直接访问子组件任意数据和方法，调用时候需要传入一个选择器。
    </p>
    <p>
     在父组件中，给子组件添加一个类名，并且设置一个按钮，添加一个绑定事件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/495f898907856671d2d0d1f3a05b7d74.png"/>
     <br/>
     接着编辑事件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b62f0005d317e42f3ba453a0e617d626.png"/>
     <br/>
     效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bf12fbd1047c573fc3967c5b5a78c33b.png"/>
     <br/>
     接着就可以对子组件里的数据进行操作了：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/947e86dfe6eefe199fb7f5343b3135c8.png"/>
     <br/>
     <mark>
      注意这里如果对数据进行赋值的话，没办法用this，因为this代表的是当前页面或组件中的数据，这里要用接收到的child。
     </mark>
    </p>
    <p>
     效果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/228b12321c0a40938c786fe73e285076.png"/>
     <br/>
     同样，也可也调用子组件的方法。（在原型上）
    </p>
    <h3>
     <a id="155_behaviors_1372">
     </a>
     15.5. behaviors
    </h3>
    <p>
     behaviors是小程序中，用于实现组件间代码共享的特性。这个可以类别vue3中的hook。
    </p>
    <p>
     如果想要复习可以看下这篇博客:
     <br/>
     <a href="https://blog.csdn.net/zxdznyy/article/details/129326624">
      Vue3中hook的使用及使用中遇到的坑
     </a>
    </p>
    <p>
     工作方式：
     <br/>
     每个behavior可以包含一组
     <mark>
      属性、数据、生命周期函数
     </mark>
     和
     <mark>
      方法
     </mark>
     。组件引用它时，它的属性、数据和方法
     <mark>
      会被合并到组件中。
     </mark>
    </p>
    <p>
     每个组件中，可以引用多个behavior，behavior也可也引用其他behavior。
    </p>
    <p>
     首先，在项目根目录下创建一个存放behavior的文件夹
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d8b3a6d42e841fb17f2f6b5f0c5ca687.png"/>
     <br/>
     在文件夹里创建第一个behavior：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/be802771dd5547662309450772a2a935.png"/>
    </p>
    <p>
     在这个文件里，创建一个Behavior构造函数的实例对象，内部可以有
     <mark>
      属性、数据、生命周期函数
     </mark>
     和
     <mark>
      方法
     </mark>
     ：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/973801413d7abecf9a5cfd5d188b39cf.png"/>
     <br/>
     把这个模块暴露出去：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/362f9daefa726f491fb63308c569544d.png"/>
     <br/>
     现在就可以导入和使用啦，使用require导入：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6ad5f65661bc9366f4755f1ea2da4b97.png"/>
    </p>
    <p>
     后面直接用即可：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0cfea8f523f86a81cf270d343c238259.png"/>
    </p>
    <h2>
     <a id="npm_1397">
     </a>
     十六，使用npm包
    </h2>
    <h3>
     <a id="161_npm_1398">
     </a>
     16.1 使用npm包的限制
    </h3>
    <p>
     小程序中已经支持使用npm第三方的包，从而提高小程序的开发效率，但是，在小程序中使用npm包有以下三个限制：
    </p>
    <p>
     不支持依赖于Nodejs内置库的包；
     <br/>
     不支持依赖于浏览器内置对象的包；
     <br/>
     不支持依赖于C++插件的包
    </p>
    <p>
     横批：为数不多。
    </p>
    <h3>
     <a id="162_Vant_Weapp_1407">
     </a>
     16.2 Vant Weapp
    </h3>
    <p>
     是有赞的前端团队开源的一套
     <mark>
      小程序UI组件库
     </mark>
     ，主力开发者快速搭建小程序应用，所使用的是MIT开源许可证协议，对商业使用比较友好。
    </p>
    <p>
     类似于element-ui。
    </p>
    <p>
     官方文档：
     <a href="https://youzan.github.io/vant-weapp" rel="nofollow">
      官方文档链接
     </a>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4659ef06e305c666f055c818fc4ef12c.png"/>
    </p>
    <h3>
     <a id="163_vant_1416">
     </a>
     16.3 安装vant组件库
    </h3>
    <p>
     在小程序项目中，安装Vant组件库主要分为如下3步：
    </p>
    <p>
     通过npm安装（建议指定版本为@1.3.3）
     <br/>
     构建npm包
     <br/>
     修改app.json
    </p>
    <p>
     第一步：
     <br/>
     我们要在终端中来使用npm命令语句，小程序的终端，在开发者工具空白处鼠标点击右键，有一个在外部终端窗口中打开：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7f65f1f1fc93ea084f5fb450c51b232e.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6309a6444a3ce2a9eeab6fc21620a90f.png"/>
     <br/>
     先初始化：
    </p>
    <pre><code>npm init -y
</code></pre>
    <p>
     <mark>
      注意，这个地方如果报错，极大可能是因为组件名称是中文。组件名称一定要是英文才可以正常使用。
     </mark>
    </p>
    <p>
     在初始化之后，这个文件有了包管理工具：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e3967e5364b762096067d8642cfb2742.png"/>
     <br/>
     第二步：安装vant组件库
    </p>
    <pre><code>npm i @vant/weapp -S --production
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/17a04836f202cce5788fae3109c72b8b.png"/>
    </p>
    <p>
     第三步：构建npm包
    </p>
    <p>
     打开微信中的开发者工具-&gt;本地设置-&gt;点击构建npm并勾选
     <mark>
      使用npm模块
     </mark>
     ，之后便可以引入组件：
    </p>
    <p>
     但是在新版本的微信开发者工具中，本地设置中找不到构建npm包了，可在工具中找：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/052519bde1b2d9cef11ee422878d7bae.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8237b02d021a73a26ef3550ec1a8d249.png"/>
    </p>
    <p>
     第四步：
    </p>
    <p>
     修改app.json：将app.json中的"style" : "v2"去除，小程序的
     <mark>
      新版基础组件
     </mark>
     强行加上了许多样式，难以去除，不关闭会造成部分样式的混乱：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/80f7d62f1aa1b54ccf5ff56ed747b63d.png"/>
     <br/>
     安装完毕。
    </p>
    <h3>
     <a id="164_Vant_1457">
     </a>
     16.4 使用Vant组件
    </h3>
    <p>
     安装完Vant组件后，可以在app.json的
     <mark>
      usingComponents
     </mark>
     节点中引入需要的组件，即可在wxml中直接使用组件。
    </p>
    <p>
     比如我们想使用vant提供的button组件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bf6f20e749722576be1064a09e75e38e.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8ad271c9e69922509c290e15251df8c5.png"/>
     <br/>
     可以在wxml中正常使用啦：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/eaad49e82de974cab285953d3a6c7563.png"/>
     <br/>
     可以正常使用：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/65e9e60637f3ff4e29300e85aebd2a06.png"/>
     <br/>
     这里如果报错，有两种主要问题：
     <br/>
     问题一： 路径不对，可以在新增的@vant文件夹里找到要引入的组件，右键复制相对路径，再更改路径格式；
    </p>
    <p>
     问题二：报错，找不到相关位置，这种情况一般是因为没构建npm包的原因。如果找不到可以在工具栏中找，这一步是不可以忽略的。
    </p>
    <h3>
     <a id="165__1471">
     </a>
     16.5 定制全局主题样式
    </h3>
    <p>
     Vant Weapp使用
     <mark>
      CSS变量
     </mark>
     来实现定制主题，可以参考官方文档的主题定制，点击链接查看：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6993dd5f6f6e546e23778411714c1230.png"/>
     <br/>
     具体可以参考官方文档。
    </p>
    <p>
     这里以一个例子来说明：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c61ef5383df1dff4c21d040e7f523645.png"/>
    </p>
    <p>
     上面这个按钮，红色是不是很深，不是很好看。那么这个时候，我们可以定制主题，来修改这个红色。
    </p>
    <p>
     在
     <mark>
      app.wxss
     </mark>
     中，写入CSS变量，即可对全局生效：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/75ee4fea29a1e4e3a9ea822809c70fe2.png"/>
     <br/>
     几个疑问：
    </p>
    <pre><code>1.为什么使用page节点？
--作用域问题，根节点是page节点。

2.怎么知道变量名？
--官方文档，定制主题，样式变量里面有个配置文件，点开即可。
</code></pre>
    <p>
     对于第二点：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4f852c4b377230b9b4a9f1700a214858.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/92e83cf4388c0131262cb7268bc3b520.png"/>
    </p>
    <h2>
     <a id="_API_Promise_1494">
     </a>
     十七 API Promise化
    </h2>
    <h3>
     <a id="171_Promise_1495">
     </a>
     17.1 Promise概述
    </h3>
    <p>
     这里有一篇我之前写的Promise文章，里面详细介绍了Promise的用法及其好处：
    </p>
    <p>
     <a href="https://blog.csdn.net/zxdznyy/article/details/129939306">
      前后端交互系列之promise详解
     </a>
    </p>
    <p>
     这里不再赘述。
    </p>
    <p>
     介绍下API Promise化，指的是
     <mark>
      通过额外的配置
     </mark>
     ，将官方提供的，基于回调函数的异步API，升级改造为基于Promise的异步API，从而提高代码的可读性、维护性、避免回调地狱的问题。
    </p>
    <h3>
     <a id="172_API_Promise_1504">
     </a>
     17.2 实现API Promise化
    </h3>
    <p>
     需要依赖于
     <mark>
      miniprogram-api-promise
     </mark>
     这个第三方包。
    </p>
    <pre><code>npm i --save miniprogram-api-promise@1.0.4
</code></pre>
    <p>
     <mark>
      小程序中，每安装一个包，都要进行npm构建。因为小程序无法去读node_modules这个包
     </mark>
    </p>
    <p>
     在构建时，要删除这个文件：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e6e139bcefef901366230074fdddbff8.png"/>
     <br/>
     删除后记得保存，保存完毕后，重启，从新编译，基本没有问题。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f4bd70a2f9780c90daad674fc5d664fe.png"/>
    </p>
    <h3>
     <a id="173_API_Promise_1517">
     </a>
     17.3 实现API Promise化
    </h3>
    <p>
     在小程序中，实现API Promise化主要依赖于miniprogram-api-promise这个第三方的npm包，它的安装和使用步骤如下：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b36f6c9f174d48af18b85f1b8f4bee4d.png"/>
     <br/>
     接着就可以使用request，并且夹杂async和await来发起网络请求。
    </p>
    <p>
     返回值就是一个promise对象。
    </p>
    <h2>
     <a id="_1524">
     </a>
     十八，全局数据共享
    </h2>
    <h3>
     <a id="181__1525">
     </a>
     18.1 数据共享概述
    </h3>
    <p>
     全局数据共享又叫做状态管理，是为了解决组件之间的数据共享问题。
    </p>
    <p>
     开啊中常用的数据共享方案有Vuex、Redux、MobX。
    </p>
    <p>
     在小程序中，可以使用mobx-minprogram来配合moby-miniprogram-bingdings实现全局数据共享，其中：
    </p>
    <p>
     mobx-miniprogram用来
     <mark>
      创建Stroe实例对象
     </mark>
     ；
    </p>
    <p>
     mobx-minprogram-bindings用来把Store中的共享数据或方法，绑定到组件或者页面中去使用。
    </p>
    <h3>
     <a id="182_MobX_1535">
     </a>
     18.2 安装MobX相关的包
    </h3>
    <p>
     运行如下命令:
    </p>
    <pre><code>npm i --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1
</code></pre>
    <p>
     注意：MobX相关包安装完成之后，记得删除miniprogram_npm目录后，重新 构建npm。
    </p>
    <p>
     上面这段npm命令最好带版本号。没有版本号可能会报错。
    </p>
    <h3>
     <a id="183_Store_1545">
     </a>
     18.3 创建Store实例
    </h3>
    <p>
     首先，在项目文件夹中创建store：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/95ba8f520e8088ff09d65dccc04b4a72.png"/>
     <br/>
     在store.js中引入相关的包，并且创建构造函数：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a9c1b8dd0223fce69c3711028810b6c7.png"/>
     <br/>
     在这个构造函数里面，可以把共享的数据挂载进去。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a71ac07f89c74df93eefc932dadc2ab5.png"/>
    </p>
    <h3>
     <a id="184_actionstore_1553">
     </a>
     18.4 action方法修改store中的数据
    </h3>
    <p>
     需要现引入action：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/94c5f0ed2ceaa51dce91e7fde021d8a4.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3056467d1a064985124da9a0b505e3f8.png"/>
    </p>
    <h2>
     <a id="_1559">
     </a>
     十九，小程序的分包
    </h2>
    <h3>
     <a id="191__1560">
     </a>
     19.1 分包的介绍
    </h3>
    <p>
     分包是把
     <mark>
      一个完整的小程序项目
     </mark>
     ，按照需求
     <mark>
      划分为不同的子包
     </mark>
     ，在构建时打包成不同的分包，用户在使用时
     <mark>
      按需加载
     </mark>
     。
    </p>
    <p>
     分包的好处：
     <br/>
     可以
     <mark>
      优化小程序首次启动的下载时间
     </mark>
     ；
     <br/>
     在
     <mark>
      多团队共同开发的时候可以更好的解耦协作。
     </mark>
    </p>
    <p>
     分包前后项目构成：
    </p>
    <pre><code>分包前
所有页面（tabBar页面，其他页面）+
公共资源（图片、js脚本、wxs脚本、wxss样式）

分包后
1个主包（启动页面或tabBar页面，以及分包需要用到的公共资源）+
分包（只包含和当期分包有关的页面和私有资源)
</code></pre>
    <p>
     结构图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f7cbb8b5903db3b33b74f94b13b54cd6.png"/>
    </p>
    <h3>
     <a id="192__1580">
     </a>
     19.2 分包的加载规则
    </h3>
    <p>
     在小程序启动时，默认会
     <mark>
      下载主包
     </mark>
     并
     <mark>
      启动主包内页面
     </mark>
     。
     <br/>
     （tabBar页面一定要加载到主包里面）
    </p>
    <p>
     当客户进入分包的某个页面时，
     <mark>
      客户端会把对应分包下载下来
     </mark>
     ，下载完成后再进行展示。
     <br/>
     （非tabBar页面可以按照功能的不同，分为不同的分包，这就叫做
     <mark>
      按需下载
     </mark>
     ）
    </p>
    <h3>
     <a id="193__1587">
     </a>
     19.3 分包体积限制
    </h3>
    <p>
     有两个限制：
    </p>
    <p>
     主包+分包体积不超过16M；
    </p>
    <p>
     单个分包/主包大小不能超过2M。
    </p>
    <p>
     否则会发布失败。
    </p>
    <h3>
     <a id="194__1596">
     </a>
     19.4 分包
    </h3>
    <p>
     以我的为例，这是我的小程序的项目结构，其中，call，home，messages是tabBar页面，要放在主包，info是非tabBar页面，而且不占用公共资源，所以是分包：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a3d3fa5e8757418ec4e17f158f8f3cd4.png"/>
    </p>
    <p>
     现在我在
     <mark>
      app.json
     </mark>
     中进行分包的配置。
    </p>
    <p>
     先配置主包的所有页面：复习一下，主包页面包括tabBar页面以及分包用到的公共资源，这是第一层配置：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/24457baa88c7fe528c0222c6231cf244.png"/>
     <br/>
     接着是分包的配置，主包配置的节点是page，分包配置的节点是
     <mark>
      subpackages
     </mark>
     ：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0f706e4176a61e3cba9ee2790262a04e.png"/>
    </p>
    <p>
     其中，root节点是分包的根目录；name是分包的别名；pages里面存放的是根目录下所有页面的相对存放路径。
    </p>
    <h3>
     <a id="195__1609">
     </a>
     19.5 打包规则
    </h3>
    <p>
     小程序会按照subpackages的配置进行分包，subpackages之外的目录将被打包到主包中；
    </p>
    <p>
     主包也可也有自己的pages（最外层的pages字段）；
    </p>
    <p>
     tabBar页面必须在主包内；
    </p>
    <p>
     分包之间不能相互嵌套。
    </p>
    <h3>
     <a id="196__1618">
     </a>
     19.6 引用原则
    </h3>
    <p>
     主包无法引用分包内的私有资源；
    </p>
    <p>
     分包之间不能相互引用私有资源；
    </p>
    <p>
     分包可以引用主包内的公共资源。
    </p>
    <h3>
     <a id="197__1625">
     </a>
     19.7 独立分包
    </h3>
    <p>
     独立分包的本质是
     <mark>
      分包
     </mark>
     ，只不过比较特殊的是，独立分包可以独立于主包和其他分包而单独运行。
    </p>
    <p>
     示意图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4cb9cd5bbf13776654a308ce92ddcf66.png"/>
     <br/>
     独立分包和主包的区别：
     <mark>
      是否依赖于主包才能运行
     </mark>
     ：
     <br/>
     普通分包必须依赖于主包才能运行；
     <br/>
     独立分包可以在不下载主包的情况下，独立运行。
    </p>
    <p>
     独立分包的应用场景：
     <br/>
     开发者可以按需，将某些
     <mark>
      具有一定功能独立性的页面
     </mark>
     配置到独立分包中，原因如下：
     <br/>
     小程序从普通的分包页面启动时，需要首先下载主包；
     <br/>
     而独立分包
     <mark>
      不依赖主包
     </mark>
     即可运行，可以很大程度上提升分包页面的启动速度。
    </p>
    <p>
     配置：
     <br/>
     在众多节点下加一个平级的
    </p>
    <pre><code>"independent": true
</code></pre>
    <p>
     引用原则
     <br/>
     独立分包和普通分包以及主包之间，是相互隔绝的，
     <mark>
      不能相互引用彼此的资源
     </mark>
     ：
     <br/>
     主包无法引用独立分包内的私有资源；
     <br/>
     独立分包之间，不能相互引用私有资源；
     <br/>
     独立分包和普通分包之间，不能相互引用私有资源；
     <br/>
     <mark>
      特别注意：独立分包不能引用主包内的公共资源。
     </mark>
    </p>
    <h3>
     <a id="198__1653">
     </a>
     19.8 分包预下载
    </h3>
    <p>
     分包预下载指的是在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面时的启动速度。
    </p>
    <p>
     如何配置：
     <br/>
     预下载分包的行为，
     <mark>
      会在进入指定的页面时触发。
      <mark>
       配置时，在app.json中使用
      </mark>
      preloadRule
     </mark>
     节点定义分包的预下载规则：
    </p>
    <p>
     preloadRule与其他对象属性平级，内部是一个键值对：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/473f225fb8c6f0f7ff9844ace1e37db5.png"/>
    </p>
    <p>
     内部配置：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/de9a92346eee133e8679bdf97a0b0997.png"/>
     <br/>
     其中，第一个地址指的是，进入该页面后进行分包预下载；
     <br/>
     packages是必填选项，意思是下载哪个包；
     <br/>
     network不是必选，all的意思是不论什么网络都可以分包预下载，如果改成wifi那就是只有网络面膜是是wifi才可以分包预下载。
    </p>
    <p>
     分包预下载限制：
     <br/>
     同一个分包中的页面享有
     <mark>
      共同的预下载大小限额2M
     </mark>
     。
     <br/>
     如：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0ed3d2118e4f4629dd7c4ca898da9b37.png"/>
    </p>
    <h2>
     <a id="_1672">
     </a>
     后记
    </h2>
    <p>
     到此为止，小程序基础相关的知识已经呈现，我来谈一下我的学习感受。
    </p>
    <p>
     小程序在我看来，和Vue很相似，并且很多地方也与之前接触到的前端知识吻合。经常听到有人说，小程序很简单很容易上手，真正一套学下来，发现还是很有难度的。
    </p>
    <p>
     让我觉得学习比较困难的地方是数据共享和分包这一块。在学Vue的时候就觉得数据共享非常繁琐，在小程序中虽然原理上与Vue类似，但是配置发生了改变，所以只是走马观花似的学习；在学习分包这一块，我感到困难并不是因为本身配置有多难，而是没有接触过，所以不理解为什么要这么做。
    </p>
    <p>
     还是一句话，单凭理论知识的学习，掌握的仅仅只是冰山一角，想要掌握，还需动手做项目，真正的实战实操。
    </p>
    <p>
     而我之所以写这篇文章的意义，是想记录学习的过程，文章本身比文档更有逻辑性，许久没看，再回顾的时候可以拾起思路，很认真的写下这篇文章，虽然很多都是从老师的课程中拿来的，但是也有很多地方夹杂了我自己的理解，链接了我往期的知识点。所以如果觉得有用，也可也关注收藏一下。而本篇文章的篇幅很长，可能会出现问题，希望大家评论区批评指正。另外有什么这方面的想法或者疑问，也可以评论区或者私信交流。
    </p>
    <p>
     最后要说，学习是永无止境的，互联网行业的学习，更是不能断的。在这里和大家共勉，希望都能找到好的工作，以及把工作更好的发展延续下去。
    </p>
    <p>
     后续我还会出一些小程序的其他内容，以及前端甚至架构方面的内容，也可也关注我，我会努力带给您更好的文章！！！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f7a78647a6e79792f:61727469636c652f64657461696c732f313330333334363436" class_="artid" style="display:none">
 </p>
</div>


