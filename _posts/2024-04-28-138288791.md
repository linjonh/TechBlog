---
layout: post
title: "TCP通信分包和组包过程详解"
date: 2024-04-28 19:32:02 +0800
description: "TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、"
keywords: "TCP通信分包和组包过程详解"
categories: ['通信协议']
tags: ['网络协议']
artid: "138288791"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138288791
    alt: "TCP通信分包和组包过程详解"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     TCP通信分包和组包过程详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层协议。在TCP通信中，数据的传输需要进行分包和组包操作，以确保数据的完整性和可靠性。本文将详细介绍TCP通信中的分包和组包过程，结合C语言代码进行说明，并探讨其原因、解决办法以及应用场景。
    </p>
    <h5>
     <a id="TCP_4">
     </a>
     TCP通信分包过程
    </h5>
    <p>
     TCP通信分包指的是将应用层数据拆分成多个小的TCP报文段进行传输的过程。TCP协议并不保证应用层数据在传输过程中的边界，因此接收端需要根据TCP报文段的头部信息来正确地重组应用层数据。分包的主要原因包括：
    </p>
    <ol>
     <li>
      <strong>
       MTU限制：
      </strong>
      网络中的链路通常有最大传输单元（MTU）限制，超过MTU的数据需要进行分片，导致TCP分包。
     </li>
     <li>
      <strong>
       拥塞控制：
      </strong>
      TCP会根据网络状况进行流量控制和拥塞控制，可能导致数据分包和合并。
     </li>
     <li>
      <strong>
       窗口大小：
      </strong>
      TCP通信中的窗口大小动态变化，可能会导致数据的分包和合并。
     </li>
    </ol>
    <p>
     下面是一个简单的C语言示例，模拟TCP通信中的分包过程：
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PACKET_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">void</span> <span class="token function">send_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> sent_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>sent_bytes <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> remaining_bytes <span class="token operator">=</span> length <span class="token operator">-</span> sent_bytes<span class="token punctuation">;</span>
        <span class="token keyword">int</span> packet_size <span class="token operator">=</span> remaining_bytes <span class="token operator">&gt;</span> MAX_PACKET_SIZE <span class="token operator">?</span> MAX_PACKET_SIZE <span class="token operator">:</span> remaining_bytes<span class="token punctuation">;</span>
        <span class="token comment">// 发送数据包</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sending packet: %.*s\n"</span><span class="token punctuation">,</span> packet_size<span class="token punctuation">,</span> data <span class="token operator">+</span> sent_bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sent_bytes <span class="token operator">+=</span> packet_size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is a sample TCP data."</span><span class="token punctuation">;</span>
    <span class="token function">send_data</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="TCP_38">
     </a>
     TCP通信组包过程
    </h5>
    <p>
     TCP通信组包是指接收端根据接收到的TCP报文段将数据进行重组的过程。接收端需要根据TCP头部信息中的序列号和数据长度来正确地组装应用层数据。组包的主要原因包括：
    </p>
    <ol>
     <li>
      <strong>
       TCP头部信息：
      </strong>
      TCP报文段的头部包含了序列号和数据长度等信息，接收端可以根据这些信息来确定数据的边界，进行组包操作。
     </li>
     <li>
      <strong>
       接收窗口：
      </strong>
      TCP通信中的接收窗口大小会动态调整，接收端根据窗口大小来接收数据，可能会导致数据的分包和合并。
     </li>
    </ol>
    <p>
     以下是一个简单的C语言示例，模拟TCP通信中的组包过程：
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PACKET_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">void</span> <span class="token function">receive_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> packet<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>MAX_PACKET_SIZE <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> buffer_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 将接收到的数据存入缓冲区</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer <span class="token operator">+</span> buffer_offset<span class="token punctuation">,</span> packet<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    buffer_offset <span class="token operator">+=</span> length<span class="token punctuation">;</span>

    <span class="token comment">// 判断是否可以组包</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer_offset <span class="token operator">&gt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> data_length<span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_length<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer_offset <span class="token operator">&gt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">+</span> data_length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 组包完成，处理数据</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Received packet: %.*s\n"</span><span class="token punctuation">,</span> data_length<span class="token punctuation">,</span> buffer <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 从缓冲区移除已处理数据</span>
            <span class="token function">memmove</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">+</span> data_length<span class="token punctuation">,</span> buffer_offset <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> data_length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            buffer_offset <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">+</span> data_length<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 数据不完整，等待下一个包</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> packet1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"\x00\x00\x00\x14This is "</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> packet2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"a sample TCP data."</span><span class="token punctuation">;</span>
    <span class="token function">receive_data</span><span class="token punctuation">(</span>packet1<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>packet1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">receive_data</span><span class="token punctuation">(</span>packet2<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>packet2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_87">
     </a>
     解决办法
    </h5>
    <p>
     针对TCP通信中的分包和组包问题，可以采取以下解决办法：
    </p>
    <ol>
     <li>
      <strong>
       消息边界标记：
      </strong>
      在应用层协议中增加消息边界标记，如XML、JSON中的结束标记，以便接收端能够正确地识别消息边界。
     </li>
     <li>
      <strong>
       固定长度消息：
      </strong>
      在应用层协议中规定固定长度的消息，接收端根据消息长度来进行分包和组包。
     </li>
     <li>
      <strong>
       消息长度字段：
      </strong>
      在应用层协议中增加消息长度字段，发送端在发送消息时附带消息长度，接收端根据消息长度来进行分包和组包。
     </li>
    </ol>
    <h5>
     <a id="_95">
     </a>
     应用场景
    </h5>
    <p>
     TCP通信分包和组包的技术在网络编程中广泛应用，特别适用于以下场景：
    </p>
    <ul>
     <li>
      <strong>
       实时音视频传输：
      </strong>
      在实时音视频传输中，数据量大且需要实时性，分包和组包技术能够有效地保证数据的传输效率和实时性。
     </li>
     <li>
      <strong>
       大文件传输：
      </strong>
      在大文件传输过程中，可能会出现MTU限制和网络拥塞等问题，分包和组包技术能够确保大文件的完整传输。
     </li>
     <li>
      <strong>
       物联网通信：
      </strong>
      在物联网设备之间的通信中，数据量通常较小且需要高效可靠地传输，分包和组包技术能够满足物联网通信的需求。
     </li>
    </ul>
    <p>
     综上所述，TCP通信分包和组包过程是保证数据传输可靠性和完整性的重要环节，通过合理地处理分包和组包问题，可以提高网络通信的效率和可靠性。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373033373334382f:61727469636c652f64657461696c732f313338323838373931" class_="artid" style="display:none">
 </p>
</div>


