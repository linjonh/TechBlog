---
layout: post
title: "Qt之TCP通信"
date: 2022-10-03 13:13:21 +0800
description: "TCP 协议（Transmission Control Protocol）全称是传输控制协议是一种面"
keywords: "TCP协议,Qt,QTcpServer"
categories: ['Qt']
tags: ['网络协议', '网络', 'Tcp']
artid: "127149867"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=127149867
    alt: "Qt之TCP通信"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Qt之TCP通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="%E4%B8%80%E3%80%81TCP%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;">
     <a href="#%E4%B8%80%E3%80%81TCP%E7%AE%80%E4%BB%8B" rel="nofollow">
      一、TCP简介
     </a>
    </p>
    <p id="%E4%BA%8C%E3%80%81TCP%E7%B1%BB-toc" style="margin-left:0px;">
     <a href="#%E4%BA%8C%E3%80%81TCP%E7%B1%BB" rel="nofollow">
      二、TCP类
     </a>
    </p>
    <p id="%C2%A01.QTcpServer-toc" style="margin-left:40px;">
     <a href="#%C2%A01.QTcpServer" rel="nofollow">
      1.QTcpServer
     </a>
    </p>
    <p id="2.%C2%A0%C2%A0QTcpSocket-toc" style="margin-left:40px;">
     <a href="#2.%C2%A0%C2%A0QTcpSocket" rel="nofollow">
      2. QTcpSocket
     </a>
    </p>
    <p id="%C2%A0%E4%BA%8C%E3%80%81TCP%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:0px;">
     <a href="#%C2%A0%E4%BA%8C%E3%80%81TCP%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">
      三、TCP服务器
     </a>
    </p>
    <p id="%E4%B8%89%E3%80%81TCP%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:0px;">
     <a href="#%E4%B8%89%E3%80%81TCP%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">
      四、TCP客户端
     </a>
    </p>
    <p id="%C2%A0%E5%9B%9B%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF-toc" style="margin-left:0px;">
     <a href="#%C2%A0%E5%9B%9B%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF" rel="nofollow">
      五、获取本机网络信息
     </a>
    </p>
    <p id="%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;">
     <a href="#%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">
      六、代码
     </a>
    </p>
    <p id="1.TCP%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;">
     <a href="#1.TCP%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">
      1.TCP服务器
     </a>
    </p>
    <p id="2.TCP%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:40px;">
     <a href="#2.TCP%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">
      2.TCP客户端
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81TCP%E7%AE%80%E4%BB%8B">
     一、TCP简介
    </h2>
    <p>
     <span style="color:#fe2c24;">
      <strong>
       TCP 协议（Transmission Control Protocol）全称是传输控制协议是一种面向连接的、可靠的、
       <br/>
       基于字节流的传输层通信协议
      </strong>
     </span>
     。TCP是大多数 Internet 协议（包括 HTTP 和 FTP）用于数据传输的低级网络协议。它是一种可靠的，面向流，面向连接的传输协议。它特别适合连续数据传输。
    </p>
    <p>
     TCP 通信必须先建立 TCP 连接，通信端分为
     <span style="background-color:#ff9900;">
      客户端
     </span>
     和
     <span style="background-color:#a2e043;">
      服务端
     </span>
     。
     <strong>
      服务端通过监听某个端口来监听是否有客户端连接到来，如果有连接到来，则建立新的 socket 连接
     </strong>
     ；
     <strong>
      客户端通过 ip 和port 连接服务端，当成功建立连接之后，就可进行数据的收发了
     </strong>
     。
    </p>
    <p>
     需要注意的是，在 Qt 中把 socket 当成输入输出流来对待的，数据的收发是
     <span style="background-color:#ed7976;">
      通过 read()和 write()来进行的
     </span>
     ，需要与常见的 send()与 recv()进行区分。
    </p>
    <p>
     TCP 客户端与服务端通信示意图如下：
     <br/>
     <img alt="" height="263" src="https://i-blog.csdnimg.cn/blog_migrate/351b644abdedc133df61c85e0052347b.png" width="719"/>
    </p>
    <p>
     <img alt="" height="710" src="https://i-blog.csdnimg.cn/blog_migrate/6f7e4e983586df0435584f423db620d8.png" width="1200"/>
    </p>
    <p>
     Qt 网络模块提供了编写 TCP / IP 客户端和服务器的类。它提供了较低级别的类，如代表低级网络概念的
     <span style="background-color:#a2e043;">
      QTcpSocket， QTcpServer 和 QUdpSocket
     </span>
     ，以及如
     <span style="background-color:#ff9900;">
      QNetworkRequest，QNetworkReply 和 QNetworkAccessManager
     </span>
     之类的高级类来执行使用应用层网络相关类和通用协议的网络操作。 它还提供了如QNetworkConfiguration， QNetworkConfigurationManager和QNetworkSession等类，实现承载管理。
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81TCP%E7%B1%BB">
     二、TCP类
    </h2>
    <p>
     想要在程序中使用 Qt 网络模块，需要在 pro 项目配置文件添加network模块
    </p>
    <blockquote>
     <p>
      QT   +=     network
     </p>
     <p>
      #include &lt;QtNetwork&gt;  //在头文件中添加
     </p>
    </blockquote>
    <p>
     使用 Qt 提供的类进行基于 TCP 的套接字通信需要用到两个类：
    </p>
    <blockquote>
     <p>
      <span style="color:#fe2c24;">
       QTcpServer：
      </span>
      服务器类，
      <span style="background-color:#38d8f0;">
       用于监听客户端连接以及和客户端建立连接
      </span>
      。
      <br/>
      <span style="color:#fe2c24;">
       QTcpSocket：
      </span>
      通信的套接字类，
      <span style="background-color:#38d8f0;">
       客户端、服务器端都需要使用
      </span>
      。
     </p>
    </blockquote>
    <h3 id="%C2%A01.QTcpServer">
     1.QTcpServer
    </h3>
    <p>
     QTcpServer 类用于监听客户端连接以及和客户端建立连接 。
    </p>
    <p>
     常用API函数
    </p>
    <p>
     <strong>
      ①构造函数
     </strong>
    </p>
    <blockquote>
     <p>
      QTcpServer::QTcpServer(QObject *parent = Q_NULLPTR);
     </p>
    </blockquote>
    <p>
     <strong>
      ②给监听的套接字设置监听
     </strong>
    </p>
    <pre><code class="language-cpp">bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0);
// 判断当前对象是否在监听, 是返回true，没有监听返回false
bool QTcpServer::isListening() const;
// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null
QHostAddress QTcpServer::serverAddress() const;
// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0
quint16 QTcpServer::serverPort() const
</code></pre>
    <blockquote>
     <p>
      address：通过类 QHostAddress 可以封装 IPv4、IPv6 格式的 IP 地址，
      <span style="color:#fe2c24;">
       QHostAddress::Any 表示自动绑定
      </span>
      <br/>
      port：如果指定为 0 表示随机绑定一个可用端口。
      <br/>
      返回值：绑定成功返回 true，失败返回 false
     </p>
    </blockquote>
    <p>
     得到和客户端建立连接之后用于
     <span style="background-color:#a2e043;">
      通信的 QTcpSocket 套接字对象
     </span>
     ，它是 QTcpServer 的一个子对象，当 QTcpServer 对象析构的时候会自动析构这个子对象，当然也可自己手动析构，建议用完之后自己手动析构这个通信的 QTcpSocket 对象。
    </p>
    <blockquote>
     <p>
      QTcpSocket *QTcpServer::nextPendingConnection();//获取客户端连接的套接字
     </p>
    </blockquote>
    <p>
     阻塞等待客户端发起的连接请求，不推荐在单线程程序中使用，建议使用非阻塞方式处理新连接，即使用信号 newConnection() 。
    </p>
    <blockquote>
     <p>
      bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = Q_NULLPTR);
     </p>
     <p>
      msec：指定阻塞的最大时长，单位为毫秒（ms）
      <br/>
      timeout：传出参数，如果操作超时 timeout 为 true，没有超时 timeout 为 false
     </p>
    </blockquote>
    <p>
     常用信号
    </p>
    <p>
     ① 当接受新连接导致错误时，将发射如下信号。socketError 参数描述了发生的错误相关的信息。
    </p>
    <blockquote>
     <p>
      [signal] void QTcpServer::acceptError(QAbstractSocket::SocketError socketError);
     </p>
    </blockquote>
    <p>
     ②
     <strong>
      每次有新连接可用时都会发出 newConnection () 信号
     </strong>
     。
    </p>
    <blockquote>
     <p>
      <span style="background-color:#a2e043;">
       [signal] void QTcpServer::newConnection();
      </span>
     </p>
    </blockquote>
    <p>
    </p>
    <h3 id="2.%C2%A0%C2%A0QTcpSocket">
     2. QTcpSocket
    </h3>
    <p>
     QTcpSocket 是一个
     <span style="color:#fe2c24;">
      套接字通信类
     </span>
     ，
     <strong>
      <span style="color:#ff9900;">
       不管是客户端还是服务器端都需要使用
      </span>
     </strong>
     。在 Qt 中发送和接收数据也属于 IO 操作（网络 IO）。
    </p>
    <p>
     <img alt="" height="151" src="https://i-blog.csdnimg.cn/blog_migrate/fbec4dd263e13412b28a486d9e338b24.png" width="1038"/>
    </p>
    <p>
     常用API函数
    </p>
    <p>
     <strong>
      ①构造函数
     </strong>
    </p>
    <blockquote>
     <p>
      QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR);
     </p>
    </blockquote>
    <p>
     ②连接服务器，需要指定服务器端绑定的IP和端口信息。
    </p>
    <pre><code class="language-cpp">[virtual] void QAbstractSocket::connectToHost(const QString &amp;hostName, quint16 port,OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol);

[virtual] void QAbstractSocket::connectToHost(const QHostAddress &amp;address, quint16 port,OpenMode openMode = ReadWrite);</code></pre>
    <p>
     一般给ip地址和端口号就可以了。
    </p>
    <p>
     ③接收数据
    </p>
    <pre><code class="language-cpp">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中
qint64 QIODevice::read(char *data, qint64 maxSize);
// 指定可接收的最大字节数 maxSize，返回接收的字符串
QByteArray QIODevice::read(qint64 maxSize);
// 将当前可用操作数据全部读出，通过返回值返回读出的字符串
QByteArray QIODevice::readAll();
</code></pre>
    <p>
     ④发送数据
    </p>
    <pre><code class="language-cpp">// 发送指针 data 指向的内存中的 maxSize 个字节的数据
qint64 QIODevice::write(const char *data, qint64 maxSize);
// 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记
qint64 QIODevice::write(const char *data);
// 发送参数指定的字符串
qint64 QIODevice::write(const QByteArray &amp;byteArray);
</code></pre>
    <p>
     常用信号
    </p>
    <p>
     ①在使用 QTcpSocket 进行套接字通信的过程中，如果
     <strong>
      该类对象发射出 readyRead() 信号，说明对端发送的数据达到了，之后就可以调用 read 函数接收数据了
     </strong>
     。
    </p>
    <blockquote>
     <p>
      [signal] void QIODevice::readyRead();
     </p>
    </blockquote>
    <p>
     ②调用
     <span style="background-color:#ffd900;">
      connectToHost() 函数
     </span>
     连接TCP服务器并成功建立连接之后
     <span style="background-color:#38d8f0;">
      发出 connected() 信号
     </span>
     。
    </p>
    <blockquote>
     <p>
      [signal] void QAbstractSocket::connected();
     </p>
    </blockquote>
    <p>
     ③在套接字断开连接时发出 disconnected() 信号。
    </p>
    <blockquote>
     <p>
      [signal] void QAbstractSocket::disconnected();
     </p>
    </blockquote>
    <h2 id="%C2%A0%E4%BA%8C%E3%80%81TCP%E6%9C%8D%E5%8A%A1%E5%99%A8">
     三、TCP服务器
    </h2>
    <p>
     <strong>
      ①创建套接字服务器 QTcpServer 对象
     </strong>
    </p>
    <blockquote>
     <p>
      mServer = new QTcpServer(this);
     </p>
    </blockquote>
    <p>
     <strong>
      ②通过 QTcpServer 对象设置监听，即：
      <span style="color:#ffd900;">
       QTcpServer::listen()
      </span>
     </strong>
    </p>
    <blockquote>
     <p>
      mServer-&gt;listen(QHostAddress::Any/*IP地址*/,端口号);
     </p>
    </blockquote>
    <p>
     <strong>
      ③基于 QTcpServer::newConnection() 信号检测是否有新的客户端连接
     </strong>
    </p>
    <blockquote>
     <p>
      connect(mServer,&amp;QTcpServer::newConnection,this,[&amp;](){
      <!-- -->
     </p>
     <p>
     </p>
     <p>
      });
     </p>
    </blockquote>
    <p>
     <span style="background-color:#a2e043;">
      当客户端连接上来时，会触发信号(newConnection),连接该信号和槽
     </span>
     ， 如果需要处理客户端发起的 TCP 连接，请使用 QTcpServer 类。调用
     <span style="background-color:#ff9900;">
      QTcpServer::listen() 设置服务器
     </span>
     ，并连接到
     <span style="color:#fe2c24;">
      QTcpServer::newConnection() 信号
     </span>
     ，该信号对于每个连接的客户端发出一次。在对应的槽函数中，
     <span style="background-color:#a2e043;">
      调用 QTcpServer::nextPendingConnection() 接受连接
     </span>
     ，并使用返回的QTcpSocket 与客户端进行通信。
     <br/>
    </p>
    <p>
     <strong>
      ④在上面的槽函数中获取和客户端通信的套接字
     </strong>
    </p>
    <blockquote>
     <p>
      //获取和客户端通信的套接字
     </p>
     <p>
      mSocket = mServer-&gt;nextPendingConnection();
     </p>
     <p>
      //获取客户端地址
      <br/>
      QHostAddress c_addr = mSocket-&gt;peerAddress();
     </p>
    </blockquote>
    <p>
     <span style="color:#fe2c24;">
      如果有新的客户端连接，调用 QTcpSocket *QTcpServer::nextPendingConnection() 得到通信的套接字对象
     </span>
     。
    </p>
    <p>
     QTcpSocket 使用必须先建立与远程主机和端口的 TCP 连接，然后才能开始任何数据传输。建立
     <br/>
     连接后，即可通过
     <span style="background-color:#a2e043;">
      QTcpSocket::peerAddress()
     </span>
     和
     <span style="background-color:#38d8f0;">
      QTcpSocket::peerPort()
     </span>
     获得对等方的
     <span style="color:#fe2c24;">
      IP 地址和端口
     </span>
     。对等方可以随时关闭连接，然后数据传输将立即停止
    </p>
    <p>
     注意：
     <span style="color:#fe2c24;">
      这里对mSocket的操作是从客户端连接服务端得到的通过nextPendingConnection方式。
     </span>
    </p>
    <p>
     <strong>
      ⑤使用通信的套接字对象 QTcpSocket 和客户端进行通信
     </strong>
    </p>
    <p>
     发送： 通过QTcpSocket对象的
     <span style="background-color:#a2e043;">
      write成员函数
     </span>
     发送数据
    </p>
    <blockquote>
     <p>
      //获取发送的数据
      <br/>
      QString str = ui-&gt;lineEdit-&gt;text();
      <br/>
      //转换成QByteArray
      <br/>
      QByteArray arr;
      <br/>
      arr.append(str);
      <br/>
      //发送
      <br/>
      mSocket-&gt;write(arr);
     </p>
    </blockquote>
    <p>
     接收： 收到数据会
     <span style="background-color:#a2e043;">
      触发信号readyRead
     </span>
     , 在连接的槽函数中调用QTcpSocket对象的
     <span style="background-color:#38d8f0;">
      read/readAll接收数据
     </span>
     。
    </p>
    <blockquote>
     <p>
      //连接readyRead信号和槽
      <br/>
      QObject::connect(mSocket,&amp;QTcpSocket::readyRead,this,[&amp;]()
     </p>
     <p>
      {
      <!-- -->
      <br/>
      //接收数据
      <br/>
      QByteArray arr = mSocket-&gt;readAll();
      <br/>
      //转换成字符串
      <br/>
      QString str(arr);
      <br/>
      //显示
      <br/>
      ui-&gt;textBrowser-&gt;insertPlainText("rcv:"+str+"\n");
      <br/>
      });
     </p>
    </blockquote>
    <h2 id="%E4%B8%89%E3%80%81TCP%E5%AE%A2%E6%88%B7%E7%AB%AF">
     四、TCP客户端
    </h2>
    <p>
     <strong>
      ①创建通信的套接字类 QTcpSocket 对象
     </strong>
    </p>
    <blockquote>
     <p>
      mSocket = new QTcpSocket(this);
     </p>
    </blockquote>
    <p>
     <strong>
      ②使用服务器端绑定的 IP 和端口连接服务器
      <span style="color:#fe2c24;">
       QAbstractSocket::connectToHost()
      </span>
      。
     </strong>
    </p>
    <blockquote>
     <p>
      mSocket-&gt;connectToHost(ip,端口号);
     </p>
    </blockquote>
    <p>
     <strong>
      ③连接成功会
      <span style="background-color:#a2e043;">
       触发connected信号
      </span>
     </strong>
    </p>
    <blockquote>
     <p>
      QObject::connect(mSocket,&amp;QTcpSocket::connected,this,[&amp;](){
      <!-- -->
     </p>
     <p>
     </p>
     <p>
      });
     </p>
    </blockquote>
    <p>
     <strong>
      ④使用 QTcpSocket 对象和服务器进行通信
     </strong>
    </p>
    <p>
     发送： 通过QTcpSocket对象的write成员函数发送数据
    </p>
    <blockquote>
     <p>
      //获取发送的数据
     </p>
     <p>
      QString str = ui-&gt;lineEdit_send-&gt;text();
     </p>
     <p>
      //转换成QByteArray QByteArray arr;
     </p>
     <p>
      arr.append(str);
     </p>
     <p>
      //发送 mSocket-&gt;write(arr);
     </p>
    </blockquote>
    <p>
     接收： 收到数据会
     <span style="background-color:#a2e043;">
      触发信号readyRead
     </span>
     ,在连接的槽函数中调用QTcpSocket对象的
     <span style="background-color:#38d8f0;">
      read/readAll接收数据
     </span>
     。
    </p>
    <blockquote>
     <p>
      //连接readyRead信号和槽
     </p>
     <p>
      QObject::connect(mSocket,&amp;QTcpSocket::readyRead,this,[&amp;]()
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      //接收数据
     </p>
     <p>
      QByteArray arr = mSocket-&gt;readAll();
     </p>
     <p>
      //转换成字符串
     </p>
     <p>
      QString str(arr);
     </p>
     <p>
      //显示
     </p>
     <p>
      ui-&gt;textBrowser-&gt;insertPlainText(rcv:+str+\n);
     </p>
     <p>
      });
     </p>
    </blockquote>
    <h2 id="%C2%A0%E5%9B%9B%E3%80%81%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF">
     五、获取本机网络信息
    </h2>
    <p>
     在建立网络通信之前至少要得获取对方的 IP地址。 在网络应用中，经常需要用到本机的主机名、 IP 地址、 MAC 地址等网络信息，通常通在 Windows 通过调出命令行 cmd 窗口输入 ipconfig 或者在 Linux 系统中使用 ifconfig 命令就可以查看相关信息了。
    </p>
    <p>
     Qt 提供了
     <span style="background-color:#a2e043;">
      QHostInfo 和 QNetworkInterface 类可以用于此类信息查询
     </span>
     。
    </p>
    <blockquote>
     <p>
      #include &lt;QNetworkInterface&gt;
      <br/>
      #include &lt;QHostInfo&gt;
     </p>
    </blockquote>
    <pre><code class="language-cpp">//通过 QHostInfo 的 localHostName 函数获取主机名称 
QString str = "主机名称： " + QHostInfo::localHostName() + "\n";


//获取所有的网络接口，QNetworkInterface 类提供主机的 IP 地址和网络接口的列表
QList&lt;QNetworkInterface&gt; list = QNetworkInterface::allInterfaces();

//遍历 list
foreach (QNetworkInterface interface, list) 
{
    str+= "网卡设备:" + interface.name() + "\n";
    str+= "MAC 地址:" + interface.hardwareAddress() + "\n";


    //QNetworkAddressEntry 类存储 IP 地址子网掩码和广播地址
    QList&lt;QNetworkAddressEntry&gt; entryList= interface.addressEntries();
    //遍历 entryList
    foreach (QNetworkAddressEntry entry, entryList) 
    {
        //过滤 IPv6 地址，只留下 IPv4 
        if (entry.ip().protocol() ==QAbstractSocket::IPv4Protocol) 
        {
            str+= "IP 地址:" + entry.ip().toString() + "\n";
            str+= "子网掩码:" + entry.netmask().toString() + "\n";
            str+= "广播地址:" + entry.broadcast().toString() + "\n\n";
        }
    }
 }</code></pre>
    <h2 id="%E4%BA%94%E3%80%81%E4%BB%A3%E7%A0%81">
     六、代码
    </h2>
    <h3 id="1.TCP%E6%9C%8D%E5%8A%A1%E5%99%A8">
     1.TCP服务器
    </h3>
    <p>
     头文件
    </p>
    <pre><code class="language-cpp">#ifndef TCPSERVER_H
#define TCPSERVER_H

#include &lt;QWidget&gt;
#include &lt;QtNetwork&gt;

QT_BEGIN_NAMESPACE
namespace Ui { class TcpServer; }
QT_END_NAMESPACE

class TcpServer : public QWidget
{
    Q_OBJECT

public:
    TcpServer(QWidget *parent = nullptr);
    ~TcpServer();

private slots:
    void on_pushButton_start_clicked();

    void on_pushButton_send_clicked();

private:
    Ui::TcpServer *ui;
    //TCP服务器
    QTcpServer *mServer;
    QTcpSocket *mSocket;
};
#endif // TCPSERVER_H
</code></pre>
    <p>
     源文件
    </p>
    <pre><code class="language-cpp">#include "tcpserver.h"
#include "ui_tcpserver.h"
#include &lt;QDebug&gt;

TcpServer::TcpServer(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::TcpServer)
{
    ui-&gt;setupUi(this);
}

TcpServer::~TcpServer()
{
    delete ui;
}

//启动TCP服务器
void TcpServer::on_pushButton_start_clicked()
{
    //1.构造QTcpServer对象
    mServer = new QTcpServer(this);
    //2.连接客户端连接上来的信号
    QObject::connect(mServer,&amp;QTcpServer::newConnection,this,[&amp;](){
        //获取客户端连接上来的套接字
        mSocket = mServer-&gt;nextPendingConnection();
        //打印客户端的地址
        QHostAddress c_addr = mSocket-&gt;peerAddress();
        qDebug()&lt;&lt;c_addr.toString()&lt;&lt;"连接上来!";

        //使能发送输入框和按钮
        ui-&gt;lineEdit-&gt;setEnabled(true);
        ui-&gt;pushButton_send-&gt;setEnabled(true);

        //连接readyRead信号和槽
        QObject::connect(mSocket,&amp;QTcpSocket::readyRead,this,[&amp;](){
            //接收数据
            QByteArray arr = mSocket-&gt;readAll();
            //转换成字符串
            QString str(arr);
            //显示
            ui-&gt;textBrowser-&gt;insertPlainText("rcv:"+str+"\n");
        });
    });

    //3.监听
    mServer-&gt;listen(QHostAddress::Any,ui-&gt;spinBox-&gt;value());

    //连接回车发送的信号和槽
    QObject::connect(ui-&gt;lineEdit,&amp;QLineEdit::returnPressed,this,&amp;TcpServer::on_pushButton_send_clicked);

    //禁止端口号和启动按钮
    ui-&gt;spinBox-&gt;setEnabled(false);
    ui-&gt;pushButton_start-&gt;setEnabled(false);
}

void TcpServer::on_pushButton_send_clicked()
{
    //获取发送的数据
    QString str = ui-&gt;lineEdit-&gt;text();
    //转换成QByteArray
    QByteArray arr;
    arr.append(str);

    //发送
    mSocket-&gt;write(arr);
    //显示发送的内容
    ui-&gt;textBrowser-&gt;insertPlainText("send:"+str+"\n");
    //情况lineEdit
    ui-&gt;lineEdit-&gt;clear();
}
</code></pre>
    <p>
     ui界面
    </p>
    <p>
     <img alt="" height="526" src="https://i-blog.csdnimg.cn/blog_migrate/0e755d97913d4bccc0bb254e50db1983.png" width="802"/>
    </p>
    <p>
    </p>
    <h3 id="2.TCP%E5%AE%A2%E6%88%B7%E7%AB%AF">
     2.TCP客户端
    </h3>
    <p>
     头文件
    </p>
    <pre><code class="language-cpp">#ifndef TCPCILENT_H
#define TCPCILENT_H

#include &lt;QWidget&gt;
#include &lt;QtNetwork&gt;

QT_BEGIN_NAMESPACE
namespace Ui { class TcpCilent; }
QT_END_NAMESPACE

class TcpCilent : public QWidget
{
    Q_OBJECT

public:
    TcpCilent(QWidget *parent = nullptr);
    ~TcpCilent();

private slots:
    void on_pushButton_start_clicked();

    void on_pushButton_send_clicked();

private:
    Ui::TcpCilent *ui;
    //TCP客户端
    QTcpSocket *mSocket;
};
#endif // TCPCILENT_H
</code></pre>
    <p>
     源文件
    </p>
    <pre><code class="language-cpp">#include "tcpcilent.h"
#include "ui_tcpcilent.h"

TcpCilent::TcpCilent(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::TcpCilent)
{
    ui-&gt;setupUi(this);
}

TcpCilent::~TcpCilent()
{
    delete ui;
}

//连接服务器
void TcpCilent::on_pushButton_start_clicked()
{
    //1.创建QTcpSocket对象
    mSocket = new QTcpSocket(this);
    //2.连接连接成功的信号和槽
    QObject::connect(mSocket,&amp;QTcpSocket::connected,this,[&amp;](){
        //使能发送按钮和发送输入框
        ui-&gt;lineEdit_send-&gt;setEnabled(true);
        ui-&gt;pushButton_send-&gt;setEnabled(true);

        //禁止ip 端口号和连接按钮
        ui-&gt;lineEdit_ip-&gt;setEnabled(false);
        ui-&gt;spinBox-&gt;setEnabled(false);
        ui-&gt;pushButton_start-&gt;setEnabled(false);


        //连接readyRead信号和槽
        QObject::connect(mSocket,&amp;QTcpSocket::readyRead,this,[&amp;](){
            //接收数据
            QByteArray arr = mSocket-&gt;readAll();
            //转换成字符串
            QString str(arr);
            //显示
            ui-&gt;textBrowser-&gt;insertPlainText("rcv:"+str+"\n");
        });
    });


    //3.连接服务器
    QString ip = ui-&gt;lineEdit_ip-&gt;text();
    quint16 port = ui-&gt;spinBox-&gt;value();
    mSocket-&gt;connectToHost(ip,port);

    //连接回车发送的信号和槽
    QObject::connect(ui-&gt;lineEdit_send,&amp;QLineEdit::returnPressed,this,&amp;TcpCilent::on_pushButton_send_clicked);
}

//发送
void TcpCilent::on_pushButton_send_clicked()
{
    //获取发送的数据
    QString str = ui-&gt;lineEdit_send-&gt;text();
    //转换成QByteArray
    QByteArray arr;
    arr.append(str);

    //发送
    mSocket-&gt;write(arr);
    //显示发送的内容
    ui-&gt;textBrowser-&gt;insertPlainText("send:"+str+"\n");
    //情况lineEdit
    ui-&gt;lineEdit_send-&gt;clear();
}
</code></pre>
    <p>
     <img alt="" height="526" src="https://i-blog.csdnimg.cn/blog_migrate/7eae5a993cc1da6693aa4a504cf05269.png" width="802"/>
    </p>
    <p>
     通信：
    </p>
    <p>
     <img alt="" height="522" src="https://i-blog.csdnimg.cn/blog_migrate/b36f1734cefff8a14f93e446fac3fd32.png" width="1200"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35333134343834332f:61727469636c652f64657461696c732f313237313439383637" class_="artid" style="display:none">
 </p>
</div>


