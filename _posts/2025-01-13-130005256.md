---
layout: post
title: "前端加密,后端解密用RSA和AES256双重加密"
date: 2025-01-13 17:15:13 +0800
description: "7、服务器端收到key_str用RSA2048私钥解密key_str得到AES256密钥，然后用AE"
keywords: "ase sha256 前端加密 后端解密"
categories: ["未分类"]
tags: ["后端", "前端", "Vue", "Java"]
artid: "130005256"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=130005256
  alt: "前端加密,后端解密用RSA和AES256双重加密"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端加密，后端解密（用RSA和AES256双重加密）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     这两天接到这么一个需求：
     <br/>
     1、生成一个密钥对
     <br/>
     2、前端写死RSA2048公钥
     <br/>
     3、后端RSA2048私钥写到配置文件中
     <br/>
     4、前端发请求的时候random一个AES256的key，然后用RSA2048公钥加密Key生成key_str
     <br/>
     5、前端发的请求体用AES256key整个加密生成sec_text
     <br/>
     6、前端发请求的时候将key_str放入请求头（或者请求体也可以）
     <br/>
     7、服务器端收到key_str用RSA2048私钥解密key_str得到AES256密钥，然后用AES256密钥解密sec_text获得请求数据
    </p>
    <p>
     具体实现：
     <br/>
     前后端用RSA加解密详情请点击这里：
     <a href="https://blog.csdn.net/qq_1382430/article/details/123692258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168077903216800192235274%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168077903216800192235274&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-123692258-null-null.142%5Ev81%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%89%8D%E5%90%8E%E7%AB%AFRSA2048%E5%8A%A0%E8%A7%A3%E5%AF%86&amp;spm=1018.2226.3001.4187">
      前后端RSA加解密
     </a>
    </p>
    <p>
     前后端用AES加解密详情请点击这里：
     <a href="https://blog.csdn.net/qq_35228658/article/details/126658431">
      前后端AES加解密
     </a>
    </p>
    <p>
     random函数生成一个n位随机数：
    </p>
    <pre><code>// n位随机数生成
function randomNum(n) {
  let sString = "";
  let strings =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  for (let i = 0; i &lt; n; i++) {
    let ind = Math.floor(Math.random() * strings.length);
    sString += strings.charAt(ind);
  }
  return sString;
}
</code></pre>
    <pre><code>// 生成一个16位随机数作为AES加密的key值
var word = randomNum(16).toString();
</code></pre>
    <pre><code>/* JSEncrypt 公钥加密  padding:pkcs1pad2 */
export const getRsaKey = () =&gt; {
  // 公钥
  let pubKey = `XXXX`; // ES6 模板字符串 引用 rsa 公钥
  //创建jsencrypt加密对象
  let encryptStr = new JSEncrypt();
  encryptStr.setPublicKey(pubKey); // 设置 加密公钥
  let key_str = encryptStr.encrypt(word); // 进行加密
  return key_str;
};

/_ JSEncrypt 私钥解密 _/
export function decrypt() {
let decrypt = new JSEncrypt();
// 私钥
const privateKeyStr = `XXXX`;
// 设置私钥
decrypt.setPrivateKey(privateKeyStr);
// 解密
var decryptMsg = decrypt.decrypt(getRsaKey());
return decryptMsg;
}
/\*\*

- AES 加密
  \*/
  export const AESEncrypt = (str, key) =&gt; {
  let \_key = key || word;
  const **key = CryptoJS.enc.Utf8.parse(\_key); //将秘钥转换成 Utf8 字节数组
  // const iv = CryptoJS.enc.Utf8.parse(\_key.substr(0, 16))
  //加密
  const encrypt = CryptoJS.AES.encrypt(JSON.stringify(str), **key, {
  // iv: iv,
  mode: CryptoJS.mode.ECB,
  padding: CryptoJS.pad.Pkcs7,
  });
  return encrypt.toString();
  };

/\*\*

- AES 解密密
  \*/
  export const AESDecrypt = (str, key) =&gt; {
  let \_key = key || word;
  const \_\_key = CryptoJS.enc.Utf8.parse(\_key); //将秘钥转换成 Utf8 字节数组

const decrypt = CryptoJS.AES.decrypt(str, \_\_key, {
mode: CryptoJS.mode.ECB,
padding: CryptoJS.pad.Pkcs7,
});
const \_decrypt = JSON.parse(decrypt.toString(CryptoJS.enc.Utf8)); //解密后的数据
return \_decrypt;
};
</code></pre>
<p>
<strong>
传给后端接口请求体里的参数参照如下：
</strong>
</p>
<pre><code>import { AESEncrypt, getRsaKey } from "@/utils/AES.js";
let rqdata = {
key_str: getRsaKey(),
sec_text: AESEncrypt(
JSON.stringify({
name: data.applicant,
areaCode: String(data.areaCode),
phone: String(data.phoneNumber),
}),
null
),
};
</code></pre>

   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353634343335352f:61727469636c652f64657461696c732f313330303035323536" class_="artid" style="display:none">
 </p>
</div>
