---
layout: post
title: "HTTP流量拷贝测试神器GoReplay"
date: 2025-01-13 07:00:00 +0800
description: "一般在软件发布之前，都会经过单元测试, 接口测试, 集成测试, 性能测试等。但是这些测试往往都是基于"
keywords: "goreplay 响应结果对比"
categories: ['测试']
tags: ['测试', 'Http']
artid: "121436093"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=121436093
    alt: "HTTP流量拷贝测试神器GoReplay"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     HTTP流量拷贝测试神器GoReplay
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     一般在软件发布之前，都会经过
     <code>
      单元测试
     </code>
     ,
     <code>
      接口测试
     </code>
     ,
     <code>
      集成测试
     </code>
     ,
     <code>
      性能测试
     </code>
     等。但是这些测试往往都是基于自己定义的测试数据集合，很可能会有漏网之鱼，那么在软件上线之后，在线上的流量冲击下，会出现各种之前测试中并没有发现的问题。这是因为线上的流量数据比测试的数据更加多样性，并且随着用户数量的增加，线上流量的也越来越大，更多的隐藏问题也会明显暴露，比如并发处理不当导致的Crash也随之出现。 那么我们有什么方法能够在上线之前完成这些测试呢？有的，那就是
     <code>
      GoReplay
     </code>
     。
    </p>
    <h2>
     <a id="GoReplay_2">
     </a>
     GoReplay概述
    </h2>
    <p>
     当前越来越多的产品SaaS化，而SaaS化之后很多的服务都切分成多个
     <code>
      微服务
     </code>
     ，HTTP又是服务之间常用的远程调用方式。
     <br/>
     <code>
      GoReplay
     </code>
     是一个用
     <code>
      Golang
     </code>
     编写的开源的流量复制工具, 基于
     <code>
      libpcap
     </code>
     (windows也叫做
     <code>
      Winpcap
     </code>
     ，
     <code>
      Npcap
     </code>
     也可以支持)，其原理和
     <code>
      Wireshark
     </code>
     和
     <code>
      Tcpdump
     </code>
     类似，是一种非侵入软件方式的流量复制方式。（
     <strong>
      下图来自于GoReplay 官方 Wiki
     </strong>
     ）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/99b54b0f5424d4a7d27c2c2e02d5608a.png">
      <br/>
      上图是一个典型的应用场景：
     </img>
    </p>
    <ol>
     <li>
      <code>
       GoReplay
      </code>
      实现为一个可执行程序，方便运行, 支持
      <code>
       Windows
      </code>
      和
      <code>
       Linux
      </code>
      。先将其运行在一个具有流量环境的机器上, 监听指定端口的流量。
     </li>
     <li>
      <code>
       GoReplay
      </code>
      将监听到的流量，以
      <code>
       HTTP
      </code>
      发送到指定的一个或者多台测试机器。
     </li>
     <li>
      测试人员可以在测试机器上对流量处理结果进行分析。
     </li>
    </ol>
    <p>
     软件还提供了丰富的功能:
    </p>
    <ol>
     <li>
      比如根据
      <code>
       HTTP
      </code>
      请求的
      <code>
       Method
      </code>
      ,
      <code>
       请求路径
      </code>
      ,
      <code>
       请求头
      </code>
      进行过滤
     </li>
     <li>
      可以对请求进行进行改写，比如增加HTTP Header
     </li>
     <li>
      可以基于
      <code>
       Middleware
      </code>
      ，可以理解为自己编写插件。在插件中自己可以获取
      <code>
       原始请求
      </code>
      ,
      <code>
       原始响应结果
      </code>
      ， 以及测试机器返回
      <code>
       测试响应结果
      </code>
      ，这样就可以实现当前机器上的
      <code>
       原始响应结果
      </code>
      和
      <code>
       测试响应结果
      </code>
      做对比测试。
     </li>
    </ol>
    <p>
     <code>
      GoReplay
     </code>
     作者提供了编译好的版本，提供
     <a href="https://github.com/buger/goreplay/releases">
      下载地址
     </a>
     。
    </p>
    <p>
     本文将介绍 如下几个方面，来阐述
     <code>
      GoReplay
     </code>
     的常见功能，而关于进阶的
     <code>
      GoReplay插件实现
     </code>
     将放在后续的文章中。
    </p>
    <ul>
     <li>
      流量复制测试
     </li>
     <li>
      流量保存到文件和重放功能介绍
     </li>
     <li>
      HTTP请求过滤
     </li>
     <li>
      HTTP请求更改
     </li>
    </ul>
    <h2>
     <a id="_24">
     </a>
     流量复制测试
    </h2>
    <p>
     现在假设有一台有流量的机器，运行了一个服务，监听端口
     <code>
      9797
     </code>
     , 客户端使用
     <code>
      HTTP
     </code>
     和服务通信。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d84b4da92784050da74bfb0f8d24a573.png">
      <br/>
      如果你想练练手，可是没有现成服务进程，不要担心，
      <code>
       GoReplay
      </code>
      本身提供了模拟服务的功能。那么你可以在服务机器上模拟运行
      <code>
       sudo ./gor file-server :9797
      </code>
      。这个时候你通过浏览器访问这个机器就可以产生流量了。
     </img>
    </p>
    <p>
     现在要开始进行测试了，先准备一台测试机器，也运行这个服务。然后进行流量拷贝操作。如下图所示在机器上运行
     <code>
      GoReplay
     </code>
     命令如下：
    </p>
    <pre><code>sudo ./gor  --input-raw :9797 --output-http "http://&lt;测试机器IP&gt;:9797"
</code></pre>
    <p>
     这个时候将会在
     <code>
      服务机器
     </code>
     上将端口
     <code>
      9797
     </code>
     上的HTTP流量复制到
     <code>
      测试机器
     </code>
     。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ddfb249596ae892bc13e1a0f2dcd3753.png">
      <br/>
      这样做了，你就可以在不影响运行的
      <code>
       服务机器
      </code>
      ，在
      <code>
       测试机器
      </code>
      上任意的开启调试选项或者更改
      <code>
       服务进程
      </code>
      的代码等，来辅助进行流量测试分析。是不是没有想到，
      <code>
       GoReplay
      </code>
      的使用如此简单。
     </img>
    </p>
    <p>
     <strong>
      !!!注意!!!: 从实践角度而言，不建议进行在线的流量复制测试，因为只要在线上操作，那就有可能会对线上产生影响。比如服务机器和测试机器在互通的网络之中，如果服务进程可能对第三方比如DB，Redis进行写操作，而测试机器上的服务进程收到同样的流量后，也会进行同样的操作，这样必然容易引起问题。你可以通过修改代码，在测试服务机器上屏蔽对数据库等第三方服务的写操作。但是是人就会犯错误，那有可能屏蔽的不够完全，对线上产生第三方服务的更改产生了影响。所以本人不建议在线上使用这个方法。
     </strong>
    </p>
    <p>
     那么可以在
     <strong>
      保证流量落盘符合隐私保护法律和公司操作规范的情况下
     </strong>
     将流量Dump到本地磁盘文件，然后再在和
     <strong>
      线上环境隔离的测试环境
     </strong>
     中进行流量重放的测试和分析。
    </p>
    <h2>
     <a id="_42">
     </a>
     流量保存到文件和重放功能介绍
    </h2>
    <p>
     若要将流量保存到本地磁盘文件，那就一定要注意自己的行为是不侵犯
     <code>
      隐私保护法律
     </code>
     的，并且符合公司的规范。下面我们来讲一讲方法:
     <br/>
     将流量保存到文件：
     <br/>
     <code>
      sudo ./gor --input-raw :9797 --output-file Traffic.gor
     </code>
     <br/>
     那么将会产生若干个
     <code>
      Traffic_*.gor
     </code>
     的文件。
    </p>
    <p>
     那么如果重放则可以采用如下方式 (支持通配符方式)。
    </p>
    <pre><code>sudo ./gor --input-file  Traffic_*.gor --output-http "http://[测试机器A的IP]:9797" --output-http "http://[测试机器B的IP]:9797"
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ea872b897fc54890f5205dea3a605733.png">
      <br/>
      注意这里特意将流量发送到两台机器了，假设这里的
      <code>
       测试机器A
      </code>
      采用的是上一个发布版本的软件，而
      <code>
       测试机器B
      </code>
      采用的是正准备发布的新版本，通过两者运行的结果，比如Log，机器CPU，Memory等情况对比来做对比分析。 当然了如果不需要做对比，你也可以只讲流量导入到一个测试机器。
     </img>
    </p>
    <p>
     <code>
      GoReplay
     </code>
     重放的时候还可以用来做性能测试分析, 其可以通过放大速率来提高单位时间请求数量,比如下面按照五倍
     <code>
      500%
     </code>
     速率发送。
    </p>
    <pre><code>sudo ./gor --input-file  "Traffic_*.gor|500%" --output-http "http://[测试机器的IP]:9797"
</code></pre>
    <p>
     还可以使用
     <code>
      --input-file-loop
     </code>
     来实现循环不断的发送:
    </p>
    <pre><code>sudo ./gor --input-file  "Traffic_*.gor|500%" --input-file-loop --output-http "http://[测试机器的IP]:9797"
</code></pre>
    <p>
     另外可以使用
     <code>
      --stats --output-http-stats
     </code>
     来查看一些统计信息，不过本人觉得当前的统计信息还不够清晰。
    </p>
    <h2>
     <a id="HTTP_67">
     </a>
     HTTP请求过滤
    </h2>
    <p>
     HTTP请求的抓取，可以进行一些过滤，从而只抓取和自己感兴趣的请求。
     <br/>
     比如下面的命令，只有符合下述条件的才会抓取
    </p>
    <ol>
     <li>
      <code>
       --http-allow-url
      </code>
      采用正则表达式，只抓取
      <code>
       请求URL
      </code>
      中含有
      <code>
       test
      </code>
      的请求;
     </li>
     <li>
      <code>
       --http-allow-header
      </code>
      采用正则表达式，只抓取
      <code>
       XHeader
      </code>
      是
      <code>
       123
      </code>
      的请求;
     </li>
     <li>
      <code>
       --http-allow-method GET
      </code>
      , 只抓取HTTP请求方法为
      <code>
       GET
      </code>
      的请求。
     </li>
    </ol>
    <pre><code>sudo ./gor --input-raw :9797 --output-file test.gor --http-allow-url .*test.* --http-allow-header XHeader:123 --http-allow-method GET
</code></pre>
    <p>
     也可以使用
     <code>
      --http-disallow-url
     </code>
     和
     <code>
      --http-disallow-header
     </code>
     去除一些不需要抓取的请求，同样支持正则表达式。
    </p>
    <h2>
     <a id="HTTP_79">
     </a>
     HTTP请求更改
    </h2>
    <p>
     有时候你也需要更改HTTP请求，比如你想增加某个HTTP Header去让测试服务器识别，这个Request来自于
     <code>
      GoReplay
     </code>
     。 我们举出一下例子来进行说明:
    </p>
    <ol>
     <li>
      <code>
       --http-rewrite-url "/v1/user/([^\\/]+)/ping:/v2/user/$1/ping"
      </code>
      这个采用的是官方文档的案例，表示将
      <code>
       /v1/user/([^\\/]+)/ping
      </code>
      替换为
      <code>
       /v2/user/$1/ping
      </code>
      。不过经过本人测试
      <code>
       1.3.3
      </code>
      的版本替换
      <code>
       $1
      </code>
      有问题。
     </li>
     <li>
      <code>
       --http-set-param "isTest=1"
      </code>
      设置参数
      <code>
       isTest
      </code>
      为
      <code>
       1
      </code>
      , 如果没有则增加这个参数，如果已经有，则修改这个参数。
     </li>
     <li>
      <code>
       --http-set-header "User-Agent: tester agent"
      </code>
      修改或者增加一个HTTP Header
     </li>
     <li>
      <code>
       --http-rewrite-header "Host: (.*):9797,$1:9898"
      </code>
      比如原先的HTTP Header为
      <code>
       Host: xxx:9797
      </code>
      修改后变成
      <code>
       Host: xxx:9898
      </code>
     </li>
    </ol>
    <pre><code>sudo ./gor --input-raw :9797 --output-file test.gor --http-rewrite-url "/v1/user/([^\\/]+)/ping:/v2/user/$1/ping" --http-set-param "isTest=1" --http-set-header "XGoReplay: 1" --http-set-header "User-Agent: tester agent" --http-rewrite-header "Host: (.*):9797,$1:9898"
</code></pre>
    <p>
     这些都是通过
     <code>
      GoReplay
     </code>
     的命令行参数去进行一些基本的更改HTTP请求的方法。需要更强的重写功能，那必须借助
     <code>
      GoReplay
     </code>
     的
     <code>
      Middlware
     </code>
     ，支持使用者编写插件去处理，除此之外插件功能也可以根据
     <code>
      原始流量的响应结果
     </code>
     和
     <code>
      测试响应结果
     </code>
     来实现的结果对比。
    </p>
    <h2>
     <a id="_91">
     </a>
     总结
    </h2>
    <p>
     <code>
      GoReplay
     </code>
     可以协助我们利用已有的流量进行部分的功能测试，稳定性测试，以及性能测试等等。但是在使用的过程中，一定要注意不要对线上的数据造成影响，并且操作不要侵犯
     <code>
      隐私保护法律
     </code>
     ，遵循公司的操作规范。
     <br/>
     对于
     <code>
      GoReplay
     </code>
     的进阶部分
     <code>
      Middleware
     </code>
     去编写自己的插件，实现Rewrite和直接的测试结果对比功能，将在后续文章进行阐述。
    </p>
    <h2>
     <a id="_95">
     </a>
     参考
    </h2>
    <p>
     <a href="https://github.com/buger/goreplay/wiki">
      GoRepay Wiki
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f434a465f6963654b696e672f:61727469636c652f64657461696c732f313231343336303933" class_="artid" style="display:none">
 </p>
</div>


