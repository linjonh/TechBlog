---
layout: post
title: "hdu1667-IDA-迭代加深搜索-A算法"
date: 2024-12-10 11:47:43 +0800
description: "迭代加深搜索迭代加深搜索，实质上是限定下界的深度优先搜索。即首先允许深度优先搜索K层，若没有发现可行"
keywords: "a*算法的改进迭代加深a*搜索"
categories: ['迭代加深搜索', 'Hdu', 'Dfs', 'Acm', 'A']
tags: ['迭代', '算法', '搜索', 'Dfs']
artid: "72329464"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=72329464
    alt: "hdu1667-IDA-迭代加深搜索-A算法"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     hdu1667-IDA*-迭代加深搜索 A*算法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2 id="迭代加深搜索">
     迭代加深搜索
    </h2>
    <p>
     <strong>
      迭代加深搜索
     </strong>
     ，实质上是限定下界的深度优先搜索。即首先允许深度优先搜索K层，若没有发现可行解，再将K+1后重复以上步骤搜索（即深度优先搜索k+1层），直到搜索到可行解。
    </p>
    <p>
     在迭代加深搜索的算法中，连续的深度优先搜索被引入，每一个深度约束逐次加1，直到搜索到目标为止。可以看出，很多情况会重复搜索。但是它的好处在于：
    </p>
    <ol>
     <li>
      空间开销小。每个深度下实际上是一个有深度限制的深度优先搜索。而DFS的空间消耗小是众所周知的。
     </li>
     <li>
      利于深度剪枝。
     </li>
     <li>
      时间效率不低。虽然重复搜索，但是整体并不比广度有限搜索慢很多。
     </li>
    </ol>
    <p>
     我们可以看出，迭代加深搜索算法就是仿广度优先搜索的深度优先搜索。既能满足深度优先搜索的线性存储要求，又能保证发现一个最小深度的目标结点。
    </p>
    <p>
     从实际应用来看，迭代加深搜索的效果比较好，并不比广度优先搜索慢很多，但是空间复杂度却与深度优先搜索相同，比广度优先搜索小很多。
    </p>
    <p>
     使用搜索算法的时候，选择正确的搜索方式很重要。当有一类问题需要做广度优先搜索，但却没有足够的空间，而时间却很充裕，碰到这类问题，我们可以选择迭代加深搜索算法。
    </p>
    <p>
     一般来说，如果目标结点离根结点远，需要遍历整棵树，可以考虑使用深度优先搜索；如果目标离根结点近，或求最小步数，则考虑广度优先搜索或迭代加深搜索；若广度优先搜索存在空间不够的问题，则考虑使用迭代加深搜索。
    </p>
    <h2 id="a">
     A*
    </h2>
    <p>
     <strong>
      A*
     </strong>
     算法我现在也不是很懂，就不说了，免得误导大家。可以自己google一下，有点了解后就可以看这题了。感觉这题是迭代加深搜索的模板题，只不过用了一点A*的思想。
    </p>
    <h2 id="hdu1667">
     HDU1667
    </h2>
    <p>
     上面的看一遍没看懂没关系，先看看题目，把代码看懂了再看上面的解释就好懂了。
     <br/>
     我搜这一题的博客搜了好多，基本都没有详细一点的讲解，直接贴的代码。不过后来发现一个博客讲的很好，还好看到他的博客，不然真没学到什么。自觉这个博客已经讲的很详细很好了，我就直接转载了。
     <br/>
     转载自：
     <a href="https://lo-li.net/1363.html#comment-737" rel="nofollow noopener noreferrer" target="_blank">
      https://lo-li.net/1363.html#comment-737
     </a>
    </p>
    <p>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5a2726535b3eca12d8fe337390228563.jpeg" title=""/>
    </p>
    <h3 id="问题描述">
     问题描述
    </h3>
    <p>
     现有一块有24个格子的井字板子，每个格子用1、2或3标记，每种格子各有8个。
     <br/>
     起初这些格子分布随机，你需要通过A-H 8种操作将中心8个格子作变为相同的标记。（图中使用A操作将A列向上拉了一格，C操作将C列向右拉了一列，中心变为2）
    </p>
    <h3 id="输入">
     输入
    </h3>
    <p>
     有多组数据(≤30)，每组数据包含一行24个数字，代表从左上到右下24个格子的初始状态。输入0代表结束。
    </p>
    <h3 id="输出">
     输出
    </h3>
    <p>
     每组数据包含两行，第一行是最佳的操作顺序，第二行是此时中心的字符。若不需要操作，即初始时中心八个字符就相同，则输出No moves needed。（也要输出中心字符）
     <br/>
     最佳操作顺序为：操作次数最少，同次数若有多种则为字典序小者
    </p>
    <p>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0c19687500661cfa49eccdf583d7c163.png" title="">
      <br/>
      将板子如上图编号存下来，操作A-H编号为0-7
     </img>
    </p>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> center[] = {<!-- --><span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>};  <span class="hljs-comment">//中心8个点坐标</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> reverseop[] = {<!-- --><span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>};  <span class="hljs-comment">//每种操作的逆操作</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> index[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>] = {  <span class="hljs-comment">//从A-H操作变动的下标</span>
    { <span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span> },    <span class="hljs-comment">//A</span>
    { <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span> },    <span class="hljs-comment">//B</span>
    { <span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span> },       <span class="hljs-comment">//C</span>
    { <span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">17</span>,<span class="hljs-number">16</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">13</span> }, <span class="hljs-comment">//D</span>
    { <span class="hljs-number">23</span>,<span class="hljs-number">21</span>,<span class="hljs-number">17</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> },    <span class="hljs-comment">//E</span>
    { <span class="hljs-number">22</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span> },    <span class="hljs-comment">//F </span>
    { <span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span> }, <span class="hljs-comment">//G</span>
    { <span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> },       <span class="hljs-comment">//H</span>
};
<span class="hljs-keyword">int</span> mp[<span class="hljs-number">24</span>];
<span class="hljs-keyword">char</span> finop[<span class="hljs-number">105</span>];  <span class="hljs-comment">//搜到目标的操作序列</span>
<span class="hljs-keyword">bool</span> flag;  <span class="hljs-comment">//是否搜到目标</span></code></pre>
    <p>
     执行某一个操作只需将那一列/行每格顺序往后挪
    </p>
    <pre class="prettyprint"><code class="hljs axapta"><span class="hljs-keyword">void</span> option(<span class="hljs-keyword">int</span> op)
{
    <span class="hljs-keyword">int</span> tmp=mp[<span class="hljs-keyword">index</span>[op][<span class="hljs-number">0</span>]];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)
    {
        mp[<span class="hljs-keyword">index</span>[op][i]] = mp[<span class="hljs-keyword">index</span>[op][i+<span class="hljs-number">1</span>]];
    }
    mp[<span class="hljs-keyword">index</span>[op][<span class="hljs-number">6</span>]]=tmp;
}</code></pre>
    <p>
     估值函数，找出当前局面下使得中心点变成1、2和3所需的最小步数。因为总共就3个数，一次任何一种操作只会改变中间一种数字的数量，用8减去数量最多那个数字的个数即为最小步数。
    </p>
    <pre class="prettyprint"><code class="hljs glsl"><span class="hljs-keyword">int</span> get_h()
{
    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">3</span>]={<!-- --><span class="hljs-number">0</span>};
    <span class="hljs-keyword">int</span> num=-<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)
    {
        cnt[mp[center[i]]-<span class="hljs-number">1</span>]++;
        num = <span class="hljs-built_in">max</span>(num,cnt[mp[center[i]]-<span class="hljs-number">1</span>]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>-num;
}</code></pre>
    <p>
     搜索
    </p>
    <p>
     迭代加深：保证第一次搜到的解是最短的
    </p>
    <p>
     从A操作到H操作搜，保证字典序最小
    </p>
    <p>
     可行性剪枝：当前深度（已操作的次数）+估价函数值= （至少还需要的步数）若大于当前规定的最大深度（最多步数）则剪枝
    </p>
    <p>
     相邻操作不为互逆操作
    </p>
    <pre class="prettyprint"><code class="hljs rsl">void dfs(int <span class="hljs-built_in">depth</span>,int lastop,int maxdepth)  <span class="hljs-comment">//depth当前深度 lastop上一次的操作 maxdepth每次迭代加深搜索的最大深度</span>
{
    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">depth</span>&gt;maxdepth || <span class="hljs-built_in">depth</span>+get_h()&gt;maxdepth) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//可行性剪枝</span>
    <span class="hljs-keyword">if</span>(get_h()==<span class="hljs-number">0</span>)  <span class="hljs-comment">//中心相同了</span>
    {
        flag=true;
        finop[<span class="hljs-built_in">depth</span>]=<span class="hljs-string">'\0'</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n%d\n"</span>,finop,mp[center[<span class="hljs-number">0</span>]]);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span>(int nextop=<span class="hljs-number">0</span>;nextop&lt;<span class="hljs-number">8</span>;nextop++)  <span class="hljs-comment">//从A开始搜索</span>
    {
        <span class="hljs-keyword">if</span>(nextop!=reverseop[lastop])  <span class="hljs-comment">//与上一次操作不互逆</span>
        {
            <span class="hljs-built_in">option</span>(nextop);
            finop[<span class="hljs-built_in">depth</span>]=nextop+<span class="hljs-string">'A'</span>;
            dfs(<span class="hljs-built_in">depth</span>+<span class="hljs-number">1</span>,nextop,maxdepth);
            <span class="hljs-built_in">option</span>(reverseop[nextop]);  <span class="hljs-comment">//回溯还原</span>
        }
    }
}

int main()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">24</span>;i++)
        {
            scanf(<span class="hljs-string">"%d"</span>,&amp;mp[i]);
            <span class="hljs-keyword">if</span>(mp[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span>(get_h()==<span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No moves needed\n%d\n"</span>, mp[center[<span class="hljs-number">0</span>]]);
            <span class="hljs-keyword">continue</span>;
        }
        flag=false;
        <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">depth</span>=<span class="hljs-number">1</span>;!flag;<span class="hljs-built_in">depth</span>++) <span class="hljs-comment">//迭代加深</span>
        {
            dfs(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-built_in">depth</span>);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    <h4 id="完整代码">
     完整代码
    </h4>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> center[] = {<!-- --><span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>};  <span class="hljs-comment">//中心8个点坐标</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> reverseop[] = {<!-- --><span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>};  <span class="hljs-comment">//每种操作的逆操作</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> index[<span class="hljs-number">8</span>][<span class="hljs-number">7</span>] = {  <span class="hljs-comment">//从A-H操作变动的下标</span>
    { <span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span> },    <span class="hljs-comment">//A</span>
    { <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span> },    <span class="hljs-comment">//B</span>
    { <span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span> },       <span class="hljs-comment">//C</span>
    { <span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">17</span>,<span class="hljs-number">16</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">13</span> }, <span class="hljs-comment">//D</span>
    { <span class="hljs-number">23</span>,<span class="hljs-number">21</span>,<span class="hljs-number">17</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> },    <span class="hljs-comment">//E</span>
    { <span class="hljs-number">22</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span> },    <span class="hljs-comment">//F </span>
    { <span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span> }, <span class="hljs-comment">//G</span>
    { <span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> },       <span class="hljs-comment">//H</span>
};
<span class="hljs-keyword">int</span> mp[<span class="hljs-number">24</span>];
<span class="hljs-keyword">char</span> finop[<span class="hljs-number">105</span>];  <span class="hljs-comment">//搜到目标的操作序列</span>
<span class="hljs-keyword">bool</span> flag;  <span class="hljs-comment">//是否搜到目标</span>

<span class="hljs-keyword">int</span> get_h()
{
    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">3</span>]={<!-- --><span class="hljs-number">0</span>};
    <span class="hljs-keyword">int</span> num=-<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)
    {
        cnt[mp[center[i]]-<span class="hljs-number">1</span>]++;
        num = max(num,cnt[mp[center[i]]-<span class="hljs-number">1</span>]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>-num;
}

<span class="hljs-keyword">void</span> option(<span class="hljs-keyword">int</span> op)
{
    <span class="hljs-keyword">int</span> tmp=mp[index[op][<span class="hljs-number">0</span>]];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)
    {
        mp[index[op][i]] = mp[index[op][i+<span class="hljs-number">1</span>]];
    }
    mp[index[op][<span class="hljs-number">6</span>]]=tmp;
}

<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> depth,<span class="hljs-keyword">int</span> lastop,<span class="hljs-keyword">int</span> maxdepth)  <span class="hljs-comment">//depth当前深度 lastop上一次的操作 maxdepth每次迭代加深搜索的最大深度</span>
{
    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(depth&gt;maxdepth || depth+get_h()&gt;maxdepth) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//可行性剪枝</span>
    <span class="hljs-keyword">if</span>(get_h()==<span class="hljs-number">0</span>)  <span class="hljs-comment">//中心相同了</span>
    {
        flag=<span class="hljs-keyword">true</span>;
        finop[depth]=<span class="hljs-string">'\0'</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n%d\n"</span>,finop,mp[center[<span class="hljs-number">0</span>]]);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextop=<span class="hljs-number">0</span>;nextop&lt;<span class="hljs-number">8</span>;nextop++)  <span class="hljs-comment">//从A开始搜索</span>
    {
        <span class="hljs-keyword">if</span>(nextop!=reverseop[lastop])  <span class="hljs-comment">//与上一次操作不互逆</span>
        {
            option(nextop);
            finop[depth]=nextop+<span class="hljs-string">'A'</span>;
            dfs(depth+<span class="hljs-number">1</span>,nextop,maxdepth);
            option(reverseop[nextop]);  <span class="hljs-comment">//回溯还原</span>
        }
    }
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">24</span>;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;mp[i]);
            <span class="hljs-keyword">if</span>(mp[i]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span>(get_h()==<span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No moves needed\n%d\n"</span>, mp[center[<span class="hljs-number">0</span>]]);
            <span class="hljs-keyword">continue</span>;
        }
        flag=<span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> depth=<span class="hljs-number">1</span>;!flag;depth++) <span class="hljs-comment">//迭代加深</span>
        {
            dfs(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,depth);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f57696c6c69616d53756e30313232:2f61727469636c652f64657461696c732f3732333239343634" class_="artid" style="display:none">
 </p>
</div>


