---
layout: post
title: "操作系统初始化"
date: 2024-12-06 11:32:28 +0800
description: "操作系统初始化_操作系统初始化"
keywords: "操作系统初始化"
categories: ['计算机基础知识']
tags: ['Linux']
artid: "127557381"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=127557381
    alt: "操作系统初始化"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统初始化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      BIOS: 创业指导手册
     </strong>
    </p>
    <p>
     在主板上，
     <strong>
      ROM
     </strong>
     (read only memory只读存储器）， 上面固化了一些初始化程序，就是
     <strong>
      BIOS
     </strong>
     (Basic input output system)基本输入输出系统。
    </p>
    <p class="img-center">
     <img alt="" height="257" src="https://i-blog.csdnimg.cn/blog_migrate/9dc93e90cd005f56dd619ef76375cdf7.jpeg" width="403"/>
    </p>
    <p>
     在 x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM，也就是说，到这部分地址访问的时候，会访问
     <strong>
      ROM
     </strong>
     。当电脑刚加电的时候，会做一些重置的工作，将 CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以
     <strong>
      第一条指令就会指向 0xFFFF0，正是在 ROM 的范围内
     </strong>
     。在这里，有一个 JMP 命令会跳到 ROM 中做初始化工作的代码，于是，BIOS 开始进行初始化的工作。
    </p>
    <p>
    </p>
    <p>
     <strong>
      引导扇区：门卫 boot.img
     </strong>
    </p>
    <p>
     操作系统一般都会在安装在硬盘上，在 BIOS 的界面上。你会看到一个启动盘的选项。启动盘有一般在第一个扇区，占
     <strong>
      512 字节
     </strong>
     ，而且以 0xAA55 结束。这是一个约定，当满足这个条件的时候，就说明这是一个启动盘，在 512 字节以内会启动相关的代码。
    </p>
    <p>
     grub2 第一个要安装的就是
     <strong>
      boot.img
     </strong>
     。它由 boot.S 编译而成，一共 512 字节，正式安装到启动盘的第一个扇区。这个扇区通常称为 MBR（Master Boot Record，主引导记录 / 扇区）。BIOS 完成任务后，会
     <strong>
      将 boot.img 从硬盘加载到内存中的 0x7c00 来运行
     </strong>
     。由于 512 个字节实在有限，boot.img 做不了太多的事情。它能做的最重要的一个事情就是加载 grub2 的另一个镜像 core.img。
    </p>
    <p>
     由于 512 个字节实在有限，boot.img 做不了太多的事情。它能做的最重要的一个事情就是加载 grub2 的另一个镜像 core.img。
    </p>
    <p>
     <strong>
      管理处：core.img
     </strong>
    </p>
    <p>
     core.img 由 lzma_decompress.img、diskboot.img、kernel.img 和一系列的模块组成.
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/2dc1b62c86c6cbb8b1842b497aba9f45.jpeg"/>
    </p>
    <p>
     我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这 1M 的地址空间实在放不下了，所以在真正的解压缩之前，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，
     <strong>
      切换到保护模式
     </strong>
     ，这样就能在更大的寻址空间里面，加载更多的东西。
    </p>
    <p>
     <strong>
      从实模式切换到保护模式
     </strong>
    </p>
    <p>
     第一项是启用
     <strong>
      分段
     </strong>
     ，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现
     <strong>
      不同进程
     </strong>
     的切换了。
    </p>
    <p>
     第二项是启动
     <strong>
      分页
     </strong>
     。能够管理的内存变大了，就需要将
     <strong>
      内存
     </strong>
     分成相等大小的块，这些我们放到内存那一节详细再讲。
    </p>
    <p>
    </p>
    <p>
     grub2 是一个非常牛的 Linux 启动管理器
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f4368756e79696e6732372f:61727469636c652f64657461696c732f313237353537333831" class_="artid" style="display:none">
 </p>
</div>


