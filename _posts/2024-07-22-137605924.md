---
layout: post
title: "微信小程序部分面试题汇总15道"
date: 2024-07-22 15:35:41 +0800
description: "小程序提供了读写本地数据缓存的接口，通过 wx.getStora"
keywords: "微信小程序面试题"
categories: ["未分类"]
tags: ["微信小程序", "小程序", "Notepad"]
artid: "137605924"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=137605924
  alt: "微信小程序部分面试题汇总15道"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微信小程序部分面试题汇总15道
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      1.小程序中如何进行接口请求？会不会跨域，为什么
     </strong>
     <br/>
     微信小程序有自带的api接口，wx.request();
     <br/>
     不会跨域，因为微信小程序不是浏览器，没有同源策略的约束；
    </p>
    <p>
     wx.request({
     <!-- -->
     <br/>
     url: 'https://xxxxxxx.com/api',
     <br/>
     method: "POST",
     <br/>
     data: {
     <!-- -->
     <br/>
     pageNum: 1,
     <br/>
     pageSize: 10
     <br/>
     },
     <br/>
     header: {
     <!-- -->
     <br/>
     "content-type": "application/x-www-form-urlencoded"
     <br/>
     },
     <br/>
     success: res =&gt; {
     <!-- -->
     <br/>
     console.log(res)
     <br/>
     }
     <br/>
     })
     <br/>
     <br/>
     <strong>
      2.小程序的常用命令有哪些
     </strong>
     <br/>
     引用数据 {
     <!-- -->
     {}}
     <br/>
     逻辑渲染 wx:if wx:elif wx:else hidden
     <br/>
     列表渲染 wx:for wx:for-item wx:for-index wx:key，使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前下标的变量名。
    </p>
    <p>
     &lt;view wx:for="{
     <!-- -->
     {array}}" wx:for-index="idx" wx:for-item="itemName"&gt;&lt;/view&gt;
     <br/>
     <br/>
     驱动视图 this.setData({})
     <br/>
     事件绑定 bind
    </p>
    <p>
     <strong>
      3.你认为微信小程序的优点是什么，缺点是什么
     </strong>
     <br/>
     优点：①容易推广。在微信中，小程序拥有众多入口，且微信用户基数大，这些都有助于推广小程序；②使用便捷。微信下拉即可打开小程序列表，点击即可使用小程序，不需要额外的安装操作等；③体验良好。小程序不会像H5页面一样经常出现卡顿、延时、加载慢、权限不足等问题；④成本更低，从开发成本到运营推广成本，小程序的花费仅为APP的十分之一。
    </p>
    <p>
     缺点：①单个包大小限制为2M，这导致无法开发大型的应用，采用分包最大是20M；②需要像app一样审核上架，这点相对于H5的发布要麻烦一些；③处处受微信限制。例如不能直接分享到朋友圈，涉及到积分，或者虚拟交易的时候，小程序也是不允许的。
    </p>
    <p>
     <strong>
      4.微信小程序中的js和浏览器中的js以及node中的js的区别
     </strong>
     <br/>
     👉这篇文章有更详细的解释
    </p>
    <p>
     浏览器中的JS：ES，DOM，BOM
    </p>
    <p>
     ES: ECMAScript、 DOM : 文档对象模型、 BOM : 浏览器对象模型;
    </p>
    <p>
     Node 中的JS：ES，NPM，Native
    </p>
    <p>
     Native就是原生的模块，通过这个模块来使用JavaScript语言本身不具有的一些能力（来自百度：native方法简单的讲，即Java调用非Java代码的接口）。
    </p>
    <p>
     NPM是包管理系统、NPM是目前最大的开原库生态系统，通过各种NPM扩展包快速的实践一些功能。
    </p>
    <p>
     <img alt="" height="201" src="https://i-blog.csdnimg.cn/blog_migrate/6d9523a0a59a32020aa9b838d56b5ea4.png" width="752">
      <br/>
      小程序中的JS：ES、小程序框架，小程序API
     </img>
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/blog_migrate/331196c9622e15cf0dd37d70c8c743d2.png" width="752">
      <br/>
      直观的说小程序中没有DOM和BOM对象，也无法对npm包进行管理
     </img>
    </p>
    <p>
     <strong>
      5.微信小程序中的数据渲染与浏览器中有什么不同
     </strong>
     <br/>
     浏览器中渲染是单线程的;
    </p>
    <p>
     而在小程序中的运行环境分成渲染层和逻辑层， WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。
    </p>
    <p>
     <strong>
      6.简述一下微信小程序中通讯模型
     </strong>
     <br/>
     小程序的渲染层和逻辑层分别由2个线程管理：
    </p>
    <p>
     渲染层的界面使用了WebView 进行渲染；
    </p>
    <p>
     逻辑层采用JsCore线程运行JS脚本。
    </p>
    <p>
     一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（Native）做中转。
    </p>
    <p>
     逻辑层发送网络请求也经由Native转发。
    </p>
    <p>
     <img alt="" height="642" src="https://i-blog.csdnimg.cn/blog_migrate/646a7f8550680a6d1edf3d8ce8ecfacd.png" width="922">
      <br/>
      <strong>
       7.谈谈你对微信小程序中生命周期函数的理解
      </strong>
      <br/>
      小程序中的生命周期函数，分为 应用生命周期函数 和 页面生命周期函数 ；
     </img>
    </p>
    <p>
     应用生命周期函数有：
    </p>
    <p>
     <img alt="" height="260" src="https://i-blog.csdnimg.cn/blog_migrate/0eaba5482628a4b96feb86eaf2be0cc9.png" width="830"/>
    </p>
    <p>
     onLaunch 函数的参数也可以使用 wx.getLaunchOptionsSync 获取；
     <br/>
     onShow 也可以使用 wx.onAppShow 绑定监听；
     <br/>
     onHide 也可以使用 wx.onAppHide 绑定监听；
    </p>
    <p>
     App.js是小程序入口文件，所以在App.js中调用应用生命周期函数：
    </p>
    <p>
     App({
     <!-- -->
     <br/>
     // 小程序初始化完成时，执行此函数，可以做一些初始化的工作
     <br/>
     onLaunch: function( options ){}
     <br/>
     // 小程序显示到屏幕上的时候，执行此函数
     <br/>
     onShow: function( options ){}
     <br/>
     // 小程序被最小化的时候，执行此函数
     <br/>
     onHide: function(){}
     <br/>
     })
     <br/>
     <br/>
     还有一个不太常用，但还是挺有作用的应用生命周期函数：onError(String error) ，在小程序发生脚本错误或 API 调用报错时触发。也可以使用 wx.onError 绑定监听。
    </p>
    <p>
     还有其他不常用的应用生命周期函数，可以参考：
     <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object" rel="nofollow" title="官方文档">
      官方文档
     </a>
    </p>
    <p>
     <img alt="" height="395" src="https://i-blog.csdnimg.cn/blog_migrate/d31d488bcc6a48f066951b4908dab25a.png" width="906"/>
    </p>
    <p>
     页面生命周期函数有：
    </p>
    <p>
     onLoad函数有一个参数：onLoad(Object query)
    </p>
    <p>
     <img alt="" height="286" src="https://i-blog.csdnimg.cn/blog_migrate/5c0284a0263c220f103ca5517b7fd0c1.png" width="755"/>
    </p>
    <p>
     还有其他比较常用的，如下图红框内容：
    </p>
    <p>
     <img alt="" height="699" src="https://i-blog.csdnimg.cn/blog_migrate/339a7afb87dfae53af52c863c2ce587a.png" width="938"/>
    </p>
    <p>
     <strong>
      8.微信小程序中如何进行事件的定义，传参
     </strong>
     <br/>
     小程序中使用bind关键字绑定事件，但小程序中不能在绑定事件的同时为事件处理函数传递参数，可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字。
    </p>
    <p>
     &lt;button bindtap="tapTap" data-param="{
     <!-- -->
     {"事件传参"}}"&gt;事件传参&lt;/button&gt;
     <br/>
     1
     <br/>
     接收传递到的参数：
    </p>
    <p>
     tapTap(e){
     <!-- -->
     <br/>
     console.log(e.currentTarget.dataset.param)
     <br/>
     // 打印结果为：事件传参
     <br/>
     }
     <br/>
     <br/>
     <strong>
      9.wxss和css有什么区别
     </strong>
     <br/>
     WXSS和CSS类似，不过在CSS的基础上做了一些补充和修改。
    </p>
    <p>
     wxss尺寸单位rpx的引入，来提升不同屏幕的适配体验，750rpx = 375px；
     <br/>
     提供了全局的样式和局部样式
     <br/>
     项目根目录中的 app.wxss 会作用于所有小程序页面
     <br/>
     局部页面的 .wxss 样式仅对当前页面生效
     <br/>
     wxss仅支持部分css选择器
     <br/>
     .class和#id
     <br/>
     element
     <br/>
     并集选择器 后代选择器
     <br/>
     ::after ::before等伪类选择器
     <br/>
     外联样式导入不同，wxss 使用@import标识符来导入外联样式。
     <br/>
     <strong>
      10.小程序如何进行页面的跳转传参以及接收数据
     </strong>
     <br/>
     最常用的两个页面的跳转和传参方式：①wx.navigateTo ②navigator标签
    </p>
    <p>
     wx.navigateTo({
     <!-- -->
     <br/>
     url: `/pages/details?id=${xxx}`
     <br/>
     });
     <br/>
     <br/>
     &lt;navigator url="/page/navigate/navigate?title=navigate" hover-class="navigator-hover"&gt;跳转到新页面&lt;/navigator&gt;
     <br/>
     <br/>
     跳转页接收参数：
    </p>
    <p>
     onLoad (options) {
     <!-- -->
     <br/>
     console.log(options)
     <br/>
     this.setData({
     <!-- -->
     <br/>
     goodsId:options.id,
     <br/>
     goodsName:options.name
     <br/>
     })
     <br/>
     }
     <br/>
     其他方式：
    </p>
    <p>
     wx.switchTab() 用来 跳转至tabBar页面，并关闭其他所有非 tabBar 页面
    </p>
    <p>
     wx.redirectTo() 和 wx.navigateTo() 一样，都 跳转至非tabBar页面，但会关闭当前页面
    </p>
    <p>
     wx.reLaunch() 也是 跳转至非tabBar页面，并且会关闭其他所有页面
    </p>
    <p>
     wx.navigateBack() 用来返回上一页面或多级页面，并关闭当前页面。
    </p>
    <p>
     wx.navigateBack({
     <!-- -->
     <br/>
     delta: 2 //返回的页面数，1为返回上一页，如果delta大于现有页面数，则返回到首页。
     <br/>
     })
     <br/>
     <br/>
     <strong>
      11.小程序如何进行本地存储？
     </strong>
     <br/>
     小程序提供了读写本地数据缓存的接口，通过 wx.getStorage/wx.getStorageSync读取本地缓存，通过 wx.setStorage/wx.setStorageSync写数据到缓存，其中带Sync后缀的接口表示是同步接口
    </p>
    <p>
     // 同步存储
     <br/>
     wx.setStorageSync('key', 'value')
     <br/>
     // 异步存储，并且开启加密存储
     <br/>
     wx.setStorage({
     <!-- -->
     <br/>
     key: "key",
     <br/>
     data: "value",
     <br/>
     encrypt: true, // 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true
     <br/>
     success() {
     <!-- -->
     <br/>
     wx.getStorage({
     <!-- -->
     <br/>
     key: "key",
     <br/>
     encrypt: true, // 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true
     <br/>
     success(res) {
     <!-- -->
     <br/>
     console.log(res.data)
     <br/>
     }
     <br/>
     })
     <br/>
     }
     <br/>
     })
     <br/>
     // 同步读取缓存
     <br/>
     var value = wx.getStorageSync('key')
     <br/>
     // 异步读取缓存
     <br/>
     wx.getStorage({
     <!-- -->
     <br/>
     key: 'key',
     <br/>
     success (res) {
     <!-- -->
     <br/>
     console.log(res.data)
     <br/>
     }
     <br/>
     })
     <br/>
     小程序宿主环境会管理不同小程序的数据缓存，不同小程序的本地缓存空间是分开的，每个小程序的缓存空间上限为10MB，如果当前缓存已经达到10MB，再通过wx.setStorage写入缓存会触发fail回调。
    </p>
    <p>
     小程序的本地缓存不仅仅通过小程序这个维度来隔离空间，考虑到同一个设备可以登录不同微信用户，宿主环境还对不同用户的缓存进行了隔离，避免用户间的数据隐私泄露。
    </p>
    <p>
     由于本地缓存是存放在当前设备，用户换设备之后无法从另一个设备读取到当前设备数据，因此用户的关键信息不建议只存在本地缓存，应该把数据放到服务器端进行持久化存储。
    </p>
    <p>
     <strong>
      12.谈谈你对微信小程序请求封装的理解
     </strong>
     <br/>
     在小程序开发过程中,我们可能会进行许多的网络请求,如果每次请求都去写一遍 request 代码：
    </p>
    <p>
     wx.request({
     <!-- -->
     <br/>
     url: 'xxx',
     <br/>
     data: {
     <!-- -->
     <br/>
     a: '',
     <br/>
     b: ''
     <br/>
     },
     <br/>
     header: {
     <!-- -->
     <br/>
     'content-type': 'application/json' // 默认值
     <br/>
     },
     <br/>
     success(res) {
     <!-- -->
     <br/>
     console.log(res.data)
     <br/>
     },
     <br/>
     fail(err){
     <!-- -->
     <br/>
     console.log(err)
     <br/>
     }
     <br/>
     })
    </p>
    <p>
     <br/>
     效率低下且不便于维护，所以封装一下 wx.request 接口还是有必要的。
     <br/>
     通常以返回 promise 对象的形式进行请求的封装：
    </p>
    <p>
     const baseUrl = "123456.com"
     <br/>
     function request(method, url, dataObj) {
     <!-- -->
     <br/>
     return new Promise(function(resolve, reject) {
     <!-- -->
     <br/>
     let header = {
     <!-- -->
     <br/>
     'content-type': 'application/json',
     <br/>
     };
     <br/>
     wx.request({
     <!-- -->
     <br/>
     url: baseURL + url,
     <br/>
     method: method,
     <br/>
     data: dataObj.data,
     <br/>
     header: dataObj.header||header,
     <br/>
     success(res) {
     <!-- -->
     <br/>
     //请求成功
     <br/>
     if (res.code == 0) {
     <!-- -->
     <br/>
     resolve(res);
     <br/>
     } else {
     <!-- -->
     <br/>
     //其他异常
     <br/>
     reject('运行时错误,请稍后再试');
     <br/>
     }
     <br/>
     },
     <br/>
     fail(err) {
     <!-- -->
     <br/>
     //请求失败
     <br/>
     reject(err)
     <br/>
     }
     <br/>
     })
     <br/>
     })
     <br/>
     }
    </p>
    <p>
     <br/>
     封装之后代码统一管理，方便维护，节省时间，提高了工作效率！
    </p>
    <p>
     <strong>
      13.小程序如何实现数据驱动视图
     </strong>
     <br/>
     微信小程序中使用 setData 函数把变量渲染到视图层
    </p>
    <p>
     注意：
    </p>
    <p>
     直接修改this.data，而不调用this.setData()，是无法改变当前页面的状态的，会导致数据不一致
     <br/>
     仅支持可以JSON化的数据
     <br/>
     单次设置的数据不能超过1024KB，尽量避免一次设置过多的数据
     <br/>
     不要把data中的任何一项的value设为undefined，否则这一项将不能被设置，可能会有潜在的问题
     <br/>
     示例：
    </p>
    <p>
     Page({
     <!-- -->
     <br/>
     data: {
     <!-- -->
     <br/>
     testOne: 1,
     <br/>
     testTwo: 2
     <br/>
     },
     <br/>
     onLoad: function() {},
     <br/>
     onShow () {
     <!-- -->
     <br/>
     this.setData({
     <!-- -->
     <br/>
     test02:8
     <br/>
     })
     <br/>
     console.log(this.data.testTwo)
     <br/>
     }
     <br/>
     },
     <br/>
     })
     <br/>
     <br/>
     <strong>
      14.对小程序中常见的开放能力API有什么了解
     </strong>
     <br/>
     获取网络状态（2G/3G/4G/5G/WIFI…）
    </p>
    <p>
     Page({
     <!-- -->
     <br/>
     // 点击“预览文档”的按钮，触发tap回调
     <br/>
     tap: function() {
     <!-- -->
     <br/>
     wx.getNetworkType({
     <!-- -->
     <br/>
     success: function(res) {
     <!-- -->
     <br/>
     // networkType字段的有效值：
     <br/>
     // wifi/2g/3g/4g/5g/unknown(Android下不常见的网络类型)/none(无网络)
     <br/>
     if (res.networkType == 'wifi') {
     <!-- -->
     <br/>
     // 从网络上下载文档
     <br/>
     wx.downloadFile({
     <!-- -->
     <br/>
     url:' https://lark-temp.oss-cn-hangzhou.aliyuncs.com/__temp/464110/docx/bb5d8e7d-97bc-406b-be94-ca2b4724c0e6.docx?OSSAccessKeyId=LTAI4GKnqTWmz2X8mzA1Sjbv&amp;Expires=1644944885&amp;Signature=qUYOtNWZOaopjkEFbcKpvgmn%2B1U%3D',
     <br/>
     success: function (res) {
     <!-- -->
     <br/>
     // 下载成功之后进行预览文档
     <br/>
     wx.openDocument({
     <!-- -->
     <br/>
     filePath: res.tempFilePath
     <br/>
     })
     <br/>
     }
     <br/>
     })
     <br/>
     } else {
     <!-- -->
     <br/>
     wx.showToast({ title: '当前为非Wifi环境' })
     <br/>
     }
     <br/>
     }
     <br/>
     })
     <br/>
     }
     <br/>
     })
    </p>
    <p>
     <br/>
     扫码能力
    </p>
    <p>
     Page({
     <!-- -->
     <br/>
     // 点击“扫码订餐”的按钮，触发tapScan回调
     <br/>
     tapScan: function() {
     <!-- -->
     <br/>
     // 调用wx.login获取微信登录凭证
     <br/>
     wx.scanCode({
     <!-- -->
     <br/>
     success: function(res) {
     <!-- -->
     <br/>
     var num = res.result // 获取到的num就是餐桌的编号
     <br/>
     }
     <br/>
     })
     <br/>
     }
     <br/>
     })
     <br/>
     <br/>
     分享能力（分享到朋友圈或个人聊天等）
    </p>
    <p>
     Page({
     <br/>
     onShareAppMessage(){
     <br/>
     // 我们要记录转发的记录
     <br/>
     return {
     <br/>
     // 分享的标题
     <br/>
     title:'网友热议',
     <br/>
     // 分享的封面， 默认为当前页面的截图
     <br/>
     imageUrl:"/assets/icon/index.png",
     <br/>
     // 点击分享跳转的路径，默认是当前路径，也可以自定义配置，添加额外的跳转参数      path:"/pages/index/index?userId=10&amp;entry=share"
     <br/>
     }
     <br/>
     },  // 省略了别的属性  ...})
     <br/>
     <br/>
     wx.canIUse(string schema)
     <br/>
     判断小程序的API、回调、参数、组件等是否在当前版本可用
    </p>
    <p>
     wx.getSystemInfoSync() | wx.getSystemInfo()
     <br/>
     获取系统信息
    </p>
    <p>
     wx.getUserProfile(Object object)
     <br/>
     获取用户信息。页面产生点击事件（例如 button 上 bindtap 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo。该接口用于替换 wx.getUserInfo
    </p>
    <p>
     <strong>
      15.小程序的父子传参和vue中的有什么区别
     </strong>
     <br/>
     父传子的不同点是：微信小程序在子组件中接受父组件传 用 propertites 进行接收，而不是 props
    </p>
    <p>
     properties: {
     <!-- -->
     <br/>
     msg:{
     <!-- -->
     <br/>
     // type 要接收的数据的类型
     <br/>
     type:String,
     <br/>
     // value 默认值
     <br/>
     value:""
     <br/>
     },
     <br/>
     },
     <br/>
     <br/>
     子传父的不同点是：微信小程序在子组件中使用 triggerEvent 抛出自定义事件名，而不是 this.$emit()
    </p>
    <p>
     methods: {
     <!-- -->
     <br/>
     sendData() {
     <!-- -->
     <br/>
     console.log(this.data.msg)
     <br/>
     this.triggerEvent('eventName', '要传递的参数')
     <br/>
     }
     <br/>
     }
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333437303130322f:61727469636c652f64657461696c732f313337363035393234" class_="artid" style="display:none">
 </p>
</div>
