---
layout: post
title: "如何设计和生成游戏的激活码"
date: 2025-01-22 00:15:00 +0800
description: "游戏的激活码，也叫作奖励码，通常是由字符和数字组成的字符串，用于在游戏的推广阶段发放给玩家，玩家在下"
keywords: "c++生成游戏兑换码"
categories: ['C']
tags: ['激活码', '游戏', '奖励码', '兑换码', '位操作']
artid: "72771843"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=72771843
    alt: "如何设计和生成游戏的激活码"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     如何设计和生成游戏的激活码
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      游戏的激活码，也叫作奖励码、兑换码，通常是由字符和数字组成的字符串，用于在游戏的推广阶段发放给玩家，玩家在下载登录游戏之后兑换获得相应的奖励。
     </strong>
    </p>
    <p>
     <strong>
      首先设计我们激活码的规则
     </strong>
    </p>
    <ol>
     <li>
      字符 + 数字 组成 长度待定
     </li>
     <li>
      激活码分批次或者叫分组，即一个批次/一组激活码对应一个礼包
     </li>
     <li>
      同一批次/同一组的激活码兑换时有以下两种设计：
      <br/>
      <ul>
       <li>
        玩家可多次兑换
       </li>
       <li>
        玩家仅可兑换一次
       </li>
      </ul>
     </li>
     <li>
      激活码不区分大小写
     </li>
    </ol>
    <p>
     <strong>
      定义一个字符字典
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DICT_SIZE 32</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> AwardCodeDict[DICT_SIZE] = { <span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'H'</span>,<span class="hljs-string">'J'</span>,
                                        <span class="hljs-string">'K'</span>,<span class="hljs-string">'M'</span>,<span class="hljs-string">'N'</span>,<span class="hljs-string">'P'</span>,<span class="hljs-string">'Q'</span>,<span class="hljs-string">'R'</span>,<span class="hljs-string">'S'</span>,<span class="hljs-string">'T'</span>,<span class="hljs-string">'U'</span>,
                                        <span class="hljs-string">'V'</span>,<span class="hljs-string">'W'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'Y'</span>,<span class="hljs-string">'Z'</span>,
                                        <span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span> };</code></pre>
    <p>
     去掉辨识度比较低的字符 I 和 L， O 和 0
     <br/>
     <strong>
      ps：数字1也易混淆，但我们这里是没有去掉的
     </strong>
    </p>
    <p>
     <strong>
      如何去构造一个激活码
     </strong>
     <br/>
     首先我们要考虑把哪些信息存入到激活码中，这些信息最终是要能够被解析出来的。这里我们存入的是礼包ID，在玩家兑换激活码时，我们通过解析这个激活码获得的礼包ID给玩家发放奖励。除了礼包ID我们还需要一些随机码，随机码的作用是为了让激活码看起来更加具有随机性，不容易被破解。那么如何去存入这些信息？ 通过
     <strong>
      码值的移位操作
     </strong>
    </p>
    <p>
     <strong>
      举一个例子来说明
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">//               1</span>
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 2 &lt;&lt; 2     1000</span>
    <span class="hljs-keyword">int</span> c = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 3 &lt;&lt; 4   110000</span>

                <span class="hljs-comment">//          111001              a,b,c |操作       ==&gt; 57 </span>

                <span class="hljs-comment">//          111001 &amp; 000011     第一次&amp;操作      ==&gt; 1</span>
                <span class="hljs-comment">// 57 &gt;&gt; 2  1110   &amp; 000011                     ==&gt; 2</span>
                <span class="hljs-comment">// 14 &gt;&gt; 2  11     &amp; 000011                     ==&gt; 3</span>
    val = a | (b &lt;&lt; <span class="hljs-number">2</span>) | (c &lt;&lt; <span class="hljs-number">4</span>);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,val);

    <span class="hljs-keyword">while</span>(val)
    {
        <span class="hljs-keyword">int</span> num = val &amp; <span class="hljs-number">3</span>;  <span class="hljs-comment">// 3的二进制 11</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,num);
        val = val &gt;&gt; <span class="hljs-number">2</span>;
    }

    system(<span class="hljs-string">"pause"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    <p>
     <img alt="执行结果" src="https://img-blog.csdn.net/20170527172913255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VfYXJlX3RoZV93b3JsZF8xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""/>
    </p>
    <p>
     这里先通过a,b,c依次向左等差移位2，作 | 操作得到值57，其二进制111001从右向左每两位代表一个数值。利用&amp;操作的特性，再依次向右等差移位2，便可依次解析出来a,b,c。
     <strong>
      ps：移位间隔由最大数值的二进制位数决定，这里如果想存入数值4，那么移位间隔就需要调整为3，相&amp;的值也应调整为7(二进制111)。
     </strong>
    </p>
    <p>
     <strong>
      如此，激活码的礼包ID和随机码也利用这样的原理去存入和解析。略有不同的是，礼包ID和随机码我们并不直接去存入，我们只存入礼包ID和随机码的索引，也就是AwardCodeDict的key值。这样，激活码的构造基本就出来了，通过字典的key值移位和 | 操作得到激活码的码值，再通过解码操作，最终我们就能得到一个激活码了。
     </strong>
    </p>
    <p>
     <strong>
      生成码值
     </strong>
     <br/>
     AwardCodeDict的key值最大为31，所以我们的移位间隔定义为5，相&amp;的值为0x1F。随机码的个数我们限定为7个。
    </p>
    <pre class="prettyprint"><code class="hljs cs">typedef unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  UINT64;

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> AWARD_CODE_BIT 5</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> AWARD_CODE_NUM 7</span>

UINT64 GenerateAwardCodeVaule(UINT64 awardId)
{
    UINT64 codeVal = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; AWARD_CODE_NUM; i++)
    {
        UINT64 key = rand() % DICT_SIZE;    
        codeVal |= key &lt;&lt; (AWARD_CODE_BIT * i);
    }
    codeVal |= awardId &lt;&lt; (AWARD_CODE_BIT * AWARD_CODE_NUM);
    <span class="hljs-keyword">return</span> codeVal;
}</code></pre>
    <p>
     <strong>
      这里需要特别留心awardId和key的类型定义，一定按最大的精度来定义，否则会导致codeVal部分数据丢失，最终解码错误。&lt;把key定义成int即可试验&gt;
     </strong>
    </p>
    <p>
     <strong>
      解析码值，生成激活码
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs perl"><span class="hljs-keyword">int</span> DecodeAwardCodeValue(UINT64 codeVal, char* code)
{
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(codeVal)
    {
        <span class="hljs-keyword">int</span> key = codeVal &amp; <span class="hljs-number">0x1F</span>;
        code[<span class="hljs-keyword">pos</span>++] = AwardCodeDict[key];
        codeVal = codeVal &gt;&gt; AWARD_CODE_BIT;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">pos</span>;
}</code></pre>
    <p>
     <strong>
      解析激活码，获取码值和礼包ID
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-comment">// 不区分字符的大小写</span>
<span class="hljs-keyword">int</span> GetKeyFromDict(<span class="hljs-keyword">char</span> ch)
{
    <span class="hljs-keyword">int</span> key = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; DICT_SIZE; i++)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">toupper</span>(ch) == AwardCodeDict[i]){
            key = i;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> key;
}

UINT64 GetAwardID(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* code)
{
    <span class="hljs-keyword">if</span>(!code || <span class="hljs-built_in">strlen</span>(code) &lt;= AWARD_CODE_NUM) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    UINT64 awardId = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = AWARD_CODE_NUM; i &lt; <span class="hljs-built_in">strlen</span>(code); i++)
    {
        UINT64 val = GetKeyFromDict(code[i]);
        awardId |= val &lt;&lt; (AWARD_CODE_BIT * (i - AWARD_CODE_NUM));
    }
    <span class="hljs-keyword">return</span> awardId;
}

UINT64 GetAwardCodeVaule(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* code)
{
    <span class="hljs-keyword">if</span>(!code) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    UINT64 codeVal = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">strlen</span>(code) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
        UINT64 key = GetKeyFromDict(code[i]);       
        codeVal |= key &lt;&lt; (AWARD_CODE_BIT * i);
    }
    <span class="hljs-keyword">return</span> codeVal;
}</code></pre>
    <p>
     <strong>
      最后写一段执行程序，验证上述方法
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs perl"><span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">srand</span>((unsigned)<span class="hljs-keyword">time</span>(NULL));

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">int</span> awardId;
        char code[<span class="hljs-number">32</span>] = <span class="hljs-string">{0}</span>;
        UINT64 codeVal = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"请输入礼包ID:"</span>);
        cin &gt;&gt; awardId;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
        {
            codeVal = GenerateAwardCodeVaule(awardId);
            DecodeAwardCodeValue(codeVal,code);
            <span class="hljs-keyword">printf</span>(<span class="hljs-string">"code:<span class="hljs-variable">%s</span> value:<span class="hljs-variable">%llu</span>  c2v:<span class="hljs-variable">%llu</span> c2k:<span class="hljs-variable">%d</span>\n"</span>,code,codeVal,GetAwardCodeVaule(code),GetAwardID(code));
            memset(code,<span class="hljs-number">0</span>,<span class="hljs-number">32</span>);
        }

    }

    <span class="hljs-keyword">system</span>(<span class="hljs-string">"pause"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    <p>
     <img alt="执行结果" src="https://img-blog.csdn.net/20170528093740496?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VfYXJlX3RoZV93b3JsZF8xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""/>
    </p>
    <p>
     <strong>
      结尾总结
     </strong>
     <br/>
     观察激活码，可以发现同一批次/同一组/同一礼包的激活码后几位是相同的。分析激活码的生成和解析过程，不难发现，生成码值时我们是从低位到高位(从右向左的一个过程)，生成激活码时我们依次 &amp; 操作得到的也是 从低位到高位，而字符串的读取是从左向右，所以我们的礼包ID处于最高位，却显示在了字符串的末尾。最后我们再来分析一下，这个激活码最大长度的问题。UINT64 8字节 64bit，移位间隔5，所以有效长度为12，超过12就可能会出现部分数据丢失。那么礼包ID最大有效值是多少呢？除去7个随机码占用的比特位，剩下64 - 7*5 = 29bit，再除以移位间隔，那么礼包ID的有效字符个数应该是5，最终可以得出礼包ID最大有效值应该是 11111 11111 11111 11111 11111 = 33554431。超过这个安全值之后，就不能保证一定能解码成功。
     <strong>
      所以我们可以得出，激活码有效字符为12个字符，礼包ID有效最大值为33554431。由此，我们可以在生成和验证激活码时加上保护判断。
     </strong>
    </p>
    <p>
     <strong>
      简述激活码的兑换
     </strong>
     <br/>
     这个过程，如果限定该礼包玩家只能兑换一次，只需记录玩家ID和礼包ID(从激活码中获得)即可。这里使用redis数据库最为便捷。把玩家ID和礼包ID以字符串的形式存入到以xx为key的集合(Set)中。使用”SISMEMBER key member “即可查询到玩家是否兑换过该礼包。激活码在被兑换或者使用后失效，则需要把该激活码从数据库中删除或者更新状态，使用集合(Set)来存储激活码也是非常方便的。
    </p>
    <p>
     <strong>
      补充一点
     </strong>
     <br/>
     生成的激活码会不会重复。从UINT64表示的数值范围中随机出一个值，这个值重复的概率是很低的。如果不是特别要求，可以忽略不计。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e6373646e:2e6e65742f77655f6172655f7468655f776f726c645f313233:2f61727469636c652f64657461696c732f3732373731383433" class_="artid" style="display:none">
 </p>
</div>


