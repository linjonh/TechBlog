---
layout: post
title: "在微信小程序中渲染HTML内容"
date: 2025-01-05 10:10:06 +0800
description: "大部分Web应用的富文本内容都是以HTML字符串的形式存储的，通过HTML文档去展示HTML内容自然"
keywords: "小程序渲染html"
categories: ['微信小程序']
tags: ['无标签']
artid: "82784710"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=82784710
    alt: "在微信小程序中渲染HTML内容"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     在微信小程序中渲染HTML内容
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     大部分Web应用的富文本内容都是以HTML字符串的形式存储的，通过HTML文档去展示HTML内容自然没有问题。但是，在微信
     <a href="http://www.wxapp-union.com/" rel="nofollow">
      小程序
     </a>
     （下文简称为「小程序」）中，应当如何渲染这部分内容呢？
    </p>
    <h3>
     解决方案
    </h3>
    <h4>
     wxParse
    </h4>
    <p>
     小程序刚上线那会儿，是无法直接渲染HTML内容的，于是就诞生了一个叫做「
     <a href="https://github.com/icindy/wxParse">
      wxParse
     </a>
     」的库。它的原理就是把HTML代码解析成树结构的数据，再通过小程序的模板把该数据渲染出来。
    </p>
    <h4>
     rich-text
    </h4>
    <p>
     后来，小程序增加了「rich-text」组件用于展示富文本内容。然而，这个组件存在一个极大的限制：
     <strong>
      组件内屏蔽了所有节点的事件
     </strong>
     。也就是说，在该组件内，连「预览图片」这样一个简单的功能都无法实现。
    </p>
    <h4>
     web-view
    </h4>
    <p>
     再后来，小程序允许通过「web-view」组件嵌套网页，通过网页展示HTML内容是兼容性最好的解决方案了。然而，因为要多加载一个页面，性能是较差的。
    </p>
    <h3>
     当「WePY」遇上「wxParse」
    </h3>
    <p>
     基于用户体验和功能交互上的考虑，我们抛弃了「rich-text」和「web-view」这两个原生组件，选择了「wxParse」。然而，用着用着却发现，「wxParse」也不能很好地满足需要：
    </p>
    <ul>
     <li>
      我们的小程序是基于「WePY」框架开发的，而「wxParse」是基于原生的小程序编写的。要想让两者兼容，必须修改「wxParse」的源代码。
     </li>
     <li>
      「wxParse」只是简单地通过image组件对原img元素的图片进行显示和预览。而在实际使用中，可能会用到云存储的接口对图片进行缩小，达到「
      <strong>
       用小图显示，用原图预览
      </strong>
      」的目的。
     </li>
     <li>
      「wxParse」直接使用小程序的video组件展示视频，但是video组件的
      <strong>
       层级问题
      </strong>
      经常导致UI异常（例如把某个固定定位的元素给挡了）。
     </li>
    </ul>
    <p>
     此外，围观一下「wxParse」的代码仓库可以发现，它已经两年没有迭代了。所以就萌生了基于「WePY」的组件模式重新写一个富文本组件的想法，其成果就是「WePY HTML」项目。
    </p>
    <h3>
     实现过程
    </h3>
    <h4>
     解析HTML
    </h4>
    <p>
     首先仍然是要把HTML字符串解析为树结构的数据，我采用的是「特殊字符分隔法」。HTML中的特殊字符是「&lt;」和「&gt;」，前者为开始符，后者为结束符。
    </p>
    <ul>
     <li>
      如果待解析内容以开始符开头，则截取
      <strong>
       开始符到结束符之间
      </strong>
      的内容作为节点进行解析。
     </li>
     <li>
      如果待解析内容不以开始符开头，则截取
      <strong>
       开头到开始符之前
      </strong>
      （如果开始符不存在，则为末尾）的内容作为纯文本解析。
     </li>
     <li>
      剩余内容进入下一轮解析，直到无剩余内容为止。
     </li>
    </ul>
    <p>
     正如下图所示：
    </p>
    <p>
    </p>
    <p>
     <img alt="" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/e368a36351b9c6e8f0abe46d7e41d03c.webp?x-image-process=image/format,png"/>
    </p>
    <p>
    </p>
    <p>
     为了形成树结构，解析过程中要维护一个上下文节点（默认为根节点）：
    </p>
    <ul>
     <li>
      如果截取出来的内容是开始标签，则根据匹配出的标签名和属性，在当前上下文节点下创建一个子节点。如果该标签不是自结束标签（br、img等），就把上下文节点设为新节点。
     </li>
     <li>
      如果截取出来的内容是结束标签，则根据标签名关闭当前上下文节点（把上下文节点设为其父节点）。
     </li>
     <li>
      如果是纯文本，则在当前上下文节点下创建一个文本节点，上下文节点不变。
     </li>
    </ul>
    <p>
     过程正如下面的表格所示：
    </p>
    <p>
    </p>
    <p>
     <img alt="" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/b2a210c84f9dcc618d61e0f278939eff.webp?x-image-process=image/format,png"/>
    </p>
    <p>
    </p>
    <p>
     经过上述流程，HTML字符串就被解析为节点树了。
    </p>
    <p>
     对比
    </p>
    <p>
     把上述算法与其他类似的解析算法进行对比（性能以「解析10000长度的HTML代码」进行测定）：
    </p>
    <p>
    </p>
    <p>
     <img alt="" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/b3f6e856be478f74036bcaba9984e7b0.webp?x-image-process=image/format,png"/>
    </p>
    <p>
    </p>
    <p>
     可见，在不考虑容错性（产生错误的结果，而非抛出异常）的情况下，本组件的算法与其余两者相比有压倒性的优势，符合小程序「
     <strong>
      小而快
     </strong>
     」的需要。而一般情况下，富文本编辑器所生成的代码也不会出现语法错误。因此，即使容错性较差，问题也不大（但这是需要改进的）。
    </p>
    <h4>
     模板渲染
    </h4>
    <p>
     树结构的渲染，必然会涉及到子节点的
     <strong>
      递归
     </strong>
     处理。然而，小程序的模板并不支持递归，这下仿佛掉入了一个大坑。
    </p>
    <p>
     看了一下「wxParse」模板的实现，它采用简单粗暴的方式解决这个问题：通过13个长得几乎一模一样的模板进行嵌套调用（1调用2，2调用3，……，12调用13），也就是说最多可以支持12次嵌套。一般来说，这个深度也足够了。
    </p>
    <p>
     由于「WePY」框架本身是有构建机制的，所以不必手写十来个几乎一模一样的模板，通过一个构建的插件去生成即可。
    </p>
    <p>
     以下为需要重复嵌套的模板（精简过），在其代码的开始前和结束后分别插入特殊注释进行标识，并在需要嵌入下一层模板的地方以另一段特殊注释（「」）标识：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs dust" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;&lt;!-- wepyhtml-repeat start --&gt;
&lt;template name="wepyhtml-0"&gt;
    &lt;block wx:if="{<!-- -->{ content }}" wx:for="{<!-- -->{ content }}"&gt;
        &lt;block wx:if="{<!-- -->{ item.type === 'node' }}"&gt;
            &lt;view class="wepyhtml-tag-{<!-- -->{ item.name }}"&gt;
                &lt;!-- next template --&gt;
            &lt;/view&gt;
        &lt;/block&gt;
        &lt;block wx:else&gt;{<!-- -->{ item.text }}&lt;/block&gt;
    &lt;/block&gt;
&lt;/template&gt;
&lt;!-- wepyhtml-repeat end --&gt;&lt;/pre&gt;
</code></pre>
    <p>
     以下是对应的构建代码（需要安装「
     <strong>
      wepy-plugin-replace
     </strong>
     」）：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs coffeescript" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;// wepy.config.js
{
    plugins: {
        replace: {
            filter: /\.wxml$/,
            config: {
                find: /&lt;\!-- wepyhtml-repeat start --&gt;([\W\w]+?)&lt;\!-- wepyhtml-repeat end --&gt;/,
                replace(match, tpl) {
                    let result = '';
                    // 反正不要钱，直接写个20层嵌套
                    for (let i = 0; i &lt;= 20; i++) {
                        result += '\n' + tpl
                            .replace('wepyhtml-0', 'wepyhtml-' + i)
                            .replace(/&lt;\!-- next template --&gt;/g, () =&gt; {
                                return i === 20 ?
                                    '' :
                                    `&lt;template is="wepyhtml-${ i + 1 }" wx:if="{<!-- -->{ item.children }}" data="{<!-- -->{ content: item.children"&gt;&lt;/template&gt;`;
                            });
                    }
                    return result;
                }
            }
        }
    }
}&lt;/pre&gt;
</code></pre>
    <p>
     然而，运行起来后发现，第二层及更深层级的节点都没有渲染出来，说明嵌套失败了。再看一下dist目录下生成的wxml文件可以发现，变量名与组件源代码的并不相同：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs bash" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;&lt;block wx:if="{<!-- -->{ $htmlContent$wepyHtml$content }}" wx:for="{<!-- -->{ $htmlContent$wepyHtml$content }}"&gt;&lt;/pre&gt;
</code></pre>
    <p>
     「WePY」在生成组件代码时，为了避免组件数据与页面数据的变量名冲突，会
     <strong>
      根据一定的规则给组件的变量名增加前缀
     </strong>
     （如上面代码中的「
     <img alt="htmlContent" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/284ac59cc433c1bdf6be456948032990.png">
      wepyHtml$」）。所以在生成嵌套模板时，也必须使用带前缀的变量名。
     </img>
    </p>
    <p>
     先在组件代码中增加一个变量「thisIsMe」用于识别前缀：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs dust" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;&lt;!-- wepyhtml-repeat start --&gt;
&lt;template name="wepyhtml-0"&gt; {<!-- -->{ thisIsMe }}
    &lt;block wx:if="{<!-- -->{ content }}" wx:for="{<!-- -->{ content }}"&gt;
        &lt;block wx:if="{<!-- -->{ item.type === 'node' }}"&gt;
            &lt;view class="wepyhtml-tag-{<!-- -->{ item.name }}"&gt;
                &lt;!-- next template --&gt;
            &lt;/view&gt;
        &lt;/block&gt;
        &lt;block wx:else&gt;{<!-- -->{ item.text }}&lt;/block&gt;
    &lt;/block&gt;
&lt;/template&gt;
&lt;!-- wepyhtml-repeat end --&gt;&lt;/pre&gt;
</code></pre>
    <p>
     然后修改构建代码：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs coffeescript" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;replace(match, tpl) {
    let result = '';
    let prefix = '';

    // 匹配 thisIsMe 的前缀
    tpl = tpl.replace(/\{\{\s*(\$.*?\$)thisIsMe\s*\}\}/, (match, p) =&gt; {
        prefix = p;
        return '';
    });

    for (let i = 0; i &lt;= 20; i++) {
        result += '\n' + tpl
            .replace('wepyhtml-0', 'wepyhtml-' + i)
            .replace(/&lt;\!-- next template --&gt;/g, () =&gt; {
                return i === 20 ?
                    '' :
                    `&lt;template is="wepyhtml-${ i + 1 }" wx:if="{<!-- -->{ item.children }}" data="{<!-- -->{ ${ prefix }content: item.children }}"&gt;&lt;/template&gt;`;
            });
    }

    return result;
}&lt;/pre&gt;
</code></pre>
    <p>
     至此，渲染问题就解决了。
    </p>
    <h4>
     图片
    </h4>
    <p>
     为了节省流量和提高加载速度，展示富文本内容时，一般都会按照所需尺寸对里面的图片进行缩小，点击小图进行预览时才展示原图。这主要涉及节点属性的修改：
    </p>
    <ul>
     <li>
      把图片原路径（src属性值）存到自定义属性（例如「data-src」）中，并将其添加到预览图数组。
     </li>
     <li>
      把图片的src属性值修改为缩小后的图片URL（一般云服务商都有提供此类URL规则）。
     </li>
     <li>
      点击图片时，使用自定义属性的值进行预览。
     </li>
    </ul>
    <p>
     为了实现这个需求，本组件在解析节点时提供了一个钩子（
     <strong>
      onNodeCreate
     </strong>
     ）：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs kotlin" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;onNodeCreate(name, attrs) {
    if (name === 'img') {
        attrs['data-src'] = attrs.src;
        // 预览图数组
        this.previewImgs.push(attrs.src);
        // 缩图
        attrs.src = resizeImg(attrs.src, 640);
    }
}&lt;/pre&gt;
</code></pre>
    <p>
     对应的模板和事件处理逻辑如下：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs dust" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;&lt;template name="wepyhtml-img"&gt;
    &lt;image class="wepyhtml-tag-img" mode="widthFix" src="{<!-- -->{ elem.attrs.src }}" data-src="{<!-- -->{ elem.attrs['data-src'] || elem.attrs.src }}" @tap="imgTap"&gt;&lt;/image&gt;
&lt;/template&gt;&lt;/pre&gt;

&lt;pre class="prettyprint hljs less" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;// 点击小图看大图
imgTap(e) {
    wepy.previewImage({
        current: e.currentTarget.dataset.src,
        urls: this.previewImgs
    });
}&lt;/pre&gt;
</code></pre>
    <h4>
     视频
    </h4>
    <p>
     在小程序中，video组件的层级是较高的（且无法降低）。如果页面设计上存在着可能挡住视频的元素，处理起来就需要一些技巧了：
    </p>
    <ul>
     <li>
      隐藏video组件，用image组件（视频封面）占位；
     </li>
     <li>
      点击图片时，让视频全屏播放；
     </li>
     <li>
      如果退出了全屏，则暂停播放。
     </li>
    </ul>
    <p>
     相关代码如下：
    </p>
    <pre class="has"><code>&lt;pre class="prettyprint hljs dust" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;&lt;template name="wepyhtml-video"&gt;
    &lt;view class="wepyhtml-tag-video" @tap="videoTap" data-nodeid="{<!-- -->{ elem.nodeId }}"&gt;
        &lt;!-- 视频封面 --&gt;
        &lt;image class="wepyhtml-tag-img wepyhtml-tag-video__poster" mode="widthFix" src="{<!-- -->{ elem.attrs.poster }}"&gt;&lt;/image&gt;
        &lt;!-- 播放图标 --&gt;
        &lt;image class="wepyhtml-tag-img wepyhtml-tag-video__play" src="./imgs/icon-play.png"&gt;&lt;/image&gt;
        &lt;!-- 视频组件 --&gt;
        &lt;video style="display: none;" src="{<!-- -->{ elem.attrs.src }}" id="wepyhtml-video-{<!-- -->{ elem.nodeId }}" @fullscreenchange="videoFullscreenChange" @play="videoPlay"&gt;&lt;/video&gt;
    &lt;/view&gt;
&lt;/template&gt;&lt;/pre&gt;

&lt;pre class="prettyprint hljs clojure" style="word-wrap: break-word; margin: 0px 0px 1.5em; padding: 0.5em; text-decoration: none; font-style: normal; font-family: Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(68, 68, 68); border-radius: 4px; line-height: 1.5em; word-break: break-all; background-color: rgb(246, 246, 246); border: none; overflow-x: auto;"&gt;{
    // 点击封面图，播放视频
    videoTap(e) {
        const nodeId = e.currentTarget.dataset.nodeid;
        const context = wepy.createVideoContext('wepyhtml-video-' + nodeId);
        context.play();
        // 在安卓微信下，如果视频不可见，则调用play()也无法播放
        // 需要再调用全屏方法
        if (wepy.getSystemInfoSync().platform === 'android') {
            context.requestFullScreen();
        }
    },
    // 视频层级较高，为防止遮挡其他特殊定位元素，造成界面异常，
    // 强制全屏播放
    videoPlay(e) {
        wepy.createVideoContext(e.currentTarget.id).requestFullScreen();
    },
    // 退出全屏则暂停
    videoFullscreenChange(e) {
        if (!e.detail.fullScreen) {
            wepy.createVideoContext(e.currentTarget.id).pause();
        }
    }
}&lt;/pre&gt;
</code></pre>
    <h3>
     开源
    </h3>
    <p>
     最后贴一下「WePY HTML」的项目仓库：
     <a href="https://github.com/beiliao-web-frontend/wepy-html">
      https://github.com/beiliao-web-frontend/wepy-html
     </a>
     ，具体使用方法见项目内的
     <a href="https://github.com/beiliao-web-frontend/wepy-html#readme">
      README
     </a>
     。如果你在使用过程中遇到了问题，或者是有好的建议和意见，都可以在
     <a href="https://github.com/beiliao-web-frontend/wepy-html/issues">
      Issues
     </a>
     中提出。
    </p>
    <p>
     原文：
     <a href="http://www.heeroluo.net/article/detail/142/render-html-content-in-weixin-mini-program?utm_source=tuicool&amp;utm_medium=referral" rel="nofollow">
      Heero's Blog
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f726f6c616e31393933:2f61727469636c652f64657461696c732f3832373834373130" class_="artid" style="display:none">
 </p>
</div>


