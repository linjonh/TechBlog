---
layout: post
title: "使用element-穿梭框分页加搜索框实现"
date: 2025-01-14 14:29:35 +0800
description: "背景：根据类目选择面料，因为面料太多，故而在页面分页  <el-transfer          "
keywords: "el-transfer 分页"
categories: ['']
tags: ['Elementui']
artid: "117019480"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=117019480
    alt: "使用element-穿梭框分页加搜索框实现"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     使用element  穿梭框分页加搜索框实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     背景：根据类目选择面料，因为面料太多，故而在页面分页
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c3b9ce3f4d1e2be181981dda0448c691.png"/>
    </p>
    <pre><code>  &lt;el-transfer
                  v-model="fabricVOS"
                  :props="{
                    key:'fabricNo',
                    value:'fabricNo'
                  }"
                  :data="fabricList"
                  style="justify-content:flex-start;"
                &gt;
                  &lt;el-pagination
                    slot="left-footer"
                    :current-page="listQuery.current"
                    :page-size="listQuery.size"
                    :total="listQuery.total"
                    :pager-count="5"
                    small
                    align="right"
                    layout="prev, pager, next"
                    @current-change="handleCurrentChange"
                  &gt;&lt;/el-pagination&gt;
 &lt;/el-transfer&gt;
</code></pre>
    <p>
     关于分页的时候选择其他页面，目标数据丢失的问题，我的解决方法是
     <br/>
     新增的时候：
     <br/>
     在每一次分页的时候把目标源的数据塞到数据源
    </p>
    <pre><code>    if (this.fabricVOS.length &gt; 0) {
          this.fabricVOS.map(item =&gt; {
            this.fabricList.push({ fabricNo: item })
          })
        }
</code></pre>
    <p>
     这样即使切换页面，目标源的数据也不会丢失
    </p>
    <p>
     编辑的时候
     <br/>
     后端把已选中的数据塞到返回来的每一页的数据了
    </p>
    <p>
     搜索框
    </p>
    <pre><code> &lt;el-input v-model="searchValue" style="margin-bottom: 10px;width: 200px" &gt;&lt;/el-input&gt;
 &lt;el-button type="primary" size="small" style="margin-left: 10px" @click="handleChange"&gt;搜索&lt;/el-button&gt;
 &lt;el-button type="plain" size="small" @click="restValue"&gt;重置&lt;/el-button&gt;
</code></pre>
    <p>
     搜索我是本地搜索
    </p>
    <pre><code>    handleChange() {
      const value = this.searchValue
      const list = this.mianliaoList.filter(item =&gt; {       //获取全部数据遍历
        return item.fabricNo.indexOf(value) != -1
      })
      let lastList = []

      if (this.fabricVOS.length &gt; 0) {     //目标源数据
        const fabricList = []
        this.fabricVOS.map(item =&gt; {
          fabricList.push({ fabricNo: item })   //数据源数据塞入目标源的数据
        })
        lastList = list.concat(fabricList)    //数据拼接
      } else {
        lastList = list
      }
      this.$nextTick(() =&gt; {
        this.listQuery.total = lastList.length     //修改分页的总数据
        this.fabricList = lastList                       
      })
    },
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34333433373633302f:61727469636c652f64657461696c732f313137303139343830" class_="artid" style="display:none">
 </p>
</div>


