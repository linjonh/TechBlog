---
layout: post
title: "FPGA验证技术简介"
date: 2024-06-19 17:02:56 +0800
description: "第一编 验证的重要性　　验证，顾名思义就是通过仿真、时序分析、上板调试等手段检验设计正确性的过程，在"
keywords: "fpga板级验证"
categories: ['Fpga']
tags: ['无标签']
artid: "48714593"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=48714593
    alt: "FPGA验证技术简介"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     FPGA验证技术简介
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <strong>
     <span style="font-size:18px">
      第一编 验证的重要性
     </span>
    </strong>
    <p>
     <span style="font-size:18px">
      验证，顾名思义就是通过仿真、时序分析、上板调试等手段检验设计正确性的过程，在
     </span>
     <a href="http://www.elecfans.com/emb/fpga/20120516271958.html" rel="nofollow noopener noreferrer" target="_blank">
      <span style="font-size:18px">
       FPGA
      </span>
     </a>
     <span style="font-size:18px">
      /
     </span>
     <a href="http://www.elecfans.com/bandaoti/eda/20120514271574.html" rel="nofollow noopener noreferrer" target="_blank">
      <span style="font-size:18px">
       IC
      </span>
     </a>
     <span style="font-size:18px">
      开发流程中，验证主要包括功能验证和时序验证两个部分。为了了解验证的重要性，我们先来回顾一下FPGA开发的整个流程。FPGA开发流程和IC的开发流程相似，主要分为以下几个部分：
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      1)设计输入，利用HDL输入工具、原理图输入工具或状态机输入工具等把所要设计的电路描述出来;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      2)功能验证，也就是前仿真，利用Modelsim、VCS等仿真工具对设计进行仿真，检验设计的功能是否正确;常用的仿真工具有Model Tech公司的ModelSim，Synopsys公司的VCS，Cadence公司的NC-Verilog和NC-VHDL，Aldec公司的 Active HDL VHDL/Verilog HDL等。仿真过程能及时发现设计中的错误，加快了设计进度，提高了设计的可*性。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      3)综合，综合优化是把HDL语言翻译成最基本的与或非门的连接关系(网表)，并根据要求(约束条件)优化所生成的门级逻辑连接，输出edf和edn等文件，导给CPLD/FPGA厂家的软件进行实现和布局布线。常用的专业综合优化工具有Synplicity公司的Synplify/Synplify Pro、Amplify等综合工具，Synopsys公司的FPGA Compiler II综合工具(Synopsys公司将停止发展FPGA Express软件，而转到FPGA Compiler II平台)，Exemplar Logic公司出品的LeonardoSpectrum等综合工具。另外FPGA/CPLD厂商的集成开发环境也带有一些综合工具，如Xilinx ISE中的XST等。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      4)布局布线，综合的结果只是通用的门级网表，只是一些门与或非的逻辑关系，与芯片实际的配置情况还有差距。此时应该使用FPGA/CPLD厂商提供的实现与布局布线工具，根据所选芯片的型号，进行芯片内部功能单元的实际连接与映射。这种实现与布局布线工具一般要选用所选器件的生产商开发的工具，因为只有生产者最了解器件内部的结构，如在ISE的集成环境中完成实现与布局布线的工具是Flow Engine。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      5)时序验证，其目的是保证设计满足时序要求，即setup/hold time符合要求，以便数据能被正确的采样。时序验证的主要方法包括STA(Static Timing Analysis)和后仿真。在后仿真中将布局布线的时延反标到设计中去，使仿真既包含门延时，又包含线延时信息。这种后仿真是最准确的仿真，能较好地反映芯片的实际工作情况。仿真工具与综合前仿真工具相同。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      6)生成并下载BIT或PROM文件，进行板级调试。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      在以上几个主要开发步骤当中，属于验证的有功能仿真和时序验证两个步骤，由于前仿真和后仿真涉及验证环境的建立，需要耗费大量的时间，而在STA中对时序报告进行分析也是一个非常复杂的事情，因此验证在整个设计流程中占用了大量的时间，在复杂的FPGA/IC设计中，验证所占的时间估计在60%～70%之间。相比较而言， FPGA设计流程的其他环节由于需要人为干预的东西比较少，例如综合、布局布线等流程，基本所有的工作都由工具完成，设置好工具的参数之后，结果很快就可以出来，因此所花的时间精力要比验证少的多。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      一般而言，在验证的几个内容中功能验证最受重视，研究讨论得最多，特别是现在FPGA/IC设计都朝向SOC(System On Chip，片上系统)的方向发展，设计的复杂都大大提高，如何保证这些复杂系统的功能是正确的成了至关重要的问题。功能验证对所有功能进行充分的验证，尽早地暴露问题，保证所有功能完全正确，满足设计的需要。任何潜在的问题都会给后续工作作带来难以极大的困难，而且由于问题发现得越迟，付出的代价也越大，这个代价是几何级数增长的。这里将以功能验证为主说明验证方法、工具、验证环境的建立、
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      做功能验证时，需要建立验证环境，以便对设计(DUT/DUV，Design Under Test/Verification)施加特定的输入，然后对DUT的输出进行检查，确实其是否正确。在实际验证工作中，一般采用由TESTBENCH 和DUT(design under test)组成的Verification体系。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      Verification体系是验证系统普遍适用的模型，Testbench为DUT提供输入，然后监视输出，从而判断DUT工作是否正确。注意到这是一个封闭的系统，没有输入也没有输出。验证工作的难度在于确定应该输入何种激励，相应的正确的输出应该是怎样的。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      下一篇我们看个具体的例子，一起写代码和仿真。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      第二篇 分析一个testbench
     </span>
    </p>
    <p>
     <span style="font-size:18px">
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      很多FPGA/IC开发工具都提供设计例子，方便使用者学习和练习，例如，Xilinx ISE提供了很多设计实例，放在ISE5.X的安装目录下的ISEexamples目录下，例如CDMA匹配滤波器、Johnson计数器、PN码发生器、频率计等，这些例子是经验丰富的工程师写的，我们可以学到编程思想、代码风格等方面的知识和经验，这些东西可能从学校老师或一般书籍都学习不到。如果你用的不是Xilinx的FPGA，也就是说不使用ISE，那也没关系，HDL代码和testbench的设计思想和方法是一样的，你照样可以从中学到很多东西。下面以其中一个例子――同步FIFO为例，分析一下我们的第一个testbench，设计的源代码可以在ISEexamples目录下找到， Xilinx还提供了Application Note详细介绍了该FIFO的细节，下载的网址是http://www.xilinx.com/xapp/xapp131.pdf
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      1.511x8同步FIFO功能简介
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      为了对这个511x8同步FIFO进行功能验证，首先要清楚它的功能，只有这样才能知道需要验证什么功能，以及如何进行验证，图1为该同步FIFO的原理框图。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      与异步FIFO相比，同步FIFO的读、写时钟是同一个时钟，简化了FIFO的设计，Empty和Full标志的产生也比较容易，同步 FIFO内部使用二进制计数器记录读地址和写地址。在异步FIFO中，由于读写使用不同的时钟，也就是说设计存在两个时钟域，为了减少出现亚稳态时产生的错误，记录读写地址的计数器要使用格雷码，Empty和Full标志的产生也比较复杂。511x8同步FIFO(以下简称FIFO)的工作时序如图2所示。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      读FIFO数据时，首先read_allow信号置高，时钟上升沿到来时read_addr地址处的数据将出现在read_data处，同时read_addr加1。让read_allow信号持续为高可以完成burst read操作。如果读出的数据是FIFO的最后一个数据，那么读操作完成后Empty信号变高。Empty信号为高时读出来的数据是无效的。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      写FIFO数据时，首先write_allow信号置高，同时准备好输入数据write_data，时钟上升沿到来时，数据将写入 write_addr所指向的地址中，同时write_addr加1。让write_allow信号持续为高可以完成burst write操作。如果某一个时钟上升沿时写入第511个数，那么下一个时钟沿到来的时候Full信号变高，表示FIFO已经写满。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      我们再详细分析FIFO的工作时序图。在图2中，开始时FIFO的读写指针均为0，Empty为高表示FIFO处于空的状态，然后 write_allow置高，时钟上升沿到来时写入第一个数据，Empty变低;一个CLK之后，read_allow置高，时钟上升沿到来时，读出数据，由于是最后一个数据，所以Empty信号又变为有效(高电平)。在时序图的右半部分，写入509个数据之后，再写入两个数据，Full信号变为有效，表示FIFO为满。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      这个FIFO还有一个名为fifo_count_out的输出，从4’b0000~4’b1111，分别表示FIFO满的程度从不足1/16到15/16，为某些应用提供方便。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      2.验证
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      清楚FIFO的功能之后，我们就可以开始验证工作了。验证工作的第一步是整理出FIFO需要验证的功能点，这些功能点一般直接来源于FIFO应该具有的功能，或者来源于它的使用方法。FIFO需要验证的功能点包括：
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      1)FIFO复位后，read_addr和write_addr为0，Full为0，Empty为1。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      2)读FIFO数据时，read_allow信号必须置高，时钟上升沿到来时read_addr地址处的数据将出现在read_data处，同时read_addr加1。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      3)读出FIFO的最后一个数据后，Empty信号变高。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      4)写FIFO数据时，write_allow信号必须置高，时钟上升沿到来时，输入数据write_data将写入write_addr所指向的地址中，同时write_addr加1。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      5)如果某一个时钟上升沿时写入第511个数，那么下一个时钟沿到来的时候Full信号变高，表示FIFO已经写满。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      6)fifo_count_out端能正确的指示FIFO满的程度。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      分析Xilinx提供的testbench可以为我们编写自己的testbench提供很好的参考。FIFO的RTL代码和 testbench代码放在ISEexamplesfifo_ver_131和fifo_vhd_131下。以verilog代码为例， fifo_ver_131中包括了两个testbench文件，一个是功能仿真testbench文件fifoctlr_cc_tb.tf，另一个是时序仿真(后仿真)testbench文件fifoctlr_cc_tb_timing.tf，这里我们主要分析功能仿真文件，为了方便大家理解，以下(下一帖)为注释过的功能仿真testbench。大家看testbench的代码时，对照FIFO需要验证的功能点，检查是不是所有功能点都经过了验证。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      FIFO的testbench主要包括初始化、验证initial块、读写task等内容，初始化部分主要完成复位信号、CLK信号等的初始化工作，读写task把读写、delay等操作模块化，方便使用。这里主要介绍一下验证initial块，也可以说是验证的主程序，如下所示。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      initial begin
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      delay; //保证验证环境正确复位
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      writeburst128; //写入512个数，Full信号应该在写入511个数后变高
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      writeburst128;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      writeburst128;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      writeburst128;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      read_enable = 1; //读出一个数，Full信号应该变低
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      writeburst128; //同时读写，检查FIFO操作是否正确
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      read_enable = 0; //读操作结束
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      endwriteburst; //写操作结束
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      delay;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      readburst128; //连续读512次，Empty信号应在读出511个数后变高
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      readburst128;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      readburst128;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      readburst128;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      endreadburst;
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      end
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      这段程序首先延迟5个时钟周期，等初始化完成之后再开始验证工作。验证时，首先写入512个数，使用波形观察器可以检查写入的过程是否正确，以及Full信号在写入511个数后是否变高;然后read_enable = 1，读出一个数，Full信号应该变低，这样写操作和Full信号的验证就基本完成了;程序接着也启动了写操作，由于此时read_enable仍然为高，即读写同时进行，这是对实际情况的模拟，可以对FIFO的功能进行更严格的验证;最后，连续读FIFO 512次，用波形观察器检查读操作是否正确，Empty信号是否在读出511个数后变高，如果这些操作都是正确的，那么FIFO的功能就基本正确了。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      需要注意的一点是，以上的程序是不可综合的，因为不是RTL级描述，而是行为级描述(Behavioral Description)。行为级描述的特点是直接描述对象的功能，具有比较高的抽象层次，开发、运行速度都比RTL代码要会，因此testbench都是用行为级描述写的。关于行为级描述的特点、写法以后将有专门的章节论述。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      这个testbench的特点是，输入激励由testbench产生，输出响应的检查人工完成，这样的testbench编写相对容易，可以加快开发速度，作为开发人员自己验证是非常好的选择。有些testbench能完成输入激励和输出检查，不用观察波形也能完成验证工作，这样的 testbench具有更高的自动化程度，使用方便，可重复性好，当设计比较复杂而且团队中有专门的验证工程师时，一般会有验证工程师建立一套这样的 testbench，用于验证开发工程师的RTL级代码，如果发现问题，开发工程师修改后在testbench再运行一次所花的时间非常少，开发复杂项目时这样做可以比用波形观察器节省很多时间。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      3.总结
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      验证一般要通过写testbench实现，从《FPGA验证》第一篇我们知道，testbench要完成向DUT施加激励和检查DUT相应是否正确的功能，这就要求我们非常清楚待验证模块(DUT)的功能，这样才知道需要验证什么、如何施加激励和如何检查响应是否正确。写
     </span>
    </p>
    <p>
     <span style="font-size:18px">
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      第三篇 验证工具介绍
     </span>
    </p>
    <p>
     <span style="font-size:18px">
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      我们做FPGA/IC开发会用到很多工具，包括代码输入、仿真、综合、布局布线、时序分析等各种各样工具，熟悉这些工具是成功完成设计的关键，因为我们的设计思想需要通过这些工具来实现，只有清楚的知道工具的用法、如何设置参数、如果检查工具的输出结果，才能使设计者的想法变为显示，对验证来说也是如此。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      验证的工具很多，有些是验证必不可少的，例如仿真器，有些工具可以代替人完成最繁琐的工作，并能提高功能验证的可信度，例如linting和代码覆盖率工具。这里我们介绍常用验证工具的特点和用途，以便为工具的使用提供参考。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      1)代码检查工具
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      常用的代码检查工具有nlint等，nlint根据设计的RTL描述代码结构做静态分析，推断描述代码存在的逻辑错误，但无法决定描述代码是否能够现实设计要求的功能。代码检查工具可用于强制代码遵从编写规范，由于代码检查工具工具是静态验证工具，因此运行速度快，可以节省时间。由于Verilog不是强类型语言，使用代码检查工具非常必要，可以检测race conditions 及数据宽度不匹配，可保证Verilog正确描述数据处理过程，避免造成数据的弃位及增位现象，这种错误通过仿真并不一定发现。因为verilog 语言的特点， 对Verilog描述的设计，Linting tool是一种有益的验证工具。因为VHDL 语言的特点，对VHDL使用Linting tool的作用不如对Verilog语言那么明显，但Linting tool还是能发现一些潜在的问题。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      2)仿真器
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      仿真器是常用的验证工具，它通过忽略及简化设计的物理特性，对设计的实现进行模拟。仿真器通过执行RTL级的设计描述，模拟设计的物理实现，它无法确定设计真实的物理实现与设计描述之间的区别。仿真的结果取决于设计描述是否准确反映了设计的物理实现。仿真器不是一个静态工具，需要编写激励和检查输出响应。激励由模拟设计工作环境的testbench 产生，响应为仿真的输出，由设计者确定输出的有效性。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      仿真器的类型分为3种类型，Event-driven Simulator(事件驱动仿真器)、Cycle-Based Simulator(基于周期的仿真器)、Co-Simulator(联合仿真器)，分别介绍如下：
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      1.Event-driven Simulator
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      事件驱动仿真器是最常用的仿真器，例如modelsim/VCS等都是事件驱动仿真器，它将信号的变化定义为一个事件，该事件驱动仿真执行，事件驱动仿真器能准确地模拟设计的时序特征，可模拟异步设计。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      2.Cycle-based simulator
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      Cycle-based simulator仿真器的特点是忽略设计的时序，假定所有flip_flop的setup和hold时间都满足要求，在一个时钟周期，信号仅更新一次，从而信号必须与时钟同步。仿真速度比事件驱动仿真器高。基于周期的仿真器的工作过程步骤是，首先编译电路，将组合逻辑压缩成单独的表达式，根据该表达式可确定flop的输入，然后执行仿真，遇到时钟的有效沿， flip_flop 的值被更新。基于周期的仿真器的缺点是不能仿真异步电路，不能进行验证设计的时序。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      3.Co-Simulators
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      联合仿真器对同一设计各个部分，分别用不同的仿真器仿真，如即含有同步设计又含有异步设计的电路，可用Event-driven Simulator对异步设计仿真，用Cycle-based Simulator对异步设计仿真。联合仿真器中各个Simulator 的操作是locked-step的，类似于电路的pipeline 操作。其缺点是由于不同仿真器之间需要同步和相互通讯，Co-Simulators的仿真速度受到最慢Simulator的限制，因而影响仿真器的性能，而且在各仿真器传送的信息会产生多义性。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      4.Hardware modeler
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      硬件模拟器创建一个物理芯片的逻辑模型，向仿真器提供该芯片的行为信息，芯片和仿真器的通信过是首先将物理芯片插入硬件仿真器，然后格式化来自仿真器的数据，作为该芯片的输入，最后将该芯片输出的数据，包含时序信息，送往仿真器。硬件模拟器可以提供很高的仿真速度，但是设备价格高昂。需要注意的是，硬件模拟器做的仍然是功能仿真，而不是时序仿真，因为芯片是降频运行的。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      3)波形观察器
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      仿真调试的过程中波形观察器是必不可少的工具，它能提供信号状态和变化的详细信息，但是波形观察器不能用来判断一个设计是否通过验证，因为波形是不可重复的且无法用于递归仿真。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      波形观察器的优点是可以观察仿真的整个过程，有利于设计及testbench 的诊断，缺点是由于要输出波形，影响了仿真的速度，因此应尽可能限制在波形图中显示的信号数量及时间长度。波形观察器的另一个作用是波形比较，主要用于 redesign，保证设计具有cycle-accurate的后向兼容性。在波形比较中，不能仅看表象，需仔细分析，确认波形之间存在的差别是有意义的。例如，有时我们仅关心波形transitions之间的相对位置，而不关心它的绝对位置。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
      以上是比较常用的验证工具，另外可能用到的验证工具有：形式验证工具、静态时序分析工具以及Vera、SpecmanE、SystemC等高级语言验证工具，这些工具在复杂的IC/FPGA设计中用得比较多。
     </span>
    </p>
    <p>
     <span style="font-size:18px">
     </span>
    </p>
    <p>
     <a href="http://www.elecfans.com/emb/fpga/20120518272325_3.html" rel="nofollow noopener noreferrer" target="_blank">
      <span style="font-size:18px">
       http://www.elecfans.com/emb/fpga/20120518272325_3.html
      </span>
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f7068656e69787966:2f61727469636c652f64657461696c732f3438373134353933" class_="artid" style="display:none">
 </p>
</div>


