---
layout: post
title: "操作系统-进程进程的概念"
date: 2022-09-25 17:46:15 +0800
description: "【操作系统-进程】进程的概念_进程和进程实体"
keywords: "进程和进程实体"
categories: ['计算机操作系统']
tags: ['网络', '服务器', 'Linux']
artid: "127040677"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=127040677
    alt: "操作系统-进程进程的概念"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【操作系统-进程】进程的概念
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <ul>
        <li>
         <a href="#0__1" rel="nofollow">
          0 补充
         </a>
        </li>
        <li>
         <a href="#1__9" rel="nofollow">
          1 进程
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#11__10" rel="nofollow">
            1.1 进程的组成（进程实体/进程映像）
           </a>
          </li>
          <li>
           <a href="#12__34" rel="nofollow">
            1.2 进程的状态
           </a>
          </li>
          <li>
           <a href="#13_IPC_81" rel="nofollow">
            1.3 进程的通信（IPC）
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#2__112" rel="nofollow">
          2 线程
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#21__113" rel="nofollow">
            2.1 线程与进程的比较
           </a>
          </li>
          <li>
           <a href="#22__125" rel="nofollow">
            2.2 线程的实现
           </a>
          </li>
          <li>
           <a href="#23__134" rel="nofollow">
            2.3 多线程模型
           </a>
          </li>
          <li>
           <a href="#24__144" rel="nofollow">
            2.4 相关例题
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#3__198" rel="nofollow">
          3 调度
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#31__199" rel="nofollow">
            3.1 调度的层次
           </a>
          </li>
          <li>
           <a href="#32__209" rel="nofollow">
            3.2 调度的时机
           </a>
          </li>
          <li>
           <a href="#33__219" rel="nofollow">
            3.3 调度的方式
           </a>
          </li>
          <li>
           <a href="#34__226" rel="nofollow">
            3.4 调度的算法
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#4__237" rel="nofollow">
          4 同步和异步
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#41__238" rel="nofollow">
            4.1 临界资源和临界区
           </a>
          </li>
          <li>
           <a href="#42__246" rel="nofollow">
            4.2 同步
           </a>
          </li>
          <li>
           <a href="#43__261" rel="nofollow">
            4.3 互斥
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#431__265" rel="nofollow">
              4.3.1 软件实现
             </a>
            </li>
            <li>
             <a href="#432__387" rel="nofollow">
              4.3.2 硬件实现
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#44__397" rel="nofollow">
            4.4 信号量
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#441__404" rel="nofollow">
              4.4.1 实现进程同步
             </a>
            </li>
            <li>
             <a href="#442__429" rel="nofollow">
              4.4.2 实现进程互斥
             </a>
            </li>
            <li>
             <a href="#443__451" rel="nofollow">
              4.4.3 实现前驱关系
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#45__487" rel="nofollow">
            4.5 管程
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#5__513" rel="nofollow">
          5 死锁
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#51__514" rel="nofollow">
            5.1 死锁产生的原因
           </a>
          </li>
          <li>
           <a href="#52__528" rel="nofollow">
            5.2 死锁的四个必要条件
           </a>
          </li>
          <li>
           <a href="#53__544" rel="nofollow">
            5.3 死锁的处理策略
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#531__545" rel="nofollow">
              5.3.1 死锁预防（不允许死锁发生-静态策略）
             </a>
            </li>
            <li>
             <a href="#532__554" rel="nofollow">
              5.3.2 死锁避免（不允许死锁发生-动态策略）
             </a>
            </li>
            <li>
             <a href="#533__594" rel="nofollow">
              5.3.3 死锁检测和解除（允许死锁发生）
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h3>
     <a id="0__1">
     </a>
     0 补充
    </h3>
    <ul>
     <li>
      并发：指两个或多个事件在同一时间间隔内发生。
     </li>
     <li>
      并行：指两个或多个事件在同一时刻发生。
     </li>
    </ul>
    <blockquote>
     <p>
      【注】对于单处理机，在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机仅能有一道程序执行。此时操作系统
      <br/>
      是通过分时来实现并发性的，没有真正实现并行性。
     </p>
    </blockquote>
    <h3>
     <a id="1__9">
     </a>
     1 进程
    </h3>
    <h4>
     <a id="11__10">
     </a>
     1.1 进程的组成（进程实体/进程映像）
    </h4>
    <p>
     一个进程实体（进程映像）由 PCB、程序段、数据段组成。
     <strong>
      进程是动态的，进程实体（进程映像）是静态的。进程是进程实体的运行过程，是系统进行资源分配、拥有资源和调度的一个基本单位
     </strong>
     。
    </p>
    <p>
     程序和进程的区别：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        程序
       </th>
       <th>
        进程
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        组成
       </td>
       <td>
        代码和数据
       </td>
       <td>
        代码，数据和 PCB
       </td>
      </tr>
      <tr>
       <td>
        特点
       </td>
       <td>
        永久的，静态的
       </td>
       <td>
        暂时的，动态的
       </td>
      </tr>
      <tr>
       <td>
        对应关系
       </td>
       <td>
        程序代码经过多次创建可对应不同进程
       </td>
       <td>
        一个进程可由系统调用方法被不同进程多次调用
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <strong>
       进程控制块（PCB）
      </strong>
      ：
      <strong>
       PCB 是进程存在的唯一标志
      </strong>
      ，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB。
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        内容
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        进程描述信息
       </td>
       <td>
        进程标识符 PID，用户标识符 UID
       </td>
      </tr>
      <tr>
       <td>
        进程控制和管理信息
       </td>
       <td>
        各硬件使用情况信息，进程当前状态
       </td>
      </tr>
      <tr>
       <td>
        资源分配清单
       </td>
       <td>
        使用的文件、内存区域、I/O设备
       </td>
      </tr>
      <tr>
       <td>
        CPU 相关信息
       </td>
       <td>
        PSW、PC，用于实现进程切换
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <strong>
       程序段
      </strong>
      ：即程序的代码（指令序列）。
     </li>
     <li>
      <strong>
       数据段
      </strong>
      ：运行过程中产生的数据。
     </li>
    </ul>
    <h4>
     <a id="12__34">
     </a>
     1.2 进程的状态
    </h4>
    <ul>
     <li>
      <strong>
       进程的状态
      </strong>
      ：
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        进程的状态
       </th>
       <th>
        描述
       </th>
       <th>
        CPU 占用
       </th>
       <th>
        拥有资源
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        创建态
       </td>
       <td>
        进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化 PCB
       </td>
       <td>
        ~
       </td>
       <td>
        ~
       </td>
      </tr>
      <tr>
       <td>
        就绪态
       </td>
       <td>
        当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲 CPU，就暂时不能运行
       </td>
       <td>
        否
       </td>
       <td>
        是
       </td>
      </tr>
      <tr>
       <td>
        运行态
       </td>
       <td>
        如果一个进程此时在CPU上运行，那么这个进程处于“运行态”
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
      </tr>
      <tr>
       <td>
        阻塞态
       </td>
       <td>
        进程请求等待某个事件的发生，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下 CPU，并让它进入“阻塞态”
       </td>
       <td>
        否
       </td>
       <td>
        否
       </td>
      </tr>
      <tr>
       <td>
        终止态
       </td>
       <td>
        进程请求操作系统终止该进程，此时操作系统会让该进程下 CPU，并回收内存空间等资源，最后还要回收该进程的 PCB
       </td>
       <td>
        ~
       </td>
       <td>
        ~
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <strong>
       进程的状态转换
      </strong>
      ：
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        进程的状态转换
       </th>
       <th>
        原语操作
       </th>
       <th>
        何事件会引起状态转换？
       </th>
       <th>
        进程主动还是被动发起？
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        创建态–&gt;就绪态
       </td>
       <td>
        创建原语
       </td>
       <td>
        用户登录、作业调度、提供服务、应用请求
       </td>
       <td>
        主动/被动
       </td>
      </tr>
      <tr>
       <td>
        就绪态–&gt;运行态
       </td>
       <td>
        切换原语
       </td>
       <td>
        其他进程的时间片用完、更高优先级进程到达
       </td>
       <td>
        被动（操作系统发起）
       </td>
      </tr>
      <tr>
       <td>
        运行态–&gt;就绪态
       </td>
       <td>
        切换原语
       </td>
       <td>
        该进程的时间片用完、更高优先级进程到达
       </td>
       <td>
        被动（操作系统发起）
       </td>
      </tr>
      <tr>
       <td>
        运行态–&gt;阻塞态
       </td>
       <td>
        切换原语
       </td>
       <td>
        当前进程主动阻塞
       </td>
       <td>
        主动
       </td>
      </tr>
      <tr>
       <td>
        阻塞态–&gt;就绪态
       </td>
       <td>
        唤醒原语
       </td>
       <td>
        等待的事件发生
       </td>
       <td>
        被动（操作系统发起）
       </td>
      </tr>
      <tr>
       <td>
        运行态–&gt;终止态
       </td>
       <td>
        撤销原语
       </td>
       <td>
        正常结束、异常结束、用户干预
       </td>
       <td>
        主动/被动
       </td>
      </tr>
      <tr>
       <td>
        阻塞态–&gt;终止态
       </td>
       <td>
        撤销原语
       </td>
       <td>
        正常结束、异常结束、用户干预
       </td>
       <td>
        主动/被动
       </td>
      </tr>
      <tr>
       <td>
        就绪态–&gt;终止态
       </td>
       <td>
        撤销原语
       </td>
       <td>
        正常结束、异常结束、用户干预
       </td>
       <td>
        主动/被动
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      【注 1】假设一个单处理器系统，若同时存在 m 个进程，则 m 个进程不可能同时处于就绪态，但 m 个进程可能同时处于阻塞态（此时就绪队列为空），这时 CPU 将调度闲逛进程（idel）。
      <br/>
      【注 2】系统中有 n 个进程，其中至少有一个进程运行，则就绪队列中最多有 n–1 个进程。
     </p>
    </blockquote>
    <ul>
     <li>
      <strong>
       原语
      </strong>
      ：原语的执行具有原子性，即执行过程只能
      <strong>
       一气呵成
      </strong>
      ，期间不允许被中断，可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性。
     </li>
    </ul>
    <blockquote>
     <p>
      <strong>
       原语执行的一般过程
      </strong>
      ：
     </p>
     <ul>
      <li>
       更新 PCB 信息：（a）修改当前进程状态标志；（b）往 PCB 保存当前进程的运行环境；（c）根据 PCB 恢复欲切换进程的运行环境
      </li>
      <li>
       将 PCB 插入对应的队列
      </li>
      <li>
       分配/回收资源
      </li>
     </ul>
    </blockquote>
    <table>
     <thead>
      <tr>
       <th>
        原语操作
       </th>
       <th>
        过程
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        创建原语
       </td>
       <td>
        （1）申请空白 PCB；（2）为新进程分配资源；（3）初始化 PCB；（4）将 PCB 插入就绪队列
       </td>
      </tr>
      <tr>
       <td>
        切换原语
       </td>
       <td>
        （1）保护进程运行现场；（2）PCB 状态信息改为就绪态或阻塞态；（3）将 PCB 插入对应资源的就绪队列或等待队列
       </td>
      </tr>
      <tr>
       <td>
        唤醒原语
       </td>
       <td>
        （1）等待队列找到该进程；（2）PCB 状态信息改为就绪态，将 PCB 从等待队列中移出；（3）将 PCB 插入对应资源的等待队列
       </td>
      </tr>
      <tr>
       <td>
        撤销原语
       </td>
       <td>
        （1）找到该 PCB；（2）若处于运行态，立即剥夺 CPU；（3）终止其所有子进程，将资源还给父进程或操作系统；（4）删除 PCB
       </td>
      </tr>
      <tr>
       <td>
        发送原语
       </td>
       <td>
        略
       </td>
      </tr>
      <tr>
       <td>
        接收原语
       </td>
       <td>
        略
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      【注】切换原语（切换到阻塞态）和唤醒原语需一一对应。
     </p>
    </blockquote>
    <h4>
     <a id="13_IPC_81">
     </a>
     1.3 进程的通信（IPC）
    </h4>
    <ul>
     <li>
      <strong>
       共享存储
      </strong>
      ：划分一块共享空间，通过对这片共享空间进行读写操作实现进程通信，需要使用同步互斥工具（PV操作）。
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        方式
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        低级方式
       </td>
       <td>
        基于数据结构的共享
       </td>
      </tr>
      <tr>
       <td>
        高级方式
       </td>
       <td>
        基于存储区的共享
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <strong>
       消息传递
      </strong>
      ：进程间的数据交换以
      <strong>
       格式化的消息（Message
      </strong>
      ）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        消息传递方式
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        直接通信方式
       </td>
       <td>
        发送进程直接把消息发送给接收进程
       </td>
      </tr>
      <tr>
       <td>
        间接通信方式
       </td>
       <td>
        以“信箱”作为中间实体进行消息传递
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      间接通信方式：可以多个进程往同一个信箱 send 消息，也可以多个进程从同一个信箱中 receive 消息。
     </p>
    </blockquote>
    <ul>
     <li>
      <strong>
       管道通信
      </strong>
     </li>
    </ul>
    <blockquote>
     <p>
      管道文件：“管道”是一个特殊的共享文件，又名 pipe 文件，其实就是在内存中开辟一个大小固定的内存缓冲区。
     </p>
    </blockquote>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        内容
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        通信方式
       </td>
       <td>
        半双工通信
       </td>
      </tr>
      <tr>
       <td>
        进程访问
       </td>
       <td>
        互斥进行
       </td>
      </tr>
      <tr>
       <td>
        管道写满
       </td>
       <td>
        写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程
       </td>
      </tr>
      <tr>
       <td>
        管道读空
       </td>
       <td>
        读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      【注】多进程读一个管道的解决方案：一个管道允许多个写进程，一个读进程。
     </p>
    </blockquote>
    <h3>
     <a id="2__112">
     </a>
     2 线程
    </h3>
    <h4>
     <a id="21__113">
     </a>
     2.1 线程与进程的比较
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        引入进程和线程的操作系统
       </th>
       <th>
        仅引入进程的操作系统
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        状态
       </td>
       <td>
        线程和进程都有创建态、就绪态、运行态、阻塞态、终止态
       </td>
       <td>
        进程有创建态、就绪态、运行态、阻塞态、终止态
       </td>
      </tr>
      <tr>
       <td>
        组成
       </td>
       <td>
        线程 ID、线程控制块（TCB）；进程 ID、进程控制块（PCB）
       </td>
       <td>
        进程 ID、进程控制块（PCB）
       </td>
      </tr>
      <tr>
       <td>
        调度
       </td>
       <td>
        同一进程下的线程切换不引起进程切换，调度开销小；从一个进程中的线程切换到另一个进程中的线程引起进程切换（
        <strong>
         线程是调度的基本单位
        </strong>
        ）
       </td>
       <td>
        一定引起进程切换，调度开销大（
        <strong>
         进程是调度的基本单位
        </strong>
        ）
       </td>
      </tr>
      <tr>
       <td>
        系统资源
       </td>
       <td>
        进程拥有系统资源，线程不拥有系统资源，但可以访问它从属于进程的系统资源（
        <strong>
         进程是资源分配的基本单位
        </strong>
        ）
       </td>
       <td>
        进程拥有系统资源（
        <strong>
         进程是资源分配的基本单位
        </strong>
        ）
       </td>
      </tr>
      <tr>
       <td>
        系统开销
       </td>
       <td>
        创建、撤销、切换线程的开销比进程的小
       </td>
       <td>
        创建、撤销、切换进程的开销大
       </td>
      </tr>
      <tr>
       <td>
        独立性
       </td>
       <td>
        每个进程都有自己独立的地址空间，而同一进程的不同线程共享同一地址空间
       </td>
       <td>
        每个进程都有自己独立的地址空间
       </td>
      </tr>
      <tr>
       <td>
        处理机
       </td>
       <td>
        多个线程尅分配在多个处理机上
       </td>
       <td>
        进程只能运行在一个处理机上
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="22__125">
     </a>
     2.2 线程的实现
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        用户级线程
       </th>
       <th>
        内核级线程
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        谁来完成管理？
       </td>
       <td>
        应用程序
       </td>
       <td>
        操作系统内核
       </td>
      </tr>
      <tr>
       <td>
        在哪完成切换？
       </td>
       <td>
        用户态
       </td>
       <td>
        内核态
       </td>
      </tr>
      <tr>
       <td>
        系统开销
       </td>
       <td>
        开销小，效率高
       </td>
       <td>
        开销大，效率慢
       </td>
      </tr>
      <tr>
       <td>
        线程阻塞会发生什么？
       </td>
       <td>
        整个进程被阻塞，并发度低
       </td>
       <td>
        同一进程中的其他线程还可以继续执行，并发度高
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="23__134">
     </a>
     2.3 多线程模型
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        一对一模型
       </th>
       <th>
        多对一模型
       </th>
       <th>
        多对多模型
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        描述
       </td>
       <td>
        在同一进程中，每个用户级线程各自映射到不同内核级线程（一对一）
       </td>
       <td>
        在同一进程中，多个用户级线程映射到一个内核级线程（多对一）
       </td>
       <td>
        n 个用户级线程映射到 m 个内核级线程（n &gt;= m）（多对多）
       </td>
      </tr>
      <tr>
       <td>
        占用的内核级线程
       </td>
       <td>
        多，每个用户进程有与用户级线程同数量的内核级线程
       </td>
       <td>
        少，一个进程只被分配一个内核级线程
       </td>
       <td>
        一般，每个用户进程对应 m 个内核级线程
       </td>
      </tr>
      <tr>
       <td>
        在哪完成切换？
       </td>
       <td>
        内核态
       </td>
       <td>
        用户态
       </td>
       <td>
        内核态 、用户态
       </td>
      </tr>
      <tr>
       <td>
        系统开销
       </td>
       <td>
        开销大，效率慢
       </td>
       <td>
        开销小，效率高
       </td>
       <td>
        一般
       </td>
      </tr>
      <tr>
       <td>
        线程阻塞会发生什么？
       </td>
       <td>
        同一进程中的其他线程还可以继续执行，并发度高
       </td>
       <td>
        整个进程被阻塞，并发度低
       </td>
       <td>
        ~
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="24__144">
     </a>
     2.4 相关例题
    </h4>
    <p>
     下面是一道将进程与线程、互斥结合在一起的考题：
    </p>
    <p>
     【例】进程 P1 和 P2 均包含并发执行的线程，部分伪代码描述如下所示：
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 进程 P1</span>
<span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>   
    <span class="token keyword">int</span> a<span class="token punctuation">;</span> 
    a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
    x<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
<span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>   
    <span class="token keyword">int</span> a<span class="token punctuation">;</span> 
    a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
    x<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token comment">// 进程 P2</span>
<span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">thread3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>   
     <span class="token keyword">int</span> a<span class="token punctuation">;</span> 
     a<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">// 5</span>
     x<span class="token operator">+=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
<span class="token punctuation">}</span>
<span class="token function">thread4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>   
     <span class="token keyword">int</span> b<span class="token punctuation">;</span>
     b<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">// 7</span>
     x<span class="token operator">+=</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     需要互斥执行的操作是（ ）
    </p>
    <p>
     A．a=1 与 a=2
    </p>
    <p>
     B．a=x 与 b=x
    </p>
    <p>
     C．x+=1 与 x+=2
    </p>
    <p>
     D．x+=1 与 x+=3
    </p>
    <blockquote>
     <p>
      【解】进程有独立的地址空间，因而进程 1 和进程 2 的 x 不是同一个 x；线程共享所属进程的地址空间，因而进程 1 的 x 被线程 1 和线程 2 所共享（x 是进程 1 的全局变量），进程 2 的 x 被线程 3 和线程 4 所共享（x 是进程 2 的全局变量）。在线程内定义的 a、b 变量均为线程自己所有，不共享到其他线程（局部变量）。
     </p>
     <p>
      显然，语句 2、4 和语句 6、8 没有关系，不会发生互斥。语句 1 和 2 不会互斥，语句 5 和 6 也不会互斥，因为 a 和 b 是线程各自的局部变量。但是进程 1 内部的语句 2 和 4 会发生互斥，考虑到机器内部的执行过程，两个线程可能同时访问 x 所在的存储器，而两个线程对存储器同时进行写操作或读操作是不允许的。同理，进程 2 内部的语句 6 和 8 会发生互斥。只有 C 项符合题意。
     </p>
    </blockquote>
    <h3>
     <a id="3__198">
     </a>
     3 调度
    </h3>
    <h4>
     <a id="31__199">
     </a>
     3.1 调度的层次
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        要做什么？
       </th>
       <th>
        调度发生在？
       </th>
       <th>
        发生频率
       </th>
       <th>
        对进程状态的影响
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        作业调度（高级调度）
       </td>
       <td>
        从后备队列中选择合适的作业将其调入内存，并为其创建进程
       </td>
       <td>
        外存–&gt;内存（面向作业）
       </td>
       <td>
        低
       </td>
       <td>
        无–&gt;创建态–&gt;就绪态
       </td>
      </tr>
      <tr>
       <td>
        内存调度（中级调度）
       </td>
       <td>
        从挂起队列中选择合适的进程将其数据调回内存
       </td>
       <td>
        外存–&gt;内存（面向进程）
       </td>
       <td>
        中
       </td>
       <td>
        挂起态–&gt;就绪态（阻塞挂起–&gt;阻塞态）
       </td>
      </tr>
      <tr>
       <td>
        进程调度（低级调度）
       </td>
       <td>
        从就绪队列中选择一个进程为其分配处理机
       </td>
       <td>
        内存–&gt;CPU
       </td>
       <td>
        低
       </td>
       <td>
        就绪态–&gt;运行态
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      【注】挂起和阻塞的区别：两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。
     </p>
    </blockquote>
    <h4>
     <a id="32__209">
     </a>
     3.2 调度的时机
    </h4>
    <p>
     不能进行进程调度与切换的情况：
    </p>
    <ul>
     <li>
      在处理中断的过程中
     </li>
     <li>
      进程在操作系统内核程序临界区中
     </li>
     <li>
      在原子操作（原语）过程中
     </li>
    </ul>
    <blockquote>
     <p>
      【注】进程在普通临界区中是可以进行调度、切换的。
     </p>
    </blockquote>
    <h4>
     <a id="33__219">
     </a>
     3.3 调度的方式
    </h4>
    <p>
     （届时将专门开一篇文章来整理）
    </p>
    <ul>
     <li>
      非抢占式调度：又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
     </li>
     <li>
      抢占式调度：又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
     </li>
    </ul>
    <h4>
     <a id="34__226">
     </a>
     3.4 调度的算法
    </h4>
    <p>
     （届时将专门开一篇文章来整理）
    </p>
    <ul>
     <li>
      先来先服务（FCFS）调度算法
     </li>
     <li>
      短作业优先（SJF）调度算法
     </li>
     <li>
      优先级调度算法
     </li>
     <li>
      高响应比优先调度算法
     </li>
     <li>
      时间片轮转调度算法
     </li>
     <li>
      多级队列调度算法
     </li>
    </ul>
    <h3>
     <a id="4__237">
     </a>
     4 同步和异步
    </h3>
    <h4>
     <a id="41__238">
     </a>
     4.1 临界资源和临界区
    </h4>
    <ul>
     <li>
      <strong>
       临界资源
      </strong>
      ：一个时间段内只允许一个进程使用的资源称为临界资源。
     </li>
     <li>
      <strong>
       进入区
      </strong>
      ：检查是否可以进入临界区，若可以则上锁。
     </li>
     <li>
      <strong>
       临界区（临界段）
      </strong>
      ：进程中访问临界资源的代码段。
     </li>
     <li>
      <strong>
       退出区
      </strong>
      ：负责解锁。
     </li>
     <li>
      <strong>
       剩余区
      </strong>
      ：其余代码部分。
     </li>
    </ul>
    <h4>
     <a id="42__246">
     </a>
     4.2 同步
    </h4>
    <p>
     同步指的是进程之间的直接制约关系。
    </p>
    <p>
     <strong>
      同步互斥机制应遵守的四大准则
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       空闲让进
      </strong>
      ：临界区空闲时，应允许一个进程访问。
     </li>
     <li>
      <strong>
       忙则等待
      </strong>
      ：临界区正在被访问时，其他要访问的进程需等待。
     </li>
     <li>
      <strong>
       有限等待
      </strong>
      ：进程不能一直等待临界区释放，否则出现“饥饿”现象。
     </li>
     <li>
      <strong>
       让权等待
      </strong>
      ：进不了临界区的进程要下处理机，以免进程陷入“忙等”状态。
     </li>
    </ul>
    <blockquote>
     <p>
      【注 1】关于“让权等待”的问题，除了信号量方法能解决外，其他方案无法解决，因为这些方案都包含了 while 语句，进程会一直卡在 while 语句死等。
     </p>
     <p>
      【注 2】注意区别“忙则等待”、“有限等待”和“让权等待”：违反“有限等待”是有人想进临界区，但一直进不了，一直死等；违反“让权等待”是有人进了临界区，其他人在干等这个人退出临界区；违反“忙则等待”是有人进了临界区，其他人也闯进来了。
     </p>
    </blockquote>
    <h4>
     <a id="43__261">
     </a>
     4.3 互斥
    </h4>
    <p>
     互斥指的是进程之间的间接制约关系。
    </p>
    <h5>
     <a id="431__265">
     </a>
     4.3.1 软件实现
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        描述
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         单标志检查法
        </strong>
       </td>
       <td>
        在进入区只“检查”，不“上锁”
       </td>
       <td>
        违反“空闲让进”
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         双标志先检查法
        </strong>
       </td>
       <td>
        在进入区先“检查”后“上锁”，退出区“解锁”
       </td>
       <td>
        违反“忙则等待”
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         双标志后检查法
        </strong>
       </td>
       <td>
        在进入区先“上锁”后“检查”，退出区“解锁”
       </td>
       <td>
        违反“空闲让进”“有限等待”
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Peterson 算法
        </strong>
       </td>
       <td>
        在进入区“主动争取-主动谦让-检查对方是否想进、己方是否谦让”
       </td>
       <td>
        违反“让权等待”
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      如何分析出这些算法的缺点
     </strong>
     ？注意到这些算法通常由“检查”和“上锁”两个操作组成，而这两个操作必须一气呵成地完成才能达到目的。因此，我们只需让这些操作不再一气呵成地完成，缺点也就自然分析出来了。
    </p>
    <p>
     <strong>
      如何分析出这些算法是否可能引起饥饿
     </strong>
     ？将算法的缺点分析出来，自然就知道会不会产生饥饿现象了。
     <strong>
      只有违反“有限等待”的算法可能导致饥饿现象
     </strong>
     ，而违反“忙则等待”则是“喂得过饱”了。
    </p>
    <p>
     来看下面实例：
    </p>
    <p>
     <strong>
      （1）单标志检查法
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 全局变量</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// P1 进程</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>trun <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1（检查）</span>
critical section<span class="token punctuation">;</span>
turn <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token comment">// P2 进程</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2（检查）</span>
critical section<span class="token punctuation">;</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       缺点分析
      </strong>
      ：交替执行语句 1 和 2 时，语句 1 的循环条件不满足，进程 1 进入临界区，语句 2 的循环条件满足，进程 2 等待。看起来没什么问题，但若进程 1 连续两次申请访问临界区时，turn 值为 2，依然进不去临界区，因此不满足“空闲让进”原则。
     </li>
     <li>
      <strong>
       饥饿分析
      </strong>
      ：不会产生饥饿。
     </li>
    </ul>
    <p>
     <strong>
      （2）双标志先检查法
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 全局变量</span>
flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span> 
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>

<span class="token comment">// P1 进程</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1（检查）</span>
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// 2（加锁）</span>
critical section<span class="token punctuation">;</span>
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token comment">// P2 进程</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3（检查）</span>
flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// 4（加锁）</span>
critical section<span class="token punctuation">;</span>
flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       缺点分析
      </strong>
      ：交替执行语句 1、3、2、4，执行语句 1 和 3 时，由于 flag[1] 和 flag[2] 都为 false，因此会跳出循环，这就意味着两个进程都进入了临界区，违反了“忙则等待”原则。
     </li>
     <li>
      <strong>
       饥饿分析
      </strong>
      ：不会产生饥饿现象。
     </li>
    </ul>
    <p>
     <strong>
      （3）双标志后检查法
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 全局变量</span>
flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span> 
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>

<span class="token comment">// P1 进程</span>
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// 1（加锁）</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2（检查）</span>
critical section<span class="token punctuation">;</span>
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token comment">// P2 进程</span>
flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// 3（加锁）</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4（检查）</span>
critical section<span class="token punctuation">;</span>
flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       缺点分析
      </strong>
      ：交替执行语句 1、3、2、4，执行语句 1 和 3 后，flag[1] 和 flag[2] 都为 true。执行语句 2，由于 flag[1] 为 true，因此进程 1 会一直卡在 while 循环；执行语句 4，由于 flag[2] 也为 true，因此进程 2 也会一直卡在 while 循环。两个进程无限等待下去，但是临界区又处于空闲状态，因而违反了“空闲让进”和“有限等待”原则。
     </li>
     <li>
      <strong>
       饥饿分析
      </strong>
      ：违反了“有限等待”原则，可能产生饥饿现象。
     </li>
    </ul>
    <p>
     <strong>
      （4）Peterson 算法
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 注意 turn 为全局变量</span>

<span class="token comment">// P1 进程</span>
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// 1</span>
turn <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>
critical section<span class="token punctuation">,</span>
flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token comment">// P2 进程</span>
flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// 4</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
critical section<span class="token punctuation">;</span>
flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
remainder section<span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       缺点分析
      </strong>
      ：交替执行语句 1、4、2、5、3、6，执行语句 1、4、2、5 后，flag[1] = TRUE，turn = 1，flag[2] = TRUE。执行语句 3，循环条件不满足，进程 1 进入临界区。执行语句 4，循环条件满足，进程 2 将一直等待下去，这违反了“让权等待”。因而除了“让权等待”没有遵守外，其他三个原则都遵守了。
     </li>
     <li>
      <strong>
       饥饿分析
      </strong>
      ：不会产生饥饿现象。
     </li>
    </ul>
    <h5>
     <a id="432__387">
     </a>
     4.3.2 硬件实现
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        描述
       </th>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         中断屏蔽方法
        </strong>
       </td>
       <td>
        利用“开/关中断指令”实现
       </td>
       <td>
        简单高效
       </td>
       <td>
        只适用于单处理机，只适用于操作系统内核进程
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         TestAndSet 指令
        </strong>
        （TSL 指令）
       </td>
       <td>
        使用变量 old 记录原来 lock 的值，再将 lock 设为 true，最后不断检查临界区是否已被其他进程上锁
       </td>
       <td>
        实现简单，适用于多处理机
       </td>
       <td>
        不满足让权等待
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Swap 指令
        </strong>
       </td>
       <td>
        逻辑上同 TSL 指令
       </td>
       <td>
        实现简单，适用于多处理机
       </td>
       <td>
        不满足让权等待
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      【注】后两者是用硬件实现的，它把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作，但仍未解决让权等待的问题。
     </p>
    </blockquote>
    <h4>
     <a id="44__397">
     </a>
     4.4 信号量
    </h4>
    <p>
     <strong>
      P 操作负责分配资源，没有资源的时候就等着（进入阻塞队列）。V 操作负责释放资源，在阻塞队列不为空的时候唤醒某个进程进入临界区。
     </strong>
    </p>
    <ul>
     <li>
      P 操作：使信号量 - 1。若信号量 &lt; 0，则执行 P 操作的进程被阻塞，否则进程继续执行。
     </li>
     <li>
      V 操作：使信号量 + 1。若信号量 ≤ 0，则被 P 操作阻塞的进程被解除阻塞。
     </li>
    </ul>
    <h5>
     <a id="441__404">
     </a>
     4.4.1 实现进程同步
    </h5>
    <p>
     <strong>
      一般信号量
     </strong>
     ：初值一般为可用物理资源的总数，用于进程同步问题。若期望的消息尚未产生，则初值应设为 0；若期望的消息已存在，则初值应设为一个非零正整数。
    </p>
    <blockquote>
     <ul>
      <li>
       信号量 &gt; 0：表示某类可用资源的数量。
      </li>
      <li>
       信号量 = 0：表示某类资源已经没有。
      </li>
      <li>
       信号量 &lt; 0：表示某类资源已经没有，还有因请求该资源而被阻塞的进程。
      </li>
      <li>
       信号量 ≤ 0 的绝对值：表示等待该资源的进程数。
      </li>
     </ul>
    </blockquote>
    <p>
     实现功能：执行完 A 后才能执行 B。因此，执行 A 后执行 V 操作，再执行 P 操作，然后执行 B。
    </p>
    <pre><code class="prism language-c">信号量 S<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    A<span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    B<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="442__429">
     </a>
     4.4.2 实现进程互斥
    </h5>
    <p>
     <strong>
      二元信号量
     </strong>
     ：取值仅为“0”或“1”，用作实现互斥。
     <strong>
      初值一定为“1”
     </strong>
     ，此时 P、V 操作需夹紧临界区。
    </p>
    <p>
     实现功能：两个进程对临界资源的互斥访问。
    </p>
    <pre><code class="prism language-c">信号量 S<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    P1的临界区<span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    P2的临界区<span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="443__451">
     </a>
     4.4.3 实现前驱关系
    </h5>
    <p>
     例如：
    </p>
    <ul>
     <li>
      P1–(信号量 a)–&gt;P2
     </li>
     <li>
      P1–(信号量 b)–&gt;P3
     </li>
     <li>
      P2–(信号量 c)–&gt;P3
     </li>
    </ul>
    <p>
     分析：
    </p>
    <ul>
     <li>
      P1(V(a))–(信号量 a)–&gt;(P(a))P2
     </li>
     <li>
      P1(V(b))–(信号量 b)–&gt;(P(b))P3
     </li>
     <li>
      P2(V©)–(信号量 c)–&gt;(P©)P3
     </li>
    </ul>
    <p>
     代码：
    </p>
    <pre><code class="prism language-c">信号量 a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">P3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">P</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="45__487">
     </a>
     4.5 管程
    </h4>
    <p>
     <strong>
      管程的组成（类似于面向对象的类）
     </strong>
     ：
    </p>
    <ul>
     <li>
      局部于管程的共享数据结构说明；
     </li>
     <li>
      对共享数据结构进行操作的一组过程；
     </li>
     <li>
      对局部于管程的共享数据设置初始值的语句；
     </li>
     <li>
      管程有一个名字。
     </li>
    </ul>
    <p>
     <strong>
      管程的基本特征
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       每次仅允许一个进程在管程内执行某个内部过程
      </strong>
      。
     </li>
     <li>
      一个进程只有通过调用管程内的过程才能进入管程访问共享数据。
     </li>
     <li>
      局部于管程的数据只能被局部于管程的过程所访问。
     </li>
     <li>
      互斥特性由编译器实现。
     </li>
    </ul>
    <p>
     <strong>
      信号量与条件变量
     </strong>
     ：
    </p>
    <p>
     阻塞原因定义为条件变量，每个条件变量保存一个等待队列。它们的区别：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        信号量
       </th>
       <th>
        条件变量
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        操作
       </td>
       <td>
        P、V 操作
       </td>
       <td>
        signal、wait 操作
       </td>
      </tr>
      <tr>
       <td>
        功能
       </td>
       <td>
        实现进程的阻塞、唤醒
       </td>
       <td>
        实现进程的阻塞、唤醒
       </td>
      </tr>
      <tr>
       <td>
        是否有值？
       </td>
       <td>
        有值，反映剩余资源数
       </td>
       <td>
        没有值，实现排队等待的功能
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="5__513">
     </a>
     5 死锁
    </h3>
    <h4>
     <a id="51__514">
     </a>
     5.1 死锁产生的原因
    </h4>
    <ul>
     <li>
      对不可剥夺资源的竞争，可能引起死锁。
     </li>
     <li>
      请求和释放资源的顺序不当。
     </li>
     <li>
      信号量使用不当。
     </li>
    </ul>
    <p>
     【注】
     <strong>
      死锁和饥饿的区别
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        死锁
       </th>
       <th>
        饥饿
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        产生原因
       </td>
       <td>
        循环等待对方手里的资源
       </td>
       <td>
        长期得不到需要的 I/O 设备，或长期得不到处理机
       </td>
      </tr>
      <tr>
       <td>
        进程状态
       </td>
       <td>
        阻塞态
       </td>
       <td>
        阻塞态或就绪态
       </td>
      </tr>
      <tr>
       <td>
        进程数量
       </td>
       <td>
        两个或以上
       </td>
       <td>
        一个
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="52__528">
     </a>
     5.2 死锁的四个必要条件
    </h4>
    <ul>
     <li>
      <strong>
       互斥条件
      </strong>
      ：只有对必须互斥使用的资源的争抢才会导致死锁。
     </li>
     <li>
      <strong>
       不剥夺条件
      </strong>
      ：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
     </li>
     <li>
      <strong>
       请求并保持条件
      </strong>
      ：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
     </li>
     <li>
      <strong>
       循环等待条件
      </strong>
      ：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
     </li>
    </ul>
    <blockquote>
     <p>
      【注】
      <strong>
       发生死锁时一定有循环等待，但是发生循环等待时未必死锁。
      </strong>
     </p>
    </blockquote>
    <p>
     由以上四个必要条件，可得以下
     <strong>
      常用结论
     </strong>
     ：
    </p>
    <ul>
     <li>
      若系统有 x 个进程，每个进程需要 y 个资源，则该系统必然不会发生死锁的最少资源是 x*(y-1) + 1 个。
     </li>
     <li>
      若系统有 x 个资源，每个进程需要 y 个资源，则该系统可能发生死锁的最小进程数为 x / (y-1)。
     </li>
    </ul>
    <blockquote>
     <p>
      【推导思路】系统有 x 个进程，每个进程已拥有 y-1 个资源，此时如果资源总数刚好为 x*(y-1) 个，意味着资源已用完，则一定发生死锁，此时再多加一个资源，令其中一个进程获得所需的最大资源，则死锁解除。即使每个进程所需资源数各不相同，一样可以按此思路分析。
     </p>
    </blockquote>
    <h4>
     <a id="53__544">
     </a>
     5.3 死锁的处理策略
    </h4>
    <h5>
     <a id="531__545">
     </a>
     5.3.1 死锁预防（不允许死锁发生-静态策略）
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        方法
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         破坏互斥条件
        </strong>
       </td>
       <td>
        把互斥资源改造为共享资源（如 SPOOLing 技术）
       </td>
       <td>
        可行性不高
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         破坏不剥夺条件
        </strong>
       </td>
       <td>
        （1）申请的资源得不到满足时，立即释放拥有的所有资源；（2）申请的资源被其他进程占用时，由操作系统协助剥夺
       </td>
       <td>
        可能导致进程部分工作失效，系统开销大，可能引起饥饿
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         破坏请求并保持条件
        </strong>
       </td>
       <td>
        运行前分配好所有需要的资源，之后一直保持
       </td>
       <td>
        资源利用率高，可能引起饥饿
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         破坏循环等待条件
        </strong>
       </td>
       <td>
        给资源编号，必须按编号递增的顺序请求资源
       </td>
       <td>
        用户编程麻烦，不方便新增新设备，资源浪费
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     <a id="532__554">
     </a>
     5.3.2 死锁避免（不允许死锁发生-动态策略）
    </h5>
    <p>
     安全性算法和银行家算法：
    </p>
    <p>
     【例】已知资源可用数为 S(x,y,z)，某时刻状态如下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        进程
       </th>
       <th>
        最大需求
       </th>
       <th>
        已拥有
       </th>
       <th>
        最多还要
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        A
       </td>
       <td>
        (0,0,4)
       </td>
       <td>
        (0,0,3)
       </td>
       <td>
        (0,0,1)
       </td>
      </tr>
      <tr>
       <td>
        B
       </td>
       <td>
        (1,7,5)
       </td>
       <td>
        (1,0,0)
       </td>
       <td>
        (0,7,5)
       </td>
      </tr>
      <tr>
       <td>
        C
       </td>
       <td>
        (2,3,5)
       </td>
       <td>
        (1,3,5)
       </td>
       <td>
        (1,0,0)
       </td>
      </tr>
      <tr>
       <td>
        D
       </td>
       <td>
        (0,6,4)
       </td>
       <td>
        (0,0,2)
       </td>
       <td>
        (0,6,2)
       </td>
      </tr>
      <tr>
       <td>
        E
       </td>
       <td>
        (0,6,5)
       </td>
       <td>
        (0,0,1)
       </td>
       <td>
        (0,6,4)
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     则 x、y、z 取以下值时系统处于安全状态？
    </p>
    <p>
     （1）1,4,0；（2）0,6,2；（3）1,1,1；（4）0,4,7。
    </p>
    <blockquote>
     <p>
      （1）【解】S(1,4,0) &gt; A(0,0,1)，S(1,4,0) &gt; C(1,0,0)，说明可以分配给 A 和 C。回收 A、C 资源后 S(1+0+1, 4+0+3, 0+3+5) = S(2,7,8)。
     </p>
     <p>
      考虑 B、D、E 进程，S(2,7,8) &gt; B(0,7,5)，S(2,7,8) &gt; D(0,6,2)，S(2,7,8) &gt; E(0,6,4)，说明可以分配给 B、D 和 E。回收 B、D、E 资源后 S(2+1+0+0, 7+0+0, 8+0+2+1) = S(3,7,11)。
     </p>
     <p>
      安全序列可以为 A、C、B、D、E，也可以为 C、A、D、B、E 等，因此处于安全状态。
     </p>
    </blockquote>
    <blockquote>
     <p>
      （2）【解】S(0,6,2) &gt; A(0,0,1)，S(0,6,2) = D(0,6,2)，说明可以分配给 A 和 D。回收 A、D 资源后 S(0+0+0, 6+0+0, 2+3+2) = S(0,6,7)。
     </p>
     <p>
      考虑 B、D、E 进程，S(0,6,7) &gt; D(0,6,2)，说明可以分配给 D。回收 D 资源后 S(0+0, 6+0, 7+2) = S(0,6,9)。
     </p>
     <p>
      考虑 B、E 进程，S(0,6,9) &lt; B(0,7,5)，S(0,6,9) &lt; E(0,6,4)，说明不可以分配给 B、E，因此系统处于不安全状态。
     </p>
    </blockquote>
    <blockquote>
     <p>
      （3）【解】S(1,1,1) &gt; A(0,0,1)，S(1,1,1) &gt; C(1,0,0)，说明可以分配给 A 和 C。回收 A、C 资源后 S(1+0+1, 1+0+3, 1+3+5) = S(2,4,9)。
     </p>
     <p>
      考虑 B、D、E 进程，S(2,4,9) &lt; B(0,7,5)，S(2,4,9) &lt; D(0,6,2)，S(2,4,9) &lt; E(0,6,4)，说明不可以分配给 B、D 和 E。因此处于不安全状态。
     </p>
    </blockquote>
    <blockquote>
     <p>
      （4）【解】S(0,4,7) &gt; A(0,0,1)，说明可以分配给 A。回收 A 资源后 S(0+0, 4+0, 7+3) = S(0,4,10)。
     </p>
     <p>
      考虑 B、C、D、E 进程，S(0,4,10) &lt; B(0,7,5)，S(0,4,10) &lt; C(1,0,0)，S(0,4,10) &lt; D(0,6,2)，S(0,4,10) &lt; E(0,6,4)，说明不可以分配给 B、C、D、E，因此处于不安全状态。
     </p>
    </blockquote>
    <p>
     【注】
     <strong>
      如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁
     </strong>
     （处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）。
    </p>
    <h5>
     <a id="533__594">
     </a>
     5.3.3 死锁检测和解除（允许死锁发生）
    </h5>
    <p>
     <strong>
      1. 死锁检测
     </strong>
    </p>
    <p>
     <strong>
      （1）资源分配图的组成
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        项目
       </th>
       <th>
        解释
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        进程结点
       </td>
       <td>
        对应一个进程
       </td>
      </tr>
      <tr>
       <td>
        资源结点
       </td>
       <td>
        对应一类资源，一类资源可能有多个资源
       </td>
      </tr>
      <tr>
       <td>
        进程结点到资源结点的边
       </td>
       <td>
        进程申请一个资源（每条边代表一个）
       </td>
      </tr>
      <tr>
       <td>
        资源结点到进程结点的边
       </td>
       <td>
        已经为进程分配了一个资源（每条边代表一个）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      （2）使用死锁检测算法简化资源分配图
     </strong>
     ：
    </p>
    <ul>
     <li>
      找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。
     </li>
     <li>
      消去它所有的请求边和分配边，使之称为孤立的结点。
     </li>
     <li>
      继续对剩余点进行一系列简化，若能消去图中所有的边，则称该图是可完全简化的。
     </li>
    </ul>
    <p>
     <strong>
      （3）死锁定理
     </strong>
     ：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。注意，并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。
    </p>
    <p>
     <strong>
      2. 死锁解除
     </strong>
    </p>
    <ul>
     <li>
      方法：资源剥夺法；撤销进程法；进程回退法。
     </li>
     <li>
      如何决定“对谁动手”：进程优先级；已执行多长时间；还要多久能完成；进程已经使用了多少资源；进程是交互式的还是批处理式的。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f62616964755f33393531343335372f:61727469636c652f64657461696c732f313237303430363737" class_="artid" style="display:none">
 </p>
</div>


