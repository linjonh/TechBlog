---
layout: post
title: "Java-热更新-加载class和jar"
date: 2024-11-30 10:52:02 +0800
description: "1、首先了解下java几个加载器的基本原理：         Java 中的类加载器大致可以分成两类"
keywords: "java如何通过压缩包实现类加载和升级"
categories: ['脚本热更新', '游戏服务器代码', 'Java']
tags: ['无标签']
artid: "79396727"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=79396727
    alt: "Java-热更新-加载class和jar"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java 热更新 加载class和jar
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="font-size:18px;background-color:rgb(255,255,255);color:rgb(51,51,51);font-family:Arial;">
      1、首先了解下java几个加载器的基本原理：
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <span style="margin:0px;padding:0px;font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);">
       Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：
      </span>
      <br style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);"/>
      <span style="margin:0px;padding:0px;font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);">
       引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。
      </span>
      <br style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);"/>
      <span style="margin:0px;padding:0px;font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);">
       扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
      </span>
      <br style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);"/>
      <span style="margin:0px;padding:0px;font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);">
       系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。
      </span>
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <span style="margin:0px;padding:0px;font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);">
       除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。
      </span>
      <br/>
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <span style="margin:0px;padding:0px;font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.1875px;background-color:rgb(239,239,239);">
       <span style="margin:0px;padding:0px;line-height:25.1875px;">
        我们平时程序执行的时候在类加载器中寻找类的结构的顺序是：引导类加载器-》 扩展类加载器-》系统类加载器-》我们自定义的一些类加载器，每个类加载器都有自己的空间，同一个加载器里面的类的二进制名字必须是唯一的，当然同一个类也可以存在不同的加载器内存区域里面，不过我们寻找类的时候是按顺序找的，一但找的也就不会继续往下找了，最终也没找到就会报类不存在异常。
       </span>
       <br style="line-height:25.1875px;"/>
       <span style="margin:0px;padding:0px;line-height:25.1875px;">
        我们如果想动态加载类的话就要仿照我们用的服务器如tomcat和weblogic之类的，他们的开发模式也就是把所有的类都加载到自身的类加载器中，当文件被替换的时候他们就重新加载新的class到内存里面去，从而实现了类的动态加载。
       </span>
       <br/>
      </span>
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      2、使用概要：
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      File   file   =   new   File(jar文件全路径);
      <br/>
      URL   url   =   file.toURI().toURL();
      <br/>
      URLClassLoader   loader   =   new   URLClassLoader(new   URL[]   {   url   });
      <br/>
      Class   tidyClazz   =   loader.loadClass(所需class的含包名的全名);
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      详细说明：
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      我们知道，Java利用ClassLoader将类载入内存，并且在同一应用中，可以有很多个ClassLoader，通过委派机制，把装载的任务传递给上级的装载器的，依次类推，直到启动类装载器（没有上级类装载器）。如果启动类装载器能够装载这个类，那么它会首先装载。如果不能，则往下传递。当父类为null时，JVM内置的类(称为:bootstrap class loader)就会充当父类。想想眼下的越来越多用XML文件做配置文件或者是描述符、部署符。其实这些通过XML文档描述的配置信息最终都要变成Java类，
      <span style="margin:0px;padding:0px;line-height:26px;">
       其
      </span>
      实都是通过ClassLoader来完成的。URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      参考代码：
     </span>
    </p>
    public class ReloadClassLoader extends ClassLoader{
    <br/>
    <span style="white-space:pre;">
    </span>
    /**
    <br/>
    <span style="white-space:pre;">
    </span>
    *
    <br/>
    <span style="white-space:pre;">
    </span>
    * @param classFile class文件
    <br/>
    <span style="white-space:pre;">
    </span>
    * @return
    <br/>
    <span style="white-space:pre;">
    </span>
    * @throws Exception
    <br/>
    <span style="white-space:pre;">
    </span>
    */
    <br/>
    <span style="white-space:pre;">
    </span>
    public Class&lt;?&gt; loadClass(File classFile){
    <br/>
    <span style="white-space:pre;">
    </span>
    // 一般的class文件通常都小于100k，如果现实情况超出这个范围可以放大长度
    <br/>
    <span style="white-space:pre;">
    </span>
    byte bytes[] = new byte[(int) classFile.length()];
    <br/>
    <span style="white-space:pre;">
    </span>
    FileInputStream fis = null;
    <br/>
    <span style="white-space:pre;">
    </span>
    Class&lt;?&gt; clazz = null;
    <br/>
    <span style="white-space:pre;">
    </span>
    try
    <br/>
    <span style="white-space:pre;">
    </span>
    {
    <br/>
    <span style="white-space:pre;">
    </span>
    fis = new FileInputStream(classFile);
    <br/>
    <span style="white-space:pre;">
    </span>
    int j = 0;
    <br/>
    <span style="white-space:pre;">
    </span>
    while (true)
    <br/>
    <span style="white-space:pre;">
    </span>
    {
    <br/>
    <span style="white-space:pre;">
    </span>
    int i = fis.read(bytes);
    <br/>
    <span style="white-space:pre;">
    </span>
    if (i == -1)
    <br/>
    <span style="white-space:pre;">
    </span>
    break;
    <br/>
    <span style="white-space:pre;">
    </span>
    j += i;
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    <span style="white-space:pre;">
    </span>
    clazz = super.defineClass(null, bytes, 0, j);
    <br/>
    <span style="white-space:pre;">
    </span>
    } catch (FileNotFoundException e) {
    <br/>
    <span style="white-space:pre;">
    </span>
    e.printStackTrace();
    <br/>
    <span style="white-space:pre;">
    </span>
    } catch (IOException e) {
    <span style="white-space:pre;">
    </span>
    <br/>
    <span style="white-space:pre;">
    </span>
    e.printStackTrace();
    <br/>
    <span style="white-space:pre;">
    </span>
    } finally {
    <br/>
    <span style="white-space:pre;">
    </span>
    if (fis != null) {
    <span style="white-space:pre;">
    </span>
    <br/>
    <span style="white-space:pre;">
    </span>
    try {
    <br/>
    <span style="white-space:pre;">
    </span>
    fis.close();
    <br/>
    <span style="white-space:pre;">
    </span>
    } catch (IOException e) {
    <br/>
    <span style="white-space:pre;">
    </span>
    e.printStackTrace();
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    <span style="white-space:pre;">
    </span>
    return clazz;
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    <span style="white-space:pre;">
    </span>
    /**
    <br/>
    <span style="white-space:pre;">
    </span>
    *
    <br/>
    <span style="white-space:pre;">
    </span>
    * @param JarFile Jar包
    <br/>
    <span style="white-space:pre;">
    </span>
    * @param className 全类名
    <br/>
    <span style="white-space:pre;">
    </span>
    * @return
    <br/>
    <span style="white-space:pre;">
    </span>
    * @throws Exception
    <br/>
    <span style="white-space:pre;">
    </span>
    */
    <br/>
    <span style="white-space:pre;">
    </span>
    public Class&lt;?&gt; loadJAR(File JarFile,String className){
    <br/>
    <span style="white-space:pre;">
    </span>
    Class&lt;?&gt; cls = null;
    <br/>
    if (!JarFile.exists()) {
    <br/>
    return null;
    <br/>
    }
    <br/>
    <br/>
    <span style="white-space:pre;">
    </span>
    try {
    <br/>
    <span style="white-space:pre;">
    </span>
    URL
    <span style="white-space:pre;">
    </span>
    url = JarFile.toURI().toURL();
    <br/>
    <span style="white-space:pre;">
    </span>
    URLClassLoader classLoader = new URLClassLoader(new URL[] { url }, Thread.currentThread().getContextClassLoader());
    <br/>
    <span style="white-space:pre;">
    </span>
    cls = classLoader.loadClass(className);
    <br/>
    <span style="white-space:pre;">
    </span>
    } catch (MalformedURLException e) {
    <br/>
    <span style="white-space:pre;">
    </span>
    // TODO Auto-generated catch block
    <br/>
    <span style="white-space:pre;">
    </span>
    e.printStackTrace();
    <br/>
    <span style="white-space:pre;">
    </span>
    } catch (ClassNotFoundException e) {
    <br/>
    <span style="white-space:pre;">
    </span>
    // TODO Auto-generated catch block
    <br/>
    <span style="white-space:pre;">
    </span>
    e.printStackTrace();
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    return cls;
    <br/>
    <span style="white-space:pre;">
    </span>
    }
    <br/>
    }
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <br/>
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <br/>
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <br/>
     </span>
    </p>
    <p style="color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Arial;">
     <span style="margin:0px;padding:0px;font-size:18px;">
      <br/>
     </span>
    </p>
    <p>
     <span style="background-color:rgb(255,255,255);">
      <span style="background-color:rgb(255,255,255);">
       <span style="background-color:rgb(255,255,255);">
       </span>
      </span>
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3335333336333132:2f61727469636c652f64657461696c732f3739333936373237" class_="artid" style="display:none">
 </p>
</div>


