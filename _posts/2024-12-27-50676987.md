---
layout: post
title: "用c语言代码编写的游戏简易五子棋"
date: 2024-12-27 15:42:24 +0800
description: "用c语言制作的小游戏，有兴趣的朋友可以试一下哦！_c语言简单小游戏代码"
keywords: "c语言简单小游戏代码"
categories: ['C']
tags: ['游戏', '数据', '指针', '五子棋', 'C']
artid: "50676987"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=50676987
    alt: "用c语言代码编写的游戏简易五子棋"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     用c语言代码编写的游戏“简易五子棋”
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="color:#ff0000">
      编译代码
     </span>
    </p>
    <p>
     #include &lt;stdlib.h&gt;
    </p>
    #include &lt;stdio.h&gt;
    <br/>
    #include &lt;conio.h&gt;
    <br/>
    #include &lt;string.h&gt;
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    #define MAXIMUS 15 //定义棋盘大小
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    int p[MAXIMUS][MAXIMUS];//存储对局信息
    <br/>
    char buff[MAXIMUS*2+1][MAXIMUS*4+3];//输出缓冲器
    <br/>
    int Cx,Cy;//当前光标位置
    <br/>
    int Now;//当前走子的玩家，1代表黑，2代表白
    <br/>
    int wl,wp;//当前写入缓冲器的列数和行数位置
    <br/>
    char* showText;//在棋盘中央显示的文字信息
    <br/>
    int count;//回合数
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    char* Copy(char* strDest,const char* strSrc)//修改过的字符串复制函数，会忽略末端的\0
    <br/>
    {
    <br/>
    char* strDestCopy = strDest;
    <br/>
    while (*strSrc!='\0')
    <br/>
    {
    <br/>
    *strDest++=*strSrc++;
    <br/>
    }
    <br/>
    return strDestCopy;
    <br/>
    }
    <br/>
    void Initialize()//初始化一个对局函数
    <br/>
    {
    <br/>
    int i,j;//循环变量
    <br/>
    showText="";//重置显示信息
    <br/>
    count=0;//回合数归零
    <br/>
    for(i=0;i&lt;MAXIMUS;i++)//重置对局数据
    <br/>
    {
    <br/>
    for(j=0;j&lt;MAXIMUS;j++)
    <br/>
    {
    <br/>
    p[i][j]=0;
    <br/>
    }
    <br/>
    }
    <br/>
    Cx=Cy=MAXIMUS/2;//重置光标到中央
    <br/>
    Now=1;//重置当前为黑方
    <br/>
    }
    <br/>
    char* getStyle(int i,int j)//获得棋盘中指定坐标交点位置的字符，通过制表符拼成棋盘
    <br/>
    {
    <br/>
    if(p[i][j]==1)//1为黑子
    <br/>
    return "●";
    <br/>
    else if(p[i][j]==2)//2为白子
    <br/>
    return "○";
    <br/>
    else if(i==0&amp;&amp;j==0)//以下为边缘棋盘样式
    <br/>
    return "┏";
    <br/>
    else if(i==MAXIMUS-1&amp;&amp;j==0)
    <br/>
    return "┓";
    <br/>
    else if(i==MAXIMUS-1&amp;&amp;j==MAXIMUS-1)
    <br/>
    return "┛";
    <br/>
    else if(i==0&amp;&amp;j==MAXIMUS-1)
    <br/>
    return "┗";
    <br/>
    else if(i==0)
    <br/>
    return "┠";
    <br/>
    else if(i==MAXIMUS-1)
    <br/>
    return "┨";
    <br/>
    else if(j==0)
    <br/>
    return "┯";
    <br/>
    else if(j==MAXIMUS-1)
    <br/>
    return "┷";
    <br/>
    return "┼";//中间的空位
    <br/>
    }
    <br/>
    char* getCurse(int i,int j){//获得指定坐标交点位置左上格的样式，通过制表符来模拟光标的显示
    <br/>
    if(i==Cx){
    <br/>
    if(j==Cy)
    <br/>
    return "┏";
    <br/>
    else if (j==Cy+1)
    <br/>
    return "┗";
    <br/>
    }
    <br/>
    else if(i==Cx+1)
    <br/>
    {
    <br/>
    if(j==Cy)
    <br/>
    return "┓";
    <br/>
    else if (j==Cy+1)
    <br/>
    return "┛";
    <br/>
    }
    <br/>
    return "　";//如果不在光标附近则为空
    <br/>
    }
    <br/>
    void write(char* c)//向缓冲器写入字符串
    <br/>
    {
    <br/>
    Copy(buff[wl]+wp,c);
    <br/>
    wp+=strlen(c);
    <br/>
    }
    <br/>
    void ln()//缓冲器写入位置提行
    <br/>
    {
    <br/>
    wl+=1;
    <br/>
    wp=0;
    <br/>
    }
    <br/>
    void Display()//将缓冲器内容输出到屏幕
    <br/>
    {
    <br/>
    int i,l=strlen(showText);//循环变量，中间文字信息的长度
    <br/>
    int Offset=MAXIMUS*2+2-l/2;//算出中间文字信息居中显示所在的横坐标位置
    <br/>
    if(Offset%2==1)//如果位置为奇数，则移动到偶数，避免混乱
    <br/>
    {
    <br/>
    Offset--;
    <br/>
    }
    <br/>
    Copy(buff[MAXIMUS]+Offset,showText);//讲中间文字信息复制到缓冲器
    <br/>
    if(l%2==1)//如果中间文字长度为半角奇数，则补上空格，避免混乱
    <br/>
    {
    <br/>
    *(buff[MAXIMUS]+Offset+l)=0x20;
    <br/>
    }
    <br/>
    system("cls");//清理屏幕，准备写入
    <br/>
    for(i=0;i&lt;MAXIMUS*2+1;i++){//循环写入每一行
    <br/>
    printf("%s",buff[i]);
    <br/>
    if(i&lt;MAXIMUS*2)//写入完每一行需要换行
    <br/>
    printf("\n");
    <br/>
    }
    <br/>
    }
    <br/>
    void Print()//将整个棋盘算出并储存到缓冲器，然后调用Display函数显示出来
    <br/>
    {
    <br/>
    int i,j;//循环变量
    <br/>
    wl=0;
    <br/>
    wp=0;
    <br/>
    for(j=0;j&lt;=MAXIMUS;j++)//写入出交点左上角的字符，因为需要打印棋盘右下角，所以很以横纵各多一次循环
    <br/>
    {
    <br/>
    for(i=0;i&lt;=MAXIMUS;i++)
    <br/>
    {
    <br/>
    write(getCurse(i,j));//写入左上角字符
    <br/>
    if(j==0||j==MAXIMUS)//如果是棋上下盘边缘则没有连接的竖线，用空格填充位置
    <br/>
    {
    <br/>
    if(i!=MAXIMUS)
    <br/>
    write("　");
    <br/>
    }
    <br/>
    else//如果在棋盘中间则用竖线承接上下
    <br/>
    {
    <br/>
    if(i==0||i==MAXIMUS-1)//左右边缘的竖线更粗
    <br/>
    write("┃");
    <br/>
    else if(i!=MAXIMUS)//中间的竖线
    <br/>
    write("│");
    <br/>
    }
    <br/>
    }
    <br/>
    if(j==MAXIMUS)//如果是最后一次循环，则只需要处理边侧字符，交点要少一排
    <br/>
    {
    <br/>
    break;
    <br/>
    }
    <br/>
    ln();//提行开始打印交点内容
    <br/>
    write("　");//用空位补齐位置
    <br/>
    for(i=0;i&lt;MAXIMUS;i++)//按横坐标循环正常的次数
    <br/>
    {
    <br/>
    write(getStyle(i,j));//写入交点字符
    <br/>
    if(i!=MAXIMUS-1)//如果不在最右侧则补充一个横线承接左右
    <br/>
    {
    <br/>
    if(j==0||j==MAXIMUS-1)
    <br/>
    {
    <br/>
    write("━");//上下边缘的横线更粗
    <br/>
    }
    <br/>
    else
    <br/>
    {
    <br/>
    write("—");//中间的横线
    <br/>
    }
    <br/>
    }
    <br/>
    }
    <br/>
    ln();//写完一行后提行
    <br/>
    }
    <br/>
    Display();//将缓冲器内容输出到屏幕
    <br/>
    }
    <br/>
    int Put(){//在当前光标位置走子，如果非空，则返回0表示失败
    <br/>
    if(p[Cx][Cy]==0)
    <br/>
    {
    <br/>
    p[Cx][Cy]=Now;//改变该位置数据
    <br/>
    return 1;//返回1表示成功
    <br/>
    }
    <br/>
    else
    <br/>
    {
    <br/>
    return 0;
    <br/>
    }
    <br/>
    }
    <br/>
    int Check()//胜负检查，即判断当前走子位置有没有造成五连珠的情况
    <br/>
    {
    <br/>
    int w=1,x=1,y=1,z=1,i;//累计横竖正斜反邪四个方向的连续相同棋子数目
    <br/>
    for(i=1;i&lt;5;i++)if(Cy+i&lt;MAXIMUS&amp;&amp;p[Cx][Cy+i]==Now)w++;else break;//向下检查
    <br/>
    for(i=1;i&lt;5;i++)if(Cy-i&gt;0&amp;&amp;p[Cx][Cy-i]==Now)w++;else break;//向上检查
    <br/>
    if(w&gt;=5)return Now;//若果达到5个则判断当前走子玩家为赢家
    <br/>
    for(i=1;i&lt;5;i++)if(Cx+i&lt;MAXIMUS&amp;&amp;p[Cx+i][Cy]==Now)x++;else break;//向右检查
    <br/>
    for(i=1;i&lt;5;i++)if(Cx-i&gt;0&amp;&amp;p[Cx-i][Cy]==Now)x++;else break;//向左检查
    <br/>
    if(x&gt;=5)return Now;//若果达到5个则判断当前走子玩家为赢家
    <br/>
    for(i=1;i&lt;5;i++)if(Cx+i&lt;MAXIMUS&amp;&amp;Cy+i&lt;MAXIMUS&amp;&amp;p[Cx+i][Cy+i]==Now)y++;else break;//向右下检查
    <br/>
    for(i=1;i&lt;5;i++)if(Cx-i&gt;0&amp;&amp;Cy-i&gt;0&amp;&amp;p[Cx-i][Cy-i]==Now)y++;else break;//向左上检查
    <br/>
    if(y&gt;=5)return Now;//若果达到5个则判断当前走子玩家为赢家
    <br/>
    for(i=1;i&lt;5;i++)if(Cx+i&lt;MAXIMUS&amp;&amp;Cy-i&gt;0&amp;&amp;p[Cx+i][Cy-i]==Now)z++;else break;//向右上检查
    <br/>
    for(i=1;i&lt;5;i++)if(Cx-i&gt;0&amp;&amp;Cy+i&lt;MAXIMUS&amp;&amp;p[Cx-i][Cy+i]==Now)z++;else break;//向左下检查
    <br/>
    if(z&gt;=5)return Now;//若果达到5个则判断当前走子玩家为赢家
    <br/>
    return 0;//若没有检查到五连珠，则返回0表示还没有玩家达成胜利
    <br/>
    }
    <br/>
    int RunGame()//进行整个对局，返回赢家信息(虽然有用上)
    <br/>
    {
    <br/>
    int input;//输入变量
    <br/>
    int victor;//赢家信息
    <br/>
    Initialize();//初始化对局
    <br/>
    while(1){//开始无限回合的死循环，直到出现胜利跳出
    <br/>
    Print();//打印棋盘
    <br/>
    input=getch();//等待键盘按下一个字符
    <br/>
    if(input==27)//如果是ESC则退出程序
    <br/>
    {
    <br/>
    exit(0);
    <br/>
    }
    <br/>
    else if(input==0x20)//如果是空格则开始走子
    <br/>
    {
    <br/>
    if(Put())//如果走子成功则判断胜负
    <br/>
    {
    <br/>
    victor=Check();
    <br/>
    Now=3-Now;//轮换当前走子玩家
    <br/>
    count++;
    <br/>
    if(victor==1)//如果黑方达到胜利，显示提示文字并等待一次按键，返回胜利信息
    <br/>
    {
    <br/>
    showText="黑方获得了胜利！";
    <br/>
    Print();
    <br/>
    if(getch()==0xE0)
    <br/>
    {
    <br/>
    getch();
    <br/>
    }
    <br/>
    return Now;
    <br/>
    }
    <br/>
    else if(victor==2)//如果白方达到胜利，显示提示文字并等待一次按键，返回胜利信息
    <br/>
    {
    <br/>
    showText="白方获得了胜利！";
    <br/>
    Display();
    <br/>
    if(getch()==0xE0)
    <br/>
    {
    <br/>
    getch();
    <br/>
    }
    <br/>
    return Now;
    <br/>
    }else if(count==MAXIMUS*MAXIMUS)//如果回合数达到了棋盘总量，即棋盘充满，即为平局
    <br/>
    {
    <br/>
    showText="平局！";
    <br/>
    Display();
    <br/>
    if(getch()==0xE0)
    <br/>
    {
    <br/>
    getch();
    <br/>
    }
    <br/>
    return 0;
    <br/>
    }
    <br/>
    }
    <br/>
    }
    <br/>
    else if(input==0xE0)//如果按下的是方向键，会填充两次输入，第一次为0xE0表示按下的是控制键
    <br/>
    {
    <br/>
    input=getch();//获得第二次输入信息
    <br/>
    switch(input)//判断方向键方向并移动光标位置
    <br/>
    {
    <br/>
    case 0x4B://
    <br/>
    Cx--;
    <br/>
    break;
    <br/>
    case 0x48:
    <br/>
    Cy--;
    <br/>
    break;
    <br/>
    case 0x4D:
    <br/>
    Cx++;
    <br/>
    break;
    <br/>
    case 0x50:
    <br/>
    Cy++;
    <br/>
    break;
    <br/>
    }
    <br/>
    if(Cx&lt;0)Cx=MAXIMUS-1;//如果光标位置越界则移动到对侧
    <br/>
    if(Cy&lt;0)Cy=MAXIMUS-1;
    <br/>
    if(Cx&gt;MAXIMUS-1)Cx=0;
    <br/>
    if(Cy&gt;MAXIMUS-1)Cy=0;
    <br/>
    }
    <br/>
    }
    <br/>
    }
    <br/>
    int main()//主函数
    <br/>
    {
    <br/>
    system("title 简易五子棋 ——Etsnarl制作");//设置标题
    <br/>
    system("mode con cols=63 lines=32");//设置窗口大小
    <br/>
    system("color A1");//设置颜色
    <br/>
    while(1){//循环执行游戏
    <br/>
    RunGame();
    <br/>
    }
    <br/>
    <p>
     }
    </p>
    <p>
     <span style="color:#ff0000">
      运行结果
     </span>
    </p>
    <p>
     <span style="color:#ff0000">
      <img alt="" src="https://img-blog.csdn.net/20160216214538721">
       <br/>
      </img>
     </span>
    </p>
    <p>
     <span style="color:#ff0000">
      嘻嘻，有兴趣的朋友试一下吧！
     </span>
    </p>
    <p>
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3333373638323630:2f61727469636c652f64657461696c732f3530363736393837" class_="artid" style="display:none">
 </p>
</div>


