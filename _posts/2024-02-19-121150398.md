---
layout: post
title: "C语言基于Easyx库实现连连看小游戏"
date: 2024-02-19 14:05:21 +0800
description: "EasyX 是针对 C++ 的图形库，可以帮助 C/C++ 初学者快速上手图形和游戏编程。通过查阅E"
keywords: "连连看图片带掩码图"
categories: ["未分类"]
tags: ["C"]
artid: "121150398"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=121150398
  alt: "C语言基于Easyx库实现连连看小游戏"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言：基于Easyx库实现连连看小游戏
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     EasyX 是针对 C++ 的图形库，可以帮助 C/C++ 初学者快速上手图形和游戏编程。通过查阅Easyx的官方文档我们可以很快速的上手并编写一些小游戏，如贪吃蛇、连连看等。本文章实现用C语言基于Easyx库，编写一个简单的连连看小游戏。
    </p>
    <p>
     <strong>
      代码部分
     </strong>
    </p>
    <blockquote>
     <p>
      先是一些头文件、宏定义等，方便后续修改游戏相关设置
     </p>
    </blockquote>
    <pre><code>#include&lt;time.h&gt;
#define MAP_SIZE 10 //每一行有多少张图片
#define IMG_SIZE 39 //每张图片的宽度
#define WIDTH (MAP_SIZE +2) * IMG_SIZE //窗口的宽度
#define ANIMAL_NUM 42 //图片的总个数

int map[MAP_SIZE + 2][MAP_SIZE + 2];
int way[MAP_SIZE + 2][MAP_SIZE + 2];
IMAGE img_bk;
IMAGE img_Animal[ANIMAL_NUM][2];
struct Index
{
int row;
int col;
}begin = { 1, -1 }, end = { -1, -1 };
enum Cur
{
BEGIN,
END
};
int step = 0;
Cur state = BEGIN;</code></pre>
<blockquote>
<p>
这部分是游戏初始化的函数
</p>
</blockquote>
<pre><code>void gameInit()
{
//设置随机数种子
srand((unsigned)time(NULL));
//用不同的数据表示不同的图片，每种图片来 10 个，一共需要 10 种图片
for (int i = 1; i &lt;= MAP_SIZE; i++)
{
for (int k = 1; k &lt;= MAP_SIZE; k++)
{
map[i][k] = i; //10 个 i
}
}
//加载图片
loadimage(&amp;img_bk,"./ref/bk.jpg",WIDTH+80,WIDTH+50); //后两个参数用来调整背景图片的位置
IMAGE animal;
loadimage(&amp;animal, "./ref/animal.bmp"); //bmp
//如何切割图片
SetWorkingImage(&amp;animal); //设置工作区
for (int i = 0; i &lt; ANIMAL_NUM; i++)
{
for (int k = 0; k &lt; 2; k++)
{
getimage(&amp;img_Animal[i][k], k _ IMG_SIZE, i _ IMG_SIZE, IMG_SIZE, IMG_SIZE);
}
}
SetWorkingImage(); //恢复默认工作区
//打乱数组排列，让图片也随机排列
for (int i = 1; i &lt;= MAP_SIZE; i++)
{
for (int k = 1; k &lt;= MAP_SIZE; k++)
{
//随即找到两个游戏区域的下标位置，然后交换值 随机函数 rand()
int x = rand() % MAP_SIZE + 1;
int y= rand() % MAP_SIZE + 1;
int \_swap = map[i][k];
map[i][k] = map[x][y];
map[x][y] = \_swap;
}
}
}</code></pre>
<p>
<span style="color:#fe2c24;">
我们使用一个二维数组来存储图片的位置信息，为了使每次运行程序时图片的排列方式不同，因此设置了一个随机数种子。
</span>
</p>
<blockquote>
<p>
游戏图形的绘制
</p>
</blockquote>
<pre><code>void gameDraw()
{
putimage(0, 0, &amp;img_bk);
for (int i = 1; i &lt;= MAP_SIZE; i++)
{
for (int k = 1; k &lt;= MAP_SIZE; k++)
{
if (map[i][k] != 0)
{
putimage(k _ IMG_SIZE, i _ IMG_SIZE, &amp;img_Animal[map[i][k]][1], SRCAND); //原图
putimage(k _ IMG_SIZE, i _ IMG_SIZE, &amp;img_Animal[map[i][k]][0], SRCPAINT); //掩码图
}
}
}
}</code></pre>
<blockquote>
<p>
获取鼠标消息，获取点击的两个位置的下标
</p>
</blockquote>
<p>
</p>
<pre><code>void mouseEvent()
{
if (MouseHit())
{
MOUSEMSG msg = GetMouseMsg();
//判断鼠标点击的位置(begin,end)
if (msg.uMsg == WM_LBUTTONDOWN &amp;&amp; state == BEGIN)
{
//把鼠标的坐标转成对应的数组的下标
begin.col = msg.x / IMG_SIZE;
begin.row = msg.y / IMG_SIZE;
end.col = -1;
end.row = -1;
state = END; //改变状态
}
else if (msg.uMsg == WM_LBUTTONDOWN &amp;&amp; state == END)
{
end.col = msg.x / IMG_SIZE;
end.row = msg.y / IMG_SIZE;
state = BEGIN; //改变状态
}
if (msg.uMsg == WM_LBUTTONDOWN)
{
printf("begin(%d,%d) end(%d,%d)\n", begin.col, begin.row, end.col, end.row);
}
}
}</code></pre>
<blockquote>
<p>
判断某个位置是否有图片
</p>
</blockquote>
<pre><code>bool isBlock(int row, int col)
{
if (row &lt; 0 || col &lt; 0 || row &gt;= MAP_SIZE + 2 || col &gt;= MAP_SIZE + 2)
return 1;
return map[row][col] + way[row][col];
}</code></pre>
<blockquote>
<p>
在控制台打印出二维数组（为了后续观察寻路器的运作）
</p>
</blockquote>
<pre><code>void showMap()
{
for (int i = 0; i &lt; MAP_SIZE + 2; i++)
{
for (int k = 0; k &lt; MAP_SIZE + 2; k++)
{
printf("%-2d ", map[i][k]);
}
printf("\n");
}
}</code></pre>
<blockquote>
<p>
判断鼠标点击的起点和终点是否一致
</p>
</blockquote>
<pre><code>bool same(int begin_x, int begin_y, int end_x, int end_y)
{
if (begin_x &lt; 0 || begin_y &lt; 0 || end_x &lt; 0 || end_y &lt; 0 || end_x &gt;= MAP_SIZE + 2 || end_y &gt;= MAP_SIZE + 2 || begin_x &gt;= MAP_SIZE + 2 || begin_y &gt;= MAP_SIZE + 2)
return false;
if (begin_x == end_x &amp;&amp; begin_y == end_y)
return true;
return false;
}</code></pre>
<blockquote>
<p>
判断是否满足消除条件
</p>
</blockquote>
<pre><code>bool can_pass(int begin_x, int begin_y, int end_x, int end_y)
{
if (state != BEGIN || begin_x &lt; 0 || begin_y &lt; 0 || end_x &lt; 0 || end_y &lt; 0 || end_x &gt;= MAP_SIZE + 2 || end_y &gt;= MAP_SIZE + 2 || begin_x &gt;= MAP_SIZE + 2 || begin_y &gt;= MAP_SIZE + 2)
return false;
if (begin_x == end_x &amp;&amp; begin_y == end_y)
return false;
if (map[begin.row][begin.col] != map[end.row][end.col])
return false;
return true;
}</code></pre>
<blockquote>
<p>
使用 A\*寻路算法进行递归寻路消除
</p>
</blockquote>
<pre><code>bool can(int begin_x, int begin_y, int end_x, int end_y)
{
printf("step:%d (%d,%d)-&gt;(%d,%d)\n", step, begin_x, begin_y, end_x, end_y);
if (step++ &gt; 2000) //当找路太多了
return false;
if (begin_x &lt; 0 || begin_y &lt; 0 || end_x &lt; 0 || end_y &lt; 0 || end_x &gt;= MAP_SIZE + 2 || end_y &gt;= MAP_SIZE + 2 || begin_x &gt;= MAP_SIZE + 2 || begin_y &gt;= MAP_SIZE + 2)
return false;
if (same(begin_x, begin_y, end_x, end_y) || same(begin_x - 1, begin_y, end_x, end_y) || same(begin_x + 1, begin_y, end_x, end_y) || same(begin_x, begin_y - 1, end_x, end_y) || same(begin_x, begin_y + 1, end_x, end_y))
return true;
if (!isBlock(begin_x - 1, begin_y)) //1
{
way[begin_x - 1][begin_y] = 1;
if (can(begin_x - 1, begin_y, end_x, end_y))
return true;
way[begin_x - 1][begin_y] = 0;
}
if (!isBlock(begin_x, begin_y - 1)) //3
{
way[begin_x][begin_y - 1] = 1;
if (can(begin_x, begin_y - 1, end_x, end_y))
return true;
way[begin_x][begin_y - 1] = 0;
}
if (!isBlock(begin_x + 1, begin_y)) //2
{
way[begin_x + 1][begin_y] = 1;
if (can(begin_x + 1, begin_y, end_x, end_y))
return true;
way[begin_x + 1][begin_y] = 0;
}
if (!isBlock(begin_x, begin_y + 1)) //4
{
way[begin_x][begin_y + 1] = 1;
if (can(begin_x, begin_y + 1, end_x, end_y))
return true;
way[begin_x][begin_y + 1] = 0;
}
return false;
}</code></pre>
<blockquote>
<p>
主函数部分
</p>
</blockquote>
<pre><code>int main()
{
//首先需要我们自己创建一个图形窗口
initgraph(WIDTH, WIDTH, SHOWCONSOLE);
gameInit();
showMap();
while (1)
{
//开始双缓冲绘图
BeginBatchDraw();
gameDraw();
//结束双缓冲绘图
EndBatchDraw();
if (can_pass(begin.row, begin.col, end.row, end.col))
{
memset(way, 0, sizeof(way));
way[begin.row][begin.col] = 1;
step = 0;
printf("inininininin");
if (can(begin.row, begin.col, end.row, end.col))
{
map[begin.row][begin.col] = 0;
map[end.row][end.col] = 0;
begin.row = -1;
begin.col = -1;
end.row = -1;
end.col = -1;
}
}
mouseEvent();
}
getchar();
return 0;
}</code></pre>
<p>
使用双缓冲绘图防止闪烁
</p>
<p>
<strong>
运行结果
</strong>
</p>
<p>
<img alt="" height="638" src="https://i-blog.csdnimg.cn/blog_migrate/398110dc67a3414a94a0a9d845d57114.png" width="1200"/>
</p>
<p>
<img alt="" height="638" src="https://i-blog.csdnimg.cn/blog_migrate/64ed38ade60d144ce242b61c03621fca.png" width="1200"/>
</p>
<p>
</p>
<p>
<span style="color:#fe2c24;">
（背景图片和连连看内容图片可以自行更换，这里背景我随便放了一张球星照片，注意连连看图片要同时制作其掩码图以实现透明效果）
</span>
</p>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313330323737392f:61727469636c652f64657461696c732f313231313530333938" class_="artid" style="display:none">
 </p>
</div>
