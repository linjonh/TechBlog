---
layout: post
title: "计算机三级数据库技术复习资料总结"
date: 2024-08-17 12:30:16 +0800
description: "第7章 数据库及数据库对象一、创建及维护数据库1、两大类：系统数据库 （自动创建和维护的）：mast"
keywords: "带exists谓词的查询是先外后内,即先执行外层查询,再执行内层查询"
categories: ["未分类"]
tags: ["数据库"]
artid: "109276263"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=109276263
  alt: "计算机三级数据库技术复习资料总结"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     计算机三级数据库技术复习资料总结
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <a href="https://blog.csdn.net/cenrc/article/details/115000688">
      参考、常忘知识点总结
     </a>
    </p>
    <h4>
     <a id="1__2">
     </a>
     第1章 数据库应用系统开发方法
    </h4>
    <h6>
     <a id="_3">
     </a>
     一、系统规划与定义：
    </h6>
    <p>
     1、任务陈述。
     <br/>
     2、确定任务目标。
     <br/>
     3、确定系统范围和边界。
     <br/>
     4、确定用户视图。
    </p>
    <h5>
     <a id="_8">
     </a>
     二、可行性分区：
    </h5>
    <p>
     1、经济可行性。
     <br/>
     2、技术可行性。
     <br/>
     3、操作可行性。（各种人员资源，常考选择题）
     <br/>
     4、开发方案选择。
    </p>
    <h5>
     <a id="_14">
     </a>
     三、数据字典：
    </h5>
    <p>
     1、数据项。
     <br/>
     2、数据结构。
     <br/>
     3、数据流。
     <br/>
     4、数据存储。
     <br/>
     5、处理过程。
    </p>
    <h6>
     <a id="_21">
     </a>
     四、数据处理需求（事务规范）：
    </h6>
    <p>
     1、事务名称。
     <br/>
     2、事务描述。
     <br/>
     3、事务所访问的数据项。
     <br/>
     4、事务用户。
     <br/>
     注意：事务隔离级别不属于事务规范。（选择题）
    </p>
    <h6>
     <a id="_28">
     </a>
     五、性能指标：
    </h6>
    <p>
     1、数据操作响应时间。
     <br/>
     2、系统吞吐量。
     <br/>
     3、允许并发访问的最大用户数。
     <br/>
     4、每TPS代价值。用于衡量系统
     <strong>
      性价比
     </strong>
     的指标。
    </p>
    <h5>
     <a id="_34">
     </a>
     六、系统设计：
    </h5>
    <p>
     1、概念设计。（ER图）
     <br/>
     2、逻辑设计。（ER图转关系模式）
     <br/>
     包括：数据库逻辑结构设计、应用程序概要设计、数据库事务概要设计。
     <br/>
     3、物理设计。（具体实现）
    </p>
    <h5>
     <a id="_40">
     </a>
     七、实现与部署：
    </h5>
    <p>
     1、建立数据库结构。
     <br/>
     2、数据加载。
     <br/>
     3、事务和应用程序的编码及测试。
     <br/>
     4、系统集成、测试与试运行。
     <br/>
     5、系统部署。
    </p>
    <hr/>
    <h4>
     <a id="2__50">
     </a>
     第2章 需求分析
    </h4>
    <h6>
     <a id="_51">
     </a>
     一、获取需求的方法：
    </h6>
    <p>
     1、面谈。
     <br/>
     2、实地观察。
     <br/>
     3、问卷调查。
     <br/>
     4、查阅资料。
    </p>
    <h5>
     <a id="_57">
     </a>
     二、软件需求说明书：
    </h5>
    <p>
     1、需求概述。
     <br/>
     2、功能需求。（常考区分功能需求与非功能需求）
     <br/>
     3、信息需求。
     <br/>
     4、性能需求。
     <br/>
     5、环境需求。（运行环境）
     <br/>
     6、其他需求。
    </p>
    <h5>
     <a id="DFDIDEF0UML_65">
     </a>
     三、三种需求分析方法：DFD、IDEF0、UML。
    </h5>
    <p>
     <strong>
      DFD建模方法：
     </strong>
     过程建模和功能建模方法
    </p>
    <p>
     都是结构化分析思路。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        DFD（自顶向下逐步细化）
       </th>
       <th>
        IDEF0
       </th>
       <th>
        UNM
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        数据流（核心）、处理 、数据存储、外部项。
       </td>
       <td>
        箭头（强调数据约束）、矩形框（活动）
       </td>
       <td>
        系统、角色、用例
       </td>
      </tr>
      <tr>
       <td>
        <img alt="图片1" src="https://i-blog.csdnimg.cn/blog_migrate/8e641cc79a104844a1f44c3a63dcee4d.jpeg#pic_center"/>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <img alt="图片2" src="https://i-blog.csdnimg.cn/blog_migrate/943945bf96de27ca357997052c688754.png#pic_center"/>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="3_80">
     </a>
     第3章、数据库结构设计
    </h4>
    <h6>
     <a id="_81">
     </a>
     一、数据库概念设计：
    </h6>
    <p>
     <strong>
      两种数据建模方法：
     </strong>
     ER建模方法、IDEF1X建模方法
    </p>
    <h6>
     <a id="1ER_84">
     </a>
     1、ER建模方法：第一大题
    </h6>
    <h6>
     <a id="2IDEF1X%09_85">
     </a>
     2、IDEF1X 建模方法：
    </h6>
    <p>
     a、实体集：独立实体集（矩形框）、从属实体集（加圆角矩形框）。
     <br/>
     b、联系：
     <br/>
     ①、标定型联系：两个实例确定第三个实例。（
     <strong>
      实线连接
     </strong>
     ）
     <br/>
     ②、非标定型联系：唯一实例确定。（
     <strong>
      虚线连接
     </strong>
     ）
     <br/>
     ③、分类联系：如学生可以是大学生、高中生、初中生。
     <br/>
     ④、分确定联系：多对多关系
    </p>
    <h5>
     <a id="ER_92">
     </a>
     二、数据库逻辑设计（ER图转关系模式）
    </h5>
    <h5>
     <a id="_93">
     </a>
     三、数据库物理设计：
    </h5>
    <h6>
     <a id="1_95">
     </a>
     1、索引：
    </h6>
    <p>
     <strong>
      两大类：有序索引、散列索引
     </strong>
     <br/>
     a、有序索引又可以分为：
     <br/>
     ①、聚集索引与非聚集索引：排列顺序相一致
     <strong>
      或
     </strong>
     不一致。
     <br/>
     ②、稠密索引与稀疏索引：每个查找码都对应一个索引记录
     <strong>
      或
     </strong>
     只是一部分对应。
     <br/>
     ③、主索引与辅索引：建立在主键上
     <strong>
      或
     </strong>
     非主键上。
     <br/>
     ④、唯一索引：确保索引列不包含重复的值。
     <br/>
     ⑤、单层索引与多层索引：没刷到过题。
    </p>
    <h6>
     <a id="2_104">
     </a>
     2、物理设计内容：
    </h6>
    <p>
     a、数据库逻辑模式描述。（关系模式转换成基本表）
     <br/>
     b、文件组织与存取设计。
     <br/>
     c、数据分布设计。
     <br/>
     d、确定系统配置。
     <br/>
     e、物理模式评估。
    </p>
    <p>
     <strong>
      基本表选择合适的文件结构原则：
     </strong>
     <br/>
     ①堆文件：数据量少，更新频繁。
     <br/>
     ②顺序文件：查询条件在查找码上。
     <br/>
     ③散列文件：访问顺序随机，
     <strong>
      并且没有以下情况：
     </strong>
     <br/>
     a、基于散列域值的非精确查询（模糊查询、范围查询）。
     <br/>
     b、基于非散列域进行的查询。
     <br/>
     ④B-数和B+数文件：大数据量的基本表、等值查询、范围查询、模糊查询、部分查询。
     <br/>
     ⑤聚集文件：频繁执行且进行多表连接操作的查询。
    </p>
    <p>
     <strong>
      适合建立索引原则：
     </strong>
     <br/>
     ①、表的主键。
     <br/>
     ②、在where查询子句中引用率较高的属性。
     <br/>
     ③、参与连接的属性。
     <br/>
     ④、group by 与 order by 子句中的属性。
     <br/>
     ⑤、对于经常需要进行查询、连接、统计操作，且数据量大的基本表。
    </p>
    <hr/>
    <h4>
     <a id="4__129">
     </a>
     第4章 数据库应用系统设计与实施
    </h4>
    <h5>
     <a id="DBAS_130">
     </a>
     一、DBAS体系结构设计
    </h5>
    <h6>
     <a id="1___C__S_131">
     </a>
     1、客户 / 服务器体系结构（两层 C / S）
    </h6>
    <h6>
     <a id="2____B__S_132">
     </a>
     2、浏览器 / 服务器结构 （三层 B / S）
    </h6>
    <p>
     表示层：位于客户端。
     <br/>
     功能层：位于Web应用服务器。
     <br/>
     数据层：位于数据库服务器。
    </p>
    <h5>
     <a id="DBAS_136">
     </a>
     二、DBAS功能概要设计
    </h5>
    <p>
     <strong>
      从功能角度划分
     </strong>
     <br/>
     1、表示层：进行人机界面设计。
     <br/>
     2、数据逻辑层：梳理DBAS的各项业务活动，减去表示为各种系统架构。传输数据的作用。
     <br/>
     高内聚，松耦合原则：
     <br/>
     a、单一责任原则。
     <br/>
     b、各个构件均应具有独立的功能。
     <br/>
     c、构件之间的接口应尽量简单明确。
     <br/>
     d、构件间关系比较复杂，进一步模块划分。
     <br/>
     e、构件间关系过于复杂，细分。
    </p>
    <p>
     3、数据访问层：设计操作数据库的事务。负责与DBMS系统进行交互。
     <br/>
     4、数据持久层：进行应用系统的存储结构设计。保存和管理应用系统数据。
    </p>
    <p>
     <strong>
      事务设计：
     </strong>
     <br/>
     1、事务规范（数据处理需求）：事务名称、事务描述、事务所访问的数据项、事务用户等。
     <br/>
     2、两个元操作：read、write
     <br/>
     3、事务隔离性级别越高，安全性越高，性能越低，同时事务的隔离级别和数据库并发性是对立的。
     <br/>
     4数据库的一致性：事务执行成功则全部提交，如果一个事务提交失败，则做过的所有更新则全部撤销。
    </p>
    <h5>
     <a id="_156">
     </a>
     三、安全架构设计
    </h5>
    <p>
     安全可靠性是应用系统的重要衡量指标。
    </p>
    <h6>
     <a id="1_159">
     </a>
     1、数据安全设计
    </h6>
    <p>
     <strong>
      数据库的安全性保护：
     </strong>
     <br/>
     a、用户身份鉴别。
     <br/>
     b、权限控制。
     <br/>
     c、视图机制。
    </p>
    <p>
     <strong>
      数据库的完整性保护：
     </strong>
     <br/>
     完整性：是指数据库中数据的正确性、一致性、相容性。
     <br/>
     方法：设置完整性检查。
     <br/>
     检查数据表时（select等）不会检查数据的完整性约束。
    </p>
    <p>
     <strong>
      两段锁协议：
     </strong>
     指所有事务必须分两个阶段对数据项加锁和解锁。
     <br/>
     1、在对任何数据进行读、写操作之前，要申请并获得对该数据的封锁。
     <br/>
     2、在释放一个封锁之后，事务不再申请和获得其他任何封锁。
     <br/>
     可以证明，若并发执行的素有事务均遵守两段锁协议。则对这些事务的任何并发调度策略都是
     <strong>
      可串行化
     </strong>
     的。
     <br/>
     也可能发生死锁。
     <br/>
     加锁协议事务可以申请获得任何数据项的任何类型的锁，但不允许释放任何锁。
     <br/>
     <strong>
      一次封锁法：
     </strong>
     要求每个事务必须一次将所有要使用的数据全部加锁。一次封锁法遵守两段锁协议，但两段锁协议并不要求一次全加锁。
    </p>
    <p>
     <strong>
      三级加锁协议
     </strong>
     ：保证数据的一致性。
     <br/>
     <strong>
      检测死锁
     </strong>
     ：检测
     <strong>
      事务等待图
     </strong>
     是否出现回路。
    </p>
    <p>
     <strong>
      数据库并发控制：
     </strong>
     <br/>
     封锁技术：排它锁（x锁）、共享锁（s锁）
     <br/>
     避免死锁的方法：
     <br/>
     a、按同一顺序访问资源。
     <br/>
     b、避免事务中的用户交互。
     <br/>
     c、采用小事务模式，尽量缩短事务的长度，减少占有锁的时间。
     <br/>
     d、尽量使用记录级别的锁（行锁），少用表级别的锁。
     <br/>
     e、使用绑定连接，使同一应用程序锁打开的两个或多个连接可以相互合作。
    </p>
    <p>
     <strong>
      数据库的备份与恢复：
     </strong>
     <br/>
     a、双机热备。
     <br/>
     b、数据转储。
     <br/>
     c、数据加密存储。
    </p>
    <p>
     <strong>
      数据加密传输：
     </strong>
     <br/>
     a、数字安全证书。
     <br/>
     b、对称密钥加密。
     <br/>
     c、数字签名。
     <br/>
     d、数字信封。
    </p>
    <h6>
     <a id="2_201">
     </a>
     2、环境安全设计
    </h6>
    <p>
     <strong>
      漏洞与补丁
     </strong>
    </p>
    <p>
     <strong>
      计算机病毒保护：
     </strong>
     <br/>
     a、安装杀毒软件，定期查杀病毒。
     <br/>
     b、计算机实时监控。
     <br/>
     <strong>
      网络环境安全：
     </strong>
     <br/>
     a、防火墙。
     <br/>
     b、入侵检测系统。
     <br/>
     c、网络隔离。
    </p>
    <p>
     <strong>
      物理环境安全
     </strong>
    </p>
    <h5>
     <a id="DBAS_214">
     </a>
     四、DBAS实施
    </h5>
    <p>
     <strong>
      1、创建数据库：
     </strong>
     <br/>
     a、初始空间大小。
     <br/>
     b、数据库增量大小。
     <br/>
     c、访问性能。
    </p>
    <p>
     <strong>
      2、数据装载：
     </strong>
     <br/>
     a、筛选数据。
     <br/>
     b、转换数据格式。
     <br/>
     c、输入数据。
     <br/>
     d、校验数据。
     <br/>
     <strong>
      3、编写与调试应用程序
     </strong>
     <br/>
     <strong>
      4、数据库系统试运行：
     </strong>
     <br/>
     a、功能测试。
     <br/>
     b、性能测试。
    </p>
    <hr/>
    <h4>
     <a id="5_UML_233">
     </a>
     第5章 UML与数据库应用系统
    </h4>
    <p>
     <strong>
      UML四层建模概念框架
     </strong>
     <br/>
     1、元元模型层。
     <br/>
     2、元模型层。
     <br/>
     3、模型层。
     <br/>
     4、用户模型层。
    </p>
    <p>
     <strong>
      13种图
     </strong>
     <br/>
     结构图（静态）6种：类图、对象图、复合结构图、包图、组件图、部署图。
     <br/>
     简记：
     <strong>
      类对复包组部
     </strong>
    </p>
    <p>
     行为图（动态）7种：用例图、顺序图、通信图、交互概述图、时间图、状态图、活动图。
     <br/>
     简记：
     <strong>
      用顺通交时状活
     </strong>
    </p>
    <h5>
     <a id="_247">
     </a>
     一、类图：
    </h5>
    <p>
     类图关系：
     <br/>
     泛化：——▷ 父类
     <br/>
     实现：------▷ 接口（被实现类）
     <br/>
     关联：——&gt; 被拥有者
     <br/>
     聚合：——◇ 整体
     <br/>
     组合：——◆ 整体
     <br/>
     依赖：------&gt; 被使用者
    </p>
    <h5>
     <a id="_255">
     </a>
     二、对象图：
    </h5>
    <p>
     系统某个时间的所有对象的
     <strong>
      快照
     </strong>
     。
    </p>
    <h5>
     <a id="_257">
     </a>
     三、复合结构图：
    </h5>
    <p>
     最主要元素：部件。
    </p>
    <h5>
     <a id="_259">
     </a>
     四、包图：
    </h5>
    <p>
     用于表达系统中不同的包、命名空间或不同的项目间彼此关系的图。
     <br/>
     包与包之间不能共享一个相同的模型元素。
    </p>
    <h5>
     <a id="_262">
     </a>
     五、组件图：
    </h5>
    <p>
     表示系统的静态实现视图，展现一组组件之间的组织和依赖。
    </p>
    <h5>
     <a id="_264">
     </a>
     六、部署图：
    </h5>
    <p>
     描述系统运行时的结构，展现硬件的配置及其软件如何部署。只有一个部署图，帮助理解分布式系统。
    </p>
    <h5>
     <a id="_266">
     </a>
     七、用例图：
    </h5>
    <p>
     主要组成： 用例、角色、系统。用例之间的关系：扩展、使用、组合
    </p>
    <h5>
     <a id="_268">
     </a>
     八、顺序图：
    </h5>
    <p>
     强调时间。 用于描述系统内部的动态结构，主要用于描述系统内对象之前的消息发送与接收序列。
    </p>
    <h5>
     <a id="_270">
     </a>
     九、通信图（协作图）：
    </h5>
    <p>
     强调空间。表达对象之前的联系以及对象间发送和接收消息的图。
    </p>
    <h5>
     <a id="_272">
     </a>
     十、交互概述图：
    </h5>
    <p>
     活动图为基础。
    </p>
    <h5>
     <a id="_274">
     </a>
     十一、时间图：
    </h5>
    <p>
     作为状态图的辅助说明工具。
    </p>
    <h5>
     <a id="_276">
     </a>
     十二、状态图：
    </h5>
    <p>
     描述一个对象在其生存期内的动态行为。状态间的转移。状态之间的转移是由
     <strong>
      事件
     </strong>
     驱动的。
    </p>
    <h5>
     <a id="_278">
     </a>
     十三、活动图：
    </h5>
    <p>
     描述系统、用例、程序模块中逻辑流程的先后执行次序。
    </p>
    <hr/>
    <h4>
     <a id="6__288">
     </a>
     第6章 高级数据查询
    </h4>
    <h5>
     <a id="_289">
     </a>
     一、一般数据查询功能扩展
    </h5>
    <h6>
     <a id="1TOP__290">
     </a>
     1、使用TOP 限制结果集
    </h6>
    <p>
     【distinct】 TOP n 【percent】【with ties】
    </p>
    <p>
     distinct ：不重复的
     <br/>
     percent：使用%显示
     <br/>
     whit ties：取并列结果
     <br/>
     通常TOP与order by 排序一起使用
    </p>
    <h6>
     <a id="2case__297">
     </a>
     2、case 函数
    </h6>
    <p>
     <strong>
      简单case函数：
     </strong>
     <br/>
     case 测试表达式
     <br/>
     when 简单表达式1 then 结果表达式
     <br/>
     …
     <br/>
     [ else 结果表达式 ]
     <br/>
     end
    </p>
    <p>
     <strong>
      搜索case函数
     </strong>
     <br/>
     与简单case函数形式的区别是 case 后面不跟有测试表达式
    </p>
    <h6>
     <a id="3into_308">
     </a>
     3、将查询结果保存到新表中（into语句）
    </h6>
    <p>
     <strong>
      select 列名 into 新表名 from …
     </strong>
    </p>
    <p>
     新表可以是永久表，也可以是临时表。
     <br/>
     <strong>
      临时表区别：
     </strong>
     局部临时表（#table）、全局临时表（##table）
    </p>
    <h5>
     <a id="_314">
     </a>
     二、查询结果的并、交、差运算
    </h5>
    <p>
     <strong>
      并运算
     </strong>
     （UNION）：将两表进行垂直连接。
     <br/>
     <strong>
      交运算
     </strong>
     （INTERSECT）：取两表相交部分。
     <br/>
     <strong>
      差运算
     </strong>
     （EXCEPT）：表1 - 表2
    </p>
    <p>
     并交差运算与 join 连接不同的是join是水平合并数据，而并交差则是垂直合并数据。
     <br/>
     常考：选择填空题。
    </p>
    <h5>
     <a id="_322">
     </a>
     三、子查询
    </h5>
    <p>
     运算符 IN 与NOT IN ：将表达式与子查询返回的结果集进行比较。
     <br/>
     比较运算符：子查询返回的必须是单值。
     <br/>
     以上两者都是不相关子查询，即先执行内层查询，在执行外层查询，子查询的查询条件不依赖外层循环。
     <br/>
     <strong>
      使用子查询进行存在性测试
     </strong>
     <br/>
     关键字：EXISTS 与 NOT EXISTS
     <br/>
     子查询返回的结果为 真值或假值。
     <br/>
     <strong>
      区别
     </strong>
     ：
     <br/>
     带EXISTS谓词的查询是先执行外层查询，然后在执行内层查询。相关子查询。
    </p>
    <h5>
     <a id="_332">
     </a>
     四、聚合函数与开窗函数
    </h5>
    <p>
     <strong>
      聚合函数
     </strong>
     ：SUM、COUNT、AVG、MIN、MAX
     <br/>
     count（*）返回表中的行数，不会过滤null和重复的行，但count（列名）会过滤 null
     <br/>
     <strong>
      开窗函数
     </strong>
     ：OVER（【partition by】，【order by】）
     <br/>
     1、聚合开窗函数
     <br/>
     聚合函数与开窗函数的结合
     <br/>
     如：
     <br/>
     SUM OVER (PARTITON BY 列名)
     <br/>
     …
     <br/>
     2、排序开窗函数
     <br/>
     RANK() ：有重复，但不连续的排名。
     <br/>
     DENSE_RANK()：有重复，但连续的排名。
     <br/>
     NTILE()：不太理解。
     <br/>
     ROW_NUMBER()：不太理解。
    </p>
    <p>
     <strong>
      聚合函数与开窗函数都是位于select 【】 from
     </strong>
    </p>
    <h5>
     <a id="_350">
     </a>
     五、派生表与公用表
    </h5>
    <p>
     1、派生表（内联视图）
     <br/>
     如:（select * form table） AS 别名
    </p>
    <p>
     2、公用表
     <br/>
     如 WITH 公用表名（列名） AS (select * from table)
    </p>
    <p>
     <strong>
      需要死记得关键字：
     </strong>
     distinct（不重复的）、percent（百分比）、with ties （取相同）、UNION(并)、INTERSECT(交)、EXCEPT(差)、EXISTS(存在)。
    </p>
    <hr/>
    <h4>
     <a id="7__362">
     </a>
     第7章 数据库及数据库对象
    </h4>
    <h5>
     <a id="_363">
     </a>
     一、创建及维护数据库
    </h5>
    <h6>
     <a id="1_364">
     </a>
     1、两大类：
    </h6>
    <p>
     <strong>
      系统数据库
     </strong>
     （自动创建和维护的）：
     <br/>
     master：最重要的数据库，记录所有系统级信息，主要的信息都是存放在这。
    </p>
    <p>
     msdb：保存报警、作业、操作员等信息。（考的不多，选择判断题）
    </p>
    <p>
     model：所有创建数据库的模板。
    </p>
    <p>
     tempdb：临时数据库，每次启动SQL都会重新创建，因此
     <strong>
      不需要备份
     </strong>
     。
     <br/>
     用户创建的局部和全局临时表均被自动放置在改数据库中。
    </p>
    <p>
     Resource：只读数据库。（没见过考）
    </p>
    <p>
     <strong>
      用户数据库
     </strong>
     （用户创建和维护）
    </p>
    <p>
     经常考选择题：系统数据库如何备份？（未完成）
    </p>
    <h6>
     <a id="2_380">
     </a>
     2、数据库文件分类
    </h6>
    <p>
     <strong>
      数据文件：
     </strong>
     <br/>
     主要数据文件：每个数据库中
     <strong>
      只有一个
     </strong>
     ，第一个数据文件，推荐扩展名：mdf。
     <br/>
     次要数据文件：可以有
     <strong>
      0~n个
     </strong>
     ，推荐扩展名：ndf.
    </p>
    <p>
     <strong>
      总结
     </strong>
     ：主要数据文件有且只有一个，而次要数据文件可以有0或多个，可以建立在多个磁盘上。两者对用户来说
     <strong>
      没有区别
     </strong>
     ，在多个不同的磁盘中建立多个数据文件，有利于利用存储空间，以及提高数据的存取效率。
    </p>
    <p>
     <strong>
      日志文件
     </strong>
     <br/>
     每个数据库
     <strong>
      至少有一个
     </strong>
     日志文件（创建数据库时，如果没有创建日志文件，系统自动创建日志文件），推荐扩展名：ldf。
    </p>
    <h6>
     <a id="3_391">
     </a>
     3、数据库存储空间的分配
    </h6>
    <p>
     数据库的存储分配单位是
     <strong>
      数据页
     </strong>
     ，其中一数据页的大小是
     <strong>
      8k
     </strong>
     ,一行数据不能存储在不同的数据页中（行不能跨页存储）。
    </p>
    <p>
     经常考填空题：一个数据表中 n 行数据，每行 m 字节，则需要多少MB的存储空间，以及空间利用率为多少？
     <br/>
     解法：n 行数据需要 a 页数据页，则需要 8a MB的存储空间。空间利用率等于：每页数据页实际使用的空间 除以 一页数据页总共的空间。
    </p>
    <h6>
     <a id="4_397">
     </a>
     4、文件组
    </h6>
    <p>
     主文件组：一个数据库只有一个默认文件组，一般默认为Paimary，存放主要数据文件和未明确分配文件组的次要数据文件。
    </p>
    <p>
     特别：
     <br/>
     1、
     <strong>
      日志文件不存放在文件组中
     </strong>
     ，日志空间与数据空间是分开管理的。
     <br/>
     2、一个文件不可是多个文件组的成员。
    </p>
    <p>
     经常考点：主要数据文件、次要数据文件、日志文件可以有多少个？可以存放的位置等问题。
    </p>
    <h6>
     <a id="5_406">
     </a>
     5、创建数据库
    </h6>
    <p>
     create database db_name
     <br/>
     on [指定的文件组]
     <br/>
     （
     <br/>
     name = db_data, //逻辑名
     <br/>
     filename = ‘F:\Data\db_data.mdf’, //物理名
     <br/>
     size = 2mb, //初始大小
     <br/>
     maxsize = 10mb, //最大大小
     <br/>
     filegrowth = 2 //自动增长
     <br/>
     ）
     <br/>
     log on
     <br/>
     (
     <br/>
     …
     <br/>
     )
    </p>
    <h6>
     <a id="6_420">
     </a>
     6、修改数据库
    </h6>
    <p>
     扩大数据库两种方法：
     <br/>
     <strong>
      一：add
     </strong>
     <br/>
     添加数据文件
     <br/>
     alter database db
     <br/>
     add file（
     <br/>
     …与创建数据库时相同
     <br/>
     ）
     <br/>
     添加日志文件
     <br/>
     alter database db
     <br/>
     add log file(
     <br/>
     …
     <br/>
     )
     <br/>
     添加文件组
     <br/>
     alter database db
     <br/>
     add filegroup group_name
    </p>
    <p>
     <strong>
      二：modify
     </strong>
     <br/>
     alter database db
     <br/>
     modify file(
     <br/>
     name = 逻辑名，
     <br/>
     …修改内容
     <br/>
     size =
     <br/>
     filegrowth =
     <br/>
     )
    </p>
    <p>
     收缩数据库空间的两种方法
     <br/>
     文件收缩都是从末尾开始的
     <br/>
     一：收缩整个数据库大小
     <br/>
     DBCC shrinkdatabase (database_name, 大小 )
     <br/>
     二：收缩数据库中某个文件的大小
     <br/>
     DBCC shrinkfile （file_name,大小）
    </p>
    <p>
     删除数据库文件
     <br/>
     alter database db
     <br/>
     remove file file_name
    </p>
    <h6>
     <a id="7_457">
     </a>
     7、分离和附加数据库
    </h6>
    <p>
     分离：从SQL server 实例中删除，但不删除数据库中的数据文件和日志文件。
     <br/>
     EXEC sp_detach_db ‘db_name’,‘true’
    </p>
    <p>
     附加：创建一个新的数据库。。。
    </p>
    <p>
     经常考点选择题：分离数据库是否需要停止数据库。
     <br/>
     1、在分离数据库之前，必须先断开所有用户与该数据库的连接。
     <br/>
     2、分离数据库会分离数据文件和日志文件。
     <br/>
     3、分离和附加的位置可以不同。
     <br/>
     4、进行分离数据库操作不能停止SQL server 服务。
    </p>
    <h5>
     <a id="_469">
     </a>
     二、架构
    </h5>
    <p>
     架构：逻辑命名空间，他是一个数据库对象的容器。
     <strong>
      架构
     </strong>
     相当于文件夹（
     <strong>
      不能同名
     </strong>
     ，可以有多个），
     <strong>
      对象
     </strong>
     相当于文件（不同文件夹下的文件
     <strong>
      可以同名
     </strong>
     ）。
     <br/>
     关键字：
     <br/>
     CASCADE：所有架构对象一起全部删除。
     <br/>
     RESTRICT：包含架构对象则拒绝。
    </p>
    <p>
     创建架构：
     <br/>
     create schema 【架构名】authorizetion 用户名
    </p>
    <p>
     删除架构：
     <br/>
     DROP schema 架构名
    </p>
    <p>
     考点：选择题
    </p>
    <h5>
     <a id="_482">
     </a>
     三、分区表
    </h5>
    <p>
     a、分区表是水平划分的子集。
     <br/>
     b、优点：可以快速且有效地管理和访问数据子集。
     <br/>
     c、
     <strong>
      是否创建分区表？（选择题）
     </strong>
     主要取决于表当前的数据量大小以及将来的数据量大小，同时还取决于对表中数据进行的操作。
     <br/>
     d、物理上将一张大表分成几张小表，逻辑上还是大表。
    </p>
    <h6>
     <a id="1_487">
     </a>
     1、分区表两大步骤
    </h6>
    <p>
     <strong>
      创建分区函数
     </strong>
     ：告诉数据库管理系统以什么方式对表进行分区。
     <br/>
     create partition function PF_name(数据类型)
     <br/>
     as range [ left ] for values(分段1，分段2，分段3)
    </p>
    <p>
     <strong>
      创建分区方案
     </strong>
     ：将分区函数生成的分区映射到文件组中。
     <br/>
     create partition scheme PS_name
     <br/>
     as partiton PF_name
     <br/>
     to(文件组1，文件组2，文件组3，文件组4)
    </p>
    <p>
     PS：指定的文件组数一定要大于或等于分区函数所划分的分区数
    </p>
    <h5>
     <a id="_500">
     </a>
     四、索引
    </h5>
    <p>
     索引的创建：
     <br/>
     关键字：
     <br/>
     UNIQUE：唯一索引。
     <br/>
     CLUSTERED：聚集索引。
     <br/>
     NONCLUSTERED：默认选项，非聚集索引。
    </p>
    <p>
     通常创建唯一聚集索引为：(填空题，加粗字体
     <strong>
      必背
     </strong>
     )
     <br/>
     CREATE
     <strong>
      UNIQUE CLUSTERED
     </strong>
     INDEX index_name ON Table_name(cname)
    </p>
    <p>
     对索引键值进行升降排序：
     <br/>
     ps:系统默认查询结果按升序ASC排序。
     <br/>
     CREATE INDEX index_name ON Table_name(cname1
     <strong>
      ASC,
     </strong>
     cname2
     <strong>
      DESC
     </strong>
     )
    </p>
    <p>
     删除索引：
     <br/>
     DROP INDEX index_name
    </p>
    <h5>
     <a id="_518">
     </a>
     五、索引视图
    </h5>
    <p>
     标准视图（虚拟表）结果集并不存储在数据库中，如果频繁使用这类视图会导致开销很多。
     <br/>
     因此可以对视图创建唯一聚集索引的方式来提高查询性能。
     <br/>
     对视图创建唯一聚集索引后，视图的结果集将存储在数据库中，就像带有聚集索引的表一样。成为
     <strong>
      索引视图（物化视图）
     </strong>
     。
    </p>
    <p>
     做题：
     <br/>
     索引视图可以提高查询类型的性能：
     <br/>
     1、处理大量行的连接和聚合。
     <br/>
     2、查询经常执行连接和聚合。
     <br/>
     3、决策支持工作负荷。
     <br/>
     总结：连接和聚合使用索引视图。
    </p>
    <p>
     4、视图可以在视图上再定义视图。
    </p>
    <p>
     考点：填空题，加粗字体。
    </p>
    <p>
     <strong>
      需要死记得关键字：
     </strong>
     primary（主要的）、create（创建）、filegrowth（增长）、modify（修改）、alter（改变）、DBCC、shrinkdatabase（收缩数据库）、shrinkfile（收缩文件)、remove（移除）、EXEC(执行)、 sp_detach_db(分离数据库)、DROP、schema（架构）、scheme（方案）、partition（划分）、
    </p>
    <hr/>
    <h4>
     <a id="8__544">
     </a>
     第8章 数据库后台编程技术
    </h4>
    <h5>
     <a id="_545">
     </a>
     一、存储过程
    </h5>
    <p>
     存储过程用于存储和执行T-SQL代码。
     <br/>
     好处：
     <br/>
     1、允许模块化程序设计。
     <br/>
     2、改善性能。
     <br/>
     3、减少网络流量。
     <br/>
     4、增强应用程序的安全性。
    </p>
    <p>
     <strong>
      创建存储过程
     </strong>
     <br/>
     create procedure proc_name
     <br/>
     @parameter data_type , …
     <br/>
     @parameter2 type output
     <br/>
     AS
     <br/>
     T-SQL代码
    </p>
    <p>
     <strong>
      执行存储过程
     </strong>
     <br/>
     declare @x int , @y int
     <br/>
     EXEC proc_name ‘输入’ ， @x output,@y output
    </p>
    <p>
     <strong>
      删除存储过程
     </strong>
     <br/>
     DROP PROC name
    </p>
    <h5>
     <a id="_568">
     </a>
     二、用户定义函数
    </h5>
    <h6>
     <a id="_569">
     </a>
     标量函数
    </h6>
    <p>
     返回值
    </p>
    <p>
     <strong>
      创建标量函数
     </strong>
     <br/>
     create function function_name(@parameter)
     <br/>
     returns type
     <br/>
     AS
     <br/>
     begin
     <br/>
     declare @x int
     <br/>
     T-SQL语句
     <br/>
     return @x
     <br/>
     end
    </p>
    <p>
     <strong>
      调用标量函数
     </strong>
     <br/>
     函数拥有者名.函数名
    </p>
    <h6>
     <a id="_585">
     </a>
     内联函数
    </h6>
    <p>
     返回表
    </p>
    <p>
     <strong>
      创建内联表值函数
     </strong>
     <br/>
     create function name(@parameter)
     <br/>
     returns table
     <br/>
     AS
     <br/>
     return (T-SQL)
    </p>
    <h6>
     <a id="_594">
     </a>
     多语句表值函数
    </h6>
    <p>
     <strong>
      创建多语句表值函数
     </strong>
     <br/>
     create function name(@parameter)
     <br/>
     returns @table_name table(
     <br/>
     列名 type,
     <br/>
     …
     <br/>
     )
     <br/>
     AS
     <br/>
     begin
     <br/>
     insert into @table_name
     <br/>
     T-SQL
     <br/>
     <strong>
      return
     </strong>
     <br/>
     end
    </p>
    <p>
     <strong>
      删除用户自定义函数
     </strong>
     <br/>
     DROP FUNCTION name
    </p>
    <h5>
     <a id="_611">
     </a>
     总结：存储过程与用户自定义函数的区别
    </h5>
    <p>
     1、存储过程相当于对复杂T-SQL进行预编译封装。
     <br/>
     2、用户自定义函数相当于其他编程语言中的函数方法。
     <br/>
     区别：
     <br/>
     1、声明时，存储过程参数不需要使用括号，并且在输出参数后使用 output 。
     <br/>
     2、用户自定义函数必须要有retrun返回值。
     <br/>
     3、用户自定义函数一般使用BEGIN和END 将T-SQL语句包围起来。
    </p>
    <h5>
     <a id="_619">
     </a>
     总结：用户自定义函数中的区别
    </h5>
    <p>
     <strong>
      不同：
     </strong>
     <br/>
     1、标量函数返回的是一个值。
     <br/>
     2、内联表值函数返回的是select 查询 的一个表，类似于视图。并且一般不使用BEGIN和END。
     <br/>
     3、多语句表值函数返回的是新定义的表。
     <br/>
     <strong>
      相同：
     </strong>
     <br/>
     1、他们的创建语句基本相同，不同的是返回类型。
     <br/>
     2、调用方法相同。
    </p>
    <h5>
     <a id="_628">
     </a>
     三、触发器
    </h5>
    <p>
     一种特殊的存储过程，不需要由用户来直接调用，自动触发执行。
     <br/>
     SQL Server 2008中有五种约束类型：主键约束、外键约束、唯一约束、缺省约束、检查约束。
     <br/>
     <strong>
      触发器通常用在下列场合：
     </strong>
     <br/>
     1、完成比CHECK约束更复杂的数据约束。（check约束只能实现同一个表中列之间的取值约束）
     <br/>
     2、为了保证数据库性能而维护的非规范化数据。
     <br/>
     3、可实现复杂的商业规则。
     <br/>
     4、触发器也可以评估数据修改前后的表状态，并根据其差异采取对策。
     <br/>
     <strong>
      三种触发器：
     </strong>
     <br/>
     1、DML触发器（只讲）。2、DDL触发器。3、登录触发器。
    </p>
    <p>
     <strong>
      创建触发器
     </strong>
    </p>
    <p>
     create trigger trigger_name
     <br/>
     on table
     <br/>
     for [ after ] [ instead of ]
     <br/>
     操作类型（insert ，updata，delete）
     <br/>
     AS T-SQL
    </p>
    <p>
     <strong>
      触发器的区别：
     </strong>
     <br/>
     1、后触发型触发器：
     <br/>
     使用FOR 或 AFTER 定义的触发器。（即等引发触发器执行的操作都已成功执行才执行触发器操作）
     <br/>
     使用ROLLBACK撤销不正确的操作。（实际是回滚到引发触发器执行的操作之前的状态）
     <br/>
     后触发型触发器同一个操作可以有多个触发器。
     <br/>
     <strong>
      几个用途：
     </strong>
     <br/>
     a、维护数据操作完整性的触发器。
     <br/>
     b、维护不同列之间的取值完整性的触发器。
     <br/>
     c、维护数据的一致性的触发器。
    </p>
    <p>
     2、前触发型触发器：
     <br/>
     使用 INSTEAD OF 选项定义的触发器。（即不执行引发触发器的操作）
     <br/>
     前触发型触发器同一个操作只能有一个触发器。
    </p>
    <p>
     <strong>
      两个特殊的临时工作表：
     </strong>
     <br/>
     INSERTED表与 DELETED表。
     <br/>
     对于三种操作，insert 、updata、delete 的数据存放。
     <br/>
     insert 、delete更新删除的数据存放到对应的表中，而updata操作前的数据存放到DELETED表中，操作后的数据存放到INSERTED表中，updata操作相当于对表数据先进行删除，然后在对表数据进行插入。
    </p>
    <h5>
     <a id="_666">
     </a>
     四、游标
    </h5>
    <p>
     声明游标 --&gt; 打开游标 --&gt; 提取数据 --&gt; 关闭游标 --&gt;释放资源
    </p>
    <p>
     <strong>
      提取数据：
     </strong>
     <br/>
     FETCH
    </p>
    <p>
     <strong>
      需要死记的关键字：
     </strong>
     procedure(程序)、declare(声明)、execute(执行)、trigger（触发）、ROLLBACK(回滚)、for after （后触发型）、instead of （前触发型）
    </p>
    <hr/>
    <h4>
     <a id="9__683">
     </a>
     第9章 安全管理
    </h4>
    <h5>
     <a id="_684">
     </a>
     一、登录账户
    </h5>
    <p>
     <strong>
      创建登录账户：
     </strong>
     <br/>
     create login log_name [ whit | from ] windows 用户名 | password = ‘ ’
    </p>
    <p>
     <strong>
      修改登录账户：
     </strong>
     <br/>
     alter login log_name enable | disable
    </p>
    <p>
     <strong>
      删除登录账户：
     </strong>
     <br/>
     drop login log_name
    </p>
    <h5>
     <a id="_694">
     </a>
     二、数据库用户
    </h5>
    <p>
     <strong>
      建立数据库用户：
     </strong>
     <br/>
     create user user_name
    </p>
    <p>
     <strong>
      删除数据库用户：
     </strong>
     <br/>
     drop user user_name
    </p>
    <h5>
     <a id="Guest__701">
     </a>
     三、Guest 用户
    </h5>
    <p>
     一个特殊的数据库用户。
     <br/>
     <strong>
      启用：具有连接权限
     </strong>
     <br/>
     grant connect to guest;
    </p>
    <p>
     <strong>
      禁用：收回连接权限
     </strong>
     <br/>
     revoke connect to guest
    </p>
    <h5>
     <a id="_709">
     </a>
     四、权限管理
    </h5>
    <p>
     <strong>
      授权语句：
     </strong>
     <br/>
     grant 操作（select、insert、update、delete）on 被授权的对象（表、存储过程等） to 用户
    </p>
    <p>
     <strong>
      拒绝权限：
     </strong>
     <br/>
     deny 操作 on 被被授权对象 to 用户
    </p>
    <p>
     <strong>
      授权语句：
     </strong>
     <br/>
     revoke 操作 on 被授权对象 to 用户
    </p>
    <p>
     <strong>
      语句级别的权限：
     </strong>
     <br/>
     create database
     <br/>
     create procedure
     <br/>
     create table
     <br/>
     create view
     <br/>
     create function
     <br/>
     backup database
     <br/>
     backup log
    </p>
    <h5>
     <a id="_729">
     </a>
     五、角色
    </h5>
    <h6>
     <a id="1_730">
     </a>
     1、固定服务器角色
    </h6>
    <p>
     <strong>
      九大服务器级角色：
     </strong>
     <br/>
     bulkadmin：不常见。
     <br/>
     <strong>
      dbcreator
     </strong>
     ：具有创建、修改、删除和还原数据库的权限。
     <strong>
      常考
     </strong>
     <br/>
     diskadmin：具有管理磁盘的权限。
     <br/>
     processadmin：不常见。
     <br/>
     securityadmin：不常见。
     <br/>
     serveradmin：具有设置服务器级别的配置选项和关闭服务器的权限。
     <br/>
     setupadmin：不常见。
     <br/>
     <strong>
      sysadmin
     </strong>
     ：具有在服务器及数据库上执行任何操作的权限。
     <strong>
      常见
     </strong>
    </p>
    <p>
     <strong>
      授权与删除：
     </strong>
     <br/>
     授权：sp_addsrvrolemember
     <br/>
     删除：sp_dropsrvrolemenber
    </p>
    <p>
     ps：用户和角色语句位置的顺序：
     <strong>
      先用户后角色
     </strong>
    </p>
    <h6>
     <a id="2_747">
     </a>
     2、固定数据库角色
    </h6>
    <p>
     <strong>
      数据库级角色：
     </strong>
     <br/>
     db_accessadmin：具有添加或删除数据库用户的权限。不常见
     <br/>
     db_backupoperator：具有备份数据库、备份日志的权限。不常见
     <br/>
     <strong>
      db_datareader
     </strong>
     ：具有
     <strong>
      查询
     </strong>
     数据库中所有用户数据的权限。
     <br/>
     <strong>
      db_datawriter
     </strong>
     ：具有
     <strong>
      插入、删除、更改
     </strong>
     数据库中所有用户数据的权限。
     <br/>
     db_ddladmin：具有执行数据定义语言（DDL）的权限。
     <br/>
     db_denydatareader：不允许，与db_datareader权限相反。
     <br/>
     db_denydatawriter：不允许，与db_datawriter权限相反。
     <br/>
     <strong>
      db_owner
     </strong>
     ：具有全部操作的权限。
     <br/>
     db_securityadmin：具有管理权限。
    </p>
    <p>
     <strong>
      授权与删除：
     </strong>
     <br/>
     授权：sp_addrolemember
     <br/>
     删除：sp_denyrolemember
    </p>
    <p>
     ps：用户和角色语句位置的顺序：
     <strong>
      先角色后用户
     </strong>
    </p>
    <p>
     <strong>
      共同点：
     </strong>
     固定数据库角色与固定服务器角色都具有一个相同的角色：public
    </p>
    <h6>
     <a id="3_767">
     </a>
     3、用户定义的角色
    </h6>
    <p>
     create role name【authorization】用户或角色
    </p>
    <p>
     <strong>
      需要死记的关键字：
     </strong>
     enable（启用）、disable（禁用）、grant（允许）、revoke（撤回）
    </p>
    <hr/>
    <h4>
     <a id="10__777">
     </a>
     第10章 数据库运行维护与优化
    </h4>
    <h5>
     <a id="_779">
     </a>
     一、维护工作主要包括：
    </h5>
    <h6>
     <a id="1_780">
     </a>
     1、数据库的转储与恢复。
    </h6>
    <p>
     数据库管理员需要定期对转储的数据进行恢复测试工作。
    </p>
    <h6>
     <a id="2_782">
     </a>
     2、数据库的安全性、完整性控制。
    </h6>
    <p>
     通过行政手段制定规范。
    </p>
    <h6>
     <a id="3_784">
     </a>
     3、检测并改善数据库的性能。
    </h6>
    <h6>
     <a id="4_785">
     </a>
     4、数据库的重组与重构。
    </h6>
    <p>
     重组：不修改数据库原有设计的逻辑结构和物理结构。
     <br/>
     重构：部分修改数据库的模式和内模式。
    </p>
    <h5>
     <a id="_789">
     </a>
     二、运行状态监控与分析：
    </h5>
    <p>
     1、自动监控机制。
     <br/>
     2、手动监控机制。
     <br/>
     分为对
     <strong>
      数据库构架体系的监控
     </strong>
     和
     <strong>
      对数据库性能的监控
     </strong>
     。
    </p>
    <h5>
     <a id="_794">
     </a>
     三、数据库性能优化。
    </h5>
    <h6>
     <a id="1_795">
     </a>
     1、外部调整：
    </h6>
    <p>
     当CPU在业务空闲时使用率超过90%，说明服务器缺乏CPU资源。
    </p>
    <h6>
     <a id="2_797">
     </a>
     2、模式调整与优化：
    </h6>
    <p>
     a、增加派生性冗余列。（总价=单价*数量）
     <br/>
     b、增加冗余列。
     <br/>
     c、重新组表。
     <br/>
     d、分割表。
     <br/>
     e、新增汇总表。
    </p>
    <h6>
     <a id="3_803">
     </a>
     3、存储优化：
    </h6>
    <p>
     a、物化视图。
     <br/>
     b、聚集。
    </p>
    <h6>
     <a id="4_806">
     </a>
     4、查询优化：
    </h6>
    <p>
     a、合理使用索引。
     <br/>
     b、避免或简化排序。
     <br/>
     c、消除对大型表数据的顺序存取。
     <br/>
     d、避免复杂的正则表达式。
     <br/>
     e、使用临时表加速查询。
     <br/>
     f、用排序来取代非顺序磁盘存取。
     <br/>
     g、不充分的连接条件。
     <br/>
     h、存储过程。
     <br/>
     i、不要随意使用游标。
     <br/>
     j、事务处理。
    </p>
    <hr/>
    <h4>
     <a id="11__821">
     </a>
     第11章 故障管理
    </h4>
    <h5>
     <a id="_822">
     </a>
     一、四类故障：
    </h5>
    <p>
     1、事务内部故障：大部分是非预期的，由系统自动完成。
     <br/>
     2、系统故障（软故障）：所有正在运行的事务以非正常方式终止，需要系统重启。
     <br/>
     3、介质故障（硬故障）：破坏性最大。
     <br/>
     4、计算机病毒故障：破坏方式以破坏数据库文件为主（不多见）。
    </p>
    <h5>
     <a id="_828">
     </a>
     二、数据转储（数据备份）：
    </h5>
    <p>
     1、静态转储：转储操作和事务是互斥的，保证转储前后的一致性。
     <br/>
     2、动态转储：允许转储操作和用户事务并发执行，但不能保证转储数据的一致性。
    </p>
    <h5>
     <a id="_832">
     </a>
     三、数据转储机制：
    </h5>
    <p>
     1、完全转储。
     <br/>
     2、增量转储：只复制上次转储后发生变化的文件或数据块（复制部分）。
     <br/>
     3、差量转储：对最近一次完全转储以来发生变化的数据进行转储。
    </p>
    <p>
     4、完全转储加增量转储：其中任何一次转储出现问题都会导致恢复的失败，同时恢复时间较长。
     <br/>
     5、完全转储加差量转储：操作简单，恢复时间短。但是需要移动和存储更多数据。
    </p>
    <h5>
     <a id="_840">
     </a>
     四、日志文件：
    </h5>
    <p>
     1、以记录为单位的日志文件：
     <br/>
     日志文件中有
     <strong>
      BEGIN TRANSACTION
     </strong>
     记录，而没有
     <strong>
      COMMIT 或 ROLLBACK
     </strong>
     执行
     <strong>
      UNDO
     </strong>
     操作。
     <br/>
     日志文件中既有
     <strong>
      BEGIN TRANSACTION
     </strong>
     记录，也有
     <strong>
      COMMIT 或 ROLLBACK
     </strong>
     执行
     <strong>
      REDO
     </strong>
     操作。
    </p>
    <p>
     2、以数据块为单位的日志文件。
    </p>
    <p>
     <strong>
      什么时候使用日志文件：
     </strong>
    </p>
    <p>
     1、事务故障恢复和系统故障恢复必须使用日志文件。
     <br/>
     2、在动态转储方式中必须建立日志文件。
     <br/>
     3、在静态转储方式中，也可以使用日志文件。
     <br/>
     检查点技术大幅度减少了数据库恢复时执行的
     <strong>
      日志
     </strong>
     恢复操作量。
    </p>
    <h5>
     <a id="_854">
     </a>
     五、磁盘保护技术：
    </h5>
    <p>
     1、RAID0：优点采用数据分块、并行传送方式，能够提高读写速度。缺点出现介质故障时无法恢复。
     <br/>
     2、RAID1：提高了读速度，加强了系统的可靠性。缺点：硬盘的利用率低，冗余度为50%，同时写速度并未提高。
     <br/>
     3、RAID5：磁盘空间利用率比RAID1高，存储成本相对较低。
    </p>
    <h5>
     <a id="_859">
     </a>
     六、数据库镜像分类：
    </h5>
    <p>
     1、双机互备援模式。
     <br/>
     2、双机热备份模式。
     <br/>
     3、三种实现方式：高可用性、高保护、高性能。
    </p>
    <hr/>
    <h4>
     <a id="12_868">
     </a>
     第12章、备份与恢复数据库
    </h4>
    <h5>
     <a id="_869">
     </a>
     一、造成数据丢失的原因：
    </h5>
    <p>
     1、存储介质故障。
     <br/>
     2、用户的操作错误。
     <br/>
     3、服务器故障。
     <br/>
     4、由于病毒的侵害而造成的数据丢失或损坏。
     <br/>
     5、由于自然灾害而造成的数据丢失或损坏。
    </p>
    <h5>
     <a id="_876">
     </a>
     二、恢复模式：
    </h5>
    <p>
     <strong>
      1、简单恢复模式：
     </strong>
     只用于测试和开发数据库或只读数据库，不备份
     <strong>
      事务日志
     </strong>
     、
     <br/>
     <strong>
      2、完整恢复模式：
     </strong>
     完整记录所有的事务，备份
     <strong>
      日志文件
     </strong>
     。
     <br/>
     <strong>
      3、大容量日志恢复模式：
     </strong>
     完整恢复模式的
     <strong>
      附加模式
     </strong>
     。
    </p>
    <h5>
     <a id="_882">
     </a>
     三、数据库备份：
    </h5>
    <p>
     <strong>
      1、完整数据库备份（完全转储）：
     </strong>
     备份所有。
     <br/>
     **2、差异数据库备份（差异转储）：**备份最近一次完整数据库备份之后的数据。
    </p>
    <p>
     两种备份都备份在备份过程中用户对数据库进行的操作。
    </p>
    <h5>
     <a id="_888">
     </a>
     四、文件备份：
    </h5>
    <p>
     1、文件备份。
     <br/>
     2、差异文件备份。
    </p>
    <h5>
     <a id="_893">
     </a>
     五、事务日志备份：
    </h5>
    <p>
     <strong>
      只备份日志记录。
     </strong>
    </p>
    <p>
     <strong>
      1、纯日志备份：
     </strong>
     不包含大容量备份模式下执行的任何大容量更改的备份。
     <br/>
     <strong>
      2、大容量操作日志备份：
     </strong>
     不允许对大容量操作日志备份进行
     <strong>
      时点恢复
     </strong>
     。
     <br/>
     <strong>
      3、结尾日志备份：
     </strong>
     在出现故障时进行，用于防止丢失数据。
    </p>
    <p>
     ps：结尾日志备份可以防止数据丢失并确保日志链的完整性。
     <br/>
     日志文件中包含
     <strong>
      恢复点
     </strong>
     或者希望移动或替换（覆盖）数据库，不一定需要结尾日志备份。
    </p>
    <h5>
     <a id="_904">
     </a>
     六、常用备份策略：
    </h5>
    <p>
     <strong>
      1、完整数据库备份
     </strong>
     <br/>
     <strong>
      2、完整数据库备份加日志备份
     </strong>
     <br/>
     <strong>
      3、完整数据库备份加差异数据库备份加日志备份
     </strong>
    </p>
    <h5>
     <a id="_910">
     </a>
     七、实现备份：
    </h5>
    <p>
     <strong>
      备份数据库与文件组：
     </strong>
    </p>
    <p>
     backup database data_name
     <br/>
     to 备份设备
     <br/>
     【with
     <strong>
      differential
     </strong>
     】 （进行差异备份，默认完全备份）
     <br/>
     【disk | tape 】指定磁盘文件或磁带设备
    </p>
    <p>
     <strong>
      备份日志：
     </strong>
    </p>
    <p>
     backup log data_name
     <br/>
     to 备份设备
     <br/>
     norecovrey
    </p>
    <p>
     <strong>
      实现还原：
     </strong>
     <br/>
     restore database data_name
    </p>
    <hr/>
    <h4>
     <a id="13_930">
     </a>
     第13章、大规模数据库架构
    </h4>
    <h5>
     <a id="_931">
     </a>
     一、分布式数据库：
    </h5>
    <p>
     <strong>
      分布式数据库系统与分布式数据库的区别：
     </strong>
     <br/>
     分布式数据库系统：物理上分散、逻辑上集中的数据库系统。
     <br/>
     分布式数据库：是分布式数据库
     <strong>
      系统
     </strong>
     中各场地上数据库的逻辑集合。
    </p>
    <p>
     <strong>
      分布式数据库的12个目标：
     </strong>
     <br/>
     1、本地治理。
     <br/>
     2、非集中式管理。
     <br/>
     3、高可用性。
     <br/>
     4、位置独立性。
     <br/>
     5、数据分片独立性。
     <br/>
     6、数据复制独立性。
     <br/>
     7、分布式查询处理。
     <br/>
     8、分布式事务管理。
     <br/>
     9、硬件独立性。
     <br/>
     10、操作系统独立性。
     <br/>
     11、网络独立性。
     <br/>
     12、数据库管理系统独立性。
    </p>
    <p>
     <strong>
      数据分布策略：
     </strong>
     先数据分片、后数据分配。
    </p>
    <p>
     <strong>
      数据分片：
     </strong>
     水平分片、垂直分片、导出分片、混合分片。
     <br/>
     <strong>
      数据分配：
     </strong>
     集中式、分割式、全复制式、混合式。
    </p>
    <p>
     <strong>
      分布透明性：
     </strong>
    </p>
    <p>
     1、分片透明性：最高级别、完全透明。
     <br/>
     2、位置透明性：指数据分片的分配位置对用户是透明的。
     <br/>
     3、局部数据模型透明性：不需要了解数据模型。
    </p>
    <p>
     <strong>
      分布式数据库查询代价：
     </strong>
     <br/>
     由CPU代价和 I/0代价来衡量，要考虑站点间传输数据的
     <strong>
      通信代价
     </strong>
     。
     <br/>
     导致数据传输量大的主要原因：数据间的
     <strong>
      连接操作
     </strong>
     和
     <strong>
      并操作
     </strong>
     。
    </p>
    <p>
     <strong>
      分布式事务管理：
     </strong>
     恢复控制和并发控制。
     <br/>
     恢复控制：基于二阶段的提交协议。
     <br/>
     并发控制：基于封锁协议。
    </p>
    <h5>
     <a id="2_969">
     </a>
     2、并行数据库：
    </h5>
    <p>
     <strong>
      体系结构：
     </strong>
     <br/>
     1、共享内存结构：共享一个主存储器，实现简单、容易造成访问内存冲突。
     <br/>
     2、共享磁盘结构：共享磁盘，会产生
     <strong>
      通信代价
     </strong>
     。
     <br/>
     3、无共享结构：不共享任何资源。最好并行结构。缺点：通信代价和非本地磁盘访问的代价高。
     <br/>
     4、层次结构：顶层无共享结构、底层共享内存或共享磁盘结构。
    </p>
    <p>
     <strong>
      数据划分：
     </strong>
     <br/>
     1、轮转法：顺序扫描、评价分配、适合于扫描整个关系。缺点：不适于
     <strong>
      点查询
     </strong>
     和
     <strong>
      范围查询
     </strong>
     。
     <br/>
     2、散列划分：适合
     <strong>
      点查询
     </strong>
     。缺点：散列函数的选用。
     <br/>
     3、范围划分：适合
     <strong>
      点查询和范围查询
     </strong>
     。但是会造成数据分布不均匀。
    </p>
    <h5>
     <a id="3_981">
     </a>
     3、云计算：
    </h5>
    <p>
     <strong>
      软件即服务（SaaS）
     </strong>
     ：软件分配模式。
     <br/>
     <strong>
      平台即服务（PaaS）
     </strong>
     ：通过网络提供操作系统和相关服务，无需下载或安装。
     <br/>
     <strong>
      基础设施即服务（IaaS）
     </strong>
     ：将用于支持运作的设备对外提供服务。
    </p>
    <p>
     <strong>
      公共云：
     </strong>
     <strong>
      即用即付
     </strong>
     的方式提供给公众。
     <br/>
     <strong>
      私有云：
     </strong>
     不对公众开放的企业或组织内部数据中心的资源。
    </p>
    <p>
     <strong>
      目前主要的云计算平台：
     </strong>
     Amazon 的 AWS 、Goodle 的GAE 、开放的云计算平台Hadoop。
    </p>
    <p>
     <strong>
      云计算的缺点：
     </strong>
     <br/>
     1、数据安全问题。
     <br/>
     2、对云的管理问题。
     <br/>
     3、对因特网的依赖。
    </p>
    <p>
     <strong>
      Google开发的模型简化的大规模分布式数据库BigTable：
     </strong>
     <br/>
     <strong>
      索引：
     </strong>
     行关键字、列关键字、时间戳。共同定位。
    </p>
    <p>
     特点：
     <br/>
     1、行关键字可以是任意的字符串。
     <br/>
     2、列族是由列关键字组成的集合，是访问控制的基本单位。
     <br/>
     3、时间戳记录BigTable中不同版本数据的时间标识。
    </p>
    <hr/>
    <h4>
     <a id="14__1008">
     </a>
     第14章 数据仓库与数据挖掘
    </h4>
    <h5>
     <a id="_1010">
     </a>
     一、数据仓库：
    </h5>
    <p>
     是一个
     <strong>
      面向主题的
     </strong>
     、
     <strong>
      集成的
     </strong>
     、
     <strong>
      非易失的
     </strong>
     、且随
     <strong>
      时间变化
     </strong>
     的数据集合，用来支持管理人员的决策。
    </p>
    <p>
     <strong>
      体系结构：
     </strong>
     操作型数据、操作型数据存储、数据仓库、数据集市、个体层数据（临时数据）。
    </p>
    <p>
     <strong>
      四个级别：
     </strong>
     <br/>
     1、早期细节级：老化以后的细节数据。
     <br/>
     2、当前细节级：经过集成后，进入当前细节级。
     <br/>
     3、轻度综合级：对当前细节级进行轻度综合。
     <br/>
     4、高度综合级：对当前细节级进行高度综合。
    </p>
    <p>
     <strong>
      粒度：
     </strong>
     <br/>
     综合级别称为粒度。
     <br/>
     粒度越小，细节程度越高，数据量越大。
    </p>
    <p>
     <strong>
      元数据：
     </strong>
     描述数据的结构、内容、链、索引等内容。
     <br/>
     <strong>
      技术型元数据：
     </strong>
     描述关于数据仓库技术细节的数据。
     <br/>
     <strong>
      业务型元数据：
     </strong>
     从业务角度描述了数据仓库中的数据。
    </p>
    <p>
     <strong>
      ODS：
     </strong>
     <br/>
     面向主题的、集成的、可变的、数据是当前或接近当前的。
    </p>
    <p>
     <strong>
      ODS I
     </strong>
     ： 第一类秒级。
     <br/>
     <strong>
      ODS II
     </strong>
     ：第二类小时级。
     <br/>
     <strong>
      ODS III
     </strong>
     ：第三类天级。
     <br/>
     <strong>
      ODS IV
     </strong>
     ：第四类根据数据来源方法和类型划分。
    </p>
    <p>
     <strong>
      数据仓库的设计过程：
     </strong>
     <br/>
     概念模型设计、技术评估、环境准备工作、 逻辑模型设计、物理模型设计、数据生成与应用实现、数据仓库运行与维护。
    </p>
    <p>
     <strong>
      数据仓库的更新维护：
     </strong>
     <br/>
     <strong>
      维护策略：
     </strong>
     <br/>
     实时维护：触发条件：数据源进行数据的更新操作。（软硬件性能要求很高，难以实现）
     <br/>
     延时维护：触发条件：数据发生变化后首次进行查询操作。（视图查询时间相对比较长）
     <br/>
     快照维护：触发条件：时间。（通常无法提供最新的数据，广泛使用）
    </p>
    <h5>
     <a id="OLAP_1047">
     </a>
     二、OLAP
    </h5>
    <p>
     <strong>
      多维分析的基本操作：
     </strong>
     <br/>
     1、钻取与卷起。
     <br/>
     2、切片与切块。
     <br/>
     3、旋转。
    </p>
    <p>
     <strong>
      OLAP的实现方式：
     </strong>
     <br/>
     1、基于多维数据库的OLAP（MOLAP）。
     <br/>
     2、基于关系数据库的OLAP（ROLAP）。
     <br/>
     3、混合型的OLAP（HOLAP）。
    </p>
    <h5>
     <a id="_1059">
     </a>
     三、数据挖掘：
    </h5>
    <p>
     <strong>
      三阶段：
     </strong>
     数据准备、数据挖掘、结果解释评估。
    </p>
    <p>
     <strong>
      关联规则挖掘：
     </strong>
     <br/>
     <strong>
      1、支持度：
     </strong>
     两者都买，占总数据仓库的百分比。
     <br/>
     <strong>
      2、置信度：
     </strong>
     两者都买，占其中买X的百分比。（买了X中有多少人买了Y的百分比）
    </p>
    <p>
     <strong>
      分类挖掘：
     </strong>
     <br/>
     构造方法：统计方法、机器学习方法、神经网络方法。
    </p>
    <p>
     <strong>
      聚类挖掘：
     </strong>
     <br/>
     使得每一组内的数据尽可能的相似而不同组间的数据尽可能的不同。
     <br/>
     包括：统计方法、机器学习方法、神经网络方法、面向数据库的方法。
    </p>
    <hr/>
    <h3>
     <a id="_1077">
     </a>
     常见的创建语句：
    </h3>
    <p>
     CREATE DATABASE -----&gt; 创建数据库
     <br/>
     CREATE PARTITION FUNCTION -----&gt; 创建分区表
     <br/>
     CREATE UNQUE CLUSTERED | NONCLUSTERED -----&gt; 创建索引
     <br/>
     CREATE PROC -----&gt;创建存储过程
     <br/>
     CREATE FUNCTION -----&gt; 创建标量|内联表值|多语句表值函数
     <br/>
     CREATE TRIGGER -----&gt; 创建触发器
    </p>
    <h3>
     <a id="_1085">
     </a>
     事务的几种性质：
    </h3>
    <p>
     1、一致性：
     <br/>
     2、完整性：
     <br/>
     3、可串行性：两段锁协议保证
    </p>
    <h3>
     <a id="_1090">
     </a>
     遗忘：
    </h3>
    <p>
     1、触发器通常用于保证业务规则和数据完整性。
     <br/>
     2、与触发器相关的两张表使用大写（傻逼软件不区分大小写）
    </p>
    <h3>
     <a id="_1097">
     </a>
     数据库设计各阶段所包含的内容：
    </h3>
    <p>
     <strong>
      逻辑设计阶段：
     </strong>
     数据库逻辑结构设计、数据库事务概要设计、应用程序概要设计
     <br/>
     <strong>
      概念设计阶段：
     </strong>
     系统总体框架设计
     <br/>
     <strong>
      物理设计阶段：
     </strong>
     数据库逻辑模式调整、文件组织与存取设计、数据分布设计、安全模式设计、确定系统配置、物理模式评估
     <br/>
     <strong>
      数据库运行和维护阶段：
     </strong>
     日常维护、监控与分析、性能优化与调整、系统进化。
     <br/>
     <strong>
      数据库实现和部署阶段：
     </strong>
     创建数据库、数据装载、应用程序的编码和调试、数据库的试运行
    </p>
    <h3>
     <a id="_1104">
     </a>
     数据库应用系统设计的四个层次：
    </h3>
    <p>
     <strong>
      1、表示层：
     </strong>
     <br/>
     <strong>
      2、业务逻辑层：
     </strong>
     <br/>
     <strong>
      3、数据访问层：
     </strong>
     <br/>
     <strong>
      4、数据持久层：
     </strong>
     设计工作属于数据组织与存储等方面的物理设计内容（包括索引设计），属于物理设计阶段
    </p>
    <h3>
     <a id="_1110">
     </a>
     最后大题：
    </h3>
    <h4>
     <a id="_1111">
     </a>
     一、针对数据库系统本身及网络传输过程中可能的一些调优方案：
    </h4>
    <p>
     1、把数据、日志、索引放到不同的I/O设备上，增加读取速度，数据量越大，提高I/O越重要。
     <br/>
     2、纵向、横向分割表，减少表的尺寸。
     <br/>
     3、升级硬件，扩大服务器的内存，增加服务器CPU个数。
     <br/>
     4、重建索引，收缩数据和日志，设置自动收缩日志，对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。
     <br/>
     5、优化锁结构。
    </p>
    <h4>
     <a id="SQL_1118">
     </a>
     二、SQL查询语句优化方案：
    </h4>
    <p>
     1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where 及 order by 涉及的列上建立索引。
     <br/>
     2、应尽量避免在where 子句中使用 != 或 &lt; &gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。
     <br/>
     3、任何地方都不要使用select * from 进行全表扫描，用具体的字段列表代替 “ * ” ，不要返回冗余字段。
     <br/>
     4、避免频繁创建和删除临时表，以减少系统表只有的消耗。
     <br/>
     5、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
     <br/>
     6、尽量避免大事务操作，提高系统并发能力。
    </p>
    <h4>
     <a id="UNION__1126">
     </a>
     三、对使用UNION 对大量数据进行查询的优化方法：
    </h4>
    <p>
     使用
     <strong>
      union all
     </strong>
     替代
     <strong>
      union
     </strong>
     进行合并查询，原因是union会自动压缩多个结果集中重复的数据（删除合并后重复的数据），而 union all 则将所有的结果显示出来，减少了操作量。
    </p>
    <h4>
     <a id="_RAID%09_1129">
     </a>
     四、磁盘阵列 RAID 的特点和选择：
    </h4>
    <p>
     <strong>
      三种RAID的特点与区别：
     </strong>
     <br/>
     <strong>
      RAID 0 :
     </strong>
     采用数据分块，并行传输方式，能够提高读写速度。但是由于没有冗余备份，所有数据可靠性低（其中一个硬盘介质出现问题时，则无法恢复）。
     <br/>
     <strong>
      RAID 1：
     </strong>
     增加了镜像（冗余数据），所以数据
     <strong>
      读速度
     </strong>
     提高（可以同时从原数据和冗余数据中读取），可靠性增加。硬盘利用率低（毕竟冗余数据占用50%）。
     <br/>
     <strong>
      RAID 5：
     </strong>
     只比RAID 0 增加了一个奇偶校验信息。
    </p>
    <p>
     <strong>
      总的来说：
     </strong>
     RAID 0 单纯提高了性能，但是缺少数据可靠性。 RAID 1 提高了数据可靠性和读速度，但是CPU占用率高，磁盘利用率低。 RAID 5则是一种存储性能、数据安全和存储成本兼顾的方法。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f63656e72632f:61727469636c652f64657461696c732f313039323736323633" class_="artid" style="display:none">
 </p>
</div>
