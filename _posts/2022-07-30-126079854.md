---
layout: post
title: "我说过无数遍了从来没有一种技术是为灵活组合这个目标而设计的"
date: 2022-07-30 17:05:21 +0800
description: "（1）开发语言一、面向函数函数的发明不是为了灵活组合，而是为了代码有可读性，这样，人好维护。你可以试"
keywords: "我说过无数遍了：从来没有一种技术是为灵活组合这个目标而设计的"
categories: ['未分类']
tags: ['逻辑回归', '中间件', 'Spring', 'Java', 'C']
artid: "126079854"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=126079854
  alt: "我说过无数遍了从来没有一种技术是为灵活组合这个目标而设计的"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     我说过无数遍了：从来没有一种技术是为灵活组合这个目标而设计的
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div id="js_content">
     <p>
      <strong>
       （1）开发语言
      </strong>
      <br/>
     </p>
     <p>
      一、面向函数
      <br/>
     </p>
     <p>
      函数的发明不是为了灵活组合，而是为了代码有可读性，这样，人好维护。
     </p>
     <p>
      你可以试着不写函数，功能有多复杂、代码就有多长，你看看你的代码具有可读性不？你看看这样的代码具有维护性不？
      <br/>
     </p>
     <p>
      二、面向对象
     </p>
     <p>
      面向对象的发明不是为了灵活组合，而是为了函数的安全性。面向对象，把函数分了安全级别，有的是自己私自可调用的，有的是自己的孩子可调用的，有的是所有人都能调用的。
     </p>
     <p>
      三、面向组件
     </p>
     <p>
      面向组件，这个事有点复杂。因为面向组件，需要编程语言和中间件一起配合才能搞定的。
     </p>
     <p>
      面向组件的发明也不是为了灵活组合，而是为了两个目的：
      <br/>
     </p>
     <p>
      1、为了更好的编程表达。因为面向函数、面向对象，只能表达方法（function）。而组件能表达的更加丰富，可以表达：Property、Method、Event。很显然，这也不是为了灵活组合这个目标而设计的。
      <br/>
     </p>
     <p>
      2、为了烂程序员不用自己操心内存管理。而是由组件容器中间件负责管理组件实例的创立、实例的计数、实例的池化、实例的挂起、实例的摧毁以及相关联的内存的回收。
     </p>
     <p>
      <strong>
       （2）中间件
      </strong>
     </p>
     <p>
      上述说到面向组件的时候牵扯到了中间件，我给大家把中间件的来龙去脉讲讲。
      <br/>
     </p>
     <p>
      中间件出现在1984-1987年之间，现在各种中间件，其实都是40年前的中间件的细分和延伸。无数代程序员前赴后继地重新发明轮子，用新技术一代代地重写过去。
     </p>
     <p>
      但是大家一定要牢记一句话：中间件，目标都是为了解决分布式计算中出现的各种问题而设计的。根本不是为了灵活组合这个目标而设计的。
     </p>
     <p>
      1984年，Sun公司在自己的Unix服务器软件中实现了一个功能，那就是跨服务器调用。采取Proxy/Stub这种生产者消费者架构思想，采取TCP/IP网络协议、监听某个端口、传输二进制数据，以便达到跨服务器调用。
      <br/>
     </p>
     <p>
      1986年，IBM发明了消息中间件。也就是说，你可以不用搞跨服务器函数调用，你在服务器之间来回传输数据即可，消息中间件来保证消息的传输是质量保证的，不会丢数据、不会数据顺序不对。
      <br/>
     </p>
     <p>
      1986年，Bell实验室也对外发布了一个中间件，那就是事务中间件tuxedo。在一个服务器上保证所有逻辑在一个transaction中比较容易，但是跨服务器逻辑如何在一个transacation，这必须需要事务中间件。
     </p>
     <p>
      1990年，IBM、Sun一堆厂商组了个委员会，发布了CORBA中间件技术标准。后来Sun公司制定的J2EE中间件技术标准，其实就是从CORBA借鉴而来的。
      <br/>
     </p>
     <p>
      CORBA中间件和具体的Unix操作系统无关了，和具体的开发语言也无关了。虽然还是以来TCP/IP网络协议，也是传输的二进制数据，但是有了自己专门的应用级协议了，这就是IIOP。而且也摆脱了监听某个端口这样的套路，而是专门独立出注册与发现服务，这就是后来注册中心、API网关的雏形。
      <br/>
     </p>
     <p>
      1995年，微软随着Windows95的发布，还发布了DCOM。DCOM是微软的面向组件的技术标准，微软在Windows95和WindowsNT中都内嵌了组件中间件。而且，微软还在操作系统中内嵌了事务中间件。微软的事务中间件叫MTS（Microsoft Transaction Server）。这就是IT产业界第一次面向组件和中间件的结合。Sun发明的RPC和IBM领导的CORBA，还都是针对面向对象设计的。
     </p>
     <p>
      后来，微软沿着DCOM，在1998年又改进成COM+。2001年，微软又融合了WebService技术，改进成.Net组件。
     </p>
     <p>
      微软的DCOM组件和组件中间件只能运行在微软操作系统之上。所以Sun公司在1997年借鉴CORBA，发布了与操作系统无关的J2EE组件技术标准和中间件。Sun公司也定义了自己的应用级协议：RMI。
      <br/>
     </p>
     <p>
      1998年，W3C借鉴了SGML和HTML技术发布了XML标准。2000年，W3C又借鉴CORBA发布了WebService标准：
     </p>
     <ul>
      <li>
       <p>
        服务注册与发现中心：UDDI
       </p>
      </li>
      <li>
       <p>
        接口描述语言：WSDL
        <br/>
       </p>
      </li>
      <li>
       <p>
        应用调用协议：SOAP
        <br/>
       </p>
      </li>
      <li>
       <p>
        数据传输格式：XML
       </p>
      </li>
      <li>
       <p>
        传输协议：HTTP
        <br/>
       </p>
      </li>
     </ul>
     <p>
      IBM在2004年又领导发起SOA（毕竟风靡的J2EE是Sun公司领导的）。IBM设计的SOA标准体系涵盖以下主要方面：
      <br/>
     </p>
     <ul>
      <li>
       <p>
        组件规范：SCA
       </p>
      </li>
      <li>
       <p>
        数据传输格式：SDO
       </p>
      </li>
      <li>
       <p>
        业务流程编排与执行：BEPL
       </p>
      </li>
     </ul>
     <p>
      其实IBM领导的SOA这场运动是彻底失败的。我怀疑大家都根本不知道这三个技术。但是SOA面向服务这个词却流行了。
     </p>
     <p>
      其实大家流行用的SOA，实际上是另外两个东西：
      <br/>
     </p>
     <ul>
      <li>
       <p>
        服务注册与发现中心：API网关
       </p>
      </li>
      <li>
       <p>
        用WebService技术包装的RPC中间件
        <br/>
       </p>
      </li>
     </ul>
     <p>
      到了2009年，VMWare公司通过资本并购一顿猛整，把Spring、Cloud Foundry、Pivotal这三家公司一顿整合。于是，Pivotal的技术布道师在2013年又发明了一个特别流行的词：云原生。说云原生包含四个东西：微服务、容器、CI/CD、DevOps。其实CI/CD、Devops是敏捷软件工程的东西，和云原生没毛关系，早在他发明这个概念时已经存在很久了也流行很久了。
      <br/>
     </p>
     <p>
      其实微服务和SOA（面向服务架构）也没毛关系。本来大家过去写程序，和开发语言无关、和中间件无关、和框架也无关。现在Spring、Cloud Foundry、Pivotal，让大家和开发语言绑定、和框架绑定、和中间件绑定。这太她妈狗屎了。
      <br/>
     </p>
     <p>
      所以，2015年，Google又领导了一帮人搞了一个CNCF组织。CNCF全称就是Cloud Native Computing Foundation(云原生计算基金会)。这下VMWare Pivotal公司的云原生喊不下去了。现在，VMWare Pivotal公司的技术路线，也顺着CNCF技术路线走了。
      <br/>
     </p>
     <p>
      唉，一代又一代聪明才智的程序员，如今又重写了分布式的消息中间件如Pulsar、分布式的事务中间件如Seata、分布式RPC中间件如gRPC。这世界，40年来也没啥变化。所以我特别困惑，你们都说新技术革命、新技术层出不穷，但我咋觉得技术这40年来都没啥大变化呢？都是换姿势而已。
      <br/>
     </p>
     <p>
      有闲心的时候，我另外再给大家写篇文章，说说如今的人工智能，也是换姿势，和我在90年代学的东西没啥大改变，很多现在人工智能的东西，在90年代其实就都有了。
     </p>
     <p style="text-align:center;">
      <img alt="1987fe8065b1223d3e80707845bf36b7.jpeg" src="https://i-blog.csdnimg.cn/blog_migrate/e0d083daaf779faceed0f544db41ac57.png"/>
     </p>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f64617669645f6c762f:61727469636c652f64657461696c732f313236303739383534" class_="artid" style="display:none">
 </p>
</div>
