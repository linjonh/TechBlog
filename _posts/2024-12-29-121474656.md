---
layout: post
title: ic后端面试汇总
date: 2024-12-29 14:57:25 +0800
categories: [经验分享]
tags: [经验分享,其他]
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=121474656
    alt: ic后端面试汇总
artid: 121474656
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     ic后端面试汇总
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <ol>
     <li style="text-align:justify;">
      <strong>
       请说一下
      </strong>
      <strong>
       memory
      </strong>
      <strong>
       的摆放规则（
      </strong>
      <strong>
       floorplan
      </strong>
      <strong>
       ）
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     尽量摆放在四周，和外界数据交互
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       Place
      </strong>
      <strong>
       之后有时序违规（
      </strong>
      <strong>
       timing violation
      </strong>
      <strong>
       ），应该怎么处理？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       CTS
      </strong>
      <strong>
       的目的是什么？怎么样是一个合格的
      </strong>
      <strong>
       clock tree
      </strong>
      <strong>
       ？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     CTS的目的就是减小时钟偏差(clock skew)
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     除了PPA（performance、power、area）之外，时钟树还应该robust。即所谓设计中的时钟树在任意设计需求的corner下都能满足时序。总之，CTS的结果应为一个满足时钟树特性定义的高质量时钟树网络
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       为什么时钟树需要平衡？不平衡的时钟树有什么缺点？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     对于快速设计。时钟树的skew和latency影响时序收敛、功耗和面积。平衡可以使得timing收敛简单一点；
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     对于慢速设计，时钟树的skew和latency对时序收敛的影响降低。但是对于skew大的时钟树，工具修复时序会增加更多的面积和功耗。创造一个skew小的时钟树，虽然看似在时钟树上多用了buffer，但是会减少在修复时序问题时需要的buffer
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     所以，平衡对于时序收敛、面积和功耗都是有好处的。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是闩锁效应（
      </strong>
      <strong>
       latch up
      </strong>
      <strong>
       ）？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     闩锁效应是由NMOS的有源区、P衬底、N阱、PMOS的有源区构成的n-p-n-p结构产生的，当其中一个三极管正偏时，就会构成正反馈形成闩锁。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     避免闩锁的方法就是要减小衬底和N阱的寄生电阻，使寄生的三极管不会处于正偏状态。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请说一下标准单元的延迟与哪些因素有关？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     input transition、output load、PVT
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请说一下为什么需要对时序器件进行
      </strong>
      <strong>
       setup
      </strong>
      <strong>
       ，
      </strong>
      <strong>
       hold
      </strong>
      <strong>
       检查？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     否则会出现亚稳态
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       解释一下什么是时钟转换时间
      </strong>
      <strong>
       (clock transition time)
      </strong>
      <strong>
       ？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     分为rise和fall transition，一般指信号从10%到90%需要的时间
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       timing path
      </strong>
      <strong>
       根据路径，一般可以划分为哪几种？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     4种；input到DFF、DFF到DFF、DFF到output、input到output
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       综合
      </strong>
      <strong>
       DC
      </strong>
      <strong>
       主要做了什么事情？说一下具体综合的流程
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     将RTL变成netlist过程，主要分为3个阶段：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     Translation：翻译，主要把描述RTL级的HDL语言
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     Logic optimization：逻辑优化，就是把路径调整一下，门给改一下等等。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     Gate mapping ：门级映射，把优化了的统一门级描述
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       clock skew
      </strong>
      <strong>
       ？如何计算的？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     skew主要指时钟到达不同DFF时出现时序偏差，这个偏差叫作skew
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       create_clock
      </strong>
      <strong>
       和
      </strong>
      <strong>
       create_generate_clock
      </strong>
      <strong>
       有什么区别？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     create_clock生成的是master clock，create_generate_clock是由master clock生成的，比如通过一个分频器，不会单独产生一个时钟，连接到master clock。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       STA
      </strong>
      <strong>
       的基本概念，与仿真相比，它的优势是什么？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     静态时序分析；优势是：1.100%覆盖率  2.速度快  3.考虑串扰，工艺偏差的影响
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       STA
      </strong>
      <strong>
       在什么阶段做，各个阶段的
      </strong>
      <strong>
       STA
      </strong>
      <strong>
       都有什么区别
      </strong>
      <strong>
       ?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     DC综合 placement单元放置 routing布线 都需要时序分析。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     主要区别是CTS之前使用的都是虚拟时钟，设计约束文件SDC定义的时钟(SDC对电路的时序，面积，功耗进行约束)
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     各个阶段的时序分析model也不一样，比如DC使用的是线负载模型，routing之后就是实际的布线数据。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       LEF
      </strong>
      <strong>
       文件的主要作用，它和
      </strong>
      <strong>
       GDSII
      </strong>
      <strong>
       有什么区别？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     LEF只描述单元的底层细节，比如端口位置，层定义和通孔定义。只用于布局布线。GDSII拥有单元的全部信息，但由于过大，不利于工具的布局布线。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       列举你知道的几种修复
      </strong>
      <strong>
       setup timing violation
      </strong>
      <strong>
       的方法，该优先使用哪一种？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     调整size，更换阈值电压，修复DRC（transition和load会影响延迟），流水线，useful skew
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       timing signoff
      </strong>
      <strong>
       报告主要有哪些内容？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.setup hold violation
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.DRC检查，input transition，output load
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.corner是否全
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4.sdc检查，后仿作为最后检查sdc的过程，比如false path
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     5.噪声
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       spef
      </strong>
      <strong>
       文件里面记录了什么内容？如何得到？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     互连线寄生参数，使用starRC
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       时钟树走线和普通信号线有什么区别？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     double width和double space，高层走线
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       静态功耗的概念，如何降低？请列举一些你知道的方法？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     主要是泄露功耗
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.提高阈值电压
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.电源门控
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.体偏置。进而改变阈值电压，如果正向体偏置就会提高性能。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       动态功耗主要包含哪些部分，如何降低？请列举一些你知道的方法
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     包含短路功耗和开关功耗
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.降低电压
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.DVFS
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.多电压域
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4.降低负载
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     5.降低时钟频率
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       芯片为什么需要采用纵横交错的走线方式
      </strong>
      <strong>
       ?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     减少crosstalk
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       crosstalk?
      </strong>
      <strong>
       为什么会产生
      </strong>
      <strong>
       crosstalk?
      </strong>
      <strong>
       会带来什么后果？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     串扰。信号线之间的干扰。产生glitch和transition time的变化。transition和delay有关系，同向transition变小，反向transition变大。glitch会产生逻辑错误。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       列举一下你知道的修复
      </strong>
      <strong>
       hold timing violation
      </strong>
      <strong>
       的方法？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.单元面积
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.单元尺寸
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.流水线
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       我们在修复
      </strong>
      <strong>
       hold violation
      </strong>
      <strong>
       时，
      </strong>
      <strong>
       buffer
      </strong>
      <strong>
       应该加在什么位置？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     组合逻辑，DFF间路径
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       列举几个常见的
      </strong>
      <strong>
       drc
      </strong>
      <strong>
       种类？
      </strong>
      <strong>
       (design rule check
      </strong>
      <strong>
       。设计规则检查。主要目的是检查
      </strong>
      <strong>
       layout
      </strong>
      <strong>
       中所有因违反设计规则而引起潜在断路，短路等其他设计规则违反
      </strong>
      <strong>
       )
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     满足良率的同一金属层或者不同金属层的几何尺寸的最小值的集合，就是设计规则检查。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     版图和lef文件进行比较（lef由单元lef和技术lef，这边技术lef定义设计规则，单元lef）
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请介绍几种修复
      </strong>
      <strong>
       drc
      </strong>
      <strong>
       的方法？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.工具自动修，在DRC违规的地方添加routing guide，做iteration routing
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.工具抓取出DRC违例的地方，删除这些net，做routing eco。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       说一下
      </strong>
      <strong>
       Calibre
      </strong>
      <strong>
       检查
      </strong>
      <strong>
       drc
      </strong>
      <strong>
       的具体流程？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     主要输入两个文件。一个是得到的版图GDSII文件和工艺厂商提供的设计规则文件。工具通过标出违反设计规则的位置，进而手工修改违规。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       CTS
      </strong>
      <strong>
       之前是如何计算
      </strong>
      <strong>
       clock path
      </strong>
      <strong>
       上的延迟的
      </strong>
      <strong>
       ?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     根据sdc中clock的uncertainty（包含skew），CTS之后使用实际的CTS计算skew。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       介绍一下
      </strong>
      <strong>
       CPPR
      </strong>
      <strong>
       的概念，为什么需要用到
      </strong>
      <strong>
       CPPR?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     共同路径悲观去除。在OCV时需要乘以一个derate系数，共同路径的部分需要移除悲观量。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是天线效应
      </strong>
      <strong>
       (antenna effect)?
      </strong>
      <strong>
       说几种你知道的修复方法？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     芯片中没有氧化层覆盖的金属或者多晶硅收集游离电荷。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     给存在天线效应的金属层接上二极管；跨层走线；插入缓冲器
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请列举一下导入后端设计需要哪些文件？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     netlist
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     工艺库（逻辑库db lib 物理库lef）
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     工艺文件
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     TLU+
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请列举几个你知道的
      </strong>
      <strong>
       sdc
      </strong>
      <strong>
       命令，并说出它的用途？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     create_clock
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     create_generated_clock
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_driving
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_load
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_input_delay
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_output_delay
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_case_analysis
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_false_path
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_multicycle_path
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_max_fanout
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_max_transition
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_min_capacitance
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     set_max_capacitance
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       修复
      </strong>
      <strong>
       timing violation
      </strong>
      <strong>
       时，首先应该关注什么，有哪些需要注意的点？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.逻辑
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.floorplan
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.时序路径的延迟，cell size，阈值电压，buffer
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4.工具层次，group的weight
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     5.线延迟，插buffer
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       CTS
      </strong>
      <strong>
       之前需要修复
      </strong>
      <strong>
       hold violation
      </strong>
      <strong>
       么，为什么？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     不需要。1.没有实际的CTS 2.很好修，插buffer
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       在修复
      </strong>
      <strong>
       hold violation
      </strong>
      <strong>
       时，
      </strong>
      <strong>
       delay cell
      </strong>
      <strong>
       和
      </strong>
      <strong>
       buffer
      </strong>
      <strong>
       该优先使用哪一种，各有什么优缺点？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     特点：delay cell延迟比较大，buffer驱动能力强
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     较大的violation使用delay cell。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       setup
      </strong>
      <strong>
       和
      </strong>
      <strong>
       hold violation
      </strong>
      <strong>
       该优先修复哪种，为什么？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     优先修复setup。hold比较好修。并且setup决定我们的性能
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       clock latency
      </strong>
      <strong>
       的概念，什么情况下需要设置？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     可分为source latency和network latency。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     source latency是这clock 信号来源到芯片的 clock输入端的delay，而network latency是指芯片clokc输入端到 flip-flop clock输入的delay。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     一般不需要设置。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.不同clock source latency不同，考虑时序，需要设置。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.不同时钟network latency （insert delay cell）不同时，需要考虑时序，也需要设置。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       如何判断
      </strong>
      <strong>
       floorplan
      </strong>
      <strong>
       摆放质量的好坏？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.memory要放在边缘，和外界数据交互
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.SRAM地址线对齐
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.有关联的Macro放在一起
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       电源走线为什么需要使用高层线？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.高层金属更厚，有更强的EM能力
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.对低层信号线干扰更小
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.不会占用低层的信号线
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请说一下
      </strong>
      <strong>
       OCV
      </strong>
      <strong>
       的概念，为什么需要用到
      </strong>
      <strong>
       OCV
      </strong>
      <strong>
       ，什么阶段需要
      </strong>
      <strong>
       OCV
      </strong>
      <strong>
       ，如何实现？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     片上工艺偏差，因为OCV对时序分析造成影响，那么进行时序分析时需要将这些OCV考虑进来。 在STA中，通过对不同的时序路径添加derate来实现对OCV的建模
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       我们需要在什么阶段做
      </strong>
      <strong>
       formal
      </strong>
      <strong>
       验证？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     DC，floorplan，routing
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       DC
      </strong>
      <strong>
       综合的时候，我们是怎么计算
      </strong>
      <strong>
       net
      </strong>
      <strong>
       的
      </strong>
      <strong>
       delay?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     根据线负载模型，由扇出计算出线长，再乘以单位线长上的电阻和电容，计算RC。利用Elmore 模型计算delay。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       谈谈整个芯片设计的大概流程？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     从架构定义——前端设计——后端设计——生产制造——封装——测试
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       从后端角度，对于芯片设计的要做哪些检查？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     LVS (Layout vs Schematic) 版图与原理图比较，DRC（design rule check ）设计规则检查，timing signoff，功耗，功能，性能（频率），面积
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       clock
      </strong>
      <strong>
       时钟一般采用哪层金属走线？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     较高层的走线，一般是5，6，7；double space和double width
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       为什么采用
      </strong>
      <strong>
       double width, double spacing
      </strong>
      <strong>
       的时钟树走线方式？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     EM，fanout较大，电流大。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       clock uncertainty
      </strong>
      <strong>
       主要包含哪些内容？你设置了多少？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     CTS之前
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     setup：clock uncertainty = jitter + skew + margin
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     hold：clock uncertainty = skew + margin
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     CTS之后
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     setup：clock uncertainty = jitter + skew + margin
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     hold：clock uncertainty = skew + margin
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       IR drop?
      </strong>
      <strong>
       有
      </strong>
      <strong>
       IR drop
      </strong>
      <strong>
       问题应该怎么办？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     电压降，分为静态和动态。静态是由于连线电阻分压；动态是由于门同时打开，局部电流过大。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     有IR drop应该合理设置电源I/O PAD的数量和位置；为电源网络添加去耦电容
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       LVS
      </strong>
      <strong>
       ？出现
      </strong>
      <strong>
       LVS violation
      </strong>
      <strong>
       时应该怎么办？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     版图原理图一致性检查，又称电气规则检查。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     主要步骤将RTL抽取成spice网表，然后比对。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     比对单元数量，单元个数，节点个数等。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       说一下检查
      </strong>
      <strong>
       LVS
      </strong>
      <strong>
       的具体流程？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     版图原理图一致性检查
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     将版图抽取出spice模型和初始netlist进行对比。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请说一下
      </strong>
      <strong>
       clock gate cell
      </strong>
      <strong>
       的结构
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     时钟前面和一个latch加一个与门，latch主要是消除毛刺
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       LEC
      </strong>
      <strong>
       （等价性检查工具）主要检查哪些内容，为什么要做
      </strong>
      <strong>
       ?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     以DC后的RTL和netlist为例。读入netlist，RTL和svf判断，根据逻辑锥和svf判断是否存在错误
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       EM
      </strong>
      <strong>
       ？有
      </strong>
      <strong>
       EM
      </strong>
      <strong>
       问题应该怎么办？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     电迁移。金属原子移动。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1.减小fanout
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2.增加线的width
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3.单元驱动能力过强
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4.连线过长
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       综合的约束和后端的约束有什么区别？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     综合时，模型粗略，过约SDC，时钟频率调高。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     CTS之前没有真实的时钟树，uncertainty加大
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     PR工具和signoff工具一致性问题，margin也会有区别
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       画一个
      </strong>
      <strong>
       4
      </strong>
      <strong>
       位异步计数器，如何加时序约束？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     在每个DFF的Q端做create_generated_clock
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       为什么
      </strong>
      <strong>
       clock gating cell
      </strong>
      <strong>
       里面用的是
      </strong>
      <strong>
       latch
      </strong>
      <strong>
       ，如果换成
      </strong>
      <strong>
       flop
      </strong>
      <strong>
       的话，有什么不同
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     用latch可以borrow timing，即便enable信号不满足setup,也可以成功采到实现gating功能。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果用Flop，一旦因为干扰或者时序本身的问题，很可能导致第一拍采不到数，会使得gating的时序落后一拍，如果时序要求严格，会产生问题
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       在
      </strong>
      <strong>
       AOCV
      </strong>
      <strong>
       里面，随着逻辑单元级数的增加，
      </strong>
      <strong>
       derate
      </strong>
      <strong>
       的值是增加还是减少？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     在OCV中，随级数增加，derate不变
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     在OCV中，公共路径的derate也会被CRPR去掉
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     OCV中，随着级数的增加，derate不变。但是这样time会很难满足，因为OCV本身的影响已经很严重了。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     所以出现了AOCV，随着级数的增加，derate减小，这样可以让time更容易满足
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     在ocv中，如果设derate是1%，那么对于3级buffer链的derate值就是：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1%d+1%d+1%d=1%3d(每个buffer的延迟是d);
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     在aocv中，同样1%的derate，多级cell会对derate乘一个小于1的修正系数r，那么对于3级buffer链的derate值就是：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1%d+1%dr+1%drr=1%*d(1+r+r^2)&lt;1%*3d
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     也就是说，随着深度增加，derate值在减小
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       哪些因素可以影响标准单元的延迟？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）PVT（生产工艺，电压，温度）
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）input transition， output load
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）Vth
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       做
      </strong>
      <strong>
       RTL
      </strong>
      <strong>
       综合时，经常使用的
      </strong>
      <strong>
       wire load model
      </strong>
      <strong>
       有哪几种？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）zero wire load model
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）基于fanout的传统 WLM
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）基于物理位置（距离）的wire load model，在Cadence的RC中叫PLE，Synopsys叫DC Ultra Topographical
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       clkb
      </strong>
      <strong>
       是
      </strong>
      <strong>
       clka
      </strong>
      <strong>
       的生成时钟，在
      </strong>
      <strong>
       CTS
      </strong>
      <strong>
       的
      </strong>
      <strong>
       spec
      </strong>
      <strong>
       文件中如何定义这两个时钟？假设
      </strong>
      <strong>
       clka
      </strong>
      <strong>
       和
      </strong>
      <strong>
       clkb
      </strong>
      <strong>
       之间的
      </strong>
      <strong>
       FF
      </strong>
      <strong>
       有时序收敛的要求。
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     在CTS的spec文件中定义 clka 是 root，clkb 为 throughpin，再加上那些应该有的skew，transition，insertion delay等就好了，其它的事CTS会给你做
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请详细解释解决走线阻塞的问题
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1） routing congestion发生在后端，前端一般不太考虑这个问题，需要后端自己去想办法解决，但是解决的办法不只在后端，也有一些方法需要前端的配合
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2） 阻塞有多种情形，要分别讨论，没有一个统一的解决办法。能够把大部分的阻塞情况列举出来，就已经够4级的水平啦
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     答案：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）阻塞在RAM（macro）之间：可能RAM之间的距离没有计算正确，可以加大RAM之间的间距；扭转RAM的方向，使得RAM的IOpin朝向更容易走线的那边；如果是多个RAM共用地址或者数据线，尽量把RAM的地址数据pin对齐
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）阻塞出现在RAM和帮助单元交界的地方：在RAM周围加一条halo（keepout）；把RAM放在四周，尽量把中间留下的空间变成方形；在有阻塞的地方加一些由小的placementblockage组成的矩阵
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）阻塞出现在标准单元的某一块：也可以加一些由小的placement blockage组成的矩阵；module/instancepadding；利用placement guide减少那块地方的标准单元个数；scan chainreordering也会改善一些阻塞；定义density上限；使用congestion driven的placement，并且要求place之后做congestion优化；在综合是禁止使用那些pin太多太密集的标准单元(多半是那些复杂的组合逻辑单元)；请前端使用RAM代替触发器矩阵；请前端修改算法
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4）应该尽量减少power route占有的资源，谨慎选择power mesh使用的金属层，VIA的大小等。在detailroute完成之后，你如果已经试了各种解决signal congestion的方法，还有少量DRC无法解决时，可以考虑切掉部分power mesh
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
      </strong>
      <strong>
       如何得到更好的时钟树
      </strong>
      <strong>
       skew
      </strong>
      <strong>
       和
      </strong>
      <strong>
       insertion delay
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     clock mesh 是一种方法。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果是用普通的CTS的方法，可以从下面几个方面着手。不太可能一次就把CTS做得很好，要反复调试各种参数，达到最佳效果。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）合理的clock root和through pin。这个看似CTS会从SDC自动抓出来，但是并不一定是最好的，特别是多个clock相互有重叠的leafpin时，要特别注意
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）不要用太大或者太小的clock buf/inv
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）选用RC最小的金属层。如果上面RC最小的金属层已经被占用，比如RC最小的top，top-1已经不够clocknet时，而top-2到layer2都是一样的RC时，可以选用layer3/4。为什么不用更高层哪？因为这样既照顾了layer2/1的pin，有不用太多的via到更高层
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4）如果用double width clock wire，可以适当增大clock buf/inv的size
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     5）合理的max fanout。有时clock buf/inv的fanout可以超过max_fanout的限制
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     6）不要把skew设得太小
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     7）min_insertion_delay = 0ns
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     8）合理的transition time,不要太小
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     9）使用postCTS的CTS opt
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     10）做clock tree时，就直接把clock net走线完成
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       如果告诉你标准单元的门数，所有内存的类型和逻辑大小，其他
      </strong>
      <strong>
       IP
      </strong>
      <strong>
       的实际大小，以及
      </strong>
      <strong>
       IO cell
      </strong>
      <strong>
       的种类和数量，你如何估算整个芯片的面积？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     IO neck 和 core neck 一般称作 IO limited 和 core limited，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     IO limited ：这个芯片的面积是因为IO个数限制（太多），而不得不做得那么大。core部分其实用不了那么大。这时面积计算就简化为每边IO个数的计算了。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     Core limited：芯片面积是有core部分的决定的，IO没有那么多
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     在Core limited情况下，die size的估算如下：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     芯片面积 = core面积+ power ring面积 +PAD ring面积
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     core面积 = RAM面积 + 其他macro面积 + 标准单元面积
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     RAM面积 = RAM 自身的面积 + RAM power ring面积 + keepout面积 + mbist面积
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     RAM自身的面积可以通过memory compiler或者查datasheet得到，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     有些RAM 可以不要power ring。如果要的话，按照power mesh的宽度 x RAM的长宽 x 2 = 面积
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     keepout + mbist 的面积一般是RAM自身面积的10%
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     其他macro的面积，比如PLL，ADC，DAC等，直接把面积加起来，再留3～5%的keepout面积就好了
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     标准单元的面积=（预估的gate count x 每个gate的面积）/ utilization
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     utilization与使用的金属层数和设计的用途有关，简单地计算方法是
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     5层metal：50%
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     6层metal：60%
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     7层metal：70%
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     8层metal：80%
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     以上不包括power专用的金属层
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果设计是多媒体芯片，一般可以增加3～5% utilizaion，如果是网络芯片，则要减少3～5%
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       CTS
      </strong>
      <strong>
       中使用
      </strong>
      <strong>
       buffer
      </strong>
      <strong>
       和
      </strong>
      <strong>
       inverter
      </strong>
      <strong>
       的优缺点是什么？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     使用BUF：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     优点：逻辑简单，便于post-CTS对时钟树的修改
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     缺点：面积大，功耗大，insertion delay大
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     使用INV：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     优点：面积小，功耗小，insertion delay小，对时钟duty cycle有利
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     缺点：不易做时钟树的修改
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       如果从下面的两个芯片中选一个给你做后端设计，你选哪个？请说明选择的理由？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     <strong>
      （
     </strong>
     <strong>
      1
     </strong>
     <strong>
      ）
     </strong>
     <strong>
     </strong>
     <strong>
      宽
     </strong>
     <strong>
      = 2
     </strong>
     <strong>
      倍的长
     </strong>
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     <strong>
      （
     </strong>
     <strong>
      2
     </strong>
     <strong>
      ）
     </strong>
     <strong>
     </strong>
     <strong>
      长
     </strong>
     <strong>
      = 2
     </strong>
     <strong>
      倍的宽
     </strong>
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     去除不太好用的layer（比如metal1）和power专用layer（比如RDL）后，比较剩下的layer可以提供的H和V的routingresource，如果H的多，就选宽的，反之，就选高的。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       因为
      </strong>
      <strong>
       IO
      </strong>
      <strong>
       太多而导致芯片面积过大，有什么方法减小面积？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）stagger IO，2重io 可以算一个方法
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）IO可以不全放到四边，只要封装没问题就行啦 – flip chip 算第二个方法
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）如果有多套IOcell可以选择，尽量选瘦的
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4）调整芯片的长宽比
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       为什么
      </strong>
      <strong>
       -hold
      </strong>
      <strong>
       一般是
      </strong>
      <strong>
       -setup
      </strong>
      <strong>
       的
      </strong>
      <strong>
       n-1
      </strong>
      <strong>
       ？如果只有
      </strong>
      <strong>
       -setup
      </strong>
      <strong>
       没有
      </strong>
      <strong>
       -hold
      </strong>
      <strong>
       会怎样？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     hold 是对前后两个flipflop在相同时钟沿的检查.设了n-1就是返回n-1个周期做hold的检查，满足了两个flip flop在同一个时钟沿。如果没有-hold默认是检查n前一个有效时钟沿，如果n&gt;=2，hold的检查就不是在同一个时钟效沿，对hold的要求就要多n-1个周期，那样太苛刻了，一般时序无法收敛
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       一个设计的时序约束是怎么写出来的？请大略说明时钟，
      </strong>
      <strong>
       IO delay
      </strong>
      <strong>
       ，
      </strong>
      <strong>
       false path
      </strong>
      <strong>
       ，
      </strong>
      <strong>
       multicyclepath
      </strong>
      <strong>
       是如何得到的？在完成时序约束的过程中，后端可以给予什么样的帮助？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     clock和generated clock一般由设计spec决定。除非有些个别的local generated clock可以有前端工程师自己添加
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     IO timing与系统设计有关，应该参考/兼顾其他芯片的IO时序，由前端工程师作出
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     exception（false path， multicycle path）一般是由前端工程师在做设计时决定的
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     后端可以提供clock network delay/skew，DRV，以及帮助检查SDC是否合格
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       在只有一个
      </strong>
      <strong>
       function SDC
      </strong>
      <strong>
       的普通后端流程中，对于
      </strong>
      <strong>
       pre-CTS, post-CTS
      </strong>
      <strong>
       和
      </strong>
      <strong>
       post-Route
      </strong>
      <strong>
       这三步，请分别讲述它们在时序收敛上的方法，一般会遇到的问题和解决方法。
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     pre-CTS时，使用ideal clock，只fix setup
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     post-CTS后，使用propagate clock，可以只fix setup，检查hold，但可以不fix hold
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     post-Route后，依然使用propagate clock，fix setup和hold
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     具体遇到的问题和解决方法：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     pre-CTS: 如果有setup，重在调整floorplan，buffer tree结构
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     Post-CTS: 如果有setup，重在调整clock tree，buffer tree结构或者size
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     Post-Route: 如果有setup/hold，微调clock tree/buffer tree的size，routingchannel和图层，实在不行，回到CTS
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     preCTS和postCTs主要就是差个clock skew的问题
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     还有build clock的方法，这个很重要，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     很多inter-clock pathviolation都是由于没有balance好造成的
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     所以你在postCTS后的timing有时候有很奇怪的结果，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     postRoute主要是SI 影响，timing 会变差些，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     可以做postroute opt来修复回来，减少下crosstalk的影响，
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       假设一个设计的
      </strong>
      <strong>
       function SDC
      </strong>
      <strong>
       中有多个时钟，在
      </strong>
      <strong>
       scan mode
      </strong>
      <strong>
       下，另有一个单独的
      </strong>
      <strong>
       scanclock
      </strong>
      <strong>
       ，如果
      </strong>
      <strong>
       functional
      </strong>
      <strong>
       的各个时钟树之间是不平衡的，请问如何平衡那个
      </strong>
      <strong>
       scan
      </strong>
      <strong>
       时钟？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果CTS支持multi-mode，直接使用即可。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果不支持，或者MMCTS效果不理想，就是在CTS spec中，同时定义function 和 DFT 的时钟，然后在scanclock里面，把MUX设为leave pin，再让它们与function clok到MUX的延迟做动态平衡
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       在一个设计中有多个时序约束，象
      </strong>
      <strong>
       function
      </strong>
      <strong>
       ，
      </strong>
      <strong>
       scan shift, scan capture, scan at-speed, mbistat-speed,
      </strong>
      <strong>
       和
      </strong>
      <strong>
       jtag SDC
      </strong>
      <strong>
       ，为了减少运行时间，不能把它们都放入
      </strong>
      <strong>
       MMMC
      </strong>
      <strong>
       中，你选择哪些放入
      </strong>
      <strong>
       MMMC
      </strong>
      <strong>
       的
      </strong>
      <strong>
       setup
      </strong>
      <strong>
       中，哪些放入
      </strong>
      <strong>
       MMMC
      </strong>
      <strong>
       的
      </strong>
      <strong>
       hold
      </strong>
      <strong>
       中？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     这个要从每个SDC的特点着手，个人经验，与设计有关，不敢保证使用与所有设计。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     scanshift：速度很慢，不用太担心setup，但是hold很重要，一旦hold有问题，所有与scan有关的测试全泡汤
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     scancapture：也是慢速，但是会有很多hold出来，特别是在不同的function时钟之间
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     scanat-speed：高速，解决了它的setup，其他DFT的setup基本上就连带着解决了
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     mbist at-speed：高速，但是涉及的逻辑不多
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     jtag：慢速，很容易与function SDC合并
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     所有结论是
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     MMMC setup：function + scan at-speed
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     MMMC Hold: function（+jtag） + scanshift + scan capture
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       请解释反标
      </strong>
      <strong>
       SDF
      </strong>
      <strong>
       和
      </strong>
      <strong>
       SPEF
      </strong>
      <strong>
       在时序分析时的差异
      </strong>
      <strong>
       ,
      </strong>
      <strong>
       特别是用不同的
      </strong>
      <strong>
       STA
      </strong>
      <strong>
       工具检查
      </strong>
      <strong>
       timing
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     使用SDF做时序分析，无论使用什么tools，其结果应该是一样的，没有差异
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     使用SPEF时，因为工具需要把SPEF换算成SDF，这时会产生差异。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     所以建议使用一个你信得过的工具生成SDF，然后大家都使用这个SDF做STA和仿真
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       在后端流程的每步中，如何处理门控时钟？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果是用latch+and/or在组合成的clock gatingcell，比较麻烦，以后估计不多见了，暫不讨论。TomPaul提到的问题都很让人头痛，特别是做CTS时，如何处理那些个latch的clkpin。Place时，latch和and/or cell一定要靠得很近。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     一般使用ICG cell时，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     place：使用clock gating awareplacement选项
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     CTS：主要看工具的本领了，一般是希望在满足setup的前提下，ICGcell要尽量靠近clock root
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     route：除了clock net优先以外，不记得还有什么可做的了
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       SSO
      </strong>
      <strong>
       ，设计
      </strong>
      <strong>
       PAD ring
      </strong>
      <strong>
       时，如何计算
      </strong>
      <strong>
       SSO
      </strong>
      <strong>
       ？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     sso ，即simultaneous switchingouputs，即允许同时切换的信号IO的数量。多个信号IO同时切换时，因更多电流流过pad ring，在pad电源IO的bondingwire及片外引线上的电感上，产生Ldi/dt的压降。也即ssn，同时切换噪声。主要是会引起地弹，即ground bounce。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     避免sso有很多方法。如增加供给pad用的电源IO数量，采用doublebonding或triple bonding，采用slew rate control的IO，避免把pad电源IO放在corner上（corner处bondingwire引线最长，L最大），等。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     主要还是采用增加pad用电源IO数量的办法，计算方法一般foundry会提供，一般是给每个信号PAD一个DF值（还要根据bondingwire电感值做出选择），把自己用的所有信号IO的DF值加在一起，能得出所需要的POWER PAD的数量。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       写时序约束时，是否需要对所有的
      </strong>
      <strong>
       IO
      </strong>
      <strong>
       端口加约束？一个信号端口是否可以被多个时钟约束？应该如何对这种端口设置
      </strong>
      <strong>
       delay
      </strong>
      <strong>
       ？一个时钟端口是否可以定义多个时钟？应该如何定义这些时钟？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     CLOCK ports 不需要加，其他都要
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     可以，set_input_delay -add_delay
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     可以，create_clock -add
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       如何设计
      </strong>
      <strong>
       PAD ring
      </strong>
      <strong>
       ？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     大的流程是：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）根据系统（其他芯片的）要求，芯片内部的floorplan，决定信号PAD的位置
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）计算出power PAD的个数，插入到信号PAD里面
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）加其他的PAD，比如IO filler，powercut，power on control，corner PAD，ESD等
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     细节可以包括：
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     1）如何计算core power PAD：估算corepower，再加50%，算出电流，除以每个core power IO的最大电流，就是大致的PAD个数。插入到信号PAD ring后，还要再计算powerEM，防止一根电源线上的电流过大。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     2）如何计算IO powerPAD：从信号IO的功耗算起，同时计算SSO，取2个结果里面较大的
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     3）在什么地方插入powercut：不同的电压core电压和不同的IO电压之间，power island之间，数字和模拟电源之间。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     4）power on control PAD，一段每个IOring需要一个
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     5）ESD一般要加在每个不同的电源之间
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       在设计中，单元的输入端可以悬空吗？输出端哪？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     输入端不行，输出端可以
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     输入悬空会因为周围电场的变化而引起cell内部的翻转，继而影响到其他的逻辑的正确性
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       设计的哪些地方容易出现
      </strong>
      <strong>
       IR-drop
      </strong>
      <strong>
       的问题？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     从电源布线的角度讲，那些远离电源端的地方，电源布线少的地方，容易出现ir-drop的问题。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     比如wire bond芯片的中间，flipchip的四角，analog macro的边上（因为有些analog的上面不容许数字电源布线）
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     从swtiching activity的角度讲，toggle rate高并且celldensiy高的地方IRdrop大，所以切记不要为了balance clock tree，把一堆clock buffer摆在一起。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果是静态IRdrop，频率高的地方IRdrop大。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       输入端信号的
      </strong>
      <strong>
       transition
      </strong>
      <strong>
       的快慢是如何影响
      </strong>
      <strong>
       APR
      </strong>
      <strong>
       之后的时序，门数，和功耗的？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     对timing的影响：slowtransition使得速度变慢，fast transition使得速度变快
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     对power的影响：slowtransition时功耗增大，fast时功耗减小
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     对gatecount的影响：要分以下2种情况，（1）如果整体的transition要求较高，slow transition会增加gatecount；（2）如果整体的transition要求不高，input transition对gate count没有大的影响
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     注意：inputtransition会逐级传送到chip里面的，虽然效力在逐级减小
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么叫克隆和缓冲，什么情况下用到这
      </strong>
      <strong>
       2
      </strong>
      <strong>
       种技术？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     cloning是在有多个sink的情况下，不改变逻辑功能把当前cell复制一份，分别驱动下一级的cell，这样可以减少当前单元的负载，从而获得更好的时序，有时是为了placement的考虑，譬如几个sink的方向不同，缺点是会增加上一级的负载
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     buffering是在不改变信号的情况下对信号再生，提高它的驱动能力，通常是两级反相器构成，可以提高电路的运行速度，有时也用来当延时单元，特点是不会增加上一级的负载
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     在多个sink的时序都比较紧的情况下适合用cloning，如果sink对timing的要求区别挺大的，可以用buffering，一部分时序较紧的由上一级直接驱动，剩下的可以加一级buffer后驱动
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       LEF
      </strong>
      <strong>
       是做什么用的？与
      </strong>
      <strong>
       GDS
      </strong>
      <strong>
       的区别是什么？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     LEF是一种简化版的GDS，它只包括size和metal层有关的信息，比如pin，blockage等，其他baselayer的东西只在GDS里面可以看到。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     同时LEF还有一些GDS里面没有的信息，比如，metal的R,C，routingand placement rule等
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     LEF是一个文本文件，可以修改编辑。GDS是二进制文件，比较难修改
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       详细解释形式验证和仿真的异同
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     形式验证是为了验证综合前后或者layout前后，电路是否在数学模型上有改变吧。那综合前后的形式验证为例，用formality进行形式验证时需要DC提供验证节点，然后FM根据这些节点去验证综合前后的电路在数学逻辑功能上是否等价。形式验证不需要任何激励测试向量，他能保证逻辑上电路没有发生变化。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     仿真的话有分为layout前后的仿真，前仿真主要用于测试功能是否正确，需要测试激励，后仿真主要用于测试是否满足时序（当然也就测试了功能是否正确），同样也需要激励信号。仿真的目的是模拟电路实际工作状态，看输入和输出是否满足设计要求。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果要说区别的话，我个人感觉形式验证就像数字电路中的analyse，分析电路功能，看是否满足设计要求，而仿真的话更多的是在模拟实际电路工作情况。
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       为什么综合时，不动
      </strong>
      <strong>
       clock
      </strong>
      <strong>
       ？为什么不动某些大扇出的
      </strong>
      <strong>
       net
      </strong>
      <strong>
       ，比如
      </strong>
      <strong>
       reset
      </strong>
      <strong>
       ？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     因为clock tree与leafpin的物理位置密切相关，DC没有这些个信息，做了也不准，所以就不做了。也是因为后端知道DC给的clcok tree根本不准，所以一旦遇到，就直接删除
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     至于resettree，是可做可不做，如果reset的时序很难的话，还是建议做一下，看看DC时是否可以满足时序，如果DC都满足不了，估计后端也很难做到，趁早想别的方案
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       如何计算
      </strong>
      <strong>
       gate count
      </strong>
      <strong>
       ？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     以前比较确切地定义是4个transistor为一个gate，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     计算整个设计的gate count时，应该先算出（所有standardcell的总面积），再除以（4个transistor的面积）。注意，各种RAM，PLL，ADC，DAC等macro不能算在总面积里
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     现在人们为了简单，就把一倍驱动能力的，2输入的nandcell的面积认为一个gate的面积，一个nandcell与4个transistor的面积是有一点差别的，但是你一般不容易搞到准确的4个transistor的面积
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     所以现在的standard cell的gatecount就变成（所有standard cell的总面积），再除以（一倍驱动能力的，2输入的nand cell的面积）
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       什么是
      </strong>
      <strong>
       ESD?
      </strong>
      <strong>
       在什么地方需要插入
      </strong>
      <strong>
       ESD
      </strong>
      <strong>
       电路？
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     ESD是指静电放电。带有足够高电荷的电气绝缘的导体在靠近时，会形成有相反电势的集成电路，电荷“跨接”，从而引起静电放电(ESD)。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     ESD是指静电泄放。一般在IO 的InPut 加ESD电路，在IC的测试。封装。运输。使用等过程中可以把静电有效泄放避免对CMOS 栅极的损伤，从而有效地保护IC。
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     如果不考虑模拟电路的干扰问题，基本上在各个VDD，VSS之间都要加入back-to-backdiode的ESD电路
    </p>
    <ol>
     <li style="text-align:justify;">
      <strong>
       DFM
      </strong>
      <strong>
       包含什么？什么是
      </strong>
      <strong>
       OPC, RET, CMP
      </strong>
      <strong>
       和
      </strong>
      <strong>
       Litho
      </strong>
      <strong>
       物理
      </strong>
      <strong>
       /
      </strong>
      <strong>
       电子分析
      </strong>
      <strong>
       ?
      </strong>
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
     后端主要是double via， spead wirewidth/space, 还有add dummy metal，使metal desity更均匀，
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     OPC： optical proximity correction
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     CMP: chemical mechanicalplanarization
    </p>
    <p style="margin-left:.0001pt;text-align:justify;">
     RET: resolution enhancementtechniques
    </p>
    <ol>
     <li style="text-align:justify;">
     </li>
    </ol>
    <p style="margin-left:.0001pt;text-align:justify;">
    </p>
   </div>
  </div>
 </article>
</div>


