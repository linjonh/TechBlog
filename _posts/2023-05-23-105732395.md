---
layout: post
title: 操作系统为什么这么难
date: 2023-05-23 11:10:13 +0800
categories: [操作系统]
tags: [操作系统,后端,java]
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=105732395
    alt: 操作系统为什么这么难
artid: 105732395
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统为什么这么难
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     导读
    </h3>
    <p>
     对于计算机行业的朋友们来说，操作系统绝对是一门能让你学吐血的课程，这是为什么呢？我认为有这些原因：第一 ，专业名词晦涩难懂；第二，它摸不着，你要想看，倒是能看见，但你看的懂吗？正是这两个原因让我们跪倒在了操作系统面前。但别着急，本文会以一种易理解的描述来给你呈现一个操作系统的真面目，同时让你理解一些常见的专业名词和操作系统相关的概念。
    </p>
    <h3>
     <a id="_2">
     </a>
     一台电脑的启动
    </h3>
    <p>
     一台电脑的启动大概包含这么几个部分：电源 -&gt; BIOS -&gt; 自检 -&gt; 加载启动引导程序 -&gt; 执行具体的操作系统启动程序 -&gt; 启动完成
     <br/>
     BIOS：基本的输入输出系统，用来检测各硬件设备，如没问题，会到指定的地方加载操作系统启动难引导程序，它是写死在硬件上的一个软件。
    </p>
    <h3>
     <a id="_5">
     </a>
     主角出现
    </h3>
    <p>
     电脑启动后，我们的主角也就闪亮登场了，首先要明白我们的主角操作系统也不过就是一个软件而已
     <br/>
     和我们平常看到的软件没什么区别，它不过也是用来完成一些特定功能的程序摆了，只是它功能有点强大，完成的任务有点与众不同而已。说到它的功能那就是 管理计算机的硬件和应用，可以这么理解对下管理计算机硬件，对上为我们的应用服务。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4883295e29fef823b843fca2aa1fd1c6.png"/>
    </p>
    <h3>
     <a id="_9">
     </a>
     一些专业名词
    </h3>
    <h4>
     <a id="_10">
     </a>
     操作系统内核
    </h4>
    <p>
     可简单理解为管理计算机硬件的代码部分，是操作系统最关键、最核心的部分。
    </p>
    <h4>
     <a id="_13">
     </a>
     用户态和内核态
    </h4>
    <p>
     这两个名词可理解为操作系统的两个不同等级状态，操作系统在内核态它可以直接访问一些关键的、底层的CPU指令，它的权利更大，更加的核心；而在用户态，当你需要访问底层CPU指令时需要经内核的同意，即需要从用户态切换到内核态来访问，以此来增加操作系统的健壮性，可以说这是操作系统的两个权利等级，一个权利大，一个权利小。
    </p>
    <h4>
     <a id="___16">
     </a>
     进程 线程 纤程（协程）
    </h4>
    <p>
     简单的理解 进程就是运行中的程序，线程就是进程中的不同执行路径；专业的说 进程是操作系统资源分配的基本单位，而线程是调度执行的基本单位，进程拥有独立的内存空间，线程共享进程的内存空间。
     <br/>
     举个简单的例子：运行中的bilibili为一个进程，视屏播放 和 发弹幕就是进程中的两个线程。
     <br/>
     协程为用户态的线程，线程中的线程，协程间的切换不需要经过操作系统 （切换代价较小 适用于不需要和内核交互 高并发 多计算的场景）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9736fcbabaaa6299466b9623262a7182.png">
      <br/>
      <strong>
       注
      </strong>
      ：
      <br/>
      1.在Linux里进程和线程区别不大，创建线程即创建进程 只是和父进程共享内存空间。
      <br/>
      2.资源：独立的内存空间、内核数据结构（PCB Linux系统为每个进程维护一个PCB）
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/913d1220ecf44df346b3a70d4b555f84.png"/>
     </img>
    </p>
    <h4>
     <a id="___27">
     </a>
     僵尸进程 孤儿进程
    </h4>
    <p>
     子进程消亡，但父进程还没有释放PCB的进程称为僵尸进程
     <br/>
     父进程消亡 子进程还存在的进程称为孤儿进程 （父进程消亡后会出现新的父进程）
    </p>
    <h4>
     <a id="_31">
     </a>
     进程调度
    </h4>
    <p>
     <strong>
      涉及的问题
     </strong>
     <br/>
     哪个进程运行？什么时候运行？运行多长时间？
     <br/>
     <strong>
      进程分类
     </strong>
     ：
     <br/>
     IO密集型 CPU密集型
     <br/>
     <strong>
      优先级
     </strong>
     <br/>
     Linux系统将进程又分为实时进程和普通进程，二者可这样理解，实时进程相当于急诊，普通进程为一般情况，实时进程的优先级高于普通进程。
     <br/>
     <strong>
      调度策略
     </strong>
     <br/>
     不同的操作系统有着不同的调度策略，Linux通常按优先级的时间比分配，其他操作系统通常是按时间片分配。
    </p>
    <h4>
     <a id="_41">
     </a>
     中断
    </h4>
    <p>
     中断是一个信号，可分为硬中断和软中断，当我们做了一些操作后需要操作系统给予我们一些实时反馈时，计算机采取的一种措施或者说方式，就是中断机制。如当我们敲击键盘时，此时相当于我们给计算机发送了一个中断信号，当计算机收到这种信号后，会做出反馈。
    </p>
    <h5>
     <a id="_43">
     </a>
     硬中断
    </h5>
    <p>
     键盘、打印进、磁盘等硬件引起的中断称为硬中断 硬件和操作系统打交道的过程。
    </p>
    <p>
     <em>
      过程简易描述：
     </em>
     敲击键盘 —&gt; 发出中断信号 —&gt; 中断到达CPU —&gt; 内核 —&gt; 中断处理程序 —&gt; 处理 给出反馈。
    </p>
    <h5>
     <a id="_47">
     </a>
     软中断
    </h5>
    <p>
     程序引起的中断称为软中断 有系统调用时引发 软件想要通过操作系统进行硬件方面的操作。
    </p>
    <p>
     <em>
      过程简易描述：
     </em>
     程序发出系统调用 —&gt; 发出80中断（软中断信号）—&gt; 内核 —&gt; 中断处理（触发中断时会传递一些参数到达内核 内核根据参数做出反馈 一般 会将参数等数据加载到CPU寄存器中 执行具体的系统调用）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/16d99fb0bd55a9eab813d69cf08d30c2.png"/>
    </p>
    <h3>
     <a id="_52">
     </a>
     内存管理
    </h3>
    <p>
     操作系统中一个关键的部分就是内存管理，那么操作系统如何进行内存管理，使得各程序能够井然有序的执行而不发生错误呢？
    </p>
    <h4>
     <a id="_54">
     </a>
     内存管理的发展
    </h4>
    <p>
     对于DOS时代，操作系统一次只允许一个程序运行，也就是说内存中只会加载一个程序进来，因此也不会有太多的问题。随着计算机和软件的发展，计算机开始支持多程序运行，此时，内存会加载进多个程序，当多个程序同时进入内存时就会出现内存不够用、程序间相互影响的问题，这对于操作系统来说就是个噩耗，慢慢的慢慢的 为了解决这种问题，出现了内存分页 和 虚拟内存 ，也就是今天的操作系统种内存管理使用的方法，下面我们仔细介绍什么是内存分页？什么是虚拟内存？
    </p>
    <h4>
     <a id="_56">
     </a>
     内存分页（解决内存空间不足的问题）
    </h4>
    <p>
     以往人们通常会将程序整个加入内存，但其实我们大多数时间需要的不是一整个程序，而只是程序的一部分，这样就会出现内存的浪费，而且程序有大有小，这种分配方式将会使得内存出现许多的碎片内存的利用率非常的低。为了解决上述的两个问题，人们提出了内存分页的概念，即 将内存划分为一个个的小块，每块大小4KB（当然也可划分其他大小） 同时将我们的程序也划分为和内存块一样大小的程序段，当我们需要哪段程序时就将哪段加载到内存，这种方式即为
     <strong>
      内存分页
     </strong>
     。这样使得内存的利用率显著提高。
    </p>
    <p>
     或许这时候有人会问，那么当我的程序需要新的程序段 而内存已经占满时，会如何呢？这个问题就引出了内存分页中使用的一个著名算法
     <strong>
      LRU
     </strong>
     （最近最久未使用） 当上述问题出现时，内存将会根据这种算法找出最近最久没有使用的内存块，将该块程序移到swap分区（专门用来做交换的交换分区 在硬盘中）再将需要加载的程序段加载进来。
    </p>
    <h4>
     <a id="__61">
     </a>
     虚拟内存（解决程序互相影响问题 同时也保护了物理内存空间）
    </h4>
    <p>
     解决了内存空间不足的问题后，那么程序互相影响问题又该如何解决呢？这就引出了虚拟内存的概念
     <br/>
     <strong>
      虚拟内存
     </strong>
     即操作系统为每个进程都创建了一个虚拟的内存空间（假的，逻辑上的一块空间，实际并不存在）。
     <br/>
     <strong>
      实际上程序段还是在物理内存中放着，只是当我们需要运行该程序时 需要做复杂的地址的转换，找到真正的物理内存 需要借助CPU中的MMU(内存管理单元)来完成
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/430ad0adc899cf9be982d21a03b305a7.png"/>
    </p>
    <h6>
     <a id="_66">
     </a>
     注：地址转换的过程极为复杂，暂时不去了解。
    </h6>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


