---
layout: post
title: "第一天零基础入门刷题Python-算法篇-数据结构与算法的介绍持续更新"
date: 2025-01-19 19:43:44 +0800
description: "第一天Python数据结构与算法的详细介绍提示：以下是本篇文章正文内容，下面案例可供参考数据结构：是"
keywords: "算法刷题 csdn python"
categories: ['Python']
tags: ['算法', 'Python']
artid: "145246209"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145246209
    alt: "第一天零基础入门刷题Python-算法篇-数据结构与算法的介绍持续更新"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【第一天】零基础入门刷题Python-算法篇-数据结构与算法的介绍（持续更新）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
     </p>
    </blockquote>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#_7" rel="nofollow">
        前言
       </a>
      </li>
      <li>
       <a href="#Python_24" rel="nofollow">
        一、Python数据结构与算法的详细介绍
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_25" rel="nofollow">
          1.基本概念
         </a>
        </li>
        <li>
         <a href="#2Python_44" rel="nofollow">
          2.Python中的数据结构
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1_List_47" rel="nofollow">
            1. 列表（List）
           </a>
          </li>
          <li>
           <a href="#2_Tuple_51" rel="nofollow">
            2. 元组（Tuple）
           </a>
          </li>
          <li>
           <a href="#3_Dictionary_54" rel="nofollow">
            3. 字典（Dictionary）
           </a>
          </li>
          <li>
           <a href="#4_Set_59" rel="nofollow">
            4. 集合（Set）
           </a>
          </li>
          <li>
           <a href="#5_String_62" rel="nofollow">
            5. 字符串（String）
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#3Python_66" rel="nofollow">
          3.Python中的常用算法
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1__68" rel="nofollow">
            1. 排序算法
           </a>
          </li>
          <li>
           <a href="#2__76" rel="nofollow">
            2. 搜索算法
           </a>
          </li>
          <li>
           <a href="#3__80" rel="nofollow">
            3. 递归算法
           </a>
          </li>
          <li>
           <a href="#4__84" rel="nofollow">
            4. 动态规划
           </a>
          </li>
          <li>
           <a href="#5__86" rel="nofollow">
            5. 贪心算法
           </a>
          </li>
          <li>
           <a href="#6__88" rel="nofollow">
            6. 分治算法
           </a>
          </li>
          <li>
           <a href="#7__91" rel="nofollow">
            7. 回溯算法
           </a>
          </li>
          <li>
           <a href="#8__93" rel="nofollow">
            8. 图论算法
           </a>
          </li>
          <li>
           <a href="#9__122" rel="nofollow">
            9. 字符串算法
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#4_126" rel="nofollow">
          4.算法的时间复杂度和空间复杂度
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1__127" rel="nofollow">
            1. 时间复杂度
           </a>
          </li>
          <li>
           <a href="#2__129" rel="nofollow">
            2. 空间复杂度
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_136" rel="nofollow">
        总结
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_7">
     </a>
     前言
    </h2>
    <p>
     <code>
      提示：这里可以添加本文要记录的大概内容：
     </code>
    </p>
    <p>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145246209?spm=1001.2014.3001.5501">
      第一天
     </a>
     Python数据结构与算法的详细介绍
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145268566?sharetype=blogdetail&amp;sharerId=145268566&amp;sharerefer=PC&amp;sharesource=2301_78806917&amp;spm=1011.2480.3001.8118https://blog.csdn.net/2301_78806917/article/details/145268566?sharetype=blogdetail&amp;sharerId=145268566&amp;sharerefer=PC&amp;sharesource=2301_78806917&amp;spm=1011.2480.3001.8118">
      第二天
     </a>
     五种常见的排序算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145289246?spm=1001.2014.3001.5501">
      第三天
     </a>
     两种常见的搜索算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145311579?sharetype=blogdetail&amp;sharerId=145311579&amp;sharerefer=PC&amp;sharesource=2301_78806917&amp;spm=1011.2480.3001.8118">
      第四天
     </a>
     两种常见的递归算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145330051?sharetype=blogdetail&amp;sharerId=145330051&amp;sharerefer=PC&amp;sharesource=2301_78806917&amp;spm=1011.2480.3001.8118">
      第五天
     </a>
     一种常见的动态规划算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145347035?sharetype=blogdetail&amp;sharerId=145347035&amp;sharerefer=PC&amp;sharesource=2301_78806917&amp;spm=1011.2480.3001.8118">
      第六天
     </a>
     一种常见的贪心算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145360081">
      第七天
     </a>
     一种常见的分治算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145372376">
      第八天
     </a>
     一种常见的回溯算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145382927">
      第九天
     </a>
     六种常见的图论算法
     <br/>
     <a href="https://blog.csdn.net/2301_78806917/article/details/145389289">
      第十天
     </a>
     两种常见的字符串算法
    </p>
    <p>
     <code>
      提示：以下是本篇文章正文内容，下面案例可供参考
     </code>
    </p>
    <h2>
     <a id="Python_24">
     </a>
     一、Python数据结构与算法的详细介绍
    </h2>
    <h3>
     <a id="1_25">
     </a>
     1.基本概念
    </h3>
    <blockquote>
     <p>
      数据结构：是指计算机中存储和组织数据的方式。不同的数据结构适用于不同的应用场景，选择合适的数据结构可以显著提高程序的运行效率。数据结构涵盖数据内容、数据之间关系和数据操作方法，具有以下设计目标：
     </p>
     <ul>
      <li>
       空间占用尽量少，以节省计算机内存。
      </li>
      <li>
       数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。
      </li>
      <li>
       提供简洁的数据表示和逻辑信息，以便算法高效运行。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      算法：是指完成特定任务的一系列步骤或规则，它在有限时间内解决特定问题的一组指令或操作步骤。算法具有以下特性：
     </p>
     <ul>
      <li>
       问题是明确的，包含清晰的输入和输出定义。
      </li>
      <li>
       具有可行性，能够在有限步骤、时间和内存空间下完成。
      </li>
      <li>
       各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      数据结构与算法高度相关、紧密结合，具体表现在以下三个方面：
     </p>
     <ul>
      <li>
       数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。
      </li>
      <li>
       算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
      </li>
      <li>
       算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。
      </li>
     </ul>
    </blockquote>
    <h3>
     <a id="2Python_44">
     </a>
     2.Python中的数据结构
    </h3>
    <blockquote>
     <p>
      Python内置了多种数据结构，涵盖了常见的线性和非线性数据结构。以下是Python中一些主要的
      <strong>
       数据结构
      </strong>
      ：
     </p>
    </blockquote>
    <h4>
     <a id="1_List_47">
     </a>
     1. 列表（List）
    </h4>
    <blockquote>
     <ol>
      <li>
       <strong>
        列表（List）
       </strong>
       ：Python中最常用的内置数据结构之一，可以存储任意类型的元素，并且支持动态调整大小。 创建列表：my_list = []（空列表）或my_list = [1, 2, 3, 4, 5]（包含元素的列表）。
       <br/>
       列表操作：添加元素my_list.append(6)、删除元素my_list.remove(3)、访问元素print(my_list[2])、列表切片print(my_list[1:4])。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="2_Tuple_51">
     </a>
     2. 元组（Tuple）
    </h4>
    <blockquote>
     <ol start="2">
      <li>
       <strong>
        元组（Tuple）
       </strong>
       ：不可变的序列，创建后不能修改。元组通常用于存储固定数量的元素。 创建元组：my_tuple = ()（空元组）或my_tuple = (1, 2, 3, 4, 5)（包含元素的元组）。
       <br/>
       元组操作：访问元素print(my_tuple[2])、元组切片print(my_tuple[1:4])。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="3_Dictionary_54">
     </a>
     3. 字典（Dictionary）
    </h4>
    <blockquote>
     <ol start="3">
      <li>
       <strong>
        字典（Dictionary）
       </strong>
       ：键值对数据结构，支持快速查找、插入和删除操作。 创建字典：my_dict = {}（空字典）或my_dict = {‘name’: ‘Alice’, ‘age’: 25, ‘city’: ‘New York’}（包含键值对的字典）。
       <br/>
       字典操作：添加或更新键值对my_dict[‘age’] = 26、删除键值对del
       <br/>
       my_dict[‘city’]、访问值print(my_dict[‘name’])、遍历字典for key, value in
       <br/>
       my_dict.items(): print(f’{key}:{value}')。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="4_Set_59">
     </a>
     4. 集合（Set）
    </h4>
    <blockquote>
     <ol start="4">
      <li>
       <strong>
        集合（Set）
       </strong>
       ：无序的、不可重复的数据结构，支持集合运算如交集、并集和差集。 创建集合：my_set = set()（空集合）或my_set
       <br/>
       = {1, 2, 3, 4, 5}（包含元素的集合）。 集合操作：添加元素my_set.add(6)、删除元素my_set.remove(3)、集合运算（如并集my_set.union(other_set)、交集my_set.intersection(other_set)、差集my_set.difference(other_set)）。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="5_String_62">
     </a>
     5. 字符串（String）
    </h4>
    <blockquote>
     <ol start="5">
      <li>
       <strong>
        字符串（String）
       </strong>
       ：有序字符集合，支持多种字符串操作，如拼接、切片、查找等。
       <br/>
       此外，Python还支持其他更复杂的数据结构，
       <strong>
        如栈（Stack）、队列（Queue）、树（Tree）、图（Graph）等。
       </strong>
      </li>
     </ol>
    </blockquote>
    <h3>
     <a id="3Python_66">
     </a>
     3.Python中的常用算法
    </h3>
    <p>
     以下是Python中的一些常用算法：
    </p>
    <h4>
     <a id="1__68">
     </a>
     1. 排序算法
    </h4>
    <blockquote>
     <ol>
      <li>
       <strong>
        排序算法
       </strong>
       ：将一组数据按特定顺序排列。常见的排序算法有冒泡排序、选择排序、插入排序、快速排序和归并排序等。
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        冒泡排序
       </strong>
       ：通过重复遍历要排序的数列，比较相邻元素的值，若发现逆序则交换，直到没有逆序为止。时间复杂度为O(n^2)，空间复杂度为O(1)。
      </li>
      <li>
       <strong>
        选择排序
       </strong>
       ：每次从未排序部分选择最小（或最大）元素，放到已排序部分的末尾。时间复杂度O(n^2)，空间复杂度O(1)。
      </li>
      <li>
       <strong>
        插入排序
       </strong>
       ：将每个新元素插入到已排序部分的适当位置。时间复杂度O(n^2)（最坏情况），空间复杂度O(1)。
      </li>
      <li>
       <strong>
        快速排序
       </strong>
       ：选择一个基准元素，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，以达到整个数据变成有序序列。时间复杂度为O(n
       <br/>
       log n)，空间复杂度为O(log n)（递归栈空间）。
      </li>
      <li>
       <strong>
        归并排序
       </strong>
       ：采用分治法，将数组分成两半，递归排序后合并。时间复杂度O(n log n)，空间复杂度O(n)（需要额外空间合并）。
      </li>
     </ul>
    </blockquote>
    <h4>
     <a id="2__76">
     </a>
     2. 搜索算法
    </h4>
    <blockquote>
     <ol start="2">
      <li>
       <strong>
        搜索算法
       </strong>
       ：在数据集中查找特定元素。常见的搜索算法有线性搜索和二分搜索等。
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        线性搜索
       </strong>
       ：从数据集的第一个元素开始，依次比较每个元素，直到找到目标元素或搜索完整个数据集为止。时间复杂度为O(n)，空间复杂度为O(1)。
      </li>
      <li>
       <strong>
        二分搜索
       </strong>
       ：要求数据集必须是有序的，通过不断将搜索范围减半来查找目标元素。时间复杂度为O(log n)，空间复杂度为O(1)。
      </li>
     </ul>
    </blockquote>
    <h4>
     <a id="3__80">
     </a>
     3. 递归算法
    </h4>
    <blockquote>
     <ol start="3">
      <li>
       <strong>
        递归算法
       </strong>
       ：函数调用自身来解决问题的编程技巧。递归通常用于分治法、树和图的遍历等。
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        斐波那契数列
       </strong>
       ：通过递归调用自身来计算斐波那契数列的第n项。时间复杂度为O(2^n)，空间复杂度为O(n)（递归栈空间）。
      </li>
      <li>
       <strong>
        阶乘
       </strong>
       ：通过递归调用自身来计算一个数的阶乘。时间复杂度为O(n)，空间复杂度为O(n)（递归栈空间）。
      </li>
     </ul>
    </blockquote>
    <h4>
     <a id="4__84">
     </a>
     4. 动态规划
    </h4>
    <blockquote>
     <ol start="4">
      <li>
       <strong>
        动态规划
       </strong>
       ：解决最优化问题，通过将问题分解为子问题，并记录子问题的解以避免重复计算。时间复杂度和空间复杂度依具体问题而定，但通常较低于朴素递归解法。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="5__86">
     </a>
     5. 贪心算法
    </h4>
    <blockquote>
     <ol start="5">
      <li>
       <strong>
        贪心算法
       </strong>
       ：在每一步选择中都采取最好或最优（即最有利）的选择，从而希望能够导致结果是全局最好或最优的算法。时间复杂度依具体问题而定。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="6__88">
     </a>
     6. 分治算法
    </h4>
    <blockquote>
     <ol start="6">
      <li>
       <strong>
        分治算法
       </strong>
       ：
       <br/>
       将问题划分为几个规模较小的子问题分别解决，然后将子问题的解合并得到原问题的解。快速排序和归并排序是分治算法的典型例子。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="7__91">
     </a>
     7. 回溯算法
    </h4>
    <blockquote>
     <ol start="7">
      <li>
       <strong>
        回溯算法
       </strong>
       ：通过搜索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解，即“回溯”并尝试另一个可能的候选解。时间复杂度通常很高，因为需要探索所有可能的解空间。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="8__93">
     </a>
     8. 图论算法
    </h4>
    <blockquote>
     <ol start="8">
      <li>
       <strong>
        图论算法
       </strong>
       ：
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        深度优先搜索（DFS）
       </strong>
       ：
       <br/>
       用途：用于图的遍历或路径查找。
       <br/>
       时间复杂度：O(V+E)，其中V是顶点数，E是边数。
       <br/>
       空间复杂度：O(V)（递归栈空间）。
      </li>
      <li>
       <strong>
        广度优先搜索（BFS）
       </strong>
       ：
       <br/>
       用途：用于图的遍历或最短路径查找（无权图）。
       <br/>
       时间复杂度：O(V+E)。
       <br/>
       空间复杂度：O(V)（队列空间）。
      </li>
      <li>
       <strong>
        Dijkstra算法
       </strong>
       ：
       <br/>
       用途：用于计算单源最短路径（有权图）。
       <br/>
       时间复杂度：O(V^2)（朴素实现）或O((V+E) log V)（优先队列实现）。
       <br/>
       空间复杂度：O(V)。
       <br/>
       最小生成树算法：
      </li>
      <li>
       <strong>
        Prim算法
       </strong>
       ：
       <br/>
       用途：用于求解最小生成树。
       <br/>
       时间复杂度：
       <br/>
       使用邻接矩阵：O(V^2)。
       <br/>
       使用斐波那契堆等数据结构：O(E log V)。
       <br/>
       空间复杂度：根据具体实现而定，通常与顶点数和边的数量相关。
      </li>
      <li>
       <strong>
        Kruskal算法
       </strong>
       ：
       <br/>
       用途：用于求解最小生成树。
       <br/>
       时间复杂度：O(E log E)，其中E是边的数量。
       <br/>
       空间复杂度：O(E)（存储边）和O(V)（并查集数据结构）。
      </li>
      <li>
       <strong>
        Floyd-Warshall算法
       </strong>
       ：
       <br/>
       用途：用于计算所有顶点对之间的最短路径（有权图）。
       <br/>
       时间复杂度：O(V^3)，其中V是顶点数。注意这里的复杂度是立方，与上述算法不同。
       <br/>
       空间复杂度：O(V^2)（存储距离矩阵）。
      </li>
     </ul>
    </blockquote>
    <h4>
     <a id="9__122">
     </a>
     9. 字符串算法
    </h4>
    <blockquote>
     <ol start="9">
      <li>
       <strong>
        字符串算法
       </strong>
       ：
      </li>
     </ol>
     <ul>
      <li>
       <strong>
        KMP算法
       </strong>
       ：用于字符串匹配，时间复杂度O(n+m)，其中n和m分别是文本和模式的长度。空间复杂度O(m)。
      </li>
      <li>
       <strong>
        Rabin-Karp算法
       </strong>
       ：基于哈希的字符串匹配算法，时间复杂度平均O(n+m)，最坏O(n*m)。空间复杂度O(1)（不考虑哈希表）。
      </li>
     </ul>
    </blockquote>
    <h3>
     <a id="4_126">
     </a>
     4.算法的时间复杂度和空间复杂度
    </h3>
    <h4>
     <a id="1__127">
     </a>
     1. 时间复杂度
    </h4>
    <blockquote>
     <ol>
      <li>
       时间复杂度：是指算法运行时间随输入规模增长的变化情况。常见的时间复杂度包括常数时间O(1)、线性时间O(n)、对数时间O(log n)、线性对数时间O(n log n)、平方时间O(n
       <sup>
        2)、立方时间O(n
       </sup>
       3)和指数时间O(2^n)等。
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="2__129">
     </a>
     2. 空间复杂度
    </h4>
    <blockquote>
     <ol start="2">
      <li>
       空间复杂度：是指算法运行时所需的存储空间随输入规模增长的变化情况。空间复杂度主要衡量算法在运行过程中临时占用存储空间的大小。 在实际应用中，需要根据具体问题的需求和约束条件，选择合适的数据结构和算法，以优化程序的性能。同时，也需要关注算法的时间复杂度和空间复杂度，以确保程序在可接受的范围内运行。
      </li>
     </ol>
    </blockquote>
    <hr/>
    <h2>
     <a id="_136">
     </a>
     总结
    </h2>
    <p>
     提示：这里对文章进行总结：
     <br/>
     例如：以上就是今天要讲的内容，本文简单介绍数据结构与算法的介绍。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37383830363931372f:61727469636c652f64657461696c732f313435323436323039" class_="artid" style="display:none">
 </p>
</div>


