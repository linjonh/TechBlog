---
layout: post
title: "Web前端前沿技术专业术语解读"
date: 2016-04-10 15:32:30 +0800
description: "最近常听到关于web前端中许多新鲜的术语，并不明白是什么技术，比如Browserify Webpac"
keywords: "关于web technology的专业名词"
categories: ['Web']
tags: ['Web', 'Web', 'Web', 'Svn', 'Git']
artid: "51113167"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51113167
    alt: "Web前端前沿技术专业术语解读"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Web前端前沿技术专业术语解读
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     最近常听到关于web前端中许多新鲜的术语，并不明白是什么技术，比如Browserify Webpack NPM Bower等。下面将对一下前沿技术专业术语进行一个简单的解读，和一个层次的索引归类
    </p>
    <h3 id="什么是fis">
     什么是FIS
    </h3>
    <p>
     FIS 前端集成解决方案 Front-end Integrated Solution
    </p>
    <h3 id="什么是git和svn">
     什么是GIT和SVN ?
    </h3>
    <p>
     简单来说GIT和SVN都是版本管理系统。GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。
    </p>
    <h3 id="什么是coffeescript">
     什么是CoffeeScript
    </h3>
    <p>
     CoffeeScript是一套JavaScript的转译语言，相当于是JavaScript预编译有点像css预编译的意思
    </p>
    <h3 id="什么是grunt-gulp">
     什么是grunt、 gulp
    </h3>
    <p>
     前端构建工具也可以理解为前端自动化工具
     <br/>
     1. 可以自动编译less，sass为css
     <br/>
     2. 文件合并
     <br/>
     3. 文件压缩
     <br/>
     4. 语法检查
     <br/>
     5. 监听文件变化
    </p>
    <h3 id="什么是commonjs">
     什么是CommonJS
    </h3>
    <p>
     根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。可以理解为CommonJS是一种规范,是用在服务器端的，NodeJS是这种规范的实现。CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。
     <br/>
     开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中：
     <br/>
     ①服务器端JavaScript应用程序
     <br/>
     ②命令行工具
     <br/>
     ③图形界面应用程序
     <br/>
     ④混合应用程序（如，Titanium或Adobe AIR）)。
    </p>
    <h3 id="什么是模块">
     什么是模块
    </h3>
    <ul>
     <li>
      DuoJS
     </li>
     <li>
      RequireJS
     </li>
     <li>
      Sea.js
     </li>
     <li>
      ReactJS
     </li>
     <li>
      AngularJS
     </li>
    </ul>
    <p>
     浏览器本身并不提供模块管理的机制，为了调用各个模块，有时不得不在网页中，加入一大堆script标签。这样就使得网页体积臃肿，难以维护，还产生大量的HTTP请求，拖慢显示速度，影响用户体验。
     <br/>
     为了解决这个问题，前端的模块管理器（package management）应运而生。它可以轻松管理各种JavaScript脚本的依赖关系，自动加载各个模块，使得网页结构清晰合理。不夸张地说，将来所有的前端JavaScript项目，应该都会采用这种方式开发。
     <br/>
     最早也是最有名的前端模块管理器，非RequireJS莫属。它采用AMD格式，异步加载各种模块。具体的用法，可以参考我写的教程。Require.js的问题在于各种参数设置过于繁琐，不容易学习，很难完全掌握。而且，实际应用中，往往还需要在服务器端，将所有模块合并后，再统一加载，这多出了很多工作量。
    </p>
    <h3 id="模块管理器">
     模块管理器
    </h3>
    <ul>
     <li>
      AMD
     </li>
     <li>
      CMD
     </li>
     <li>
      Browserify
     </li>
     <li>
      Bower
     </li>
     <li>
      Component
     </li>
     <li>
      NPM
     </li>
    </ul>
    <p>
     NPM是nodejs官方未nodejs定制的一个工具，是Node.js的包管理器，是Node Packaged Modules的简称，通过npm可以下载安装nodejs的模块包，nodejs有很多优秀的模块包可以让开发这快速开发。是为了帮助Node解决依赖包的安装问题
     <br/>
     NPM属于Node模块的管理器。而spm和bower、Component是前端模块管理，作为一个静态资源共享平台，用来发布和共享前端模块
    </p>
    <p>
     AMD、CMD是用在浏览器端的，异步的，如RequireJS 和SeaJS
     <br/>
     AMD((Asynchromous Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出
     <br/>
     CMD是SeaJS 在推广过程中对模块定义的规范化产出
     <br/>
     CMD和AMD的区别有以下几点：
     <br/>
     ①对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）
     <br/>
     ②CMD推崇依赖就近，AMD推崇依赖前置。
     <br/>
     ③AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。
    </p>
    <p>
     Browserify 是目前最常用的 CommonJS 格式转换的工具。Browserify本身不是模块管理器，只是让服务器端的CommonJS格式的模块可以运行在浏览器端。这意味着通过它，我们可以使用Node.js的npm模块管理器。所以，实际上，它等于间接为浏览器提供了npm的功能
    </p>
    <p>
     spm和bower、component都是针对前端模块化共享而提供的解决方案
    </p>
    <p>
     最后
     <br/>
     - Browserify和Webpack属于同一类型技术
     <br/>
     - GIT和SVN 属于同一类型技术
     <br/>
     - AMD CMD Bower Component NPM属于同一类型技术
     <br/>
     - CommonJS 是一种规范 AngularJS RequireJS ReactJS SeaJS是基于这种规范上应运而生的框架
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874:7470733a2f2f626c6f672e6373646e2e6e65742f4a5343544f:2f61727469636c652f64657461696c732f3531313133313637" class_="artid" style="display:none">
 </p>
</div>


