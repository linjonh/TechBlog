---
layout: post
title: "基于数据库的分布式锁实现"
date: 2025-01-04 11:00:00 +0800
description: "一、基于数据库表要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现"
keywords: "数据库实现分布式锁"
categories: ['分布式知识体系']
tags: ['数据库', '悲观锁', '分布式锁', '乐观锁']
artid: "78495629"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=78495629
    alt: "基于数据库的分布式锁实现"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     基于数据库的分布式锁实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      一、基于数据库表
     </strong>
    </p>
    <p>
     要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源的时候，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。
    </p>
    <p>
     创建这样一张数据库表：
    </p>
    <pre class="prettyprint"><code class="hljs sql"><span class="hljs-operator"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`methodLock`</span> (
  <span class="hljs-string">`id`</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">'主键'</span>,
  <span class="hljs-string">`method_name`</span> <span class="hljs-keyword">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'锁定的方法名'</span>,
  <span class="hljs-string">`desc`</span> <span class="hljs-keyword">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'备注信息'</span>,
  <span class="hljs-string">`update_time`</span> <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">'保存数据时间，自动生成'</span>,
  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),
  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`uidx_method_name`</span> (<span class="hljs-string">`method_name `</span>) <span class="hljs-keyword">USING</span> BTREE
)
 ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 COMMENT=<span class="hljs-string">'锁定中的方法'</span>;</span></code></pre>
    <p>
     当我们要锁住某个方法时，执行以下SQL：
    </p>
    <pre class="prettyprint"><code class="hljs sql"><span class="hljs-operator"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> methodLock(method_name,<span class="hljs-keyword">desc</span>) <span class="hljs-keyword">values</span> (‘method_name’,‘<span class="hljs-keyword">desc</span>’)</span></code></pre>
    <p>
     因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们可以认为操作成功的那个线程获得了该方法的锁，可以执行具体内容。
    </p>
    <p>
     当方法执行完毕之后，想要释放锁的话，需要执行以下sql：
    </p>
    <pre class="prettyprint"><code class="hljs sql"> <span class="hljs-operator"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> methodLock <span class="hljs-keyword">where</span> method_name =<span class="hljs-string">'method_name'</span></span></code></pre>
    <p>
     上面这种简单的实现有以下几个问题：
    </p>
    <p>
     1、这把锁依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
     <br/>
     2、这把锁没有失效时间，一旦解决操作失败，就会导致记录一直在数据库中，其他线程无法在获得锁。
     <br/>
     3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁的操作。
     <br/>
     4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库表中数据已经存在了。
    </p>
    <p>
     当然，我们也可以有其它方式解决上面的问题：
    </p>
    <p>
     1、数据库是单点？那就搞两个数据库，数据库之前双向同步，一旦挂掉快速切换到备库上。
     <br/>
     2、没有失效时间？可以做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
     <br/>
     3、非阻塞？可以写一个while循环，直到insert成功再返回成功。
     <br/>
     4、非重入？可以在数据库表中加一个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库中可以查到的话，就直接把锁分配给它即可。
    </p>
    <p>
     <strong>
      二、基于数据库表做乐观锁
     </strong>
    </p>
    <p>
     常用的方法是为数据增加一个版本标识，具体实现请参考
     <a href="http://blog.csdn.net/lmb55/article/details/78266667">
      http://blog.csdn.net/lmb55/article/details/78266667
     </a>
    </p>
    <p>
     <strong>
      三、基于数据库表做悲观锁（排它锁）
     </strong>
    </p>
    <p>
     除了可以通过增删操作数据库表中的记录以外，还可以借助数据库中自带的锁来实现分布式锁。
    </p>
    <p>
     我们还用上面创建的数据库表，可以通过数据库的排它锁来实现分布式锁。基于MySQL的InnoDB引擎，可以使用以下方法来实现
     <strong>
      加锁操作
     </strong>
     ：
    </p>
    <pre class="prettyprint"><code class="hljs cs"> <span class="hljs-keyword">public</span> boolean <span class="hljs-title">lock</span>(){
            Connection.setAutoCommit(<span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                  <span class="hljs-keyword">try</span> {
                        result = <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> MethodLock <span class="hljs-keyword">where</span> methodName = <span class="hljs-string">'xxxx'</span> <span class="hljs-keyword">for</span> update;
                        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) {
                              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                        }
                  } <span class="hljs-keyword">catch</span> (Exception e) {

                  }
                  sleep(<span class="hljs-number">1000</span>);
            }
            returnType <span class="hljs-keyword">false</span>;
      }</code></pre>
    <p>
     在查询语句后面增加
     <strong>
      for update
     </strong>
     ，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。
    </p>
    <p>
     我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>(){
          connection.commit();
}</code></pre>
    <p>
     通过connection.commit()操作来释放锁。
    </p>
    <p>
     这里还可能存在另外一个问题，虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。
    </p>
    <p>
     还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。
    </p>
    <p>
     这种方法
     <strong>
      可以有效的解决上面提到的无法释放锁和阻塞锁的问题
     </strong>
     ：
    </p>
    <p>
     1、阻塞锁？for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。
     <br/>
     2、锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。
    </p>
    <p>
     但是还是
     <strong>
      无法解决数据库单点和可重入的问题
     </strong>
     。
    </p>
    <p>
     优点：直接借助数据库容易理解；
    </p>
    <p>
     缺点：
     <br/>
     1、会有各种各样的问题，在解决问题的过程中会使整个方案变的越来越复杂。
     <br/>
     2、操作数据库需要一定的开销，性能问题需要考虑。
    </p>
    <p>
     总结：
     <br/>
     使用数据库来实现分布式锁，
     <strong>
      这三种方式都是依赖数据库中的一张表，一种是通过表中的记录存在情况确定当前是否有锁存在，另外两种是通过数据库的乐观锁和排它锁/悲观锁来实现分布式锁
     </strong>
     。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874:7470733a2f2f626c6f672e6373646e2e6e65742f6c6d623535:2f61727469636c652f64657461696c732f3738343935363239" class_="artid" style="display:none">
 </p>
</div>


