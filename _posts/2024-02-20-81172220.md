---
layout: post
title: "操作系统19IO系统之与设备无关的IO软件用户层的IO软件"
date: 2024-02-20 15:40:30 +0800
description: "操作系统19———IO系统之与设备无关的I/O软件&a"
keywords: "与设备无关性的基本含义是什么? 为什么要设置该层?"
categories: ['操作系统']
tags: ['操作系统']
artid: "81172220"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=81172220
    alt: "操作系统19IO系统之与设备无关的IO软件用户层的IO软件"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统19———IO系统之与设备无关的I/O软件&amp;用户层的I/O软件
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="19IOIOIO_0">
     </a>
     操作系统19———IO系统之与设备无关的I/O软件&amp;用户层的I/O软件
    </h2>
    <h4>
     <a id="_1">
     </a>
     一.目录
    </h4>
    <h4>
     <a id="_2">
     </a>
     二.与设备无关软件的基本概念
    </h4>
    <p>
     <strong>
      设备独立性（设备无关性）的含义
     </strong>
     ：应用程序中所用的设备，不局限于使用某个具体的物理设备。
     <br/>
     <strong>
      与设备无关的I/O软件（设备独立性软件）含义
     </strong>
     ：在设备驱动程序之上设置一层软件，以实现设备独立性。
    </p>
    <h5>
     <a id="1__6">
     </a>
     1. 以物理设备名使用设备
    </h5>
    <p>
     早期OS中，应用程序在使用I/O设备时，都使用设备的物理名字，但这样会导致很多的问题，比如：不灵活，给用户带来不便。对提高I/O设备的利用率也很不利。
    </p>
    <h5>
     <a id="2_8">
     </a>
     2.引入了逻辑设备名
    </h5>
    <p>
     为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。逻辑设备是抽象的设备名，如/dev/printer，并不指定哪一台打印机。好处：系统设备分配灵活。
     <br/>
     可实现I/O重定向。即：用于IO操作的设备可更换，而不必改变应用程序。
    </p>
    <p>
     如修改逻辑设备表：终端-&gt;打印机
    </p>
    <h5>
     <a id="3_14">
     </a>
     3.逻辑设备名到物理设备名的转换
    </h5>
    <p>
     为了实现逻辑设备名到物理设备名的映射，系统必须设置一张逻辑设备表LUT（Logical Unit Table），能够将应用程序中所使用的逻辑设备名映射为物理设备名，并提供该设备驱动程序的入口地址。
    </p>
    <p>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/16e2aba542a30e1810ce70f4658b60a8.png"/>
    </p>
    <h4>
     <a id="_18">
     </a>
     三.与设备无关的软件
    </h4>
    <p>
     与设备无关的软件是I/O系统的最高层软件，在它下面是设备的驱动程序。总的来说，与设备无关的软件中，包括了执行所有设备的公有操作的软件，具体包括如下几项：
    </p>
    <ol>
     <li>
      设备驱动的统一接口：可以很方便的添加设备的驱动程序。
     </li>
     <li>
      缓冲管理:见后面的博客
     </li>
     <li>
      差错控制:包括两类错误，暂时性错误，永久性错误。
     </li>
     <li>
      对独立设备的分配与回收:对独占设备有系统进行统一的分配和回收处理。
     </li>
     <li>
      独立于设备的逻辑数据块:隐藏不同设备的物理数据块大小的差异，向高层软件提供大小统一的逻辑数据块。
     </li>
    </ol>
    <h4>
     <a id="_27">
     </a>
     四.设备分配
    </h4>
    <p>
     系统为实现对独占设备的分配，必须在系统中配置相应的数据结构。
    </p>
    <h5>
     <a id="1_29">
     </a>
     1.设备分配中的数据结构
    </h5>
    <p>
     在用于设备分配的数据结构中，记录了对设备或控制器进行控制所需的信息。在进行设备分配时需要如下的数据结构。
    </p>
    <p>
     <strong>
      a.设备控制表DCT
     </strong>
     <br/>
     系统为每一个设备都配置了一张设备控制表，用于记录设备的情况，如下图
     <br/>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/164170b977d8ceba2e90919a049139a9.png">
      <br/>
      <strong>
       b.控制器控制表(COCT)
      </strong>
      <br/>
      系统为每一个控制器都设置了用于记录控制器情况的控制器控制表，如图(a)所示。
      <br/>
      <strong>
       c.通道控制表(CHCT)
      </strong>
      <br/>
      每个通道都有一张通道控制表，如图(b)所示。
      <br/>
      <strong>
       d.系统设备表(SDT)
      </strong>
      <br/>
      这是系统范围的数据结构，记录了系统中全部设备的情况，每个设备占一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等项，如图©所示。
      <br/>
      <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/12390dd773608cdd7451a031e1125d5f.png"/>
     </img>
    </p>
    <h5>
     <a id="2_42">
     </a>
     2.设备分配时应考虑的因素
    </h5>
    <p>
     <strong>
      a.设备的固有属性
     </strong>
     <br/>
     设备独占属性可分为三种。对它们应采取不同的分配策略:
    </p>
    <ul>
     <li>
      独享设备:将一个设备分配给某进程后，便由该进程独占，直到该进程完成或释放该设备。
     </li>
     <li>
      共享设备:对于共享设备，可同时分配给多个进程使用，此时必须注意对于这些进程访问该设备的先后次序进行合理调度。
     </li>
     <li>
      虚拟设备:虚拟设备属于可共享设备，可以将它同时分配给多个进程使用。
     </li>
    </ul>
    <p>
     <strong>
      b.设备分配算法
     </strong>
    </p>
    <ul>
     <li>
      <p>
       先来先服务：即按照进程的请求的先后次序来进行分配设备
      </p>
     </li>
     <li>
      <p>
       优先级高者优先：该算法将队列中的优先级较高的放在队首前
       <br/>
       <strong>
        c.设备分配中的安全性
       </strong>
      </p>
     </li>
     <li>
      <p>
       安全分配方式：进程发出I/O请求后就进入阻塞态
      </p>
     </li>
     <li>
      <p>
       不安全分配方式：进程发出I/O请求仍继续运行
      </p>
     </li>
    </ul>
    <h5>
     <a id="3_59">
     </a>
     3.独占设备的分配程序
    </h5>
    <p>
     <strong>
      a.基本的设备分配程序
     </strong>
     <br/>
     分配设备–&gt;分配控制器–&gt;分配通道
     <br/>
     <strong>
      b.设备分配程序的改进
     </strong>
    </p>
    <ul>
     <li>
      增加设备的独立性: 逻辑设备名请求I/O。系统应查找所有该类设备的DCT。
     </li>
     <li>
      考虑多通路情况:对多个控制器和通道的分配，必须查找所有的控制器和通道。
     </li>
    </ul>
    <h4>
     <a id="_67">
     </a>
     五.逻辑设备名到物理设备名映射的实现
    </h4>
    <p>
     为实现与设备的无关性，当应用程序请求使用I/O设备时，应当用逻辑设备名。但系统只识别物理设备名，因此在系统中需要配置一张逻辑设备表，用于将逻辑设备名映射为物理设备名。
    </p>
    <h5>
     <a id="1LUT_69">
     </a>
     1.逻辑设备表LUT
    </h5>
    <p>
     在逻辑设备表的每个表目中包含了三项：逻辑设备名、物理设备名和设备驱动程序的入口地址。如下图。当进程用逻辑表请求分配I/O设备时，系统根据当时的具体情况，为它分配一个相应的物理设备。同时，在逻辑设备表中建立一个标目，填上应用程序中使用的逻辑设备名和系统分配的物理设备名，以及该设备驱动程序入口地址。当以后进程在利用该逻辑设备名请求I/O操作时，系统通过查找LUT，便可以找到该逻辑设备所对应的物理设备和该设备的驱动程序。
    </p>
    <p>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e8ce16e6543ba894f562690834aa7bd2.png"/>
    </p>
    <h5>
     <a id="2_74">
     </a>
     2.逻辑设备表的设置问题
    </h5>
    <p>
     在系统中可采取两种方式设置逻辑设备表：
     <br/>
     <br/>
     第一种方式，是在整个系统中只设置一张LUT。
     <br/>
     第二种方式，是为每个用户设置一张LUT。
    </p>
    <h4>
     <a id="_79">
     </a>
     六.系统调用和函数库
    </h4>
    <h5>
     <a id="1__80">
     </a>
     1. 系统调用
    </h5>
    <p>
     一方面，为使诸进程能有条不紊地使用I/O设备，且能保护设备的安全性，不允许运行在用户态的应用进程去直接调用运行在核心态(系统态)的OS过程。但另一方面，应用进程在运行时，又必须取得OS所提供的服务，否则，应用程序几乎无法运行。为了解决此矛盾，OS在用户层中引入了一个中介过程——系统调用，应用程序可以通过它间接调用OS中的I/O过程，对I/O设备进行操作。
    </p>
    <h5>
     <a id="2__84">
     </a>
     2. 库函数
    </h5>
    <p>
     在C语言以及UNIX系统中，系统调用(如read)与各系统调用所使用的库函数(如read)之间几乎是一一对应的。而微软定义了一套过程，称为Win32 API的应用程序接口(Application Program Interface)，程序员利用它们取得OS服务，该接口与实际的系统调用并不一一对应。用户程序通过调用对应的库函数使用系统调用，这些库函数与调用程序连接在一起，被嵌入在运行时装入内存的二进制程序中。
    </p>
    <h4>
     <a id="_86">
     </a>
     七.假脱机系统
    </h4>
    <h5>
     <a id="1_SPOOLing_87">
     </a>
     1. 什么是SPOOLing技术（假脱机技术）
    </h5>
    <ul>
     <li>
      定义：在联机的情况下实现的同时外围操作
     </li>
     <li>
      特点：是对脱机输入输出系统的模拟。因此， 必须建立在具有多道程序功能的操作系统上，而且需要高速外存的支持。
     </li>
     <li>
      方式：将数据从输入设备传送到磁盘或反之。
     </li>
     <li>
      通过它可以将一台独占的物理设备虚拟为多台逻辑设备，从而允许多个用户（进程）共享。
     </li>
    </ul>
    <h5>
     <a id="2SPOOLing_93">
     </a>
     2.SPOOLing系统的组成
    </h5>
    <ul>
     <li>
      输入井和输出井：在磁盘上开辟的两个大存储空间
     </li>
     <li>
      输入缓冲区和输出缓冲区：在内存中开辟的两个缓冲区
     </li>
     <li>
      输入进程Spi和输出进程Spo:是内存中的两个进程
     </li>
     <li>
      井管理程序:控制作业与磁盘井之间信息的交换
      <br/>
      <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fa13e57e1faee7b4015ad36617dcab7c.png"/>
     </li>
    </ul>
    <h5>
     <a id="3_100">
     </a>
     3.假脱机打印机系统
    </h5>
    <p>
     SPOOLing系统接收到用户进程的打印输出请求后：
    </p>
    <ul>
     <li>
      由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中；
     </li>
     <li>
      输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。
     </li>
    </ul>
    <p>
     当打印机空闲时，输出进程将从请求打印队列的队首取出一张请求打印表，再从输出井把数据送到内存缓冲区，启动打印机打印输出。打印完后，输出进程检查请求打印队列……
    </p>
    <h5>
     <a id="4SPOOLing_108">
     </a>
     4.SPOOLing系统的特点
    </h5>
    <ul>
     <li>
      提高了I/O的速度，缓和了CPU与低速I/O设备速度不匹配的矛盾
     </li>
     <li>
      利用高速共享设备，将独占设备改造为共享设备
     </li>
     <li>
      实现了虚拟设备功能：用户都感到独占了一台设备
     </li>
    </ul>
    <h5>
     <a id="5deamon_113">
     </a>
     5.守护进程（deamon）
    </h5>
    <ul>
     <li>
      守护进程取代假脱机管理进程。执行以下功能：
      <br/>
      为用户申请磁盘缓冲区的空闲盘块、写入打印数据、返回该盘块的首址。
     </li>
     <li>
      守护进程是允许使用打印机的唯一进程。打印进程要将要求打印的文件放在假脱机文件队列中。并唤醒守护进程。
     </li>
     <li>
      守护进程的任务是按照队列中每个文件的说明执行逐个打印任务，直至全部完成，然后休眠。
     </li>
     <li>
      总之，凡是需要将独占设备改造为共享设备时，都要为该设备配置守护进程和假脱机文件队列。
     </li>
    </ul>
    <h4>
     <a id="_120">
     </a>
     八.参考资料
    </h4>
    <p>
     《操作系统第四版》
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3338343939383539:2f61727469636c652f64657461696c732f3831313732323230" class_="artid" style="display:none">
 </p>
</div>


