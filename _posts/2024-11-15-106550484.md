---
layout: post
title: "Java队列介绍用队列实现栈"
date: 2024-11-15 10:49:54 +0800
description: "本文将介绍队列的概念以及Java中队列Queue的继承关系。第二部分将用队列实现栈。_java用于支"
keywords: "java用于支付采用列队"
categories: ['算法']
tags: ['队列实现栈', '队列', '数据结构', 'Queue', 'Java']
artid: "106550484"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=106550484
    alt: "Java队列介绍用队列实现栈"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java队列介绍&amp;用队列实现栈
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     队列
    </h2>
    <hr/>
    <h4>
     <a id="_3">
     </a>
     队列简介
    </h4>
    <p>
     队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列是我们日常生活中的常见场景，例如需要排队的地方（购票），最先进入队列的人，最先买到票，退出队列，这就是一个标准的队列。
    </p>
    <p>
     队列在Java中的抽象接口是Queue，它是Java集合的一个重要组成部分。Queue用于模拟队列数据结构，采用“先进先出”的方式。
    </p>
    <p>
     Queue在Java中只是一个接口，它的父接口是Collection接口，它的继承接口是Deque（双端队列），LinkedList和ArrayQueue都实现了Deque接口。
    </p>
    <h4>
     <a id="Queue_11">
     </a>
     Queue需要实现的方法
    </h4>
    <h5>
     <a id="add_13">
     </a>
     添加元素：add
    </h5>
    <p>
     将一个非空非null元素插入到该队列，如果插入成功返回true,不成功抛出异常。
    </p>
    <pre><code>boolean add(E e);
</code></pre>
    <h5>
     <a id="2_offer_20">
     </a>
     2. 添加元素：offer
    </h5>
    <p>
     将一个非空非null元素插入到该队列，如果插入成功返回true,不成功返回false。
    </p>
    <pre><code>boolean offer(E e);
</code></pre>
    <h5>
     <a id="3_remove_28">
     </a>
     3. 删除元素：remove()
    </h5>
    <p>
     删除当前队列的头部元素，并返回头部元素，如果为空，抛出异常。
    </p>
    <pre><code>E remove();
</code></pre>
    <h5>
     <a id="4_poll_36">
     </a>
     4. 删除元素：poll()
    </h5>
    <p>
     删除当前队列的头部元素，并返回头部元素,如果为空，返回null。
    </p>
    <pre><code>E poll();
</code></pre>
    <h5>
     <a id="5_element_44">
     </a>
     5. 获取队头元素：element()
    </h5>
    <p>
     获取当前队列的头部元素，如果为空，抛出异常。
    </p>
    <pre><code>E element();
</code></pre>
    <h5>
     <a id="6peek_52">
     </a>
     6.获取队头元素：peek()
    </h5>
    <p>
     获取当前队列的头部元素，如果为空，则返回null。
    </p>
    <pre><code>E peek();
</code></pre>
    <h2>
     <a id="_60">
     </a>
     用队列实现栈
    </h2>
    <hr/>
    <h4>
     <a id="_63">
     </a>
     题目描述
    </h4>
    <p>
     力扣 225. 用队列实现栈
    </p>
    <p>
     使用队列实现栈的下列操作：
    </p>
    <p>
     push(x) – 元素 x 入栈
     <br/>
     pop() – 移除栈顶元素
     <br/>
     top() – 获取栈顶元素
     <br/>
     empty() – 返回栈是否为空
    </p>
    <h4>
     <a id="_74">
     </a>
     分析
    </h4>
    <p>
     队列在Java中，我们可以使用LinkedList，它实现了Queue接口。
    </p>
    <p>
     我们来看”栈“是什么？
    </p>
    <p>
     栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。
    </p>
    <p>
     也即是说，我们要用一个”先进先出“的队列，转变成一个可以实现”后进先出“的队列。
    </p>
    <p>
     思路：我们需要在入栈时，将该元素变为下一个将要出队的元素，这样可以将队列中已存在的元素重新入队，则当前元素就变为了”最早“入队的元素了，也就是”栈顶“元素了。
    </p>
    <h4>
     <a id="_86">
     </a>
     实现
    </h4>
    <pre><code>
class MyStack {
    private Queue&lt;Integer&gt; queue;
    /** Initialize your data structure here. */
    public MyStack() {
        queue = new LinkedList&lt;&gt;();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue.add(x);
        int size = queue.size();
        while(size-- &gt; 1){
            queue.add(queue.poll());
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return queue.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue.size() == 0;
    }
}


</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031313537383733342f:61727469636c652f64657461696c732f313036353530343834" class_="artid" style="display:none">
 </p>
</div>


