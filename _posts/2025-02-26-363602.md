---
layout: post
title: "微软编程技术误区"
date: 2025-02-26 19:16:35 +0800
description: "    有关微软编程技术的书籍可谓多如牛毛，但读来读去感觉还是MSDN比较权威。这里就拿一个例子来说"
keywords: "微软编程帮助文档不好理解"
categories: ['Msdn开发精选编辑随笔']
tags: ['编程', '微软', 'Windows', 'Library', 'Function', 'Api']
artid: "363602"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=363602
    alt: "微软编程技术误区"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微软编程技术误区
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     有关微软编程技术的书籍可谓多如牛毛，但读来读去感觉还是MSDN比较权威。这里就拿一个例子来说吧，可能让很多刚开始学习Win32 API程序设计、甚至是一些已经有一定Win32 API经验的人感觉大汗淋漓。
    </p>
    <p>
     在学习Win32 API程序设计时，“第一课”我想都会学到“事件循环”吧？很多书给出了类似这样的经典示例：
    </p>
    <p class="code_p">
     int WINAPI _tWinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPCTSTR lpCmdLine, int nCmdShow)
     <br/>
     {
     <!-- -->
     <br/>
     MSG msg;
     <br/>
     ...
     <br/>
     while(GetMessage(&amp;msg, NULL, 0, 0))
     <br/>
     {
     <!-- -->
     <br/>
     TranslateMessage(&amp;msg);
     <br/>
     DispatchMessage(&amp;msg);
     <br/>
     }
     <br/>
     ...
     <br/>
     return (int)msg.wParam;
     <br/>
     }
    </p>
    <p>
     没错吧？多么熟悉的事件循环，它可以很好地工作，当收到一个
     <span class="code_a">
      WM_QUIT
     </span>
     事件的时候，
     <span class="code_a">
      GetMessage()
     </span>
     返回0，我们的程序得以正常退出。因此，几乎任何一本讲述Win32 API程序设计的书籍或文章，不论国内的还是国外的，都会以这样一个程序作为第一章中的示例。
    </p>
    <p>
     然而，就在前不久，和往常一样，闲来无事就翻起MSDN来，不知怎么的，就跑来看这个再熟悉不过的
     <span class="code_a">
      GetMessage()
     </span>
     函数的参考来了。这一看不要紧，头顶顿时冒出虚汗——原来这么多年我们这么写程序，不能说是错误的，但绝对是有漏洞！来看MSDN上对于
     <span class="code_a">
      GetMessage()
     </span>
     函数的讲解（节选）：
    </p>
    <p class="indent">
     <b>
      注意
     </b>
     ：下面一段文字节选自MSDN Library Online，原文参见：
     <br/>
     <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/messagesandmessagequeues/messagesandmessagequeuesreference/messagesandmessagequeuesfunctions/getmessage.asp" rel="nofollow">
      http://msdn.microsoft.com/
      <br/>
      library/
      <br/>
      en-us/
      <br/>
      winui/
      <br/>
      winui/
      <br/>
      windowsuserinterface/
      <br/>
      windowing/
      <br/>
      messagesandmessagequeues/
      <br/>
      messagesandmessagequeuesreference/
      <br/>
      messagesandmessagequeuesfunctions/
      <br/>
      getmessage.asp
     </a>
    </p>
    <p class="indent">
     <b>
      &gt;Return Value
     </b>
     <br/>
     <br/>
     &gt;If the function retrieves a message other than
     <span class="code_a">
      WM_QUIT
     </span>
     , the return value is nonzero.
     <br/>
     <br/>
     &gt;If the function retrieves the
     <span class="code_a">
      WM_QUIT
     </span>
     message, the return value is zero.
     <br/>
     <br/>
     &gt;If there is an error, the return value is -1. For example, the function fails if
     <span class="code_a">
      hWnd
     </span>
     is an invalid window handle or
     <span class="code_a">
      lpMsg
     </span>
     is an invalid pointer. To get extended error information, call
     <span class="code_a">
      GetLastError
     </span>
     .
     <br/>
     <br/>
     <b>
      &gt;Warning
     </b>
     <br/>
     &gt;Because the return value can be nonzero, zero, or -1, avoid code like this:
     <br/>
     <br/>
     <span class="code_a">
      while (GetMessage( lpMsg, hWnd, 0, 0)) ...
      <br/>
      <br/>
      &gt;
     </span>
     The possibility of a -1 return value means that such code can lead to fatal application errors. Instead, use code like this:
     <br/>
     <br/>
     <span class="code_a">
      BOOL bRet;
      <br/>
      <br/>
      while( (bRet = GetMessage( &amp;msg, NULL, 0, 0 )) != 0)
      <br/>
      {
      <br/>
      if (bRet == -1)
      <br/>
      {
      <!-- -->
      <br/>
      // handle the error and possibly exit
      <br/>
      }
      <br/>
      else
      <br/>
      {
      <!-- -->
      <br/>
      TranslateMessage(&amp;msg);
      <br/>
      DispatchMessage(&amp;msg);
      <br/>
      }
      <br/>
      }
     </span>
    </p>
    <p>
     草译如下，希望更多的朋友能够看清：
    </p>
    <p class="indent">
     <b>
      返回值
     </b>
     <br/>
     <br/>
     如果该函数收到一个除
     <span class="code_a">
      WM_QUIT
     </span>
     之外的事件，其返回值为一个非零值。
     <br/>
     <br/>
     如果该函数收到一个
     <span class="code_a">
      WM_QUIT
     </span>
     事件，其返回值为零。
     <br/>
     <br/>
     如果该函数发生错误，其返回值为-1。例如，如果
     <span class="code_a">
      hWnd
     </span>
     是一个无效的窗口句柄，或者
     <span class="code_a">
      lpMsg
     </span>
     是一个无效指针，该函数就会失败。要获得额外的错误信息，请调用
     <span class="code_a">
      GetLastError
     </span>
     。
     <br/>
     <br/>
     <b>
      警告
     </b>
     <br/>
     <br/>
     由于该函数的返回值可能是非零的、零或者-1，请避免这样做：
     <br/>
     <br/>
     <span class="code_a">
      while (GetMessage( lpMsg, hWnd, 0, 0)) ...
     </span>
     <br/>
     <br/>
     返回值-1出现的可能性意味着这样的代码会导致应用程序的致命错误。因此，我们应该编写这样的代码：
     <br/>
     <br/>
     <span class="code_a">
      BOOL bRet;
      <br/>
      <br/>
      while( (bRet = GetMessage( &amp;msg, NULL, 0, 0 )) != 0)
      <br/>
      {
      <br/>
      if (bRet == -1)
      <br/>
      {
      <!-- -->
      <br/>
      // handle the error and possibly exit
      <br/>
      }
      <br/>
      else
      <br/>
      {
      <!-- -->
      <br/>
      TranslateMessage(&amp;msg);
      <br/>
      DispatchMessage(&amp;msg);
      <br/>
      }
      <br/>
      }
     </span>
    </p>
    <p>
     看到了吗？我们这么长时间以来一直书写的代码，却在这个“警告”中被“明令禁止”了！可能有的朋友会想，这样的调用不可能出错啊，我们通常都在启动事件循环之前成功地创建了窗口，并且检查了是否成功，因此传递给
     <span class="code_a">
      GetMessage()
     </span>
     函数的窗口句柄肯定是有效的；而且，我们通常在堆栈上分配
     <span class="code_a">
      msg
     </span>
     ，并通过求址运算符（&amp;）来计算它的地址并传递给
     <span class="code_a">
      GetMessage()
     </span>
     函数，也不大可能出现无效指针啊？但是，还记得程序设计的基本原理之一吗——
     <b>
      永远不要假设任何事情！
     </b>
     因此，看来我们该把过去写的代码拿出来好好审视一遍了。
    </p>
    <p>
     这里仅提到了一个这样被我们忽视的技术细节，我想一定还有很多、更多这样的被忽视的东西存在！
     <b>
      希望本文抛砖引玉，大家把你们发现的类似东西分享出来
     </b>
     ，让大家都能够写出更加安全健壮的程序吧！
    </p>
    <p class="indent">
     P.S. 小感受一则，希望不要挨板砖……
     <br/>
     很多人都骂Windows是如何如何不安全，“缓冲区溢出”甚至变成连小学生都能随口说出的“名词”。其实，很多的Windows API都尽量保证了其执行的成功，并且以各种形式反馈给程序员，同时也在文档中进行了详细的描述。然而，又有多少人真正好好阅读了这些讲解？有多少技术作者、技术作家在下笔之前认真浏览了MSDN Library？
     <br/>
     Windows是安全的，不安全的是我们想当然的作风！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f646f746e65745f65646974:6f722f61727469636c652f64657461696c732f333633363032" class_="artid" style="display:none">
 </p>
</div>


