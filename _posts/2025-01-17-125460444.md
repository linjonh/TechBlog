---
layout: post
title: "数据结构与算法栈和队列"
date: 2025-01-17 21:13:43 +0800
description: "文章浏览阅读2w次，点赞142次，本文详细介绍了数据结构中的栈和队列，包括它们的定义、存储结构（顺序"
keywords: "栈和队列"
categories: ['数据结构与算法']
tags: ['链表', '算法', '数据结构', 'C']
artid: "125460444"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=125460444
    alt: "数据结构与算法栈和队列"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构与算法——栈和队列
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      😊数据结构与算法——栈和队列
     </h4>
     <ul>
      <li>
       <ul>
        <li>
         <a href="#_2" rel="nofollow">
          🚀前言
         </a>
        </li>
        <li>
         <a href="#satck_14" rel="nofollow">
          🚀栈（satck）
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_18" rel="nofollow">
            🚢栈的定义
           </a>
          </li>
          <li>
           <a href="#_30" rel="nofollow">
            🚢共享栈（节省空间）
           </a>
          </li>
          <li>
           <a href="#_53" rel="nofollow">
            🚢栈的表示和实现（顺序栈）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_60" rel="nofollow">
              👻顺序栈的定义
             </a>
            </li>
            <li>
             <a href="#_78" rel="nofollow">
              👻初始化操作
             </a>
            </li>
            <li>
             <a href="#_147" rel="nofollow">
              👻进栈操作
             </a>
            </li>
            <li>
             <a href="#_171" rel="nofollow">
              👻出栈操作
             </a>
            </li>
            <li>
             <a href="#_194" rel="nofollow">
              👻读取栈顶元素
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#_217" rel="nofollow">
            🚢栈的表示和实现（链栈）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_222" rel="nofollow">
              👻链栈的定义
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#queue_239" rel="nofollow">
          🚀队列（queue）
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_243" rel="nofollow">
            🚢队列的定义
           </a>
          </li>
          <li>
           <a href="#_272" rel="nofollow">
            🚢队列的顺序表示和实现（顺序队列）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_292" rel="nofollow">
              👻初始化操作
             </a>
            </li>
            <li>
             <a href="#_328" rel="nofollow">
              👻入队操作
             </a>
            </li>
            <li>
             <a href="#_350" rel="nofollow">
              👻出队操作
             </a>
            </li>
            <li>
             <a href="#_372" rel="nofollow">
              👻获取队头元素操作
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#_395" rel="nofollow">
            🚢队列的链式表示和实现（链队列）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_409" rel="nofollow">
              👻初始化操作
             </a>
            </li>
            <li>
             <a href="#_481" rel="nofollow">
              👻入队操作
             </a>
            </li>
            <li>
             <a href="#_533" rel="nofollow">
              👻出队操作
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#_594" rel="nofollow">
            🚢双端队列
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_612" rel="nofollow">
          💻总结
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h3>
     <a id="_2">
     </a>
     🚀前言
    </h3>
    <p>
     <strong>
      栈和队列是两种重要的线性结构
     </strong>
     。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/89a8d52df59d31cf85c77464b2c71de3.png#pic_center"/>
    </p>
    <p>
     但是从数据类型角度看，栈和队列是和线性表大不相同的两种重要的抽象数据类型。栈和队列的运用比较广泛，属于多型数据类型。
    </p>
    <br/>
    <hr/>
    <h3>
     <a id="satck_14">
     </a>
     🚀栈（satck）
    </h3>
    <br/>
    <h4>
     <a id="_18">
     </a>
     🚢栈的定义
    </h4>
    <p>
     <strong>
      栈
     </strong>
     (
     <strong>
      stack
     </strong>
     )
     <strong>
      是限定仅在表尾进行插入或删除操作的线性表
     </strong>
     。因此，对于栈来说，表尾端有其特殊的含义，称为
     <code>
      栈顶(top)
     </code>
     ，相应地，表头端称为
     <code>
      栈底(bottom)
     </code>
     。不包含元素的空表称为
     <strong>
      空栈
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4f66588ca520bb86a1c0c7791f167a2f.png#pic_center">
      <br/>
      <br/>
     </img>
    </p>
    <p>
     假设
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        S 
        
       
         = 
        
       
         ( 
        
       
         a 
        
       
         1 
        
       
         , 
        
       
         a 
        
       
         2 
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         a 
        
       
         n 
        
       
         ) 
        
       
      
        S=(a1, a2,....an)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.05764em;">
          S
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          2
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     ，则称
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         1 
        
       
      
        a1
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
        </span>
       </span>
      </span>
     </span>
     为栈底元素，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         n 
        
       
      
        an
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     为栈顶元素。栈中元素按
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         1 
        
       
         , 
        
       
         a 
        
       
         2 
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         a 
        
       
         n 
        
       
      
        a1,a2,...an
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          2
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     的次序进栈，那么出栈的第一个元素应为
     <strong>
      栈顶元素
     </strong>
     。
    </p>
    <p>
     栈的修改是按照后进先出的原则进行的，因此，栈又称为
     <strong>
      后进先出
     </strong>
     (last in first out)的线性表（简称
     <code>
      LIFO
     </code>
     ）结构
    </p>
    <br/>
    <h4>
     <a id="_30">
     </a>
     🚢共享栈（节省空间）
    </h4>
    <p>
     <strong>
      两个栈共享一个存储空间，意义在于高效利用存储空间
     </strong>
    </p>
    <p>
     📌第二种说法：两个栈底分别设置在一个空间的两端，栈顶向中间延伸
    </p>
    <br/>
    <p>
     <strong>
      共享栈的定义
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Linknode</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">;</span>      <span class="token comment">//数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">Linknode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>      <span class="token comment">//指针域</span>
<span class="token punctuation">}</span>LiStack<span class="token punctuation">;</span>                   <span class="token comment">//栈类型定义</span>

</code></pre>
    <blockquote>
     <p>
      <strong>
       📌共享栈的栈满情况：当两个栈的top在空间中某一位置相遇时
      </strong>
     </p>
    </blockquote>
    <br/>
    <h4>
     <a id="_53">
     </a>
     🚢栈的表示和实现（顺序栈）
    </h4>
    <p>
     和线性表类似，栈也有
     <strong>
      两种存储表示方法——顺序栈和链栈
     </strong>
    </p>
    <p>
     <strong>
      顺序栈
     </strong>
     ，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附加指针top表示栈顶元素在顺序栈中的位置。
     <code>
      通常当top=-1时，表示此栈为空栈。
     </code>
    </p>
    <br/>
    <h5>
     <a id="_60">
     </a>
     👻顺序栈的定义
    </h5>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//静态数组存放栈中元素 </span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                   <span class="token comment">//栈顶指针</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    SqStack S<span class="token punctuation">;</span>      <span class="token comment">//声明一个顺序栈(分配空间)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//后续操作</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     由于栈在使用过程中所需要最大空间的大小很难估计，所以，一般来说，在初始化设空栈时不应限定栈的最大容量，
     <code>
      常规做法是：先为栈分配一个基本容量，然后在应用过程中，当栈的空间不够使用时再逐步扩大容量
     </code>
    </p>
    <br/>
    <h5>
     <a id="_78">
     </a>
     👻初始化操作
    </h5>
    <p>
     <strong>
      构造一个空栈，分配内存空间
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//静态数组存放栈中元素 </span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                   <span class="token comment">//栈顶指针</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    S<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">//初始化栈顶指针</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    SqStack S<span class="token punctuation">;</span>      <span class="token comment">//声明一个顺序栈(分配空间)</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//后续操作</span>
<span class="token punctuation">}</span>


<span class="token comment">//栈的判空操作</span>
bool <span class="token function">StackEmpty</span><span class="token punctuation">(</span>SqStack S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token comment">//栈空</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>       <span class="token comment">//不为空</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <p>
     <strong>
      第二种定义
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ac080ccd7124609b3f09ec177966b969.png#pic_center"/>
    </p>
    <p>
     按设定的初始分配量进行第一次存储分配，base可称为是栈底指针，在顺序占中，它始终指向栈底的位置，
     <strong>
      若base的值为NULL
     </strong>
     ，则表明栈结构不存在，top表示栈顶指针，其初始值指向栈底，即
     <strong>
      top==base
     </strong>
     ，
     <strong>
      空栈可以表示为top==base
     </strong>
     。每当插入新的栈顶元素时，指针top增加1，删除栈顶元素时，指针top减1，因此，非空栈中的栈顶指针始终在栈顶元素的下一个位置上
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STACK_INIT_SIZE</span> <span class="token expression"><span class="token number">100</span><span class="token punctuation">;</span>        </span><span class="token comment">//存储空间初始分配量</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STACKINCREMENT</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span>          </span><span class="token comment">//存储空间分配增量</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    SElemType <span class="token operator">*</span>base<span class="token punctuation">;</span>        <span class="token comment">//栈底指针</span>
    SElemType <span class="token operator">*</span>top<span class="token punctuation">;</span>         <span class="token comment">//栈顶指针</span>
    <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>          <span class="token comment">//当前已分配的空间</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//构造一个空栈</span>
    S<span class="token punctuation">.</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>SElemType <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>STACK_INIT_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span>base<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//存储分配失败</span>
    S<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>base<span class="token punctuation">;</span>
    S<span class="token punctuation">.</span>stacksize <span class="token operator">=</span> STACK_INIT_SIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    SqStack S<span class="token punctuation">;</span>          <span class="token comment">//声明一个顺序栈</span>
    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//后续操作</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_147">
     </a>
     👻进栈操作
    </h5>
    <p>
     <strong>
      若栈未满，则将x加入使之成为新栈顶
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span>     </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//静态数组存放栈中元素</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                    <span class="token comment">//栈顶指针</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>


<span class="token comment">//新元素入栈</span>
bool <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> MaxSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//表示栈满了</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    S<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>top <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">//指针先加一</span>
    S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>S<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>          <span class="token comment">//新元素入栈</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_171">
     </a>
     👻出栈操作
    </h5>
    <p>
     <strong>
      若栈非空，则释放栈顶元素，并返回。
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span>     </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//静态数组存放栈中元素</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                    <span class="token comment">//栈顶指针</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>


<span class="token comment">//出栈操作</span>
bool <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//栈空，报错</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    x <span class="token operator">=</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>S<span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//栈顶元素先出栈</span>
    S<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">//指针再减1</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_194">
     </a>
     👻读取栈顶元素
    </h5>
    <p>
     <strong>
      若栈非空，则用x返回栈顶元素
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span>     </span><span class="token comment">//定义栈中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//静态数组存放栈中元素</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                    <span class="token comment">//栈顶指针</span>
<span class="token punctuation">}</span>SqStack<span class="token punctuation">;</span>


<span class="token comment">//读取栈顶元素</span>
bool <span class="token function">GetTop</span><span class="token punctuation">(</span>SqStack <span class="token operator">&amp;</span>S<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//栈空，报错</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    x <span class="token operator">=</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>S<span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//记录栈顶元素</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h4>
     <a id="_217">
     </a>
     🚢栈的表示和实现（链栈）
    </h4>
    <p>
     对于链栈的基本操作来说，
     <strong>
      和单链表的插入删除很类似
     </strong>
     ，所以就不在赘述，
     <code>
      链栈的入栈和出栈操作，其实就对应单链表的插入和删除操作
     </code>
    </p>
    <br/>
    <h5>
     <a id="_222">
     </a>
     👻链栈的定义
    </h5>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Linknode</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">;</span>      <span class="token comment">//数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">Linknode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>      <span class="token comment">//指针域</span>
<span class="token punctuation">}</span>LiStack<span class="token punctuation">;</span>                   <span class="token comment">//栈类型定义</span>
</code></pre>
    <blockquote>
     <p>
      <strong>
       栈的非法操作
      </strong>
      <br/>
      📌上溢：当栈满了的情况下再次放入元素会造成此情况
      <br/>
      📌下溢：当栈空了的情况下再次删除元素会造成此情况
     </p>
    </blockquote>
    <br/>
    <hr/>
    <h3>
     <a id="queue_239">
     </a>
     🚀队列（queue）
    </h3>
    <br/>
    <h4>
     <a id="_243">
     </a>
     🚢队列的定义
    </h4>
    <br/>
    <p>
     和栈相反，
     <strong>
      队列
     </strong>
     (
     <strong>
      queue
     </strong>
     )
     <strong>
      是一种先进先出
     </strong>
     (
     <code>
      first in first out
     </code>
     )
     <strong>
      的线性表
     </strong>
     （
     <code>
      缩写为FIFO
     </code>
     ）。它只允许在表的一端进行插入，在另一端进行删除元素。
     <code>
      这种数据结构概括起来就和我们平时排队是一样的道理，最早进入到的队列的元素最先离开。
     </code>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bf4cc4d019784cd8da6374caee878147.png#pic_center"/>
    </p>
    <br/>
    <p>
     在队列中，只允许插入的一端叫做
     <code>
      队尾(rear)
     </code>
     ，允许删除的一端则称为
     <code>
      队头(front)
     </code>
     。假设队列为
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        q 
        
       
         = 
        
       
         ( 
        
       
         a 
        
       
         1 
        
       
         , 
        
       
         a 
        
       
         2 
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         a 
        
       
         n 
        
       
         ) 
        
       
         ， 
        
       
      
        q=(a1,a2,...an)，
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.625em; vertical-align: -0.19444em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.03588em;">
          q
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          2
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mord cjk_fallback">
          ，
         </span>
        </span>
       </span>
      </span>
     </span>
     那么，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         1 
        
       
      
        a1
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
        </span>
       </span>
      </span>
     </span>
     就是队头元素，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         n 
        
       
      
        an
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     就是队尾元素。队列中的元素是按照
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         1 
        
       
         , 
        
       
         a 
        
       
         2 
        
       
         , 
        
       
         a 
        
       
         3.... 
        
       
         a 
        
       
         n 
        
       
      
        a1,a2,a3....an
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          2
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          3
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         1 
        
       
         , 
        
       
         a 
        
       
         2 
        
       
         , 
        
       
         a 
        
       
         3... 
        
       
         a 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
      
        a1,a2,a3...an-1
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          1
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          2
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord">
          3
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord">
          .
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          −
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
         </span>
         <span class="mord">
          1
         </span>
        </span>
       </span>
      </span>
     </span>
     都离开队列之后，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        a 
        
       
         n 
        
       
      
        an
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     才能退出队列
    </p>
    <br/>
    <ul>
     <li>
      📌
      <strong>
       队首队尾指针的两种指法
      </strong>
      <ul>
       <li>
        <p>
         ⭐队首指针（front）指向：队头元素的前一个存储位置
        </p>
       </li>
       <li>
        <p>
         ⭐队尾指针（rear）指向：队尾元素
        </p>
       </li>
       <li>
        <p>
         ⚡队首指针（front）指向：队头元素
        </p>
       </li>
       <li>
        <p>
         ⚡队尾指针（rear）指向：队尾元素的下一个存储位置
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      <strong>
       📌假溢出：队中有空间，元素无法入队
      </strong>
     </p>
    </blockquote>
    <br/>
    <h4>
     <a id="_272">
     </a>
     🚢队列的顺序表示和实现（顺序队列）
    </h4>
    <br/>
    <p>
     和顺序栈类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放队列头到队列尾的元素之外，还需要附设两个指针
     <code>
      front
     </code>
     和
     <code>
      rear
     </code>
     分别指示队列头元素以及队列尾元素的位置。
     <strong>
      基本操作基于循环队列，循环队列的引出是为了解决假溢出的问题。
     </strong>
    </p>
    <br/>
    <ul>
     <li>
      <strong>
       📌循环队列的性质
      </strong>
      <ul>
       <li>
        ⛅数组实现
        <ul>
         <li>
          空队列：front == rear
         </li>
         <li>
          满队列：牺牲一个单元判满（不牺牲的话队空队满无法区分）
         </li>
         <li>
          （rear+1）% maxSize == front
         </li>
         <li>
          进队：rear新 = （rear旧+1）% maxSize
         </li>
         <li>
          出队：front新 = （front旧+1）% maxSize
         </li>
         <li>
          队中元素个数/长度：(rear - front + maxSize) % maxSize
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <br/>
    <h5>
     <a id="_292">
     </a>
     👻初始化操作
    </h5>
    <p>
     <strong>
      初始化队列，构造一个空队列
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义队列中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//用静态数组存放队列元素</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>            <span class="token comment">//队头指针和队尾指针</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>

<span class="token comment">//初始化队列</span>
<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//初始化 队头、队尾指针指向0</span>
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//声明一个队列（顺序存储）</span>
    SqQueue Q<span class="token punctuation">;</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//后续操作</span>
<span class="token punctuation">}</span>


<span class="token comment">//判断队列是否为空</span>
bool <span class="token function">QueueEmpty</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//队空条件</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_328">
     </a>
     👻入队操作
    </h5>
    <p>
     <strong>
      若队列未满，将x加入，使之称为新的队尾
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义队列中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//用静态数组存放队列元素</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>            <span class="token comment">//队头指针和队尾指针</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>

<span class="token comment">//入队</span>
bool <span class="token function">EnQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>       <span class="token comment">//判断队列是否已满</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>       <span class="token comment">//对满则报错</span>
    <span class="token punctuation">}</span>
    Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment">//将x插入队尾</span>
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MaxSize<span class="token punctuation">;</span>    <span class="token comment">//队尾指针后移</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_350">
     </a>
     👻出队操作
    </h5>
    <p>
     <strong>
      若队列非空，删除队头元素并返回x
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义队列中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//用静态数组存放队列元素</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>            <span class="token comment">//队头指针和队尾指针</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>

<span class="token comment">//出队(删除一个队头元素，并返回x)</span>
bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>SqQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>      <span class="token comment">//判断队空</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>           <span class="token comment">//队空则报错</span>
    <span class="token punctuation">}</span>
    x <span class="token operator">=</span> Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>MaxSize<span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_372">
     </a>
     👻获取队头元素操作
    </h5>
    <p>
     <strong>
      读队头元素，若队列非空，则将队头元素赋值给x
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">10</span>         </span><span class="token comment">//定义队列中元素的最大个数</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//用静态数组存放队列元素</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>            <span class="token comment">//队头指针和队尾指针</span>
<span class="token punctuation">}</span>SqQueue<span class="token punctuation">;</span>

<span class="token comment">//获得队头元素的值，用x返回</span>
bool <span class="token function">GetHead</span><span class="token punctuation">(</span>SqQueue Q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>       <span class="token comment">//队空报错</span>
    <span class="token punctuation">}</span>
    x <span class="token operator">=</span> Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <br/>
    <h4>
     <a id="_395">
     </a>
     🚢队列的链式表示和实现（链队列）
    </h4>
    <br/>
    <p>
     和线性表类似，队列也可以有两种存储表示
    </p>
    <p>
     <strong>
      用链表表示的队列简称为链队列，一个链队列显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。
     </strong>
    </p>
    <p>
     链队列的操作即为单链表的插入和删除操作的特殊情况，只是需要修改尾指针或头指针
    </p>
    <p>
     一般情况下，删除队列头元素时仅需修改头结点中的指针，但当队列中最后一个元素被删除后，队列表尾指针也丢失了，因此需对队尾指针重新赋值（指向头结点）
    </p>
    <br/>
    <h5>
     <a id="_409">
     </a>
     👻初始化操作
    </h5>
    <p>
     <strong>
      初始化队列，构造一个空队列
     </strong>
    </p>
    <p>
     📌带头结点：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//链式队列结点</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//链式队列</span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear  <span class="token comment">//队列的队头和队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token comment">//初始化队列(带头结点)</span>
<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//初始化 front、rear都指向头结点</span>
    Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>front <span class="token operator">-&gt;</span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

viod <span class="token function">testLinkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LinkQueue Q<span class="token punctuation">;</span>        <span class="token comment">//声明一个队列</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//初始化队列</span>
<span class="token punctuation">}</span>

<span class="token comment">//判断队列是否为空</span>
bool <span class="token function">IsEmpty</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     📌不带头结点：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//链式队列结点</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//链式队列</span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear  <span class="token comment">//队列的队头和队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token comment">//初始化队列(不带头结点)</span>
<span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//初始化 front、rear都指向头结点</span>
    Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

viod <span class="token function">testLinkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LinkQueue Q<span class="token punctuation">;</span>        <span class="token comment">//声明一个队列</span>
    <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//初始化队列</span>
<span class="token punctuation">}</span>

<span class="token comment">//判断队列是否为空</span>
bool <span class="token function">IsEmpty</span><span class="token punctuation">(</span>LinkQueue Q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_481">
     </a>
     👻入队操作
    </h5>
    <p>
     <strong>
      若队列未满，将x加入，使之称为新的队尾
     </strong>
     <br/>
     📌带头结点：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//链式队列结点</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//链式队列</span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear  <span class="token comment">//队列的队头和队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token comment">//新元素入队(带头结点)</span>
<span class="token keyword">void</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LinkNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    Q<span class="token punctuation">.</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>       <span class="token comment">//新结点插入到rear之后</span>
    Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span>             <span class="token comment">//修改表尾指针</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     📌不带头结点：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//链式队列结点</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//链式队列</span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear  <span class="token comment">//队列的队头和队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token comment">//新元素入队(不带头结点)</span>
<span class="token keyword">void</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LinkNode <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//在空队列中插入第一个元素</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> s<span class="token punctuation">;</span>            <span class="token comment">//修改队头队尾指针</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        Q<span class="token punctuation">.</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>       <span class="token comment">//新结点插入到rear结点之后</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span>             <span class="token comment">//修改rear指针</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h5>
     <a id="_533">
     </a>
     👻出队操作
    </h5>
    <p>
     <strong>
      若队列非空，删除队头元素并返回x
     </strong>
    </p>
    <p>
     📌带头结点：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//链式队列结点</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//链式队列</span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear  <span class="token comment">//队列的队头和队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token comment">//队头元素出队操作(带头结点)</span>
bool <span class="token function">DEQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span>      <span class="token comment">//空队列</span>
    <span class="token punctuation">}</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    x <span class="token operator">=</span> p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>        <span class="token comment">//用变量x返回队头元素</span>
    Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>nexy <span class="token operator">=</span> p<span class="token operator">-&gt;</span>nexy<span class="token punctuation">;</span>        <span class="token comment">//修改头结点的next指针</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                <span class="token comment">//此次是最后一个结点出队</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> Q<span class="token punctuation">.</span>front            <span class="token comment">//修改rear指针</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//释放结点空间</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     📌不带头结点：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>        <span class="token comment">//链式队列结点</span>
    ElemType data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">//链式队列</span>
    LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear  <span class="token comment">//队列的队头和队尾指针</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token comment">//队头元素出队操作(不带头结点)</span>
bool <span class="token function">DEQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span>      <span class="token comment">//空队列</span>
    <span class="token punctuation">}</span>
    LinkNode <span class="token operator">*</span>p <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span>      <span class="token comment">//p指向此次出队的结点</span>
    x<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>                  <span class="token comment">//用变量x返回队头结点元素</span>
    Q<span class="token punctuation">.</span>front <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>          <span class="token comment">//修改front指针</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>            <span class="token comment">//此次是最后一个结点出队</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>         <span class="token comment">//front指向NULL</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>          <span class="token comment">//rear 指向NULL</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//释放结点空间</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <h4>
     <a id="_594">
     </a>
     🚢双端队列
    </h4>
    <p>
     <strong>
      除了栈和队列之外，还有一种限定性数据结构——双端队列(deque)
     </strong>
    </p>
    <p>
     双端队列是限定插入和删除操作在表的两端进行的线性表。着两端分别称作
     <code>
      端点1
     </code>
     和
     <code>
      端点2
     </code>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/055f0f2330f5714c4b690a5e6ebef779.png#pic_center"/>
    </p>
    <br/>
    <p>
     在实际使用中，还可以
     <strong>
      有输出受限的双端队列
     </strong>
     （即一个端点允许插入和删除，另一个端点只允许插入的双端队列）和
     <strong>
      输入受限的双端队列
     </strong>
     （即一个端点允许插入和删除，另一个端点只允许删除的双端队列）。
     <code>
      而如果限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为了两个栈底相邻接的栈了
     </code>
    </p>
    <br/>
    <hr/>
    <h3>
     <a id="_612">
     </a>
     💻总结
    </h3>
    <p>
     本节文章到这里就结束啦，以上内容涵盖数据结构与算法中栈和队列的基本概念以及基本操作，结合代码片段分析各基本操作的具体实现，在本文中，栈的链式存储以及循环队列是理解较为不易的点，需结合具体操作认真分析，希望各位小伙伴都能有所收获，一如既往希望我的文章能给各位小伙伴们带来帮助，数据结构与算法专栏也在持续更细中！！！
     <br/>
     <br/>
    </p>
    <p align="center">
     <strong>
      🎨觉得不错的话记得点赞收藏呀！！🎨
     </strong>
    </p>
    <p align="center">
     <strong>
      😀别忘了给我关注~~😀
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35333631343336372f:61727469636c652f64657461696c732f313235343630343434" class_="artid" style="display:none">
 </p>
</div>


