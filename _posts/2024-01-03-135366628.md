---
layout: post
title: "常见的微前端解决方案对比"
date: 2024-01-03 16:12:17 +0800
description: "文章浏览阅读1.5k次，点赞11次，本文详细对比了六种微前端解决方案，包括使用Nginx路由重定向、"
keywords: "微前端框架对比"
categories: ['微前端']
tags: ['微前端方案对比']
artid: "135366628"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=135366628
    alt: "常见的微前端解决方案对比"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     常见的微前端解决方案对比
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1. 使用 HTTP 服务器（Nginx）的路由来重定向多个微应用
    </h2>
    <p>
     其实这也可以理解
     <strong>
      把一个大型项目拆分成多个微模板应用
     </strong>
     ，每个微模板应用就代表一个前端服务，然后通过 Nginx 配置代理映射到不同的子模板应用上，这也叫
     <code>
      路由分发式微前端
     </code>
     ，是一个非常古老且传统的方法；
    </p>
    <p>
     细心的同学会发现这种方式看上去更像是多个前端应用的聚合，即我们只是将这些不同的前端应用拼凑到一起，使他们看起来像是一个完整的整体。但是它们并不是，每次用户从 A 应用到 B 应用的时候，往往需要刷新一下页面。
    </p>
    <p>
     <strong>
      优点：
     </strong>
     简单、快速、易配置
    </p>
    <p>
     <strong>
      缺点：
     </strong>
     在切换应用时会触发浏览器刷新，影响体验
    </p>
    <h3>
     2. 使用 iframe 及自定义消息传递机制
    </h3>
    <p>
     iframe 作为一个非常古老的，人人都觉得很普通的技术，却一直都很管用。
    </p>
    <p>
     就其性质而言，iframe 可以轻松地从独立的子页面构建页面。它们还在样式和全局变量方面提供了很好的隔离度，不会相互干扰。
    </p>
    <p>
     <strong>
      优点:
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       实现简单：
      </strong>
      子应用之间自带沙箱，天然隔离，互不影响
     </li>
     <li>
      <strong>
       技术不限制：
      </strong>
      可以各自使用完全不同的前端框架；
     </li>
     <li>
      <strong>
       消息传递：
      </strong>
      只要每个 iframe 来自同一个来源，可以使用
      <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindow%2FpostMessage" rel="nofollow" title="Window.postMessageAPI">
       Window.postMessageAPI
      </a>
      来进行消息传递；
     </li>
    </ol>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       Bundle 的大小各异：
      </strong>
      构建时也不能提取公共依赖关系；
     </li>
     <li>
      <strong>
       无 SEO：
      </strong>
      众所周知 iframe 对 SEO 是毁灭性的打击，单这一条即可否定该方案了；
     </li>
     <li>
      <strong>
       URL 状态不同步：
      </strong>
      iframe 的页面 url 中的状态信息并不能同步到父窗口，无法使用浏览器的前进后退功能；
     </li>
     <li>
      <strong>
       DOM 结构不共享：
      </strong>
      iframe 的页面布局只针对于 iframe 窗口（例如：全局弹框无法给出合理布局）；
     </li>
     <li>
      <strong>
       全局上下文完全隔离，内存变量不共享：
      </strong>
      iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的微应用中实现免登效果；
     </li>
     <li>
      <strong>
       慢：
      </strong>
      每次微应用进入都是一次浏览器上下文重建、资源重新加载的过程；
     </li>
    </ol>
    <h3>
     3. 使用纯 Web Components 构建应用
    </h3>
    <p>
     <code>
      Web Components
     </code>
     是一个 Web 标准，所以像
     <strong>
      Angular、React/Preact、Vue 或 Hyperapp
     </strong>
     这样的主流 JavaScript 框架都支持它们；
    </p>
    <p>
     你可以将
     <code>
      Web Components
     </code>
     视为使用开放 Web 技术创建的可重用的用户界面小部件，它或许会是
     <code>
      Web 组件化
     </code>
     的未来。
    </p>
    <p>
     <strong>
      优点：
     </strong>
    </p>
    <ol>
     <li>
      拥有自己独立的
      <code>
       Scripts
      </code>
      和
      <code>
       Styles
      </code>
      ，以及对应的用于单独部署子应用组件的域名；
     </li>
     <li>
      代码的可读性变得非常清晰，组件资源内部高内聚，组件资源由自身加载控制；
     </li>
    </ol>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       浏览器和框架的支持不够：
      </strong>
      需要更多的 polyfills 从而影响到用户页面的加载体验；
     </li>
     <li>
      <strong>
       重写现有的前端应用：
      </strong>
      我们需要在整个前端应用上把它们全部转换成 Web Components；
     </li>
     <li>
      <strong>
       系统架构复杂：
      </strong>
      当应用被拆分为一个又一个的组件时，组件间的通讯就成了一个特别大的麻烦
     </li>
     <li>
      <strong>
       社区不够活跃：
      </strong>
      Web Components 还没有真正流行起来，可能很快亦有可能永远也不会；
     </li>
    </ol>
    <h3>
     4. Module Federation 模块联邦
    </h3>
    <p>
     <code>
      webpack5
     </code>
     新增的
     <code>
      Module Federation（模块联邦）
     </code>
     功能，他可以帮助将多个独立的构建组成一个应用程序，不同的构建可以独立的开发与部署，利用模块联邦我们可以在一定程度上去实现微前端。
    </p>
    <p>
     <strong>
      优点：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       开箱即用
      </strong>
      ：你只需要执行几行命令即可拉取相应的模板代码并把项目跑起来，包括基座应用和微前端应用，无需处理构建工具的复杂配置；
     </li>
     <li>
      <strong>
       独立开发与部署
      </strong>
      ：基于提供的代理工具，微应用开发者在单独开发微应用时，无需启动基座或者其它微应用；
     </li>
     <li>
      <strong>
       去中心化：
      </strong>
      因为采用的是模块共享，所以不用使用中心基座的概念；
     </li>
     <li>
      <strong>
       组件共享：
      </strong>
      与 npm 发包类似的组件共享管理；
     </li>
    </ol>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       无法沙箱隔离：
      </strong>
      需借助其它工具和框架才能做到应用层面的隔离；
     </li>
     <li>
      <strong>
       技术单一：
      </strong>
      仅限使用 webpack5 版本以上；
     </li>
     <li>
      <strong>
       代码封闭性高：
      </strong>
      依旧需要做npm那一套管理和额外的拉取代码，还不如直接 npm 复用方便；
     </li>
     <li>
      <strong>
       拆分粒度需要权衡：
      </strong>
      共享的 lib 无法做到 tree-shaking；
     </li>
     <li>
      <strong>
       依赖前置：
      </strong>
      导致时间加载变长；
     </li>
    </ol>
    <h3>
     5. 组合式应用路由分发（中心基座方案）
    </h3>
    <p>
     当下微前端主要采用的是
     <code>
      组合式应用路由方案
     </code>
     ，该方案的核心是
     <code>
      主从
     </code>
     思想，即包括一个
     <strong>
      基座（MainApp）应用
     </strong>
     和
     <strong>
      若干个微（MicroApp）应用
     </strong>
     ；
    </p>
    <p>
     基座应用大多数是一个前端SPA项目，主要负责
     <code>
      应用注册，路由映射，消息下发
     </code>
     等，而微应用是独立前端项目，这些项目不限于采用 React，Vue，Angular 或者 JQuery 开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="微前端5-1.png" height="876" src="https://i-blog.csdnimg.cn/blog_migrate/684d37cbce693c193a69dcf4bc8f87f2.png" width="1164"/>
    </p>
    <p>
     <strong>
      优点：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       技术不限制：
      </strong>
      可以各自使用完全不同的前端框架；
     </li>
     <li>
      <strong>
       无感切换：
      </strong>
      因为是一个 SPA 项目，所以体验极佳；
     </li>
     <li>
      <strong>
       利于SEO
      </strong>
     </li>
     <li>
      <strong>
       独立开发与部署
      </strong>
     </li>
     <li>
      <strong>
       微前端优势几乎都有
      </strong>
     </li>
    </ol>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       沙箱不隔离：
      </strong>
      也就是 js 与 css 样式会出现冲突的问题
     </li>
    </ol>
    <h3>
     6. 自由框架组合模式（复合型）
    </h3>
    <p>
     因为上述的几种方案都存在一定的优缺点，所以顾名思义咱们可以发挥方案的优势以及结合自己的项目来进行自定义的方案的组合模式，自定义一个更适合自己项目的微前端框架；
    </p>
    <ol>
     <li>
      就好比完美解决沙箱隔离的
      <code>
       qiankun.js
      </code>
      就是基于
      <strong>
       中心基座方案去做的一个升级；
      </strong>
     </li>
     <li>
      还有比较完美的框架如：
      <code>
       micro-app
      </code>
      、
      <code>
       EMP、wujie微前端
      </code>
      等框架都是采取了以上的一种或多种方案的组合。
     </li>
    </ol>
    <p>
    </p>
    <p>
     微前端框架对比可参考
     <a href="https://blog.csdn.net/lyn1772671980/article/details/135335430" title="微前端框架对比-CSDN博客">
      微前端框架对比-CSDN博客
     </a>
    </p>
    <p>
     本文参考
     <a href="https://juejin.cn/post/7118712142764703751" rel="nofollow" title="一个写给初学者如何搞微前端的「从入门到放弃专栏」 - 掘金">
      一个写给初学者如何搞微前端的「从入门到放弃专栏」 - 掘金
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f6c796e313737323637313938302f:61727469636c652f64657461696c732f313335333636363238" class_="artid" style="display:none">
 </p>
</div>


