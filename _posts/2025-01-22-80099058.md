---
layout: post
title: "java基础-常见简答题"
date: 2025-01-22 09:27:25 +0800
description: "一、包的作用：1、将功能相近的类放到同一个包中，可以方便查找和使用。2、在一定程度上避免命名冲突。3"
keywords: "java简答题"
categories: ['总结知识点']
tags: ['无标签']
artid: "80099058"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=80099058
    alt: "java基础-常见简答题"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java基础--常见简答题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     一、包的作用：1、将功能相近的类放到同一个包中，可以方便查找和使用。2、在一定程度上避免命名冲突。3、在java中，访问权限是可以是以包为单位的。
    </p>
    <p>
     二、简述方法的重写和重载
     <br/>
     override（重写）
     <br/>
     1.方法名、参数、返回值相同。
     <br/>
     2、重写方法的访问修饰符一定要大于或等于被重写的方法。
     <br/>
     3、重写方法不能抛出新的异常或者抛出比被重写方法更宽泛的异常
     <br/>
     4、存在于父类和子类之间。
     <br/>
     5、被final修饰的方法不能重写
     <br/>
     overload（重载）
     <br/>
     1、参数类型、个数、顺序至少有一个不相同。
     <br/>
     2、不能重载只有返回值不同的方法名。
     <br/>
     3、存在于同类中。
    </p>
    <p>
     三、java实现多态的机制是什么？
     <br/>
     多态可分为：
     <br/>
     1.编译多态：主要是体现在重载，系统在编译时就能确定调用重载函数的哪个版本。
     <br/>
     2.运行多态：主要体现在OO设计的继承性上，子类的对象也是父类的对象，即上溯造型，所以子类对象可以作为父类对象使用，父类的对象变量可以指向子类对象。因此通过一个父类发出的方法调用可能执行的是方法在父类中的实现，也可能是某个子类中的实现，它是由运行时刻具体的对象类型决定的。
     <br/>
     靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
    </p>
    <p>
     四、简述this关键字的用法
     <br/>
     1、this调用本类中的属性，也就是类中的成员变量；
     <br/>
     2、this调用本类中的其他方法；
     <br/>
     3、this调用本类中的其他构造方法，调用时要放在构造方法的首行。
    </p>
    <p>
     五、什么是抽象类？什么是抽象方法？有什么特点？
     <br/>
     使用abstract关键字修饰的类
     <br/>
     特点：
     <br/>
     1、不能创建实例，即不能new一个抽象类
     <br/>
     2、可以不包含抽象方法，若一旦包含，该类必须作为抽象类
     <br/>
     3、若子类没有实现父类所有的抽象方法，那么子类也得作为抽象类（抽象派生类）
     <br/>
     4、构造方法不能都定义成私有的，否则不能有子类（创建子类对象前先调用父类构造方法）
     <br/>
     5、抽象类不能使用final修饰，因为必须有子类，抽象方法才能得以实现
     <br/>
     使用abstract修饰且没有方法体的方法，称为“抽象方法”。
     <br/>
     特点：
     <br/>
     1、使用abstract修饰，方法没有方法体，留给子类去实现。
     <br/>
     2、抽象方法修饰符不能是private、final和static
     <br/>
     3、抽象方法必须定义在抽象类或接口中
    </p>
    <p>
     六、请说出作用域public，private，protected，以及不写时的区别
     <br/>
     private修饰的成员变量和函数只能在类本身和内部类中被访问。
     <br/>
     protected 修饰的成员变量和函数能被类本身、子类及同一个包中的类访问。
     <br/>
     public修饰的成员变量和函数可以被类、子类、同一个包中的类以及任意其他类访问。
     <br/>
     默认情况（不写）下，属于一种包访问，即能被类本身以及同一个包中的类访问。
     <br/>
     画出作用域图
    </p>
    <p>
     七、&amp;和&amp;&amp;的区别？
     <br/>
     &amp;，&amp;&amp;：（与，短路与）：一样的地方就是二者执行最后的结果是一样的，但是执行的过程有区别，
     <br/>
     对于&amp;：无论&amp;左边是否为false，他都会继续检验右边的boolean值。
     <br/>
     对于&amp;&amp;:只要检测到左边Boolean值为false时，就会直接判断结果，不会在检验右边的值（因为”与”有一个false最后结果就是false了）
     <br/>
     所以&amp;&amp;的执行效率更高，所以一般都是使用&amp;&amp;.
     <br/>
     |与||之间也是同样的道理，|：无论左边是否为ture，都会检验右边 ，||：则不会。|| 的执行效率会更高
     <br/>
     八、抽象类（abstract class）和接口（interface）有什么异同？
     <br/>
     相同点：
     <br/>
     1、都不能被实例化
     <br/>
     2、接口的实现类或者抽象类的子类都必须实现了接口或抽象类中的方法后才可以被实例化
     <br/>
     不同点：
     <br/>
     1、抽象类可以包含非抽象的方法，而接口中的方法必须是抽象的。
     <br/>
     2、继承抽象类在Java语言体系中体现一种继承关系，在合理的继承关系中，父类和派生类比如按存在is-a关系。而实现接口则体现一种has-a关系，实现者仅仅是实现了interface定义的契约而已。
     <br/>
     3、抽象类中可以有成员变量，而接口中不能有成员变量。
     <br/>
     4、抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的属性可以是任意的，而接口中的静态成员变量默认且必须是public static final。
     <br/>
     5、接口中的抽象方法默认且必须都是public的，而抽象类中的抽象方法可以是public、protect或默认。
     <br/>
     6、抽象类中可以有构造方法，但是不能实例化。
     <br/>
     7、抽象类中可以有静态方法（非抽象的），而接口中不能有静态方法。
     <br/>
     8、抽象类中的抽象方法不能用static、synchronized和native连用
    </p>
    <p>
     九、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
     <br/>
     Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
     <br/>
     在不同平台编写的Java源程序（.java文件）被编译器‘翻译’成一个字节码文件（.class文件，是一种中间文件、通用文件、可被所有平台的JVM所识别的文件。 ），而这个字节码文件可被不同平台的JVM所识别，在不同平台对.class文件进行与平台相对应的处理方式。 所以JVM相当于一个翻译官： 由不同平台的.java文件解释生成统一的.class文件，再由对应平台的JVM执行这个.class文件，由此实现Java语言的一大特性：一次编写，处处运行（Write once and run anywhere）。
    </p>
    <p>
     十、是否可以从一个static方法内部发出对非static方法的调用？
     <br/>
     不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法是静态方法，是属于类的方法，调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法关联到那个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不能发出对非static方法的调用。
    </p>
    <p>
     十一、Integer与int的区别
     <br/>
     1、Integer是int的包装类；int是基本数据类型；
     <br/>
     2、Integer变量必须实例化后才能使用；int变量不需要；
     <br/>
     3、Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；
     <br/>
     4、Integer的默认值是null；int的默认值是0。
    </p>
    <p>
     十二、构造器Constructor是否可被override?
     <br/>
     构造器Constructor不能被继承，因此不能被重写(Override)，但是可以被重载（Overload）
    </p>
    <p>
     十三、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？
     <br/>
     一个.java类中是可以有多个类。
     <br/>
     但是，在多个类中，有且只有一个public类，且public类的类名必须与*.java的文件名相一致
     <br/>
     JVM虚拟机实例通过调用某个类的main()来执行程序，这个main（）必须是public static void 并接受一个字符串作为参数，但是该类不一定是public类。
    </p>
    <p>
     十四、String,StringBuffer与StringBuilder的区别??
     <br/>
     String 字符串常量
     <br/>
     StringBuffer 字符串变量（线程安全）
     <br/>
     StringBuilder 字符串变量（非线程安全）
     <br/>
     String是对象不是原始类型为不可变对象，一旦创建就不能修改它的值
     <br/>
     对于已经存在的String的对象的修改都是重新创建一个新的对象，然后把值保存进去（旧的值会被回收）。String是final类，不能被继承
     <br/>
     StringBuffer和StringBuilder是一个可变对象，它只能通过构造函数来建立。
     <br/>
     1.如果要操作少量的数据用 = String
     <br/>
     2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
     <br/>
     3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer
    </p>
    <p>
     十五、String s = new String(“xyz”);创建了几个String Object?二者之间有什么区别？
     <br/>
     两个。第一个对象是字符串常量”xyz” 第二个对象是new String(“xyz”)的时候产生的，在堆中分配内存给这个对象，只不过这个对象的内容是指向字符串常量”xyz” 另外还有一个引用s，指向第二个对象。这是一个变量，在栈中分配内存。
    </p>
    <p>
     十六、 面向对象的特征有哪些方面
     <br/>
     面向对象的三大特征：1.继承 2.封装 3.多态性
     <br/>
     （1）继承：就是保留父类的属性，开扩新的东西。通过子类可以实现继承，子类继承父类的所有状态和行为，同时添加自身的状态和行为。
     <br/>
     （2）封装：就是类的私有化。将代码及处理数据绑定在一起的一种编程机制，该机制保证程序和数据不受外部干扰。
     <br/>
     （3）多态：是允许将父对象设置成为和一个和多个它的子对象相等的技术。包括重载和重写。重载为编译时多态，重写是运行时多态。
    </p>
    <p>
     十七、接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类？
     <br/>
     接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承(extends)实体类，(但前提是实体类必须有明确的构造函数)。
    </p>
    <p>
     十八、 类和对象的关系？
     <br/>
     1、类是抽象概念，对象是类具体的实例。
     <br/>
     2、一个类可以有多个对象，而一个对象只能属于一个类
     <br/>
     3、创建对象是类的主要使用方式
    </p>
    <p>
     十九、 类体中的方法包含哪些分类？
     <br/>
     构造方法
     <br/>
     普通方法
     <br/>
     静态方法
    </p>
    <p>
     二十、类变量与实例变量的区别？
     <br/>
     类变量也叫静态变量，也就是在变量前加了static 的变量；
     <br/>
     实例变量也叫对象变量，即没加static 的变量；
     <br/>
     区别在于：类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果；而实例变量则属对象私有，某一个对象将其值改变，不影响其他对象
    </p>
    <p>
     二十一：构造函数的作用和特点
     <br/>
     作用：用来创建对象
     <br/>
     特点：
     <br/>
     1、使用new空格方法创建（实例化）一个新对象。
     <br/>
     2、构造方法方法名必须与类名同名，并且没有返回值。
     <br/>
     3、一个类可以有多个构造方法（形参，列表不同）
     <br/>
     4、如果一个类中，没有定义任何构造方法，编译器会自动添加无参构造。
    </p>
    <p>
     二十二、 Java中，请说明final关键字的使用
     <br/>
     1.用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；
     <br/>
     2.用来修饰方法参数，表示在变量的生存期中它的值不能被改变；
     <br/>
     3.修饰方法，表示该方法无法被重写；
     <br/>
     4.修饰类，表示该类无法被继承。
    </p>
    <p>
     二十三、2. 在java中，声明一个数组过程中，是如何分配内存的？
     <br/>
     静态初始化：
     <code>
      //只是指定初始值，并没有指定数组的长度，但是系统为自动决定该数组的长度为4
      <br/>
      2 String[] computers = {"Dell", "Lenovo", "Apple", "Acer"};　　//①
      <br/>
      3 //只是指定初始值，并没有指定数组的长度，但是系统为自动决定该数组的长度为3
      <br/>
      4 String[] names = new String[]{"多啦A梦", "大雄", "静香"};　　//②
     </code>
     初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度，程序员虽然没有指定数组长度，但是系统已经自动帮我们给分配了，
     <br/>
     动态初始化：初始化时由程序员显示的指定数组的长度，由系统为数据每个元素分配初始值，如：
     <code>
      //只是指定了数组的长度，并没有显示的为数组指定初始值，但是系统会默认给数组数组元素分配初始值为null
      <br/>
      String[] cars = new String[4];
     </code>
     动态初始化方式，程序员虽然没有显示的指定初始化值，但是因为Java数组是引用类型的变量，所以系统也为每个元素分配了初始化值null，当然不同类型的初始化值也是不一样的，如果是基本类型的话，假设是int类型，那么为他分配的初始化值也是对应的0。
    </p>
    <p>
     二十四、简述值类型参数与引用类型参数在传递时的不同？
     <br/>
     值类型参数在传递时直接传递的是数据值本身，在方法体中对形参的修改不会影响到实参的数值 ；引用类型参数传递时传递的是地址，若在方法体中修改形参指向的数据内容，则会对实参变量的数值产生影响，因为形参变量和实参变量共享同一块堆区。当使用引用数据类型作为方法的形参时，若在方法体中修改形参变量的指向，此时不会对实参变量的数值产生影响，因为形参变量和实参变量分别指向不同的堆区；
    </p>
    <p>
     二十五、Java内存管理
     <br/>
     在java中，有java程序、虚拟机、操作系统三个层次，其中java程序与虚拟机交互，而虚拟机与操作系统交互。这也就保证了java的与平台无关性
     <br/>
     1.程序运行前：JVM向操作系统请求一定的内存空间，成为初始内存空间！程序执行过程中所需的内存都是由java虚拟机从这片内存空间中划分的
     <br/>
     2.程序运行中：java程序一直向java虚拟机申请内存，当程序所需要的内存空间超出初始内存空间时，java虚拟机会再次向操作系统申请更多的内存供程序使用！
     <br/>
     3.内存溢出：程序接着运行，当java虚拟机已申请的内存达到了规定的最大内存空间，但程序还需要跟多的内存，这时会出现内存溢出的错误！
     <br/>
     由此，我们知道java程序所用的内存是有java虚拟机进行管理、分配的
    </p>
    <p>
     二十六、
     <a href="https://blog.csdn.net/a639735331/article/details/80094710">
      Java对象的生命周期和对象的访问过程
     </a>
    </p>
    <p>
     二十七、
     <a href="https://blog.csdn.net/a639735331/article/details/80094504">
      JAVA虚拟机：JVM内存分区及用途
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f696c696b656a6a30:2f61727469636c652f64657461696c732f3830303939303538" class_="artid" style="display:none">
 </p>
</div>


