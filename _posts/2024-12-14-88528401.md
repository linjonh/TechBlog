---
layout: post
title: "获取硬件信息绑定主板号加密软件"
date: 2024-12-14 20:05:36 +0800
description: "首先说一下获取主板号的方法，windows命令行输入wmic BaseBoard get Seria"
keywords: "绑定主板 序列号"
categories: ["未分类"]
tags: ["C"]
artid: "88528401"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=88528401
  alt: "获取硬件信息绑定主板号加密软件"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     获取硬件信息——绑定主板号（加密软件）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     首先说一下获取主板号的方法，windows命令行输入wmic BaseBoard get SerialNumber即可查看自己电脑主板号
    </p>
    <p>
     <strong>
      下面介绍具体代码来实现获取主板号，下列是头文件.h
     </strong>
    </p>
    <p>
     #if !defined(AFX_DD71A3C0_A52F_4C38_B062_8E05785607DC__INCLUDED_)
     <br/>
     #define AFX_DD71A3C0_A52F_4C38_B062_8E05785607DC__INCLUDED_
    </p>
    <p>
     #if _MSC_VER &gt; 1000
     <br/>
     #pragma once
     <br/>
     #endif // _MSC_VER &gt; 1000
    </p>
    <p>
     #include &lt;iostream&gt;
     <br/>
     #include &lt;string&gt;
     <br/>
     #include &lt;windows.h&gt;
    </p>
    <p>
     using namespace std;
    </p>
    <p>
     //--------------------------------------------------------------
     <br/>
     //                        主板序列号
     <br/>
     //--------------------------------------------------------------
     <br/>
     BOOL GetBaseBoardByCmd(char *lpszBaseBoard, int len = 128);
    </p>
    <p>
     <br/>
     #endif // !defined(AFX_DD71A3C0_A52F_4C38_B062_8E05785607DC__INCLUDED_)
    </p>
    <p>
     <strong>
      下面介绍GetBaseBoardByCmd函数的实现.cpp
     </strong>
    </p>
    <p>
     #include"Encryption.h"
     <br/>
     //#include "stdafx.h"
     <br/>
     #include&lt;QDebug&gt;
     <br/>
     //--------------------------------------------------------------
     <br/>
     //                        主板序列号 -- 获取不到时为 None
     <br/>
     //--------------------------------------------------------------
     <br/>
     BOOL GetBaseBoardByCmd(char *lpszBaseBoard, int len/*=128*/)
     <br/>
     {
     <!-- -->
     <br/>
     const long MAX_COMMAND_SIZE = 10000; // 命令行输出缓冲大小
     <br/>
     WCHAR szFetCmd[] = L"wmic BaseBoard get SerialNumber"; // 获取主板序列号命令行
     <br/>
     const string strEnSearch = "SerialNumber"; // 主板序列号的前导信息
    </p>
    <p>
     BOOL   bret = FALSE;
     <br/>
     HANDLE hReadPipe = NULL; //读取管道
     <br/>
     HANDLE hWritePipe = NULL; //写入管道
     <br/>
     PROCESS_INFORMATION pi;   //进程信息
     <br/>
     STARTUPINFO            si;      //控制命令行窗口信息
     <br/>
     SECURITY_ATTRIBUTES sa;   //安全属性
    </p>
    <p>
     char            szBuffer[MAX_COMMAND_SIZE + 1] = { 0 }; // 放置命令行结果的输出缓冲区
     <br/>
     string            strBuffer;
     <br/>
     unsigned long    count = 0;
     <br/>
     long            ipos = 0;
    </p>
    <p>
     memset(&amp;pi, 0, sizeof(pi));
     <br/>
     memset(&amp;si, 0, sizeof(si));
     <br/>
     memset(&amp;sa, 0, sizeof(sa));
    </p>
    <p>
     pi.hProcess = NULL;
     <br/>
     pi.hThread = NULL;
     <br/>
     si.cb = sizeof(STARTUPINFO);
     <br/>
     sa.nLength = sizeof(SECURITY_ATTRIBUTES);
     <br/>
     sa.lpSecurityDescriptor = NULL;
     <br/>
     sa.bInheritHandle = TRUE;
    </p>
    <p>
     //1.0 创建管道
     <br/>
     bret = CreatePipe(&amp;hReadPipe, &amp;hWritePipe, &amp;sa, 0);
     <br/>
     if (!bret)
     <br/>
     {
     <!-- -->
     <br/>
     goto END;
     <br/>
     }
    </p>
    <p>
     //2.0 设置命令行窗口的信息为指定的读写管道
     <br/>
     GetStartupInfo(&amp;si);
     <br/>
     si.hStdError = hWritePipe;
     <br/>
     si.hStdOutput = hWritePipe;
     <br/>
     si.wShowWindow = SW_HIDE; //隐藏命令行窗口
     <br/>
     si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
    </p>
    <p>
     //3.0 创建获取命令行的进程
     <br/>
     bret = CreateProcess(NULL, szFetCmd, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);
     <br/>
     if (!bret)
     <br/>
     {
     <!-- -->
     <br/>
     goto END;
     <br/>
     }
    </p>
    <p>
     //4.0 读取返回的数据
     <br/>
     WaitForSingleObject(pi.hProcess, 500/*INFINITE*/);
     <br/>
     bret = ReadFile(hReadPipe, szBuffer, MAX_COMMAND_SIZE, &amp;count, 0);
     <br/>
     if (!bret)
     <br/>
     {
     <!-- -->
     <br/>
     goto END;
     <br/>
     }
    </p>
    <p>
     //5.0 查找主板序列号
     <br/>
     bret = FALSE;
     <br/>
     strBuffer = szBuffer;
     <br/>
     ipos = strBuffer.find(strEnSearch);
    </p>
    <p>
     if (ipos &lt; 0) // 没有找到
     <br/>
     {
     <!-- -->
     <br/>
     goto END;
     <br/>
     }
     <br/>
     else
     <br/>
     {
     <!-- -->
     <br/>
     strBuffer = strBuffer.substr(ipos + strEnSearch.length());
     <br/>
     }
    </p>
    <p>
     memset(szBuffer, 0x00, sizeof(szBuffer));
     <br/>
     strcpy_s(szBuffer, strBuffer.c_str());
    </p>
    <p>
     //去掉中间的空格 \r \n
     <br/>
     int j = 0;
     <br/>
     for (int i = 0; i &lt; strlen(szBuffer); i++)
     <br/>
     {
     <!-- -->
     <br/>
     if (szBuffer[i] != ' ' &amp;&amp; szBuffer[i] != '\n' &amp;&amp; szBuffer[i] != '\r')
     <br/>
     {
     <!-- -->
     <br/>
     lpszBaseBoard[j] = szBuffer[i];
     <br/>
     j++;
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     bret = TRUE;
    </p>
    <p>
     END:
     <br/>
     //关闭所有的句柄
     <br/>
     CloseHandle(hWritePipe);
     <br/>
     CloseHandle(hReadPipe);
     <br/>
     CloseHandle(pi.hProcess);
     <br/>
     CloseHandle(pi.hThread);
    </p>
    <p>
     return(bret);
     <br/>
     }
     <br/>
     <strong>
      具体调用方法如下：
     </strong>
    </p>
    <p>
     char mother_board_serial_number[128] = {0};//代码获取到的主板号
    </p>
    <p>
     char target_board_serial_number[128] = "DBB8911001730038F530C1";//自己电脑的主板号
    </p>
    <p>
     bool ret = GetBaseBoardByCmd(mother_board_serial_number);
    </p>
    <p>
     <strong>
      接下来比较一下即可 如果不一致直接关闭程序
     </strong>
    </p>
    <p>
     if (ret)
     <br/>
     {
     <!-- -->
     <br/>
     qDebug()&lt;&lt;"本机序列号"&lt;&lt;mother_board_serial_number;
     <br/>
     if (strcmp(mother_board_serial_number, target_board_serial_number)!=0)
     <br/>
     {
     <!-- -->
     <br/>
     QMessageBox::information(NULL, "提示", "本机序列号与软件硬件环境不符，关闭软件", "好的");
     <br/>
     return 0;
     <br/>
     }
     <br/>
     }
     <br/>
     else
     <br/>
     {
     <!-- -->
     <br/>
     QMessageBox::information(NULL, "提示", "本机序列号获取失败，关闭软件", "好的");
     <br/>
     return 0;
     <br/>
     }
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3431303737343834:2f61727469636c652f64657461696c732f3838353238343031" class_="artid" style="display:none">
 </p>
</div>
