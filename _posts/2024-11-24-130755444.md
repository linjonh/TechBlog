---
layout: post
title: UartAssist串口调试工具使用指南-附UartAssist工具包
date: 2024-11-24 13:49:18 +0800
categories: ['C']
tags: ['网络', '单片机', 'Linux']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=130755444
    alt: UartAssist串口调试工具使用指南-附UartAssist工具包
artid: 130755444
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     UartAssist串口调试工具使用指南 （附UartAssist工具包）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一、UartAssist 概述
    </h3>
    <h4>
     1、UartAssist简介
    </h4>
    <p>
     UartAssist串口调试助手软件，是Windows平台下的串口通信调试工具，广泛应用于工控领域的数据监控、数据采集、数据分析等工作，是串口应用开发及调试工作必备的专业工具之一，可以帮串口通信项目的应用设计、开发、测试人员检查所开发的串口通信应用软/硬件产品的数据收发状况，提高开发速度，简化开发复杂度，是串口通信应用开发调试的得力助手。
    </p>
    <p>
     UartAssist串口调试助手是绿色软件，无需安装，只有一个执行文件，适用于各版本Windows操作系统，不需要微软dotNet框架支持。可以在一台PC上同时启动多个串口调试助手（使用不同的COM口）。
    </p>
    <p>
     典型应用场合：通过串口调试助手与自行开发的串口程序或者串口设备进行通信联调。支持多串口，自动监测枚举本地可用串口；自由设置串口号、波特率、校验位、数据位和停止位等（支持自定义非标准波特率）；支持对串口DCD、DTR、DSR、RTS等针脚状态位的检测控制。
    </p>
    <p>
     支持ASCII/Hex两种模式的数据收发，发送和接收的数据可以在16进制和AscII码之间任意转换；可以自动发送校验位，支持多种校验格式；支持间隔发送，循环发送，批处理发送，输入数据可以从外部文件导入；可以保存预定义指令/数据序列，任何时候都可以通过工具面板发送预定义的指令或数据，或进行批量指令发送，便于通信联调。
    </p>
    <p>
     软件界面支持中/英文（通过菜单选项选择切换），默认自适应操作系统的语言环境。
    </p>
    <p>
     功能点：
    </p>
    <ul>
     <li>
      绿色软件、只有一个执行文件、无需安装；
     </li>
     <li>
      支持中英文双语言，自动根据操作系统环境选择系统语言类型；
     </li>
     <li>
      支持常用的各种波特率，端口号、校验位、数据位和停止位均可设置；
     </li>
     <li>
      支持软/硬件多种流控方式；
     </li>
     <li>
      自动检测枚举本机串口号，支持虚拟串口；
     </li>
     <li>
      支持设置分包参数（最大包长、分包时间），防止接收时数据粘包。
     </li>
     <li>
      支持ASCII/HEX码数据发送,发送和接收的数据可以在十六进制码和ASCII码之间任意转换，支持发送和显示汉字；
     </li>
     <li>
      可以自动发送校验位，支持多种校验格式，如校验和、LRC、BCC、CRC8、CRC16、CRC32、MD5等，其中CRC校验码可任意定制CRC参数(CRC多项式、初始值、输入反转、输出反转、输出异或值)；
     </li>
     <li>
      发送内容支持转义字符。例如，发送框中文本包含诸如\r\n等转义符时，会自动解析成对应的ASCII码进行发送。
     </li>
     <li>
      支持AT指令自动添加回车换行选项，启用该选项时，在发送AT指定时会自动在行尾补全回车换行符；
     </li>
     <li>
      可以通过输入框发送数据,也可以从文件数据源发送数据；
     </li>
     <li>
      支持接收数据自动保存到文件,并且文件类型支持数据文件和日志文件两种格式，其中数据文件只保存接收的数据内容，而日志文件则会保存调试助手完整的数据收发日志信息。
     </li>
     <li>
      支持日志接收模式：启用该选项后在接收窗口显示接收内容时自动显示时间戳等相关信息。
     </li>
     <li>
      支持任意间隔发送，循环发送；
     </li>
     <li>
      接收和发送的文字编码支持ANSI(GBK)与UTF8两种方式，并且接收编码与发送编码可以独立设置，互不影响；
     </li>
     <li>
      支持预定义指令/数据，可通过按键或者自定义快捷键发送预定义指令,预定义指令/数据列表可以按文件的方式保存、导入和导出；
     </li>
     <li>
      支持批量发送指令/数据序列，可设置每条指令的发送延迟，并可按设定顺序及延迟时间依次批量发送。批量定义的数据/指令可以保存、导入和导出。
     </li>
     <li>
      自动保存历史发送记录，可以通过历史记录发送历史数据；
     </li>
     <li>
      支持界面窗口的字体以及背景定制；
     </li>
     <li>
      支持工作界面精简模式（主界面左侧面板可折叠收起）；
     </li>
     <li>
      可定制发送框默认数据内容；
     </li>
    </ul>
    <h4>
     2、运行环境
    </h4>
    <p>
     软件运行环境为Windows平台,包括Windows95/WinXP/Vista/Win7/Win8/Win10/WinALL，兼容32位/64位操作系统。
    </p>
    <h4>
     3、软件安装
    </h4>
    <p>
     绿色软件，解压后只有一个执行文件，直接运行即可。无需安装（不依赖）Microsoft .NETFramework框架。
    </p>
    <h4>
     4、应用场景
    </h4>
    <p>
     串口调试助手通过对PC端口串口(COM口或USB串口）的读写操作，实现对串口设备或者串口应用程序的通信联调。通过串口数据的抓取、记录、分析以及数据/指令的发送控制，实现对目标串口设备或者串口应用程序的通信能力以及通信行为的分析、验证。总的来说，串口调试助手，主要有几下几类应用场景。
    </p>
    <p>
     （1） 串口终端(仪器设备)的参数设置。工程应用中为了方便终端设备的参数设置，可通过串口调试助手建立到串口终端设备的串口连接，然后直接在串口调试助手中对串设备进行参数设置。
    </p>
    <p>
     （2）串口终端(仪器设备)的操作控制、串口数据的抓取、记录及分析。在工程应用中，某些场景下需要对串口设备发送指令从而实现对设备的控制操作，或者需要对串口设备的数据进行抓包记录。通过串口调试助手可以定时向串口终端发送指令数据，并自动将接收及发送的报文数据，并按日志的形式保存至磁盘文件，以便于用户对设备的状态数据进行分析统计。
    </p>
    <p>
     （3）工控设备/单片机的开发调试。在单片机/嵌入式系统的串口开发过程中，可通过串口调试助手接收单片机设备的串口数据，或者向单片机设备发送串口数据，配合单片机程序开发，验证单片机程序的通信能力以及业务逻辑的准确性；或者通过串口调试助手对单片机设备进行数据疲劳测试（通过批量或者循环指令发送），并记录通信过程中的数据交互日志，实现串口产品在研发过程中的可靠性验证。
    </p>
    <h4>
     5、软件界面
    </h4>
    <p>
     UartAssist串口调试助手的主要功能界面如下图所示，包括主界面及工具面板窗口各项功能构成。
    </p>
    <p>
     软件主界面：
    </p>
    <p>
     <img alt="" height="628" src="https://i-blog.csdnimg.cn/blog_migrate/cb6e6a82440f981338e3ca13d4f5e613.png" width="752"/>
    </p>
    <p>
     界面基本构成：
    </p>
    <p>
     <img alt="" height="440" src="https://i-blog.csdnimg.cn/blog_migrate/c9a6ec0fa0e22755a6f528fb21dc3ace.png" width="820"/>
    </p>
    <p>
     界面主题（背景/字体）设置：
    </p>
    <p>
     <img alt="" height="593" src="https://i-blog.csdnimg.cn/blog_migrate/dfbdd221f724ff5465fb0fa716cf1155.png" width="706"/>
    </p>
    <p>
     工具面板—快捷定义：
    </p>
    <p>
     <img alt="" height="612" src="https://i-blog.csdnimg.cn/blog_migrate/8eabcda8fdc51a5a2aaa0ac263fbd6af.png" width="726"/>
    </p>
    <p>
     工具面板/批量发送：
    </p>
    <p>
     <img alt="" height="543" src="https://i-blog.csdnimg.cn/blog_migrate/acd683f4e108cb4ba3f1a8b5124c42ba.png" width="723"/>
    </p>
    <p>
     工具面板/历史发送：
    </p>
    <p>
     <img alt="" height="544" src="https://i-blog.csdnimg.cn/blog_migrate/2b4c447e9ff8fb42903d64d4732c7bb4.png" width="724"/>
    </p>
    <p>
     工具面板/检验计算器：
    </p>
    <p>
     <img alt="" height="634" src="https://i-blog.csdnimg.cn/blog_migrate/6eb58766cf2a1829ec8094d4ee2676ec.png" width="728"/>
    </p>
    <h3>
     二、UartAssist 配置选项
    </h3>
    <p>
     调试助手的配置参数及控制选项众多，涉及的内容包括系统语言、文字编码、窗口样式、数据格式、数据校验、转义字符支持、数据发送控制方式、数据接收存储及日志文件记录等等。
    </p>
    <p>
     使用调试助手进行通信调试时，结合实际应用场景，使用恰当的配置选项，可以有效地提高通信调试的工作效率，甚至达到事半功倍的效果。
    </p>
    <h4>
     1、语言及编码
    </h4>
    <p>
     调试助手软件支持中、英文双语，默认情况下自动根据系统语言选择切换。在中文环境下自动选择中文，其它语言环境自动选择为英文。也可以通过调试助手的[Language]菜单选项，直接指定中/文语言。
    </p>
    <p>
     <img alt="" height="653" src="https://i-blog.csdnimg.cn/blog_migrate/e3d59b032cb0488f67fc427cc4375258.png" width="737"/>
    </p>
    <p>
     调试助手的数据编码支持 ANSI(GBK)/UTF-8 两种编码。默认方式是ANSI(GBK)编码。如果接收窗口显示乱码数据，有可能接收到的数据是 UTF-8 编码的文字，如果按照默认的ANSI(GBK)方式显示就会乱码.解决方法是，在接收窗口中点击右键，在弹出菜单中，选择切换编码为 UTF-8，如上图所示。
    </p>
    <p>
     注意，切换编码后，并不会刷新显示已接收的乱码数据，只有后来新接收的数据才能按新的编码设置来显示。
    </p>
    <p>
     发送数据时，也涉及到文字编码方式的选择。发送窗口的编码方式与接收窗口的编码方式是相互独立的。同接收窗口的编码设置方式一样，在发送窗口点击右键，在弹出的右键菜单，可以选择发送数据的编码方式为 ANSI(GBK)或 UTF-8。
    </p>
    <p>
     对于英文字母或字符，不需要区分是 ANSI(GBK)编码还是 UTF-8 编码，因为这两种编码是相同的，都是一个字节的 ASCII 码；但是对于汉字等多字节编码的文字或符号则是不一样的。比如，1 个汉字的 ANSI(GBK)编码占 2 个字节，而 1 个汉字的 UTF-8 编码则占3 个字节。调试助手能够按照所设置的编码方式对收发数据进行相应的编码及显示处理。
    </p>
    <p>
     比如，在发送窗口输入汉字“你好”，然后点击【发送】按钮时，如果按 ANSI(GBK)编码发送，则实际发送的 16 进制数据是“C4 E3 BA C3”，而按 UTF-8 编码发送时，实际发送的16 进制数据是“E4 BD A0 E5 A5 BD”。调试助手会按照当前设定的编码发送正确的数据。
    </p>
    <h4>
     2、窗口主题样式
    </h4>
    <p>
     为了确保软件界面更符合个人视觉习惯，调试助手提供了界面主题定制功能。界面主题定制的内容，包括字体样式、大小、颜色及背景。并且，日志提示符、接收的数据、发送的数据，其字体颜色可以分别独立设置。
    </p>
    <p>
     如下图所示，通过菜单选项，调出用户界面主题设置窗口。
    </p>
    <p>
     <img alt="" height="664" src="https://i-blog.csdnimg.cn/blog_migrate/df120af3f5f4dbd34855cd3ee47d19fa.png" width="752"/>
    </p>
    <p>
     可以分别对接收窗口以及发送窗口的界面主题进行定制，或者选择使用预设的主题样式。
    </p>
    <p>
     调试助手提供二个预置的主题样式：白底经典（默认主题）和黑底经典。也可以选择自定义方式，并按个人的喜好习惯设置界面背景以及字体。下图是选择黑底经典主题的效果。左侧控制面板可以折叠收起，显示效果会更加简洁。
    </p>
    <p>
     收/发窗口分别是“黑底经典”及“白底经典”主题模式：
    </p>
    <p>
     <img alt="" height="704" src="https://i-blog.csdnimg.cn/blog_migrate/6d519220b95e1aca10b78517a7435a8d.png" width="827"/>
    </p>
    <p>
     收/发窗口都是“黑底经典”：
    </p>
    <p>
     <img alt="" height="728" src="https://i-blog.csdnimg.cn/blog_migrate/2af0a14b84e1048d2a944c5dcb20db37.png" width="846"/>
    </p>
    <h4>
     3、数据接收设置选项
    </h4>
    <p>
     <strong>
      1. 数据接收格式
     </strong>
    </p>
    <p>
     在调试助手左侧的接收参数面板，可以设置接收数据的显示格式为ASCII 码或者HEX码，方便用户按不同的方式分析查看其所接收的数据。
    </p>
    <p>
     如果接收到的是可打印字符(文字)，可以直接按 ASCII 模式查看，或者按 HEX 模式查看其 16 进制编码；但如果接收到的数据包含非打印字符，那么按 ASCII 模式查看，接收窗口就有可能出现乱码数据，不能有效反映出实接收到的数据内容。这种情形下，可以选择 HEX 模式，就可以如实有效地打印出实际接收的数据内容。
    </p>
    <p>
     <img alt="" height="646" src="https://i-blog.csdnimg.cn/blog_migrate/0bcdc9ed769e7635106d9de274247100.png" width="756"/>
    </p>
    <p>
     如上图所示，分别按 ASCII 码与 HEX 码接收一段包含非打印字符的数据。在按ASCII码接收时包含乱码，而按 HEX 码接收时，就是很好的分辨实际接收的内容。
    </p>
    <p>
     使用调试助手时，要根据实际的场景需求来切换数据显示格式。
    </p>
    <p>
     <strong>
      2. 日志显示格式
     </strong>
    </p>
    <p>
     数据接收窗口默认是按日志模式显示的，除了显示接收到的数据内容外，还会显示接收数据的时间戳、数据格式(ASCII 码/HEX 码)、数据来源 IP 地址及端口号。另外，接收窗口还会显示所发送的数据记录信息。如下图所示：
    </p>
    <p>
     <img alt="" height="658" src="https://i-blog.csdnimg.cn/blog_migrate/62ebf3e2af27ef067de50a5d1b833e66.png" width="687"/>
    </p>
    <p>
     如果在接收设置选项中，取消【按日志模式显示】选项。那么接收窗口就仅显示接收到的数据内容，而不会显示接收记录的时间戳等附加信息，并且发送数据记录也不会显示。
    </p>
    <p>
     <strong>
      3. 接收自动换行
     </strong>
    </p>
    <p>
     【接收区自动换行】选项，决定每接收到一条新的数据记录是否会自动换行，还是在之前接收到的数据末尾追加。这个选项对于日志模式无明显效果，因为日志模式下每一条接收记录都会强制换行。
    </p>
    <p>
     自动换行涉及到一个概念问题，就是如何区分一条数据记录的起始。换句说，在接收连续的数据流时，如何将首尾相连、依次传输的多个报文切开开来，也就是处理粘包问题。由于串口数据传输类似于流式数据传输，只能保证发出的数据或指令包有序地传输，并不会给应用层提供报文分割的起始标识。
    </p>
    <p>
     即使串口发送端是一次性打包发出去的数据，到达接收端时的数据也会像流水一样陆陆续续地到达，尤其是当多个报文的发送间隔很小，并且串口应用程序由于运算能力或者算法效率问题无法及时从串口硬件接收队列取走数据时，导致应用程序无法正确地判断出原始数据包之间的时间间隙，从而无法有效的间隔密集传输的多个报文有效地分割开来。对于串口调试助手，处理数据粘包的问题比较简单粗暴，超过50ms 的间隙就自动截断，作为一条数据记录来对待。
    </p>
    <p>
     <strong>
      4. 接收报存到文件
     </strong>
    </p>
    <p>
     调试助手接收的数据可以自动保存到文件。在接收设置中，点击【接收保存到文件】选项，会弹出下图所示对话框，选择接收保存的文件路径。
    </p>
    <p>
     <img alt="" height="529" src="https://i-blog.csdnimg.cn/blog_migrate/f22049321523064572bbef2e9b4a115d.png" width="662"/>
    </p>
    <p>
     如图所示，选择目标文件存储路径时，要注意设置文件保存类型，可选项有[日志文件]（默认类型）和[数据文件]两种。
    </p>
    <p>
     所谓日志文件，就是目标文件不仅存储接收的数据内容，还存储接收数据的时间戳及数据来源 IP 等相关信息，同时还包含调试助手的发送记录信息；而数据文件，就是目标文件只保存接收到数据内容，不包含其它附加信息，也不包含发送数据记录信息。在实际应用中，如果是用于日志记录用途，那就选择日志文件类型，如果纯粹是为了保存接收到的原始数据，那就选择数据文件类型。
    </p>
    <p>
     <strong>
      5. 接收自动滚屏
     </strong>
    </p>
    <p>
     串口调试助手接收到的数据都会显示在接收窗口，新收到的数据会自动追加到之前接收到的数据末尾，并且接收窗口会实时刷新，如果接收到的数据内容超过窗口高度时就会自动逐行滚屏，保证最新接收到的数据始终在接收窗口可见。这样就会出现一个问题，如果高速接收显示连续的数据流时，接收窗口就会不断滚屏翻页，导致用户无法有效地查看数据，因为还没看清楚就已被自动翻页。
    </p>
    <p>
     接收设置中的【自动滚屏】选项，可以切换自动滚屏功能。软件启动后的默认设置是启用自动滚屏，单击该选项便可切换/关闭自动滚屏。一旦关闭自动滚屏，虽然新收到的数据还是会自动追加到接收窗口的数据末尾，但是接收窗口不会自动滚屏，配合鼠标控制接收窗口的滚动条，用户就可以自由查看接收窗口中的数据，不会再被自动滚屏功能所干扰。
    </p>
    <h4>
     4、数据发送设置选项
    </h4>
    <p>
     数据发送设置选项包括数据发送模式（ASCII/HEX）、转义字符支持、AT 指令自动回车、自动发送校验位、文件数据源设置、循环发送设置等。
    </p>
    <p>
     <strong>
      1. 数据发送类型
     </strong>
    </p>
    <p>
     调试助手可发送的数据类型有 ASCII 文本字符串和 HEX 十六进制编码数据两种。对应在软件界面左侧的发送参数面板，可以选择数据发送编码类型：ASCII 码或HEX 码。任何数据都可以编码成十六进制形式文本进行发送，但不是任何数据都可以按ASCII 码字符串发送。如果发送的数据包含非打印字符，那么转换为 ASCII 码就会发生乱码，发送时就会丢数据。
    </p>
    <p>
     因此，包含非打印字符的数据只能按十六进制编码进行发送；而不包含非打印字符的数据该如何选择数据发送类型，就要根据具体应用场景怎么方便就怎么选择。
    </p>
    <p>
     <strong>
      2. 转义字符支持
     </strong>
    </p>
    <p>
     串口调试助手支持在发送的 ASCII 文本中插入转义字符。只要勾选发送设置中的【自动解析转义符】选项，发送包含转义符的 ASCII 文本时，转义符会自动解析成对应的ASCII码数据进行发送，方便用户以文本形式发送非打印符。转义符以反斜杠开头。
    </p>
    <p>
     比如，回车符的转义字符是\r 或\x0d、换行符的转义符是\n 或\x0a，等等。任何ASCII 码字符（包括可打印字符及不可打印字符）都可以通过\x 后紧跟两位十六进制编码数据来表示。
    </p>
    <p>
     <img alt="" height="727" src="https://i-blog.csdnimg.cn/blog_migrate/bbbbc7bada642c44ed3a42e86e0472bb.png" width="842"/>
    </p>
    <p>
     上图是一个发送文本中包含转义符的例子：在发送框中输入hello\r\n，然后点击发送按钮，表示发送字符串 hello 及回车换行。注意，只有在 ASCII 码发送模式下，并勾选了【自动解析转义符】选项后才支持转义字符。
    </p>
    <p>
     <strong>
      3. AT 指令自动回车
     </strong>
    </p>
    <p>
     为方便 AT 指令的发送，只要勾选【AT 指令自动回车】选项，那么在发送以AT 开头文本指令时，调试助手软件会自动检查是否以回车换行符结尾，如果没有显式的回车换行结尾符，那么发送的 AT 指令自动会在尾部补齐回车换行符。这样，用户发送AT 指令时，就不必每次都添加回车换行符，从而可有效提高通信调试的工作效率。
    </p>
    <p>
     <strong>
      4. 自动发送校验位
     </strong>
    </p>
    <p>
     在使用调试助手进行通信调试时，某些场景下需要发送带校验位的指令数据。比如，调试 modbus 通信协议时，指令末尾需要加 CRC16 校验位。这就要求在准备调试指令前事先计算好校验码，如果遇到指令比较多且随时要修改的情形，就会比较麻烦。
    </p>
    <p>
     针对这个问题，调试助手提供了自动发送校验位功能选项。只要勾选该选项，并选择对应的校验算法，那么发送数据时就会自动在数据末尾发送所选择的校验位数据。
    </p>
    <p>
     <img alt="" height="744" src="https://i-blog.csdnimg.cn/blog_migrate/c395fa6b51ba13d4292787474dac66fd.png" width="770"/>
    </p>
    <p>
     如图所示的例子。校验位选择了 CRC-16/MODBUS，然后发送16 进制数据指令：011000000002040000，而实际发出去的指令末尾会自动增加 2 个字节的CRC16 校验位数据，免去了用户自行计算添加校验位的麻烦。
    </p>
    <p>
     <strong>
      5. 发送文件数据
     </strong>
    </p>
    <p>
     调试助手发送数据时，数据输入方式有两种，常规方式就是通过发送输入框输入数据；而在数据量比较大的情况下，可以将待发送的数据保存为文件，然后通过文件数据源发送数据。
    </p>
    <p>
     具体操作方法：在调试助手左侧控制面板的发送设置中，点击【打开文件数据源】；接着在弹出的文件选择对话框中选择待发送的目标文件，即载入文件数据源；最后，点击【发送】按钮，便开始从文件数据源发送数据。
    </p>
    <p>
     <strong>
      6. 循环发送设置
     </strong>
    </p>
    <p>
     在发送设置面板中，设置好循环发送的时间周期，单位毫秒，并勾选【循环发送】选项，然后点击【发送】按钮，调试助手就会按照所设置的时间周期，循环发送输入的数据源。一旦启动循环发送过程，【发送】按钮便自动切换成【停止】按钮，要终止循环发送操作只要点击【停止】按钮即可。
    </p>
    <p>
     <strong>
      7. 回车键发送设置
     </strong>
    </p>
    <p>
     调试助手的数据发送是通过鼠标点击【发送】按钮来触发的，也可以通过键盘按键的方式进行发送。默认情况下，单独按 Enter 键或者组合键 CTRL+Enter 都可以执行数据发送操作，如果要在发送输入框中输入回车换行符，直接按回车键只能触发数据发送而无法输入回车换行，必须通过组合键 Shift+Enter 来插入回车换行符。
    </p>
    <p>
     发送快捷键设置：
    </p>
    <p>
     <img alt="" height="416" src="https://i-blog.csdnimg.cn/blog_migrate/d5454c159825bbd17d72776c404521b2.png" width="799"/>
    </p>
    <p>
     如果要改变回车键的默认设置，可以右键点击【发送】按钮，在弹出的右键菜单中进行勾选设置，如上图所示，具体选项说明如下。
    </p>
    <ul>
     <li>
      [按 Ctrl+Enter 键发送]：该选项勾选后，组合键 Ctrl+Enter 执行发送操作；否则该组合键不执行任何操作；
     </li>
     <li>
      [按 Enter 键发送/Shift Enter 换行]：该选项勾选后，单独按Enter 键（不要组合 Shift 或 Ctrl）时执行发送操作，而组合键 Shift+Enter 用于在发送输入框中输入回车换行；如果取消勾选该选项，则单独按回车键时就会输入回车换行符而不会触发发送操作，并且组合键 Shift+Enter 无效；
     </li>
    </ul>
    <h4>
     5、发送框默认内容设置
    </h4>
    <p>
     发送框默认内容设置：
    </p>
    <p>
     <img alt="" height="656" src="https://i-blog.csdnimg.cn/blog_migrate/8ed4ad3fbe53aaa1848ad4c500bdd4d6.png" width="768"/>
    </p>
    <p>
     调试助手软件启动后，发送输入框中的默认显示内容可以进行定制，可以是固定的数据内容（或为空），也可以记住上一次关闭时最后一条发送的数据。具体设置方法：在调试助手的菜单中找到【发送框中默认内容】选项，点击弹出设置窗口，如上图所示。
    </p>
    <p>
     可以选择【记住上一次成功发送的内容】或者【固定内容】。对于固定内容，可以选择ASCII码文本或者 HEX 码十六进制数据。修改设置后，点击确定按钮，下次启动调试助手软件时生效。
    </p>
    <h4>
     6、其它参数及控制选项
    </h4>
    <p>
     <strong>
      1. 新建会话
     </strong>
    </p>
    <p>
     在通信调试过程中，根据实际应用场景，可能随时需要运行多个调试助手软件。为了避免用户在电脑中查找/执行软件的麻烦,调试助手软件提供了【新建会话】功能，该控制选项位于系统菜单的第一个菜单项，用于启动另外一个调试助手的软件实例，也就是再运行一个调试助手软件。
    </p>
    <p>
     每点击一次【新建会话】选项，就会启动一个调试助手窗口进程，只要PC 的内存足够大，可以同时启动任意多个调试助手窗口。
    </p>
    <p>
     <strong>
      2. 自动记住窗口大小
     </strong>
    </p>
    <p>
     启用【自动记住窗口大小】菜单选项后，调试助手软件在每次关闭时都会自动保存记住当前的窗口大小，再次启动软件时，会自动恢复到上次关闭时软件窗口的大小。
    </p>
    <p>
     <strong>
      3. 窗口固定在最上层
     </strong>
    </p>
    <p>
     【窗口固定在最上层】菜单选项，其实就是窗口置顶功能，可避免串口调试助手被其它软件窗口遮挡。该菜单选项还有一个快捷方式入口在调试助手主窗口标题栏目右侧，是一个图钉样式的图标按钮，点击直接切换窗口置顶模式。
    </p>
    <p>
     <strong>
      4. 始终显示任务栏图标
     </strong>
    </p>
    <p>
     调试助手软件启动后会在操作系统的任务栏条以及任务栏的托盘区显示软件图标。当调试助手最小化时，任务栏条上的图标在默认选项下会自动隐藏，只在任务栏的托盘区显示图标。如果用户的操作系统托盘区设置了折叠模式，那么调试助手的图标就有可能被隐藏起来，不容以直观地找到。
    </p>
    <p>
     这种情况下，就希望调试助手最小化时，不隐藏任务栏条上的软件图标。【始终显示任务栏图标】菜单项即用于实现该功能，该选项勾选后，操作系统的任务栏条上会始终显示调试助手的软件图标，方便用户定位工作窗口。
    </p>
    <p>
     <strong>
      5. 关闭按钮默认操作
     </strong>
    </p>
    <p>
     点击调试助手主界面的关闭按钮，是执行软件关闭还是窗口最小化，可以通过该选项来设置，如下图所示。
    </p>
    <p>
     <img alt="" height="782" src="https://i-blog.csdnimg.cn/blog_migrate/9ee1c06aaaa4c358db63df28b4b4abcb.png" width="812"/>
    </p>
    <h3>
     三、UartAssist 基础操作
    </h3>
    <p>
     基本的操作使用方法，包括串口的设置、连接、串口数据的接收以及发送等。
    </p>
    <h4>
     1、串口参数设置
    </h4>
    <p>
     串口通信参数是指波特率、数据位、奇偶校验位和停止位这些参数。在串口设备之间进行连接通信时，通信双方必须约定使用完全相同的通信参数，才能建立有效的通信。也就是说，对于两个进行通信的串行端口，这些参数必须匹配，只有通信双方都在同一个频道上才能保证双方实现有效的数据沟通。
    </p>
    <p>
     串口参数设置界面：
    </p>
    <p>
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/blog_migrate/52cc2522ff15ef56125813bb330ce477.png" width="517"/>
    </p>
    <p>
     （1）波特率。这是一个衡量符号传输速率的参数。它表示每秒钟传送的符号的个数。例如 300 波特表示每秒钟发送 300 个符号。当我们提到时钟周期时，我们就是指波特率，例如如果协议需要 4800 波特率，那么时钟是 4800Hz。这意味着串口通信在数据线上的采样率为 4800Hz。通常电话线的波特率为 14400，28800 和 36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB 设备的通信。
    </p>
    <p>
     （2）数据位。这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是 8 位的，标准的值是 5、7 和 8 位。如何设置取决于你想传送的信息。比如，标准的 ASCII 码是 0～127（7 位）。扩展的 ASCII 码是 0～255（8 位）。如果数据使用简单的文本（标准 ASCII 码），那么每个数据包使用 7 位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。
    </p>
    <p>
     （3）停止位。用于表示单个包的最后一位。典型的值为 1，1.5 和2 位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。
    </p>
    <p>
     （4）奇偶校验位。在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为 0，保证逻辑高的位数是偶数个。如果是奇校验，校验位为1，这样就有 3 个逻辑高位。高位和低位不是真正的检查数据，简单置位逻辑高或者逻辑低校验。
    </p>
    <p>
     这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。
    </p>
    <h4>
     2、打开串口连接
    </h4>
    <p>
     建立串口通信前，先要确认目标串行通信设备是否已经电气连接到本地计算机串口（COM口或 USB 串口）端，并且需要知道设备所连接的计算机串口号。如果连接的是COM 口，由于计算机的 COM 口都是有固定编号的，设备连接到几号 COM 口上，串口号就是几；如果目标通信设备连接的是 USB 转串口适配器（Dongle)，那么串口号是不固定的，但我们可以通过插拔 USB 串口适配器，然后观察调试助手的串口号下拉列表中枚举的可用串口号的增减变化来确认目标设备连接的串口号。
    </p>
    <p>
     在获悉目标通信设备所连接到本地计算机的串口号之后，就可以通过串口调试助手建立跟目标通信设备之间的通信连接了。操作方法很简单，将串口调试助手的串口设置参数中，选择串口号为目标设备一致的串口号，并将其他通信参数（波特率、数据位、奇偶校验位和停止位）设置成设备端一致，最后点击【打开】按钮。如果操作成功，按钮上指示灯由黑色转红色，表示串口成功打开，串口通信建立完成。
    </p>
    <h4>
     3、串口数据接收
    </h4>
    <p>
     串口调试助手在打开串口后，不需要其它额外操作（按默认设置），就可以接收来自串口发送过来的数据，接收到的数据会按照接收设置中设定的模式显示在接收窗口。如下图所示：
    </p>
    <p>
     <img alt="" height="705" src="https://i-blog.csdnimg.cn/blog_migrate/6a4b52f038c27cf5f8801ad1b00a7154.png" width="838"/>
    </p>
    <p>
     为了方便对接收数据的观察分析，可以在接收设置中，对接收模式进行一些修改调整。最常用的是设置数据类型（ASCII/HEX），即接收到的数据是按 ASCII 码字符串显示还是按16 进制字符串显示。如果接收到的数据是文本内容，那么就选择 ASCII 方式；如果接收到的数据是二进制数据或者包含非打印字符，那么就选择 HEX 模式，也就是将接收到的数据转换成十六进制字符串后显示。
    </p>
    <p>
     另外，接收设置中有一个常用选项叫做“按日志模式显示”。如果不勾选这个选项，那么接收窗口只显示接收到的数据，不会显示送的数据，并且显示接收数据时也不带时间戳；如果勾选了这个选项，那么，不管是接收或者发送的数据都会显示在窗口中，并且每条数据记录都带时间戳。
    </p>
    <h4>
     4、串口数据发送
    </h4>
    <p>
     <img alt="" height="735" src="https://i-blog.csdnimg.cn/blog_migrate/ff379c7918c43c508fbdeb59e061bfea.png" width="874"/>
    </p>
    <p>
     串口调试助手往目标串口发送数据，共分为 5 个步骤：
    </p>
    <ol>
     <li>
      串口参数设置；
     </li>
     <li>
      打开串口连接；
     </li>
     <li>
      设置发送的数据类型（ASCII 码字符串/HEX 十六进制字符串）；
     </li>
     <li>
      编辑好待发送的内容；
     </li>
     <li>
      点击发送按钮；
     </li>
    </ol>
    <h4>
     5、发送转义字符
    </h4>
    <p>
     以 ASCII 码字符串方式发送数据时，允许用户在字符串中使用转义字符的方式插入非打印字符。最简单的例子，发送一条带回车换行结尾的 AT 指令，只要在发送框输入AT\r\n，然后直接点击发送按钮即可。
    </p>
    <p>
     目前，调试助手支持如下这些 C 语言标准转义字符：
    </p>
    <p>
     <img alt="" height="336" src="https://i-blog.csdnimg.cn/blog_migrate/a4c032f651b7cfe8a89239223e6555ab.png" width="788"/>
    </p>
    <p>
     作为扩展，调试助手支持转义十六进制数组，例如：\xA0\x12\xF1\xAB\xCD\x51\xF3等价于 \x[A0 12 F1 AB CD 51 F3] 。包含在中括号[]中的多个 16 进制字节之间可以使用若干空格符分割或没有空格。
    </p>
    <p>
     注意：使用转义符时，必须勾选主界面左侧发送设置中的【自动解析转义符】选项，否则调试助手不会对转义符进行任何解析处理。
    </p>
    <h4>
     6、发送指令脚本
    </h4>
    <p>
     通过转义符扩展，调试助手在 V5.0.2 版本之后开始支持发送指令脚本，允许用户在发送的指令数据中，加入各种业务处理逻辑，嵌入包含函数以及计算表达式的脚本代码，动态计算生成最终用于发送的数据内容。出于调试目的，用户还可以在发送的指令中调用printf函数进行调试打印，调试输出结果会显示在日志窗口。
    </p>
    <p>
     下面这个例子，通过调试助手发送一条 Modbus 指令。在调试助手的发送窗口输入以下内容：
    </p>
    <pre><code class="hljs">\x[01 04 00 00 00 04]\[2:reverse(calculate(0,-1,ALGO_CRC16_MODBUS))]</code></pre>
    <p>
     这条指令表示发送一组长度为 6 字节的十六进制数据 01 04 00 00 00 04，后面跟2 字节的 CRC16 校验码，这个校验码通过以下代码动态计算获得：
    </p>
    <pre><code class="hljs">\[2:reverse(calculate(0,-1,ALGO_CRC16_MODBUS))]</code></pre>
    <p>
     其中，\[]称为模式符，用作嵌入脚本代码的容器。上述表达式通过冒号分割成两部分，冒号前的 2 表示最终计算值只取 2 字节，冒号后的表达式用于计算校验码。表达式中的calculate 是系统内置函数，用于计算校验算法，calculate 函数的第1 个参数表示从当前发送数据的第几个字节开始计算校验码；第 2 个参数表示校验数据长度，此长度可以负数，比如为-1 时，表示数据长度截止到当前 calculate 函数调用位置的前一个字节数据,-2 则表示数据长度从当前位置往前推 2 个字节，以此类推；calculate 函数的第3 个参数表示使用的算法，ALGO_CRC16_MODBUS 是系统内置常数，表示 MODBUS_CRC16 校验算法。
    </p>
    <p>
     函数reverse用于将目标数据的字节顺序进行逆转（高低字节交换重排）。这里调用reverse 的目的是因为 calculate 函数计算出的 16 位 CRC 校验码是网络字节顺序（BigEndian)，但是ModbusRTU协议中的 CRC 校验码要求使用 LittleEndian 字序，所以这里要进行字节顺序反转处理。
    </p>
    <p>
     发送包含函数表达式的指令脚本：
    </p>
    <p>
     <img alt="" height="737" src="https://i-blog.csdnimg.cn/blog_migrate/f255e5f1d39431a1e5099b916056d6fc.png" width="972"/>
    </p>
    <p>
     发送脚本代码时，必须勾选发送设置中的【ASCII】模式以及【转义字符指令解析】这两个选项。这是因为，只有选择【ASCII】才允许输入脚本代码，否则若选择HEX 模式，那么就只能输入十六进制数字；并且必须勾选【转义字符指令解析】选项后，调试助手才会对通过反斜杠导入的脚本表达式进行解析。
    </p>
    <p>
     指令中嵌入脚本代码必须使用模式符\[]。具体的嵌入方式有两种：运算表达式和BLOCK代码块。
    </p>
    <p>
     <strong>
      1. 运算表达式
     </strong>
    </p>
    <p>
     这里的运算表达式，特指具有返回值的基于类 C 语言语法规则的计算表达式。其一般形式为：
    </p>
    <pre><code class="hljs"> \[n:expression#remark]</code></pre>
    <p>
     这是一种三段式表示法：第 1 段是输出数据长度，第 2 段是计算表达式，第3 段是注解（注释）文字。其中第 1 段和第 3 段都可以省略，最简形式为 \[expression]。
    </p>
    <p>
     如果设置的输出长度(n)大于实际计算表达式(expression)的最终计算值的长度，则用0 补足后输出，反之若设置的输出长度小于最终计算结果的长度，则截掉高位多余字节后输出。如果省略第 1 段的长度值，则按表达式计算结果的固有长度输出。
    </p>
    <p>
     注解字段为可选字段，以#号开头，表示注释性文字，也可以作为注解名被引用。
    </p>
    <p>
     例如，上一小节示例中发送的内容中包含的单行表达式字段如下：
    </p>
    <pre><code class="hljs">\[2:reverse(calculate(0,-1,ALGO_CRC16_MODBUS))]</code></pre>
    <p>
     如果进一步省略输出长度，可简化为：
    </p>
    <pre><code class="hljs">\[reverse(calculate(0,-1,ALGO_CRC16_MODBUS))]</code></pre>
    <p>
     虽然调用了多个函数，多个参数，但是只有仅仅 1 条语句（1 个表达式），并有1 个返回值。
    </p>
    <p>
     <strong>
      2. BLOCK 代码段
     </strong>
    </p>
    <p>
     BLOCK 块级代码字段的形式为 \[{ script }]。
    </p>
    <p>
     块级代码可以包含任意多条语句，最终的计算结果通过 echo 或echob 函数产成，或者通过 return 语句返回。例如，上例中的单表达式字段，可以改写成以下的块级代码段：
    </p>
    <pre><code class="hljs">\[{
short crc16=calculate(0,-1,ALGO_CRC16_MODBUS);
crc16=reverse(crc16);
return crc16; //或者 echo(crc16);
}]</code></pre>
    <h3>
     四、脚本代码编写
    </h3>
    <p>
     串口调试工具的指令数据或指令模板可以嵌入类 C 语言语法的脚本代码，方便用户灵活地编写指令或模板，实现强大的高级指令发送或者自动应答功能。
    </p>
    <h4>
     1、运算符
    </h4>
    <p>
     自动应答规则引擎，支持各种逻辑运算及位操作符。一共有 34 种运算符，10 种运算类型：算术运算符（+、-、*、/、%）、关系运算符（&gt;、&gt;=、==、！=、&gt;、&lt;&lt;、==、!=、&lt;、&lt;=)、逻辑运算符(!、||、&amp;&amp;)、条件运算符、（？：）指针运算符（&amp;、*）、赋值运算符（=）、逗号运算符（，）、求字节运算符（sizeof）、强制类型转换运算符（（类型名））、其他（下标[]、分量、函数）；若按参与运算的对象个数，运算符可分为单目运算符（如！）、双目运算符（如+、-）和三目运算符（如？：）。
    </p>
    <p>
     指令模板中实际常用的运算符,如下表所示：
    </p>
    <p>
     <img alt="" height="752" src="https://i-blog.csdnimg.cn/blog_migrate/5a7070bd339c365b3d0d16c4f55f10f8.png" width="714"/>
    </p>
    <h4>
     2、运算表达式
    </h4>
    <p>
     所谓运算表达式，就是具有返回值的基于类 C 语言语法规则的计算表达式。例如：
    </p>
    <pre><code class="hljs">\[2: 2*(getuchar(0)+getuchar(1))]
\[（getuchar(#len)+1）: 2*(getuchar(0)+getuchar(1))]</code></pre>
    <p>
     在指令自动匹配应答过程中，运算表达式会实时动态地被最终计算值所替换。
    </p>
    <p>
     因此，运算表达式在形式上必须是一条具有返回值的脚本语句构成，而不允许分多条语句实现。如果一条语句无法实现，只能通过下一节所介绍的包含多条脚本语句的 BLOCK 代码段实现。BLOCK代码块的返回值通过 return 语句或者 echo/echob 函数实现传递。
    </p>
    <h4>
     3、BLOCK 代码块
    </h4>
    <p>
     自动应答规则的指令模板，可以要使用包含多条语句的 BLOCK 语法。一个BLOCK 的多条语句通过大括号对{}包括起来，多条语句之间用分号隔开，最终通过return 语句，或者echo函数返回 BLOCK 表达式的最终值。
    </p>
    <p>
     不同的是，return 返回值后就会终止当前BLOCK 后面的语句，而echo返回值之后会继续执行BLOCK后面的语句。如果一个BLOCK中执行了多次echo，则每次返回的数据会追加到之前返回数据的后面。如果没有执行到 echo 或return，则表示无返回数据；如果既有 echo 值，又有 return 值，则 echo 值会忽略而只取return 值。
    </p>
    <p>
     例如，下面这个 BLOCK 例子：
    </p>
    <pre><code class="hljs">\[{
    int num=getuchar(#num);
    if(num&gt;0){
        echo(0xF2F1);
        echo("\xF3\xF4%x",num);
    }
    else return 0;
}]</code></pre>
    <p>
     代码说明：若 if(num&gt;0)表达式成立，则调用两次 echo，两次数据叠加，最终返回16进制数据流 F1 F2 F3 F4 num；若 if(num&gt;0)表达式不成立，则返回数值0。
    </p>
    <p>
     作为扩展，应答规则中脚本代码支持 0x 开头的 16 进制立即数，如上面代码中的0xF2F1就是一个 16 进制立即数。
    </p>
    <h4>
     4、变量数据类型
    </h4>
    <p>
     自动应答规则引擎的内置脚本代码只能使用下表所示的基本数据类型，不支持用户自定义变量结构体。目前所支持的基本数据类型如下：
    </p>
    <p>
     <img alt="" height="229" src="https://i-blog.csdnimg.cn/blog_migrate/8609f8acc3bdb41eafa0a927d3b6a958.png" width="703"/>
    </p>
    <p>
     使用限制：仅支持一维数组和一维指针，暂不支持多维数组和多维指针；暂不支持64位数据类型。
    </p>
    <h4>
     5、变量定义及作用域
    </h4>
    <p>
     自动应答规则的脚本语言支持使用变量。根据变量的强弱类型可划分为，强类型变量和弱类型变量；根据变量作用域，则可分为局部变量及全局变量。
    </p>
    <p>
     <strong>
      1. 强类型变量与弱类型变量
     </strong>
    </p>
    <p>
     （1） 强类型变量。强类型变量类似于标准 c 语言的变量定义方式，必须先定义后使用。强类型变量的数据类型在变量定义时就被指定，不允许动态修改变量类型。强类型变量定义时，需要指定变量的数据类型以及变量名，并且允许在变量定义时初始化赋值。如：
    </p>
    <pre><code class="hljs">\[{ 
    int x,y; //定义两个强类型的整形变量
    int z=100; //定义一个初值为 100 的强类型整形变量
    char *str1="abc";//定义一个 null-teminated 字符串
    string str2="abc\x00\x01\x02";//定义一个标准字符串，允许包含0。
}]</code></pre>
    <p>
     （2） 弱类型变量。弱类型变量无需声明或定义，也不用指定变量的数据类型，可以直接使用。给弱类型变量赋值时，如果变量名不存在则会自动创建该变量。弱类型变量的数据类型总是等于最后一次赋值的数据类型。也就是说，弱类型变量的数据类型是可以被动态修改的。弱类型变量必须通过保留字 global 按数组索引的方式来使用，数组的下标为字符串形式的变量名。例如：
    </p>
    <pre><code class="hljs">\[ {
    global["x"]=100; //给弱类型全局变量 x 赋值整形数 100。
    global["x"]="abcdefg"; //给弱类型全局变量 x 赋值字符串。
}]</code></pre>
    <p>
     <strong>
      2. 局部变量与全局变量
     </strong>
    </p>
    <p>
     自动应答规则中的变量，如果是强类型方式定义的，只能作为局部变量，仅在当前指令模板的当前\[]段内有效。多个\[]内的同名局部变量互不影响。
    </p>
    <p>
     如果需要使用全局变量，就必须使用 global["name"]形式的弱类型变量。弱类型变量的作用域覆盖所有指令模板，在调试助手整个运行期间都常驻保留在内存中。
    </p>
    <p>
     弱类型全局变量一旦初始化赋值后，就可以省略 global 关键字，而直接通过变量名访问，就跟操作强类型变量一样。仅当需要修改变量数据类型时，才必须通过global 关键字来给变量赋值。
    </p>
    <h4>
     6、变量强制类型转换
    </h4>
    <p>
     跟标准的 C/C++语法规则一样，当操作数的类型不同，经常需要将操作数转化为所需要的类型，这个过程即为强制类型转换。
    </p>
    <p>
     <strong>
      1. 强制类型转换的形式
     </strong>
    </p>
    <p>
     变量强制类型转换具有两种形式：显式强制类型转换和隐式强制类型转换。下面就两种形式分别进行简单的描述。
    </p>
    <p>
     <strong>
      （1）显式强制类型转换
     </strong>
    </p>
    <p>
     显式强制类型转换很简单，格式为：
    </p>
    <pre><code class="hljs"> TYPE b = (TYPE) a;</code></pre>
    <p>
     其中，TYPE 为类型描述符，如 int，float 等。经强制类型转换运算符运算后，返回一个具有 TYPE 类型的数值，这种强制类型转换操作并不改变操作数本身，运算后操作数本身未改变，例如：
    </p>
    <pre><code class="hljs">int n=0xab65；
char a=（char）n;</code></pre>
    <p>
     上述强制类型转换的结果是将整型值 0xab65 的高端一个字节删掉，将低端一个字节的内容作为 char 型数值赋值给变量 a，而经过类型转换后 n 的值并未改变。
    </p>
    <p>
     <strong>
      （2）隐式强制类型转换
     </strong>
    </p>
    <p>
     隐式类型转换发生在赋值表达式和有返回值的函数调用表达式中。在赋值表达式中，如果赋值符左右两侧的操作数类型不同，则将赋值符右边操作数强制转换为赋值符左侧的类型数值后，赋值给赋值符左侧的变量。在函数调用时，如果 return 后面表达式的类型与函数返回值类型不同，则在返回值时将 return 后面表达式的数值强制转换为函数返回值类型后，再将值返回，如：
    </p>
    <pre><code class="hljs">int n;
double d=3.88;
n=d；//执行本句后，n 的值为 3，而 d 的值仍是 3.88</code></pre>
    <p>
     <strong>
      2. 强制类型转换在自动应答规则中的典型用途
     </strong>
    </p>
    <p>
     在指令应答模板中的模式应答数据段，如果不显式指定数据长度，则默认长度为其数据类型的固有长度。
    </p>
    <p>
     比如，有一个整形数据段,默认长度为 4 字节。如要要求只取 2 个字节。可以显示指定数据长度为 2，或者强制类型转换为 short 类型。例如，以下两个指令应答模板等价：
    </p>
    <pre><code class="hljs">\[2:getshort(0)*100] //#直接指定数据长度 2
\[(short)(getU16(0)*100)] //#强制类型转成 2 字节的short 数据类型</code></pre>
    <p>
     注：数值计算表达式的返回值,如果不做强制类型转化，则默认数据类型是32 位的int或者 float 类型，长度 4 字节。
    </p>
    <h4>
     7、语法大小写规则
    </h4>
    <p>
     调试助手内置脚本代码是不区分大小写的。但是为避免混乱，推荐大家始终坚持“大小写敏感”的代码书写规范，尽量保证函数名、变量名、常数名等大小写前后书写一致。
    </p>
    <h4>
     8、字段注解的定义及引用
    </h4>
    <p>
     不管是脚本指令还是指令模板（包括指令匹配模板及指令应答模板）都可以包含若干个模式段，每个模式段的一般形式都可以归结为：
    </p>
    <pre><code class="hljs">\[exp_len:exp_value#comment]</code></pre>
    <p>
     其中，exp_len 为字段数据长度、exp_value 为字段数据内容、#comment 为字段注解。
    </p>
    <p>
     注解的形式为#号开头加注解文字。注解字段的作用有两个：
    </p>
    <ol>
     <li>
      起注释作用，对目标字段作解释说明。
     </li>
     <li>
      给字段命名，经过命名的字段数据可以被同一个指令模板的其他模式段通过注解名引用。引用注解只能通过以下这几个用于读取指令数据段的系统函数: gets、getchar、getuchar、getshort、getushort、getint、getuint。除此之外，其他函数都不支持调用注解作为参数。
     </li>
    </ol>
    <p>
     下面举个简单例子作说明：
    </p>
    <ul>
     <li>
      指令匹配模板：REQ\[2 #command]；
     </li>
     <li>
      指令应答模板: ACK\[2:gets(#command,2)]；
     </li>
    </ul>
    <p>
     本例指令匹配模板中，\[2 #command]定长模糊匹配 2 个字节的command 数据；而在应答模板中需要复制这两个字节内容作为应答数据帧的一部分。在应答模板对应的模式应答段中，通过 gets(#comment,len)函数可以读取注解名对应的数据块，省略gets 的第二个参数表示读取整个目标字段。
    </p>
    <p>
     本例中，应答模板需要复制请求指令中整个command 段的数据，因此可以省略 gets 函数的第 2 个表示长度的参数。
    </p>
    <p>
     这样，此应答模板可以简化为：
    </p>
    <ul>
     <li>
      指令应答模板→简化: ACK\[2:gets(#command)]；
     </li>
    </ul>
    <p>
     如果模式应答段需要的数据长度跟 gets 返回的数据块长度一致，就可以省略模式应答段的长度参数，如下所示：
    </p>
    <ul>
     <li>
      指令应答模板→再简化: ACK\[gets(#command)]；
     </li>
    </ul>
    <h4>
     9、内建系统函数详解
    </h4>
    <p>
     自动应答规则的运算表达式，可以调用规则引擎内建的系统函数（函数名不区分大小写），目前支持的函数如下。
    </p>
    <p>
     <strong>
      （1）printf - 格式化输出到控制台
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">void printf(const char format, 可选参数...);</code></pre>
    <p>
     功能描述：按指定格式向标准输出设备（日志/接收窗口）输出调试打印信息。
    </p>
    <p>
     <strong>
      （2）sprintf - 格式化字符串
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int sprintf(char *buffer, char *format [,argument,...]);</code></pre>
    <p>
     功能描述: 把格式化的数据写入某个字符串缓冲区。如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。
    </p>
    <p>
     <strong>
      （3）strtoint - 字符串转整形数
     </strong>
    </p>
    <p>
     函数原型:
    </p>
    <pre><code class="hljs">int strtoint(const char *nptr);</code></pre>
    <p>
     函数别名:
    </p>
    <pre><code class="hljs">atoi</code></pre>
    <p>
     功能描述：strtoint 函数会扫描参数 nptr 字符串，跳过前面的空白字符（例如空格，tab 缩进）等，扫描直至下一个非数字字符或到达输入的结尾。如果nptr 不能转换成整数，那么将返回 0。
    </p>
    <p>
     <strong>
      （4）inttostr - 整形数转字符串
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">string inttostr(int n);</code></pre>
    <p>
     功能描述：将整形数 n 转换成字符串类型返回。
    </p>
    <p>
     <strong>
      （5）strcpy - 字符串拷贝
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">char *strcpy(char* dest, const char *src);</code></pre>
    <p>
     功能描述：把 src 指向的 null-terminated 字符串复制到 dest 指向的地址空间，并返回指向 dest 的指针。
    </p>
    <p>
     <strong>
      （6）strcat - 字符串拼接
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">char *strcat(char *dest,const char *src1, const char *src2，…);</code></pre>
    <p>
     功能描述：把若干个 NULL 结尾的源字符串（src1、src2、…）复制拼接到dest 所指向的字符串后面（删除 dest 原来末尾的“\0”）。要保证 dest 指向的字符串空间足够长，以容纳被复制进来的源字符串。最后返回指向 dest 的指针。
    </p>
    <p>
     <strong>
      （7）strcmp - 字符串比较（区分大小写）
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int strcmp(const char *s1,const char *s2);</code></pre>
    <p>
     功能描述：两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符(区分大小写)，或遇'\0'为止。当 s1s2 时，返回正数。
    </p>
    <p>
     <strong>
      （8）stricmp - 字符串的比较（不区分大小写）
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int stricmp(const char *s1,const char *s2);</code></pre>
    <p>
     功能描述：两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符(不区分大小写)，或遇'\0'为止。当 s1s2 时，返回正数。
    </p>
    <p>
     <strong>
      （9）strncpy - 限定长度的字符串拷贝
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">char *strncpy(char* dest, const char *src, int n);</code></pre>
    <p>
     功能描述：把 src 指向的 null-terminated 字符串复制到 dest 指向的地址空间，并返回指向 dest 的指针。如果源字符串实际长度大于参数 n，则最多复制n 个字节。
    </p>
    <p>
     <strong>
      （10）strncmp - 限定长度的字符串比较（区分大小写）
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int strncmp(const char *s1,const char *s2,int n);</code></pre>
    <p>
     功能描述：两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符（区分大小写），或遇'\0'，或比较字符数超过 n 为止。当s1s2 时，返回正数。
    </p>
    <p>
     <strong>
      （11）strnicmp - 限定长度的字符串比较（不区分大小写）
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int strnicmp(const char *s1,const char *s2,int n);</code></pre>
    <p>
     功能描述：两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符（不区分大小写），或遇'\0'，或比较字符数超过 n 为止。当s1s2 时，返回正数。
    </p>
    <p>
     <strong>
      （12）memcpy - 内存数据复制
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">void *memcpy(void *dest, void *src, int n);</code></pre>
    <p>
     功能描述：从存储区 src 复制 n 个字节到存储区 dest。返回指向目标存储区dest的指针。
    </p>
    <p>
     <strong>
      （13）memcmp - 内存数据比较
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int memcmp(const void *data1, const void *data2, int n);</code></pre>
    <p>
     功能描述：把存储区 data1 和存储区 data2 的前 n 个字节进行比较。如果返回值==0，则表示 data1 等于 data2；如果返回值 &lt; 0，则表示 data1 小于data2;如果返回值&gt;0，则表示 data2 小于 data1。
    </p>
    <p>
     <strong>
      （14）string - 标准字符串构造方法
     </strong>
    </p>
    <p>
     函数原型 1:
    </p>
    <pre><code class="hljs">string string(int len);</code></pre>
    <p>
     功能：构造并返回一个预留空间长度为 len 的空字符串。
    </p>
    <p>
     函数原型 2：
    </p>
    <pre><code class="hljs">string string(void *str, int len);</code></pre>
    <p>
     功能：构造一个长度为 len 的空字符串，并用 str 指向的数据进行初始化。
    </p>
    <p>
     函数原型 3：
    </p>
    <pre><code class="hljs">string string(string1,string2, …);</code></pre>
    <p>
     功能：将若干个 string 或 char *类型的字符串依次首尾连接起来，构造出一个新字符串返回。
    </p>
    <p>
     <strong>
      （15）unix_timestamp - 获取 32 位 unix 时间戳
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">unsigned int unix_timestamp(void);</code></pre>
    <p>
     入口参数：无。
    </p>
    <p>
     返回值：返回 32 位无符号整数。
    </p>
    <p>
     功能描述：生成 32 位 unix 时间戳，即从 1970-1-1 00:00:00 到当前的秒数。
    </p>
    <p>
     <strong>
      （16）genAutoID - 生成 32 位自增流水 ID
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">unsigned int genAutoID(void);</code></pre>
    <p>
     入口参数：无。
    </p>
    <p>
     返回值：返回 32 位无符号整数。 功能描述：初始值为 1，每调用一次，返回值自动加 1。
    </p>
    <p>
     <strong>
      （17）random - 生成随机数/随机选择集合数据
     </strong>
    </p>
    <p>
     函数原型 1：
    </p>
    <pre><code class="hljs">int random (int maximum);</code></pre>
    <p>
     功能描述：生成一个绝对值小于入参 maximum 的 32 位随机数。如果不指定上限（省略maximum 参数），则随机生成 1 个 32 位随机数。
    </p>
    <p>
     函数原型 2：
    </p>
    <pre><code class="hljs">var random (var1,var2,…);</code></pre>
    <p>
     入口参数：二个以上任意类型数据
    </p>
    <p>
     返回值: 随机返回入口参数列表中的一个。
    </p>
    <p>
     功能描述：随机选择集合数据，即从多个数据中随机选择一个数据返回。
    </p>
    <p>
     例如： random(100,0x255,123.456, 'x',"abcdefg")，实现从入口参数列表中随机返回一个数据，入口参数的数据类型可以自由混合，返回值类型就是随机选择参数的实际数据类型。
    </p>
    <p>
     <strong>
      （18）reverse 逆转数据的字节顺序
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">var reverse(data, maxLen);</code></pre>
    <p>
     入口参数：参数 data 为待逆序的源数据，可以是整形（短整形或长整形）或浮点等基本数据类型，也可以是字节型数组、字符串或数据指针类型；可选参数maxLen 用于指定数据转换的最大长度，如果省略该参数则转换长度取源数据 data 的默认长度值，如int 类型数据默认长度 4 字节，short 类型默认 2 字节,字符串则自动获取字符串自身长度，等等。
    </p>
    <p>
     功能描述：将源数据 data 的字节顺序高低逆转后返回逆序重排的数据。如果源数据类型是整形（短整形或长整形）或浮点等基本数据类型，则不会修改源数据的字节顺序，而是返回逆序后的数据；如果源数据类型是字符串、数组或指针类型，则源数据也会发生字序逆转，并返回逆序后的数据引用。
    </p>
    <p>
     （19）gets - 从当前指令数据中复制数据段
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">var gets(offset|#comment,len);</code></pre>
    <p>
     入口参数: offset|#comment 为偏移地址或者字段注解名。如果是通过偏移地址复制数据，则需要明确这个偏移地址是相对当前模板对应的指令数据；如果通过字段注解名复制数据，则系统会优先查找源指令帧对应的注解字段，如果不存在则再查找应答指令帧对应注解字段，并且引用的目标注解名必须确保在当前模板中调用 gets 函数前已经定义过。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址,或者模板字段注解名对应的指令数据段）处，拷贝指定长度为 len 的数据块；长度参数 len 可以省略，如果使用偏移地址拷贝，则省略长度参数时将拷贝数据直至指令帧末尾；如果使用字段名注解，则省略长度参数时表示拷贝注解名对应的整个字段的数据。
    </p>
    <p>
     例如，以下这条应答规则：
    </p>
    <p>
     指令匹配模板：
    </p>
    <pre><code class="hljs">ABCD\[2#command]</code></pre>
    <p>
     指令应答模板：
    </p>
    <pre><code class="hljs">ACK_[4:gets(0)]_\[2:gets(#command)]</code></pre>
    <p>
     假定，自动应答规则引擎收到字符串数据 ABCDFF，则指令匹配成功，其中定长模糊匹配\[2#command]所匹配的内容是 FF。根据指令应答模板，生成应答数据为: ACK_ABCD_FF。
    </p>
    <p>
     其中，\[4:gets(0)]表示从当前收到的数据报文（ABCDFF）的偏移地址0 开始拷贝4 个字节数据:ABCD；\[2:gets(#command)]表示从当前收到的数据报文（ABCDFF）的注解#command所匹配对应的偏移地址处拷贝 2 个字节数据:FF。
    </p>
    <p>
     <strong>
      （20）getchar - 从当前指令数据中复制一个字节有符号数
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">char getchar(offset|#comment);</code></pre>
    <p>
     函数别名：getS8
    </p>
    <p>
     入口参数: 指令帧偏移地址或者模板字段注解名(参考前文 gets 函数的参数说明)。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址,或者模板字段注解名对应的指令数据段处）拷贝 1 个字节的有符号数据。
    </p>
    <p>
     <strong>
      （21）getuchar - 从当前指令数据中复制一个字节无符号数
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">unsigned char getuchar(offset|#comment);</code></pre>
    <p>
     函数别名：getU8、getByte
    </p>
    <p>
     入口参数: 指令帧偏移地址或者模板字段注解名(参考前文 gets 函数的参数说明)。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址,或者模板字段注解名对应的指令数据段处）拷贝 1 个字节的无符号数据。
    </p>
    <p>
     <strong>
      （22）getshort - 从当前指令数据中复制 2 个字节有符号整数
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">short getshort(offset|#comment,isBigEndian);</code></pre>
    <p>
     函数别名：getS16
    </p>
    <p>
     入口参数：offset|#comment 为偏移地址或者字段注解名；isBigEndian 为可选参数，布尔型数据变量，表示指定读取数据的字节顺序是高字节在前还是在后。为true 表示高字节在前否则低字节在前。如果省略 isBigEndian 参数，表示取全局的字节顺序设置（自动应答设置窗口面板右下方的“网络字序”复选框，用于设置全局的默认字节顺序，勾选表示全局字序为 BigEndian，否则为 LittleEndian）。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址处,或者模板字段注解名对应的指令数据段）拷贝 2 个字节的有符号整数。
    </p>
    <p>
     <strong>
      （23）getushort - 从当前指令数据中复制 2 个字节无符号整数
     </strong>
    </p>
    <p>
     函数原型:
    </p>
    <pre><code class="hljs">unsigned short getushort(offset|#comment, isBigEndian);</code></pre>
    <p>
     函数别名：getU16
    </p>
    <p>
     入口参数：offset|#comment 为偏移地址或者字段注解名；isBigEndian 为可选参数,布尔型数据变量，表示指定读取数据的字节顺序是高字节在前还是在后。为true 表示高字节在前否则低字节在前。如果省略 isBigEndian 参数，表示取全局的字节顺序设置。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址,或者模板字段注解名对应的指令数据段处）拷贝 2 个字节的无符号整数。
    </p>
    <p>
     <strong>
      （24）getint - 从当前指令数据中复制 4 个字节有符号整数
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">short getint(offset|#comment, isBigEndian);</code></pre>
    <p>
     函数别名：getS32
    </p>
    <p>
     入口参数：offset|#comment 为偏移地址或者字段注解名；isBigEndian 为可选参数,布尔型数据变量，表示指定读取数据的字节顺序是高字节在前还是在后。为true 表示高字节在前否则低字节在前。如果省略 isBigEndian 参数，表示取全局的字节顺序设置。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址,或者模板字段注解名对应的指令数据段处）拷贝 4 个字节的有符号整数。
    </p>
    <p>
     <strong>
      （25）getuint - 从当前指令数据中复制 4 个字节无符号整数
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">unsigned short getuint(offset|#comment, isBigEndian);</code></pre>
    <p>
     函数别名：getU32
    </p>
    <p>
     入口参数：offset|#comment 为偏移地址或者字段注解名；isBigEndian 为可选参数,布尔型数据变量，表示指定读取数据的字节顺序是高字节在前还是在后。为true 表示高字节在前否则低字节在前。如果省略 isBigEndian 参数，表示取全局的字节顺序设置。
    </p>
    <p>
     功能描述：从指定位置（当前指令帧 offset 偏移地址,或者模板字段注解名对应的指令数据段处）拷贝 4 个字节的无符号整数。
    </p>
    <p>
     <strong>
      （26）calculate - 计算校验位
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">var calculate(offset, len, algorithm);</code></pre>
    <p>
     入口参数:参数 offset 为待校验数据偏移地址；len 为待校验数据长度，如果len 为-1，表示数据长度截止到当前 calculate 函数调用位置的前一个字节数据,len 为-2 则表示数据长度从当前位置往前推 2 个字节，以此类推；参数 algorithm 为选择的算法。
    </p>
    <p>
     功能描述：计算数据校验值。函数返回值的数据类型根据具体的校验算法而定。如果校验值是单字节的，则返回的数据类型是 unsigned char，如果校验值是双字节的，则返回值的数据类型是 unsigned short;如果校验值是四字节的，则返回值数据类型是unsigned int。
    </p>
    <p>
     目前 calculate 支持的算法（参数 algorithm 可取常量值）列表如下：
    </p>
    <ul>
     <li>
      ALGO_ACC //1 字节累加和
     </li>
     <li>
      ALGO_LRC //1 字节累加和再取负
     </li>
     <li>
      ALGO_XOR //1 字节异或校验
     </li>
     <li>
      ALGO_CRC16_MODBUS //2 字节 MODUBUS CRC16 校验
     </li>
     <li>
      ALGO_CRC8
     </li>
     <li>
      ALGO_CRC8_ITU
     </li>
     <li>
      ALGO_CRC8_ROHC
     </li>
     <li>
      ALGO_CRC8_MAXIM
     </li>
     <li>
      ALGO_CRC8_WCDMA
     </li>
     <li>
      ALGO_CRC8_CDMA2000
     </li>
     <li>
      ALGO_CRC16_CCITT
     </li>
     <li>
      ALGO_CRC16_CCITT_FALSE
     </li>
     <li>
      ALGO_CRC16_XMODEM
     </li>
     <li>
      ALGO_CRC16_X25
     </li>
     <li>
      ALGO_CRC16_IBM
     </li>
     <li>
      ALGO_CRC16_USB
     </li>
     <li>
      ALGO_CRC16_MAXIM
     </li>
     <li>
      ALGO_CRC16_DNP
     </li>
     <li>
      ALGO_CRC32
     </li>
     <li>
      ALGO_CRC32_BZIP2
     </li>
     <li>
      ALGO_CRC32_MPEG2
     </li>
     <li>
      ALGO_CRC32_POSIX
     </li>
     <li>
      ALGO_CRC32_JAMCRC
     </li>
    </ul>
    <p>
     <strong>
      （27）echo –实现 BLOCK 代码块的流式返回值
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">int echo (const char *format,…);</code></pre>
    <p>
     功能描述：格式化输出的文本数据作为 BLOCK 代码块的最终返回值，而echo 函数本身将返回所生成文本数据的长度。
    </p>
    <p>
     例如：
    </p>
    <pre><code class="hljs">\[{ echo("hello\r\n"); echo("ok\r\n") }]
\[{ echo("ERR=%d",errno); }]
\[{ echo (gets(#Annotation)); }]</code></pre>
    <p>
     注：echo 的第二个参数可以省略。当只有 1 个参数时，不做格式化处理，直接输出第一个参数指向的数据。形式为\[{…}]的 BLOCK 代码块，可以通过 return 语句或者echo 函数来实现整个 BLOCK 的返回值。不同的是 return 语句执行后就会立即退出当前BLOCK，不会再执行当前 BLOCK 的后续代码；而 echo 语句则不会退出 BLOCK，后续如果有多个echo 函数输出数据，这些数据会流式拼接在一起作为当前 BLOCK 的返回值。
    </p>
    <p>
     <strong>
      （28）echob – 实现 BLOCK 代码块的流式返值
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">void echob (data,length);</code></pre>
    <p>
     入口参数：data 为输出的数据内容（可以是整形数或字符串或数组或数据指针等）；length 为限定输出数据的字节长度。
    </p>
    <p>
     功能描述：输出二进制数据作为 BLOCK 代码块的返回值。同一个BLOCK 内的多个echo或 echob 函数的输出会按流式数据的方式依次追加合并。
    </p>
    <p>
     例如：
    </p>
    <pre><code class="hljs">\[{ echob(gets(0),100)); }]
\[{ echob(gets(#Annotation)); }]
\[{ char str[3]="\x01\x02\x03"; echob(str,3); }]</code></pre>
    <p>
     注， echob 的第二个参数可以省略。当只有 1 个参数时，echo 和echob 这两个函数等价，按输入数据的固有长度输出。
    </p>
    <p>
     <strong>
      （29）delay – 延迟操作
     </strong>
    </p>
    <p>
     函数原型：
    </p>
    <pre><code class="hljs">void delay(ms);</code></pre>
    <p>
     入口参数: ms 为延迟的毫秒数。
    </p>
    <p>
     功能描述：这个函数主要用于应答模板，实现延迟应答。例如以下应答模板：
    </p>
    <pre><code class="hljs">\[{delay(1000); echob(gets(0),100));}]
\[{delay(500);}]OK\r\n</code></pre>
    <p>
     通过在应答模板头部插入 delay 函数，实现应答数据的延迟输出(发送)。
    </p>
    <h3>
     五、UartAssist 使用进阶
    </h3>
    <p>
     工具面板窗口提供通信调试的进阶操作选项，包括快捷指令、批量发送、自动应答、历史发送、校验计算器等。
    </p>
    <h4>
     1、快捷定义
    </h4>
    <p>
     串口调试助手在跟目标设备或串口应用服务进行通信调试时，通常需要根据实际应用协议，发送一些交互指令或数据。当指令比较多时，现场输入这些指令数据肯定会麻烦且低效。针对这个问题，串口调试助手提供了指令预定义功能，也就是工具面板中的【快捷定义】(最新版本已经改名为快捷指令）。
    </p>
    <p>
     该功能支持按十六进制或 ASCII 码字符串的方式进行指令预定义，可以定义指令的名称以及对应的数据内容，并可定义发送热键（快捷键）。预定义的指令可以直接导出保存为文件，也可以随时从外部文件导入。默认情况下，预定义指令会自动以配置文件的形式保存在当前应用程序目录下，在软件启动时会自动载入。
    </p>
    <p>
     如下图所示：
    </p>
    <p>
     <img alt="" height="479" src="https://i-blog.csdnimg.cn/blog_migrate/69f2f75a87eaa7abf9fea36024494819.png" width="707"/>
    </p>
    <p>
     如上图所示，每条预定义指令都包含名称、数据、快捷键三个部分。指令名称相当于指令备注，对指令数据起到描述作用；每条指令都可以单独设置快捷键，通过键盘按下快捷键可以直接发送对应的指令数据。每条指令，不管是否定义快捷键，都可以直接通过点击快捷键栏中的按钮，或者通过回车键发送选中的指令数据。
    </p>
    <p>
     新建预定义指令：
    </p>
    <p>
     <img alt="" height="461" src="https://i-blog.csdnimg.cn/blog_migrate/2d4b0dda97496a2c078632a80afe052e.png" width="671"/>
    </p>
    <p>
     通过右键菜单可以对预定义指令进行增、删、改、排序、导入、导出等操作。以新建预定义指令为例，右键点击【快捷定义】窗口的空白处，弹出右键菜单，选择【新建】菜单项，就可以新建预定义指令。
    </p>
    <p>
     新建指令时，根据实际应用场景，选择字符串值还是十六进制值，然后在快捷定义窗口完成指令名称及数据内容的输入。
    </p>
    <p>
     编辑预定义指令：
    </p>
    <p>
     <img alt="" height="532" src="https://i-blog.csdnimg.cn/blog_migrate/b61fa890860738d80d085b3ea14d58c0.png" width="720"/>
    </p>
    <p>
     如果要编辑已经输入的预定义指令，可以直接右键点击目标指令，然后在弹出的右键菜单中选择对目标指令进行编辑，包括修改数据内容、数据类型（ASCII/HEX）、设置快捷键、重命名、删除等操作。
    </p>
    <p>
     例如上图，是对一条指令进行数据内容的编辑，编辑完点击【确定】按钮关闭编辑窗口，编辑修改过的内容会在软件退出时自动保存。
    </p>
    <p>
     使用十六进制专用编辑器修改指令：
    </p>
    <p>
     <img alt="" height="525" src="https://i-blog.csdnimg.cn/blog_migrate/14d794dcfa9259e20e7eb3778003a999.png" width="695"/>
    </p>
    <p>
     如上图所示，选中目标指令后，可以通过右键菜单选择【修改十六进制数据】，使用十六进制专用编辑器，以十六进制与ASCII码相互对照的方式对数据指令进行编辑。
    </p>
    <h4>
     2、批量发送
    </h4>
    <p>
     批量发送功能用于控制多条预定义数据指令按照一定的顺序和不同的延迟间隔进行发送。【批量发送】功能位于工具面板窗口，类似【快捷定义】功能，需要先进行预定义指令的编辑输入。每条指令除了可以定义指令数据和文字备注，还定义有延迟时间，即上一条指令发送完后，延迟多长时间发送当前这条指令。
    </p>
    <p>
     批量发送~指令列表：
    </p>
    <p>
     <img alt="" height="471" src="https://i-blog.csdnimg.cn/blog_migrate/456eeac6ed5487d6d48e646810a60e89.png" width="683"/>
    </p>
    <p>
     如上图所示，批量发送窗口中，每条预定义指令包含编号、延迟时间、数据、及备注四个部分。指令编号顺序决定了批量发送的指令顺序，并且只有前面复选框被勾选的指令才会被批量发送；延迟是指发送前延迟，也就是当前指令与前一条发送的指令之间的发送延迟时间，单位毫秒；指令备注实际上类似于【快捷定义】中的指令名称，用于对指令起注解作用，点击备注栏中的按钮可以直接发送对应的指令数据。
    </p>
    <p>
     勾选批量发送窗口右下角的【开始发送】选项，调试助手就会依次发送指令列表中勾选的指令，在发送每条指令前都会执行设置的延迟等待时间。发送完所有的指令，自动停止发送，并自动取消【开始发送】复选框。如果勾选了【循环模式】选项，批量发送会周而复始的进行，直至手动取消勾选【循环模式】或者【开始发送】选项。
    </p>
    <p>
     通过右键菜单，可以对批量发送的指令进行增、删、改、排序、导入、导出等操作。以新建批量指令为例，右键点击【批量发送】窗口的空白处，弹出右键菜单，选择【新建】菜单项，再根据实际应用场景，选择字符串值还是十六进制值，最后在弹出的编辑窗口完成指令内容的输入，如下图所示。
    </p>
    <p>
     <img alt="" height="558" src="https://i-blog.csdnimg.cn/blog_migrate/e2b6c18769de5e5f023dc15f797d26e6.png" width="695"/>
    </p>
    <p>
     编辑完内容后，点击保存按钮，如果要再次编辑这条指令，可以直接在指令列表中双击目标指令，或者右键点击目标指令，然后在弹出的右键菜单中点击【修改】菜单项，即会弹出目标指令的编辑窗口。
    </p>
    <h4>
     3、自动应答
    </h4>
    <p>
     自动应答功能，用于实时对调试助手接收到的数据指令进行匹配识别，并自动按用户预定义规则发送相应的应答指令。
    </p>
    <p>
     用户只须事先设计好应答规则，然后调试助手内部集成的规则引擎会自动对接收到的数据进行指令规则匹配及应答数据的发送。如果需要同时支持多条指令的自动应答，只要相应地建立多条自动应答规则。
    </p>
    <h4>
     4、历史发送
    </h4>
    <p>
     工具面板中的历史发送窗口，记录着用户发送的历史指令数据。用户可随时调出历史发送窗口进行查看，如下图所示。
    </p>
    <p>
     历史发送记录：
    </p>
    <p>
     <img alt="" height="591" src="https://i-blog.csdnimg.cn/blog_migrate/80f801559c2d4346533a2ddce49253f6.png" width="699"/>
    </p>
    <p>
     每一条历史发送记录的组成都分数据内容及记录时间两部分，其中记录时间就是该数据的初次发送的时间，该时间以按钮的形式显示，点击该按钮可以直接重发这条指令。但重发的指令不会历史发送窗口增加新的发送记录，除非删除存在的历史记录。实际上，历史发送窗口，只保存主窗口中通过发送按钮发送的数据，而通过快捷定义、批量发送、历史发送这些方式发送的数据是不会保存到历史发送记录中去的。
    </p>
    <h4>
     5、校验计算器
    </h4>
    <p>
     串口调试助手支持发送数据时自动添加校验码，也可以自行通过调试助手提供的校验计算器来进行数据的校验码计算，然后手动添加到发送数据中。
    </p>
    <p>
     校验位计算器：
    </p>
    <p>
     <img alt="" height="458" src="https://i-blog.csdnimg.cn/blog_migrate/1b85a07133e44c602572ba76c1bab463.png" width="472"/>
    </p>
    <p>
     校验位计算器从工具面板中打开，如上图所示。
    </p>
    <p>
     检验的数据类型可以选择ASCII 码或者 HEX 码，但数据类型必须跟实际输入的数据内容一致；可供选择的主要校验算法如下：
    </p>
    <ul>
     <li>
      CHECKSUM-8：8 位（1 字节）累加和校验码，校验码为校验数据所有字节之和；
     </li>
     <li>
      CHECKSUM-8N/LRC：纵向冗余校验（LRC, Longitudinal Redundancy Check）,校验值为校验数据所有字节之和的负数；
     </li>
     <li>
      XOR-8/BCC：信息组校验（BCC, Block Check Character)，校验值为校验数据所有字节的异或值；
     </li>
     <li>
      CRC-8：8 位 CRC 校验，多项式 x 8 + x 2 + x + 1（0x07），初始值0x00，输入数据不反转，输出数据不反转，输出结果异或值 0x00；
     </li>
     <li>
      CRC-16/MODBUS：适用于 Modbus 的 16 位 CRC 校验码，多项式x 16 + x 15 + x 2 + 1（0x8005），初始值0xFFFF，输入数据反转，输出数据反转，输出结果异或值0x0000；
     </li>
     <li>
      CRC-16/CCITT：多项式 x 16+x 12+x 5+1（0x1021），初始值 0x0000，输入数据反转，输出数据反转，结果与 0x0000 异或；
     </li>
     <li>
      CRC-16/CCITT-FALSE：多项式 x 16+x 12+x 5+1（0x1021），初始值0xFFFF，输入数据不反转，输出数据不反转，结果与 0x0000 异或；
     </li>
     <li>
      CRC-16/XMODEM：多项式 x 16+x 12+x 5+1（0x1021），初始值0x0000，输入数据不反转，输出数据不反转，结果与 0x0000 异或；
     </li>
     <li>
      CRC-16/X25：多项式 x 16+x 12+x 5+1（0x1021），初始值 0xFFFF，输入数据反转，输出数据反转，结果与 0xFFFF 异或；
     </li>
     <li>
      CRC-16/IBM：多项式 x 16+x 15+x 2+1（0x8005），初始值 0x0000，输入数据反转，输出数据反转，结果与 0x0000 异或；
     </li>
     <li>
      CRC-16/MAXIM：多项式 x 16+x 15+x 2+1（0x8005），初始值 0x0000，输入数据反转，输出数据反转，结果与 0xFFFF 异或；
     </li>
     <li>
      CRC-16/USB：多项式 x 16+x 15+x 2+1（0x8005），初始值 0xFFFF，输入数据反转，输出数据反转，结果与 0xFFFF 异或；
     </li>
     <li>
      CRC-32：多项式 x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 +x5 + x4 + x2 + x + 1（0x04C11DB7），初始值 0xFFFFFFFF，输入数据反转，输出数据反转，结果与 0xFFFFFFFF 异或；
     </li>
     <li>
      CRC-32/BZIP2：多项式 x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 +x7 + x5 + x4 + x2 + x + 1（0x04C11DB7），初始值 0xFFFFFFFF，输入数据不反转，输出数据不反转，结果与 0xFFFFFFFF 异或；
     </li>
     <li>
      CRC-32/MPEG-2：多项式 x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8+ x7 + x5 + x4 + x2 + x + 1（0x04C11DB7），初始值 0xFFFFFFFF，输入数据不反转，输出数据不反转，结果与 0x00000000 异或；
     </li>
     <li>
      MD5：16 字节 MD5 校验码；
     </li>
     <li>
      FIXED HEX BYTES：固定数据校验码，校验码为任意多字节常数；
     </li>
    </ul>
    <p>
     CRC 校验算法，支持 CRC8、CRC16、CRC32 三种宽度的校验算法，并可自定义修改校验参数，如多项式、初始值、输入数据翻转、输出数据翻转、输出结果异或值。通过修改CRC参数，可以实现任意的 CRC 校验算法。
    </p>
    <h4>
     6、ASCII码对照表
    </h4>
    <p>
     ASCII (American Standard Code for Information Interchange)是基于拉丁字母的一套电脑编码系统，它主要用于显示现代英语和其他西欧语言。到目前为止共定义了128 个字符,其中包含 33 个控制字符（具有某些特殊功能但是无法显示的字符，也就是非打印字符）和 95 个可显示字符（可打印字符）。
    </p>
    <p>
     <img alt="" height="517" src="https://i-blog.csdnimg.cn/blog_migrate/f88a992901328d8e842a070cf2518dd2.png" width="583"/>
    </p>
    <p>
     调试助手提供 ASCII 对照表，如上图所示。可帮助用户在通信调试时对收发数据中字符数据解析处理。比如，接收到 16 进制数据后，若需要手动转换成ASCII 码字符串时，可以借助 ASCII 码表逐个根据十六进制值查找目标字符；再比如，发送包含非打印字符的ASCII字符串时，可以通过转义符的方式，即反斜杠加小写字母 x 再加两位16 进制数据的表示方法，而非打印字符对应的 16 进制值可以通过 ASCII 码表来查找。
    </p>
    <h4>
     7、命令行启动参数
    </h4>
    <p>
     调试助手可以通过命令行参数，按给定的参数选项启动，还可以直接通过命令行发送串口数据。设置命令行参数方法如下：
    </p>
    <pre><code class="hljs">uartassist.exe [-p 串口名] [-b 波特率] [-c 校验位] [-w 数据位] [-s 停止位] [-x][-d 数据内容]</code></pre>
    <p>
     参数说明：
    </p>
    <ul>
     <li>
      串口名：如 COM1、COM2、COM3...
     </li>
     <li>
      波特率：填写实际使用的波特率，如 9600、19200、115200...
     </li>
     <li>
      校验位：取 NONE、ODD、EVEN、MARK、SPACE
     </li>
     <li>
      数据位：取 5、6、7、8
     </li>
     <li>
      停止位：取 1、1.5、2
     </li>
     <li>
      数据内容：-d 参数后跟待发送的数据内容，一定要包含在双引号内，若加参数-x 则表示按 HEX 格式发送，否则按 ASCII 码格式发送。
     </li>
    </ul>
    <p>
     例 1：
    </p>
    <pre><code class="hljs">uartassit.exe -p COM6 -b 115200</code></pre>
    <p>
     命令行启动串口调试助手，并打开串口 COM6，波特率设置为 115200，其他未设置的参数取默认值。注意，命令行方式启动串口调试助手时，如果指定了串口号，就会自动尝试打开目标串口。
    </p>
    <p>
     例 2：
    </p>
    <pre><code class="hljs">uartassit.exe -p COM6 -b 115200 -c NONE -w 8 -s 1 -d "hello" -q</code></pre>
    <p>
     命令行启动调试助手发送字符串数据，执行完毕后自动关闭调试助手软件。参数-q 表示执行完退出调试助手进程。
    </p>
    <p>
     注意：通过串口调试助手命令行参数发送数据时，由于只能携带文本字符串参数，不能直接发送二进制数据，但是可以通过转义字符方式实现二进制数据的发送。比如发送一条带回车换行符结尾的 AT 指令，对应数据 -d "AT\r\n"
    </p>
    <ul>
     <li>
      等价于 -d "AT\x0D\x0A"
     </li>
     <li>
      等价于 -d "\x41\x54\x0D\x0A"
     </li>
     <li>
      等价于 -d "\x[41 54 0D 0A]"
     </li>
     <li>
      等价于 -d "\x[41540D0A]"
     </li>
     <li>
      等价于 -x -d "41540D0A"
     </li>
     <li>
      等价于 -x -d "41 54 0D 0A"
     </li>
    </ul>
    <p>
     注意，使用-x 参数之后,-d 参数后面可以直接跟十六进制数据，不用转义字符。
    </p>
    <p>
     实际执行命令:
    </p>
    <pre><code class="hljs">uartassit.exe -p COM6 -b 115200 -q -d "AT\r\n"</code></pre>
    <p>
     等价于：
    </p>
    <pre><code class="hljs">uartassit.exe -p COM6 -b 115200 -q -x -d "41540D0A"</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     链接：
     <a href="https://pan.baidu.com/s/13Pievs8rPOpd4VcKpqw9YA?_at_=1684415493047" rel="nofollow" title="百度网盘 请输入提取码">
      百度网盘 请输入提取码
     </a>
    </p>
    <p>
     提取码：dm7u
    </p>
   </div>
  </div>
 </article>
</div>


