---
layout: post
title: 八数码问题基于状态空间法的知识表示与状态搜索无信息搜索BFSDFS-启发式搜索A
date: 2021-04-07 22:22:28 +0800
categories: [人工智能导论]
tags: [算法,深度优先,宽度优先]
image:
    path: https://img-blog.csdnimg.cn/20210324193420479.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzNjA4Mg&#61;&#61;,size_16,color_FFFFFF,t_70#pic_center
    alt: 八数码问题基于状态空间法的知识表示与状态搜索无信息搜索BFSDFS-启发式搜索A
artid: 115264396
render_with_liquid: false
---
<p class="artid" style="display:none">$url</p>
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【八数码问题】基于状态空间法的知识表示与状态搜索:无信息搜索(BFS/DFS) &amp; 启发式搜索(A*)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
     </h4>
     <ul>
      <li>
       <a href="#_6" rel="nofollow">
        前言
       </a>
      </li>
      <li>
       <a href="#_14" rel="nofollow">
        一、问题引入
       </a>
      </li>
      <li>
       <a href="#_22" rel="nofollow">
        二、状态空间法
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1__23" rel="nofollow">
          1. 知识及其表示
         </a>
        </li>
        <li>
         <a href="#2__33" rel="nofollow">
          2. 状态空间法定义
         </a>
        </li>
        <li>
         <a href="#3__43" rel="nofollow">
          3. 问题求解
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_68" rel="nofollow">
        三、基于状态空间搜索法解决八数码问题
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1__69" rel="nofollow">
          1. 八数码问题的知识表示
         </a>
        </li>
        <li>
         <a href="#2___126" rel="nofollow">
          2. 状态空间图搜索
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1__131" rel="nofollow">
            1. 无信息搜索
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#BreadthFirst_Search_139" rel="nofollow">
              广度优先搜索(Breadth-First Search)
             </a>
            </li>
            <li>
             <a href="#DepthFirst_Search_343" rel="nofollow">
              深度优先搜索(Depth-First Search)
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#2__519" rel="nofollow">
            2. 启发式搜索
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#DijkstraUCS_527" rel="nofollow">
              Dijkstra（UCS）算法
             </a>
            </li>
            <li>
             <a href="#A_532" rel="nofollow">
              A*算法
             </a>
            </li>
            <li>
             <a href="#hn_551" rel="nofollow">
              八数码问题构造启发函数$h(n)$实例
             </a>
            </li>
            <li>
             <ul>
              <li>
               <a href="#_552" rel="nofollow">
                欧式距离法
               </a>
              </li>
              <li>
               <a href="#_559" rel="nofollow">
                曼哈顿距离法
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_837" rel="nofollow">
        总结
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <hr color="#000000" size='1"'/>
    <h2>
     <a id="_6">
     </a>
     前言
    </h2>
    <p>
     搜索是人工智能里面研究的一个核心问题，个人认为机器学习本质也可以理解为一种搜索。类似强化学习,对抗学习等，都是用了一些值函数近似的方法，其本质都是在搜索参数，也可以理解为一种状态搜索。近些年来也有非常多学术研究者慢慢开始将两者融汇贯通，比如像Goog的planet，Muzero以及将熵用于蒙特卡洛树搜索中平衡探索和利用的关系等。
    </p>
    <p>
     当然笔者也是初学者，这里给出两篇文章探讨：
     <br/>
     <a href="https://www.zhihu.com/question/52256170" rel="nofollow">
      机器学习的过程可以理解为一种问题空间搜索的过程吗？
     </a>
     <br/>
     <a href="https://blog.csdn.net/uwr44uouqcnsuqb60zk2/article/details/79049212">
      将应用机器学习转化为求解搜索问题
     </a>
    </p>
    <hr color="#000000" size='1"'/>
    <h2>
     <a id="_14">
     </a>
     一、问题引入
    </h2>
    <p>
     我们以
     <a href="https://www.luogu.com.cn/problem/P1379" rel="nofollow">
      《八数码难题》
     </a>
     为例,题本身不是很难,但我们可以借助它来理解AI中的搜索策略,尝试从状态空间搜索的角度去理解它的解决方法。
    </p>
    <blockquote>
     <p>
      <strong>
       问题描述
      </strong>
      ：在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种
      <s>
       最少步骤的
      </s>
      移动方法，实现从初始布局到目标布局的转变。
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/31f16975564c8b260590bdfd1eaf604e.png#pic_center"/>
    </p>
    <hr color="#000000" size='1"'/>
    <h2>
     <a id="_22">
     </a>
     二、状态空间法
    </h2>
    <h3>
     <a id="1__23">
     </a>
     1. 知识及其表示
    </h3>
    <p>
     <strong>
      知识
     </strong>
     ：知识是人们在
     <strong>
      长期的
     </strong>
     生活和社会实践中，在
     <strong>
      科学研究及实验
     </strong>
     中累积起来的
     <strong>
      对客观世界
     </strong>
     的
     <strong>
      认识与经验
     </strong>
     。
    </p>
    <blockquote>
     <p>
      <strong>
       注意
      </strong>
      ：知识具有
      <strong>
       相对正确性、不确定性和不完整性
      </strong>
      ，它在一定的条件和环境下正确。知识一定是
      <strong>
       可表示的
      </strong>
      ，类似于艺术家的手感绘画方式、诗人的即兴作词方式，它大概率是不能用机器语言表示的，也就不能称之为知识。
      <br/>
      （e.g. 刮台风大概率会下雨 、今天是火烧云明天是大概率是晴天…诸如此类“
      <strong>
       经验
      </strong>
      ”我们都认为它是“
      <strong>
       知识
      </strong>
      ”）
     </p>
    </blockquote>
    <p>
     <strong>
      知识表示
     </strong>
     :知识表示是将人类知识
     <strong>
      形式化或者模型化
     </strong>
     ,是对各种知识的
     <strong>
      机器形式语言描述
     </strong>
     ,更通俗易懂的讲也可以理解为一种让计算机可以“接受”的用于描述知识的数据结构(表示方式)。
    </p>
    <hr color="#000000" size='1"'/>
    <h3>
     <a id="2__33">
     </a>
     2. 状态空间法定义
    </h3>
    <p>
     <strong>
      状态空间方法
     </strong>
     可形式化为四元组表示：
     <em>
      (S,O,S
      <sub>
       0
      </sub>
      ,G)
     </em>
     <br/>
     其中： S是状态空间，即问题所有可能状态的集合，O是操作算子的集合， S
     <sub>
      0
     </sub>
     是初始状态， G是目标状态。
    </p>
    <p>
     以八数码问题为例,可以基于状态空间法形式化表示为:
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/eb94f8d29be1c9122887ba6ac656d0cb.png#pic_center">
      <br/>
      <strong>
       状态空间的解
      </strong>
      ：从初始状态 S
      <sub>
       0
      </sub>
      到目标状态 G 的操作算子序列
     </img>
    </p>
    <hr color="#000000" size='1"'/>
    <h3>
     <a id="3__43">
     </a>
     3. 问题求解
    </h3>
    <blockquote>
     <p>
      问题求解(problem solving)是人工智能主要应用领域之一，它涉及表示、归约、推断、决策、规划、定理证明和相关过程等核心概念。
     </p>
    </blockquote>
    <p>
     问题求解主要包括两个主要的方面
     <br/>
     <strong>
      问题的表示
     </strong>
     ：将问题以计算机可理解接受的方式进行描述，即知识表示。例如:利用我们在数据结构学习的图进行机器语言描述，将地图表示为图结构。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/555fed1087394f628b329c194f68efad.png#pic_center"/>
    </p>
    <p>
     <strong>
      求解的方法
     </strong>
     ：解决问题的办法，如搜索法，归约法，推理法。
    </p>
    <blockquote>
     <p>
      <strong>
       问题的类型
      </strong>
      <br/>
      •
      <strong>
       单状态问题
      </strong>
      ：
      <mark>
       确定的且可全部观察
      </mark>
      （八数码）
      <br/>
      知道问题的所有状态，从而可以计算出最佳动作序列达到目标状态。
      <br/>
      <br/>
      •
      <strong>
       多状态问题
      </strong>
      ：
      <mark>
       确定的且不可全部观察
      </mark>
      （军棋）
      <br/>
      必须通过假定的动作序列和状态来推理以达到目标状态。
      <br/>
      <br/>
      •
      <strong>
       偶然性问题
      </strong>
      ：
      <mark>
       不确定的且不可全部观察
      </mark>
      （股市分析）
      <br/>
      必需通过实时反馈来决定执行下一步行动
      <br/>
      <br/>
      •
      <strong>
       探索性问题
      </strong>
      ：
      <mark>
       状态空间未知
      </mark>
      （游戏,王者荣耀,英雄联盟）
      <br/>
      通过实时环境感知和探索学习来决定实时执行行动
     </p>
    </blockquote>
    <hr color="#000000" size='1"'/>
    <h2>
     <a id="_68">
     </a>
     三、基于状态空间搜索法解决八数码问题
    </h2>
    <h3>
     <a id="1__69">
     </a>
     1. 八数码问题的知识表示
    </h3>
    <p>
     <strong>
      状态空间
     </strong>
     <br/>
     一个八数码的局面就是一个状态，根据八数码问题定义给出所有可能的局面组成的集合即为状态空间。本问题实际上求解初始状态到目标状态的操作算子序列。
    </p>
    <p>
     <strong>
      单状态的知识表示
     </strong>
     <br/>
     八数码九宫格可以看作一个
     <strong>
      隐式节点图
     </strong>
     ，只有九个存储数据的格子(节点),没有边的概念。针对本题而言，我们可以采用可以采用1*9的一维数组来存储这个隐式图的数据。在网上有不少利用9位整型数字存储的做法，但这里笔者采用
     <strong>
      Python列表
     </strong>
     来存储每一个状态（八个格子）的数据，使用这种存储结构的好处是我们可以很方便的对同类问题（4阶）进行扩展，并且能够在列表中存储空格的操作算子序列。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/dca2cef44c8efcd92767da4289149eea.png#pic_center">
      <br/>
      <strong>
       操作算子
      </strong>
      <br/>
      显然，每一个状态可执行操作有：
      <strong>
       空格上移、空格下移、空格左移、空格右移
      </strong>
      ，我们需要在我们定义的知识表示方式（数据结构）中实现状态的可执行操作，即我们需要在列表上交换对应位置的值：
     </img>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ae4ed1af3dfbca661b3f22959b13f260.png#pic_center">
      <br/>
      代码实现：（
      <a href="https://www.jianshu.com/p/7ca1534bb677" rel="nofollow">
       Python多元赋值写法
      </a>
      ,其中space_index表示空格在列表中的索引）
     </img>
    </p>
    <pre><code class="prism language-python">空格左移：
<span class="token keyword">if</span> space_index <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 判断空格是否可以向左移动</span>
	state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
空格右移：
<span class="token keyword">if</span> <span class="token punctuation">(</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 判断空格是否可以向右移动</span>
	state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
空格上移：
<span class="token keyword">if</span> space_index <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 判断空格是否可以向上移动</span>
	state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
空格下移：
<span class="token keyword">if</span> space_index <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">:</span>  <span class="token comment"># 判断空格是否可以向下移动</span>
	state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
</code></pre>
    <p>
     <strong>
      改进方法
     </strong>
     :利用一个字典来保存每个空格位置所能移动的所有位置索引,因此我们只需要直接遍历对应位置的列表即可。
    </p>
    <pre><code class="prism language-python3">position_movable<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
list_position_movable <span class="token operator">=</span> position_movable<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
<span class="token comment"># 遍历位置列表进行交换：</span>
<span class="token keyword">for</span> position <span class="token keyword">in</span> list_position_movable<span class="token punctuation">:</span>
	temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>position<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
</code></pre>
    <p>
     两种的时间效率差距不大，笔者在下面的代码中分别体现两种方法（DFS/BFS使用第一种；A*使用第二种）。
    </p>
    <p>
     <strong>
      连续状态的知识表示
     </strong>
     <br/>
     初始状态到目标状态的状态搜索过程可以表示为树结构，将
     <strong>
      每一个状态看作搜索树的一个节点
     </strong>
     ，
     <strong>
      每个节点的子节点表示经过一次空格移动得到的下一状态
     </strong>
     ，由此我们可以构建搜索状态空间树。
    </p>
    <hr color="#000000" size='1"'/>
    <p>
     对一个图进行搜索意味着按照某种特定的顺序依次访问其顶点。为了提高我们解决问题的效率，在搜索前我们可以先尝试着去寻找
     <strong>
      判断问题是否有解的方法
     </strong>
     。对于八数码问题，我们可以通过下面的方法来判断两个状态之间是否可达：
    </p>
    <blockquote>
     <p>
      <strong>
       首先判断两个状态之间的可达性
      </strong>
      ：
      <br/>
      分别计算八数码状态的八个数据组成的序列的逆序数，根据两者逆序数进行判断。
      <s>
       我们都知道
      </s>
      ：从小到大称为
      <strong>
       顺序
      </strong>
      ，例如1，2，3。
      <mark>
       如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数（例如：8，7），那么它们就称为一个
       <strong>
        逆序
       </strong>
      </mark>
      。一个排列中逆序的总数就称为这个排列的逆序数。逆序数为偶数的排列称为
      <strong>
       偶排列
      </strong>
      ；逆序数为奇数的排列称为
      <strong>
       奇排列
      </strong>
      。
      <br/>
      <br/>
      计算八数码节点的逆序数时将代表空格的0去除（不影响状态逆序数的计算）,例如：
      <br/>
      初始状态排列为：
      <mark>
       [1 ， 3 ， 2 ， 4 ， 5 ， 6 ， 7 ， 8]
      </mark>
      <br/>
      <strong>
       逆序数
      </strong>
      为：0 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 1 即为
      <strong>
       奇排列
      </strong>
      <br/>
      <br/>
      目标状态排列为：
      <mark>
       [1 ， 2 ， 3 ， 8 ， 4 ， 7 ， 6 ， 5]
      </mark>
      <br/>
      <strong>
       逆序数
      </strong>
      为：0 + 0 + 0 + 4 + 0 + 2 + 1 + 0 = 7 即为
      <strong>
       奇排列
      </strong>
      <br/>
      <br/>
      <strong>
       结论:
      </strong>
      具有
      <strong>
       同奇或同偶排列
      </strong>
      的两个八数码才能移动可达，否则不可达。
     </p>
    </blockquote>
    <hr color="#000000" size='1"'/>
    <h3>
     <a id="2___126">
     </a>
     2. 状态空间图搜索
    </h3>
    <p>
     图搜索策略主要分为
     <strong>
      无信息搜索(Uninformed Search)
      <strong>
       和
      </strong>
      启发式搜索(Heuristic Search)
     </strong>
     。
    </p>
    <blockquote>
     <p>
      <strong>
       无信息搜索
      </strong>
      ：也称为盲目搜索，即
      <mark>
       只按预定的控制策略进行搜索
      </mark>
      ,在搜索过程中获得的中间信息不会用来改进控制策略。
      <br/>
      <strong>
       启发式搜索
      </strong>
      :
      <mark>
       在搜索中加入了与问题有关的启发性信息,用于指导搜索朝着最有希望的方向进行
      </mark>
      ,加速问题的求解过程并找到最优解。
     </p>
    </blockquote>
    <h4>
     <a id="1__131">
     </a>
     1. 无信息搜索
    </h4>
    <p>
     笔者水平十分有限，因此在算法的原理上不会深入探究，明白思想且能够运用即可，首先在这推荐几篇个人参考，觉得讲得不错且有深度的博文：
     <br/>
     <a href="https://blog.csdn.net/woalss/article/details/104946710">
      【算法】广度优先搜索（BFS）和深度优先搜索（DFS）
     </a>
     <br/>
     <a href="https://blog.csdn.net/qq_45877524/article/details/104845320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161658846716780269877777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161658846716780269877777&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-104845320.pc_search_positive&amp;utm_term=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%A8%E7%94%BB">
      广度/宽度优先搜索 BFS （动画解算法 附C++\C、JAVA、Python的代码实现）
     </a>
     <br/>
     <a href="https://blog.csdn.net/qq_41681241/article/details/81432634">
      深度优先搜索和广度优先搜索及典例分析(走迷宫问题(BFS)和棋盘问题(DFS))
     </a>
    </p>
    <hr color="#000000" size='1"'/>
    <h5>
     <a id="BreadthFirst_Search_139">
     </a>
     广度优先搜索(Breadth-First Search)
    </h5>
    <blockquote>
     <p>
      <strong>
       从树（本质上也可以看作图）上看
      </strong>
      ：从初始状态开始在状态空间树搜索目标状态，
      <mark>
       首先遍历本层树节点,遍历完每一层树节点再遍历下一层
      </mark>
      ,直到找到目标状态。
      <br/>
      <strong>
       从图上看就是
      </strong>
      :
      <mark>
       首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点
      </mark>
      ，逐步的向外扩散，直到找到终点。
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" height="360" src="https://i-blog.csdnimg.cn/blog_migrate/a2d373fa08b4903a8cc7cc0647aface6.png#pic_center" width="800">
      <br/>
      <a href="https://cs.stanford.edu/people/abisee/tutorial/bfsdfs.html" rel="nofollow">
       图上广度优先遍历与深度优先遍历对比（动画，可设置障碍）
      </a>
      <br/>
      <img alt="在这里插入图片描述" height="470" src="https://i-blog.csdnimg.cn/blog_migrate/69960de4000eb333b858101b4b659024.jpeg#pic_center" width="800">
       <br/>
       <img alt="在这里插入图片描述" height="420" src="https://i-blog.csdnimg.cn/blog_migrate/f72ebda7539ff4d5af3335115744844e.png#pic_center" width="800"/>
      </img>
     </img>
    </p>
    <hr color="#000000" size='1"'/>
    <p>
     <strong>
      检测去重
     </strong>
     <br/>
     不难发现,在初始状态到目标状态的转移过程中会出现大量重复性的状态,产生了不必要的
     <strong>
      重复性无效搜索
     </strong>
     ,
     <mark>
      因此我们可以在每一次状态入队前先检验该状态是否已经入队,确保每一种状态只检测一次,能有效避免重复性的搜索,极大的节省了搜索时间
     </mark>
     。
    </p>
    <p>
     网上有不少解决重复的方法，例如：
     <strong>
      <strong>
       生成九位数全排列+二分查找记录去重
      </strong>
     </strong>
     、
     <strong>
      Hash去重
     </strong>
     （可能存在哈希冲突）等等。 Python的字典和集合其实也有不错的效果。
     <a href="https://blog.csdn.net/dili8870/article/details/101506582">
      Python的字典和集合底层原理简述
     </a>
    </p>
    <ul>
     <li>
      <strong>
       Dict
      </strong>
      底层依靠哈希表(hash table)实现, 使用开放寻址法解决冲突,字典在内存中开销很大。实际上是以空间换时间。
     </li>
     <li>
      <strong>
       Set
      </strong>
      底层利用红黑树查询，查询复杂度O(logn)；
      <strong>
       Dict
      </strong>
      是对key先进行了hash,然后再对hash生成一个红黑树进行查找，查找复杂虽然也是O(logn)，但多了一个hash的过程。
     </li>
    </ul>
    <p>
     就本题而言我们在判重时经常需要对重复状态进行判重查询，经过测试,使用Set集合时间和空间效率会更高,因此我们更适合用Set作为我们的判重记录表，节省计算资源。
    </p>
    <p>
     笔者这里写了一个函数用于检测当前状态是否已经被访问，用于状态入队前检测：(
     <code>
      请注意这种方法只适用于不限制搜索层数的搜索方式,具体原因在下面深度优先搜索时会解释并解决。Set不能保存value，后面深度优先搜索中判重需要保存层数,所以我还是选择了dict。使用set代码会更加简洁，读者可以自行动手实现。
     </code>
     )
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/51c22672d0f29b2566e95677ba411b51.png"/>
    </p>
    <hr color="#000000" size='1"'/>
    <p>
     至此我们就可以给出基于BFS搜索策略解决八数码问题的主要流程图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/81c696e282e987bb1551c43bf26c03c7.png#pic_center"/>
    </p>
    <hr color="#000000" size='1"'/>
    <p>
     其中堆栈直接用了Python标准库 queue模块，当然也可以自己写一个类实现，实现一些自己的存储结构和方法
    </p>
    <blockquote>
     <p>
      <strong>
       queue模块有三种队列及构造函数
      </strong>
      <br/>
      class queue.Queue(maxsize) ：
      <strong>
       FIFO（队列），先进先出
      </strong>
      。
      <br/>
      class queue.LifoQueue(maxsize)：
      <strong>
       LIFO（堆栈），即先进后出
      </strong>
      。
      <br/>
      class queue.PriorityQueue(maxsize)：还有一种是优先级队列级别越低越先出来。
      <br/>
     </p>
     <blockquote>
      <p>
       笔者这里只用到几个常用的方法，更多详细可查阅
       <a href="https://docs.python.org/zh-cn/3.7/library/queue.html" rel="nofollow">
        queue帮助文档
       </a>
      </p>
     </blockquote>
     <pre><code class="prism language-python">Q <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#生成一个队列</span>
Q <span class="token operator">=</span> queue<span class="token punctuation">.</span>LifoQueue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#生成一个栈</span>
Q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>
Q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
Q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
     <blockquote>
      <p>
       Queue.empty()
       <br/>
       如果队列为空，返回 True ，否则返回 False
       <br/>
       <br/>
       Queue.put(item, block=True, timeout=None)
       <br/>
       将 item 放入队列
       <br/>
       <br/>
       Queue.get(block=True, timeout=None)
       <br/>
       从队列（首部）移除并返回一个项目
      </p>
     </blockquote>
    </blockquote>
    <p>
     运行环境：Python 3.6.9
     <br/>
     笔者给了十分详细的注释，相信能帮助初学者理解
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> time
<span class="token keyword">import</span> queue

<span class="token comment"># @Function: 计算逆序数</span>
<span class="token comment"># @Parameter: state是存储每个状态的数据列表(九个字符型数字的列表)</span>
<span class="token keyword">def</span> <span class="token function">calculate_reverse_number</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	state<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
	<span class="token comment"># reverse_number用来记录逆序数</span>
	reverse_number <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> cur <span class="token keyword">in</span> state<span class="token punctuation">:</span>
		index <span class="token operator">=</span> state<span class="token punctuation">.</span>index<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token comment"># 遍历cur后面的数字</span>
		<span class="token keyword">for</span> after_cur <span class="token keyword">in</span> state<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> cur <span class="token operator">&gt;</span> after_cur<span class="token punctuation">:</span>
				reverse_number <span class="token operator">+=</span> <span class="token number">1</span>
	<span class="token keyword">if</span> reverse_number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">1</span>

<span class="token comment"># @Function: 判断初始状态到目标状态是否有解</span>
<span class="token comment"># @Parameter: initial 初始状态数据列表</span>
<span class="token comment">#             purpose 目标状态数据列表</span>
<span class="token keyword">def</span> <span class="token function">judge_solvable</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span>purpose<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> initial <span class="token operator">==</span> purpose<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"起始状态为目标状态!"</span><span class="token punctuation">)</span>
		exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	initial_rev_num <span class="token operator">=</span> calculate_reverse_number<span class="token punctuation">(</span>initial<span class="token punctuation">)</span>
	purpose_rev_num <span class="token operator">=</span> calculate_reverse_number<span class="token punctuation">(</span>purpose<span class="token punctuation">)</span>
	<span class="token keyword">if</span> initial_rev_num <span class="token operator">!=</span> purpose_rev_num<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无法到达!"</span><span class="token punctuation">)</span>
		exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># enqueued 字典 用来记录已经入队过的状态</span>
<span class="token comment"># key表示当前状态,value表示是否入队 1已经入队,0未入队</span>
enqueued <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment"># E.G  {'123405678':1,'123405687':1}</span>
<span class="token comment"># 判断当前状态是否已经被访问</span>
<span class="token keyword">def</span> <span class="token function">is_visited</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	state_key <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
	<span class="token comment"># 字典get方法: 在字典中寻找state,找到则返回字典的值,找不到则返回默认值0</span>
	<span class="token keyword">if</span> enqueued<span class="token punctuation">.</span>get<span class="token punctuation">(</span>state_key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># 已经访问过</span>
		<span class="token keyword">return</span> <span class="token boolean">True</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token comment"># 如果判断为未访问过,下一步要入队,直接在这里更改,提高代码复用性</span>
		enqueued<span class="token punctuation">[</span>state_key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token keyword">return</span> <span class="token boolean">False</span>

<span class="token comment"># 寻找当前状态的所有下一步所有可行状态,将其加入队列</span>
<span class="token keyword">def</span> <span class="token function">find_next_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">global</span> create_point<span class="token punctuation">,</span>Open
	<span class="token comment">#找到空格(0)的位置</span>
	space_index <span class="token operator">=</span> state<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> space_index <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向上移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment">#未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"up"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

	<span class="token keyword">if</span> space_index <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向下移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

	<span class="token keyword">if</span> space_index <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向左移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"left"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向右移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"right"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
	initial_state <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入初始状态：'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	purpose_state <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入目标状态：'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment"># 判断是否可以到达,如果不可以到达,则直接退出</span>
	judge_solvable<span class="token punctuation">(</span>initial_state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> purpose_state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment"># search_point为搜索的节点数 (已经经过判断,确认过不是目标状态的状态,入队然后检测删除的节点)</span>
	<span class="token comment"># create_point为生成节点数 (加入队列中的所有状态)</span>
	search_point <span class="token operator">=</span> create_point <span class="token operator">=</span> <span class="token number">0</span>

	<span class="token comment"># Open队列 用来存储生成节点</span>
	Open <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment"># 初始状态入队,设置初始状态为已访问</span>
	Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span>
	enqueued<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

	<span class="token comment"># 开始搜索</span>
	start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span> Open<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token comment"># open表空说明已经搜索完所有可能状态,未找到解</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"未找到解!"</span><span class="token punctuation">)</span>
			exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token comment"># 取出队头元素  get是queue的方法:返回并删除队头元素</span>
		queue_first <span class="token operator">=</span> Open<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token comment"># 判断是否是目标状态,是则输出查询信息,退出</span>
		<span class="token keyword">if</span> queue_first<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">==</span> purpose_state<span class="token punctuation">:</span>
			end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
			search_point <span class="token operator">+=</span> <span class="token number">1</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"搜索成功!"</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前层次：{},已搜索节点数:{},已生成结点数{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>queue_first<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">,</span> search_point<span class="token punctuation">,</span> create_point<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"空格的移动路径依次为："</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span> i <span class="token keyword">in</span> queue_first<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
				<span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'-&gt;'</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'消耗时间:{} Seconds'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>
			exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token comment"># 不是目标状态,本状态的所有下一步可能状态入队</span>
		search_point <span class="token operator">+=</span> <span class="token number">1</span>
		find_next_state<span class="token punctuation">(</span>queue_first<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     测试示例对比：
    </p>
    <blockquote>
     <p>
      <code>
       无去重
      </code>
      <br/>
      <img alt="没有去重" height="200" src="https://i-blog.csdnimg.cn/blog_migrate/5b6b3d0196d49d1f5cd2cfdb82ba1172.png" width="800"/>
      <br/>
      <code>
       去重
      </code>
      <br/>
      <img alt="在这里插入图片描述" height="200" src="https://i-blog.csdnimg.cn/blog_migrate/f6d433595d2d9674ee17896515718b62.png" width="800"/>
      <br/>
      <code>
       层数比较高时，不去重的方法会消耗大量的时间，时间复杂度和空间复杂度远远高于去重方法（实测差距巨大，不去重的代码跑几分钟）
      </code>
      <br/>
      <img alt="在这里插入图片描述" height="200" src="https://i-blog.csdnimg.cn/blog_migrate/2ded9a92f92320a40d313a77174a197e.png" width="1100"/>
     </p>
    </blockquote>
    <hr color="#000000" size='1"'/>
    <h5>
     <a id="DepthFirst_Search_343">
     </a>
     深度优先搜索(Depth-First Search)
    </h5>
    <blockquote>
     <p>
      <strong>
       深度优先搜索
      </strong>
      :顾名思义,
      <mark>
       优先扩展最新产生的(即最深的)节点
      </mark>
      ,深度优先搜索沿着状态空间某条单一的路径从起始节点向下进行下去；只有当搜索到达一个没有子节点的状态时，它才考虑另一条替代的路径。
      <code>
       状态空间搜索树的深度可能为无限深，往往给出一个节点扩展的最大深度—深度界限
      </code>
      。
      <img alt="在这里插入图片描述" height="400" src="https://i-blog.csdnimg.cn/blog_migrate/ff5c8668714f193ddd26eae66bfc7757.jpeg#pic_center" width="800"/>
      <br/>
      <a href="https://cs.stanford.edu/people/abisee/tutorial/bfsdfs.html" rel="nofollow">
       图上广度优先遍历与深度优先遍历对比（动画，可设置障碍）
      </a>
      <br/>
      <img alt="在这里插入图片描述" height="500" src="https://i-blog.csdnimg.cn/blog_migrate/6b0ae3d1ca0ff53d1f7bbfb52e429944.png#pic_center" width="800"/>
     </p>
    </blockquote>
    <hr color="#000000" size='1"'/>
    <p>
     <strong>
      检测去重
     </strong>
     <br/>
     我们前面写了一个检测函数，在每一次状态入队前先检验该状态是否已经入队,确保每一种状态只检测一次，但是它是建立在无搜索层数限制的前提下的。
     <br/>
     深度优先搜索通常会设置一个最大搜索深度,因此在这种情况下
     <code>
      判重状态
     </code>
     不入队可能会导致部分子节点直接被忽略掉搜索不到的情况 。
    </p>
    <blockquote>
     <p>
      假如下图中标红圈的两个状态是同一个状态，那么按照我们前面的去重方法，4号会先入队，在搜索11号时判定该状态已经入队，那么11号就不再入队，但是这样会出现一个问题，由于搜索深度的限制，导致4号只能继续向下搜索一层，而从11号出发还可以继续搜索3层，所以从11号出发搜索的第二层第三层就会直接被忽略掉没有搜索，而目标状态可能就在其中，因此会出现BUG。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/78770cfb145f42f4c8435b4576c6753d.png#pic_center"/>
     </p>
    </blockquote>
    <p>
     <strong>
      容易知道：状态越浅，它搜索到的子节点越多
     </strong>
     <br/>
     因此当
     <code>
      判断状态
     </code>
     的层数比
     <code>
      已经入队的那个状态
     </code>
     更深的时候，不需要入队（
     <mark>
      因为这个状态的子节点都已经被前面那个入队的状态的子节点所包含
     </mark>
     ）；比
     <code>
      已经入队的那个状态
     </code>
     更浅的时候则需要重复入队，并更新该状态的入队最浅层数。修改如下:
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f88d96f8f4cd28c45c91e45fa63fd8f2.png#pic_center"/>
    </p>
    <hr color="#000000" size='1"'/>
    <p>
     至此我们就可以给出基于DFS搜索策略解决八数码问题的主要流程图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/675810fa7e5b53798ec17b07fc2cf4ad.png"/>
    </p>
    <pre><code class="prism language-python3"><span class="token keyword">import</span> time
<span class="token keyword">import</span> queue

<span class="token comment"># @Function: 计算逆序数</span>
<span class="token comment"># @Parameter: state是存储每个状态的数据列表(九个字符型数字的列表)</span>
<span class="token keyword">def</span> <span class="token function">calculate_reverse_number</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	state<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
	<span class="token comment"># reverse_number用来记录逆序数</span>
	reverse_number <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> cur <span class="token keyword">in</span> state<span class="token punctuation">:</span>
		index <span class="token operator">=</span> state<span class="token punctuation">.</span>index<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token comment"># 遍历cur后面的数字</span>
		<span class="token keyword">for</span> after_cur <span class="token keyword">in</span> state<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> cur <span class="token operator">&gt;</span> after_cur<span class="token punctuation">:</span>
				reverse_number <span class="token operator">+=</span> <span class="token number">1</span>
	<span class="token keyword">if</span> reverse_number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">1</span>

<span class="token comment"># @Function: 判断初始状态到目标状态是否有解</span>
<span class="token comment"># @Parameter: initial 初始状态数据列表</span>
<span class="token comment">#             purpose 目标状态数据列表</span>
<span class="token keyword">def</span> <span class="token function">judge_solvable</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span>purpose<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> initial <span class="token operator">==</span> purpose<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"起始状态为目标状态!"</span><span class="token punctuation">)</span>
		exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	initial_rev_num <span class="token operator">=</span> calculate_reverse_number<span class="token punctuation">(</span>initial<span class="token punctuation">)</span>
	purpose_rev_num <span class="token operator">=</span> calculate_reverse_number<span class="token punctuation">(</span>purpose<span class="token punctuation">)</span>
	<span class="token keyword">if</span> initial_rev_num <span class="token operator">!=</span> purpose_rev_num<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无法到达!"</span><span class="token punctuation">)</span>
		exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># enqueued 字典 用来记录已经入队过的状态</span>
<span class="token comment"># key表示当前状态,value表示当前状态的层数</span>
enqueued <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment"># E.G  {'123405678':5,'123405687':6}</span>
<span class="token comment"># 判断当前状态是否已经被访问</span>
<span class="token keyword">def</span> <span class="token function">is_visited</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">global</span> max_layers
	state_key <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>state<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token comment"># 获取当前状态的层数</span>
	cur_layer <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span>

	<span class="token comment"># 字典get方法: 在字典中寻找state,找到则返回字典的值,找不到则返回默认值0</span>
	<span class="token keyword">if</span> enqueued<span class="token punctuation">.</span>get<span class="token punctuation">(</span>state_key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># 判断当前的层数是否比已经入队的那个状态更低(浅),如果是的话则需要入队</span>
		<span class="token keyword">if</span> cur_layer <span class="token operator">&lt;</span> enqueued<span class="token punctuation">.</span>get<span class="token punctuation">(</span>state_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
			enqueued<span class="token punctuation">[</span>state_key<span class="token punctuation">]</span> <span class="token operator">=</span> cur_layer
			<span class="token keyword">return</span> <span class="token boolean">False</span>
		<span class="token keyword">return</span> <span class="token boolean">True</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token comment"># 如果判断为未访问过,下一步要入队,直接在这里更改,提高代码复用性</span>
		enqueued<span class="token punctuation">[</span>state_key<span class="token punctuation">]</span> <span class="token operator">=</span> cur_layer
		<span class="token keyword">return</span> <span class="token boolean">False</span>

<span class="token comment"># 寻找当前状态的所有下一步所有可行状态,将其加入队列</span>
<span class="token keyword">def</span> <span class="token function">find_next_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">global</span> create_point
	<span class="token comment"># 找到空格(0)的位置</span>
	space_index <span class="token operator">=</span> state<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> space_index <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向上移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队,如果是倒数第二层那么就不进行去重</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"up"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

	<span class="token keyword">if</span> space_index <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向下移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

	<span class="token keyword">if</span> space_index <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向左移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"left"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 空格向右移动</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>space_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
			temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"right"</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
	initial_state <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入初始状态(例如:2 4 8 6 0 3 1 7 5)：'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	purpose_state <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入目标状态(例如:1 2 3 8 0 4 7 6 5)：'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	max_layers <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入深度优先搜索最大层数:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	cur_layers <span class="token operator">=</span> <span class="token number">0</span>

	<span class="token comment"># 判断是否可以到达,如果不可以到达,则直接退出</span>
	judge_solvable<span class="token punctuation">(</span>initial_state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> purpose_state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment"># search_point为搜索的节点数 (已经经过判断,确认过不是目标状态的状态,入队然后检测删除的节点)</span>
	<span class="token comment"># create_point为生成节点数 (加入队列中的所有状态)</span>
	search_point <span class="token operator">=</span> create_point <span class="token operator">=</span> <span class="token number">0</span>

	<span class="token comment"># Open后入先出队列 用来存储生成节点</span>
	Open <span class="token operator">=</span> queue<span class="token punctuation">.</span>LifoQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment"># 初始状态入队,设置初始状态为已访问</span>
	Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span>
	enqueued<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

	<span class="token comment"># 开始搜索</span>
	start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">while</span> true<span class="token punctuation">:</span>
		<span class="token keyword">if</span> Open<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"搜索完毕! 在"</span><span class="token punctuation">,</span>max_layers<span class="token punctuation">,</span><span class="token string">"层未找到解!"</span><span class="token punctuation">)</span>
			exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token comment"># 取出队头元素  get是queue的方法:返回并删除队头元素</span>
		queue_first <span class="token operator">=</span> Open<span class="token punctuation">.</span>get<span class="token punctuation">(</span>block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
		<span class="token comment"># 判断是否是目标状态,是则输出查询信息,退出</span>
		<span class="token keyword">if</span> queue_first<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">==</span> purpose_state<span class="token punctuation">:</span>
			end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
			search_point <span class="token operator">+=</span> <span class="token number">1</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"搜索成功!"</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前层次：{},已搜索节点数:{},已生成结点数{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>queue_first<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">,</span> search_point<span class="token punctuation">,</span> create_point<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"空格的移动路径依次为："</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span> i <span class="token keyword">in</span> queue_first<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
				<span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'-&gt;'</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'消耗时间:{} Seconds'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>
			exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token comment"># 不是目标状态,本状态的所有下一步可能状态入队</span>
		search_point <span class="token operator">+=</span> <span class="token number">1</span>
		cur_layers <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue_first<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span>
		<span class="token keyword">if</span> cur_layers <span class="token operator">&lt;</span> max_layers<span class="token punctuation">:</span>
			find_next_state<span class="token punctuation">(</span>queue_first<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"已到最大深度"</span><span class="token punctuation">,</span>cur_layers<span class="token punctuation">,</span><span class="token string">"层,返回父节点搜索"</span><span class="token punctuation">)</span>
			<span class="token comment">#exit(0)</span>
</code></pre>
    <p>
     测试示例对比：
    </p>
    <blockquote>
     <p>
      <code>
       去重
      </code>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4c3ea483ff34bc3bc55bc7436d1868a2.png"/>
      <br/>
      <code>
       不去重
      </code>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9032dd8c2f0fb84e59e1c236210835a9.png"/>
      <br/>
      <code>
       层数比较高时，不去重的方法会消耗大量的时间，远远高于去重方法
      </code>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e1baaaefb793f5417812f3eb47a47a21.png"/>
     </p>
    </blockquote>
    <hr color="#000000" size='1"'/>
    <h4>
     <a id="2__519">
     </a>
     2. 启发式搜索
    </h4>
    <p>
     <strong>
      启发式搜索
     </strong>
     (Heuristically Search)又称为
     <strong>
      有信息搜索
     </strong>
     (Informed Search)，它是利用问题拥有的
     <strong>
      启发信息
     </strong>
     来引导搜索，达到减少搜索范围、降低问题复杂度的目的，这种利用启发信息的搜索过程称为启发式搜索。其代表算法为：
     <strong>
      贪婪最佳优先搜索(Greedybest-first search)和 A * 搜索。
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       举个形象的例子来说明A*算法思想
      </strong>
      ：你是一个盲人，你在在广东，现在要步行去到北京，假如你任何信息都没有，就只是满世界随机游走（盲目搜索），直到寻找到北京。但我们都知道更优做法是：先去询问北京和广东的相对地理位置（启发信息），至少确定方向再去走。在寻找过程中，我们可以知道我们已经走过多长的路程（我们称之前向代价，它是真实的），再通过某种方法判断当前位置与北京的距离（我们称之为后向代价，它通常是估计出来的，实际求解问题我们是不知道解（路径）的），把前向代价和后向代价的和作为我们的代价，优先去走代价最小的方向，这就是A*算法的思想。
     </p>
    </blockquote>
    <hr color="#000000" size='1"'/>
    <h5>
     <a id="DijkstraUCS_527">
     </a>
     Dijkstra（UCS）算法
    </h5>
    <p>
     <a href="https://blog.csdn.net/qq_35644234/article/details/60870719">
      Dijkstra（UCS）算法详解
     </a>
     <br/>
     <strong>
      简单的说
     </strong>
     ：简单的理解就是在宽度优先搜索的基础上加上了
     <strong>
      深度（已经遍历的层数）作为代价
     </strong>
     ，
     <strong>
      优先扩展代价（已经走的路径消耗）最小的结点
     </strong>
     ，你可以理解为在每一次入队时，都会对该状态所走过的路径进行计算，并以此进行排序，将走过路径最短的节点放在Open表的首部。
    </p>
    <hr color="#000000" size='1"'/>
    <h5>
     <a id="A_532">
     </a>
     A*算法
    </h5>
    <p>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        A 
        
       
         ∗ 
        
       
      
        A*
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          A
         </span>
         <span class="mord">
          ∗
         </span>
        </span>
       </span>
      </span>
     </span>
     可以认为是添加了启发式函数的
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        D 
        
       
         i 
        
       
         j 
        
       
         k 
        
       
         s 
        
       
         t 
        
       
         r 
        
       
         a 
        
       
         ( 
        
       
         U 
        
       
         C 
        
       
         S 
        
       
         ) 
        
       
      
        Dijkstra(UCS)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.02778em;">
          D
         </span>
         <span class="mord mathdefault">
          i
         </span>
         <span class="mord mathdefault" style="margin-right: 0.05724em;">
          j
         </span>
         <span class="mord mathdefault" style="margin-right: 0.03148em;">
          k
         </span>
         <span class="mord mathdefault">
          s
         </span>
         <span class="mord mathdefault">
          t
         </span>
         <span class="mord mathdefault" style="margin-right: 0.02778em;">
          r
         </span>
         <span class="mord mathdefault">
          a
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault" style="margin-right: 0.10903em;">
          U
         </span>
         <span class="mord mathdefault" style="margin-right: 0.07153em;">
          C
         </span>
         <span class="mord mathdefault" style="margin-right: 0.05764em;">
          S
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     算法，在
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        D 
        
       
         i 
        
       
         j 
        
       
         k 
        
       
         s 
        
       
         t 
        
       
         r 
        
       
         a 
        
       
      
        Dijkstra
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.8888799999999999em; vertical-align: -0.19444em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.02778em;">
          D
         </span>
         <span class="mord mathdefault">
          i
         </span>
         <span class="mord mathdefault" style="margin-right: 0.05724em;">
          j
         </span>
         <span class="mord mathdefault" style="margin-right: 0.03148em;">
          k
         </span>
         <span class="mord mathdefault">
          s
         </span>
         <span class="mord mathdefault">
          t
         </span>
         <span class="mord mathdefault" style="margin-right: 0.02778em;">
          r
         </span>
         <span class="mord mathdefault">
          a
         </span>
        </span>
       </span>
      </span>
     </span>
     算法的基础上，构造一个函数，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        n 
        
       
      
        n
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     为当前扩展结点，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     表示结点
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        n 
        
       
      
        n
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     到终点的开销估计，我们称
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     为
     <strong>
      启发函数
     </strong>
     。然后建立
     <strong>
      估价函数
     </strong>
     <br/>
     <span class="katex--display">
      <span class="katex-display">
       <span class="katex">
        <span class="katex-mathml">
         f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          + 
         
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         f(n)=g(n)+h(n)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathdefault" style="margin-right: 0.10764em;">
           f
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathdefault">
           n
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mspace" style="margin-right: 0.2777777777777778em;">
          </span>
          <span class="mrel">
           =
          </span>
          <span class="mspace" style="margin-right: 0.2777777777777778em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathdefault" style="margin-right: 0.03588em;">
           g
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathdefault">
           n
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mspace" style="margin-right: 0.2222222222222222em;">
          </span>
          <span class="mbin">
           +
          </span>
          <span class="mspace" style="margin-right: 0.2222222222222222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathdefault">
           h
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathdefault">
           n
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
    </p>
    <p>
     其中
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        g 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        g(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.03588em;">
          g
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     为从起点到结点n已经使用了的代价，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     为从当前结点n到目标节点的预测代价。所以
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.10764em;">
          f
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     可以理解为是“从起点出发经过结点n再到终点的代价估计”。
    </p>
    <p>
     显然对于八数码问题中，我们的
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        g 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        g(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.03588em;">
          g
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     就是空格移动的步数，也就是当前的搜索深度。接下来我们需要构造结点
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        n 
        
       
      
        n
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     到终点的开销估计函数
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     <br/>
     <span class="katex--display">
      <span class="katex-display">
       <span class="katex">
        <span class="katex-mathml">
         h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          ≤ 
         
         
         
           h 
          
         
           ∗ 
          
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         h(n) ≤ h^*(n)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathdefault">
           h
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathdefault">
           n
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mspace" style="margin-right: 0.2777777777777778em;">
          </span>
          <span class="mrel">
           ≤
          </span>
          <span class="mspace" style="margin-right: 0.2777777777777778em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord">
           <span class="mord mathdefault">
            h
           </span>
           <span class="msupsub">
            <span class="vlist-t">
             <span class="vlist-r">
              <span class="vlist" style="height: 0.738696em;">
               <span class="" style="top: -3.113em; margin-right: 0.05em;">
                <span class="pstrut" style="height: 2.7em;">
                </span>
                <span class="sizing reset-size6 size3 mtight">
                 <span class="mbin mtight">
                  ∗
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathdefault">
           n
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
    </p>
    <p>
     我们构造的必须满足
     <strong>
      可纳性
     </strong>
     :(其中
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
         
        
          ∗ 
         
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h^*(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord">
          <span class="mord mathdefault">
           h
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.688696em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mbin mtight">
                 ∗
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     表示结点
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        n 
        
       
      
        n
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     到终点的真实开销估计)
    </p>
    <p>
     可纳启发式函数不会过高估计结点到目标的代价, 此时算法的解是最优的，
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     越接近
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
         
        
          ∗ 
         
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h^*(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord">
          <span class="mord mathdefault">
           h
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.688696em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mbin mtight">
                 ∗
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     ,效果越优。当
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
         = 
        
        
        
          h 
         
        
          ∗ 
         
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)=h^*(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.2777777777777778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.2777777777777778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord">
          <span class="mord mathdefault">
           h
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.688696em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mbin mtight">
                 ∗
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     时,算法的解是最优的，效果也是最优的。
     <br/>
     <img alt="在这里插入图片描述" height="500" src="https://i-blog.csdnimg.cn/blog_migrate/8d35115616b00f05410d7ddd044da18e.jpeg#pic_center" width="800"/>
     <br/>
     几篇写得不错的参考文章：
     <br/>
     <a href="https://www.pianshen.com/article/15731236974/" rel="nofollow">
      Dijkstra算法和A* 算法总结
     </a>
     <br/>
     <a href="https://zhiqianghe.blog.csdn.net/article/details/104211475" rel="nofollow">
      启发式搜索 (Heuristically Search)-【贪婪最佳优先搜索】和【A*搜索】
     </a>
    </p>
    <hr color="#000000" size='1"'/>
    <h5>
     <a id="hn_551">
     </a>
     八数码问题构造启发函数
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     实例
    </h5>
    <h6>
     <a id="_552">
     </a>
     欧式距离法
    </h6>
    <blockquote>
     <p>
      <strong>
       欧式距离
      </strong>
      : 初始状态中的每一个棋子位置与目标状态的相应棋子位置的
      <strong>
       几何距离
      </strong>
     </p>
    </blockquote>
    <p>
     例如：
     <strong>
      初始状态
     </strong>
     的6和
     <strong>
      目标状态
     </strong>
     的6相差了1个单位距离，
     <strong>
      初始状态
     </strong>
     的8和
     <strong>
      目标状态
     </strong>
     的8相差了
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        2 
         
        
       
      
        \sqrt{2}
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1.04em; vertical-align: -0.13278em;">
         </span>
         <span class="mord sqrt">
          <span class="vlist-t vlist-t2">
           <span class="vlist-r">
            <span class="vlist" style="height: 0.90722em;">
             <span class="svg-align" style="top: -3em;">
              <span class="pstrut" style="height: 3em;">
              </span>
              <span class="mord" style="padding-left: 0.833em;">
               <span class="mord">
                2
               </span>
              </span>
             </span>
             <span class="" style="top: -2.86722em;">
              <span class="pstrut" style="height: 3em;">
              </span>
              <span class="hide-tail" style="min-width: 0.853em; height: 1.08em;">
               <svg height="1.08em" preserveaspectratio="xMinYMin slice" viewbox="0 0 400000 1080" width="400em">
                <path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z">
                </path>
               </svg>
              </span>
             </span>
            </span>
            <span class="vlist-s">
             ​
            </span>
           </span>
           <span class="vlist-r">
            <span class="vlist" style="height: 0.13278em;">
             <span class="">
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
     个单位距离
     <br/>
     因此我们的启发函数就是去找出
     <strong>
      当前状态
     </strong>
     所有不在
     <strong>
      目标位置
     </strong>
     的棋子，它们距离目标位置的
     <strong>
      欧式距离之和
     </strong>
     就是当前状态到目标状态的
     <strong>
      开销估计代价
     </strong>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/31f16975564c8b260590bdfd1eaf604e.png#pic_center"/>
    </p>
    <h6>
     <a id="_559">
     </a>
     曼哈顿距离法
    </h6>
    <blockquote>
     <p>
      <strong>
       曼哈顿距离
      </strong>
      : 初始状态中的每一个棋子位置与目标状态的相应棋子位置的
      <strong>
       网格线距离
      </strong>
     </p>
    </blockquote>
    <p>
     <a href="https://blog.csdn.net/C20190413/article/details/75156509?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-7.control">
      图片来源
     </a>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a68dd579e1de5456ca87e9130925a418.png#pic_center"/>
     <br/>
     同理我们可以得到以
     <strong>
      曼哈顿距离
     </strong>
     计算的
     <strong>
      开销估计代价
     </strong>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        h 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        h(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault">
          h
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     。
    </p>
    <p>
     它们的代码实现也非常简单，我们只需要找出
     <strong>
      当前状态
     </strong>
     所有不在
     <strong>
      目标位置
     </strong>
     的棋子坐标，分别计算与目标坐标的距离再求和即可
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/052c1d46c253a7839d1a2dc686b54073.png#pic_center"/>
     <br/>
     支持我们就构建好了
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        A 
         
        
          ∗ 
         
        
       
      
        A^*
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.688696em; vertical-align: 0em;">
         </span>
         <span class="mord">
          <span class="mord mathdefault">
           A
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.688696em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mbin mtight">
                 ∗
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
     算法的两种估价函数,我们使用前面提到的
     <strong>
      python标准库的queue模块优先队列
     </strong>
     作为Open表进行存储，它在新状态入队存储时会自动根据我们设定的
     <a href="https://blog.csdn.net/besmarterbestronger/article/details/101217761">
      富比较
     </a>
     方法进行排序。
    </p>
    <p>
     为了帮助初学者，我写了下面这个小demo，初学者可以尝试跑一跑代码理解一下。
    </p>
    <pre><code class="prism language-python"><span class="token comment">#@desc: 实验python中的富比较方法,__lt__, __gt__, __le__, __ge__, __eq__, __ne__这6个富比较方法</span>
<span class="token keyword">import</span> queue
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
    
    <span class="token comment"># 可以理解为：用户指定排序方法，教计算机比较大小的准则</span>
    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'调用Test的__lt__方法'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>value

    <span class="token keyword">def</span> <span class="token function">__gt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'调用Test的__gt__方法'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>value <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>value
    
    <span class="token keyword">def</span> <span class="token function">test_a</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>

<span class="token comment"># 优先队列</span>
q <span class="token operator">=</span> queue<span class="token punctuation">.</span>PriorityQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>Test<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>Test<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>Test<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 观察输出顺序，值低的会先出来，说明优先队列中从小到大进行排序</span>
q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>test_a<span class="token punctuation">(</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>test_a<span class="token punctuation">(</span><span class="token punctuation">)</span>
q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>test_a<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <hr color="#000000" size='1"'/>
    <p>
     接下来我们可以给出我们的对于八数码问题的解决方法
     <br/>
     我们通过一个优先队列来实现
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        A 
         
        
          ∗ 
         
        
       
      
        A^*
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.688696em; vertical-align: 0em;">
         </span>
         <span class="mord">
          <span class="mord mathdefault">
           A
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.688696em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mbin mtight">
                 ∗
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
     算法，每一个状态入队都会根据该状态的
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.10764em;">
          f
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     进行排序入队，整个Open表会根据
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.10764em;">
          f
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     从小到大排序状态，因此我们每一次取出的队头元素都是目前队列中估价
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        f 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        f(n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.10764em;">
          f
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathdefault">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     最低的状态。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/625fadd6321089e264fc7c949f63acee.png"/>
     <br/>
     新状态入队：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d17ed6053db1ed174aa233e07ceb0cb1.png"/>
    </p>
    <hr color="#000000" size='1"'/>
    <p>
     至此我们可以给出完整的八数码解决方案
    </p>
    <pre><code class="prism language-python"><span class="token triple-quoted-string string">"""
@Author: XDT
@last_edit_time: 2021-04-07
@version: python 3.6.9
@Description:本程序分别输出四种方法(BFS,DFS,A*_Euclidean,A*_Manhattan)解决用户八数码问题的搜索结果
@Input:手动输入初始状态和目标状态、深度优先搜索的最大搜索深度
@Input_example:
最小深度31层                    最小23层                       最小18层
初始状态: 2 6 4 1 3 7 0 5 8     初始状态: 1 2 3 4 5 6 7 8 0    初始状态: 2 7 3 6 0 4 5 8 1
目标状态: 8 1 5 7 3 6 4 0 2     目标状态: 2 0 4 8 6 5 3 1 7    目标状态: 1 2 3 8 0 4 7 6 5
"""</span>

<span class="token keyword">import</span> time
<span class="token keyword">import</span> queue
<span class="token keyword">from</span> math <span class="token keyword">import</span> sqrt

<span class="token comment"># State是一个类,data:数据列表存储9个数字以及初始状态到这个状态的操作序列</span>
<span class="token comment"># f_distance表示该状态到目标状态的估价(gn+hn)</span>
<span class="token comment"># 注意:我们只在使用A*算法时才使用State类作为数据结构,放入优先队列</span>
<span class="token keyword">class</span> <span class="token class-name">State</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> f_distance<span class="token punctuation">)</span><span class="token punctuation">:</span>
		self<span class="token punctuation">.</span>data <span class="token operator">=</span> data
		self<span class="token punctuation">.</span>f_distance <span class="token operator">=</span> f_distance

	<span class="token comment"># 富比较,用户指定类的排序方法</span>
	<span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> self<span class="token punctuation">.</span>f_distance <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>f_distance


<span class="token comment"># @Function: 计算f(n) = f_distance = g_distance + h_distance</span>
<span class="token comment"># @Parameter: state是每一个状态数据列表,数据列表存储9个数字以及初始状态到这个状态的操作序列(上面定义的状态类中的data)</span>
<span class="token comment">#           : purpose是目标状态</span>
<span class="token comment">#           : method是方法 如:欧式距离法,曼哈顿距离法</span>
<span class="token keyword">def</span> <span class="token function">calculate_h_distance</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> purpose<span class="token punctuation">,</span> methods<span class="token punctuation">)</span><span class="token punctuation">:</span>
	g_distance <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span>
	state <span class="token operator">=</span> state<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span>
	h_distance <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> index_cur <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span> state<span class="token punctuation">[</span>index_cur<span class="token punctuation">]</span> <span class="token operator">!=</span> purpose<span class="token punctuation">[</span>index_cur<span class="token punctuation">]</span><span class="token punctuation">:</span>
			<span class="token comment"># 获取该数字在当前状态的位置坐标</span>
			x_cur <span class="token operator">=</span> index_cur <span class="token operator">%</span> <span class="token number">3</span>
			y_cur <span class="token operator">=</span> index_cur <span class="token operator">/</span> <span class="token number">3</span>
			<span class="token comment"># 找到该数字在目标状态的索引</span>
			index_pur <span class="token operator">=</span> purpose<span class="token punctuation">.</span>index<span class="token punctuation">(</span>state<span class="token punctuation">[</span>index_cur<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token comment"># 获取该数字在目标状态的位置坐标</span>
			x_pur <span class="token operator">=</span> index_pur <span class="token operator">%</span> <span class="token number">3</span>
			y_pur <span class="token operator">=</span> index_pur <span class="token operator">/</span> <span class="token number">3</span>
			<span class="token comment"># 根据用户要求的方法计算距离</span>
			<span class="token keyword">if</span> methods <span class="token operator">==</span> <span class="token string">"A*_Euclidean"</span><span class="token punctuation">:</span>
				h_distance <span class="token operator">+=</span> sqrt<span class="token punctuation">(</span><span class="token punctuation">(</span>x_cur <span class="token operator">-</span> x_pur<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y_cur <span class="token operator">-</span> y_pur<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>
			<span class="token keyword">elif</span> methods <span class="token operator">==</span> <span class="token string">"A*_Manhattan"</span><span class="token punctuation">:</span>
				h_distance <span class="token operator">+=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>x_cur <span class="token operator">-</span> x_pur<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>y_cur <span class="token operator">-</span> y_pur<span class="token punctuation">)</span>
	<span class="token keyword">return</span> g_distance <span class="token operator">+</span> h_distance

<span class="token comment"># @Function: 计算逆序数</span>
<span class="token comment"># @Parameter: state是存储每个状态的数据列表(九个字符型数字的列表)</span>
<span class="token keyword">def</span> <span class="token function">calculate_reverse_number</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	state<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
	<span class="token comment"># reverse_number用来记录逆序数</span>
	reverse_number <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> cur <span class="token keyword">in</span> state<span class="token punctuation">:</span>
		index <span class="token operator">=</span> state<span class="token punctuation">.</span>index<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		<span class="token comment"># 遍历cur后面的数字</span>
		<span class="token keyword">for</span> after_cur <span class="token keyword">in</span> state<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> cur <span class="token operator">&gt;</span> after_cur<span class="token punctuation">:</span>
				reverse_number <span class="token operator">+=</span> <span class="token number">1</span>
	<span class="token keyword">if</span> reverse_number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token number">1</span>


<span class="token comment"># @Function: 判断初始状态到目标状态是否有解</span>
<span class="token comment"># @Parameter: initial 初始状态数据列表</span>
<span class="token comment">#             purpose 目标状态数据列表</span>
<span class="token keyword">def</span> <span class="token function">judge_solvable</span><span class="token punctuation">(</span>initial<span class="token punctuation">,</span> purpose<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> initial <span class="token operator">==</span> purpose<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"起始状态为目标状态!"</span><span class="token punctuation">)</span>
		exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	initial_rev_num <span class="token operator">=</span> calculate_reverse_number<span class="token punctuation">(</span>initial<span class="token punctuation">)</span>
	purpose_rev_num <span class="token operator">=</span> calculate_reverse_number<span class="token punctuation">(</span>purpose<span class="token punctuation">)</span>
	<span class="token keyword">if</span> initial_rev_num <span class="token operator">!=</span> purpose_rev_num<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无法到达!"</span><span class="token punctuation">)</span>
		exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># @Function: 判断当前状态是否已经被访问</span>
<span class="token comment"># @Parameter: state是每一个状态数据列表,数据列表存储9个数字以及初始状态到这个状态的操作序列(上面定义的状态类中的data)</span>
<span class="token comment">#           : enqueued 字典 用来记录已经入队过的状态</span>
<span class="token comment">#           : key表示当前状态,value表示是否入队 1已经入队,0未入队</span>
enqueued <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment"># E.G  {'123405678':1,'123405687':1}</span>
<span class="token keyword">def</span> <span class="token function">is_visited</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">global</span> max_layers
	state_key <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>state<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token comment"># 获取当前状态的层数</span>
	cur_layer <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span>

	<span class="token comment"># 字典get方法: 在字典中寻找state,找到则返回字典的值,找不到则返回默认值0</span>
	<span class="token keyword">if</span> enqueued<span class="token punctuation">.</span>get<span class="token punctuation">(</span>state_key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># 对于DFS:判断当前的层数是否比已经入队的那个状态更低(浅),如果是的话则需要入队</span>
		<span class="token keyword">if</span> cur_layer <span class="token operator">&lt;</span> enqueued<span class="token punctuation">.</span>get<span class="token punctuation">(</span>state_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
			enqueued<span class="token punctuation">[</span>state_key<span class="token punctuation">]</span> <span class="token operator">=</span> cur_layer
			<span class="token keyword">return</span> <span class="token boolean">False</span>
		<span class="token comment"># 已经访问过</span>
		<span class="token keyword">return</span> <span class="token boolean">True</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token comment"># 如果判断为未访问过,下一步要入队,直接在这里更改,提高代码复用性</span>
		enqueued<span class="token punctuation">[</span>state_key<span class="token punctuation">]</span> <span class="token operator">=</span> cur_layer
		<span class="token keyword">return</span> <span class="token boolean">False</span>

<span class="token comment"># @Function: 寻找当前状态的所有下一步所有可行状态,将其加入队列</span>
<span class="token comment"># @Parameter: state是每一个状态数据列表,数据列表存储9个数字以及初始状态到这个状态的操作序列(上面定义的状态类中的data)</span>
<span class="token comment">#           : position_movable 字典用来记录空格所能移动的位置</span>
<span class="token comment">#           : key表示空格位置索引,value表示该位置所能移动到的位置列表</span>
position_movable <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    <span class="token number">7</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
<span class="token keyword">def</span> <span class="token function">find_next_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">global</span> create_point<span class="token punctuation">,</span> Open<span class="token punctuation">,</span> method<span class="token punctuation">,</span> methods_dict
	<span class="token comment"># 找到空格(0)的位置,并获取该位置所能移动的位置列表</span>
	space_index <span class="token operator">=</span> state<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
	list_position_movable <span class="token operator">=</span> position_movable<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>

	<span class="token comment"># 遍历所有能利用的位置</span>
	<span class="token keyword">for</span> position <span class="token keyword">in</span> list_position_movable<span class="token punctuation">:</span>
		temp <span class="token operator">=</span> state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
		temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>position<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">[</span>space_index<span class="token punctuation">]</span>
		<span class="token comment"># 未被访问过则入队</span>
		<span class="token keyword">if</span> <span class="token operator">not</span> is_visited<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token comment"># 记录空格移动的位置</span>
			<span class="token keyword">if</span> space_index <span class="token operator">==</span> position <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">:</span>
				temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"up"</span><span class="token punctuation">)</span>
			<span class="token keyword">elif</span> space_index <span class="token operator">==</span> position <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">:</span>
				temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">)</span>
			<span class="token keyword">elif</span> space_index <span class="token operator">==</span> position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
				temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"left"</span><span class="token punctuation">)</span>
			<span class="token keyword">elif</span> space_index <span class="token operator">==</span> position <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
				temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"right"</span><span class="token punctuation">)</span>
			<span class="token comment"># 当使用A*算法时:创建State类  使用bfs和dfs则直接用列表入队</span>
			<span class="token keyword">if</span> method <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">:</span>
				temp <span class="token operator">=</span> State<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> calculate_h_distance<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> purpose_state<span class="token punctuation">,</span> methods_dict<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
			create_point <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token comment"># @Function: 搜索:循环检测Open表</span>
<span class="token comment"># @Parameter: method_index是当前使用的方法的索引,也就是methods_dict的key</span>
<span class="token comment">#           : methods_dict = {1: "BFS", 2: "DFS", 3: "A*_Euclidean", 4: "A*_Manhattan"}</span>
<span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>method_index<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">global</span> Open<span class="token punctuation">,</span> search_point<span class="token punctuation">,</span> create_point<span class="token punctuation">,</span> methods_dict
	<span class="token comment"># 开始搜索</span>
	start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span> Open<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token comment"># open表空说明已经搜索完所有可能状态,未找到解</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"使用"</span><span class="token punctuation">,</span> methods_dict<span class="token punctuation">[</span>method_index<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"算法未找到解!\n"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token comment"># 取出队头元素(如果是A*算法,Open表中存储的是一个类) get是queue的方法:返回并删除队头元素</span>
		<span class="token keyword">if</span> method_index <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">:</span>
			queue_first <span class="token operator">=</span> Open<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>data
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			queue_first <span class="token operator">=</span> Open<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token comment"># 判断是否是目标状态,是则输出信息,退出</span>
		<span class="token keyword">if</span> queue_first<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">==</span> purpose_state<span class="token punctuation">:</span>
			end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
			search_point <span class="token operator">+=</span> <span class="token number">1</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"使用"</span><span class="token punctuation">,</span> methods_dict<span class="token punctuation">[</span>method_index<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"算法搜索成功!结果如下:"</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前层次：{},已搜索节点数:{},已生成结点数{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>queue_first<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">,</span> search_point<span class="token punctuation">,</span> create_point<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"空格的移动路径依次为："</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span> i <span class="token keyword">in</span> queue_first<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
				<span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'-&gt;'</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'消耗时间:{} Seconds'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"\n"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		search_point <span class="token operator">+=</span> <span class="token number">1</span>
		<span class="token comment"># 不是目标状态,本状态的所有下一步可能状态入队 (其中DFS需要判断是否到达最大深度)</span>
		cur_layers <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue_first<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">9</span>
		<span class="token keyword">if</span> method_index <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> cur_layers <span class="token operator">&lt;</span> max_layers<span class="token punctuation">:</span>
				find_next_state<span class="token punctuation">(</span>queue_first<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			find_next_state<span class="token punctuation">(</span>queue_first<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎使用本程序,本程序输出四种方法(BFS,DFS,A*_Euclidean,A*_Manhattan)的搜索结果,部分搜索可能会稍慢,请耐心等待程序运行完毕!"</span><span class="token punctuation">)</span>
	initial_state <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入初始状态：'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	purpose_state <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入目标状态：'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	max_layers <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'请输入最大搜索深度(仅用于DFS):'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment"># 判断是否可以到达,如果不可以到达,则直接退出</span>
	judge_solvable<span class="token punctuation">(</span>initial_state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> purpose_state<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	methods_dict <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">"BFS"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token string">"DFS"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">"A*_Euclidean"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token string">"A*_Manhattan"</span><span class="token punctuation">}</span>
	<span class="token comment">#分别使用四种方法进行搜索,展示搜索结果</span>
	<span class="token keyword">for</span> method<span class="token punctuation">,</span> method_name <span class="token keyword">in</span> methods_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># search_point为搜索的节点数 (已经经过判断,确认过不是目标状态的状态,入队然后检测删除的节点)</span>
		<span class="token comment"># create_point为生成节点数 (加入队列中的所有状态)</span>
		search_point <span class="token operator">=</span> create_point <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token comment"># 初始状态入队</span>
		create_point <span class="token operator">+=</span> <span class="token number">1</span>
		enqueued<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

		<span class="token keyword">if</span> method <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
			<span class="token comment"># Open队列 用来存储生成节点</span>
			Open <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span>
			search<span class="token punctuation">(</span>method<span class="token punctuation">)</span>

		<span class="token keyword">elif</span> method <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
			<span class="token comment"># Open栈 用来存储生成节点</span>
			Open <span class="token operator">=</span> queue<span class="token punctuation">.</span>LifoQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>initial_state<span class="token punctuation">)</span>
			search<span class="token punctuation">(</span>method<span class="token punctuation">)</span>

		<span class="token keyword">else</span><span class="token punctuation">:</span>
			<span class="token comment"># Open优先队列 用来存储生成节点</span>
			Open <span class="token operator">=</span> queue<span class="token punctuation">.</span>PriorityQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>
			Open<span class="token punctuation">.</span>put<span class="token punctuation">(</span>State<span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> calculate_h_distance<span class="token punctuation">(</span>initial_state<span class="token punctuation">,</span> purpose_state<span class="token punctuation">,</span> methods_dict<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			search<span class="token punctuation">(</span>method<span class="token punctuation">)</span>

		enqueued<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 每一次搜索完毕,清空字典和open表</span>
		Open<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      测试案例：
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7cdfa79bd6180b1fedf88abe1522dbf4.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0294560d95a21dd2fd5f07e90f4ddad0.png"/>
    </p>
    <h2>
     <a id="_837">
     </a>
     总结
    </h2>
    <ul>
     <li>
      <p>
       <strong>
        深度优先搜索优缺点
       </strong>
       <br/>
       <strong>
        ①优点
       </strong>
       ：优先搜索一棵子树，然后是另一棵，所以和宽度优先搜索对比，有着平均消耗内存相对较少的优点，在一定条件下消耗时间会很少（搜索方向和解大致一致时很快）。
       <br/>
       <strong>
        ②缺点
       </strong>
       ：要多次回溯遍历，会受到搜索顺序（初始方向）的影响，可能会搜索所有路径，在解深度很大的情况下效率不高。
      </p>
     </li>
     <li>
      <p>
       <strong>
        宽度优先搜索优缺点
       </strong>
       <br/>
       <strong>
        ①优点
       </strong>
       ：对于解决最短或最短路径问题特别有效，而且寻找深度小，每个结点只访问一遍，不需要回溯，结点总是以最短路径被访问，所以第二次路径确定不会比第一次短
       <br/>
       <strong>
        ②缺点
       </strong>
       ：平均内存耗费量相对深度优先搜索较大，在解深度很大时空间复杂度和时间复杂度都较高。
      </p>
     </li>
     <li>
      <p>
       <strong>
        贪婪算法
       </strong>
       是指在对问题求解时，一定程度利用了启发信息（例如路径查找时预估与目的地的距离），总是做出在当前看来是最好的选择，也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解，因此它可能找不到最短的路径，但也是一种启发式的方法，搜索效果十分受启发函数准确性的影响。
      </p>
     </li>
     <li>
      <p>
       <strong>
        A/A*算法
       </strong>
       <br/>
       对于问题的搜索过程，如果加上启发函数，不让它盲目的寻找，就衍生出很多启发式搜索算法。A* 是其中的一种。之所以加一个 * 号，是因为它的启发式函数是有限制的，这个限制确保它能找到绝对最优解，去掉这个限制，就是 A 算法了，所以A算法是有可能得不到最优解的。
       <br/>
       <strong>
        优点
       </strong>
       ：
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          A 
          
         
           ∗ 
          
         
        
          A*
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
           </span>
           <span class="mord mathdefault">
            A
           </span>
           <span class="mord">
            ∗
           </span>
          </span>
         </span>
        </span>
       </span>
       类似于Dijkstra和贪婪算法的结合体，它既考虑走过的真实代价，也考虑了预估代价，它比Dijkstra更具有启发性，不会过于盲目的搜索，也比贪婪算法更谨慎，不会太过于依赖启发函数的影响。它具有优势性，能找到最优解，平均消耗时间更低。
       <br/>
       <strong>
        缺点
       </strong>
       ：
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          A 
          
         
           ∗ 
          
         
        
          A*
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
           </span>
           <span class="mord mathdefault">
            A
           </span>
           <span class="mord">
            ∗
           </span>
          </span>
         </span>
        </span>
       </span>
       算法在搜索过程中需要相对准确且完整的启发信息，虽然在八数码问题中我们有多种距离构造的可纳性函数得到了不错的启发信息，但这在更泛化的搜索问题中其实是很难保证启发信息的可纳性的。（
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          D 
          
         
           ∗ 
          
         
        
          D*
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
           </span>
           <span class="mord mathdefault" style="margin-right: 0.02778em;">
            D
           </span>
           <span class="mord">
            ∗
           </span>
          </span>
         </span>
        </span>
       </span>
       算法：不完整启发信息搜索）
      </p>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


