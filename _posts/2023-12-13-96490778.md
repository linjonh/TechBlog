---
layout: post
title: FFmpeg学习之-一-音视频理论知识
date: 2023-12-13 11:22:00 +0800
description: 文章浏览阅读9k次，点赞5次，收藏19次。FFmpeg学习之 一 （音视频理论知识）1. 音视频理论
keywords: ffmpeg原理
categories: ['FFmpeg']
tags: ['音视频理论知识']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=96490778
    alt: FFmpeg学习之-一-音视频理论知识
artid: 96490778
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     FFmpeg学习之 一 （音视频理论知识）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      FFmpeg学习之 一 （音视频理论知识）
     </h4>
     <ul>
      <li>
       <a href="#1__1" rel="nofollow">
        1. 音视频理论知识
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#11__2" rel="nofollow">
          1.1 基本概念
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#111__4" rel="nofollow">
            1.1.1 音视频必备的基本概念
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_8" rel="nofollow">
              常用的视频封装格式
             </a>
            </li>
            <li>
             <a href="#_20" rel="nofollow">
              常用的视频编码器
             </a>
            </li>
            <li>
             <a href="#_32" rel="nofollow">
              常用的音频编程器：
             </a>
            </li>
            <li>
             <a href="#_YUV_36" rel="nofollow">
              视频流 裸数据YUV
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#112__304" rel="nofollow">
            1.1.2 音视频常见处理
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_305" rel="nofollow">
              采集
             </a>
            </li>
            <li>
             <a href="#_343" rel="nofollow">
              处理
             </a>
            </li>
            <li>
             <a href="#_352" rel="nofollow">
              编码
             </a>
            </li>
            <li>
             <a href="#_419" rel="nofollow">
              传输
             </a>
            </li>
            <li>
             <a href="#_430" rel="nofollow">
              解码
             </a>
            </li>
            <li>
             <a href="#_448" rel="nofollow">
              渲染
             </a>
            </li>
            <li>
             <a href="#_450" rel="nofollow">
              常用音频编码格式
             </a>
            </li>
            <li>
             <a href="#_452" rel="nofollow">
              常用视频编码格式
             </a>
            </li>
            <li>
             <a href="#_454" rel="nofollow">
              常用编解码算法
             </a>
            </li>
            <li>
             <a href="#_456" rel="nofollow">
              视频音频同步算法
             </a>
            </li>
            <li>
             <a href="#_465" rel="nofollow">
              录像
             </a>
            </li>
            <li>
             <a href="#_467" rel="nofollow">
              音频播放
             </a>
            </li>
            <li>
             <a href="#_469" rel="nofollow">
              视频播放
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#12___494" rel="nofollow">
          1.2 直播
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#121__495" rel="nofollow">
            1.2.1 推流
           </a>
          </li>
          <li>
           <a href="#1211__501" rel="nofollow">
            1.2.1.1 推流常用协议简介
           </a>
          </li>
          <li>
           <a href="#122__525" rel="nofollow">
            1.2.2 拉流
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#13_FFmpeg_532" rel="nofollow">
          1.3. FFmpeg简介
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="1__1">
     </a>
     1. 音视频理论知识
    </h2>
    <h3>
     <a id="11__2">
     </a>
     1.1 基本概念
    </h3>
    <p>
     <a href="http://ffmpeg.org/ffmpeg.html" rel="nofollow">
      FFmpeg官方文档
     </a>
    </p>
    <h4>
     <a id="111__4">
     </a>
     1.1.1 音视频必备的基本概念
    </h4>
    <h5>
     <a id="_8">
     </a>
     常用的视频封装格式
    </h5>
    <p>
     1）AVI 格式(后缀为 .avi)
     <br/>
     2）DV-AVI 格式(后缀为 .avi)
     <br/>
     3）QuickTime File Format 格式(后缀为 .mov)
     <br/>
     4）MPEG 格式(文件后缀可以是 .mpg .mpeg .mpe .dat .vob .asf .3gp .mp4等)
     <br/>
     5）WMV 格式(后缀为.wmv .asf)
     <br/>
     6）Real Video 格式(后缀为 .rm .rmvb)
     <br/>
     7）Flash Video 格式(后缀为 .flv)
     <br/>
     8）Matroska 格式(后缀为 .mkv)
     <br/>
     9）MPEG2-TS 格式 (后缀为 .ts)
    </p>
    <h5>
     <a id="_20">
     </a>
     常用的视频编码器
    </h5>
    <p>
     1）H.264/AVC
     <br/>
     2）HEVC/H.265
     <br/>
     3）VP8
     <br/>
     4）VP9
     <br/>
     5）
     <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
      FFmpeg
     </a>
    </p>
    <blockquote>
     <p>
      FFmpeg 是一个开源框架，可以运行音频和视频多种格式的录影、转换、流功能，包含了 libavcodec: 这是一个用于多个项目中音频和视频的解码器库，以及 libavformat 一个音频与视频格式转换库。
      <br/>
      目前支持 Linux ,Mac OS,Windows 三个主流的平台，也可以自己编译到 Android 或者 iOS 平台。
      <br/>
      如果是 Mac OS ，可以通过 brew 安装 brew install ffmpeg --with-libvpx --with-libvorbis --with-ffplay
     </p>
    </blockquote>
    <h5>
     <a id="_32">
     </a>
     常用的音频编程器：
    </h5>
    <p>
     Mp3
     <br/>
     AAC
    </p>
    <h5>
     <a id="_YUV_36">
     </a>
     视频流 裸数据YUV
    </h5>
    <ol>
     <li>
      <p>
       YUV简介
       <br/>
       YUV虽说是视频帧的裸数据，YUV数据是不能直接用于渲染，还是要转换为RGB的形式才可以渲染，YUV主要应用于优化彩色视频信号的传输。YUV应该是RGB存储形式和编码存储的一种折衷吧。YUV比RGB省空间，有没有编码后数据那么耗内存去解码，只要简单作个转换就可以变成RGB信号。
      </p>
     </li>
     <li>
      <p>
       YUV视频渲染方式
       <br/>
       一个图像最终要变成RGB的表现方式才可以渲染到显示屏上。而一个RGB形式的图片是超级耗空间，所以编程时注意bitmap对象的回收。我们可以通过yuv转化为RGB图片显示，但这种方式非常消耗CPU性能。一般都通过opengl文理利用GPU直接渲染，这样对CPU的消耗就会少很多。
       <br/>
       具体YUV怎么通过openGL渲染请参考我的另一篇博客：
       <br/>
       <a href="https://blog.csdn.net/kyl282889543/article/details/96490933">
        FFmpeg学习之二 （yuv视频渲染）
       </a>
      </p>
     </li>
     <li>
      <p>
       RGB 和 YUV的区别
      </p>
     </li>
    </ol>
    <ul>
     <li>
      <p>
       RGB
       <br/>
       我们先来看一下RGB的定义：
       <br/>
       RGB是红绿蓝三原色的意思，R=Red、G=Green、B=Blue。
       <br/>
       计算机显示彩色图像的时，最终显示的时候，要控制一个像素中Red,Green,Blue的值，来确定这个像素的颜色。计算机中无法模拟连续的存储从最暗到最亮的量值，而只能以数字的方式表示。于是，结合人眼睛的敏感程度，使用3个字节（3*8位）来分别表示一个像素里面的Red,Green和Blue的发光强度数值，这就是常见的RGB格式。我们可以打开画图板，在自定义颜色工具框中，输入r,g,b值，得到不同的颜色。
       <br/>
       但是对于视频捕获和编解码等应用来讲，这样的表示方式数据量太大了。需要想办法在不太影响感觉的情况下，对原始数据的表示方法进行更改，减少数据量。
       <br/>
       无论中间处理过程怎样，最终都是为了展示给人观看，这样的更改，也是从人眼睛的特性出发，和发明RGB三原色表示方法的出发点是一样的。
       <br/>
       于是我们使用Y,Cb,Cr模型来表示颜色。Iain的书中写道：The human visual system (HVS) is less sensitive to colour than to luminance (brightness).人类视觉系统（其实就是人的眼睛）对亮度的感觉比对颜色更加敏感。
       <br/>
       在RGB色彩空间中，三个颜色的重要程度相同，所以需要使用相同的分辨率进行存储，最多使用RGB565这样的形式减少量化的精度，但是3个颜色需要按照相同的分辨率进行存储，数据量还是很大的。所以，利用人眼睛对亮度比对颜色更加敏感，将图像的亮度信息和颜色信息分离，并使用不同的分辨率进行存储，这样可以在对主观感觉影响很小的前提下，更加有效的存储图像数据。
      </p>
     </li>
     <li>
      <p>
       YUV
       <br/>
       YCbCr色彩空间和它的变形（有时被称为YUV）是最常用的有效的表示彩色图像的方法。Y是图像的亮度（luminance/luma）分量，使用以下公式计算，为R,G,B分量的加权平均值：
      </p>
     </li>
    </ul>
    <pre><code> Y = kr R + kgG + kbB
        其中k是权重因数。
        上面的公式计算出了亮度信息，还有颜色信息，使用色差（color difference/chrominance或chroma）来表示，其中每个色差分量为R,G,B值和亮度Y的差值：
　　Cb = B －Y
　　Cr = R －Y
        Cg = G－ Y
        其中，Cb+Cr+Cg是一个常数（其实是一个关于Y的表达式），所以，只需要其中两个数值结合Y值就能够计算出原来的RGB值。所以，我们仅保存亮度和蓝色、红色的色差值，这就是(Y,Cb,Cr)。
相比RGB色彩空间，YCbCr色彩空间有一个显著的优点。Y的存储可以采用和原来画面一样的分辨率，但是Cb,Cr的存储可以使用更低的分辨率。这样可以占用更少的数据量，并且在图像质量上没有明显的下降。所以，将色彩信息以低于量度信息的分辨率来保存是一个简单有效的图像压缩方法。
在COLOUR SPACES .17 ITU-R recommendation BT.601 中，建议在计算Y时，权重选择为kr=0.299,kg=0.587,kb=0.114。于是常用的转换公式如下：
Y = 0.299R + 0.587G + 0.114B
Cb = 0.564(B － Y )
Cr = 0.713(R － Y )
R = Y + 1.402Cr
G = Y - 0.344Cb - 0.714Cr
B = Y + 1.772Cb

</code></pre>
    <p>
     有了上面这个公式，我们就能够将一幅RGB画面转换成为YUV画面了，反过来也可以。
    </p>
    <p>
     下面将画面数据究竟是以什么形式存储起来的。
    </p>
    <blockquote>
     <p>
      在RGB24格式中，对于宽度为w,高度为h的画面，需要w
      <em>
       h
      </em>
      3个字节来存储其每个像素的rgb信息，画面的像素数据是连续排列的。按照r(0,0),g(0,0),b(0,0);r(0,1),g(0,1),b(0,1);…;r(w-1,0),g(w-1,0),b(w-1,0);…;r(w-1,h-1),g(w-1,h-1),b(w-1,h-1)这样的顺序存放起来。
      <br/>
      在YUV格式中，以YUV420格式为例。宽度为w高度为h的画面，其亮度Y数据需要w
      <em>
       h个字节来表示（每个像素点一个亮度）。而Cb和Cr数据则是画面中4个像素共享一个Cb,Cr值。这样Cb用w
      </em>
      h/4个字节，Cr用w
      <em>
       h/4个字节。
       <br/>
       YUV文件中，把多个帧的画面连续存放。就是YUV YUV YUV……这样的不断连续的形式，而其中每个YUV，就是一幅画面。
       <br/>
       在这单个YUV中，前w
      </em>
      h个字节是Y数据，接着的w
      <em>
       h/4个字节是Cb数据，再接着的w
      </em>
      h/4个字节为Cr数据。
      <br/>
      在由这样降低了分辨率的数据还原出RGB数据的时候，就要依据像素的位置找到它对应的Y,Cb,Cr值，其中Y值最好找到，像素位置为x,y的话，Y数据中第y
      <em>
       width+x个数值就是它的Y值。Cb和Cr由于是每2x2像素的画面块拥有一个，这样Cb和Cr数据相当于两个分辨率为w/2 * h/2的画面，那么原来画面中的位置为x,y的像素，在这样的低分辨率画面中的位置是x/2,y/2，属于它的Cb,Cr值就在这个地方：(y/2)
      </em>
      (width/2)+(x/2)。
      <br/>
      为了直观起见，再下面的图中，分别将Y画面(Cb,Cr=0)和Cb,Cr画面(Y=128)显示出来，可见Cb,Cr画面的分辨率是Y画面的1/4。但是合成一个画面之后，我们的眼睛丝毫感觉不到4个像素是共用一个Cb,Cr的。
     </p>
    </blockquote>
    <p>
     <strong>
      Cb,Cr画面
     </strong>
    </p>
    <blockquote>
     <p>
      将Cb,Cr画面放大观察，里面颜色相同的块都是2x2大小的。
      <br/>
      附件为Windows Mobile上使用公式进行YUV到RGB转换的程序。其中需要注意的是Cb,Cr在计算过程中是会出现负数的，但是从-128到127这些数值都用一个字节表示，读取的时候就映射0到255这个区间，成为了无符号的值，所以要减去128，才能参与公式计算。这样的运算有浮点运算，效率是比较低的，所以要提高效率的话，一般在实用程序中使用整数计算或者查表法来代替。还有，运算后的r,g,b可能会超过0-255的区间，作一个判断进行调整就可以了。
     </p>
    </blockquote>
    <p>
     <strong>
      什么是YUV/YCbCr/YPbPr？
     </strong>
    </p>
    <blockquote>
     <p>
      亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视颜色系统和格式不同，两种色度信号经常被称作U和V或Pb和Pr或Cb和Cr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色）
     </p>
    </blockquote>
    <p>
     <strong>
      yuv中什么是4:4:4、4:2:2、4:2:0？
     </strong>
    </p>
    <blockquote>
     <p>
      在最近十年中，视频工程师发现人眼对色度的敏感程度要低于对亮度的敏感程度。在生理学中，有一条规律，那就是人类视网膜上的视网膜杆细胞要多于视网膜锥细胞，说得通俗一些，视网膜杆细胞的作用就是识别亮度，而视网膜锥细胞的作用就是识别色度。所以，你的眼睛对于亮和暗的分辨要比对颜色的分辨精细一些。正是因为这个，在我们的视频存储中，没有必要存储全部颜色信号。既然眼睛看不见，那为什么要浪费存储空间（或者说是金钱）来存储它们呢？
      <br/>
      像Beta或VHS之类的消费用录像带就得益于将录像带上的更多带宽留给黑—白信号（被称作“亮度”），将稍少的带宽留给彩色信号（被称作“色度”）。
      <br/>
      在MPEG2（也就是DVD使用的压缩格式）当中，Y、Cb、Cr信号是分开储存的（这就是为什么分量视频传输需要三条电缆）。其中Y信号是黑白信号，是以全分辨率存储的。但是，由于人眼对于彩色信息的敏感度较低，色度信号并不是用全分辨率存储的。
      <br/>
      色度信号分辨率最高的格式是4:4:4，也就是说，每4点Y采样，就有相对应的4点Cb和4点Cr。换句话说，在这种格式中，色度信号的分辨率和亮度信号的分辨率是相同的。这种格式主要应用在视频处理设备内部，避免画面质量在处理过程中降低。当图像被存储到Master Tape，比如D1或者D5，的时候，颜色信号通常被削减为4:2:2。
      <br/>
      其次就是4:2:2，就是说，每4点Y采样，就有2点Cb和2点Cr。在这种格式中，色度信号的扫描线数量和亮度信号一样多，但是每条扫描线上的色度采样点数却只有亮度信号的一半。当4:2:2信号被解码的时候，“缺失”的色度采样，通常由一定的内插补点算法通过它两侧的色度信息运算补充。
      <br/>
      看 4:2:2格式亮度、色度采样的分布情况。在这里，每个象素都有与之对应的亮度采样，同时一半的色度采样被丢弃，所以我们看到，色度采样信号每隔一个采样点才有一个。当着张画面显示的时候，缺少的色度信息会由两侧的颜色通过内插补点的方式运算得到。就像上面提到的那样，人眼对色度的敏感程度不如亮度，大多数人并不能分辨出4:2:2和4:4:4颜色构成的画面之间的不同。
      <br/>
      色度信号分辨率最低的格式，也就是DVD所使用的格式，就是4:2:0了。事实上4:2:0是一个混乱的称呼，按照字面上理解，4:2:0应该是每4点Y采样，就有2点Cb和0点Cr，但事实上完全不是这样。事实上，4:2:0的意思是，色度采样在每条横向扫描线上只有亮度采样的一半，扫描线的条数上，也只有亮度的一半！换句话说，无论是横向还是纵向，色度信号的分辨率都只有亮度信号的一半。举个例子，如果整张画面的尺寸是720
      <em>
       480，那么亮度信号是720
      </em>
      480，色度信号只有360*240。在 4:2:0中，“缺失”的色度采样不单单要由左右相邻的采样通过内插补点计算补充，整行的色度采样也要通过它上下两行的色度采样通过内插补点运算获得。这样做的原因是为了最经济有效地利用DVD的存储空间。诚然，4:4:4的效果很棒，但是如果要用4:4:4存储一部电影，我们的DVD盘的直径至少要有两 英尺（六十多厘米）！
      <br/>
      概念上4:2:0颜色格式非交错画面中亮度、色度采样信号的排列情况。同4:2:2格式一样，每条扫描线中，只有一半的色度采样信息。与4:2:2不同的是，不光是横向的色度信息被“扔掉”了一半，纵向的色度信息也被“扔掉”了一半，整个屏幕中色度采样只有亮度采样的四分之一。请注意，在4:2:0颜色格式中，色度采样被放在了两条扫描线中间。
     </p>
    </blockquote>
    <p>
     <strong>
      什么是YV12，什么是YUY2？
     </strong>
    </p>
    <blockquote>
     <p>
      YUV 格式通常有两大类：打包（ packed ）格式和平面（ planar ）格式。前者将 YUV 分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素（ macro-pixel ）；而后者使用三个数组分开存放 YUV 三个分量，就像是一个三维平面一样。表 2.3 中的 YUY2 到 Y211 都是打包格式，而 IF09 到 YVU9 都是平面格式。（注意：在介绍各种具体格式时，
      <br/>
      YUV 各分量都会带有下标，如 Y0 、 U0 、 V0 表示第一个像素的YUV 分量， Y1 、 U1 、 V1 表示第二个像素的 YUV 分量，以此类推。） YUY2 （和 YUYV ）格式为每个像素保留 Y 分量，而 UV 分量在水平方向上每两个像素采样一次。一个宏像素为 4 个字节，实际表示 2 个像素。（ 4:2:2 的意思为一个宏像素中有 4 个 Y 分量、 2 个 U 分量和 2个 V 分量。）图像数据中 YUV 分量排列顺序如下：
      <br/>
      Y0 U0 Y1 V0 Y2 U2 Y3 V2 …
     </p>
    </blockquote>
    <blockquote>
     <p>
      YVYU 格式跟 YUY2 类似，只是图像数据中 YUV 分量的排列顺序有所不同：
      <br/>
      Y0 V0 Y1 U0 Y2 V2 Y3 U2 …
     </p>
    </blockquote>
    <blockquote>
     <p>
      UYVY 格式跟 YUY2 类似，只是图像数据中 YUV 分量的排列顺序有所不同：
      <br/>
      U0 Y0 V0 Y1 U2 Y2 V2 Y3 …
      <br/>
      AYUV 格式带有一个 Alpha 通道，并且为每个像素都提取 YUV 分量，图像数据格式如下：
      <br/>
      A0 Y0 U0 V0 A1 Y1 U1 V1 …
     </p>
    </blockquote>
    <blockquote>
     <p>
      Y41P （和 Y411 ）格式为每个像素保留 Y 分量，而 UV 分量在水平方向上每 4 个像素采样一次。一个宏像素为 12 个字节，实际表示 8 个像素。图像数据中 YUV 分量排列顺序如下：
      <br/>
      U0 Y0 V0 Y1 U4 Y2 V4 Y3 Y4 Y5 Y6 Y8 …
     </p>
    </blockquote>
    <blockquote>
     <p>
      Y211 格式在水平方向上 Y 分量每 2 个像素采样一次，而 UV 分量每 4 个像素采样一次。一个宏像素为 4 个字节，实际表示 4 个像素。图像数据中 YUV 分量排列顺序如下：
      <br/>
      Y0 U0 Y2 V0 Y4 U4 Y6 V4 …
     </p>
    </blockquote>
    <blockquote>
     <p>
      YVU9 格式为每个像素都提取 Y 分量，而在 UV 分量的提取时，首先将图像分成若干个 4 x 4 的宏块，然后每个宏块提取一个 U 分量和一个 V 分量。图像数据存储时，首先是整幅图像的 Y 分量数组，然后就跟着 U 分量数组，以及 V 分量数组。 IF09 格式与 YVU9 类似。
     </p>
    </blockquote>
    <blockquote>
     <p>
      IYUV 格式为每个像素都提取 Y 分量，而在 UV 分量的提取时，首先将图像分成若干个 2 x 2 的宏块，然后每个宏块提取一个 U 分量和一个 V 分量。 YV12 格式与 IYUV 类似。
     </p>
    </blockquote>
    <blockquote>
     <p>
      YUV411 、 YUV420 格式多见于 DV 数据中，前者用于 NTSC 制，后者用于 PAL 制。 YUV411 为每个像素都提取 Y 分量，而 UV 分量在水平方向上每 4 个像素采样一次。 YUV420 并非 V 分量采样为 0 ，而是跟YUV411 相比，在水平方向上提高一倍色差采样频率，在垂直方向上以 U/V 间隔的方式减小一半色差采样
     </p>
    </blockquote>
    <ol start="4">
     <li>
      YUV和RGB转换
      <br/>
      计算机彩色显示器显示色彩的原理与彩色电视机一样，都是采用R（Red）、G（Green）、B（Blue）
      <br/>
      相加混色的原理：
      <br/>
      通过发射出三种不同强度的电子束，使屏幕内侧覆盖的红、绿、蓝磷光材料发光而产生色彩。这种色彩的表示方法称为RGB色彩空间表示（它也是多媒体计算机技术中用得最多的一种色彩空间表示方法）。
      <br/>
      根据三基色原理，任意一种色光F都可以用不同分量的R、G、B三色相加混合而成。
      <br/>
      <code>
       F = r [ R ] + g [ G ] + b [ B ]
      </code>
      <br/>
      其中，r、g、b分别为三基色参与混合的系数。当三基色分量都为0（最弱）时混合为黑色光；而当三基色分量都为k（最强）时混合为白色光。调整r、g、b三个系数的值，可以混合出介于黑色光和白色光之间的各种各样的色光。
     </li>
    </ol>
    <p>
     <strong>
      那么YUV又从何而来呢？
     </strong>
     <br/>
     在现代彩色电视系统中，通常采用三管彩色摄像机或彩色CCD摄像机进行摄像，然后把摄得的彩色图像信号经分色、分别放大校正后得到 RGB，再经过矩阵变换电路得到亮度信号Y和两个色差信号R－Y（即U）、B－Y（即V），最后发送端将亮度和色差三个信号分别进行编码，用同一信道发送出去。这种色彩的表示方法就是所谓的YUV色彩空间表示。
     <br/>
     采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。
     <br/>
     <strong>
      YUV与RGB相互转换的公式
     </strong>
     <br/>
     如下（RGB取值范围均为0-255）：
     <br/>
     下面代码使用“BT.601标准"
    </p>
    <pre><code class="prism language-swift">Y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span>299R <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">.</span>587G <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">.</span>114B
U <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">.</span>147R <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">.</span>289G <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">.</span>436B
V <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">.</span>615R <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">.</span>515G <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">.</span>100B

R <span class="token operator">=</span> Y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">.</span>14V
G <span class="token operator">=</span> Y <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">.</span>39U <span class="token operator">-</span> <span class="token number">0</span><span class="token punctuation">.</span>58V
B <span class="token operator">=</span> Y <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">.</span>03U
</code></pre>
    <p>
     公式在不同电视使用标准是不同的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e69b136eb4fdcfae297ae8aea1bd949a.png">
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/55e896e2d5abc8a26da9a579463809de.png">
       <br/>
       <strong>
        RGB-&gt;YUV
       </strong>
       <br/>
       C语言代码如下：
      </img>
     </img>
    </p>
    <pre><code class="prism language-c">Y <span class="token operator">=</span> <span class="token number">0.299</span>R <span class="token operator">+</span> <span class="token number">0.587</span>G <span class="token operator">+</span> <span class="token number">0.114</span>B   
Cb <span class="token operator">=</span> <span class="token number">0.</span><span class="token function">564</span><span class="token punctuation">(</span>B <span class="token operator">&amp;</span>#<span class="token number">8722</span><span class="token punctuation">;</span> Y <span class="token punctuation">)</span>   
Cr <span class="token operator">=</span> <span class="token number">0.</span><span class="token function">713</span><span class="token punctuation">(</span>R <span class="token operator">&amp;</span>#<span class="token number">8722</span><span class="token punctuation">;</span> Y <span class="token punctuation">)</span>   
  
代码：   
  
uint8_t <span class="token function">COL_RgbToYuv</span><span class="token punctuation">(</span>uint8_t R<span class="token punctuation">,</span>uint8_t G<span class="token punctuation">,</span>uint8_t B<span class="token punctuation">,</span> uint8_t <span class="token operator">*</span>y<span class="token punctuation">,</span>int8_t <span class="token operator">*</span>u<span class="token punctuation">,</span>int8_t <span class="token operator">*</span>v<span class="token punctuation">)</span>   
<span class="token punctuation">{<!-- --></span>   
    <span class="token keyword">float</span> rr<span class="token operator">=</span>R<span class="token punctuation">,</span>bb<span class="token operator">=</span>B<span class="token punctuation">,</span>gg<span class="token operator">=</span>G<span class="token punctuation">;</span>   
    <span class="token keyword">float</span> yy<span class="token punctuation">,</span>uu<span class="token punctuation">,</span>vv<span class="token punctuation">;</span>   
  
    yy<span class="token operator">=</span><span class="token number">0.299</span><span class="token operator">*</span>rr<span class="token operator">+</span> <span class="token number">0.587</span><span class="token operator">*</span>gg<span class="token operator">+</span> <span class="token number">0.114</span><span class="token operator">*</span>bb<span class="token punctuation">;</span>   
    uu<span class="token operator">=</span><span class="token operator">-</span><span class="token number">0.169</span><span class="token operator">*</span>rr<span class="token operator">+</span> <span class="token operator">-</span><span class="token number">0.331</span><span class="token operator">*</span>gg<span class="token operator">+</span> <span class="token number">0.5</span><span class="token operator">*</span>bb<span class="token punctuation">;</span>   
    vv<span class="token operator">=</span><span class="token number">0.5</span><span class="token operator">*</span>rr<span class="token operator">+</span> <span class="token operator">-</span><span class="token number">0.419</span><span class="token operator">*</span>gg<span class="token operator">+</span> <span class="token operator">-</span><span class="token number">0.081</span><span class="token operator">*</span>bb<span class="token punctuation">;</span>   
  
  
    <span class="token keyword">if</span><span class="token punctuation">(</span>uu<span class="token operator">&gt;</span><span class="token number">127</span><span class="token punctuation">)</span> uu<span class="token operator">=</span><span class="token number">127</span><span class="token punctuation">;</span>   
    <span class="token keyword">if</span><span class="token punctuation">(</span>uu<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> uu<span class="token operator">=</span><span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">;</span>   
    <span class="token operator">*</span>u<span class="token operator">=</span><span class="token punctuation">(</span>int8_t<span class="token punctuation">)</span><span class="token function">floor</span><span class="token punctuation">(</span>uu<span class="token punctuation">)</span><span class="token punctuation">;</span>   
  
    <span class="token keyword">if</span><span class="token punctuation">(</span>vv<span class="token operator">&gt;</span><span class="token number">127</span><span class="token punctuation">)</span> vv<span class="token operator">=</span><span class="token number">127</span><span class="token punctuation">;</span>   
    <span class="token keyword">if</span><span class="token punctuation">(</span>vv<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> vv<span class="token operator">=</span><span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">;</span>   
    <span class="token operator">*</span>v<span class="token operator">=</span><span class="token punctuation">(</span>int8_t<span class="token punctuation">)</span><span class="token function">floor</span><span class="token punctuation">(</span>vv<span class="token punctuation">)</span><span class="token punctuation">;</span>   
  
    <span class="token keyword">if</span><span class="token punctuation">(</span>yy<span class="token operator">&gt;</span><span class="token number">255</span><span class="token punctuation">)</span> yy<span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">;</span>   
    <span class="token keyword">if</span><span class="token punctuation">(</span>yy<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> yy<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   
    <span class="token operator">*</span>y<span class="token operator">=</span><span class="token punctuation">(</span>uint8_t<span class="token punctuation">)</span><span class="token function">floor</span><span class="token punctuation">(</span>yy<span class="token punctuation">)</span><span class="token punctuation">;</span>   
  
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span>  
</code></pre>
    <p>
     <strong>
      YUV-&gt;RGB
     </strong>
     <br/>
     c 语言代码如下：
    </p>
    <pre><code class="prism language-c">R <span class="token operator">=</span> Y <span class="token operator">+</span> <span class="token number">1.402</span>Cr   
G <span class="token operator">=</span> Y <span class="token operator">&amp;</span>#<span class="token number">8722</span><span class="token punctuation">;</span> <span class="token number">0.344</span>Cb <span class="token operator">&amp;</span>#<span class="token number">8722</span><span class="token punctuation">;</span> <span class="token number">0.714</span>Cr   
B <span class="token operator">=</span> Y <span class="token operator">+</span> <span class="token number">1.772</span>Cb   
  
代码：   
  
uint8_t <span class="token function">COL_YuvToRgb</span><span class="token punctuation">(</span> uint8_t y<span class="token punctuation">,</span>int8_t u<span class="token punctuation">,</span>int8_t v<span class="token punctuation">,</span>uint8_t <span class="token operator">*</span>r<span class="token punctuation">,</span>uint8_t <span class="token operator">*</span>g<span class="token punctuation">,</span>uint8_t <span class="token operator">*</span>b<span class="token punctuation">)</span>   
<span class="token punctuation">{<!-- --></span>   
    <span class="token keyword">float</span> rr<span class="token punctuation">,</span>bb<span class="token punctuation">,</span>gg<span class="token punctuation">;</span>   
    <span class="token keyword">float</span> yy<span class="token operator">=</span>y<span class="token punctuation">,</span>uu<span class="token operator">=</span>u<span class="token punctuation">,</span>vv<span class="token operator">=</span>v<span class="token punctuation">;</span>   
  
    rr<span class="token operator">=</span> yy<span class="token operator">+</span> <span class="token number">1.402</span><span class="token operator">*</span>vv<span class="token punctuation">;</span>   
    gg<span class="token operator">=</span> yy<span class="token operator">+</span> <span class="token operator">-</span><span class="token number">0.344</span><span class="token operator">*</span>uu<span class="token operator">+</span> <span class="token operator">-</span><span class="token number">0.714</span><span class="token operator">*</span>vv<span class="token punctuation">;</span>   
    bb<span class="token operator">=</span> yy<span class="token operator">+</span> <span class="token number">1.772</span><span class="token operator">*</span>uu <span class="token punctuation">;</span>   
  
    <span class="token macro property">#<span class="token directive keyword">define</span> CLIP(x) if(x&gt;255) x=255; else if (x&lt;0) x=0;x=x+0.49;   </span>
    <span class="token macro property">#<span class="token directive keyword">define</span> CVT(x,y) CLIP(x);*y=(uint8_t)floor(x);   </span>
  
    <span class="token function">CVT</span><span class="token punctuation">(</span>rr<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">CVT</span><span class="token punctuation">(</span>gg<span class="token punctuation">,</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">CVT</span><span class="token punctuation">(</span>bb<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   
  
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span>  
</code></pre>
    <ol start="5">
     <li>
      常用的YUV，RGB格式
      <br/>
      在DirectShow 中，常见的RGB格式有RGB1、RGB4、RGB8、RGB565、RGB555、RGB24、RGB32、ARGB32等；常见的YUV格式有 YUY2、YUYV、YVYU、UYVY、AYUV、Y41P、Y411、Y211、IF09、IYUV、YV12、YVU9、YUV411、 YUV420等。作为视频媒体类型的辅助说明类型（Subtype）。
     </li>
    </ol>
    <table>
     <thead>
      <tr>
       <th align="center">
        名称
       </th>
       <th align="center">
        格式
       </th>
       <th align="left">
        表示
       </th>
       <th align="left">
        是否需要调色板
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB1
       </td>
       <td align="center">
        2色，
       </td>
       <td align="left">
        每个像素用1位表示，
       </td>
       <td align="left">
        需要调色板
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB4
       </td>
       <td align="center">
        16色，
       </td>
       <td align="left">
        每个像素用4位表示，
       </td>
       <td align="left">
        需要调色板
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB8
       </td>
       <td align="center">
        256色，
       </td>
       <td align="left">
        每个像素用8位表示，
       </td>
       <td align="left">
        需要调色板
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB565
       </td>
       <td align="center">
        每个像素用16位表示，
       </td>
       <td align="left">
        RGB分量分别使用5位、6位、5位
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB555
       </td>
       <td align="center">
        每个像素用16位表示，
       </td>
       <td align="left">
        RGB分量都使用5位（剩下的1位不用）
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB24
       </td>
       <td align="center">
        每个像素用24位表示，
       </td>
       <td align="left">
        RGB分量各使用8位
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_RGB32
       </td>
       <td align="center">
        每个像素用32位表示，
       </td>
       <td align="left">
        RGB分量各使用8位（剩下的8位不用）
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_ARGB32
       </td>
       <td align="center">
        每个像素用32位表示，
       </td>
       <td align="left">
        RGB分量各使用8位（剩下的8位用于表示Alpha通道值）
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_YUY2
       </td>
       <td align="center">
        YUY2格式，
       </td>
       <td align="left">
        以4:2:2方式打包
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_YUYV
       </td>
       <td align="center">
        YUYV格式
       </td>
       <td align="left">
        （实际格式与YUY2相同）
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_YVYU
       </td>
       <td align="center">
        YVYU格式，
       </td>
       <td align="left">
        以4:2:2方式打包
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_UYVY
       </td>
       <td align="center">
        UYVY格式
       </td>
       <td align="left">
        ，以4:2:2方式打包
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_AYUV
       </td>
       <td align="center">
        带Alpha通道的4:4:4 YUV格式
       </td>
       <td align="left">
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_Y41P
       </td>
       <td align="center">
        Y41P格式，
       </td>
       <td align="left">
        以4:1:1方式打包
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_Y411
       </td>
       <td align="center">
        Y411格式
       </td>
       <td align="left">
        （实际格式与Y41P相同）
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_Y211
       </td>
       <td align="center">
        Y211格式
       </td>
       <td align="left">
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_IF09
       </td>
       <td align="center">
        IF09格式
       </td>
       <td align="left">
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_IYUV
       </td>
       <td align="center">
        IYUV格式
       </td>
       <td align="left">
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_YV12
       </td>
       <td align="center">
        YV12格式
       </td>
       <td align="left">
       </td>
       <td align="left">
       </td>
      </tr>
      <tr>
       <td align="center">
        MEDIASUBTYPE_YVU9
       </td>
       <td align="center">
        YVU9格式
       </td>
       <td align="left">
       </td>
       <td align="left">
       </td>
      </tr>
     </tbody>
    </table>
    <ol start="6">
     <li>
      各种RGB格式
     </li>
    </ol>
    <blockquote>
     <p>
      ¨ RGB1、RGB4、RGB8都是调色板类型的RGB格式，在描述这些媒体类型的格式细节时，通常会在BITMAPINFOHEADER数据结构后面跟着一个调色板（定义一系列颜色）。它们的图像数据并不是真正的颜色值，而是当前像素颜色值在调色板中的索引。以RGB1（2色位图）为例，比如它的调色板中定义的两种颜色值依次为0x000000（黑色）和0xFFFFFF（白色），那么图像数据001101010111…（每个像素用1位表示）表示对应各像素的颜色为：黑黑白白黑白黑白黑白白白…。
     </p>
    </blockquote>
    <blockquote>
     <p>
      ¨ RGB565使用16位表示一个像素，这16位中的5位用于R，6位用于G，5位用于B。程序中通常使用一个字（WORD，一个字等于两个字节）来操作一个像素。当读出一个像素后，这个字的各个位意义如下：
      <br/>
      高字节 低字节
      <br/>
      R R R R R G G G G G G B B B B B
      <br/>
      可以组合使用屏蔽字和移位操作来得到RGB各分量的值：
     </p>
    </blockquote>
    <pre><code>#define RGB565_MASK_RED 0xF800
#define RGB565_MASK_GREEN 0x07E0
#define RGB565_MASK_BLUE 0x001F
R = (wPixel &amp; RGB565_MASK_RED) &gt;&gt; 11; // 取值范围0-31
G = (wPixel &amp; RGB565_MASK_GREEN) &gt;&gt; 5; // 取值范围0-63
B = wPixel &amp; RGB565_MASK_BLUE; // 取值范围0-31
</code></pre>
    <blockquote>
     <p>
      ¨ RGB555是另一种16位的RGB格式，RGB分量都用5位表示（剩下的1位不用）。使用一个字读出一个像素后，这个字的各个位意义如下：
      <br/>
      高字节 低字节
      <br/>
      X R R R R G G G G G B B B B B （X表示不用，可以忽略）
      <br/>
      可以组合使用屏蔽字和移位操作来得到RGB各分量的值：
     </p>
    </blockquote>
    <pre><code>#define RGB555_MASK_RED 0x7C00
#define RGB555_MASK_GREEN 0x03E0
#define RGB555_MASK_BLUE 0x001F
R = (wPixel &amp; RGB555_MASK_RED) &gt;&gt; 10; // 取值范围0-31
G = (wPixel &amp; RGB555_MASK_GREEN) &gt;&gt; 5; // 取值范围0-31
B = wPixel &amp; RGB555_MASK_BLUE; // 取值范围0-31

</code></pre>
    <blockquote>
     <p>
      RGB24使用24位来表示一个像素，RGB分量都用8位表示，取值范围为0-255。注意在内存中RGB各分量的排列顺序为：BGR BGR BGR…。通常可以使用RGBTRIPLE数据结构来操作一个像素，它的定义为：
     </p>
    </blockquote>
    <pre><code>typedef struct tagRGBTRIPLE { 
BYTE rgbtBlue; // 蓝色分量
BYTE rgbtGreen; // 绿色分量
BYTE rgbtRed; // 红色分量
} RGBTRIPLE;

</code></pre>
    <blockquote>
     <p>
      ¨ RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha通道或者不用。（ARGB32就是带Alpha通道的 RGB32。）注意在内存中RGB各分量的排列顺序为：BGRA BGRA BGRA…。通常可以使用RGBQUAD数据结构来操作一个像素，它的定义为：
     </p>
    </blockquote>
    <pre><code>typedef struct tagRGBQUAD {
BYTE rgbBlue; // 蓝色分量
BYTE rgbGreen; // 绿色分量
BYTE rgbRed; // 红色分量
BYTE rgbReserved; // 保留字节（用作Alpha通道或忽略）
} RGBQUAD;
 
</code></pre>
    <ol start="7">
     <li>
     </li>
    </ol>
    <h4>
     <a id="112__304">
     </a>
     1.1.2 音视频常见处理
    </h4>
    <h5>
     <a id="_305">
     </a>
     采集
    </h5>
    <ul>
     <li>
      为什么要采集数据
     </li>
    </ul>
    <blockquote>
     <p>
      无论是iOS平台,还是安卓平台,我们都是需要借助官方的API实现一系列相关功能.首先我们要明白我们想要什么,最开始我们需要一部手机,智能手机中摄像头是不可缺少的一部分,所以我们通过一些系统API获取就要可以获取物理摄像头将采集到的视频数据与麦克风采集到的音频数据.
     </p>
    </blockquote>
    <ul>
     <li>
      如何采集数据
     </li>
    </ul>
    <blockquote>
     <p>
      首先要对模拟信号进行采样，所谓采样就是在时间轴上对信号进行数字化。根据奈奎斯特定理（也称为采样定理），按比声音最高频率高2倍以上的频率对声音进行采样（也称为AD转换），1.1节中提到过，对于高质量的音频信号，其频率范围（人耳能够听到的频率范围）是20Hz～20kHz，所以采样频率一般为44.1kHz，这样就可以保证采样声音达到20kHz也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低。而所谓的44.1kHz就是代表1秒会采样44100次
     </p>
    </blockquote>
    <p>
     <strong>
      量化
     </strong>
     :
     <br/>
     量化是指在幅度轴上对信号进行数字化，比如用16比特的二进制信号来表示声音的一个采样，而16比特（一个short）所表示的范围是［-32768，32767］，共有65536个可能取值，因此最终模拟的音频信号在幅度上也分为了65536层。
    </p>
    <p>
     <strong>
      编码
     </strong>
     ：所谓编码，就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储，等等。
    </p>
    <p>
     音频的裸数据格式就是脉冲编码调制（Pulse Code Modulation，PCM）数据。描述一段PCM数据一般需要以下几个概念：量化格式（sampleFormat）、采样率（sampleRate）、声道数（channel）。以CD的音质为例：量化格式（有的地方描述为位深度）为16比特（2字节），采样率为44100，声道数为2，这些信息就描述了CD的音质。而对于声音格式，还有一个概念用来描述它的大小，称为数据比特率，即1秒时间内的比特数目，它用于衡量音频数据单位时间内的容量大小。而对于CD音质的数据，比特率为多少呢？计算如下：
    </p>
    <p>
     44100 * 16 * 2 = 1378.125kbps
    </p>
    <p>
     那么在1分钟里，这类CD音质的数据需要占据多大的存储空间呢？计算如下：
    </p>
    <p>
     1378.125 * 60 / 8 / 1024 = 10.09MB
    </p>
    <p>
     如果sampleFormat更加精确（比如用4字节来描述一个采样），或者sampleRate更加密集（比如48kHz的采样率），那么所占的存储空间就会更大，同时能够描述的声音细节就会越精确。
    </p>
    <p>
     <strong>
      音频采集
     </strong>
     ：
     <br/>
     音频数据既能与图像结合组合成视频数据，也能以纯音频的方式采集播放，后者在很多成熟的应用场景如在线电台和语音电台等起着非常重要的作用。音频的采集过程主要通过设备将环境中的模拟信号采集成 PCM 编码的原始数据，然后编码压缩成 MP3 等格式的数据分发出去。常见的音频压缩格式有：MP3，AAC，HE-AAC，Opus，FLAC，Vorbis (Ogg)，Speex 和 AMR等。
     <br/>
     音频采集和编码主要面临的挑战在于：延时敏感、卡顿敏感、噪声消除（Denoise）、回声消除（AEC）、静音检测（VAD）和各种混音算法等。
    </p>
    <p>
     <strong>
      图像采集
     </strong>
     ：
    </p>
    <p>
     将图像采集的图片结果组合成一组连续播放的动画，即构成视频中可肉眼观看的内容。图像的采集过程主要由摄像头等设备拍摄成
     <a href="https://blog.csdn.net/kyl282889543/article/details/96490933">
      YUV
     </a>
     编码的原始数据，然后经过编码压缩成 H.264 等格式的数据分发出去。常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 等。
     <br/>
     图像由于其直观感受最强并且体积也比较大，构成了一个视频内容的主要部分。图像采集和编码面临的主要挑战在于：设备兼容性差、延时敏感、卡顿敏感以及各种对图像的处理操作如美颜和水印等。
    </p>
    <p>
     <strong>
      视频采集
     </strong>
     ：
    </p>
    <p>
     摄像头采集
     <br/>
     屏幕录制
     <br/>
     从视频文件推流
    </p>
    <ul>
     <li>
      注意点
     </li>
    </ul>
    <h5>
     <a id="_343">
     </a>
     处理
    </h5>
    <ul>
     <li>
      常见的数据处理
     </li>
    </ul>
    <blockquote>
     <p>
      音频和视频原始数据本质都是一大段数据,系统将其包装进自定义的结构体中,通常都以回调函数形式提供给我们,拿到音视频数据后,可以根据各自项目需求做一系列特殊处理,如: 视频的旋转,缩放,滤镜,美颜,裁剪等等功能, 音频的单声道降噪,消除回声,静音等等功能.
     </p>
    </blockquote>
    <p>
     <img alt="视音频处理" src="https://i-blog.csdnimg.cn/blog_migrate/4b9cfc257e34ebe1f0f354d264a7539e.png"/>
    </p>
    <ul>
     <li>
      <p>
       数据处理工具
      </p>
     </li>
     <li>
      <p>
       注意点
      </p>
     </li>
    </ul>
    <h5>
     <a id="_352">
     </a>
     编码
    </h5>
    <ul>
     <li>
      为什么要编码数据
     </li>
    </ul>
    <blockquote>
     <p>
      原始数据做完自定义处理后就可以进行传输,像直播这样的功能就是把采集好的视频数据发送给服务器,以在网页端供所有粉丝观看,而传输由于本身就是基于网络环境,庞大的原始数据就必须压缩后才能带走,可以理解为我们搬家要将物品都打包到行李箱这样理解.
      <br/>
      原始视频数据存储空间大，一个 1080P 的 7 s 视频需要 817 MB
      <br/>
      原始视频数据传输占用带宽大，10 Mbps 的带宽传输上述 7 s 视频需要 11 分钟
      <br/>
      而经过 H.264 编码压缩之后，视频大小只有 708 k ，10 Mbps 的带宽仅仅需要 500 ms ，可以满足实时传输的需求，所以从视频采集传感器采集来的原始视频势必要经过视频编码。
     </p>
    </blockquote>
    <ul>
     <li>
      编码原理
      <br/>
      为什么巨大的原始视频可以编码成很小的视频呢?这其中的技术是什么呢?核心思想就是去除冗余信息：
      <br/>
      1）空间冗余：图像相邻像素之间有较强的相关性
      <br/>
      2）时间冗余：视频序列的相邻图像之间内容相似
      <br/>
      3）编码冗余：不同像素值出现的概率不同
      <br/>
      4）视觉冗余：人的视觉系统对某些细节不敏感
      <br/>
      5）知识冗余：规律性的结构可由先验知识和背景知识得到
     </li>
     <li>
      常用编码工具
      <br/>
      视频编码器：
      <br/>
      1）H.264/AVC
      <br/>
      2）HEVC/H.265
      <br/>
      3）VP8
      <br/>
      4）VP9
      <br/>
      5）FFmpeg
     </li>
     <li>
      音频编码：
      <br/>
      WAV
      <br/>
      Mp3
      <br/>
      AAC
      <br/>
      G711
      <br/>
      G726
      <br/>
      Ogg
     </li>
    </ul>
    <p>
     CD音质的数据采样格式，曾计算出每分钟需要的存储空间约为10.1MB，如果仅仅是将其存放在存储设备（光盘、硬盘）中，可能是可以接受的，但是若要在网络中实时在线传播的话，那么这个数据量可能就太大了，所以必须对其进行压缩编码。压缩编码的基本指标之一就是压缩比，压缩比通常小于1（否则就没有必要去做压缩，因为压缩就是要减小数据容量）。压缩算法包括有损压缩和无损压缩。无损压缩是指解压后的数据可以完全复原。在常用的压缩格式中，用得较多的是有损压缩，有损压缩是指解压后的数据不能完全复原，会丢失一部分信息，压缩比越小，丢失的信息就越多，信号还原后的失真就会越大。根据不同的应用场景（包括存储设备、传输网络环境、播放设备等），可以选用不同的压缩编码算法，如PCM、WAV、AAC、MP3、Ogg等。
     <br/>
     压缩编码的原理实际上是压缩掉冗余信号，冗余信号是指不能被人耳感知到的信号，包含人耳听觉范围之外的音频信号以及被掩蔽的音频信号等。人耳听觉范围之外的音频信号在1.2节中已经提到过，所以在此不再赘述。而被掩蔽掉的音频信号则主要是因为人耳的掩蔽效应，主要表现为频域掩蔽效应与时域掩蔽效应，无论是在时域还是频域上，被掩蔽掉的声音信号都被认为是冗余信息，不进行编码处理。
    </p>
    <p>
     （1）WAV编码
    </p>
    <blockquote>
     <p>
      PCM（脉冲编码调制）是Pulse Code Modulation的缩写。前面已经介绍过PCM大致的工作流程，而WAV编码的一种实现（有多种实现方式，但是都不会进行压缩操作）就是在PCM数据格式的前面加上44字节，分别用来描述PCM的采样率、声道数、数据格式等信息。
      <br/>
      特点：音质非常好，大量软件都支持。
      <br/>
      适用场合：多媒体开发的中间文件、保存音乐和音效素材。
     </p>
    </blockquote>
    <p>
     （2）MP3编码
    </p>
    <blockquote>
     <p>
      MP3具有不错的压缩比，使用LAME编码（MP3编码格式的一种实现）的中高码率的MP3文件，听感上非常接近源WAV文件，当然在不同的应用场景下，应该调整合适的参数以达到最好的效果。
      <br/>
      特点：音质在128Kbit/s以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好。
      <br/>
      适用场合：高比特率下对兼容性有要求的音乐欣赏。
     </p>
    </blockquote>
    <p>
     （3）AAC编码
    </p>
    <blockquote>
     <p>
      AAC是新一代的音频有损压缩技术，它通过一些附加的编码技术（比如PS、SBR等），衍生出了LC-AAC、HE-AAC、HE-AAC v2三种主要的编码格式。LC-AAC是比较传统的AAC，相对而言，其主要应用于中高码率场景的编码（≥80Kbit/s）；HE-AAC（相当于AAC＋SBR）主要应用于中低码率场景的编码（≤80Kbit/s）；而新近推出的HE-AAC v2（相当于AAC＋SBR＋PS）主要应用于低码率场景的编码（≤48Kbit/s）。事实上大部分编码器都设置为≤48Kbit/s自动启用PS技术，而&gt;48Kbit/s则不加PS，相当于普通的HE-AAC。
      <br/>
      特点：在小于128Kbit/s的码率下表现优异，并且多用于视频中的音频编码。
      <br/>
      适用场合：128Kbit/s以下的音频编码，多用于视频中音频轨的编码。
     </p>
    </blockquote>
    <p>
     (4)Ogg编码
    </p>
    <blockquote>
     <p>
      Ogg是一种非常有潜力的编码，在各种码率下都有t匕较优秀的表现，尤其是在中低码率场景下。Ogg除了音质好之外，还是完
      <br/>
      全免费的，这为Ogg获得更多的支持打好了基础》Ogg有着非常出色的算法，可以用更小的码率达到更好的音质，l28Kbit/s的Ogg比192Kbit/s甚至更高码率的MP3还要出色。但目前因为还没有媒体服务软件的支持，因此基于Ogg的数字广播还无法实现。Ogg目前受支持的情况还不够好，无论是软件上的还是硬件上的支持，都无法和MP3相提并论。
      <br/>
      特点：可以用比MP3更小的码率实现比MP3更好的音质，高中低码率下均有良好的表现，兼容性不够好，流媒体特性不支持。
      <br/>
      适用场合：语音聊天的音频消息场景。
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       视频编码
      </p>
     </li>
     <li>
      <p>
       IOS平台编码方式
       <br/>
       iOS上编解码分为两种，硬编解码和软编解码，可以参考下表：
      </p>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th align="center">
        类型
       </th>
       <th align="center">
        工具
       </th>
       <th align="center">
        硬件支持
       </th>
       <th align="center">
        后台
       </th>
       <th align="center">
        思路
       </th>
       <th align="center">
        备注
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        硬编解码
       </td>
       <td align="center">
        VideoToolBox
       </td>
       <td align="center">
        非CPU或者专用处理器
       </td>
       <td align="center">
        编码(iOS&gt;=10.0),解码不支持
       </td>
       <td align="center">
        VideoVTToolBox
       </td>
       <td align="center">
        -
       </td>
      </tr>
      <tr>
       <td align="center">
        硬编解码
       </td>
       <td align="center">
        AVAssetWriter
       </td>
       <td align="center">
        非CPU或者专用处理器
       </td>
       <td align="center">
        支持编码
       </td>
       <td align="center">
        需要将视频写入本地文件，然后通过实时监听文件内容的改变，读取文件并处理封包
       </td>
       <td align="center">
        -
       </td>
      </tr>
      <tr>
       <td align="center">
        软编解码
       </td>
       <td align="center">
        FFmpeg
       </td>
       <td align="center">
        CPU
       </td>
       <td align="center">
        支持
       </td>
       <td align="center">
        -
       </td>
       <td align="center">
        -
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <p>
       常用编码算法
      </p>
     </li>
     <li>
      <p>
       注意点
      </p>
     </li>
    </ul>
    <h5>
     <a id="_419">
     </a>
     传输
    </h5>
    <ul>
     <li>
      常用的传输协议
     </li>
    </ul>
    <blockquote>
     <p>
      编码后的音视频数据通常以RTMP协议进行传输,这是一种专门用于传输音视频的协议,因为各种各样的视频数据格式无法统一,所以需要有一个标准作为传输的规则.协议就起到这样的作用.
      <br/>
      常用传输协议：RTMP， FTP, TCP/IP, HTTP, XMMP
      <br/>
      常用数据封装：json, xml,
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       传输数据过程
      </p>
     </li>
     <li>
      <p>
       常用工具
      </p>
     </li>
     <li>
      <p>
       注意点
      </p>
     </li>
    </ul>
    <h5>
     <a id="_430">
     </a>
     解码
    </h5>
    <ul>
     <li>
      为什么要解码数据
     </li>
    </ul>
    <blockquote>
     <p>
      服务端接收到我们送过去的编码数据后,需要对其解码成原始数据,因为编码的数据直接送给物理硬件的设备是不能直接播放的,只有解码为原始数据才能使用.
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       常用解码算法
      </p>
     </li>
     <li>
      <p>
       常用解码工具
      </p>
     </li>
    </ul>
    <ol>
     <li>
      H264/H265裸码流提取工具
      <br/>
      工具下载地址：
      <a href="https://download.csdn.net/download/listener51/10952502">
       https://download.csdn.net/download/listener51/10952502
      </a>
      <br/>
      源码下载地址：
      <a href="https://github.com/fermay/open_media_demux">
       https://github.com/fermay/open_media_demux
      </a>
     </li>
    </ol>
    <p>
     码流拖曳到软件中显示如下：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/4d4241c77abda96a94194e8cba11e86f.png">
      <br/>
      2.
     </img>
    </p>
    <ul>
     <li>
      <p>
       解码原理
      </p>
     </li>
     <li>
      <p>
       注意点
      </p>
     </li>
    </ul>
    <h5>
     <a id="_448">
     </a>
     渲染
    </h5>
    <h5>
     <a id="_450">
     </a>
     常用音频编码格式
    </h5>
    <h5>
     <a id="_452">
     </a>
     常用视频编码格式
    </h5>
    <h5>
     <a id="_454">
     </a>
     常用编解码算法
    </h5>
    <h5>
     <a id="_456">
     </a>
     视频音频同步算法
    </h5>
    <ul>
     <li>
      音视频同步需求
     </li>
    </ul>
    <blockquote>
     <p>
      解码后的每帧音视频中都含有最开始录制时候设置的时间戳,我们需要根据时间戳将它们正确的播放出来,但是在网络传输中可能会丢失一些数据,或者是延时获取,这时我们就需要一定的策略去实现音视频的同步,大体分为几种策略:缓存一定视频数据,视频追音频等等.
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       常用音视频同步算法
      </p>
     </li>
     <li>
      <p>
       音视频处理工具
      </p>
     </li>
     <li>
      <p>
       注意点
      </p>
     </li>
    </ul>
    <h5>
     <a id="_465">
     </a>
     录像
    </h5>
    <h5>
     <a id="_467">
     </a>
     音频播放
    </h5>
    <h5>
     <a id="_469">
     </a>
     视频播放
    </h5>
    <ul>
     <li>
      本地视频播放
      <br/>
      <strong>
       IOS常用的播放本地视频方式
      </strong>
      ：
      <br/>
      1). 系统自带API方式
      <br/>
      2）
      <a href="https://www.videolan.org/vlc/download-sources.html" rel="nofollow">
       VLC
      </a>
      +
      <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
       FFmpeg
      </a>
      方式
      <br/>
      3）
      <a href="https://www.libsdl.org/download-2.0.php" rel="nofollow">
       SDL
      </a>
      +
      <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
       FFmpeg
      </a>
      方式
      <br/>
      4）Vitamio以及ijkplayer等
     </li>
    </ul>
    <p>
     <strong>
      Android常用的播放本地视频方式
     </strong>
     ：
     <br/>
     1). 系统自带API方式
     <br/>
     2）
     <a href="https://www.videolan.org/vlc/download-sources.html" rel="nofollow">
      VLC
     </a>
     +
     <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
      FFmpeg
     </a>
     方式
     <br/>
     3）
     <a href="https://www.libsdl.org/download-2.0.php" rel="nofollow">
      SDL
     </a>
     +
     <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
      FFmpeg
     </a>
     方式
     <br/>
     4）Vitamio以及ijkplayer等
     <br/>
     <strong>
      Qt常用的播放本地视频方式
     </strong>
     ：
     <br/>
     1). 系统自带API方式
     <br/>
     2）
     <a href="https://www.videolan.org/vlc/download-sources.html" rel="nofollow">
      VLC
     </a>
     +
     <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
      FFmpeg
     </a>
     方式
     <br/>
     3）
     <a href="https://www.libsdl.org/download-2.0.php" rel="nofollow">
      SDL
     </a>
     +
     <a href="http://www.ffmpeg.org/download.html" rel="nofollow">
      FFmpeg
     </a>
     方式
    </p>
    <ul>
     <li>
      <p>
       远程视频播放
      </p>
     </li>
     <li>
      <p>
       直播
      </p>
     </li>
    </ul>
    <ol start="14">
     <li>
     </li>
    </ol>
    <h3>
     <a id="12___494">
     </a>
     1.2 直播
    </h3>
    <h4>
     <a id="121__495">
     </a>
     1.2.1 推流
    </h4>
    <p>
     将手机采集到的视频数据传给后台播放端进行展示，播放端可以是windows, linux, web端，即手机充当采集的功能，将手机摄像头采集到视频和麦克风采集到的音频合成编码后传给对应平台的播放端。
    </p>
    <p>
     流程图如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/330a3e900608f88b930f2d4a7817b3a2.png"/>
    </p>
    <h4>
     <a id="1211__501">
     </a>
     1.2.1.1 推流常用协议简介
    </h4>
    <p>
     推送协议主要有三种：
    </p>
    <ul>
     <li>
      <strong>
       RTSP
      </strong>
      （Real Time Streaming Protocol）：实时流传送协议，是用来控制声音或影像的多媒体串流协议, 由Real Networks和Netscape共同提出的；
     </li>
     <li>
      <strong>
       RTMP
      </strong>
      (Real Time Messaging Protocol)：实时消息传送协议，是Adobe公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议；
     </li>
     <li>
      <strong>
       HLS
      </strong>
      (HTTP Live Streaming)：是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议；
     </li>
    </ul>
    <ol>
     <li>
      <p>
       <a href="https://blog.csdn.net/kyl282889543/article/details/97371688">
        RTSP协议
       </a>
      </p>
     </li>
     <li>
      <p>
       <a href="https://blog.csdn.net/kyl282889543/article/details/97294300">
        RTMP
       </a>
       协议
       <br/>
       RTMP协议基于 TCP，是一种设计用来进行实时数据通信的网络协议，主要用来在 flash/AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media Server/red5 等。
       <br/>
       它有三种变种：
      </p>
     </li>
    </ol>
    <ol>
     <li>
      RTMP工作在TCP之上的明文协议，使用端口1935；
     </li>
     <li>
      RTMPT封装在HTTP请求之中，可穿越防火墙；
     </li>
     <li>
      RTMPS类似RTMPT，但使用的是HTTPS连接；
     </li>
    </ol>
    <p>
     RTMP 是目前主流的流媒体传输协议，广泛用于直播领域，可以说市面上绝大多数的直播产品都采用了这个协议。
     <br/>
     RTMP协议就像一个用来装数据包的容器，这些数据可以是AMF格式的数据,也可以是FLV中的视/音频数据。一个单一的连接可以通过不同的通道传输多路网络流。这些通道中的包都是按照固定大小的包传输的。
    </p>
    <p>
     大致流程图如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/39efd27fd581280b78ab6013139715a8.png"/>
    </p>
    <ol start="3">
     <li>
      HLS协议
     </li>
    </ol>
    <h4>
     <a id="122__525">
     </a>
     1.2.2 拉流
    </h4>
    <p>
     将播放端传来的视频数据在手机上播放,推流的逆过程，即将windows, linux, web端传来的视频数据进行解码后传给对应音视频硬件，最终将视频渲染在手机界面上播放.
    </p>
    <p>
     流程图如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/390736e25081880851d28a8ecf495875.png"/>
    </p>
    <h3>
     <a id="13_FFmpeg_532">
     </a>
     1.3. FFmpeg简介
    </h3>
    <blockquote>
     <p>
      FFmpeg 是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库。
      <br/>
      “FFmpeg”这个单词中的“FF”指的是“Fast Forward（快速前进）”。有些新手写信给“FFmpeg”的项目负责人，询问FF是不是代表“Fast Free”或者“Fast Fourier”等意思，“FFmpeg”的项目负责人回信说：“Just for the record, the original meaning of “FF” in FFmpeg is “Fast Forward”…”
      <br/>
      这个项目最初是由Fabrice Bellard发起的，而现在是由Michael Niedermayer在进行维护。许多FFmpeg的开发者同时也是
      <a href="https://zh.wikipedia.org/wiki/MPlayer" rel="nofollow">
       MPlayer
      </a>
      项目的成员，FFmpeg在MPlayer项目中是被设计为服务器版本进行开发。
      <br/>
      2011年3月13日，FFmpeg部分开发人士决定另组Libav，同时制定了一套关于项目继续发展和维护的规则
     </p>
    </blockquote>
    <p>
     更多详情参考维基百科：
     <a href="https://zh.wikipedia.org/wiki/FFmpeg" rel="nofollow">
      FFmpeg简介
     </a>
    </p>
    <ul>
     <li>
      常用库
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th align="center">
        库名
       </th>
       <th align="center">
        用途
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        ffmpeg
       </td>
       <td align="center">
        一个命令行工具，用来对视频文件转换格式，也支持对电视卡即时编码
       </td>
      </tr>
      <tr>
       <td align="center">
        ffserver
       </td>
       <td align="center">
        一个HTTP多媒体即时广播流服务器，支持时光平移
       </td>
      </tr>
      <tr>
       <td align="center">
        ffplay
       </td>
       <td align="center">
        一个简单的播放器，基于SDL与FFmpeg库
       </td>
      </tr>
      <tr>
       <td align="center">
        libavcodec
       </td>
       <td align="center">
        包含全部FFmpeg音频/视频编解码库
       </td>
      </tr>
      <tr>
       <td align="center">
        libavformat
       </td>
       <td align="center">
        包含demuxers和muxer库
       </td>
      </tr>
      <tr>
       <td align="center">
        libavutil
       </td>
       <td align="center">
        包含一些工具库
       </td>
      </tr>
      <tr>
       <td align="center">
        libpostproc
       </td>
       <td align="center">
        对于视频做前处理的库
       </td>
      </tr>
      <tr>
       <td align="center">
        libavutil
       </td>
       <td align="center">
        包含一些工具库
       </td>
      </tr>
      <tr>
       <td align="center">
        libswscale
       </td>
       <td align="center">
        对于影像作缩放的库
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      主要参数
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th align="center">
        参数名
       </th>
       <th align="center">
        意义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        -i
       </td>
       <td align="center">
        设置输入档名。
       </td>
      </tr>
      <tr>
       <td align="center">
        -f
       </td>
       <td align="center">
        设置输出格式。
       </td>
      </tr>
      <tr>
       <td align="center">
        -y
       </td>
       <td align="center">
        若输出文件已存在时则覆盖文件。
       </td>
      </tr>
      <tr>
       <td align="center">
        -fs
       </td>
       <td align="center">
        超过指定的文件大小时则结束转换。
       </td>
      </tr>
      <tr>
       <td align="center">
        -ss
       </td>
       <td align="center">
        从指定时间开始转换。
       </td>
      </tr>
      <tr>
       <td align="center">
        -t
       </td>
       <td align="center">
        从-ss时间开始转换（如-ss 00:00:01.00 -t 00:00:10.00即从00:00:01.00开始到00:00:11.00）。
       </td>
      </tr>
      <tr>
       <td align="center">
        -title
       </td>
       <td align="center">
        设置标题。
       </td>
      </tr>
      <tr>
       <td align="center">
        -timestamp
       </td>
       <td align="center">
        设置时间戳。
       </td>
      </tr>
      <tr>
       <td align="center">
        -vsync
       </td>
       <td align="center">
        增减Frame使影音同步。
       </td>
      </tr>
      <tr>
       <td align="center">
        -c
       </td>
       <td align="center">
        指定输出文件的编码。
       </td>
      </tr>
      <tr>
       <td align="center">
        -metadata
       </td>
       <td align="center">
        更改输出文件的元数据。
       </td>
      </tr>
      <tr>
       <td align="center">
        -help
       </td>
       <td align="center">
        查看帮助信息。
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th align="center">
        视频参数名
       </th>
       <th align="center">
        意义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        b:v
       </td>
       <td align="center">
        设置视频流量，默认为200Kbit/秒。（单位请引用下方注意事项）
       </td>
      </tr>
      <tr>
       <td align="center">
        r
       </td>
       <td align="center">
        设置帧率值，默认为25。
       </td>
      </tr>
      <tr>
       <td align="center">
        s
       </td>
       <td align="center">
        设置画面的宽与高。
       </td>
      </tr>
      <tr>
       <td align="center">
        aspect
       </td>
       <td align="center">
        设置画面的比例。
       </td>
      </tr>
      <tr>
       <td align="center">
        vn
       </td>
       <td align="center">
        不处理视频，于仅针对声音做处理时使用。
       </td>
      </tr>
      <tr>
       <td align="center">
        vcodec( -c:v )
       </td>
       <td align="center">
        设置视频视频编解码器，未设置时则使用与输入文件相同之编解码器。
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th align="center">
        声音参数名
       </th>
       <th align="center">
        意义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        b:a
       </td>
       <td align="center">
        设置每Channel（最近的SVN版为所有Channel的总合）的流量。（单位请引用下方注意事项）
       </td>
      </tr>
      <tr>
       <td align="center">
        ar
       </td>
       <td align="center">
        设置采样率。
       </td>
      </tr>
      <tr>
       <td align="center">
        ac
       </td>
       <td align="center">
        设置声音的Channel数。
       </td>
      </tr>
      <tr>
       <td align="center">
        acodec ( -c:a )
       </td>
       <td align="center">
        设置声音编解码器，未设置时与视频相同，使用与输入文件相同之编解码器。
       </td>
      </tr>
      <tr>
       <td align="center">
        an
       </td>
       <td align="center">
        不处理声音，于仅针对视频做处理时使用。
       </td>
      </tr>
      <tr>
       <td align="center">
        vol
       </td>
       <td align="center">
        设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。）
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      查看
      <a href="http://ffmpeg.org/ffmpeg.html" rel="nofollow">
       FFmpeg官方文档
      </a>
     </li>
    </ul>
    <ol>
     <li>
      查看h265的数据的基本信息
     </li>
    </ol>
    <pre><code class="prism language-shell">ffmpeg -i /Users/tomxiang/Desktop/h265/test_tomxiang.h265
</code></pre>
    <ol start="2">
     <li>
      用libx265转mp4.
     </li>
    </ol>
    <pre><code class="prism language-shell">ffmpeg -i /Users/tomxiang/Desktop/test_tomxiang.h265  -c:v libx265 /Users/tomxiang/xxtest/test265.mp4
</code></pre>
    <ol start="3">
     <li>
      ffplay逐帧播放视频与显示视频帧序号
      <br/>
      macOS下使用ffplay，按下s键可单帧播放视频，配合一个显示文字的视频滤镜即可显示当前画面的帧序号，命令示例如下所示:
     </li>
    </ol>
    <pre><code class="prism language-shell">ffplay -vf <span class="token string">"drawtext=fontfile=/Library/Fonts/Arial.ttf:text=%{n}:box=1:x=(w-tw)/2:y=h-(2*lh)"</span> sample.mp4
</code></pre>
    <p>
     音视频专家博客收集：
    </p>
    <ol>
     <li>
      肖雷华大神：
      <a href="https://blog.csdn.net/leixiaohua1020/article/details/18893769">
       https://blog.csdn.net/leixiaohua1020/article/details/18893769
      </a>
     </li>
     <li>
      小东邪大神：
      <a href="https://www.jianshu.com/u/23f3ec991fed" rel="nofollow">
       https://www.jianshu.com/u/23f3ec991fed
      </a>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6b796c323832383839353433:2f61727469636c652f64657461696c732f3936343930373738" class_="artid" style="display:none">
 </p>
</div>


