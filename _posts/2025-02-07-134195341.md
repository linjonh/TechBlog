---
layout: post
title: "前端UniApp使用SignalR实例及踩的坑"
date: 2025-02-07 11:59:07 +0800
description: "2、与SignalR相关的代码不能使用UniApp或其它第三方的的方法或组件，比如调用renderj"
keywords: "前端signalr连接状态"
categories: ["未分类"]
tags: ["前端", "App"]
artid: "134195341"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=134195341
  alt: "前端UniApp使用SignalR实例及踩的坑"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端UniApp使用SignalR实例及踩的坑
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     UniApp H5+App前端使用SignalR时,H5端正常,App端异常,经查询和测试,总结如几点:
    </p>
    <p>
     1、前端关于SignalR的代码要写成 renderjs,不然App端会报错“ReferenceError: require is not defined”
    </p>
    <p>
     2、与SignalR相关的代码不能使用UniApp或其它第三方的的方法或组件，比如调用renderjs中的方法时，不能用&lt;u-buttton&gt;的click事件，否则H5正常，App没反应
    </p>
    <p>
     3、在renderjs里通过this.$ownerInstance.callMethod()调用service层（正常&lt;script&gt; ）里的方法
    </p>
    <p>
     4、renderjs里如果想调用service层的变量，需要在&lt;template&gt;中使用" :change"监测然后传入renderjs
    </p>
    <p>
     其它方面网上讲很多，自己查吧
    </p>
    <pre><code class="language-javascript">&lt;template&gt;
	&lt;view style="margin-top: 200px;" class="renderjs"&gt;
		&lt;!-- &lt;u-button @click="socket.sendMsg" text="Send"&gt;&lt;/u-button&gt; --&gt;
		&lt;!-- &lt;u-button&gt;不能用,在h5正常,app中无效,这个坑踩了好几天,希望能帮到你 --&gt;
		&lt;button @click="socket.sendMsg"&gt;Send&lt;/button&gt;
		&lt;u-button&gt;&lt;/u-button&gt;
		&lt;!-- 通过监测host的改变,把host的值传入renderjs里 --&gt;
		&lt;view :url="host" :change:url="socket.getHost"&gt;&lt;/view&gt;
	&lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
	export default {
		data() {
			return {
                //后端地址,通过 :change 可传入renderjs, 需要改成你自己实际的地址
				host: "http://192.168.1.8:5278" 
			}
		},
		methods: {
			reciveMsg(obj) {
				//收到信息后进一步处理,由renderjs中的
                //this.$ownerInstance.callMethod调用,obj为收到的内容
				console.log("reciveMsg:", obj);
			}
		},
	}
&lt;/script&gt;
&lt;script module="socket" lang="renderjs"&gt;
	import * as signalR from "@microsoft/signalr"
	var connection
	export default {
		data() {
			return {}
		},
		methods: {
			sendMsg(e, ownerVm) {
				//console.log('ownerVm: ', ownerVm);
				//调用后端的"SendMessage"方法 
				connection.invoke("SendMessage", "发送的数据")
			},
			getHost(newValue, oldValue, ownerVm, vm) {
				//从service层动态获取后端地址
				this.url = newValue
			}
		},
		async mounted() {
			//url 后端SignalR的地址
			this.url = this.url + '/Hubs/Notifier'
			connection = new signalR.HubConnectionBuilder()
				.withUrl(this.url)
				.configureLogging(signalR.LogLevel.Information)
				.withAutomaticReconnect()
				.build()
			//监听 ReceiveMessage 事件,名称为invoke调用后端方法后,后端返回的事件名
			await connection.on("ReceiveMessage", msg =&gt; {
				//调用&lt;script&gt; 也叫service层的 reciveMsg 方法 msg为方法的参数
				this.$ownerInstance.callMethod("reciveMsg", msg)
			})
			await connection.start()
		},
	}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f706f6e79313638382f:61727469636c652f64657461696c732f313334313935333431" class_="artid" style="display:none">
 </p>
</div>
