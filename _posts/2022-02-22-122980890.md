---
layout: post
title: "C语言实现推箱子-数据库连接项目打包发布"
date: 2022-02-22 23:27:49 +0800
description: "小时候都玩过推箱子这个经典的小游戏，它伴随着我们的童年，带给我们了许多的乐趣。今天呢小编为大家分享一"
keywords: "c语言打包游戏"
categories: ['实现各种小游戏', 'Mysql', 'C', 'C']
tags: ['算法', 'C']
artid: "122980890"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122980890
    alt: "C语言实现推箱子-数据库连接项目打包发布"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言实现推箱子 （数据库连接+项目打包发布）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p style="text-align:center;">
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/8f2cbe0b286d6d63417b41fc622cfb1d.png"/>
    </p>
    <p>
     小时候都玩过推箱子这个经典的小游戏，它伴随着我们的童年，带给我们了许多的乐趣。今天呢小编为大家分享一下使用C语言来完成推箱子游戏。以及如何将游戏与数据库连接和项目的打包发布。
    </p>
    <p>
     下面是完成之后的效果展示：
    </p>
    <p>
     <span style="color:#0d0016;">
      <strong>
       ①项目打包后我们会获得一个安装程序，点击安装程序就能将推箱子游戏安装在电脑上。
      </strong>
      这时候也可以将安装程序发给朋友安装试玩（因为时间原因没有做登录页面）
     </span>
    </p>
    <p style="text-align:center;">
     <img alt="9b5091ce3a484531ac98f9fe033caa8e.gif" src="https://i-blog.csdnimg.cn/blog_migrate/90788d007aacfcaaee6b1391925a7e84.gif"/>
    </p>
    <p>
     <span style="color:#0d0016;">
      <strong>
       ②游戏内效果，一共设计了四种地图，感兴趣的朋友可以继续在自己的数据库中添加地图。
      </strong>
     </span>
    </p>
    <p>
     <img alt="aada0b539c204d22a1c1653d50d2a80b.gif" src="https://i-blog.csdnimg.cn/blog_migrate/e845cb5f1b31cf04898d6e78a5dce82c.gif">
      ​下面我按照 推箱子游戏实现 → 数据库连接 → 程序打包 的路线分享本次项目
     </img>
    </p>
    <h2>
     <span style="color:#0d0016;">
      一、推箱子游戏源码（可直接拷贝运行）
     </span>
    </h2>
    <p>
     游戏图片下载（将图片与代码放在同一文件夹下）。
     <a class="link-info has-card" href="https://download.csdn.net/download/qq_54169998/81551789" title="图片下载">
      <span class="link-card-box">
       <span class="link-title">
        图片下载
       </span>
       <span class="link-link">
        <img alt="" class="link-link-icon" src="https://i-blog.csdnimg.cn/blog_migrate/108103d72789eafe62012253d677a985.png">
         https://download.csdn.net/download/qq_54169998/81551789
        </img>
       </span>
      </span>
     </a>
     <strong>
      这里为分享的源码是以文档做数据结构。下面我会介绍与MySQL相连
     </strong>
    </p>
    <pre><code class="language-cpp">#include&lt;graphics.h&gt;
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;string&gt;
#include&lt;conio.h&gt;	
#include&lt;fstream&gt;
#include&lt;sstream&gt;
using namespace std;

#define LINE 48
#define COLUMN 48

#define RATIO 40
#define SCREEN_WIDTH 740
#define SCREEN_HEIGHT 500

#define START_X 50
#define START_Y 75

#define KEY_UP 'W'
#define KEY_LEFT 'A'
#define KEY_RIGHT 'D'
#define KEY_DOWN 'S'
#define KEY_OUT 'Q'
#define GAME_AGAIN 'R'

#define MAX_RETRY_TIMES 4
#define BG_IMAGE -1
#define isValid(next_pos) next_pos.x &gt; 0 &amp;&amp; next_pos.x &lt; LINE &amp;&amp; next_pos.y&gt;0 &amp;&amp; next_pos.y &lt; COLUMN

#define USERS "users.txt"
#define LEVELS "levels.txt"
#define ROUND 4

typedef enum  _PROPS {
	WALL,	//墙
	FLOOR,	//地板
	BOX_DES,//箱子目的地
	MAN,	//小人
	BOX,	//箱子
	HIT,	//箱子命中目标
	MAN_DES,	//人站在目标上
	VECTOR	//通关图片
}PROPS;

typedef enum  _DIRECTION {
	UP,
	DOWN,
	LEFT,
	RIGHT
}DIRECTION;

typedef struct _POS {
	int x;	//小人所在二维数组的行数
	int y;	//小人所在二维数组的列数
}POS;

typedef struct _userinfo {
	//这里将字符串初始为空
	_userinfo() :id(0), username(""), password(""), level_id(0) {};
	_userinfo(int _id, string _username, string _password, int _level_id) :id(_id), username(_username), password(_password), level_id(_level_id) {};
	int id;	// 用户id
	string username;
	string password;	// 密码
	int level_id;
}userinfo;

typedef struct _levelinfo {
	_levelinfo() :id(0), name(""), map_row(0), map_column(0), map_data(""), next_level(0) {};
	_levelinfo(int _id, string _name, int _map_row, int _map_column, string _map_data, int _next_level) :id(_id), name(_name), map_row(_map_row), map_column(_map_column), map_data(_map_data), next_level(_next_level) {};
	int id;	// 关卡id
	string name;	// 关卡名字
	int map_row;	// 地图行数
	int map_column;	//地图列数
	string map_data;	// 二维地图数据
	int next_level;	//下一关卡id
}levelinfo;

levelinfo game_data[4];
struct _POS man;
IMAGE images[9];
int map[LINE][COLUMN] = { 0 };

/******************************
 * 功能：数据重置，当数据文档错乱时可调用此函数一次将数据重装
 * 输入：
 *		无
 *
 * 返回值：
 *		无
 *****************************/
void resetting_data() {
	levelinfo levels[ROUND] = { {1,"小试牛刀→第一关",8,10,"-1,0,0,0,0,0,0,0,-1,-1|-1,0,2,2,2,2,1,0,-1,-1|0,0,0,2,2,2,4,0,0,0|0,1,1,4,0,4,1,4,1,0|0,1,4,4,1,1,0,4,1,0|0,1,1,1,3,0,1,1,1,0|0,0,0,0,1,1,1,0,0,0,|-1,-1,-1,0,0,0,0,0,-1,-1",2},
							{2,"绝地强者→第二关",6,6,"0,0,0,0,0,0|0,2,2,1,1,0|0,4,4,1,3,0|0,2,1,4,0,0|0,1,1,1,0,-1|0,0,0,0,0,-1",3},
							{3,"天外强人→第三关",8,10,"-1,-1,0,0,0,0,0,0,-1,-1|0,0,0,1,1,1,0,0,0,0|0,1,1,1,4,1,4,1,1,0|0,1,4,1,1,1,4,1,3,0|0,0,0,4,4,0,0,0,0,0,|-1,-1,0,1,1,2,2,0,-1,-1|-1,-1,0,2,2,2,2,0,-1,-1|-1,-1,0,0,0,0,0,0,-1,-1",4},
							{4,"死而复生→BOSS关",8,8,"-1,0,0,0,0,0,0,-1|-1,0,2,1,2,2,0,-1|-1,0,2,1,4,2,0,-1|0,0,0,1,1,4,0,0|0,1,4,1,1,4,1,0|0,1,0,4,0,0,1,0|0,1,1,1,3,1,1,0|0,0,0,0,0,0,0,0",0}
	};
	ofstream ofs;
	ofs.open(LEVELS, ios::out);
	for (int i = 0; i &lt; ROUND; ++i) {
		stringstream str_stream;
		str_stream &lt;&lt; levels[i].id &lt;&lt; " " &lt;&lt; levels[i].name &lt;&lt; " " &lt;&lt; levels[i].map_row &lt;&lt; " " &lt;&lt; levels[i].map_column &lt;&lt; " " &lt;&lt; levels[i].map_data &lt;&lt; " " &lt;&lt; levels[i].next_level &lt;&lt; endl;
		ofs &lt;&lt; str_stream.str();
	}
	ofs.close();
	ofs.open(USERS, ios::out);
	userinfo user = { 1,"Jack","123456" ,1 };
	stringstream str;
	str &lt;&lt; user.id &lt;&lt; " " &lt;&lt; user.username &lt;&lt; " " &lt;&lt; user.password &lt;&lt; " " &lt;&lt; user.level_id;
	ofs &lt;&lt; str.str();
	ofs.close();
}

/******************************
 * 功能：地图数据加载
 * 输入：
 *		无
 *
 * 返回值：
 *		无
 *****************************/
void load_data() {
	ifstream ifs;
	ifs.open(LEVELS);
	int index = 0;
	while (index &lt; ROUND) {
		string line;
		getline(ifs, line);
		//cout &lt;&lt; line &lt;&lt; endl;
		int _id;
		char _name[64];
		int _map_row;
		int _map_column;
		char _map_data[2304];
		int _next_level_id;
		levelinfo info;
		sscanf_s(line.c_str(), "%d %s %d %d %s %d", &amp;_id, _name, (unsigned int)sizeof(_name), &amp;_map_row, &amp;_map_column, _map_data, (unsigned int)sizeof(_map_data), &amp;_next_level_id);
		game_data[index] = { _id,_name,_map_row,_map_column,_map_data,_next_level_id };
		index++;
	}
}


/******************************
 *功能：通过用户名和密码获取用户信息
 * 输入：
 *		user - 用户信息结构体
 *
 * 返回值：
 *		获取成功返回true，失败false
 *****************************/
bool fetch_user_info(userinfo&amp; user) {
	ifstream ifs;
	ifs.open(USERS);
	if (!ifs) {
		return false;
	}
	string line;
	while (1) {
		getline(ifs, line);
		int _id;
		char _username[64];
		char _password[64];
		int _level_id;
		sscanf_s(line.c_str(), "%d%s%s%d", &amp;_id, _username, (unsigned int)sizeof(_username), _password, (unsigned int)sizeof(_password), &amp;_level_id);
		if (_username == user.username &amp;&amp; _password == user.password) {
			user.id = _id;
			user.level_id = _level_id;
			return true;
		}
		if (ifs.eof()) {
			break;
		}
	}
	return false;
}

/*********************************
 *功能：根据关卡id获取完整的关卡信息（如：地图，下一关等）
 * 输入：
 *		level - 保存关卡信息的结构体
 *		level_id - 获取关卡id
 * 返回值：
 *		0  - 查找结果为空（用户已通关）
 *		1 - 查找成功
 *********************************/
bool fetch_level_info(levelinfo&amp; level, int level_id) {
	if (level_id == 0) {
		return false;
	}
	else {
		level = game_data[level_id - 1];
		return true;
	}
}

/******************************
 *功能：将获得的关卡数据转换到map地图数组中
 * 输入：
 *		level - 关卡数据
 *		map - 二维地图数组
 *
 * 返回值：
 *		false - 转换失败
 *		true - 转换成功
 *****************************/
bool transform_map_db2array(levelinfo&amp; level, int map[][COLUMN]) {
	if (level.map_row &gt; LINE || level.map_column &gt; COLUMN) {
		printf("地图过大，请重新设置\n");
		return false;
	}
	if (level.map_data.length() &lt; 1) {
		printf("地图数据有误，请重新设置！\n");
		return false;
	}
	long long start = 0, end = 0;
	int row = 0, column = 0;
	do {
		/******************************
		 *find返回size_t类型值，size_t在64位下是8字节长度，因此这里把start和end设置成long long类型（不设置会有“数据丢失”警告）。当然也可以简单粗暴的修改警告设置
		******************************/
		end = level.map_data.find('|', start);
		if (end == -1) {
			end = level.map_data.length();
		}
		//合法性检查，结束时end=level.map_data.length，start=end+1
		if (start &gt;= end)
			break;
		string line = level.map_data.substr(start, end - start);
		// 对行数据进行解析：0,1,0,1,1,1,1,1,1,1,0,0
		char* next_token = NULL;
		//line转为const char*（C语言中的字符串），strtok_s会修改line里的值，按照某个特定字符，所以需要将line.c_str()转为char *
		// strtok_s第一个参数是要劈开的字符串（要求是一个char *类型的）；第二个参数是按某个字符劈开（会把“，”逗号变成‘\0’结束符，也就是说会修改原来字符串，所以要把原来的const char*转为char*）；第三个参数是这个接口
		// 需要的，用来做定位功能，
		char* item = strtok_s((char*)line.c_str(), ",", &amp;next_token);
		column = 0;
		//printf("%p", next_token);
		//::system("pause");
		//如果某行数据个数多余这个地图列数，控制只读取level.map_column-1个
		while (item &amp;&amp; column &lt; level.map_column) {
			map[row][column] = atoi(item);
			column++;
			//再使用strtok_s接口第一个参数可以写NULL，应该是next_token参数上一次做定位功能时已经记录了要劈开字符串给的某个位置
			item = strtok_s(NULL, ",", &amp;next_token);
		}
		//合法性检查
		if (column &lt; level.map_column) {	// 某行的数据个数小于这个地图的列数
			printf("地图数据解析出错，终止！\n");
			return false;
		}
		row++;

		//列数多余的话直接舍弃
		if (row &gt;= level.map_row) {
			break;
		}
		start = end + 1;
	} while (1 == 1);
	//列数多余则直接报错
	if (row &lt; level.map_row) {
		printf("地图行数少于设定，终止！");
		return false;
	}
	return true;
}

/******************************
 *功能：更新用户游戏进度信息
 * 输入：
 *		user - 用户信息
 *		next_level_id - 游戏进度
 *
 * 返回值：
 *		获取成功返回true，失败false
 *****************************/
bool update_user_level(userinfo&amp; user, int next_level_id) {
	ifstream ifs;
	ifs.open(USERS);
	if (!ifs) {
		return false;
	}
	int user_index = 1;
	string strFileData = "";
	while (1) {
		if (user_index == user.id) {
			{string temp;
			getline(ifs, temp); }
			user_index++;
			continue;
		}
		if (ifs.eof()) {
			break;
		}
		string line;
		getline(ifs, line);
		strFileData += line;
		strFileData += '\n';

	}
	ifs.close();
	stringstream str_stream;
	str_stream &lt;&lt; user.id &lt;&lt; " " &lt;&lt; user.username &lt;&lt; " " &lt;&lt; user.password &lt;&lt; " " &lt;&lt; next_level_id &lt;&lt; endl;
	strFileData += str_stream.str();
	ofstream ofs;
	ofs.open(USERS);
	ofs.flush();
	ofs &lt;&lt; strFileData;
	ofs.close();
	user.level_id = next_level_id;
	return true;
}

/*****************************
* 功能：判断游戏是否结束
* 输入：
*		无
* 输出：
*		true - 未结束
*		flase - 结束
*****************************/
bool isGameOver() {
	for (int i = 0; i &lt; LINE; ++i) {
		for (int j = 0; j &lt; COLUMN; ++j) {
			if (map[i][j] == BOX_DES)
				return false;
		}
	}
	return true;
}

/*****************************
* 功能：加载游戏结束图片
* 输入：
*		无
* 输出：
*		无
*****************************/
void show_over() {
	cleardevice();
	IMAGE game_over;
	loadimage(&amp;game_over, _T("gameover.png"), SCREEN_WIDTH, SCREEN_HEIGHT, true);
	putimage(0, 0, &amp;game_over);
}

/*****************************
* 功能：在指定位置更改地图信息 显示指定图片
* 输入：
*		next_pos - 指定位置
*		prop - 指定图片
* 输出：
*		无
*****************************/
void changeMap(POS* next_pos, PROPS prop) {
	map[next_pos-&gt;x][next_pos-&gt;y] = prop;
	putimage(START_X + next_pos-&gt;y * RATIO, START_Y + next_pos-&gt;x * RATIO, &amp;images[prop]);
}

/*****************************
* 功能：在指定位置显示指定图片
* 输入：
*		next_pos - 指定位置
*		prop - 指定图片
* 输出：
*		无
*****************************/
void changeMap2(POS* next_pos, PROPS prop) {
	putimage(START_X + next_pos-&gt;y * RATIO, START_Y + next_pos-&gt;x * RATIO, &amp;images[prop]);
}

/*****************************
* 功能：控制小人向指定方向移动
* 输入：
*		direct - 指定方向
* 输出：
*		无
*****************************/
void gameControl(DIRECTION direct) {
	POS next_pos = man;
	POS next_next_pos = man;
	switch (direct) {
	case UP:
		next_pos.x--;
		next_next_pos.x -= 2;
		break;
	case DOWN:
		next_pos.x++;
		next_next_pos.x += 2;
		break;
	case LEFT:
		next_pos.y--;
		next_next_pos.y -= 2;
		break;
	case RIGHT:
		next_pos.y++;
		next_next_pos.y += 2;
		break;
	}
	//宏展开next_pos.x &gt; 0 &amp;&amp; next_pos.x &lt; LINE &amp;&amp; next_pos.y&gt;0 &amp;&amp; next_pos.y &lt; COLUMN
	// 人的前方是地板
	if (isValid(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == FLOOR) {
		//人的脚下是目的地
		if (map[man.x][man.y] == BOX_DES) {
			changeMap(&amp;next_pos, MAN);
			changeMap2(&amp;man, BOX_DES);
		}
		else {
			changeMap(&amp;man, FLOOR);
			changeMap(&amp;next_pos, MAN);
		}
		man = next_pos;
	}
	// 人的前方是箱子
	else if (isValid(next_next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == BOX) {
		if (map[next_next_pos.x][next_next_pos.y] == FLOOR) {	// 箱子的前方是地板
			changeMap(&amp;next_next_pos, BOX);
			changeMap(&amp;next_pos, MAN);
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
		else if (map[next_next_pos.x][next_next_pos.y] == BOX_DES) {	// 箱子前面是目的地
			changeMap(&amp;next_next_pos, HIT);
			changeMap(&amp;next_pos, MAN);
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
	}
	//前方是目的地
	else if (isValid(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == BOX_DES) {
		//小人脚下也是目的地
		if (map[man.x][man.y] == BOX_DES) {
			changeMap2(&amp;next_pos, MAN_DES);
			changeMap(&amp;man, BOX_DES);
		}
		else {
			changeMap(&amp;man, FLOOR);
			changeMap2(&amp;next_pos, MAN_DES);

		}
		man = next_pos;
	}
	//前方是箱子命中点
	else if (isValid(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == HIT) {
		if (map[next_next_pos.x][next_next_pos.y] == FLOOR) {	// 箱子的前方是地板
			changeMap(&amp;next_next_pos, BOX);
			changeMap(&amp;next_pos, BOX_DES);
			changeMap2(&amp;next_pos, MAN_DES);
			//人的脚下是目的地
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
		else if (map[next_next_pos.x][next_next_pos.y] == BOX_DES) {	// 箱子前面是目的地
			changeMap(&amp;next_next_pos, HIT);
			changeMap(&amp;next_pos, BOX_DES);
			changeMap2(&amp;next_pos, MAN_DES);
			//人的脚下是目的地
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
	}
}

/*****************************
* 功能：用户登录
* 输入：
*		user - 用户信息
* 输出：
*		false - 登录失败
*		true - 登录成功
*****************************/
bool login(userinfo&amp; user) {
	int times = 0;
	bool ret = false;
	do {
		cout &lt;&lt; "请输入用户名：";
		cin &gt;&gt; user.username;
		cout &lt;&lt; "请输入密码：";
		cin &gt;&gt; user.password;
		ret = fetch_user_info(user);
		times++;
		if (times &gt;= MAX_RETRY_TIMES)
			break;
		if (ret == false) {
			cout &lt;&lt; "登录失败，请重新输入！" &lt;&lt; endl;
		}
	} while (!ret);
	return ret;
}

/*****************************
* 功能：加载游戏素材
* 输入：
*		无
* 输出：
*		无
*****************************/
void init_graph() {
	initgraph(SCREEN_WIDTH, SCREEN_HEIGHT);
	loadimage(&amp;images[WALL], _T("wall_right.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[FLOOR], _T("floor.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[BOX_DES], _T("des.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[MAN], _T("man.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[BOX], _T("box.jpg"), RATIO, RATIO, true);
	loadimage(&amp;images[HIT], _T("box_des.jpg"), RATIO, RATIO, true);
	loadimage(&amp;images[MAN_DES], _T("man_des.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[VECTOR], _T("vector.png"), 6 * RATIO, 6 * RATIO, true);
}

/*****************************
* 功能：显示指定地图
* 输入：
*		level - 指定地图
* 输出：
*		无
*****************************/
void show_images(levelinfo&amp; level) {
	cleardevice();	// 每次贴图清屏一下
	IMAGE bg_img;
	//图片的宽，高最后一个参数“是否拉伸”
	loadimage(&amp;bg_img, _T("bgimage.png"), SCREEN_WIDTH, SCREEN_HEIGHT, true);
	putimage(0, 0, &amp;bg_img);
	for (int i = 0; i &lt; level.map_row; ++i) {
		for (int j = 0; j &lt; level.map_column; ++j) {
			if (map[i][j] == MAN) {
				man.x = i;
				man.y = j;
			}
			if (map[i][j] == BG_IMAGE)
				continue;
			putimage(START_X + j * RATIO, START_Y + i * RATIO, &amp;images[map[i][j]]);
		}
	}
	const char* str = level.name.c_str();
	setbkmode(TRANSPARENT);
	setfont(RATIO, 0, _T("华文楷体"));
	setcolor(WHITE);
	outtextxy(200, 25, str);
}

/*****************************
* 功能：载入PNG图并去透明部分
* 输入：
*		无
* 输出：
*		无
*****************************/
void drawAlpha(IMAGE* picture, int  picture_x, int picture_y) //x为载入图片的X坐标，y为Y坐标
{
	// 变量初始化
	DWORD* dst = GetImageBuffer();    // GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带
	DWORD* draw = GetImageBuffer();
	DWORD* src = GetImageBuffer(picture); //获取picture的显存指针
	int picture_width = picture-&gt;getwidth(); //获取picture的宽度，EASYX自带
	int picture_height = picture-&gt;getheight(); //获取picture的高度，EASYX自带
	int graphWidth = getwidth();       //获取绘图区的宽度，EASYX自带
	int graphHeight = getheight();     //获取绘图区的高度，EASYX自带
	int dstX = 0;    //在显存里像素的角标

	// 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算
	for (int iy = 0; iy &lt; picture_height; iy++)
	{
		for (int ix = 0; ix &lt; picture_width; ix++)
		{
			int srcX = ix + iy * picture_width; //在显存里像素的角标
			int sa = ((src[srcX] &amp; 0xff000000) &gt;&gt; 24); //0xAArrggbb;AA是透明度
			int sr = ((src[srcX] &amp; 0xff0000) &gt;&gt; 16); //获取RGB里的R
			int sg = ((src[srcX] &amp; 0xff00) &gt;&gt; 8);   //G
			int sb = src[srcX] &amp; 0xff;              //B
			if (ix &gt;= 0 &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= 0 &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight)
			{
				dstX = (ix + picture_x) + (iy + picture_y) * graphWidth; //在显存里像素的角标
				int dr = ((dst[dstX] &amp; 0xff0000) &gt;&gt; 16);
				int dg = ((dst[dstX] &amp; 0xff00) &gt;&gt; 8);
				int db = dst[dstX] &amp; 0xff;
				draw[dstX] = ((sr * sa / 255 + dr * (255 - sa) / 255) &lt;&lt; 16)  //公式： Cp=αp*FP+(1-αp)*BP  ； αp=sa/255 , FP=sr , BP=dr
					| ((sg * sa / 255 + dg * (255 - sa) / 255) &lt;&lt; 8)         //αp=sa/255 , FP=sg , BP=dg
					| (sb * sa / 255 + db * (255 - sa) / 255);              //αp=sa/255 , FP=sb , BP=db
			}
		}
	}
}

/*****************************
* 功能：载入“恭喜通关”图片
* 输入：
*		无
* 输出：
*		无
*****************************/
void promot_over() {
	setbkmode(TRANSPARENT);
	drawAlpha(&amp;images[VECTOR], 250, 130);     // 载入PNG图并去透明部分
	Sleep(1100);
}

/*****************************
* 功能：休眠
* 输入：
*		interval - 休眠时间
* 输出：
*		无
*****************************/
void wait(int interval) {
	int count = interval / 10;
	for (int i = 0; i &lt; count; ++i) {
		Sleep(10);
		if (_kbhit())
			return;
	}
}

/*****************************
* 功能：游戏控制
* 输入：
*		level - 挡墙关卡数据
*		user - 用户信息
* 输出：
*		无
*****************************/
void game_operation(levelinfo&amp; level, userinfo&amp; user) {
	bool quit = false;
	do {
		//判断是否有按键按下
		if (_kbhit()) {
			//无缓冲读取
			char ch = _getch();
			if (ch == KEY_UP) {
				gameControl(UP);
			}
			else if (ch == KEY_DOWN) {
				gameControl(DOWN);
			}
			else if (ch == KEY_LEFT) {
				gameControl(LEFT);
			}
			else if (ch == KEY_RIGHT) {
				gameControl(RIGHT);
			}
			else if (ch == GAME_AGAIN) {
				fetch_level_info(level, user.level_id);
				transform_map_db2array(level, map);
				show_images(level);
			}
			else if (ch == KEY_OUT) {
				closegraph();
				exit(0);
			}
			if (isGameOver()) {
				//更新用户下一关关卡信息（用户通关后直接跳转下一关）
				update_user_level(user, level.next_level);
				quit = true;
			}
		}
		wait(100);
	} while (quit == false);
}

/*****************************
* 功能：根据“由用户ID获取关卡数据”的返回结果进行判断
* 输入：
*		result - 返回结果（-1：获取失败  0：用户已通关  1：获取成功）
*		level - 关卡数据
*		user - 用户信息
* 输出：
*		无
*****************************/
void judge_by_result(levelinfo&amp; level, userinfo&amp; user) {
	show_over();
	do {
		//判断是否有按键按下
		if (_kbhit()) {
			//无缓冲读取
			char ch = _getch();
			if (ch == KEY_OUT) {
				closegraph();
				exit(0);
			}
			else if (ch == GAME_AGAIN) {
				if (!update_user_level(user, 1)) {
					std::system("pause");
					closegraph();
					exit(0);
				}
				break;
			}
		}
		Sleep(50);
	} while (1);
	fetch_level_info(level, user.level_id);
}
int main() {
//作为数据初始化，只需运行一次    
	resetting_data();
	load_data();
	//用户身份验证
	userinfo user;
	levelinfo level;
	if (!login(user)) {
		cout &lt;&lt; "登录失败，请重新登录！" &lt;&lt; endl;
		::system("pause");
		exit(-1);
	}
	init_graph();
	//循环（读取关卡→用户操作）
	do {
		//根据用户信息加载关卡数据
		if (!fetch_level_info(level, user.level_id)) {
			judge_by_result(level, user);
		}
		//将关卡数据数据转换到map游戏地图中
		transform_map_db2array(level, map);
		//加载游戏图片
		show_images(level);
		//小人移动
		game_operation(level, user);
		//恭喜通关
		promot_over();
	} while (1);
	std::system("pause");
	closegraph();
	return 0;
}</code></pre>
    <h2>
     <strong>
      目录
     </strong>
    </h2>
    <p style="margin-left:0px;">
     <a href="#%E4%B8%80%E3%80%81%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F%E6%BA%90%E7%A0%81%EF%BC%88%E5%8F%AF%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D%E8%BF%90%E8%A1%8C%EF%BC%89" rel="nofollow">
      一、
      <span style="color:#be191c;">
       <strong>
        推箱子游戏源码（可直接拷贝运行）
       </strong>
      </span>
     </a>
    </p>
    <p style="margin-left:0px;">
     <a href="#%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F%E5%AE%9E%E7%8E%B0" rel="nofollow">
      二、C语言推箱子游戏实现
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#1.%E5%9C%B0%E5%9B%BE%E5%88%9D%E5%A7%8B%E5%8C%96%20init_graph%28%20%29%20+%20show_images%28%20%29" rel="nofollow">
      1.地图初始化 init_graph( ) + show_images( )
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%202.%E5%9C%B0%E5%9B%BE%E8%A1%A8%E7%A4%BA" rel="nofollow">
      2.地图表示
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%203.%E8%AE%BE%E8%AE%A1%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6%20%F0%9F%91%89%20%E5%BE%AA%E7%8E%AF%EF%BC%88%E8%AF%BB%E5%8F%96%E5%85%B3%E5%8D%A1%E2%86%92%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%EF%BC%89" rel="nofollow">
      3.设计操作框架 👉 循环（读取关卡→用户操作）
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%204.%E7%AE%B1%E5%AD%90%E6%8E%A7%E5%88%B6game_operation%28%20%29" rel="nofollow">
      4.箱子控制game_operation( )
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%E2%91%A0%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6" rel="nofollow">
      ①设计用户操作框架
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%E2%91%A1%E6%8E%A7%E5%88%B6%E5%B0%8F%E4%BA%BA%E6%8C%87%E5%AE%9A%E6%96%B9%E5%90%91%E7%A7%BB%E5%8A%A8" rel="nofollow">
      ②控制小人指定方向移动
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%E2%91%A2%E6%B8%B8%E6%88%8F%E9%80%80%E5%87%BA" rel="nofollow">
      ③游戏退出
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%E2%91%A3%E6%B8%B8%E6%88%8F%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B" rel="nofollow">
      ④游戏重新开始
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%E2%91%A4%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F%E5%88%A4%E6%96%AD" rel="nofollow">
      ⑤游戏结束判断
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%C2%A0%E2%91%A5%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85" rel="nofollow">
      ⑥用户操作框架补充
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%205.%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E9%80%9A%E5%85%B3%E5%9B%BE%E7%89%87%EF%BC%88%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDpng%E9%80%8F%E6%98%8E%E5%9B%BE%E7%89%87%EF%BC%89" rel="nofollow">
      5.加载游戏通关图片（如何加载png透明图片）
     </a>
    </p>
    <p style="margin-left:0px;">
     <a href="#%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F" rel="nofollow">
      二、编写数据库连接程序
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E4%B8%8E%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%BA%90%E7%A0%81" rel="nofollow">
      前言：
      <span style="color:#be191c;">
       <strong>
        与连接MySQL数据库源码
       </strong>
      </span>
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%20&amp;&amp;%20C++%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BE%E8%AE%A1" rel="nofollow">
      1.数据库表的设计 &amp;&amp; C++结构体设计
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%C2%A0%C2%A0%C2%A0%20%E2%91%A0SQL%E8%AF%AD%E5%8F%A5%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE" rel="nofollow">
      ①SQL语句创建数据
     </a>
    </p>
    <p style="margin-left:80px;">
     <a href="#%C2%A0%20%C2%A0%20%E2%91%A1C++%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BE%E8%AE%A1" rel="nofollow">
      ②C++结构体设计
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%20%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%20fetch_user_info%28%20%29" rel="nofollow">
      2.用户登录 fetch_user_info( )
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%20%E8%8E%B7%E5%8F%96%E5%85%B3%E5%8D%A1%E4%BF%A1%E6%81%AF" rel="nofollow">
      3.获取关卡信息
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%20%E5%9C%B0%E5%9B%BE%E8%BD%AC%E6%8D%A2" rel="nofollow">
      4.地图转换
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%20%E8%B7%B3%E8%BD%AC%E4%B8%8B%E4%B8%80%E5%85%B3" rel="nofollow">
      5.跳转下一关
     </a>
    </p>
    <p style="margin-left:0px;">
     <a href="#%E4%B8%89%E3%80%81%E5%8D%87%E7%BA%A7%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E8%BF%9E" rel="nofollow">
      三、修改游戏代码适应与数据库连接
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#1.%E6%90%9E%E5%AE%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD" rel="nofollow">
      1.搞定用户登录功能
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#2.%E5%AF%B9%E7%94%A8%E6%88%B7%E7%9A%84%E6%B8%B8%E6%88%8F%E8%BF%9B%E5%BA%A6%E5%81%9A%E5%87%BA%E5%88%A4%E6%96%AD" rel="nofollow">
      2.对用户的游戏进度做出判断
     </a>
    </p>
    <p style="margin-left:0px;">
     <a href="#%E5%9B%9B%E3%80%81%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83" rel="nofollow">
      四、程序打包发布
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%E4%B8%80%E3%80%81%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E7%BB%84%E4%BB%B6" rel="nofollow">
      1.下载程序打包组件
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%C2%A0%E4%BA%8C%E3%80%81%E8%AE%BE%E7%BD%AEVS%E7%BC%96%E8%AF%91%E5%99%A8" rel="nofollow">
      2.设置VS编译器
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E4%B8%89%E3%80%81%E5%9C%A8%E5%90%8C%E4%B8%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8B%E5%88%9B%E5%BB%BASetup%E9%A1%B9%E7%9B%AE" rel="nofollow">
      3.在同一解决方案下创建Setup项目
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E5%9B%9B%E3%80%81%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%88%B0Setup%E9%A1%B9%E7%9B%AE%E4%B8%AD" rel="nofollow">
      4.添加项目文件到Setup项目中
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E4%BA%94%E3%80%81%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE%E8%BE%93%E5%87%BA" rel="nofollow">
      5.添加项目输出
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E5%85%AD%E3%80%81%E5%B0%86%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%94%BE%E5%85%A5%E7%94%A8%E6%88%B7%E6%A1%8C%E9%9D%A2%E4%B8%AD" rel="nofollow">
      6.将快捷方式放入用户桌面中
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E4%B8%83%E3%80%81%E4%B8%BA%E7%A8%8B%E5%BA%8F%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%A0%87" rel="nofollow">
      7.为程序选择一个图标
     </a>
    </p>
    <p style="margin-left:40px;">
     <a href="#%E5%85%AB%E3%80%81%E5%B0%86%E5%9B%BE%E6%A0%87%E4%B8%8E%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%BB%91%E5%AE%9A" rel="nofollow">
      8.将图标与快捷方式绑定
     </a>
    </p>
    <p style="margin-left:0px;">
     <a href="#%E4%BA%94%E3%80%81%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" rel="nofollow">
      五、不足之处
     </a>
    </p>
    <hr/>
    <p>
    </p>
    <h2>
     二、C语言推箱子游戏实现
    </h2>
    <h3>
     1.地图初始化 init_graph( ) + show_images( )
    </h3>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/4d816b925fd4b3e77af2dbb7c8f72be3.png">
       ​
      </img>
     </p>
    </div>
    <p>
     我们首先需要初始化画布，加载游戏背景图以及所需其他图片素材。
    </p>
    <div>
     <pre><code class="language-cpp">typedef enum  _PROPS {
	WALL,	//墙
	FLOOR,	//地板
	BOX_DES,//箱子目的地
	MAN,	//小人
	BOX,	//箱子
	HIT,	//箱子命中目标
	MAN_DES,	//人站在目标上
	VECTOR	//通关图片
}PROPS;

/*****************************
* 功能：加载游戏素材
* 输入：
*		无
* 输出：
*		无
*****************************/
void init_graph() {
	initgraph(SCREEN_WIDTH, SCREEN_HEIGHT);
	loadimage(&amp;images[WALL], _T("wall_right.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[FLOOR], _T("floor.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[BOX_DES], _T("des.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[MAN], _T("man.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[BOX], _T("box.jpg"), RATIO, RATIO, true);
	loadimage(&amp;images[HIT], _T("box_des.jpg"), RATIO, RATIO, true);
	loadimage(&amp;images[MAN_DES], _T("man_des.bmp"), RATIO, RATIO, true);
	loadimage(&amp;images[VECTOR], _T("vector.png"), 6 * RATIO, 6 * RATIO, true);
}

/*****************************
* 功能：显示指定地图
* 输入：
*		level - 指定地图
* 输出：
*		无
*****************************/
void show_images(levelinfo&amp; level) {
	cleardevice();	// 每次贴图清屏一下
	IMAGE bg_img;
	//图片的宽，高最后一个参数“是否拉伸”
	loadimage(&amp;bg_img, _T("bgimage.png"), SCREEN_WIDTH, SCREEN_HEIGHT, true);
	putimage(0, 0, &amp;bg_img);
	for (int i = 0; i &lt; level.map_row; ++i) {
		for (int j = 0; j &lt; level.map_column; ++j) {
			if (map[i][j] == MAN) {
				man.x = i;
				man.y = j;
			}
			if (map[i][j] == BG_IMAGE)
				continue;
			putimage(START_X + j * RATIO, START_Y + i * RATIO, &amp;images[map[i][j]]);
		}
	}
	const char* str = level.name.c_str();
	setbkmode(TRANSPARENT);
	setfont(RATIO, 0, _T("华文楷体"));
	setcolor(WHITE);
	outtextxy(200, 25, str);
}</code></pre>
    </div>
    <h3>
     2.地图表示
    </h3>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/b06164ecf9438ebf1cc61b3c76e9d646.png">
      ​
     </img>
    </p>
    <p>
     游戏地图使用二维数组存储，对不同的图形用不同的数字表示
    </p>
    <div>
     <pre><code class="language-cpp">//墙: 0；地板: 1；箱子目的地: 2,；小人: 3；箱子: 4；背景图：-1；目标: 5
int mapdata[LINE][COLUMN] = {
    {-1,0,0,0,0,0,0,0,-1,-1 },
    { -1, 0, 2, 2, 2, 2, 1, 0, -1, -1 },
    {0, 0, 0, 2, 2, 2, 4, 0, 0, 0 },
    {0, 1, 1, 4, 0, 4, 1, 4, 1, 0 },
    {0, 1, 4, 4, 1, 1, 0, 4, 1, 0 },
    {0, 1, 1, 1, 3, 0, 1, 1, 1, 0 },
    {0, 0, 0, 0, 1, 1, 1, 0, 0, 0, },
    {-1, -1, -1, 0, 0, 0, 0, 0, -1, -1}
};</code></pre>
    </div>
    <h3>
     <strong>
      3.设计操作框架 👉
     </strong>
     循环（读取关卡→用户操作）
    </h3>
    <p>
     每次读取关卡，然后是用户操作，用户通关后继续读取下一关卡。如果用户中途按下退出键则会退出游戏。
    </p>
    <div>
     <pre><code class="language-cpp">int main() {    
    //读取地图信息
    memcpy(map, mapdata, sizeof(mapdata));
    init_graph();//循环（读取关卡→用户操作）
    do {
        //加载游戏图片
        show_images();
        //用户操作
        game_operation();
        //恭喜通关
        promot_over();
        } while (1);
    std::system("pause");
    closegraph();
    return 0;
}</code></pre>
    </div>
    <h3>
     4.箱子控制game_operation( )
    </h3>
    <h4>
     ①设计用户操作框架
    </h4>
    <p>
     通过循环，每次读取用户按键，根据按键做出相应游戏效果实现。小人每次可以上下左右四个方向移动，以及用户的退出和重新开始共六个热键。当游戏结束时退出循环，如果用户按下退出则直接结束游戏。
    </p>
    <div>
     <pre><code class="language-cpp">#define KEY_UP 'W'    //上移
#define KEY_LEFT 'A'    //左移
#define KEY_RIGHT 'D'    //右移
#define KEY_DOWN 'S'    //下移
#define KEY_OUT 'Q'    //退出
#define GAME_AGAIN 'R'    //重试/
*****************************
* 功能：游戏控制
* 输入：        
*    无
* 输出：
*    无
*****************************/
void game_operation() {
    bool quit = false;    //记录是否游戏结束
    do {
        //判断是否有按键按下
        if (_kbhit()) {
            //无缓冲读取
            char ch = _getch();
            if (ch == KEY_UP) {
                // to do
            }else if (ch == KEY_DOWN) {
                // to do
            }else if (ch == KEY_LEFT) {
                // to do
            }else if (ch == KEY_RIGHT) {
                // to do
            }else if (ch == GAME_AGAIN) {
                // to do
            }else if (ch == KEY_OUT) {
                // to do
            }if (isGameOver()) {
                // to do
            }
        }wait(100);
    } while (quit == false);
}</code></pre>
    </div>
    <h4>
     ②控制小人指定方向移动
    </h4>
    <p>
     对于小人可以移动的情况可以分成四种：
    </p>
    <p>
     Ⅰ：小人前面是地板
    </p>
    <p>
     Ⅱ：小人前面是目的地
    </p>
    <p>
     Ⅲ：小人项目是箱子
    </p>
    <p>
     Ⅳ：小人前面是已经在目的地上的箱子
    </p>
    <p>
     还有其他可能出现的情况都属于不能移动。那为什么要分成这四种情况呢？如果小人前面是地板或者箱子时，每次移动我们要去更改地图信息（为判断游戏结束做准备），而如果小人前面是目的地或者是已经在目的地上的箱子那就不能更改地图信息了。
    </p>
    <div>
     <pre><code class="language-cpp">#define isValid(next_pos) next_pos.x &gt; 0 &amp;&amp; next_pos.x &lt; LINE &amp;&amp; next_pos.y&gt;0 &amp;&amp; next_pos.y &lt; COLUMN

/*****************************
* 功能：在指定位置更改地图信息 显示指定图片
* 输入：
*		next_pos - 指定位置
*		prop - 指定图片
* 输出：	
*		无
*****************************/
void changeMap(POS* next_pos, PROPS prop) {
	map[next_pos-&gt;x][next_pos-&gt;y] = prop;
	putimage(START_X + next_pos-&gt;y * RATIO, START_Y + next_pos-&gt;x * RATIO, &amp;images[prop]);
}

/*****************************
* 功能：在指定位置显示指定图片
* 输入：
*		next_pos - 指定位置
*		prop - 指定图片
* 输出：
*		无
*****************************/
void changeMap2(POS* next_pos, PROPS prop) {
	putimage(START_X + next_pos-&gt;y * RATIO, START_Y + next_pos-&gt;x * RATIO, &amp;images[prop]);
}

/*****************************
* 功能：控制小人向指定方向移动
* 输入：
*		direct - 指定方向
* 输出：
*		无
*****************************/
void gameControl(DIRECTION direct) {
	POS next_pos = man;
	POS next_next_pos = man;
	switch (direct) {
	case UP:
		next_pos.x--;
		next_next_pos.x -= 2;
		break;
	case DOWN:
		next_pos.x++;
		next_next_pos.x += 2;
		break;
	case LEFT :
		next_pos.y--;
		next_next_pos.y -= 2;
		break;
	case RIGHT:
		next_pos.y++;
		next_next_pos.y += 2;
		break;
	}	
	//宏展开next_pos.x &gt; 0 &amp;&amp; next_pos.x &lt; LINE &amp;&amp; next_pos.y&gt;0 &amp;&amp; next_pos.y &lt; COLUMN
	// 人的前方是地板
	if (isValid(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == FLOOR) {
		//人的脚下是目的地
		if (map[man.x][man.y] == BOX_DES) {
			changeMap(&amp;next_pos, MAN);
			changeMap2(&amp;man, BOX_DES);
		}
		else {
			changeMap(&amp;man, FLOOR);
			changeMap(&amp;next_pos, MAN);
		}	
		man = next_pos;
	}
	// 人的前方是箱子
	else if (isValid(next_next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == BOX) {	
		if (map[next_next_pos.x][next_next_pos.y] == FLOOR) {	// 箱子的前方是地板
			changeMap(&amp;next_next_pos, BOX);
			changeMap(&amp;next_pos, MAN);
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
		else if (map[next_next_pos.x][next_next_pos.y] == BOX_DES) {	// 箱子前面是目的地
			changeMap(&amp;next_next_pos, HIT);
			changeMap(&amp;next_pos, MAN);
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}	
	}
	//前方是目的地
	else if (isValid(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == BOX_DES) {
		//小人脚下也是目的地
		if (map[man.x][man.y] == BOX_DES) {
			changeMap2(&amp;next_pos, MAN_DES);
			changeMap(&amp;man, BOX_DES);
		}
		else {
			changeMap(&amp;man, FLOOR);
			changeMap2(&amp;next_pos, MAN_DES);
			
		}
		man = next_pos;
	}
	//前方是箱子命中点
	else if (isValid(next_pos) &amp;&amp; map[next_pos.x][next_pos.y] == HIT) {
		if (map[next_next_pos.x][next_next_pos.y] == FLOOR) {	// 箱子的前方是地板
			changeMap(&amp;next_next_pos, BOX);
			changeMap(&amp;next_pos, BOX_DES);
			changeMap2(&amp;next_pos, MAN_DES);
			//人的脚下是目的地
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
		else if (map[next_next_pos.x][next_next_pos.y] == BOX_DES) {	// 箱子前面是目的地
			changeMap(&amp;next_next_pos, HIT);
			changeMap(&amp;next_pos, BOX_DES);
			changeMap2(&amp;next_pos, MAN_DES);
			//人的脚下是目的地
			if (map[man.x][man.y] == BOX_DES) {
				changeMap(&amp;man, BOX_DES);
			}
			else {
				changeMap(&amp;man, FLOOR);
			}
			man = next_pos;
		}
	}
}</code></pre>
    </div>
    <h4>
     ③游戏退出
    </h4>
    <p>
     如果用户按下“Q”键可以直接退出游戏，这个还是比较好写的直接一个exit(0)
    </p>
    <div>
     <pre><code class="language-cpp">else if (ch == KEY_OUT) {
    closegraph();exit(0);
}</code></pre>
    </div>
    <h4>
     ④游戏重新开始
    </h4>
    <p>
     如果用户按下“R”键，重置游戏。现在还没有连接数据库，这个功能还是容易完成，只要重置地图信息然后显示出来即可
    </p>
    <div>
     <pre><code class="language-cpp">else if (ch == GAME_AGAIN) {
    memcpy(map, mapdata, sizeof(mapdata));
    show_images();
}</code></pre>
    </div>
    <h4>
     ⑤游戏结束判断
    </h4>
    <p>
     每次将箱子推到目的地时我们已经更改地图信息，所以对于游戏是否结束判断我们可以遍历地图，只要找不到“目的地”则代表游戏结束。
    </p>
    <div>
     <pre><code class="language-cpp">/*****************************
* 功能：判断游戏是否结束
* 输入：
*		无
* 输出：
*		true - 未结束
*		flase - 结束
*****************************/
bool isGameOver() {
	for (int i = 0; i &lt; LINE; ++i) {
		for (int j = 0; j &lt; COLUMN; ++j) {
			if (map[i][j] == BOX_DES)
				return false;
		}
	}
	return true;
}</code></pre>
    </div>
    <h4>
     ⑥用户操作框架补充
    </h4>
    <p>
     将上述实现功能补充到用户操作框架中
    </p>
    <div>
     <pre><code class="language-cpp">/*****************************
* 功能：游戏控制
* 输入：
*		level - 挡墙关卡数据
*		user - 用户信息
* 输出：
*		无
*****************************/
void game_operation() {
	bool quit = false;
	do {
		//判断是否有按键按下
		if (_kbhit()) {
			//无缓冲读取
			char ch = _getch();
			if (ch == KEY_UP) {
				gameControl(UP);
			}
			else if (ch == KEY_DOWN) {
				gameControl(DOWN);
			}
			else if (ch == KEY_LEFT) {
				gameControl(LEFT);
			}
			else if (ch == KEY_RIGHT) {
				gameControl(RIGHT);
			}
			else if (ch == GAME_AGAIN) {
				memcpy(map, mapdata, sizeof(mapdata));
				show_images();
			}
			else if (ch == KEY_OUT) {
				closegraph();
				exit(0);
			}
			if (isGameOver()) {
				quit = true;
			}
		}
		wait(100);
	} while (quit == false);
}
</code></pre>
    </div>
    <h3>
     5.加载游戏通关图片（如何加载png透明图片）
    </h3>
    <p>
     其实加载游戏通关图片只需使用putimage函数即可，这里之所以单独作为一个标题是因为使用putimage时如果时png透明图片加载出来时还是会有背景，这里为大家提供一个可以加载png透明背景图片的算法（可以单独拷贝使用）
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/6d81b879a1bb08699b15eca78f8d92af.png">
       ​
      </img>
     </p>
    </div>
    <div>
     <pre><code class="language-cpp">/*****************************
* 功能：载入PNG图并去透明部分
* 输入：
*		无
* 输出：
*		无
*****************************/
void drawAlpha(IMAGE* picture, int  picture_x, int picture_y) //x为载入图片的X坐标，y为Y坐标
{

	// 变量初始化
	DWORD* dst = GetImageBuffer();    // GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带
	DWORD* draw = GetImageBuffer();
	DWORD* src = GetImageBuffer(picture); //获取picture的显存指针
	int picture_width = picture-&gt;getwidth(); //获取picture的宽度，EASYX自带
	int picture_height = picture-&gt;getheight(); //获取picture的高度，EASYX自带
	int graphWidth = getwidth();       //获取绘图区的宽度，EASYX自带
	int graphHeight = getheight();     //获取绘图区的高度，EASYX自带
	int dstX = 0;    //在显存里像素的角标

	// 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算
	for (int iy = 0; iy &lt; picture_height; iy++)
	{
		for (int ix = 0; ix &lt; picture_width; ix++)
		{
			int srcX = ix + iy * picture_width; //在显存里像素的角标
			int sa = ((src[srcX] &amp; 0xff000000) &gt;&gt; 24); //0xAArrggbb;AA是透明度
			int sr = ((src[srcX] &amp; 0xff0000) &gt;&gt; 16); //获取RGB里的R
			int sg = ((src[srcX] &amp; 0xff00) &gt;&gt; 8);   //G
			int sb = src[srcX] &amp; 0xff;              //B
			if (ix &gt;= 0 &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= 0 &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight)
			{
				dstX = (ix + picture_x) + (iy + picture_y) * graphWidth; //在显存里像素的角标
				int dr = ((dst[dstX] &amp; 0xff0000) &gt;&gt; 16);
				int dg = ((dst[dstX] &amp; 0xff00) &gt;&gt; 8);
				int db = dst[dstX] &amp; 0xff;
				draw[dstX] = ((sr * sa / 255 + dr * (255 - sa) / 255) &lt;&lt; 16)  //公式： Cp=αp*FP+(1-αp)*BP  ； αp=sa/255 , FP=sr , BP=dr
					| ((sg * sa / 255 + dg * (255 - sa) / 255) &lt;&lt; 8)         //αp=sa/255 , FP=sg , BP=dg
					| (sb * sa / 255 + db * (255 - sa) / 255);              //αp=sa/255 , FP=sb , BP=db
			}
		}
	}
}

/*****************************
* 功能：载入“恭喜通关”图片
* 输入：
*		无
* 输出：
*		无
*****************************/
void promot_over() {
	setbkmode(TRANSPARENT);
	drawAlpha(&amp;images[VECTOR], 250, 130);     // 载入PNG图并去透明部分
	Sleep(1100);
}</code></pre>
    </div>
    <p>
     <strong>
      到这里推箱子游戏就已经完成了，接下来就是将数据库与游戏连接起来。
     </strong>
    </p>
    <h2>
     二、编写数据库连接程序
    </h2>
    <p>
     上面 分享的源码是基于文本文档做为数据库存储，小编就使不做过多说明。这里为大家分享如何与MySQL数据库连接
    </p>
    <h3>
     前言：与连接MySQL数据库源码
    </h3>
    <p>
     <a class="link-info has-card" href="https://download.csdn.net/download/qq_54169998/81166262" title="连接MySQL数据库源码">
      <span class="link-card-box">
       <span class="link-title">
        连接MySQL数据库源码
       </span>
       <span class="link-link">
        <img alt="" class="link-link-icon" src="https://i-blog.csdnimg.cn/blog_migrate/108103d72789eafe62012253d677a985.png">
         https://download.csdn.net/download/qq_54169998/81166262
        </img>
       </span>
      </span>
     </a>
     在编写程序之前，首先要做的是配置VS编译器，如果有不会的朋友可以参考下面的配置教程
    </p>
    <p>
     <a class="link-info has-card" href="https://blog.csdn.net/qq_54169998/article/details/122764798?spm=1001.2014.3001.5501" title="C/C++连接MySQL数据库   配置VS编译器">
      <span class="link-card-box">
       <span class="link-title">
        C/C++连接MySQL数据库 配置VS编译器
       </span>
       <span class="link-link">
        <img alt="" class="link-link-icon" src="https://i-blog.csdnimg.cn/blog_migrate/47d24f4aaa077eeb7345bbfa47a6853e.png">
         https://blog.csdn.net/qq_54169998/article/details/122764798?spm=1001.2014.3001.5501
        </img>
       </span>
      </span>
     </a>
    </p>
    <h3>
     1.数据库表的设计 &amp;&amp; C++结构体设计
    </h3>
    <ul>
     <li>
      用户表
     </li>
    </ul>
    <table border="1" cellspacing="0">
     <tbody>
      <tr>
       <td style="background-color:#ffffff;width:84.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           表名
          </strong>
         </strong>
        </p>
       </td>
       <td colspan="5" style="background-color:#ffffff;width:444.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           Users
          </strong>
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td style="background-color:#d7d7d7;width:84.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           字段名
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:79.1pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           类型
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:63.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           是否为空
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:61.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           默认值
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:57.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           主、外键
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:182.15pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           备注
          </strong>
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td style="background-color:#ffffff;width:84.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         id
        </p>
       </td>
       <td style="background-color:#ffffff;width:79.1pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         int(11)
        </p>
       </td>
       <td style="background-color:#ffffff;width:63.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="background-color:#ffffff;width:61.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         1,自增长
        </p>
       </td>
       <td style="background-color:#ffffff;width:57.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         PK
        </p>
       </td>
       <td style="background-color:#ffffff;width:182.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         用户id
        </p>
       </td>
      </tr>
      <tr>
       <td style="background-color:#ffffff;width:84.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         username
        </p>
       </td>
       <td style="background-color:#ffffff;width:79.1pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         varchar(64)
        </p>
       </td>
       <td style="background-color:#ffffff;width:63.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="background-color:#ffffff;width:61.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="background-color:#ffffff;width:57.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="background-color:#ffffff;width:182.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         用户名：英文字符、数字和特殊符号的组合
        </p>
       </td>
      </tr>
      <tr>
       <td style="background-color:#ffffff;width:84.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         password
        </p>
       </td>
       <td style="background-color:#ffffff;width:79.1pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         varchar(32)
        </p>
       </td>
       <td style="background-color:#ffffff;width:63.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="background-color:#ffffff;width:61.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="background-color:#ffffff;width:57.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="background-color:#ffffff;width:182.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         密码：英文字符、数字和特殊符号的组合，8-16位
        </p>
       </td>
      </tr>
      <tr>
       <td style="background-color:#ffffff;width:84.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         level_id
        </p>
       </td>
       <td style="background-color:#ffffff;width:79.1pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         int
        </p>
       </td>
       <td style="background-color:#ffffff;width:63.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="background-color:#ffffff;width:61.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         1
        </p>
       </td>
       <td style="background-color:#ffffff;width:57.85pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="background-color:#ffffff;width:182.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         当前关卡，关联Levels表中的id
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      关卡表
     </li>
    </ul>
    <table border="1" cellspacing="0">
     <tbody>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           表名
          </strong>
         </strong>
        </p>
       </td>
       <td colspan="5" style="vertical-align:top;width:444.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           Levels
          </strong>
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td style="background-color:#d7d7d7;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           字段名
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           类型
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           是否为空
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           默认值
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           主、外键
          </strong>
         </strong>
        </p>
       </td>
       <td style="background-color:#d7d7d7;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         <strong>
          <strong>
           备注
          </strong>
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         id
        </p>
       </td>
       <td style="vertical-align:top;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         int
        </p>
       </td>
       <td style="vertical-align:top;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="vertical-align:top;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         1
        </p>
       </td>
       <td style="vertical-align:top;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         PK
        </p>
       </td>
       <td style="vertical-align:top;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         游戏关卡序号，从1开始
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         name
        </p>
       </td>
       <td style="vertical-align:top;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         varchar(64)
        </p>
       </td>
       <td style="vertical-align:top;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="vertical-align:top;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         地图名称
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         map_row
        </p>
       </td>
       <td style="vertical-align:top;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         int
        </p>
       </td>
       <td style="vertical-align:top;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="vertical-align:top;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         地图二位组的总行数
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         map_column
        </p>
       </td>
       <td style="vertical-align:top;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         int
        </p>
       </td>
       <td style="vertical-align:top;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="vertical-align:top;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         地图二维组的总列数
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         map_data
        </p>
       </td>
       <td style="vertical-align:top;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         varchar(4096)
        </p>
       </td>
       <td style="vertical-align:top;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         NOT
        </p>
       </td>
       <td style="vertical-align:top;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         地图数据，二维数组对应的行列式，多行以|分开,列以逗号分隔，最大接近支持45x45的地图
        </p>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top;width:84.6pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         next_level_id
        </p>
       </td>
       <td style="vertical-align:top;width:92.7pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         int
        </p>
       </td>
       <td style="vertical-align:top;width:58.9pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:63.3pt;">
        <p style="margin-left:.0001pt;text-align:center;">
         0
        </p>
       </td>
       <td style="vertical-align:top;width:60.55pt;">
        <p style="margin-left:.0001pt;text-align:center;">
        </p>
       </td>
       <td style="vertical-align:top;width:169.15pt;">
        <p style="margin-left:.0001pt;text-align:left;">
         下一关的关卡id,0代表通关
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     ①SQL语句创建数据
    </h4>
    <div>
     <pre><code class="language-sql">create database box_man if not exists;
use box_man;
create table users ( 
    id int not null auto_increment,
    username varchar(64) not null,
    password varchar(32) not null,
    level_id int default 1,
    primary key(id),
    unique key username(username)
);

create table levels(
    id int not null auto_increment,
    name varchar(64) not null,
    map_row int not null,
    map_column int not null,
    map_data varchar(4096) not null,
    next_level_id int default 0 comment '下一关的id，0代表通关',
    primary key(id)
);
insert into users 
    values(1,'Jack',md5(123456),1);
insert into levels 
    values(1,'小试牛刀→第一关',8,10,'-1,0,0,0,0,0,0,0,-1,-1|-1,0,2,2,2,2,1,0,-1,-1|0,0,0,2,2,2,4,0,0,0|0,1,1,4,0,4,1,4,1,0|0,1,4,4,1,1,0,4,1,0|0,1,1,1,3,0,1,1,1,0|0,0,0,0,1,1,1,0,0,0,|-1,-1,-1,0,0,0,0,0,-1,-1',2),
    (2,'绝地强者→第二关',6,6,'0,0,0,0,0,0|0,2,2,1,1,0|0,4,4,1,3,0|0,2,1,4,0,0|0,1,1,1,0,-1|0,0,0,0,0,-1',3),
    (3,'天外强人→第三关',8,10,'-1,-1,0,0,0,0,0,0,-1,-1|0,0,0,1,1,1,0,0,0,0|0,1,1,1,4,1,4,1,1,0|0,1,4,1,1,1,4,1,3,0|0,0,0,4,4,0,0,0,0,0,|-1,-1,0,1,1,2,2,0,-1,-1|-1,-1,0,2,2,2,2,0,-1,-1|-1,-1,0,0,0,0,0,0,-1,-1',4),
    (4,'死而复生→BOSS关',8,8,'-1,0,0,0,0,0,0,-1|-1,0,2,1,2,2,0,-1|-1,0,2,1,4,2,0,-1|0,0,0,1,1,4,0,0|0,1,4,1,1,4,1,0|0,1,0,4,0,0,1,0|0,1,1,1,3,1,1,0|0,0,0,0,0,0,0,0',0);

</code></pre>
    </div>
    <h4>
     ②C++结构体设计
    </h4>
    <div>
     <pre><code class="language-cpp">typedef struct _userinfo {
	//这里将字符串初始为空
	_userinfo() :id(0), username(""), password(""), level_id(0) {};
	int id;	// 用户id
	string username;
	string password;	// 密码
	int level_id;
}userinfo;

typedef struct _levelinfo {
	_levelinfo() :id(0), name(""), map_row(0), map_column(0), map_data(""), next_level(0) {};
	int id;	// 关卡id
	string name;	// 关卡名字
	int map_row;	// 地图行数
	int map_column;	//地图列数
	string map_data;	// 二维地图数据
	int next_level;	//下一关卡id
}levelinfo;</code></pre>
    </div>
    <h3>
     2.用户登录 fetch_user_info( )
    </h3>
    <p>
     实现用户登录功能首先是获取用户输入的账号和密码，接着在数据库中进行查找，如果找到则读取游戏进度然后进入游戏界面，如果没找到则提示用户是否有输入错误。
    </p>
    <p>
     获取用户输入的账号和密码因为种（本）种（人）原（较）因（懒）没有设置页面，而是在控制台中输入，感兴趣的朋友可以根据自己风格设计页面。在控制台中读取用户输入内容还是非常容易实现，关键还是在于和数据库的操作。如果是第一次MySQL连接C++使用的化其实也不用惊慌，因为很多语法都是高重复性，学会一些其余的只需要：
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_19,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/174449b4c0209d38a9dffc42734cdca3.jpeg">
       ​
      </img>
     </p>
    </div>
    <p>
     就可以了。
    </p>
    <p>
     当我们在MySQL中对数据操作时，我们只需要启动MySQL，执行操作，关闭MySQL。而与C++连接后这些操作则会稍有改变，在每次单一操作结束后我们就要去关闭与数据库连接，例如我查找找完用户信息后我就要去关闭数据库连接，接着是读取关卡信息，那么我们就要继续打开数据库，读取关卡信息，然后关闭。
    </p>
    <p>
     因此我们可以先将与数据库连接功能实现，
     <strong>
      这里大家记得将用户名和密码改成自己的
     </strong>
    </p>
    <div>
     <pre><code class="language-cpp">#define DB_NAME	"box_man"    //数据库名
#define DB_HOST	"127.0.0.1"    //IP地址
#define DB_PORT 3306            //端口号
#define DB_USER "root"           //用户名
#define DB_USER_PASSWORD "******"    //密码



/******************************
 *功能：数据库链接
 * 输入：
 *		mysql - 数据库访问句柄
 *
 * 返回值：
 *		true - 连接成功
 *		false - 连接失败
 *****************************/
bool connect_db(MYSQL&amp; mysql) {
	//1.初始数据库句柄
	mysql_init(&amp;mysql);

	//2.设置字符编码（为句柄设置）
	//windows支持中文，在windows上一般是gbk字符集，gbk包含中文简体和繁体，简体是gbk2312
	mysql_options(&amp;mysql, MYSQL_SET_CHARSET_NAME, "gbk");

	//3.连接数据库
	//句柄，主机，用户名，密码，数据库，端口号，——，——
	if (mysql_real_connect(&amp;mysql, DB_HOST, DB_USER, DB_USER_PASSWORD, DB_NAME, DB_PORT, NULL, 0) == NULL) {
		printf("数据库连接失败，错误原因：%s\n", mysql_error(&amp;mysql));
		return false;
	}
	return true;
}
</code></pre>
    </div>
    <p>
     数据库连接功能实现好后接下来就是传入用户输入的信息，编写SQL查询语句进行查找。我将这套动作分成四步，这四步也基本可以满足平时设计程序所需
    </p>
    <p>
     1.连接数据库
    </p>
    <p>
     2.编写SQL语句
    </p>
    <p>
     3.进行查找或修改
    </p>
    <p>
     4.返回查询结果并关闭数据库
    </p>
    <div>
     <pre><code class="language-cpp">/******************************
 *功能：通过用户名和密码获取用户信息
 * 输入：
 *		user - 用户信息结构体
 *
 * 返回值：
 *		获取成功返回true，失败false
 *****************************/
bool fetch_user_info(userinfo&amp; user) {
	MYSQL mysql;	//定义一个句柄，对mysql的访问都是通过这个句柄（就是一个集合）
	MYSQL_RES* res;		// 查询的结果集
	MYSQL_ROW row;		// 如果结果集有多条，可以使用row获取
	char sql[256];
	bool ret = false;
	//1.连接数据库
	if (connect_db(mysql) == false) {
		return false;
	}
	//2.设置SQL查询语句
	//snprintf函数，设将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。
	snprintf(sql, 256, "select id,level_id from users where username='%s' and password = md5('%s');", user.username.c_str(), user.password.c_str());
	ret = mysql_query(&amp;mysql, sql);	//mysql查询，成功返回0
	if (ret) {
		printf("数据库查询出错，%s错误原因：%s\n", sql, mysql_error(&amp;mysql));
		// 关闭数据库
		mysql_close(&amp;mysql);
		return false;
	}
	
	//3.获取查到的结果
	res = mysql_store_result(&amp;mysql);
	//row获得结果集里的一行记录，再通过下标访问记录里的数据，如果结果集有多行时可以通过 while(row = mysql_fetch_row(res)){ }循环获得
	row = mysql_fetch_row(res);

	if (row == NULL) {	//没有查到记录
		//1.释放结果集
		mysql_free_result(res);
		//1.关闭数据库
		mysql_close(&amp;mysql);
		return false;
	}
	user.id = atoi(row[0]);	// 字符串转整数
	user.level_id = atoi(row[1]);
	//4.返回结果
	mysql_free_result(res);
	mysql_close(&amp;mysql);
	return true;
}
</code></pre>
    </div>
    <h3>
     3.获取关卡信息
    </h3>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/2558646d24c47e73cecaf43ca9df3e7d.png">
       ​
      </img>
     </p>
    </div>
    <p>
     地图数据使用二维数组表示，对于不同图形用不同编号表示
    </p>
    <p>
     在数据库录入中，我们使用不同数字代表不同图形，并且使用“|”符号作为每行的分隔符，我们只需根据读取到的用户信息中的游戏进度，来获得对应关卡数据即可。
    </p>
    <div>
     <pre><code class="language-cpp">/*********************************
 *功能：根据关卡id获取完整的关卡信息（如：地图，下一关等）
 * 输入：
 *		level - 保存关卡信息的结构体
 *		level_id - 获取关卡id
 * 返回值：
 *		-1 - 数据库连接或查询出错
 *		0  - 查找结果为空
 *		1 - 查找成功
 *********************************/
int fetch_level_info(levelinfo&amp; level, int level_id) {
	MYSQL mysql;	//定义一个句柄，对mysql的访问都是通过这个句柄（就是一个集合）
	MYSQL_RES* res;		// 查询的结果集
	MYSQL_ROW row;		// 如果结果集有多条，可以使用row获取
	char sql[256];
	bool ret = false;
	//1.连接数据库
	if (connect_db(mysql) == false) {
		return -1;
	}
	//2.编写SQL语句
	snprintf(sql, 256, "select name,map_row,  map_column,map_data,next_level_id from levels where id=%d;", level_id);
	ret = mysql_query(&amp;mysql, sql);	//mysql查询，成功返回0
	if (ret) {
		printf("数据库查询出错，%s错误原因：%s\n", sql, mysql_error(&amp;mysql));
		// 关闭数据库
		mysql_close(&amp;mysql);
		return -1;
	}

	//3.获取查到的结果
	res = mysql_store_result(&amp;mysql);
	//row获得结果集里的一行记录，再通过下标访问记录里的数据，如果结果集有多行时可以通过 while(row = mysql_fetch_row(res)){ }循环获得
	row = mysql_fetch_row(res);

	if (row == NULL) {	//没有查到记录
		//1.释放结果集
		mysql_free_result(res);
		//1.关闭数据库
		mysql_close(&amp;mysql);
		return 0;
	}
	level.id = level_id;
	level.name = row[0];
	level.map_row = atoi(row[1]);
	level.map_column = atoi(row[2]);
	level.map_data = row[3];
	level.next_level = atoi(row[4]);
	//string用printf输出，使用.c_str()可以返回一个const char* 的指针
	//printf("level id: %d  name: %s map row: %d  map column: %d map data: %s next level: %d\n", level.id, level.name.c_str(), level.map_row, level.map_column, level.map_data.c_str(), level.next_level);
	
	//4.返回结果
	mysql_free_result(res);
	mysql_close(&amp;mysql);
	return 1;
}</code></pre>
    </div>
    <h3>
     4.地图转换
    </h3>
    <p>
     获得的关卡数据是由结构体存储，我们需要将地图信息转为二维数组存储，也就是将string存储的地图信息转为int map[ ][ ] 存储
    </p>
    <div>
     <pre><code class="language-cpp">/******************************
 *功能：将获得的关卡数据转换到map地图数组中
 * 输入：
 *		level - 关卡数据
 *		map - 二维地图数组
 *
 * 返回值：
 *		false - 转换失败
 *		true - 转换成功
 *****************************/
bool transform_map_db2array(levelinfo&amp; level, int map[][COLUMN]) {
	if (level.map_row &gt; LINE || level.map_column &gt; COLUMN) {
		printf("地图过大，请重新设置\n");
		return false;
	}
	if (level.map_data.length() &lt; 1) {
		printf("地图数据有误，请重新设置！\n");
		return false;
	}
	long long start = 0, end = 0;
	int row = 0, column = 0;
	do {
		/******************************
		 *find返回size_t类型值，size_t在64位下是8字节长度，因此这里把start和end设置成long long类型（不设置会有“数据丢失”警告）。当然也可以简单粗暴的修改警告设置
		******************************/
		end = level.map_data.find('|', start);
		if (end == -1) {
			end = level.map_data.length();
		}
		//合法性检查，结束时end=level.map_data.length，start=end+1
		if (start &gt;= end)
			break;
		string line = level.map_data.substr(start, end - start);
		//printf("get-line：%s\n", line.c_str());
		// 对行数据进行解析：0,1,0,1,1,1,1,1,1,1,0,0
		char* next_token = NULL;
		//line转为const char*（C语言中的字符串），strtok_s会修改line里的值，按照某个特定字符，所以需要将line.c_str()转为char *
		// strtok_s第一个参数是要劈开的字符串（要求是一个char *类型的）；第二个参数是按某个字符劈开（会把“，”逗号变成‘\0’结束符，也就是说会修改原来字符串，所以要把原来的const char*转为char*）；第三个参数是这个接口
		// 需要的，用来做定位功能，
		//printf("%p\n", &amp;line[2]);
		char* item = strtok_s((char*)line.c_str(), ",", &amp;next_token);
		column = 0;
	    //printf("%p", next_token);
		//::system("pause");
		//如果某行数据个数多余这个地图列数，控制只读取level.map_column-1个
		while (item&amp;&amp;column&lt;level.map_column) {
			map[row][column] = atoi(item);
			column++;
			//再使用strtok_s接口第一个参数可以写NULL，应该是next_token参数上一次做定位功能时已经记录了要劈开字符串给的某个位置
			item = strtok_s(NULL, ",", &amp;next_token);
		}

		//合法性检查
		if (column &lt; level.map_column) {	// 某行的数据个数小于这个地图的列数
			printf("地图数据解析出错，终止！\n");
			return false;
		}
		row++;

		//列数多余的话直接舍弃
		if (row &gt;= level.map_row) {
			break;
		}
		start = end + 1;
	} while (1 == 1);
	//列数多余则直接报错
	if (row &lt; level.map_row) {
		printf("地图行数少于设定，终止！");
		return false;
	}
	return true;
}</code></pre>
    </div>
    <h3>
     5.跳转下一关
    </h3>
    <p>
     每当 用户通关后，便更新用户的游戏进度，实现下一关的跳转
    </p>
    <div>
     <pre><code class="language-cpp">/******************************
 *功能：更新用户游戏进度信息
 * 输入：
 *		user - 用户信息
 *		next_level_id - 游戏进度
 *
 * 返回值：
 *		获取成功返回true，失败false
 *****************************/
bool update_user_level(userinfo&amp; user, int next_level_id) {
	MYSQL mysql;	//定义一个句柄，对mysql的访问都是通过这个句柄（就是一个集合）
	char sql[256];
	bool ret = false;
	//1.连接数据库
	if (connect_db(mysql) == false) {
		return false;
	}
	//2.编写SQL语句
	snprintf(sql, 256, "update users set level_id=%d where id=%d", next_level_id, user.id);
	ret = mysql_query(&amp;mysql, sql);

	if (ret) {
		printf("数据库更新出错，%s错误原因：%s\n", sql, mysql_error(&amp;mysql));
		// 关闭数据库
		mysql_close(&amp;mysql);
		return false;
	}
	user.level_id = next_level_id;
	mysql_close(&amp;mysql);
	return true;
}</code></pre>
    </div>
    <h2>
     三、修改游戏代码适应与数据库连接
    </h2>
    <h3>
     1.搞定用户登录功能
    </h3>
    <p>
     数据库连接程序写好后，下面就是对推箱子游戏的程序升级，首先呢就是更改游戏框架，在初始化画布之前就是先让用户登录，我们规允许用户输入失败次数，若达到次数限制后则强制退出。
    </p>
    <div>
     <pre><code class="language-cpp">/*****************************
* 功能：用户登录
* 输入：
*		user - 用户信息
* 输出：
*		false - 登录失败
*		true - 登录成功
*****************************/
bool login(userinfo&amp; user) {
	int times = 0;
	bool ret = false;
	do {
		cout &lt;&lt; "请输入用户名：";
		cin &gt;&gt; user.username;
		cout &lt;&lt; "请输入密码：";
		cin &gt;&gt; user.password;
		ret = fetch_user_info(user);
		times++;
		if (times &gt;= MAX_RETRY_TIMES)
			break;
		if (ret == false) {
			cout &lt;&lt; "登录失败，请重新输入！" &lt;&lt; endl;
		}
	} while (!ret);
	return ret;
}</code></pre>
    </div>
    <h3>
     2.对用户的游戏进度做出判断
    </h3>
    <p>
     用户登录成功后就要对用户的游戏进度做出判断，如果返回-1，则代表数据库查询中失败了，此时就要强制退出程序；如果返回0，则代表用户已通关，此时就要是要重新开始还是要退出；如果返回1，则代表查询成功，进入游戏页面。
    </p>
    <p>
     对于返回-1或者0需要单独处理
    </p>
    <div>
     <pre><code class="language-cpp">/*****************************
* 功能：根据“由用户ID获取关卡数据”的返回结果进行判断
* 输入：
*		result - 返回结果（-1：获取失败  0：用户已通关  1：获取成功）
*		level - 关卡数据
*		user - 用户信息
* 输出：
*		无
*****************************/
void judge_by_result(int result, levelinfo&amp; level, userinfo&amp; user) {
	if (result == 1) {
		return;
	}
	else if (result == -1) {
		closegraph();
		cout &lt;&lt; "获取关卡数据失败，请重试！" &lt;&lt; endl;
		std::system("pause");
		exit(-1);
	}
	else if (result == 0) {
		show_over();
		do {
			//判断是否有按键按下
			if (_kbhit()) {
				//无缓冲读取
				char ch = _getch();
				if (ch == KEY_OUT) {
					closegraph();
					exit(0);
				}
				else if (ch == GAME_AGAIN) {
					if (!update_user_level(user,1)) {
						std::system("pause");
						closegraph();
						exit(0);
					}
					break;
				}
			}
			Sleep(50);
		} while (1);
		fetch_level_info(level, user.level_id);
	}
}</code></pre>
    </div>
    <p>
     读取 用户进度后，接下来便是调用地图信息转换功能，将地图信息转换到二维数组中，到这里对程序的升级工作也算是大功告成了。
    </p>
    <h2>
     <strong>
      四、程序打包发布
     </strong>
    </h2>
    <p>
     将推箱子游戏连接数据库之后也算是给游戏升了一个逼格，但当我们每次想玩的时候还要去打开编译器，甚至想发给自己的朋友都不行，难道还要让别人下载一个编译器还不成。因此，这里为大家带来一种程序打包方法，让你的项目也可以像软件安装一样直接安装运行
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="b9c6fe35a84c48e1a1ac607602b1551a.gif" src="https://i-blog.csdnimg.cn/blog_migrate/958b3ac13e1085f66e499cee36113a8e.gif"/>
      ​
     </p>
    </div>
    <h3>
     1.下载程序打包组件
    </h3>
    <p>
     <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioClient.MicrosoftVisualStudio2017InstallerProjects" rel="nofollow" title="VS 2022程序打包组件">
      VS 2022程序打包组件
     </a>
    </p>
    <p>
     <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioClient.MicrosoftVisualStudio2017InstallerProjects" rel="nofollow" title="VS 2017-2019程序打包组件">
      VS 2017-2019程序打包组件
     </a>
    </p>
    <p>
     下载好的组件直接打开安装
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/652ff218d61687b4702e94282e4923be.png"/>
     ​
    </p>
    <h3>
     2.设置VS编译器
    </h3>
    <p>
     1）设置为release模式，并把相关的设置也重新配置（sdl检查、字符集等等）
    </p>
    <p>
     2）把项目属性中的运行库，更改为“多线程(/MT)”
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/beb13dbf7352ad54662aa2a6ffc6357f.png"/>
      ​
     </p>
    </div>
    <h3>
     3.在同一解决方案下创建Setup项目
    </h3>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/e179acf277f0211c167568379e719572.png"/>
      ​
     </p>
    </div>
    <h3>
     <strong>
      4.添加项目文件到Setup项目中
     </strong>
    </h3>
    <p>
     <strong>
      这里演示我的推箱子项目
     </strong>
    </p>
    <p>
     <strong>
      这里将演示两种情况，一种是程序需要的素材文件与程序文件在同一目录下，另一种是素材文件在二级目录下
     </strong>
    </p>
    <p>
     <strong>
      第一种情况
     </strong>
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/bf76e53d9e8d28f4d02937685378a8a1.png"/>
     ​
    </p>
    <p>
     在应用程序文件夹（Application Folder)中添加项目路径
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/219329a9a6ce5d67404e1e9dc0645344.png"/>
     ​ 因为我的图片和运行程序在同一目录下，所以这里添加文件是要全部包括
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/e0e3ab80883256faa1fbbdfec31c0d8b.png"/>
      ​
     </p>
    </div>
    <hr/>
    <p>
     <strong>
      第二种情况
     </strong>
    </p>
    <p>
     如果运行程序和图片不在同一级目录时
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/2847c9fb5c47e08756d99dd261e69603.png"/>
     ​
    </p>
    <p>
     在应用程序文件夹（Application Folder)中先将全部程序文件添加进来
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/c4ad4447169914f42b5b6dfa97648bb3.png"/>
     ​
    </p>
    <p>
     在 应用程序文件夹（Application Folder) 创建一个子文件夹
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/ed5917e93df4441a33cb02bd782f839f.png"/>
      ​
     </p>
    </div>
    <p>
     将子文件夹重命名，并将全部图片添加进来
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/71f05f9e1cad2aae682c6268279dc968.png"/>
     ​
    </p>
    <p>
     添加好后在程序文件夹里便是所有的程序文件和一个images文件，在images文件中是全部的图片文件
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/2149816201711251019821d6b1186e44.png"/>
     ​
    </p>
    <p>
     <strong>
      如果在imagse还有子文件夹，则需要按上面步骤继续添加同级文件夹或则子文件夹即可
     </strong>
    </p>
    <h3>
     5.添加项目输出
    </h3>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/281a381c02321dcbe14faf2b2194d1f4.png"/>
     ​
    </p>
    <p>
     选择“主输出”后点击确定，在已导入的文件目录里就会多了一个主输出
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/3e950673e4523bfc305b8c0ba8d087a7.png"/>
     ​
    </p>
    <p>
     右键单击主输出，创建快捷方式，可以给快捷方式改一个想要的名字（最终程序安装时名字便会以这个名字为准）。
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/bab562f9f441e4ff59eaedacefce0da1.png"/>
      ​
     </p>
    </div>
    <h3>
     6.将快捷方式放入用户桌面中
    </h3>
    <p>
     截切快捷方式，到用户桌面（User's Desktop）中
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/8f0764e237477f66109e15d135179692.png"/>
     ​ 如下效果
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/42768dccfe3731c96d4f251a1a44e87d.png"/>
      ​
     </p>
    </div>
    <h3>
     7.为程序选择一个图标
    </h3>
    <p>
     找一张正方形图片，例如我的推箱子游戏的图标为
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_11,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/fb236c06864016f927bcf7a84b5afb19.png"/>
      ​
     </p>
    </div>
    <p>
     将选择的图片转为ico图标，这里给大家提供一个
     <a href="https://www.bitbug.net/" rel="nofollow" title="ico图标在线制作">
      ico图标在线制作
     </a>
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/f0621dc5b0a626c7d56a79bfc9bb2bb2.png"/>
      ​
     </p>
    </div>
    <h3>
     8.将图标与快捷方式绑定
    </h3>
    <p>
     将图标放入应用程序文件夹（Application Folder)中
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/f5e8bc7a8ca8e0cbd7c3862e79b785f0.png"/>
     ​
    </p>
    <p>
     右击快捷方式，选择属性窗口，在icon中浏览到刚才添加的图标，一直点击OK
    </p>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/b4131b30b266cee94388d8a741b3f6e9.png"/>
     ​
    </p>
    <p>
     选择安装项目，右击选择“重新生成”
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/682121d8dc206a992eaa2264270e9877.png"/>
      ​
     </p>
    </div>
    <p>
     <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/35e567765e22a8e1dba1b0a868b46b23.png"/>
     ​
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/62ddcb90280bac7a35a5d9617c183486.png"/>
      ​
     </p>
    </div>
    <p>
     安装程序并运行
    </p>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/dd4bdbc10bfea4f4c42f37aab62b8ce1.png"/>
      ​
     </p>
    </div>
    <div>
     <p style="text-align:center;">
      <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zy46YGT5bCP5piO,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://i-blog.csdnimg.cn/blog_migrate/ad5f4b31beec46382832c9b26be553fd.png"/>
      ​
     </p>
    </div>
    <p>
     运行结果简直就是三个字：棒棒棒！！！(๑•̀ㅂ•́)و✧
    </p>
    <div>
     <p>
      <img alt="575aa5c86ff04c5c8b2b0ef5ca04a4db.gif" src="https://i-blog.csdnimg.cn/blog_migrate/930843dff3fc15946e8319804326a4bd.gif"/>
      ​
     </p>
     <p>
     </p>
    </div>
    <h2>
     五、不足之处
    </h2>
    <ol>
     <li>
      游戏未设计注册功能，登录页面过于简单
     </li>
     <li>
      使用的是本地数据库，云端服务器会更好一点
     </li>
     <li>
      关卡量较少
     </li>
    </ol>
    <p style="text-align:center;">
    </p>
    <p>
     如果觉得有帮助，请点个赞支持一下吧
    </p>
    <p style="text-align:center;">
     <img alt="38d94eb7c8c14d3488e81977cfd8ae2b.png" src="https://i-blog.csdnimg.cn/blog_migrate/05ac6d49385459bd54fbca111196c790.jpeg"/>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35343136393939382f:61727469636c652f64657461696c732f313232393830383930" class_="artid" style="display:none">
 </p>
</div>


