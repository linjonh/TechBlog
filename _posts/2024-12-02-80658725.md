---
layout: post
title: "什么是反射什么Java反射"
date: 2024-12-02 18:55:40 +0800
description: "什么是反射（Reflection ）？主要是指程序可以访问、检测和修改它本身状态或行为的一种能力Ja"
keywords: "什么是反射java，应用"
categories: ['未分类']
tags: ['无标签']
artid: "80658725"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=80658725
  alt: "什么是反射什么Java反射"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     什么是反射？什么Java反射？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     什么是反射（Reflection ）？
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     主要是指程序可以访问、检测和修改它本身状态或行为的一种能力
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Java反射？
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Java反射机制主要提供了以下功能：
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     * 1.在运行时判断任意一个对象所属的类。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     * 2.在运行时构造任意一个类的对象。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     * 3.在运行时判断任意一个类所具有的成员变量和方法。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     * 4.在运行时调用任意一个对象的方法。
     <br/>
     <br/>
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Reflectio
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Reflection是Java被视为动态（或准动态）语言的一个关键性质。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     包括其modifiers（诸如public、static等）、 superclass（例如Object）、实现了的 interfaces （例如Serializable）、也包括其fields和methods的所有信息，并可于运行时改变fields内容或调用methods。
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     动态语言
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     动态语言的定义“程序运行时，允许改变程序结构或者变量类型，这种语言称为动态语言”。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制：Reflection。这个字的意思是：反射、映像、倒影，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     这种“看透”class的能力（the ability of the program to examine itself）被称为introspection（内省、内观、反省）。Reflection和introspection是常被并提的两个术语。
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Java Reflection API简介
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     在JDK中，主要由以下类来实现Java反射机制，这些类（除了第一个）都位于java.lang.reflect包中
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Class类：代表一个类，位于java.lang包下。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Field类：代表类的成员变量（成员变量也称为类的属性）。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Method类：代表类的方法。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Constructor类：代表类的构造方法。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Array类：提供了动态创建数组，以及访问数组的元素的静态方法。
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Class对象
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     要想使用反射，首先需要获得待操作的类所对应的Class对象。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Java中，无论生成某个类的多少个对象，这些对象都会对应于同一个Class对象。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     这个Class对象是由JVM生成的，通过它能够获悉整个类的结构。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     常用的获取Class对象的3种方式：
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     1.使用Class类的静态方法。例如:
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Class.forName(“java.lang.String”);
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     2.使用类的.class语法。如:
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     String.class;
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     3.使用对象的getClass()方法。如：
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     String str = “aa”;
     <br/>
     Class
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     例程1：获取方法
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     例程DumpMethods类演示了Reflection API的基本作用，它读取命令行参数指定的类名，然后打印这个类所具有的方法信息。
    </p>
    <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs cs has-numbering">import java.lang.reflect.Method;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> DumpMethods
{
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception //在方法后加上这句，异常就消失了
{
<span class="hljs-comment">//获得字符串所标识的类的 class 对象</span>
Class&lt;?&gt; classType = Class.forName(<span class="hljs-string">"java.lang.String"</span>);<span class="hljs-comment">//在此处传入字符串指定类名，所以参数获取可以是一个运行期的行为，可以用 args[0]</span>

        <span class="hljs-comment">//返回class对象所对应的类或接口中，所声明的所有方法的数组（包括私有方法）</span>
        Method[] methods = classType.getDeclaredMethods();

        <span class="hljs-comment">//遍历输出所有方法声明</span>
        <span class="hljs-keyword">for</span>(Method method : methods)
        {
            System.<span class="hljs-keyword">out</span>.println(method);
        }
    }

}</code></pre>
<ul class="pre-numbering">
<li style="color:rgb(153,153,153);">
1
</li>
<li style="color:rgb(153,153,153);">
2
</li>
<li style="color:rgb(153,153,153);">
3
</li>
<li style="color:rgb(153,153,153);">
4
</li>
<li style="color:rgb(153,153,153);">
5
</li>
<li style="color:rgb(153,153,153);">
6
</li>
<li style="color:rgb(153,153,153);">
7
</li>
<li style="color:rgb(153,153,153);">
8
</li>
<li style="color:rgb(153,153,153);">
9
</li>
<li style="color:rgb(153,153,153);">
10
</li>
<li style="color:rgb(153,153,153);">
11
</li>
<li style="color:rgb(153,153,153);">
12
</li>
<li style="color:rgb(153,153,153);">
13
</li>
<li style="color:rgb(153,153,153);">
14
</li>
<li style="color:rgb(153,153,153);">
15
</li>
<li style="color:rgb(153,153,153);">
16
</li>
<li style="color:rgb(153,153,153);">
17
</li>
<li style="color:rgb(153,153,153);">
18
</li>
<li style="color:rgb(153,153,153);">
19
</li>
<li style="color:rgb(153,153,153);">
20
</li>
</ul>
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
例程 2：通过反射调用方法
<br/>
通过反射调用方法。详情见代码及注释：
</p>
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs cs has-numbering">import java.lang.reflect.Method;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> InvokeTester
{
<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">int</span> param1, <span class="hljs-keyword">int</span> param2)
{
<span class="hljs-keyword">return</span> param1 + param2;

    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span>(String message)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello: "</span> + message;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception
    {

        <span class="hljs-comment">// 以前的常规执行手段</span>
        InvokeTester tester = <span class="hljs-keyword">new</span> InvokeTester();
        System.<span class="hljs-keyword">out</span>.println(tester.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
        System.<span class="hljs-keyword">out</span>.println(tester.echo(<span class="hljs-string">"Tom"</span>));
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"---------------------------"</span>);

        <span class="hljs-comment">// 通过反射的方式</span>

        <span class="hljs-comment">// 第一步，获取Class对象</span>
        <span class="hljs-comment">// 前面用的方法是：Class.forName()方法获取</span>
        <span class="hljs-comment">// 这里用第二种方法，类名.class</span>
        Class&lt;?&gt; classType = InvokeTester.class;

        <span class="hljs-comment">// 生成新的对象：用newInstance()方法</span>
        Object invokeTester = classType.newInstance();
        System.<span class="hljs-keyword">out</span>.println(invokeTester instanceof InvokeTester); <span class="hljs-comment">// 输出true</span>

        <span class="hljs-comment">// 通过反射调用方法</span>
        <span class="hljs-comment">// 首先需要获得与该方法对应的Method对象</span>
        Method addMethod = classType.getMethod(<span class="hljs-string">"add"</span>, <span class="hljs-keyword">new</span> Class[] { <span class="hljs-keyword">int</span>.class,
                <span class="hljs-keyword">int</span>.class });
        <span class="hljs-comment">// 第一个参数是方法名，第二个参数是这个方法所需要的参数的Class对象的数组</span>

        <span class="hljs-comment">// 调用目标方法</span>
        Object result = addMethod.invoke(invokeTester, <span class="hljs-keyword">new</span> Object[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span> });
        System.<span class="hljs-keyword">out</span>.println(result); <span class="hljs-comment">// 此时result是Integer类型</span>

        <span class="hljs-comment">//调用第二个方法</span>
        Method echoMethod = classType.getDeclaredMethod(<span class="hljs-string">"echo"</span>, <span class="hljs-keyword">new</span> Class[]{String.class});
        Object result2 = echoMethod.invoke(invokeTester, <span class="hljs-keyword">new</span> Object[]{<!-- --><span class="hljs-string">"Tom"</span>});
        System.<span class="hljs-keyword">out</span>.println(result2);

    }

}</code></pre>
<ul class="pre-numbering">
<li style="color:rgb(153,153,153);">
1
</li>
<li style="color:rgb(153,153,153);">
2
</li>
<li style="color:rgb(153,153,153);">
3
</li>
<li style="color:rgb(153,153,153);">
4
</li>
<li style="color:rgb(153,153,153);">
5
</li>
<li style="color:rgb(153,153,153);">
6
</li>
<li style="color:rgb(153,153,153);">
7
</li>
<li style="color:rgb(153,153,153);">
8
</li>
<li style="color:rgb(153,153,153);">
9
</li>
<li style="color:rgb(153,153,153);">
10
</li>
<li style="color:rgb(153,153,153);">
11
</li>
<li style="color:rgb(153,153,153);">
12
</li>
<li style="color:rgb(153,153,153);">
13
</li>
<li style="color:rgb(153,153,153);">
14
</li>
<li style="color:rgb(153,153,153);">
15
</li>
<li style="color:rgb(153,153,153);">
16
</li>
<li style="color:rgb(153,153,153);">
17
</li>
<li style="color:rgb(153,153,153);">
18
</li>
<li style="color:rgb(153,153,153);">
19
</li>
<li style="color:rgb(153,153,153);">
20
</li>
<li style="color:rgb(153,153,153);">
21
</li>
<li style="color:rgb(153,153,153);">
22
</li>
<li style="color:rgb(153,153,153);">
23
</li>
<li style="color:rgb(153,153,153);">
24
</li>
<li style="color:rgb(153,153,153);">
25
</li>
<li style="color:rgb(153,153,153);">
26
</li>
<li style="color:rgb(153,153,153);">
27
</li>
<li style="color:rgb(153,153,153);">
28
</li>
<li style="color:rgb(153,153,153);">
29
</li>
<li style="color:rgb(153,153,153);">
30
</li>
<li style="color:rgb(153,153,153);">
31
</li>
<li style="color:rgb(153,153,153);">
32
</li>
<li style="color:rgb(153,153,153);">
33
</li>
<li style="color:rgb(153,153,153);">
34
</li>
<li style="color:rgb(153,153,153);">
35
</li>
<li style="color:rgb(153,153,153);">
36
</li>
<li style="color:rgb(153,153,153);">
37
</li>
<li style="color:rgb(153,153,153);">
38
</li>
<li style="color:rgb(153,153,153);">
39
</li>
<li style="color:rgb(153,153,153);">
40
</li>
<li style="color:rgb(153,153,153);">
41
</li>
<li style="color:rgb(153,153,153);">
42
</li>
<li style="color:rgb(153,153,153);">
43
</li>
<li style="color:rgb(153,153,153);">
44
</li>
<li style="color:rgb(153,153,153);">
45
</li>
<li style="color:rgb(153,153,153);">
46
</li>
<li style="color:rgb(153,153,153);">
47
</li>
<li style="color:rgb(153,153,153);">
48
</li>
<li style="color:rgb(153,153,153);">
49
</li>
<li style="color:rgb(153,153,153);">
50
</li>
<li style="color:rgb(153,153,153);">
51
</li>
<li style="color:rgb(153,153,153);">
52
</li>
</ul>
<h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
生成对象
</h3>
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
若想通过类的不带参数的构造方法来生成对象，我们有两种方式：
</p>
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"> 1.先获得 Class 对象，然后通过该 Class 对象的 newInstance()方法直接生成即可：
</p>
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="has-numbering"> Class&lt;?&gt; classType = String.class;

Object obj = classType.newInstance();
</code></pre>
<ul class="pre-numbering">
<li style="color:rgb(153,153,153);">
1
</li>
<li style="color:rgb(153,153,153);">
2
</li>
<li style="color:rgb(153,153,153);">
3
</li>
<li style="color:rgb(153,153,153);">
4
</li>
</ul>
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"> 2.先获得 Class 对象，然后通过该对象获得对应的 Constructor 对象，再通过该 Constructor 对象的 newInstance()方法生成
</p>
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
（其中 Customer 是一个自定义的类，有一个无参数的构造方法，也有带参数的构造方法）：
</p>
<pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs delphi has-numbering"> <span class="hljs-keyword">Class</span>&lt;?&gt; classType = Customer.<span class="hljs-keyword">class</span>;

    <span class="hljs-comment">// 获得Constructor对象,此处获取第一个无参数的构造方法的</span>
    <span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">cons</span> = <span class="hljs-title">classType</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">(new <span class="hljs-keyword">Class</span>[] {})</span>;</span>

    <span class="hljs-comment">// 通过构造方法来生成一个对象</span>
    <span class="hljs-keyword">Object</span> obj = cons.newInstance(new <span class="hljs-keyword">Object</span>[] <span class="hljs-comment">{}</span>);</code></pre>
    <ul class="pre-numbering">
     <li style="color:rgb(153,153,153);">
      1
     </li>
     <li style="color:rgb(153,153,153);">
      2
     </li>
     <li style="color:rgb(153,153,153);">
      3
     </li>
     <li style="color:rgb(153,153,153);">
      4
     </li>
     <li style="color:rgb(153,153,153);">
      5
     </li>
     <li style="color:rgb(153,153,153);">
      6
     </li>
     <li style="color:rgb(153,153,153);">
      7
     </li>
    </ul>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     若想通过类的带参数的构造方法生成对象，只能使用下面这一种方式：
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     （Customer为一个自定义的类，有无参数的构造方法，也有一个带参数的构造方法，传入字符串和整型）
    </p>
    <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs delphi has-numbering">    <span class="hljs-keyword">Class</span>&lt;?&gt; classType = Customer.<span class="hljs-keyword">class</span>;

    <span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">cons2</span> = <span class="hljs-title">classType</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">(new <span class="hljs-keyword">Class</span>[] {<!-- --><span class="hljs-keyword">String</span>.<span class="hljs-keyword">class</span>, int.<span class="hljs-keyword">class</span>})</span>;</span>

    <span class="hljs-keyword">Object</span> obj2 = cons2.newInstance(new <span class="hljs-keyword">Object</span>[] <span class="hljs-comment">{"ZhangSan",20}</span>);</code></pre>
    <ul class="pre-numbering">
     <li style="color:rgb(153,153,153);">
      1
     </li>
     <li style="color:rgb(153,153,153);">
      2
     </li>
     <li style="color:rgb(153,153,153);">
      3
     </li>
     <li style="color:rgb(153,153,153);">
      4
     </li>
     <li style="color:rgb(153,153,153);">
      5
     </li>
    </ul>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     可以看出调用构造方法生成对象的方法和调用一般方法的类似，不同的是从Class对象获取Constructor对象时不需要指定名字，而获取Method对象时需要指定名字。
    </p>
    <h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     参考资料
    </h3>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     张龙老师Java SE教学视频。
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     文档链接：
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Class：
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html" rel="nofollow">
      http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html
     </a>
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Field:
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Field.html" rel="nofollow">
      http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Field.html
     </a>
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Method:
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Method.html" rel="nofollow">
      http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Method.html
     </a>
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Constructor:
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Constructor.html" rel="nofollow">
      http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Constructor.html
     </a>
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     Array:
    </p>
    <p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">
     <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html" rel="nofollow">
      http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html
     </a>
    </p>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f636f64696e675f31393934:2f61727469636c652f64657461696c732f3830363538373235" class_="artid" style="display:none">
 </p>
</div>
