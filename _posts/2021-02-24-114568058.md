---
layout: post
title: "java时间传到前端变成数字_关于JavaDate数据返回到前端变数字的问题并引申到前后端时间的传输..."
date: 2021-02-24 15:57:34 +0800
description: "不知道为什么，前端显示的所有数据项都没有错，就只有时间那一项很奇怪，是一串数字，而且这个数字在数据库"
keywords: "前端可传递时间格式为数字型的吗"
categories: ['未分类']
tags: ['Java']
artid: "114568058"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=114568058
  alt: "java时间传到前端变成数字_关于JavaDate数据返回到前端变数字的问题并引申到前后端时间的传输..."
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java时间传到前端变成数字_关于JavaDate数据返回到前端变数字的问题（并引申到前后端时间的传输）...
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div style="font-size:16px;">
     <p>
      不知道为什么，前端显示的所有数据项都没有错，就只有时间那一项很奇怪，是一串数字，而且这个数字在数据库怎么都找不到……
     </p>
     <p align="center">
      <img alt="53323d3287d76785a7237f595c55f48a.png" src="https://i-blog.csdnimg.cn/blog_migrate/75aab55c4e863214d25ffc54c6c74c87.png"/>
     </p>
     <p>
      然后我在后端从service到controller都debug了一遍，发现数据都没有错，拿的都是时间啊。
     </p>
     <p>
      后来百度知道，原来后台在返回json数据的时候，用自身的序列化机制会把时间变成一段很长的数字，就像上面的显示一样。
     </p>
     <p>
      然后这里就要用到一个东西：
     </p>
     <p>
      @JsonFormat，它的作用是，出参时，自动把Date型对象数据转化成正确的格式化后的字符串出去
     </p>
     <p align="center">
      <img alt="35d69cf9b74aa10b9eea87b3cd421031.png" src="https://i-blog.csdnimg.cn/blog_migrate/ba581e8f2dc1acbadd413bbbab13b41e.png"/>
     </p>
     <p>
      效果：
     </p>
     <p align="center">
      <img alt="7d50d5af29ebb7c0268f9c11beff41fe.png" src="https://i-blog.csdnimg.cn/blog_migrate/b3076c5ef649d974d08230602d6397a3.png"/>
     </p>
     <p>
      然后又通过度娘知道，还有个注解
     </p>
     <p>
      @DateTimeFormat
     </p>
     <p>
      这个是用于将前台传到后台字符串变量转换为Date类型。请求报文只需要传入yyyymmddhhmmss字符串进来，则自动转换为Date类型数据。(不过好像前端要传的是json)
     </p>
     <p>
      这里也有个小例子：
     </p>
     <p>
      前端只传了一个 格式正确的  时间字符串
     </p>
     <p align="center">
      <img alt="227c66296e4165054b4dbba9ce1dba1e.gif" src="https://i-blog.csdnimg.cn/blog_migrate/99328ebf1d7c3e50d2cda1ca088eb093.gif"/>
     </p>
     <p>
      layer.open({
      <!-- -->
     </p>
     <p>
      type : 2,
     </p>
     <p>
      title : '归档详情',
     </p>
     <p>
      //btn: ['选中', '取消'],
     </p>
     <p>
      shade : false,
     </p>
     <p>
      area : [ '900px', '600px' ],
     </p>
     <p>
      maxmin : true,
     </p>
     <p>
      content : gateUrl.UiUrl + '/productbaseEdition?eTime='
     </p>
     <p>
      + edition.table.bootstrapTable('getSelections')[0].eTime,// 这里content是一个URL，如果你不想让iframe出现滚动条，你还可以content:['http://sentsin.com', 'no']
     </p>
     <p>
      end : function() {
      <!-- -->
     </p>
     <p>
      }
     </p>
     <p>
      });
     </p>
     <p align="center">
      <img alt="bd39b1204244f01d59d537b6f7c5529b.gif" src="https://i-blog.csdnimg.cn/blog_migrate/b871136177b8aa860134f866ae28e32b.gif"/>
     </p>
     <p>
      这里就只是在请求url那里拼接了一个  eTime上去。
     </p>
     <p>
      然后后台一开始直接用Date接，毫无疑问，无法成功，然后就用了这个@DateTimeFormat
     </p>
     <p>
      看后端代码：
     </p>
     <p align="center">
      <img alt="f5da3b099695f12d2e51df0cd260b334.gif" src="https://i-blog.csdnimg.cn/blog_migrate/d6a58c4d07a00e5264fd339cb9215dd8.gif"/>
     </p>
     <p>
      @Controller
     </p>
     <p>
      @RequestMapping("")
     </p>
     <p>
      public class ProductbaseEditionController extends BaseController {
      <!-- -->
     </p>
     <p>
      @GetMapping("/productbaseEdition")
     </p>
     <p>
      public String productbaseEdition(@DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")Date eTime) {
      <!-- -->
     </p>
     <p>
      System.out.println("#################test time:"+eTime);
     </p>
     <p>
      return "productbaseEdition/list";
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p align="center">
      <img alt="45f22d354d09ffc7db88b9b6b6db1fb8.gif" src="https://i-blog.csdnimg.cn/blog_migrate/9737652522ccbd165be65a2615e95b54.gif"/>
     </p>
     <p>
      接收成功！(这里不是json数据，然后用注解@JsonFormat似乎不能成功接收)
     </p>
     <p>
      不过也有资料说，@JsonFormat不仅可以完成后台到前台参数传递的类型转换，还可以实现前台到后台类型转换。当content-type为application/json时，优先使用@JsonFormat的pattern进行类型转换。而不会使用@DateTimeFormat进行类型转换。
     </p>
     <p>
      然后我也根据这个做了几个实验，
     </p>
     <p>
      @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
     </p>
     <p>
      //@DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")
     </p>
     <p>
      private Date eTime;//归档时间，也是归档的版本号
     </p>
     <p>
      这是实体里面的一个属性，前端传用json传数据过来，然后Controller用这个实体来接收
     </p>
     <p align="center">
      <img alt="537a04e4d97029fe4864a68bb3eee8ac.gif" src="https://i-blog.csdnimg.cn/blog_migrate/2d61daf8e891c40a6cb71d29aedc067e.gif"/>
     </p>
     <p>
      var data = {};
     </p>
     <p>
      data.id = edition.currentItem.id;
     </p>
     <p>
      data.eTime = edition.currentItem.eTime;
     </p>
     <p>
      layer.confirm('确定删除这个归档版本吗？', null, function (index) {
      <!-- -->
     </p>
     <p>
      $.ajax({
      <!-- -->
     </p>
     <p>
      url: edition.baseUrl + "/editionDelete",
     </p>
     <p>
      type: "POST",
     </p>
     <p>
      data:JSON.stringify(data),
     </p>
     <p>
      headers : {
      <!-- -->
     </p>
     <p>
      'Content-Type' : 'application/json;charset=utf-8'
     </p>
     <p>
      },
     </p>
     <p>
      success: function (data) {
      <!-- -->
     </p>
     <p>
      console.log(data);
     </p>
     <p>
      if (data.code == '0') {
      <!-- -->
     </p>
     <p>
      layerTips.msg("删除成功！");
     </p>
     <p>
      edition.refresh();
     </p>
     <p>
      } else {
      <!-- -->
     </p>
     <p>
      layerTips.msg("删除失败！")
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      });
     </p>
     <p>
      layer.close(index);
     </p>
     <p>
      });
     </p>
     <p align="center">
      <img alt="deb58526e9012bf2fd09b6c532fe4ed3.gif" src="https://i-blog.csdnimg.cn/blog_migrate/e95c6d6c97d32f80dcc52fd72f09d73e.gif"/>
     </p>
     <p>
      结论是：
     </p>
     <p>
      1.前端如果传来的是json数据，时间格式是正确的，那么@JsonFormat是可以正确将其转换成Date类型的。
     </p>
     <p>
      2.前端如果传来的是json数据，时间格式是正确的，那么@DateTimeFormat是可以正确将其转换成Date类型的。
     </p>
     <p>
      3.但是，用json出参时用注解@DateTimeFormat似乎行不通，就是前面的问题，json返回Date对象时，java的序列化会把date变成一串数字，然后@dataTimeFormat似乎无法解决这个问题。
     </p>
     <p>
      结论：
     </p>
     <p>
      1.如果前后端传的数据都是json，那么后台接数据，传数据都可以用@JsonFormat。
     </p>
     <p>
      2.@DateTimeFormat适合后端  接收   前端传来的数据，不管是不是json都可以正确转换成Date型数据，只要前端传来的格式正确且后端@DateTimeFormat的pattern写正确了，但是这个注解无法将Date型数据用json传到后端去。
     </p>
    </div>
   </div>
  </div>
  <div id="recommendDown">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34323130373337342f:61727469636c652f64657461696c732f313134353638303538" class_="artid" style="display:none">
 </p>
</div>
