---
layout: post
title: "C-硬件信息-获取主板序列号"
date: 2025-01-23 00:15:00 +0800
description: "获取计算机网卡主板序列号的方法很多，这里采用的是命令行的形式获取，可以获取主板序列号，很简单，直接上"
keywords: "c++获取主板序列号"
categories: ['C']
tags: ['硬件', '序列号', '主板']
artid: "44958985"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=44958985
    alt: "C-硬件信息-获取主板序列号"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ 硬件信息 获取主板序列号
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
      获取计算机网卡主板序列号的方法很多，这里采用的是
      <strong>
       <span style="color:#ff0000">
        命令行
       </span>
      </strong>
      的形式获取，可以获取主板序列号，很简单，直接上代码。
     </span>
    </p>
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
      <br/>
     </span>
    </p>
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
      <strong>
       【1】头文件
      </strong>
     </span>
    </p>
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
     </span>
    </p>
    <pre><code class="language-cpp">#if !defined(AFX_DD71A3C0_A52F_4C38_B062_8E05785607DC__INCLUDED_)
#define AFX_DD71A3C0_A52F_4C38_B062_8E05785607DC__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;windows.h&gt;

using namespace std;

//--------------------------------------------------------------
//						主板序列号
//--------------------------------------------------------------
BOOL GetBaseBoardByCmd(char *lpszBaseBoard, int len=128);


#endif // !defined(AFX_DD71A3C0_A52F_4C38_B062_8E05785607DC__INCLUDED_)</code></pre>
    <p>
    </p>
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
      <br/>
     </span>
    </p>
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
      <strong>
       【2】CPP
      </strong>
     </span>
    </p>
    <p>
     <span style="font-family:Microsoft YaHei; font-size:14px">
     </span>
    </p>
    <pre><code class="language-cpp">#include "stdafx.h"
#include "BaseBoard.h"


//--------------------------------------------------------------
//						主板序列号 -- 获取不到时为 None
//--------------------------------------------------------------
BOOL GetBaseBoardByCmd(char *lpszBaseBoard, int len/*=128*/)
{	
	const long MAX_COMMAND_SIZE = 10000; // 命令行输出缓冲大小	
	WCHAR szFetCmd[]			= L"wmic BaseBoard get SerialNumber"; // 获取主板序列号命令行	
	const string strEnSearch = "SerialNumber"; // 主板序列号的前导信息
	
	BOOL   bret		  = FALSE;
	HANDLE hReadPipe  = NULL; //读取管道
	HANDLE hWritePipe = NULL; //写入管道	
	PROCESS_INFORMATION pi;   //进程信息	
	STARTUPINFO			si;	  //控制命令行窗口信息
	SECURITY_ATTRIBUTES sa;   //安全属性

	char			szBuffer[MAX_COMMAND_SIZE+1] = {0}; // 放置命令行结果的输出缓冲区
	string			strBuffer;
	unsigned long	count = 0;
	long			ipos  = 0;

	memset(&amp;pi, 0, sizeof(pi));
	memset(&amp;si, 0, sizeof(si));
	memset(&amp;sa, 0, sizeof(sa));

	pi.hProcess = NULL;
	pi.hThread  = NULL;
	si.cb		= sizeof(STARTUPINFO);
	sa.nLength	= sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle		= TRUE;

	//1.0 创建管道
	bret = CreatePipe(&amp;hReadPipe, &amp;hWritePipe, &amp;sa, 0);
	if(!bret)
	{
		goto END;
	}

	//2.0 设置命令行窗口的信息为指定的读写管道
	GetStartupInfo(&amp;si);
	si.hStdError	= hWritePipe;
	si.hStdOutput	= hWritePipe;
	si.wShowWindow	= SW_HIDE; //隐藏命令行窗口
	si.dwFlags		= STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;

	//3.0 创建获取命令行的进程
	bret = CreateProcess(NULL, szFetCmd, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi );
	if(!bret)
	{
		goto END;
	}	

	//4.0 读取返回的数据
	WaitForSingleObject (pi.hProcess, 500/*INFINITE*/);
	bret  =  ReadFile(hReadPipe,  szBuffer,  MAX_COMMAND_SIZE,  &amp;count,  0);
	if(!bret)
	{
		goto END;
	}

	//5.0 查找主板序列号
	bret = FALSE;
	strBuffer = szBuffer;
	ipos = strBuffer.find(strEnSearch);

	if (ipos &lt; 0) // 没有找到
	{		
	    goto END;
	}
	else
	{
		strBuffer = strBuffer.substr(ipos+strEnSearch.length());
	}	

	memset(szBuffer, 0x00, sizeof(szBuffer));
	strcpy_s(szBuffer, strBuffer.c_str());

    //去掉中间的空格 \r \n
    int j = 0;
    for (int i = 0; i &lt; strlen(szBuffer); i++)
    {
        if (szBuffer[i] != ' ' &amp;&amp; szBuffer[i] != '\n' &amp;&amp; szBuffer[i] != '\r')
        {
            lpszBaseBoard[j] = szBuffer[i];
            j++;
        }
    }

	bret = TRUE;

END:
	//关闭所有的句柄
	CloseHandle(hWritePipe);
	CloseHandle(hReadPipe);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	return(bret);
}
</code></pre>
    <br/>
    <br/>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f616f7368696c616e6732323439:2f61727469636c652f64657461696c732f3434393538393835" class_="artid" style="display:none">
 </p>
</div>


