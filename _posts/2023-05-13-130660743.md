---
layout: post
title: "linuxinit进程的详解"
date: 2023-05-13 18:35:12 +0800
description: "init进程是Linux系统启动的关键，它从内核态开始，挂载根文件系统，执行用户态的init程序，从"
keywords: "linux init进程"
categories: ["未分类"]
tags: ["详解", "Linux", "Init"]
artid: "130660743"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=130660743
  alt: "linuxinit进程的详解"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【linux】init进程的详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#_2" rel="nofollow">
        概述
       </a>
      </li>
      <li>
       <a href="#init_5" rel="nofollow">
        init进程完成从内核态向用户态的转变
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_8" rel="nofollow">
          （1）一个进程先后两种状态
         </a>
        </li>
        <li>
         <a href="#2init_12" rel="nofollow">
          （2）init进程在内核态下的工作内容
         </a>
        </li>
        <li>
         <a href="#3init_19" rel="nofollow">
          （3）init进程在用户态下的工作内容
         </a>
        </li>
        <li>
         <a href="#4init__27" rel="nofollow">
          （4）init进程如何从内核态跳跃到用户态 ？还能回来不？
         </a>
        </li>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <a href="#1init_36" rel="nofollow">
              1、init进程挂载了根文件系统
             </a>
            </li>
            <li>
             <a href="#2initinit_60" rel="nofollow">
              2、init进程执行init程序完成内核态到用户态的转变
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#3init_73" rel="nofollow">
            3、init进程构建了用户交互界面
           </a>
          </li>
          <li>
           <a href="#4init_83" rel="nofollow">
            4、init进程打开了控制台
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_92" rel="nofollow">
        参考
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="_2">
     </a>
     概述
    </h2>
    <p>
     注意：
     <code>
      init进程和init程序（linuxrc程序）是有区别的
     </code>
     。init进程一开始就有，它运行于内核态，属于一个内核线程。后来init进程挂载根文件系统，并运行应用程序init程序后，init进程才从内核态转变为用户态。因为转变过程中进程号没有变，还是进程1，所以有人会把init程序（linuxrc程序）当做进程1。但其实init进程除了后来的init程序，还包括内核态下挂载根文件系统等操作。
    </p>
    <h2>
     <a id="init_5">
     </a>
     init进程完成从内核态向用户态的转变
    </h2>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b9f5abfbb80eadaaaa0809d505fcb3a2.png">
      <br/>
      从上图可以看到Init 的先从内核空间运行，然后切换到用户空间运行
     </img>
    </p>
    <h3>
     <a id="1_8">
     </a>
     （1）一个进程先后两种状态
    </h3>
    <p>
     init进程刚开始运行的时候是内核态，它属于一个内核线程，然后运行一个用户态下面的程序后，把自己强行转成用户态（后面的进程需要工作在用户态下）。
     <br/>
     init进程完成了从内核态到用户态的过渡，因此后续的其他进程都可以工作在用户态。
    </p>
    <h3>
     <a id="2init_12">
     </a>
     （2）init进程在内核态下的工作内容
    </h3>
    <p>
     <code>
      主要是挂载根文件系统，并试图找到用户态下的那个init程序
     </code>
     。（这句话看出，init进程是早于init程序运行的。）
    </p>
    <p>
     init进程要把自己转成用户态就必须运行一个用户态的应用程序，要运行这个应用程序就必须得找到这个应用程序，要找到这个应用程序就必须得挂载根文件系统，因为所有的应用程序都在文件系统中。
    </p>
    <p>
     内核源代码中的所有函数都处于内核态，执行其中任何一个都不能脱离内核态。应用程序必须不属于内核源代码，这样才能保证应用程序处于用户态。这里执行的init程序和内核不在一起，由根文件系统另外提供。
    </p>
    <h3>
     <a id="3init_19">
     </a>
     （3）init进程在用户态下的工作内容
    </h3>
    <p>
     init进程大部分有意义的工作都是在用户态下进行的。
     <br/>
     init进程对操作系统的意义在于，
    </p>
    <blockquote>
     <p>
      其他所有的用户进程都直接或者间接派生自init进程
     </p>
    </blockquote>
    <p>
     。
    </p>
    <h3>
     <a id="4init__27">
     </a>
     （4）init进程如何从内核态跳跃到用户态 ？还能回来不？
    </h3>
    <p>
     <code>
      init进程处于内核态时，通过函数kernel_execve来执行一个用户空间编译链接的应用程序就跳跃到用户态了
     </code>
     。
    </p>
    <ul>
     <li>
      跳跃过程中进程号没有改变，一直是进程1。
     </li>
     <li>
      跳跃过程是单向的，一旦执行init程序转到用户态，整个操作系统就算真正运转起来了，以后只能在用户态下工作，用户态下想要进入内核态只能通过调用API。
     </li>
     <li>
      跳跃过程是
      <code>
       单向
      </code>
      的，一旦执行init程序转到用户态，整个操作系统就算真正运转起来了，以后只能在用户态下工作，用户态下想要进入内核态只能通过调用API。
     </li>
    </ul>
    <h5>
     <a id="1init_36">
     </a>
     1、init进程挂载了根文件系统
    </h5>
    <p>
     （1）prepare_namespace函数挂载根文件系统。
    </p>
    <p>
     （2）根文件系统在哪里？根文件系统的文件系统类型是什么？
    </p>
    <p>
     uboot通过传参来告诉内核这些信息。
     <br/>
     uboot传参中的root=/dev/mmcblk0p2 rw 这一句就是告诉内核根文件系统在哪里。
     <br/>
     uboot传参中的rootfstype=ext3这一句就是告诉内核rootfs的类型。
    </p>
    <p>
     （3）挂载结果
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fe2ee7359e91e3ae28df97b6e56a16b6.png">
      <br/>
      如果内核挂载根文件系统成功，则会打印出：VFS: Mounted root (ext3 filesystem) on device 179:2。（也可能其他数字）
      <br/>
      如果挂载根文件系统失败，则会打印：No filesystem could mount root, tried: yaffs2
      <br/>
      （4）如果内核启动时挂载rootfs失败，则后面无法执行。
     </img>
    </p>
    <p>
     内核中设置了启动失败休息5s自动重启的机制，因此这里会自动重启，所以有时候大家会看到反复重启的情况。
     <br/>
     （5）如果挂载rootfs失败，可能的原因有
    </p>
    <p>
     最常见的错误就是uboot的bootargs设置不对。
     <br/>
     rootfs烧录失败（fastboot烧录不容易出错）。
     <br/>
     rootfs本身制作失败的。
    </p>
    <h5>
     <a id="2initinit_60">
     </a>
     2、init进程执行init程序完成内核态到用户态的转变
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7c37823677a898943401820c9fd009d5.png"/>
    </p>
    <p>
     （1）一旦挂载rootfs成功，则进入rootfs中寻找应用程序的init程序（在init_post()函数中），找到后用run_init_process去执行。
    </p>
    <p>
     （2）如果确定init程序是谁？
    </p>
    <p>
     先从uboot传参cmdline中看有没有指定，如果有指定先执行cmdline中指定的程序。比如init=/linuxrc表示rootfs的根目录下的linuxrc程序就是init程序。
     <br/>
     如果uboot传参cmdline中没有init=xx或者cmdline中指定的这个xx执行失败，还有备用方案。第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。如果以上都不成功，则没有办法了。
     <br/>
     init=/linuxrc一般指向busybox。
    </p>
    <h4>
     <a id="3init_73">
     </a>
     3、init进程构建了用户交互界面
    </h4>
    <p>
     （1）init进程是其他用户进程的老祖宗。
    </p>
    <p>
     linux系统中一个进程的创建是通过其父进程创建出来的。根据这个理论只要有一个父进程就能生出一堆子孙进程了。
     <br/>
     （2）init启动了login进程（用户登录进程）、命令行进程（提供命令行环境）、shell进程（提供命令解释和执行）。
    </p>
    <p>
     （3）shell进程启动了其他用户进程。
    </p>
    <p>
     命令行和shell一旦工作，用户就可以在命令行下通过./xx的方式来执行其他应用程序，每一个应用程序的运行就是一个进程。
    </p>
    <h4>
     <a id="4init_83">
     </a>
     4、init进程打开了控制台
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2adcbe74f26cefd12e10fd47c1273bc6.png">
      <br/>
      （1）linux系统中每个进程都有自己的一个文件描述符表，表中存储的是本进程打开的文件。
     </img>
    </p>
    <p>
     （2）linux系统中一切皆是文件，因此设备也是以文件的方式来访问的。要访问一个设备，就要打开此设备对应的文件描述符。譬如/dev/fb0这个设备文件就代表LCD显示器设备，/dev/buzzer代表蜂鸣器设备，/dev/console代表控制台设备。
    </p>
    <p>
     （3）这里打开了/dev/console文件，并且复制了2次文件描述符，一共得到了3个文件描述符。这三个文件描述符分别是0、1、2，就是所谓的标准输入、标准输出、标准错误这3个文件描述符。
    </p>
    <p>
     （4）进程1打开了这3个文件描述符，因此进程1衍生出来的所有的进程默认都具有这3个文件描述符。
    </p>
    <h2>
     <a id="_92">
     </a>
     参考
    </h2>
    <p>
     <a href="https://www.ngui.cc/el/1214400.html?action=onClick" rel="nofollow">
      init进程的详解
     </a>
     <br/>
     <a href="https://blog.csdn.net/NUAA1703/article/details/115096547">
      Linux启动过程分析之init进程分析
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34353430363039322f:61727469636c652f64657461696c732f313330363630373433" class_="artid" style="display:none">
 </p>
</div>
