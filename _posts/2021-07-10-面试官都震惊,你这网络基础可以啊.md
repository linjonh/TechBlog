---
layout: post
title: 2021-07-10-面试官都震惊,你这网络基础可以啊
date: 2021-07-10 15:52:44 +0800
categories: [Java从入门到精通]
tags: [网络]
image:
  path: https://img-blog.csdnimg.cn/20210710152936441.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzA0NTI4,size_16,color_FFFFFF,t_70
  alt: 面试官都震惊,你这网络基础可以啊
artid: 118635841
---
<span class="artid" style="display:none" artid=68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353730343532382f:61727469636c652f64657461696c732f313138363335383431></span>
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     面试官都震惊，你这网络基础可以啊！
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      目录
     </h4>
     <ul>
      <li>
       <a href="#_2" rel="nofollow">
        网络
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_4" rel="nofollow">
          1.对网络的基础认识
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1_6" rel="nofollow">
            &lt;1&gt;.组网方式
           </a>
          </li>
          <li>
           <a href="#2OSI_35" rel="nofollow">
            &lt;2&gt;.OSI七层模型
           </a>
          </li>
          <li>
           <a href="#3TCPIP_44" rel="nofollow">
            &lt;3&gt;.TCP/IP五层（四层模型）
           </a>
          </li>
          <li>
           <a href="#4_61" rel="nofollow">
            &lt;4&gt;.对封装分用的理解
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#2_85" rel="nofollow">
          2.网络数据传输
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1_87" rel="nofollow">
            &lt;1&gt;局域网
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#1IPMAC_89" rel="nofollow">
              (1)认识IP和MAC
             </a>
            </li>
            <li>
             <a href="#2_112" rel="nofollow">
              (2)网络数据传输的特性
             </a>
            </li>
            <li>
             <a href="#3_153" rel="nofollow">
              (3)网络数据传输流程
             </a>
            </li>
            <li>
             <ul>
              <li>
               <a href="#1_163" rel="nofollow">
                1)网络互联的方式
               </a>
              </li>
              <li>
               <a href="#2_212" rel="nofollow">
                2).局域网交换机组网的方式
               </a>
              </li>
              <li>
               <a href="#3_234" rel="nofollow">
                3)局域网交换机+路由器组网的方式
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
          <li>
           <a href="#2_273" rel="nofollow">
            &lt;2&gt;广域网传输流程
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#3UDPTCP_341" rel="nofollow">
          3.UDP和TCP
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1UDP_343" rel="nofollow">
            &lt;1&gt;UDP协议
           </a>
          </li>
          <li>
           <a href="#2TCP_369" rel="nofollow">
            &lt;2&gt;TCP协议(可靠的传输协议)
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#1TCP_371" rel="nofollow">
              (1)TCP相关概念
             </a>
            </li>
            <li>
             <a href="#2_389" rel="nofollow">
              (2)确认应答机制
             </a>
            </li>
            <li>
             <a href="#3_401" rel="nofollow">
              (3)超时重传机制(安全机制)
             </a>
            </li>
            <li>
             <a href="#4_415" rel="nofollow">
              (4)连接管理机制（安全机制）
             </a>
            </li>
            <li>
             <a href="#5_464" rel="nofollow">
              (5)滑动窗口（效率）
             </a>
            </li>
            <li>
             <a href="#6_502" rel="nofollow">
              (6)流量控制机制（安全机制）
             </a>
            </li>
            <li>
             <a href="#7_517" rel="nofollow">
              (7)拥塞控制机制（安全机制）
             </a>
            </li>
            <li>
             <a href="#8_534" rel="nofollow">
              (8)延迟应答机制(效率)
             </a>
            </li>
            <li>
             <a href="#9_546" rel="nofollow">
              (9)捎带机制（效率）
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#3TCP_554" rel="nofollow">
            &lt;3&gt;TCP的总结
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#1TCP_556" rel="nofollow">
              (1)TCP特性
             </a>
            </li>
            <li>
             <a href="#2_563" rel="nofollow">
              (2)面向字节流
             </a>
            </li>
            <li>
             <a href="#3_574" rel="nofollow">
              (3)粘包问题
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#4UDP_VS_TCP_585" rel="nofollow">
            &lt;4&gt;UDP VS TCP
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#1UDPTCP_587" rel="nofollow">
              (1)UDP和TCP的特性
             </a>
            </li>
            <li>
             <a href="#2UDP_592" rel="nofollow">
              (2)如何使用UDP进行可靠传输
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#4MTUIP_600" rel="nofollow">
          4.MTU和IP协议
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1MTU_602" rel="nofollow">
            &lt;1&gt;MTU协议
           </a>
          </li>
          <li>
           <a href="#2IP_609" rel="nofollow">
            &lt;2&gt;IP协议
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#5HTTPHTTPS_624" rel="nofollow">
          5.HTTP和HTTPS
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1HTTP_626" rel="nofollow">
            &lt;1&gt;HTTP
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#1Http_628" rel="nofollow">
              (1)Http的前置知识
             </a>
            </li>
            <li>
             <ul>
              <li>
               <a href="#1_630" rel="nofollow">
                1)网络数据传输
               </a>
              </li>
              <li>
               <a href="#2URL_639" rel="nofollow">
                2)认识URL
               </a>
              </li>
             </ul>
            </li>
            <li>
             <a href="#2HTTP_644" rel="nofollow">
              (2)HTTP
             </a>
            </li>
            <li>
             <ul>
              <li>
               <a href="#1_646" rel="nofollow">
                1)域名
               </a>
              </li>
              <li>
               <a href="#2http_658" rel="nofollow">
                2)http协议格式
               </a>
              </li>
              <li>
               <a href="#3http_662" rel="nofollow">
                3)http请求方法
               </a>
              </li>
              <li>
               <a href="#4http_682" rel="nofollow">
                4)http状态码
               </a>
              </li>
              <li>
               <a href="#5http_695" rel="nofollow">
                5)http头信息
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
          <li>
           <a href="#2HTTPS_700" rel="nofollow">
            &lt;2&gt;HTTPS
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#6_761" rel="nofollow">
          6.正向代理和反向代理
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1_763" rel="nofollow">
            &lt;1&gt;.正向代理服务器
           </a>
          </li>
          <li>
           <a href="#2_779" rel="nofollow">
            &lt;2&gt;.反向代理服务器
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#7_796" rel="nofollow">
          7.网络面试题
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1TCPIP_798" rel="nofollow">
            &lt;1&gt;.说一说TCP/IP模型，以及都做了哪些事情
           </a>
          </li>
          <li>
           <a href="#2TCP_804" rel="nofollow">
            &lt;2&gt;.说一说TCP的三次握手四次挥手
           </a>
          </li>
          <li>
           <a href="#3IPV4IPV6_848" rel="nofollow">
            &lt;3&gt;IPV4和IPV6的区别
           </a>
          </li>
          <li>
           <a href="#4TCPUDP_856" rel="nofollow">
            &lt;4&gt;TCP和UDP的区别
           </a>
          </li>
          <li>
           <a href="#5UDP_865" rel="nofollow">
            &lt;5&gt;如何用UDP进行可靠传输
           </a>
          </li>
          <li>
           <a href="#6_871" rel="nofollow">
            &lt;6&gt;正向代理和反向代理的区别
           </a>
          </li>
          <li>
           <a href="#7HTTPHTTPS_877" rel="nofollow">
            &lt;7&gt;说说HTTP和HTTPS
           </a>
          </li>
          <li>
           <a href="#8httpsSSL_897" rel="nofollow">
            &lt;8&gt;https中SSL握手的过程
           </a>
          </li>
          <li>
           <a href="#9DNSDNSIP_909" rel="nofollow">
            &lt;9&gt;DNS解析（DNS找IP）
           </a>
          </li>
          <li>
           <a href="#10GETPOST_925" rel="nofollow">
            &lt;10&gt;GET和POST的区别
           </a>
          </li>
          <li>
           <a href="#11_937" rel="nofollow">
            &lt;11&gt;常见的状态码
           </a>
          </li>
          <li>
           <a href="#12URL_947" rel="nofollow">
            &lt;12&gt;输入一个URL到浏览器中，会发生什么
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <br/>
    打个小广告：最近和朋友搞个副业，做计算机编程相关服务（包括作业，课程设计，毕业设计，就业相关，考研相关，学习遇到的问题），各种语言技术栈都可以。如果有需要的加qq群877635095
    <p>
    </p>
    <h2>
     <a id="_2">
     </a>
     网络
    </h2>
    <h3>
     <a id="1_4">
     </a>
     1.对网络的基础认识
    </h3>
    <h4>
     <a id="1_6">
     </a>
     &lt;1&gt;.组网方式
    </h4>
    <p>
     1.网络互联:使用集线器将少量主机连在一起
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b57dd97c59f45ffde1dc47e185da3dae.png"/>
    </p>
    <ol start="2">
     <li>
      <p>
       局域网(LAN):使用交换机和路由器将主机连接，可以自由组合三种方式
      </p>
      <p>
       组网方式：
      </p>
      <p>
       &lt;1&gt;.交换机
      </p>
      <p>
       &lt;2&gt;.路由器
      </p>
      <p>
       &lt;3&gt;.交换机+路由器
      </p>
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4f0a77119d5d436288c3b3c97046b90b.png"/>
    </p>
    <p>
     3.广域网(WAN):广域网和局域网知识相对的概念
    </p>
    <p>
     例如：一个学校之间的网络就可以成为局域网，而一个国家，多个国家之间可以称为广域网，覆盖的区域不同
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a0bfd54f7fea65f762c6bcf9bdf42796.png"/>
    </p>
    <p>
     组网方式：公网上，网络结点组成，每一个结点可以是：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/cb8f187a5c13f54e61b7345400c16189.png"/>
    </p>
    <h4>
     <a id="2OSI_35">
     </a>
     &lt;2&gt;.OSI七层模型
    </h4>
    <p>
     1.对协议的简单理解：本质上是数据格式的定义。而知名的数据格式，大家普遍遵循的规定，就属于协议
    </p>
    <p>
     2.OSI七层模型：一种网络分层的设计方法论，比较复杂且不实用，落地几乎都是TCP/IP四层，五层模型
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/54465a475df5274f3f0d954388eceffc.png"/>
    </p>
    <h4>
     <a id="3TCPIP_44">
     </a>
     &lt;3&gt;.TCP/IP五层（四层模型）
    </h4>
    <p>
     五层模型：除去OSI的表示层和会话层
    </p>
    <p>
     四层模型：除去OSI的表示层，会话层和物理层
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0a0a1c6371dd5073e28b2ed87c84d5dc.png"/>
    </p>
    <p>
     <strong>
      注意：
     </strong>
    </p>
    <p>
     应用程序实现对应用层的封装分用
    </p>
    <p>
     对于一台主机, 它的操作系统内核实现了从传输层到物理层的内容;（四.层封装分用）对于一台路由器, 它实现了从网络层到物理层;（下三层封装分用）
     <br/>
     对于一台交换机, 它实现了从数据链路层到物理层;（下两层分装分用）
     <br/>
     对于集线器, 它只实现了物理层;
    </p>
    <h4>
     <a id="4_61">
     </a>
     &lt;4&gt;.对封装分用的理解
    </h4>
    <p>
     <strong>
      1.封装：发送数据时，从高到低的顺序，按照对应的网络分层协议对数据进行包装
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/223dab2a18fe582cca8da4e50ced49d1.png"/>
    </p>
    <p>
     例如：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ed3a3589aad86b024cc7606ff3bd23b5.png"/>
    </p>
    <p>
     <strong>
      2.分用：封装的逆过程：接收数据时，从低到高的顺序，按照对应的网络分层协议，解析数据
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/49bf07454a9ccbf320ff0c35f9632df1.png"/>
    </p>
    <p>
     例如：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/03ac75bb9535d28d679fc7c5507a66b3.png"/>
    </p>
    <h3>
     <a id="2_85">
     </a>
     2.网络数据传输
    </h3>
    <h4>
     <a id="1_87">
     </a>
     &lt;1&gt;局域网
    </h4>
    <h5>
     <a id="1IPMAC_89">
     </a>
     (1)认识IP和MAC
    </h5>
    <p>
     <strong>
      IP:
     </strong>
    </p>
    <p>
     IP的格式：xxx.xxx.xxx.xxx
     <br/>
     IP由四个部分组成，每个部分都是0-255.
     <br/>
     网络号：前三个部分组成（用来标识网段），前三个部分相同，标识在一个网段
     <br/>
     主机号：最后一个部分用来标识主机号
     <br/>
     IP分为A-E五大类，部分范围是局域网IP，部分是广域网IP，可以根据规范，知道某个IP是局域网IP还是公网IP
     <br/>
     注意： 局域网内（局域网IP）：网段唯一，同一个网段，主机号唯一
     <br/>
     公网(公网IP）：公网IP是唯一的
    </p>
    <p>
     <strong>
      MAC:
     </strong>
    </p>
    <p>
     和网卡硬件绑定的，全球唯一
     <br/>
     作用：网络数据传输定位网卡硬件的位置，一个主机可能有多个网卡（例如蓝牙连接，无线连接，有线连接的网卡），电脑硬件定位数据发送的目的位置只能使用MAC
    </p>
    <p>
     <strong>
      总结：
     </strong>
     <br/>
     IP地址描述的是路途总体的起点和终点。（给人用的，网络主机的逻辑地址）
     <br/>
     MAC地址描述的是路途上的每一个区间的起点和终点（给电脑硬件用的，网络主机的物理地址）
    </p>
    <h5>
     <a id="2_112">
     </a>
     (2)网络数据传输的特性
    </h5>
    <p>
     1.IP，MAC起的作用
     <br/>
     2.封装分用——发送数据从高到低封装，接收数据从低到高分用
     <br/>
     3.结合IP，MAC，理解网络数据传输，本质上是一跳一跳的传输数据
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/351b550ec720778caa8a380c4615082f.png"/>
    </p>
    <p>
     首先根据目的主机发送http请求，从源IP发送数据到目的IP
     <br/>
     从源MAC（1）发送数据到目的MAC（2），然后MAC（2）对数据进行封装和分用，再以MAC（2）为源MAC，目的MAC为MAC（3），以此，发送数据到最终目的MAC。
     <br/>
     注意： 接收数据报的主机：可能在一些情况下（广播或者转发），出现目的MAC不是我，我也能收到的情况（后面会提到）。
    </p>
    <p>
     <strong>
      五元组：
     </strong>
     <br/>
     源IP，目的IP，源端口，目的端口，协议号
    </p>
    <p>
     IP：标识主机，给人用
     <br/>
     源IP：发送数据的主机
     <br/>
     目的IP：接收数据的主机
    </p>
    <p>
     端口号：
     <br/>
     源端口：标识发送数据的进程
     <br/>
     目的端口，标识接收数据的进程
     <br/>
     协议号：进程需要封装，解析数据报的数据格式
    </p>
    <p>
     <strong>
      DNS协议：
     </strong>
     <br/>
     作用：域名转IP
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ae70532c9100c0793d7d1c0be7b60b10.png"/>
    </p>
    <p>
     主机/路由器：都存在DNS缓存
     <br/>
     域名查询的方式：上图树形结构从下往上查找（缓存，域名服务器）。
     <br/>
     先在主机/路由器的DNS缓存中找，如果找不到，依次向上
    </p>
    <p>
     特殊的IP，域名：本机IP为127.0.0.1，本机域名为localhost
    </p>
    <h5>
     <a id="3_153">
     </a>
     (3)网络数据传输流程
    </h5>
    <p>
     <strong>
      ARP/RARP协议：
     </strong>
     <br/>
     主机中有ARP缓存表
     <br/>
     ARP协议：IP转MAC
     <br/>
     RARP协议：MAC转IP
    </p>
    <p>
     注意：交换机和集线器自己是没有MAC地址的，都是通过转发(不会修改源MAC和目的MAC）
     <br/>
     交换机有MAC地址转换表，可以根据MAC找到对应的端口，而集线器没有这个功能
    </p>
    <h6>
     <a id="1_163">
     </a>
     1)网络互联的方式
    </h6>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/58f9798937da6540338adee2a5d89208.png"/>
    </p>
    <p>
     首先介绍集线器：如上图，网络数据传输时，直接转发到其他所有端口（工作在物理层）
    </p>
    <p>
     网络数据传输的过程：
    </p>
    <p>
     <strong>
      1.ARP缓存表找到了
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/36a8bda91451d28bf5738bd2f0870215.png"/>
    </p>
    <p>
     1.主机1发送数据到主机3（http：//主机3：80）
     <br/>
     2.主机1查找本机的ARP缓存表，根据ARP协议，找到目的MAC
     <br/>
     3.数据报由主机1，发送到集线器（数据报中的源MAC（主机1），目的MAC（主机3）真实的数据报
     <br/>
     4.集线器转发数据报到除主机1的其他所有相连的主机（主机2，主机3）
     <br/>
     5.主机2接收：数据报中，目的MAC不是我，丢弃
     <br/>
     主机3接收，数据报中，目的MAC是我，接收
     <br/>
     目的IP是我，交给对应端口处理，如果不是我，执行上述网络传输（一跳一跳的过程）
    </p>
    <p>
     <strong>
      2.ARP缓存表没找到
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9e1bed6242f622fd8e1956278c4eab46.png"/>
    </p>
    <p>
     1.主机1发送数据到主机3，http：//主机3：80
     <br/>
     2.主机1查找本机的ARP缓存表，发现找不到
     <br/>
     3.主机1发送广播数据报（非真实数据，只是要求对应主机返回MAC：我要IP为主机3的MAC，谁是主机3，快告诉我）
    </p>
    <p>
     <strong>
      注意：
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9660bb349f462bfb96169757439b7954.png"/>
    </p>
    <p>
     4.集线器转发到主机2，主机3
     <br/>
     5.主机2接收：要求的IP不是我，丢弃
     <br/>
     主机3接收：要求的IP是我，返回我的MAC
     <br/>
     6.主机1收到主机3的返回数据（IP，MAC）更新自己的ARP缓存表
     <br/>
     7.主机1发送真实的数据到主机3
    </p>
    <p>
     <strong>
      注意：使用集线器的缺陷
     </strong>
     <br/>
     网络冲突，这样构成的网络区域叫冲突域/碰撞域（例如，房间里有多个人说话，那么其中某一个人说话就听不清楚了）
    </p>
    <h6>
     <a id="2_212">
     </a>
     2).局域网交换机组网的方式
    </h6>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/77777927c63e474d39058c22c613fa3b.png"/>
    </p>
    <p>
     首先介绍交换机，交换机的作用：
     <br/>
     MAC地址转换表：保存连接的主机MAC和端口的映射，目的MAC是谁，直接转发到对应的端口（不像集线器，发送到所有端口），不会产生冲突域。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/db61f0123de5146b3e1ac41f744e6f49.png"/>
    </p>
    <p>
     1.主机1发送数据到主机3 ，http：//主机3：80
     <br/>
     2.主机1查找本机的ARP缓存表，如果找到，主机1发送数据到主机3。如果找不到，发送广播数据报，让IP为主机3的告诉我，你的MAC
     <br/>
     3.交换机转发到其他所有端口（广播）
     <br/>
     4.主机2丢弃，主机3返回自己的MAC
     <br/>
     5.交换机知道主机3的MAC，主机1知道主机3的MAC（更新ARP缓存表）
     <br/>
     注意：上述五个步骤，都是根据IP找MAC，和集线器的流程相似，下面的步骤时根据MAC找端口
     <br/>
     6.主机1发送真实数据给交换机
     <br/>
     7.交换机查找自己的MAC地址转换表，通过MAC找端口，发送数据到对应的端口
     <br/>
     8.主机3接收，目的MAC是我，目的IP也是我
     <br/>
     这种网络数据传输的方式就像：先问张三的手机号，再打电话给张三，对别人没有影响
    </p>
    <h6>
     <a id="3_234">
     </a>
     3)局域网交换机+路由器组网的方式
    </h6>
    <p>
     <strong>
      注意：单独由路由器组网的方式，和上述由交换机单独组网的方式相同
     </strong>
     <br/>
     首先介绍路由器，这里介绍两种：
     <br/>
     &lt;1&gt;LAN口连接局域网，为主机分配局域网IP，分配的局域网IP都是一个网段（路由器下连接多个主机的类型）
     <br/>
     路由器还有个网卡：绑定局域网的IP，和下面连接的主机进行信息交互用的
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a0ed5f098220b99cbb8a5b09400a0820.png"/>
    </p>
    <p>
     &lt;2&gt;LAN口是网卡。每个LAN口都可以连接类似交换机组网的方式
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/471d5a00814bcc8463cae50fe4e4320d.png"/>
    </p>
    <p>
     主机上的网络信息：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8b765895374063361088e2cc452471f6.png"/>
    </p>
    <p>
     第二种路由器组网方式：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fe2cf7d480e8db50910084915834201a.png"/>
    </p>
    <p>
     1.主机1发送数据到主机2:http://192.168.2.y:8080/xxx
     <br/>
     2.通过目的IP+子网掩码，计算出目的主机和本机是否在一个网段
     <br/>
     3.如果是，不需要使用路由器，和上述使用交换机组网方式一样
     <br/>
     4.如果不是，表示我主机1和交换机处理不了，要发送给网关转发（网关就类似于IP的管理者，能查询其他主机的IP）
     <br/>
     5.数据报发送给网关设备
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3d1c74d744e612ee597f563d24f50bc2.png"/>
    </p>
    <p>
     目的MC：通过路由器网关的IP在主机1的ARP缓存表中，获取网关的MAC
     <br/>
     6.路由器接收到数据报，分用：物理层到网络层，网络层分用，所有可以获取到目的IP
     <br/>
     7.路由器查找自己的ARP缓存表（IP找MAC）
     <br/>
     8.找不到，路由器发广播，主机2在哪，告诉我你的MAC
     <br/>
     9.有了MAC，直接发到主机3
    </p>
    <h4>
     <a id="2_273">
     </a>
     &lt;2&gt;广域网传输流程
    </h4>
    <p>
     1.NAT和NAPT
    </p>
    <p>
     NAT协议：局域网IP映射公网IP
     <br/>
     NAPT协议：局域网IP+局域网端口映射-----&gt;公网IP+公网端口
    </p>
    <p>
     2.传输流程
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6d651a48a0566c193b43a8b8f7fec023.png"/>
    </p>
    <p>
     <strong>
      结合上图，理解广域网传输流程
     </strong>
     <br/>
     首先：主机1发送http://www.baidu.com网络流程
    </p>
    <p>
     <strong>
      传输流程
     </strong>
     <br/>
     <strong>
      1
     </strong>
     首先主机1发送http请求，使用DNS协议：进行域名转IP
     <br/>
     域名转IP：首先在本机DNS缓存表找，如果找不到----&gt;向上查找------&gt;如果根域名服务器也找不到，表示公网上没有该域名的主机
    </p>
    <p>
     <strong>
      2.
     </strong>
     找到IP，数据报IP部分，PORT部分都有了：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/43151df59f1758ed23c5d6e2f3a4d768.png"/>
    </p>
    <ol start="3">
     <li>
      <p>
       根据目的IP计算是否和主机在同一个网段
       <br/>
       主机1的IP+子网掩码 计算出------&gt;主机1的网段
       <br/>
       目的IP+子网掩码 计算出-------&gt;目的主机的网段
       <br/>
       通过上述计算，判断目的IP和主机是否在同一个网段
      </p>
     </li>
     <li>
      <p>
       如果是同一个网段，和局域网传输一样
       <br/>
       如果不是同一个网段：发送数据到网关
       <br/>
       找网关的MAC：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/12a9ccf7ec90c7da60a448867488c65b.png"/>
      </p>
     </li>
     <li>
      <p>
       找到网关的MAC之后，将http数据重新封装，交由交换机转发
       <br/>
       交换机转发：在MAC地址转换表（MAC映射端口），通过目的MAC找端口（交换机的屁股口）
       <br/>
       注意：这个过程没有封装和分用
      </p>
     </li>
    </ol>
    <p>
     注意：前五个步骤，和路由器组成的局域网传输流程一样 参考：局域网传输
    </p>
    <ol start="6">
     <li>
      路由器接收，分用数据报
     </li>
    </ol>
    <p>
     注意：路由器会根据最短路径算法，计算出下一个发送数据的设备，会离目的IP更近一步
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/45d14e9def72ea64b51465a63a722030.png"/>
    </p>
    <p>
     <strong>
      7.
     </strong>
     上述步骤之后，数据报由局域网到广域网进行传输
     <br/>
     路途中的设备：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/53a0c7b56b25eeb132bdbfa8d1c87322.png"/>
    </p>
    <p>
     <strong>
      8.
     </strong>
     数据报到达百度服务器之后
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2b96c3f3e1ce65d08339d36c8ad998a6.png"/>
    </p>
    <p>
     **9.**数据由百度服务器返回，路途上经过的设备传输流程和步骤七相同（但是不一定是原路返回)
     <br/>
     **10.**路由器1接收响应数据（对接收的数据进行分用，修改，封装)
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/edbd4199e2e6da5b52763328a8b48f0c.png"/>
    </p>
    <p>
     <strong>
      11.
     </strong>
     之后的步骤，和局域网传输相同
     <br/>
     主机接收数据报，分用
    </p>
    <h3>
     <a id="3UDPTCP_341">
     </a>
     3.UDP和TCP
    </h3>
    <h4>
     <a id="1UDP_343">
     </a>
     &lt;1&gt;UDP协议
    </h4>
    <p>
     UDP协议端格式：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9405607d3f9c44774cc769418796af72.png"/>
    </p>
    <p>
     16位UDP校验和作用：类似于藏头诗，双方约定好的校验数据，进行数据校验
    </p>
    <p>
     UDP的特性：
     <br/>
     1.无连接：没有建立连接就发数据
     <br/>
     2.不可靠：没有类似TCP保证数据传输的安全机制，（连接管理机制，确认应答机制，超时机制
     <br/>
     ，）效率更高。
     <br/>
     3.面向数据报：只能一次接收（系统级别的操作：调用系统函数）
     <br/>
     4.没有发送缓冲区（发了消息就不管），有接收缓冲区
     <br/>
     5.数据最大为64k
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4429dca36440f01c6c1e699dedb36f95.png"/>
    </p>
    <p>
     发送缓冲区：主机1发送完数据，发出之后就不管了
     <br/>
     接收缓冲区：
     <br/>
     如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个字节; 而不能循环调用10次recvfrom, 每次接收10个字节;
     <br/>
     所以，接收数据的时候，发送100个字节，系统读取只调用一次，但是可以读取多次发来的其他100字节。
     <br/>
     但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果缓冲区满了, 再到达的UDP数据就会被丢弃;
    </p>
    <h4>
     <a id="2TCP_369">
     </a>
     &lt;2&gt;TCP协议(可靠的传输协议)
    </h4>
    <h5>
     <a id="1TCP_371">
     </a>
     (1)TCP相关概念
    </h5>
    <p>
     TCP协议：可靠的传输协议，安全，效率(有连接的可靠传输协议)
     <br/>
     设计TCP协议的理念：非100%安全，保证可承受范围内的安全，尽可能的提高网络传输数据的效率
     <br/>
     TCP协议端格式：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b9c4ffab93eb7135796075506cf8449a.png"/>
    </p>
    <p>
     六位标志位：
     <br/>
     URG: 紧急指针是否有效
     <br/>
     ACK: 确认号是否有效
     <br/>
     PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
     <br/>
     RST: 对方要求重新建立连接; 我们把携带RST标识的称为复位报文段
     <br/>
     SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段
     <br/>
     FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段
     <br/>
     重点掌握ACK,SYN,FIN
    </p>
    <h5>
     <a id="2_389">
     </a>
     (2)确认应答机制
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3d8ef5d60d548471c9b212372d2a8a23.png"/>
    </p>
    <p>
     主机A发送数据给主机B，每个数据都带了数据序号,主机B返回ACK应答
     <br/>
     每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据; 下一次你从哪里开始发
    </p>
    <p>
     作用：
     <br/>
     1.保证安全：保证‘我’发送的消息，对方必须确认并恢复
     <br/>
     2.保证多条数据确认信息的安全（告诉发送者，这次回应是对哪些数据，下次数据发送应该从什么时候开始）
    </p>
    <h5>
     <a id="3_401">
     </a>
     (3)超时重传机制(安全机制)
    </h5>
    <p>
     超时重传机制触发：主机A发送数据给主机B，如果主机A在一个特定的时间间隔内没有收到来自主机B的确认应答，就会进行数据重发。
    </p>
    <p>
     没有收到确认应答的情况：1.主机A的数据报在发送的过程中丢了。2.主机B的ACK应答丢了
    </p>
    <p>
     超时时间的确定：TCP会根据当时的网络状态，动态的计算数据发送的速度，得到单次数据报发送的最大生存时间（MSL），超时时间即为（2MSL）
    </p>
    <p>
     了解：如果一直接收不到ACK，超时时间会如何处理？
     <br/>
     Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍.
     <br/>
     如果重发一次之后, 仍然得不到应答, 等待 2500ms 后再进行重传.
     <br/>
     如果仍然得不到应答, 等待 4500ms 进行重传. 依次类推, 以指数形式递增（2的指数倍）.
     <br/>
     累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接.
    </p>
    <h5>
     <a id="4_415">
     </a>
     (4)连接管理机制（安全机制）
    </h5>
    <p>
     流程图：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7964399c6687623b71ae5bb2fbae5786.png"/>
    </p>
    <p>
     <strong>
      1.建立连接------&gt;TCP三次握手:
     </strong>
    </p>
    <p>
     TCP------&gt;三次握手的流程
    </p>
    <p>
     1.主机A发送syn到主机B，要求建立a到b的连接。此时主机A的状态为syn_sent
     <br/>
     2.主机B回复ack+syn（这里的ack和syn数据报本来是两个，但是仅标志位不同，所以可以合并,为什么不是四次的原因），要求建立b到a的连接，主机B的状态为syn_rcvd
     <br/>
     3.主机A回复第2步syn的ack。主机A的状态为established，建立A到B的连接
     <br/>
     主机B接收到第3步的数据报，建立B到A 的连接，主机B的状态置为established
    </p>
    <p>
     TCP------&gt;三次握手中的问题：
     <br/>
     1.syn为什么有两个？
     <br/>
     双方的连接状态会持续，且连接是有方向的
    </p>
    <p>
     2.第二步中，为什么是ack+syn？
     <br/>
     本质上是一个发ack应答，一个发syn请求，而且是方向一致的两个数据报，可以合并
    </p>
    <p>
     3.第三步中，ack确认应答哪个？
     <br/>
     应答第二步的syn
    </p>
    <p>
     <strong>
      2.断开连接------&gt;TCP四次挥手:
     </strong>
    </p>
    <p>
     TCP------&gt;四次挥手的流程
     <br/>
     1.主机A发送fin到主机B，请求关闭a到b的连接
     <br/>
     2.主机B回复ack，主机B的状态置为close_wait
     <br/>
     3.主机B发送fin到主机A，请求关闭b到a的连接
     <br/>
     4.值即A回复ack（第三步的fin），状态置为time_wait
     <br/>
     主机B接收到第四步的数据报，状态置为closed
     <br/>
     主机A经过2MSL（超时等待时间）之后，状态置为closed
    </p>
    <p>
     TCP------&gt;4次挥手中的问题
     <br/>
     1.第2步和第3步为什么不能和3次握手流程一样，进行合并
     <br/>
     原因：第2步是TCP协议在系统内核中实现时，自动响应的ack
     <br/>
     第3步时应用程序手动调用close来关闭连接的
     <br/>
     程序在关闭连接之前，可能需要执行释放资源等前置操作，所以不能合并（TCP协议实现时，没有这样进行设计）
    </p>
    <p>
     2.第3步中，主机A为什么不能直接设置为closed状态
     <br/>
     原因： 第4个数据报可能丢包，如果直接置为closed，丢包后无法重新发送数据。
     <br/>
     主机B达到超时时间之后，会重发第三个数据报，然后要求主机A再次回复ack
    </p>
    <p>
     3.服务器出现大量的close_wait状态，是为什么？
     <br/>
     服务端没有正确的关闭连接（程序没有调用close，或者没有正确使用）
    </p>
    <h5>
     <a id="5_464">
     </a>
     (5)滑动窗口（效率）
    </h5>
    <p>
     如果没有滑动窗口，网路数据传输就是串行的方式（发送一次之后，等待应答，这个时间内，主机A无事可做，主机B也一样），效率比较差。
    </p>
    <p>
     使用滑动窗口可以解决效率的问题：类似于多线程的方式，并发的，同时发送多个数据报。
     <br/>
     如下图：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/237afa9ff414165f8aa30f861ff0b9d1.png"/>
    </p>
    <p>
     1.窗口大小指的是无需等待确认应答而可以继续发送数据的最大值. 上图的窗口大小就是4000个字节(四个段).
     <br/>
     2.发送前四个段的时候, 不需要等待任何ACK, 直接发送;
     <br/>
     3.收到第一个ACK后, 滑动窗口向后移动, 继续发送第五个段的数据; 依次类推;
     <br/>
     4.操作系统内核为了维护这个滑动窗口, 需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答;只有确认应答过的数据, 才能从缓冲区删掉;
     <br/>
     5.窗口越大, 则网络的吞吐率就越高;
    </p>
    <p>
     丢包问题：
     <br/>
     1.数据报丢包
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/add6beae16ec123e74932ca03908ef8f.png"/>
    </p>
    <p>
     如上图：如果主机A发送的数据报丢包，主机B的ack应答，会根据主机A已经收到的连续数据报的最大值+1返回ack应答，当主机A收到三个同样的ack应答之后，会将丢掉的数据报进行重发（具有接收缓冲区，来记录已经接收的数据报的序号）
    </p>
    <p>
     2.ACK应答丢包：这种情况下, 部分ACK丢了并不要紧, 因为可以通过后续的ACK进行确认
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5acafd163f71b3fdc75fb539c79c5c8d.png"/>
    </p>
    <p>
     如果是滑动窗口的第一个包丢了，根据上述数据报丢包的情况，收到了第6个报的ACK应答，是从6001开始，说明第一个报主机B已经收到，所以ack丢包可以根据后序ack确定数据报主机B是否收到
    </p>
    <p>
     关于滑动窗口的几个问题：
     <br/>
     &lt;1&gt;.滑动窗口的大小：无需等待确认应答而可以继续发送数据的最大值
     <br/>
     &lt;2&gt;.如何确定窗口的大小：由拥塞窗口和流量控制窗口决定（滑动窗口大小=（拥塞窗口大小，流量控制大小））（后序会讲到）
     <br/>
     &lt;3&gt;.如何滑动：依赖于ACK的确认序号（ack确认序号前的数据报都已经接收到了），在该ACK确认序号前，当次并行收到了多少个数据报，就可以滑动多少
     <br/>
     &lt;4.&gt;为什么要有接收缓冲区和发送缓冲区：
     <br/>
     发送端的发送缓冲区：记录已经发送的数据——搜到对应的ACK应答，才可以清理该数据
     <br/>
     接收端的接收缓冲区：记录已经接收的数据——如果发送数据报丢包，才知道让对方重发
    </p>
    <h5>
     <a id="6_502">
     </a>
     (6)流量控制机制（安全机制）
    </h5>
    <p>
     接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送, 就
     <br/>
     会造成丢包, 继而引起丢包重传等等一系列连锁反应.
    </p>
    <p>
     接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 通过ACK端通知发送端;
     <br/>
     窗口大小字段越大, 说明网络的吞吐量越高;
     <br/>
     接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;
     <br/>
     发送端接受到这个窗口之后, 就会减慢自己的发送速度;
     <br/>
     如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据
     <br/>
     段, 使接收端把窗口大小告诉发送端.
    </p>
    <p>
     当接收端使用流量控制窗口时，如何保证接受端的数据安全？
     <br/>
     告诉发送端，影响发送端滑动窗口的大小
    </p>
    <h5>
     <a id="7_517">
     </a>
     (7)拥塞控制机制（安全机制）
    </h5>
    <p>
     少量的丢包, 我们仅仅是触发超时重传; 大量的丢包, 我们就认为网络拥塞;
    </p>
    <p>
     发送端在网络状态不明的情况下，贸然发送大量的数据，会造成网络拥堵，需要先发送少量数据探路，设置拥塞窗口的大小
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/845452d6a0e5c9a66e7144b0f1dbd3c7.png"/>
    </p>
    <p>
     如上图：如何确定拥塞窗口的大小
     <br/>
     此处引入一个概念程为拥塞窗口
     <br/>
     发送开始的时候, 定义拥塞窗口大小为1;
     <br/>
     每次收到一个ACK应答, 拥塞窗口加1;
     <br/>
     每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口;
     <br/>
     为了不增长的那么快, 因此不能使拥塞窗口单纯的加倍.
     <br/>
     此处引入一个叫做慢启动的阈值
     <br/>
     当拥塞窗口超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长
    </p>
    <h5>
     <a id="8_534">
     </a>
     (8)延迟应答机制(效率)
    </h5>
    <p>
     举个例子：
     <br/>
     假设接收端缓冲区为1M. 一次收到了500K的数据; 如果立刻应答, 返回的窗口就是500K;
     <br/>
     但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了;
     <br/>
     在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来;
     <br/>
     如果接收端稍微等一会再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M;
    </p>
    <p>
     延迟应答类型：
     <br/>
     数量限制: 每隔N个包就应答一次;
     <br/>
     时间限制: 超过最大延迟时间就应答一次;
    </p>
    <h5>
     <a id="9_546">
     </a>
     (9)捎带机制（效率）
    </h5>
    <p>
     在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “一发一收” 的，意味着当客户端给服务端发送请求时，服务端会给客户端响应数据，此时ACK就像可以搭请求数据的顺风车，一起发送。
    </p>
    <p>
     接收端响应的ACK，和主动发送的数据，可以合并返回。
    </p>
    <h4>
     <a id="3TCP_554">
     </a>
     &lt;3&gt;TCP的总结
    </h4>
    <h5>
     <a id="1TCP_556">
     </a>
     (1)TCP特性
    </h5>
    <p>
     TCP是有连接的可靠协议
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5a045409e484f1c2ffb7bc1b72fcb0d5.png"/>
    </p>
    <h5>
     <a id="2_563">
     </a>
     (2)面向字节流
    </h5>
    <p>
     TCP既有发送缓冲区，也有接收缓冲区，数据没有大小限制
    </p>
    <p>
     调用write时, 数据会先写入发送缓冲区中;
     <br/>
     如果发送的字节数太长, 会被拆分成多个TCP的数据包发出;
     <br/>
     如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出去;
     <br/>
     接收数据的时候, 数据也是从网卡驱动程序到达内核的接收缓冲区;
     <br/>
     然后应用程序可以调用read从接收缓冲区拿数据;
     <br/>
     另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做 全双工
    </p>
    <h5>
     <a id="3_574">
     </a>
     (3)粘包问题
    </h5>
    <p>
     在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段
     <br/>
     站在传输层角度看，报文是一个一个按照顺序排序好放在缓冲区，但是站在应用层角度看，都是一个个数字，不知道哪个数字是一段保文的开头，也不知道哪一个数字是结尾。这就是粘包
     <br/>
     所以得明确一个报文的开头和结尾
    </p>
    <p>
     但是对应UDP来说：
     <br/>
     对于UDP, 如果还没有上层交付数据, UDP的报文长度仍然在. 同时, UDP是一个一个把数据交付给应用层.就有很明确的数据边界.
     <br/>
     站在应用层的站在应用层的角度, 使用UDP的时候, 要么收到完整的UDP报文, 要么不收. 不会出现"半个"的情况
    </p>
    <h4>
     <a id="4UDP_VS_TCP_585">
     </a>
     &lt;4&gt;UDP VS TCP
    </h4>
    <h5>
     <a id="1UDPTCP_587">
     </a>
     (1)UDP和TCP的特性
    </h5>
    <p>
     TCP用于可靠传输的情况, 应用于文件传输, 重要状态更新等场景;
     <br/>
     UDP用于对高速传输和实时性要求较高的通信领域, 例如, 早期的QQ, 视频传输等. 另外UDP可以用于广播
    </p>
    <h5>
     <a id="2UDP_592">
     </a>
     (2)如何使用UDP进行可靠传输
    </h5>
    <p>
     引入序列号, 保证数据顺序;
     <br/>
     引入确认应答, 确保对端收到了数据;
     <br/>
     引入超时重传, 如果隔一段时间没有应答, 就重发数据;
    </p>
    <h3>
     <a id="4MTUIP_600">
     </a>
     4.MTU和IP协议
    </h3>
    <h4>
     <a id="1MTU_602">
     </a>
     &lt;1&gt;MTU协议
    </h4>
    <p>
     MTU相当于发快递时对包裹尺寸的限制. 这个限制是不同的数据链路对应的物理层, 产生的限制.
     <br/>
     以太网帧中的数据长度规定最小46字节,最大1500字节,ARP数据包的长度不够46字节,要在后面补填充位;最大值1500称为以太网的最大传输单元(MTU),不同的网络类型有不同的MTU;
     <br/>
     如果一个数据包从以太网路由到拨号链路上,数据包长度大于拨号链路的MTU了,则需要对数据包进行分片
     <br/>
     不同的数据链路层标准的MTU是不同的;
    </p>
    <h4>
     <a id="2IP_609">
     </a>
     &lt;2&gt;IP协议
    </h4>
    <p>
     1.协议头格式
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/26fd9283c8d71616918ec948980086fd.png"/>
    </p>
    <p>
     简单了解：
     <br/>
     4位版本号(version): 指定IP协议的版本, 对于IPv4来说, 就是4.
    </p>
    <p>
     8位服务类型(Type Of Service): 3位优先权字段(已经弃用), 4位TOS字段, 和1位保留字段(必须置为0). 4位 TOS分别表示: 最小延时, 最大吞吐量, 最高可靠性, 最小成本. 这四者相互冲突, 只能选择一个. 对于ssh/telnet这样的应用程序, 最小延时比较重要; 对于ftp这样的程序, 最大吞吐量比较重要（应用层协议需要不同安全/效率需求，此时可以设置服务类型来满足）
    </p>
    <p>
     下面三个字段都与数据链路层MTU相关：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/351d79615a2e85e93ca099a935159057.png"/>
    </p>
    <h3>
     <a id="5HTTPHTTPS_624">
     </a>
     5.HTTP和HTTPS
    </h3>
    <h4>
     <a id="1HTTP_626">
     </a>
     &lt;1&gt;HTTP
    </h4>
    <h5>
     <a id="1Http_628">
     </a>
     (1)Http的前置知识
    </h5>
    <h6>
     <a id="1_630">
     </a>
     1)网络数据传输
    </h6>
    <p>
     网络数据传输，都需要使用相同的协议，双方约定好的统一规范（封装和解析的数据格式规范）
     <br/>
     协议：数据格式的约定
     <br/>
     目标：对于http协议来说，就是学习里边的协议格式。结合理论实操，进行程序的调试，http协议格式本身，http数据中，包括自己的数据格式
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/87972ef6c5ae8ef73991ec6f7f7a888e.png"/>
    </p>
    <h6>
     <a id="2URL_639">
     </a>
     2)认识URL
    </h6>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a2303babc46c485f1a39aef41f1258c6.png"/>
    </p>
    <h5>
     <a id="2HTTP_644">
     </a>
     (2)HTTP
    </h5>
    <h6>
     <a id="1_646">
     </a>
     1)域名
    </h6>
    <p>
     域名：基于DNS解析为IP
     <br/>
     IP：网络中定位主机的地址（逻辑地址）
     <br/>
     PORT：端口号，定位某个主机中唯一的进程（应用程序）
     <br/>
     url：url是全路径（绝对路径）
     <br/>
     uri：uri包含了url这种全路径，还包含相对路径
     <br/>
     特殊注意事项：输入域名直接访问，其实是访问/这个资源的路径。
     <br/>
     浏览器中，不输入端口号，是因为http协议的默认端口是80
     <br/>
     url中的请求数据：请求路径？key1=value1&amp;key2=value2…
     <br/>
     问号前代表绝对路径，问号后代表请求的资源，数据
    </p>
    <h6>
     <a id="2http_658">
     </a>
     2)http协议格式
    </h6>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d30c626d96b43066be30cb295a811436.png"/>
    </p>
    <h6>
     <a id="3http_662">
     </a>
     3)http请求方法
    </h6>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/087b5957271ef26957847cbb0ce6ba87.png"/>
    </p>
    <p>
     <strong>
      重点了解get和post方法
     </strong>
    </p>
    <p>
     <strong>
      get和post方法的区别：
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/643888672f7ed3693f098667b4e560d1.png"/>
    </p>
    <blockquote>
     <p>
      1.get的请求数据只能放在url中，post的数据，可以放在url和请求体
     </p>
     <p>
      2.url长度有限制，所有get方法请求数据不能太多，冰球url只能传输ascli字符
     </p>
     <p>
      3.安全性将，post可以存放请求数据在请求体，相对更加安全
     </p>
     <p>
      其他区别：了解即可
     </p>
    </blockquote>
    <h6>
     <a id="4http_682">
     </a>
     4)http状态码
    </h6>
    <p>
     服务端返回（服务端设置），站在服务端的角色上，状态码都是对应的含义，站在客户端的角色上就不一定
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a664e6ae85373a31095591abceb73007.png"/>
    </p>
    <p>
     注：x表示0到9的数字
     <br/>
     <strong>
      重点掌握：
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2a135ac4a74447a9b3b7b6583c703116.png"/>
    </p>
    <h6>
     <a id="5http_695">
     </a>
     5)http头信息
    </h6>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/59007c3f61c5b228132a58dbc5a9807d.png"/>
    </p>
    <h4>
     <a id="2HTTPS_700">
     </a>
     &lt;2&gt;HTTPS
    </h4>
    <p>
     HTTP是明文传输的，不安全
     <br/>
     HTTPS是基于HTTP+SSL/TSL来实现的，发送的数据需要加密，接收到的数据需要解密，比HTTP安全，但是传输效率比HTTP低
    </p>
    <p>
     &lt;1&gt;.前置知识：为什么需要HTTPS
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/df93ea8ee5a0710fa35083b72f7d93cd.png"/>
    </p>
    <p>
     如上图：HTTP是不安全的，在传输的过程中，当客户端发送数据时，可能被钓鱼网站“欺骗”，将钓鱼网站当作服务端，或者直接被钓鱼网站窃取到数据，然后更改，造成不安全的影响
    </p>
    <p>
     此时需要解决：
     <br/>
     a：如何保证服务器是真实的，不是钓鱼网站？
     <br/>
     b：解决网络数据传输，使用明文，所有路途中的设备，如果获取到，存在信息泄露
    </p>
    <p>
     所以，就要使用到证书来解决安全问题
     <br/>
     a：权威的证书机构颁发的证书（安装浏览器时，初始化就内置权威证书）（解决上述a问题）
     <br/>
     b：https服务器证书（解决上述b问题）
    </p>
    <p>
     私钥，公钥，密钥：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/94ee9b50ca975ff6bcd1ddfeb64742d5.png"/>
    </p>
    <p>
     密钥：客户端，服务端用来加解密
     <br/>
     对称加密：使用同一个钥匙，来加解密
     <br/>
     公钥的生成（SSL握手阶段）： 见SLL握手
    </p>
    <p>
     https中涉及的细节：
     <br/>
     1.使用公钥和私钥来生成密钥（这里是非对称加密生成密钥）
     <br/>
     2.密钥加解密真正的数据（这里进行的对称加密，效率比非对称加密高）
    </p>
    <p>
     如何获取并验证服务器证书：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e22f5699dd455cefdb9466817d09dcd9.png"/>
    </p>
    <p>
     具体流程：
     <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" rel="nofollow">
      流程
     </a>
     <br/>
     1.用密钥进行加解密：
     <br/>
     &lt;1&gt;.客户端向服务端索要并验证公钥
     <br/>
     &lt;2&gt;.双放协商生成"对话密钥"
     <br/>
     &lt;3&gt;.双方采用“对话密钥”进行加解密通信
    </p>
    <p>
     2.HTTPS握手阶段（根据公钥私钥生成对话密钥）（以上1，2步需要保证对话密钥不被钓鱼）
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/28bdeca6ff32114ac717ccd14aabe5a5.png"/>
    </p>
    <p>
     &lt;1&gt;.首先客户端给出协议版本号，一个客户端生成的随机数，以及支持的加密方式
    </p>
    <p>
     &lt;2&gt;.服务端确认双方使用的加密方式，给出数字证书，以及一个服务器生成的随机数
    </p>
    <p>
     &lt;3&gt;.客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，发个服务端
    </p>
    <p>
     &lt;4&gt;.服务端使用自己的私钥，获取客户端发来的随机数
    </p>
    <p>
     &lt;5&gt;.客户端和服务端根据约定的加密方式，使用前面的三个随机数，生成密钥
    </p>
    <p>
     3.发送数据的阶段：
     <br/>
     客户端使用对话密钥加解密真正的数据
     <br/>
     服务端使用对话密钥加解密真正的数据
     <br/>
     注意：此部分被钓鱼也没有关系（对话密钥无法解密）
    </p>
    <h3>
     <a id="6_761">
     </a>
     6.正向代理和反向代理
    </h3>
    <h4>
     <a id="1_763">
     </a>
     &lt;1&gt;.正向代理服务器
    </h4>
    <p>
     &lt;1&gt;概念
    </p>
    <p>
     正向代理服务器：抓包工具
     <br/>
     正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。
    </p>
    <p>
     &lt;2&gt;原理图
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3088a03f74947e5b89d08a6167fc6bec.png"/>
    </p>
    <p>
     &lt;3&gt;使用场景和特点
    </p>
    <p>
     1.特点：要访问的服务器只知道代理服务器来访问它，并不知道真实的客户端是谁
     <br/>
     2.使用场景：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。
    </p>
    <h4>
     <a id="2_779">
     </a>
     &lt;2&gt;.反向代理服务器
    </h4>
    <p>
     &lt;1&gt;概念
    </p>
    <p>
     反向代理服务器：nginx等
     <br/>
     反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了
    </p>
    <p>
     &lt;2&gt;原理图
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d191841ddb1843d3c3ed19f1d3a0490b.png"/>
    </p>
    <p>
     &lt;3&gt;使用场景和特点
    </p>
    <p>
     1.特点:特点:反向代理服务器隐藏了真实服务器的信息，例如淘宝，京东，天猫等
     <br/>
     2.使用场景:
     <br/>
     反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。
    </p>
    <h3>
     <a id="7_796">
     </a>
     7.网络面试题
    </h3>
    <h4>
     <a id="1TCPIP_798">
     </a>
     &lt;1&gt;.说一说TCP/IP模型，以及都做了哪些事情
    </h4>
    <p>
     TCP/IP模型分为五层，分别是应用层，传输层，网络层，数据链路层，物理层
    </p>
    <p>
     TCP/IP协议群主要是报文的拆分，增加协议头，数据的传输，路由和寻址以及数据的重组
    </p>
    <h4>
     <a id="2TCP_804">
     </a>
     &lt;2&gt;.说一说TCP的三次握手四次挥手
    </h4>
    <p>
     <strong>
      1.建立连接------&gt;TCP三次握手:
     </strong>
    </p>
    <p>
     TCP------&gt;三次握手的流程
    </p>
    <p>
     1.主机A发送syn到主机B，要求建立a到b的连接。此时主机A的状态为syn_sent
     <br/>
     2.主机B回复ack+syn（这里的ack和syn数据报本来是两个，但是仅标志位不同，所以可以合并,为什么不是四次的原因），要求建立b到a的连接，主机B的状态为syn_rcvd
     <br/>
     3.主机A回复第2步syn的ack。主机A的状态为established，建立A到B的连接
     <br/>
     主机B接收到第3步的数据报，建立B到A 的连接，主机B的状态置为established
    </p>
    <p>
     TCP------&gt;三次握手中的问题：
     <br/>
     1.syn为什么有两个？
     <br/>
     双方的连接状态会持续，且连接是有方向的
    </p>
    <p>
     2.第二步中，为什么是ack+syn？
     <br/>
     本质上是一个发ack应答，一个发syn请求，而且是方向一致的两个数据报，可以合并
    </p>
    <p>
     3.第三步中，ack确认应答哪个？
     <br/>
     应答第二步的syn
    </p>
    <p>
     <strong>
      2.断开连接------&gt;TCP四次挥手:
     </strong>
    </p>
    <p>
     TCP------&gt;四次挥手的流程
     <br/>
     1.主机A发送fin到主机B，请求关闭a到b的连接
     <br/>
     2.主机B回复ack，主机B的状态置为close_wait
     <br/>
     3.主机B发送fin到主机A，请求关闭b到a的连接
     <br/>
     4.值即A回复ack（第三步的fin），状态置为time_wait
     <br/>
     主机B接收到第四步的数据报，状态置为closed
     <br/>
     主机A经过2MSL（超时等待时间）之后，状态置为closed
    </p>
    <p>
     TCP------&gt;4次挥手中的问题
     <br/>
     1.第2步和第3步为什么不能和3次握手流程一样，进行合并
     <br/>
     原因：第2步是TCP协议在系统内核中实现时，自动响应的ack
     <br/>
     第3步时应用程序手动调用close来关闭连接的
     <br/>
     程序在关闭连接之前，可能需要执行释放资源等前置操作，所以不能合并（TCP协议实现时，没有这样进行设计）
    </p>
    <p>
     2.第3步中，主机A为什么不能直接设置为closed状态
     <br/>
     原因： 第4个数据报可能丢包，如果直接置为closed，丢包后无法重新发送数据。
     <br/>
     主机B达到超时时间之后，会重发第三个数据报，然后要求主机A再次回复ack
    </p>
    <p>
     3.服务器出现大量的close_wait状态，是为什么？
     <br/>
     服务端没有正确的关闭连接（程序没有调用close，或者没有正确使用）
    </p>
    <h4>
     <a id="3IPV4IPV6_848">
     </a>
     &lt;3&gt;IPV4和IPV6的区别
    </h4>
    <p>
     1.地址不同（IPV4 32位，IPV6 128位），所有地址的空间，数目不同
    </p>
    <p>
     2.地址分配不同（IPV4资源不够，分配的话需要竞争，而IPV6可以给每个人都分配很多的地址）
    </p>
    <p>
     3.寻址的方式不同：IPV4 通过子网掩码计算网络地址，而IPV6有固定的计算方式划分网络
    </p>
    <h4>
     <a id="4TCPUDP_856">
     </a>
     &lt;4&gt;TCP和UDP的区别
    </h4>
    <p>
     1.TCP是有连接的可靠传输协议，而UDP是无连接的
     <br/>
     2.UDP传时数据是有大小限制的，而TCP没有
     <br/>
     3.UDP是面向数据报的，而TCP是面向数据流的。
     <br/>
     4.TCP保证数据正确性，顺序性，而UDP不能保证.
    </p>
    <p>
     5.UDP的传输速率高于TCP
    </p>
    <h4>
     <a id="5UDP_865">
     </a>
     &lt;5&gt;如何用UDP进行可靠传输
    </h4>
    <p>
     引入序列号, 保证数据顺序;
     <br/>
     引入确认应答, 确保对端收到了数据;
     <br/>
     引入超时重传, 如果隔一段时间没有应答, 就重发数据;
    </p>
    <h4>
     <a id="6_871">
     </a>
     &lt;6&gt;正向代理和反向代理的区别
    </h4>
    <p>
     正向代理：要访问的服务器只知道代理服务器来访问它，并不知道真实的客户端是谁
    </p>
    <p>
     反向代理：反向代理正好相反。对于客户端来说，反向代理就好像目标服务器，客户端向反向代理发送请求，接着反向代理判断请求走向何处，隐藏了真实的服务器。
    </p>
    <h4>
     <a id="7HTTPHTTPS_877">
     </a>
     &lt;7&gt;说说HTTP和HTTPS
    </h4>
    <p>
     HTTP是超文本传输协议，是目前应用最广泛的网络通信协议，也是客户端和服务端交互的一系列行为的标准
    </p>
    <p>
     http header包含三大部分，有General。Response Headers（响应头）。 Request Headers（请求头）。
    </p>
    <p>
     http是无连接，无状态的（每次连接只处理一个请求，发送完数据后，不会记录）
    </p>
    <p>
     而https简单讲是HTTP的安全版，即HTTP下加入SSL层，主要是来确认网站的真实性和数据传输的安全。
    </p>
    <p>
     区别：
    </p>
    <p>
     1.http的数据是明文传输，而https是加密传输，需要用到ca证书
    </p>
    <p>
     2.http使用80端口，而https是443端口
    </p>
    <p>
     3.http的速度比https要快
    </p>
    <h4>
     <a id="8httpsSSL_897">
     </a>
     &lt;8&gt;https中SSL握手的过程
    </h4>
    <p>
     &lt;1&gt;.首先客户端给出协议版本号，一个客户端生成的随机数，以及支持的加密方式
    </p>
    <p>
     &lt;2&gt;.服务端确认双方使用的加密方式，给出数字证书，以及一个服务器生成的随机数
    </p>
    <p>
     &lt;3&gt;.客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，发个服务端
    </p>
    <p>
     &lt;4&gt;.服务端使用自己的私钥，获取客户端发来的随机数
    </p>
    <p>
     &lt;5&gt;.客户端和服务端根据约定的加密方式，使用前面的三个随机数，生成密钥
    </p>
    <h4>
     <a id="9DNSDNSIP_909">
     </a>
     &lt;9&gt;DNS解析（DNS找IP）
    </h4>
    <p>
     1.当浏览器中输入www.bai.com域名时，操作系统会检查自己本地的hosts文件查看是否有这个网址的映射关系，如果有，直接调用
    </p>
    <p>
     2.如果没有，则查找本地的DNS解析器缓存，如果有，则直接返回IP
    </p>
    <p>
     3.如果没有，再找TCP/IP参数中设置的本地的DNS服务器，如果该域名包含再本地配置区域的资源中，则返回解析结果。
    </p>
    <p>
     4.也可能查找的域名，本地的DNS服务器已经缓存在网址的映射关系，那么直接调用这个IP
    </p>
    <p>
     5.如果本地DNS服务器也无法解析，会根据本地的DNS服务器是否设置转发器进行查询
    </p>
    <p>
     如果是未转发模式，本地DNS会把请求发给13台根DNS，由对应的根服务器（例如.com）向下找，最后完成解析
    </p>
    <p>
     如果是转发模式，那么DNS服务器会把请求一级一级向上传，往上找，直到传到根DNS。
    </p>
    <h4>
     <a id="10GETPOST_925">
     </a>
     &lt;10&gt;GET和POST的区别
    </h4>
    <p>
     1.get的请求数据只能放在url中，post的数据，可以放在url和请求体
    </p>
    <p>
     2.url长度有限制，所有get方法请求数据不能太多，并且url只能传输ascli字符
    </p>
    <p>
     3.安全性将，post可以存放请求数据在请求体，相对更加安全
    </p>
    <p>
     4.GET主要是从服务端获取数据，而POST请求主要是将数据发送到服务端
    </p>
    <p>
     5.POST请求刷新会被重新提交，但Get请求不会
    </p>
    <h4>
     <a id="11_937">
     </a>
     &lt;11&gt;常见的状态码
    </h4>
    <p>
     400:客户端请求语法错误，服务端无法理解
    </p>
    <p>
     405：映射找到了，但是客户端请求方法和服务端提供的请求方法不匹配
    </p>
    <p>
     500:服务端内部报错
    </p>
    <p>
     403：无权限
    </p>
    <h4>
     <a id="12URL_947">
     </a>
     &lt;12&gt;输入一个URL到浏览器中，会发生什么
    </h4>
    <p>
     1.域名解析(DNS解析)
    </p>
    <p>
     2.发起TCP的三次握手
    </p>
    <p>
     3.建立TCP连接后发起HTTP请求（如果浏览器存储了该域名下的Cookies，那么会把Cookies放入HTTP请求头里发给服务器。）
    </p>
    <p>
     4.服务器端响应http请求，浏览器得到html代码
    </p>
    <p>
     5.浏览器解析html代码，并请求html代码中的资源
    </p>
    <p>
     6.浏览器对页面进行渲染呈现给用户
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


