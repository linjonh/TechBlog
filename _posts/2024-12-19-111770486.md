---
layout: post
title: "计算机操作系统-进程的描述与控制"
date: 2024-12-19 20:05:41 +0800
description: "前趋图与程序执行1.1 前趋图前趋图( Precedence Graph)，是指一个有向无循环图，可"
keywords: "进程 a、b、c、d 为一组合作进程,其前趋图如下图所示,请在下面的程序代码片 断中,"
categories: ['计算机操作系统']
tags: ['操作系统']
artid: "111770486"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=111770486
    alt: "计算机操作系统-进程的描述与控制"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     计算机操作系统-进程的描述与控制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      <strong>
       学习总结目录：
      </strong>
     </p>
     <ul>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/111769238">
        计算机操作系统-学习总结（操作系统引论）
       </a>
      </li>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/111770486">
        计算机操作系统-学习总结（进程的描述与控制）
       </a>
      </li>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/111825735">
        计算机操作系统-学习总结（处理机调度与死锁）
       </a>
      </li>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/111827372">
        计算机操作系统-学习总结（存储器管理）
       </a>
      </li>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/111968686">
        计算机操作系统-学习总结（输入输出系统）
       </a>
      </li>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/111992747">
        计算机操作系统-学习总结（文件管理）
       </a>
      </li>
      <li>
       <a href="https://blog.csdn.net/Lzy410992/article/details/112061979">
        计算机操作系统-学习总结（磁盘存储器）
       </a>
      </li>
     </ul>
    </blockquote>
    <h3>
     <a id="_9">
     </a>
     前趋图与程序执行
    </h3>
    <p>
     <strong>
      1.1 前趋图
     </strong>
     <br/>
     <font color="red">
      前趋图( Precedence Graph)，是指一个有向无循环图，可记为DAG( Directed Acyclic Graph)，它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序( Partial Order)或前趋关系( Precedence Relation）：
     </font>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ee3cf22752c18cfbbf691aaefd749c14.png">
      <br/>
      表示关系：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/05420a84b8465358820bc5755a1ddd68.png"/>
     </img>
    </p>
    <p>
     <strong>
      1.2 程序顺序执行
     </strong>
     <br/>
     <font color="blue">
      一个程序由若干个程序段执行，每个程序段完成特定的功能，在执行过程中，这些程序段需要按照某种顺序执行，当一个程序段完成后，才能运行后一段程序段。
     </font>
    </p>
    <p>
     例如在进行运算时，应该先运行输入程序，在运行计算程序，最后打印程序。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2cf536fc9a79683c35d4f960a85e952a.png">
      <br/>
      <strong>
       程序顺序执行的特征：
      </strong>
     </img>
    </p>
    <ul>
     <li>
      <font color="blue">
       <strong>
        顺序性：
       </strong>
       严格按照程序规定的顺序执行
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        封闭性：
       </strong>
       程序运行时独占全机资源
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        可再现性：
       </strong>
       当环境与初始条件一样时，执行的结果也一样
      </font>
     </li>
    </ul>
    <p>
     <strong>
      1.3 程序并发执行
     </strong>
    </p>
    <p>
     虽然程序顺序执行时，可以给程序员带来方便但是系统资源的利用率却很低。为此，在系统中引入了多道程序技术，使程序或程序段之间能并发执行。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/085beb32668d87be7543eef971b8f2f8.png"/>
    </p>
    <p>
     <strong>
      程序并发执行时的特征：
     </strong>
     <br/>
     <font color="blue">
      在引入了程序间的并发执行功能后，虽然提高了系统的吞吐量和资源利用率，但由于它们共享系统资源，以及它们为完成同一项任务而相互合作，致使在这些并发执行的程序之间必将形成相互制约的关系，由此会给程序并发执行带来新的特征。
     </font>
    </p>
    <ul>
     <li>
      <font color="blue">
       间断性
      </font>
     </li>
     <li>
      <font color="blue">
       失去封闭性
      </font>
     </li>
     <li>
      <font color="blue">
       不可再现性
      </font>
     </li>
    </ul>
    <h3>
     <a id="_40">
     </a>
     进程的描述
    </h3>
    <p>
     <strong>
      2.1 进程的定义和特征
     </strong>
    </p>
    <p>
     <strong>
      1. 进程的定义
     </strong>
     <br/>
     在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性，以及其运行结果不可再现性的特征。
     <strong>
      为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制
     </strong>
     ，人们引入了“进程”的概念。
    </p>
    <p>
     <font color="blue">
      为了使参与并发执行的每个程序都独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为
      <strong>
       进程控制块（Process Control Block，PCB）
      </strong>
      。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。
     </font>
    </p>
    <p>
     <font color="blue">
      进程实体由程序段、相关的数据段和PCB三部分组成，而所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程就是撤销进程的PCB。
     </font>
    </p>
    <p>
     <strong>
      对于进程的定义，从不同的角度可以有不同的定义，其中较典型的定义有:
     </strong>
    </p>
    <ul>
     <li>
      (1)进程是程序的一次执行。
     </li>
     <li>
      (2)进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
     </li>
     <li>
      (3)进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。
     </li>
    </ul>
    <p>
     <font color="blue">
      在引入进程实体的概念后，我们可以把传统OS中的进程定义为：
      <strong>
       “进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”
      </strong>
     </font>
    </p>
    <p>
     <strong>
      2. 进程的特征
     </strong>
    </p>
    <p>
     <font color="blue">
      进程和程序是两个截然不同的概念，除了进程具有程序所没有的
      <strong>
       PCB结构
      </strong>
      外，还具有下面一些特征:
     </font>
    </p>
    <ul>
     <li>
      <font color="blue">
       <strong>
        动态性
       </strong>
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        并发性
       </strong>
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        独立性
       </strong>
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        异步性
       </strong>
      </font>
     </li>
    </ul>
    <p>
     <strong>
      2.2 进程的状态及转换
     </strong>
    </p>
    <p>
     <strong>
      1. 进程的三种基本状态
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       <strong>
        就绪(Ready)状态：
       </strong>
       进程处于准备好运行的状态，一旦得到CPU就可以立即运行
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        执行(Running)状态：
       </strong>
       正在运行的进程所处的状态
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        阻塞(Block)状态：
       </strong>
       由于某些因素，导致该进程即使的到CPU也无法运行（还需要I/O设备），就会进入阻塞状态
      </font>
     </li>
    </ul>
    <p>
     <strong>
      2. 三种基本状态的转换
     </strong>
    </p>
    <p>
     进程在运行过程中会经常发生状态的转换。正在执行的进程如果因分配给它的
     <strong>
      时间片已完
     </strong>
     而被剥夺处理机暂停执行时，其状态便由执行转为就绪；如果因发生某事件，致使当前进程的执行受阻(例如进程访问某临界资源，而该资源正被其它进程访问时)，使之无法继续执行，则该进程状态将由执行转变为阻塞。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/968e888efaae910648ba02c91631091b.png">
      <br/>
      <font color="blue">
       创建状态：进程是需要创建的，且创建进程的过程十分复杂
       <br/>
       <font color="blue">
        终止状态：分为两个步骤（首先，等待操作系统进行善后处理，然后将其PCB清零，将PCB空间返还系统）
       </font>
      </font>
     </img>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/848710682450805ece0a118ae8a780f6.png"/>
    </p>
    <p>
     <strong>
      3.
     </strong>
     挂起操作：挂起处于静止，不再参与CPU的竞争
    </p>
    <ul>
     <li>
      终端用户的需要
     </li>
     <li>
      父进程的请求
     </li>
     <li>
      负荷调节的需要
     </li>
     <li>
      操作系统的需要
     </li>
    </ul>
    <p>
     <strong>
      4. 进程控制块PCB（Process Control Block）
     </strong>
    </p>
    <p>
     PCB是操作系统中最重要的记录型数据结构，它的作用是使一个多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。
    </p>
    <ul>
     <li>
      <font color="blue">
       作为独立运行基本单位的标志：当系统创建一个新进程时，就会建立一个PCB，进程结束时随之消亡
      </font>
     </li>
     <li>
      <font color="blue">
       能实现断性运行方式
      </font>
     </li>
     <li>
      <font color="blue">
       提供进程管理所需的信息
      </font>
     </li>
     <li>
      <font color="blue">
       提供进程调度所需要的信息：如果在优先级调度算法中，需要直到进程的优先级
      </font>
     </li>
     <li>
      <font color="blue">
       实现与其他进程的同步与通信
      </font>
     </li>
    </ul>
    <p>
     <strong>
      进程控制块中的信息：
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       进程标识符(PLD)：外部标识符、内部标识符
      </font>
     </li>
     <li>
      <font color="blue">
       处理机状态
      </font>
     </li>
     <li>
      <font color="blue">
       进程调度信息
      </font>
     </li>
     <li>
      <font color="blue">
       进程控制信息
      </font>
     </li>
    </ul>
    <p>
     <strong>
      进程控制块的组织方式：
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       线性方式（实现简单）
      </font>
     </li>
     <li>
      <font color="blue">
       链式方式，把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列
      </font>
     </li>
     <li>
      <font color="blue">
       索引方式，系统根据所有进程状态的不同，建立几张索引表
      </font>
     </li>
    </ul>
    <h3>
     <a id="_113">
     </a>
     进程控制
    </h3>
    <p>
     进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。进程控制一般是由操作系统的内核中的原语来实现的。
    </p>
    <p>
     <strong>
      3.1 操作系统内核
     </strong>
    </p>
    <p>
     通常将一些硬件紧密相关的模块（如中断处理程序等）、各种常用设备的驱动程序以及运行频率较高的模块，都安排在仅靠硬件的软件层次中，将它们常驻内存，及通常被称为的OS内核。这种安排方式的目的包括：
    </p>
    <ul>
     <li>
      <font color="blue">
       便于对这些软件进行保护
      </font>
     </li>
     <li>
      <font color="blue">
       提高OS的运行效率
      </font>
     </li>
    </ul>
    <p>
     <font color="blue">
      为防止OS本身及关键数据遭受应用程序有意或无意的破坏，通常也将处理机的执行状态分为系统态和用户态：
     </font>
    </p>
    <ul>
     <li>
      <font color="blue">
       系统态（管态、内核态）具有较高特权，能执行一切指令，访问所有寄存器和存储区
      </font>
     </li>
     <li>
      <font color="blue">
       用户态（目态）特权较低，只能执行规定的指令，访问指定的寄存器和存储区
      </font>
     </li>
    </ul>
    <p>
     一般情况下，应用程序只能在用户态运行（在用户态执行的是命令解释程序）
    </p>
    <p>
     <font color="blue">
      用户状态切换到内核的3种方式：
      <strong>
       系统调用、异常、外围设备中断
      </strong>
     </font>
    </p>
    <p>
     <strong>
      支撑功能：
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       中断处理，内核最基本的功能
      </font>
     </li>
     <li>
      <font color="blue">
       时钟管理，内核的一项基本功能，在时间片转轮调度、实时系统中的截止时间控制、批处理系统中的醉成运行时间控制等都需要时钟管理功能
      </font>
     </li>
     <li>
      <font color="blue">
       原语操作，原子操作在系统态下执行常驻内存
      </font>
     </li>
    </ul>
    <p>
     <strong>
      原语是一个程序，是不能被打断的，内核是通过各种原语操作来实现管理和控制功能的。
     </strong>
     <br/>
     <font color="blue">
      几个原语：
      <br/>
      创建——终止（撤销），挂起——激活，阻塞——唤醒。P操作——V操作。
      <br/>
      通信原语：send（发送）-receive（接收）
     </font>
    </p>
    <p>
     <strong>
      资源管理功能：
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       进程管理
      </font>
     </li>
     <li>
      <font color="blue">
       存储器管理
      </font>
     </li>
     <li>
      <font color="blue">
       设备管理
      </font>
     </li>
    </ul>
    <p>
     <strong>
      3.2 进程的创建
     </strong>
    </p>
    <p>
     在操作系统中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，而被创建的进程称为子进程，子进程可以继承父进程所拥有的资源。在撤销父进程时必须撤销子进程。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2113ab9c34b630d97935cb40271914c1.png">
      <br/>
      <strong>
       引起创建进程的事件：
      </strong>
     </img>
    </p>
    <ul>
     <li>
      用户登录
     </li>
     <li>
      作业调度
     </li>
     <li>
      提供服务
     </li>
     <li>
      应用请求
     </li>
    </ul>
    <p>
     <strong>
      进程的创建（Creation of Process）：
     </strong>
     <br/>
     （1）申请空白PCB，为新进程申请获得唯一的数字标识符
     <br/>
     （2）为新进程分配器运行所需的资源
     <br/>
     （3）初始化进程控制块（PCB）
     <br/>
     （4）如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列
    </p>
    <p>
     <strong>
      3.3 进程的终止
     </strong>
    </p>
    <p>
     <strong>
      引起进程终止的事件：
     </strong>
    </p>
    <ul>
     <li>
      正常结束
     </li>
     <li>
      异常结束：越界错、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/O故障
     </li>
     <li>
      外界干预
     </li>
    </ul>
    <p>
     <strong>
      3.4 进程的阻塞与唤醒
     </strong>
    </p>
    <p>
     <strong>
      引起进程阻塞或唤醒的事件：
     </strong>
    </p>
    <ul>
     <li>
      向系统请求共享资源失败
     </li>
     <li>
      等待某种操作的完成
     </li>
     <li>
      新数据尚未到达
     </li>
     <li>
      等待新任务的到达
     </li>
    </ul>
    <p>
     <font color="blue">
      进程阻塞是进程自身的一种主动行为
     </font>
    </p>
    <p>
     <font color="blue">
      进程的挂起：进程静止不动的状态
      <br/>
      原因：运行空间不足，内存不足
     </font>
    </p>
    <h3>
     <a id="_181">
     </a>
     进程同步
    </h3>
    <p>
     <font color="red">
      为了
      <strong>
       保证多个进程能够有条不紊地运行
      </strong>
      ，在多道程序系统中，必须引入进程同步机制（硬件同步机制、信号量机制、管城机制）利用它们来保证程序执行的可再现性。
     </font>
    </p>
    <p>
     <strong>
      4.1 进程同步的基本概念
     </strong>
    </p>
    <p>
     <strong>
      两种制约关系
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       <strong>
        间接相互制约关系（互斥）：系统资源竞争，进程间彼此无关
       </strong>
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        直接相互制约关系（同步）：进程间合作，彼此相关，有先后顺序
       </strong>
      </font>
     </li>
    </ul>
    <p>
     <font color="blue">
      <strong>
       临界资源( Critical Resouce)：
      </strong>
      许多硬件资源如打印机、磁带机等,都属于临界资源，诸进程间应采取互斥方式，实现对这种资源的共享。（一次只能访问一个）
     </font>
    </p>
    <p>
     <font color="blue">
      <strong>
       临界区( critical section)：
      </strong>
      不论是硬件临界资源还是软件临界资源多个进程必须互斥地对它进行访问。人们把在每个进程中访问临界资源的那段代码称为临界区( critical section）
     </font>
    </p>
    <p>
     为实现进程互斥地进入自己的临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则：
    </p>
    <ul>
     <li>
      空闲让进
     </li>
     <li>
      忙则等待
     </li>
     <li>
      有限等待
     </li>
     <li>
      让权等待
     </li>
    </ul>
    <p>
     <strong>
      4.2 硬件同步机制
     </strong>
    </p>
    <p>
     虽然可以利用软件方法解决诸进程互斥进入临界区的问题,但有一定难度,并且存在很大的局限性,因而现在已很少采用。相应地,目前许多计算机已提供了一些特殊的硬件指令,允许对一个字中的内容进行检测和修正,或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。
    </p>
    <p>
     <strong>
      4.3 信号量机制（用来表示资源的数量）
     </strong>
    </p>
    <p>
     <strong>
      1.整型信号量
     </strong>
    </p>
    <p>
     <font color="blue">
      最初由 Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作( Atomic Operation)
      <strong>
       wait(S)和signal(s)
      </strong>
      来访问。很长时间以来，这两个操作一直被分别称为P、V操作。
     </font>
    </p>
    <pre><code class="prism language-java"><span class="token comment">//P(S)&lt;=&gt;wait(S) V(S)&lt;=&gt;signal(S)</span>
<span class="token comment">//P减一操作：S&gt;=0系统有资源，进程执行，S&lt;0进程进入阻塞状态</span>
<span class="token comment">//V加一操作：S&gt;0进程执行，S&lt;=0系统中有等待使用资源的进程，唤醒等待的进程</span>
<span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	S<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	S<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      2. 记录型信号量
     </strong>
    </p>
    <p>
     <strong>
      3. AND型信号量
     </strong>
    </p>
    <p>
     <strong>
      4. 信号量集
     </strong>
    </p>
    <p>
     <strong>
      4.4 信号量级的应用
     </strong>
     <br/>
     为使多个进程能互斥地访问某临界资源,只需为该资源设置一互斥信号量 mutex,并设其初始值为1,然后将各进程访问该资源的临界区CS置于wait( mutex)和 signal( mutex)操作之间即可。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0387052d7e62cc24d8420e8fb0e06f6e.png">
      <br/>
      代码框架：
     </img>
    </p>
    <pre><code class="prism language-java"><span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> S1<span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">wait</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> S2<span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">wait</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> S3<span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">wait</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> S4<span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">wait</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> S5<span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">wait</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span> S6<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	semaphore a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">,</span>g<span class="token punctuation">;</span>
	a<span class="token punctuation">.</span>value<span class="token operator">=</span>b<span class="token punctuation">.</span>value<span class="token operator">=</span>c<span class="token punctuation">.</span>value<span class="token operator">=</span>d<span class="token punctuation">.</span>value<span class="token operator">=</span>e<span class="token punctuation">.</span>value<span class="token operator">=</span>f<span class="token punctuation">.</span>value<span class="token operator">=</span>g<span class="token punctuation">.</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	cobegin
	  <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	coend
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_259">
     </a>
     进程通信
    </h3>
    <p>
     <font color="red">
      所谓进程通信是指进程之间信息交换。由于进程的互斥和同步，需要在进程间交换一定的信息，故不少学者将它们也归为进程通信，但只能被称为低级进程通信（效率低、通信对用户不透明）
     </font>
    </p>
    <p>
     <font color="blue">
      高级通信：用户可直接利用OS提供的一组通信命令高效传送大量数据。可以分为四大类：
     </font>
    </p>
    <ul>
     <li>
      <p>
       <font color="blue">
        <strong>
         共享存储器系统(Shared-Memory System) ：
        </strong>
        进程间通过共享某些数据结构或共享存储区进行通信。
       </font>
      </p>
     </li>
     <li>
      <p>
       <font color="blue">
        <strong>
         管道(Pipe)通信：
        </strong>
        用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件（pipe文件）。管道机制必须提供的协调能力：互斥、同步、确定对方是否存在。
       </font>
      </p>
     </li>
     <li>
      <p>
       <font color="blue">
        <strong>
         消息传递系统 (Message Passing System)：
        </strong>
        进程不必借助任何共享区或数据结构，而是以格式化的消息（message）为单位，将通信的数据封装在消息中，完成进程间的数据交换。因实现方式不同可以分为两类：
        <br/>
        <strong>
         直接通信：
        </strong>
        发送进程直接把消息发送给接收者，并将它挂在接收进程的消息缓冲队列上。接收进程从消息缓冲队列中取得消息。也称为消息缓冲通信
        <br/>
        <strong>
         间接通信：
        </strong>
        发送进程将消息发送到某种中间实体中（信箱），接收进程从（信箱）中取得消息。也称信箱通信。在网络中称为电子邮件系统。
       </font>
      </p>
     </li>
     <li>
      <p>
       <font color="blue">
        <strong>
         客户机-服务器系统（Client-Server system）
        </strong>
       </font>
      </p>
     </li>
    </ul>
    <h3>
     <a id="Threads_273">
     </a>
     线程（Threads）的基本概念
    </h3>
    <p>
     <font color="red">
      在操作系统中引入进程的目的是为了使多个程序能够并发执行，
      <strong>
       以提高资源的利用率和系统的吞吐量
      </strong>
      ，那么，在操作系统中在引入线程，则是为了
      <strong>
       减少程序在并发执行时所付出的时空开销，使操作系统具有更好的并发性
      </strong>
      。
     </font>
    </p>
    <p>
     <strong>
      进程的两个基本属性：
     </strong>
    </p>
    <ul>
     <li>
      <font color="blue">
       进程是一个可拥有资源的独立单位，一个进程要能独立运行，它必须拥有一定的资源,包括用于存放程序正文数据的磁盘和内存地址空间，以及它在运行时所需要的IO设备、已打开的文件、信号量等
      </font>
     </li>
     <li>
      <font color="blue">
       进程同时又是一个可独立调度和分派的基本单位，一个进程要能独立运行，它还必须是一个可独立调度和分派的基本单位。
      </font>
     </li>
    </ul>
    <p>
     <strong>
      线程作为调度和分派的基本单位：
     </strong>
     <br/>
     设法将进程的上述两个属性分开，由操作系统分开处理，亦即并不把作为调度和分派的基本单位也同时作为拥有资源的单位。以线程作为调度和分派的基本单位，可以有效地改善多处理机系统的性能。一些主要的OS（UNIX，Windows）厂家有进一步对线程技术做了开发，使之适用于SMP的计算机系统。
    </p>
    <h3>
     <a id="_285">
     </a>
     线程与进程的比较
    </h3>
    <p>
     <font color="blue">
      由于线程具有传统进程所具有的特征，所以又称之为轻型进程（Light-Weigth Process）或进程元，相应地，把传统进程称之为重型进程（Heavy-Weight Process）。
     </font>
    </p>
    <ul>
     <li>
      1.调度的基本单位
     </li>
     <li>
      2.并发性：都可以并发执行
     </li>
     <li>
      3.拥有资源：进程可以拥有资源，并作为系统中拥有资源的一个基本单位，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证自己独立运行的资源，同时它还允许多个线程共享该进程所拥有的资源。
     </li>
     <li>
      4.独立性：每个进程都拥有一个独立的地址空间和其他资源，除了共享全局变量外，不允许其它进程访问。同一进程中的不同线程往往共享进程的内存地址空间等资源
     </li>
     <li>
      5.系统开销：在创建和撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其它资源，线程的切换的代价远远低于进程。
     </li>
     <li>
      6.支持多处理机系统：可将一个进程的多个线程分配到多个处理机上
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5d5c59716bb32abe5556da4e4b8f622e.png"/>
     </li>
    </ul>
    <p>
     <strong>
      线程运行的三个状态：
     </strong>
    </p>
    <p>
     <font color="blue">
      与传统的进程一样，在各线程之间也存在着共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下述三种基本状态：
     </font>
    </p>
    <ul>
     <li>
      <font color="blue">
       <strong>
        执行状态
       </strong>
       ，表示线程已获得处理机而正在运行;
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        就绪状态
       </strong>
       ，指线程已具备了各种执行条件,只须再获得CPU便可立即执行;
      </font>
     </li>
     <li>
      <font color="blue">
       <strong>
        阻塞状态
       </strong>
       ，指线程在执行中因某事件受阻而处于暂停状态,例如,当一个线程执行从键盘读入数据的系统调用时,该线程就褀阳塞
      </font>
     </li>
    </ul>
    <h3>
     <a id="_303">
     </a>
     线程
    </h3>
    <p>
     <font color="blue">
      <strong>
       内核支持线程KST（Kernel Supported Threads）
      </strong>
      <br/>
      在操作系统的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。
     </font>
    </p>
    <p>
     <strong>
      四个优点：
     </strong>
    </p>
    <ul>
     <li>
      在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行
     </li>
     <li>
      如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行,也可以运行其它进程中的线程
     </li>
     <li>
      内核支持线程具有很小的数据结构和堆栈，线程的切换比较快,切换开销小；
     </li>
     <li>
      内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。
     </li>
    </ul>
    <p>
     <font color="blue">
      <strong>
       用户级线程ULT（User Level Threads）
      </strong>
      ：调度过程不需要内核支持
     </font>
    </p>
    <h3>
     <a id="_315">
     </a>
     测试题
    </h3>
    <p>
     一、选择题
    </p>
    <p>
     <strong>
      1、进程与程序的根本区别是（ ）。
     </strong>
     <br/>
     A．静态和动态特征 B．是不是被调入到内存中
     <br/>
     C．是不是存在三种基本状态 D．是不是占有处理机
    </p>
    <p>
     <strong>
      2、操作系统是根据（ ）来对并发执行的进程进行控制和管理的。
     </strong>
     <br/>
     A．进程放入基本状态 B．进程控制块
     <br/>
     C．多道程序设计 D．进程的优先权
    </p>
    <p>
     <strong>
      3、某进程由于需要从磁盘上读入数据而处于等待状态。当系统完成了所需的读盘操作后，此时该进程的状态将（ ）。
     </strong>
     <br/>
     A．从就绪变为运行 B．从运行变为就绪
     <br/>
     C．从运行变为阻塞 D．从阻塞变为就绪
    </p>
    <p>
     <strong>
      4、一个进程被唤醒意味着（ ）。
     </strong>
     <br/>
     A．该进程重新占有CPU B．进程状态变为就绪状态
     <br/>
     C．它的优先权变为最大 D．其PCB移至就绪队列的队首
    </p>
    <p>
     <strong>
      5、进程从运行态到等待态可能是（ ）。
     </strong>
     <br/>
     A．运行进程执行了P操作 B．运行进程执行了V操作
     <br/>
     C．进程时间片用完 D．进程被调度
    </p>
    <p>
     <strong>
      6、一个进程释放了一台打印机，有可能改变（ ）的状态。
     </strong>
     <br/>
     A．自身进程 B．输入输出进程
     <br/>
     C．另一个等待打印机的进程 D．所有等待打印机的进程
    </p>
    <p>
     <strong>
      7、可能导致进程从运行状态变为就绪状态的事件为（ ）。
     </strong>
     <br/>
     A．等待I/O操作 B．等待的事件发生
     <br/>
     C．进程运行结束 D．出现了比当前进程优先级高的进行
    </p>
    <p>
     <strong>
      8、必然会引起进程切换的事件为（ ）。
     </strong>
     <br/>
     A．创建一个新的进程后进入就绪状态 B．一个进程从运行状态变为就绪状态
     <br/>
     C．一个进程从阻塞状态变为就绪状态 D．以上说法都不对
    </p>
    <p>
     <strong>
      9、系统中有n（n&gt;2）个进程，则不可能发生（ ）。
     </strong>
     <br/>
     A．有1个运行进行和n-1个就绪进程，但没有进程处于等待状态
     <br/>
     B．有1个运行进程和1和就绪进程，剩下n-2个进程处于等待进行
     <br/>
     C．没有运行进程，1个就绪进程，剩下的n-1个进程处于等待状态
     <br/>
     D．没有就绪的进程和运行的进程，全部进程处于等待状态
    </p>
    <p>
     <strong>
      10、下列状态的改变可以由进程自身决定的是（ ）。
     </strong>
     <br/>
     A．从运行到阻塞 B．从运行到就绪
     <br/>
     C．从就绪到运行 D．从阻塞到就绪
    </p>
    <p>
     <strong>
      11、用户可以通过（ ）创建或终止一个进程。
     </strong>
     <br/>
     A．函数调用 B．指令 C．系统调用 D．命令
    </p>
    <p>
     <strong>
      12、两个进程合作完成一个任务，在并发执行中，一个进程要等待其合作伙伴发来信息，或者建立某个条件后再向前执行，这种关系是进程间的（ ）关系。
     </strong>
     <br/>
     A．同步 B．互斥 C．合作 D．竞争
    </p>
    <p>
     <strong>
      13、进程间的同步和互斥，分别表示了进程间的（ ）。
     </strong>
     <br/>
     A．独立和制约 B．协作和竞争 C．动态性和独立性 D．不同状态
    </p>
    <p>
     <strong>
      14、操作系统在使用信号量解决同步和互斥问题中，若P、V操作的信号量S初始值为3，当前值为-2，则表示有（ ）个等待进程。
     </strong>
    </p>
    <p>
     <strong>
      15、有3个进程共享同一个程序段，而每次只允许两个进程进入该程序段，若用P、V操作同步机制，则信号量S的取值范围是（ ）。
     </strong>
    </p>
    <p>
     <strong>
      16、设某资源关联的信号量初值为3，当前值为1，若M表示资源可以的数量，N表示等待资源的进程数，则M、N分别是（ ）。
     </strong>
     <br/>
     A．0、1 B．1、0 C．1、2 D．2、0
    </p>
    <p>
     <strong>
      17、执行V操作时，当信号量的值（ ），应释放一个等待该信号量的进程。
     </strong>
     <br/>
     A．小于0 B．大于0 C．小于等于0 D．大于等于0
    </p>
    <p>
     <strong>
      18、对两个并发进程，其互斥信号量为mutex，若mutex=0,则表明（ ）
     </strong>
     <br/>
     A．没有进程进入临界区 B．有两个进程进入临界区
     <br/>
     C．一个进程进入临界区但没有进程处于阻塞状态
     <br/>
     D．一个进入临界区一个出去等待进入临界区的状态
    </p>
    <p>
     <strong>
      19、信箱通信是一种（ ）。
     </strong>
     <br/>
     A．直接通信 B．间接通信 C．低级通信 D．信号量
    </p>
    <p>
     <strong>
      20、下面说法正确的是（ ）。
     </strong>
     <br/>
     A．不论是系统支持的线程还是用户级线程，其切换都需要内核的支持
     <br/>
     B．线程是资源分配的单位，进程是调度和分派的单位
     <br/>
     C．不管系统中是否有线程，进程都是拥有资源的独立单位
     <br/>
     D．在引入线程的系统中，进程仍是资源调度和分配的基本单位
    </p>
    <p>
     <strong>
      21、下列选项中，会导致用户从用户态切换到内核态的操作是（ ）
     </strong>
     <br/>
     ⅰ.整数除以零 ⅱ.sin函数调用 ⅲ.read函数调用
     <br/>
     A. ⅰ和ⅱ B. ⅰ和ⅲ C. ⅱ和ⅲ D. ⅰ、ⅱ和ⅲ
    </p>
    <blockquote>
     <p>
      <font color="blue">
       1-5 ABDBA 6-10 CDBCA
       <br/>
       11-13 CAB 14. 2 15. (-1,0,1,2)
       <br/>
       16-21 BCCBCB
      </font>
     </p>
    </blockquote>
    <p>
     <strong>
      二、综合应用题
     </strong>
    </p>
    <p>
     <strong>
      1、进程之间存在哪些制约关系？下列活动属于哪些制约关系？
     </strong>
     <br/>
     （1）若干学生去图书馆借同一本书
     <br/>
     （2）两队进行篮球比赛
     <br/>
     （3）流水线生产的各道工序
     <br/>
     （4）商品生产和消费
    </p>
    <blockquote>
     <p>
      进程之间存在着直接制约和间接制约两种制约关系,其中直接制约(同步)是由于进程间的相互合作而引起的（生产者、消费者问题）,而间接制约(互斥)则是由于进程间共享临界资源而引起的。
      <br/>
      （1）若干学生去图书馆借同一本书
      <br/>
      间接制约关系（互斥），因为书是临界资源，需要采用互斥的方式来实现对该资源的共享。
      <br/>
      （2）两队进行篮球比赛
      <br/>
      间接制约关系（互斥），因为篮球是临界资源。
      <br/>
      （3）流水线生产的各道工序
      <br/>
      直接制约(同步)，一个工序生产后才能开始下一个工序。
      <br/>
      （4）商品生产和消费
      <br/>
      直接制约(同步)，生产后才能消费
     </p>
    </blockquote>
    <p>
     <strong>
      2、某组相互合作的进程，其前趋图如下所示，信号量a，b，c，d，e，f的初始值为0，请用P、V操作实现进程间的同步操作。
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a8f6414f6093ce7510dfa5afb27f539c.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> P1<span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">P</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> P2<span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">P</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> P3<span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">P</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> P4<span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">P</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> P5<span class="token punctuation">;</span> <span class="token function">V</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">p6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">P</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">P</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> P6<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	semaphore a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">,</span>g<span class="token punctuation">;</span>
	a<span class="token punctuation">.</span>value<span class="token operator">=</span>b<span class="token punctuation">.</span>value<span class="token operator">=</span>c<span class="token punctuation">.</span>value<span class="token operator">=</span>d<span class="token punctuation">.</span>value<span class="token operator">=</span>e<span class="token punctuation">.</span>value<span class="token operator">=</span>f<span class="token punctuation">.</span>value<span class="token operator">=</span>g<span class="token punctuation">.</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	cobegin
	  <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">p6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	coend
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      3、桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专门向盘子中放苹果，妈妈专门向盘子中橘子，儿子专门等吃盘子中的橘子，女儿专门等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈就可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。请利用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步和互斥关系。
     </strong>
    </p>
    <pre><code class="prism language-java">semaphore f<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>o<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">processDad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先判断盘子是否有空间 ，没有的话就不能向下进行了 </span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断盘子是否被占用，即是否有其他人在操作</span>
    <span class="token function">setApple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//放置苹果 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//苹果加一 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放盘子资源 </span>
<span class="token punctuation">}</span> 

<span class="token function">processMom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先判断盘子是否有空间 ，没有的话就不能向下进行了 </span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断盘子是否被占用，即是否有其他人在操作 </span>
    <span class="token function">setOrange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//放置橘子 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//橘子加一 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放盘子资源 </span>
<span class="token punctuation">}</span>

<span class="token function">processSon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先判断盘子是否有橘子 ，没有的话就不能向下进行了 </span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断盘子是否被占用，即是否有其他人在操作</span>
    <span class="token function">eatOrange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿走橘子 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//盘子空间加一 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放盘子资源 </span>
<span class="token punctuation">}</span> 

<span class="token function">processDaughter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先判断盘子是否有苹果 ，没有的话就不能向下进行了 </span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断盘子是否被占用，即是否有其他人在操作</span>
    <span class="token function">eatApple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿走苹果 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//盘子空间加一 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放盘子资源 </span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      4、某博物馆最多可以容纳1000人同时参观，有一个出入口，该出入口一次仅允许一个人通过。参观者的活动描述如下：
     </strong>
    </p>
    <pre><code class="prism language-java">参观者进程：
<span class="token punctuation">{<!-- --></span>
	进门<span class="token punctuation">;</span>
	……
	参观<span class="token punctuation">;</span>
	……
	出门<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-java">semaphore empty<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span>mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//empty表示空闲位置的数量 </span>
<span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为是先执行进门操作，所以需要先对容量进行判断 </span>
<span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//占用临界资源 </span>
进门<span class="token punctuation">;</span> 
<span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放 </span>

<span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//占用 </span>
出门<span class="token punctuation">;</span> 
<span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放 </span>
<span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空间加一 </span>
</code></pre>
    <p>
     请添加必要的信号量和P、V操作以实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋初值。
    </p>
    <p>
     <strong>
      5、有一只最多能装2只兔子的铁笼子，猎人仅能向笼子中放入兔子（每次只能放入1只），若笼子是满的，则猎人必须等待；饭店老板仅能从笼子中取兔子（每次只能取出1只），若笼子是空的则他也必须等待。假设初始时笼子是空的。使用P、V操作实现猎人和饭店老板进程之间的同步与互斥。要求写出完整的过程，并对信号量赋初值。
     </strong>
    </p>
    <pre><code class="prism language-java">semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>empty<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>full<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">Hunter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先判断是否有空间 </span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//猎人和用户要实现对笼子的互斥访问 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放笼子资源 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空间减一 </span>
<span class="token punctuation">}</span>

<span class="token function">Boss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先判断笼子里是否有兔子 </span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//猎人和用户要实现对笼子的互斥访问 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放笼子资源 </span>
    <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空间加一 </span>
<span class="token punctuation">}</span> 
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f4c7a793431303939322f:61727469636c652f64657461696c732f313131373730343836" class_="artid" style="display:none">
 </p>
</div>


