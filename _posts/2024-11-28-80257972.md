---
layout: post
title: "Elasticsearch数据库match和term的区别"
date: 2024-11-28 16:30:27 +0800
description: "es种有两种查询模式，一种是像传递URL参数一样去传递查询语句，被称为简单搜索或查询字符串(quer"
keywords: "match是什么库"
categories: ['30Elasticsearch']
tags: ['Term', 'Match', 'Elasticsearch']
artid: "80257972"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=80257972
    alt: "Elasticsearch数据库match和term的区别"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Elasticsearch数据库match和term的区别
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div>
     <div>
      <p>
       <span style="color:#3333ff;">
        <strong>
         <span style="background-color:rgb(255,255,255);">
          作者：木鸟飞鱼
         </span>
         <br style="background-color:rgb(255,255,255);"/>
         <span style="background-color:rgb(255,255,255);">
          链接：https://www.jianshu.com/p/eb30eee13923
         </span>
         <br style="background-color:rgb(255,255,255);"/>
         <span style="background-color:rgb(255,255,255);">
          來源：简书
         </span>
        </strong>
       </span>
      </p>
      <p>
       es种有两种查询模式，一种是像传递URL参数一样去传递查询语句，被称为简单搜索或
       <strong>
        查询字符串(query string)
       </strong>
       搜索，比如
      </p>
      <pre><code class="language-cpp"><code class="cpp">GET /megacorp/employee/_search <span class="hljs-comment">//查询全部员工</span>
GET /megacorp/employee/_search?q=last_name:Smith <span class="hljs-comment">//查询last_name为Smith的员工</span>
</code></code></pre>
      <p>
       另外一种是通过DSL语句来进行查询，被称为
       <strong>
        DSL查询(Query DSL)
       </strong>
       ,DSL是Elasticsearch提供的一种丰富且灵活的查询语言，该语言以json请求体的形式出现，通过restful请求与Elasticsearch进行交互，本文主要讲DSL查询的一些常用规则，在介绍之前，我们先简单插入一个测试用的小例子(假设我们已经有了一个elasticsearch测试环境且装好了分词插件, 如果需要查看如何安装中文环境，可浏览我的另一篇文章
       <a href="https://www.jianshu.com/p/f169e70364d4" rel="nofollow">
        Elasticsearch中文搜索环境搭建
       </a>
       )。
      </p>
      <pre><code class="language-ruby"><code class="ruby"> $curl -XPOST <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhost:9200/index</span><span class="hljs-regexp">/doc/</span><span class="hljs-number">1</span> -d<span class="hljs-string">'{"content":"美国留给伊拉克的是个烂摊子吗","title":"标题","tags":["美国","伊拉克","烂摊子"]}'</span>
 $curl -XPOST <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhost:9200/index</span><span class="hljs-regexp">/doc/</span><span class="hljs-number">2</span> -d<span class="hljs-string">'{"content":"中国是世界上人口最多的国家","title":"中国","tags":["中国","人口"]}'</span>
 $curl -XPOST <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhost:9200/index</span><span class="hljs-regexp">/doc/</span><span class="hljs-number">3</span> -d<span class="hljs-string">'{"content":"同一个世界同一个梦想","title":"北京奥运","tags":["和平"]}'</span>
 $curl -XPOST <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhost:9200/index</span><span class="hljs-regexp">/doc/</span><span class="hljs-number">4</span> -d<span class="hljs-string">'{"content":"杭州是一个美丽的城市,欢迎来到杭州","title":"宣传","tags":["旅游","城市"]}'</span>
</code></code></pre>
      <p>
       检查一下我们的数据是否导入成功
      </p>
      <pre><code class="language-ruby"><code class="ruby">$curl -XGET <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/localhost:9200/index</span><span class="hljs-regexp">/doc/</span>_search
{<!-- --><span class="hljs-string">"took"</span><span class="hljs-symbol">:</span><span class="hljs-number">1</span>,<span class="hljs-string">"timed_out"</span><span class="hljs-symbol">:false</span>,<span class="hljs-string">"_shards"</span><span class="hljs-symbol">:</span>{<!-- --><span class="hljs-string">"total"</span><span class="hljs-symbol">:</span><span class="hljs-number">5</span>,<span class="hljs-string">"successful"</span><span class="hljs-symbol">:</span><span class="hljs-number">5</span>,<span class="hljs-string">"failed"</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span>},<span class="hljs-string">"hits"</span><span class="hljs-symbol">:</span>{<!-- --><span class="hljs-string">"total"</span><span class="hljs-symbol">:</span><span class="hljs-number">4</span>,<span class="hljs-string">"max_score"</span><span class="hljs-symbol">:</span><span class="hljs-number">1.0</span>,<span class="hljs-string">"hits"</span><span class="hljs-symbol">:</span>[{<!-- --><span class="hljs-string">"_index"</span><span class="hljs-symbol">:<span class="hljs-string">"index"</span></span>,<span class="hljs-string">"_type"</span><span class="hljs-symbol">:<span class="hljs-string">"doc"</span></span>,<span class="hljs-string">"_id"</span><span class="hljs-symbol">:<span class="hljs-string">"2"</span></span>,<span class="hljs-string">"_score"</span><span class="hljs-symbol">:</span><span class="hljs-number">1.0</span>,<span class="hljs-string">"_source"</span><span class="hljs-symbol">:</span>{<!-- --><span class="hljs-string">"content"</span><span class="hljs-symbol">:<span class="hljs-string">"中国是世界上人口最多的国家"</span></span>,<span class="hljs-string">"title"</span><span class="hljs-symbol">:<span class="hljs-string">"中国"</span></span>,<span class="hljs-string">"tags"</span><span class="hljs-symbol">:</span>[<span class="hljs-string">"中国"</span>,<span class="hljs-string">"人口"</span>]}},{<!-- --><span class="hljs-string">"_index"</span><span class="hljs-symbol">:<span class="hljs-string">"index"</span></span>,<span class="hljs-string">"_type"</span><span class="hljs-symbol">:<span class="hljs-string">"doc"</span></span>,<span class="hljs-string">"_id"</span><span class="hljs-symbol">:<span class="hljs-string">"4"</span></span>,<span class="hljs-string">"_score"</span><span class="hljs-symbol">:</span><span class="hljs-number">1.0</span>,<span class="hljs-string">"_source"</span><span class="hljs-symbol">:</span>{<!-- --><span class="hljs-string">"content"</span><span class="hljs-symbol">:<span class="hljs-string">"杭州是一个美丽的城市,欢迎来到杭州"</span></span>,<span class="hljs-string">"title"</span><span class="hljs-symbol">:<span class="hljs-string">"宣传"</span></span>,<span class="hljs-string">"tags"</span><span class="hljs-symbol">:</span>[<span class="hljs-string">"旅游"</span>,<span class="hljs-string">"城市"</span>]}},{<!-- --><span class="hljs-string">"_index"</span><span class="hljs-symbol">:<span class="hljs-string">"index"</span></span>,<span class="hljs-string">"_type"</span><span class="hljs-symbol">:<span class="hljs-string">"doc"</span></span>,<span class="hljs-string">"_id"</span><span class="hljs-symbol">:<span class="hljs-string">"1"</span></span>,<span class="hljs-string">"_score"</span><span class="hljs-symbol">:</span><span class="hljs-number">1.0</span>,<span class="hljs-string">"_source"</span><span class="hljs-symbol">:</span>{<!-- --><span class="hljs-string">"content"</span><span class="hljs-symbol">:<span class="hljs-string">"美国留给伊拉克的是个烂摊子吗"</span></span>,<span class="hljs-string">"title"</span><span class="hljs-symbol">:<span class="hljs-string">"标题"</span></span>,<span class="hljs-string">"tags"</span><span class="hljs-symbol">:</span>[<span class="hljs-string">"美国"</span>,<span class="hljs-string">"伊拉克"</span>,<span class="hljs-string">"烂摊子"</span>]}},{<!-- --><span class="hljs-string">"_index"</span><span class="hljs-symbol">:<span class="hljs-string">"index"</span></span>,<span class="hljs-string">"_type"</span><span class="hljs-symbol">:<span class="hljs-string">"doc"</span></span>,<span class="hljs-string">"_id"</span><span class="hljs-symbol">:<span class="hljs-string">"3"</span></span>,<span class="hljs-string">"_score"</span><span class="hljs-symbol">:</span><span class="hljs-number">1.0</span>,<span class="hljs-string">"_source"</span><span class="hljs-symbol">:</span>{<!-- --><span class="hljs-string">"content"</span><span class="hljs-symbol">:<span class="hljs-string">"同一个世界同一个梦想"</span></span>,<span class="hljs-string">"title"</span><span class="hljs-symbol">:<span class="hljs-string">"北京奥运"</span></span>,<span class="hljs-string">"tags"</span><span class="hljs-symbol">:</span>[<span class="hljs-string">"和平"</span>]}}]}}
</code></code></pre>
      <p>
       ok，导入成功，接下来利用这些数据逐步介绍各种常用查询
      </p>
      <h5>
       term查询
      </h5>
      <p>
       term是代表完全匹配，也就是精确查询，搜索前不会再对搜索词进行分词，所以我们的搜索词必须是文档分词集合中的一个。比如说我们要找标题为北京奥运的所有文档
      </p>
      <pre><code class="language-php"><code class="php">$curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
  "query":{
    "term":{
        "title":"北京奥运"
    }
  }
}'</span>
</code></code></pre>
      <p>
       将会得到如下结果
      </p>
      <pre class="hljs json"><code class="json">{
    <span class="hljs-attr">"took"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"timed_out"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"_shards"</span>: {
        <span class="hljs-attr">"total"</span>: <span class="hljs-number">5</span>,
        <span class="hljs-attr">"successful"</span>: <span class="hljs-number">5</span>,
        <span class="hljs-attr">"failed"</span>: <span class="hljs-number">0</span>
    },
    <span class="hljs-attr">"hits"</span>: {
    <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"max_score"</span>: <span class="hljs-number">0.92055845</span>,
    <span class="hljs-attr">"hits"</span>: [
     {
        <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"index"</span>,
        <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,
        <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"3"</span>,
        <span class="hljs-attr">"_score"</span>: <span class="hljs-number">0.92055845</span>,
        <span class="hljs-attr">"_source"</span>: {
           <span class="hljs-attr">"content"</span>: <span class="hljs-string">"同一个世界同一个梦想"</span>,
           <span class="hljs-attr">"title"</span>: <span class="hljs-string">"北京奥运"</span>,
           <span class="hljs-attr">"tags"</span>: [
               <span class="hljs-string">"和平"</span>
            ]
        }
      }
    ]
  }
}
</code></pre>
      <p>
       搜索
       <code>
        title
       </code>
       包含
       <code>
        北京
       </code>
       或者
       <code>
        奥运
       </code>
       的，结果也一样，但是如果你搜索词为
       <code>
        京奥
       </code>
       ,或者
       <code>
        北京奥
       </code>
       这样的，那么搜索结果将为空
      </p>
      <pre class="hljs json"><code class="json">{
  <span class="hljs-attr">"took"</span> : <span class="hljs-number">1</span>,
  <span class="hljs-attr">"timed_out"</span> : <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"_shards"</span> : {
      <span class="hljs-attr">"total"</span> : <span class="hljs-number">5</span>,
      <span class="hljs-attr">"successful"</span> : <span class="hljs-number">5</span>,
      <span class="hljs-attr">"failed"</span> : <span class="hljs-number">0</span>
  },
  <span class="hljs-attr">"hits"</span> : {
      <span class="hljs-attr">"total"</span> : <span class="hljs-number">0</span>,
      <span class="hljs-attr">"max_score"</span> : <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"hits"</span> : [ ]
  }
}
</code></pre>
      <p>
       这是因为在对文档建立索引时，会将北京奥运分词为
       <code>
        北京
       </code>
       ，
       <code>
        奥运
       </code>
       ，
       <code>
        北京奥运
       </code>
       ，只要搜索词为这三个之一，都可以将这篇文章搜索出来，而
       <code>
        京奥
       </code>
       和
       <code>
        北京奥
       </code>
       并不在分词集合里，所以无法搜索到该文档。
       <br/>
       如果对于某个字段，你想精确匹配，即搜索什么词匹配什么词，类似sql中的
       <code>
        =
       </code>
       操作，比如只能通过
       <code>
        北京奥运
       </code>
       搜索到文档3而不想让
       <code>
        北京
       </code>
       和
       <code>
        奥运
       </code>
       也搜索到，那么，你可以在建立索引阶段指定该字段为
       <code>
        "index": "not_analyzed"
       </code>
       ,此时，elasticsearch将不会对该字段的值进行分词操作，只保留全文字索引。比如本例子中的tags字段,我在建立索引时设置了
       <code>
        "index": "not_analyzed"
       </code>
       , 搜索时，不管是指定tags为
       <code>
        美
       </code>
       ，还是
       <code>
        国
       </code>
       ，都无法将第一条结果搜索出来
      </p>
      <pre><code class="language-php"><code class="php">$curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
  "query":{
    "term":{
        "tags":"美"
    }
  }
}'</span>
</code></code></pre>
      <p>
       搜索结果：
      </p>
      <pre class="hljs json"><code class="json">{
  <span class="hljs-attr">"took"</span> : <span class="hljs-number">1</span>,
  <span class="hljs-attr">"timed_out"</span> : <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"_shards"</span> : {
      <span class="hljs-attr">"total"</span> : <span class="hljs-number">5</span>,
      <span class="hljs-attr">"successful"</span> : <span class="hljs-number">5</span>,
      <span class="hljs-attr">"failed"</span> : <span class="hljs-number">0</span>
  },
  <span class="hljs-attr">"hits"</span> : {
      <span class="hljs-attr">"total"</span> : <span class="hljs-number">0</span>,
      <span class="hljs-attr">"max_score"</span> : <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"hits"</span> : [ ]
  }
}
</code></pre>
      <p>
       而全词
       <code>
        美国
       </code>
       却可以
      </p>
      <pre><code class="language-php"><code class="php">$curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
  "query":{
    "term":{
        "tags":"美国"
    }
  }
}'</span>
</code></code></pre>
      <p>
       搜索结果：
      </p>
      <pre class="hljs json"><code class="json">{
    <span class="hljs-attr">"took"</span> : <span class="hljs-number">2</span>,
    <span class="hljs-attr">"timed_out"</span> : <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"_shards"</span> : {
        <span class="hljs-attr">"total"</span> : <span class="hljs-number">5</span>,
        <span class="hljs-attr">"successful"</span> : <span class="hljs-number">5</span>,
        <span class="hljs-attr">"failed"</span> : <span class="hljs-number">0</span>
    },
    <span class="hljs-attr">"hits"</span> : {
        <span class="hljs-attr">"total"</span> : <span class="hljs-number">1</span>,
        <span class="hljs-attr">"max_score"</span> : <span class="hljs-number">0.30685282</span>,
        <span class="hljs-attr">"hits"</span> : [ {
            <span class="hljs-attr">"_index"</span> : <span class="hljs-string">"index"</span>,
            <span class="hljs-attr">"_type"</span> : <span class="hljs-string">"doc"</span>,
            <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"1"</span>,
            <span class="hljs-attr">"_score"</span> : <span class="hljs-number">0.30685282</span>,
            <span class="hljs-attr">"_source"</span> : {
                  <span class="hljs-attr">"content"</span> : <span class="hljs-string">"美国留给伊拉克的是个烂摊子吗"</span>,
                  <span class="hljs-attr">"title"</span> : <span class="hljs-string">"标题"</span>,
                  <span class="hljs-attr">"tags"</span> : [ <span class="hljs-string">"美国"</span>, <span class="hljs-string">"伊拉克"</span>, <span class="hljs-string">"烂摊子"</span> ]
            }
      } ]
  }
}
</code></pre>
      <h5>
       match类查询
      </h5>
      <p>
       match查询会先对搜索词进行分词,分词完毕后再逐个对分词结果进行匹配，因此相比于term的精确搜索，match是分词匹配搜索,match搜索还有两个相似功能的变种，一个是match_phrase，一个是multi_match，接下来详细介绍一下
      </p>
      <h6>
       match
      </h6>
      <p>
       前面提到match搜索会先对搜索词进行分词，对于最基本的match搜索来说，只要搜索词的分词集合中的一个或多个存在于文档中即可，例如，当我们搜索
       <code>
        中国杭州
       </code>
       ，搜索词会先分词为
       <code>
        中国
       </code>
       和
       <code>
        杭州
       </code>
       ,只要文档中包含
       <code>
        搜索
       </code>
       和
       <code>
        杭州
       </code>
       任意一个词，都会被搜索到
      </p>
      <pre><code class="language-php"><code class="php">$curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
    "query": {
        "match": {
            "content": "中国杭州"
        }
    }
}'</span>
</code></code></pre>
      <p>
       文档3正文中有杭州，文档2中有中国，因此搜索结果有两个，文档3中杭州出现两次，所以排在前面，结果如下：
      </p>
      <pre class="hljs json"><code class="json">{
  <span class="hljs-attr">"took"</span> : <span class="hljs-number">1</span>,
  <span class="hljs-attr">"timed_out"</span> : <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"_shards"</span> : {
    <span class="hljs-attr">"total"</span> : <span class="hljs-number">5</span>,
    <span class="hljs-attr">"successful"</span> : <span class="hljs-number">5</span>,
    <span class="hljs-attr">"failed"</span> : <span class="hljs-number">0</span>
  },
  <span class="hljs-attr">"hits"</span> : {
      <span class="hljs-attr">"total"</span> : <span class="hljs-number">2</span>,
      <span class="hljs-attr">"max_score"</span> : <span class="hljs-number">0.99999994</span>,
      <span class="hljs-attr">"hits"</span> : [ {
            <span class="hljs-attr">"_index"</span> : <span class="hljs-string">"index"</span>,
            <span class="hljs-attr">"_type"</span> : <span class="hljs-string">"doc"</span>,
            <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"4"</span>,
            <span class="hljs-attr">"_score"</span> : <span class="hljs-number">0.99999994</span>,
            <span class="hljs-attr">"_source"</span> : {
                 <span class="hljs-attr">"content"</span> : <span class="hljs-string">"杭州是一个美丽的城市,欢迎来到杭州"</span>,
                <span class="hljs-attr">"title"</span> : <span class="hljs-string">"宣传"</span>,
                <span class="hljs-attr">"tags"</span> : [ <span class="hljs-string">"旅游"</span>, <span class="hljs-string">"城市"</span> ]
            }
       }, {
            <span class="hljs-attr">"_index"</span> : <span class="hljs-string">"index"</span>,
            <span class="hljs-attr">"_type"</span> : <span class="hljs-string">"doc"</span>,
            <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"2"</span>,
            <span class="hljs-attr">"_score"</span> : <span class="hljs-number">0.8838835</span>,
            <span class="hljs-attr">"_source"</span> : {
                  <span class="hljs-attr">"content"</span> : <span class="hljs-string">"中国是世界上人口最多的国家"</span>,
                  <span class="hljs-attr">"title"</span> : <span class="hljs-string">"中国"</span>,
                  <span class="hljs-attr">"tags"</span> : [ <span class="hljs-string">"中国"</span>, <span class="hljs-string">"人口"</span> ]
            }
       } ]
    }
}
</code></pre>
      <p>
       同样的，我们用match的方式搜索
       <code>
        中国世界
       </code>
       ，那么，文档2(含有
       <code>
        中国
       </code>
       和
       <code>
        世界
       </code>
       )和文档3(含有
       <code>
        世界
       </code>
       都会被搜索出来)。如果我们仅仅想搜索
       <code>
        中国
       </code>
       和
       <code>
        世界
       </code>
       都包含的文档该怎么办呢？
       <br/>
       其实，对于match搜索，可以按照分词后的分词集合的
       <code>
        or
       </code>
       或者
       <code>
        and
       </code>
       进行匹配，默认为
       <code>
        or
       </code>
       ，这也是为什么我们看到前面的搜索都是只要有一个分词出现在文档中就会被搜索出来，同样的，如果我们希望是所有分词都要出现，那只要把匹配模式改成
       <code>
        and
       </code>
       就行了
      </p>
      <pre><code class="language-php"><code class="php">curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
    "query": {
        "match": {
            "content": {
                "query": "中国世界",
                "operator": "and"
            }
        }
    }
}'</span>
</code></code></pre>
      <p>
       如上所示，查询时将operator设置为
       <code>
        and
       </code>
       ，此时，就只会搜索到既包含中国，也包含世界的文档了(因返回的字段较多，后面搜索结果只展示_source中的内容)
      </p>
      <pre class="hljs bash"><code class="bash"><span class="hljs-string">"_source"</span> : {
    <span class="hljs-string">"content"</span> : <span class="hljs-string">"中国是世界上人口最多的国家"</span>,
    <span class="hljs-string">"title"</span> : <span class="hljs-string">"中国"</span>,
    <span class="hljs-string">"tags"</span> : [ <span class="hljs-string">"中国"</span>, <span class="hljs-string">"人口"</span> ]
}
</code></pre>
      <h6>
       match_phrase
      </h6>
      <p>
       match_phrase为按短语搜索，这个可能先用英文来解释会直观一点(中文分词后其实已经是一个一个有具体意思的词语)。英文中以空格分词，因此分词后是一个个的单词，当想搜索类似
       <code>
        hope so
       </code>
       这样的短语时，你或许并不想将一些只含有hope的文档搜索出来，也不想将一些类似
       <code>
        I hope ×××. So ××
       </code>
       这样的搜索出来，此时，就可以用match_phrase。
       <br/>
       match_phrase的搜索方式和match类似，先对搜索词建立索引，并要求所有分词必须在文档中出现(像不像operator为
       <code>
        and
       </code>
       的match查询)，除此之外，还必须满足分词在文档中出现的顺序和搜索词中一致且各搜索词之间必须
       <strong>
        紧邻
       </strong>
       ，因此match_phrase也可以叫做紧邻搜索。
       <br/>
       所以，当我们搜
       <code>
        美国留给
       </code>
       时
      </p>
      <pre><code class="language-php"><code class="php">curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
  "query": {
    "match_phrase": {
        "content": "美国留给"
    }
  }
}'</span>
</code></code></pre>
      <p>
       能搜出文档
       <code>
        美国留给伊拉克的是个烂摊子吗
       </code>
      </p>
      <pre class="hljs bash"><code class="bash">    <span class="hljs-string">"_source"</span> : {
        <span class="hljs-string">"content"</span> : <span class="hljs-string">"美国留给伊拉克的是个烂摊子吗"</span>,
        <span class="hljs-string">"title"</span> : <span class="hljs-string">"标题"</span>,
        <span class="hljs-string">"tags"</span> : [ <span class="hljs-string">"美国"</span>, <span class="hljs-string">"伊拉克"</span>, <span class="hljs-string">"烂摊子"</span> ]
    }
</code></pre>
      <p>
       但是我们搜索
       <code>
        留给美国
       </code>
       或
       <code>
        美国伊拉克
       </code>
       时，却没有搜索结果，因为一个顺序不对，一个不是紧邻(隔着
       <code>
        留给
       </code>
       )。
       <br/>
       紧邻对于匹配度要求较高，为了减小精度增加可操作性，引入了
       <code>
        slop
       </code>
       参数。该参数可以指定相隔多少个词仍被算作匹配成功。如下，
      </p>
      <pre><code class="language-php"><code class="php">curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
    "query": {
        "match_phrase": {
            "content": {
                "query": "美国伊拉克",
                "slop": "1"
            }
        }
    }
}'</span>
</code></code></pre>
      <p>
       当我们将
       <code>
        slop
       </code>
       设置为1时，文档1已能被搜索到。
      </p>
      <pre class="hljs bash"><code class="bash">  <span class="hljs-string">"_source"</span> : {
    <span class="hljs-string">"content"</span> : <span class="hljs-string">"美国留给伊拉克的是个烂摊子吗"</span>,
    <span class="hljs-string">"title"</span> : <span class="hljs-string">"标题"</span>,
    <span class="hljs-string">"tags"</span> : [ <span class="hljs-string">"美国"</span>, <span class="hljs-string">"伊拉克"</span>, <span class="hljs-string">"烂摊子"</span> ]
  }
</code></pre>
      <p>
       需要注意的是，当slop的值过大时(超出文档总分词数)，那么分词数据将可以是随意的，即跟operator为
       <code>
        and
       </code>
       的match查询效果一样。比如我们查询
      </p>
      <pre><code class="language-php"><code class="php">curl -XGET http:<span class="hljs-comment">//localhost:9200/index/doc/_search?pretty -d </span>
<span class="hljs-string">'{
    "query": {
        "match_phrase": {
            "content": {
                "query": "伊拉克美国",
                "slop": "12"
            }
        }
    }
}'</span>
</code></code></pre>
      <p>
       将会得到与上面一样的结果
      </p>
      <h6>
       multi_match
      </h6>
      <p>
       当我们想对多个字段进行匹配，其中一个字段包含分词就被文档就被搜索到时，可以用multi_match,这一部分内容我们后面再讲
      </p>
     </div>
     <br/>
     <br/>
     作者：木鸟飞鱼
     <br/>
     链接：https://www.jianshu.com/p/eb30eee13923
     <br/>
     來源：简书
     <br/>
     著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    </div>
    <br/>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f77656978696e5f3339383030313434:2f61727469636c652f64657461696c732f3830323537393732" class_="artid" style="display:none">
 </p>
</div>


