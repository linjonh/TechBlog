---
layout: post
title: "SpringBoot整合ElasticSearch实现多版本的兼容"
date: 2024-02-06 10:56:58 +0800
description: "前言在上一篇学习SpringBoot中，整合了Mybatis、Druid和PageHelper并实现"
keywords: "elasticsearch 该主版本下的一个兼容子版本"
categories: ['整合系列', 'Springboot', 'Springboot']
tags: ['Jestclient', 'Java', 'Elasticsearch', 'Boot']
artid: "80208495"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=80208495
    alt: "SpringBoot整合ElasticSearch实现多版本的兼容"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringBoot整合ElasticSearch实现多版本的兼容
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atelier-sulphurpool-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     前言
    </h3>
    <p>
     在
     <a href="http://www.panchengming.com/2018/04/27/pancm81/" rel="nofollow">
      上一篇
     </a>
     学习
     <strong>
      SpringBoot
     </strong>
     中，整合了Mybatis、Druid和PageHelper并实现了多数据源的操作。本篇主要是介绍和使用目前最火的搜索引擎
     <strong>
      ElastiSearch
     </strong>
     ，并和
     <strong>
      SpringBoot
     </strong>
     进行结合使用。
    </p>
    <h3>
     <a id="ElasticSearch_5">
     </a>
     ElasticSearch介绍
    </h3>
    <blockquote>
     <p>
      <strong>
       ElasticSearch
      </strong>
      是一个基于
      <strong>
       Lucene
      </strong>
      的搜索服务器，其实就是对
      <strong>
       Lucene
      </strong>
      进行封装，提供了 REST API 的操作接口
      <strong>
       ElasticSearch
      </strong>
      作为一个高度可拓展的开源全文搜索和分析引擎，可用于快速地对大数据进行存储，搜索和分析。
      <br/>
      <strong>
       ElasticSearch
      </strong>
      主要特点：分布式、高可用、异步写入、多API、面向文档 。
      <br/>
      <strong>
       ElasticSearch
      </strong>
      核心概念：近实时，集群，节点（保存数据），索引，分片（将索引分片），副本（分片可设置多个副本） 。它可以快速地储存、搜索和分析海量数据。
      <br/>
      <strong>
       ElasticSearch
      </strong>
      使用案例:维基百科、Stack Overflow、Github 等等。
     </p>
    </blockquote>
    <h3>
     <a id="SpringBootElasticsearch_14">
     </a>
     SpringBoot整合Elasticsearch
    </h3>
    <p>
     在使用
     <strong>
      SpringBoot
     </strong>
     整合
     <strong>
      Elasticsearch
     </strong>
     之前，我们应该了解下它们之间
     <a href="https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix">
      对应版本
     </a>
     的关系。
    </p>
    <table>
     <thead>
      <tr>
       <th align="center">
        Spring Boot Version (x)
       </th>
       <th align="center">
        Spring Data Elasticsearch Version (y)
       </th>
       <th align="center">
        Elasticsearch Version (z)
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        x &lt;= 1.3.5
       </td>
       <td align="center">
        y &lt;= 1.3.4
       </td>
       <td align="center">
        z &lt;= 1.7.2*
       </td>
      </tr>
      <tr>
       <td align="center">
        x &gt;= 1.4.x
       </td>
       <td align="center">
        2.0.0 &lt;=y &lt; 5.0.0**
       </td>
       <td align="center">
        2.0.0 &lt;= z &lt; 5.0.0**
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     这里我们使用的
     <strong>
      SpringBoot
     </strong>
     的版本是1.5.9，
     <strong>
      Elasticsearch
     </strong>
     的版本是2.3.5。
    </p>
    <p>
     使用
     <strong>
      SpringBoot
     </strong>
     整合
     <strong>
      Elasticsearch
     </strong>
     ，一般都是使用
     <strong>
      SpringData
     </strong>
     进行封装的，然后再dao层接口继承
     <strong>
      ElasticsearchRepository
     </strong>
     类，该类实现了很多的方法，比如常用的CRUD方法。
    </p>
    <h4>
     <a id="SpringData_31">
     </a>
     SpringData的使用
    </h4>
    <p>
     首先，在使用之前，先做好相关的准备。
    </p>
    <h5>
     <a id="Maven_35">
     </a>
     Maven的配置如下:
    </h5>
    <pre><code>&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
             &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
  &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;
             &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
    <h5>
     <a id="applicationproperties_49">
     </a>
     <strong>
      application.properties
     </strong>
     的配置
    </h5>
    <pre><code>spring.data.elasticsearch.repositories.enabled = true
spring.data.elasticsearch.cluster-nodes =127.0.0.1\:9300
</code></pre>
    <p>
     <strong>
      注: 9300 是 Java 客户端的端口。9200 是支持 Restful HTTP 的接口。
     </strong>
    </p>
    <p>
     更多的配置:
    </p>
    <pre><code>spring.data.elasticsearch.cluster-name Elasticsearch 集群名。(默认值: elasticsearch)
spring.data.elasticsearch.cluster-nodes 集群节点地址列表，用逗号分隔。如果没有指定，就启动一个客户端节点。
spring.data.elasticsearch.propertie 用来配置客户端的额外属性。
spring.data.elasticsearch.repositories.enabled 开启 Elasticsearch 仓库。(默认值:true。)
</code></pre>
    <h5>
     <a id="_65">
     </a>
     代码编写
    </h5>
    <p>
     <strong>
      实体类
     </strong>
    </p>
    <pre><code>@Document(indexName = "userindex", type = "user")
public class User implements Serializable{
	 /**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	/** 编号 */
	 private Long id;
	 /** 姓名 */
	 private String name;
	 
	 /** 年龄 */
	 private Integer age;
	 
	 /** 描述 */  
	 private String description;
	 
	 /** 创建时间 */
	 private String createtm;

	// getter和setter 略
｝	 

</code></pre>
    <p>
     使用
     <strong>
      SpringData
     </strong>
     的时候，它需要在实体类中设置
     <strong>
      indexName
     </strong>
     和
     <strong>
      type
     </strong>
     ，如果和传统型数据库比较的话，就相当于
     <strong>
      库
     </strong>
     和
     <strong>
      表
     </strong>
     。需要注意的是
     <strong>
      indexName
     </strong>
     和
     <strong>
      type
     </strong>
     都必须是小写!!!
    </p>
    <p>
     <strong>
      dao层
     </strong>
    </p>
    <pre><code>public interface UserDao extends ElasticsearchRepository&lt;User, Long&gt;{
}
</code></pre>
    <p>
     dao层这里就比较简单了，只需继承
     <strong>
      ElasticsearchRepository
     </strong>
     该类就行了。其中主要的方法就是 save、delete和search。其中save方法相当如insert和update，没有就新增，有就覆盖。delete方法主要就是删除数据以及索引库。至于search就是查询了，包括一些常用的查询，如分页、权重之类的。
    </p>
    <p>
     <strong>
      Service层
     </strong>
    </p>
    <pre><code>@Service
public class UserServiceImpl implements UserService {
	@Autowired
    private UserDao userDao;
	@Override
	public boolean insert(User user) {
		boolean falg=false;
		try{
			userDao.save(user);
			falg=true;
		}catch(Exception e){
			e.printStackTrace();
		}
		return falg;
	}

	@Override
	public List&lt;User&gt; search(String searchContent) {
		  QueryStringQueryBuilder builder = new QueryStringQueryBuilder(searchContent);
		  System.out.println("查询的语句:"+builder);
          Iterable&lt;User&gt; searchResult = userDao.search(builder);
          Iterator&lt;User&gt; iterator = searchResult.iterator();
          List&lt;User&gt; list=new ArrayList&lt;User&gt;();
          while (iterator.hasNext()) {
       	   	list.add(iterator.next());
          }
       return list;
	}
	
	
	
	@Override
	public List&lt;User&gt; searchUser(Integer pageNumber, Integer pageSize,String searchContent) {
		 // 分页参数
        Pageable pageable = new PageRequest(pageNumber, pageSize);
        QueryStringQueryBuilder builder = new QueryStringQueryBuilder(searchContent);
        SearchQuery searchQuery = new NativeSearchQueryBuilder().withPageable(pageable).withQuery(builder).build();
        System.out.println("查询的语句:" + searchQuery.getQuery().toString());
        Page&lt;User&gt; searchPageResults = userDao.search(searchQuery);
        return searchPageResults.getContent();
	}
	

	@Override
	public List&lt;User&gt; searchUserByWeight(String searchContent) {
	 // 根据权重进行查询
        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()
                .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery("name", searchContent)),
                    ScoreFunctionBuilders.weightFactorFunction(10))
                .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery("description", searchContent)),
                        ScoreFunctionBuilders.weightFactorFunction(100)).setMinScore(2);
        System.out.println("查询的语句:" + functionScoreQueryBuilder.toString());
        Iterable&lt;User&gt; searchResult = userDao.search(functionScoreQueryBuilder);
        Iterator&lt;User&gt; iterator = searchResult.iterator();
        List&lt;User&gt; list=new ArrayList&lt;User&gt;();
        while (iterator.hasNext()) {
     	   	list.add(iterator.next());
        }
        return list;
	}
}
</code></pre>
    <p>
     这里我就简单的写了几个方法，其中主要的方法是查询。查询包括全文搜索，分页查询和权重查询。其中需要说明的是权重查询这块，权重的分值越高，查询的结果也越靠前，如果没有对其它的数据设置分值，它们默认的分值就是1，如果不想查询这些语句，只需使用
     <strong>
      setMinScore
     </strong>
     将其设为大于1即可。
    </p>
    <p>
     <strong>
      代码测试
     </strong>
    </p>
    <p>
     调用接口进行添加数据
    </p>
    <p>
     新增数据:
    </p>
    <pre><code>POST http://localhost:8086/api/user

{"id":1,"name":"张三","age":20,"description":"张三是个Java开发工程师","createtm":"2018-4-25 11:07:42"}
{"id":2,"name":"李四","age":24,"description":"李四是个测试工程师","createtm":"1980-2-15 19:01:32"}
{"id":3,"name":"王五","age":25,"description":"王五是个运维工程师","createtm":"2016-8-21 06:11:32"}
</code></pre>
    <p>
     <strong>
      进行全文查询
     </strong>
     <br/>
     请求
    </p>
    <pre><code>http://localhost:8086/api/user?searchContent=工程师
</code></pre>
    <p>
     返回
    </p>
    <pre><code>[{"id":2,"name":"李四","age":14,"description":"李四是个测试工程师","createtm": "1980-2-15 19:01:32"},
{"id":1,"name":"张三","age":20,"description":"张三是个Java开发工程师", "createtm": "2018-4-25 11:07:42"},
{"id":3,"name":"王五","age":25,"description":"王五是个运维工程师","createtm": "2016-8-21 06:11:32"}]
</code></pre>
    <p>
     <strong>
      进行分页查询
     </strong>
     <br/>
     请求
    </p>
    <pre><code>http://localhost:8086/api/user?pageNumber=0&amp;pageSize=2&amp;searchContent=工程师
</code></pre>
    <p>
     返回
    </p>
    <pre><code>[{"id":2,"name":"李四","age":14,"description":"李四是个测试工程师"},{"id":1,"name":"张三","age":20,"description":"张三是个Java开发工程师"}]
</code></pre>
    <p>
     <strong>
      进行权重查询
     </strong>
     <br/>
     请求
    </p>
    <pre><code>http://localhost:8086/api/user2?searchContent=李四
</code></pre>
    <p>
     返回
    </p>
    <pre><code>[{"id":2,"name":"李四","age":24,"description":"李四是个测试工程师","createtm":"1980-2-15 19:01:32"}]
</code></pre>
    <p>
     权重查询打印的语句:
    </p>
    <pre><code>查询的语句:{<!-- -->{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "bool" : {
          "should" : {
            "match" : {
              "name" : {
                "query" : "李四",
                "type" : "boolean"
              }
            }
          }
        }
      },
      "weight" : 10.0
    }, {
      "filter" : {
        "bool" : {
          "should" : {
            "match" : {
              "description" : {
                "query" : "李四",
                "type" : "boolean"
              }
            }
          }
        }
      },
      "weight" : 100.0
    } ],
    "min_score" : 2.0
  }
}

</code></pre>
    <p>
     <strong>
      注:测试中，因为设置了setMinScore最小权重分为2的，所以无关的数据是不会显示出来的。如果想显示的话，在代码中去掉即可。
     </strong>
    </p>
    <p>
     新增完数据之后，可以在浏览器输入:
     <a href="http://localhost:9200/_plugin/head/" rel="nofollow">
      http://localhost:9200/_plugin/head/
     </a>
     <br/>
     然后点击基本查询，便可以查看添加的数据。如果想用语句查询，可以将程序中控制台打印的查询语句粘贴到查询界面上进行查询!
     <br/>
     <img alt="这里写图片描述" src="//img-blog.csdn.net/20180506132924277?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </p>
    <p>
     <strong>
      注:这里的ElasticSearch是我在windows上安装的，并安装了ES插件head，具体安装步骤在文章末尾。
     </strong>
    </p>
    <p>
     除了SpringData之外，其实还有其它的方法操作
     <strong>
      ElasticSearch
     </strong>
     的。
     <br/>
     比如使用原生
     <strong>
      ElasticSearch
     </strong>
     的Api，使用
     <strong>
      TransportClient
     </strong>
     类实现。
     <br/>
     或者使用由Spring封装，只需在Service层，进行注入Bean即可。
     <br/>
     示例:
    </p>
    <pre><code>@Autowired
 ElasticsearchTemplate elasticsearchTemplate; 
</code></pre>
    <p>
     但是，上述方法中都有其局限性，也就是随着
     <strong>
      ElasticSearch
     </strong>
     的版本变更，相关的Java API也在做不断的调整，就是
     <strong>
      ElasticSearch
     </strong>
     服务端版本进行更改之后，客户端的代码可能需要重新编写。
     <br/>
     因此介绍一个相当好用的第三方工具
     <strong>
      JestClient
     </strong>
     ，它对
     <strong>
      ElasticSearch
     </strong>
     进行封装，填补了
     <strong>
      ElasticSearch
     </strong>
     HttpRest接口 客户端的空白，它适用于
     <strong>
      ElasticSearch
     </strong>
     2.x以上的版本，无需因为
     <strong>
      ElasticSearch
     </strong>
     服务端版本更改而对代码进行更改！
    </p>
    <h4>
     <a id="JestClient_287">
     </a>
     JestClient
    </h4>
    <p>
     首先在Maven中添加如下依赖:
    </p>
    <pre><code>	&lt;dependency&gt;
    	&lt;groupId&gt;io.searchbox&lt;/groupId&gt; 
   		 &lt;artifactId&gt;jest&lt;/artifactId&gt;
    	&lt;version&gt;5.3.3&lt;/version&gt;
	&lt;/dependency&gt;
</code></pre>
    <p>
     然后编写相关的测试代码。
     <br/>
     代码中的注释应该很完整，所以这里就不再对代码过多的讲述了。
    </p>
    <pre><code>import java.util.ArrayList;
import java.util.List;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import com.pancm.pojo.User;
import io.searchbox.client.JestClient;
import io.searchbox.client.JestClientFactory;
import io.searchbox.client.JestResult;
import io.searchbox.client.config.HttpClientConfig;
import io.searchbox.core.Bulk;
import io.searchbox.core.BulkResult;
import io.searchbox.core.Delete;
import io.searchbox.core.DocumentResult;
import io.searchbox.core.Index;
import io.searchbox.core.Search;
import io.searchbox.indices.CreateIndex;
import io.searchbox.indices.DeleteIndex;
import io.searchbox.indices.mapping.GetMapping;
import io.searchbox.indices.mapping.PutMapping;

public class JestTest {  
	    private static JestClient jestClient;  
	    private static String indexName = "userindex";  
//	    private static String indexName = "userindex2";  
	    private static String typeName = "user";  
	    private static String elasticIps="http://192.169.2.98:9200";
//	    private static String elasticIps="http://127.0.0.1:9200";
		
	    
	    public static void main(String[] args) throws Exception {
	        jestClient = getJestClient();  
	        insertBatch();
	        serach1();
	        serach2();
	        serach3();
	        jestClient.close();  
	        
		}
	    
	    private static  JestClient getJestClient() {  
	    	JestClientFactory factory = new JestClientFactory();  
			factory.setHttpClientConfig(new HttpClientConfig.Builder(elasticIps).connTimeout(60000).readTimeout(60000).multiThreaded(true).build());  
	        return factory.getObject();  
	    }  
	    
	    public static void insertBatch() {
			List&lt;Object&gt; objs = new ArrayList&lt;Object&gt;();
			objs.add(new User(1L, "张三", 20, "张三是个Java开发工程师","2018-4-25 11:07:42"));
			objs.add(new User(2L, "李四", 24, "李四是个测试工程师","1980-2-15 19:01:32"));
			objs.add(new User(3L, "王五", 25, "王五是个运维工程师","2016-8-21 06:11:32"));
			boolean result = false;
			try {
				result = insertBatch(jestClient,indexName, typeName,objs);
			} catch (Exception e) {
				e.printStackTrace();
			}
			System.out.println("批量新增:"+result);
		}
	    
	    
	    /**
	     * 全文搜索
	     */
	    public static void serach1() {
			String query ="工程师";
			try {
				SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); 
		    	 searchSourceBuilder.query(QueryBuilders.queryStringQuery(query)); 
		    	 //分页设置
		    	 searchSourceBuilder.from(0).size(2); 
		        System.out.println("全文搜索查询语句:"+searchSourceBuilder.toString());
				System.out.println("全文搜索返回结果:"+search(jestClient,indexName, typeName, searchSourceBuilder.toString()));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	    
	    /**
	     * 精确搜索
	     */
	    public static void serach2() {
			try {
				SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); 
		    	searchSourceBuilder.query(QueryBuilders.termQuery("age", 24)); 
		    	System.out.println("精确搜索查询语句:"+searchSourceBuilder.toString());
				System.out.println("精确搜索返回结果:"+search(jestClient,indexName, typeName, searchSourceBuilder.toString()));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	    
	    
	    /**
	     * 区间搜索
	     */
	    public static void serach3() {
			String createtm="createtm";
			String from="2016-8-21 06:11:32";
			String to="2018-8-21 06:11:32";
			
			try {
				SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); 
		    	searchSourceBuilder.query(QueryBuilders.rangeQuery(createtm).gte(from).lte(to)); 
		    	System.out.println("区间搜索语句:"+searchSourceBuilder.toString());
				System.out.println("区间搜索返回结果:"+search(jestClient,indexName, typeName, searchSourceBuilder.toString()));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	    
	    
	    /**
	     * 创建索引
	     * @param indexName
	     * @return
	     * @throws Exception
	     */
	    public boolean createIndex(JestClient jestClient,String indexName) throws Exception {  
	        JestResult jr = jestClient.execute(new CreateIndex.Builder(indexName).build());  
	        return jr.isSucceeded();  
	    }  
	      
	    /**
	     * 新增数据
	     * @param indexName
	     * @param typeName
	     * @param source
	     * @return
	     * @throws Exception
	     */
	    public boolean insert(JestClient jestClient,String indexName, String typeName, String source) throws Exception {  
	        PutMapping putMapping = new PutMapping.Builder(indexName, typeName, source).build();  
	        JestResult jr = jestClient.execute(putMapping);  
	        return jr.isSucceeded();  
	    }  
	      
	    
	     /**
	      * 查询数据
	      * @param indexName
	      * @param typeName
	      * @return
	      * @throws Exception
	      */
	    public static String getIndexMapping(JestClient jestClient,String indexName, String typeName) throws Exception {  
	        GetMapping getMapping = new GetMapping.Builder().addIndex(indexName).addType(typeName).build();  
	        JestResult jr =jestClient.execute(getMapping);  
	        return jr.getJsonString();  
	     }  
	      
	    
	    
	   /**
	    * 批量新增数据
	    * @param indexName
	    * @param typeName
	    * @param objs
	    * @return
	    * @throws Exception
	    */
	    public static boolean insertBatch(JestClient jestClient,String indexName, String typeName, List&lt;Object&gt; objs) throws Exception {  
	        Bulk.Builder bulk = new Bulk.Builder().defaultIndex(indexName).defaultType(typeName);  
	        for (Object obj : objs) {  
	            Index index = new Index.Builder(obj).build();  
	             bulk.addAction(index);  
	        }  
	        BulkResult br = jestClient.execute(bulk.build());  
	        return br.isSucceeded();  
	       }  
	      
	    /**
	     * 全文搜索
	     * @param indexName
	     * @param typeName
	     * @param query
	     * @return
	     * @throws Exception
	     */
	    public static String search(JestClient jestClient,String indexName, String typeName, String query) throws Exception {  
	    	 Search search = new Search.Builder(query)
	    	 .addIndex(indexName)
	    	 .addType(typeName)  
	    	 .build(); 
	        JestResult jr = jestClient.execute(search);  
//	        System.out.println("--"+jr.getJsonString());
//	        System.out.println("--"+jr.getSourceAsObject(User.class));
	        return jr.getSourceAsString();  
	     }  
	      
	      
	    
	   
	      
	   /**
	    * 删除索引
	    * @param indexName
	    * @return
	    * @throws Exception
	    */
	    public boolean delete(JestClient jestClient,String indexName) throws Exception {  
	        JestResult jr = jestClient.execute(new DeleteIndex.Builder(indexName).build());  
	        return jr.isSucceeded();  
	    }  
	      
	   /**
	    * 删除数据
	    * @param indexName
	    * @param typeName
	    * @param id
	    * @return
	    * @throws Exception
	    */
	    public boolean delete(JestClient jestClient,String indexName, String typeName, String id) throws Exception {  
	        DocumentResult dr = jestClient.execute(new Delete.Builder(id).index(indexName).type(typeName).build());  
	        return dr.isSucceeded();  
	    }  
</code></pre>
    <p>
     <strong>
      注:测试之前先说明下，本地windows系统安装的是ElasticSearch版本是2.3.5，linux服务器上安装的ElasticSearch版本是6.2。
     </strong>
    </p>
    <h5>
     <a id="_524">
     </a>
     测试结果
    </h5>
    <p>
     <strong>
      全文搜索
     </strong>
    </p>
    <pre><code>全文搜索查询语句:{
  "from" : 0,
  "size" : 2,
  "query" : {
    "query_string" : {
      "query" : "工程师"
    }
  }
}

全文搜索返回结果:{"id":1,"name":"张三","age":20,"description":"张三是个Java开发工程师","createtm":"2018-4-25 11:07:42"},{"id":2,"name":"李四","age":24,"description":"李四是个测试工程师","createtm":"1980-2-15 19:01:32"}
</code></pre>
    <p>
     <strong>
      匹配搜索
     </strong>
    </p>
    <pre><code>精确搜索查询语句:{
  "query" : {
    "term" : {
      "age" : 24
    }
  }
}

精确搜索返回结果:{"id":2,"name":"李四","age":24,"description":"李四是个测试工程师","createtm":"1980-2-15 19:01:32"}
</code></pre>
    <p>
     <strong>
      时间区间搜索
     </strong>
    </p>
    <pre><code>区间搜索语句:{
  "query" : {
    "range" : {
      "createtm" : {
        "from" : "2016-8-21 06:11:32",
        "to" : "2018-8-21 06:11:32",
        "include_lower" : true,
        "include_upper" : true
      }
    }
  }
}
区间搜索返回结果:{"id":1,"name":"张三","age":20,"description":"张三是个Java开发工程师","createtm":"2018-4-25 11:07:42"}
</code></pre>
    <p>
     新增完数据之后，我们可以上linux的
     <strong>
      Kibana
     </strong>
     中进行相关的查询，查询结果如下:
    </p>
    <p>
     <img alt="这里写图片描述" src="//img-blog.csdn.net/20180507083027751?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </p>
    <p>
     <strong>
      注:Kibana 是属于ELK中一个开源软件。Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。
     </strong>
    </p>
    <p>
     上述代码中测试返回的结果符合我们的预期。其中关于JestClient只是用到了很少的一部分，更多的使用可以查看JestClient的官方文档。
    </p>
    <h3>
     <a id="WindowsElasticSearch_588">
     </a>
     Windows安装ElasticSearch
    </h3>
    <p>
     1，文件准备
     <br/>
     下载地址:
     <br/>
     <a href="https://www.elastic.co/downloads" rel="nofollow">
      https://www.elastic.co/downloads
     </a>
     <br/>
     选择ElasticSearch相关版本， 然后选择后缀名为ZIP文件进行下载，下载之后进行解压。
    </p>
    <p>
     2，启动Elasticsearch
     <br/>
     进入bin目录下，运行 elasticsearch.bat
     <br/>
     然后在浏览上输入: localhost:9200
     <br/>
     成功显示一下界面表示成功！
     <br/>
     <img alt="这里写图片描述" src="//img-blog.csdn.net/20180506141939952?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </p>
    <p>
     3，安装ES插件
     <br/>
     web管理界面head 安装
     <br/>
     进入bin目录下，打开cmd，进入dos界面
     <br/>
     输入:
     <code>
      plugin install mobz/elasticsearch-head
     </code>
     <br/>
     进行下载
     <br/>
     成功下载之后，在浏览器输入：
     <a href="http://localhost:9200/_plugin/head/" rel="nofollow">
      http://localhost:9200/_plugin/head/
     </a>
     <br/>
     若显示一下界面，则安装成功!
     <br/>
     <img alt="这里写图片描述" src="//img-blog.csdn.net/20180506142010212?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </p>
    <p>
     4，注册服务
     <br/>
     进入bin目录下，打开cmd，进入dos界面
     <br/>
     依次输入:
     <br/>
     service.bat install
     <br/>
     service.bat start
     <br/>
     成功之后，再输入
     <br/>
     services.msc
     <br/>
     跳转到Service服务界面，可以直接查看es的运行状态!
    </p>
    <h3>
     <a id="_620">
     </a>
     其它
    </h3>
    <p>
     ElasticSearch官网API地址：
     <br/>
     <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/2.3/index.html" rel="nofollow">
      https://www.elastic.co/guide/en/elasticsearch/client/java-api/2.3/index.html
     </a>
    </p>
    <p>
     JestClientGithub地址：
     <br/>
     <a href="https://github.com/searchbox-io/Jest">
      https://github.com/searchbox-io/Jest
     </a>
    </p>
    <p>
     项目我放到github上面去了。
     <br/>
     <a href="https://github.com/xuwujing/springBoot">
      https://github.com/xuwujing/springBoot
     </a>
    </p>
    <p>
     ------------- 分割线 2019-06-19 ---------------------
    </p>
    <p>
     最新看到评论说SpringBoot官方整合的
     <strong>
      Elasticsearch
     </strong>
     版本太低了，查看官网发现，如果想在SpringBoot中想使用更高的
     <strong>
      Elasticsearch
     </strong>
     版本，可以使用 spring-data-elasticsearch 这个spring的架包，它们版本的对应关系如下:
    </p>
    <table>
     <thead>
      <tr>
       <th align="center">
        Spring Data Elasticsearch
       </th>
       <th align="center">
        Elasticsearch Version (z)
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        3.2.x
       </td>
       <td align="center">
        6.7.2
       </td>
      </tr>
      <tr>
       <td align="center">
        3.1.x
       </td>
       <td align="center">
        6.2.2
       </td>
      </tr>
      <tr>
       <td align="center">
        3.0.x
       </td>
       <td align="center">
        5.5.0
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     官网地址:
     <a href="https://github.com/spring-projects/spring-data-elasticsearch">
      https://github.com/spring-projects/spring-data-elasticsearch
     </a>
     <br/>
     对应的SpringBoot2.x整合ElasticSearch项目地址:
     <a href="https://github.com/xuwujing/springBoot-study/tree/master/springboot2-elasticsearch">
      https://github.com/xuwujing/springBoot-study/tree/master/springboot2-elasticsearch
     </a>
    </p>
    <p>
     如果觉得不错，希望顺便给个star。
     <br/>
     到此，本文结束，谢谢阅读。
    </p>
    <p>
     版权声明:
     <br/>
     作者：虚无境
     <br/>
     博客园出处：
     <a href="http://www.cnblogs.com/xuwujing" rel="nofollow">
      http://www.cnblogs.com/xuwujing
     </a>
     <br/>
     CSDN出处：
     <a href="http://blog.csdn.net/qazwsxpcm">
      http://blog.csdn.net/qazwsxpcm
     </a>
     <br/>
     个人博客出处：
     <a href="http://www.panchengming.com" rel="nofollow">
      http://www.panchengming.com
     </a>
     <br/>
     原创不易，转载请标明出处，谢谢！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f71617a77737870636d:2f61727469636c652f64657461696c732f3830323038343935" class_="artid" style="display:none">
 </p>
</div>


