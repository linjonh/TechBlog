---
layout: post
title: "Java客户端调用Websocket服务端,基于Springboot"
date: 2024-12-31 15:28:48 +0800
description: "目录WebSocket服务端\t\t创建Springboot工程，引入WebSocket依赖\t\t配置We"
keywords: "java作为client 调用websocket接口"
categories: ["未分类"]
tags: ["Websocket", "Spring", "Boot"]
artid: "114027148"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=114027148
  alt: "Java客户端调用Websocket服务端,基于Springboot"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java客户端调用Websocket服务端，基于Springboot
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="-toc" style="margin-left:80px;">
    </p>
    <p id="WebSocket%E6%9C%8D%E5%8A%A1%E7%AB%AF-toc" style="margin-left:0px;">
     <a href="#WebSocket%E6%9C%8D%E5%8A%A1%E7%AB%AF" rel="nofollow">
      WebSocket服务端
     </a>
    </p>
    <p id="%E5%88%9B%E5%BB%BASpringboot%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%BC%95%E5%85%A5WebSocket%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;">
     <a href="#%E5%88%9B%E5%BB%BASpringboot%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%BC%95%E5%85%A5WebSocket%E4%BE%9D%E8%B5%96" rel="nofollow">
      创建Springboot工程，引入WebSocket依赖
     </a>
    </p>
    <p id="%E9%85%8D%E7%BD%AEWebSocketConfig-toc" style="margin-left:40px;">
     <a href="#%E9%85%8D%E7%BD%AEWebSocketConfig" rel="nofollow">
      配置WebSocketConfig
     </a>
    </p>
    <p id="%E9%85%8D%E7%BD%AEWebSocketServer-toc" style="margin-left:40px;">
     <a href="#%E9%85%8D%E7%BD%AEWebSocketServer" rel="nofollow">
      配置WebSocketServer
     </a>
    </p>
    <p id="Java%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:0px;">
     <a href="#Java%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">
      Java客户端
     </a>
    </p>
    <p id="%E5%88%9B%E5%BB%BASpringboot%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%BC%95%E5%85%A5java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;">
     <a href="#%E5%88%9B%E5%BB%BASpringboot%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%BC%95%E5%85%A5java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%9D%E8%B5%96" rel="nofollow">
      创建Springboot工程，引入java客户端依赖
     </a>
    </p>
    <p id="%E9%85%8D%E7%BD%AEJavaClient-toc" style="margin-left:40px;">
     <a href="#%E9%85%8D%E7%BD%AEJavaClient" rel="nofollow">
      配置JavaClient
     </a>
    </p>
    <p id="%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px;">
     <a href="#%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5" rel="nofollow">
      创建连接
     </a>
    </p>
    <p id="%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C-toc" style="margin-left:40px;">
     <a href="#%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C" rel="nofollow">
      测试效果
     </a>
    </p>
    <hr id="hr-toc"/>
    <h2 id="WebSocket%E6%9C%8D%E5%8A%A1%E7%AB%AF">
     <a name="t1">
     </a>
     <a id="WebSocket_1">
     </a>
     WebSocket服务端
    </h2>
    <p>
     简单说一下WebSocket，本身就是一种基于TCP的有状态的双向通信协议，可以实现即时通讯、消息推送等需要长连接的业务场景。
    </p>
    <h3 id="%E5%88%9B%E5%BB%BASpringboot%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%BC%95%E5%85%A5WebSocket%E4%BE%9D%E8%B5%96">
     <a name="t2">
     </a>
     <a id="SpringbootWebSocket_3">
     </a>
     创建Springboot工程，引入WebSocket依赖
    </h3>
    <p>
     本示例引入的pom依赖如下：
    </p>
    <pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
    <h3 id="%E9%85%8D%E7%BD%AEWebSocketConfig">
     配置WebSocketConfig
    </h3>
    <p>
     代码如下
    </p>
    <pre><code class="language-java">package com.websocket.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/\*\*

- WebSocket 配置类
- @author Neo
  \*/
  @Configuration
  public class WebSocketConfig {

      @Bean
      public ServerEndpointExporter serverEndpointExporter(){

          return new ServerEndpointExporter();

      }

  }</code></pre>
  <h3 id="%E9%85%8D%E7%BD%AEWebSocketServer">
  配置 WebSocketServer
  </h3>
  <p>
  代码如下
  </p>
  <pre><code class="language-java">package com.websocket.server;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.websocket.\*;
import javax.websocket.server.ServerEndpoint;
import java.io.IOException;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.atomic.AtomicInteger;

/\*\*

- WebSocket 服务类
- @author Neo
  \*/
  @Slf4j
  @ServerEndpoint(value = "/ws/server")
  @Component
  public class WebSocketServer {

      //存储每一个客户端会话信息的线程安全的集合
      private static final CopyOnWriteArraySet&lt;Session&gt; sessions = new CopyOnWriteArraySet&lt;&gt;();
      //使用线程安全的计数器，记录在线数
      private static final AtomicInteger onlineCount = new AtomicInteger(0);

      /**
       * 连接成功时调用的方法
       * @param session
       */
      @OnOpen
      public void onOpen(Session session) {
          //存储会话信息
          sessions.add(session);
          //计数+1
          int cnt = onlineCount.incrementAndGet();
          //打印日志
          log.info("有连接加入，当前连接数为：" + cnt);
          //给客户端发消息
          this.sendMessage(session, "连接成功");
      }

      /**
       * 连接关闭时调用的方法
       * @param session
       */
      @OnClose
      public void onClose(Session session) {
          //删除会话信息
          sessions.remove(session);
          //计数-1
          int cnt = onlineCount.decrementAndGet();
          //打印日志
          log.info("有连接关闭，当前连接数为：" + cnt);
      }

      /**
       * 收到客户端消息时调用的方法
       * @param message
       * @param session
       */
      @OnMessage
      public void onMessage(String message, Session session) {
          //打印日志
          log.info("来自客户端的消息：" + message);
          //给客户端发消息
          this.sendMessage(session, "收到消息，消息内容：" + message);
      }

      /**
       * 出现异常时调用的方法
       * @param session
       * @param error
       */
      @OnError
      public void onError(Session session, Throwable error) {
          //打印日志
          log.error("发生错误：Session ID：" + error.getMessage() + session.getId());
      }

      /**
       * 发送消息
       * @param session
       * @param message
       */
      public void sendMessage(Session session, String message) {
          try {
              //发送消息
              session.getBasicRemote().sendText("SID:::" + session.getId() + ":::" + message);
          } catch (IOException e) {
              //打印日志
              log.error("发送消息出错：" + e.getMessage());
          }
      }

      /**
       * 群发消息
       * 这个方法可以升级为消息推送的工具，给在线的客户端弹个广告啥的
       * @param message
       * @throws IOException
       */
      public void sendMessage(String message) throws IOException {
          for (Session session : sessions) {
              //判断连接是否开着
              if(session.isOpen()){
                  //一个一个发
                  this.sendMessage(session, message);
              }
          }
      }

      /**
       * 给指定的客户端发消息
       * 这个方法可以升级为即时通讯的工具，例如客户端A、客户端B、服务端WS
       * 首先，客户端要有身份id与WS的session进行绑定
       * 然后，A要给B发送消息，先获取B的身份id，然后将消息和B的身份id发给WS
       * WS收到A的消息后，拿着B的身份id去查询B与WS的会话信息，找到了，就把A的消息发送给B
       * @param sessionId
       * @param message
       * @throws IOException
       */
      public void sendMessage(String sessionId,String message) throws IOException {
          Session session = null;
          //遍历找会话信息
          for (Session s : sessions) {
              if(s.getId().equals(sessionId)){
                  session = s;
                  break;
              }
          }
          if(session!=null){
              //找到了，发消息
              this.sendMessage(session, message);
          } else{
              //打印日志
              log.warn("没有找到指定的会话：" + sessionId);
          }
      }

  }</code></pre>
  <p>
  到这里，WebSocket 的服务端就配置完成了。
  </p>
  <h2 id="Java%E5%AE%A2%E6%88%B7%E7%AB%AF">
  <a name="t5">
  </a>
  <a id="Java_195">
  </a>
  Java 客户端
  </h2>
  <p>
  这里的 java 客户端，其实就是用 java 代码，去建立与 websocket 服务端连接的，java 工程
  </p>
  <h3 id="%E5%88%9B%E5%BB%BASpringboot%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%BC%95%E5%85%A5java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%9D%E8%B5%96">
  <a name="t6">
  </a>
  <a id="Springbootjava_197">
  </a>
  创建 Springboot 工程，引入 java 客户端依赖
  </h3>
  <p>
  pom 依赖如下：
  </p>
  <pre><code class="language-XML">&lt;dependencies&gt;
  &lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
  &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;
  &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;
  &lt;version&gt;1.4.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;/dependencies&gt;</code></pre>
  <h3 id="%E9%85%8D%E7%BD%AEJavaClient">
  配置 JavaClient
  </h3>
  <p>
  代码如下：
  </p>
  <pre><code class="language-java">package com.websocket.javaclient;

import lombok.extern.slf4j.Slf4j;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.drafts.Draft_6455;
import org.java_websocket.handshake.ServerHandshake;
import org.springframework.stereotype.Component;

import java.net.URI;
import java.net.URISyntaxException;

@Slf4j
@Component
public class JavaClient {

    /**
     * 获取客户端连接实例
     * @param uri
     * @return
     */
    public WebSocketClient getClient(String uri){

        try {

            //创建客户端连接对象
            WebSocketClient client = new WebSocketClient(new URI(uri),new Draft_6455()) {

                /**
                 * 建立连接调用
                 * @param serverHandshake
                 */
                @Override
                public void onOpen(ServerHandshake serverHandshake) {
                    log.info("建立连接");
                }

                /**
                 * 收到服务端消息调用
                 * @param s
                 */
                @Override
                public void onMessage(String s) {
                    log.info("收到来自服务端的消息:::" + s);
                }

                /**
                 * 断开连接调用
                 * @param i
                 * @param s
                 * @param b
                 */
                @Override
                public void onClose(int i, String s, boolean b) {
                    log.info("关闭连接:::" + "i = " + i + ":::s = " + s +":::b = " + b);
                }

                /**
                 * 连接报错调用
                 * @param e
                 */
                @Override
                public void onError(Exception e) {
                    log.error("报错了:::" + e.getMessage());
                }

            };

            //请求与服务端建立连接
            client.connect();

            //判断连接状态，0为请求中  1为已建立  其它值都是建立失败
            while(client.getReadyState().ordinal() == 0){

                try {

                    Thread.sleep(200);

                }catch (Exception e){

                    log.warn("延迟操作出现问题，但并不影响功能");

                }

                log.info("连接中。。。");

            }

            //连接状态不再是0请求中，判断建立结果是不是1已建立
            if (client.getReadyState().ordinal() == 1){

                return client;

            }

        }catch (URISyntaxException e){

            log.error(e.getMessage());
        }

        return null;
    }

}</code></pre>
<h3 id="%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5">
创建连接
</h3>
<p>
这里创建连接的方式采用了 web 接口访问的方式，其实可以直接用 main 函数跑，没办法，web 职业病
<br/>
代码如下：
</p>
<pre><code class="language-java">package com.websocket.controller;

import com.websocket.javaclient.JavaClient;
import org.java_websocket.client.WebSocketClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(value = "/jc")
public class JavaClientController {

    @Autowired
    private JavaClient javaClient;

    @GetMapping(value = "hello")
    public void hello(String str){

        WebSocketClient client = this.javaClient.getClient("ws://localhost:8080/ws/server");

        if (client != null){

            client.send(str);

        }

    }

}</code></pre>
<h3 id="%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">
测试效果
</h3>
<p>
测试 1：
</p>
<p>
<img alt="" height="176" src="https://i-blog.csdnimg.cn/blog_migrate/bb6a613cc84bddbd04017cde2a6bdbcb.png" width="995"/>
</p>
<p>
客户端：
</p>
<p>
<img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/db76d0340bedd103a88686f8d86129a3.png"/>
</p>
<p>
服务端：
<br/>
<img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e4e66e01a69b37a9d2a0d9d63e0043da.png">
<br/>
测试 2：
</img>
</p>
<p>
<img alt="在这里插入图片描述" height="169" src="https://i-blog.csdnimg.cn/blog_migrate/e9306ea4d33acaf131fe825c33b98e00.png" width="518"/>
</p>
<p>
客户端：
<br/>
<img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4966d862ddd17224ac02955640e41cef.png">
<br/>
服务端：
<br/>
<img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7b0f8ea1d1f874cc2c22ebfae98fd152.png"/>
</img>
</p>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34303738343738332f:61727469636c652f64657461696c732f313134303237313438" class_="artid" style="display:none">
 </p>
</div>
