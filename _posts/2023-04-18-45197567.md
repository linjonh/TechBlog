---
layout: post
title: "robotframework如何提取失败的测试,以便下次运行"
date: 2023-04-18 09:23:41 +0800
description: "思路  robotframework在运行的结果中会生成一个output.xml文件，只要通过分析这"
keywords: "robotframework如何识别测试报告有失败的用例"
categories: ['Robotframework']
tags: ['测试失败', '测试', 'Parse']
artid: "45197567"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=45197567
    alt: "robotframework如何提取失败的测试,以便下次运行"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     robotframework如何提取失败的测试，以便下次运行
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2 id="思路">
     思路
    </h2>
    <blockquote>
     <p>
      robotframework在运行的结果中会生成一个output.xml文件，只要通过分析这个文件就可以获得所有失败状态下的测试的名称，获得名称后，将这些名称通过写入参数文件中，然后下次运行生成的参数文件就可以了
     </p>
    </blockquote>
    <hr/>
    <p>
     下面是我写的提取失败测试名称到参数文件的一个脚本：parse_fail_test.py，另外分享一个小技巧，可以直接借助于robotframework强大的参数处理机制，从而避免过多参数处理操作：
    </p>
    <pre class="prettyprint"><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># encoding: utf-8</span>

<span class="hljs-string">"""用于提取失败的测试，以便下次直接运行失败的测试
使用方法:  parse_fail_test.py [options] input_files
输入一个或者多个测试输出xml文件,如默认生成的output.xml,最终得到一个用于下次跑失败测试的配置
文件.
选项:
 -f --file file           最终生成的配置文件,如果不指定名字默认为args.txt文件
 -n --name name *         输入的文件名字,如果使用了参数,那么只能够放在最前面,不
                                                                 带参数的全部认为是输入文件.不带参数和带参数一起使用也没问题的
 -r --report name         设置参数文件生成的下次运行脚本时的报告名称                                                       
 ?                        输出帮助信息.
标有*号的参数是可以带多个参数的.

例子:
$ parse_fail_test.py output1.xml output2.xml output3.xml
$ parse_fail_test.py --report 重新跑失败测试报告 -f fail_run_args.txt output1.xml output2.xml
"""</span>

<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> inspect
<span class="hljs-keyword">from</span> xml.etree <span class="hljs-keyword">import</span> ElementTree
<span class="hljs-keyword">from</span> robot.utils <span class="hljs-keyword">import</span> ArgumentParser
<span class="hljs-keyword">from</span> robot.errors <span class="hljs-keyword">import</span> DataError, Information

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_to_str</span><span class="hljs-params">(unicode_or_str)</span>:</span>
    <span class="hljs-string">''' 将unicode字符串转换为str类型
    '''</span>
    <span class="hljs-keyword">if</span> isinstance(unicode_or_str, unicode):
        value = unicode_or_str.encode(<span class="hljs-string">'utf-8'</span>)
    <span class="hljs-keyword">else</span>:
        value = unicode_or_str
    <span class="hljs-keyword">return</span> value 

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_failed_test_name</span><span class="hljs-params">(input_file)</span>:</span>
    <span class="hljs-string">'''提供一个需要分析测试结果文件，获得失败的测试用例的名字
    '''</span>
    <span class="hljs-keyword">with</span> open(input_file, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
        tree = ElementTree.parse(f)

    <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> tree.getiterator(<span class="hljs-string">'test'</span>):
            <span class="hljs-keyword">if</span> test.find(<span class="hljs-string">'status'</span>).attrib.get(<span class="hljs-string">'status'</span>) == <span class="hljs-string">'FAIL'</span>:
                <span class="hljs-keyword">yield</span> _to_str(test.attrib.get(<span class="hljs-string">'name'</span>))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_write_args</span><span class="hljs-params">(file_name,inputfiles)</span>:</span>
    <span class="hljs-string">'''指定要产生的参数文件名字，以及对应失败的output.xml文件，
                 可以同时放入多个output.xml
    '''</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(inputfiles,list) :
        _exit(<span class="hljs-string">u'%s中传入write_args方法的参数不正确'</span>%inspect.stack()[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>], error=<span class="hljs-keyword">True</span>)
    <span class="hljs-comment">#获得所有的失败测试,然后生成参数文件,注意去掉重复的失败测试名字</span>
    fail_test_set = set()
    <span class="hljs-keyword">for</span> input_file <span class="hljs-keyword">in</span> inputfiles:
        fail_tests = _get_failed_test_name(input_file)
        <span class="hljs-keyword">if</span> fail_tests:
            <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> fail_tests:
                fail_test_set.add(test)
    <span class="hljs-keyword">with</span> open(file_name, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> uniq_test <span class="hljs-keyword">in</span> fail_test_set:
            f.write(<span class="hljs-string">'--test '</span>+ uniq_test +<span class="hljs-string">'\n'</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_paths</span><span class="hljs-params">(opts, paths)</span>:</span>
    <span class="hljs-string">'''解析参数获得所有的输入文件，返回文件列表
    '''</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> opts[<span class="hljs-string">'name'</span>] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> paths:
        _exit(<span class="hljs-string">u'没有输入要提取的文件'</span>, error=<span class="hljs-keyword">True</span>)
    all_paths = paths
    all_paths.extend(opts[<span class="hljs-string">'name'</span>])
    <span class="hljs-keyword">return</span> all_paths

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(args)</span>:</span>
    opts, paths = _process_args(args)
    <span class="hljs-keyword">if</span> <span class="hljs-string">'?'</span> <span class="hljs-keyword">in</span> paths :
        <span class="hljs-keyword">print</span> __doc__
        sys.exit()
    all_paths =  _get_paths(opts, paths)
    arg_file_name = opts[<span class="hljs-string">'file'</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">'args.txt'</span>
    report_name = opts[<span class="hljs-string">'report'</span>] <span class="hljs-keyword">or</span> <span class="hljs-string">u'下次运行时的报告名称'</span>
    <span class="hljs-comment">#清理可能已经存在的参数文件</span>
    <span class="hljs-keyword">if</span> os.path.exists(arg_file_name): 
        os.remove(arg_file_name)
    _write_args(arg_file_name, all_paths)
    <span class="hljs-comment">#如果传入的文件没有分析得到失败的case，那就没有必要生成最后的参数文件了</span>
    <span class="hljs-keyword">if</span> os.path.exists(arg_file_name): 
        <span class="hljs-keyword">with</span> open(arg_file_name, <span class="hljs-string">'a'</span>) <span class="hljs-keyword">as</span> f:
            f.write(<span class="hljs-string">'--loglevel DEBUG\n'</span>) 
            f.write(<span class="hljs-string">'--reporttitle '</span>+_to_str(report_name)+<span class="hljs-string">'\n'</span>)
    <span class="hljs-keyword">else</span>:
        _exit(<span class="hljs-string">u'传入的文件没有失败的测试'</span>, error=<span class="hljs-keyword">True</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_process_args</span><span class="hljs-params">(cliargs)</span>:</span>
    <span class="hljs-string">'''解析参数
    '''</span>
    ap = ArgumentParser(__doc__, arg_limits=(<span class="hljs-number">0</span>, ))
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> ap.parse_args(cliargs)
    <span class="hljs-keyword">except</span> Information, msg:
        _exit(msg)
    <span class="hljs-keyword">except</span> DataError, err:
        _exit(err, error=<span class="hljs-keyword">True</span>)   

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_exit</span><span class="hljs-params">(msg, error=False)</span>:</span>
    <span class="hljs-keyword">print</span> unicode(msg)
    <span class="hljs-keyword">if</span> error:
        <span class="hljs-keyword">print</span> <span class="hljs-string">u"\n请用 '?' 命令查看帮助文档."</span>
    sys.exit(int(error)) 

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main(sys.argv[<span class="hljs-number">1</span>:])</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f75303131353436383036:2f61727469636c652f64657461696c732f3435313937353637" class_="artid" style="display:none">
 </p>
</div>


