---
layout: post
title: "Android-单元测试之UI测试"
date: 2024-10-08 15:32:15 +0800
description: "Espresso提供了两个方法：intended 和 indending，这两个方法分别可以看成是M"
keywords: "android ui test"
categories: ['未分类']
tags: []
  ["测试用例", "测试工具", "压力测试", "单元测试", "Ui", "Pytest", "Android"]
artid: "142761146"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=142761146
  alt: "Android-单元测试之UI测试"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android 单元测试之UI测试
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     Android 单元测试之
     <a href="https://so.csdn.net/so/search?q=UI%E6%B5%8B%E8%AF%95&amp;spm=1001.2101.3001.7020" title="UI测试">
      UI测试
     </a>
    </h3>
    <h4>
     <a name="t1">
     </a>
     UI测试
    </h4>
    <h5>
     <a name="t2">
     </a>
     Espresso
    </h5>
    <p>
     <a href="https://developer.android.com/training/testing/espresso" rel="nofollow" title="官网地址">
      官网地址
     </a>
    </p>
    <p>
     Espresso是Google官方的一个针对Android UI测试的库，可以自动化的进行UI测试。
    </p>
    <p>
     Espresso可以验证View的可见性，文字显示是否正确，图片是否正确，位置等等，相对于人工测试，Espresso覆盖更全，测试速度更快。
    </p>
    <p>
     UI测试分为三个部分：ViewMatcher、ViewAction、ViewAssertion。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/8a003413aa7509e163045cae3919bb13.png"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     一般的
     <a href="https://so.csdn.net/so/search?q=%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B&amp;spm=1001.2101.3001.7020" title="测试流程">
      测试流程
     </a>
     就是按照上面图示的步骤来进行，首先匹配到UI组件，然后执行一些操作，比如click()，然后执行断言判断。其中每个部分包括很多个方法，官方有一个图：
    </p>
    <p>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/14e3ba3e17fba93081c560b0e1316e27.png"/>
    </p>
    <p>
    </p>
    <p>
     可以看到每个步骤下面有很多个方法，在写测试用例的时候都可以使用。
    </p>
    <p>
     普通UI组件测试
    </p>
    <p>
     对于普通的UI组件测试，在之前的Junit的测试中说，所有UI测试相关的都在androidTest文件夹下，看下一个简单的例子：
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        @RunWith(AndroidJUnit4::class)
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        class MainActivityTest {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @get:Rule
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        public val activity = ActivityTestRule(MainActivity::class.java)
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        fun onViewClicked() {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        onView(withId(R.id.tv_content)).check(matches(not(isDisplayed())))
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        onView(withId(R.id.btn_change)).check(matches(withText("change"))).perform(click())
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        onView(withId(R.id.tv_content)).check(matches(withText("content"))).check(matches(isDisplayed()))
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
     可以看出，测试UI的流程就是按照上面的三个步骤来进行的。
    </p>
    <p>
     Intent跳转测试
    </p>
    <p>
     引入：
    </p>
    <pre><code>androidTestImplementation 'androidx.test.espresso:espresso-intents:3.1.0'</code></pre>
    <p>
     在一些场景下，可能需要测试Intent的跳转，但是可能并不需要真正去执行这个跳转的操作，实际上只需要验证一下这个跳转的intent是否发送成功就可以了。Espresso提供了两个方法：intended 和 indending，这两个方法分别可以看成是Mockito中的verify()和when ()，一般情况下，如果跳转不需要返回值，就使用 intended ，如果跳转需要返回值，则用 indending 模拟一个返回值。看一个简单的例子：
     <br/>
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        //如果需要测试Intent，这里的Rule需要更换成IntentTestRule
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        @get:Rule
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        public val intentRule = IntentsTestRule(MainActivity::class.java)
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        private val PACKAGE_NAME = "com.example.myapplication"
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        fun onIntent(){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        onView(withId(R.id.btn_intent)).perform(click())
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        //点击btn跳转到SecondActivity, 验证intent中是否包含有SecondActivity组件，以及目标package是否为指定的package。
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        intended(allOf(hasComponent(hasShortClassName(".SecondActivity")), toPackage(PACKAGE_NAME)))
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
     如果使用的是startActivityforResult的话，需要返回值，可以按照如下的写法：
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        val resultIntent = Intent()
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        resultIntent.putExtra("result", "OK")
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        val result = Instrumentation.ActivityResult(Activity.RESULT_OK, resultIntent)
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        intending(allOf(hasComponent(hasShortClassName(".SecondActivity")), toPackage(PACKAGE_NAME))).respondWith(result)
       </code>
      </p>
     </li>
    </ol>
    <p>
     上面的代码就是利用
     <code>
      intending
     </code>
     对目标Intent构造了一个返回值，和
     <code>
      when().thenReturn()
     </code>
     有点类似。
    </p>
    <p>
     WebView 测试
    </p>
    <p>
     引入：
    </p>
    <pre><code>androidTestImplementation 'androidx.test.espresso:espresso-web:3.1.0'</code></pre>
    <p>
     除了对于一些普通的控件进行UI测试之外，Espresso还可以对WebView进行测试，并且可以获取web页中的element，对其进行一些Action、或者获取当前加载的url、也可以检查某些控件中是否包含有某些字段，下面是一个简单的例子：
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        @Test
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        fun onLoadUrl(){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        onView(withId(R.id.btn_start_webview)).perform(click())
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        //onIdle()
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        //检测当前加载的url中是否包含bing
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        onWebView().check(webMatches(getCurrentUrl(), containsString("bing")))
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
     还可以检测WebView中元素，并且进行断言判断：
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        onWebView()
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .withElement(findElement(Locator.ID, "teacher"))
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .withContextualElement(findElement(Locator.ID, "person_name"))
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .check(webMatches(getText(), containsString("Socrates")))
       </code>
      </p>
     </li>
    </ol>
    <p>
     检测teacher.person_name是否包含有Socrates。
    </p>
    <p>
     也可以对WebView中的元素进行操作
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        onWebView()
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .withElement(findElement(Locator.ID, "teacher"))
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        .perform(webClick())
       </code>
      </p>
     </li>
    </ol>
    <p>
     自定义Matcher
    </p>
    <p>
     在一些情况下，可能系统提供的Matcher并不能满足需求，这时候也可以通过自定义Matcher来实现：
    </p>
    <pre></pre>
    <ol>
     <li>
      <p>
       <code>
        fun textViewTextColorMatcher(matcherColor: Int): Matcher&lt;View&gt; {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        return object: BoundedMatcher&lt;View, TextView&gt;(TextView::class.java){
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        override fun describeTo(description: Description?) {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        description?.appendText("with test color: $matcherColor")
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
     </li>
     <li>
      <p>
       <code>
        override fun matchesSafely(item: TextView?): Boolean {
        <!-- -->
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        return matcherColor == item?.currentTextColor
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
     <li>
      <p>
       <code>
        }
       </code>
      </p>
     </li>
    </ol>
    <p>
     上述代码自定义了一个TextView的textColor的匹配器，describeTo是当匹配失败的时候的提示，matchesSafely是主要的匹配逻辑。
    </p>
    <p>
     然后就可以通过以下方式来使用自定义的匹配器了。
    </p>
    <pre><code>onView(withId(R.id.search_action_button)).check(matches(textViewTextColorMatcher(TEXT_BTN_COLOR_DISABLED)))</code></pre>
    <h4>
     <a name="t3">
     </a>
     其它
    </h4>
    <ul>
     <li>
      <strong>
       测试报告
      </strong>
     </li>
    </ul>
    <p>
     当使用gralde/app/verification/test 编译的时候，会运行所有的测试类(包括所有的module)，并且在对应的build/reports/tests/下面生成一个测试报告（也可以通过运行命令 ./gradlew test）。可以通过这个测试报告来查看到底有多少测试类通过，多少失败，然后针对性的检查问题。下图就是跑了test之后生成的报告
    </p>
    <p>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/ef1650c7a3fd46a6831559497b4d06bf.png"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
     </strong>
    </p>
    <p>
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a8df6180353b492aac88bbbfe4e6bf4b.png"/>
    </p>
    <p>
     这些资料，对于【
     <a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95&amp;spm=1001.2101.3001.7020" title="软件测试">
      软件测试
     </a>
     】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你!
     <strong>
      有需要的小伙伴可以点击下方小卡片领取
     </strong>
    </p>
    <p class="img-center">
     <img alt="" src="https://img-blog.csdnimg.cn/direct/c7c3209b53db4e71bfff8d42a6bbd8be.gif"/>
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f6368656e67787579757a6e67756f6b652f:61727469636c652f64657461696c732f313432373631313436" class_="artid" style="display:none">
 </p>
</div>
