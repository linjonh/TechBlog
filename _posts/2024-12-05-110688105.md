---
layout: post
title: "python-simplehttp_python内置HTTP服务SimpleHTTPServer"
date: 2024-12-05 11:31:48 +0800
description: "我们可以很简单的使用SimpleHTTPServer快速搭建一个http服务，提供一个文件浏览的we"
keywords: "python simple"
categories: ["未分类"]
tags: ["Simplehttp", "Python"]
artid: "110688105"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=110688105
  alt: "python-simplehttp_python内置HTTP服务SimpleHTTPServer"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     python simplehttp_python内置HTTP服务（SimpleHTTPServer）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div style="font-size:16px;">
     <p>
      我们可以很简单的使用SimpleHTTPServer快速搭建一个http服务，提供一个文件浏览的web服务，首先进入一个目录，之后再该目录中按如下操作即可创建http服务：
     </p>
     <p>
      一、python2.x环境
     </p>
     <p>
      a、no ssl
     </p>
     <p>
      python -m SimpleHTTPServer 80(自定义端口)
     </p>
     <p>
      说明：
     </p>
     <p>
      -- 只能接受端口作为参数绑定地址参数不可用Python 2.x文档
     </p>
     <p>
      -- 如果目录下有index.html或者(index.htm)，那么index.html文件会被视为默认主页；如果不存在index.html文件，那么就会显示整个目录列表
     </p>
     <p>
      b、with ssl
     </p>
     <p>
      创建server.py
     </p>
     <p>
      import BaseHTTPServer, SimpleHTTPServer
     </p>
     <p>
      import ssl
     </p>
     <p>
      class MyRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
     </p>
     <p>
      def translate_path(self, path):
     </p>
     <p>
      index = path.find('/', 2)
     </p>
     <p>
      return SimpleHTTPServer.SimpleHTTPRequestHandler.translate_path(self,"/index.html")
     </p>
     <p>
      httpd = BaseHTTPServer.HTTPServer(('', 443), MyRequestHandler)
     </p>
     <p>
      # httpd = BaseHTTPServer.HTTPServer(('', 8444), SimpleHTTPServer.SimpleHTTPRequestHandler)
     </p>
     <p>
      # httpd.socket = ssl.wrap_socket(httpd.socket, certfile='localhost.pem', server_side=True)
     </p>
     <p>
      httpd.socket = ssl.wrap_socket(httpd.socket,keyfile="./3064079_myclusterbox.com.key", certfile='./3064079_myclusterbox.com.pem', server_side=True)
     </p>
     <p>
      httpd.serve_forever()
     </p>
     <p>
      运行python server.py以启动服务器
     </p>
     <p>
      可能遇到如下问题：
     </p>
     <p>
      二、python3.x环境
     </p>
     <p>
      a、no ssl
     </p>
     <p>
      python3 -m http.server 8000 --bind 127.0.0.1
     </p>
     <p>
      说明：
     </p>
     <p>
      -- 端口和绑定地址都是可选的。有关更多详细信息，请阅读官方文档。
     </p>
     <p>
      b、with ssl
     </p>
     <p>
      from http.server import HTTPServer, BaseHTTPRequestHandler
     </p>
     <p>
      import ssl
     </p>
     <p>
      httpd = HTTPServer(('localhost', 4443), BaseHTTPRequestHandler)
     </p>
     <p>
      httpd.socket = ssl.wrap_socket (httpd.socket,
     </p>
     <p>
      keyfile="path/to/key.pem",
     </p>
     <p>
      certfile='path/to/cert.pem', server_side=True)
     </p>
     <p>
      httpd.serve_forever()
     </p>
     <p>
      c、Do_GET请求示例
     </p>
     <p>
      from http.server import HTTPServer, BaseHTTPRequestHandler
     </p>
     <p>
      class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
     </p>
     <p>
      def do_GET(self):
     </p>
     <p>
      self.send_response(200)
     </p>
     <p>
      self.end_headers()
     </p>
     <p>
      self.wfile.write(b'Hello, world!')
     </p>
     <p>
      httpd = HTTPServer(('localhost', 8000), SimpleHTTPRequestHandler)
     </p>
     <p>
      httpd.serve_forever()
     </p>
     <p>
      这是一个非常简单的HTTP服务器，它可以响应Hello，世界！给请求者。请注意，这self.send_response(200)和 self.end_headers()是强制性的，否则不会响应被视为有效。我们可以通过使用HTTPie发送请求来检查它是否确实有效：
     </p>
     <p>
      $ http http://127.0.0.1:8000
     </p>
     <p>
      HTTP/1.0 200 OK
     </p>
     <p>
      Date: Sun, 25 Feb 2018 17:26:20 GMT
     </p>
     <p>
      Server: BaseHTTP/0.6 Python/3.6.1
     </p>
     <p>
      Hello, world!
     </p>
     <p>
      请注意，这self.wfile是一个类似对象的文件，因此希望该write函数使用类似字节的对象。喂的另一种方法wfile是使用BytesIO 对象(请参见下面的示例)。
     </p>
     <p>
      d、Do_POST请求示例
     </p>
     <p>
      from http.server import HTTPServer, BaseHTTPRequestHandler
     </p>
     <p>
      from io import BytesIO
     </p>
     <p>
      class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
     </p>
     <p>
      def do_GET(self):
     </p>
     <p>
      self.send_response(200)
     </p>
     <p>
      self.end_headers()
     </p>
     <p>
      self.wfile.write(b'Hello, world!')
     </p>
     <p>
      def do_POST(self):
     </p>
     <p>
      content_length = int(self.headers['Content-Length'])
     </p>
     <p>
      body = self.rfile.read(content_length)
     </p>
     <p>
      self.send_response(200)
     </p>
     <p>
      self.end_headers()
     </p>
     <p>
      response = BytesIO()
     </p>
     <p>
      response.write(b'This is POST request. ')
     </p>
     <p>
      response.write(b'Received: ')
     </p>
     <p>
      response.write(body)
     </p>
     <p>
      self.wfile.write(response.getvalue())
     </p>
     <p>
      httpd = HTTPServer(('localhost', 8000), SimpleHTTPRequestHandler)
     </p>
     <p>
      httpd.serve_forever()
     </p>
     <p>
      可以通过访问请求正文self.rfile。它是一个BufferedReader， 因此read([size])应执行方法以获取内容。注意，size应该将其显式传递给函数，否则请求将挂起并且永不结束。这就是为什么content_length需要获取的原因。可以通过检索它self.headers并将其转换为整数。上面的示例只是打印出他收到的所有内容，如下所示：
     </p>
     <p>
      http http://127.0.0.1:8000 key=value
     </p>
     <p>
      HTTP/1.0 200 OK
     </p>
     <p>
      Date: Sun, 25 Feb 2018 17:46:06 GMT
     </p>
     <p>
      Server: BaseHTTP/0.6 Python/3.6.1
     </p>
     <p>
      This is POST request. Received: {"key": "value"}
     </p>
     <p>
      如果愿意，您可以考虑解析JSON。
     </p>
     <p>
      e、get请求访问index.html示例
     </p>
     <p>
      import sys
     </p>
     <p>
      from http.server import HTTPServer, BaseHTTPRequestHandler, SimpleHTTPRequestHandler
     </p>
     <p>
      import ssl
     </p>
     <p>
      import urllib
     </p>
     <p>
      import os
     </p>
     <p>
      class SimpleHTTPRequestHandler(SimpleHTTPRequestHandler):
     </p>
     <p>
      def do_GET(self):
     </p>
     <p>
      root = os.path.dirname(os.path.abspath(__file__))
     </p>
     <p>
      filename = root + '/index.html'
     </p>
     <p>
      self.send_response(200)
     </p>
     <p>
      if filename[-4:] == '.css':
     </p>
     <p>
      self.send_header('Content-type', 'text/css')
     </p>
     <p>
      elif filename[-5:] == '.json':
     </p>
     <p>
      self.send_header('Content-type', 'application/javascript')
     </p>
     <p>
      elif filename[-3:] == '.js':
     </p>
     <p>
      self.send_header('Content-type', 'application/javascript')
     </p>
     <p>
      elif filename[-4:] == '.ico':
     </p>
     <p>
      self.send_header('Content-type', 'image/x-icon')
     </p>
     <p>
      else:
     </p>
     <p>
      self.send_header('Content-type', 'text/html')
     </p>
     <p>
      self.end_headers()
     </p>
     <p>
      with open(filename, 'rb') as fh:
     </p>
     <p>
      html = fh.read()
     </p>
     <p>
      self.wfile.write(html)
     </p>
     <p>
      httpd = HTTPServer(('', 443), SimpleHTTPRequestHandler)
     </p>
     <p>
      httpd.socket = ssl.wrap_socket (httpd.socket,
     </p>
     <p>
      keyfile="./3064079_myclusterbox.com.key",
     </p>
     <p>
      certfile='./3064079_myclusterbox.com.pem', server_side=True)
     </p>
     <p>
      httpd.serve_forever()
     </p>
     <p>
      可能遇到如下问题：
     </p>
     <p>
      附录一、生成自签名证书
     </p>
     <p>
      需要确保“公用名”与服务器的名称相同，例如“ localhost”，如下
     </p>
     <p>
      1、python2.x
     </p>
     <p>
      openssl req -new -x509 -keyout localhost.pem -out localhost.pem -days 365 -nodes
     </p>
     <p>
      2、python3.x
     </p>
     <p>
      openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365
     </p>
     <p>
      注意：本文归作者所有，未经作者允许，不得转载
     </p>
    </div>
   </div>
  </div>
  <div id="recommendDown">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33393535313939362f:61727469636c652f64657461696c732f313130363838313035" class_="artid" style="display:none">
 </p>
</div>
