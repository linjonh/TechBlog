---
layout: post
title: "Linux进程概念进程优先级详细解读"
date: 2024-12-05 02:04:22 +0800
description: "本文详细探讨了冯诺依曼体系结构，介绍了操作系统的基本概念、设计目的，进程管理中的PCB、task_s"
keywords: "linux系统父进程id和子进程id优先级"
categories: ['系统编程', 'Linux']
tags: ['进程概念', '进程优先级', '运维', '详细讲解', '服务器', '新手向', 'Linux']
artid: "137621937"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=137621937
    alt: "Linux进程概念进程优先级详细解读"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [Linux][进程概念][进程优先级]详细解读
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      目录）
     </h4>
     <ul>
      <li>
       <a href="#0_1" rel="nofollow">
        0.冯诺依曼体系结构
       </a>
      </li>
      <li>
       <a href="#1Operator_System_16" rel="nofollow">
        1.操作系统(Operator System)
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_18" rel="nofollow">
          1.概念
         </a>
        </li>
        <li>
         <a href="#2OS_24" rel="nofollow">
          2.设计OS的目的
         </a>
        </li>
        <li>
         <a href="#3_28" rel="nofollow">
          3.定位
         </a>
        </li>
        <li>
         <a href="#4_34" rel="nofollow">
          4.系统调用和库函数概念
         </a>
        </li>
        <li>
         <a href="#5_38" rel="nofollow">
          5.总结
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#2_44" rel="nofollow">
        2.进程
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_46" rel="nofollow">
          1.基本概念
         </a>
        </li>
        <li>
         <a href="#2__PCB_53" rel="nofollow">
          2.描述进程 -- PCB
         </a>
        </li>
        <li>
         <a href="#3task_struct_58" rel="nofollow">
          3.task_struct内容分类
         </a>
        </li>
        <li>
         <a href="#4_69" rel="nofollow">
          4.组织进程
         </a>
        </li>
        <li>
         <a href="#5_72" rel="nofollow">
          5.查看进程
         </a>
        </li>
        <li>
         <a href="#6_81" rel="nofollow">
          6.通过系统调用获取进程标识符
         </a>
        </li>
        <li>
         <a href="#7____fork_85" rel="nofollow">
          7.通过系统调用创建进程 -- fork初识
         </a>
        </li>
        <li>
         <a href="#8_119" rel="nofollow">
          8.进程状态
         </a>
        </li>
        <li>
         <a href="#9_144" rel="nofollow">
          9.进程状态查看
         </a>
        </li>
        <li>
         <a href="#10_148" rel="nofollow">
          10.僵尸进程
         </a>
        </li>
        <li>
         <a href="#11_180" rel="nofollow">
          11.僵尸进程危害
         </a>
        </li>
        <li>
         <a href="#12_189" rel="nofollow">
          12.孤儿进程
         </a>
        </li>
        <li>
         <a href="#13_196" rel="nofollow">
          13.守护进程&amp;精灵进程
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#3_201" rel="nofollow">
        3.进程优先级
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_203" rel="nofollow">
          1.基本概念
         </a>
        </li>
        <li>
         <a href="#2_209" rel="nofollow">
          2.查看系统进程
         </a>
        </li>
        <li>
         <a href="#3PRI__NI_221" rel="nofollow">
          3.PRI &amp; NI
         </a>
        </li>
        <li>
         <a href="#4PRI_vs_NI_230" rel="nofollow">
          4.PRI vs NI
         </a>
        </li>
        <li>
         <a href="#5_234" rel="nofollow">
          5.查看进程优先级的命令
         </a>
        </li>
        <li>
         <a href="#6_238" rel="nofollow">
          6.其他概念
         </a>
        </li>
        <li>
         <a href="#7_246" rel="nofollow">
          7.什么是进程切换？
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="0_1">
     </a>
     0.冯诺依曼体系结构
    </h2>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/da72ea3a7f642b22960caf9da1fc914d.png"/>
    </p>
    <ul>
     <li>
      截至目前，我们所认识的计算机，都是由一个个的硬件组件组成
      <ul>
       <li>
        输入单元：包括键盘，鼠标，扫描仪，磁盘，网卡等
       </li>
       <li>
        输出单元：显示器，打印机，磁盘，网卡等
       </li>
      </ul>
     </li>
     <li>
      <strong>
       注意：
      </strong>
      <ul>
       <li>
        这里的存储器指的是内存
       </li>
       <li>
        不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)
       </li>
       <li>
        外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取
       </li>
       <li>
        <strong>
         一句话总结，所有设备都只能直接和内存打交道
        </strong>
       </li>
      </ul>
     </li>
     <li>
      <strong>
       对冯诺依曼的理解，不能停留在概念上，要深入到对软件数据流理解上
      </strong>
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="1Operator_System_16">
     </a>
     1.操作系统(Operator System)
    </h2>
    <h3>
     <a id="1_18">
     </a>
     1.概念
    </h3>
    <ul>
     <li>
      任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)
     </li>
     <li>
      笼统的理解，操作系统包括：
      <ul>
       <li>
        内核（进程管理，内存管理，文件管理，驱动管理）
       </li>
       <li>
        其他程序（例如函数库，shell程序等等）
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="2OS_24">
     </a>
     2.设计OS的目的
    </h3>
    <ul>
     <li>
      与硬件交互，管理所有的软硬件资源
     </li>
     <li>
      为用户程序（应用程序）提供一个良好的执行环境
     </li>
    </ul>
    <h3>
     <a id="3_28">
     </a>
     3.定位
    </h3>
    <ul>
     <li>
      在整个计算机软硬件架构中，操作系统的定位是：
      <strong>
       一款纯正的“搞管理”的软件
      </strong>
     </li>
    </ul>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c13b8da01cd61925ece1d73ec72770e5.png"/>
    </p>
    <h3>
     <a id="4_34">
     </a>
     4.系统调用和库函数概念
    </h3>
    <ul>
     <li>
      在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分
      <strong>
       由操作系统提供的接口
      </strong>
      ，叫做
      <strong>
       系统调用
      </strong>
     </li>
     <li>
      系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以
      <strong>
       对部分系统调用进行适度封装，从而形成库
      </strong>
      ，有了库，就很有利于更上层用户或者开发者进行二次开发
     </li>
    </ul>
    <h3>
     <a id="5_38">
     </a>
     5.总结
    </h3>
    <ul>
     <li>
      计算机
      <strong>
       管理
      </strong>
      硬件：
      <font color="red">
       <strong>
        先描述，再管理
       </strong>
      </font>
      <ul>
       <li>
        <strong>
         描述
        </strong>
        起来，用struct结构体
       </li>
       <li>
        <strong>
         组织
        </strong>
        起来，用链表或其他高效的数据结构
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="2_44">
     </a>
     2.进程
    </h2>
    <h3>
     <a id="1_46">
     </a>
     1.基本概念
    </h3>
    <ul>
     <li>
      课本概念：程序的一个执行实例，正在执行的程序等
     </li>
     <li>
      内核观点：担当分配系统资源（CPU时间，内存）的实体
     </li>
     <li>
      什么叫做进程？
      <ul>
       <li>
        <strong>
         进程 = 对应的代码和数据 + 进程对应的PCB结构体
        </strong>
       </li>
       <li>
        文件 = 内容 + 属性
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="2__PCB_53">
     </a>
     2.描述进程 – PCB
    </h3>
    <ul>
     <li>
      进程信息被放在一个叫做
      <strong>
       进程控制块
      </strong>
      的数据结构中，可以理解为
      <strong>
       进程属性的集合
      </strong>
      <ul>
       <li>
        PCB(Process Control Block)，Linux操作系统下的PCB是:
        <strong>
         task_struct
        </strong>
       </li>
       <li>
        task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="3task_struct_58">
     </a>
     3.task_struct内容分类
    </h3>
    <ul>
     <li>
      **标示符：**描述本进程的唯一标示符，用来区别其他进程
     </li>
     <li>
      **状态：**任务状态，退出代码，退出信号等
     </li>
     <li>
      **优先级：**相对于其他进程的优先级
     </li>
     <li>
      **程序计数器：**程序中即将被执行的下一条指令的地址
     </li>
     <li>
      **内存指针：**包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
     </li>
     <li>
      <strong>
       上下文数据
      </strong>
      ：进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]
     </li>
     <li>
      <strong>
       I/O状态信息
      </strong>
      ：包括显示的I/O请求,分配给进程的I/O设备和被进程使用的文件列表
     </li>
     <li>
      **记账信息：**可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等
     </li>
     <li>
      其他信息
     </li>
    </ul>
    <h3>
     <a id="4_69">
     </a>
     4.组织进程
    </h3>
    <ul>
     <li>
      可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里
     </li>
    </ul>
    <h3>
     <a id="5_72">
     </a>
     5.查看进程
    </h3>
    <ul>
     <li>
      进程的信息可以通过
      <strong>
       /proc
      </strong>
      系统文件夹查看
      <ul>
       <li>
        如：要获取PID为1的进程信息，你需要查看 /proc/1 这个文件夹
       </li>
       <li>
        大多数进程信息同样可以使用
        <strong>
         top
        </strong>
        和
        <strong>
         ps
        </strong>
        这些用户级工具来获取
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-sh"><span class="token function">ps</span> ajx <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'filename'</span>  
<span class="token function">ps</span> ajx <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">ps</span> ajx <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'filename'</span>
</code></pre>
    <h3>
     <a id="6_81">
     </a>
     6.通过系统调用获取进程标识符
    </h3>
    <ul>
     <li>
      进程id(PID) --&gt;
      <strong>
       getpid()
      </strong>
     </li>
     <li>
      父进程id(PPID) --&gt;
      <strong>
       getppid()
      </strong>
     </li>
    </ul>
    <h3>
     <a id="7____fork_85">
     </a>
     7.通过系统调用创建进程 – fork初识
    </h3>
    <ul>
     <li>
      运行
      <strong>
       man fork
      </strong>
      认识fork
     </li>
     <li>
      <strong>
       fork****有两个返回值
      </strong>
      <ul>
       <li>
        为什么会有两个返回值？
        <ul>
         <li>
          子进程内部属性，要以父进程为模板
         </li>
         <li>
          fork内部，父子各自会执行自己的return语句
         </li>
        </ul>
       </li>
       <li>
        失败的时候：返回-1
       </li>
       <li>
        成功的时候：
        <ul>
         <li>
          给父进程返回子进程的pid
         </li>
         <li>
          给子进程返回0
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <strong>
       fork****之后，代码是父子共享的
      </strong>
     </li>
     <li>
      <strong>
       fork****之后通常要用
       <font color="red">
        if
       </font>
       进行分流
      </strong>
     </li>
    </ul>
    <pre><code class="prism language-cpp">	pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token comment">//创建失败</span>
	    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token comment">//child process(task)</span>
	    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> 
	<span class="token punctuation">{<!-- --></span>
	    <span class="token comment">//parent process</span>
	    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="8_119">
     </a>
     8.进程状态
    </h3>
    <ul>
     <li>
      <strong>
       新建
      </strong>
     </li>
     <li>
      **运行：**task_struct结构体在运行队列中排队 --&gt; 运行态
     </li>
     <li>
      **阻塞：**等待非CPU资源就绪 --&gt; 阻塞状态
      <ul>
       <li>
        进程阻塞本质 --&gt; 进程阻塞在系统函数的内部
       </li>
      </ul>
     </li>
     <li>
      **挂起：**当内存不足的时候，OS通过适当的置换进程的代码和数据到磁盘，进程的状态就叫做挂起
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> task_state_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token string">"R (running)"</span><span class="token punctuation">,</span>      <span class="token comment">/* 0 */</span>
    <span class="token string">"S (sleeping)"</span><span class="token punctuation">,</span>     <span class="token comment">/* 1 */</span>
    <span class="token string">"D (disk sleep)"</span><span class="token punctuation">,</span>   <span class="token comment">/* 2 */</span>
    <span class="token string">"T (stopped)"</span><span class="token punctuation">,</span>      <span class="token comment">/* 4 */</span>
    <span class="token string">"t (tracing stop)"</span><span class="token punctuation">,</span> <span class="token comment">/* 8 */</span>
    <span class="token string">"X (dead)"</span><span class="token punctuation">,</span>         <span class="token comment">/* 16 */</span>
    <span class="token string">"Z (zombie)"</span><span class="token punctuation">,</span>       <span class="token comment">/* 32 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       R
      </strong>
      运行状态（running）：并不意味着进程一定在运行中，它表明进程
      <strong>
       要么是在运行中要么在运行队列里
      </strong>
     </li>
     <li>
      <strong>
       S
      </strong>
      睡眠状态（sleeping）：对应着上面的
      <strong>
       阻塞
      </strong>
      状态，意味着进程在等待事件完成(这里的睡眠有时候也叫做
      <strong>
       可中断睡眠
      </strong>
      (interruptible sleep))
     </li>
     <li>
      <strong>
       D
      </strong>
      磁盘休眠状态（Disk sleep）睡眠状态，磁盘睡眠，深度睡眠，也叫
      <strong>
       不可中断睡眠状态
      </strong>
      （uninterruptible sleep），不可以被被动唤醒，
      <strong>
       在这个状态的进程通常会等待IO的结束
      </strong>
     </li>
     <li>
      <strong>
       T
      </strong>
      停止状态（stopped）： 可以通过发送SIGSTOP信号给进程来停止进程。这个被暂停的进程可以通过发送SIGCONT信号让进程继续运行
     </li>
     <li>
      <strong>
       X
      </strong>
      死亡状态（dead）：这个状态只是一个返回状态，不会在任务列表里看到这个状态
     </li>
    </ul>
    <h3>
     <a id="9_144">
     </a>
     9.进程状态查看
    </h3>
    <pre><code class="prism language-sh"><span class="token function">ps</span> aux / <span class="token function">ps</span> axj 命令
</code></pre>
    <h3>
     <a id="10_148">
     </a>
     10.僵尸进程
    </h3>
    <ul>
     <li>
      僵死状态（Zombies）是一个比较特殊的状态
      <ul>
       <li>
        当进程退出并且父进程（使用wait()系统调用）没有读取到子进程退出的返回代码时就会产生僵尸进程
       </li>
       <li>
        僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码
       </li>
       <li>
        所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程就进入Z状态
       </li>
      </ul>
     </li>
     <li>
      综上，即一个进程已经退出，但是还不允许被OS释放，
      <strong>
       处于一个被检测的状态
      </strong>
      --&gt; 僵尸状态
     </li>
     <li>
      以下为一个创建维持30s的僵尸进程的例子
     </li>
    </ul>
    <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am parent process! -- PID:"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

pid_t ret <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 变成两个进程，一个是父进程，一个是子进程</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// parent process</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"parent:"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":is sleeping"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// child process</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child:"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":is sleeping"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="11_180">
     </a>
     11.僵尸进程危害
    </h3>
    <ul>
     <li>
      进程的退出状态必须被维持下去，因为它要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了
      <ul>
       <li>
        可父进程如果一直不读取，那子进程就一直处于Z状态？ --&gt; 是的！
       </li>
      </ul>
     </li>
     <li>
      维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中
      <ul>
       <li>
        换句话说，Z状态一直不退出，PCB一直都要维护？ --&gt; 是的！
       </li>
      </ul>
     </li>
     <li>
      那一个父进程创建了很多子进程，就是不回收，是不是就会造成内存资源的浪费？ --&gt; 是的！
      <ul>
       <li>
        因为数据结构对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置开辟空间！
       </li>
      </ul>
     </li>
     <li>
      以上是否构成内存泄漏？ --&gt; 是的！
     </li>
    </ul>
    <h3>
     <a id="12_189">
     </a>
     12.孤儿进程
    </h3>
    <ul>
     <li>
      父进程先退出，子进程就称之为“孤儿进程”
     </li>
     <li>
      父进程如果提前退出，那么子进程后退出，进入Z之后，那该如何处理呢？
     </li>
     <li>
      孤儿进程被1号init进程领养，当然要由init进程回收
     </li>
     <li>
      为什么要被领养？
     </li>
     <li>
      未来子进程退出的时候，父进程早已不在，需要领养进程来进行回收
     </li>
    </ul>
    <h3>
     <a id="13_196">
     </a>
     13.守护进程&amp;精灵进程
    </h3>
    <ul>
     <li>
      这两种是同一种进程的不同翻译，是特殊的孤儿进程
      <ul>
       <li>
        不但运行在后台，最主要的是脱离了与终端和登录会话的所有联系，也就是默默的运行在后台不想受到任何影响
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="3_201">
     </a>
     3.进程优先级
    </h2>
    <h3>
     <a id="1_203">
     </a>
     1.基本概念
    </h3>
    <ul>
     <li>
      CPU资源分配的先后顺序，就是指进程的优先权（priority）
     </li>
     <li>
      优先权高的进程有优先执行权利
      <ul>
       <li>
        配置进程优先权对多任务环境的Linux很有用，可以改善系统性能
       </li>
       <li>
        还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="2_209">
     </a>
     2.查看系统进程
    </h3>
    <ul>
     <li>
      <p>
       在Linux或者unix系统中，用
       <strong>
        ps –l
       </strong>
       命令则会类似输出以下几个内容
       <br/>
       <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8f6fbf821ea6e63e8f9846367ec73ffd.png"/>
      </p>
     </li>
     <li>
      <p>
       几个重要信息：
      </p>
      <ul>
       <li>
        <strong>
         UID
        </strong>
        : 代表执行者的身份
       </li>
       <li>
        <strong>
         PID
        </strong>
        : 代表这个进程的代号
       </li>
       <li>
        <strong>
         PPID
        </strong>
        ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号
       </li>
       <li>
        <strong>
         PRI
        </strong>
        ：代表这个进程可被执行的优先级，其
        <strong>
         值越小越早被执行
        </strong>
       </li>
       <li>
        <strong>
         NI
        </strong>
        ：代表这个进程的nice值
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="3PRI__NI_221">
     </a>
     3.PRI &amp; NI
    </h3>
    <ul>
     <li>
      PRI，即进程的优先级，通俗点说就是程序被CPU执行的先后顺序，
      <strong>
       此值越小进程的优先级别越高
      </strong>
     </li>
     <li>
      NI，即nice值，其表示进程可被执行的
      <strong>
       优先级的修正数值
      </strong>
     </li>
     <li>
      PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为：
      <font color="red">
       <strong>
        PRI(new)=PRI(old)+nice
       </strong>
      </font>
      <ul>
       <li>
        这样，当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行
       </li>
       <li>
        所以，调整进程优先级，在Linux下，就是
        <strong>
         调整进程nice值
        </strong>
       </li>
       <li>
        <font color="red">
         <strong>
          PRI(old)
         </strong>
        </font>
        <strong>
         都是80
        </strong>
        ，每次设置优先级，都要从进程最开始的优先级开始设置
       </li>
      </ul>
     </li>
     <li>
      nice其取值范围是**-20至19**，一共40个级别
     </li>
    </ul>
    <h3>
     <a id="4PRI_vs_NI_230">
     </a>
     4.PRI vs NI
    </h3>
    <ul>
     <li>
      需要强调一点的是，
      <strong>
       进程的nice值不是进程的优先级
      </strong>
      ，他们不是一个概念，但是进程nice值会影响到进程的优先级变化
     </li>
     <li>
      可以理解nice值是进程优先级的修正修正数据
     </li>
    </ul>
    <h3>
     <a id="5_234">
     </a>
     5.查看进程优先级的命令
    </h3>
    <ul>
     <li>
      用
      <strong>
       top
      </strong>
      命令更改已存在进程的nice：
      <ul>
       <li>
        <strong>
         进入top后按“r”–&gt;输入进程PID–&gt;输入nice值
        </strong>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="6_238">
     </a>
     6.其他概念
    </h3>
    <ul>
     <li>
      <strong>
       竞争性
      </strong>
      ：系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级
     </li>
     <li>
      <strong>
       独立性
      </strong>
      ：多进程运行，需要独享各种资源，多进程运行期间互不干扰，父子进程也具有独立性
     </li>
     <li>
      <strong>
       并行
      </strong>
      ：多个进程在
      <strong>
       多个CPU
      </strong>
      下分别，同时进行运行，这称之为并行
     </li>
     <li>
      <strong>
       并发
      </strong>
      ：多个进程在
      <strong>
       一个CPU
      </strong>
      下采用
      <strong>
       进程切换的方式
      </strong>
      ，在一段时间之内，让多个进程都得以推进，称之为并发
      <ul>
       <li>
        时间片
       </li>
       <li>
        抢占与出让
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="7_246">
     </a>
     7.什么是进程切换？
    </h3>
    <ul>
     <li>
      OS在多任务环境下，
      <strong>
       将CPU的执行控制从一个正在执行的进程切换到另一个进程的过程
      </strong>
      <ul>
       <li>
        它确保多个进程能够共享CPU时间，并在一个系统上同时运行多个任务，使系统能够高效地利用计算资源
       </li>
      </ul>
     </li>
     <li>
      <strong>
       上下文切换：
      </strong>
      <ul>
       <li>
        <strong>
         上下文是指OS维护的关于进程状态和寄存器内容的信息
        </strong>
       </li>
       <li>
        当OS决定切换到另一个进程时，它会保存当前执行进程的上下文，包括寄存器的内容、程序计数器和其他与进程相关的信息
       </li>
      </ul>
     </li>
     <li>
      **原因：**进程切换可以由多种原因触发，包括进程的时间片耗尽、等待I/O完成、信号的到来、进程主动放弃CPU(例如，通过系统调用yield或sleep)，或者新进程被调度执行
     </li>
     <li>
      <strong>
       调度器
      </strong>
      ：
      <ul>
       <li>
        Linux使用调度器来选择下一个要运行的进程，调度器基于一些策略和优先级来选择要执行的进程
       </li>
       <li>
        这确保了高优先级的任务得到更多的CPU时间，并使系统对多个任务进行公平分配
       </li>
      </ul>
     </li>
     <li>
      <strong>
       切换过程：
      </strong>
      <ul>
       <li>
        当发生进程切换时，操作系统会保存当前进程的上下文，选择下一个要运行的进程，然后还原其上下文，以便它从中断的地方继续执行
       </li>
       <li>
        这个过程包括在内核态和用户态之间的切换，因为内核需要在不同的进程之间进行操作
        <ul>
         <li>
          进程切换通常包括大量的操作，如保存和恢复寄存器、切换内存映射、刷新页表等，以确保新进程能够正确执行
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <strong>
       性能影响：
      </strong>
      <ul>
       <li>
        进程切换是有开销的，因为它涉及到复杂的操作。过多的进程切换会导致系统性能下降，因此操作系统的调度算法需要权衡各个进程的需求，以最大程度地减少不必要的切换
       </li>
      </ul>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373238313635362f:61727469636c652f64657461696c732f313337363231393337" class_="artid" style="display:none">
 </p>
</div>


