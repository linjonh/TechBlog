---
layout: post
title: "在线-xml转java对象_XML转Java实体对象"
date: 2024-12-28 23:23:27 +0800
description: "本文介绍了如何将XML转换为Java对象，包括从XML字符串直接转换、处理属性名不一致的情况，以及处"
keywords: "在线xml生成java实体类 根据xml生成java"
categories: ['']
tags: ['在线', 'Xml']
artid: "114118890"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=114118890
    alt: "在线-xml转java对象_XML转Java实体对象"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     在线 xml转java对象_XML转Java实体对象
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div style="font-size:16px;">
     <p>
      1.当拿到的xml是String 类型的
     </p>
     <p>
      String xml = "" +
     </p>
     <p>
      "张三" +
     </p>
     <p>
      "男" +
     </p>
     <p>
      "28" +
     </p>
     <p>
      "";
     </p>
     <p>
      通过下面方法就可以转成java对象
     </p>
     <p>
      public static T xmlToBean(String xmlPath,Class load) throws JAXBException {
      <!-- -->
     </p>
     <p>
      JAXBContext context = JAXBContext.newInstance(load);
     </p>
     <p>
      Unmarshaller unmarshaller = context.createUnmarshaller();
     </p>
     <p>
      return (T) unmarshaller.unmarshal(new StringReader(xmlPath));
     </p>
     <p>
      }
     </p>
     <p>
      Java对象需要@XmlAccessorType(XmlAccessType.FIELD)；@XmlType；@XmlRootElement(name = "User")注释用来映射
     </p>
     <p>
      @Data
     </p>
     <p>
      @JsonSerialize
     </p>
     <p>
      @XmlAccessorType(XmlAccessType.FIELD)
     </p>
     <p>
      @XmlType(name = "",propOrder = {
      <!-- -->
     </p>
     <p>
      "name",
     </p>
     <p>
      "age",
     </p>
     <p>
      "sex"
     </p>
     <p>
      })
     </p>
     <p>
      @XmlRootElement(name = "User")
     </p>
     <p>
      public class User {
      <!-- -->
     </p>
     <p>
      private String name;
     </p>
     <p>
      private Integer age;
     </p>
     <p>
      private String sex;
     </p>
     <p>
      }
     </p>
     <p>
      最后直接调用方法就可以
     </p>
     <p>
      User user = (User) JaxbUtil.xmlToBean(xml, User.class);
     </p>
     <p>
      2.当拿到的xml与实体类的属性名不一致时，将@XmlType注释换成@XmlElement(name = "Name", required = true)单独为每个属性注释，
     </p>
     <p>
      @Data
     </p>
     <p>
      @JsonSerialize
     </p>
     <p>
      @XmlAccessorType(XmlAccessType.FIELD)
     </p>
     <p>
      @XmlRootElement(name = "User")
     </p>
     <p>
      public class User {
      <!-- -->
     </p>
     <p>
      @XmlElement(name = "Name", required = true)
     </p>
     <p>
      private String name;
     </p>
     <p>
      @XmlElement(name = "Age", required = true)
     </p>
     <p>
      private Integer age;
     </p>
     <p>
      @XmlElement(name = "Sex", required = true)
     </p>
     <p>
      private String sex;
     </p>
     <p>
      }
     </p>
     <p>
      3.当拿到的xml不是String类型是，是NoteList对象；需要先转为String在转为对象
     </p>
     <p>
      MessageElement[] elements = value.get_any();
     </p>
     <p>
      调用转换方法
     </p>
     <p>
      List outboundlist = (List) JaxbUtil.xmlToString(HicOutBoundDTO.class,elements,"Outbound");
     </p>
     <p>
      该方法是直接转为对象的List集合了
     </p>
     <p>
      public static T xmlToString(Class load, MessageElement[] elements, String table) {
      <!-- -->
     </p>
     <p>
      try{
      <!-- -->
     </p>
     <p>
      NodeList outbound = elements[1].getElementsByTagName(table);
     </p>
     <p>
      List listDto = new ArrayList&lt;&gt;() ;
     </p>
     <p>
      for(int i=0;i
     </p>
     <p>
      Element node = (Element)outbound.item(i);
     </p>
     <p>
      TransformerFactory transFactory = TransformerFactory.newInstance();
     </p>
     <p>
      Transformer transformer = transFactory.newTransformer();
     </p>
     <p>
      StringWriter buffer = new StringWriter();
     </p>
     <p>
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
     </p>
     <p>
      transformer.transform(new DOMSource(node),
     </p>
     <p>
      new StreamResult(buffer));
     </p>
     <p>
      String str = buffer.toString();
     </p>
     <p>
      //再转为java对象
     </p>
     <p>
      JAXBContext context = JAXBContext.newInstance(load);
     </p>
     <p>
      Unmarshaller unmarshaller = context.createUnmarshaller();
     </p>
     <p>
      listDto.add(unmarshaller.unmarshal(new StringReader(str)));
     </p>
     <p>
      }
     </p>
     <p>
      return (T)listDto;
     </p>
     <p>
      }
     </p>
     <p>
      catch(Exception e)
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      return null;
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      4需要一个一个的值拿出来的时候
     </p>
     <p>
      Element node = (Element)outbound.item(0);
     </p>
     <p>
      node.getElementsByTagName("DeliveyType").item(0).getFirstChild().getNodeValue();
     </p>
    </div>
   </div>
  </div>
  <div id="recommendDown">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34323330343631382f:61727469636c652f64657461696c732f313134313138383930" class_="artid" style="display:none">
 </p>
</div>


