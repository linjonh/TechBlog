---
layout: post
title: 推荐前-6-名-JavaScript-和-HTML5-游戏引擎
date: 2025-01-08 00:35:02 +0800
categories: ['游戏引擎']
tags: ['游戏引擎', 'Javascript', 'Html']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=132496551
    alt: 推荐前-6-名-JavaScript-和-HTML5-游戏引擎
artid: 132496551
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     推荐前 6 名 JavaScript 和 HTML5 游戏引擎
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <em>
      <em>
       推荐：使用
      </em>
     </em>
     <a href="https://ted.sinoccdc.cn/" rel="nofollow" title="NSDT场景编辑器">
      NSDT场景编辑器
     </a>
     <em>
      <em>
       助你快速搭建3D应用场景
      </em>
     </em>
    </blockquote>
    <p>
     事实是，自从引入JavaScript WebGL API以来，现代浏览器具有直观的功能，使它们能够渲染更复杂和复杂的2D和3D图形，而无需依赖第三方插件。
    </p>
    <p>
     你可以用纯粹的JavaScript开始你的网页游戏开发之旅，如果你是初学者，这可能是最好的学习方式。但是，当有这么多被广泛采用的游戏引擎可供选择时，为什么要重新发明轮子呢？
    </p>
    <p>
     本指南将探索排名前六位的 JS/HTML5 游戏引擎，按 GitHub 星级的数量排名，并引导您了解如何使用它们。
    </p>
    <p>
     我们将介绍：
    </p>
    <ul>
     <li>
      Three.js
     </li>
     <li>
      Pixi.js
     </li>
     <li>
      Phaser
     </li>
     <li>
      Babylon.js
     </li>
     <li>
      Matter.js
     </li>
     <li>
      PlayCanvas
     </li>
    </ul>
    <h3>
     <strong>
      1. Three.js
     </strong>
    </h3>
    <p>
     Three.js 是最受欢迎的 JavaScript 库之一，用于使用 WebGL 在 Web 浏览器中创建和动画 3D 计算机图形。它也是为网络浏览器创建 3D 游戏的绝佳工具。
    </p>
    <p>
     由于 Three.js 基于 JavaScript，因此在 3D 对象和用户界面（如键盘和鼠标）之间添加任何交互性相对容易。这使得该库非常适合在网络上制作 3D 游戏。
    </p>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       易于学习
      </strong>
      ：Three.js最重要的优点——除了它能够很好地执行复杂的渲染——是它很容易上手。
     </li>
     <li>
      <strong>
       大量
      </strong>
      示例：由于其受欢迎程度，有无数示例可以帮助您入门。以下是一些示例项目，展示了 Three.js 的可能性：
     </li>
    </ul>
    <p>
    </p>
    <p class="img-center">
     <a href="http://https//codepen.io/ste-vg/pen/ppLQNW" rel="nofollow">
      <img alt="三.js示例项目" height="380" src="https://i-blog.csdnimg.cn/blog_migrate/881d2fda8b31ea82ff34e117d0713d01.gif" width="730"/>
     </a>
    </p>
    <p>
     <a href="http://https//codepen.io/Yakudoo/pen/YGxYej" rel="nofollow">
      <img alt="三.js 示例项目 2" src="https://blog.logrocket.com/wp-content/uploads/2020/09/threejs-example-project-2-1.gif"/>
     </a>
    </p>
    <p>
     <img alt="" height="428" src="https://i-blog.csdnimg.cn/blog_migrate/fabddd11251b526f7e85a77062a1994a.png" width="808">
      <img alt="三.js 示例项目 2" src="https://blog.logrocket.com/wp-content/uploads/2020/09/threejs-example-project-2-1.gif"/>
     </img>
    </p>
    <p>
     <img alt="" height="407" src="https://i-blog.csdnimg.cn/blog_migrate/889b191cbb5fe147c875735ce369ad31.png" width="810">
     </img>
    </p>
    <p>
    </p>
    <p>
     <a href="http://https//codepen.io/bsehovac/pen/EMyWVv" rel="nofollow">
      <img alt="三.js 示例项目 3" src="https://blog.logrocket.com/wp-content/uploads/2020/09/threejs-example-project-3-1.gif"/>
     </a>
    </p>
    <ul>
     <li>
      <strong>
       大型社区
      </strong>
      ：Three.js在GitHub上有87.1k星和33.4k分叉。它拥有大量用户和庞大的开发人员社区，他们使用并为库创建各种第三方工具和扩展
     </li>
     <li>
      <strong>
       良好的
      </strong>
      文档：强大的文档通常是强大库的重要指标，而 Three.js 拥有出色的文档
     </li>
     <li>
      <strong>
       出色的性能
      </strong>
      ：Three.js 比我使用过的其他库具有性能优势
     </li>
     <li>
      <strong>
       PBR渲染
      </strong>
      ：Three.js内置了基于物理的渲染（PBR），使渲染图形更准确
     </li>
    </ul>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       没有渲染管线
      </strong>
      ：这使得许多现代渲染技术无法/不可能用 Three 实现.js
     </li>
     <li>
      <strong>
       不是游戏引擎
      </strong>
      ：尽管 Three.js 拥有创建游戏的基本功能，但它不是像 PlayCanvas 和 Unity 那样提供交互性和渲染之外功能的游戏引擎。但是，可以构建 Three.js' API 来创建游戏引擎;这方面的一个例子是流氓引擎
     </li>
     <li>
      <strong>
       面向新手
      </strong>
      ：由于API迎合新手，因此隐藏了许多高级功能
     </li>
     <li>
      <strong>
       缺乏
      </strong>
      支持：没有对空间索引、精确光线投射或视锥剔除的内置支持，并且在复杂场景中碰撞检测效率低下
     </li>
    </ul>
    <h4>
     <strong>
      三.js在行动
     </strong>
    </h4>
    <p>
     如果您想深入研究在网络上创建简单或复杂的 3D 对象，Three.js 是首选库。它的主要优势包括庞大的人才用户社区以及丰富的示例和资源。
    </p>
    <p>
     Three.js是我合作的第一个3D动画库，我会推荐给任何刚开始游戏开发的人。
    </p>
    <p>
     让我们创建一个简单的旋转几何体来演示 Three.js 可以做什么：
    </p>
    <p>
     import * as THREE from 'js/three.module.js';
    </p>
    <p>
     var camera, scene, renderer;
     <br/>
     var geometry, material, mesh;
    </p>
    <p>
     animate();
    </p>
    <p>
     创建一个函数来设置使用 Three 运行演示动画所需的一切.js：
     <code>
      init
     </code>
    </p>
    <p>
     function init() {
     <!-- -->
     <br/>
     const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, .01, 20 );
     <br/>
     camera.position.z = 1;
    </p>
    <p>
     const scene = new THREE.Scene();
    </p>
    <p>
     const geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
     <br/>
     const material = new THREE.MeshNormalMaterial();
    </p>
    <p>
     const mesh = new THREE.Mesh( geometry, material );
     <br/>
     scene.add( mesh );
    </p>
    <p>
     const renderer = new THREE.WebGLRenderer( { antialias: true } );
     <br/>
     renderer.setSize( window.innerWidth, window.innerHeight );
     <br/>
     document.body.appendChild( renderer.domElement );
     <br/>
     }
    </p>
    <p>
     接下来，创建一个函数，以使用所需的运动类型对对象进行动画处理：
     <code>
      animate
     </code>
    </p>
    <p>
     function animate() {    init();    requestAnimationFrame( animate );    mesh.rotation.x += .01;    mesh.rotation.y += .02;    renderer.render( scene, camera );}
    </p>
    <p>
     最终结果应如下所示：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="旋转立方体演示由三个构建.js" height="431" src="https://i-blog.csdnimg.cn/blog_migrate/ddf29b1c80442afba224710b6a35d467.gif" width="720"/>
    </p>
    <h3>
     <strong>
      2.Pixi.js
     </strong>
    </h3>
    <p>
     如果您正在寻找一个JS库来创建支持跨平台应用程序的丰富交互式2D图形，那么Pixi.js就是您的最佳选择。这个HTML5创建引擎使你能够在没有WebGL API知识的情况下开发动画和游戏。
    </p>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       快速性能
      </strong>
      ：就像三.js，小精灵.js非常快
     </li>
     <li>
      <strong>
       大型社区
      </strong>
      ：Pixi.js 在 GitHub 上拥有 38.2k 颗星和 4.7k 个分支，拥有庞大的用户/开发人员社区
     </li>
     <li>
      <strong>
       多平台支持
      </strong>
      ：也像Three.js，Pixi.js支持多个平台，如Web和本机系统，如Android，iOS，Windows和mac
     </li>
     <li>
      <strong>
       简单的API
      </strong>
      ：API对于初学者来说很容易理解
     </li>
     <li>
      支持 WebGL 和 Canvas 回退：Pixi.js 使用
      <strong>
       WebGL
      </strong>
      渲染器，但也支持 Canvas 回退
     </li>
    </ul>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       过于复杂
      </strong>
      ：根据我的经验，Three.js比Pixi更容易上手.js
     </li>
     <li>
      <strong>
       不是一个完整的解决方案
      </strong>
      ：Pixi.js自豪地只支持渲染器
     </li>
    </ul>
    <h4>
     Pixi
     <strong>
      .js在行动
     </strong>
    </h4>
    <p>
     在大多数情况下，Pixi 是一个不错的选择，尤其是在创建面向性能的 3D 交互式图形并考虑设备兼容性时。Pixi在WebGL失败的情况下对Canvas回退的支持是一个特别诱人的功能。
    </p>
    <p>
     让我们构建一个简单的演示来了解 Pixi.js 的实际应用。使用以下命令或 CDN 将 Pixi.js 添加到项目中：
    </p>
    <p>
     npm install pixi.js
    </p>
    <p>
     或 CDN：
    </p>
    <p>
     &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js" &gt;&lt;/script&gt;
    </p>
    <p>
     创建脚本文件并添加以下代码：
    </p>
    <p>
     import * as PIXI from 'pixi.js';
    </p>
    <p>
     const app = new PIXI.Application();
     <br/>
     document.body.appendChild(app.view);
    </p>
    <p>
     app.loader.add('jumper', 'jumper.png').load((loader, resources) =&gt; {
     <!-- -->
     <br/>
     const bunny = new PIXI.Sprite(resources.bunny.texture);
     <br/>
     bunny.x = app.renderer.width / 2;
     <br/>
     bunny.y = app.renderer.height / 2;
    </p>
    <pre><code>bunny.anchor.x = .5;
bunny.anchor.y = .5;

app.stage.addChild(bunny);

app.ticker.add(() =&gt; {
    bunny.rotation += .01;
});
</code></pre>
    <p>
     });
    </p>
    <p>
     结果应如下所示：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="貔貅.js演示" height="535" src="https://i-blog.csdnimg.cn/blog_migrate/5ab414f4784bf4521e1d2344e513189f.gif" width="720"/>
    </p>
    <h3>
     3. Phaser
    </h3>
    <p>
     Phaser 是一个跨平台的游戏引擎，使您能够创建基于 JavaScript 和 HTML5 的游戏，并为许多平台进行编译。例如，您可能决定使用第三方工具将游戏编译为 iOS、Android 和其他本机应用程序。
    </p>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       结构合理
      </strong>
      ：众所周知，移相器具有精心设计的结构
     </li>
     <li>
      <strong>
       TypeScript
      </strong>
      支持：该库支持使用 TypeScript 进行游戏开发
     </li>
     <li>
      <strong>
       专注于游戏开发
      </strong>
      ：Phaser主要是一个游戏开发引擎——而且是一个很好的引擎。
     </li>
     <li>
      <strong>
       大型社区
      </strong>
      ：虽然没有前两个库那么大，但 Phaser 在 GitHub 上拥有 33.2k 星和 6.9k 分叉的庞大社区
     </li>
     <li>
      <strong>
       插件很多
      </strong>
      ：Phaser支持大量的插件。这包括相位器-物质-碰撞、导航网格、移相器输入和光滑的 ui 插件，仅举几例
     </li>
     <li>
      <strong>
       WebGL和
      </strong>
      Canvas支持：Phaser支持WebGL，并启用了Canvas作为后备
     </li>
    </ul>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       构建大小
      </strong>
      ：桌面版 Phaser 的构建大小非常庞大
     </li>
     <li>
      <strong>
       对移动开发的支持不佳
      </strong>
      ：创建本机移动应用程序需要使用Cordova或其他第三方框架
     </li>
     <li>
      <strong>
       状态管理
      </strong>
      ：开始使用 Phaser 的状态管理器可能有些困难
     </li>
    </ul>
    <h4>
     <strong>
      移相器在行动
     </strong>
    </h4>
    <p>
     Phaser 非常适合开发跨平台游戏应用程序。它支持广泛的插件，并且使用Phaser构建游戏的大型开发人员社区使开始使用该框架变得容易。
    </p>
    <p>
     让我们使用 Phaser 构建一个基本应用程序。首先，将 Phaser 安装为 Node 模块或通过 CDN：
    </p>
    <p>
     npm install phaser
    </p>
    <p>
     或：
    </p>
    <p>
     &lt;script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"&gt;&lt;/script&gt;
    </p>
    <p>
     接下来，将一些默认配置传递给您的 Phaser 引擎：
    </p>
    <p>
     const config = {
     <!-- -->
     <br/>
     type: Phaser.AUTO,
     <br/>
     width: 800,
     <br/>
     height: 600,
     <br/>
     physics: {
     <!-- -->
     <br/>
     default: "arcade",
     <br/>
     arcade: {
     <!-- -->
     <br/>
     gravity: { y: 200 },
     <br/>
     },
     <br/>
     },
     <br/>
     scene: {
     <!-- -->
     <br/>
     preload: preload,
     <br/>
     create: create,
     <br/>
     },
     <br/>
     };
    </p>
    <p>
     const game = new Phaser.Game(config);
    </p>
    <p>
     创建一个预加载函数以加载默认静态文件：
    </p>
    <p>
     function preload() {
     <!-- -->
     <br/>
     this.load.setBaseURL("
     <a href="https://labs.phaser.io/" rel="nofollow" title="https://labs.phaser.io">
      https://labs.phaser.io
     </a>
     ");
     <br/>
     this.load.image("sky", "assets/skies/space3.png");
     <br/>
     this.load.image("plane", "assets/sprites/ww2plane.png");
     <br/>
     this.load.image("green", "assets/particles/green.png");
     <br/>
     this.load.image("astroid", "assets/games/asteroids/asteroid1.png");
     <br/>
     this.load.image("astroid2", "assets/games/asteroids/asteroid1.png");
     <br/>
     this.load.image("astroid3", "assets/games/asteroids/asteroid1.png");
     <br/>
     }
    </p>
    <p>
     最后，定义一个函数来显示新创建的游戏：
     <code>
      create
     </code>
    </p>
    <p>
     function create() {
     <!-- -->
     <br/>
     this.add.image(400, 300, "sky");
     <br/>
     this.add.image(700, 300, "astroid");
     <br/>
     this.add.image(100, 200, "astroid2");
     <br/>
     this.add.image(400, 40, "astroid3");
    </p>
    <p>
     const particles = this.add.particles("green");
    </p>
    <p>
     const emitter = particles.createEmitter({
     <!-- -->
     <br/>
     speed: 100,
     <br/>
     scale: { start: 1, end: 0 },
     <br/>
     blendMode: "ADD",
     <br/>
     });
    </p>
    <p>
     const plane = this.physics.add.image(400, 100, "plane");
     <br/>
     plane.setVelocity(100, 200);
     <br/>
     plane.setBounce(1, 1);
     <br/>
     plane.setCollideWorldBounds(true);
     <br/>
     emitter.startFollow(plane);
     <br/>
     }
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="移相器.js演示" height="547" src="https://i-blog.csdnimg.cn/blog_migrate/c8ed78db249b93936415e5f2017273ce.gif" width="730"/>
    </p>
    <h3>
     <strong>
      4.
     </strong>
     Babylon
     <strong>
      .js
     </strong>
    </h3>
    <p>
     Babylon.js是一个强大，简单，开放的游戏和渲染引擎，打包在一个友好的JavaScript框架中。
    </p>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <ul>
     <li>
      Playground：Babylon提供了一个
      <strong>
       Playground
      </strong>
      工具，用于在进入全面开发之前进行测试 - 并且它有很好的文档可以启动。
     </li>
     <li>
      <strong>
       强大的社区支持
      </strong>
      ：Babylon有一个论坛，里面有一个活跃的开发人员和用户的大型社区，他们非常有帮助。该框架在GitHub上有18.9k星和3k分叉
     </li>
     <li>
      <strong>
       最新的代码
      </strong>
      库：该框架享有经常更新的代码库和活跃的第三方工具开发。
      <a href="https://github.com/BabylonJS/Babylon.js" title="官方">
       官方
      </a>
      回购文件最近于11/26/22更新
     </li>
     <li>
      PBR 渲染：对
      <strong>
       PBR 渲染
      </strong>
      支持非常出色
     </li>
     <li>
      <strong>
       信任投票
      </strong>
      ：Babylon被Adobe，Microsoft等大品牌使用和支持
     </li>
     <li>
      <strong>
       维护
      </strong>
      ：错误通常会很快得到解决
     </li>
    </ul>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       缺乏成熟度
      </strong>
      ：巴比伦于2013年首次发布，与许多竞争对手相比，它相当年轻
     </li>
     <li>
      <strong>
       文档
      </strong>
      ：引擎缺少 API 文档
     </li>
     <li>
      不适合小型项目
     </li>
    </ul>
    <h4>
     Babylon
     <strong>
      .js在行动
     </strong>
    </h4>
    <p>
     许多大品牌都信任巴比伦.js作为他们选择的游戏开发引擎。Babylon Playground 是一个蓬勃发展的代码示例中心，是帮助您开始使用框架的绝佳工具。
    </p>
    <p>
     巴比伦及其模块发布在npm上。若要安装它，请在命令行工具中运行以下命令：
    </p>
    <p>
     npm install babylonjs --save
    </p>
    <p>
     或者，您可以通过 CDN 将库集成到项目中。为此，请创建一个文件并添加以下代码：
     <code>
      index.html
     </code>
    </p>
    <p>
     &lt;canvas id="renderCanvas"&gt;&lt;/canvas&gt;
    </p>
    <p>
     &lt;script src="https://cdn.babylonjs.com/babylon.js"&gt;&lt;/script&gt;
    </p>
    <p>
     &lt;script src="script.js"&gt;&lt;/script&gt;
    </p>
    <p>
     安装后，您可以通过导入全局对象或解构场景和引擎方法来开始使用库，如下所示：
    </p>
    <p>
     import * as BABYLON from 'babylonjs'
    </p>
    <p>
     // OR
    </p>
    <p>
     import { Scene, Engine } from 'babylonjs'
    </p>
    <p>
     接下来，创建一个文件并包含以下代码：
     <code>
      script.js
     </code>
    </p>
    <p>
     const { createScene } = require('scene.js')
    </p>
    <p>
     window.addEventListener('DOMContentLoaded', function(){
     <!-- -->
     <br/>
     const canvas = document.getElementById('renderCanvas');
     <br/>
     const engine = new BABYLON.Engine(canvas, true);
     <br/>
     const scene = createScene();
     <br/>
     engine.runRenderLoop(function(){
     <!-- -->
     <br/>
     scene.render();
     <br/>
     });
     <br/>
     window.addEventListener('resize', function(){
     <!-- -->
     <br/>
     engine.resize();
     <br/>
     });
     <br/>
     });
    </p>
    <p>
     创建一个文件并添加以下代码：
     <code>
      scene.js
     </code>
    </p>
    <p>
     export function(){
     <!-- -->
     <br/>
     const scene = new BABYLON.Scene(engine);
     <br/>
     const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 5,-10), scene);
     <br/>
     camera.setTarget(BABYLON.Vector3.Zero());
     <br/>
     camera.attachControl(canvas, false);
     <br/>
     const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0,1,0), scene);
     <br/>
     const sphere = BABYLON.Mesh.CreateSphere('sphere', 16, 2, scene);
     <br/>
     sphere.position.y = 1;
     <br/>
     const ground = BABYLON.Mesh.CreateGround('ground', 6, 6, 2, scene);
     <br/>
     return scene;
     <br/>
     }
    </p>
    <p>
     以下是动画外观的预览：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="巴比伦.js演示" height="526" src="https://i-blog.csdnimg.cn/blog_migrate/c744b028a7d3cb30f6ce9b3cc1cf23b9.gif" width="720"/>
    </p>
    <h3>
     <strong>
      5.
     </strong>
     Matter
     <strong>
      .js
     </strong>
    </h3>
    <p>
     Matter.js是一个用于Web的JavaScript 2D刚体物理引擎。即使它是一个JavaScript物理引擎，你也可以将它与各种包和插件结合起来，创建有趣的网页游戏。
    </p>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       令人兴奋的功能
      </strong>
      ：Matter.js提供了许多功能，例如刚性、复合体和复合材料体、稳定的堆叠和静止、运动守恒等等
     </li>
    </ul>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       无CCD
      </strong>
      ：Matter.js缺乏连续碰撞检测（CCD）会导致快速移动的物体穿过其他物体的问题
     </li>
    </ul>
    <h4>
     <strong>
      物质.js在行动
     </strong>
    </h4>
    <p>
     Matter.js 本质上是创建简单、移动的动画对象的最佳库。Matter.js是一个物理库，更关注2D对象。但是，您可以将其与第三方解决方案结合使用以创建动态游戏。
    </p>
    <p>
     要开始使用 Matter.js在原版项目中，请下载 or
     <code>
      matter。最小值.js
     </code>
     从官方 GitHub 存储库打包文件，并使用以下代码将其添加到 HTML 文件中：
     <code>
      matter.js
     </code>
    </p>
    <p>
     &lt;script src="matter.js"&gt;&lt;/script&gt;
    </p>
    <p>
     但是，如果您使用的是捆绑器，例如 Parcel，则可以通过以下命令将软件包安装为 Node 模块：
     <code>
      npm
     </code>
     <code>
      yarn
     </code>
    </p>
    <p>
     npm install matter-js
     <br/>
     //OR
     <br/>
     yarn add matter-js
    </p>
    <p>
     以下是使用内置渲染器和运行器入门的最小示例：
    </p>
    <p>
     // module aliases
     <br/>
     const Engine = Matter.Engine;
     <br/>
     const Render = Matter.Render;
     <br/>
     const World = Matter.World;
     <br/>
     const Bodies = Matter.Bodies;
    </p>
    <p>
     // create an engine
     <br/>
     const engine = Engine.create();
    </p>
    <p>
     // instantiating the renderer
     <br/>
     const render = Render.create({
     <!-- -->
     <br/>
     element: document.body,
     <br/>
     engine: engine,
     <br/>
     options: {
     <!-- -->
     <br/>
     wireframes: false,
     <br/>
     showAngleIndicator: false,
     <br/>
     background: "white",
     <br/>
     },
     <br/>
     });
    </p>
    <p>
     // create two boxes and a ground
     <br/>
     const boxA = Bodies.rectangle(300, 300, 70, 70);
     <br/>
     const boxB = Bodies.rectangle(400, 10, 60, 60);
     <br/>
     const ground = Bodies.rectangle(300, 510, 910, 10, { isStatic: true });
    </p>
    <p>
     // add all bodies to the world
     <br/>
     World.add(engine.world, [boxA, boxB, ground]);
    </p>
    <p>
     // run the engine
     <br/>
     Matter.Runner.run(engine);
    </p>
    <p>
     // run the renderer
     <br/>
     Render.run(render);
    </p>
    <hr/>
    <p>
     你应该看到两个矩形物体掉落，然后在它们落在地面上时相互撞击。如果没有，请检查浏览器控制台以查看是否有任何错误：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="重要.js演示" height="501" src="https://i-blog.csdnimg.cn/blog_migrate/9a09188aadae4dc6c12c5be1977fa8a2.gif" width="730"/>
    </p>
    <h3>
     <strong>
      6.
     </strong>
     PlayCanvas
    </h3>
    <p>
     PlayCanvas使用HTML5和WebGL在任何移动或桌面浏览器中运行游戏和其他交互式3D内容。虽然它是免费和开源的，但PlayCanvas更关注游戏引擎而不是渲染引擎。因此，它更适合创建
     <br/>
     使用WebGL和HTML3 Canvas的5D游戏。
    </p>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       游戏引擎
      </strong>
      ：与其他引擎不同，PlayCanvas 是一个游戏引擎，具有您在库或框架中找不到的功能
     </li>
     <li>
      <strong>
       开源
      </strong>
      ：PlayCanvas是一个开源工具，用于强大的游戏开发
     </li>
     <li>
      移动优化：游戏开发平台
      <strong>
       移动
      </strong>
      优先
     </li>
     <li>
      零编译时间：引擎的
      <strong>
       零编译时间
      </strong>
      自然使过程更快
     </li>
     <li>
      <strong>
       资产管道
      </strong>
      ：PlayCanvas 使用最佳做法来决定内容的交付方式和形式
     </li>
     <li>
      <strong>
       集成
      </strong>
      物理引擎：您可以使用强大的子弹物理引擎弹药轻松地将物理集成到游戏中.js
     </li>
     <li>
      <strong>
       热重载
      </strong>
      ：您不必每次进行更改时都重新加载浏览器
     </li>
     <li>
      <strong>
       仅在浏览器上运行的渲染引擎
      </strong>
      ：PlayCanvas具有仅在浏览器上运行的高级WebGL功能
     </li>
    </ul>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       付费
      </strong>
      专用项目：免费层不支持私有项目，因此所有代码和资源都公开托管
     </li>
     <li>
      碰撞偏移：没有
      <strong>
       碰撞偏移
      </strong>
     </li>
     <li>
      <strong>
       缺乏示例
      </strong>
      ：PlayCanvas 的教程很少而且相距甚远
     </li>
    </ul>
    <h4>
     <strong>
      PlayCanvas 在行动
     </strong>
    </h4>
    <p>
     PlayCanvas非常适合创建小型公共项目或学校项目 - 至少，这是我使用它的目的。如果您需要更多功能和对游戏开发的更多控制，您可能需要考虑订阅高级功能。
    </p>
    <p>
     现在，让我们使用引擎进行一些基本的渲染。第一步，从 Git
     <a href="https://code.playcanvas.com/playcanvas-latest.min.js" rel="nofollow" title="H">
      H
     </a>
     ub 存储库下载包文件，并使用以下代码将其添加到项目中：
    </p>
    <p>
     &lt;script src='https://code.playcanvas.com/playcanvas-stable.min.js'&gt;
    </p>
    <p>
     接下来，使用以下代码创建一个文件并将其链接到 HTML 文件：
     <code>
      script.js
     </code>
    </p>
    <p>
     &lt;canvas id='canvas'&gt;&lt;/canvas&gt;    &lt;script src='/script.js'&gt;
    </p>
    <p>
     现在，打开该文件并添加以下代码以实例化新的 PlayCanvas 应用程序：
     <code>
      script.js
     </code>
    </p>
    <p>
     const canvas = document.getElementById('canvas');
     <br/>
     const app = new pc.Application(canvas);
    </p>
    <p>
     window.addEventListener('resize', () =&gt; app.resizeCanvas());
    </p>
    <p>
     const box = new pc.Entity('cube');
     <br/>
     box.addComponent('model', {
     <!-- -->
     <br/>
     type: 'box'
     <br/>
     });
     <br/>
     app.root.addChild(box);
    </p>
    <p>
     要为对象创建相机和光源，请添加以下代码：
    </p>
    <p>
     const camera = new pc.Entity('camera');
     <br/>
     camera.addComponent('camera', {
     <!-- -->
     <br/>
     clearColor: new pc.Color(.1, .1, .1)
     <br/>
     });
     <br/>
     app.root.addChild(camera);
     <br/>
     camera.setPosition(0, 0, 3);
    </p>
    <p>
     const light = new pc.Entity('light');
     <br/>
     light.addComponent('light');
     <br/>
     app.root.addChild(light);
     <br/>
     light.setEulerAngles(46, 0, 0);
    </p>
    <p>
     app.on('update', dt =&gt; box.rotate(10 * dt, 20 * dt, 30 * dt));
    </p>
    <p>
     app.start();
    </p>
    <p>
     上面的代码应产生以下结果：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="PlayCanvas 旋转立方体演示" height="489" src="https://i-blog.csdnimg.cn/blog_migrate/e74550af0d10369e027073df7cdc8de7.gif" width="720"/>
    </p>
    <h3>
     <strong>
      结语
     </strong>
    </h3>
    <p>
     通过分解与上面列出的每个 JS/HTML5 游戏引擎相关的优缺点和用例，我希望您能深入了解哪一个最适合您想要创建的游戏或动画类型。
    </p>
    <p>
     在大多数情况下，我建议使用 Three.js，特别是如果您正在寻找更多的渲染引擎而不是游戏引擎。由于它在开发人员生态系统中的受欢迎程度，很容易找到充足的资源来帮助您启动和运行。
    </p>
    <p>
     如果你更关注游戏开发，我会推荐巴比伦.js因为它很简单。Babylon还具有更新的代码库和活跃的第三方开发，游乐场功能是一个很好的测试工具。PlayCanvas是一个可靠的备份选项 - 它主要是一个游戏引擎，您可以使用它来构建复杂的3D游戏。
    </p>
    <p>
     您在游戏开发项目中使用什么游戏引擎？请在评论中告诉我们！
    </p>
    <h3>
     <strong>
      <strong>
       LogRocket：通过理解上下文更轻松地调试JavaScript错误
      </strong>
     </strong>
    </h3>
    <p>
     调试代码始终是一项繁琐的任务。但是，您越了解错误，就越容易修复它们。
    </p>
    <p>
     LogRocket 允许您以新颖独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与 JavaScript 前端的互动情况，使您能够准确了解用户导致错误的行为。
    </p>
    <p>
    </p>
    <p class="img-center">
     <a href="https://lp.logrocket.com/blg/javascript-signup" rel="nofollow">
      <img alt="日志火箭仪表板免费试用横幅" height="407" src="https://i-blog.csdnimg.cn/blog_migrate/b3ad9cc5cfc5e988e034047f76790bae.gif" width="800"/>
     </a>
    </p>
    <p>
     LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、带有标头 + 正文的慢速网络请求/响应、浏览器元数据和自定义日志。了解 JavaScript 代码的影响从未如此简单！
    </p>
    <p>
     原文链接：
     <a href="https://www.mvrlink.com/javascript-and-html5-game-engines/" rel="nofollow" title="推荐前 6 名 JavaScript 和 HTML5 游戏引擎 (mvrlink.com)">
      推荐前 6 名 JavaScript 和 HTML5 游戏引擎 (mvrlink.com)
     </a>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
</div>


