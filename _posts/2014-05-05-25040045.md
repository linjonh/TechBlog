---
layout: post
title: "安卓2048源码解析"
date: 2014-05-05 12:24:15 +0800
description: "安卓2048源码解析2014年4月24日联系商易上海电子商务网站建设，了解更多 2048游戏比来很火"
keywords: "2048 游戏安卓adt重新开始按钮"
categories: ['']
tags: ['无标签']
artid: "25040045"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=25040045
    alt: "安卓2048源码解析"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     安卓2048源码解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <table align="center" border="0" cellspacing="0" style="border-spacing:0px; border-collapse:collapse; color:rgb(102,102,102); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:12px; line-height:18px; background-color:rgb(240,240,240)" width="500">
     <tbody>
      <tr style="color:rgb(51,51,51); font-family:����,Verdana,Arial; line-height:24px">
       <td align="center" style="font-size:16px; color:rgb(102,102,102); font-family:����,Verdana,Arial; font-weight:600; border-bottom-style:dashed; border-bottom-width:1px; border-bottom-color:rgb(204,204,204)">
        安卓2048源码解析
        <br/>
       </td>
      </tr>
      <tr style="color:rgb(51,51,51); font-family:����,Verdana,Arial; line-height:24px">
       <td style="font-size:14px; color:rgb(102,102,102); font-family:����,Verdana,Arial">
        <span style="float:left">
         2014年4月24日
        </span>
        <span style="float:right">
         联系商易上海电子商务网站建设，了解更多
        </span>
       </td>
      </tr>
      <tr style="color:rgb(51,51,51); font-family:����,Verdana,Arial; line-height:24px">
       <td style="font-size:14px; color:rgb(102,102,102); font-family:����,Verdana,Arial">
       </td>
      </tr>
      <tr style="color:rgb(51,51,51); font-family:����,Verdana,Arial; line-height:24px">
       <td style="font-size:14px; color:rgb(102,102,102); font-family:����,Verdana,Arial">
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
        </p>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         2048游戏比来很火，想看下源码，却不会JavaScript。网上搜了搜安卓版的源码，测验测验下来进修。
        </p>
        <br/>
        <h3 style="padding:4px 10px 0px; margin:0px; font-size:12px; font-weight:normal; line-height:18px; position:relative; height:21px; color:white; overflow:hidden">
         uberspot
        </h3>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         在https://github.com/uberspot/2048-android 上方发了然一个安卓版的2048代码，于是筹办浏览。却发明源文件中只有一个Java类，MainActivity.java。打开大致看了一下：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">// If there is a previous instance restore it in the webview

if （savedInstanceState != null） {

    mWebView.restoreState（savedInstanceState）;

} else {

    mWebView.loadUrl（"file:///android_asset/2048/index.html"）;

}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         本来是用一个webview对底本的JavaScript进行了封装，应用安卓内部webkit浏览器进行了加载。相当于用浏览器玩网页版的游戏，只能再搜刮了。
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
        </p>
        <br/>
        <h3 align="left" style="padding:4px 10px 0px; margin:0px; font-size:12px; font-weight:normal; line-height:18px; position:relative; height:21px; color:white; overflow:hidden">
         极客学院
        </h3>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         别的找到一个极客学院版本的源码，在网站上方还有视频教程。本文解析的首要内容就是极客学院版本的源代码了，作者是ime。
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         源码链接：https://github.com/plter/Android2048GameLesson
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         解析的目标为code\ide\ADT\Game2048Publish目次中的源码版本
        </p>
        <br/>
        <h4 style="padding:0px; margin:0px; font-size:14px; line-height:18px; color:rgb(125,140,165); word-spacing:-0.1em">
         1 界面
        </h4>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         界面斗劲简单了，打开activity_main.xml看看，几个TextView，一个按钮，还有三个自定义的控件GameView，AnimLayer，Card。游戏的截图如下：
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         <img alt="image" border="0" height="296" src="http://images.cnitblog.com/blog/466411/201404/241552526078329.png" style="border-style:none; padding-top:0px; padding-left:0px; display:inline; padding-right:0px; border-width:0px" title="image" width="254"/>
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         标准控件就不介绍了，介绍一系三个自定义的控件。
        </p>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         1.1 Card（后文混用Card 卡片 方块三个词语）
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         类Card持续了FrameLayout，目标是作为游戏中的卡片。卡片数字和样式的实现：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">public void setNum（int num） {

        this.num = num;



        if （num&lt;=0） {

            label.setText（""）;

        }else{

            label.setText（num+""）;

        }



        switch （num） {

        case 0:

            label.setBackgroundColor（0 x00000000）;//透明色

            break;

        case 2:

            label.setBackgroundColor（0 xffeee4da）;

            break;

        case 4:

            label.setBackgroundColor（0 xffede0c8）;

            break;

        case 8:

            label.setBackgroundColor（0 xfff2b179）;

            break;

        case 16:

            label.setBackgroundColor（0 xfff59563）;

            break;

            ……

             default:

            label.setBackgroundColor（0 xff3c3a32）;

            break;

        }

}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         num&lt;=0注解是空白方格。当前地位上若是没有card，则应用num&lt;=0的card进行调换。card 0没有label，同时底色为透明。除了card 0之外，card 2之后的卡片都有对应的色彩和数字。
        </p>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         1.2 AnimLayer
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         类AnimLayer持续了FramLayout，用于动画显现。在极客学院安卓2048最首要由两个动画：卡片移动和卡片呈现。
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         a） 对于卡片呈现动画：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">//目标卡片

public void createScaleTo1（Card target）{

    //缩放

     ScaleAnimation sa = new ScaleAnimation（0.1f， 1， 0.1f， 1， Animation.RELATIVE_TO_SELF， 0.5f， Animation.RELATIVE_TO_SELF， 0.5f）;

    sa.setDuration（100）;

    target.setAnimation（null）;

    target.getLabel（）.startAnimation（sa）;

   }</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         b） 对于卡片移动动画：
        </p>
        <br/>
        <pre><code class="language-java">应用ArrayList&lt;Card&gt; cards用于经管姑且卡片的创建和收受接管（避免每次创建姑且卡片时创建新的对象）</code></pre>
        <br/>
        <pre><code class="language-java">创建一个姑且卡片，从卡片移动到卡片to，当完成动画之后将姑且卡片设为不成见，并应用cards收受接管该卡片。</code></pre>
        <br/>
        <pre><code class="language-java">创建卡片：</code></pre>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private Card getCard（int num）{

    Card c;

    if （cards.size（）&gt;0） {

        c = cards.remove（0）;

    }else{

        c = new Card（getContext（））;

        addView（c）;

    }

    c.setVisibility（View.VISIBLE）;

    c.setNum（num）;

    return c;

  }</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         创建卡片时，若是cards不为空，则从cards队首取出一张姑且卡片。（这里认为应用LinkedList&lt;Card&gt;加倍合适姑且卡片经管队列）
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         收受接管卡片：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private void recycleCard（Card c）{

    c.setVisibility（View.INVISIBLE）;

    c.setAnimation（null）;

    cards.add（c）;

  }</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         收受接管卡片将当前卡片设为不成见，并参加到cards中。
        </p>
        <br/>
        <p class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;" style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         卡片移动：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">public void createMoveAnim（final Card ，final Card to，int X，int toX，int Y，int toY）{

    //姑且卡片

    final Card c = getCard（.getNum（））;



    //设置布局

    LayoutParams lp = new LayoutParams（Config.CARD_WIDTH， Config.CARD_WIDTH）;

    lp.leftMargin = X*Config.CARD_WIDTH;

    lp.topMargin = Y*Config.CARD_WIDTH;

    c.setLayoutParams（lp）;



    if （to.getNum（）&lt;=0） {

        to.getLabel（）.setVisibility（View.INVISIBLE）;

    }

    //从卡片地位移动到to卡片

    TranslateAnimation ta = new TranslateAnimation（0， Config.CARD_WIDTH*（toX-X）， 0， Config.CARD_WIDTH*（toY-Y））;

    ta.setDuration（25）;

    ta.setAnimationListener（new Animation.AnimationListener（） {



        ＠Override

        public void onAnimationStart（Animation animation） {}



        ＠Override

        public void onAnimationRepeat（Animation animation） {}



        //动画停止，将姑且卡片收受接管

        ＠Override

        public void onAnimationEnd（Animation animation） {

            to.getLabel（）.setVisibility（View.VISIBLE）;

            recycleCard（c）;

        }

    }）;

    c.startAnimation（ta）;



  }</pre>
         <br/>
        </div>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         1.3 GameView
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         GameView持续了GridLayout，包含了界面和游戏逻辑两个项目组。这里介绍界面。
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         界面中斗劲首要的内容就是手势辨认，用于操控格子的移动：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private void initGameView（）{

    setColumnCount（Config.LINES）;

    setBackgroundColor（0 xffbbada0）;

    setOnTouchListener（new View.OnTouchListener（） {



        private float startX，startY，offsetX，offsetY;



        ＠Override

        public boolean onTouch（View v， MotionEvent event） {



            switch （event.getAction（）） {

                case MotionEvent.ACTION_DOWN://按下坐标

                    startX = event.getX（）;

                    startY = event.getY（）;

                    break;

                case MotionEvent.ACTION_UP:

                    offsetX = event.getX（）-startX;

                    offsetY = event.getY（）-startY;

                    if （Math.abs（offsetX）&gt;Math.abs（offsetY）） {

                        if （offsetX&lt;-5） {

                            swipeLeft（）;

                        }else if （offsetX&gt;5） {

                            swipeRight（）;

                        }

                    }else{

                        if （offsetY&lt;-5） {

                            swipeUp（）;

                        }else if （offsetY&gt;5） {

                            swipeDown（）;

                        }

                    }

                    break;

            }

            return true;//listener已经处理惩罚了事务

        }

    }）;

     }</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         应用了View.OnTouchListener来侦听触摸事务：策画按下和抬起来时offsetX和offsetY，猜测手势的移动。
        </p>
        <br/>
        <h4 style="padding:0px; margin:0px; font-size:14px; line-height:18px; color:rgb(125,140,165); word-spacing:-0.1em">
         2 游戏逻辑
        </h4>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         上一节介绍了根蒂根基的界面显现，本节介绍营业逻辑，即游戏实现道理。
        </p>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         2.1 游戏初始化
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         调用函数initGameView（）完成游戏初始化：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private void initGameView（）{

    setColumnCount（Config.LINES）;//设置行数量

    setBackgroundColor（0 xffbbada0）;





    setOnTouchListener（new View.OnTouchListener（） {

        }

    }）;

}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         设置控件的方格数量，随后设置了控件北京，最后注册了刚才解析过的触摸事务器。此时游戏已经筹办好了，正式开端。
        </p>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         2.2 开端游戏
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         函数startGame（）;正式开端游戏，起首向方格内随机写入两个方块：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">public void startGame（）{



    MainActivity aty = MainActivity.getMainActivity（）;

    aty.clearScore（）;

    aty.showBestScore（aty.getBestScore（））;



    for （int y = 0; y &lt; Config.LINES; y++） {

        for （int x = 0; x &lt; Config.LINES; x++） {

            cardsMap[x][y].setNum（0）;

        }

    }



    addRandomNum（）;

    addRandomNum（）;

}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         这个函数addRandomNum（）向游戏面板内随机参加两个方块，开端游戏:
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private void addRandomNum（）{

    //private List&lt;Point&gt; emptyPoints = new ArrayList&lt;Point&gt;（）; 

    emptyPoints.clear（）;



    //将所有空格子汇集起来

    for （int y = 0; y &lt; Config.LINES; y++） {

        for （int x = 0; x &lt; Config.LINES; x++） {

            if （cardsMap[x][y].getNum（）&lt;=0） {

                emptyPoints.add（new Point（x， y））;

            }

        }

    }



    if （emptyPoints.size（）&gt;0） {

        //随机地位生成一个card

        Point p = emptyPoints.remove（（int）（Math.random（）*emptyPoints.size（）））;

        int num = Math.random（）&gt;0.1？2:4;

        cardsMap[p.x][p.y].setNum（num）;

        MainActivity.getMainActivity（）.getAnimLayer（）.createScaleTo1（cardsMap[p.x][p.y]）;

    }

}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         函数addRandomNum（）向面板中空的格子中随机生成一个卡片。起首汇集面板中所有空的地位，汇集到一个List中，最后生成随机数，随机生成一个数字，并完成天活泼画。
        </p>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         2.3 移动
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         2048游戏经由过程游戏中所有的方格朝某个标的目标移动，归并雷同数字的方块。有四个函数负责移动，分别是高低阁下，这里只解析一个标的目标。
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private void swipeLeft（）{



    boolean merge = false;//是否归并卡片， 1空卡片和已有卡片归并 2两个数字雷同的卡片归并



    for （int y = 0; y &lt; Config.LINES; y++） {//对所有列

        for （int x = 0; x &lt; Config.LINES; x++） {

            //搜检当前点的右侧是否有非空卡片（非空：num&gt;=2）

            for （int x1 = x+1; x1 &lt; Config.LINES; x1++） {

                if （cardsMap[x1][y].getNum（）&gt;0） {//若是右边有非空卡片



                    if （cardsMap[x][y].getNum（）&lt;=0） {//当前坐标上没有格子（空卡片和已有卡片归并）



                        MainActivity.getMainActivity（）.getAnimLayer（）.createMoveAnim（cardsMap[x1][y]，cardsMap[x][y]， x1， x， y， y）;



                        cardsMap[x][y].setNum（cardsMap[x1][y].getNum（））;

                        cardsMap[x1][y].setNum（0）;



                        x--;//和空卡片归并，还须要从当前地位策画（不然：|0|2|2|2|左移之后变为|2|2|2|0|）

                        merge = true;



                    }else if （cardsMap[x][y].equals（cardsMap[x1][y]）） {

                        MainActivity.getMainActivity（）.getAnimLayer（）.createMoveAnim（cardsMap[x1][y]， cardsMap[x][y]，x1， x， y， y）;

                        cardsMap[x][y].setNum（cardsMap[x][y].getNum（）*2）;

                        cardsMap[x1][y].setNum（0）;



                        MainActivity.getMainActivity（）.addScore（cardsMap[x][y].getNum（））;

                        merge = true;

                    }



                    break;

                }

            }

        }

    }



    //只要有随便率性一行产生过卡片移动，则须要产生新的卡片

    if （merge） {



        addRandomNum（）;

        checkComplete（）;//断定当前游戏是否失败

    }

}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         左移，针对面板中所有列，将每行的方块向左移动。在两种景象产生卡片归并：
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         1 当前地位为空卡片，右侧为非空卡片，归并后当前地位卡片Num为右侧卡片，右侧卡片清零。
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         2 当前地位为非空卡片，右侧卡片数值和它相等，归并后当前地位卡片数量翻倍，右侧卡片清零。
        </p>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         从游戏角度来讲：1 对应卡片纯真的移动，2 对应两张雷同卡片的归并。是以，只要产生卡片本质上的移动，就应当随机再临盆一个卡片，调用addRandomNum（）。
        </p>
        <br/>
        <h5 style="padding:0px; margin:5px 0px; font-size:12px; line-height:18px; color:black">
         2.4 游戏停止的断定
        </h5>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         每次产生卡片移动，都要搜检游戏还可否持续，是否已经停止。函数checkComplete（）完成游戏失败（感触感染叫做checkFailure（）更好）的搜检：
        </p>
        <br/>
        <div class="cnblogs_code" style="padding:0px; margin:0px">
         <br/>
         <pre style="padding:0px; margin-top:0px; margin-bottom:0px; font-size:1em">private void checkComplete（）{



    boolean complete = true;



ALL:

    for （int y = 0; y &lt; Config.LINES; y++） {

        for （int x = 0; x &lt; Config.LINES; x++） {

            //满足随便率性两个前提，游戏就可以持续：1 有空的格子，2 有可以归并的卡片

            if （cardsMap[x][y].getNum（）==0||//1 有多余空间

                    （x&gt;0&amp;&amp;cardsMap[x][y].equals（cardsMap[x-1][y]））||//2 和左面相等

                    （x&lt;Config.LINES-1&amp;&amp;cardsMap[x][y].equals（cardsMap[x+1][y]））|//2 和右面相等

                    （y&gt;0&amp;&amp;cardsMap[x][y].equals（cardsMap[x][y-1]））||//2 和上方相等

                    （y&lt;Config.LINES-1&amp;&amp;cardsMap[x][y].equals（cardsMap[x][y+1]））） {//2 和下面相等



                complete = false;

                break ALL;

        }

    }

    if （complete） {

        new AlertDialog.Builder（getContext（））.setTitle（"你好"）.setMessage（"游戏停止"）.setPositiveButton（"从头开端"， new DialogInterface.OnClickListener（） {



            ＠Override

            public void onClick（DialogInterface dialog， int which） {

                startGame（）;

            }

        }）.show（）;

    }



}</pre>
         <br/>
        </div>
        <br/>
        <p style="padding-top:0px; padding-bottom:0px; margin-top:0px; margin-bottom:18px">
         游戏可以持续的两个前提：有空的格子，或者还有可以或许归并的卡片。
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <br/>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f617368656e6731393839333231:2f61727469636c652f64657461696c732f3235303430303435" class_="artid" style="display:none">
 </p>
</div>


