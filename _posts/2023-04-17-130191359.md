---
layout: post
title: "微信小程序-eval-替代数学运算支持小数点,支持uniapp,最新完全可用版"
date: 2023-04-17 01:34:50 +0800
description: "最近有个开发计算器的需求，想着用eval很方便        =，=        小程序还给禁用了"
keywords: "小程序 eval"
categories: ["未分类"]
tags: ["微信小程序", "小程序", "App"]
artid: "130191359"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=130191359
  alt: "微信小程序-eval-替代数学运算支持小数点,支持uniapp,最新完全可用版"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微信小程序 eval 替代（数学运算）支持小数点，支持uniapp，最新完全可用版！
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     最近有个开发计算器的需求，想着用eval很方便        =，=        小程序还给禁用了。
    </p>
    <p>
     去网上去搜 没有找到好用的解决办法（eval5 太大了，不优雅）。突然想到在大一看算法书时 有一个实现计算机的例子 话不多说上代码  ：）
    </p>
    <p>
     GitHub地址 ：
     <a class="link-info" href="https://github.com/hzbnb/eval-math" title="https://github.com/hzbnb/eval-math">
      https://github.com/hzbnb/eval-math
     </a>
     ( 点个star 方便以后找到学习～ 😁
    </p>
    <p>
     纯js实现兼容性极强 支持各跨平台框架 （uniapp ，等）
    </p>
    <h4>
     使用方法：
    </h4>
    <pre><code class="language-javascript">	import {evalMath} from "./eval-math.js";
    
    evalMath("(1.5+1)*2*4"); // 20</code></pre>
    <h4>
     核心代码：
    </h4>
    <pre><code class="language-javascript">export const evalMath = (expression)=&gt; {
    // 将表达式转换为标记数组
    const tokens = expression.match(/[+\-*/()]|[-+]?(\d+(\.\d*)?|\.\d+)/g);

    // 定义操作数和操作符的堆栈
    const operands = [];
    const operators = [];

    // 定义优先级映射
    const precedence = {
        "+": 1,
        "-": 1,
        "*": 2,
        "/": 2,
    };

    // 处理每个标记
    for (const token of tokens) {
        if (/^[\d\.]+$/.test(token)) {
            // 如果标记是一个数字，将其作为操作数压入堆栈
            operands.push(Number(token));
        } else if (/^[+\-*/]$/.test(token)) {
            // 如果标记是一个操作符，将其与堆栈中的操作符进行比较，
            // 并根据优先级将操作符弹出并应用于操作数
            while (
                operators.length &gt; 0 &amp;&amp;
                precedence[operators[operators.length - 1]] &gt;= precedence[token]
            ) {
                const operator = operators.pop();
                const operand2 = operands.pop();
                const operand1 = operands.pop();
                operands.push(applyOperator(operand1, operand2, operator));
            }
            operators.push(token);
        } else if (token === "(") {
            // 如果标记是左括号，将其压入操作符堆栈
            operators.push(token);
        } else if (token === ")") {
            // 如果标记是右括号，将堆栈中的操作符弹出并应用于操作数，直到找到左括号为止
            while (operators[operators.length - 1] !== "(") {
                const operator = operators.pop();
                const operand2 = operands.pop();
                const operand1 = operands.pop();
                operands.push(applyOperator(operand1, operand2, operator));
            }
            operators.pop(); // 弹出左括号
        }
    }

    // 处理堆栈中剩余的操作符
    while (operators.length &gt; 0) {
        const operator = operators.pop();
        const operand2 = operands.pop();
        const operand1 = operands.pop();
        operands.push(applyOperator(operand1, operand2, operator));
    }

    // 返回最终结果
    return operands[0];

}

function applyOperator(operand1, operand2, operator) {
switch (operator) {
case "+":
return operand1 + operand2;
case "-":
return operand1 - operand2;
case "_":
return operand1 _ operand2;
case "/":
return operand1 / operand2;
}
}

// 使用示例
// console.log(evalMath("(1.5+1)*2*4"));
</code></pre>
<h4>
</h4>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34363338323134312f:61727469636c652f64657461696c732f313330313931333539" class_="artid" style="display:none">
 </p>
</div>
