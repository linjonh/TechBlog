---
layout: post
title: "Android-音视频开发打怪升级音视频硬解码篇二音视频硬解码流程封装基础解码框架1"
date: 2024-07-23 00:12:22 +0800
description: "为了方便记录解码状态，这里使用一个枚举类表示/*开始状态START,/*解码中DECODING,/*"
keywords: "android 音视频开发打怪"
categories: ['程序员']
tags: ['面试', '学习', 'Android']
artid: "138637962"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138637962
    alt: "Android-音视频开发打怪升级音视频硬解码篇二音视频硬解码流程封装基础解码框架1"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Android 音视频开发打怪升级：音视频硬解码篇】二、音视频硬解码流程：封装基础解码框架(1)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h5>
     <a id="_2">
     </a>
     【附】相关架构及资料
    </h5>
    <blockquote>
     <p>
      <strong>
       源码、笔记、视频。高级UI、性能优化、架构师课程、NDK、混合式开发（ReactNative+Weex）微信小程序、Flutter全方面的Android进阶实践技术，和技术大牛一起讨论交流解决问题。
      </strong>
     </p>
    </blockquote>
    <p>
     <img alt="image" src="https://i-blog.csdnimg.cn/blog_migrate/512ddf3c999b41155f236511d945dfe5.png"/>
    </p>
    <p>
     <strong>
      网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
     </strong>
    </p>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618156601">
       需要这份系统化学习资料的朋友，可以戳这里获取
      </a>
     </strong>
    </p>
    <p>
     <strong>
      一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
     </strong>
    </p>
    <ul>
     <li>
      其中，有一个解码状态DecodeState和音视频数据读取器IExtractor。
     </li>
    </ul>
    <h5>
     <a id="_22">
     </a>
     定义解码状态
    </h5>
    <p>
     为了方便记录解码状态，这里使用一个枚举类表示
    </p>
    <p>
     enum class DecodeState {
     <!-- -->
     <br/>
     /*
     <em>
      开始状态
     </em>
     /
     <br/>
     START,
     <br/>
     /*
     <em>
      解码中
     </em>
     /
     <br/>
     DECODING,
     <br/>
     /*
     <em>
      解码暂停
     </em>
     /
     <br/>
     PAUSE,
     <br/>
     /*
     <em>
      正在快进
     </em>
     /
     <br/>
     SEEKING,
     <br/>
     /*
     <em>
      解码完成
     </em>
     /
     <br/>
     FINISH,
     <br/>
     /*
     <em>
      解码器释放
     </em>
     /
     <br/>
     STOP
     <br/>
     }
    </p>
    <h5>
     <a id="_43">
     </a>
     定义音视频数据分离器
    </h5>
    <p>
     前面说过，MediaCodec需要我们不断地喂数据给输入缓冲，那么数据从哪里来呢？肯定是音视频文件了，这里的IExtractor就是用来提取音视频文件中数据流。
    </p>
    <p>
     Android自带有一个音视频数据读取器MediaExtractor，同样为了方便维护和拓展性，我们依然先定一个读取器IExtractor。
    </p>
    <p>
     interface IExtractor {
     <!-- -->
     <br/>
     /**
    </p>
    <ul>
     <li>
      获取音视频格式参数
      <br/>
      */
      <br/>
      fun getFormat(): MediaFormat?
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      读取音视频数据
      <br/>
      */
      <br/>
      fun readBuffer(byteBuffer: ByteBuffer): Int
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      获取当前帧时间
      <br/>
      */
      <br/>
      fun getCurrentTimestamp(): Long
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      Seek到指定位置，并返回实际帧的时间戳
      <br/>
      */
      <br/>
      fun seek(pos: Long): Long
     </li>
    </ul>
    <p>
     fun setStartPos(pos: Long)
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      停止读取数据
      <br/>
      */
      <br/>
      fun stop()
      <br/>
      }
     </li>
    </ul>
    <p>
     最重要的一个方法就是readBuffer，用于读取音视频数据流
    </p>
    <h5>
     <a id="_82">
     </a>
     定义解码流程
    </h5>
    <p>
     前面我们只贴出了解码器的参数部分，接下来，贴出最重要的部分，也就是解码流程部分。
    </p>
    <p>
     abstract class BaseDecoder: IDecoder {
     <!-- -->
     <br/>
     //省略参数定义部分，见上
     <br/>
     …
    </p>
    <p>
     final override fun run() {
     <!-- -->
     <br/>
     mState = DecodeState.START
     <br/>
     mStateListener?.decoderPrepare(this)
    </p>
    <p>
     //【解码步骤：1. 初始化，并启动解码器】
     <br/>
     if (!init()) return
    </p>
    <p>
     while (mIsRunning) {
     <!-- -->
     <br/>
     if (mState != DecodeState.START &amp;&amp;
     <br/>
     mState != DecodeState.DECODING &amp;&amp;
     <br/>
     mState != DecodeState.SEEKING) {
     <!-- -->
     <br/>
     waitDecode()
     <br/>
     }
    </p>
    <p>
     if (!mIsRunning ||
     <br/>
     mState == DecodeState.STOP) {
     <!-- -->
     <br/>
     mIsRunning = false
     <br/>
     break
     <br/>
     }
    </p>
    <p>
     //如果数据没有解码完毕，将数据推入解码器解码
     <br/>
     if (!mIsEOS) {
     <!-- -->
     <br/>
     //【解码步骤：2. 将数据压入解码器输入缓冲】
     <br/>
     mIsEOS = pushBufferToDecoder()
     <br/>
     }
    </p>
    <p>
     //【解码步骤：3. 将解码好的数据从缓冲区拉取出来】
     <br/>
     val index = pullBufferFromDecoder()
     <br/>
     if (index &gt;= 0) {
     <!-- -->
     <br/>
     //【解码步骤：4. 渲染】
     <br/>
     render(mOutputBuffers!![index], mBufferInfo)
     <br/>
     //【解码步骤：5. 释放输出缓冲】
     <br/>
     mCodec!!.releaseOutputBuffer(index, true)
     <br/>
     if (mState == DecodeState.START) {
     <!-- -->
     <br/>
     mState = DecodeState.PAUSE
     <br/>
     }
     <br/>
     }
     <br/>
     //【解码步骤：6. 判断解码是否完成】
     <br/>
     if (mBufferInfo.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) {
     <!-- -->
     <br/>
     mState = DecodeState.FINISH
     <br/>
     mStateListener?.decoderFinish(this)
     <br/>
     }
     <br/>
     }
     <br/>
     doneDecode()
     <br/>
     //【解码步骤：7. 释放解码器】
     <br/>
     release()
     <br/>
     }
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      解码线程进入等待
      <br/>
      */
      <br/>
      private fun waitDecode() {
      <!-- -->
      <br/>
      try {
      <!-- -->
      <br/>
      if (mState == DecodeState.PAUSE) {
      <!-- -->
      <br/>
      mStateListener?.decoderPause(this)
      <br/>
      }
      <br/>
      synchronized(mLock) {
      <!-- -->
      <br/>
      mLock.wait()
      <br/>
      }
      <br/>
      } catch (e: Exception) {
      <!-- -->
      <br/>
      e.printStackTrace()
      <br/>
      }
      <br/>
      }
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      通知解码线程继续运行
      <br/>
      */
      <br/>
      protected fun notifyDecode() {
      <!-- -->
      <br/>
      synchronized(mLock) {
      <!-- -->
      <br/>
      mLock.notifyAll()
      <br/>
      }
      <br/>
      if (mState == DecodeState.DECODING) {
      <!-- -->
      <br/>
      mStateListener?.decoderRunning(this)
      <br/>
      }
      <br/>
      }
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      渲染
      <br/>
      */
      <br/>
      abstract fun render(outputBuffers: ByteBuffer,
      <br/>
      bufferInfo: MediaCodec.BufferInfo)
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      结束解码
      <br/>
      */
      <br/>
      abstract fun doneDecode()
      <br/>
      }
     </li>
    </ul>
    <p>
     在Runnable的run回调方法中，集成了整个解码流程:
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：1. 初始化，并启动解码器】
      </strong>
     </li>
    </ul>
    <p>
     abstract class BaseDecoder: IDecoder {
     <!-- -->
     <br/>
     //省略上面已有代码
     <br/>
     …
    </p>
    <p>
     private fun init(): Boolean {
     <!-- -->
     <br/>
     //1.检查参数是否完整
     <br/>
     if (mFilePath.isEmpty() || File(mFilePath).exists()) {
     <!-- -->
     <br/>
     Log.w(TAG, “文件路径为空”)
     <br/>
     mStateListener?.decoderError(this, “文件路径为空”)
     <br/>
     return false
     <br/>
     }
     <br/>
     //调用虚函数，检查子类参数是否完整
     <br/>
     if (!check()) return false
    </p>
    <p>
     //2.初始化数据提取器
     <br/>
     mExtractor = initExtractor(mFilePath)
     <br/>
     if (mExtractor == null ||
     <br/>
     mExtractor!!.getFormat() == null) return false
    </p>
    <p>
     //3.初始化参数
     <br/>
     if (!initParams()) return false
    </p>
    <p>
     //4.初始化渲染器
     <br/>
     if (!initRender()) return false
    </p>
    <p>
     //5.初始化解码器
     <br/>
     if (!initCodec()) return false
     <br/>
     return true
     <br/>
     }
    </p>
    <p>
     private fun initParams(): Boolean {
     <!-- -->
     <br/>
     try {
     <!-- -->
     <br/>
     val format = mExtractor!!.getFormat()!!
     <br/>
     mDuration = format.getLong(MediaFormat.KEY_DURATION) / 1000
     <br/>
     if (mEndPos == 0L) mEndPos = mDuration
    </p>
    <p>
     initSpecParams(mExtractor!!.getFormat()!!)
     <br/>
     } catch (e: Exception) {
     <!-- -->
     <br/>
     return false
     <br/>
     }
     <br/>
     return true
     <br/>
     }
    </p>
    <p>
     private fun initCodec(): Boolean {
     <!-- -->
     <br/>
     try {
     <!-- -->
     <br/>
     //1.根据音视频编码格式初始化解码器
     <br/>
     val type = mExtractor!!.getFormat()!!.getString(MediaFormat.KEY_MIME)
     <br/>
     mCodec = MediaCodec.createDecoderByType(type)
     <br/>
     //2.配置解码器
     <br/>
     if (!configCodec(mCodec!!, mExtractor!!.getFormat()!!)) {
     <!-- -->
     <br/>
     waitDecode()
     <br/>
     }
     <br/>
     //3.启动解码器
     <br/>
     mCodec!!.start()
    </p>
    <p>
     //4.获取解码器缓冲区
     <br/>
     mInputBuffers = mCodec?.inputBuffers
     <br/>
     mOutputBuffers = mCodec?.outputBuffers
     <br/>
     } catch (e: Exception) {
     <!-- -->
     <br/>
     return false
     <br/>
     }
     <br/>
     return true
     <br/>
     }
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      检查子类参数
      <br/>
      */
      <br/>
      abstract fun check(): Boolean
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      初始化数据提取器
      <br/>
      */
      <br/>
      abstract fun initExtractor(path: String): IExtractor
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      初始化子类自己特有的参数
      <br/>
      */
      <br/>
      abstract fun initSpecParams(format: MediaFormat)
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      初始化渲染器
      <br/>
      */
      <br/>
      abstract fun initRender(): Boolean
     </li>
    </ul>
    <p>
     /**
    </p>
    <ul>
     <li>
      配置解码器
      <br/>
      */
      <br/>
      abstract fun configCodec(codec: MediaCodec, format: MediaFormat): Boolean
      <br/>
      }
     </li>
    </ul>
    <p>
     初始化方法中，分为5个步骤，看起很复杂，实际很简单。
    </p>
    <ol>
     <li>
      <p>
       检查参数是否完整：路径是否有效等
      </p>
     </li>
     <li>
      <p>
       初始化数据提取器：初始化Extractor
      </p>
     </li>
     <li>
      <p>
       初始化参数：提取一些必须的参数：duration，width，height等
      </p>
     </li>
     <li>
      <p>
       初始化渲染器：视频不需要，音频为AudioTracker
      </p>
     </li>
     <li>
      <p>
       初始化解码器：初始化MediaCodec
      </p>
     </li>
    </ol>
    <p>
     在initCodec()中，
    </p>
    <p>
     val type = mExtractor!!.getFormat()!!.getString(MediaFormat.KEY_MIME)
     <br/>
     mCodec = MediaCodec.createDecoderByType(type)
    </p>
    <p>
     初始化MediaCodec的时候：
    </p>
    <ol>
     <li>
      首先，通过Extractor获取到音视频数据的编码信息MediaFormat；
     </li>
     <li>
      然后，查询MediaFormat中的编码类型（如video/avc，即H264；audio/mp4a-latm，即AAC）；
     </li>
     <li>
      最后，调用createDecoderByType创建解码器。
     </li>
    </ol>
    <p>
     <strong>
      需要说明的是
     </strong>
     ：由于音频和视频的初始化稍有不同，所以定义了几个虚函数，将不同的东西交给子类去实现。具体将在下一篇文章[音视频播放：音视频同步]说明。
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：2. 将数据压入解码器输入缓冲】
      </strong>
     </li>
    </ul>
    <p>
     直接进入pushBufferToDecoder方法中
    </p>
    <p>
     abstract class BaseDecoder: IDecoder {
     <!-- -->
     <br/>
     //省略上面已有代码
     <br/>
     …
    </p>
    <p>
     private fun pushBufferToDecoder(): Boolean {
     <!-- -->
     <br/>
     var inputBufferIndex = mCodec!!.dequeueInputBuffer(2000)
     <br/>
     var isEndOfStream = false
    </p>
    <p>
     if (inputBufferIndex &gt;= 0) {
     <!-- -->
     <br/>
     val inputBuffer = mInputBuffers!![inputBufferIndex]
     <br/>
     val sampleSize = mExtractor!!.readBuffer(inputBuffer)
     <br/>
     if (sampleSize &lt; 0) {
     <!-- -->
     <br/>
     //如果数据已经取完，压入数据结束标志：BUFFER_FLAG_END_OF_STREAM
     <br/>
     mCodec!!.queueInputBuffer(inputBufferIndex, 0, 0,
     <br/>
     0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)
     <br/>
     isEndOfStream = true
     <br/>
     } else {
     <!-- -->
     <br/>
     mCodec!!.queueInputBuffer(inputBufferIndex, 0,
     <br/>
     sampleSize, mExtractor!!.getCurrentTimestamp(), 0)
     <br/>
     }
     <br/>
     }
     <br/>
     return isEndOfStream
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     调用了以下方法：
    </p>
    <ol>
     <li>
      查询是否有可用的输入缓冲，返回缓冲索引。其中参数2000为等待2000ms，如果填入-1则无限等待。
     </li>
    </ol>
    <p>
     var inputBufferIndex = mCodec!!.dequeueInputBuffer(2000)
    </p>
    <ol start="2">
     <li>
      通过缓冲索引 inputBufferIndex 获取可用的缓冲区，并使用Extractor提取待解码数据，填充到缓冲区中。
     </li>
    </ol>
    <p>
     val inputBuffer = mInputBuffers!![inputBufferIndex]
     <br/>
     val sampleSize = mExtractor!!.readBuffer(inputBuffer)
    </p>
    <ol start="3">
     <li>
      调用queueInputBuffer将数据压入解码器。
     </li>
    </ol>
    <p>
     mCodec!!.queueInputBuffer(inputBufferIndex, 0,
     <br/>
     sampleSize, mExtractor!!.getCurrentTimestamp(), 0)
    </p>
    <blockquote>
     <p>
      <strong>
       注意
      </strong>
      ：如果SampleSize返回-1，说明没有更多的数据了。
     </p>
    </blockquote>
    <p>
     这个时候，queueInputBuffer的最后一个参数要传入结束标记MediaCodec.BUFFER_FLAG_END_OF_STREAM。
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：3. 将解码好的数据从缓冲区拉取出来】
      </strong>
     </li>
    </ul>
    <p>
     直接进入pullBufferFromDecoder()
    </p>
    <p>
     abstract class BaseDecoder: IDecoder {
     <!-- -->
     <br/>
     //省略上面已有代码
     <br/>
     …
    </p>
    <p>
     private fun pullBufferFromDecoder(): Int {
     <!-- -->
     <br/>
     // 查询是否有解码完成的数据，index &gt;=0 时，表示数据有效，并且index为缓冲区索引
     <br/>
     var index = mCodec!!.dequeueOutputBuffer(mBufferInfo, 1000)
     <br/>
     when (index) {
     <!-- -->
     <br/>
     MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -&gt; {}
     <br/>
     MediaCodec.INFO_TRY_AGAIN_LATER -&gt; {}
     <br/>
     MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED -&gt; {
     <!-- -->
     <br/>
     mOutputBuffers = mCodec!!.outputBuffers
     <br/>
     }
     <br/>
     else -&gt; {
     <!-- -->
     <br/>
     return index
     <br/>
     }
     <br/>
     }
     <br/>
     return -1
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     第一、调用dequeueOutputBuffer方法查询是否有解码完成的可用数据，其中mBufferInfo用于获取数据帧信息，第二参数是等待时间，这里等待1000ms，填入-1是无限等待。
    </p>
    <p>
     var index = mCodec!!.dequeueOutputBuffer(mBufferInfo, 1000)
    </p>
    <p>
     第二、判断index类型：
    </p>
    <p>
     MediaCodec.INFO_OUTPUT_FORMAT_CHANGED：输出格式改变了
    </p>
    <p>
     MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED：输入缓冲改变了
    </p>
    <p>
     MediaCodec.INFO_TRY_AGAIN_LATER：没有可用数据，等会再来
    </p>
    <p>
     大于等于0：有可用数据，index就是输出缓冲索引
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：4. 渲染】
      </strong>
     </li>
    </ul>
    <p>
     这里调用了一个虚函数render，也就是将渲染交给子类
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：5. 释放输出缓冲】
      </strong>
     </li>
    </ul>
    <p>
     调用releaseOutputBuffer方法， 释放输出缓冲区。
    </p>
    <blockquote>
     <p>
      注：第二个参数，是个boolean，命名为render，这个参数在视频解码时，用于决定是否要将这一帧数据显示出来。
     </p>
    </blockquote>
    <p>
     mCodec!!.releaseOutputBuffer(index, true)
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：6. 判断解码是否完成】
      </strong>
     </li>
    </ul>
    <p>
     还记得我们在把数据压入解码器时，当sampleSize &lt; 0 时，压入了一个结束标记吗？
    </p>
    <p>
     当接收到这个标志后，解码器就知道所有数据已经接收完毕，在所有数据解码完成以后，会在最后一帧数据加上结束标记信息，即
    </p>
    <p>
     if (mBufferInfo.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) {
     <!-- -->
     <br/>
     mState = DecodeState.FINISH
     <br/>
     mStateListener?.decoderFinish(this)
     <br/>
     }
    </p>
    <ul>
     <li>
      <strong>
       【解码步骤：7. 释放解码器】
      </strong>
     </li>
    </ul>
    <p>
     在while循环结束后，释放掉所有的资源。至此，一次解码结束。
    </p>
    <p>
     abstract class BaseDecoder: IDecoder {
     <!-- -->
     <br/>
     //省略上面已有代码
     <br/>
     …
    </p>
    <p>
     private fun release() {
     <!-- -->
     <br/>
     try {
     <!-- -->
     <br/>
     mState = DecodeState.STOP
     <br/>
     mIsEOS = false
     <br/>
     mExtractor?.stop()
     <br/>
     mCodec?.stop()
     <br/>
     mCodec?.release()
     <br/>
     mStateListener?.decoderDestroy(this)
    </p>
    <h5>
     <a id="Android_450">
     </a>
     如何成为Android高级架构师！
    </h5>
    <p>
     架构师必须具备抽象思维和分析的能力，这是你进行系统分析和系统分解的基本素质。只有具备这样的能力，架构师才能看清系统的整体，掌控全局，这也是架构师大局观的形成基础。
     <strong>
      你如何具备这种能力呢？一是来自于经验，二是来自于学习。
     </strong>
    </p>
    <p>
     架构师不仅要具备在问题领域上的经验，也需要具备在软件工程领域内的经验。也就是说，架构师必须能够准确得理解需求，然后用软件工程的思想，把需求转化和分解成可用计算机语言实现的程度。经验的积累是需要一个时间过程的，这个过程谁也帮不了你，是需要你去经历的。
    </p>
    <p>
     <strong>
      但是，如果你有意识地去培养，不断吸取前人的经验的话，还是可以缩短这个周期的。这也是我整理架构师进阶此系列的始动力之一。
     </strong>
    </p>
    <hr/>
    <h6>
     <a id="Android_460">
     </a>
     成为Android架构师必备知识技能
    </h6>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/0b206a3953aacd85ace2bac34bacb330.png"/>
    </p>
    <h6>
     <a id="P8PDF_464">
     </a>
     对应导图的学习笔记(由阿里P8大牛手写，我负责整理成PDF笔记）
    </h6>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/57d50f2bdcc4bafcd8798fd9f6e91050.png"/>
    </p>
    <h6>
     <a id="_468">
     </a>
     部分内容展示
    </h6>
    <p>
     <strong>
      《设计思想解读开源框架》
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       目录
      </strong>
      <br/>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/7452893dd2122847fb0e0d98a2d19a24.png"/>
     </li>
     <li>
      <strong>
       热修复设计
      </strong>
      <br/>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b6769886554c29992ff4b28cf39d9f08.png"/>
     </li>
     <li>
      <strong>
       插件化框架设计
      </strong>
      <br/>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/d95fc2590377429b594368d4bb99b48f.png">
       <br/>
       <strong>
        《360°全方面性能优化》
       </strong>
       <br/>
       <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/da464097ac489e013149fa4a2a86857b.png"/>
      </img>
     </li>
     <li>
      <strong>
       设计思想与代码质量优化
      </strong>
      <br/>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/57d4a8bf907c754bccb787b7bfa73aec.png"/>
     </li>
     <li>
      <strong>
       程序性能优化
      </strong>
      <br/>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/71bf2695b61eafac55886ee54ea5d8a3.png"/>
     </li>
    </ul>
    <p>
     <strong>
      网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
     </strong>
    </p>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618156601">
       需要这份系统化学习资料的朋友，可以戳这里获取
      </a>
     </strong>
    </p>
    <p>
     <strong>
      一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
     </strong>
    </p>
    <p>
     ]
    </p>
    <ul>
     <li>
      <strong>
       插件化框架设计
      </strong>
      <br/>
      [外链图片转存中…(img-hNJCKrSe-1715272409414)]
      <br/>
      <strong>
       《360°全方面性能优化》
      </strong>
      <br/>
      [外链图片转存中…(img-zWYonn4w-1715272409414)]
     </li>
     <li>
      <strong>
       设计思想与代码质量优化
      </strong>
      <br/>
      [外链图片转存中…(img-MI4Oq1u4-1715272409414)]
     </li>
     <li>
      <strong>
       程序性能优化
      </strong>
      <br/>
      [外链图片转存中…(img-pBQeMPCV-1715272409415)]
     </li>
    </ul>
    <p>
     <strong>
      网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
     </strong>
    </p>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618156601">
       需要这份系统化学习资料的朋友，可以戳这里获取
      </a>
     </strong>
    </p>
    <p>
     <strong>
      一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343533383133352f:61727469636c652f64657461696c732f313338363337393632" class_="artid" style="display:none">
 </p>
</div>


