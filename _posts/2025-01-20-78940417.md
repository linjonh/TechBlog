---
layout: post
title: "用Python编写微信小游戏跳一跳的运行脚本"
date: 2025-01-20 07:11:57 +0800
description: "前言 更新了微信后发现了一款小游戏跳一跳，但是玩了一下午最高才达到200，每次差点破纪录后总是手抖就"
keywords: "自动跳一跳python脚本"
categories: ['Python']
tags: ['Python']
artid: "78940417"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=78940417
    alt: "用Python编写微信小游戏跳一跳的运行脚本"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     用Python编写微信小游戏“跳一跳”的运行脚本
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      前言
     </strong>
     <br/>
     更新了微信后发现了一款小游戏跳一跳，但是玩了一下午最高才达到200，每次差点破纪录后总是手抖就挂掉了，气的想要砸手机。。闲来无事刷微博的时候正好看到有人分析如何编写脚本自动运行游戏破了3000多分，细看后觉得原理并不复杂，就索性花了一个晚上，参考
     <a href="https://github.com/wangshub/wechat_jump_game" rel="noopener noreferrer" target="_blank">
      大神的实现方法
     </a>
     ，在他的基础上删减了一些代码，也用Python写了个脚本。接下来进行原理和代码分析。
     <br/>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20171231091911004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjI0MDg1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title="">
      <br/>
      图1.跳一跳启动界面
      <br/>
      <strong>
       原理
      </strong>
     </img>
    </p>
    <ol>
     <li>
      <p>
       配置adb环境变量，在我的电脑–》属性–》高级系统设置–》环境变量–》Path上添加adb.exe所在的路径。
      </p>
     </li>
     <li>
      <p>
       打开手机的usb调试模式，并连接电脑，打开跳一跳，然后通过adb工具获取当前手机截图，具体指令如下所示：
      </p>
      <p>
       <code>
        adb shell screencap -p /sdcard/1.png
        <br/>
        adb pull /sdcard/1.png
       </code>
       <br/>
       在程序中的具体代码实现如下所示：
      </p>
     </li>
    </ol>
    <pre class="prettyprint"><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">screenshot</span><span class="hljs-params">()</span>:</span>
    cmd = <span class="hljs-string">'adb shell screencap -p /sdcard/1.png'</span>
    os.system(cmd)
    cmd = <span class="hljs-string">'adb pull /sdcard/1.png'</span>
    os.system(cmd)</code></pre>
    <ol>
     <li>
      查找棋子的位置，通过颜色来识别棋子，通过将棋子底盘所在行的所有点的x轴坐标相加，然后取平均值获得X轴坐标，将Y轴坐标取最低点减去棋子底盘高度的一半。具体代码实现如下：
     </li>
    </ol>
    <pre class="prettyprint"><code class="hljs glsl"><span class="hljs-preprocessor">#开始查找棋子的坐标，从start_y开始据目测棋子不会位于屏幕底部1/3处</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_y, <span class="hljs-keyword">int</span>(height * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>)):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(border_x, width - border_x):  <span class="hljs-preprocessor">#删除周围空白部分，加快程序运行速度</span>
        next_point = im[j,i]
        <span class="hljs-preprocessor"># 根据棋子的颜色判断，求所有点的和然后求平均值</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-number">50</span> &lt; next_point[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">60</span>) and (<span class="hljs-number">53</span> &lt;next_point[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">63</span>) and (<span class="hljs-number">95</span> &lt; next_point[<span class="hljs-number">2</span>] &lt; <span class="hljs-number">110</span>):
            x1_temp += j <span class="hljs-preprocessor">#点求和</span>
            x1_num += <span class="hljs-number">1</span> <span class="hljs-preprocessor">#点的个数</span>
            y1_max = <span class="hljs-built_in">max</span>(i, y1_max)

<span class="hljs-keyword">if</span> <span class="hljs-built_in">not</span> <span class="hljs-built_in">all</span>((x1_temp,x1_num)):
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
x1 = x1_temp / x1_num
y1 = y1_max - piece_height/<span class="hljs-number">2</span>  <span class="hljs-preprocessor"># 棋子Y轴坐标上移到底盘高度的一半</span></code></pre>
    <ol>
     <li>
      查找下一个棋盘的位置，一般可以通过两种方法实现。第一种是通过鼠标点击下一个棋盘的位置，具体参考编程美丽写的博客。
     </li>
    </ol>
    <blockquote>
     <p>
      <a href="http://blog.csdn.net/F0ED9cZN4Ly992G/article/details/78937011" rel="noopener noreferrer" target="_blank">
       http://blog.csdn.net/F0ED9cZN4Ly992G/article/details/78937011
      </a>
     </p>
    </blockquote>
    <p>
     第二种是本文使用的，从上往下一行一行扫描，找到块中点的X轴坐标，然后通过截图中两个具体的棋盘获取的固定的角度，即正切值来推出中点的 Y坐标。 具体代码如下：
    </p>
    <pre class="prettyprint"><code class="hljs glsl"><span class="hljs-preprocessor">#查找下一个棋盘的位置</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_y, height * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>):
    start_point = im[<span class="hljs-number">0</span>, i]
    <span class="hljs-keyword">if</span> x2 or y2:
        <span class="hljs-keyword">break</span>
    x2_temp = <span class="hljs-number">0</span>
    x2_num = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(width):
        next_point = im[j,i]

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(j - x1) &lt; body_width:
            <span class="hljs-keyword">continue</span>

        <span class="hljs-preprocessor"># 棋盘为圆</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(next_point[<span class="hljs-number">0</span>] - start_point[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(next_point[<span class="hljs-number">1</span>] - start_point[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">abs</span>(next_point[<span class="hljs-number">2</span>] - start_point[<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">10</span>:
            x2_temp += j
            x2_num += <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> x2_temp:
        x2 = x2_temp / x2_num
<span class="hljs-preprocessor"># 按实际的角度通过tan值来算计算下一个棋盘的中心点的Y轴坐标</span>
y2 = y1 - <span class="hljs-built_in">abs</span>(x2 - x1) * <span class="hljs-built_in">abs</span>(sample_y1 - sample_y2) / <span class="hljs-built_in">abs</span>(sample_x1 - sample_x2)

<span class="hljs-keyword">if</span> <span class="hljs-built_in">not</span> <span class="hljs-built_in">all</span>((x2, y2)):
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span></code></pre>
    <ol>
     <li>
      根据棋子的位置跟下一个棋盘的位置求得两点的具体，推算出长按时间。具体代码如下：
     </li>
    </ol>
    <pre class="prettyprint"><code class="hljs python"><span class="hljs-comment">#跳到下一个棋盘</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span><span class="hljs-params">(distance)</span>:</span>
    press_time = distance * press
    press_time = max(press_time, <span class="hljs-number">200</span>)   <span class="hljs-comment"># 设置最小的按压时间位200ms</span>
    press_time = int(press_time)
    cmd = <span class="hljs-string">'adb shell input swipe {} {} {} {} {}'</span>.format(swipe_x1, swipe_y1, swipe_x2, swipe_y2, press_time)
    print(cmd)
    os.system(cmd)</code></pre>
    <p>
     <strong>
      结果展示
     </strong>
     <br/>
     通过运行脚本，能够轻松上分到400+，由于时间原因并没有继续测试，下图为测试时截的动态gif，以及控制台窗口运行结果。
     <br/>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20171231033642315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjI0MDg1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title="">
      <img alt="这里写图片描述" src="https://img-blog.csdn.net/20171231092556771?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjI0MDg1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title="">
       <br/>
       图2.真机运行
      </img>
     </img>
    </p>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20171231034325931?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjI0MDg1Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title="">
      <br/>
      图3.控制台输出信息
      <br/>
      下载链接：
      <a href="http://download.csdn.net/download/qq_22408539/10187952">
       http://download.csdn.net/download/qq_22408539/10187952
      </a>
     </img>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3232343038353339:2f61727469636c652f64657461696c732f3738393430343137" class_="artid" style="display:none">
 </p>
</div>


