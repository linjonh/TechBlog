---
layout: post
title: "除非另外还指定了-TOP-或-FOR-XML,否则,ORDER-BY-子句在视图内联函数派生表子查询和公用表表达式中无效"
date: 2024-09-25 08:56:10 +0800
description: "SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但"
keywords: "除非另外还指定了top 否则order by"
categories: ['数据库', '开发笔记', 'J']
tags: ['无标签']
artid: "17170115"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=17170115
    alt: "除非另外还指定了-TOP-或-FOR-XML,否则,ORDER-BY-子句在视图内联函数派生表子查询和公用表表达式中无效"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     除非另外还指定了 TOP 或 FOR XML，否则，ORDER BY 子句在视图、内联函数、派生表、子查询和公用表表达式中无效
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div id="cnblogs_post_body">
     SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理。
     <p>
      每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。下面是对应用于SQL server 2000和SQL Server 2005的各个逻辑步骤的简单描述。
     </p>
     <br/>
     <div class="cnblogs_code">
      <div class="cnblogs_code_toolbar">
       <span class="cnblogs_code_copy">
        <a target="_blank" title="复制代码">
         <img alt="复制代码" src="https://i-blog.csdnimg.cn/blog_migrate/69c5a8ac3fa60e0848d784a6dd461da6.gif"/>
        </a>
       </span>
      </div>
      <span style="color:#000000">
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       8
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       SELECT
      </span>
      <span style="color:#000000">
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       9
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       DISTINCT
      </span>
      <span style="color:#000000">
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       11
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#0000ff">
       Top
      </span>
      <span style="color:#000000">
       Num
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#0000ff">
       select
      </span>
      <span style="color:#000000">
       list
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       1
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       FROM
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#ff0000">
       [
      </span>
      <span style="color:#ff0000">
       left_table
      </span>
      <span style="color:#ff0000">
       ]
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       3
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       join_type
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       JOIN
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       right_table
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       2
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       ON
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       join_condition
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       4
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       WHERE
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       where_condition
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       5
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       GROUP
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#0000ff">
       BY
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       group_by_list
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       6
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       WITH
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       CUBE
      </span>
      <span style="color:#808080">
       |
      </span>
      <span style="color:#000000">
       RollUP
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       7
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       HAVING
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       having_condition
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <span style="color:#000000">
       <br/>
       (
      </span>
      <span style="color:#800000; font-weight:bold">
       10
      </span>
      <span style="color:#000000">
       )
      </span>
      <span style="color:#0000ff">
       ORDER
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#0000ff">
       BY
      </span>
      <span style="color:#000000">
      </span>
      <span style="color:#808080">
       &lt;
      </span>
      <span style="color:#000000">
       order_by_list
      </span>
      <span style="color:#808080">
       &gt;
      </span>
      <div class="cnblogs_code_toolbar">
       <span class="cnblogs_code_copy">
        <a target="_blank" title="复制代码">
         <img alt="复制代码" src="https://i-blog.csdnimg.cn/blog_migrate/69c5a8ac3fa60e0848d784a6dd461da6.gif"/>
        </a>
       </span>
      </div>
     </div>
     <p>
      <strong>
       逻辑查询处理阶段简介
      </strong>
     </p>
     <ol>
      <li>
       <strong>
        FROM：
       </strong>
       对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1
      </li>
      <li>
       <strong>
        ON：
       </strong>
       对VT1应用ON筛选器。只有那些使&lt;join_condition&gt;为真的行才被插入VT2。
      </li>
      <li>
       <strong>
        OUTER(JOIN)：
       </strong>
       如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。
      </li>
      <li>
       <strong>
        WHERE：
       </strong>
       对VT3应用WHERE筛选器。只有使&lt;where_condition&gt;为true的行才被插入VT4.
      </li>
      <li>
       <strong>
        GROUP BY：
       </strong>
       按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.
      </li>
      <li>
       <strong>
        CUBE|ROLLUP：
       </strong>
       把超组(Suppergroups)插入VT5,生成VT6.
      </li>
      <li>
       <strong>
        HAVING：
       </strong>
       对VT6应用HAVING筛选器。只有使&lt;having_condition&gt;为true的组才会被插入VT7.
      </li>
      <li>
       <strong>
        SELECT：
       </strong>
       处理SELECT列表，产生VT8.
      </li>
      <li>
       <strong>
        DISTINCT：
       </strong>
       将重复的行从VT8中移除，产生VT9.
      </li>
      <li>
       <strong>
        ORDER BY：
       </strong>
       将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).
      </li>
      <li>
       <strong>
        TOP：
       </strong>
       从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。
      </li>
     </ol>
     <p>
      注：步骤10，按ORDER BY子句中的列列表排序上步返回的行，返回游标VC10.这一步是第一步也是唯一一步可以使用SELECT列表中的列别名的步骤。这一步不同于其它步骤的 是，它不返回有效的表，而是返回一个游标。SQL是基于集合理论的。集合不会预先对它的行排序，它只是成员的逻辑集合，成员的顺序无关紧要。对表进行排序 的查询可以返回一个对象，包含按特定物理顺序组织的行。ANSI把这种对象称为游标。理解这一步是正确理解SQL的基础。
     </p>
     <p>
      因为这一步不返回表（而是返回游标），使用了ORDER BY子句的查询不能用作表表达式。表表达式包括：视图、内联表值函数、子查询、派生表和共用表达式。它的结果必须返回给期望得到物理记录的客户端应用程序。例如，下面的派生表查询无效，并产生一个错误：
     </p>
     <pre><span style="color:blue">select </span><span style="color:gray">* 
</span><span style="color:blue">from</span><span style="color:gray">(</span><span style="color:blue">select </span><span style="color:teal">orderid</span><span style="color:gray">,</span><span style="color:teal">customerid </span><span style="color:blue">from </span><span style="color:teal">orders </span><span style="color:blue">order by </span><span style="color:teal">orderid</span><span style="color:gray">) 
</span><span style="color:blue">as </span><span style="color:teal">d</span></pre>
     <p>
      下面的视图也会产生错误
     </p>
     <pre><span style="color:blue">create view </span><span style="color:teal">my_view
</span><span style="color:blue">as
select </span><span style="color:gray">*
</span><span style="color:blue">from </span><span style="color:teal">orders
</span><span style="color:blue">order by </span><span style="color:teal">orderid</span></pre>
     <p>
      在SQL中，表表达式中不允许使用带有ORDER BY子句的查询，而在T—SQL中却有一个例外（应用TOP选项）。
     </p>
     <p>
      所以要记住，不要为表中的行假设任何特定的顺序。换句话说，除非你确定要有序行，否则不要指定ORDER BY 子句。排序是需要成本的，SQL Server需要执行有序索引扫描或使用排序运行符。
      <br/>
     </p>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f77726d5f6e616e6379:2f61727469636c652f64657461696c732f3137313730313135" class_="artid" style="display:none">
 </p>
</div>


