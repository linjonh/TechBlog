---
layout: post
title: "二叉搜索树的创建,删除,查找"
date: 2025-01-09 16:38:45 +0800
description: "二叉搜索树的概念  二叉搜索树又称二叉排序树，它或者是一颗"
keywords: "二叉查找树的删除"
categories: ['数据结构', 'C']
tags: ['二叉搜索树的添加', '二叉搜索树的查找', '二叉搜索树的删除', '二叉搜索树', '二叉排序树']
artid: "82312723"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=82312723
    alt: "二叉搜索树的创建,删除,查找"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     二叉搜索树的创建，删除，查找
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h6 id="二叉搜索树的概念">
     二叉搜索树的概念
    </h6>
    <p>
     二叉搜索树又称二叉排序树，它或者是一颗空树，或者是具有以下性质的二叉树
    </p>
    <ul>
     <li>
      若它的左子树不为空，则左子树上的所有结点的值都小于根结点的值。
     </li>
     <li>
      若它的右子树不为空，则右子树上的所有结点的值都大于根节点的值。
     </li>
     <li>
      它的左右子树也分别为二叉搜索树。
      <br/>
      <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/898e5657eac9c02f3f2cdf2ff6f8bef0.jpeg" title=""/>
     </li>
    </ul>
    <hr/>
    <h6 id="二叉搜索树的操作">
     二叉搜索树的操作
    </h6>
    <p>
     <strong>
      查找关键字data：
     </strong>
     ①.若根节点为空，即二叉搜索树为空。返回0。
     <br/>
     ②.若data&gt;根节点的data，在其右子树查找；若data&lt;根节点的data，在其左子树查找；若data==根节点的data，返回1；找不到返回0。
    </p>
    <pre class="prettyprint"><code class="hljs lasso">int  FindBSTree(BSTree <span class="hljs-subst">*</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> BStree;
    <span class="hljs-comment">//根节点为空，即二叉树为空，返回0</span>
    <span class="hljs-keyword">if</span> (BStree <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">while</span> (cur <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">==</span> <span class="hljs-built_in">data</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">&gt;</span> <span class="hljs-built_in">data</span>)
        {
            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pleft;
        }
        <span class="hljs-keyword">else</span>
            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
    }
    <span class="hljs-comment">//cur==NULL即没有找到元素和data相等，返回0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    <p>
     递归查找
    </p>
    <pre class="prettyprint"><code class="hljs lasso"><span class="hljs-comment">//递归查找</span>
int  FindBSTree(BSTree <span class="hljs-subst">*</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> BStree;
    <span class="hljs-keyword">if</span> (BStree <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">==</span> <span class="hljs-built_in">data</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">&gt;</span> <span class="hljs-built_in">data</span>)   
    {
        <span class="hljs-keyword">return</span> FindBSTree(BStree<span class="hljs-subst">-&gt;</span>_pleft,<span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span> FindBSTree(BStree<span class="hljs-subst">-&gt;</span>_pright, <span class="hljs-built_in">data</span>);
    }
}
</code></pre>
    <p>
     <strong>
      插入元素data：
     </strong>
     在二叉树中插入元素时，必须检测该元素在树中是否已经存在，若存在则不进行插入。
     <br/>
     ①.树为空，即二叉树为空时直接插入。
     <br/>
     ②.树不为空，若data&gt;根节点的data，在右子树插入；若data&lt;根节点的data，在其左子树插入；若data==根节点的data，返回0，不插入；
     <br/>
     在找要插入的位置的时候始终记录双亲结点。
     <br/>
     ③.找到要插入的位置之后，判断双亲结点的data和要插入的data的大小，若data&gt;双亲结点的data，则插入右子树，否则插入左子树。
    </p>
    <pre class="prettyprint"><code class="hljs lasso"><span class="hljs-comment">//插入</span>
int InsertBSTree(BSTree <span class="hljs-subst">**</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur  <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    BSTree <span class="hljs-subst">*</span><span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    assert(BStree);
    cur <span class="hljs-subst">=</span> <span class="hljs-subst">*</span>BStree;
    <span class="hljs-comment">//1.若二叉树为空</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NULL</span> <span class="hljs-subst">==</span> <span class="hljs-subst">*</span>BStree)    
    {
        <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> BuyNode(<span class="hljs-built_in">data</span>);
    }
    <span class="hljs-comment">//2.若二叉树不为空  </span>
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">//①.寻找插入的位置</span>
        <span class="hljs-keyword">while</span> (cur <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>)
        {
            <span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> cur;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
            {         
                cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pleft;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&gt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
            {
                cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-comment">//②.建立新结点</span>
        cur <span class="hljs-subst">=</span> BuyNode(<span class="hljs-built_in">data</span>);
        <span class="hljs-comment">//③.data若比双亲大，则插右边，若比双亲小，则插左边</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_data)
        {
            <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">=</span> cur;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">=</span> cur;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre>
    <p>
     递归插入：
    </p>
    <pre class="prettyprint"><code class="hljs lasso">int InsertBSTree(BSTree <span class="hljs-subst">**</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    BSTree <span class="hljs-subst">*</span><span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    assert(BStree);
    cur <span class="hljs-subst">=</span> <span class="hljs-subst">*</span>BStree;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NULL</span> <span class="hljs-subst">==</span> <span class="hljs-subst">*</span>BStree)
    {
        <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> BuyNode(<span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&gt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
        {
            <span class="hljs-keyword">return</span> InsertBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright, <span class="hljs-built_in">data</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
        {
            <span class="hljs-keyword">return</span>  InsertBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft, <span class="hljs-built_in">data</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre>
    <p>
     <strong>
      删除元素data：
     </strong>
     在二叉树中删除元素时，必须检测该元素在树中是否已经存在，若不存在则直接返回0，不删除。若存在又分为以下四种情况：
    </p>
    <ol>
     <li>
      要删除的结点无孩子结点（叶子结点）。
     </li>
     <li>
      要删除的结点只有右孩子结点。
     </li>
     <li>
      要删除的结点只有左孩子结点。
     </li>
     <li>
      要删除的结点有左,右孩子结点。
      <br/>
      情况1可以和情况2或者情况3合并，对于上述情况，相应的删除方法有：
      <br/>
      ① 直接删除该结点
      <br/>
      ② 删除该结点且被删除结点的双亲结点指向被删除孩子的右孩子结点。
      <br/>
      ③ 删除该结点且被删除结点的双亲结点指向被删除孩子的左孩子结点。
      <br/>
      ④ 在它的右子树中寻找最小的结点，用它的值替换被删除结点的值。
     </li>
    </ol>
    <pre class="prettyprint"><code class="hljs lasso">int  DeleteBSTree(BSTree <span class="hljs-subst">**</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    BSTree <span class="hljs-subst">*</span>del <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;      <span class="hljs-comment">//要删除的结点</span>
    BSTree <span class="hljs-subst">*</span><span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;   <span class="hljs-comment">//要删除结点的双亲结点</span>
    assert(BStree);
    cur <span class="hljs-subst">=</span> <span class="hljs-subst">*</span>BStree;
    <span class="hljs-keyword">if</span> (<span class="hljs-subst">*</span>BStree <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">//寻找要删除的点</span>
    <span class="hljs-keyword">while</span> (cur <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">==</span> <span class="hljs-built_in">data</span>)
        {
            break;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
        {
            <span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> cur;
            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pleft;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> cur;
            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
        }
    }
    <span class="hljs-keyword">if</span> (cur <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-comment">//证明要删除的元素不在二叉搜索树内</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">//只有右孩子或者叶子</span>
    <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-comment">//如果是根节点，让根节点指向它的右子树</span>
        <span class="hljs-keyword">if</span> (cur <span class="hljs-subst">==</span> <span class="hljs-subst">*</span>BStree)
        {
            <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//判断cur是双亲的左孩子还是右孩子</span>
            <span class="hljs-comment">//双亲指向cur的右孩子，因为左孩子为空</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">==</span> cur)
            {
                <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
            }
        }
    }
    <span class="hljs-comment">//只有左孩子</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-comment">//如果是根节点，让根节点指向它的左子树</span>
        <span class="hljs-keyword">if</span> (cur <span class="hljs-subst">==</span> <span class="hljs-subst">*</span>BStree)
        {
            <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//判断cur是双亲的左孩子还是右孩子</span>
            <span class="hljs-comment">//双亲指向cur的左孩子，因为右孩子为空</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">==</span> cur)
            {
                <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pleft;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pleft;
            }

        }
    }
    <span class="hljs-comment">//左右孩子均存在</span>
    <span class="hljs-keyword">else</span>
    {
        del <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
        <span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> cur;
        <span class="hljs-comment">//找到右子树里面最小的一个，覆盖要删除的结点</span>
        <span class="hljs-keyword">while</span> (del<span class="hljs-subst">-&gt;</span>_pleft)
        {
            <span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> del;
            del <span class="hljs-subst">=</span> del<span class="hljs-subst">-&gt;</span>_pleft;
        }
        <span class="hljs-comment">//将找到的结点的值赋给要删除的结点</span>
        cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">=</span> del<span class="hljs-subst">-&gt;</span>_data;
        <span class="hljs-comment">//删除replace </span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">==</span> del)
        {
            <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
            cur <span class="hljs-subst">=</span> del;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">parent</span><span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
            cur <span class="hljs-subst">=</span> del;
        }
    }
    free(cur);
    cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
} </code></pre>
    <p>
     递归删除
    </p>
    <pre class="prettyprint"><code class="hljs lasso">int DeleteBSTree(BSTree <span class="hljs-subst">**</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>del <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;

    assert(BStree);
    <span class="hljs-keyword">if</span> ((<span class="hljs-subst">*</span>BStree) <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_data )
    {
        <span class="hljs-keyword">return</span> DeleteBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft,<span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&gt;</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_data )
    {
        <span class="hljs-keyword">return</span> DeleteBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright, <span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        cur <span class="hljs-subst">=</span> <span class="hljs-subst">*</span>BStree;
        <span class="hljs-keyword">if</span> ((<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
        {
            <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright;
            free(cur);
            cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
        {
            <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft;
            free(cur);
            cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            del <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright;
            <span class="hljs-keyword">while</span> (del<span class="hljs-subst">-&gt;</span>_pleft) 
            {
                del <span class="hljs-subst">=</span> del<span class="hljs-subst">-&gt;</span>_pleft;
            }
            (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">=</span> del<span class="hljs-subst">-&gt;</span>_data;
            <span class="hljs-keyword">return</span> DeleteBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright, del<span class="hljs-subst">-&gt;</span>_data);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre>
    <hr/>
    <pre><code>                       整体代码：
</code></pre>
    <p>
     .h文件
    </p>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include&lt;assert.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;malloc.h&gt;</span>

<span class="hljs-comment">//二叉树的结构</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> BSDataType;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> BSTree
{
    <span class="hljs-keyword">struct</span> BSTree *_pleft;
    <span class="hljs-keyword">struct</span> BSTree *_pright;
    BSDataType _data;
}BSTree;
<span class="hljs-comment">//初始化</span>
<span class="hljs-keyword">void</span> InitBSTree(BSTree **BSTree);
<span class="hljs-comment">//插入</span>
<span class="hljs-keyword">int</span> InsertBSTree(BSTree **BSTree, BSDataType data);
<span class="hljs-comment">//中序遍历</span>
<span class="hljs-keyword">void</span> InOrder(BSTree *BStree);
<span class="hljs-comment">//删除</span>
<span class="hljs-keyword">int</span> DeleteBSTree(BSTree **BStree, BSDataType data);
<span class="hljs-comment">//查找</span>
<span class="hljs-keyword">int</span>  FindBSTree(BSTree *BStree, BSDataType data);
<span class="hljs-comment">//销毁</span>
<span class="hljs-keyword">void</span> DestroyBSTree(BSTree **BStree);</code></pre>
    <p>
     .c文件
    </p>
    <pre class="prettyprint"><code class="hljs lasso"><span class="hljs-variable">#include</span><span class="hljs-string">"BSTree.h"</span>


<span class="hljs-comment">//初始化</span>
<span class="hljs-literal">void</span> InitBSTree(BSTree <span class="hljs-subst">**</span>BSTree)
{
    assert(BSTree);
    <span class="hljs-subst">*</span>BSTree <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
}


BSTree<span class="hljs-subst">*</span> BuyNode(BSDataType d)
{
    BSTree <span class="hljs-subst">*</span>newnode <span class="hljs-subst">=</span> (BSTree <span class="hljs-subst">*</span>)malloc(sizeof(BSTree));
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NULL</span> <span class="hljs-subst">==</span> newnode)
    {
        <span class="hljs-comment">//若开辟空间失败，则打印出错误，不进行后面的代码</span>
        assert(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NULL</span>;
    }
    newnode<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">=</span> d;
    newnode<span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    newnode<span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;

    <span class="hljs-keyword">return</span> newnode;
}
<span class="hljs-comment">插入</span>
<span class="hljs-comment">//int InsertBSTree(BSTree **BStree, BSDataType data)</span>
<span class="hljs-comment">//{<!-- --></span>
<span class="hljs-comment">//  BSTree *cur  = NULL;</span>
<span class="hljs-comment">//  BSTree *parent = NULL;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  assert(BStree);</span>
<span class="hljs-comment">//  cur = *BStree;</span>
<span class="hljs-comment">//  //1.若二叉树为空</span>
<span class="hljs-comment">//  if (NULL == *BStree)    </span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      *BStree = BuyNode(data);</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  //2.若二叉树不为空  </span>
<span class="hljs-comment">//  else</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      </span>
<span class="hljs-comment">//      //①.寻找插入的位置</span>
<span class="hljs-comment">//      while (cur != NULL)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent = cur;</span>
<span class="hljs-comment">//          if (data &lt; cur-&gt;_data)</span>
<span class="hljs-comment">//          {         </span>
<span class="hljs-comment">//              cur = cur-&gt;_pleft;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//          else if (data &gt; cur-&gt;_data)</span>
<span class="hljs-comment">//          {<!-- --></span>
<span class="hljs-comment">//              cur = cur-&gt;_pright;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//          else</span>
<span class="hljs-comment">//          {<!-- --></span>
<span class="hljs-comment">//              return 0;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      //②.建立新结点</span>
<span class="hljs-comment">//      cur = BuyNode(data);</span>
<span class="hljs-comment">//      //③.data若比双亲大，则插右边，若比双亲小，则插左边</span>
<span class="hljs-comment">//      if (data &lt; parent-&gt;_data)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent-&gt;_pleft = cur;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      else</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent-&gt;_pright = cur;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  return 1;</span>
<span class="hljs-comment">//}</span>
<span class="hljs-comment">//递归插入</span>
int InsertBSTree(BSTree <span class="hljs-subst">**</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    BSTree <span class="hljs-subst">*</span><span class="hljs-keyword">parent</span> <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    assert(BStree);
    cur <span class="hljs-subst">=</span> <span class="hljs-subst">*</span>BStree;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NULL</span> <span class="hljs-subst">==</span> <span class="hljs-subst">*</span>BStree)
    {
        <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> BuyNode(<span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&gt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
        {
            InsertBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright, <span class="hljs-built_in">data</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> cur<span class="hljs-subst">-&gt;</span>_data)
        {
            InsertBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft, <span class="hljs-built_in">data</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-comment">//中序遍历   左--&gt;根--&gt;右</span>
<span class="hljs-literal">void</span> InOrder(BSTree <span class="hljs-subst">*</span>BStree)
{
    <span class="hljs-keyword">if</span> (BStree <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    InOrder(BStree<span class="hljs-subst">-&gt;</span>_pleft);
    printf(<span class="hljs-string">"%d "</span>, BStree<span class="hljs-subst">-&gt;</span>_data);
    InOrder(BStree<span class="hljs-subst">-&gt;</span>_pright);
}



<span class="hljs-comment">删除</span>
<span class="hljs-comment">//int  DeleteBSTree(BSTree **BStree, BSDataType data)</span>
<span class="hljs-comment">//{<!-- --></span>
<span class="hljs-comment">//  BSTree *cur = NULL;</span>
<span class="hljs-comment">//  BSTree *del = NULL;      //要删除的结点</span>
<span class="hljs-comment">//  BSTree *parent = NULL;   //要删除结点的双亲结点</span>
<span class="hljs-comment">//  assert(BStree);</span>
<span class="hljs-comment">//  cur = *BStree;</span>
<span class="hljs-comment">//  if (*BStree == NULL)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      return 0;</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  //寻找要删除的点</span>
<span class="hljs-comment">//  while (cur != NULL)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      if (cur-&gt;_data == data)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          break;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      else if (data &lt; cur-&gt;_data)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent = cur;</span>
<span class="hljs-comment">//          cur = cur-&gt;_pleft;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      else</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent = cur;</span>
<span class="hljs-comment">//          cur = cur-&gt;_pright;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  if (cur == NULL)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      //证明要删除的元素不在二叉搜索树内</span>
<span class="hljs-comment">//      return 0;</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  //只有右孩子或者叶子</span>
<span class="hljs-comment">//  if (cur-&gt;_pleft == NULL)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      //如果是根节点，让根节点指向它的右子树</span>
<span class="hljs-comment">//      if (cur == *BStree)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          *BStree = (*BStree)-&gt;_pright;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      else</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          //判断cur是双亲的左孩子还是右孩子</span>
<span class="hljs-comment">//          if (parent-&gt;_pleft == cur)</span>
<span class="hljs-comment">//          {<!-- --></span>
<span class="hljs-comment">//              parent-&gt;_pleft = cur-&gt;_pright;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//          else</span>
<span class="hljs-comment">//          {<!-- --></span>
<span class="hljs-comment">//              parent-&gt;_pright = cur-&gt;_pright;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  //只有左孩子</span>
<span class="hljs-comment">//  else if (cur-&gt;_pright == NULL)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      //如果是根节点，让根节点指向它的左子树</span>
<span class="hljs-comment">//      if (cur == *BStree)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          *BStree = (*BStree)-&gt;_pleft;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      else</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          //判断cur是双亲的左孩子还是右孩子</span>
<span class="hljs-comment">//          if (parent-&gt;_pleft == cur)</span>
<span class="hljs-comment">//          {<!-- --></span>
<span class="hljs-comment">//              parent-&gt;_pleft = cur-&gt;_pleft;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//          else</span>
<span class="hljs-comment">//          {<!-- --></span>
<span class="hljs-comment">//              parent-&gt;_pright = cur-&gt;_pleft;</span>
<span class="hljs-comment">//          }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  //左右孩子均存在</span>
<span class="hljs-comment">//  else</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      del = cur-&gt;_pright;</span>
<span class="hljs-comment">//      parent = cur;</span>
<span class="hljs-comment">//      //找到右子树里面最小的一个</span>
<span class="hljs-comment">//      while (del-&gt;_pleft)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent = del;</span>
<span class="hljs-comment">//          del = del-&gt;_pleft;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      //将找到的结点的值赋给要删除的结点</span>
<span class="hljs-comment">//      cur-&gt;_data = del-&gt;_data;</span>
<span class="hljs-comment">//      //删除replace </span>
<span class="hljs-comment">//      if (parent-&gt;_pleft == del)</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent-&gt;_pleft = NULL;</span>
<span class="hljs-comment">//          cur = del;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//      else</span>
<span class="hljs-comment">//      {<!-- --></span>
<span class="hljs-comment">//          parent-&gt;_pright = NULL;</span>
<span class="hljs-comment">//          cur = del;</span>
<span class="hljs-comment">//      }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  free(cur);</span>
<span class="hljs-comment">//  cur = NULL;</span>
<span class="hljs-comment">//  return 1;</span>
<span class="hljs-comment">//} </span>


<span class="hljs-comment">//递归删除</span>
int DeleteBSTree(BSTree <span class="hljs-subst">**</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>del <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;

    assert(BStree);
    <span class="hljs-keyword">if</span> ((<span class="hljs-subst">*</span>BStree) <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&lt;</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_data )
    {
        DeleteBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft,<span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">data</span> <span class="hljs-subst">&gt;</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_data )
    {
        DeleteBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright, <span class="hljs-built_in">data</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        cur <span class="hljs-subst">=</span> <span class="hljs-subst">*</span>BStree;
        <span class="hljs-keyword">if</span> ((<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
        {
            <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright;
            free(cur);
            cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
        {
            <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft;
            free(cur);
            cur <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            del <span class="hljs-subst">=</span> (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright;
            <span class="hljs-keyword">while</span> (del<span class="hljs-subst">-&gt;</span>_pleft) 
            {
                del <span class="hljs-subst">=</span> del<span class="hljs-subst">-&gt;</span>_pleft;
            }
            (<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">=</span> del<span class="hljs-subst">-&gt;</span>_data;
            DeleteBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright, del<span class="hljs-subst">-&gt;</span>_data);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-comment">//查找</span>
int  FindBSTree(BSTree <span class="hljs-subst">*</span>BStree, BSDataType <span class="hljs-built_in">data</span>)
{
    BSTree <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> BStree;
    <span class="hljs-comment">//根节点为空，即二叉树为空，返回0</span>
    <span class="hljs-keyword">if</span> (BStree <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">while</span> (cur <span class="hljs-subst">!=</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">==</span> <span class="hljs-built_in">data</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur<span class="hljs-subst">-&gt;</span>_data <span class="hljs-subst">&gt;</span> <span class="hljs-built_in">data</span>)
        {
            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pleft;
        }
        <span class="hljs-keyword">else</span>
            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>_pright;
    }
    <span class="hljs-comment">//cur==NULL即没有找到元素和data相等，返回0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">递归查找</span>
<span class="hljs-comment">//int  FindBSTree(BSTree *BStree, BSDataType data)</span>
<span class="hljs-comment">//{<!-- --></span>
<span class="hljs-comment">//  BSTree *cur = BStree;</span>
<span class="hljs-comment">//  if (BStree == NULL)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      return 0;</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  if (cur-&gt;_data == data)</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      return 1;</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  else if (cur-&gt;_data &gt; data)   </span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      return FindBSTree(BStree-&gt;_pleft,data);</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//  else</span>
<span class="hljs-comment">//  {<!-- --></span>
<span class="hljs-comment">//      return FindBSTree(BStree-&gt;_pright, data);</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//}</span>

<span class="hljs-comment">//销毁二叉树</span>
<span class="hljs-literal">void</span> DestroyBSTree(BSTree <span class="hljs-subst">**</span>BStree)
{
    assert(BStree);
    <span class="hljs-keyword">if</span> (<span class="hljs-subst">*</span>BStree <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    DestroyBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pleft);
    DestroyBSTree(<span class="hljs-subst">&amp;</span>(<span class="hljs-subst">*</span>BStree)<span class="hljs-subst">-&gt;</span>_pright);
    free(<span class="hljs-subst">*</span>BStree);
    <span class="hljs-subst">*</span>BStree <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;
}</code></pre>
    <p>
     测试文件：
    </p>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include"BSTree.h"</span>

<span class="hljs-keyword">void</span> TestBSTree()
{
    BSTree *BStree;
    <span class="hljs-keyword">int</span> a[] = { <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span> };
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//初始化二叉搜索树</span>
    InitBSTree(&amp;BStree);
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]); i++)
    {
        <span class="hljs-comment">//插入</span>
        InsertBSTree(&amp;BStree, a[i]);
    }
    <span class="hljs-comment">//插入</span>
    InsertBSTree(&amp;BStree, <span class="hljs-number">10</span>);
    <span class="hljs-comment">//中序遍历</span>
    InOrder(BStree);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-comment">//查找</span>
    <span class="hljs-keyword">if</span> (FindBSTree(BStree, <span class="hljs-number">1</span>))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"找到了！\n"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"没找到!\n"</span>);
    }
    <span class="hljs-comment">//查找</span>
    <span class="hljs-keyword">if</span> (FindBSTree(BStree, -<span class="hljs-number">1</span>))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"找到了！\n"</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"没找到!\n"</span>);
    }
    <span class="hljs-comment">//删除</span>
    DeleteBSTree(&amp;BStree, <span class="hljs-number">5</span>);
    <span class="hljs-comment">//删除</span>
    DeleteBSTree(&amp;BStree, <span class="hljs-number">3</span>);
    <span class="hljs-comment">//中序遍历</span>
    InOrder(BStree);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-comment">//摧毁</span>
    DestroyBSTree(&amp;BStree);
}

<span class="hljs-keyword">int</span> main()
{
    TestBSTree();
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    <p>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/62488ed8002a508117612787e6ad4e3b.jpeg" title=""/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f7a68616f5f6d69616f:2f61727469636c652f64657461696c732f3832333132373233" class_="artid" style="display:none">
 </p>
</div>


