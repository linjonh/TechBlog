---
layout: post
title: 数据库范式1NF-2NF-3NF-BCNF详解
date: 2024-12-30 08:00:00 +0800
categories: [编程语言/数据库/SSH]
tags: [数据库,java]
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=50706596
    alt: 数据库范式1NF-2NF-3NF-BCNF详解
artid: 50706596
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据库范式（1NF 2NF 3NF BCNF）详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div class="article_content" id="article_content">
     <p style="color:rgb(0,0,0)">
      数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <strong>
       范式说明
      </strong>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <strong>
       1.1 第一范式（1NF）无重复的列
      </strong>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即
      <span style="color:#ff0000">
       实体中的某个属性不能有多个值或者不能有重复的属性。
      </span>
      如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      例如，如下的数据库表是符合第一范式的：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <table border="1" cellpadding="0" cellspacing="0" style="color:rgb(0,0,0)">
      <tbody>
       <tr>
        <td>
         <p>
          字段1
         </p>
        </td>
        <td>
         <p>
          字段2
         </p>
        </td>
        <td>
         <p>
          字段3
         </p>
        </td>
        <td>
         <p>
          字段4
         </p>
        </td>
       </tr>
      </tbody>
     </table>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      而这样的数据库表是不符合第一范式的：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <table border="1" cellpadding="0" cellspacing="0" style="color:rgb(0,0,0)">
      <tbody>
       <tr>
        <td>
         <p>
          字段1
         </p>
        </td>
        <td>
         <p>
          字段2
         </p>
        </td>
        <td>
         <p>
          字段3
         </p>
        </td>
        <td>
         <p>
          字段4
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
         </p>
        </td>
        <td>
         <p>
         </p>
        </td>
        <td>
         <p>
          字段3.1
         </p>
        </td>
        <td>
         <p>
          字段3.2
         </p>
        </td>
        <td>
         <p>
         </p>
        </td>
       </tr>
       <tr height="0">
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
       </tr>
      </tbody>
     </table>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。很显然，在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <strong>
       1.2 第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]
      </strong>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      如果关系模式R为第一范式，并且R中每一个非主属性完全函数依赖于R的某个候选键， 则称为第二范式模式。
     </p>
     <p style="color:rgb(0,0,0)">
      第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。
     </p>
     <p style="color:rgb(0,0,0)">
      简而言之，第二范式（2NF）就是
      <span style="color:#ff0000">
       非主属性完全依赖于主关键字
      </span>
      。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      所谓完全依赖是指不能存在仅依赖主关键字一部分的属性（设有函数依赖W→A，若存在XW，有X→A成立，那么称W→A是局部依赖，否则就称W→A是完全函数依赖）。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，关键字为组合关键字(学号, 课程名称)，因为存在如下决定关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      这个数据库表不满足第二范式，因为存在如下决定关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (课程名称) → (学分)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (学号) → (姓名, 年龄)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      即存在组合关键字中的字段决定非关键字的情况。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      由于不符合2NF，这个选课关系表会存在如下问题：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (1) 数据冗余：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (2) 更新异常：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (3) 插入异常：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (4) 删除异常：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      把选课关系表SelectCourse改为如下三个表：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      学生：Student(学号, 姓名, 年龄)；
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      课程：Course(课程名称, 学分)；
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      选课关系：SelectCourse(学号, 课程名称, 成绩)。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      这样的数据库表是符合第二范式的， 消除了数据冗余、更新异常、插入异常和删除异常。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      另外，
      <span style="color:#ff0000">
       所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。
      </span>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <strong>
       1.3 第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]
      </strong>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选键，则称R为第三范式模式。
     </p>
     <p style="color:rgb(0,0,0)">
      满足第三范式（3NF）必须先满足第二范式（2NF）。第三范式（3NF）要求一个数据库表中
      <span style="color:#ff0000">
       不包含已在其它表中已包含的非主关键字信息
      </span>
      。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <span style="color:#ff0000">
       例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。
      </span>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。简而言之，第三范式就是属性不依赖于其它非主属性。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      因此，满足第三范式的数据库表应该不存在如下依赖关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      关键字段 → 非关键字段x → 非关键字段y
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字"学号"，因为存在如下决定关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (学号) → (所在学院) → (学院地点, 学院电话)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      即存在非关键字段"学院地点"、"学院电话"对关键字段"学号"的传递函数依赖。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      它也会存在数据冗余、更新异常、插入异常和删除异常的情况，读者可自行分析得知。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      把学生关系表分为如下两个表：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      学生：(学号, 姓名, 年龄, 所在学院)；
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      学院：(学院, 地点, 电话)。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <strong>
       1.4 鲍依斯-科得范式（BCNF是3NF的改进形式）
      </strong>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      若关系模式R是第一范式，且每个属性都不传递依赖于R的候选键。这种关系模式就是BCNF模式。即在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合鲍依斯-科得范式。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (仓库ID, 存储物品ID) →(管理员ID, 数量)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (管理员ID, 存储物品ID) → (仓库ID, 数量)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (仓库ID) → (管理员ID)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (管理员ID) → (仓库ID)
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      即
      <span style="color:#ff0000">
       存在关键字段决定关键字段的情况，所以其不符合BCNF
      </span>
      <span style="color:#ff0000">
       范式
      </span>
      。它会出现如下异常情况：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (1) 删除异常：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (2) 插入异常：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      当仓库没有存储任何物品时，无法给仓库分配管理员。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      (3) 更新异常：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      如果仓库换了管理员，则表中所有行的管理员ID都要修改。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      把仓库管理关系表分解为二个关系表：
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      仓库管理：StorehouseManage(仓库ID, 管理员ID)；
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      仓库：Storehouse(仓库ID, 存储物品ID, 数量)。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <strong>
       四种范式之间存在如下关系：
      </strong>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      <img alt="" src="http://dl.iteye.com/upload/attachment/318912/3a355af3-9f9c-3109-8c5e-b21e3600847b.gif">
       <br/>
       <br/>
       <img alt="" src="http://dl.iteye.com/upload/attachment/318920/fa4fcfba-7888-310d-bd10-a736ef1ac97d.gif"/>
      </img>
     </p>
     <p style="color:rgb(0,0,0)">
     </p>
     <p style="color:rgb(0,0,0)">
      quote:
      <a href="http://jacki6.iteye.com/blog/774866" rel="nofollow noopener noreferrer" target="_blank">
       http://jacki6.iteye.com/blog/774866
      </a>
     </p>
    </div>
   </div>
  </div>
 </article>
</div>


