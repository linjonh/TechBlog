---
layout: post
title: "前端面试如何理解this指向"
date: 2022-10-24 19:57:14 +0800
description: "this指向真的是老生常谈的问题，在八股文当中也占据很重要的位置，面试过程中也会经常问道this指向"
keywords: "前端this指向"
categories: ['面试题目']
tags: ['前端', 'Javascript', '1024程序员节']
artid: "127447570"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=127447570
    alt: "前端面试如何理解this指向"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端面试——如何理解this指向？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;">
     <a href="#%E5%89%8D%E8%A8%80" rel="nofollow">
      前言
     </a>
    </p>
    <p id="%E4%B8%80%E3%80%81this%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E5%90%91-toc" style="margin-left:0px;">
     <a href="#%E4%B8%80%E3%80%81this%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E5%90%91" rel="nofollow">
      一、this在不同函数中的指向
     </a>
    </p>
    <p id="1.%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;">
     <a href="#1.%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1" rel="nofollow">
      1.普通函数this指向全局对象
     </a>
    </p>
    <p id="%C2%A02.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91new%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;">
     <a href="#%C2%A02.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91new%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1" rel="nofollow">
      2.构造函数指向new这个对象
     </a>
    </p>
    <p id="3.%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E4%B8%8A%E4%B8%80%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0-toc" style="margin-left:40px;">
     <a href="#3.%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E4%B8%8A%E4%B8%80%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0" rel="nofollow">
      3.箭头函数指向上一级作用域
     </a>
    </p>
    <p id="4.%E5%AF%B9%E8%B1%A1%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;">
     <a href="#4.%E5%AF%B9%E8%B1%A1%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1" rel="nofollow">
      4.对象函数指向这个对象
     </a>
    </p>
    <p id="5.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%90%91%E8%BF%99%E4%B8%AA%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;">
     <a href="#5.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%90%91%E8%BF%99%E4%B8%AA%E6%95%B0%E7%BB%84" rel="nofollow">
      5.数组中有函数，指向这个数组
     </a>
    </p>
    <p id="6.apply%E3%80%81call%E8%B0%83%E7%94%A8%E6%97%B6%E6%8C%87%E5%90%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%88%99%E9%BB%98%E8%AE%A4window-toc" style="margin-left:40px;">
     <a href="#6.apply%E3%80%81call%E8%B0%83%E7%94%A8%E6%97%B6%E6%8C%87%E5%90%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%88%99%E9%BB%98%E8%AE%A4window" rel="nofollow">
      6.apply、call调用时指向第一个参数，没有则默认window
     </a>
    </p>
    <p id="%C2%A07.window%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91window%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;">
     <a href="#%C2%A07.window%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91window%E5%AF%B9%E8%B1%A1" rel="nofollow">
      7.window内置对象指向window对象
     </a>
    </p>
    <p id="%E4%BA%8C%E3%80%81%E9%A2%84%E7%BC%96%E8%AF%91-toc" style="margin-left:0px;">
     <a href="#%E4%BA%8C%E3%80%81%E9%A2%84%E7%BC%96%E8%AF%91" rel="nofollow">
      二、预编译
     </a>
    </p>
    <p id="1.js%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;">
     <a href="#1.js%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4" rel="nofollow">
      1.js执行步骤
     </a>
    </p>
    <p id="2.%E9%A2%84%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;">
     <a href="#2.%E9%A2%84%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8" rel="nofollow">
      2.预编译作用
     </a>
    </p>
    <p id="3.%E9%A2%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;">
     <a href="#3.%E9%A2%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4" rel="nofollow">
      3.预编译步骤
     </a>
    </p>
    <hr/>
    <h2 id="%E5%89%8D%E8%A8%80">
     <a id="_7">
     </a>
     前言
    </h2>
    <p>
     this指向真的是老生常谈的问题，在八股文当中也占据很重要的位置，面试过程中也会经常问道this指向问题，那么我们今天就来看看this指向和实践把~
    </p>
    <p>
     后面还浅讲了以下预编译~有兴趣继续往下看吧~
    </p>
    <hr/>
    <h2 id="%E4%B8%80%E3%80%81this%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E5%90%91">
     <strong>
      一、this在不同函数中的指向
     </strong>
    </h2>
    <h3 id="1.%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0this%E6%8C%87%E5%90%91%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1">
     1.普通函数this指向全局对象
    </h3>
    <p>
     注意：浏览器默认对象是window，下面例子中函数内部没有全局对象，所以找到了window对象
    </p>
    <pre><code class="language-javascript">   var b = 22
    function Comm() {
        let a = 11
        console.log(this.a) //let作用域是函数作用域，不是window对象
        console.log(this.b) //var定义的是window对象
    }
    Comm()//普通函数</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="85" src="https://i-blog.csdnimg.cn/blog_migrate/7440c48b62913c97d0ac17afdeec2741.png" width="593"/>
    </p>
    <h3 id="%C2%A02.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91new%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1">
     2.构造函数指向new这个对象
    </h3>
    <pre><code class="language-javascript"> var b = 22
    function Comm() {
        console.log(this)
    }
   
    const arrowsFyn = new Comm() //构造函数
    console.log(arrowsFyn)</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="92" src="https://i-blog.csdnimg.cn/blog_migrate/f8453f0d6ccff60af537cd5fdff35a3d.png" width="598"/>
    </p>
    <h3 id="3.%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E4%B8%8A%E4%B8%80%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0">
     3.箭头函数指向上一级作用域
    </h3>
    <p>
     注意：箭头函数没有this，永远是指向上层作用域
    </p>
    <pre><code class="language-javascript"> var b = 22  
 const arrowFun =(a,b)=&gt;{
            console.log(this.b,b)
    }
    arrowFun(2,3) //监听函数指向上一层作用域</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="33" src="https://i-blog.csdnimg.cn/blog_migrate/1b41e326bac838c68aac37d461cf44a2.png" width="192"/>
    </p>
    <h3 id="4.%E5%AF%B9%E8%B1%A1%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1">
     4.对象函数指向这个对象
    </h3>
    <pre><code class="language-javascript">   const obj= {
        a:3,
        objFun:function () {
           console.log(this)
        }
    }
    obj.objFun()//对象函数</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="45" src="https://i-blog.csdnimg.cn/blog_migrate/45e64f97556ebee391022cc193adc7bf.png" width="263"/>
    </p>
    <p>
    </p>
    <p>
     当然，还有一种可能，如果对象函数是箭头函数得话，那this也会指向父级作用域，比如：
    </p>
    <pre><code class="language-javascript">  var a = 666
    const obj= {
        a:3,
        objFun:()=&gt;{
            console.log(this.a)
        }
    }
    obj.objFun()//对象函数</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="21" src="https://i-blog.csdnimg.cn/blog_migrate/4e3f79357255913d1658532805599d18.png" width="209"/>
    </p>
    <h3 id="5.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%EF%BC%8C%E6%8C%87%E5%90%91%E8%BF%99%E4%B8%AA%E6%95%B0%E7%BB%84">
     5.数组中有函数，指向这个数组
    </h3>
    <pre><code class="language-javascript">   function Comm() {
        console.log(this)
    }
    var arr = [2,3,Comm ,4]
    arr[2]() //数组中有函数</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="46" src="https://i-blog.csdnimg.cn/blog_migrate/f85753add5e68f040a5644b028a4b6f1.png" width="287"/>
    </p>
    <h3 id="6.apply%E3%80%81call%E8%B0%83%E7%94%A8%E6%97%B6%E6%8C%87%E5%90%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%88%99%E9%BB%98%E8%AE%A4window">
     6.apply、call调用时指向第一个参数，没有则默认window
    </h3>
    <p>
     注意：关于着两个参数（还有一个bind得具体作用和区别，可以参考这篇：）,他们可以改变this得指向
    </p>
    <pre><code class="language-javascript">  var a =33 //关键是这里是否定义
    function Comm() {
        console.log(this)
  
    }
   Comm.apply(this.a)</code></pre>
    <p>
     没有定义a ,输出：
    </p>
    <p>
     <img alt="" height="63" src="https://i-blog.csdnimg.cn/blog_migrate/e824fd079e1c807bd061ead720dbe894.png" width="575"/>
    </p>
    <p>
     定义a后输出：
    </p>
    <p>
     <img alt="" height="37" src="https://i-blog.csdnimg.cn/blog_migrate/cf301c9bc5946262baeef1946c0a75af.png" width="300"/>
    </p>
    <h3 id="%C2%A07.window%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91window%E5%AF%B9%E8%B1%A1">
     7.window内置对象指向window对象
    </h3>
    <pre><code class="language-javascript"> setTimeout(()=&gt;{
        console.log(this)
    }，1000)

</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="61" src="https://i-blog.csdnimg.cn/blog_migrate/67521fdbe08ca4fd74d9639301d5f293.png" width="568"/>
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E9%A2%84%E7%BC%96%E8%AF%91">
     <a id="_19">
     </a>
     二、预编译
    </h2>
    <h3 id="1.js%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4">
     1.js执行步骤
    </h3>
    <p>
     <span style="color:#4d4d4d;">
      这里浅说一下预编译，在js运行时，会对代码进行预编译，步骤如下：
     </span>
    </p>
    <p>
     1.检查语法是否符合规范。不符合则报错提示，符合则继续下一步
    </p>
    <p>
     2.预编译
    </p>
    <p>
     3.解释执行
    </p>
    <p>
     <span style="color:#333333;">
      那么为什么要有预编译这一步呢？
     </span>
    </p>
    <h3 id="2.%E9%A2%84%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8">
     2.预编译作用
    </h3>
    <p>
     因为在js中可以有函数和变量，那么可能会出现以下情况：
    </p>
    <p>
     1.先使用后定义，这就是
     <span style="color:#511b78;">
      <strong>
       变量声明提升
      </strong>
     </span>
    </p>
    <p>
     2.函数总是在变量之前编译，这叫
     <strong>
      <span style="color:#511b78;">
       函数声明提升
      </span>
     </strong>
    </p>
    <h3 id="3.%E9%A2%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4">
     <span style="color:#333333;">
      3.预编译步骤
     </span>
    </h3>
    <p>
     <span style="color:#333333;">
      预编译分为全局预编译和函数预编译~
     </span>
    </p>
    <p>
     <strong>
      全局预编译
     </strong>
     会在js执行之前执行，例如定义了一个变量，变量赋值等等
    </p>
    <p>
     <strong>
      函数预编译
     </strong>
     会在函数调用得时候执行
    </p>
    <p>
     他们得步骤相似，但又有区别，下面我们来看看他们分别得步骤吧~
    </p>
    <p>
     下面我们用一段代码来解释一下
    </p>
    <pre><code class="language-javascript"> function change(a) {//2 .由于函数声明提升，这个函数会被提到逻辑之前解析
        console.log(a,"你好，这里是函数预编译")
         function funny(){} //3 函数体内有函数声明啦，Ao中要赋值
    }
    change(2)
    var a //1. 这个变量在js加载之前就开始啦
    a =333
    console.log(a,"这里是全局预编译")
</code></pre>
    <p>
     <span style="color:#4d4d4d;">
     </span>
     <span style="color:#511b78;">
      <strong>
       1.全局预编译
      </strong>
     </span>
    </p>
    <p>
     上面定义变量就是全局预编译，他会执行以下几个步骤：
    </p>
    <blockquote>
     <p>
      1.创建Go（window）对象 。于是存在了   Go{ }
     </p>
    </blockquote>
    <blockquote>
     <p>
      2.找变量声明，初始值为undefined。于是存在  Go{ a:undefined }
     </p>
    </blockquote>
    <blockquote>
     <p>
      3.找函数声明。于是存在   Go{a:undefined ,change:function change(a){ console.log(a,"你好，这里是函数预编译") } }
     </p>
    </blockquote>
    <p>
     然后执行到change(2)得时候，就会对函数进行预编译：
    </p>
    <blockquote>
     <p>
      1.创建Ao对象。于是存在 Ao{ }
     </p>
    </blockquote>
    <blockquote>
     <p>
      2.找形参和实参。于是存在  Ao{ a:undefined }
     </p>
    </blockquote>
    <blockquote>
     <p>
      3.形参实参统一。于是存在 Ao { a:2 }
     </p>
    </blockquote>
    <blockquote>
     <p>
      4.函数体内找函数声明，值赋予给函数体。于是存在  Ao{ a:2 ,funny:function funny(){} }
     </p>
    </blockquote>
    <p>
     所以，这段代码最后得输出结果如下：
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="73" src="https://i-blog.csdnimg.cn/blog_migrate/69b54adaff007dd8a6b44ccab3f99e81.png" width="263"/>
    </p>
    <p>
     好啦，讲完后，我再把这个稍微修改以下，我们来看看输出吧~
    </p>
    <pre><code class="language-javascript">  function change(a) {//2 .由于函数声明提升，这个函数会被提到逻辑之前解析
        console.log(funny,"这里是funny，会被函数覆盖")
        console.log(a,"你好，这里是函数预编译")
        var funny = "开心得很呀~"
        function funny(){} //3 函数体内有函数声明啦，Ao中要赋值
    }
    change(2)</code></pre>
    <p>
     输出：
    </p>
    <p>
     <img alt="" height="141" src="https://i-blog.csdnimg.cn/blog_migrate/03fefab2270dc88132e5197cd1647bf0.png" width="349"/>
    </p>
    <p>
     可以看出，这里得字符串funny由于预编译，已经被替换成了funny函数啦~
    </p>
    <p>
     好啦，关于预编译就讲到这里啦~
    </p>
    <hr/>
    <p>
     <strong>
      总结
     </strong>
    </p>
    <p>
     以上就是今天要讲的内容，本文仅仅简单介绍了this在js中指向问题，并浅浅介绍了预编译得原理~希望对你有用吧~,可以得话一键三连哟。
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f445731343638372f:61727469636c652f64657461696c732f313237343437353730" class_="artid" style="display:none">
 </p>
</div>


