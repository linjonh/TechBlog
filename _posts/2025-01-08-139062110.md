---
layout: post
title: "Vue-采用blob下载后端返回的pdf流或者excel流文件乱码问题解决方案"
date: 2025-01-08 10:57:35 +0800
description: "打开或者预览全是乱码。预览pdf如下图：解决办法：1. 后端接口返回的blob文件流，你下载下来的文"
keywords: "new blob文件设置编码"
categories: ['未分类']
tags: ['Pdf']
artid: "139062110"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=139062110
  alt: "Vue-采用blob下载后端返回的pdf流或者excel流文件乱码问题解决方案"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Vue 采用blob下载后端返回的pdf流或者excel流文件乱码问题解决方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     流文件乱码问题解决方案
    </h5>
    <ul>
     <li>
      <ul>
       <li>
        <a href="https://link.csdn.net/?target=%23_3" rel="nofollow" title="问题介绍：">
         问题介绍：
        </a>
       </li>
       <li>
        <a href="https://link.csdn.net/?target=%23_18" rel="nofollow" title="一、前端方式解决：">
         一、前端方式解决：
        </a>
       </li>
      </ul>
     </li>
     <li>
      <a href="https://link.csdn.net/?target=%23_87" rel="nofollow" title="二、后端方式解决：">
       二、后端方式解决：
      </a>
     </li>
     <li>
      <ul>
       <li>
        <a href="https://link.csdn.net/?target=%23_134" rel="nofollow" title="三、文件预览实现">
         三、文件预览实现
        </a>
       </li>
       <li>
        <a href="https://link.csdn.net/?target=%23_197" rel="nofollow" title="四、点击按钮打开新窗口预览">
         四、点击按钮打开新窗口预览
        </a>
        <h4 id="devmenu1">
         问题介绍：
        </h4>
        <p>
         打开或者预览全是乱码。预览pdf如下图：
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/24febba6e4a38fffb53889338a223539.png"/>
        </p>
        <p>
         <strong>
          解决办法：
         </strong>
        </p>
        <p>
         <strong>
          1. 后端接口返回的blob文件流，你下载下来的文件是乱码的？
         </strong>
        </p>
        <p>
         解决办法 ：让你的后端设置流的编码为utf-8。请跟后端大佬说，一定要给blob格式的文件流。
        </p>
        <p>
         <strong>
          2. 后端返回的blob文件流，并且已经设置了utf-8,但是你接受的接口返回值，依然是乱码？
         </strong>
        </p>
        <p>
         解决办法： 肯定没有设置 responseType: “arraybuffer”。
        </p>
        <h4 id="devmenu2">
         一、前端方式解决：
        </h4>
        <p>
         <strong>
          预览pdf如下图：
         </strong>
        </p>
       </li>
       <li>
        <p>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/78b0f8e2ec3894c08e6e24ef0ccca605.png"/>
        </p>
        <blockquote>
         <pre>这个charset=utf-8一定要添加，不添加可能乱码，如果后台返回的格式里面有，那就没必要了！
</pre>
        </blockquote>
        <blockquote>
         <pre>代码：
const binaryData = []
binaryData.push(res.data)
// 获取blob链接
this.pdfUrl = window.URL.createObjectURL(new Blob(binaryData, { type: ‘application/pdf;charset=utf-8’ }))
window.open(this.pdfUrl)
</pre>
        </blockquote>
        <p>
         <strong>
          pdf下载如下图：
         </strong>
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3379924b6864e5182f4e3d78680e89f3.png"/>
        </p>
        <blockquote>
         <pre>代码如下：
this.pdfUrl = window.URL.createObjectURL(new Blob([res.data], { type: application/pdf;charset=utf-8 }))
const fname = 合同 // 下载文件的名字
const link = document.createElement(‘a’)
console.log(this.pdfUrl)
link.href = this.pdfUrl
link.setAttribute(‘download’, fname)
document.body.appendChild(link)
link.click()
</pre>
        </blockquote>
        <blockquote>
         <pre>代码：
export default {
  name: 'pdf',
  async mounted () {
    this.pdfHeight = '100%'
    this.ewpId = this.$route.query.ewpId
    this.pdfUrl = await this.getPdf(this.baseUrl + '/rcgl/TalPolicy/onlinePreview?id=' + this.ewpId + '&amp;BDSOFT-TOKEN=' + this.userToken)
  },
  data () {
    return {
      baseUrl: process.env.VUE_APP_BASE_API,
      pdfUrl: '',
      ewpId: '',
      pdfHeight: 0
    }
  },
  methods: {
    async getPdf (url) {
      // eslint-disable-next-line no-undef
      const data = await axios.get(url, {
        responseType: 'arraybuffer'
      })
      const blob = new Blob([data.data], { type: 'application/pdf' })
      return URL.createObjectURL(blob)
    }
  },
  computed: {
    ...mapState('global', {
      userToken: state =&gt; state.token,
      unitId: state =&gt; state.userInfo.b00
    })
  }
}
</pre>
        </blockquote>
        <h3 id="devmenu3">
         二、后端方式解决：
        </h3>
       </li>
       <li>
        <p>
         因为有的文件可能含有中文，因此在文件传输过程中会涉及到编码问题。后台的代码需要将输出流的编码格式设置为UTF-8。
        </p>
        <blockquote>
         <pre>response.setContentType("application/octet-stream;charset=UTF-8");
</pre>
        </blockquote>
        <p>
         另一种方式就是：（优先级最高）
        </p>
        <blockquote>
         <pre>response.setCharacterEncoding("UTF-8"); // 设置文件流编码格式 不然中文会乱码
</pre>
        </blockquote>
        <p>
         这样前端接收到输出流的时候是以Blob类型接收的。
        </p>
        <blockquote>
         <pre>代码:
 @Override
    public void onlinePreview(String filePath, HttpServletResponse response) throws Exception {
        //获取文件类型
        String[] str = filePath.split("\\.");
        if (str.length == 0) {
            throw new Exception("文件格式不正确");
        }
        String suffix = str[str.length - 1];
        if (!suffix.equals("txt") &amp;&amp; !suffix.equals("doc") &amp;&amp; !suffix.equals("docx") &amp;&amp; !suffix.equals("xls")
                &amp;&amp; !suffix.equals("xlsx") &amp;&amp; !suffix.equals("ppt") &amp;&amp; !suffix.equals("pptx")) {
            throw new Exception("文件格式不支持预览");
        }
        InputStream in = FileConvertUtil.convertLocaleFile(filePath, suffix);
        response.setContentType("application/octet-stream;charset=UTF-8");
        OutputStream outputStream = response.getOutputStream();
        //创建存放文件内容的数组
        byte[] buff = new byte[1024];
        //所读取的内容使用n来接收
        int n;
        //当没有读取完时,继续读取,循环
        while ((n = in.read(buff)) != -1) {
            //将字节数组的数据全部写入到输出流中
            outputStream.write(buff, 0, n);
        }
        //强制将缓存区的数据进行输出
        outputStream.flush();
        //关流
        outputStream.close();
        in.close();

    }

</pre>
        </blockquote>
        <h4 id="devmenu4">
         三、文件预览实现
        </h4>
        <p>
         <strong>
          controller 代码
         </strong>
        </p>
        <blockquote>
         <pre>@ApiOperation(value = "系统文件在线预览", notes = "系统文件在线预览")
    @GetMapping(Urls.TalPolicy.onlinePreview)
    public void onlinePreview(String id, HttpServletResponse  response) throws Exception {
        Assert.notNull(id, "用户id不能为空");
        TalPolicy Policy = TalPolicyService.getAllById(id);
        if (Policy != null) {
            String fid = Policy.getFileid();
            if (!StringUtils.isEmpty(fid)) {
                SAttachmentFile sAttachmentFile = fileManagerService.getById(fid);
                String filePath = sAttachmentFile.getFilepath();
                TalPolicyService.onlinePreview(filePath, response);
            }
        }
    }
</pre>
        </blockquote>
        <p>
         <strong>
          service 代码
         </strong>
        </p>
        <blockquote>
         <pre>void onlinePreview(String filePath, HttpServletResponse  response) throws Exception;
</pre>
        </blockquote>
        <p>
         <strong>
          serviceimpl代码
         </strong>
        </p>
        <blockquote>
         <pre> @Override
    public void onlinePreview(String filePath, HttpServletResponse response) throws Exception {
        //获取文件类型
        String[] str = filePath.split("\\.");
        if (str.length == 0) {
            throw new Exception("文件格式不正确");
        }
        String suffix = str[str.length - 1];
        if (!suffix.equals("txt") &amp;&amp; !suffix.equals("doc") &amp;&amp; !suffix.equals("docx") &amp;&amp; !suffix.equals("xls")
                &amp;&amp; !suffix.equals("xlsx") &amp;&amp; !suffix.equals("ppt") &amp;&amp; !suffix.equals("pptx")) {
            throw new Exception("文件格式不支持预览");
        }
        InputStream in = FileConvertUtil.convertLocaleFile(filePath, suffix);
        response.setContentType("application/octet-stream;charset=UTF-8");
        OutputStream outputStream = response.getOutputStream();
        //创建存放文件内容的数组
        byte[] buff = new byte[1024];
        //所读取的内容使用n来接收
        int n;
        //当没有读取完时,继续读取,循环
        while ((n = in.read(buff)) != -1) {
            //将字节数组的数据全部写入到输出流中
            outputStream.write(buff, 0, n);
        }
        //强制将缓存区的数据进行输出
        outputStream.flush();
        //关流
        outputStream.close();
        in.close();

    }

</pre>
        </blockquote>
        <p>
         工具类及其他详情步骤参考：
         <br/>
         <a href="https://link.csdn.net/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_41512902%2Farticle%2Fdetails%2F125558981" rel="nofollow" title="java用openOffice实现在线预览">
          java用openOffice实现在线预览
         </a>
        </p>
        <h4 id="devmenu5">
         四、点击按钮打开新窗口预览
        </h4>
        <blockquote>
         <pre> &lt;el-table-column
          label="操作"
          align="center"
          width="120px"&gt;
          &lt;template slot-scope="scope"&gt;
            &lt;div style="line-height: 1; font-size: 0;"&gt;
              &lt;el-button size="mini" @click="prewelRow(scope.row)"&gt;查看&lt;/el-button&gt;
            &lt;/div&gt;
          &lt;/template&gt;
        &lt;/el-table-column&gt;
</pre>
        </blockquote>
        <blockquote>
         <pre>data () {
    return {
      baseUrl: process.env.VUE_APP_BASE_API
      }
      },
computed: {
    ...mapState('global', {
      userToken: state =&gt; state.token,
      unitId: state =&gt; state.userInfo.b00
    })
  }
methods: {
 prewelRow: async function (row) {
      const pdfUrl = await this.getPdf(this.baseUrl + '/rcgl/TalPolicy/onlinePreview?id=' + row.recordid + '&amp;TOKEN=' +   	   		this.userToken)
      window.open(pdfUrl)
    },

}</pre>
</blockquote>
</li>
</ul>
</li>
</ul>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031343736323933332f:61727469636c652f64657461696c732f313339303632313130" class_="artid" style="display:none">
 </p>
</div>
