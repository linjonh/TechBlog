---
layout: post
title: "Kotlin-语法上的一些亮眼操作"
date: 2025-01-11 15:37:09 +0800
description: "Kotlin 语法上的一些亮眼操作Kotlin 初体验写在前面： 上上周我们创建了第一个 kotli"
keywords: "kotlin惊艳的用法"
categories: ['Android']
tags: ['函数式编程', 'Kotlin', 'Java', 'Android']
artid: "73184009"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=73184009
    alt: "Kotlin-语法上的一些亮眼操作"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Kotlin 语法上的一些亮眼操作
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2 id="kotlin-语法上的一些亮眼操作">
     Kotlin 语法上的一些亮眼操作
    </h2>
    <p>
     <a href="http://www.jianshu.com/p/ac7600182b87" rel="nofollow noopener noreferrer" target="_blank">
      Kotlin 初体验
     </a>
    </p>
    <p>
     写在前面：
     <br/>
     上上周我们创建了第一个 kotlin 的 android 应用。上周我花了一周的时间，在工作之余了解了 kotlin 的语法。感叹 kotlin 做为“高级”语言与 java相比，展现出来的简洁、高效、智能。不过如果有人问我 kotlin 和 java 的具体区别，那我肯定会首先描述为
     <strong>
      命令式编程语言
     </strong>
     和
     <strong>
      函数式编程语言
     </strong>
     的区别。
    </p>
    <p>
     <strong>
      命令式编程语言
     </strong>
     和
     <strong>
      函数式编程语言
     </strong>
     用概念描述，可以为：命令式编程语言泛指所有把修改变量的值当作最基本计算方式的语言，函数式编程语言指把一个程序的输出定义为其输入的数学函数的语言，纯函数式编程没有内部状态的概念，也没有副作用。
    </p>
    <p>
     对两者而言，我的体会并不深刻，所以来引用
     <strong>
      知乎
     </strong>
     的一段话：
    </p>
    <p>
     纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写“x = x + 1”，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。
    </p>
    <p>
     函数式语言的如条件语句，循环语句也不是命令式编程语言中的控制语句，而是函数的语法糖，比如在Scala语言中，if else不是语句而是三元运算符，是有返回值的。
    </p>
    <p>
     关于二者的比较可以进一步查阅资料来了解，对于理解编程语言的本质和计算机的构成，很有帮助。
    </p>
    <p>
     下面我们就来看看与 java 相比，kotlin 有哪些“高级”的语法。
    </p>
    <h3 id="函数扩展">
     函数扩展
    </h3>
    <pre class="prettyprint"><code class="hljs javascript">        val array: <span class="hljs-built_in">Array</span>&lt;Int&gt; = arrayOf(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
        val array3: <span class="hljs-built_in">Array</span>&lt;Int&gt; = arrayOf(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)
        <span class="hljs-comment">// 声明一个函数扩展，我们需要在函数前加一个接收者类型作为前缀。上面就是为 `Array&lt;Int&gt;` 添加一个 swap 函数</span>
        fun <span class="hljs-built_in">Array</span>&lt;Int&gt;.swap(x: Int, y: Int) {
            <span class="hljs-comment">// 在扩展函数中的 this 关键字对应接收者对象。</span>
            val temp: Int = <span class="hljs-keyword">this</span>[x]
            <span class="hljs-keyword">this</span>[x] = <span class="hljs-keyword">this</span>[y]
            <span class="hljs-keyword">this</span>[y] = temp
        }
        <span class="hljs-comment">// 可以在任何 Array&lt;Int&gt; 实例中使用这个函数了</span>
        array.swap(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        array3.swap(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)</code></pre>
    <p>
     如果用 java 来做的话，我们需要继承父类。或者用一个方法做这个操作，需要将 array 作为参数传递进去，这样一来就加大了出错概率，也不够自由美观，这就是扩展带来的好处。
    </p>
    <h3 id="空安全">
     空安全
    </h3>
    <p>
     导致 java 程序崩溃最多的 Exception 就是 NullPointerException 也叫 NPE，Kotlin 类型系统致力与消灭它。
    </p>
    <p>
     在 Kotlin 类型系统中可以为空和不可为空的引用是不同的。比如，普通的 String 类型的变量不能为空：
    </p>
    <pre class="prettyprint"><code class="hljs javascript">        <span class="hljs-keyword">var</span> s: <span class="hljs-built_in">String</span> = <span class="hljs-string">"activity"</span>
        s = <span class="hljs-literal">null</span> <span class="hljs-comment">//编译报错 普通字符串类型不可为空</span>

        <span class="hljs-keyword">var</span> t:<span class="hljs-built_in">String</span>? = <span class="hljs-string">"fragment"</span>
        t = <span class="hljs-literal">null</span> <span class="hljs-comment">//同?声明的 String 可以为空</span>

        print(s.length)<span class="hljs-comment">// 可以调用，这里的 s 永不为 null</span>
        print(t.length)<span class="hljs-comment">// 报错，这里的 t 可能为空</span></code></pre>
    <p>
     可以看到，这里在声明一些可能为 null 的引用时，kotlin 是区分对待的，并且在调用的时候自动判断它是否可能为 null，当可能为空的时候，直接用
     <code>
      .
     </code>
     调用，会直接报错。
    </p>
    <p>
     如果我们想调用，可以用条件判断的方式：
    </p>
    <pre class="prettyprint"><code class="hljs livecodeserver">        val u = <span class="hljs-keyword">if</span> (t != <span class="hljs-constant">null</span> &amp;&amp; t.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) {
            print(t.<span class="hljs-built_in">length</span>)
            t.<span class="hljs-built_in">length</span>
        } <span class="hljs-keyword">else</span> {
            -<span class="hljs-number">1</span>
        }</code></pre>
    <p>
     这样显然稍显啰嗦，kotlin 自然想到了这一点，这样安全操作符
     <code>
      ?.
     </code>
     就出现了。
    </p>
    <pre class="prettyprint"><code class="hljs fix"><span class="hljs-attribute">        val r: Int? </span>=<span class="hljs-string"> t?.length</span></code></pre>
    <p>
     这个表达式，当 t 为 null 时，返回 null，否则返回 t.length
    </p>
    <p>
     安全调用在链式调用是是很有用的。比如，如果 Bob 是一个雇员可能分配部门(也可能不分配)，如果我们想获取 Bob 的部门名作为名字的前缀，就可以这样做：
    </p>
    <pre class="prettyprint"><code class="hljs avrasm">    bob?<span class="hljs-preprocessor">.department</span>?<span class="hljs-preprocessor">.head</span>?<span class="hljs-preprocessor">.name</span> //这样的调用链在任何一个属性为空都会返回空</code></pre>
    <p>
     如果用 java 来做，那就会完全体现 java 的“又臭又长”了
    </p>
    <p>
     <strong>
      Elvis 操作符
     </strong>
     <br/>
     <code>
      ?:
     </code>
     Elvis 操作符表达的是，当左边表达式为空时，会执行右边的表达式。否则执行左边的表达式。
    </p>
    <pre class="prettyprint"><code class="hljs scala">        <span class="hljs-keyword">val</span> o = t?.length ?: -<span class="hljs-number">1</span>
        <span class="hljs-keyword">val</span> i = t?.length ?: <span class="hljs-keyword">throw</span> NullPointerException()</code></pre>
    <p>
     <strong>
      !! 表达式
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs erlang-repl">        <span class="hljs-function_or_atom">val</span> <span class="hljs-function_or_atom">y</span> = <span class="hljs-function_or_atom">t</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span>.<span class="hljs-function_or_atom">length</span></code></pre>
    <p>
     当 t 为 null 时，抛出一个 NPE，否则返回 t 的长度值。
    </p>
    <h3 id="智能转换">
     智能转换
    </h3>
    <p>
     <strong>
      is !is 表达式
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs glsl">    fun smartCast(<span class="hljs-built_in">any</span>: Any) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">any</span> is String) {
            println(<span class="hljs-built_in">any</span>.<span class="hljs-built_in">length</span>)<span class="hljs-comment">// x is automatically cast to String</span>
        }
    }</code></pre>
    <p>
     通过
     <code>
      is
     </code>
     关键字，在 if 表达式中，any 已经自动被转换成了 String 类型。
    </p>
    <p>
     <strong>
      安全转换 as?
     </strong>
    </p>
    <pre class="prettyprint"><code class="hljs vbnet">        val s: <span class="hljs-built_in">String</span>? = any <span class="hljs-keyword">as</span>? <span class="hljs-built_in">String</span></code></pre>
    <p>
     若 any 为 null 时，显然是不可以转换成 String 的，这时候用 as? 安全转换，如果失败了，则返回 null。
    </p>
    <h3 id="字符串模板">
     字符串模板
    </h3>
    <pre class="prettyprint"><code class="hljs nginx">        <span class="hljs-title">val</span> firstName = <span class="hljs-string">"Android"</span>

        val <span class="hljs-built_in">last</span>Name = <span class="hljs-string">"Studio"</span>

        println(<span class="hljs-string">"his name is <span class="hljs-variable">$firstName</span> <span class="hljs-variable">$lastName</span>"</span>)</code></pre>
    <p>
     如上所示，kotlin 可以用 $ 将一些值直接连接在字符串当中
    </p>
    <h3 id="单例模式">
     单例模式
    </h3>
    <p>
     在 java 中，我们创建一个单例模式的对象可能是这样子的：
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Utils {

    <span class="hljs-keyword">private</span> <span class="hljs-title">Utils</span>() { 
      <span class="hljs-comment">// This utility class is not publicly instantiable </span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span>(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">value</span>;
    }

}</code></pre>
    <p>
     在 kotlin 中，就方便了很多：
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">object</span> Utils {

    fun getScore(<span class="hljs-keyword">value</span>: Int): Int {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">value</span>
    }

}</code></pre>
    <h3 id="bean-对象">
     Bean 对象
    </h3>
    <p>
     在 java 中创建一个 bean 对象，可能是这样的：
    </p>
    <pre class="prettyprint"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Developer</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title">Developer</span>(String name, <span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>() {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span>(Object o) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        Developer developer = (Developer) o;

        <span class="hljs-keyword">if</span> (age != developer.age) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> name != <span class="hljs-keyword">null</span> ? name.equals(developer.name) : developer.name == <span class="hljs-keyword">null</span>;

    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span>() {
        <span class="hljs-keyword">int</span> result = name != <span class="hljs-keyword">null</span> ? name.hashCode() : <span class="hljs-number">0</span>;
        result = <span class="hljs-number">31</span> * result + age;
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Developer{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }
}</code></pre>
    <p>
     在 kotlin 中，可以使用 data 关键字，直接创建一个 bean 对象：
    </p>
    <pre class="prettyprint"><code class="hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> class <span class="hljs-type">Developer</span><span class="hljs-container">(<span class="hljs-title">var</span> <span class="hljs-title">name</span>: <span class="hljs-type">String</span>, <span class="hljs-title">var</span> <span class="hljs-title">age</span>: <span class="hljs-type">Int</span>)</span></span></code></pre>
    <h3 id="ranges">
     Ranges
    </h3>
    <p>
     kotlin 还有一些特有的属性，比如类型的推断啊，一级构造函数啊，等等。这些自己去撸文档就可以了，最后一个想说的就是 kotlin 中的 Ranges 属性。
    </p>
    <p>
     Ranges 操作符是由
     <code>
      in
     </code>
     关键字实现的：
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) {
    println(i) <span class="hljs-comment">// 打印 1 - 10 闭区间</span>
}

<span class="hljs-keyword">if</span> (x !<span class="hljs-keyword">in</span> <span class="hljs-number">1.0</span>.<span class="hljs-number">.3</span><span class="hljs-number">.0</span>) println(x)

<span class="hljs-keyword">if</span> (str <span class="hljs-keyword">in</span> <span class="hljs-string">"island"</span>..<span class="hljs-string">"isle"</span>) println(str)</code></pre>
    <p>
     当然还有更多的用法和关键字，根据打印值体会：
    </p>
    <pre class="prettyprint"><code class="hljs lua"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.4</span> step <span class="hljs-number">2</span>) <span class="hljs-built_in">print</span>(i) // prints <span class="hljs-string">"13"</span>

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">4</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>) <span class="hljs-built_in">print</span>(i) // prints <span class="hljs-string">"42"</span>

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.0</span>.<span class="hljs-number">.2</span><span class="hljs-number">.0</span> step <span class="hljs-number">0.3</span>) <span class="hljs-built_in">print</span>(<span class="hljs-string">"$i "</span>) // prints <span class="hljs-string">"1.0 1.3 1.6 1.9 "</span></code></pre>
    <p>
     好了本文对 kotlin 一些我认为很亮眼的语法和用法就介绍完成了，下一步我打算研究下 kotlin 在快速开发 android 上，有哪些黑科技。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f4d656c6f446576:2f61727469636c652f64657461696c732f3733313834303039" class_="artid" style="display:none">
 </p>
</div>


