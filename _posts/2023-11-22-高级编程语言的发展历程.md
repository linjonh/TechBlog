---
layout: post
title: 2023-11-22-高级编程语言的发展历程
date: 2023-11-22 22:55:52 +0800
categories: [编程语言]
tags: [语言,编程,lisp,fortran,ibm,跨平台]
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=7251110
  alt: 高级编程语言的发展历程
artid: 7251110
---
<span class="artid" style="display:none" artid=6874747073:3a2f2f626c6f672e6373646e2e6e65742f6564736f6e313938:352f61727469636c652f64657461696c732f37323531313130></span>
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     高级编程语言的发展历程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    目录
    <p>
     <a href="http://kb.cnblogs.com/page/130672/#c1" rel="nofollow">
      高级编程语言的发展历程（一）创始纪
     </a>
     <br/>
     <a href="http://kb.cnblogs.com/page/130672/#c2" rel="nofollow">
      高级编程语言的发展历程（二）虚拟机的前世今生
     </a>
     <br/>
     <a href="http://kb.cnblogs.com/page/130672/#c3" rel="nofollow">
      高级编程语言的发展历程（三）FORTRAN 语言是怎么来的
     </a>
     <br/>
     <a href="http://kb.cnblogs.com/page/130672/#c4" rel="nofollow">
      高级编程语言的发展历程（四）LISP 和 AI 的青梅竹马 A
     </a>
     <br/>
     <a href="http://kb.cnblogs.com/page/130672/#c5" rel="nofollow">
      高级编程语言的发展历程（五）LISP 和 AI 的青梅竹马 B
     </a>
     <br/>
     <a href="http://kb.cnblogs.com/page/130672/#c6" rel="nofollow">
      高级编程语言的发展历程（六）SCHEME 语言是怎么来的
     </a>
     <br/>
     <a href="http://kb.cnblogs.com/page/130672/#c7" rel="nofollow">
      高级编程语言的发展历程（七） LISP 语言前传
     </a>
    </p>
    <p>
     原文标题：高级语言是怎么来的
     <strong>
      <br/>
     </strong>
    </p>
    <p>
     <strong>
      <a name="c1">
      </a>
      高级编程语言的发展历程（一） 创始纪
     </strong>
    </p>
    <p>
     2009-5-13
     <a href="http://blog.youxu.info/2009/05/13/hpl/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
    </p>
    <p>
     终于放暑假了，有心情来八卦了。我主要想八卦一下高级语言的设计思想和各种范式的来龙去脉，也就是回答这个问题：编程语言为什么会发生成现在这个样子哩?这里面的奥妙又在哪里哩? 我尝试着把这个系列的八卦写下去，包括虚拟机的设计、线程的设计、栈和寄存器两大流派的来龙去脉等等。
    </p>
    <p>
     高级编程语言的创始纪上写道：“初，世间无语言，仅电路与连线。及大牛出，天地开，始有 FORTRAN, LISP。ALGOL 随之，乃有万种语。” 我们都知道，LISP 是基于递归函数的，FORTRAN 是做科学计算的。现在的 C 等等，都比较像 FORTRAN 而不像 LISP。可是很少有人知道，最初，FORTRAN 是不支持函数递归调用的，而LISP是一生下来就支持的，所有高级语言里面的递归调用，都是逐渐从 LISP 那里学来的。这段尘封的历史非常有趣，值得八卦一番。
    </p>
    <p>
     一般人学编程，除了写 Hello World 之外，人生写的第二个程序，不是阶乘就是菲波拉契数列，要不就是汉洛塔。而这几个程序，基本上都是因为函数的递归调用才显得简单漂亮。没有递归的日子里， 人民非常想念您。可是，第一版的 FORTRAN 就居然不支持递归。 细心的读者要问了，不支持递归的语言能图灵完全么？当然可以，图灵机就是没递归的典型的例子。但是没递归调用的程序会很难写，尤其像汉诺塔这种。那 么，FORTRAN 他怎么就悍然不支持递归呢，让我们回到 1960 年。
    </p>
    <p>
     话说当年，IBM 是计算机行业的领军者。那时候的计算机，都是比柜子还大的大家伙，至于计算能力嘛，却比你的手机还弱。那时候计算机所做的最多的事情，不是发邮件打游戏， 而是作计算。作计算嘛，自然需要一种和数学语言比较接近的编程语言。于是，1960年，IBM 就捣鼓出了 FORTRAN，用行话说，就是公式翻译系统。这 个公式翻译系统，就成了世界上第一个编程语言。这个编程语言能做数学计算，能作条件判断，能 GOTO。用现在的眼光看，这个语言能够模拟图灵机上的一切操作，所以是图灵完全的。学过数值计算的同学都知道，科学计算无非就是一大堆数学计算按照步骤进行而已。所以，一些控制判断语句，数学公式加上一个数组，基本上就能完成所有的科学计算了。IBM 觉得这个语言够用了，就发布了 FORTRAN 语言规范，并且在自家的大型机上实现了这个语言。
    </p>
    <p>
     在实现这个语言的时候，IBM 的工程师要写一个 FORTRAN 编译器 （请注意那时候的大型机没有操作系统）。那时候的编译器都是用机器语言或者很低级的汇编语言写成的，所以编译器要越简单越好。这些工程师觉得，弄一个让用户运行时动态开辟内存的机制太麻烦了，所以干脆，强迫用户在写程序的时候，就要定好数组的大小，变量的类型和数目。这个要求并不过分，因为在科学计算中， 数组的维度，用到的变量等，在计算之前，就是可以知道大小的。用现在的话说，就是不能动态开辟内存空间，也就相当于没有 malloc 的 C，或者没有 new 的 C++。这样的好处是，一个程序要多少内存，编译的时候就知道的一清二楚了。这个主意看上去很聪明，不过 IBM 的工程师比你想得更加聪明，他们想，既然一个程序或者子程序要多少内存在编译的时候都知道了，我们干脆就静态的把每个子程序在内存中的位置，子程序中参数，返回值和局部变量放的位置，大小都定好，不久更加整齐高效么。是的，我们都知道，在没有操作系统管理的情况下，程序的内存策略越简单越好，如果内存放的整整齐齐的，计算机的管理员就能够很好的管理机器的内存，这样也是一件非常好的事情。（再次强调，当年还没有操作系统呢，操作系统要等到1964年发布 的 IBM 360 才有，具体开发一个操作系统之难度可参考《人月神话》）。
    </p>
    <p>
     可是，聪明的读者一下子就看出来了，这样静态的搞内存分配，就递不成归不了。为啥呢？试想，我有个 Fib 函数，用来计算第 N 个菲波拉契数。这个函数输入一个整数，返回一个整数，FORTRAN 编译器帮我把这个函数给静态分配了。好，我运行 Fib(5) 起来，FORTRAN 帮我把 5 存在某个专门给输入参数的位置。我在 Fib(5) 里面递归的调用了Fib(4)，FORTRAN 一看，哈，不还是 Fib 么，参数是 4，我存。这一存，新的参数4，就把原来的 5 给覆盖掉了，新的返回值，也把原来的返回值给覆盖掉了。大事不好了，这么一搞，新的调用的状态居然覆盖了老的调用，这下，就没法返回原来的 Fib(5) 了，这样一搞，怎么递归啊？
    </p>
    <p>
     IBM 这些写编译器的老前辈们，不是不知道这个问题，而是压根就鄙视提出这个问题的人：你丫科学计算递归什么呀，通通给我展开成循环，展不开是你数学没学好，想用递归，你就不要用 FORTRAN 了。那时候 IBM 乃是老大，只有他们家才生产大型机，老大发话，下面的消费者只能听他的。
    </p>
    <p>
     既然软件不支持，硬件也就可以偷工减料嘛，所以，硬件上，就压根没有任何栈支持。我们都知道，计算机发展史上，软件和硬件是相互作用的。我们现在也很难猜测，是 IBM 的软件工程师因为 IBM 的硬件工程师没有在硬件上设计出堆栈，所以没有能在 FORTRAN 里面设计出递归调用呢，还是 IBM 的硬件工程师觉得既然软件没要求，我就不设计了呢？不管怎么样，我们看到的是，1960 年前，所有的机器的硬件都没有直接支持栈的机制。熟悉 CPU 的都知道，现代 CPU 里面，都有两个至关重要的地址寄存器，一个叫做 PC(Program Counter)， 用来标记下一条要执行的指令的位置，还有一个就是栈顶指针 SP(Stack Pointer)。如果没有后者，程序之间的调用就会非常麻烦，因为需要程序员手工维护一个栈，才能保证程序之间调用最后还能正确的返回。而当年，因为 FORTRAN 压根就不支持递归，所以支持 FORTRAN 的硬件，就省去了栈指针了。如果一个程序员想要递归调用，唯一的实现方法，就是让程序员借用一个通用寄存器作为栈指针，自己硬写一个栈，而且不能用 FORTRAN。
    </p>
    <p>
     因为 FORTRAN 不支持递归调用，按照自然规律，自然会有支持递归的语言在同时代出现。于是，很快的，LISP 和 ALGOL 这两个新语言就出道了。我们只说 LISP，它的创始人 John McCarchy 是 MIT 教授，也是人工智能之父，是学院派人物。他喜欢阿隆佐·邱奇(
     <a href="http://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87" rel="nofollow noopener noreferrer" target="_blank">
      Alonzo Church
     </a>
     )的那一套 Lambda 演算，而非图灵的机械构造。所以，LISP 从一开始，就支持递归的调用，因为递归就是 lambda 演算的灵魂. 但是有两大问题摆在 McCarchy 面前。一是他的 LISP 理论模型找不到一个可以跑的机器，二是他的 LISP 模型中有一个叫做 eval 的指令，可以把一个字符串当成指令在运行时求值，而这个，当时还没有人解决过。按照 Paul Graham 大叔在他的《黑客与画家》 里面的说法，McCarchy 甚至压根就不想实现这个 eval 指令，因为当 IBM 的一个叫 Steve Russell 的工程师宣称要实现 eval 的时候，McCarthy 还连连摇手说理论是理论，实际是实际，我不指望这个能被实现。可是，Russell 居然就把这两个问题一并给解决了（这哥们也是电子游戏创始人，史上第一个电子游戏就是他写的，叫 Space War）。他的方法，说来也简单，就是写了一个解释器，让 LISP 在这个解释器里面跑。这个创举，让传统上编译 -&gt; 运行 的高级语言流程，变成了编写 -&gt; 解释执行的流程，也就是著名的 REPL(
     <span class="st">
      <a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="nofollow noopener noreferrer" target="_blank">
       read–eval–print loop
      </a>
      )
     </span>
     流程。他做的事情，相当于在IBM 的机器上用机器码写了一个通用图灵机，用来解释所有的 LISP 指令。这个创举，就让 LISP 从理论走到了实践。
    </p>
    <p>
     因为有了运行时的概念，LISP 想怎么递归，就可以怎么递归，只要运行时支持一个软件实现的栈就可以了。上面我也说了，也就是写解释器的人麻烦一点而已，写 LISP 程序的人完全就可以不管下层怎么管理栈的了。同时，有了解释器，也解放了原来动态分配空间的麻烦，因为现在所有的空间分配都可以由解释器管理了，所以，运行时环境允许你动态的分配空间。对空间分配的动态支持，随之就带来了一项新技术：垃圾收集器。这个技术出现在 LISP 里面不是偶然的，是解释器的自然要求和归宿。在 FORTRAN 上本来被绕过的问题，就在 LISP 里面用全新的方法被解决了。LISP 的划时代意义和解释器技术，使得伴随的很多技术，比如抽象语法树，动态数据结构，垃圾收集，字节码等等，都很早的出现在了 LISP 中，加上 LISP 本身规则很少，使用起来非常灵活。所以，每当有一项新技术出现，特别是和解释器和运行时相关的一项新技术出现，我们就会听到有人说， “这玩意儿 LISP 里早就有了”，这话，是有一定道理的。
    </p>
    <p>
     除了上面的软件模拟之外，MIT 还有一派在作硬件模拟，这一派，以后发展成了灿烂一时的 LISP machine，为日后所有虚拟机理论铺开了一条新路。这一派在70、80年代迅速崛起，然后随着 PC 的兴起又迅速的陨落，让人唏嘘不已.
    </p>
    <p>
     最后附送一个八卦：1960 年的时候，高级语言编程领域也发生了一件大事，即 ALGOL 60 的提出。ALGOL 是划时代的标准，我们今天用的 C/Java 全是 ALGOL 家族的。ALGOL 注意到了 FORTRAN 不支持递归的问题，于是从一开始，就订立标准支持递归。但是，处理递归需要很小心的安排每个函数每次调用的地址和所谓的活动窗口(Active Frame)，而并不是每个编译器都是牛人写的，所以在处理递归这样一个新事物上，难免会出点小问题和小 BUG。这时候，搞笑的高爷爷(Knuth)出场了，他提出了一个测试，叫做“是男人就得负67”。(The man or boy test). 恕我功底不深，不能给各位读者把这个男人测试的关窍讲清楚，但是，我知道，这个测试，乃是看 ALGOL 60 编译器有没有正确的实现递归和外部引用的。照高爷爷的说法，真的男人要能得到正确答案，不是男人的就得不到正确答案。当然，高爷爷当时自己也没有男人编译器，所以自己猜了一个-121，后来，真的男人编译器出来了，正确答案是-67。可见，高爷爷的人脑编译器，也不是男人编译器。（各位欲知详情的，猛点
     <a href="http://en.wikipedia.org/wiki/Man_or_boy_test" rel="nofollow">
      这个
     </a>
     ）
    </p>
    <p>
     <a name="c2">
     </a>
     <strong>
      高级编程语言的发展历程（二）虚拟机的前世今生
     </strong>
    </p>
    <p>
     2009-6-13
     <a href="http://blog.youxu.info/2009/06/13/vm/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
     <strong>
     </strong>
    </p>
    <p>
     上节我们提到了 LISP 中，因为 eval 的原因，发展出了运行时环境这样一个概念。基于这个概念，日后发展出了虚拟机技术。但这段历史并不是平铺直叙的，实际上，这里面还经历了一个非常漫长而曲折的过程，说起来也是非常有意思的。本文我们就着重解释虚拟机的历史。
    </p>
    <p>
     我们21世纪的程序员，凡要是懂一点编程技术的，基本上都知道虚拟机和字节码这样两个重要的概念。所谓的字节码(bytecode)，是一 种非常类似于机器码的指令格式。这种指令格式是以二进制字节为单位定义的（不会有一个指令只用到一个字节的前四位），所以叫做字节码。所谓的虚拟机，就是说不是一台真的计算机，而是一个环境，其他程序能在这个环境中运行，而不是在真的机器上运行。现在主流高级语言如 Java, Python, PHP, C#，编译后的代码都是以字节码的形式存在的，这些字节码程序，最后都是在虚拟机上运行的。
    </p>
    <p>
     <strong>
      虚拟机的安全性和跨平台性
     </strong>
    </p>
    <p>
     虚拟机的好处大家都知道，最容易想到的是安全性和跨平台性。安全性是因为现在可执行程序被放在虚拟机环境中运行，虚拟机可以随时对程序的危险行为，比如缓冲区溢出，数组访问过界等等进行控制。跨平台性是因为只要不同平台上都装上了支持同一个字节码标准的虚拟机，程序就可以在不同的平台上不加修改而运行，因为虚拟机架构在各种不同的平台之上，用虚拟机把下层平台间的差异性给抹平了。我们最熟悉的例子就是 Java 了。Java 语言号称一次编写，到处运行(Write Once, Run Anywhere)，就是因为各个平台上的 Java 虚拟机都统一支持 Java 字节码，所以用户感觉不到虚拟机下层平台的差异。
    </p>
    <p>
     虚拟机是个好东西，但是它的出现，不是完全由安全性和跨平台性驱使的。
    </p>
    <p>
     <strong>
      跨平台需求的出现
     </strong>
    </p>
    <p>
     我们知道，在计算机还是锁在机房里面的昂贵的庞然大物的时候，系统软件都是硬件厂商附送的东西（是比尔·盖茨这一代人的出现，才有了和硬件产业分庭抗礼的软件产业），一个系统程序员可能一辈子只和一个产品线的计算机打交道，压根没有跨平台的需求。应用程序员更加不要说了，因为计算机很稀有，写程序都是为某一台计算机专门写的，所以一段时间可能只和一台庞然大物打交道，更加不要说什么跨平台了。真的有跨平台需求，是从微型计算机开始真的普及开始的。因为只有计算机普及了，各种平台都被广泛采用了，相互又不互相兼容软件，才会有软件跨平台的需求。微机普及的历史，比 PC 普及的历史要早10年，而这段历史，正好和 UNIX 发展史是并行重叠的。
    </p>
    <p>
     熟悉 UNIX 发展史的读者都知道， UNIX 真正普及开来，是因为其全部都用 C，一个当时绝对能够称为跨平台的语言重写了一次。又因为美国大学和科研机构之间的开源共享文化，C 版本的 UNIX 出生没多久，就迅速从原始的 PDP-11 实现，移植到了 DEC, Intel 等平台上，产生了无数衍生版本。随着跨平台的 UNIX 的普及， 微型计算机也更多的普及开来，因为只需要掌握基本的 UNIX 知识，就可以顺利操作微型计算机了。所以，微机和 UNIX 这两样东西都在 1970年 到 1980 年在美国政府、大学、科研机构、公司、金融机构等各种信息化前沿部门间真正的普及开来了。这些历史都是人所共知耳熟能详的。
    </p>
    <p>
     既然 UNIX 是跨平台的，那么，UNIX 上的语言也应当是跨平台的 （注: 本节所有的故事都和 Windows 无关，因为 Windows 本身就不是一个跨平台的操作系统）。UNIX 上的主打语言 C 的跨平台性，一般是以各平台厂商提供编译器的方式实现的，而最终编译生成的可执行程序，其实不是跨平台的。所以，跨平台是源代码级别的跨平台，而不是可执行程序层面的。而除了标准了 C 语言外，UNIX 上有一派生机勃勃的跨平台语言，就是脚本语言。（注：脚本语言和普通的编程语言相比，在能完成的任务上并没有什么的巨大差异。脚本语言往往是针对特定类型的问题提出的，语法更加简单，功能更加高层，常常几百行C语言要做的事情，几行简单的脚本就能完成）
    </p>
    <p>
     <strong>
      解释和执行
     </strong>
    </p>
    <p>
     脚本语言美妙的地方在于，它们的源代码本身就是可执行程序，所以在两个层面上都是跨平台的。不难看出，脚本语言既要能被直接执行，又要跨平台的话，就必然要有一个“东西”，横亘在语言源代码和平台之间。往上，在源代码层面，分析源代码的语法，结构和逻辑，也就是所谓的“解释”；往下，要隐藏平台差异，使得源代码中的逻辑，能在具体的平台上以正确的方式执行，也就是所谓的“执行”。
    </p>
    <p>
     虽说我们知道一定要这么一个东西，能够对上“解释”，对下“执行”，但是 “解释” 和 “执行” 两个模块毕竟是相互独立的，因此就很自然的会出现两个流派：“把解释和执行设计到一起”和“把解释和执行单独分开来”这样两个设计思路，需要读者注意的是，现在这两个都是跨平台的、安全的设计，而在后者中字节码作为了解释和执行之间的沟通桥梁，前者并没有字节码作为桥梁。
    </p>
    <p>
     <strong>
      解释和执行在一起的方案
     </strong>
    </p>
    <p>
     我们先说前者，前者的优点是设计简单，不需要搞什么字节码规范，所以 UNIX 上早期的脚本语言，都是采用前者的设计方法。我们以 UNIX 上大名鼎鼎的 AWK 和 Perl 两个脚本语言的解释器为例说明。AWK 和 Perl 都是 UNIX 上极为常用的、图灵完全的语言，其中 AWK， 在任何 UNIX 系统中都是作为标准配置的，甚至入选 IEEE POSIX 标准，是入选 IEEE POSIX 卢浮宫的唯一同类语言品牌，其地位绝对不是 UNIX 下其他脚本语言能够比的。这两个语言是怎么实现解释和运行的呢？我从 AWK 的标准实现中摘一段代码您一看就清楚了：
    </p>
    <div class="cnblogs_code">
     <pre><span style="color:#0000ff">int</span> main(<span style="color:#0000ff">int</span> argc, <span style="color:#0000ff">char</span> *argv[])
{
    ...
    syminit();
    compile_time = <span style="color:#800080">1</span>;
    yyparse();
    ...
    <span style="color:#0000ff">if</span> (errorflag == <span style="color:#800080">0</span>)
    {
        compile_time = <span style="color:#800080">0</span>;
        run(winner);
    }
    ...
}</pre>
    </div>
    <p>
     其中，run 的原型是：
    </p>
    <div class="cnblogs_code">
     <pre>run(Node *a)    <span style="color:#008000">/*</span><span style="color:#008000"> execution of parse tree starts here </span><span style="color:#008000">*/</span></pre>
    </div>
    <p>
     而 winner 的定义是：
    </p>
    <div class="cnblogs_code">
     <pre>Node *winner ;    <span style="color:#008000">/*</span><span style="color:#008000"> root of parse tree </span><span style="color:#008000">*/</span></pre>
    </div>
    <p>
     熟悉 Yacc 的读者应该能够立即看出，AWK 调用了 Yacc 解析源代码，生成了一棵语法树。按照 winner 的定义，winner 是这棵语法树的根节点。 在“解释”没有任何错误之后，AWK 就转入了“执行” (compile_time 变成了 0)，将 run 作用到这棵语法树的根节点上。不难想像，这个 run 函数的逻辑是递归的（事实上也是），在语法树上，从根依次往下，执行每个节点的子节点，然后收集结果。是的，这就是整个 AWK 的基本逻辑：对于一段源代码，先用解释器（这里 awk 用了 Yacc 解释器），生成一棵语法树，然后，从树的根节点开始，往下用 run 这个函数，遇山开山，遇水搭桥，一路递归下去，最后把整个语法树遍历完，程序就执行完毕了。（这里附送一个小八卦，抽象语法树这个概念是 LISP 先提出的，因为 LISP 是最早像 AWK 这样做的，LISP 实在是属于开天辟地的作品！）Perl 的源代码也是类似的逻辑解释执行的，我就不一一举例了。
    </p>
    <p>
     <strong>
      三大缺点
     </strong>
    </p>
    <p>
     现在我们看看这个方法的优缺点。优点是显而易见的，因为通过抽象语法树在两个模块之间通信，避免了设计复杂的字节码规范，设计简单。但是缺点也非常明显。最核心的缺点就是性能差，需要资源多，具体来说，就是如下三个缺点。
    </p>
    <p>
     缺点1，因为解释和运行放在了一起，每次运行都需要经过解释这个过程。假如我们有一个脚本，写好了就不修改了，只需要重复的运行，那么在一般应用下尚可以忍受每次零点几秒的重复冗余的解释过程，在高性能的场合就不能适用了。
    </p>
    <p>
     缺点2，因为运行是采用递归的方式的，效率会比较低。我们都知道，因为递归涉及到栈操作和状态保存和恢复等，代价通常比较高，所以能不用递归就不用递归。在高性能的场合使用递归去执行语法树，不值得。
    </p>
    <p>
     缺点3，因为一切程序的起点都是源代码，而抽象语法树不能作为通用的结构在机器之间互传，所以不得不在所有的机器上都布置一个解释+运行的模块。在资源充裕的系统上布置一个这样的系统没什么，可在资源受限的系统上就要慎重了，比如嵌入式系统上。鉴于有些语言本身语法结构复杂，布置一个解释模块的代价是非常高昂的。本来一个递归执行模块就很吃资源了，再加一个解释器，嵌入式系统就没法做了。所以， 这种设计在嵌入式系统上是行不通的。
    </p>
    <p>
     当然，还有一些其他的小缺点，比如有程序员不喜欢开放源代码，但这种设计中，一切都从源代码开始，要发布可执行程序，就等于发布源代码，所以，不愿意公布源代码的商业公司很不喜欢这些语言等等。但是上面的三个缺点，是最致命的，这三个缺点，决定了有些场合，就是不能用这种设计。
    </p>
    <p>
     <strong>
      分开解释和执行
     </strong>
    </p>
    <p>
     前面的三个主要缺点，恰好全部被第二个设计所克服了。在第二种设计中，我们可以只解释一次语法结构，生成一个结构更加简单紧凑的字节码文件。这样，以后每次要运行脚本的时候，只需要把字节码文件送给一个简单的解释字节码的模块就行了。因为字节码比源程序要简单多了，所以解释字节码的模块比原来解释源程序的模块要小很多；同时，脱离了语法树，我们完全可以用更加高性能的方式设计运行时，避免递归遍历语法树这种低效的执行方式；同时，在嵌入式系统上，我们可以只部署运行时，不部署编译器。这三个解决方案，预示了在运行次数远大于编译次数的场合，或在性能要求高的场合，或在嵌入式系统里，想要跨平台和安全性，就非得用第二种设计，也就是字节码+虚拟机的设计。
    </p>
    <p>
     讲到了这里，相信对 Java，对 PHP 或者对 Tcl 历史稍微了解的读者都会一拍脑袋顿悟了：原来这些牛逼的虚拟机都不是天才拍脑袋想出来的，而是被需求和现实给召唤出来的啊！
    </p>
    <p>
     我们先以 Java 为例，说说在嵌入式场合的应用。Java 语言原本叫 Oak 语言，最初不是为桌面和服务器应用开发的，而是为机顶盒开发的。SUN 最初开发 Java 的唯一目的，就是为了参加机顶盒项目的竞标。嵌入式系统的资源受限程度不必细说了，自然不会允许上面放一个解释器和一个运行时。所以，不管 Java 语言如何，Java 虚拟机设计得直白无比，简单无比，手机上，智能卡上都能放上一个 Java 运行时（当然是精简版本的）。 这就是字节码和虚拟机的威力了。
    </p>
    <p>
     SUN 无心插柳，等到互联网兴起的时候， Java 正好对绘图支持非常好，在 Flash 一统江湖之前，凭借跨平台性能，以 Applet 的名义一举走红。然后，又因为这种设计先天性的能克服性能问题，在性能上大作文章，凭借 JIT 技术，充分发挥上面说到的优点2，再加上安全性，一举拿下了企业服务器市场的半壁江山，这都是后话了。
    </p>
    <p>
     再说 PHP。PHP 的历史就包含了从第一种设计转化到第二种设计以用来优化运行时性能的历史。PHP 是一般用来生成服务器网页的脚本语言。一个大站点上的 PHP 脚本，一旦写好了，每天能访问千百万次，所以，如果全靠每次都解释，每次都递归执行，性能上是必然要打折扣的。所以，从1999年的 PHP4 开始， Zend 引擎就横空出世，专门管加速解释后的 PHP 脚本，而对应的 PHP 解释引擎，就开始将 PHP 解释成字节码，以支持这种一次解释，多次运行的框架。在此之前， PHP 和 Perl，还有 cgi，还算平分秋色的样子，基本上服务器上三类网页的数量都差不多，三者语法也很类似，但是到了 PHP4 出现之后，其他两个基于第一种设计方案的页面就慢慢消逝了，全部让位给 PHP。WordPress 博客，也是基于 PHP 技术的，底层也是 Zend 引擎的。著名的 LAMP 里面的那个 P， 原始上也是 PHP，而这个词真的火起来，也是99年 PHP4 出现之后的事情。
    </p>
    <p>
     第二种设计的优点正好满足了实际需求的事情，其实不胜枚举。比如说 在 Lua 和 Tcl 等宿主语言上也都表现的淋漓尽致。像这样的小型语言，本来就是让运行时为了嵌入其他语言的，所以运行时越小越好，自然的，就走了和嵌入式系统一样的设计道路。
    </p>
    <p>
     <strong>
      结语
     </strong>
    </p>
    <p>
     其实第二种设计也不是铁板一块，里面也有很多流派，各派有很多优缺点，也有很多细致的考量，下一节，如果不出意外，我将介绍我最喜欢的一个内容：下一代虚拟机：寄存器还是栈。
    </p>
    <p>
     说了这么多，最后就是一句话，有时候我们看上去觉得一种设计好像是天外飞仙，横空出世，其实其后都有现实、需求等等的诸多考量。虚拟机技术就是这样，在各种需求的引导下，逐渐的演化成了现在的样子。
    </p>
    <p>
     <a name="c3">
     </a>
     <strong>
      高级编程语言的发展历程（三）FORTRAN 语言是怎么来的
     </strong>
    </p>
    <p>
     2009-7-2
     <a href="http://blog.youxu.info/2009/07/02/fortran/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
    </p>
    <p>
     在“高级语言是怎么来的”子系列的第一篇中，我们结合当时硬件的特点，分析了 FORTRAN 为什么一开始不支持递归。但是 FORTRAN 本身是怎么来的这个问题其实还是没有得到正面回答，本节我们就谈谈 FORTRAN 语言本身是怎么来的。
    </p>
    <p>
     其实，FORTRAN 语言也是现实驱动的。所以我们还是回到当时，看看当时程序员的需求和软硬件条件，看看 FORTRAN 是怎么来的。了解历史的另一个好处是，因为 FORTRAN 的发展历史正好和高级语言的发展历史高度重合，所以了解 FORTRAN 的背景，对于理解其他高级语言的产生都是大有帮助的。
    </p>
    <p>
     <strong>
      困难的浮点计算
     </strong>
    </p>
    <p>
     我们先从硬件的角度说起。大致从 1946 年第一台计算机诞生，到 1953 年，计算机一直都缺少两件非常重要的功能，一个叫浮点计算，一个叫数组下标寻址，这两个功能的缺失直接导致了高级语言的兴起。我们依次单个分析。读者对浮点计算应该都不陌生，用通俗的话说就是如 0.98×12.6 这样的实数乘法，或者 0.98 + 12.6 这样的实数加法的运算。用行话说，就是用计算机进行大范围高精度数的算术运算。
    </p>
    <p>
     学过二进制的同学都知道，二进制整数之间的乘法和加法等运算都是相对简单的，和正常的十进制运算是一样的，只是把加法和乘法这些基本操作用更加简单的逻辑或(OR) 和逻辑与 (AND) 实现而已，在电子电路上也很好实现。因此，就是世界上最早的电子计算机，ENIAC，也是支持整数的乘法加法等算术操作的。
    </p>
    <p>
     可是浮点运算就不一样了。因为一个额外的小数点的引入，在任何时候都要注意小数点的对齐。如果用定点计数，则计数的范围受到限制，不能表示非常大或者非常小的数。所以，浮点数一般都是用科学记数法表示的，比如 IEEE 754 标准。（不熟悉 IEEE 754 的读者也可以想像一下如何设计一套高效的存储和操作浮点数的规范和标准，以及浮点算法），科学记数法表示的浮点数的加减法每次都要对齐小数点，乘除法为了保持精度，在设计算法上也有很多技巧，所以说，相比较于整数的运算和逻辑运算，浮点运算是一件复杂的事情。落实到硬件上就是说，在硬件上设计一个浮点运 算，需要复杂的电路和大量的电子元器件。在早期电子管计算机中，是很少能做到这么大的集成度的。因此，不支持浮点也是自然的设计取舍。在计算机上放一个浮点模块这个想法，需要等电子工业继续发展，使得电子管体积小一点，功耗低一点后，才能进入实践。
    </p>
    <p>
     <strong>
      关于浮点计算的一些八卦
     </strong>
    </p>
    <p>
     关于浮点，这里顺带八卦一点浮点计算的事情。在计算机芯片设计中，浮点计算一直是一个让硬件工程师头疼的事情，即使到了386时代，386 处理器(CPU)的浮点乘法也是用软件模拟的，如果想用硬件做浮点乘法，需要额外购买一块 80387 浮点协处理器 FPU，否则就在 386 上做软件的模拟。这样做的原因在一块硅片上刻蚀一个 CPU 和一个 FPU 需要的集成度还是太高，当时的工艺根本没法实现。真的把 FPU 和 CPU 融在一起刻蚀到一块硅片上，已经是 1989 年的事情了。当时，Intel 把融合了 80386 和 80387 的芯片改了改，起了个名字叫 80486，推向了市场。带着浮点的处理器的普及，使得个人计算机能做的事情变多了。极度依赖于浮点计算的多媒体计算机（视频和声音等多媒体的压缩，转换和回放都是要依赖于浮点运算的），也正好随着 80486 的流行，逐渐普及开来。
    </p>
    <p>
     在处理器上融合浮点运算依然是困难的。即使到今天，很多低端的处理器，都不带有浮点处理器。所以，号称能够上天入地的，被移植到很多低端设备（比如手机）上的 Linux 内核，必然是不能支持浮点运算的，因为这样会破坏内核的可移植性。我们都知道，在内核模式下，为了保证内核操作的原子性，一般在内核从事关键任务的时候所有中断是要被屏蔽的，用通俗的话说就是内核在做事情的时候，其他任何人不得打扰。如果内核支持浮点运算，不管是硬件实现也好，软件模拟也罢，如果允许在内核中进行像浮点计算这样复杂而耗时的操作，整个系统的性能和实时响应能力会急剧下 降。即使是在硬件上实现的浮点运算，也不是件容易的事情，会耗费 CPU 较多的时钟周期，比如 Pentium 上的浮点数除法，需要耗费 39 个时钟周期才行，在流水线设计的 CPU 中，这种占用多个时钟周期的浮点运算会让整个流水线暂停，让 CPU 的吞吐量下降。在现代 CPU 设计中，工程师们发明了超标量，乱序执行，SIMD 等多种方式来克服流水线被浮点运算这种长周期指令堵塞的问题，这都是后话了。
    </p>
    <p>
     正因为对于计算机来说，浮点运算是一个挑战性的操作，但又是做科学计算所需要的基本操作，所以浮点计算能力就成了计算机能力的一个测试标准。我们常常听说有一个世界上前 500 台最快的超级计算机列表，这里所谓的“快”的衡量标准，就是以每秒钟进行多少次浮点计算(FLOPS) 为准。按照 Top500.org, 即评选世界上前 500 台超级计算机的机构2009年6月的数据，世界上最快的计算机，部署在美国能源部位于新墨西哥的洛斯阿拉莫斯国家实验室 (Los Alamos National Laboratory)，当年造出第一颗原子弹的实验室。这台超级计算机，浮点计算速度的峰值高达 1456 TFlops，主要用来模拟核试验。因为美国的所有核弹头，海军核动力航母中的反应堆以及核试验，都由能源部国家核安全署(NNSA) 管理，所以能源部一直在投资用超级计算机进行核试验。在1996年美国宣布不再进行大规模的物理核试验后的这么多年，美国能源部一直用超级计算机来做核试验，所以在 Top500 列表中，美国能源部拥有最多数量的超级计算机。
    </p>
    <p>
     <strong>
      数组下标寻址之障
     </strong>
    </p>
    <p>
     言归正传，我们刚才说了在早期计算机发展史上，浮点计算的困难。除了浮点计算，还有一件事情特别困难，叫做数组下标寻址。用现代通俗的话 说，就是当年的计算机，不直接支持 A[3] 这样的数组索引操作，即使这个操作从逻辑上说很简单：把数组 A 的地址加上 3，就得到了 A[3] 的地址，然后去访问这个地址。
    </p>
    <p>
     这个困难在今天的程序员看来是不可思议的。为什么这么简单的数组下标寻址机制最一开始的计算机没有支持呢？ 原来，当年的计算机内存很小，只有一千到两K的存储空间，所以，描述地址只需要几位二/十进制数（BCD)。从而，在每条指令后面直接加一个物理地址是可行且高效的寻址方式。这种寻址方式，叫做直接寻址，当时所有的机器，都只支持直接寻址，因为在机器码中直接指出操作数的准确地址是最简单直接的方法，计算机不需要任何复杂的地址解码电路。但坏处是，这个设计太不灵活了，比如说 A[3] 这个例子，就没法用直接寻址来表示。
    </p>
    <p>
     一般情况下，如果知道数组A， 对于 A[3] 这样的例子，用直接寻址问题去模拟间接寻址的困难还不是很大，只要程序员事先记住数组 A 的地址然后手工加上 3 就行了 （A也是程序员分配的，因为当时没有操作系统，所以程序员手工管理内存的一切）。可是，也有一些情况这样直接寻址是不行的。比如说，当时计算机已经能支持跳转和判断指令了，也就是说，可以写循环语句了。我们可以很容易看到， 以 i 为循环变量的循环体内，对 A[i] 的访问是不能写成一个静态的直接寻址的，因为 i 一直在变化，所以不可能事先一劳永逸的定好 A[i] 的所在位置，然后静态写在程序中。
    </p>
    <p>
     这样，即使写一个简单的 10×10 矩阵的乘法，程序员就不得不死写10的三次方即1000 行地址访问，而没办法用几行循环代替。当时的一些聪明人，也想了一些方法去克服这个问题，比如说，他们先取出 A 的地址，然后做一次加法，把结果，也就是当时 A[i] 的地址，注射到一个读内存的 LOAD 指令后面。然后执行那条 LOAD 指令。比如我要读 A[i]，我先看，A的地址是 600，再看看 i 是3， 就加上 i，变成603，然后，把后面的指令改成 LOAD 603， 这样，就可以读到 A[i]。这个小技巧之所以可行，要感谢冯诺依曼爷爷的体系设计。在冯诺依曼计算机中，数据和程序是混在一起不加区分的，所以程序员可以随时像修改数据一样修改将要运行的下一条程序指令。就这样，靠着这个小技巧，好歹程序员再也不要用1000行代码表示一个矩阵乘法了。
    </p>
    <p>
     <strong>
      SpeedCoding 的出现
     </strong>
    </p>
    <p>
     计算机本来就是用来做数学计算的，可是科学计算里面最最基本的两个要素——浮点计算和数组下标访问，在当时的计算机上都缺少支持。这种需求和实际的巨大落差，必然会召唤出一个中间层来消弭这种落差。其实计算机科学的一般规律就是这样：当 A 和 C 相差巨大的时候，我们就引入一个中间层 B，用 B 来弥合 A 和 C 之间的不兼容。当年的这个中间层，就叫做 SpeedCoding，由 IBM 的工程师 John Backus 开发。
    </p>
    <p>
     SpeedCoding，顾名思义，就是让程序员编程更快。它其实是一个简单，运行在 IBM 701 计算机上的解释器。它允许程序员直接写浮点计算和下标寻址的指令，并且在底层把这些 “伪指令” 翻译成对应的机器码，用软件模拟浮点计算，自动修改地址等等。这样，程序员就可以从没完没了的手工实现浮点运算和下标寻址实现中解放出来，快速的编程。这 个 SpeedCoding，这可以算得上是 FORTRAN 的种子了。
    </p>
    <p>
     虽然这个解释器超级慢，程序员用这个解释器也用得很爽，也不感到它非常慢。这是因为当年计算机浮点计算都绕不过软件模拟，即使最好的程序员用机器码而不用这个解释器，写出来的程序，也不比这个解释器下运行快多少。另一个更加重要 的原因是，这个解释器极大的减少了程序员 debug 和 code 的时间。随着计算机速度的提高，当年一个程序耗费的计算成本和程序员编程耗费的人力成本基本上已经持平了。所以，相比较于写更加底层的机器码，用了 SpeedCoding 的程序员的程序虽然慢点，但人力成本瞬间降成 0，总体下来，用 SpeedCoding 比起不用来，总体成本还要低不少。
    </p>
    <p>
     好景不长，因为客户一直的要求和电子工业的发展，IBM 在 1954 年，终于发布了划时代的 704 计算机，很多经典的语言和程序，都首次在 704 上完成了。比如之前我们提到的 Steve Russell 的 LISP 解释器，就是在 704 上完成的。704 计算机一下子支持了浮点计算和间接下标寻址。这下用 SpeedCoding 的人没优势了，因为机器码支持浮点和下标寻址之后，写机器码比写 SpeedCoding 复杂不了多少，但是速度快了很多倍，因为 SpeedCoding 解释器太慢了，以前因为浮点和解释器一样慢，所以大家不在意它慢，现在浮点和寻址快了，就剩下解释器慢，写机器码的反而占了上风，程序员也就不用 SpeedCoding 了。
    </p>
    <p>
     <strong>
      FORTRAN 创世纪
     </strong>
    </p>
    <p>
     在 704 出来之前，做 SpeedCoding 的 John Backus 就认识到，要想让大家用他的 SpeedCoding, 或者说，想要从软件工具上入手，减少程序的开发成本，只有两个方法：
    </p>
    <ul>
     <li>
      程序员可以方便的写数学公式
     </li>
     <li>
      这个系统最后能够解析/生成足够的快的程序
     </li>
    </ul>
    <p>
     他认为，只有达到了这两点，程序员才会乐意使用高级的像 SpeedCoding 这样的工具，而不是随着硬件的发展在机器码和 SpeedCoding 这样的工具之间跳来跳去。他本人通过实现 SpeedCoding，也认识到如果有一个比机器码高级的语言，生产效率会高很多倍。那么，现在唯一的问题就是实现它，当然，这就不是一个小项目了，就需要 IBM 来支持他的开发了。 所以，在1953年，他把他的想法写成了一个文档，送给了 IBM 的经理。项目在 1954 年， 704 发布的当年，终于启动。John Backus 领导的设计一个能达到上面两点的编程系统的项目的成果，就是日后的 FORTRAN。
    </p>
    <p>
     和现在大多数编程语言不一样，FORTRAN 语言的设计的主要问题不是语法和功能，而是编译器怎么写才能高性能。John Backus 日后回忆说，当时谁也没把精力放在语言细节上，语言设计很潦草的就完成了（所以其后正式发布后又经过了N多修订），他们所有的功夫都是花在怎么写一个高性能的编译器上。这个高性能的编译器很难写，到 1957 年才写好，总共花了 IBM 216 个人月。等到 FORTRAN 一推出，不到一年的时间，在 IBM 总共售出的 60 台 704上，就部署了超过一半。现在没啥编程语言能够这么牛的攻城掠地了 ：）
    </p>
    <p>
     <strong>
      结语
     </strong>
    </p>
    <p>
     放到历史的上下文中看，FORTRAN 的出现是很自然的。一方面，复杂的数学运算使得一个能够表述数学计算的高级语言成为必须，计算机的发展也为这个需求提供了硬件条件；另一方面，随着计算机的发展，程序员的时间成本一直不变，但是计算的成本一直在降低，用高级语言和用机器码在性能上的些许差异变得可以忽略。这样的历史现实，必然会召唤出以少量的增加计算机工作量为代价，但能大幅度降低程序员时间成本的新的工具和设计。这种新的工具，新的设计，又对程序设计产生革命性的影响。在整个编程发展的 历史上，FORTRAN 和其他高级语言的出现可以说是第一波的革命；而后， UNIX和C语言的兴盛，使得系统编程的效率得到革命性提升，可以算是第二波革命；而面向对象方法，使得复杂的 GUI 等系统的编程效率得到提升，应该算得上是第三波革命。到如今，现在各种各样的方法论就更加多了，且看以后回看，哪种方法和工具能够大浪淘沙留下来。
    </p>
    <p>
     <a name="c4">
     </a>
     <strong>
      高级编程语言的发展历程（四）LISP 和 AI 的青梅竹马 A
     </strong>
    </p>
    <p>
     2009-8-31
     <a href="http://blog.youxu.info/2009/08/31/lisp-and-ai-1/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
    </p>
    <p>
     LISP 语言的历史和一些番外的八卦和有趣的逸事，其实值得花一本书讲。我打算用三篇文章扼要的介绍一下 LISP 的早期历史。讲 LISP，躲不过要讲 AI （人工智能）的，所以干脆我就先八卦八卦他们的青梅竹马好了。
    </p>
    <p>
     翻开任何一本介绍各种编程语言的书，都会毫无惊奇的发现，每每说到 LISP，通常的话就是“LISP 是适合人工智能（AI）的语言”。我不知道读者读到这句话的时候是怎么理解的，但是我刚上大学的时候，自以为懂了一点 LISP 和一点人工智能的时候，猛然看到这句话，打死我也不觉得“适合”。即使后来我看了 SICP 很多遍， 也难以想象为什么它就 “适合” 了， 难道 LISP 真的能做 C 不能做的事情么？难道仅仅是因为 John McCarthy 这样的神人既是 AI 之父， 又是 LISP 之父， 所以 AI 和 LISP 兄妹两个就一定是很般配？ 计算机科学家又不是上帝，创造个亚当夏娃让他们没事很般配干啥？ 既然“本是同根生”这样的说法是不能让人信服的，那么到底这句话的依据在哪里呢？ 我也是后来看 AI 文献，看当年的人工智能的研究情况，再结合当年人工智能研究的指导思想，当年的研究者可用的语言等历史背景，才完全理解“适合” 这两个自的。所以，这篇既是八卦，也是我的心得笔记。我们一起穿越到 LISP 和 AI 的童年时代。虽然他们现在看上去没什么紧密联系， 他们小时候真的是青梅竹马的亲密玩伴呢！
    </p>
    <p>
     让机器拥有智能，是人长久的梦想，因为这样机器就可以聪明的替代人类完成一些任务。二战中高速电子计算机的出现使得这个梦想更加近了一步。二战后，计算机也不被完全军用了，精英科学家也不要继续制造原子弹了，所以，一下子既有资源也有大脑来研究 “智能机器”这种神奇的东西了。我们可以随便举出当年研究繁盛的例子：维纳在 1948 年发表了《控制论》，副标题叫做 《动物和机器的控制和通信》，其中讲了生物和机器的反馈，讲了脑的行为。创立信息论的大师香农在 1949 年提出了可以下棋的机器，也就是面向特定领域的智能机器。同时，1949年，加拿大著名的神经科学家 Donald Hebb 发表了“行为的组织”，开创了神经网络的研究；图灵在 1950 年发表了著名的题为“计算的机器和智能”的文章，提出了著名的图灵测试。如此多的学科被创立，如此多的学科创始人在关心智能机器，可见当时的确是这方面研究的黄金时期。
    </p>
    <p>
     二战结束十年后，也就是 1956 年，研究智能机器的这些研究者，都隐隐觉得自己研究的东西是一个新玩意，虽然和数学、生物、电子都有关系，但和传统的数学、生物、电子或者脑科学都不一样，因此，另立一个新招牌成了一个必然的趋势。John McCarthy 同学就趁着 1956 年的这个暑假，在 Dortmouth 大学（当年也是美国计算机科学发展的圣地之一，比如说，它是 BASIC 语言发源地）， 和香农、Minsky 等其他人（这帮人当年还都是年轻人），一起开了个会，提出了一个很酷的词，叫做 Artificial Intelligence，算是人工智能这个学科正式成立。因为 AI 是研究智能的机器，学科一成立，就必然有两个重要的问题要回答，一是你怎么表示这个世界，二是计算机怎么能基于这个世界的知识得出智能。第一点用行话说就 是“知识表示”的模型，第二点用行话说就是“智能的计算模型”。别看这两个问题的不起眼，就因为当时的研究者对两个看上去很细微的问题的回答，直接造就了 LISP 和 AI 的一段情缘。
    </p>
    <p>
     我们各表一支。先说怎么表示知识的问题。AI 研究和普通的编程不一样的地方在于，AI 的输入数据通常非常多样化，而且没有固定格式。比如一道要求解的数学题，一段要翻译成中文的英文，一个待解的 sodoku 谜题，或者一个待识别的人脸图片。所有的这些，都需要先通过一个叫做“知识表示”的学科，表达成计算机能够处理的数据格式。自然，计算机科学家想用一种统 一的数据格式表示需要处理多种多样的现实对象，这样，就自然的要求设计一个强大的，灵活的数据格式。这个数据格式，就是链表。
    </p>
    <p>
     这里我就不自量力的凭我有限的学识，追寻一下为啥链表正好成为理想的数据结构的逻辑线。我想，读过 SICP 的读者应该对链表的灵活性深有感触。为了分析链表的长处，我们不妨把他和同时代的其他数据结构来做一比较。如我在前面所说，当时的数据结构很有限，所以我们不妨比较一下链表和同时代的另一个最广泛使用的数据结构——数组——的优劣。我们都知道，数组和链表都是线性数据结构，两者各有千秋，而 FORTRAN 基本上是围绕数组建立的，LISP 则是围绕链表实现的。通过研究下棋，几何题等 AI 问题的表示，我们的读者不难发现， AI 研究关心于符号和逻辑计算远大于数值计算，比如下棋，就很难抽象成一个基于纯数字的计算问题。这样，只能存数字的数组就显得不适合。当然我们可以把数组扩展一下，让这些数组元素也可以存符号。不过即使这样，数组也不能做到存储不同结构的数据。比方说棋类中，车马炮各有各自的规则，存储这些规则需要的结构和单元大小都不一样，所以我们需要一个存储异构数据单元的模块，而不是让每个单元格的结构一样。加上在AI 中，一些数据需要随时增加和修改的。比如国际象棋里，兵第一步能走两步，到底部又能变成皇后等等，这就需要兵的规则能够随时修改、增加、删除和改变。其他问题也有类似的要求，所有的这些，都需要放开数组维度大小一样的约束，允许动态增加和减少某一维度的大小，或者动态高效的增加删除数组元素。而一旦放开了单元格要同构和能随时增加和删除这样两个约束，数组其实就不再是数组了，因为随机访问的特性基本上就丢失了，数组就自然的变成了链表，要用链表的实现。
    </p>
    <p>
     所以，用链表而不是数组来作为人工智能的统一的数据结构，固然有天才的灵机一动，也有现实需求的影响。当然，值得一提的是，在 Common LISP 这样一个更加面向实践而不是科学研究的 LISP 版本中，数组又作为链表的补充，成了基本的数据结构，而 Common LISP，也就能做图像处理等和矩阵打交道的事情。这个事实更加说明，用什么样的数据结构作为基本单元，都是由现实需求推动的。
    </p>
    <p>
     当然，科学家光证明了列表能表示这些现实世界的问题还不够，还要能证明或者验证额外的两点才行。第一点是列表表示能够充分的表示所有的人工智能问题，即列表结构的充分性。只有证明了这一点，我们才敢放心大胆的用链表，而不会担心突然跳出一个问题链表表达不了；第二是人工智能的确能够通过对列表的某种处理方法获得，而不会担心突然跳出一个人工智能问题，用现有的对链表的处理方法根本没法实现。只有这两个问题的回答是肯定的时候，列表处理才会成为人工智能的一部分。
    </p>
    <p>
     对于这两个问题，其实都并没有一个确定的答案，而只是科学家的猜想，或者说是一种大家普遍接受的研究范式（paradigm）。 在 1976 年，当年构想 IPL(
     <a href="http://en.wikipedia.org/wiki/Information_Processing_Language" rel="nofollow noopener noreferrer" target="_blank">
      Information Processing Language
     </a>
     )，也就是 LISP 前身的两位神人 Alan Newell 和 Herbert Simon，终于以回忆历史的方式写了一篇文章。在这篇文章中，他们哲学般的把当时的这个范式概括为：一个物理符号系统对于一般智能行为是既充分又必要的（ A physical symbol system has the necessary and sufficient means for general intelligence action）。用大白话说就是，“智能必须依赖于某种符号演算系统，且基于符号演算系统也能够衍生出智能”。在实践中，如果你承认这个猜想，或者说这个范式，那你就承认了可以用符号演算来实现 AI。于是，这个猜想就让当时几乎所有的研究者，把宝押在了实现一个通用的符号演算系统上，因为假如我们制造出一个通用的基于符号演算的系统，我们就能用这个系统实现智能。
    </p>
    <p>
     上面我们说过，链表的强大的表达能力对于这个符号演算系统来讲是绰绰有余的了，所以我们只要关心如何实现符号演算，因为假如上面的猜想是对的，且链表已经能够表示所有的符号，那么我们的全部问题就变成了如何去构建这样的符号演算系统。后面我们可以看到，LISP 通过函数式编程来完成了这些演算规则的构建。
    </p>
    <p>
     这里，需要提请读者注意的是，LISP 的全称是 LISt Processing，即列表处理，但实际上 LISP 是由两种互相正交的哲学组合形成的，一个是列表处理，另一个是函数式编程。虽然在下面以后，我们会介绍 S-Expression 这样美妙的把两者无缝结合在一起的形式，但是为了清晰我们的概念，我要强调一下列表处理和函数式编程是两个正交的部分。实际上，我们完全可以用其他的不是函数的方式构建一个列表处理语言。在历史上，早在 FORTRAN 出现之前，Alan Newell 和 Herbert Simon 就用汇编实现了一个叫 IPL 的语言，而这个 IPL 语言就是面向过程的对列表处理的，而后，McCarthy 一开始也是用一系列的 FORTRAN 子程序来做列表处理的。比如 LISP 里面的 CAR 操作，其全称实际上是 Content of the Address portion of the Register， 顾名思义，寄存器的地址单元内容，也即列表的第一个元素（和C表达数组的方式类似，这里寄存器中存着指向列表第一个元素的指针）。 函数式的却不以列表为基本数据单元的语言也很多，比如 Scala ，就是以对象为基本数据单元。 因此，函数式和列表处理是不一定要互相耦合的。 那么，到底是什么原因使得 LISP 选择函数式，这样的选择又为啥更加适合当时 AI 的研究呢，我们下节将继续介绍当时 AI 的研究范式，强弱 AI 之间的辩论和函数式编程在当年 AI 研究上的优点。
    </p>
    <p>
     <strong>
      <a name="c5">
      </a>
      高级编程语言的发展历程（五）LISP 和 AI 的青梅竹马 B
     </strong>
    </p>
    <p>
     2010-2-10
     <a href="http://blog.youxu.info/2010/02/10/lisp-and-ai-2/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
    </p>
    <p>
     上回我们说到 LISP 和 AI 很是青梅竹马的时候，浮光掠影地说因为 LISP 的基本数据单元——”链表”在知识表示上的比较优势。我们说， AI 要处理的数据结构和要刻画的现实世界的模型很复杂，使得数组等其他简单数据结构不能胜任，所以“链表”成了最佳的选择。如果我们顺着这样的逻辑线往下看， 似乎选择 LISP 这个“列表处理的语言”似乎是理所当然的。可是，这个原因并不充分。因为 LISP 语言可不仅仅是列表处理，还包括函数式编程等等其他。反过来说，如果仅仅是列表处理对于 AI 至关重要的话，那么在 FORTRAN 和 ALGOL 这些通用编程语言又非常普及的传统语言里面写一些关于列表处理的函数岂不是更加直观和方便？ 归根结底，到底 LISP 还有什么其他奥妙呢？
    </p>
    <p>
     当我们追寻函数式编程这条线索的时候，就会不可避免的触及到 AI 的早期历史。LISP 的特性，其实都是和当时 AI 的范式 (paradigm) 息息相关的。
    </p>
    <p>
     <strong>
      AI 范式的演变
     </strong>
    </p>
    <p>
     早在 McCarthy 这一代人提出 AI 之前，冯诺伊曼等人就开始研究什么是智能以及如何实现智能的问题了。所不同的是，他们更加偏重于研究大脑的内部工作机理，并且试图通过在模拟大脑的工作机理，来实现智能。这一学派的哲学很清晰： 人类大脑是一个标准的智能体，我们只需要让计算机模拟人的大脑的工作方式，计算机就有了和人类大脑一样的智能了。对于这一派的研究者来说，他们相信大脑的结构和工作机理决定了智能，至于大脑是用脑细胞构成的，还是用电子电路模拟的，对于智能来说毫不重要。这方面的著名工作就是冯·诺伊曼的《计算机和大脑》这篇论文。在这篇不算很学术的随笔里面，他分析了人的大脑有多少个神经元，计算机有多少个晶体管，通过这些定量的比较来解释计算机和人的大脑的差距。当时和冯·诺伊曼齐名的另一个神童是开创控制论的维纳。他和冯·诺伊曼一样，兼通很多学科。和冯·诺伊曼一样，他职业是数学家，但是也精通如神经科学和脑科学等学科。 一个显然的例子就是在《控制论》这本书里面， 维纳对大脑和神经的分析比比皆是。这种对大脑和神经分析的传统，从 Cajal （对，就是写 Advice for a Young Investigator 的那个大神)）开始，一直延续到了后来 AI 中的联接主义（主要研究神经网络的一个人工智能学派）。
    </p>
    <p>
     可是，从脑科学和认知科学的角度去分析智能在当时有一个非常大的局限: 脑神经解剖学本身不成熟。比方说，现如今脑科学家在分析脑功能的时候一般会借助于 fMRI 和其他一些神经造影技术。这些技术可以做到实时观测到脑中血氧分布，直接确定大脑在执行特定任务时候的活跃部分。当年的科学家则只能使用有限的几种医学成 像技术，或者从血管摄影的角度研究大脑。受限于当时的研究条件，当年的研究者很难直接观测到脑神经的实时工作状态，分析大脑的实时工作机理。因此，对脑的研究就很难做到非常深刻。医学研究条件的限制，加上当时电子学的发展和集成度远远不够，用电子电路模拟大脑生成智能就显得非常遥远。因此，虽然这一派的思想超前，但是大部分的工作都不在于真正的用电子电路模拟大脑，而是在探索脑科学和神经科学本身，或者仅仅用电子电路模拟一些简单的神经动力学行为和小规模神经网络。正是因为连接主义在实现人工智能本身方面进展并不大，所以在AI领域中一直不是潮流的研究方向。上个世纪 80 年代前成功实施的一些人工智能系统，极少是来自于连接主义学派的。直到80年代后随着 BP 算法的重新发现，联接主义才迎来了第二春。这时候，LISP 已经过完 20 岁生日了。所以，联接主义 对 AI 领域使用的编程语言的选择的影响并不算大。
    </p>
    <p>
     <strong>
      符号主义
     </strong>
    </p>
    <p>
     虽然联接主义这一学派在当时不怎么流行，当年的 AI 研究可是进行的如火如荼。这如火如荼的学派，采用的是另外一套方法，我们称之为“符号主义学派”。符号主义学派的渊源，可以直接追溯到图灵。图灵在人工智能方面做过很多的研究，其中最为大家所知的就是“图灵测试“了。有句俗话叫做“在网上，没人知道你是一条狗”， 在这句话里，只要把“狗”换成“计算机”，就是简单版的图灵测试了。用个比较“潮”的比方，图灵测试就是让一台计算机或者一个真实的人（又叫评委）在网上交流，然后让这个评委猜测和他交谈的究竟是人还是计算机。如果这位评委也不能分辨谈话的对方到底是人还是计算机的话，我们就认为这个计算机已经足以“以假乱真”，拥有“和人类一样的智能”了，也就是通过“图灵测试了”。
    </p>
    <p>
     在很长一段时间里，图灵测试一直是人工智能研究的圣杯(holy grail)。也就是说，通过”图灵测试“ 成了人工智能研究的终极目标。那么，自然的，最最直接的通过图灵测试的方法不是让计算机和人脑一样思考，而是只要能够让计算机处理对话中用到的的单词、句子和符号，并且在对话中能够和人一样的操纵这些单词和符号，计算机就有很大的希望通过图灵测试。从最极端的情况来看，计算机甚至都不需要去“理解”这些句子的含义，都有可能通过图灵测试。[具体细节可以阅读 Wikipedia 上的“
     <a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%87%E6%88%BF%E9%97%B4" rel="nofollow noopener noreferrer" target="_blank">
      Chinese Room (中文房间)
     </a>
     ”条目]。有一个开源的聊天机器人，叫做 A.L.I.C.E.， 就把上面我们说的“只要能够处理和操纵符号，就有可能通过图灵测试”发挥到了近乎极致。这个聊天机器人在图灵测试比赛中已经多次骗过人类评委，到了非常 “智能”几乎能以假乱真的地步。可是，就是这样一个离通过图灵测试很近的机器人，其基本结构却简单到了我们都不能想像的地步：A.L.I.C.E. 的数据库里面有一条一条的规则，这些规则规定了她看到你说什么的时候她说什么。唯一有点“智能”的地方，就是有些规则不光取决于你这句话，还取决于你的上一句话。[比如日常对话中我们先问“你喜欢看电影么？”，接着再问“什么类型的？”，这时候就需要前一句话推出这个问题是“（喜欢）什么类型的（电 影)”]。“中文房间”的例子，和 A.L.I.C.E. 机器人如此简单的结构，都出人意料的显示出，即使计算机拥有了对符号的操作能力，通过了图灵测试，它也未必是“有智能”的。可惜这句话只是我的马后炮而已，在 AI 发展的早期，因为图灵测试的拉动，联接主义的相对弱势和符号主义的繁盛，都把全世界的 AI 研究往一个方向拽，这个方向，很自然的，就是“符号处理”。
    </p>
    <p>
     <strong>
      符号处理和 LISP 补充
     </strong>
    </p>
    <p>
     其实上一篇我们已经提到了，Alan Newell 和 Herbert Simon 认为对符号演算系统就可以衍生出智能，所以上面的文字，算是对符号主义这个 paradigm 做一个历史的小注解。当我们把 LISP 放到这段历史中，就会自然的想到， 什么语言适合人工智能的问题，就变成了“什么语言能做符号处理”。这个问题的答案，读者也都猜到了，就是 LISP。
    </p>
    <p>
     符号处理在 LISP 里面的长处前文我已经介绍过一些了，这里我们可以再补充几点零碎的。LISP 里有一个大家都知道的统一表示程序和数据的方法，叫做 S-Expression。这个 S，其实就是 Symbolic 的意思。把程序和数据都统一的当成符号，用现代编程语言的话说，就是 LISP 支持 meta-programming。LISP 程序可以处理，生成和修改 LISP 程序。这个特性，加上函数是一阶对象的特性，使得 LISP 远远比同时代的任何语言灵活。我本人不是 LISP 的用户（初级用户都算不上），因此在这一点上所知有限。但单就我有限的对 LISP 的理解，我认为 LISP 的这种灵活，恰好满足了基于符号处理的 AI 领域对语言的“强大的表达能力”（可以对任何复杂系统建模）和“高层的抽象能力” 的需求。关于第一点，有一个著名的段子，说任何一门编程语言技巧和思想被提出的时候，总会有一个高人出来，说，这个玩意儿在 LISP 里面早就有了，具体的例子包括刚才说的 metaprogramming， object oriented language。这里面蕴含的，就是 LISP 的强大的表达能力，使得很多编程的范式，在 LISP 里面都能实现，或者找到影子。关于第二点，SICP 中例子比比皆是，讲得都比我深刻许多，就无需废话了。
    </p>
    <p>
     在上篇文章中我提到，翻开任何一本编程的书，都会讲到“LISP是适合 AI 的编程语言”。那么，如果您和我当年一样，有兴趣从事 AI 方面的研究和探索，就不免要疑惑：“为了学习 AI， 我要不要学习 LISP” 呢？现在距离我当年的这个疑惑已经差不多8年了，我并没有一个确定的答案，但是我知道了更多的一些事实。
    </p>
    <p>
     <strong>
      如今的 AI 范式
     </strong>
    </p>
    <p>
     如果你让任何一个 AI 方向的研究者推荐几本适合初学者的书的话，十有八九他会提到 “Artificial Intelligence: A Modern Approach”(人工智能，一种现代方法) 和 “Artificial Intelligence: A New Synthesis” (人工智能，一个新的综述)。这两本书的作者分别是 Peter Norvig 和 Nils Nilsson，都是 AI 领域的元老级人物。如果你是一个对书名很敏感的人，你肯定会想：奇怪了，这种书又不是畅销书，难道这两位大牛写了书怕卖不出去，非要在书名上加一个 “现代” 或者 “新” 来吸引眼球？ 事实上，这个“现代”和这个“新”都大有来头。实际上，这二十年来，AI 研究领域接连发生了好几个非常大的 paradigm shift. 传统的基于符号的 AI 方法不再是主流，取而代之的，是多种多样的基于统计的，基于自动推理的，基于机器学习的，基于群体智慧的，基于大规模数据集的等等各种各样研究方法的兴起。这个 paradigm shift， 对于领域之外的人好像是静悄悄的，可实际上 AI 领域早已发生了翻天覆地的变化。所以才会有 “新” 和 “现代” 这样的词出现在书标题上。不幸的是，大多写编程语言书的作者，未必全部知晓这个变化，因此还沿袭原来的框架，继续写下 “LISP是适合 AI 的编程语言” 这样一个早就不能完全反映现状的断言。如果我们统计一个从事 AI 研究的研究者或者科学家用什么语言，答案可能是五花八门无所不有： 做 AI Search 的用 C/C++/Java， 做机器学习的如果模型和矩阵关系密切，可以用 Matlab， 如果统计计算较多，也可以用 R。至于做数据挖掘等等，语言和库更加五花八门，根本无法宣称那一个语言占上风。LISP 是适合 AI 的语言的教科书神话，也早就被无数的这样的实例给打破了。（延伸阅读：
     <a href="http://stackoverflow.com/questions/130475/why-is-lisp-used-for-ai" rel="nofollow noopener noreferrer" target="_blank">
      Why is Lisp used for AI?
     </a>
     ）
    </p>
    <p>
     <strong>
      <a name="c6">
      </a>
      高级编程语言的发展历程（六）SCHEME 语言是怎么来的
     </strong>
    </p>
    <p>
     2010-7-12
     <a href="http://blog.youxu.info/2010/07/12/scheme-1/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
    </p>
    <p>
     <strong>
      导言
     </strong>
    </p>
    <p>
     Scheme 是 LISP 的一个方言(dialect)。著名的 SICP 书就是以 Scheme 为教学语言（实际上 SICP 的作者就是 Scheme 的作者）。虽然 Scheme 本身只是一个精简化的适合教学的语言，可它首先提出的一些重要的思想，引领了新一代的 LISP 语言的出现。实际上， LISP 语言发展的历史是连续的，之所以我在这里人为的把 LISP 的发展史划分为上一代和现代，是因为随着 Scheme 首次引入并规范化了一些重要概念， LISP 语言出现了很多以前从来没有大规模普及的新特性。以 Common LISP 为代表的 LISP 语言也因为这些新特性，而焕发了第二春。人所共知的 Paul Graham 大叔，借着这一波 LISP 复兴的浪潮，不光写出了 On Lisp 这样的好书；而且还用 Common LISP 写出了一个在线电子商务平台，在 1998 年的时候以近 5 千万美元的价格卖给了 Yahoo! （凭借这笔买卖, Paul 大叔现在经营着 Y Combinator 天使投资，成为硅谷著名的天使）。前段时间卖给 Google 的 ITA，负担着世界上大部分的航班资讯查询，核心系统也是 Common LISP。虽然不该把 Common LISP 的很多成就全部归结到 Scheme, 但 Scheme 作为一个重要的历史分水岭，探究一下它的历史来源还是很有趣的。
    </p>
    <p>
     <strong>
      函数作为一级对象
     </strong>
    </p>
    <p>
     我们都知道 LISP 是一个函数式的编程语言。在 LISP 中，函数是一种基本类型。类比的看，C 家族的语言中，整数是一个基本的类型，所以，整数类型的变量既可以作为参数传递给一个函数，也可以作为返回值返回。比如，两个整数求和这个函数，用 C 家族的语法就是：
    </p>
    <div class="cnblogs_code">
     <pre><span style="color:#0000ff">int</span> add(<span style="color:#0000ff">int</span> a, <span style="color:#0000ff">int</span> b);</pre>
    </div>
    <p>
     因为在 LISP 里面，函数也成了基本类型。如果我们有一个 add 函数如下：
    </p>
    <div class="cnblogs_code">
     <pre>(define (<span style="color:#0000ff">add</span> x y) (+ x y))</pre>
    </div>
    <p>
     显然，它在 LISP 里就和 C 里的 int 一样，能够作为参数传递给其他函数。
    </p>
    <p>
     函数作为参数在 LISP 里非常普遍。我们知道著名的 APPLY MAP 和 REDUCE 这三个“高阶”函数（所谓高阶的意义就是参数可以是函数）。其中 APPLY 的最基本形式可以带两个参数，第一个参数是函数，第二个参数是一个列表。APPLY 的效果就是把这个列表作为参数表，送给第一个参数所代表的函数求值。如果我们在 LISP 里面用 APPLY(add, (1, 2)) 结果就是3，即把 (1,2) 送给add 作为参数，结果自然是 3。这是函数作为参数的例子，还有函数作为返回值的例子就不一一列举了。
    </p>
    <p>
     <strong>
      自由变量的幽灵
     </strong>
    </p>
    <p>
     在 add 这个函数的定义中我们可以看到，它的结果和两个输入值 x, y 有关。如果我们用 add(1,2) 调用 add 函数， 我们至少期望变量 x 会被赋值为 1， 变量 y 被赋值为 2。而结果 (+ x y) 则相应的为 3。在这个简单的例子中， 显然，如果 x 和 y 有一个值不知道的话， (+ x y) 的计算就无法完成。我们暂且把这些对函数求值不可缺少的变量称之为“必要变量”。显然，这些必要变量的值是需要确定的，否则函数无法进行求值。在我们 add 函数的例子里，x, y 这两个变量既是全部的必要变量，又是这个函数的参数，所以这个函数的结果就完全由输入的 x, y 的值确定。可以想象，任何一个像 add 这样的所有的必要变量都是来自于输入参数的函数，不论在什么地方被调用，只要输入的参数值一样，输出的结果必然一样。
    </p>
    <p>
     如果现实中所有的函数都有上面的性质的话，那就没有这篇文章了。可惜的是我们很快发现有好多函数不符合上面我们说的“输入的参数值一样，输出的结果必然一样”这个结论。我们甚至无须用 LISP 里面的例子来说明这一点。用 C 语言的都知道，取系统当前时间的函数 time，以及取随机数的函数 rand, 都是不需要输入值（0个输入参数）。因此任何时候这两个函数被调用的时候，我们都可以认为输入值一样（为 void 或 null)。但我们在不同的时间调用 time 或者多次调用 rand，很显然可以知道他们输出的结果不可能每次一样。
    </p>
    <p>
     函数式编程里面有更多的类似的例子。这些例子说明了的确有些函数，对于同样的输入值，能够得到不同的结果。这就很显然的表明，这些函数的必要变量中，有些不是函数的输入参数或者内部变量。我们把这些变量，叫做自由变量(free variable) [相反的那些被成为受限变量(bounded variable)]。这里的自由和受限，都是相对函数讲的，以变量的取值是不是由函数本身决定来划分的。
    </p>
    <p>
     虽然自由和受限变量是函数式语言里面的概念，但在命令式语言中也有影子。比方说，C 语言中，函数中用到的全局变量就是自由变量；在 Java 程序中，匿名内部类里面的方法可以用到所在外部类中的成员变量或者所在方法里标记为 final 的那些变量。这些可以被内部类的方法访问的，又不在内部类方法的参数表里面的变量都是自由变量。乐意翻看 GNU C Library 的好奇读者会看到，GNU libc 中的 rand 函数就用到了一个 random_data 的变量作为自由变量 (glibc/stdlib/random.c)。time 也是一样，通过一个系统调用来设置时间，而这在原理上等价于用到一个叫做”当前时间”的自由变量 (glibc/stdlib/time/time.c)。
    </p>
    <p>
     我们知道，在高级语言里面仅仅设计或者加入一个特性不难，难的是让所有的特性能协调一致的工作。比方说 Java 语言假设一切均为为对象，容器类型也假设装着对象，但是 int 类型却不是对象，让无数程序员为装箱拆箱大汗淋漓。回到 LISP， 当函数允许自由变量，函数有能够被作为参数传来传去的时候，自由变量的幽灵就随着函数作为参数传递而在程序各处游荡。这就带来了两个问题，一个涉及到自由变量的值的确定机制，另一个涉及到这个机制的实现。
    </p>
    <p>
     <strong>
      两种作用域
     </strong>
    </p>
    <p>
     为了说明自由变量的幽灵和作用域，我们还是从一个例子入手。假设我们要一个做加 n 的函数。为了体现出自由变量，我们把它写成
    </p>
    <div class="cnblogs_code">
     <pre>(define (addn s) ( lambda x (+ x s)))</pre>
    </div>
    <p>
     这个函数本身没什么特别的：输入一个 s, 输出一个 对任意 x 返回 x+s 的函数。注意到这个函数的“返回值”是一个函数。基于这个 addn 函数，我们可以定义 +1 函数 add1 函数如下
    </p>
    <div class="cnblogs_code">
     <pre>(define (add1 s) ((addn 1) s))</pre>
    </div>
    <p>
     这个也很好解释，如果输入一个 s， (addn 1) 返回了一个加一函数，这个函数作用在 s 上，即可得到 s+1。一切看上去很顺利，直到我们用一个 Scheme 出现前的 LISP 解析器去计算 (add1 4)。我们期望得到的值是 5， 而它给你的值可能是 8。怎么回事？
    </p>
    <p>
     为了解释这个 8 的来源，我们可以模拟一下一个基于栈的解释器的工作过程。(add1 4) 调用首先将参数 s 赋值为 4 然后，展开 add1 函数，即将 s=4 压栈，计算 (addn 1)。在调用 addn 时。s 又作为了 addn 的形式参数。因此，按照基于栈的解释器的标准做法，我们在一个新的活动窗口中将 s =1 压栈。addn 这个函数返回的是一个 “lambda x (+ x s)” 的函数，其中 s 是自由变量。然而一旦 addn 返回，栈中的 s=1 就会被弹出。当我们把这个返回了的 lambda 表达式作用到 4 上求值时候，x 是这个 lambda 表达式传入的形式参数，赋值为 4，栈里面的 s 的值 只有 s=4, 因此 (+ x s) 得到的是 8。
    </p>
    <p>
     这显然不是我们想要的。总结这个结果错了的原因，是因为我们的解释器没有限定 lambda x (+ x s) 里面的自由变量 s 为 1。而是在计算这个 lambda 表达式的时候才去查找这个自由变量的值。自由变量的幽灵在函数上开了一个后门，而我们没有在我们想要的地方堵上它，让它在函数真正求值的时候泄漏出来。
    </p>
    <p>
     我们不是第一个发现这个问题的人。实际上， LISP 刚出来没多久，就有人向 LISP 的发明人 John McCarthy 报告了这个 “BUG”。John 也认为这是一个小 BUG，就把球踢给了当时写 LISP 实现的 Steve Russell。此人我之前介绍过，乃是一个水平很高的程序猿(Code Monkey)。他认识到，这个问题的来源，在于返回的 lambda 表达式失去了不应该失去的确定它自由变量值的环境信息，在求值的时候，这些环境信息应该跟着这个 lambda 表达式一起。这样才能保证没有这个 BUG。不过 lambda 表达式在 LISP 语言中已经成型了，所以他就引入了一个新叫做 FUNCTION 的修饰符。作为参数的 lambda 表达式或函数要改写成 (FUNCTION lambda) 。这样，这个 lambda 表达式在被 eval 解析的时候就会被标记成 FUNARG，并且静态绑定到解析时所在环境。而用 APPLY 对函数求值时，有 FUNARG 标签的函数会在当时绑定的环境中求值，而不是在当前环境中求值。自由变量没有到处乱跑，而是被限制在了当时绑定的环境里面。Russell 的这个巧妙设计，成功关闭了自由变量在函数上开的口。这种加上了环境的函数就既能够被四处传递，而不需要担心自由变量的幽灵到处乱串。这个东西，后来就被 称为“闭包”。Russell 用 FUNCTION，以用一种“装饰”的方式，在 LISP 1.5 中第一次引入和实现了闭包。
    </p>
    <p>
     在编程语言的术语中，上面的让自由变量自由自在的在运行时赋值的机制，一般叫做动态作用域(dynamic scope)，而让函数和确定自由变量值在解析时静态绑定的机制，一般称之为静态作用域(static dynamic scope)。既然是静态绑定的环境是解析的时候确定的，而解析器是逐行解析程序的，所以，静态作用域的环境是完全由程序代码的结构确定的。因此有时候静态作用域又被等价的称为“文法作用域”(lexical scope)。上面我们的例子里。我们的真正意图是使用静态作用域，却遇到了一个使用动态作用域的 LISP 解析器，因此出现了 (add1 4) 等于 8 的错误。但这个问题并不足以说明静态作用域一定好。动态作用域的问题，关键在于违反了 Alpha 变换原则和封装原则，不过不在此详细展开了。
    </p>
    <p>
     <a name="c7">
     </a>
     <strong>
      高级编程语言的发展历程（七） LISP 语言前传
     </strong>
    </p>
    <p>
     2011-9-27
     <a href="http://blog.youxu.info/2011/09/27/lisp-prehistory/" rel="nofollow noopener noreferrer" target="_blank">
      原文链接
     </a>
     <strong>
      <br/>
     </strong>
    </p>
    <p>
     Lisp 的主要设计者 John McCarthy 曾经就 Lisp 的发展史，专门写过一篇
     <a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html" rel="nofollow">
      History of Lisp
     </a>
     的文章。这里介绍的历史，基本史实部分参照了 John McCarthy 的这篇文章，以及同时期 MIT 的关于 Lisp 的技术报告。
    </p>
    <p>
     Lisp 的历史要从 IBM 的神奇机器 704 说起。此时是 1954 年，尽管距离 1946 年第一台计算机 ENIAC 的出现已经八年了，商用计算机市场还仅仅起步。很早就进入计算机市场的 IBM 做出了一个影响深远的决定：发布一台可以进行浮点计算的，面向科学和工程的电子计算机。这台计算机，很朴素地跟着 IBM 之前发布的 701，702 后，被编号成 704（不知为什么 IBM 从来没公布过 703）。说 704 是神奇机器，是因为这台机器在计算机科学发展史上意义重大：世界上最早的语音合成程序就是由 Bell 实验室的科学家在 IBM 704 上完成的。 Fortran，Lisp 也是最早在 IBM 704 上实现的。
    </p>
    <p>
     和当年的所有计算机一样，IBM 704 是个百万美元级别的大玩具，不是一般人甚至一般大学能够买得起的。好在 IBM 和大学的关系一向很紧密，在 1957 年的时候，决定捐一台 704 给 MIT。当时在 Dartmouth 教书的 John McCarthy 和在 MIT 教书的 Marvin Minsky 关系很好，因此这台即将到达的 704，即将成为 McCarthy 的新玩具。
    </p>
    <p>
     当年部署一台计算机的周期很长，为了不让自己闲着，McCarthy 决定一边等机器部署，一边研究一下如果有了这台机器，可以做点什么。当时 Minsky 手里有一个 IBM 的项目，内容是使用计算机证明平面几何问题。既然计算机没来不能写程序，他们就只能从抽象的层面思考问题的解决方法。这个思考的结果，是开发一套支持符号计算的 FORTRAN 子系统。他们的基本想法是，用一系列的 FORTRAN 子程序，来做逻辑推理和符号演绎。
    </p>
    <p>
     回头看，这条路的确绕开了没有 704 就写不了程序的路障。因为我们只需要大致了解 Fortran 能够做什么，不能做什么，无需实际 Fortran 编程，就可以假想我们已经有了一系列未来可以实现的子程序，然后只要在数学上证明这些通过子程序的组合，加上自动逻辑推理，就可以证明平面几何定理。这就把一个计算机工程学问题，抽象成了一个数学问题（日后这个领域被正式划归到人工智能的学科中，但在当时这还是属于数学问题）
    </p>
    <p>
     这样，计算机没来之前，McCarthy 的最终结果，是一个用 Fortran 子程序做列表处理的简单系统。McCarthy 的这条路很现实的做法——如果不用 Fortran 而是自己写一个新的语言的编译器话，可能需要好几年的时间。而 McCarthy 当年还不是终身教授，投入到写作新语言这样旷日持久且不能保证成果的项目中去，不会对他的职业生涯有太大的正面作用。
    </p>
    <p>
     704 送到 MIT 后， McCarthy 带着两个研究生，将之前计划的 Fortran 列表处理子程序实现了，并命名为 Fortran 列表处理语言 (FLPL) 。然而，因为 Fortran 语言本身的限制，McCarthy 对 FLPL 并不满意。他在写作自动求函数导数的程序时[读过 SICP 的读者会发现这是一道习题]，发现 FLPL 的弱点集中体现在两个地方。
    </p>
    <p>
     第一个问题是递归。我们在 Fortran 语言怎么来的这一节已经提到，704 上的 Fortran 语言是不支持递归的。而 McCarthy 心中所设想的语言，很重要的一条就是递归：没有递归，很多列表处理的函数只能用循环来实现，而循环本身并不是 McCarthy 设想的语言的一部分。熟悉函数求导的链式法则的读者可以想像，没有递归的求导程序是何其难写，因为函数求导过程本身就是递归定义的。
    </p>
    <p>
     第二个问题是 Fortran 的 IF 语句。IF 家族的分支语句，在计算机程序设计中可以说必不可少。在 McCarthy 那里 IF 就更重要了，因为几乎所有有递归函数的地方就有 IF（因为递归函数需要 IF 判断结束条件）。相信读者都很熟悉这种 IF 结构
    </p>
    <div class="cnblogs_code">
     <pre><span style="color:#0000ff">IF</span> 条件 <span style="color:#0000ff">THEN</span>
    一些语句;
<span style="color:#0000ff">ELSE</span>
    另一些语句;
<span style="color:#0000ff">END</span> <span style="color:#0000ff">IF</span></pre>
    </div>
    <p>
     这是从 ALGOL 语言一脉相承下来的，很“自然”的 IF 写法。而早期的 FORTRAN 的 IF 写法却不这么直观，而是
    </p>
    <div class="cnblogs_code">
     <pre><span style="color:#0000ff">IF</span> (表达式) A B C</pre>
    </div>
    <p>
     取决于表达式的值是小于零，等于零还是大于零，分别跳到（等价于 goto）标签 A， 标签B 或者标签 C。这个 IF 隐含了三个 Goto，可以说和结构化编程的实践截然相反，降低了程序的可读性。 Fortran 首创的这个三分支跳转的 IF 饱受诟病，Fortran 77 开始支持结构化的 IF，而 Fortran 90 标准进一步宣布三分支跳转的用法已经“过时”，不支持使用。
    </p>
    <p>
     在 McCarthy 那里，Fortran 的三分支跳转 IF 也不方便。为此，在 FLPL 中，他试图用一个叫 XIF 子程序完成类似于 IF 的分支功能，用法是：
    </p>
    <div class="cnblogs_code">
     <pre>XIF(条件, 表达式A, 表达式B)</pre>
    </div>
    <p>
     取决于条件的满足与否，XIF 返回表达式 A 或者表达式 B 的值。很快，他发现，用子程序的方法实现 XIF，在语义上并不正确。我们知道，在 Fortran 和其他高级语言中，函数参数的值在进入函数之前必须全部确定。在 XIF 这里，不难看出，不管条件满足与否，我们都先要计算表达式 A 和表达式 B 的值。而 IF 是个分支逻辑，从语义上来说，应该只计算满足条件的分支的值。因此，用函数来实现 IF 是不正确的 [读过 SICP 的读者会发现这又是一道习题]。
    </p>
    <p>
     作为一个旁注，尽管 John McCarthy 早在50多年前就发现了函数实现 IF 是语义错误的，现代的程序员还常常犯这个错误。一个值得一提的例子是 C++ 逻辑运算符重载和短路表达式的不等价性。我们都知道，在 C 语言中，逻辑与 (&amp;&amp;) 和逻辑或( || ) 都隶属于短路表达式，也就是说，对于 A &amp;&amp; B 这样的表达式，如果 A 已经确定为 false，就无需计算表达式 B 的值，即 B 的计算被”短路”。以 C 为蓝本的 C++ 一方便保留了这些短路表达式，另一方面在面向对象的特性中，引入了运算符重载。具体来说，只要一个对象定义了 operator&amp;&amp; 成员函数，就可以进行 &amp;&amp; 运算。乍一看，这是一个很酷的特性，可以让程序员用 A&amp;&amp;B 这样的数学表达式表达复杂的逻辑关系。然而，仔细想想，  A.operator&amp;&amp;(B) 在语义上并不等价于 C 所定义的 A&amp;&amp;B，原因在于 A.operator&amp;&amp;() 是个函数，在求值之前需要先计算 B 的值，而后者是个短路表达式，本质上相当于
    </p>
    <div class="cnblogs_code">
     <pre><span style="color:#0000ff">IF</span> A:
    <span style="color:#0000ff">return</span> <span style="color:#0000ff">True</span>
<span style="color:#0000ff">ELSE</span>:
    <span style="color:#0000ff">return</span> B</pre>
    </div>
    <p>
     因为短路表达式不一定会对 B 求值，这两者从语义上就是不等价的。如果 B 不是一个简单的对象，而是一个复杂表达式的时候，对 B 求值可能有副作用，而这个副作用，是写 A &amp;&amp; B 并把它当做短路表达式的程序员所没有预见的。按照 C++ Gotcha 的说法，这很容易造成潜在的程序 Bug。实际上，C++逻辑运算符重载是一个危险的特性，很多公司的编程标准都禁止使用逻辑运算符重载。
    </p>
    <p>
     递归和 IF 两个问题，使得 Fortran 从本质上就不符合 McCarthy 期望，以 Fortran 为宿主的开发列表处理语言也不可能达到 McCarthy 想要的结果。因此，唯一的解，就是抛开 Fortran，从头开始，设计一个新的语言。值得注意的是，此时 McCarthy 正好跳槽到了 MIT 做助理教授，MIT 有足够多的编程强人，可以帮 McCarthy 完成这个编写新语言的任务。这个强人，就是 Steve Russell；这个语言，就是 Lisp。
    </p>
   </div>
  </div>
 </article>
</div>


