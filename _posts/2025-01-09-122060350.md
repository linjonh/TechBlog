---
layout: post
title: "微信小程序-实现最简单的组件拖拽"
date: 2025-01-09 17:33:29 +0800
description: "背景最近在自主学习微信小程序的开发；对于零基础入门(没有学习过前端)的我，查阅了许多微信小程序拖拽的"
keywords: "bindtouchmove"
categories: ['']
tags: ['微信小程序', '小程序', '前端']
artid: "122060350"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122060350
    alt: "微信小程序-实现最简单的组件拖拽"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微信小程序 实现最简单的组件拖拽
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     背景
    </h3>
    <p>
     最近在自主学习微信小程序的开发；对于零基础入门(没有学习过前端)的我，查阅了许多微信小程序拖拽的实现，大部分要么实现起来太复杂了，要么封装组件太复杂了，附带了拖拽之后排序等功能；因此写下这篇个人觉得最好理解的 微信小程序元素拖拽的实现；
    </p>
    <h3>
     <a id="_3">
     </a>
     原理
    </h3>
    <p>
     这边采用了 微信小程序中的
     <code>
      bindtouchstart
     </code>
     、
     <code>
      bindtouchmove
     </code>
     、
     <code>
      bindtouchend
     </code>
     三兄弟 实现 开始触摸、触摸后移动、触摸结束；并加上一些坐标的转换，实现简单的 拖动功能；
    </p>
    <h4>
     <a id="_touchStart_8">
     </a>
     第一步 touchStart
    </h4>
    <p>
     拖拽的开始 (一切尽在图中)
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/a05842c615fd952cc159c0eeb652a1e1.png"/>
    </p>
    <p>
     控件的位置为 left:posX; top:posY;
    </p>
    <p>
     通过bindtouchstart 得到首次的触摸点坐标：touch.pageY;touch.pageX;
    </p>
    <p>
     此时 可以得到 触摸点和 控制的位置坐标差为
    </p>
    <p>
     chaX = touch.pageX - posX;
    </p>
    <p>
     chaY = touch.pageY - posY;
    </p>
    <p>
     将这两个值 暂存；用于拖动的后 位置的转换；
    </p>
    <h4>
     <a id="_toucMove_25">
     </a>
     第二步 toucMove
    </h4>
    <p>
     通过bindtouchmove 可以得到 触摸移动的实时坐标：touch.pageY;touch.pageX;
    </p>
    <p>
     然后通过刚刚得到chaX 和 chaY 可以转换得到 实时移动的控件位置：
    </p>
    <p>
     new_posX = touch.pageX - chaX;
     <br/>
     new_posY = touch.pageY - chaY;
    </p>
    <p>
     将这两个值都更新至 控件的位置信息上；此时 可以实时渲染出 控件的移动；
    </p>
    <h4>
     <a id="_touchEnd_36">
     </a>
     第三步 touchEnd
    </h4>
    <p>
     通过bindtouchend 用于处理 拖拽动作的结束，清空临时数据等；
    </p>
    <h3>
     <a id="_41">
     </a>
     代码
    </h3>
    <h4>
     <a id="WXML__43">
     </a>
     WXML 代码
    </h4>
    <ul>
     <li>
      position: absolute; 绝对位置 用于left 和 top的使用
     </li>
     <li>
      left:{
      <!-- -->
      {posX}}px; 显示的位置X
     </li>
     <li>
      top:{
      <!-- -->
      {posY}}px; 显示的位置Y
     </li>
     <li>
      bindtouchstart=“touchStart” 设置绑定的函数
     </li>
     <li>
      bindtouchmove=“touchMove” 设置绑定的函数
     </li>
     <li>
      bindtouchend=“touchEnd” 设置绑定的函数
     </li>
     <li>
      其余元素只是为了控件展示
     </li>
    </ul>
    <pre><code>&lt;view class="stick" style="position: absolute; text-align: center; width: 200rpx; height:50rpx;background: rgb(100, 180, 100);display: block;left:{<!-- -->{posX}}px;top:{<!-- -->{posY}}px" bindtouchmove="touchMove" bindtouchstart="touchStart" bindtouchend="touchEnd" &gt;
        &lt;view&gt;AAAA&lt;/view&gt;
    &lt;/view&gt;
</code></pre>
    <h4>
     <a id="js_57">
     </a>
     js代码
    </h4>
    <pre><code>Page({
    data: {
        chaX: 0,// 转换值X
        chaY: 0,// 转换值Y
        touch: false, // 触摸标记
        posX:100, // 初始位置
        posY:20, // 初始位置
    },

    // 开始触摸
    touchStart: function (e) {
        console.log("== touchStart ==");// 拖动开始
        // e.touches[0] 内容就是触摸点的坐标值
        var tranX = e.touches[0].pageX-this.data.posX;
        var tranY = e.touches[0].pageY-this.data.posY;
        console.log("start tranX: " + tranX);
        console.log("start tranY: " + tranY);
        // 存储chaX和chaY 并设置 touch: true
        this.setData({
            touch: true, 
            chaX:tranX,
            chaY:tranY
        });
    },
    // 触摸移动
    touchMove: function (e) {
        if (!this.data.touch) return;
        // e.touches[0] 内容就是触摸点的坐标值
        var new_posX = e.touches[0].pageX-this.data.chaX;
        var new_posY = e.touches[0].pageY-this.data.chaY;
        console.log(" move new_posX: " + new_posX);
        console.log(" move nwe_posY: " + new_posY);
        this.setData({
            posX: new_posX,
            posY: new_posY
        });
    },
    // 触摸结束
    touchEnd: function (e) {
        console.log("== touchEnd ==")
        if (!this.data.touch) return;
        this.setData({
            touch: flase,
            chaX:0,
            chaY:0
        });
    }
})
</code></pre>
    <h3>
     <a id="_110">
     </a>
     参考资料
    </h3>
    <p>
     <a href="https://www.cnblogs.com/q1076452761/p/15662272.html" rel="nofollow">
      微信小程序 入门学习 资料收集
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71313037363435323736312f:61727469636c652f64657461696c732f313232303630333530" class_="artid" style="display:none">
 </p>
</div>


