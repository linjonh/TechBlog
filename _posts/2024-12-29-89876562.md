---
layout: post
title: "前端微服务化解决方案2-Single-SPA"
date: 2024-12-29 14:32:43 +0800
description: "微前端MicroFrontend前端架构技术选型经过各种技术调研我们最终选择的方案是基于Single"
keywords: "singlespa.start() was not called"
categories: ["未分类"]
tags: ["无标签"]
artid: "89876562"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=89876562
  alt: "前端微服务化解决方案2-Single-SPA"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端微服务化解决方案2 - Single-SPA
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
    </h2>
    <p>
     <a href="https://alili.tech/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF" rel="nofollow">
      微前端
     </a>
     <a href="https://alili.tech/tags/microfrontend" rel="nofollow">
      MicroFrontend
     </a>
     <a href="https://alili.tech/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84" rel="nofollow">
      前端架构
     </a>
    </p>
    <h2 id="技术选型">
     技术选型
    </h2>
    <p>
     经过各种技术调研我们最终选择的方案是基于
     <a href="https://single-spa.js.org/" rel="nofollow">
      Single-SPA
     </a>
     来实现我们的前端微服务化.
    </p>
    <h2 id="single-spa">
     Single-SPA
    </h2>
    <blockquote>
     <p>
      一个用于前端微服务化的JavaScript前端解决方案
     </p>
    </blockquote>
    <p>
     使用Single-SPA之后,你可以这样做:
    </p>
    <ul>
     <li>
      (兼容各种技术栈)在同一个页面中使用多种技术框架(React, Vue, AngularJS, Angular, Ember等任意技术框架),并且不需要刷新页面.
     </li>
     <li>
      (无需重构现有代码)使用新的技术框架编写代码,现有项目中的代码无需重构.
     </li>
     <li>
      (更优的性能)每个独立模块的代码可做到按需加载,不浪费额外资源.
     </li>
     <li>
      每个独立模块可独立运行.
     </li>
    </ul>
    <p>
     下面是一个微前端的演示页面 (你可能需要科学的上网)
     <a href="https://single-spa.surge.sh/" rel="nofollow">
      https://single-spa.surge.sh/
     </a>
     &gt; 以上是官方例子,但是官方例子中并没有解决一个问题.就是各种技术栈的路由实现方式大相径庭,如何做到路由之间的协同? 后续文章会讲解,如何解决这样的问题.
    </p>
    <h3 id="单体应用对比前端微服务化">
     单体应用对比前端微服务化
    </h3>
    <h4 id="普通的前端单体应用">
     普通的前端单体应用
    </h4>
    <p>
     <img alt="" class="has" src="https://static.alili.tech/images/micro/current.png"/>
    </p>
    <h4 id="微前端架构">
     微前端架构
    </h4>
    <p>
     <img alt="" class="has" src="https://i-blog.csdnimg.cn/blog_migrate/72fb556075ac7f74fccab17499ba2f66.png"/>
    </p>
    <h2 id="single-spa的简单用法">
     Single-SPA的简单用法
    </h2>
    <h3 id="1-创建一个html文件">
     1.创建一个HTML文件
    </h3>
    <pre class="has"><code>&lt;html&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="single-spa-config.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <h3 id="2-创建single-spa-config-js-文件">
     2.创建single-spa-config.js 文件
    </h3>
    <pre class="has"><code>// single-spa-config.js
import * as singleSpa from 'single-spa';

// 加载 react 项目的入口 js 文件 (模块加载)
const loadingFunction = () =&gt; import('./react/app.js');

// 当 url 前缀为 /react 的时候.返回 true (底层路由)
const activityFunction = location =&gt; location.pathname.startsWith('/react');

// 注册应用
singleSpa.registerApplication('react', loadingFunction, activityFunction);

//singleSpa 启动
singleSpa.start();
</code></pre>
<h3 id="封装react项目的渲染出口文件">
封装 React 项目的渲染出口文件
</h3>
<p>
我们把渲染 react 的入口文件修改成这样,便可接入到 single-spa
</p>
<pre class="has"><code>import React from 'react'
import ReactDOM from 'react-dom'
import singleSpaReact from 'single-spa-react'
import RootComponent from './root.component'

if (process.env.NODE_ENV === 'development') {
// 开发环境直接渲染
ReactDOM.render(&lt;RootComponent /&gt;, document.getElementById('root'))
}

//创建生命周期实例
const reactLifecycles = singleSpaReact({
React,
ReactDOM,
rootComponent: RootComponent
domElementGetter: () =&gt; document.getElementById('root')
})

// 项目启动的钩子
export const bootstrap = [
reactLifecycles.bootstrap,
]
// 项目启动后的钩子
export const mount = [
reactLifecycles.mount,
]
// 项目卸载的钩子
export const unmount = [
reactLifecycles.unmount,
]

</code></pre>
<blockquote>
<p>
这就是 single-spa 的简单使用, 当我们的浏览器 url 的前缀有
<code>
/react
</code>
的时候,程序就可以正常渲染这个应用 所以,所以我们这个 react 应用的所有路由前缀都得有
<code>
/react
</code>
未完待续 …
</p>
</blockquote>
<h2 id="相关文章">
相关文章
</h2>
<p>
<a href="http://alili.tech/archive/ea599f7c/" rel="nofollow">
前端微服务化解决方案 1 - 思考
</a>
</p>
<p>
<a href="http://alili.tech/archive/11052bf4/" rel="nofollow">
前端微服务化解决方案 2 - Single-SPA
</a>
</p>
<p>
<a href="http://alili.tech/archive/1a60cede/" rel="nofollow">
前端微服务化解决方案 3 - 模块加载器
</a>
</p>
<p>
<a href="http://alili.tech/archive/a9a1f81b/" rel="nofollow">
前端微服务化解决方案 4 - 消息总线
</a>
</p>
<p>
<a href="http://alili.tech/archive/5ff0b366/" rel="nofollow">
前端微服务化解决方案 5 - 路由分发
</a>
</p>
<p>
<a href="http://alili.tech/archive/ffb0c5ab/" rel="nofollow">
前端微服务化解决方案 6 - 构建与部署
</a>
</p>
<p>
<a href="http://alili.tech/archive/5e00e43d/" rel="nofollow">
前端微服务化解决方案 7 - 静态数据共享
</a>
</p>
<p>
<a href="http://alili.tech/archive/ce685b9f/" rel="nofollow">
前端微服务化解决方案 8 - 二次构建
</a>
</p>
<h2 id="demo">
Demo
</h2>
<p>
<a href="http://microfrontend.alili.tech/" rel="nofollow">
前端微服务化 Micro Frontend Demo
</a>
</p>
<p>
<a href="https://github.com/Fantasy9527/lotus-scaffold-micro-frontend-portal">
微前端模块加载器
</a>
</p>
<p>
<a href="https://github.com/Fantasy9527/microfrontend-base-demo">
微前端 Base App 示例源码
</a>
</p>
<p>
<a href="https://github.com/Fantasy9527/microfrontend-submodule-demo">
微前端子项目示例源码
</a>
</p>
<h3>
本文链接：
</h3>
<p>
<a href="https://alili.tech/archive/11052bf4/" rel="nofollow">
https://alili.tech/archive/11052bf4/
</a>
</p>
<p>
</p>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f71715f3236353632363431:2f61727469636c652f64657461696c732f3839383736353632" class_="artid" style="display:none">
 </p>
</div>
