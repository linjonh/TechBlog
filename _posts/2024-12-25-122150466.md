---
layout: post
title: 数据库期末复习
date: 2024-12-25 11:53:58 +0800
description: 文章浏览阅读2.3k次，点赞15次，收藏40次。数据库期末复习数据库的基本概念数据（Data）数据库
keywords: 数据库中t1
categories: ['笔记', '数据库']
tags: ['数据库', 'Database']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122150466
    alt: 数据库期末复习
artid: 122150466
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据库期末复习
    </h1>
   </div>
   <div class="ai-article-tag" id="ai-article-tag">
    <div class="ai-article-tag-box">
     <p class="ai-article-tag-item-active">
      <img alt="" class="item-target" src="https://img-home.csdnimg.cn/images/20240715101418.png"/>
     </p>
     <a class="ai-article-tag-item" data-report-click='{"spm":"3001.10231","extra":{"searchword":"数据库管理系统"}}' data-report-query="spm=1001.2101.3001.10231" data-report-view='{"spm":"3001.10231","extra":{"searchword":"数据库管理系统"}}' href="https://so.csdn.net/so/search/s.do?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">
      <span>
       数据库管理系统
      </span>
     </a>
     <a class="ai-article-tag-item" data-report-click='{"spm":"3001.10231","extra":{"searchword":"数据独立性"}}' data-report-query="spm=1001.2101.3001.10231" data-report-view='{"spm":"3001.10231","extra":{"searchword":"数据独立性"}}' href="https://so.csdn.net/so/search/s.do?q=%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">
      <span>
       数据独立性
      </span>
     </a>
     <a class="ai-article-tag-item" data-report-click='{"spm":"3001.10231","extra":{"searchword":"关系模型"}}' data-report-query="spm=1001.2101.3001.10231" data-report-view='{"spm":"3001.10231","extra":{"searchword":"关系模型"}}' href="https://so.csdn.net/so/search/s.do?q=%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">
      <span>
       关系模型
      </span>
     </a>
     <a class="ai-article-tag-item" data-report-click='{"spm":"3001.10231","extra":{"searchword":"范式"}}' data-report-query="spm=1001.2101.3001.10231" data-report-view='{"spm":"3001.10231","extra":{"searchword":"范式"}}' href="https://so.csdn.net/so/search/s.do?q=%E8%8C%83%E5%BC%8F&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">
      <span>
       范式
      </span>
     </a>
     <a class="ai-article-tag-item" data-report-click='{"spm":"3001.10231","extra":{"searchword":"数据库设计"}}' data-report-query="spm=1001.2101.3001.10231" data-report-view='{"spm":"3001.10231","extra":{"searchword":"数据库设计"}}' href="https://so.csdn.net/so/search/s.do?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">
      <span>
       数据库设计
      </span>
     </a>
    </div>
    <span class="ai-article-tag-text">
     关键词由CSDN通过智能技术生成
    </span>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night-eighties" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      数据库期末复习
     </h4>
     <ul>
      <li>
       <a href="#_1" rel="nofollow">
        数据库的基本概念
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#Data_2" rel="nofollow">
          数据（Data）
         </a>
        </li>
        <li>
         <a href="#DB_8" rel="nofollow">
          数据库（DB）
         </a>
        </li>
        <li>
         <a href="#DBS_11" rel="nofollow">
          数据库系统（DBS）
         </a>
        </li>
        <li>
         <a href="#DBMS_13" rel="nofollow">
          数据库管理系统(DBMS)
         </a>
        </li>
        <li>
         <a href="#_15" rel="nofollow">
          数据库管理员
         </a>
        </li>
        <li>
         <a href="#_18" rel="nofollow">
          数据库系统的三级模式结构：
         </a>
        </li>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <a href="#_22" rel="nofollow">
              模式：
             </a>
            </li>
            <li>
             <a href="#_34" rel="nofollow">
              外模式：
             </a>
            </li>
            <li>
             <a href="#_42" rel="nofollow">
              内模式：
             </a>
            </li>
            <li>
             <a href="#_46" rel="nofollow">
              总结：
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_49" rel="nofollow">
          数据库的二级映像功能与数据独立性：
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_53" rel="nofollow">
            二级映像：
           </a>
          </li>
          <li>
           <a href="#_60" rel="nofollow">
            外模式/模式映像：
           </a>
          </li>
          <li>
           <a href="#_70" rel="nofollow">
            模式/内模式映像：
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_77" rel="nofollow">
          数据独立性
         </a>
        </li>
        <li>
         <a href="#_82" rel="nofollow">
          数据模型
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_83" rel="nofollow">
            数据模型的三要素
           </a>
          </li>
          <li>
           <a href="#_87" rel="nofollow">
            常见的三种数据模型：
           </a>
          </li>
          <li>
           <a href="#_91" rel="nofollow">
            关系模型的特点
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_96" rel="nofollow">
        关系数据库理论
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_97" rel="nofollow">
          关系的基本概念
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_98" rel="nofollow">
            域
           </a>
          </li>
          <li>
           <a href="#_100" rel="nofollow">
            关系
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_108" rel="nofollow">
              关系表示：
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#_111" rel="nofollow">
            元组
           </a>
          </li>
          <li>
           <a href="#_113" rel="nofollow">
            属性
           </a>
          </li>
          <li>
           <a href="#_115" rel="nofollow">
            目/度
           </a>
          </li>
          <li>
           <a href="#_129" rel="nofollow">
            候选码
           </a>
          </li>
          <li>
           <a href="#_131" rel="nofollow">
            主属性
           </a>
          </li>
          <li>
           <a href="#_133" rel="nofollow">
            非主属性
           </a>
          </li>
          <li>
           <a href="#_135" rel="nofollow">
            外码
           </a>
          </li>
          <li>
           <a href="#_137" rel="nofollow">
            全码
           </a>
          </li>
          <li>
           <a href="#_139" rel="nofollow">
            范式
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_142" rel="nofollow">
          总结（建议看这个因为是人话）：
         </a>
        </li>
        <li>
         <a href="#_153" rel="nofollow">
          关系的三种类型：
         </a>
        </li>
        <li>
         <a href="#6_159" rel="nofollow">
          基本关系的6条性质：
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_167" rel="nofollow">
        关系代数
       </a>
      </li>
      <li>
       <a href="#_170" rel="nofollow">
        关系的完整性
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1__172" rel="nofollow">
          1. 实体完整性
         </a>
        </li>
        <li>
         <a href="#2__175" rel="nofollow">
          2. 参照完整性
         </a>
        </li>
        <li>
         <a href="#3__178" rel="nofollow">
          3. 用户定义完整性
         </a>
        </li>
        <li>
         <a href="#_181" rel="nofollow">
          关系的两个不变性：
         </a>
        </li>
        <li>
         <a href="#_183" rel="nofollow">
          数据完整性
         </a>
        </li>
        <li>
         <a href="#_185" rel="nofollow">
          存在参照完整性约束要求的数据库中建立表的顺序？数据输入的顺序？数据修改和删除的顺序？
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_190" rel="nofollow">
        关系规范化理论
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_194" rel="nofollow">
          关系规范化的目的
         </a>
        </li>
        <li>
         <a href="#_197" rel="nofollow">
          关系规范化的过程实质上是模式分解
         </a>
        </li>
        <li>
         <a href="#_198" rel="nofollow">
          数据依赖
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_205" rel="nofollow">
            函数依赖
           </a>
          </li>
          <li>
           <a href="#_212" rel="nofollow">
            平凡函数依赖
           </a>
          </li>
          <li>
           <a href="#_216" rel="nofollow">
            完全函数依赖和部分函数依赖
           </a>
          </li>
          <li>
           <a href="#_220" rel="nofollow">
            传递函数依赖
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_227" rel="nofollow">
          范式
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_233" rel="nofollow">
            范式的种类
           </a>
          </li>
          <li>
           <a href="#_244" rel="nofollow">
            规范化
           </a>
          </li>
          <li>
           <a href="#_250" rel="nofollow">
            第一范式
           </a>
          </li>
          <li>
           <a href="#_255" rel="nofollow">
            第二范式
           </a>
          </li>
          <li>
           <a href="#_263" rel="nofollow">
            第三范式
           </a>
          </li>
          <li>
           <a href="#BC_268" rel="nofollow">
            BC范式
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#SQL_290" rel="nofollow">
        SQL语言
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#DDL_291" rel="nofollow">
          DDL数据定义语言
         </a>
        </li>
        <li>
         <a href="#DML_304" rel="nofollow">
          DML数据操纵语言
         </a>
        </li>
        <li>
         <a href="#DCL_313" rel="nofollow">
          DCL数据控制语言
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_327" rel="nofollow">
        视图
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_330" rel="nofollow">
          视图与基本表的区别联系
         </a>
        </li>
        <li>
         <a href="#_333" rel="nofollow">
          视图与基本表分别属于三级模式结构的哪一级
         </a>
        </li>
        <li>
         <a href="#_335" rel="nofollow">
          视图的用途:
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_337" rel="nofollow">
        数据库安全保护
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_343" rel="nofollow">
          权限管理
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#GRANT_344" rel="nofollow">
            GRANT授予权限
           </a>
          </li>
          <li>
           <a href="#REVOKE_346" rel="nofollow">
            REVOKE
           </a>
          </li>
          <li>
           <a href="#DENY_348" rel="nofollow">
            DENY拒绝权限
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_350" rel="nofollow">
          角色
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_358" rel="nofollow">
        数据库的备份与恢复
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_359" rel="nofollow">
          数据库备份恢复的必要性
         </a>
        </li>
        <li>
         <a href="#_363" rel="nofollow">
          故障是不可避免的
         </a>
        </li>
        <li>
         <a href="#_378" rel="nofollow">
          恢复操作的基本原理：
         </a>
        </li>
        <li>
         <a href="#_383" rel="nofollow">
          数据库恢复的实现技术
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_387" rel="nofollow">
        数据库的并发控制
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_388" rel="nofollow">
          事物的概念
         </a>
        </li>
        <li>
         <a href="#_395" rel="nofollow">
          事物的特性
         </a>
        </li>
        <li>
         <a href="#_404" rel="nofollow">
          并发控制
         </a>
        </li>
        <li>
         <a href="#_419" rel="nofollow">
          并发控制机制：
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_422" rel="nofollow">
            基本的封锁类型有两种：
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_428" rel="nofollow">
        数据库设计
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_429" rel="nofollow">
          数据库设计的步骤、各个步骤的任务是什么？
         </a>
        </li>
        <li>
         <a href="#_440" rel="nofollow">
          概念设计举例
         </a>
        </li>
        <li>
         <a href="#_443" rel="nofollow">
          逻辑设计举例
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     数据库的基本概念
    </h2>
    <h3>
     <a id="Data_2">
     </a>
     数据（Data）
    </h3>
    <p>
     <strong>
      定义：描述事物的符号记录称为数据
     </strong>
     <br/>
     是数据库中存储的基本对象，例如：文本，视频，语音，图像等都属于数据
     <br/>
     数据的表现形式还不能完全表达其内容，需要经过解释，数据和关于数据的解释是不可分的，数据的含义（解释）称为数据的语义
    </p>
    <p>
     即：
     <strong>
      数据与其语义是不可分的
     </strong>
    </p>
    <h3>
     <a id="DB_8">
     </a>
     数据库（DB）
    </h3>
    <p>
     <strong>
      定义：数据库是长期储存在计算机内、有组织、可共享到达大量数据的集合，数据库中的数据按照一定的数据模型组织、描述和存储，具有较小的冗余度，较高的独立性和易扩展性，并可为各种用户共享
     </strong>
     <br/>
     特点（对于数据库中的数据）：永久存储，有组织，可共享
    </p>
    <h3>
     <a id="DBS_11">
     </a>
     数据库系统（DBS）
    </h3>
    <p>
     DBS由DB,DBMS,应用程序，DBA（数据库管理员）组成，是存储，管理，处理，维护数据的系统
    </p>
    <h3>
     <a id="DBMS_13">
     </a>
     数据库管理系统(DBMS)
    </h3>
    <p>
     是一个位于用户和操作系统之间的一层数据管理软件，与操作系统一样是计算机的基础软件
    </p>
    <h3>
     <a id="_15">
     </a>
     数据库管理员
    </h3>
    <p>
     使用数据库管理系统对数据库里的数据进行管理的专业人员
    </p>
    <h3>
     <a id="_18">
     </a>
     数据库系统的三级模式结构：
    </h3>
    <p>
     分别为：外模式，模式，内模式
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/20d1b159ea23a4f432e5e9684cad5112.png"/>
    </p>
    <h5>
     <a id="_22">
     </a>
     模式：
    </h5>
    <p>
     也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图（处于结构的中间层）
    </p>
    <p>
     <strong>
      不干涉数据的物理存储细节和硬件环境，与具体的应用程序、所用的应用开发工具及高级程序设计语言无关
     </strong>
    </p>
    <p>
     <strong>
      一个数据库只有一个模式
     </strong>
    </p>
    <p>
     <strong>
      以某种数据模型为基础，统一考虑所有用户的需求，并有机结合形成一个逻辑整体
     </strong>
    </p>
    <p>
     <strong>
      定义模式时不仅要定义数据的逻辑结构而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求
     </strong>
    </p>
    <h5>
     <a id="_34">
     </a>
     外模式：
    </h5>
    <p>
     也称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据逻辑表示
    </p>
    <p>
     通常情况下外模式是模式的子集，一个数据库可以有多个外模式
    </p>
    <p>
     <strong>
      外模式是保证数据库安全性的一个有力措施，有个用户只能看见和访问其所对应的外模式中的数据，其余数据不可见
     </strong>
    </p>
    <h5>
     <a id="_42">
     </a>
     内模式：
    </h5>
    <p>
     也称存储模式，一个数据库只有一个内模式，
     <strong>
      是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式
     </strong>
    </p>
    <h5>
     <a id="_46">
     </a>
     总结：
    </h5>
    <p>
     三级模式是数据的三个抽象级别，把数据的具体组织留给DBMS来管理，使得用户可以有逻辑地、抽象地处理数据，而不必关心数据在计算机中具体表现形式（与面向对象概念相似）
    </p>
    <h3>
     <a id="_49">
     </a>
     数据库的二级映像功能与数据独立性：
    </h3>
    <p>
     二级映像能在系统内部实现三个抽象层次的联系和转换
    </p>
    <h4>
     <a id="_53">
     </a>
     二级映像：
    </h4>
    <ol>
     <li>
      外模式/模式映像
     </li>
     <li>
      模式/内模式映像
     </li>
    </ol>
    <p>
     <strong>
      两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性
     </strong>
    </p>
    <h4>
     <a id="_60">
     </a>
     外模式/模式映像：
    </h4>
    <p>
     模式描述是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构
    </p>
    <p>
     同一个模式可以有任意多个外模式，每个外模式DBS都有一个外模式/模式
    </p>
    <p>
     <strong>
      当模式改变时，由DBA对各个外模式/模式映像作相应改变，可以使外模式保持不变
     </strong>
    </p>
    <p>
     <strong>
      应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性
     </strong>
    </p>
    <h4>
     <a id="_70">
     </a>
     模式/内模式映像：
    </h4>
    <p>
     数据库中只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的。
    </p>
    <p>
     <strong>
      定义了数据全局逻辑结构与存储结构之间的对应关系
     </strong>
    </p>
    <p>
     <strong>
      当数据库的存储结构改变时，由DBA对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序不必改变，保证了数据与程序的物理独立性
     </strong>
    </p>
    <h3>
     <a id="_77">
     </a>
     数据独立性
    </h3>
    <p>
     表示应用程序与数据库中存储的数据不存在依赖关系，包括逻辑数据独立性和物理数据独立性。
     <br/>
     逻辑独立性：模式改变，外模式和应用程序不变
     <br/>
     物理独立性：内模式改变，模式不变，应用程序不变
    </p>
    <h3>
     <a id="_82">
     </a>
     数据模型
    </h3>
    <h4>
     <a id="_83">
     </a>
     数据模型的三要素
    </h4>
    <ol>
     <li>
      数据结构（静态描述）
     </li>
     <li>
      数据操作（动态描述）
     </li>
     <li>
      完整性约束
     </li>
    </ol>
    <h4>
     <a id="_87">
     </a>
     常见的三种数据模型：
    </h4>
    <ol>
     <li>
      层次模型
     </li>
     <li>
      网状模型
     </li>
     <li>
      关系模型
     </li>
    </ol>
    <h4>
     <a id="_91">
     </a>
     关系模型的特点
    </h4>
    <ol>
     <li>
      建立在严格的数学概念的基础上
     </li>
     <li>
      概念统一，实体和联系都以关系来表示；关系必须是规范化的关系，有关系代数作为数学基础，操作简便。
     </li>
     <li>
      对数据的检索结果也是关系。
     </li>
     <li>
      关系模型的存取路径对用户透明
     </li>
    </ol>
    <h2>
     <a id="_96">
     </a>
     关系数据库理论
    </h2>
    <h3>
     <a id="_97">
     </a>
     关系的基本概念
    </h3>
    <h4>
     <a id="_98">
     </a>
     域
    </h4>
    <p>
     定义：具有相同数据类型的值的集合
    </p>
    <h4>
     <a id="_100">
     </a>
     关系
    </h4>
    <p>
     是关系模型的数据结构
    </p>
    <p>
     特点：简单，描述性强（描述出现实世界的实体和实体之间的联系），语义丰富
    </p>
    <p>
     关系模型建立在集合代数的基础上
    </p>
    <p>
     其实就是满足约束的表
    </p>
    <h5>
     <a id="_108">
     </a>
     关系表示：
    </h5>
    <p>
     关系（属性名1，……）
    </p>
    <h4>
     <a id="_111">
     </a>
     元组
    </h4>
    <p>
     关系中可以用于描述一个具体的实例的集合
    </p>
    <h4>
     <a id="_113">
     </a>
     属性
    </h4>
    <p>
     描述实体的特性称为属性。如职工的职工号，姓名，性别，出生日期，职称等。
    </p>
    <h4>
     <a id="_115">
     </a>
     目/度
    </h4>
    <p>
     定义：D1×D2×……×Dn的子集叫做D1,D2,……Dn上的关系表示为R（D1,D2,……Dn）
    </p>
    <p>
     R：关系的名字
    </p>
    <p>
     n：关系的目或度
    </p>
    <p>
     <strong>
      关系是笛卡尔积的有限子集，n目关系必有n个属性
     </strong>
    </p>
    <p>
     按照定义关系可以是个无限集合，不满足交换律
    </p>
    <p>
     ①无限关系在数据库系统中是无意义的（数据库中必须为有限集）
    </p>
    <p>
     ②通过为关系的每个列附加一个属性名的方式来消除关系属性的有序性
    </p>
    <h4>
     <a id="_129">
     </a>
     候选码
    </h4>
    <p>
     关系中某一属性组的值能唯一地标识一个元组，而其子集不能，这个属性组就是候选码
    </p>
    <h4>
     <a id="_131">
     </a>
     主属性
    </h4>
    <p>
     候选码的各个属性
    </p>
    <h4>
     <a id="_133">
     </a>
     非主属性
    </h4>
    <p>
     不包含在任何候选码中的属性
    </p>
    <h4>
     <a id="_135">
     </a>
     外码
    </h4>
    <p>
     数据库中如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码
    </p>
    <h4>
     <a id="_137">
     </a>
     全码
    </h4>
    <p>
     极端情况下，关系模式的所有属性是这个关系模式的候选码
    </p>
    <h4>
     <a id="_139">
     </a>
     范式
    </h4>
    <p>
     规范化的关系
    </p>
    <h3>
     <a id="_142">
     </a>
     总结（建议看这个因为是人话）：
    </h3>
    <p>
     关系是一张属性不可分二维表，表中的每行（即数据库中的每条记录）就是一个元组，元组的集合称为关系，每列就是一个属性。 在二维表里，元组也称为行，属性为列。能够将这张二维表中的元组进行区分的属性的集合就是候选码，候选码中的每一个属性都是主属性，不在候选码中的属性就是非主属性，如果出现一张二维表中需要使用所有属性才能区分出每个元组的情况那么这些所有的属性就合称为全码。
    </p>
    <p>
     例子：
     <br/>
     学生表：关系
     <br/>
     学生表中的学生号，学生姓名，学生性别：属性
     <br/>
     学生表中的学生性别可取男或女，其中男女：域
     <br/>
     学生表中有一行为 200020002 张三 男 ：元组
     <br/>
     学生表中的学生号：主属性
     <br/>
     学生表中的学生姓名，学生性别：非主属性
    </p>
    <h3>
     <a id="_153">
     </a>
     关系的三种类型：
    </h3>
    <ol>
     <li>
      基本关系或基本表（实际存在，是实际存储数据的逻辑表示）
     </li>
     <li>
      查询表（查询结果对应的表）
     </li>
     <li>
      视图表（虚表，不对应实际存储的数据，由基本表或其他视图表导出）
     </li>
    </ol>
    <h3>
     <a id="6_159">
     </a>
     基本关系的6条性质：
    </h3>
    <ol>
     <li>
      同质——每个列中的分量是同一类型的数据，属于同域
     </li>
     <li>
      不同列可属于同域，每列为一个属性，不同的属性应有不同的属性名
     </li>
     <li>
      列的顺序无所谓
     </li>
     <li>
      任意两个元组的候选码不能取相同的值
     </li>
     <li>
      行的顺序也无所谓
     </li>
     <li>
      <strong>
       每个分量必须是不可再分的数据项
      </strong>
     </li>
    </ol>
    <h2>
     <a id="_167">
     </a>
     关系代数
    </h2>
    <p>
     看《数据库系统概论》p48~p57
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/74ad7b6c9efb59a735dadaef56183693.png"/>
    </p>
    <h2>
     <a id="_170">
     </a>
     关系的完整性
    </h2>
    <p>
     为了保证数据库中的数据在逻辑上的正确性，一致性，有效性，保证数据的完整性，关系数据库提供的一套数据完整性的约束机制
    </p>
    <h3>
     <a id="1__172">
     </a>
     1. 实体完整性
    </h3>
    <p>
     实体完整性指表中行的完整性。主要用于保证操作的数据(记录)非空、唯一且不重复。即实体完整性要求每个关系表有且仅有一个主键，每个主键值必须唯一，而且不允许为“空”或重复。
    </p>
    <h3>
     <a id="2__175">
     </a>
     2. 参照完整性
    </h3>
    <p>
     参照完整性属于表间规则。对于更新、插入、删除表间数据的完整性，统称为参照完整性。在关系数据库中，关系之间的联系是通过公共属性实现的。这个公共属性经常是一个表的主键，同时是另一个表的外键。参照完整性体现在两个方面：实现了表与表之间的联系，外键的取值必须是另一个表的主键的有效值，或是“空”值。
    </p>
    <h3>
     <a id="3__178">
     </a>
     3. 用户定义完整性
    </h3>
    <p>
     用户定义完整性是对数据表中字段属性的约束，用户定义完整性规则也称域完整性规则。包括字段的值域、字段类型和字段的有效规则等约束，是由确定关系结构时所定义的字段属性决定的。
    </p>
    <h3>
     <a id="_181">
     </a>
     关系的两个不变性：
    </h3>
    <p>
     实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。
    </p>
    <h3>
     <a id="_183">
     </a>
     数据完整性
    </h3>
    <p>
     实体完整性规则规定基本关系的所有主属性都不能取空值
    </p>
    <h3>
     <a id="_185">
     </a>
     存在参照完整性约束要求的数据库中建立表的顺序？数据输入的顺序？数据修改和删除的顺序？
    </h3>
    <p>
     建表和输入：先主表（被参照表），后从表（参照表）
    </p>
    <p>
     修改和删除：先从表，后主表
    </p>
    <h2>
     <a id="_190">
     </a>
     关系规范化理论
    </h2>
    <p>
     关系规范化是为了解决数据库中数据的插入、删除、修改异常等问题的一组规则。
    </p>
    <h3>
     <a id="_194">
     </a>
     关系规范化的目的
    </h3>
    <p>
     控制冗余，避免插入与删除异常，增强结构的稳定性和灵活性
    </p>
    <h3>
     <a id="_197">
     </a>
     关系规范化的过程实质上是模式分解
    </h3>
    <h3>
     <a id="_198">
     </a>
     数据依赖
    </h3>
    <p>
     通过一个关系内部属性与属性之间的一种约束关系。
     <br/>
     是现实世界属性间相互联系的抽象
     <br/>
     是数据内在的性质
    </p>
    <p>
     在数据依赖中，函数依赖是最基本、最重要的一种依赖。
    </p>
    <h4>
     <a id="_205">
     </a>
     函数依赖
    </h4>
    <p>
     定义：
     <br/>
     设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)
     <br/>
     的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，
     <br/>
     而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作：X --&gt; Y
     <br/>
     X称为决定因素，Y称为依赖因素。
     <br/>
     若Y不函数依赖于X，则记作：X–&gt;Y
    </p>
    <h4>
     <a id="_212">
     </a>
     平凡函数依赖
    </h4>
    <p>
     • X→Y，Y⊈X，则称X→Y是非平凡的函数依赖。
     <br/>
     • X→Y，但Y⊆X ，则称X→Y是平凡的函数依赖。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b36ba9cf2cab4620a480608069648b0a.png"/>
    </p>
    <h4>
     <a id="_216">
     </a>
     完全函数依赖和部分函数依赖
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0b12bb467990f6ecb3b37d507acfb8af.png">
      完全函数依赖就是需要所有候选码才能唯一辨识一张表
      <br/>
      部分函数依赖即主属性和非主属性辨识一张表，是否含有非主属性不影响辨识
     </img>
    </p>
    <h4>
     <a id="_220">
     </a>
     传递函数依赖
    </h4>
    <p>
     定义：
     <br/>
     在R（U）中，如果X→Y，（Y⊈X），Y--&gt; X，Y→Z，则称
     <br/>
     Z对X传递函数依赖（transitive functional dependency）。
     <br/>
     记为：X传递Z。
     <br/>
     如果Y→X, 即X ↔ Y，则Z直接依赖于X。
    </p>
    <h3>
     <a id="_227">
     </a>
     范式
    </h3>
    <p>
     范式是符合某一种级别的关系模式的集合
    </p>
    <p>
     关系数据库中的关系必须满足一定的要求。
     <br/>
     满足不同程度要求的为不同范式
    </p>
    <h4>
     <a id="_233">
     </a>
     范式的种类
    </h4>
    <p>
     第一范式(1NF)
     <br/>
     第二范式(2NF)
     <br/>
     第三范式(3NF)
     <br/>
     BC范式(BCNF，Boyce和Codd共同提出的范式）
     <br/>
     第四范式(4NF)
     <br/>
     第五范式(5NF)
    </p>
    <p>
     各种范式之间存在联系：
     <br/>
     1NF⊃2NF ⊃3NF ⊃ BCNF ⊃ 4NF ⊃ 5NF
    </p>
    <h4>
     <a id="_244">
     </a>
     规范化
    </h4>
    <p>
     一个低一级范式的关系模式，通过模式分解
     <br/>
     （schema decomposition）可以转换为若
     <br/>
     干个高一级范式的关系模式的集合，这种过
     <br/>
     程就叫规范化（normalization）。
    </p>
    <h4>
     <a id="_250">
     </a>
     第一范式
    </h4>
    <p>
     如果一个关系模式R的所有属性都是不可分的基本数据项，则 R∈1NF。
    </p>
    <p>
     第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据模式。
    </p>
    <h4>
     <a id="_255">
     </a>
     第二范式
    </h4>
    <p>
     若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则 R∈2NF。
    </p>
    <p>
     关系模式不属于2NF会出现的问题
    </p>
    <ol>
     <li>
      插入异常
     </li>
     <li>
      删除异常
     </li>
     <li>
      数据冗余度大
     </li>
     <li>
      修改复杂
     </li>
    </ol>
    <h4>
     <a id="_263">
     </a>
     第三范式
    </h4>
    <p>
     若关系模式R∈2NF，并且不存在非主属性对码的传递函数依赖，则 R∈3NF。
     <br/>
     关系模式不属于2NF会出现的问题
     <br/>
     同2NF
    </p>
    <h4>
     <a id="BC_268">
     </a>
     BC范式
    </h4>
    <p>
     在关系模式R&lt;U，F&gt;中，如果每一个决定因素都包含码，则R∈BCNF。
     <br/>
     BCNF的关系模式所具有的性质
    </p>
    <ol>
     <li>
      所有非主属性对每一个码都是完全函数依赖。
     </li>
     <li>
      所有主属性对每一个不包含它的码也是完全函数依赖。
     </li>
     <li>
      没有任何属性完全函数依赖于非码的任何一组属性。
     </li>
    </ol>
    <p>
     如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了操
     <br/>
     作异常诸多问题。
    </p>
    <p>
     总结：
     <br/>
     1NF --&gt; 消除非主属性对码的部分函数依赖 --&gt; 2NF
     <br/>
     2NF --&gt; 消除非主属性对码的传递函数依赖 --&gt;3NF
     <br/>
     3NF --&gt; 消除主属性对码的部分和传递函数依赖–&gt;BCNF
    </p>
    <p>
     一个关系模式只要其分量都是不可分的数据项，它就是规范化的关系模式，但这只是最基本的规范化。
     <br/>
     规范化程度过低的关系模式不一定能够很好地描述现实世界，可能会存在插入异常、删除异常、修改复杂、数据冗余等问题，解决方法就是对其进行规范化，转换成高级范式。
     <br/>
     一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。
     <br/>
     关系数据库的规范化理论是数据库逻辑设计的工具
    </p>
    <p>
     规范化实质上是概念的单一化
    </p>
    <h2>
     <a id="SQL_290">
     </a>
     SQL语言
    </h2>
    <h3>
     <a id="DDL_291">
     </a>
     DDL数据定义语言
    </h3>
    <p>
     用途：
    </p>
    <ol>
     <li>
      创建数据库
     </li>
     <li>
      创建表格
     </li>
     <li>
      创建视图
     </li>
     <li>
      创建索引
     </li>
     <li>
      删除表格
     </li>
     <li>
      删除索引
     </li>
     <li>
      删除视图
     </li>
     <li>
      修改表格
     </li>
     <li>
      修改视图
     </li>
     <li>
      修改索引
     </li>
    </ol>
    <h3>
     <a id="DML_304">
     </a>
     DML数据操纵语言
    </h3>
    <p>
     SELECT
     <br/>
     SELECT是SQL数据操纵语言(DML)中用于查询表格内字段数据的指令，可搭配条件限制的子句(如where)或排列顺序的子句(如order)来获取查询结果。
     <br/>
     INSERT
     <br/>
     INSERT向表中插入数据
     <br/>
     UPDATE
     <br/>
     UPDATE 给定条件，将匹配条件的数据表中的数据更新为新的数值。
     <br/>
     DELETE
     <br/>
     DELETE 删除表中的数据的指令
    </p>
    <h3>
     <a id="DCL_313">
     </a>
     DCL数据控制语言
    </h3>
    <p>
     DCL 以控制用户的访问权限为主
     <br/>
     GRANT授予权限
     <br/>
     GRANT [权限] ON [要授予权限的资料库物件] TO [使用者帐户名称] WITH [授权选项]
     <br/>
     REVOKE
     <br/>
     REVOKE [权限] ON [表名] TO [用户名]
     <br/>
     DENY拒绝权限
     <br/>
     DENY [权限] ON [要授予权限的资料库物件] TO [使用者帐户名称]
     <br/>
     详细看实验
     <br/>
     <a href="https://blog.csdn.net/qq_51553982/article/details/121190049?spm=1001.2014.3001.5501">
      数据库练习1
     </a>
     <br/>
     <a href="https://blog.csdn.net/qq_51553982/article/details/121196652?spm=1001.2014.3001.5501">
      数据库练习2
     </a>
     <br/>
     <a href="https://blog.csdn.net/qq_51553982/article/details/121454183?spm=1001.2014.3001.5501">
      数据库练习3
     </a>
     <br/>
     <a href="https://blog.csdn.net/qq_51553982/article/details/121781796?spm=1001.2014.3001.5501">
      数据库练习4
     </a>
     <br/>
     <a href="https://blog.csdn.net/qq_51553982/article/details/121965625?spm=1001.2014.3001.5501">
      数据库练习5
     </a>
    </p>
    <h2>
     <a id="_327">
     </a>
     视图
    </h2>
    <p>
     视图是指计算机数据库中的视图，是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    </p>
    <h3>
     <a id="_330">
     </a>
     视图与基本表的区别联系
    </h3>
    <p>
     视图是从一个或几个基本表导出的表，是一个虚表。数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。一般的视图在使用上与基本表基本等同，用户可以如同使用基本表一样使用视图，可以在视图上再定义视图。有些视图不同于基本表，在数据操作上有限制。
    </p>
    <h3>
     <a id="_333">
     </a>
     视图与基本表分别属于三级模式结构的哪一级
    </h3>
    <p>
     外模式和模式
    </p>
    <h3>
     <a id="_335">
     </a>
     视图的用途:
    </h3>
    <p>
     简化权限管理，提高安全性、屏蔽复杂性，简化用户的操作处理、便于数据共享、方便应用维护，提高数据独立性
    </p>
    <h2>
     <a id="_337">
     </a>
     数据库安全保护
    </h2>
    <p>
     数据库的安全性是指保护数据库以防止不合法的使用造成的数据泄露，更改或破坏。
     <br/>
     数据库系统的安全特性主要是针对数据而言的，包括数据独立性、数据安全性、数据完整性、并发控制、故障恢复等几个方面。
    </p>
    <p>
     数据库安全性的核心问题是DBMS的存取控制机制，它确保进入系统的合法用户只能进行合法的操作
    </p>
    <h3>
     <a id="_343">
     </a>
     权限管理
    </h3>
    <h4>
     <a id="GRANT_344">
     </a>
     GRANT授予权限
    </h4>
    <p>
     GRANT [权限] ON [要授予权限的资料库物件] TO [使用者帐户名称] WITH [授权选项]
    </p>
    <h4>
     <a id="REVOKE_346">
     </a>
     REVOKE
    </h4>
    <p>
     REVOKE [权限] ON [表名] TO [用户名]
    </p>
    <h4>
     <a id="DENY_348">
     </a>
     DENY拒绝权限
    </h4>
    <p>
     DENY [权限] ON [要授予权限的资料库物件] TO [使用者帐户名称]
    </p>
    <h3>
     <a id="_350">
     </a>
     角色
    </h3>
    <p>
     为便于对用户及权限的管理，可以将一组具有相同权限的用户组织在一起，这一组具有相同权限的用户就称为角色(Role)
    </p>
    <p>
     角色是权限的集合
     <br/>
     可以为一组具有相同权限的用户创建一个角色
     <br/>
     简化授权的过程
     <br/>
     使用角色来管理数据库权限，可以简化授权和回收的过程。
    </p>
    <h2>
     <a id="_358">
     </a>
     数据库的备份与恢复
    </h2>
    <h3>
     <a id="_359">
     </a>
     数据库备份恢复的必要性
    </h3>
    <ol>
     <li>
      提高系统的高可用性和灾难可恢复性，在数据库系统崩溃的时候，没有数据库备份就没法找到数据。
     </li>
     <li>
      使用数据库备份还原数据库是数据库系统崩溃时提供数据恢复最小代价的最优方案
     </li>
     <li>
      没有数据就没有一切，数据库备份就是一种防范灾难于未然的强力手段
     </li>
    </ol>
    <h3>
     <a id="_363">
     </a>
     故障是不可避免的
    </h3>
    <ol>
     <li>
      <p>
       计算机硬件故障
      </p>
     </li>
     <li>
      <p>
       系统软件和应用软件的错误
      </p>
     </li>
     <li>
      <p>
       操作员的失误
      </p>
     </li>
     <li>
      <p>
       恶意的破坏
      </p>
     </li>
    </ol>
    <p>
     <strong>
      这些故障轻则造成事务非正常中断，影响数据库中数据的正确性，重则破坏数据库，使数据库中的数据部分或全部丢失。
     </strong>
    </p>
    <h3>
     <a id="_378">
     </a>
     恢复操作的基本原理：
    </h3>
    <p>
     <strong>
      利用冗余
     </strong>
    </p>
    <p>
     <strong>
      利用存储在系统其它地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据
     </strong>
    </p>
    <h3>
     <a id="_383">
     </a>
     数据库恢复的实现技术
    </h3>
    <ol>
     <li>
      数据转储
     </li>
     <li>
      登记日志文件
     </li>
    </ol>
    <h2>
     <a id="_387">
     </a>
     数据库的并发控制
    </h2>
    <h3>
     <a id="_388">
     </a>
     事物的概念
    </h3>
    <p>
     定义：
     <br/>
     事务（Transaction）是指作为单个逻辑工作单元执行的一系列数据库操作。一个事务可以是一组SQL语句、一条SQL语句或整个程序。
     <br/>
     <strong>
      一个应用程序可以包括多个事务。
     </strong>
     <br/>
     一个事务内的所有语句被作为整体执行，要么全部执行，要么全部不执行。
     <br/>
     <strong>
      事务是保证数据一致性的基本手段
     </strong>
     <br/>
     <strong>
      事务是数据库并发控制技术涉及的基本概念，是并发控制的基本单位。
     </strong>
    </p>
    <h3>
     <a id="_395">
     </a>
     事物的特性
    </h3>
    <p>
     （1）原子性（Atomicity）：事务所包含的所有操作要么全部正确地
     <br/>
     反映在数据库中，要么全部不反映；
     <br/>
     （2）一致性（Consistency）：事务的执行会使数据库从一种一致性
     <br/>
     的状态达到另一种一致性状态，即事务的执行不会让数据库出现不一致；
     <br/>
     （3）隔离性（Isolation）：事务之间是隔离的，每个事务都感觉不到
     <br/>
     系统中有其他事务在并发地执行；
     <br/>
     （4）持久性（Durability）：一个事务成功完成后，它对数据库的改
     <br/>
     变是永久的，即使系统出现故障也是如此。
    </p>
    <h3>
     <a id="_404">
     </a>
     并发控制
    </h3>
    <p>
     为了保证事务的隔离性和一致性，DBMS需要对并发操作进行正确的调度。
     <br/>
     并发操作带来的数据不一致性主要包括三类：
    </p>
    <ol>
     <li>
      丢失修改
      <br/>
      两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。
     </li>
     <li>
      不可重复读
      <br/>
      不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一
      <br/>
      次的读取结果。
      <br/>
      对同一个数据库对象进行读和更新操作
     </li>
     <li>
      读“脏”数据
      <br/>
      读“脏”数据是指事务T1更新了数据A，并将其写回磁盘，事务T2读取了更新后的数据A，而事务T1由于某种原因被撤销，修改无效，数据A恢复原值。事务T2得到的数据与数据库的数据不一致，则T2读到的数据就为“脏”数据，即不正确的数据。
     </li>
    </ol>
    <p>
     产生上述三类数据不一致性的主要原因就是：
     <br/>
     并发操作破坏了事务的隔离性。并发控制就是要用正确的方式调度并发操作，使
     <br/>
     每个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。
    </p>
    <h3>
     <a id="_419">
     </a>
     并发控制机制：
    </h3>
    <p>
     封锁机制
    </p>
    <h4>
     <a id="_422">
     </a>
     基本的封锁类型有两种：
    </h4>
    <p>
     排它锁,简称X锁:不允许其他任何事务读取和修改，不能再加任何类型的锁
    </p>
    <p>
     共享锁，简称S锁：其他事务只能再加S锁，不能加X锁
    </p>
    <h2>
     <a id="_428">
     </a>
     数据库设计
    </h2>
    <h3>
     <a id="_429">
     </a>
     数据库设计的步骤、各个步骤的任务是什么？
    </h3>
    <ol>
     <li>
      需求分析的任务、表达工具：数据流图、数据字典
     </li>
     <li>
      概念结构设计（画E-R图）：自底向上、局部E-R图、集成
      <br/>
      概念结构独立于DBMS，通常用E-R图表示（三要素：实体、属性、联系）
      <br/>
      实体之间的联系类型（1:1、1:n、m:n）
     </li>
     <li>
      逻辑结构设计（转换为DBMS支持的数据模型）：
      <br/>
      不同类型联系的转换、表间的关联（关系模型）
     </li>
     <li>
      物理结构设计：
      <br/>
      要求、内容、索引的使用
     </li>
     <li>
      数据库实施
     </li>
     <li>
      数据库的运行和维护
     </li>
    </ol>
    <h3>
     <a id="_440">
     </a>
     概念设计举例
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/13cb1fdf64d9a7290da4133ba0436fdb.png"/>
    </p>
    <h3>
     <a id="_443">
     </a>
     逻辑设计举例
    </h3>
    <p>
     产品（
     <strong>
      产品号
     </strong>
     ，产品名，规格）
    </p>
    <p>
     工人（
     <strong>
      工号
     </strong>
     ，姓名，性别，年龄，职称，
     <strong>
      车间
     </strong>
     ）
    </p>
    <p>
     车间（
     <strong>
      车间号
     </strong>
     ，车间名，负责人）
    </p>
    <p>
     生产（
     <strong>
      产品号
     </strong>
     ，
     <strong>
      车间号
     </strong>
     ， 生产数量）
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35313535333938322f:61727469636c652f64657461696c732f313232313530343636" class_="artid" style="display:none">
 </p>
</div>


