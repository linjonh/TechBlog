---
layout: post
title: python-基础学习六pygame游戏开发飞机大战
date: 2021-09-09 01:28:27 +0800
categories: [Python]
tags: [python,pygame]
image:
    path: https://img-blog.csdnimg.cn/6e68b9f24c484ebe85fa646844634f2f.png?x-oss-process&#61;image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQmVnb25pYV9jYXQ&#61;,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center
    alt: python-基础学习六pygame游戏开发飞机大战
artid: 120182430
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     python | 基础学习（六）pygame游戏开发：飞机大战
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-kimbie-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#pygame_2" rel="nofollow">
        一、pygame模块
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_5" rel="nofollow">
          1、安装：
         </a>
        </li>
        <li>
         <a href="#2pygame_9" rel="nofollow">
          2、使用pygame创建图形窗口
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1_10" rel="nofollow">
            （1）新建项目`飞机大战`
           </a>
          </li>
          <li>
           <a href="#2pygamepy_11" rel="nofollow">
            （2）新建文件`pygame.py`
           </a>
          </li>
          <li>
           <a href="#3_12" rel="nofollow">
            （3）建立游戏窗口：
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#pygame_13" rel="nofollow">
              ①pygame的初始化和退出
             </a>
            </li>
            <li>
             <a href="#pygame_26" rel="nofollow">
              ②pygame的坐标系
             </a>
            </li>
            <li>
             <a href="#pygamedisplay_44" rel="nofollow">
              ③创建游戏主窗口pygame.display
             </a>
            </li>
            <li>
             <a href="#_60" rel="nofollow">
              ④导入游戏背景图片
             </a>
            </li>
            <li>
             <a href="#_74" rel="nofollow">
              ⑤把一些精致的图像绘制到游戏窗口中
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#3_89" rel="nofollow">
          3、游戏循环
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_97" rel="nofollow">
            ①动画效果——游戏时钟
           </a>
          </li>
          <li>
           <a href="#_112" rel="nofollow">
            ②动画的简单实现
           </a>
          </li>
          <li>
           <a href="#_137" rel="nofollow">
            ③在游戏循环中监听事件
           </a>
          </li>
          <li>
           <a href="#spriteSpritespriteGroup_162" rel="nofollow">
            ④精灵sprite.Sprite和精灵组sprite.Group
           </a>
          </li>
          <li>
           <a href="#_167" rel="nofollow">
            ⑤派生精灵子类
           </a>
          </li>
          <li>
           <a href="#_____205" rel="nofollow">
            ⑥使用 游戏精灵 和 精灵组 创建敌机
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#4_239" rel="nofollow">
          4、游戏框架搭建
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1_241" rel="nofollow">
            （1）明确主程序职责
           </a>
          </li>
          <li>
           <a href="#2_249" rel="nofollow">
            （2）实现飞机大战主游戏类
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_261" rel="nofollow">
              常量
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#3_283" rel="nofollow">
            （3）游戏背景
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_284" rel="nofollow">
              ①背景交替滚动的思路
             </a>
            </li>
            <li>
             <a href="#plane_mainpy_307" rel="nofollow">
              ②在plane_main.py中显示背景精灵
             </a>
            </li>
            <li>
             <a href="#_321" rel="nofollow">
              ③简化背景精灵的创建
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#4_354" rel="nofollow">
            （4）敌机
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_356" rel="nofollow">
              ①使用定时器添加敌机
             </a>
            </li>
            <li>
             <a href="#Enemy_378" rel="nofollow">
              ②设计Enemy类
             </a>
            </li>
            <li>
             <a href="#_392" rel="nofollow">
              ③创建敌机
             </a>
            </li>
            <li>
             <a href="#___412" rel="nofollow">
              ④ 随机 敌机位置和速度
             </a>
            </li>
            <li>
             <ul>
              <li>
               <a href="#_413" rel="nofollow">
                导入模块时，建议按照以下顺序导入
               </a>
              </li>
             </ul>
            </li>
            <li>
             <a href="#_435" rel="nofollow">
              ⑤移出屏幕销毁敌机
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#5_454" rel="nofollow">
            （5）英雄飞机
           </a>
          </li>
          <li>
           <a href="#6_459" rel="nofollow">
            （6）子弹需求
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_481" rel="nofollow">
              ①绘制英雄
             </a>
            </li>
            <li>
             <a href="#_495" rel="nofollow">
              ②移动英雄位置
             </a>
            </li>
            <li>
             <a href="#_540" rel="nofollow">
              ③控制英雄的移动边界
             </a>
            </li>
            <li>
             <a href="#_549" rel="nofollow">
              ④发射子弹
             </a>
            </li>
            <li>
             <a href="#_576" rel="nofollow">
              ⑤定义子弹类
             </a>
            </li>
            <li>
             <a href="#_609" rel="nofollow">
              ⑥发射子弹
             </a>
            </li>
            <li>
             <a href="#_631" rel="nofollow">
              ⑦一次发射三枚子弹
             </a>
            </li>
            <li>
             <a href="#_645" rel="nofollow">
              ⑧碰撞检测
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_673" rel="nofollow">
        五、游戏设计完成，运行图片
       </a>
      </li>
      <li>
       <a href="#plane_mainpy_680" rel="nofollow">
        附录一：plane_main.py
       </a>
      </li>
      <li>
       <a href="#plane_spritespy_800" rel="nofollow">
        附录二：plane_sprites.py
       </a>
      </li>
      <li>
       <a href="#_932" rel="nofollow">
        附录三：飞机大战设计图片
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="pygame_2">
     </a>
     一、pygame模块
    </h2>
    <p>
     <code>
      pygame
     </code>
     模块，转为电子游戏设计
    </p>
    <h3>
     <a id="1_5">
     </a>
     1、安装：
    </h3>
    <p>
     <code>
      $ sudo pip3 install pygame
     </code>
     <br/>
     windows：
     <code>
      pip install pygame
     </code>
    </p>
    <h3>
     <a id="2pygame_9">
     </a>
     2、使用pygame创建图形窗口
    </h3>
    <h4>
     <a id="1_10">
     </a>
     （1）新建项目
     <code>
      飞机大战
     </code>
    </h4>
    <h4>
     <a id="2pygamepy_11">
     </a>
     （2）新建文件
     <code>
      pygame.py
     </code>
    </h4>
    <h4>
     <a id="3_12">
     </a>
     （3）建立游戏窗口：
    </h4>
    <h5>
     <a id="pygame_13">
     </a>
     ①pygame的初始化和退出
    </h5>
    <p>
     <code>
      pygame.init()
     </code>
     ：导入并初始化所有pygame模块，使用其他模块之前，必须先调用init方法。
     <br/>
     <code>
      pygame.quit()
     </code>
     ：卸载所有pygame模块，在游戏结束之前调用。
    </p>
    <p>
     <strong>
      代码框架
     </strong>
     ：
    </p>
    <pre><code>import pygame 

pygame.init()

print("游戏的代码")

pygame.quit()
</code></pre>
    <h5>
     <a id="pygame_26">
     </a>
     ②pygame的坐标系
    </h5>
    <p>
     原点在左上角
     <code>
      (0, 0)
     </code>
     <br/>
     <strong>
      x轴
     </strong>
     水平方向向右，逐渐增加
     <br/>
     <strong>
      y轴
     </strong>
     垂直方向向下，逐渐增加
    </p>
    <p>
     在游戏中，所有可见的元素都是以
     <strong>
      矩形区域
     </strong>
     来描述位置的。四要素
     <code>
      (x, y)(width, height)
     </code>
     。
     <strong>
      (x, y)
     </strong>
     指定矩形的左上角位置，
     <strong>
      (width, height)
     </strong>
     指定矩形区域的大小。
     <br/>
     pygame专门提供了一个类
     <code>
      pygame.Rect
     </code>
     用于描述矩形区域，【其中，size表示(width, height)】：
    </p>
    <blockquote>
     <p>
      <code>
       Rect(x, y, width, height)
      </code>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0e3e02d2c32b1242575c4142022097d2.png#pic_center"/>
     </p>
    </blockquote>
    <pre><code>import pygame

hero_rect = pygame.Rect(100, 500, 120, 125)
print("hero的原点%d %d" % (hero_rect.x, hero_rect.y))
print("hero的尺寸%d %d" % (hero_rect.width, hero_rect.height))
print("hero的size%d %d" % hero_rect.size )
</code></pre>
    <p>
     输出：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5512693795a6d64690f786e2b1d6aec4.png#pic_center"/>
    </p>
    <h5>
     <a id="pygamedisplay_44">
     </a>
     ③创建游戏主窗口pygame.display
    </h5>
    <p>
     <code>
      pygame.diaplay.set_mode()
     </code>
     ：初始化游戏显示窗口
    </p>
    <blockquote>
     <p>
      <code>
       set_mode
      </code>
      方法：
      <br/>
      <code>
       det_mode(resolution = (0, 0), flags = 0, depth = 0)
      </code>
      <br/>
      <strong>
       参数
      </strong>
      ：（因为每个参数都有
      <code>
       =
      </code>
      ，也就是都有默认值，因此调用时不需要指定值）
     </p>
     <blockquote>
      <p>
       resolution：指定屏幕的
       <strong>
        宽、高
       </strong>
       ，默认创建的窗口大小和屏幕大小一致
       <br/>
       flags：参数指定屏幕的附加选项，例如是否全屏等等，默认不需要传递
       <br/>
       depth：参数表示颜色的位数，默认自动匹配
      </p>
     </blockquote>
     <p>
      <strong>
       返回值
      </strong>
      ：
     </p>
     <blockquote>
      <p>
       暂时可以理解为
       <strong>
        游戏的屏幕
       </strong>
       ，
       <strong>
        游戏的元素
       </strong>
       都需要被绘制到
       <strong>
        游戏的屏幕上
       </strong>
       。
       <br/>
       例如：指定screen接收返回值。
       <br/>
       screen = pygame.display.set_mode((480, 700))。
      </p>
     </blockquote>
    </blockquote>
    <p>
     <code>
      pygame.display.update()
     </code>
     ：刷新屏幕内容显示，稍后使用
    </p>
    <h5>
     <a id="_60">
     </a>
     ④导入游戏背景图片
    </h5>
    <blockquote>
     <p>
      1、将图片加载到内存中。
      <code>
       pygame.image.load()
      </code>
      加载图像的数据
      <br/>
      <strong>
       注
      </strong>
      ：(./images/1.jpg)其中的
      <code>
       .
      </code>
      表示当前目录
     </p>
     <blockquote>
      <p>
       <code>
        bg = pygame.image.load("D:/My life/music/some photos/sunrise.jpg")
       </code>
      </p>
     </blockquote>
    </blockquote>
    <blockquote>
     <p>
      2、使用
      <strong>
       游戏屏幕
      </strong>
      对象，调用
      <code>
       bilt(图像，位置)
      </code>
      方法将图像绘制到指定位置
     </p>
     <blockquote>
      <p>
       <code>
        screen.blit(bg, (0, 0)) # (0, 0)表示从屏幕左上角开始绘制
       </code>
      </p>
     </blockquote>
    </blockquote>
    <blockquote>
     <p>
      3、调用
      <code>
       pygame.display.update()
      </code>
      方法更新整个屏幕的显示。
      <br/>
      <strong>
       注
      </strong>
      ：如果想在屏幕上看到绘制的结果，一定要调用这个方法
     </p>
     <blockquote>
      <p>
       <code>
        pygame.display.update()
       </code>
      </p>
     </blockquote>
    </blockquote>
    <p>
     运行结果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1fc9f68baab5c4025c4ca3cd934853b5.png#pic_center"/>
    </p>
    <h5>
     <a id="_74">
     </a>
     ⑤把一些精致的图像绘制到游戏窗口中
    </h5>
    <blockquote>
     <p>
      1、加载hero_plane图像
      <br/>
      <strong>
       png
      </strong>
      格式是支持透明的。在绘制图像时，透明区域不会显示任何内容。如果下方有内容，会透过
      <strong>
       透明区域
      </strong>
      显示出来
     </p>
     <blockquote>
      <p>
       <code>
        hero = pygame.image.load("D:/My life/music/some photos/plane.png")
       </code>
      </p>
     </blockquote>
    </blockquote>
    <blockquote>
     <p>
      2、将其绘制在屏幕的(150, 500)位置
     </p>
     <blockquote>
      <p>
       <code>
        screen.blit(hero, (150, 500))
       </code>
      </p>
     </blockquote>
    </blockquote>
    <blockquote>
     <p>
      3、调用屏幕更新显示飞机图像
     </p>
     <blockquote>
      <p>
       <code>
        pygame.diaplay.update()
       </code>
      </p>
     </blockquote>
    </blockquote>
    <p>
     输出：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0ed79f0dadb30db1489e2663aef7c96c.png#pic_center">
      <br/>
      注：
      <code>
       screen.blit
      </code>
      方法可以在屏幕上绘制很多图像，这些图像之间可能会彼此重叠。编程时可以在screen对象
      <strong>
       完成所有bilt
      </strong>
      之后，
      <strong>
       统一执行一次
      </strong>
      <code>
       display.update()
      </code>
      。而不是每执行一步update一次，可以减少程序的繁琐。
     </img>
    </p>
    <h3>
     <a id="3_89">
     </a>
     3、游戏循环
    </h3>
    <p>
     将
     <strong>
      while True:
      <strong>
       称为游戏循环（无限循环、死循环）。进入
      </strong>
      游戏循环
     </strong>
     ，意味着游戏正式开始。
    </p>
    <blockquote>
     <p>
      设置刷新频率
      <br/>
      检测用户交互
      <br/>
      更新所有图像位置
      <br/>
      更新屏幕显示
     </p>
    </blockquote>
    <h4>
     <a id="_97">
     </a>
     ①动画效果——游戏时钟
    </h4>
    <p>
     根据
     <strong>
      用户的交互
     </strong>
     或者其他情况，快速
     <strong>
      移动
     </strong>
     这些图像，产生动画效果。一般在电脑上
     <strong>
      每绘制60次
     </strong>
     ，就能够达到非常
     <strong>
      连续 高品质
     </strong>
     的效果。每次绘制的结果被称为
     <strong>
      帧Frame
     </strong>
     。
     <br/>
     pygame专门提供了一个类
     <code>
      pygame.time.Clock
     </code>
     可以非常方便地设置屏幕绘制速度。
    </p>
    <blockquote>
     <p>
      1、在游戏初始化 创建一个时钟对象
      <br/>
      2、在游戏循环中让时钟对象调用
      <code>
       tick(频率)
      </code>
      方法。
     </p>
     <blockquote>
      <p>
       如：
       <code>
        clock.tick(20)
       </code>
       表示每秒20次
      </p>
     </blockquote>
     <p>
      <strong>
       tick
      </strong>
      方法会根据上次被调用的时间，自动设置
      <strong>
       游戏循环
      </strong>
      中的延时。
     </p>
    </blockquote>
    <p>
     代码示例：
    </p>
    <pre><code>i = 0
while True:
	clock.tick(60)
	print(i)
</code></pre>
    <h4>
     <a id="_112">
     </a>
     ②动画的简单实现
    </h4>
    <p>
     每次调用
     <code>
      update()
     </code>
     之前，需要把所有的游戏图像都重新绘制一遍，而且
     <strong>
      最先
     </strong>
     重新绘制
     <strong>
      背景图像
     </strong>
    </p>
    <pre><code>clock = pygame.time.Clock()
plane_rect = pygame.Rect(250, 500, 107, 113)  # 107和113表示所插入的飞机图片的宽度和高度

#死循环，确保上方执行的游戏界面不会退出
while True:
    # 1、指定循环体内部代码执行的频率
    clock.tick(60)

    # 2、修改飞机的位置
    plane_rect.y -= 1
    # 如果移出顶部，就从底部重新开始移动
    if plane_rect.y &lt;= -113:  # -113表示导入飞机图片的高度
        plane_rect.y = 700

    # 3、调用blit方法绘制图像
    screen.blit(bg, (0, 0))# 先绘制背景图像，再绘制飞机，这样就可以遮住上一次飞机的残影
    screen.blit(plane, plane_rect)

    # 4、调用update方法更新显示
    pygame.display.update()
</code></pre>
    <h4>
     <a id="_137">
     </a>
     ③在游戏循环中监听事件
    </h4>
    <p>
     <strong>
      监听
     </strong>
     ：在
     <strong>
      游戏循环
     </strong>
     中，判断用户
     <strong>
      具体的操作（也称为“事件”）
     </strong>
     。只有
     <strong>
      捕获
     </strong>
     到用户的具体操作，才能有针对性地作出相应。
     <br/>
     pygame中通过
     <code>
      pygame.event.get()
     </code>
     可以获得
     <strong>
      用户当前所做的动作
     </strong>
     的
     <strong>
      事件列表
     </strong>
     ，用户可以同一时间做很多事情。
    </p>
    <p>
     下面这段代码非常固定，几乎所有的pygame游戏都大同小异。
    </p>
    <pre><code>#游戏循环
while True:

	#设置屏幕刷新频率
	clock.tick(60)
	
	#事件监听
	for event in pygame.event.get():
		
		#判断用户是否点击了关闭按钮
		if event.type == pygame.QUIT:
			print("退出游戏...")

			#卸载所有的模块
			pygame.quit()

			#直接退出系统，终止当前正在执行的程序
			exit()
</code></pre>
    <h4>
     <a id="spriteSpritespriteGroup_162">
     </a>
     ④精灵sprite.Sprite和精灵组sprite.Group
    </h4>
    <p>
     为了简化开发步骤，pygame提供了两个类：
     <br/>
     pygame.sprite.Sprite——存储
     <strong>
      图像数据image
     </strong>
     和
     <strong>
      位置Rect
     </strong>
     的
     <strong>
      对象
     </strong>
     <br/>
     pygame.sprite.Group
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1af022831cefe541a7937d734b892de7.png#pic_center"/>
    </p>
    <h4>
     <a id="_167">
     </a>
     ⑤派生精灵子类
    </h4>
    <p>
     <strong>
      从本节开始，面向对象开发
     </strong>
     ：
     <br/>
     新建plane_sprites.py文件
     <br/>
     定义GameSprite继承自pygame.sprite.Sprite
     <br/>
     注意：
     <br/>
     如果一个类的父类不是object，在重写
     <strong>
      初始化方法
     </strong>
     时，一定要先super()一下父类的初始化
     <code>
      __init__
     </code>
     方法，保证父类中实现的
     <code>
      __init__
     </code>
     代码能够被正常执行。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f1c466fe7c46b1c777e7592250c7f748.png#pic_center">
      <br/>
      属性：
      <br/>
      <code>
       image
      </code>
      精灵图像，使用
      <code>
       image_name
      </code>
      加载
      <br/>
      <code>
       rect
      </code>
      精灵大小，默认使用图像大小
      <br/>
      <code>
       speed
      </code>
      精灵移动速度，默认为
      <code>
       1
      </code>
     </img>
    </p>
    <p>
     方法：
     <br/>
     <code>
      update
     </code>
     每次更新屏幕时在游戏循环内调用。
     <br/>
     让精灵
     <code>
      self,rect.y += self.speed
     </code>
    </p>
    <p>
     提示：
     <br/>
     <code>
      image
     </code>
     的
     <code>
      get_rect()
     </code>
     方法，可以返回 **pygame.Rect(0, 0, 图像宽，图像高)**的对象。
    </p>
    <pre><code>import pygame

class GameSprite(pygame.sprite.Sprite):
	#飞机大战游戏精灵
	
	def __init__(self, image_name, speed = 1):
	
		#调用父类的初始化方法
		super().__init__()
		
		#定义对象的属性
		self.image = pygame.image.load(image_name)
		self.rect = self.image.get_rect()
		self.speed = speed
		
	def update(self):
		#在屏幕的绘制方向移动
		self.rect.y += self.speed
</code></pre>
    <h4>
     <a id="_____205">
     </a>
     ⑥使用 游戏精灵 和 精灵组 创建敌机
    </h4>
    <p>
     需求：
     <br/>
     使用刚刚派生的 游戏精灵 和 精灵组 创建敌机 并且 实现敌机动画。
     <br/>
     步骤：
     <br/>
     1、使用
     <code>
      from
     </code>
     导入
     <code>
      plane_sprite
     </code>
     模块
    </p>
    <blockquote>
     <p>
      <code>
       from
      </code>
      导入的模块可以
      <strong>
       直接使用
      </strong>
      <br/>
      <code>
       import
      </code>
      导入的模块需要通过
      <code>
       模块名.
      </code>
      来使用
     </p>
     <blockquote>
      <p>
       <code>
        from plane_sprites import *
       </code>
       # 可以直接使用模块的工具，而不用
       <code>
        模块名.
       </code>
      </p>
     </blockquote>
    </blockquote>
    <p>
     2、在游戏初始化 创建
     <strong>
      精灵对象
     </strong>
     和
     <strong>
      精灵组对象
     </strong>
    </p>
    <blockquote>
     <p>
      #创建敌机的精灵
     </p>
     <blockquote>
      <p>
       <code>
        enemy = GameSprite("D:/My life/music/some photos/enemyplane.png")
       </code>
       <br/>
       <code>
        enemy1 = GameSprite("D:/My life/music/some photos/enemyplane.png", 2)
       </code>
       # 第二架敌机的速度是2
      </p>
     </blockquote>
     <p>
      #创建敌机的精灵组
     </p>
     <blockquote>
      <p>
       <code>
        enemy_group = pygame.sprite.Group(enemy, enemy1)
       </code>
      </p>
     </blockquote>
    </blockquote>
    <p>
     3、在
     <strong>
      游戏循环中
     </strong>
     让
     <strong>
      精灵组
     </strong>
     分别调用
     <code>
      update()
     </code>
     和
     <code>
      draw(screen)
     </code>
     方法
    </p>
    <blockquote>
     <p>
      #1、update
     </p>
     <blockquote>
      <p>
       <code>
        enemy_group.update()
       </code>
      </p>
     </blockquote>
     <p>
      #2、draw 在screen上绘制所有的精灵
     </p>
     <blockquote>
      <p>
       <code>
        enemy_group.draw(screen)
       </code>
      </p>
     </blockquote>
    </blockquote>
    <p>
     职责：
     <br/>
     精灵
    </p>
    <blockquote>
     <p>
      封装
      <strong>
       图像image、位置rect 和速度speed
      </strong>
      <br/>
      提供
      <code>
       update()
      </code>
      方法、根据游戏需求、
      <strong>
       更新位置rect
      </strong>
     </p>
    </blockquote>
    <p>
     精灵组
    </p>
    <blockquote>
     <p>
      包含
      <strong>
       多个
      </strong>
      精灵对象
      <br/>
      <code>
       update
      </code>
      方法，让精灵组中的所有精灵各自调用各自的
      <code>
       update
      </code>
      方法更新位置；
      <br/>
      <code>
       draw(screen)
      </code>
      方法，在
      <code>
       screen
      </code>
      上绘制精灵组中的所有精灵
     </p>
    </blockquote>
    <h3>
     <a id="4_239">
     </a>
     4、游戏框架搭建
    </h3>
    <p>
     目标——使用 面向对象 设计 飞机大战游戏类。
    </p>
    <h4>
     <a id="1_241">
     </a>
     （1）明确主程序职责
    </h4>
    <p>
     一个游戏的主程序有两个职责：
    </p>
    <blockquote>
     <p>
      游戏初始化
      <br/>
      游戏循环
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/acf8449593f3a3572a5c9a18f0f70eab.png#pic_center">
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/18cd70c8a5ba0ddd1a572d71342057ba.png#pic_center">
       <br/>
       根据
       <strong>
        职责
       </strong>
       封装
       <strong>
        私有方法
       </strong>
       ，可以避免某一个方法的代码写得太冗长。如果某一个方法编写得太长，不方便阅读。
      </img>
     </img>
    </p>
    <h4>
     <a id="2_249">
     </a>
     （2）实现飞机大战主游戏类
    </h4>
    <p>
     明确文件职责
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9f9e292cf31cb1f2280d7fc46ed0b3c5.png#pic_center"/>
     <br/>
     plane_main
    </p>
    <blockquote>
     <p>
      封装 主游戏类
      <br/>
      创建 游戏对象
      <br/>
      启动游戏
     </p>
    </blockquote>
    <p>
     plane_sprites
    </p>
    <blockquote>
     <p>
      封装游戏中 所有 需要使用的 精灵子类
      <br/>
      提供游戏的 相关工具
     </p>
    </blockquote>
    <h5>
     <a id="_261">
     </a>
     常量
    </h5>
    <p>
     变量：可以变化的量
     <br/>
     常量：不变化的量。
    </p>
    <blockquote>
     <p>
      在开发时，可能会需要使用
      <strong>
       固定的值
      </strong>
      ，这个时候，建议
      <strong>
       不要
      </strong>
      直接使用固定的数值，而应该使用
      <strong>
       常量
      </strong>
      。这样也可以保证代码的可维护性。
      <br/>
      <strong>
       常量的定义
      </strong>
     </p>
     <blockquote>
      <p>
       定义常量的语法与定义变量一样，都是使用
       <strong>
        赋值语句
       </strong>
       。
       <br/>
       常量的命名应该
       <strong>
        所有字母都使用大写，单词与单词之间使用下划线连接
       </strong>
       。
      </p>
     </blockquote>
     <p>
      <strong>
       常量的好处
      </strong>
     </p>
     <blockquote>
      <p>
       阅读代码时，通过 常量名 见名知意，不用猜测数字的含义。
       <br/>
       如果需要调整值，只需要
       <strong>
        修改常量定义
       </strong>
       就可以实现
       <strong>
        统一修改
       </strong>
      </p>
     </blockquote>
    </blockquote>
    <p>
     #屏幕大小的常量
     <br/>
     SCREN_RECT = pygame.Rect(0, 0, 480, 700)
     <br/>
     使用时仅需要
     <code>
      SCREN_RECT.size
     </code>
     就可以表示(480, 700)
     <br/>
     #刷新的帧率
     <br/>
     FRAME_PER_SECOND = 60
    </p>
    <h4>
     <a id="3_283">
     </a>
     （3）游戏背景
    </h4>
    <h5>
     <a id="_284">
     </a>
     ①背景交替滚动的思路
    </h5>
    <p>
     在游戏启动后，
     <strong>
      背景图像
     </strong>
     会连续不断地
     <strong>
      向下方
     </strong>
     移动，
     <strong>
      游戏主角的位置
     </strong>
     始终保持不变，在
     <strong>
      视觉上
     </strong>
     产生英雄的飞机不断向上飞行的
     <strong>
      错觉
     </strong>
     ——在很多跑酷类游戏的套路。
    </p>
    <p>
     解决办法：
    </p>
    <blockquote>
     <p>
      1、创建2张背景图像精灵：第1张完全和屏幕重合，第2张在屏幕的
      <strong>
       正上方
      </strong>
      。
      <br/>
      2、两张图像
      <strong>
       一起向下运动
      </strong>
      <code>
       self.rect.y += self.speed
      </code>
      。
      <br/>
      3、当任意背景精灵的
      <code>
       rect.y &gt;= 屏幕的高度
      </code>
      说明已经
      <strong>
       移动到屏幕下方
      </strong>
      。
      <br/>
      4、当移动到屏幕下方的这张图像 设置到 屏幕的正上方
      <code>
       rect.y = -rect.height
      </code>
     </p>
    </blockquote>
    <p>
     update()方法：
    </p>
    <blockquote>
     <p>
      判断
      <strong>
       是否移出屏幕
      </strong>
      ，如果是，将图像设置到
      <strong>
       屏幕的正上方
      </strong>
      ，从而实现
      <strong>
       交替滚动
      </strong>
     </p>
    </blockquote>
    <p>
     背景精灵的代码实现：
    </p>
    <pre><code>class Background(GameSprite):
    """游戏背景精灵"""

    def update(self):
        # 1、调用父类的方法实现
        super().update()
        # 2、判断是否移出屏幕，如果移出屏幕，将图片移动到正上方
        if self.rect.y &gt;= SCREEN_RECT.height:
            self.rect.y = -self.rect.height
</code></pre>
    <h5>
     <a id="plane_mainpy_307">
     </a>
     ②在plane_main.py中显示背景精灵
    </h5>
    <p>
     在
     <code>
      __creat_sprites
     </code>
     方法中创建 精灵 和 精灵组
    </p>
    <pre><code>def __create_sprites(self):
    # 创建背景精灵和精灵组
    bg1 = Background("D:/My life/music/some photos/sunrise.jpg")
    bg2 = Background("D:/My life/music/some photos/sunrise.jpg")
    bg2.rect.y = -bg2.rect.height
    self.back_group = pygame.sprite.Group(bg1, bg2)
</code></pre>
    <p>
     在
     <code>
      __update_sprites
     </code>
     方法中，让 精灵组 调用 update()和draw()方法
    </p>
    <pre><code>def __update_sprites(self):
    self.back_group.update()
    self.back_group.draw(self.screen)
</code></pre>
    <h5>
     <a id="_321">
     </a>
     ③简化背景精灵的创建
    </h5>
    <p>
     精灵的
     <strong>
      初始位置
     </strong>
     的设置，由
     <strong>
      精灵自己
     </strong>
     负责，不由主程序负责。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2a55002cd855355b4dff0a993397c4b1.png#pic_center"/>
     <br/>
     初始化方法：
    </p>
    <blockquote>
     <p>
      直接指定背景图片
      <br/>
      <code>
       is_alt
      </code>
      判断是否是另一张图像
     </p>
     <blockquote>
      <p>
       <code>
        Flase
       </code>
       表示 第一张图像，需要与屏幕重合
       <br/>
       <code>
        True
       </code>
       表示 另一张图像，在屏幕的正上方
      </p>
     </blockquote>
    </blockquote>
    <p>
     继承：
    </p>
    <blockquote>
     <p>
      如果父类提供的方法不能满足子类的需求：
      <br/>
      派生一个子类
      <br/>
      在子类中针对特有的需求，重写父类方法，并且进行扩展
     </p>
    </blockquote>
    <pre><code>def __init__(self, is_alt = False):  # 默认alt为False
	#1、调用父类方法实现精灵的创建（image / rect / speed）
	super().__init__("D:/My life/music/some photos/sunrise.jpg")
	#2、判断是否是交替图像，如果是，需要设置初始位置
	if is_alt:
		self.rect.y = -self.rect.height
</code></pre>
    <p>
     由此一来，主程序的代码就可以简化为：
    </p>
    <pre><code>def __create_sprites(self):
    # 创建背景精灵和精灵组
    bg1 = Background()
    bg2 = Background(True)

    self.back_group = pygame.sprite.Group(bg1, bg2)
</code></pre>
    <h4>
     <a id="4_354">
     </a>
     （4）敌机
    </h4>
    <p>
     设计Enemy类
    </p>
    <h5>
     <a id="_356">
     </a>
     ①使用定时器添加敌机
    </h5>
    <p>
     在pygame中，可以使用
     <code>
      pygame.time.set_timer()
     </code>
     来添加
     <strong>
      定时器（每隔一段时间，去执行一些动作）
     </strong>
     。
    </p>
    <blockquote>
     <p>
      <code>
       set_timer(eventid, milliseconds)
      </code>
      。
      <br/>
      <code>
       set_timer
      </code>
      可以创建一个事件，可以在 游戏循环 的事件监听方法中捕获到该事件。
      <br/>
      第一个参数
      <strong>
       事件代号
      </strong>
      需要基于常量
      <code>
       pygame.USEREVENT
      </code>
      来指定。
     </p>
     <blockquote>
      <p>
       USERENEVT是一个整数，再增加的事件可以使用
       <code>
        USEREVENT + 1
       </code>
       指定，以此类推…
      </p>
     </blockquote>
     <p>
      第2个参数是
      <strong>
       事件触发
      </strong>
      间隔的
      <strong>
       毫秒值
      </strong>
     </p>
    </blockquote>
    <p>
     通过
     <code>
      pygame.event.get()
     </code>
     获取当前时刻所有的
     <strong>
      事件列表
     </strong>
     ；
     <br/>
     <strong>
      遍历列表
     </strong>
     并且判断
     <code>
      event.type
     </code>
     是否等于
     <code>
      eventid
     </code>
     ，如果相等，表示
     <strong>
      定时器事件
     </strong>
     发生。
     <br/>
     pygame的定时器使用套路非常固定：
    </p>
    <blockquote>
     <p>
      1、定义 定时器常量——
      <code>
       eventid
      </code>
      <br/>
      2、在初始化方法中，调用
      <code>
       set_timer
      </code>
      方法设置定时器事件
      <br/>
      3、在游戏循环中，监听定时器事件。
     </p>
    </blockquote>
    <p>
     定义事件：
     <br/>
     在
     <code>
      plane_sprites.py
     </code>
     的顶部定义
     <strong>
      事件常量
     </strong>
    </p>
    <pre><code>#创建敌机的定时器常量
CREATE_ENEMY_EVENT = pygame.USEREVENT
</code></pre>
    <h5>
     <a id="Enemy_378">
     </a>
     ②设计Enemy类
    </h5>
    <blockquote>
     <p>
      游戏启动后，
      <strong>
       每隔1秒
      </strong>
      会
      <strong>
       出现一架敌机
      </strong>
      <br/>
      每架敌机
      <strong>
       向屏幕下方飞行
      </strong>
      ，飞行的
      <strong>
       速度各不相同
      </strong>
      <br/>
      没架敌机出现的
      <strong>
       水平位置
      </strong>
      也不尽相同
      <br/>
      当敌机
      <strong>
       从屏幕下方飞出
      </strong>
      ，不会再飞回屏幕中
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1be6b3ef5fca9adb2516c9b696de0bda.png#pic_center"/>
     <br/>
     初始化方法：
    </p>
    <blockquote>
     <p>
      指定
      <strong>
       敌机图片
      </strong>
      <br/>
      <strong>
       随机
      </strong>
      敌机的初始位置和初始速度
     </p>
    </blockquote>
    <p>
     重写update()方法
    </p>
    <blockquote>
     <p>
      判断是否飞出屏幕，如果是，从
      <strong>
       精灵组
      </strong>
      删除
     </p>
    </blockquote>
    <h5>
     <a id="_392">
     </a>
     ③创建敌机
    </h5>
    <p>
     1、在
     <code>
      __creat_sprites
     </code>
     添加敌机精灵组。
    </p>
    <blockquote>
     <p>
      敌机是
      <strong>
       定时被创建的
      </strong>
      ，因此在初始化方法中，不需要创建敌机
      <br/>
      <code>
       self.enemy_group = pygame.sprite.Group()
      </code>
     </p>
    </blockquote>
    <p>
     2、在
     <code>
      __event_handler
     </code>
     创建敌机，并且添加到精灵组
    </p>
    <blockquote>
     <p>
      调用
      <strong>
       精灵组
      </strong>
      的
      <code>
       add
      </code>
      方法，可以向精灵组添加精灵
      <br/>
      <code>
       #创建敌机
      </code>
      <br/>
      <code>
       enemy = Enemy()
      </code>
      <br/>
      <code>
       #将敌机精灵添加到精灵组
      </code>
      <br/>
      <code>
       self.enemy_group.add(enemy)
      </code>
     </p>
    </blockquote>
    <p>
     3、在
     <code>
      __update_sprites
     </code>
     让
     <strong>
      敌机精灵组
     </strong>
     调用
     <code>
      update
     </code>
     和
     <code>
      draw
     </code>
     方法
    </p>
    <blockquote>
     <p>
      <code>
       self.enemy_group.update()
      </code>
      <br/>
      <code>
       self.enemy_group.draw(self.screen)
      </code>
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6d2cf1d45139dd12252fb0e0a490fde9.png#pic_center"/>
     <br/>
     可以看到敌机一架架陆续出现
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/337bf88699d368129878ee6b717dc505.png#pic_center"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0063246b89d7c076e72ce7b3ad5369ec.png#pic_center"/>
    </p>
    <h5>
     <a id="___412">
     </a>
     ④ 随机 敌机位置和速度
    </h5>
    <h6>
     <a id="_413">
     </a>
     导入模块时，建议按照以下顺序导入
    </h6>
    <blockquote>
     <p>
      官方标准模块导入
      <br/>
      第三方模块导入
      <br/>
      应用程序模块导入
     </p>
    </blockquote>
    <p>
     修改
     <code>
      plane_sprites.py
     </code>
     增加
     <code>
      random
     </code>
     的导入
    </p>
    <blockquote>
     <p>
      <code>
       import random # 官方标准模块
      </code>
     </p>
    </blockquote>
    <p>
     随机化敌机初始速度
    </p>
    <blockquote>
     <p>
      <code>
       self.speed = random.randint(1, 3) # (随机数的最小值，随机数的最大值)
      </code>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f050270721dbd8e6102f6089996c7505.png#pic_center"/>
     </p>
    </blockquote>
    <p>
     敌机从屏幕顶部缓缓进入
    </p>
    <blockquote>
     <p>
      <code>
       self.rect.bottom = 0
      </code>
     </p>
    </blockquote>
    <p>
     随机化敌机出现的水平位置
    </p>
    <blockquote>
     <p>
      <code>
       max_x = SCREEN_RECT.width - self.rect.width
      </code>
      <br/>
      <code>
       self.rect.x = random.randint(0, max_x)
      </code>
      <br/>
      #水平位置最小值为0，最大位置为“屏幕宽度-飞机宽度”
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/37c5210255bab6203dc4285ff60d7708.png#pic_center"/>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/026bde0c423cd197e034fc154ff3a6da.png#pic_center"/>
     </p>
    </blockquote>
    <h5>
     <a id="_435">
     </a>
     ⑤移出屏幕销毁敌机
    </h5>
    <p>
     敌机移出屏幕后，如果没有撞到飞机，敌机的历史生命已经终结。需要从
     <strong>
      敌机组
     </strong>
     删除，否则会造成
     <strong>
      内存浪费
     </strong>
    </p>
    <p>
     检测敌机被销毁：
     <br/>
     <code>
      __del__
     </code>
     内置方法会在对象被销毁前调用。在开发中，可以用于
     <strong>
      判断对象是否被销毁
     </strong>
    </p>
    <pre><code>def __del__(self):
	print("敌机销毁%s" %self.rect)
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b475e318976ff6744adb9c43cd09b70b.png#pic_center"/>
     <br/>
     判断敌机是否飞出屏幕，如果是，调用
     <code>
      kill()
     </code>
     方法将精灵精灵组中移出，敌机自动销毁
    </p>
    <pre><code>def update(self):
	super().update(args)

	#判断敌机是否移出屏幕
	if self.rect.y &gt;= SCREEN_RECT.height:
		#将精灵从精灵组中删除
		self.kill()
</code></pre>
    <h4>
     <a id="5_454">
     </a>
     （5）英雄飞机
    </h4>
    <p>
     游戏启动后，飞机出现在屏幕的
     <strong>
      水平中间
     </strong>
     位置，距离
     <strong>
      屏幕底部
      <code>
       120
      </code>
      像素
     </strong>
     。
     <br/>
     飞机每隔
     <code>
      0.5
     </code>
     秒发射一次子弹，每次
     <strong>
      连发三枚子弹
     </strong>
     。
     <br/>
     飞机默认不会移动，需要通过
     <code>
      左 / 右
     </code>
     方向键，控制
     <strong>
      英雄
     </strong>
     在水平方向移动。
    </p>
    <h4>
     <a id="6_459">
     </a>
     （6）子弹需求
    </h4>
    <p>
     <strong>
      子弹
     </strong>
     从
     <strong>
      英雄飞机
     </strong>
     的正上方发射
     <strong>
      沿直线
     </strong>
     向
     <strong>
      上方
     </strong>
     飞行
     <br/>
     <strong>
      飞出屏幕后
     </strong>
     ，需要从
     <strong>
      精灵组
     </strong>
     中删除
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5c6831dae1ee7b6fa708bec3bcb2cfed.png#pic_center"/>
    </p>
    <p>
     在
     <code>
      plane_sprites
     </code>
     新建
     <code>
      Hero
     </code>
     类
    </p>
    <blockquote>
     <p>
      初始化方法
     </p>
     <blockquote>
      <p>
       指定
       <strong>
        英雄图片
       </strong>
       <br/>
       <strong>
        初始速度=0
       </strong>
       ——英雄默认静止不动
       <br/>
       定义
       <code>
        bullets
       </code>
       子弹精灵组 保存子弹精灵
      </p>
     </blockquote>
     <p>
      重写update()方法
     </p>
     <blockquote>
      <p>
       英雄需要
       <strong>
        水平移动
       </strong>
       <br/>
       并且需要保证不能
       <strong>
        移出屏幕
       </strong>
       <br/>
       增加
       <code>
        bullets
       </code>
       属性，记录所有
       <strong>
        子弹精灵
       </strong>
       <br/>
       增加
       <code>
        file
       </code>
       方法，用于发射子弹
      </p>
     </blockquote>
    </blockquote>
    <p>
     center
    </p>
    <blockquote>
     <p>
      centerx = x + 0.5 * width # x的中心点
      <br/>
      centery = y + 0.5 * height # y的中心点
      <br/>
      bottom = y + height
     </p>
    </blockquote>
    <h5>
     <a id="_481">
     </a>
     ①绘制英雄
    </h5>
    <p>
     在
     <code>
      __creat_sprites
     </code>
     添加 英雄精灵 和 英雄精灵组
    </p>
    <blockquote>
     <p>
      英雄需要单独定义成属性，因为后续要针对 英雄 做 碰撞检测 以及发射子弹
     </p>
    </blockquote>
    <blockquote>
     <p>
      #创建英雄的精灵和 英雄精灵组
      <br/>
      self.hero = Hero()
      <br/>
      self.hero_group = pygame.sprite.Group(self.hero)
     </p>
    </blockquote>
    <p>
     在
     <code>
      __update_sprites
     </code>
     ，让 英雄精灵组 调用 update和 draw 方法。
    </p>
    <blockquote>
     <p>
      self.hero_group.update()
      <br/>
      self.hero_group.draw(self.screen)
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/413a11a1de628b70d657b23f11dcb23b.png#pic_center"/>
    </p>
    <h5>
     <a id="_495">
     </a>
     ②移动英雄位置
    </h5>
    <p>
     在pygame中针对 键盘按键的捕获，有两种方式：
    </p>
    <p>
     第一种方式：
    </p>
    <blockquote>
     <p>
      判断
      <code>
       event.type == pygame.KEYDOWN
      </code>
     </p>
    </blockquote>
    <pre><code>elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
	print("向右移动...")
</code></pre>
    <blockquote>
     <p>
      缺点：如果用户按住不放，默认只按了一次。
     </p>
    </blockquote>
    <p>
     第二种方式：
    </p>
    <blockquote>
     <p>
      首先使用
      <code>
       pygame.key.get_pressed()
      </code>
      返回 所有
      <strong>
       按键元组
      </strong>
      <br/>
      通过
      <strong>
       键盘常量
      </strong>
      ，判断元组中某一个键是否被按下——如果被按下，对应数值为
      <code>
       1
      </code>
     </p>
    </blockquote>
    <pre><code>keys_pressed = pygame.key.get_pressed()
#判断是否按下了方向键
if keys_pressed[pygame.K_RIGHT]:
	print("持续向右移动...")
</code></pre>
    <blockquote>
     <p>
      优点：可以
      <strong>
       按住键盘不放
      </strong>
      ，实现
      <strong>
       持续移动
      </strong>
      。
     </p>
    </blockquote>
    <p>
     <strong>
      在
      <code>
       Hero
      </code>
      类中重写
      <code>
       update
      </code>
      方法
     </strong>
    </p>
    <blockquote>
     <p>
      用速度
      <code>
       speed
      </code>
      和英雄
      <code>
       rect.x
      </code>
      进行叠加
      <br/>
      不需要调用父类方法——父类方法只是实现了单纯的垂直运动
     </p>
    </blockquote>
    <pre><code>def update(self):
	self.rect.x += self.speed
</code></pre>
    <p>
     在
     <code>
      __event_handler
     </code>
     方法中根据
     <strong>
      左右方向键
     </strong>
     设置英雄的
     <strong>
      速度
     </strong>
    </p>
    <blockquote>
     <p>
      向右 =&gt;
      <code>
       speed = 2
      </code>
     </p>
    </blockquote>
    <pre><code>self.hero.speed = 2
</code></pre>
    <p>
     向左 =&gt;
     <code>
      speed = -2
     </code>
    </p>
    <pre><code>elif keys_pressed[pygame.K_LEFT]:
	self.hero.speed = -2
</code></pre>
    <p>
     其他 =&gt;
     <code>
      speed = 0
     </code>
    </p>
    <pre><code>else:
	self.hero.speed = 0
</code></pre>
    <h5>
     <a id="_540">
     </a>
     ③控制英雄的移动边界
    </h5>
    <p>
     <code>
      right = x + width
     </code>
     ，利用
     <code>
      right
     </code>
     属性可以非常容易地针对右侧设置精灵位置。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/58f22771dea1a0df7a2f03896154bfac.png#pic_center"/>
     <br/>
     #控制英雄的移动边界
     <br/>
     if self.rect.x &lt; 0:
     <br/>
     self.rect.x = 0
     <br/>
     elif self.rect.right &gt; SCREEN_RECT.right:
     <br/>
     self.rect.right = SCREEN_RECT.right
    </p>
    <h5>
     <a id="_549">
     </a>
     ④发射子弹
    </h5>
    <p>
     回顾 “四（4）①”的知识点
     <br/>
     <code>
      pygame
     </code>
     的定时器使用套路非常固定：
    </p>
    <blockquote>
     <p>
      1、定义 定时器常量——
      <code>
       eventid
      </code>
      <br/>
      2、在初始化方法中，调用
      <code>
       set_timer
      </code>
      方法设置定时器事件
      <br/>
      3、在游戏循环中，监听定时器事件。
     </p>
    </blockquote>
    <p>
     第一步：
     <br/>
     在
     <code>
      Hero
     </code>
     中定义
     <code>
      fire
     </code>
     方法
    </p>
    <pre><code>def fire(self):
	print("发射子弹")
</code></pre>
    <p>
     第二步：
    </p>
    <pre><code>#英雄发射子弹事件
HERO_FIRE_EVENT = pygame.USEREVENT + 1
</code></pre>
    <p>
     第三步：
    </p>
    <pre><code>pygame.time.set_timer(HERO_FIRE_EVENT, 500)  # 500ms
</code></pre>
    <p>
     第四步：
    </p>
    <pre><code>elif event.type == HERO_FIRE_EVENT:
   self.hero.fire()
</code></pre>
    <h5>
     <a id="_576">
     </a>
     ⑤定义子弹类
    </h5>
    <p>
     Bullet
     <br/>
     初始化方法：
    </p>
    <blockquote>
     <p>
      指定子弹图片
      <br/>
      初始速度 = -2——实现子弹向
      <strong>
       上方
      </strong>
      飞行
     </p>
    </blockquote>
    <p>
     重写update()方法
    </p>
    <blockquote>
     <p>
      判断是否飞出屏幕，如果是，从
      <strong>
       精灵组
      </strong>
      删除
     </p>
    </blockquote>
    <p>
     定义子弹类
     <br/>
     在
     <code>
      plane_sprites
     </code>
     新建
     <code>
      Bullet
     </code>
     继承自
     <code>
      GameSprite
     </code>
     <br/>
     重写 初始化方法，直接指定 图片名称，并且设置初始速度
     <br/>
     重写
     <code>
      update()
     </code>
     方法，判断子弹 飞出屏幕从精灵组删除
    </p>
    <pre><code>class Bullet(GameSprite):
	"""子弹精灵"""	
	def __init__(self):

		# 调用父类方法，指定 图片名称，并且设置初始速度
		super().__init__("D:/My life/music/some photos/bullet.png", -2)
		
	def update(self):

		# 调用父类方法，让子弹沿垂直方向飞行
		super().update()
		# 判断子弹是否飞出屏幕
		if self.rect.bottom &lt; 0:
			self.kill()
		
	def __del__(self):
		print("子弹被销毁...")
</code></pre>
    <h5>
     <a id="_609">
     </a>
     ⑥发射子弹
    </h5>
    <p>
     1、在
     <code>
      Hero
     </code>
     的
     <strong>
      初始化方法
     </strong>
     中创建
     <strong>
      子弹精灵组
     </strong>
     属性
     <br/>
     #3、创建子弹精灵组
     <br/>
     self.bullets = pygame.sprite.Group()
    </p>
    <p>
     2、修改
     <code>
      plane_main.py
     </code>
     的
     <code>
      __update_sprites
     </code>
     方法，让
     <strong>
      子弹精灵组
     </strong>
     调用
     <code>
      update
     </code>
     和
     <code>
      draw
     </code>
     方法
    </p>
    <pre><code>self.hero.bullets.update()
self.hero.bullets.draw(self.screen)
</code></pre>
    <p>
     3、实现
     <code>
      fire()
     </code>
     方法
    </p>
    <pre><code># 1、创建子弹精灵
bullet = Bullet()

# 2、设置初始位置——在英雄的正上方
bullet.rect.bottom = self.rect.y - 20
bullet.rect.centerx = self.rect.centerx

# 3、将 **子弹** 添加到精灵组
self.bullet.add(bullet)
</code></pre>
    <h5>
     <a id="_631">
     </a>
     ⑦一次发射三枚子弹
    </h5>
    <p>
     修改
     <code>
      fire
     </code>
     ，一次发射三枚子弹
    </p>
    <pre><code>for i in (0, 1, 2):

	# 1、创建子弹精灵
    bullet = Bullet()

    # 2、设置初始位置——在英雄的正上方
    bullet.rect.bottom = self.rect.y - i * 20
    bullet.rect.centerx = self.rect.centerx

    # 3、将 子弹 添加到精灵组
    self.bullets.add(bullet)
</code></pre>
    <h5>
     <a id="_645">
     </a>
     ⑧碰撞检测
    </h5>
    <p>
     了解碰撞检测的方法：
     <br/>
     方法一：pygame.sprite.groupcollide()
    </p>
    <blockquote>
     <p>
      两个精灵组 中 所有的精灵 的 碰撞检测
      <br/>
      <code>
       groupcollide(group1, group2, dokill1, dokill2, collided = None)
      </code>
     </p>
     <blockquote>
      <p>
       如果将
       <code>
        dokill
       </code>
       设置为
       <code>
        True
       </code>
       ，则 发生碰撞的精灵将被自动移除。
       <br/>
       <code>
        collided
       </code>
       参数是用于
       <strong>
        计算碰撞的回调函数
       </strong>
       。如果没有指定，则每个精灵必须有一个
       <code>
        rect
       </code>
       属性。
      </p>
     </blockquote>
    </blockquote>
    <p>
     方法二：pygame.sprite.spritecollie()
    </p>
    <blockquote>
     <p>
      判断 某个精灵 和 指定精灵组 中的精灵的碰撞
      <br/>
      <code>
       spritecollide(sprite, froup, dokill, collided = None)
      </code>
     </p>
     <blockquote>
      <p>
       如果将
       <code>
        dokill
       </code>
       设置为
       <code>
        True
       </code>
       ，则 指定精灵组 中 发生碰撞的精灵将被自动移除。
       <br/>
       <code>
        collided
       </code>
       参数是用于
       <strong>
        计算碰撞的回调函数
       </strong>
       。如果没有指定，则每个精灵必须有一个
       <code>
        rect
       </code>
       属性。
       <br/>
       返回
       <strong>
        精灵组
       </strong>
       中 跟 精灵 发生碰撞的
       <strong>
        精灵列表
       </strong>
      </p>
     </blockquote>
    </blockquote>
    <pre><code>def __check_collide(self):

	#1、子弹摧毁敌机
	pygame.sprite.groupcollide(self.hero.bullets, self.enemy_group, True, True)
	#2、敌机撞毁英雄
	enemies = pygame.sprite.spritecollide(self.hero, self.enemyy_group, True)
	#判断列表是否有内容
	if len(enemies) &gt;0:
		#让英雄牺牲
		self.hero.kill()
		#结束游戏
		PlaneGame.__game_over()
</code></pre>
    <h2>
     <a id="_673">
     </a>
     五、游戏设计完成，运行图片
    </h2>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/02942be977102c63abbd72f3d9582c5a.png#pic_center"/>
    </p>
    <hr/>
    <p>
     飞机大战游戏共包含两个python文件：
     <code>
      plane_main.py
     </code>
     和
     <code>
      plane_sprites.py
     </code>
    </p>
    <h2>
     <a id="plane_mainpy_680">
     </a>
     附录一：plane_main.py
    </h2>
    <pre><code>import pygame
pygame.init()  # 这行代码可以解决“pygame is not initialized”问题
from plane_sprites import *


class PlaneGame(object):
    def __init__(self):
        print("游戏初始化")
        # 1、创建游戏的窗口
        self.screen = pygame.display.set_mode(SCREEN_RECT.size)
        # 2、创建游戏的时钟
        self.clock = pygame.time.Clock()
        # 3、调用私有方法，精灵和精灵组的创建
        self.__create_sprites()
        # 4、设置定时器事件-创建敌机 1s
        pygame.time.set_timer(CREATE_ENEMY_EVENT, 1000)  # 1000ms
        pygame.time.set_timer(HERO_FIRE_EVENT, 500)  # 500ms


    def __create_sprites(self):
        # 创建背景精灵和精灵组
        bg1 = Background()
        bg2 = Background(True)

        self.back_group = pygame.sprite.Group(bg1, bg2)

        # 创建敌机的精灵组
        self.enemy_group = pygame.sprite.Group()
        # 创建英雄的精灵和 英雄精灵组
        self.hero = Hero()
        self.hero_group = pygame.sprite.Group(self.hero)

    def start_game(self):
        print("游戏开始")
        while True:
            # 1、设置刷新频率
            self.clock.tick(FRAME_PER_SECOND)
            # 2、事件监听
            self.__event_handler()
            # 3、碰撞检测
            self.__check_collide()
            # 4、更新 / 绘制精灵组
            self.__update_sprites()
            # 5、更新显示
            pygame.display.update()

    # 事件监听
    def __event_handler(self):
        for event in pygame.event.get():

            # 判断是否退出游戏
            if event.type == pygame.QUIT:
                PlaneGame.__game_over()
            elif event.type == CREATE_ENEMY_EVENT:
                # print("敌机出场...")
                # 创建敌机
                enemy = Enemy()
                # 将敌机精灵添加到精灵组
                self.enemy_group.add(enemy)
            elif event.type == HERO_FIRE_EVENT:
                self.hero.fire()

            # elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
            #     print("向右移动...")

        # 首先使用`pygame.key.get_pressed()`返回所有按键元组
        # 通过键盘常量，判断元组中某一个键是否被按下——如果被按下，对应数值为`1`
        keys_pressed = pygame.key.get_pressed()
        # 判断是否按下了方向键
        if keys_pressed[pygame.K_RIGHT]:
            # print("持续向右移动...")
            self.hero.speed = 2
        elif keys_pressed[pygame.K_LEFT]:
            self.hero.speed = -2
        else:
            self.hero.speed = 0


    # 碰撞
    def __check_collide(self):
        # 1、子弹摧毁敌机
        pygame.sprite.groupcollide(self.hero.bullets, self.enemy_group, True, True)
        # 2、敌机撞毁英雄
        enemies = pygame.sprite.spritecollide(self.hero, self.enemy_group, True)
        # 判断列表是否有内容
        if len(enemies) &gt; 0:
            # 让英雄牺牲
            print("英雄牺牲了")
            self.hero.kill()
            # 结束游戏
            PlaneGame.__game_over()

    def __update_sprites(self):
        self.back_group.update()
        self.back_group.draw(self.screen)

        self.enemy_group.update()
        self.enemy_group.draw(self.screen)

        self.hero_group.update()
        self.hero_group.draw(self.screen)

        self.hero.bullets.update()
        self.hero.bullets.draw(self.screen)

    @staticmethod
    def __game_over():
        print("游戏结束")
        pygame.quit()
        exit()


if __name__ == '__main__':
    # 创建游戏对象
    game = PlaneGame()
    # 启动游戏
    game.start_game()
</code></pre>
    <h2>
     <a id="plane_spritespy_800">
     </a>
     附录二：plane_sprites.py
    </h2>
    <pre><code>import random  # 官方标准模块

import pygame

SCREEN_RECT = pygame.Rect(0, 0, 480, 700)
FRAME_PER_SECOND = 60

# 创建敌机的定时器常量
CREATE_ENEMY_EVENT = pygame.USEREVENT
# 英雄发射子弹事件
HERO_FIRE_EVENT = pygame.USEREVENT + 1


class GameSprite(pygame.sprite.Sprite):
    # 飞机大战游戏精灵

    def __init__(self, image_name, speed=1):
        # 调用父类的初始化方法
        super().__init__()

        # 定义对象的属性
        self.image = pygame.image.load(image_name)
        self.rect = self.image.get_rect()
        self.speed = speed

    def update(self):
        # 在屏幕的绘制方向移动
        self.rect.y += self.speed


class Background(GameSprite):
    """游戏背景精灵"""

    def __init__(self, is_alt=False):  # 默认alt为False
        # 1、调用父类方法实现精灵的创建（image / rect / speed）
        super().__init__("D:/My life/music/some photos/sunrise.jpg")
        # 2、判断是否是交替图像，如果是，需要设置初始位置
        if is_alt:
            self.rect.y = -self.rect.height

    def update(self):
        # 1、调用父类的方法实现
        super().update()
        # 2、判断是否移出屏幕，如果移出屏幕，将图片移动到正上方
        if self.rect.y &gt;= SCREEN_RECT.height:
            self.rect.y = -self.rect.height


class Enemy(GameSprite):
    """敌机精灵"""

    def __init__(self):
        # 1、调用父类方法，创建敌机精灵，同时指定敌机图片
        super().__init__("D:/My life/music/some photos/enemyplane.png")

        # 2、指定敌机的初始位置
        self.speed = random.randint(1, 3)  # (随机数的最小值，随机数的最大值)
        # 3、指定敌机的初始速度
        self.rect.bottom = 0

        max_x = SCREEN_RECT.width - self.rect.width
        self.rect.x = random.randint(0, max_x)

    def update(self):
        # 1、调用父类方法，保持垂直方向的飞行
        super().update()
        # 2、判断是否飞出屏幕，如果是，从 **精灵组** 删除
        if self.rect.y &gt;= SCREEN_RECT.height:
            # print("飞出屏幕，需要从精灵组中删除...")
            # 调用kill()方法将精灵精灵组中移出，敌机自动销毁
            self.kill()

    def __del__(self):
        # print("敌机销毁成功%s" % self.rect)
        pass


class Hero(GameSprite):
    """英雌精灵"""

    def __init__(self):
        # 1、调用父类方法，设置image和速度
        super().__init__("D:/My life/music/some photos/plane.png", 0)
        # 2、设置英雌的初始位置
        self.rect.centerx = SCREEN_RECT.centerx
        self.rect.bottom = SCREEN_RECT.bottom - 120

        # 3、创建子弹精灵组
        self.bullets = pygame.sprite.Group()

    def update(self):
        self.rect.x += self.speed

        # 控制英雄的移动边界
        if self.rect.x &lt; 0:
            self.rect.x = 0
        elif self.rect.right &gt; SCREEN_RECT.right:
            self.rect.right = SCREEN_RECT.right

    def fire(self):
        print("发射子弹")
        for i in (0, 1, 2):
            # 1、创建子弹精灵
            bullet = Bullet()

            # 2、设置初始位置——在英雄的正上方
            bullet.rect.bottom = self.rect.y - i * 20
            bullet.rect.centerx = self.rect.centerx

            # 3、将 子弹 添加到精灵组
            self.bullets.add(bullet)


class Bullet(GameSprite):
    """子弹精灵"""

    def __init__(self):
        # 调用父类方法，指定 图片名称，并且设置初始速度
        super().__init__("D:/My life/music/some photos/bullet.png", -2)

    def update(self):
        # 调用父类方法，让子弹沿垂直方向飞行
        super().update()
        # 判断子弹是否飞出屏幕
        if self.rect.bottom &lt; 0:
            self.kill()

    def __del__(self):
        # print("子弹被销毁...")
        pass
</code></pre>
    <h2>
     <a id="_932">
     </a>
     附录三：飞机大战设计图片
    </h2>
    <p>
     “英雄”“敌机”“子弹”均为PNG格式——便于设置透明背景。
     <br/>
     英雄：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5c3208ae9c97e83674d3731dbe9450c0.png#pic_center"/>
     <br/>
     敌机：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7eaa7be6f7776bf08c6d61c4261f22d2.png#pic_center"/>
     <br/>
     子弹：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fdf7bd1b709d0ed84c89dc60f51717fc.png#pic_center"/>
     <br/>
     背景图片：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5a0ba841b0665fb9daa82291478e5ec1.jpeg#pic_center"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


