---
layout: post
title: "C语言-一步步教你做一个带有图形界面的冒险小游戏"
date: 2022-09-22 20:43:18 +0800
description: "本文没有繁难的代码，所以很适合想做游戏但不知道如何做游戏的同学食用~_c语言开发图形化游戏"
keywords: "c语言开发图形化游戏"
categories: ['C']
tags: ['开发语言', '后端', 'C']
artid: "122593251"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122593251
    alt: "C语言-一步步教你做一个带有图形界面的冒险小游戏"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言 一步步教你做一个带有图形界面的冒险小游戏
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p id="main-toc">
      <strong>
       目录
      </strong>
     </p>
     <p id="%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;">
      <a href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D" rel="nofollow">
       简要介绍
      </a>
     </p>
     <p id="%E6%B8%B8%E6%88%8F%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%26%E4%B8%BB%E5%BE%AA%E7%8E%AF-toc" style="margin-left:40px;">
      <a href="#%E6%B8%B8%E6%88%8F%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%26%E4%B8%BB%E5%BE%AA%E7%8E%AF" rel="nofollow">
       游戏基本框架&amp;主循环
      </a>
     </p>
     <p id="%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2-toc" style="margin-left:40px;">
      <a href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2" rel="nofollow">
       如何在控制台实现图形界面
      </a>
     </p>
     <p id="%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%8D%E6%96%AD%E7%9A%84%E6%9B%B4%E6%96%B0-toc" style="margin-left:40px;">
      <a href="#%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%8D%E6%96%AD%E7%9A%84%E6%9B%B4%E6%96%B0" rel="nofollow">
       实现游戏不断的更新
      </a>
     </p>
     <p id="%E6%B6%88%E9%99%A4%E9%97%AA%E5%B1%8F-toc" style="margin-left:40px;">
      <a href="#%E6%B6%88%E9%99%A4%E9%97%AA%E5%B1%8F" rel="nofollow">
       消除闪屏
      </a>
     </p>
     <p id="%E6%9C%80%E5%90%8E%E5%AF%B9%E4%B8%80%E9%81%8D%E4%BB%A3%E7%A0%81~-toc" style="margin-left:40px;">
      <a href="#%E6%9C%80%E5%90%8E%E5%AF%B9%E4%B8%80%E9%81%8D%E4%BB%A3%E7%A0%81~" rel="nofollow">
       最后对一遍代码~
      </a>
     </p>
    </blockquote>
    <h3 id="%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D">
     简要介绍
    </h3>
    <p>
     本文没有繁难的代码，所以很适合想做游戏但不知道如何做游戏的同学食用~
    </p>
    <h3 id="%E6%B8%B8%E6%88%8F%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%26%E4%B8%BB%E5%BE%AA%E7%8E%AF">
     <strong>
      游戏基本框架&amp;主循环
     </strong>
    </h3>
    <p>
     要想做一个游戏，首先要弄清楚游戏的基本框架：
    </p>
    <blockquote>
     <p>
      <img alt="" height="668" src="https://i-blog.csdnimg.cn/blog_migrate/832125dd6615bd0ee71a6708f8523df8.png" width="1200"/>
     </p>
     <p>
      其中，
     </p>
     <p>
      Model代表游戏模型，存储着游戏的所有信息；
     </p>
     <p>
      Update每时每刻都在根据Model的自身状态来对Model进行更新；
     </p>
     <p>
      Handle是根据外界输入来调整Model的信息；
     </p>
     <p>
      Show是对Model的信息进行翻译，并呈现在玩家眼前；
     </p>
    </blockquote>
    <p>
     根据以上的基本理念，我们可以这样写：
    </p>
    <pre><code class="language-cpp">int main()
{
    //先处理用户的输入，并更改Model的数据
	handle();
    //在根据Model自身的数据来对Model进行更新
	update();
    //最后将Model的内容提取并展示出来
	show();

	handle();
	update();
	show();

	handle();
	update();
	show();

	...
    ...
}</code></pre>
    <p>
     当然，肯定不能就一直这样重复写，为此，我们需要构造一个main loop来不断读取用户输入，更新Model信息，并将信息翻译展示到玩家面前。
    </p>
    <p>
     为了实现每秒循环一定次数的效果，我们需要#include &lt;time.h&gt;来构造主循环，具体如下：
    </p>
    <pre><code class="language-cpp">#include &lt;time.h&gt;
#define FPS 4

int main()
{
	clock_t t1=0,t2=0;
	while (1) {
		t2 = clock();
		if (t2-t1 &gt; CLOCKS_PER_SEC*1.0/FPS) {
			t1 = t2;

			handle();
			update();
			show();

		}
	}
}</code></pre>
    <p>
     其中，除了三个基本函数handle，update，show外都是main loop的内容,这样便可以实现按一定的帧率(FPS)来进行游戏循环。
    </p>
    <p>
     但是，一款游戏至少要做到随时响应玩家的输入，而现在的代码每隔1.0/FPS的时间才会响应一次玩家输入，因此我们需要多加这样几行代码：
    </p>
    <pre><code class="language-cpp">#include &lt;conio.h&gt;

char key;

int main()
{
	clock_t t1=0,t2=0;
	while (1) {
		t2 = clock();

		if (_kbhit()) key = _getch();

		if (t2-t1 &gt; CLOCKS_PER_SEC*1.0/FPS) {
			t1 = t2;

			handle();
			update();
			show();

		}
	}
}</code></pre>
    <p>
     通过声明一个全局变量char key，同时又用if (_kbhit()) key = _getch()来每时每刻响应用户输入，如有输入便将用户的按键值传给key，这样handle所处理的内容便只是key的值。
    </p>
    <p>
     OK，现在基本的东西已经搞好了，下面就可以随意发挥了！
    </p>
    <h3 id="%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2">
     如何在控制台实现图形界面
    </h3>
    <p>
     显然，我们并不打算去制作一款3D游戏(而且俺也不会啊(≧﹏ ≦))，而制作一款2D平面游戏的话，我们只需要一张画布即可。
    </p>
    <blockquote>
     <p>
      首先，声明一块长宽固定的二维数组，将其当作画布(screen)，然后构造一种结构类型作为演员(Actor)，这样，游戏的Model就只需要存储每一位演员的样子和位置，再在需要show的时候把这些演员给渲染到screen上，最后把screen展示给玩家看即可。
     </p>
    </blockquote>
    <pre><code class="language-cpp">#define WIDTH 100
#define HEIGHT 40

typedef struct _actor{
	int width;    //演员的宽度
	int height;    //演员的高度
	char** image;    //指向演员的图形
	int x;	//最左侧的位置
	int y;	//最顶部的位置
} Actor;

char screen[HEIGHT][WIDTH+1];

Actor boy; //创建一个名为boy的演员

int main()
{
    ...
    ...
}</code></pre>
    <p>
     现在，我们有一块画布宽为WIDTH+1，高为HEIGHT，之所以宽要加1，是想让每一行的最后一个字符存储的是'\n'，这样在show的时候，我们可以先赋值screen[HEIGHT-1][WIDTH] = '\0'，再直接把整块画布以'%s'的格式printf出来(是不是很棒的一个小技巧~)。
    </p>
    <p>
     但是，相信大家已经注意到了，screen，key，boy这些全局变量在声明之后都还没有进行初始化，所以我们有必要统一地在一个函数里面进行全局变量的初始化。
    </p>
    <pre><code class="language-cpp">#include &lt;string.h&gt;//由于用到了strlen函数

void init(void)
{
    for (int i = 0; i&lt;HEIGHT; i++) screen[i][WIDTH] = '\n';
	key = '\0';
    static char* image_boy[] = 
    //加static是为了保证离开init函数后,boy的图像依旧会被保护
	   {"  ~@~  ",
		" /BOY\\ ",
		"~ ### ~",
		" _/ \\_ "};
	boy = (Actor){.x=2,.y=4,.width=strlen(image_boy[0]),.height=4,.image = image_boy};
}

int main()
{
    init();
    //main loop ...
{<!-- --></code></pre>
    <blockquote>
     <p>
      最后运行的效果如下：(当然，现在show()还没有写好，所以你还看不见~(￣▽￣)~*)
     </p>
     <p>
      <img alt="" height="222" src="https://i-blog.csdnimg.cn/blog_migrate/9aeb4298b2abfeeab89633fbc226252d.png" width="244"/>
     </p>
    </blockquote>
    <p>
     然后，为了能尽快看到效果，我们先把show()给写出来。(ヾ(•ω•`)o)
    </p>
    <blockquote>
     <p>
      show()应该包含两个部分：render()以及draw()。render即渲染，把演员给誊到画布上，draw即显示，把画布给玩家显示出来。
     </p>
    </blockquote>
    <pre><code class="language-cpp">void show(void);
    void render(void);
        void clear(void);
        void load(Actor* actor);
    void draw(void);

void show(void)
{
	render();//渲染
    system("cls");//清空控制台内容
	draw();//显示
}

void render(void)
{
	clear();//先把画布弄干净
	load(&amp;boy);//把boy誊上画布
}

void clear(void)
{
	for (int i = 0; i&lt; HEIGHT; i++) {
		for (int j = 0; j &lt; WIDTH; j ++) {
			screen[i][j] = ' ';//用' '填充画布
		}
	}
}

void load(Actor* actor)
//传入actor的指针，而非actor本身，传输速度更快
{
	for (int i = 0; i&lt;actor-&gt;height; i++) {
		for (int j = 0; j&lt;actor-&gt;width; j++) {
			if (actor-&gt;image[i][j] != ' ') { 
                //if条件的添加，使得boy的图片像是png图像一样，有透明像素
				screen[actor-&gt;y+i][actor-&gt;x+j] = actor-&gt;image[i][j];
			}
		}
	}
}

void draw(void)
{
    
	screen[HEIGHT-1][WIDTH] = '\0';
	printf("%s\n",screen);
}</code></pre>
    <p>
     好了！现在你也能看到小boy了，是不是非常奈斯~
    </p>
    <p>
     最后我们对一下代码，看看是不是一样的：
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt;

#define FPS 4
#define WIDTH 100
#define HEIGHT 40

typedef struct _actor{
	int width;
	int height;
	char** image;
	int x;
	int y;
} Actor;

char screen[HEIGHT][WIDTH+1];
char key;
Actor boy;

void init(void);

void handle(void);

void update(void);

void show(void);
	void render(void);
		void clear(void);
		void load(Actor* actor);
	void draw(void);


int main()
{
	init();

	clock_t t1=0,t2=0;
	while (1) {
		t2 = clock();

		if (_kbhit()) key = _getch();

		if (t2-t1 &gt; CLOCKS_PER_SEC*1.0/FPS) {
			t1 = t2;

			handle();
			update();
			show();

		}
	}
}


void init(void)
{
	for (int i = 0; i&lt;HEIGHT; i++) screen[i][WIDTH] = '\n';
	key = '\0';
	static char* image_boy[] =
	   {"  ~@~  ",
		" /BOY\\ ",
		"~ ### ~",
		" _/ \\_ "};
	boy = (Actor){.x=2,.y=4,.width=strlen(image_boy[0]),.height=4,.image = image_boy};
}

void handle(void)
{
}

void update(void)
{
}

void show(void)
{
	render();
	system("cls");
	draw();
}

void render(void)
{
	clear();
	load(&amp;boy);
}

void clear(void)
{
	for (int i = 0; i&lt; HEIGHT; i++) {
		for (int j = 0; j &lt; WIDTH; j ++) {
			screen[i][j] = ' ';
		}
	}
}

void load(Actor* actor)
{
	for (int i = 0; i&lt;actor-&gt;height; i++) {
		for (int j = 0; j&lt;actor-&gt;width; j++) {
			if (actor-&gt;image[i][j] != ' ') {
				screen[actor-&gt;y+i][actor-&gt;x+j] = actor-&gt;image[i][j];
			}
		}
	}
}

void draw(void)
{
	screen[HEIGHT-1][WIDTH] = '\0';
	printf("%s\n",screen);
}</code></pre>
    <h3 id="%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%8D%E6%96%AD%E7%9A%84%E6%9B%B4%E6%96%B0">
     实现游戏不断的更新
    </h3>
    <p>
     现在，我们只剩下handle和update没有写了，之所以最后写，是因为这两个函数是十分灵活的，完全取决于你的游戏内容。
    </p>
    <p>
     那我就写一个我想的故事吧(。・ω・。)
    </p>
    <p>
     先介绍一下所有参演角色：
    </p>
    <pre><code class="language-cpp">static char* image_boy[] =
   {"  ~@~  ",
	" /BOY\\ ",
	"~ ### ~",
	" _/ \\_ "};
boy = (Actor){.x=4,.y=22,.width=strlen(image_boy[0]),.height=4,.image = image_boy};
static char* image_bed[] =
   {"|                             |",
	"|                             |",
	"+#############################+",
	"|  |__|                       |",
	"|  |__|                       |",
	"|  |__|                       |",
	"|  |__|                       |",
	"|  |__|                       |",
	"|  |__|                       |",
	"|  |__|                       |",
	"|  |__|                       |",
	"+#############################+",
	"|                             |",
	"|                             |"};
bed = (Actor){.x=50,.y=10,.width=strlen(image_bed[0]),.height=14,.image=image_bed};
static char* image_guard[] =
   {"!    @    T",
	"*~~GUARD~~+",
	"   \\###/  |",
	"   /###\\  |",
	"   L   L  |"};
guard = (Actor){.x=65,.y=16,.width=strlen(image_guard[0]),.height=5,.image = image_guard};
static char* image_ground[] =
   {"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"};
ground_1 = (Actor){.x=0,.y=30,.width=strlen(image_ground[0]),.height=1,.image=image_ground};
ground_2 = (Actor){.x=12,.y=23,.width=strlen(image_ground[0]),.height=1,.image=image_ground};</code></pre>
    <p>
     效果：
    </p>
    <p>
     <img alt="" height="1008" src="https://i-blog.csdnimg.cn/blog_migrate/ebcbd4528f1dec8796a5b978f0e38207.png" width="1200"/>
    </p>
    <p>
     对了，还要注意一件事情，就是我们定义的结构Actor还是比较简陋的，因为角色可能有很多状态，比如说，我可以搞一个叫做Monster的结构，在Actor的基础上加入血量，等级，防御力，状态等等内容，然后可以在初始化的时候声明出Monster许多的形态，比如受伤，愉悦等等。
    </p>
    <p>
     然后就要写handle和update了，，，
    </p>
    <p>
     好累，，写一整天了教程了，能不能赏一个赞再看(′д｀ )…卑微新人还没有被赞过呢...感谢~~
    </p>
    <p>
     ✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
    </p>
    <pre><code class="language-cpp">void handle(void)
{
	switch (key) {
		case 'w':
			if (boy.y &gt; 20) {
				boy.y --;
			} break;
		case 'a':
			if (boy.x &gt; 0) {
				boy.x --;
			} break;
		case 's':
			if (boy.y &lt; 26) {
				boy.y ++;
			} break;
		case 'd':
			if (boy.x &lt; 90) {
				boy.x ++;
			} break;
	}
	key = '\0';
}

void update(void)
{
	if (boy.x &gt;= guard.x-boy.width &amp;&amp; boy.x &lt;= guard.x+guard.width) {
        //boy进入guard的攻击范围
		guard.y += 2;//冲撞
		if (boy.y &lt;= guard.y+guard.height) {
			//boy被撞到了
			static char* image_boy[] =
			   {"   ~www",
				" (&gt;_&lt;) ",
				" ~###~ ",
				"  / \\  "};
			boy.image = image_boy;//更换表情
			boy.x -= 10;//被撞飞
		}
	}
}</code></pre>
    <p>
     当然啦，这个update写的很简单，所以游戏也很简单，如果可以的话，建议你也写一个自己的故事，然后自己设计一下角色图片，比如之前我做的第一个图形小游戏： （这个小游戏剧情也有一百多行呢~）
    </p>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/blog_migrate/a718cb307640d9a0f1bada3b36575850.png" width="346">
      <img alt="" height="250" src="https://i-blog.csdnimg.cn/blog_migrate/d4e093f2edfc2964859cc8643b24ac40.png" width="324"/>
     </img>
    </p>
    <p>
     <img alt="" height="241" src="https://i-blog.csdnimg.cn/blog_migrate/4a2c11aef86c9053ebb02c01eb6cfc55.png" width="329">
      <img alt="" height="241" src="https://i-blog.csdnimg.cn/blog_migrate/68827b1da320e7b81f32ca18846c2528.png" width="338"/>
     </img>
    </p>
    <p>
    </p>
    <h3 id="%E6%B6%88%E9%99%A4%E9%97%AA%E5%B1%8F">
     消除闪屏
    </h3>
    <p>
     之所以会闪屏，原因就在于show()里面的system("cls")会导致整个界面会清空，所以我们可以不采用清空的做法，而是采用覆盖式显示，每次draw之前将光标移到控制台的最开始的位置，然后什么都不管，直接覆盖掉原有的图像。
    </p>
    <p>
     所以很简单，只用把原来的system("cls")改成移动光标到开始处即可,别忘了#include &lt;windows.h&gt;
    </p>
    <pre><code class="language-cpp">system("cls");</code></pre>
    <p>
     ————&gt;&gt;&gt;
    </p>
    <pre><code class="language-cpp">HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
COORD pos = { 0,0 };
SetConsoleCursorPosition(hOut, pos);</code></pre>
    <h3 id="%E6%9C%80%E5%90%8E%E5%AF%B9%E4%B8%80%E9%81%8D%E4%BB%A3%E7%A0%81~">
     最后对一遍代码~
    </h3>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt;
#include &lt;windows.h&gt;

#define FPS 4
#define WIDTH 100
#define HEIGHT 40

typedef struct _actor{
	int width;
	int height;
	char** image;
	int x;
	int y;
} Actor;

char screen[HEIGHT][WIDTH+1];
char key;
Actor boy;
Actor bed;
Actor guard;
Actor ground_1;
Actor ground_2;

void init(void);

void handle(void);

void update(void);

void show(void);
	void render(void);
		void clear(void);
		void load(Actor* actor);
	void draw(void);


int main()
{
	init();

	clock_t t1=0,t2=0;
	while (1) {
		t2 = clock();

		if (_kbhit()) key = _getch();

		if (t2-t1 &gt; CLOCKS_PER_SEC*1.0/FPS) {
			t1 = t2;

			handle();
			update();
			show();

		}
	}
}


void init(void)
{
	for (int i = 0; i&lt;HEIGHT; i++) screen[i][WIDTH] = '\n';
	key = '\0';
	static char* image_boy[] =
	   {"  ~@~  ",
		" /BOY\\ ",
		"~ ### ~",
		" _/ \\_ "};
	boy = (Actor){.x=4,.y=22,.width=strlen(image_boy[0]),.height=4,.image = image_boy};
	static char* image_bed[] =
	   {"|                             |",
		"|                             |",
		"+#############################+",
		"|  |__|                       |",
		"|  |__|                       |",
		"|  |__|                       |",
		"|  |__|                       |",
		"|  |__|                       |",
		"|  |__|                       |",
		"|  |__|                       |",
		"|  |__|                       |",
		"+#############################+",
		"|                             |",
		"|                             |"};
	bed = (Actor){.x=50,.y=10,.width=strlen(image_bed[0]),.height=14,.image=image_bed};
	static char* image_guard[] =
	   {"!    @    T",
		"*~~GUARD~~+",
		"   \\###/  |",
		"   /###\\  |",
		"   L   L  |"};
	guard = (Actor){.x=65,.y=16,.width=strlen(image_guard[0]),.height=5,.image = image_guard};
	static char* image_ground[] =
	   {"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"};
	ground_1 = (Actor){.x=0,.y=30,.width=strlen(image_ground[0]),.height=1,.image=image_ground};
	ground_2 = (Actor){.x=12,.y=23,.width=strlen(image_ground[0]),.height=1,.image=image_ground};
}

void handle(void)
{
	switch (key) {
		case 'w':
			if (boy.y &gt; 20) {
				boy.y --;
			} break;
		case 'a':
			if (boy.x &gt; 0) {
				boy.x --;
			} break;
		case 's':
			if (boy.y &lt; 26) {
				boy.y ++;
			} break;
		case 'd':
			if (boy.x &lt; 90) {
				boy.x ++;
			} break;
	}
	key = '\0';
}

void update(void)
{
	if (boy.x &gt;= guard.x-boy.width &amp;&amp; boy.x &lt;= guard.x+guard.width) {
		guard.y += 2;
		if (boy.y &lt;= guard.y+guard.height) {
			static char* image_boy[] =
			   {"   ~www",
				" (&gt;_&lt;) ",
				" ~###~ ",
				"  / \\  "};
			boy.image = image_boy;
			boy.x -= 10;
		}
	}
}

void show(void)
{
	render();
	HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD pos = { 0,0 };
    SetConsoleCursorPosition(hOut, pos);
	draw();
}

void render(void)
{
	clear();
	load(&amp;ground_1);
	load(&amp;ground_2);
	load(&amp;bed);
	load(&amp;guard);
	load(&amp;boy);
}

void clear(void)
{
	for (int i = 0; i&lt; HEIGHT; i++) {
		for (int j = 0; j &lt; WIDTH; j ++) {
			screen[i][j] = ' ';
		}
	}
}

void load(Actor* actor)
{
	for (int i = 0; i&lt;actor-&gt;height; i++) {
		for (int j = 0; j&lt;actor-&gt;width; j++) {
			if (actor-&gt;image[i][j] != ' ') {
				screen[actor-&gt;y+i][actor-&gt;x+j] = actor-&gt;image[i][j];
			}
		}
	}
}

void draw(void)
{
	screen[HEIGHT-1][WIDTH] = '\0';
	printf("%s\n",screen);
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f6c65656879756b73687561692f:61727469636c652f64657461696c732f313232353933323531" class_="artid" style="display:none">
 </p>
</div>


