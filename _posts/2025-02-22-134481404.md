---
layout: post
title: "Linux进程解析冯诺依曼体系结构,操作系统,进程初步解析"
date: 2025-02-22 17:58:56 +0800
description: "Linux进程解析：冯诺依曼体系结构，操作系统，"
keywords: "Linux进程解析(冯诺依曼体系结构，操作系统，进程初步解析)"
categories: ['Linux']
tags: ['运维', '笔记', '深度学习', '服务器', 'Linux']
artid: "134481404"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=134481404
    alt: "Linux进程解析冯诺依曼体系结构,操作系统,进程初步解析"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux进程解析(冯诺依曼体系结构，操作系统，进程初步解析)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <img alt="" height="808" src="https://i-blog.csdnimg.cn/blog_migrate/c982160a9df465abcebecb097b274ab3.png" width="1200"/>
    </h2>
    <h2>
     冯诺依曼体系结构：
    </h2>
    <p>
     我们常见的计算机，如笔记本。
     <strong>
      我们常见的计算机，服务器，大部分都遵守冯诺依曼体系。
     </strong>
    </p>
    <p>
     <img alt="" height="339" src="https://i-blog.csdnimg.cn/blog_migrate/73ab51e70038f4e5e2540a8de2909f5e.jpeg" width="640"/>
    </p>
    <blockquote>
     <p>
      截至目前，我们所认识的计算机，都是有一个个的
      <strong>
       硬件组件组成：
      </strong>
      <br/>
      <strong>
       中央处理器(CPU)：含有运算器和控制器等；
      </strong>
     </p>
     <p>
      <strong>
       输入单元：包括键盘, 鼠标，扫描仪, 写板、话筒、摄像头、磁盘、网卡等；
       <br/>
       输出单元：显示器，打印机、声卡、显卡、网卡、磁盘等；
      </strong>
     </p>
     <p>
      <strong>
       以上的设备有的只做输入，或者只做输出，有的即做输入又做输出。
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       关于冯诺依曼，必须强调几点：
       <br/>
       <span style="color:#ff9900;">
        1.这里的存储器指的是内存，特点是：断电后在内存的数据会丢失(掉电易失)！
       </span>
       <br/>
       <span style="color:#ff9900;">
        2.不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取。
       </span>
       <br/>
       一句话，
       <span style="color:#fe2c24;">
        所有设备都只能直接和内存打交道。
       </span>
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <img alt="" height="552" src="https://i-blog.csdnimg.cn/blog_migrate/6c62a276579004bba9b0740be25b5e2f.png" width="786">
       <span style="color:#ff9900;">
        <strong>
         效率越高，造价贵单体容量越小距离CPU越近的存储单元，
        </strong>
       </span>
      </img>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        距离CPU越远的存储单元，效率越低，造价便宜，单体容量大
       </strong>
      </span>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <span style="color:#956fe7;">
       <strong>
        各个设备之间是用总线连接在主板上的，目的：数据在设备之间流动(本质是设备之间会进行数据的来回拷贝，拷贝的整体速度，是决定计算机效率的重要指标！)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#956fe7;">
       <strong>
        为什么在体系结构中要存在内存？
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#956fe7;">
       <strong>
        答：以一个文本文件为例：CPU的速度是非常快的，而键盘的输入和显示是我们写的速度决定的， 这样就导致CPU在效率上就过度的浪费，所以引入内存，可以理解为一个非常大的缓存，介于设备和CPU之间，这样计算机效率就变成了内存效率问题，并且由于内存的引入，让我们在计算机效率不错还比较便宜的情况下，让老百姓使用。
       </strong>
      </span>
     </p>
    </blockquote>
    <blockquote>
     <p>
      对冯诺依曼的理解，不能停留在概念上，要深入到对软件数据流理解上，请解释，从你登录上qq开始和某位朋友聊天开始，数据的流动过程。从你打开窗口，开始给他发消息，到他的到消息之后的数据流动过程。
      <strong>
       如果是在qq上发送文件呢？
      </strong>
     </p>
     <p>
      <strong>
       答：我们在键盘进行输入，然后将数据交给内存，由内存将数据给CPU处理打包，然后返回给内存，内存再将打包好的数据交给网卡，另一个人的网卡接受到数据，交给内存，内存再给CPU处理解包，然后输出到显示器上。
      </strong>
     </p>
    </blockquote>
    <p>
     <img alt="" height="791" src="https://i-blog.csdnimg.cn/blog_migrate/3af3a85b00ac91d259ca43706e9641ab.png" width="1200">
      <br/>
     </img>
    </p>
    <h2>
     操作系统
    </h2>
    <h3>
     概念：
    </h3>
    <blockquote>
     <p>
      <strong>
       任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。
      </strong>
     </p>
     <p>
      <strong>
       笼统的理解，操作系统包括：
       <br/>
       内核（进程管理，内存管理，文件管理，驱动管理）
       <br/>
       其他程序（例如函数库，shell程序等等）
      </strong>
     </p>
    </blockquote>
    <h3>
     设计OS的目的：
    </h3>
    <blockquote>
     <p>
      <strong>
       1.与硬件交互，管理所有的软硬件资源
       <br/>
       2.为用户程序（应用程序）提供一个良好的执行环境
      </strong>
     </p>
     <p>
     </p>
     <p>
      <strong>
       当我们
       <span style="color:#ff9900;">
        将电脑开机，第一个被加载的软件是操作系统，
       </span>
      </strong>
     </p>
     <p>
      <span style="color:#fe2c24;">
       <strong>
        操作系统是一个进行软硬件资源管理的软件。
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
     <img alt="" height="756" src="https://i-blog.csdnimg.cn/blog_migrate/69ec741323ff926feb8f1c2126b5dcf8.png" width="875"/>
    </p>
    <blockquote>
     <p>
      <strong>
       以操作系统、驱动程序、底层硬件讲解：
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24;">
        每一个硬件都有对应的驱动！！！
       </span>
      </strong>
     </p>
     <p>
      <strong>
       以校园生活为背景：
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#956fe7;">
        校长(管理者)、辅导员(保证管理决策的落地)、学生(被管理者)
       </span>
      </strong>
     </p>
     <p>
      <strong>
       首先我们应该知道管理者与被管理者，并不需要见面，
       <span style="color:#fe2c24;">
        管理的本质不在于对人做管理，而在于对人的信息(数据)做管理，管理者核心工作是做决策，根据数据做决策。
       </span>
      </strong>
     </p>
     <p>
      <span style="color:#fe2c24;">
       <strong>
        先描述，再组织：
       </strong>
      </span>
     </p>
     <p>
      <strong>
       以面向对象语言为例：
      </strong>
     </p>
     <p>
      <strong>
       从历史的角度：
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#ff9900;">
        我们要对一个事物进行管理，首先要知道他们的属性：如：名字，学号，年龄……信息，有了这些信息我们将他们写成一个结构体，这就是先描述！！！
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#ff9900;">
        我们再用不同的STL容器(string、list、map……)将数据统一管理就是再组织！！
       </span>
      </strong>
     </p>
     <p>
      <strong>
       最后按不同的需求来对数据的增删改查！
      </strong>
     </p>
     <p>
      <strong>
       预测未来：
      </strong>
     </p>
     <p>
      <span style="color:#956fe7;">
       <strong>
        如果你要做一件事情第一步：先描述(struct/class);
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#956fe7;">
       <strong>
        做一件事情的第二步：再组织——&gt;容器(数据结构)
       </strong>
      </span>
     </p>
     <p>
      <strong>
       最后把你对数据的管理场景转化成为对特点数据结构的增删改查！
      </strong>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        以上将具体问题，进行计算机级别的建模过程！转成计算机能够认识的问题！
       </strong>
      </span>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       系统调用和库函数概念：
      </strong>
      <br/>
      <strong>
       在开发角度
      </strong>
      ，
      <span style="color:#956fe7;">
       <strong>
        操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。
       </strong>
      </span>
      <br/>
      <strong>
       系统调用在使用上
      </strong>
      ，
      <span style="color:#ff9900;">
       <strong>
        功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。
       </strong>
      </span>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       1.为什么要有操作系统？
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#956fe7;">
        需要去管理软硬件；
       </span>
      </strong>
     </p>
     <p>
      <strong>
       2.为什么要有操作系统的管理？
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#956fe7;">
        对下：管理好软硬件资源——手段
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#956fe7;">
        对上：提供一个良好(稳定、高效、安全)的环境——目的
       </span>
      </strong>
     </p>
     <p>
      <strong>
       比如：一个用户去银行存钱，是自己拿到金库中，取钱也是自己去金库拿，这样必然会出现问题！！！
      </strong>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        所以在操作系统中，需要一个把用户和操作系统进行分隔的区间，所以就有了系统接口，它是由操作系统提供的系统调用函数。
       </strong>
      </span>
     </p>
     <p>
      <strong>
       比如：用户在一个程序中用了printf这个函数，它会调用已经封装好系统调用的用户操作接口lib库，所有的操作都不能越级访问，必须按级调用
      </strong>
     </p>
     <p>
      <strong>
       比如一个printf可以实现在windows和Linux上使用，调用设计者提供的lib库来实现对系统调用接口向下实现
      </strong>
      ​​​​​​​
     </p>
    </blockquote>
    <h2>
     进程：
    </h2>
    <blockquote>
     <p>
      <strong>
       描述进程-PCB
      </strong>
      <br/>
      <strong>
       进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合。
      </strong>
      <br/>
      课本上称之为PCB（process control block），
      <span style="color:#0d0016;">
       <strong>
        Linux操作系统下的PCB是: task_struct
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016;">
       <strong>
        task_struct-PCB的一种
       </strong>
      </span>
      <br/>
      <span style="color:#fe2c24;">
       <strong>
        在Linux中描述进程的结构体叫做task_struct。
       </strong>
      </span>
      <br/>
      <strong>
       task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       task_ struct内容分类
       <br/>
       标示符: 描述本进程的唯一标示符，用来区别其他进程。（pid）
       <br/>
       状态: 任务状态，退出代码，退出信号等。
       <br/>
       优先级: 相对于其他进程的优先级。
       <br/>
       程序计数器: 程序中即将被执行的下一条指令的地址。
       <br/>
       内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
       <br/>
       上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
       <br/>
       I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
       <br/>
       记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
       <br/>
       其他信息
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       事实
       <br/>
       1.我们可以同时启动多个程序--- 我们一定要将多个.exe加载到内存
      </strong>
     </p>
     <p>
      <strong>
       2.操作系统要不要管理多个加载到内存的程序呢??要的
      </strong>
     </p>
     <p>
      <strong>
       2.操作系统如何管理加载到内存的程序呢? 先描述，在组织！！！
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <span style="color:#fe2c24;">
       <strong>
        进程=内核PCB对象(内核数据结构)+可执行程序
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24;">
       <strong>
        所有对进程的控制和操作，都只和进程的PCB有关，与进程的可执行程序无关！！！
       </strong>
      </span>
     </p>
     <p>
      <strong>
       如：需要启动多个程序，也是PCB去排队来等待调度！！！
      </strong>
     </p>
     <p>
      <strong>
       因此，对进程的管理，转化为对PCB对象的管理，就可以通过对数据结构的增删改查来实现对进程的管理！！！
      </strong>
     </p>
    </blockquote>
    <h3>
     扩展：
    </h3>
    <blockquote>
     <p>
      <span style="color:#ff9900;">
       <strong>
        程序计数器(pc指针 / eip寄存器):指向将被执行的下一条指令的地址。
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        当程序运行到判断,循环,函数跳转这些语法时本质都是修改pc指针/eip寄存器，pc指针/eip寄存器指向哪一个进程的代码,就表示哪一个进程是下一个要被调度运行！！！
       </strong>
      </span>
     </p>
    </blockquote>
    <h3>
     在Linux关于进程的相关操作：
    </h3>
    <h4>
     查看进程信息：
    </h4>
    <blockquote>
     <p>
      <strong>
       进程的信息可以通过 /proc 系统文件夹查看。
      </strong>
     </p>
    </blockquote>
    <p>
     <img alt="" height="121" src="https://i-blog.csdnimg.cn/blog_migrate/1e6817155328c95ec11f31394cca111b.png" width="1056"/>
    </p>
    <p>
     <strong>
      写一个死循环程序来，查看进程的执行：
     </strong>
    </p>
    <p>
     <img alt="" height="257" src="https://i-blog.csdnimg.cn/blog_migrate/b18e40c82a84d3eca57000f57e99d224.png" width="213"/>
    </p>
    <p>
     <span style="color:#fe2c24;">
      <strong>
       ps ajx | head -1 &amp;&amp; ps -ajx | grep myprocess(编译结束后的文件名)
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="191" src="https://i-blog.csdnimg.cn/blog_migrate/d624fe265fded1712af9e898c66e3d7a.png" width="1055"/>
    </p>
    <p>
     <strong>
      查看进程里的信息：
      <span style="color:#fe2c24;">
       ls /proc/进程pid
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="825" src="https://i-blog.csdnimg.cn/blog_migrate/698be5742ff2ca7f2efc239f20c239c8.png" width="1093"/>
    </p>
    <p>
     <strong>
      更改cwd(当前工作目录):更改为/home/LFH路径
     </strong>
    </p>
    <p>
     <img alt="" height="234" src="https://i-blog.csdnimg.cn/blog_migrate/4807f162d91590c026d8c6fc1484c7ac.png" width="1078"/>
    </p>
    <p>
     <img alt="" height="418" src="https://i-blog.csdnimg.cn/blog_migrate/2a721946d262362948f0bff38160bace.png" width="453"/>
    </p>
    <p>
     <img alt="" height="109" src="https://i-blog.csdnimg.cn/blog_migrate/950445ae81a2ba35a16285f3261377d2.png" width="351"/>
    </p>
    <blockquote>
     <p>
      <strong>
       我们创建一个文件会去找到对应的cwd，然后在这个路径下创建对应的文件。
      </strong>
     </p>
     <p>
      <strong>
       通过更改cwd，此时我们成功将110.txt创建到/home/LFH这个路径下。
      </strong>
     </p>
    </blockquote>
    <h4>
     通过系统调用获取进程标示符(pid)：
    </h4>
    <p>
     <strong>
      1.getpid()和getppid()
     </strong>
    </p>
    <p>
     <img alt="" height="621" src="https://i-blog.csdnimg.cn/blog_migrate/98d46d434a596dcfcd9f010c76981a72.png" width="1070"/>
    </p>
    <p>
     <strong>
      2.查看进程pid和父进程pid：
     </strong>
    </p>
    <p>
     <img alt="" height="197" src="https://i-blog.csdnimg.cn/blog_migrate/08172e3f54c05675c5cd8b1f83ed12b1.png" width="301"/>
    </p>
    <p>
     <img alt="" height="75" src="https://i-blog.csdnimg.cn/blog_migrate/8fa78bdc5d78b451027e11ff5b99c618.png" width="362"/>
    </p>
    <blockquote>
     <p>
      <strong>
       特别注意：
      </strong>
     </p>
     <p>
      <span style="color:#fe2c24;">
       <strong>
        1.每次执行这个编译好的程序，操作系统分配的pid会不相同，运行结束就进程就会销毁，再次运行又会重新分配！！！
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24;">
       <strong>
        2.而每次运行的父进程相同都是bach(即：上面的14047)，每个进程都有它的父进程，而bash就是process的父进程，也是shell外壳的一种！
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
     <strong>
      3.fork()函数
     </strong>
    </p>
    <p>
     <img alt="" height="401" src="https://i-blog.csdnimg.cn/blog_migrate/e44b0b795651cd3bfe418a7bf23da482.png" width="1103"/>
    </p>
    <p>
     <img alt="" height="60" src="https://i-blog.csdnimg.cn/blog_migrate/c7b0118a664ea668932f7427f7d3bcb1.png" width="1036"/>
    </p>
    <blockquote>
     <p>
      <span style="color:#956fe7;">
       <strong>
        用fork()函数创建子进程，如果创建成功父进程的返回值是子进程的pid，子进程的返回值为0；如果创建失败父进程返回值为-1.
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
     4.创建子进程
    </p>
    <p>
     <img alt="" height="491" src="https://i-blog.csdnimg.cn/blog_migrate/d5996740c97ece78897c927dcb0e669c.png" width="697"/>
    </p>
    <p>
     <img alt="" height="183" src="https://i-blog.csdnimg.cn/blog_migrate/ad35ae1e5b4046abbf4116f6a0e6a599.png" width="739"/>
    </p>
    <blockquote>
     <p>
      <strong>
       运行后发现父进程和子进程都在执行！！！
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      总结：
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       用fork()函数创建子进程后：
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#ff9900;">
        1.父子进程会共用代码块；
       </span>
      </strong>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        2.在父子进程进行代码共享时，父进程会把PCB中的部分数据给子进程，但是比如pid就不会给，所以当创建子进程后，子进程也会执行后面的代码；
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        3.因为代码共享，所以对应如果需要改变代码中的数据，各个进程会创建属于自己的数据区，用于存放自己改变的数据(写时拷贝)。
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#ff9900;">
       <strong>
        4.创建子进程的目的：因为有些事情我们的父进程不想做，还有其他的事要做，所以创建一个子进程，然后通过if -else语句让它们去执行它们各个需要去做的事情！！！
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
     <strong>
      5.进程之间具有相互独立性
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       任意一个进程之间具有相对独立性，相互之间没有影响！！！
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       即使父进程和子进程亲如父子,但是当我们的子进程和父进程都运行起来之后,子进程挂了,代码也仍会存在,对父进程无影响，父进程挂了,代码也仍会存在,对子进程无影响！！！
      </strong>
     </p>
     <p>
      <strong>
       因为程序被加载到内存，运行起来后，
       <span style="color:#fe2c24;">
        进程里存放的是程序的拷贝数据。
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <p id="%C2%A0%E4%BB%A5%E4%B8%8A%E5%B0%B1%E6%98%AF%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%90%84%E4%BD%8D%E5%A4%A7%E4%BD%AC%E5%9C%A8%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%8E%A2%E8%AE%A8%EF%BC%81">
     <strong>
      以上就是个人学习的见解和学习过程的解析，欢迎各位大佬在评论区探讨，交流！
     </strong>
    </p>
    <p>
     <strong>
      如果本篇对你有帮助的话，三连支持一下吧。
     </strong>
    </p>
    <p>
     <strong>
      感谢大佬们的三连！ 感谢大佬们的三连！ 感谢大佬们的三连！
     </strong>
    </p>
    <p>
     <strong>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/23520666c57419622fc185943d97f065.png"/>
     </strong>
    </p>
    <p>
    </p>
   </div>
  </div>
  <div class="blog-vote-box" id="blogVoteBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37313936343738302f:61727469636c652f64657461696c732f313334343831343034" class_="artid" style="display:none">
 </p>
</div>


