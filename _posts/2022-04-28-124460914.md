---
layout: post
title: "云原生架构阿里云-主要架构模式"
date: 2022-04-28 07:00:00 +0800
description: "云原生架构中主要的架构模式"
keywords: "【云原生架构】阿里云 —— 主要架构模式"
categories: ['未分类']
tags: ['云原生架构', '云原生']
artid: "124460914"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=124460914
  alt: "云原生架构阿里云-主要架构模式"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【云原生架构】阿里云 —— 主要架构模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8d8f681a98635ef287491c26a4239a40.gif#pic_center"/>
    </p>
    <p>
     🔎这里是【阿里云·云原生架构·白皮书】，关注我学习云原生不迷路
     <br/>
     👍如果对你有帮助，给博主一个免费的点赞以示鼓励
     <br/>
     欢迎各位🔎点赞👍评论收藏⭐️
    </p>
    <h2>
     <a id="_6">
     </a>
     👀专栏介绍
    </h2>
    <p>
     <strong>
      【阿里云·云原生架构·白皮书】
     </strong>
     主要更新一些在学习云原生架构时的一些总结，以及对白皮书内容的解读。
    </p>
    <h2>
     <a id="_9">
     </a>
     👀本期介绍
    </h2>
    <p>
     主要介绍主要架构模式
     <br/>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#_6" rel="nofollow">
        👀专栏介绍
       </a>
      </li>
      <li>
       <a href="#_9" rel="nofollow">
        👀本期介绍
       </a>
      </li>
      <li>
       <a href="#_12" rel="nofollow">
        主要架构模式
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_14" rel="nofollow">
          服务化架构模式
         </a>
        </li>
        <li>
         <a href="#Mesh__25" rel="nofollow">
          Mesh 化架构模式
         </a>
        </li>
        <li>
         <a href="#Serverless_39" rel="nofollow">
          Serverless模式
         </a>
        </li>
        <li>
         <a href="#_53" rel="nofollow">
          存储计算分离模式
         </a>
        </li>
        <li>
         <a href="#_67" rel="nofollow">
          分布式事务模式
         </a>
        </li>
        <li>
         <a href="#_76" rel="nofollow">
          可观测架构
         </a>
        </li>
        <li>
         <a href="#_83" rel="nofollow">
          事件驱动架构
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="_12">
     </a>
     主要架构模式
    </h2>
    <p>
     云原生架构有非常多的架构模式，这里选取一些对应用收益更大的主要架构模式进行讨论。
    </p>
    <h3>
     <a id="_14">
     </a>
     服务化架构模式
    </h3>
    <blockquote>
     <p>
      服务化架构是云时代构建云原生应用的标准架构模式，要求以应用模块为颗粒度划分一个软件，以接口契约（例如IDL)定义彼此业务关系，以标准协议（HTTP、gRPC等）确保彼此的互联互通，结合DDD(领域模型驱动）、TDD（测试驱动开发)、容器化部署提升每个接口的代码质量和迭代速度。服务化架构的典型模式是微服务和小服务(Mini Service)模式，其中小服务可以看做是一组关系非常密切的服务的组合，这组服务会共享数据，小服务模式通常适用于非常大型的软件系统，避免接口的颗粒度太细而导致过多的调用损耗（特别是服务间调用和数据一致性处理）和治理复杂度。
     </p>
    </blockquote>
    <blockquote>
     <p>
      通过服务化架构，把代码模块关系和部署关系进行分离，每个接口可以部署不同数量的实例，单独扩缩容，从而使得整体的部署更经济。此外，由于在进程级实现了模块的分离，每个接口都可以单独升级，从而提升了整体的迭代效率。但也需要注意，服务拆分导致要维护的模块数量增多，如果缺乏服务的自动化能力和治理能力，会让模块管理和组织技能不匹配，反而导致开发和运维效率的降低。
     </p>
    </blockquote>
    <p>
     <strong>
      SBA网络架构具备三大特征：
     </strong>
     <br/>
     1、松耦合的微服务
     <br/>
     2、轻量高效的服务调用接口
     <br/>
     3、自动化、智能化的服务管理框架
    </p>
    <h3>
     <a id="Mesh__25">
     </a>
     Mesh 化架构模式
    </h3>
    <blockquote>
     <p>
      Mesh 化架构是把中间件框架（比如RPC、缓存、异步消息等）从业务进程中分离，让中间件SDK与业务代码进一步解耦，从而使得中间件升级对业务进程没有影响，甚至迁移到另外一个平台的中间件也对业务透明。分离后在业务进程中只保留很“薄”的Client部分，Client通常很少变化，只负责与Mesh进程通讯，原来需要在SDK中处理的流量控制、安全等逻辑由Mesh进程完成。整个架构如下图所示。
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fda5e5081dd29f6136788f6d3c72ca12.png">
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/607db17e4d80045a8773b72220b9c9a5.png"/>
     </img>
    </p>
    <blockquote>
     <p>
      实施Mesh 化架构后，大量分布式架构模式（熔断、限流、降级、重试、反压、隔仓……)都由Mesh进程完成，即使在业务代码的制品中并没有使用这些三方软件包;同时获得更好的安全性（比如零信任架构能力)、按流量进行动态环境隔离、基于流量做冒烟/回归测试等。
     </p>
    </blockquote>
    <p>
     <strong>
      Mesh网络有其自身的特点：
     </strong>
    </p>
    <p>
     1、平衡负载，Mesh网络可以提供更大的冗余度以利负载平衡。在比较繁忙的网络，例如有两台设备进行大数据量的通讯，每台设备附近都有许多节点可供选择，创建多条路径来平衡负载。而单跳网络则没有动态调整的能力。
    </p>
    <p>
     2、健壮性，因为Mesh网络不像单跳网络，仅仅依靠一个节点，一旦某个节点出现故障或者有冲突发生，Mesh网络可以继续工作，数据也可选择替代路径继续传递。
    </p>
    <p>
     3、空间的复用性，Mesh网络可以充分地利用带宽。在一个单跳环境中，所有设备不得不共享一个节点，如果多台设备同时要求接入网络，那么必然导致速度变慢;而Mesh网络，多设备可以同时接入网络，却通过不同的节点。
    </p>
    <h3>
     <a id="Serverless_39">
     </a>
     Serverless模式
    </h3>
    <blockquote>
     <p>
      和大部分计算模式不同，Serverless 将“部署”这个动作从运维中“收走”，使开发者不用关心应用在哪里运行，更不用关心装什么OS、怎么配置网络、需要多少CPU……从架构抽象上看，当业务流量到来/业务事件发生时，云会启动或调度一个已启动的业务进程进行处理，处理完成后云自动会关闭/调度业务进程，等待下一次触发，也就是把应用的整个运行时都委托给云。
     </p>
    </blockquote>
    <blockquote>
     <p>
      今天Serverless 还没有达到任何类型的应用都适用的地步，因此架构决策者需要关心应用类型是否适合于Serverless运算。如果应用是有状态的，云在进行调度时可能导致上下文丢失，毕竟Serverless 的调度不会帮助应用做状态同步;如果应用是长时间后台运行的密集型计算任务，会得不到太多Serverless的优势;如果应用涉及到频繁的外部VO（网络或者存储，以及服务间调用)，也因为繁重的IO负担、时延大而不适合。Serverless非常适合于事件驱动的数据计算任务、计算时间短的请求/响应应用、没有复杂相互调用的长周期任务。
     </p>
    </blockquote>
    <p>
     <strong>
      Serverless 架构的 Traits 特质：
     </strong>
    </p>
    <p>
     入门门槛低（Low barrier-to-entry）
     <br/>
     无主机（Hostless）
     <br/>
     无状态（Stateless）
     <br/>
     弹性（Elasticity）
     <br/>
     分布式（Distributed）
     <br/>
     事件驱动（Event-driven）
    </p>
    <h3>
     <a id="_53">
     </a>
     存储计算分离模式
    </h3>
    <blockquote>
     <p>
      分布式环境中的CAP困难主要是针对有状态应用，因为无状态应用不存在C(一致性）这个维度，因此可以获得很好的A(可用性）和P(分区容错性)，因而获得更好的弹性。在云环境中，推荐把各类暂态数据(如session )、结构化和非结构化持久数据都采用云服务来保存，从而实现存储计算分离。但仍然有一些状态如果保存到远端缓存，会造成交易性能的明显下降，比如交易会话数据太大、需要不断根据上下文重新获取等，则可以考虑通过采用Event Log +快照（或 Check Point)的方式，实现重启后快速增量恢复服务，减少不可用对业务的影响时长。
     </p>
    </blockquote>
    <p>
     <strong>
      分离架构有以下优势：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       对于不同类型的集群，可以针对性地部署更加合适的服务器；
      </p>
     </li>
     <li>
      <p>
       计算和存储可以分别按需进行扩展，而不是一起扩展；
      </p>
     </li>
     <li>
      <p>
       不同集群可以有不同的升级周期；
      </p>
     </li>
     <li>
      <p>
       划分了运维职责，更加便于管理；
      </p>
     </li>
     <li>
      <p>
       提高了资源利用率，降低了能耗开销。
      </p>
     </li>
    </ol>
    <h3>
     <a id="_67">
     </a>
     分布式事务模式
    </h3>
    <p>
     微服务模式提倡每个服务使用私有的数据源，而不是像单体这样共享数据源，但往往大颗粒度的业务需要访问多个微服务，必然带来分布式事务问题，否则数据就会出现不一致。架构师需要根据不同的场景选择合适的分布式事务模式。
    </p>
    <ul>
     <li>
      传统采用XA模式，虽然具备很强的一致性，但是性能差;
     </li>
     <li>
      基于消息的最终一致性（BASE）通常有很高的性能，但是通用性有限，且消息端只能成功而不能触发消息生产端的事务回滚;
     </li>
     <li>
      TCC模式完全由应用层来控制事务，事务隔离性可控，也可以做到比较高效;但是对业务的侵入性非常强，设计开发维护等成本很高;
     </li>
     <li>
      SAGA模式与TCC模式的优缺点类似但没有try这个阶段，而是每个正向事务都对应一个补偿事务，也是开发维护成本高;
     </li>
     <li>
      开源项目SEATA的AT模式非常高性能且无代码开发工作量，且可以自动执行回滚操作，同时也存在一些使用场景限制。
     </li>
    </ul>
    <h3>
     <a id="_76">
     </a>
     可观测架构
    </h3>
    <blockquote>
     <p>
      可观测架构包括Logging、Tracing、Metrics三个方面，其中Logging提供多个级别( verboseldebuglwarning/errorlfatal)的详细信息跟踪，由应用开发者主动提供;Tracing 提供一个请求从前端到后端的完整调用链路跟踪，对于分布式场景尤其有用;Metrics则提供对系统量化的多维度度量。
     </p>
    </blockquote>
    <blockquote>
     <p>
      架构决策者需要选择合适的、支持可观测的开源框架（比如OpenTracing、OpenTelemetry ) ,并规范上下文的可观测数据规范（例如方法名、用户信息、地理位置、请求参数等），规划这些可观测数据在哪些服务和技术组件中传播，利用日志和tracing 信息中的span id/trace id，确保进行分布式链路分析时有足够的信息进行快速关联分析。
     </p>
    </blockquote>
    <blockquote>
     <p>
      由于建立可观测性的主要目标是对服务SLO ( Service Level Objective）进行度量，从而优化SLA，因此架构设计上需要为各个组件定义清晰的SLO，包括并发度、耗时、可用时长、容量等。
     </p>
    </blockquote>
    <h3>
     <a id="_83">
     </a>
     事件驱动架构
    </h3>
    <p>
     事件驱动架构（EDA，Event Driven Architecture)本质上是一种应用/组件间的集成架构模式，典型的事件驱动架构如下图:在这里插入图片描述
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0beb86c7e91728bc57f18e29e3cf75b6.png">
      <br/>
      事件和传统的消息不同，事件具有schema，所以可以校验event的有效性，同时EDA具备QoS保障机制，也能够对事件处理失败进行响应。事件驱动架构不仅用于(微）服务解耦，还可应用于下面的场景中:
     </img>
    </p>
    <ul>
     <li>
      增强服务韧性:由于服务间是异步集成的，也就是下游的任何处理失败甚至宕机都不会被上游感知，自然也就不会对上游带来影响;
     </li>
     <li>
      cQRs(Command Query Responsibility Segregation):把对服务状态有影响的命令用事件来发起，而对服务状态没有影响的查询才使用同步调用的API接口;结合EDA中的Event Sourcing可以用于维护数据变更的一致性，当需要重新构建服务状态时，把 EDA中的事件重新“播放”一遍即可;
     </li>
     <li>
      数据变化通知:在服务架构下，往往一个服务中的数据发生变化，另外的服务会感兴趣，比如用户订单完成后，积分服务、信用服务等都需要得到事件通知并更新用户积分和信用等级;
     </li>
     <li>
      构建开放式接口:在 EDA下，事件的提供者并不用关心有哪些订阅者，不像服务调用的场景―一数据的产生者需要知道数据的消费者在哪里并调用它，因此保持了接口的开放性;
     </li>
     <li>
      事件流处理:应用于大量事件流（而非离散事件）的数据分析场景，典型应用是基于Kafka的日志处理;·基于事件触发的响应:在loT时代大量传感器产生的数据，不会像人机交互一样需要等待处理结果的返回，天然适合用EDA来构建数据处理应用。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/076ed2ee9ea504d1526c9fd1f43b00a1.webp?x-image-process=image/format,png#pic_center"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35303834333931382f:61727469636c652f64657461696c732f313234343630393134" class_="artid" style="display:none">
 </p>
</div>
