---
layout: post
title: "多线程同步IO和单线程异步IO"
date: 2025-01-06 21:12:31 +0800
description: "多线程同步I/O和单线程异步I/O2014-08-24同步I/O与异步I/O线程在执行中如果遇到磁盘"
keywords: "异步io线程数"
categories: ['未分类']
tags: ['无标签']
artid: "43198137"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=43198137
  alt: "多线程同步IO和单线程异步IO"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     多线程同步I/O和单线程异步I/O
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 class="entry-title">
     <a href="http://linzhi.co.in/multithread-io-singlethread-io" rel="nofollow noopener noreferrer" target="_blank" title="多线程同步I/O和单线程异步I/O">
      多线程同步I/O和单线程异步I/O
     </a>
    </h2>
    <p class="entry-date">
     2014-08-24
    </p>
    <h5>
     同步I/O与异步I/O
    </h5>
    <p>
     线程在执行中如果遇到磁盘读写或网络通信（统称IO操作），通常要耗费较长的时间，这时OS会剥夺此线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行，这种I/O模式就是同步式I/O或阻塞式I/O。在这种情况下，程序是线下执行的，比如
    </p>
    <pre class="prettyprint linenums"> 
 <ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> fs </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">"fs"</span><span class="pun">);</span></code></li><li class="L1"><code></code>
</li><li class="L2"><code><span class="kwd">var</span><span class="pln"> data </span><span class="pun">=</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">readFileSync</span><span class="pun">(</span><span class="str">"test.txt"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"utf-8"</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">data</span><span class="pun">);</span></code></li><li class="L4"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"over"</span><span class="pun">);</span></code></li></ol></pre>
    <p>
     这种执行方式很好理解，传统服务器的处理方式是为每个请求开启一个线程，在遇到I/O请求的时候阻塞处理。但每个CPU能承受的线程数是有限制的，于是达到限制的时候就必须添加新的CPU，而且开启线程是非常消耗资源的。
    </p>
    <p>
     异步I/O诞生就解决了上述问题，在异步I/O模型中，线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而是将I/O请求发送给操作系统，继续执行下一条语句。当操作系统完成/IO操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理,
     <code>
      典型的异步编程模型有Node.js
     </code>
    </p>
    <pre class="prettyprint linenums"> 
 <ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> fs </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">"fs"</span><span class="pun">);</span></code></li><li class="L1"><code></code>
</li><li class="L2"><code><span class="pln">fs</span><span class="pun">.</span><span class="pln">readFile</span><span class="pun">(</span><span class="str">"test.txt"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"utf-8"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">    </span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{<!-- --></span></code></li><li class="L4"><code><span class="pln">        console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">err</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{<!-- --></span></code></li><li class="L6"><code><span class="pln">        console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">data</span><span class="pun">);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code><span class="pun">});</span></code></li><li class="L9"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"over"</span><span class="pun">);</span></code></li></ol></pre>
    <p>
     node函数默认是异步处理，上述程序执行会先打印出"over"，待I/O处理完成，再继续执行读文件操作。
    </p>
    <p>
     可以看到阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程；而非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%, I/O 以事件的方式通知。
    </p>
    <p>
     <img alt="同步I/O和异步I/O图解" src="https://i-blog.csdnimg.cn/blog_migrate/95e61d6d5c1813ce8b8af539357ceef9.png"/>
    </p>
    <h5>
     Node的异步I/O
    </h5>
    <p>
     多线程带来的好处是在多核CPU的情况下利用更多的核，而Node.js的单线程也能带来同样的好处，Node.js使用了单线程、非阻塞的事件编程模式。
    </p>
    <p>
     单线程事件编程模式的异步I/O与多线程阻塞式I/O相比，异步I/O少了多线程的开销。对OS来说，创建一个线程的代价比较昂贵，需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU的缓存被清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。
    </p>
    <p>
     单线程事件驱动的异步I/O有个缺点就是异步程序不是很好理解，编写异步程序比较困难。
    </p>
    <p>
     <br/>
    </p>
    <p>
     （
     <a href="http://linzhi.co.in/multithread-io-singlethread-io/" rel="nofollow noopener noreferrer" target="_blank">
      http://linzhi.co.in/multithread-io-singlethread-io/
     </a>
     ）
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f7377696e67626f617264:2f61727469636c652f64657461696c732f3433313938313337" class_="artid" style="display:none">
 </p>
</div>
