---
layout: post
title: "常见网络协议汇总"
date: 2024-07-01 22:43:29 +0800
description: "收藏2.3k次。常用网络协议前言TCP/IP五层网络模型回顾应用层协议DNS协议：HTTP协议HTT"
keywords: "网络协议"
categories: ["未分类"]
tags: ["网络协议", "网络传输"]
artid: "119455352"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=119455352
  alt: "常见网络协议汇总"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     常见网络协议汇总
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      常用网络协议
     </h4>
     <ul>
      <li>
       <ul>
        <li>
         <a href="#_1" rel="nofollow">
          前言
         </a>
        </li>
        <li>
         <a href="#_4" rel="nofollow">
          计算机网络五层模型回顾
         </a>
        </li>
        <li>
         <a href="#_24" rel="nofollow">
          应用层协议
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#DNS_27" rel="nofollow">
            DNS协议：
           </a>
          </li>
          <li>
           <a href="#HTTP_45" rel="nofollow">
            HTTP协议
           </a>
          </li>
          <li>
           <a href="#HTTPS_109" rel="nofollow">
            HTTPS协议
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_143" rel="nofollow">
          传输层协议
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#UDP_145" rel="nofollow">
            UDP协议
           </a>
          </li>
          <li>
           <a href="#TCP_161" rel="nofollow">
            TCP
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_183" rel="nofollow">
          网络层
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#IP_188" rel="nofollow">
            IP协议
           </a>
          </li>
          <li>
           <a href="#ICMP_223" rel="nofollow">
            ICMP协议
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_231" rel="nofollow">
          数据链路层
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#ARP_234" rel="nofollow">
            ARP协议
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_255" rel="nofollow">
          物理层
         </a>
        </li>
        <li>
         <a href="#_258" rel="nofollow">
          整体的网络传输流程
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h3>
     <a id="_1">
     </a>
     前言
    </h3>
    <p>
     <em>
      本篇博客将对基于 计算机网络五层模型 中的常见协议做以总结 ，目的通过这些具体的协议更深刻的认识整体网络的传输流程及相关网络原理
     </em>
    </p>
    <h3>
     <a id="_4">
     </a>
     计算机网络五层模型回顾
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9ede7277b4433329e6464738754036d7.png"/>
    </p>
    <ul>
     <li>
      应用层：为用户为用户的
      <strong>
       应用进程
      </strong>
      提供网络通信服务
      <br/>
      协议——DNS协议、HTTP协议、HTTPS协议
     </li>
     <li>
      传输层：负责
      <strong>
       两台主机之间的数据传输
      </strong>
      ，将数据从发送端传输到接收端
      <br/>
      协议——TCP协议、UDP协议
     </li>
     <li>
      网络层：负责
      <strong>
       传输的地址管理和路由选择
      </strong>
      ，在众多复杂的网络环境中确定一条合适的路径
      <br/>
      协议——IP协议
     </li>
     <li>
      数据链路层：负责
      <strong>
       设备之间数据帧的传送和识别
      </strong>
      ，将网络层传递的数据报封装成帧，在处于同一个数据数据链路节点的两个设备之间传输
      <br/>
      协议——ARP协议、MTU协议
     </li>
     <li>
      物理层：负责
      <strong>
       光电信号的传递方式
      </strong>
      ，实现相邻计算机节点之间比特流的透明传输
     </li>
    </ul>
    <p>
     对于五层网络模型基本都是耳熟能详，但是有没有思考过，网络为什么要这样分层呢？
    </p>
    <p>
     最直接的回答就是
     <strong>
      为了简化网络设计的复杂性
     </strong>
     ，通信协议采用分层结构，各层之间既相互独立又相互协调工作，如此以来便达到的高效的目的。如同设计模式中对于设计一个复杂的程序时，尽量使程序各功能之间是解耦合的一样，对于复杂的网络设计，分层设计也是很明智的一种做法。
    </p>
    <p>
     网络分层的最本质就是
     <strong>
      每一层独立的完成一个任务而不必考虑自己任务之外的实现
     </strong>
     ，而因为不同的任务因此就有了每一层所对应的不同设备。(实例到应用就是，物理层只需要关系0和1的光电信号如何传输，而对它所表达的内容毫不关心；再往上数据链路层只需要关心封装好的数据帧如何准确的送到对应的MAC地址的目的主机中，而不必关心数据报的具体内容和具体会通过何种方式光纤还是局域网…同理往上对于所有层)
    </p>
    <h3>
     <a id="_24">
     </a>
     应用层协议
    </h3>
    <p>
     应用层协议主要负责各个程序间的通信，发生网络传输一个数据时，先由应用层对数据按照对应的协议封装，然后交给下一层传输层，当经过一系列网络传输，数据达到接收端时，一层层的分用，最后一层再由应用层分用，最终得到数据。
    </p>
    <h4>
     <a id="DNS_27">
     </a>
     DNS协议：
    </h4>
    <p>
     DNS协议是一个应用层协议，建立在TCP和UDP的基础之上，使用默认端口为53，其默认通过UDP协议通信，但如果报文过大是则会切换成TCP协议。
    </p>
    <p>
     域名系统 (DNS) 的作用是将人类可读的域名 (如，www.baidu.com) 转换为机器可读的 IP 地址 (如，192.0.2.44)，本质是通过DNS域名和IP地址的对应关系转换，而这种对应关系则保存在DNS服务器中
    </p>
    <p>
     <strong>
      域名的解析过程：
     </strong>
    </p>
    <p>
     域名的解析工作大体上可以分为两个步骤：第一步客户端向本地DNS服务器发起一个DNS请求报文，报文里携带需要查询的域名，第二步本地DNS服务器向本机回应一个DNS响应报文，报文里携带查询域名所对应的IP地址
    </p>
    <p>
     具体流程如下：
    </p>
    <blockquote>
     <ol>
      <li>
       在本地缓存中查询，如果有则返回对应IP，如果没有将请求发给DNS服务器
      </li>
      <li>
       当本地DNS服务器接收到查询后，先在服务器管理区域记录中查询，若没有再在服务器本地缓存中查询，如果没有将请求发送到根域名服务器
      </li>
      <li>
       根域名服务器负责解析请求的根域部分，然后将包含下一级域名信息的DNS服务地址返回给本地DNS服务器
      </li>
      <li>
       本地DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级域的DNS服务器地址
      </li>
      <li>
       按照上述递归方法逐级接近查询目标，最后在有目标域名的DNS服务器上找到相应的IP地址信息
      </li>
      <li>
       本地DNS服务器将最终查询到的IP返回给客户端，让客户端访问对应主机
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="HTTP_45">
     </a>
     HTTP协议
    </h4>
    <p>
     HTTP协议是一个简单的请求——响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。
     <br/>
     同其他应用层协议一样，是为了实现某一类具体应用的协议，并由某一运行在用户空间的应用程序来实现其功能。HTTP是一种协议规范，这种规范记录在文档上，为真正通过HTTP进行通信的HTTP的实现程序。
    </p>
    <p>
     HTTP是基于TCP协议，且面向连接的。典型的HTTP事务处理有如下的过程：
    </p>
    <ol>
     <li>
      客户端与服务器建立连接；
     </li>
     <li>
      客户端向服务器提出请求；
     </li>
     <li>
      服务器接受请求，并根据请求返回相应的数据作为应答响应；
     </li>
     <li>
      客户端与服务器关闭连接。
     </li>
    </ol>
    <p>
     <strong>
      HTTP协议报文格式
     </strong>
     <br/>
     HTTP报文由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Respone)构成
    </p>
    <p>
     请求由请求行，请求头，请求体组成
     <br/>
     请求行中包含请求方法、路径、版本号，请求头为多个key-value数据，请求正文包含一些请求的数据
     <br/>
     响应由响应行，响应头，响应体组成
     <br/>
     响应行中包含状态码，状态码描述，版本号，响应头为多个key-value数据，响应正文包含一些响应的数据
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ce1cd33d9bea1e3a15098552ee4c8dc6.png">
      <br/>
      <strong>
       常见HTTP响应状态码汇总
      </strong>
     </img>
    </p>
    <blockquote>
     <p>
      200 OK ：客户端请求成功
     </p>
    </blockquote>
    <p>
     3XX系列
    </p>
    <blockquote>
     <p>
      301 Moved Permanently ：
      <strong>
       请求的资源以被永久的移动到新URL中
      </strong>
      ，返回的Response中包含一个Location，浏览器会自动重定向到新URL，以后请求都会被新的URL替代
      <br/>
      302 Found ：与301类似，但
      <strong>
       请求的资源只是临时的被移动到新的URL中
      </strong>
      ，下次请求客户端继续使用原URL
      <br/>
      307 Temporary Redirect ：
      <strong>
       临时重定向
      </strong>
      ，类似于302，使用GET请求重定向
     </p>
    </blockquote>
    <p>
     4XX系列
    </p>
    <blockquote>
     <p>
      400 Bad Request ：
      <strong>
       客户端请求语法错误，服务器无法理解
      </strong>
      （在 ajax 请求后台数据时比较常见）
      <br/>
      401 Unauthorized ：
      <strong>
       请求要求用户的身份认证
      </strong>
      <br/>
      403 Forbidden ：
      <strong>
       服务器理解客户端请求，但是拒绝执行
      </strong>
      （一般用于用户级别为达到要求等等不支持访问）
      <br/>
      404 Not Found ：
      <strong>
       服务器无法根据客户端请求找到对应资源
      </strong>
      <br/>
      405 Method Not Allowed ：
      <strong>
       服务器不支持该方法
      </strong>
     </p>
    </blockquote>
    <p>
     5XX系列
    </p>
    <blockquote>
     <p>
      500 Internal Server Error ： 服务器内部错误，无法完成请求
      <br/>
      503 Service Unavailable ：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
     </p>
    </blockquote>
    <p>
     <strong>
      HTTP协议的特点
     </strong>
    </p>
    <ol>
     <li>
      支持服务器/客户端模式
     </li>
     <li>
      传输较快速，客户端向服务器发送请求，只需要传输请求方法和路径
     </li>
     <li>
      灵活，HTTP允许传输任意类型的数据对象
     </li>
     <li>
      无连接，每次连接只能处理一个请求，服务器处理完客户端请求，客户端收到响应后就断开连接
     </li>
     <li>
      无状态，协议本身对事务处理没有记忆能力，如果后序连接需要之前发送的信息时就需要重传
     </li>
    </ol>
    <p>
     <strong>
      HTTP1.0和HTTP1.1和HTTP2.0的区别：
     </strong>
    </p>
    <p>
     HTTP1.0和HTTP1.1的区别：
    </p>
    <blockquote>
     <ol>
      <li>
       长连接：HTTP1.0只支持浏览器与服务器的短连接，即每次请求都要重新建立连接，服务器无法记录每个历史请求，HTTP1.1支持长连接即在一次连接下，浏览器可以向服务器发送多次请求
      </li>
      <li>
       增加Host字段：HTTP1.0中认为每个服务器都绑定这唯一一个IP，所有发送的请求头URL中没有host信息，而HTTP1.1在请求和响应中都支持了host头域，且请求消息中如果没有Host头域会报告一个错误(400 Bad Request)
      </li>
      <li>
       缓存：HTTP1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。
      </li>
      <li>
       错误提示：HTTP1.0中定义了16个状态码，对错误或警告的提示不够具体。HTTP1.1引入了一个Warning头域，增加对错误或警告信息的描述，并且还新增了24个状态响应码，如409(Conflict)表示请求的资源与资源的当前状态发生冲突；410(Gone)表示服务器上的某个资源被永久性的删除
      </li>
     </ol>
    </blockquote>
    <p>
     HTTP1.X和HTTP2.0的区别
    </p>
    <blockquote>
     <ol>
      <li>
       增加二进制格式解析：HTTP1.X解析基于文本，而文本格式本身就具有多样性，很多场景下不方便，而引入二进制后，只有0和1组合，使解析更加方便也增强了健壮性
      </li>
      <li>
       多路复用：即每个request都是是用作连接共享机制的，每个request都对应一个id，使一个连接可以有多个请求，再根据id将request归属到不同的服务端请求里
      </li>
      <li>
       header压缩：HTTP1.X中，每次传输都要写点header头，占用了大量数据，因此HTTP2.0在客户端和服务端各保存了一份header fields表，每次传输时只需传输header的更新信息，将header fields表更新即可实现header传输
      </li>
      <li>
       服务端推送：HTTP2.0也添加了server push功能
      </li>
     </ol>
    </blockquote>
    <h4>
     <a id="HTTPS_109">
     </a>
     HTTPS协议
    </h4>
    <p>
     HTTPS同样作为应用层协议，可以说它是HTTP的升级版，增加了传输数据的安全性，HTTPS协议是在HTTP的基础上增加了一个SSL外壳，HTTPS运行在SSL上，SSL运行在TCP上，对数据的加密工作就是在SSL上完成的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/af68e2708be409f68538d95fd5fe25ed.png"/>
    </p>
    <p>
     其保证安全性的做法是通过证书验证和对信息混合加密的方式
     <br/>
     <strong>
      混合加密技术：
     </strong>
    </p>
    <blockquote>
     <p>
      混合加密技术：结合对称加密与非对称加密
      <br/>
      服务端生成私钥，再通过私钥生成公钥，然后将公钥放在证书中颁发给客户端
      <br/>
      使用公钥和私钥以非对称方式加密生成密钥
      <br/>
      客户端接下来的传输数据中，都会用密钥以对称方式对信息加密，再传输给服务端
     </p>
    </blockquote>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f262a082ac38ded06e7b4cf41ca9137a.png"/>
    </p>
    <p>
     <em>
      对于，上述提到的公钥和私钥，我们规定用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开
     </em>
    </p>
    <p>
     所以HTTPS传输数据是用被密钥加密的密文和用公钥加密的私钥来保证数据安全的
    </p>
    <blockquote>
     <p>
      <strong>
       HTTPS加密，只用对称加密可以吗？
      </strong>
      <br/>
      不行！无法保证安全性，因为只用对称加密即只用密钥对数据加密传输的话，如果传输途中，信息被第三方劫持，获取到密钥，那接下来的传输，第三方都可以通过密钥对数据解密从而得到原始数据。
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       HTTPS加密，只用非对称加密可以吗？两次呢？
      </strong>
      <br/>
      同样不行，如果只用非对称加密。客户端每次传输数据用公钥加密，服务端再用私钥解密这一方向看似安全，但当服务端发送数据用私钥加密，客户端收到用公钥解密时，第三方劫持到信息，但可能在此之前就获得公钥，因为首次服务端向客户端发送公钥是明文传输的。
      <br/>
      而换个角度如果使用两次非对称加密，即两组公钥，两组私钥，客户端服务端各持一组，理论上可以达到安全，但实际HTTPS并未采用，因为非对称加密耗时十分大
     </p>
    </blockquote>
    <p>
     <strong>
      证书：
     </strong>
    </p>
    <p>
     单有混合加密技术，看似已经保证了传输的安全性，实则还是有漏洞，问题就在于
     <strong>
      服务器根本无法识别发送过来的公钥是否是自己的
     </strong>
     ，如此以来在第三方劫持到数据后，自行再定义一个公钥B，并将公钥B传回给客服端，此时客户端就会利用该公钥B重新加密数据然后发送，此时第三方就可以通过自己的公钥B解密得到原始数据了。
    </p>
    <p>
     证书就解决了这一问题，指定颁发的为CA机构，当网站使用HTTPS时，会向CA机构申请一个数字证书，证书中可以存放公钥、数据等信息，由此以来，服务端就可以通过证书来向客户端证明正确的公钥是哪一个，以此保证安全。
     <br/>
     而对于证书，还有一些自己的放篡改机制，防止第三方获取到使用
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c104b4793096833f51568786e092632a.png"/>
    </p>
    <h3>
     <a id="_143">
     </a>
     传输层协议
    </h3>
    <p>
     传输层的主要功能是为了实现“端口到端口”的通信，以确保一条数据发送到主机上后，能够正确的传递到对应的端口上
    </p>
    <h4>
     <a id="UDP_145">
     </a>
     UDP协议
    </h4>
    <p>
     UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法，但是UDP也有自己的缺陷，一旦进行通信，就不知道对方是否接收到数据了，很有可能会造成传输数据的丢包问题
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fcbe89d154b5bfa782ccdd1a57b50f34.png">
      <br/>
      特点：
     </img>
    </p>
    <ul>
     <li>
      无连接：只需要知道目的ip和端口号就可以发送数据，无需建立连接
     </li>
     <li>
      不可靠：没有一系列机制来应对传输数据时的丢包问题
     </li>
     <li>
      面向数据报发送：应用层交给UDP什么样的报文，UDP就会发送什么样的，不会进行拆分，合并
     </li>
     <li>
      UDP一次传输的数据大小有限，最大64k
     </li>
    </ul>
    <p>
     UDP的传输流程
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/937170afa8937ce803c9eb16acecf387.png">
      <br/>
      UDP的适用范围：
     </img>
    </p>
    <p>
     由于UDP不属于连接型协议，所以具有资源消耗小。处理速度优的特点，因此经常使用与视频、音频通话传输中，因为发送的数据较多，偶尔丢包一两个不会产生太大影响
    </p>
    <h4>
     <a id="TCP_161">
     </a>
     TCP
    </h4>
    <p>
     因为上述讲到UDP的传输是不可靠的，经常会导致连接错误、数据丢包问题，针对这些问题规定了另一个传输层协议——TCP协议，TCP是一种面向连接、可靠的、基于字节流的传输层协议
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0004054de923e1fa8b83d0e87d4c837f.png"/>
    </p>
    <p>
     <strong>
      TCP的特点：
     </strong>
    </p>
    <ul>
     <li>
      面向连接：在传输数据是，要先建立起客户端与服务端的连接，才能进行数据传输
     </li>
     <li>
      可靠的通信：TCP输出数据中，会基于内部的各种机制保证数据传输到目的端口
     </li>
     <li>
      基于字节流：TCP传输数据是基于字节传输的，易于对数据的拆分与合并发送
     </li>
     <li>
      TCP的头部比UDP的开销要打，因为要存放更多的信息
     </li>
    </ul>
    <p>
     关于TCP内部各种机制，在这里不做过多的介绍，需要博友可以参考之前的一篇博客
     <a href="https://blog.csdn.net/m0_46233999/article/details/118445571">
      网络原理基础
     </a>
    </p>
    <p>
     <strong>
      TCP与UDP的区别：
     </strong>
    </p>
    <ul>
     <li>
      UDP是无连接的，TCP是有连接的
     </li>
     <li>
      UDP是不可靠的，TCP是可靠的
     </li>
     <li>
      UDP面向数据报，TCP面向字节流
     </li>
     <li>
      UDP比TCP的传输消耗小，速度更快
     </li>
    </ul>
    <p>
     这里分享一张神图，以便于更加形象的理解TCP和UDP的区别
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/33859728baaaf0da5cce61f75e07ab35.png"/>
    </p>
    <h3>
     <a id="_183">
     </a>
     网络层
    </h3>
    <p>
     网络层是基于数据链路层和传输层之间的第三层协议，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，
     <strong>
      进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端
     </strong>
     ，从而向传输层提供最基本的端到端的数据传送服务
    </p>
    <p>
     网络层的目的是
     <strong>
      实现两个端系统之间的数据透明传送
     </strong>
     ，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。
    </p>
    <h4>
     <a id="IP_188">
     </a>
     IP协议
    </h4>
    <p>
     IP协议是TCP/IP网络模型中的核心部分，他提供了一种分层的、无关硬件的寻址方式，可以在复杂的路由式网络中传递数据所需的服务
    </p>
    <p>
     IP协议可以将多个交换网络连接起来，在源地址和目的地址之间传输数据包，同时它还能提供数据的组装功能，以适应不同网络对数据包大小的要求
    </p>
    <p>
     预研知识：
    </p>
    <blockquote>
     <p>
      <strong>
       IP地址：
      </strong>
      <br/>
      IP地址是互联网协议特有的一种地址，它是IP协议提供的一种统一的地址格式，IP地址为互联网的每个网络和每台主机分配了一个逻辑地址，以此来屏蔽物理地址的差异
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       IP地址的格式：
      </strong>
      <br/>
      IP地址为32位地址，被分为4个部分，如XXX.XXX.XXX.XXX，IP地址又被划分为两个部分
      <br/>
      网络号：前三部分用于标识网段，保证相互连接的两个网段有不同标识
      <br/>
      主机号：由最后一部分组成，用于标识主机，保证处于同一网段的两台主机有不同的主机号
      <br/>
      通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同4
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       MAC地址：
      </strong>
      <br/>
      被称为物理地址，是用来标识网络中每个设备的，MAC地址是设备出厂之后就写死的
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       引入IP地址的目的：
      </strong>
      <br/>
      在单个局域网网段中，计算机与计算机之间可以使用数据链路层提供的MAC地址进行通信
      <br/>
      如果在路由式网络中，计算机之间就不能用MAC地址实现通信，主要是因为在路由式网络中，数据只是经过一次简单的利用两个计算机之间的MAC地址建立通信，而是需要进行多次的通信，每次跳转都会体目的主机更近一步，经历都次跳转，最终找到目的主机实现通信，而这个过程中，要知道每次向哪跳转才能更接近目的主机，必须使用一种逻辑化、层次化的寻址方案对网络进行组织，这就是 IP 地址
     </p>
    </blockquote>
    <blockquote>
     <p>
      IP协议数据报格式
      <img alt="这里是引用" src="https://i-blog.csdnimg.cn/blog_migrate/8e9d8dc288944166791ceebf26ec40f9.png"/>
     </p>
    </blockquote>
    <p>
     IP协议的工作方式：
    </p>
    <p>
     由于网络分为同网段和不同网段，所以会分成两种方式
    </p>
    <ul>
     <li>
      同网段：如果源地址主机和目的地址主机处于同一网段，则目的IP地址被 ARP协议 解析为MAC地址后，源主机会根据目的MAC地址直接将数据包发送给目的主机
     </li>
     <li>
      不同网段：
      <br/>
      如果源地址主机和目的地址主机不处于同一网段，则数据包会经历多个过程最终发送给目的主机
      <br/>
      1、网关(一般为路由器)的 IP地址 被 ARP协议 解析为 MAC地址，根据该 MAC地址 源主机会将数据包发送到网关
      <br/>
      2、网关根据数据包中的网段ID找到目标网络，如果找到，将数据包发送给目标网路，如果没有则重复第一步发送到更高一级网关
      <br/>
      3、数据包经过网关发送到正确的网段后，目标IP被 ARP协议 解析为MAC地址，在根据该 MAC地址 将数据包发送给目标地址的主机
     </li>
    </ul>
    <h4>
     <a id="ICMP_223">
     </a>
     ICMP协议
    </h4>
    <p>
     ICMP协议又叫控制报文协议，ICMP协议用于在IP 和 路由器之间传递控制消息，描述网络是否通畅、主机是否可达、路由器是否可用等网络状态，ICMP本身并不传输数据，但对于用户间数据的传递起着重要的作用
    </p>
    <p>
     作用：
     <br/>
     在数据包从源主机传输到目的主机的过程中，会经历一个或多个路由器，而数据包在经过这些路由器传输过程中，可能会遇到很多问题，最终导致数据包没有成功传递给目的主机。为了了解数据包在传输过程中在哪个环节出了问题，就需要用到ICMP协议，它可以跟踪数据包，并把消息返回给源主机。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e18dfc154d483d1d72fbd55ccf4ca2f6.png"/>
    </p>
    <h3>
     <a id="_231">
     </a>
     数据链路层
    </h3>
    <p>
     数据链路层是TCP/IP网络模型的第二层，基于物理层和网络层之间，数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是
     <strong>
      将源自物理层来的数据可靠地传输到相邻节点的目标机网络层
     </strong>
     。
    </p>
    <h4>
     <a id="ARP_234">
     </a>
     ARP协议
    </h4>
    <p>
     ARP协议是数据进行网络传输过程中，通过IP地址向MAC地址的转换，解决网络层和物理层衔接问题
    </p>
    <p>
     引入ARP协议的目的：
     <br/>
     由于 IP 地址和 MAC 地址定位方式不同，ARP 协议成为数据传输的必备协议。主机发送信息前，必须通过 ARP 协议获取目标 IP 地址对应的 MAC 地址，才能正确地发送数据包。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6d04fb7fd6db1602bf58b2f537e26449.png"/>
     <br/>
     ARP的工作流程：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/030f9cd8de90076b66e2595f27bee52d.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/44e11537ccbf22052b29cd81784b1cf0.png"/>
     <br/>
     如图展示的是同一网段下的两台主机，ARP的工作流程
    </p>
    <ul>
     <li>
      主机A以广播的形式向该网段内的所有主机发送ARP请求，请求中包含了目的主机的IP地址
     </li>
     <li>
      主机B接收到请求，通过请求中的目的IP地址发现自己是主机A要找的，返回响应，响应包括主机B的 MAC地址
     </li>
    </ul>
    <p>
     ARP缓存：
     <br/>
     在请求目标主机的 MAC 地址时，每次获取目标主机 MAC 地址都需要发送一次 ARP 请求，然后根据响应获取到 MAC 地址。
    </p>
    <p>
     为了避免重复发送 ARP 请求，每台主机都有一个 ARP 高速缓存。当主机得到 ARP 响应后，将目标主机的 IP 地址和物理地址存入本机 ARP 缓存中，并保留一定时间。
    </p>
    <p>
     只要在这个时间范围内，下次请求 MAC 地址时，直接查询 ARP 缓存，而无须再发送 ARP 请求，从而节约了网络资源。
    </p>
    <h3>
     <a id="_255">
     </a>
     物理层
    </h3>
    <p>
     物理层，顾名思义就是用物理手段将两个要通信的电脑连接起来，主要用来传输0、1光电信号，因为这一层过于偏硬件，所以本文不做过多的赘述
    </p>
    <h3>
     <a id="_258">
     </a>
     整体的网络传输流程
    </h3>
    <p>
     经过以上对网络传输层中每一层理解下面我们来看看，当访问一个网页时，到底发生了什么？
    </p>
    <p>
     主机A：发送http://www.baidu.com网络数据报
    </p>
    <ol>
     <li>
      DNS解析：将域名转换成对应IP地址(本机DNS缓存栈开始找—&gt;逐级向上查找，如果根域服务器找不到，表示公网上没有该域名主机)
     </li>
     <li>
      找到IP后：通过目的IP找到对应的目的MAC地址
     </li>
     <li>
      根据目的IP计算目的主机是否和主机A处于同一网段
     </li>
     <li>
      如在同网段：接通过ARP协议解析出对应的目的MAC，跳转到底9步
     </li>
     <li>
      如不在同一网段：发送数据报到网关，现在ARP缓存表查找，通过网关IP查找MAC地址，找不到发送查询MAC广播数据报，最终返回网关自己的MAC
     </li>
     <li>
      交换机转发：在MAC地址转换表中找到对应MAC交换机接口
     </li>
     <li>
      路由器接收：分用数据报
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/475a1621909b76668ce3f3b5318e33ba.png"/>
     </li>
     <li>
      途中的设备：与第7步同样操作如目的IP对应的MAC地址不是当前设备则继续重复该操作继续往更接近目的IP的路由发送
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/571b7dd654346e94c50b674aed5a3467.png"/>
     </li>
     <li>
      找到目的主机B，主机B的服务器开始接受分用请求，解析，最终组织响应
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bc53eb012a0b793068370db0968f9896.png"/>
     </li>
     <li>
      同上述操作一样，由主机B向主机A发送数据
     </li>
     <li>
      最终主机A接受到数据报，经过分用，解析，最终得到响应
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34363233333939392f:61727469636c652f64657461696c732f313139343535333532" class_="artid" style="display:none">
 </p>
</div>
