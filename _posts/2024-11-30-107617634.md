---
layout: post
title: "操作系统死锁-四个必要条件"
date: 2024-11-30 15:41:14 +0800
description: "操作系统死锁 四个必要条件操作系统中有若干进程并发执行，它们不断申请、使用、释放系统资源，虽然系统的"
keywords: "死锁的四个必要条件"
categories: ['面试题', '笔记']
tags: ['操作系统']
artid: "107617634"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=107617634
    alt: "操作系统死锁-四个必要条件"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统死锁 四个必要条件
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="__0">
     </a>
     操作系统死锁 四个必要条件
    </h3>
    <p>
     <strong>
      1.
     </strong>
     死锁：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。
    </p>
    <p>
     <strong>
      2.
     </strong>
     产生死锁的原因：
    </p>
    <p>
     （1）竞争不可抢占性资源。
    </p>
    <p>
     （2）竞争可消耗资源。
    </p>
    <pre><code class="prism language-cpp">当系统中供多个进程共享的资源如打印机，公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。
</code></pre>
    <p>
     （3）进程推进顺序不当。
    </p>
    <pre><code class="prism language-cpp"> 进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。
</code></pre>
    <p>
     如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。
    </p>
    <pre><code class="prism language-cpp">  一个线程也可引起死锁。
</code></pre>
    <p>
     <strong>
      3.
     </strong>
     产生死锁的四个必要条件：
    </p>
    <p>
     （1） 互斥条件：一个资源每次只能被一个进程使用。
    </p>
    <p>
     （2） 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
    </p>
    <p>
     （3） 不可抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺，只能在进程使用完时由自己释放。
    </p>
    <p>
     （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
    </p>
    <p>
     这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。因此可以写下如下的预防死锁的方法。
    </p>
    <p>
     4.避免死锁的方法：
    </p>
    <p>
     （1）破坏“互斥”条件:就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。
    </p>
    <p>
     （2）破坏“请求和保持”条件:在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。
    </p>
    <p>
     <code>
      方法一
     </code>
     ：所有进程在运行之前，必须一次性地申请在整个运行过程中所需的全部资源。这样，该进程在整个运行期间，便不会再提出资源请求，从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不分配给该进程，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件。
    </p>
    <p>
     该方法优点：简单、易行且安全。
    </p>
    <p>
     缺点：
    </p>
    <ol>
     <li>
      <p>
       资源被严重浪费，严重恶化了资源的利用率。
      </p>
     </li>
     <li>
      <p>
       使进程经常会发生饥饿现象。
      </p>
     </li>
    </ol>
    <p>
     <code>
      方法二
     </code>
     ：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。
    </p>
    <p>
     （3）破坏“不可抢占”条件：允许对资源实行抢夺。
     <br/>
     方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
     <br/>
     方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。
    </p>
    <p>
     （4）破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。
    </p>
    <p>
     利用银行家算法避免死锁：
    </p>
    <p>
     银行家算法:
    </p>
    <p>
     设进程i提出请求Request[j]，则银行家算法按如下规则进行判断。
    </p>
    <p>
     (1) 如果Request[j]≤Need[i,j]，则转向（2），否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
    </p>
    <p>
     (2) 如果Request[j]≤Available[j]，则转向（3）；否则表示尚无足够资源，Pi需等待。
    </p>
    <p>
     (3) 假设进程i的申请已获批准，于是修改系统状态：
    </p>
    <p>
     Available[j]=Available[j]-Request[i]
    </p>
    <p>
     Allocation[i,j]=Allocation[i,j]+Request[j]
    </p>
    <p>
     Need[i,j]=Need[i,j]-Request[j]
    </p>
    <p>
     (4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。
    </p>
    <p>
     安全性算法：
    </p>
    <p>
     (1) 设置两个工作向量Work=Available；Finish[i]=False
    </p>
    <p>
     (2) 从进程集合中找到一个满足下述条件的进程，
    </p>
    <pre><code class="prism language-cpp"> Finish <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>False<span class="token punctuation">;</span>

 Need<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span>≤Work<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

 如找到，执行<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>；否则，执行<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     (3) 设进程获得资源，可顺利执行，直至完成，从而释放资源。
    </p>
    <pre><code class="prism language-cpp">Work<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Work<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>Allocation<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

Finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>True<span class="token punctuation">;</span>

Go to step <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     (4) 如所有的进程Finish[i]=true，则表示安全；否则系统不安全。
    </p>
    <p>
     <strong>
      5.
     </strong>
     死锁的解除：
    </p>
    <p>
     一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要两种方法：
    </p>
    <ol>
     <li>
      <p>
       抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。
      </p>
     </li>
     <li>
      <p>
       终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。
      </p>
     </li>
    </ol>
    <p>
     <mark>
      总结：
     </mark>
    </p>
    <p>
     一般情况下,如果同一个线程先后两次调用lock,在第二次调用时,由于锁已经被占用,该线程会挂起等待别的线程释放锁,然而锁正是被自己占用着的,该线程又被挂起而没有机会释放锁,因此就永远处于挂起等待状态了,这叫做死锁(Deadlock)。另⼀一种典型的死锁情形是这样:线程A获得了锁1,线程B获得了锁2,这时线程A调⽤用lock试图获得锁2,结果是需要挂起等待线程B释放锁2,而这时线程B也调⽤用lock试图获得锁1,结果是需要挂起等待线程A释放锁1,于是线程A和B都永远处于挂起状态了。
    </p>
    <p>
     <mark>
      注意：
     </mark>
    </p>
    <p>
     写程序时应该尽量避免同时获得多个锁,如果一定有必要这么做,则有一个原则:如果所有线程在需要多个锁时都按相同的先后顺
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34313936393639302f:61727469636c652f64657461696c732f313037363137363334" class_="artid" style="display:none">
 </p>
</div>


