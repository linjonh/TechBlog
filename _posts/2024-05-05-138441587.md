---
layout: post
title: "一Socket通信"
date: 2024-05-05 15:49:43 +0800
description: "本文详细介绍了Socket在Python中的概念、类型（TCP、UDP和原始套接字），如何创建Soc"
keywords: "socket通信"
categories: ['Python']
tags: ['Python']
artid: "138441587"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138441587
    alt: "一Socket通信"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     一、Socket通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="11_Socket_0">
     </a>
     1.1 什么是Socket
    </h2>
    <p>
     Socket（套接字）是操作系统中I/O系统的延伸部分，它可以使进程和机器之间的通信成为可能。Socket实际上是一个通信端点，它包含了一个 IP 地址和一个端口号。IP 地址标识了主机，而端口号标识了主机上的进程。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。
    </p>
    <h2>
     <a id="12_Socket_2">
     </a>
     1.2 Socket类型
    </h2>
    <p>
     在python网络编程中，Socket有三种主要类型
    </p>
    <ul>
     <li>
      <strong>
       TCP流套接字（socket.SOCK_STREAM）
      </strong>
      ：基于
      <strong>
       TCP(传输控制协议，The Transmission Control Protocol)
      </strong>
      ，提供
      <strong>
       面向连接的、可靠的、双向的
      </strong>
      数据流通信。TCP需要进行连接的建立和关闭过程，以及数据的确认与重传，延迟较高，适用于大量数据传输的场景，如文件传输、视频流等。
     </li>
     <li>
      <strong>
       UDP数据报套接字（socket.SOCK_DGRAM）
      </strong>
      ：基于
      <strong>
       UDP(用户数据报协议， User DatagramProtocol)
      </strong>
      ，提供
      <strong>
       无连接的、不可靠
      </strong>
      的通信。UDP不需要建立连接，延迟较低，且支持广播和多播，可以将数据包发送给多个接收者，适用于对实时性要求不高的小数据量传输场景。
     </li>
     <li>
      <strong>
       原始套接字（socket.SOCK_RAW）
      </strong>
      ：允许程序直接访问网络层协议，如IP协议，程序可以直接接收和发送原始数据包，而无需进行传输层（如TCP和UDP）的处理。
     </li>
    </ul>
    <h2>
     <a id="13_Socket_7">
     </a>
     1.3 建立Socket对象
    </h2>
    <p>
     在建立Socket对象的时候，我们需要告诉系统两件事情：
     <strong>
      协议家族
     </strong>
     和
     <strong>
      socket类型
     </strong>
     。通信类型指明用什么Socket类型来传输数据，常见的协议包括IPv4、IPv6、IPX/SPX、AFP等等，目前最常用的是IPv4。python的socket模块支持以下几种常见的协议家族。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        常见协议族
       </th>
       <th>
        表示方法
       </th>
       <th>
        应用场景
       </th>
       <th>
        备注
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         IPv4协议族
        </strong>
       </td>
       <td>
        <strong>
         AF_INET
        </strong>
       </td>
       <td>
        用于Internet网络
       </td>
       <td>
        使用IP地址和端口号来标识套接字。最常用的协议族，用于TCP和UDP通信。
       </td>
      </tr>
      <tr>
       <td>
        IPv6协议族
       </td>
       <td>
        AF_INET6
       </td>
       <td>
        用于Internet网络
       </td>
       <td>
        与IPv4类似，但使用IPv6地址。
       </td>
      </tr>
      <tr>
       <td>
        Unix域协议族
       </td>
       <td>
        AF_UNIX
       </td>
       <td>
        用于同一台计算机上进程间通信
       </td>
       <td>
        使用文件系统路径作为套接字地址。
       </td>
      </tr>
      <tr>
       <td>
        Netlink协议族
       </td>
       <td>
        AF_NETLINK
       </td>
       <td>
        用于与Linux内核通信
       </td>
       <td>
        主要用于配置网络和获取网络状态信息
       </td>
      </tr>
      <tr>
       <td>
        蓝牙协议族
       </td>
       <td>
        AF_BLUETOOTH
       </td>
       <td>
        用于蓝牙设备之间的通信
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        原始套接字协议族
       </td>
       <td>
        AF_PACKET
       </td>
       <td>
        用于直接访问数据链路层的数据包
       </td>
       <td>
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="prism language-python"><span class="token keyword">import</span> socket

<span class="token comment"># 我们通过socket()函数创建一个套接字对象</span>
s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
<span class="token comment"># 通过connect()函数进行连接，我们需要提供一个元组，包含远程主机名或IP地址、远程端口</span>
s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre>
    <h3>
     <a id="131_getservbyname_29">
     </a>
     1.3.1 getservbyname()查询端口号
    </h3>
    <p>
     getservbyname() 函数是socket 模块中用于根据服务名称获取对应端口号的函数。它通过查询系统的服务配置文件（通常是 /etc/services）来查找服务名称对应的端口号。
    </p>
    <p>
     使用方法如下：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> socket

<span class="token comment"># 根据服务名获取端口号</span>
<span class="token triple-quoted-string string">'''
未指定传输协议类型
如果在服务器配置文件中只有一个对应的端口号，则返回该端口号
如果服务名称对应多个端口号，会引发‘socket.error’错误
'''</span>
port1 <span class="token operator">=</span> socket<span class="token punctuation">.</span>getservbyname<span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'HTTP服务的默认端口号是：'</span><span class="token punctuation">,</span> port1<span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''
指定传输协议(tcp),返回在指定传输协议下的端口号
如果该服务名称在系统配置文件中没有对应的端口号，或者指定的传输协议不支持该服务，则会引发‘socket.error’错误
'''</span>                                                                                                              
port2 <span class="token operator">=</span> socket<span class="token punctuation">.</span>getservbyname<span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">,</span> <span class="token string">'tcp'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'HTTPS服务的默认端口号是：'</span><span class="token punctuation">,</span> port2<span class="token punctuation">)</span>
</code></pre>
    <h3>
     <a id="132_socket_52">
     </a>
     1.3.2 从socket获取信息
    </h3>
    <p>
     我们可以通过getsockname()和getpeername()来分别获取本机和远程机器的IP地址和端口号
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> socket

s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'www.baidu.com'</span><span class="token punctuation">,</span> <span class="token number">443</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 获取本机IP地址和端口号</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'本机IP及端口：'</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>getsockname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 获取远程机器的IP地址和端口号</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'远程机器IP及端口：'</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>getpeername<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 获取返回类型(元组)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>getsockname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     程序运行结果如下：
     <br/>
     <img alt="运行结果" src="https://i-blog.csdnimg.cn/blog_migrate/bfc4adde808ab6df2fcf806cf9f1d4ce.png"/>
    </p>
    <p>
     <strong>
      注意
     </strong>
     ：在客户端，端口号是由操作系统随机分配的，所以每次运行程序的时候会发现端口号不一样！
    </p>
    <h3>
     <a id="133_socket_70">
     </a>
     1.3.3 socket通信
    </h3>
    <p>
     利用socket模块进行通信通常包括以下步骤：
    </p>
    <ol>
     <li>
      <strong>
       创建套接字
      </strong>
      ：使用socket()函数创建套接字对象，指定地址族和套接字类型。
     </li>
     <li>
      <strong>
       绑定地址和端口（可选）
      </strong>
      ：如果是服务器，可以使用bind()方法绑定地址和端口。
     </li>
     <li>
      <strong>
       监听连接（仅服务器端）
      </strong>
      ：使用listen()方法开始监听连接。
     </li>
     <li>
      <strong>
       接受连接（仅服务器端）
      </strong>
      ：使用accept()方法接受客户端的连接请求，返回新的套接字对象和客户端地址。
     </li>
     <li>
      <strong>
       发送和接收数据
      </strong>
      ：使用send()方法发送数据，使用recv()方法接收数据。
     </li>
     <li>
      <strong>
       关闭连接
      </strong>
      ：使用close()方法关闭套接字。
     </li>
    </ol>
    <p>
     下面是一个例子，演示客户端和服务器端的通信：
    </p>
    <blockquote>
     <p>
      关于服务器程序具体实现请参考
      <a href="https://blog.csdn.net/weixin_75094128/article/details/138468156">
       第二章 TCP与UDP服务器简单实现及测试
      </a>
     </p>
    </blockquote>
    <p>
     <strong>
      服务器端
     </strong>
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> socket

<span class="token comment"># 创建套接字对象</span>
server_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
<span class="token comment"># 绑定地址和端口</span>
server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 开始监听连接</span>
server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Wating for connection...'</span><span class="token punctuation">)</span>
<span class="token comment"># 接受连接</span>
client_socket<span class="token punctuation">,</span> client_addr <span class="token operator">=</span> server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Connection from'</span><span class="token punctuation">,</span> client_addr<span class="token punctuation">)</span>
<span class="token comment"># 接收数据</span>
data <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 发送响应数据</span>
client_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b'Hello,client!'</span><span class="token punctuation">)</span>
<span class="token comment"># 关闭连接</span>
client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
server_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      客户端
     </strong>
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> socket

<span class="token comment"># 创建套接字对象</span>
client_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
<span class="token comment"># 连接服务器</span>
client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 发送数据</span>
client_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b'Hello Server!'</span><span class="token punctuation">)</span>
<span class="token comment"># 接收响应数据</span>
data <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received:'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 关闭连接</span>
client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      运行测试
     </strong>
     <br/>
     我们先运行服务器端代码，控制台显示如下：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/dd14fd554a02b327ebad39c26a9be695.png">
      <br/>
      再运行客户端代码，控制台显示如下：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/90d8861985a569c6174b918832df6825.png">
       <br/>
       再回到服务器端，控制台显示如下：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3bcabfd18ec3e352969393385a6ca55b.png">
        <br/>
        这个例子中，服务器端创建了一个TCP套接字，绑定到地址"127.0.0.1"的端口12345，并开始监听连接。客户端创建了一个TCP套接字，并连接到服务器。然后，客户端发送数据到服务器，服务器接收并处理数据，然后发送响应数据给客户端。从而实现了客户端与服务器间的通信。
       </img>
      </img>
     </img>
    </p>
    <h2>
     <a id="14_socket_135">
     </a>
     1.4 socket异常
    </h2>
    <p>
     使用socket进行网络编程时，常见的有以下异常出现：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        异常
       </th>
       <th>
        原因
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        socket.error
       </td>
       <td>
        所有socket相关错误的基类
       </td>
      </tr>
      <tr>
       <td>
        socket.timeout
       </td>
       <td>
        操作超时
       </td>
      </tr>
      <tr>
       <td>
        socket.herror
       </td>
       <td>
        DNS解析错误
       </td>
      </tr>
      <tr>
       <td>
        socket.gaierror
       </td>
       <td>
        获取地址信息引发的错误
       </td>
      </tr>
      <tr>
       <td>
        socket.ConnectionAbortedError
       </td>
       <td>
        连接被对端终止
       </td>
      </tr>
      <tr>
       <td>
        socket.ConnectionRefuseError
       </td>
       <td>
        连接被对端拒绝
       </td>
      </tr>
      <tr>
       <td>
        socket.ConnectionResetError
       </td>
       <td>
        连接被对端重置
       </td>
      </tr>
      <tr>
       <td>
        socket.NotConnectedError
       </td>
       <td>
        未连接时尝试操作
       </td>
      </tr>
     </tbody>
    </table>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37353039343132382f:61727469636c652f64657461696c732f313338343431353837" class_="artid" style="display:none">
 </p>
</div>


