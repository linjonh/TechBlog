---
layout: post
title: "操作系统知识点整理-面经"
date: 2023-11-09 16:09:43 +0800
description: "进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。引入线"
keywords: "操作系统面经"
categories: ['计算机专业复习资料']
tags: ['面试', '考研', '系统架构', '服务器', '前端', 'Java']
artid: "134313347"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=134313347
    alt: "操作系统知识点整理-面经"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统知识点整理-面经
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="1_5">
     </a>
     1.操作系统引论
    </h2>
    <h3>
     <a id="1_7">
     </a>
     （1）什么是操作系统？
    </h3>
    <p>
     操作系统是管理计算机系统资源，控制程序执行，改善人机界面，为应用软件提供支持的一种系统软件，它合理的组织计算机的工作流程，是用户与计算机硬件系统之间的接口。
    </p>
    <h3>
     <a id="2_11">
     </a>
     （2）操作系统的作用
    </h3>
    <p>
     ·作为用户与计算机硬件系统之间的接口
    </p>
    <p>
     ·作为计算机系统资源的管理者
    </p>
    <p>
     ·实现了对计算机资源的抽象与扩充
    </p>
    <h3>
     <a id="3_19">
     </a>
     （3）操作系统的特性
    </h3>
    <ul>
     <li>
      并发
     </li>
    </ul>
    <p>
     并发是指两个或多个事件在同一时间间隔内执行
    </p>
    <ul>
     <li>
      共享
     </li>
    </ul>
    <p>
     共享是计算机资源可以被多个可以并发执行的进程或者线程共同使用
    </p>
    <p>
     互斥共享：当某一进程访问完并释放该资源后，才允许另一进程访问。
    </p>
    <p>
     同时共享：计算机资源允许在同一时刻内被多个进程同时访问。
    </p>
    <ul>
     <li>
      虚拟
     </li>
    </ul>
    <p>
     虚拟指通过某种技术将一个物理实体变为多个逻辑上的对应物。
    </p>
    <ul>
     <li>
      异步
     </li>
    </ul>
    <p>
     指多道程序环境下多个程序并发执行，但由于资源有限，每个程序在何时执行，程序间的执行顺序以及完成每道程序所需的时间都是不确定和不可预知的，进程以不可预知的速度向前推进。
    </p>
    <h3>
     <a id="4_45">
     </a>
     （4）并发并行的区别
    </h3>
    <p>
     并发是两个或多个事件在同一时间间隔内执行。
    </p>
    <p>
     并行是两个或多个事件在同一时刻执行。
    </p>
    <p>
     在多处理机环境下，多个可并发执行的程序可以分散到各个处理机上并行执行。
    </p>
    <p>
     在多道程序处理环境下，一段时间内，宏观上有多个程序在同时执行，但是在单处理机环境下，每个时刻只能有一个程序执行，所以微观上这些程序只是在分时交替的执行。
    </p>
    <h3>
     <a id="5_55">
     </a>
     （5）操作系统结构
    </h3>
    <ul>
     <li>
      大内核结构
     </li>
    </ul>
    <p>
     模块化分层式结构
    </p>
    <p>
     优点：系统内各个模块间直接调用函数实现功能，除了函数调用的开销外没有额外开销。
    </p>
    <p>
     缺点：庞大的操作系统有数以千计的函数，复杂的调用关系势必会造成操作系统的维护困难。
    </p>
    <ul>
     <li>
      微内核结构
     </li>
    </ul>
    <p>
     微内核是精心设计的，运行在核心态，能实现现代操作系统核心功能的小型内核，它将那些不必在核心态执行的功能移到用户态执行。
    </p>
    <p>
     优点：各个服务器模块之间具有相对独立性，维护比较容易。
    </p>
    <p>
     缺点：内核发出请求，服务器做出应答，内核与服务器之间通过通信机制进行交互，使得微内核的效率大打折扣。会引起更多的上下文切换。
    </p>
    <h3>
     <a id="6_75">
     </a>
     （6）微内核的功能
    </h3>
    <p>
     进程（线程）管理
    </p>
    <p>
     低级存储器管理
    </p>
    <p>
     中断和陷入处理
    </p>
    <h3>
     <a id="7_83">
     </a>
     （7）操作系统发展历史
    </h3>
    <p>
     手工操作阶段-&gt;早期批处理-&gt;多道程序批处理操作系统-&gt;分时操作系统-&gt;实时操作系统-&gt;网络操作系统-&gt;分布式操作系统-&gt;个人计算机操作系统
    </p>
    <p>
     操作系统基本类型：多道程序批处理操作系统-&gt;分时操作系统-&gt;实时操作系统
    </p>
    <p>
     多道程序批处理：用户脱机使用计算机，作业成批处理，系统内多道程序并发执行，交互性差
    </p>
    <p>
     分时操作系统：允许多个用户同时使用计算机，具有每个用户独立使用计算机的独占性，人机交互性强，系统响应及时
    </p>
    <p>
     实时操作系统：能对控制对象做出及时反映，可靠性高，响应及时，但是资源利用率低。
    </p>
    <h3>
     <a id="8_95">
     </a>
     （8）分时操作系统与实时操作系统的比较
    </h3>
    <p>
     设计目标：分时系统是为多用户提供的通用交互型开发运行环境；实时系统是为特殊用途提供的专用系统。
    </p>
    <p>
     响应时间：分时系统以用户能够接受的响应时间为准；实时系统与受控对象和应用场合有关。
    </p>
    <p>
     交互性：分时系统交互性强；实时系统较弱。
    </p>
    <h3>
     <a id="9_103">
     </a>
     （9）分布式操作系统与网络操作系统的比较
    </h3>
    <p>
     耦合程度：分布式操作系统是紧密耦合系统，分布式操作系统是在各机上统一建立的操作系统同质，直接管理CPU、外设、存储器，统一进行全系统的管理；网络操作系统通常允许异种操作系统进行互连，各机上各种服务程序需按相同网络协议协议同质。
    </p>
    <p>
     并行性：分布式操作系统可将一个进程分散到各机上并行运行；网络操作系统各机上的进程独立。
    </p>
    <p>
     透明性：分布式操作系统的网络资源调度对用户透明，用户不了解所占有资源的位置；网络操作系统对网络资源的使用要由用户明确指定。
    </p>
    <p>
     健壮性：分布式操作系统要有更高的健壮性。
    </p>
    <h3>
     <a id="10_113">
     </a>
     (10)系统调用
    </h3>
    <p>
     系统调用是操作系统为应用程序提供的接口，可以理解为可供应用程序调用的特殊函数，应用程序可以发出系统调用向向操作系统提出请求，操作系统代为完成。
    </p>
    <p>
     系统调用（按功能分类）：设备管理、文件管理、进程通信、进程控制、内存管理
    </p>
    <h3>
     <a id="11_119">
     </a>
     （11）系统调用和库函数的区别
    </h3>
    <p>
     库函数是语言或应用程序的一部分，库函数可以在用户态下执行，库函数可以涉及系统调用，比如创建文件函数，也可以不涉及系统调用，比如绝对值函数。不涉及系统调用的函数效率要比涉及的效率高，因为使用系统调用时需要上下文切换以及状态转换。
    </p>
    <p>
     系统调用是操作系统的一部分，是内核为应用程序提供的接口，必须在核心态下执行。
    </p>
    <h3>
     <a id="12_125">
     </a>
     （12）中断和异常
    </h3>
    <img src="image/interrupt.png">
     <p>
      中断：计算机在运行过程中，出现某些意外情况需要主机干预时，主机停止正在运行的程序转去执行处理意外情况的中断服务程序，处理完毕后又返回原被暂停的程序继续执行。
     </p>
     <p>
      中断分为内中断和外中断
     </p>
     <p>
      内中断信号来自CPU内部，与当前执行指令有关；外中断信号来自CPU外部，与当前执行指令无关。
     </p>
     <h3>
      <a id="13_135">
      </a>
      （13）处理器为什么要区分用户态和核心态？在什么情况下进行两种方式的切换？
     </h3>
     <p>
      区分执行态的目的是保护系统程序，用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用请求操作系统代为完成，以便保证系统的稳定性和安全性，防止用户程序随意访问或者修改系统中的重要资源，影响其他进程的执行。
     </p>
     <p>
      用户态到核心态的转换发生在中断产生时，并且中断是唯一条件，由硬件完成；核心态到用户态的转换发生在中断返回应用程序时，由一条修改PSW（进程状态字）程序状态寄存器的特权指令完成。
     </p>
     <h2>
      <a id="2_141">
      </a>
      2.进程与线程
     </h2>
     <h3>
      <a id="21_143">
      </a>
      2.1进程概述
     </h3>
     <h4>
      <a id="1_145">
      </a>
      （1）什么是进程？什么是线程？
     </h4>
     <p>
      进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。
     </p>
     <p>
      引入线程后，线程是调度的独立单位。
     </p>
     <p>
      引入进程的目的是更好的使多道程序并发执行，提高资源利用率和系统吞吐量。
     </p>
     <p>
      引入线程的目的是减小程序并发执行时的时空开销，提高操作系统的并发性能。
     </p>
     <h4>
      <a id="2_155">
      </a>
      （2）进程和线程的比较
     </h4>
     <p>
      ·调度：在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大；在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。
     </p>
     <p>
      ·并发性：在引入线程的操作系统中，不仅进程可以并发执行，而且一个进程中的多个线程也可以并发执行，使操作系统有了更好的并发性，提高了系统吞吐量。
     </p>
     <p>
      ·拥有资源：进程是系统中拥有资源的基本单位，而线程不拥有资源，但可以访问其隶属进程的系统资源。
     </p>
     <p>
      ·系统开销：在创建、撤销或切换进程时的开销大于线程，线程切换只需要保存和设置较少寄存器内容。
     </p>
     <p>
      ·支持多处理机系统：对于单线程进程，进程只能运行在一个处理机上，对于多线程进程，可以将进程中的多个线程分散到各个处理机上执行。
     </p>
     <p>
      ·地址空间和其他资源：每个进程都拥有独立的地址空间和资源，而同一进程中的各线程共享进程资源，且对其他进程不可见。
     </p>
     <p>
      ·通信：进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性；线程间可以直接读写进程数据段来进行通信。
     </p>
     <p>
      ·线程是进程的一个组成部分，每个进程在创建时通常只有一个线程，需要时可以创建其他线程。
     </p>
     <h4>
      <a id="3_173">
      </a>
      （3）进程的组成和特性？
     </h4>
     <p>
      进程由数据段、程序段和进程控制块（PCB）组成，PCB是进程存在的唯一标志，系统利用PCB来管理和控制进程。
     </p>
     <p>
      进程特点：
     </p>
     <p>
      动态性(进程最基本的特性)：进程是程序的执行过程，是动态的概念
     </p>
     <p>
      并发性：多个进程可以在同一时间间隔并发执行
     </p>
     <p>
      独立性：进程拥有独立的地址空间和资源
     </p>
     <p>
      异步性：由于系统资源有限，并发执行的进程在何时开始执行，执行的顺序与执行多长时间是不确定和不可预知的，进程以不可预知的速度向前推进。
     </p>
     <p>
      结构性：进程由数据段、程序段和进程控制块组成，具有结构性
     </p>
     <p>
      交互性：
     </p>
     <h4>
      <a id="4_191">
      </a>
      （4）进程和程序的区别
     </h4>
     <p>
      程序是指令的集合。是静态的概念；而进程是程序的执行过程，是动态的概念。
     </p>
     <p>
      程序可以作为资料永久保存；而进程具有生命周期，存在是暂时的。
     </p>
     <p>
      程序与进程不是一一对应的，一个进程可以运行多个程序，一个程序也可以在多个进程中运行。
     </p>
     <p>
      进程是有结构的——由程序段、数据段和PCB组成，而程序没有。
     </p>
     <p>
      进程可以生成子进程，程序不可以。
     </p>
     <p>
      进程具有并发性，程序没有。
     </p>
     <p>
      进程是竞争计算机资源的基本单位。
     </p>
     <h4>
      <a id="5_207">
      </a>
      （5）程序顺序执行时的特征
     </h4>
     <p>
      程序运行的顺序性
     </p>
     <p>
      程序运行环境的封闭性
     </p>
     <p>
      程序计算结果的可再现性
     </p>
     <h4>
      <a id="6_215">
      </a>
      （6）程序并发执行的特征
     </h4>
     <p>
      间断性
     </p>
     <p>
      失去封闭性
     </p>
     <p>
      不可再现性
     </p>
     <p>
      计算与结果不再一一对应
     </p>
     <h4>
      <a id="7_225">
      </a>
      （7）程序输入一样运行结果为什么不一样？
     </h4>
     <p>
      程序在并发执行时，由于失去了封闭性，其计算结果已经和并发执行速度有关，从而使程序失去了可再现性。
     </p>
     <h4>
      <a id="8_229">
      </a>
      （8）进程控制块的作用
     </h4>
     <p>
      系统借助PCB来控制和管理进程，PCB是系统感知进程存在的唯一标志。
     </p>
     <p>
      PCB中包含：进程标识符——标志各个进程
     </p>
     <p>
      ​ 进程控制和管理信息
     </p>
     <p>
      ​ 进程当前状态、进程优先级——作为处理机调度的依据
     </p>
     <p>
      ​ 处理机相关信息——当进程被切换时，处理及状态信息都必须保存在相应的PCB中，以便该进程重新执行时，能从断点继续执行。
     </p>
     <p>
      ​ 资源分配清单
     </p>
     <h4>
      <a id="9_243">
      </a>
      （9）什么是上下文？
     </h4>
     <p>
      执行过的指令和数据在相关寄存器和堆栈中的内容称为上文。
     </p>
     <p>
      正在执行的指令和数据在相关寄存器和堆栈中的内容称为正文。
     </p>
     <p>
      待执行的指令和数据在相关寄存器和堆栈中的内容称为下文。
     </p>
     <h3>
      <a id="22_251">
      </a>
      2.2进程状态和管理
     </h3>
     <h4>
      <a id="1_253">
      </a>
      （1）进程的三种基本状态及基本转换
     </h4>
     <p>
      就绪状态：进程已经分配到除处理机之外的所有必要的资源，只要能够获得处理机，便可立即执行的状态。
     </p>
     <p>
      运行状态：进程已经获得处理机，其程序正在执行。
     </p>
     <p>
      阻塞状态：进程因发生某些事件而暂停执行的状态。
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/36278932f9e618504193546621e7ea8a.jpeg#pic_center"/>
     </p>
     <p>
      就绪-&gt;运行：调度程序选择一个新的程序运行
     </p>
     <p>
      运行-&gt;就绪：运行进程用完了时间片、高优先级进程处于就绪状态，运行进程被中断
     </p>
     <p>
      运行-&gt;阻塞：进程需要等待某一事件的发生
     </p>
     <p>
      阻塞-&gt;就绪：进程等待的事件发生
     </p>
     <p>
      不能由阻塞态直接转换成运行态：只有通过调度才能进入运行态，而只有位于就绪态的进程才会被调度。
     </p>
     <p>
      不能由就绪态直接转换为阻塞态：进程进入阻塞态是主动请求的，所以只有处于运行态的进程才能发出进入阻塞态的请求。
     </p>
     <h4>
      <a id="2_276">
      </a>
      （2）进程的五状态转换模型、单挂起进程模型和双挂起进程模型
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e4e11a7f55f798b37e2500376ad9b8ad.jpeg#pic_center"/>
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bdd4ced215679ac8bfcef4b908317838.jpeg#pic_center"/>
     </p>
     <p>
      挂起：把一个进程从内存转到外存
     </p>
     <p>
      挂起的目的：提高处理机效率、为运行进程提供足够内存、用于调试
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/127254b681a4868568af1253e63efae2.jpeg#pic_center"/>
     </p>
     <p>
      收容（Admit）:让一个新建的进程进入就绪状态或就绪挂起状态
     </p>
     <h3>
      <a id="23_296">
      </a>
      2.3进程通信及线程
     </h3>
     <h4>
      <a id="1_298">
      </a>
      （1）什么是进程通信？通信机制有哪些？
     </h4>
     <p>
      一个进程直接或通过某一机构发一条消息给另一个进程，且据此来控制其他进程，进程之间的这种信息交流称为进程通信。
     </p>
     <p>
      通信机制
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e48dd0e9bc4454626b1f351a6d92a5d0.png#pic_center"/>
     </p>
     <p>
      低级通信机制：一般只传送一个或几个字节的信息，达到控制进程执行速度的作用。优点：速度快；缺点：信息量小、效率低、编程复杂。
     </p>
     <p>
      高级通信机制：可以传送任意字节的消息，进程之间交换的信息量较多且效率高，解决了一个进程将大批量数据传送至另一个进程的问题。
     </p>
     <h4>
      <a id="2_310">
      </a>
      （2）什么是共享存储系统通信？
     </h4>
     <p>
      在内存空间中开辟一个区域，并连接进入多个进程的虚拟地址空间，一个进程在该空间写入数据后，另一个进程便可从中读出数据，此后便可像读写普通存储器一样读写该区域。
     </p>
     <p>
      特点：效率高，一个进程可以分配多个共享存储区。
     </p>
     <h4>
      <a id="3_316">
      </a>
      （3）什么是消息传递系统通信？
     </h4>
     <p>
      进程间通信以消息为单位进行传递，发送进程发送消息到消息队列，接收进程从中取出消息，程序员直接利用系统的通信原语进行通信。
     </p>
     <h4>
      <a id="4_320">
      </a>
      （4）什么是管道通信？
     </h4>
     <p>
      管道：指用于连接读进程和写进程以实现进程通信的共享文件，称pipe文件。
     </p>
     <p>
      发送进程以字符流形式将大量数据送入管道，接收进程从中取出数据的通信过程称为管道通信。
     </p>
     <h4>
      <a id="5_326">
      </a>
      （5）什么是内核级线程和用户级线程？他们的区别是什么？
     </h4>
     <p>
      内核级线程：从操作系统视角能看到的线程，依赖于操作系统核心，由内核的内部需求进行创建和撤销，用来执行一个指定的函数。
     </p>
     <p>
      用户级线程：有关线程管理（创建、撤销、切换）的所有工作全部由用户程序在用户态下执行，内核意识不到线程的存在。
     </p>
     <p>
      <strong>
       区别
      </strong>
     </p>
     <p>
      创建：用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责完成；内核级线程的管理工作由操作系统内核完成。
     </p>
     <p>
      切换：用户级线程中线程切换在用户态下进行；内核级线程切换必须在核心态下完成
     </p>
     <p>
      开销：用户级线程管理的系统开销小，效率高；内核级线程管理需要切换到核心态，管理成本高，开销大。
     </p>
     <p>
      操作系统意识：操作系统意识不到用户级线程的存在；但是可以看到内核级线程
     </p>
     <p>
      并发度：用户级线程当其中一个线程被阻塞后，整个进程会被阻塞，并发度不高；内核级线程被阻塞后，别的线程可以继续执行，并发能力强。
     </p>
     <p>
      并行性：多个用户级线程不可在多处理机上并行运行；内核级线程可以。
     </p>
     <h4>
      <a id="6_346">
      </a>
      （6）多线程进程优点
     </h4>
     <p>
      响应速度快：即使部分线程阻塞，其余线程可以继续运行
     </p>
     <p>
      资源共享：共享所属进程的内存和资源
     </p>
     <p>
      经济：创建和切换线程更加经济
     </p>
     <p>
      多处理机资源的利用：多个线程可以分散到多个处理机上并行执行
     </p>
     <h4>
      <a id="7_356">
      </a>
      （7）多线程模型
     </h4>
     <p>
      有些系统同时支持用户级线程和内核级线程，由于用户级线程和内核级线程的连接方式不同，形成了三种不同的多线程模型。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/70fac93a5224fe67281b88bce370860f.png#pic_center"/>
     </p>
     <p>
      一对一模型：将每个用户级线程映射到一个内核级线程
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/03dd026d97ea6a7ad958d6c629d5d055.jpeg#pic_center"/>
     </p>
     <p>
      优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强
     </p>
     <p>
      缺点：每创建一个用户进程，就要创建一个内核进程，开销较大
     </p>
     <p>
      多对一模型：将多个用户级线程映射到一个内核级线程
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fa8c527c76b5b4808b0c64ccc30f11cc.jpeg#pic_center"/>
     </p>
     <p>
      优点：线程管理是在用户空间进行的，效率高
     </p>
     <p>
      缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞，在任何时刻只有一个线程能够访问内核。
     </p>
     <p>
      多对多模型：将多个用户级线程映射到多个内核级线程
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/402b696ad56d678630fa53f6ea609a5b.jpeg#pic_center"/>
     </p>
     <p>
      克服了一对一模型开销大的缺点和多对一模型并发度不高的缺点。拥有着两种模型的优点。
     </p>
     <h3>
      <a id="24_388">
      </a>
      2.4处理器调度
     </h3>
     <h4>
      <a id="1_390">
      </a>
      （1）什么是处理器调度，处理器管理的工作是什么？
     </h4>
     <p>
      从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。
     </p>
     <p>
      处理器管理的工作是对CPU资源进行合理的分配使用，以提高处理机利用率，并使各用户公平的得到处理机资源。
     </p>
     <h4>
      <a id="2_396">
      </a>
      （2）处理器的调度级别？
     </h4>
     <p>
      <strong>
       高级调度（作业调度）
      </strong>
      ：从后备队列中按照一定的算法选择合适的作业调入内存，并为其创建进程
     </p>
     <p>
      <strong>
       中级调度（交换调度）
      </strong>
      ：从挂起队列中按照一定的算法选择合适的进程调入内存
     </p>
     <p>
      <strong>
       低级调度（进程调度）
      </strong>
      ：从就绪队列中按照一定的算法选择合适的进程调入CPU
     </p>
     <p>
      高级调度发生的频率最低，低级调度发生的频率最高。
     </p>
     <h4>
      <a id="3_406">
      </a>
      （3）什么是作业？作业的组成
     </h4>
     <p>
      作业是在一次计算过程中或一次事务处理过程中要求计算机系统完成的全部工作。
     </p>
     <p>
      作业 = 程序 + 数据 + 作业说明书
     </p>
     <h4>
      <a id="4_412">
      </a>
      （4）作业与进程的关系？
     </h4>
     <p>
      作业是任务实体，进程是完成任务的执行实体。
     </p>
     <p>
      没有作业进程无事可做，没有进程作业无法完成。
     </p>
     <p>
      作业的概念更多的用于批处理操作系统中，而进程则可以用于各种多道程序设计系统。
     </p>
     <h4>
      <a id="5_420">
      </a>
      （5）进程调度的时机
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2de00fa28e00489f0adbce723a6fda12.png#pic_center"/>
     </p>
     <p>
      <strong>
       不能进行进程调度与切换的情况
      </strong>
      ：
     </p>
     <p>
      在处理中断的过程中
     </p>
     <p>
      进程在操作系统内核程序临界区中
     </p>
     <p>
      在原语操作过程中
     </p>
     <h4>
      <a id="6_433">
      </a>
      （6）进程调度的方式？
     </h4>
     <p>
      可剥夺方式（抢占方式）：当某一个进程正在执行时，操作系统可以基于某种原则剥夺已分配给他的处理机资源，将处理机分配给其他进程，适用于分时实时操作系统。
     </p>
     <p>
      不可剥夺方式（非抢占方式）：进程调度程序一旦把处理机分配给某进程后，只有当这个进程执行完或者发生某事件而阻塞时，才把处理器分配给另外的进程。
     </p>
     <h4>
      <a id="7_439">
      </a>
      （7）调度算法的评价指标和若干标准
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/55253a128169ed2c7a3df4dbf02cabd3.png#pic_center"/>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3afa43e22b51448ea979843a8a61de10.png#pic_center"/>
     </p>
     <p>
      作业周转时间：从作业提交时刻到作业完成时刻的时间间隔。
     </p>
     <p>
      进程周转时间：进程进入时刻到进程完成这段时间的时间间隔，也就是作业周转时间减去作业在后备队列中的等待时间
     </p>
     <p>
      平均周转时间：各进程周转时间之和/进程个数
     </p>
     <p>
      带权周转时间=周转时间/实际运行的时间
     </p>
     <p>
      平均带权周转时间=各进程带权周转时间之和/进程个数
     </p>
     <p>
      <strong>
       等待时间
      </strong>
      指进程/作业处于等待处理机的状态的时间之和
     </p>
     <p>
      <strong>
       系统吞吐量
      </strong>
      ：单位时间内完成作业的数量（完成作业量/时间）
     </p>
     <p>
      <strong>
       cpu利用率
      </strong>
      ：指cpu忙碌的时间占总时间的比例
     </p>
     <h4>
      <a id="8_463">
      </a>
      （8）调度算法
     </h4>
     <p>
      <strong>
       先来先服务（FCFS）
      </strong>
      ：每次调度时总是选择最先进入就绪队列的进程为其分配处理机，使其执行，该进程一直执行到完成或发生阻塞事件时为止。
     </p>
     <p>
      优点：公平，实现简单 缺点：对短作业不利
     </p>
     <p>
      <strong>
       短作业优先（SJF）
      </strong>
      :从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即运行，该进程一直执行到完成或发生阻塞事件时为止，再重新进行调度。
     </p>
     <p>
      优点：有利于短作业，在给定的时间内可以完成更多作业，增大了系统吞吐量，改善调度性能
     </p>
     <p>
      缺点：对长作业不利，没有考虑作业的紧急程度
     </p>
     <p>
      ​ 作业长短只根据用户提供的估计运行时间而定，不一定真正能做到短作业优先调度
     </p>
     <p>
      <strong>
       高响应比优先（HRRN）
      </strong>
      ：优先权=（等待时间+要求服务时间）/要求服务时间
     </p>
     <p>
      <strong>
       时间片轮转调度算法（RR）
      </strong>
      ：就绪进程按先来先服务的原则，把CPU分配给队首进程，并令其执行一个时间片，当执行的时间片用完时，将该进程放到队尾，依次执行下一个进程。
     </p>
     <p>
      优点：保证所有的就绪进程在一定的时间内均能获得一时间片的执行时间
     </p>
     <p>
      缺点：时间片的长短对其调度有着很大的影响，若时间片太短，则将频繁的进行进程切换，将增大系统的开销；若时间片太长，则退化成FCFS算法。
     </p>
     <p>
      <strong>
       高优先级调度算法
      </strong>
      ：优先选择就绪队列中优先级最高的进程分配处理机。
     </p>
     <p>
      <strong>
       多级反馈队列调度算法
      </strong>
      ：时间片轮转调度算法与高优先级调度算法的结合。
     </p>
     <h3>
      <a id="25_489">
      </a>
      2.5进程同步与互斥
     </h3>
     <h4>
      <a id="1_491">
      </a>
      （1）同步与互斥的定义？
     </h4>
     <p>
      同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。（执行时有先后顺序）
     </p>
     <p>
      互斥：并发进程在竞争共享资源时，一个时刻只允许一个进程去使用，其他想要使用该资源的进程必须等待，直至该资源被释放。（不能同时进入临界区）
     </p>
     <h4>
      <a id="2_497">
      </a>
      （2）什么是临界资源与临界区、进入区、退出区？
     </h4>
     <p>
      临界资源：一次只允许一个进程访问的资源
     </p>
     <p>
      临界区：访问临界资源的那段代码
     </p>
     <p>
      进入区：在临界区前面增加的一段用于进行临界资源检查的代码
     </p>
     <p>
      退出区：将临界资源正被访问的标志恢复为未被访问的标志
     </p>
     <h4>
      <a id="3_507">
      </a>
      （3）临界区的四个管理准则
     </h4>
     <p>
      空闲让进：其他进程均不处于临界区
     </p>
     <p>
      忙则等待：已有进程处于临界区
     </p>
     <p>
      有限等待：等待进入临界区的进程不能死等
     </p>
     <p>
      让权等待：不能进入临界区的进程，应释放CPU
     </p>
     <h4>
      <a id="4_517">
      </a>
      （4）进程同步机制有哪些？
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bc276dd87c479c87c58e0460ad6926cc.png#pic_center"/>
     </p>
     <p>
      <strong>
       单标志法
      </strong>
      ：一个进程在访问完临界区后会把使用临界区的权限交给另一个进程。
     </p>
     <pre><code class="prism language-c++">int turn = 0;
//P0进程                              //P1进程
while(turn != 0);					 while(turn != 1);
critical section;					 critical section;
turn = 1;							 turn = 0;
remainder section;					 remainder section;
</code></pre>
     <p>
      该算法对于临界区的访问一定是按照P0-&gt;P1-&gt;P0-&gt;P1……的顺序来的。若P0此时允许进入临界区而P0一直不访问临界区，那么虽然临界区空闲，但并不允许P1访问。
     </p>
     <p>
      该算法违背了“空闲让进”原则。
     </p>
     <p>
      <strong>
       双标志先检查法
      </strong>
      ：设置一个布尔型数组flag[],数组中各个元素用来标记各进程想进入临界区的意愿，每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，把自身flag设为true,之后开始访问临界区。
     </p>
     <pre><code class="prism language-c++">bool flag[2] = {false};
//P0进程									//P1进程
while(flag[1]);(1)						 while(flag[0]);(6)
flag[0] = true;	(2)					 	 flag[1] = true;(7)
critical section;(3)					 critical section;(8)
flag[0] = false;(4)					 	 flag[1] = false;(9)
remainder section;(5)					 remainder section;(10)
</code></pre>
     <p>
      （1）（6）（2）（7）……顺序执行两个进程会同时访问临界资源，违背了“忙则等待”原则。
     </p>
     <p>
      <strong>
       双标志后检查法
      </strong>
      ：双标志先检查法的改版，前一算法是先检查后上锁，这一算法是先上锁后检查。
     </p>
     <pre><code class="prism language-c++">bool flag[2] = {false};
//P0进程									//P1进程
flag[0] = true;(1)						 flag[1] = true;(6)
while(flag[1]);	(2)					 	 while(flag[0]);(7)
critical section;(3)					 critical section;(8)
flag[0] = false;(4)					 	 flag[1] = false;(9)
remainder section;(5)					 remainder section;(10)
</code></pre>
     <p>
      解决了忙则等待问题，但是违反了空闲让进和有限等待原则（（1）（6）（2）（7）……顺序执行）
     </p>
     <p>
      <strong>
       peterson算法
      </strong>
      ：只能处理两个进程
     </p>
     <pre><code class="prism language-c++">bool flag[2];
turn = 0;//turn 表示优先让哪个进程进入临界区
//P0进程									//P1进程
flag[0] = true;					 		 flag[1] = true;
turn = 1;							     turn = 0;
while(flag[1] &amp;&amp; turn == 1);     	     while(flag[0] &amp;&amp; turn ==0);
critical section;			 			 critical section;
flag[0] = false;				 	 	 flag[1] = false;
remainder section;					 	 remainder section;
</code></pre>
     <p>
      遵循空闲让进、忙则等待、有限等待原则，违背了让权等待原则。
     </p>
     <p>
      <strong>
       硬件同步机制
      </strong>
     </p>
     <p>
      <strong>
       关中断
      </strong>
      ：在进入临界区之前关中断，直到该进程访问完临界区再开中断。
     </p>
     <p>
      优点：简单高效
     </p>
     <p>
      缺点：滥用中断权力可能会导致严重后果
     </p>
     <p>
      ​ 关中断时间过长会影响系统效率
     </p>
     <p>
      ​ 不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其他处理器上执行相同的临界区代码。
     </p>
     <p>
      <strong>
       TSL/swap指令
      </strong>
     </p>
     <p>
      优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境
     </p>
     <p>
      缺点：不满足让权等待原则，会出现忙等现象。
     </p>
     <h4>
      <a id="5_599">
      </a>
      （5）信号量机制实现进程互斥
     </h4>
     <p>
      信号量：表示可以使用的资源个数
     </p>
     <p>
      实现互斥是在同一进程中进行一对PV操作
     </p>
     <p>
      实现同步是在一个进程P，一个进程V
     </p>
     <h5>
      <a id="_607">
      </a>
      经典问题
     </h5>
     <h6>
      <a id="1_609">
      </a>
      1）生产者-消费者问题
     </h6>
     <pre><code class="prism language-c++">semaphore mutex = 1;
semaphore full = 0;
semaphore empty = 1;
producer(){
	while(1){
        P(empty);
		P(muntex);
        生产产品
        V(full);
        V(mutex);
	}
}
consumer(){
	while(1){
        P(full);
		P(mutex);
        消费产品
        V(empty);
        V(mutex);
	}
}
</code></pre>
     <h6>
      <a id="2_635">
      </a>
      2）哲学家进餐问题
     </h6>
     <p>
      避免死锁办法：
     </p>
     <p>
      最多允许4个人同时拿起筷子
     </p>
     <p>
      当哲学家两边筷子都可用时才允许拿起筷子
     </p>
     <p>
      对哲学家编号，奇号哲学家先拿左边筷子，偶号哲学家先拿右边筷子
     </p>
     <pre><code class="prism language-c++">//当两边筷子都可用时才拿起筷子
semaphore chopsticks[5] = {1,1,1,1,1};
semaphore mutex = 1;
P(){
	while(1){
        P(mutex);
        P(chopsticks[i]);
        P(chopsticks[(i + 1) % 5]);
        V(mutex);
        进餐;
        V(chopsticks[i]);
        V(chopsticks[(i + 1) % 5]);
        思考;
    }
}
</code></pre>
     <h6>
      <a id="3_663">
      </a>
      3）读者-写者问题
     </h6>
     <p>
      读读允许，读写，写写不允许
     </p>
     <pre><code class="prism language-c++">//写进程优先
int count = 0;
semaphore mutex = 1;//更新count互斥
semaphore rw = 1;//读者写者互斥
semaphore w = 1;//实现写优先
writer(){
    while(1){
        P(w);
        P(rw);
        写;
        V(rw);
        V(w);
    }
}

reader(){
    while(1){
        P(w);//没有写进程才读，如果有w &lt; 0，该进程阻塞
        P(mutex);
        if(count == 0)
            P(rw);
        count++;
        V(mutex);
        读;
        P(mutex);
        count--;
        if(count == 0)
            V(rw);
        V(mutex);
    }
}
</code></pre>
     <h4>
      <a id="6_701">
      </a>
      （6）死锁、饥饿与死循环的联系和区别
     </h4>
     <p>
      共同点：都是进程无法向前顺利推进的现象（故意设计的死循环除外)
     </p>
     <p>
      区别：死锁一定是循环等待对方手里的资源导致的，因此如果有死锁现象，
      <strong>
       至少有两个进程
      </strong>
      同时发生死锁，发生死锁的进程一定处于
      <strong>
       阻塞态
      </strong>
     </p>
     <p>
      <strong>
       可能只有一个进程
      </strong>
      发生饥饿。饥饿的进程可能处于
      <strong>
       阻塞态
      </strong>
      ，也可能处于
      <strong>
       就绪态
      </strong>
      。
     </p>
     <p>
      <strong>
       可能只有一个进程
      </strong>
      发生死循环，死循环的进程可能处在
      <strong>
       运行态
      </strong>
      ，只不过无法像期望那样顺利推进。
     </p>
     <p>
      死锁和饥饿是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的，死锁和饥饿是管理者（操作系统）的问题 ，而死循环是被管理者的问题。
     </p>
     <h3>
      <a id="26_713">
      </a>
      2.6死锁
     </h3>
     <h4>
      <a id="1_715">
      </a>
      （1）死锁的概念
     </h4>
     <p>
      指两个或多个进程都无限的等待一个事件，而该事件又只能由这些等待进程之一来产生。
     </p>
     <h4>
      <a id="2_719">
      </a>
      （2）死锁形成的四个必要条件
     </h4>
     <p>
      互斥使用
     </p>
     <p>
      不可抢占
     </p>
     <p>
      请求并保持
     </p>
     <p>
      循环等待
     </p>
     <h4>
      <a id="3_729">
      </a>
      （3）解决死锁问题的几个策略
     </h4>
     <p>
      死锁预防（预防火灾）
     </p>
     <p>
      死锁避免（检测到煤气超标，自动切断电源）
     </p>
     <p>
      死锁检测和解除（发现火灾，灭火）
     </p>
     <p>
      死锁忽略（在太阳上不管火灾）
     </p>
     <h4>
      <a id="4_739">
      </a>
      （4）银行家算法工作原理及缺点
     </h4>
     <p>
      <strong>
       安全序列
      </strong>
      ：如果系统按照这种序列分配资源，则每个进程都能顺利完成。
     </p>
     <p>
      主要思想是避免系统进入不安全状态，在每次进行资源分配时，他首先检查系统是否有足够的资源，如果有，先进行试分配，并对分配后的新状态进行安全性检查，若新状态安全，则正式分配上述资源；否则拒绝分配该资源。保证系统始终处于安全状态，从而避免了死锁现象的发生。
     </p>
     <p>
      例题：
     </p>
     <table>
      <thead>
       <tr>
        <th align="center">
         process
        </th>
        <th align="center">
         current_allocation
        </th>
        <th align="center">
         still_need
        </th>
        <th align="center">
         available
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td align="center">
         P0
        </td>
        <td align="center">
         0032
        </td>
        <td align="center">
         0012
        </td>
        <td align="center">
         2022
        </td>
       </tr>
       <tr>
        <td align="center">
         P1
        </td>
        <td align="center">
         1000
        </td>
        <td align="center">
         1130
        </td>
        <td align="center">
        </td>
       </tr>
       <tr>
        <td align="center">
         P2
        </td>
        <td align="center">
         1301
        </td>
        <td align="center">
         1310
        </td>
        <td align="center">
        </td>
       </tr>
       <tr>
        <td align="center">
         P3
        </td>
        <td align="center">
         0301
        </td>
        <td align="center">
         0032
        </td>
        <td align="center">
        </td>
       </tr>
       <tr>
        <td align="center">
         P4
        </td>
        <td align="center">
         0012
        </td>
        <td align="center">
         1023
        </td>
        <td align="center">
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      (1)该状态是否安全，列出一个安全序列
     </p>
     <p>
      当前状态work = [2,0,2,2]
     </p>
     <p>
      P0 work = [2,0,5,4]
     </p>
     <p>
      P3 work = [2,3,5,5]
     </p>
     <p>
      P1 work = [3,3,5,5]
     </p>
     <p>
      P2 work = [4,6,5,6]
     </p>
     <p>
      P4 work = [4,6,6,8]
     </p>
     <p>
      所以一个安全序列为P0,P3,P1,P2,P4
     </p>
     <p>
      (2)P2请求1，0，1，0能否予以满足？
     </p>
     <p>
      若将P2请求1，0，1，0予以满足，则系统资源剩余量为1，0，1，2，可以满足进程P0,P0完成后资源剩余量1，0，4，4，可满足进程P3,P4，假设让P3先完成，完成后资源剩余量为1，3，4，5，满足进程P1,P2,P4，假设先让P1完成，完成后资源剩余量2，3，4，5，满足P2，P4，假设让P2先完成，完成后资源剩余量4，6，5，6，最后P4可以完成，所以可以满足P2请求。
     </p>
     <p>
      <strong>
       缺点
      </strong>
      ：
     </p>
     <p>
      请求矩阵R不容易得到
     </p>
     <p>
      进程的个数不是固定的而是动态变化的
     </p>
     <p>
      资源的个数也不是固定的
     </p>
     <h4>
      <a id="5_785">
      </a>
      （5）死锁检测算法
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b94c1f7804d47da0698c1dc954d349f9.jpeg#pic_center"/>
     </p>
     <h2>
      <a id="3_790">
      </a>
      3.内存管理
     </h2>
     <h3>
      <a id="31_792">
      </a>
      3.1概述
     </h3>
     <h4>
      <a id="1_794">
      </a>
      （1）什么是内存管理？存储管理有哪些功能？
     </h4>
     <p>
      操作系统对内存的划分与动态分配
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2078469e4d1ac3a6d1148bf4c1387572.png#pic_center"/>
     </p>
     <p>
      内存分配与回收：由操作系统完成主存储空间的分配和管理
     </p>
     <p>
      地址映射：把逻辑地址转换为相应的物理地址
     </p>
     <p>
      内存共享：允许多个进程访问内存的同一部分
     </p>
     <p>
      存储保护：保证各道作业在各自的存储空间内运行，互不干扰
     </p>
     <p>
      内存扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
     </p>
     <h4>
      <a id="2_811">
      </a>
      （2）物理地址和逻辑地址的概念？
     </h4>
     <p>
      物理地址（绝对地址）：主存储器中每个存储单元的地址，信息在存储器中的实际存放地址
     </p>
     <p>
      逻辑地址（相对地址）：允许在程序中编排的地址
     </p>
     <h4>
      <a id="3_817">
      </a>
      （3）程序的编译、链接和装入
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/69698ff8927d905f33c9ef037f192e80.png#pic_center"/>
     </p>
     <p>
      <strong>
       编译
      </strong>
      ：由编译程序将用户源代码编译成若按目标模块
     </p>
     <p>
      <strong>
       链接
      </strong>
      ：由链接程序将编译后形成的一组目标模块及他们所需的库函数链接在一起，形成一个完整的装入模块
     </p>
     <p>
      静态链接：在程序运行之前，先将各目标模块及他们所需要的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开
     </p>
     <p>
      装入时动态链接：将各目标模块装入内存时，边装入边链接
     </p>
     <p>
      运行时动态链接：在程序执行过程中需要该目标模块时，才对他进行链接
     </p>
     <p>
      <strong>
       装入（重定位）
      </strong>
      ：由装入程序将装入模块装入内存中运行，一个经过编译链接的程序存在于自己的虚拟地址空间中，当要运行时才把他装入自己的内存空间中，这时需要将程序中的逻辑地址转换成主存中侧物理地址，这个转换过程即为重定位技术
     </p>
     <p>
      绝对装入：程序中的逻辑地址和实际内存地址完全相同，不需对程序和数据的地址进行修改，只适用于单道程序运行环境
     </p>
     <p>
      可重定位装入：地址变换通常在进程装入时一次完成，一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存就不能装入该作业，作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间
     </p>
     <p>
      动态运行时重定位：在程序装入时保留逻辑地址不变，在程序执行过程中，CPU执行到具体的指令时，才将要访问指令的逻辑地址转换为物理地址
     </p>
     <h3>
      <a id="32_840">
      </a>
      3.2分区分页分段管理技术
     </h3>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fc1dc6cfb87c032493ef59004289ea3c.png#pic_center"/>
     </p>
     <h4>
      <a id="_845">
      </a>
      什么是连续分配方式和非连续分配方式
     </h4>
     <p>
      连续分配：为用户进程分配的必须是一个连续的内存空间
     </p>
     <p>
      非连续分配：：为用户进程分配的可以是一些分散的内存空间
     </p>
     <p>
      <strong>
       分区存储管理
      </strong>
     </p>
     <h4>
      <a id="1_853">
      </a>
      （1）什么是外碎片和内碎片？
     </h4>
     <p>
      外碎片：指还没有被分配出去，但是由于太小了无法分配给申请内存空间的新进程的内存空闲区域
     </p>
     <p>
      内碎片：指已经分配出去，但是没有被利用的内存空间
     </p>
     <h4>
      <a id="2_859">
      </a>
      （2）固定分区分配的特点
     </h4>
     <p>
      分区大小相等：缺乏灵活性，但很适合用于一台计算机控制多个相同对象的场合
     </p>
     <p>
      分区大小不等
     </p>
     <p>
      优点：实现简单，无外部碎片
     </p>
     <p>
      缺点：当用户程序太大时，可能所有的分区都不能满足要求，需要采用覆盖技术解决，会降低性能
     </p>
     <h4>
      <a id="3_869">
      </a>
      （3）动态分区分配的特点及其中的算法
     </h4>
     <p>
      动态分区分配：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小
     </p>
     <p>
      <strong>
       动态分区的分配算法
      </strong>
     </p>
     <p>
      首次适应算法(First fit)
     </p>
     <p>
      循环首次适应算法(Next Fit)
     </p>
     <p>
      最佳适应算法(Best Fit)
     </p>
     <p>
      最坏适应算法(Worst Fit)
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/27a8215727f63954320d06d5f3f65297.jpeg#pic_center"/>
     </p>
     <h4>
      <a id="4_886">
      </a>
      （4）覆盖与对换的概念
     </h4>
     <p>
      覆盖：把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称覆盖段），共享主存的同一个区域。
     </p>
     <p>
      对换：把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够内存空间，再把已具备运行条件的进程和进程所需要的程序和数据调入内存
     </p>
     <h4>
      <a id="5_892">
      </a>
      （5）进程的换入和换出规则
     </h4>
     <p>
      外存分为
      <strong>
       文件区
      </strong>
      和
      <strong>
       对换区
      </strong>
     </p>
     <p>
      文件区用于存放文件，采用
      <strong>
       离散分配方式
      </strong>
     </p>
     <p>
      对换区用于存放从内存换出的进程，进程在对换区中驻留的时间是短暂的，采用
      <strong>
       连续分配方式
      </strong>
     </p>
     <p>
      换出：选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘对换区上
     </p>
     <p>
      换入：系统检查所有进程的状态，从中找出就绪状态但已换出的进程，将其换出时间最久的进程作为换入进程
     </p>
     <h4>
      <a id="6_904">
      </a>
      （6）分页的概念
     </h4>
     <p>
      把进程的逻辑地址空间分为若干个大小相等的片，称为页面或页，相应的也把内存空间划分为大小相等的存储块，称为块或页框，在为进程分配内存时，以块为单位将进程中的若干页分别装入到多个可以不相邻的物理块中
     </p>
     <p>
      分页存储器的逻辑地址：（页号，页内地址）
     </p>
     <h4>
      <a id="7_910">
      </a>
      （7）什么是页内碎片？页面太大太小有什么特点？
     </h4>
     <p>
      页内碎片：进程的最后一页装不满而形成的不可利用的碎片
     </p>
     <p>
      页面太大，可减少页表长度，提高页面换进换出速度，却会使页内碎片增大
     </p>
     <p>
      页面太小，可使页内碎片减小。但会使每个进程占用更多页面，从而导致页表过长，占用大量内存，还会降低页面换进换出的效率
     </p>
     <h4>
      <a id="8_918">
      </a>
      （8）页表的概念和组成
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d65e0dfcddb3f7c915ee34a52766be51.jpeg#pic_center"/>
     </p>
     <p>
      给定逻辑地址A，页面大小为L，页号P = INT[A/L],偏移量A % L
     </p>
     <h4>
      <a id="9_925">
      </a>
      （9）分页存储地址变换机构
     </h4>
     <p>
      地址变换机构任务：将逻辑地址转换为内存中的物理地址
     </p>
     <p>
      在系统中通常设置一个页表寄存器（PTR），存放页表在内存中的起始地址及页表长度
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1a5d7e7f938fec5966a5d14da0bb7258.jpeg#pic_center"/>
     </p>
     <p>
      若页表全部放在内存中，则存取一条数据或指令至少要访问
      <strong>
       两次
      </strong>
      内存，第一次是访问页表，确定所存取数据或指令的物理地址，第二次是根据得到的物理地址存取指令或数据
     </p>
     <p>
      <strong>
       存在的问题
      </strong>
     </p>
     <p>
      （1）每次访存操作都需要进行逻辑地址导物理地址的转换，影响计算机处理速度
     </p>
     <p>
      （2）每个进程引入页表用于存储映射机制，页表不能太大，否则内存利用率低
     </p>
     <h4>
      <a id="10_942">
      </a>
      （10）引入快表的地址变换机构
     </h4>
     <p>
      快表：访问速度比内存块很多的高速缓冲存储器
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/464b38200277c9a0afc1ae305bd830c8.jpeg#pic_center"/>
     </p>
     <p>
      <strong>
       单级页表存在的问题
      </strong>
     </p>
     <p>
      （1）页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框
     </p>
     <p>
      （2）没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面
     </p>
     <h4>
      <a id="11_955">
      </a>
      （11）两级页表的概念和地址变换机构
     </h4>
     <p>
      ​ 将页表在内存中离散存储，为离散分配的页表再建立一张页表，称为页目录表（外层页表，顶层页表）
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0834894c3ffa0450e43825ccb13fbd22.jpeg#pic_center"/>
     </p>
     <h4>
      <a id="12_962">
      </a>
      （12）基本分段存储管理的概念
     </h4>
     <p>
      分段系统中逻辑地址结构是二维的（段号S，段内偏移W）
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/80582bb0682791f1356f506d9d097959.jpeg#pic_center"/>
     </p>
     <h4>
      <a id="13_969">
      </a>
      （13）段页式管理
     </h4>
     <p>
      在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页
     </p>
     <p>
      <strong>
       注意！
      </strong>
      ：在一个进程中，段表只能有一个，而页表可以有多个
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/314b9ca3c1d379d7b3edbde544bdf819.jpeg#pic_center"/>
     </p>
     <h4>
      <a id="14_978">
      </a>
      （14）分页和分段的区别和联系
     </h4>
     <p>
      <strong>
       相同点
      </strong>
     </p>
     <ul>
      <li>
       都采用离散分配方式
      </li>
      <li>
       都要通过地址映射机构来实现地址变换
      </li>
     </ul>
     <p>
      <strong>
       区别
      </strong>
     </p>
     <ul>
      <li>
       分页是出于系统管理的需要，分段是出于用户应用的需要
      </li>
      <li>
       页大小是系统固定的，段大小通常不固定
      </li>
      <li>
       分页逻辑地址表示是一维的，分段是二维的
      </li>
      <li>
       通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度
      </li>
      <li>
       分段比分页更容易实现信息的共享和保护
      </li>
     </ul>
     <h3>
      <a id="33_995">
      </a>
      3.3虚拟内存技术
     </h3>
     <h4>
      <a id="1_997">
      </a>
      （1）什么是虚拟存储器？
     </h4>
     <p>
      具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统
     </p>
     <h4>
      <a id="2_1001">
      </a>
      （2）虚拟内存容量问题
     </h4>
     <p>
      虚拟内存的最大容量是由CPU寻址范围确定的
     </p>
     <p>
      虚拟内存实际容量 = min(内存外存容量之和，CPU寻址范围)
     </p>
     <p>
      <strong>
       例
      </strong>
      ：某计算机地址结构为32位，内存大小512MB，外存大小2GB
     </p>
     <p>
      虚拟内存最大容量为
      <br/>
      <span class="katex--display">
       <span class="katex-display">
        <span class="katex">
         <span class="katex-mathml">
          2 
          
         
           32 
          
         
        
          = 
         
        
          4 
         
        
          G 
         
        
          B 
         
        
       
         2^{32} = 4GB
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.8641em;">
           </span>
           <span class="mord">
            <span class="mord">
             2
            </span>
            <span class="msupsub">
             <span class="vlist-t">
              <span class="vlist-r">
               <span class="vlist" style="height: 0.8641em;">
                <span class="" style="top: -3.113em; margin-right: 0.05em;">
                 <span class="pstrut" style="height: 2.7em;">
                 </span>
                 <span class="sizing reset-size6 size3 mtight">
                  <span class="mord mtight">
                   <span class="mord mtight">
                    32
                   </span>
                  </span>
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
           <span class="mspace" style="margin-right: 0.2778em;">
           </span>
           <span class="mrel">
            =
           </span>
           <span class="mspace" style="margin-right: 0.2778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 0.6833em;">
           </span>
           <span class="mord">
            4
           </span>
           <span class="mord mathnormal" style="margin-right: 0.0502em;">
            GB
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
      <br/>
      虚拟内存实际容量=min(4GB,512MB+2GB) = 512MB+2GB
     </p>
     <h4>
      <a id="3_1015">
      </a>
      （3）虚拟存储器的特征
     </h4>
     <ul>
      <li>
       多次性
      </li>
      <li>
       对换性
      </li>
      <li>
       虚拟性
      </li>
      <li>
       离散分配，部分安装
      </li>
     </ul>
     <h4>
      <a id="4_1022">
      </a>
      （4）虚拟内存的实现
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1d7fa5f0431b35654980d4506635ee8a.png#pic_center"/>
     </p>
     <p>
      页表机制：
     </p>
     <p>
      请求页表数据结构
     </p>
     <table>
      <thead>
       <tr>
        <th>
         页号
        </th>
        <th>
         内存块号
        </th>
        <th>
         状态位
        </th>
        <th>
         访问字段
        </th>
        <th>
         修改位
        </th>
        <th>
         外存地址
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      缺页中断：因为当前执行的指令想要访问的目标页面未调入内存而产生的，属于内中断
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bdf843146be45785f9111a55552981ef.jpeg#pic_center"/>
     </p>
     <h4>
      <a id="5_1041">
      </a>
      （5）调入策略
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d1ad699430885b5c048022be4a0931e5.png#pic_center"/>
     </p>
     <h4>
      <a id="6_1045">
      </a>
      （6）什么是局部性原理?
     </h4>
     <p>
      局部性原理：程序在执行过程中的一个较短时期，所执行的指令的地址和指令操作数的地址分别局限于一定区域
     </p>
     <p>
      时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行，如果某个数据被访问过，不久之后该数据可能被再次访问
     </p>
     <p>
      空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元很有可能被再次访问
     </p>
     <h4>
      <a id="7_1053">
      </a>
      （7）什么是抖动？产生抖动的原因是什么？
     </h4>
     <p>
      抖动（颠簸）：刚刚换出的界面马上就要换入内存，刚刚换入的页面马上就要换出内存，这种频繁的页面调度行为
     </p>
     <p>
      主要原因：进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）
     </p>
     <p>
      为进程分配的物理块太少，会使进程发生抖动现象
     </p>
     <p>
      为进程分配的物理块太多，会降低系统整体的并发度，降低某些资源的利用率
     </p>
     <h4>
      <a id="8_1063">
      </a>
      （8）驻留集和工作集
     </h4>
     <p>
      驻留集：请求分页存储管理中给进程分配的内存块的集合
     </p>
     <p>
      工作集：指在某段时间间隔里，进程实际访问页面的集合
     </p>
     <p>
      驻留集的大小不能小于工作集的大小，否则进程运行过程中将频繁缺页
     </p>
     <h4>
      <a id="9_1071">
      </a>
      （9）页面分配、置换和清除策略
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9db933d225d9b885bffbdf7a976177d3.png#pic_center"/>
     </p>
     <h4>
      <a id="10_1076">
      </a>
      （10）页面置换算法
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d7034b37bcf0ac8b5142e433e625cbe3.png#pic_center"/>
     </p>
     <h4>
      <a id="11Belady_1081">
      </a>
      （11）Belady异常
     </h4>
     <p>
      当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
     </p>
     <p>
      <strong>
       只有FIFO算法会产生Belady异常
      </strong>
     </p>
     <h2>
      <a id="4_1089">
      </a>
      4.文件管理
     </h2>
     <h3>
      <a id="1_1091">
      </a>
      （1）什么是文件和文件系统
     </h3>
     <p>
      文件：一组带标识的、在逻辑上有完整意义并存储于物理介质上的信息项的集合
     </p>
     <p>
      文件系统：与文件管理有关的那部分软件，被管理的文件以及管理所需要的数据结构的总体
     </p>
     <h3>
      <a id="2_1097">
      </a>
      （2）文件系统中数据的分类
     </h3>
     <ul>
      <li>
       数据项：最低级的数据组织形式
      </li>
      <li>
       记录：一组相关数据项的集合
      </li>
      <li>
       文件：由若干记录组成，文件系统中的最大单位
      </li>
     </ul>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5e947c238d223ace0f48b3cb4e9ba8f4.png#pic_center"/>
     </p>
     <h3>
      <a id="3_1106">
      </a>
      （3）文件系统的作用
     </h3>
     <ul>
      <li>
       从用户角度看，文件系统主要实现“按名存取”，对文件进行存取控制。负责管理控制用户对文件的各种操作
      </li>
      <li>
       从系统管理角度，文件系统主要是实现文件存储空间的组织、分配以及文件的存储、检索、共享、保护等管理
      </li>
     </ul>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f74d37e32ecd7b0f2d9f0599b77cd686.png#pic_center"/>
     </p>
     <h3>
      <a id="4_1114">
      </a>
      （4）什么是文件目录？文件目录的结构及特点
     </h3>
     <p>
      文件目录：文件控制块（FCB）的有序集合，把所有FCB有机组织起来就构成了文件目录
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d0fc2bffb55d01bd324d06db2f7e736f.png#pic_center"/>
     </p>
     <ul>
      <li>
       单级目录结构
      </li>
     </ul>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ba5937910dd295df4915ab509aabea35.png#pic_center"/>
     </p>
     <p>
      存在的问题
     </p>
     <p>
      （1）查找速度慢
     </p>
     <p>
      （2）不允许重名
     </p>
     <p>
      （3）不便于实现文件共享
     </p>
     <ul>
      <li>
       二级目录结构
      </li>
     </ul>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ebd554c741a8a7f784c3406b06204768.png#pic_center"/>
     </p>
     <p>
      优点
     </p>
     <p>
      （1）提高了检索目录的速度
     </p>
     <p>
      （2）在不同的用户目录中可以使用相同文件名
     </p>
     <p>
      （3）不同用户还可以使用不同的文件名来访问系统中的同一个共享文件
     </p>
     <p>
      缺点:缺乏灵活性，用户不能对自己的文件进行分类
     </p>
     <ul>
      <li>
       多级目录结构
      </li>
     </ul>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/05e128af6ec7aa4ed9c5868101a1f65f.png#pic_center"/>
     </p>
     <p>
      优点
     </p>
     <p>
      （1）层次清晰，解决了文件重名问题
     </p>
     <p>
      （2）查找搜索速度快
     </p>
     <p>
      缺点：多次访问磁盘影响速度，结构相对比较复杂，不便于实现文件的共享
     </p>
     <h3>
      <a id="5_1162">
      </a>
      （5）文件的逻辑结构和物理结构
     </h3>
     <p>
      <strong>
       逻辑结构
      </strong>
      ：在用户看来，文件内部的数据是如何组织起来的
     </p>
     <p>
      <strong>
       物理结构
      </strong>
      ：在操作系统看来，文件的数据是如何存放在外存中的
     </p>
     <h4>
      <a id="1_1168">
      </a>
      1.逻辑结构
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1c82b6d281db2723dbd5d929415b1ed4.png#pic_center"/>
     </p>
     <p>
      [OSC_4_1 文件管理——文件系统.pdf](…\HitStudy\操作系统\课件\2022朱东杰\OSC_4_1 文件管理——文件系统.pdf)
     </p>
     <p>
      <strong>
       无结构文件
      </strong>
      ：文件内部的数据是一系列二进制流或字符流组成，又称
      <strong>
       流式文件
      </strong>
      ，如windows操作系统中的.txt文件
     </p>
     <h5>
      <a id="_1177">
      </a>
      有结构文件
     </h5>
     <p>
      <strong>
       有结构文件
      </strong>
      ：有一组相似的记录组成，又称
      <strong>
       记录式文件
      </strong>
      ,每条记录由若干数据项组成。
     </p>
     <h6>
      <a id="1_1181">
      </a>
      1）
      <strong>
       顺序文件
      </strong>
     </h6>
     <p>
      <strong>
       顺序文件
      </strong>
      ：文件中的记录一个接一个的顺序排列（逻辑上）。各个记录在物理上可以顺序存储或链式存储。
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5f3f1ba704a3cada10ec3dedd23addae.png#pic_center"/>
     </p>
     <p>
      <strong>
       已经知道了文件的起始地址（第一个记录存放的位置），能否快速找到第i个记录对应的地址（随机存取）？
      </strong>
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fcddaacfe6f48b4b9358616e20408ed7.png#pic_center"/>
     </p>
     <h6>
      <a id="2_1193">
      </a>
      2）索引文件
     </h6>
     <p>
      <strong>
       索引文件
      </strong>
      ：建立一张索引表以加快文件检索速度，每条记录对应一个索引项
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/45f320384ccc2e087dc41f9e9f54371d.png#pic_center"/>
     </p>
     <h6>
      <a id="3_1200">
      </a>
      3）索引顺序文件
     </h6>
     <p>
      <strong>
       索引顺序文件
      </strong>
      ：是索引文件和顺序文件的思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/56f2eacf1cb3197428c5342375001f58.png#pic_center"/>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/21eabe7a61f298f21a913b88b5c20880.png#pic_center"/>
     </p>
     <h4>
      <a id="2_1210">
      </a>
      2.物理结构
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b945bf3be1ec7e43c7791c235abb470b.png#pic_center"/>
     </p>
     <h5>
      <a id="1_1215">
      </a>
      1）连续分配
     </h5>
     <p>
      <strong>
       连续分配
      </strong>
      ：每个文件在磁盘上占有一组连续的块
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/01e68e9ffac270112d44f1f6687c89b0.png#pic_center"/>
     </p>
     <p>
      优点：顺序访问容易，访问速度快
     </p>
     <p>
      缺点：要求有连续的存储空间，必须事先知道文件的长度，随着文件不停的被分配和删除，空闲空间逐渐被分割成很小的碎片
     </p>
     <h5>
      <a id="2_1226">
      </a>
      2）链接分配
     </h5>
     <p>
      <strong>
       隐式链接
      </strong>
      ：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0638af09a17860c4fb56e2796c4705f9.png#pic_center"/>
     </p>
     <p>
      <strong>
       显式链接
      </strong>
      ：把用于链接各文件各物理块的指针显式的存放在一张表中，即文件分配表（FAT,File Allocation Table）
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a8d17a1f94a837879b8aebedb19de0cc.png#pic_center"/>
     </p>
     <p>
      链接结构优点：存储碎片问题迎刃而解，有利于文件动态扩充，有利于文件的插入和删除，提高了磁盘空间利用率
     </p>
     <p>
      缺点：存取速度慢，不适于随机存取
     </p>
     <p>
      磁头移动多，效率相对较低
     </p>
     <p>
      存在可靠性问题，如指针出错
     </p>
     <p>
      链接指针要占用一定空间
     </p>
     <h5>
      <a id="3_1248">
      </a>
      3）索引分配
     </h5>
     <p>
      <strong>
       索引结构
      </strong>
      ：把每个磁盘块的指针字取出，放在主存的表或索引中（一个文件对应一张索引表）。
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/44f996981351b5a14d9fc57f68d6db53.png#pic_center"/>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0ead4a8249d6f372338df64222c69952.png#pic_center"/>
     </p>
     <h3>
      <a id="6_1256">
      </a>
      （6）文件存储空间的管理方法
     </h3>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/47e44129f10d11c126c193c08e2af70d.png#pic_center"/>
     </p>
     <h4>
      <a id="1_1261">
      </a>
      1.空闲表法
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/465a10ef122b978448fb9b559f407267.png#pic_center"/>
     </p>
     <h4>
      <a id="2_1268">
      </a>
      2.空闲链表法
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2181e88c27ebbf5d7d9e5f61b9771441.png#pic_center"/>
     </p>
     <h4>
      <a id="3_1272">
      </a>
      3.位示图法
     </h4>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9864ffd52bf5b2f466a09b653a2fbcb7.png#pic_center"/>
     </p>
     <h3>
      <a id="7_1277">
      </a>
      （7）磁盘调度算法
     </h3>
     <p>
      [OSC_4_2 文件管理——磁盘组织与管理.pdf](D:\HitStudy\操作系统\课件\2022朱东杰\OSC_4_2 文件管理——磁盘组织与管理.pdf)
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/8790f2a60911caddfdd5f19124108b3b.png#pic_center"/>
     </p>
     <h2>
      <a id="5IO_1286">
      </a>
      5.I/O管理
     </h2>
     <p>
      [OSC_5-1 设备管理——IO管理.pdf](D:\HitStudy\操作系统\课件\2022朱东杰\OSC_5-1 设备管理——IO管理.pdf)
     </p>
     <h3>
      <a id="1spooling_1290">
      </a>
      （1）spooling假脱机技术
     </h3>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/63140a93f820bec3fd3a1efdc607d58b.png#pic_center"/>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0cd3c8f940c575b4c10a4bedf143a326.png#pic_center"/>
     </p>
     <p>
      <strong>
       spooling技术特点
      </strong>
     </p>
     <p>
      （1）提高了I/O的速度
     </p>
     <p>
      （2）将独占设备改造为共享设备
     </p>
     <p>
      （3）实现了虚拟设备功能
     </p>
    </img>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35333030343533312f:61727469636c652f64657461696c732f313334333133333437" class_="artid" style="display:none">
 </p>
</div>


