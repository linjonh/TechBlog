---
layout: post
title: "操作系统实验三进程间通信"
date: 2021-06-11 10:19:30 +0800
description: "操作系统实验三进程间通信_进程间通信实验"
keywords: "进程间通信实验"
categories: ['操作系统实验实训', '大学实验实训']
tags: ['操作系统实验', '操作系统']
artid: "117790532"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=117790532
    alt: "操作系统实验三进程间通信"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统实验三进程间通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      文末也可直接获取实验文档
     </strong>
    </p>
    <p>
     <strong>
      实验三 进程间通信
     </strong>
     <br/>
    </p>
    <div class="toc">
     <h4>
      目录
     </h4>
     <ul>
      <li>
       <a href="#1_4" rel="nofollow">
        1实验目的
       </a>
      </li>
      <li>
       <a href="#2__8" rel="nofollow">
        2 实验内容
       </a>
      </li>
      <li>
       <a href="#3_18" rel="nofollow">
        3实验详细操作步骤及程序清单：
       </a>
      </li>
      <li>
       <a href="#4_336" rel="nofollow">
        4相关问题及思考
       </a>
      </li>
      <li>
       <a href="#5_345" rel="nofollow">
        5总结
       </a>
      </li>
      <li>
       <a href="#6_350" rel="nofollow">
        6背景知识
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="1_4">
     </a>
     1实验目的
    </h2>
    <p>
     1、了解linux系统中进程通信的基本原理。
     <br/>
     2、分析进程竞争资源现象，学习解决进程互斥的方法。
    </p>
    <h2>
     <a id="2__8">
     </a>
     2 实验内容
    </h2>
    <p>
     （1）消息的创建，发送和接收。
     <br/>
     ①使用系统调用msgget (), msgsnd (), msgrcv (), 及msgctl () 等编制一长度为1k的消息的发送和接收程序。
     <br/>
     ②观察程序，说明控制消息队列系统调用msgctl () 在此起什么作用？
     <br/>
     （2）编程实现进程的管道通信。
     <br/>
     使用系统调用pipe()建立一条管道，两个子进程p1和P2分别向管道各写一句话，而父进程则从管道中读出来自于两个子进程的信息并显示在屏幕上。
     <br/>
     ①观察程序中的sleep(1)起什么作用？
     <br/>
     ②子进程1和2为什么也能对管道进行操作？
     <br/>
     （3）比较上述（1），（2）两种通信机制的不同特点。
    </p>
    <h2>
     <a id="3_18">
     </a>
     3实验详细操作步骤及程序清单：
    </h2>
    <p>
     3.1通过Linux提供的系统调用signal()来说明如何执行一个预先安排好的信号处理函数。（选做）
     <br/>
     signal()的返回值是指向一个函数的指针，该函数的参数为一个整数。
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
intctrl_c_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>old_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">voidctrl_c</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">voidmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
intc<span class="token punctuation">;</span>
<span class="token comment">/*设置ctrl+c产生的信号SIGINT的处理程序为ctrl_c.取代系统原来默认的处理程序*/</span>
old_handler<span class="token operator">=</span><span class="token function">singal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>ctrl_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*不断输入字符，同时按多次ctrl+c，直到按回车结束*/</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>’\n’<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span>“ctrl_c_count<span class="token operator">=</span><span class="token operator">%</span>d\n”<span class="token punctuation">,</span>ctrl_c_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*设置信号处理程序为原来的处理程序*/</span>
<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">singal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>old_hander<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*不断输入字符，ctrl+c结束*/</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>’\n’<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*对SIGINT信号的处理程序*/</span>
<span class="token function">voidctrl_c</span><span class="token punctuation">(</span>intsignum<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>ctrl_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">++</span>ctrl_c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     程序说明：这个程序是从键盘获得字符，直到换行符为止，然后进入无限循环。这里，程序安排了捕获ctrl_c信号(SIGINT)，并且利用SIGINT来执行一个ctrl_c的处理函数。当在键盘上敲入一个换行符时，SIGINT原来的操作(很可能是默认操作)才被恢复。Main()函数中的第一个语句完成设置信号处理程序：
     <br/>
     old_handler=signal(SIGINT,ctrl_c);
     <br/>
     signal()的两个参数是：信号值，这里是键盘中断信号SIGINT；以及一个指向函数的指针，这里是ctrl_c，当这个中断信号出现时，将调用该函数。Signal()调用返回旧的信号处理程序的地址，在此它被赋给变量older_handler，使得原来的信号处理程序稍后可以被恢复。
     <br/>
     1写入程序
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/33e9c1cfcd22a2bf7d2e3f740ea72b8c.png">
      <br/>
      2编译并运行
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/573aa29d0ea5051deabd55ba0f8c7e91.png"/>
     </img>
    </p>
    <p>
     结果分析：程序中的ctrl_c函数的功能是记录SIGINT（CTRL+c）的次数，所以ctrl_c_count=10，当使用默认的函数操作时，CTRL+c退出程序
    </p>
    <p>
     3.2软中断通信（选做）
     <br/>
     编制一段程序，使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上来的中断信号（即按ctrl+c键），当捕捉到中断信号后，父进程用系统调用kill()向两个子进程发出信号，子进程捕捉到信号后，分别输出下列信息后终止：
     <br/>
     childprocess1iskilledbyparent!
     <br/>
     childprocess2iskilledbyparent!
     <br/>
     父进程等待两个子进程终止后，输出以下信息后终止：
     <br/>
     parentprocessiskilled!
     <br/>
     源程序：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token function">voidwaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
intwait_mark<span class="token punctuation">;</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
intp1<span class="token punctuation">,</span>p2<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/*创建子进程p1*/</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/*创建子进程p2*/</span>
<span class="token punctuation">{<!-- --></span>
wait_mark<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*接收到^c信号，转stop*/</span>
<span class="token function">waiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">kill</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*向p1发软中断信号16*/</span>
<span class="token function">kill</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*向p2发软中断信号17*/</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*同步*/</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parentprocessiskilled!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
wait_mark<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">waiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lockf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"childprocess2iskilledbyparent!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lockf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
wait_mark<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">waiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lockf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"childprocess1iskilledbyparent!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lockf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">voidwaiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">while</span><span class="token punctuation">(</span>wait_mark<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">voidstop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
wait_mark<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     1， 写入参考程序
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ccc01d4462699e6408355ba0214c5edf.png"/>
    </p>
    <p>
     2编译和运行
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a882dbcb883f3a73c9fa18265fff880e.png"/>
    </p>
    <p>
     使用系统调用fork()创建两个子进程,再用系统调用signal()让父进程捕捉键盘上的中断信号(即按DEL键);当捕捉到中断信号后,父进程用系统调用Kill()向两个子进程发出信号,子进程捕捉到信号后分别输出下列信息后终止： Child Proeess 1 is Killed by Parent! Child Process 2 is Killed by Parent! 父进程等待两个子进程终止后,输出如下的信息后终止： Parent Process is Killed!
    </p>
    <p>
     3.3消息通信（必做）
     <br/>
     使用系统调用msgget(),msgsnd(),msgrcv()及msgctl()编制一长度为1K的消息发送和接收的程序。
     <br/>
     〈程序设计〉
     <br/>
     （1）为了便于操作和观察结果，用一个程序为“引子”，先后fork()两个子进程，SERVER和CLIENT，进行通信。
     <br/>
     （2）SERVER端建立一个Key为75的消息队列，等待其他进程发来的消息。当遇到类型为1的消息，则作为结束信号，取消该队列，并退出SERVER。SERVER每接收到一个消息后显示一句“(server)received”。
     <br/>
     （3）CLIENT端使用Key为75的消息队列，先后发送类型从10到1的消息，然后退出。最后的一个消息，既是SERVER端需要的结束信号。CLIENT每发送一条消息后显示一句“(client)sent”。
     <br/>
     （4）父进程在SERVER和CLIENT均退出后结束。
     <br/>
     参考程序：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">MSGKEY75</span><span class="token comment">/*定义关键词MEGKEY*/</span></span>
structmsgform<span class="token comment">/*消息结构*/</span>
<span class="token punctuation">{<!-- --></span>
longmtype<span class="token punctuation">;</span>
charmtxt<span class="token punctuation">[</span><span class="token number">1030</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*文本长度*/</span>
<span class="token punctuation">}</span>msg<span class="token punctuation">;</span>
intmsgqid<span class="token punctuation">,</span>i<span class="token punctuation">;</span>

<span class="token function">voidCLIENT</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
inti<span class="token punctuation">;</span>
msgqid<span class="token operator">=</span><span class="token function">msgget</span><span class="token punctuation">(</span>MSGKEY<span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
msg<span class="token punctuation">.</span>mtype<span class="token operator">=</span>i<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(client)sent\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">msgsnd</span><span class="token punctuation">(</span>msgqid<span class="token punctuation">,</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*发送消息msg入msgid消息队列*/</span>
<span class="token punctuation">}</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">voidSERVER</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
msgqid<span class="token operator">=</span><span class="token function">msgget</span><span class="token punctuation">(</span>MSGKEY<span class="token punctuation">,</span><span class="token number">0777</span><span class="token operator">|</span>IPC_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*由关键字获得消息队列*/</span>
<span class="token keyword">do</span>
<span class="token punctuation">{<!-- --></span>
<span class="token function">msgrcv</span><span class="token punctuation">(</span>msgqid<span class="token punctuation">,</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">1030</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*从队列msgid接受消息msg*/</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(server)receive\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>mtype<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*消息类型为1时，释放队列*/</span>
<span class="token function">msgctl</span><span class="token punctuation">(</span>msgqid<span class="token punctuation">,</span>IPC_RMID<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">SERVER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">elseCLIENT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     1， 输入参考程序
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3285d3bef2535cf64d23f4ade83ac6fd.png"/>
    </p>
    <p>
     2， 编译并运行
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e3b7efb03da974caf785d7821d665bca.png"/>
    </p>
    <p>
     &lt;结果&gt;
    </p>
    <p>
     从理想的结果来说，应当是每当Client发送一个消息后，server接收该消息，Client再发送下一条。也就是说“(Client)sent”和“(server)received”的字样应该在屏幕上交替出现。实际的结果大多是，先由Client发送两条消息，然后Server接收一条消息。此后Client、Server交替发送和接收消息.最后一次接收两条消息.Client和Server分别发送和接收了10条消息,与预期设想一致。
    </p>
    <p>
     &lt;分析&gt;
     <br/>
     message的传送和控制并不保证完全同步,当一个程序不再激活状态的时候,它完全可能继续睡眠,造成上面现象,在多次sendmessage后才receivemessage.这一点有助于理解消息转送的实现机理。
    </p>
    <p>
     消息通信的特点：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息的传递,自身就带有同步的控制.当等到消息的时候,进程进入睡眠状态,不再消耗CPU资源。
     <br/>
     3.4进程的管道通信（必做）
     <br/>
     编制一段程序，实现进程的管道通信。使用系统调用pipe()建立一条管道先。两个子进程p1和分别向管道各写一句话：
     <br/>
     Child1processissendingamessage!
     <br/>
     Child2processissendingamessage!
     <br/>
     而父进程则从管道中读出来自于两个子进程的信息并显示在屏幕上。
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span></span>
Intpid1<span class="token punctuation">,</span>pid2<span class="token punctuation">;</span>
<span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
Intfd<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Charoutpipe<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inpipe<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">Pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*创建一个管道*/</span> 
<span class="token function">While</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid1<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">If</span><span class="token punctuation">(</span>pid1<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
Printf”p1\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Lockf</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Sprintf</span><span class="token punctuation">(</span>outpipe<span class="token punctuation">,</span>”child1processissendingamessage<span class="token operator">!</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*把串放入数组outpipe中*/</span>
<span class="token function">Write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>outpipe<span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*向管道写长为50字节的串*/</span>
<span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/*自我阻塞1秒*/</span>
<span class="token function">Lockf</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Else
<span class="token punctuation">{<!-- --></span>
<span class="token function">While</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid2<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">If</span><span class="token punctuation">(</span>pid2<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token function">Printf</span><span class="token punctuation">(</span>“p2\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Lockf</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*互斥*/</span>
<span class="token function">Sprintf</span><span class="token punctuation">(</span>outpipe<span class="token punctuation">,</span>”child2processissendingamessage<span class="token operator">!</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>outpipe<span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Lockf</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Else
<span class="token punctuation">{<!-- --></span>
<span class="token function">Printf</span><span class="token punctuation">(</span>“parent\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*同步*/</span>
<span class="token function">Read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inpipe<span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*从管道中读长为50字节的串*/</span>
<span class="token function">Printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>s\n”<span class="token punctuation">,</span>inpipe<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>inpipe<span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>s\n”<span class="token punctuation">,</span>inpipe<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     运行结果：
     <br/>
     child1processissendingamessage!
     <br/>
     child2processissendingamessage!
     <br/>
     1输入参考程序
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/79406ab5400ec86b4f9cc7017460a97b.png"/>
    </p>
    <p>
     2编译并运行
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fd028261ae760f24d3664f2d883cf096.png"/>
    </p>
    <p>
     相关问题及思考：
     <br/>
     （1）无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
     <br/>
     （2）有名管道（namedpipe)：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
     <br/>
     （3）管道通信的特点：管道只能承载无格式字节流。
     <br/>
     （4）观察程序中的sleep(1)起什么作用？
     <br/>
     答：延长子进程占用管道的时间，并没有让子进程1先输出而子进程2后输出的作用。
     <br/>
     （5）子进程1和2为什么也能对管道进行操作？
     <br/>
     答：因为该pipe管道属于无名管道，调用pipe()的父进程及其子孙进程均能识别此文件描述符，能利用该文件（管道）进行通信。
    </p>
    <p>
     3.5共享存储区通信（选做）
     <br/>
     使用系统调用shmget()，sgmat()，smgdt()，shmctl()，编制一个与上述相同功能的程序。
     <br/>
     参考程序：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">SHMKEY75</span></span>
Intshmid<span class="token punctuation">,</span>I<span class="token punctuation">;</span>
Int<span class="token operator">*</span>addr<span class="token punctuation">;</span>
<span class="token function">Voidclient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
IntI<span class="token punctuation">;</span>
Shmid<span class="token operator">=</span><span class="token function">shmget</span><span class="token punctuation">(</span>SHMKEY<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取共享区，长度为1024*/</span>
Addr<span class="token operator">=</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*共享区起始地址为addr*/</span>
<span class="token function">For</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token function">While</span><span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Printf</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span>client<span class="token punctuation">)</span>sent\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*打印(client)sent*/</span>
<span class="token operator">*</span>addr<span class="token operator">=</span>I<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">Voidserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
Shmid<span class="token operator">=</span><span class="token function">shmget</span><span class="token punctuation">(</span>SHMKEY<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token number">0777</span><span class="token operator">|</span>IPC_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*创建共享区*/</span>
Addr<span class="token operator">=</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*共享区起始地址为addr*/</span>
Do
<span class="token punctuation">{<!-- --></span><span class="token operator">*</span>addr<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">While</span><span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Printf</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span>server<span class="token punctuation">)</span>received\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*服务进程使用共享区*/</span>
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span>IPC_RMID<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Eixt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">Voidmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token function">While</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">If</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span><span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">While</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">If</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span><span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     1输入修改后的参考代码
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4ac04b437f44d74466b4d06c77bc22df.png"/>
    </p>
    <p>
     2编译并运行
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5c616541af9e15350830dbc1a3f74eea.png"/>
    </p>
    <p>
     结果：
     <br/>
     运行结果和预想的完全一样，但在运行过程中，发现每当client发送一次数据后，server要等待大学0.1秒才有响应。同样，client又需要等待约0.1秒后才发送下一个数据。
    </p>
    <p>
     分析：
     <br/>
     当client发送一个数据后，并没有任何措施通知server数据已经发出，需要由client的查询才能知道。此时client并没有放弃系统控制权，只有当系统进行调度时，切换到了server进程，再进行应答。
    </p>
    <h2>
     <a id="4_336">
     </a>
     4相关问题及思考
    </h2>
    <p>
     (1)消息队列方式是由消息的链表，存在内核中并由消息队列标识符标识。克服了信号传递信息少，管道只能承载无格式字节流及缓冲区大小受限的缺点。
     <br/>
     (2)管道通信是一种半双工的通信方式，数据只能单向流动，只能在有父子进程关系的进程间使用
    </p>
    <p>
     观察程序中的sleep(1)起什么作用？
     <br/>
     答：延长子进程占用管道的时间，并没有让子进程1先输出而子进程2后输出的作用。
    </p>
    <p>
     子进程1和2为什么也能对管道进行操作？
     <br/>
     答：因为该pipe管道属于无名管道，调用pipe()的父进程及其子孙进程均能识别此文件描述符，能利用该文件（管道）进行通信。
    </p>
    <h2>
     <a id="5_345">
     </a>
     5总结
    </h2>
    <p>
     这次实验让我了解了linux系统中进程通信的基本原理，通过分析进程竞争资源现象，学习了解决进程互斥的方法。
     <br/>
     在实验过程中对实验内容提出的问题感到吃力，但在查看代码和查阅相关资料后得到了解决。
    </p>
    <h2>
     <a id="6_350">
     </a>
     6背景知识
    </h2>
    <p>
     1、fork()
     <br/>
     创建一个新进程
     <br/>
     intfork()
     <br/>
     其中返回int取值意义如下：
     <br/>
     0：创建子进程，从子进程返回的id值
     <br/>
     大于0：从父进程返回的子进程id值
     <br/>
     -1：创建失败
     <br/>
     2、lockf(files,function,size):
     <br/>
     用作锁定文件的某些段或者整个文件，本函数适用的头文件为：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
参数定义：
<span class="token function">intlockf</span><span class="token punctuation">(</span>files<span class="token punctuation">,</span>function<span class="token punctuation">,</span>size<span class="token punctuation">)</span>
intfiles<span class="token punctuation">,</span>function<span class="token punctuation">;</span>
longsize<span class="token punctuation">;</span>
其中：files是文件描述符：function是锁定和解锁；<span class="token number">1</span>表示锁定，<span class="token number">0</span>表示解锁。size是锁定和解锁的字节数，若用<span class="token number">0</span>，表示从文件的当前位置到文件尾。
</code></pre>
    <p>
     3、msgget(key,flag):
     <br/>
     获得一个消息的描述符，该描述符指定一个消息队列以便用于其他系统调用。
     <br/>
     该函数使用偷文件如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/msg.h&gt;</span></span>
参数定义
<span class="token function">intmsgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
key_tkey<span class="token punctuation">;</span>
intflag<span class="token punctuation">;</span>
语法格式：msgqid<span class="token operator">=</span><span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
其中：msgid是该系统调用返回的描述符，失败则返回<span class="token operator">-</span><span class="token number">1</span>；flag本身由操作允许权和控制命令值相“或”得到。
如：IP_CREAT<span class="token operator">|</span><span class="token number">0400</span>是否该队列应被创建；
IP_EXCL<span class="token operator">|</span><span class="token number">0400</span>是否该队列的创建应是互斥的；等。
</code></pre>
    <p>
     4、msgsnd(id,msgp,size,flag):
     <br/>
     发送一消息。
     <br/>
     该函数是用头文件如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/msg.h&gt;</span></span>
参数定义
<span class="token function">intmsgnd</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>msgp<span class="token punctuation">,</span>size<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
intid<span class="token punctuation">,</span>size<span class="token punctuation">,</span>flag<span class="token punctuation">;</span>
structmsgbuf<span class="token operator">*</span>msgp<span class="token punctuation">;</span>
其中：id是返回消息队列的描述符；msgp是指向用户存储区的一个构造体指针，size指示由msgp指向的数据结构中字符数组的长度；即消息的长度。这个数组的最大值由MSG<span class="token operator">-</span>MAX系统可调用参数来确定。flag规定当核心用尽内部缓冲空间时应执行的动作；若在标志flag中末设置IPC_NOWAIT位，则当该消息队列中字节数超过一最大值时，或系统范围的消息数超过某一最大值时，调用msgsnd进程睡眠。若是设置IPC_NOWAIT，则在此情况下，msgsnd立即返回。
</code></pre>
    <p>
     5、msgrcv(id,msgp,size,type,flag):
     <br/>
     接受一消息。
     <br/>
     该函数调用使用头文件如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/msg.h&gt;</span></span>
参数定义
<span class="token function">intmsgrcv</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>msgp<span class="token punctuation">,</span>size<span class="token punctuation">,</span>type<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
intid<span class="token punctuation">,</span>size<span class="token punctuation">,</span>type<span class="token punctuation">,</span>flag<span class="token punctuation">;</span>
structmsgbuf<span class="token operator">*</span>msgq<span class="token punctuation">;</span>
structsgbuf<span class="token punctuation">{<!-- --></span>longmtpe<span class="token punctuation">;</span>chatmtext<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
语法格式：
count<span class="token operator">=</span><span class="token function">msgrcv</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>msgp<span class="token punctuation">,</span>size<span class="token punctuation">,</span>type<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
其中：id是用来存放欲接收消息的拥护数据结构的地址；size是msgp中数据数组的大小；type是用户要读的消息类型：
type为<span class="token number">0</span><span class="token operator">:</span>接收该队列的第一个消息；
type为正：接收类型type的第一个消息；
type为负：接收小于或等于type绝对值的最低类型的第一个消息。
flag规定倘若该队列无消息，核心应当做什么事，如果此时设置了IPC_NOWAIT标志，则立即返回，若在flag中设置了MSG_NOERROR，且所接收的消息大小大于size，核心截断所接受的消息。
count是返回消息正文的字节数。
</code></pre>
    <p>
     6、msgctl(id,cmd,buf):
     <br/>
     查询一个消息描述符的状态，设置它的状态及删除一个消息描述符。
     <br/>
     调用该函数使用头文件如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/msg.h&gt;</span></span>
参数定义
<span class="token function">intmsgctl</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>buf<span class="token punctuation">)</span>
intid<span class="token punctuation">,</span>cmd<span class="token punctuation">;</span>
structmsgbuf<span class="token operator">*</span>msgq<span class="token punctuation">;</span>
structmsqid_ds<span class="token operator">*</span>buf<span class="token punctuation">;</span>
其中：函数调用成功时返回<span class="token number">0</span>，调用不成功时返回<span class="token operator">-</span><span class="token number">1</span>。id用来识别该消息的描述符；cmd规定命令的类型。
IPC_START将与id相关联的消息队列首标读入buf。
IPC_SET为这个消息序列设置有效的用户和小组标识及操作允许权和字节的数量。
IPC_RMID删除id的消息队列。
buf是含有控制参数或查询结果的用户数据结构的地址。
附：msgid_ds结构定义如下：
structmsgid_ds
<span class="token punctuation">{<!-- --></span>structipc_permmsg_perm<span class="token punctuation">;</span><span class="token comment">/*许可权结构*/</span>
shotpadl<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*由系统使用*/</span>
ushortonsg_qnum<span class="token punctuation">;</span><span class="token comment">/*队列上消息数*/</span>
ushortmsg_qbytes<span class="token punctuation">;</span><span class="token comment">/*队列上最大字节数*/</span>
ushortmsg_lspid<span class="token punctuation">;</span><span class="token comment">/*最后发送消息的PID*/</span>
ushortmsg_lrpid<span class="token punctuation">;</span><span class="token comment">/*最后接收消息的PID*/</span>
time_tmsg__stime<span class="token punctuation">;</span><span class="token comment">/*最后发送消息的时间*/</span>
time_tmsg_rtime<span class="token punctuation">;</span><span class="token comment">/*最后接收消息的时间*/</span>
me_tmsg_ctime<span class="token punctuation">;</span><span class="token comment">/*最后更改时间*/</span>
<span class="token punctuation">}</span>；
structipc_perm
<span class="token punctuation">{<!-- --></span>ushortuid<span class="token punctuation">;</span><span class="token comment">/*当前用户id*/</span>
ushortgid<span class="token punctuation">;</span><span class="token comment">/*当前进程组id*/</span>
ushortcuid<span class="token punctuation">;</span><span class="token comment">/*创建用户id*/</span>
ushortcgid<span class="token comment">/*创建进程组id*/</span>
ushortmode<span class="token punctuation">;</span><span class="token comment">/*存取许可权*/</span>
<span class="token punctuation">{<!-- --></span>shotpatl<span class="token punctuation">;</span>longpad2<span class="token punctuation">}</span><span class="token comment">/*由系统使用*/</span>
<span class="token punctuation">}</span>；
</code></pre>
    <p>
     7、shmget(key,size,flag):
     <br/>
     获得一个共享存储区。
     <br/>
     该函数使用头文件如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/shm.h&gt;</span></span>
语法格式：
shmid<span class="token operator">=</span><span class="token function">shmaget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>size<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
参数定义<span class="token operator">:</span>
<span class="token function">intshmaget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>size<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
key_tkey<span class="token punctuation">;</span>
intsize<span class="token punctuation">,</span>flag<span class="token punctuation">;</span>
其中：size是存储区的字节数，key和flag与系统调用msgget中的参数含义相同。
附：
操作允许权八进制数
用户可读<span class="token number">00400</span>
用户可读<span class="token number">00200</span>
小组可读<span class="token number">00040</span>
小组可读<span class="token number">00020</span>
其他可读<span class="token number">00004</span>
其他可读<span class="token number">00002</span>
控制命令值
IPC_CREAT0001000
IPC_EXCL0002000
</code></pre>
    <p>
     如:shmid=shmget(key,size,(IPC_CREAT|0400））；
     <br/>
     创建一个关键字为key,长度为size的共享存储区。
     <br/>
     8、shmat(id,addr,flag):
     <br/>
     从逻辑上将一个共享存储区附接到进程的虚拟地址空间上。
     <br/>
     该函数调用使用头文件如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/msg.h&gt;</span></span>
参数定义<span class="token operator">:</span>
<span class="token keyword">char</span><span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
intid<span class="token punctuation">,</span>flag<span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span>addr<span class="token punctuation">;</span>
语法格式：virtaddr<span class="token operator">=</span><span class="token function">shmat</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>flag<span class="token punctuation">)</span>
</code></pre>
    <p>
     其中：id是共享存储区的标识符，addr是用户要使用共享存储区附接的虚地址，若addr是0，系统是否对应用户规定的地址做舍入操作。如果flag中设置了shm_rnd即表示操作系统在必要时舍去这个地址。如果设置了shm_rdonly，即表示只允许读操作。viraddr是附接的虚地址。
     <br/>
     9、shmdt(addr):
     <br/>
     把一个共享存储区从指定进程的虚地址空间分开。
     <br/>
     调用该函数使用头文件：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/mhm.h&gt;</span></span>
参数定义<span class="token operator">:</span>
<span class="token function">intshmdt</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>
<span class="token keyword">char</span><span class="token operator">*</span>addr
</code></pre>
    <p>
     其中，当调用成功时，返回0值，调用不成功，返回-1，addr是系统调用shmat所返回的地址。
     <br/>
     10、shmctl(id,cmd,buf):
     <br/>
     对与共享存储区关联的各种参数进行操作，从而对共享存储区进行控制。
     <br/>
     调用该函数使用头文件：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sy/shm.h&gt;</span></span>
参数定义<span class="token operator">:</span>
<span class="token function">intshmctl</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>cmd<span class="token punctuation">,</span>buf<span class="token punctuation">)</span>
intid<span class="token punctuation">,</span>cmd<span class="token punctuation">;</span>
structshmid_ds<span class="token operator">*</span>buf<span class="token punctuation">;</span>
其中：调用成功返回<span class="token number">0</span>，否则返回<span class="token operator">-</span><span class="token number">1</span>。id为被共享存储区的标识符。cmd规定操作的类型。规定如下：
IPC_STAT<span class="token operator">:</span>返回包含在指定的shmid相关数据结构中的状态信息，并且把它放置在用户存储区中的<span class="token operator">*</span>but指针所指的数据结构中。执行此命令的进程必须有读取允许权。
IPC_SET：对于指定的shmid，为它设置有效用户和小组标识和操作存取权。
IPC_RMID：删除指定的shmid以及与它相关的共享存储区的数据结构。
SHM_LOCK：在内存中锁定指定的共享存储区，必须是超级用户才可以进行此项操作。
Buf是一个用户级数据结构地址。
附：
shmid_ds
<span class="token punctuation">{<!-- --></span>structipc_permshm_perm<span class="token punctuation">;</span><span class="token comment">/*允许权结构*/</span>
intshm_segsz<span class="token punctuation">;</span><span class="token comment">/*段大小*/</span>
intpadl<span class="token punctuation">;</span><span class="token comment">/*由系统使用；*/</span>
ushortshm_lpid<span class="token punctuation">;</span><span class="token comment">/*最后操作的进程id；*/</span>
ushortshm_cpid<span class="token punctuation">;</span><span class="token comment">/*创建者的进程id；*/</span>
ushortshm_nattch<span class="token punctuation">;</span><span class="token comment">/*当前附界数；*/</span>
shortpad2<span class="token punctuation">;</span><span class="token comment">/*由系统使用；*/</span>
time_tshm_atime<span class="token punctuation">;</span><span class="token comment">/*最后附接时间*/</span>
time_tshm_dtime<span class="token punctuation">;</span><span class="token comment">/*最后段接时间*/</span>
time_tshm_ctime<span class="token punctuation">;</span><span class="token comment">/*最后修改时间*/</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     11、signal(sig,function):
     <br/>
     允许调用进程控制软中断信号的处理。
     <br/>
     头文件为：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span></span>
参数定义<span class="token operator">:</span>
<span class="token function">signal</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span>function<span class="token punctuation">)</span><span class="token punctuation">;</span>
intsig<span class="token punctuation">;</span>
<span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
其中：sig的值是：
SIGHVP挂起
SIGINT键盘按<span class="token operator">^</span>c键或<span class="token keyword">break</span>键
SIGQUIT键盘按quit键
SIGILL非法指令
SIGIOTIOT指令
SIGEMTEMT指令
SIGFPE浮点运算溢出
SIGKILL要求终止进程
SIGBUS总线错
SIGSEGV段违例
SIGSYS系统调用参数错
SIGPIPE向无读者管道上写
SIGALRM闹钟
SIGTERM软件终结
SIGUSRI用户定义信号
SIGUSR2第二个用户定义信号
SIGCLD子进程死
SIGPWR电源故障
function的解释如下：
SIG_DEL：缺省操作。
</code></pre>
    <p>
     对除SIGPWR和SIGCLD外所有信号的缺省操作是进程终结对信号SIGQUIT,SIGILL,SIGTRA,SIGIOT,SIGEMT,SIGFPE,SIGBUS,SIGSEGV和SIGSYS它产生一内存映像文件。
     <br/>
     SIG_IGN：忽视该信号的出现。
     <br/>
     Function:在该进程中的一个函数地址，在核心返回用户态时，它以软中断信号的序号作为参数调用该函数，对除了信号SIGILL,SIGTRAP和SIGTWR以外的信号，核心自动地重新设置软中断信号处理程序的值为SIG_DEL，一个进程不能捕获SIGKILL信号。
    </p>
    <p>
     <strong>
      关注公众号：Time木
      <br/>
      回复：操作系统实验
      <br/>
      可获得相关代码，数据，文档
      <br/>
      回复：操作系统试卷
      <br/>
      可获取操作系统试卷整理
      <br/>
      更多大学课业实验实训可关注公众号回复相关关键词
      <br/>
      学艺不精，若有错误还望指点
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34333337343638312f:61727469636c652f64657461696c732f313137373930353332" class_="artid" style="display:none">
 </p>
</div>


