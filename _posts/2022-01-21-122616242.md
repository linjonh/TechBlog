---
layout: post
title: "Unity-游戏实例开发集合-之-CutFruit-切水果水果忍者-休闲小游戏快速实现"
date: 2022-01-21 13:46:45 +0800
description: "文章浏览阅读1w次，点赞13次，Unity 游戏实例开发集合 之 CutFruit (切水果(水果忍"
keywords: "unity3d切水果"
categories: ['游戏实例开发集合', 'Unity']
tags: ['游戏', '水果忍者', '切水果', 'Unity', 'Cutfruit']
artid: "122616242"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122616242
    alt: "Unity-游戏实例开发集合-之-CutFruit-切水果水果忍者-休闲小游戏快速实现"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity 游戏实例开发集合 之 CutFruit (切水果(水果忍者)) 休闲小游戏快速实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="Unity%20%E6%B8%B8%E6%88%8F%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91%E9%9B%86%E5%90%88%20%E4%B9%8B%20CutFruit%20(%E5%88%87%E6%B0%B4%E6%9E%9C(%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85))%20%E4%BC%91%E9%97%B2%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0">
     Unity 游戏实例开发集合 之 CutFruit (切水果(水果忍者)) 休闲小游戏快速实现
    </h2>
    <p>
    </p>
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="Unity%20%E6%B8%B8%E6%88%8F%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91%E9%9B%86%E5%90%88%20%E4%B9%8B%20CutFruit%20(%E5%88%87%E6%B0%B4%E6%9E%9C(%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85))%20%E4%BC%91%E9%97%B2%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;">
     <a href="#Unity%20%E6%B8%B8%E6%88%8F%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%8F%91%E9%9B%86%E5%90%88%20%E4%B9%8B%20CutFruit%20%28%E5%88%87%E6%B0%B4%E6%9E%9C%28%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85%29%29%20%E4%BC%91%E9%97%B2%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">
      Unity 游戏实例开发集合 之 CutFruit (切水果(水果忍者)) 休闲小游戏快速实现
     </a>
    </p>
    <p id="%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;">
     <a href="#%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" rel="nofollow">
      一、简单介绍
     </a>
    </p>
    <p id="%E4%BA%8C%E3%80%81CutFruit%20(%E5%88%87%E6%B0%B4%E6%9E%9C(%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85))%20%E6%B8%B8%E6%88%8F%E5%86%85%E5%AE%B9%E4%B8%8E%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;">
     <a href="#%E4%BA%8C%E3%80%81CutFruit%20%28%E5%88%87%E6%B0%B4%E6%9E%9C%28%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85%29%29%20%E6%B8%B8%E6%88%8F%E5%86%85%E5%AE%B9%E4%B8%8E%E6%93%8D%E4%BD%9C" rel="nofollow">
      二、CutFruit (切水果(水果忍者)) 游戏内容与操作
     </a>
    </p>
    <p id="%E4%B8%89%E3%80%81%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;">
     <a href="#%E4%B8%89%E3%80%81%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E" rel="nofollow">
      三、相关说明
     </a>
    </p>
    <p id="%E5%9B%9B%E3%80%81%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;">
     <a href="#%E5%9B%9B%E3%80%81%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6" rel="nofollow">
      四、游戏代码框架
     </a>
    </p>
    <p id="%E4%BA%94%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9-toc" style="margin-left:40px;">
     <a href="#%E4%BA%94%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9" rel="nofollow">
      五、知识点
     </a>
    </p>
    <p id="%E5%85%AD%E3%80%81%E6%B8%B8%E6%88%8F%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88%E2%80%8B-toc" style="margin-left:40px;">
     <a href="#%E5%85%AD%E3%80%81%E6%B8%B8%E6%88%8F%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88%E2%80%8B" rel="nofollow">
      六、游戏效果预览​
     </a>
    </p>
    <p id="%E4%B8%83%E3%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;">
     <a href="#%E4%B8%83%E3%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" rel="nofollow">
      七、实现步骤
     </a>
    </p>
    <p id="%E5%85%AB%E3%80%81%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;">
     <a href="#%E5%85%AB%E3%80%81%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80" rel="nofollow">
      八、工程源码地址
     </a>
    </p>
    <p id="%E4%B9%9D%E3%80%81%E5%BB%B6%E4%BC%B8%E6%89%A9%E5%B1%95-toc" style="margin-left:40px;">
     <a href="#%E4%B9%9D%E3%80%81%E5%BB%B6%E4%BC%B8%E6%89%A9%E5%B1%95" rel="nofollow">
      九、延伸扩展
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h3 id="%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">
     一、简单介绍
    </h3>
    <p>
     Unity 游戏实例开发集合，使用简单易懂的方式，讲解常见游戏的开发实现过程，方便后期类似游戏开发的借鉴和复用。
    </p>
    <p>
     本节介绍，CutFruit (切水果(水果忍者))休闲小游戏快速实现的方法，希望能帮到你，若有不对，请留言。
    </p>
    <p>
     这是一个 3D 游戏，主要是使用精灵图（水果特效等）、3D 重力、3D 碰撞体，TrailRenderer (切刀效果) 实现。
    </p>
    <p>
    </p>
    <h3 id="%E4%BA%8C%E3%80%81CutFruit%20(%E5%88%87%E6%B0%B4%E6%9E%9C(%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85))%20%E6%B8%B8%E6%88%8F%E5%86%85%E5%AE%B9%E4%B8%8E%E6%93%8D%E4%BD%9C">
     二、CutFruit (切水果(水果忍者)) 游戏内容与操作
    </h3>
    <p>
     1、游戏开始，底部会自动生成向上运动的水果
    </p>
    <p>
     2、按下鼠标，移动就会生成切水果的刀锋
    </p>
    <p>
     3、鼠标刀锋碰到水果，水果就会被切开
    </p>
    <p>
     4、松开鼠标，切割刀锋消失
    </p>
    <p>
     5、当切到水果，会对应加分，切刀炸弹，会对应失去生命
    </p>
    <p>
     6、生命没有了，则游戏结束
    </p>
    <p>
    </p>
    <h3 id="%E4%B8%89%E3%80%81%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E">
     三、相关说明
    </h3>
    <p>
     1、这里底部生成水果位置，做了屏幕适配，x 方向是：宽度的20% - 80%，y 方向是：屏幕向下高度的 20 %
    </p>
    <p>
     2、随机生成水果和炸弹的规则是：随机某个范围，指定某个数是炸弹，其他是随机水果
    </p>
    <p>
     3、这里 3D 水果和炸弹，使用 Collider 3D 碰撞体，但是使用了的是 Trigger 效果，Knife 可以喝水果碰撞，触发事件，但是不会发生实际碰撞效果
    </p>
    <p>
     4、这里水果或者水果碎片回收，使用的是 OnBecameInvisible() 函数（编辑状态下，包括编辑Scene 的窗口，不仅仅是游戏Game窗口），既是：水果出相机视野，则进行，对应的回收，对象池中继续使用，节约性能
    </p>
    <p>
     5、脚本复刻这块建议：先复刻 Common 和 Tools 文件夹的脚本，然后 Fruit 和 Effect 文件夹的脚本，接着 Manager 的各个脚本（顺序可按实现步骤的顺序来），最后 GameManager 和 GameStart 即可
    </p>
    <p>
     6、这里值得注意的是，水果的枚举的作用：1）枚举值是随机生成水果的随机值对应；2）枚举是对应的预制体名称一致；3）枚举是对饮水果的脚本名称一致
    </p>
    <p>
    </p>
    <h3 id="%E5%9B%9B%E3%80%81%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6">
     四、游戏代码框架
    </h3>
    <p>
     <img alt="" height="421" src="https://i-blog.csdnimg.cn/blog_migrate/7a9f723a7cd1964b6f8f2ad0d2fedebf.png" width="1200"/>
    </p>
    <p>
     <img alt="" height="421" src="https://i-blog.csdnimg.cn/blog_migrate/ce28ce7f683bd3373d0171b49f811515.png" width="1169"/>
    </p>
    <p>
     <img alt="" height="276" src="https://i-blog.csdnimg.cn/blog_migrate/008be592c4512cf9522988c7e1021c7d.png" width="687"/>
    </p>
    <p>
    </p>
    <h3 id="%E4%BA%94%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9">
     五、知识点
    </h3>
    <p>
     1、MonoBehaviour 生命周期函数：Awake，Start，Update，Destroy
    </p>
    <p>
     2、Input 按键的监控鼠标按键的状态
    </p>
    <p>
     3、GameObject.Instantiate 物体的生成，GameObject.Destroy 物体的销毁
    </p>
    <p>
     4、简单的对象池管理
    </p>
    <p>
     5、Rigidbody 重力效果，添加 CirecleCollider ，进行 碰撞检测（Trigger）
    </p>
    <p>
     6、简单UGUI的使用
    </p>
    <p>
     7、简单屏幕适配（主要是UI和 水果生成位置）
    </p>
    <p>
     8、一些数据，路径等的统一常量管理
    </p>
    <p>
     9、Transform.Rotate 旋转使用
    </p>
    <p>
     10、IEnumerator 协程 ， StartCoroutine 开始协程 和 StopAllCoroutines 停止所有协程的使用
    </p>
    <p>
     11、IManager 简单的接口规范 Manager 类函数
    </p>
    <p>
     12、Action&lt;int&gt; OnChangeValue 属性变化中委托的使用
    </p>
    <p>
     13、Resources.Load&lt;GameObject&gt;() 代码加载预制体的使用
    </p>
    <p>
     14、简单的屏幕坐标转为世界坐标的工具类
    </p>
    <p>
     15、 SceneManager.LoadScene 加载，和 SceneManager.GetActiveScene() 当前场景的获取
    </p>
    <p>
     16、游戏开发的资源脚本文件夹分类管理
    </p>
    <p>
     17、等等
    </p>
    <h3 id="%E5%85%AD%E3%80%81%E6%B8%B8%E6%88%8F%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88%E2%80%8B">
     <br/>
     六、游戏效果预览
     <br/>
     <img alt="" height="441" src="https://i-blog.csdnimg.cn/blog_migrate/6a51f3f32cc55b665ce76191368ceadb.gif" width="991"/>
    </h3>
    <p>
    </p>
    <p>
    </p>
    <h3 id="%E4%B8%83%E3%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">
     七、实现步骤
    </h3>
    <p>
     1、打开 Unity，导入水果 等相关资源
    </p>
    <p>
     <img alt="" height="407" src="https://i-blog.csdnimg.cn/blog_migrate/48c0d42c93a303cc8fb534ce257a7276.png" width="679"/>
    </p>
    <p>
    </p>
    <p>
     2、然后把对应的资源做成预制体
    </p>
    <p>
     <img alt="" height="371" src="https://i-blog.csdnimg.cn/blog_migrate/9c4d763c266caf71b009c7adeb91b8a8.png" width="697"/>
    </p>
    <p>
    </p>
    <p>
     3、这个说明一下 Knife 的制作过程：1）图片是刀锋，可以替换图片更换刀锋；2） 创建一个拖尾的材质Trail，对应shader 为 Particles/Additive，并赋值对应刀锋图；3）创建一个 Sphere ，改名为Knife，添加 TrailRenderer 组件，并赋值 Trail 材质，TrailRenderer  Time 适当改小为 0.1，Knife scale 适当改小为 0.2（可参照实际水果大小调整）
    </p>
    <p>
     <img alt="" height="404" src="https://i-blog.csdnimg.cn/blog_migrate/f8e82f673eecbab04a301bdb718edbeb.png" width="769"/>
    </p>
    <p>
     <img alt="" height="745" src="https://i-blog.csdnimg.cn/blog_migrate/dfc71da292f08db1c9b0d7741f4cc7b2.png" width="742"/>
    </p>
    <p>
     <img alt="" height="823" src="https://i-blog.csdnimg.cn/blog_migrate/f7a62f02547f3311a371709519079970.png" width="741"/>
    </p>
    <p>
     <img alt="" height="325" src="https://i-blog.csdnimg.cn/blog_migrate/54b882fb1efa57931f08b33c06f796ec.png" width="1122"/>
    </p>
    <p>
    </p>
    <p>
     4、取消 Knife 的MeshRenderer 渲染，保留 Collier ，用于与水果触发碰撞事件
    </p>
    <p>
     <img alt="" height="271" src="https://i-blog.csdnimg.cn/blog_migrate/2dff4fa585e079a09b09dea7ee0328d3.png" width="704"/>
    </p>
    <p>
    </p>
    <p>
     5、其中水果预制体，添加 Rigibody，和 MeshCollider ，MeshCollider  勾选 Convex 和 Is Trigger（碰撞的时候只触发碰撞事件，不发生实际碰撞效果），Bomb 类似操作
    </p>
    <p>
     <img alt="" height="600" src="https://i-blog.csdnimg.cn/blog_migrate/27f2284abfc3fc5cbc3659ffc76b51a0.png" width="761"/>
    </p>
    <p>
     <img alt="" height="434" src="https://i-blog.csdnimg.cn/blog_migrate/df1aa2878aa832ebffa3a432c01efba6.png" width="748"/>
    </p>
    <p>
    </p>
    <p>
     6、BombEffect 和 Splash 是 Spriterenderer 图片动画来的
    </p>
    <p>
     <img alt="" height="347" src="https://i-blog.csdnimg.cn/blog_migrate/48bf0ee9d0697c3f296a91bbcaf3eb75.png" width="669"/>
    </p>
    <p>
     <img alt="" height="456" src="https://i-blog.csdnimg.cn/blog_migrate/797b988dc6cc7900b4071853039936a5.png" width="1082"/>
    </p>
    <p>
    </p>
    <p>
     7、在场景中，创建一个 GameObject，改名为 World（pos(0,0,0)），把默认的Main Camera（位置修改为（0,0,0）） 和 Direction Light 至于World 下面，类似依次创建 GameObject，改名为 SpawnFruitPos、SpawnSplashPos、SpawnKnifePos、SpawnBombPos、SpawnBombEffectPos，位置都为（0,0,0），功能如其名，用来把对应生成的游戏物体统一管理
    </p>
    <p>
     <img alt="" height="413" src="https://i-blog.csdnimg.cn/blog_migrate/1c682b31b2ce2e87d79521637b6fc176.png" width="744"/>
    </p>
    <p>
     <img alt="" height="376" src="https://i-blog.csdnimg.cn/blog_migrate/acf0478282762d9bbb1bab2befb90962.png" width="722"/>
    </p>
    <p>
     <img alt="" height="517" src="https://i-blog.csdnimg.cn/blog_migrate/3c9adf45bcebb789f995783e19f8e921.png" width="735"/>
    </p>
    <p>
     <img alt="" height="331" src="https://i-blog.csdnimg.cn/blog_migrate/9c547a3f7fabcc9168e394662e387d1f.png" width="742"/>
    </p>
    <p>
    </p>
    <p>
     8、创建一个 GameObject，改名为UI（Pos(0,0,0)），添加一个Canvas （自动添加EventSystem），设置 Canvas Scaler 的 UI Scale Mode 为 Scale with Screen Size ，Reference Resolution 为  1080 x 1920 ，Match 滑动到 Height
    </p>
    <p>
     <img alt="" height="697" src="https://i-blog.csdnimg.cn/blog_migrate/7ff7ebf047dfd50a6b6700f985415d14.png" width="758"/>
    </p>
    <p>
    </p>
    <p>
     9、LifeText 放置在左边上，改变锚点，文字加粗居中显示，可以根据实际情况自行调整
    </p>
    <p>
     <img alt="" height="571" src="https://i-blog.csdnimg.cn/blog_migrate/977862ad20b5da54aca5cda03c959a43.png" width="712"/>
    </p>
    <p>
    </p>
    <p>
     10、ScoreText 放置在右边上，改变锚点，文字加粗居中显示，可以根据实际情况自行调整
    </p>
    <p>
     <img alt="" height="590" src="https://i-blog.csdnimg.cn/blog_migrate/09270270452446e1b032c091a8a58f60.png" width="730"/>
    </p>
    <p>
    </p>
    <p>
     11、GameOverImage 图片铺满屏幕，设置为黑色，增加透明度，GameOverText 文字加粗居中显示，RestartGameButton 放大，文字调大，可以根据实际情况自行调整，最终如图
    </p>
    <p>
     <img alt="" height="495" src="https://i-blog.csdnimg.cn/blog_migrate/544d0f6a000b684dc8e1ba80fbfdf286.png" width="733"/>
    </p>
    <p>
     <img alt="" height="593" src="https://i-blog.csdnimg.cn/blog_migrate/167dd25d66ab6df3b3d6d649d8e9a774.png" width="730"/>
    </p>
    <p>
     <img alt="" height="617" src="https://i-blog.csdnimg.cn/blog_migrate/723af25e0f5675c93464491947cbbec9.png" width="754"/>
    </p>
    <p>
    </p>
    <p>
     12、修改屏幕为 1080x1920 ，最终 UI 效果如下
    </p>
    <p>
     <img alt="" height="487" src="https://i-blog.csdnimg.cn/blog_migrate/703a67d76bcc80396d596a61d173ff19.png" width="1084"/>
    </p>
    <p>
    </p>
    <p>
     13、在工程中添加 Enum 脚本，管理所有枚举，目前只是水果类型，和水果破碎类型枚举
    </p>
    <p>
     <img alt="" height="377" src="https://i-blog.csdnimg.cn/blog_migrate/e0002ecf7b254fbc60c311bece041d70.png" width="608"/>
    </p>
    <pre><code class="language-cs">	/// &lt;summary&gt;
	/// 水果类型
	/// &lt;/summary&gt;
	public enum FruitType { 
		Apple = 0,
		Lemon,
		Watermelon,

		SUM_COUNT, // 水果类型总数
	}

	/// &lt;summary&gt;
	/// 破碎水果类型
	/// &lt;/summary&gt;
	public enum FruitBrokenType { 
		Apple_Broken = 0,
		Lemon_Broken,
		Watermelon_Broken,


		SUM_COUNT,  // 破碎水果类型总数
	}</code></pre>
    <p>
    </p>
    <p>
     14、在工程中添加 GameConfig 脚本，管理游戏中的一些数据
    </p>
    <p>
     <img alt="" height="396" src="https://i-blog.csdnimg.cn/blog_migrate/1bf420f4f7fb60db5998e29ed7423da9.png" width="653"/>
    </p>
    <pre><code class="language-cs">	/// &lt;summary&gt;
	/// 游戏配置数据
	/// &lt;/summary&gt;
	public class GameConfig 
	{
		public const string NAME_SPACE_NAME = "MGP_005CutFruit.";

		// Knife 预制体名称（用于碰撞触发判断使用）
		public const string KNIFE_NAME = "Knife";

		// 水果、炸弹、Knife 等游戏生成的统一深度距离
		public const float GAME_OBJECT_Z_VALUE = 5;	

		// 底部间隔几秒生成物体
		public const float BOTTOM_SPAWN_INTERVAL_TIME = 2;	

		// 游戏生命（可切破几次炸弹）
		public const int GAME_LIFE_LENGTH = 3;
		// 游戏剩余几条命结束
		public const int REMAIN_LIFE_IS_GAME_OVER = 0;

		// 水果 炸弹生成向上的最小最大速度
		public const float FRUIT_UP_Y_VELOSITY_MIN_VALUE = 8;
		public const float FRUIT_UP_Y_VELOSITY_MAX_VALUE = 10;

		/// &lt;summary&gt;
		/// 随机生成水果炸弹的数值范围
		/// 随机数多少是炸弹
		/// &lt;/summary&gt;
		public const int FRUIT_RANDOM_MIN_VALUE = 0;
		public const int FRUIT_RANDOM_MAX_VALUE = 15;
		public const int BOMB_RANDOM_VALUE = 10;

		/// &lt;summary&gt;
		/// 切刀不同水果的得分
		/// &lt;/summary&gt;
		public const int FRUIT_APPLE_SCORE = 10;
		public const int FRUIT_LEMON_SCORE = 20;
		public const int FRUIT_WATERMELON_SCORE = 30;

		//切到炸弹失去的生命值
		public const int BOMB_REDUCE_LIFE = 1;
	}</code></pre>
    <p>
    </p>
    <p>
     15、在工程中添加 GameObjectPathInSceneDefine 脚本，定义场景中的游戏物体路径类，ResPathDefine 定义预制体路径类
    </p>
    <p>
     <img alt="" height="445" src="https://i-blog.csdnimg.cn/blog_migrate/a8f8b030a005c929bd51e58ffbfeab16.png" width="740"/>
    </p>
    <p>
     <img alt="" height="438" src="https://i-blog.csdnimg.cn/blog_migrate/22b1738e0650f36cf4a8b08ab8ba4076.png" width="746"/>
    </p>
    <pre><code class="language-cs">	/// &lt;summary&gt;
	/// 定义场景中的游戏物体路径类
	/// &lt;/summary&gt;
	public class GameObjectPathInSceneDefine 
	{
		public const string WORLD_PATH = "World";
		public const string UI_PATH = "UI";

		public const string SPAWN_FRUIT_POS_PATH = "SpawnFruitPos";
		public const string SPAWN_SPLASH_POS_PATH = "SpawnSplashPos";
		public const string SPAWN_KNIFE_POS_PATH = "SpawnKnifePos";
		public const string SPAWN_BMOB_POS_PATH = "SpawnBombPos";
		public const string SPAWN_BMOB_EFFECT_POS_PATH = "SpawnBombEffectPos";


		public const string UI_LIFE_TEXT_PATH = "Canvas/LifeText";
		public const string UI_SCORE_TEXT_PATH = "Canvas/ScoreText";
		public const string UI_GAME_OVER_IMAGE_PATH = "Canvas/GameOverImage";
		public const string UI_RESTART_GAME_BUTTON_PATH = "Canvas/GameOverImage/RestartGameButton";


	}

	/// &lt;summary&gt;
	/// 定义预制体路径类
	/// &lt;/summary&gt;
	public class ResPathDefine 
	{
		public const string FRUIT_PREFAB_BASE_PATH = "Prefabs/CutFruits/";

		public const string SPLASH_PREFAB_PATH = "Prefabs/Splash";
		public const string KNIFE_PREFAB_PATH = "Prefabs/Knife";
		public const string BOMB_PREFAB_PATH = "Prefabs/Bomb";
		public const string BOMB_EFFECT_PREFAB_PATH = "Prefabs/BombEffect";
	}</code></pre>
    <p>
    </p>
    <p>
     16、在工程中添加 BaseFruit 脚本，水果基类脚本，主要管理水果和 Knife 碰撞事件（加分，生成水果碎片，特效等），以及出相机视野外的回收处理，关键代码如下
    </p>
    <p>
     <img alt="" height="477" src="https://i-blog.csdnimg.cn/blog_migrate/29184845984bc39b10b41bbed918c78e.png" width="673"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 碰撞事件
        /// &lt;/summary&gt;
        /// &lt;param name="other"&gt;&lt;/param&gt;
        private void OnTriggerEnter(Collider other)
        {
            if (other.name.StartsWith( GameConfig.KNIFE_NAME))
            {
                //增加分数
                m_DataModelManager.Score.Value += Score;


                for (int i = 0; i &lt; 2; i++)
                {
                    //产生破碎的水果
                    FruitBroken fruitBroken = SpawnBroken();
                    fruitBroken.Init(FruitBrokenType,m_FruitManager);
                    GameObject temp = fruitBroken.gameObject;
                    temp.SetActive(true);
                    temp.transform.position = transform.position;
                    temp.transform.eulerAngles = new Vector3(Random.Range(0, 360), Random.Range(0, 360), Random.Range(0, 360));
                    //-3 -2  2 3

                    // 随机水果碎片速度
                    float x, y;
                    int ranX = Random.Range(0, 2);
                    if (ranX == 0)
                    {
                        x = Random.Range(-3.0f, -2.0f);
                    }
                    else
                    {
                        x = Random.Range(2.0f, 3.0f);
                    }

                    int ranY = Random.Range(0, 2);
                    if (ranY == 0)
                    {
                        y = Random.Range(-3.0f, -2.0f);
                    }
                    else
                    {
                        y = Random.Range(2.0f, 3.0f);
                    }

                    temp.GetComponent&lt;Rigidbody&gt;().velocity = new Vector2(x, y);

                }

                //产生果汁特效
                Splash splash = SpawnSplash();
                splash.transform.position = transform.position;
                splash.transform.rotation = Quaternion.Euler(Vector3.forward * Random.Range(-180,180));
                splash.Show(FruitSplahColor, m_SplashManager.RecycleSplah);
                

                //隐藏水果物体
                m_FruitManager.RecycleFruit(FruitType,this);
                m_IsRecycle = false;
            }
            if (other.tag == "BottomCollider")
            {
                gameObject.SetActive(false);
            }
        }

        private void OnBecameVisible()
        {
            m_IsRecycle = true;
        }

        /// &lt;summary&gt;
        /// 相机视野外
        /// 回收水果
        /// &lt;/summary&gt;
        private void OnBecameInvisible()
        {
            if (m_IsRecycle==true)
            {
                m_FruitManager.RecycleFruit(FruitType, this);
                m_IsRecycle = false;

            }
        }</code></pre>
    <p>
    </p>
    <p>
     17、在工程中添加Apple、Lemon、Watermelon 脚本，继承 BaseFruit ，实现抽象类，设置其对应水果类型，水果破碎类型，碎果Splash 颜色，和得分
    </p>
    <p>
     <img alt="" height="494" src="https://i-blog.csdnimg.cn/blog_migrate/1d3011e86c6932d9807e7ad021a95fd4.png" width="681"/>
    </p>
    <pre><code class="language-cs">	public class Apple : BaseFruit
	{
       

        public override FruitType FruitType =&gt; FruitType.Apple;

        public override FruitBrokenType FruitBrokenType =&gt; FruitBrokenType.Apple_Broken;

        public override Color FruitSplahColor =&gt; Color.red;

        public override int Score =&gt; GameConfig.FRUIT_APPLE_SCORE;
    }</code></pre>
    <p>
    </p>
    <p>
     18、在工程中添加 FruitManager 脚本，主要管理水果和水果碎片的预制体加载，以及水果和水果碎片对象池的初始化，并提供接口，从对象池中获取水果和水果碎片，和回收水果和水果碎片
    </p>
    <p>
     <img alt="" height="484" src="https://i-blog.csdnimg.cn/blog_migrate/63b51bcacb0cce5f7edf666e7af838c1.png" width="675"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 获取水果碎片
        /// &lt;/summary&gt;
        /// &lt;param name="fruitBrokenType"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public FruitBroken GetFruitBroken(FruitBrokenType fruitBrokenType)
        {
            Queue&lt;FruitBroken&gt; fruitBrokenQue = m_FruitBrokenObjectPoolDict[fruitBrokenType];
            if (fruitBrokenQue.Count &gt; 0)
            {
                return fruitBrokenQue.Dequeue();
            }
            else
            {
                return InstantiateFruitBroken(fruitBrokenType);
            }
        }

        /// &lt;summary&gt;
        /// 回收水果
        /// &lt;/summary&gt;
        /// &lt;param name="fruitType"&gt;&lt;/param&gt;
        /// &lt;param name="baseFruit"&gt;&lt;/param&gt;
        public void RecycleFruit(FruitType fruitType,BaseFruit baseFruit) {
            baseFruit.gameObject.SetActive(false);
            if (m_FruitObjectPoolDict!=null &amp;&amp; m_FruitObjectPoolDict[fruitType]!=null)
            {
                m_FruitObjectPoolDict[fruitType].Enqueue(baseFruit);

            }
        }

        /// &lt;summary&gt;
        /// 回收水果碎片
        /// &lt;/summary&gt;
        /// &lt;param name="fruitBrokenType"&gt;&lt;/param&gt;
        /// &lt;param name="fruitBroken"&gt;&lt;/param&gt;
        public void RecycleFruitBroken(FruitBrokenType fruitBrokenType, FruitBroken fruitBroken)
        {
            fruitBroken.gameObject.SetActive(false);
            m_FruitBrokenObjectPoolDict[fruitBrokenType].Enqueue(fruitBroken);
        }

        /// &lt;summary&gt;
        /// 加载预制体和预载水果到对象池中
        /// &lt;/summary&gt;
        private void InitFruit() {

            // 加载预制体
            m_FruitPrefabsDict = new Dictionary&lt;string, GameObject&gt;();
            for (FruitType fruitType = FruitType.Apple; fruitType &lt; FruitType.SUM_COUNT; fruitType++)
            {
                GameObject prefab = Resources.Load&lt;GameObject&gt;(ResPathDefine.FRUIT_PREFAB_BASE_PATH+fruitType.ToString());
                if (prefab == null)
                {
                    Debug.LogError(GetType() + "/InitFruit()/prefab is null, path = " + ResPathDefine.FRUIT_PREFAB_BASE_PATH + fruitType.ToString());
                }
                else {
                    m_FruitPrefabsDict.Add(fruitType.ToString(),prefab);
                }
            }

            // 加载预制体
            for (FruitBrokenType fruitBrokenType = FruitBrokenType.Apple_Broken; fruitBrokenType &lt; FruitBrokenType.SUM_COUNT; fruitBrokenType++)
            {
                GameObject prefab = Resources.Load&lt;GameObject&gt;(ResPathDefine.FRUIT_PREFAB_BASE_PATH + fruitBrokenType.ToString());
                if (prefab == null)
                {
                    Debug.LogError(GetType() + "/InitFruit()/prefab is null, path = " + ResPathDefine.FRUIT_PREFAB_BASE_PATH + fruitBrokenType.ToString());
                }
                else
                {
                    m_FruitPrefabsDict.Add(fruitBrokenType.ToString(), prefab);
                }
            }

            // 预载水果
            m_FruitObjectPoolDict = new Dictionary&lt;FruitType, Queue&lt;BaseFruit&gt;&gt;();
            for (FruitType fruitType = FruitType.Apple; fruitType &lt; FruitType.SUM_COUNT; fruitType++) {
                Queue&lt;BaseFruit&gt; fruits = new Queue&lt;BaseFruit&gt;();
                m_FruitObjectPoolDict.Add(fruitType, fruits);

                RecycleFruit(fruitType, InstantiateFruit(fruitType));
            }

            // 预载水果 Broken
            m_FruitBrokenObjectPoolDict = new Dictionary&lt;FruitBrokenType, Queue&lt;FruitBroken&gt;&gt;();
            for (FruitBrokenType fruitBrokenType = FruitBrokenType.Apple_Broken; fruitBrokenType &lt; FruitBrokenType.SUM_COUNT; fruitBrokenType++)
            {
                Queue&lt;FruitBroken&gt; fruitBrokens = new Queue&lt;FruitBroken&gt;();
                m_FruitBrokenObjectPoolDict.Add(fruitBrokenType, fruitBrokens);

                RecycleFruitBroken(fruitBrokenType, InstantiateFruitBroken(fruitBrokenType));
            }
        }

        /// &lt;summary&gt;
        /// 生成指定水果对象
        /// &lt;/summary&gt;
        /// &lt;param name="fruitType"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private BaseFruit InstantiateFruit(FruitType fruitType) {
            GameObject fruit = GameObject.Instantiate(m_FruitPrefabsDict[fruitType.ToString()], m_SpawnFruitPosTrans);
            // 反射获取脚本类型，添加脚本 (注意添加命名空间)
            Type type = Type.GetType( GameConfig.NAME_SPACE_NAME+ fruitType.ToString());
            return (fruit.AddComponent(type) as BaseFruit);
        }

        /// &lt;summary&gt;
        /// 生成破碎水果
        /// &lt;/summary&gt;
        /// &lt;param name="fruitBrokenType"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private FruitBroken InstantiateFruitBroken(FruitBrokenType fruitBrokenType)
        {
            GameObject fruit = GameObject.Instantiate(m_FruitPrefabsDict[fruitBrokenType.ToString()], m_SpawnFruitPosTrans);
          
            return fruit.AddComponent&lt;FruitBroken&gt;();
        }</code></pre>
    <p>
    </p>
    <p>
     19、在工程中添加 Bomb 脚本，主要功能是 Bomb 与 Knife 的碰撞（减少生命值，以及生成特效），以及相机视野外后回收
    </p>
    <p>
     <img alt="" height="491" src="https://i-blog.csdnimg.cn/blog_migrate/e06448e96e9444053882406e6e855901.png" width="677"/>
    </p>
    <pre><code class="language-cs">        private void OnTriggerEnter(Collider other)
        {
            if (other.name.StartsWith( GameConfig.KNIFE_NAME))
            {
                //减少生命值
                m_DataModelManager.Life.Value -= GameConfig.BOMB_REDUCE_LIFE;

                //产生爆炸特效
                BombEffect bombEffect = m_BombEffectManager.GetBombEffect();
                bombEffect.Show(transform.position, m_BombEffectManager.RecycleBombEffect);

                //隐藏物体
                m_BmobManager.RecycleBomb(this);
            }
        }


        private void OnBecameVisible()
        {
            m_IsRecycle = true;
        }


        /// &lt;summary&gt;
        /// 相机是野外事件
        /// &lt;/summary&gt;
        private void OnBecameInvisible()
        {
            if (m_IsRecycle == true)
            {
                m_BmobManager.RecycleBomb( this);
                m_IsRecycle = false;

            }
        }</code></pre>
    <p>
    </p>
    <p>
     20、在工程中添加 BombManager 脚本，主要管理 Bomb 预制体加载，对象池初始化，提供接口获取和回收 Bomb
    </p>
    <p>
     <img alt="" height="608" src="https://i-blog.csdnimg.cn/blog_migrate/9f81125b85e1212c384c9fce72f182e2.png" width="622"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 获取 Bomb 
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Bomb GetBmob()
        {
            if (m_BombQueue.Count &gt; 0)
            {
                Bomb bomb = m_BombQueue.Dequeue();
                bomb.gameObject.SetActive(true);
                return bomb;
            }
            else
            {
                return InstantiateBomb();
            }
        }

        /// &lt;summary&gt;
        /// 回收 Bomb 
        /// &lt;/summary&gt;
        /// &lt;param name="bomb"&gt;&lt;/param&gt;
        public void RecycleBomb(Bomb bomb)
        {
            bomb.gameObject.SetActive(false);
            m_BombQueue.Enqueue(bomb);
        }

        /// &lt;summary&gt;
        /// 初始化
        /// &lt;/summary&gt;
        private void InitBmob()
        {
            // 加载预制体
            m_BombPrefab = Resources.Load&lt;GameObject&gt;(ResPathDefine.BOMB_PREFAB_PATH);

            // 预载 Bomb
            m_BombQueue = new Queue&lt;Bomb&gt;();
            RecycleBomb(InstantiateBomb());
        }

        private Bomb InstantiateBomb()
        {
            GameObject go = GameObject.Instantiate(m_BombPrefab, m_SpawnBombPosTrans);

            return go.AddComponent&lt;Bomb&gt;();
        }</code></pre>
    <p>
    </p>
    <p>
     21、在工程中添加 BombEffect 脚本，主要功能是 显示特效，并且定时回收特效
    </p>
    <p>
     <img alt="" height="446" src="https://i-blog.csdnimg.cn/blog_migrate/4ed72011978c0b9a09f995c058192b43.png" width="690"/>
    </p>
    <pre><code class="language-cs">		/// &lt;summary&gt;
		/// 显示特效
		/// &lt;/summary&gt;
		/// &lt;param name="pos"&gt;&lt;/param&gt;
		/// &lt;param name="showAnimationEndAction"&gt;&lt;/param&gt;
		public void Show(Vector3 pos, Action&lt;BombEffect&gt; showAnimationEndAction)
		{
			// 赋值位置和随机旋转，并且定时回收
			transform.position = pos;
			transform.rotation = Quaternion.Euler(Vector3.forward * UnityEngine.Random.Range(-180, 180));
			StartCoroutine(Recycle(showAnimationEndAction));

		}

		/// &lt;summary&gt;
		/// 协程回收特效
		/// &lt;/summary&gt;
		/// &lt;param name="showAnimationEndAction"&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		IEnumerator Recycle(Action&lt;BombEffect&gt; showAnimationEndAction) {
			yield return new WaitForSeconds(m_AnimationLength);
            if (showAnimationEndAction!=null)
            {
				showAnimationEndAction.Invoke(this);

			}
		}</code></pre>
    <p>
    </p>
    <p>
     22、在工程中添加 BombEffectManager 脚本，主要管理 Bomb 预制体加载，对象池初始化，提供接口获取和回收 BombEffect
    </p>
    <p>
     <img alt="" height="427" src="https://i-blog.csdnimg.cn/blog_migrate/a7fafe5315769c61adf5104302a628ea.png" width="726"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 获取爆炸特效
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public BombEffect GetBombEffect()
        {
            if (m_BombEffectQueue.Count &gt; 0)
            {
                BombEffect bombEffect = m_BombEffectQueue.Dequeue();
                bombEffect.gameObject.SetActive(true);
                return bombEffect;
            }
            else
            {
                return InstantiateBombEffect();
            }
        }

        /// &lt;summary&gt;
        /// 回收爆炸特效
        /// &lt;/summary&gt;
        /// &lt;param name="bombEffect"&gt;&lt;/param&gt;
        public void RecycleBombEffect(BombEffect bombEffect)
        {
            bombEffect.gameObject.SetActive(false);
            m_BombEffectQueue.Enqueue(bombEffect);
        }

        /// &lt;summary&gt;
        /// 初始化特效
        /// &lt;/summary&gt;
        private void InitBombEffect()
        {
            // 加载预制体
            m_BombEffectPrefab = Resources.Load&lt;GameObject&gt;(ResPathDefine.BOMB_EFFECT_PREFAB_PATH);

            // 预载 BombEffect
            m_BombEffectQueue = new Queue&lt;BombEffect&gt;();
            RecycleBombEffect(InstantiateBombEffect());
        }

        private BombEffect InstantiateBombEffect()
        {
            GameObject go = GameObject.Instantiate(m_BombEffectPrefab, m_SpawnBombEffectPosTrans);

            return go.AddComponent&lt;BombEffect&gt;();
        }</code></pre>
    <p>
    </p>
    <p>
     23、在工程中添加 Splash 脚本，主要功能是 显示 Splash ，并且定时回收 Splash
    </p>
    <p>
     <img alt="" height="484" src="https://i-blog.csdnimg.cn/blog_migrate/f00cc522b0d53cb2409850a4d4e568d4.png" width="658"/>
    </p>
    <pre><code class="language-cs">		/// &lt;summary&gt;
		/// 显示特效
		/// &lt;/summary&gt;
		/// &lt;param name="color"&gt;&lt;/param&gt;
		/// &lt;param name="showAnimationEndAction"&gt;&lt;/param&gt;
		public void Show(Color32 color, Action&lt;Splash&gt; showAnimationEndAction)
		{
			StartCoroutine(EffectAnimation(color, showAnimationEndAction));
		}

		/// &lt;summary&gt;
		/// 特效动画
		/// &lt;/summary&gt;
		/// &lt;param name="color"&gt;&lt;/param&gt;
		/// &lt;param name="showAnimationEndAction"&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		IEnumerator EffectAnimation(Color color, Action&lt;Splash&gt; showAnimationEndAction)
		{
			m_ColorValue = 0;
			color.a = 0;
			SpriteRenderer.color = color;
			while (true)
			{
				// lerp 匀速插值处理
				m_ColorValue += 1.0f / SPEED * Time.deltaTime;
				color.a = Mathf.Lerp(color.a, 1, m_ColorValue);
				SpriteRenderer.color = color;
				if ((1 - color.a &lt;= 0.05f))
				{
					color.a = 1;
					SpriteRenderer.color = color;

					break;
				}


				yield return new WaitForEndOfFrame();
			}
			m_ColorValue = 0;
			while (true)
			{
				// lerp 匀速插值处理
				m_ColorValue += 1.0f / SPEED * Time.deltaTime;
				color.a = Mathf.Lerp(color.a, 0, m_ColorValue);
				SpriteRenderer.color = color;
				if ((color.a - 0) &lt;= 0.05f)
				{
					color.a = 0;
					SpriteRenderer.color = color;
					break;
				}


				yield return new WaitForEndOfFrame();
			}


			if (showAnimationEndAction != null)
			{
				showAnimationEndAction.Invoke(this);
			}
		}</code></pre>
    <p>
    </p>
    <p>
     24、在工程中添加 SplashManager 脚本，主要管理 Bomb 预制体加载，对象池初始化，提供接口获取和回收 Splash
    </p>
    <p>
     <img alt="" height="282" src="https://i-blog.csdnimg.cn/blog_migrate/64886939ffec9f476e60b95e2ed918d0.png" width="656"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 获取 Splash
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Splash GetSplash()
        {
            if (m_SplashQueue.Count &gt; 0)
            {
                Splash splash = m_SplashQueue.Dequeue();
                splash.gameObject.SetActive(true);
                return splash;
            }
            else
            {
                return InstantiateSplash();
            }
        }

        /// &lt;summary&gt;
        /// 回收 Splash
        /// &lt;/summary&gt;
        /// &lt;param name="splash"&gt;&lt;/param&gt;
        public void RecycleSplah(Splash splash)
        {
            splash.gameObject.SetActive(false);
            m_SplashQueue.Enqueue(splash);
        }

        /// &lt;summary&gt;
        /// 初始化 SPlash
        /// &lt;/summary&gt;
        private void InitSplash()
        {
            // 加载预制体
            m_SplashPrefab = Resources.Load&lt;GameObject&gt;(ResPathDefine.SPLASH_PREFAB_PATH);

            // 预载Splash
            m_SplashQueue = new Queue&lt;Splash&gt;();
            RecycleSplah(InstantiateSplash());
        }

        private Splash InstantiateSplash()
        {
            GameObject go = GameObject.Instantiate(m_SplashPrefab, m_SpawnSplashPosTrans);

            return go.AddComponent&lt;Splash&gt;();
        }</code></pre>
    <p>
    </p>
    <p>
     25、在工程中添加 Tools 脚本，主要功能是 把屏幕坐标转为世界坐标
    </p>
    <p>
     <img alt="" height="439" src="https://i-blog.csdnimg.cn/blog_migrate/6f01f87dbf5bbdbd74e41ac96b35b350.png" width="715"/>
    </p>
    <pre><code class="language-cs">public class Tools
	{
		/// &lt;summary&gt;
		/// 把屏幕坐标转为世界坐标
		/// &lt;/summary&gt;
		/// &lt;param name="refTran"&gt;对应参照对象&lt;/param&gt;
		/// &lt;param name="refCamera"&gt;对应参照相机&lt;/param&gt;
		/// &lt;param name="screenPos"&gt;屏幕位置&lt;/param&gt;
		/// &lt;returns&gt;屏幕位置的世界位置&lt;/returns&gt;
		public static Vector3 ScreenPosToWorldPos(Transform refTran, Camera refCamera, Vector2 screenPos)
		{
			//将对象坐标换成屏幕坐标
			Vector3 pos = refCamera.WorldToScreenPoint(refTran.position);
			//让鼠标的屏幕坐标与对象坐标一致
			Vector3 mousePos = new Vector3(screenPos.x, screenPos.y, pos.z);
			//将正确的鼠标屏幕坐标换成世界坐标交给物体
			return refCamera.ScreenToWorldPoint(mousePos);

		}
	}</code></pre>
    <p>
    </p>
    <p>
     26、在工程中添加 KnifeManager 脚本，主要管理 Knife 预制体加载，监控鼠标按下情况，进行刀锋切水果功能
    </p>
    <p>
     <img alt="" height="406" src="https://i-blog.csdnimg.cn/blog_migrate/b501293f6744839180eacf346fd4ce8e.png" width="703"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 加载预制体
        /// &lt;/summary&gt;
        void LoadPrefab() {
            m_KnifePrefab = Resources.Load&lt;GameObject&gt;(ResPathDefine.KNIFE_PREFAB_PATH);
            if (m_KnifePrefab == null)
            {
                Debug.LogError(GetType() + "/LoadPrefab()/ prefab  is  null, path = " + ResPathDefine.KNIFE_PREFAB_PATH);
            }
            else {
                m_KnifeTrans = GameObject.Instantiate(m_KnifePrefab,m_SpawnKnifePosTrans).transform;
                m_KnifeTrans.position = Vector3.forward * GameConfig.GAME_OBJECT_Z_VALUE;
                m_KnifeTrans.gameObject.SetActive(false);
            }
        }

        /// &lt;summary&gt;
        /// 游戏未结束时，鼠标按下更新刀锋
        /// &lt;/summary&gt;
        void UpdateShowKnife() {
            if (m_KnifeTrans!=null &amp;&amp; m_IsGameOver==false)
            {
                if (Input.GetMouseButtonDown(0))
                {
                    m_KnifeTrans.position = Tools.ScreenPosToWorldPos(m_KnifeTrans, Camera.main, Input.mousePosition);
                    m_KnifeTrans.gameObject.SetActive(true);
                }
                else if (Input.GetMouseButton(0))
                {
                    m_KnifeTrans.position = Tools.ScreenPosToWorldPos(m_KnifeTrans, Camera.main, Input.mousePosition);
                }
                else if (Input.GetMouseButtonUp(0))
                {
                    m_KnifeTrans.gameObject.SetActive(false);
                }
            }
            
        }</code></pre>
    <p>
    </p>
    <p>
     27、在工程中添加 Model 脚本，主要功能是 分数和生命数据模型，包含数值记录，和数值变化事件委托
    </p>
    <p>
     <img alt="" height="399" src="https://i-blog.csdnimg.cn/blog_migrate/429167176d86f38eea67d313137341be.png" width="692"/>
    </p>
    <pre><code class="language-cs">	/// &lt;summary&gt;
	/// 数据模型
	/// &lt;/summary&gt;
	public class Model 
	{
		private int m_Value;
		public int Value
		{
			get { return m_Value; }
			set
			{
				if (m_Value != value)
				{
					m_Value = value;

					if (OnValueChanged != null)
					{
						OnValueChanged.Invoke(value);

					}
				}
			}
		}

		/// &lt;summary&gt;
		/// 数值变化事件
		/// &lt;/summary&gt;
		public Action&lt;int&gt; OnValueChanged;
	}</code></pre>
    <p>
    </p>
    <p>
     28、在工程中添加 DataModelManager 脚本，主要管理 分数Score 和 生命Life
    </p>
    <p>
     <img alt="" height="452" src="https://i-blog.csdnimg.cn/blog_migrate/8f7f1d5dcbef302b94f8309f2231eb5e.png" width="564"/>
    </p>
    <pre><code class="language-cs">        public Model Score =&gt; m_Scroe;
        public Model Life =&gt; m_Life;

        public void Init(Transform rootTrans, params object[] manager)
        {
            m_Scroe = new Model();
            m_Scroe.Value = 0;
            m_Life = new Model();
            m_Life.Value = GameConfig.GAME_LIFE_LENGTH;
        }</code></pre>
    <p>
    </p>
    <p>
     29、在工程中添加 UIManager 脚本，主要管理 UI 相关获取，以及数据显示，游戏结束，按钮事件重新加载游戏
    </p>
    <p>
     <img alt="" height="465" src="https://i-blog.csdnimg.cn/blog_migrate/4153aa0e4f05b045924f4c9c54c4d351.png" width="706"/>
    </p>
    <pre><code class="language-cs">        private Text m_LifeText;
        private Text m_ScoreText;
        private GameObject m_GameOverImageGo;
        private Button m_RestartGameButton;

        private DataModelManager m_DataModelManager;
        public void Init(Transform rootTrans, params object[] managers)
        {
            m_LifeText = rootTrans.Find(GameObjectPathInSceneDefine.UI_LIFE_TEXT_PATH).GetComponent&lt;Text&gt;();
            m_ScoreText = rootTrans.Find(GameObjectPathInSceneDefine.UI_SCORE_TEXT_PATH).GetComponent&lt;Text&gt;();
            m_GameOverImageGo = rootTrans.Find(GameObjectPathInSceneDefine.UI_GAME_OVER_IMAGE_PATH).gameObject;
            m_RestartGameButton = rootTrans.Find(GameObjectPathInSceneDefine.UI_RESTART_GAME_BUTTON_PATH).GetComponent&lt;Button&gt;();

            m_DataModelManager = managers[0] as DataModelManager;

            m_GameOverImageGo.SetActive(false);
            m_LifeText.text = m_DataModelManager.Life.Value.ToString();
            m_ScoreText.text = m_DataModelManager.Score.Value.ToString();
            m_DataModelManager.Life.OnValueChanged += OnLifeValueChanged;
            m_DataModelManager.Score.OnValueChanged += OnScroeValueChanged;
            m_RestartGameButton.onClick.AddListener(OnRestartButton);
        }

        public void OnGameOver()
        {
            m_GameOverImageGo.SetActive(true);
        }

        private void OnLifeValueChanged(int life)
        {
            m_LifeText.text = life.ToString();
        }

        private void OnScroeValueChanged(int score)
        {
            m_ScoreText.text = score.ToString();
        }

        private void OnRestartButton()
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }</code></pre>
    <p>
    </p>
    <p>
     30、在工程中添加 GameManager 脚本（单例脚本），主要功能：1)获取场景中相关游戏物体或者 UI，2）new 相关的 Manager 管理类，初始化Init，Update 、和Destroy；3）定时生成水果和炸弹；4）判断游戏是否结束；
    </p>
    <p>
     <img alt="" height="514" src="https://i-blog.csdnimg.cn/blog_migrate/53f6f363ebbe616fd6489de2ac6a6854.png" width="721"/>
    </p>
    <pre><code class="language-cs">        /// &lt;summary&gt;
        /// 底部生成
        /// &lt;/summary&gt;
        private void BottomSpawnFruitAndBomb()
        {
            GameObject go = null;
            // 随机数，判断生成水果还是炸弹
            int ran = Random.Range(GameConfig.FRUIT_RANDOM_MIN_VALUE, GameConfig.FRUIT_RANDOM_MAX_VALUE);
            if (ran != GameConfig.BOMB_RANDOM_VALUE)
            {
                BaseFruit fruit = m_FruitManager.GetRandomFruit();
                fruit.Init(m_FruitManager, m_SplashManager, m_DataModelManager);
                go = fruit.gameObject;
            }
            else
            {
                Bomb bomb = m_BmobManager.GetBmob();
                bomb.Init(m_BmobManager,m_BombEffectManager,m_DataModelManager);
                go = bomb.gameObject;
            }

            
            // 生成物体的位置和，向上速度
            go.transform.position = new Vector3(Random.Range(m_Bottom_Spawn_X_Min, m_Bottom_Spawn_X_Max), m_Bottom_Spawn_Y, GameConfig.GAME_OBJECT_Z_VALUE);
            go.transform.rotation = Quaternion.identity;
            go.GetComponent&lt;Rigidbody&gt;().velocity = new Vector2(0, Random.Range(GameConfig.FRUIT_UP_Y_VELOSITY_MIN_VALUE,
                GameConfig.FRUIT_UP_Y_VELOSITY_MAX_VALUE));

        }

        /// &lt;summary&gt;
        /// 判断游戏是否结束
        /// &lt;/summary&gt;
        /// &lt;param name="life"&gt;&lt;/param&gt;
        void JudageGameOverByLife(int life) {
            if (life == GameConfig.REMAIN_LIFE_IS_GAME_OVER)
            {
                OnGameOver();
            }
        }

        /// &lt;summary&gt;
        /// 结束的操作
        /// &lt;/summary&gt;
        void OnGameOver() {
            m_IsGameOver = true;
            m_UIManager.OnGameOver();
            m_KnifeManager.OnGameOver();
        }</code></pre>
    <p>
    </p>
    <p>
     31、在工程中添加 GameStart 脚本，整个游戏的入口，管理对应 GameManager 的 Awake()，Start()，Update()，OnDestroy() 对应函数功能
    </p>
    <p>
     <img alt="" height="403" src="https://i-blog.csdnimg.cn/blog_migrate/1a9b9caf22eb0c7e83bceb4c3a478e72.png" width="631"/>
    </p>
    <pre><code class="language-cs">    /// &lt;summary&gt;
    /// 游戏入口
    /// &lt;/summary&gt;
	public class GameStart : MonoBehaviour
	{
        private void Awake()
        {
            GameManager.Instance.Awake(this);
        }

        // Start is called before the first frame update
        void Start()
		{
            GameManager.Instance.Start();
        }

		// Update is called once per frame
		void Update()
		{
            GameManager.Instance.Update();
        }

        private void OnDestroy()
        {
            GameManager.Instance.Destroy();
        }
     }</code></pre>
    <p>
    </p>
    <p>
     32、在场景中添加 GameObject 空物体，改名为 GameStart，并且挂载 GameStart 脚本
    </p>
    <p>
     <img alt="" height="660" src="https://i-blog.csdnimg.cn/blog_migrate/5720a98a15cdcbc4d8233ed97bae8947.png" width="757"/>
    </p>
    <p>
    </p>
    <p>
     34、运行游戏，自动生水果，按下鼠标，既可以切割水果了
    </p>
    <p>
     <img alt="" height="456" src="https://i-blog.csdnimg.cn/blog_migrate/48298a9e7e19dc402ff5af94b55e9534.png" width="981"/>
    </p>
    <p>
     <img alt="" height="461" src="https://i-blog.csdnimg.cn/blog_migrate/b6da35130488559aea0b9197bbbedade.png" width="797"/>
    </p>
    <p>
    </p>
    <h3 id="%E5%85%AB%E3%80%81%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80">
     八、工程源码地址
    </h3>
    <p>
     github 地址：
     <a href="https://github.com/XANkui/UnityMiniGameParadise" title="GitHub - XANkui/UnityMiniGameParadise: Unity 游戏开发集合代码集">
      GitHub - XANkui/UnityMiniGameParadise: Unity 游戏开发集合代码集
     </a>
    </p>
    <p>
     的 MGP_005CutFruit 工程
    </p>
    <p>
    </p>
    <h3 id="%E4%B9%9D%E3%80%81%E5%BB%B6%E4%BC%B8%E6%89%A9%E5%B1%95">
     九、延伸扩展
    </h3>
    <p>
     游戏的好不好玩，趣味性，视觉化等诸多因素影响，下面简单介绍几个方面拓展游戏的方向，仅做参考
    </p>
    <p>
     1、可以根据自己需要修改游戏资源，换肤什么的等
    </p>
    <p>
     2、可以根据需要添加加分特效，音效，背景更多的细节变化等等
    </p>
    <p>
     3、添加 UI 面板等，美化游戏
    </p>
    <p>
     4、Effect 可以设置不同类型的的特效，或者3D 粒子特效
    </p>
    <p>
     5、特殊水果特殊事件，冰冻，火烧等；
    </p>
    <p>
     6、添加最高分数保留，和游戏排行榜等；
    </p>
    <p>
     7、炸弹的特效，可以进行设置不同炸弹，不同特效；
    </p>
    <p>
     8、水果生成只设置底部生成，可以添加两侧生成也生成水果炸弹等
    </p>
    <p>
     9、可以是设置，不同波数的水果数量，和间歇频次，定时游戏时间
    </p>
    <p>
     10、音乐音效也可以对应添加上，效果更好
    </p>
    <p>
     11、等等
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031343336313238302f:61727469636c652f64657461696c732f313232363136323432" class_="artid" style="display:none">
 </p>
</div>


