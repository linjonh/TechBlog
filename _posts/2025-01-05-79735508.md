---
layout: post
title: "数据结构哈希表线性探测法"
date: 2025-01-05 16:59:48 +0800
description: "哈希表是一种搜索结构，当数据量大时，哈希搜索的效率高，平均时间复杂度O(1)。【哈希查找】： （1）"
keywords: "线性探查法"
categories: ['数据结构']
tags: ['无标签']
artid: "79735508"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=79735508
    alt: "数据结构哈希表线性探测法"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【数据结构】哈希表（线性探测法）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      哈希表是一种搜索结构，当数据量大时，哈希搜索的效率高，平均时间复杂度O(1)。
     </strong>
    </p>
    <p>
     <font size="5">
      <strong>
       【哈希查找】：
      </strong>
     </font>
     <br/>
     （1）在插入时，根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。
     <br/>
     （2）在搜索时，对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。
     <br/>
     <font color="#FF0000">
      该方式即散列方法（Hash Method），在散列方法中使用的转换函数叫着散列函数（Hash function），构造出来的结构叫散列表（Hash Table）。用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。
     </font>
    </p>
    <p>
     <font size="5">
      【哈希冲突】：
     </font>
     <br/>
     对于两个数据元素的关键字Ki和Kj（i != j），有Ki != Kj ( i != j) ,但HashFun( Ki ) ==HashFun( Kj ) ,将该种现象称为哈希冲突或哈希碰撞。
    </p>
    <p>
     <font color="#FF0000">
      哈希表元素的插入:
     </font>
     <br/>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/51dea2b24636ada8324ed12027a98dba.jpeg" title=""/>
    </p>
    <p>
     <font size="5">
      <strong>
       【散列函数】：
      </strong>
     </font>
    </p>
    <p>
     常见的求哈希值的方法：
    </p>
    <p>
     <strong>
      1.直接定址法：
     </strong>
     <br/>
     取关键字的某个线性函数为散列地址：
     <strong>
      Hash（Key）= A*Key + B
     </strong>
     。
     <br/>
     优点：简单、均匀
     <br/>
     缺点：需要事先知道关键字的分布情况
     <br/>
     <font color="#FF0000">
      （适合查找比较小且连续的情况）
     </font>
    </p>
    <p>
     <strong>
      2.除留余数法：
     </strong>
     <br/>
     设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数，按照哈希函数：Hash( key ) = key % p ( p &lt;= m) ,将关键码转换成哈希地址。
    </p>
    <p>
     <strong>
      3.平方取中法
     </strong>
     <br/>
     <strong>
      4.折叠法
     </strong>
     <br/>
     <strong>
      5.随机数法
     </strong>
     <br/>
     <strong>
      6.数学分析法
     </strong>
    </p>
    <p>
     <font size="5">
      <strong>
       【散列冲突处理方法】：
      </strong>
     </font>
     <br/>
     <font color="#FF0000">
      <strong>
       闭散列法：
      </strong>
     </font>
     <br/>
     在元素插入时遇到哈希冲突，我们可选择
     <font color="#FF0000">
      线性探查法
     </font>
     处理冲突，还可以选择
     <font color="#FF0000">
      二次探查法
     </font>
     处理冲突。
     <br/>
     <strong>
      这里我们分析下线性探查法：
     </strong>
     <br/>
     给出一组元素，它们的关键码为：37，25，14，36，49，68，57，11，散列表为HT[12]，表的大小 m=12 ，假设采用Hash（key）= key % p ；（p=11）11是最接近m的质数，就有：
     <br/>
     <img alt="这里写图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/486567c1f8b9f8e64636f922de7ee40a.jpeg" title=""/>
    </p>
    <p>
     <font color="#FF0000">
      添加元素时，使用散列函数确定元素的插入位置，如果此空间有值：
     </font>
     <br/>
     1.该值是所要插入元素的关键码，不进行插入。
     <br/>
     2.产生冲突，依次查看其后的下一个桶，如果发现空位置插入新元素
    </p>
    <p>
     <font color="#FF0000">
      <strong>
       注意：
      </strong>
     </font>
     <br/>
     <strong>
      散列表的载荷因子：a = 插入元素个数 / 散列表的长度
     </strong>
    </p>
    <p>
     a是散列表装满程度的标志因子。对于开放地址法，载荷因子非常重要，应严格限制在 0.7~0.8 以下。超过 0.8 ，查表时的CPU缓存按照指数曲线上升。
    </p>
    <p>
     <font size="5">
      <strong>
       【代码实现】：
      </strong>
     </font>
     <br/>
     1.用vector开辟出一段空间来存放元素。
     <br/>
     2.每个节点都有三种状态
     <strong>
      EXIST(存在) 、DELETE(删除)、EMPTY(空)
     </strong>
     ，初始化时每个节点的状态设置为
     <strong>
      EMPTY
     </strong>
     。
    </p>
    <p>
     【Hash.h】
    </p>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;vector&gt;</span>
<span class="hljs-preprocessor">#include&lt;assert.h&gt;</span>
<span class="hljs-preprocessor">#include&lt;utility&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstring&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">//定义仿函数</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> K&gt;
<span class="hljs-keyword">struct</span> _HashFunc
{
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> K&amp; key)
    {
        <span class="hljs-keyword">return</span> key;
    }
};

<span class="hljs-comment">//特化string的版本</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> _HashFunc&lt;<span class="hljs-built_in">string</span>&gt;
{
    <span class="hljs-keyword">static</span> size_t BKDRHash(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)
    {
        size_t seed = <span class="hljs-number">131</span>;    <span class="hljs-comment">// 31 131 1313 13131 131313</span>
        size_t hash = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (*str)
        {
            hash = hash*seed + (*str++);
        }
        <span class="hljs-keyword">return</span> (hash &amp; <span class="hljs-number">0x7fffffff</span>);
    }
    size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; key)
    {
        <span class="hljs-keyword">return</span> BKDRHash(key.c_str());    <span class="hljs-comment">//c_str()返回的是一个const char*  类型的字符串</span>
    }
};

<span class="hljs-keyword">enum</span> Status
{
    EXIST,
    DELETE,
    EMPTY
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> K,<span class="hljs-keyword">class</span> V&gt;
<span class="hljs-keyword">struct</span> HashTableNode
{
    <span class="hljs-comment">//HashTableNode&lt;K,V&gt;* _pNode;</span>
    K _key;
    V _value;
    Status _status;
    HashTableNode(<span class="hljs-keyword">const</span> K&amp; key=K(),<span class="hljs-keyword">const</span> V&amp; value=V())
        :_key(key)
        , _value(value)
        , _status(EMPTY)
    { }

};

<span class="hljs-comment">//素数表，表内为哈希表的容量，素数降低哈希冲突</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> _PrimeSize = <span class="hljs-number">28</span>;                
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> _PrimeList[_PrimeSize] =
{
    <span class="hljs-number">53u</span>l, <span class="hljs-number">97u</span>l, <span class="hljs-number">193u</span>l, <span class="hljs-number">389u</span>l, <span class="hljs-number">769u</span>l,<span class="hljs-number">1543u</span>l, <span class="hljs-number">3079u</span>l, <span class="hljs-number">6151u</span>l,
    <span class="hljs-number">12289u</span>l, <span class="hljs-number">24593u</span>l,<span class="hljs-number">49157u</span>l, <span class="hljs-number">98317u</span>l, <span class="hljs-number">196613u</span>l, <span class="hljs-number">393241u</span>l,
    <span class="hljs-number">786433u</span>l,<span class="hljs-number">1572869u</span>l, <span class="hljs-number">3145739u</span>l, <span class="hljs-number">6291469u</span>l, <span class="hljs-number">12582917u</span>l,
    <span class="hljs-number">25165843u</span>l,<span class="hljs-number">50331653u</span>l, <span class="hljs-number">100663319u</span>l, <span class="hljs-number">201326611u</span>l, 
    <span class="hljs-number">402653189u</span>l,<span class="hljs-number">805306457u</span>l,<span class="hljs-number">1610612741u</span>l, <span class="hljs-number">3221225473u</span>l,
    <span class="hljs-number">4294967291u</span>l
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> K,<span class="hljs-keyword">class</span> V,<span class="hljs-keyword">class</span> HashFunc=_HashFunc&lt;K&gt;&gt;
<span class="hljs-keyword">class</span> HashTable
{
    <span class="hljs-keyword">typedef</span> HashTableNode&lt;K, V&gt; Node;
<span class="hljs-keyword">public</span>:
    HashTable()
    {}
    HashTable(size_t size)
    {
        assert(size &gt; <span class="hljs-number">0</span>);
        _v.resize(size);
        _size = <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">//将K值转换成哈希值</span>
    size_t _HashTableFunc(<span class="hljs-keyword">const</span> K&amp; key)
    {
        HashFunc hf;    <span class="hljs-comment">//定义一个HashFunc的变量hf</span>
        size_t hash = hf(key);  <span class="hljs-comment">//用变量hf调用HashFunc的仿函数，返回对应的整型</span>
        <span class="hljs-keyword">return</span> hash% _v.size(); <span class="hljs-comment">//算出哈希值，并返回</span>
    }

    pair&lt;Node*, <span class="hljs-keyword">bool</span>&gt; Insert(<span class="hljs-keyword">const</span> K&amp; key, <span class="hljs-keyword">const</span> V&amp; value)
    {
        <span class="hljs-comment">//检查是否需要扩容</span>
        CheckCapacity();

        <span class="hljs-comment">//对K值进行取余，判断插入位置</span>
        size_t index = _HashTableFunc(key);
        <span class="hljs-comment">//如果存在，则循环着继续找</span>
        <span class="hljs-keyword">while</span> (_v[index]._status !=EMPTY)
        {
            index++;
            <span class="hljs-keyword">if</span> (index == _v.size())
                index = <span class="hljs-number">0</span>;
        }
        _v[index]._key = key;
        _v[index]._value = value;
        _v[index]._status = EXIST;

        _size++;
        <span class="hljs-keyword">return</span> make_pair&lt;Node*, <span class="hljs-keyword">bool</span>&gt;(&amp;_v[index], <span class="hljs-keyword">true</span>);
    }

    Node* find(<span class="hljs-keyword">const</span> K&amp; key)        <span class="hljs-comment">//查找位置</span>
    {
        size_t index = _HashTableFunc(key);

        <span class="hljs-comment">//如果存在，则继续寻找</span>
        <span class="hljs-keyword">while</span> (_v[index]._status == EXIST)
        {
            <span class="hljs-comment">//若相等，判断状态是否是删除</span>
            <span class="hljs-comment">//若删除，则没找到，返回空</span>
            <span class="hljs-comment">//若没删除，则返回该位置的地址</span>
            <span class="hljs-keyword">if</span> (_v[index]._key == key)
            {
                <span class="hljs-keyword">if</span> (_v[index]._status == DELETE)
                    <span class="hljs-keyword">return</span> NULL;

                <span class="hljs-keyword">return</span> &amp;_v[index];
            }
            index++;
            <span class="hljs-keyword">if</span> (index == _size)
                index = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> NULL;
    }

    <span class="hljs-keyword">void</span> Delete(<span class="hljs-keyword">const</span> K&amp; key)
    {
        <span class="hljs-comment">//删除仅需要将状态修改</span>
        Node* delNode = find(key);

        <span class="hljs-keyword">if</span> (delNode)
            delNode-&gt;_status = DELETE;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">//交换两个哈希表</span>
    <span class="hljs-keyword">void</span> Swap(HashTable&lt;K, V&gt;&amp; h)
    {
        swap(_v, h._v);
        swap(_size, h._size);
    }

    <span class="hljs-keyword">void</span> CheckCapacity()
    {
        <span class="hljs-comment">//如果_v为空，则扩容到11</span>
        <span class="hljs-keyword">if</span> (_v.empty())
        {
            _v.resize(<span class="hljs-number">11</span>);
        }

        <span class="hljs-comment">//如果超过比例系数，则需要扩容</span>
        <span class="hljs-keyword">if</span> (_size * <span class="hljs-number">10</span> / _v.size() &gt;= <span class="hljs-number">7</span>)
        {
            size_t index = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (_PrimeList[index] &lt; _v.size())
            {
                index++;
            }
            size_t newSize = _PrimeList[index];
            HashTable&lt;K, V&gt; newh(newSize);    <span class="hljs-comment">//新近一个哈希表</span>
            <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; _v.size(); i++)  <span class="hljs-comment">//将旧的哈希表中的元素重新插入到新的哈希表</span>
            {
                <span class="hljs-keyword">if</span> (_v[i]._status==EXIST)
                newh.Insert(_v[i]._key, _v[i]._value);
            }
            <span class="hljs-comment">//交换两个哈希表</span>
            Swap(newh);
        }
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Node&gt;</span> _v;
    size_t _size;

};</code></pre>
    <p>
     【测试存入整型数据】
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">void</span> test()
{
    <span class="hljs-keyword">int</span> arr[] = { <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>, <span class="hljs-number">13</span>, <span class="hljs-number">43</span> };
    <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);
    HashTable&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; h1(<span class="hljs-number">11</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)
    {
        h1.Insert(arr[i], arr[i]+ <span class="hljs-number">3</span>);
    }
}</code></pre>
    <p>
     【测试以字符串为关键码存入】
    </p>
    <pre class="prettyprint"><code class="hljs avrasm">void test2()
{
    HashTable&lt;string, string&gt; h2(<span class="hljs-number">11</span>)<span class="hljs-comment">;</span>
    h2<span class="hljs-preprocessor">.Insert</span>(<span class="hljs-string">"abs"</span>, <span class="hljs-string">"1111"</span>)<span class="hljs-comment">;</span>
    h2<span class="hljs-preprocessor">.Insert</span>(<span class="hljs-string">"222"</span>,<span class="hljs-string">"2222"</span>)<span class="hljs-comment">;</span>
    h2<span class="hljs-preprocessor">.Insert</span>(<span class="hljs-string">"223"</span>, <span class="hljs-string">"2223"</span>)<span class="hljs-comment">;</span>
    h2<span class="hljs-preprocessor">.Insert</span>(<span class="hljs-string">"224"</span>, <span class="hljs-string">"2224"</span>)<span class="hljs-comment">;</span>
    h2<span class="hljs-preprocessor">.Insert</span>(<span class="hljs-string">"225"</span>, <span class="hljs-string">"2225"</span>)<span class="hljs-comment">;</span>
}</code></pre>
    <p>
     【test.cpp】
    </p>
    <pre class="prettyprint"><code class="hljs vala"><span class="hljs-preprocessor">#include"Hash.h"</span>
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-comment">//test();</span>
    test2();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6c7a323031373838:2f61727469636c652f64657461696c732f3739373335353038" class_="artid" style="display:none">
 </p>
</div>


