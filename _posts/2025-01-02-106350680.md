---
layout: post
title: 2025-01-02-最全数据库原理及应用知识点整理习题
date: 2025-01-02 12:29:57 +0800
categories: ['未分类']
tags: ['无标签']
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=106350680
  alt: 最全数据库原理及应用知识点整理习题
artid: 106350680
render_with_liquid: false
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【最全】《数据库原理及应用》知识点整理+习题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <div class="article_content clearfix" id="article_content">
     <div class="htmledit_views" id="content_views">
      <p id="main-toc">
       <strong>
        目录
       </strong>
      </p>
     </div>
    </div>
    <p id="%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA-toc">
     <a href="#%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA" rel="nofollow noopener noreferrer" target="_self">
      第1章 绪论
     </a>
    </p>
    <p id="1.1%E6%9C%AF%E8%AF%AD-toc">
     <a href="#1.1%E6%9C%AF%E8%AF%AD" rel="nofollow noopener noreferrer" target="_self">
      1.1术语
     </a>
    </p>
    <p id="1.2%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-toc">
     <a href="#1.2%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5" rel="nofollow noopener noreferrer" target="_self">
      1.2重要概念
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%89-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%89" rel="nofollow noopener noreferrer" target="_self">
      数据库管理技术的发展过程（三个阶段）
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%88Data%20Model%EF%BC%89-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%88Data%20Model%EF%BC%89" rel="nofollow noopener noreferrer" target="_self">
      数据模型（Data Model）
     </a>
    </p>
    <p id="%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%88%E9%9D%9E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%EF%BC%89-toc">
     <a href="#%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%88%E9%9D%9E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%EF%BC%89" rel="nofollow noopener noreferrer" target="_self">
      逻辑模型的分类（非关系模型与关系模型）
     </a>
    </p>
    <p id="%E7%94%BBE-R%E5%9B%BE-toc">
     <a href="#%E7%94%BBE-R%E5%9B%BE" rel="nofollow noopener noreferrer" target="_self">
      画E-R图
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84" rel="nofollow noopener noreferrer" target="_self">
      数据库系统结构
     </a>
    </p>
    <p id="%E7%AC%AC2%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93-toc">
     <a href="#%E7%AC%AC2%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow noopener noreferrer" target="_self">
      第2章 关系数据库
     </a>
    </p>
    <p id="2.1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89-toc">
     <a href="#2.1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89" rel="nofollow noopener noreferrer" target="_self">
      2.1关系数据结构及形式化定义
     </a>
    </p>
    <p id="2.2%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C-toc">
     <a href="#2.2%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C" rel="nofollow noopener noreferrer" target="_self">
      2.2关系操作
     </a>
    </p>
    <p id="2.3%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7-toc">
     <a href="#2.3%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      2.3关系的完整性
     </a>
    </p>
    <p id="2.4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0-toc">
     <a href="#2.4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0" rel="nofollow noopener noreferrer" target="_self">
      2.4关系代数
     </a>
    </p>
    <p id="%E9%80%89%E6%8B%A9-toc">
     <a href="#%E9%80%89%E6%8B%A9" rel="nofollow noopener noreferrer" target="_self">
      选择
     </a>
    </p>
    <p id="%E6%8A%95%E5%BD%B1-toc">
     <a href="#%E6%8A%95%E5%BD%B1" rel="nofollow noopener noreferrer" target="_self">
      投影
     </a>
    </p>
    <p id="%E8%BF%9E%E6%8E%A5-toc">
     <a href="#%E8%BF%9E%E6%8E%A5" rel="nofollow noopener noreferrer" target="_self">
      连接
     </a>
    </p>
    <p id="%E9%99%A4-toc">
     <a href="#%E9%99%A4" rel="nofollow noopener noreferrer" target="_self">
      除
     </a>
    </p>
    <p id="%E7%AC%AC3%E7%AB%A0%20SQL-toc">
     <a href="#%E7%AC%AC3%E7%AB%A0%20SQL" rel="nofollow noopener noreferrer" target="_self">
      第3章 SQL
     </a>
    </p>
    <p id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc">
     <a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow noopener noreferrer" target="_self">
      基本概念
     </a>
    </p>
    <p id="%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E5%8F%8A%E8%A7%A3%E9%87%8A-toc">
     <a href="#%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E5%8F%8A%E8%A7%A3%E9%87%8A" rel="nofollow noopener noreferrer" target="_self">
      专有名词及解释
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89" rel="nofollow noopener noreferrer" target="_self">
      数据定义
     </a>
    </p>
    <p id="1.%E5%88%9B%E5%BB%BA%2F%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93-toc">
     <a href="#1.%E5%88%9B%E5%BB%BA%2F%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow noopener noreferrer" target="_self">
      1.创建/删除数据库
     </a>
    </p>
    <p id="2.%E5%88%9B%E5%BB%BA%2F%E5%88%A0%E9%99%A4%2F%E4%BF%AE%E6%94%B9%E5%9F%BA%E6%9C%AC%E8%A1%A8-toc">
     <a href="#2.%E5%88%9B%E5%BB%BA%2F%E5%88%A0%E9%99%A4%2F%E4%BF%AE%E6%94%B9%E5%9F%BA%E6%9C%AC%E8%A1%A8" rel="nofollow noopener noreferrer" target="_self">
      2.创建/删除/修改基本表
     </a>
    </p>
    <p id="3.%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE-toc">
     <a href="#3.%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE" rel="nofollow noopener noreferrer" target="_self">
      3.主键和外键
     </a>
    </p>
    <p id="4.%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95-toc">
     <a href="#4.%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95" rel="nofollow noopener noreferrer" target="_self">
      4.建立索引
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2" rel="nofollow noopener noreferrer" target="_self">
      数据查询
     </a>
    </p>
    <p id="%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2-toc">
     <a href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2" rel="nofollow noopener noreferrer" target="_self">
      单表查询
     </a>
    </p>
    <p id="%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-toc">
     <a href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2" rel="nofollow noopener noreferrer" target="_self">
      连接查询
     </a>
    </p>
    <p id="%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2-toc">
     <a href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2" rel="nofollow noopener noreferrer" target="_self">
      嵌套查询
     </a>
    </p>
    <p id="%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2-toc">
     <a href="#%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2" rel="nofollow noopener noreferrer" target="_self">
      集合查询
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0" rel="nofollow noopener noreferrer" target="_self">
      数据更新
     </a>
    </p>
    <p id="%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc">
     <a href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow noopener noreferrer" target="_self">
      插入数据
     </a>
    </p>
    <p id="%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE-toc">
     <a href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE" rel="nofollow noopener noreferrer" target="_self">
      修改数据
     </a>
    </p>
    <p id="%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-toc">
     <a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE" rel="nofollow noopener noreferrer" target="_self">
      删除数据
     </a>
    </p>
    <p id="%E8%A7%86%E5%9B%BE-toc">
     <a href="#%E8%A7%86%E5%9B%BE" rel="nofollow noopener noreferrer" target="_self">
      视图
     </a>
    </p>
    <p id="%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7-toc">
     <a href="#%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      第4章 数据库安全性
     </a>
    </p>
    <p>
     <a href="#%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E5%8F%8A%E8%A7%A3%E9%87%8A" rel="nofollow noopener noreferrer" target="_self">
      专有名词及解释
     </a>
    </p>
    <p id="%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86%E4%B8%8E%E9%89%B4%E5%88%AB%EF%BC%88Identification%20%26%20Authentication%EF%BC%89-toc">
     <a href="#%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86%E4%B8%8E%E9%89%B4%E5%88%AB%EF%BC%88Identification%20%26%20Authentication%EF%BC%89" rel="nofollow noopener noreferrer" target="_self">
      用户标识与鉴别（Identification &amp; Authentication）
     </a>
    </p>
    <p id="%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6-toc">
     <a href="#%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6" rel="nofollow noopener noreferrer" target="_self">
      存取控制
     </a>
    </p>
    <p id="%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6-toc">
     <a href="#%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6" rel="nofollow noopener noreferrer" target="_self">
      自主存取控制
     </a>
    </p>
    <p id="%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6-toc">
     <a href="#%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6" rel="nofollow noopener noreferrer" target="_self">
      强制存取控制
     </a>
    </p>
    <p id="%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7-toc">
     <a href="#%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      第5章 数据库完整性
     </a>
    </p>
    <p id="%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7-toc">
     <a href="#%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      实体完整性
     </a>
    </p>
    <p id="%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7-toc">
     <a href="#%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      参照完整性
     </a>
    </p>
    <p id="%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7-toc">
     <a href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      用户自定义完整性
     </a>
    </p>
    <p id="%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88Trigger%EF%BC%89-toc">
     <a href="#%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88Trigger%EF%BC%89" rel="nofollow noopener noreferrer" target="_self">
      触发器（Trigger）
     </a>
    </p>
    <p id="%E7%AC%AC6%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA-toc">
     <a href="#%E7%AC%AC6%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA" rel="nofollow noopener noreferrer" target="_self">
      第6章 关系数据库理论
     </a>
    </p>
    <p id="%E8%A7%84%E8%8C%83%E5%8C%96-toc">
     <a href="#%E8%A7%84%E8%8C%83%E5%8C%96" rel="nofollow noopener noreferrer" target="_self">
      规范化
     </a>
    </p>
    <p id="1NF%EF%BC%9A-toc">
     <a href="#1NF%EF%BC%9A" rel="nofollow noopener noreferrer" target="_self">
      1NF：
     </a>
    </p>
    <p id="2NF%EF%BC%9A-toc">
     <a href="#2NF%EF%BC%9A" rel="nofollow noopener noreferrer" target="_self">
      2NF：
     </a>
    </p>
    <p id="3NF%EF%BC%9A-toc">
     <a href="#3NF%EF%BC%9A" rel="nofollow noopener noreferrer" target="_self">
      3NF：
     </a>
    </p>
    <p id="BCNF-toc">
     <a href="#BCNF" rel="nofollow noopener noreferrer" target="_self">
      BCNF
     </a>
    </p>
    <p id="%E5%B0%8F%E7%BB%93-toc">
     <a href="#%E5%B0%8F%E7%BB%93" rel="nofollow noopener noreferrer" target="_self">
      小结
     </a>
    </p>
    <p id="%E7%AC%AC7%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-toc">
     <a href="#%E7%AC%AC7%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1" rel="nofollow noopener noreferrer" target="_self">
      第7章 数据库设计
     </a>
    </p>
    <p id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-toc">
     <a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" rel="nofollow noopener noreferrer" target="_self">
      需求分析
     </a>
    </p>
    <p id="%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-toc">
     <a href="#%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1" rel="nofollow noopener noreferrer" target="_self">
      概念结构设计
     </a>
    </p>
    <p id="%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-toc">
     <a href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1" rel="nofollow noopener noreferrer" target="_self">
      逻辑结构设计
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BB%B4%E6%8A%A4-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BB%B4%E6%8A%A4" rel="nofollow noopener noreferrer" target="_self">
      数据库的运行与维护
     </a>
    </p>
    <p id="%E7%AC%AC9%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-toc">
     <a href="#%E7%AC%AC9%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96" rel="nofollow noopener noreferrer" target="_self">
      第9章 关系查询处理和查询优化
     </a>
    </p>
    <p id="%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4-toc">
     <a href="#%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4" rel="nofollow noopener noreferrer" target="_self">
      查询处理步骤
     </a>
    </p>
    <p id="%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-toc">
     <a href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" rel="nofollow noopener noreferrer" target="_self">
      查询优化策略
     </a>
    </p>
    <p id="%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96-toc">
     <a href="#%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96" rel="nofollow noopener noreferrer" target="_self">
      代数优化
     </a>
    </p>
    <p id="%E7%90%86%E4%BC%98%E5%8C%96-toc">
     <a href="#%E7%90%86%E4%BC%98%E5%8C%96" rel="nofollow noopener noreferrer" target="_self">
      理优化
     </a>
    </p>
    <p id="%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF-toc">
     <a href="#%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF" rel="nofollow noopener noreferrer" target="_self">
      第10章 数据库恢复技术
     </a>
    </p>
    <p id="%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc">
     <a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow noopener noreferrer" target="_self">
      事务的基本概念
     </a>
    </p>
    <p id="%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB-toc">
     <a href="#%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB" rel="nofollow noopener noreferrer" target="_self">
      故障的种类
     </a>
    </p>
    <p id="%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%AD%96%E7%95%A5-toc">
     <a href="#%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%AD%96%E7%95%A5" rel="nofollow noopener noreferrer" target="_self">
      恢复的实现技术及策略
     </a>
    </p>
    <p id="%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8-toc">
     <a href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8" rel="nofollow noopener noreferrer" target="_self">
      数据转储
     </a>
    </p>
    <p id="%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88Logging%EF%BC%89-toc">
     <a href="#%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88Logging%EF%BC%89" rel="nofollow noopener noreferrer" target="_self">
      登记日志文件（Logging）
     </a>
    </p>
    <p id="%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5-toc">
     <a href="#%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5" rel="nofollow noopener noreferrer" target="_self">
      恢复策略
     </a>
    </p>
    <p id="%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF-toc">
     <a href="#%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF" rel="nofollow noopener noreferrer" target="_self">
      具有检查点的恢复技术
     </a>
    </p>
    <p id="%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0-toc">
     <a href="#%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0" rel="nofollow noopener noreferrer" target="_self">
      第11章 并发控制概述
     </a>
    </p>
    <p id="%E5%B0%81%E9%94%81-toc">
     <a href="#%E5%B0%81%E9%94%81" rel="nofollow noopener noreferrer" target="_self">
      封锁
     </a>
    </p>
    <p id="%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81-toc">
     <a href="#%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81" rel="nofollow noopener noreferrer" target="_self">
      活锁和死锁
     </a>
    </p>
    <p id="%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7-toc">
     <a href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7" rel="nofollow noopener noreferrer" target="_self">
      并发调度的可串行性
     </a>
    </p>
    <p id="%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE-toc">
     <a href="#%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE" rel="nofollow noopener noreferrer" target="_self">
      两段锁协议
     </a>
    </p>
    <p id="%E4%B9%A0%E9%A2%98-toc">
     <a href="#%E4%B9%A0%E9%A2%98" rel="nofollow noopener noreferrer" target="_self">
      习题
     </a>
    </p>
    <p id="%E9%80%89%E6%8B%A9%E9%A2%98-toc">
     <a href="#%E9%80%89%E6%8B%A9%E9%A2%98" rel="nofollow noopener noreferrer" target="_self">
      选择题
     </a>
    </p>
    <p id="%E7%AE%80%E7%AD%94%E9%A2%98-toc">
     <a href="#%E7%AE%80%E7%AD%94%E9%A2%98" rel="nofollow noopener noreferrer" target="_self">
      简答题
     </a>
    </p>
    <p id="%E5%BA%94%E7%94%A8%E9%A2%98-toc">
     <a href="#%E5%BA%94%E7%94%A8%E9%A2%98" rel="nofollow noopener noreferrer" target="_self">
      应用题
     </a>
    </p>
    <hr id="hr-toc"/>
    <h2 id="%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA">
     第1章 绪论
    </h2>
    <h3 id="1.1%E6%9C%AF%E8%AF%AD">
     1.1术语
    </h3>
    <p>
     1.数据（Data）
    </p>
    <p>
     数据是数据库中存储的基本对象。定义为描述事务的符号记录。数据的含义称为语义，数据与其语义是不可分的。
    </p>
    <p>
     2.数据库（DataBase，DB）
    </p>
    <p>
     长期存储在计算机内，有组织的，可共享的大量数据的集合。
    </p>
    <p>
     数据库基本特征：1.永久存储  2.有组织  3.可共享 4.冗余度小 5.易扩展
    </p>
    <p>
     3.数据库管理系统（DataBase Management System,DBMS）
    </p>
    <p>
     位于用户与操作系统之间的一层数据管理软件
    </p>
    <p>
     数据库管理系统和操作系统一样是计算机的基础软件。
    </p>
    <p>
     主要功能：提供数据定义语言（DDL）、数据操纵语言（DML）等
    </p>
    <p>
     4.数据库系统（DataBase System,DBS）
    </p>
    <p>
     数据库系统由数据库（DB），数据库管理系统(DBMS)，应用程序和数据库管理员(DBA)组成的存储、管理、处理和维护数据的系统。
    </p>
    <h3 id="1.2%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5">
     1.2重要概念
    </h3>
    <h4 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%89">
     数据库管理技术的发展过程（三个阶段）
    </h4>
    <p>
     <strong>
      1.人工管理阶段：
     </strong>
    </p>
    <p>
     在计算机出现之前，人们运用常规的手段从事记录、存储和对数据加工，也就是利用纸张来记录和利用计算工具（算盘、计算尺）来进行计算，并主要使用人的大脑来
    </p>
    <p>
     管理和利用这些数据。
    </p>
    <p>
     特点:
    </p>
    <p>
     (1)计算机系统不提供对用户数据的管理功能；
    </p>
    <p>
     (2)数据不能共享；
    </p>
    <p>
     (3)不保存数据。
    </p>
    <p>
     <strong>
      2.文件系统阶段：
     </strong>
    </p>
    <p>
     在这一阶段（20世纪50年代后期至60年代中期）计算机不仅用于科学计算，还利用在信息管理方面。随着数据量的增加，数据的存储、检索和维护问题成为紧迫的需要，数据结构和数据管理技术迅速发展起来。此时，外部存储器已有磁盘、磁鼓等直接存取的存储设备。软件领域出现了操作系统和高级软件。操作系统中的文件系统是专门管理外存的数据管理软件，文件是操作系统管理的重要资源之一。
    </p>
    <p>
     特点:
    </p>
    <p>
     数据以“文件”形式可长期保存在外部存储器的磁盘上。由于计算机的应用转向信息管理，因此对文件要进行大量的查询、修改和插入等操作，这些操作由文件系统提供。
    </p>
    <p>
     缺点:
    </p>
    <p>
     数据冗余;不一致性;数据独立性差。
    </p>
    <p>
     <strong>
      3.数据库系统阶段：
     </strong>
    </p>
    <p>
     20世纪60年代后期以来 ，计算机性能得到进一步提高，更重要的是出现了大容量磁盘，存储容量大大增加且价格下降。在此基础上，才有可能克服文件 系统管理数据时的不足，而满足和解决实际应用中多个用户、多个 应用程序共享数据的要求，从而使数据能为尽可能多的 应用程序服务，这就出现了数据库这样的数据管理技术。
    </p>
    <p>
     特点:
    </p>
    <p>
     （1）数据结构化。
    </p>
    <p>
     （2）数据共享性高、冗余少且易扩充。
    </p>
    <p>
     （3）数据独立性高。
    </p>
    <p>
     （4）数据由DBMS统一管理和控制。
    </p>
    <p>
    </p>
    <h4 id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%88Data%20Model%EF%BC%89">
     数据模型（Data Model）
    </h4>
    <p>
     一、数据模型的分类
    </p>
    <p>
     1.概念模型
    </p>
    <p>
     按用户的观点来对数据和信息建模，主要用于数据库设计
    </p>
    <p>
     概念模型的表示方法很多，最常用的为实体-联系方法(Entity-Relationship approach），该方法用E-R图来描述概念模型。E-R方法也成为E-R模型
    </p>
    <p>
     2.逻辑模型和物理模型
    </p>
    <p>
     逻辑模型主要包括层次模型、网状模型、关系模型、面向对象模型和对象关系数据模型等，主要用于数据库管理系统的实现。
    </p>
    <p>
     物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。
    </p>
    <p>
     <img alt="" class="has" height="228" src="https://i-blog.csdnimg.cn/blog_migrate/2efdfe4d6e621d7b2359ca14f023bd49.png" width="375"/>
    </p>
    <p>
     二、数据模型的组成要素
    </p>
    <p>
     数据模型通常由数据结构、数据操作和完整性约束三个部分组成。
    </p>
    <p>
     <strong>
      数据结构
     </strong>
     描述数据库的组成对象以及对象之间的联系，通常按其数据结构的类型来命名数据模型，例如层次结构、网状结构和关系结构的数据模型分别命名为层次模型、网状模型、关系模型。
    </p>
    <p>
     <strong>
      数据操作
     </strong>
     是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及其有关的规则，主要分为查询和更新（插入、删除、修改）两大类操作。
    </p>
    <p>
     <strong>
      完整性约束条件
     </strong>
     是给定的数据模型中数据及其联系所具有的制约和依存规则，在关系模型中体现为实体完整性和参照完整性。例如，某大学的数据库中规定学生成绩如果有6门以上不及格则不能授予学士学位，教授的退休年龄是65周岁等。
    </p>
    <h4 id="%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%88%E9%9D%9E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%EF%BC%89">
     逻辑模型的分类（非关系模型与关系模型）
    </h4>
    <p>
     非关系模型：层次模型(Hierarchical Model)、网状模型(Network Model)
    </p>
    <p>
     关系模型(Relational Model)
    </p>
    <p>
     层次模型，满足下面两个条件的基本层次联系的集合为层次模型（就是树结构）：
    </p>
    <p>
     ①有且只有一个结点没有双亲结点，这个结点称为根结点
    </p>
    <p>
     ②根以外的其它结点有且只有一个双亲结点
    </p>
    <p>
     网状模型，满足下面两个条件的基本层次联系的集合（一对多关系，结构上像有向图）：
    </p>
    <p>
     ①允许一个以上的结点无双亲；
    </p>
    <p>
     ②一个结点可以有多于一个的双亲。
    </p>
    <p>
    </p>
    <p>
     关系模型术语：
    </p>
    <p>
     1.关系：一个关系对应通常说的一张表。
    </p>
    <p>
     2.属性：表中的一列即为一个属性。
    </p>
    <p>
     3.域：属性的取值范围。
    </p>
    <p>
     4.元组：表中的一行即为一个元组。
    </p>
    <p>
     5.码：也称码键。表中的某个属性组，它可以唯一确定一个元组。
    </p>
    <p>
     6.分量：元组中的一个属性值。
    </p>
    <p>
     7.关系模式：对关系的描述，一般表示为 关系名（属性1，属性2，.....，属性n）
    </p>
    <h4 id="%E7%94%BBE-R%E5%9B%BE">
     画E-R图
    </h4>
    <p>
     实体-联系方法（Entity-Relationship Approach）是概念模型的一种表示方法，其提供了表示实体型、属性和联系的方法。
    </p>
    <p>
     <img alt="" class="has" height="228" src="https://i-blog.csdnimg.cn/blog_migrate/d4f94c0d984b51eb807f02359ba3e899.png" width="375"/>
    </p>
    <p>
     实体型：用矩形表示，矩形框内写明实体名
    </p>
    <p>
     属性：用椭圆表示，并用无向边将其与相应的实体型连接起来
    </p>
    <p>
     联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时标明联系的类型（1:1， 1：n， m：n）
    </p>
    <p>
     比如有两个简单实体，分别是单位和职员，它们的关系就是1:m，一个单位可以有多个职员；
    </p>
    <p>
     再比如有两个实体，分别是学生和图书，它们的关系就是m:n，从而形成中间表学生借阅的图书，结果是1本图书可以被多人借阅，1个人也可以借多本图书。
    </p>
    <h4 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">
     数据库系统结构
    </h4>
    <p>
     数据库系统的三级模式结构：模式（Schema）、外模式（External Schema）、内模式（Internal Schema）
    </p>
    <p>
     <img alt="" class="has" height="271" src="https://i-blog.csdnimg.cn/blog_migrate/1507580db4267cb3a4dd18f5ba1883f9.png" width="409"/>
    </p>
    <p>
     <strong>
      模式（也称逻辑模式）：
     </strong>
    </p>
    <p>
     ①数据库中全体数据的逻辑结构和特征的描述
    </p>
    <p>
     ②所有用户的公共数据视图，综合了所有用户的需求
    </p>
    <p>
     模式的地位：是数据库系统模式结构的中间层
    </p>
    <p>
     ①与数据的物理存储细节和硬件环境无关
    </p>
    <p>
     ②与具体的应用程序、开发工具及高级程序设计语言无关
    </p>
    <p>
     <strong>
      外模式（也称子模式或用户模式）：
     </strong>
    </p>
    <p>
     ①数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述
    </p>
    <p>
     ②数据库用户的数据视图，是与某一应用有关的数据的逻辑表示
    </p>
    <p>
     外模式的用途：①保证数据库安全性的一个有力措施 ②每个用户只能看见和访问所对应的外模式中的数据
    </p>
    <p>
     <strong>
      内模式（也称存储模式）：
     </strong>
    </p>
    <p>
     ①是数据物理结构和存储方式的描述
    </p>
    <p>
     ②是数据在数据库内部的表示方式：
    </p>
    <p>
     a. 记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）
    </p>
    <p>
     b. 索引的组织方式
    </p>
    <p>
     c. 数据是否压缩存储
    </p>
    <p>
     d. 数据是否加密
    </p>
    <p>
     e. 数据存储记录结构的规定
    </p>
    <p>
    </p>
    <h2 id="%E7%AC%AC2%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">
     第2章 关系数据库
    </h2>
    <p>
     由之前的内容直到，关系模型是由关系数据结构、关系操作集合、关系完整性约束三部分组成的，所以要了解对于关系模型这三部分的含义
    </p>
    <h3 id="2.1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89">
     2.1关系数据结构及形式化定义
    </h3>
    <p>
     关系模型是建立在集合代数的基础上的，因此从集合论角度给出关系数据结构的形式化定义。
    </p>
    <p>
     <strong>
      1.域（Domain）
     </strong>
     ：域是一组具有相同数据类型的值的集合，例如整数、自然数都是域
    </p>
    <p>
     <strong>
      2.笛卡尔积（Cartesian Product）
     </strong>
     ：笛卡尔积是域上面的一种集合运算。
    </p>
    <p>
     给定一组域D1，D2，…，Dn，允许其中某些域是相同的。 D1，D2，…，Dn的笛卡尔积为：
    </p>
    <p>
     <img alt="" class="has" height="34" src="https://i-blog.csdnimg.cn/blog_migrate/94eda05120c366459bc6a4f2f5a51990.png" width="443"/>
    </p>
    <p>
     笛卡尔积中每个元素(d1,d2,…dn)称为一个n元组或简称
     <strong>
      元组
     </strong>
    </p>
    <p>
     笛卡尔积可表示为一个二维表，
     <strong>
      表中每行对应一个元组，表中每一列的值来自一个域
     </strong>
    </p>
    <p>
     例如，给出3个域：
    </p>
    <p>
     D1=导师集合SUPERVISOR=｛张清玫，刘逸｝
    </p>
    <p>
     D2=专业集合SPECIALITY=｛计算机专业，信息专业｝
    </p>
    <p>
     D3=研究生集合POSTGRADUATE=｛李勇，刘晨，王敏｝
    </p>
    <p>
     D1，D2，D3的笛卡尔积为
    </p>
    <p>
     <img alt="" class="has" height="318" src="https://i-blog.csdnimg.cn/blog_migrate/9110222dd9ea1d03bc4b5dd83557b990.png" width="403"/>
    </p>
    <p>
     <strong>
      3.关系（Relation）
     </strong>
    </p>
    <p>
     D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，
    </p>
    <p>
     表示为R（D1，D2，…，Dn）
    </p>
    <p>
     R：关系名
    </p>
    <p>
     n：关系的目或度（Degree）
    </p>
    <p>
     关系也是一个二维表，每行对应一个元组，每列对应一个域，每列称为属性
    </p>
    <p>
     若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为
     <strong>
      候选码（Candidate key）
     </strong>
    </p>
    <p>
     若一个关系有多个候选码，则选定其中一个或多个为
     <strong>
      主码（Primary key）
     </strong>
    </p>
    <p>
     候选码的多个属性称为
     <strong>
      主属性（Prime attribute）
     </strong>
     ，不包含在任何候选码中的属性称为
     <strong>
      非主属性
     </strong>
     ；最简单的情况下，候选码只包含一个属性，如果关系模式的所有属性都是这个关系的候选码，则称为
     <strong>
      全码（All-key）
     </strong>
    </p>
    <h3 id="2.2%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C">
     2.2关系操作
    </h3>
    <p>
     关系模型中常用的关系操作包括查询（Query）操作和插入（Insert）、删除（Delete）、修改（Update）操作这两大部分。
    </p>
    <p>
     查询操作又分为：选择（Select）、投影（Project）、连接（Join）、除（Divide）、并（Union）、差（Except）、交（Intersection）、笛卡尔积等；其中：
     <strong>
      选择、投影、并、差、笛卡尔积
     </strong>
     是5种基本操作，其他操作是可以用基本操作来定义和导出的。
    </p>
    <h3 id="2.3%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">
     2.3关系的完整性
    </h3>
    <p>
     关系模型的完整性规则是对关系的某种约束条件，关系模型中有三类完整性约束：
    </p>
    <p>
     实体完整性（Entity Integrity）：关系模型以主码作为唯一性标识，主码中的属性即主属性不能取空值
    </p>
    <p>
     参照完整性（Referential Integrity）：外码
    </p>
    <p>
     用户自定义完整性（User-defined Integrity）：反映某一具体应用所涉及的数据必须满足的语义要求
    </p>
    <h3 id="2.4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0">
     2.4关系代数
    </h3>
    <p>
     并、差、投影、笛卡尔积、选择为五个基本操作，交、连接、除等为附加操作，附加操作可以用五个基本操作表示
    </p>
    <h4 id="%E9%80%89%E6%8B%A9">
     选择
    </h4>
    <p>
     选择运算是从关系R中选取使逻辑表达式F为真的元组，是从行的角度进行的运算
    </p>
    <p>
     <img alt="" class="has" height="72" src="https://i-blog.csdnimg.cn/blog_migrate/39aad975fdff1f6e1c1aa5d100da363b.png" width="235"/>
    </p>
    <p>
     如查询信息系（IS系）全体学生
     <img alt="" class="has" height="23" src="https://i-blog.csdnimg.cn/blog_migrate/e7d5edbe5b6b03e94a95d68cbfe9d363.png" width="154"/>
    </p>
    <h4 id="%E6%8A%95%E5%BD%B1">
     投影
    </h4>
    <p>
     投影操作主要是从列的角度进行运算，但投影成功之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）
    </p>
    <p>
     <img alt="" class="has" height="90" src="https://i-blog.csdnimg.cn/blog_migrate/bee66b8dec5041cf60a2e6bdae6cea66.png" width="161"/>
    </p>
    <p>
     如查询学生的姓名和所在系
     <img alt="" class="has" height="23" src="https://i-blog.csdnimg.cn/blog_migrate/3fabdddcd18da619fa9d2c5f51dfa02a.png" width="175"/>
    </p>
    <h4 id="%E8%BF%9E%E6%8E%A5">
     连接
    </h4>
    <p>
     连接运算的含义：
     <strong>
      从两个关系的笛卡尔积中选取属性间满足一定条件的元组
     </strong>
    </p>
    <p>
     等值连接：θ为’=’的连接运算称为等值连接，即选取属性相等的元组
    </p>
    <p>
     自然连接：特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组，在结果中要把重复的属性列去掉
    </p>
    <p>
     一般的连接操作是从行的角度进行运算的，自然连接还需要取消重复列，所以是同时从行和列的角度进行运算
    </p>
    <p>
     <img alt="" class="has" height="123" src="https://i-blog.csdnimg.cn/blog_migrate/1215566e197cd62a76423e360c38c8f4.png" width="294"/>
    </p>
    <p>
     例如：
    </p>
    <p>
     <img alt="" class="has" height="291" src="https://i-blog.csdnimg.cn/blog_migrate/332fc0207ee8c22a716c3b38807fee71.png" width="372"/>
    </p>
    <p>
     可以先得到两个关系的笛卡尔积，然后筛选出C &lt; E的
    </p>
    <p>
     <img alt="" class="has" height="301" src="https://i-blog.csdnimg.cn/blog_migrate/a7b5bed422101b8dd47882a612ea2b20.png" width="439"/>
    </p>
    <p>
     <img alt="" class="has" height="305" src="https://i-blog.csdnimg.cn/blog_migrate/13fe44962e9447007a6c406c8bba7229.png" width="437"/>
    </p>
    <p>
     自然连接是特殊的等值连接，相同的属性组进行比较，并去除重复的属性列。即笛卡尔积里找出B相等的然后合并R.B和S.B为B
    </p>
    <p>
     <strong>
      悬浮元组与外连接
     </strong>
    </p>
    <p>
     两个关系R和S在做
     <strong>
      自然连接
     </strong>
     时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为
     <strong>
      悬浮元组
     </strong>
     。
    </p>
    <p>
     外连接（OUTER JOIN）
    </p>
    <p>
     如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接
    </p>
    <p>
     左外连接(LEFT OUTER JOIN或LEFT JOIN)：只保留左边关系R中的悬浮元组
    </p>
    <p>
     右外连接(RIGHT OUTER JOIN或RIGHT JOIN)：只保留右边关系S中的悬浮元组
    </p>
    <p>
     <img alt="" class="has" height="165" src="https://i-blog.csdnimg.cn/blog_migrate/7aecdecb915746fd98818eea21a8c5c7.png" width="380"/>
    </p>
    <p>
     <img alt="" class="has" height="206" src="https://i-blog.csdnimg.cn/blog_migrate/0511c63331d8ab55a871a147cfd3c585.png" width="398"/>
    </p>
    <h4 id="%E9%99%A4">
     除
    </h4>
    <p>
     除操作是同时从行和列的角度进行运算的
    </p>
    <p>
     <img alt="" class="has" height="140" src="https://i-blog.csdnimg.cn/blog_migrate/eb414204cd4fe86b7786e334d17cd114.png" width="243"/>
    </p>
    <p>
     <img alt="" class="has" height="257" src="https://i-blog.csdnimg.cn/blog_migrate/7776ea88bbcc843517be3d840d9601a1.png" width="447"/>
    </p>
    <p>
     <img alt="" class="has" height="311" src="https://i-blog.csdnimg.cn/blog_migrate/8053271d17c7af8ed1ac86458ad90d5e.png" width="467"/>
    </p>
    <h2 id="%E7%AC%AC3%E7%AB%A0%20SQL">
     第3章 SQL
    </h2>
    <h3 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">
     基本概念
    </h3>
    <p>
     <img alt="" class="has" height="249" src="https://i-blog.csdnimg.cn/blog_migrate/9601c00444ceb67f7f8228dbd09a5466.png" width="484"/>
    </p>
    <p>
     在SQL中一个关系就对应一个基本表，一个（或多个）基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。
    </p>
    <p>
     存储文件的逻辑结构组成了关系数据库的内模式
    </p>
    <p>
     视图是从一个或几个基本表导出的表，它本身不独立存储在数据库中，这些数据仍存放在导出视图的基本表中
    </p>
    <h3 id="%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E5%8F%8A%E8%A7%A3%E9%87%8A">
     专有名词及解释
    </h3>
    <p>
     <strong>
      1.索引
     </strong>
     ：建立索引是加快查询速度的有效手段，用户（数据库管理员或建表者）可以在基本表上建立一个或多个索引，以提供多种存取路径，系统在存取数据时会自动选择合适的索引作为存取路径。
    </p>
    <p>
     索引是关系数据库的内部实现技术，属于内模式的范畴。
    </p>
    <p>
     唯一索引：使用UNIQUE关键字，每个索引值对应唯一一条数据记录
    </p>
    <p>
     非唯一索引：不使用UNIQUE关键字
    </p>
    <p>
     聚簇索引：指索引项的顺序与表中记录的物理顺序一致的索引组织，可以在最经常查询的列上建立聚簇索引，对于经常更新的列不宜建立聚簇索引。一个表只能建立一个聚簇索引，一般默认是主键，所谓“与记录的物理顺序一致”即该记录升序索引也升序之类的？
    </p>
    <p>
    </p>
    <p>
     <strong>
      2.视图
     </strong>
     ：视图是从一个或几个基本表（或视图）导出的表，数据库只存放视图的定义而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中数据发生变化，从视图查询出的数据也会随之改变。
    </p>
    <p>
     视图的作用：
    </p>
    <p>
     ①简化用户的操作：用户所做的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无须了解。
    </p>
    <p>
     ②使用户能以多种角度来看待同一数据：当许多不同种类的用户共享同一个数据库时，这种灵活性是非常有必要的。
    </p>
    <p>
     ③对重构数据库提供了一定的逻辑独立性：即使重构数据库也不一定需要修改应用程序。
    </p>
    <p>
     ④能够对机密数据提供安全保护：只允许用户查询提供给他的视图而不是直接查询表，可以隐藏表中的机密数据
    </p>
    <p>
     ⑤适当的利用视图可以更清晰地表达查询语句：利用视图来表达查询语句
    </p>
    <h3 id="%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">
     数据定义
    </h3>
    <p>
     SQL数据定义语句
    </p>
    <div class="table-box">
     <table border="1" cellspacing="0">
      <tbody>
       <tr>
        <td rowspan="2">
         <p>
          操作对象
         </p>
        </td>
        <td colspan="3">
         <p>
          操作方式
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          创建
         </p>
        </td>
        <td>
         <p>
          删除
         </p>
        </td>
        <td>
         <p>
          修改
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          模式
         </p>
        </td>
        <td>
         <p>
          CREATE SCHEMA
         </p>
        </td>
        <td>
         <p>
          DROP SCHEMA
         </p>
        </td>
        <td>
         <p>
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          表
         </p>
        </td>
        <td>
         <p>
          CREATE TABLE
         </p>
        </td>
        <td>
         <p>
          DROP TABLE
         </p>
        </td>
        <td>
         <p>
          ALTER TABLE
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          视图
         </p>
        </td>
        <td>
         <p>
          CREATE VIEW
         </p>
        </td>
        <td>
         <p>
          DROP VIEW
         </p>
        </td>
        <td>
         <p>
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          索引
         </p>
        </td>
        <td>
         <p>
          CREATE INDEX
         </p>
        </td>
        <td>
         <p>
          DROP INDEX
         </p>
        </td>
        <td>
         <p>
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>
    </p>
    <h4 id="1.%E5%88%9B%E5%BB%BA%2F%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">
     1.创建/删除数据库
    </h4>
    <p>
     create database 数据库名 [其他选项];
    </p>
    <p>
     例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令:
    </p>
    <p>
     create database samp_db character set gbk;
    </p>
    <p>
     为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。
    </p>
    <p>
     drop database 数据库名 删除数据库
    </p>
    <h4 id="2.%E5%88%9B%E5%BB%BA%2F%E5%88%A0%E9%99%A4%2F%E4%BF%AE%E6%94%B9%E5%9F%BA%E6%9C%AC%E8%A1%A8">
     2.创建/删除/修改基本表
    </h4>
    <p>
     create table student(
    </p>
    <p>
     id int auto_increment primary key,
    </p>
    <p>
     name varchar(50),
    </p>
    <p>
     sex varchar(20),
    </p>
    <p>
     date varchar(50),
    </p>
    <p>
     content varchar(100)
    </p>
    <p>
     )default charset=utf8;
    </p>
    <p>
     【说明】
    </p>
    <p>
     DATATYPE --数据类型，mysql有bit int decimal float varchar char date datetime
    </p>
    <p>
     NUT NULL --可不可以允许资料有空的
    </p>
    <p>
     PRIMARY KEY --是本表的主键
    </p>
    <p>
     CONSTRAINT --是对表里的字段添加约束.(约束类型有Check,Unique,Primary key,not null,Foreign key);
    </p>
    <p>
     删除表：drop table student
    </p>
    <p>
     <em>
      修改表：
     </em>
    </p>
    <p>
     #表结构修改
    </p>
    <p>
     create table test
    </p>
    <p>
     (
    </p>
    <p>
     id int not null auto_increment primary key, #设定主键
    </p>
    <p>
     name varchar(20) not null default 'NoName', #设定默认值
    </p>
    <p>
     department_id int not null,
    </p>
    <p>
     position_id int not null,
    </p>
    <p>
     unique (department_id,position_id) #设定唯一值
    </p>
    <p>
     );
    </p>
    <p>
    </p>
    <p>
     #修改表的名字
    </p>
    <p>
     #格式:alter table tbl_name rename to new_name
    </p>
    <p>
     alter table test rename to test_rename;
    </p>
    <p>
    </p>
    <p>
     #向表中增加一个字段(列)
    </p>
    <p>
     #格式:alter table tablename add columnname type;/alter table tablename add(columnname type);
    </p>
    <p>
     alter table test add  columnname varchar(20);
    </p>
    <p>
    </p>
    <p>
     #修改表中某个字段的名字
    </p>
    <p>
     alter table tablename change columnname newcolumnname type;  #修改一个表的字段名
    </p>
    <p>
     alter table test change name uname varchar(50);
    </p>
    <p>
    </p>
    <p>
     select * from test;
    </p>
    <p>
    </p>
    <p>
     #表position 增加列test
    </p>
    <p>
     alter table position add(test char(10));
    </p>
    <p>
     #表position 修改列test
    </p>
    <p>
     alter table position modify test char(20) not null;
    </p>
    <p>
     #表position 修改列test 默认值
    </p>
    <p>
     alter table position alter test set default 'system';
    </p>
    <p>
     #表position 去掉test 默认值
    </p>
    <p>
     alter table position alter test drop default;
    </p>
    <p>
     #表position 去掉列test
    </p>
    <p>
     alter table position drop column test;
    </p>
    <p>
     #表depart_pos 删除主键
    </p>
    <p>
     alter table depart_pos drop primary key;
    </p>
    <p>
     #表depart_pos 增加主键
    </p>
    <p>
     alter table depart_pos add primary key PK_depart_pos
    </p>
    <p>
     (department_id,position_id);
    </p>
    <h4 id="3.%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE">
     3.主键和外键
    </h4>
    <p>
     主键具有唯一性，能够唯一标识表中的一个单独的行
    </p>
    <p>
     定义外键是为了确保这一列的值是有效的（比如说该列为该表与另一个表“共同使用”的列，那么需要保证其“确实存在”，即在另一个表中有对应的值才能进行相关操作）
    </p>
    <h4 id="4.%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">
     4.建立索引
    </h4>
    <p>
     CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;
    </p>
    <p>
     ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);
    </p>
    <ul>
     <li>
      &lt;表名&gt;：要建索引的基本表的名字
     </li>
     <li>
      索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔
     </li>
     <li>
      &lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC
     </li>
     <li>
      UNIQUE：此索引的每一个索引值只对应唯一的数据记录
     </li>
     <li>
      CLUSTER：表示要建立的索引是聚簇索引
     </li>
    </ul>
    <p>
     <img alt="" class="has" height="197" src="https://i-blog.csdnimg.cn/blog_migrate/adb3ad0d82e233393545c994a3af8c5c.png" width="405"/>
    </p>
    <p>
     <img alt="" class="has" height="323" src="https://i-blog.csdnimg.cn/blog_migrate/fd829f1d5af9733b967bb035aec05652.png" width="469"/>
    </p>
    <h3 id="%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">
     数据查询
    </h3>
    <p>
     SELECT [ALL | DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] …
    </p>
    <p>
     FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] …
    </p>
    <p>
     [ WHERE &lt;条件表达式&gt; ]
    </p>
    <p>
     [ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ]
    </p>
    <p>
     [ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]；
    </p>
    <p>
     语义：根据WHERE子句的条件表达式，从FROM子句指定的基本表或视图中找出满足条件的元组，再按SELECT子句中的目标表达式，选出元组中的属性值形成结果表。
    </p>
    <p>
     如果有GROUP BY子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组称为一个组。如果GROUP BY子句带HAVING短语，则只有满足指定条件的组才予以输出。
    </p>
    <p>
     如果有ORDER BY子句，则结果表还要按&lt;列名 2&gt;的值的升序或降序排列
    </p>
    <h4 id="%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2">
     单表查询
    </h4>
    <p>
     <strong>
      1.选择表中的若干列
     </strong>
    </p>
    <p>
     SELECT Sno,Sname FROM Student
    </p>
    <p>
     SELECT * FROM Student
    </p>
    <p>
     SELECT Sname, 2014 – Sage FROM Student /* 查询结果的第2列是一个算术表达式，表中会得到2014 – Sage的值 */
    </p>
    <p>
     SELECT Sname NAME, ‘Year of Birth’: BIRTH, 2004 – Sage BIRTHDAY, LOWER(Sdept) DEPARTMENT /* 可以通过指定别名来改变查询结果的列标题，Sname列名会变为NAME */
    </p>
    <p>
     <strong>
      2.选择表中的若干元组
     </strong>
    </p>
    <p>
     ①SELECT DISTINCT Sno FROM SC /* 使用DISTINCT关键字消除重复的行 */
    </p>
    <p>
     ②使用WHERE查询满足条件的元组
    </p>
    <div class="table-box">
     <table border="1" cellspacing="0">
      <tbody>
       <tr>
        <td>
         <p>
          查 询 条 件
         </p>
        </td>
        <td>
         <p>
          谓 词
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          比 较
         </p>
        </td>
        <td>
         <p>
          =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt;；NOT+上述比较运算符
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          确定范围
         </p>
        </td>
        <td>
         <p>
          BETWEEN AND，NOT BETWEEN AND
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          确定集合
         </p>
        </td>
        <td>
         <p>
          IN，NOT IN
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          字符匹配
         </p>
        </td>
        <td>
         <p>
          LIKE，NOT LIKE
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          空 值
         </p>
        </td>
        <td>
         <p>
          IS NULL，IS NOT NULL
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          多重条件（逻辑运算）
         </p>
        </td>
        <td>
         <p>
          AND，OR，NOT
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>
     SELECT Sname, Sdept, Sage FROM Student WHERE Sage BETWEEN 20 AND 33
    </p>
    <p>
     /* 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别、年龄 */
    </p>
    <p>
     SELECT Sname, Ssex FROM Student WHERE Sdept IN (‘CS’, ‘MA’, ‘IS’)
    </p>
    <p>
     /* IN用于查找属性值属于指定集合的元组，即Sdept等于’CS’ ‘MA’ ‘IS’中的一个即可 */
    </p>
    <p>
     字符匹配：[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]
    </p>
    <p>
     语义：查找指定的属性列值与&lt;匹配串&gt;相匹配的元组，ESCAPE用于对通配符的转义，如WHERE Cname LIKE ‘DB\_Design’ ESCAPE ‘\’
    </p>
    <p>
     /* 将\定义为转义字符，这样匹配的就是’DB_Design’，即’_’失去了通配符的含义 */
    </p>
    <ul>
     <li>
      %：代表任意长度（&gt;=0）的字符串
     </li>
     <li>
      _：代表任意单个字符
     </li>
     <li>
      [ ]：匹配括号内所列字符中的一个,
     </li>
     <li>
      [^]：匹配不在括号内所列字符中的单个字符
     </li>
    </ul>
    <p>
     注：数据库字符集为ASCII时一个汉字需要两个_，字符集为GBK时只需要一个
    </p>
    <p>
     ③多重条件查询，逻辑运算符AND 和 OR 可用来联结过个查询条件，AND的优先级高于OR，但可用括号改变优先级
    </p>
    <p>
     SELECT Sname FROM Student WHERE Sdept = ‘CS’ AND Sage &lt; 20
    </p>
    <p>
     <strong>
      3.ORDER BY子句
     </strong>
    </p>
    <p>
     对查询结果按一个或多个属性列的升序（ASC）或降序（DESC）排列，缺省值为升序
    </p>
    <p>
    </p>
    <p>
     <strong>
      4.聚集函数（系统自带函数?）
     </strong>
    </p>
    <p>
     COUNT（*）                                    统计元组个数
    </p>
    <p>
     COUNT（[DISTINCT|ALL] &lt;列名&gt;）  统计一列中值的个数
    </p>
    <p>
     SUM（[DISTINCT|ALL] &lt;列名&gt;）   计算一列值的总和（此列必须为数值型）
    </p>
    <p>
     AVG（[DISTINCT|ALL] &lt;列名&gt;）            计算一列值的平均值（此列必须为数值型）
    </p>
    <p>
     MAX（[DISTINCT|ALL] &lt;列名&gt;）      求一列中的最大值
    </p>
    <p>
     MIN（[DISTINCT|ALL] &lt;列名&gt;）       求一列中的最小值
    </p>
    <p>
     如果指定DISTINCT短语，则表示在计算时取消指定列中的重复值，ALL为缺省值，表示不取消重复值
    </p>
    <p>
     SELECT COUNT(*) FROM Student /* 查询学生总人数 */
    </p>
    <p>
    </p>
    <p>
     <strong>
      5.GROUP BY子句
     </strong>
    </p>
    <p>
     GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组；分组的目的是为了细化聚集函数的作用对象，如果未对查询结果分组，聚集函数将作用于整个查询结果分组后聚集函数将作用于每一个组，即每一个组都有一个函数值
    </p>
    <p>
     SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*) &gt; 3
    </p>
    <p>
     这里先用GROUP BY 子句按Sno进行分组，再用聚集函数COUNT对每一个组计数，HAVING短语给出了选择组的条件。
    </p>
    <p>
     另外，注意WHERE子句与HAVING子句的作用对象，WHERE子句作用于基本表或视图，从中选择满足条件的元组；HAVING短语作用于组，从中选择满足条件的组
    </p>
    <p>
     如下面的语句是不对的：
    </p>
    <p>
     SELECT Sno, AVG(Grade) FROM SC
    </p>
    <p>
     WHERE AVG(Grade) &gt;= 90 GROUP BY Sno;
    </p>
    <p>
     正确的语句
    </p>
    <p>
     SELECT Sno, AVG(Grade) FROM SC
    </p>
    <p>
     GROUP BY Sno HAVING AVG(Grade) &gt;= 90
    </p>
    <h4 id="%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2">
     连接查询
    </h4>
    <p>
     若一个查询同时涉及两个以上的表，则称之为连接查询
    </p>
    <p>
     <strong>
      1.等值与非等值连接查询
     </strong>
    </p>
    <p>
     连接查询的WHERE子句中用来连接两个表的条件称为链接条件或连接谓词，其一般格式如下：
    </p>
    <p>
     [&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;
    </p>
    <p>
     运算符为 = 时称为等值连接，否则称为非等值连接
    </p>
    <p>
     SELECT Student. *, SC. * FROM Student, SC
    </p>
    <p>
     WHERE Student.Sno = SC.Sno
    </p>
    <p>
     <img alt="" class="has" height="156" src="https://i-blog.csdnimg.cn/blog_migrate/e5c42c86e21fec7ec01418e69d329aa9.png" width="447"/>
    </p>
    <p>
     自然连接（在等值连接中把目标列中重复的属性列去掉）
    </p>
    <p>
     SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade
    </p>
    <p>
     FROM Student, SC
    </p>
    <p>
     WHERE Student.Sno = SC.Sno
    </p>
    <p>
     <strong>
      2.自身连接
     </strong>
    </p>
    <p>
     需要取两个表名
    </p>
    <p>
     SELECT FIRST.Cno, SECOND.Cpno
    </p>
    <p>
     FROM Course FIRST, Course SECOND
    </p>
    <p>
     WHERE FIRST.Cpno = SECOND.Cno
    </p>
    <p>
     <strong>
      3.外连接
     </strong>
    </p>
    <p>
     SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade
    </p>
    <p>
     FROM Student LEFT OUT JOIN SC ON(Student.Sno = SC.Sno)
    </p>
    <p>
     <strong>
      4.复合条件连接
     </strong>
    </p>
    <p>
     INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
    </p>
    <p>
     LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
    </p>
    <p>
     RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。
    </p>
    <p>
     <img alt="" class="has" height="181" src="https://i-blog.csdnimg.cn/blog_migrate/b2ff1108636c9ed03a44f7fc07019ab3.png" width="266"/>
     <img alt="" class="has" height="183" src="https://i-blog.csdnimg.cn/blog_migrate/6c130d0e0c5618c18e23c8b4f13c7842.png" width="285"/>
     <img alt="" class="has" height="179" src="https://i-blog.csdnimg.cn/blog_migrate/659b78e5bbbb46ebf0265971e282ad74.png" width="302"/>
    </p>
    <p>
     <strong>
      嵌套查询和集合查询
     </strong>
    </p>
    <p>
     在子查询中，程序先运行在嵌套在最内层的语句，再运行外层。因此在写子查询语句时，可以先测试下内层的子查询语句是否输出了想要的内容，再一层层往外测试，增加子查询正确率。否则多层的嵌套使语句可读性很低
    </p>
    <p>
     exists的返回结果是bool型，只有true或者false
    </p>
    <p>
     如 SELECT * FROM alumni_info t WHERE EXISTS(SELECT a_id FROM alumni_education e WHERE e.a_id='6588' )，返回的结果跟SELECT * FROM alumni_info t一样（a_id=6588存在），因为select语句先执行where条件后的语句，再筛选字段，当执行完where条件后，若这条结果集存在，则where表达式后面永远都是true，否则为false。也就是说要么查询所有，要么没有数据。
    </p>
    <h4 id="%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2">
     嵌套查询
    </h4>
    <p>
     注意：子查询的SELECT语句中不能使用ORDER BY 子句，ORDER BY子句只能对最终查询结果排序
    </p>
    <p>
     子查询的查询条件依赖于父查询，则称这类子查询为相关子查询，否则称不相关子查询。
    </p>
    <p>
     <strong>
      1.带有IN谓词的子查询
     </strong>
    </p>
    <p>
     子查询结果往往是一个集合，所以谓词IN是嵌套查询中最常使用的谓词
    </p>
    <p>
     SELECT Sno, Sname, Sdept FROM Student
    </p>
    <p>
     WHERE Sdept IN
    </p>
    <p>
     (SELECT Sdept FROM Student WHERE Sname=’刘晨’)
    </p>
    <p>
    </p>
    <p>
     <strong>
      2.带有比较运算符的子查询
     </strong>
    </p>
    <p>
     SELECT Sno, Cno
    </p>
    <p>
     FROM SC x
    </p>
    <p>
     WHERE Grade &gt;= (SELECT AVG(Grade))
    </p>
    <p>
     FROM SC y
    </p>
    <p>
     WHERE y.Sno = x.Sno /* 依赖x.Sno，相关子查询 */
    </p>
    <p>
     其可能的执行过程：
    </p>
    <p>
     ①从外层查询中取出SC的一个元组x，将元组x的Sno值传送给内层查询
    </p>
    <p>
     ②执行内层查询，得到值88，用该值代替内层查询，得到外层查询
    </p>
    <p>
     ③执行这个查询，得到
    </p>
    <p>
     (200215121, 1)
    </p>
    <p>
     (200215121, 3)
    </p>
    <p>
     ④然后外层查询取出下一个元组重复①~③，直到外层的SC元组全部处理完毕
    </p>
    <p>
     如果是不相关子查询，可以发现其求解顺序是从内向外的。
    </p>
    <p>
     <strong>
      3.带有ANY(SOME)或ALL谓词的子查询
     </strong>
    </p>
    <p>
     子查询如果返回多值，就需要使用ANY或ALL谓词，其语义为
    </p>
    <p>
     &gt; ANY           大于子查询结果中的某个值
    </p>
    <p>
     &gt; ALL            大于子查询结果中的所有值
    </p>
    <p>
     ……
    </p>
    <p>
     SELECT Sname, Sage FROM Student
    </p>
    <p>
     WHERE Sage &lt; ALL (SELECT Sage FROM Student
    </p>
    <p>
     WHERE Sdept = ‘CS’)
    </p>
    <p>
     AND Sdept &lt;&gt; ‘CS’;
    </p>
    <p>
     查询其他系中比计算机科学系所有学生年龄都小的学生姓名及年龄
    </p>
    <p>
     执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个集合（20， 19），然后处理父查询
    </p>
    <p>
     <strong>
      4.带有EXISTS谓词的子查询
     </strong>
    </p>
    <p>
     带有EXISTS谓词的子查询不返回任何数据，只产生逻辑值”true”或”false”
    </p>
    <p>
     若内层查询结果非空，则外层的WHERE子句返回真值，否则返回假值，带EXISTS的子查询一般都是用 *
    </p>
    <p>
     SELECT Sname FROM Student
    </p>
    <p>
     WHERE EXISTS
    </p>
    <p>
     (SELECT * FROM SC WHERE Sno = Student.Sno AND Cno = ‘1’);
    </p>
    <p>
     其处理过程：首先取外层查询Student表中的第一个元组，根据它与内层查询相关的属性值（Sno）处理内层查询，若WHERE子句返回值为真，则取外层查询中该元组的Sname放入结果表；……
    </p>
    <p>
    </p>
    <h4 id="%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2">
     集合查询
    </h4>
    <p>
     集合操作包括并操作UNION、交操作INTERSECT和差操作EXCEPT，参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同。（相同属性列？）
    </p>
    <h3 id="%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0">
     数据更新
    </h3>
    <h4 id="%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">
     插入数据
    </h4>
    <p>
     INSERT通常有两种形式，一种是插入一个元组，另一种是插入子查询结果。后者可一次插入多个元组。
    </p>
    <p>
     INSERT
    </p>
    <p>
     INTO &lt;表名&gt; [(&lt;属性列1&gt;[，&lt;属性列2 &gt;…)]
    </p>
    <p>
     VALUES (&lt;常量1&gt; [，&lt;常量2&gt;] … )
    </p>
    <p>
     注意：INTO子句中没有出现的属性列，新元组在这些列上将取空值。如果表定义说明了NOT NULL的属性列不能取空值，否则会出错。
    </p>
    <p>
     如果INTO子句没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值。
    </p>
    <p>
    </p>
    <h4 id="%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">
     修改数据
    </h4>
    <p>
     UPDATE &lt;表名&gt;
    </p>
    <p>
     SET &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…
    </p>
    <p>
     [WHERE &lt;条件&gt;]；
    </p>
    <p>
     修改指定表中满足WHERE子句条件的元组，如果省略WHERE子句，则表示要修改表中所有的元组。
    </p>
    <p>
     UPDATE Student SET Sage = Sage + 1 /* 将所有学生的年龄增加1岁 */
    </p>
    <p>
     UPDATE Student SET Sage = 22 WHERE Sno = ‘200215121’
    </p>
    <p>
    </p>
    <h4 id="%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">
     删除数据
    </h4>
    <p>
     DELETE
    </p>
    <p>
     FROM &lt;表名&gt;
    </p>
    <p>
     [WHERE &lt;条件&gt;]；
    </p>
    <p>
     从指定表删除满足WHERE子句条件的所有元组。如果省略WHERE子句，则删除表中全部元组，但表的定义仍在字典中。即DELETE语句删除的是表中的数据，而不是关于表的定义。
    </p>
    <h3 id="%E8%A7%86%E5%9B%BE">
     视图
    </h3>
    <p>
     CREATE VIEW
    </p>
    <p>
     &lt;视图名&gt; [(&lt;列名&gt; [，&lt;列名&gt;]…)]
    </p>
    <p>
     AS &lt;子查询&gt;
    </p>
    <p>
     [WITH CHECK OPTION]；
    </p>
    <h2 id="%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7">
     第4章 数据库安全性
    </h2>
    <p>
     这里只讨论用户标识和鉴定、存取控制、视图、审计、数据加密技术。
    </p>
    <h3>
     专有名词及解释
    </h3>
    <p>
     <strong>
      1.数据库管理员
     </strong>
     ：拥有所有对象的所有权限，根据实际情况不同的权限授予不同的用户
    </p>
    <p>
     <strong>
      2.用户
     </strong>
     ：拥有自己建立的对象的全部的操作权限，可以使用GRANT，把权限授予其他用户
    </p>
    <p>
     <strong>
      3.角色
     </strong>
     ：数据库角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程。
    </p>
    <p>
     <strong>
      4.审计
     </strong>
     ：启用一个专用的审计日志（Audit Log），将用户对数据库的所有操作记录在上面；审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容。
    </p>
    <ul>
     <li>
      审计很费时间和空间
     </li>
     <li>
      DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能
     </li>
     <li>
      审计功能主要用于安全性要求较高的部门
     </li>
    </ul>
    <p>
    </p>
    <h3 id="%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86%E4%B8%8E%E9%89%B4%E5%88%AB%EF%BC%88Identification%20%26%20Authentication%EF%BC%89">
     用户标识与鉴别（Identification &amp; Authentication）
    </h3>
    <p>
     即由系统提供一定的方式让用户标识自己的名字或身份，每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供机器使用权。如连接数据库时输入的用户名和密码。
    </p>
    <h3 id="%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">
     存取控制
    </h3>
    <p>
     存取控制机制主要包括两部分：
    </p>
    <p>
     1.定义用户权限，并将用户权限登记到数据字典中
    </p>
    <p>
     2.合法权限检查：每当用户发出存取数据库的操作请求后，DBMS查找数据字典，根据安全规则进行合法权限检查。
    </p>
    <p>
     <strong>
      自主存取控制（Discretionary Access Control，DAC）
     </strong>
     ：用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的存取权限转授给其他用户。非常灵活。主要通过SQL的GRANT语句和REVOKE语句来实现。
    </p>
    <p>
     <strong>
      强制存取控制（Mandatory Access Control，MAC）
     </strong>
     ：每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。较为严格。
    </p>
    <h4 id="%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">
     自主存取控制
    </h4>
    <p>
     <img alt="" class="has" height="254" src="https://i-blog.csdnimg.cn/blog_migrate/1d72f2e64328d2c4c28ec94632bf001b.png" width="554"/>
    </p>
    <p>
     GRANT &lt;权限&gt;[,&lt;权限&gt;]...
    </p>
    <p>
     ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…
    </p>
    <p>
     TO &lt;用户&gt;[,&lt;用户&gt;]...
    </p>
    <p>
     [WITH GRANT OPTION];
    </p>
    <p>
     语义：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是DBA，也可以是数据库对象创建者，也可以是已经拥有该权限的用户。
    </p>
    <p>
     如果指定了WITH GRANT OPTION 子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。不允许循环授权
    </p>
    <p>
     <img alt="" class="has" height="55" src="https://i-blog.csdnimg.cn/blog_migrate/2b3a77623ee9d37b30bbd2ad1f33fdc4.png" width="236"/>
    </p>
    <p>
     GRANT SELECT ON TABLE Student TO U1; /* 把查询Student表的权限授予用户U1 */
    </p>
    <p>
    </p>
    <p>
     REVOKE &lt;权限&gt;[,&lt;权限&gt;]...
    </p>
    <p>
     ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…
    </p>
    <p>
     FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE|RESTRICT];
    </p>
    <p>
     REVOKE UPDATE(Sno) ON TABLE Student FROM U4; /*回收用户U4修改学生学号的权限*/
    </p>
    <p>
    </p>
    <h4 id="%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">
     强制存取控制
    </h4>
    <ol>
     <li>
      保证更高程度的安全性
     </li>
     <li>
      用户不能直接感知或进行控制
     </li>
     <li>
      适用于对数据有严格而固定密级分类的部门
     </li>
    </ol>
    <p>
    </p>
    <p>
     在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类：
    </p>
    <p>
     <strong>
      主体
     </strong>
     是系统中的活动实体，如：DBMS所管理的实际用户，代表用户的各进程
    </p>
    <p>
     <strong>
      客体
     </strong>
     是系统中的被动实体，受主体操纵，如：文件、基表、索引、视图
    </p>
    <p>
     <strong>
      敏感度标记（Label）
     </strong>
     ：对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）敏感度标记分成若干级别
    </p>
    <ul>
     <li>
      绝密（Top Secret，TS）
     </li>
     <li>
      机密（Secret，S）
     </li>
     <li>
      可信（Confidential，C）
     </li>
     <li>
      公开（Public，P）
     </li>
    </ul>
    <p>
     TS&gt;=S&gt;=C&gt;=P
    </p>
    <p>
     主体的敏感度标记称为
     <strong>
      许可证级别
     </strong>
     （Clearance Level）
    </p>
    <p>
     客体的敏感度标记称为
     <strong>
      密级
     </strong>
     （Classification Level）
    </p>
    <p>
     当一个用户以标记label注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：
    </p>
    <p>
     (1)仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体
    </p>
    <p>
     (2)仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体
    </p>
    <p>
     注意第2点，即用户可以写入数据但是不能再读取自己写入的数据。
    </p>
    <p>
    </p>
    <h2 id="%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7">
     第5章 数据库完整性
    </h2>
    <p>
     数据库完整性是指数据的正确性和相容性。完整性是为了防止数据库中存在不符合语义的数据，即防止数据库中存在不正确的数据。
    </p>
    <p>
     为了维护数据库的完整性，DBMS必须能够：
    </p>
    <p>
     1.提供定义完整性约束条件的机制：完整性一般由SQL的DDL语句来实现，它们作为数据库模式的一部分存入数据字典中。
    </p>
    <p>
     2.提供完整性检查的方法：检查数据是否满足完整性约束条件的机制
    </p>
    <p>
     3.违约处理：若用户违背了完整性约束条件，应该采取的动作
    </p>
    <h3 id="%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7">
     实体完整性
    </h3>
    <p>
     关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。一种是定义为列级约束条件，另一种是定义为表级约束条件
    </p>
    <p>
     CREATE TABLE Student (
    </p>
    <p>
     Sno CHAR(9) PRIMARY KEY, /*在列级定义主码*/
    </p>
    <p>
     Sname CHAR(20) NOT NULL,
    </p>
    <p>
     Ssex CHAR(2),
    </p>
    <p>
     Sage SMALLINT,
    </p>
    <p>
     Sdept CHAR(20)
    </p>
    <p>
     );
    </p>
    <p>
    </p>
    <p>
     CREATE TABLE Student (
    </p>
    <p>
     Sno CHAR(9) ,
    </p>
    <p>
     Sname CHAR(20) NOT NULL,
    </p>
    <p>
     Ssex CHAR(2),
    </p>
    <p>
     Sage SMALLINT,
    </p>
    <p>
     Sdept CHAR(20)
    </p>
    <p>
     PRIMARY KEY(Sno)  /*在表级定义主码*/
    </p>
    <p>
     );
    </p>
    <p>
     CREATE TABLE Student (
    </p>
    <p>
     Sno CHAR(9) ,
    </p>
    <p>
     Sname CHAR(20) NOT NULL,
    </p>
    <p>
     Ssex CHAR(2),
    </p>
    <p>
     Sage SMALLINT,
    </p>
    <p>
     Sdept CHAR(20)
    </p>
    <p>
     PRIMARY KEY(Sno,Sname)  /*属性组定义为主码，只能在表级定义*/
    </p>
    <p>
     );
    </p>
    <p>
     违约处理：
    </p>
    <p>
     当用户程序对基本表插入一条记录或对主码列进行更新操作时，会进行如下检查
    </p>
    <p>
     （1）检查主码值是否唯一，如果不唯一则拒绝插入或修改
    </p>
    <p>
     （2）检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改
    </p>
    <h3 id="%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7">
     参照完整性
    </h3>
    <p>
     关系模型的参照完整性在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码，用REFERENCES短语指明这些外码参照哪些表的主码。
    </p>
    <p>
     例如，关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno,Cno）是主码。Sno、Cno分别参照引用Student表的主码和Course表的主码
    </p>
    <p>
     CREATE TABLE SC (
    </p>
    <p>
     Sno CHAR(9) NOT NULL,
    </p>
    <p>
     Cno CHAR(4) NOT NULL,
    </p>
    <p>
     Grade SMALLINT,
    </p>
    <p>
     PRIMARY KEY(Sno, Cno),
    </p>
    <p>
     FOREIGN KEY(Sno) REFERENCES Student(Sno),
    </p>
    <p>
     FOREIGN KEY(Cno) REFERENCES Course(Cno)    /*在表级定义参照完整性*/
    </p>
    <p>
     );
    </p>
    <p>
     违约检查：
    </p>
    <p>
     对被参照表和参照表进行增删改操作时都会进行检查
    </p>
    <p>
     <img alt="" class="has" height="149" src="https://i-blog.csdnimg.cn/blog_migrate/76b73c08300c285d3cd559060f90ae24.png" width="358"/>
    </p>
    <p>
     当不一致发生时，系统可以采用如下策略处理：
    </p>
    <p>
     （1）拒绝(NO ACTION)执行：不允许该操作执行，该策略一般设置为默认策略
    </p>
    <p>
     （2）级联(CASCADE)操作：当删除或修改被参照表的一个元组导致与参照表（SC）的不一致时，删除或修改参照表中的所有导致不一致的元组。
    </p>
    <p>
     （3）设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有造成不一致的元组的对应属性设置为空值。
    </p>
    <p>
     如果要采取非默认策略需要显式地加以说明，如：
    </p>
    <p>
     ON DELETE NO ACTION
    </p>
    <p>
     ON UPDATE CASCADE
    </p>
    <h3 id="%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7">
     用户自定义完整性
    </h3>
    <p>
     1.属性上的约束条件的定义
    </p>
    <p>
     NULL/NOT NULL、DEFAULT，UNIQUE、CHECK
    </p>
    <ul>
     <li>
      列值非空（NOT NULL）
     </li>
     <li>
      列值唯一（UNIQUE）
     </li>
    </ul>
    <p>
     2.元组上的约束条件
    </p>
    <p>
     使用CHECK短语定义元组上的约束条件，如下：
    </p>
    <p>
     CREATE TABLE SC (
    </p>
    <p>
     Sno CHAR(9) NOT NULL,
    </p>
    <p>
     Cno CHAR(4) NOT NULL,
    </p>
    <p>
     Grade SMALLINT,
    </p>
    <p>
     PRIMARY KEY(Sno, Cno),
    </p>
    <p>
     <strong>
      CHECK(Sno='x' OR Cno NOT LIKE 'MS.%')
     </strong>
    </p>
    <p>
     );
    </p>
    <p>
     违约处理：拒绝执行
    </p>
    <h3 id="%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88Trigger%EF%BC%89">
     触发器（Trigger）
    </h3>
    <p>
     触发器是用户定义在关系表上的一类由事件驱动的特殊过程，其不仅可以用于数据库完整性检查，也可以用来实现数据库的其他功能，包括数据库安全性，以及一些业务流程和控制流程。
    </p>
    <p>
     定义触发器：
    </p>
    <p>
     CREATE TRIGGER &lt;触发器名&gt;    /*每当触发事件发生时，该触发器被激活*/
    </p>
    <p>
     {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt; /*指明触发器激活的时间是在执行触发事件前或后*/
    </p>
    <p>
     REFERENCING NEW|OLD ROW AS &lt;变量&gt; /*REFERENCING 指出引用的变量*/
    </p>
    <p>
     FOR EACH {ROW | STATEMENT}             /*定义触发器的类型，指明动作体执行的频率*/
    </p>
    <p>
     [WHEN &lt;触发条件&gt; ]                         /*仅当触发条件为真时才执行触发动作体*/
    </p>
    <p>
     &lt;触发动作体&gt;
    </p>
    <p>
     要点:
    </p>
    <ol>
     <li>
      只有创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器
     </li>
     <li>
      触发器名唯一
     </li>
     <li>
      触发器只能定义在基本表上，不能定义在视图上
     </li>
     <li>
      触发事件可以是INSERT DELETE 或 UPDATE，也可以是这几个事件的组合，如INSERT OR DELETE等，还可以是UPDATE OF &lt;触发列, …&gt;指明修改哪些列时激活触发器。
     </li>
     <li>
      AFTER / BEFORE 是触发的时机，AFTER表示在触发事件的操作执行之后激活触发器。
     </li>
     <li>
      触发器类型：FOR EACH ROW（行级触发器）和FOR EACH STATEMENT（语句触发器），假设表TEACHAR 有1000行，行级触发器将执行1000次，而语句触发器只执行1次
     </li>
     <li>
      触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行。
     </li>
     <li>
      触发动作体：在过程体中可以使用NEW和OLD来引用UPDATE/INSERT事件之后的新值和之前的旧值，如果是语句级触发器则不能使用NEW或OLD引用。
     </li>
    </ol>
    <p>
    </p>
    <p>
     多个执行语句的触发器：
    </p>
    <p>
     CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件
    </p>
    <p>
     ON 表名 FOR EACH ROW
    </p>
    <p>
     BEGIN
    </p>
    <p>
     执行语句列表
    </p>
    <p>
     END
    </p>
    <p>
    </p>
    <p>
     CREATE TRIGGER Insert_Or_Update_Sal
    </p>
    <p>
     BEFORE INSERT OR UPDATE ON Teacher
    </p>
    <p>
     FOR EACH ROW
    </p>
    <p>
     AS BEGIN
    </p>
    <p>
     IF (new.Job = ‘教授’) AND (new.Sal &lt; 4000) THEN
    </p>
    <p>
     new.Sal := 4000;
    </p>
    <p>
     END IF;
    </p>
    <p>
     END;
    </p>
    <p>
     删除触发器：DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;
    </p>
    <p>
    </p>
    <h2 id="%E7%AC%AC6%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA">
     第6章 关系数据库理论
    </h2>
    <p>
     <strong>
      数据依赖
     </strong>
     ：数据依赖是一个关系内部属性与属性之间的一种约束关系。有多种类型的数据依赖，其中最重要的是
     <strong>
      函数依赖（Functional Dependency,FD）
     </strong>
     和
     <strong>
      多值依赖（Multivalued Dependency,MVD）
     </strong>
    </p>
    <p>
     一个不好的关系模式会存在以下一些问题：
    </p>
    <p>
     (1) 数据冗余太大：信息被重复存储，导致浪费大量存储空间
    </p>
    <p>
     (2) 更新异常：当重复信息的一个副本被修改，所有副本都必须进行同样的修改。因此当更新数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。
    </p>
    <p>
     (3) 插入异常：只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中
    </p>
    <p>
     (4) 删除异常：删除某些信息时可能丢失其它信息
    </p>
    <h3 id="%E8%A7%84%E8%8C%83%E5%8C%96">
     规范化
    </h3>
    <p>
     规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决数据冗余、插入异常、更新异常、删除异常这些问题。
    </p>
    <p>
     定义1：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。
    </p>
    <p>
     <img alt="" class="has" height="218" src="https://i-blog.csdnimg.cn/blog_migrate/96e7357631bac30177779042d169904c.png" width="413"/>
    </p>
    <p>
     即Sno→Sname这个函数依赖只有在不可能存在两个元组在Sno上的值相等，而在Sname上的值不等时才成立。（左边相等右边必相等）
    </p>
    <p>
     在关系模式R(U)中，对于U的子集X和Y，
    </p>
    <p>
     如果X→Y，但Y不为X的子集？，则称X→Y是
     <strong>
      非平凡的函数依赖
     </strong>
    </p>
    <p>
     若X→Y，但Y Í X, 则称X→Y是
     <strong>
      平凡的函数依赖
     </strong>
    </p>
    <p>
     完全函数依赖：
     <img alt="" class="has" height="28" src="https://i-blog.csdnimg.cn/blog_migrate/ab690f1a9d50c89696d1134ec86d3ffc.png" width="75"/>
    </p>
    <p>
     部分函数依赖：
     <img alt="" class="has" height="28" src="https://i-blog.csdnimg.cn/blog_migrate/c888975f9f4664dcf017990381c99266.png" width="75"/>
    </p>
    <p>
     <img alt="" class="has" height="185" src="https://i-blog.csdnimg.cn/blog_migrate/691ca49f06e282fb3582f312d580a94c.png" width="481"/>
    </p>
    <p>
     上图中
     <img alt="" class="has" height="28" src="https://i-blog.csdnimg.cn/blog_migrate/17279b187a46943f1eb9a0e3b9a8fcd0.png" width="180"/>
     是完全函数依赖，
     <img alt="" class="has" height="28" src="https://i-blog.csdnimg.cn/blog_migrate/9554c6760a160259749791991b88650f.png" width="177"/>
     是部分数依赖，因为Sno→Sdept成立，而Sno是（Sno，Cno）的真子集
    </p>
    <p>
     范式：
    </p>
    <p>
     <img alt="" class="has" height="27" src="https://i-blog.csdnimg.cn/blog_migrate/fb7b0a9a151ed501d4b243f91b8b07ad.png" width="370"/>
    </p>
    <p>
     一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化
    </p>
    <h4 id="1NF%EF%BC%9A">
     1NF：
    </h4>
    <p>
     如果一关系模式r(R)的每个属性对应的域值都是不可分的(即原子的)，则称r(R)属于第一范式，记为r(R)Î1NF.
    </p>
    <p>
     第一范式的目标是：将基本数据划分成称为实体集或表的逻辑单元，当设计好每个实体后，需要为其指定主码。
    </p>
    <p>
     <img alt="" class="has" height="156" src="https://i-blog.csdnimg.cn/blog_migrate/0f9e98d03ddd1854851cf05dd1f3e466.png" width="465"/>
    </p>
    <p>
     第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库
    </p>
    <h4 id="2NF%EF%BC%9A">
     2NF：
    </h4>
    <p>
     若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈2NF。
    </p>
    <p>
     第二范式的目标：将只部分依赖于候选码（即依赖于候选码的部分属性）的非主属性移到其他表中。
    </p>
    <p>
     <img alt="" class="has" height="124" src="https://i-blog.csdnimg.cn/blog_migrate/828b2b29861ad2e1a1c127ad8f77887d.png" width="241"/>
    </p>
    <p>
     S-L-C这个函数依赖图中非主属性Sdept和Sloc部分函数依赖于码(Sno, Cno)
    </p>
    <p>
     <img alt="" class="has" height="105" src="https://i-blog.csdnimg.cn/blog_migrate/c9b21728bc4c8458b5d5b6955f642bca.png" width="336"/>
    </p>
    <p>
     将其分为两个表后使得非主属性对其各自的码都是完全函数依赖
    </p>
    <p>
     2NF范式虽然消除了由于非主属性对候选码的部 分依赖所引起的冗余及各种异常，但并没有排除传递依赖。因此，还需要对其进一步规范化
    </p>
    <h4 id="3NF%EF%BC%9A">
     3NF：
    </h4>
    <p>
     若R∈3NF，则每一个非主属性既不部分依赖于码也不传递依赖于码
    </p>
    <p>
     第三范式的目标：去掉表中不直接依赖于候选码的非主属性
    </p>
    <p>
     <img alt="" class="has" height="127" src="https://i-blog.csdnimg.cn/blog_migrate/ab25eff8e4d8f77bba1f352de215eb37.png" width="180"/>
    </p>
    <p>
     Sno→Sdept  Sdept → Sno  Sdept→Sloc 可得： Sno→Sloc，即S-L中存在非主属性对码的传递函数依 赖，S-L ∉ 3NF
    </p>
    <p>
     采用投影分解法，把S-L分解为两个关系模式，以消除传递函数依赖：
    </p>
    <p>
     <img alt="" class="has" height="108" src="https://i-blog.csdnimg.cn/blog_migrate/d557a417eaf6a32a6565d90b07050baa.png" width="331"/>
    </p>
    <h4 id="BCNF">
     BCNF
    </h4>
    <p>
     通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。
    </p>
    <p>
     一个满足BCNF的关系模式有：
    </p>
    <ul>
     <li>
      所有非主属性都完全函数依赖于每个候选码
     </li>
     <li>
      所有的主属性都完全函数依赖于每个不包含它的候选码
     </li>
     <li>
      没有任何属性完全函数依赖于非码的任何一组属性
     </li>
    </ul>
    <p>
     BCNF范式排除了：
    </p>
    <ul>
     <li>
      任何属性(包括主属性和非主属性)对候选码的部分依赖和传递依赖；
     </li>
     <li>
      主属性之间的传递依赖。
     </li>
    </ul>
    <p>
     例子：
    </p>
    <p>
     关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课，
    </p>
    <p>
     每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。
    </p>
    <p>
     由语义可得到函数依赖：(S,J)→T；(S,T)→J；T→J
    </p>
    <p>
     因为没有任何非主属性对码传递依赖或部分依赖，
    </p>
    <p>
     STJ ∈ 3NF。
    </p>
    <p>
     因为T是决定因素，而T不包含码，所以STJ 不属于 BCNF 关系。
    </p>
    <p>
     候选码可以有多个，如上面（S,J）和（S,T）都是候选码，包含在任一一个候选码中的属性称为主属性，那么S,J,T都是主属性,以上不满足“所有的主属性都完全函数依赖于每个不包含它的候选码”，是否可以直接理解为决定因素必须为候选码中的一个？
    </p>
    <p>
    </p>
    <h4 id="%E5%B0%8F%E7%BB%93">
     小结
    </h4>
    <p>
     <img alt="" class="has" height="305" src="https://i-blog.csdnimg.cn/blog_migrate/8ded54ba7d761480662ee5cadbb64ea5.png" width="554"/>
    </p>
    <h2 id="%E7%AC%AC7%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">
     第7章 数据库设计
    </h2>
    <p>
     数据库设计可以分为以下6个阶段：
    </p>
    <ol>
     <li>
      需求分析：准确了解和分析用户需求（包括数据和处理）
     </li>
     <li>
      概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型
     </li>
     <li>
      逻辑结构设计：将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化
     </li>
     <li>
      物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）
     </li>
     <li>
      数据库实施：根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库并试运行
     </li>
     <li>
      数据库运行和维护：在数据库投入正式使用后不断地对其进行评价、调整与修改
     </li>
    </ol>
    <p>
     其具体要做的事情如下图：
    </p>
    <p>
     <img alt="" class="has" height="512" src="https://i-blog.csdnimg.cn/blog_migrate/a1348308dc717215929989dc8115f974.png" width="534"/>
    </p>
    <h3 id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">
     需求分析
    </h3>
    <p>
     <strong>
      数据流图表达了数据和处理的关系，数据字典是系统中各类数据描述的集合
     </strong>
    </p>
    <p>
     数据字典通常包括数据项、数据结构、数据流、数据存储、处理过程5个部分
    </p>
    <p>
     1.数据项：数据项描述 = {数据项名，数据项含义说明，别名，数据类型，取值范围……}
    </p>
    <p>
     2.数据结构：数据结构反映了数据之间的组合关系。数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}
    </p>
    <p>
     3.数据流：数据流是数据结构在系统内传输的路径。数据流描述 = {数据流名，数据流来源，数据流去向，平均流量，高峰期流量，组成：{数据结构}}
    </p>
    <p>
     4.数据存储：数据存储是数据结构停留或保存的地方。数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}
    </p>
    <p>
     5.处理过程：处理过程的具体处理逻辑一般用判定表或判定树来描述。处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}概念结构设计
    </p>
    <p>
     需求分析阶段完成数据字典（用于表示收集到的数据）和一组数据流程图（Data Flow Diagram，DFD）
    </p>
    <h3 id="%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">
     概念结构设计
    </h3>
    <p>
     设计概念结构通常有四类方法
    </p>
    <p>
     自顶向下：即首先定义全局概念结构的框架，然后逐步细化
    </p>
    <p>
     自底向上：即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构
    </p>
    <p>
     逐步扩张：首先定义最重要的核心概念结构，然后向外扩充
    </p>
    <p>
     混合策略：即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。
    </p>
    <h3 id="%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">
     逻辑结构设计
    </h3>
    <p>
     E-R图如何转换为关系模型？
    </p>
    <p>
     （1）一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的码；如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。（联系本身的属性？）
    </p>
    <p>
     （2）一个1：n联系可以转换为一个独立的关系模式，
     <strong>
      也可以与n端对应的关系模式合并
     </strong>
     。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码
    </p>
    <p>
     （3）一个m：n联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分
    </p>
    <p>
     <strong>
      数据模型的优化
     </strong>
    </p>
    <p>
     数据库逻辑设计的结果不是唯一的。关系数据模型的优化通常以规范化理论为指导。
    </p>
    <p>
     具体如下：确定数据依赖、分析各关系模式属于第几范式，并不是规范化程度越高的关系就越优，这需要考虑具体情况；
    </p>
    <p>
     对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率。常用的两种分解方法为水平分解和垂直分解。
    </p>
    <p>
     水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系
    </p>
    <p>
     垂直分解：把关系的属性分解为若干个子集合，形成若干子关系模式
    </p>
    <p>
     <strong>
      设计用户子模式
     </strong>
    </p>
    <p>
     如果某些局部应用经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图，用户每次只对定义好的视图进行查询即可。
    </p>
    <h3 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BB%B4%E6%8A%A4">
     数据库的运行与维护
    </h3>
    <p>
     从以下几个角度考虑：
    </p>
    <p>
     1.数据库的转储和恢复
    </p>
    <p>
     2.数据库的安全性、完整性控制
    </p>
    <p>
     3.数据库性能的监督、分析和改造
    </p>
    <p>
     4.数据库的重组织和重构造
    </p>
    <h2 id="%E7%AC%AC9%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">
     第9章 关系查询处理和查询优化
    </h2>
    <h3 id="%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4">
     查询处理步骤
    </h3>
    <p>
     RDBMS查询处理可分为4个阶段：查询分析、查询检查、查询优化和查询执行
    </p>
    <p>
     查询分析：对查询语句进行扫描、词法和语法分析，判断是否符合SQL语法规则。
    </p>
    <p>
     查询检查：根据数据字典对合法的查询语句进行语义检查
    </p>
    <p>
     查询优化：从多种可供选择的执行策略中选择一个高效执行的查询处理策略
    </p>
    <p>
     查询执行：代码生成器生成执行这个查询计划的代码
    </p>
    <p>
     <strong>
      实现查询操作的算法示例
     </strong>
    </p>
    <p>
     一、选择操作的实现
    </p>
    <p>
     1.简单的全表扫描方法：对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件
    </p>
    <p>
     2.索引（或散列）扫描方法：如果选择条件的属性上有索引（如B+树索引或Hash索引），可以用索引扫描方法，通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组
    </p>
    <p>
     二、连接操作的实现
    </p>
    <p>
     例：SELECT * FROM Student, SC WHERE Student.Sno = SC.Sno;
    </p>
    <p>
     <strong>
      1.嵌套循环方法（nested loop）
     </strong>
     ：对外层循环(Student)的每一个元组，检索内层循环(SC)中的每一个元组，并检查这两个元组在连接属性(sno)上是否相等
    </p>
    <p>
     <strong>
      2.排序-合并方法（sort-merge join 或 merge join）
     </strong>
     ：尤其适合连接的表已排好序的情况
    </p>
    <p>
     步骤如下：
    </p>
    <p>
     ①如果连接的表没有排好序，首先对Student表和SC表按连接属性Sno排序
    </p>
    <p>
     ②取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组，把它们连接起来
    </p>
    <p>
     ③当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来。
    </p>
    <p>
     ④重复以上步骤直到Student表扫描完
    </p>
    <p>
     <img alt="" class="has" height="192" src="https://i-blog.csdnimg.cn/blog_migrate/6a3bc2a71e694938e8ae158b0e458e8f.png" width="428"/>
    </p>
    <p>
     <strong>
      3.索引连接方法（index join）
     </strong>
     ：如果内层循环的连接属性上有索引，对于外层关系r的每一个元组tr，利用索引来搜索内层关系s 中与元组tr满足连接条件的元组 。
    </p>
    <p>
     步骤：
    </p>
    <p>
     ① 在SC表上已经建立属性Sno的索引。
    </p>
    <p>
     ② 对Student中每一个元组，由Sno值通过SC的索引查找 相应的SC元组。
    </p>
    <p>
     ③ 把这些SC元组和Student元组连接起来 循环执行②③，直到Student表中的元组处理完
    </p>
    <p>
     <strong>
      4.Hash Join方法
     </strong>
    </p>
    <p>
     把连接属性作为hash码，用同一个hash函数把Student表和SC表中的元组散列到hash表中。
    </p>
    <p>
     划分阶段(building phase, 也称为partitioning phase)：
    </p>
    <p>
     对包含较少元组的表(如Student表)进行一遍处理把它的元组按hash函数分散到hash表的桶中
    </p>
    <p>
     试探阶段(probing phase,也称为连接阶段join phase)
    </p>
    <p>
     对另一个表(SC表)进行一遍处理
    </p>
    <p>
     把SC表的元组也按同一个hash函数（hash码是连接属性）进行散列
    </p>
    <p>
     把SC元组与桶中来自Student表并与之相匹配的元组连接起来
    </p>
    <h3 id="%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5">
     查询优化策略
    </h3>
    <p>
     查询优化的优点：用户不必考虑如何最好地表达查询以获得较好的效率，系统可以比用户程序的“优化”做得更好
    </p>
    <ol>
     <li>
      优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。
     </li>
     <li>
      如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。
     </li>
     <li>
      优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。
     </li>
     <li>
      优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动 优化相当于使得所有人都拥有这些优化技术。
     </li>
    </ol>
    <p>
    </p>
    <h4 id="%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96">
     代数优化
    </h4>
    <p>
     基于关系代数等价变换规则的优化方法，称为代数优化
    </p>
    <p>
     ①XXX结合律、交换律……
    </p>
    <p>
     ②查询树的启发式优化
    </p>
    <p>
     关系代数表达式
     <strong>
      典型的启发式规则
     </strong>
     有：
    </p>
    <p>
     1.选择运算应尽可能先做。这在优化策略中是最重要、最基本的一条，因为选择运算一般使计算的中间结果大大变小？？？
    </p>
    <p>
     2.把投影运算和选择运算同时进行
    </p>
    <p>
     3.把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系
    </p>
    <p>
     4.把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算
    </p>
    <p>
     5.找出公共子表达式
    </p>
    <p>
     <img alt="" class="has" height="189" src="https://i-blog.csdnimg.cn/blog_migrate/dc5a6ef763be2e96412248043bcbf882.png" width="533"/>
    </p>
    <h4 id="%E7%90%86%E4%BC%98%E5%8C%96">
     理优化
    </h4>
    <p>
     物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。
    </p>
    <p>
     选择的方法可以是：
    </p>
    <p>
     ①基于规则的启发式优化：如对于用OR连接的析取选择条件，一般使用全表顺序扫描；如果2个表都已经按照连接属性排序，则选用排序-合并方法等。
    </p>
    <p>
     ②基于代价估算的优化：对各算法通过代价估算公式计算代价选择最优解
    </p>
    <p>
     ③两者结合的优化方法
    </p>
    <p>
    </p>
    <p>
     基于启发式规则的存取路径选择优化
    </p>
    <p>
     <strong>
      一、选择操作的启发式规则
     </strong>
    </p>
    <p>
     1.对于小关系，使用全表顺序扫描，即使选择列上有索引
    </p>
    <p>
     2.对于选择条件是主码 = 值 的查询，查询结果最多是一个元组，可以选择主码索引
    </p>
    <p>
     3.对于选择条件是非主属性 = 值的查询，并且选择列上有索引，则要估算查询结果的元组数目，如果比例较小（&lt; 10%）可以使用索引扫描，否则还是使用全表顺序扫描
    </p>
    <p>
     4.对于选择条件是属性上的非等值查询或范围查询，并且选择列上有索引，同样要估算查询结果的元组数目。
    </p>
    <p>
     5.对于用AND连接的合取选择条件，如果有涉及这些属性的组合索引，则优先采用组合索引扫描方法；如果某些属性上有一般的索引？否则使用全表顺序扫描
    </p>
    <p>
     6.对于用OR连接的析取选择条件，一般使用全表顺序扫描
    </p>
    <p>
     <strong>
      二、连接操作的启发式规则
     </strong>
    </p>
    <p>
     1.如果2个表都已经按照连接属性排序，则选用排序-合并方法
    </p>
    <p>
     2.如果一个表在连接属性上有索引，则可以选用索引连接方法
    </p>
    <p>
     3.如果上面2个规则都不适用，其中一个表较小，可以选用Hash Join
    </p>
    <p>
     4.最后可选用循环嵌套，选择其中较小的表作为外表
    </p>
    <h2 id="%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF">
     第10章 数据库恢复技术
    </h2>
    <p>
     尽管数据库系统中采取了各种保护措施来防止数据库的安全性和完整性被破坏以及并发事务的正确执行，但某些故障仍然不可避免，会导致数据库中部分数据的丢失甚至破坏数据库，数据库恢复就是为了将数据库从错误状态恢复到某一已知的正确状态。
    </p>
    <h3 id="%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">
     事务的基本概念
    </h3>
    <p>
     事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。例如在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句。
    </p>
    <p>
     事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，ROLLBACK表示回滚，在事务运行的过程中发生某种故障事务不能继续执行，系统就会将事务对数据库的已完成操作全部撤销，从而回滚到事务开始时的状态。
    </p>
    <p>
    </p>
    <p>
     <strong>
      事务的特性：
     </strong>
    </p>
    <p>
     原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability），简称ACID
    </p>
    <p>
     1.原子性：事务是数据库的逻辑工作单位，事务中包括的操作要么都做，要么都不做
    </p>
    <p>
     2.一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。事务执行过程中出现故障则称这时的数据库处于不一致性状态。
    </p>
    <p>
     3.隔离性：一个事务的执行不能被其他事务干扰，并发执行的各个事务之间不能互相干扰
    </p>
    <p>
     4.持续性（永久性）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。
    </p>
    <p>
    </p>
    <p>
     事务的ACID特性可能遭到破坏的因素有：
    </p>
    <p>
     (1) 多个事务并行运行时，不同事务的操作交叉执行
    </p>
    <p>
     (2) 事务在运行过程中被强制停止
    </p>
    <h3 id="%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB">
     故障的种类
    </h3>
    <p>
     1.事务内部的故障：
    </p>
    <p>
     2.系统故障：如操作系统故障，CPU故障，系统断电
    </p>
    <p>
     3.介质故障：如磁盘损坏、磁头碰撞、瞬时强磁场干扰等
    </p>
    <p>
     4.计算机病毒
    </p>
    <h3 id="%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E5%8F%8A%E7%AD%96%E7%95%A5">
     恢复的实现技术及策略
    </h3>
    <h4 id="%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8">
     数据转储
    </h4>
    <p>
     转储即DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据称为后被副本。
    </p>
    <p>
     转储又分为
     <strong>
      静态转储
     </strong>
     和
     <strong>
      动态转储
     </strong>
     ：静态转储必须等待正在运行的用户事务结束才能进行；动态转储是指转储期间允许对数据库进行存取或修改，即转储和用户事务可以并发执行。
    </p>
    <p>
     也可分为
     <strong>
      海量转储
     </strong>
     和
     <strong>
      增量转储
     </strong>
     ：海量转储即每次转储全部数据库，增量转储即每次只转储上一次转储后更新的数据。
    </p>
    <h4 id="%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88Logging%EF%BC%89">
     登记日志文件（Logging）
    </h4>
    <p>
     日志文件是用来记录事务对数据库的更新操作的文件。不同数据库系统采用的日志文件格式并不完全一样，主要有两种格式：
     <strong>
      以记录为单位的日志文件
     </strong>
     和
     <strong>
      以数据块为单位的日志文件
     </strong>
    </p>
    <p>
     对以记录为单位的日志文件，日志文件中需要登记的内容包括：
    </p>
    <ul>
     <li>
      各个事务的开始（BEGIN TRANSACTION）标记
     </li>
     <li>
      各个事务的结束（COMMIT或ROLLBACK）标记
     </li>
     <li>
      各个事务的所有更新操作
     </li>
    </ul>
    <p>
     以上每一条内容记为一个日志记录（log record）
    </p>
    <p>
     每个日志记录的内容主要包括：
    </p>
    <ul>
     <li>
      事务标识（标明是哪个事务）
     </li>
     <li>
      操作的类型（插入、删除或修改）
     </li>
     <li>
      操作对象（记录内部标识）
     </li>
     <li>
      更新前数据的旧值（对插入操作而言，此项为空值）
     </li>
     <li>
      更新后数据的新值（对删除操作而言，此项为空值）
     </li>
    </ul>
    <p>
    </p>
    <p>
     对以数据块为单位的日志文件，日志记录的内容包括事务标识和被更新的数据块。由于将更新前的整个块和更新后的整个块都放入日志文件中，操作的类型和操作对象等信息就不必放入日志记录中了。
    </p>
    <p>
    </p>
    <p>
     <strong>
      日志文件的作用：
     </strong>
    </p>
    <p>
     日志文件用于事务故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复
    </p>
    <p>
     具体作用如下：
    </p>
    <ol>
     <li>
      事务故障恢复和系统故障恢复必须用日志文件。
     </li>
     <li>
      在动态转储方式中必须建立日志文件，备份副本和日志文件结合起来才能有效地恢复数据库。
     </li>
     <li>
      在静态转储方式中，也可以建立日志文件。
     </li>
    </ol>
    <p>
     <img alt="" class="has" height="209" src="https://i-blog.csdnimg.cn/blog_migrate/f9186e590effd5073b07ec6a4ce8b8d2.png" width="315"/>
    </p>
    <p>
     <strong>
      登记日志文件
     </strong>
    </p>
    <p>
     为保证数据库是可恢复的，登记日志文件时必须遵循两条规则：
    </p>
    <p>
     (1) 登记的次序严格按并发事务执行的时间次序
    </p>
    <p>
     (2) 必须先写日志文件，后写数据库
    </p>
    <p>
     如果先写了数据库修改，但是没有登记这个日志，那么中途运行故障就无法恢复这个修改了。
    </p>
    <h4 id="%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5">
     恢复策略
    </h4>
    <p>
     REDO：重做，正向扫描日志文件，对每个REDO事务重新执行日志文件登记的操作
    </p>
    <p>
     UDNO：撤销，反向扫描日志文件，对每个UNDO事务的更新操作执行逆操作
    </p>
    <p>
     COMMIT：提交，将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束
    </p>
    <p>
     ROLLBACK：回滚，事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成操作全部撤销，回滚到事务开始时的状态
    </p>
    <p>
     <strong>
      事务故障的恢复：
     </strong>
    </p>
    <p>
     （1）反向扫描日志文件（即从最后向前扫描日志文件），查找该事务的更新操作
    </p>
    <p>
     （2）对该事务的更新操作执行逆操作。（来得及或者未来得及写入数据库都没关系）
    </p>
    <p>
     （3）继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理
    </p>
    <p>
     （4）如此继续，直到读到该事务的开始标记
    </p>
    <p>
     <strong>
      系统故障的恢复：
     </strong>
    </p>
    <p>
     （1）正向扫描日志文件，找出在故障发生前已经提交的事务（这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录），将其事务标记记入REDO队列；同时找出故障发生时尚未完成的事务（这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录），将其事务标记记入UNDO队列
    </p>
    <p>
     （2）对撤销队列中的各个事务执行UNDO操作
    </p>
    <p>
     （3）对重做队列中的各个事务执行REDO操作
    </p>
    <p>
     为什么要REDO？考虑已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库（磁盘）。
    </p>
    <p>
     <strong>
      介质故障的恢复：
     </strong>
    </p>
    <p>
     （1）装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态
    </p>
    <p>
     （2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务，即扫描日志文件找出需要重做和撤销的事务
    </p>
    <p>
    </p>
    <h4 id="%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF">
     具有检查点的恢复技术
    </h4>
    <p>
     <img alt="" class="has" height="316" src="https://i-blog.csdnimg.cn/blog_migrate/5a5a7f482c35bdbffcc060c34423ab4c.png" width="516"/>
    </p>
    <p>
     在故障发生时还未完成的事务需要撤销，在检查点和故障点之间完成的事务需要重做，因为它们对数据库所做的修改在故障发生时可能还在缓冲区中。
    </p>
    <h2 id="%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0">
     第11章 并发控制概述
    </h2>
    <p>
     并发控制概述：事务是并发控制的基本单位，并发控制用于保证事务的隔离性和一致性。
    </p>
    <p>
     事务读数据x一般记为R(x)，写数据x一般记为W(x)
    </p>
    <p>
     如果不对并发操作进行正确调度，可能导致数据的不一致性问题，主要包括丢失修改、不可重复读和读“脏”数据。
    </p>
    <p>
     1.丢失修改：两个事务读入同一数据并修改，其中一个事务的修改会丢失
    </p>
    <p>
     2.不可读重复：事务T1读取数据后，T2执行更新操作，使T1无法再现前一次读取结果
    </p>
    <p>
     3.读脏数据：“脏”数据指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，则T2读取到的数据就为“脏”数据，即不正确的数据。
    </p>
    <h3 id="%E5%B0%81%E9%94%81">
     封锁
    </h3>
    <p>
     封锁即事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。
    </p>
    <p>
     排它锁（写锁，X锁）：若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁前不能再读取和修改A
    </p>
    <p>
     共享锁（读锁，S锁）：若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
    </p>
    <h3 id="%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81">
     活锁和死锁
    </h3>
    <p>
     活锁即一个事务可能永远等待（系统总是先批准其他事务的锁请求），可以采用先来先服务的策略解决。
    </p>
    <p>
     死锁即两个事务互相申请对方锁住的资源导致两个事务永远不能结束。
    </p>
    <p>
     <strong>
      预防策略：
     </strong>
    </p>
    <p>
     (1) 一次性封锁法：一次性封锁发要求每个事务必须一次将所有要使用的数据全部加锁
    </p>
    <p>
     缺点：势必扩大封锁的范围，从而降低了系统的并发度；
    </p>
    <p>
     (2) 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。
    </p>
    <p>
     缺点；难以事先确定封锁顺序
    </p>
    <p>
     <strong>
      死锁解除策略：
     </strong>
    </p>
    <p>
     (1) 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁；
    </p>
    <p>
     缺点：可能误判死锁，事务因为其他原因使等待时间超过时限；若时限设置得太长，死锁发生后不能及时发现
    </p>
    <p>
     (2) 等待图法：并发控制子系统周期性地生成事务等待图，并进行检测，如果发现图中存在回路，则发生了死锁。
    </p>
    <p>
     如果检测到死锁，一般采用的方法是选择一个处理死锁代价较小的事务，将其撤销，释放此事务持有的所有的锁，之后对撤销的事务所执行的数据修改操作必须加以恢复。
    </p>
    <p>
     <img alt="" class="has" height="166" src="https://i-blog.csdnimg.cn/blog_migrate/3727a87794cb300d57b01161e20ea37d.png" width="445"/>
    </p>
    <h3 id="%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7">
     并发调度的可串行性
    </h3>
    <p>
     定义：多个事务的并发执行是正确的，当
     <strong>
      且仅当其结果与按某一次序串行地执行这些事务时的结果相同
     </strong>
     ，称这种调度策略为可串行化的调度。
    </p>
    <p>
     可串行性（Serializability）是并发事务正确调度的准则，按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。
    </p>
    <p>
    </p>
    <p>
     <strong>
      冲突可串行化调度
     </strong>
    </p>
    <p>
     冲突操作是指不同的事务对同一个数据的读写操作和写写操作：
    </p>
    <p>
     Ri (x)与Wj(x) /* 事务Ti读x，Tj写x，其中i≠j*/
    </p>
    <p>
     Wi(x)与Wj(x) /* 事务Ti写x，Tj写x，其中i≠j*/
    </p>
    <p>
     不能交换(Swap)的动作：
    </p>
    <ul>
     <li>
      同一事务的两个操作
     </li>
     <li>
      不同事务的冲突操作
     </li>
    </ul>
    <p>
     一个调度Sc在
     <strong>
      保证冲突操作的次序不变
     </strong>
     的情况下，通过
     <strong>
      交换两个事务不冲突操作的次序
     </strong>
     得到 另一个调度Sc’ ，如果Sc’是串行的，称调度Sc 为
     <strong>
      冲突可串行化的调度
     </strong>
    </p>
    <p>
     一个调度时冲突可串行化的，那么它一定是可串行化的调度，因此，可以用这种方法来判断一个调度是否是冲突可串行化的。
    </p>
    <p>
     冲突可串行化调度是可串行化调度的
     <strong>
      充分条件
     </strong>
     ，不是必要条件，还有不满足冲突可串行化条
    </p>
    <p>
     件的可串行化调度
    </p>
    <p>
     Sc1=r1(A)w1(A)r2(A)w2(A)r1(B)w1(B)r2(B)w2(B)
    </p>
    <p>
     把w2(A)与r1(B)w1(B)交换，得到：
    </p>
    <p>
     r1(A)w1(A)r2(A)r1(B)w1(B)w2(A)r2(B)w2(B)
    </p>
    <p>
     再把r2(A)与r1(B)w1(B)交换：
    </p>
    <p>
     Sc2＝r1(A)w1(A)r1(B)w1(B)r2(A)w2(A)r2(B)w2(B)
    </p>
    <p>
     Sc2等价于一个串行调度T1，T2，Sc1冲突可串行化的调度
    </p>
    <h3 id="%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE">
     两段锁协议
    </h3>
    <p>
     <strong>
      封锁协议（Locking Protocol）
     </strong>
     即对数据对象加锁时约定的一些规则，如何时申请封锁、持锁时间、何时释放锁等。两段锁协议是最常用的一种封锁协议，使用两段锁协议产生的是可串行化调度（充分条件）。
    </p>
    <p>
     两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁
    </p>
    <p>
     (1) 在对任何数据进行读、写操作之前，首先要申请并获取对该数据的封锁
    </p>
    <p>
     (2) 在释放一个封锁之后，事务不得再申请和获得任何其他封锁
    </p>
    <p>
     简单来说，申请锁和释放锁必须是连续的
    </p>
    <p>
     例：
    </p>
    <p>
     事务T1遵守两段锁协议，其封锁序列是：
    </p>
    <p>
     Slock A Slock B Xlock C Unlock B Unlock A Unlock C；
    </p>
    <p>
     l← 扩展阶段 →l l← 收缩阶段 →l
    </p>
    <p>
     事务T2不遵守两段锁协议，其封锁序列是：
    </p>
    <p>
     Slock A Unlock A Slock B Xlock C Unlock C Unlock B
    </p>
    <h2 id="%E4%B9%A0%E9%A2%98">
     习题
    </h2>
    <h3 id="%E9%80%89%E6%8B%A9%E9%A2%98">
     选择题
    </h3>
    <p>
     1.关系代数中的等值连接操作是由
     <u>
      选择和笛卡尔积
     </u>
     这两个操作组成的
    </p>
    <p>
     2.事务日志一般用于保存
     <u>
      对数据的更新操作
     </u>
    </p>
    <p>
     3.设有一个关系：DEPT(DNO,DNAME)，如果要找出倒数第三个字母为 W，并且至少包含 4 个字母的 DNAME，则查询条件子句应写成 WHERE DNAME LIKE （
     <u>
      B
     </u>
     ）
    </p>
    <p>
     （A）'_ _W_%' （B） '_%W_ _' （C） '_W_ _' （D） '_W_%'
    </p>
    <p>
     PS：
    </p>
    <p>
     ‘_’匹配单个任意字符，’%’匹配0个或多个任意字符, ‘[ ]’匹配括号内所列字符中的一个, ‘[^]’匹配不在括号内所列字符中的单个字符
    </p>
    <p>
     4、以下（
     <u>
      D
     </u>
     ）不属于实现数据库系统安全性的主要技术和方法。
    </p>
    <p>
     （A）存取控制技术 （B）视图技术 （C）审计技术 （D）并发控制技术
    </p>
    <p>
     PS：
    </p>
    <p>
     实现数据库安全性的技术和方法有多种，如存取控制技术、视图技术和审计技术
    </p>
    <p>
     并发控制技术用于保证事务的隔离性和一致性
    </p>
    <p>
    </p>
    <p>
     5、有两个关系 R（A，B，C）和 S（B，C，D），则 R÷S 结果的属性个数是（
     <u>
      C
     </u>
     ）。
    </p>
    <p>
     （A）3 （B）2 （C）1 （D）不一定
    </p>
    <p>
    </p>
    <p>
     6、设 U 是所有属性的集合，X、Y、Z 都是 U 的子集，且 Z＝U－X－Y。下面关于多值依赖的叙述中，不正确的是（？？？ ）。
    </p>
    <p>
     （A）若 X→→Y，则 X→→Z （B）若 X→Y，则 X→→Y （C）若 X→→Y，且 Y′∈Y，则 X→→Y′ （D）若 Z＝Φ，则 X→→Y
    </p>
    <p>
     [解析] 多值依赖的性质包括：
    </p>
    <p>
     （1）多值依赖具有对称性 即若X→→Y，则X→→Z，其中Z＝U－X－Y
    </p>
    <p>
     （2）多值依赖具有传递性 即若X→→Y，Y→→Z， 则X→→Z –Y
    </p>
    <p>
     （3）函数依赖是多值依赖的特殊情况。 即若X→Y，则X→→Y。
    </p>
    <p>
     （4）若X→→Y，X→→Z，则X→→YZ。
    </p>
    <p>
     （5）若X→→Y，X→→Z，则X→→Y∩Z。
    </p>
    <p>
     （6）若X→→Y，X→→Z，则X→→Y-Z，X→→Z-Y。
    </p>
    <p>
     多值依赖的定义：设R(U)是一个属性集U上的一个关系模式， X、 Y和Z是U的子集，并且Z＝U－X－Y。关系模式R(U)中多值依赖 X→→Y（Y多值依赖于X）成立， 当且仅当对R(U)的任一关系r，给定的一对（x，z）值，有一 组Y的值，这组值仅仅决定于x值而与z值无关
    </p>
    <p>
    </p>
    <p>
     7、现有一个关系：借阅（书号、书名，库存数，读者号，借期，还期），假如同一本书允许一个读者多次借阅，但不能同时对一种书借多本。则该关系模式的码是（C ）。
    </p>
    <p>
     （A）书号 （B）读者号 （C）书号+读者号 （D）书号+读者号+借期
    </p>
    <p>
    </p>
    <p>
     9、设有关系 R（A，B，C）的值如下：
    </p>
    <div class="table-box">
     <table border="1" cellspacing="0">
      <tbody>
       <tr>
        <td>
         <p>
          A
         </p>
        </td>
        <td>
         <p>
          B
         </p>
        </td>
        <td>
         <p>
          C
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          2
         </p>
        </td>
        <td>
         <p>
          2
         </p>
        </td>
        <td>
         <p>
          3
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          2
         </p>
        </td>
        <td>
         <p>
          3
         </p>
        </td>
        <td>
         <p>
          4
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <p>
          3
         </p>
        </td>
        <td>
         <p>
          3
         </p>
        </td>
        <td>
         <p>
          5
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <p>
    </p>
    <p>
     下列叙述正确的是（B）
    </p>
    <p>
     A．函数依赖 A→B 在上述关系中成立 B．函数依赖 BC→A 在上述关系中成立
    </p>
    <p>
     C．函数依赖 B→A 在上述关系中成立 D．函数依赖 A→BC 在上述关系中成立
    </p>
    <p>
     【解析】：判断一个函数依赖是否成立即对每个决定因素（左边的）其右边的值唯一
    </p>
    <p>
     10、设有事务 T1 和 T2，其并发操作顺序如下图所示，该并发操作带来的问题是:（A）
    </p>
    <p>
     <img alt="" class="has" height="189" src="https://i-blog.csdnimg.cn/blog_migrate/0dc375491a5638f457ebd5fdcd71ba7f.png" width="279"/>
    </p>
    <p>
     A.丢失更新 B.读“脏数据” C.事务不能提交 D.不能重复读
    </p>
    <p>
    </p>
    <p>
     11、关系代数表达式的优化策略中，首先要做的是（B）
    </p>
    <p>
     （A）对文件进行预处理 （B）尽早执行选择运算 （C）尽早执行笛卡尔积运算 （D）尽早执行投影运算
    </p>
    <p>
    </p>
    <p>
     12、在 DB 的三级模式中，外模式（D ）。
    </p>
    <p>
     （A）只有一个 （B）不能有多个 （C）至多一个 （D）可以有多个
    </p>
    <p>
    </p>
    <p>
     13、在 SELECT 语句中，需对分组情况满足的条件进行判断时，应使用（ D）。
    </p>
    <p>
     （A）WHERE （B）GROUP BY （C）GROUP CONDITION （D）HAVING
    </p>
    <p>
    </p>
    <p>
     14、若两个实体间的关系是 1:m，则进行逻辑设计时实现 1:m 联系的方法是（ A）
    </p>
    <p>
     （A）在“m”端实体转换的关系中加入“1”端实体转换的关系的码
    </p>
    <p>
     （B）将“m”端实体转换的关系的码加入“1”端实体转换的关系中
    </p>
    <p>
     （C）在两个实体转换的关系中，分别加入另外一个关系的码
    </p>
    <p>
     （D）将两个实体转换成一个关系
    </p>
    <p>
     【解析】：考察E-R图转换为关系模式，1：n关系可以独自成一个表，也可以与n端关系模式合并
    </p>
    <p>
     其规则如下：注意联系独自成表（关系模式）时合并的是实体的码（而不是所有属性）
    </p>
    <p>
     （1）一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的码；如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。（联系本身的属性？）
    </p>
    <p>
     （2）一个1：n联系可以转换为一个独立的关系模式，
     <strong>
      也可以与n端对应的关系模式合并
     </strong>
     。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码
    </p>
    <p>
     （3）一个m：n联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分
    </p>
    <p>
    </p>
    <p>
     15、若数据库中只包含成功事务提交的结果，则此数据库处于（
     <strong>
      B
     </strong>
     ）状态。
    </p>
    <p>
     （A）安全 （B）一致 （C）不安全 （D）不一致
    </p>
    <p>
    </p>
    <p>
     16、关系数据库的规范化理论主要解决的问题是（
     <strong>
      A
     </strong>
     ）
    </p>
    <p>
     （A）如何构造合适的数据逻辑结构 （B）如何构造合适的数据物理结构 （C）如何构造合适的应用程序 （D）如何控制不同用的操作权限
    </p>
    <p>
     【解析】：概念结构是画E-R图，逻辑结构是建表，物理结构是选择存储结构和存取方法等
    </p>
    <p>
     规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决数据冗余、插入异常、更新异常、删除异常这些问题。说白了就是改造表。
    </p>
    <p>
    </p>
    <p>
     17、DBMS 普遍采用（
     <strong>
      C
     </strong>
     ）方法来保证调度的正确性。
    </p>
    <p>
     （A）索引 （B）授权 （C） 封锁 （D） 日志
    </p>
    <p>
    </p>
    <p>
     18、X→Ai 成立（i=l，2，…，k）是 X→A1 A2…Ak 成立的（
     <strong>
      C
     </strong>
     ）。
    </p>
    <p>
     （A）充分条件 （B）必要条件 （C）充要条件 （D）既不充分也不必要
    </p>
    <p>
    </p>
    <p>
     19、在进行授权时，数据对象的（
     <strong>
      A
     </strong>
     ），授权子系统就越灵活。
    </p>
    <p>
     （A）粒度越小 （B）粒度越大（C）约束越细（D）约束越粗
    </p>
    <p>
     【解析】：粒度？约束？粒度理解为范围？如数据库、表、表操作等；约束理解为规定的细致与否？
    </p>
    <p>
    </p>
    <p>
     20、数据库的概念模型独立于（
     <strong>
      A
     </strong>
     ）。
    </p>
    <p>
     （A）具体的机器和 DBMS （B）E-R 图 （C）信息世界 （D）现实世界
    </p>
    <p>
    </p>
    <p>
     22、如果一个关系 R 中的属性全部都是主属性，则 R 至少可以达到（
     <strong>
      B
     </strong>
     ）。
    </p>
    <p>
     （A）2NF （B）3NF （C）BCNF （D）4NF
    </p>
    <p>
     【解析】一个全部是主属性的关系必然不会有非主属性部分或者传递依赖的问题，故至少是3NF。但此关系无法保证每一个非平凡的多值依赖或者函数依赖都包含码，所以R的最高范式至少是3NF。
    </p>
    <p>
    </p>
    <p>
     23、在 E-R 模型中，如果有 3 个不同的实体集，3 个多对多的联系， 则应转换为（
     <strong>
      B
     </strong>
     ）个关系模式。
    </p>
    <p>
     （A）3 （B）6 （C）9 （D）4
    </p>
    <p>
    </p>
    <p>
     24、关于死锁，下列说法正确的是（
     <strong>
      D
     </strong>
     ）
    </p>
    <p>
     （A）死锁是操作系统中的问题，数据库中不存在
    </p>
    <p>
     （B）数据库中防止死锁的方法是禁止两个用户同时访问数据库
    </p>
    <p>
     （C）当两个用户竞争相同的资源时不会发生死锁
    </p>
    <p>
     （D）只有出现并发操作时，才有可能出现死锁
    </p>
    <p>
    </p>
    <p>
     25、写一个修改到数据库中，与写一个表示这个修改的记录到日志文件中的操作，应该（
     <strong>
      C
     </strong>
     ）。 （A）前者先做 （B）由程序员安排 （C）后者先做 （D）由系统决定哪一个先做
    </p>
    <p>
    </p>
    <p>
     26、在第一个事务以 S 封锁方式读数据 A 时，第二个事务对数据 A 的读取 方式会遭到失败的是（
     <strong>
      A
     </strong>
     ）。
    </p>
    <p>
     （A）实现 X 封锁的读 （B）实现 S 封锁的读 （C）不加锁的读 （D）实现意向共享锁的读
    </p>
    <p>
    </p>
    <p>
     27、视图建立后，在数据字典中存放的是（
     <strong>
      C
     </strong>
     ）。
    </p>
    <p>
     （A）查询语句 （B）组成视图的表的内容 （C）视图的定义 （D）视图对应的表的定义
    </p>
    <p>
    </p>
    <h3 id="%E7%AE%80%E7%AD%94%E9%A2%98">
     简答题
    </h3>
    <p>
     1、什么是视图？使用视图有什么好处？
    </p>
    <p>
     【答】： 视图是从一个或几个基本表（或视图）导出的表，数据库只存放视图的定义而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中数据发生变化，从视图查询出的数据也会随之改变。
    </p>
    <p>
     视图的作用：
    </p>
    <p>
     ①简化用户的操作：用户所做的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无须了解。
    </p>
    <p>
     ②使用户能以多种角度来看待同一数据：当许多不同种类的用户共享同一个数据库时，这种灵活性是非常有必要的。
    </p>
    <p>
     ③对重构数据库提供了一定的逻辑独立性：即使重构数据库也不一定需要修改应用程序。
    </p>
    <p>
     ④能够对机密数据提供安全保护：只允许用户查询提供给他的视图而不是直接查询表，可以隐藏表中的机密数据
    </p>
    <p>
     ⑤适当的利用视图可以更清晰地表达查询语句：利用视图来表达查询语句
    </p>
    <p>
    </p>
    <p>
     2、发生介质故障时，应该如何恢复数据库？
    </p>
    <p>
     【答】：（1）装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态
    </p>
    <p>
     （2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务，即扫描日志文件找出需要重做和撤销的事务
    </p>
    <p>
    </p>
    <p>
     3、什么是数据库的审计？它有什么作用？
    </p>
    <p>
     【答】：数据库的审计即每当用户对数据库执行操作（CRUD）时就在审计文件中增加一条记录（包含谁执行了什么操作），启用一个专用的审计日志（Audit Log），将用户对数据库的所有操作记录在上面；
    </p>
    <p>
     审计的作用：
    </p>
    <p>
     (1) 保证数据库的安全性，数据库管理员可以根据审计文件观察是否有人执行了不安全的操作。审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容
    </p>
    <p>
     (2) 利于查错，可以通过观察执行了哪些操作来找出错误的来源
    </p>
    <ul>
     <li>
      审计很费时间和空间
     </li>
     <li>
      DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能
     </li>
     <li>
      审计功能主要用于安全性要求较高的部门
     </li>
    </ul>
    <p>
    </p>
    <p>
     4、什么是数据库中的事务？它有哪些特性？这些特性的含义是什么
    </p>
    <p>
     【答】：事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。例如在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句。
    </p>
    <p>
     事务的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability），简称ACID
    </p>
    <p>
     1.原子性：事务是数据库的逻辑工作单位，事务中包括的操作要么都做，要么都不做
    </p>
    <p>
     2.一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。事务执行过程中出现故障则称这时的数据库处于不一致性状态。
    </p>
    <p>
     3.隔离性：一个事务的执行不能被其他事务干扰，并发执行的各个事务之间不能互相干扰
    </p>
    <p>
     4.持续性（永久性）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。
    </p>
    <p>
    </p>
    <p>
     5、如何判断一个关系是否属于第三范式？
    </p>
    <p>
     【答】：判断一个关系是否属于第三范式首先判断它是否属于第二范式，即非主属性是否部分依赖于码，如果属于第二范式再看非主属性是否传递依赖于码，如果两个都是否，则该关系属于第三范式。（1NF：每个属性对应的值域都是不可分的）；另外，如果该关系为全码，则它肯定属于第三范式
    </p>
    <p>
    </p>
    <p>
     6、在数据库设计时，什么是数据字典？数据字典中通常有哪些内容？
    </p>
    <p>
     【答】：
     <strong>
      数据流图表达了数据和处理的关系，数据字典是系统中各类数据描述的集合
     </strong>
    </p>
    <p>
     数据字典通常包括数据项、数据结构、数据流、数据存储、处理过程5个部分
    </p>
    <p>
     ①数据项：数据项描述 = {数据项名，数据项含义说明，别名，数据类型，取值范围……}
    </p>
    <p>
     ②数据结构：数据结构反映了数据之间的组合关系。数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}
    </p>
    <p>
     ③数据流：数据流是数据结构在系统内传输的路径。数据流描述 = {数据流名，数据流来源，数据流去向，平均流量，高峰期流量，组成：{数据结构}}
    </p>
    <p>
     ④数据存储：数据存储是数据结构停留或保存的地方。数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}
    </p>
    <p>
     ⑤处理过程：处理过程的具体处理逻辑一般用判定表或判定树来描述。处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}概念结构设计
    </p>
    <p>
    </p>
    <p>
     7、在数据库的查询优化中，什么是代数优化？什么是物理优化？
    </p>
    <p>
     【答】：代数优化即通过一些定律或启发式规则对关系代数操作（选择、投影、连接等）做替换（顺序）、合并等从而达到优化的效果；物理优化即通过使用合适的存储方式及存取方法来实现优化（如选择操作是使用全表扫描还是索引扫描，连接操作是使用嵌套循环还是排序-合并方法等）
    </p>
    <p>
     基于关系代数等价变换规则的优化方法，称为代数优化
    </p>
    <p>
     物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标
    </p>
    <p>
    </p>
    <p>
     8、在基于检查点的数据库恢复技术中，检查点记录的内容应该包括哪些？
    </p>
    <p>
     【答】：检查点记录的内容包括
    </p>
    <p>
     ①建立检查点时刻所有正在执行的事务清单
    </p>
    <p>
     ②这些事务最近一个日志记录的地址
    </p>
    <p>
    </p>
    <p>
     9、什么是数据库中的死锁？如何解决死锁问题
    </p>
    <p>
     【答】：死锁即两个事务互相申请对方锁住的资源导致两个事务永远不能结束
    </p>
    <p>
     解决死锁有以下方案：
    </p>
    <p>
     (1) 一次性封锁法：一次性封锁发要求每个事务必须一次将所有要使用的数据全部加锁
    </p>
    <p>
     缺点：势必扩大封锁的范围，从而降低了系统的并发度；
    </p>
    <p>
     (2) 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。
    </p>
    <p>
     缺点；难以事先确定封锁顺序
    </p>
    <p>
    </p>
    <p>
     10、举例说明连接操作的排序-合并实现方法
    </p>
    <p>
     【答】：假设有两个表Student表和SC表，其有相同属性列Sno表示学生学号
    </p>
    <p>
     步骤如下：
    </p>
    <p>
     ①如果连接的表没有排好序，首先对Student表和SC表按连接属性Sno排序
    </p>
    <p>
     ②取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组，把它们连接起来
    </p>
    <p>
     ③当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来。
    </p>
    <p>
     ④重复以上步骤直到Student表扫描完
    </p>
    <p>
     <img alt="" class="has" height="192" src="https://i-blog.csdnimg.cn/blog_migrate/f4a82624f09b58b0e5d4ad2b842b1b59.png" width="428"/>
    </p>
    <p>
     11、在学习了关系数据库以后，你觉得它主要的好处是什么？它又有哪些缺陷导致它无法胜任某些应用？
    </p>
    <p>
     【答】：好处：①对现实事务中的关系描述很清晰 ②数据定义语言和数据操作语言语义化程度较好 ③便于数据库设计的规范化
    </p>
    <ol>
     <li>
      保持数据的一致性；
     </li>
     <li>
      由于以标准为前提，数据更新的开销小（相同的字段基本都是只有一处）；
     </li>
     <li>
      存在很多实际成果和专业技术信息（成熟的技术）；
     </li>
     <li>
      容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；
     </li>
     <li>
      使用方便：通用的SQL语言使得操作关系型数据库非常方便，可以进行join等复杂查询。
     </li>
    </ol>
    <p>
     缺陷：
    </p>
    <ol>
     <li>
      为了维护一致性所付出的巨大代价就是其读写性能比较差；
     </li>
     <li>
      当有数据更新的表做索引或对表结构进行变更时，性能差；
     </li>
     <li>
      对简单查询需要快速返回结果的处理；
     </li>
     <li>
      高并发读写需求；
     </li>
     <li>
      当字段不固定时，关系型数据库处理起来很麻烦；
     </li>
     <li>
      进行大量数据的写入处理时。
     </li>
    </ol>
    <p>
    </p>
    <h3 id="%E5%BA%94%E7%94%A8%E9%A2%98">
     应用题
    </h3>
    <p>
     设有关系模式如下：S(Sno, Sname, Age, Sex), SC(Sno, Cno, Grade), C(Cno, Cname, Teacher)。其中 S 表示学生，C 表示课程，SC 表示 选课。Sno 代表学号，Sname 代表学生姓名，Age 代表学生年龄， Sex 代表学生性别，Cno 代表课程号，Grade 代表成绩，Cname 代 表课程名，Teacher 代表任课教师姓名。用 SQL 语句完成：（共 10 分）
    </p>
    <p>
     1、查询平均成绩大于 85 分的学生的姓名及其平均成绩（5 分）。
    </p>
    <p>
     2、把三个表的查询和插入权限授予用户张明，并允许张明进一步 把这些权限授予其他用户（5 分）。
    </p>
    <p>
     【解析】：
    </p>
    <p>
     1.
    </p>
    <p>
     SELECT Sname, AVG(Grade) FROM
    </p>
    <p>
     (SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade
    </p>
    <p>
     FROM Student, SC
    </p>
    <p>
     WHERE Student.Sno = SC.Sno); /* 自然连接 */
    </p>
    <p>
     GROUP BY Sname HAVING AVG(Grade) &gt; 85
    </p>
    <p>
    </p>
    <p>
     2.授权
    </p>
    <p>
     GRANT SELECT, INSERT
    </p>
    <p>
     ON TABLE S,SC,C
    </p>
    <p>
     TO ZHANGMING
    </p>
    <p>
     WITH GRANT OPTION
    </p>
    <p>
    </p>
    <p>
     2、设关系模式 R（A，B，C，D，E），F 是 R 上成立的依赖集，F={ AB→C，BC→A，AC →B，D→E }，试写出 R 的所有候选码，并说明理由。
    </p>
    <p>
     【解析】：（A,B,D）（A,C,D）（B,C,D）
    </p>
    <p>
    </p>
    <p>
     3、设有关系 R(W, X, Y, Z)，依赖关系 F={X→Z，WX→Y}，判断该关系模式符合第几范式，并说明理由。
    </p>
    <p>
     【解析】：因为其存在非主属性部分依赖于码
     <img alt="" class="has" height="28" src="https://i-blog.csdnimg.cn/blog_migrate/a33e29b984dc5238610c51df38c219cb.png" width="231"/>
     ，所以其符合第一范式
    </p>
    <p>
    </p>
    <p>
     4、在数据库系统中有如下一个调度 S，它涉及到 5 个不同的事务 T1、T2、T3、T4 和 T5。 判断调度 S 是否为冲突可串行化。如果调度 S 是冲突可串行化的，就请给出与之等价的一 个串行调度序列。
    </p>
    <p>
     <img alt="" class="has" height="317" src="https://i-blog.csdnimg.cn/blog_migrate/f6390f713d6b8e9b7cdb4e51293b957b.png" width="359"/>
    </p>
    <p>
     【解析】：目前的调度为
    </p>
    <p>
     S = r2(A) r1(Q) r5(C) w1(Q) r4(A) w2(Q) w1(B) r3(Q) r3(M) r4(Q) r4(M) r5(M) w5(M)
    </p>
    <p>
     冲突操作是指不同的事务对同一个数据的读写操作和写写操作：
    </p>
    <p>
     Ri (x)与Wj(x) /* 事务Ti读x，Tj写x，其中i≠j*/
    </p>
    <p>
     Wi(x)与Wj(x) /* 事务Ti写x，Tj写x，其中i≠j*/
    </p>
    <p>
     不能交换(Swap)的动作：
    </p>
    <ul>
     <li>
      同一事务的两个操作
     </li>
     <li>
      不同事务的冲突操作
     </li>
    </ul>
    <p>
     S能否交换为一个串行化的调度？
    </p>
    <p>
     其可以交换为T1T2T3T4T5（具体过程略）
    </p>
    <p>
     序列：r1(Q)w1(Q)w1(B)………
    </p>
    <p>
    </p>
    <p>
     6、在查询优化的代数优化方法中，你认为哪条启发式规则是最重要的？为什么？请举例 说明。
    </p>
    <p>
     【解析】：选择运算应尽可能先做。这在优化策略中是最重要、最基本的一条，因为选择运算一般使计算的中间结果大大变小
    </p>
    <p>
     <img alt="" class="has" height="209" src="https://i-blog.csdnimg.cn/blog_migrate/af69329507d56536fefd5f27084f53fe.png" width="554"/>
    </p>
    <p>
     如图，先选择之后再做连接操作可以减小数据量
    </p>
    <p>
     SELECT Sname FROM Student, SC
    </p>
    <p>
     WHERE Student.Sno = SC.Sno AND Cno = ‘2’
    </p>
    <p>
    </p>
    <p>
    </p>
    <div>
     <div>
     </div>
    </div>
    原址链接https://blog.csdn.net/qq_37205708/article/details/94194465?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


<p class="artid" style="display:none">68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353539313034342f:61727469636c652f64657461696c732f313036333530363830</p>
