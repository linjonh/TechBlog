---
layout: post
title: "java多线程和队列实例"
date: 2021-02-16 12:14:47 +0800
description: "java多线程和队列实例_java队列和线程池例子"
keywords: "java队列和线程池例子"
categories: ['Java']
tags: ['队列', '线程池', '多线程', 'Java']
artid: "51566632"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51566632
    alt: "java多线程和队列实例"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java多线程和队列实例
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     第一步：创建一个无边界自动回收的线程池，在此用 JDK提供的ExecutorService类
    </p>
    <p>
    </p>
    <p>
     此线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
    </p>
    <br/>
    <p>
    </p>
    <pre><code class="language-java">package com.thread.test;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPool {
	private static ExecutorService threadPool = null;
	public static ExecutorService getThreadPool(){
		if(threadPool==null){
			threadPool = Executors.newCachedThreadPool();
		}
		return 	threadPool;
	}

}</code></pre>
    <br/>
    <p>
     第二步：使用单例模式创建一个无界队列，并提供入队的方法
    </p>
    <p>
     <span style="padding:0px; margin:0px; font-family:'Microsoft YaHei',Verdana,sans-serif,SimSun; font-size:14px; line-height:22px; text-indent:28.1333px">
      <span style="padding:0px; margin:0px; font-family:宋体">
       无界队列。
      </span>
     </span>
     <span style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:宋体">
      使用无界队列（例如，不具有预定义容量的
     </span>
     <span lang="EN-US" style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:'Courier New'">
      LinkedBlockingQueue
     </span>
     <span style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:宋体">
      ）将导致在所有
     </span>
     <span lang="EN-US" style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:'Courier New'">
      corePoolSize
     </span>
     <span style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:宋体">
      线程都忙时新任务在队列中等待。这样，
      <span style="padding:0px; margin:0px; color:red">
       创建的线程就不会超过
      </span>
     </span>
     <span lang="EN-US" style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:'Courier New'; color:red">
      corePoolSize
     </span>
     <span style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:宋体">
      。（因此，
     </span>
     <span lang="EN-US" style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:'Courier New'">
      maximumPoolSize
     </span>
     <span style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:宋体">
      的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在
     </span>
     <span lang="EN-US" style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:'Courier New'">
      Web
     </span>
     <span style="padding:0px; margin:0px; font-size:14px; line-height:22px; text-indent:28.1333px; font-family:宋体">
      页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。
     </span>
     <br/>
    </p>
    <p>
    </p>
    <pre><code class="language-java">package com.thread.test;

import java.util.concurrent.LinkedBlockingQueue;

public class TaskQueue {
	private static  LinkedBlockingQueue queues = null;
	
	public static LinkedBlockingQueue getTaskQueue(){
		if(queues==null){
			queues =  new LinkedBlockingQueue();
			System.out.println("初始化 队列");
		}
		return queues;
	}
	
	public static void add(Object obj){
		if(queues==null)
			queues =  getTaskQueue();
		queues.offer(obj);
		System.out.println("-------------------------------");
		System.out.println("入队："+obj);
	}
}
</code></pre>
    <br/>
    第三步：提供一个入队的线程，实际使用中的生产者
    <p>
    </p>
    <p>
    </p>
    <pre><code class="language-java">package com.thread.test;

public class Produce implements Runnable {
	private static volatile int i=0;
	private static volatile boolean isRunning=true;

	public void run() {
		while(isRunning){
			TaskQueue.add(Integer.valueOf(i+""));
			Produce.i++;
			try {
				Thread.sleep(1*1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
	}

}
</code></pre>
    <br/>
    第四步：提供一个出队的线程，实际使用中的消费者
    <p>
    </p>
    <p>
    </p>
    <pre><code class="language-java">package com.thread.test;

public class Consumer implements Runnable {
	private static Consumer consumer;
	
	public static volatile boolean isRunning=true;
	public void run() {
		while(Thread.currentThread().isInterrupted()==false &amp;&amp; isRunning)  
        {  
			try {
				System.out.println("出队"+TaskQueue.getTaskQueue().take());
				Thread.sleep(1*1000);  
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
        }
		
	}
	public static Consumer getInstance(){
		if(consumer==null){
			consumer = new Consumer();
			System.out.println("初始化消费线程");
		}
		return consumer;
	}

}
</code></pre>
    <br/>
    第五步：启动生产消费策略
    <p>
    </p>
    <p>
    </p>
    <pre><code class="language-java">package com.thread.test;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;

public class Test {
	
	public static void main(String[] args) {
		ExecutorService threadPool = ThreadPool.getThreadPool();
		Produce consumer2 = new Produce();
		threadPool.execute(consumer2);
		Consumer consumer=Consumer.getInstance();
		threadPool.execute(consumer);
	}

}
</code></pre>
    <br/>
    <br/>
    <p>
    </p>
    <p>
     <br/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f6361695f6368696e61736f6674:2f61727469636c652f64657461696c732f3531353636363332" class_="artid" style="display:none">
 </p>
</div>


