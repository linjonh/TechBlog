---
layout: post
title: "iOS-端实现1对1音视频实时通话"
date: 2023-09-22 23:08:34 +0800
description: "同样的，当收到服务端，或对端的信令后，状态会随之发生改变。如果是视频的话，就将remoteVideo"
keywords: "ios 开发视频通话"
categories: ['']
tags: ['音视频', 'Xcode', 'Ios']
artid: "129593394"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=129593394
    alt: "iOS-端实现1对1音视频实时通话"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     iOS 端实现1对1音视频实时通话
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div class="kdocs-document">
     <h3 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       1.申请权限
      </span>
     </h3>
     <hr/>
     <p style="text-align:null;">
      首先，我们来看一下 iOS 端是如何获取访问音视频设备权限的。相比 Android 端而言，iOS端获取相关权限要容易很多。其步骤如下：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        打开项目，点击左侧目录中的项目。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        在左侧目录找到
        <span class="kdocs-bold" style="font-weight:bold;">
         info.plist
        </span>
        ，并将其打开。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        点击
        <span class="kdocs-bold" style="font-weight:bold;">
         右侧
        </span>
        看到 “+” 号的地方。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        添加 Camera 和 Microphone 访问权限。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      下面这张图更清晰的展现了申请权限的步骤：
     </p>
     <p style="text-align:null;">
     </p>
     <div class="kdocs-line-container" style="display:flex;">
      <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;">
       <div class="kdocs-img" style="padding-top:34.030685%;height:0;">
        <img src="https://i-blog.csdnimg.cn/blog_migrate/3a15d5408b899dcbeeffb643fadae437.png" style="margin-left:;display:block;width:717px;margin-top:-34.030685%;height:auto;">
        </img>
       </div>
      </div>
     </div>
     <p style="text-align:null;">
      iOS申请权限
     </p>
     <p style="text-align:null;">
      通过以上步骤，我们就将访问音视频设备的权限申请好了。申请完权限后，下面我们来看一下iOS端如何引入 WebRTC 库。
     </p>
     <h3 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       2.引入WebRTC库
      </span>
     </h3>
     <hr/>
     <p style="text-align:null;">
      在iOS端引入 WebRTC 库有两种方式：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        第一种，是通过 WebRTC 源码编译出 WebRTC 库，然后在项目中手动引入它；
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        第二种方式，是 WebRTC 官方会定期发布编译好的 WebRTC 库，我们可以使用 Pod 方式进行安装。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      在本项目中，我们使用第二种方式。
     </p>
     <p style="text-align:null;">
      使用第二种方式引入 WebRTC 库非常简单，我们只需要写个
      <span class="kdocs-bold" style="font-weight:bold;">
       Podfile
      </span>
      文件就可以了。在
      <span class="kdocs-bold" style="font-weight:bold;">
       Podfile
      </span>
      中可以指定下载 WebRTC 库的地址，以及我们要安装的库的名子。
     </p>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       Podfile
      </span>
      文件的具体格式如下:
     </p>
     <p style="text-align:left;">
      source '
      <a class="kdocs-link" href="https://github.com/CocoaPods/Specs.git'" rel="noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       https://github.com/CocoaPods/Specs.git'
      </a>
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      platform :ios,'11.0'
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      target 'WebRTC4iOS2' do
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      pod 'GoogleWebRTC'
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      end
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        source，指定了库文件从哪里下载
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        platform，指定了使用的平台及平台版本
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        target，指定项目的名子
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        pod，指定要安装的库
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      有了 Podfile 之后，在当前目录下执行 pod install 命令，这样 Pod 工具就可以将 WebRTC 库从源上来载下来。
     </p>
     <p style="text-align:null;">
      在执行 pod install 之后，它除了下载库文件之外，会为我们产生一个新的工作空间文件，即
      <span class="kdocs-bold" style="font-weight:bold;">
       {project}.xcworkspace
      </span>
      。在该文件里，会同时加载项目文件及刚才安装好的 Pod 依赖库，并使两者建立好关联。
     </p>
     <p style="text-align:null;">
      这样，WebRTC库就算引入成功了。下面就可以开始写我们自己的代码了。
     </p>
     <h3 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       3.获取本地视频
      </span>
     </h3>
     <hr/>
     <p style="text-align:null;">
      WebRTC 库引入成功之后，我们就可以开始真正的 WebRTC 之旅了。下面，我们来看一下如何获取本地视频并将其展示出来。
     </p>
     <p style="text-align:null;">
      在获取视频之前，我们首先要选择使用哪个视频设备采集数据。在WebRTC中，我们可以通过
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCCameraVideoCapture
      </span>
      类获取所有的视频设备。如下所示：
     </p>
     <p style="text-align:left;">
      NSArray&lt;AVCaptureDevice*&gt;* devices = [RTCCameraVideoCapture captureDevices];
     </p>
     <p style="text-align:left;">
      AVCaptureDevice* device = devices[0];
     </p>
     <p style="text-align:null;">
      通过上面两行代码，我们就拿到了视频设备中的第一个设备。简单吧！
     </p>
     <p style="text-align:null;">
      当然，光有设备还不行。我们还要清楚从设备中采集的数据放到哪里了，这样我们才能将其展示出来。
     </p>
     <p style="text-align:null;">
      WebRTC 为我们提供了一个专门的类，即
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCVideoSource
      </span>
      。它有两层含义：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        一是表明它是一个视频
        <span class="kdocs-bold" style="font-weight:bold;">
         源
        </span>
        。当我们要展示视频的时候，就从这里获取数据；
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        另一方面，它也是一个
        <span class="kdocs-bold" style="font-weight:bold;">
         终点
        </span>
        。即，当我们从视频设备采集到视频数据时，要交给它暂存起来。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      除此之外，为了能更方便的控制视频设备，WebRTC 提供了一个专门用于操作设备的类，即
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCCameraVideoCapture
      </span>
      。通过它，我们就可以自如的控制视频设备了。
     </p>
     <p style="text-align:null;">
      通过上面介绍的两个类，以及前面介绍的
      <span class="kdocs-bold" style="font-weight:bold;">
       AVCaptureDevice
      </span>
      ，我们就可以轻松的将视频数据采集出来了。下面我们就来具体看一下代码吧！
     </p>
     <p style="text-align:null;">
      在该代码中，首先将
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCVideoSource
      </span>
      与
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCCameraVideoCapture
      </span>
      进行绑定，然后再开启设备，这样视频数据就源源不断的被采集到
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCVideoSource
      </span>
      中了。
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      RTCVideoSource* videoSource = [factory videoSource];
     </p>
     <p style="text-align:left;">
      capture = [[RTCCameraVideoCapturer alloc] initWithDelegate:videoSource];
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      [capture startCaptureWithDevice:device
     </p>
     <p style="text-align:left;">
      format:format
     </p>
     <p style="text-align:left;">
      fps:fps];
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      通过上面的几行代码就可以从摄像头捕获视频数据了。
     </p>
     <p style="text-align:null;">
      这里有一点需要特别强调一下，就是
      <span class="kdocs-bold" style="font-weight:bold;">
       factory
      </span>
      对象。在 WebRTC Native 层，
      <span class="kdocs-bold" style="font-weight:bold;">
       factory
      </span>
      可以说是
      <span class="kdocs-bold" style="font-weight:bold;">
       “万物的根源”
      </span>
      ，像 RTCVideoSource、RTCVideoTrack、RTCPeerConnection 这些类型的对象，都需要通过
      <span class="kdocs-bold" style="font-weight:bold;">
       factory
      </span>
      来创建。 那么，
      <span class="kdocs-bold" style="font-weight:bold;">
       factory
      </span>
      对象又是如何创建出来的呢？
     </p>
     <p style="text-align:null;">
      通过下面的代码你就可以一知究竟了：
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      [RTCPeerConnectionFactory initialize];
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      //如果点对点工厂为空
     </p>
     <p style="text-align:left;">
      if (!factory)
     </p>
     <p style="text-align:left;">
      {
      <!-- -->
     </p>
     <p style="text-align:left;">
      RTCDefaultVideoDecoderFactory* decoderFactory = [[RTCDefaultVideoDecoderFactory alloc] init];
     </p>
     <p style="text-align:left;">
      RTCDefaultVideoEncoderFactory* encoderFactory = [[RTCDefaultVideoEncoderFactory alloc] init];
     </p>
     <p style="text-align:left;">
      NSArray* codecs = [encoderFactory supportedCodecs];
     </p>
     <p style="text-align:left;">
      [encoderFactory setPreferredCodec:codecs[2]];
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      factory = [[RTCPeerConnectionFactory alloc] initWithEncoderFactory: encoderFactory
     </p>
     <p style="text-align:left;">
      decoderFactory: decoderFactory];
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      在上面代码中，
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        首先要调用 RTCPeerConnectionFactory 类的 initialize 方法进行初始化；
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        然后创建
        <span class="kdocs-bold" style="font-weight:bold;">
         factory
        </span>
        对象。需要注意的是，在创建
        <span class="kdocs-bold" style="font-weight:bold;">
         factory
        </span>
        对象时，传入了两个参数：一个是默认的编码器；一个是默认的解码器。我们可以通过修改这两个参数来达到使用不同编解码器的目的。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      有了
      <span class="kdocs-bold" style="font-weight:bold;">
       factory
      </span>
      对象后，我们就可以开始创建其它对象了。那么，紧接下来的问题就是如何将采集到的视频展示出来了。
     </p>
     <p style="text-align:null;">
      在iOS端展示本地视频与Android端还是有很大区别的，这主要是由于不同系统底层实现方式不一样。为了更高效的展示本地视频，它们采用了不同的方式。
     </p>
     <p style="text-align:null;">
      在iOS端展示本地视频其实非常的简单，只需要在调用 capture 的
      <span class="kdocs-bold" style="font-weight:bold;">
       startCaptureWithDevice
      </span>
      方法之前执行下面的语句就好了：
     </p>
     <p style="text-align:left;">
      self.localVideoView.captureSession = capture.captureSession;
     </p>
     <p style="text-align:null;">
      当然，在iOS页面初始化的时候，一定要记得定义
      <span class="kdocs-bold" style="font-weight:bold;">
       localVideoView
      </span>
      哟，其类型为
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCCameraPreviewView
      </span>
      ！
     </p>
     <p style="text-align:null;">
      通过上面的步骤，我们就可以看到视频设备采集到的视频图像了。
     </p>
     <h3 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       4.信令驱动
      </span>
     </h3>
     <hr/>
     <p style="text-align:null;">
      上面我们介绍了iOS端权限的申请，WebRTC库的引入，以及本地视频的采集与展示，这些功能实现起来都很简单。但接下来我们要介绍的信令就要复杂一些了。
     </p>
     <p style="text-align:null;">
      在任何系统中，都可以说信令是系统的灵魂。例如，由谁来发起呼叫；媒体协商时，什么时间发哪种
      <span class="kdocs-bold" style="font-weight:bold;">
       SDP
      </span>
      都是由信令控制的。
     </p>
     <p style="text-align:null;">
      对于本项目来说，它的信令相对还是比较简单，它包括下面几种信令：
     </p>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       客户端命令
      </span>
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        join，用户加入房间
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        leave，用户离开房间
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        message，端到端命令（offer、answer、candidate）
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       服务端命令
      </span>
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        joined，用户已加入
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        leaved，用户已离开
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        other_joined，其它用户已加入
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        bye，其它用户已离开
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        full，房间已满
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      这些信令之间是怎样一种关系？在什么情况下该发送怎样的信令呢？要回答这个问题我们就要看一下信令状态机了。
     </p>
     <h4 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       4.1信令状态机
      </span>
     </h4>
     <p style="text-align:null;">
      在 iOS 端的信令与我们之前介绍的 js端 和 Android 端一样，会通过一个信令状态机来管理。在不同的状态下，需要发不同的信令。同样的，当收到服务端，或对端的信令后，状态会随之发生改变。下面我们来看一下这个状态的变化图吧：
     </p>
     <p style="text-align:null;">
     </p>
     <div class="kdocs-line-container" style="display:flex;">
      <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;">
       <div class="kdocs-img" style="padding-top:78.10321%;height:0;">
        <img src="https://i-blog.csdnimg.cn/blog_migrate/532a940f81225f052d19c679b8ee6736.jpeg" style="margin-left:;display:block;width:717px;margin-top:-78.10321%;height:auto;">
        </img>
       </div>
      </div>
     </div>
     <p style="text-align:null;">
      信令状态机
     </p>
     <p style="text-align:null;">
      在初始时，客户端处于 init/leaved 状态。
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        在 init/leaved 状态下，用户只能发送
        <span class="kdocs-bold" style="font-weight:bold;">
         join
        </span>
        消息。服务端收到
        <span class="kdocs-bold" style="font-weight:bold;">
         join
        </span>
        消息后，会返回
        <span class="kdocs-bold" style="font-weight:bold;">
         joined
        </span>
        消息。此时，客户端会更新为
        <span class="kdocs-bold" style="font-weight:bold;">
         joined
        </span>
        状态。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        在
        <span class="kdocs-bold" style="font-weight:bold;">
         joined
        </span>
        状态下，客户端有多种选择，收到不同的消息会切到不同的状态:
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:2.8em;list-style-type:circle;text-indent:0;">
       <p>
        如果用户离开房间，那客户端又回到了初始状态，即 init/leaved 状态。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:2.8em;list-style-type:circle;text-indent:0;">
       <p>
        如果客户端收到
        <span class="kdocs-bold" style="font-weight:bold;">
         second user join
        </span>
        消息，则切换到
        <span class="kdocs-bold" style="font-weight:bold;">
         join_conn
        </span>
        状态。在这种状态下，两个用户就可以进行通话了。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:2.8em;list-style-type:circle;text-indent:0;">
       <p>
        如果客户端收到
        <span class="kdocs-bold" style="font-weight:bold;">
         second user leave
        </span>
        消息，则切换到
        <span class="kdocs-bold" style="font-weight:bold;">
         join_unbind
        </span>
        状态。其实
        <span class="kdocs-bold" style="font-weight:bold;">
         join_unbind
        </span>
        状态与
        <span class="kdocs-bold" style="font-weight:bold;">
         joined
        </span>
        状态基本是一致的。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        如果客户端处于
        <span class="kdocs-bold" style="font-weight:bold;">
         join_conn
        </span>
        状态，当它收到
        <span class="kdocs-bold" style="font-weight:bold;">
         second user leave
        </span>
        消息时，也会转成
        <span class="kdocs-bold" style="font-weight:bold;">
         joined_unbind
        </span>
        状态。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        如果客户端是
        <span class="kdocs-bold" style="font-weight:bold;">
         joined_unbind
        </span>
        状态，当它收到
        <span class="kdocs-bold" style="font-weight:bold;">
         second user join
        </span>
        消息时，会切到
        <span class="kdocs-bold" style="font-weight:bold;">
         join_conn
        </span>
        状态。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      通过上面的状态图，我们就非常清楚的知道了在什么状态下应该发什么信令；或者说，发什么样的信令，状态会发生怎样的变化了。
     </p>
     <h4 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       4.2引入
      </span>
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       <span class="kdocs-bold" style="font-weight:bold;">
        http://socket.io
       </span>
      </a>
      <span class="kdocs-bold" style="font-weight:bold;">
       库
      </span>
     </h4>
     <p style="text-align:null;">
      看过我之前文章的同学应该都清楚，无论是在 js端，还是在 Android 端的实时通话中，我一直使用
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      库作为信令的基础库。之所以选择
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      是基于以下原因：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        一方面是由于它支持跨平台，这样在各个平台上我们都可以保持相同的逻辑；
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        另一方面，
        <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
         http://socket.io
        </a>
        使用简单，功能又非常强大；
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      不过，在 iOS 端的
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      是用
      <span class="kdocs-bold" style="font-weight:bold;">
       swift
      </span>
      语言实现的，而我们的1对1系统则是用 Object-C 实现的。那么，就带来一个问题，在 OC (Object-C) 里是否可以直接使用 swift 编写的库呢？
     </p>
     <p style="text-align:null;">
      答案是肯定的。我们只需要在 Podfile 中 增加 use_frameworks! 指令即可。 所以，我们的 Podfile 现在应该变成这个样子：
     </p>
     <p style="text-align:left;">
      source '
      <a class="kdocs-link" href="https://github.com/CocoaPods/Specs.git'" rel="noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       https://github.com/CocoaPods/Specs.git'
      </a>
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      platform :ios,'11.0'
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      use_frameworks!
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      target 'WebRTC4iOS2' do
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      pod 'Socket.IO-Client-Swift', '~&gt; 13.3.0'
     </p>
     <p style="text-align:left;">
      pod 'GoogleWebRTC'
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      end
     </p>
     <p style="text-align:null;">
      上面 Podfile 中，每行的含义大家应该都很清楚了，我这里就不做过多讲解了。
     </p>
     <h3 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       5.信令的使用
      </span>
     </h3>
     <hr/>
     <p style="text-align:null;">
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       <span class="kdocs-bold" style="font-weight:bold;">
        http://socket.io
       </span>
      </a>
      库引入成功后，下面我们来看一下何使用
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      。在 iOS 下，使用
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      分为三步：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        通过 url 获取 socket。有了 socket 之后我们就可建立与服务器的连接了。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        注册侦听的消息，并为每个侦听的消息绑定一个处理函数。当收到服务器的消息后，随之会触发绑定的函数。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        通过 socket 建立连接。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        发送消息。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      下我们我们就逐一的看它们是如何实现的吧！
     </p>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       获取 socket
      </span>
     </p>
     <p style="text-align:null;">
      在 iOS 中获取 socket 其实很简单，我们来看一下代码：
     </p>
     <p style="text-align:left;">
      NSURL*url= [[NSURLalloc] initWithString:addr];
     </p>
     <p style="text-align:left;">
      manager= [[SocketManageralloc] initWithSocketURL:url
     </p>
     <p style="text-align:left;">
      config:@{
      <!-- -->
     </p>
     <p style="text-align:left;">
      @"log": @YES,
     </p>
     <p style="text-align:left;">
      @"forcePolling":@YES,
     </p>
     <p style="text-align:left;">
      @"forceWebsockets":@YES
     </p>
     <p style="text-align:left;">
      }];
     </p>
     <p style="text-align:left;">
      socket=manager.defaultSocket;
     </p>
     <p style="text-align:null;">
      没错，通过这三行代码就可以了。至于为什么这么写我就不解释了，大家记下来就好了。这是
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      的固定格式。
     </p>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       注册侦听消息
      </span>
     </p>
     <p style="text-align:null;">
      使用
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      注册一个侦听消息也非常容易，如下所示：
     </p>
     <p style="text-align:left;">
      [socket on:@"joined" callback:^(NSArray * data, SocketAckEmitter * ack) {
      <!-- -->
     </p>
     <p style="text-align:left;">
      NSString* room = [data objectAtIndex:0];
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      NSLog(@"joined room(%@)", room);
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      [self.delegate joined:room];
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      }];
     </p>
     <p style="text-align:null;">
      上面就是注册一个
      <span class="kdocs-bold" style="font-weight:bold;">
       joined
      </span>
      消息，并给它绑定一个匿名的处理函数。如果带来的消息还有参数的话，我们可以从 data 这个数组中获取到。
     </p>
     <p style="text-align:null;">
      同样的道理，如果我们想注册一个新的侦听消息，可以按着上面的格式，只需将
      <span class="kdocs-bold" style="font-weight:bold;">
       joined
      </span>
      替换一下就可以了。
     </p>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       建立连接
      </span>
      这个就更简单了，下接上代码了：
     </p>
     <p style="text-align:left;">
      [socketconnect];
     </p>
     <p style="text-align:null;">
      没错，只这一句连接就建好了哈！
     </p>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       发送消息
      </span>
      接下来，让我们看一下如何使用
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      发送消息。
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      if(socket.status == SocketIOStatusConnected){
      <!-- -->
     </p>
     <p style="text-align:left;">
      [socketemit:@"join"with:@[room]];
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      使用
      <span class="kdocs-bold" style="font-weight:bold;">
       emit
      </span>
      方法发送消息。它可以带一些参数，这些参数都被放在一个数据里。在上面的代码中，首先要判断socket是否已经处理连接状态，只有处于连接状态时，消息才能被真正发送出去。
     </p>
     <p style="text-align:null;">
      以上就是
      <a class="kdocs-link" href="https://link.zhihu.com/?target=http%3A//socket.io" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       http://socket.io
      </a>
      的使用，是不是非常的简单？
     </p>
     <h3 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       6.创建 RTCPeerConnection
      </span>
     </h3>
     <hr/>
     <p style="text-align:null;">
      信令系统建立好后，后面的逻辑都是围绕着信令系统建立起来的。
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCPeerConnection
      </span>
      对象的建立也不例外。
     </p>
     <p style="text-align:null;">
      在客户端，用户要想与远端通话，首先要发送
      <span class="kdocs-bold" style="font-weight:bold;">
       join
      </span>
      消息，也就是要先进入房间。此时，如果服务器判定用户是合法的，则会给客户端回
      <span class="kdocs-bold" style="font-weight:bold;">
       joined
      </span>
      消息。
     </p>
     <p style="text-align:null;">
      客户端收到
      <span class="kdocs-bold" style="font-weight:bold;">
       joined
      </span>
      消息后，就要创建 RTCPeerConnection 了，也就是要建立一条与远端通话的音视频数据传输通道。
     </p>
     <p style="text-align:null;">
      下面，我们就来看一下 RTCPeerConnection 是如何建立的：
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      if (!ICEServers) {
      <!-- -->
     </p>
     <p style="text-align:left;">
      ICEServers = [NSMutableArray array];
     </p>
     <p style="text-align:left;">
      [ICEServers addObject:[self defaultSTUNServer]];
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      RTCConfiguration* configuration = [[RTCConfiguration alloc] init];
     </p>
     <p style="text-align:left;">
      [configuration setIceServers:ICEServers];
     </p>
     <p style="text-align:left;">
      RTCPeerConnection* conn = [factory
     </p>
     <p style="text-align:left;">
      peerConnectionWithConfiguration:configuration
     </p>
     <p style="text-align:left;">
      constraints:[self defaultPeerConnContraints]
     </p>
     <p style="text-align:left;">
      delegate:self];
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      对于 iOS 的
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCPeerConnection
      </span>
      对象有三个参数：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        第一个，是 RTCConfiguration 类型的对象，该对象中最重要的一个字段是
        <span class="kdocs-bold" style="font-weight:bold;">
         iceservers
        </span>
        。它里边存放了 stun/turn 服务器地址。其主要作用是用于NAT穿越。对于 NAT 穿越的知识大家可以看
        <a class="kdocs-link" href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fcoding.imooc.com%2Fclass%2F329.html" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
         《WebRTC实时互动直播技术入门与实战》
        </a>
        ，这门课里对其原理做了说细阐述。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        第二个参数，是 RTCMediaConstraints 类型对象，也就是对 RTCPeerConnection 的限制。如，是否接收视频数据？是否接收音频数据？如果要与浏览器互通还要开启
        <span class="kdocs-bold" style="font-weight:bold;">
         DtlsSrtpKeyAgreement
        </span>
        选项。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        第三个参数，是
        <span class="kdocs-bold" style="font-weight:bold;">
         委拖
        </span>
        类型。相当于给 RTCPeerConnection 设置一个
        <span class="kdocs-bold" style="font-weight:bold;">
         观察者
        </span>
        。这样RTCPeerConnection 可以将一个状态/信息通过它通知给
        <span class="kdocs-bold" style="font-weight:bold;">
         观察者
        </span>
        。但它并不属于
        <span class="kdocs-bold" style="font-weight:bold;">
         观察者
        </span>
        模式，这一点大家一定要清楚。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCPeerConnection
      </span>
      对象创建好后，接下来我们介绍的是整个实时通话过程中，最重要的一部分知识，那就是
      <span class="kdocs-bold" style="font-weight:bold;">
       媒体协商
      </span>
      。
     </p>
     <h4 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       6.1媒体协商
      </span>
     </h4>
     <p style="text-align:null;">
      首先，我们要知道媒体协商内容使用是 SDP 协议，不了解这部分知识的同学可以看
      <a class="kdocs-link" href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%3A%2F%2Fcoding.imooc.com%2Fclass%2F329.html" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       《WebRTC实时互动直播技术入门与实战》
      </a>
      这门课，在门课里对其做了详细讲解。
     </p>
     <p style="text-align:null;">
      其次，我们要清楚整体媒体协商的过程。
     </p>
     <p style="text-align:null;">
      iOS 端的媒体协商过程与 Android/JS 端是一模一样的。还是下面这个经典的图:
     </p>
     <p style="text-align:null;">
     </p>
     <div class="kdocs-line-container" style="display:flex;">
      <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:717px;justify-content:center;align-items:center;height:auto;">
       <div class="kdocs-img" style="padding-top:40.167366%;height:0;">
        <img src="https://i-blog.csdnimg.cn/blog_migrate/fddf332a18760a4c72e069cc6735f075.png" style="margin-left:;display:block;width:717px;margin-top:-40.167366%;height:auto;">
        </img>
       </div>
      </div>
     </div>
     <p style="text-align:null;">
      媒体协商
     </p>
     <p style="text-align:null;">
      A 与 B 进行通话，通话的发起方，首先要创建
      <span class="kdocs-bold" style="font-weight:bold;">
       Offer
      </span>
      类型的 SDP 内容。之后调用 RTCPeerConnection 对象的
      <span class="kdocs-bold" style="font-weight:bold;">
       setLocalDescription
      </span>
      方法，将
      <span class="kdocs-bold" style="font-weight:bold;">
       Offer
      </span>
      保存到本地。
     </p>
     <p style="text-align:null;">
      紧接着，将
      <span class="kdocs-bold" style="font-weight:bold;">
       Offer
      </span>
      发送给服务器。然后，通过信令服务器中转到被呼叫方。被呼叫方收到
      <span class="kdocs-bold" style="font-weight:bold;">
       Offer
      </span>
      后，调用它的 RTCPeerConnection 对象的
      <span class="kdocs-bold" style="font-weight:bold;">
       setRemoteDescription
      </span>
      方法，将远端的
      <span class="kdocs-bold" style="font-weight:bold;">
       Offer
      </span>
      保存起来。
     </p>
     <p style="text-align:null;">
      之后，被呼到方创建
      <span class="kdocs-bold" style="font-weight:bold;">
       Answer
      </span>
      类型的 SDP 内容，并调用 RTCPeerConnection 对象的
      <span class="kdocs-bold" style="font-weight:bold;">
       setLocalDescription
      </span>
      方法将它存储到本地。
     </p>
     <p style="text-align:null;">
      同样的，它也要将
      <span class="kdocs-bold" style="font-weight:bold;">
       Answer
      </span>
      发送给服务器。服务器收到该消息后，不做任何处理，直接中转给呼叫方。呼叫方收到
      <span class="kdocs-bold" style="font-weight:bold;">
       Answer
      </span>
      后，调用
      <span class="kdocs-bold" style="font-weight:bold;">
       setRemoteDescription
      </span>
      将其保存起来。
     </p>
     <p style="text-align:null;">
      通过上面的步骤，整个
      <span class="kdocs-bold" style="font-weight:bold;">
       媒体协商
      </span>
      部分就完成了。
     </p>
     <p style="text-align:null;">
      下面我们就具体看看，在 iOS 端是如何实现这个逻辑的：
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      ​
     </p>
     <p style="text-align:left;">
      [peerConnection offerForConstraints:[self defaultPeerConnContraints]
     </p>
     <p style="text-align:left;">
      completionHandler:^(RTCSessionDescription * _Nullable sdp, NSError * _Nullable error) {
      <!-- -->
     </p>
     <p style="text-align:left;">
      if(error){
      <!-- -->
     </p>
     <p style="text-align:left;">
      NSLog(@"Failed to create offer SDP, err=%@", error);
     </p>
     <p style="text-align:left;">
      } else {
      <!-- -->
     </p>
     <p style="text-align:left;">
      __weak RTCPeerConnection* weakPeerConnction = self-&gt;peerConnection;
     </p>
     <p style="text-align:left;">
      [self setLocalOffer: weakPeerConnction withSdp: sdp];
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
      }];
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      在iOS端使用 RTCPeerConnection 对象的
      <span class="kdocs-bold" style="font-weight:bold;">
       offerForConstraints
      </span>
      方法创建
      <span class="kdocs-bold" style="font-weight:bold;">
       Offer
      </span>
      SDP。它有两个参数：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        一个是 RTCMediaConstraints 类型的参数，该参数我们在前面创建 RTCPeerConnection 对象时介绍过，这里不在赘述。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        另一个参数是一个匿名回调函数。可以通过对
        <span class="kdocs-bold" style="font-weight:bold;">
         error
        </span>
        是否为空来判定
        <span class="kdocs-bold" style="font-weight:bold;">
         offerForConstraints
        </span>
        方法有没有执行成功。如果执行成功了，参数
        <span class="kdocs-bold" style="font-weight:bold;">
         sdp
        </span>
        就是创建好的 SDP 内容。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      如果成功获得了
      <span class="kdocs-bold" style="font-weight:bold;">
       sdp
      </span>
      ，按照之前的处理流程描述，我们首先要将它只存到本地；然后再将它发送给他务器，服务器中转给另一端。
     </p>
     <p style="text-align:null;">
      我们的代码也是严格按照这个过程来的。在上面代码中
      <span class="kdocs-bold" style="font-weight:bold;">
       setLocalOffer
      </span>
      方法就是做这件事儿。具体代码如下：
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      [pc setLocalDescription:sdp completionHandler:^(NSError * _Nullable error) {
      <!-- -->
     </p>
     <p style="text-align:left;">
      if (!error) {
      <!-- -->
     </p>
     <p style="text-align:left;">
      NSLog(@"Successed to set local offer sdp!");
     </p>
     <p style="text-align:left;">
      }else{
      <!-- -->
     </p>
     <p style="text-align:left;">
      NSLog(@"Failed to set local offer sdp, err=%@", error);
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
      }];
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      __weak NSString* weakMyRoom = myRoom;
     </p>
     <p style="text-align:left;">
      dispatch_async(dispatch_get_main_queue(), ^{
      <!-- -->
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      NSDictionary* dict = [[NSDictionary alloc] initWithObjects:@[@"offer", sdp.sdp]
     </p>
     <p style="text-align:left;">
      forKeys: @[@"type", @"sdp"]];
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      [[SignalClient getInstance] sendMessage: weakMyRoom
     </p>
     <p style="text-align:left;">
      withMsg: dict];
     </p>
     <p style="text-align:left;">
      });
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      从上面的代码可以清楚的看出，它做了两件事儿。一是调用
      <span class="kdocs-bold" style="font-weight:bold;">
       setLocalDescription
      </span>
      方法将 sdp 保存到本地；另一件事儿就是发送消息；
     </p>
     <p style="text-align:null;">
      所以，通过上面的描述大家也就知道后面的所有逻辑了。这里我们就不一一展开来讲了。
     </p>
     <p style="text-align:null;">
      当整个协商完成之后，紧接着，在WebRTC底层就会进行音视频数据的传输。如果远端的视频数据到达本地后，我们就需要将它展示到界面上。这又是如何做到的呢？
     </p>
     <h4 style="text-align:left;">
      <span class="kdocs-bold" style="font-weight:bold;">
       6.2渲染远端视频
      </span>
     </h4>
     <p style="text-align:null;">
      大家是否还记得，在我们创建 RTCPeerConnection 对象时，同时给RTCPeerConnection设置了一个
      <span class="kdocs-bold" style="font-weight:bold;">
       委拖
      </span>
      ，在我们的项目中就是
      <span class="kdocs-bold" style="font-weight:bold;">
       CallViewController
      </span>
      对象。在该对象中我们实现了所有
      <span class="kdocs-bold" style="font-weight:bold;">
       RTCPeerConnection
      </span>
      对象的代理方法。其中比较关键的有下面几个：
     </p>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        (void)peerConnection:(RTCPeerConnection *)peerConnectiondidGenerateIceCandidate:(RTCIceCandidate *)candidate；该方法用于收集可用的 Candidate。
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        (void)peerConnection:(RTCPeerConnection *)peerConnectiondidChangeIceConnectionState:(RTCIceConnectionState)newState；当 ICE 连接状态发生变化时会触发该方法
       </p>
      </li>
     </ul>
     <ul>
      <li style="margin-left:1.4em;list-style-type:disc;text-indent:0;">
       <p>
        (void)peerConnection:(RTCPeerConnection *)peerConnectiondidAddReceiver:(RTCRtpReceiver *)rtpReceiverstreams:(NSArray&lt;RTCMediaStream *&gt; *)mediaStreams；该方法在侦听到远端 track 时会触发。
       </p>
      </li>
     </ul>
     <p style="text-align:null;">
      那么，什么时候开始渲染远端视频呢？当有远端视频流过来的时候，就会触发 (void)peerConnection:(RTCPeerConnection *)peerConnectiondidAddReceiver:(RTCRtpReceiver *)rtpReceiverstreams:(NSArray&lt;RTCMediaStream *&gt; *)mediaStreams 方法。所以我们只需要在该方法中写一些逻辑即可。
     </p>
     <p style="text-align:null;">
      当上面的函数被调用后，我们可以通过
      <span class="kdocs-bold" style="font-weight:bold;">
       rtpReceiver
      </span>
      参数获取到
      <span class="kdocs-bold" style="font-weight:bold;">
       track
      </span>
      。这个track有可能是音频trak，也有可能是视频trak。所以，我们首先要对 track 做个判断，看其是视频还是音频。
     </p>
     <p style="text-align:null;">
      如果是视频的话，就将remoteVideoView加入到trak中，相当于给track添加了一个观察者，这样remoteVideoView就可以从track获取到视频数据了。在
      <span class="kdocs-bold" style="font-weight:bold;">
       remoteVideoView
      </span>
      实现了渲染方法，一量收到数据就会直接进行渲染。最终，我们就可以看到远端的视频了。
     </p>
     <p style="text-align:null;">
      具体代码如下：
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:left;">
      RTCMediaStreamTrack* track = rtpReceiver.track;
     </p>
     <p style="text-align:left;">
      if([track.kind isEqualToString:kRTCMediaStreamTrackKindVideo]){
      <!-- -->
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      if(!self.remoteVideoView){
      <!-- -->
     </p>
     <p style="text-align:left;">
      NSLog(@"error:remoteVideoView have not been created!");
     </p>
     <p style="text-align:left;">
      return;
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      remoteVideoTrack = (RTCVideoTrack*)track;
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      [remoteVideoTrack addRenderer: self.remoteVideoView];
     </p>
     <p style="text-align:left;">
      }
     </p>
     <p style="text-align:left;">
     </p>
     <p style="text-align:left;">
      ...
     </p>
     <p style="text-align:null;">
      通过上面的代码，我们就可以将远端传来的视频展示出来了。
     </p>
     <p style="text-align:null;">
      原文
      <a class="kdocs-link" href="https://zhuanlan.zhihu.com/p/65448600" rel="nofollow noopener noreferrer" style="color:#0A6CFF;" target="_blank">
       https://zhuanlan.zhihu.com/p/65448600
      </a>
     </p>
     <p style="text-align:left;">
      <span class="kdocs-color" style="color:#C21C13;">
       <span class="kdocs-bold" style="font-weight:bold;">
        ★文末名片可以免费领取音视频开发学习资料，内容包括（FFmpeg ，webRTC ，rtmp ，hls ，rtsp ，ffplay ，srs）以及音视频学习路线图等等。
       </span>
      </span>
     </p>
     <p style="text-align:left;">
      <span class="kdocs-color" style="color:#C21C13;">
       <span class="kdocs-bold" style="font-weight:bold;">
        见下方!↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
       </span>
      </span>
     </p>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f79696e73686970696e3030372f:61727469636c652f64657461696c732f313239353933333934" class_="artid" style="display:none">
 </p>
</div>


