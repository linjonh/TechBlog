---
layout: post
title: "密码安全之密码技术1置换密码"
date: 2024-02-18 21:31:40 +0800
description: "密码学是一门研究设计密码算法和破译密码算法的综合性技术科学，是网络空间安全学科中理论体系最完善的一门"
keywords: "置换密码例题"
categories: ['Security', 'Password']
tags: ['Security', 'Replacement', 'Password', 'Password', 'Cryptography', 'Classical']
artid: "100624315"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=100624315
    alt: "密码安全之密码技术1置换密码"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     密码安全之密码技术【1】置换密码
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     密码学
    </h3>
    <p>
     一门研究设计密码算法和破译密码算法的综合性技术科学，是网络空间安全学科中理论体系最完善的一门科学，也是信息安全的基石。密码学通常由密码编码和密码分析两大分支组成。
    </p>
    <p>
     从密码学的发展历史来看，可以分为
     <strong>
      古典密码学
     </strong>
     和
     <strong>
      现代密码学
     </strong>
     。
    </p>
    <pre><code>古典密码学
</code></pre>
    <p>
     主要依靠人工计算和简单的机械，并且以人的主观意识来设计和应用。古典加密算法往往只是对单个的代替或置换操作。
    </p>
    <p>
     现代密码学…
    </p>
    <ol>
     <li>
      置换密码
     </li>
    </ol>
    <p>
     置换密码就是把明文中的字母或数字重新排列，字母或数字本身不变，但其位置发生了改变，示例如下：
    </p>
    <pre><code>明文：this is transposition cipher
密文：rehp ic noitisopsnart sisiht
</code></pre>
    <p>
     本例是一种直接将明文按倒序排列的简单置换加密算法，可被直接分析，进一步将明文按一定顺序排成一个矩阵，然后按置换规则的顺序选出矩阵中的字母序列，最后按固定长度读取字母即形成密文。
    </p>
    <pre><code>原始明文：this is transposition cipher
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bfea571ad43ad636b792c8144015b3a9.png">
      <br/>
      置换规则：按列读取
     </img>
    </p>
    <pre><code>形成密文：tiao ii rhsnsopitsinh srptce
</code></pre>
    <p>
     由此看出改变矩阵的大小和置换规则可以得到不同形式的密码，通常我们先选定一个词语作为密钥，去掉重复字母然后按字典顺序给密钥字母一个数字编号，就可以得到一组与密钥对应的数字序列，最后以此序列作为置换规则选出密文。
    </p>
    <pre><code>明文：this is transposition cipher
词语密钥：password
</code></pre>
    <p>
     根据词语密钥得到数字序列为：4167352
     <br/>
     排成矩阵:
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/39a7393ec9f850825c238bd3c539f690.png">
      <br/>
      根据序列得到密文：ssor tr ipsoctsiiniei pnhath
     </img>
    </p>
    <p>
     置换密码是一种通过变换矩阵大小选出的顺序组合，而密钥仅仅是便于记忆，因此，置换密码比较简单，经不起穷举攻击（穷举攻击无视顺序），但可以把此种方法与其他密码结合可以得到相对安全且高效的密码。
     <br/>
     .
     <br/>
     .
     <br/>
     .
     <br/>
     然后我用c++实现了加密的过程【望指正！！！】
    </p>
    <pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
int main() {
	cout &lt;&lt; "Enter the characters you need to encrypt and the key:";
	string characters,key;
	cin &gt;&gt; characters &gt;&gt; key;
	int len_c = characters.length();
	int len_k = key.length();
	int row = len_c / len_k + 1;
	int column = len_k;
	if (len_c != 0 &amp;&amp; len_k != 0) {
		vector&lt;char&gt; matrix;
		for (int i = 0; i &lt; len_c; i++) {
			char *p_c = &amp;characters[0];
			if (p_c != " ") {
				matrix.push_back(*p_c);
			}
			p_c++;
		}
		//De - weighting and sort
		set&lt;char&gt; digital_sequence;
		char *p_k = &amp;key[0];
		for (int j = 0; j &lt; len_k; j++,p_k++)
			digital_sequence.insert(*p_k);
		//Build key - value pairs
		map&lt;char, int&gt; encrypt;
		int key_temp = 1;
		for (int k = 0; k &lt; len_k; k++, key_temp++)
			encrypt.insert(pair&lt;char, int&gt;(digital_sequence.count[k],key_temp));
		string encrypt_result;
		for (char it : key) {
			int column_part = encrypt.at(it);
			for (int row_part = 0; row_part &lt; row; row_part++) {
				if (matrix[column_part - 1 + row_part * column] != NULL)
					encrypt_result += matrix[column_part - 1 + row_part * column];
			}
		}
		cout &lt;&lt; "Encrypted character:" &lt;&lt; encrypt_result &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "Possible input may be incorrect, please re-enter^_^";
	}
	return 0;
}
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f526f6b6f426173696c69736b2f:61727469636c652f64657461696c732f313030363234333135" class_="artid" style="display:none">
 </p>
</div>


