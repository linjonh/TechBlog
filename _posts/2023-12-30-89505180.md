---
layout: post
title: "课堂笔记数据库系统概论第5版-第7章数据库设计"
date: 2023-12-30 20:52:56 +0800
description: "7.1 数据库设计概述在数据库领域内，广义的讲，数据库设计是数据库及其应用系统的设计；狭义的讲，数据"
keywords: "对初步e-r图进行修改和重构时,可以利用()消除不必要的冗余,生成基本e-r图。a."
categories: ['数据库系统概论第5版']
tags: ['数据库系统概论', '数据库']
artid: "89505180"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=89505180
    alt: "课堂笔记数据库系统概论第5版-第7章数据库设计"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【课堂笔记】《数据库系统概论（第5版）》-第7章：数据库设计
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="71__0">
     </a>
     7.1 数据库设计概述
    </h3>
    <p>
     在数据库领域内，通常把使用数据库的各类信息系统都称为数据库应用系统。
    </p>
    <p>
     广义的讲，数据库设计是数据库及其应用系统的设计；
    </p>
    <p>
     狭义的讲，数据库设计是设计数据库本身，即：设计数据库的各级模式并建立数据库。
    </p>
    <p>
     <strong>
      数据库设计的一般定义
     </strong>
     ：
    </p>
    <p>
     对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，并据此建立数据库及其应用系统，使之能够有效的储存和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。
    </p>
    <p>
     <strong>
      数据库设计的目的
     </strong>
     是为用户和各种应用系统提供一个信息基础设施和高效的运行环境；高效的运行环境是指数据库数据的存取效率、数据库存储空间的利用率、数据库系统运行管理的效率。
    </p>
    <h4>
     <a id="711__14">
     </a>
     7.1.1 数据库设计的特点
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        数据库建设的基本规律
       </strong>
      </p>
      <p>
       <strong>
        三分技术、七分管理、十二分基础数据
       </strong>
      </p>
      <p>
       这里的管理不仅包括数据库建设作为一个大型项目工程项目本身的项目管理，还包括该企业的业务管理。
      </p>
      <p>
       十二分基础数据则强调了数据的收集、整理、组织和不断更新是数据库建设过程中的重要环节。
      </p>
     </li>
     <li>
      <p>
       <strong>
        结构设计和行为设计相结合
       </strong>
      </p>
      <p>
       传统的结构和行为分离的设计：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2cfeb46f3427f0d1da24335ec91ce7a6.jpeg"/>
      </p>
     </li>
    </ol>
    <h4>
     <a id="712__29">
     </a>
     7.1.2 数据库设计方法
    </h4>
    <p>
     从事数据库设计的专业人员需要具备多方面的知识，主要包括：
    </p>
    <ul>
     <li>
      计算机的基础知识
     </li>
     <li>
      软件工程的原理和方法
     </li>
     <li>
      程序设计的方法和技巧
     </li>
     <li>
      数据库的基本知识
     </li>
     <li>
      数据库设计技术
     </li>
     <li>
      应用领域的知识
     </li>
    </ul>
    <p>
     早期数据库设计主要采用手工与经验相结合的方法，设计质量往往与设计人员的经验和水平有直接的关系。
    </p>
    <p>
     为此，人们努力探索，提出了各种数据库设计方法，例如新奥尔良方法（emm…），基于E-R模型的设计方法，3NF设计方法、统一建模语言方法等。
    </p>
    <h4>
     <a id="713__44">
     </a>
     7.1.3 数据库设计的基本步骤
    </h4>
    <p>
     数据库设计分为以下6个阶段：
    </p>
    <ul>
     <li>
      需求分析
     </li>
     <li>
      概念结构设计
     </li>
     <li>
      逻辑结构设计
     </li>
     <li>
      物理结构设计
     </li>
     <li>
      数据库实施
     </li>
     <li>
      数据库运行和维护
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/aac651f3ca03eae709e4310938789d39.jpeg"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ecfe097f280fdac12a3a8fe8e327ae0c.jpeg"/>
    </p>
    <h4>
     <a id="714__59">
     </a>
     7.1.4 数据库设计过程中的各级模式
    </h4>
    <p>
     数据库设计的不同阶段形成数据库的各级模式：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c3584d1da14513fff58f733ecd29ca8c.jpeg"/>
    </p>
    <h3>
     <a id="72__65">
     </a>
     7.2 需求分析
    </h3>
    <p>
     需求分析是数据库设计的起点，需求分析结果是否准确反映用户的实际要求将直接影响到后续各个阶段的设计，并影响到设计结果是否合理和实用。
    </p>
    <h4>
     <a id="721__69">
     </a>
     7.2.1 需求分析的任务
    </h4>
    <p>
     需求分析的任务是：通过详细调查显示世界需要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或是计算机系统）的工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能；
    </p>
    <p>
     新系统必须充分考虑今后可能的扩充和改变，不能仅仅按当前的应用需求来设计数据库。
    </p>
    <p>
     <strong>
      调查的重点是数据和处理，通过调查收集与分析，获得用户对数据库的如下要求
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       信息要求：
      </p>
      <p>
       用户需要从数据库中获得的信息的内容与性质
      </p>
     </li>
     <li>
      <p>
       处理要求：
      </p>
      <p>
       用户需要完成的数据处理功能，以及对于处理性能的要求
      </p>
     </li>
     <li>
      <p>
       安全性与完整性要求
      </p>
     </li>
    </ol>
    <p>
     <em>
      确定用户最终需求是一件很困难的事情，一方面用户缺少计算机知识，另一方面设计人员缺少用户的专业知识（真实）。
     </em>
    </p>
    <h4>
     <a id="722__89">
     </a>
     7.2.2 需求分析的方法
    </h4>
    <p>
     <strong>
      调查用户需求的具体步骤
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       调查组织机构情况：
      </p>
      <p>
       了解组织的部门组成情况、各部门的职责等等，为分析信息流程做准备。
      </p>
     </li>
     <li>
      <p>
       调查各部门的业务活动情况
      </p>
      <p>
       了解各部门使用和输入什么数据，如何加工处理这些数据，输出何种信息到何种部门，输出何种格式的信息等。
      </p>
     </li>
     <li>
      <p>
       在熟悉业务活动的基础上，协助用户明确对信系统的各种要求，其中包括信息要求、处理要求、安全性与完整性要求等。
      </p>
     </li>
     <li>
      <p>
       确定新系统的边界，即哪些任务由计算机完成，哪些任务由人工完成
      </p>
     </li>
    </ol>
    <p>
     <strong>
      常用的调查方法
     </strong>
     ：
    </p>
    <ol>
     <li>
      跟班作业
     </li>
     <li>
      开调查会
     </li>
     <li>
      请专人介绍
     </li>
     <li>
      询问
     </li>
     <li>
      设计调查表请用户填写
     </li>
     <li>
      查阅记录：与原系统有关的记录
     </li>
    </ol>
    <p>
     在调查了用户的需求之后，还需要进一步
     <strong>
      分析和表达用户的需求
     </strong>
     ，在众多的分析方法中，结构化分析（SA）方法是一种简单实用的方法。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ff82e17002eaf29ea258b5708de0fe3c.jpeg"/>
    </p>
    <h4>
     <a id="723__118">
     </a>
     7.2.3 数据字典
    </h4>
    <p>
     数据字典是关于
     <strong>
      数据库中数据的描述，即元数据，而不是数据的本身
     </strong>
     。
    </p>
    <p>
     数据字典在需求分析阶段建立，在数据库设计过程中不断的修改充实和完善。
    </p>
    <p>
     数据字典通常包括数据项、数据结构、数据流、数据存储和处理过程。
    </p>
    <p>
     数据项是数据的最小组成单位；
    </p>
    <p>
     若干个数据项组成一个数据结构；
    </p>
    <p>
     数据字典通过对数据项和数据结构的定义来描述数据流、数据储存的逻辑内容。
    </p>
    <ol>
     <li>
      <p>
       数据项
      </p>
      <p>
       数据项是不可再分的数据单位
      </p>
      <pre><code>数据项描述 = {
    数据项名，
    数据项含义说明，
    别名，
    数据类型，
    长度，
    取值范围，
    取值含义，
    与其他数据项的逻辑关系，
    数据项之间的联系，
}
</code></pre>
      <p>
       其中，
       <strong>
        取值范围
       </strong>
       和
       <strong>
        与其他数据项的逻辑关系
       </strong>
       定义了数据的
       <strong>
        完整性约束条件
       </strong>
       ，是设计数据检验功能的依据。
      </p>
      <p>
       用数据依赖的概念分析和表示数据项之间的联系，即按实际语义写出每个数据项之间的数据依赖，他们是数据库逻辑设计阶段数据模型优化的依据。
      </p>
     </li>
     <li>
      <p>
       数据结构
      </p>
      <p>
       数据结构反映了数据之间的组合关系；
      </p>
      <p>
       一个数据结构可以由若干个数据项或其他数据结构组合而成。
      </p>
      <pre><code>数据结构描述 = {
    数据结构名，
    含义说明，
    组成：{
        数据项或数据结构
    }
}
</code></pre>
     </li>
     <li>
      <p>
       数据流
      </p>
      <p>
       数据流是数据结构在系统内传输的路径；
      </p>
      <pre><code>数据流描述 = {
    数据流名，
    说明，
    数据流来源，
    数据流去向，
    组成： {
        数据结构，
    }，
    平均流量，
    高峰期流量，
}
</code></pre>
     </li>
     <li>
      <p>
       数据存储
      </p>
      <p>
       数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一，它可以是手工文档或者手工凭单，也可以是计算机文档。
      </p>
      <pre><code>数据存储描述 = {
    数据存储名，
    说明，
    编号，
    输入的数据流，
    输出的数据流，
    组成： {
        数据结构，
    }，
    数据量，
    存取频度，
    存取方式，
}
</code></pre>
      <p>
       其中，存取方式是指批处理还是联机处理，是检索还是更新，是顺序检索还是随即检索等。
      </p>
     </li>
     <li>
      <p>
       处理过程
      </p>
      <p>
       处理过程的具体处理逻辑一般用判定表或者是判定树来描述，数据字典中只需要描述处理过程的说明性信息即可。
      </p>
      <pre><code>处理过程描述 = {
    处理过程名，
    说明，
    输入： {数据流}，
    输出： {数据流}，
    处理： {简要说明}，
}
</code></pre>
      <p>
       其中，
       <strong>
        简要说明
       </strong>
       主要说明该处理过程的功能以及处理要求；
      </p>
      <p>
       功能是指该处理过程用来做什么；
      </p>
      <p>
       处理要求指的是处理频度要求；
      </p>
     </li>
    </ol>
    <p>
     <strong>
      最后强调两点
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       需求分析阶段的一个重要而又困难的任务是：收集将来应用所涉及的数据，设计人员应充分考虑到可能的扩充和改变，使设计易于更改、系统易于扩充。
      </p>
     </li>
     <li>
      <p>
       必须强调用户的参与，这是数据库应用系统设计的特点。
      </p>
     </li>
    </ol>
    <h3>
     <a id="73__236">
     </a>
     7.3 概念结构设计
    </h3>
    <p>
     将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计。
    </p>
    <h4>
     <a id="731__240">
     </a>
     7.3.1 概念模型
    </h4>
    <p>
     <strong>
      概念模型的主要特点是
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       能够真实的、充分的反映现实世界，包括事物与事物之间的联系，能够满足用户对数据的处理要求，是现实世界的一个真实模型。
      </p>
     </li>
     <li>
      <p>
       易于理解，可以用它和不熟悉计算机的用户交换意见。
      </p>
     </li>
     <li>
      <p>
       易于更改。
      </p>
     </li>
     <li>
      <p>
       易于向关系、网状、层次等各种数据模型转换。
      </p>
     </li>
    </ol>
    <p>
     描述概念模型的有力工具是
     <strong>
      E-R模型
     </strong>
     。
    </p>
    <h4>
     <a id="732_ER_254">
     </a>
     7.3.2 E-R模型
    </h4>
    <p>
     E-R模型是用E-R图来描述现实世界的概念模型，包括实体、属性、实体之间的联系等等。
    </p>
    <ol>
     <li>
      <p>
       实体之间的联系：
      </p>
      <p>
       在现实世界中，事物内部以及事物之间是有联系的，实体内部的联系通常是指组成实体的各属性之间的联系，实体之间的联系通常是指不同实体类型的实体集之间的联系。
      </p>
      <ol>
       <li>
        <p>
         两个实体型之间的联系
        </p>
        <ol>
         <li>
          <p>
           一对一联系
          </p>
          <p>
           比如一个班长对应一个班级，一个班级只有一个班长。
          </p>
         </li>
         <li>
          <p>
           一对多联系
          </p>
          <p>
           比如一个班级中有多名学生，一个学生只有一个班级。
          </p>
         </li>
         <li>
          <p>
           多对多联系
          </p>
          <p>
           例如一个学生可以选修多门课程，一门课程可以有多个学生选修。
          </p>
         </li>
        </ol>
        <p>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/12e58ee1af062dff5a09dee5fcb1d7ae.jpeg"/>
        </p>
       </li>
       <li>
        <p>
         两个以上的实体型之间的联系
        </p>
        <p>
         一般的，两个以上的实体型之间也存在着一对一、一对多、多对多的联系。
        </p>
        <p>
         例如，一门课有若干个老师讲授，一个老师讲一门课，一门课又有多本参考书。
        </p>
        <p>
         再例如，一个供应商提供多种零件，一个零件可由不同的供应商提供，一个项目可能需要不同供应商的不同零件。
        </p>
        <p>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/11f08c3e42b87b4b47e9f60d191fa148.jpeg"/>
        </p>
       </li>
       <li>
        <p>
         单个实体型内部的联系
        </p>
        <p>
         同一个实体集内部也可以存在一对一、一对多、多对多的联系。
        </p>
        <p>
         例如，在职工实体型内部同时具有领导和被领导的联系。
        </p>
       </li>
      </ol>
      <p>
       一般的，把参与联系的实体型的数目称为
       <strong>
        联系的度
       </strong>
       ，两个实体型之间的联系度为2，也称为
       <strong>
        二元联系
       </strong>
       ，同理，有三元联系、N元联系。
      </p>
     </li>
     <li>
      <p>
       <strong>
        E-R图
       </strong>
      </p>
      <p>
       <strong>
        E-R图提供了表示实体型、属性和联系的方法
       </strong>
      </p>
      <ol>
       <li>
        实体型用矩形表示
       </li>
       <li>
        属性用椭圆形表示
       </li>
       <li>
        联系用菱形表示（注明1:1、1:n、m:n）
        <br/>
        <em>
         如果一个联系具有属性，这些属性也要用无向边与该联系连接起来。
        </em>
       </li>
      </ol>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/43eaecce7bf13cf6587094f78e2bec3c.jpeg"/>
      </p>
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f5223acef4fc3d5042f0f671d9a5e972.jpeg"/>
    </p>
    <ol start="3">
     <li>
      <p>
       一个实例
      </p>
      <ul>
       <li>
        仓库：属性有仓库号、面积、电话号码；
       </li>
       <li>
        零件：属性有零件号、名称、规格、单价、描述
       </li>
       <li>
        供应商：属性有供应商号、姓名、地址、电话号码、账号
       </li>
       <li>
        项目：属性有项目号、预算、开工日期
       </li>
       <li>
        职工：属性有职工号、姓名、年龄、值称
       </li>
      </ul>
      <p>
       仓库和零件之间是多对多的联系；
      </p>
      <p>
       职工和仓库是一对多的关系；
      </p>
      <p>
       职工实体型中有一对多的关系（领导与被领导）；
      </p>
      <p>
       供应商、项目、零件之间有多对多的联系；
      </p>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b33c8275c023ea3094db73f18903f2d5.jpeg"/>
      </p>
     </li>
    </ol>
    <h4>
     <a id="735__329">
     </a>
     7.3.5 概念结构设计
    </h4>
    <p>
     本节介绍在设计E-R图的过程中，如何让确定实体与属性，以及在集成E-R图时如何让解决冲突等关键技术。
    </p>
    <p>
     <strong>
      概念结构设计的第一步是
     </strong>
     对需求分析阶段收集到的数据进行分类、组织，确定实体、实体的属性、实体之间联系的类型，形成E-R图。
    </p>
    <ol>
     <li>
      <p>
       实体与属性的划分原则
      </p>
      <p>
       一条基本原则：
       <strong>
        为了简化E-R图的处置，现实世界的事物能作为属性对待的尽量作为属性对待。
       </strong>
      </p>
      <p>
       满足下面两个条件的事物可以作为属性对待：
      </p>
      <ol>
       <li>
        作为属性，不能再拥有需要描述的性质（即属性必须是不可分的数据项，不能包含其他属性）；
       </li>
       <li>
        属性不能与其他实体具有联系；
       </li>
      </ol>
      <p>
       举例：
      </p>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/61b3330fb351793114ff7bc9519e2c9f.jpeg"/>
      </p>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/dc3852bf8f45ffa18cf2e3ad022357b8.jpeg"/>
      </p>
     </li>
     <li>
      <p>
       E-R图的集成
      </p>
      <p>
       在开发一个大型的系统时，首先设计各分系统的ER图，然后将他们集成起来，得到全局ER图，ER图的集成一般需要分两步走：
      </p>
      <ul>
       <li>
        合并，解决各分ER图的冲突，将分ER图合并起来形成初步的ER图。
       </li>
       <li>
        修改和重构，消除不必要的冗余，生成基本ER图。
       </li>
      </ul>
      <ol>
       <li>
        <p>
         合并ER图，生成初步ER图：
        </p>
        <p>
         各个子系统的ER图会存在一些不一致的地方，称之为
         <strong>
          冲突
         </strong>
         ，合并ER图的过程中要消除这些冲突。
        </p>
        <p>
         各个子系统之间的ER图的冲突主要有三类：
         <strong>
          属性冲突、命名冲突、结构冲突
         </strong>
         。
        </p>
        <ol>
         <li>
          <p>
           属性冲突主要包含以下两类：
          </p>
          <ol>
           <li>
            属性域冲突，即属性的值的类型，或者取值范围取值集合不同；
           </li>
           <li>
            属性取值单位冲突；
           </li>
          </ol>
         </li>
         <li>
          <p>
           命名冲突主要包含以下两类：
          </p>
          <ol>
           <li>
            同名异义：不同意义的对象再不同的局部应用中具有相同的名字；
           </li>
           <li>
            异名同义：同一意义的对象再不同的局部应用中具有不同的名字；
           </li>
          </ol>
          <p>
           命名冲突可能发生在实体、联系一级上，也可能发生在属性一级上。
          </p>
         </li>
         <li>
          <p>
           结构冲突
          </p>
          <p>
           结构冲突主要包含以下三类冲突：
          </p>
          <ol>
           <li>
            <p>
             同一个对象在不同的应用中具有不同的抽象，例如职工在某一局部应用中被当作实体，而在另一局部应用中被当作属性。
            </p>
           </li>
           <li>
            <p>
             同一实体在不同子系统的ER图中所包含的属性个数和属性排列次序不完全相同；这种冲突产生的原因是不同的局部应用关心实体的不同侧面，解决方案是取属性的并集在调整属性的次序。
            </p>
           </li>
           <li>
            <p>
             实体之间的联系类型在不同的ER图中为不同的类型。
            </p>
           </li>
          </ol>
         </li>
        </ol>
       </li>
       <li>
        <p>
         消除不必要的冗余，设计基本ER图
        </p>
        <p>
         在初步ER图中可能会存在一些
         <strong>
          冗余的数据和实体之间冗余的联系
         </strong>
         ，冗余的数据指的是可以由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。冗余数据和冗余联系容易破坏数据库的完整性，给数据库维护增加困难，
         <strong>
          消除的冗余后的初步ER图被称为基本ER图
         </strong>
         。
        </p>
        <p>
         消除冗余数据主要采用分析的方法，即
         <strong>
          以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余
         </strong>
         。
        </p>
        <p>
         不过，并不是所有的冗余数据和冗余联系都必须加以消除，有时为了提高效率，不得不以冗余信息作为代价。
        </p>
        <p>
         如果认为的保留了一些冗余数据，则应该把数据字典中数据关联的说明作为完整性约束条件。
        </p>
        <p>
         除了使用分析的方法之外，还可以利用
         <strong>
          规范化理论
         </strong>
         来消除冗余，在规范化理论中，函数依赖的概念提供了消除冗余联系的形式化工具，具体方法如下：
        </p>
        <ul>
         <li>
          确定分ER图实体之间的数据依赖，实体之间的联系可以用实体码之间的函数依赖来表示，于是就可以求得函数依赖集
          <span class="katex--inline">
           <span class="katex">
            <span class="katex-mathml">
             F 
              
             
               L 
              
             
            
           
             F_L
            </span>
            <span class="katex-html">
             <span class="base">
              <span class="strut" style="height: 0.83333em; vertical-align: -0.15em;">
              </span>
              <span class="mord">
               <span class="mord mathit" style="margin-right: 0.13889em;">
                F
               </span>
               <span class="msupsub">
                <span class="vlist-t vlist-t2">
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.328331em;">
                   <span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;">
                    <span class="pstrut" style="height: 2.7em;">
                    </span>
                    <span class="sizing reset-size6 size3 mtight">
                     <span class="mord mathit mtight">
                      L
                     </span>
                    </span>
                   </span>
                  </span>
                  <span class="vlist-s">
                   ​
                  </span>
                 </span>
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.15em;">
                   <span class="">
                   </span>
                  </span>
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
          。
         </li>
         <li>
          求得
          <span class="katex--inline">
           <span class="katex">
            <span class="katex-mathml">
             F 
              
             
               L 
              
             
            
           
             F_L
            </span>
            <span class="katex-html">
             <span class="base">
              <span class="strut" style="height: 0.83333em; vertical-align: -0.15em;">
              </span>
              <span class="mord">
               <span class="mord mathit" style="margin-right: 0.13889em;">
                F
               </span>
               <span class="msupsub">
                <span class="vlist-t vlist-t2">
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.328331em;">
                   <span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;">
                    <span class="pstrut" style="height: 2.7em;">
                    </span>
                    <span class="sizing reset-size6 size3 mtight">
                     <span class="mord mathit mtight">
                      L
                     </span>
                    </span>
                   </span>
                  </span>
                  <span class="vlist-s">
                   ​
                  </span>
                 </span>
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.15em;">
                   <span class="">
                   </span>
                  </span>
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
          的最小覆盖
          <span class="katex--inline">
           <span class="katex">
            <span class="katex-mathml">
             G 
              
             
               L 
              
             
            
           
             G_L
            </span>
            <span class="katex-html">
             <span class="base">
              <span class="strut" style="height: 0.83333em; vertical-align: -0.15em;">
              </span>
              <span class="mord">
               <span class="mord mathit">
                G
               </span>
               <span class="msupsub">
                <span class="vlist-t vlist-t2">
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.328331em;">
                   <span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;">
                    <span class="pstrut" style="height: 2.7em;">
                    </span>
                    <span class="sizing reset-size6 size3 mtight">
                     <span class="mord mathit mtight">
                      L
                     </span>
                    </span>
                   </span>
                  </span>
                  <span class="vlist-s">
                   ​
                  </span>
                 </span>
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.15em;">
                   <span class="">
                   </span>
                  </span>
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
          ，差集为
          <span class="katex--inline">
           <span class="katex">
            <span class="katex-mathml">
             D 
             
            
              = 
             
             
             
               F 
              
             
               L 
              
             
            
              − 
             
             
             
               G 
              
             
               L 
              
             
            
           
             D = F_L - G_L
            </span>
            <span class="katex-html">
             <span class="base">
              <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
              </span>
              <span class="mord mathit" style="margin-right: 0.02778em;">
               D
              </span>
              <span class="mspace" style="margin-right: 0.277778em;">
              </span>
              <span class="mrel">
               =
              </span>
              <span class="mspace" style="margin-right: 0.277778em;">
              </span>
             </span>
             <span class="base">
              <span class="strut" style="height: 0.83333em; vertical-align: -0.15em;">
              </span>
              <span class="mord">
               <span class="mord mathit" style="margin-right: 0.13889em;">
                F
               </span>
               <span class="msupsub">
                <span class="vlist-t vlist-t2">
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.328331em;">
                   <span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;">
                    <span class="pstrut" style="height: 2.7em;">
                    </span>
                    <span class="sizing reset-size6 size3 mtight">
                     <span class="mord mathit mtight">
                      L
                     </span>
                    </span>
                   </span>
                  </span>
                  <span class="vlist-s">
                   ​
                  </span>
                 </span>
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.15em;">
                   <span class="">
                   </span>
                  </span>
                 </span>
                </span>
               </span>
              </span>
              <span class="mspace" style="margin-right: 0.222222em;">
              </span>
              <span class="mbin">
               −
              </span>
              <span class="mspace" style="margin-right: 0.222222em;">
              </span>
             </span>
             <span class="base">
              <span class="strut" style="height: 0.83333em; vertical-align: -0.15em;">
              </span>
              <span class="mord">
               <span class="mord mathit">
                G
               </span>
               <span class="msupsub">
                <span class="vlist-t vlist-t2">
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.328331em;">
                   <span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;">
                    <span class="pstrut" style="height: 2.7em;">
                    </span>
                    <span class="sizing reset-size6 size3 mtight">
                     <span class="mord mathit mtight">
                      L
                     </span>
                    </span>
                   </span>
                  </span>
                  <span class="vlist-s">
                   ​
                  </span>
                 </span>
                 <span class="vlist-r">
                  <span class="vlist" style="height: 0.15em;">
                   <span class="">
                   </span>
                  </span>
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
          ，逐一考察
          <span class="katex--inline">
           <span class="katex">
            <span class="katex-mathml">
             D 
             
            
           
             D
            </span>
            <span class="katex-html">
             <span class="base">
              <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
              </span>
              <span class="mord mathit" style="margin-right: 0.02778em;">
               D
              </span>
             </span>
            </span>
           </span>
          </span>
          中的函数依赖，确定是否是冗余的联系，如果是，就将其去掉。
         </li>
        </ul>
       </li>
      </ol>
     </li>
    </ol>
    <h3>
     <a id="74__400">
     </a>
     7.4 逻辑结构设计
    </h3>
    <p>
     <strong>
      逻辑结构设计的任务是把概念结构设计阶段设计好的基本ER图转化为与选用的数据库管理系统产品所支持的数据模型相符合的逻辑结构
     </strong>
     。
    </p>
    <h4>
     <a id="741_ER_404">
     </a>
     7.4.1 E-R图向关系模型的转换
    </h4>
    <p>
     需要解决的问题是，如何将实体型和实体型之间的联系转换为关系模式，如何确定这些关系模式的属性和码。
    </p>
    <p>
     对于实体型，
     <strong>
      一个实体型转换为一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码
     </strong>
     。
    </p>
    <p>
     对于实体型之间的联系有以下不同的情况：
    </p>
    <ul>
     <li>
      <p>
       一个
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          1 
          
         
           : 
          
         
           1 
          
         
        
          1:1
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
           </span>
           <span class="mord">
            1
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            :
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
           </span>
           <span class="mord">
            1
           </span>
          </span>
         </span>
        </span>
       </span>
       的联系可以转换为一个独立的关系模式，也可以与任意一端的关系模式合并。
      </p>
      <p>
       如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。
      </p>
      <p>
       如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。
      </p>
     </li>
     <li>
      <p>
       一个
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          1 
          
         
           : 
          
         
           n 
          
         
        
          1:n
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
           </span>
           <span class="mord">
            1
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            :
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
           </span>
           <span class="mord mathit">
            n
           </span>
          </span>
         </span>
        </span>
       </span>
       的关系模式可以转换为一个独立的关系模式，也可以与n段对应的关系模式合并。
      </p>
      <p>
       如果要转换为独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。
      </p>
     </li>
     <li>
      <p>
       一个
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          n 
          
         
           : 
          
         
           m 
          
         
        
          n:m
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
           </span>
           <span class="mord mathit">
            n
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            :
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
           </span>
           <span class="mord mathit">
            m
           </span>
          </span>
         </span>
        </span>
       </span>
       的联系转换为一个关系模式，与该联系相连的各实体的码和联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系的码的一部分。
      </p>
     </li>
     <li>
      <p>
       三个或三个以上的实体之间的联系可以转换为一个关系模式，属性和码的组成同上。
      </p>
     </li>
     <li>
      <p>
       <strong>
        具有相同的码的关系模式可以合并
       </strong>
      </p>
     </li>
    </ul>
    <h4>
     <a id="742__428">
     </a>
     7.4.2 数据模型的优化
    </h4>
    <p>
     <strong>
      数据库逻辑设计的结果不是唯一的
     </strong>
     ，为了提高数据库应用系统的性能，还应该根据应用适当的修改、调整数据模型的结构，这就是数据模型的优化。
    </p>
    <p>
     <strong>
      关系数据模型的优化通常以规范化理论为指导
     </strong>
     ，方法为：
    </p>
    <ol>
     <li>
      <p>
       确定数据依赖（7.2.3）
      </p>
     </li>
     <li>
      <p>
       对各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系（7.3.5）
      </p>
     </li>
     <li>
      <p>
       按照数据以来理论对关系模式逐一进行分析，考察是否存在部分函数依赖，传递函数依赖，多值依赖等，确定各个关系模式分别属于第几范式。
      </p>
     </li>
     <li>
      <p>
       根据
       <strong>
        需求分析阶段
       </strong>
       得到的处理要求分析对于这样的应用环境这些关系模式是否合适，确定是否要对某些模式进行合并或分解。
      </p>
      <p>
       需要注意的是，
       <strong>
        并不是规范化程度越高的关系就越优
       </strong>
       ，例如，当查询涉及多个关系模式的属性时，需要进行连接运算，代价是相当高的，这时候可以将经常需要连接的关系模式合并；又例如，非BCNF的关系模式虽然从理论上来京会存在不同程度的更新异常或者冗余，但是如果在实际应用中只涉及查询，不涉及更新，就不会产生影响。
      </p>
     </li>
     <li>
      <p>
       对关系模式进行必要的分解，以提高数据操作效率和数据存储效率，常用的分解方法是
       <strong>
        水平分解和垂直分解
       </strong>
       。
      </p>
      <p>
       <strong>
        水平分解
       </strong>
       是把关系的元组分为若干子集，然后为每一个子集定义一个关系。
      </p>
      <p>
       <strong>
        垂直拆分
       </strong>
       是把关系的属性分为若干子集，形成若干子关系模式。
      </p>
      <p>
       <a href="https://blog.csdn.net/qq_29842929/article/details/79771316">
        看他人博客
       </a>
      </p>
     </li>
    </ol>
    <h4>
     <a id="743__449">
     </a>
     7.4.3 设计用户子模式
    </h4>
    <p>
     将概念模型转换为全局逻辑模型后，还应该根据局部应用需求，结合具体的关系数据库管理系统的特点设计用户的外模式。
    </p>
    <p>
     主要有以下几方面：
    </p>
    <ul>
     <li>
      使用更符合用户习惯的别名
     </li>
     <li>
      可以针对不同级别的用户，定义不同的视图，以保证系统的安全性
     </li>
     <li>
      简化用户对系统的使用，如果某些局部应用中需要用到某些很复杂的查询，为了方便用户，可以将这些复杂的查询定义为视图，每次用户只需要对视图进行查询。
     </li>
    </ul>
    <h3>
     <a id="75__459">
     </a>
     7.5 物理结构设计
    </h3>
    <p>
     数据库在物理设备上的存储结构和存取方法被称为数据库的物理结构，他依赖于选定的数据库管理系统。
    </p>
    <p>
     为一个给定的逻辑数据模型选取一个最合适应用要求的物理结构的过程，就是数据库的物理设计。
    </p>
    <p>
     数据库的物理设计通常分为两步：
    </p>
    <ul>
     <li>
      确定数据库的物理结构，在关系数据库中主要是指存取方法和存储结构
     </li>
     <li>
      对物理结构进行评价，主要是时间和空间的效率
     </li>
    </ul>
    <h4>
     <a id="751__470">
     </a>
     7.5.1 数据库物理设计的方法和内容
    </h4>
    <p>
     没有通用的物理设计方法可以遵循，只能给出一般的设计内容和原则。
    </p>
    <p>
     我们希望数据库上运行的各种事物响应时间小，存储空间利用率高，事物吞吐率大。
    </p>
    <p>
     为此，首先要对运行的事务进行详细分析，获得所需参数；其次，要充分了解所用关系数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构。
    </p>
    <p>
     通常关系数据库物理设计
     <strong>
      的主要内容包括
     </strong>
     ：为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。
    </p>
    <h4>
     <a id="752__480">
     </a>
     7.5.2 关系模式存取方法的选择
    </h4>
    <p>
     数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。
    </p>
    <p>
     物理设计的任务之一就是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。
    </p>
    <p>
     存取方法是快速存取数据库中数据的技术。
    </p>
    <p>
     常用的存取方法为
     <strong>
      索引方法和聚簇方法
     </strong>
     。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        B+树索引存取方法
       </strong>
      </p>
      <ul>
       <li>
        如果一个或者一组属性经常在查询条件中出现，则考虑在这个或者这组属性上建立索引/组合索引。
       </li>
       <li>
        如果一个索引经常作为聚集函数的参数，则考虑建立索引
       </li>
       <li>
        如果一个或者一组属性经常在连接操作的连接条件中出现，则考虑建立索引
       </li>
      </ul>
      <p>
       查找、维护索引也要付出代价，因此索引并非越多越好。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Hash索引存取方法
       </strong>
      </p>
      <p>
       如果一个关系的属性主要出现在
       <strong>
        等值连接条件
       </strong>
       或者
       <strong>
        等值比较选择条件
       </strong>
       中，并且满足以下两个条件之一，就可以考虑Hash。
      </p>
      <ul>
       <li>
        一个关系的大小可以预知，而且不变
       </li>
       <li>
        关系的大小动态改变但是数据库管理系统有动态hash存取方法
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        聚簇存取方法
       </strong>
      </p>
      <p>
       为了提高某个属性或属性组的查询速度，把在这些属性上有相同值的元组集中存放在 连续的物理块中，称为
       <strong>
        聚簇
       </strong>
       ，该属性或属性组称为
       <strong>
        聚簇码
       </strong>
       。
      </p>
      <p>
       聚簇功能不但适用于单个关系，也适用于经常进行连接操作的多个关系，即将多个连接关系的元组按连接属性值聚集存放，也就相当于把多个关系按
       <em>
        预连接
       </em>
       的形式存放，从而大大提高连接操作的效率。
      </p>
      <p>
       一个数据库可以建立多个聚簇，但是一个关系只能加入一个聚簇。
      </p>
      <p>
       选择聚簇存取方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系。
      </p>
      <p>
       <strong>
        候选聚簇的条件
       </strong>
       ：
      </p>
      <ul>
       <li>
        经常在一起进行连接操作的关系。
       </li>
       <li>
        如果一个关系的一组属性经常出现在等值比较中，则该单个关系可以建立聚簇。
       </li>
       <li>
        如果一个关系的一个或者一组属性上的重复率很高，则此单个关系可以建立聚簇（换句话说，每个聚簇码值的平均元组数不能太少，否则聚簇的效果不明显）
       </li>
      </ul>
      <p>
       <strong>
        检查候选聚簇中的消息，取消其中不必要的关系
       </strong>
       ：
      </p>
      <ul>
       <li>
        删除经常进行全表扫描的关系
       </li>
       <li>
        删除更新操作远多于连接操作的关系
       </li>
       <li>
        一个关系只能在一个聚簇中，如果有多个聚簇方案，要从中选择最优的一个
       </li>
      </ul>
      <p>
       <strong>
        需要强调的是
       </strong>
       ：聚簇只能够提高某些应用的性能，而建立与维护聚簇的开销是相当大的；对已有的关系建立聚簇，将改变某些元组的物理储存位置，并使其原有的索引无效；而当一个元组的聚簇码改变时，也要做相应的物理储存位置移动。
      </p>
      <p>
       因此，当
       <strong>
        通过聚簇码进行访问或者连接
       </strong>
       是该关系的主要应用，对与聚簇码无关的访问很少或者次要时，可以使用聚簇，尤其是当SQL中包含与聚簇码有关的
       <code>
        order by, group by, union, distinct
       </code>
       等子句时，使用聚簇
       <strong>
        特别有利
       </strong>
       。
      </p>
     </li>
    </ol>
    <h4>
     <a id="753__531">
     </a>
     7.5.3 确定数据库的存储结构
    </h4>
    <p>
     确定数据库的物理结构主要指的是确定数据的存放位置和存储结构，包括确定关系，索引，日志，备份等的存储安排和存储结构，确定系统配置等。
    </p>
    <p>
     确定数据库的存放位置和存储结构要综合考虑
     <strong>
      存取时间，存储空间利用率，维护代价
     </strong>
     三方面因素，在三者之间进行权衡。
    </p>
    <ol>
     <li>
      <p>
       确定数据的存放位置
      </p>
      <p>
       为了提高应用性能，应该根据应用情况将数据的易变部分与稳定部分、经常存取的部分和存取频率较低的部分分开存放。
      </p>
     </li>
     <li>
      <p>
       确定系统配置
      </p>
      <p>
       关系数据库管理系统一般都提供了一些系统配置变量和存储分配参数（比如同时使用的用户数，同时打开的数据库的数量，缓冲区分配参数，……），供设计人员和数据库管理员对数据库进行物理优化，初始情况下，这些变量都有合理的默认值，但在进行物理设计时，应该根据应用的具体环境，重新设置这些变量，以改善系统性能。
      </p>
      <p>
       在设计阶段对系统配置变量的调整只是初步的，在系统运行时还要根据实际运行情况进行进一步调整。
      </p>
     </li>
    </ol>
    <h4>
     <a id="754__547">
     </a>
     7.5.4 评价物理结构
    </h4>
    <p>
     在数据库物理设计过程中，需要对时间效率、空间效率、维护代价（定量），以及各种用户需求进行权衡，从中可能产生多种方案，需要从中择优选择。
    </p>
    <h3>
     <a id="76__551">
     </a>
     7.6 数据库的实施和维护
    </h3>
    <p>
     完成物理结构设计，实现设计之后，就可以组织数据入库，进入实施阶段。
    </p>
    <h4>
     <a id="761__555">
     </a>
     7.6.1 数据的载入和应用程序的调试
    </h4>
    <p>
     标题是数据库实施阶段两项重要工作
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        ⇑ 
        
       
      
        \Uparrow
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;">
         </span>
         <span class="mrel">
          ⇑
         </span>
        </span>
       </span>
      </span>
     </span>
     。
    </p>
    <p>
     一般数据库系统中的数据量都很大，可能来自部门中各个不同的单位，数据的组织方式，组织结构都会与新设计的系统存在相当大的差距；因此需要抽取数据、输入计算机、分类转换的过程，这是相当费时费力的。
    </p>
    <p>
     特别是对于手工处理的纸上的数据。。。
    </p>
    <p>
     为了提高数据输入工作的效率和质量，应当针对具体的应用环境设计一个数据录入子系统，有计算机完成数据录入的任务（重要！！！）。
    </p>
    <p>
     特别的，如果就的数据存在于另一个数据库系统中，可以充分利用新旧系统提供的数据转换工具。
    </p>
    <p>
     数据库系统的设计和数据库应用程序的设计应当同时进行，因此在组织数据入库的时候还要同时进行应用程序的调试。
    </p>
    <h4>
     <a id="762__569">
     </a>
     7.6.2 数据库的试运行
    </h4>
    <p>
     在已经有一小部分数据入库之后，就可以进行数据库系统的联合调试，又称数据库的试运行。
    </p>
    <p>
     功能测试：
    </p>
    <ul>
     <li>
      实际运行数据库应用程序
     </li>
     <li>
      执行数据库的各种操作
     </li>
     <li>
      测试应用程序的功能是否满足设计要求
     </li>
    </ul>
    <p>
     性能测试：
    </p>
    <ul>
     <li>
      实际测量系统的性能指标
     </li>
    </ul>
    <p>
     如果以上测试不满足要求，则需要返回物理设计阶段甚至逻辑设计阶段。
    </p>
    <p>
     <strong>
      强调两点
     </strong>
     ：
    </p>
    <ol>
     <li>
      数据入库花费很大，应当分批进行，逐步增加数据量，逐步完成运行篇评价。
     </li>
     <li>
      试运行阶段，由于系统不稳定、操作人员不熟悉，随时有可能发生硬软件故障，因此要做好数据库的转储和恢复工作。
     </li>
    </ol>
    <h4>
     <a id="763__590">
     </a>
     7.6.3 数据库的运行和维护
    </h4>
    <p>
     试运行合格之后，数据库的开发工作就基本完成，可以投入正式运行了。
    </p>
    <p>
     不过，由于应用环境的不断变化，数据库在运行过程中物理储存也会不断变化，对数据库设计进行评价、调整、修改等维护工作是一个长期的任务，也是设计工作的继续和提高。
    </p>
    <p>
     <strong>
      数据库的维护工作主要包括一下几个方面
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       数据库的转储和恢复（
       <strong>
        vital!
       </strong>
       ）
      </p>
      <p>
       针对不同的应用要求制定不同的转储计划，保证一旦发生故障能将数据湖库恢复到某种一致的状态，并尽可能的减少破坏。
      </p>
     </li>
     <li>
      <p>
       数据库的安全性、完整性控制
      </p>
      <p>
       运行过程中，安全性要求（如密级），完整性要求会发生变化，需要管理员的不断修正。
      </p>
     </li>
     <li>
      <p>
       数据库性能的监督、分析和改造
      </p>
      <p>
       监督系统运行，分析监测数据，找出改进性能的方法；
      </p>
      <p>
       数据库管理员可以充分利用数据库管理系统提供的系统性能检测工具；
      </p>
      <p>
       仔细分析监测数据，判断当前状况是否最佳，应当进行那些改进。
      </p>
     </li>
     <li>
      <p>
       数据库的重组织与重构造
      </p>
      <p>
       数据库在运行一段时间之后，由于记录不断的增删改，会改变数据库的物理存储情况，降低存取效率，降低数据库性能；这时候管理员就应当对数据库进行重组织或部分重组织（对频繁增删改的表进行重组织）。
      </p>
      <p>
       关系数据库管理系统一般提供数据重组织的实用程序。
      </p>
      <p>
       在重组织的过程中，按原来的设计要求重新安排存储位置、回收垃圾、减少指针链等，提高性能。
      </p>
      <p>
       数据库重构指的是
       <strong>
        部分修改数据库的模式和内模式
       </strong>
       。
      </p>
      <p>
       由于数据库应用环境发生变化，增加了新的应用或者实体，取消了某些应用，某些实体与实体之间的联系也发生了变化等，使得原有的设计不能满足要求，需要调整模式和内模式。
      </p>
      <p>
       如果应用变化太大，重构也无济于事，说明该换新的了。
      </p>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f77656978696e5f3431343239393939:2f61727469636c652f64657461696c732f3839353035313830" class_="artid" style="display:none">
 </p>
</div>


