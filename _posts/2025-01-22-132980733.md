---
layout: post
title: "微信小程序登录流程包含前端后端代码"
date: 2025-01-22 12:54:54 +0800
description: "theme: channing-cyan一、前言在微信小程序的开发过程中，如果想要保留用户的数据(比"
keywords: "小程序免密登录前端"
categories: ["未分类"]
tags: ["微信小程序", "小程序", "前端"]
artid: "132980733"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=132980733
  alt: "微信小程序登录流程包含前端后端代码"
render_with_liquid: false
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     微信小程序登录流程（包含前端、后端代码）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div style="font-size: 16px;">
     <hr/>
     <h3>
      theme: channing-cyan
     </h3>
     <p>
      <img alt="cover (2).png" src="https://i-blog.csdnimg.cn/blog_migrate/1de458c1f416ee1d3c84f4af62cd9409.png" style="outline: none;"/>
     </p>
     <h2>
      一、前言
     </h2>
     <p>
      在微信小程序的开发过程中，如果想要保留
      <code>
       用户
      </code>
      的
      <code>
       数据
      </code>
      (比如：
      <code>
       操作记录
      </code>
      、
      <code>
       购物车信息
      </code>
      等等)就必须要
      <code>
       用户
      </code>
      登陆。为什么呢？比如说，数据库中有一条
      <code>
       数据
      </code>
      你如何知道这条数据属于谁？属于那个用户呢？这就需要用户登录来获取
      <code>
       用户
      </code>
      的
      <code>
       唯一标识
      </code>
      从而确定这条数据是属于哪个用户的，那么如何做微信小程序的登陆功能呢？让我们使用
      <code>
       Springboot
      </code>
      框架+
      <code>
       AOP
      </code>
      一起来学习吧！
     </p>
     <hr/>
     <h2>
      二、流程
     </h2>
     <p>
      <code>
       微信小程序登录
      </code>
      流程：
     </p>
     <p>
      <img alt="此图来自微信小程序开发文档" src="https://i-blog.csdnimg.cn/blog_migrate/108ef52978663e4a6d8d14e15d3d680a.png" style="outline: none;"/>
     </p>
     <p>
      <code>
       开发者服务器
      </code>
      处理流程：
     </p>
     <p>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c2a170ea841b431f419d240703ee0438.png" style="outline: none;"/>
     </p>
     <h3>
      1.1 获取用户
      <code>
       Code
      </code>
     </h3>
     <p>
      通过
      <code>
       wx.login
      </code>
      来获取临时登录
      <code>
       code
      </code>
      ：
     </p>
     <p>
      <code>
       javascript wx.login({ success (res) { if (res.code) { //发起网络请求 wx.request({ url: 'https://example.com/onLogin', data: { code: res.code } }) } else { console.log('登录失败！' + res.errMsg) } } })
      </code>
     </p>
     <h3>
      1.2 获取
      <code>
       appid
      </code>
     </h3>
     <p>
      在注册
      <code>
       微信开发者账
      </code>
      后，可以在
      <code>
       微信小程序管理后台
      </code>
      获取
      <code>
       appid
      </code>
      ：
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f4c76ac080af1c19e6eb7f8bad2867ec.png" style="outline: none;"/>
     </p>
     <h3>
      1.3 获取
      <code>
       appsecret
      </code>
     </h3>
     <p>
      小程序密钥同样是在注册微信开发者平台账号后，在管理后台获取的：
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/5cc1b7c6db52bcca0677ff71fa4af6a1.png" style="outline: none;">
       由于微信小程序密钥不以明文的方式展示，如果忘记了，
       <code>
        重置
       </code>
       下就可以了。
      </img>
     </p>
     <h3>
      1.4 开发者服务向微信接口服务发起请求
     </h3>
     <p>
      拿着
      <code>
       微信code
      </code>
      、
      <code>
       appid
      </code>
      、
      <code>
       appsecret
      </code>
      在
      <code>
       开发者服务器
      </code>
      去请求
      <code>
       微信接口服务
      </code>
      换取
      <code>
       openId
      </code>
      和
      <code>
       secretKey
      </code>
      (这里我们使用ApiPost工具来进行请求，当然PostMan工具也行)：
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1ca97e6a3045fa533ac0ad059121a60e.png" style="outline: none;"/>
     </p>
     <p>
      调用
      <code>
       微信接口服务
      </code>
      接口(注意是
      <code>
       Get
      </code>
      请求)：
     </p>
     <p>
      <code>
       javascript https://api.weixin.qq.com/sns/jscode2session?
      </code>
     </p>
     <h3>
      1.5 返回值
     </h3>
     <p>
      <code>
       java { "session_key": "xxxxx", "openid": "xxxxx" }
      </code>
     </p>
     <p>
      拿到返回值后，应该
      <code>
       入库
      </code>
      ，保存一下。 数据库结构如下：
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/14685e78ed6d5be19254abcb4d2414e0.png" style="outline: none;">
       等下次该用户登录时，走完
       <code>
        1.4
       </code>
       流程后，可以根据返回值中的
       <code>
        openid
       </code>
       在我们库中找到该用户，然后进行后续的操作。
      </img>
     </p>
     <h3>
      1.6 自定义
      <code>
       token
      </code>
     </h3>
     <p>
      所谓
      <code>
       token
      </code>
      就是用来确认用户的身份证，拿到下面的返回值后，我们有下面两种方式生成
      <code>
       自定义token
      </code>
      ：
     </p>
     <h4>
      (1)使用
      <code>
       业务ID
      </code>
      生成
      <code>
       token
      </code>
      (推荐使用，后续的内容都是以用户ID作为例子的)：
      <div style="text-align: center;">
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ce218daf289983ff4625cbfd3495fcc5.png" style="outline: none;"/>
      </div>
     </h4>
     <h4>
      (2)使用
      <code>
       session_key
      </code>
      生成
      <code>
       token
      </code>
      ：
     </h4>
     <p>
      <code>
       java { "session_key": "xxxxx" }
      </code>
     </p>
     <h4>
      (3)生成
      <code>
       token
      </code>
      的工具：
     </h4>
     <p>
      使用
      <code>
       md5
      </code>
      加密工具来生成
      <code>
       token
      </code>
      ，工具类如下：
     </p>
     <p>
      ```java import cn.hutool.crypto.Mode; import cn.hutool.crypto.Padding; import cn.hutool.crypto.symmetric.AES;
     </p>
     <p>
      import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets;
     </p>
     <p>
      public class AESUtil {
      <!-- -->
     </p>
     <pre class="has"><code>/**
 * 加密密钥
 */
private static final String ENCODE_KEY = "test_key_secret_";
/**
 * 偏移量
 */
private static final String IV_KEY = "0000000000000000";

public static String encryptFromString(String data, Mode mode, Padding padding) {
AES aes;
if (Mode.CBC == mode) {
aes = new AES(mode, padding,
new SecretKeySpec(ENCODE_KEY.getBytes(), "AES"),
new IvParameterSpec(IV_KEY.getBytes()));
} else {
aes = new AES(mode, padding,
new SecretKeySpec(ENCODE_KEY.getBytes(), "AES"));
}
return aes.encryptBase64(data, StandardCharsets.UTF_8);
}

public static String decryptFromString(String data, Mode mode, Padding padding) {
AES aes;
if (Mode.CBC == mode) {
aes = new AES(mode, padding,
new SecretKeySpec(ENCODE_KEY.getBytes(), "AES"),
new IvParameterSpec(IV_KEY.getBytes()));
} else {
aes = new AES(mode, padding,
new SecretKeySpec(ENCODE_KEY.getBytes(), "AES"));
}
byte[] decryptDataBase64 = aes.decrypt(data);
return new String(decryptDataBase64, StandardCharsets.UTF_8);
}</code></pre>
<p>
} `     </p>
     <p>
      <strong>
       <em>
        注意：
        <code>
         ENCODE_KEY
        </code>
        加密密钥不是固定的可以自己设置，但是！！！
        <code>
         ENCODE_KEY
        </code>
        和
        <code>
         IV_KEY
        </code>
        偏移量的字符
        <code>
         数量
        </code>
        一定要保持一致！！！否者解密失败！！！
       </em>
      </strong>
     </p>
     <p>
      <strong>
       测试：
      </strong>
     </p>
     <p>
      <code>
       java String encryptData = AESUtil.encryptFromString("test123456..", Mode.CBC, Padding.ZeroPadding); System.out.println("加密：" + encryptData); String decryptData = AESUtil.decryptFromString(encryptData, Mode.CBC, Padding.ZeroPadding); System.out.println("解密：" + decryptData);
      </code>
     </p>
     <p>
      <strong>
       结果：
      </strong>
     </p>
     <p>
      <code>
       java 加密：UYKwmVTh39qvwHsQ+tkFow== 解密：test123456..
      </code>
     </p>
     <h4>
      (5)将生成好的
      <code>
       token
      </code>
      放入到
      <code>
       Redis
      </code>
      (不重要，可以省略)
     </h4>
     <p>
      之所以放入
      <code>
       Redis
      </code>
      是因为它可以设置过期时间，可以实现
      <code>
       token
      </code>
      过期重新登录的功能。比如：如果接收到
      <code>
       微信小程序
      </code>
      请求所携带的
      <code>
       token
      </code>
      后先去
      <code>
       Redis
      </code>
      查询是否
      <code>
       存在
      </code>
      ，如果
      <code>
       不存
      </code>
      在则判定过期，直接返回让再次用户登录。
     </p>
     <p>
     `java @Autowired private RedisTemplate redisTemplate; .... //微信用户的唯一标识 private String userId= 'xxxxx' //将 token 放入 redis 并设置 3 天过期 redisTemplate.opsForValue().set(userId,JSONObject.toJSONString(userInfo),3, TimeUnit.DAYS);
</p>
<p>
`     </p>
     <h4>
      (6)返回
      <code>
       token
      </code>
      给微信小程序
     </h4>
     <p>
      将
      <code>
       token
      </code>
      放到返回体中返回给微信端。
     </p>
     <p>
      <code>
       java ... return returnSuccess(token);
      </code>
     </p>
     <h3>
      1.7 将
      <code>
       token
      </code>
      放到本地
     </h3>
     <p>
      在
      <code>
       开发者服务器
      </code>
      返回给微信小程序结果后，将
      <code>
       token
      </code>
      放入到本地存储。
     </p>
     <p>
      <code>
       javascript ... //将token放到本地 wx.setStorageSync('token', result.sessionKey) ...
      </code>
     </p>
     <h3>
      1.8 请求带上
      <code>
       token
      </code>
     </h3>
     <p>
      向
      <code>
       开发者服务器
      </code>
      发起请求时，在
      <code>
       header
      </code>
      中带上
      <code>
       token
      </code>
     </p>
     <p>
      <code>
       javascript ... wx.request({ url: 'https://xxxx.com/api/method', header:{"token":wx.getStorageSync('token')}, success:function(res){}, fail:function(res){} }) ...
      </code>
     </p>
     <h3>
      1.9 开发者服务器验证
      <code>
       token
      </code>
     </h3>
     <p>
      <code>
       开发者服务器
      </code>
      在接收到微信端发起的业务请求时，通过
      <code>
       AOP
      </code>
      进行拦截获取
      <code>
       header
      </code>
      中的
      <code>
       token
      </code>
      ：
     </p>
     <h4>
      (1)
      <code>
       AOP
      </code>
      统一拦截：
     </h4>
     <p>
      使用
      <code>
       Spring
      </code>
      的
      <code>
       AOP
      </code>
      来拦截请求获取
      <code>
       token
      </code>
      。
     </p>
     <p>
      <code>
       java //获取token String token = request.getHeader("token"); log.info("token:{}",token);
      </code>
     </p>
     <h4>
      (2)解密
      <code>
       token
      </code>
     </h4>
     <p>
      <code>
       java ... String token = 'xxxx'; log.info("解密前：{}",decryptData); String decryptData = AESUtil.decryptFromString(token, Mode.CBC, Padding.ZeroPadding); log.info("解密结果：{}",decryptData); //拿到用户ID String userId = decryptData; ...
      </code>
     </p>
     <h4>
      (3)验证是否过期(不重要，可以省略的步骤)
     </h4>
     <p>
      <code>
       java @Autowired private RedisTemplate redisTemplate; ... //用户ID String userId = decryptData ValueOperations valueOperations = redisTemplate.opsForValue(); String userInfoRedis = (String)valueOperations.get(userId); ...
      </code>
     </p>
     <h2>
      三、前后端完整代码
     </h2>
     <h3>
      2.1 前端代码
     </h3>
     <h4>
      (1)登陆
     </h4>
     <p>
      <code>
       javascript wx.login({ success(res){ if(res.code){ wx.request({ url:'https://xxxx.com/login/wxLogin', method:"POST", data:{"code":res.code} , dataType:"json", success:function(res){ result = res.data.result wx.setStorageSync('token', result.token) //页面跳转 ... }, fail:function(res){}, }) } } })
      </code>
     </p>
     <h4>
      (2)发起业务请求
     </h4>
     <p>
      <code>
       javascript wx.request({ url: "https://xxxx.com/test/test", method: "GET", dataType:"json", data:{}, //在heard中戴上token header:{"token":wx.getStorageSync('token')}, success:function(res){ ... }, fail:function(res){} });
      </code>
     </p>
     <h3>
      2.2 后端代码
     </h3>
     <p>
      后端使用的
      <code>
       Java
      </code>
      语言，框架是
      <code>
       Springboot
      </code>
      +
      <code>
       AOP
      </code>
      实现。 目录结构如下：
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/db5945102f9d7f43be62d35c2b67359f.png" style="outline: none;"/>
      <code>
       yml
      </code>
      配置文件：
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ce46788f7898b34ec540f68ef62420c6.png" style="outline: none;"/>
     </p>
     <h4>
      (1)依赖
     </h4>
     <p>
     `xml

     org.springframework.boot


     spring-boot-starter-web


     2.1.2.RELEASE
     </p>
     <p>
      org.springframework.boot


     spring-boot-starter


     2.3.7.RELEASE
     </p>
     <p>
      org.projectlombok


     lombok


     1.16.16
     </p>
     <p>
      org.slf4j


     slf4j-api


     1.7.30
     </p>
     <p>
      cn.hutool


     hutool-all


     5.6.3
     </p>
     <p>
      org.springframework.boot


     spring-boot-starter-aop


     3.0.4

````
  </p>
  <h4>
   (2)切面相关代码
  </h4>
  <p>
   ```java import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import javax.servlet.http.HttpServletRequest;
  </p>
  <p>
   @Aspect @Component @Slf4j public class TestAspect { @Autowired private HttpServletRequest request;
  </p>
  <pre class="has"><code>@Pointcut("execution(* xx.xxx.controller.*.*(..))"
       +"&amp;&amp; !execution(* xx.xxx.controller.WxLogin.*(..)"    )
public void pointCut(){}
@Around(value = "pointCut()")
public Object Around(ProceedingJoinPoint joinPoint) throws Throwable {
 //获取token
 String token = request.getHeader("token");
 log.info("token:{}",token);
 //不存在token直接抛出异常
 if(StringUtils.isEmpty(token)){
     throw new AopException();
 }
 //解析token
 String userId = AESUtil.decryptFromString(token, Mode.CBC, Padding.ZeroPadding);
 log.info("解析token:{}",userId);
 //将token 放入到 Base基础类
 Base base = new Base();
 base.setUserId(userId);
 //放到Base中
 final Object[] args = joinPoint.getArgs();
 for (Object arg : args) {
     if(arg instanceof Base){
         BeanUtils.copyProperties(base, arg);
     }
 }
 //放到ThreadLocal中
 User user = new User();
 user.setUserId(userId);
 UserContent.setUserContext(user);
 return joinPoint.proceed();
}

@After(value = "pointCut()")
public void controllerAfter() throws Throwable {
 log.info("后置通知");
 log.info("移除ThreadLocal中的用户信息:{}",UserContent.getUserContext());
 UserContent.removeUserContext();
}</code></pre>
  <p>
   }
  </p>
  <p>
   ```
  </p>
  <h5>
   知识点：
  </h5>
  <blockquote>
   <p>
    从上面代码中我们可以看到。我们通过解密可以拿到
    <code>
     UserId
    </code>
    ，这个值我们是频繁使用的，那么如何做到
    <code>
     随用随取
    </code>
    呢？
   </p>
   <ul>
    <li>
     <p>
      第一种方式：使用
      <code>
       Base
      </code>
      基础类，然后让
      <code>
       Controller
      </code>
      需要传递参数的
      <code>
       DTO
      </code>
      都继承
      <code>
       Base
      </code>
      然后就可以随时使用
      <code>
       UserId
      </code>
      了。
     </p>
    </li>
    <li>
     <p>
      第二种方式：使用
      <code>
       ThreadLocal
      </code>
      ，这种是比上一种优雅一些，也可以完全做到随用随取。但是需要注意在
      <code>
       会话
      </code>
      结束后一定要移除
      <code>
       ThreadLocal
      </code>
      中的用户信息，否则会导致内存溢出(这很重要)，一般使用
      <code>
       切面
      </code>
      的后置通知来做这件事情。
     </p>
    </li>
   </ul>
  </blockquote>
  <blockquote>
   <p>
    <code>
     execution(* xx.xx.controller.*.*(..))
    </code>
    解释：在方法执行时，xx.xx.controller包下的所有
    <code>
     类
    </code>
    下面的所有带有任何参数的
    <code>
     方法
    </code>
    都需要走这个切面。
   </p>
   <p>
    <code>
     @PointCut
    </code>
    注解值的规则：
   </p>
   <ul>
    <li>
     <code>
      execution
     </code>
     ：方法执行时触发。
    </li>
    <li>
     第一个
     <code>
      *
     </code>
     ：返回任意类型。
    </li>
    <li>
     <code>
      xx.xx.controller
     </code>
     ：具体的报路径。
    </li>
    <li>
     第二个
     <code>
      *
     </code>
     ：任意类。
    </li>
    <li>
     第三个
     <code>
      *
     </code>
     ：任意方法。
    </li>
    <li>
     <code>
      (..)
     </code>
     ：任意参数。
    </li>
   </ul>
   <p>
    如果想要排除
    <code>
     xxController
    </code>
    类可以这样写： @Pointcut("execution(* xx.xxx.xxxx.controller.
    <em>
     .
    </em>
    (..)) " + "&amp;&amp; !execution(* xx.xxx.xxxx.controller.xxController.*(..))") 比如 登陆的时候就需要
    <code>
     放行
    </code>
    登陆的接口。
   </p>
  </blockquote>
  <p>
   ```java public class AopException extends Exception { public AopException() { super("登录超时，请重新登录"); } }
  </p>
  <p>
   ```
  </p>
  <h4>
   (3)控制层代码
  </h4>
  <p>
   登陆
   <code>
    Controller
   </code>
   代码：
  </p>
  <p>
   ```java import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping("/login") public class WxLogin {
   <!-- -->
  </p>
  <pre class="has"><code>@Autowired
private IWxLoginService iWxLoginService;

@PostMapping("/wxLogin")
public Response wxLogin(@RequestBody WxLoginRequestDto requestDto){
 WxLoginResponseDto wxLoginResponseDto = iWxLoginService.wxLogin(requestDto);
 return returnSuccess(wxLoginResponseDto);
}</code></pre>
  <p>
   }
  </p>
  <p>
   ```
  </p>
  <p>
   业务逻辑
   <code>
    Controller
   </code>
   代码：
  </p>
  <p>
   ```java import cn.trueland.model.Base; import cn.trueland.model.UserContent; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;
  </p>
  <p>
   @RestController @RequestMapping("/test") public class TestController { @GetMapping("/test") public String test(Base base){ return base.getUserId(); } @GetMapping("/test2") public String test2(){ return UserContent.getUserContext().getUserId(); }
  </p>
  <p>
   }
  </p>
  <p>
   ```
  </p>
  <h4>
   (4)
   <code>
    Service
   </code>
   层代码：
  </h4>
  <p>
   这里我只帖登陆的
   <code>
    Service
   </code>
   层代码，业务的没有必要。
  </p>
  <p>
   <code>
    java public String wxLogin(WxLoginRequestDto requestDto) { if(StringUtils.isBlank(requestDto.getCode())){ throw new BusinessException("code为空!"); } //获取微信服务接口地址 String authCode2Session = wxConfig.getAuthCode2Session(requestDto.getCode()); //请求微信服务接口获取 openId String result = HttpClientUtil.doGet(authCode2Session); String openId = JSONObject.parseObject(result).getString("openid"); String sessionKey = JSONObject.parseObject(result).getString("session_key"); //入库 并返回 userId (逻辑省略) String userId = ...; //将用户信息存入redis redisTemplate.opsForValue().set(userId,userId ,3, TimeUnit.DAYS); String token = AESUtil.encryptFromString(userId, Mode.CBC, Padding.ZeroPadding); return token; }
   </code>
  </p>
  <h4>
   (4)实体类相关代码
  </h4>
  <p>
   登录请求
   <code>
    DTO
   </code>
   :
  </p>
  <p>
   <code>
    java import lombok.Data; @Data public class WxLoginRequestDto { /** * code */ private String code; }
   </code>
  </p>
  <p>
   基础类
   <code>
    Base
   </code>
   :
  </p>
  <p>
   ```java import lombok.Data;
  </p>
  <p>
   @Data public class Base { private String userId; }
  </p>
  <p>
   ``
   <code>
    用户实体类
   </code>
   User`:
  </p>
  <p>
   ```java import lombok.Data;
  </p>
  <p>
   @Data public class User { private String userId; }
  </p>
  <p>
   ``
   <code>
    用户信息实体
   </code>
   UserContent`:
  </p>
  <p>
   ```java public class UserContent { private static final ThreadLocal

 userInfo = new ThreadLocal();
  </p>
  <pre class="has"><code>public static User getUserContext(){
 return userInfo.get();
}

public static void setUserContext(User userContext){
 userInfo.set(userContext);
}

public static void removeUserContext(){
 userInfo.remove();
}</code></pre>
  <p>
   }
  </p>
  <p>
   ```
  </p>
  <h4>
   (5)配置类
  </h4>
  <p>
   ```java import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component;
  </p>
  <p>
   @Data @Component @ConfigurationProperties(prefix = "wx") public class WxConfig { /
   <em>
    * * 小程序AppId */ private String appId; /
   </em>
   * * 小程序密钥
   <em>
    / private String appSecret; /
   </em>
   * * 授权类型
   <em>
    / private String grantType; /
   </em>
   * * auth.code2Session 的 url */ private String authCodeSessionUrl; } ```
  </p>
  <h4>
   (6)
   <code>
    yml
   </code>
   配置信息
  </h4>
  <p>
   <code>
    xml wx: app-id: xxxx app-secret: xxxx auth-code-session-url: https://api.weixin.qq.com/sns/jscode2session? grant-type: authorization_code
   </code>
  </p>
  <h4>
   测试结果
  </h4>
  <p>
   <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d7b4aaae356e0d6e3b50c06bc53f8b71.png" style="outline: none;"/>
  </p>
  <p>
   <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c39bc28d7d03e532bf08e54f52955671.png" style="outline: none;"/>
   都可以拿到
   <code>
    UserId
   </code>
   并返回。
  </p>
  <p>
   下面就可以开心的处理业务逻辑啦！！！
  </p>
 </div>
</div>
</div>
</article>
<p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34323738353235302f:61727469636c652f64657461696c732f313332393830373333" class_="artid" style="display:none">
</p>
</div>


````
