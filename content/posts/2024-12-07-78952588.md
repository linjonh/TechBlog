---
layout: post
title: "超快数据库-ObjectBox-使用小记"
date: 2024-12-07 19:48:48 +0800
description: "超快的对象型 NoSQL 数据库 ObjectBox 在 Android上的使用小记_objectb"
keywords: "objectbox数据库文件安全吗"
categories: ['笔记', '库使用', 'Android']
tags: ['数据库', 'Android']
artid: "78952588"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=78952588
    alt: "超快数据库-ObjectBox-使用小记"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=78952588
featuredImagePreview: https://bing.ee123.net/img/rand?artid=78952588
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     超快数据库 ObjectBox 使用小记
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     最近新项目要求做一个下载的功能，需要实现显示“已下载”和“正在下载”两个列表的展示，左思右想后，决定用数据库来实现记录下载任务信息的功能，也正好实战一下想了很久的
     <code>
      ObjectBox
     </code>
     数据库。
    </p>
    <p>
     这个数据库是比较出名的另一个 Android 数据库
     <code>
      greenDAO
     </code>
     的母公司开发的，一个
     <code>
      NoSQL
     </code>
     数据库，也就是一个非 SQLite 的数据库，据说速度完爆任何移动数据库，具体对比结果可以看着一篇文章：
     <a href="http://jp1017.top/2017/11/24/%E5%AE%89%E5%8D%93%E8%B6%85%E5%BF%AB%E6%95%B0%E6%8D%AE%E5%BA%93ObjectBox%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97/" rel="nofollow noopener noreferrer" target="_blank">
      安卓超快数据库ObjectBox使用及填坑指南
     </a>
     ，官方有
     <a href="http://objectbox.io/documentation/how-to-get-started/" rel="nofollow noopener noreferrer" target="_blank">
      详细使用文档
     </a>
     ，算是比较全面的了。ObjectBox 宣称是“面向对象的数据库”，实际上，它的使用方法也是充满了面向对象语言的特点，所以对于
     <code>
      java
     </code>
     开发者来说应该是非常好上手的。
    </p>
    <h2 id="集成">
     集成
    </h2>
    <p>
     首先将 ObjectBox 集成到项目中，在根目录的
     <code>
      build.gradle
     </code>
     里添加如下代码：
    </p>
    <pre class="prettyprint"><code class="language-groovy hljs r">buildscript {
    <span class="hljs-keyword">...</span>
    ext.objectboxVersion = <span class="hljs-string">'1.3.4'</span> //截至本文完成时的最新版
    repositories {
        <span class="hljs-keyword">...</span>
        maven { url <span class="hljs-string">"http://objectbox.net/beta-repo/"</span> }
    }
    dependencies {
        <span class="hljs-keyword">...</span>
        classpath <span class="hljs-string">"io.objectbox:objectbox-gradle-plugin:$objectboxVersion"</span>
    }
}

allprojects {
    repositories {
        <span class="hljs-keyword">...</span>
        maven { url <span class="hljs-string">"http://objectbox.net/beta-repo/"</span> }
    }
}</code></pre>
    <p>
     然后在
     <code>
      app
     </code>
     模块下的
     <code>
      build.gradle
     </code>
     文件的
     <code>
      dependencies
     </code>
     中添加依赖，并使用插件：
    </p>
    <pre class="prettyprint"><code class="language-groovy hljs r">apply plugin: <span class="hljs-string">'com.android.application'</span>
<span class="hljs-keyword">...</span>
apply plugin: <span class="hljs-string">'io.objectbox'</span>

<span class="hljs-keyword">...</span>

dependencies {
    <span class="hljs-keyword">...</span>
    implementation <span class="hljs-string">"io.objectbox:objectbox-android:$objectboxVersion"</span>
    annotationProcessor <span class="hljs-string">"io.objectbox:objectbox-processor:$objectboxVersion"</span>
    <span class="hljs-keyword">...</span>
}</code></pre>
    <p>
     注意，因为
     <code>
      ObjectBox
     </code>
     是
     <code>
      NoSQL
     </code>
     数据库，它生成的数据库文件使不能通过 SQLite 查看器查看的，所以如果想查看数据库里的数据，需要开启 debug 模式，通过官方提供的数据库查看工具查看，在
     <code>
      app
     </code>
     模块下的
     <code>
      build.gradle
     </code>
     文件中添加依赖需要添加在文件
     <strong>
      顶部
     </strong>
     ，并添加 debug 依赖：
    </p>
    <pre class="prettyprint"><code class="language-groovy hljs r">apply plugin: <span class="hljs-string">'com.android.application'</span>
<span class="hljs-keyword">...</span>
dependencies {
    releaseImplementation <span class="hljs-string">"io.objectbox:objectbox-android:$objectboxVersion"</span>
    debugImplementation <span class="hljs-string">"io.objectbox:objectbox-android-objectbrowser:$objectboxVersion"</span>
    annotationProcessor <span class="hljs-string">"io.objectbox:objectbox-processor:$objectboxVersion"</span>
}
apply plugin: <span class="hljs-string">'io.objectbox'</span>

<span class="hljs-keyword">...</span></code></pre>
    <p>
     以 debug 模式运行后，会出现一个通知，点击可通过浏览器打开并浏览数据表里的内容，想当简单易用。
     <br/>
     若想在 PC 端通过浏览器查看数据库，需要将端口转发一下
     <code>
      adb forward tcp:8090 tcp:8090
     </code>
     ，至于具体的端口号，可以在 app 启动时在 Android Studio 的 Logcat 窗口查看，一般情况下都是 8090。
    </p>
    <p>
     另外 debug 模式数据库查看是通过浏览器打开特定端口进行查看，所以还需在
     <code>
      Manifest
     </code>
     文件中添加网络权限。
    </p>
    <pre class="prettyprint"><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-title">uses-permission</span> <span class="hljs-attribute">android:name</span>=<span class="hljs-value">"android.permission.INTERNET"</span>/&gt;</span></code></pre>
    <p>
     到此即集成完毕。
    </p>
    <h2 id="基本用法">
     基本用法
    </h2>
    <h3 id="初始化">
     初始化
    </h3>
    <p>
     一般在
     <code>
      Application
     </code>
     的
     <code>
      onCreate()
     </code>
     方法里进行初始化，我是将初始化后的数据库实例作为静态变量存储在
     <code>
      Application
     </code>
     里面，方便调用。
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BaseApp INSTANCE;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BoxStore mBoxStore;

<span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>() {
    <span class="hljs-keyword">super</span>.onCreate();
    INSTANCE = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 初始化数据库</span>
    mBoxStore = MyObjectBox.builder().androidContext(<span class="hljs-keyword">this</span>).build();
    <span class="hljs-comment">// debug模式开启数据库浏览器</span>
    <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) {
        <span class="hljs-keyword">new</span> AndroidObjectBrowser(mBoxStore).start(<span class="hljs-keyword">this</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BoxStore <span class="hljs-title">getBoxStore</span>() {
    <span class="hljs-keyword">return</span> mBoxStore;
}</code></pre>
    <h3 id="建立数据表">
     建立数据表
    </h3>
    <p>
     然后像建立一个实体类一样建立对应的数据库。只需要在类上面注释一行
     <code>
      @Entity
     </code>
     ，表明这个类是个数据库实体类，然后添加一个属性
     <code>
      id
     </code>
     ，用
     <code>
      @Id
     </code>
     注释，当作数据表条目 Id。
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-annotation">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadTaskEntity</span> {<!-- --></span>

    <span class="hljs-annotation">@Id</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span>() {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span>(<span class="hljs-keyword">long</span> id) {
        <span class="hljs-keyword">this</span>.id = id;
    }
}</code></pre>
    <h3 id="获取数据表">
     获取数据表
    </h3>
    <p>
     可以通过如下方法获取上文中建立的
     <code>
      DownloadTaskEntity
     </code>
     数据表进行 CRUD 操作：
    </p>
    <pre class="prettyprint"><code class="language-java hljs">Box&lt;DownloadTaskEntity&gt; box = BaseApp.getBoxStore().boxFor(DownloadTaskEntity.class)</code></pre>
    <p>
     因为 CRUD 操作基本上都要进行多次反复操作，所以我将表实例写成了单例：
    </p>
    <pre class="prettyprint"><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadInfoDb</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Box&lt;DownloadTaskEntity&gt; DOWNLOAD_INFO_BOX;

    <span class="hljs-keyword">private</span> <span class="hljs-title">DownloadInfoDb</span>() {}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Box&lt;DownloadTaskEntity&gt; <span class="hljs-title">getBox</span>() {
        <span class="hljs-keyword">if</span> (DOWNLOAD_INFO_BOX == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">synchronized</span> (DownloadInfoDb.class) {
                <span class="hljs-keyword">if</span> (DOWNLOAD_INFO_BOX == <span class="hljs-keyword">null</span>) {
                    DOWNLOAD_INFO_BOX = BaseApp.getBoxStore().boxFor(DownloadTaskEntity.class);
                }
            }
        }
        <span class="hljs-keyword">return</span> DOWNLOAD_INFO_BOX;
    }
}</code></pre>
    <h3 id="基本操作">
     基本操作
    </h3>
    <h4 id="新增和更新数据">
     新增和更新数据
    </h4>
    <p>
     <code>
      put(DownloadTaskEntity entity)
     </code>
     方法，需要注意的是，如果
     <code>
      entity
     </code>
     的
     <code>
      Id
     </code>
     与表中现有数据的
     <code>
      Id
     </code>
     一致，那么会替换掉表中的条目，这也就是 ObjectBox 更新数据的方法，即先查询获得表中的某个
     <code>
      entity
     </code>
     ，然后修改属性，再
     <code>
      put
     </code>
     进去，即是升级数据条目。
    </p>
    <h4 id="查询数据">
     查询数据
    </h4>
    <p>
     一般要新建一个 Query，然后给新建的 Query 设置查询条件，然后执行查询，比如查询
     <code>
      filename
     </code>
     属性为“xyz”的条目：
    </p>
    <pre class="prettyprint"><code class="language-java hljs">QueryBuilder&lt;DownloadTaskEntity&gt; builder = DownloadInfoDb.getBox().query();
builder.equal(DownloadTaskEntity_.filename, <span class="hljs-string">"xyz"</span>);
List&lt;DownloadTaskEntity&gt; entityList = builder.build().find();</code></pre>
    <p>
     当然也可以写成一句的形式：
    </p>
    <pre class="prettyprint"><code class="language-java hljs">List&lt;DownloadTaskEntity&gt; entityList = DownloadInfoDb.getBox().query()
                                .equal(DownloadTaskEntity_.filename, <span class="hljs-string">"filename"</span>)
                                .build().find();</code></pre>
    <p>
     到底怎么写，具体看应用情况了，还有另外几种写法，详情可以看
     <a href="http://objectbox.io/documentation/queries/" rel="nofollow noopener noreferrer" target="_blank">
      官方文档的Queries介绍
     </a>
    </p>
    <h4 id="删除数据">
     删除数据
    </h4>
    <p>
     这个没什么好说的了，就是
     <code>
      remove()
     </code>
     方法以及它的各种重载方法了。
    </p>
    <hr/>
    <p>
     然后还有一些诸如“懒查询数据”，“关联数据表”，“查询结果不返回数据实体列表，而返回对应属性的列表”等等之类的高级用法，可以参看官方文档，这里就不展开讲了。这个数据表甚至能取代 Google 官方的 Room 作为 LiveData 加入到 Google 官方套餐里。
    </p>
    <p>
     需要注意的一点是，如果用了类似 git 的 VCS 软件，那么
     <code>
      app
     </code>
     模块下自动生成的
     <code>
      /objectbox-models/default.json
     </code>
     需要加入到 VCS 系统里。
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f5269636172646f36:2f61727469636c652f64657461696c732f3738393532353838" class_="artid" style="display:none">
 </p>
</div>


