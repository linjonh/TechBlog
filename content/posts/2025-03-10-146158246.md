---
layout: post
title: "LeetCode-2380-二进制字符串重新安排顺序需要的时间"
date: 2025-03-10 19:47:12 +0800
description: "暴力模拟法：直观易懂，适合小规模输入。数学规律法：高效优化，适合大规模输入。实际开发中需根据场景选择合适方法。掌握字符串处理技巧和数学规律推导能力，对解决类似问题至关重要。如果您有任何疑问或建议，欢迎在评论区交流！🚀。"
keywords: "LeetCode 2380 二进制字符串重新安排顺序需要的时间"
categories: ['未分类']
tags: ['职场和发展', '算法', '数据结构', '开发语言', 'Leetcode', 'Java']
artid: "146158246"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158246
    alt: "LeetCode-2380-二进制字符串重新安排顺序需要的时间"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158246
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158246
cover: https://bing.ee123.net/img/rand?artid=146158246
image: https://bing.ee123.net/img/rand?artid=146158246
img: https://bing.ee123.net/img/rand?artid=146158246
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LeetCode 2380 二进制字符串重新安排顺序需要的时间
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     二进制字符串替换问题：计算消除 "01" 所需秒数
    </h2>
    <h3>
     题目描述
    </h3>
    <p>
     给定一个二进制字符串
     <code>
      s
     </code>
     ，每秒将所有子字符串
     <code>
      "01"
     </code>
     同时替换为
     <code>
      "10"
     </code>
     ，直到字符串中不再存在
     <code>
      "01"
     </code>
     。求完成这个过程所需的秒数。
    </p>
    <h4>
     输入输出示例
    </h4>
    <p>
     <strong>
      输入
     </strong>
     ：
    </p>
    <pre><code class="language-java">s = "0101"</code></pre>
    <p>
     <strong>
      输出
     </strong>
     ：
    </p>
    <pre><code class="language-java">2</code></pre>
    <p>
     <strong>
      解释
     </strong>
     ：
    </p>
    <ul>
     <li>
      第 1 秒："0101" → "1010"
     </li>
     <li>
      第 2 秒："1010" → "1100"
     </li>
    </ul>
    <h3>
     解题思路分析
    </h3>
    <h4>
     1. 暴力模拟法
    </h4>
    <p>
     最直观的思路是模拟替换过程：
    </p>
    <ol>
     <li>
      遍历字符串，找到所有
      <code>
       "01"
      </code>
      并替换为
      <code>
       "10"
      </code>
      。
     </li>
     <li>
      每次替换后秒数加 1。
     </li>
     <li>
      重复上述步骤，直到字符串不再变化。
     </li>
    </ol>
    <p>
     <strong>
      优点
     </strong>
     ：实现简单，逻辑清晰。
     <br/>
     <strong>
      缺点
     </strong>
     ：时间复杂度较高，最坏情况下为 O (n²)。
    </p>
    <h4>
     2. 数学规律优化
    </h4>
    <p>
     观察发现：
    </p>
    <ul>
     <li>
      每个
      <code>
       '0'
      </code>
      需要向右移动的次数等于其右侧连续
      <code>
       '1'
      </code>
      的数量。
     </li>
     <li>
      总秒数等于所有
      <code>
       '0'
      </code>
      右侧连续
      <code>
       '1'
      </code>
      数量的最大值。
     </li>
    </ul>
    <p>
     <strong>
      示例分析
     </strong>
     ：
    </p>
    <pre><code class="language-java">s = "0101"</code></pre>
    <ul>
     <li>
      第一个
      <code>
       '0'
      </code>
      右侧有 1 个
      <code>
       '1'
      </code>
      → 需 1 秒。
     </li>
     <li>
      第二个
      <code>
       '0'
      </code>
      右侧有 2 个
      <code>
       '1'
      </code>
      → 需 2 秒。
     </li>
     <li>
      总秒数为 2。
     </li>
    </ul>
    <p>
     <strong>
      优点
     </strong>
     ：时间复杂度 O (n)。
     <br/>
     <strong>
      缺点
     </strong>
     ：需要理解并推导出数学规律。
    </p>
    <h3>
     代码实现（Java）
    </h3>
    <h4>
     方法一：暴力模拟法
    </h4>
    <pre><code class="language-java">class Solution {
    public int secondsToRemoveOccurrences(String s) {
        int seconds = 0;
        boolean hasChanged;
        char[] chars = s.toCharArray();

        do {
            hasChanged = false;
            for (int i = 0; i &lt; chars.length - 1; i++) {
                if (chars[i] == '0' &amp;&amp; chars[i + 1] == '1') {
                    // 交换 '0' 和 '1'
                    chars[i] = '1';
                    chars[i + 1] = '0';
                    hasChanged = true;
                    // 跳过下一个位置，避免重复处理
                    i++;
                }
            }
            if (hasChanged) {
                seconds++;
            }
        } while (hasChanged);

        return seconds;
    }
}</code></pre>
    <h4>
     方法二：数学规律法
    </h4>
    <pre><code class="language-java">class Solution {
    public int secondsToRemoveOccurrences(String s) {
        int seconds = 0;
        int ones = 0; // 当前累积的连续 '1' 数量

        for (char c : s.toCharArray()) {
            if (c == '0') {
                // 当前 '0' 需要等待 ones 秒才能移动
                seconds = Math.max(seconds, ones);
            } else {
                ones++;
            }
        }
        return seconds;
    }
}</code></pre>
    <h3>
     代码逐行解析
    </h3>
    <h4>
     方法一：暴力模拟法
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        初始化变量
       </strong>
       ：
      </p>
      <ul>
       <li>
        <code>
         seconds
        </code>
        ：记录总秒数。
       </li>
       <li>
        <code>
         hasChanged
        </code>
        ：标记本次是否发生替换。
       </li>
       <li>
        <code>
         chars
        </code>
        ：将字符串转换为字符数组以便修改。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        循环处理
       </strong>
       ：
      </p>
      <ul>
       <li>
        使用
        <code>
         do-while
        </code>
        确保至少执行一次替换。
       </li>
       <li>
        遍历字符数组，找到
        <code>
         "01"
        </code>
        并交换为
        <code>
         "10"
        </code>
        。
       </li>
       <li>
        每次交换后跳过下一个位置（
        <code>
         i++
        </code>
        ），避免重复处理。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        更新秒数
       </strong>
       ：
      </p>
      <ul>
       <li>
        若发生替换，
        <code>
         seconds
        </code>
        加 1。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     方法二：数学规律法
    </h4>
    <ol>
     <li>
      <strong>
       遍历字符
      </strong>
      ：
      <ul>
       <li>
        遇到
        <code>
         '0'
        </code>
        时，记录当前累积的连续
        <code>
         '1'
        </code>
        数量
        <code>
         ones
        </code>
        ，并更新最大秒数。
       </li>
       <li>
        遇到
        <code>
         '1'
        </code>
        时，累积
        <code>
         ones
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     复杂度分析
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        时间复杂度
       </th>
       <th>
        空间复杂度
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        暴力模拟法
       </td>
       <td>
        O(n²)
       </td>
       <td>
        O(n)
       </td>
      </tr>
      <tr>
       <td>
        数学规律法
       </td>
       <td>
        O(n)
       </td>
       <td>
        O(1)
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     常见问题解答
    </h3>
    <h4>
     Q1：为什么暴力模拟法的时间复杂度是 O (n²)？
    </h4>
    <p>
     最坏情况下（如
     <code>
      "010101..."
     </code>
     ），每次只能处理一个
     <code>
      "01"
     </code>
     ，需要进行 O (n) 次遍历，每次遍历 O (n) 时间。
    </p>
    <h4>
     Q2：数学规律法的正确性如何证明？
    </h4>
    <ul>
     <li>
      每个
      <code>
       '0'
      </code>
      必须等待其右侧的所有
      <code>
       '1'
      </code>
      全部移动到左边后，才能移动。
     </li>
     <li>
      例如，
      <code>
       "011"
      </code>
      中的
      <code>
       '0'
      </code>
      需要 2 秒才能移动到最后。
     </li>
    </ul>
    <h4>
     Q3：为什么字符数组比字符串更高效？
    </h4>
    <p>
     字符串是不可变对象，每次修改会生成新实例。字符数组支持原地修改，减少内存开销。
    </p>
    <h3>
     测试用例
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        输入
       </th>
       <th>
        输出
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         "01"
        </code>
       </td>
       <td>
        1
       </td>
       <td>
        一次替换即可
       </td>
      </tr>
      <tr>
       <td>
        <code>
         "10"
        </code>
       </td>
       <td>
        0
       </td>
       <td>
        初始无
        <code>
         "01"
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         "010101"
        </code>
       </td>
       <td>
        3
       </td>
       <td>
        每个
        <code>
         '0'
        </code>
        需要移动 3 次
       </td>
      </tr>
      <tr>
       <td>
        <code>
         "111000"
        </code>
       </td>
       <td>
        0
       </td>
       <td>
        初始无
        <code>
         "01"
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         "0"
        </code>
       </td>
       <td>
        0
       </td>
       <td>
        空字符串
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     总结
    </h3>
    <p>
     本题通过两种方法实现：
    </p>
    <ol>
     <li>
      <strong>
       暴力模拟法
      </strong>
      ：直观易懂，适合小规模输入。
     </li>
     <li>
      <strong>
       数学规律法
      </strong>
      ：高效优化，适合大规模输入。
     </li>
    </ol>
    <p>
     实际开发中需根据场景选择合适方法。掌握字符串处理技巧和数学规律推导能力，对解决类似问题至关重要。如果您有任何疑问或建议，欢迎在评论区交流！ 🚀
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36343630343733322f:61727469636c652f64657461696c732f313436313538323436" class_="artid" style="display:none">
 </p>
</div>


