---
layout: post
title: "短分享-Flink图构建"
date: 2025-03-06 21:48:43 +0800
description: "Execution是ExecutionVertex的执行抽象，Flink构成图之后，会将Execution结点分发到各个TaskManager进行执行，可以看下面本地debug图，各个Execution刚刚处于创建状态等待执行，具体后续执行流程各位感兴趣可以再继续探究。有了所有的边，就可以将边构成图了，图主要通过递归关系构建，不同Transformation有不同处理策略，对于map会把该结点和它之前的结点构成边，对于union会把它的前后结点连接起来，对于keyby会变成边的策略。"
keywords: "短分享-Flink图构建"
categories: ['未分类']
tags: ['大数据', 'Flink']
artid: "144834165"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144834165
    alt: "短分享-Flink图构建"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144834165
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144834165
cover: https://bing.ee123.net/img/rand?artid=144834165
image: https://bing.ee123.net/img/rand?artid=144834165
img: https://bing.ee123.net/img/rand?artid=144834165
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     短分享-Flink图构建
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="eb601d0d-4288-452f-af85-e4807940a5dc">
     一、背景
    </h2>
    <p>
     通过简单的书写map、union、keyby等代码，Flink便能构建起一个庞大的分布式计算任务，Flink如何实现的这个酷炫功能呢？我们本次分享Flink做的第一步，将代码解析构建成图
    </p>
    <p>
     源码基于Flink 2.10，书籍参考《Flink核心技术源码剖析与特性开发》第四章
    </p>
    <p>
     我这次会用一个简单的代码来举例图的构建过程
    </p>
    <h2 id="0771c7e1-f02e-46f3-ad8b-5a007cb46742">
     二、例子代码
    </h2>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/4e019eb000204baba868dde803130f4e.png" width="1200"/>
    </p>
    <p>
     以上代码转换关系如下图：
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/289d85e6e9184c2085fc8ad755347a98.jpeg" width="1200"/>
    </p>
    <h2 id="1d5406d9-78df-40fd-9f00-e371b6c5ea76">
     三、代码转StreamGraph
    </h2>
    <h3 id="69b6547a-64b2-41e0-b6ea-4086b3974ef0">
     3.1 路由关系的搭建
    </h3>
    <p>
     Flink中每一次转换（如map）用Transformation表示，每次转换都会有一条类似的边被保存(Transformation1-&gt; Transformation2) ，而所有的关联关系存储在Environment的transformations中
    </p>
    <h3 id="b1351afd-735b-4a87-b618-d6bfa9f11c52">
     3.2 路由关系转StreamGraph
    </h3>
    <p>
     有了所有的边，就可以将边构成图了，图主要通过递归关系构建，不同Transformation有不同处理策略，对于map会把该结点和它之前的结点构成边，对于union会把它的前后结点连接起来，对于keyby会变成边的策略
    </p>
    <p>
     转换之后图如下所示，可以看到union和keyby都消失了
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/da1692feb3a14f8ebdf868315943d82e.jpeg" width="1200"/>
    </p>
    <p>
     我们debug中间过程，可以看到确实是7个结点
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/06c7a67be50140738ef3d6157ee2ba45.png" width="1200"/>
    </p>
    <p>
     且keyby变成了边的策略
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/dbe4c93f15c14882a401def765f1d0c0.png" width="1200"/>
    </p>
    <h2 id="ad3b7ded-8ed7-4054-b5af-b4f67e41c519">
     四、StreamGraph转JobGraph
    </h2>
    <p>
     在这一步会做很做很多重要操作，比如结点链接，配置检查点，设置分布式缓存文件等，我们本次主要聚焦于结点的链接，满足如下条件的会被链接
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/cbce1859fe9d409d85242933e414b80c.jpeg" width="1200"/>
    </p>
    <p>
     StreamGraph转JobGraph同样通过递归进行，链接完后的图如下图所示，map1和map2被链接，map4和slink被链接：
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/f43ea3053d724ee68f64dc6a9ab3c425.jpeg" width="1200"/>
    </p>
    <p>
     可以debug中间过程，可以看到确实是只剩了5个结点：
    </p>
    <p>
     <img alt="" height="1096" src="https://i-blog.csdnimg.cn/direct/47c9229edab4491194867d720f1d9fdf.png" width="1200"/>
    </p>
    <p>
     如果我们再加上实际的对象，实际如下图所示，每个结点是一个JobVertex，IntermediateDataSet 对象就是数据写入的地方，JobEdge是连接关系
    </p>
    <p>
     其中ID是IntermediateDataSet，为后面数据分区做准备
    </p>
    <p>
     JE是JobEdge
    </p>
    <p>
     <img alt="" height="1200" src="https://i-blog.csdnimg.cn/direct/b0615c58f35b4f6d8d1323f3f1b2d56d.jpeg" width="1200"/>
    </p>
    <h2 id="7a69bb77-2b24-40c3-ab79-0e69489048fc">
     五、JobGraph转ExecutionGraph
    </h2>
    <p>
     JobGraph创建好之后，会被提交到JobManager，在JobManager中会根据JobGraph图做拓扑排序，然后完成JobGraph到ExecutionGraph的转化，其中：
    </p>
    <p>
     JobVertex一比一转换ExecutionJobVertex，ExecutionJobVertex会根据并发度拆分成ExecutionVertex，比如map1-&gt;Map2，就会变成两个ExecutionVertex
    </p>
    <p>
     IntermediateDataSet会转成IntermediateResult，并根据生产结点个数，拆成不同的数据分区IntermediateResultPartition，比如map1-&gt;Map2，就会变成两个ExecutionVertex，同时有两个IntermediateResultPartition
    </p>
    <p>
     转换之后的图为如下所示，其中：
    </p>
    <p>
     IRP=IntermediateResultPartition 表示一个数据分区，数据分区满了之后会Flink会根据边ExecutionEdge的关联关系，提醒下游获取数据，进行计算
    </p>
    <p>
     EE=ExecutionEdge表示一条边
    </p>
    <p>
     EJV=ExecutionJobVertex 表示一个Task任务，由JobVertex一比一转换
    </p>
    <p>
     EV=ExecutionVertex，由ExecutionJobVertex根据并发度拆出来的
    </p>
    <p>
     <img alt="" height="1080" src="https://i-blog.csdnimg.cn/direct/dc46c373e0f742d58caa25a2e78a52dd.jpeg" width="1200"/>
    </p>
    <p>
     根据debug断点也可以看到确实有五个ExecutionJobVertex，其中map1-&gt;map2结点有两个ExecutionVertex，每个ExecutionVertex有一个IntermediateResultPartition
    </p>
    <p>
     <img alt="" height="1093" src="https://i-blog.csdnimg.cn/direct/8f056925c13e4ffa8fb546a4fffa9861.png" width="1200"/>
    </p>
    <h2 id="7f774e74-a95f-4a86-88c0-d1e1c1831a7d">
     六、后续
    </h2>
    <p>
     Execution是ExecutionVertex的执行抽象，Flink构成图之后，会将Execution结点分发到各个TaskManager进行执行，可以看下面本地debug图，各个Execution刚刚处于创建状态等待执行，具体后续执行流程各位感兴趣可以再继续探究
    </p>
    <p>
     <img alt="" height="1195" src="https://i-blog.csdnimg.cn/direct/b76bcc6f4e2c44b187cf8cf1a259dfa0.png" width="1200"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f713631303337363638312f:61727469636c652f64657461696c732f313434383334313635" class_="artid" style="display:none">
 </p>
</div>


