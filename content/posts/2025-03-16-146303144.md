---
layout: post
title: "C面试-关于deque"
date: 2025-03-16 23:42:52 +0800
description: "底层由多个固定大小的缓冲区组成，通过“中控器”（通常是一个指针数组）管理这些缓冲区的地址。的随机访问需通过中控器定位到具体缓冲区，再计算元素在缓冲区内的偏移，多了一层间接寻址；由多个固定大小的缓冲区组成，通过中控器（指针数组）管理。在中间插入/删除元素：可能导致后续元素的迭代器失效（需移动元素）。，支持在头部和尾部高效插入/删除元素，同时允许随机访问。直接通过连续内存的基地址+偏移量访问，无需额外查找步骤。在插入/删除元素时，所有后续迭代器均失效；仅在涉及缓冲区重新分配时影响部分迭代器。"
keywords: "[C++面试] 关于deque"
categories: ['C']
tags: ['开发语言', 'C']
artid: "146303144"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146303144
    alt: "C面试-关于deque"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146303144
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146303144
cover: https://bing.ee123.net/img/rand?artid=146303144
image: https://bing.ee123.net/img/rand?artid=146303144
img: https://bing.ee123.net/img/rand?artid=146303144
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [C++面试] 关于deque
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一、入门
    </h3>
    <h4>
     1、deque与vector的区别
    </h4>
    <p>
     <code>
      deque
     </code>
     的迭代器包含以下信息：
    </p>
    <ul>
     <li>
      当前缓冲区指针（
      <code>
       current_buffer
      </code>
      ）
     </li>
     <li>
      当前元素在缓冲区内的位置（
      <code>
       current
      </code>
      ）
     </li>
     <li>
      中控器的位置（
      <code>
       map
      </code>
      ）
      <br/>
      每次移动迭代器时，需检查是否跨越缓冲区边界，必要时跳转到下一个缓冲区
     </li>
    </ul>
    <p>
     <code>
      deque
     </code>
     （双端队列）是C++标准库中的
     <strong>
      序列容器
     </strong>
     ，支持在头部和尾部高效插入/删除元素，同时允许随机访问。
     <br/>
     与
     <code>
      vector
     </code>
     的主要区别：
    </p>
    <ul>
     <li>
      ​
      <strong>
       存储结构
      </strong>
      ：
      <code>
       vector
      </code>
      使用连续内存块，而
      <code>
       deque
      </code>
      由多个分段缓冲区组成，逻辑连续但物理非连续
     </li>
     <li>
      ​
      <strong>
       操作效率
      </strong>
      ：
      <code>
       deque
      </code>
      在头部插入/删除时间复杂度为O(1)，而
      <code>
       vector
      </code>
      头部操作需移动所有元素，效率为O(n)
     </li>
     <li>
      ​
      <strong>
       内存扩展
      </strong>
      ：
      <code>
       vector
      </code>
      扩容时需整体复制，
      <strong>
       <code>
        deque
       </code>
       仅需新增缓冲区
      </strong>
     </li>
    </ul>
    <h4>
     2、
     <strong>
      如何初始化一个
      <code>
       deque
      </code>
     </strong>
     （int 类型为例）
    </h4>
    <pre><code>deque&lt;int&gt; d1;                   // 默认构造
deque&lt;int&gt; d2(10, 5);           // 10个元素，每个为5
deque&lt;int&gt; d3(d2.begin(), d2.end()); // 范围复制
deque&lt;int&gt; d4(d3);              // 拷贝构造</code></pre>
    <h4>
     3、deque常用成员函数有哪些？
    </h4>
    <ul>
     <li>
      <code>
       push_front()
      </code>
      /
      <code>
       push_back()
      </code>
      ：头尾插入
     </li>
     <li>
      <code>
       pop_front()
      </code>
      /
      <code>
       pop_back()
      </code>
      ：头尾删除
     </li>
     <li>
      <code>
       operator[]
      </code>
      或
      <code>
       at()
      </code>
      ：随机访问
     </li>
     <li>
      <code>
       size()
      </code>
      /
      <code>
       empty()
      </code>
      ：容量查询
     </li>
    </ul>
    <h4>
     4、deque允许随机访问是怎么做到的？性能怎么样？
    </h4>
    <p>
     效率略低于
     <code>
      vector
     </code>
     。
     <br/>
     ​
     <strong>
      原因
     </strong>
     ：
     <code>
      deque
     </code>
     的随机访问需通过中控器定位到具体缓冲区，再计算元素在缓冲区内的偏移，多了一层间接寻址；而
     <code>
      vector
     </code>
     直接通过连续内存的基地址+偏移量访问，无需额外查找步骤。
    </p>
    <p>
     a、​
     <strong>
      确定目标缓冲区
     </strong>
     ：假设每个缓冲区存储
     <code>
      block_size
     </code>
     个元素，则目标缓冲区在中控器中的索引为：
    </p>
    <pre><code>buffer_index = (n / block_size) + start_buffer_index;</code></pre>
    <p>
     b、
     <strong>
      确定元素在缓冲区内的偏移
     </strong>
    </p>
    <pre><code>element_offset = n % block_size;</code></pre>
    <p>
     c、 ​
     <strong>
      访问元素
     </strong>
    </p>
    <pre><code>value = *(中控器[buffer_index] + element_offset);</code></pre>
    <p>
    </p>
    <h3>
     二、进阶
    </h3>
    <h4>
     <a name="t7">
     </a>
     1、
     <strong>
      解释
      <code>
       deque
      </code>
      的底层实现原理（中控器的作用）
     </strong>
    </h4>
    <p>
     <code>
      deque
     </code>
     底层由多个固定大小的缓冲区组成，通过“中控器”（通常是一个指针数组）管理这些缓冲区的地址。
    </p>
    <ul>
     <li>
      中控器维护各缓冲区的起始地址，使得逻辑上呈现连续空间。
     </li>
     <li>
      插入元素时，若当前缓冲区已满，则分配新缓冲区并更新中控器，避免整体扩容
     </li>
    </ul>
    <h4>
     2、
     <strong>
      在中间位置插入元素时，
      <code>
       deque
      </code>
      和
      <code>
       list
      </code>
      的性能差异如何？为什么？
     </strong>
    </h4>
    <ul>
     <li>
      <code>
       list
      </code>
      在已知迭代器位置时，中间插入/删除时间复杂度为O(1)，仅需调整指针。
     </li>
     <li>
      <code>
       deque
      </code>
      的中间插入/删除需移动元素，时间复杂度为O(n)
      <br/>
      ​
      <strong>
       原因
      </strong>
      ：
      <code>
       deque
      </code>
      需保持逻辑连续性，插入点后的元素需整体移动；而
      <strong>
       <span style="color:#fe2c24">
        <code>
         list
        </code>
        作为双向链
       </span>
      </strong>
      表无需移动数据
     </li>
    </ul>
    <h4>
     3、
     <code>
      deque
     </code>
     的迭代器失效场景有哪些？与
     <code>
      vector
     </code>
     有何不同？
    </h4>
    <p>
     在中间插入/删除元素：可能导致后续元素的迭代器失效（需移动元素）。
     <code>
      vector
     </code>
     在插入/删除元素时，所有后续迭代器均失效；而
     <code>
      deque
     </code>
     仅在涉及缓冲区重新分配时影响部分迭代器。
    </p>
    <p>
     <code>
      vector
     </code>
     的所有元素存储在
     <strong>
      单个连续内存块
     </strong>
     中。当插入/删除元素时：
    </p>
    <ul>
     <li>
      ​
      <strong>
       插入导致扩容
      </strong>
      ：会分配更大的内存块，将旧元素整体复制到新内存，此时所有迭代器（包括首尾指针）均失效。
     </li>
     <li>
      ​
      <strong>
       删除或中间插入
      </strong>
      ：后续元素需要向前或向后移动，所有指向移动元素的迭代器（包括之后的迭代器）均失效
     </li>
    </ul>
    <p>
     <code>
      deque
     </code>
     由多个固定大小的缓冲区组成，通过中控器（指针数组）管理。插入/删除时：
    </p>
    <ul>
     <li>
      ​
      <strong>
       头尾插入不触发缓冲区扩容
      </strong>
      ：仅修改中控器的头尾指针，其他迭代器仍有效。
     </li>
     <li>
      ​
      <strong>
       头尾插入触发缓冲区扩容
      </strong>
      ：中控器可能需要扩展（例如中控器的指针数组已满），此时所有迭代器可能失效（但实际实现会尽量避免）。
     </li>
     <li>
      ​
      <strong>
       中间插入/删除
      </strong>
      ：需移动元素，导致部分迭代器失效，但其他缓冲区的迭代器仍有效。
     </li>
    </ul>
    <h3>
     三、高阶
    </h3>
    <h4>
     <a name="t13">
     </a>
     1、
     <strong>
      在实际开发中，
      <code>
       deque
      </code>
      适合哪些应用场景？举例说明
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       双端操作频繁的场景
      </strong>
      ：如实现滑动窗口算法、任务调度队列
     </li>
     <li>
      ​
      <strong>
       需要随机访问的队列
      </strong>
      ：例如需要快速访问历史记录的
      <strong>
       <span style="color:#fe2c24">
        撤销/重做
       </span>
      </strong>
      功能（结合
      <code>
       push_front
      </code>
      和随机访问）
     </li>
     <li>
      ​
      <strong>
       替代
       <code>
        vector
       </code>
       的中间插入场景
      </strong>
      ：若仅在两端操作，
      <code>
       deque
      </code>
      性能优于
      <code>
       vector
      </code>
      ，且避免内存频繁重分配
     </li>
    </ul>
    <h4>
     2、
     <strong>
      为何
      <code>
       deque
      </code>
      在STL的
      <code>
       stack
      </code>
      和
      <code>
       queue
      </code>
      中作为默认底层容器？
     </strong>
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       内存效率
      </strong>
      ：
      <code>
       deque
      </code>
      的内存利用率高于
      <code>
       list
      </code>
      （无节点指针开销）
     </li>
     <li>
      ​
      <strong>
       性能平衡
      </strong>
      ：
      <code>
       stack
      </code>
      和
      <code>
       queue
      </code>
      仅需操作一端或两端，
      <code>
       deque
      </code>
      的O(1)头尾操作和连续内存访问特性更合适
     </li>
     <li>
      ​
      <strong>
       历史原因
      </strong>
      ：
      <code>
       vector
      </code>
      曾作为
      <code>
       stack
      </code>
      默认容器，但
      <code>
       deque
      </code>
      的头部扩展能力更灵活
     </li>
    </ul>
    <h4>
     3、
     <strong>
      多线程环境下使用
      <code>
       deque
      </code>
      需要注意什么？
     </strong>
    </h4>
    <ul>
     <li>
      ​
      <strong>
       线程安全性
      </strong>
      ：C++标准库容器本身不保证线程安全，需外部同步（如互斥锁）。
     </li>
     <li>
      ​
      <strong>
       操作原子性
      </strong>
      ：例如
      <code>
       push_back()
      </code>
      和
      <code>
       pop_front()
      </code>
      需加锁，避免竞争条件
     </li>
    </ul>
    <h4>
     4、
     <strong>
      如何优化
      <code>
       deque
      </code>
      的性能？是否支持自定义内存分配器？
     </strong>
    </h4>
    <ul>
     <li>
      预分配缓冲区（如通过构造函数指定初始大小）。
     </li>
     <li>
      避免频繁的中间插入/删除操作。
     </li>
     <li>
      ​
      <strong>
       自定义内存分配器
      </strong>
      ：支持。可通过模板参数替换默认分配器，优化内存管理策略
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f5461646563616e6c616e2f:61727469636c652f64657461696c732f313436333033313434" class_="artid" style="display:none">
 </p>
</div>


