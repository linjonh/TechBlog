---
layout: post
title: "OpenHarmony子系统开发-Rust编译构建指导"
date: 2025-03-15 18:52:54 +0800
description: "本文用于指导 Rust 语言开发者编译构建 OpenHarmony OS Rust 应用程序。Rust 是一门静态强类型语言，具有更安全的内存管理、更好的运行性能、原生支持多线程开发等优势。本工具链基于开源 rust 与 llvm 增量开发，适配了 OpenHarmony OS target 二进制构建。可将 rust 源码编译成能在 OpenHarmony OS 设备上使用的目标二进制。rust三方库使用cargo编译，配置为Cargo.toml。"
keywords: "OpenHarmony子系统开发 - Rust编译构建指导"
categories: ['子系统开发', 'Openharmony']
tags: ['开发语言', '后端', '人工智能', 'Rust', 'Harmonyos']
artid: "146283622"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146283622
    alt: "OpenHarmony子系统开发-Rust编译构建指导"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146283622
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146283622
cover: https://bing.ee123.net/img/rand?artid=146283622
image: https://bing.ee123.net/img/rand?artid=146283622
img: https://bing.ee123.net/img/rand?artid=146283622
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     OpenHarmony子系统开发 - Rust编译构建指导
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     OpenHarmony子系统开发 - Rust编译构建指导
    </h2>
    <h2>
     一、Rust模块配置规则和指导
    </h2>
    <h3>
     概述
    </h3>
    <p>
     Rust是一门静态强类型语言，具有更安全的内存管理、更好的运行性能、原生支持多线程开发等优势。Rust官方也使用Cargo工具来专门为Rust代码创建工程和构建编译。 OpenHarmony为了集成C/C++代码和提升编译速度，使用了GN + Ninja的编译构建系统。GN的构建语言简洁易读，Ninja的汇编级编译规则直接高效。 为了在OpenHarmony中集成Rust代码，并最大程度发挥Rust和OpenHarmony中原有C/C++代码的交互性，采用GN作为统一构建工具，即通过GN构建Rust源码文件(xxx.rs)，并增加与C/C++互操作、编译时lint、测试、IDL转换、三方库集成、IDE等功能。同时扩展gn框架，支持接口自动化转换，最大程度简化开发。
    </p>
    <h4>
     基本概念
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        术语
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        Cargo
       </td>
       <td>
        Cargo是Rust官方使用的构建工具,允许Rust项目声明其各种依赖项，并确保您始终获得可重复的构建。
       </td>
      </tr>
      <tr>
       <td>
        crate
       </td>
       <td>
        crate是一个独立的可编译单元。
       </td>
      </tr>
      <tr>
       <td>
        Lint
       </td>
       <td>
        Lint是指出常见编程错误、错误、样式错误和可疑结构的工具。可以对程序进行更加广泛的错误分析。
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     配置规则
    </h3>
    <p>
     OpenHarmony提供了用于Rust代码编译构建的各类型GN模板，可以用于编译Rust可执行文件，动态库和静态库等。各类型模板说明如下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        GN模板
       </th>
       <th>
        功能
       </th>
       <th>
        输出
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ohos_rust_executable
       </td>
       <td>
        rust可执行文件
       </td>
       <td>
        rust可执行文件，不带后缀
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_shared_library
       </td>
       <td>
        rust动态库
       </td>
       <td>
        rust dylib动态库，默认后缀.dylib.so
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_static_library
       </td>
       <td>
        rust静态库
       </td>
       <td>
        rust rlib静态库，默认后缀.rlib
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_proc_macro
       </td>
       <td>
        rust proc_macro
       </td>
       <td>
        rust proc_macro库， 默认后缀.so
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_shared_ffi
       </td>
       <td>
        rust FFI动态库
       </td>
       <td>
        rust cdylib动态库，给C/C++模块调用，默认后缀.so
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_static_ffi
       </td>
       <td>
        rust FFI静态库
       </td>
       <td>
        rust staticlib库，给C/C++模块调用，默认后缀.a
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_cargo_crate
       </td>
       <td>
        三方包Cargo crate
       </td>
       <td>
        rust三方crate，支持rlib、dylib、bin
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_systemtest
       </td>
       <td>
        rust系统测试用例
       </td>
       <td>
        rust可执行系统测试用例，不带后缀
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_unittest
       </td>
       <td>
        rust单元测试用例
       </td>
       <td>
        rust可执行单元测试用例，不带后缀
       </td>
      </tr>
      <tr>
       <td>
        ohos_rust_fuzztest
       </td>
       <td>
        rust Fuzz测试用例
       </td>
       <td>
        rust可执行Fuzz测试用例，不带后缀
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     配置指导
    </h3>
    <p>
     配置Rust模块与C/C++模块类似，参考
     <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-module.md" rel="nofollow" title="模块配置规则">
      模块配置规则
     </a>
     。下面是使用不同模板的示例。
    </p>
    <h4>
     配置Rust静态库示例
    </h4>
    <p>
     该示例用于测试Rust可执行bin文件和静态库rlib文件的编译，以及可执行文件对静态库的依赖，使用模板ohos_rust_executable和ohos_rust_static_library。操作步骤如下：
    </p>
    <ol>
     <li>
      <p>
       创建build/rust/tests/test_rlib_crate/src/simple_printer.rs，如下所示：
      </p>
      <pre><code>//! simple_printer

/// struct RustLogMessage

pub struct RustLogMessage {
    /// i32: id
    pub id: i32,
    /// String: msg
    pub msg: String,
}

/// function rust_log_rlib
pub fn rust_log_rlib(msg: RustLogMessage) {
    println!("id:{} message:{:?}", msg.id, msg.msg)
}
</code></pre>
     </li>
     <li>
      <p>
       创建build/rust/tests/test_rlib_crate/src/main.rs，如下所示：
      </p>
      <pre><code>//! rlib_crate example for Rust.

extern crate simple_printer_rlib;

use simple_printer_rlib::rust_log_rlib;
use simple_printer_rlib::RustLogMessage;

fn main() {
    let msg: RustLogMessage = RustLogMessage {
        id: 0,
        msg: "string in rlib crate".to_string(),
    };
    rust_log_rlib(msg);
}
</code></pre>
     </li>
     <li>
      <p>
       配置gn脚本build/rust/tests/test_rlib_crate/BUILD.gn，如下所示：
      </p>
      <pre><code>import("//build/ohos.gni")

ohos_rust_executable("test_rlib_crate") {
  sources = [ "src/main.rs" ]
  deps = [ ":simple_printer_rlib" ]
}

ohos_rust_static_library("simple_printer_rlib") {
  sources = [ "src/simple_printer.rs" ]
  crate_name = "simple_printer_rlib"
  crate_type = "rlib"
  features = [ "std" ]
}
</code></pre>
     </li>
     <li>
      <p>
       执行编译得到的可执行文件，运行结果如下：
      </p>
      <p>
      </p>
      <p class="img-center">
       <img alt="test_rlib_crate" height="69" src="https://i-blog.csdnimg.cn/img_convert/edd68032b0171506dc27c9b00262e9bb.png" width="776"/>
      </p>
     </li>
    </ol>
    <h4>
     配置三方库示例
    </h4>
    <p>
     rust三方库的BUILD.gn文件可通过cargo2gn工具自动生成。参见：
     <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-cargo2gn-guide.md" rel="nofollow" title="Cargo2gn工具操作指导">
      Cargo2gn工具操作指导
     </a>
    </p>
    <p>
     该示例用于测试包含预编译文件build.rs的三方静态库rlib文件的编译，使用了模板ohos_rust_executable和ohos_rust_cargo_crate。操作步骤如下：
    </p>
    <ol>
     <li>
      <p>
       创建build/rust/tests/test_rlib_cargo_crate/crate/src/lib.rs，如下所示：
      </p>
      <pre><code>include!(concat!(env!("OUT_DIR"), "/generated/generated.rs"));

pub fn say_hello_from_crate() {
    assert_eq!(run_some_generated_code(), 45);
    #[cfg(is_new_rustc)]
    println!("Is new rustc");
    #[cfg(is_old_rustc)]
    println!("Is old rustc");
    #[cfg(is_ohos)]
    println!("Is ohos");
    #[cfg(is_mac)]
    println!("Is darwin");
    #[cfg(has_feature_a)]
    println!("Has feature_a");
    #[cfg(not(has_feature_a))]
    panic!("Wasn't passed feature_a");
    #[cfg(not(has_feature_b))]
    #[cfg(test_a_and_b)]
    panic!("feature_b wasn't passed");
    #[cfg(has_feature_b)]
    #[cfg(not(test_a_and_b))]
    panic!("feature_b was passed");
}

#[cfg(test)]
mod tests {
    /// Test features are passed through from BUILD.gn correctly. This test is the target configuration.
    #[test]
    #[cfg(test_a_and_b)]
    fn test_features_passed_target1() {
        #[cfg(not(has_feature_a))]
        panic!("feature a was not passed");
        #[cfg(not(has_feature_b))]
        panic!("feature b was not passed");
    }

    #[test]
    fn test_generated_code_works() {
        assert_eq!(crate::run_some_generated_code(), 45);
    }
}
</code></pre>
     </li>
     <li>
      <p>
       创建build/rust/tests/test_rlib_cargo_crate/crate/src/main.rs，如下所示：
      </p>
      <pre><code>pub fn main() {
    test_rlib_crate::say_hello_from_crate();
}
</code></pre>
     </li>
     <li>
      <p>
       创建build/rust/tests/test_rlib_cargo_crate/crate/build.rs，如下所示：
      </p>
      <pre><code>use std::env;
use std::path::Path;
use std::io::Write;
use std::process::Command;
use std::str::{self, FromStr};

fn main() {
    println!("cargo:rustc-cfg=build_script_ran");
    let my_minor = match rustc_minor_version() {
        Some(my_minor) =&gt; my_minor,
        None =&gt; return,
    };

    if my_minor &gt;= 34 {
        println!("cargo:rustc-cfg=is_new_rustc");
    } else {
        println!("cargo:rustc-cfg=is_old_rustc");
    }

    let target = env::var("TARGET").unwrap();

    if target.contains("ohos") {
        println!("cargo:rustc-cfg=is_ohos");
    }
    if target.contains("darwin") {
        println!("cargo:rustc-cfg=is_mac");
    }

    let feature_a = env::var_os("CARGO_FEATURE_MY_FEATURE_A").is_some();
    if feature_a {
        println!("cargo:rustc-cfg=has_feature_a");
    }
    let feature_b = env::var_os("CARGO_FEATURE_MY_FEATURE_B").is_some();
    if feature_b {
        println!("cargo:rustc-cfg=has_feature_b");
    }

    // Some tests as to whether we're properly emulating various cargo features.
    assert!(Path::new("build.rs").exists());
    assert!(Path::new(&amp;env::var_os("CARGO_MANIFEST_DIR").unwrap()).join("build.rs").exists());
    assert!(Path::new(&amp;env::var_os("OUT_DIR").unwrap()).exists());

    // Confirm the following env var is set
    env::var_os("CARGO_CFG_TARGET_ARCH").unwrap();

    generate_some_code().unwrap();
}

fn generate_some_code() -&gt; std::io::Result&lt;()&gt; {
    let test_output_dir = Path::new(&amp;env::var_os("OUT_DIR").unwrap()).join("generated");
    let _ = std::fs::create_dir_all(&amp;test_output_dir);
    // Test that environment variables from .gn files are passed to build scripts
    let preferred_number = env::var("ENV_VAR_FOR_BUILD_SCRIPT").unwrap();
    let mut file = std::fs::File::create(test_output_dir.join("generated.rs"))?;
    write!(file, "fn run_some_generated_code() -&gt; u32 {<!-- -->{ {} }}", preferred_number)?;
    Ok(())
}

fn rustc_minor_version() -&gt; Option&lt;u32&gt; {
    let rustc_bin = match env::var_os("RUSTC") {
        Some(rustc_bin) =&gt; rustc_bin,
        None =&gt; return None,
    };

    let output = match Command::new(rustc_bin).arg("--version").output() {
        Ok(output) =&gt; output,
        Err(_) =&gt; return None,
    };

    let rustc_version = match str::from_utf8(&amp;output.stdout) {
        Ok(rustc_version) =&gt; rustc_version,
        Err(_) =&gt; return None,
    };

    let mut pieces = rustc_version.split('.');
    if pieces.next() != Some("rustc 1") {
        return None;
    }

    let next_var = match pieces.next() {
        Some(next_var) =&gt; next_var,
        None =&gt; return None,
    };

    u32::from_str(next_var).ok()
}
</code></pre>
     </li>
     <li>
      <p>
       配置gn脚本build/rust/tests/test_rlib_cargo_crate/BUILD.gn，如下所示：
      </p>
      <pre><code>import("//build/templates/rust/ohos_cargo_crate.gni")

ohos_cargo_crate("target") {
  crate_name = "test_rlib_crate"
  crate_root = "crate/src/lib.rs"
  sources = [ "crate/src/lib.rs" ]

  #To generate the build_script binary
  build_root = "crate/build.rs"
  build_sources = [ "crate/build.rs" ]
  build_script_outputs = [ "generated/generated.rs" ]

  features = [
    "my-feature_a",
    "my-feature_b",
    "std",
  ]
  rustflags = [
    "--cfg",
    "test_a_and_b",
  ]
  rustenv = [ "ENV_VAR_FOR_BUILD_SCRIPT=45" ]
}

# Exists to test the case that a single crate has both a library and a binary
ohos_cargo_crate("test_rlib_crate_associated_bin") {
  crate_root = "crate/src/main.rs"
  crate_type = "bin"
  sources = [ "crate/src/main.rs" ]

  #To generate the build_script binary
  build_root = "crate/build.rs"
  build_sources = [ "crate/build.rs" ]
  features = [
    "my-feature_a",
    "my-feature_b",
    "std",
  ]
  rustenv = [ "ENV_VAR_FOR_BUILD_SCRIPT=45" ]
  deps = [ ":target" ]
}
</code></pre>
     </li>
     <li>
      <p>
       执行编译得到的可执行文件，运行结果如下：
      </p>
      <p>
      </p>
      <p class="img-center">
       <img alt="test_rlib_cargo_crate" height="90" src="https://i-blog.csdnimg.cn/img_convert/b95aa791f1919ce42b4a00568beac54e.png" width="755"/>
      </p>
     </li>
    </ol>
    <h4>
     其他源码实例
    </h4>
    <p>
     在build/rust/tests目录下有Rust各类型模块的配置实例可供参考：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        用例目录
       </th>
       <th>
        测试功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        build/rust/tests/test_bin_crate
       </td>
       <td>
        用ohos_rust_executable模板在host平台编译可执行文件，在target平台上运行可执行文件。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_static_link
       </td>
       <td>
        测试可执行文件对标准库的静态链接。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_dylib_crate
       </td>
       <td>
        测试对动态库的编译和动态链接功能
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_rlib_crate
       </td>
       <td>
        测试对静态库的编译和静态链接功能
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_proc_macro_crate
       </td>
       <td>
        测试对Rust过程宏的编译和链接功能。提供对不同类型的宏的测试用例。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_cdylib_crate
       </td>
       <td>
        测试将Rust代码编译成C/C++动态库。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_staticlib_crate
       </td>
       <td>
        测试将Rust代码编译成C/C++静态库。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/rust_test_ut
       </td>
       <td>
        测试Rust代码单元测试模板功能（ability）。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/rust_test_st
       </td>
       <td>
        测试Rust代码系统测试模板功能（ability）。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_bin_cargo_crate
       </td>
       <td>
        测试Rust三方可执行文件的编译和运行。三方源码中包含build.rs。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_rlib_cargo_crate
       </td>
       <td>
        测试Rust三方静态库的编译和静态链接。三方源码中包含build.rs。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/test_proc_macro_cargo_crate
       </td>
       <td>
        测试Rust三方过程宏的编译和链接。三方源码中包含build.rs。
       </td>
      </tr>
      <tr>
       <td>
        build/rust/tests/rust_test_fuzzb
       </td>
       <td>
        测试Rust代码Fuzz测试模板功能。
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     参考
    </h3>
    <h4>
     特性点实例
    </h4>
    <h5>
     Rust源码依赖调用C/C++库
    </h5>
    <p>
     OpenHarmony上C/C++模块动态库默认用.z.so后缀，但是Rust的编译命令通过-l链接时，默认只会链接.so后缀的动态库。因此如果要依赖一个C/C++动态库编译模块，需要在该动态库的GN构建文件中添加output_extension = "so"的声明，这样编译得到的动态库将会以".so"作为后缀，而不是".z.so"。 在Rust源码中如果直接链接动态库，后缀也需要使用".so"，这时使用动态库的中间名，不需要添加lib前缀。例如Rust源码中链接libhilog.so:
    </p>
    <pre><code>#[link(name = "hilog")]
</code></pre>
    <h5>
     externs使用
    </h5>
    <p>
     某个模块如果依赖二进制的rlib库，可以使用externs属性：
    </p>
    <pre><code>executable("foo") {
    sources = [ "main.rs" ]
    externs = [{                    # 编译时会转成`--extern bar=path/to/bar.rlib`
        crate_name = "bar"
        path = "path/to/bar.rlib"
    }]
}
</code></pre>
    <h4>
     Lint规则
    </h4>
    <p>
     OpenHarmony框架支持rustc lints和clippy lints两种Lint，每种Lint划为三个等级的标准："openharmony"、"vendor"和"none"，严格程度按照"openharmony" -&gt; "vendor" -&gt; "none"逐级递减。 配置Rust模块时可以通过rustc_lints和clippy_lints来指定使用Lint的等级。 模块中没有配置rustc_lints或者clippy_lints时会根据模块所在路径来匹配lints等级。不同路径下的Rust代码的语法规范会有不同程度地约束，因此用户在OpenHarmony配置Rust代码编译模块时还应关注模块所在路径。
    </p>
    <h5>
     rustc lints和clippy lints的各等级标志
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         lints类型
        </strong>
       </th>
       <th>
        <strong>
         模块属性
        </strong>
       </th>
       <th>
        <strong>
         lints等级
        </strong>
       </th>
       <th>
        <strong>
         lints等级标志
        </strong>
       </th>
       <th>
        <strong>
         lints内容
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        rustc_lints
       </td>
       <td>
        rustc_lints
       </td>
       <td>
        openharmony
       </td>
       <td>
        RustOhosLints
       </td>
       <td>
        "-A deprecated", "-D missing-docs", "-D warnigngs"
       </td>
      </tr>
      <tr>
       <td>
        rustc_lints
       </td>
       <td>
        rustc_lints
       </td>
       <td>
        vendor
       </td>
       <td>
        RustcVendorLints
       </td>
       <td>
        "-A deprecated", "-D warnigs"
       </td>
      </tr>
      <tr>
       <td>
        rustc_lints
       </td>
       <td>
        rustc_lints
       </td>
       <td>
        none
       </td>
       <td>
        allowAllLints
       </td>
       <td>
        "-cap-lints allow"
       </td>
      </tr>
      <tr>
       <td>
        clippy lints
       </td>
       <td>
        clippy lints
       </td>
       <td>
        openharmony
       </td>
       <td>
        ClippyOhosLints
       </td>
       <td>
        "-A clippy::type-complexity", "-A clippy::unnecessary-wraps", "-A clippy::unusual-byte-groupings", "-A clippy::upper-case-acronyms"
       </td>
      </tr>
      <tr>
       <td>
        clippy lints
       </td>
       <td>
        clippy lints
       </td>
       <td>
        vendor
       </td>
       <td>
        ClippyVendorLints
       </td>
       <td>
        "-A clippy::complexity", "-A Clippy::perf", "-A clippy::style"
       </td>
      </tr>
      <tr>
       <td>
        clippy lints
       </td>
       <td>
        clippy lints
       </td>
       <td>
        none
       </td>
       <td>
        allowAllLints
       </td>
       <td>
        "--cap-lints allow"
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     代码路径与lints等级的对应关系
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        路径
       </th>
       <th>
        Lints等级
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        thirdparty
       </td>
       <td>
        none
       </td>
      </tr>
      <tr>
       <td>
        prebuilts
       </td>
       <td>
        none
       </td>
      </tr>
      <tr>
       <td>
        vendor
       </td>
       <td>
        vendor
       </td>
      </tr>
      <tr>
       <td>
        device
       </td>
       <td>
        vendor
       </td>
      </tr>
      <tr>
       <td>
        others
       </td>
       <td>
        openharmony
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-bindgen-cxx-guide.md" rel="nofollow" title="交互工具使用指导">
      交互工具使用指导
     </a>
    </h4>
    <h4>
     <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-cargo2gn-guide.md" rel="nofollow" title="Cargo2gn工具操作指导">
      Cargo2gn工具操作指导
     </a>
    </h4>
    <h2>
     二、Rust 工具链使用说明
    </h2>
    <h3>
     简介
    </h3>
    <p>
     本文用于指导 Rust 语言开发者编译构建 OpenHarmony OS Rust 应用程序。
    </p>
    <p>
     Rust 是一门静态强类型语言，具有更安全的内存管理、更好的运行性能、原生支持多线程开发等优势。
    </p>
    <p>
     本工具链基于开源 rust 与 llvm 增量开发，适配了 OpenHarmony OS target 二进制构建。可将 rust 源码编译成能在 OpenHarmony OS 设备上使用的目标二进制。
    </p>
    <h3>
     使用场景
    </h3>
    <ul>
     <li>
      在 Linux x86环境本地编译 Linux x86 目标二进制或交叉编译 OpenHarmony OS 目标二进制。
     </li>
     <li>
      在 Mac x86 环境本地编译 Mac x86 目标二进制。
     </li>
     <li>
      在 Mac arm64 环境本地编译 Mac arm64 目标二进制。
     </li>
    </ul>
    <h3>
     操作指导
    </h3>
    <h4>
     OpenHarmony 社区代码编译
    </h4>
    <ol>
     <li>
      <p>
       下载或更新环境中 OpenHarmony 社区代码，下载方式可参考
       <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/sourcecode-acquire.md" rel="nofollow" title="获取源码">
        获取源码
       </a>
       。
      </p>
     </li>
     <li>
      <p>
       执行源码中脚本下载安装工具链。
      </p>
      <pre><code>./build/prebuilts_download.sh
</code></pre>
     </li>
     <li>
      <p>
       准备待编译代码。
      </p>
      <p>
       创建 build/rust/tests/test_bin_crate 目录，目录下新建如下所示文件与文件夹。
      </p>
      <pre><code>├── BUILD.gn
└── src
     └── main.rs
</code></pre>
      <p>
       main.rs 代码示例。
      </p>
      <pre><code>//! Hello world example for Rust.

fn main() {
     println!("Hello, world!");
     println!(env!("RUSTENV_TEST"));
}
</code></pre>
      <p>
       BUILD.gn 代码示例。
      </p>
      <pre><code>import("//build/ohos.gni")

ohos_rust_executable("test_bin_crate") {
  sources = [ "src/main.rs" ]
  rustenv = [ "RUSTENV_TEST=123" ]
  features = [ "std" ]
  if (is_mingw) {
    rust_static_link = true
  }
}
</code></pre>
     </li>
     <li>
      <p>
       执行编译命令。
      </p>
      <pre><code>./build.sh --product-name {product_name} --build-target
</code></pre>
      <p>
       以RK3568为例，若要编译，请执行如下命令。
      </p>
      <pre><code>./build.sh --product-name rk3568 --build-target build/rust/tests/test_bin_crate:test_bin_crate –no-prebuilt-sdk
</code></pre>
      <p>
       编译生成的文件。
      </p>
      <pre><code>./out/rk3568/build/build_framework/test_bin_crate
</code></pre>
     </li>
    </ol>
    <h4>
     非OpenHarmony 社区代码编译
    </h4>
    <h5>
     安装 rust 工具链
    </h5>
    <ol>
     <li>
      <p>
       下载 build 仓代码。
      </p>
      <pre><code>git clone git@gitee.com:openharmony/build.git
</code></pre>
     </li>
     <li>
      <p>
       执行脚本下载安装工具链。
      </p>
      <pre><code>./build/prebuilts_download.sh
</code></pre>
     </li>
     <li>
      <p>
       查看安装情况。
      </p>
      <pre><code>./prebuilts/rustc/linux-x86_64/current/bin/rustc --version
</code></pre>
      <p>
       有类似如下显示表示安装成功。
      </p>
      <pre><code>rustc 1.72.0-nightly (xxxx)
</code></pre>
     </li>
    </ol>
    <h5>
     安装 OpenHarmony OS Clang 工具
    </h5>
    <p class="img-center">
     <img alt="icon-note" src="https://i-blog.csdnimg.cn/img_convert/e4def96ef27fe708e185677124f9a82c.gif"/>
    </p>
    <p>
     <em>
      说明
     </em>
    </p>
    <blockquote>
     <p>
      用于在 Linux x86 环境下进行 OpenHarmony OS 的 target 交叉编译，不编译 OpenHarmony OS target 可不安装。
     </p>
    </blockquote>
    <ol>
     <li>
      <p>
       在 OpenHarmony 的最新
       <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/Readme.md" rel="nofollow" title="版本说明">
        版本说明
       </a>
       中获取 SDK 包下载路径
      </p>
      <p class="img-center">
       <img alt="ohos_sdk_download" height="369" src="https://i-blog.csdnimg.cn/img_convert/55c9eba30e5100b084b6e1745060b91b.png" width="840"/>
      </p>
     </li>
     <li>
      <p>
       选择 Linux 环境 SDK 包下载，依次解压下载的压缩包。
      </p>
      <pre><code>mv ohos-sdk-windows_linux-public.tar.gz /opt/
cd /opt/
tar -zxvf ohos-sdk-windows_linux-public.tar.gz
cd ohos-sdk/linux
unzip native-linux-x64-4.1.7.5-Release.zip
</code></pre>
     </li>
    </ol>
    <h5>
     编译代码
    </h5>
    <ol>
     <li>
      <p>
       代码用例main.rs。
      </p>
      <pre><code>fn main() {
  println!("hello world");
}
</code></pre>
     </li>
     <li>
      <p>
       编译 target 为本地环境时命令示例。
      </p>
      <pre><code>./prebuilts/rustc/linux-x86_64/current/bin/rustc main.rs
</code></pre>
      <p>
       执行构建结果。
      </p>
      <pre><code>./main
hello world
</code></pre>
     </li>
     <li>
      <p>
       编译 target 为 armv7-unknown-linux-ohos时命令示例。
      </p>
      <pre><code>./prebuilts/rustc/linux-x86_64/current/bin/rustc main.rs --target=armv7-unknown-linux-ohos -C linker=/opt/ohos-sdk/linux/native/llvm/bin/armv7-unknown-linux-ohos-clang
</code></pre>
     </li>
     <li>
      <p>
       编译 target 为 aarch64-unknown-linux-ohos时命令示例。
      </p>
      <pre><code>./prebuilts/rustc/linux-x86_64/current/bin/rustc main.rs --target=aarch64-unknown-linux-ohos -C linker=/opt/ohos-sdk/linux/native/llvm/bin/aarch64-unknown-linux-ohos-clang
</code></pre>
     </li>
     <li>
      <p>
       编译 target 为 x86_64-unknown-linux-ohos时命令示例。
      </p>
      <pre><code>./prebuilts/rustc/linux-x86_64/current/bin/rustc main.rs --target=x8</code></pre>
     </li>
    </ol>
    <h2>
     三、Cargo2gn工具操作指导
    </h2>
    <h3>
     概述
    </h3>
    <p>
     rust三方库使用cargo编译，配置为Cargo.toml。集成到OpenHarmony上需要转换成BUILD.gn规则。为了满足这个需求，需要提供一个cargo2gn转换工具。当需要引入rust三方crate时使用cargo2gn转换工具来把三方库的Cargo.toml转换成BUILD.gn规则。cargo2gn可以单个库进行转换，也可以多个库进行批量转换。
    </p>
    <h3>
     单个库转换操作步骤
    </h3>
    <ol>
     <li>
      <p>
       进入到需要转化的rust三方库的目录下，比如需要转化bindgen。
      </p>
      <pre><code>cd openharmony/third_party/rust/bindgen
</code></pre>
     </li>
     <li>
      <p>
       创建配置文件cargo2gn.json，可以参考如下配置。
      </p>
      <pre><code>{
    "copy-out": true,
    "run": true,
    "add-workspace": true,
    "cargo-bin": "/mnt/xxx/openharmony/prebuilts/rustc/linux-x86_64/current/bin"
}
</code></pre>
     </li>
     <li>
      <p>
       执行以下命令进行转换。
      </p>
      <pre><code>python3 /mnt/xxx/openharmony/build/scripts/cargo2gn.py --config cargo2gn.json
</code></pre>
      <p>
       转换结果
      </p>
      <pre><code>import("//build/templates/rust/ohos_cargo_crate.gni")

ohos_cargo_crate("lib") {
    crate_name = "bindgen"
    crate_type = "rlib"
    crate_root = "./lib.rs"

    sources = ["./lib.rs"]
    edition = "2018"
    cargo_pkg_version = "0.64.0"
    cargo_pkg_authors = "Jyun-Yan You &lt;jyyou.tw@gmail.com&gt;,  Emilio Cobos Álvarez &lt;emilio@crisal.io&gt;,  Nick Fitzgerald &lt;fitzgen@gmail.com&gt;,  The Servo project developers"
    cargo_pkg_name = "bindgen"
    cargo_pkg_description = "Automatically generates Rust FFI bindings to C and C++ libraries."
    deps = [
        "//third_party/rust/bitflags:lib",
        "//third_party/rust/cexpr:lib",
        "//third_party/rust/clang-sys:lib",
        "//third_party/rust/lazy_static:lib",
        "//third_party/rust/lazycell:lib",
        "//third_party/rust/log:lib",
        "//third_party/rust/peeking_take_while:lib",
        "//third_party/rust/proc-macro2:lib",
        "//third_party/rust/quote:lib",
        "//third_party/rust/regex:lib",
        "//third_party/rust/rustc-hash:lib",
        "//third_party/rust/shlex:lib",
        "//third_party/rust/syn:lib",
        "//third_party/rust/which:lib",
    ]
    features = [
        "default",
        "log",
        "logging",
        "static",
        "which",
        "which-rustfmt",
    ]
    build_root = "build.rs"
    build_sources = ["build.rs"]
    build_script_outputs = ["host-target.txt"]
}
</code></pre>
     </li>
    </ol>
    <h3>
     多个库批量转换操作步骤
    </h3>
    <ol>
     <li>
      <p>
       进入到rust目录下。
      </p>
      <pre><code>cd openharmony/third_party/rust
</code></pre>
     </li>
     <li>
      <p>
       把所有需要转换的rust三方库添加到rust目录下的Cargo.toml的[workspace]里，如下所示。
      </p>
      <pre><code>[workspace]
members = [
    "aho-corasick",
    "memchr",
]
</code></pre>
     </li>
     <li>
      <p>
       执行单个库转换操作步骤的2和3。
      </p>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f62656e636f313938362f:61727469636c652f64657461696c732f313436323833363232" class_="artid" style="display:none">
 </p>
</div>


