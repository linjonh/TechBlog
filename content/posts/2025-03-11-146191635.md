---
layout: post
title: "Linux进程基础知识"
date: 2025-03-11 23:20:00 +0800
description: "进程就是运行中的程序，是系统资源分配的基本单位每个进程都有唯一的PID（进程ID）进程有父子关系，通过ps -ef可以查看。"
keywords: "Linux进程基础知识"
categories: ['未分类']
tags: ['运维', '服务器', 'Linux']
artid: "146191635"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146191635
    alt: "Linux进程基础知识"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146191635
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146191635
cover: https://bing.ee123.net/img/rand?artid=146191635
image: https://bing.ee123.net/img/rand?artid=146191635
img: https://bing.ee123.net/img/rand?artid=146191635
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux进程基础知识
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     1. 什么是进程？
    </h4>
    <ul>
     <li>
      进程就是运行中的程序，是系统资源分配的基本单位
     </li>
    </ul>
    <ul>
     <li>
      每个进程都有唯一的PID（进程ID）
     </li>
    </ul>
    <ul>
     <li>
      进程有父子关系，通过ps -ef可以查看
     </li>
    </ul>
    <h4>
     2. 进程的创建 - fork()
    </h4>
    <pre><code class="hljs">pid_t pid = fork();</code></pre>
    <p>
     - 简单理解：fork()就像细胞分裂，一个变两个
    </p>
    <ul>
     <li>
      调用一次，返回两次：父进程得到子进程PID，子进程得到0
     </li>
    </ul>
    <ul>
     <li>
      子进程是父进程的复制品
     </li>
    </ul>
    <h4>
     3. 进程的程序替换 - exec族
    </h4>
    <pre><code class="hljs">execl("/bin/ls", "ls", "-l", NULL);</code></pre>
    <p>
     - 保留进程ID，但内容完全变成新程序
    </p>
    <ul>
     <li>
      就像换灵魂：外壳不变，内在全变
     </li>
    </ul>
    <ul>
     <li>
      常用函数：execl, execlp, execle, execv, execvp等
     </li>
    </ul>
    <h4>
     4. 进程的等待与回收 - wait/waitpid
    </h4>
    <pre><code class="hljs">pid_t wait(int *status);

pid_t waitpid(pid_t pid, int *status, int options);</code></pre>
    <p>
     - 父进程等待子进程结束并回收资源
    </p>
    <ul>
     <li>
      避免僵尸进程（zombie）的产生
     </li>
    </ul>
    <ul>
     <li>
      waitpid比wait更灵活，可以非阻塞等待
     </li>
    </ul>
    <h4>
     5. 进程的退出
    </h4>
    <p>
     exit(0);    // 标准C库函数
    </p>
    <p>
     _exit(0);   // 系统调用
    </p>
    <ul>
     <li>
      exit会刷新缓冲区，exit直接退出
     </li>
    </ul>
    <ul>
     <li>
      返回值0表示正常退出
     </li>
    </ul>
    <h3>
     一. 文件操作与I/O
    </h3>
    <h4>
     1. 文件描述符
    </h4>
    <ul>
     <li>
      就像文件的"身份证号码"
     </li>
    </ul>
    <ul>
     <li>
      标准输入(0)、标准输出(1)、标准错误(2)
     </li>
    </ul>
    <ul>
     <li>
      每个进程最多可打开的文件数有限制
     </li>
    </ul>
    <h4>
     2. 文件操作基本函数
    </h4>
    <pre><code class="hljs">// 打开文件

int fd = open("test.txt", O_RDWR | O_CREAT, 0644);

// 读取文件

char buf[1024];

int n = read(fd, buf, sizeof(buf));

// 写入文件

write(fd, "hello", 5);

// 关闭文件

close(fd);

// 文件指针定位

lseek(fd, 0, SEEK_SET);  // 回到文件开头</code></pre>
    <p>
    </p>
    <h4>
     3. 文件属性获取
    </h4>
    <pre><code class="hljs">struct stat st;

stat("file.txt", &amp;st);



- 获取文件大小：st.st_size</code></pre>
    <ul>
     <li>
      判断文件类型：S_ISREG(st.st_mode)、S_ISDIR(st.st_mode)
     </li>
    </ul>
    <h4>
     4. 目录操作
    </h4>
    <pre><code class="hljs">DIR *dir = opendir(".");

struct dirent *entry;

while ((entry = readdir(dir)) != NULL) {

    printf("%s\n", entry-&gt;d_name);

}

closedir(dir);</code></pre>
    <p>
    </p>
    <h3>
     三、进程间通信(IPC)
    </h3>
    <h4>
     1. 管道通信
    </h4>
    <pre><code class="hljs">int fd[2];

pipe(fd);  // fd[0]读端，fd[1]写端</code></pre>
    <ul>
     <li>
      单向通信：水管模型，一端进一端出
     </li>
    </ul>
    <ul>
     <li>
      只能用于有亲缘关系的进程
     </li>
    </ul>
    <ul>
     <li>
      适合简单的数据传输
     </li>
    </ul>
    <h4>
     2. 命名管道(FIFO)
    </h4>
    <pre><code class="hljs">// 创建命名管道

mkfifo("myfifo", 0644);

// 使用方法与普通文件类似

int fd = open("myfifo", O_WRONLY);</code></pre>
    <p>
     - 可用于无关进程间通信
    </p>
    <ul>
     <li>
      遵循先进先出原则
     </li>
    </ul>
    <h4>
     3. 信号通信
    </h4>
    <pre><code class="hljs">// 信号处理函数

void sig_handler(int signo) {

    printf("收到信号: %d\n", signo);

}

// 设置信号处理

signal(SIGINT, sig_handler);</code></pre>
    <p>
     - 常见信号：
    </p>
    <ul>
     <li>
      SIGINT (2): Ctrl+C中断
     </li>
    </ul>
    <ul>
     <li>
      SIGKILL (9): 强制终止(不可捕获)
     </li>
    </ul>
    <ul>
     <li>
      SIGTERM (15): 终止信号
     </li>
    </ul>
    <ul>
     <li>
      SIGCHLD (17): 子进程状态改变
     </li>
    </ul>
    <ul>
     <li>
      SIGALRM (14): 定时器到期
     </li>
    </ul>
    <h3>
     四、实用示例
    </h3>
    <h4>
     1. 创建守护进程
    </h4>
    <pre><code class="hljs">void daemonize() {

    pid_t pid = fork();

    if (pid &lt; 0) exit(1);

    if (pid &gt; 0) exit(0);  // 父进程退出

    

    setsid();  // 创建新会话

    

    // 关闭标准输入输出错误

    close(0);

    close(1);

    close(2);

    // ...更多操作

}</code></pre>
    <p>
    </p>
    <h4>
     2. 简单shell实现
    </h4>
    <pre><code class="hljs">while (1) {

    printf("myshell&gt; ");

    fgets(cmd, sizeof(cmd), stdin);

    

    if (fork() == 0) {

        // 子进程执行命令

        execlp(cmd, cmd, NULL);

        exit(0);

    } else {

        // 父进程等待

        wait(NULL);

    }

}</code></pre>
    <p>
    </p>
    <h3>
     五、常见错误与调试技巧
    </h3>
    <h4>
     1. 经典错误
    </h4>
    <ul>
     <li>
      僵尸进程：子进程结束但未被回收
     </li>
    </ul>
    <ul>
     <li>
      孤儿进程：父进程先于子进程结束
     </li>
    </ul>
    <ul>
     <li>
      内存泄漏：申请的内存未释放
     </li>
    </ul>
    <ul>
     <li>
      文件描述符泄漏：打开文件未关闭
     </li>
    </ul>
    <h4>
     2. 调试工具
    </h4>
    <ul>
     <li>
      strace：跟踪系统调用
     </li>
    </ul>
    <ul>
     <li>
      gdb：代码调试器
     </li>
    </ul>
    <ul>
     <li>
      valgrind：内存错误检测
     </li>
    </ul>
    <ul>
     <li>
      lsof：查看打开的文件
     </li>
    </ul>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343331393933332f:61727469636c652f64657461696c732f313436313931363335" class_="artid" style="display:none">
 </p>
</div>


