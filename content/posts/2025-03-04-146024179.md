---
layout: post
title: "每日八股计算机网络篇三IP"
date: 2025-03-04 20:39:25 +0800
description: "根据 csview 整理计网中 IP 部分的八股。"
keywords: "【每日八股】计算机网络篇（三）：IP"
categories: ['计算机网络']
tags: ['计算机网络']
artid: "146024179"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146024179
    alt: "每日八股计算机网络篇三IP"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146024179
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146024179
cover: https://bing.ee123.net/img/rand?artid=146024179
image: https://bing.ee123.net/img/rand?artid=146024179
img: https://bing.ee123.net/img/rand?artid=146024179
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【每日八股】计算机网络篇（三）：IP
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="DNS__1">
     </a>
     DNS 查询服务器的基本流程
    </h2>
    <ol>
     <li>
      首先，用户在浏览器输入域名后，浏览器会先检查自身缓存，若缓存中存在且未过期，则直接返回对应的 IP 地址。若浏览器中无缓存，则操作系统检查本地 Hosts 文件和系统 DNS 缓存。
     </li>
     <li>
      若前两步骤未命中，则向本地 DNS 服务器发送递归查询请求；
     </li>
     <li>
      本地 DNS 服务器无缓存，则以 DNS 客户的身份向
      <strong>
       根域名
      </strong>
      服务器发出解析请求；
     </li>
     <li>
      <strong>
       根域名
      </strong>
      服务器收到请求后，判断该域名所属域，将对应的
      <strong>
       顶级域名服务器
      </strong>
      的 IP 地址返回给本地域名服务器；
     </li>
     <li>
      本地域名服务器向
      <strong>
       顶级域名服务器
      </strong>
      发出解析请求报文；
     </li>
     <li>
      顶级域名服务器收到请求后，将对应的
      <strong>
       授权域名服务器
      </strong>
      的 IP 地址返回给本地域名服务器；
     </li>
     <li>
      本地域名服务器向授权域名服务器发起解析请求；
     </li>
     <li>
      授权域名服务器收到请求后，将
      <strong>
       查询结果返回给本地域名服务器
      </strong>
      ；
     </li>
     <li>
      本地域名服务器将查询结果保存到
      <strong>
       本地缓存
      </strong>
      ，同时将 IP 地址返回给客户机；
     </li>
     <li>
      用户通过获得的 IP 地址与目标服务器建立 TCP 连接，然后开始传输数据。
     </li>
    </ol>
    <h2>
     <a id="DNS__TCP__UDP_13">
     </a>
     DNS 采用 TCP 还是 UDP，为什么？
    </h2>
    <p>
     DNS 主要使用 UDP（用户数据报协议），但在某些特定场景下会切换到 TCP（传输控制协议）。具体原因如下：
    </p>
    <h3>
     <a id="_UDP__15">
     </a>
     默认使用 UDP 的原因
    </h3>
    <p>
     <strong>
      高效性
     </strong>
     ：UDP 是无连接的协议，
     <strong>
      无需建立和断开连接
     </strong>
     ，减少了通信延迟。DNS 查询通常是简单的
     <strong>
      请求-响应
     </strong>
     模式，UDP 能更快地完成
     <strong>
      单次
     </strong>
     交互。
    </p>
    <p>
     <strong>
      小数据包的适用性
     </strong>
     ：DNS 的查询和响应通常较小（不超过 512 字节），UDP 单词传输即可满足需求。
    </p>
    <p>
     <strong>
      低资源消耗
     </strong>
     ：UDP 的头部开销更小（8 字节 vs. TCP 的 20 字节），适合高频的 DNS 查询场景。
    </p>
    <h3>
     <a id="_TCP__22">
     </a>
     需要使用 TCP 的场景？
    </h3>
    <p>
     <strong>
      响应数据过大
     </strong>
     ：当 DNS 响应数据超过 512 字节（超过 UDP 的最大限制）时，服务器会返回截断标志（TC 位），客户端改用 TCP 重新请求（TCP 支持分段传输）。
    </p>
    <p>
     <strong>
      区域传输
     </strong>
     ：主 DNS 服务器向从服务器同步全量区域数据时，需通过 TCP 端口 53 完成，确保大量数据的可靠传输。
    </p>
    <p>
     <strong>
      DNSSEC 拓展
     </strong>
     ：启用 DNSSEC （DNS 安全拓展）后，数字签名会增加响应大小，可能超过 UDP 限制，强制使用 TCP。
    </p>
    <p>
     <strong>
      可靠性要求
     </strong>
     ：TCP 提供丢包重传、按需到达等机制，适合数据完整性要求高的场景（比如关键配置同步）。
    </p>
    <h3>
     <a id="_31">
     </a>
     总结
    </h3>
    <p>
     <strong>
      常规查询
     </strong>
     ：UDP（快速、高效）；
    </p>
    <p>
     <strong>
      大规模传输及可靠性要求
     </strong>
     ：TCP（如区域传输、大响应、DNSSEC）。
    </p>
    <h2>
     <a id="DNS__36">
     </a>
     DNS 劫持是什么？解决办法？
    </h2>
    <p>
     DNS 劫持是一种网络攻击手段，
     <strong>
      攻击者通过篡改域名解析结果，将用户引导至虚假网站或插入广告
     </strong>
     。
    </p>
    <p>
     常见形式如下：
    </p>
    <ul>
     <li>
      路由器劫持：攻击者入侵路由器修改 DNS 设置；
     </li>
     <li>
      本地劫持：恶意软件修改设备 hosts 文件或 DNS 配置；
     </li>
     <li>
      ISP 劫持：网络服务商主动劫持用于广告投放；
     </li>
     <li>
      中间人攻击：在传输链路中截获并篡改 DNS 响应。
     </li>
    </ul>
    <p>
     解决办法：
    </p>
    <ul>
     <li>
      更换可信 DNS；
     </li>
     <li>
      设备检查；
     </li>
     <li>
      路由器防护；
     </li>
     <li>
      网络加密；
     </li>
     <li>
      定期更换重要账户密码；
     </li>
     <li>
      启用双重身份验证；
     </li>
     <li>
      使用网络监控工具（比如 Wireshark）检测异常请求；
     </li>
    </ul>
    <h2>
     <a id="_URL__54">
     </a>
     浏览器输入一个 URL 到显示器显示的过程？
    </h2>
    <h3>
     <a id="URL__55">
     </a>
     URL 解析
    </h3>
    <p>
     用户在浏览器输入域名后，浏览器首先从自身的缓存中查找是否存在域名，存在就取出对应的 IP 地址，否则去 OS 缓存查找。前两步均未命中的情况下，浏览器调用 OS 的 API 使操作系统开启 DNS 解析服务，递归地从本地 DNS 到 根域 DNS 再到顶级域 DNS 最后到权威域 DNS 请求解析，最终由权威域 DNS 返回域名的 IP 地址，浏览器会对其进行缓存。
    </p>
    <h3>
     <a id="TCP__57">
     </a>
     TCP 连接
    </h3>
    <p>
     在 URL 解析过程中得到真实的 IP 地址后，浏览器会调用 Socket 函数，根据 IP 和端口与目标建立 TCP 连接。
    </p>
    <h3>
     <a id="HTTP__60">
     </a>
     HTTP 请求
    </h3>
    <p>
     浏览器向服务器发送一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的 TCP 连接之上，按照 HTTP 协议标准发送一个索要网页的请求。请求包括请求行、请求头、请求体三部分，
     <strong>
      有 GET、POST 等方法
     </strong>
     。
    </p>
    <h3>
     <a id="_63">
     </a>
     页面渲染
    </h3>
    <p>
     服务器在收到浏览器发送的 HTTP 请求之后，会将收到的 HTTP 报文封装成 HTTP Request 对象，并通过不同的 Web 服务器进行处理，处理完的结果以 HTTP Response 对象的形式返回，包括状态码、响应头和响应报文三部分。
    </p>
    <h3>
     <a id="_66">
     </a>
     断开连接
    </h3>
    <p>
     数据传输完毕后，客户端和服务端通过四次挥手断连。
    </p>
    <h2>
     <a id="PING__69">
     </a>
     PING 如何工作？
    </h2>
    <p>
     PING（Packet Internet Groper）是一种网络诊断工具，用于测试两台设备之间的连通性。其核心原理是通过 ICMP 协议（Internet Control Message Protocol）发送探测数据包并等待响应。
    </p>
    <blockquote>
     <p>
      ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置等。在IP通信中如果某个IP包因为某种原因未能达到目标地址，具体的原因将由ICMP通知。
     </p>
    </blockquote>
    <p>
     PING 的工作流程如下：
    </p>
    <ol>
     <li>
      发送 Echo Request：首先源设备构造一个 ICMP Echo Request 数据包，包括目标 IP、序列号和时间戳；
     </li>
     <li>
      数据包经过路由器逐跳转发，没经过一个路由，TTL 减一，若 TTL 归零，则路由器丢弃包并返回 ICMP Time Exceeded 消息；
     </li>
     <li>
      目标设备收到 Echo Request 后，检查 ICMP 报文合法性，构造 ICMP Echo Reply 报文，将 Reply 发回源设备；
     </li>
     <li>
      源设备收到 Echo Reply 之后，计算往返时间 RTT，统计丢包率。
     </li>
    </ol>
    <h2>
     <a id="Cookie__Session__79">
     </a>
     Cookie 和 Session 的区别是什么？
    </h2>
    <h3>
     <a id="Cookie_80">
     </a>
     Cookie
    </h3>
    <p>
     Cookie 是服务器发送到用户浏览器
     <strong>
      并保存在本地的一小块数据
     </strong>
     ，它会
     <strong>
      在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上
     </strong>
     。通常，它用于告知服务器两个请求是否来自同一浏览器。
    </p>
    <p>
     <strong>
      作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      会话状态管理（如用户登录状态、购物车、游戏分数等其它需要记录的信息）；
     </li>
     <li>
      个性化设置（如用户自定义设置、主题等）；
     </li>
     <li>
      浏览器行为跟踪（分析用户行为等）；
     </li>
    </ul>
    <h3>
     <a id="Session_88">
     </a>
     Session
    </h3>
    <p>
     Session代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。
    </p>
    <h3>
     <a id="_91">
     </a>
     差别
    </h3>
    <ul>
     <li>
      <strong>
       保存形式不同
      </strong>
      ：Cookie 保存在客户端（浏览器），Session 保存在服务器；
     </li>
     <li>
      <strong>
       存取方式不同
      </strong>
      ：Cookie 只能保存 ASCII，Session 可保存任意数据类型；
     </li>
     <li>
      <strong>
       有效期不同
      </strong>
      ：Cookie 可设置为长时间保持，比如默认登录；Session 一般时效较短，客户端关闭或超时，Session 都会失效。
     </li>
     <li>
      <strong>
       存储大小不同
      </strong>
      ：单个 Cookie 保存的数据不超过 4K，Session 可存储的数据远高于 Cookie。
     </li>
    </ul>
    <h2>
     <a id="IPv4__IPv6__97">
     </a>
     IPv4 和 IPv6 的区别？
    </h2>
    <ul>
     <li>
      IPv6 的首部长度是 40 个字节，相对 IPv4 的首部长度 24 字节要长，但 IPv6 首部结构比 IPv4 简单。
     </li>
     <li>
      <strong>
       IPv6 把 IP 地址由 32 位增加到 128 位，从而能够支持更大的地址空间
      </strong>
      。IPv6 简化了路由， 加快了路由速度。
     </li>
     <li>
      IPv6 的可选项不放入报头，而是放在一个个独立的扩展头部。如果不指定路由器不会打开处理扩展头部， IPv6 放宽了对可选项长度的严格要求 (IPv4 的可选项总长最多为 40 字节) ，并可根据需要随时引入新选项。
     </li>
     <li>
      IPv6 协议支持地址自动配置，这是一种即插即用的机制。IPv6 节点通过地址自动配置得到 IPv6 地址和网关地址。IPv6 支持无状态地址自动配置和状态地址自动配置两种地址自动配置方式。它会给配置 128 位的地址带来很大的方便，特别是无状态地址自动配置。
     </li>
     <li>
      在 IPv6 中加入了关于身份验证、数据一致性和保密性的内容。
     </li>
    </ul>
    <h2>
     <a id="_104">
     </a>
     什么是跨域？什么情况下会发生跨域请求？
    </h2>
    <h3>
     <a id="_105">
     </a>
     概念
    </h3>
    <p>
     跨域（Cross-Origin）是指浏览器出于安全考虑，限制不同源（协议、域名、端口）之间的资源交互。常见的跨域场景包括：
    </p>
    <ul>
     <li>
      前后端分离开发时，前端
      <code>
       localhost:3000
      </code>
      调用后端
      <code>
       localhost:8080
      </code>
      ；
     </li>
     <li>
      调用第三方 API（如支付接口、地图服务）；
     </li>
     <li>
      多子域名系统；
     </li>
     <li>
      CDN 资源加载；
     </li>
    </ul>
    <h3>
     <a id="_112">
     </a>
     解决办法
    </h3>
    <ul>
     <li>
      Nginx：使用 Nginx 作为代理服务器和用户交互，用户就只需要在 80 端口上进行交互就可以了，这样就避免了跨域问题。
     </li>
     <li>
      JSONP：网页通过添加一个 script 元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。
      <strong>
       缺点是只支持 get 请求，不支持 post 请求
      </strong>
      。
     </li>
     <li>
      CORS：跨域资源分享。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f436f666665656d616b657238382f:61727469636c652f64657461696c732f313436303234313739" class_="artid" style="display:none">
 </p>
</div>


