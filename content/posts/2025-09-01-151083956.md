---
layout: post
title: "Linux-孤儿进程-Orphan-Process"
date: 2025-09-01T21:43:57+0800
description: "孤儿进程是指在父进程执行完毕并终止后，其仍然还在运行的一个或多个子进程。简单来说，就是一个孩子还在，但它的父母已经不在了。⽗进程如果提前退出，那么子进程后退出，进⼊“Z”状态后，那该如何处理呢？父进程先退出，子进程就称之为 “孤儿进程”孤儿进程被1号systemd进程领养孤儿进程是活进程：它还在运行，只是父亲没了。内核安全网：内核通过让init 进程（PID 1）自动收养所有孤儿进程来避免问题。这是一个关键的设计，保证了系统的健壮性。无害性。"
keywords: "Linux 孤儿进程 (Orphan Process)"
categories: ['未分类']
tags: ['孤儿进程', 'Process', 'Orphan', 'Linux', 'C']
artid: "151083956"
arturl: "https://blog.csdn.net/2401_87692970/article/details/151083956"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151083956
    alt: "Linux-孤儿进程-Orphan-Process"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151083956
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151083956
cover: https://bing.ee123.net/img/rand?artid=151083956
image: https://bing.ee123.net/img/rand?artid=151083956
img: https://bing.ee123.net/img/rand?artid=151083956
---



# Linux 孤儿进程 (Orphan Process)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/90435f49292b4dd29cffa1925f469cad.gif#pic_center)

---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/44cbb4e422ec4cbbac9422dc3a93fd21.jpeg#pic_center)

---

**🎁个人主页：**[工藤新一¹](https://blog.csdn.net/2401_87692970?type=lately)

**🔍系列专栏：**[C++面向对象（类和对象篇）](https://blog.csdn.net/2401_87692970/category_12916875.html?spm=1001.2014.3001.5482)

🌟**心中的天空之城，终会照亮我前方的路**

**🎉欢迎大家点赞👍评论📝收藏⭐文章**

---

## 孤儿进程

### 一、核心定义

**孤儿进程是指在父进程执行完毕并终止后，其仍然还在运行的一个或多个子进程。**

简单来说，就是一个孩子还在，但它的父母已经不在了。

> * ⽗进程如果提前退出，那么子进程后退出，进⼊“Z”状态后，那该如何处理呢？
> * **父进程先退出，子进程就称之为 “孤儿进程”**
> * 孤儿进程被1号 `systemd` 进程领养

---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f59aa7f36c354a26809323ae46ac7f88.png)

---

### 二、 产生过程与内核的应对机制

**孤儿进程**的产生是一个自然的过程，但操作系统（内核）有一个非常重要的机制来妥善处理它，以**避免资源泄露**。

1. **正常情况**：一个父进程创建了一个或多个子进程。在理想情况下，父进程应该使用 `wait()` 或 `waitpid()` 系统调用来等待其子进程结束，从而**回收子进程的退出状态和资源**（主要是进程描述符 `task_struct` 和 `PCB` 中的其他信息）。这样可以避免产生僵尸进程（Zombie Process）。
2. **异常情况**：如果父进程先于其子进程终止了，会发生什么？
   * 这些子进程瞬间就变成了“孤儿”。
   * 内核深知不能对这些孤儿坐视不管。如果没人回收它们，它们终止后会永远变成僵尸，占用系统资源。
   * 为了解决这个问题，内核会**强制地将 systemd 进程（PID 1） 设置为这些孤儿进程的新父进程**。这个过程称为“重新收养”（re-parenting）。

---

> **systemd(init) 进程是什么？**  
>  Init 进程是系统启动后由内核创建的第一个用户进程。它非常特殊：
>
> * 它的 `PID` 永远是1。
> * 它是所有用户进程的祖先。
> * 它永远不会终止，会一直运行直到系统关闭。
> * 它的一个核心职责就是收养系统中的所有孤儿进程，并负责等待它们结束。

---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ff19d94e544b4803afcf9deb5a5e7f1f.png)

---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/21e0b9659bd6488aaedd58096574725b.png)

---

**问题1：为什么父进程很少被描述为 孤儿/僵尸进程？**

因为父进程也有其自己的父进程：**`bash`**；父进程随便退出，**`bash`** 进程会自动对其回收

---

**问题2：进程变为孤儿进程后，会直接被系统领养，会自动成为后台进程**

**将进程放到后台（Background）** 运行：`./cmd &`

* `./cmd`：执行当前目录下的一个名为 `cmd` 的可执行文件
* `&`（按位与）：一个**控制操作符（control operator）**，它告诉 Shell（如 Bash）**不要等待命令 `./cmd` 结束，而是立即返回一个提示符**，并让 `./cmd` 在后台继续运行

此时，我们无法使用 `Ctrl + C` kill 掉进程（后台进程）

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3ec0096d266f4c1899dcd0faac8ee27f.png)

只能通过远端 **`kill -9 pid`** 杀死当前进程

---

### 三、孤儿进程 vs. 僵尸进程

这是一个非常重要的区别，经常被一起讨论和比较：

| 特征 | **孤儿进程 (Orphan Process)** | **僵尸进程 (Zombie Process)** |
| --- | --- | --- |
| **定义** | **活着的进程**，但其父进程已死。 | **已终止的进程**，但其父进程未回收它。 |
| **状态** | 仍然是 **TASK_RUNNING** 或 **TASK_INTERRUPTIBLE** 等**活动状态**。 | 处于 **EXIT_ZOMBIE** 状态。**已经死了**，但在进程表中仍保留一个条目。 |
| **危害** | **无害**。内核机制（`systemd` 收养）确保了它终止后会被正常回收。 | **有害**。占用内核进程表 slot（资源泄露），如果过多会导致无法创建新进程。 |
| **成因** | 父进程先于子进程终止。 | 父进程未调用 `wait()` 系列函数，且父进程还活着（或者异常崩溃未来得及回收）。 |
| **解决方式** | 无需手动解决，由内核自动处理。 | 需要让父进程调用 `wait()` 来回收，或者终止父进程（此时僵尸会被init回收）。 |

---

### 四、总结与要点

1. **孤儿进程是活进程**：它还在运行，只是父亲没了。
2. **内核安全网**：内核通过让 **init 进程（PID 1）自动收养**所有孤儿进程来避免问题。这是一个关键的设计，保证了系统的健壮性。
3. **无害性**：孤儿进程本身不是一个问题或 bug，它是一种被系统妥善管理的正常状态。当一个孤儿进程最终终止时，它的养父init进程会自动为它调用 `wait()`，从而回收其资源，**它不会变成僵尸**。
4. **与僵尸进程的区别**：最关键的区别在于**是死是活**。孤儿是“活孤儿”，僵尸是“死僵尸”。僵尸进程才是需要开发者警惕和避免的资源泄露问题。

---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c42e3f2a8ee24a29abfbeb669a31b192.gif#pic_center)

🌟 **各位看官好**，**我是[工藤新一¹呀~](https://blog.csdn.net/2401_87692970?type=lately)**

**🌈** **愿各位心中所想，终有所致！**



