---
layout: post
title: "54.-螺旋矩阵C"
date: 2025-03-11 20:39:20 +0800
description: "为了实现这个目标，我们采用了一种边界控制的方法，通过定义矩阵的四个边界（左、右、上、下），并按照顺时针方向依次遍历这些边界上的元素，同时不断收缩边界，直到遍历完整个矩阵。给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]"
keywords: "54. 螺旋矩阵（C++）"
categories: ['Leetcode']
tags: ['算法', '矩阵', 'C']
artid: "146188510"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146188510
    alt: "54.-螺旋矩阵C"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146188510
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146188510
cover: https://bing.ee123.net/img/rand?artid=146188510
image: https://bing.ee123.net/img/rand?artid=146188510
img: https://bing.ee123.net/img/rand?artid=146188510
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     54. 螺旋矩阵（C++）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     题目
    </h3>
    <p>
     给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
     <br/>
     示例 1：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e27825bbcea84f1195fbe21711c9a2c9.png"/>
    </p>
    <p>
     输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
     <br/>
     输出：[1,2,3,6,9,8,7,4,5]
     <br/>
     示例 2：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/69a9e1215f4943c59ca9eada83674186.png"/>
    </p>
    <p>
     输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
     <br/>
     输出：[1,2,3,4,8,12,11,10,9,5,6,7]
    </p>
    <p>
     提示：
    </p>
    <p>
     m == matrix.length
     <br/>
     n == matrix[i].length
     <br/>
     1 &lt;= m, n &lt;= 10
     <br/>
     -100 &lt;= matrix[i][j] &lt;= 100
    </p>
    <h3>
     <a id="_22">
     </a>
     题解
    </h3>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>

        <span class="token keyword">int</span> rows <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> cols <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> cols <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> rows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 从左到右遍历上边界</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> left<span class="token punctuation">;</span> col <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            top<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token comment">// 从上到下遍历右边界</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> top<span class="token punctuation">;</span> row <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>

            <span class="token comment">// 若上下边界未重合，从右到左遍历下边界</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> right<span class="token punctuation">;</span> col <span class="token operator">&gt;=</span> left<span class="token punctuation">;</span> col<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                bottom<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 若左右边界未重合，从下到上遍历左边界</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> bottom<span class="token punctuation">;</span> row <span class="token operator">&gt;=</span> top<span class="token punctuation">;</span> row<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="_70">
     </a>
     算法原理
    </h3>
    <h4>
     <a id="_71">
     </a>
     整体目标
    </h4>
    <p>
     该算法的目标是按照顺时针螺旋顺序遍历一个二维矩阵，并将遍历到的元素依次存储在一个一维向量中返回。为了实现这个目标，我们采用了一种边界控制的方法，通过定义矩阵的四个边界（左、右、上、下），并按照顺时针方向依次遍历这些边界上的元素，同时不断收缩边界，直到遍历完整个矩阵。
    </p>
    <h5>
     <a id="1__73">
     </a>
     1. 初始化边界
    </h5>
    <p>
     在开始遍历之前，我们需要明确矩阵的边界信息。假设矩阵有
     <code>
      m
     </code>
     行
     <code>
      n
     </code>
     列，我们定义四个变量来表示矩阵的边界：
    </p>
    <ul>
     <li>
      <code>
       left
      </code>
      ：矩阵左边界的列索引，初始值为 0。
     </li>
     <li>
      <code>
       right
      </code>
      ：矩阵右边界的列索引，初始值为
      <code>
       n - 1
      </code>
      。
     </li>
     <li>
      <code>
       top
      </code>
      ：矩阵上边界的行索引，初始值为 0。
     </li>
     <li>
      <code>
       bottom
      </code>
      ：矩阵下边界的行索引，初始值为
      <code>
       m - 1
      </code>
      。
     </li>
    </ul>
    <p>
     这些边界变量将帮助我们确定每次遍历的范围。
    </p>
    <h5>
     <a id="2__82">
     </a>
     2. 循环遍历矩阵
    </h5>
    <p>
     使用一个
     <code>
      while
     </code>
     循环来控制遍历过程，循环条件为
     <code>
      left &lt;= right
     </code>
     且
     <code>
      top &lt;= bottom
     </code>
     。只要满足这个条件，就说明矩阵中还有未遍历的元素，继续进行遍历。
    </p>
    <h5>
     <a id="3__85">
     </a>
     3. 顺时针遍历边界
    </h5>
    <p>
     在每次循环中，按照顺时针方向依次遍历矩阵的四个边界：
    </p>
    <h6>
     <a id="1_88">
     </a>
     （1）从左到右遍历上边界
    </h6>
    <pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> left<span class="token punctuation">;</span> col <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
top<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：从矩阵的左上角开始，沿着当前上边界（第
      <code>
       top
      </code>
      行）从左到右依次访问元素，并将其添加到结果向量
      <code>
       result
      </code>
      中。遍历完上边界后，上边界向下移动一行，即
      <code>
       top
      </code>
      加 1。
     </li>
    </ul>
    <h6>
     <a id="2_97">
     </a>
     （2）从上到下遍历右边界
    </h6>
    <pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> top<span class="token punctuation">;</span> row <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
right<span class="token operator">--</span><span class="token punctuation">;</span>
</code></pre>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：从当前上边界的下一行（
      <code>
       top
      </code>
      行）开始，沿着右边界（第
      <code>
       right
      </code>
      列）从上到下依次访问元素，并将其添加到结果向量中。遍历完右边界后，右边界向左移动一列，即
      <code>
       right
      </code>
      减 1。
     </li>
    </ul>
    <h6>
     <a id="3_106">
     </a>
     （3）从右到左遍历下边界
    </h6>
    <pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> right<span class="token punctuation">;</span> col <span class="token operator">&gt;=</span> left<span class="token punctuation">;</span> col<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    bottom<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：在遍历下边界之前，需要先检查
      <code>
       top
      </code>
      是否小于等于
      <code>
       bottom
      </code>
      ，因为在某些情况下（例如矩阵只有一行），上边界和下边界可能已经重合，此时不需要再遍历下边界。如果满足条件，从当前右边界的左一列（
      <code>
       right
      </code>
      列）开始，沿着下边界（第
      <code>
       bottom
      </code>
      行）从右到左依次访问元素，并将其添加到结果向量中。遍历完下边界后，下边界向上移动一行，即
      <code>
       bottom
      </code>
      减 1。
     </li>
    </ul>
    <h6>
     <a id="4_117">
     </a>
     （4）从下到上遍历左边界
    </h6>
    <pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> bottom<span class="token punctuation">;</span> row <span class="token operator">&gt;=</span> top<span class="token punctuation">;</span> row<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    left<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <strong>
       原理
      </strong>
      ：在遍历左边界之前，需要先检查
      <code>
       left
      </code>
      是否小于等于
      <code>
       right
      </code>
      ，因为在某些情况下（例如矩阵只有一列），左边界和右边界可能已经重合，此时不需要再遍历左边界。如果满足条件，从当前下边界的上一行（
      <code>
       bottom
      </code>
      行）开始，沿着左边界（第
      <code>
       left
      </code>
      列）从下到上依次访问元素，并将其添加到结果向量中。遍历完左边界后，左边界向右移动一列，即
      <code>
       left
      </code>
      加 1。
     </li>
    </ul>
    <h5>
     <a id="4__128">
     </a>
     4. 结束条件
    </h5>
    <p>
     当
     <code>
      left &gt; right
     </code>
     或
     <code>
      top &gt; bottom
     </code>
     时，说明矩阵中的所有元素都已经被遍历完，此时退出循环，返回结果向量
     <code>
      result
     </code>
     。
    </p>
    <h4>
     <a id="_131">
     </a>
     复杂度分析
    </h4>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：由于我们需要遍历矩阵中的每个元素一次，矩阵共有
      <code>
       m * n
      </code>
      个元素，因此时间复杂度为
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         O 
         
        
          ( 
         
        
          m 
         
        
          ∗ 
         
        
          n 
         
        
          ) 
         
        
       
         O(m * n)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0278em;">
           O
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathnormal">
           m
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
          <span class="mbin">
           ∗
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
      。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：除了结果向量外，只使用了常数级的额外空间（四个边界变量），因此空间复杂度为
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0278em;">
           O
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord">
           1
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
      。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353831333132312f:61727469636c652f64657461696c732f313436313838353130" class_="artid" style="display:none">
 </p>
</div>


