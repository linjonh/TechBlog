---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f75303134333738313831:2f61727469636c652f64657461696c732f3831383731383239"
layout: post
title: "Java高级工程师常见面试题七-网络通信"
date: 2025-01-24 09:00:00 +0800
description: "1. http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。HTTP是无状态的"
keywords: "通信高级工程师面试题"
categories: ['面试', 'Java', 'Java']
tags: ['面试题', '网络通信', 'Tcp', 'Java', 'Http']
artid: "81871829"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=81871829
    alt: "Java高级工程师常见面试题七-网络通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=81871829
featuredImagePreview: https://bing.ee123.net/img/rand?artid=81871829
---

# Java高级工程师常见面试题（七）-网络通信

1. http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。

HTTP是无状态的，它的底层协议是由状态的TCP，但是HTTP的一次完整协议动作，里面是使用有状态的TCP协议来完成的。而每次协议动作之间没有任何关系。例如：第7次请求HTTP协议包，并不知道，这个包是为了什么？它或许是因为上次没有请求成功而重传，或许是上次的后续请求，或许是其他的，这些HTTP自身都不知道。

参考：
<https://blog.csdn.net/wu1991924/article/details/8548051>

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

|  |  |  |
| --- | --- | --- |
| 序号 | 方法 | 描述 |
| 1 | GET | 请求指定的页面信息，并返回实体主体。 |
| 2 | HEAD | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3 | POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4 | PUT | 从客户端向服务器传送的数据取代指定的文档的内容。 |
| 5 | DELETE | 请求服务器删除指定的页面。 |
| 6 | CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 |
| 7 | OPTIONS | 允许客户端查看服务器的性能。 |
| 8 | TRACE | 回显服务器收到的请求，主要用于测试或诊断。 |

2. socket通信，以及长连接，分包，连接异常断开的处理。

参考：
<http://www.jianshu.com/p/90348ef3f41e>

<http://www.cnblogs.com/fuchongjundream/p/3914696.html>

3. socket通信模型的使用，AIO和NIO。

参考：
<https://blog.csdn.net/u014401141/article/details/54406195>

<https://blog.csdn.net/anxpp/article/details/51512200>

4. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。

Netty是一个高性能、异步事件驱动的NIO框架，基于JAVA NIO提供的API实现。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。

Java NIO是在jdk1.4开始使用的，它既可以说成“新I/O”，也可以说成非阻塞式I/O。下面是java NIO的工作原理：

1. 由一个专门的线程来处理所有的 IO 事件，并负责分发。

2. 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。

3. 线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。

阅读过一些资料之后，下面贴出我理解的java NIO的工作原理图：

![](https://i-blog.csdnimg.cn/blog_migrate/98ecc291e8c1c033682f620e7889c7c3.png)

（注：每个线程的处理流程大概都是读取数据、解码、计算处理、编码、发送响应。）

Java NIO的服务端只需启动一个专门的线程来处理所有的 IO 事件，这种通信模型是怎么实现的呢？呵呵，我们一起来探究它的奥秘吧。java NIO采用了双向通道（channel）进行数据传输，而不是单向的流（stream），在通道上可以注册我们感兴趣的事件。一共有以下四种事件：

|  |  |
| --- | --- |
| 事件名 | 对应值 |
| 服务端接收客户端连接事件 | SelectionKey.OP\_ACCEPT(16) |
| 客户端连接服务端事件 | SelectionKey.OP\_CONNECT(8) |
| 读事件 | SelectionKey.OP\_READ(1) |
| 写事件 | SelectionKey.OP\_WRITE(4) |

服务端和客户端各自维护一个管理通道的对象，我们称之为selector，该对象能检测一个或多个通道 (channel) 上的事件。我们以服务端为例，如果服务端的selector上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞I/O这时会调用read()方法阻塞地读取数据，而NIO的服务端会在selector中添加一个读事件。服务端的处理线程会轮询地访问selector，如果访问selector时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。下面是我理解的java NIO的通信模型示意图：

![](https://i-blog.csdnimg.cn/blog_migrate/e725cbf376fe465f713e3083a4ccde33.png)

5. 同步和异步，阻塞和非阻塞。

“阻塞”与“非阻塞”与“同步”与“异步”不能简单的从字面埋解，提供一个从分布式系统角度的回答。

1. 同步与异步

同步和异步关注的是消息通信机制（synchronous communication/ asynchronous communication）

所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用遐回， 就得到返回值了。

換句话说，就是由调用者主动等待这个调用的结果。

而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。換句话说，当一 个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：

你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，“我查一下”，然后开始查啊查，等查好了 (可能是5秒，也可能是一天）告诉你结果（返回结果）。

而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了(不返回结果）。然后查好了,他会主动打电话给你。在这里老板通过回电这神方式来回调。

2. 阻塞与非阻塞

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的扶态。

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子， 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己挂起，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩 了，当然你也要偶尔过几分钟check—下老板有没有遐回结果。

在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关

6. OSI七层模型，包括TCP,IP的一些基本知识

1. OSI七层和TCP/IP四层的关系

1.1 OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。

1.2 OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。

1.3 OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。

TCP：transmission control protocol 传输控制协议

UDP：user data protocol 用户数据报协议

|  |  |  |
| --- | --- | --- |
| OSI七层网络模型 | TCP/IP四层概念模型 | 对应网络协议 |
| 应用层（Application） | 应用层 | HTTP、TFTP, FTP, NFS, WAIS、SMTP |
| 表示层（Presentation） | Telnet, Rlogin, SNMP, Gopher |
| 会话层（Session） | SMTP, DNS |
| 传输层（Transport） | 传输层 | TCP, UDP |
| 网络层（Network） | 网络层 | IP, ICMP, ARP, RARP, AKP, UUCP |
| 数据链路层（Data Link） | 数据链路层 | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP |
| 物理层（Physical） | IEEE 802.1A, IEEE 802.2到IEEE 802.11 |

参考：
<https://blog.csdn.net/guoguo527/article/details/52078962>

7. http中，get post的区别

* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST么有。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。

GET和POST本质上没有区别

GET和POST是什么？HTTP协议中的两种发送请求的方法。

HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。

因此，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

GET和POST还有一个重大区别，简单的说：

GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

1. GET与POST都有自己的语义，不能随便混用。

2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

8. 说说http,tcp,udp之间关系和区别。

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。

在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。

在传输层中有TCP协议与UDP协议。

在应用层有HTTP、FTP、TELNET、SMTP、DNS等协议。

TCP  传送控制协议(Transmission Control Protocol)：

TCP是传输层的一个协议，基于IP协议，用来传输类似HTTP的信息。如果把IP协议类比为一个“公路”的话，那TCP协议可以看成是在公路上行驶的“卡车”。TCP协议是面向连接的协议，通过三次握手机制，尽量保证连接的可靠性。tcp的链接需要进行三次握手，释放连接需要四次挥手。

UDP 用户数据报协议 （User Datagram Protocol） ：

UDP也是传输层的一个协议。但是与TCP不同的是，UDP不是面向连接的，并不保证传输的可靠性，没有TCP的建立连接的三次握手机制，对于传输效率上面有了提升。

个人理解：

这个就比较简单粗暴了，A要给B传数据，然后就直接传了。

HTTP 超文本传输协议（HyperText Transfer Protocal）：

HTTP是在应用层的一个协议，本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传输协议。

HTTP协议基于请求\响应模型的，并且是基于TCP协议的。

HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

9. 说说浏览器访问
[www.taobao.com](http://www.taobao.com/)
，经历了怎样的过程。

1、客户端浏览器通过DNS解析到www.taobao.com的IP地址a，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到a，然后通过TCP进行封装数据包，输入到网络层。

2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。

3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。

4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

参考：
<https://blog.csdn.net/DoUUnderstand/article/details/69761491>

10. HTTP协议、  HTTPS协议，SSL协议及完整交互过程；

SSL

1.安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议。

2.SSL协议的三个特性

Ø  保密：在握手协议中定义了会话密钥后，所有的消息都被加密。

Ø  鉴别：可选的客户端认证，和强制的服务器端认证。

Ø  完整性：传送的消息包括消息完整性检查（使用MAC）。

3.SSL的位置

![](https://i-blog.csdnimg.cn/blog_migrate/6b1df231aff34fef90aed77ba6cebb63.png)

HTTPS

1.HTTPS基于SSL的HTTP协议。

2.HTTPS使用与HTTP不同的端口(HTTP:80 ， HTTPS:443，一个加密、身份验证层（HTTP与TCP之间）)。

3.提供了身份验证与加密通信方法，被广泛用于互联网上安全敏感的通信。

交互过程

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

![](https://i-blog.csdnimg.cn/blog_migrate/7589e24d52edc69287f9e23dcc50d630.png)

1)    客户端请求建立SSL连接，并将自己支持的一套加密规则发送给网站。

2)    网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息

3)    获得网站证书之后浏览器要做以下工作：

Ø  验证证书的合法性

Ø  如果证书受信任，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。

Ø  使用约定好的HASH计算握手消息，

Ø  使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

4)    网站接收浏览器发来的数据之后要做以下的操作：

Ø  使用自己的私钥将信息解密取出密码

Ø  使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。

Ø  使用密码加密一段握手消息，发送给浏览器

5)    浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手结束。

6)    使用随机密码和对称加密算法对传输的数据加密，传输。

4.     加密与HASH算法如下：

1)     非对称加密算法：RSA，DSA/DSS，用于在握手过程中加密生成的密码。

2)     对称加密算法：AES，RC4，3DES，用于对真正传输的数据进行加密。

3)     HASH算法：MD5，SHA1，SHA256，验证数据的完整性。

5.     HTTP与HTTPS的区别：

1)     https协议需要申请证书。

2)     http是超文本传输协议，明文传输；https使用的是具有安全性的SSL加密传输协议。

3)     http端口80,；https端口443。

4)     http连接简单无状态；https由SSL+HTTP协议构件的可进行加密传输、身份验证的网络协议。

11. tcp的拥塞，快回传，ip的报文丢弃

参考：
<https://blog.csdn.net/a386stf/article/details/80510045>

12. https处理的一个过程，对称加密和非对称加密

参考问题10

13. head各个特点和区别

感觉问题有问题，估计是问http请求方法的区别，参考问题1