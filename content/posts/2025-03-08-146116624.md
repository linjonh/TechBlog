---
layout: post
title: "LeetCode刷题实战删除字符串中的所有相邻重复项栈的经典应用"
date: 2025-03-08 15:01:59 +0800
description: "栈是处理相邻元素匹配问题的核心数据结构，通过维护“已处理序列”的状态，避免暴力解法中的重复扫描。本题与“有效括号”（LeetCode 20）的实现异曲同工，均通过栈的及时弹出来确保数据的合法性。栈的先进后出（FILO）特性非常适合处理相邻重复项的匹配问题。，重复项删除操作会选择两个相邻且相同的字符并删除它们。栈中存储的元素已经是“处理过的无相邻重复项”的子序列。最直观的暴力解法是重复扫描字符串，每次删除相邻重复项，直到没有可删项。栈操作完成后，剩余元素即为删除所有相邻重复项后的结果。显然需要更高效的实现。"
keywords: "LeetCode刷题实战：删除字符串中的所有相邻重复项（栈的经典应用）"
categories: ['未分类']
tags: ['算法', '数据结构', 'Leetcode']
artid: "146116624"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146116624
    alt: "LeetCode刷题实战删除字符串中的所有相邻重复项栈的经典应用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146116624
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146116624
cover: https://bing.ee123.net/img/rand?artid=146116624
image: https://bing.ee123.net/img/rand?artid=146116624
img: https://bing.ee123.net/img/rand?artid=146116624
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LeetCode刷题实战：删除字符串中的所有相邻重复项（栈的经典应用）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     <strong>
      题目描述
     </strong>
    </h4>
    <p>
     <strong>
      题目链接
     </strong>
     ：
     <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" rel="nofollow" title="1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）">
      1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     给定一个由小写字母组成的字符串
     <code>
      s
     </code>
     ，重复项删除操作会选择两个相邻且相同的字符并删除它们。此操作反复进行，直到无法继续删除。返回最终的字符串。答案保证唯一。
    </p>
    <pre><code class="hljs">输入：s = "abbaca"
输出："ca"
解释：删除 "bb" 得到 "aaca"，再删除 "aa" 得到 "ca"。
</code></pre>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      问题分析与解法思路
     </strong>
    </h4>
    <h5>
     <strong>
      暴力解法的缺陷
     </strong>
    </h5>
    <p>
     最直观的暴力解法是重复扫描字符串，每次删除相邻重复项，直到没有可删项。例如：
    </p>
    <ol>
     <li>
      第一次扫描找到所有相邻重复对并删除，生成新字符串。
     </li>
     <li>
      对新字符串重复上述操作，直至不能再删。
     </li>
    </ol>
    <p>
     这种方法的时间复杂度为
     <code>
      O(n²)
     </code>
     （例如形如
     <code>
      aaaaa
     </code>
     的字符串需要进行
     <code>
      n/2
     </code>
     轮扫描），效率极低。显然需要更高效的实现。
    </p>
    <h5>
     <strong>
      栈的核心思想
     </strong>
    </h5>
    <p>
     栈的先进后出（FILO）特性非常适合处理相邻重复项的匹配问题。我们可以用栈存储未处理字符，每次遍历字符时比较当前字符与栈顶元素：
    </p>
    <ul>
     <li>
      如果相同，则弹出栈顶元素（表示删除这两个相邻重复项）。
     </li>
     <li>
      否则，将当前字符压入栈。
     </li>
    </ul>
    <p>
     栈操作完成后，剩余元素即为删除所有相邻重复项后的结果。
    </p>
    <h6>
     <strong>
      为什么栈能解决问题？
     </strong>
    </h6>
    <p>
     栈中存储的元素已经是“处理过的无相邻重复项”的子序列。当遇到一个新的字符时，只需检查它与栈顶是否相同：
    </p>
    <ul>
     <li>
      相同，弹出栈顶，相当于删除当前字符与栈顶字符的相邻重复对。
     </li>
     <li>
      不同，压入栈作为新的待匹配字符。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      代码实现与逐行解析
     </strong>
    </h4>
    <pre><code class="language-cpp">class Solution {
public:
    string removeDuplicates(string s) {
        stack&lt;char&gt; st; // 辅助栈存储未处理字符
        for (char ch : s) { // 遍历每个字符
            if (st.empty() || ch != st.top()) {
                st.push(ch); // 字符入栈：无相邻重复项
            } else {
                st.pop();    // 弹出栈顶：遇到相邻重复项，删除
            }
        }
        string result = "";
        while (!st.empty()) { // 合并栈中剩余字符
            result += st.top();
            st.pop();
        }
        reverse(result.begin(), result.end()); // 反转以恢复原顺序
        return result;
    }
};
</code></pre>
    <h5>
     <strong>
      步骤解析
     </strong>
    </h5>
    <ol>
     <li>
      <strong>
       初始化栈
      </strong>
      （第5行）：用于存储需保留的字符。
     </li>
     <li>
      <strong>
       遍历字符
      </strong>
      （第6行）：逐个检查每个字符与栈顶的关系。
      <ul>
       <li>
        <strong>
         压栈条件
        </strong>
        （第7行）：栈空或当前字符不等于栈顶。
       </li>
       <li>
        <strong>
         弹栈条件
        </strong>
        （第9行）：当前字符等于栈顶，删除这一对字符。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       构建结果字符串
      </strong>
      （第12-15行）：栈中剩余字符即为最终字符，但顺序是逆序的（出栈为从尾到头），需反转一次。
     </li>
    </ol>
    <h5>
     <strong>
      关键点说明
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       时间复杂度
       <code>
        O(n)
       </code>
      </strong>
      : 每个字符仅出入栈一次，反转操作也是
      <code>
       O(n)
      </code>
      。
     </li>
     <li>
      <strong>
       空间复杂度
       <code>
        O(n)
       </code>
      </strong>
      : 最坏情况下栈存储全部字符（如无重复项的字符串）。
     </li>
     <li>
      <strong>
       反转的必要性
      </strong>
      : 栈的弹出顺序与原字符串顺序相反（例如输入
      <code>
       "abc"
      </code>
      ，栈弹出顺序为
      <code>
       cba
      </code>
      ，需反转），确保结果的正确性。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      示例分析与测试验证
     </strong>
    </h4>
    <p>
     <strong>
      示例1：输入
      <code>
       s = "abbaca"
      </code>
     </strong>
    </p>
    <pre><code class="language-cpp">遍历过程：
a → 栈空 → 压入 → 栈: [a]
b → 栈顶为a → 压入 → 栈: [a, b]
b → 栈顶为b → 弹出 → 栈: [a]
a → 栈顶为a → 弹出 → 栈: []
c → 栈空 → 压入 → 栈: [c]
a → 栈顶为c → 压入 → 栈: [c, a]

剩余字符：c, a → 反转后结果："ca"
</code></pre>
    <h5>
     <strong>
      边界测试用例
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       输入空字符串
      </strong>
      : 返回空字符串。
     </li>
     <li>
      <strong>
       输入无相邻重复字符
      </strong>
      （如
      <code>
       "abcd"
      </code>
      ）: 结果与原字符串一致。
     </li>
     <li>
      <strong>
       全部重复字符
      </strong>
      （如
      <code>
       "aaaaa"
      </code>
      ）: 最终栈为空，返回空字符串。
     </li>
     <li>
      <strong>
       嵌套重复项
      </strong>
      （如
      <code>
       "abba"
      </code>
      ）: 处理后成为空字符串。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      优化与扩展
     </strong>
    </h4>
    <h5>
     <strong>
      改进点
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       直接构建字符串模拟栈
      </strong>
      ：使用
      <code>
       stack
      </code>
      可能需要较多内存操作，可用
      <code>
       string
      </code>
      直接作为栈（以下为优化代码示例）：
      <pre><code class="language-cpp">class Solution {
public:
    string removeDuplicates(string s) {
        string st; // string模拟栈
        for (char ch : s) {
            if (!st.empty() &amp;&amp; ch == st.back()) {
                st.pop_back();
            } else {
                st.push_back(ch);
            }
        }
        return st;
    }
};
</code></pre>
      <p>
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      扩展思考
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       保留至少 k 个连续字符
      </strong>
      （进阶题目
      <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/" rel="nofollow" title="1209. 删除字符串中的所有相邻重复项 II">
       1209. 删除字符串中的所有相邻重复项 II
      </a>
      ）：每次需检查是否连续出现 k 次才进行删除。
     </li>
     <li>
      <strong>
       并行处理多个相邻项
      </strong>
      （如三元重复、四元重复）：栈结构可扩展存储计数（当前字符+出现次数）。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     栈是处理相邻元素匹配问题的核心数据结构，通过维护“已处理序列”的状态，避免暴力解法中的重复扫描。本题与“有效括号”（LeetCode 20）的实现异曲同工，均通过栈的及时弹出来确保数据的合法性。建议类比练习以下题目：
    </p>
    <ol>
     <li>
      <a href="https://leetcode.cn/problems/valid-parentheses/" rel="nofollow" title="20. 有效的括号">
       20. 有效的括号
      </a>
     </li>
     <li>
      <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/" rel="nofollow" title="1209. 删除字符串中的所有相邻重复项 II">
       1209. 删除字符串中的所有相邻重复项 II
      </a>
     </li>
     <li>
      <a href="https://leetcode.cn/problems/valid-parenthesis-string/" rel="nofollow" title="678. 有效的括号字符串">
       678. 有效的括号字符串
      </a>
     </li>
    </ol>
    <p>
     <strong>
      思考题
     </strong>
     ：如果将问题改为删除两个以上相邻重复项（如
     <code>
      "aaa" → ""
     </code>
     ），代码应如何调整？
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36333030363437382f:61727469636c652f64657461696c732f313436313136363234" class_="artid" style="display:none">
 </p>
</div>


