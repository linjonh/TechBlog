---
layout: post
title: "Codeforces-Round-1045-Div.-2-C"
date: 2025-08-27T01:26:05+0800
description: "【代码】Codeforces Round 1045 (Div. 2) C。"
keywords: "Codeforces Round 1045 (Div. 2) C"
categories: ['未分类']
tags: ['算法', 'C']
artid: "150894214"
arturl: "https://blog.csdn.net/m0_63322121/article/details/150894214"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150894214
    alt: "Codeforces-Round-1045-Div.-2-C"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150894214
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150894214
cover: https://bing.ee123.net/img/rand?artid=150894214
image: https://bing.ee123.net/img/rand?artid=150894214
img: https://bing.ee123.net/img/rand?artid=150894214
---



# Codeforces Round 1045 (Div. 2) C

**前序：很久没有打CF了，更准确的说是很久没有碰OI了，今天偶然碰到赛时，就随手做了一道C。**

## **C. Even Larger**

##### **题意：给你一个序列，让你使每一个长度大于等于2的子序列的偶数项之和大于等于奇数项之和，你可以操作使某个数字每次减少1，问最少需要操作多少次。**

##### **题解：看到最小我一开始考虑dp或者二分，看到数据范围可排除dp，二分虽然数据具有单调性，但也不可做。再手模一下数据，很容易发现，前一个数字一定要小于等于当前数字，并且，每个偶数位置必须要满足a_{i - 1} + a_{i + 1} <= a_i**

##### **代码：**

```

#include<bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int maxn = 1e6 + 7 ;
int t , n , a[maxn] ;
ll sum[maxn] , Sum[maxn] ;
void solve(){
	cin >> n ;
//	ll res = 0 ;
	for(int i = 1 ; i <= n ; i ++){
		cin >> a[i] ;
	}
	ll res = 0 ;
	for(int i = 2 ; i <= n ; i += 2){
		if(i == n){
			if(a[i - 1] > a[i]){
				res += (a[i - 1] - min(a[i] , a[i - 1])) ;
			}
			cout << res << endl ;
			return ;
		}
		if(a[i - 1] + a[i + 1] > a[i]){
			res += (a[i - 1] - min(a[i] , a[i - 1])) ;
			a[i - 1] = min(a[i] , a[i - 1]) ;
			if(a[i - 1] + a[i + 1] > a[i]){
				ll ans = a[i] - a[i - 1] ;
				res += (a[i + 1] - ans) ;
				a[i + 1] -= (a[i + 1] - ans) ; 
			}
		}
	}
	cout << res << endl ;
}
int main(){
	ios :: sync_with_stdio(0) ;
	cin.tie(0) ;
	cin >> t ;
	while(t --){
		solve() ;
	}
	return 0 ;
}
```

**喜欢的记得点赞，收藏加关注！**



