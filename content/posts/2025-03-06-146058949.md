---
layout: post
title: "MySQL学习笔记3InnoDB存储引擎对MVCC的实现"
date: 2025-03-06 11:00:49 +0800
description: "MVCC（Multi-Version Concurrecy Control) 多版本并发控制MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。"
keywords: "MySQL学习笔记（3）InnoDB存储引擎对MVCC的实现"
categories: ['Mysql']
tags: ['笔记', '学习', 'Mysql']
artid: "146058949"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146058949
    alt: "MySQL学习笔记3InnoDB存储引擎对MVCC的实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146058949
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146058949
cover: https://bing.ee123.net/img/rand?artid=146058949
image: https://bing.ee123.net/img/rand?artid=146058949
img: https://bing.ee123.net/img/rand?artid=146058949
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL学习笔记（3）InnoDB存储引擎对MVCC的实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     本文参考https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html
    </p>
    <h2>
     <a id="MVCC_1">
     </a>
     什么是MVCC
    </h2>
    <p>
     <strong>
      MVCC（Multi-Version Concurrecy Control) 多版本并发控制
     </strong>
     <br/>
     MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在
     <strong>
      每个数据行上维护多个版本的数据
     </strong>
     来实现的。当一个事务要对数据库中的数据进行
     <strong>
      修改时，MVCC 会为该事务创建一个数据快照
     </strong>
     ，而不是直接修改实际的数据行。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/049d4977f00748debab1f2db90ec7880.png"/>
    </p>
    <h5>
     <a id="SELECT_6">
     </a>
     读操作（SELECT）
    </h5>
    <p>
     当一个事务进行读取的操作时，并不会读取实际行上的数据，而是在事务开始的时刻为需要读取的数据创建一个快照，防止该事务读取其他事务中提交或修改的数据。
    </p>
    <ul>
     <li>
      对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。
     </li>
     <li>
      如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。
     </li>
     <li>
      事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。
     </li>
    </ul>
    <h5>
     <a id="INSERTUPDATEDELETE_11">
     </a>
     写操作（INSERT、UPDATE、DELETE）
    </h5>
    <p>
     当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。
    </p>
    <ul>
     <li>
      对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。
     </li>
     <li>
      新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。
     </li>
     <li>
      原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。
     </li>
    </ul>
    <h5>
     <a id="_16">
     </a>
     事务的回滚和提交
    </h5>
    <ul>
     <li>
      当一个事务提交时，该数据便成为了最新版数据，对其他事务可见。
     </li>
     <li>
      当一个事务回滚时，他所作的修改被撤销，对其他事务不可见。
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="_21">
     </a>
     一致性锁定读（当前读）和非锁定读
    </h2>
    <p>
     在 InnoDB 存储引擎中，多版本控制 (multi versioning) 就是对
     <strong>
      非锁定读
     </strong>
     的实现。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它
     <strong>
      快照读
     </strong>
     (snapshot read)
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6c3e100a91464575af6b8df8252f1dd8.png">
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e22178a5b3514a8e8488cd377c0717bc.png">
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/620555af058d49f083431cc4b28bee56.png"/>
      </img>
     </img>
    </p>
    <hr/>
    <h2>
     <a id="InnoDB__MVCC__30">
     </a>
     InnoDB 对 MVCC 的实现
    </h2>
    <p>
     InnoDB对于MVCC的实现依赖于三个部分
    </p>
    <ul>
     <li>
      <code>
       隐藏字段
      </code>
     </li>
     <li>
      <code>
       undo log
      </code>
     </li>
     <li>
      <code>
       Read View
      </code>
     </li>
    </ul>
    <h4>
     <a id="_36">
     </a>
     隐藏字段
    </h4>
    <p>
     InnoDB会自动为每行的数据加上几个
     <strong>
      隐藏的字段
     </strong>
    </p>
    <ul>
     <li>
      DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除
     </li>
     <li>
      DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log（上一版本的历史数据） 。如果该行未被更新，则为空
     </li>
     <li>
      DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8fdb4b69e1c84c6c90b09638b4396367.png"/>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="undo_log_43">
     </a>
     undo log
    </h4>
    <h5>
     <a id="undo_log_44">
     </a>
     undo log作用：
    </h5>
    <ul>
     <li>
      当事务回滚时用于将数据恢复到修改前的样子
     </li>
     <li>
      另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/94f999681655448d9ec2a54a99a72f75.png"/>
    </p>
    <h5>
     <a id="undo_log_49">
     </a>
     undo log版本链
    </h5>
    <p>
     不同事务或相同事务对同一条记录进行修改, 会导致该记录的undolog生成一条记录版本链表,链表的头部是最新的旧记录,链表尾部是最早的旧记录。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1a34e16ff7334ecdbc8d4d8bb8e5e862.png"/>
    </p>
    <hr/>
    <h4>
     <a id="Read_View_56">
     </a>
     Read View
    </h4>
    <p>
     ReadView (读视图)是快照读SQL执行时MVCC提取数据的依据,记录并维护系统当前活跃的事务(未提交的) id，包含了四个核心字段:
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7ad3a1f8c3df47b2bc278eedc20439d5.png">
      <br/>
      <strong>
       活跃事务：生成Read View时未提交的事务
      </strong>
     </img>
    </p>
    <pre><code class="prism language-c">class ReadView <span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* ... */</span>
private<span class="token operator">:</span>
  <span class="token class-name">trx_id_t</span> m_low_limit_id<span class="token punctuation">;</span>      <span class="token comment">/* 大于等于这个 ID 的事务均不可见 */</span>

  <span class="token class-name">trx_id_t</span> m_up_limit_id<span class="token punctuation">;</span>       <span class="token comment">/* 小于这个 ID 的事务均可见 */</span>

  <span class="token class-name">trx_id_t</span> m_creator_trx_id<span class="token punctuation">;</span>    <span class="token comment">/* 创建该 Read View 的事务ID */</span>

  <span class="token class-name">trx_id_t</span> m_low_limit_no<span class="token punctuation">;</span>      <span class="token comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span>

  <span class="token class-name">ids_t</span> m_ids<span class="token punctuation">;</span>                  <span class="token comment">/* 创建 Read View 时的活跃事务列表 */</span>

  m_closed<span class="token punctuation">;</span>                     <span class="token comment">/* 标记 Read View 是否 close */</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ae5444e3ffb24c8f9aee70363d879228.png"/>
    </p>
    <h5>
     <a id="_80">
     </a>
     可见性算法
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/160f41a04ad54b4ea4f26b63e3093719.png"/>
     <br/>
     <strong>
      trx_id: 数据行中的隐藏字段其一(注意要和creator_trx_id区分)
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/89cd30fb40c74505a6c42d1c51d5c0fa.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d0737bee5fb642f381048e7891f0c657.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/122415217c124fd58032ce6d384d5a87.png"/>
    </p>
    <h4>
     <a id="READ_COMMITREPEATABLE_READ_86">
     </a>
     在READ COMMIT于REPEATABLE READ隔离级别下的区别
    </h4>
    <ul>
     <li>
      READ COMMITTED :在事务中
      <code>
       每一次
      </code>
      执行快照读时生成ReadView。
     </li>
     <li>
      REPEATABLE READ:仅在事务中
      <code>
       第一次
      </code>
      执行快照读时生成ReadView, 后续复用该ReadView。
     </li>
    </ul>
    <h2>
     <a id="MVCC__NextKey_Lock__89">
     </a>
     MVCC + Next-Key Lock 防止幻读
    </h2>
    <ul>
     <li>
      执行普通 select，此时会以 MVCC 快照读的方式读取数据在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”.
     </li>
     <li>
      执行 select…for update/lock in share mode、insert、update、delete 等当前读在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读.
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303139303137302f:61727469636c652f64657461696c732f313436303538393439" class_="artid" style="display:none">
 </p>
</div>


