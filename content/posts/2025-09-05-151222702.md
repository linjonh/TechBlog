---
layout: post
title: "UE4-Macæ„å»ºç¼–è¯‘æŠ¥é”™-no-member-named-disjunction-in-namespace-std"
date: 2025-09-05T14:41:50+0800
description: "åœ¨iOSç¼–è¯‘è¿‡ç¨‹ä¸­é‡åˆ°std::disjunctionæœªå®šä¹‰é”™è¯¯ï¼ŒåŸå› æ˜¯Macæ„å»ºæœºæœªé…ç½®_LIBCPP_STD_VERå®ã€‚é€šè¿‡åˆ†æWindowså’ŒMacä¸‹çš„å®ç°å·®å¼‚å‘ç°ï¼Œdisjunctionæ˜¯C++17å¼•å…¥çš„æ¨¡æ¿å…ƒå‡½æ•°ï¼Œç”¨äºç¼–è¯‘æœŸç±»å‹ç‰¹æ€§çš„é€»è¾‘æˆ–è¿ç®—ã€‚æœ€ç»ˆè§£å†³æ–¹æ¡ˆæ˜¯é’ˆå¯¹iOSå¹³å°æ”¹ç”¨std::_Oræ›¿ä»£std::disjunctionï¼Œé€šè¿‡æ¡ä»¶ç¼–è¯‘å®ç°å…¼å®¹æ€§ã€‚è¯¥é—®é¢˜æ­ç¤ºäº†ä¸åŒå¹³å°ä¸‹C++æ ‡å‡†åº“å®ç°çš„å·®å¼‚ï¼Œç‰¹åˆ«æ˜¯ä¸C++17ç‰¹æ€§ç›¸å…³çš„æ¡ä»¶ç¼–è¯‘å¤„ç†ã€‚"
keywords: "UE4 Macæ„å»ºç¼–è¯‘æŠ¥é”™ no member named â€œdisjunctionâ€ in namespace â€œstdâ€"
categories: ['æœªåˆ†ç±»']
tags: ['Ue']
artid: "151222702"
arturl: "https://blog.csdn.net/sinat_23135151/article/details/151222702"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151222702
    alt: "UE4-Macæ„å»ºç¼–è¯‘æŠ¥é”™-no-member-named-disjunction-in-namespace-std"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151222702
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151222702
cover: https://bing.ee123.net/img/rand?artid=151222702
image: https://bing.ee123.net/img/rand?artid=151222702
img: https://bing.ee123.net/img/rand?artid=151222702
---



# UE4 Macæ„å»ºç¼–è¯‘æŠ¥é”™ no member named â€œdisjunctionâ€ in namespace â€œstdâ€

## èƒŒæ™¯

æˆ‘çš„å·¥ç¨‹åœ¨ç¼–è¯‘iOSæ—¶ï¼Œé‡åˆ°å¦‚ä¸‹æŠ¥é”™ï¼š

2025-09-05 11:43:51:940 : /Users/bkdevops/_ios1/EngineSource/Engine/Source/Runtime/Core/Public/Containers/Array.h:46:53: error: no member named 'disjunction' in namespace 'std'

## åˆ†æ

ç”±äºWINDOWSçš„æ„åŒ…æ²¡æœ‰è¿™ä¸ªæŠ¥é”™ï¼Œå› æ­¤å…ˆè§‚å¯Ÿå…¶ï¼ˆdisjunctionï¼‰å®šä¹‰ã€‚WINDOWSä¸‹å®šä¹‰åœ¨ C:\Program Files\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC\14.40.33807\include\xtr1common ï¼Œå¦‚ä»£ç 1ï¼ŒMacä¸‹çš„å®šä¹‰åœ¨

/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/disjunction.h ï¼Œå¦‚ä»£ç 2ã€‚

```
//ä»£ç 1ï¼š
_EXPORT_STD template <class... _Traits>
struct disjunction : false_type {}; // If _Traits is empty, false_type

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    // the first true trait in _Traits, or the last trait if none are true
};

```

```
//ä»£ç 2ï¼š
// _Or always performs lazy evaluation of its arguments.
//
// However, `_Or<_Pred...>` itself will evaluate its result immediately (without having to
// be instantiated) since it is an alias, unlike `disjunction<_Pred...>`, which is a struct.
// If you want to defer the evaluation of `_Or<_Pred...>` itself, use `_Lazy<_Or, _Pred...>`
// or `disjunction<_Pred...>` directly.
template <class... _Args>
using _Or _LIBCPP_NODEBUG = typename _OrImpl<sizeof...(_Args) != 0>::template _Result<false_type, _Args...>;

#if _LIBCPP_STD_VER >= 17

template <class... _Args>
struct disjunction : _Or<_Args...> {};

template <class... _Args>
inline constexpr bool disjunction_v = _Or<_Args...>::value;

#endif // _LIBCPP_STD_VER >= 17
```

ç”±äºæˆ‘çš„Macæ„å»ºæœºæ²¡æœ‰é…ç½®ä¸ºÂ _LIBCPP_STD_VERÂ  17 ï¼Œå…·ä½“åŸå› è§æˆ‘çš„ä¸‹ä¸€ç¯‡åšæ–‡ï¼ˆ[UE4 Macæ„å»ºç¼–è¯‘æŠ¥é”™ no template named â€œis_void_vâ€ in namespace â€œstdâ€-CSDNåšå®¢](https://blog.csdn.net/sinat_23135151/article/details/151223046?fromshare=blogdetail&sharetype=blogdetail&sharerId=151223046&sharerefer=PC&sharesource=sinat_23135151&sharefrom=from_link "UE4 Macæ„å»ºç¼–è¯‘æŠ¥é”™ no template named â€œis_void_vâ€ in namespace â€œstdâ€-CSDNåšå®¢")ï¼‰ã€‚å› æ­¤ disjunction æœªå®šä¹‰ã€‚

## æœ€ç»ˆæ–¹æ¡ˆ

åœ¨UE4çš„ä½¿ç”¨äº†disjunction çš„åœ°æ–¹ï¼Œæ”¹ä¸ºä¸‹é¢å½¢å¼ï¼š

```
#if PLATFORM_IOS
constexpr bool TArrayElementsAreCompatible_V = std::_Or<std::is_same<DestType, std::decay_t<SourceType>>, std::is_constructible<DestType, SourceType>>::value;
#else
constexpr bool TArrayElementsAreCompatible_V = std::disjunction<std::is_same<DestType, std::decay_t<SourceType>>, std::is_constructible<DestType, SourceType>>::value;
#endif
```

## disjunctionçš„å«ä¹‰

é’ˆå¯¹ä»£ç 2ï¼Œä¸‹é¢è¿™ä¸ªè¡¨æ ¼æ±‡æ€»äº†ä»£ç ä¸­å…³é”®éƒ¨åˆ†åŠå…¶å«ä¹‰ï¼š

| ä»£ç ç‰‡æ®µ | å«ä¹‰ |
| --- | --- |
| `#if _LIBCPP_STD_VER >= 17` | â€‹**æ¡ä»¶ç¼–è¯‘é¢„å¤„ç†æŒ‡ä»¤**â€‹ï¼šæ£€æŸ¥ libc++ çš„é…ç½®å® `_LIBCPP_STD_VER`æ˜¯å¦è¡¨ç¤ºæ”¯æŒ C++17 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚ |
| `_LIBCPP_STD_VER` | â€‹**libc++ å†…éƒ¨å®**â€‹ï¼šå…¶æ•´æ•°å€¼ä»£è¡¨ libc++ â€‹**ç›®æ ‡éµå¾ªçš„ C++ æ ‡å‡†ç‰ˆæœ¬**ï¼Œä¾‹å¦‚ `17`ä»£è¡¨ C++17ï¼Œ`20`ä»£è¡¨ C++20ã€‚ |
| `template <class... _Args> struct disjunction : _Or<_Args...> {};` | â€‹**`std::disjunction`çš„ä¸»æ¨¡æ¿å®šä¹‰**â€‹ï¼šå®ƒç»§æ‰¿è‡ªä¸€ä¸ªå†…éƒ¨å®ç° `_Or`ã€‚ |
| `std::disjunction` | â€‹**C++17 æ ‡å‡†å¼•å…¥çš„æ¨¡æ¿**â€‹ï¼šå¯¹å¤šä¸ª**ç±»å‹ç‰¹æ€§ (type traits)â€‹**â€‹ è¿›è¡Œ**é€»è¾‘æˆ– (OR) è¿ç®—**çš„å…ƒå‡½æ•°ã€‚ |
| `template <class... _Args> inline constexpr bool disjunction_v = _Or<_Args...>::value;` | â€‹**C++17 æ ‡å‡†å¼•å…¥çš„å˜é‡æ¨¡æ¿**â€‹ï¼šæ˜¯ `disjunction<_Args...>::value`çš„ç®€å†™ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚ |
| `#endif` | ç»“æŸæ¡ä»¶ç¼–è¯‘å—ã€‚ |

ğŸ”§ â€‹**`std::disjunction`çš„åŠŸèƒ½ä¸åŸç†**â€‹

`std::disjunction`æ˜¯ä¸€ä¸ª**æ¨¡æ¿å…ƒå‡½æ•°**ï¼Œå®ƒæ¥å—ä»»æ„æ•°é‡ï¼ˆå˜é•¿æ¨¡æ¿å‚æ•° `class... _Args`ï¼‰çš„ç±»å‹ç‰¹æ€§ï¼ˆä¾‹å¦‚ `std::is_integral<T>`, `std::is_floating_point<T>`ç­‰ï¼‰ï¼Œå¹¶è®¡ç®—å®ƒä»¬çš„é€»è¾‘æˆ–ã€‚

* â€‹**è¿ç®—è§„åˆ™**â€‹ï¼šç›¸å½“äº `T1::value || T2::value || ... || Tn::value`ï¼Œä½†æ˜¯**åœ¨ç¼–è¯‘æœŸè¿›è¡Œ**çš„ã€‚
* â€‹**çŸ­è·¯æ±‚å€¼**â€‹ï¼šè¿™æ˜¯ `disjunction`ä¸€ä¸ªéå¸¸é‡è¦çš„ç‰¹æ€§ã€‚å¦‚æœåœ¨æ¨¡æ¿å‚æ•°åŒ… `_Args...`ä¸­ï¼Œâ€‹**æŸä¸ªç±»å‹ç‰¹æ€§ `Bi`çš„ `value`é™æ€æˆå‘˜ä¸º `true`**ï¼Œé‚£ä¹ˆ `disjunction`çš„ `value`å°±æ˜¯ `true`ï¼Œå¹¶ä¸”**ç¼–è¯‘å™¨ä¼šåœæ­¢å®ä¾‹åŒ–åç»­çš„ç±»å‹ç‰¹æ€§**â€‹ï¼ˆå³ä¸ä¼šå»è®¡ç®— `Bj::value`ï¼Œå…¶ä¸­ `j > i`ï¼‰ã€‚è¿™åœ¨åç»­çš„ç±»å‹å®ä¾‹åŒ–ä»£ä»·é«˜æ˜‚æˆ–å¯èƒ½å¯¼è‡´ç¼–è¯‘é”™è¯¯æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚
* â€‹**ç»§æ‰¿å…³ç³»**â€‹ï¼š`std::disjunction<B1, B2, ..., BN>`ä¼šå…¬å¼€ç»§æ‰¿è‡ªç¬¬ä¸€ä¸ª `value`ä¸º `true`çš„ `Bi`ç±»å‹ã€‚å¦‚æœæ‰€æœ‰ `Bi::value`éƒ½ä¸º `false`ï¼Œåˆ™ç»§æ‰¿è‡ªæœ€åä¸€ä¸ª `BN`ã€‚è¿™æ„å‘³ç€ä½ ä¸ä»…å¯ä»¥è·å–æœ€ç»ˆçš„ `::value`ï¼Œæœ‰æ—¶è¿˜å¯ä»¥è·å–åˆ°ç¬¦åˆæ¡ä»¶çš„é‚£ä¸ªç‰¹æ€§ç±»å‹æœ¬èº«çš„ä¿¡æ¯ã€‚

ğŸ’¡ â€‹**ç®€å•ç¤ºä¾‹**â€‹

```
#include <type_traits>
#include <iostream>

int main() {
    // æ£€æŸ¥ç±»å‹ T æ˜¯å¦æ˜¯æ•´å‹æˆ–æµ®ç‚¹å‹ä¹‹ä¸€
    using T = double;
    
    if (std::disjunction_v<std::is_integral<T>, std::is_floating_point<T>>) {
        std::cout << "T is either integral or floating point.\n";
    } else {
        std::cout << "T is neither integral nor floating point.\n";
    }
    
    return 0;
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`std::disjunction_v<>`ä¼šåœ¨ç¼–è¯‘æœŸè®¡ç®— `std::is_integral<double>::value || std::is_floating_point<double>::value`ã€‚ç”±äº `double`æ˜¯æµ®ç‚¹ç±»å‹ï¼Œç¬¬äºŒä¸ªç‰¹æ€§çš„ `value`ä¸º `true`ï¼Œå› æ­¤æ•´ä¸ª `disjunction_v`çš„ç»“æœä¸º `true`ã€‚



