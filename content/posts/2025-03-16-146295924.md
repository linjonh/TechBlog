---
layout: post
title: "SpringBoot-第一课-配置类注解"
date: 2025-03-16 19:13:51 +0800
description: "ImportResource注解实现配置类。"
keywords: "SpringBoot 第一课（Ⅲ） 配置类注解"
categories: ['未分类']
tags: ['Spring', 'Spring', 'Propertysource', 'Profile', 'Java', 'Importresource', 'Boot', 'Bean']
artid: "146295924"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146295924
    alt: "SpringBoot-第一课-配置类注解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146295924
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146295924
cover: https://bing.ee123.net/img/rand?artid=146295924
image: https://bing.ee123.net/img/rand?artid=146295924
img: https://bing.ee123.net/img/rand?artid=146295924
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringBoot 第一课（Ⅲ） 配置类注解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
     对于SpringBoot项目来说，有3种常用来绑定指定配置文件的注解：​​​​​
     <strong>
      @
      <span style="color:#333333">
       PropertySource，@ImportResource
      </span>
     </strong>
     <span style="color:#333333">
      和
     </span>
     <strong>
      <span style="color:#333333">
       @Bean
      </span>
     </strong>
     。
    </p>
    <blockquote>
     <p>
      想看默认配置绑定看这篇：
      <a class="has-card" href="https://blog.csdn.net/m0_74977981/article/details/146282864?spm=1001.2014.3001.5501" title="SpringBoot 第一课（Ⅱ）配置文件注入-CSDN博客">
       <span class="link-card-box" contenteditable="false">
        <span class="link-title">
         SpringBoot 第一课（Ⅱ）配置文件注入-CSDN博客
        </span>
        <span class="link-desc">
         文章浏览阅读500次，点赞7次，收藏14次。需要为每个属性单独指定，适用于简单的配置或单个属性的注入。属性上，Spring Boot 会处理这种命名风格的差异。使用@ConfigurationProperties注入。），而松散绑定支持这三种名字互通，就比如配置文件里的。允许一次性注入整个对象，适用于复杂的配置结构。Java中常见命名规则有驼峰命名法（实现上面操作后，就可以通过访问“使用注解时，在处理复杂情况时，
        </span>
        <span class="link-link">
         <img alt=" " class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico">
          https://blog.csdn.net/m0_74977981/article/details/146282864?spm=1001.2014.3001.5501
         </img>
        </span>
       </span>
      </a>
     </p>
    </blockquote>
    <h2 id="%E4%B8%80%E3%80%81%40PropertySource" name="%E4%B8%80%E3%80%81%40PropertySource">
     <strong>
      一、@
      <span style="color:#333333">
       PropertySource
      </span>
     </strong>
    </h2>
    <p>
     <strong>
      <span style="color:#333333">
       配置文件
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="613" src="https://i-blog.csdnimg.cn/direct/20af932e93c44b8dbc58539c596f1d0c.png" width="510"/>
    </p>
    <p>
     在里面编写：
    </p>
    <pre><code class="language-java">student1.name=admin
student1.age=20
student1.id=1

</code></pre>
    <p>
     <strong>
      Java实体类
     </strong>
    </p>
    <pre><code class="language-java">package com.qcby.entity1;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(value="classpath:student1.properties")
@ConfigurationProperties(prefix="student1")
public class Student1 {
    private String name;
    private int age;
    private int id;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Student1{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                '}';
    }
}
</code></pre>
    <p>
     现在我们需要测试这个类：
     <br/>
     在test路径下测试：
    </p>
    <p>
     <img alt="" height="714" src="https://i-blog.csdnimg.cn/direct/176613dc98c84eac9e5b78157cb11c50.png" width="550"/>
    </p>
    <p>
     注意这里SpringBoot项目在创建时会自动生成这么一个test类（如下）：
    </p>
    <p>
     <img alt="" height="303" src="https://i-blog.csdnimg.cn/direct/0330647be97b4134a18998316fc54721.png" width="465"/>
    </p>
    <p>
     为了方便查看，我们再在它旁边创建一个StudentTest类：
    </p>
    <pre><code class="language-java">package com.qcby.sbdemotest01;

import com.qcby.entity1.Student1;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;


/**
 * 从Spring Boot 2.2版本开始，@SpringBootTest 已经包含了 SpringRunner 的功能，
 * 因此在大多数情况下，工程师不再需要显式地使用 @RunWith(SpringRunner.class)。
 */
//@RunWith(SpringRunner.class)  
//我用的是2.7.0，所以不用显式这一行【我在这里显式加上它的话，日志会报错警告（虽然能用吧）】（但是要知道有这么一个注释）
@SpringBootTest
public class StudentTest {
    @Autowired
    Student1 student1;
    @Test
    void contextLoads() {
        System.out.println(student1);
    }


}
</code></pre>
    <p>
     得到结果：
    </p>
    <p>
     <img alt="" height="375" src="https://i-blog.csdnimg.cn/direct/de92baefb82a42c6926f02c48095c8a4.png" width="1173"/>
    </p>
    <blockquote>
     <p>
      <strong>
       注意：
      </strong>
      在Spring中，
      <strong>
       <code>
        classpath
       </code>
      </strong>
      是一个特殊的路径前缀，在SpringBoot项目中，默认代表的根目录一般是
      <strong>
       <code>
        src/main/resources。
       </code>
      </strong>
     </p>
     <p>
      <strong>
       ①规范情况
      </strong>
     </p>
     <p>
      即假设一个项目的目录结构是：
     </p>
     <pre><code class="language-java">src/
├── main/
│   ├── java/
│   │   └── com/example/Student1.java
│   └── resources/
│       ├── student1.properties
│       └── beans.xml</code></pre>
     <p>
      那么会在实体类中这么书写：
     </p>
     <pre><code class="language-java">@PropertySource("classpath:config.properties")</code></pre>
     <p>
      <strong>
       ②嵌套子目录
      </strong>
     </p>
     <pre><code class="language-java">src/
├── main/
│   ├── java/
│   │   └── com/example/Student1.java
│   └── resources/
│       └── config/
│           ├── student1.properties
│           └── beans.xml</code></pre>
     <p>
      此时在实体类中定义时，就要加上目录路径前缀：
     </p>
     <pre><code class="language-java">@PropertySource("classpath:config/config.properties")
</code></pre>
     <p>
      不只是@PropertySource，其他用到
      <strong>
       <code>
        classpath
       </code>
      </strong>
      的地方同样遵循这个准则。
     </p>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81%40ImportResource" name="%E4%BA%8C%E3%80%81%40ImportResource">
     二、@
     <strong>
      <span style="color:#333333">
       ImportResource
      </span>
     </strong>
    </h2>
    <blockquote>
     <p>
      在讲@ImportResource这里时，结合Spring框架全注解实现配置一起。
     </p>
     <p>
      详文参照：
      <a class="has-card" href="https://blog.csdn.net/m0_74977981/article/details/144626708?spm=1001.2014.3001.5501" title="Spring（二）---基于注解的方式实现Bean管理和注入属性_有没有注解可以实现bean动态注入,配置项打开注入,关闭则剔除-CSDN博客">
       <span class="link-card-box" contenteditable="false">
        <span class="link-title">
         Spring（二）---基于注解的方式实现Bean管理和注入属性_有没有注解可以实现bean动态注入,配置项打开注入,关闭则剔除-CSDN博客
        </span>
        <span class="link-desc">
         文章浏览阅读488次，点赞9次，收藏6次。①：注解是代码特殊标记，格式：@注解名称(属性名称=属性值，属性名称=属性值...)②：使用注解，注解作用在类上面，方法上面，属性上边③：使用注解的目的：简化XML配置。_有没有注解可以实现bean动态注入,配置项打开注入,关闭则剔除
        </span>
        <span class="link-link">
         <img alt=" " class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico">
          https://blog.csdn.net/m0_74977981/article/details/144626708?spm=1001.2014.3001.5501
         </img>
        </span>
       </span>
      </a>
     </p>
    </blockquote>
    <h3 id="%E2%91%A0SpringConfig%C2%A0%EF%BC%88Spring%E6%A1%86%E6%9E%B6%E5%85%A8%E6%B3%A8%E8%A7%A3%EF%BC%89" name="%E2%91%A0SpringConfig%C2%A0%EF%BC%88Spring%E6%A1%86%E6%9E%B6%E5%85%A8%E6%B3%A8%E8%A7%A3%EF%BC%89">
     <code>
      ①SpringConfig
     </code>
     （Spring框架全注解）
    </h3>
    <pre><code class="language-java">import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;

@Configuration
@ComponentScan(value = "com.qcby")
public class SpringConfig {
}</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         @Configuration
        </code>
        注解
       </strong>
       ：标识这是一个配置类，Spring容器会扫描这个类中定义的Bean。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         @ComponentScan
        </code>
        注解
       </strong>
       ：指定Spring容器扫描的包。在这个例子中，Spring容器会扫描
       <code>
        com.qcby
       </code>
       包及其子包中的所有Spring组件（如
       <code>
        @Component
       </code>
       ,
       <code>
        @Service
       </code>
       ,
       <code>
        @Repository
       </code>
       等），并将它们注册为Spring容器中的Bean。
      </p>
     </li>
    </ul>
    <p>
     这种方式是基于Java的配置，它允许项目通过
     <strong>
      Java代码来定义Spring容器的配置（并且是范围性的）。
     </strong>
    </p>
    <h3 id="%E2%91%A1%40ImportResource%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0" name="%E2%91%A1%40ImportResource%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0">
     <strong>
      ②@
      <span style="color:#333333">
       ImportResource注解实现
      </span>
     </strong>
    </h3>
    <p>
     <strong>
      <span style="color:#333333">
       配置类
      </span>
     </strong>
    </p>
    <pre><code class="language-java">@Configuration
@ImportResource("classpath:applicationContext.xml")
public class AppConfig {
    // 配置类中的其他配置
}</code></pre>
    <p>
     <strong>
      resources路径下的：applicationContext.xml
     </strong>
    </p>
    <pre><code class="language-html">&lt;!-- applicationContext.xml --&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- &lt;context:component-scan base-package="com.qcby" /&gt; --&gt;
    &lt;!-- 扫描可以选择范围扫描或是逐一注入 --&gt;

    &lt;!-- 逐一声明Bean --&gt;
    &lt;bean id="myBean" class="com.qcby.MyBean" /&gt;
&lt;/beans&gt;</code></pre>
    <ul>
     <li>
      <strong>
       <code>
        @Configuration
       </code>
       注解
      </strong>
      ：同样标识这是一个配置类。
     </li>
     <li>
      <p>
       <strong>
        <code>
         @ImportResource
        </code>
        注解
       </strong>
       ：用于导入一个XML配置文件。在这个例子中，它导入了类路径下的
       <code>
        applicationContext.xml
       </code>
       文件。这种方式允许你将配置信息放在XML文件中，而不是Java代码中。
      </p>
     </li>
    </ul>
    <h2 id="%E4%B8%89%E3%80%81%40Bean" name="%E4%B8%89%E3%80%81%40Bean">
     三、@Bean
    </h2>
    <p>
     在Spring Boot中，推荐使用
     <strong>
      全注解
     </strong>
     的方式来配置和添加组件到Spring容器中。这种方式不仅代码更简洁，而且易于维护和理解。下面我将详细解释如何使用
     <strong>
      <code>
       @Configuration
      </code>
      和
      <code>
       @Bean
      </code>
      注解
     </strong>
     来实现这一过程。
    </p>
    <p>
     <strong>
      接口
     </strong>
    </p>
    <pre><code class="language-java">package com.qcby.service;

public interface HelloService {
    void sayHello();
}
</code></pre>
    <p>
     <strong>
      Java实现类
     </strong>
    </p>
    <pre><code class="language-java">package com.qcby.service;

import org.springframework.stereotype.Service;

@Service
public class SimpleHelloService implements HelloService {
    @Override
    public void sayHello() {
        System.out.println("Hello, Spring Boot!");
    }
}
</code></pre>
    <p>
     在这个例子中，
     <code>
      SimpleHelloService
     </code>
     类被标记为
     <code>
      @Service
     </code>
     ，这表示它是一个服务层组件，Spring会自动将其注册为一个Bean。
    </p>
    <p>
     <strong>
      <code>
       MyAppConfig类：
      </code>
     </strong>
    </p>
    <p>
     我们创建一个配置类
     <code>
      MyAppConfig
     </code>
     ，并在其中使用
     <code>
      @Bean
     </code>
     注解来声明一个Bean。
    </p>
    <pre><code class="language-java">package com.qcby.service;

import com.qcby.service.HelloService;
import com.qcby.service.SimpleHelloService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Configuration
public class MyAppConfig {
    @Bean
    @Primary // 指定为首选bean
    public HelloService helloService02() {
        System.out.println("配置类@Bean给容器中添加组件了...");
        return new SimpleHelloService();
    }
}</code></pre>
    <p>
     在这个配置类中，我们使用
     <code>
      @Bean
     </code>
     注解声明了一个
     <code>
      HelloService
     </code>
     类型的Bean。这意味着Spring容器将创建一个
     <code>
      SimpleHelloService
     </code>
     实例，并将其注册为
     <code>
      HelloService
     </code>
     类型的Bean。
    </p>
    <p>
     创建Test类确认是否调用正确：
    </p>
    <pre><code class="language-java">package com.qcby.sbdemotest01;


import com.qcby.service.HelloService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HelloServiceTest  {
    @Autowired
    private HelloService helloService;

    @Test
    void contextLoads() {
        helloService.sayHello();
    }

}
</code></pre>
    <p>
     得到结果：
     <br/>
     <img alt="" height="352" src="https://i-blog.csdnimg.cn/direct/5fa0924ed2a04e2cb5be9a4efce1f193.png" width="626"/>
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" name="%E5%9B%9B%E3%80%81%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">
     <span style="color:#333333">
      四、多配置文件
     </span>
    </h2>
    <p>
     Spring Boot 支持多环境配置，允许为不同的环境（如开发、测试、生产等）创建不同的配置文件。这是通过使用不同的配置文件来实现的，这些文件可以是
     <code>
      .properties
     </code>
     格式或
     <code>
      .yml。
     </code>
    </p>
    <h3 id="%E5%A4%9AProfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8" name="%E5%A4%9AProfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8">
     多Profile文件的使用
    </h3>
    <h4 id="%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%EF%BC%9A" name="%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%EF%BC%9A">
     <strong>
      文件命名约定
     </strong>
     ：
    </h4>
    <p>
     对于
     <code>
      .properties
     </code>
     文件，可以使用
     <strong>
      <code>
       application-{profile}.properties
      </code>
     </strong>
     来命名不同的配置文件。例如：
    </p>
    <ul>
     <li>
      <p>
       <code>
        application-dev.properties
       </code>
       ：开发环境的配置文件。
      </p>
     </li>
     <li>
      <p>
       <code>
        application-test.properties
       </code>
       ：测试环境的配置文件。
      </p>
     </li>
     <li>
      <p>
       <code>
        application-prod.properties
       </code>
       ：生产环境的配置文件。
      </p>
     </li>
    </ul>
    <p>
     <span style="color:#fe2c24">
      默认情况下，如果没有指定环境，Spring Boot 会使用
      <code>
       application.properties
      </code>
      文件。
     </span>
    </p>
    <h4 id="%E6%BF%80%E6%B4%BBProfile%EF%BC%9A" name="%E6%BF%80%E6%B4%BBProfile%EF%BC%9A">
     <strong>
      激活Profile
     </strong>
     ：
    </h4>
    <p>
     可以通过多种方式激活特定的Profile：
    </p>
    <ul>
     <li>
      <p>
       在启动应用时，通过命令行参数指定：
       <code>
        <span style="color:#fe2c24">
         <strong>
          java -jar
         </strong>
        </span>
        your-application.jar
        <span style="color:#fe2c24">
         <strong>
          --spring.profiles.active=dev
         </strong>
        </span>
        <strong>
         <span style="color:#ff9900">
          【终端】
         </span>
        </strong>
       </code>
      </p>
     </li>
     <li>
      <p>
       在
       <code>
        application.properties
       </code>
       或
       <code>
        application.yml
       </code>
       文件中指定：
       <code>
        spring.profiles.active=dev
        <strong>
         <span style="color:#ff9900">
          【配置文件中】
         </span>
        </strong>
       </code>
      </p>
     </li>
     <li>
      <p>
       在环境变量中设置：
       <strong>
        <code>
         export SPRING_PROFILES_ACTIVE=dev
        </code>
        （Linux/Mac）
       </strong>
       或
       <strong>
        <code>
         set SPRING_PROFILES_ACTIVE=dev
        </code>
        （Windows）
        <span style="color:#ff9900">
         【操作系统级别】
        </span>
       </strong>
      </p>
     </li>
    </ul>
    <h4 id="YAML%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81%E5%A4%9A%E6%96%87%E6%A1%A3%E5%9D%97%EF%BC%9A" name="YAML%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81%E5%A4%9A%E6%96%87%E6%A1%A3%E5%9D%97%EF%BC%9A">
     <strong>
      YAML文件支持多文档块
     </strong>
     ：
    </h4>
    <p>
     YAML文件支持多文档块方式，这意味着可以在一个YAML文件中定义多个配置块，每个块对应一个Profile。例如：
    </p>
    <pre><code class="language-javascript">spring:
  profiles: dev
  application:
    name: MyApplication

---
spring:
  profiles: test
  application:
    name: MyTestApplication

---
spring:
  profiles: prod
  application:
    name: MyProductionApplication</code></pre>
    <p>
     在这个例子中，我们定义了三个配置块，每个块对应一个不同的Profile（开发、测试、生产）。Spring Boot会根据激活的Profile加载相应的配置块。
    </p>
    <h2 id="%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7" name="%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7">
     五、配置加载位置优先级
    </h2>
    <p>
     Spring Boot在启动时会按照一定的顺序扫描并加载配置文件，这些配置文件的位置和优先级如下：
    </p>
    <ol>
     <li>
      <p>
       <code>
        file:./config/
       </code>
       ：项目根目录下的
       <code>
        config
       </code>
       文件夹中。
      </p>
     </li>
     <li>
      <p>
       <code>
        file:./
       </code>
       ：项目根目录中。
      </p>
     </li>
     <li>
      <p>
       <code>
        classpath:/config/
       </code>
       ：类路径下的
       <code>
        config
       </code>
       文件夹中。
      </p>
     </li>
     <li>
      <p>
       <code>
        classpath:/
       </code>
       ：类路径根目录中。
      </p>
     </li>
    </ol>
    <p>
     Spring Boot会从这四个位置加载
     <code>
      application.properties
     </code>
     或
     <code>
      application.yml
     </code>
     文件作为默认配置文件
     <span style="color:#fe2c24">
      <strong>
       ，优先级由高到低，高优先级的配置会覆盖低优先级的配置
      </strong>
     </span>
     。这意味着如果同一配置项在多个文件中出现，那么优先级高的文件中的配置将被使用。
    </p>
    <blockquote>
     <p>
      /myproject
      <br/>
      /src
      <br/>
      /main
      <br/>
      /java
      <br/>
      /com
      <br/>
      /yourcompany
      <br/>
      /YourApplication.java
      <br/>
      /resources
      <br/>
      <strong>
       application.properties
      </strong>
      <br/>
      /config
      <br/>
      <strong>
       application.properties
      </strong>
      <br/>
      <strong>
       application.properties
      </strong>
     </p>
    </blockquote>
    <p>
     即：
    </p>
    <p>
     <img alt="" height="652" src="https://i-blog.csdnimg.cn/direct/d2947f64b9974571aab170cc5ef04bb7.png" width="547"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343937373938312f:61727469636c652f64657461696c732f313436323935393234" class_="artid" style="display:none">
 </p>
</div>


