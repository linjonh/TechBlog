---
layout: post
title: "Linux我做主基础命令完全指南下篇"
date: 2025-03-16 19:03:56 +08:00
description: "本文详细介绍Linux系统一些进阶命令的使用，更多用法需结合man手册进行查询。"
keywords: "【Linux我做主】基础命令完全指南下篇"
categories: ['Linux系统从命令到内核的系统编程']
tags: ['运维', '服务器', '开源', 'Unix', 'Linux', 'Centos', 'C']
artid: "146295920"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146295920
    alt: "Linux我做主基础命令完全指南下篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146295920
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146295920
cover: https://bing.ee123.net/img/rand?artid=146295920
image: https://bing.ee123.net/img/rand?artid=146295920
img: https://bing.ee123.net/img/rand?artid=146295920
---

# 【Linux我做主】基础命令完全指南下篇
## Linux基础命令完全指南
## github地址
[有梦想的电信狗](https://github.com/changan-memory)
## 前言
本文介绍`Linux系统`的基本知识和一些常见命令的基本使用，更多用法需结合`man`手册进行查询。命令和命令的细节较多，因此文章分为上篇和下篇。本文是文章的下篇。
## 回顾上篇
> 在上篇中我们引入了命令行操作，介绍了Linux下的一些基础概念和一些常见指令的使用。接下来我们来介绍一些进阶指令。
## 进阶命令
### 删除命令rm&rmdir
#### rmdir
> rmdir是一个与mkdir相对应的命令。mkdir是建立目录，而rmdir是删除命令。
**语法** ：`rmdir [-p] [dirName]`
**适用对象** ：具有当前目录操作权限的所有使用者
**功能** ：删除空目录。注意:`rmdir`只能用于删除目录
**常用选项** ：
* `-p` 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。
* `-p`可以直接理解成递归删除子目录。
#### rm
> `rm`命令可以同时删除文件或目录
**语法** ：`rm [-f-i-r-v][fileName/dir]`
**适用对象** ：所有使用者
**功能** ：删除文件或目录(可以删除一切能被删除的内容)
**常用选项** ：
* `-f` 即使文件属性为`只读(即写保护)`，亦直接删除。强制(`force`)删除文件，删除时不会进行询问是否确认删除
* `-i` 删除前逐一询问确认
* `-r` 递归删除目录及其下所有文件
> 可以看到，`rm`命令既可以删除普通文件，也可以删除目录以及递归的目录文件，因此一般多使用功能更强大的`rm`命令
### 查找相关
> `Linux`下的查找指令分为，`查找文件`和`查找文件中的内容`。(`Linux下一切皆文件`)
#### which
**语法** ： `which [选项] 命令名`
**​功能** :
​+ **查找可执行文件** ：在 PATH 环境变量指定的目录中搜索给定的命令，返回第一个匹配的可执行文件的完整路径。
**常用选项** ：
* `-a`: 显示所有匹配的路径，而不仅仅是第一个。适用于存在多个同名命令的情况。
* `--version`：显示 which 的版本信息（部分系统支持）
* `--help`: 显示帮助信息，简要说明选项用法（部分系统支持）。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cb85cc9e583b4a3180f9f076b0ba7d4c.png)
> 可以看到，我们的所有的系统命令都存放在系统目录`/bin/`下。
#### Linux下命令的本质
* 执行指令前，我们应该先在系统重查找到对应的指令。既然可以指令可以被查找，那么指令一定是在系统的某个位置存在的。
>
> 通过`which`指令，我们不难想到，Linux下的命令，其实就是一个可执行程序，当我们在终端输入命令时，由shell命令解释器解析命令后，在系统的环境变量`PATH`目录下进行查找，之后根据参数执行指令。
* 指令就是安装在系统指定路径下的可执行文件罢了。
#### find
**语法** ： `find [pathname] [-options]`; **find后跟路径名，再跟选项**
**功能** ： 用于在文件树中(Linux的磁盘文件系统为树形结构)`查找文件`，并作出相应的处理（可能访问磁盘）
> 前面提到，`Linux下一切皆文件`，而`find`用于`查找文件`。因此可以得出，`find可以查找整个磁盘中的任何文件`。
**常用选项** ：
* `-name` 按照文件名查找文件。我们最常用的是按照文件名进行查找。
# 示例
find ./ -name *.jpg # *为通配符，匹配 0-n个字符
# 在当前路径下查找以.jpg结尾的文件
> 由于`find`指令的选项过多，这里就不一一介绍了，我们可以通过`man`手册对`find`指令进行学习如下查找选项：
* `-size`
* `-time`
* `-type`
* `-maxdepth`
#### whereis
**语法** ： `whereis 指令名或文件名`
**​功能** :
`whereis`命令介于`find`和`which`之间，可查找`可执行文件`，也可查找`手册`、`安装包`、`压缩包`之类的文件，在终端中`显示文件的绝对路径`。
* **在系统的指定路径下进行查找**
​+ **查找可执行文件**
* **查找文件、手册、压缩包等** :
* **会显示文件的完整路径**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a134b74e3244d19a100e33ca227d53a.png)
#### grep
> `grep`是一个行文本过滤工具，主要用于查找文件中的内容。
**语法** ： `grep [选项] 搜寻字符串 文件`
**功能** ： 在文件中搜索字符串，将找到的行打印出来
**常用选项** ：
* `-i` ：忽略大小写的不同，将大小写视为相同
* `-n` ：查找字符串时输出行号
* `-v` ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行
* `-R` ： 递归式的在目录中进行过滤
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3b19e1072d06416c84b3da166d4c38fc.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/035db9935fc24582920f29c5c4e8c993.png)
#### 查找对象对比
命令| 查找对象| 主要用途| 查找范围| 常用参数/选项| 示例
---|---|---|---|---|---
**find**| 文件或目录| 按名称、类型、时间等条件搜索文件/目录| 指定目录（**`默认递归当前目录`** ）| `-name`,
`-type`, `-size`| `find /home -name "*.txt"`
**whereis**| 可执行文件、源码、手册页| 快速定位二进制文件、源码和文档| 系统预定义路径（如 `/bin`, `/usr`）|
`-b`（二进制）, `-m`（手册）| `whereis -b ls`
**which**| 可执行文件（PATH 中的命令）| 确定当前 Shell 使用的命令路径| 用户 `$PATH` 环境变量中的目录|
无（仅路径查询）| `which python`
**grep**| 文件内容（文本模式）| 在文件内容中搜索匹配的文本模式| 指定文件或输入流| `-i`（忽略大小写）, `-r`（递归）| `grep
"error" log.txt`
* * *
### 解压与压缩相关
> 问题：为什么要进行打包和压缩？
1. 能被打包压缩的，一定是**一个整体。**
2. 打包压缩后，多个文件变成了单个文件。可以**有效防止文件在传输途中丢失**
3. 打包压缩后，总体的**体积变小** 。**下载时间更短，占据的体积更小。**
#### zip 和 unzip
**语法** ： `zip filename.zip 目录或文件`
**功能** ： 将目录或文件`压缩成zip格式`
**常用选项** ：
* `-r` 递归处理，将指定目录下的所有文件和子目录一并处理
> `zip`默认是非递归式的打包，因此我们在打包目录式，一定要加上`-r`选项。
# 打包一个目录
zip -r d1.zip test_zip/
# 解压
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c268abb40cbb493fabe446e211ec062b.png)
# 可以看到，终端中对压缩包用特性的颜色标识
# 对压缩后的文件进行解压
unzip d1.zip # 默认解压到当前目录
# 解压到home目录下
unzip d1.zip -d /home
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3e29d6b5322c48f9b5af6dfa73b67fe0.png)
#### tar
**语法** ：`tar [-cxtzjvf] 文件与目录 .... 参数`
**功能** ：
1. 对一系列文件或目录进行`打包`。
2. 对`tar`打包后得到的结果进行`解包`。
3. `tar`命令还可对由`tar`产生的压缩包进行`预览`。
**常用选项** ：
* `-c` ：建立一个压缩文件的参数指令(create 的意思)；
* `-x` ：解开一个压缩文件的参数指令！
* `-t` ：查看 `tarfile` 里面的文件！
* `-z` ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩算法？
* `-j` ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩算法？
* `-v` ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！
* `-f` ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！
* `-C` ： 解压到指定目录
> tar的指令这么多,其实我们只需要记住三种命令组合，两种常用后缀即可。
* **打包压缩** ：`tar -czf [包名] [待的文件或目录]`
* **预览包中的内容** ： `tar -tzf XXX.tgz`或`tar -tzf XXX.tar.gz`。其中`XXX`表示去除后缀名后的文件名。
* **解压解包** ： `tar -xzf XXX.tgz`或`tar -xzf XXX.tar.gz`。其中`XXX`表示去除后缀名后的文件名。
* `.tar`是打包后缀
* `.gz`是压缩后缀。`.gz`是`.tar.gz`的简写。
> 压缩后查看包的内容
* 打包为`.tar.gz`并查看
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/63044a51598c4b9abd961d6ced7b0c9d.png)
* 打包为`.tgz`并查看
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/74f1b22468a54d1fb8a1be8f3a3a9c8a.png)
### echo
#### 基本语法及使用
**语法** ： `echo [选项] [字符串]`
**功能** ： 输出指定的字符串或变量值到`标准输出`(**默认是显示器**)
`echo`输出是默认有换行符，`printf`默认无换行符
**常用选项** ：
* `-n` ：不输出行尾的换行符
* `-e` ：启用反斜杠转义字符的解释（如 `\n` 换行、`\t` 制表符等）
* `-E` ：**禁用** 反斜杠转义字符的解释（**默认就是禁用的** ）
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8c538883117841dfbb9fdd605a9e3bff.png)
**示例** ：
1. 输出环境变量值：
echo $PATH
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/40a789f6807c4cd0a416d4804c1b4598.png)
2. 启用转义字符换行：
echo -e "Hello\nWorld"
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/15bb56cf04d7439192935e1557ea8961.png)
3. 不换行输出：
echo -n "Hello"
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e6d6d29f6ab74f788ae13e09ce480272.png)
**注意** ：不同系统的 `echo` 行为可能不同，建议在脚本中使用 `printf` 以获得更一致的结果。
#### 与cat进行对比
* `echo`是把后面`跟的字符串`写入到显示器
* `cat`是把`后面文件的内容`写入到显示器
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/375717d597644b21aa663c812424a00e.png)
### echo与重定向
#### 1\. 输出重定向
将命令的输出结果 重定向 **写入到文件** （而非默认的终端文件）。
> 重定向的原理：
> `把本该输出到显示器的内容，重定向，输出到文件中`
符号| 作用
---|---
`>`| `覆盖`写入文件（若文件不存在则创建）
`>>`| `追加`写入文件（若文件不存在则创建）
`>`输出重定向时执行的操作：
`1`. 清空文件内容。
`2`. 写入新内容
`>>`输出重定向时执行的操作：
* 在文件末尾追加内容。
**示例** ：
`1`. **覆盖写入** ：
# 将 "Hello" 写入 output.txt（覆盖原有内容）
echo "Hello" > output.txt
`2`. **追加写入** ：
# 将 "World" 追加到 output.txt 末尾
echo "World" >> output.txt
`3`. **结合变量** ：
name="Alice" # 输出变量值到文件
echo "Name: $name" > user.txt
* * *
#### 2\. 输入重定向
将文件内容作为命令的输入（**代替键盘输入** ）。
符号| 作用
---|---
`<`| 从文件读取输入
`<<`| **Here Document** ：从命令行直接输入多行内容（直到指定终止符）
**示例** ：
`1`. **从文件读取输入** （结合 `cat`）：
# 前文我们已指出
# cat的输入默认是键盘
# < 可以将cat的输入重定向为文件
cat < input.txt # 显示 input.txt 的内容（等同于 cat input.txt）
> `cat`的输入本该从键盘读入，利用重定向，让`cat`从文件读入。
`2`. **Here Document** （多行输入）：
cat << EOF
Line 1
Line 2
EOF
输出：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e15909b0baf1419e99fc5b8a041cc98c.png)
`3`. **结合`echo` 生成多行文件**：
echo -e "Line 1\nLine 2" > lines.txt # -e 启用转义符
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d1a6a18c2b58424c941c07791d6c2627.png)
* * *
#### 综合使用场景
1. **快速创建配置文件** ：
cat > config.conf << EOF
user = admin
port = 8080
timeout = 60
EOF
_生成`config.conf` 文件并写入指定内容。_
2. **追加日志信息** ：
echo "[$(date)] Log message" >> app.log
3. **通过管道传递`echo` 输出**：
echo "Error: something wrong" | grep "Error" # 筛选含 "Error" 的行
4. **通过`echo`快速创建文件**：
#快速创建新文件
>newfile.txt
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/65b00a6b5dc64aa8b295cee944d5580d.png)
* * *
#### 注意事项
1. `>` 会覆盖文件内容，使用前确认文件是否重要。
2. 若需避免误覆盖，可设置 `set -o noclobber`（Bash 中生效），此时 `>` 会拒绝覆盖已有文件。
3. **`<<` 的终止符**（如 `EOF`）必须单独成行且顶格书写。
4. 不同 Shell（如 Bash、Zsh）对重定向的支持略有差异，但大多数场景下行为一致。
### 管道符 `|`
将前一个命令的 **标准输出** 作为后一个命令的 **标准输入** ，用于串联多个命令，实现数据流的逐级处理。
* * *
#### 语法
命令1 | 命令2 | 命令3 ...
`管道`：级联左侧指令和右侧指令。
`1. `将左侧程序的输出交给管道文件
`2. `让右侧的程序再从管道文件中读入到自己的程序
> 管道是一种符号，会被系统解释成为管道文件，是一种内存级的文件(存在于内存中)
* * *
#### 功能
1. **串联命令** ：将多个命令组合成处理流水线，前一个命令的输出作为后一个命令的输入。
2. **数据过滤与加工** ：常用于结合 `grep`、`awk`、`sed`、`sort` 等工具进行文本处理。
3. **简化复杂操作** ：避免生成中间临时文件，直接在内存中传递数据流。
* * *
#### 常用场景
场景| 示例| 作用
---|---|---
**过滤文本**| `cat log.txt| grep “Error”`
**统计数量**| `ls -l| wc -l`
**排序去重**| `sort data.txt| uniq`
**分页查看**| `ls -a| less`
**多级处理**| `ps aux| grep “nginx”
* * *
#### 示例
1. **基础过滤** ：
echo -e "apple\nbanana\ncherry" | grep "an"
输出：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/16533ec4264146199a47c14001e641ad.png)
2. **处理文本** ：
# 查看一个文件中间的 20 行
cat log.txt | head -60 | tail -20
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c1c1a2bad3254208b2946ef64d997d5f.png)
4. **多级处理** ：
cat access.log | awk '{print $1}' | sort | uniq -c | sort -nr
_解析日志文件，统计并排序访问量最高的 IP 地址。_
5. **结合重定向** ：
ls *.txt | wc -l > count.txt # 统计 txt 文件数并保存到 count.txt
* * *
#### 注意事项
1. **仅传递标准输出** ：管道默认不传递错误输出（需用 `2>&1` 合并错误流）。
2. **命令顺序敏感** ：需确保前一个命令的输出格式能被后一个命令正确处理。
# 错误示例：试图用 grep 过滤非文本输出
ls -l | grep "*.jpg" # 可能无法匹配文件名
3. **性能影响** ：长管道可能降低效率（尤其是在处理大文件时）。
4. **替代方案** ：复杂操作可改用 `xargs` 或 `tee` 增强功能。
* * *
#### 扩展技巧
* **合并错误流** ：
ls /invalid_dir 2>&1 | grep "No such file"
* **并行处理** ：
find . -type f | parallel gzip # 使用 GNU Parallel 并行压缩文件
* **可视化管道流** ：
echo "hello" | tee >(grep "h") >(wc -c) # 同时输出到多个命令
管道符是 Shell 编程的核心工具，熟练掌握可极大提升命令行操作效率！
### 查看历史使用过的命令
#### ctrl + r搜索历史命令
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7ac04770667c4f0a9f3a53eaa49022f9.png)
> 当我们在终端中输入`ctrl +
> r`时，会出现以上提示，之后输入字符串，会自动搜索最近一次使用过的包含有该子串的命令,按下回车会执行该命令。这也是一个实用的技巧。
* 既然能够查找到历史使用过的命令，那么这些使用过的命令一定被存储在了某个位置。下面的`history`指令可以查看历史所有命令。
#### history命令
**语法** ：`history [选项] [n]`
• **`n`（可选参数）**：显示最近的 `n` 条历史记录。例如，`history 10` 显示最近10条命令。
**功能**
1. **查看历史记录** ：默认显示所有命令历史，按时间顺序排列，每条记录前有编号。
2. **快速执行历史命令** （需结合其他操作）：
• `!n`：执行编号为 `n` 的命令。
• `!!`：执行上一条命令。
• `!string`：执行最近一条以 `string` 开头的命令。
3. **管理历史记录** ：可清空、删除或同步历史记录。
* * *
**常用选项**
选项| 说明
---|---
`-c`| 清空当前会话的历史记录（不影响历史文件）。
`-d offset`| 删除指定编号的历史记录。例如，`history -d 1000` 删除第1000条记录。
`-a`| 将当前会话的历史记录追加到历史文件（默认文件：`~/.bash_history`）。
`-w`| 将当前历史记录覆盖写入历史文件。
`-r`| 从历史文件中读取记录到当前会话。
`-n`| 显示尚未加载到当前会话的新历史记录（如其他终端写入的内容）。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8cf2a9ab9a3a4da1bd85ea145fc04bb2.png)
* * *
##### 环境变量与历史命令存储的位置
* 我们使用过的历史命令保存在内存中，默认记录`1000`条历史命令
* **`HISTSIZE`** ：控制内存中保存的历史记录条数（默认为500或1000）。
* **`HISTFILE`** ：指定历史文件路径（默认为 `~/.bash_history`）。
* * *
### 查看系统及硬件信息相关
> 查看系统内核版本和架构信息
#### uname
**语法** ：`uname [选项]`
**功能** ： `uname`用来获取电脑和操作系统的相关信息。
**补充说明** ：`uname`可显示`linux`主机所用的操作系统的版本、硬件的名称等基本信息。
**常用选项** ：
* `-a或–all` 详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称。
* `-r`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1c2a427e0f0c45ad8d762d40ebebd809.png)
#### lscpu
> 查看cpu的信息
* `lscpu`直接输入即可
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bf1e7b5e88d24e9aa9ebb2f961004422.png)
#### lsmem
> 查看内存的信息
* `lsmem`直接输入即可
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a00a79820caa4f1c975a16498764bfaf.png)
#### df
* 常用选项组合为 `df -h`,可以方便的查看系统的磁盘信息及使用情况。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2014925a7129457c96689835a571f191.png)
### 好用的工具命令
#### cal
>
> cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。
**语法** ： `cal [参数][月份][年份]`
**功能** ： 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份
**常用选项** ：
* `-3`:显示系统的当前月，前一个月和下一个月的日历。
* `-j` 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数）
* `-y` 显示当前年份的日历
* -3
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3d88e30d4c1b4c6ca69c1b0b2de60f5f.png)
* -j。可以看到，2025年3月11日是当年的第70天
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2d195f9874b44dab8f5cf699f449f658.png)
* -y。显示一年中所有月份的日历
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b16855f1128b445493e434da4edbd28c.png)
#### bc
> `bc`命令可以很方便的进行浮点运算，`bc`就是Linux终端下的一个计算器。
>
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b2e559bc72b94568944f4dcfbc3cabbd.png)
* 输入数字和运算符，回车键课得出结果。
### Linux命令的手册 man
> `Linux操作系统`下有很多指令，且每条命令有很多参数，我们不可能完全熟记于心。因此Linux中内置的指令手册，提供了指令的用法以及指令的参数的功能。
访问Linux手册页的命令是`man`
**语法** : `man [选项] 命令`
**常用选项** ：
* -k 根据关键字搜索联机帮助
* num 只在第num章节找
* -a 将所有章节的都显示出来，比如 man printf 它缺省从第一章开始搜索，知道就停止，用a选项，当按下q退出，他会继续往后面搜索，直到所有章节都搜索完毕。
#### **man 手册章节标准划分**
Linux的联机手册（manual）按内容类别分为 **9个标准章节** ，部分系统可能扩展更多章节（如第0、n节）。每个章节存放特定类型的文档：
章节| 内容类型| 典型示例
---|---|---
**1**| **用户命令**
（普通用户可执行的命令）| `ls`, `grep`, `man`
**2**| **系统调用**
（内核提供的底层函数）| `open`, `fork`, `write`
**3**| **库函数**
（C标准库等编程接口）| `printf`, `malloc`, `pthread_create`
**4**| **特殊文件**
（设备文件、驱动程序）| `/dev/null`, `tty`, `sd`
**5**| **文件格式与配置文件**
（配置文件语法、数据文件格式）| `/etc/passwd`, `crontab`, `json`
**6**| **游戏**
（娱乐程序说明）| `bastet`（俄罗斯方块）, `ninvaders`
**7**| **杂项**
（协议、宏包、字符集等）| `utf-8`, `tcp`, `groff`
**8**| **系统管理命令**
（需root权限的命令）| `mount`, `fdisk`, `systemctl`
**9**| **内核例程**
（内核内部API，非标准章节）| `sysctl`, `proc`文件系统
* * *
例如我想查看`rm`指令的用法
man 1 rm
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9c3346b6e2cc449892561ee20fa9141f.png)
> 需要查找什么内容直接在各自的章节查找即可。
`man`手册内提供了相应命令的用法和参数的意义，其他命令的查询也是如此。当我们遇到不清楚的指令时，便可以查询`man`手册。
> 如果你的系统未安装`man`手册，则安装命令如下。
sudo yum install man-pages # CentOs系统下的安装
# 需要root权限
### shutdown关机指令
**语法** ：`shutdown [选项]`
**功能** ：关机
** 常见选项：**
* `-h` ： 将系统的服务停掉后，立即关机。
* `-r` ： 在将系统的服务停掉之后就重新启动
* `-t sec` ： -t 后面加秒数，即『过几秒后关机』的意思
**关机指令就是简单的关机，可以根据不同的需求选择合适的参数** 。
* * *
### **总结与建议**
1. **动手实验** ：每条命令至少实操3遍，观察输出结果。
2. **组合使用** ：尝试管道符组合`find`、`grep`、`wc`等命令。
3. **安全第一** ：慎用`rm -rf`，删除前用`ls`验证路径。
4. **手册优先** ：遇到新命令先`man`查用法，再搜索示例。
通过上述思考，逐步将命令内化为“肌肉记忆”，提升Linux操作效率！
**以上就是本文的所有内容了，如果觉得文章写的不错，还请留下免费的赞和收藏，也欢迎各位大佬在评论区交流**
> `分享到此结束啦`
> `一键三连，好运连连！`