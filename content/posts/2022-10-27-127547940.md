---
layout: post
title: "图的广度优先搜索和深度优先搜索"
date: 2022-10-27 23:10:47 +0800
description: "图的广度优先搜索和深度优先搜索，BFS和DFS的算法思路、分析、"
keywords: "有向图的广度优先搜索"
categories: ['数据结构']
tags: ['算法', '数据结构', '图论', 'C']
artid: "127547940"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=127547940
    alt: "图的广度优先搜索和深度优先搜索"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=127547940
featuredImagePreview: https://bing.ee123.net/img/rand?artid=127547940
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     图的广度优先搜索和深度优先搜索
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="%E4%B8%80%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:0px;">
     <a href="#%E4%B8%80%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">
      一、图的基本操作
     </a>
    </p>
    <p id="%E4%BA%8C%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:0px;">
     <a href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">
      二、图的遍历
     </a>
    </p>
    <p id="%E2%91%A0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-toc" style="margin-left:40px;">
     <a href="#%E2%91%A0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" rel="nofollow">
      ①广度优先搜索
     </a>
    </p>
    <p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;">
     <a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">
      基本思想
     </a>
    </p>
    <p id="BFS%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#BFS%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" rel="nofollow">
      BFS实现方法
     </a>
    </p>
    <p id="BFS%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;">
     <a href="#BFS%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81" rel="nofollow">
      BFS算法代码
     </a>
    </p>
    <p id="%C2%A0BFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;">
     <a href="#%C2%A0BFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">
      BFS算法分析
     </a>
    </p>
    <p id="BFS%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8-toc" style="margin-left:80px;">
     <a href="#BFS%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8" rel="nofollow">
      BFS算法应用
     </a>
    </p>
    <p id="%E2%91%A1%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%C2%A0-toc" style="margin-left:40px;">
     <a href="#%E2%91%A1%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%C2%A0" rel="nofollow">
      ②深度优先搜索
     </a>
    </p>
    <p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;">
     <a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">
      基本思想
     </a>
    </p>
    <p id="DFS%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;">
     <a href="#DFS%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" rel="nofollow">
      DFS实现方法
     </a>
    </p>
    <p id="DFS%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;">
     <a href="#DFS%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81" rel="nofollow">
      DFS算法代码
     </a>
    </p>
    <p id="%C2%A0DFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-toc" style="margin-left:80px;">
     <a href="#%C2%A0DFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90" rel="nofollow">
      DFS算法分析
     </a>
    </p>
    <p id="DFS%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%C2%A0-toc" style="margin-left:80px;">
     <a href="#DFS%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%C2%A0" rel="nofollow">
      DFS算法应用
     </a>
    </p>
    <p id="%E4%B8%89%E3%80%81%E9%81%8D%E5%8E%86%E5%BE%97%E5%88%B0%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:0px;">
     <a href="#%E4%B8%89%E3%80%81%E9%81%8D%E5%8E%86%E5%BE%97%E5%88%B0%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">
      三、遍历得到的生成树、生成森林相关问题
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%A0">
     <span style="color:#1a439c;">
      <strong>
       一、图的基本操作
      </strong>
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#4da8ee;">
       //备注为图在邻接矩阵法和邻接表法下的时间复杂度,问题规模V为顶点数，E为边数。
      </span>
     </p>
     <p>
      <span style="color:#4da8ee;">
       邻接矩阵法的顶点表为一维数组，边表为二维数组存储。
      </span>
     </p>
     <p>
      <span style="color:#4da8ee;">
       邻接表法的顶点表为一维数组，边表为V个链表。
      </span>
     </p>
     <ul>
      <li>
       Adjacent(G,x,y) 判断图G是否存在边(x,y)或&lt;x,y&gt;。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(1),邻接表法为O(E
       </span>
       <span style="color:#ff9900;">
        )
       </span>
      </li>
      <li>
       Neighbors(G,x)  列出图G中与顶点x邻接的边。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(V),邻接表法为O(E)
       </span>
      </li>
      <li>
       InsertVex( &amp;G, x )    在图G中增添新顶点x。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(V)，邻接表法为O(1)
       </span>
      </li>
      <li>
       DeleteVex( &amp;G, x )   在图G中删除顶点x及其相关的弧。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(
        <img alt="gif.latex?V%5E%7B2%7D" class="mathcode" src="https://latex.csdn.net/eq?V%5E%7B2%7D">
         ) ,邻接表法需遍历整个邻接表找相关弧故为O(E)。
        </img>
       </span>
       <span style="color:#a2e043;">
       </span>
      </li>
      <li>
       AddEdge( &amp;G, x, y )  若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图中添加该边。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(1)，邻接表法即同单链表头插为O(1)。
       </span>
      </li>
      <li>
       RemoveEdge( &amp;G, x, y ) 若无向边(x,y)或有向边&lt;x,y&gt;存在，则在图中删除该边。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(1)，邻接表法为O(E)。
       </span>
      </li>
      <li>
       Get_edge_value(G,x,y)  获取图G无向边(x,y)或有向边&lt;x,y&gt;对应的权值。
       <span style="color:#ff9900;">
        //等同判断该边是否存在。
       </span>
      </li>
      <li>
       Set_edge_value(G,x,y,v)  设置图G无向边(x,y)或有向边&lt;x,y&gt;的权值为v。
       <span style="color:#ff9900;">
        //等同判断该边是否存在。
       </span>
      </li>
      <li>
       <span style="color:#ff9900;">
        //对于有向图G=(V,E),如果有弧&lt;v,v’&gt;，则称顶点V邻接到顶点V’，或顶点V’邻接自顶点V
       </span>
      </li>
      <li>
       FirstNeighbor( G, x)   返回顶点x的第一个邻接顶点的顶点号。若顶点在G中没有邻接顶点，则返回-1。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(V)，邻接表法为O(1)
       </span>
      </li>
      <li>
       NextNeighbor( G, x, y )  假设顶点y是顶点x的一个邻接顶点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接顶点，则返回-1。
       <span style="color:#ff9900;">
        //邻接矩阵法为O(V)，邻接表法为O(1)
       </span>
      </li>
     </ul>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0">
     <span style="color:#1a439c;">
      二、图的遍历
     </span>
    </h2>
    <p>
     <strong>
      图的遍历
     </strong>
     是指从图中某一个顶点出发，按某种搜索方法沿着图中的边对图中的所有顶点都访问一次且仅访问一次。
    </p>
    <p>
     图的任一顶点都可能会和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点上。
     <strong>
      为避免同一顶点被访问多次
     </strong>
     ，在遍历图的过程中，我们必须记下每个已经访问过的顶点，为此可以设置一个辅助数组visited[]来标记顶点是否被访问过。
    </p>
    <p>
     图的遍历算法主要有两种：广度优先搜索和深度优先搜索。
    </p>
    <h3 id="%E2%91%A0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">
     <span style="color:#1a439c;">
      <strong>
       ①广度优先搜索
      </strong>
     </span>
    </h3>
    <p>
     (Breadth-First-Search,
     <strong>
      BFS
     </strong>
     )类似于树的层序遍历算法。
    </p>
    <blockquote>
     <h4 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">
      <span style="color:#1a439c;">
       基本思想
      </span>
     </h4>
     <ol>
      <li>
       首先访问起始顶点v；
      </li>
      <li>
       然后依次访问v的未访问过的邻接顶点
       <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D">
        、
        <img alt="gif.latex?w_2%7B%7D" class="mathcode" src="https://latex.csdn.net/eq?w_2%7B%7D">
         ,...,
         <img alt="gif.latex?w_%7Bn%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bn%7D">
          ；
         </img>
        </img>
       </img>
      </li>
      <li>
       然后依次访问
       <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D">
        、
        <img alt="gif.latex?w_2%7B%7D" class="mathcode" src="https://latex.csdn.net/eq?w_2%7B%7D">
         ,...,
         <img alt="gif.latex?w_%7Bn%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bn%7D">
          的所有未被访问过的邻接顶点；
         </img>
        </img>
       </img>
      </li>
      <li>
       再从依次从这些访问过的邻接顶点出发，访问它们的所有未被访问过的邻接顶点；
      </li>
      <li>
       依次类推，直到与V连通的所有顶点都被访问过为止。
      </li>
      <li>
       若此时图中尚有顶点未被访问，则选另图中一个未曾被访问过的顶点作为起始顶点，重复上述过程，直到图中所有顶点都被访问过为止。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <h4 id="BFS%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">
      <span style="color:#1a439c;">
       BFS实现方法
      </span>
     </h4>
     <ul>
      <li>
       找一个顶点的所有未访问过的邻接顶点我们用到这两个接口函数FirstNeighbor( G, x)、NextNeighbor( G, x, y )
      </li>
      <li>
       我们访问完
       <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D">
        、
        <img alt="gif.latex?w_2%7B%7D" class="mathcode" src="https://latex.csdn.net/eq?w_2%7B%7D"/>
        ,...,
        <img alt="gif.latex?w_%7Bn%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bn%7D"/>
        后要访问
        <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D"/>
        的未访问过的邻接顶点了，但是我们一会还要访问
        <img alt="gif.latex?w_2%7B%7D" class="mathcode" src="https://latex.csdn.net/eq?w_2%7B%7D"/>
        的未访问过的邻接顶点，因此需要保留
        <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D"/>
        、
        <img alt="gif.latex?w_2%7B%7D" class="mathcode" src="https://latex.csdn.net/eq?w_2%7B%7D"/>
        ,...,
        <img alt="gif.latex?w_%7Bn%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7Bn%7D"/>
        这些顶点的信息以供我们接下来访问它们的未访问过的邻接顶点，符合先进先出因此我们借助一个
        <strong>
         辅助队列
        </strong>
        。
       </img>
      </li>
      <li>
       bool型辅助数组visited[MAX_VERTEX_NUM]的下标用来代表每个顶点的编号，并存放它们是否被访问过的信息。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <h4 id="BFS%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81">
      <span style="color:#1a439c;">
       BFS算法代码
      </span>
     </h4>
     <pre><code class="language-cpp">bool visited[MAX_VERTEX_NUM];
void BFS(Graph G,int V);
void BFSTraverse(Graph G)
{
    for(i=0;i&lt;G.vexnum;i++)
    visited[i]=FALSE;//将顶点都标志为未访问过
    InitQueue(Q);//初始化辅助队列
    for(i=0;i&lt;G.vexnum;i++)
    {
        if(!visited[i])//确保所有连通分量都被访问过一次，即上文基本思想中的6
        BFS(G,i);    
    }
        
}
void BFS(Graph G,int V)
{
    visit(V);//访问初始顶点
    visited[V]=TURE;//标志为已访问
    Enqueue(Q,V);//入队列
    while(!isEmpty(Q))
    {
        DeQueue(Q,V);//出队列去访问它的未访问过的邻接顶点
        for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w ))
        {//依次访问每一个未访问过的邻接顶点
            if(!visited[w])
            {
                visit(w);
                visited[w]=TURE;
                Enqueue(Q,w);//该顶点入队列   
            }     
    }
}</code></pre>
    </blockquote>
    <blockquote>
     <h4 id="%C2%A0BFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">
      <span style="color:#1a439c;">
       BFS算法分析
      </span>
     </h4>
     <ul>
      <li>
       无论是邻接表法还是邻接矩阵的存储方式，我们都需要一个辅助队列Q，空间复杂度为O(|V|)
      </li>
      <li>
       采用邻接表存储方式时，每个顶点都入队一次时间复杂度为O(|V|),每条边都至少被访问一次(出边表遍历)时间复杂度为O(|E|)。故总的时间复杂度为O(|V|+|E|)。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为O(|V|)，故算法总的时间复杂度为O(|
       <img alt="gif.latex?V%5E%7B2%7D" class="mathcode" src="https://latex.csdn.net/eq?V%5E%7B2%7D"/>
       |)
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <h4 id="BFS%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8">
      <span style="color:#1a439c;">
       BFS算法应用
      </span>
     </h4>
     <ul>
      <li>
       <strong>
        我们可以使用BFS算法求解无权图的单源最短路径问题
       </strong>
       。这是由BFS算法总是按照距离由近及远来遍历图中的每个顶点的性质决定的。
      </li>
      <li>
       <pre><code class="language-cpp">#define INFINITY 65535//用65535来代表无穷
void BFS_MIN_Distance(Graph G,int u)
{//d[i]表示从u到i的最短路径
  for(i=0;i&lt;G.vexnum;i++)
    { d[i]=65535;//初始化路径长度
      path[i]=-1;//i的最短路径从哪个顶点过来
    }
    visited[u]=TRUE;
    d[u]=0;
    EQueue(Q,u);
 while(!isEmpty(Q))
    {
        DeQueue(Q,u);//队头元素出队列
        for(w=FirstNeighbor(G,u);w&gt;=0;w=NextNeighbor(G,u,w ))
        {
            if(!visited[w])
            {
                visited[w]=TRUE;
                d[w]=d[u]+1//注意此处u为刚出队列的那个顶点
                path[w]=u;//记录w顶点从哪个顶点过来的
                EnQueue(Q,w);
            }
        }
    }
}</code></pre>
       <p>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="%E2%91%A1%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%C2%A0">
     <span style="color:#1a439c;">
      <strong>
       ②深度优先搜索
      </strong>
     </span>
    </h3>
    <p>
     (Depth-First-Search,
     <strong>
      DFS
     </strong>
     )类似于树的先序遍历算法。
    </p>
    <blockquote>
     <h4>
      <span style="color:#1a439c;">
       基本思想
      </span>
     </h4>
     <ol>
      <li>
       首先访问起始顶点v；
      </li>
      <li>
       然后访问v的未访问过的邻接顶点
       <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D"/>
       。
      </li>
      <li>
       然后访问
       <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D"/>
       的未被访问过的邻接顶点
       <img alt="gif.latex?w_2%7B%7D" class="mathcode" src="https://latex.csdn.net/eq?w_2%7B%7D"/>
       ；
      </li>
      <li>
       重复上述过程，当不能再向下访问时，依次
       <span style="color:#fe2c24;">
        退回到最近被访问
       </span>
       的顶点，若它还有邻接顶点未被访问过，则从该点开始继续2~4的的过程。直到所有与起始顶点连通的顶点都被访问过为止。
      </li>
      <li>
       若此时图中尚有顶点未被访问，则另选图中一个未曾被访问过的顶点作为起始顶点，重复上述1~4过程，直到图中所有顶点都被访问过为止。
      </li>
     </ol>
    </blockquote>
    <p>
    </p>
    <blockquote>
     <h4 id="DFS%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">
      <span style="color:#1a439c;">
       DFS实现方法
      </span>
     </h4>
     <ul>
      <li>
       找一个顶点的所有未访问过的邻接顶点我们用到这两个接口函数FirstNeighbor( G, x)、NextNeighbor( G, x, y )
      </li>
      <li>
       我们看到第3步对
       <img alt="gif.latex?w_%7B1%7D" class="mathcode" src="https://latex.csdn.net/eq?w_%7B1%7D"/>
       的操作与第2步对v的操作相同，因此使用同一个函数，第4步的思想我们直接用
       <strong>
        递归(栈)
       </strong>
       实现即可。
      </li>
      <li>
       bool型辅助数组visited[MAX_VERTEX_NUM]的下标用来代表每个顶点的编号，并存放它们是否被访问过的信息。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <h4 id="DFS%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81">
      <span style="color:#1a439c;">
       DFS算法代码
      </span>
     </h4>
     <pre><code class="language-cpp">bool visited[MAX_VERTEX_NUM];
void DFS(Graph G,int V);
void BFSTraverse(Graph G)
{
    for(i=0;i&lt;G.vexnum;i++)
    visited[i]=FALSE;//将顶点都标志为未访问过
    for(i=0;i&lt;G.vexnum;i++)
    {
        if(!visited[i])//确保所有连通分量都被访问过一次，即上文基本思想中的5
        DFS(G,i);    
    }        
}
void DFS(Graph G,int V)
{
    visit(V);//访问初始顶点
    visited[V]=TURE;//标志为已访问
        for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w ))
        {//步骤234的具体代码实现
            if(!visited[w])
            DFS(G,W);
        }
}</code></pre>
     <p>
     </p>
    </blockquote>
    <blockquote>
     <h4 id="%C2%A0DFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">
      <span style="color:#1a439c;">
       DFS算法分析
      </span>
     </h4>
     <ul>
      <li>
       深度优先搜索遍历算法是一个递归算法，需要借助一个递归工作栈，故空间复杂度为O(|V|)
      </li>
      <li>
       采用邻接表存储方式时，每个顶点都标记过，故时间复杂度为O(|V|),每条边都至少被访问一次(出边表遍历)时间复杂度为O(|E|)，故时间复杂度为O(|V|+|E|)。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为O(|V|)，故算法总的时间复杂度为O(|
       <img alt="gif.latex?V%5E%7B2%7D" class="mathcode" src="https://latex.csdn.net/eq?V%5E%7B2%7D"/>
       |)
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <h4 id="DFS%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%C2%A0">
      <span style="color:#1a439c;">
       DFS算法应用
      </span>
     </h4>
     <p>
      <strong>
       深度优先搜索是求有向图的强连通分量的一个有效方法
      </strong>
      。假设以十字链表作为有向图的存储结构（方便我们一会逆向搜索，即从找出边变为找入边了），求强连通分量的步骤如下：
     </p>
     <ol>
      <li>
       在有向图G上，从某个顶点出发沿着以该顶点为尾的弧进行深度优先搜索遍历，并按其
       <span style="color:#fe2c24;">
        所有邻接点的搜索都完成
       </span>
       (即退出DFS函数)的顺序将顶点排列起来。
      </li>
      <li>
       在有向图G上，从最后完成搜索的顶点出发，沿着以该顶点为头的弧进行
       <span style="color:#fe2c24;">
        逆向
       </span>
       的深度优先搜索遍历。若此次遍历不能访问到有向图中所有顶点，则从余下的顶点中最后完成搜索的顶点出发，继续做逆向的深度优先搜索遍历，直到有向图中的顶点都被访问到为止。
      </li>
     </ol>
     <ul>
      <li>
       由此，第二步每一次调用DFS作逆向深度优先遍历所访问到的顶点集便是有向图G中一个强连通分量的顶点集。
      </li>
     </ul>
     <p>
      <img alt="" height="530" src="https://i-blog.csdnimg.cn/blog_migrate/885133c84c27d482a52450d6a2c0cae3.png" width="1200"/>
     </p>
     <p>
      <img alt="" height="500" src="https://i-blog.csdnimg.cn/blog_migrate/01e83e34eb0f2be07c0e33ebc24a3c1f.png" width="799"/>
     </p>
    </blockquote>
    <h2 id="%E4%B8%89%E3%80%81%E9%81%8D%E5%8E%86%E5%BE%97%E5%88%B0%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%C2%A0">
     <span style="color:#1a439c;">
      三、遍历得到的生成树、生成森林相关问题
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#1a439c;">
       <strong>
        回顾：
       </strong>
      </span>
     </p>
     <ol>
      <li>
       任意两个顶点都连通的
       <strong>
        无向图为连通图
       </strong>
       ，任意两个顶点都强连通的有向图为
       <strong>
        强连通图
       </strong>
       。
      </li>
      <li>
       <strong>
        连通分量
       </strong>
       是无向图中的极大连通子图，
       <strong>
        强连通分量
       </strong>
       是有向图中的极大强连通子图。
      </li>
      <li>
       <strong>
        生成子图
       </strong>
       是包含全部顶点的子图，
       <strong>
        连通图的生成树
       </strong>
       是包含全部顶点的极小连通子图，非连通无向图的连通分量的生成树构成了
       <strong>
        非连通无向图的生成森林。
       </strong>
      </li>
      <li>
       只有一个顶点的入度为0，其余顶点的入度均为1的有向图，称为
       <strong>
        有向树
       </strong>
       。
      </li>
      <li>
       一个
       <strong>
        有向图的生成森林
       </strong>
       由若干有向树组成，含有图中的全部顶点，但只有足以构成若干棵不相交的有向树的弧。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <p>
      <span style="color:#1a439c;">
       <strong>
        广度优先搜索(BFS)
       </strong>
      </span>
     </p>
     <ul>
      <li>
       <strong>
        无向图：
       </strong>
      </li>
      <li>
       连通图经过广度优先搜索后得到的遍历树为广度优先生成树。
      </li>
      <li>
       非连通无向图经过广度优先搜索后得到的遍历树集合为广度优先生成森林。
      </li>
      <li>
       <strong>
        有向图：
       </strong>
      </li>
      <li>
       强连通图经过广度优先搜索后得到的遍历树为广度优先生成树。
      </li>
      <li>
       非强连通有向图经过广度优先搜索后得到的遍历树集合为广度优先生成森林。
       <hr/>
       <p>
        王道教材上给的解释是只说了连通图，也就是无向图的生成森林问题。但举的例子又是一个有向图，很明显是牛头不对马嘴。具体怎么样不用管了，先按这样理解。
       </p>
      </li>
      <li>
       图按邻接矩阵存储时表示是唯一的，故其广度优先生成树、森林也是唯一的。按邻接表法存储时是不唯一的，故其广度优先生成树、森林也是不唯一的。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
     </p>
     <p>
      <span style="color:#1a439c;">
       <strong>
        深度优先搜索 (DFS)
       </strong>
      </span>
     </p>
     <ul>
      <li>
       <strong>
        无向图：
       </strong>
      </li>
      <li>
       连通图经过深度优先搜索后得到的遍历树为深度优先生成树。
      </li>
      <li>
       非连通无向图经过深度优先搜索后得到的遍历树集合为深度优先生成森林。
      </li>
      <li>
       <strong>
        有向图：
       </strong>
      </li>
      <li>
       强连通图经过深度优先搜索后得到的遍历树为深度优先生成树。
      </li>
      <li>
       非强连通有向图经过深度优先搜索后得到的遍历树集合为深度优先生成森林。
       <hr/>
       <p>
       </p>
      </li>
      <li>
       图按邻接矩阵存储时表示是唯一的，故其深度优先生成树、森林也是唯一的。按邻接表法存储时是不唯一的，故其深度优先生成树、森林也是不唯一的。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <span style="color:#1a439c;">
       <strong>
        BFS与DFS综合对比
       </strong>
      </span>
     </p>
     <ul>
      <li>
       对于无向图的广度优先生成树，起点到其他顶点的路径是图中对应的最短路径，即所有生成树中树高最小。此外，深度优先总是尽可能“深”地搜索图，因此路径可能会更长，故
       <strong>
        深度优先生成树的树高总是大于或等于广度优先生成树的树高。
       </strong>
      </li>
      <li>
       对于无向图而言，void BFSTraverse(Graph G)调用遍历函数（BFS或DFS）的次数为无向图的连通分量的个数。
      </li>
      <li>
       对于有向图而言，如果调用一次遍历函数（BFS或DFS)可以遍历到所有结点，不能说明该有向图强连通。调用遍历函数（BFS或DFS）的次数与有向图的强连通分量的个数无关，具体求强连通分量的算法见上述DFS算法的应用。
      </li>
     </ul>
    </blockquote>
    <p>
     正文结束。
    </p>
    <hr/>
    <p>
    </p>
    <blockquote>
     <p>
      DFS算法求强连通分量好像也可以这么做，不知道对不对。
     </p>
     <p>
      <img alt="" height="530" src="https://i-blog.csdnimg.cn/blog_migrate/885133c84c27d482a52450d6a2c0cae3.png" width="1200"/>
     </p>
     <p>
      <img alt="" height="254" src="https://i-blog.csdnimg.cn/blog_migrate/c5b477c846e23bd431f93ef77d66fbd9.png" width="498"/>
     </p>
     <p>
      可以看到也可以求出强连通分量 。
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37343035393637312f:61727469636c652f64657461696c732f313237353437393430" class_="artid" style="display:none">
 </p>
</div>


