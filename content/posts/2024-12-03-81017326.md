---
layout: post
title: "Android音视频-视频采集OpenGL-ES渲染"
date: 2024-12-03 20:00:28 +0800
description: "之前有介绍过这方面的知识内容 Android音视频-视频采集（系统API预览） Android音视频"
keywords: "gradio采集音视频数据"
categories: ['Ffmpeg']
tags: ['无标签']
artid: "81017326"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=81017326
    alt: "Android音视频-视频采集OpenGL-ES渲染"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=81017326
featuredImagePreview: https://bing.ee123.net/img/rand?artid=81017326
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android音视频-视频采集（OpenGL ES渲染）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     之前有介绍过这方面的知识内容
     <br/>
     <a href="https://blog.csdn.net/lyman_ye/article/details/78723067">
      Android音视频-视频采集（系统API预览）
     </a>
     <br/>
     <a href="https://blog.csdn.net/lyman_ye/article/details/78788781">
      Android音视频-视频采集（Camera预览）
     </a>
     <br/>
     <a href="https://blog.csdn.net/lyman_ye/article/details/78840927">
      Android音视频-视频采集（Camera2预览基础）
     </a>
     <br/>
     <a href="https://blog.csdn.net/lyman_ye/article/details/78897819">
      Android音视频-视频采集（Camera2功能实现）
     </a>
    </p>
    <p>
     上面的都是基于Android的高级应用层API来实现的音视频的采集和编码，下面我们要打开摄像头通过OpenGL ES底层native代码来渲染视频画面。
    </p>
    <h2 id="简介">
     简介
    </h2>
    <p>
     总体的思路是从摄像头采集到视频的数据，然后传递给底层的OpenGL ES来渲染显示到上层的SurfaceView上面，项目总体文件结构如下：
     <br/>
    </p>
    <center>
     <img src="https://i-blog.csdnimg.cn/blog_migrate/8ac678ec098078ccd1d2043ba9374b58.jpeg" width="50%">
     </img>
    </center>
    <br/>
    下面的实现列出关键的步骤和代码，完整的项目代码文章末尾列出。
    <p>
    </p>
    <h3 id="java上层代码实现">
     Java上层代码实现
    </h3>
    <p>
     这里主要是Android应用层的Camera的一些配置切换等操作，并且通过native接口调用底层的实现代码
     <br/>
     代码简单类图：
     <br/>
    </p>
    <center>
     <img src="https://i-blog.csdnimg.cn/blog_migrate/466c088cb3a0262eb0616972aef5a850.jpeg" width="50%">
     </img>
    </center>
    <br/>
    前面的一些权限配置等基础的代码就不列出。主要类是LPreviewScheduler.java文件
    <p>
    </p>
    <ul>
     <li>
      LPreviewView:SurfaceView继承封装类
     </li>
     <li>
      LVideoCamera:封装操作Camera的一些方法
     </li>
     <li>
      <p>
       LPreviewScheduler:总体调度器，包含上面两个类，并且对外提供应用接口
      </p>
      <p>
       上面的操作Camera的类LVideoCamera.java是基于Camera来做的，详细可见以前文章的一些介绍。下面主要列出LPreviewScheduler的代码实现。
      </p>
     </li>
    </ul>
    <pre class="prettyprint"><code class="hljs java"><span class="hljs-keyword">package</span> com.lyman.camerapreview.preview;

<span class="hljs-keyword">import</span> android.hardware.Camera.CameraInfo;
<span class="hljs-keyword">import</span> android.util.Log;
<span class="hljs-keyword">import</span> android.view.Surface;
<span class="hljs-keyword">import</span> android.view.SurfaceHolder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LPreviewScheduler</span>
        <span class="hljs-keyword">implements</span> <span class="hljs-title">LVideoCamera</span>.<span class="hljs-title">LVideoCameraCallback</span>, <span class="hljs-title">LPreviewView</span>.<span class="hljs-title">LPreviewViewCallback</span> {<!-- --></span>
    <span class="hljs-keyword">static</span> {
        System.loadLibrary(<span class="hljs-string">"camerapreview"</span>);
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"LPreviewScheduler"</span>;
    <span class="hljs-keyword">private</span> LPreviewView mPreviewView;
    <span class="hljs-keyword">private</span> LVideoCamera mCamera;

    <span class="hljs-keyword">public</span> <span class="hljs-title">LPreviewScheduler</span>(LPreviewView previewView, LVideoCamera camera) {
        isStopped = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">this</span>.mPreviewView = previewView;
        <span class="hljs-keyword">this</span>.mCamera = camera;
        <span class="hljs-keyword">this</span>.mPreviewView.setCallback(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>.mCamera.setCallback(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumberOfCameras</span>() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mCamera) {
            <span class="hljs-keyword">return</span> mCamera.getNumberOfCameras();
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-javadoc">/** 切换摄像头, 底层会在返回来调用configCamera, 之后在启动预览 **/</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">switchCameraFacing</span>();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isFirst = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isSurfaceExsist = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isStopped = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> defaultCameraFacingId = CameraInfo.CAMERA_FACING_FRONT;
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createSurface</span>(Surface surface, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height){
        startPreview(surface, width, height, defaultCameraFacingId);
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPreview</span>(Surface surface, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cameraFacingId){
        <span class="hljs-keyword">if</span> (isFirst) {
            prepareEGLContext(surface, width, height, cameraFacingId);
            isFirst = <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            createWindowSurface(surface);
        }
        isSurfaceExsist = <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPreview</span>(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cameraFacingId){
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != mPreviewView){
                SurfaceHolder holder = mPreviewView.getHolder();
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != holder){
                    Surface surface = holder.getSurface();
                    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != surface){
                        startPreview(surface, mPreviewView.getWidth(), mPreviewView.getHeight(), cameraFacingId);
                    }
                }
            }
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            e.printStackTrace();
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareEGLContext</span>(Surface surface, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> cameraFacingId);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWindowSurface</span>(Surface surface);

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetRenderSize</span>(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height);

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroySurface</span>(){
        <span class="hljs-keyword">if</span>(isStopped){
            <span class="hljs-keyword">this</span>.stopPreview();
        } <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">this</span>.destroyWindowSurface();
        }
        isSurfaceExsist = <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>() {
        isStopped = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span>(!isSurfaceExsist){
            <span class="hljs-keyword">this</span>.stopPreview();
        }
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopPreview</span>(){
        <span class="hljs-keyword">this</span>.destroyEGLContext();
        isFirst = <span class="hljs-keyword">true</span>;
        isSurfaceExsist = <span class="hljs-keyword">false</span>;
        isStopped = <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyWindowSurface</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyEGLContext</span>();

    <span class="hljs-javadoc">/**
     * 当Camera捕捉到了新的一帧图像的时候会调用这个方法,因为更新纹理必须要在EGLThread中,
     * 所以配合下updateTexImageFromNative使用
     **/</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyFrameAvailable</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPermissionDismiss</span>(String tip){
        Log.i(<span class="hljs-string">"problem"</span>, <span class="hljs-string">"onPermissionDismiss : "</span> + tip);
    }

    <span class="hljs-keyword">private</span> CameraConfigInfo mConfigInfo;
    <span class="hljs-javadoc">/** 当底层创建好EGLContext之后，回调回来配置Camera，返回Camera的配置信息，然后在EGLThread线程中回调回来继续做Camera未完的配置以及Preview **/</span>
    <span class="hljs-keyword">public</span> CameraConfigInfo <span class="hljs-title">configCameraFromNative</span>(<span class="hljs-keyword">int</span> cameraFacingId){
        defaultCameraFacingId = cameraFacingId;
        mConfigInfo = mCamera.configCameraFromNative(cameraFacingId);
        <span class="hljs-keyword">return</span> mConfigInfo;
    }
    <span class="hljs-javadoc">/** 当底层EGLThread创建初纹理之后,设置给Camera **/</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startPreviewFromNative</span>(<span class="hljs-keyword">int</span> textureId) {
        mCamera.setCameraPreviewTexture(textureId);
    }
    <span class="hljs-javadoc">/** 当底层EGLThread更新纹理的时候调用这个方法 **/</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateTexImageFromNative</span>() {
        mCamera.updateTexImage();
    }
    <span class="hljs-javadoc">/** 释放掉当前的Camera **/</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseCameraFromNative</span>(){
        mCamera.releaseCamera();
    }

}
</code></pre>
    <p>
     从开始显示到停止的过程通过下面的图串一遍
     <br/>
    </p>
    <center>
     <img src="https://i-blog.csdnimg.cn/blog_migrate/bf839ff87c889524789953a432325b9a.jpeg" width="50%">
     </img>
    </center>
    <br/>
    上层代码还是比较简单的。
    <p>
    </p>
    <h2 id="native层代码分析">
     Native层代码分析
    </h2>
    <p>
     下面主要介绍底层的C++实现代码。
    </p>
    <h3 id="配置项目">
     配置项目
    </h3>
    <p>
     首先看一下C++文件的目录结构：
     <br/>
    </p>
    <center>
     <img src="https://i-blog.csdnimg.cn/blog_migrate/4041e080e57d9f36492df7f9f8085198.jpeg" width="50%">
     </img>
    </center>
    <br/>
    上面我配置了两个输出so库，一个commontool和一个camerapreview库，其中camerapreview引用commontool中的实现代码。
    <br/>
    CmakeLists.txt在项目中的配置略，看其中的配置C++代码如下：
    <p>
    </p>
    <pre class="prettyprint"><code class="hljs perl">cmake_minimum_required(VERSION <span class="hljs-number">3.4</span>.<span class="hljs-number">1</span>)
find_library( <span class="hljs-comment"># Sets the name of the path variable.</span>
              <span class="hljs-keyword">log</span>-lib

              <span class="hljs-comment"># Specifies the name of the NDK library that</span>
              <span class="hljs-comment"># you want CMake to locate.</span>
              <span class="hljs-keyword">log</span> )

set(PATH_TO_ROOT <span class="hljs-variable">${CMAKE_SOURCE_DIR}</span>/src/main/cpp)

include_directories(<span class="hljs-variable">${PATH_TO_ROOT}</span>/libcommon/)

file(GLOB FILES_LIB_COMMON <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_EGL_CORE <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/egl_core/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_MSG_Q <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/message_queue/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_GL_MEDIA <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/opengl_media/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_GL_MEDIA_RENDER <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/opengl_media/render/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_GL_MEDIA_TEXTURE <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/opengl_media/texture/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_GL_MEDIA_TEXTURE_COPIER <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/opengl_media/texture_copier/<span class="hljs-variable">*.</span>cpp"</span>)
file(GLOB FILES_LIB_COMMON_SL_MEDIA <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/libcommon/opensl_media/<span class="hljs-variable">*.</span>cpp"</span>)

add_library( <span class="hljs-comment"># Sets the name of the library.</span>
             commontool

             <span class="hljs-comment"># Sets the library as a shared library.</span>
             SHARED

             <span class="hljs-comment"># Provides a relative path to your source file(s).</span>
             <span class="hljs-variable">${FILES_LIB_COMMON}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_EGL_CORE}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_MSG_Q}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_GL_MEDIA}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_GL_MEDIA_RENDER}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_GL_MEDIA_TEXTURE}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_GL_MEDIA_TEXTURE_COPIER}</span>
             <span class="hljs-variable">${FILES_LIB_COMMON_SL_MEDIA}</span>
             )

<span class="hljs-comment"># Include libraries needed for renderer lib</span>
target_link_libraries(
                      commontool
                      ${<!-- --><span class="hljs-keyword">log</span>-lib}
                      android
                      GLESv2
                      EGL
                      OpenSLES)

include_directories(<span class="hljs-variable">${PATH_TO_ROOT}</span>/camera_preview/)

file(GLOB FILES_LIB_CAMERA_PREVIEW <span class="hljs-string">"<span class="hljs-subst">${PATH_TO_ROOT}</span>/camera_preview/<span class="hljs-variable">*.</span>cpp"</span>)

add_library( <span class="hljs-comment"># Sets the name of the library.</span>
             camerapreview

             <span class="hljs-comment"># Sets the library as a shared library.</span>
             SHARED

             <span class="hljs-comment"># Provides a relative path to your source file(s).</span>
             <span class="hljs-variable">${FILES_LIB_CAMERA_PREVIEW}</span>
             <span class="hljs-variable">${PATH_TO_ROOT}</span>/LPreviewScheduler.cpp
             )

<span class="hljs-comment"># Include libraries needed for renderer lib</span>
target_link_libraries(
                      camerapreview
                      commontool)

</code></pre>
    <p>
     其中核心交互的类文件为mv_recording_preview_controller.cpp，它与上层的交互过程已经在上面列出来，下面主要分析这个类的实现。
    </p>
    <h3 id="实现代码">
     实现代码
    </h3>
    <p>
     类文件mv_recording_preview_controller.cpp为和上层交互的主要集合类，串联了其他各个模块的实现。
     <br/>
     主要的使用类如下：
     <br/>
    </p>
    <center>
     <img src="https://i-blog.csdnimg.cn/blog_migrate/97972203dd8958edf348e518edcf19e8.jpeg" width="50%">
     </img>
    </center>
    <p>
    </p>
    <ul>
     <li>
      MVRecordingPreviewHandler：实现了消息机制，上层所有方法的调用通过它转发到消息队列调用
     </li>
     <li>
      EGLSurface：通过接受上层的Surface构造显示视图
     </li>
     <li>
      render_preview_renderer:渲染视图逻辑处理类，这个里面主要是OpenGL ES相关的实现代码
     </li>
    </ul>
    <p>
     底层的实现的代码还是在OpenGL ES的渲染部分，里面的细节实现代码还没有完全弄明白，这里先串联出整个的渲染的流程，具体细节日后慢慢了解了再细究。下面是render_preview_renderer.cpp的实现大体流程：
     <br/>
    </p>
    <center>
     <img src="https://i-blog.csdnimg.cn/blog_migrate/7e7802842069a0be82876b1b45415d1b.jpeg" width="50%">
     </img>
    </center>
    <p>
    </p>
    <p>
     其中渲染模块的OpenGL代码没有完全吃透。待以后补充。
    </p>
    <p>
     <a href="https://github.com/LymanYe/FFmpeg/tree/master/camerapreview">
      本文Demo代码
     </a>
     <br/>
     <a href="https://github.com/zhanxiaokai/Android-CameraPreview">
      原参考书籍代码
     </a>
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f4c796d616e5f5965:2f61727469636c652f64657461696c732f3831303137333236" class_="artid" style="display:none">
 </p>
</div>


