---
layout: post
title: "C遇到的问题"
date: 2025-03-09 16:49:33 +0800
description: "原题是利用顺序表和链表实现两个多项式的相加在读取时：我写的代码是这样是错误的，会一直让你输入字符，即使点了空格键也没用第一个多项式的输入是3 4 2 3 1 2，第二个多项式是-2 3 4 2 5 1 6 0。当用户使用第一个循环读取时，第一个循环会读取3 4，然后2 3，然后1 2，然后继续读下去，也就是说，原代码中的第一个循环会一直读取所有输入的两个整数，直到输入结束。后面的输入可能还在输入流中。解决方法：用string输入+用sstream库是 C++ 标准库<sstream>"
keywords: "C++遇到的问题"
categories: ['C']
tags: ['算法', '数据结构', 'C']
artid: "145954509"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145954509
    alt: "C遇到的问题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145954509
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145954509
cover: https://bing.ee123.net/img/rand?artid=145954509
image: https://bing.ee123.net/img/rand?artid=145954509
img: https://bing.ee123.net/img/rand?artid=145954509
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++遇到的问题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     关于while(cin&gt;&gt;n&gt;&gt;m)的读取问题
    </h2>
    <p>
     原题是利用顺序表和链表实现两个多项式的相加
    </p>
    <p>
     在读取时：
    </p>
    <p>
     <img alt="" height="473" src="https://i-blog.csdnimg.cn/direct/84cdf79373654ddba76f2cd717399d62.png" width="1256"/>
    </p>
    <p>
     我写的代码是
    </p>
    <pre><code class="language-cpp">int n,m;
while (cin &gt;&gt; n&gt;&gt;m)  //n是系数，m是指数
{
	a[m] = n;
}
while (cin &gt;&gt; n&gt;&gt;m)
{
	b[m] = n;
}</code></pre>
    <p>
     这样是错误的，会一直让你输入字符，即使点了空格键也没用
    </p>
    <p>
     原因是：
    </p>
    <p>
     <span style="color:#be191c">
      <strong>
       cin在输入时会自动跳过空格和换行符。
      </strong>
     </span>
     第一个多项式的输入是3 4 2 3 1 2，第二个多项式是-2 3 4 2 5 1 6 0。当用户使用第一个循环读取时，第一个循环会读取3 4，然后2 3，然后1 2，然后继续读下去，也就是说，原代码中的第一个循环会一直读取所有输入的两个整数，直到输入结束。后面的输入可能还在输入流中。
    </p>
    <p>
     解决方法：用string输入+用sstream库
    </p>
    <pre><code class="language-cpp">int main() {
    string line1, line2;
    getline(cin, line1); // 读取第一个多项式
    getline(cin, line2); // 读取第二个多项式

    // 处理第一个多项式
    stringstream ss1(line1);
    int coeff, exp;
    while (ss1 &gt;&gt; coeff &gt;&gt; exp) {
        a[exp] = coeff; // 直接赋值，输入中每个指数唯一
    }

    // 处理第二个多项式
    stringstream ss2(line2);
    while (ss2 &gt;&gt; coeff &gt;&gt; exp) {
        b[exp] = coeff;
    }
</code></pre>
    <p>
     <code>
      stringstream
     </code>
     是 C++ 标准库
     <code>
      &lt;sstream&gt;
     </code>
     头文件中提供的一个类模板，
     <span style="color:#ed7976">
      <strong>
       它主要用于字符串和其他数据类型之间的相互转换，以及对字符串进行格式化操作，类似于标准输入输出流
       <code>
        cin
       </code>
       和
       <code>
        cout
       </code>
      </strong>
     </span>
     ，只不过它操作的对象是字符串而不是控制台或文件。
    </p>
    <p>
     <code>
      stringstream
     </code>
     有三种类型：
    </p>
    <ul>
     <li>
      <code>
       istringstream
      </code>
      （字符串读取数据）
     </li>
     <li>
      <code>
       ostringstream
      </code>
      （向字符串写入数据）
     </li>
     <li>
      <code>
       stringstream
      </code>
      （读+写）
     </li>
    </ul>
    <p>
     当你有一个包含多个数据项的字符串，并且这些数据项之间有特定的分隔符（如空格、逗号等），可以使用
     <code>
      stringstream
     </code>
     来将字符串分割成多个独立的数据项，并将其转换为合适的数据类型。
    </p>
    <h3>
     <strong>
      stringstream使用示例：
     </strong>
    </h3>
    <p>
     <strong>
      字符串读写（用到istringstream）：
     </strong>
    </p>
    <p>
     <strong>
      类比cin吧，但还是有点抽象了
     </strong>
    </p>
    <pre><code class="language-cpp">int main() {
    std::stringstream ss;
    // 写入数据
//这个写入数据的操作和std::stringstream ss input("10 20")没啥区别
    ss &lt;&lt; 10 &lt;&lt; " " &lt;&lt; 20;
    // 读取数据
    int num1, num2;
//cin&gt;&gt;num1是从键盘中读取数据并存储在num1中
//ss是从内部存储的字符串中读取数据并存储在num1中，很相似吧
//提取到的字符串类型会被转换成num1的类型
    ss &gt;&gt; num1 &gt;&gt; num2;
    std::cout &lt;&lt; "num1: " &lt;&lt; num1 &lt;&lt; ", num2: " &lt;&lt; num2 &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     具体原理是指针：
    </p>
    <ul>
     <li>
      执行
      <code>
       iss &gt;&gt; num1
      </code>
      时，从字符串的起始位置开始提取连续的数字字符
      <code>
       "123"
      </code>
      ，将其转换为整数
      <code>
       123
      </code>
      并存储到
      <code>
       num1
      </code>
      中，此时内部指针移动到空格字符处。
     </li>
     <li>
      执行
      <code>
       iss &gt;&gt; num2
      </code>
      时，从空格字符后的位置开始提取连续的数字字符
      <code>
       "456"
      </code>
      ，将其转换为整数
      <code>
       456
      </code>
      并存储到
      <code>
       num2
      </code>
      中。
     </li>
    </ul>
    <p>
     <strong>
      字符串分割与解析：
     </strong>
    </p>
    <p>
     <strong>
      这里使用stringstream，因为要分割字符串，既有字符串的输入，也有字符串的输出
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
    std::string input = "10 20 30";
//创建一个 stringstream 对象 ss，并将包含三个整数的字符串 input 作为其初始化内容。
    std::stringstream ss(input);
    int num1, num2, num3;
//使用 &gt;&gt; 操作符从 ss 中依次提取数据，并将其存储到 num1、num2 和 num3 中
//就像使用 cin 从标准输入读取数据一样。
    ss &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;
    std::cout &lt;&lt; "num1: " &lt;&lt; num1 &lt;&lt; ", num2: " &lt;&lt; num2 &lt;&lt; ", num3: " &lt;&lt; num3 &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     <strong>
      将其他数据类型（如整数、浮点数等）转换为字符串（以整数为例）：
     </strong>
    </p>
    <p>
     <strong>
      这里使用ostringstream，因为要将整数转换成字符串，输出字符串，所以用ostringstream
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
//创建一个 ostringstream 对象 oss，它专门用于向字符串写入数据
    int number = 123;
    std::ostringstream oss;
//使用 &lt;&lt; 操作符将整数 number 写入 oss 中。
    oss &lt;&lt; number;
//调用 oss.str() 方法获取 oss 中存储的字符串内容
    std::string str = oss.str();
    std::cout &lt;&lt; "Converted string: " &lt;&lt; str &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     <strong>
      将字符串转换为整数
     </strong>
    </p>
    <p>
     <strong>
      这里用istringstream，因为要从字符串中读取数据，将其转换成整数
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
    std::string str = "456";
    std::istringstream iss(str);
    int number;
    iss &gt;&gt; number;
    std::cout &lt;&lt; "Converted number: " &lt;&lt; number &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>
     一直头疼字符串和数字相互转化的问题，还有怎么解决未知长度输入的问题，今日一见茅厕顿开
    </p>
    <h3>
     老师上课讲的输入输出切换的方法
    </h3>
    <p>
     从文件1.txt中读取一行整数，将这些整数累加求和，最后输出结果
    </p>
    <p>
     这里也是遇到读取未知字符长度的问题
    </p>
    <pre><code class="language-cpp">//在使用一些较新版本的 Visual Studio 编译器时，对于部分传统的 C 标准库函数（如 scanf、strcpy、fopen 等），
//编译器会发出安全警告。这是因为这些函数在使用时可能存在缓冲区溢出等安全风险
//编译器会给出相应的警告信息
//这里define作用是告诉编译器忽略这些安全警告
#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;
int main()
{
	//使用freopen在文件和控制台之间切换输入
	FILE* instream;
	//从文件D:\\1.txt中输入数据，读取数据用r
	//如果是要写入数据就用w
	instream = freopen("1.txt","r", stdin);
	int a, sum = 0;
	while (1)
	{
		if (scanf("%d", &amp;a) != 1) return 0; //如果读取失败，则结束
		sum += a;
//原先的代码是if (char c = getchar() == '\n') break;
//==的优先级高于=，实际执行顺序是先判断输入字符是否是\n，然后返回0或者1
//所以正确的应该是下面这个
        if ((char c = getchar()) == '\n') break;
	}
	printf("%d", sum);//也可以输出到文件2.txt，如果没有2.txt则会现场建一个

	fclose(instream);
	return 0;
}</code></pre>
    <p>
     <strong>
      对于FILE* instream
     </strong>
    </p>
    <p>
     在 C 语言中，
     <code>
      FILE
     </code>
     是一个预定义的结构体类型，它用于表示文件流。
     <strong>
      文件流是程序与文件之间进行数据传输的通道，通过文件流，程序可以对文件进行读取、写入等操作
     </strong>
    </p>
    <p>
     这里声明了一个名为
     <code>
      instream
     </code>
     的指针变量，其类型为
     <code>
      FILE*
     </code>
     。这个指针变量用于指向一个
     <code>
      FILE
     </code>
     类型的对象，也就是指向一个文件流。通过这个指针对相应的文件进行各种操作。
    </p>
    <p>
     <strong>
      文件流小示例：
     </strong>
    </p>
    <p>
     基本流程就是打开文件然后输出文件中的字符
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    FILE* instream;  // 声明一个 FILE 类型的指针
    instream = fopen("example.txt", "r");  // 打开一个文件，将文件流指针赋值给 instream
    if (instream != NULL) {
        char ch;
        while ((ch = fgetc(instream)) != EOF) {
            putchar(ch);  // 从文件中读取字符并输出
        }
        fclose(instream);  // 关闭文件流
    } else {
        printf("无法打开文件\n");
    }
    return 0;
}</code></pre>
    <p>
     fgetc(instream)：从文件流中读取字符，直到文件结束（EOF）
    </p>
    <h2>
     获取数组实际长度
    </h2>
    <p>
     问题：cin.getline(a, 10000); cin.getline(b, 10000);以后怎么得知a和b的实际长度
    </p>
    <p>
     此时a[]和b[]为字符串
    </p>
    <ul>
     <li>
      strlen()
     </li>
     <li>
      a.size()
     </li>
     <li>
      a.length()
     </li>
    </ul>
    <p>
     若int a[]
    </p>
    <ul>
     <li>
      length=sizeof(a)/4
     </li>
     <li>
      使用vector代替数组，可以直接调用size函数获取其实际长度
     </li>
     <li>
      <pre><code class="language-cpp">vector&lt;int&gt; c = {1, 2, 3, 4, 5};
int length = c.size();</code></pre>
     </li>
    </ul>
    <h2>
     关于指针赋值和&amp;的问题
    </h2>
    <p>
     写链表的时候遇到两行这样的代码：
     <br/>
     node是struct类型
    </p>
    <p>
     同样都是指针=struct，为什么第一个需要用&amp;取地址，而第二个不用呢
    </p>
    <pre><code class="language-cpp">node index(0, 0);
node* tail = &amp;index;</code></pre>
    <pre><code class="language-cpp">node* newnode = new node(a, b);</code></pre>
    <p>
     <strong>
      第一个
     </strong>
    </p>
    <p>
     <code>
      node index(0, 0)
     </code>
     ：这行代码在
     <strong>
      栈上
     </strong>
     创建了一个
     <code>
      node
     </code>
     类型的对象
     <code>
      index，
     </code>
     栈上的对象由系统自动管理内存，当对象所在的作用域结束时，系统会自动释放该对象的内存。
    </p>
    <p>
     <strong>
      第二个
     </strong>
    </p>
    <p>
     <code>
      new node(a, b)
     </code>
     ：
     <code>
      new
     </code>
     是 C++ 中用于动态内存分配的运算符，它在
     <strong>
      堆上
     </strong>
     为
     <code>
      node
     </code>
     类型的对象分配内存，并调用构造函数
     <code>
      node(a, b)
     </code>
     对该对象进行初始化。堆上的内存需要程序员手动管理，使用
     <code>
      delete
     </code>
     运算符来释放。
    </p>
    <p>
     <code>
      node* newnode = ...
     </code>
     ：
     <strong>
      <code>
       new
      </code>
      运算符返回的就是新分配对象的内存地址
     </strong>
     ，所以可以直接将
     <code>
      new
     </code>
     的返回值赋给指针
     <code>
      newnode
     </code>
     ，不需要再使用取地址运算符
     <code>
      &amp;
     </code>
     。
    </p>
    <h2 style="background-color:transparent">
     报错大合集
    </h2>
    <h3>
     ‘nullptr’在此作用域中尚未声明
    </h3>
    <blockquote>
     <p>
      /tmp/compiler_65pf_i0l/src:11:24: 警告：identifier ‘nullptr’ is a keyword in C++11 [-Wc++11-compat] 11 | next = nullptr; | ^~~~~~~ /tmp/compiler_65pf_i0l/src: In constructor ‘node::node(int)’: /tmp/compiler_65pf_i0l/src:11:24: 错误：‘nullptr’在此作用域中尚未声明 /tmp/compiler_65pf_i0l/src: In function ‘int main()’: /tmp/compiler_65pf_i0l/src:58:21: 错误：‘nullptr’在此作用域中尚未声明 58 | node* cur = nullptr; | ^~~~~~~
     </p>
    </blockquote>
    <p>
     解决办法：编译器太老了不认识nullptr，把nullptr改为NULL
    </p>
    <h3 style="background-color:transparent">
     一运行就弹出这个窗口
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b7818e704e474011984c18d3f705ca13.png"/>
    </h3>
    <p>
     原因：是错误设置了断点的原因，重新新建一个项目把代码复制过去就好了
    </p>
    <h2>
     STL list 的迭代器it报错
    </h2>
    <p>
     在
     <a href="https://blog.csdn.net/2401_86190146/article/details/145898096?spm=1001.2014.3001.5501" title="数据结构--【顺序表与链表】笔记-CSDN博客">
      数据结构--【顺序表与链表】笔记-CSDN博客
     </a>
     中蓝桥杯一题中遇到的
    </p>
    <p>
     <img alt="" height="542" src="https://i-blog.csdnimg.cn/direct/bdb7dc7b98224714b6b9e12f6423fa22.png" width="668"/>
    </p>
    <p>
     decrement是减小的意思
    </p>
    <p>
     这里就是it--造成的错误，当it是第一个iterator的时候不能--
    </p>
    <h2>
     上课例子：关于浅拷贝和深拷贝导致的指针链表错误
    </h2>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
struct node{...};
class linklist 
{
private:
	node* head;
public:
	//注意这种新新的写法，xxx():变量值(要赋的值) {函数体，没有就是光赋值不干别的}
	linklist() :head(nullptr) {};
	~linklist() {
		node* current = head, * nextnode;
		while (current != nullptr)
		{
			nextnode = current-&gt;next;
			delete current;
			current = nextnode;
		}
	}
	void insertAtHead(int val) { }//在链表头部插入结点
};
int main()
{
	linklist list1;
	list1.insertAtHead(2);
	list1.insertAtHead(1);
	linklist list2 = list1;
	return 0;
}</code></pre>
    <p>
     这段代码会报错，原因是指针指向的同一片区域被释放了两次
    </p>
    <p>
     首先 linklist没有定义拷贝构造函数和赋值运算符，所以当执行
    </p>
    <pre><code class="language-cpp">linklist list2 = list1;</code></pre>
    <p>
     的时候，编译器生成的默认拷贝构造函数会直接复制head指针的值，这就导致list1和list2的head指向的其实是同一片内存地址，也就是他俩指向的同一个链表，是浅拷贝导致的错误
    </p>
    <p>
     所以当结束的时候会自动调用析构函数，同一片内存被delete两次，导致错误
    </p>
    <p>
     <strong>
      但是，什么是深拷贝？什么是浅拷贝？
     </strong>
    </p>
    <p>
     <s>
      浅拷贝就是浅层拷贝
     </s>
     ，比如说B要从A那里浅拷贝，其实A和B就是同一个东西，当A改变的时候B也会改变，当B改变的时候A也会改变
    </p>
    <p>
     深拷贝就是A和B是完全独立的两个东西，A的值改变不会影响B同样B的值改变不会影响A
    </p>
    <p>
     <img alt="" height="608" src="https://i-blog.csdnimg.cn/direct/f7c8634bb6f344ef8dde8b185a4dd41f.png" width="806"/>
    </p>
    <h2>
     字符串和数字之间相互转换的问题
    </h2>
    <p>
     每次遇到每次都不会
    </p>
    <h3>
     <strong>
      char字符 --&gt; int数字
     </strong>
    </h3>
    <p>
     <strong>
      （适合输入的数字为0~9之间，比如高精度算法）
     </strong>
    </p>
    <p>
     <strong>
      方法一：减去 '0'
     </strong>
    </p>
    <pre><code class="language-cpp">char c = '5'; 
int num = c - '0'; // 结果是整数5</code></pre>
    <p>
     于是num就水灵灵地转换成了5
    </p>
    <p>
     对于s[i]-='0'：
    </p>
    <p>
     假设s[i]的值为字符5，'5'的ascii码减去'0'的ascii码也就是ascii码对应为5的那个字符，不过在内存中存储s[i]的时候还是存储的二进制形式的5，只不过单拿出来s[i]是ascii码对应的3，将s[i]运算的时候还是ascii码3。
    </p>
    <p>
     <strong>
      方法二：atoi()（引入&lt;cstdlib&gt;头文件）
     </strong>
    </p>
    <p>
     这是把整个char数组看成一个数，转换成int
    </p>
    <pre><code class="language-cpp">char str[]="123";
int num=atoi(str);
//num就变成了123</code></pre>
    <h3>
     string字符串--&gt;int数字
    </h3>
    <p>
     <strong>
      （适合输入11 2 3 + * #这一行数据，里面有数字11不能拆开成单个char字符，也有除了数字字符别的其他运算符，比如后缀表达式运算）
     </strong>
    </p>
    <p>
     <strong>
      利用stoi函数（引入&lt;string&gt;库）
     </strong>
    </p>
    <pre><code class="language-cpp">string b="123"
int num=stoi(b);//此时num的值是123
</code></pre>
    <p>
     stoi是把string类型的字符串转换成int类型并保存在num数组中
    </p>
    <p>
     它还有它的好兄弟 stol（表示转换成long），stoll（表示转换成long long）
    </p>
    <h3>
     <strong>
      int数字--&gt;string字符串
     </strong>
    </h3>
    <p>
     <strong>
      方法一：to_string()
     </strong>
    </p>
    <pre><code class="language-cpp">int num=123;
string str=to_string(num)；
//此时str就是"123"</code></pre>
    <p>
     <strong>
      方法二：stringstream()
     </strong>
    </p>
    <pre><code class="language-cpp">int num=123;
stringstream ss;
ss&lt;&lt;num;
string str=ss.str();
//此时字符串str的值就是"123"</code></pre>
    <h3>
     int数字--&gt;char字符
    </h3>
    <p>
     利用的就是asscii码的问题
    </p>
    <pre><code class="language-cpp">int num=1;
char s=1+'0';
//此时s就变成了字符'1'</code></pre>
    <h3>
     int多位数字--&gt;char数组
    </h3>
    <p>
     循环/10吧
    </p>
    <p>
     掌握这些应该就差不多了
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38363139303134362f:61727469636c652f64657461696c732f313435393534353039" class_="artid" style="display:none">
 </p>
</div>


