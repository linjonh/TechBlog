---
layout: post
title: "快速入门MyBatis"
date: 2025-03-11 22:46:48 +0800
description: "基础操作、XML配置文件、动态SQL"
keywords: "【快速入门】MyBatis"
categories: ['未分类']
tags: ['后端', 'Mybatis', 'Java']
artid: "146155454"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146155454
    alt: "快速入门MyBatis"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146155454
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146155454
cover: https://bing.ee123.net/img/rand?artid=146155454
image: https://bing.ee123.net/img/rand?artid=146155454
img: https://bing.ee123.net/img/rand?artid=146155454
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【快速入门】MyBatis
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一.基础操作
    </h3>
    <h4>
     1.准备工作
    </h4>
    <p>
     <strong>
      1）引入依赖
     </strong>
    </p>
    <p>
     一个是mysql驱动包，一个是mybatis的依赖包：
    </p>
    <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.0.4&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
    <p>
     如果创建项目后，项目中自带着就不用引入了。
    </p>
    <p>
     <strong>
      2）配置文件
     </strong>
    </p>
    <p>
     数据库连接配置：
    </p>
    <pre><code>spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/mybatis_test?characterEncoding=utf8&amp;useSSL=false
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre>
    <p>
     上面的username和password要根据自己的数据库进行修改。
    </p>
    <p>
     <img alt="" height="130" src="https://i-blog.csdnimg.cn/direct/408e506d58ae4d8f8710f58466b1edff.png" width="741"/>
    </p>
    <p>
     这个是我们要用的
     <strong>
      数据库的名字
     </strong>
     ，也要根据自己的数据库进行修改。
    </p>
    <p>
     如果使用mysql是
     <strong>
      5.x之前
     </strong>
     的使用的是
     <strong>
      com.mysql.jdbc.Driver
     </strong>
     ，如果是
     <strong>
      大于5.x
     </strong>
     使用的是
     <strong>
      com.mysql.cj.jdbc.Driver
     </strong>
     。
    </p>
    <p>
     打印日志配置：
    </p>
    <pre><code>mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre>
    <h4>
     2.查询（select）
    </h4>
    <p>
     对于查询，使用
     <strong>
      @Select
     </strong>
     这个标签即可完成。
    </p>
    <pre><code>@Select("SQL语句")</code></pre>
    <p>
     举个例子，我们想要查询 user_info 这个表：
    </p>
    <pre><code class="language-java">@Select("select * from user_info;")
List&lt;UserInfo&gt; selectAll();

@Select("select * from user_info where id=3;")
List&lt;UserInfo&gt; selectById();</code></pre>
    <p>
     此时，selectAll()这个方法就具有了查询 user_info 这个表的功能。
    </p>
    <p>
     那如果我们想要指定参数，那么要使用 #{参数} ：
    </p>
    <pre><code class="language-java">@Select("select * from user_info where id=#{id};")
List&lt;UserInfo&gt; selectById(Integer id);

@Select("select * from user_info where id=#{id} and username = #{username};")
List&lt;UserInfo&gt; selectByIdAndName(String username,Integer id);</code></pre>
    <p>
     我们可以使用
     <strong>
      @Param
     </strong>
     这个注解对参数进行
     <strong>
      重命名
     </strong>
     ，但是要保证重命名后的参数必须是重命名：
    </p>
    <pre><code class="language-java">@Select("select * from user_info where id=#{userId};")
List&lt;UserInfo&gt; selectByIdAndName1(@Param("userId") Integer id);</code></pre>
    <p>
     这里要注意一件事，只有数据库的字段与Java中的对象属性相同时才能进行赋值，那如果不同怎么办呢？
    </p>
    <p>
     <strong>
      1）别名查询
     </strong>
    </p>
    <p>
     从SQL语句入手，我们将字段与属性名不同的起一个别名
    </p>
    <pre><code class="language-java">@Select("select user_name as username from user_info ;")
List&lt;UserInfo&gt; selectAll1();</code></pre>
    <p>
     这样，即使数据库字段是user_name也会成功查询。
    </p>
    <p>
     <strong>
      2）结果映射
     </strong>
    </p>
    <p>
     使用
     <strong>
      @Results
     </strong>
     注解
    </p>
    <pre><code class="language-java">@Results(id = "BaseMap",value = {
        @Result(column = "user_name",property = "userName"),
        @Result(column = "create_time",property = "createTime"),
        @Result(column = "update_time",property = "updateTime")
})
@Select("select * from user_info;")
List&lt;UserInfo&gt; selectAll();</code></pre>
    <p>
     <strong>
      3）驼峰自动转换
     </strong>
    </p>
    <p>
     数据库使用蛇形命名法，Java中使用驼峰命名法，通过配置可以两种命名进行自动映射，但是要注意，一定要遵从上述的命名方法，不遵从也不好使。
    </p>
    <pre><code>mybatis:
  configuration: 
    map-underscore-to-camel-case: true #配置驼峰⾃动转换</code></pre>
    <h4>
     3.插入（insert）
    </h4>
    <p>
     插入操作使用
     <strong>
      @Insert
     </strong>
     注解，用法与查询的大差不差，重复的内容就不过多介绍了：
    </p>
    <pre><code class="language-java">@Insert("insert into user_info(username,`password`) values(#{username},#{password});")
Integer insertUser(UserInfo userInfo);

@Insert("insert into user_info(username,`password`,age) values(#{userInfo.username},#{userInfo.password},#{userInfo.age});")
Integer insertUser(@Param("userInfo") UserInfo userInf);</code></pre>
    <p>
     insertUser返回的Integer是收影响的行数。
    </p>
    <p>
     这里要注意重命名那里要使用
     <strong>
      参数.属性
     </strong>
     来获取。
    </p>
    <p>
     如果我们想要获取主键，执行完SQL语句后，使用userInf.getId()是获取不到的。要使用Options注解：
    </p>
    <pre><code class="language-java">@Options(useGeneratedKeys = true,keyProperty = "id")
@Insert("insert into user_info(username,`password`,age) values(#{username},#{password},#{age});")
Integer insertUser(UserInfo userInfo);</code></pre>
    <h4>
     4.删除（delete）
    </h4>
    <p>
     这个注解是什么应该不难猜了，
     <strong>
      @Delete
     </strong>
     。
    </p>
    <pre><code class="language-java">@Delete("delete from user_info where id=#{id}")
Integer deleteUser(Integer id);</code></pre>
    <h4>
     5.更新（update）
    </h4>
    <p>
     注解
     <strong>
      @Update
     </strong>
     ，其他与上面的注解都一样。
    </p>
    <pre><code class="language-java">@Update("update user_info set phone=#{phone} where id=#{id}")
Integer updateUser(Integer phone,Integer id);</code></pre>
    <h3>
     二.XML配置文件
    </h3>
    <h4>
     1.准备工作
    </h4>
    <p>
     <strong>
      1）配置文件
     </strong>
    </p>
    <pre><code>spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/mybatis_test?characterEncoding=utf8&amp;useSSL=false
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
mybatis:
  mapper-locations: classpath:mapper/**Mapper.xml</code></pre>
    <p>
     注意后面的 **Mapper ，这个要根据实际情况写，这个的意思是以 Mapper 为后缀。如果我们写的xml文件的后缀不是 Mapper ，那么要改成与xml文件名相同。
    </p>
    <p>
     <strong>
      2）xml格式
     </strong>
    </p>
    <pre><code> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
 &lt;mapper namespace="***********"&gt;

 &lt;/mapper&gt;</code></pre>
    <p>
     上面******这些要填的是实现Mapper的类的路径，即
     <strong>
      全包名+类名
     </strong>
     。
    </p>
    <h4>
     2.查询（select）
    </h4>
    <p>
     <strong>
      接口中的方法：
     </strong>
    </p>
    <pre><code class="language-java">List&lt;UserInfo&gt; selectAll();
List&lt;UserInfo&gt; selectById(Integer id);</code></pre>
    <p>
     <strong>
      在xml文件中写：
     </strong>
    </p>
    <pre><code class="language-XML">&lt;select id="selectAll" resultType="com.springdemo.model.UserInfo"&gt;
    select * from user_info;
&lt;/select&gt;
&lt;select id="selectById" resultType="com.springdemo.model.UserInfo"&gt;
    select * from user_info where id = #{id};
&lt;/select&gt;</code></pre>
    <p>
     <strong>
      id是与对应接口的方法的名称是一样的，resultType是返回的数据类型。
     </strong>
    </p>
    <p>
     使用xml文件的方法仍然存在数据库字段与对象属性不同的无法赋值的情况，处理方法与注解的一样，都是三种，其中别名查询和配置文件这两个处理方法相同，这里说一下不同的结果映射。
    </p>
    <pre><code class="language-XML">&lt;resultMap id="BaseMap" type="com.springdemo.model.UserInfo"&gt;
    &lt;id column="id" property="id"&gt;&lt;/id&gt;
    &lt;result column="create_time" property="createTime"&gt;&lt;/result&gt;
    &lt;result column="update_time" property="updateTime"&gt;&lt;/result&gt;
&lt;/resultMap&gt;
&lt;select id="selectAll" resultMap="BaseMap"&gt;
    select * from user_info;
&lt;/select&gt;</code></pre>
    <p>
     在resultMap结构中，id是主键，result中的column是数据库字段名，property是对象属性名。
    </p>
    <h4>
     3.插入（insert）
    </h4>
    <p>
     <strong>
      xml文件：
     </strong>
    </p>
    <pre><code class="language-XML">&lt;insert id="insertUser"&gt;
    insert into user_info(username,`password`,age) values(#{username},#{password},#{age});
&lt;/insert&gt;</code></pre>
    <p>
     <strong>
      返回主键：
     </strong>
    </p>
    <pre><code class="language-XML">&lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt;
    insert into user_info(username,`password`,age) values(#{username},#{password},#{age});
&lt;/insert&gt;</code></pre>
    <p>
     从这里我们也能发现：其实这些代码都是重复的，就换个词，包括重命名啥的，本质上没有变化，下面只是简单的给出xml文件代码。
    </p>
    <h4>
     4.删除（delete）
    </h4>
    <pre><code class="language-XML">&lt;delete id="deleteUser"&gt;
    delete from user_info where id=#{id};
&lt;/delete&gt;</code></pre>
    <h4>
     5.更新（update）
    </h4>
    <pre><code class="language-XML">&lt;update id="updateUser"&gt;
    update user_info set phone=#{phone} where id=#{id};
&lt;/update&gt;</code></pre>
    <h3>
     三.${}与#{}
    </h3>
    <h4>
     1.区别
    </h4>
    <p>
     前面一直使用的是#{}，那${}是什么。
    </p>
    <p>
     在实际使用上，我们仅通过看是看不出什么区别的，用是一样用，但是得到的结果是不同的。
    </p>
    <pre><code class="language-java">@Select("select * from user_info where username=#{name}")
//@Select("select * from user_info where username=${name}")
List&lt;UserInfo&gt; selectByName(String name);</code></pre>
    <p>
     分别运行上面的两个注解，得到下面的运行结果：
    </p>
    <p>
     #{}的正常：
     <br/>
     <img alt="" height="64" src="https://i-blog.csdnimg.cn/direct/e08bf2ab5c7d4197b2a958b9b23de428.png" width="1342"/>
    </p>
    <p>
     ${}的报错了：
    </p>
    <p>
     <img alt="" height="55" src="https://i-blog.csdnimg.cn/direct/79ff843410f1475cb8a44325a5cef2ba.png" width="1181"/>
    </p>
    <p>
     报错提示是SQL写错了。
    </p>
    <p>
     ${}写的SQL语句，我们写的参数是直接拼接上的，username直接等于了lisi，lisi应该是一个字符串，不应该直接拼上去，要加上''。#{}是通过占位符的方法
    </p>
    <p>
     我们这样修改上面的注解就可以了：
    </p>
    <pre><code class="language-java">@Select("select * from user_info where username='${name}'")
List&lt;UserInfo&gt; selectByName(String name);</code></pre>
    <p>
     <img alt="" height="61" src="https://i-blog.csdnimg.cn/direct/6718ab27f6114bfeadf99c9af8100057.png" width="1104"/>
    </p>
    <p>
     但是这又引出了一个新的问题，SQL注入。
    </p>
    <p>
     由于使用${}是直接拼接上的，那么完全可以实现SQL注入，因此使用${}的时候就要注意SQL注入问题。
    </p>
    <p>
     所以，相对${}，#{}可谓是优势满满：
    </p>
    <p>
     1）性能更高，#{}是预编译SQL，其在编译一次后会缓存，下次再次执行的时候就不用编译了；
    </p>
    <p>
     2）没有SQL注入，更加安全；
    </p>
    <p>
     那${}真的一无是处吗？存在即合理，要是一点用没有早删了。
    </p>
    <h4>
     2.${}应用
    </h4>
    <p>
     举一个例子，在某些场景下，我们需要对某一数据进行排序查询。先简单写一个查询排序：
    </p>
    <pre><code class="language-sql">select * from standings order by chinese DESC</code></pre>
    <p>
     desc是降序，asc是升序。
    </p>
    <p>
     从上面的例子可以看到，desc是没加 '  ' 的。如果我们使用#{}，势必会加上 ' ' 。这个时候我们就使用${}，可以通过直接拼接来实现。但是也要注意SQL注入问题。
    </p>
    <p>
     再举一个例子，我们要对表进行模糊匹配查询，简单写一个模糊匹配查询：
    </p>
    <pre><code class="language-java">@Select("select name from standings where name like '${name}%'")</code></pre>
    <p>
     上面的？可以填入任意参数，如果我们使用#{}，那么就无法将%给包进去，使用${}就可以。但是这个也有SQL注入问题，我们在实际开发中使用的是mysql内置函数concat来处理：
    </p>
    <pre><code class="language-java">@Select("select name from standings where name like concat(${name},'%')")</code></pre>
    <p>
     还有一个场景是我们写的SQL要传入参数名，这个时候也要使用${}，不能使用#{}。
    </p>
    <h3>
     四.动态SQL
    </h3>
    <p>
     在某些场景，我们传入的字段不是固定的。比如在用户填写个人信息的时候，有一些是必填的，有一些呢可以默认，有一些可以不填。我们在写代码的时候难道要给每一种情况都写一个方法吗？当然不是，这其实就是动态SQL干的事了。
    </p>
    <p>
     动态SQL可以动态的完成SQL拼接。
    </p>
    <h4>
     1.&lt;if&gt;标签
    </h4>
    <p>
     这个标签就可以动态的填入那些不确定的字段。这个是写在XML文件中的：
    </p>
    <pre><code class="language-XML">&lt;insert id="insertUser"&gt;
    insert into user_info(
    username,
    `password`,
    &lt;if test="gender!=null"&gt;
        gender,
    &lt;/if&gt;
    age)
    values(
    #{username},
    #{password},
    &lt;if test="gender!=null"&gt;
        #{gender},
    &lt;/if&gt;
    #{age})
&lt;/insert&gt;
</code></pre>
    <p>
     那用注解的方法呢？
    </p>
    <p>
     用注解写的比较难看，具体写法就是使用
     <strong>
      &lt;script&gt;&lt;/script&gt;
     </strong>
     将上面写的XML语句写在标签中。
    </p>
    <p>
     下面的各个命名一定要分清，属性名一定要与我们定义的类中的名相同，别乱写，字段名就是数据库中的数据名称。
    </p>
    <p>
     <img alt="" height="533" src="https://i-blog.csdnimg.cn/direct/203658538b1c4a5fbb7a440b395d6a71.png" width="1002"/>
    </p>
    <h4>
     2.&lt;trim&gt;标签
    </h4>
    <p>
     有这么一种情况，我们要将最前面的一个参数设成不确定参数。如果第一个参数不填，那么就会出现错误，即多出一个 ，
    </p>
    <pre><code class="language-XML">&lt;insert id="insertUser"&gt;
    insert into user_info(
    &lt;if test="gender!=null"&gt;
        gender
    &lt;/if&gt;                      
    ,username
    ,`password`
    ,age)
    values(
    &lt;if test="gender!=null"&gt;
        #{gender}
    &lt;/if&gt;       
    ,#{username}
    ,#{password}
    ,#{age})
&lt;/insert&gt;</code></pre>
    <p>
     面对这种问题，我们可以使用&lt;trim&gt;标签来添加和去除前后缀：
    </p>
    <pre><code class="language-XML">&lt;insert id="insertUser"&gt;
    insert into user_info
    &lt;trim prefix="(" suffix=")" prefixOverrides=","&gt;
        &lt;if test="gender!=null"&gt;
            gender
        &lt;/if&gt;
        ,username
        ,`password`
        ,age
    &lt;/trim&gt;    
        values
    &lt;trim prefix="(" suffix=")" prefixOverrides=","&gt;
        &lt;if test="gender!=null"&gt;
            #{gender}
        &lt;/if&gt;
        ,#{username}
        ,#{password}
        ,#{age}
    &lt;/trim&gt;
&lt;/insert&gt;</code></pre>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        prefix
       </td>
       <td>
        整个语句块以prefix的值作为前缀
       </td>
      </tr>
      <tr>
       <td>
        suffix
       </td>
       <td>
        整个语句块以suffix的值作为后缀
       </td>
      </tr>
      <tr>
       <td>
        prefixOverrides
       </td>
       <td>
        整个语句块要去除的前缀
       </td>
      </tr>
      <tr>
       <td>
        suffixOverrides
       </td>
       <td>
        整个语句块要去除的后缀
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     3.&lt;where&gt;标签
    </h4>
    <p>
     这种用于在使用where的时候，我们要动态的插入where中的条件：
    </p>
    <pre><code class="language-XML">&lt;select id="selectByIdAndName" resultType="com.springdemo.model.UserInfo"&gt;
    select * from user_info
    &lt;where&gt;
        &lt;if test="id!=null"&gt;
            and id=#{id}
        &lt;/if&gt;
        &lt;if test="username!=null"&gt;
            and username = #{username}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre>
    <p>
     where标签会自动帮我们去除掉多余的 and 或 or
    </p>
    <h4>
     4.&lt;set&gt;标签
    </h4>
    <p>
     这种用于更新（update）数据的时候，我们要动态的传入数据：
    </p>
    <pre><code class="language-XML">&lt;update id="updateUser"&gt;
    update user_info
    &lt;set&gt;
        &lt;if test="phone!=null"&gt;
            phone=#{phone},
        &lt;/if&gt;
        &lt;if test="gender!=null"&gt;
            gender=#{gender},
        &lt;/if&gt;
    &lt;/set&gt;&gt;
    where id=#{id};
&lt;/update&gt;</code></pre>
    <p>
     set标签会自动去除掉多余的，
    </p>
    <h4>
     5.&lt;foreach&gt;标签
    </h4>
    <p>
     这种用于遍历集合。比如我们想要根据一个List集合去删除对应id的用户，我们可以使用foreach标签去遍历每一个id：
    </p>
    <pre><code class="language-XML">&lt;delete id="deleteUser"&gt;
    delete from user_info 
    where id in 
    &lt;foreach collection="idList" item="id" separator="," open="(" close=")"&gt;
        #{id}
    &lt;/foreach&gt;
&lt;/delete&gt;</code></pre>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        collection
       </td>
       <td>
        绑定方法参数中的集合
       </td>
      </tr>
      <tr>
       <td>
        item
       </td>
       <td>
        遍历时的每一个对象
       </td>
      </tr>
      <tr>
       <td>
        open
       </td>
       <td>
        语句块开头的字符串
       </td>
      </tr>
      <tr>
       <td>
        close
       </td>
       <td>
        语句块结束的字符串
       </td>
      </tr>
      <tr>
       <td>
        separator
       </td>
       <td>
        每次遍历之间间隔的字符串
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     6.&lt;include&gt;标签
    </h4>
    <p>
     主要用于处理冗余重复的片段。
    </p>
    <p>
     我们使用&lt;sql&gt;标签定义可重定向的sql片段，&lt;include&gt;标签来获取&lt;sql&gt;中的片段。
    </p>
    <pre><code class="language-XML">&lt;sql id="allColumn"&gt;
    id,name,age
&lt;/sql&gt;&gt;
&lt;select id="selectById" resultType="com.gdut.springdemo08.model.UserInfo"&gt;
    select
    &lt;include refid="allColumn"&gt;&lt;/include&gt;
    from user_info where id = #{id};
&lt;/select&gt;</code></pre>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6c6c6c737572652f:61727469636c652f64657461696c732f313436313535343534" class_="artid" style="display:none">
 </p>
</div>


