---
layout: post
title: "C数据结构-双链表的实现企业存储用户数据的实现"
date: 2025-03-06 23:09:21 +0800
description: "数据结构双链表的双向，企业存储数据的方法"
keywords: "【C++】数据结构 双链表的实现（企业存储用户数据的实现）"
categories: ['未分类']
tags: ['数据结构', '开发语言', 'C']
artid: "146053651"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053651
    alt: "C数据结构-双链表的实现企业存储用户数据的实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053651
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053651
cover: https://bing.ee123.net/img/rand?artid=146053651
image: https://bing.ee123.net/img/rand?artid=146053651
img: https://bing.ee123.net/img/rand?artid=146053651
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【C++】数据结构 双链表的实现（企业存储用户数据的实现）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p class="img-center">
      <img alt="" height="321" src="https://i-blog.csdnimg.cn/direct/fec4ff178c3741fc83e092562a7f41ec.png" width="148"/>
     </p>
     <p>
      <span style="background-color:#ffd900">
       本篇博客给大家带来的是用C++语言来实现数据结构的双向链表（企业存储用户数据的实现）
      </span>
     </p>
     <p>
      🐟🐟文章专栏：C++
     </p>
     <p>
      🚀🚀若有问题评论区下讨论，我会及时回答
     </p>
     <p>
      <span style="color:#fe2c24">
       ❤❤
      </span>
      欢迎大家点赞、收藏、分享
     </p>
     <p>
      <span style="background-color:#ffd900">
       先给大家说一声抱歉，之前被学校安排去上海做服务员了，没有更新，请大家多多包涵
      </span>
      ！
     </p>
     <p>
      <span style="background-color:#38d8f0">
       今日思想：曙光之前尽是黑暗！
      </span>
     </p>
    </blockquote>
    <h2>
     一、双向链表的性质
    </h2>
    <p>
     <span style="background-color:#ffd900">
      双向链表是线性的，逻辑结构：是线性的，物理结构：不一定线性。
     </span>
    </p>
    <h2>
     二、双向链表的定义      ​​​​​
    </h2>
    <p>
     图一：
    </p>
    <p>
     <img alt="" height="826" src="https://i-blog.csdnimg.cn/direct/6b34331fa2254353a9ba71f1e62b79de.png" width="1589"/>
    </p>
    <blockquote>
     <p>
      注意：这里的head结点是不存储数据的，由上图所示我们可知双向链表通过存储前后结点的地址来实现循环，可见双向链表是可以往前或者往后遍历的。
     </p>
    </blockquote>
    <h2>
     三、双向链表的实现
    </h2>
    <p>
     <span style="background-color:#ffd900">
      实现方法：双向链表的初始化、尾插、头插、尾删、头删、在pos(指定位置)之后插入数据、在pos位置、删除pos位置的结点、双向链表的打印。
     </span>
    </p>
    <h3>
     1、双向链表的初始化
    </h3>
    <p>
     <span style="background-color:#ffd900">
      如图一所示我们我们先创造一个结构体，这个结构体包含前一个结点的地址、存储的数据、下一个结点的地址。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
//定义双向链表的结构
typedef int LTDataType;
typedef struct ListNode
{
	LTDataType data;//存储的数据
	struct ListNode* next;//下一个结点
	struct ListNode* prev;//上一个结点
}LTNode;</code></pre>
    <p>
     <span style="background-color:#ffd900">
      我们要进行初始化，头结点是不存储任何数据的，那么接下来的头插和尾插等要申请结点来存储数据，所以可以利用这一点我们对头结点进行初始化。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//双向链表的初始化
LTNode* LTInit();</code></pre>
    <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#define _CRT_SECURE_NO_WARNINGS 1
#include"List.h"
//List.c文件
//申请结点
LTNode* buyNode(LTDataType x)
{
	LTNode* node = (LTNode*)malloc(sizeof(LTNode));
	if (node == NULL)
	{
		perror("malloc fail!");
	}
	node-&gt;data = x;
	node-&gt;next = node-&gt;prev = node;
	return node;
}

//初始化
LTNode* LTInit()
{
	LTNode* phead = buyNode(-1);
	return phead;
}</code></pre>
    <h3>
     2、双向链表的尾插
    </h3>
    <p>
     图二：
    </p>
    <p>
     <img alt="" height="595" src="https://i-blog.csdnimg.cn/direct/4dc9c5304f314a1388b531f1ceedd099.png" width="1562"/>
    </p>
    <p>
     <span style="background-color:#ffd900">
      和图一不同的是我们在这个双向链表的尾部插入一个结点，那么受影响的有新结点的前后地址和node3的下一个地址、head的前地址的指向。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//尾插
void LTPushBack(LTNode* phead, LTDataType x);

</code></pre>
    <pre><code class="language-cpp">//List.c文件
//尾插
//尾插
void LTPushBack(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = buyNode(x);
	newnode-&gt;prev = phead-&gt;prev;
	newnode-&gt;next = phead;
	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}</code></pre>
    <h3>
     3、双向链表的头插
    </h3>
    <p>
     图三：
     <img alt="" height="703" src="https://i-blog.csdnimg.cn/direct/3c5f52415f4147a29a901e003b92e8b0.png" width="1924"/>
    </p>
    <p>
     <span style="background-color:#ffd900">
      头插不能在head之前插入，因为这样和尾插没什么区别，所以我们在head的后面插入，那么受影响只有新结点，改变前后地址的指向就行。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//头插
void LTPushFront(LTNode* phead, LTDataType x);</code></pre>
    <pre><code class="language-cpp">//List.c文件
//头插
void LTPushFront(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = buyNode(x);
	newnode-&gt;prev = phead;
	newnode-&gt;next = phead-&gt;next;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}</code></pre>
    <h3>
     4、双向链表的尾删
    </h3>
    <p>
     图四：
    </p>
    <p>
     <img alt="" height="675" src="https://i-blog.csdnimg.cn/direct/13d916e8714d4d39857cb3449f70aa5f.png" width="1583"/>
    </p>
    <p>
     <span style="color:#0d0016">
      <span style="background-color:#ffd900">
       如图四，我们把node3结点删除那么受影响的有head的前一个指向和node2结点的下一个指向。
      </span>
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//尾删
void LTPopBack(LTNode* phead);</code></pre>
    <pre><code class="language-cpp">//List.c文件
bool LTEmpty(LTNode* phead)
{
	assert(phead);
	return phead-&gt;next == phead;
}
//尾删
void LTPopBack(LTNode* phead)
{
	assert(!LTEmpty(phead));
	LTNode* del = phead-&gt;prev;//先把head结点上一个结点的地址存储起来也就是微博的地址，以便后面释放
	del-&gt;prev-&gt;next = phead;//改变倒数第二个结点的下一个存储的地址
	phead-&gt;prev = del-&gt;prev;

	free(del);
	del = NULL;
}</code></pre>
    <h3>
     5、双向链表的头删
    </h3>
    <p>
     如图五：
    </p>
    <p>
     <img alt="" height="685" src="https://i-blog.csdnimg.cn/direct/ae38d56d9bf2421eb2eaa6ba26fc5b8c.png" width="1808"/>
    </p>
    <p>
     <span style="background-color:#ffd900">
      如图五我们把node1结点删除，那么受影响的有head结点的下一个指向和node2的上一个指向。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//头删
void LTPopFront(LTNode* phead);</code></pre>
    <pre><code class="language-cpp">//List.c文件

//头删
void LTPopFront(LTNode* phead)
{
	assert(!LTEmpty(phead));
	LTNode* del = phead-&gt;next;
	del-&gt;next-&gt;prev = phead;
	phead-&gt;next = del-&gt;next;

	free(del);
	del;
}</code></pre>
    <h3>
     6、双向链表的查找
    </h3>
    <p>
     <span style="background-color:#ffd900">
      双向链表的查找就是把各个结点存储的数据打印出来看看。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//双向链表的打印
void LTPrint(LTNode* phead);</code></pre>
    <pre><code class="language-cpp">//List.c文件
//双向链表的打印
void LTPrint(LTNode* phead)
{
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d -&gt; ", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}</code></pre>
    <h3>
     7、数据的查找
    </h3>
    <p>
     <span style="background-color:#ffd900">
      给一个数据在双向链表查找，有就返回存储数据的结点的地址，没有返回NULL。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//数据的查找
void LTFind(LTNode* phead, LTDataType x);</code></pre>
    <pre><code class="language-cpp">//List.c文件
//数据的查找
void LTFind(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)//不打印head存储的数据
	{
		if (pcur-&gt;data == x)
		{
			return pcur;//找到了
		}
		pcur = pcur-&gt;next;//往下找
	}
	return NULL;//没有找到
}</code></pre>
    <h3>
     8、在pos位置之后插入数据
    </h3>
    <p>
     如图六：
    </p>
    <p>
     <img alt="" height="659" src="https://i-blog.csdnimg.cn/direct/4afeae080ca44d4183b39094068f3e29.png" width="1545"/>
    </p>
    <p>
     <span style="background-color:#ffd900">
      根据用户给出的地址在双向链表找到结点并且在结点后面插入一个结点。如图六，我们假设在node2的后面插入结点node4，那么受影响的有node4结点的前后指向、node3的前一个指向和node2的下一个指向。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x);</code></pre>
    <pre><code class="language-cpp">//List.c文件
//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x)
{
	assert(pos);
	LTNode* newnode = buyNode(x);
	newnode-&gt;prev = pos;
	newnode-&gt;next = pos-&gt;next;

	pos-&gt;next-&gt;prev = newnode;
	pos-&gt;next = newnode;
}</code></pre>
    <h3>
     9、删除pos位置的结点
    </h3>
    <p>
     如图七：
    </p>
    <p>
     <img alt="" height="643" src="https://i-blog.csdnimg.cn/direct/907e1758a1c14ee0b76ac626217fecfb.png" width="1835"/>
    </p>
    <p>
     <span style="background-color:#ffd900">
      如图七我们假设删除node2结点，那么受影响的有node3的前一个结点和node1的下一个结点。
     </span>
    </p>
    <p>
     代码实例：
    </p>
    <pre><code class="language-cpp">//List.h文件
//删除pos位置的结点
void LTErase(LTNode* pos);</code></pre>
    <pre><code class="language-cpp">//List.c文件
//删除pos位置的结点
void LTErase(LTNode* pos)
{
	assert(pos);
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;

	free(pos);
	pos = NULL;
}</code></pre>
    <p>
     <span style="background-color:#ffd900">
      以上内容讲述结束，接下来是完整的代码：
     </span>
    </p>
    <pre><code class="language-cpp">//List.h文件
#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
//定义双向链表的结构
typedef int LTDataType;
typedef struct ListNode
{
	LTDataType data;//存储的数据
	struct ListNode* next;//下一个结点
	struct ListNode* prev;//上一个结点
}LTNode;

//双向链表的初始化
LTNode* LTInit();
//尾插
void LTPushBack(LTNode* phead, LTDataType x);
//头插
void LTPushFront(LTNode* phead, LTDataType x);
//尾删
void LTPopBack(LTNode* phead);
//头删
void LTPopFront(LTNode* phead);
//双向链表的打印
void LTPrint(LTNode* phead);
//数据的查找
void LTFind(LTNode* phead, LTDataType x);
//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x);
//删除pos位置的结点
void LTErase(LTNode* pos);</code></pre>
    <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#define _CRT_SECURE_NO_WARNINGS 1
#include"List.h"
//List.c文件
//申请结点
LTNode* buyNode(LTDataType x)
{
	LTNode* node = (LTNode*)malloc(sizeof(LTNode));
	if (node == NULL)
	{
		perror("malloc fail!");
	}
	node-&gt;data = x;
	node-&gt;next = node-&gt;prev = node;
	return node;
}

//初始化
LTNode* LTInit()
{
	LTNode* phead = buyNode(-1);
	return phead;
}
//尾插
void LTPushBack(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = buyNode(x);
	newnode-&gt;prev = phead-&gt;prev;
	newnode-&gt;next = phead;
	phead-&gt;prev-&gt;next = newnode;
	phead-&gt;prev = newnode;
}
//头插
void LTPushFront(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* newnode = buyNode(x);
	newnode-&gt;prev = phead;
	newnode-&gt;next = phead-&gt;next;

	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}
bool LTEmpty(LTNode* phead)
{
	assert(phead);
	return phead-&gt;next == phead;
}
//尾删
void LTPopBack(LTNode* phead)
{
	assert(!LTEmpty(phead));
	LTNode* del = phead-&gt;prev;//先把head结点上一个结点的地址存储起来也就是微博的地址，以便后面释放
	del-&gt;prev-&gt;next = phead;//改变倒数第二个结点的下一个存储的地址
	phead-&gt;prev = del-&gt;prev;

	free(del);
	del = NULL;
}
//头删
void LTPopFront(LTNode* phead)
{
	assert(!LTEmpty(phead));
	LTNode* del = phead-&gt;next;
	del-&gt;next-&gt;prev = phead;
	phead-&gt;next = del-&gt;next;

	free(del);
	del;
}
//双向链表的打印
void LTPrint(LTNode* phead)
{
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d -&gt; ", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}
//数据的查找
void LTFind(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* pcur = phead-&gt;next;
	while (pcur != phead)//不打印head存储的数据
	{
		if (pcur-&gt;data == x)
		{
			return pcur;//找到了
		}
		pcur = pcur-&gt;next;//往下找
	}
	return NULL;//没有找到
}
//在pos位置之后插入数据
void LTInsert(LTNode* pos, LTDataType x)
{
	assert(pos);
	LTNode* newnode = buyNode(x);
	newnode-&gt;prev = pos;
	newnode-&gt;next = pos-&gt;next;

	pos-&gt;next-&gt;prev = newnode;
	pos-&gt;next = newnode;
}
//删除pos位置的结点
void LTErase(LTNode* pos)
{
	assert(pos);
	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;

	free(pos);
	pos = NULL;
}</code></pre>
    <p>
     完！！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430335f38343935383537312f:61727469636c652f64657461696c732f313436303533363531" class_="artid" style="display:none">
 </p>
</div>


