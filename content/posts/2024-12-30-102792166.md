---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33343636363835372f:61727469636c652f64657461696c732f313032373932313636"
layout: post
title: "计算机操作系统概述-目标作用功能特性和发展过程"
date: 2024-12-30 23:20:58 +08:00
description: "最近在研究操作系统这门基础专业课，在前面也写了篇博客–进程和线程的区"
keywords: "计算机操作系统学习目标"
categories: ['操作系统']
tags: ['操作系统概述', 'Os']
artid: "102792166"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=102792166
    alt: "计算机操作系统概述-目标作用功能特性和发展过程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=102792166
featuredImagePreview: https://bing.ee123.net/img/rand?artid=102792166
---

# 计算机操作系统概述---目标、作用、功能、特性和发展过程

最近在研究操作系统这门基础专业课，在前面也写了篇博客–
[进程和线程的区别](https://blog.csdn.net/qq_34666857/article/details/102549849)
，从操作系统的发展过程来引出进程和线程被引入到操作系统的目的，并从六大方面对进程和线程进行对比。在里面简单的提了下操作系统的发展过程，不过总感觉这个OS专栏少了一个大纲性质的东西，因此写了这篇博客，后续的博客也都是对本文中操作系统中的功能和特性来进行展开的。

​ 本来是只讲OS的发展过程的，不过既然是综述性的博文，就把OS的概述都讲一讲，有些概念可能大家都已经知到，如有写的不好的地方或是错误的地方，还请批评指正。

## 1.操作系统的目标

​ 首先给出操作系统的概念：
**操作系统（Operating System, OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充**
。OS是现代计算机系统中的最基本和
**最重要的系统软件**
，而其他的如编译软件，数据库系统等
**系统软件**
和大量的
**应用软件**
都直接依赖于操作系统的支持。

​ 事实上我们日常中使用的PC上，安装着Windows、MacOs或者linux等，手机上安装着的Android、IOS或者是已经死亡的Symbian，又或者正在兴起的国产鸿蒙OS，在具体到我们的生活中，智能电视、冰箱和家居等都安装着各式各样的OS，操作系统已经在我们身边生根发芽了，并且大家都习以为常，OS在无形中在帮助我们管理着设备上的硬件资源，OS已必不可少。

​ 下面我们通过一张图来说明操作系统在计算机中的层次结构，在图中我们可以看到，OS是直接控制硬件的系统软件，对于用户来说，用户直接操作应用，而应用再来调用语言处理程序或OS提供的接口来操作硬件，OS对于用户来说是透明的。
  
![操作系统在计算机中的层次结构](https://i-blog.csdnimg.cn/blog_migrate/117699c4508866d6076134b0b0ded482.png)

操作系统的主要目标是：

1. **方便性**
   ：方便用户（普通使用者和开发人员）使用，更好的操作计算机的硬件资源；
2. **有效性**
   ：最主要的是提高系统的资源利用率和系统吞吐量，在早期计算机的资源非常有限，提高有效性也是推动操作系统发展的主要动力；
3. **可扩充性**
   ：可以使用计算机硬件、体系结构以及计算机应用发展的要求，可扩充性一直推动OS体系机构的不断发展；
4. **开放性**
   ：OS需要遵循世界标准规范，尤其是开放系统互连OSI国际标准，可以是计算机和应用能够彼此兼容，方便的实现互联。

​ 上述是OS的主要目标，但是OS的目标与使用环境有关，不同的OS的设计目标是不一致的，后面再讲述OS的发展过程时会单独在讲述各个OS的目标。

## 2.操作系统的作用

​ 我们从用户、资源管理及资源抽象多个不同的角度来进行分析。

1. **OS作为用户和计算机硬件系统之间的接口**
   ：主要是用户能够方便、快捷、可靠的操纵计算机硬件和运行自己的程序，如下图所示。从图中可以看到，用户可以通过系统调用、命令、图标、窗口的方式来实现与OS的通信，并使用OS提供的服务。
     
   ![OS作为用户和计算机硬件之间的接口](https://i-blog.csdnimg.cn/blog_migrate/486b05c0d8827253698f6c0ac331ec52.png)
2. **OS作为计算机系统资源的管理者**
   ：主要管理处理机、存储器，I/O设备以及文件（数据和程序），相应的这也是OS的主要功能。
3. **OS实现了对计算机资源的抽象**
   ：通过对资源的抽象，不但增强了系统的功能，还隐藏了对硬件操作的细节，实现了对计算机硬件操作的多个层次的抽象模型，让用户操作起来更简单。

## 3.操作系统的功能

​ 此处的功能我们按照百度给出的五大管理功能来总结，有些教材和资源对此可能会有些不同，但是中心思想都是一致的。因此OS的主要功能如下：

1. **设备管理**
   ：完成用户进程的提出的I/O请求，提高CPU和I/O设备的利用率，提高I/O，方便用户使用I/O设备；
2. **作业管理**
   ：负责作业的输入和输出，作业的调度（选取进入内存）与控制（挂起操作）；
3. **文件管理**
   ：主要任务是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全；
4. **处理机管理**
   ：也称进程管理，主要功能有创建和撤销进行，对诸多进行的运行进行协调，实现进程间的信息交换，以及按照一定的算法把处理机分配给进程（进程调度算法）；
5. **存储器管理**
   ：存储器管理主要管理的是内存，主要任务是为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能存逻辑上扩充内存。

   后面的文章也是主要以OS的功能来进行展开的。

## 4.操作系统的特性

​ 除了不同的操作系统所特有的一些特性外，所有的OS都共同具有四个基本特性，也就是这些基本特性让操作系统可以更好的为多道程序的并发执行创造好的条件。

1. **并发**
   ：Concurrence，指两个或多个事件在同一时间间隔内发生，正是因为系统中的程序能并发的执行这一特征，才使得OS可以有效的提高系统中的资源利用率，关于并发的概念可以参看我的另一篇博文–
   [并发和并行的区别](https://blog.csdn.net/qq_34666857/article/details/102730424)
   。也正是为了增加操作系统的并发性，OS引入了进程和线程的概念，让程序可以并发的执行，甚至是一个进程中的线程可以并行的执行在多个处理机上。
2. **共享**
   ：也称资源复用，是指系统中的资源可供内存中的多个并发执行的进程共同使用。
3. **虚拟**
   ：通过某种技术将一个物理实体变为若干个逻辑上的对应物，主要分为时分复用和空分复用两种技术。
4. **异步性**
   ：由于资源等因素的限制，使进程的执行通常都不是一气呵成的，而是以走走停停的方式运行，即进程是以人们不可预知的速度向前推进的。

​ 其中并发和共享是多用户（任务）的两个基本特征，它们是互为存在的条件，一方面资源共享是以进程的并发执行为条件的，若系统不允许并发执行也就不存在资源共享问题，另一方面，若系统不能对资源共享实施有效管理，以协调好诸进程对共享资源的访问，也必然会影响到诸进程间的并发执行程度，甚至基本无法并发执行。

​ 对于虚拟的两种技术，始于信道通信，学过计算机网络的应该都知道，这里应该记住两个1/N，即时分复用每个用户（或者是虚拟设备）获得的处理速度必然小于等于物理设备速度的1/N；空分复用每个用户（虚拟设备）平均占用的空间也是小于等于物理设备所拥有的空间的1/N。

​ 对于异步，大家可以参考ajax中的异步请求，或者是Java编程中的线程池，单独启动的线程的执行速度无法直接的预测，这也是我们在进行并发编程是需要特别注意的。

## 5.操作系统的发展过程

​ 此部分也是我最开始想写的东西，下面我们按照时间轴来组织OS的发展过程，使用人们对OS提出的新需求来慢慢叙说。下面的部分我不增加小标题，一个阶段使用1，2，3，4来标识。

​ 1.在1945年，世界上的第一台计算机ENIAC诞生了，此时，还未出现OS，对计算机的全部操作都是有用户采用人工操作的方式进行的(通过纸带将程序和数据输入到内存中)。因为是人工操作的，需要一个程序运行完成才可以再次装入另一个程序和数据，这样会存在一下两个缺点：
**用户独占主机**
，
**CPU处理速度和人工输入速度的不匹配**
。

​ 2.为了解决上述问题，20实际50年代出现了脱机I/O技术。该技术主要是采用缓冲区的概念，提前将一批作业在外围机的控制下输入到磁带上，当CPU需要这些程序和数据时，再从磁带上高度的调入内存，并执行。类似的，CPU需要输出时，直接将内存高度的将数据写入到磁带上，之后再外围机的控制下将作业的运行结果输出。
  
![脱机I/O方式](https://i-blog.csdnimg.cn/blog_migrate/8480963c6b52e03ed710df13fb9979c4.jpeg)

3.
**为了进一步提高计算机中的资源利用率，可以尽量的保持系统的连续运行**
，开发人员在脱机I/O方式的基础上，增加了一个
**监督程序**
（Monitor），在它的控制下，是这批在外围机控制下一次输入到系统中的这批作业可以一个接着一个的连续处理。这也就形成了
**单道批处理系统**
，下图是其作业的处理流程：
  
![单道批处理作业处理流程](https://i-blog.csdnimg.cn/blog_migrate/4bd47c4cc5a7ffeb90e7e314aaffff87.png)

但是单道批处理系统中，系统中的资源还是得不到充分地利用，我们看下面这张图。从图中我们可以看到，如果程序在执行的过程中多次发生I/O请求，那么程序在等着I/O完成是就会一直占用着处理机，在这个阶段内，别的程序无法执行，这就做成了t2
t3,t6
t7时间间隔内CPU空闲。
  
![单道批处理程序执行顺序](https://i-blog.csdnimg.cn/blog_migrate/f4d99b4ef6dc0874aa61ba2e68b2f03e.jpeg)

4.为了解决单道批处理系统中存在的问题，即为了
**进一步提高资源利用率和系统吞吐量**
，在20世纪60年代中期引入了多道程序设计技术，由此形成了
**多道批处理系统**
。多道批处理系统同一时刻允许多个作业在内存中
**并发**
的执行，使他们共享CPU和系统中的各种资源。并且为了保证程序并发执行的正确性，引入了进程的概念。下图是四道批处理系统中，程序执行时的运行情况。从图中我们可以看到，在A发生I/O请求时，可以利用CPU的这段空档时间调度程序B执行，在同样的B、C、D发生I/O请求时，再去调度其他可执行的程序。
  
![多道批处理系统中程序执行情况](https://i-blog.csdnimg.cn/blog_migrate/6631cee6b535d1a9292e4211cfb76ca5.jpeg)

通过这种交替的执行程序，让CPU尽量少处于空闲状态，因此其系统资源利用率高、系统吞吐量大；但是因为其作业的交替执行，因而作业的平均周转时间长，并且
**无人机交互能力**
。

​ OS发展到多道批处理系统，系统中的资源利用率已经非常的高了，后续的OS发展主要受特定的需求或者是硬件的升级换代而推动的，这些促使着OS可以满足新的需求，并且可以利用好更强大的硬件，提高系统的性能。

5.为了满足用
**户对人–机交互**
、
**共享主机**
的需求，由此形成了一种新型的OS-----
**分时系统**
。在20世纪60年代，因为计算机还是非常昂贵的，一台计算机需要供多个用户共享使用，在每个用户使用的过程中，都是希望处理机可以快速的处理自己的请求或者是作业，希望能够独占计算机，因此分时系统是像下图一样，一个主机连接了多个显示器和键盘的终端，每个用户以时间片轮转的形式获得主机的处理资源。
  
![分时系统](https://i-blog.csdnimg.cn/blog_migrate/b830172537feac01ee7a6db5f271300d.jpeg)

6.为了保证作业的开始时间和结束时间，
**能够及时的响应外部事件的请求**
，
**在规定的时间内完成对该事件的一个处理**
，并控制所有实时任务协调一致的运行，出现了
**实时系统**
。实时OS要求系统高度可靠，可以保证事件的及时处理，之后又衍生出很多实时系统的类型，包括工业（武器）控制系统、信息查询系统、多媒体系统和嵌入式系统。

​ 7.随着VLSI（超大规模集成电路）和计算机体系结构的发展，以及应用需求的不断发展，操作系统仍然在不断的发展，并且产生了微机（微型机）操作系统、网络操作系统、多处理机操作系统，下面我们分别简单的讲一下。

​
**微机操作操作系统**
是配置在微型机上的系统，其主要目标是
**方便用户使用**
，及使用的方便性，主要可以分为单用户单任务OS，单用户多任务OS和多用户多任务OS，现在我们使用的都是多用户多任务系统，典型的就是Linux系统，一个用户登录就为之创建一个进行，一个linux服务器允许多个用户同时登录。

​
**网络操作系统**
是随着万维网的发展而形成的，要求网络OS不仅具有原有OS的单机处理功能，还需要有向网络中的其他计算机提供网络通信和网络资源共享功能，并且为网络用户提供各种网络服务。

​
**多处理机操作系统**
是指利用系统内的多个CPU并行执行用户多个程序，以提高系统的吞吐量或用来进行冗余操作以提高系统的可靠性。多处理机OS也是由于多个CPU的出现，为了能够充分地发挥他们的
**并行**
处理能力，进一步提高系统的性能而诞生的。并且因为此，传统的进程“太重”，致使进程的创建、调度、撤销会有较大的时空开销，
**因此OS引入了线程的概念**
。（本文中进程和线程中的概念可以参考我的另一篇博文—进程和线程的区别）

​ 下面我们来总结一下推动操作系统发展的动力：

1. 不断提高计算机资源利用率；
2. 方便用户使用；
3. 器件（硬件）的不断更新换代；
4. 计算机体系结构的不断发展；（理论推动实践）
5. 不断提出的新的应用需求。

​ 对于OS来说，不断被提出的应用需求促使了分时系统、实时系统等其他的OS的产生。其实在我们的开发的过程中，需求也都是非常重要的，一个系统开发出来如果无法满足任何人的需求，那么这个系统是没有任何的生命力的，如果能创造出能迎合部分人甚至是大部分人需求的应用（这个世界人这么多，一小部分也是非常大的受众了），那么你就可以站在风口了。比如饿了么、摩拜等等。

---

又到了分隔符以下，本文到此就结束了，本文内容全部都是有博主自己进行整理并结合自身的理解进行总结，如果有什么错误，还请批评指正，如果有什么疑惑也可以评论留言。

​ 全文4500多字，原创不易，如果对你有所帮助，还请留下个赞。