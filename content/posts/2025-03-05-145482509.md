---
layout: post
title: "单例设计模式"
date: 2025-03-05 23:50:51 +0800
description: "在 Java 中，单例模式（Singleton Pattern）是一种常用的设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。在实现单例模式时，有几种不同的加载方式，主要包括 懒汉式（Lazy Initialization）和 饿汉式（Eager Initialization）。下面会详细介绍这些实现方式。饿汉式单例的特点是，在类加载时就创建单例对象，确保线程安全，不需要任何同步机制。这种方式在类加载时就创建实例，因此无法进行延迟加载。懒汉式单例的特点是实例是在第一次调用 "
keywords: "单例设计模式"
categories: ['未分类']
tags: ['单例模式']
artid: "145482509"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145482509
    alt: "单例设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145482509
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145482509
cover: https://bing.ee123.net/img/rand?artid=145482509
image: https://bing.ee123.net/img/rand?artid=145482509
img: https://bing.ee123.net/img/rand?artid=145482509
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     单例设计模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Java 中，
     <strong>
      单例模式
     </strong>
     （Singleton Pattern）是一种常用的设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。在实现单例模式时，有几种不同的加载方式，主要包括
     <strong>
      懒汉式
     </strong>
     （Lazy Initialization）和
     <strong>
      饿汉式
     </strong>
     （Eager Initialization）。
    </p>
    <h4>
     单例模式的加载方式
    </h4>
    <ol>
     <li>
      <strong>
       饿汉式单例
      </strong>
      （Eager Initialization）
     </li>
     <li>
      <strong>
       懒汉式单例
      </strong>
      （Lazy Initialization）
     </li>
     <li>
      <strong>
       双重检查锁定（Double-Checked Locking）
      </strong>
      单例
     </li>
     <li>
      <strong>
       静态内部类单例
      </strong>
      （Bill Pugh Singleton）
     </li>
     <li>
      <strong>
       枚举单例
      </strong>
      （Enum Singleton）
     </li>
    </ol>
    <p>
     下面会详细介绍这些实现方式。
    </p>
    <hr/>
    <h4>
     1.
     <strong>
      饿汉式单例
     </strong>
     （Eager Initialization）
    </h4>
    <p>
     饿汉式单例的特点是，在类加载时就创建单例对象，确保线程安全，不需要任何同步机制。这种方式在类加载时就创建实例，因此无法进行延迟加载。
    </p>
    <h5>
     实现方式：
    </h5>
    <pre></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <pre><code><code>public class Singleton {
    // 在类加载时就创建实例
    private static final Singleton instance = new Singleton();
    
    // 私有化构造函数
    private Singleton() {}
    
    // 提供公共访问方法
    public static Singleton getInstance() {
        return instance;
    }
}
</code></code></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <h5>
     解释：
    </h5>
    <ul>
     <li>
      <strong>
       线程安全
      </strong>
      ：由于实例是在类加载时就创建的，确保了线程安全。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：即使实例从未使用，类加载时实例也会被创建，浪费了资源。
     </li>
    </ul>
    <hr/>
    <h4>
     2.
     <strong>
      懒汉式单例
     </strong>
     （Lazy Initialization）
    </h4>
    <p>
     懒汉式单例的特点是实例是在第一次调用
     <code>
      getInstance()
     </code>
     时创建的，采用延迟加载。通常需要加锁以保证线程安全。
    </p>
    <h5>
     实现方式：
    </h5>
    <pre></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <pre><code><code>public class Singleton {
    // 实例对象，未初始化
    private static Singleton instance;
    
    // 私有化构造函数
    private Singleton() {}
    
    // 提供公共访问方法
    public static synchronized Singleton getInstance() {
        // 如果实例为空，则创建实例
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></code></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <h5>
     解释：
    </h5>
    <ul>
     <li>
      <strong>
       延迟加载
      </strong>
      ：实例只会在第一次使用时被创建，节省了资源。
     </li>
     <li>
      <strong>
       线程安全
      </strong>
      ：使用了
      <code>
       synchronized
      </code>
      关键字来保证线程安全。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：每次调用
      <code>
       getInstance()
      </code>
      都会进行同步，性能较差。
     </li>
    </ul>
    <hr/>
    <h4>
     3.
     <strong>
      双重检查锁定（Double-Checked Locking）
     </strong>
     单例
    </h4>
    <p>
     双重检查锁定的懒汉式单例，通过两次
     <code>
      if (instance == null)
     </code>
     检查来减少加锁的次数，提升性能。第一层检查不加锁，第二层检查加锁后创建实例。
    </p>
    <h5>
     实现方式：
    </h5>
    <pre></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <pre><code><code>public class Singleton {
    // 使用 volatile 关键字确保对象的正确创建
    private static volatile Singleton instance;
    
    // 私有化构造函数
    private Singleton() {}
    
    // 提供公共访问方法
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
</code></code></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <h5>
     解释：
    </h5>
    <ul>
     <li>
      <strong>
       延迟加载
      </strong>
      ：实例只会在第一次调用时被创建。
     </li>
     <li>
      <strong>
       性能优化
      </strong>
      ：第一次检查不加锁，只有在实例为空时才进行加锁，减少了加锁的开销。
     </li>
     <li>
      <strong>
       线程安全
      </strong>
      ：使用
      <code>
       synchronized
      </code>
      保证线程安全，且
      <code>
       volatile
      </code>
      关键字确保实例初始化的正确性。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：代码较为复杂，需要理解双重检查锁定的实现原理。
     </li>
    </ul>
    <hr/>
    <h4>
     4.
     <strong>
      静态内部类单例
     </strong>
     （Bill Pugh Singleton）
    </h4>
    <p>
     静态内部类单例是一种非常高效且线程安全的单例实现方式，它利用了
     <strong>
      类加载机制
     </strong>
     来保证线程安全，且没有加锁的性能问题。
    </p>
    <h5>
     实现方式：
    </h5>
    <pre></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <pre><code><code>public class Singleton {
    // 静态内部类实现单例
    private static class SingletonHelper {
        // 静态初始化器，由JVM来保证线程安全
        private static final Singleton INSTANCE = new Singleton();
    }
    
    // 私有化构造函数
    private Singleton() {}
    
    // 提供公共访问方法
    public static Singleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
</code></code></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <h5>
     解释：
    </h5>
    <ul>
     <li>
      <strong>
       线程安全
      </strong>
      ：静态内部类在第一次加载时才会被初始化，而类加载是线程安全的。
     </li>
     <li>
      <strong>
       性能
      </strong>
      ：静态内部类只有在首次使用时才会被加载，避免了不必要的同步操作。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：没有同步的开销，且实现简单。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：需要理解类加载的机制。
     </li>
    </ul>
    <hr/>
    <h4>
     5.
     <strong>
      枚举单例
     </strong>
     （Enum Singleton）
    </h4>
    <p>
     使用
     <code>
      enum
     </code>
     实现单例模式是最简单也是最安全的方式。由于 Java 枚举的特性，JVM 会保证枚举实例的唯一性，同时会确保线程安全。根据
     <strong>
      Joshua Bloch
     </strong>
     （《Effective Java》的作者）的建议，这是实现单例模式的最佳方式。
    </p>
    <h5>
     实现方式：
    </h5>
    <pre></pre>
    <p>
     <code>
      java
     </code>
    </p>
    <pre><code><code>public enum Singleton {
    INSTANCE;
    
    // 可以添加其他方法
    public void someMethod() {
        System.out.println("Hello, Singleton!");
    }
}
</code></code></pre>
    <h5>
     解释：
    </h5>
    <ul>
     <li>
      <strong>
       线程安全
      </strong>
      ：Java 枚举类本身就是线程安全的。
     </li>
     <li>
      <strong>
       实现简单
      </strong>
      ：使用枚举类避免了许多复杂的代码和同步问题。
     </li>
     <li>
      <strong>
       JVM 保证
      </strong>
      ：JVM 在加载枚举类型时会保证它只会加载一次，并且是线程安全的。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：最简单，最安全，且是 JDK 推荐的单例实现方式。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：无法延迟实例化，单例是预先创建的。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结：懒汉式 vs 饿汉式
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        懒汉式单例
       </strong>
       （Lazy Initialization）：
      </p>
      <ul>
       <li>
        <strong>
         优点
        </strong>
        ：延迟加载，只有在需要时才创建实例，节省资源。
       </li>
       <li>
        <strong>
         缺点
        </strong>
        ：需要加锁，性能差，特别是在多线程环境下。
       </li>
       <li>
        <strong>
         线程安全
        </strong>
        ：需要使用
        <code>
         synchronized
        </code>
        或其他同步机制来保证线程安全。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        饿汉式单例
       </strong>
       （Eager Initialization）：
      </p>
      <ul>
       <li>
        <strong>
         优点
        </strong>
        ：简单实现，线程安全，类加载时即创建实例。
       </li>
       <li>
        <strong>
         缺点
        </strong>
        ：即使没有使用该实例，也会创建，浪费资源。
       </li>
       <li>
        <strong>
         线程安全
        </strong>
        ：类加载时创建实例，线程安全。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <strong>
      推荐使用方式
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       枚举单例
      </strong>
      是最推荐的单例实现方式，简单、安全、可靠，避免了所有其他方式中的问题。
     </li>
     <li>
      如果需要延迟加载且在多线程环境中使用，可以考虑
      <strong>
       静态内部类单例
      </strong>
      或
      <strong>
       双重检查锁定
      </strong>
      单例，它们是线程安全且性能较好的方案。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f63633033313963632f:61727469636c652f64657461696c732f313435343832353039" class_="artid" style="display:none">
 </p>
</div>


