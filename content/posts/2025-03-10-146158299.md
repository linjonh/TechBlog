---
layout: post
title: "Flutter中使用NetworkImage加载网络图片缓存问题学习实践"
date: 2025-03-10 16:50:40 +0800
description: "Flutter中使用HttpClient实现无缓存NetworkImage的代码实现"
keywords: "Flutter中使用NetworkImage加载网络图片缓存问题学习实践"
categories: ['未分类']
tags: ['缓存', 'Flutter']
artid: "146158299"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158299
    alt: "Flutter中使用NetworkImage加载网络图片缓存问题学习实践"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158299
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158299
cover: https://bing.ee123.net/img/rand?artid=146158299
image: https://bing.ee123.net/img/rand?artid=146158299
img: https://bing.ee123.net/img/rand?artid=146158299
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Flutter中使用NetworkImage加载网络图片缓存问题学习实践
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <pre>Flutter中默认的NetworkImage会有缓存机制，如果图片的url不变化，但是url的图片已经发生变化，NetworkImage不会下载新的图片

deepseek是这么解决问题的，但是在鸿蒙上禁用缓存无效
</pre>
    <p>
     在Flutter中，
     <code>
      NetworkImage
     </code>
     默认会使用缓存机制来优化性能。如果你想禁用缓存，可以通过以下几种方式实现：
    </p>
    <h4>
     1. 使用
     <code>
      NetworkImage
     </code>
     的
     <code>
      headers
     </code>
     参数
    </h4>
    <p>
     你可以通过设置
     <code>
      headers
     </code>
     参数来禁用缓存。例如，添加
     <code>
      Cache-Control
     </code>
     头来禁用缓存：
    </p>
    <p>
     dart
    </p>
    <p>
     复制
    </p>
    <pre>Image(
  image: NetworkImage(
    'https://example.com/image.png',
    headers: {
      'Cache-Control': 'no-cache',
    },
  ),
)</pre>
    <h4>
     2. 使用
     <code>
      CachedNetworkImage
     </code>
     并禁用缓存
    </h4>
    <p>
     如果你使用的是
     <code>
      cached_network_image
     </code>
     包，可以通过设置
     <code>
      cacheKey
     </code>
     来避免缓存：
    </p>
    <p>
     dart
    </p>
    <p>
     复制
    </p>
    <pre>CachedNetworkImage(
  imageUrl: 'https://example.com/image.png',
  cacheKey: DateTime.now().toString(), // 使用当前时间戳作为缓存键
)</pre>
    <h4>
     3. 使用
     <code>
      HttpClient
     </code>
     手动下载图片
    </h4>
    <p>
     你可以使用
     <code>
      HttpClient
     </code>
     手动下载图片，并禁用缓存：
    </p>
    <p>
     dart
    </p>
    <pre>import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';

class NoCacheNetworkImage extends ImageProvider&lt;NoCacheNetworkImage&gt; {
  final String url;

  NoCacheNetworkImage(this.url);

  @override
  Future&lt;NoCacheNetworkImage&gt; obtainKey(ImageConfiguration configuration) {
    return SynchronousFuture&lt;NoCacheNetworkImage&gt;(this);
  }

  @override
  ImageStreamCompleter load(NoCacheNetworkImage key, DecoderCallback decode) {
    return MultiFrameImageStreamCompleter(
      codec: _loadAsync(key),
      scale: 1.0,
    );
  }

  Future&lt;ui.Codec&gt; _loadAsync(NoCacheNetworkImage key) async {
    final HttpClient client = HttpClient();
    final HttpClientRequest request = await client.getUrl(Uri.parse(key.url));
    request.headers.add('Cache-Control', 'no-cache');
    final HttpClientResponse response = await request.close();
    final Uint8List bytes = await consolidateHttpClientResponseBytes(response);
    return await ui.instantiateImageCodec(bytes);
  }
}

// 使用
Image(
  image: NoCacheNetworkImage('https://example.com/image.png'),
)</pre>
    <p>
    </p>
    <h4>
     4. 使用
     <code>
      FadeInImage
     </code>
     并禁用缓存
    </h4>
    <p>
     你可以使用
     <code>
      FadeInImage
     </code>
     并结合
     <code>
      NetworkImage
     </code>
     的
     <code>
      headers
     </code>
     参数来禁用缓存：
    </p>
    <p>
     dart
    </p>
    <p>
     复制
    </p>
    <pre>FadeInImage(
  image: NetworkImage(
    'https://example.com/image.png',
    headers: {
      'Cache-Control': 'no-cache',
    },
  ),
  placeholder: MemoryImage(kTransparentImage),
)</pre>
    <h4>
     5. 使用
     <code>
      Image.network
     </code>
     并禁用缓存
    </h4>
    <p>
     你也可以直接在
     <code>
      Image.network
     </code>
     中使用
     <code>
      headers
     </code>
     参数：
    </p>
    <p>
     dart
    </p>
    <p>
     复制
    </p>
    <pre>Image.network(
  'https://example.com/image.png',
  headers: {
    'Cache-Control': 'no-cache',
  },
)</pre>
    <h4>
     总结
    </h4>
    <p>
     以上方法都可以帮助你禁用
     <code>
      NetworkImage
     </code>
     的缓存机制。选择哪种方式取决于你的具体需求和应用场景。如果你只是简单地想禁用缓存，使用
     <code>
      headers
     </code>
     参数是最直接的方式。如果你需要更复杂的控制，可以考虑手动下载图片或使用
     <code>
      CachedNetworkImage
     </code>
     。
    </p>
    <p>
    </p>
    <p>
     <span style="color:#fe2c24">
      但是 headers: { 'Cache-Control': 'no-cache', }, 在纯鸿蒙系统上无效，还是NetworkImage，
      <code>
       FadeInImage，
      </code>
      Image.network 会加载缓存。
     </span>
    </p>
    <p>
    </p>
    <p>
     实践测试如下：
    </p>
    <pre>1. 使用 HttpClient手动下载图片
   使用 HttpClient 添加  request.headers.add('Cache-Control', 'no-cache'); 
实现不实用缓存机制，缺点：加载图片比较慢.

 解决NetworkImage缓存机制的办法： 在url后面添加时间戳参数，每次请求的url都不同, eg:
 //String iconUrl = "$resUrl${servicelist.id}.png?timestamp=${DateTime.now().millisecondsSinceEpoch}";

</pre>
    <pre></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f7a68616e6768616f5f48756c6b2f:61727469636c652f64657461696c732f313436313538323939" class_="artid" style="display:none">
 </p>
</div>


