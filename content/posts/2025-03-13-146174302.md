---
layout: post
title: "3.3-Spring-Boot多数据源动态切换AbstractRoutingDataSource实战"
date: 2025-03-13 10:06:16 +0800
description: "是Spring框架提供的一个抽象类，通过路由机制（Routing）实现数据源的动态切换。其核心逻辑是维护一个结构，通过方法返回当前线程需要使用的数据源标识（lookup key），进而从目标数据源集合中获取对应的DataSource。通过实现多数据源动态切换，我们既保持了Spring Boot简洁的配置风格，又获得了灵活的数据源管理能力。这种方案在中小型项目中表现优异，但对于需要复杂分片策略的大型分布式系统，建议考虑集成ShardingSphere等专业中间件。"
keywords: "springboot 动态主从多数据源"
categories: ['零基础7天精通Spring', '从入门到精通', 'Spring', 'Boot', 'Boot']
tags: ['后端', 'Spring', 'Java', 'Boot']
artid: "146174302"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146174302
    alt: "3.3-Spring-Boot多数据源动态切换AbstractRoutingDataSource实战"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146174302
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146174302
cover: https://bing.ee123.net/img/rand?artid=146174302
image: https://bing.ee123.net/img/rand?artid=146174302
img: https://bing.ee123.net/img/rand?artid=146174302
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     3.3 Spring Boot多数据源动态切换：AbstractRoutingDataSource实战
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     Spring Boot多数据源动态切换：AbstractRoutingDataSource实战
    </h2>
    <h3>
     引言
    </h3>
    <p>
     在企业级应用开发中，随着业务规模的扩大，我们经常会遇到需要同时操作多个数据库的场景：可能是主从读写分离、多租户架构、分库分表需求，或是需要同时连接业务库和日志库等特殊场景。传统的单数据源配置已无法满足这类需求，而Spring Boot提供的
     <code>
      AbstractRoutingDataSource
     </code>
     正是解决这类问题的利器。本文将深入探讨如何基于
     <code>
      AbstractRoutingDataSource
     </code>
     实现多数据源的动态切换，并通过实战代码演示具体实现方案。
    </p>
    <hr/>
    <h3>
     一、核心原理剖析
    </h3>
    <h4>
     1.1 AbstractRoutingDataSource工作机制
    </h4>
    <p>
     <code>
      AbstractRoutingDataSource
     </code>
     是Spring框架提供的一个抽象类，通过路由机制（Routing）实现数据源的动态切换。其核心逻辑是维护一个
     <code>
      Map&lt;Object, DataSource&gt;
     </code>
     结构，通过
     <code>
      determineCurrentLookupKey()
     </code>
     方法返回当前线程需要使用的数据源标识（lookup key），进而从目标数据源集合中获取对应的
     <code>
      DataSource
     </code>
     。
    </p>
    <h4>
     1.2 线程级数据源管理
    </h4>
    <p>
     动态数据源切换的核心是
     <strong>
      线程隔离
     </strong>
     。每个请求线程通过
     <code>
      ThreadLocal
     </code>
     保存当前数据源标识，确保不同线程间的数据源选择互不干扰。这种设计完美适配Web应用的请求-响应模型，天然支持高并发场景。
    </p>
    <hr/>
    <h3>
     二、实战：四步实现动态数据源
    </h3>
    <h4>
     2.1 环境准备
    </h4>
    <p>
     在
     <code>
      pom.xml
     </code>
     中添加基础依赖：
    </p>
    <pre></pre>
    <p>
     xml
    </p>
    <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
    <h4>
     2.2 数据源配置
    </h4>
    <p>
     在
     <code>
      application.yml
     </code>
     中配置主从数据源：
    </p>
    <pre></pre>
    <p>
     yaml
    </p>
    <pre><code>datasource:
  master:
    driver-class-name: com.mysql.cj.jdbc.Driver
    jdbc-url: jdbc:mysql://localhost:3306/master_db
    username: root
    password: master_pwd
    pool-name: MASTER_POOL
  slave:
    driver-class-name: com.mysql.cj.jdbc.Driver
    jdbc-url: jdbc:mysql://localhost:3306/slave_db
    username: root
    password: slave_pwd
    pool-name: SLAVE_POOL</code></pre>
    <h4>
     2.3 动态数据源核心实现
    </h4>
    <h5>
     2.3.1 数据源上下文持有器
    </h5>
    <pre></pre>
    <p>
     java
    </p>
    <pre><code>public class DataSourceContextHolder {
    private static final ThreadLocal&lt;String&gt; CONTEXT = new ThreadLocal&lt;&gt;();

    public static void setDataSource(String name) {
        CONTEXT.set(name);
    }

    public static String getDataSource() {
        return CONTEXT.get();
    }

    public static void clear() {
        CONTEXT.remove();
    }
}</code></pre>
    <h5>
     2.3.2 动态数据源实现类
    </h5>
    <pre></pre>
    <p>
     java
    </p>
    <pre><code>public class DynamicDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSource();
    }

    @Bean
    @ConfigurationProperties(prefix = "datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties(prefix = "datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public DataSource dynamicDataSource() {
        Map&lt;Object, Object&gt; dataSources = new HashMap&lt;&gt;(2);
        dataSources.put("master", masterDataSource());
        dataSources.put("slave", slaveDataSource());

        DynamicDataSource ds = new DynamicDataSource();
        ds.setDefaultTargetDataSource(masterDataSource());
        ds.setTargetDataSources(dataSources);
        return ds;
    }
}</code></pre>
    <h4>
     2.4 切换切面实现
    </h4>
    <pre></pre>
    <p>
     java
    </p>
    <pre><code>@Aspect
@Component
public class DataSourceAspect {

    @Before("@annotation(com.example.annotation.Master)")
    public void switchMaster() {
        DataSourceContextHolder.setDataSource("master");
    }

    @Before("@annotation(com.example.annotation.Slave)")
    public void switchSlave() {
        DataSourceContextHolder.setDataSource("slave");
    }

    @AfterReturning("@annotation(com.example.annotation.Master) || @annotation(com.example.annotation.Slave)")
    public void clearDataSource() {
        DataSourceContextHolder.clear();
    }
}</code></pre>
    <hr/>
    <h3>
     三、进阶功能扩展
    </h3>
    <h4>
     3.1 动态数据源注册
    </h4>
    <pre></pre>
    <p>
     java
    </p>
    <pre><code>public void addNewDataSource(String key, DataSource dataSource) {
    Map&lt;Object, Object&gt; targetDataSources = 
        new HashMap&lt;&gt;(dynamicDataSource.getTargetDataSources());
    targetDataSources.put(key, dataSource);
    dynamicDataSource.setTargetDataSources(targetDataSources);
    dynamicDataSource.afterPropertiesSet();
}</code></pre>
    <h4>
     3.2 事务管理增强
    </h4>
    <pre></pre>
    <p>
     java
    </p>
    <pre><code>@Bean
public PlatformTransactionManager transactionManager() {
    return new DataSourceTransactionManager(dynamicDataSource());
}</code></pre>
    <hr/>
    <h3>
     四、测试验证
    </h3>
    <pre></pre>
    <p>
     java
    </p>
    <pre><code>@SpringBootTest
class DynamicDSTest {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    @Master
    void testMasterWrite() {
        jdbcTemplate.execute("INSERT INTO user(name) VALUES('test')");
    }

    @Test
    @Slave
    void testSlaveRead() {
        List&lt;Map&lt;String, Object&gt;&gt; result = 
            jdbcTemplate.queryForList("SELECT * FROM user");
        System.out.println(result);
    }
}</code></pre>
    <hr/>
    <h3>
     五、注意事项与优化建议
    </h3>
    <ol>
     <li>
      ​
      <strong>
       连接池监控
      </strong>
      ：建议集成Druid的监控功能，实时观察各数据源状态
     </li>
     <li>
      ​
      <strong>
       失败回退机制
      </strong>
      ：当目标数据源不可用时，自动切换到默认数据源
     </li>
     <li>
      ​
      <strong>
       性能调优
      </strong>
      ：根据实际场景调整各连接池参数（maxPoolSize、minIdle等）
     </li>
     <li>
      ​
      <strong>
       分布式事务
      </strong>
      ：对于跨数据源事务，建议使用Seata等分布式事务解决方案
     </li>
     <li>
      ​
      <strong>
       动态刷新
      </strong>
      ：结合Nacos配置中心实现数据源配置的热更新
     </li>
    </ol>
    <hr/>
    <h3>
     总结
    </h3>
    <p>
     通过
     <code>
      AbstractRoutingDataSource
     </code>
     实现多数据源动态切换，我们既保持了Spring Boot简洁的配置风格，又获得了灵活的数据源管理能力。这种方案在中小型项目中表现优异，但对于需要复杂分片策略的大型分布式系统，建议考虑集成ShardingSphere等专业中间件。希望本文能为您在应对复杂数据源场景时提供有价值的参考。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031323736323631392f:61727469636c652f64657461696c732f313436313734333032" class_="artid" style="display:none">
 </p>
</div>


