---
layout: post
title: "再谈设计模式解释器模式语法的解析执行者"
date: 2025-03-06 00:27:37 +0800
description: "解释器模式定义了一种语言的语法表示，并定义一个解释器来解释该语言中的句子。它使用类来表示每个语法规则，并且通过递归调用这些类的方法来解释表达式。本质上，它将一个复杂的表达式分解为一系列简单的部分，然后按照特定的语法规则进行解析和执行。"
keywords: "【再谈设计模式】解释器模式~语法的解析执行者"
categories: ['软件工程', '编程框架', '数据结构与算法']
tags: ['软件工程', '设计模式', '数据结构', '开发语言']
artid: "146055874"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146055874
    alt: "再谈设计模式解释器模式语法的解析执行者"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146055874
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146055874
cover: https://bing.ee123.net/img/rand?artid=146055874
image: https://bing.ee123.net/img/rand?artid=146055874
img: https://bing.ee123.net/img/rand?artid=146055874
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【再谈设计模式】解释器模式~语法的解析执行者
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <img alt="" height="2500" src="https://i-blog.csdnimg.cn/direct/c87a978e078d40d58c734ea9635dfc42.png" width="1440"/>
    </h3>
    <h3 id="一、引言">
     一、引言
    </h3>
    <p>
     在软件工程，软件开发领域，设计模式是解决常见问题的可复用方案。解释器模式是一种行为型设计模式，它为语言创建解释器，就像编译器或解释器处理高级编程语言一样。这种模式在处理特定领域语言（DSL）或者需要解析和执行特定语法规则的场景下非常有用。通过理解解释器模式，我们可以更好地处理复杂的语法结构，将其转化为可执行的代码逻辑。
    </p>
    <p style="text-align:center">
     <img alt="" height="604" src="https://i-blog.csdnimg.cn/direct/db3d628124b7431eacddd2c28561fbf4.png" width="188"/>
    </p>
    <p style="text-align:center">
    </p>
    <h3 id="二、定义与描述">
     二、定义与描述
    </h3>
    <p class="img-center">
     <img alt="" height="543" src="https://i-blog.csdnimg.cn/direct/d26a20ecdf324727b3f7be9123d8ae26.png" width="393"/>
    </p>
    <p>
     解释器模式定义了一种语言的语法表示，并定义一个解释器来解释该语言中的句子。它使用类来表示每个语法规则，并且通过递归调用这些类的方法来解释表达式。本质上，它将一个复杂的表达式分解为一系列简单的部分，然后按照特定的语法规则进行解析和执行。
    </p>
    <p class="img-center">
     <img alt="" height="1102" src="https://i-blog.csdnimg.cn/direct/36bb0116ba434077bfaf027b76b8b4c1.png" width="461"/>
    </p>
    <h3 id="三、抽象背景">
     三、抽象背景
    </h3>
    <p>
     在许多应用场景中，我们需要处理一些自定义的、具有特定语法规则的语言。例如，在数据库查询语言中，有特定的语法来表示查询条件（如SQL语句）；在数学表达式求值中，有运算符号和数字组成的表达式（如3 + 4 * 2）。解释器模式提供了一种方式，将这些表达式转化为可执行的操作。
    </p>
    <p class="img-center">
     <img alt="" height="483" src="https://i-blog.csdnimg.cn/direct/c87895bef7eb4b7490f321398590dc8b.png" width="109"/>
    </p>
    <p>
    </p>
    <h3 id="四、适用场景与现实问题解决">
     四、适用场景与现实问题解决
    </h3>
    <p>
     <strong>
      特定领域语言（DSL）处理
     </strong>
    </p>
    <p>
     现实问题：在配置文件中，可能存在一种自定义的配置语言，用于描述系统的某些行为。例如，在游戏开发中，可能有自定义的脚本语言来控制游戏角色的行为。
    </p>
    <p>
     解决方案：使用解释器模式可以编写解释器来解析这些自定义的脚本语言，从而实现游戏角色按照脚本中的指令进行行动。
    </p>
    <table>
     <thead>
      <tr>
       <th style="width: 55px;">
        步骤
       </th>
       <th style="width: 83px;">
        组件
       </th>
       <th style="width: 323px;">
        输入
       </th>
       <th style="width: 227px;">
        输出
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="width:55px">
        1
       </td>
       <td style="width:83px">
        脚本文件
       </td>
       <td style="width:323px">
        自定义游戏脚本（如“移动（角色A，10个单位）”）
       </td>
       <td style="width:227px">
        -
       </td>
      </tr>
      <tr>
       <td style="width:55px">
        2
       </td>
       <td style="width:83px">
        词法分析器
       </td>
       <td style="width:323px">
        自定义游戏脚本
       </td>
       <td style="width:227px">
        单个Token（“移动”、“角色A”、“10个单位”）
       </td>
      </tr>
      <tr>
       <td style="width:55px">
        3
       </td>
       <td style="width:83px">
        语法分析器
       </td>
       <td style="width:323px">
        单个Token
       </td>
       <td style="width:227px">
        抽象语法树（以“移动”为根节点等结构）
       </td>
      </tr>
      <tr>
       <td style="width:55px">
        4
       </td>
       <td style="width:83px">
        解释器
       </td>
       <td style="width:323px">
        抽象语法树
       </td>
       <td style="width:227px">
        游戏角色行为指令（角色A移动10个单位）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      数学表达式求值
     </strong>
    </p>
    <p>
     现实问题：在科学计算或者金融计算中，需要对包含变量和运算符的数学表达式进行求值。
    </p>
    <p>
     解决方案：解释器模式可以将数学表达式分解为数字、变量和运算符等元素，然后按照数学运算规则进行求值。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        步骤
       </th>
       <th>
        组件
       </th>
       <th>
        输入
       </th>
       <th>
        输出
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1
       </td>
       <td>
        数学表达式文本
       </td>
       <td>
        “3 + 4 * x”（设x = 2）
       </td>
       <td>
        -
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        词法分析器
       </td>
       <td>
        “3 + 4 * x”
       </td>
       <td>
        3、+、4、*、x
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        语法分析器
       </td>
       <td>
        3、+、4、*、x
       </td>
       <td>
        抽象语法树（以“+”为根节点等结构）
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        解释器
       </td>
       <td>
        抽象语法树
       </td>
       <td>
        11
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="五、解释器模式的现实生活的例子">
     五、解释器模式的现实生活的例子
    </h3>
    <p>
     <strong>
      音乐乐谱解释
     </strong>
    </p>
    <p>
     初衷：音乐乐谱是一种特定的“语言”，它由音符、节拍、休止符等元素按照一定的规则组成。音乐家需要将乐谱上的符号转化为实际的音乐演奏。
    </p>
    <p>
     问题解决：可以将乐谱看作是一种待解释的表达式，使用解释器模式创建一个解释器，将乐谱中的每个元素（音符等）解释为对应的音乐演奏指令，如音高、持续时间等，从而实现音乐的演奏。
    </p>
    <p class="img-center">
     <img alt="" height="706" src="https://i-blog.csdnimg.cn/direct/e5d5ba98d537481ab5d2154f667dcfd0.png" width="239"/>
    </p>
    <h3 id="六、代码示例">
     六、代码示例
    </h3>
    <h4 id="Java代码示例">
     Java代码示例
    </h4>
    <pre><code class="language-java">// 抽象表达式
interface Expression {
    int interpret();
}

// 终结符表达式 - 数字
class NumberExpression implements Expression {
    private int number;

    public NumberExpression(int number) {
        this.number = number;
    }

    @Override
    public int interpret() {
        return number;
    }
}

// 非终结符表达式 - 加法
class AddExpression implements Expression {
    private Expression left;
    private Expression right;

    public AddExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int interpret() {
        return left.interpret() + right.interpret();
    }
}

public class InterpreterPatternJava {
    public static void main(String[] args) {
        Expression num1 = new NumberExpression(3);
        Expression num2 = new NumberExpression(4);
        Expression add = new AddExpression(num1, num2);
        System.out.println("结果: " + add.interpret());
    }
}</code></pre>
    <p>
     类图：
    </p>
    <p>
     <img alt="" height="382" src="https://i-blog.csdnimg.cn/direct/cecb766e20154033b961233f2f66ff94.png" width="877"/>
    </p>
    <p>
     流程图：
    </p>
    <p class="img-center">
     <img alt="" height="557" src="https://i-blog.csdnimg.cn/direct/89f513bebc64434faa4d5ce789c0bfe9.png" width="356"/>
    </p>
    <p>
     时序图：
    </p>
    <p>
     <img alt="" height="606" src="https://i-blog.csdnimg.cn/direct/ed447c09710442939dfabc92473e147e.png" width="871"/>
    </p>
    <hr/>
    <h4 id="C++代码示例">
     C++代码示例
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;

// 抽象表达式类
class Expression {
public:
    virtual int interpret() = 0;
};

// 数字表达式类（终结符表达式）
class NumberExpression : public Expression {
private:
    int number;
public:
    NumberExpression(int num) : number(num) {}
    int interpret() override {
        return number;
    }
};

// 加法表达式类（非终结符表达式）
class AddExpression : public Expression {
private:
    Expression* left;
    Expression* right;
public:
    AddExpression(Expression* l, Expression* r) : left(l), right(r) {}
    int interpret() override {
        return left-&gt;interpret() + right-&gt;interpret();
    }
};

int main() {
    Expression* num1 = new NumberExpression(3);
    Expression* num2 = new NumberExpression(4);
    Expression* add = new AddExpression(num1, num2);
    std::cout &lt;&lt; "结果: " &lt;&lt; add-&gt;interpret() &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <hr/>
    <h4 id="Python代码示例" style="background-color:transparent">
     Python代码示例
    </h4>
    <p>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/65c7b2a013264686856450fd8a05668b.png" width="1024"/>
    </p>
    <pre><code class="language-python"># 抽象表达式
class Expression:
    def interpret(self):
        pass

# 终结符表达式 - 数字
class NumberExpression(Expression):
    def __init__(self, number):
        self.number = number

    def interpret(self):
        return self.number

# 非终结符表达式 - 加法
class AddExpression(Expression):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def interpret(self):
        return self.left.interpret() + self.right.interpret()


num1 = NumberExpression(3)
num2 = NumberExpression(4)
add = AddExpression(num1, num2)
print("结果:", add.interpret())</code></pre>
    <hr/>
    <h4 id="Go代码示例">
     Go代码示例
    </h4>
    <pre><code class="language-Go">// 抽象表达式接口
type Expression interface {
    interpret() int
}

// 数字表达式结构体（终结符表达式）
type NumberExpression struct {
    number int
}

func (n *NumberExpression) interpret() int {
    return n.number
}

// 加法表达式结构体（非终结符表达式）
type AddExpression struct {
    left  Expression
    right Expression
}

func (a *AddExpression) interpret() int {
    return a.left.interpret() + a.right.interpret()
}

func main() {
    num1 := &amp;NumberExpression{3}
    num2 := &amp;NumberExpression{4}
    add := &amp;AddExpression{num1, num2}
    println("结果:", add.interpret())
}</code></pre>
    <hr/>
    <h3 id="七、解释器模式的优缺点">
     七、解释器模式的优缺点
    </h3>
    <h4 id="优点">
     优点
    </h4>
    <p>
     <strong>
      灵活性
     </strong>
    </p>
    <p>
     可以很容易地改变和扩展语法规则，只要修改相应的表达式类即可。
    </p>
    <p>
     <strong>
      可维护性
     </strong>
    </p>
    <p>
     每个语法规则都由一个单独的类表示，使得代码结构清晰，易于理解和维护。
    </p>
    <p>
     <strong>
      易于实现简单的语法
     </strong>
    </p>
    <p>
     对于简单的语法规则，解释器模式可以快速实现解析和执行功能。
    </p>
    <h4 id="缺点">
     缺点
    </h4>
    <p>
     <strong>
      复杂性
     </strong>
    </p>
    <p>
     对于复杂的语法，可能需要创建大量的表达式类，导致类的数量过多，增加系统的复杂性。
    </p>
    <p>
     <strong>
      性能问题
     </strong>
    </p>
    <p>
     解释器模式通常是通过递归调用方法来解释表达式，对于复杂的表达式可能会导致性能下降。
    </p>
    <table>
     <thead>
      <tr>
       <th style="width: 64px;">
        <strong>
         分类
        </strong>
       </th>
       <th style="width: 181px;">
        <strong>
         特性
        </strong>
       </th>
       <th style="width: 444px;">
        <strong>
         说明
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td colspan="1" rowspan="3" style="width:64px">
        <strong>
         优点
        </strong>
       </td>
       <td style="width:181px">
        <strong>
         灵活性
        </strong>
       </td>
       <td style="width:444px">
        可通过修改表达式类轻松调整语法规则，支持动态扩展功能。
       </td>
      </tr>
      <tr>
       <td style="width:181px">
        <strong>
         可维护性
        </strong>
       </td>
       <td style="width:444px">
        语法规则独立成类，结构清晰，便于理解、修改和维护。
       </td>
      </tr>
      <tr>
       <td style="width:181px">
        <strong>
         简单语法实现高效
        </strong>
       </td>
       <td style="width:444px">
        对于简单语法场景，能快速完成解析与执行逻辑的编码。
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="2" style="width:64px">
        <strong>
         缺点
        </strong>
       </td>
       <td style="width:181px">
        <strong>
         类爆炸问题
        </strong>
       </td>
       <td style="width:444px">
        复杂语法需创建大量表达式类，导致类数量激增，增加系统复杂度。
       </td>
      </tr>
      <tr>
       <td style="width:181px">
        <strong>
         性能瓶颈
        </strong>
       </td>
       <td style="width:444px">
        递归调用解释表达式，复杂场景下可能引发栈溢出或性能下降（如多层嵌套表达式）。
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="八、解释器模式的升级版">
     八、解释器模式的升级版
    </h3>
    <p>
     <strong>
      语法分析器生成器（Parser Generator）
     </strong>
    </p>
    <p>
     一些工具如ANTLR（Another Tool for Language Recognition）可以根据语法定义自动生成语法分析器。这种方式比手动编写解释器模式更加高效和准确，尤其适用于复杂的语法结构。它将语法定义与代码实现分离，使得语法的修改更加方便，同时可以生成更加优化的解析代码，提高性能。
    </p>
    <p>
     <img alt="" height="774" src="https://i-blog.csdnimg.cn/direct/956d725f7ee74ff9a407217bed99843a.png" width="965"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f776e6d32332f:61727469636c652f64657461696c732f313436303535383734" class_="artid" style="display:none">
 </p>
</div>


