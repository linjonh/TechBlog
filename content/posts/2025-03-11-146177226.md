---
layout: post
title: "常见的死锁情况分析"
date: 2025-03-11 17:28:14 +0800
description: "如果线程在获取锁时超时了，就主动释放已持有的锁，并重新尝试或返回失败，这样就可以避免死锁的发生。的状态，即某个资源在同一时刻只能被一个线程或进程占用。如果其他线程或进程请求该资源，它们必须等待该资源被释放。在一个线程的等待链中，存在一个环路，使得每个线程都在等待另一个线程释放资源。一个线程已经持有至少一个资源，但又请求其他线程占有的资源，并且在等待的过程中保持对已占有资源的控制。已经分配给一个线程的资源，在该线程使用完之前不能被强制剥夺。在一些情况下，如果锁定的资源是递归锁，锁，而不允许线程先获得。"
keywords: "常见的死锁情况分析"
categories: ['操作系统']
tags: ['死锁', 'C']
artid: "146177226"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146177226
    alt: "常见的死锁情况分析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146177226
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146177226
cover: https://bing.ee123.net/img/rand?artid=146177226
image: https://bing.ee123.net/img/rand?artid=146177226
img: https://bing.ee123.net/img/rand?artid=146177226
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     常见的死锁情况分析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <strong>
      死锁
     </strong>
    </h2>
    <p>
     <strong>
      定义：
     </strong>
    </p>
    <p>
     <strong>
      是指
      <span style="color:#fe2c24">
       多个进程或线程
      </span>
      在执行过程中，由于竞争资源或因通信的需要而产生的相互等待的状态，使得它们无法继续执行下去（单线程中使用不恰当也会导致死锁问题）。
     </strong>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       <span style="background-color:#cccccc">
        如下为常见的死锁原因：
       </span>
      </strong>
     </span>
    </p>
    <p>
     <strong>
      a. 互斥条件
     </strong>
     ：
    </p>
    <p>
     至少有一个资源必须处于
     <strong>
      不可共享
     </strong>
     的状态，即某个资源在同一时刻只能被一个线程或进程占用。如果其他线程或进程请求该资源，它们必须等待该资源被释放。
    </p>
    <p>
     <strong>
      b. 请求与保持条件
     </strong>
     ：
    </p>
    <p>
     一个线程已经持有至少一个资源，但又请求其他线程占有的资源，并且在等待的过程中保持对已占有资源的控制。
    </p>
    <p>
     <strong>
      c. 不剥夺条件
     </strong>
     ：
    </p>
    <p>
     已经分配给一个线程的资源，在该线程使用完之前不能被强制剥夺。资源只能由线程自己释放。
    </p>
    <p>
     <strong>
      d. 循环等待条件
     </strong>
     ：
    </p>
    <p>
     在一个线程的等待链中，存在一个环路，使得每个线程都在等待另一个线程释放资源。即形成了一种“循环等待”状态。
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       <span style="background-color:#cccccc">
        如下为常见的死锁原因对应代码分析：
       </span>
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std;

std::mutex mtxAB;
std::recursive_mutex rmtxAB;
std::mutex mtx_C;
std::mutex mtx_D;

void B(void);
void B1(void);

// 死锁1——demo1
void A(void)
{
    lock_guard&lt;std::mutex&gt; lock(mtxAB);
    // 保护资源
    B();
}

void B(void)
{
    A();
}

// 死锁2——demo2
void A1(void)
{
    // lock_guard&lt;std::mutex&gt; lock(mtxAB);
    // 解决这种死锁方法
    lock_guard&lt;std::recursive_mutex&gt; lock(rmtxAB);
    // 保护资源
    B1();
}

void B1(void)
{
    // lock_guard&lt;std::mutex&gt; lock(mtxAB);
    // 解决这种死锁方法
    lock_guard&lt;std::recursive_mutex&gt; lock(rmtxAB);    
    // 保护资源
}

// 死锁3——demo1
void C(void)
{
    // 先获取mtx_C
    std::lock_guard&lt;std::mutex&gt; lock1(mtx_C);
    // 保护资源
    printf("C: operate something\n");
    // 再获取mtx_D
    std::lock_guard&lt;std::mutex&gt; lock2(mtx_D);
}

void D(void)
{
    // 先获取mtx_D
    std::lock_guard&lt;std::mutex&gt; lock1(mtx_D);
    // 保护资源
    printf("D: operate something\n");
    // 再获取mtx_C
    std::lock_guard&lt;std::mutex&gt; lock2(mtx_C);
}

int main()
{
    // test死锁1——demo1
    // A();
    // test死锁2——demo2
    A1();    
    // test死锁3——demo3
    // std::thread thread[] = {
    //     std::thread(C),
    //     std::thread(D)
    // };
    // for(auto&amp; t : thread){
    //     t.join();
    // }
    // 死锁4...
    printf("the main normally exit!\n");
    return 0;
}
</code></pre>
    <p>
     <span style="color:#fe2c24">
      <span style="background-color:#fef2f0">
       那么如何解决死锁呢？
      </span>
     </span>
    </p>
    <h5>
     <strong>
      1. 避免嵌套锁（或锁的顺序）
     </strong>
    </h5>
    <p>
     最常见的避免死锁的方法之一是确保线程按
     <strong>
      固定的顺序
     </strong>
     获取锁。比如，规定所有线程首先获得
     <code>
      MutexA
     </code>
     锁，然后再获得
     <code>
      MutexB
     </code>
     锁，而不允许线程先获得
     <code>
      MutexB
     </code>
     锁再去获得
     <code>
      MutexA
     </code>
     锁。
    </p>
    <p>
     <span style="color:#fe2c24">
      <span style="background-color:#d7d8d9">
       （可自行尝试解决如上代码中demo3）
      </span>
     </span>
    </p>
    <h5>
     <strong>
      2. 使用超时机制
     </strong>
    </h5>
    <p>
     设置锁的超时时间。如果线程在获取锁时超时了，就主动释放已持有的锁，并重新尝试或返回失败，这样就可以避免死锁的发生。
    </p>
    <h5>
     <strong>
      3. 死锁检测与恢复
     </strong>
    </h5>
    <p>
     某些系统会周期性检查是否存在死锁。如果发现死锁状态，可以通过终止一个或多个线程、回滚某些操作或强制释放锁来恢复。
    </p>
    <h5>
     <strong>
      4. 使用递归锁
     </strong>
    </h5>
    <p>
     在一些情况下，如果锁定的资源是递归锁，
     <strong>
      同一线程
     </strong>
     可以多次获取锁，而不会导致死锁。这对于某些设计中需要递归调用的情况有效。
    </p>
    <p>
     <strong>
      end！
     </strong>
    </p>
    <p>
     <strong>
      各位大佬有什么补充，或者需要更正的欢迎指出哈~
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34393936323231302f:61727469636c652f64657461696c732f313436313737323236" class_="artid" style="display:none">
 </p>
</div>


