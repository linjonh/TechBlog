---
layout: post
title: "6.聊天室环境安装-Ubuntu22.04-elasticsearches的安装和使用"
date: 2025-03-09 18:07:30 +0800
description: "Ubuntu22.04 - elasticsearch(es)的安装和使用"
keywords: "6.聊天室环境安装 - Ubuntu22.04 - elasticsearch(es)的安装和使用"
categories: ['聊天室', '框架工具的安装和使用', '仿微信程序', 'Ubuntu']
tags: ['搜索引擎', 'Elasticsearch']
artid: "145805635"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145805635
    alt: "6.聊天室环境安装-Ubuntu22.04-elasticsearches的安装和使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145805635
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145805635
cover: https://bing.ee123.net/img/rand?artid=145805635
image: https://bing.ee123.net/img/rand?artid=145805635
img: https://bing.ee123.net/img/rand?artid=145805635
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     6.聊天室环境安装 - Ubuntu22.04 - elasticsearch(es)的安装和使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-kimbie-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_3">
     </a>
     介绍
    </h2>
    <p>
     Elasticsearch， 简称 ES，它是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful 风格接口，多数据源，自动搜索负载等。它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。es 也使用 Java 开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。
     <br/>
     Elasticsearch 是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在 Elasticsearch 中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。
    </p>
    <h2>
     <a id="_8">
     </a>
     安装
    </h2>
    <p>
     <strong>
      1.添加仓库密钥
     </strong>
     <br/>
     <code>
      wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
     </code>
     <br/>
     <strong>
      2.添加镜像源仓库
     </strong>
     <br/>
     <code>
      echo "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee /etc/apt/sources.list.d/elasticsearch.list
     </code>
     <br/>
     <strong>
      3.更新软件包列表
     </strong>
     <br/>
     <code>
      sudo apt update
     </code>
     <br/>
     <strong>
      4.安装es
     </strong>
     <br/>
     <code>
      sudo apt-get install elasticsearch=7.17.21
     </code>
     <br/>
     <strong>
      5.安装ik分词器插件
     </strong>
     <br/>
     <code>
      sudo /usr/share/elasticsearch/bin/elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/7.17.21
     </code>
     <br/>
     <strong>
      6.启动es
     </strong>
     <br/>
     <code>
      sudo systemctl start elasticsearch
     </code>
     <br/>
     <strong>
      6.5如果启动es失败
     </strong>
     <br/>
     调整 ES 虚拟内存，虚拟内存默认最大映射数为 65530，无法满足 ES 系统要求，需要调整为 262144 以上
     <br/>
     <code>
      sysctl -w vm.max_map_count=262144
     </code>
     <br/>
     增加虚拟机内存配置
     <br/>
     <code>
      vim /etc/elasticsearch/jvm.options
     </code>
     <br/>
     新增如下内容:
     <br/>
     -Xms512m
     <br/>
     -Xmx512m
     <br/>
     <img alt="在这里插入图片描述" height="300" src="https://i-blog.csdnimg.cn/direct/da0e27a7feee47fdbdfcf6177797df49.png"/>
    </p>
    <p>
     设置完后重启ubuntu
     <br/>
     <strong>
      7.查看es服务的状态
     </strong>
     <br/>
     <code>
      sudo systemctl status elasticsearch.service
     </code>
     <br/>
     <img alt="在这里插入图片描述" height="200" src="https://i-blog.csdnimg.cn/direct/35e0bd6a67fe4f3fad7cc8ab6434da90.png">
      <br/>
      <strong>
       8.验证es是否安装成功
      </strong>
      <br/>
      <code>
       curl -X GET "http://localhost:9200/"
      </code>
      <br/>
      <img alt="在这里插入图片描述" height="200" src="https://i-blog.csdnimg.cn/direct/ddc3aa02d406452fb2122959fd78bcc0.png">
       <br/>
       <strong>
        9.设置能够外部访问: 如果新配置完成默认只能在本机进行访问
       </strong>
       <br/>
       <code>
        vim /etc/elasticsearch/elasticsearch.yml
       </code>
       <br/>
       新增配置
      </img>
     </img>
    </p>
    <pre><code>network.host: 0.0.0.0
http.port: 9200
cluster.initial_master_nodes: ["node-1"]
</code></pre>
    <p>
     <img alt="在这里插入图片描述" height="200" src="https://i-blog.csdnimg.cn/direct/3651428ca2584586911d4e7fe4188124.png">
      <br/>
      重启后
      <code>
       sudo systemctl restart elasticsearch.service
      </code>
      <br/>
      浏览器访问http://自己的IP:9200/
      <br/>
      <img alt="在这里插入图片描述" height="300" src="https://i-blog.csdnimg.cn/direct/1f7d24020a3c4a40b3fefce41a9e3255.png"/>
     </img>
    </p>
    <h2>
     <a id="kibana_51">
     </a>
     安装kibana
    </h2>
    <p>
     kibana可以支持通过网页对ES进行访问(增删查改), 这可以让我们的测试更加直观一些
     <br/>
     <strong>
      1.安装kibana
     </strong>
     <br/>
     <code>
      sudo apt install kibana
     </code>
     <br/>
     <strong>
      2.配置kibana
     </strong>
     <br/>
     <code>
      sudo vim /etc/kibana/kibana.yml
     </code>
     <br/>
     在7行修改为
     <code>
      server.host: "0.0.0.0"
     </code>
     <br/>
     <img alt="在这里插入图片描述" height="200" src="https://i-blog.csdnimg.cn/direct/d17b76cc47594e57a01d2886cf1eca9c.png"/>
    </p>
    <p>
     在32行修改为
     <code>
      elasticsearch.hosts: ["http://0.0.0.0:9200"]
     </code>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c2fe2302542745c68a2d4ceb867f45be.png">
      <br/>
      <strong>
       3.启动kibana服务
      </strong>
      <br/>
      <code>
       sudo systemctl start kibana
      </code>
      <br/>
      <strong>
       4.验证安装
      </strong>
      <br/>
      <code>
       sudo systemctl status kibana
      </code>
      <br/>
      <strong>
       5.访问kibana
      </strong>
      <br/>
      在浏览器访问kibana,
      <code>
       http://你的ip:5601
      </code>
      <br/>
      <img alt="在这里插入图片描述" height="300" src="https://i-blog.csdnimg.cn/direct/33974b9a38694e3b982d9dd67393bbe2.png"/>
     </img>
    </p>
    <h2>
     <a id="ES_70">
     </a>
     安装ES客户端
    </h2>
    <p>
     <strong>
      1.克隆代码
     </strong>
     <br/>
     <code>
      git clone https://github.com/seznam/elasticlient
     </code>
     <br/>
     <strong>
      注意: 这里不能从github下载源码然后拖拽进来
     </strong>
     , 因为内部有git子模块, 需要去更新子模块之后, 才能去编译
     <br/>
     如果无法始终clone不下来, 也有对应的解决方案:
     <a href="https://blog.csdn.net/eyuyanniniu/article/details/145807381?spm=1001.2014.3001.5501">
      https://blog.csdn.net/eyuyanniniu/article/details/145807381
     </a>
     <br/>
     <strong>
      2.切换目录
     </strong>
     <br/>
     <code>
      cd elasticlient
     </code>
     <br/>
     <strong>
      3.安装 MicroHTTPD 库
     </strong>
     <br/>
     <code>
      sudo apt-get install libmicrohttpd-dev
     </code>
     <br/>
     <strong>
      4.更新子模块
     </strong>
     <br/>
     <code>
      git submodule update --init --recursive
     </code>
     <br/>
     <strong>
      5.编译安装代码
     </strong>
     <br/>
     <code>
      mkdir build
     </code>
     <br/>
     <code>
      cd build
     </code>
     <br/>
     <code>
      cmake ..
     </code>
     <br/>
     <code>
      make
     </code>
     <br/>
     <code>
      make install
     </code>
    </p>
    <p>
     <strong>
      6.配置环境变量
     </strong>
     <br/>
     因为我们的库默认安装路径是/usr/local/lib, 编译器可能找不到这个库目录的位置
     <br/>
     所以我们需要配置(这些文件最好都进行配置):
     <br/>
     <code>
      全局设置: /etc/profile
     </code>
     <code>
      当前用户设置: .bash_profil或.bashrc
     </code>
     <br/>
     在文件末尾加上
     <code>
      export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
     </code>
    </p>
    <h2>
     <a id="_93">
     </a>
     使用
    </h2>
    <p>
     封装icsearch.hpp文件
    </p>
    <pre><code>#include &lt;elasticlient/client.h&gt;
#include &lt;cpr/cpr.h&gt;
#include &lt;json/json.h&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include "logger.hpp"

//ES的二次封装, 原因: 为了简化ES的使用操作, 我们可以看到, 请求的时候, 正文很长, 我们希望只设置我们关心的参数即可, 而且能自动的构造完成
//封装四个操作: 索引创建, 数据新增, 数据查询, 数据删除

namespace wufan_im{
bool UnSerialize(const std::string&amp; src, Json::Value&amp; val)
{
    // 同样的Read类, 需要先构造出工厂类
    Json::CharReaderBuilder crb;
    std::unique_ptr&lt;Json::CharReader&gt; cr(crb.newCharReader());
    std::string err;
    bool ret = cr-&gt;parse(src.c_str(), src.c_str() + src.size(), &amp;val, &amp;err);
    if (ret == false) {
        std::cout &lt;&lt; "json反序列化失败: " &lt;&lt; err &lt;&lt; std::endl;
        return false;
    }
    return true;
}

bool Serialize(const Json::Value&amp; val, std::string&amp; dst)
{
    // Writer(StreamWriter)类, 这个类就是用来序列化的, 但是这个类不能直接构造, 因为使用了工厂模式
    // 先定义Json::SreamWriter 工厂类 Json::StreamWriterBuilder
    Json::StreamWriterBuilder swb;  //构造出工厂类
    std::unique_ptr&lt;Json::StreamWriter&gt; sw(swb.newStreamWriter());
    // 通过Json::StreamWriter中的write接口进行序列化
    std::stringstream ss;
    int ret = sw-&gt;write(val, &amp;ss);  //将其序列化到字符流里面
    if (ret != 0) {
        std::cout &lt;&lt; "Json反序列化失败!\n";
        return false;
    }
    dst = ss.str();
    return true;
}

// 索引创建:
// 传两个参数, 索引名称 和 索引类型 就可以创建出索引
// 能够添加字段, 并设置字段类型, 设置分词器类型, 是否构造索引
class ESIndex{
    public:
        ESIndex(std::shared_ptr&lt;elasticlient::Client&gt;&amp; client, const std::string&amp; name, const std::string&amp; type = "_doc")
        :_name(name), _type(type), _client(client)
        {
            Json::Value analysis;   //可以把Value当做Json里的{ }
            Json::Value analyzer;
            Json::Value ik;
            Json::Value tokenizer;
            tokenizer["tokenizer"] = "ik_max_word";
            ik["ik"] = tokenizer;
            analyzer["analyzer"] = ik;
            analysis["analysis"] = analyzer;
            _index["settings"] = analysis;
        }
        // 创建索引, 就相当于在设置表结构 - ai说的
        // 添加字段, 就相当于设置表的字段属性
        ESIndex&amp; append(const std::string&amp; key, const std::string&amp; type = "text", 
        const std::string&amp; analyzer = "ik_max_word", bool enabled = true) {
            Json::Value fields;
            fields["type"] = type;
            fields["analyzer"] = analyzer;
            if (enabled == false) fields["enabled"] = enabled;
            _properties[key] = fields;
            return *this;
        }
        bool create(const std::string&amp; index_id = "default_index_id") {
            Json::Value mappings;
            mappings["dynamic"] = true;
            mappings["properties"] = _properties;
            _index["mappings"] = mappings;

            std::string body;
            bool ret = Serialize(_index, body);
            if (ret == false) {
                LOG_ERROR("索引序列化失败! ");
                return false;
            }
            
            LOG_DEBUG("{}", body);
            // 2. 发起搜索请求
            try{    //因为请求失败就可能会抛异常, 异常你不接住, 程序就会崩溃
                auto rsp = _client-&gt;index(_name, _type, index_id, body);
                if (rsp.status_code &lt; 200 || rsp.status_code &gt;= 300) {
                    LOG_ERROR("创建ES索引 {} 失败, 响应状态码异常: {}", _name, rsp.status_code);
                    return false;
                }
            } catch(std::exception&amp; e) {
                LOG_ERROR("创建ES索引 {} 失败: {}", _name, e.what());
                return false;
            }
            return true;
        }
    private:
        std::string _name;
        std::string _type;
        Json::Value _properties;
        Json::Value _index;
        std::shared_ptr&lt;elasticlient::Client&gt; _client;
};

// 数据新增
class ESInsert{
    public:
        ESInsert(std::shared_ptr&lt;elasticlient::Client&gt;&amp; client, const std::string&amp; name,
                 const std::string&amp; type = "_doc")
        :_name(name), _type(type), _client(client)
        {}
        ESInsert&amp; append(const std::string&amp; key, const std::string&amp; val){
            _item[key] = val;
            return *this;
        }
        // 插入到哪个id里面 -  这个ID就相当于是每一次插入时数据的唯一标识
        bool insert(const std::string id = ""){
            std::string body;
            bool ret = Serialize(_item, body);
            if (ret == false) {
                LOG_ERROR("索引序列化失败! ");
                return false;
            }
            
            LOG_DEBUG("{}", body);
            // 2. 发起搜索请求
            try{    //因为请求失败就可能会抛异常, 异常你不接住, 程序就会崩溃
                auto rsp = _client-&gt;index(_name, _type, id, body);
                if (rsp.status_code &lt; 200 || rsp.status_code &gt;= 300) {
                    LOG_ERROR("新增数据 {} 失败, 响应状态码异常: {}", body, rsp.status_code);
                    return false;
                }
            } catch(std::exception&amp; e) {
                LOG_ERROR("新增数据 {} 失败: {}", body, e.what());
                return false;
            }
            return true;
        }
    private:
        std::string _name;
        std::string _type;
        Json::Value _item;
        std::shared_ptr&lt;elasticlient::Client&gt; _client;
};


// 数据删除
class ESRemove{
    public:
        ESRemove(std::shared_ptr&lt;elasticlient::Client&gt;&amp; client, const std::string&amp; name, const std::string&amp; type)
        :_name(name), _type(type), _client(client)
        {}
        bool remove(const std::string&amp; id) {
            try{    //因为请求失败就可能会抛异常, 异常你不接住, 程序就会崩溃
                auto rsp = _client-&gt;remove(_name, _type, id);
                if (rsp.status_code &lt; 200 || rsp.status_code &gt;= 300) {
                    LOG_ERROR("删除数据 {} 失败, 响应状态码异常: {}", id, rsp.status_code);
                    return false;
                }
            } catch(std::exception&amp; e) {
                LOG_ERROR("删除数据 {} 失败: {}", id, e.what());
                return false;
            }
            return true;
        }
    private:
        std::string _name;
        std::string _type;
        std::shared_ptr&lt;elasticlient::Client&gt; _client;
};


//数据查询
class ESSearch{
    public: //用户还会设置过滤条件，以及应该包含的字段
        ESSearch(std::shared_ptr&lt;elasticlient::Client&gt;&amp; client, const std::string&amp; name, const std::string&amp; type = "_doc")
        :_name(name), _type(type), _client(client)
        {}
        ESSearch&amp; append_must_not_terms(const std::string&amp; key, const std::vector&lt;std::string&gt;&amp; vals){
            Json::Value fields;
            for (const auto&amp; val : vals) {
                fields[key].append(val);
            }
            Json::Value terms;
            terms["terms"] = fields;
            _must_not.append(terms);
            return *this;
        }
        ESSearch&amp; append_should_match(const std::string&amp; key, const std::string&amp; val) {
            Json::Value field;
            field[key] = val;
            Json::Value match;
            match["match"] = field;
            _should.append(match);
            return *this;
        }
        Json::Value search() {
            Json::Value cond;
            if (_must_not.empty() == false) cond["must_not"] = _must_not;
            if (_should.empty() == false) cond["should"] = _should;
            Json::Value query;
            query["bool"] = cond;
            Json::Value root;
            root["query"] = query;
            std::string body;
            bool ret = Serialize(root, body);
            if (ret == false) {
                LOG_ERROR("索引序列化失败! ");
                return Json::Value();
            }
            LOG_DEBUG("{}", body);
            // 2. 发起搜索请求
            cpr::Response rsp;
            try{    //因为请求失败就可能会抛异常, 异常你不接住, 程序就会崩溃
                rsp = _client-&gt;search(_name, _type, body);
                if (rsp.status_code &lt; 200 || rsp.status_code &gt;= 300) {
                    LOG_ERROR("检索数据 {} 失败, 响应状态码异常: {}", body, rsp.status_code);
                    return Json::Value();
                }
            } catch(std::exception&amp; e) {
                LOG_ERROR("检索数据 {} 失败: {}", body, e.what());
                return Json::Value();
            }
            //3. 需要对响应正文进行反序列化
            LOG_DEBUG("检索响应正文: [{}]", rsp.text);
            Json::Value json_res;
            ret = UnSerialize(rsp.text, json_res);
            if (ret == false) {
                LOG_ERROR("检索数据 {} 结果反序列化失败", rsp.text);
                return Json::Value();
            }
            return json_res["hits"]["hits"];
        }
    private:
        std::string _name;
        std::string _type;
        //用户还会设置过滤条件，以及应该包含的字段
        Json::Value _must_not;  //必须不包含的
        Json::Value _should;    //必须包含的, 多选一即可
        std::shared_ptr&lt;elasticlient::Client&gt; _client;
};
}
</code></pre>
    <p>
     main.cc文件
    </p>
    <pre><code>#include "../../common/icsearch.hpp"
#include &lt;gflags/gflags.h&gt;

DEFINE_bool(run_mode, false, "程序的运行模式, false-调试; true-发布;");
DEFINE_string(log_file, "", "发布模式下, 用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下, 用于指定日志输出等级");

int main(int argc, char* argv[])
{
    google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);
    wufan_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);
    std::shared_ptr&lt;elasticlient::Client&gt; client(new elasticlient::Client({"http://127.0.0.1:9200/"}));
    bool ret = wufan_im::ESIndex(client, "test_user")
        // 创建索引, 就相当于在设置表结构 - ai说的
        // 添加字段, 就相当于设置表的字段属性
        .append("nickname")
        .append("phone", "keyword", "standard", true) //手机号是不能进行分词的, 是一个关键字, 分词器用标准分词器, 需要构造索引
        .create();
    if (ret == false) {
        LOG_INFO("索引创建失败!");
        return -1;
    }
    LOG_INFO("索引创建成功");

    // 新增数据
    ret = wufan_im::ESInsert(client, "test_user")
        .append("nickname", "张三")
        .append("phone", "155666777")
        .insert("00001");   // 这个ID就相当于是每一次插入时数据的唯一标识
    if (ret == false) {
        LOG_ERROR("数据插入失败!");
        return -1;
    }
    // 数据的修改
    ret = wufan_im::ESInsert(client, "test_user")
        .append("nickname", "张三")
        .append("phone", "1334444555")
        .insert("00001");
    if (ret == false) {
        LOG_ERROR("数据更新失败!");
        return -1;
    }
    LOG_INFO("数据新增成功");

    Json::Value user = wufan_im::ESSearch(client, "test_user")
        .append_should_match("phone.keyword", "1334444555")     //检索的时候, 告诉ES, 这个关键词不要进行分词
        // .append_must_not_terms("nickname.keyword", {"张三"})
        .search();
    if (user.empty() || user.isArray() == false) {
        LOG_ERROR("结果为空, 或者结果不是数组类型");
        return -1;
    }
    LOG_INFO("数据检索成功");
    int sz = user.size();
    LOG_DEBUG("检索结果条目数量: {}", sz);
    for (int i = 0; i &lt; sz; ++i) {
        LOG_INFO("nickname: {}", user[i]["_source"]["nickname"].asString());
    }

    ret = wufan_im::ESRemove(client, "test_user", "_doc").remove("00001");
    if (ret == false) {
        LOG_ERROR("删除数据失败");
        return -1;
    }
    LOG_INFO("数据删除成功");

    return 0;
}
</code></pre>
    <blockquote>
     <p>
      运行程序:
      <br/>
      <img alt="在这里插入图片描述" height="1000" src="https://i-blog.csdnimg.cn/direct/3b03c02934704cf9939f05c7a46da2ab.png"/>
     </p>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f65797579616e6e696e69752f:61727469636c652f64657461696c732f313435383035363335" class_="artid" style="display:none">
 </p>
</div>


