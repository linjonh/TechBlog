---
layout: post
title: "为什么大模型网站使用-SSE-而不是-WebSocket"
date: 2025-03-10 10:32:36 +0800
description: "在大模型网站（如 ChatGPT、Claude、Gemini 等）中，前端通常使用来与后端对接，而不是。这是因为 SSE 更适合类似流式文本生成的场景。下面我们详细对比。"
keywords: "sse 长连接对接大模型"
categories: ['未分类']
tags: ['网络协议', '网络', 'Websocket']
artid: "146146467"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146146467
    alt: "为什么大模型网站使用-SSE-而不是-WebSocket"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146146467
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146146467
cover: https://bing.ee123.net/img/rand?artid=146146467
image: https://bing.ee123.net/img/rand?artid=146146467
img: https://bing.ee123.net/img/rand?artid=146146467
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     为什么大模型网站使用 SSE 而不是 WebSocket？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      在大模型网站（如 ChatGPT、Claude、Gemini 等）中，前端通常使用
      <strong>
       EventSource（Server-Sent Events, SSE）
      </strong>
      来与后端对接，而不是
      <strong>
       WebSocket
      </strong>
      。这是因为 SSE 更适合类似流式文本生成的场景。下面我们详细对比
      <strong>
       SSE、WebSocket 和其他可选方案
      </strong>
      。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="1_SSEServerSent_Events_5">
     </a>
     1. SSE（Server-Sent Events，服务器发送事件）
    </h3>
    <h4>
     <a id="_6">
     </a>
     <strong>
      特点：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       单向通信
      </strong>
      （服务器 → 客户端），适用于大模型输出流式文本的场景。
     </li>
     <li>
      <strong>
       基于 HTTP/1.1 及 EventSource API
      </strong>
      ，兼容性较好，易于集成。
     </li>
     <li>
      <strong>
       自动重连
      </strong>
      ，如果连接断开，浏览器会自动尝试重新连接。
     </li>
     <li>
      <strong>
       轻量级
      </strong>
      ，开销小，适合传输文本数据。
     </li>
    </ul>
    <h4>
     <a id="_12">
     </a>
     <strong>
      缺点：
     </strong>
    </h4>
    <ul>
     <li>
      只支持
      <strong>
       服务器推送
      </strong>
      ，客户端无法主动发送消息（需要用 AJAX/Fetch 结合）。
     </li>
     <li>
      受
      <strong>
       同源策略
      </strong>
      影响，跨域时需要 CORS 配置。
     </li>
     <li>
      在
      <strong>
       HTTP/2 之前，SSE 只能打开 6 个连接
      </strong>
      （浏览器限制），但在 HTTP/2 上可复用单连接，问题减小。
     </li>
    </ul>
    <h4>
     <a id="_17">
     </a>
     <strong>
      适用场景：
     </strong>
    </h4>
    <p>
     ✔
     <strong>
      流式返回
     </strong>
     （如 ChatGPT 逐字输出）
     <br/>
     ✔ 服务器向前端持续推送数据（如股票行情、日志监控）
    </p>
    <hr/>
    <h3>
     <a id="2_WebSocket_23">
     </a>
     2. WebSocket
    </h3>
    <h4>
     <a id="_24">
     </a>
     <strong>
      特点：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       全双工通信
      </strong>
      ，客户端和服务器可以随时相互发送数据。
     </li>
     <li>
      <strong>
       基于 TCP，独立于 HTTP
      </strong>
      ，但通常通过 HTTP/HTTPS 协商（
      <code>
       ws://
      </code>
      或
      <code>
       wss://
      </code>
      ）。
     </li>
     <li>
      <strong>
       低延迟
      </strong>
      ，适用于高频交互（如实时聊天、游戏、协作编辑）。
     </li>
    </ul>
    <h4>
     <a id="_29">
     </a>
     <strong>
      缺点：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       连接管理复杂
      </strong>
      （心跳检测、断线重连、负载均衡较难）。
     </li>
     <li>
      <strong>
       代理/防火墙兼容性问题
      </strong>
      ，某些企业网络可能会阻止 WebSocket。
     </li>
     <li>
      <strong>
       服务器资源占用更大
      </strong>
      ，需要维护长连接，占用线程/内存。
     </li>
    </ul>
    <h4>
     <a id="_34">
     </a>
     <strong>
      适用场景：
     </strong>
    </h4>
    <p>
     ✔
     <strong>
      双向实时交互
     </strong>
     （如在线协作、弹幕、游戏匹配）
     <br/>
     ✔
     <strong>
      低延迟高频数据更新
     </strong>
     （如金融交易、物联网）
    </p>
    <h4>
     <a id="_WebSocket_38">
     </a>
     <strong>
      为什么大模型网站不用 WebSocket？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       WebSocket 适用于双向通信
      </strong>
      ，而
      <strong>
       大模型的输出是“流式”文本，客户端只需接收数据
      </strong>
      ，WebSocket 的优势无法体现。
     </li>
     <li>
      WebSocket 需要额外的
      <strong>
       连接管理
      </strong>
      ，而 SSE 依赖于现有的 HTTP 连接，更易集成。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="3_HTTP_Long_Polling_44">
     </a>
     3. HTTP 长轮询（Long Polling）
    </h3>
    <h4>
     <a id="_45">
     </a>
     <strong>
      特点：
     </strong>
    </h4>
    <ul>
     <li>
      客户端发送请求，服务器
      <strong>
       保持连接不返回数据
      </strong>
      ，直到有新数据才返回。
     </li>
     <li>
      客户端收到数据后立即发送新的请求，模拟流式通信。
     </li>
     <li>
      兼容性极好，所有 HTTP 服务器都支持。
     </li>
    </ul>
    <h4>
     <a id="_50">
     </a>
     <strong>
      缺点：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       请求开销大
      </strong>
      ，每次返回数据后都需要重新建立 HTTP 连接，浪费资源。
     </li>
     <li>
      <strong>
       延迟较高
      </strong>
      ，如果服务器没有数据，客户端必须定期请求，效率低。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="4_gRPC_HTTP2__56">
     </a>
     4. gRPC（基于 HTTP/2 的流式通信）
    </h3>
    <h4>
     <a id="_57">
     </a>
     <strong>
      特点：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       双向流式通信
      </strong>
      （客户端和服务器都可以持续发送数据）。
     </li>
     <li>
      <strong>
       基于 HTTP/2
      </strong>
      ，性能较好，可在单个连接上多路复用请求。
     </li>
     <li>
      <strong>
       适用于微服务通信
      </strong>
      ，比 REST API 更高效。
     </li>
    </ul>
    <h4>
     <a id="_62">
     </a>
     <strong>
      缺点：
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       浏览器原生不支持
      </strong>
      ，需要使用
      <strong>
       gRPC-Web
      </strong>
      代理转换。
     </li>
     <li>
      <strong>
       复杂度高
      </strong>
      ，部署比 SSE/WebSocket 难。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_68">
     </a>
     <strong>
      总结：哪种方式适合大模型前端？
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         方案
        </strong>
       </th>
       <th>
        <strong>
         是否适用于大模型流式返回？
        </strong>
       </th>
       <th>
        <strong>
         特点
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         SSE（EventSource）
        </strong>
       </td>
       <td>
        ✅
        <strong>
         最佳选择
        </strong>
       </td>
       <td>
        服务器 → 客户端单向推送，轻量、自动重连
       </td>
       <td>
        <strong>
         流式输出（ChatGPT）
        </strong>
        、实时通知
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         WebSocket
        </strong>
       </td>
       <td>
        ❌ 过度设计
       </td>
       <td>
        双向通信，低延迟，复杂连接管理
       </td>
       <td>
        聊天、游戏、协作编辑
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         长轮询（Long Polling）
        </strong>
       </td>
       <td>
        ❌ 开销大
       </td>
       <td>
        兼容性强但效率低，每次数据返回后需重新请求
       </td>
       <td>
        旧系统支持
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         gRPC（HTTP/2 流）
        </strong>
       </td>
       <td>
        ❌ 需要代理
       </td>
       <td>
        双向流式，高性能，浏览器需 gRPC-Web
       </td>
       <td>
        微服务、API 交互
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     📌
     <strong>
      所以，SSE 是最佳选择
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       天然支持流式输出
      </strong>
      ，非常适合 ChatGPT 这类逐字返回的内容。
     </li>
     <li>
      <strong>
       轻量级、简单易用
      </strong>
      ，只需
      <code>
       EventSource
      </code>
      API，不需要额外的连接管理。
     </li>
     <li>
      <strong>
       支持 HTTP/2
      </strong>
      ，比 WebSocket 适合这类请求响应模式。
     </li>
    </ol>
    <hr/>
    <h3>
     <a id="_SSE__84">
     </a>
     <strong>
      实际应用示例（基于 SSE 实现大模型流式输出）
     </strong>
    </h3>
    <h4>
     <a id="_SSE__86">
     </a>
     <strong>
      前端代码（使用 SSE 监听服务器消息）：
     </strong>
    </h4>
    <pre><code class="prism language-js"><span class="token keyword">const</span> eventSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span><span class="token string">'/chat/stream'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 后端返回流式数据</span>

eventSource<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'收到新消息:'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

eventSource<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'连接断开，尝试重连...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  eventSource<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="Nodejs__100">
     </a>
     <strong>
      后端代码（Node.js 示例）：
     </strong>
    </h4>
    <pre><code class="prism language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/chat/stream'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/event-stream'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Cache-Control'</span><span class="token punctuation">,</span> <span class="token string">'no-cache'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Connection'</span><span class="token punctuation">,</span> <span class="token string">'keep-alive'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> interval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">data: 你好，消息 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>count<span class="token operator">++</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\n\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">clearInterval</span><span class="token punctuation">(</span>interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <hr/>
    <h3>
     <a id="_120">
     </a>
     <strong>
      结论
     </strong>
    </h3>
    <p>
     SSE 是
     <strong>
      最适合大模型流式返回的方案
     </strong>
     ，因为它：
     <br/>
     ✅
     <strong>
      轻量级
     </strong>
     <br/>
     ✅
     <strong>
      自动重连
     </strong>
     <br/>
     ✅
     <strong>
      支持 HTTP/2
     </strong>
     <br/>
     ✅
     <strong>
      适用于服务器单向推送
     </strong>
    </p>
    <p>
     所以，大模型网站普遍使用
     <strong>
      SSE，而不是 WebSocket
     </strong>
     ！ 🚀
    </p>
    <h3>
     <a id="_128">
     </a>
     网站截图
    </h3>
    <h4>
     <a id="DeepSeek_129">
     </a>
     DeepSeek
    </h4>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/d13b9b44346b4a878ffeb785bc6efef5.png"/>
    </p>
    <h4>
     <a id="ChatGPThttpsiblogcsdnimgcndirect92652459ec884426b9a7d0151f18f372png_132">
     </a>
     ChatGPT
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/92652459ec884426b9a7d0151f18f372.png"/>
    </h4>
    <h4>
     <a id="Claudehttpsiblogcsdnimgcndirectec755c5068774fa4b68357806edbabe7png_133">
     </a>
     Claude
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/ec755c5068774fa4b68357806edbabe7.png"/>
    </h4>
    <h4>
     <a id="httpsiblogcsdnimgcndirect0e9c24cce8124b2f8caabdbdcc8b66b8png_134">
     </a>
     文心一言
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/0e9c24cce8124b2f8caabdbdcc8b66b8.png"/>
    </h4>
    <p>
     → 以上 🐒
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f66616b6572706c75732f:61727469636c652f64657461696c732f313436313436343637" class_="artid" style="display:none">
 </p>
</div>


