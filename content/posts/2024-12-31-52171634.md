---
layout: post
title: "音视频开发ffmpeg解码四"
date: 2024-12-31 10:57:25 +0800
description: "音视频最强大的开源库非ffmpeg莫属，网上对ffmpeg总结的最好的是雷神的博客（http://b"
keywords: "ffmpeg video codec"
categories: ['音视频教程']
tags: ['解码', 'Ios', 'Ffmpeg']
artid: "52171634"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=52171634
    alt: "音视频开发ffmpeg解码四"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=52171634
featuredImagePreview: https://bing.ee123.net/img/rand?artid=52171634
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     音视频开发——ffmpeg解码（四）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     iOS音视频开发相关文章：
    </p>
    <p>
     <a href="http://blog.csdn.net/a411358606/article/details/52168452" rel="noopener noreferrer" style="list-style:none; text-decoration:none; word-break:break-all; word-wrap:break-word; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif" target="_blank">
      音视频开发——概述（一）
     </a>
     <br/>
    </p>
    <p>
     <a href="http://blog.csdn.net/a411358606/article/details/52169400" rel="noopener noreferrer" style="list-style:none; text-decoration:none; word-break:break-all; word-wrap:break-word; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif" target="_blank">
      音视频开发——流媒体数据传输RTSP（二）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/a411358606/article/details/52171202" rel="noopener noreferrer" style="list-style:none; word-break:break-all; word-wrap:break-word; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif" target="_blank">
      音视频开发——流媒体数据传输RTP（三）
     </a>
     <br/>
    </p>
    <p>
     <a href="http://blog.csdn.net/a411358606/article/details/52171634" rel="noopener noreferrer" style="list-style:none; word-break:break-all; word-wrap:break-word; color:rgb(59,89,152); font-family:Verdana,'Lucida Grande',Arial,Helvetica,sans-serif" target="_blank">
      音视频开发——ffmpeg解码（四）
     </a>
    </p>
    <br/>
    <p>
     音视频最强大的开源库非ffmpeg莫属，网上对ffmpeg总结的最好的是￼
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/15811977" rel="noopener noreferrer" target="_blank">
      雷神的博客（http://blog.csdn.net/leixiaohua1020/article/details/15811977）
     </a>
     ，本文简单介绍下ffmpeg视频解码的使用。
    </p>
    <p>
     <strong>
      <span style="font-size:18px">
       1、ffmpeg初始化
      </span>
     </strong>
    </p>
    <p>
    </p>
    <pre><code class="language-objc">- (void)videoDecoder_init {
    
    avcodec_register_all();
//    _videoFrame = av_frame_alloc();
    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    _videoCodecCtx = avcodec_alloc_context3(codec);
    int ret = avcodec_open2(_videoCodecCtx, codec, nil);
    if (ret != 0){
        NSLog(@"open codec failed :%d",ret);
    }
    
    _videoFrame = av_frame_alloc();
    av_init_packet(&amp;_packet);
}</code></pre>
    <br/>
    其中，
    <p>
    </p>
    <p>
     _videoCodecCtx是ffmpeg编解码对象；
    </p>
    <p>
     _videoFrame是解码后的图像帧，可从中生成image图像；
    </p>
    <p>
    </p>
    <p class="p1">
     <span class="s1">
      _packet是解码前的数据帧，包括I帧、P帧等
     </span>
    </p>
    <p class="p1">
     <span class="s1">
      <strong>
       <span style="font-size:18px">
        2、解码操作
       </span>
      </strong>
     </span>
    </p>
    <p class="p1">
     <span class="s1">
     </span>
    </p>
    <pre><code class="language-objc">- (CGSize)videoDecoder_decodeToImage:(uint8_t *)nalBuffer size:(int)inSize {
    
    _packet.size = inSize;
    _packet.data = nalBuffer;

    CGSize frameSize = {0, 0};
    
    while (inSize &gt; 0) {
        
        int gotframe = 0;
        int len = avcodec_decode_video2(_videoCodecCtx,
                                        _videoFrame,
                                        &amp;gotframe,
                                        &amp;_packet);
        
        if (len &lt; 0) {
            NSLog(@"decode video error, skip packet");
            return frameSize;
        }
        
        inSize -= len;
    }
    frameSize.width = _videoCodecCtx-&gt;width;
    frameSize.height = _videoCodecCtx-&gt;height;
    
    _outputWidth = _videoCodecCtx-&gt;width;
    self.outputHeight = _videoCodecCtx-&gt;height;
    
    return frameSize;
}</code></pre>
    <strong>
     <span style="font-size:18px">
      <br/>
      3、获取解码后的图像
     </span>
    </strong>
    <p>
    </p>
    <p class="p1">
     <span class="s1">
     </span>
    </p>
    <pre><code class="language-objc">- (UIImage *)currentImage {

    if (!_videoFrame-&gt;data[0]) {
        return nil;
    }
    
    [self convertFrameToRGB];
    return [self imageFromAVPicture:_picture width:_outputWidth height:_outputHeight];
}

- (void)convertFrameToRGB {

    sws_scale(_img_convert_ctx, (const uint8_t * const*)_videoFrame-&gt;data, _videoFrame-&gt;linesize, 0, _videoCodecCtx-&gt;height, _picture.data, _picture.linesize);
}

- (UIImage *)imageFromAVPicture:(AVPicture)pict width:(int)width height:(int)height {

    CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;
    CFDataRef data = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, pict.data[0], pict.linesize[0] * height,kCFAllocatorNull);
    CGDataProviderRef provider = CGDataProviderCreateWithCFData(data);
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGImageRef cgImage = CGImageCreate(width,
                                       height,
                                       8,
                                       24,
                                       pict.linesize[0],
                                       colorSpace,
                                       bitmapInfo,
                                       provider,
                                       NULL,
                                       YES,
                                       kCGRenderingIntentDefault);
    CGColorSpaceRelease(colorSpace);
    UIImage *image = [[UIImage alloc]initWithCGImage:cgImage];
    
    CGImageRelease(cgImage);
    CGDataProviderRelease(provider);
    CFRelease(data);
    
    return image;
}
</code></pre>
    <br/>
    对解码后的图像传入UIImageView，即可进行视频播放
    <p>
    </p>
    <p class="p1">
     <span class="s1">
      <img alt="" src="https://img-blog.csdn.net/20160810151039321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
       <br/>
      </img>
     </span>
    </p>
    <br/>
    <p>
     附上之前参考的ffmpeg解码播放的例子：
     <a href="https://github.com/durfu/DFURTSPPlayer" rel="noopener noreferrer" target="_blank">
      ffmpeg解码播放：https://github.com/durfu/DFURTSPPlayer
     </a>
    </p>
    <p>
     另外，欢迎大家加入iOS音视频开发的QQ群：
     <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
      331753091
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f61343131333538363036:2f61727469636c652f64657461696c732f3532313731363334" class_="artid" style="display:none">
 </p>
</div>


