---
layout: post
title: "SciKit-Learn-全面分析分类任务-wine-葡萄酒数据集"
date: 2025-09-11T14:51:37+0800
description: "本文对葡萄酒数据集（178个样本，13个特征，3个类别）进行了7种分类模型的比较分析。通过标准化预处理后，分别测试了K近邻、决策树、SVM、逻辑回归、随机森林、朴素贝叶斯和MLP模型。结果显示，随机森林和朴素贝叶斯表现最佳，准确率达100%；SVM、逻辑回归和MLP准确率为98.15%；K近邻和决策树为96.30%。ROC曲线分析表明各模型对三类葡萄酒均有良好区分能力，其中随机森林和朴素贝叶斯的AUC值达到1.0，展现出最优的分类性能。该研究为葡萄酒品种识别提供了有效的机器学习方法参考。"
keywords: "SciKit-Learn 全面分析分类任务 wine 葡萄酒数据集"
categories: ['未分类']
tags: ['机器学习', '数据集', '分类', 'Svm', 'Python', 'Mlp', 'Learn']
artid: "151577110"
arturl: "https://blog.csdn.net/xchenhao/article/details/151577110"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151577110
    alt: "SciKit-Learn-全面分析分类任务-wine-葡萄酒数据集"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151577110
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151577110
cover: https://bing.ee123.net/img/rand?artid=151577110
image: https://bing.ee123.net/img/rand?artid=151577110
img: https://bing.ee123.net/img/rand?artid=151577110
---



# SciKit-Learn 全面分析分类任务 wine 葡萄酒数据集



### 背景

`wine` 葡萄酒数据集，提供了对三种不同品种的意大利葡萄酒的化学分析结果  
主要特点：

* 数据集规模：总共有 178 个样本
* 特征数量：每个样本有 13 个化学特征，包括酒精、苹果酸、灰分、镁等
* 类别数量：总共有 3 个类别，分别代表三种不同的葡萄酒品种

> ![wine.frame.head](https://i-blog.csdnimg.cn/direct/5aeadf0d6acb4a03919e5206143da03d.png)

### 步骤

1. 加载数据集
2. 拆分训练集、测试集
3. 数据预处理（标准化）
4. 选择模型
5. 模型训练（拟合）
6. 测试模型效果
7. 评估模型

### 分析方法

对数据集使用 7 种分类方法进行分析

1. K 近邻（K-NN）
2. 决策树
3. 支持向量机（SVM）
4. 逻辑回归
5. 随机森林
6. 朴素贝叶斯
7. 多层感知机（MLP）

### 分析结果

#### 不同模型的 ROC 及 AUC

> ![ROC & AUC](https://i-blog.csdnimg.cn/direct/648ca28ddb1d40ec9c89a803079945b9.png)

#### 不同模型效果

```
--- 模型训练与评估 ---

--- 正在训练 K近邻 (K-NN) 模型 ---
K近邻 (K-NN) 模型的准确率: 0.9630
K近邻 (K-NN) 模型的分类报告:
              precision    recall  f1-score   support

     class_0       0.95      1.00      0.97        19
     class_1       1.00      0.90      0.95        21
     class_2       0.93      1.00      0.97        14

    accuracy                           0.96        54
   macro avg       0.96      0.97      0.96        54
weighted avg       0.97      0.96      0.96        54


--- 正在训练 决策树 模型 ---
决策树 模型的准确率: 0.9630
决策树 模型的分类报告:
              precision    recall  f1-score   support

     class_0       0.95      0.95      0.95        19
     class_1       0.95      1.00      0.98        21
     class_2       1.00      0.93      0.96        14

    accuracy                           0.96        54
   macro avg       0.97      0.96      0.96        54
weighted avg       0.96      0.96      0.96        54


--- 正在训练 支持向量机 (SVM) 模型 ---
支持向量机 (SVM) 模型的准确率: 0.9815
支持向量机 (SVM) 模型的分类报告:
              precision    recall  f1-score   support

     class_0       1.00      1.00      1.00        19
     class_1       0.95      1.00      0.98        21
     class_2       1.00      0.93      0.96        14

    accuracy                           0.98        54
   macro avg       0.98      0.98      0.98        54
weighted avg       0.98      0.98      0.98        54


--- 正在训练 逻辑回归 模型 ---
逻辑回归 模型的准确率: 0.9815
逻辑回归 模型的分类报告:
              precision    recall  f1-score   support

     class_0       1.00      1.00      1.00        19
     class_1       1.00      0.95      0.98        21
     class_2       0.93      1.00      0.97        14

    accuracy                           0.98        54
   macro avg       0.98      0.98      0.98        54
weighted avg       0.98      0.98      0.98        54


--- 正在训练 随机森林 模型 ---
随机森林 模型的准确率: 1.0000
随机森林 模型的分类报告:
              precision    recall  f1-score   support

     class_0       1.00      1.00      1.00        19
     class_1       1.00      1.00      1.00        21
     class_2       1.00      1.00      1.00        14

    accuracy                           1.00        54
   macro avg       1.00      1.00      1.00        54
weighted avg       1.00      1.00      1.00        54


--- 正在训练 朴素贝叶斯 模型 ---
朴素贝叶斯 模型的准确率: 1.0000
朴素贝叶斯 模型的分类报告:
              precision    recall  f1-score   support

     class_0       1.00      1.00      1.00        19
     class_1       1.00      1.00      1.00        21
     class_2       1.00      1.00      1.00        14

    accuracy                           1.00        54
   macro avg       1.00      1.00      1.00        54
weighted avg       1.00      1.00      1.00        54


--- 正在训练 多层感知器 (MLP) 模型 ---
多层感知器 (MLP) 模型的准确率: 0.9815
多层感知器 (MLP) 模型的分类报告:
              precision    recall  f1-score   support

     class_0       1.00      1.00      1.00        19
     class_1       1.00      0.95      0.98        21
     class_2       0.93      1.00      0.97        14

    accuracy                           0.98        54
   macro avg       0.98      0.98      0.98        54
weighted avg       0.98      0.98      0.98        54

```

### 代码

```python
from sklearn.datasets import load_wine

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.neural_network import MLPClassifier

from sklearn.metrics import accuracy_score, classification_report, roc_curve, auc
from sklearn.preprocessing import label_binarize

import matplotlib.pyplot as plt
import numpy as np

# 设置 Matplotlib 字体以正确显示中文
plt.rcParams['font.sans-serif'] = ['SimHei', 'WenQuanYi Zen Hei', 'STHeiti', 'Arial Unicode MS']
# 解决保存图像时负号'-'显示为方块的问题
plt.rcParams['axes.unicode_minus'] = False  

def perform_wine_analysis():
    """
    使用 scikit-learn 对葡萄酒数据集进行全面的分析。
    该函数包含数据加载、预处理、模型训练、评估和 ROC/AUC 可视化。
    """
    print("--- 正在加载葡萄酒数据集 ---")
    # 加载葡萄酒数据集
    wine = load_wine()
    
    # 获取数据特征和目标标签
    X = wine.data
    y = wine.target
    target_names = wine.target_names

    print("\n--- 数据集概览 ---")
    print(f"数据形状: {X.shape}")
    print(f"目标名称: {target_names}")

    # 将数据集划分为训练集和测试集
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    print("\n--- 数据划分结果 ---")
    print(f"训练集形状: {X_train.shape}")
    print(f"测试集形状: {X_test.shape}")
    
    # 数据标准化
    print("\n--- 正在对数据进行标准化处理 ---")
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)
    
    # 定义并训练多个分类器模型
    models = {
        "K近邻 (K-NN)": KNeighborsClassifier(n_neighbors=5),
        "决策树": DecisionTreeClassifier(random_state=42),
        "支持向量机 (SVM)": SVC(kernel='rbf', C=1.0, random_state=42, probability=True),
        "逻辑回归": LogisticRegression(random_state=42, max_iter=10000),
        "随机森林": RandomForestClassifier(random_state=42),
        "朴素贝叶斯": GaussianNB(),
        "多层感知器 (MLP)": MLPClassifier(random_state=42, max_iter=10000)
    }

    print("\n--- 模型训练与评估 ---")
    for name, model in models.items():
        print(f"\n--- 正在训练 {name} 模型 ---")
        model.fit(X_train_scaled, y_train)
        y_pred = model.predict(X_test_scaled)
        accuracy = accuracy_score(y_test, y_pred)
        report = classification_report(y_test, y_pred, target_names=target_names)
        print(f"{name} 模型的准确率: {accuracy:.4f}")
        print(f"{name} 模型的分类报告:\n{report}")

    print("\n--- ROC 曲线和 AUC 对比 ---")
    num_models = len(models)
    cols = 3
    rows = (num_models + cols - 1) // cols
    fig, axes = plt.subplots(rows, cols, figsize=(18, 6 * rows))
    axes = axes.flatten()
    
    # 将多分类标签二值化，用于 ROC 曲线计算
    y_test_bin = label_binarize(y_test, classes=np.arange(len(target_names)))

    for i, (name, model) in enumerate(models.items()):
        ax = axes[i]
        
        # 获取预测概率
        if hasattr(model, "predict_proba"):
            y_score = model.predict_proba(X_test_scaled)
        else:
            y_score = model.decision_function(X_test_scaled)
        
        # 计算每个类别的 ROC 曲线和 AUC
        fpr = dict()
        tpr = dict()
        roc_auc = dict()
        for j in range(len(target_names)):
            fpr[j], tpr[j], _ = roc_curve(y_test_bin[:, j], y_score[:, j])
            roc_auc[j] = auc(fpr[j], tpr[j])
        
        # 计算微平均 ROC 曲线和 AUC
        fpr["micro"], tpr["micro"], _ = roc_curve(y_test_bin.ravel(), y_score.ravel())
        roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])
        
        # 绘制所有类别的 ROC 曲线并填充
        for j in range(len(target_names)):
            ax.plot(fpr[j], tpr[j], label=f'类别 {target_names[j]} (AUC = {roc_auc[j]:.2f})', alpha=0.7)
            ax.fill_between(fpr[j], tpr[j], alpha=0.1)
        
        # 绘制微平均 ROC 曲线
        ax.plot(fpr["micro"], tpr["micro"], label=f'微平均 (AUC = {roc_auc["micro"]:.2f})',
                color='deeppink', linestyle=':', linewidth=4)
        
        # 绘制对角线 (随机猜测)
        ax.plot([0, 1], [0, 1], 'k--', lw=2)
        
        # 设置图表属性
        ax.set_xlim([0.0, 1.0])
        ax.set_ylim([0.0, 1.05])
        ax.set_xlabel('假正率 (FPR)')
        ax.set_ylabel('真正率 (TPR)')
        ax.set_title(f'{name} - ROC 曲线')
        ax.legend(loc="lower right", fontsize='small')
        ax.grid(True)
    
    # 隐藏未使用的子图边框
    for j in range(num_models, len(axes)):
        axes[j].axis('off')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    perform_wine_analysis()

```



