---
layout: post
title: "stdlist的模拟实现"
date: 2025-03-12 12:43:02 +0800
description: "对std::list的模拟实现，详细介绍了list迭代器的特点及其独特之处，帮助读者快速了解list的底层实现逻辑，能够更好的使用list完成程序。"
keywords: "std::list的模拟实现"
categories: ['未分类']
tags: ['算法', '数据结构', '排序算法', 'List', 'C', 'C']
artid: "145996338"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145996338
    alt: "stdlist的模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145996338
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145996338
cover: https://bing.ee123.net/img/rand?artid=145996338
image: https://bing.ee123.net/img/rand?artid=145996338
img: https://bing.ee123.net/img/rand?artid=145996338
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     std::list的模拟实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     在C++中list实际上是一个双向带头循环链表，所以list是不支持随机访问的。
     <span style="background-color:#ff9900">
      list的迭代器类型是双向迭代器，与string和vector不同的是，list不是简单的指针，list的迭代器是类。
     </span>
     此处本文将会详细讲解。
    </p>
    <hr/>
    <h2 id="list%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" name="list%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" style="text-align:center">
     list的成员变量
    </h2>
    <p>
     list的成员变量是指向哨兵位节点的指针，通过定义ListNode类来实现节点的定义及使用。注意：此处使用struct来声明ListNode而不用class的原因是：
     <span style="background-color:#ff9900">
      struct默认权限是public而private的默认权限是private，直接用struct可以让类外直接访问。
     </span>
    </p>
    <pre><code class="language-cpp">template&lt;class T&gt;
struct ListNode
{
	//初始化节点
	ListNode(const T&amp; val=T())
		:_val(val)
		,_next(this)
		,_prev(this)
	{}

	T _val;
	ListNode&lt;T&gt;* _next;
	ListNode&lt;T&gt;* _prev;
};


template&lt;class T&gt;
class list
{
public:
	typedef ListNode&lt;T&gt; ListNode;
	
private:
	ListNode* _phead;
};</code></pre>
    <hr/>
    <h2 id="list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" name="list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" style="text-align:center">
     list的迭代器
    </h2>
    <p>
     list底层是节点所以list是不支持随机访问的，因此不能简单的对指针++或--来实现对迭代器的左移和右移。
     <span style="color:null">
      <span style="background-color:#ff9900">
       list迭代器底层也是一个类，这个类用来存放当前节点。重载++，--等等迭代器的基本功能。
      </span>
     </span>
    </p>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89">
     迭代器的定义
    </h3>
    <p>
     此处的模板并不完善，后面还要添加其他模板。
    </p>
    <pre><code class="language-cpp">//创建list迭代器
template&lt;class T&gt;
struct list_iterator
{
	typedef ListNode&lt;T&gt; ListNode;
	typedef list_iterator&lt;T&gt; list_iterator;

	//构造函数
	list_iterator(ListNode* node = nullptr)
		:_node(node)
	{}


	ListNode* _node;
};</code></pre>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8*%E5%92%8C-%3E" name="%E8%BF%AD%E4%BB%A3%E5%99%A8*%E5%92%8C-%3E">
     迭代器*和-&gt;
    </h3>
    <pre><code class="language-cpp">//重载解引用*
T&amp; operator*()
{
	return _node-&gt;_val;
}
//重载-&gt;
T* operator-&gt;()
{
	return &amp;(operator*);  //此处直接调用*运算符重载来实现取地址
}</code></pre>
    <p>
     <span style="background-color:null">
      注意：
     </span>
     <span style="background-color:#ff9900">
      此处需要考虑只有读取权限的const_iterator不能对解引用的数据进行修改，所以再使用T&amp;和T*是明显不够的。
     </span>
    </p>
    <p>
     <span style="background-color:null">
      因此需要添加模板参数来实现const_iterator。
     </span>
    </p>
    <pre><code class="language-cpp">template&lt;class T,class Ref ,class Ptr&gt;
//用ref来代替T&amp;和const T&amp;，同理用Ptr来代替T*和const T*
typedef list_iterator&lt;T,Ref,Ptr&gt; Self;

//重载解引用*
Ref operator*()
{
	return _node-&gt;_val;
}

//重载-&gt;
Ptr operator-&gt;()
{
	return &amp;(operator*);  //此处直接调用*运算符重载来实现取地址
}</code></pre>
    <p>
     在list的类中iterator和const_iterator的声明如下；
    </p>
    <pre><code class="language-cpp">typedef list_iterator&lt;T, T&amp;, T*&gt; iterator;
typedef list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;</code></pre>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%2B%2B%E5%92%8C--" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%2B%2B%E5%92%8C--">
     迭代器的++和--
    </h3>
    <pre><code class="language-cpp">typedef list_iterator&lt;T,Ref,Ptr&gt; Self;

//重载++,非const类型
Self operator++()
{
	_node = _node-&gt;_next;
	return *this;
}
//重载--，非const类型
Self operator--()
{
	_node = _node-&gt;_prev;
	return *this;
}

//重载++,const类型
Self operator++()const
{
	_node = _node-&gt;_next;
		return *this;
}
//重载--，const类型
Self operator--()const
{
	_node = _node-&gt;_prev;
		return *this;
}</code></pre>
    <p>
     此处前置++和--就不展示了。
    </p>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%3D%3D%E5%92%8C!%3D" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%3D%3D%E5%92%8C!%3D">
     迭代器的==和!=
    </h3>
    <pre><code class="language-cpp">//重载==
bool operator==(const Self&amp; it)
{
	return _node == it._node;
}
//重载!=
bool operator!=(const Self&amp; it)
{
	return !(*this==it);  //此处直接调用==
}</code></pre>
    <hr/>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB" style="text-align:center">
     迭代器代码汇总
    </h3>
    <pre><code class="language-cpp">//创建list迭代器
template&lt;class T,class Ref ,class Ptr&gt;
//用ref来代替T&amp;和const T&amp;，同理用Ptr来代替T*和const T*
struct list_iterator
{
	typedef ListNode&lt;T&gt; ListNode;
	typedef list_iterator&lt;T,Ref,Ptr&gt; Self;
	//构造函数
	list_iterator(ListNode* node = nullptr)
		:_node(node)
	{}
	//重载++,非const类型
	Self operator++()
	{
		_node = _node-&gt;_next;
		return *this;
	}
	//重载--，非const类型
	Self operator--()
	{
		_node = _node-&gt;_prev;
		return *this;
	}

	//重载++,const类型
	Self operator++()const
	{
		_node = _node-&gt;_next;
			return *this;
	}
	//重载--，const类型
	Self operator--()const
	{
		_node = _node-&gt;_prev;
			return *this;
	}

	//重载解引用*
	Ref operator*()
	{
		return _node-&gt;_val;
	}
	//重载-&gt;
	Ptr operator-&gt;()
	{
		return &amp;(operator*);  //此处直接调用*运算符重载来实现取地址
	}

	//重载==
	bool operator==(const Self&amp; it)
	{
		return _node == it._node;
	}
	//重载!=
	bool operator!=(const Self&amp; it)
	{
		return !(*this==it);  //此处直接调用==
	}
	ListNode* _node;
};</code></pre>
    <hr/>
    <h2 id="list%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" name="list%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" style="text-align:center">
     list的成员函数
    </h2>
    <pre><code class="language-cpp">template&lt;class T&gt;
class list
{
public:
	typedef ListNode&lt;T&gt; ListNode;
	typedef list_iterator&lt;T, T&amp;, T*&gt; iterator;
	typedef list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;

private:
	ListNode* _phead;
};</code></pre>
    <hr/>
    <h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84begin%E5%92%8Cend" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84begin%E5%92%8Cend" style="text-align:center">
     迭代器的begin和end
    </h3>
    <pre><code class="language-cpp">//begin函数，非const类型
iterator begin()
{
	return _phead-&gt;_next;  //此处使用了隐式类型转化，将ListNode*转化为了iterator
}
//end函数，非const类型
iterator end()
{
	return _phead;
}
//begin函数，const类型
const_iterator begin()const
{
	return _phead-&gt;_next;  
}
//end函数，const类型
const_iterator end()const
{
	return _phead;
}</code></pre>
    <hr/>
    <h3 id="%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" name="%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" style="text-align:center">
     构造函数
    </h3>
    <h4 id="%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0" name="%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0">
     无参构造
    </h4>
    <pre><code class="language-cpp">//构造函数，无参初始化
list()
	:_phead(new ListNode)   //此处需要创建哨兵位，交给ListNode的构造函数
{}</code></pre>
    <h4 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9E%84%E9%80%A0" name="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9E%84%E9%80%A0">
     迭代器构造
    </h4>
    <p>
     此处偷懒直接调用了push_back尾插函数。
    </p>
    <pre><code class="language-cpp">//迭代器构造函数
template&lt;class T&gt;
list(const T* first, const T* last)
	: _phead(new ListNode)  //还是创建哨兵位
{
	while (first != last)
	{
		push_back(*first);
		++first;
	}
}</code></pre>
    <h4 id="n%E7%9A%84val%E6%9E%84%E9%80%A0" name="n%E7%9A%84val%E6%9E%84%E9%80%A0">
     n的val构造
    </h4>
    <pre><code class="language-cpp">//用n个val构造
list(size_t n, const T&amp; val)
	:_phead(new ListNode)
{
	while (n--)
	{
		push_back(val);
	}
}</code></pre>
    <h4 id="%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0" name="%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">
     拷贝构造
    </h4>
    <pre><code class="language-cpp">//拷贝构造
list(const list&amp; l)
	: _phead(new ListNode)
{
	for (auto&amp; e : l)  //范围for遍历原链表
	{
		push_back(e);
	}
}</code></pre>
    <hr/>
    <h3 id="%E5%B0%BE%E6%8F%92%E5%92%8C%E5%A4%B4%E6%8F%92" name="%E5%B0%BE%E6%8F%92%E5%92%8C%E5%A4%B4%E6%8F%92">
     尾插和头插
    </h3>
    <p>
     尾插即创建新节点，对原有节点的指针进行修改。
    </p>
    <pre><code class="language-cpp">//尾插
void push_back(const T&amp; val)
{
	ListNode* newnode = new ListNode(val);
	newnode-&gt;_next = _phead;
	newnode-&gt;_prev = _phead-&gt;_prev;

	_phead-&gt;_prev-&gt;_next = newnode;
	_phead-&gt;_prev = newnode;
}

//头插
void push_front(const T&amp; val)
{
	ListNode* newnode = new ListNode(val);
	newnode-&gt;_next = _phead-&gt;_next;
	newnode-&gt;_prev = _phead;

	_phead-&gt;_next-&gt;_prev = newnode;
	_phead-&gt;_next = newnode;
}</code></pre>
    <hr/>
    <h3 id="%E5%B0%BE%E5%88%A0%E5%92%8C%E5%A4%B4%E5%88%A0" name="%E5%B0%BE%E5%88%A0%E5%92%8C%E5%A4%B4%E5%88%A0">
     尾删和头删
    </h3>
    <p>
     删除就是记录需要删除的节点位置将其前后节点指向改变即可。
    </p>
    <pre><code class="language-cpp">//尾删
void pop_back()
{
	ListNode* del = _phead-&gt;_prev;
	del-&gt;_prev-&gt;_next = _phead;
	_phead-&gt;_prev = del-&gt;_prev;

	delete[] del;
}
//头删
void pop_front()
{
	ListNode* del = _phead-&gt;_next;
	del-&gt;_next-&gt;_prev = _phead;
	_phead-&gt;_next = del-&gt;_next;

	delete[] del;
}</code></pre>
    <hr/>
    <h3 id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4" name="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4">
     指定位置插入，删除
    </h3>
    <p>
     通过迭代器实现指定位置的插入和删除。指定位置插入会返回插入节点的迭代器；指定位置删除会返回删除位置的下一个迭代器。
    </p>
    <pre><code class="language-cpp">//指定位置之前插入
iterator insert(iterator it, const T&amp; val)
{
	ListNode* newnode = new ListNode(val);
	ListNode* cur = it._node;

	newnode-&gt;_next = cur;
	newnode-&gt;_prev = cur-&gt;_prev;

	cur-&gt;_prev-&gt;_next = newnode;
	cur-&gt;_prev = newnode;

	return newnode;
}
//指定位置删除
iterator erase(iterator it)
{
	ListNode* del = it._node;
	ListNode* cur = del-&gt;_next;

	del-&gt;_prev-&gt;_next = cur;
	cur-&gt;_prev = del-&gt;_prev;

	return cur;
}</code></pre>
    <hr/>
    <h3 id="swap%E4%BA%A4%E6%8D%A2" name="swap%E4%BA%A4%E6%8D%A2" style="text-align:center">
     swap交换
    </h3>
    <p>
     <span style="background-color:#ff9900">
      此处为了实现swap(l1,l2)，而不是l1.swap(l2)，需要使用友元函数而不是成员函数。
     </span>
    </p>
    <p>
     <span style="background-color:#4da8ee">
      注意：编译器在解析友元函数的时候无法正确的匹配外部声明的模板函数，此时就需要在声明的时候也加上模板参数。
     </span>
    </p>
    <pre><code class="language-cpp">template&lt;class T&gt;
friend void swap(list&lt;T&gt;&amp; l1, list&lt;T&gt;&amp; l2);


template&lt;class T&gt;
void swap(list&lt;T&gt;&amp; l1, list&lt;T&gt;&amp; l2)
{
	std::swap(l1._phead, l2._phead);
}</code></pre>
    <hr/>
    <h3 id="clear" name="clear">
     clear
    </h3>
    <p>
     list::clear函数的作用是清空有效节点，只保留哨兵位。
     <span style="background-color:#ff9900">
      注意：清空节点之后还要将哨兵位指向本身。
     </span>
    </p>
    <pre><code class="language-cpp">void clear()
{
	ListNode* cur = _phead-&gt;_next;
	while (cur != _phead)
	{
		ListNode* del = cur;
		cur = cur-&gt;_next;
		delete[] del;
	}
	//清空数据之后，将哨兵位指向哨兵位
	_phead-&gt;_next = _phead;
	_phead-&gt;_prev = _phead;
}</code></pre>
    <hr/>
    <h3 id="%E8%BF%94%E5%9B%9E%E9%A6%96%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E8%8A%82%E7%82%B9" name="%E8%BF%94%E5%9B%9E%E9%A6%96%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E8%8A%82%E7%82%B9">
     返回首节点和尾节点
    </h3>
    <p>
     返回首尾节点的值。
    </p>
    <pre><code class="language-cpp">//非const类型
T&amp; front()
{
	return _phead-&gt;_next-&gt;_val;
}
T&amp; back()
{
	return _phead-&gt;_prev-&gt;_val;
}
//const类型
const T&amp; front()const
{
	return _phead-&gt;_next-&gt;_val;
}
const T&amp; back()const
{
	return _phead-&gt;_prev-&gt;_val;
}</code></pre>
    <hr/>
    <h3 id="%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6" name="%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6">
     返回链表长度
    </h3>
    <pre><code class="language-cpp">//返回链表长度
size_t size()
{
	ListNode* cur = _phead-&gt;_next;
	size_t sz = 0;
	while (cur != _phead)
	{
		cur = cur-&gt;_next;
		++sz;
	}
	return sz;
}</code></pre>
    <h3 id="%E5%88%A4%E7%A9%BA" name="%E5%88%A4%E7%A9%BA" style="background-color:transparent">
     判空
    </h3>
    <pre><code class="language-cpp">//链表是否为空
bool empty()
{
	return _phead == _phead-&gt;_next;
}</code></pre>
    <hr/>
    <h3 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" name="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" style="background-color:transparent">
     赋值运算符重载
    </h3>
    <p>
     <span style="background-color:#ff9900">
      进行赋值的是否需要先将原链表的所有数据清空。
     </span>
    </p>
    <pre><code class="language-cpp">//赋值运算符重载
list&amp; operator=(const list&amp; l)
{
	clear();
	ListNode* cur = l._phead-&gt;_next;
	while (cur != l._phead)
	{
		push_back(cur-&gt;_val);
		cur = cur-&gt;_next;
	}
	return *this;
}</code></pre>
    <h2 id="%E8%A1%A5%E5%85%85%E7%BB%83%E4%B9%A0" name="%E8%A1%A5%E5%85%85%E7%BB%83%E4%B9%A0" style="text-align:center">
    </h2>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38373934343837382f:61727469636c652f64657461696c732f313435393936333338" class_="artid" style="display:none">
 </p>
</div>


