---
layout: post
title: "JavaScript性能优化的12种方式"
date: 2025-03-16 11:38:59 +0800
description: "对JavaScript代码进行优化和压缩，去除不必要的空格、注释和代码块，缩小文件体积，加快加载 通过合理的算法和数据处理方式优化代码： 假设我们需要计算一个数组中所有元素的总和，我们可。对于涉及大量计算或耗时操作的任务，可以将其放入Web Worker中，在后台线程中运行，避免阻塞主线程，提高页面响应性能。将事件监听器绑定到父元素，利用事件冒泡机制来处理子元素的事件，可以减少事件处理函数的数量，提高性能。延迟加载非关键的资源（如图片、脚本等），在用户需要时再进行加载，减少页面初始加载时间，提高用户体验。"
keywords: "JavaScript性能优化的12种方式"
categories: ['前端技术']
tags: ['性能优化', '开发语言', 'Javascript']
artid: "146292546"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146292546
    alt: "JavaScript性能优化的12种方式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146292546
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146292546
cover: https://bing.ee123.net/img/rand?artid=146292546
image: https://bing.ee123.net/img/rand?artid=146292546
img: https://bing.ee123.net/img/rand?artid=146292546
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JavaScript性能优化的12种方式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     当涉及到JavaScript性能优化时，有几个关键的方面需要考虑。下面是一些常见的JavaScript性能优化技巧和实践：
    </p>
    <p>
    </p>
    <h4 id="6u15g" name="%E5%87%8F%E5%B0%91DOM%E6%93%8D%E4%BD%9C%EF%BC%9A">
     <strong>
      减少DOM操作：
     </strong>
    </h4>
    <p>
     频繁的DOM操作会导致重绘和重新布局，影响性能。建议将多个DOM操作合并为一个操作，或者使用DocumentFragment来批量插入DOM元素。
    </p>
    <pre><code class="hljs">// 不推荐写法（频繁操作DOM）
const container = document.getElementById('container');
for (let i = 0; i &lt; 1000; i++) {
  const element = document.createElement('div');
  element.textContent = 'Item ' + i;
  container.appendChild(element);
}

// 推荐写法（合并DOM操作）
const container = document.getElementById('container');
const fragment = document.createDocumentFragment();
for (let i = 0; i &lt; 1000; i++) {
  const element = document.createElement('div');
  element.textContent = 'Item ' + i;
  fragment.appendChild(element);
}
container.appendChild(fragment);
</code></pre>
    <h4 id="3tv6v" name="%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%9A">
     <strong>
      避免不必要的重绘和回流：
     </strong>
    </h4>
    <p>
     重绘和回流会消耗大量的计算资源。尽量避免在循环中修改样式属性或获取布局信息。如果需要对多个样式进行修改，可以使用CSS的class切换。
    </p>
    <pre><code class="hljs">// 不推荐写法（频繁触发重绘和回流）
const element = document.getElementById('myElement');
for (let i = 0; i &lt; 1000; i++) {
  element.style.left = i + 'px';
  element.style.top = i + 'px';
}

// 推荐写法（使用CSS class）
const element = document.getElementById('myElement');
element.classList.add('move');

// CSS样式：
// .move {
//   left: 1000px;
//   top: 1000px;
// }
</code></pre>
    <h4 id="6dfrt" name="%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9A">
     <strong>
      使用事件委托：
     </strong>
    </h4>
    <p>
     将事件监听器绑定到父元素，利用事件冒泡机制来处理子元素的事件，可以减少事件处理函数的数量，提高性能。
    </p>
    <pre><code class="hljs">// 不推荐写法（为每个子元素添加事件监听器）
const items = document.querySelectorAll('.item');
items.forEach((item) =&gt; {
  item.addEventListener('click', () =&gt; {
    // 处理点击事件
  });
});

// 推荐写法（使用事件委托）
const container = document.getElementById('container');
container.addEventListener('click', (event) =&gt; {
  if (event.target.classList.contains('item')) {
    // 处理点击事件
  }
});
</code></pre>
    <h4 id="a84mv" name="%E4%BD%BF%E7%94%A8%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%EF%BC%9A">
     <strong>
      使用节流与防抖：
     </strong>
    </h4>
    <p>
     在处理一些高频触发的事件（如resize、scroll）时，使用节流（throttling）和防抖（debouncing）可以限制事件处理函数的执行频率，提高性能。
    </p>
    <pre><code class="hljs">// 节流
function throttle(func, delay) {
  let timerId;
  return function (...args) {
    if (!timerId) {
      timerId = setTimeout(() =&gt; {
        func(...args);
        timerId = null;
      }, delay);
    }
  };
}


// 防抖
function debounce(func, delay) {
  let timerId;
  return function (...args) {
    clearTimeout(timerId);
    timerId = setTimeout(() =&gt; {
      func(...args);
    }, delay);
  };
}

// 使用节流处理scroll事件
window.addEventListener('scroll', throttle(handleScroll, 200));

// 使用防抖处理输入事件
input.addEventListener('input', debounce(handleInput, 300));
</code></pre>
    <h4 id="82c6b" name="%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9A">
     <strong>
      减少网络请求：
     </strong>
    </h4>
    <p>
     减少HTTP请求次数可以显著提高页面加载速度。可以将多个脚本或样式表合并为单个文件，使用CSS Sprites技术来减少图片请求，使用CDN加速等。 这些是一些常见的JavaScript性能优化技巧和实践。根据实际情况，你可以选择适合你项目的优化策略来提高JavaScript代码的性能。记住，在编写优化代码之前，先进行性能测试和分析以确定哪些部分需要优化。
    </p>
    <p>
     请注意，优化性能不仅仅限于JavaScript代码本身，也需要考虑其他因素，如网络延迟、服务器响应时间、缓存策略等。 当涉及到JavaScript性能优化时，还有几个关键的方面需要考虑。下面是一些常见的JavaScript性能优化技巧和实践：
    </p>
    <h4 id="qf0t" name="%E4%BD%BF%E7%94%A8Web-Workers%EF%BC%9A">
     <strong>
      使用Web Workers：
     </strong>
    </h4>
    <p>
     对于涉及大量计算或耗时操作的任务，可以将其放入Web Worker中，在后台线程中运行，避免阻塞主线程，提高页面响应性能。
    </p>
    <pre><code class="hljs">// 主线程代码
const worker = new Worker('worker.js');
worker.postMessage('Hello from main thread!');
worker.onmessage = function (event) {
  const result = event.data;
  // 处理Worker返回的结果
};

// worker.js代码
self.onmessage = function (event) {
  const message = event.data;
  // 执行计算或耗时操作
  const result = doSomeWork(message);
  self.postMessage(result);
};
</code></pre>
    <h4 id="12i0o" name="%E6%87%92%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%EF%BC%9A">
     <strong>
      懒加载资源：
     </strong>
    </h4>
    <p>
     延迟加载非关键的资源（如图片、脚本等），在用户需要时再进行加载，减少页面初始加载时间，提高用户体验。
    </p>
    <pre><code class="hljs">&lt;!-- 图片懒加载 --&gt;
&lt;img data-src="image.jpg" class="lazyload" alt="Lazy-loaded Image"&gt;

&lt;script&gt;
  // 使用Intersection Observer检测元素是否进入视口
  const lazyloadImages = document.querySelectorAll('.lazyload');
  const observer = new IntersectionObserver(function (entries, observer) {
    entries.forEach(function (entry) {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        observer.unobserve(img);
      }
    });
  });
  lazyloadImages.forEach(function (img) {
    observer.observe(img);
  });
&lt;/script&gt;
</code></pre>
    <h4 id="frer4" name="%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9A">
     <strong>
      使用缓存：
     </strong>
    </h4>
    <p>
     合理利用浏览器缓存机制，减少不必要的请求。设置正确的Cache-Control和Expires头信息，让浏览器缓存静态资源。
    </p>
    <pre><code class="hljs">//设置缓存过期时间为1年（根据实际情况调整）
&lt;IfModule mod_expires.c&gt;
  ExpiresActive on
  ExpiresDefault "access plus 1 year"
&lt;/IfModule&gt;
</code></pre>
    <h4 id="c9aj7" name="%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E5%8E%8B%E7%BC%A9%EF%BC%9A">
     <strong>
      代码优化和压缩：
     </strong>
    </h4>
    <p>
     对JavaScript代码进行优化和压缩，去除不必要的空格、注释和代码块，缩小文件体积，加快加载 通过合理的算法和数据处理方式优化代码： 假设我们需要计算一个数组中所有元素的总和，我们可
    </p>
    <pre><code class="hljs">以使用reduce方法来避免显式的循环。
javascript
const numbers = [1, 2, 3, 4, 5];

// 使用 reduce 方法计算数组元素的总和
const sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0);

console.log(sum); // 输出15
</code></pre>
    <h4 id="2l15l" name="%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%90%88%E5%B9%B6JavaScript%E6%96%87%E4%BB%B6%EF%BC%9A">
     <strong>
      压缩和合并JavaScript文件：
     </strong>
    </h4>
    <p>
     利用压缩工具（如UglifyJS）对JavaScript文件进行压缩，以减小文件大小。此外，将多个JavaScript文件合并成一个文件可以减少HTTP请求次数。
    </p>
    <h4 id="a1ue1" name="%E4%BD%BF%E7%94%A8Web-Workers%EF%BC%9A">
     <strong>
      使用Web Workers：
     </strong>
    </h4>
    <p>
     使用Web Workers可以将大量计算或耗时操作转移到后台线程中进行，避免阻塞主线程。下面是一个简单的Web Worker示例：
    </p>
    <pre><code class="hljs">// 在主线程中创建Web Worker
const worker = new Worker('worker.js');

// 向Web Worker发送消息
worker.postMessage({ data: 'some data' });

// 接收来自Web Worker的消息
worker.onmessage = function(event) {
  console.log(event.data);
};
</code></pre>
    <p>
     在Web Worker的代码文件worker.js中可以执行复杂的计算或耗时操作，并通过postMessage方法将结果发送回主线程。
    </p>
    <h4 id="3b2kk" name="%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%BC%93%E5%AD%98%EF%BC%9A">
     <strong>
      使用事件缓存：
     </strong>
    </h4>
    <p>
     对于频繁触发的事件，可以使用事件缓存来减少事件处理函数的调用次数。下面是一个示例：
    </p>
    <pre><code class="hljs">// 定义事件缓存标志位
let isProcessing = false;

// 监听滚动事件
window.addEventListener('scroll', function() {
  // 如果正在处理中，则跳过本次事件
  if (isProcessing) return;

  // 设置处理中标志位
  isProcessing = true;

  // 执行滚动相关操作

  // 在合适的时机重置处理中标志位
  setTimeout(function() {
    isProcessing = false;
  }, 100);
});
</code></pre>
    <p>
     通过在处理事件前设置标志位，并在合适的时机重置标志位，可以防止事件处理函数被频繁调用。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f6c7766333131353834312f:61727469636c652f64657461696c732f313436323932353436" class_="artid" style="display:none">
 </p>
</div>


