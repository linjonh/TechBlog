---
layout: post
title: "STL-begin,end-end最后一个元素的后一个哨兵"
date: 2025-03-14 16:25:37 +0800
description: "note"
keywords: "STL [begin,end) | end()最后一个元素的后一个（哨兵）"
categories: ['Stl', 'C']
tags: ['算法', '开发语言', 'C']
artid: "146260528"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146260528
    alt: "STL-begin,end-end最后一个元素的后一个哨兵"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146260528
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146260528
cover: https://bing.ee123.net/img/rand?artid=146260528
image: https://bing.ee123.net/img/rand?artid=146260528
img: https://bing.ee123.net/img/rand?artid=146260528
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     STL [begin,end) | end()最后一个元素的后一个（哨兵）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
     <img alt="" height="104" src="https://i-blog.csdnimg.cn/direct/ca65faf956184078888fb08cff341559.png" width="865"/>
    </p>
    <p>
     在 C++ STL 中，
     <code>
      包前不包后
     </code>
     是指迭代器/指针范围采用
     <strong>
      左闭右开
     </strong>
     的数学区间表示方式
     <code>
      [begin, end)
     </code>
     ，即包含起始位置但不包含结束位置。这与
     <code>
      arr.end()
     </code>
     的指针特性密切相关，具体可通过以下代码示例理解：
    </p>
    <hr id="UD7sR"/>
    <h4 id="HvI6j" name="HvI6j">
     一、包前不包后的含义
    </h4>
    <p id="u28daecad">
     假设我们有一个
     <code>
      vector&lt;int&gt; arr = {5,3,7,1};
     </code>
     ：
    </p>
    <pre id="bwKaA"><code>sort(arr.begin(), arr.begin()+2); // 对前两个元素排序（索引 0~1）</code></pre>
    <p id="uf441c118">
     此时排序范围是
     <code>
      arr[0]
     </code>
     和
     <code>
      arr[1]
     </code>
     ，而
     <strong>
      <code>
       <span style="background-color:#f9eda6">
        arr.begin()+2
       </span>
      </code>
      <span style="background-color:#f9eda6">
       指向的
      </span>
      <code>
       <span style="background-color:#f9eda6">
        arr[2]
       </span>
      </code>
      <span style="background-color:#f9eda6">
       不参与排序，这就是
       <span style="color:#fe2c24">
        「包前不包后」
       </span>
       的体现。
      </span>
     </strong>
    </p>
    <hr id="XEW1a"/>
    <h4 id="qd1ER" name="qd1ER">
     二、arr.end() 的指向
    </h4>
    <p id="u1fa50576">
     <code>
      <span style="background-color:#f9eda6">
       arr.end()
      </span>
     </code>
     <span style="background-color:#f9eda6">
     </span>
     <strong>
      <span style="background-color:#f9eda6">
       指向容器最后一个
       <span style="color:#fe2c24">
        有效元素的下一个位置
       </span>
      </span>
     </strong>
     <span style="background-color:#f9eda6">
      （类似于哨兵位）
     </span>
     ，而非最后一个元素本身。例如：
    </p>
    <pre id="LVKpx"><code>vector&lt;int&gt; arr = {5,3,7,1};
auto it = arr.end();  // it 指向 arr[4]（虚拟位置）</code></pre>
    <p id="u88e6cb08">
     通过遍历可以验证：
    </p>
    <pre id="jQCUg"><code>for (auto p = arr.begin(); p != arr.end(); ++p) {
    cout &lt;&lt; *p &lt;&lt; " "; // 输出 5 3 7 1
}</code></pre>
    <p id="u5c2d551b">
     循环会在
     <code>
      p == arr.end()
     </code>
     时终止，因此不会访问越界内存。
    </p>
    <hr id="mXlUj"/>
    <h4 id="XwHw2" name="XwHw2">
     三、代码示例：排序与反转
    </h4>
    <pre id="Ae8Vg"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    vector&lt;int&gt; arr = {5,3,7,1};
    vector&lt;int&gt; arr2 = {9,2,4};
    
    // 整体交换
    arr.swap(arr2);  // 现在 arr={9,2,4}, arr2={5,3,7,1} [7]
    
    // 排序（范围包前不包后）
    sort(arr.begin(), arr.end());  // 排序后 arr={2,4,9}
    for (auto x : arr) cout &lt;&lt; x &lt;&lt; " "; // 输出 2 4 9
    
    // 反转（范围同样是[begin, end)）
    reverse(arr.begin(), arr.end()); // 反转后 arr={9,4,2}
    return 0;
}</code></pre>
    <hr id="Hq21j"/>
    <h4 id="YgZv7" name="YgZv7">
     四、关键总结
    </h4>
    <table id="jj0Hd">
     <tbody>
      <tr>
       <td>
        <p id="uc085675f">
         概念
        </p>
       </td>
       <td>
        <p id="uec5f5167">
         说明
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u91129872">
         <strong>
          包前不包后
         </strong>
        </p>
       </td>
       <td>
        <p id="u86b796a0">
         操作区间为
         <code>
          [begin, end)
         </code>
         ，确保不越界且逻辑统一
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="u30339b1f">
         <strong>
          arr.end() 指向
         </strong>
        </p>
       </td>
       <td>
        <p id="u48e77b3a">
         容器末尾的「虚拟哨兵位」，用于标识循环终止条件
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p id="ue11a6508">
         <strong>
          swap 操作
         </strong>
        </p>
       </td>
       <td>
        <p id="ub72577fc">
         直接交换两个容器的内部数据指针，时间复杂度 O(1)
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p id="u311ebae3">
     注：「end() 指向最后一个元素的 后 一个」，实际指向尾部哨兵位
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303137313030342f:61727469636c652f64657461696c732f313436323630353238" class_="artid" style="display:none">
 </p>
</div>


