---
layout: post
title: "LFU最不经常使用-缓存算法实现"
date: 2025-03-16 21:53:56 +0800
description: "LFU（Least Frequently Used）是一种基于访问频率的缓存淘汰策略。当缓存容量不足时，系统会优先淘汰使用频率最低的条目，当频率相同时则淘汰最久未使用的条目。本文通过C++实现了一个时间复杂度为O(1)的LFU算法方案。"
keywords: "LFU（最不经常使用） 缓存算法实现"
categories: ['未分类']
tags: ['缓存', '算法', 'C']
artid: "146301940"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146301940
    alt: "LFU最不经常使用-缓存算法实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146301940
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146301940
cover: https://bing.ee123.net/img/rand?artid=146301940
image: https://bing.ee123.net/img/rand?artid=146301940
img: https://bing.ee123.net/img/rand?artid=146301940
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LFU（最不经常使用） 缓存算法实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     上一篇博客我们实现了LRU缓存算法。
     <br/>
     进一步地，我们思考一下LFU算法又该如何实现呢？与LRU算法相比，LFU算法要求当缓存达到其容量 capacity 时，则应该在插入新项之前，移除
     <strong>
      最不经常使用
     </strong>
     的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除
     <strong>
      最久未使用
     </strong>
     的键。也就是说LFU算法实现比LRU算法要考虑的更多一步，也就是要考虑每个缓存内容的使用频率。
    </p>
    <h3>
     <a id="_3">
     </a>
     思路
    </h3>
    <p>
     在上一篇LRU算法实现过程中，我们提到了可以将缓存的更新和替换看成对一堆书进行操作，每次get和put已有的书时，则将书放到书堆的最上面，当有新的书加入时，则将最下面的书取出，并将新的书放到最上面。
     <br/>
     对于LFU算法的实现，我们同样可以将其看成对书堆的操作，不同的是，我们需要看成对多个书堆的操作，每本书用一个使用频率
     <code>
      freq
     </code>
     来进行维护其使用次数。当对一本书进行get和put操作时，其频率加一，同时每个书堆分别代表不同使用频率的书的集合，每个集合则用LRU算法进行维护书堆。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fd9b3257d6064e62a3d30432a349154c.png">
      <br/>
      那么。
     </img>
    </p>
    <ol>
     <li>
      如何实现好几堆书呢？
     </li>
    </ol>
    <blockquote>
     <p>
      同样，可以用哈希表实现，哈希表的键表示频率，哈希表的值则是双链表的头结点。这样我们就能在O(1)的时间复杂度获取相应频率的书堆。
     </p>
    </blockquote>
    <ol start="2">
     <li>
      超过缓存容量时，如何快速获取到使用频率最小的书呢？
     </li>
    </ol>
    <blockquote>
     <p>
      我们可以维护一个min_freq的变量记录使用频率最小的数。在添加一本新书的情况下，这本新书一定是放在
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         f 
         
        
          r 
         
        
          e 
         
        
          q 
         
        
          = 
         
        
          1 
         
        
       
         freq=1
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.1076em;">
           f
          </span>
          <span class="mord mathnormal">
           re
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0359em;">
           q
          </span>
          <span class="mspace" style="margin-right: 0.2778em;">
          </span>
          <span class="mrel">
           =
          </span>
          <span class="mspace" style="margin-right: 0.2778em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 0.6444em;">
          </span>
          <span class="mord">
           1
          </span>
         </span>
        </span>
       </span>
      </span>
      的那摞书上，此时我们把 min_freq置为 1。在「抽出一本书且这摞书变成空」的情况下，我们会把这本书放到它右边这摞书的最上面。如果变成空的那摞书是最左边的，我们还会把 min_freq加一。所以无论如何，min_freq都会对应着最左边的非空的那摞书。相应的，如果有新的书放到这几个书堆中来，则这本新书的使用频率肯定是最小的并且为1，此时可以更新min_freq的值为1。
     </p>
    </blockquote>
    <h3>
     <a id="_13">
     </a>
     算法分析
    </h3>
    <ul>
     <li>
      <p>
       时间复杂度：所有操作均为O(1)
      </p>
     </li>
     <li>
      <p>
       空间复杂度：O(capacity)
      </p>
     </li>
     <li>
      <p>
       淘汰策略：
       <br/>
       优先淘汰最低频率节点
       <br/>
       同频率时淘汰最久未使用
      </p>
     </li>
    </ul>
    <h3>
     <a id="_22">
     </a>
     优化亮点
    </h3>
    <ol>
     <li>
      <p>
       双哈希表结构：实现快速访问和频率管理
      </p>
     </li>
     <li>
      <p>
       哨兵节点：简化链表边界操作
      </p>
     </li>
     <li>
      <p>
       动态频率维护：自动跟踪最小频率
      </p>
     </li>
     <li>
      <p>
       LRU辅助策略：在相同频率下保留访问时序
      </p>
     </li>
    </ol>
    <h3>
     <a id="_31">
     </a>
     代码实现
    </h3>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span> 
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">int</span> freq<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>next<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">key</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">value</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">freq</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">LFUCache</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
    <span class="token keyword">int</span> min_freq<span class="token punctuation">;</span>
    unordered_map <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Node<span class="token operator">*</span><span class="token operator">&gt;</span> key_to_node<span class="token punctuation">;</span>
    unordered_map <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Node<span class="token operator">*</span><span class="token operator">&gt;</span> freq_to_node<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">RemoveNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Node <span class="token operator">*</span>node <span class="token operator">=</span> key_to_node<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        node <span class="token operator">-&gt;</span> prev <span class="token operator">-&gt;</span> next <span class="token operator">=</span> node <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>
        node <span class="token operator">-&gt;</span> next <span class="token operator">-&gt;</span> prev <span class="token operator">=</span> node <span class="token operator">-&gt;</span> prev<span class="token punctuation">;</span>
        <span class="token keyword">int</span> freq <span class="token operator">=</span> node <span class="token operator">-&gt;</span> freq<span class="token punctuation">;</span>
        key_to_node<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>freq_to_node<span class="token punctuation">[</span>min_freq<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> next <span class="token operator">==</span> freq_to_node<span class="token punctuation">[</span>min_freq<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">delete</span> freq_to_node<span class="token punctuation">[</span>min_freq<span class="token punctuation">]</span><span class="token punctuation">;</span>
            freq_to_node<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>min_freq<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果被删除的是当前最小频率链表，则最小频率+1</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>min_freq <span class="token operator">==</span> freq<span class="token punctuation">)</span> min_freq<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">delete</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">PushFront</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 头插法</span>
        Node <span class="token operator">*</span>cache<span class="token punctuation">;</span>
        <span class="token keyword">int</span> freq <span class="token operator">=</span> node <span class="token operator">-&gt;</span> freq<span class="token punctuation">;</span>
        <span class="token comment">// 如果该频率没有链表，则新建哨兵节点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>freq_to_node<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>freq<span class="token punctuation">)</span> <span class="token operator">==</span> freq_to_node<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个哨兵结点</span>
            cache <span class="token operator">-&gt;</span> next <span class="token operator">=</span> cache <span class="token operator">-&gt;</span> prev <span class="token operator">=</span> cache<span class="token punctuation">;</span>
            freq_to_node<span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            cache <span class="token operator">=</span> freq_to_node<span class="token punctuation">[</span>freq<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node <span class="token operator">-&gt;</span> next <span class="token operator">=</span> cache <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>
        node <span class="token operator">-&gt;</span> prev <span class="token operator">=</span> cache<span class="token punctuation">;</span>
        cache <span class="token operator">-&gt;</span> next <span class="token operator">-&gt;</span> prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
        cache <span class="token operator">-&gt;</span> next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        key_to_node<span class="token punctuation">[</span>node <span class="token operator">-&gt;</span> key<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">LFUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span> <span class="token operator">-&gt;</span> capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
        min_freq <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 初始最小频率为1（新节点频率都是1）</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key_to_node<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> key_to_node<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> value <span class="token operator">=</span> key_to_node<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> value<span class="token punctuation">;</span>
            <span class="token keyword">int</span> freq <span class="token operator">=</span> key_to_node<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> freq <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token function">RemoveNode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从旧频率链表移除</span>
            Node <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> freq<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">PushFront</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 插入新频率链表</span>
            <span class="token keyword">return</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">auto</span> find_key <span class="token operator">=</span> key_to_node<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>find_key <span class="token operator">==</span> key_to_node<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Node <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>key_to_node<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">PushFront</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">RemoveNode</span><span class="token punctuation">(</span>freq_to_node<span class="token punctuation">[</span>min_freq<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> prev <span class="token operator">-&gt;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">PushFront</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            min_freq <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果是新内容</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果内容已经存在</span>
            <span class="token keyword">int</span> freq <span class="token operator">=</span> key_to_node<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">-&gt;</span> freq<span class="token punctuation">;</span>
            <span class="token function">RemoveNode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Node <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> freq <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">PushFront</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f6c697570616e6731343135392f:61727469636c652f64657461696c732f313436333031393430" class_="artid" style="display:none">
 </p>
</div>


