---
layout: post
title: "数据结构之DFS与BFS实现"
date: 2025-01-12 15:59:03 +0800
description: "本文主要包括以下内容 邻接矩阵实现无向图的BFS与DFS 邻接表实现无向图的BFS与DFS理论介绍深"
keywords: "以邻接矩阵为存储结构,对无向图分别进行dfs(深度优先遍历)和bfs(广度优先遍历)。"
categories: ['数据结构']
tags: ['遍历', '数据结构', '搜索', 'Dfs', 'Bfs']
artid: "51763042"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51763042
    alt: "数据结构之DFS与BFS实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51763042
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51763042
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构之DFS与BFS实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      本文主要包括以下内容
     </strong>
    </p>
    <ol>
     <li>
      邻接矩阵实现无向图的BFS与DFS
     </li>
     <li>
      邻接表实现无向图的BFS与DFS
     </li>
    </ol>
    <h4 id="理论介绍">
     理论介绍
    </h4>
    <p>
     <strong>
      深度优先搜索介绍
     </strong>
    </p>
    <p>
     图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。
    </p>
    <p>
     它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。
    </p>
    <p>
     显然，深度优先搜索是一个递归的过程。
    </p>
    <p>
     <img alt="" src="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/02.jpg?raw=true" title=""/>
    </p>
    <p>
     <strong>
      广度优先搜索介绍
     </strong>
    </p>
    <p>
     广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。
    </p>
    <p>
     它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。
    </p>
    <p>
     换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。
    </p>
    <p>
     <img alt="" src="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/05.jpg?raw=true" title=""/>
    </p>
    <h4 id="邻接矩阵实现无向图的bfs与dfs">
     邻接矩阵实现无向图的BFS与DFS
    </h4>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-comment">/**
 * C++: 邻接矩阵表示的"无向图(Matrix Undirected Graph)"
 *
 * @author skywang
 * @date 2014/04/19
 */</span>

<span class="hljs-preprocessor">#include &lt;iomanip&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-preprocessor">#define MAX 100</span>
<span class="hljs-keyword">class</span> MatrixUDG {
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">char</span> mVexs[MAX];    <span class="hljs-comment">// 顶点集合</span>
        <span class="hljs-keyword">int</span> mVexNum;             <span class="hljs-comment">// 顶点数</span>
        <span class="hljs-keyword">int</span> mEdgNum;             <span class="hljs-comment">// 边数</span>
        <span class="hljs-keyword">int</span> mMatrix[MAX][MAX];   <span class="hljs-comment">// 邻接矩阵</span>

    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">// 创建图(自己输入数据)</span>
        MatrixUDG();
        <span class="hljs-comment">// 创建图(用已提供的矩阵)</span>
        MatrixUDG(<span class="hljs-keyword">char</span> vexs[], <span class="hljs-keyword">int</span> vlen, <span class="hljs-keyword">char</span> edges[][<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> elen);
        ~MatrixUDG();

        <span class="hljs-comment">// 深度优先搜索遍历图</span>
        <span class="hljs-keyword">void</span> DFS();
        <span class="hljs-comment">// 广度优先搜索（类似于树的层次遍历）</span>
        <span class="hljs-keyword">void</span> BFS();
        <span class="hljs-comment">// 打印矩阵队列图</span>
        <span class="hljs-keyword">void</span> print();

    <span class="hljs-keyword">private</span>:
        <span class="hljs-comment">// 读取一个输入字符</span>
        <span class="hljs-keyword">char</span> readChar();
        <span class="hljs-comment">// 返回ch在mMatrix矩阵中的位置</span>
        <span class="hljs-keyword">int</span> getPosition(<span class="hljs-keyword">char</span> ch);
        <span class="hljs-comment">// 返回顶点v的第一个邻接顶点的索引，失败则返回-1</span>
        <span class="hljs-keyword">int</span> firstVertex(<span class="hljs-keyword">int</span> v);
        <span class="hljs-comment">// 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</span>
        <span class="hljs-keyword">int</span> nextVertex(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w);
        <span class="hljs-comment">// 深度优先搜索遍历图的递归实现</span>
        <span class="hljs-keyword">void</span> DFS(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> *visited);

};

<span class="hljs-comment">/* 
 * 创建图(自己输入数据)
 */</span>
MatrixUDG::MatrixUDG()
{
    <span class="hljs-keyword">char</span> c1, c2;
    <span class="hljs-keyword">int</span> i, p1, p2;

    <span class="hljs-comment">// 输入"顶点数"和"边数"</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input vertex number: "</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; mVexNum;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input edge number: "</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; mEdgNum;
    <span class="hljs-keyword">if</span> ( mVexNum &lt; <span class="hljs-number">1</span> || mEdgNum &lt; <span class="hljs-number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum-<span class="hljs-number">1</span>))))
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input error: invalid parameters!"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> ;
    }

    <span class="hljs-comment">// 初始化"顶点"</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"): "</span>;
        mVexs[i] = readChar();
    }

    <span class="hljs-comment">// 初始化"边"</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mEdgNum; i++)
    {
        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"): "</span>;
        c1 = readChar();
        c2 = readChar();

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        <span class="hljs-keyword">if</span> (p1==-<span class="hljs-number">1</span> || p2==-<span class="hljs-number">1</span>)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input error: invalid edge!"</span> &lt;&lt; endl;
            <span class="hljs-keyword">return</span> ;
        }

        mMatrix[p1][p2] = <span class="hljs-number">1</span>;
        mMatrix[p2][p1] = <span class="hljs-number">1</span>;
    }
}

<span class="hljs-comment">/*
 * 创建图(用已提供的矩阵)
 *
 * 参数说明：
 *     vexs  -- 顶点数组
 *     vlen  -- 顶点数组的长度
 *     edges -- 边数组
 *     elen  -- 边数组的长度
 */</span>
MatrixUDG::MatrixUDG(<span class="hljs-keyword">char</span> vexs[], <span class="hljs-keyword">int</span> vlen, <span class="hljs-keyword">char</span> edges[][<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> elen)
{
    <span class="hljs-keyword">int</span> i, p1, p2;

    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span>
    mVexNum = vlen;
    mEdgNum = elen;
    <span class="hljs-comment">// 初始化"顶点"</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
        mVexs[i] = vexs[i];

    <span class="hljs-comment">// 初始化"边"</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mEdgNum; i++)
    {
        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span>
        p1 = getPosition(edges[i][<span class="hljs-number">0</span>]);
        p2 = getPosition(edges[i][<span class="hljs-number">1</span>]);

        mMatrix[p1][p2] = <span class="hljs-number">1</span>;
        mMatrix[p2][p1] = <span class="hljs-number">1</span>;
    }
}

<span class="hljs-comment">/* 
 * 析构函数
 */</span>
MatrixUDG::~MatrixUDG() 
{
}

<span class="hljs-comment">/*
 * 返回ch在mMatrix矩阵中的位置
 */</span>
<span class="hljs-keyword">int</span> MatrixUDG::getPosition(<span class="hljs-keyword">char</span> ch)
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;mVexNum; i++)
        <span class="hljs-keyword">if</span>(mVexs[i]==ch)
            <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-comment">/*
 * 读取一个输入字符
 */</span>
<span class="hljs-keyword">char</span> MatrixUDG::readChar()
{
    <span class="hljs-keyword">char</span> ch;

    <span class="hljs-keyword">do</span> {
        <span class="hljs-built_in">cin</span> &gt;&gt; ch;
    } <span class="hljs-keyword">while</span>(!((ch&gt;=<span class="hljs-string">'a'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'z'</span>) || (ch&gt;=<span class="hljs-string">'A'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'Z'</span>)));

    <span class="hljs-keyword">return</span> ch;
}


<span class="hljs-comment">/*
 * 返回顶点v的第一个邻接顶点的索引，失败则返回-1
 */</span>
<span class="hljs-keyword">int</span> MatrixUDG::firstVertex(<span class="hljs-keyword">int</span> v)
{
    <span class="hljs-keyword">int</span> i;

    <span class="hljs-keyword">if</span> (v&lt;<span class="hljs-number">0</span> || v&gt;(mVexNum-<span class="hljs-number">1</span>))
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
        <span class="hljs-keyword">if</span> (mMatrix[v][i] == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> i;

    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-comment">/*
 * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1
 */</span>
<span class="hljs-keyword">int</span> MatrixUDG::nextVertex(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)
{
    <span class="hljs-keyword">int</span> i;

    <span class="hljs-keyword">if</span> (v&lt;<span class="hljs-number">0</span> || v&gt;(mVexNum-<span class="hljs-number">1</span>) || w&lt;<span class="hljs-number">0</span> || w&gt;(mVexNum-<span class="hljs-number">1</span>))
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (i = w + <span class="hljs-number">1</span>; i &lt; mVexNum; i++)
        <span class="hljs-keyword">if</span> (mMatrix[v][i] == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> i;

    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-comment">/*
 * 深度优先搜索遍历图的递归实现
 */</span>
<span class="hljs-keyword">void</span> MatrixUDG::DFS(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> *visited)
{
    <span class="hljs-keyword">int</span> w;

    visited[i] = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-comment">// 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走</span>
    <span class="hljs-keyword">for</span> (w = firstVertex(i); w &gt;= <span class="hljs-number">0</span>; w = nextVertex(i, w))
    {
        <span class="hljs-keyword">if</span> (!visited[w])
            DFS(w, visited);
    }

}

<span class="hljs-comment">/*
 * 深度优先搜索遍历图
 */</span>
<span class="hljs-keyword">void</span> MatrixUDG::DFS()
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> visited[MAX];       <span class="hljs-comment">// 顶点访问标记</span>

    <span class="hljs-comment">// 初始化所有顶点都没有被访问</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DFS: "</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-comment">//printf("\n== LOOP(%d)\n", i);</span>
        <span class="hljs-keyword">if</span> (!visited[i])
            DFS(i, visited);
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">/*
 * 广度优先搜索（类似于树的层次遍历）
 */</span>
<span class="hljs-keyword">void</span> MatrixUDG::BFS()
{
    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">queue</span>[MAX];     <span class="hljs-comment">// 辅组队列</span>
    <span class="hljs-keyword">int</span> visited[MAX];   <span class="hljs-comment">// 顶点访问标记</span>
    <span class="hljs-keyword">int</span> i, j, k;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"BFS: "</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-keyword">if</span> (!visited[i])
        {
            visited[i] = <span class="hljs-number">1</span>;
            <span class="hljs-built_in">cout</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="hljs-string">" "</span>;
            <span class="hljs-built_in">queue</span>[rear++] = i;  <span class="hljs-comment">// 入队列</span>
        }
        <span class="hljs-keyword">while</span> (head != rear) 
        {
            j = <span class="hljs-built_in">queue</span>[head++];  <span class="hljs-comment">// 出队列</span>
            <span class="hljs-keyword">for</span> (k = firstVertex(j); k &gt;= <span class="hljs-number">0</span>; k = nextVertex(j, k)) <span class="hljs-comment">//k是为访问的邻接顶点</span>
            {
                <span class="hljs-keyword">if</span> (!visited[k])
                {
                    visited[k] = <span class="hljs-number">1</span>;
                    <span class="hljs-built_in">cout</span> &lt;&lt; mVexs[k] &lt;&lt; <span class="hljs-string">" "</span>;
                    <span class="hljs-built_in">queue</span>[rear++] = k;
                }
            }
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">/*
 * 打印矩阵队列图
 */</span>
<span class="hljs-keyword">void</span> MatrixUDG::print()
{
    <span class="hljs-keyword">int</span> i,j;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Martix Graph:"</span> &lt;&lt; endl;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; mVexNum; j++)
            <span class="hljs-built_in">cout</span> &lt;&lt; mMatrix[i][j] &lt;&lt; <span class="hljs-string">" "</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; endl;
    }
}


<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">char</span> vexs[] = {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>};
    <span class="hljs-keyword">char</span> edges[][<span class="hljs-number">2</span>] = {
        {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>}, 
        {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>}, 
        {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>}, 
        {<!-- --><span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>}, 
        {<!-- --><span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>}, 
        {<!-- --><span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>}, 
        {<!-- --><span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>}};
    <span class="hljs-keyword">int</span> vlen = <span class="hljs-keyword">sizeof</span>(vexs)/<span class="hljs-keyword">sizeof</span>(vexs[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">int</span> elen = <span class="hljs-keyword">sizeof</span>(edges)/<span class="hljs-keyword">sizeof</span>(edges[<span class="hljs-number">0</span>]);
    MatrixUDG* pG;

    <span class="hljs-comment">// 自定义"图"(输入矩阵队列)</span>
    <span class="hljs-comment">//pG = new MatrixUDG();</span>
    <span class="hljs-comment">// 采用已有的"图"</span>
    pG = <span class="hljs-keyword">new</span> MatrixUDG(vexs, vlen, edges, elen);

    pG-&gt;print();   <span class="hljs-comment">// 打印图</span>
    pG-&gt;DFS();     <span class="hljs-comment">// 深度优先遍历</span>
    pG-&gt;BFS();     <span class="hljs-comment">// 广度优先遍历</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    <h4 id="邻接表实现无向图的bfs与dfs">
     邻接表实现无向图的BFS与DFS
    </h4>
    <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-comment">/**
 * C++: 邻接表表示的"无向图(List Undirected Graph)"
 *
 * @author skywang
 * @date 2014/04/19
 */</span>

<span class="hljs-preprocessor">#include &lt;iomanip&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-preprocessor">#define MAX 100</span>
<span class="hljs-comment">// 邻接表</span>
<span class="hljs-keyword">class</span> ListUDG
{
    <span class="hljs-keyword">private</span>: <span class="hljs-comment">// 内部类</span>
        <span class="hljs-comment">// 邻接表中表对应的链表的顶点</span>
        <span class="hljs-keyword">class</span> ENode
        {
            <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">int</span> ivex;           <span class="hljs-comment">// 该边所指向的顶点的位置</span>
                ENode *nextEdge;    <span class="hljs-comment">// 指向下一条弧的指针</span>
        };

        <span class="hljs-comment">// 邻接表中表的顶点</span>
        <span class="hljs-keyword">class</span> VNode
        {
            <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">char</span> data;          <span class="hljs-comment">// 顶点信息</span>
                ENode *firstEdge;   <span class="hljs-comment">// 指向第一条依附该顶点的弧</span>
        };

    <span class="hljs-keyword">private</span>: <span class="hljs-comment">// 私有成员</span>
        <span class="hljs-keyword">int</span> mVexNum;             <span class="hljs-comment">// 图的顶点的数目</span>
        <span class="hljs-keyword">int</span> mEdgNum;             <span class="hljs-comment">// 图的边的数目</span>
        VNode mVexs[MAX];

    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">// 创建邻接表对应的图(自己输入)</span>
        ListUDG();
        <span class="hljs-comment">// 创建邻接表对应的图(用已提供的数据)</span>
        ListUDG(<span class="hljs-keyword">char</span> vexs[], <span class="hljs-keyword">int</span> vlen, <span class="hljs-keyword">char</span> edges[][<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> elen);
        ~ListUDG();

        <span class="hljs-comment">// 深度优先搜索遍历图</span>
        <span class="hljs-keyword">void</span> DFS();
        <span class="hljs-comment">// 广度优先搜索（类似于树的层次遍历）</span>
        <span class="hljs-keyword">void</span> BFS();
        <span class="hljs-comment">// 打印邻接表图</span>
        <span class="hljs-keyword">void</span> print();

    <span class="hljs-keyword">private</span>:
        <span class="hljs-comment">// 读取一个输入字符</span>
        <span class="hljs-keyword">char</span> readChar();
        <span class="hljs-comment">// 返回ch的位置</span>
        <span class="hljs-keyword">int</span> getPosition(<span class="hljs-keyword">char</span> ch);
        <span class="hljs-comment">// 深度优先搜索遍历图的递归实现</span>
        <span class="hljs-keyword">void</span> DFS(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> *visited);
        <span class="hljs-comment">// 将node节点链接到list的最后</span>
        <span class="hljs-keyword">void</span> linkLast(ENode *<span class="hljs-built_in">list</span>, ENode *node);
};

<span class="hljs-comment">/*
 * 创建邻接表对应的图(自己输入)
 */</span>
ListUDG::ListUDG()
{
    <span class="hljs-keyword">char</span> c1, c2;
    <span class="hljs-keyword">int</span> v, e;
    <span class="hljs-keyword">int</span> i, p1, p2;
    ENode *node1, *node2;

    <span class="hljs-comment">// 输入"顶点数"和"边数"</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input vertex number: "</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; mVexNum;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input edge number: "</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; mEdgNum;
    <span class="hljs-keyword">if</span> ( mVexNum &lt; <span class="hljs-number">1</span> || mEdgNum &lt; <span class="hljs-number">1</span> || (mEdgNum &gt; (mVexNum * (mVexNum-<span class="hljs-number">1</span>))))
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"input error: invalid parameters!"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> ;
    }

    <span class="hljs-comment">// 初始化"邻接表"的顶点</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;mVexNum; i++)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"vertex("</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"): "</span>;
        mVexs[i].data = readChar();
        mVexs[i].firstEdge = NULL;
    }

    <span class="hljs-comment">// 初始化"邻接表"的边</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;mEdgNum; i++)
    {
        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"edge("</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"): "</span>;
        c1 = readChar();
        c2 = readChar();

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        <span class="hljs-comment">// 初始化node1</span>
        node1 = <span class="hljs-keyword">new</span> ENode();
        node1-&gt;ivex = p2;
        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span>
        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == NULL)
          mVexs[p1].firstEdge = node1;
        <span class="hljs-keyword">else</span>
            linkLast(mVexs[p1].firstEdge, node1);
        <span class="hljs-comment">// 初始化node2</span>
        node2 = <span class="hljs-keyword">new</span> ENode();
        node2-&gt;ivex = p1;
        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span>
        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == NULL)
          mVexs[p2].firstEdge = node2;
        <span class="hljs-keyword">else</span>
            linkLast(mVexs[p2].firstEdge, node2);
    }
}

<span class="hljs-comment">/*
 * 创建邻接表对应的图(用已提供的数据)
 */</span>
ListUDG::ListUDG(<span class="hljs-keyword">char</span> vexs[], <span class="hljs-keyword">int</span> vlen, <span class="hljs-keyword">char</span> edges[][<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> elen)
{
    <span class="hljs-keyword">char</span> c1, c2;
    <span class="hljs-keyword">int</span> i, p1, p2;
    ENode *node1, *node2;

    <span class="hljs-comment">// 初始化"顶点数"和"边数"</span>
    mVexNum = vlen;
    mEdgNum = elen;
    <span class="hljs-comment">// 初始化"邻接表"的顶点</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;mVexNum; i++)
    {
        mVexs[i].data = vexs[i];
        mVexs[i].firstEdge = NULL;
    }

    <span class="hljs-comment">// 初始化"邻接表"的边</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;mEdgNum; i++)
    {
        <span class="hljs-comment">// 读取边的起始顶点和结束顶点</span>
        c1 = edges[i][<span class="hljs-number">0</span>];
        c2 = edges[i][<span class="hljs-number">1</span>];

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        <span class="hljs-comment">// 初始化node1</span>
        node1 = <span class="hljs-keyword">new</span> ENode();
        node1-&gt;ivex = p2;
        <span class="hljs-comment">// 将node1链接到"p1所在链表的末尾"</span>
        <span class="hljs-keyword">if</span>(mVexs[p1].firstEdge == NULL)
          mVexs[p1].firstEdge = node1;
        <span class="hljs-keyword">else</span>
            linkLast(mVexs[p1].firstEdge, node1);
        <span class="hljs-comment">// 初始化node2</span>
        node2 = <span class="hljs-keyword">new</span> ENode();
        node2-&gt;ivex = p1;
        <span class="hljs-comment">// 将node2链接到"p2所在链表的末尾"</span>
        <span class="hljs-keyword">if</span>(mVexs[p2].firstEdge == NULL)
          mVexs[p2].firstEdge = node2;
        <span class="hljs-keyword">else</span>
            linkLast(mVexs[p2].firstEdge, node2);
    }
}

<span class="hljs-comment">/* 
 * 析构函数
 */</span>
ListUDG::~ListUDG() 
{
}

<span class="hljs-comment">/*
 * 将node节点链接到list的最后
 */</span>
<span class="hljs-keyword">void</span> ListUDG::linkLast(ENode *<span class="hljs-built_in">list</span>, ENode *node)
{
    ENode *p = <span class="hljs-built_in">list</span>;

    <span class="hljs-keyword">while</span>(p-&gt;nextEdge)
        p = p-&gt;nextEdge;
    p-&gt;nextEdge = node;
}

<span class="hljs-comment">/*
 * 返回ch的位置
 */</span>
<span class="hljs-keyword">int</span> ListUDG::getPosition(<span class="hljs-keyword">char</span> ch)
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;mVexNum; i++)
        <span class="hljs-keyword">if</span>(mVexs[i].data==ch)
            <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-comment">/*
 * 读取一个输入字符
 */</span>
<span class="hljs-keyword">char</span> ListUDG::readChar()
{
    <span class="hljs-keyword">char</span> ch;

    <span class="hljs-keyword">do</span> {
        <span class="hljs-built_in">cin</span> &gt;&gt; ch;
    } <span class="hljs-keyword">while</span>(!((ch&gt;=<span class="hljs-string">'a'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'z'</span>) || (ch&gt;=<span class="hljs-string">'A'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'Z'</span>)));

    <span class="hljs-keyword">return</span> ch;
}


<span class="hljs-comment">/*
 * 深度优先搜索遍历图的递归实现
 */</span>
<span class="hljs-keyword">void</span> ListUDG::DFS(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> *visited)
{
    ENode *node;

    visited[i] = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="hljs-string">" "</span>;
    node = mVexs[i].firstEdge;
    <span class="hljs-keyword">while</span> (node != NULL)
    {
        <span class="hljs-keyword">if</span> (!visited[node-&gt;ivex])
            DFS(node-&gt;ivex, visited);
        node = node-&gt;nextEdge;
    }
}

<span class="hljs-comment">/*
 * 深度优先搜索遍历图
 */</span>
<span class="hljs-keyword">void</span> ListUDG::DFS()
{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> visited[MAX];       <span class="hljs-comment">// 顶点访问标记</span>

    <span class="hljs-comment">// 初始化所有顶点都没有被访问</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"DFS: "</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-keyword">if</span> (!visited[i])
            DFS(i, visited);
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">/*
 * 广度优先搜索（类似于树的层次遍历）
 */</span>
<span class="hljs-keyword">void</span> ListUDG::BFS()
{
    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">queue</span>[MAX];     <span class="hljs-comment">// 辅组队列</span>
    <span class="hljs-keyword">int</span> visited[MAX];   <span class="hljs-comment">// 顶点访问标记</span>
    <span class="hljs-keyword">int</span> i, j, k;
    ENode *node;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
        visited[i] = <span class="hljs-number">0</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"BFS: "</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-keyword">if</span> (!visited[i])
        {
            visited[i] = <span class="hljs-number">1</span>;
            <span class="hljs-built_in">cout</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="hljs-string">" "</span>;
            <span class="hljs-built_in">queue</span>[rear++] = i;  <span class="hljs-comment">// 入队列</span>
        }
        <span class="hljs-keyword">while</span> (head != rear) 
        {
            j = <span class="hljs-built_in">queue</span>[head++];  <span class="hljs-comment">// 出队列</span>
            node = mVexs[j].firstEdge;
            <span class="hljs-keyword">while</span> (node != NULL)
            {
                k = node-&gt;ivex;
                <span class="hljs-keyword">if</span> (!visited[k])
                {
                    visited[k] = <span class="hljs-number">1</span>;
                    <span class="hljs-built_in">cout</span> &lt;&lt; mVexs[k].data &lt;&lt; <span class="hljs-string">" "</span>;
                    <span class="hljs-built_in">queue</span>[rear++] = k;
                }
                node = node-&gt;nextEdge;
            }
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">/*
 * 打印邻接表图
 */</span>
<span class="hljs-keyword">void</span> ListUDG::print()
{
    <span class="hljs-keyword">int</span> i,j;
    ENode *node;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"List Graph:"</span> &lt;&lt; endl;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; mVexs[i].data &lt;&lt; <span class="hljs-string">"): "</span>;
        node = mVexs[i].firstEdge;
        <span class="hljs-keyword">while</span> (node != NULL)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; node-&gt;ivex &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; mVexs[node-&gt;ivex].data &lt;&lt; <span class="hljs-string">") "</span>;
            node = node-&gt;nextEdge;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; endl;
    }
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">char</span> vexs[] = {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>};
    <span class="hljs-keyword">char</span> edges[][<span class="hljs-number">2</span>] = {
        {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>}, 
        {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>}, 
        {<!-- --><span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>}, 
        {<!-- --><span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>}, 
        {<!-- --><span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>}, 
        {<!-- --><span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>}, 
        {<!-- --><span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>}};
    <span class="hljs-keyword">int</span> vlen = <span class="hljs-keyword">sizeof</span>(vexs)/<span class="hljs-keyword">sizeof</span>(vexs[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">int</span> elen = <span class="hljs-keyword">sizeof</span>(edges)/<span class="hljs-keyword">sizeof</span>(edges[<span class="hljs-number">0</span>]);
    ListUDG* pG;

    <span class="hljs-comment">// 自定义"图"(输入矩阵队列)</span>
    <span class="hljs-comment">//pG = new ListUDG();</span>
    <span class="hljs-comment">// 采用已有的"图"</span>
    pG = <span class="hljs-keyword">new</span> ListUDG(vexs, vlen, edges, elen);

    pG-&gt;print();   <span class="hljs-comment">// 打印图</span>
    pG-&gt;DFS();     <span class="hljs-comment">// 深度优先遍历</span>
    pG-&gt;BFS();     <span class="hljs-comment">// 广度优先遍历</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    <h4 id="references">
     References
    </h4>
    <p>
     <a href="http://www.cnblogs.com/skywang12345/p/3711483.html" rel="nofollow">
      图的遍历之 深度优先搜索和广度优先搜索 - 如果天空不死 - 博客园
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f77687568616e32303133:2f61727469636c652f64657461696c732f3531373633303432" class_="artid" style="display:none">
 </p>
</div>


