---
layout: post
title: "c-观察者模式-订阅发布架构"
date: 2025-08-28T23:09:32+0800
description: "【代码】c++ 观察者模式 订阅发布架构。"
keywords: "c++ 观察者模式 订阅发布架构"
categories: ['未分类']
tags: ['观察者模式']
artid: "150965164"
arturl: "https://blog.csdn.net/sinat_20962951/article/details/150965164"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150965164
    alt: "c-观察者模式-订阅发布架构"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150965164
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150965164
cover: https://bing.ee123.net/img/rand?artid=150965164
image: https://bing.ee123.net/img/rand?artid=150965164
img: https://bing.ee123.net/img/rand?artid=150965164
---



# c++ 观察者模式 订阅发布架构

![](https://i-blog.csdnimg.cn/direct/8dc4007df6fc4a46975110d06cd96126.png)

![](https://i-blog.csdnimg.cn/direct/a915f7ee89c94c3299a8d100e3be282b.png)

![](https://i-blog.csdnimg.cn/direct/8755081a741e4d678398a9594c9570a3.png)

![](https://i-blog.csdnimg.cn/direct/5e5ddbed914f467990a2c5ffde536d3f.png)

```

#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>
#include <mutex>

// 观察者接口
class IObserver {
public:
    virtual ~IObserver() = default;
    virtual void update(const std::string& message) = 0;
};

// 主题接口
class ISubject {
public:
    virtual ~ISubject() = default;
    virtual void attach(std::shared_ptr<IObserver> observer) = 0;
    virtual void detach(std::shared_ptr<IObserver> observer) = 0;
    virtual void notify(const std::string& message) = 0;
};

// 具体主题实现
class ConcreteSubject : public ISubject {
private:
    std::vector<std::shared_ptr<IObserver>> observers_;
    std::mutex mutex_;
    std::string state_;

public:
    void attach(std::shared_ptr<IObserver> observer) override {
        std::lock_guard<std::mutex> lock(mutex_);
        observers_.push_back(observer);
    }

    void detach(std::shared_ptr<IObserver> observer) override {
        std::lock_guard<std::mutex> lock(mutex_);
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), observer),
            observers_.end()
        );
    }

    void notify(const std::string& message) override {
        std::vector<std::shared_ptr<IObserver>> observers_copy;
        {
            std::lock_guard<std::mutex> lock(mutex_);
            observers_copy = observers_;
        }
        
        for (auto& observer : observers_copy) {
            observer->update(message);
        }
    }

    void setState(const std::string& state) {
        state_ = state;
        notify("State changed to: " + state);
    }

    std::string getState() const {
        return state_;
    }
};

// 具体观察者实现
class ConcreteObserver : public IObserver, public std::enable_shared_from_this<ConcreteObserver> {
private:
    std::string name_;
    std::weak_ptr<ISubject> subject_;

public:
    ConcreteObserver(const std::string& name, std::shared_ptr<ISubject> subject)
        : name_(name), subject_(subject) {
        subject->attach(shared_from_this());
    }

    ~ConcreteObserver() {
        if (auto subject = subject_.lock()) {
            subject->detach(shared_from_this());
        }
    }

    void update(const std::string& message) override {
        std::cout << "Observer " << name_ << " received: " << message << std::endl;
    }
};

// 使用示例
int main() {
    auto subject = std::make_shared<ConcreteSubject>();
    
    auto observer1 = std::make_shared<ConcreteObserver>("Observer1", subject);
    auto observer2 = std::make_shared<ConcreteObserver>("Observer2", subject);
    
    subject->setState("Active");
    subject->setState("Inactive");
    
    return 0;
}
```



