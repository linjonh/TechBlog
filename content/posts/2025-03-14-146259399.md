---
layout: post
title: "嵌入式八股ARM篇"
date: 2025-03-14 16:03:08 +0800
description: "嵌入式2026秋招八股"
keywords: "嵌入式八股ARM篇"
categories: ['嵌入式八股']
tags: ['嵌入式硬件', '单片机', 'C', 'Arm']
artid: "146259399"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146259399
    alt: "嵌入式八股ARM篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146259399
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146259399
cover: https://bing.ee123.net/img/rand?artid=146259399
image: https://bing.ee123.net/img/rand?artid=146259399
img: https://bing.ee123.net/img/rand?artid=146259399
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     嵌入式八股ARM篇
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     前言
    </h2>
    <p>
     ARM篇主要介绍一下寄存器和中断机制,至于汇编这一块…还请大家感兴趣自行学习
    </p>
    <h2>
     <a id="1_2">
     </a>
     1.寄存器
    </h2>
    <ol>
     <li>
      R0 - R3 R4 - R11 寄存器
      <br/>
      R0 - R3一般用作函数传参
      <br/>
      R4 - R11用来保存程序运算的中间结果或函数的局部变量
      <br/>
      在函数调用过程中
     </li>
    </ol>
    <ul>
     <li>
      注意在发生异常的时候 cortex-M0架构会自动将R0-R3压入栈中, 这也是为什么我们的PendSV只用压入R4 - R11
     </li>
    </ul>
    <ol start="2">
     <li>
      <p>
       R12 没啥用
      </p>
     </li>
     <li>
      <p>
       R13寄存器
       <br/>
       R13寄存器又叫做堆栈指针寄存器SP 总是指向当前正在运行的函数的栈帧
      </p>
      <ul>
       <li>
        <p>
         MSP 和 PSP
         <br/>
         对于 cortex-M3架构 存在两个SP 指针 一个 MSP 一个 PSP
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a86ea920300c413dbbc8c80341825d0d.png"/>
        </p>
        <ul>
         <li>
          PSP只能被用作线程模式 MSP可以在 线程/handler模式运行
          <br/>
          具体的等后面模式做详解
         </li>
        </ul>
       </li>
       <li>
        <p>
         FP 与 SP
         <br/>
         前面将函数调用过程的时候讲到了 栈帧是靠这俩寄存器FP和SP维护的 可是为啥没见FP寄存器呢?
         <strong>
          FP似乎通常是R11寄存器
         </strong>
         但不绝对
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       R14寄存器—LR寄存器
      </p>
      <ul>
       <li>
        用来保存保存上一级函数调用者的返回地址,这样当我们函数调用返回的时候就知道从哪里接着运行了
       </li>
       <li>
        当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行
       </li>
       <li>
        当中断发生的时候,LR寄存器的值会被设定为"EXC_RETURN"
       </li>
       <li>
        BL function
        <br/>
        当我们通过这样的指令跳转的时候 就会更新我们的LR寄存器的值了
       </li>
       <li>
        BX LR
        <br/>
        这个我们在RTOS的PendSV函数的最后会看到 BX LR 指令 这是因为PendSV结束调用时还处于特权模式（LR = EXC_RETURN）,而我们实际上是想返回线程模式的 所以用BX LR 而不是 MOV PC, LR
       </li>
      </ul>
     </li>
     <li>
      <p>
       R15寄存器—PC寄存器
       <br/>
       每取一次指令,PC的值会自动 + 8
      </p>
     </li>
     <li>
      <p>
       各种状态寄存器
       <br/>
       不必关心
      </p>
     </li>
     <li>
      <p>
       ARM的三级流水线
       <br/>
       一条指令的执行分为三步:
       <strong>
        取址, 译码 和 执行
       </strong>
       每一条都需要一个时钟周期 所以一条指令需要三个时钟周期。 那如果我们只有第一条指令执行完才执行第二条 就意味着取址单元
       <strong>
        会有两个时钟周期啥也不干
       </strong>
       。
       <br/>
       所以引入流水线就好了
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e616bd462b824a9a98dd810861c8abae.png"/>
      </p>
      <ul>
       <li>
        为什么是PC = PC + 8 呢
        <br/>
        这么理解
        <br/>
        “正在取值的指令” = “正在执行的指令” + 8 *
        <br/>
        就对了,反正这也是给你看的不是给机器看的…
        <br/>
        可以看到对于第一条指令add r0,r1,#5真正执行的时候,我们取的是第三条指令cmp r2,#3的值
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a3b86a61486d463caecb28fd63ea3920.png"/>
       </li>
      </ul>
     </li>
     <li>
      <p>
       顺序执行与乱序执行
       <br/>
       因为我们的指令很有可能下个指令依赖上个指令的结果,那此时三级流水线就出问题了
       <br/>
       比如上个指令的结果还没放回内存了 这边已经从内存开始取数据了
       <br/>
       此时就得加入空指令 暂停流水线了–效率低下
       <br/>
       所以就会有乱序执行–有专门逻辑电路进行分析做这个事
      </p>
     </li>
    </ol>
    <h2>
     <a id="2_48">
     </a>
     2.特权与模式
    </h2>
    <ol>
     <li>
      cortex-M3的模式
      <br/>
      两种模式 – handler模式与线程模式
      <br/>
      两种特权 – 用户级和特权级
     </li>
     <li>
      ARM的七种模式
      <ul>
       <li>
        用户模式（User）：这是唯一的非特权模式，
       </li>
       <li>
        快速中断模式（FIQ, Fast Interrupt Request）：
       </li>
       <li>
        标准中断模式（IRQ, Interrupt Request）
       </li>
       <li>
        管理模式（SVC, Supervisor）。
       </li>
       <li>
        中止模式（Abort）
       </li>
       <li>
        未定义模式（Undefined）
       </li>
       <li>
        系统模式（System）
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a9feed49bfb04c099e6cdb1abe31952c.png"/>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     用户级和特权级是针对
     <strong>
      访问权限
     </strong>
     :特权级访问寄存器不受限，用户级不行
     <br/>
     模式是针对
     <strong>
      运行状态
     </strong>
     : 触发异常了就得进入 handler模式 普通状态就是线程模式
     <br/>
     所以
     <strong>
      不能在用户级去操作handler模式
     </strong>
     ,但是线程模式下特权级还是用户级都无所谓啦
    </p>
    <ol>
     <li>
      复位后的状态
      <br/>
      复位后，处理器默认进入线程模式(MSP),特权极访问
      <br/>
      可以通过修改CTRL寄存器回到线程模式(PSP指针)
      <br/>
      但是线程模式可就不能修改CTRL寄存器了—那想回去怎么办?触发异常再异常中修该
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e63bc830a9cf4810880d57b09c2bd217.png"/>
     </li>
    </ol>
    <h2>
     <a id="3_71">
     </a>
     3.存储区映射
    </h2>
    <p>
     对于32位的处理器 地址空间是4个G 这4G对于ARM来说是这么定义的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/38ae29dfdc1244fcbd6c775f7a258a6f.png"/>
    </p>
    <h2>
     <a id="_75">
     </a>
     异常
    </h2>
    <p>
     对于所有的异常都进行了编号 前15种是系统异常 后面的都是外部中断
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2b662130674c45a1ad24e8a270e2f708.png"/>
    </p>
    <p>
     我们可以看到对于后面几个异常是可编程的,这个在
     <strong>
      RTOS的任务切换
     </strong>
     很重要,我们一般会把PendSV这个异常设定为最低优先级(0xffffffff)—为了在对所有中断都响应后在切换任务
    </p>
    <ul>
     <li>
      <p>
       抢占优先级和响应优先级
       <br/>
       高抢占优先级可以打断低抢占优先级
       <br/>
       但是同抢占优先级下,高响应优先级打断不了低的响应优先级
      </p>
     </li>
     <li>
      <p>
       中断向量表—处理中断的关键
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/27093cc5492047358ff50f61c2ae8018.png"/>
      </p>
      <p>
       这个是在starup.s中定义的 一般我们也不会有重新定义新的中断的需求
      </p>
     </li>
     <li>
      <p>
       对中断的响应
       <br/>
       正常来说需要我们在中断服务程序清除对应的标志位
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5f1a4f374c514d4fb30e9f753731a4c1.png"/>
      </p>
      <p>
       如果不清除会咋样—那就反复进入该中断处理程序操作
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d5fd167cd04240ca85b04ee5e797c606.png"/>
      </p>
      <p>
       如果极短时间多次请求–一般只会响应一次,因为中断就悬起了一次
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6257e1b86d134562b636a035b5ee5e18.png"/>
      </p>
      <p>
       假如在中断服务函数执行过程中,又触发了一次相同的中断–就会再执行一次
      </p>
     </li>
     <li>
      <p>
       NVIC中断控制器
      </p>
      <ul>
       <li>
        中断的悬起与解悬
       </li>
       <li>
        中断的优先级控制
       </li>
       <li>
        对中断响应的暂时屏蔽
       </li>
      </ul>
     </li>
    </ul>
    <h2>
     <a id="_103">
     </a>
     中断
    </h2>
    <ul>
     <li>
      msp与psp指针
      <br/>
      MSP:复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包括中断服务例程）
      <br/>
      PSP:由用户的应用程序代码使用。
      <br/>
      两个堆栈指针，同一时刻只能用一个。
      <br/>
      作用：提升程序健壮性。一定程度上保证应用的数据（栈）空间不会溢出到操作系统数据（栈）空间
     </li>
     <li>
      中断发生后做了什么
      <br/>
      当一个中断发生的时候 我们的内核到底做了什么
      <ul>
       <li>
        <p>
         寄存器入栈–保存现场
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ebf9a5269f0d41908c4d4c24a3f36671.png"/>
        </p>
       </li>
       <li>
        <p>
         地址总线从向量表查询中断向量
        </p>
       </li>
       <li>
        <p>
         更新寄存器–此时就进入handler模式了同时使用的也是MSP指针了
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e940e0d476084f3c929955aacf3e9c92.png"/>
        </p>
        <p>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ac6f936d6968467589bdf9fd3435d065.png"/>
        </p>
       </li>
       <li>
        <p>
         跳转执行中断服务程序
        </p>
       </li>
       <li>
        <p>
         中断返回–包括把之前保存的寄存器的值自动弹出来(恢复现场)
        </p>
       </li>
      </ul>
     </li>
     <li>
      中断的递归调用
      <br/>
      不用我等操心 但是需要我们注意的是就是给栈提供一个合适的大小
     </li>
     <li>
      中断与异常的区别
      <br/>
      中断——外部事件引起，正在运行的程序所不期望的–异步的
      <br/>
      异常——内部执行指令引起–同步的
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8c060ba2af274a8d83e0dcaca4742759.png"/>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353733313834352f:61727469636c652f64657461696c732f313436323539333939" class_="artid" style="display:none">
 </p>
</div>


