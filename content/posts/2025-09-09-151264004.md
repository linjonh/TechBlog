---
layout: post
title: "C语言文件操作"
date: 2025-09-09T17:34:05+0800
description: "磁盘（硬盘）上的文件是文件；程序文件数据文件。"
keywords: "C语言——文件操作"
categories: ['C']
tags: ['文件操作', 'C']
artid: "151264004"
arturl: "https://blog.csdn.net/2402_87037360/article/details/151264004"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151264004
    alt: "C语言文件操作"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151264004
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151264004
cover: https://bing.ee123.net/img/rand?artid=151264004
image: https://bing.ee123.net/img/rand?artid=151264004
img: https://bing.ee123.net/img/rand?artid=151264004
---



# C语言——文件操作



## 文件操作

### 一.文件

#### 1.为什么使用文件

没有文件，但因为我们写的程序的数据存在电脑的内存中，若程序退出，内存回收，数据就会丢失，再次运行程序，看不到上次的数据，如果要将数据进行**持久化的保存**，我们可以使用文件，只要硬件不损坏，数据就一直在。

#### 2.什么是文件

磁盘（硬盘）上的文件是文件；但在程序设计中，根据文件功能，文件有：**程序文件**，**数据文件**

##### 程序文件

程序文件包括**源程序文件**（后缀为.c），**目标文件**（windows环境后缀为.obj），**可执行程序**（windows环境后缀为.exe）。如：  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1caed3a9f9f54f10938c86d626b005d4.png)

##### 数据文件

文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。

##### 文件名

文件名包含三部分：文件路径+文件名主干+文件后缀  
例如：c:\code\c_9.2.txt  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/15be8db9893442fa856cf2c628df041a.png)

### 二 .二进制文件和文本文件

根据数据的组织形式，数据文件分为**文本文件**和**二进制文件**。

* 二进制文件：数据在内存中以二进制的形式存储，如果不加转换的输出到外村的文件中，就是**二进制文件**。  
  如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符⼀个字节），而以二进制形式输出，则在磁盘上只占4个字节  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a59d5a1407b54fa2a0038dc3dea87faa.png)
* 文本文件：如果要求在外存上以ASCII码的形式存储，则需要在存储前转换，以ASCII字符的形式存储的文件就是**文本文件**。例如：  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e116fd7a64414224a094daf3aebffa45.png)

### 三.文件的打开和关闭

#### 1.流和标准流

##### 流

我们都知道程序的数据需要输出到各种外部设备，当然也需要从外部设备获取数据，不同的外部设备的输入输出操作各不相同，因而抽象出了**流**的概念。  
C语言针对文件，画面，键盘等的数据输入输出操作都是通过流操作的，一般情况下，向流中读取数据，都是要打开流，然后操作。

##### 标准流

C语言程序在启动的时候，默认打开了三个流，我们使用scanf，printf等函数就可以输出到显示器界面：

* **stdin**——标准输入流，在大多数的环境中从键盘输入，scanf函数就是从标准输入流中读取数据的
* **stdout**——标准输出流，大多数的环境中输出至显示器界面，printf函数就是将信息输出到标准输入流中
* **stderr**——标准错误流，大多数环境中输出到显示器界面  
  这三个流的类型是：**FILE * **，通常称为**文件指针**，C语言中就是通过FILE*的文件指针来维护流的各种操作的。

#### 2.文件指针

每个被使用的文件都在内存中开辟了一个相应的**文件信息区**，用来存放文件的相关信息（文件的名字，文件状态及文件当前的位置）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名**FILE**,如：

```c
struct st
{
	char* _ptr;
	int _cnt;
	int _flag;
};
typedef struct FILE;

```

每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息。一般通过一个FILE的指针来维护这个FILE结构的变量。  
下面创建一个FILE*的指针变量：  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a117abbe8bbe48e69dcf177664308357.png)  
定义pf是一个指向FILE类型数据的指针变量，可以使其指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能访问该文件。  
即**通过文件指针变量能够间接找到与它关联的文件**  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4aa595a048494b7baaafd41cd252c521.png)

#### 3.文件的打开和关闭

文件在读写之前应该先**打开文件**，使用结束后应该**关闭文件**。在编写程序时，再打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系，ANSI C规定使用**fopen**函数打开文件，**fclose**关闭文件

##### fopen

```c
FILE* fopen(const char* filename,const char* mode);

```

* **功能**：该函数用来**打开参数**filename**指定的文件**，同时将打开的文件和一个流进行关联，后续对流的操作是通过fopen函数返回的指针来维护。具体对流的操作是通过参数mode来指定的。
* **返回值**：文件若成功打开，该函数将返回一个指向FILE对象的指针，该指针可用于后续操作中标识对应的流；若打开失败，则返回NULL指针，所以一定要fopen的返回值做判断，来验证文件是否打开成功
* mode表示对打开文件的操作方式  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b4458a8155db4049be5e9d14fb35aa97.png)
* 示例：  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f0993cc6ba91460796ac89150b724690.png)  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e6da177686534bf7ab37deb9e5b03208.png)  
  因为该文件不存在，所以打开失败；但可以使用指令创建，如：  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/49e1500edf9c47fcba381dc2b2bd7f45.png)  
  这时我们会发现，列表里多了一个data.txt文件，但该文件中是没有数据的，现在我们来打开该文件，这里我们要先知道：

> . ——>表示当前路径  
> . . ——>表示上一级路径

下面没有报错，就打开成功了  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8ad4920934544284b2769936cdbdb5a4.png)  
当然也可以使用绝对路径来打开文件，就是该文件从根目录上开始写的完整路径

##### fclose

```c
int fclose(FILE* stream);

```

* 功能：**关闭参数stream关联的文件**，并取消其关联关系。与该流关联的所有内部缓冲区均会解除关联并刷新：任何未写入的输出缓冲区内容将被写入，任何未读取的输入缓冲区内容将被丢弃  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/10474645c42744a69e940df59b8973f7.png)
* 返回值：成功关闭stream指向的流就会返回0，否则返回EOF

### 四.文件的顺序读写

#### 1.涉及函数

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/30692a769f0946ada8b9631b1bbf0e5b.png)  
上面的所有输入输出流指的是所有标准输入输出流

##### fputc

```c
int fputc(int character,FILE* stream);

```

* **功能**：将参数character指定的字符写入到stream指向的输出流中，**通常同于向文件或标准输入流写入字符**。再写入字符之后还会**调整指示器指向当前的位置**，随后该指示器自动向前移动一个位置。
* **参数**：  
  character：被写入的字符  
  stream：是一个FILE*类型的指针，字符会被写入流内部位置指示器当前指向的位置，随后该指示器自动向前移动一个位置
* **返回值**：  
  成功时返回写入的字符（int形式）  
  失败时返回EOF（-1），错误指示器会被设置，可通过ferror（）检查具体错误。
* **代码演示**

```c
#include<stdio.h>
int main()
{
	//写文件
	FILE* pf = fopen("data.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
		}
		//写文件
		fputc('a', pf);
		fputc('b', pf);
		fputc('c', pf);
		fputc('d', pf);
		//关文件
		fclose(pf);
		pf = NULL;
	}
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/45af2a08ffa042848bfe2ff296dfa1f9.png)  
当然也可以向标准输出流中写  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/34099737464540618bb3fe87533edde9.png)  
这就类似于putchar函数的功能：

```c
putchar('a');

```

当然我们也可以用循环来写文件：

```c
int i = 0;
for (i = 'a';i <= 'z';i++)
{
	fputc(i, pf);
}

```

##### fgetc

```c
int fgetc(FILE* stream);

```

* **功能**：**从参数stream指向的流中读取一个字符，**函数返回的是文件指示器当前指向的字符，读取这个字符后，文件指示器自动前进到下一个字符。
* **参数**：stream：FILE*类型的文件指针，可以是stdin，也可以是其他输入流的指针。如果是stdin就从标准输入流读取数据。如果是文件流指针，就从文件读取数据。
* **返回值**：  
  成功时返回读取的字符（int）；  
  若调用时流已处于文件末尾，函数返回EOF并设置流的文件结束指示器（feof）。  
  若发生读取错误，函数返回EOF并设置流的错误指示器（ferror）
* **代码示例**：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写文件
	int i = 0;
	for (i = 'a';i <= 'z';i++)
	{
		fputc(i, pf);
	}
	//读文件
	int ch = fgetc(pf);
	printf("%c\n", ch);
	putchar(ch);
	fputc(ch, stdout);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
	}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ec35e59379bf430eb318a9e0c200db5f.png)  
当然我们也可以使用循环多读几个

```c
//从键盘读取数据
int i = 0;
for (i = 0;i < 10;i++)
{
	int ch = fgetc(pf);
	fputc(ch, stdout);
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bfcf69a3417d4de7ae203223d22cf314.png)

##### feof和ferror

```c
int feof(FILE* stream);
//检测stream指针指向的流是否遇到文件末尾
int ferror(FILE* stream);
//检测stream指针指向的流是否发生读/写错误

```

* 在读取文件时，遇到文件末尾，文件读取就会结束。这是读取函数会在对应的流上设置一个文件结束的指示符，这个文件结束指示符可以通过feof函数检测到。如果feof函数检测到文件结束指示符已经被设置，则返回非0的值，如果没有设置则返回0.
* 在读/写文件时，发生了读/写错误，文件读取就会结束。这时读/写函数会在对应的流上设置一个错误指示符，这个错误指示符可以通过ferror函数检测到。如果ferror函数检测到错误指示符已经被设置，则返回非0的值，如果没有设置则返回0。
* 代码示例

```c
//测试feof
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	int i = 0;
	for (i = 0;i < 28;i++)
	{
		int c = fgetc(pf);
		if (c == EOF)
		{
			if (feof(pf))
				printf("遇到文件末尾了\n");
			else if (ferror(pf))
				printf("读取发生了错误\n");
		}
		else
		{
			fputc(c, stdout);
		}
	}
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b72f2be795ca4252a3709bcd6ad7a41e.png)  
**以写的形式打开文件后，再去读文件，就会发生错误**，如下：

```c
//测试ferror
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	int i = 0;
	for (i = 0;i < 28;i++)
	{
		int c = fgetc(pf);
		if (c == EOF)
		{
			if (feof(pf))
				printf("遇到文件末尾了\n");
			else if (ferror(pf))
				printf("读取发生了错误\n");
		}
		else
		{
			fputc(c, stdout);
		}
	}
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9fec340f44ba4ca8afde923647158d1b.png)

##### fputs

```c
int fputs(const char*str,FILE*stream);

```

* **功能**：**将参数str指向的字符串写入到参数stream指定的流中**（不含结尾\0），适用于文件流或标准输出（stdout）
* **参数**：  
  str：str是指针，指向了要写入的字符串（必须以\0结尾）  
  stream：是一个FILE*的指针，指向了要写入字符串的流
* **返回值**：  
  成功时返回非负整数；  
  失败时返回EOF(-1),同时会设置流的错误指示器，可以使用ferror（）检查错误原因。
* **代码示例**：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写文件
	fputs("abc\n", pf);
	fputs("def", pf);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/89550e964756448792658ef4115819c8.png)

##### fgets

```c
char* fgets(char* str,int num,FILE* stream);

```

* **功能**：**从stream指定输入流中读取字符，至读取到换行符**，文件末尾（EOF）或达到指定字符数（包含结尾的空字符\0），然后读取到的字符串存储到str指向的空间中。
* **参数**：  
  str：指向字符数组的指针，str指向的空间用于存储读取到的字符串。  
  num：最大读取字符数（包含结尾的\0,实际最多读取num-1个字符）。  
  stream：输入流的文件指针（如文件流或stdin）。
* **返回值**：  
  成功时返回str指针；  
  若再尝试读取字符时遇到文件末尾，则设置文件结束指示器，并返回NULL，需通过feof（）检测；  
  若发生读取错误，则设置流错误指示器，并返回NULL，通过ferror（）检测。
* 注意：  
  若读取到换行符（\n），会将其包含在字符串中（除非超出num-1限制），然后以\0结尾；  
  文件末尾无换行符时，字符串以\0结尾，不包含\n
* **代码演示**：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	char arr[20] = "xxxxxxxxxxxxxxxxx";
	fgets(arr, 20, pf);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bd8e6d3451134956b32deb26624a4c79.png)

##### fprintf

```c
int fprintf(FILE* stream,const char* format,...);
//类比printf

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/133d360b525e44799f0accf626226102.png)

* **功能**：**将格式化数据写入指定文件流的函数**，与printf类似，但可以输出到任意输出流（磁盘文件，标准输出，标准错误等），而不仅限于控制台。
* **参数**：  
  stream：指向FILE对象的指针，表示要写入的文件流（stdout，文件指针等）  
  format：格式化字符串，包含要写入的文本和格式说明符（如%d，%s等）  
  … :可变参数列表，提供与格式字符串中说明符对应的数据
* **返回值**：  
  成功时，返回写入的字符总数（非负值）；  
  失败是，先设置对应流的错误指示器，再返回负值，可以通过ferror（）来检测
* **代码演示**：

```c
#include<stdio.h>
struct Stu
{
	char name[20];
	int age;
	float score;
};
int main()
{
	struct Stu s = { "zhangsan",20,85.5f };
	FILE* pf = fopen("data.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写文件
	fprintf(pf, "%s %d %f\n", s.name, s.age, s.score);
		//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0bfc19d42e214506b42763df4d9f8314.png)  
当然也可以写到控制台上：

```c
	//写文件
	fprintf(stdout, "%s %d %f\n", s.name, s.age, s.score);

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/29408cda4ce247279280d88dfa4c2c13.png)

##### fscanf

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f8b0effc7ef945af9669d57c1f7ff6b7.png)

* **功能**：fscanf是从指定文件流中读取格式化数据的函数，它类似于scanf，但可以指定输入源（如文件，标准输入等），而非仅限于控制台，适用于从文件解析结构化数据（整数，浮点数，字符串等）。
* **返回值**：  
  成功时，函数返回成功填充到参数列表中的项数。该值可能与预期项数一致，也可能因以下原因少于预期（甚至为零）：  
  （1）格式和数据匹配失败；  
  （2）读取发生错误；  
  （3）到达文件末尾（EOF）。  
  如果在成功读取任何数据之前发生：  
  （1）发生读取错误，会在对应流上设置错误指示符，则返回EOF  
  （2）到达文件末尾，会在对应流上设置文件结束指示符，则返回EOF
* **代码演示**：

```c
#include<stdio.h>
struct Stu
{
	char name[20];
	int age;
	float score;
};
int main()
{
	struct Stu s = { 0 };
	FILE* pf = fopen("data.txt", "r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	fscanf(pf, "%s %d %f\n", s.name,&(s.age),&(s.score));
	printf("%s %d %f\n", s.name, s.age, s.score);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b20f52b701394d22bfbfc22e80b2ecb2.png)  
以上的函数是能写和读到文件中的文本信息  
下面的两个函数以二进制的形式写文件和读文件

##### fwrite

```c
size_t fwrite(const void* ptr,size_t count,FILE* stream);

```

* **功能**：函数用于将数据块写入stream指向的文件流中，以2进制的形式写入
* **参数**：  
  ptr：指要写入的数据块的指针  
  size：要写入的每个数据项的大小（字节为单位）  
  count：要写入的数据项的数量  
  stream：指向FILE类型结构体的指针，指向了要写入数据的文件流
* **返回值**：返回实际写入的数据项数量。如果发生错误，则返回值可能小于count
* **注意**：  
  在使用fwrite（）之前，需要确保文件已经以二进制可写方式打开；该函数通常用于二进制数据的写入，如果写入文本数据，请谨慎处理换行符和编码的问题。
* **代码演示**：

```c
#include<stdio.h>
struct S
{
	char name[20];
	int age;
	float score;
};
int main()
{
	struct S s = { "zhangsan",20,95.5 };
	FILE* pf=fopen("data.txt", "wb");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写文件
	fwrite(&s, sizeof(struct S), 1, pf);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

以二进制的形式打开文件就会得到  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/91cdd856f627486b847f7c42ac69b1e1.png)

##### fread

```c
size_t fread(void* ptr,size_t size,size_t count,FILE* stream);

```

* **功能**：函数用于从stream指向的文件流中读取数据块，并将其存储到ptr指向的内存缓冲区中。
* **返回值**：返回实际读取的数据块数量
* **注意**：  
  （1）使用fread（）之前，需要确保文件已经以二进制可读方式打开；  
  （2）ptr指向的内存区域必须足够大，以便存储指定数量大小的数据块；  
  （3）如果fread（）成功读取了指定数量的数据块，则返回值等于count；如果读取数量小于count，则可能已经达到文件结尾或者发生了错误；  
  （4）在二进制文件读取时，fread（）是常用的函数，但对于文本文件读取，通常使用fgets（）或者fscanf（）
* **代码演示**：

```c
#include<stdio.h>
struct S
{
	char name[20];
	int age;
	float score;
};
int main()
{
	struct S s = { "zhangsan",20,95.5 };
	FILE* pf=fopen("data.txt", "rb");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	int r=fread(&s, sizeof(struct S), 1, pf);
if (r != 1)
{
	//遇到了文件末尾
	if (feof(pf))
	{
		printf("遇到了文件末尾\n");
	}
	else if (ferror(pf))
	{
		printf("读取过程中发生了错误\n");
	}
}
else
{
	printf("%s %d %f\n", s.name, s.age, s.score);
}
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c207e399c2e94581a132fdc1108b466d.png)

#### 2.对比一组函数

> * scanf/printf——**针对标准输入/标准输出的格式化的输入函数和输出函数**
> * fscanf/fprintf——**针对所有输入流/所有输出流的格式化的输入函数和输出函数**  
>   sscanf/sprintf——**将格式化的数据转化成字符串/从字符中提取格式化的数据**

##### sprintf

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/35f43314f2464d32b21fdc896850d447.png)

* **功能**：将格式化数据写入字符数组（字符串）。它类似于printf，但输出目标不是控制台或文件，而是用户指定的内存缓冲区。常用于动态生成字符串，拼接数据或转换数据格式。即**将格式化的数据转换成一个字符串**。
* **参数**：  
  str：指向字符数组的指针，用于存储生成的字符串（需要确保足够大以防止溢出）  
  format：格式化字符串，定义输出格式（%d，%f，%s等）  
  . . . :可变参数列表，提供与格式字符串中说明符对应的数据。
* **返回值**：  
  成功时，返回写入buffer的字符数（不包括结尾的空字符\0）  
  失败时：返回负值
* **代码演示**：

```c
#include<stdio.h>
struct S
{
	char name[20];
	int age;
	float score;
};
int main()
{
	struct S s = { "zhangsan",20,95.5f };
	char buf[100] = { 0 };
	sprintf(buf,"%s ,%d ,%f",s.name,s.age,s.score);
	printf("%s\n ", buf);
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5bd0d5de060b4046afa571f1dc8f50b8.png)

##### sscanf

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/58b396b47932480b8883525d90b1d39c.png)

* **功能**：**从字符串中读取格式化数据**，它与 scanf类似，但输入源是内存中的字符串而非控制台或文件。常用于解析字符串中的结构化数据（如提取文字，分割文本）
* **返回值**：  
  成功时：返回成功解析并赋值的参数数量（非负值）  
  失败或非匹配任何数据：若输入结束或解析失败，返回EOF（-1）
* **代码演示**：

```c
#include<stdio.h>
struct S
{
	char name[20];
	int age;
	float score;
};
int main()
{
	char buf[100] = { "zhangsan 100 95.5f" };
	struct S t = { 0 };
	sscanf(buf,"%s %d %f", t.name, &(t.age), &(t.score));//结构体数据
	printf("%s %d %f\n", t.name, t.age, t.score);

	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/072b1d033905427a8b8f25ec85ba0837.png)

### 五.文件的随机读写

#### fseek

* **功能**：**根据文件指针的位置和偏移量来定位文件指针**（文件内容的光标）
* **代码**：

```c
int fseek(FILE* stream,long int offset,int origin);

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/595e410bf5944bd0876361c46a049eee.png)

* **函数使用示例**：当我们没有指定光标位置，没有设定偏移量的时候，打开文件每次的输出不能随意按照我们的想法来输出：  
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d387a24da5724a33a5a662cdeb450426.png)

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt","r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	int ch = fgetc(pf);
	printf("%c\n", ch);
	ch = fgetc(pf);
	printf("%c\n", ch);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5ce4d6643ba94fc0a9d84b6c4daa84c7.png)  
当我们想输出a和g，那就使用fseek函数，让光标停在文件开始的位置，给第二个参数设定偏移量6后：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt","r");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	//写文件也和读文件差不多
	int ch = fgetc(pf);
	printf("%c\n", ch);
	//从文件开始位置偏移
	fseek(pf, 6, SEEK_SET);
	//从文件末尾偏移
	//	fseek(pf, -3, SEEK_END);
	ch = fgetc(pf);
	printf("%c\n", ch);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7079ed3a2753467496180412497e6ebc.png)

#### ftell

* **功能**：**返回文件指针相对于起始位置的偏移量**
* **代码**：

```c
long int ftell(FILE* stream);

```

* **示例**：我们来写一个文件，然后进行光标偏移量的查找：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data2.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
		//写文件
	fputs("abcdefghi", pf);//写入字符串
	fseek(pf, -3, SEEK_END);
	//偏移后，此时文件指针停在g前
	fputc('x', pf);
	//x覆盖g，文件指针停在x后
	int ret = ftell(pf);
	//ftell计算相对于文件指针位置相当于起始位置偏移量：7
	printf("%d\n", ret);
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/14ff05c7d7854ccbb84ecb0880c3c16c.png)

#### rewind

* **功能**：**让文件指针的位置回到文件的起始位置**
* **代码**：

```c
void rewind(FILE* stream);

```

* **示例**：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data2.txt", "w");
	if (pf == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写文件
	fputs("abcdefghi", pf);
	fseek(pf, -3, SEEK_END);
	fputc('x', pf);
	int ret = ftell(pf);
	printf("文件的字节数：%d\n", ret);
	rewind(pf);// 等价于fseek(pf, 0, SEEK_END);
	//文件指针回到了文件的起始位置了
	//关文件
	fclose(pf);
	pf = NULL;
	return 0;
	}

```

### 七.文件缓冲区

ANSI C标准采用“**缓冲文件系统**”——（是指系统自动的在内存中为程序中每一个正在使用的文件开辟一块“**文件缓冲区**”）处理数据文件  
缓冲：完全缓冲；行缓冲，无缓冲  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1e6725fe24a643479b06380e236d73f3.png)

#### fflush

* **代码**：

```c
int fflush(FILE* stream);

```

* **功能**：**强制刷新stream指定的缓冲区**  
  对**输入流**：将缓冲区中未写入的数据立即写入文件  
  对**输出流**：行为由具体实现决定，非C语言标准行为（可清空输入缓冲区）  
  参数为NULL时：刷新打开所有的输出流
* **注意事项**：  
  （1）仅对输出流或更新流（最后一次操作为输出）有明确刷新行为  
  （2）输入流的刷新行为不可移植（如清空输入缓冲区是非标准特性）  
  （3）程序正常终止（exit）或调用fclose时会自动刷新，但程序崩溃时缓冲区数据可能丢失
* **代码示例**：

```c
#include <stdio.h>
#include <windows.h>
int main()
{
	FILE* pf = fopen("test.txt", "w");
	fputs("abcdef", pf);//先将代码放在输出缓冲区
	printf("睡眠10秒-已经开始写数据了，打开test.txt文件，发现文件没有内容\n");
	Sleep(10000);
	printf("刷新缓冲区\b");
	fflush(pf);
	//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）
	printf("再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\n");
	Sleep(10000);
	fclose(pf);
	//注意：fclose在关闭文件的时候，也会刷新缓冲区
	pf = NULL;
	return 0;
}

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/be32fb3581f64fd4a33c127d93f37c29.png)  
我们发现此时文件是没有内容的：  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/33e2388501694ece997176a4a6f6afef.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a17284e4218d4ceb9780b373b65be06e.png)  
现在文件有了内容：  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4f016a65126f437cbbdd86099449191e.png)

### 八.更新文件

| **行为** | “ r+ ” | “w+” | “a+” |
| --- | --- | --- | --- |
| **解释** | 可读/可写 | 可读/可写 | 可读/可写 |
| **文件不存在时** | 打开失败 | 自动创建新文件 | 自动创建新文件 |
| **文件存在时** | 保留内容 | 清空内容 | 保留内容 |
| **初始文件指针位置** | 文件开头 | 文件开头 | 文件末尾 |
| **写入是否覆盖原有数据** | 是（可定位覆盖） | 是（内容已清空，从头写入） | 否（默认是在文件末尾写数据） |
| **典型用途** | 修改文件部分内容 | 创建新文件或完全重写旧文件 | 在文件末尾追加数据，比如记录日志 |

**注意**：

* 在写完文件后，要继续读文件的时候，在读取之前一定要使用fflush（）刷新文件缓冲区，或者使用fseek（），rewind（）重新定位文件指示器的位置
* 在读写完文件后，需要继续写文件，写之前使用fseek（），rewind（）重新定位文件指示器的位置。

代码示例：

```c
#include<stdio.h>
int main()
{
	FILE* pf = fopen("data.txt", "w+");
	if (pf == NULL);
	{
		perror("fopen");
		return 1;
	}
	//写文件
	fputs("abcdefghi", pf);
	fflush(pf);//刷新缓冲区
	//读文件
	fseek(pf, 0, SEEK_SET);
	int ch = fgetc(pf);
	printf("%c\n", ch);
	//abcdefghi
	fseek(pf, 2, SEEK_CUR);
	fputs("xxx", pf);
	//abcxxxghi
	fclose(pf);
	pf = NULL;
	return 0;
}

```

> 本次内容到这里就结束了，感谢观看！



