---
layout: post
title: "图论FLOYD弗洛伊德算法-最短路径-"
date: 2025-03-16 11:00:33 +0800
description: "弗洛伊德算法用于求多源最短路径，也就是求两个点的最短路径，其思想是基于动态规划。"
keywords: "【图论】FLOYD弗洛伊德算法-最短路径 "
categories: ['C']
tags: ['算法', '学习', '图论']
artid: "146291150"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146291150
    alt: "图论FLOYD弗洛伊德算法-最短路径-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146291150
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146291150
cover: https://bing.ee123.net/img/rand?artid=146291150
image: https://bing.ee123.net/img/rand?artid=146291150
img: https://bing.ee123.net/img/rand?artid=146291150
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【图论】FLOYD弗洛伊德算法-最短路径
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88" name="%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">
     弗洛伊德算法是什么
    </h2>
    <p>
     弗洛伊德算法用于求多源最短路径，也就是求两个点的最短路径，其思想是基于动态规划。
    </p>
    <h2 id="%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E6%AD%A5%E9%AA%A4" name="%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E6%AD%A5%E9%AA%A4">
     弗洛伊德算法的组成和步骤
    </h2>
    <h3 id="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5dis%EF%BC%9A" name="%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5dis%EF%BC%9A">
     邻接矩阵dis：
    </h3>
    <p>
     若有n个点，则构建n*n的邻接矩阵 如果路径带权值，则构建int数组：存储的数值代表两点间的最短距离，如果为INF，则两点不连接。如果路径不带权值，则构建bool数组：1代表两点有路径，0代表没有。
    </p>
    <p>
     code：
    </p>
    <pre><code class="language-cpp">int dis[n+1][n+1] 

bool dis[n+1][n+1]</code></pre>
    <p>
     构建n*n的 最少要n+1 因为数组下标从0开始
    </p>
    <h3 id="%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" name="%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">
     初始化：
    </h3>
    <p>
     对于一个点自己来说，自己到自己没有距离，初始化为0。其他值全部初始化为INF，默认任意两点之间没有距离。
    </p>
    <p>
     code:
    </p>
    <pre><code class="language-cpp">for(int i=1;i&lt;=n;++i){
    for(int j=1;j&lt;=n;++j){
        if(i==j){
            dis[i][j]=0;
        }else{
            dis[i][j]=INF;
        }
    }
}</code></pre>
    <h3 id="%E9%81%8D%E5%8E%86%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%EF%BC%9A" name="%E9%81%8D%E5%8E%86%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%EF%BC%9A">
     遍历邻接关系：
    </h3>
    <p>
     code1:
    </p>
    <p>
     无边权
    </p>
    <pre><code class="language-cpp">//不带权值的情况
int x,y;//用于输入一条边的两个点
while(m--){
    cin&gt;&gt;x&gt;&gt;y;
    dis[x][y]=1;
    dis[y][x]=1;
}</code></pre>
    <p>
     code2:
    </p>
    <p>
     有边权
    </p>
    <pre><code class="language-cpp">//带权值的情况
int x,y;//用于输入一条边的两个点
int val;//用于输入权值
while(m--){
    cin&gt;&gt;x&gt;&gt;y&gt;&gt;val;
    dis[x][y]=val;
    dis[y][x]=val;
}</code></pre>
    <h3 id="FLOYD%E6%A0%B8%E5%BF%83%EF%BC%9A" name="FLOYD%E6%A0%B8%E5%BF%83%EF%BC%9A">
     FLOYD核心：
    </h3>
    <p>
     是通过一个三层循环，利用动态规划的思想，先确定中转点k，再枚举每一对点i j 。看i通过k到j会不会比本来的dis[i][j]更近，如果更近就更新。所以最外层循环为枚举中转点K，内两层循环为枚举每一对点。
    </p>
    <p>
     所以状态转移方程就是:
    </p>
    <p>
     dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    </p>
    <p>
     code:
    </p>
    <pre><code class="language-cpp"> //floyd 计算最短路径
        for(int k=1;k&lt;=n;++k){//中转点
            for(int i=1;i&lt;=n;++i){//每一对邻接点
                for(int j=1;j&lt;=n;++j){
                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
                }
            }
        }</code></pre>
    <h2 id="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%9A" name="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%9A">
     最短路径的存储：
    </h2>
    <p>
     上述代码只完成了最短距离的计算，无法输出最短的路径。
    </p>
    <p>
     我们只需要构建一个path[n][n]数组，在FLOYD算法的最内层。如果有更新dis[i][j]，则同步更新记录 i到j的最短路径的中转点即可。
    </p>
    <h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96path%EF%BC%9A" name="%E5%88%9D%E5%A7%8B%E5%8C%96path%EF%BC%9A">
     初始化path：
    </h3>
    <p>
     默认path[i][j]=j 就是两个点的最短路径都默认初始化为要经过右边的终点。
    </p>
    <pre><code class="language-cpp"> for(int i=1;i&lt;=n;++i)
        for(int j=1;j&lt;=n;++j) {
            path[i][j]=j;
        } </code></pre>
    <h3 id="%E5%B8%A6%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84%E7%9A%84FLOYD%E7%AE%97%E6%B3%95" name="%E5%B8%A6%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84%E7%9A%84FLOYD%E7%AE%97%E6%B3%95">
     带记录路径的FLOYD算法
    </h3>
    <pre><code class="language-cpp"> //floyd 计算最短路径
        for(int k=1;k&lt;=n;++k){//中转点
            for(int i=1;i&lt;=n;++i){//每一对邻接点
                for(int j=1;j&lt;=n;++j){
                    if(dis[i][j]&gt;dis[i][k]+dis[k][j]){
                        dis[i][j]=dis[i][k]+dis[k][j];
                        path[i][j]=k;//更新最短路径的中转点
                    }
                    
                }
            }
        }</code></pre>
    <h3 id="%E8%BE%93%E5%87%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%3A" name="%E8%BE%93%E5%87%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%3A">
     输出最短路径:
    </h3>
    <p>
     比如要求3 到 5的最短路径 ：先输出起点3。由于我们初始化path数组时 默认path[i][j]=j，所以每次记录path[i][j]=k，用一个while循环判断 只要k!=j 就先输出k 代表会途径这个点 再记录path[k][j]，重新循环判断，直到k==j。 最后再输出终点
    </p>
    <pre><code class="language-cpp">int s,e;//代表起点和终点
cin&gt;&gt;s&gt;&gt;e;
cout&lt;&lt;s;//先输出起点
//先记录中转点 
int k=path[s][e];
while(k!=e){//如果中转点不是终点
    cout&lt;&lt;"-&gt;"&lt;&lt;k;//输出中转点
    k=path[k][e];//记录新的中转点 重新循环
}
cout&lt;&lt;"-&gt;"&lt;&lt;e;//输出终点</code></pre>
    <h2 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A" name="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A">
     完整代码：
    </h2>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
#define INF 0x3f3f3f3f
const int n=5;//10个点
int m=5;//十条边
int main(){
    int dis[n+1][n+1];
    int path[n+1][n+1];
    for(int i=1;i&lt;=n;++i){//初始化dis 和path
        for(int j=1;j&lt;=n;++j){
            path[i][j]=j;
            if(i==j){
                dis[i][j]=0;
            }else{
                dis[i][j]=INF;
            }
        }
    }

    //比如有m对邻接关系 或者说m条边
    //带权值的情况
    int x,y;//用于输入一条边的两个点
    int val;//用于输入权值
    while(m--){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;val;
        dis[x][y]=val;
        dis[y][x]=val;
    }
     //floyd 计算最短路径
        for(int k=1;k&lt;=n;++k){//中转点
            for(int i=1;i&lt;=n;++i){//每一对邻接点
                for(int j=1;j&lt;=n;++j){
                    if(dis[i][j]&gt;dis[i][k]+dis[k][j]){
                        dis[i][j]=dis[i][k]+dis[k][j];
                        path[i][j]=k;//更新最短路径的中转点
                    }

                }
            }
        }
    int s,e;//代表起点和终点
    while(cin&gt;&gt;s&gt;&gt;e){
        //先判断两点之间是否有最短路径
        if(dis[s][e]==INF){//两点到不了

        cout&lt;&lt;s&lt;&lt;"和"&lt;&lt;e&lt;&lt;"无最短路径";
        }else{
            cout&lt;&lt;s&lt;&lt;"和"&lt;&lt;e&lt;&lt;"最短距离为："&lt;&lt;dis[s][e]&lt;&lt;endl;//先输出最短距离
            cout&lt;&lt;s;//先输出起点
            //先记录中转点
            int k=path[s][e];
            while(k!=e){//如果中转点不是终点
                cout&lt;&lt;"-&gt;"&lt;&lt;k;//输出中转点
                k=path[k][e];//记录新的中转点 重新循环
            }
            cout&lt;&lt;"-&gt;"&lt;&lt;e&lt;&lt;endl;//输出终点
        }
    }


    return 0;
}






</code></pre>
    <h3 id="%E6%B5%8B%E8%AF%95%EF%BC%9A" name="%E6%B5%8B%E8%AF%95%EF%BC%9A">
     测试：
    </h3>
    <p>
     <img alt="" height="349" src="https://i-blog.csdnimg.cn/direct/bd8a092a70a14aa5bf6845d81e28dd03.png" width="615"/>
    </p>
    <p>
     <img alt="" height="769" src="https://i-blog.csdnimg.cn/direct/911f5cea41fc409c94b7d5fc331c866b.png" width="1500"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36323333353632392f:61727469636c652f64657461696c732f313436323931313530" class_="artid" style="display:none">
 </p>
</div>


