---
layout: post
title: "scala有关-类-的知识点与Java的比较"
date: 2025-03-06 17:42:09 +0800
description: "Scala 的类定义和 Java 类似，但语法更简洁。Scala 示例scala复制代码var name: String = \"\" // 可变变量val age: Int = 0 // 不可变变量（类似Java的final）Java 对比java复制代码关键点Scala 中成员变量（字段）可以直接声明在类体中，不需要放在构造器中。var表示可变变量，val表示不可变变量（类似 Java 的final方法定义用def，返回值类型在参数后（如Unit表示无返回值，类似 Java 的void。"
keywords: "scala有关 类 的知识点与Java的比较"
categories: ['Scala']
tags: ['开发语言', 'Scala']
artid: "146076313"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146076313
    alt: "scala有关-类-的知识点与Java的比较"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146076313
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146076313
cover: https://bing.ee123.net/img/rand?artid=146076313
image: https://bing.ee123.net/img/rand?artid=146076313
img: https://bing.ee123.net/img/rand?artid=146076313
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     scala有关 类 的知识点与Java的比较
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4 id="1. 类的定义：最简形式">
     1. 类的定义：最简形式
    </h4>
    <p>
     Scala 的类定义和 Java 类似，但语法更简洁。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code class="language-Scala">class Person {
  var name: String = ""  // 可变变量
  val age: Int = 0       // 不可变变量（类似Java的final）
  
  def sayHello(): Unit = {
    println(s"Hello, I'm $name, $age years old.")
  }
}</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public class Person {
    private String name = "";
    private final int age = 0;

    public void sayHello() {
        System.out.println("Hello, I'm " + name + ", " + age + " years old.");
    }
}</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      Scala 中成员变量（字段）可以直接声明在类体中，不需要放在构造器中。
     </li>
     <li>
      <code>
       var
      </code>
      表示可变变量，
      <code>
       val
      </code>
      表示不可变变量（类似 Java 的
      <code>
       final
      </code>
      ）。
     </li>
     <li>
      方法定义用
      <code>
       def
      </code>
      ，返回值类型在参数后（如
      <code>
       Unit
      </code>
      表示无返回值，类似 Java 的
      <code>
       void
      </code>
      ）。
     </li>
    </ul>
    <hr/>
    <h4 id="2. 构造器：主构造器 vs 辅助构造器">
     2. 构造器：主构造器 vs 辅助构造器
    </h4>
    <p>
     Scala 的构造器分为
     <strong>
      主构造器
     </strong>
     和
     <strong>
      辅助构造器
     </strong>
     ，这是与 Java 不同的重要特性。
    </p>
    <h5 id="(1) 主构造器（Primary Constructor）">
     (1) 主构造器（Primary Constructor）
    </h5>
    <p>
     主构造器是类定义的一部分，直接写在类名后面。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>class Person(var name: String, val age: Int) {
  def sayHello(): Unit = {
    println(s"Hello, I'm $name, $age years old.")
  }
}</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public class Person {
    private String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, I'm " + name + ", " + age + " years old.");
    }
}</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      主构造器的参数直接写在类名后的括号中。
     </li>
     <li>
      如果参数用
      <code>
       var
      </code>
      或
      <code>
       val
      </code>
      修饰，会自动生成对应的公有字段（类似 Java 的 public 成员变量）。
     </li>
     <li>
      如果参数不加
      <code>
       var
      </code>
      /
      <code>
       val
      </code>
      ，则参数仅作为构造器参数使用，不会成为类的字段。
     </li>
    </ul>
    <hr/>
    <h5 id="(2) 辅助构造器（Auxiliary Constructor）">
     (2) 辅助构造器（Auxiliary Constructor）
    </h5>
    <p>
     辅助构造器通过
     <code>
      def this(...)
     </code>
     定义，且必须调用主构造器。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>class Person(var name: String, val age: Int) {
  // 辅助构造器1
  def this(name: String) {
    this(name, 0)  // 必须调用主构造器
  }

  // 辅助构造器2
  def this() {
    this("Anonymous")  // 调用辅助构造器1，最终仍调用主构造器
  }
}</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public class Person {
    private String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this(name, 0);
    }

    public Person() {
        this("Anonymous");
    }
}</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      辅助构造器必须首先调用主构造器（或另一个辅助构造器）。
     </li>
     <li>
      主构造器是 Scala 类的唯一入口。
     </li>
    </ul>
    <hr/>
    <h4 id="3. 继承：extends 关键字">
     3. 继承：
     <code>
      extends
     </code>
     关键字
    </h4>
    <p>
     Scala 的继承机制与 Java 类似，但方法覆盖必须用
     <code>
      override
     </code>
     关键字。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>class Animal {
  def speak(): Unit = {
    println("Animal speaks")
  }
}

class Dog extends Animal {
  override def speak(): Unit = {
    println("Dog barks")
  }
}</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public class Animal {
    public void speak() {
        System.out.println("Animal speaks");
    }
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Dog barks");
    }
}</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      用
      <code>
       extends
      </code>
      继承父类。
     </li>
     <li>
      覆盖方法必须加
      <code>
       override
      </code>
      关键字（Java 的
      <code>
       @Override
      </code>
      是注解，Scala 的
      <code>
       override
      </code>
      是强制语法）。
     </li>
    </ul>
    <hr/>
    <h4 id="4. 抽象类：abstract 关键字">
     4. 抽象类：
     <code>
      abstract
     </code>
     关键字
    </h4>
    <p>
     抽象类用于定义未实现的方法或字段，类似 Java 的抽象类。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>abstract class Shape {
  def area(): Double  // 抽象方法（无实现）
  val color: String   // 抽象字段
}

class Circle(radius: Double, override val color: String) extends Shape {
  override def area(): Double = Math.PI * radius * radius
}</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public abstract class Shape {
    public abstract double area();
    public abstract String getColor();
}

public class Circle extends Shape {
    private double radius;
    private String color;

    public Circle(double radius, String color) {
        this.radius = radius;
        this.color = color;
    }

    @Override
    public double area() {
        return Math.PI * radius * radius;
    }

    @Override
    public String getColor() {
        return color;
    }
}</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      抽象方法用
      <code>
       def
      </code>
      定义，无方法体。
     </li>
     <li>
      抽象字段用
      <code>
       val
      </code>
      或
      <code>
       var
      </code>
      声明，无初始值。
     </li>
     <li>
      子类必须实现所有抽象成员。
     </li>
    </ul>
    <hr/>
    <h4 id="5. 伴生对象：object 关键字">
     5. 伴生对象：
     <code>
      object
     </code>
     关键字
    </h4>
    <p>
     Scala 没有静态成员（
     <code>
      static
     </code>
     ），而是通过
     <strong>
      伴生对象
     </strong>
     实现类似功能。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>class Person(val name: String, val age: Int)

// 伴生对象（与类同名）
object Person {
  def apply(name: String, age: Int): Person = new Person(name, age)
  def apply(name: String): Person = new Person(name, 0)
}

// 使用伴生对象创建实例
val p1 = Person("Alice", 30)  // 调用 apply 方法
val p2 = Person("Bob")</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public static Person create(String name, int age) {
        return new Person(name, age);
    }

    public static Person create(String name) {
        return new Person(name, 0);
    }
}

// 使用静态工厂方法
Person p1 = Person.create("Alice", 30);
Person p2 = Person.create("Bob");</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      伴生对象与类同名，定义在同一个文件中。
     </li>
     <li>
      通过
      <code>
       apply
      </code>
      方法实现类似构造器的调用语法。
     </li>
     <li>
      伴生对象可以访问类的私有成员。
     </li>
    </ul>
    <hr/>
    <h4 id="6. 特质（Trait）：类似接口的增强版">
     6. 特质（Trait）：类似接口的增强版
    </h4>
    <p>
     Scala 的
     <code>
      trait
     </code>
     类似 Java 的接口，但支持方法实现和多重继承。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>trait Speaker {
  def speak(): Unit  // 抽象方法
  def greet(): Unit = {
    println("Hello!")  // 具体方法
  }
}

class Human extends Speaker {
  override def speak(): Unit = {
    println("Human speaks")
  }
}

val h = new Human
h.speak()  // 输出：Human speaks
h.greet()  // 输出：Hello!</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     （Java 8+）：
    </p>
    <p>
     java复制代码
    </p>
    <pre><code>public interface Speaker {
    void speak();
    default void greet() {
        System.out.println("Hello!");
    }
}

public class Human implements Speaker {
    @Override
    public void speak() {
        System.out.println("Human speaks");
    }
}</code></pre>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      特质可以包含抽象方法和具体方法。
     </li>
     <li>
      类通过
      <code>
       with
      </code>
      关键字继承多个特质：
      <p>
       scala复制代码
      </p>
      <pre><code>class Robot extends Speaker with Walker with Worker</code></pre>
     </li>
     <li>
      解决多重继承冲突时，采用
      <strong>
       线性化规则
      </strong>
      （最后继承的特质优先级最高）。
     </li>
    </ul>
    <hr/>
    <h4 id="7. Case 类：专为模式匹配优化的类">
     7. Case 类：专为模式匹配优化的类
    </h4>
    <p>
     <code>
      case class
     </code>
     是 Scala 中特殊的类，自动生成常用方法（如
     <code>
      equals
     </code>
     、
     <code>
      hashCode
     </code>
     、
     <code>
      toString
     </code>
     ）。
    </p>
    <p>
     <strong>
      Scala 示例
     </strong>
     ：
    </p>
    <p>
     scala复制代码
    </p>
    <pre><code>case class Point(x: Int, y: Int)

val p1 = Point(1, 2)
val p2 = Point(1, 2)
println(p1 == p2)  // 输出 true（自动实现值比较）</code></pre>
    <p>
     <strong>
      Java 对比
     </strong>
     ：
     <br/>
     需要手动实现
     <code>
      equals
     </code>
     、
     <code>
      hashCode
     </code>
     、
     <code>
      toString
     </code>
     等方法。
    </p>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      默认字段为
      <code>
       val
      </code>
      （不可变）。
     </li>
     <li>
      自动生成伴生对象和
      <code>
       apply
      </code>
      方法。
     </li>
     <li>
      支持模式匹配：
      <p>
       scala复制代码
      </p>
      <pre><code>def describe(p: Point): String = p match {
  case Point(0, 0) =&gt; "原点"
  case Point(x, 0) =&gt; s"X轴上的点($x, 0)"
  case _ =&gt; "其他点"
}</code></pre>
     </li>
    </ul>
    <hr/>
    <h4 id="总结：Scala vs Java 类设计的差异" style="background-color:transparent">
     总结：Scala vs Java 类设计的差异
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        Scala
       </th>
       <th>
        Java
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        构造器
       </td>
       <td>
        主构造器 + 辅助构造器
       </td>
       <td>
        普通构造器
       </td>
      </tr>
      <tr>
       <td>
        静态成员
       </td>
       <td>
        通过伴生对象实现
       </td>
       <td>
        <code>
         static
        </code>
        关键字
       </td>
      </tr>
      <tr>
       <td>
        接口
       </td>
       <td>
        特质（支持方法实现）
       </td>
       <td>
        接口（Java 8+ 支持默认方法）
       </td>
      </tr>
      <tr>
       <td>
        不可变类
       </td>
       <td>
        用
        <code>
         case class
        </code>
        自动生成
       </td>
       <td>
        需手动实现
       </td>
      </tr>
      <tr>
       <td>
        多重继承
       </td>
       <td>
        通过特质支持
       </td>
       <td>
        不支持（接口允许多实现）
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f37393438303432322f:61727469636c652f64657461696c732f313436303736333133" class_="artid" style="display:none">
 </p>
</div>


