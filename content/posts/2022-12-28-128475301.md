---
layout: post
title: "数据库与缓存保持一致性"
date: 2022-12-28 23:46:01 +0800
description: "数据库和缓存一致性"
keywords: "缓存一致性,数据库更新,分布式锁"
categories: ['Redis']
tags: ['缓存', '数据库', 'Java']
artid: "128475301"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=128475301
    alt: "数据库与缓存保持一致性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=128475301
featuredImagePreview: https://bing.ee123.net/img/rand?artid=128475301
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【数据库与缓存保持一致性】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#1_1_1" rel="nofollow">
        1. 方案1
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_3" rel="nofollow">
          先更新数据库，再更新缓存
         </a>
        </li>
        <li>
         <a href="#_6" rel="nofollow">
          先更新缓存，在更新数据库
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#2_2_20" rel="nofollow">
        2. 方案2
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_31" rel="nofollow">
          先更新数据库，在删缓存
         </a>
        </li>
        <li>
         <a href="#_41" rel="nofollow">
          先删缓存，在更新数据库
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#3_3_62" rel="nofollow">
        3. 方案3—如何保证两个操作都能执行成功？
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_70" rel="nofollow">
          重试机制
         </a>
        </li>
        <li>
         <a href="#_MySQL_binlog_77" rel="nofollow">
          订阅 MySQL binlog
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="1_1_1">
     </a>
     1. 方案1
    </h2>
    <h3>
     <a id="_3">
     </a>
     先更新数据库，再更新缓存
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1cb9a01427b0de89e84d0e2ae4096e3f.png"/>
    </p>
    <h3>
     <a id="_6">
     </a>
     先更新缓存，在更新数据库
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/f3cc88207c26b8130df2ff2d058934e6.png"/>
    </p>
    <blockquote>
     <p>
      <code>
       总结：无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。
      </code>
     </p>
     <ul>
      <li>
       我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。
      </li>
     </ul>
     <p>
      <strong>
       <code>
        问题
       </code>
      </strong>
     </p>
     <ul>
      <li>
       在两个更新请求并发执行的时候，会出现数据不一致的问题，因为更新数据库和更新缓存这两个操作是独立的，而我们&gt;又没有对操作做任何并发控制，那么当两个线程并发更新它们的话，就会因为写入顺序的不同造成数据的不一致。
      </li>
     </ul>
     <p>
      <strong>
       <code>
        解决办法
       </code>
      </strong>
     </p>
     <ol>
      <li>
       <code>
        在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就&gt;会带来影响。
       </code>
      </li>
      <li>
       <code>
        在更新完缓存时，给缓存加上较短的过期时间，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。
       </code>
      </li>
     </ol>
    </blockquote>
    <h2>
     <a id="2_2_20">
     </a>
     2. 方案2
    </h2>
    <ul>
     <li>
      <p>
       先更新数据库，还是先删除缓存，叫
       <code>
        Cache Aside 策略
       </code>
       ，中文是叫
       <code>
        旁路缓存策略
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       该策略又可以细分为
       <code>
        「读策略」
       </code>
       和
       <code>
        「写策略」
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <code>
        写策略的步骤
       </code>
       ：
      </p>
      <ol>
       <li>
        更新数据库中的数据；
       </li>
       <li>
        删除缓存中的数据。
       </li>
      </ol>
     </li>
     <li>
      <p>
       <code>
        读策略的步骤
       </code>
       ：
      </p>
      <ol>
       <li>
        如果读取的数据命中了缓存，则直接返回数据；
       </li>
       <li>
        如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。
       </li>
      </ol>
     </li>
    </ul>
    <h3>
     <a id="_31">
     </a>
     先更新数据库，在删缓存
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/08d415289fe03d49f090f8cf6ea47605.png"/>
    </p>
    <ul>
     <li>
      因为缓存的写入通常要远远快于数据库的写入，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。
     </li>
     <li>
      而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。
     </li>
     <li>
      <code>
       缓存数据加上了「过期时间」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。
      </code>
     </li>
    </ul>
    <p>
     所以，
     <code>
      「先更新数据库 + 再删除缓存」
     </code>
     的方案，是可以保证数据一致性的。
    </p>
    <p>
     <strong>
      <code>
       问题
      </code>
     </strong>
    </p>
    <ul>
     <li>
      明明更新了数据，但是数据要过一段时间才生效。（原因：「先更新数据库， 再删除缓存」其实是两个操作，前面的所有分析都是建立在这两个操作都能同时执行成功，而这次客户投诉的问题就在于，在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值。给缓存加上了过期时间，所以才会出现客户说的过一段时间才更新生效的现象。）
     </li>
    </ul>
    <h3>
     <a id="_41">
     </a>
     先删缓存，在更新数据库
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1059ca8669cfae522f9787163f4f5b3b.png"/>
    </p>
    <p>
     <strong>
      <code>
       解决办法
      </code>
     </strong>
    </p>
    <ul>
     <li>
      延迟双删
     </li>
    </ul>
    <pre><code class="prism language-c">#删除缓存
redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>
#更新数据库
db<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>
#睡眠
Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span>
#再删除缓存
redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>
</code></pre>
    <ul>
     <li>
      加个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。
      <br/>
      所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。
     </li>
    </ul>
    <p>
     <code>
      建议使用「先更新数据库，再删除缓存」的方案。
     </code>
    </p>
    <h2>
     <a id="3_3_62">
     </a>
     3. 方案3—如何保证两个操作都能执行成功？
    </h2>
    <ul>
     <li>
      <code>
       「先更新数据库 + 再删除缓存」
      </code>
      的方案，是可以保证数据一致性的。但是在删除缓存（第二个操作）的时候失败了，导致缓存还是旧值，而数据库是最新值，虽然加了过期时间，但是也需要过一会才生效，所以还会造成数据库和缓存数据不一致的问题。
     </li>
     <li>
      不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a2da223015c46531e0b0cacc0517f29a.png">
       <br/>
       <strong>
        <code>
         解决办法
        </code>
       </strong>
      </img>
     </li>
     <li>
      重试机制。
     </li>
     <li>
      订阅 MySQL binlog，再操作缓存。
     </li>
    </ul>
    <h3>
     <a id="_70">
     </a>
     重试机制
    </h3>
    <ul>
     <li>
      引入
      <code>
       消息队列
      </code>
      ，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。
      <ul>
       <li>
        如果应用
        <code>
         删除缓存失败
        </code>
        ，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
       </li>
       <li>
        如果
        <code>
         删除缓存成功
        </code>
        ，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/795a90b9f84d44dafd711f33bc97cb78.png"/>
    </p>
    <h3>
     <a id="_MySQL_binlog_77">
     </a>
     订阅 MySQL binlog
    </h3>
    <ul>
     <li>
      「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。
     </li>
     <li>
      通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除,Canal 中间件就是基于这个实现的。
     </li>
    </ul>
    <p>
     <strong>
      Canal 原理
     </strong>
    </p>
    <ul>
     <li>
      Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4338d61aff8494020efc9513b48b0789.png">
       <br/>
       文章:
       <a href="https://www.xiaolincoding.com/" rel="nofollow">
        https://www.xiaolincoding.com/
       </a>
      </img>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353034333333342f:61727469636c652f64657461696c732f313238343735333031" class_="artid" style="display:none">
 </p>
</div>


