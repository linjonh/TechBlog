---
layout: post
title: "Spring-Boot-中使用-Transactional-注解配置事务管理"
date: 2025-03-10 17:06:52 +0800
description: "下面分别介绍一下的几个属性。"
keywords: "Spring Boot 中使用 @Transactional 注解配置事务管理"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['数据库', 'Sql', 'Spring', 'Boot']
artid: "146158809"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158809
    alt: "Spring-Boot-中使用-Transactional-注解配置事务管理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158809
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158809
cover: https://bing.ee123.net/img/rand?artid=146158809
image: https://bing.ee123.net/img/rand?artid=146158809
img: https://bing.ee123.net/img/rand?artid=146158809
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring Boot 中使用 @Transactional 注解配置事务管理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     事务管理是应用系统开发中必不可少的一部分。Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编程式和声明式的两种方式。编程式事务指的是通过编码方式实现事务；声明式事务基于 AOP,将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染, 因此在实际使用中声明式事务用的比较多。声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional注解的方式。本文将着重介绍基于@Transactional注解的事务管理。
    </p>
    <p>
     需要明确几点：
    </p>
    <ul>
     <li>
      <strong>
       默认配置下
      </strong>
      Spring 只会回滚运行时、未检查异常（继承自 RuntimeException 的异常）或者 Error。
      <a href="https://docs.spring.io/spring-framework/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-rolling-back" rel="nofollow" title="参考这里">
       参考这里
      </a>
     </li>
     <li>
      @Transactional注解只能应用到 public 方法才有效。
      <a href="https://docs.spring.io/spring-framework/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-annotations" rel="nofollow" title="参考这里 Method visibility and @Transactional">
       参考这里 Method visibility and @Transactional
      </a>
     </li>
    </ul>
    <p>
     以下的示例使用的是 mybatis，所以 spring boot 会
     <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-auto-configuration" rel="nofollow" title="自动配置">
      自动配置
     </a>
     一个
     <code>
      DataSourceTransactionManager
     </code>
     ，我们只需在方法（或者类）加上
     <code>
      @Transactional
     </code>
     注解，就自动纳入 Spring 的事务管理了。
    </p>
    <h3>
     <a id="1__13">
     </a>
     1. 简单的使用方法
    </h3>
    <p>
     只需在方法加上
     <code>
      @Transactional
     </code>
     注解就可以了。
    </p>
    <p>
     如下有一个保存用户的方法，加入
     <code>
      @Transactional
     </code>
     注解，使用默认配置，抛出异常之后，事务会自动回滚，数据不会插入到数据库。
    </p>
    <p>
     @Transactional
     <br/>
     @Override
     <br/>
     public void save() {
     <!-- -->
     <br/>
     User user = new User(“花花”);
     <br/>
     userMapper.insertSelective(user);
    </p>
    <pre><code>if (true) {
    throw new RuntimeException("save 抛异常了");
}
</code></pre>
    <p>
     }
    </p>
    <h3>
     <a id="2_Transactional__31">
     </a>
     2. @Transactional 注解的属性介绍
    </h3>
    <p>
     下面分别介绍一下
     <code>
      @Transactional
     </code>
     的几个属性。
    </p>
    <h4>
     <a id="21_value__transactionManager__36">
     </a>
     2.1 value 和 transactionManager 属性
    </h4>
    <p>
     它们两个是一样的意思。当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器。
    </p>
    <h4>
     <a id="22_propagation__40">
     </a>
     2.2 propagation 属性
    </h4>
    <p>
     事务的传播行为，String默认的事务传播类型为 Propagation.REQUIRED。
    </p>
    <p>
     可选的值有：
    </p>
    <p>
     Propagation.REQUIRED
    </p>
    <p>
     如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。
    </p>
    <p>
     Propagation.SUPPORTS
    </p>
    <p>
     如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。
    </p>
    <p>
     Propagation.MANDATORY
    </p>
    <p>
     如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。
    </p>
    <p>
     Propagation.REQUIRES_NEW
    </p>
    <p>
     重新创建一个新的事务，如果当前存在事务，暂停当前的事务。
    </p>
    <p>
     Propagation.NOT_SUPPORTED
    </p>
    <p>
     以非事务的方式运行，如果当前存在事务，暂停当前的事务。
    </p>
    <p>
     Propagation.NEVER
    </p>
    <p>
     以非事务的方式运行，如果当前存在事务，则抛出异常。
    </p>
    <p>
     Propagation.NESTED
    </p>
    <p>
     和 Propagation.REQUIRED 效果一样。
    </p>
    <p>
     这些概念理解起来实在是有点儿抽象，后文会用代码示例解释说明。
    </p>
    <h4>
     <a id="23_isolation__76">
     </a>
     2.3 isolation 属性
    </h4>
    <p>
     事务的隔离级别，默认值为 Isolation.DEFAULT。
    </p>
    <p>
     可选的值有：
    </p>
    <p>
     Isolation.DEFAULT
    </p>
    <p>
     使用底层数据库默认的隔离级别。
    </p>
    <p>
     Isolation.READ_UNCOMMITTED （未提交读）
    </p>
    <p>
     Isolation.READ_COMMITTED （提交读，不可重复读）oracle默认的隔离级别
     <br/>
     Isolation.REPEATABLE_READ （可重复读）mysql默认的隔离级别
     <br/>
     Isolation.SERIALIZABLE （可串行化）
    </p>
    <p>
     越往下效率越低
    </p>
    <h4>
     <a id="24_timeout__94">
     </a>
     2.4 timeout 属性
    </h4>
    <p>
     事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
    </p>
    <h4>
     <a id="25_readOnly__98">
     </a>
     2.5 readOnly 属性
    </h4>
    <p>
     指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。
    </p>
    <h4>
     <a id="26_rollbackFor__102">
     </a>
     2.6 rollbackFor 属性
    </h4>
    <p>
     用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。
    </p>
    <h4>
     <a id="27_noRollbackFor__106">
     </a>
     2.7 noRollbackFor 属性
    </h4>
    <p>
     抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。
    </p>
    <h3>
     <a id="3_Transactional__propagation__110">
     </a>
     3. @Transactional 的 propagation 属性代码示例
    </h3>
    <p>
     比如如下代码，save 方法首先调用了 method1 方法，然后抛出了异常，就会导致事务回滚，如下两条数据都不会插入数据库。
    </p>
    <p>
     @Transactional(propagation = Propagation.REQUIRED)
     <br/>
     @Override
     <br/>
     public void save() {
     <!-- -->
    </p>
    <pre><code>method1();

User user = new User("许嵩");
userMapper.insertSelective(user);

if (true) {
    throw new RuntimeException("save 抛异常了");
}
</code></pre>
    <p>
     }
    </p>
    <p>
     public void method1() {
     <!-- -->
     <br/>
     User user = new User(“汪苏泷”);
     <br/>
     userMapper.insertSelective(user);
     <br/>
     }
    </p>
    <p>
     现在有需求如下，就算 save 方法的后面抛异常了，也不能影响 method1 方法的数据插入。或许很多人的想法如下，给 method1 页加入一个新的事务，这样 method1 就会在这个新的事务中执行，原来的事务不会影响到新的事务。比如 method1 方法上面再加入注解 @Transactional，设置 propagation 属性为 Propagation.REQUIRES_NEW，代码如下。
    </p>
    <p>
     @Transactional(propagation = Propagation.REQUIRED)
     <br/>
     @Override
     <br/>
     public void save() {
     <!-- -->
    </p>
    <pre><code>method1();

User user = new User("许嵩");
userMapper.insertSelective(user);

if (true) {
    throw new RuntimeException("save 抛异常了");
}
</code></pre>
    <p>
     }
    </p>
    <p>
     @Transactional(propagation = Propagation.REQUIRES_NEW)
     <br/>
     public void method1() {
     <!-- -->
     <br/>
     User user = new User(“汪苏泷”);
     <br/>
     userMapper.insertSelective(user);
     <br/>
     }
    </p>
    <p>
     运行之后，发现然并卵，数据也是没有插入数据库。怎么肥四，看起来很不科学。其实两个方法都是处于同一个事务中，method1 方法并没有创建一个新的事务。
    </p>
    <p>
     这就得看看
     <a href="https://docs.spring.io/spring/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-annotations" rel="nofollow" title="Spring 官方文档">
      Spring 官方文档
     </a>
     了。
    </p>
    <p>
     In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-
     <br/>
     invocation, in effect, a method within the target object calling another method of the target object, will not lead to an actual transaction
     <br/>
     at runtime even if the invoked method is marked with @Transactional.
    </p>
    <p>
     大概意思：在默认的代理模式下，只有目标方法由外部调用，才能被 Spring 的事务拦截器拦截。在同一个类中的两个方法直接调用，是不会被 Spring 的事务拦截器拦截，就像上面的 save 方法直接调用了同一个类中的 method1方法，method1 方法不会被 Spring 的事务拦截器拦截。可以使用 AspectJ 取代 Spring AOP 代理来解决这个问题，但是这里暂不讨论。
    </p>
    <p>
     为了解决这个问题，我们可以新建一个类。
    </p>
    <p>
     @Service
     <br/>
     public class OtherServiceImpl implements OtherService {
     <!-- -->
    </p>
    <pre><code>@Autowired
private UserMapper userMapper;

@Transactional(propagation = Propagation.REQUIRES\_NEW)
@Override
public void method1() {
    User user = new User("周杰伦");
    userMapper.insertSelective(user);
}
</code></pre>
    <p>
     }
    </p>
    <p>
     然后在 save 方法中调用 otherService.method1 方法
    </p>
    <p>
     @Autowired
     <br/>
     private OtherService otherService;
    </p>
    <p>
     @Transactional(propagation = Propagation.REQUIRED)
     <br/>
     @Override
     <br/>
     public void save() {
     <!-- -->
    </p>
    <pre><code>otherService.method1();

User user = new User("林俊杰");
userMapper.insertSelective(user);

if (true) {
    throw new RuntimeException("save 抛异常了");
}
</code></pre>
    <p>
     }
    </p>
    <p>
     这下，otherService.method1 方法的数据插入成功，save 方法的数据未插入，事务回滚。
    </p>
    <p>
     从日志可以看出，首先创建了 save 方法的事务，由于 otherService.method1 方法的 @Transactional 的 propagation 属性为 Propagation.REQUIRES_NEW ，所以接着暂停了 save 方法的事务，重新创建了 otherService.method1 方法的事务，接着 otherService.method1 方法的事务提交，接着 save 方法的事务回滚。这就印证了只有目标方法由外部调用，才能被 Spring 的事务拦截器拦截。
     <br/>
     还有几个示例如下：
    </p>
    <p>
     接着把 save 方法的 @Transactional 注解去掉，otherService.method1 的 @Transactional 注解保持不变，从日志就可以看出，只会创建一个 otherService.method1 方法的事务，两条数据都会插入。
    </p>
    <p>
     @Autowired
     <br/>
     private OtherService otherService;
    </p>
    <p>
     // @Transactional(propagation = Propagation.REQUIRED)
     <br/>
     @Override
     <br/>
     public void save() {
     <!-- -->
    </p>
    <pre><code>otherService.method1();

User user = new User("汪苏泷");
userMapper.insertSelective(user);

if (true) {
    throw new RuntimeException("save 抛异常了");
}
</code></pre>
    <p>
     }
    </p>
    <p>
     接着把 save 方法的 @Transactional 注解去掉，save 方法改为调用内部的 method1 方法，从日志就可以看出，完全没有创建任何事务，两条数据都会插入。
    </p>
    <p>
     // @Transactional(propagation = Propagation.REQUIRED)
     <br/>
     @Override
     <br/>
     public void save() {
     <!-- -->
    </p>
    <pre><code>method1();

User user = new User("华晨宇");
userMapper.insertSelective(user);

if (true) {
    throw new RuntimeException("save 抛异常了");
}
</code></pre>
    <p>
     }
    </p>
    <p>
     @Transactional(propagation = Propagation.REQUIRES_NEW)
     <br/>
     public void method1() {
     <!-- -->
     <br/>
     User user = new User(“许嵩”);
     <br/>
     userMapper.insertSelective(user);
     <br/>
     }
    </p>
    <p>
     这样，其他的几个 propagation 属性值也就比较好理解了。
    </p>
    <h3>
     <a id="4_Transactional__250">
     </a>
     4. @Transactional 事务实现机制
    </h3>
    <p>
     在应用系统调用声明了@Transactional的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional的属性配置信息，这个代理对象决定该声明@Transactional的目标方法是否由拦截器TransactionInterceptor来使用拦截，在TransactionInterceptor拦截时，会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器AbstractPlatformTransactionManager操作数据源DataSource提交或回滚事务。
    </p>
    <p>
     Spring AOP 代理有CglibAopProxy和JdkDynamicAopProxy两种，以CglibAopProxy为例，对于CglibAopProxy，需要调用其内部类的DynamicAdvisedInterceptor的 intercept 方法。对于JdkDynamicAopProxy，需要调用其 invoke 方法。
    </p>
    <p>
     正如上文提到的，事务管理的框架是由抽象事务管理器AbstractPlatformTransactionManager来提供的，而具体的底层事务处理实现，由PlatformTransactionManager的具体实现类来实现，如事务管理器DataSourceTransactionManager。不同的事务管理器管理不同的数据资源DataSource，比如DataSourceTransactionManager管理JDBC 的 Connection。
    </p>
    <h3>
     <a id="5__259">
     </a>
     5. 源码地址
    </h3>
    <ul>
     <li>
      <a href="https://github.com/nextyu/spring-transaction-demo" title="https://github.com/nextyu/spring-transaction-demo">
       https://github.com/nextyu/spring-transaction-demo
      </a>
     </li>
    </ul>
    <h3>
     <a id="6__264">
     </a>
     6. 参考资料
    </h3>
    <ul>
     <li>
      <a href="https://docs.spring.io/spring/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/" rel="nofollow" title="Spring 官方文档">
       Spring 官方文档
      </a>
     </li>
     <li>
      <a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/" rel="nofollow" title="Spring boot 官方文档">
       Spring boot 官方文档
      </a>
     </li>
     <li>
      <a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" rel="nofollow" title="Mybatis">
       Mybatis
      </a>
     </li>
     <li>
      <a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" rel="nofollow" title="资料">
       资料
      </a>
     </li>
     <li>
      <a href="https://stackoverflow.com/questions/3423972/spring-transaction-method-call-by-the-method-within-the-same-class-does-not-wo" rel="nofollow" title="资料">
       资料
      </a>
     </li>
     <li>
      <a href="https://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/" rel="nofollow" title="资料">
       资料
      </a>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343832333433342f:61727469636c652f64657461696c732f313436313538383039" class_="artid" style="display:none">
 </p>
</div>


