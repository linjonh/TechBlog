---
layout: post
title: "数据库系统-关系模型"
date: 2025-01-22 08:50:21 +0800
description: "MySQL数据库学习记录_关系模式"
keywords: "关系模式"
categories: ['未分类']
tags: ['数据库']
artid: "134939904"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=134939904
    alt: "数据库系统-关系模型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=134939904
featuredImagePreview: https://bing.ee123.net/img/rand?artid=134939904
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据库系统 --- 关系模型
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、关系模型的数据结构以及形式化定义
    </h2>
    <h3>
     1.关系
    </h3>
    <p>
     域：一组具有相同数据结构的值的集合。
    </p>
    <p>
     笛卡尔积：域上的一种集合运算。多个集合做笛卡尔积的结果是每个集合取一个元素组合得到的一个新的集合。
    </p>
    <p>
     域的基数：一个域上允许的不同取值的个数。
    </p>
    <p>
     关系：在关系模型D1、D2、D3、...的笛卡尔积是没有实际语意的，只有它的某个真子集才有实际含义。
    </p>
    <p>
     给定一组域D1，D2，D3，…，Dn，允许其中某些域是相同的，D1，D2，D3，…，Dn。的笛卡儿积D1×D2xD3×...Dn的子集称为这组域上的关系，表示为R(D1,D2,…,Dn)。
    </p>
    <p>
     这里R表示关系名，n是关系的目或度(degree)。
    </p>
    <p>
     当n=1时，称该关系为一元关系(unary relation)或单元关系、单目关系。
     <br/>
     当n=2时，称该关系为二元关系(binary relation)或二目关系。
    </p>
    <p>
     关系中的每个元素是关系中的元组，通常用t来表示。
    </p>
    <p>
     关系是笛卡儿积的有限子集，所以关系是一张二维表，表的每一行对应一个元组，表的每一列对应一个域。由于域可以相同，为了加以区分，必须对每一列起一个名字，称为属性。n目关系必有n个属性。
    </p>
    <p>
     关系可以有三种类型：
     <span style="color:#fe2c24;">
      <strong>
       基本关系
      </strong>
     </span>
     (通常又称为基本表或基表)、
     <span style="color:#fe2c24;">
      <strong>
       查询结果
      </strong>
     </span>
     和
     <span style="color:#fe2c24;">
      <strong>
       视图
      </strong>
     </span>
     。其中，基本关系是实际存在的表，它是实际存储数据的逻辑表示；查询结果是查询执行产生的结果对应的临时表；视图是由基本表或其他视图导出的虚表，不存储实际数据。
    </p>
    <p>
     基本关系具有6条性质：①.列是同质的(homogeneous)，即每一列中的分量是同一类型的数据，来自同一个域。②.不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。③.列的顺序无所谓，即列的次序可以任意交换。由于列顺序是无关紧要的，因此在许多实际的关系数据库产品中增加新属性时，永远是将其插至最后。④.任意两个元组的码不能取相同的值。⑤.行的顺序无所谓，即行的次序可以任意交换。⑥.分量必须取原子值，即每一个分量都必须是不可分的数据项。
    </p>
    <p>
     关系模型要求关系必须满足一定的规范条件，其最基本的一条就是元组的每一个分量必须是一个不可分的数据项。
    </p>
    <p>
     规范化的关系简称为范式(normal form， NF)
    </p>
    <h3>
     2.关系模式
    </h3>
    <p>
     关系模式是“型”，关系是“值”。
    </p>
    <p>
     关系的描述称为关系模式(relation schema)。它可以形式化地表示为
    </p>
    <p style="text-align:center;">
     R(U，D，DOM，F)
    </p>
    <p>
     其中R为关系名，U为组成该关系的属性的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据依赖关系的集合。
    </p>
    <p>
     关系模式通常简记为
    </p>
    <p style="text-align:center;">
     R(U)或者
     <br/>
     R(A1,A2,…,An)
    </p>
    <p>
     其中R为关系名，A，A，…，A，为属性名；而域名及属性向域的映像则常直接说明为属性的类型、长度。
    </p>
    <p>
     若关系模式中的某一个属性或一组属性的值能唯一地标识一个元组，而它的真子集不能唯一地标识一个元组，则称该属性或属性组为
     <span style="color:#fe2c24;">
      <strong>
       候选码
      </strong>
     </span>
     (candidate key)。
    </p>
    <p>
     若一个关系有多个候选码，则选定其中一个为主码(primary key)，或称主键。
    </p>
    <p>
     候选码的诸属性称为主属性(prime atnbute)。
    </p>
    <p>
     不包含在任何候选码中的属性称为非主属性(non prime attribute)或非码属性(non-key atribute)。
    </p>
    <p>
     在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为全码(all-key)。
    </p>
    <p>
     关系是关系模式在某一时刻的状态或内容。
    </p>
    <p>
     关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，这是因为关系操作在不断地更新着数据库中的数据。
    </p>
    <p>
     在实际工作中，人们常常把关系模式和关系都笼统地称为关系。
    </p>
    <h3>
     3.关系数据库
    </h3>
    <p>
     支持关系模型的数据库系统称为关系数据库系统。在关系模型中，实体以及实体间的联系都是用关系来表示的。
    </p>
    <p>
     例如，“学生”实体、“课程”实体、学生与课程之间选修课程的多对多联系都可以分别用一个关系模式来描述。
    </p>
    <p>
     “学生”关系模式：Student(Sno,Sname,Ssex,Sbirthdate,Smajor)，包括学号、姓名、性别、出生日期和主修专业等属性。
     <br/>
     “课程”关系模式：Course(Cno，Cname，Ccredit,Cpno)，包括课程号、课程名、学分、先修课(直接先修课)等属性。
     <br/>
     “学生选课”关系模式：SC(Sno，Cno，Grade,Semester,Teachingclass)，包括学号、课程号、成绩、开课学期、教学班等属性。
    </p>
    <p>
     在一个关系数据库中，某一时刻所有关系模式对应的关系的集合构成一个关系数据库。
    </p>
    <p>
     关系数据库也有类型和值之分。
    </p>
    <p>
     关系数据库的类型就是关系数据库中所有关系模式的集合，是对关系数据库的描述，通常称为关系数据库模式。
    </p>
    <p>
     关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常将为关系数据库。
    </p>
    <h3>
     4.关系模型的存储结构
    </h3>
    <p>
     关系模型是关系数据的逻辑结构，用关系数据定义语言描述。例如关系数据库标准语言SQL。
    </p>
    <p>
     支持关系模型的关系数据库管理系统(relational database management system, RDBMS)将以一定的组织方式存储和管理数据，即设计和实现关系模型的存储结构，这是关系数据库管理系统的重要职责之一。
    </p>
    <p>
     例如，有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织的许多任务交给操作系统完成；有的关系数据库管理系统则从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构并进行存储管理。
    </p>
    <h2>
     二、关系操作
    </h2>
    <h3>
     1.基本的关系操作
    </h3>
    <p>
     关系模型中常用的关系操作包括查询(query)操作和更新操作两大部分，而更新操作又可分为插入(insert)、删除(delete)、修改(update)等操作。
    </p>
    <p>
     关系的查询表达能力很强，因此查询操作是关系操作中最主要的部分。查询操作又可进一步分为选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(difference)、交(intersection)、笛卡儿积等操作。其中选择、投影、并、差、笛卡儿积是5种基本操作，其他操作可以用基本操作来定义和导出，就像乘法可以用加法来定义和导出一样。
    </p>
    <p>
     关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为成组数据处理(set-at-a-time processing)，即一次一个集合的操作方式。相应地，层次模型和网状模型的数据操作方式则为一次一个记录(record-at-a-time)的方式。
    </p>
    <p>
     这里强调一下，关系操作的所有输入和输出均是关系，包括关系操作的中间结果也是关系。
    </p>
    <h3>
     2.关系数据语言的分类
    </h3>
    <p>
     早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数(relational al-gebra)和关系演算(relational calculus)。
    </p>
    <p>
     关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。
    </p>
    <p>
     关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。
    </p>
    <p>
     一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。
    </p>
    <p>
     此外，还有一种结构化查询语言(structured query language， SQL)。SQL不仅具有丰富的查询功能，而且具有数据定义和数据控制功能，是集数据查询语言(data query language, DQL)、数据定义语言(DDL)、数据操纵语言(DML)和数据控制语言(data control language， DCL)于一体的关系数据语言。它充分体现了关系数据语言的特点和优点，自20世纪80年代起成为关系数据库的标准语言。
    </p>
    <h2>
     三、关系的完整性
    </h2>
    <p>
     关系模型的完整性约束是对关系的其种约束条件。也就是说关系的值随着时间变化时应该满足一些的约束条件，这些约束系件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。
    </p>
    <p>
     关系模型中有三类完整性约束：实体完整性(cntiy iteoity)、参照完整性(refecntial inte
     <br/>
     2)和用户定义的完整性(ir- Ihfind imegrity)。
    </p>
    <p>
     其中实体完整性和参照完整性是关系模型必级满足的完整性约束，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。
    </p>
    <h3>
     1.实体完整性
    </h3>
    <p>
     关系数据库中每个元组应该是可区分的，是唯一的。这样的约束条件用实体完整性来保证。
    </p>
    <p>
     实体完整性约束：若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值(null value)。其中空值就是“不知道”或“不存在”或“无意义”的值。
    </p>
    <p>
     对于实体完整性约束说明：
     <br/>
     ①.实体完整性约束是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如，“学生”关系对应学生的集合。
     <br/>
     ②.现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如，每个学生都是独立的个体，是不一样的。
     <br/>
     ③.关系模型中以主码作为唯一性标识。
     <br/>
     ④.主码中的属性不能取空值，如果取了空值，就说明存在某个不可标识的实体，即存在不可区分的实体。
    </p>
    <h3>
     2.参照完整性
    </h3>
    <p>
     现实世界中的实体之间往往存在某种联系，在关系模型中实体及实体间的联系都是用关系来描述的，这样就自然存在着关系与关系间的引用。
    </p>
    <p>
     定义  设F是基本关系R的一个或一组属性，但不是关系R的码，Ks 是基本关系S的主码。如果F与Ks相对应，则称F是R的外码(foreign key)， 并称基本关系R为参照关系(relerencing relation), 基本关系S为被参照关系( referenced relation) 或目标关系( targetrlation)。关系R和S不一定是不同的关系。显然，目标关系S的主码K。和参照关系R的外码F必须定义在同一个(或同一组)域上。
    </p>
    <p class="img-center">
     <img alt="" height="67" src="https://i-blog.csdnimg.cn/blog_migrate/f0a989627ab735e032b18f1e97442fcd.png" width="269"/>
    </p>
    <p>
     外码并不一定要与相应的主码同名。
    </p>
    <p>
     参照完整性约束就是定义外码与主码之间的引用规则。
    </p>
    <p>
     参照完整性约束：若属性( 或属性组)F是基本关系R的外码，它与基本关系S 的主码K相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值 必须:
    </p>
    <p>
     ①或者取空值(F的每个属性值均为空值)。
    </p>
    <p>
     ②或者等于S中某个元组的主码值。
    </p>
    <p>
     在参照完整性约束中，R与S可以是同一个关系。
    </p>
    <h3>
     3.用户定义完整性
    </h3>
    <p>
     任何关系数据库系统都应该支持实体完整性和参照完整性，这是关系模型所要求的。除此
     <br/>
     之外，不同的关系数据库根据其应用场景不同，往往还需要一些特殊的约束条件。 用户定义的
     <br/>
     完整性就是针对某一具体关系数据库的约束条件，它反映某一县体应用所涉及的数据必须满足
     <br/>
     的语义要求。例如，某个属性必须取唯一值，某个非主属性不能取空值等。
     <br/>
     关系模型应提供定义和检验这类完整性约束的机制，以便用统一的系统的方法处理它们，
     <br/>
     而不需要由应用程序承担这一功能。
    </p>
    <h2>
     四、关系代数
    </h2>
    <p>
     关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。
    </p>
    <p>
     运算对象、运算符、运算结果是运算的三大要素。
    </p>
    <p>
     关系代数的运算对象是关系，运算结果亦为关系。关系代数用到的运算符包括两类:集合运算符和专门的关系运算符。
    </p>
    <p class="img-center">
     <img alt="" height="247" src="https://i-blog.csdnimg.cn/blog_migrate/6349b5c2998c627569c89dea0d398024.png" width="210"/>
    </p>
    <p>
     <img alt="" height="557" src="https://i-blog.csdnimg.cn/blog_migrate/8dd01cace35958956e1713ee01e3752b.png" width="666"/>
    </p>
    <p>
     <img alt="" height="279" src="https://i-blog.csdnimg.cn/blog_migrate/627839ee24cf342d519bd56a665f85e4.png" width="1137"/>
    </p>
    <p>
     <img alt="" height="580" src="https://i-blog.csdnimg.cn/blog_migrate/59856b2f523934e020659a20fd24dd69.png" width="1200"/>
    </p>
    <p class="img-center">
     <img alt="" height="712" src="https://i-blog.csdnimg.cn/blog_migrate/72d68b470063a9267081cf423e22be11.png" width="567"/>
    </p>
    <p class="img-center">
     <img alt="" height="766" src="https://i-blog.csdnimg.cn/blog_migrate/876c3588fce73119b8e462e6bef79235.png" width="611"/>
    </p>
    <p>
     <img alt="" height="767" src="https://i-blog.csdnimg.cn/blog_migrate/308b5032aee67a721543ab80d700138f.png" width="586"/>
    </p>
    <p class="img-center">
     <img alt="" height="696" src="https://i-blog.csdnimg.cn/blog_migrate/f2a2be84ba2518878e73908b9dbc1612.png" width="569"/>
    </p>
    <p class="img-center">
     <img alt="" height="772" src="https://i-blog.csdnimg.cn/blog_migrate/df37a96cb5192dee4455418d1206cf9a.png" width="574"/>
    </p>
    <p class="img-center">
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/blog_migrate/223f5598c5e536f8d6df7a89b9986a41.png" width="625"/>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36323532353534372f:61727469636c652f64657461696c732f313334393339393034" class_="artid" style="display:none">
 </p>
</div>


