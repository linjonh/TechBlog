---
layout: post
title: "机器学习基于t-SNE的MNIST数据集可视化探索"
date: 2025-03-12 10:00:00 +0800
description: "在机器学习和数据科学领域，高维数据的可视化是一个极具挑战但又至关重要的问题。高维数据难以直观地理解和分析，而有效的可视化方法能够帮助我们发现数据中的潜在结构、模式和关系。本文以经典的MNIST手写数字数据集为例，探讨如何利用t-分布随机邻域嵌入（t-SNE）这一强大的降维技术，将高维的图像数据降维到二维空间，并进行可视化展示。通过本文，我们将深入了解t-SNE的原理、算法步骤，以及如何在Python中实现并应用它，从而更好地理解和探索高维数据的内在特性。"
keywords: "t-sne数据可视化"
categories: ['机器学习', 'Py']
tags: ['降维', '聚类', '机器学习', '人工智能']
artid: "146161615"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146161615
    alt: "机器学习基于t-SNE的MNIST数据集可视化探索"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146161615
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146161615
cover: https://bing.ee123.net/img/rand?artid=146161615
image: https://bing.ee123.net/img/rand?artid=146161615
img: https://bing.ee123.net/img/rand?artid=146161615
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【机器学习】基于t-SNE的MNIST数据集可视化探索
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" name="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">
     <strong>
      一、前言
     </strong>
    </h2>
    <p>
     在机器学习和数据科学领域，高维数据的可视化是一个极具挑战但又至关重要的问题。高维数据难以直观地理解和分析，而有效的可视化方法能够帮助我们发现数据中的潜在结构、模式和关系。本文以经典的MNIST手写数字数据集为例，探讨如何利用t-分布随机邻域嵌入（t-SNE）这一强大的降维技术，将高维的图像数据降维到二维空间，并进行可视化展示。通过本文，我们将深入了解t-SNE的原理、算法步骤，以及如何在Python中实现并应用它，从而更好地理解和探索高维数据的内在特性。
    </p>
    <hr/>
    <h2 id="%E4%BA%8C%E3%80%81%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B" name="%E4%BA%8C%E3%80%81%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B">
     <strong>
      二、
     </strong>
     技术与原理简介
    </h2>
    <p>
     在深入探讨t-SNE之前，我们首先需要区分机器学习中的两大主要范畴：监督学习和无监督学习。
    </p>
    <h3>
     <strong>
      1. 监督学习
     </strong>
    </h3>
    <p>
     监督学习是指在已知输入数据和对应标签的情况下，训练模型学习输入与输出之间的映射关系。模型通过学习大量的带标签数据，能够对新的、未见过的数据进行预测或分类。常见的监督学习算法包括：
    </p>
    <ul>
     <li>
      <strong>
       线性回归:
      </strong>
      用于预测连续型变量。
     </li>
     <li>
      <strong>
       逻辑回归:
      </strong>
      用于分类问题。
     </li>
     <li>
      <strong>
       支持向量机 (SVM):
      </strong>
      用于分类和回归问题，尤其擅长处理高维数据。
     </li>
     <li>
      <strong>
       决策树:
      </strong>
      基于树状结构进行决策，易于理解和解释。
     </li>
     <li>
      <strong>
       随机森林:
      </strong>
      集成多个决策树，提高预测的准确性和鲁棒性。
     </li>
     <li>
      <strong>
       神经网络:
      </strong>
      模拟人脑神经元结构，能够学习复杂的非线性关系。
     </li>
    </ul>
    <h3>
     <strong>
      2. 无监督学习
     </strong>
    </h3>
    <p>
     无监督学习是指在没有标签的情况下，训练模型发现数据中的潜在结构和模式。模型通过分析数据的内在特征，能够进行聚类、降维、关联规则挖掘等任务。常见的无监督学习算法包括：
    </p>
    <ul>
     <li>
      <strong>
       聚类:
      </strong>
      将数据划分为不同的簇，使得同一簇内的数据相似度较高，不同簇之间的数据相似度较低。常见的聚类算法包括K-means、层次聚类、DBSCAN等。
     </li>
     <li>
      <strong>
       降维:
      </strong>
      将高维数据降维到低维空间，同时尽可能保留数据的关键信息。常见的降维算法包括主成分分析 (PCA)、t-SNE、UMAP等。
     </li>
     <li>
      <strong>
       关联规则挖掘:
      </strong>
      发现数据中不同项之间的关联关系，例如购物篮分析。
     </li>
    </ul>
    <h3>
     <strong>
      3. 监督学习与无监督学习的区别
     </strong>
    </h3>
    <p>
     <img alt="" height="505" src="https://i-blog.csdnimg.cn/direct/6671f326daf4403283e344b0f9dfaf46.png" width="1303"/>
    </p>
    <h3>
     <strong>
      4. MNIST数据集简介
     </strong>
    </h3>
    <p>
     MNIST (Modified National Institute of Standards and Technology database) 是一个经典的手写数字数据集，广泛应用于机器学习和深度学习领域。它包含60,000个训练样本和10,000个测试样本，每个样本都是一个28x28像素的灰度图像，代表0到9之间的手写数字。
    </p>
    <p>
     <img alt="" height="517" src="https://i-blog.csdnimg.cn/direct/1e86f074b31247f4bb72517110c0be58.png" width="847"/>
    </p>
    <p>
     <strong>
      4.1 数据格式
     </strong>
    </p>
    <p>
     MNIST数据集通常以两种格式提供：
    </p>
    <ul>
     <li>
      <strong>
       图像格式:
      </strong>
      每个样本都是一个图像文件，例如PNG或JPEG格式。
     </li>
     <li>
      <strong>
       数值格式:
      </strong>
      每个样本都被转换为一个784维的向量，其中每个元素代表一个像素的灰度值 (0到255)。
     </li>
    </ul>
    <p>
     <strong>
      4.2 数据集特点
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       规模适中:
      </strong>
      MNIST数据集的规模适中，既可以用于快速原型验证，又可以用于训练复杂的模型。
     </li>
     <li>
      <strong>
       易于获取:
      </strong>
      MNIST数据集可以从多个来源免费获取，例如Scikit-learn、TensorFlow等。
     </li>
     <li>
      <strong>
       广泛应用:
      </strong>
      MNIST数据集被广泛应用于各种机器学习和深度学习算法的评估和比较。
     </li>
    </ul>
    <h3>
     5. t-SNE算法原理与数学推导
    </h3>
    <h4>
     5.1 算法核心思想
    </h4>
    <p>
     t-SNE（t-Distributed Stochastic Neighbor Embedding）是一种非线性降维技术，通过以下步骤实现高维数据到低维空间的映射：
    </p>
    <ol>
     <li>
      <strong>
       计算高维相似度
      </strong>
      ：在原始空间中，计算每对样本间的相似度
     </li>
     <li>
      <strong>
       构建低维嵌入空间
      </strong>
      ：在目标空间（如2D）中，通过优化使相似度分布匹配
     </li>
     <li>
      <strong>
       梯度下降优化
      </strong>
      ：最小化两空间分布的KL散度
     </li>
    </ol>
    <h4>
     <strong>
      5.2 数学公式详解
     </strong>
    </h4>
    <h5>
     5.2.1 高维相似度计算
    </h5>
    <p>
     对原始空间中的样本对(𝑥𝑖,𝑥𝑗) ，定义条件概率：
    </p>
    <p class="img-center">
     <img alt="" height="91" src="https://i-blog.csdnimg.cn/direct/03c8dd8281e94510936e0fd549c48842.png" width="442"/>
    </p>
    <p>
     其中𝜎𝑖 ​为高斯核带宽，通过二分查找确定以满足**
     <strong>
      perplexity
     </strong>
     **参数（控制邻域大小）。
    </p>
    <h5>
     5.2.2 低维相似度建模
    </h5>
    <p>
     在目标空间中，定义联合概率：
    </p>
    <p class="img-center">
     <img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/47940b53ef2444ee84cb78e32bb82457.png" width="361"/>
    </p>
    <p>
     采用t-分布（自由度为1的Student分布）以增强对异常值的鲁棒性。
    </p>
    <h5>
     5.2.3 目标函数优化
    </h5>
    <p>
     通过最小化KL散度实现分布匹配：
    </p>
    <p class="img-center">
     <img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/ab630535d86c403397bdc12a520f01d2.png" width="303"/>
    </p>
    <p>
     其中
    </p>
    <p class="img-center">
     <img alt="" height="39" src="https://i-blog.csdnimg.cn/direct/c24c16a797924b1a879808161d3ccad1.png" width="334"/>
    </p>
    <p>
     优化过程使用梯度下降：
    </p>
    <p class="img-center">
     <img alt="" height="91" src="https://i-blog.csdnimg.cn/direct/559a07f71c634e09869a6648d5fcc6cc.png" width="586"/>
    </p>
    <h4>
     5.3 算法步骤流程
    </h4>
    <ol>
     <li>
      <strong>
       参数初始化
      </strong>
      ：设置降维维度（如2D）、perplexity（通常5-50）、学习率等
     </li>
     <li>
      <strong>
       高维相似度计算
      </strong>
      ：为每个样本计算条件概率矩阵𝑃P
     </li>
     <li>
      <strong>
       低维初始化
      </strong>
      ：随机生成初始嵌入坐标𝑌Y
     </li>
     <li>
      <strong>
       梯度下降优化
      </strong>
      ：迭代更新𝑌Y以最小化KL散度
     </li>
     <li>
      <strong>
       结果输出
      </strong>
      ：返回低维坐标矩阵
     </li>
    </ol>
    <hr/>
    <h2 id="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3" name="%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3">
     三、代码详解
    </h2>
    <p>
     本文的代码主要分为以下几个部分：
    </p>
    <h3>
     1. 导入库
    </h3>
    <pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from sklearn import datasets
from sklearn import manifold
%matplotlib inline
</code></pre>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       import matplotlib.pyplot as plt
      </code>
      : 导入matplotlib库，用于绘制图像。
     </li>
     <li>
      <code>
       import numpy as np
      </code>
      : 导入numpy库，用于进行数值计算。
     </li>
     <li>
      <code>
       import pandas as pd
      </code>
      : 导入pandas库，用于数据处理。
     </li>
     <li>
      <code>
       import seaborn as sns
      </code>
      : 导入seaborn库，用于数据可视化。
     </li>
     <li>
      <code>
       from sklearn import datasets
      </code>
      : 导入sklearn库中的datasets模块，用于加载数据集。
     </li>
     <li>
      <code>
       from sklearn import manifold
      </code>
      : 导入sklearn库中的manifold模块，用于降维。
     </li>
     <li>
      <code>
       %matplotlib inline
      </code>
      : 在Jupyter Notebook中显示图像。
     </li>
    </ul>
    <h3>
     2. 加载数据
    </h3>
    <pre><code class="language-python"># 加载数据
data = datasets.fetch_openml('mnist_784', version=1, return_X_y=True)
pixel_values, targets = data
targets = targets.astype(int)

# 将DataFrame转换为numpy数组以便更容易操作
# 如果pixel_values已经是numpy数组，这一步可以跳过
if isinstance(pixel_values, pd.DataFrame):
    pixel_values_array = pixel_values.values
else:
    pixel_values_array = pixel_values
</code></pre>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       data = datasets.fetch_openml('mnist_784', version=1, return_X_y=True)
      </code>
      : 使用
      <code>
       datasets.fetch_openml
      </code>
      函数加载MNIST数据集。
      <code>
       'mnist_784'
      </code>
      表示数据集的名称，
      <code>
       version=1
      </code>
      表示数据集的版本，
      <code>
       return_X_y=True
      </code>
      表示返回输入数据和标签。
     </li>
     <li>
      <code>
       pixel_values, targets = data
      </code>
      : 将返回的数据解包为
      <code>
       pixel_values
      </code>
      和
      <code>
       targets
      </code>
      。
      <code>
       pixel_values
      </code>
      包含图像的像素值，
      <code>
       targets
      </code>
      包含图像的标签。
     </li>
     <li>
      <code>
       targets = targets.astype(int)
      </code>
      : 将标签转换为整数类型。
     </li>
     <li>
      <code>
       if isinstance(pixel_values, pd.DataFrame):
      </code>
      : 检查
      <code>
       pixel_values
      </code>
      是否为pandas DataFrame类型。
     </li>
     <li>
      <code>
       pixel_values_array = pixel_values.values
      </code>
      : 如果
      <code>
       pixel_values
      </code>
      为pandas DataFrame类型，则将其转换为numpy数组。
     </li>
     <li>
      <code>
       else: pixel_values_array = pixel_values
      </code>
      : 否则，直接使用
      <code>
       pixel_values
      </code>
      。
     </li>
    </ul>
    <h3>
     3. 显示单个图像
    </h3>
    <pre><code class="language-python"># 显示单个图像
single_image = pixel_values_array[1].reshape(28, 28)
plt.imshow(single_image, cmap='gray')
</code></pre>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       single_image = pixel_values_array[1].reshape(28, 28)
      </code>
      : 选择第一个图像，并将其reshape为28x28的矩阵。
     </li>
     <li>
      <code>
       plt.imshow(single_image, cmap='gray')
      </code>
      : 使用
      <code>
       plt.imshow
      </code>
      函数显示图像，
      <code>
       cmap='gray'
      </code>
      表示使用灰度颜色映射。
     </li>
    </ul>
    <h3>
     <strong>
      4.
     </strong>
     t-SNE降维
    </h3>
    <pre><code class="language-python"># t-SNE降维
tsne = manifold.TSNE(n_components=2, random_state=42)
transformed_data = tsne.fit_transform(pixel_values_array[:3000])
</code></pre>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       tsne = manifold.TSNE(n_components=2, random_state=42)
      </code>
      : 创建一个t-SNE对象。
      <code>
       n_components=2
      </code>
      表示将数据降维到二维空间，
      <code>
       random_state=42
      </code>
      表示设置随机种子，保证结果的可重复性。
     </li>
     <li>
      <code>
       transformed_data = tsne.fit_transform(pixel_values_array[:3000])
      </code>
      : 使用
      <code>
       fit_transform
      </code>
      函数对数据进行降维。这里只使用了前3000个样本，因为t-SNE的计算复杂度较高。
     </li>
    </ul>
    <h3>
     5. 创建DataFrame用于可视化
    </h3>
    <pre><code class="language-python"># 创建DataFrame用于可视化
tsne_df = pd.DataFrame(
    np.column_stack((transformed_data, targets[:3000])),
    columns=["x", "y", "targets"]
)
tsne_df.loc[:, "targets"] = tsne_df.targets.astype(int)
</code></pre>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       tsne_df = pd.DataFrame(...)
      </code>
      : 创建一个pandas DataFrame对象，用于存储降维后的数据和标签。
     </li>
     <li>
      <code>
       np.column_stack((transformed_data, targets[:3000]))
      </code>
      : 将降维后的数据和标签按列拼接在一起。
     </li>
     <li>
      <code>
       columns=["x", "y", "targets"]
      </code>
      : 设置DataFrame的列名。
     </li>
     <li>
      <code>
       tsne_df.loc[:, "targets"] = tsne_df.targets.astype(int)
      </code>
      : 将DataFrame中的标签转换为整数类型。
     </li>
    </ul>
    <h3>
     6. 可视化
    </h3>
    <pre><code class="language-python"># 可视化
# 注意：在新版本的seaborn中，size参数已更改为height
try:
    grid = sns.FacetGrid(tsne_df, hue="targets", size=8)
except TypeError:
    grid = sns.FacetGrid(tsne_df, hue="targets", height=8)
    
grid.map(plt.scatter, "x", "y").add_legend()
</code></pre>
    <p>
     <strong>
      说明
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       grid = sns.FacetGrid(tsne_df, hue="targets", size=8)
      </code>
      : 创建一个seaborn FacetGrid对象，用于可视化降维后的数据。
      <code>
       hue="targets"
      </code>
      表示使用标签作为颜色编码，
      <code>
       size=8
      </code>
      表示设置图像的大小。
     </li>
     <li>
      <code>
       grid.map(plt.scatter, "x", "y").add_legend()
      </code>
      : 使用
      <code>
       plt.scatter
      </code>
      函数绘制散点图，
      <code>
       "x"
      </code>
      和
      <code>
       "y"
      </code>
      表示散点图的横坐标和纵坐标，
      <code>
       add_legend()
      </code>
      表示添加图例。
     </li>
    </ul>
    <h3>
     7. 完整代码
    </h3>
    <pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from sklearn import datasets
from sklearn import manifold
%matplotlib inline

# 加载数据
data = datasets.fetch_openml('mnist_784', version=1, return_X_y=True)
pixel_values, targets = data
targets = targets.astype(int)

# 将DataFrame转换为numpy数组以便更容易操作
# 如果pixel_values已经是numpy数组，这一步可以跳过
if isinstance(pixel_values, pd.DataFrame):
    pixel_values_array = pixel_values.values
else:
    pixel_values_array = pixel_values

# 显示单个图像
single_image = pixel_values_array[1].reshape(28, 28)
plt.imshow(single_image, cmap='gray')

# t-SNE降维
tsne = manifold.TSNE(n_components=2, random_state=42)
transformed_data = tsne.fit_transform(pixel_values_array[:3000])

# 创建DataFrame用于可视化
tsne_df = pd.DataFrame(
    np.column_stack((transformed_data, targets[:3000])),
    columns=["x", "y", "targets"]
)
tsne_df.loc[:, "targets"] = tsne_df.targets.astype(int)

# 可视化
# 注意：在新版本的seaborn中，size参数已更改为height
try:
    grid = sns.FacetGrid(tsne_df, hue="targets", size=8)
except TypeError:
    grid = sns.FacetGrid(tsne_df, hue="targets", height=8)
    
grid.map(plt.scatter, "x", "y").add_legend()</code></pre>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/fea1ab0e85ad45c5866311bd87b3d5de.png"/>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b6da1b126227437db51753060b2c1d32.png"/>
    </p>
    <hr/>
    <h2 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83" name="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83">
     四、总结与思考
    </h2>
    <p>
     本文以MNIST数据集为例，详细介绍了如何使用t-SNE进行高维数据可视化。通过t-SNE降维，我们可以将784维的图像数据降维到二维空间，并在散点图上清晰地看到不同数字之间的分布情况。
    </p>
    <p>
     t-SNE是一种强大的降维技术，但也有一些局限性：
    </p>
    <ul>
     <li>
      <strong>
       计算复杂度高:
      </strong>
      t-SNE的计算复杂度为O(n^2)，对于大规模数据集，计算时间会非常长。
     </li>
     <li>
      <strong>
       参数敏感:
      </strong>
      t-SNE的性能受到参数的影响，例如困惑度 (perplexity) 和学习率 (learning_rate)。
     </li>
     <li>
      <strong>
       全局结构失真:
      </strong>
      t-SNE主要关注局部结构，可能会导致全局结构失真。
     </li>
    </ul>
    <p>
     在实际应用中，我们需要根据具体情况选择合适的降维技术。对于大规模数据集，可以考虑使用PCA或UMAP等更高效的算法。对于需要保留全局结构的场景，可以考虑使用Isomap或LLE等算法。
    </p>
    <hr/>
    <h2 id="%E3%80%90%E4%BD%9C%E8%80%85%E5%A3%B0%E6%98%8E%E3%80%91" name="%E3%80%90%E4%BD%9C%E8%80%85%E5%A3%B0%E6%98%8E%E3%80%91">
     【作者声明】
    </h2>
    <p>
     本文内容基于作者对基于t-SNE的MNIST数据集可视化探索实现过程的实验与总结，所有数据和代码均为原创。文章中的观点仅代表个人见解，供读者参考交流。若有任何问题或建议，欢迎在评论区留言讨论，共同促进技术进步。
    </p>
    <hr/>
    <h2 id="%E3%80%90%E5%85%B3%E6%B3%A8%E6%88%91%E4%BB%AC%E3%80%91" name="%E3%80%90%E5%85%B3%E6%B3%A8%E6%88%91%E4%BB%AC%E3%80%91">
     【关注我们】
    </h2>
    <p>
     如果您对神经网络、群智能算法及人工智能技术感兴趣，欢迎点赞、收藏并转发，与更多朋友一起探讨与交流！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f37373230303332342f:61727469636c652f64657461696c732f313436313631363135" class_="artid" style="display:none">
 </p>
</div>


