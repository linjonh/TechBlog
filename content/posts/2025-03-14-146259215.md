---
layout: post
title: "Linux之进程控制"
date: 2025-03-14 17:09:18 +0800
description: "进程控制"
keywords: "Linux之进程控制"
categories: ['未分类']
tags: ['运维', '服务器', 'Linux']
artid: "146259215"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146259215
    alt: "Linux之进程控制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146259215
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146259215
cover: https://bing.ee123.net/img/rand?artid=146259215
image: https://bing.ee123.net/img/rand?artid=146259215
img: https://bing.ee123.net/img/rand?artid=146259215
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux之进程控制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA" name="%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA">
     进程创建
    </h2>
    <h3 id="fork()" name="fork()">
     fork()
    </h3>
    <p>
     1.函数介绍：pid_t fork();fork函数用于创建子进程，若是创建成功，在子进程中返回0，在父进程返回新创建的子进程的id，若是创建失败，返回-1
    </p>
    <p>
     2.调用fork函数，内核会做什么？
    </p>
    <p>
     &lt;1&gt;分配资源：
    </p>
    <p>
     1)控制进程快：内核为新创建的子进程分配一个新的
     <code>
      task_struct
     </code>
     结构体，这是进程在内核中的核心数据结构，用于存储进程的所有信息，如进程ID、状态、内存映射、文件描述符等。
    </p>
    <p>
     2)内存空间：为子进程分配必要的内存空间，包括用户态的内存（如栈、堆）和内核态的内存
    </p>
    <p>
     &lt;2&gt;复制父进程的代码和数据：
    </p>
    <p>
     1)复制代码段、数据段、堆和栈：内核将父进程的代码段、数据段、堆和栈的内容复制到子进程中。但为了提高效率，现代Linux内核采用了写时复制（Copy-on-Write, COW）技术。这意味着在
     <code>
      fork()
     </code>
     时，实际上并没有立即复制数据，而是让父子进程共享相同的物理内存页。只有当某个进程尝试修改这些共享的内存页时，才会触发缺页异常，内核才会为修改的进程创建这些内存页的副本。
    </p>
    <p>
     2)复制文件描述符表:复制父进程的文件描述符表，使得父子进程可以共享打开的文件。但是，每个文件描述符的引用计数会增加，以反映它被两个进程共享。
    </p>
    <p>
     &lt;3&gt;初始化子进程：
    </p>
    <p>
     1)为新创建的子进程分配一个唯一的进程ID。
    </p>
    <p>
     2)将子进程的状态设置为不可中断睡眠状态（TASK_UNINTERRUPTIBLE），以确保在子进程完成初始化之前不会被调度执行。
    </p>
    <p>
     &lt;4&gt;设置父子关系：
    </p>
    <p>
     1)在父进程的
     <code>
      task_struct
     </code>
     中添加对新创建的子进程的引用。
    </p>
    <p>
     2)在子进程的
     <code>
      task_struct
     </code>
     中设置父进程的引用，以及指向父进程进程组的指针
    </p>
    <p>
     &lt;5&gt;执行调度：
    </p>
    <p>
     1)内核将子进程添加到系统的进程列表中，准备进行调度。
    </p>
    <p>
     2)返回值
    </p>
    <p>
     3.fork函数可以有两个返回值，这是为什么呢？
    </p>
    <p>
     答案是在进行程序调度时发生写实拷贝，子进程和父进程共享大部分的数据和代码，当执行子进程时，在物理内存上对子进程的代码和数据进行拷贝，在另一块物理内存上执行，同理执行父进程时也是如此，故而父进程和子进程在执行时实际上是两个独立的进程，每个进程都会接收fork的返回值
    </p>
    <p>
     补充：写实拷贝
    </p>
    <p>
     &lt;1&gt;概念：写实拷贝是一种内存管理策略，其核心思想是：在多个进程或线程共享同一块内存区域时，如果不进行写操作，则这些进程或线程可以共享同一块物理内存；一旦某个进程或线程尝试对共享内存区域进行写操作，操作系统会为该进程或线程分配一块新的物理内存，并将原共享内存区域的内容复制到新的内存中，以确保数据的一致性和独立性。
    </p>
    <p>
     &lt;2&gt;原理：
    </p>
    <p id="">
     写实拷贝技术通常通过引用计数来实现。在分配共享内存区域时，系统会多分配一些空间来存储引用计数，用于记录有多少个进程或线程正在共享这块内存。当某个进程或线程尝试对共享内存进行写操作时，系统会先检查引用计数：
    </p>
    <p>
     ***如果引用计数大于1，说明有其他进程或线程也在共享这块内存，此时系统会为该进程或线程分配一块新的物理内存，并将原共享内存的内容复制到新内存中，然后将引用计数减1。
    </p>
    <p>
     ***如果引用计数等于1，说明没有其他进程或线程在共享这块内存，此时可以直接对该内存进行写操作，无需复制。
    </p>
    <p>
     &lt;3&gt;好处：提高性能，简化内存管理
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2" name="%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2">
     进程终止
    </h2>
    <h3 id="1.%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9A%84%E5%9C%BA%E6%99%AF" name="1.%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9A%84%E5%9C%BA%E6%99%AF">
     1.进程退出的场景
    </h3>
    <p>
     &lt;1&gt;代码运行完毕，结果正确
    </p>
    <p>
     &lt;2&gt;代码运行完毕，结果不正确
    </p>
    <p>
     &lt;3&gt;代码异常终止
    </p>
    <p>
     注：若代码运行完毕，结果正确与否是通过进程退出码判断的；若进程异常终止，此时进程退出码无意义，而进程出现异常，往往是进程接收了信号
    </p>
    <h3 id="2.%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81%E7%9A%84%E5%91%BD%E4%BB%A4" name="2.%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81%E7%9A%84%E5%91%BD%E4%BB%A4">
     2.查看进程退出码的命令
    </h3>
    <p>
     . echo $? ：此命令用于打印最近一个程序/进程退出时的退出码（因为进程退出码会被写在进程的task_struct内部）
    </p>
    <h3 id="3.%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95" name="3.%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95">
     3.进程退出的方法
    </h3>
    <p>
     &lt;1&gt;在main函数内部写return
    </p>
    <p>
     &lt;2&gt;使用exit(进程退出码)函数，在任何地方调用exit()，进程会结束，同时将子进程的进程退出码返回给父进程
    </p>
    <p>
     &lt;3&gt;使用_exit(进程退出码)函数
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
       </td>
       <td>
        exit
       </td>
       <td>
        _exit
       </td>
      </tr>
      <tr>
       <td>
        头文件
       </td>
       <td>
        &lt;stdlib.h&gt;
       </td>
       <td>
        &lt;unistd.h&gt;
       </td>
      </tr>
      <tr>
       <td>
        是否进行缓冲区刷新
       </td>
       <td>
        是
       </td>
       <td>
        否
       </td>
      </tr>
      <tr>
       <td>
        返回值
       </td>
       <td>
        将代表退出状态的整数返回
       </td>
       <td>
        将代表退出状态的整数返回
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     注：exit函数底层封装了_exit函数
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85" name="%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85">
     进程等待
    </h2>
    <h3 id="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%9F" name="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%9F">
     1.为什么要进行进程等待？
    </h3>
    <p>
     答案是通过等待，解决内存泄漏问题，回收子进程资源；获取子进程的退出信息
    </p>
    <h3 id="2.%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%9F" name="2.%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%9F">
     2.如何进行进程等待？
    </h3>
    <p>
     &lt;1&gt;pid_t wait(int* status);
    </p>
    <p>
     1)功能：使父进程等待任意一个子进程结束，并获取子进程的终止状态
    </p>
    <p>
     2)头文件：&lt;sys/wait.h&gt;
    </p>
    <p>
     3)参数解释：
     <strong>
      status:
     </strong>
     一个指向整数的指针，用于存储子进程的终止状态。如果不需要这个信息，可以传递
     <code>
      NULL
     </code>
     。
    </p>
    <p>
     4)返回值：成功返回子进程的id；失败返回-1，并设置errno指示错误信息
    </p>
    <p>
     &lt;2&gt;pid_t waitpid(pid_t pid,int* status,int options);
    </p>
    <p>
     1)功能：使父进程等待特定子进程结束，设置是否阻塞父进程模式，并获取子进程的终止状态
    </p>
    <p>
     2)头文件：&lt;sys/wait.h&gt;
    </p>
    <p>
     3)参数解释：
    </p>
    <p>
     <strong>
      pid
     </strong>
     :指定要等待的子进程的进程 ID
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        &gt;0
       </td>
       <td>
        等待进程 ID 等于
        <code>
         pid
        </code>
        的子进程
       </td>
      </tr>
      <tr>
       <td>
        =0
       </td>
       <td>
        等待与调用进程属于同一个进程组的任意子进程
       </td>
      </tr>
      <tr>
       <td>
        &lt;-1
       </td>
       <td>
        等待进程组 ID 等于
        <code>
         pid
        </code>
        绝对值的任意子进程
       </td>
      </tr>
      <tr>
       <td>
        =-1
       </td>
       <td>
        等待任意一个子进程，此时
        <code>
         waitpid
        </code>
        的行为与
        <code>
         wait
        </code>
        类似
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p id="">
     <strong>
      status
     </strong>
     :指向整数的指针，用于存储子进程的终止状态。如果不需要这个信息，可以传递
     <code>
      NULL
     </code>
    </p>
    <p>
     <strong>
      options
     </strong>
     :设置是否阻塞，默认为0
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        WNOHANG
       </td>
       <td>
        如果没有子进程结束，则立即返回
        <code>
         0
        </code>
        ，而不是阻塞等待。这允许父进程以非阻塞的方式检查子进程的状态
       </td>
      </tr>
      <tr>
       <td>
        WUNTRACED
       </td>
       <td>
        除了等待终止的子进程外，还等待被暂停（stopped）的子进程
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     4)返回值：
    </p>
    <p>
     &gt;0说明等待结束，返回子进程的id；
    </p>
    <p>
     =0说明调用结束，但是子进程没有退出；
    </p>
    <p>
     &lt;0说明等待失败，并设置errno指示错误信息
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2" name="%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2">
     进程替换
    </h2>
    <h3 id="1.%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%A6%82%E5%BF%B5%EF%BC%9A" name="1.%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%A6%82%E5%BF%B5%EF%BC%9A">
     1.进程替换概念：
    </h3>
    <p>
     进程替换允许一个进程在运行过程中被另一个新的进程完全替换，在进程替换发生时，原有进程的代码、数据和资源会被新的进程所取代，新进程开始执行，原有进程的执行状态和上下文信息会被丢弃。
    </p>
    <h3 id="2.%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%90%86%EF%BC%9A" name="2.%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%90%86%EF%BC%9A">
     2.进程替换原理：
    </h3>
    <p>
     父进程通过fork函数创建子进程，子进程内部调用exec*系列函数来执行新进程。
     <span style="color:#fe2c24">
      <code>
       exec
      </code>
      系列函数不会创建新进程，而是直接用新程序替换当前进程的内容,一旦替换完成，后续代码将不在执行。
     </span>
     调用
     <code>
      exec
     </code>
     函数后，当前进程的代码和数据完全被新程序替换，从新程序的启动例程（通常是
     <code>
      main
     </code>
     函数）开始执行。尽管进程的代码和数据被替换了，但进程的 ID（PID）、父进程 ID（PPID）、文件描述符等关键信息会被保留。在进程替换之后，父进程仍然可以通过原来的 PID 来等待子进程的结束
    </p>
    <h3 id="3.%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3--exec*%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97" name="3.%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E7%9A%84%E6%8E%A5%E5%8F%A3--exec*%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97">
     3.进程替换的接口--exec*函数系列
    </h3>
    <p>
     &lt;1&gt;int execl(const char* path,const char* arg,...);
    </p>
    <p>
     直接接受参数列表和环境变量（或继承当前环境变量）
    </p>
    <p>
     &lt;2&gt;int execlp(const char* file,const char* arg,...);
    </p>
    <p>
     接受程序名而不是路径，并使用
     <code>
      PATH
     </code>
     环境变量来查找程序
    </p>
    <p>
     &lt;3&gt;int execv(const char* path,const char* argv[]);
    </p>
    <p>
     接受参数列表作为数组，并继承当前环境变量。
    </p>
    <p>
     &lt;4&gt;int execvp(const char* file,const char* argv[]);
    </p>
    <p>
     类似于
     <code>
      execv
     </code>
     ，但接受程序名并使用
     <code>
      PATH
     </code>
     环境变量查找。
    </p>
    <p>
     &lt;5&gt;int execvpe(const char* file,const char* argv[],char* const envp[]);
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6f7ecce2ea9947ff953fac2750f45ccb.png"/>
    </p>
    <p>
     1)参数解释：
    </p>
    <p>
     path:路径+程序名，用于解释我要执行什么
    </p>
    <p>
     file:要执行的文件名（因为会自动在环境变量PATH中查找指定命令）
    </p>
    <p>
     arg:可变参数列表，命令行怎么写，我就怎么写，最后要以NULL结尾
    </p>
    <p>
     argv[]:参数列表数组，第一个元素是程序名，最后一个元素是
     <code>
      NULL
     </code>
    </p>
    <p>
     envp[]:存放环境变量的指针数组列表
    </p>
    <p>
     2)返回值：成功不返回任何东西；失败返回-1，并设置errno指示错误信息
    </p>
    <p>
     3)若要将新的环境变量添加到子进程内？
    </p>
    <p>
     方法一：使用putenv()，在哪个进程调用它，就在哪个进程新增环境变量
    </p>
    <p>
     方法二：使用extern char** environ;声明，再调用execvpe(file,argv[],envp[],environ)函数
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303030313334332f:61727469636c652f64657461696c732f313436323539323135" class_="artid" style="display:none">
 </p>
</div>


