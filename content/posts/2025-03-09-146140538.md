---
layout: post
title: "C-滑动窗口"
date: 2025-03-09 23:16:49 +0800
description: "该文章为C++语言滑动窗口的基础算法"
keywords: "C++ 滑动窗口"
categories: ['未分类']
tags: ['算法', '数据结构', 'Leetcode', 'C']
artid: "146140538"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146140538
    alt: "C-滑动窗口"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146140538
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146140538
cover: https://bing.ee123.net/img/rand?artid=146140538
image: https://bing.ee123.net/img/rand?artid=146140538
img: https://bing.ee123.net/img/rand?artid=146140538
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ 滑动窗口
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     前言
    </h2>
    <p>
     C++ 中滑动窗口分两种，一种是给定窗口长度，还有一种是不定长窗口长度。
    </p>
    <p>
     本篇文章主要讲解这两种状态的滑动窗口，结合例题让读者更好的理解
    </p>
    <h2 style="background-color:transparent">
     一、给定窗口长度K
    </h2>
    <p>
     一般的，对于给定窗口长度的题，通常要求我们对窗口内的元素进行一些操作，解决一些问题，具体问题具体分析。
    </p>
    <p>
     给定窗口长度的题目通常要求解决以下问题：
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        找到每个窗口内的最大值或最小值。
       </p>
      </li>
      <li>
       <p>
        计算每个窗口的和或平均值。
       </p>
      </li>
      <li>
       <p>
        统计满足条件的子数组数量。
       </p>
      </li>
      <li>
       <p>
        找到满足条件的最长或最短子数组。
       </p>
      </li>
      <li>
       <p>
        统计窗口内的唯一元素数量。
       </p>
      </li>
     </ul>
    </blockquote>
    <p>
     可以在 O(n) 的时间复杂度内解决问题
    </p>
    <h3>
     题目1：
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/" rel="nofollow" title="力扣 1343 题大小为 K 且平均值大于等于阈值的子数组数目">
      力扣 1343 题大小为 K 且平均值大于等于阈值的子数组数目
     </a>
    </p>
    <p id="uacff14b0">
     给你一个整数数组
     <code>
      arr
     </code>
     和两个整数
     <code>
      k
     </code>
     和
     <code>
      threshold
     </code>
     。
    </p>
    <p id="ua3137245">
     请你返回长度为
     <code>
      k
     </code>
     且平均值大于等于
     <code>
      threshold
     </code>
     的子数组数目。
    </p>
    <p id="u2ba9e978">
     <strong>
      示例 1：
     </strong>
    </p>
    <blockquote>
     <p>
      输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
      <br/>
      输出：3
      <br/>
      解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。
     </p>
    </blockquote>
    <p id="uae7dd4f9">
     <strong>
      示例 2：
     </strong>
    </p>
    <blockquote>
     <p>
      输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
      <br/>
      输出：6
      <br/>
      解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数
     </p>
    </blockquote>
    <p>
     直接上代码：
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int numOfSubarrays(vector&lt;int&gt;&amp; arr, int k, int threshold) {
        int ans = 0;
        int s = 0; // 维护窗口元素和
        for (int i = 0; i &lt; arr.size(); i++) {
            // 1. 进入窗口
            s += arr[i];
            
            if (i &lt; k - 1) { // 窗口大小不足 k
                continue;
            }
            // 2. 更新答案
            ans += s &gt;= k * threshold;
            // 3. 离开窗口
            s -= arr[i - k + 1];
        }
        return ans;
    }
};
</code></pre>
    <p>
     解释：总共主要分3步，不足窗口长度的先进入窗口，满足长度等于窗口大小后更新答案，之后就是窗口往后移，右边元素进入窗口，左边元素移除窗口，然后不断更新答案。
    </p>
    <h3>
     题目2：
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/" rel="nofollow" title="力扣2461题长度为 K 子数组中的最大和">
      力扣2461题长度为 K 子数组中的最大和
     </a>
    </p>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     和一个整数
     <code>
      k
     </code>
     。请你从
     <code>
      nums
     </code>
     中满足下述条件的全部子数组中找出最大子数组和：
    </p>
    <ul>
     <li>
      子数组的长度是
      <code>
       k
      </code>
      ，且
     </li>
     <li>
      子数组中的所有元素
      <strong>
       各不相同 。
      </strong>
     </li>
    </ul>
    <p>
     返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回
     <code>
      0
     </code>
     。
    </p>
    <p>
     <strong>
      子数组
     </strong>
     是数组中一段连续非空的元素序列。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>nums = [1,5,4,2,9,9,9], k = 3
<strong>输出：</strong>15
<strong>解释：</strong>nums 中长度为 3 的子数组是：
- [1,5,4] 满足全部条件，和为 10 。
- [5,4,2] 满足全部条件，和为 11 。
- [4,2,9] 满足全部条件，和为 15 。
- [2,9,9] 不满足全部条件，因为元素 9 出现重复。
- [9,9,9] 不满足全部条件，因为元素 9 出现重复。
因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。
</pre>
    </blockquote>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>nums = [4,4,4], k = 3
<strong>输出：</strong>0
<strong>解释：</strong>nums 中长度为 3 的子数组是：
- [4,4,4] 不满足全部条件，因为元素 4 出现重复。
因为不存在满足全部条件的子数组，所以返回 0 。</pre>
    </blockquote>
    <p>
     上代码看注释来理解
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    long long maximumSubarraySum(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();  // 获取数组的长度
        long long sum = 0;    // 当前窗口的和
        long long ma = 0;     // 用于存储最大子数组和
        unordered_map&lt;int, int&gt; hash;  // 哈希表，用于记录窗口内每个元素的出现次数

        // 初始化窗口的前 k-1 个元素
        for (int i = 0; i &lt; k - 1; i++) {
            hash[nums[i]]++;  // 更新元素的出现次数
            sum += nums[i];   // 将元素加入当前窗口的和
        }

        // 遍历数组，维护一个大小为 k 的滑动窗口
        for (int i = k - 1; i &lt; n; i++) {
            hash[nums[i]]++;  // 将当前元素加入窗口，并更新其出现次数
            sum += nums[i];   // 更新当前窗口的和

            // 如果窗口内有 k 个不同的元素，更新最大和
            if (hash.size() == k) {
                ma = max(ma, sum);  // 更新最大子数组和
            }

            // 移动窗口：移除窗口左侧的元素
            hash[nums[i - k + 1]]--;  // 减少左侧元素的出现次数
            if (hash[nums[i - k + 1]] == 0) {
                hash.erase(nums[i - k + 1]);  // 如果元素的出现次数为 0，从哈希表中移除
            }
            sum -= nums[i - k + 1];  // 从当前窗口的和中移除左侧元素
        }

        return ma;  // 返回最大子数组和
    }
};</code></pre>
    <p>
     <strong>
      逻辑解释：
     </strong>
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        <strong>
         初始化窗口
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          使用一个哈希表
          <code>
           hash
          </code>
          来记录窗口内每个元素的出现次数。
         </p>
        </li>
        <li>
         <p>
          使用
          <code>
           sum
          </code>
          来记录当前窗口的和。
         </p>
        </li>
        <li>
         <p>
          首先将前
          <code>
           k-1
          </code>
          个元素加入窗口，初始化
          <code>
           sum
          </code>
          和
          <code>
           hash
          </code>
          。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         滑动窗口遍历
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          从第
          <code>
           k-1
          </code>
          个元素开始遍历数组。
         </p>
        </li>
        <li>
         <p>
          每次将当前元素
          <code>
           nums[i]
          </code>
          加入窗口，并更新其出现次数和窗口的和。
         </p>
        </li>
        <li>
         <p>
          检查窗口内是否有
          <code>
           k
          </code>
          个不同的元素：
         </p>
         <ul>
          <li>
           <p>
            如果有
            <code>
             k
            </code>
            个不同的元素，更新最大和
            <code>
             ma
            </code>
            。
           </p>
          </li>
         </ul>
        </li>
        <li>
         <p>
          移动窗口：移除窗口左侧的元素
          <code>
           nums[i-k+1]
          </code>
          ，更新其出现次数和窗口的和。
         </p>
         <ul>
          <li>
           <p>
            如果某个元素的出现次数变为 0，从哈希表中移除该元素。
           </p>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         返回结果
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          遍历结束后，
          <code>
           ma
          </code>
          中存储的就是满足条件的最大子数组和。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h2>
     二、不定长窗口大小
    </h2>
    <p id="ud4a3fac5">
     不定长滑动窗口主要分为三类：求
     <strong>
      最长子数组
     </strong>
     ，求
     <strong>
      最短子数组
     </strong>
     ，以及求
     <strong>
      子数组个数
     </strong>
     。
    </p>
    <p>
     通常我们对于处理串的问题时，使用暴力算法超时的时候，就可以考虑使用滑动窗口来优化时间了
    </p>
    <p>
     看题目来加深理解
    </p>
    <h3>
     题目1：
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/fruit-into-baskets/" rel="nofollow" title="力扣904题水果成篮">
      力扣904题水果成篮
     </a>
    </p>
    <p>
     你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组
     <code>
      fruits
     </code>
     表示，其中
     <code>
      fruits[i]
     </code>
     是第
     <code>
      i
     </code>
     棵树上的水果
     <strong>
      种类
     </strong>
     。
    </p>
    <p>
     你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
    </p>
    <ul>
     <li>
      你只有
      <strong>
       两个
      </strong>
      篮子，并且每个篮子只能装
      <strong>
       单一类型
      </strong>
      的水果。每个篮子能够装的水果总量没有限制。
     </li>
     <li>
      你可以选择任意一棵树开始采摘，你必须从
      <strong>
       每棵
      </strong>
      树（包括开始采摘的树）上
      <strong>
       恰好摘一个水果
      </strong>
      。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
     </li>
     <li>
      一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
     </li>
    </ul>
    <p>
     给你一个整数数组
     <code>
      fruits
     </code>
     ，返回你可以收集的水果的
     <strong>
      最大
     </strong>
     数目。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>fruits = [<em><strong>1,2,1</strong></em>]
<strong>输出：</strong>3
<strong>解释：</strong>可以采摘全部 3 棵树。
</pre>
    </blockquote>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>fruits = [0,<em><strong>1,2,2</strong></em>]
<strong>输出：</strong>3
<strong>解释：</strong>可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
</pre>
    </blockquote>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>fruits = [1,<em><strong>2,3,2,2</strong></em>]
<strong>输出：</strong>4
<strong>解释：</strong>可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
</pre>
    </blockquote>
    <p>
     <strong>
      示例 4：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>fruits = [3,3,3,<em><strong>1,2,1,1,2</strong></em>,3,3,4]
<strong>输出：</strong>5
<strong>解释：</strong>可以采摘 [1,2,1,1,2] 这五棵树。</pre>
    </blockquote>
    <p>
     <strong>
      AC代码
     </strong>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) {
        int n = fruits.size();  // 获取果树的数量
        unordered_map&lt;int, int&gt; hash;  // 哈希表，用于记录当前窗口内每种水果的数量
        int left = 0;  // 滑动窗口的左边界
        int ma = 0;  // 用于记录最多可以采摘的水果数量

        // 遍历所有果树，right 表示滑动窗口的右边界
        for (int right = 0; right &lt; n; right++) {
            hash[fruits[right]]++;  // 将当前果树的水果加入窗口，并更新其数量

            // 如果窗口内有超过两种水果，需要收缩窗口
            while (hash.size() &gt; 2) {
                int out = fruits[left];  // 获取窗口左侧的水果
                hash[out]--;  // 减少左侧水果的数量
                if (hash[out] == 0) {
                    hash.erase(out);  // 如果某种水果的数量变为 0，从哈希表中移除
                }
                left++;  // 移动左边界，缩小窗口
            }

            // 更新最多可以采摘的水果数量
            // 当前窗口的水果数量为 right - left + 1
            ma = max(ma, right - left + 1);
        }

        return ma;  // 返回最多可以采摘的水果数量
    }
};</code></pre>
    <p>
     很多题套路都差不多的，对于不定长滑动窗口大小，用的比较多的就是哈希表来存储
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        <strong>
         初始化
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          <code>
           n
          </code>
          ：果树的总数。
         </p>
        </li>
        <li>
         <p>
          <code>
           hash
          </code>
          ：哈希表，用于记录当前窗口内每种水果的数量。
         </p>
        </li>
        <li>
         <p>
          <code>
           left
          </code>
          ：滑动窗口的左边界，初始值为0。
         </p>
        </li>
        <li>
         <p>
          <code>
           ma
          </code>
          ：用于记录最多可以采摘的水果数量，初始值为0。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         滑动窗口遍历
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          使用
          <code>
           right
          </code>
          作为滑动窗口的右边界，从左到右遍历所有果树。
         </p>
        </li>
        <li>
         <p>
          每次将当前果树的水果加入窗口，并更新其在哈希表中的数量。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         收缩窗口
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          如果当前窗口内有超过两种水果（
          <code>
           hash.size() &gt; 2
          </code>
          ），需要收缩窗口。
         </p>
        </li>
        <li>
         <p>
          移动左边界
          <code>
           left
          </code>
          ，移除窗口左侧的水果，直到窗口内只剩下两种水果。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         更新结果
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          每次调整窗口后，计算当前窗口的水果数量（
          <code>
           right - left + 1
          </code>
          ），并更新最大值
          <code>
           ma
          </code>
          。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         返回结果
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          遍历结束后，
          <code>
           ma
          </code>
          中存储的就是最多可以采摘的水果数量。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h3 style="background-color:transparent">
     题目2：
    </h3>
    <p>
     <a href="https://leetcode.cn/problems/maximum-erasure-value/" rel="nofollow" title="力扣1695题删除子数组的最大得分">
      力扣1695题删除子数组的最大得分
     </a>
    </p>
    <p>
     给你一个正整数数组
     <code>
      nums
     </code>
     ，请你从中删除一个含有
     <strong>
      若干不同元素
     </strong>
     的子数组
     <strong>
      。
     </strong>
     删除子数组的
     <strong>
      得分
     </strong>
     就是子数组各元素之
     <strong>
      和
     </strong>
     。
    </p>
    <p>
     返回
     <strong>
      只删除一个
     </strong>
     子数组可获得的
     <strong>
      最大得分
     </strong>
     <em>
      。
     </em>
    </p>
    <p>
     如果数组
     <code>
      b
     </code>
     是数组
     <code>
      a
     </code>
     的一个连续子序列，即如果它等于
     <code>
      a[l],a[l+1],...,a[r]
     </code>
     ，那么它就是
     <code>
      a
     </code>
     的一个子数组。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>nums = [4,2,4,5,6]
<strong>输出：</strong>17
<strong>解释：</strong>最优子数组是 [2,4,5,6]
</pre>
    </blockquote>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <blockquote>
     <pre><strong>输入：</strong>nums = [5,2,1,2,5,2,1,2,5]
<strong>输出：</strong>8
<strong>解释：</strong>最优子数组是 [5,2,1] 或 [1,2,5]</pre>
    </blockquote>
    <p>
     这题和上题非常相识，都是同一个套路，变的就是题目给的条件
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();  // 获取数组的长度
        long long ma = 0;     // 用于存储最大唯一子数组的和
        int left = 0;         // 滑动窗口的左边界
        long long sum = 0;    // 当前窗口内所有元素的和
        unordered_map&lt;int, int&gt; hash;  // 哈希表，用于记录窗口内每个元素的出现次数

        // 遍历数组，right 表示滑动窗口的右边界
        for (int right = 0; right &lt; n; right++) {
            // 将当前元素加入窗口，并更新其出现次数
            hash[nums[right]]++;
            sum += nums[right];  // 更新当前窗口的和

            // 如果当前元素的出现次数大于 1，说明窗口内有重复元素
            // 需要收缩窗口，移除窗口左侧的元素，直到窗口内没有重复元素
            while (hash[nums[right]] &gt; 1) {
                sum -= nums[left];  // 从窗口的和中移除左侧元素
                hash[nums[left]]--;  // 更新左侧元素的出现次数
                left++;  // 移动左边界
            }

            // 更新最大唯一子数组的和
            ma = max(ma, sum);
        }

        return ma;  // 返回最大唯一子数组的和
    }
};</code></pre>
    <p>
     万变不离其宗，只有多刷题才能加深算法的印象。祝各位读者在刷算法的路上越走越远 0v0!
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333031373630342f:61727469636c652f64657461696c732f313436313430353338" class_="artid" style="display:none">
 </p>
</div>


