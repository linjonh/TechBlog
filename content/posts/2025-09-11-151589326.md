---
layout: post
title: "MySQL-主键约束表的-身份证,数据完整性的核心保障"
date: 2025-09-11T21:40:27+0800
description: "MySQL主键约束是确保数据完整性的核心机制，它通过唯一且非空的字段标识每条记录。文章介绍了单字段主键（推荐自增整数）、复合主键（多字段组合）的基本用法，强调了主键设计原则：必须存在、优先使用无业务意义的自增整数、避免字符串和复合主键。同时指出常见错误如手动生成ID、允许NULL值等，并总结&amp;quot;必选、优选、慎选、少用、不做&amp;quot;的终极口诀。合理的主键设计能显著提升数据库性能和可维护性。"
keywords: "MySQL 主键约束：表的 “身份证”，数据完整性的核心保障"
categories: ['未分类']
tags: ['数据库', 'Mysql']
artid: "151589326"
arturl: "https://blog.csdn.net/m0_60277481/article/details/151589326"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151589326
    alt: "MySQL-主键约束表的-身份证,数据完整性的核心保障"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151589326
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151589326
cover: https://bing.ee123.net/img/rand?artid=151589326
image: https://bing.ee123.net/img/rand?artid=151589326
img: https://bing.ee123.net/img/rand?artid=151589326
---



# MySQL 主键约束：表的 “身份证”，数据完整性的核心保障



## MySQL 主键约束：表的 “身份证”，数据完整性的核心保障

在 MySQL 数据库设计中，主键约束（PRIMARY KEY）是最基础也最重要的约束 —— 它为表中的每条记录提供唯一标识，就像现实世界中的身份证号。正确使用主键约束，能解决 80% 的 “记录定位” 和 “数据重复” 问题。本文从基础用法到核心原则，带你彻底掌握这个数据库设计的 “必备技能”。

### 一、什么是主键约束？一句话讲透本质

主键约束的核心作用：**通过一个或多个字段，唯一标识表中的每条记录，且该字段（或组合）的值非空且唯一**。

简单说，主键要满足两个硬性条件：

* **非空（NOT NULL）**：不能没有值（不像唯一约束允许 NULL）；
* **唯一（UNIQUE）**：不能重复（确保每条记录都能被单独定位）。

例如：

* 用户表的id字段：1、2、3…… 每个用户一个唯一 ID，绝不重复且不能为空；
* 订单表的order_no字段：20240501001、20240501002…… 每个订单号唯一，确保能精准查询某笔订单。

### 二、基本用法：3 种场景的标准操作

主键约束的用法集中在 “定义” 和 “管理”，掌握以下 3 种操作，就能应对绝大多数开发场景。

#### 1. 创建表时定义单字段主键（最常用）

单字段主键是 80% 场景的选择，尤其是用自增整数（INT AUTO_INCREMENT）作为主键，简洁高效。

```sql
-- 示例：用户表（单字段主键，推荐用法）
CREATE TABLE users (
  id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,  -- 主键：自增非负整数
  username VARCHAR(50) NOT NULL,
  phone CHAR(11) NOT NULL UNIQUE
);

-- 插入数据时，主键可自动生成（无需手动指定）
INSERT INTO users (username, phone) VALUES 
('张三', '13800138000'),
('李四', '13900139000');

-- 结果：id自动为1、2，唯一且非空

```

**为什么推荐INT UNSIGNED AUTO_INCREMENT？**

* INT UNSIGNED：范围 0~42 亿，足够大多数业务；
* AUTO_INCREMENT：自动增长，避免手动生成 ID 的重复风险；
* 存储空间小（4 字节），查询速度快（主键索引效率最高）。

#### 2. 创建表时定义复合主键（特殊场景）

当 “单个字段无法唯一标识记录” 时，用多个字段组合作为主键（复合主键），常见于 “关联表”（如学生选课表）。

```sql
-- 示例：学生选课表（复合主键：student_id+course_id）
CREATE TABLE student_course (
  student_id INT UNSIGNED NOT NULL,  -- 学生ID
  course_id INT UNSIGNED NOT NULL,   -- 课程ID
  score DECIMAL(5,2),
  -- 复合主键：两个字段组合唯一，确保同一学生不重复选同一课程
  PRIMARY KEY (student_id, course_id)
);

-- 插入数据：组合不重复则成功
INSERT INTO student_course (student_id, course_id) VALUES (101, 201);  -- 成功
INSERT INTO student_course (student_id, course_id) VALUES (101, 202);  -- 成功
INSERT INTO student_course (student_id, course_id) VALUES (101, 201);  -- 失败（重复组合）

```

**注意**：复合主键会让表结构更复杂，查询时需用所有主键字段，非必要不使用（优先考虑新增单字段主键，如id INT PRIMARY KEY AUTO_INCREMENT）。复合主键其中有一个为null就添加失败。

#### 3. 修改表时添加 / 删除主键（极少用，谨慎操作）

主键一旦定义，通常不会修改，但业务变更时可能需要调整（需先删除旧主键，再添加新主键）。

```sql
-- 场景1：给现有表添加主键（需确保字段非空且唯一）
-- 步骤1：先确保字段无NULL和重复值
UPDATE old_table SET id = 1 WHERE id IS NULL;  -- 处理NULL
-- 步骤2：添加主键
ALTER TABLE old_table ADD PRIMARY KEY (id);

-- 场景2：删除主键（谨慎！会导致记录失去唯一标识）
ALTER TABLE old_table DROP PRIMARY KEY;

```

**警告**：删除主键会导致表失去唯一标识，索引失效，查询性能暴跌，非特殊情况禁止操作。

### 三、核心原则：主键设计的 “黄金标准”

主键设计直接影响表的性能和可维护性，遵循以下原则，能避开 80% 的坑。

#### 1. 每张表必须有主键（无例外）

没有主键的表就像 “没有身份证的人群”，无法精准定位记录，会导致：

* 无法创建有效的索引，查询缓慢；
* 无法通过主键关联其他表（如外键约束依赖主键）；
* 数据重复风险（无法确保记录唯一）。

**反例**：某系统的日志表未设主键，后期需要删除某条日志时，因无法精准定位，只能全表扫描，效率极低。

#### 2. 优先选择 “无业务意义的自增整数”

主键的核心作用是 “唯一标识”，而非存储业务信息，选择 “与业务无关的自增整数” 有三大优势：

* **稳定**：不会因业务变更（如用户手机号更换）而变动；
* **高效**：整数比字符串（如 UUID）存储更小，索引查询更快；
* **简单**：自动增长，无需手动生成（避免重复逻辑）。

**反例**：用手机号作为用户表主键，当用户更换手机号时，需修改主键，还会影响所有关联表（如订单表的user_id），风险极高。

#### 3. 避免使用字符串作为主键（除非万不得已）

字符串（如 UUID、身份证号）作为主键存在明显缺陷：

* **占空间**：UUID（36 字符）是 INT（4 字节）的 9 倍，浪费存储；
* **查询慢**：字符串比较比整数耗时，影响索引效率；
* **碎片多**：UUID 无序，插入时会导致索引碎片化，性能下降。

**例外场景**：分布式系统需要全局唯一 ID 时，可考虑 UUID，但需权衡性能影响。

#### 4. 复合主键尽量不用（用单字段替代）

复合主键会增加表的复杂度，例如 “学生选课表” 用(student_id, course_id)作为主键：

* 查询时必须带两个条件（WHERE student_id=? AND course_id=?），无法通过单个字段快速定位；
* 关联其他表时（如成绩表），需传递多个字段，操作繁琐。

**优化方案**：新增单字段主键id，用唯一约束保证(student_id, course_id)不重复：

```sql
CREATE TABLE student_course (
  id INT PRIMARY KEY AUTO_INCREMENT,  -- 单字段主键
  student_id INT UNSIGNED NOT NULL,
  course_id INT UNSIGNED NOT NULL,
  UNIQUE KEY uk_student_course (student_id, course_id)  -- 用唯一约束防重复
);

```

### 四、避坑指南：主键使用的 5 个常见错误

* **主键值手动生成，导致重复**

错误：用代码生成 ID（如max(id)+1），高并发下会产生重复值；

正确：用AUTO_INCREMENT自动生成，MySQL 内部保证唯一。

* **主键字段允许 NULL 或重复**

错误：创建主键时未确保字段非空或存在重复数据，导致创建失败；

正确：添加主键前，先执行SELECT COUNT(*) FROM 表名 WHERE 主键字段 IS NULL和SELECT 主键字段, COUNT(*) FROM 表名 GROUP BY 主键字段 HAVING COUNT(*)>1，确保无 NULL 和重复。

* **频繁更新主键值**

错误：因业务需求修改主键（如用户 ID 从 1001 改为 2001）；

后果：会导致关联表的外键失效，索引重建，性能暴跌；

正确：主键一旦生成，永不修改（业务信息变更用其他字段存储）。

* **用 UUID 作为主键且不排序**

错误：直接用UUID()生成无序主键，导致索引碎片化；

优化：用UUID_TO_BIN(UUID(), 1)生成有序二进制 UUID，减少碎片。

* **一张表多个主键**

错误：试图给一张表添加多个主键（PRIMARY KEY (id), PRIMARY KEY (code)）；

后果：MySQL 会报错（一张表只能有一个主键）；

正确：用唯一约束实现 “多字段唯一”，主键保持一个。

### 五、总结：主键设计的 “终极口诀”

* **必选**：每张表必有主键，无主键的表是 “废表”；
* **优选**：自增整数（INT UNSIGNED AUTO_INCREMENT），简单高效无业务关联；
* **慎选**：字符串主键（如 UUID），仅分布式系统特殊场景用；
* **少用**：复合主键，能用单字段 + 唯一约束替代就不用；
* **不做**：不手动生成主键，不更新主键值，不允许主键为 NULL 或重复。

主键是表的 “基石”，花 5 分钟做好主键设计，能为后续开发节省 50 小时的性能优化和问题排查时间。记住：好的主键设计，是 “隐形” 的 —— 它默默工作，不干扰业务，却让整个数据库更稳定、更高效。



