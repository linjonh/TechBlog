---
layout: post
title: "Spring-MVC源码分析请求处理流程"
date: 2025-03-12 22:17:45 +0800
description: "在Spring MVC中，请求处理的关键是的doDispatch方法：其中包含了@RequestBody,@ResponseBody等注解的解析，参数的适配，方法拦截器的执行，目标方法的执行，返回值处理，以及异常处理等逻辑。Spring MVC整体请求流程，本篇只简单地进行主要流程的分析，诸如如何解析参数，解析返回值，渲染视图等不在此列。客户端请求↓↓↓HandlerExecutionChain（包含Handler和拦截器）↓调用拦截器 preHandle()↓。"
keywords: "Spring MVC源码分析の请求处理流程"
categories: ['源码分析']
tags: ['后端', 'Springboot', 'Spring', 'Mvc', 'Java']
artid: "146213280"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146213280
    alt: "Spring-MVC源码分析请求处理流程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146213280
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146213280
cover: https://bing.ee123.net/img/rand?artid=146213280
image: https://bing.ee123.net/img/rand?artid=146213280
img: https://bing.ee123.net/img/rand?artid=146213280
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring MVC源码分析の请求处理流程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_4">
     </a>
     前言
    </h2>
    <p>
     在Spring MVC中，请求处理的关键是
     <code>
      DispatcherServlet
     </code>
     的
     <code>
      doDispatch
     </code>
     方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f8142b60515f4daaac0f83c6f98c1384.png">
      其中包含了@RequestBody,@ResponseBody等注解的解析，参数的适配，方法拦截器的执行，目标方法的执行，返回值处理，以及异常处理等逻辑。
      <br/>
      Spring MVC整体请求流程，本篇只简单地进行主要流程的分析，诸如如何解析参数，解析返回值，渲染视图等不在此列。
     </img>
    </p>
    <blockquote>
     <p>
      客户端请求
      <br/>
      ↓
      <br/>
      DispatcherServlet
      <br/>
      ↓
      <br/>
      getHandler(request)
      <br/>
      ↓
      <br/>
      HandlerExecutionChain（包含Handler和拦截器）
      <br/>
      ↓
      <br/>
      调用拦截器 preHandle()
      <br/>
      ↓
      <br/>
      调用 Controller 方法
      <br/>
      ↓
      <br/>
      调用拦截器 postHandle()
      <br/>
      ↓
      <br/>
      返回视图、渲染
      <br/>
      ↓
      <br/>
      调用拦截器 afterCompletion()
     </p>
    </blockquote>
    <h2>
     <a id="doDispatch_30">
     </a>
     一、doDispatch
    </h2>
    <h3>
     <a id="11_32">
     </a>
     1.1、检查文件上传
    </h3>
    <p>
     当某个请求到达
     <code>
      doDispatch
     </code>
     时，首先会检查其是否为
     <code>
      文件格式
     </code>
     ：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/23fb970df33948beae5d569cf91b2d66.png">
      假设我在controller层中进行文件上传的请求处理：
     </img>
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">TestService</span> testService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token string">"/test"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span> <span class="token class-name">MultipartFile</span> file<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     同时需要在
     <code>
      web.xml
     </code>
     中配置：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bbe0ea5255214a20a62726b3038f7a14.png">
      还需要在
      <code>
       web.xml
      </code>
      所引用的
      <code>
       spring.xml
      </code>
      中进行配置：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f8fd26b0d7b449ebb345b5dde493a29a.png">
       这样在进入
       <code>
        checkMultipart
       </code>
       方法时，首先会利用
       <code>
        multipartResolver
       </code>
       校验该请求的类型是否为文件上传：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2f4c58cf4c6e46eba020d2e323b4d2fd.png">
        调用的是
        <code>
         StandardServletMultipartResolver
        </code>
        的
        <code>
         isMultipart
        </code>
        ，在该方法中，首先会获取请求头中的 Content-Type，如果用户在表单中使用
        <code>
         &lt;form enctype="multipart/form-data"&gt;
        </code>
        ，那么 Content-Type 就是：multipart/form-data;然后会忽略大小写判断 Content-Type 是否以 multipart/form-data 开头。
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/681f8ee6e44d4464b08179ab5fe46158.png">
         如果满足条件，则会进入
         <code>
          multipartResolver
         </code>
         的
         <code>
          resolveMultipart
         </code>
         方法进行解析：
         <br/>
         <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/45acd88d2dde44beaa9a92c17ef67577.png">
          调用的同样是
          <code>
           StandardServletMultipartResolver
          </code>
          的
          <code>
           resolveMultipart
          </code>
          ，关键代码，区分普通的form-data和文件类型的form-data:
         </img>
        </img>
       </img>
      </img>
     </img>
    </p>
    <ul>
     <li>
      普通的form-data存入
      <code>
       multipartParameterNames
      </code>
      集合中。
     </li>
     <li>
      文件类型的form-data存入
      <code>
       multipartFiles
      </code>
      集合中。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9234ed57818e4c188ced2da618933658.png">
       如果是文件请求，最后会封装成
       <code>
        MultipartHttpServletRequest
       </code>
       的对象，返回到方法的调用处：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6408ec24fe8c4c9d855456c1f100cf21.png"/>
       这时拿到的
       <code>
        processedRequest
       </code>
       的类型是
       <code>
        MultipartHttpServletRequest
       </code>
       ，和最初记录的
       <code>
        request
       </code>
       类型不一致，故
       <strong>
        multipartRequestParsed
       </strong>
       的值是true，
       <strong>
        标记本次请求为上传文件
       </strong>
       （反之为false）
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/975ea792b9fb410eb02308ab6a359679.png"/>
      </img>
     </li>
    </ul>
    <h3>
     <a id="12Handler_62">
     </a>
     1.2、得到Handler
    </h3>
    <p>
     继续向下执行，到
     <code>
      DispatcherServlet
     </code>
     的
     <code>
      getHandler
     </code>
     ，该方法的目的是：根据当前请求 URI，找到对应的 Handler（Controller 方法或对象），并包装为 HandlerExecutionChain（包含拦截器链）。
     <br/>
     首先会遍历
     <code>
      DispatcherServlet.properties
     </code>
     中的三个默认
     <code>
      HandlerMapping
     </code>
     ：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3d3f0c3daf4148cda09924f4281bd234.png"/>
     再去调用各自的
     <code>
      getHandler
     </code>
     方法，目前案例中是
     <code>
      @Controller注解
     </code>
     的模式，所以利用的是
     <code>
      RequestMappingHandlerMapping
     </code>
     ，其中的关键代码，利用请求路径，
     <strong>
      去容器启动过程中收集的集合中找有无匹配的
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e537c4c2b8b24f6aa72932a26897e523.png"/>
     <code>
      lookupHandlerMethod
     </code>
     ，会去
     <strong>
      pathLookup
     </strong>
     集合中找，
     <strong>
      pathLookup：key存放了请求路径，value存放了注解的信息。
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3b3d662c83dd4a4ebb2ee8251aaa0011.png"/>
     最终找到对应的方法对象并返回：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0fce5d7b3af24d89ba6299729c0275e5.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d88d76c58b0d4fa08b39fd875f90ebf2.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/605eb01c6105409fa3187efb648c5d8e.png"/>
     如果找不到匹配的，会在该方法中直接返回给浏览器404：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8b313a165a00467d9ebcba302fec80b8.png"/>
     <code>
      getHandler
     </code>
     方法的整体逻辑，除了上图中的根据路径找Handler，还有组装拦截器和跨域请求的逻辑：
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">HandlerExecutionChain</span> <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 调用子类实现的 getHandlerInternal 方法，根据当前请求查找对应的 Handler（Controller 或 HandlerAdapter）</span>
    <span class="token class-name">Object</span> handler <span class="token operator">=</span> <span class="token function">getHandlerInternal</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果没有找到对应的 Handler，则尝试获取默认 Handler（可在配置中设置）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        handler <span class="token operator">=</span> <span class="token function">getDefaultHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果仍然没有找到任何 Handler（也没有默认 Handler），则返回 null，DispatcherServlet 会响应 404</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果 handler 是一个字符串（通常表示 Bean 名），通过 Spring 容器获取对应的 Bean 实例</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> handlerName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> handler<span class="token punctuation">;</span>
        handler <span class="token operator">=</span> <span class="token function">obtainApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>handlerName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 确保 request 中缓存了 lookupPath（URI 去除 contextPath 的路径），供拦截器或后续处理使用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">ServletRequestPathUtils</span><span class="token punctuation">.</span><span class="token function">hasCachedPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">initLookupPath</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 构建 HandlerExecutionChain，它包含了 handler 及所有匹配的 HandlerInterceptor 拦截器链</span>
    <span class="token class-name">HandlerExecutionChain</span> executionChain <span class="token operator">=</span> <span class="token function">getHandlerExecutionChain</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Mapped to "</span> <span class="token operator">+</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">DispatcherType</span><span class="token punctuation">.</span><span class="token constant">ASYNC</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getDispatcherType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Mapped to "</span> <span class="token operator">+</span> executionChain<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断是否 handler 提供了 CORS 配置，或者当前请求是 CORS 的预检请求（OPTIONS 请求）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasCorsConfigurationSource</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">CorsUtils</span><span class="token punctuation">.</span><span class="token function">isPreFlightRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取当前 handler 的 CORS 配置对象</span>
        <span class="token class-name">CorsConfiguration</span> config <span class="token operator">=</span> <span class="token function">getCorsConfiguration</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果配置了全局 CorsConfigurationSource，则合并全局 CORS 配置与当前配置</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">CorsConfiguration</span> globalConfig <span class="token operator">=</span> <span class="token function">getCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCorsConfiguration</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
            config <span class="token operator">=</span> <span class="token punctuation">(</span>globalConfig <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> globalConfig<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token operator">:</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果存在 CORS 配置，则进行配置合法性校验（如 allowCredentials 是否兼容 allowOrigins）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>config <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            config<span class="token punctuation">.</span><span class="token function">validateAllowCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将 CORS 拦截器添加到 HandlerExecutionChain 中，形成新的执行链</span>
        executionChain <span class="token operator">=</span> <span class="token function">getCorsHandlerExecutionChain</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> executionChain<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回最终构建的 HandlerExecutionChain，包含 handler 和对应拦截器链，供 DispatcherServlet 后续调用</span>
    <span class="token keyword">return</span> executionChain<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <h3>
     <a id="13Handler_134">
     </a>
     1.3、Handler适配
    </h3>
    <p>
     在拿到请求路径相对应的Handler后，就会进入
     <code>
      getHandlerAdapter
     </code>
     方法进行适配，同样是拿到
     <code>
      DispatcherServlet.properties
     </code>
     中的四个默认
     <code>
      HandlerAdapter
     </code>
     ：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d0815e28cd9644fdb6a3ce9d6e9702c8.png"/>
     与案例中适配的应该是
     <code>
      RequestMappingHandlerAdapter
     </code>
     :
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/51c4845ea09e4756bba874f6a4093fea.png"/>
     这一块的代码和Spring AOP的切面适配一样，都是
     <strong>
      适配器模式
     </strong>
     的体现。
    </p>
    <h3>
     <a id="14preHandle_140">
     </a>
     1.4、执行拦截器preHandle方法
    </h3>
    <p>
     在拿到Handler对应的适配器之后，就会去执行自定义拦截器的preHandle方法（如果有的话），preHandle方法条件不匹配，就直接结束，不会调用目标方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0e5a89abc1e84129b608cf39a4fe71d3.png"/>
     注意如果有多个拦截器，
     <strong>
      preHandle的顺序是从前往后执行
     </strong>
     。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bc97edd9fea749c1a2ea35d6dcbf94cb.png"/>
     并且不满足preHandle定义的条件，还会去执行自定义拦截器链中重写的
     <code>
      AfterCompletion
     </code>
     方法**（顺序是从后往前执行）**。
     <strong>
      并且在执行的过程中抛出了异常，只会记录日志。
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b2d8a656b93041f5b87b2372bb36b85c.png"/>
    </p>
    <h3>
     <a id="15_146">
     </a>
     1.5、执行目标方法
    </h3>
    <p>
     如果拦截器链的preHandle方法条件满足，或者没有自定义拦截器，则会使用1.3中找到的适配器，调用其中的
     <code>
      handle
     </code>
     ，执行目标方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/825e4d57c20f46e9a8835a33eb1eca22.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/82ee4d66de654b2c991430cf5e0cd42b.png"/>
     首先会初始化一个
     <code>
      ModelAndView
     </code>
     ，然后进入关键代码
     <code>
      invokeHandlerMethod
     </code>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ba82275c1c024d4d877a8ef5bc8ca075.png"/>
     执行目标方法的是在
     <code>
      invokeHandlerMethod
     </code>
     的
     <code>
      invokeAndHandle
     </code>
     :
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f121cedf034345a9b3accda29d467526.png"/>
     <code>
      invokeAndHandle
     </code>
     :
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/67083a3aeef04ebeaa2d37f7e4a20926.png"/>
     <code>
      invokeAndHandle
     </code>
     的
     <code>
      invokeForRequest
     </code>
     ：先获取请求参数，然后
     <strong>
      通过反射
     </strong>
     调用目标方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/735cb65c43984a7eb0e0747464f394ce.png"/>
     最后回到
     <code>
      invokeAndHandle
     </code>
     ，设置返回状态码，并且使用返回值处理器对返回值进行处理：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/850465fb0b984d4380b3fc2785a957ed.png"/>
    </p>
    <h3>
     <a id="16PostHandle_155">
     </a>
     1.6、执行拦截器PostHandle方法
    </h3>
    <p>
     在执行完目标方法之后，会执行自定义拦截器重写的PostHandle方法**（从后往前执行）**
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e9905d6e165046e7bd7bf5c3c2a04897.png"/>
    </p>
    <h3>
     <a id="17_160">
     </a>
     1.7、处理异常&amp;渲染视图
    </h3>
    <p>
     如果在上述的执行过程中出现了异常，会被捕获，并且在
     <code>
      processDispatchResult
     </code>
     方法中统一处理，该方法还会进行视图的渲染：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/61e1c27ee9c04ff29829d051cfc60de5.png"/>
     <code>
      processDispatchResult
     </code>
     方法的整体逻辑：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// DispatcherServlet 中用于处理处理器执行结果的方法（无论是正常返回 ModelAndView 还是发生异常）</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processDispatchResult</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span>
        <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">HandlerExecutionChain</span> mappedHandler<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ModelAndView</span> mv<span class="token punctuation">,</span>
        <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 标记是否进入了异常处理视图（比如跳转到 error.jsp 等）</span>
    <span class="token keyword">boolean</span> errorView <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果 Controller 执行过程中发生了异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>exception <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果是特殊的 ModelAndViewDefiningException，说明异常中直接包含了一个要跳转的视图</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>exception <span class="token keyword">instanceof</span> <span class="token class-name">ModelAndViewDefiningException</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"ModelAndViewDefiningException encountered"</span><span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>
            mv <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ModelAndViewDefiningException</span><span class="token punctuation">)</span> exception<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从异常中取出 ModelAndView</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 否则进入标准异常处理流程，由异常解析器（HandlerExceptionResolver）来处理异常，返回 ModelAndView</span>
            <span class="token class-name">Object</span> handler <span class="token operator">=</span> <span class="token punctuation">(</span>mappedHandler <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            mv <span class="token operator">=</span> <span class="token function">processHandlerException</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用异常处理器链</span>
            errorView <span class="token operator">=</span> <span class="token punctuation">(</span>mv <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果异常处理器返回了视图，标记 errorView = true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果最终拿到了一个 ModelAndView 且没有被清空（wasCleared 表示是否显式清除视图渲染流程）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mv <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mv<span class="token punctuation">.</span><span class="token function">wasCleared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">render</span><span class="token punctuation">(</span>mv<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行视图渲染流程（包括视图名解析、模板引擎处理、输出 HTML）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>errorView<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">WebUtils</span><span class="token punctuation">.</span><span class="token function">clearErrorRequestAttributes</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果是错误页面，清除 request 中设置的错误信息</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果 ModelAndView 是 null 或者已被清除，说明 controller 自行处理了 response，不需要视图渲染</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"No view rendering, null ModelAndView returned."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果当前请求是异步处理（比如 @Async 或 DeferredResult 等），则跳过后续操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">WebAsyncUtils</span><span class="token punctuation">.</span><span class="token function">getAsyncManager</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isConcurrentHandlingStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 在 forward 场景下开启异步处理了，直接 return，不做后续 cleanup</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果存在 handler，则触发 afterCompletion 回调（对应 HandlerInterceptor 的 afterCompletion 方法）</span>
    <span class="token comment">// 这是请求生命周期的最后一步，无论是否异常都要执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mappedHandler <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里不传异常，表示异常已经处理过（前面已经调用过 processHandlerException）</span>
        mappedHandler<span class="token punctuation">.</span><span class="token function">triggerAfterCompletion</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <hr/>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373539393037362f:61727469636c652f64657461696c732f313436323133323830" class_="artid" style="display:none">
 </p>
</div>


