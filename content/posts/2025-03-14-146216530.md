---
layout: post
title: "Python-数据模型"
date: 2025-03-14 00:00:00 +0800
description: "Python :数据模型"
keywords: "Python :数据模型"
categories: ['Python']
tags: ['开发语言', 'Python']
artid: "146216530"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216530
    alt: "Python-数据模型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216530
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216530
cover: https://bing.ee123.net/img/rand?artid=146216530
image: https://bing.ee123.net/img/rand?artid=146216530
img: https://bing.ee123.net/img/rand?artid=146216530
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python :数据模型
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <strong>
      一. 什么是数据模型？
     </strong>
    </h2>
    <p>
     Python数据模型是Python对象系统的抽象，通过一组
     <strong>
      特殊方法
     </strong>
     ​（如
     <code>
      __init__
     </code>
     、
     <code>
      __len__
     </code>
     等）和
     <strong>
      协议
     </strong>
     ​（如迭代协议、上下文管理协议），定义了对象如何与语言的内置功能（如
     <code>
      len()
     </code>
     、
     <code>
      for
     </code>
     循环等）交互。
    </p>
    <h4 style="background-color:transparent">
     ​
     <strong>
      核心思想
     </strong>
    </h4>
    <ul>
     <li>
      ​
      <strong>
       统一性
      </strong>
      ：所有对象（如列表、字典、自定义类）的行为都通过相同的特殊方法实现。
     </li>
     <li>
      ​
      <strong>
       灵活性
      </strong>
      ：通过实现特殊方法，可以让自定义对象支持内置操作（如
      <code>
       +
      </code>
      、
      <code>
       in
      </code>
      、切片等）。
     </li>
    </ul>
    <h4 style="background-color:transparent">
     例子
    </h4>
    <pre><code class="language-python">import collections
Card = collections.namedtuple('Card', ['rank', 'suit'])
class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()
    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
        for rank in self.ranks]
    def __len__(self):
        return len(self._cards)
    def __getitem__(self, position):
        return self._cards[position]</code></pre>
    <blockquote>
     <h5>
      解释
     </h5>
     <ol>
      <li>
       <p>
        <strong>
         模块导入
        </strong>
        ：
       </p>
       <p>
        <code>
         import collections
        </code>
       </p>
       <p>
        导入了 Python 标准库中的
        <code>
         collections
        </code>
        模块。
       </p>
      </li>
      <li>
       <p>
        <strong>
         命名元组定义：
         <code>
          Card
         </code>
        </strong>
        ：
       </p>
       <p>
        <code>
         Card = collections.namedtuple('Card', ['rank', 'suit'])
        </code>
       </p>
       <p>
        使用
        <code>
         namedtuple
        </code>
        创建了一个名为
        <code>
         Card
        </code>
        的简单类，表示扑克牌的一张牌。每个
        <code>
         Card
        </code>
        对象有两个属性：
       </p>
       <ul>
        <li>
         <code>
          rank
         </code>
         ：表示牌的点数（如
         <code>
          '2'
         </code>
         ,
         <code>
          'J'
         </code>
         ,
         <code>
          'A'
         </code>
         等）。
        </li>
        <li>
         <code>
          suit
         </code>
         ：表示牌的花色（如
         <code>
          'spades'
         </code>
         ,
         <code>
          'diamonds'
         </code>
         等）。
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         类定义：
         <code>
          FrenchDeck
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         定义了一个名为
         <code>
          FrenchDeck
         </code>
         的类，表示一副标准的 52 张扑克牌。
        </li>
        <li>
         类属性：
         <p>
          <code>
           ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split()
          </code>
         </p>
         <ul>
          <li>
           <code>
            ranks
           </code>
           ：表示牌的所有点数，包括数字牌（
           <code>
            '2'
           </code>
           到
           <code>
            '10'
           </code>
           ）和字母牌（
           <code>
            'J'
           </code>
           ,
           <code>
            'Q'
           </code>
           ,
           <code>
            'K'
           </code>
           ,
           <code>
            'A'
           </code>
           ）。
          </li>
          <li>
           <code>
            suits
           </code>
           ：表示牌的所有花色（
           <code>
            'spades'
           </code>
           黑桃、
           <code>
            'diamonds'
           </code>
           方片、
           <code>
            'clubs'
           </code>
           梅花、
           <code>
            'hearts'
           </code>
           红心）。
          </li>
         </ul>
        </li>
        <li>
         构造函数
         <code>
          __init__
         </code>
         ：
         <p>
          <code>
           def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]
          </code>
         </p>
         初始化时创建了一副完整的扑克牌，存储在
         <code>
          _cards
         </code>
         列表中。通过列表推导式生成所有可能的牌组合。
        </li>
        <li>
         方法
         <code>
          __len__
         </code>
         ：
         <p>
          <code>
           def __len__(self): return len(self._cards)
          </code>
         </p>
         实现了特殊方法
         <code>
          __len__
         </code>
         ，使得可以通过
         <code>
          len(deck)
         </code>
         获取扑克牌的数量。
        </li>
        <li>
         方法
         <code>
          __getitem__
         </code>
         ：
         <p>
          <code>
           def __getitem__(self, position): return self._cards[position]
          </code>
         </p>
         实现了特殊方法
         <code>
          __getitem__
         </code>
         ，使得可以通过索引访问扑克牌，例如
         <code>
          deck[0]
         </code>
         。
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h4>
     <strong>
      常用特殊方法
     </strong>
     ：
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        对应操作
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         __init__
        </code>
       </td>
       <td>
        对象初始化
       </td>
      </tr>
      <tr>
       <td>
        <code>
         __repr__
        </code>
        /
        <code>
         __str__
        </code>
       </td>
       <td>
        字符串表示
       </td>
      </tr>
      <tr>
       <td>
        <code>
         __len__
        </code>
       </td>
       <td>
        <code>
         len(obj)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         __getitem__
        </code>
       </td>
       <td>
        <code>
         obj[key]
        </code>
        （支持索引和切片）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         __iter__
        </code>
       </td>
       <td>
        <code>
         for x in obj
        </code>
        （迭代）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         __enter__
        </code>
        /
        <code>
         __exit__
        </code>
       </td>
       <td>
        <code>
         with
        </code>
        语句（上下文管理）
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <strong>
      迭代协议
     </strong>
    </h4>
    <p>
     实现
     <code>
      __iter__
     </code>
     和
     <code>
      __next__
     </code>
     方法，让对象支持
     <code>
      for
     </code>
     循环：
    </p>
    <pre><code class="language-python">class CountDown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current &lt;= 0:
            raise StopIteration
        else:
            self.current -= 1
            return self.current + 1

for num in CountDown(3):
    print(num)  # 输出: 3 2 1</code></pre>
    <blockquote>
     <p>
     </p>
     <h5>
      解释
     </h5>
     <ol>
      <li>
       <p>
        <strong>
         类定义：
         <code>
          CountDown
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          定义了一个名为
          <code>
           CountDown
          </code>
          的类，用于实现倒计时功能。
         </p>
        </li>
        <li>
         <p>
          构造函数
          <code>
           __init__
          </code>
          ：
         </p>
         <p>
          <code>
           def __init__(self, start): self.current = start
          </code>
         </p>
         <p>
          初始化时接收一个参数
          <code>
           start
          </code>
          ，表示倒计时的起始值，并将其赋值给实例属性
          <code>
           self.current
          </code>
          。
         </p>
        </li>
        <li>
         <p>
          方法
          <code>
           __iter__
          </code>
          ：
         </p>
         <p>
          <code>
           def __iter__(self): return self
          </code>
         </p>
         <p>
          实现了可迭代协议，使得该类的实例可以作为迭代器使用。返回自身（
          <code>
           self
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          方法
          <code>
           __next__
          </code>
          ：
         </p>
         <p>
          <code>
           def __next__(self): if self.current &lt;= 0: raise StopIteration else: self.current -= 1 return self.current + 1
          </code>
         </p>
         <p>
          实现了迭代器协议中的
          <code>
           __next__
          </code>
          方法：
         </p>
         <ul>
          <li>
           如果当前值
           <code>
            self.current
           </code>
           小于或等于 0，则抛出
           <code>
            StopIteration
           </code>
           异常，表示迭代结束。
          </li>
          <li>
           否则，将
           <code>
            self.current
           </code>
           减 1，并返回减 1 前的值（即当前值）。
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         使用场景
        </strong>
        ：
       </p>
       <ul>
        <li>
         该类可以通过
         <code>
          for
         </code>
         循环或手动调用
         <code>
          next()
         </code>
         方法进行倒计时。
        </li>
        <li>
         示例：
         <pre><code class="language-python">countdown = CountDown(5)
for value in countdown:
    print(value)</code></pre>
         输出结果：
         <p>
          <code>
           5 4 3 2 1
          </code>
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h4>
     <strong>
      上下文管理协议
     </strong>
    </h4>
    <p>
     实现
     <code>
      __enter__
     </code>
     和
     <code>
      __exit__
     </code>
     方法，支持
     <code>
      with
     </code>
     语句：
    </p>
    <pre><code class="language-python">class Timer:
    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = time.time()
        print(f"耗时: {self.end - self.start:.2f}秒")

with Timer():
    time.sleep(1)  # 输出: 耗时: 1.00秒</code></pre>
    <blockquote>
     <h5 style="background-color:transparent">
      解释
     </h5>
     <ol>
      <li>
       <p>
        <strong>
         类定义：
         <code>
          Timer
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          定义了一个名为
          <code>
           Timer
          </code>
          的类，用于测量代码块的执行时间。
         </p>
        </li>
        <li>
         <p>
          方法
          <code>
           __enter__
          </code>
          ：
         </p>
         <p>
          <code>
           def __enter__(self): self.start = time.time() return self
          </code>
         </p>
         <ul>
          <li>
           实现了上下文管理协议中的
           <code>
            __enter__
           </code>
           方法。
          </li>
          <li>
           在进入
           <code>
            with
           </code>
           语句块时，记录当前时间（以秒为单位）并存储在实例属性
           <code>
            self.start
           </code>
           中。
          </li>
          <li>
           返回自身（
           <code>
            self
           </code>
           ），以便在
           <code>
            with
           </code>
           语句块中可以访问该对象。
          </li>
         </ul>
        </li>
        <li>
         <p>
          方法
          <code>
           __exit__
          </code>
          ：
         </p>
         <p>
          <code>
           def __exit__(self, exc_type, exc_val, exc_tb): self.end = time.time() print(f"耗时: {self.end - self.start:.2f}秒")
          </code>
         </p>
         <ul>
          <li>
           实现了上下文管理协议中的
           <code>
            __exit__
           </code>
           方法。
          </li>
          <li>
           在退出
           <code>
            with
           </code>
           语句块时，记录当前时间（以秒为单位）并存储在实例属性
           <code>
            self.end
           </code>
           中。
          </li>
          <li>
           计算执行时间（
           <code>
            self.end - self.start
           </code>
           ），并以两位小数的格式打印到控制台。
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         使用场景
        </strong>
        ：
       </p>
       <ul>
        <li>
         通过
         <code>
          with
         </code>
         语句使用
         <code>
          Timer
         </code>
         类来测量代码块的执行时间。
        </li>
        <li>
         示例：
         <p>
          <code>
           with Timer(): time.sleep(1) # 输出: 耗时: 1.00秒
          </code>
         </p>
         <ul>
          <li>
           在
           <code>
            with
           </code>
           语句块中调用了
           <code>
            time.sleep(1)
           </code>
           ，模拟了一个耗时 1 秒的操作。
          </li>
          <li>
           <code>
            Timer
           </code>
           类会自动计算并打印出这段代码的执行时间。
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h4>
     <strong>
      让自定义类支持切片
     </strong>
    </h4>
    <pre><code class="language-python">class MySequence:
    def __init__(self, data):
        self.data = data

    def __len__(self):
        return len(self.data)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return self.data[index.start : index.stop : index.step]
        else:
            return self.data[index]

seq = MySequence([0, 1, 2, 3, 4])
print(seq[1:3])  # [1, 2]（支持切片！）</code></pre>
    <h4>
     <strong>
      鸭子类型（Duck Typing）​
     </strong>
    </h4>
    <p>
     Python不检查对象的类型，而是检查对象是否实现了特定的方法（即是否“像鸭子一样叫”）。
    </p>
    <h5>
     ​
     <strong>
      示例
     </strong>
     ：
    </h5>
    <pre><code class="language-python">class FakeList:
    def __len__(self):
        return 10

    def __getitem__(self, index):
        return index * 2

fake = FakeList()
print(len(fake))       # 10（调用__len__）
print(fake[5])         # 10（调用__getitem__）
print(isinstance(fake, list))  # False，但行为类似列表！</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323733373438362f:61727469636c652f64657461696c732f313436323136353330" class_="artid" style="display:none">
 </p>
</div>


