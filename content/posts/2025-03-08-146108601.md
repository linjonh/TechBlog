---
layout: post
title: "十三Golang-通道"
date: 2025-03-08 00:20:23 +0800
description: "通道就是 golang 中实现 Goroutine 之间通信的机制。它是一种类型化的通道，允许多个 Goroutine 之间安全地传递数据。通道是 Golang 并发模型的核心，它解决了传统并发编程中共享内存带来的复杂性和风险。"
keywords: "【十三】Golang 通道"
categories: ['Golang']
tags: ['开发语言', '后端', 'Golang']
artid: "146108601"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146108601
    alt: "十三Golang-通道"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146108601
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146108601
cover: https://bing.ee123.net/img/rand?artid=146108601
image: https://bing.ee123.net/img/rand?artid=146108601
img: https://bing.ee123.net/img/rand?artid=146108601
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【十三】Golang 通道
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      💢欢迎来到张胤尘的开源技术站
      <br/>
      💥开源如江河，汇聚众志成。代码似星辰，照亮行征程。开源精神长，传承永不忘。携手共前行，未来更辉煌💥
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_5">
     </a>
     通道
    </h2>
    <p>
     在传统的并发编程中，多个线程或进程之间通常通过共享内存来通信。这种模型虽然高效，但容易引发
     <strong>
      竞争条件
     </strong>
     和
     <strong>
      死锁
     </strong>
     等问题。为了避免这些问题，程序员在开发时需要使用复杂的同步机制（例如：锁、信号量等）来保护共享数据。但是
     <code>
      golang
     </code>
     采用了不同的思路：
     <strong>
      避免共享内存，通过通信来实现并发
     </strong>
     。
    </p>
    <p>
     示意图所下所示：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/62f98800d43642fa8f37dda53731d8d8.png"/>
    </p>
    <p>
     通道就是
     <code>
      golang
     </code>
     中实现
     <code>
      Goroutine
     </code>
     之间通信的机制。它是一种
     <strong>
      类型化的通道
     </strong>
     ，允许多个
     <code>
      Goroutine
     </code>
     之间安全地传递数据。通道是
     <code>
      Golang
     </code>
     并发模型的核心，它解决了传统并发编程中共享内存带来的复杂性和风险。
    </p>
    <blockquote>
     <p>
      本篇文章主要介绍的是通道，有关于协程、并发编程等相关知识点请关注后续文章《
      <code>
       Golang
      </code>
      协程》、《
      <code>
       Golang
      </code>
      并发编程》。
     </p>
    </blockquote>
    <h3>
     <a id="_18">
     </a>
     通道声明
    </h3>
    <p>
     使用
     <code>
      var
     </code>
     关键字声明通道变量。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span>
</code></pre>
    <p>
     声明后，
     <code>
      ch
     </code>
     是一个未初始化的通道，其默认值为
     <code>
      nil
     </code>
     。
    </p>
    <h3>
     <a id="_28">
     </a>
     初始化
    </h3>
    <p>
     使用
     <code>
      make
     </code>
     函数初始化通道，如下所示：
    </p>
    <pre><code class="prism language-go">ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     也可以使用
     <code>
      make
     </code>
     函数创建一个带缓冲区的通道，如下所示：
    </p>
    <pre><code class="prism language-go">ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
</code></pre>
    <h3>
     <a id="_42">
     </a>
     缓冲机制
    </h3>
    <p>
     通道分为
     <strong>
      无缓冲通道
     </strong>
     和
     <strong>
      带缓冲通道
     </strong>
     ，它们在行为和使用场景上有一些关键区别。
    </p>
    <h4>
     <a id="_46">
     </a>
     无缓冲通道
    </h4>
    <p>
     在初始化的小结中，使用
     <code>
      make
     </code>
     函数进行初始化通道，当没有指定通道的容量，或者说通道的容量大小为 0 时，称为无缓冲通道。
    </p>
    <p>
     无缓冲通道在发送数据和接收数据时存在如下的特点：
    </p>
    <ul>
     <li>
      <strong>
       发送操作
      </strong>
      ：发送数据时，发送方会阻塞，直到有接收方准备接收数据。
     </li>
     <li>
      <strong>
       接收操作
      </strong>
      ：接收方会阻塞，直到有发送方发送数据。
     </li>
     <li>
      无缓冲通道的发送和接收操作是
      <strong>
       同步的
      </strong>
      ，必须有发送方和接收方同时准备好，才能完成通信。
     </li>
    </ul>
    <h5>
     <a id="_56">
     </a>
     代码示例
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	unbufferedChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 创建无缓冲通道</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"receiver is waiting..."</span><span class="token punctuation">)</span> <span class="token comment">// receiver is waiting...</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span>	<span class="token comment">// 模拟3秒的准备时间</span>
		data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>unbufferedChan <span class="token comment">// 在这行函数执行之前，发送方处于阻塞状态</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"received:"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	unbufferedChan <span class="token operator">&lt;-</span> <span class="token number">42</span> 	<span class="token comment">// 发送方阻塞，直到接收方准备好</span>
    
    <span class="token function">close</span><span class="token punctuation">(</span>unbufferedChan<span class="token punctuation">)</span>	<span class="token comment">// 关闭通道</span>
	
    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_88">
     </a>
     带缓冲通道
    </h4>
    <p>
     当指定了通道的容量，例如
     <code>
      make(chan int, 10)
     </code>
     ，则称为带缓冲通道。
    </p>
    <p>
     带缓冲通道在发送数据和接收数据时存在如下的特点：
    </p>
    <ul>
     <li>
      <strong>
       发送操作
      </strong>
      ：发送数据时，如果缓冲区未满，数据会被放入缓冲区，发送方不会阻塞；如果缓冲区已满，发送方会阻塞，直到缓冲区有空间。
     </li>
     <li>
      <strong>
       接收操作
      </strong>
      ：接收方从缓冲区中取出数据，如果缓冲区为空，接收方会阻塞，直到有数据可用。
     </li>
     <li>
      带缓冲通道的发送和接收操作是
      <strong>
       异步的
      </strong>
      ，发送方和接收方不需要同时准备好。缓冲区的存在允许数据在发送方和接收方之间暂时存储。
     </li>
    </ul>
    <h5>
     <a id="_98">
     </a>
     代码示例
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	bufferedChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 创建带缓冲通道，容量大小为2</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"receiver is waiting..."</span><span class="token punctuation">)</span>
		<span class="token comment">// for {<!-- --></span>
		<span class="token comment">// 	select {<!-- --></span>
		<span class="token comment">// 	case data, ok := &lt;-bufferedChan:</span>
		<span class="token comment">// 		if ok {<!-- --></span>
		<span class="token comment">// 			fmt.Println("received:", data)</span>
		<span class="token comment">// 		} else {<!-- --></span>
		<span class="token comment">// 			fmt.Println("bufferedChan closed")</span>
		<span class="token comment">// 			return</span>
		<span class="token comment">// 		}</span>
		<span class="token comment">// 	}</span>
		<span class="token comment">// }</span>
		<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// 模拟接收方不从缓冲通道中接收数据</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	bufferedChan <span class="token operator">&lt;-</span> <span class="token number">42</span>
	bufferedChan <span class="token operator">&lt;-</span> <span class="token number">43</span>
	bufferedChan <span class="token operator">&lt;-</span> <span class="token number">44</span> <span class="token comment">// 如果接收方一直未接收数据，则在此处会发送阻塞</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send data over ..."</span><span class="token punctuation">)</span>

	<span class="token function">close</span><span class="token punctuation">(</span>bufferedChan<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>

	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_144">
     </a>
     通道操作
    </h3>
    <h4>
     <a id="_146">
     </a>
     发送数据
    </h4>
    <p>
     使用
     <code>
      &lt;-
     </code>
     操作符将数据发送到通道，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">10</span> <span class="token comment">// 向通道中发送一个 10</span>
    
    <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_161">
     </a>
     接收数据
    </h4>
    <p>
     使用
     <code>
      &lt;-
     </code>
     操作符从通道中读取数据，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">10</span> <span class="token comment">// 向通道中发送一个 10</span>

	data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch      <span class="token comment">// 通道中读取一个数据</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 10</span>

	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_181">
     </a>
     单向通道
    </h4>
    <p>
     <code>
      golang
     </code>
     中提供了单向通道这么一种特殊的通道类型，它只能用于发送或接收数据，而不能同时进行发送和接收操作。单向通道在类型声明上与普通通道（双向通道）有所不同，主要用于限制通道的使用方式，从而提高代码的可读性和安全性。
    </p>
    <p>
     单向通道有如下两种类型：
    </p>
    <ul>
     <li>
      <strong>
       只发送通道
      </strong>
      ：用于发送数据，但不能接收数据。
     </li>
    </ul>
    <pre><code class="prism language-go"><span class="token keyword">chan</span><span class="token operator">&lt;-</span> Type
</code></pre>
    <ul>
     <li>
      <strong>
       只接收通道
      </strong>
      ：用于接收数据，但不能发送数据。
     </li>
    </ul>
    <pre><code class="prism language-go"><span class="token operator">&lt;-</span><span class="token keyword">chan</span> Type
</code></pre>
    <h5>
     <a id="_199">
     </a>
     单向通道的用途
    </h5>
    <p>
     单向通道的主要用途是限制通道的使用范围，避免在函数或方法中滥用通道的发送和接收功能。例如：
    </p>
    <ul>
     <li>
      当一个函数只需要从通道中读取数据时，使用只接收通道可以明确表示该函数的意图。
     </li>
     <li>
      当一个函数只需要向通道中写入数据时，使用只发送通道可以避免意外读取通道中的数据。
     </li>
    </ul>
    <h5>
     <a id="_206">
     </a>
     代码示例
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">producer</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">,</span> wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// ch 参数：一个只发送通道</span>
	<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		ch <span class="token operator">&lt;-</span> i <span class="token comment">// 向通道发送数据</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"sent: %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">consumer</span><span class="token punctuation">(</span>ch <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// ch 参数：一个只接收通道</span>
	<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">case</span> data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>	<span class="token comment">// 读取通道数据</span>
			<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"received: %d\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"chan closed ..."</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个双向通道</span>
	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

	<span class="token comment">// received: 0</span>
	<span class="token comment">// sent: 0</span>
	<span class="token comment">// sent: 1</span>
	<span class="token comment">// received: 1</span>
	<span class="token comment">// received: 2</span>
	<span class="token comment">// sent: 2</span>
	<span class="token comment">// sent: 3</span>
	<span class="token comment">// received: 3</span>
	<span class="token comment">// received: 4</span>
	<span class="token comment">// sent: 4</span>
	<span class="token comment">// chan closed ...</span>

	<span class="token keyword">go</span> <span class="token function">consumer</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wg<span class="token punctuation">)</span> <span class="token comment">// 接收者</span>
	<span class="token keyword">go</span> <span class="token function">producer</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wg<span class="token punctuation">)</span> <span class="token comment">// 发送者</span>

	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre>
    <h4>
     <a id="_266">
     </a>
     多路复用
    </h4>
    <p>
     通道的多路复用机制是一种用于处理多个通道操作的技术，它允许程序同时等待多个通道的读写操作。这种机制的核心是
     <code>
      select...case
     </code>
     语句，它提供了对多个通道操作的并发处理能力。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>
    <span class="token comment">// 处理 ch1 的读操作</span>
<span class="token keyword">case</span> data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
    <span class="token comment">// 处理 ch2 的读操作，并将读取到的数据赋值给 data</span>
<span class="token keyword">case</span> ch3 <span class="token operator">&lt;-</span> value<span class="token punctuation">:</span>
    <span class="token comment">// 向 ch3 中发送值</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token comment">// 如果没有通道准备好，则执行默认逻辑</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     另外需要强调的是，如果多个通道同时准备好，
     <code>
      select...case
     </code>
     会随机选择一个通道执行操作；如果没有任何一个
     <strong>
      通道准备好
     </strong>
     ，则
     <code>
      select
     </code>
     会陷入阻塞，除非有
     <code>
      default
     </code>
     分支执行。
    </p>
    <p>
     需要注意的是，上面提到的
     <strong>
      通道准备好
     </strong>
     是个口语，对于接收操作来说需要满足以下两个条件中的任意一个：
    </p>
    <ul>
     <li>
      <strong>
       通道中有数据可读
      </strong>
      ：如果通道的缓冲区中有数据，或者有发送操作正在等待发送数据到通道中，那么接收操作就准备好。
     </li>
     <li>
      <strong>
       通道已关闭
      </strong>
      ：即使通道中没有数据，如果通道已经被关闭，接收操作也会立即返回零值，并且
      <code>
       ok
      </code>
      为
      <code>
       false
      </code>
      （如果使用了
      <code>
       data, ok := &lt;-ch
      </code>
      的形式）。
     </li>
    </ul>
    <p>
     对发送操作来说也需要满足以下两个条件中的任意一个：
    </p>
    <ul>
     <li>
      <strong>
       通道中有空间可写
      </strong>
      ：如果通道是无缓冲的，并且有等待接收的协程，或者通道是缓冲的且缓冲区中有空闲位置，那么发送操作就准备好。
     </li>
     <li>
      <strong>
       通道已关闭
      </strong>
      ：如果通道已经被关闭，发送操作会触发
      <code>
       panic("send on closed channel")
      </code>
      。
     </li>
    </ul>
    <h5>
     <a id="_295">
     </a>
     代码示例
    </h5>
    <p>
     通过
     <code>
      select
     </code>
     同时处理多个通道，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道 ch1</span>
	ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道 ch2</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 每间隔 1 秒，向通道 ch1 中发送数据，一共发送 10 条数据</span>
		<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			ch1 <span class="token operator">&lt;-</span> <span class="token string">"message from ch1"</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 每间隔 2 秒，向通道 ch2 中发送数据，一共发送 10 条数据</span>
		<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			ch2 <span class="token operator">&lt;-</span> <span class="token string">"message from ch2"</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch1</span>
	<span class="token comment">// no data reception ...</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// ch1 chan closed ...</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// recived:  message from ch2</span>
	<span class="token comment">// ch2 chan closed ...</span>
	<span class="token comment">// both channels closed. exiting...</span>

	ch1_s<span class="token punctuation">,</span> ch2_s <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span>

	<span class="token keyword">for</span> ch1_s <span class="token operator">||</span> ch2_s <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">case</span> data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>
			<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"recived: "</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> ch1_s <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ch1 chan closed ..."</span><span class="token punctuation">)</span>
				ch1_s <span class="token operator">=</span> <span class="token boolean">false</span>
			<span class="token punctuation">}</span>
		<span class="token keyword">case</span> data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
			<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"recived: "</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> ch2_s <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ch2 chan closed ..."</span><span class="token punctuation">)</span>
				ch2_s <span class="token operator">=</span> <span class="token boolean">false</span>
			<span class="token punctuation">}</span>
		<span class="token keyword">default</span><span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"no data reception ..."</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"both channels closed. exiting..."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre>
    <h5>
     <a id="_394">
     </a>
     通道复用器的实现
    </h5>
    <p>
     在某些复杂场景中，可能需要手动实现通道复用器。例如，可以将多个通道的输出合并到一个通道中，从而简化后续的处理逻辑。
    </p>
    <p>
     下面是一个简单的通道复用器实现思路：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">send</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 模拟数据发送，每秒发送一个数字</span>
	<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		ch <span class="token operator">&lt;-</span> i
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">multiplexer</span><span class="token punctuation">(</span>channels <span class="token operator">...</span><span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 合并多个通道数据，函数返回最终的一个只读通道</span>
	out <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span>
		<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ch <span class="token operator">:=</span> <span class="token keyword">range</span> channels <span class="token punctuation">{<!-- --></span>
			wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ch <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">case</span> data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
						<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
							out <span class="token operator">&lt;-</span> data <span class="token comment">// 数据发送到最终的只读通道</span>
						<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
							<span class="token keyword">return</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> out
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道 ch1</span>
	ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道 ch2</span>
	ch3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道 ch3</span>

	<span class="token keyword">go</span> <span class="token function">send</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">send</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">send</span><span class="token punctuation">(</span>ch3<span class="token punctuation">)</span>

	ret_ch <span class="token operator">:=</span> <span class="token function">multiplexer</span><span class="token punctuation">(</span>ch1<span class="token punctuation">,</span> ch2<span class="token punctuation">,</span> ch3<span class="token punctuation">)</span> <span class="token comment">// 接收返回的通道</span>

	<span class="token keyword">for</span> data <span class="token operator">:=</span> <span class="token keyword">range</span> ret_ch <span class="token punctuation">{<!-- --></span> <span class="token comment">// 从只读通道中获取合并后的数据</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"ret received: %d\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ret chan closed ..."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_464">
     </a>
     超时机制
    </h4>
    <p>
     在
     <code>
      golang
     </code>
     中，通道的超时机制可以通过
     <code>
      time.After
     </code>
     或
     <code>
      context
     </code>
     两种方式来实现。
    </p>
    <h5>
     <a id="timeAfter_468">
     </a>
     <code>
      time.After
     </code>
    </h5>
    <p>
     <code>
      time.After
     </code>
     是一个返回通道的函数，会在指定的超时时间后向通道发送一个时间值。结合
     <code>
      select...case
     </code>
     语句，可以实现超时逻辑。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// 模拟耗时操作</span>
		ch <span class="token operator">&lt;-</span> <span class="token string">"任务完成"</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">// 设置超时为2秒</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"超时退出"</span><span class="token punctuation">)</span> <span class="token comment">// 最终打印 超时退出</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      time.After
     </code>
     是一种非常简洁且易于理解的超时机制，特别适合简单的超时场景。
     <strong>
      但是需要注意的是，
      <code>
       time.After
      </code>
      会在后台启动一个定时器，即使
      <code>
       select
      </code>
      提前退出，定时器也不会立刻回收，可能导致轻微的资源泄漏
     </strong>
     。
    </p>
    <h5>
     <a id="context_499">
     </a>
     <code>
      context
     </code>
    </h5>
    <p>
     <code>
      context
     </code>
     是
     <code>
      golang
     </code>
     中用于传递可取消信号、超时时间等的工具。通过
     <code>
      context.WithTimeout
     </code>
     创建一个带有超时功能的上下文，其
     <code>
      Done()
     </code>
     方法返回一个通道，用于超时控制，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 创建通道</span>
	ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// cancel() 会释放与上下文相关的资源，避免内存泄漏</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// 模拟耗时操作</span>
		ch <span class="token operator">&lt;-</span> <span class="token string">"任务完成"</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">// 监听超时信号</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"超时退出"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在上面的这个代码中：
    </p>
    <ul>
     <li>
      <code>
       context.WithTimeout
      </code>
      创建了一个带有超时的上下文，并设置超时时间为 2 秒。
     </li>
     <li>
      <code>
       defer cancel()
      </code>
      确保在函数返回时调用
      <code>
       cancel()
      </code>
      ，释放资源。
     </li>
     <li>
      如果任务在超时前完成，
      <code>
       cancel()
      </code>
      会被调用，终止所有监听
      <code>
       ctx.Done()
      </code>
      的协程。
     </li>
    </ul>
    <p>
     总的来说，
     <code>
      context
     </code>
     更适用于复杂的并发场景，例如多个任务的超时控制、任务取消等；
     <code>
      time.After
     </code>
     更适用于简单的超时控制，例如单个任务的超时。
    </p>
    <h4>
     <a id="_539">
     </a>
     关闭通道
    </h4>
    <p>
     使用
     <code>
      close
     </code>
     函数关闭通道，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     需要注意的是，当关闭通道后，不能再向通道发送数据，但可以继续从通道中接收数据。
    </p>
    <h4>
     <a id="_554">
     </a>
     检查通道是否关闭
    </h4>
    <p>
     接收数据时会有两个返回值，一个是数据另一个是布尔值，用于判断通道是否关闭，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">case</span> data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span> <span class="token comment">// data 表示数据，ok 表示通道是否关闭</span>
				<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
					<span class="token comment">// received: 11</span>
					<span class="token comment">// received: 10</span>
					<span class="token comment">// received: 15</span>
					fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"received:"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ch closed"</span><span class="token punctuation">)</span> <span class="token comment">// ch closed</span>
					<span class="token keyword">return</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	ch <span class="token operator">&lt;-</span> <span class="token number">11</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">10</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">15</span>

	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>
	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_598">
     </a>
     获取通道长度
    </h4>
    <p>
     使用
     <code>
      len
     </code>
     函数获取通道的当前长度，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>

	ch <span class="token operator">&lt;-</span> <span class="token number">10</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>

	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 关闭通道</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="_618">
     </a>
     获取通道容量
    </h4>
    <p>
     使用
     <code>
      cap
     </code>
     函数获取通道的当前容量，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span>

	ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>

	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>  <span class="token comment">// 关闭通道 ch</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span> <span class="token comment">// 关闭通道 ch1</span>
<span class="token punctuation">}</span>

</code></pre>
    <h3>
     <a id="_640">
     </a>
     源码解析
    </h3>
    <p>
     针对通道的源代码进行解析，从以下几个方面：
    </p>
    <ul>
     <li>
      创建通道
     </li>
     <li>
      发送数据
     </li>
     <li>
      接收数据
     </li>
     <li>
      关闭通道
     </li>
    </ul>
    <h4>
     <a id="_649">
     </a>
     通道结构体
    </h4>
    <blockquote>
     <p>
      源码位置：src/runtime/chan.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> hchan <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	qcount   <span class="token builtin">uint</span>           <span class="token comment">// total data in the queue</span>
	dataqsiz <span class="token builtin">uint</span>           <span class="token comment">// size of the circular queue</span>
	buf      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// points to an array of dataqsiz elements</span>
	elemsize <span class="token builtin">uint16</span>
	closed   <span class="token builtin">uint32</span>
	timer    <span class="token operator">*</span>timer <span class="token comment">// timer feeding this chan</span>
	elemtype <span class="token operator">*</span>_type <span class="token comment">// element type</span>
	sendx    <span class="token builtin">uint</span>   <span class="token comment">// send index</span>
	recvx    <span class="token builtin">uint</span>   <span class="token comment">// receive index</span>
	recvq    waitq  <span class="token comment">// list of recv waiters</span>
	sendq    waitq  <span class="token comment">// list of send waiters</span>

	<span class="token comment">// lock protects all fields in hchan, as well as several</span>
	<span class="token comment">// fields in sudogs blocked on this channel.</span>
	<span class="token comment">//</span>
	<span class="token comment">// Do not change another G's status while holding this lock</span>
	<span class="token comment">// (in particular, do not ready a G), as this can deadlock</span>
	<span class="token comment">// with stack shrinking.</span>
	lock mutex
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       qcount
      </code>
      ：当前通道中存储的数据数量，对于无缓冲通道，
      <code>
       qcount
      </code>
      的值通常为 0 或 1。
     </li>
     <li>
      <code>
       dataqsiz
      </code>
      ：对于缓冲通道，
      <code>
       dataqsiz
      </code>
      表示缓冲区可以存储的最大元素数量。对于无缓冲通道，
      <code>
       dataqsiz
      </code>
      为 0。
     </li>
     <li>
      <code>
       buf
      </code>
      ：指向缓冲区的指针。缓冲区是一个数组，用于存储通道中的数据。仅对缓冲通道有效。无缓冲通道的
      <code>
       buf
      </code>
      为
      <code>
       nil
      </code>
      。
     </li>
     <li>
      <code>
       elemsize
      </code>
      ：通道中每个元素的大小（以字节为单位）。
     </li>
     <li>
      <code>
       closed
      </code>
      ：标记通道是否已关闭。关闭的通道不能再次发送数据，但可以继续接收数据直到缓冲区为空。
     </li>
     <li>
      <code>
       timer
      </code>
      ：指向一个定时器，该定时器与通道相关联（例如，用于超时操作）。
     </li>
     <li>
      <code>
       elemtype
      </code>
      ：指向通道中元素的类型信息，用于在运行时检查通道中存储的数据类型是否正确。
     </li>
     <li>
      <code>
       sendx
      </code>
      ：用于管理缓冲区的环形队列，记录下一次发送操作在缓冲区中的索引。
     </li>
     <li>
      <code>
       recvx
      </code>
      ：用于管理缓冲区的环形队列，记录下一次接收操作在缓冲区中的索引。
     </li>
     <li>
      <code>
       recvq
      </code>
      ：存储等待接收的协程队列，在发送操作中，如果缓冲区已满且没有等待接收的协程，则发送协程会被加入到
      <code>
       sendq
      </code>
      。
     </li>
     <li>
      <code>
       sendq
      </code>
      ：存储等待发送的协程队列，在接收操作中，如果缓冲区为空且没有等待发送的协程，则接收协程会被加入到
      <code>
       recvq
      </code>
      。
     </li>
     <li>
      <code>
       lock
      </code>
      ：保护
      <code>
       hchan
      </code>
      结构体中所有字段的互斥锁，确保通道操作的线程安全性。在发送、接收和关闭操作中，
      <code>
       lock
      </code>
      用于防止多个协程同时修改通道的状态。
     </li>
    </ul>
    <h4>
     <a id="_690">
     </a>
     创建通道
    </h4>
    <p>
     在
     <code>
      golang
     </code>
     的运行时中，创建通道的代码会被编译为对
     <code>
      makechan
     </code>
     的调用。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     编译成汇编代码如下所示：
    </p>
    <pre><code class="prism language-assembly">0x001a 00026        CALL    runtime.makechan(SB)
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     <code>
      makechan
     </code>
     函数是运行时中用于创建通道的核心函数。它初始化了一个
     <code>
      hchan
     </code>
     结构体，并根据指定的类型和缓冲区大小分配内存。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/chan.go
     </p>
    </blockquote>
    <h5>
     <a id="_714">
     </a>
     函数原型
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">makechan</span><span class="token punctuation">(</span>t <span class="token operator">*</span>chantype<span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>hchan <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       t *chantype
      </code>
      ：通道的类型信息，包含通道中元素的类型。
     </li>
     <li>
      <code>
       size int
      </code>
      ：通道的缓冲区大小。如果为 0，则创建无缓冲通道；如果大于 0，则创建有缓冲通道。
     </li>
     <li>
      返回一个初始化后的
      <code>
       hchan
      </code>
      结构体指针。
     </li>
    </ul>
    <h5>
     <a id="_726">
     </a>
     函数内容
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">makechan</span><span class="token punctuation">(</span>t <span class="token operator">*</span>chantype<span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>hchan <span class="token punctuation">{<!-- --></span>
	elem <span class="token operator">:=</span> t<span class="token punctuation">.</span>Elem	<span class="token comment">// 从通道类型 t 中获取通道中元素的类型信息</span>

	<span class="token comment">// compiler checks this but be safe.</span>
    <span class="token comment">// 检查通道中元素的大小是否超过 64KB，如果超过，抛出异常</span>
	<span class="token keyword">if</span> elem<span class="token punctuation">.</span>Size_ <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"makechan: invalid channel element type"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 确保 hchan 的大小是最大对齐单位的倍数，并且元素的对齐要求不超过最大对齐单位</span>
    <span class="token comment">// maxAlign = 8</span>
	<span class="token keyword">if</span> hchanSize<span class="token operator">%</span>maxAlign <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> elem<span class="token punctuation">.</span>Align_ <span class="token operator">&gt;</span> maxAlign <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"makechan: bad alignment"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 计算缓冲区的总大小：elem.Size_ * size</span>
	mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span>Size_<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 检查是否发生溢出，或者缓冲区大小超过最大分配限制，或者缓冲区大小小于0，抛出异常</span>
	<span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">&gt;</span> maxAlloc<span class="token operator">-</span>hchanSize <span class="token operator">||</span> size <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"makechan: size out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span>
	<span class="token comment">// buf points into the same allocation, elemtype is persistent.</span>
	<span class="token comment">// SudoG's are referenced from their owning thread so they can't be collected.</span>
	<span class="token comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span>
    <span class="token comment">// 内存分配</span>
	<span class="token keyword">var</span> c <span class="token operator">*</span>hchan
	<span class="token keyword">switch</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token comment">// 如果缓冲区大小为 0（无缓冲通道）或元素大小为 0，仅分配 hchan 的内存</span>
		<span class="token comment">// Queue or element size is zero.</span>
		c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>hchan<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span>hchanSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">// Race detector uses this location for synchronization.</span>
        <span class="token comment">// 初始化通道的缓冲区的指针</span>
        <span class="token comment">// buf 指向 hchan 结构体本身，表示没有独立的缓冲区</span>
		c<span class="token punctuation">.</span>buf <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token operator">!</span>elem<span class="token punctuation">.</span><span class="token function">Pointers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment">// 如果元素类型不包含指针（如基本类型或数组），将 hchan 和缓冲区分配在同一块内存中</span>
		<span class="token comment">// Elements do not contain pointers.</span>
		<span class="token comment">// Allocate hchan and buf in one call.</span>
		c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>hchan<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span>hchanSize<span class="token operator">+</span>mem<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 初始化通道的缓冲区的指针</span>
        <span class="token comment">// 将 c.buf 指向 hchan 结构体之后的内存区域，该区域用于存储缓冲区数据</span>
		c<span class="token punctuation">.</span>buf <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> hchanSize<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token comment">// 如果元素类型包含指针（如结构体或切片），分别分配 hchan 和缓冲区的内存</span>
        <span class="token comment">// 因为 gc 需要跟踪指针类型的内存分配</span>
		<span class="token comment">// Elements contain pointers.</span>
		c <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>hchan<span class="token punctuation">)</span>
        <span class="token comment">// 初始化通道的缓冲区的指针</span>
		c<span class="token punctuation">.</span>buf <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 设置通道的元素大小</span>
	c<span class="token punctuation">.</span>elemsize <span class="token operator">=</span> <span class="token function">uint16</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span>Size_<span class="token punctuation">)</span>
    <span class="token comment">// 设置通道的元素类型</span>
	c<span class="token punctuation">.</span>elemtype <span class="token operator">=</span> elem
    <span class="token comment">// 设置通道的缓冲区大小</span>
	c<span class="token punctuation">.</span>dataqsiz <span class="token operator">=</span> <span class="token function">uint</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>
    <span class="token comment">// 初始化通道的互斥锁</span>
	<span class="token function">lockInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> lockRankHchan<span class="token punctuation">)</span>
	
    <span class="token comment">// 如果启用了通道调试模式，打印调试信息</span>
	<span class="token keyword">if</span> debugChan <span class="token punctuation">{<!-- --></span>
		<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"makechan: chan="</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token string">"; elemsize="</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>Size_<span class="token punctuation">,</span> <span class="token string">"; dataqsiz="</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 返回通道指针</span>
	<span class="token keyword">return</span> c
<span class="token punctuation">}</span>
</code></pre>
    <p>
     具体分配内存
     <code>
      mallocgc
     </code>
     函数原型如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> needzero <span class="token builtin">bool</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       size
      </code>
      ：分配的内存大小。
     </li>
     <li>
      <code>
       typ
      </code>
      ：分配内存的类型信息。
     </li>
     <li>
      <code>
       needzero
      </code>
      ：是否需要将分配的内存清零。
     </li>
    </ul>
    <blockquote>
     <p>
      更多关于
      <code>
       mallocgc
      </code>
      函数的内容本文章不再赘述，感兴趣的同学请关注后续文章《
      <code>
       Golang
      </code>
      内存模型》。
     </p>
    </blockquote>
    <h4>
     <a id="_816">
     </a>
     发送数据
    </h4>
    <p>
     在
     <code>
      golang
     </code>
     的运行时中，发送操作的代码会被编译为对
     <code>
      chansend1
     </code>
     的调用。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     编译成汇编代码如下所示：
    </p>
    <pre><code class="prism language-assembly">0x001a 00026        CALL    runtime.makechan(SB)
# ...
0x0026 00038        CALL    runtime.chansend1(SB)
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     而在
     <code>
      chansend1
     </code>
     的函数内部，又是对
     <code>
      chansend
     </code>
     的调用，如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/chan.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// entry point for c &lt;- x from compiled code.</span>
<span class="token comment">//</span>
<span class="token comment">//go:nosplit</span>
<span class="token keyword">func</span> <span class="token function">chansend1</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">chansend</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_852">
     </a>
     函数原型
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">chansend</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> block <span class="token builtin">bool</span><span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       c *hchan
      </code>
      ：指向通道的指针。
     </li>
     <li>
      <code>
       ep unsafe.Pointer
      </code>
      ：指向数据的指针。
     </li>
     <li>
      <code>
       block bool
      </code>
      ：是否阻塞发送。
      <ul>
       <li>
        如果
        <code>
         block == true
        </code>
        ，发送操作会在通道缓冲区满或没有接收方时阻塞，直到可以发送数据。
       </li>
       <li>
        如果
        <code>
         block == false
        </code>
        ，发送操作是非阻塞的。如果当前无法发送数据（缓冲区满或没有接收方），函数会立即返回
        <code>
         false
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <code>
       callerpc uintptr
      </code>
      ：程序计数器（PC）的值，主要用于调试和竞态检测。
     </li>
     <li>
      发送操作是否成功。
     </li>
    </ul>
    <h5>
     <a id="_868">
     </a>
     函数内容
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">chansend</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> block <span class="token builtin">bool</span><span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 检查通道指针 c 是否为 nil</span>
	<span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token operator">!</span>block <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果通道为 nil 且是非阻塞发送，直接返回 false</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果是阻塞发送，则协程会阻塞并抛出异常</span>
		<span class="token function">gopark</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonChanSendNilChan<span class="token punctuation">,</span> traceBlockForever<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"unreachable"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 如果启用了通道调试模式，打印调试信息</span>
	<span class="token keyword">if</span> debugChan <span class="token punctuation">{<!-- --></span>
		<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"chansend: chan="</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果启用了竞态检测器，记录对通道的读操作</span>
	<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
		<span class="token function">racereadpc</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> callerpc<span class="token punctuation">,</span> abi<span class="token punctuation">.</span><span class="token function">FuncPCABIInternal</span><span class="token punctuation">(</span>chansend<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span>
	<span class="token comment">//</span>
	<span class="token comment">// After observing that the channel is not closed, we observe that the channel is</span>
	<span class="token comment">// not ready for sending. Each of these observations is a single word-sized read</span>
	<span class="token comment">// (first c.closed and second full()).</span>
	<span class="token comment">// Because a closed channel cannot transition from 'ready for sending' to</span>
	<span class="token comment">// 'not ready for sending', even if the channel is closed between the two observations,</span>
	<span class="token comment">// they imply a moment between the two when the channel was both not yet closed</span>
	<span class="token comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span>
	<span class="token comment">// and report that the send cannot proceed.</span>
	<span class="token comment">//</span>
	<span class="token comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span>
	<span class="token comment">// ready for sending and then observe that it is not closed, that implies that the</span>
	<span class="token comment">// channel wasn't closed during the first observation. However, nothing here</span>
	<span class="token comment">// guarantees forward progress. We rely on the side effects of lock release in</span>
	<span class="token comment">// chanrecv() and closechan() to update this thread's view of c.closed and full().</span>
    
    <span class="token comment">// 如果是非阻塞发送并且通道未关闭但缓冲区已满，直接返回 false</span>
    <span class="token comment">// 前置判断，避免进入锁的开销</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>block <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>closed <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">full</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果启用了阻塞剖析，记录当前时间戳</span>
	<span class="token keyword">var</span> t0 <span class="token builtin">int64</span>
	<span class="token keyword">if</span> blockprofilerate <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		t0 <span class="token operator">=</span> <span class="token function">cputicks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 锁定通道的互斥锁，确保操作的原子性</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	
    <span class="token comment">// 如果通道已关闭，解锁并抛出异常</span>
    <span class="token comment">// 阅读到此处时，考虑是否改为使用原子操作，代替 lock/unlock？</span>
    <span class="token comment">// 可？不可？</span>
    <span class="token comment">// 记录吧！！！</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>closed <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"send on closed channel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果有等待接收的协程，直接将数据发送给接收协程，跳过缓冲区</span>
	<span class="token keyword">if</span> sg <span class="token operator">:=</span> c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> sg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Found a waiting receiver. We pass the value we want to send</span>
		<span class="token comment">// directly to the receiver, bypassing the channel buffer (if any).</span>
        <span class="token comment">// 调用 send 函数完成数据传递，并解锁</span>
		<span class="token function">send</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> ep<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 如果没有等待接收的协程，则判断缓冲区是否有空间</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>qcount <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Space is available in the channel buffer. Enqueue the element to send.</span>
        <span class="token comment">// 计算缓冲区中下一个写入位置的指针</span>
		qp <span class="token operator">:=</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>sendx<span class="token punctuation">)</span>
		<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 通知竞态检测器当前操作的上下文信息，对缓冲区的写入操作被正确跟踪</span>
			<span class="token function">racenotify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>sendx<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">// 将要发送的数据从 ep 复制到缓冲区的 qp 位置</span>
		<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> qp<span class="token punctuation">,</span> ep<span class="token punctuation">)</span>
        <span class="token comment">// 更新发送索引为下一个写入位置</span>
		c<span class="token punctuation">.</span>sendx<span class="token operator">++</span>
        <span class="token comment">// 如果 c.sendx 达到缓冲区大小，则将其重置为 0，实现环形缓冲区的效果</span>
		<span class="token keyword">if</span> c<span class="token punctuation">.</span>sendx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">.</span>sendx <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 每次成功写入数据后，c.qcount 增加 1</span>
		c<span class="token punctuation">.</span>qcount<span class="token operator">++</span>
        <span class="token comment">// 解锁通道的互斥锁</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
        <span class="token comment">// 写入成功，返回 true</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果缓冲区已满且是非阻塞发送，解锁并返回 false</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>block <span class="token punctuation">{<!-- --></span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 下面是阻塞发送的代码逻辑</span>

	<span class="token comment">// Block on the channel. Some receiver will complete our operation for us.</span>
    <span class="token comment">// 获取当前正在运行的协程的指针</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 分配一个 sudog 对象，sudog 是 golang 运行时中用于表示协程在通道操作中等待的结构体</span>
	mysg <span class="token operator">:=</span> <span class="token function">acquireSudog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	mysg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">if</span> t0 <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		mysg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// No stack splits between assigning elem and enqueuing mysg</span>
	<span class="token comment">// on gp.waiting where copystack can find it.</span>
    <span class="token comment">// 下面这些是初始化 sudog 对象属性</span>
	mysg<span class="token punctuation">.</span>elem <span class="token operator">=</span> ep	<span class="token comment">// 指向要发送的数据指针</span>
	mysg<span class="token punctuation">.</span>waitlink <span class="token operator">=</span> <span class="token boolean">nil</span>
	mysg<span class="token punctuation">.</span>g <span class="token operator">=</span> gp	<span class="token comment">// 指向当前协程</span>
	mysg<span class="token punctuation">.</span>isSelect <span class="token operator">=</span> <span class="token boolean">false</span>	<span class="token comment">// 标记是否是 select 操作</span>
	mysg<span class="token punctuation">.</span>c <span class="token operator">=</span> c	<span class="token comment">// 指向当前通道</span>
	gp<span class="token punctuation">.</span>waiting <span class="token operator">=</span> mysg	<span class="token comment">// 将当前协程的 sudog 对象设置为等待状态</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>
    
    <span class="token comment">// 将 sudog 对象加入通道的发送等待队列</span>
	c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>mysg<span class="token punctuation">)</span>
	<span class="token comment">// Signal to anyone trying to shrink our stack that we're about</span>
	<span class="token comment">// to park on a channel. The window between when this G's status</span>
	<span class="token comment">// changes and when we set gp.activeStackChans is not safe for</span>
	<span class="token comment">// stack shrinking.</span>
    <span class="token comment">// 标记当前协程即将阻塞在通道操作</span>
	gp<span class="token punctuation">.</span>parkingOnChan<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token comment">// 阻塞当前协程，直到被接收操作唤醒</span>
	<span class="token function">gopark</span><span class="token punctuation">(</span>chanparkcommit<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span> waitReasonChanSend<span class="token punctuation">,</span> traceBlockChanSend<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token comment">// Ensure the value being sent is kept alive until the</span>
	<span class="token comment">// receiver copies it out. The sudog has a pointer to the</span>
	<span class="token comment">// stack object, but sudogs aren't considered as roots of the</span>
	<span class="token comment">// stack tracer.</span>
    <span class="token comment">// 确保发送的数据在接收协程拷贝之前不会被回收，因为 ep 指向的数据有可能是栈上的数据</span>
    <span class="token comment">// 而栈上的数据可能在协程阻塞后被回收</span>
	<span class="token function">KeepAlive</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span>
    
    <span class="token comment">// 下面是协程被唤醒后的处理代码</span>

	<span class="token comment">// someone woke us up.</span>
	<span class="token keyword">if</span> mysg <span class="token operator">!=</span> gp<span class="token punctuation">.</span>waiting <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"G waiting list is corrupted"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 清空协程的等待状态</span>
	gp<span class="token punctuation">.</span>waiting <span class="token operator">=</span> <span class="token boolean">nil</span>	
    <span class="token comment">// 标记协程不再阻塞在通道操作上</span>
	gp<span class="token punctuation">.</span>activeStackChans <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">// 发送操作是否成功，mysg.success 表示 true 成功，false 失败</span>
	closed <span class="token operator">:=</span> <span class="token operator">!</span>mysg<span class="token punctuation">.</span>success
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token keyword">if</span> mysg<span class="token punctuation">.</span>releasetime <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 记录协程阻塞的时间</span>
		<span class="token function">blockevent</span><span class="token punctuation">(</span>mysg<span class="token punctuation">.</span>releasetime<span class="token operator">-</span>t0<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 清空 sudog 对象的通道指针</span>
	mysg<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token function">releaseSudog</span><span class="token punctuation">(</span>mysg<span class="token punctuation">)</span>
	<span class="token keyword">if</span> closed <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果通道未关闭但协程被唤醒，抛出异常</span>
		<span class="token keyword">if</span> c<span class="token punctuation">.</span>closed <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"chansend: spurious wakeup"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 通道在发送操作完成前被关闭，报错 ！！！</span>
        <span class="token comment">// 这也就是为什么说向一个已经关闭通道写数据会报错，原因就在这里</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"send on closed channel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 发送操作成功完成</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      send
     </code>
     函数的作用是将数据直接发送给等待接收的协程，并唤醒等待接收的协程。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">send</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> sg <span class="token operator">*</span>sudog<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unlockf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> skip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 竞态检测</span>
	<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 无缓冲通道</span>
		<span class="token keyword">if</span> c<span class="token punctuation">.</span>dataqsiz <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 通知竞态检测器当前操作的上下文</span>
			<span class="token function">racesync</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 有缓冲通道</span>
			<span class="token comment">// Pretend we go through the buffer, even though</span>
			<span class="token comment">// we copy directly. Note that we need to increment</span>
			<span class="token comment">// the head/tail locations only when raceenabled.</span>
            <span class="token comment">// 即使数据是直接发送的，竞态检测器也会模拟数据通过缓冲区的流程</span>
			<span class="token comment">// 调用 racenotify，记录接收索引（c.recvx）的变化。</span>
			<span class="token function">racenotify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
			<span class="token function">racenotify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">,</span> sg<span class="token punctuation">)</span>
            <span class="token comment">// 更新接收索引 c.recvx 和发送索引 c.sendx，模拟环形缓冲区的行为</span>
			c<span class="token punctuation">.</span>recvx<span class="token operator">++</span>
			<span class="token keyword">if</span> c<span class="token punctuation">.</span>recvx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">{<!-- --></span>
				c<span class="token punctuation">.</span>recvx <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token punctuation">}</span>
			c<span class="token punctuation">.</span>sendx <span class="token operator">=</span> c<span class="token punctuation">.</span>recvx <span class="token comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 如果 sg.elem 不为 nil，调用 sendDirect 将数据从发送方 ep 直接发送到接收方 sg.elem</span>
	<span class="token keyword">if</span> sg<span class="token punctuation">.</span>elem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">sendDirect</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> ep<span class="token punctuation">)</span>
        <span class="token comment">// 清空 sg.elem，表示数据已发送</span>
		sg<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 获取等待接收的协程</span>
	gp <span class="token operator">:=</span> sg<span class="token punctuation">.</span>g
    <span class="token comment">// 调用解锁函数，释放通道的锁</span>
	<span class="token function">unlockf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 将 sudog 对象传递给接收协程，用于后续处理</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
    <span class="token comment">// 标记发送操作成功</span>
	sg<span class="token punctuation">.</span>success <span class="token operator">=</span> <span class="token boolean">true</span>
	<span class="token keyword">if</span> sg<span class="token punctuation">.</span>releasetime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		sg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token function">cputicks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 将 gp 协程标记为可运行状态，并将其加入调度队列中等待执行</span>
	<span class="token function">goready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> skip<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      sendDirect
     </code>
     函数的作用是将数据直接从发送方的内存位置发送到等待接收的协程
     <code>
      sudog
     </code>
     对象 。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">sendDirect</span><span class="token punctuation">(</span>t <span class="token operator">*</span>_type<span class="token punctuation">,</span> sg <span class="token operator">*</span>sudog<span class="token punctuation">,</span> src unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// src is on our stack, dst is a slot on another stack.</span>

	<span class="token comment">// Once we read sg.elem out of sg, it will no longer</span>
	<span class="token comment">// be updated if the destination's stack gets copied (shrunk).</span>
	<span class="token comment">// So make sure that no preemption points can happen between read &amp; use.</span>
    <span class="token comment">// 获取接收方的内存位置，以便将数据直接发送到该位置</span>
	dst <span class="token operator">:=</span> sg<span class="token punctuation">.</span>elem
    <span class="token comment">// 触发写屏障</span>
    <span class="token comment">// 确保垃圾回收器能够正确追踪目标内存区域中的指针</span>
	<span class="token function">typeBitsBulkBarrier</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>Size_<span class="token punctuation">)</span>
	<span class="token comment">// No need for cgo write barrier checks because dst is always</span>
	<span class="token comment">// Go memory.</span>
    <span class="token comment">// 这是一个底层函数，用于在内存中安全地移动数据</span>
    <span class="token comment">// dst 目标地址，src 源地址</span>
	<span class="token function">memmove</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Size_<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      关于更多内存管理的知识点，请关注后续文章《
      <code>
       Golang
      </code>
      内存模型》。
     </p>
    </blockquote>
    <h4>
     <a id="_1123">
     </a>
     接收数据
    </h4>
    <p>
     在
     <code>
      golang
     </code>
     的运行时中，接收数据操作的代码会被编译为对
     <code>
      chanrecv1
     </code>
     的调用。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">1</span>

	data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     编译成汇编代码如下所示：
    </p>
    <pre><code class="prism language-assembly">0x001a 00026        CALL    runtime.makechan(SB)
# ...
0x0043 00067        CALL    runtime.chanrecv1(SB)
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     而在
     <code>
      chanrecv1
     </code>
     的函数内部，又是对
     <code>
      chanrecv
     </code>
     的调用，如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/chan.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// entry points for &lt;- c from compiled code.</span>
<span class="token comment">//</span>
<span class="token comment">//go:nosplit</span>
<span class="token keyword">func</span> <span class="token function">chanrecv1</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> elem unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">chanrecv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_1164">
     </a>
     函数原型
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> block <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>selected<span class="token punctuation">,</span> received <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       c *hchan
      </code>
      ：指向目标通道的指针。
     </li>
     <li>
      <code>
       ep unsafe.Pointer
      </code>
      ：指向接收数据的内存位置。如果为
      <code>
       nil
      </code>
      ，表示仅检查通道状态而不接收数据。
     </li>
     <li>
      <code>
       block bool
      </code>
      ：是否允许阻塞接收。如果为
      <code>
       false
      </code>
      ，则在无法立即接收数据时返回。
     </li>
     <li>
      <code>
       selected bool
      </code>
      ：表示是否成功接收数据。在
      <code>
       select
      </code>
      语句中，用于标记是否选择了当前通道。
     </li>
     <li>
      <code>
       received bool
      </code>
      ：表示是否实际接收到数据。如果通道关闭且缓冲区为空，
      <code>
       received
      </code>
      为
      <code>
       false
      </code>
      。
     </li>
    </ul>
    <h5>
     <a id="_1178">
     </a>
     函数内容
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">chanrecv</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> block <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>selected<span class="token punctuation">,</span> received <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// raceenabled: don't need to check ep, as it is always on the stack</span>
	<span class="token comment">// or is new memory allocated by reflect.</span>
	<span class="token comment">// 如果启用了通道调试模式，打印调试信息</span>
	<span class="token keyword">if</span> debugChan <span class="token punctuation">{<!-- --></span>
		<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"chanrecv: chan="</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果通道为 nil</span>
	<span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token operator">!</span>block <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 非阻塞接收，直接返回</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果是阻塞接收，协程会阻塞并抛出异常</span>
		<span class="token function">gopark</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonChanReceiveNilChan<span class="token punctuation">,</span> traceBlockForever<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"unreachable"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果通道关联了一个定时器,则调用 maybeRunChan 来处理定时器事件</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>timer <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		c<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">maybeRunChan</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果是非阻塞接收且通道为空</span>
	<span class="token comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>block <span class="token operator">&amp;&amp;</span> <span class="token function">empty</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// After observing that the channel is not ready for receiving, we observe whether the</span>
		<span class="token comment">// channel is closed.</span>
		<span class="token comment">//</span>
		<span class="token comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span>
		<span class="token comment">// For example, if the channel was open and not empty, was closed, and then drained,</span>
		<span class="token comment">// reordered reads could incorrectly indicate "open and empty". To prevent reordering,</span>
		<span class="token comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span>
		<span class="token comment">// separate critical sections under the same lock.  This assumption fails when closing</span>
		<span class="token comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span>
        <span class="token comment">// 检查通道是否关闭</span>
		<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>closed<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Because a channel cannot be reopened, the later observation of the channel</span>
			<span class="token comment">// being not closed implies that it was also not closed at the moment of the</span>
			<span class="token comment">// first observation. We behave as if we observed the channel at that moment</span>
			<span class="token comment">// and report that the receive cannot proceed.</span>
            <span class="token comment">// 如果通道未关闭，直接返回</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span>
		<span class="token comment">// to receive, which could have arrived between the empty and closed checks above.</span>
		<span class="token comment">// Sequential consistency is also required here, when racing with such a send.</span>
        <span class="token comment">// 如果通道已关闭并且为非阻塞并且缓冲区为空</span>
		<span class="token keyword">if</span> <span class="token function">empty</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// The channel is irreversibly closed and empty.</span>
			<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
				<span class="token function">raceacquire</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
            <span class="token comment">// ep 不是空，则清空目标内存 ep</span>
			<span class="token keyword">if</span> ep <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> ep<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
            
            <span class="token comment">// 返回成功接收数据(true)，未实际接收到数据(false)</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> t0 <span class="token builtin">int64</span>
	<span class="token keyword">if</span> blockprofilerate <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		t0 <span class="token operator">=</span> <span class="token function">cputicks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 锁定通道的互斥锁，确保操作的原子性</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>

    <span class="token comment">// 如果通道已关闭</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>closed <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 缓冲区为空</span>
		<span class="token keyword">if</span> c<span class="token punctuation">.</span>qcount <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
				<span class="token function">raceacquire</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
            <span class="token comment">// 这里是通道已经关闭了，而且缓冲区已经为空</span>
            <span class="token comment">// 考虑是否可以采用原子操作来代替这里的 lock/unlock 操作的操作？</span>
            <span class="token comment">// ...</span>
            <span class="token comment">// 和通道关闭时，发送者的检测同理</span>
           	<span class="token comment">// 虽然理论上可以通过原子操作来避免加锁，但在实际实现中，锁的使用是为了确保线程安全和一致性，另外，虽然原子操作避免了锁的开销，但它们仍然有一定的性能开销</span>
            <span class="token comment">// 即使使用原子操作，也需要确保在检查 c.closed 和 c.qcount 时不会出现竞态条件。例如，如果一个协程在检查 c.closed 后修改了 c.qcount，可能会导致不一致的行为</span>
            <span class="token comment">// 记录吧！！！</span>
         	<span class="token comment">// 解锁</span>
			<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
            <span class="token comment">// 清空目标内存 ep</span>
			<span class="token keyword">if</span> ep <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> ep<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
            <span class="token comment">// 返回成功接收数据(true)，未实际接收到数据(false)</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// The channel has been closed, but the channel's buffer have data.</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 通道未关闭，并且有等待发送的协程</span>
		<span class="token comment">// Just found waiting sender with not closed.</span>
		<span class="token keyword">if</span> sg <span class="token operator">:=</span> c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> sg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// Found a waiting sender. If buffer is size 0, receive value</span>
			<span class="token comment">// directly from sender. Otherwise, receive from head of queue</span>
			<span class="token comment">// and add sender's value to the tail of the queue (both map to</span>
			<span class="token comment">// the same buffer slot because the queue is full).</span>
            <span class="token comment">// 调用 recv 函数直接从发送协程接收数据，跳过缓冲区</span>
            <span class="token comment">// 解锁通道</span>
			<span class="token function">recv</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> ep<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
            <span class="token comment">// 返回成功接收数据(true)，实际接收到数据(true)</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果缓冲区中有数据</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>qcount <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Receive directly from queue</span>
        <span class="token comment">// 得到缓冲区地址</span>
		qp <span class="token operator">:=</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">)</span>
		<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
			<span class="token function">racenotify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 从缓冲区中读取数据到目标内存</span>
		<span class="token keyword">if</span> ep <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> ep<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 清空缓冲区中的数据</span>
		<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
        <span class="token comment">// 更新接收索引 c.recvx</span>
		c<span class="token punctuation">.</span>recvx<span class="token operator">++</span>
        <span class="token comment">// 如果接收索引 == 缓冲区大小，则从 0 重新开始</span>
		<span class="token keyword">if</span> c<span class="token punctuation">.</span>recvx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">.</span>recvx <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 更新缓冲区计数 c.qcount</span>
		c<span class="token punctuation">.</span>qcount<span class="token operator">--</span>
        <span class="token comment">// 解锁</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
        <span class="token comment">// 返回成功接收数据(true)，实际接收到数据(true)</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 如果是非阻塞接收且缓冲区为空，解锁通道并返回未成功接收数据(false)，未实际接收到数据(false)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>block <span class="token punctuation">{<!-- --></span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 下面是进行阻塞接收数据代码逻辑</span>

	<span class="token comment">// no sender available: block on this channel.</span>
    <span class="token comment">// 获取当前协程</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 分配一个 sudog 对象</span>
	mysg <span class="token operator">:=</span> <span class="token function">acquireSudog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 下面是针对 mysg 对象属性的初始化</span>
	mysg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">if</span> t0 <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		mysg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// No stack splits between assigning elem and enqueuing mysg</span>
	<span class="token comment">// on gp.waiting where copystack can find it.</span>
	mysg<span class="token punctuation">.</span>elem <span class="token operator">=</span> ep
	mysg<span class="token punctuation">.</span>waitlink <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>waiting <span class="token operator">=</span> mysg

	mysg<span class="token punctuation">.</span>g <span class="token operator">=</span> gp
	mysg<span class="token punctuation">.</span>isSelect <span class="token operator">=</span> <span class="token boolean">false</span>
	mysg<span class="token punctuation">.</span>c <span class="token operator">=</span> c
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>
    <span class="token comment">// 将协程加入接收等待队列</span>
	c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>mysg<span class="token punctuation">)</span>
    <span class="token comment">// 如果通道关联了定时器，调用 blockTimerChan</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>timer <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">blockTimerChan</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Signal to anyone trying to shrink our stack that we're about</span>
	<span class="token comment">// to park on a channel. The window between when this G's status</span>
	<span class="token comment">// changes and when we set gp.activeStackChans is not safe for</span>
	<span class="token comment">// stack shrinking.</span>
    <span class="token comment">// 标记协程即将阻塞在通道操作上</span>
	gp<span class="token punctuation">.</span>parkingOnChan<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token comment">// 调用 gopark 阻塞当前协程，直到被发送操作唤醒</span>
	<span class="token function">gopark</span><span class="token punctuation">(</span>chanparkcommit<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span> waitReasonChanReceive<span class="token punctuation">,</span> traceBlockChanRecv<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token comment">// 下面是协程被唤醒之后的操作流程</span>
    
	<span class="token comment">// someone woke us up</span>
    <span class="token comment">// 检查协程是否被正确唤醒</span>
	<span class="token keyword">if</span> mysg <span class="token operator">!=</span> gp<span class="token punctuation">.</span>waiting <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"G waiting list is corrupted"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 如果通道关联了定时器，调用 unblockTimerChan</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>timer <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">unblockTimerChan</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 清理协程状态</span>
	gp<span class="token punctuation">.</span>waiting <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>activeStackChans <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token keyword">if</span> mysg<span class="token punctuation">.</span>releasetime <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">blockevent</span><span class="token punctuation">(</span>mysg<span class="token punctuation">.</span>releasetime<span class="token operator">-</span>t0<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 获取接收操作的结果</span>
	success <span class="token operator">:=</span> mysg<span class="token punctuation">.</span>success
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>
    <span class="token comment">// 释放 sudog 对象</span>
	mysg<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token function">releaseSudog</span><span class="token punctuation">(</span>mysg<span class="token punctuation">)</span>
    <span class="token comment">// 返回接收操作结果</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> success
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      recv
     </code>
     函数用于从通道中读取数据，并将其传递给等待接收的协程。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">recv</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">,</span> sg <span class="token operator">*</span>sudog<span class="token punctuation">,</span> ep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unlockf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> skip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果通道无缓冲区</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>dataqsiz <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
			<span class="token function">racesync</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> sg<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 并且目标内存位置不是 nil， 则直接拷贝到目标位置</span>
		<span class="token keyword">if</span> ep <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// copy data from sender</span>
			<span class="token function">recvDirect</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> ep<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 通道有缓冲区</span>
		<span class="token comment">// Queue is full. Take the item at the</span>
		<span class="token comment">// head of the queue. Make the sender enqueue</span>
		<span class="token comment">// its item at the tail of the queue. Since the</span>
		<span class="token comment">// queue is full, those are both the same slot.</span>
        <span class="token comment">// 计算缓冲区中接收位置的指针</span>
		qp <span class="token operator">:=</span> <span class="token function">chanbuf</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">)</span>
		<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
			<span class="token function">racenotify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
			<span class="token function">racenotify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">.</span>recvx<span class="token punctuation">,</span> sg<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// copy data from queue to receiver</span>
		<span class="token keyword">if</span> ep <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果目标内存位置不是 nil， 将数据从缓冲区复制到接收方的内存位置</span>
			<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> ep<span class="token punctuation">,</span> qp<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// copy data from sender to queue</span>
        <span class="token comment">// 将发送方的数据复制到缓冲区的尾部</span>
		<span class="token function">typedmemmove</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> qp<span class="token punctuation">,</span> sg<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
        <span class="token comment">// 增加接收索引并处理环形缓冲区的边界条件</span>
		c<span class="token punctuation">.</span>recvx<span class="token operator">++</span>
		<span class="token keyword">if</span> c<span class="token punctuation">.</span>recvx <span class="token operator">==</span> c<span class="token punctuation">.</span>dataqsiz <span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">.</span>recvx <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 更新发送索引，使其指向下一个可用位置</span>
		c<span class="token punctuation">.</span>sendx <span class="token operator">=</span> c<span class="token punctuation">.</span>recvx <span class="token comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 清空 sudog 对象中的数据指针</span>
	sg<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token boolean">nil</span>
    <span class="token comment">// 获取发送协程的指针</span>
	gp <span class="token operator">:=</span> sg<span class="token punctuation">.</span>g
    <span class="token comment">// 调用解锁函数，释放通道的锁</span>
	<span class="token function">unlockf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
    <span class="token comment">// 标记接收操作成功</span>
	sg<span class="token punctuation">.</span>success <span class="token operator">=</span> <span class="token boolean">true</span>
	<span class="token keyword">if</span> sg<span class="token punctuation">.</span>releasetime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		sg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token function">cputicks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 将 gp 协程标记为可运行状态，并将其加入调度队列中等待执行</span>
	<span class="token function">goready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> skip<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      recvDirect
     </code>
     函数的作用是从发送方直接接收数据，并将其复制到接收方的目标内存位置。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">recvDirect</span><span class="token punctuation">(</span>t <span class="token operator">*</span>_type<span class="token punctuation">,</span> sg <span class="token operator">*</span>sudog<span class="token punctuation">,</span> dst unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// dst is on our stack or the heap, src is on another stack.</span>
	<span class="token comment">// The channel is locked, so src will not move during this</span>
	<span class="token comment">// operation.</span>
    <span class="token comment">// 指向发送方的内存位置</span>
	src <span class="token operator">:=</span> sg<span class="token punctuation">.</span>elem
    <span class="token comment">// 写屏障</span>
    <span class="token comment">// 确保目标内存位置中的指针被垃圾回收器正确追踪</span>
	<span class="token function">typeBitsBulkBarrier</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>Size_<span class="token punctuation">)</span>
    <span class="token comment">// 将数据从发送方的内存位置复制到接收方的内存位置</span>
	<span class="token function">memmove</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Size_<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      关于更多内存管理的知识点，请关注后续文章《
      <code>
       Golang
      </code>
      内存模型》。
     </p>
    </blockquote>
    <h4>
     <a id="_1471">
     </a>
     关闭通道
    </h4>
    <p>
     在
     <code>
      golang
     </code>
     的运行时中，关闭通道操作的代码会被编译为对
     <code>
      closechan
     </code>
     的调用。如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     编译成汇编代码如下所示：
    </p>
    <pre><code class="prism language-assembly">0x001a 00026        CALL    runtime.makechan(SB)
# ...
0x0020 00032        CALL    runtime.closechan(SB)
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <h5>
     <a id="_1496">
     </a>
     函数原型
    </h5>
    <blockquote>
     <p>
      源码位置：src/runtime/chan.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">closechan</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      <code>
       c *hchan
      </code>
      ：指向要关闭的通道的指针。
     </li>
    </ul>
    <h5>
     <a id="_1508">
     </a>
     函数内容
    </h5>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">closechan</span><span class="token punctuation">(</span>c <span class="token operator">*</span>hchan<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果通道为 nil，直接抛出异常</span>
	<span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"close of nil channel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 锁定通道的互斥锁，确保关闭操作的原子性</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>closed <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果通道已经关闭，解锁，抛出异常</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">"close of closed channel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
		callerpc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token function">racewritepc</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> callerpc<span class="token punctuation">,</span> abi<span class="token punctuation">.</span><span class="token function">FuncPCABIInternal</span><span class="token punctuation">(</span>closechan<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">racerelease</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 将通道的 closed 标志设置为 1，表示通道已关闭</span>
	c<span class="token punctuation">.</span>closed <span class="token operator">=</span> <span class="token number">1</span>
	
    <span class="token comment">// 需要被唤醒的协程集合</span>
	<span class="token keyword">var</span> glist gList

	<span class="token comment">// release all readers</span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 遍历通道的接收等待队列，释放所有等待接收的协程</span>
		sg <span class="token operator">:=</span> c<span class="token punctuation">.</span>recvq<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> sg <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果 sg.elem 不为 nil</span>
		<span class="token keyword">if</span> sg<span class="token punctuation">.</span>elem <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 清空接收方的内存位置</span>
			<span class="token function">typedmemclr</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>elemtype<span class="token punctuation">,</span> sg<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>
			sg<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> sg<span class="token punctuation">.</span>releasetime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			sg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token function">cputicks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">// 获取到接收者协程</span>
		gp <span class="token operator">:=</span> sg<span class="token punctuation">.</span>g
		gp<span class="token punctuation">.</span>param <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
        <span class="token comment">// 标记获取操作失败</span>
		sg<span class="token punctuation">.</span>success <span class="token operator">=</span> <span class="token boolean">false</span>
		<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
			<span class="token function">raceacquireg</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 将协程加入到 glist 中，稍后唤醒</span>
		glist<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// release all writers (they will panic)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 遍历通道的发送等待队列，释放所有等待发送的协程</span>
		sg <span class="token operator">:=</span> c<span class="token punctuation">.</span>sendq<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> sg <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 清空 sg.elem，避免内存泄漏</span>
		sg<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token keyword">if</span> sg<span class="token punctuation">.</span>releasetime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			sg<span class="token punctuation">.</span>releasetime <span class="token operator">=</span> <span class="token function">cputicks</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">// 获取到发送者协程</span>
		gp <span class="token operator">:=</span> sg<span class="token punctuation">.</span>g
		gp<span class="token punctuation">.</span>param <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span>
        <span class="token comment">// 标记发送操作失败</span>
		sg<span class="token punctuation">.</span>success <span class="token operator">=</span> <span class="token boolean">false</span>
		<span class="token keyword">if</span> raceenabled <span class="token punctuation">{<!-- --></span>
			<span class="token function">raceacquireg</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">raceaddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 将协程加入到 glist 中，稍后唤醒</span>
		glist<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 解锁通道的互斥锁</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>

	<span class="token comment">// Ready all Gs now that we've dropped the channel lock.</span>
    <span class="token comment">// 遍历 glist，唤醒所有等待的协程</span>
	<span class="token keyword">for</span> <span class="token operator">!</span>glist<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		gp <span class="token operator">:=</span> glist<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		gp<span class="token punctuation">.</span>schedlink <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token comment">// 调用 goready 将协程标记为可运行状态</span>
		<span class="token function">goready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     🌺🌺🌺撒花！
    </p>
    <p>
     如果本文对你有帮助，就点关注或者留个👍
     <br/>
     如果您有任何技术问题或者需要更多其他的内容，请随时向我提问。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3734a0d4d24847a6ad83ea7ad3b1a2c6.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34363238373931382f:61727469636c652f64657461696c732f313436313038363031" class_="artid" style="display:none">
 </p>
</div>


