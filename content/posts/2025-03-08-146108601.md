---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34363238373931382f:61727469636c652f64657461696c732f313436313038363031"
layout: post
title: "åä¸‰Golang-é€šé“"
date: 2025-03-08 00:20:23 +08:00
description: "é€šé“å°±æ˜¯ golang ä¸­å®ç° Goroutine ä¹‹é—´é€šä¿¡çš„æœºåˆ¶ã€‚å®ƒæ˜¯ä¸€ç§ç±»å‹åŒ–çš„é€šé“ï¼Œå…è®¸å¤šä¸ª Goroutine ä¹‹é—´å®‰å…¨åœ°ä¼ é€’æ•°æ®ã€‚é€šé“æ˜¯ Golang å¹¶å‘æ¨¡å‹çš„æ ¸å¿ƒï¼Œå®ƒè§£å†³äº†ä¼ ç»Ÿå¹¶å‘ç¼–ç¨‹ä¸­å…±äº«å†…å­˜å¸¦æ¥çš„å¤æ‚æ€§å’Œé£é™©ã€‚"
keywords: "ã€åä¸‰ã€‘Golang é€šé“"
categories: ['Golang']
tags: ['å¼€å‘è¯­è¨€', 'åç«¯', 'Golang']
artid: "146108601"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146108601
    alt: "åä¸‰Golang-é€šé“"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146108601
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146108601
cover: https://bing.ee123.net/img/rand?artid=146108601
image: https://bing.ee123.net/img/rand?artid=146108601
img: https://bing.ee123.net/img/rand?artid=146108601
---

# ã€åä¸‰ã€‘Golang é€šé“

> ğŸ’¢æ¬¢è¿æ¥åˆ°å¼ èƒ¤å°˜çš„å¼€æºæŠ€æœ¯ç«™
>   
> ğŸ’¥å¼€æºå¦‚æ±Ÿæ²³ï¼Œæ±‡èšä¼—å¿—æˆã€‚ä»£ç ä¼¼æ˜Ÿè¾°ï¼Œç…§äº®è¡Œå¾ç¨‹ã€‚å¼€æºç²¾ç¥é•¿ï¼Œä¼ æ‰¿æ°¸ä¸å¿˜ã€‚æºæ‰‹å…±å‰è¡Œï¼Œæœªæ¥æ›´è¾‰ç…ŒğŸ’¥

## é€šé“

åœ¨ä¼ ç»Ÿçš„å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œå¤šä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹ä¹‹é—´é€šå¸¸é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ã€‚è¿™ç§æ¨¡å‹è™½ç„¶é«˜æ•ˆï¼Œä½†å®¹æ˜“å¼•å‘
**ç«äº‰æ¡ä»¶**
å’Œ
**æ­»é”**
ç­‰é—®é¢˜ã€‚ä¸ºäº†é¿å…è¿™äº›é—®é¢˜ï¼Œç¨‹åºå‘˜åœ¨å¼€å‘æ—¶éœ€è¦ä½¿ç”¨å¤æ‚çš„åŒæ­¥æœºåˆ¶ï¼ˆä¾‹å¦‚ï¼šé”ã€ä¿¡å·é‡ç­‰ï¼‰æ¥ä¿æŠ¤å…±äº«æ•°æ®ã€‚ä½†æ˜¯
`golang`
é‡‡ç”¨äº†ä¸åŒçš„æ€è·¯ï¼š
**é¿å…å…±äº«å†…å­˜ï¼Œé€šè¿‡é€šä¿¡æ¥å®ç°å¹¶å‘**
ã€‚

ç¤ºæ„å›¾æ‰€ä¸‹æ‰€ç¤ºï¼š

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/62f98800d43642fa8f37dda53731d8d8.png)

é€šé“å°±æ˜¯
`golang`
ä¸­å®ç°
`Goroutine`
ä¹‹é—´é€šä¿¡çš„æœºåˆ¶ã€‚å®ƒæ˜¯ä¸€ç§
**ç±»å‹åŒ–çš„é€šé“**
ï¼Œå…è®¸å¤šä¸ª
`Goroutine`
ä¹‹é—´å®‰å…¨åœ°ä¼ é€’æ•°æ®ã€‚é€šé“æ˜¯
`Golang`
å¹¶å‘æ¨¡å‹çš„æ ¸å¿ƒï¼Œå®ƒè§£å†³äº†ä¼ ç»Ÿå¹¶å‘ç¼–ç¨‹ä¸­å…±äº«å†…å­˜å¸¦æ¥çš„å¤æ‚æ€§å’Œé£é™©ã€‚

> æœ¬ç¯‡æ–‡ç« ä¸»è¦ä»‹ç»çš„æ˜¯é€šé“ï¼Œæœ‰å…³äºåç¨‹ã€å¹¶å‘ç¼–ç¨‹ç­‰ç›¸å…³çŸ¥è¯†ç‚¹è¯·å…³æ³¨åç»­æ–‡ç« ã€Š
> `Golang`
> åç¨‹ã€‹ã€ã€Š
> `Golang`
> å¹¶å‘ç¼–ç¨‹ã€‹ã€‚

### é€šé“å£°æ˜

ä½¿ç”¨
`var`
å…³é”®å­—å£°æ˜é€šé“å˜é‡ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
var ch chan int

```

å£°æ˜åï¼Œ
`ch`
æ˜¯ä¸€ä¸ªæœªåˆå§‹åŒ–çš„é€šé“ï¼Œå…¶é»˜è®¤å€¼ä¸º
`nil`
ã€‚

### åˆå§‹åŒ–

ä½¿ç”¨
`make`
å‡½æ•°åˆå§‹åŒ–é€šé“ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
ch = make(chan int)

```

ä¹Ÿå¯ä»¥ä½¿ç”¨
`make`
å‡½æ•°åˆ›å»ºä¸€ä¸ªå¸¦ç¼“å†²åŒºçš„é€šé“ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
ch = make(chan int, 10)

```

### ç¼“å†²æœºåˆ¶

é€šé“åˆ†ä¸º
**æ— ç¼“å†²é€šé“**
å’Œ
**å¸¦ç¼“å†²é€šé“**
ï¼Œå®ƒä»¬åœ¨è¡Œä¸ºå’Œä½¿ç”¨åœºæ™¯ä¸Šæœ‰ä¸€äº›å…³é”®åŒºåˆ«ã€‚

#### æ— ç¼“å†²é€šé“

åœ¨åˆå§‹åŒ–çš„å°ç»“ä¸­ï¼Œä½¿ç”¨
`make`
å‡½æ•°è¿›è¡Œåˆå§‹åŒ–é€šé“ï¼Œå½“æ²¡æœ‰æŒ‡å®šé€šé“çš„å®¹é‡ï¼Œæˆ–è€…è¯´é€šé“çš„å®¹é‡å¤§å°ä¸º 0 æ—¶ï¼Œç§°ä¸ºæ— ç¼“å†²é€šé“ã€‚

æ— ç¼“å†²é€šé“åœ¨å‘é€æ•°æ®å’Œæ¥æ”¶æ•°æ®æ—¶å­˜åœ¨å¦‚ä¸‹çš„ç‰¹ç‚¹ï¼š

* **å‘é€æ“ä½œ**
  ï¼šå‘é€æ•°æ®æ—¶ï¼Œå‘é€æ–¹ä¼šé˜»å¡ï¼Œç›´åˆ°æœ‰æ¥æ”¶æ–¹å‡†å¤‡æ¥æ”¶æ•°æ®ã€‚
* **æ¥æ”¶æ“ä½œ**
  ï¼šæ¥æ”¶æ–¹ä¼šé˜»å¡ï¼Œç›´åˆ°æœ‰å‘é€æ–¹å‘é€æ•°æ®ã€‚
* æ— ç¼“å†²é€šé“çš„å‘é€å’Œæ¥æ”¶æ“ä½œæ˜¯
  **åŒæ­¥çš„**
  ï¼Œå¿…é¡»æœ‰å‘é€æ–¹å’Œæ¥æ”¶æ–¹åŒæ—¶å‡†å¤‡å¥½ï¼Œæ‰èƒ½å®Œæˆé€šä¿¡ã€‚

##### ä»£ç ç¤ºä¾‹

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	unbufferedChan := make(chan int) // åˆ›å»ºæ— ç¼“å†²é€šé“
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		fmt.Println("receiver is waiting...") // receiver is waiting...
		time.Sleep(time.Second * 3)	// æ¨¡æ‹Ÿ3ç§’çš„å‡†å¤‡æ—¶é—´
		data := <-unbufferedChan // åœ¨è¿™è¡Œå‡½æ•°æ‰§è¡Œä¹‹å‰ï¼Œå‘é€æ–¹å¤„äºé˜»å¡çŠ¶æ€
		fmt.Println("received:", data)
	}()

	unbufferedChan <- 42 	// å‘é€æ–¹é˜»å¡ï¼Œç›´åˆ°æ¥æ”¶æ–¹å‡†å¤‡å¥½
    
    close(unbufferedChan)	// å…³é—­é€šé“
	
    wg.Wait()
}

```

#### å¸¦ç¼“å†²é€šé“

å½“æŒ‡å®šäº†é€šé“çš„å®¹é‡ï¼Œä¾‹å¦‚
`make(chan int, 10)`
ï¼Œåˆ™ç§°ä¸ºå¸¦ç¼“å†²é€šé“ã€‚

å¸¦ç¼“å†²é€šé“åœ¨å‘é€æ•°æ®å’Œæ¥æ”¶æ•°æ®æ—¶å­˜åœ¨å¦‚ä¸‹çš„ç‰¹ç‚¹ï¼š

* **å‘é€æ“ä½œ**
  ï¼šå‘é€æ•°æ®æ—¶ï¼Œå¦‚æœç¼“å†²åŒºæœªæ»¡ï¼Œæ•°æ®ä¼šè¢«æ”¾å…¥ç¼“å†²åŒºï¼Œå‘é€æ–¹ä¸ä¼šé˜»å¡ï¼›å¦‚æœç¼“å†²åŒºå·²æ»¡ï¼Œå‘é€æ–¹ä¼šé˜»å¡ï¼Œç›´åˆ°ç¼“å†²åŒºæœ‰ç©ºé—´ã€‚
* **æ¥æ”¶æ“ä½œ**
  ï¼šæ¥æ”¶æ–¹ä»ç¼“å†²åŒºä¸­å–å‡ºæ•°æ®ï¼Œå¦‚æœç¼“å†²åŒºä¸ºç©ºï¼Œæ¥æ”¶æ–¹ä¼šé˜»å¡ï¼Œç›´åˆ°æœ‰æ•°æ®å¯ç”¨ã€‚
* å¸¦ç¼“å†²é€šé“çš„å‘é€å’Œæ¥æ”¶æ“ä½œæ˜¯
  **å¼‚æ­¥çš„**
  ï¼Œå‘é€æ–¹å’Œæ¥æ”¶æ–¹ä¸éœ€è¦åŒæ—¶å‡†å¤‡å¥½ã€‚ç¼“å†²åŒºçš„å­˜åœ¨å…è®¸æ•°æ®åœ¨å‘é€æ–¹å’Œæ¥æ”¶æ–¹ä¹‹é—´æš‚æ—¶å­˜å‚¨ã€‚

##### ä»£ç ç¤ºä¾‹

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	bufferedChan := make(chan int, 2) // åˆ›å»ºå¸¦ç¼“å†²é€šé“ï¼Œå®¹é‡å¤§å°ä¸º2
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		fmt.Println("receiver is waiting...")
		// for {
		// 	select {
		// 	case data, ok := <-bufferedChan:
		// 		if ok {
		// 			fmt.Println("received:", data)
		// 		} else {
		// 			fmt.Println("bufferedChan closed")
		// 			return
		// 		}
		// 	}
		// }
		for {
			time.Sleep(time.Second * 5) // æ¨¡æ‹Ÿæ¥æ”¶æ–¹ä¸ä»ç¼“å†²é€šé“ä¸­æ¥æ”¶æ•°æ®
		}
	}()

	bufferedChan <- 42
	bufferedChan <- 43
	bufferedChan <- 44 // å¦‚æœæ¥æ”¶æ–¹ä¸€ç›´æœªæ¥æ”¶æ•°æ®ï¼Œåˆ™åœ¨æ­¤å¤„ä¼šå‘é€é˜»å¡
	fmt.Println("send data over ...")

	close(bufferedChan) // å…³é—­é€šé“

	wg.Wait()
}

```

### é€šé“æ“ä½œ

#### å‘é€æ•°æ®

ä½¿ç”¨
`<-`
æ“ä½œç¬¦å°†æ•°æ®å‘é€åˆ°é€šé“ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

func main() {
	ch := make(chan int)
	ch <- 10 // å‘é€šé“ä¸­å‘é€ä¸€ä¸ª 10
    
    close(ch) // å…³é—­é€šé“
}

```

#### æ¥æ”¶æ•°æ®

ä½¿ç”¨
`<-`
æ“ä½œç¬¦ä»é€šé“ä¸­è¯»å–æ•°æ®ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 1)
	ch <- 10 // å‘é€šé“ä¸­å‘é€ä¸€ä¸ª 10

	data := <-ch      // é€šé“ä¸­è¯»å–ä¸€ä¸ªæ•°æ®
	fmt.Println(data) // 10

	close(ch) // å…³é—­é€šé“
}

```

#### å•å‘é€šé“

`golang`
ä¸­æä¾›äº†å•å‘é€šé“è¿™ä¹ˆä¸€ç§ç‰¹æ®Šçš„é€šé“ç±»å‹ï¼Œå®ƒåªèƒ½ç”¨äºå‘é€æˆ–æ¥æ”¶æ•°æ®ï¼Œè€Œä¸èƒ½åŒæ—¶è¿›è¡Œå‘é€å’Œæ¥æ”¶æ“ä½œã€‚å•å‘é€šé“åœ¨ç±»å‹å£°æ˜ä¸Šä¸æ™®é€šé€šé“ï¼ˆåŒå‘é€šé“ï¼‰æœ‰æ‰€ä¸åŒï¼Œä¸»è¦ç”¨äºé™åˆ¶é€šé“çš„ä½¿ç”¨æ–¹å¼ï¼Œä»è€Œæé«˜ä»£ç çš„å¯è¯»æ€§å’Œå®‰å…¨æ€§ã€‚

å•å‘é€šé“æœ‰å¦‚ä¸‹ä¸¤ç§ç±»å‹ï¼š

* **åªå‘é€é€šé“**
  ï¼šç”¨äºå‘é€æ•°æ®ï¼Œä½†ä¸èƒ½æ¥æ”¶æ•°æ®ã€‚

```go
chan<- Type

```

* **åªæ¥æ”¶é€šé“**
  ï¼šç”¨äºæ¥æ”¶æ•°æ®ï¼Œä½†ä¸èƒ½å‘é€æ•°æ®ã€‚

```go
<-chan Type

```

##### å•å‘é€šé“çš„ç”¨é€”

å•å‘é€šé“çš„ä¸»è¦ç”¨é€”æ˜¯é™åˆ¶é€šé“çš„ä½¿ç”¨èŒƒå›´ï¼Œé¿å…åœ¨å‡½æ•°æˆ–æ–¹æ³•ä¸­æ»¥ç”¨é€šé“çš„å‘é€å’Œæ¥æ”¶åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼š

* å½“ä¸€ä¸ªå‡½æ•°åªéœ€è¦ä»é€šé“ä¸­è¯»å–æ•°æ®æ—¶ï¼Œä½¿ç”¨åªæ¥æ”¶é€šé“å¯ä»¥æ˜ç¡®è¡¨ç¤ºè¯¥å‡½æ•°çš„æ„å›¾ã€‚
* å½“ä¸€ä¸ªå‡½æ•°åªéœ€è¦å‘é€šé“ä¸­å†™å…¥æ•°æ®æ—¶ï¼Œä½¿ç”¨åªå‘é€é€šé“å¯ä»¥é¿å…æ„å¤–è¯»å–é€šé“ä¸­çš„æ•°æ®ã€‚

##### ä»£ç ç¤ºä¾‹

```go
package main

import (
	"fmt"
	"sync"
)

func producer(ch chan<- int, wg *sync.WaitGroup) { // ch å‚æ•°ï¼šä¸€ä¸ªåªå‘é€é€šé“
	defer wg.Done()
	for i := 0; i < 5; i++ {
		ch <- i // å‘é€šé“å‘é€æ•°æ®
		fmt.Printf("sent: %d\n", i)
	}

	close(ch) // å…³é—­é€šé“
}

func consumer(ch <-chan int, wg *sync.WaitGroup) { // ch å‚æ•°ï¼šä¸€ä¸ªåªæ¥æ”¶é€šé“
	defer wg.Done()
	for {
		select {
		case data, ok := <-ch:	// è¯»å–é€šé“æ•°æ®
			if ok {
				fmt.Printf("received: %d\n", data)
			} else {
				fmt.Println("chan closed ...")
				return
			}
		}
	}
}

func main() {
	var wg sync.WaitGroup
	ch := make(chan int) // åˆ›å»ºä¸€ä¸ªåŒå‘é€šé“
	wg.Add(2)

	// received: 0
	// sent: 0
	// sent: 1
	// received: 1
	// received: 2
	// sent: 2
	// sent: 3
	// received: 3
	// received: 4
	// sent: 4
	// chan closed ...

	go consumer(ch, &wg) // æ¥æ”¶è€…
	go producer(ch, &wg) // å‘é€è€…

	wg.Wait()
}


```

#### å¤šè·¯å¤ç”¨

é€šé“çš„å¤šè·¯å¤ç”¨æœºåˆ¶æ˜¯ä¸€ç§ç”¨äºå¤„ç†å¤šä¸ªé€šé“æ“ä½œçš„æŠ€æœ¯ï¼Œå®ƒå…è®¸ç¨‹åºåŒæ—¶ç­‰å¾…å¤šä¸ªé€šé“çš„è¯»å†™æ“ä½œã€‚è¿™ç§æœºåˆ¶çš„æ ¸å¿ƒæ˜¯
`select...case`
è¯­å¥ï¼Œå®ƒæä¾›äº†å¯¹å¤šä¸ªé€šé“æ“ä½œçš„å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚

```go
select {
case <-ch1:
    // å¤„ç† ch1 çš„è¯»æ“ä½œ
case data := <-ch2:
    // å¤„ç† ch2 çš„è¯»æ“ä½œï¼Œå¹¶å°†è¯»å–åˆ°çš„æ•°æ®èµ‹å€¼ç»™ data
case ch3 <- value:
    // å‘ ch3 ä¸­å‘é€å€¼
default:
    // å¦‚æœæ²¡æœ‰é€šé“å‡†å¤‡å¥½ï¼Œåˆ™æ‰§è¡Œé»˜è®¤é€»è¾‘
}

```

å¦å¤–éœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œå¦‚æœå¤šä¸ªé€šé“åŒæ—¶å‡†å¤‡å¥½ï¼Œ
`select...case`
ä¼šéšæœºé€‰æ‹©ä¸€ä¸ªé€šé“æ‰§è¡Œæ“ä½œï¼›å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ä¸ª
**é€šé“å‡†å¤‡å¥½**
ï¼Œåˆ™
`select`
ä¼šé™·å…¥é˜»å¡ï¼Œé™¤éæœ‰
`default`
åˆ†æ”¯æ‰§è¡Œã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸Šé¢æåˆ°çš„
**é€šé“å‡†å¤‡å¥½**
æ˜¯ä¸ªå£è¯­ï¼Œå¯¹äºæ¥æ”¶æ“ä½œæ¥è¯´éœ€è¦æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ä¸­çš„ä»»æ„ä¸€ä¸ªï¼š

* **é€šé“ä¸­æœ‰æ•°æ®å¯è¯»**
  ï¼šå¦‚æœé€šé“çš„ç¼“å†²åŒºä¸­æœ‰æ•°æ®ï¼Œæˆ–è€…æœ‰å‘é€æ“ä½œæ­£åœ¨ç­‰å¾…å‘é€æ•°æ®åˆ°é€šé“ä¸­ï¼Œé‚£ä¹ˆæ¥æ”¶æ“ä½œå°±å‡†å¤‡å¥½ã€‚
* **é€šé“å·²å…³é—­**
  ï¼šå³ä½¿é€šé“ä¸­æ²¡æœ‰æ•°æ®ï¼Œå¦‚æœé€šé“å·²ç»è¢«å…³é—­ï¼Œæ¥æ”¶æ“ä½œä¹Ÿä¼šç«‹å³è¿”å›é›¶å€¼ï¼Œå¹¶ä¸”
  `ok`
  ä¸º
  `false`
  ï¼ˆå¦‚æœä½¿ç”¨äº†
  `data, ok := <-ch`
  çš„å½¢å¼ï¼‰ã€‚

å¯¹å‘é€æ“ä½œæ¥è¯´ä¹Ÿéœ€è¦æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ä¸­çš„ä»»æ„ä¸€ä¸ªï¼š

* **é€šé“ä¸­æœ‰ç©ºé—´å¯å†™**
  ï¼šå¦‚æœé€šé“æ˜¯æ— ç¼“å†²çš„ï¼Œå¹¶ä¸”æœ‰ç­‰å¾…æ¥æ”¶çš„åç¨‹ï¼Œæˆ–è€…é€šé“æ˜¯ç¼“å†²çš„ä¸”ç¼“å†²åŒºä¸­æœ‰ç©ºé—²ä½ç½®ï¼Œé‚£ä¹ˆå‘é€æ“ä½œå°±å‡†å¤‡å¥½ã€‚
* **é€šé“å·²å…³é—­**
  ï¼šå¦‚æœé€šé“å·²ç»è¢«å…³é—­ï¼Œå‘é€æ“ä½œä¼šè§¦å‘
  `panic("send on closed channel")`
  ã€‚

##### ä»£ç ç¤ºä¾‹

é€šè¿‡
`select`
åŒæ—¶å¤„ç†å¤šä¸ªé€šé“ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch1 := make(chan string) // åˆ›å»ºé€šé“ ch1
	ch2 := make(chan string) // åˆ›å»ºé€šé“ ch2

	go func() { // æ¯é—´éš” 1 ç§’ï¼Œå‘é€šé“ ch1 ä¸­å‘é€æ•°æ®ï¼Œä¸€å…±å‘é€ 10 æ¡æ•°æ®
		defer close(ch1)
		for i := 1; i <= 10; i++ {
			ch1 <- "message from ch1"
			time.Sleep(1 * time.Second)
		}
	}()

	go func() { // æ¯é—´éš” 2 ç§’ï¼Œå‘é€šé“ ch2 ä¸­å‘é€æ•°æ®ï¼Œä¸€å…±å‘é€ 10 æ¡æ•°æ®
		defer close(ch2)
		for i := 1; i <= 10; i++ {
			ch2 <- "message from ch2"
			time.Sleep(2 * time.Second)
		}
	}()

	// no data reception ...
	// recived:  message from ch2
	// recived:  message from ch1
	// no data reception ...
	// no data reception ...
	// recived:  message from ch1
	// no data reception ...
	// recived:  message from ch2
	// recived:  message from ch1
	// no data reception ...
	// recived:  message from ch1
	// no data reception ...
	// no data reception ...
	// recived:  message from ch1
	// recived:  message from ch2
	// no data reception ...
	// recived:  message from ch1
	// no data reception ...
	// recived:  message from ch1
	// recived:  message from ch2
	// no data reception ...
	// recived:  message from ch1
	// no data reception ...
	// no data reception ...
	// recived:  message from ch1
	// recived:  message from ch2
	// no data reception ...
	// recived:  message from ch1
	// no data reception ...
	// recived:  message from ch2
	// ch1 chan closed ...
	// recived:  message from ch2
	// recived:  message from ch2
	// recived:  message from ch2
	// recived:  message from ch2
	// ch2 chan closed ...
	// both channels closed. exiting...

	ch1_s, ch2_s := true, true

	for ch1_s || ch2_s {
		select {
		case data, ok := <-ch1:
			if ok {
				fmt.Println("recived: ", data)
			} else if ch1_s {
				fmt.Println("ch1 chan closed ...")
				ch1_s = false
			}
		case data, ok := <-ch2:
			if ok {
				fmt.Println("recived: ", data)
			} else if ch2_s {
				fmt.Println("ch2 chan closed ...")
				ch2_s = false
			}
		default:
			fmt.Println("no data reception ...")
			time.Sleep(time.Second)
		}
	}

	fmt.Println("both channels closed. exiting...")
}


```

##### é€šé“å¤ç”¨å™¨çš„å®ç°

åœ¨æŸäº›å¤æ‚åœºæ™¯ä¸­ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨å®ç°é€šé“å¤ç”¨å™¨ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å°†å¤šä¸ªé€šé“çš„è¾“å‡ºåˆå¹¶åˆ°ä¸€ä¸ªé€šé“ä¸­ï¼Œä»è€Œç®€åŒ–åç»­çš„å¤„ç†é€»è¾‘ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„é€šé“å¤ç”¨å™¨å®ç°æ€è·¯ï¼š

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func send(ch chan<- int) { // æ¨¡æ‹Ÿæ•°æ®å‘é€ï¼Œæ¯ç§’å‘é€ä¸€ä¸ªæ•°å­—
	defer close(ch)
	for i := 1; i <= 10; i++ {
		ch <- i
		time.Sleep(time.Second)
	}
}

func multiplexer(channels ...<-chan int) <-chan int { // åˆå¹¶å¤šä¸ªé€šé“æ•°æ®ï¼Œå‡½æ•°è¿”å›æœ€ç»ˆçš„ä¸€ä¸ªåªè¯»é€šé“
	out := make(chan int)
	go func() {
		defer close(out)
		var wg sync.WaitGroup
		for _, ch := range channels {
			wg.Add(1)
			go func(ch <-chan int) {
				defer wg.Done()
				for {
					select {
					case data, ok := <-ch:
						if ok {
							out <- data // æ•°æ®å‘é€åˆ°æœ€ç»ˆçš„åªè¯»é€šé“
						} else {
							return
						}
					}
				}
			}(ch)
		}
		wg.Wait()
	}()

	return out
}

func main() {

	ch1 := make(chan int) // åˆ›å»ºé€šé“ ch1
	ch2 := make(chan int) // åˆ›å»ºé€šé“ ch2
	ch3 := make(chan int) // åˆ›å»ºé€šé“ ch3

	go send(ch1)
	go send(ch2)
	go send(ch3)

	ret_ch := multiplexer(ch1, ch2, ch3) // æ¥æ”¶è¿”å›çš„é€šé“

	for data := range ret_ch { // ä»åªè¯»é€šé“ä¸­è·å–åˆå¹¶åçš„æ•°æ®
		fmt.Printf("ret received: %d\n", data)
	}

	fmt.Println("ret chan closed ...")
}

```

#### è¶…æ—¶æœºåˆ¶

åœ¨
`golang`
ä¸­ï¼Œé€šé“çš„è¶…æ—¶æœºåˆ¶å¯ä»¥é€šè¿‡
`time.After`
æˆ–
`context`
ä¸¤ç§æ–¹å¼æ¥å®ç°ã€‚

##### `time.After`

`time.After`
æ˜¯ä¸€ä¸ªè¿”å›é€šé“çš„å‡½æ•°ï¼Œä¼šåœ¨æŒ‡å®šçš„è¶…æ—¶æ—¶é—´åå‘é€šé“å‘é€ä¸€ä¸ªæ—¶é—´å€¼ã€‚ç»“åˆ
`select...case`
è¯­å¥ï¼Œå¯ä»¥å®ç°è¶…æ—¶é€»è¾‘ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan string) // åˆ›å»ºé€šé“

	go func() {
		time.Sleep(3 * time.Second) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
		ch <- "ä»»åŠ¡å®Œæˆ"
	}()

	select {
	case res := <-ch:
		fmt.Println(res)
	case <-time.After(2 * time.Second): // è®¾ç½®è¶…æ—¶ä¸º2ç§’
		fmt.Println("è¶…æ—¶é€€å‡º") // æœ€ç»ˆæ‰“å° è¶…æ—¶é€€å‡º
	}
}

```

`time.After`
æ˜¯ä¸€ç§éå¸¸ç®€æ´ä¸”æ˜“äºç†è§£çš„è¶…æ—¶æœºåˆ¶ï¼Œç‰¹åˆ«é€‚åˆç®€å•çš„è¶…æ—¶åœºæ™¯ã€‚
**ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ
`time.After`
ä¼šåœ¨åå°å¯åŠ¨ä¸€ä¸ªå®šæ—¶å™¨ï¼Œå³ä½¿
`select`
æå‰é€€å‡ºï¼Œå®šæ—¶å™¨ä¹Ÿä¸ä¼šç«‹åˆ»å›æ”¶ï¼Œå¯èƒ½å¯¼è‡´è½»å¾®çš„èµ„æºæ³„æ¼**
ã€‚

##### `context`

`context`
æ˜¯
`golang`
ä¸­ç”¨äºä¼ é€’å¯å–æ¶ˆä¿¡å·ã€è¶…æ—¶æ—¶é—´ç­‰çš„å·¥å…·ã€‚é€šè¿‡
`context.WithTimeout`
åˆ›å»ºä¸€ä¸ªå¸¦æœ‰è¶…æ—¶åŠŸèƒ½çš„ä¸Šä¸‹æ–‡ï¼Œå…¶
`Done()`
æ–¹æ³•è¿”å›ä¸€ä¸ªé€šé“ï¼Œç”¨äºè¶…æ—¶æ§åˆ¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	ch := make(chan string) // åˆ›å»ºé€šé“
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel() // cancel() ä¼šé‡Šæ”¾ä¸ä¸Šä¸‹æ–‡ç›¸å…³çš„èµ„æºï¼Œé¿å…å†…å­˜æ³„æ¼

	go func() {
		time.Sleep(3 * time.Second) // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
		ch <- "ä»»åŠ¡å®Œæˆ"
	}()

	select {
	case res := <-ch:
		fmt.Println(res)
	case <-ctx.Done(): // ç›‘å¬è¶…æ—¶ä¿¡å·
		fmt.Println("è¶…æ—¶é€€å‡º", ctx.Err())
	}
}

```

åœ¨ä¸Šé¢çš„è¿™ä¸ªä»£ç ä¸­ï¼š

* `context.WithTimeout`
  åˆ›å»ºäº†ä¸€ä¸ªå¸¦æœ‰è¶…æ—¶çš„ä¸Šä¸‹æ–‡ï¼Œå¹¶è®¾ç½®è¶…æ—¶æ—¶é—´ä¸º 2 ç§’ã€‚
* `defer cancel()`
  ç¡®ä¿åœ¨å‡½æ•°è¿”å›æ—¶è°ƒç”¨
  `cancel()`
  ï¼Œé‡Šæ”¾èµ„æºã€‚
* å¦‚æœä»»åŠ¡åœ¨è¶…æ—¶å‰å®Œæˆï¼Œ
  `cancel()`
  ä¼šè¢«è°ƒç”¨ï¼Œç»ˆæ­¢æ‰€æœ‰ç›‘å¬
  `ctx.Done()`
  çš„åç¨‹ã€‚

æ€»çš„æ¥è¯´ï¼Œ
`context`
æ›´é€‚ç”¨äºå¤æ‚çš„å¹¶å‘åœºæ™¯ï¼Œä¾‹å¦‚å¤šä¸ªä»»åŠ¡çš„è¶…æ—¶æ§åˆ¶ã€ä»»åŠ¡å–æ¶ˆç­‰ï¼›
`time.After`
æ›´é€‚ç”¨äºç®€å•çš„è¶…æ—¶æ§åˆ¶ï¼Œä¾‹å¦‚å•ä¸ªä»»åŠ¡çš„è¶…æ—¶ã€‚

#### å…³é—­é€šé“

ä½¿ç”¨
`close`
å‡½æ•°å…³é—­é€šé“ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

func main() {
	ch := make(chan int, 5)
	close(ch) // å…³é—­é€šé“
}

```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“å…³é—­é€šé“åï¼Œä¸èƒ½å†å‘é€šé“å‘é€æ•°æ®ï¼Œä½†å¯ä»¥ç»§ç»­ä»é€šé“ä¸­æ¥æ”¶æ•°æ®ã€‚

#### æ£€æŸ¥é€šé“æ˜¯å¦å…³é—­

æ¥æ”¶æ•°æ®æ—¶ä¼šæœ‰ä¸¤ä¸ªè¿”å›å€¼ï¼Œä¸€ä¸ªæ˜¯æ•°æ®å¦ä¸€ä¸ªæ˜¯å¸ƒå°”å€¼ï¼Œç”¨äºåˆ¤æ–­é€šé“æ˜¯å¦å…³é—­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	ch := make(chan int, 5)
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		for {
			select {
			case data, ok := <-ch: // data è¡¨ç¤ºæ•°æ®ï¼Œok è¡¨ç¤ºé€šé“æ˜¯å¦å…³é—­
				if ok {
					// received: 11
					// received: 10
					// received: 15
					fmt.Println("received:", data)
				} else {
					fmt.Println("ch closed") // ch closed
					return
				}
			}
		}
	}()

	ch <- 11
	ch <- 10
	ch <- 15

	close(ch) // å…³é—­é€šé“
	wg.Wait()
}

```

#### è·å–é€šé“é•¿åº¦

ä½¿ç”¨
`len`
å‡½æ•°è·å–é€šé“çš„å½“å‰é•¿åº¦ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 5)
	fmt.Println(len(ch)) // 0

	ch <- 10
	fmt.Println(len(ch)) // 1

	close(ch) // å…³é—­é€šé“
}

```

#### è·å–é€šé“å®¹é‡

ä½¿ç”¨
`cap`
å‡½æ•°è·å–é€šé“çš„å½“å‰å®¹é‡ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 5)
	fmt.Println(cap(ch)) // 5

	ch1 := make(chan int)
	fmt.Println(cap(ch1)) // 0

	close(ch)  // å…³é—­é€šé“ ch
	close(ch1) // å…³é—­é€šé“ ch1
}


```

### æºç è§£æ

é’ˆå¯¹é€šé“çš„æºä»£ç è¿›è¡Œè§£æï¼Œä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š

* åˆ›å»ºé€šé“
* å‘é€æ•°æ®
* æ¥æ”¶æ•°æ®
* å…³é—­é€šé“

#### é€šé“ç»“æ„ä½“

> æºç ä½ç½®ï¼šsrc/runtime/chan.go

```go
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	timer    *timer // timer feeding this chan
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}

```

* `qcount`
  ï¼šå½“å‰é€šé“ä¸­å­˜å‚¨çš„æ•°æ®æ•°é‡ï¼Œå¯¹äºæ— ç¼“å†²é€šé“ï¼Œ
  `qcount`
  çš„å€¼é€šå¸¸ä¸º 0 æˆ– 1ã€‚
* `dataqsiz`
  ï¼šå¯¹äºç¼“å†²é€šé“ï¼Œ
  `dataqsiz`
  è¡¨ç¤ºç¼“å†²åŒºå¯ä»¥å­˜å‚¨çš„æœ€å¤§å…ƒç´ æ•°é‡ã€‚å¯¹äºæ— ç¼“å†²é€šé“ï¼Œ
  `dataqsiz`
  ä¸º 0ã€‚
* `buf`
  ï¼šæŒ‡å‘ç¼“å†²åŒºçš„æŒ‡é’ˆã€‚ç¼“å†²åŒºæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”¨äºå­˜å‚¨é€šé“ä¸­çš„æ•°æ®ã€‚ä»…å¯¹ç¼“å†²é€šé“æœ‰æ•ˆã€‚æ— ç¼“å†²é€šé“çš„
  `buf`
  ä¸º
  `nil`
  ã€‚
* `elemsize`
  ï¼šé€šé“ä¸­æ¯ä¸ªå…ƒç´ çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚
* `closed`
  ï¼šæ ‡è®°é€šé“æ˜¯å¦å·²å…³é—­ã€‚å…³é—­çš„é€šé“ä¸èƒ½å†æ¬¡å‘é€æ•°æ®ï¼Œä½†å¯ä»¥ç»§ç»­æ¥æ”¶æ•°æ®ç›´åˆ°ç¼“å†²åŒºä¸ºç©ºã€‚
* `timer`
  ï¼šæŒ‡å‘ä¸€ä¸ªå®šæ—¶å™¨ï¼Œè¯¥å®šæ—¶å™¨ä¸é€šé“ç›¸å…³è”ï¼ˆä¾‹å¦‚ï¼Œç”¨äºè¶…æ—¶æ“ä½œï¼‰ã€‚
* `elemtype`
  ï¼šæŒ‡å‘é€šé“ä¸­å…ƒç´ çš„ç±»å‹ä¿¡æ¯ï¼Œç”¨äºåœ¨è¿è¡Œæ—¶æ£€æŸ¥é€šé“ä¸­å­˜å‚¨çš„æ•°æ®ç±»å‹æ˜¯å¦æ­£ç¡®ã€‚
* `sendx`
  ï¼šç”¨äºç®¡ç†ç¼“å†²åŒºçš„ç¯å½¢é˜Ÿåˆ—ï¼Œè®°å½•ä¸‹ä¸€æ¬¡å‘é€æ“ä½œåœ¨ç¼“å†²åŒºä¸­çš„ç´¢å¼•ã€‚
* `recvx`
  ï¼šç”¨äºç®¡ç†ç¼“å†²åŒºçš„ç¯å½¢é˜Ÿåˆ—ï¼Œè®°å½•ä¸‹ä¸€æ¬¡æ¥æ”¶æ“ä½œåœ¨ç¼“å†²åŒºä¸­çš„ç´¢å¼•ã€‚
* `recvq`
  ï¼šå­˜å‚¨ç­‰å¾…æ¥æ”¶çš„åç¨‹é˜Ÿåˆ—ï¼Œåœ¨å‘é€æ“ä½œä¸­ï¼Œå¦‚æœç¼“å†²åŒºå·²æ»¡ä¸”æ²¡æœ‰ç­‰å¾…æ¥æ”¶çš„åç¨‹ï¼Œåˆ™å‘é€åç¨‹ä¼šè¢«åŠ å…¥åˆ°
  `sendq`
  ã€‚
* `sendq`
  ï¼šå­˜å‚¨ç­‰å¾…å‘é€çš„åç¨‹é˜Ÿåˆ—ï¼Œåœ¨æ¥æ”¶æ“ä½œä¸­ï¼Œå¦‚æœç¼“å†²åŒºä¸ºç©ºä¸”æ²¡æœ‰ç­‰å¾…å‘é€çš„åç¨‹ï¼Œåˆ™æ¥æ”¶åç¨‹ä¼šè¢«åŠ å…¥åˆ°
  `recvq`
  ã€‚
* `lock`
  ï¼šä¿æŠ¤
  `hchan`
  ç»“æ„ä½“ä¸­æ‰€æœ‰å­—æ®µçš„äº’æ–¥é”ï¼Œç¡®ä¿é€šé“æ“ä½œçš„çº¿ç¨‹å®‰å…¨æ€§ã€‚åœ¨å‘é€ã€æ¥æ”¶å’Œå…³é—­æ“ä½œä¸­ï¼Œ
  `lock`
  ç”¨äºé˜²æ­¢å¤šä¸ªåç¨‹åŒæ—¶ä¿®æ”¹é€šé“çš„çŠ¶æ€ã€‚

#### åˆ›å»ºé€šé“

åœ¨
`golang`
çš„è¿è¡Œæ—¶ä¸­ï¼Œåˆ›å»ºé€šé“çš„ä»£ç ä¼šè¢«ç¼–è¯‘ä¸ºå¯¹
`makechan`
çš„è°ƒç”¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

func main() {
	ch := make(chan int, 1)
}

```

ç¼–è¯‘æˆæ±‡ç¼–ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
0x001a 00026        CALL    runtime.makechan(SB)

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

`makechan`
å‡½æ•°æ˜¯è¿è¡Œæ—¶ä¸­ç”¨äºåˆ›å»ºé€šé“çš„æ ¸å¿ƒå‡½æ•°ã€‚å®ƒåˆå§‹åŒ–äº†ä¸€ä¸ª
`hchan`
ç»“æ„ä½“ï¼Œå¹¶æ ¹æ®æŒ‡å®šçš„ç±»å‹å’Œç¼“å†²åŒºå¤§å°åˆ†é…å†…å­˜ã€‚

> æºç ä½ç½®ï¼šsrc/runtime/chan.go

##### å‡½æ•°åŸå‹

```go
func makechan(t *chantype, size int) *hchan {
    // ...
}

```

* `t *chantype`
  ï¼šé€šé“çš„ç±»å‹ä¿¡æ¯ï¼ŒåŒ…å«é€šé“ä¸­å…ƒç´ çš„ç±»å‹ã€‚
* `size int`
  ï¼šé€šé“çš„ç¼“å†²åŒºå¤§å°ã€‚å¦‚æœä¸º 0ï¼Œåˆ™åˆ›å»ºæ— ç¼“å†²é€šé“ï¼›å¦‚æœå¤§äº 0ï¼Œåˆ™åˆ›å»ºæœ‰ç¼“å†²é€šé“ã€‚
* è¿”å›ä¸€ä¸ªåˆå§‹åŒ–åçš„
  `hchan`
  ç»“æ„ä½“æŒ‡é’ˆã€‚

##### å‡½æ•°å†…å®¹

```go
func makechan(t *chantype, size int) *hchan {
	elem := t.Elem	// ä»é€šé“ç±»å‹ t ä¸­è·å–é€šé“ä¸­å…ƒç´ çš„ç±»å‹ä¿¡æ¯

	// compiler checks this but be safe.
    // æ£€æŸ¥é€šé“ä¸­å…ƒç´ çš„å¤§å°æ˜¯å¦è¶…è¿‡ 64KBï¼Œå¦‚æœè¶…è¿‡ï¼ŒæŠ›å‡ºå¼‚å¸¸
	if elem.Size_ >= 1<<16 {
		throw("makechan: invalid channel element type")
	}
    
    // ç¡®ä¿ hchan çš„å¤§å°æ˜¯æœ€å¤§å¯¹é½å•ä½çš„å€æ•°ï¼Œå¹¶ä¸”å…ƒç´ çš„å¯¹é½è¦æ±‚ä¸è¶…è¿‡æœ€å¤§å¯¹é½å•ä½
    // maxAlign = 8
	if hchanSize%maxAlign != 0 || elem.Align_ > maxAlign {
		throw("makechan: bad alignment")
	}

    // è®¡ç®—ç¼“å†²åŒºçš„æ€»å¤§å°ï¼šelem.Size_ * size
	mem, overflow := math.MulUintptr(elem.Size_, uintptr(size))
    // æ£€æŸ¥æ˜¯å¦å‘ç”Ÿæº¢å‡ºï¼Œæˆ–è€…ç¼“å†²åŒºå¤§å°è¶…è¿‡æœ€å¤§åˆ†é…é™åˆ¶ï¼Œæˆ–è€…ç¼“å†²åŒºå¤§å°å°äº0ï¼ŒæŠ›å‡ºå¼‚å¸¸
	if overflow || mem > maxAlloc-hchanSize || size < 0 {
		panic(plainError("makechan: size out of range"))
	}

	// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
	// buf points into the same allocation, elemtype is persistent.
	// SudoG's are referenced from their owning thread so they can't be collected.
	// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
    // å†…å­˜åˆ†é…
	var c *hchan
	switch {
	case mem == 0:
        // å¦‚æœç¼“å†²åŒºå¤§å°ä¸º 0ï¼ˆæ— ç¼“å†²é€šé“ï¼‰æˆ–å…ƒç´ å¤§å°ä¸º 0ï¼Œä»…åˆ†é… hchan çš„å†…å­˜
		// Queue or element size is zero.
		c = (*hchan)(mallocgc(hchanSize, nil, true))
		// Race detector uses this location for synchronization.
        // åˆå§‹åŒ–é€šé“çš„ç¼“å†²åŒºçš„æŒ‡é’ˆ
        // buf æŒ‡å‘ hchan ç»“æ„ä½“æœ¬èº«ï¼Œè¡¨ç¤ºæ²¡æœ‰ç‹¬ç«‹çš„ç¼“å†²åŒº
		c.buf = c.raceaddr()
	case !elem.Pointers():
        // å¦‚æœå…ƒç´ ç±»å‹ä¸åŒ…å«æŒ‡é’ˆï¼ˆå¦‚åŸºæœ¬ç±»å‹æˆ–æ•°ç»„ï¼‰ï¼Œå°† hchan å’Œç¼“å†²åŒºåˆ†é…åœ¨åŒä¸€å—å†…å­˜ä¸­
		// Elements do not contain pointers.
		// Allocate hchan and buf in one call.
		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
        // åˆå§‹åŒ–é€šé“çš„ç¼“å†²åŒºçš„æŒ‡é’ˆ
        // å°† c.buf æŒ‡å‘ hchan ç»“æ„ä½“ä¹‹åçš„å†…å­˜åŒºåŸŸï¼Œè¯¥åŒºåŸŸç”¨äºå­˜å‚¨ç¼“å†²åŒºæ•°æ®
		c.buf = add(unsafe.Pointer(c), hchanSize)
	default:
        // å¦‚æœå…ƒç´ ç±»å‹åŒ…å«æŒ‡é’ˆï¼ˆå¦‚ç»“æ„ä½“æˆ–åˆ‡ç‰‡ï¼‰ï¼Œåˆ†åˆ«åˆ†é… hchan å’Œç¼“å†²åŒºçš„å†…å­˜
        // å› ä¸º gc éœ€è¦è·Ÿè¸ªæŒ‡é’ˆç±»å‹çš„å†…å­˜åˆ†é…
		// Elements contain pointers.
		c = new(hchan)
        // åˆå§‹åŒ–é€šé“çš„ç¼“å†²åŒºçš„æŒ‡é’ˆ
		c.buf = mallocgc(mem, elem, true)
	}
	
    // è®¾ç½®é€šé“çš„å…ƒç´ å¤§å°
	c.elemsize = uint16(elem.Size_)
    // è®¾ç½®é€šé“çš„å…ƒç´ ç±»å‹
	c.elemtype = elem
    // è®¾ç½®é€šé“çš„ç¼“å†²åŒºå¤§å°
	c.dataqsiz = uint(size)
    // åˆå§‹åŒ–é€šé“çš„äº’æ–¥é”
	lockInit(&c.lock, lockRankHchan)
	
    // å¦‚æœå¯ç”¨äº†é€šé“è°ƒè¯•æ¨¡å¼ï¼Œæ‰“å°è°ƒè¯•ä¿¡æ¯
	if debugChan {
		print("makechan: chan=", c, "; elemsize=", elem.Size_, "; dataqsiz=", size, "\n")
	}
    
    // è¿”å›é€šé“æŒ‡é’ˆ
	return c
}

```

å…·ä½“åˆ†é…å†…å­˜
`mallocgc`
å‡½æ•°åŸå‹å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
    // ...
}

```

* `size`
  ï¼šåˆ†é…çš„å†…å­˜å¤§å°ã€‚
* `typ`
  ï¼šåˆ†é…å†…å­˜çš„ç±»å‹ä¿¡æ¯ã€‚
* `needzero`
  ï¼šæ˜¯å¦éœ€è¦å°†åˆ†é…çš„å†…å­˜æ¸…é›¶ã€‚

> æ›´å¤šå…³äº
> `mallocgc`
> å‡½æ•°çš„å†…å®¹æœ¬æ–‡ç« ä¸å†èµ˜è¿°ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦è¯·å…³æ³¨åç»­æ–‡ç« ã€Š
> `Golang`
> å†…å­˜æ¨¡å‹ã€‹ã€‚

#### å‘é€æ•°æ®

åœ¨
`golang`
çš„è¿è¡Œæ—¶ä¸­ï¼Œå‘é€æ“ä½œçš„ä»£ç ä¼šè¢«ç¼–è¯‘ä¸ºå¯¹
`chansend1`
çš„è°ƒç”¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

func main() {
	ch := make(chan int, 1)
	ch <- 1
}

```

ç¼–è¯‘æˆæ±‡ç¼–ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
0x001a 00026        CALL    runtime.makechan(SB)
# ...
0x0026 00038        CALL    runtime.chansend1(SB)

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

è€Œåœ¨
`chansend1`
çš„å‡½æ•°å†…éƒ¨ï¼Œåˆæ˜¯å¯¹
`chansend`
çš„è°ƒç”¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/chan.go

```go
// entry point for c <- x from compiled code.
//
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
	chansend(c, elem, true, getcallerpc())
}

```

##### å‡½æ•°åŸå‹

```go
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // ...
}

```

* `c *hchan`
  ï¼šæŒ‡å‘é€šé“çš„æŒ‡é’ˆã€‚
* `ep unsafe.Pointer`
  ï¼šæŒ‡å‘æ•°æ®çš„æŒ‡é’ˆã€‚
* `block bool`
  ï¼šæ˜¯å¦é˜»å¡å‘é€ã€‚
  + å¦‚æœ
    `block == true`
    ï¼Œå‘é€æ“ä½œä¼šåœ¨é€šé“ç¼“å†²åŒºæ»¡æˆ–æ²¡æœ‰æ¥æ”¶æ–¹æ—¶é˜»å¡ï¼Œç›´åˆ°å¯ä»¥å‘é€æ•°æ®ã€‚
  + å¦‚æœ
    `block == false`
    ï¼Œå‘é€æ“ä½œæ˜¯éé˜»å¡çš„ã€‚å¦‚æœå½“å‰æ— æ³•å‘é€æ•°æ®ï¼ˆç¼“å†²åŒºæ»¡æˆ–æ²¡æœ‰æ¥æ”¶æ–¹ï¼‰ï¼Œå‡½æ•°ä¼šç«‹å³è¿”å›
    `false`
    ã€‚
* `callerpc uintptr`
  ï¼šç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰çš„å€¼ï¼Œä¸»è¦ç”¨äºè°ƒè¯•å’Œç«æ€æ£€æµ‹ã€‚
* å‘é€æ“ä½œæ˜¯å¦æˆåŠŸã€‚

##### å‡½æ•°å†…å®¹

```go
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // æ£€æŸ¥é€šé“æŒ‡é’ˆ c æ˜¯å¦ä¸º nil
	if c == nil {
		if !block {
            // å¦‚æœé€šé“ä¸º nil ä¸”æ˜¯éé˜»å¡å‘é€ï¼Œç›´æ¥è¿”å› false
			return false
		}
        // å¦‚æœæ˜¯é˜»å¡å‘é€ï¼Œåˆ™åç¨‹ä¼šé˜»å¡å¹¶æŠ›å‡ºå¼‚å¸¸
		gopark(nil, nil, waitReasonChanSendNilChan, traceBlockForever, 2)
		throw("unreachable")
	}

    // å¦‚æœå¯ç”¨äº†é€šé“è°ƒè¯•æ¨¡å¼ï¼Œæ‰“å°è°ƒè¯•ä¿¡æ¯
	if debugChan {
		print("chansend: chan=", c, "\n")
	}
	
    // å¦‚æœå¯ç”¨äº†ç«æ€æ£€æµ‹å™¨ï¼Œè®°å½•å¯¹é€šé“çš„è¯»æ“ä½œ
	if raceenabled {
		racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))
	}

	// Fast path: check for failed non-blocking operation without acquiring the lock.
	//
	// After observing that the channel is not closed, we observe that the channel is
	// not ready for sending. Each of these observations is a single word-sized read
	// (first c.closed and second full()).
	// Because a closed channel cannot transition from 'ready for sending' to
	// 'not ready for sending', even if the channel is closed between the two observations,
	// they imply a moment between the two when the channel was both not yet closed
	// and not ready for sending. We behave as if we observed the channel at that moment,
	// and report that the send cannot proceed.
	//
	// It is okay if the reads are reordered here: if we observe that the channel is not
	// ready for sending and then observe that it is not closed, that implies that the
	// channel wasn't closed during the first observation. However, nothing here
	// guarantees forward progress. We rely on the side effects of lock release in
	// chanrecv() and closechan() to update this thread's view of c.closed and full().
    
    // å¦‚æœæ˜¯éé˜»å¡å‘é€å¹¶ä¸”é€šé“æœªå…³é—­ä½†ç¼“å†²åŒºå·²æ»¡ï¼Œç›´æ¥è¿”å› false
    // å‰ç½®åˆ¤æ–­ï¼Œé¿å…è¿›å…¥é”çš„å¼€é”€
	if !block && c.closed == 0 && full(c) {
		return false
	}
	
    // å¦‚æœå¯ç”¨äº†é˜»å¡å‰–æï¼Œè®°å½•å½“å‰æ—¶é—´æˆ³
	var t0 int64
	if blockprofilerate > 0 {
		t0 = cputicks()
	}
	
    // é”å®šé€šé“çš„äº’æ–¥é”ï¼Œç¡®ä¿æ“ä½œçš„åŸå­æ€§
	lock(&c.lock)
	
    // å¦‚æœé€šé“å·²å…³é—­ï¼Œè§£é”å¹¶æŠ›å‡ºå¼‚å¸¸
    // é˜…è¯»åˆ°æ­¤å¤„æ—¶ï¼Œè€ƒè™‘æ˜¯å¦æ”¹ä¸ºä½¿ç”¨åŸå­æ“ä½œï¼Œä»£æ›¿ lock/unlockï¼Ÿ
    // å¯ï¼Ÿä¸å¯ï¼Ÿ
    // è®°å½•å§ï¼ï¼ï¼
	if c.closed != 0 {
		unlock(&c.lock)
		panic(plainError("send on closed channel"))
	}
	
    // å¦‚æœæœ‰ç­‰å¾…æ¥æ”¶çš„åç¨‹ï¼Œç›´æ¥å°†æ•°æ®å‘é€ç»™æ¥æ”¶åç¨‹ï¼Œè·³è¿‡ç¼“å†²åŒº
	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
        // è°ƒç”¨ send å‡½æ•°å®Œæˆæ•°æ®ä¼ é€’ï¼Œå¹¶è§£é”
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true
	}

    // å¦‚æœæ²¡æœ‰ç­‰å¾…æ¥æ”¶çš„åç¨‹ï¼Œåˆ™åˆ¤æ–­ç¼“å†²åŒºæ˜¯å¦æœ‰ç©ºé—´
	if c.qcount < c.dataqsiz {
		// Space is available in the channel buffer. Enqueue the element to send.
        // è®¡ç®—ç¼“å†²åŒºä¸­ä¸‹ä¸€ä¸ªå†™å…¥ä½ç½®çš„æŒ‡é’ˆ
		qp := chanbuf(c, c.sendx)
		if raceenabled {
            // é€šçŸ¥ç«æ€æ£€æµ‹å™¨å½“å‰æ“ä½œçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¯¹ç¼“å†²åŒºçš„å†™å…¥æ“ä½œè¢«æ­£ç¡®è·Ÿè¸ª
			racenotify(c, c.sendx, nil)
		}
        
        // å°†è¦å‘é€çš„æ•°æ®ä» ep å¤åˆ¶åˆ°ç¼“å†²åŒºçš„ qp ä½ç½®
		typedmemmove(c.elemtype, qp, ep)
        // æ›´æ–°å‘é€ç´¢å¼•ä¸ºä¸‹ä¸€ä¸ªå†™å…¥ä½ç½®
		c.sendx++
        // å¦‚æœ c.sendx è¾¾åˆ°ç¼“å†²åŒºå¤§å°ï¼Œåˆ™å°†å…¶é‡ç½®ä¸º 0ï¼Œå®ç°ç¯å½¢ç¼“å†²åŒºçš„æ•ˆæœ
		if c.sendx == c.dataqsiz {
			c.sendx = 0
		}
        // æ¯æ¬¡æˆåŠŸå†™å…¥æ•°æ®åï¼Œc.qcount å¢åŠ  1
		c.qcount++
        // è§£é”é€šé“çš„äº’æ–¥é”
		unlock(&c.lock)
        // å†™å…¥æˆåŠŸï¼Œè¿”å› true
		return true
	}
	
    // å¦‚æœç¼“å†²åŒºå·²æ»¡ä¸”æ˜¯éé˜»å¡å‘é€ï¼Œè§£é”å¹¶è¿”å› false
	if !block {
		unlock(&c.lock)
		return false
	}
    
    // ä¸‹é¢æ˜¯é˜»å¡å‘é€çš„ä»£ç é€»è¾‘

	// Block on the channel. Some receiver will complete our operation for us.
    // è·å–å½“å‰æ­£åœ¨è¿è¡Œçš„åç¨‹çš„æŒ‡é’ˆ
	gp := getg()
    // åˆ†é…ä¸€ä¸ª sudog å¯¹è±¡ï¼Œsudog æ˜¯ golang è¿è¡Œæ—¶ä¸­ç”¨äºè¡¨ç¤ºåç¨‹åœ¨é€šé“æ“ä½œä¸­ç­‰å¾…çš„ç»“æ„ä½“
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
    // ä¸‹é¢è¿™äº›æ˜¯åˆå§‹åŒ– sudog å¯¹è±¡å±æ€§
	mysg.elem = ep	// æŒ‡å‘è¦å‘é€çš„æ•°æ®æŒ‡é’ˆ
	mysg.waitlink = nil
	mysg.g = gp	// æŒ‡å‘å½“å‰åç¨‹
	mysg.isSelect = false	// æ ‡è®°æ˜¯å¦æ˜¯ select æ“ä½œ
	mysg.c = c	// æŒ‡å‘å½“å‰é€šé“
	gp.waiting = mysg	// å°†å½“å‰åç¨‹çš„ sudog å¯¹è±¡è®¾ç½®ä¸ºç­‰å¾…çŠ¶æ€
	gp.param = nil
    
    // å°† sudog å¯¹è±¡åŠ å…¥é€šé“çš„å‘é€ç­‰å¾…é˜Ÿåˆ—
	c.sendq.enqueue(mysg)
	// Signal to anyone trying to shrink our stack that we're about
	// to park on a channel. The window between when this G's status
	// changes and when we set gp.activeStackChans is not safe for
	// stack shrinking.
    // æ ‡è®°å½“å‰åç¨‹å³å°†é˜»å¡åœ¨é€šé“æ“ä½œ
	gp.parkingOnChan.Store(true)
    // é˜»å¡å½“å‰åç¨‹ï¼Œç›´åˆ°è¢«æ¥æ”¶æ“ä½œå”¤é†’
	gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceBlockChanSend, 2)
	// Ensure the value being sent is kept alive until the
	// receiver copies it out. The sudog has a pointer to the
	// stack object, but sudogs aren't considered as roots of the
	// stack tracer.
    // ç¡®ä¿å‘é€çš„æ•°æ®åœ¨æ¥æ”¶åç¨‹æ‹·è´ä¹‹å‰ä¸ä¼šè¢«å›æ”¶ï¼Œå› ä¸º ep æŒ‡å‘çš„æ•°æ®æœ‰å¯èƒ½æ˜¯æ ˆä¸Šçš„æ•°æ®
    // è€Œæ ˆä¸Šçš„æ•°æ®å¯èƒ½åœ¨åç¨‹é˜»å¡åè¢«å›æ”¶
	KeepAlive(ep)
    
    // ä¸‹é¢æ˜¯åç¨‹è¢«å”¤é†’åçš„å¤„ç†ä»£ç 

	// someone woke us up.
	if mysg != gp.waiting {
		throw("G waiting list is corrupted")
	}
    // æ¸…ç©ºåç¨‹çš„ç­‰å¾…çŠ¶æ€
	gp.waiting = nil	
    // æ ‡è®°åç¨‹ä¸å†é˜»å¡åœ¨é€šé“æ“ä½œä¸Š
	gp.activeStackChans = false
    // å‘é€æ“ä½œæ˜¯å¦æˆåŠŸï¼Œmysg.success è¡¨ç¤º true æˆåŠŸï¼Œfalse å¤±è´¥
	closed := !mysg.success
	gp.param = nil
	if mysg.releasetime > 0 {
        // è®°å½•åç¨‹é˜»å¡çš„æ—¶é—´
		blockevent(mysg.releasetime-t0, 2)
	}
    // æ¸…ç©º sudog å¯¹è±¡çš„é€šé“æŒ‡é’ˆ
	mysg.c = nil
	releaseSudog(mysg)
	if closed {
        // å¦‚æœé€šé“æœªå…³é—­ä½†åç¨‹è¢«å”¤é†’ï¼ŒæŠ›å‡ºå¼‚å¸¸
		if c.closed == 0 {
			throw("chansend: spurious wakeup")
		}
        // é€šé“åœ¨å‘é€æ“ä½œå®Œæˆå‰è¢«å…³é—­ï¼ŒæŠ¥é”™ ï¼ï¼ï¼
        // è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆè¯´å‘ä¸€ä¸ªå·²ç»å…³é—­é€šé“å†™æ•°æ®ä¼šæŠ¥é”™ï¼ŒåŸå› å°±åœ¨è¿™é‡Œ
		panic(plainError("send on closed channel"))
	}
    // å‘é€æ“ä½œæˆåŠŸå®Œæˆ
	return true
}

```

`send`
å‡½æ•°çš„ä½œç”¨æ˜¯å°†æ•°æ®ç›´æ¥å‘é€ç»™ç­‰å¾…æ¥æ”¶çš„åç¨‹ï¼Œå¹¶å”¤é†’ç­‰å¾…æ¥æ”¶çš„åç¨‹ã€‚

```go
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    // ç«æ€æ£€æµ‹
	if raceenabled {
        // æ— ç¼“å†²é€šé“
		if c.dataqsiz == 0 {
            // é€šçŸ¥ç«æ€æ£€æµ‹å™¨å½“å‰æ“ä½œçš„ä¸Šä¸‹æ–‡
			racesync(c, sg)
		} else {
            // æœ‰ç¼“å†²é€šé“
			// Pretend we go through the buffer, even though
			// we copy directly. Note that we need to increment
			// the head/tail locations only when raceenabled.
            // å³ä½¿æ•°æ®æ˜¯ç›´æ¥å‘é€çš„ï¼Œç«æ€æ£€æµ‹å™¨ä¹Ÿä¼šæ¨¡æ‹Ÿæ•°æ®é€šè¿‡ç¼“å†²åŒºçš„æµç¨‹
			// è°ƒç”¨ racenotifyï¼Œè®°å½•æ¥æ”¶ç´¢å¼•ï¼ˆc.recvxï¼‰çš„å˜åŒ–ã€‚
			racenotify(c, c.recvx, nil)
			racenotify(c, c.recvx, sg)
            // æ›´æ–°æ¥æ”¶ç´¢å¼• c.recvx å’Œå‘é€ç´¢å¼• c.sendxï¼Œæ¨¡æ‹Ÿç¯å½¢ç¼“å†²åŒºçš„è¡Œä¸º
			c.recvx++
			if c.recvx == c.dataqsiz {
				c.recvx = 0
			}
			c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
		}
	}
    
    // å¦‚æœ sg.elem ä¸ä¸º nilï¼Œè°ƒç”¨ sendDirect å°†æ•°æ®ä»å‘é€æ–¹ ep ç›´æ¥å‘é€åˆ°æ¥æ”¶æ–¹ sg.elem
	if sg.elem != nil {
		sendDirect(c.elemtype, sg, ep)
        // æ¸…ç©º sg.elemï¼Œè¡¨ç¤ºæ•°æ®å·²å‘é€
		sg.elem = nil
	}
    // è·å–ç­‰å¾…æ¥æ”¶çš„åç¨‹
	gp := sg.g
    // è°ƒç”¨è§£é”å‡½æ•°ï¼Œé‡Šæ”¾é€šé“çš„é”
	unlockf()
    // å°† sudog å¯¹è±¡ä¼ é€’ç»™æ¥æ”¶åç¨‹ï¼Œç”¨äºåç»­å¤„ç†
	gp.param = unsafe.Pointer(sg)
    // æ ‡è®°å‘é€æ“ä½œæˆåŠŸ
	sg.success = true
	if sg.releasetime != 0 {
		sg.releasetime = cputicks()
	}
    // å°† gp åç¨‹æ ‡è®°ä¸ºå¯è¿è¡ŒçŠ¶æ€ï¼Œå¹¶å°†å…¶åŠ å…¥è°ƒåº¦é˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œ
	goready(gp, skip+1)
}

```

`sendDirect`
å‡½æ•°çš„ä½œç”¨æ˜¯å°†æ•°æ®ç›´æ¥ä»å‘é€æ–¹çš„å†…å­˜ä½ç½®å‘é€åˆ°ç­‰å¾…æ¥æ”¶çš„åç¨‹
`sudog`
å¯¹è±¡ ã€‚

```go
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
	// src is on our stack, dst is a slot on another stack.

	// Once we read sg.elem out of sg, it will no longer
	// be updated if the destination's stack gets copied (shrunk).
	// So make sure that no preemption points can happen between read & use.
    // è·å–æ¥æ”¶æ–¹çš„å†…å­˜ä½ç½®ï¼Œä»¥ä¾¿å°†æ•°æ®ç›´æ¥å‘é€åˆ°è¯¥ä½ç½®
	dst := sg.elem
    // è§¦å‘å†™å±éšœ
    // ç¡®ä¿åƒåœ¾å›æ”¶å™¨èƒ½å¤Ÿæ­£ç¡®è¿½è¸ªç›®æ ‡å†…å­˜åŒºåŸŸä¸­çš„æŒ‡é’ˆ
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.Size_)
	// No need for cgo write barrier checks because dst is always
	// Go memory.
    // è¿™æ˜¯ä¸€ä¸ªåº•å±‚å‡½æ•°ï¼Œç”¨äºåœ¨å†…å­˜ä¸­å®‰å…¨åœ°ç§»åŠ¨æ•°æ®
    // dst ç›®æ ‡åœ°å€ï¼Œsrc æºåœ°å€
	memmove(dst, src, t.Size_)
}

```

> å…³äºæ›´å¤šå†…å­˜ç®¡ç†çš„çŸ¥è¯†ç‚¹ï¼Œè¯·å…³æ³¨åç»­æ–‡ç« ã€Š
> `Golang`
> å†…å­˜æ¨¡å‹ã€‹ã€‚

#### æ¥æ”¶æ•°æ®

åœ¨
`golang`
çš„è¿è¡Œæ—¶ä¸­ï¼Œæ¥æ”¶æ•°æ®æ“ä½œçš„ä»£ç ä¼šè¢«ç¼–è¯‘ä¸ºå¯¹
`chanrecv1`
çš„è°ƒç”¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 1)
	ch <- 1

	data := <-ch
	fmt.Println(data)
}

```

ç¼–è¯‘æˆæ±‡ç¼–ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
0x001a 00026        CALL    runtime.makechan(SB)
# ...
0x0043 00067        CALL    runtime.chanrecv1(SB)

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

è€Œåœ¨
`chanrecv1`
çš„å‡½æ•°å†…éƒ¨ï¼Œåˆæ˜¯å¯¹
`chanrecv`
çš„è°ƒç”¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

> æºç ä½ç½®ï¼šsrc/runtime/chan.go

```go
// entry points for <- c from compiled code.
//
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
	chanrecv(c, elem, true)
}

```

##### å‡½æ•°åŸå‹

```go
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    // ...
}

```

* `c *hchan`
  ï¼šæŒ‡å‘ç›®æ ‡é€šé“çš„æŒ‡é’ˆã€‚
* `ep unsafe.Pointer`
  ï¼šæŒ‡å‘æ¥æ”¶æ•°æ®çš„å†…å­˜ä½ç½®ã€‚å¦‚æœä¸º
  `nil`
  ï¼Œè¡¨ç¤ºä»…æ£€æŸ¥é€šé“çŠ¶æ€è€Œä¸æ¥æ”¶æ•°æ®ã€‚
* `block bool`
  ï¼šæ˜¯å¦å…è®¸é˜»å¡æ¥æ”¶ã€‚å¦‚æœä¸º
  `false`
  ï¼Œåˆ™åœ¨æ— æ³•ç«‹å³æ¥æ”¶æ•°æ®æ—¶è¿”å›ã€‚
* `selected bool`
  ï¼šè¡¨ç¤ºæ˜¯å¦æˆåŠŸæ¥æ”¶æ•°æ®ã€‚åœ¨
  `select`
  è¯­å¥ä¸­ï¼Œç”¨äºæ ‡è®°æ˜¯å¦é€‰æ‹©äº†å½“å‰é€šé“ã€‚
* `received bool`
  ï¼šè¡¨ç¤ºæ˜¯å¦å®é™…æ¥æ”¶åˆ°æ•°æ®ã€‚å¦‚æœé€šé“å…³é—­ä¸”ç¼“å†²åŒºä¸ºç©ºï¼Œ
  `received`
  ä¸º
  `false`
  ã€‚

##### å‡½æ•°å†…å®¹

```go
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
	// raceenabled: don't need to check ep, as it is always on the stack
	// or is new memory allocated by reflect.
	// å¦‚æœå¯ç”¨äº†é€šé“è°ƒè¯•æ¨¡å¼ï¼Œæ‰“å°è°ƒè¯•ä¿¡æ¯
	if debugChan {
		print("chanrecv: chan=", c, "\n")
	}
	// å¦‚æœé€šé“ä¸º nil
	if c == nil {
		if !block {
            // éé˜»å¡æ¥æ”¶ï¼Œç›´æ¥è¿”å›
			return
		}
        // å¦‚æœæ˜¯é˜»å¡æ¥æ”¶ï¼Œåç¨‹ä¼šé˜»å¡å¹¶æŠ›å‡ºå¼‚å¸¸
		gopark(nil, nil, waitReasonChanReceiveNilChan, traceBlockForever, 2)
		throw("unreachable")
	}
	
    // å¦‚æœé€šé“å…³è”äº†ä¸€ä¸ªå®šæ—¶å™¨,åˆ™è°ƒç”¨ maybeRunChan æ¥å¤„ç†å®šæ—¶å™¨äº‹ä»¶
	if c.timer != nil {
		c.timer.maybeRunChan()
	}
	
    // å¦‚æœæ˜¯éé˜»å¡æ¥æ”¶ä¸”é€šé“ä¸ºç©º
	// Fast path: check for failed non-blocking operation without acquiring the lock.
	if !block && empty(c) {
		// After observing that the channel is not ready for receiving, we observe whether the
		// channel is closed.
		//
		// Reordering of these checks could lead to incorrect behavior when racing with a close.
		// For example, if the channel was open and not empty, was closed, and then drained,
		// reordered reads could incorrectly indicate "open and empty". To prevent reordering,
		// we use atomic loads for both checks, and rely on emptying and closing to happen in
		// separate critical sections under the same lock.  This assumption fails when closing
		// an unbuffered channel with a blocked send, but that is an error condition anyway.
        // æ£€æŸ¥é€šé“æ˜¯å¦å…³é—­
		if atomic.Load(&c.closed) == 0 {
			// Because a channel cannot be reopened, the later observation of the channel
			// being not closed implies that it was also not closed at the moment of the
			// first observation. We behave as if we observed the channel at that moment
			// and report that the receive cannot proceed.
            // å¦‚æœé€šé“æœªå…³é—­ï¼Œç›´æ¥è¿”å›
			return
		}
		// The channel is irreversibly closed. Re-check whether the channel has any pending data
		// to receive, which could have arrived between the empty and closed checks above.
		// Sequential consistency is also required here, when racing with such a send.
        // å¦‚æœé€šé“å·²å…³é—­å¹¶ä¸”ä¸ºéé˜»å¡å¹¶ä¸”ç¼“å†²åŒºä¸ºç©º
		if empty(c) {
			// The channel is irreversibly closed and empty.
			if raceenabled {
				raceacquire(c.raceaddr())
			}
            // ep ä¸æ˜¯ç©ºï¼Œåˆ™æ¸…ç©ºç›®æ ‡å†…å­˜ ep
			if ep != nil {
				typedmemclr(c.elemtype, ep)
			}
            
            // è¿”å›æˆåŠŸæ¥æ”¶æ•°æ®(true)ï¼Œæœªå®é™…æ¥æ”¶åˆ°æ•°æ®(false)
			return true, false
		}
	}

	var t0 int64
	if blockprofilerate > 0 {
		t0 = cputicks()
	}
	
    // é”å®šé€šé“çš„äº’æ–¥é”ï¼Œç¡®ä¿æ“ä½œçš„åŸå­æ€§
	lock(&c.lock)

    // å¦‚æœé€šé“å·²å…³é—­
	if c.closed != 0 {
        // ç¼“å†²åŒºä¸ºç©º
		if c.qcount == 0 {
			if raceenabled {
				raceacquire(c.raceaddr())
			}
            // è¿™é‡Œæ˜¯é€šé“å·²ç»å…³é—­äº†ï¼Œè€Œä¸”ç¼“å†²åŒºå·²ç»ä¸ºç©º
            // è€ƒè™‘æ˜¯å¦å¯ä»¥é‡‡ç”¨åŸå­æ“ä½œæ¥ä»£æ›¿è¿™é‡Œçš„ lock/unlock æ“ä½œçš„æ“ä½œï¼Ÿ
            // ...
            // å’Œé€šé“å…³é—­æ—¶ï¼Œå‘é€è€…çš„æ£€æµ‹åŒç†
           	// è™½ç„¶ç†è®ºä¸Šå¯ä»¥é€šè¿‡åŸå­æ“ä½œæ¥é¿å…åŠ é”ï¼Œä½†åœ¨å®é™…å®ç°ä¸­ï¼Œé”çš„ä½¿ç”¨æ˜¯ä¸ºäº†ç¡®ä¿çº¿ç¨‹å®‰å…¨å’Œä¸€è‡´æ€§ï¼Œå¦å¤–ï¼Œè™½ç„¶åŸå­æ“ä½œé¿å…äº†é”çš„å¼€é”€ï¼Œä½†å®ƒä»¬ä»ç„¶æœ‰ä¸€å®šçš„æ€§èƒ½å¼€é”€
            // å³ä½¿ä½¿ç”¨åŸå­æ“ä½œï¼Œä¹Ÿéœ€è¦ç¡®ä¿åœ¨æ£€æŸ¥ c.closed å’Œ c.qcount æ—¶ä¸ä¼šå‡ºç°ç«æ€æ¡ä»¶ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªåç¨‹åœ¨æ£€æŸ¥ c.closed åä¿®æ”¹äº† c.qcountï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸ä¸€è‡´çš„è¡Œä¸º
            // è®°å½•å§ï¼ï¼ï¼
         	// è§£é”
			unlock(&c.lock)
            // æ¸…ç©ºç›®æ ‡å†…å­˜ ep
			if ep != nil {
				typedmemclr(c.elemtype, ep)
			}
            // è¿”å›æˆåŠŸæ¥æ”¶æ•°æ®(true)ï¼Œæœªå®é™…æ¥æ”¶åˆ°æ•°æ®(false)
			return true, false
		}
		// The channel has been closed, but the channel's buffer have data.
	} else {
        // é€šé“æœªå…³é—­ï¼Œå¹¶ä¸”æœ‰ç­‰å¾…å‘é€çš„åç¨‹
		// Just found waiting sender with not closed.
		if sg := c.sendq.dequeue(); sg != nil {
			// Found a waiting sender. If buffer is size 0, receive value
			// directly from sender. Otherwise, receive from head of queue
			// and add sender's value to the tail of the queue (both map to
			// the same buffer slot because the queue is full).
            // è°ƒç”¨ recv å‡½æ•°ç›´æ¥ä»å‘é€åç¨‹æ¥æ”¶æ•°æ®ï¼Œè·³è¿‡ç¼“å†²åŒº
            // è§£é”é€šé“
			recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
            // è¿”å›æˆåŠŸæ¥æ”¶æ•°æ®(true)ï¼Œå®é™…æ¥æ”¶åˆ°æ•°æ®(true)
			return true, true
		}
	}
	
    // å¦‚æœç¼“å†²åŒºä¸­æœ‰æ•°æ®
	if c.qcount > 0 {
		// Receive directly from queue
        // å¾—åˆ°ç¼“å†²åŒºåœ°å€
		qp := chanbuf(c, c.recvx)
		if raceenabled {
			racenotify(c, c.recvx, nil)
		}
        // ä»ç¼“å†²åŒºä¸­è¯»å–æ•°æ®åˆ°ç›®æ ‡å†…å­˜
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)
		}
        // æ¸…ç©ºç¼“å†²åŒºä¸­çš„æ•°æ®
		typedmemclr(c.elemtype, qp)
        // æ›´æ–°æ¥æ”¶ç´¢å¼• c.recvx
		c.recvx++
        // å¦‚æœæ¥æ”¶ç´¢å¼• == ç¼“å†²åŒºå¤§å°ï¼Œåˆ™ä» 0 é‡æ–°å¼€å§‹
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
        // æ›´æ–°ç¼“å†²åŒºè®¡æ•° c.qcount
		c.qcount--
        // è§£é”
		unlock(&c.lock)
        // è¿”å›æˆåŠŸæ¥æ”¶æ•°æ®(true)ï¼Œå®é™…æ¥æ”¶åˆ°æ•°æ®(true)
		return true, true
	}

    // å¦‚æœæ˜¯éé˜»å¡æ¥æ”¶ä¸”ç¼“å†²åŒºä¸ºç©ºï¼Œè§£é”é€šé“å¹¶è¿”å›æœªæˆåŠŸæ¥æ”¶æ•°æ®(false)ï¼Œæœªå®é™…æ¥æ”¶åˆ°æ•°æ®(false)
	if !block {
		unlock(&c.lock)
		return false, false
	}
    
    // ä¸‹é¢æ˜¯è¿›è¡Œé˜»å¡æ¥æ”¶æ•°æ®ä»£ç é€»è¾‘

	// no sender available: block on this channel.
    // è·å–å½“å‰åç¨‹
	gp := getg()
    // åˆ†é…ä¸€ä¸ª sudog å¯¹è±¡
	mysg := acquireSudog()
    // ä¸‹é¢æ˜¯é’ˆå¯¹ mysg å¯¹è±¡å±æ€§çš„åˆå§‹åŒ–
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
	mysg.elem = ep
	mysg.waitlink = nil
	gp.waiting = mysg

	mysg.g = gp
	mysg.isSelect = false
	mysg.c = c
	gp.param = nil
    // å°†åç¨‹åŠ å…¥æ¥æ”¶ç­‰å¾…é˜Ÿåˆ—
	c.recvq.enqueue(mysg)
    // å¦‚æœé€šé“å…³è”äº†å®šæ—¶å™¨ï¼Œè°ƒç”¨ blockTimerChan
	if c.timer != nil {
		blockTimerChan(c)
	}

	// Signal to anyone trying to shrink our stack that we're about
	// to park on a channel. The window between when this G's status
	// changes and when we set gp.activeStackChans is not safe for
	// stack shrinking.
    // æ ‡è®°åç¨‹å³å°†é˜»å¡åœ¨é€šé“æ“ä½œä¸Š
	gp.parkingOnChan.Store(true)
    // è°ƒç”¨ gopark é˜»å¡å½“å‰åç¨‹ï¼Œç›´åˆ°è¢«å‘é€æ“ä½œå”¤é†’
	gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanReceive, traceBlockChanRecv, 2)

    // ä¸‹é¢æ˜¯åç¨‹è¢«å”¤é†’ä¹‹åçš„æ“ä½œæµç¨‹
    
	// someone woke us up
    // æ£€æŸ¥åç¨‹æ˜¯å¦è¢«æ­£ç¡®å”¤é†’
	if mysg != gp.waiting {
		throw("G waiting list is corrupted")
	}
    // å¦‚æœé€šé“å…³è”äº†å®šæ—¶å™¨ï¼Œè°ƒç”¨ unblockTimerChan
	if c.timer != nil {
		unblockTimerChan(c)
	}
    // æ¸…ç†åç¨‹çŠ¶æ€
	gp.waiting = nil
	gp.activeStackChans = false
	if mysg.releasetime > 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
    // è·å–æ¥æ”¶æ“ä½œçš„ç»“æœ
	success := mysg.success
	gp.param = nil
    // é‡Šæ”¾ sudog å¯¹è±¡
	mysg.c = nil
	releaseSudog(mysg)
    // è¿”å›æ¥æ”¶æ“ä½œç»“æœ
	return true, success
}

```

`recv`
å‡½æ•°ç”¨äºä»é€šé“ä¸­è¯»å–æ•°æ®ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™ç­‰å¾…æ¥æ”¶çš„åç¨‹ã€‚

```go
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    // å¦‚æœé€šé“æ— ç¼“å†²åŒº
	if c.dataqsiz == 0 {
		if raceenabled {
			racesync(c, sg)
		}
        // å¹¶ä¸”ç›®æ ‡å†…å­˜ä½ç½®ä¸æ˜¯ nilï¼Œ åˆ™ç›´æ¥æ‹·è´åˆ°ç›®æ ‡ä½ç½®
		if ep != nil {
			// copy data from sender
			recvDirect(c.elemtype, sg, ep)
		}
	} else {
        // é€šé“æœ‰ç¼“å†²åŒº
		// Queue is full. Take the item at the
		// head of the queue. Make the sender enqueue
		// its item at the tail of the queue. Since the
		// queue is full, those are both the same slot.
        // è®¡ç®—ç¼“å†²åŒºä¸­æ¥æ”¶ä½ç½®çš„æŒ‡é’ˆ
		qp := chanbuf(c, c.recvx)
		if raceenabled {
			racenotify(c, c.recvx, nil)
			racenotify(c, c.recvx, sg)
		}
		// copy data from queue to receiver
		if ep != nil {
            // å¦‚æœç›®æ ‡å†…å­˜ä½ç½®ä¸æ˜¯ nilï¼Œ å°†æ•°æ®ä»ç¼“å†²åŒºå¤åˆ¶åˆ°æ¥æ”¶æ–¹çš„å†…å­˜ä½ç½®
			typedmemmove(c.elemtype, ep, qp)
		}
		// copy data from sender to queue
        // å°†å‘é€æ–¹çš„æ•°æ®å¤åˆ¶åˆ°ç¼“å†²åŒºçš„å°¾éƒ¨
		typedmemmove(c.elemtype, qp, sg.elem)
        // å¢åŠ æ¥æ”¶ç´¢å¼•å¹¶å¤„ç†ç¯å½¢ç¼“å†²åŒºçš„è¾¹ç•Œæ¡ä»¶
		c.recvx++
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
        // æ›´æ–°å‘é€ç´¢å¼•ï¼Œä½¿å…¶æŒ‡å‘ä¸‹ä¸€ä¸ªå¯ç”¨ä½ç½®
		c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
	}
    
    // æ¸…ç©º sudog å¯¹è±¡ä¸­çš„æ•°æ®æŒ‡é’ˆ
	sg.elem = nil
    // è·å–å‘é€åç¨‹çš„æŒ‡é’ˆ
	gp := sg.g
    // è°ƒç”¨è§£é”å‡½æ•°ï¼Œé‡Šæ”¾é€šé“çš„é”
	unlockf()
	gp.param = unsafe.Pointer(sg)
    // æ ‡è®°æ¥æ”¶æ“ä½œæˆåŠŸ
	sg.success = true
	if sg.releasetime != 0 {
		sg.releasetime = cputicks()
	}
    // å°† gp åç¨‹æ ‡è®°ä¸ºå¯è¿è¡ŒçŠ¶æ€ï¼Œå¹¶å°†å…¶åŠ å…¥è°ƒåº¦é˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œ
	goready(gp, skip+1)
}

```

`recvDirect`
å‡½æ•°çš„ä½œç”¨æ˜¯ä»å‘é€æ–¹ç›´æ¥æ¥æ”¶æ•°æ®ï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°æ¥æ”¶æ–¹çš„ç›®æ ‡å†…å­˜ä½ç½®ã€‚

```go
func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
	// dst is on our stack or the heap, src is on another stack.
	// The channel is locked, so src will not move during this
	// operation.
    // æŒ‡å‘å‘é€æ–¹çš„å†…å­˜ä½ç½®
	src := sg.elem
    // å†™å±éšœ
    // ç¡®ä¿ç›®æ ‡å†…å­˜ä½ç½®ä¸­çš„æŒ‡é’ˆè¢«åƒåœ¾å›æ”¶å™¨æ­£ç¡®è¿½è¸ª
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.Size_)
    // å°†æ•°æ®ä»å‘é€æ–¹çš„å†…å­˜ä½ç½®å¤åˆ¶åˆ°æ¥æ”¶æ–¹çš„å†…å­˜ä½ç½®
	memmove(dst, src, t.Size_)
}

```

> å…³äºæ›´å¤šå†…å­˜ç®¡ç†çš„çŸ¥è¯†ç‚¹ï¼Œè¯·å…³æ³¨åç»­æ–‡ç« ã€Š
> `Golang`
> å†…å­˜æ¨¡å‹ã€‹ã€‚

#### å…³é—­é€šé“

åœ¨
`golang`
çš„è¿è¡Œæ—¶ä¸­ï¼Œå…³é—­é€šé“æ“ä½œçš„ä»£ç ä¼šè¢«ç¼–è¯‘ä¸ºå¯¹
`closechan`
çš„è°ƒç”¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 1)
	close(ch)
}

```

ç¼–è¯‘æˆæ±‡ç¼–ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š

```assembly
0x001a 00026        CALL    runtime.makechan(SB)
# ...
0x0020 00032        CALL    runtime.closechan(SB)

```

> ä»¥ä¸Šæ±‡ç¼–ä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

##### å‡½æ•°åŸå‹

> æºç ä½ç½®ï¼šsrc/runtime/chan.go

```go
func closechan(c *hchan) {
    // ...
}

```

* `c *hchan`
  ï¼šæŒ‡å‘è¦å…³é—­çš„é€šé“çš„æŒ‡é’ˆã€‚

##### å‡½æ•°å†…å®¹

```go
func closechan(c *hchan) {
    // å¦‚æœé€šé“ä¸º nilï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸
	if c == nil {
		panic(plainError("close of nil channel"))
	}
	
    // é”å®šé€šé“çš„äº’æ–¥é”ï¼Œç¡®ä¿å…³é—­æ“ä½œçš„åŸå­æ€§
	lock(&c.lock)
	if c.closed != 0 {
        // å¦‚æœé€šé“å·²ç»å…³é—­ï¼Œè§£é”ï¼ŒæŠ›å‡ºå¼‚å¸¸
		unlock(&c.lock)
		panic(plainError("close of closed channel"))
	}

	if raceenabled {
		callerpc := getcallerpc()
		racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))
		racerelease(c.raceaddr())
	}

    // å°†é€šé“çš„ closed æ ‡å¿—è®¾ç½®ä¸º 1ï¼Œè¡¨ç¤ºé€šé“å·²å…³é—­
	c.closed = 1
	
    // éœ€è¦è¢«å”¤é†’çš„åç¨‹é›†åˆ
	var glist gList

	// release all readers
	for {
        // éå†é€šé“çš„æ¥æ”¶ç­‰å¾…é˜Ÿåˆ—ï¼Œé‡Šæ”¾æ‰€æœ‰ç­‰å¾…æ¥æ”¶çš„åç¨‹
		sg := c.recvq.dequeue()
		if sg == nil {
			break
		}
        // å¦‚æœ sg.elem ä¸ä¸º nil
		if sg.elem != nil {
            // æ¸…ç©ºæ¥æ”¶æ–¹çš„å†…å­˜ä½ç½®
			typedmemclr(c.elemtype, sg.elem)
			sg.elem = nil
		}
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
        
        // è·å–åˆ°æ¥æ”¶è€…åç¨‹
		gp := sg.g
		gp.param = unsafe.Pointer(sg)
        // æ ‡è®°è·å–æ“ä½œå¤±è´¥
		sg.success = false
		if raceenabled {
			raceacquireg(gp, c.raceaddr())
		}
        // å°†åç¨‹åŠ å…¥åˆ° glist ä¸­ï¼Œç¨åå”¤é†’
		glist.push(gp)
	}

	// release all writers (they will panic)
	for {
        // éå†é€šé“çš„å‘é€ç­‰å¾…é˜Ÿåˆ—ï¼Œé‡Šæ”¾æ‰€æœ‰ç­‰å¾…å‘é€çš„åç¨‹
		sg := c.sendq.dequeue()
		if sg == nil {
			break
		}
        // æ¸…ç©º sg.elemï¼Œé¿å…å†…å­˜æ³„æ¼
		sg.elem = nil
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
        
        // è·å–åˆ°å‘é€è€…åç¨‹
		gp := sg.g
		gp.param = unsafe.Pointer(sg)
        // æ ‡è®°å‘é€æ“ä½œå¤±è´¥
		sg.success = false
		if raceenabled {
			raceacquireg(gp, c.raceaddr())
		}
        // å°†åç¨‹åŠ å…¥åˆ° glist ä¸­ï¼Œç¨åå”¤é†’
		glist.push(gp)
	}
    
    // è§£é”é€šé“çš„äº’æ–¥é”
	unlock(&c.lock)

	// Ready all Gs now that we've dropped the channel lock.
    // éå† glistï¼Œå”¤é†’æ‰€æœ‰ç­‰å¾…çš„åç¨‹
	for !glist.empty() {
		gp := glist.pop()
		gp.schedlink = 0
        // è°ƒç”¨ goready å°†åç¨‹æ ‡è®°ä¸ºå¯è¿è¡ŒçŠ¶æ€
		goready(gp, 3)
	}
}

```

ğŸŒºğŸŒºğŸŒºæ’’èŠ±ï¼

å¦‚æœæœ¬æ–‡å¯¹ä½ æœ‰å¸®åŠ©ï¼Œå°±ç‚¹å…³æ³¨æˆ–è€…ç•™ä¸ªğŸ‘
  
å¦‚æœæ‚¨æœ‰ä»»ä½•æŠ€æœ¯é—®é¢˜æˆ–è€…éœ€è¦æ›´å¤šå…¶ä»–çš„å†…å®¹ï¼Œè¯·éšæ—¶å‘æˆ‘æé—®ã€‚
  
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/3734a0d4d24847a6ad83ea7ad3b1a2c6.png)