---
layout: post
title: "UniApp-SignalR-Asp.net-Core-åšä¸€ä¸ªèŠå¤©IM,å«emoji-è¡¨æƒ…åŒ…"
date: 2025-09-01T15:15:51+0800
description: "ã€æ‘˜è¦ã€‘æœ¬æ–‡å®ç°äº†ä¸€ä¸ªåŸºäºUniAppå’ŒSignalRçš„å³æ—¶é€šè®¯ç³»ç»Ÿï¼Œæ¨¡ä»¿Bossç›´è˜çš„èŠå¤©åŠŸèƒ½ã€‚å‰ç«¯é‡‡ç”¨Ubestæ¡†æ¶æ„å»ºUniAppåº”ç”¨ï¼ŒåŒ…å«æ¶ˆæ¯æ”¶å‘ã€è¡¨æƒ…é€‰æ‹©ã€å¸¸ç”¨è¯­ç®¡ç†ç­‰ç•Œé¢ç»„ä»¶ï¼›åç«¯ä½¿ç”¨ASP.NET Core SignalRå®ç°å®æ—¶é€šä¿¡ï¼Œå¤„ç†æ¶ˆæ¯æ”¶å‘ã€è”ç³»äººäº¤æ¢ã€é»‘åå•ç®¡ç†ç­‰æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ã€‚ç³»ç»Ÿé€šè¿‡é˜²éªšæ‰°æœºåˆ¶å’Œé»‘åå•æ£€æŸ¥ç¡®ä¿é€šä¿¡å®‰å…¨ï¼Œæ”¯æŒç¦»çº¿æ¶ˆæ¯æ¨é€ï¼Œå¹¶é‡‡ç”¨ç¼“å­˜ä¼˜åŒ–åœ¨çº¿çŠ¶æ€ç®¡ç†ã€‚æŠ€æœ¯æ–¹æ¡ˆå®ç°äº†è·¨å¹³å°ç§»åŠ¨ç«¯åº”ç”¨ä¸é«˜æ•ˆå®æ—¶é€šä¿¡çš„ç»“åˆã€‚"
keywords: "uni-app textareå¦‚ä½•å±•ç¤ºè¡¨æƒ…"
categories: ['æœªåˆ†ç±»']
tags: ['å‰ç«¯', 'Vue', 'Typescript', 'C']
artid: "151071150"
arturl: "https://blog.csdn.net/lee576/article/details/151071150"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151071150
    alt: "UniApp-SignalR-Asp.net-Core-åšä¸€ä¸ªèŠå¤©IM,å«emoji-è¡¨æƒ…åŒ…"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151071150
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151071150
cover: https://bing.ee123.net/img/rand?artid=151071150
image: https://bing.ee123.net/img/rand?artid=151071150
img: https://bing.ee123.net/img/rand?artid=151071150
---



# UniApp + SignalR + Asp.net Core åšä¸€ä¸ªèŠå¤©IMï¼Œå«emoji è¡¨æƒ…åŒ…

åŠŸèƒ½æ˜¯æ¨¡ä»¿Boss ç›´è˜ï¼Œä¸»è¦æ˜¯æ±‚èŒè€…ä¸æ‹›è˜è€…çš„èŠå¤©åŠŸèƒ½ï¼ŒèŠå¤©çš„æ—¶å€™ç´¢è¦è”ç³»æ–¹å¼ï¼ŒåŠ é»‘åå•ï¼Œä¸¾æŠ¥ï¼Œæ ‡è®°/ç½®é¡¶è¿™äº›ï¼Œè·ŸèŠå¤©çš„åŠŸèƒ½æ— å…³ï¼Œæˆ‘ä¹Ÿæ‡’å¾—å‰”é™¤äº†ï¼Œä¸»è¦æ˜¯å®ç°æ–¹å¼å’Œæ ·å¼ä¿ç•™å¥½ï¼Œæ”¶è—ï¼Œä»¥åè¯´ä¸å®šè¿˜è¦ç”¨åˆ°ï¼Œæ ¸å¿ƒè¿˜æ˜¯èŠå¤©åŠŸèƒ½çš„å®ç°

![](https://i-blog.csdnimg.cn/direct/b7564892ec7a4629b8a49e2ed2a2f97b.png)

ä»¥ä¸Šçš„èŠå¤©åŠŸèƒ½ä½¿ç”¨äº†Ubest æ¡†æ¶åˆ›å»ºçš„ UniAppï¼Œåœ¨çº¿èŠå¤©çš„åå°æŠ€æœ¯ä½¿ç”¨äº†SignalRï¼Œä¸Šä»£ç ï¼Œé¦–å…ˆæ˜¯ UniApp ç«¯

```

<route lang="json5" type="page">
{
  layout: 'default',
  style: {
    navigationBarTitleText: '',
  },
}
</route>
<template>
  <view class="chat">
    <!-- é¡¶éƒ¨æ ‡é¢˜ -->
    <view class="topTabbar">
      <!-- è¿”å›æŒ‰é’® -->
      <wd-button
        class="back-button"
        type="text"
        icon="arrow-left"
        size="small"
        @click="goback()"
      ></wd-button>
      <wd-row>
        <wd-col :span="24" style="text-align: center; padding: 0 60rpx">
          {{ recruiterInfo ? `${recruiterInfo.surname} ${recruiterInfo.givenName}` : '' }}
        </wd-col>
      </wd-row>
      <wd-row>
        <wd-tabbar v-model="tabbar" @change="handleChange">
          <wd-tabbar-item
            :title="$t('chat.message.exchangeContacts')"
            icon="phone"
          ></wd-tabbar-item>
          <wd-tabbar-item :title="$t('chat.message.pin')" icon="pin"></wd-tabbar-item>
          <wd-tabbar-item :title="$t('chat.message.unsuitable')" icon="close"></wd-tabbar-item>
          <wd-tabbar-item :title="$t('chat.message.report')" icon="warning"></wd-tabbar-item>
          <wd-tabbar-item
            :title="$t('chat.message.blacklist')"
            icon="usergroup-clear"
          ></wd-tabbar-item>
        </wd-tabbar>
      </wd-row>
    </view>
    <scroll-view
      :style="{ height: `calc(100vh + ${2 * inputHeight}rpx)` }"
      id="scrollview"
      scroll-y
      :scroll-top="scrollTop"
      class="scroll-view"
    >
      <!-- èŠå¤©ä¸»ä½“ -->
      <view id="msglistview" class="chat-body">
        <!-- èŠå¤©è®°å½• -->
        <view v-for="(item, index) in msgList" :key="item.id">
          <!-- ç³»ç»Ÿæ¶ˆæ¯ -->
          <view class="item system" v-if="item.isSystem">
            <view class="content system">
              {{ item.content }}
            </view>
          </view>
          <!-- è‡ªå·±å‘çš„æ¶ˆæ¯ -->
          <view class="item self" v-else-if="item.isSelf">
            <!-- æ–‡å­—å†…å®¹ -->
            <view class="content right">
              {{ item.content }}
            </view>
            <!-- å¤´åƒ -->
            <wd-img
              class="avatar"
              :src="item.image || '/static/images/default-avatar.png'"
              width="78rpx"
              height="78rpx"
              radius="50%"
            ></wd-img>
          </view>
          <!-- å¯¹æ–¹å‘çš„æ¶ˆæ¯ -->
          <view class="item Ai" v-else>
            <!-- å¤´åƒ -->
            <wd-img
              class="avatar"
              :src="item.image || '/static/images/default-avatar.png'"
              width="78rpx"
              height="78rpx"
              radius="50%"
            ></wd-img>
            <!-- æ–‡å­—å†…å®¹ -->
            <view class="content left">
              {{ item.content }}
            </view>
          </view>
        </view>
      </view>
    </scroll-view>
    <!-- åº•éƒ¨æ¶ˆæ¯å‘é€æ  -->
    <!-- ç”¨æ¥å ä½ï¼Œé˜²æ­¢èŠå¤©æ¶ˆæ¯è¢«å‘é€æ¡†é®æŒ¡ -->
    <view class="chat-bottom" :style="{ height: `${inputHeight}rpx` }">
      <view class="send-msg" :style="{ bottom: `${keyboardHeight - 60}rpx` }">
        <view class="uni-textarea">
          <div class="textarea-container">
            <!-- <button class="embed-btn left-btn" @click="handleEmbedButtonClick">
              <wd-icon name="chat1" size="22px"></wd-icon>
            </button> -->
            <wd-button type="icon" icon="chat1" @click="handleEmbedButtonClick"></wd-button>
            <textarea
              v-model="chatMsg"
              maxlength="300"
              confirm-type="send"
              @confirm="handleSend"
              :placeholder="$t('chat.message.placeholder')"
              :show-confirm-bar="false"
              :adjust-position="false"
              @linechange="sendHeight"
              @focus="focus"
              @blur="blur"
              auto-height
            ></textarea>
            <wd-button type="icon" icon="dong" @click="toggleEmojiPicker"></wd-button>
          </div>
        </view>
        <button @click="handleSend" class="send-btn">{{ $t('chat.message.sendBtn') }}</button>
      </view>
    </view>

    <!-- emojiè¡¨æƒ…é€‰æ‹©å™¨ -->
    <view v-if="showEmojiPicker" class="emoji-picker-container" @click.stop="stopPropagation">
      <scroll-view scroll-y class="emoji-scroll-view">
        <view class="emoji-category">
          <view class="emoji-grid">
            <view
              v-for="emoji in emojiList"
              :key="emoji.name"
              class="emoji-item"
              @click="selectEmoji(emoji, $event)"
            >
              <span class="emoji-char">{{ emoji.char }}</span>
            </view>
          </view>
        </view>
      </scroll-view>
    </view>
    <wd-action-sheet
      :title="$t('chat.commonPhrase.title')"
      v-model="showCommonPhrase"
      @close="closeCommonPhrase"
    >
      <!-- å¸¸ç”¨è¯­åˆ—è¡¨ -->
      <wd-row v-if="!showAddPhraseInput">
        <wd-col span="24" style="text-align: right; height: 60rpx; padding: 0 15rpx; margin: 0px">
          <wd-button type="icon" icon="add-circle" @click="showAddPhraseForm"></wd-button>
        </wd-col>
      </wd-row>

      <!-- å¸¸ç”¨è¯­åˆ—è¡¨é¡¹ -->
      <wd-row
        v-if="!showAddPhraseInput && commonPhrases.length > 0"
        v-for="(phrase, index) in commonPhrases"
        :key="index"
      >
        <wd-col span="20" style="padding: 10rpx 15rpx">
          <view class="phrase-item" @click="selectCommonPhrase(phrase)">
            {{ phrase.commonText }}
          </view>
        </wd-col>
        <wd-col span="4" style="padding: 10rpx 5rpx">
          <wd-button
            type="icon"
            icon="delete"
            size="small"
            @click.stop="deleteCommonPhrase(phrase)"
          ></wd-button>
        </wd-col>
      </wd-row>

      <!-- ç©ºçŠ¶æ€æç¤º -->
      <wd-row v-if="!showAddPhraseInput && commonPhrases.length === 0">
        <wd-col span="24" style="text-align: center; padding: 30rpx 0">
          <text style="color: #999">{{ $t('chat.commonPhrase.empty') }}</text>
        </wd-col>
      </wd-row>

      <!-- æ·»åŠ å¸¸ç”¨è¯­è¡¨å• -->
      <wd-row v-if="showAddPhraseInput">
        <wd-col span="24" style="padding: 15rpx">
          <wd-input
            v-model="newPhraseInput"
            :placeholder="$t('chat.commonPhrase.addPlaceholder')"
          ></wd-input>
        </wd-col>
        <wd-col span="24" style="text-align: right; padding: 10rpx 15rpx">
          <wd-button
            size="small"
            type="success"
            @click="showAddPhraseInput = false"
            style="margin-right: 10px"
          >
            {{ $t('common.cancel') }}
          </wd-button>
          <wd-button size="small" type="primary" @click="addCommonPhrase">
            {{ $t('common.confirm') }}
          </wd-button>
        </wd-col>
      </wd-row>
    </wd-action-sheet>
  </view>
</template>
<script lang="ts" setup>
import { ref, computed, onUpdated, Ref, onMounted } from 'vue'
import { useUserStore } from '@/store'
import { storeToRefs } from 'pinia'
import { getCommonPhrases, createCommonPhrase, removeCommonPhrase } from '@/api/commonPhrase'
import { useToast } from 'wot-design-uni'
import { i18n } from '@/locale/index'
import * as signalR from '@microsoft/signalr'
import { useMessage } from 'wot-design-uni'
import type { CommonPhraseEntity } from '@/api/commonPhrase.typings'
import { RoleEnum } from '@/typings'

// emojiç±»å‹å®šä¹‰
interface Emoji {
  name: string
  char: string
  category: string
}
const message = useMessage()

const tabbar = ref(-1)
// ç”¨æˆ·ä¿¡æ¯
const userStore = useUserStore()
const { userInfo } = storeToRefs(userStore)

// å¸¸ç”¨è¯­ç›¸å…³çŠ¶æ€
const showCommonPhrase = ref(false)
// å¸¸ç”¨è¯­åˆ—è¡¨åº”è¯¥æ˜¯CommonPhraseEntityç±»å‹çš„æ•°ç»„
const commonPhrases = ref<CommonPhraseEntity[]>([])
const newPhraseInput = ref('')
const showAddPhraseInput = ref(false)

// æ‰“å¼€å¸¸ç”¨è¯­é¢æ¿
const handleEmbedButtonClick = () => {
  showCommonPhrase.value = true
  loadCommonPhrases()
}

// å…³é—­å¸¸ç”¨è¯­é¢æ¿
const closeommonPhrase = () => {
  showCommonPhrase.value = false
  showAddPhraseInput.value = false
}

// åŠ è½½å¸¸ç”¨è¯­åˆ—è¡¨
const loadCommonPhrases = async () => {
  try {
    const phrases = await getCommonPhrases(userInfo.value?.id)
    // ç¡®ä¿dataå§‹ç»ˆæ˜¯æ•°ç»„ç±»å‹
    commonPhrases.value = Array.isArray(phrases.data)
      ? phrases.data
      : phrases.data
        ? [phrases.data]
        : []
  } catch (error) {
    console.error('åŠ è½½å¸¸ç”¨è¯­å¤±è´¥:', error)
  }
}

// é€‰æ‹©å¸¸ç”¨è¯­
const selectCommonPhrase = (phrase: CommonPhraseEntity) => {
  chatMsg.value += phrase.commonText
  showCommonPhrase.value = false
}

// æ˜¾ç¤ºæ·»åŠ å¸¸ç”¨è¯­è¾“å…¥æ¡†
const showAddPhraseForm = () => {
  showAddPhraseInput.value = true
  newPhraseInput.value = ''
}

// æ·»åŠ æ–°å¸¸ç”¨è¯­
const addCommonPhrase = async () => {
  if (!newPhraseInput.value.trim()) {
    return
  }

  // è·å–å½“å‰ç”¨æˆ·è§’è‰²
  const currentRole = Number(userInfo.value?.currentRole) || 0

  try {
    // æ„é€ CommonPhraseEntityç±»å‹çš„å‚æ•°
    const newPhrase: CommonPhraseEntity = {
      Id: 0,
      UserId: userInfo.value?.id || 0,
      Role: currentRole,
      CommonText: newPhraseInput.value.trim(),
      SortOrder: commonPhrases.value.length + 1,
      LastEditTime: new Date().toISOString(),
    }

    await createCommonPhrase(newPhrase)
    newPhraseInput.value = ''
    loadCommonPhrases()
    showAddPhraseInput.value = false
  } catch (error) {
    console.error('æ·»åŠ å¸¸ç”¨è¯­å¤±è´¥:', error)
  }
}

// åˆ é™¤å¸¸ç”¨è¯­
const deleteCommonPhrase = async (phrase: CommonPhraseEntity) => {
  try {
    await removeCommonPhrase(phrase.id)
    loadCommonPhrases()
  } catch (error) {
    console.error('åˆ é™¤å¸¸ç”¨è¯­å¤±è´¥:', error)
  }
}

// SignalRè¿æ¥å¯¹è±¡
let hubConnection: signalR.HubConnection | null = null

// è¿æ¥çŠ¶æ€
const connectionState = ref<signalR.HubConnectionState>(signalR.HubConnectionState.Disconnected)

// SignalR URL
const hubUrl = `${import.meta.env.VITE_SERVER_BASEURL}/chatHub`

// å¯åŠ¨è¿æ¥
async function startConnection() {
  // é˜²æ­¢é‡å¤è¿æ¥è¯·æ±‚
  if (
    connectionState.value === signalR.HubConnectionState.Connecting ||
    connectionState.value === signalR.HubConnectionState.Connected
  ) {
    console.log(`Connection already in progress or connected: ${connectionState.value}`)
    return
  }

  connectionState.value = signalR.HubConnectionState.Connecting

  // å…³é—­å·²æœ‰çš„è¿æ¥
  if (hubConnection) {
    console.log('Closing existing connection...')
    await hubConnection.stop()
    hubConnection = null
    console.log('Existing connection closed')
  }

  try {
    // æ£€æŸ¥tokenæ˜¯å¦å­˜åœ¨
    const token = uni.getStorageSync('token')
    if (!token) {
      console.warn('No authentication token found')
      toast.show('æœªæ‰¾åˆ°è®¤è¯ä¿¡æ¯ï¼Œè¯·é‡æ–°ç™»å½•')
      return
    }

    // éªŒè¯hubUrl
    if (!hubUrl) {
      console.error('Hub URL is not defined')
      toast.show('æœåŠ¡å™¨åœ°å€æœªé…ç½®')
      return
    }

    // åˆ›å»ºæ–°çš„SignalRè¿æ¥
    hubConnection = new signalR.HubConnectionBuilder()
      .withUrl(hubUrl, {
        accessTokenFactory: () => token,
        skipNegotiation: true,
        transport: signalR.HttpTransportType.WebSockets,
      })
      .withAutomaticReconnect()
      .build()

    // æ¥æ”¶æ¶ˆæ¯äº‹ä»¶
    hubConnection.on('ReceiveMessage', (senderId, message) => {
      const newMessage: MessageItem = {
        id: Date.now().toString(),
        senderId: senderId.toString(),
        receiverId: currentUserId.value,
        content: message,
        sentTime: new Date().toISOString(),
        isSelf: senderId.toString() === currentUserId.value.toString(),
        image: recruiterInfo.value?.image || '',
      }
      msgList.value.push(newMessage)
      // æ»šåŠ¨åˆ°åº•éƒ¨
      setTimeout(() => {
        scrollToBottom().catch((err) =>
          console.error('Error in ReceiveMessage scrollToBottom:', err),
        )
      }, 100)
    })

    // æ¥æ”¶äº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚äº‹ä»¶
    hubConnection.on('ReceiveContactRequest', (senderId, senderInfo) => {
      // åªæœ‰å½“å½“å‰é¡µé¢æ˜¯ä¸è¯·æ±‚æ–¹çš„èŠå¤©ç•Œé¢æ—¶æ‰å¼¹å‡ºå¯¹è¯æ¡†
      if (receiverId.value && receiverId.value.toString() === senderId.toString()) {
        message
          .confirm({
            msg: i18n.global.t('chat.message.receiveContactRequestMsg', {
              senderName: senderInfo?.name || 'å¯¹æ–¹',
            }),
            title: i18n.global.t('chat.message.receiveContactRequestTitle'),
          })
          .then(() => {
            // åŒæ„äº¤æ¢è”ç³»æ–¹å¼
            sendSocketMessage('ApproveContactRequest', senderId).then((success) => {
              if (success) {
                toast.show(i18n.global.t('chat.message.approveContactSuccess'))
                // è·å–å¯¹æ–¹è”ç³»æ–¹å¼
                if (senderInfo?.contactInfo) {
                  // è¿™é‡Œå¯ä»¥æ·»åŠ æ˜¾ç¤ºå¯¹æ–¹è”ç³»æ–¹å¼çš„é€»è¾‘
                  toast.show(`å·²è·å–å¯¹æ–¹è”ç³»æ–¹å¼: ${senderInfo.contactInfo}`)
                }
              } else {
                toast.show(i18n.global.t('chat.message.approveContactFailed'))
              }
            })
          })
          .catch(() => {
            // æ‹’ç»äº¤æ¢è”ç³»æ–¹å¼
            sendSocketMessage('RejectContactRequest', senderId)
            toast.show(i18n.global.t('chat.message.rejectContactSuccess'))
          })
      }
    })

    // æ¥æ”¶åŒæ„äº¤æ¢è”ç³»æ–¹å¼å“åº”äº‹ä»¶
    hubConnection.on('ContactRequestApproved', (senderId, contactInfo) => {
      if (receiverId.value && receiverId.value.toString() === senderId.toString()) {
        // åˆ›å»ºäº¤æ¢è”ç³»æ–¹å¼æˆåŠŸç³»ç»Ÿæ¶ˆæ¯
        const exchangeSuccessMessage: MessageItem = {
          id: Date.now().toString(),
          senderId: 'system',
          receiverId: '',
          content: i18n.global.t('chat.message.exchangeContactsSuccess'),
          sentTime: new Date().toISOString(),
          isSelf: false,
          isSystem: true,
          image: '',
        }
        msgList.value.push(exchangeSuccessMessage)

        if (contactInfo) {
          // åˆ›å»ºè·å–è”ç³»æ–¹å¼ç³»ç»Ÿæ¶ˆæ¯
          const contactInfoMessage: MessageItem = {
            id: Date.now().toString() + '_contact',
            senderId: 'system',
            receiverId: '',
            content: i18n.global.t('chat.message.getContactInfoSuccess', { contactInfo }),
            sentTime: new Date().toISOString(),
            isSelf: false,
            isSystem: true,
            image: '',
          }
          msgList.value.push(contactInfoMessage)
        }
      }
    })

    // æ¥æ”¶æ‹’ç»äº¤æ¢è”ç³»æ–¹å¼å“åº”äº‹ä»¶
    hubConnection.on('ContactRequestRejected', (senderId) => {
      if (receiverId.value && receiverId.value.toString() === senderId.toString()) {
        // åˆ›å»ºè”ç³»æ–¹å¼è¯·æ±‚è¢«æ‹’ç»ç³»ç»Ÿæ¶ˆæ¯
        const rejectedMessage: MessageItem = {
          id: Date.now().toString(),
          senderId: 'system',
          receiverId: '',
          content: i18n.global.t('chat.message.contactRequestRejected'),
          sentTime: new Date().toISOString(),
          isSelf: false,
          isSystem: true,
          image: '',
        }
        msgList.value.push(rejectedMessage)
      }
    })

    // ç›‘å¬è¢«é˜»æ–­äº‹ä»¶ï¼ˆé˜²éªšæ‰°æœºåˆ¶ï¼‰
    hubConnection.on('Blocked', (message) => {
      // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
      const systemMessage: MessageItem = {
        id: Date.now().toString(),
        senderId: 'system',
        receiverId: '',
        content: i18n.global.t('chat.message.blocked'),
        sentTime: new Date().toISOString(),
        isSelf: false,
        isSystem: true,
        image: '',
      }
      msgList.value.push(systemMessage)
      // æ»šåŠ¨åˆ°åº•éƒ¨
      setTimeout(() => {
        scrollToBottom().catch((err) => console.error('Error in Blocked scrollToBottom:', err))
      }, 100)
    })

    // ç›‘å¬é»‘åå•æ¶ˆæ¯é˜»æ–­äº‹ä»¶
    hubConnection.on('BlacklistMessageBlocked', (type) => {
      // æ ¹æ®ç±»å‹é€‰æ‹©ä¸åŒçš„å›½é™…åŒ–æç¤º
      const content =
        Number(type) === 1
          ? i18n.global.t('chat.message.youAddedBlacklist')
          : i18n.global.t('chat.message.otherAddedBlacklist')

      // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
      const systemMessage: MessageItem = {
        id: Date.now().toString(),
        senderId: 'system',
        receiverId: '',
        content,
        sentTime: new Date().toISOString(),
        isSelf: false,
        isSystem: true,
        image: '',
      }
      msgList.value.push(systemMessage)
      // æ»šåŠ¨åˆ°åº•éƒ¨
      setTimeout(() => {
        scrollToBottom().catch((err) =>
          console.error('Error in BlacklistMessageBlocked scrollToBottom:', err),
        )
      }, 100)
    })

    // ç›‘å¬è”ç³»æ–¹å¼è¯·æ±‚å·²å‘é€äº‹ä»¶
    hubConnection.on('ContactRequestAlreadySent', (senderId) => {
      // è®¾ç½®æ ‡å¿—ï¼Œè¡¨ç¤ºå·²æ¥æ”¶åˆ°æ­¤äº‹ä»¶
      contactRequestAlreadySent.value = true

      const contactAlreadySentMessage: MessageItem = {
        id: Date.now().toString(),
        senderId: 'system',
        receiverId: '',
        content: i18n.global.t('chat.message.contactAlreadyExchanged'),
        sentTime: new Date().toISOString(),
        isSelf: false,
        isSystem: true,
        image: '',
      }
      msgList.value.push(contactAlreadySentMessage)
      // æ»šåŠ¨åˆ°åº•éƒ¨
      setTimeout(() => {
        scrollToBottom().catch((err) =>
          console.error('Error in ContactRequestAlreadySent scrollToBottom:', err),
        )
      }, 100)
    })

    // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
    hubConnection.onreconnecting((error) => {
      connectionState.value = signalR.HubConnectionState.Reconnecting
    })

    hubConnection.onreconnected((connectionId) => {
      connectionState.value = signalR.HubConnectionState.Connected
    })

    hubConnection.onclose((error) => {
      connectionState.value = signalR.HubConnectionState.Disconnected
      if (error) {
        toast.show(`Connection lost: ${error.message}. Reconnecting...`)
      }
    })

    // å¯åŠ¨è¿æ¥
    await hubConnection
      .start()
      .then(() => console.log('Connected to SignalR Hub'))
      .catch((err) => console.error('Connection failed:', err))
    connectionState.value = signalR.HubConnectionState.Connected
  } catch (error) {
    connectionState.value = signalR.HubConnectionState.Disconnected

    // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
    uni.getNetworkType({
      success: (res) => {
        console.log('Network type:', res.networkType)
      },
    })
    console.log(`Failed to connect: ${error instanceof Error ? error.message : String(error)}`)
  }
}

// å‘é€SignalRæ¶ˆæ¯
async function sendSocketMessage(methodName: string, ...args: any[]) {
  if (!hubConnection || connectionState.value !== signalR.HubConnectionState.Connected) {
    console.error(
      `[${new Date().toISOString()}] Cannot send message: Connection is not in Connected state (current: ${connectionState.value})`,
    )
    toast.show(i18n.global.t('chat.message.notConnected'))
    return false
  }

  try {
    console.log(`[${new Date().toISOString()}] Sending message: ${methodName}`, args)
    // æ•è·æœåŠ¡å™¨è¿”å›çš„ç»“æœ
    const result = await hubConnection.invoke(methodName, ...args)
    console.log(
      `[${new Date().toISOString()}] Message sent successfully: ${methodName}, result:`,
      result,
    )
    // è¿”å›æœåŠ¡å™¨è¿”å›çš„ç»“æœ
    return result
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Failed to send message: ${methodName}`, error)
    toast.show(i18n.global.t('chat.message.sendError'))
    return false
  }
}

type MessageItem = {
  id: string
  senderId: string
  receiverId: string
  content: string
  sentTime: string
  isSelf: boolean
  isSystem?: boolean
  image: string
}

type RecruiterInfo = {
  id: string
  surname: string
  givenName: string
  image?: string
}

// çŠ¶æ€å®šä¹‰
const keyboardHeight = ref(0)
const bottomHeight = ref(0)
const scrollTop = ref(0)
const chatMsg = ref('')
const recruiterInfo = ref<RecruiterInfo | null>(null)
const msgList = ref<MessageItem[]>([])
const isBlocked = ref(false)
const blockedMessage = ref('')
// ç”¨äºè·Ÿè¸ªæ˜¯å¦å·²æ¥æ”¶åˆ°"è”ç³»æ–¹å¼å·²äº¤æ¢"çš„äº‹ä»¶
const contactRequestAlreadySent = ref(false)
// ç”¨äºæ§åˆ¶emojiè¡¨æƒ…é€‰æ‹©å™¨çš„æ˜¾ç¤ºå’Œéšè—
const showEmojiPicker = ref(false)
// emojiåˆ—è¡¨
const emojiList = ref<Emoji[]>([])

const toast = useToast()

// åˆ‡æ¢emojiè¡¨æƒ…é€‰æ‹©å™¨çš„æ˜¾ç¤ºå’Œéšè—
const toggleEmojiPicker = () => {
  showEmojiPicker.value = !showEmojiPicker.value
  // å…³é—­å¸¸ç”¨è¯­é¢æ¿
  showCommonPhrase.value = false
}

// é˜»æ­¢è¡¨æƒ…é€‰æ‹©å™¨å†…éƒ¨ç‚¹å‡»äº‹ä»¶å†’æ³¡
const stopPropagation = (event: Event) => {
  event.stopPropagation()
}

// é€‰æ‹©emojiå¹¶æ·»åŠ åˆ°è¾“å…¥æ¡†
const selectEmoji = (emoji: Emoji, event: Event) => {
  // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘å…¶ä»–å…³é—­è¡¨æƒ…é¢æ¿çš„é€»è¾‘
  event.stopPropagation()
  chatMsg.value += emoji.char
  // ç‚¹å‡»è¡¨æƒ…åå…³é—­è¡¨æƒ…é¢æ¿
  showEmojiPicker.value = false
  // æ»šåŠ¨åˆ°åº•éƒ¨
  setTimeout(() => {
    scrollToBottom().catch((err) => console.error('Error in selectEmoji scrollToBottom:', err))
  }, 100)
}

// ä»APIåŠ è½½emojiæ•°æ®
const loadEmojiData = async () => {
  try {
    const response = await fetch('https://unpkg.com/emoji.json@16.0.0/emoji.json')
    const data = await response.json()

    // æ‰“å°ç¬¬ä¸€ä¸ªitemæŸ¥çœ‹æ•°æ®ç»“æ„
    console.log('APIè¿”å›çš„emojiæ•°æ®ç»“æ„:', data[0])

    // å¤„ç†emojiæ•°æ®ï¼Œè½¬æ¢ä¸ºæˆ‘ä»¬éœ€è¦çš„æ ¼å¼
    emojiList.value = data
      .slice(0, 100)
      .map((item: any) => ({
        name: item.slug || item.name || 'emoji',
        char: item.character || item.char || '',
        category: item.category || 'unknown',
      }))
      .filter((emoji: Emoji) => emoji.char)

    console.log('å¤„ç†åçš„emojiåˆ—è¡¨:', emojiList.value)
  } catch (error) {
    console.error('åŠ è½½emojiæ•°æ®å¤±è´¥:', error)
    // æ·»åŠ ä¸€äº›é»˜è®¤emojiä½œä¸ºå¤‡ç”¨
    emojiList.value = [
      { name: 'smile', char: 'ğŸ˜Š', category: 'face' },
      { name: 'heart', char: 'â¤ï¸', category: 'heart' },
      { name: 'thumbsup', char: 'ğŸ‘', category: 'hand' },
      { name: 'laugh', char: 'ğŸ˜‚', category: 'face' },
      { name: 'love', char: 'ğŸ˜', category: 'face' },
      { name: 'clap', char: 'ğŸ‘', category: 'hand' },
    ]
  }
}

// åœ¨ç»„ä»¶æŒ‚è½½æ—¶åŠ è½½emojiæ•°æ®
onMounted(() => {
  loadEmojiData()
})

// å½“å‰ç”¨æˆ·ID (ä»æœ¬åœ°å­˜å‚¨è·å–ï¼Œå®é™…åº”ç”¨ä¸­åº”ä»èº«ä»½éªŒè¯ç³»ç»Ÿè·å–)
const currentUserId = ref('')

// ä»æœ¬åœ°å­˜å‚¨è·å–ç”¨æˆ·ID
function getCurrentUserId() {
  try {
    const userInfo = uni.getStorageSync('userInfo')
    if (userInfo) {
      currentUserId.value = userInfo.id || ''
    }
  } catch (e) {
    console.error('Error getting user info:', e)
  }
}

// å¯¹æ–¹ç”¨æˆ·ID
const receiverId = ref('')

// è®¡ç®—å±æ€§
const windowHeight = computed(() => {
  return rpxTopx(uni.getSystemInfoSync().windowHeight)
})

const inputHeight = computed(() => {
  return bottomHeight.value + keyboardHeight.value
})

// Define the keyboard height change handler
const keyboardHeightChangeHandler = (res: any) => {
  keyboardHeight.value = rpxTopx(res.height)
  if (keyboardHeight.value < 0) keyboardHeight.value = 0
}

// ç”Ÿå‘½å‘¨æœŸ
onLoad(() => {
  // è·å–å½“å‰ç”¨æˆ·ID
  getCurrentUserId()

  // è·å–é¡µé¢å‚æ•°
  const pages = getCurrentPages()
  const currentPage = pages[pages.length - 1]
  const options = currentPage.options

  // è§£æä¼ é€’è¿‡æ¥çš„æ‹›è˜è€…ä¿¡æ¯
  if (options && options.recruiterInfo) {
    try {
      const decodedInfo = decodeURIComponent(options.recruiterInfo)
      recruiterInfo.value = JSON.parse(decodedInfo)
      receiverId.value = recruiterInfo.value?.id || ''
    } catch (error) {
      console.error('Error parsing recruiterInfo:', error)
    }
  } else {
    console.error('No recruiterInfo in options')
    toast.show('æœªæ‰¾åˆ°æ‹›è˜è€…ä¿¡æ¯')
  }

  // åˆå§‹åŒ–æ¶ˆæ¯åˆ—è¡¨
  initMsgList()

  // å¯åŠ¨ WebSocket è¿æ¥
  startConnection()
  // é‡æ–°è¿æ¥äº‹ä»¶ç›‘å¬
  function onReconnecting() {
    console.log('WebSocket reconnecting...')
    connectionState.value = signalR.HubConnectionState.Reconnecting
    toast.show('Reconnecting to server...')
  }

  // é‡æ–°è¿æ¥æˆåŠŸäº‹ä»¶ç›‘å¬ (æ¨¡æ‹Ÿ)
  function onReconnected() {
    console.log('WebSocket reconnected')
    connectionState.value = signalR.HubConnectionState.Connected
    toast.show('Reconnected to server.')
  }

  // Register the event listener
  uni.onKeyboardHeightChange(keyboardHeightChangeHandler)
})

onUnload(async () => {
  if (hubConnection) {
    try {
      await hubConnection.stop()
      hubConnection = null
      console.log('Disconnected from SignalR server')
    } catch (error) {
      console.error('Error closing SignalR connection:', error)
    }
  }
  // Unregister the keyboard height change handler
  uni.offKeyboardHeightChange(keyboardHeightChangeHandler)
})

onUpdated(() => {
  // æ­£ç¡®å¤„ç†å¼‚æ­¥å‡½æ•°
  scrollToBottom().catch((err) => console.error('Error in onUpdated scrollToBottom:', err))
})

// å¼•å…¥ç”¨æˆ·API
import { getUserInfoById } from '@/api/login'
// å¼•å…¥è”ç³»äººå…³ç³»API
import { addToBlacklist, markAsNotSuitable, togglePinOrFollow } from '@/api/contactRelationship'

// éªŒè¯æ¥æ”¶è€…IDæ˜¯å¦å­˜åœ¨
async function verifyReceiverId(receiverId: string) {
  console.log(`=== Verifying receiverId: ${receiverId} ===`)
  try {
    // ä½¿ç”¨ç°æœ‰APIæ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const userInfo = await getUserInfoById(parseInt(receiverId))
    const exists = !!userInfo
    console.log(`Receiver verification result: ${exists ? 'Exists' : 'Does not exist'}`)
    return exists
  } catch (error) {
    console.error(`Failed to verify receiverId: ${receiverId}`, error)
    return false
  }
}

// åˆå§‹åŒ–æ¶ˆæ¯åˆ—è¡¨
function initMsgList() {
  // å®é™…åº”ç”¨ä¸­åº”ä»APIè·å–å†å²æ¶ˆæ¯
  msgList.value = []
}

// æ–¹æ³•å®šä¹‰
function goback() {
  uni.switchTab({
    url: '/pages/tutorship/tutorship',
  })
}

function focus() {
  // æ­£ç¡®å¤„ç†å¼‚æ­¥å‡½æ•°
  scrollToBottom().catch((err) => console.error('Error in focus scrollToBottom:', err))
}

// æ»šåŠ¨åˆ°åº•éƒ¨
async function scrollToBottom() {
  console.log('scrollToBottom function called')
  try {
    // ç­‰å¾…DOMæ›´æ–°
    await new Promise((resolve) => setTimeout(resolve, 50))
    console.log('DOM updated, proceeding with scroll')
    // è·å–æ»šåŠ¨å…ƒç´ å’Œå†…å®¹å…ƒç´ 
    const query = uni.createSelectorQuery().in(getCurrentInstance())
    query.select('.scroll-view').boundingClientRect()
    query.select('.chat-body').boundingClientRect()
    const res = await query.exec()
    if (res && res[0] && res[1]) {
      console.log('Scrolling to bottom with values:', res[1].height, res[0].height)
      // ç›´æ¥ä½¿ç”¨åƒç´ å€¼ï¼Œä¸è¿›è¡Œrpxè½¬æ¢
      scrollTop.value = res[1].height - res[0].height + 40 // å¢åŠ åç§»é‡åˆ°40åƒç´ 
      console.log('Set scrollTop to:', scrollTop.value)
    } else {
      console.warn('Could not get element dimensions for scrolling')
    }
  } catch (err) {
    console.error('Error scrolling to bottom:', err)
  }
}

function blur() {
  scrollToBottom()
}

// pxè½¬æ¢æˆrpx
function rpxTopx(px: number): number {
  const deviceWidth = uni.getSystemInfoSync().windowWidth
  const rpx = (750 / deviceWidth) * Number(px)
  return Math.floor(rpx)
}

// ç›‘è§†èŠå¤©å‘é€æ é«˜åº¦
function sendHeight() {
  setTimeout(() => {
    const query = uni.createSelectorQuery()
    query.select('.send-msg').boundingClientRect()
    query.exec((res) => {
      if (res && res[0]) {
        bottomHeight.value = rpxTopx(res[0].height)
      }
    })
  }, 10)
}

// å‘é€æ¶ˆæ¯
async function handleSend() {
  //å¦‚æœæ¶ˆæ¯ä¸ä¸ºç©º
  if (chatMsg.value && !/^\s+$/.test(chatMsg.value)) {
    if (!receiverId.value) {
      toast.show(i18n.global.t('chat.message.selectReceiver'))
      return
    }

    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    const isConnected = connectionState.value === signalR.HubConnectionState.Connected
    if (!isConnected) {
      if (connectionState.value === signalR.HubConnectionState.Connecting) {
        toast.show('Connecting to server. Please wait...')
      } else {
        toast.show('Connection not established. Reconnecting...')
        // å°è¯•é‡æ–°è¿æ¥
        startConnection()
      }
      return
    }

    try {
      // å‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
      const success = await sendSocketMessage(
        'SendPrivateMessage',
        receiverId.value.toString(),
        chatMsg.value,
      )
      console.log(`success:`, success)
      if (success) {
        // åˆ›å»ºæ–°æ¶ˆæ¯å¹¶æ·»åŠ åˆ°åˆ—è¡¨
        const newMessage: MessageItem = {
          id: Date.now().toString(),
          senderId: currentUserId.value,
          receiverId: receiverId.value,
          content: chatMsg.value,
          sentTime: new Date().toISOString(),
          isSelf: true,
          image: userInfo.value?.image || '/static/images/default-avatar.png',
        }
        msgList.value.push(newMessage)

        // æ¸…ç©ºè¾“å…¥æ¡†
        chatMsg.value = ''

        // æ»šåŠ¨åˆ°åº•éƒ¨
        setTimeout(() => {
          scrollToBottom().catch((err) => console.error('Error in handleSend scrollToBottom:', err))
        }, 100)
      } else {
        //toast.show('Failed to send message. Please try again.')
      }
    } catch (err) {
      console.error('Error sending message:', err)
      //toast.show('Failed to send message. Please try again.')
    }
  } else {
    toast.show(i18n.global.t('chat.message.emptyError'))
  }
}

// å›å¤æ¶ˆæ¯
function handleReply(senderId: string) {
  receiverId.value = senderId
  blockedMessage.value = ''

  // èšç„¦åˆ°è¾“å…¥æ¡†
  const textarea = uni.createSelectorQuery().select('textarea')
  textarea.focus()
}

function handleChange({ value }: { value: string }) {
  const tabIndex = parseInt(value)
  switch (tabIndex) {
    case 0:
      // äº¤æ¢è”ç³»æ–¹å¼
      handleExchangeContacts()
      break
    case 1:
      // ç½®é¡¶
      handlePinConversation()
      break
    case 2:
      // ä¸åˆé€‚
      handleMarkUnsuitable()
      break
    case 3:
      // ä¸¾æŠ¥
      handleReport()
      break
    case 4:
      // é»‘åå•
      handleAddToBlacklist()
      break
    default:
      console.warn(`Unknown tab index: ${tabIndex}`)
  }
}

// äº¤æ¢è”ç³»æ–¹å¼å¤„ç†å‡½æ•°
function handleExchangeContacts() {
  // åœ¨å‘é€è¯·æ±‚å‰é‡ç½®æ ‡å¿—
  contactRequestAlreadySent.value = false

  message
    .confirm({
      msg: i18n.global.t('chat.message.confirmExchangeContacts'),
      title: i18n.global.t('chat.message.exchangeContactsTitle'),
    })
    .then(() => {
      // å‘é€äº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚
      if (receiverId.value) {
        sendSocketMessage('ExchangeContactRequest', receiverId.value).then((success) => {
          if (success) {
            // åˆ›å»ºäº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚æˆåŠŸç³»ç»Ÿæ¶ˆæ¯
            const requestSuccessMessage: MessageItem = {
              id: Date.now().toString(),
              senderId: 'system',
              receiverId: '',
              content: i18n.global.t('chat.message.requestSendSuccess'),
              sentTime: new Date().toISOString(),
              isSelf: false,
              isSystem: true,
              image: '',
            }
            msgList.value.push(requestSuccessMessage)
          } else {
            // å¦‚æœæ˜¯å› ä¸º"å·²äº¤æ¢è¿‡è”ç³»æ–¹å¼"è€Œå¤±è´¥ï¼Œåˆ™ä¸æ˜¾ç¤ºå¤±è´¥æ¶ˆæ¯
            // å› ä¸ºContactRequestAlreadySentäº‹ä»¶å¤„ç†å™¨ä¼šæ˜¾ç¤ºä¸“é—¨çš„æ¶ˆæ¯
            if (!contactRequestAlreadySent.value) {
              // åˆ›å»ºäº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚å¤±è´¥ç³»ç»Ÿæ¶ˆæ¯
              const requestFailedMessage: MessageItem = {
                id: Date.now().toString(),
                senderId: 'system',
                receiverId: '',
                content: i18n.global.t('chat.message.requestSendFailed'),
                sentTime: new Date().toISOString(),
                isSelf: false,
                isSystem: true,
                image: '',
              }
              msgList.value.push(requestFailedMessage)
            } else {
              // é‡ç½®æ ‡å¿—ï¼Œä»¥ä¾¿ä¸‹ä¸€æ¬¡æ“ä½œ
              contactRequestAlreadySent.value = false
            }
          }
        })
      } else {
        // åˆ›å»ºæœªæ‰¾åˆ°æ¥æ”¶æ–¹ä¿¡æ¯ç³»ç»Ÿæ¶ˆæ¯
        const noReceiverMessage: MessageItem = {
          id: Date.now().toString(),
          senderId: 'system',
          receiverId: '',
          content: 'æœªæ‰¾åˆ°æ¥æ”¶æ–¹ä¿¡æ¯',
          sentTime: new Date().toISOString(),
          isSelf: false,
          isSystem: true,
          image: '',
        }
        msgList.value.push(noReceiverMessage)
      }
    })
    .catch(() => {})
}

// ç½®é¡¶å¤„ç†å‡½æ•°
function handlePinConversation() {
  message
    .confirm({
      msg: i18n.global.t('chat.message.confirmPinConversation'),
      title: i18n.global.t('chat.message.pinConversationTitle'),
    })
    .then(() => {
      if (!currentUserId.value || !receiverId.value) {
        toast.error(i18n.global.t('chat.message.selectReceiver'))
        return
      }

      // è°ƒç”¨togglePinOrFollowæ¥å£
      togglePinOrFollow(parseInt(currentUserId.value), parseInt(receiverId.value), true)
        .then((result) => {
          if (result.Success) {
            toast.show(i18n.global.t('chat.message.pinConversationSuccess'))
          } else {
            toast.error(result.Message || i18n.global.t('message.relation.togglePinOrFollowError'))
          }
        })
        .catch(() => {
          toast.error(i18n.global.t('message.relation.togglePinOrFollowError'))
        })
    })
    .catch(() => {})
}

// æ ‡è®°ä¸åˆé€‚å¤„ç†å‡½æ•°
function handleMarkUnsuitable() {
  message
    .confirm({
      msg: i18n.global.t('chat.message.confirmMarkUnsuitable'),
      title: i18n.global.t('chat.message.markUnsuitableTitle'),
    })
    .then(() => {
      if (!currentUserId.value || !receiverId.value) {
        toast.error(i18n.global.t('chat.message.selectReceiver'))
        return
      }

      markAsNotSuitable(parseInt(currentUserId.value), parseInt(receiverId.value))
        .then((result) => {
          if (result.Success) {
            toast.show(i18n.global.t('chat.message.markUnsuitableSuccess'))
          } else {
            toast.error(result.Message || i18n.global.t('message.relation.markNotSuitableError'))
          }
        })
        .catch(() => {
          toast.error(i18n.global.t('message.relation.markNotSuitableError'))
        })
    })
    .catch(() => {})
}

// ä¸¾æŠ¥å¤„ç†å‡½æ•°
function handleReport() {
  message
    .confirm({
      msg: i18n.global.t('chat.message.confirmReport'),
      title: i18n.global.t('chat.message.reportTitle'),
    })
    .then(() => {
      // è·³è½¬åˆ°ä¸¾æŠ¥é¡µé¢ï¼Œå¹¶ä¼ é€’ç”¨æˆ·IDå‚æ•°
      uni.navigateTo({
        url: `/pages/chat/report?currentUserId=${currentUserId.value}&receiverId=${receiverId.value}`,
      })
    })
    .catch(() => {})
}

// æ·»åŠ åˆ°é»‘åå•å¤„ç†å‡½æ•°
function handleAddToBlacklist() {
  message
    .confirm({
      msg: i18n.global.t('chat.message.confirmAddToBlacklist'),
      title: i18n.global.t('chat.message.addToBlacklistTitle'),
    })
    .then(() => {
      if (!receiverId.value) {
        toast.show(i18n.global.t('chat.message.selectReceiver'))
        return
      }

      addToBlacklist(parseInt(currentUserId.value), parseInt(receiverId.value))
        .then((result) => {
          if (result.Success) {
            toast.show(i18n.global.t('chat.message.addToBlacklistSuccess'))
            // æ›´æ–°é»‘åå•çŠ¶æ€
            blockedMessage.value = i18n.global.t('chat.message.youAddedBlacklist')
          } else {
            toast.error(result.Message || i18n.global.t('message.relation.blacklistError'))
          }
        })
        .catch((error) => {
          console.error('Failed to add to blacklist:', error)
          toast.error(i18n.global.t('message.relation.blacklistError'))
        })
    })
    .catch(() => {})
}
// å…³é—­å¸¸ç”¨è¯­é¢æ¿
const closeCommonPhrase = () => {
  showCommonPhrase.value = false
  showAddPhraseInput.value = false
}
</script>
<style lang="scss" scoped>
/* emojiè¡¨æƒ…é€‰æ‹©å™¨æ ·å¼ */
.emoji-picker-container {
  position: fixed;
  bottom: 100rpx;
  left: 0;
  right: 0;
  z-index: 9999;
  background-color: #fff;
  border-top: 1px solid #eee;
  height: 500rpx;
}

.emoji-scroll-view {
  height: 100%;
}

.emoji-category {
  padding: 20rpx;
}

.emoji-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 10rpx;
}

.emoji-item {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 80rpx;
  cursor: pointer;
}

.emoji-char {
  font-size: 44rpx;
  line-height: 1;
  display: inline-block;
}

.emoji-item:active {
  background-color: #f0f0f0;
  border-radius: 8rpx;
}

.emoji-btn {
  width: 80rpx;
  height: 80rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  color: #666;
  margin-left: 10rpx;
}
.wd-action-sheet__header {
  height: 50px !important;
}

/* å¸¸ç”¨è¯­æ ·å¼ */
.phrase-item {
  padding: 10rpx;
  background-color: #f5f5f5;
  border-radius: 8rpx;
  font-size: 28rpx;
  color: #333;
}

.phrase-item:hover {
  background-color: #e6e6e6;
}

wd-input {
  width: 100%;
}

wd-button[size='small'] {
  margin-left: 10rpx;
}
.uni-scroll-view-content {
  background-color: #f6f6f6;
}

$chatContentbgc: #c2dcff;
$sendBtnbgc: #4f7df5;

view,
button,
text,
input,
textarea {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* èŠå¤©æ¶ˆæ¯ */
.chat {
  height: 100%;
  .topTabbar {
    width: 100%;
    height: auto;
    min-height: 90rpx;
    display: flex;
    flex-direction: column;
    position: fixed;
    top: 0;
    left: 0;
    background-color: #fff;
    z-index: 999;
    padding: 0 20rpx;

    .back-button {
      position: absolute;
      left: 0rpx;
      top: 0rpx;
      padding: 10rpx;
      z-index: 1000;
    }
    .back-button:active {
      background-color: rgba(0, 0, 0, 0.1);
      border-radius: 50%;
    }
  }
  .scroll-view {
    // ç§»åŠ¨èƒŒæ™¯é¢œè‰²å£°æ˜åˆ°åµŒå¥—è§„åˆ™ä¹‹å‰
    background-color: #f6f6f6;
    margin-top: 90rpx; // ä¸ºé¡¶éƒ¨å¯¼èˆªæ è…¾å‡ºç©ºé—´
    padding-right: 20rpx; // å¢åŠ å³ä¾§paddingåˆ°20rpxï¼Œé¿å…å†…å®¹è¢«æ»šåŠ¨æ¡é®æŒ¡

    // åªåœ¨èŠå¤©è®°å½•åŒºåŸŸæ˜¾ç¤ºæ»šåŠ¨æ¡
    ::-webkit-scrollbar {
      width: 6rpx;
      height: 0 !important;
      -webkit-appearance: none;
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      border-radius: 3rpx;
      background-color: rgba(0, 0, 0, 0.2);
    }
    // background-color: orange;
    .chat-body {
      display: flex;
      flex-direction: column;
      padding-top: 23rpx;
      padding-bottom: 100rpx;

      // background-color:skyblue;

      .self {
        justify-content: flex-end;
      }
      .item {
        display: flex;
        padding: 23rpx 30rpx;
        // background-color: greenyellow;

        &.system {
          justify-content: center;
        }

        .right {
          background-color: $chatContentbgc;
        }
        .left {
          background-color: #ffffff;
        }
        .system {
          background-color: #f0f0f0;
          color: #666666;
          text-align: center;
        }
        // èŠå¤©æ¶ˆæ¯çš„ä¸‰è§’å½¢
        .right::after {
          position: absolute;
          display: inline-block;
          content: '';
          width: 0;
          height: 0;
          left: 100%;
          top: 10px;
          border: 12rpx solid transparent;
          border-left: 12rpx solid $chatContentbgc;
        }

        .left::after {
          position: absolute;
          display: inline-block;
          content: '';
          width: 0;
          height: 0;
          top: 10px;
          right: 100%;
          border: 12rpx solid transparent;
          border-right: 12rpx solid #ffffff;
        }

        .content {
          position: relative;
          max-width: 486rpx;
          border-radius: 8rpx;
          word-wrap: break-word;
          padding: 24rpx 24rpx;
          margin: 0 24rpx;
          border-radius: 5px;
          font-size: 32rpx;
          font-family: PingFang SC;
          font-weight: 500;
          color: #333333;
          line-height: 42rpx;
        }

        .reply-btn {
          margin-top: 8rpx;
          font-size: 24rpx;
          color: #4f7df5;
          text-align: right;
          padding-right: 8rpx;
        }

        .avatar {
          display: flex;
          justify-content: center;
          width: 78rpx;
          height: 78rpx;
          background: $sendBtnbgc;
          border-radius: 50rpx;
          overflow: hidden;

          image {
            align-self: center;
          }
        }
      }
    }
  }

  /* åº•éƒ¨èŠå¤©å‘é€æ  */
  .chat-bottom {
    width: 100%;
    height: 100rpx;
    background: #f4f5f7;
    transition: all 0.1s ease;
    position: fixed;
    bottom: 0;
    left: 0;
    z-index: 1;

    .send-msg {
      display: flex;
      align-items: center;
      padding: 16rpx 30rpx;
      width: 100%;
      min-height: 100rpx;
      background: #fff;
      transition: all 0.1s ease;
      z-index: 1;
    }

    .uni-textarea {
      padding-bottom: 0rpx;
      .textarea-container {
        display: flex;
        align-items: center;
      }
      .embed-btn.left-btn {
        margin-right: 10rpx;
        width: 120rpx;
        height: 60rpx;
        background: #f1f1f1;
        border-radius: 30rpx;
        font-size: 24rpx;
        color: #333333;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
      }
      textarea {
        width: 417rpx;
        min-height: 60rpx;
        max-height: 500rpx;
        background: #f1f1f1;
        border-radius: 30rpx;
        font-size: 28rpx;
        font-family: PingFang SC;
        color: #333333;
        line-height: 60rpx;
        padding: 5rpx 8rpx;
        text-indent: 30rpx;
      }
    }

    .send-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 0rpx;
      margin-left: 25rpx;
      width: 120rpx;
      height: 60rpx;
      background: #ed5a65;
      border-radius: 30rpx;
      font-size: 24rpx;
      font-family: PingFang SC;
      font-weight: 700;
      color: #ffffff;
      line-height: 24rpx;
      z-index: 1;
      outline: 2rpx solid #ffffff;
      box-shadow: 0 2rpx 10rpx rgba(237, 90, 101, 0.5);
    }
  }
}
</style>

```

Asp.net Core éƒ¨åˆ†ï¼Œè‡ªç„¶æ˜¯åˆ›å»ºä¸€ä¸ª SignalR çš„ä¸€ä¸ª Hub

```

using CacheManager.Core;
using FreeWorking.Business.App;
using FreeWorking.Domain;
using FreeWorking.Domain.Attribute;
using FreeWorking.Domain.Entities.App;
using FreeWorking.Domain.Enums;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;

namespace FreeWorking.App.Api.SignalR
{
    [AuthorizeRoles(RoleEnum.JobSeeker, RoleEnum.Recruiter)]
    public class ChatHub : Hub
    {
        private readonly ChatMessageService _chatMessageService;
        private readonly ContactRequestService _contactRequestService;
        private readonly IFreeWorkingDatabase _database;
        private readonly ICacheManager<object> _cache;
        private readonly ContactedRelationshipService _contactedRelationshipService;
        private readonly NotContactedRelationshipService _notContactedRelationshipService;

        public ChatHub(ChatMessageService chatMessageService, ContactRequestService contactRequestService, IFreeWorkingDatabase database, ICacheManager<object> cache, ContactedRelationshipService contactedRelationshipService, NotContactedRelationshipService notContactedRelationshipService)
        {
            _chatMessageService = chatMessageService;
            _contactRequestService = contactRequestService;
            _database = database;
            _cache = cache;
            _contactedRelationshipService = contactedRelationshipService;
            _notContactedRelationshipService = notContactedRelationshipService;
            OnlineUsers.Initialize(cache); // åˆå§‹åŒ–åœ¨çº¿ç”¨æˆ·ç®¡ç†çš„ç¼“å­˜
        }

        // å‘é€äº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚
        public async Task<bool> ExchangeContactRequest(long receiverId)
        {
            var senderId = Context.UserIdentifier!;
            var findSender = await _database.Set<UserEntity>().FirstOrDefaultAsync(u => u.Id == receiverId);
            var senderRole = findSender!.CurrentRole;

            // è·å–ç”¨æˆ·ä¿¡æ¯
            var senderUser = await _database.Set<UserEntity>().FirstOrDefaultAsync(u => u.Id.ToString() == senderId);
            var receiverUser = await _database.Set<UserEntity>().FirstOrDefaultAsync(u => u.Id == receiverId);

            // æ£€æŸ¥é»‘åå•å…³ç³»
            if (!await CheckBlacklistRelationship(senderUser, receiverUser))
            {
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å·²ç»å‘é€è¿‡è¯·æ±‚
            var existingRequest = await _contactRequestService.SingleExpressAsync(t =>
                ((t.RecruiterId.ToString() == senderId && t.SeekerId == receiverId) ||
                 (t.RecruiterId == receiverId && t.SeekerId.ToString() == senderId)) &&
                t.ApprovalStatus == ApprovalStatusEnum.Pending &&
                t.RequestItem == RequestItemTypeEnum.ContactInfo);

            if (existingRequest != null)
            {
                await Clients.Caller.SendAsync("ContactRequestAlreadySent");
                return false;
            }

            // åˆ›å»ºæ–°çš„è”ç³»æ–¹å¼è¯·æ±‚
            var contactRequest = new ContactRequestEntity
            {
                RecruiterId = senderRole == RoleEnum.Recruiter ? long.Parse(senderId) : receiverId,
                SeekerId = senderRole == RoleEnum.JobSeeker ? long.Parse(senderId) : receiverId,
                RequestItem = RequestItemTypeEnum.ContactInfo,
                InitiatorRole = (RoleEnum)senderRole!,
                RequestTime = DateTime.UtcNow,
                ApprovalStatus = ApprovalStatusEnum.Pending
            };

            await _contactRequestService.CreateAsync(contactRequest);

            // æ£€æŸ¥æ¥æ”¶æ–¹æ˜¯å¦åœ¨çº¿
            if (OnlineUsers.IsUserOnline(receiverId.ToString()))
            {
                await Clients.User(receiverId.ToString()).SendAsync("ReceiveContactRequest", senderId);
            }

            return true;
        }

        // åŒæ„äº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚
        public async Task ApproveContactRequest(string senderId)
        {
            var receiverId = Context.UserIdentifier!;
            //var receiverRole = Context.User.FindFirst(ClaimTypes.Role)?.Value == RoleEnum.Recruiter.ToString() ? RoleEnum.Recruiter : RoleEnum.JobSeeker;

            // æŸ¥æ‰¾å¯¹åº”çš„è¯·æ±‚
            var contactRequest = await _contactRequestService.SingleExpressAsync(t =>
                ((t.RecruiterId.ToString() == senderId && t.SeekerId.ToString() == receiverId) ||
                 (t.RecruiterId.ToString() == receiverId && t.SeekerId.ToString() == senderId)) &&
                t.ApprovalStatus == ApprovalStatusEnum.Pending &&
                t.RequestItem == RequestItemTypeEnum.ContactInfo);

            if (contactRequest == null)
            {
                return;
            }

            // æ›´æ–°è¯·æ±‚çŠ¶æ€
            contactRequest.ApprovalStatus = ApprovalStatusEnum.Approved;
            contactRequest.ProcessTime = DateTime.UtcNow;
            await _contactRequestService.UpdateAsync(contactRequest);

            // è·å–åŒæ–¹è”ç³»æ–¹å¼
            var receiverInfo = await GetUserContactInfo(receiverId);
            var senderInfo = await GetUserContactInfo(senderId);

            // é€šçŸ¥å‘é€æ–¹è¯·æ±‚å·²è¢«åŒæ„ï¼Œå¹¶å‘é€æ¥æ”¶æ–¹çš„è”ç³»æ–¹å¼
            if (OnlineUsers.IsUserOnline(senderId))
            {
                await Clients.User(senderId).SendAsync("ContactRequestApproved", receiverId, receiverInfo);
            }

            // é€šçŸ¥æ¥æ”¶æ–¹ï¼ˆå½“å‰ç”¨æˆ·ï¼‰ï¼Œå¹¶å‘é€å‘é€æ–¹çš„è”ç³»æ–¹å¼
            await Clients.Caller.SendAsync("ContactRequestApproved", senderId, senderInfo);

            // æ›´æ–°åŒæ–¹å…³ç³»çŠ¶æ€ä¸ºå·²äº¤æ¢è”ç³»æ–¹å¼
            long jobSeekerId = contactRequest.SeekerId;
            long employerId = contactRequest.RecruiterId;
            await _contactedRelationshipService.UpdateRelationshipStatusToContactExchangedAsync(jobSeekerId, employerId);

        }

        // æ‹’ç»äº¤æ¢è”ç³»æ–¹å¼è¯·æ±‚
        public async Task RejectContactRequest(string senderId)
        {
            var receiverId = Context.UserIdentifier!;

            // æŸ¥æ‰¾å¯¹åº”çš„è¯·æ±‚
            var contactRequest = await _contactRequestService.SingleExpressAsync(t =>
                ((t.RecruiterId.ToString() == senderId && t.SeekerId.ToString() == receiverId) ||
                 (t.RecruiterId.ToString() == receiverId && t.SeekerId.ToString() == senderId)) &&
                t.ApprovalStatus == ApprovalStatusEnum.Pending &&
                t.RequestItem == RequestItemTypeEnum.ContactInfo);

            if (contactRequest == null)
            {
                return;
            }

            // æ›´æ–°è¯·æ±‚çŠ¶æ€
            contactRequest.ApprovalStatus = ApprovalStatusEnum.Rejected;
            contactRequest.ProcessTime = DateTime.UtcNow;
            await _contactRequestService.UpdateAsync(contactRequest);

            // é€šçŸ¥å‘é€æ–¹è¯·æ±‚å·²è¢«æ‹’ç»
            if (OnlineUsers.IsUserOnline(senderId))
            {
                await Clients.User(senderId).SendAsync("ContactRequestRejected", receiverId);
            }
        }

        // è·å–ç”¨æˆ·è”ç³»æ–¹å¼ä¿¡æ¯
        private async Task<string> GetUserContactInfo(string userId)
        {
            // ä»æ•°æ®åº“ä¸­è·å–ç”¨æˆ·ä¿¡æ¯
            var user = await _database.Set<UserEntity>().FirstOrDefaultAsync(u => u.Id.ToString() == userId);
            if (user == null)
            {
                return "æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯";
            }

            // æ„å»ºè”ç³»æ–¹å¼ä¿¡æ¯
            var contactInfo = new List<string>();
            if (!string.IsNullOrEmpty(user.PhoneNumber))
            {
                contactInfo.Add($"ç”µè¯: {user.PhoneNumber}");
            }
            if (!string.IsNullOrEmpty(user.Email))
            {
                contactInfo.Add($"é‚®ç®±: {user.Email}");
            }

            // å¦‚æœæ²¡æœ‰è”ç³»æ–¹å¼ï¼Œè¿”å›é»˜è®¤æ¶ˆæ¯
            return contactInfo.Any() ? string.Join("ï¼Œ", contactInfo) : "æœªè®¾ç½®è”ç³»æ–¹å¼";
        }

        // å‘é€ç§èŠæ¶ˆæ¯ï¼ˆå«é˜²éªšæ‰°æœºåˆ¶å’Œé»‘åå•æ£€æŸ¥ï¼‰
        public async Task<bool> SendPrivateMessage(string receiverId, string message)
        {
            var senderId = Context.UserIdentifier!;
            var sessionKey = $"{senderId}_{receiverId}";

            // è·å–ç”¨æˆ·ä¿¡æ¯
            var senderUser = await _database.Set<UserEntity>().FirstOrDefaultAsync(u => u.Id.ToString() == senderId);
            var receiverUser = await _database.Set<UserEntity>().FirstOrDefaultAsync(u => u.Id.ToString() == receiverId);

            // æ£€æŸ¥é»‘åå•å…³ç³»
            if (!await CheckBlacklistRelationship(senderUser, receiverUser))
            {
                return false;
            }

            // è·å–æ¶ˆæ¯è®¡æ•°
            var (messageSendCount, messageReplyCount) = await GetMessageCounts(senderId, receiverId);

            // å¦‚æœå¯¹æ–¹å·²å›å¤ï¼Œåˆ é™¤æœªè”ç³»å…³ç³»è®°å½•
            //if (messageReplyCount > 0 && senderUser != null && receiverUser != null)
            //{
            //    await DeleteNotContactedRelationship(senderUser, receiverUser);
            //}

            // é˜²éªšæ‰°æ£€æŸ¥
            if (!await CheckAntiHarassment(messageSendCount, messageReplyCount))
            {
                return false;
            }

            // ä¿å­˜å¹¶å‘é€æ¶ˆæ¯
            return await SaveAndSendMessage(senderId, receiverId, message, sessionKey);
        }

        // æ£€æŸ¥é»‘åå•å…³ç³»
        private async Task<bool> CheckBlacklistRelationship(UserEntity? senderUser, UserEntity? receiverUser)
        {
            if (senderUser == null || receiverUser == null)
            {
                return true; // ç”¨æˆ·ä¸å­˜åœ¨ï¼Œä¸è¿›è¡Œæ£€æŸ¥
            }

            // åˆ¤æ–­åŒæ–¹è§’è‰²ï¼Œç¡®å®šæŸ¥è¯¢æ¡ä»¶
            if (senderUser.CurrentRole == RoleEnum.JobSeeker && receiverUser.CurrentRole == RoleEnum.Recruiter)
            {
                // æ±‚èŒè€…å‘æ‹›è˜è€…å‘é€æ¶ˆæ¯
                // æ£€æŸ¥æœªè”ç³»å…³ç³»è¡¨
                var notContactedRelationship = await _database.Set<NotContactedRelationshipEntity>()
                    .FirstOrDefaultAsync(r => r.JobSeekerId == senderUser.Id && r.RecruiterId == receiverUser.Id 
                    && r.Removed == false);

                if (notContactedRelationship != null && notContactedRelationship.JobSeekerToRecruiterRelation == NotContactedRelationStatusEnum.Rejected)
                {
                    //æ‚¨å·²å°†å¯¹æ–¹åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", 1);
                    return false;
                }

                if (notContactedRelationship != null && notContactedRelationship.RecruiterToJobSeekerRelation == NotContactedRelationStatusEnum.Rejected)
                {
                    //å¯¹æ–¹å·²å°†æ‚¨åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", 2);
                    return false;
                }

                // æ£€æŸ¥å·²è”ç³»å…³ç³»è¡¨
                var contactedRelationship = await _database.Set<ContactedRelationshipEntity>()
                    .FirstOrDefaultAsync(r => r.JobSeekerId == senderUser.Id && r.EmployerId == receiverUser.Id);

                if (contactedRelationship != null && contactedRelationship.JobSeekerRelationStatus == ContactedRelationStatusEnum.Blocked)
                {
                    //æ‚¨å·²å°†å¯¹æ–¹åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", 1);
                    return false;
                }

                if (contactedRelationship != null && contactedRelationship.EmployerRelationStatus == ContactedRelationStatusEnum.Blocked)
                {
                    //å¯¹æ–¹å·²å°†æ‚¨åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", 2);
                    return false;
                }
            }
            else if (senderUser.CurrentRole == RoleEnum.Recruiter && receiverUser.CurrentRole == RoleEnum.JobSeeker)
            {
                // æ‹›è˜è€…å‘æ±‚èŒè€…å‘é€æ¶ˆæ¯
                // æ£€æŸ¥æœªè”ç³»å…³ç³»è¡¨
                var notContactedRelationship = await _database.Set<NotContactedRelationshipEntity>()
                    .FirstOrDefaultAsync(r => r.RecruiterId == senderUser.Id && r.JobSeekerId == receiverUser.Id 
                    && r.Removed == false);

                if (notContactedRelationship != null && notContactedRelationship.RecruiterToJobSeekerRelation == NotContactedRelationStatusEnum.Rejected)
                {
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", "æ‚¨å·²å°†å¯¹æ–¹åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯");
                    return false;
                }

                if (notContactedRelationship != null && notContactedRelationship.JobSeekerToRecruiterRelation == NotContactedRelationStatusEnum.Rejected)
                {
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", "å¯¹æ–¹å·²å°†æ‚¨åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯");
                    return false;
                }

                // æ£€æŸ¥å·²è”ç³»å…³ç³»è¡¨
                var contactedRelationship = await _database.Set<ContactedRelationshipEntity>()
                    .FirstOrDefaultAsync(r => r.EmployerId == senderUser.Id && r.JobSeekerId == receiverUser.Id);

                if (contactedRelationship != null && contactedRelationship.EmployerRelationStatus == ContactedRelationStatusEnum.Blocked)
                {
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", "æ‚¨å·²å°†å¯¹æ–¹åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯");
                    return false;
                }

                if (contactedRelationship != null && contactedRelationship.JobSeekerRelationStatus == ContactedRelationStatusEnum.Blocked)
                {
                    await Clients.Caller.SendAsync("BlacklistMessageBlocked", "å¯¹æ–¹å·²å°†æ‚¨åŠ å…¥é»‘åå•ï¼Œæ— æ³•å‘é€æ¶ˆæ¯");
                    return false;
                }
            }

            return true;
        }

        // è·å–æ¶ˆæ¯è®¡æ•°
        private async Task<(int SendCount, int ReplyCount)> GetMessageCounts(string senderId, string receiverId)
        {
            var sendCount = await _chatMessageService.CountAsync(t =>
                t.SenderId == senderId && t.ReceiverId == receiverId);
            
            var replyCount = await _chatMessageService.CountAsync(t =>
                t.SenderId == receiverId && t.ReceiverId == senderId);
            
            return (sendCount, replyCount);
        }

        // åˆ é™¤æœªè”ç³»å…³ç³»è®°å½•
        private async Task DeleteNotContactedRelationship(UserEntity senderUser, UserEntity receiverUser)
        {
            if (senderUser.CurrentRole == RoleEnum.JobSeeker && receiverUser.CurrentRole == RoleEnum.Recruiter)
            {
                // åˆ é™¤æ±‚èŒè€…ä¸æ‹›è˜è€…çš„æœªè”ç³»å…³ç³»
                var relationship = await _database.Set<NotContactedRelationshipEntity>()
                    .FirstOrDefaultAsync(r => r.JobSeekerId == senderUser.Id && r.RecruiterId == receiverUser.Id 
                    && r.Removed == false);
                
                if (relationship != null)
                {
                    await _notContactedRelationshipService.RemoveAsync(relationship);
                }
            }
            else if (senderUser.CurrentRole == RoleEnum.Recruiter && receiverUser.CurrentRole == RoleEnum.JobSeeker)
            {
                // åˆ é™¤æ‹›è˜è€…ä¸æ±‚èŒè€…çš„æœªè”ç³»å…³ç³»
                var relationship = await _database.Set<NotContactedRelationshipEntity>()
                    .FirstOrDefaultAsync(r => r.RecruiterId == senderUser.Id && r.JobSeekerId == receiverUser.Id 
                    && r.Removed == false);
                
                if (relationship != null)
                {
                    await _notContactedRelationshipService.RemoveAsync(relationship);
                }
            }
        }

        // é˜²éªšæ‰°æ£€æŸ¥
        private async Task<bool> CheckAntiHarassment(int sendCount, int replyCount)
        {
            if (sendCount > 0 && replyCount == 0)
            {
                await Clients.Caller.SendAsync("Blocked", "è¯·ç­‰å¾…å¯¹æ–¹å›å¤åå†å‘é€æ–°æ¶ˆæ¯");
                return false;
            }
            return true;
        }

        // ä¿å­˜å¹¶å‘é€æ¶ˆæ¯
        private async Task<bool> SaveAndSendMessage(string senderId, string receiverId, string message, string sessionKey)
        {
            // ä¿å­˜æ¶ˆæ¯ï¼ˆå«15å¤©è¿‡æœŸæ—¶é—´ï¼‰
            var chatMessage = new ChatMessageEntity
            {
                SenderId = senderId,
                ReceiverId = receiverId,
                Content = message,
                SentTime = DateTime.UtcNow,
                ExpireTime = DateTime.UtcNow.AddDays(15),
                IsDelivered = false
            };
            await _chatMessageService.CreateAsync(chatMessage);

            // æ ‡è®°ä¸ºç­‰å¾…å›å¤çŠ¶æ€
            _cache.Put(sessionKey, receiverId);

            // æ£€æŸ¥æ¥æ”¶æ–¹åœ¨çº¿çŠ¶æ€
            if (OnlineUsers.IsUserOnline(receiverId))
            {
                await Clients.User(receiverId).SendAsync("ReceiveMessage", senderId, message);
                chatMessage.IsDelivered = true;
                await _chatMessageService.UpdateAsync(chatMessage);
            }
            return true;
        }

        // ç”¨æˆ·è¿æ¥æ—¶å¤„ç†ç¦»çº¿æ¶ˆæ¯å’Œå†å²æ¶ˆæ¯
        public override async Task OnConnectedAsync()
        {
            var userId = Context.UserIdentifier!;
            OnlineUsers.AddUser(userId);

            // è·å–å¹¶æŒ‰æ—¶é—´é¡ºåºå‘é€å†å²æ¶ˆæ¯å’Œæœªé€è¾¾æ¶ˆæ¯
            // 1. è·å–æ‰€æœ‰æœªé€è¾¾æ¶ˆæ¯
            var undeliveredMessages = await _chatMessageService.ListExpressAsync(m =>
                (m.ReceiverId == userId || m.SenderId == userId) && m.IsDelivered == false
            );

            // 2. è·å–æ‰€æœ‰å·²é€è¾¾æ¶ˆæ¯ï¼ˆç”¨äºæŒ‰å¯¹è¯åˆ†ç»„ï¼‰
            var deliveredMessages = await _chatMessageService.ListExpressAsync(m =>
                (m.ReceiverId == userId || m.SenderId == userId) && m.IsDelivered == true
            );

            // 3. åˆå¹¶æ‰€æœ‰æ¶ˆæ¯
            var allMessages = new List<ChatMessageEntity>();
            if (deliveredMessages != null)
                allMessages.AddRange(deliveredMessages);
            if (undeliveredMessages != null)
                allMessages.AddRange(undeliveredMessages);

            // 4. æŒ‰å¯¹è¯IDåˆ†ç»„ï¼ˆå¯¹è¯IDç”±ä¸¤ä¸ªç”¨æˆ·IDç»„æˆï¼ŒæŒ‰å­—æ¯é¡ºåºæ’åºç¡®ä¿ä¸€è‡´æ€§ï¼‰
            var conversationGroups = allMessages
                .GroupBy(m =>
                {
                    var ids = new[] { m.SenderId, m.ReceiverId };
                    Array.Sort(ids);
                    return $"{ids[0]}_{ids[1]}";
                })
                .ToList();

            // 5. å¯¹æ¯ä¸ªå¯¹è¯çš„æ¶ˆæ¯æŒ‰æ—¶é—´é¡ºåºæ’åºå¹¶å‘é€
            foreach (var group in conversationGroups)
            {
                var sortedMessages = group.OrderBy(m => m.SentTime).ToList();

                // åªå‘é€æ¯ä¸ªå¯¹è¯çš„æœ€è¿‘30æ¡æ¶ˆæ¯
                //if (sortedMessages.Count > 30)
                //{
                //    sortedMessages = sortedMessages.Skip(sortedMessages.Count - 30).ToList();
                //}

                foreach (var msg in sortedMessages)
                {
                    await Clients.Caller.SendAsync("ReceiveMessage", msg.SenderId, msg.Content);
                    // æ ‡è®°æœªé€è¾¾æ¶ˆæ¯ä¸ºå·²é€è¾¾
                    if (!msg.IsDelivered)
                    {
                        msg.IsDelivered = true;
                        await _chatMessageService.UpdateAsync(msg);
                    }
                }
            }

            await base.OnConnectedAsync();
        }

        // ç”¨æˆ·æ–­å¼€è¿æ¥å¤„ç†
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var userId = Context.UserIdentifier!;
            OnlineUsers.RemoveUser(userId);
            await base.OnDisconnectedAsync(exception);
        }
    }

    // åœ¨çº¿ç”¨æˆ·ç®¡ç†ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
    public static class OnlineUsers
    {
        private static ICacheManager<object> _cache;

        // è®¾ç½®ç¼“å­˜ç®¡ç†å™¨
        public static void Initialize(ICacheManager<object> cache)
        {
            _cache = cache;
        }

        private static string GetUserOnlineKey(string userId) => $"online_user:{userId}";

        public static void AddUser(string userId)
        {
            var cacheItem = new CacheItem<object>(
                GetUserOnlineKey(userId),
                true,
                ExpirationMode.Absolute,
                TimeSpan.FromMinutes(30)
            );
            _cache.Put(cacheItem); // è®¾ç½®30åˆ†é’Ÿè¿‡æœŸ
        }

        public static void RemoveUser(string userId) =>
            _cache.Remove(GetUserOnlineKey(userId));

        public static bool IsUserOnline(string userId) =>
            _cache.Get<bool?>(GetUserOnlineKey(userId)) ?? false;
    }
}

```



