---
layout: post
title: "从-Prop-Drilling-到-ContextReact-状态管理的演进与抉择"
date: 2025-03-16 19:18:21 +0800
description: "redux的核心是发布订阅模式，zustand核心是观察者模式，从设计模式角度，redux比zustand多了事件总线用来派发任务，在任务量大的情况下由于发布订阅模式的中间件及事件派发会像虚拟dom一样造成一定的性能损耗，所以性能不如观察者模式，延迟也相对较高。发布订阅模式其实就是观察者模式的升级，多了一个用于派发的中间件（事件总线），发布者和订阅者不直接通信，耦合度较低；Context 依赖组件树，耦合度高，而 Zustand 独立于组件树，灵活性更高。2.难以维护（这个就不用多说了吧，可读性很差）"
keywords: "从 Prop Drilling 到 Context：React 状态管理的演进与抉择"
categories: ['前端开发']
tags: ['开发语言', '前端框架', '前端', 'Vue', 'React', 'Javascript', 'Ecmascript']
artid: "146299723"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146299723
    alt: "从-Prop-Drilling-到-ContextReact-状态管理的演进与抉择"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146299723
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146299723
cover: https://bing.ee123.net/img/rand?artid=146299723
image: https://bing.ee123.net/img/rand?artid=146299723
img: https://bing.ee123.net/img/rand?artid=146299723
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     从 Prop Drilling 到 Context：React 状态管理的演进与抉择
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="Context_1">
     </a>
     Context的出现解决了什么问题？
    </h4>
    <p>
     Vue中的provide/inject和React中的Context非常相似，具体区别如下：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3c63c90b2c3043e8a38484e390057764.png#pic_center"/>
    </p>
    <p>
     可以看到实际上最大的区别在于Vue是响应式，React是非响应式
    </p>
    <p>
     那么context具体解决了什么问题？我们先看下面这个例子：
    </p>
    <pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>ComponentB count<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ComponentB</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{<!-- --></span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>ComponentC count<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ComponentC</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{<!-- --></span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>ComponentD count<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ComponentD</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{<!-- --></span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>ComponentE count<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>count<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ComponentE</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{<!-- --></span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     这种层层传递的形式就是典型的prop drilling (prop下钻)，会产生什么问题？
    </p>
    <p>
     1.性能损耗（props改变会导致所有传递组件重新渲染）
    </p>
    <p>
     2.难以维护（这个就不用多说了吧，可读性很差）
    </p>
    <p>
     3.心智负担（react经典问题）
    </p>
    <p>
     **那使用Context足够完美吗？**当然是不够，Context依旧有性能损耗问题，Context中任意的属性变化会引起所有使用该Context的组件发生re-render(重新渲染)，及无法只订阅局部变量，如何解决：
     <br/>
     1.拆分Context，保证每个组件有属于自己的独立依赖空间且各组件间互不影响。
    </p>
    <p>
     2.使用memo或者useMemo包裹组件（常见的react优化）。
    </p>
    <h4>
     <a id="Context_50">
     </a>
     为什么有Context还需要状态管理库，区别是什么？
    </h4>
    <p>
     根据上文我们可以知道context在优化是可以满足全局状态管理的需求的，那为什么还是要使用zustand这种状态管理库呢？
    </p>
    <p>
     Context 可以实现全局状态管理，但优化（如避免重复渲染）会增加代码复杂度和心智负担，且功能性有限。Zustand 提供选择性订阅、异步支持等特性，易用性更强。
    </p>
    <p>
     Context 依赖组件树，耦合度高，而 Zustand 独立于组件树，灵活性更高。Context 优势在于轻量、无依赖，适合简单场景。
    </p>
    <h4>
     <a id="_58">
     </a>
     状态管理库与设计模式
    </h4>
    <p>
     redux的核心是发布订阅模式，而zustand等大部分状态管理库的核心是观察者模式。
    </p>
    <p>
     如何理解观察者模式？vue的响应式核心就是使用的观察者模式，一个观察者和多个被观察者直接通信，耦合度较高；发布订阅模式其实就是观察者模式的升级，多了一个用于派发的中间件（事件总线），发布者和订阅者不直接通信，耦合度较低；
    </p>
    <h4>
     <a id="reduxzustand_64">
     </a>
     redux和zustand有什么区别
    </h4>
    <p>
     redux的核心是发布订阅模式，zustand核心是观察者模式，从设计模式角度，redux比zustand多了事件总线用来派发任务，在任务量大的情况下由于发布订阅模式的中间件及事件派发会像虚拟dom一样造成一定的性能损耗，所以性能不如观察者模式，延迟也相对较高。
    </p>
    <p>
     所以zustand就像一个功能性更强的全局useState更加轻量易用适合中小型项目，而redux更适合像企业级电商那种需要大量且复杂状态管理的情况。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37343039393138342f:61727469636c652f64657461696c732f313436323939373233" class_="artid" style="display:none">
 </p>
</div>


