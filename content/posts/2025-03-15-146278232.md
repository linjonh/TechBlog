---
layout: post
title: "Linux操作系统6-线程2线程的创建,终止,等待与退出"
date: 2025-03-15 15:34:03 +0800
description: "Linux中POXSIX线程库用于控制线程，线程等待创建于终止，等待与退出"
keywords: "Linux操作系统6- 线程2（线程的创建，终止，等待与退出）"
categories: ['Linux']
tags: ['线程控制', '服务器', '开发语言', '多线程', 'Linux', 'C']
artid: "146278232"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146278232
    alt: "Linux操作系统6-线程2线程的创建,终止,等待与退出"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146278232
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146278232
cover: https://bing.ee123.net/img/rand?artid=146278232
image: https://bing.ee123.net/img/rand?artid=146278232
img: https://bing.ee123.net/img/rand?artid=146278232
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux操作系统6- 线程2（线程的创建，终止，等待与退出）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      上篇文章：
      <a href="https://blog.csdn.net/yzcllzx/article/details/146138073?spm=1001.2014.3001.5501" title="Linux操作系统6- 线程1（线程基础，调用接口，线程优缺点）-CSDN博客">
       Linux操作系统6- 线程1（线程基础，调用接口，线程优缺点）-CSDN博客
      </a>
     </p>
     <p>
      本篇Gitee仓库：
      <a href="https://gitee.com/yzc-YZC/linux-learning/tree/master/myLerningCode/l28" rel="nofollow" title="myLerningCode/l28 · 橘子真甜/Linux操作系统与网络编程学习 - 码云 - 开源中国 (gitee.com)">
       myLerningCode/l28 · 橘子真甜/Linux操作系统与网络编程学习 - 码云 - 开源中国 (gitee.com)
      </a>
     </p>
    </blockquote>
    <p>
     进程：承担操作系统分配资源的基本单位
    </p>
    <p>
     线程：CPU调度的基本单位，是进程内的执行流。在Linux中，使用轻量级进程模拟线程
    </p>
    <p>
     本文的线程操作都是POSIX线程控制库。
     <strong>
      链接这些线程库需要在编译的时候加上 -lpthread
     </strong>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80.%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BApthread_create%C2%A0" name="%E4%B8%80.%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BApthread_create%C2%A0">
     一. 线程创建pthread_create
    </h2>
    <p>
     调用接口原型
    </p>
    <pre><code class="language-cpp">//所需头文件
#include &lt;pthread.h&gt;

//用于创建一个线程并执行对应函数
int pthread_create(pthread_t* thread, const pthread_attr_t *attr, void*(*start_rountine)(void*), void* args);

// thread    输入输出型参数，表示创造线程的tid

// attr      用于控制线程的属性，一般设置为nullptr

// start_rountine    一个函数指针，表示要线程执行的函数

// args             一个void*参数，线程创建后，将这个参数传递给start_routine的参数列表

//成功返回0，失败返回-1，并且设置错误码
</code></pre>
    <p>
     args参数是void*类型的，所以我们能够传递任意参数让其接收。
    </p>
    <p>
     测试代码：
    </p>
    <p>
     <span style="background-color:null">
      <span style="color:null">
       我们使用vector保存线程的tid，同时创建一批线程，并且通过arg参数传递一个string类型作为线程的名字
      </span>
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
int gnum = 5;

void *start_routine(void *args)
{
    std::string name = static_cast&lt;const char *&gt;(args);
    while (true)
    {
        std::cout &lt;&lt; "我是新线程,我的名字是" &lt;&lt; name &lt;&lt; "pid为:" &lt;&lt; getpid() &lt;&lt; std::endl;
        sleep(1);
    }
}

int main()
{
    std::vector&lt;pthread_t&gt; tids(gnum);
    for (int i = 0; i &lt; tids.size(); ++i)
    {
        std::string name = "thread" + std::to_string(i);
        pthread_create(&amp;tids[i], nullptr, start_routine, (void *)name.c_str());
    }

    while (true)
    {
        std::cout &lt;&lt; "我是主线程,我的pid为:" &lt;&lt; getpid() &lt;&lt; std::endl;
        sleep(1);
    }
    return 0;
}</code></pre>
    <p>
     测试结果如下：
    </p>
    <p>
     <img alt="" height="551" src="https://i-blog.csdnimg.cn/direct/c79b2fd5140d4b838de48e0f3f7a808e.png" width="821"/>
    </p>
    <p>
     可以看到，我们创建了4个新线程，它们的pid相同。
     <strong>
      但是它们的名字为何没有0，2和3呢？
     </strong>
     这是因为我们的name是同一个name，销毁后，线程仍访问这块销毁空间。
    </p>
    <p>
     <strong>
      所以这里我们需要定义一个结构体来保存数据。
     </strong>
    </p>
    <p>
     示例代码：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
int gnum = 5;

struct ThreadData
{
    pthread_t tid;
    std::string name;
};

void *start_routine(void *args)
{
    ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
    while (true)
    {
        std::cout &lt;&lt; "我是新线程,我的名字是:" &lt;&lt; td-&gt;name &lt;&lt; " pid为:" &lt;&lt; getpid() &lt;&lt; std::endl;
        sleep(1);
    }
}

int main()
{
    std::vector&lt;ThreadData *&gt; tids(gnum);
    for (int i = 0; i &lt; tids.size(); ++i)
    {
        // 在堆中创建数据
        ThreadData *td = new ThreadData();
        td-&gt;name = "Thread " + std::to_string(i);
        pthread_create(&amp;td-&gt;tid, nullptr, start_routine, (void *)td);
        tids[i] = td;
    }

    while (true)
    {
        std::cout &lt;&lt; "我是主线程,我的pid为:" &lt;&lt; getpid() &lt;&lt; " " &lt;&lt; std::endl;
        sleep(1);
    }
    return 0;
}</code></pre>
    <p>
     测试结果如下：
    </p>
    <p>
     <img alt="" height="653" src="https://i-blog.csdnimg.cn/direct/26a8660785e04b1ba2c96279878643c5.png" width="1109">
      如果在线程的执行流中定义变量，这些变量是线程独有的
     </img>
    </p>
    <p>
     修改start_routine
    </p>
    <pre><code class="language-cpp">void *start_routine(void *args)
{
    int cnt = 10;
    ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
    while (true)
    {
        std::cout &lt;&lt; "我是新线程,我的名字是:" &lt;&lt; td-&gt;name &lt;&lt; "cnt:" &lt;&lt; cnt-- &lt;&lt; "cnt 地址为:" &lt;&lt; &amp;cnt &lt;&lt; std::endl;
        sleep(1);
    }
}</code></pre>
    <p>
     运行结果如下：可以看到，每一个线程中的cnt的地址都是不一样的。
     <strong>
      这说明每一个线程都有自己独立的栈资源
     </strong>
    </p>
    <p>
     <img alt="" height="320" src="https://i-blog.csdnimg.cn/direct/48e25542e58f475eb390bf856a25414a.png" width="1195"/>
    </p>
    <h2 id="%E4%BA%8C.%C2%A0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2" name="%E4%BA%8C.%C2%A0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2" style="background-color:transparent">
     二. 线程的终止
    </h2>
    <p>
     如果线程调用exit()会导致整个线程终止。
    </p>
    <p>
     测试代码如下：
     <strong>
      在cnt为5的时候，线程调用exit进行终止
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
int gnum = 5;

struct ThreadData
{
    pthread_t tid;
    std::string name;
};

void *start_routine(void *args)
{
    int cnt = 10;
    ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
    while (true)
    {
        if (cnt == 5)
            exit(1);
        std::cout &lt;&lt; "我是新线程,我的名字是:" &lt;&lt; td-&gt;name &lt;&lt; " cnt:" &lt;&lt; cnt-- &lt;&lt; " cnt 地址为:" &lt;&lt; &amp;cnt &lt;&lt; std::endl;
        sleep(1);
    }
}

int main()
{
    std::vector&lt;ThreadData *&gt; tids(gnum);
    for (int i = 0; i &lt; tids.size(); ++i)
    {
        // 在堆中创建数据
        ThreadData *td = new ThreadData();
        td-&gt;name = "Thread " + std::to_string(i);
        pthread_create(&amp;td-&gt;tid, nullptr, start_routine, (void *)td);
        tids[i] = td;
    }

    while (true)
    {
        std::cout &lt;&lt; "我是主线程,我的pid为:" &lt;&lt; getpid() &lt;&lt; " " &lt;&lt; std::endl;
        sleep(1);
    }
    return 0;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/17cae42102884288ad147c4e44bc249f.png" width="895"/>
    </p>
    <p>
     可以看到，线程调用exit会导致整个进程退出。
     <strong>
      exit是用于进程终止，而不是用于某一个线程的终止。
     </strong>
    </p>
    <p>
     <strong>
      线程终止是当线程的函数执行完毕就会自动退出。
     </strong>
    </p>
    <p>
     修改start_routine：当cnt为0的时候，退出循环。以返回的形式终止线程
    </p>
    <pre><code class="language-cpp">void *start_routine(void *args)
{
    int cnt = 10;
    ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
    while (cnt--)
    {
        std::cout &lt;&lt; "我是新线程,我的名字是:" &lt;&lt; td-&gt;name &lt;&lt; " cnt:" &lt;&lt; cnt &lt;&lt; " cnt 地址为:" &lt;&lt; &amp;cnt &lt;&lt; std::endl;
        sleep(1);
    }
    return nullptr;
}</code></pre>
    <p>
     运行结果如下：
    </p>
    <p>
     <img alt="" height="727" src="https://i-blog.csdnimg.cn/direct/880a982a8e1a4e27918bb28753f7dfc4.png" width="1575"/>
    </p>
    <h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20pthread_exit" name="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20pthread_exit">
     2.1 pthread_exit
    </h3>
    <p>
     可以通过pthread_exit退出线程。效果与return是一样的
    </p>
    <pre><code class="language-cpp">//函数原型
void pthread_exit(void* retval)</code></pre>
    <p>
     pthread_exit的效果与函数内使用return的效果是一样的，这里就不过多解释
    </p>
    <h2 id="%E4%B8%89.%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%80%E5%87%BA" name="%E4%B8%89.%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%80%E5%87%BA">
     三. 线程的等待与退出
    </h2>
    <p>
     与进程等待一样，线程也需要等待。
     <strong>
      如果不等待线程，线程对应的pcb可能不会被释放。就会造成类似僵尸进程一样的资源泄露。
     </strong>
    </p>
    <blockquote>
     <p>
      线程等待的作用
     </p>
     <p>
      1
      <strong>
       等待线程退出的资源与信息（通过 return 的返回值获取）
      </strong>
     </p>
     <p>
      <strong>
       2 回收线程的pcb与内核资源防止资源泄露
      </strong>
     </p>
     <p>
      <strong>
      </strong>
      <strong>
       当然我们可以不获取线程退出的信息，但是必须收回线程的资源
      </strong>
     </p>
    </blockquote>
    <h3 id="3.1%20pthread_join" name="3.1%20pthread_join">
     3.1 pthread_join
    </h3>
    <p>
     pthread_join用于主线程等待新线程的退出。通过输入输出型参数，可以获取主线程退出的信息和需要传递给主线程的资源。
     <strong>
      同时会回收新线程的pcb和内核资源。
     </strong>
    </p>
    <pre><code class="language-cpp">//所需头文件
#include &lt;pthread.h&gt;

//函数原型
int pthread_join(pthread_t thread, void** retval)

//参数说明
thread:需要等待的线程
retval：输入输出型参数，通过指针的方法来获取我们的退出值</code></pre>
    <p>
     测试代码：主线程一次性等待所有的新线程
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
int gnum = 5;

struct ThreadData
{
    pthread_t tid;
    std::string name;
};

void *start_routine(void *args)
{
    int cnt = 10;
    ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
    while (cnt--)
    {
        std::cout &lt;&lt; "我是新线程,我的名字是:" &lt;&lt; td-&gt;name &lt;&lt; " cnt:" &lt;&lt; cnt &lt;&lt; " cnt 地址为:" &lt;&lt; &amp;cnt &lt;&lt; std::endl;
        sleep(1);
    }
    return nullptr;
}

int main()
{
    std::vector&lt;ThreadData *&gt; tds(gnum);
    for (int i = 0; i &lt; tds.size(); ++i)
    {
        // 在堆中创建数据
        ThreadData *td = new ThreadData();
        td-&gt;name = "Thread " + std::to_string(i);
        pthread_create(&amp;td-&gt;tid, nullptr, start_routine, (void *)td);
        tds[i] = td;
    }

    for (const auto &amp;td : tds)
    {
        int n = pthread_join(td-&gt;tid, nullptr); // 使用bullptr表示不关心线程退出的状态与信息
        if (n != 0)
            std::cout &lt;&lt; "线程退出失败" &lt;&lt; std::endl;
        std::cout &lt;&lt; "主线程成功等待新线程:" &lt;&lt; td-&gt;name &lt;&lt; std::endl;
    }

    while (true)
    {
        std::cout &lt;&lt; "我是主线程,我的pid为:" &lt;&lt; getpid() &lt;&lt; " " &lt;&lt; std::endl;
        sleep(1);
    }
    return 0;
}</code></pre>
    <p>
     测试结果如下：
     <strong>
      可以看到，主线程成功等待了所有等待新线程
     </strong>
    </p>
    <p>
     <img alt="" height="429" src="https://i-blog.csdnimg.cn/direct/e538462a3d334364ac22b7a523323767.png" width="1308">
     </img>
    </p>
    <h3 id="3.2%20%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%C2%A0" name="3.2%20%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%C2%A0">
     3.2 线程退出信息
    </h3>
    <p>
     <strong>
      无论是return还是调用pthread_join退出的信息都是 void*retval。pthread_join通过输入输出型参数 voidd**retval来获取退出信息。
     </strong>
    </p>
    <p>
     测试代码如下：
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
int gnum = 5;

struct ThreadData
{
    pthread_t tid;
    std::string name;
};

struct ThreadReturn
{
    int exit_code;
    int exit_result;
};

void *start_routine(void *args)
{
    int cnt = 10;
    ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
    while (cnt--)
    {
        std::cout &lt;&lt; "我是新线程,我的名字是:" &lt;&lt; td-&gt;name &lt;&lt; " cnt:" &lt;&lt; cnt &lt;&lt; " cnt 地址为:" &lt;&lt; &amp;cnt &lt;&lt; std::endl;
        sleep(1);
    }
    ThreadReturn *tr = new ThreadReturn(); // 堆中创建的数据才能正常返回
    tr-&gt;exit_code = 0;
    tr-&gt;exit_result = td-&gt;tid;
    return (void *)tr; // 退出线程的信息结构体
}

int main()
{
    std::vector&lt;ThreadData *&gt; tds(gnum);
    for (int i = 0; i &lt; tds.size(); ++i)
    {
        // 在堆中创建数据
        ThreadData *td = new ThreadData();
        td-&gt;name = "Thread " + std::to_string(i);
        pthread_create(&amp;td-&gt;tid, nullptr, start_routine, (void *)td);
        tds[i] = td;
    }

    for (const auto &amp;td : tds)
    {
        ThreadReturn *tr;                            // 用于获取线程退出的信息
        int n = pthread_join(td-&gt;tid, (void **)&amp;tr); // 使用bullptr表示不关心线程退出的状态与信息
        if (n != 0)
            std::cout &lt;&lt; "线程退出失败" &lt;&lt; std::endl;
        std::cout &lt;&lt; "主线程成功等待新线程:" &lt;&lt; td-&gt;name;
        std::cout &lt;&lt; " 该线程退出大队信息为 " &lt;&lt; "exitcode:" &lt;&lt; tr-&gt;exit_code &lt;&lt; " exit_result:" &lt;&lt; tr-&gt;exit_result &lt;&lt; std::endl;
    }

    while (true)
    {
        std::cout &lt;&lt; "我是主线程,我的pid为:" &lt;&lt; getpid() &lt;&lt; " " &lt;&lt; std::endl;
        sleep(1);
    }
    return 0;
}</code></pre>
    <p>
     测试结果如下：
    </p>
    <p>
     <img alt="" height="409" src="https://i-blog.csdnimg.cn/direct/66c4e53ab2e64c1e8a587c5384b6ea14.png" width="1186"/>
    </p>
    <blockquote>
     <p>
      在进程退出中，
      <strong>
       我们会关心进程的退出码和退出信号。
      </strong>
     </p>
     <p>
      <strong>
       而线程不用关心异常信号，因为一旦出现异常信号整个进程都会退出。
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f797a636c6c7a782f:61727469636c652f64657461696c732f313436323738323332" class_="artid" style="display:none">
 </p>
</div>


