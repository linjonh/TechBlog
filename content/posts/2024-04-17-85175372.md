---
layout: post
title: "终身规划A算法LPALifelong-Planning-A"
date: 2024-04-17 20:48:54 +0800
description: "本文深入探讨了终身规划A*算法（LPA*），一种基于A*的增量启发式搜索算法，适用于动态环境下的路径"
keywords: "终身规划a*"
categories: ['路径规划']
tags: ['路径规划', '搜索算法', 'Lpa', 'A']
artid: "85175372"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=85175372
    alt: "终身规划A算法LPALifelong-Planning-A"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=85175372
featuredImagePreview: https://bing.ee123.net/img/rand?artid=85175372
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     终身规划A*算法（LPA*）：Lifelong Planning A*
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      终身规划A*算法（LPA*）：Lifelong Planning A*
     </h4>
     <ul>
      <li>
       <a href="#1_3" rel="nofollow">
        1.描述
       </a>
      </li>
      <li>
       <a href="#2_8" rel="nofollow">
        2.父代节点与子代节点
       </a>
      </li>
      <li>
       <a href="#3_16" rel="nofollow">
        3.起始距离估计
       </a>
      </li>
      <li>
       <a href="#4_25" rel="nofollow">
        4.优先队列
       </a>
      </li>
      <li>
       <a href="#5_41" rel="nofollow">
        5.节点状态及扩展
       </a>
      </li>
      <li>
       <a href="#6_53" rel="nofollow">
        6.初始化运行
       </a>
      </li>
      <li>
       <a href="#7_61" rel="nofollow">
        7.最短路径搜索
       </a>
      </li>
      <li>
       <a href="#8_67" rel="nofollow">
        8.伪代码
       </a>
      </li>
      <li>
       <a href="#9_140" rel="nofollow">
        9.性质
       </a>
      </li>
      <li>
       <a href="#10_154" rel="nofollow">
        10.符号表示
       </a>
      </li>
      <li>
       <a href="#11_193" rel="nofollow">
        11.算法示例推演
       </a>
      </li>
      <li>
       <a href="#12_221" rel="nofollow">
        12.总结
       </a>
      </li>
      <li>
       <a href="#13_224" rel="nofollow">
        13.对公式的进一步理解
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_295" rel="nofollow">
          伪代码
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_328" rel="nofollow">
        参考资料
       </a>
      </li>
      <li>
       <a href="#font_colorredfont_336" rel="nofollow">
        <font color="red">
         搜索算法其他文章
        </font>
       </a>
      </li>
     </ul>
    </div>
    <br/>
    LPA_start或life Planning A_star是一种基于A*的增量启发式搜索算法。2001年，斯文·柯尼格(Sven Koenig)和马克西姆·利卡切夫(Maxim Likhachev)首次提出。
    <p>
    </p>
    <h2>
     <a id="1_3">
     </a>
     1.描述
    </h2>
    <p>
     LPA_star是A_star的增量版本，它可以适应图形中的变化而无需重新计算整个图形，方法是在当前搜索期间更新前一次搜索的g值（从开始起的距离），以便在必要时进行更正。与A_star一样，LPA*使用启发式算法，该启发性来源于从给定节点到目标路径代价的更低边界。如果保证是非负的（零可以接受）并且从不大于到目标的最低路径的代价，则允许该启发式。
    </p>
    <p>
     启发式搜索和增量式搜索的区别在于，启发式搜索是利用启发函数来对搜索进行指导，从而实现高效的搜索，启发式搜索是一种“智能”搜索，典型的算法例如A_star算法、遗传算法等。增量搜索是对以前的搜索结果信息进行再利用来实现高效搜索，大大减少搜索范围和时间，典型的例如LPA_star、D_star Lite算法等。
    </p>
    <h2>
     <a id="2_8">
     </a>
     2.父代节点与子代节点
    </h2>
    <p>
     除了开始节点和目标节点外，每个节点n都有上一代和下一代节点：
    </p>
    <ul>
     <li>
      任何一条边指向n的节点都是n的前一代；
     </li>
     <li>
      从n引出一条边的任何节点都是n的后继节点。
     </li>
    </ul>
    <p>
     在下面的描述中，这两个术语仅指直接的父代（上一代）和子代（下一代），不指父代的父代或子代的子代。
    </p>
    <h2>
     <a id="3_16">
     </a>
     3.起始距离估计
    </h2>
    <p>
     LPA_star对每个节点的起始距离g_star(n)保持两个估计值：
    </p>
    <ul>
     <li>
      g(n)为之前计算的g值(起始距离)，如在A*中的含义；
     </li>
     <li>
      rhs（n），一个基于节点父代（上一代）的g值的预测值（所有g（n’）+d（n’，n）的最小值，其中n’是n的父代，d（x，y）是连接x和y的边的代价）。
      <br/>
      对于开始节点，以下始终为真：
      <br/>
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         r 
         
        
          h 
         
        
          s 
         
        
          ( 
         
        
          s 
         
        
          t 
         
        
          a 
         
        
          r 
         
        
          t 
         
        
          ) 
         
        
          = 
         
        
          g 
         
        
          ( 
         
        
          s 
         
        
          t 
         
        
          a 
         
        
          r 
         
        
          t 
         
        
          ) 
         
        
          = 
         
        
          0 
         
        
       
         rhs(start)=g(start)=0
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathit" style="margin-right: 0.02778em;">
           r
          </span>
          <span class="mord mathit">
           h
          </span>
          <span class="mord mathit">
           s
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathit">
           s
          </span>
          <span class="mord mathit">
           t
          </span>
          <span class="mord mathit">
           a
          </span>
          <span class="mord mathit" style="margin-right: 0.02778em;">
           r
          </span>
          <span class="mord mathit">
           t
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mspace" style="margin-right: 0.277778em;">
          </span>
          <span class="mrel">
           =
          </span>
          <span class="mspace" style="margin-right: 0.277778em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathit" style="margin-right: 0.03588em;">
           g
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathit">
           s
          </span>
          <span class="mord mathit">
           t
          </span>
          <span class="mord mathit">
           a
          </span>
          <span class="mord mathit" style="margin-right: 0.02778em;">
           r
          </span>
          <span class="mord mathit">
           t
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mspace" style="margin-right: 0.277778em;">
          </span>
          <span class="mrel">
           =
          </span>
          <span class="mspace" style="margin-right: 0.277778em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 0.64444em; vertical-align: 0em;">
          </span>
          <span class="mord">
           0
          </span>
         </span>
        </span>
       </span>
      </span>
     </li>
    </ul>
    <p>
     如果rhs(n)等于g(n)，则称n局部一致的。如果所有节点都是局部一致的，那么最短路径可以用A*来确定。但是，当边缘代价发生变化时，只需要对与路由相关的节点重新建立局部一致。
    </p>
    <h2>
     <a id="4_25">
     </a>
     4.优先队列
    </h2>
    <p>
     当一个节点在局部变得不一致时(因为它的父代节点的代价或将它链接到父代节点的边缘发生了变化)，它将被放在一个优先级队列中进行重新评估。
     <br/>
     LPA*使用二维key：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/db1c82165d287abbf324489ddbd05509.png">
     </img>
    </div>
    <p>
     元素由
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        k 
         
        
          1 
         
        
       
      
        k_1
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.84444em; vertical-align: -0.15em;">
         </span>
         <span class="mord">
          <span class="mord mathit" style="margin-right: 0.03148em;">
           k
          </span>
          <span class="msupsub">
           <span class="vlist-t vlist-t2">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.301108em;">
              <span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mord mtight">
                 1
                </span>
               </span>
              </span>
             </span>
             <span class="vlist-s">
              ​
             </span>
            </span>
            <span class="vlist-r">
             <span class="vlist" style="height: 0.15em;">
              <span class="">
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
     (它直接对应于A*中使用的f值)排序，然后由
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        k 
         
        
          2 
         
        
       
      
        k_2
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.84444em; vertical-align: -0.15em;">
         </span>
         <span class="mord">
          <span class="mord mathit" style="margin-right: 0.03148em;">
           k
          </span>
          <span class="msupsub">
           <span class="vlist-t vlist-t2">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.301108em;">
              <span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mord mtight">
                 2
                </span>
               </span>
              </span>
             </span>
             <span class="vlist-s">
              ​
             </span>
            </span>
            <span class="vlist-r">
             <span class="vlist" style="height: 0.15em;">
              <span class="">
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
     排序。
    </p>
    <p>
     根据更小的k(n)的值搜寻更优的路径节点，当一个节点n比另一个节点n’更优时，n节点的k(n)不大于k(n’)，即：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/09991f0d1f614289bdd67e124c3ba4ad.png">
     </img>
    </div>
    <h2>
     <a id="5_41">
     </a>
     5.节点状态及扩展
    </h2>
    <p>
     队列顶部节点展开如下：
    </p>
    <ul>
     <li>
      局部一致（Locally Consistent）：g(s)=rhs(s)。当所有节点均为局部一致状态时，g(s)的值等于s到起始点的最短距离（注意，反向不成立）。这个概念很重要，当上述条件满足时，可以找到任意一点u到起始点的最短路径，假设当前位置为s,父辈节点s’(向着起始点前进的下一个节点)通过最小化(g(s’)+c(s,s’))来获得，不断重复直到到达sStart。然而，LPA*并不需要使所有节点均为局部一致状态，它通过启发式搜索将关注点放在搜索上，并且只更新那些与计算最短路径相关的节点的g值。
     </li>
     <li>
      局部过一致（Locally Overconsistent）：g(s)&gt;rhs(s)。当优先队列U中取出的节点为局部过一致状态时，意味着g(s)可以通过父辈节点使自己到起点的路径更短，此时将设置g(s)=rhs(s)，节点状态变为局部一致状态。
     </li>
     <li>
      局部欠一致(Locally Underconsistent)：g(s)&lt;rhs(s)。这种情况通常出现在父辈的某一节点突然变为障碍的情况下，造成父辈节点到起点的路径变大，从而需要修改g(s)的值，如果节点处于这种状态，则当它由优先队列中取出时，将其g值设置为∞，即将该节点状态变为局部过一致，而局部过一致的点将会被再次添加到优先队列中，这样就可以在它下次被取出时将其作为局部过一致状态处理，最终达到局部一致状态（如果这一节点与要搜索的最短路径相关的话）。
     </li>
    </ul>
    <p>
     由于更改节点的g值也可能更改其后续节点的rhs值(从而更改它们的局部一致)，因此将对它们进行评估，并在必要时更新它们的队列成员和key。
    </p>
    <p>
     节点将继续扩展到下一个节点，直到满足以下两个条件:
    </p>
    <ul>
     <li>
      目标是局部一致的
     </li>
     <li>
      优先级队列顶部的节点有一个大于或等于目标的key。
     </li>
    </ul>
    <h2>
     <a id="6_53">
     </a>
     6.初始化运行
    </h2>
    <p>
     当边的代价发生变化时，LPA*检查受变化影响的所有节点，即其中一条变化边终止的所有节点(如果一条边可以在两个方向上遍历，且变化影响两个方向，则检查由该边连接的两个节点)：
    </p>
    <ul>
     <li>
      更新节点的rhs值。
     </li>
     <li>
      已成为局部一致的节点将从队列中删除。
     </li>
     <li>
      已成为局部不一致的节点将添加到队列中。
     </li>
     <li>
      保持局部不一致的节点的key已更新。
     </li>
    </ul>
    <p>
     之后，节点继续扩展，直到达到结束条件。
    </p>
    <h2>
     <a id="7_61">
     </a>
     7.最短路径搜索
    </h2>
    <p>
     节点展开完成后(即满足退出条件)，计算最短路径。如果目标的代价为无穷大，那么从开始到目标没有有限的代价路径。否则，最短路径可以通过向后移动来确定：
    </p>
    <ul>
     <li>
      从目标开始。
     </li>
     <li>
      移动到当前节点n的父代n’，其中g（n’）+d（n’，n）最低（如果最低分数由多个节点共享，则每个节点都是有效的解决方案，其中任何一个都可以任意选择）。
     </li>
     <li>
      重复上一步，直到开始。
     </li>
    </ul>
    <h2>
     <a id="8_67">
     </a>
     8.伪代码
    </h2>
    <p>
     该代码假定一个优先队列queue，该队列支持以下操作：
    </p>
    <ul>
     <li>
      topKey()返回队列中任何节点的(数字上的)最低优先级(如果队列为空，则返回无穷大)；
     </li>
     <li>
      pop()从队列中删除优先级最低的节点并返回它；
     </li>
     <li>
      insert(node, priority) 将具有给定优先级的节点插入队列；
     </li>
     <li>
      remove(node) 从队列中移除一个节点；
     </li>
     <li>
      contains(node) 如果队列包含指定节点，则返回true;如果不包含指定节点，则返回false；
     </li>
    </ul>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/065fe79f6731d65ac9fc48a1147a1921.png">
     </img>
    </div>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">computeShortestPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasCostChanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      sleep<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>edge <span class="token punctuation">:</span> <span class="token function">getChangedEdges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        edge<span class="token punctuation">.</span><span class="token function">setCost</span><span class="token punctuation">(</span><span class="token function">getNewCost</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">updateNode</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>endNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  queue <span class="token operator">=</span> new <span class="token function">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>node <span class="token punctuation">:</span> <span class="token function">getAllNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    node<span class="token punctuation">.</span>g <span class="token operator">=</span> INFINITY<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>rhs <span class="token operator">=</span> INFINITY<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  start<span class="token punctuation">.</span>rhs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  queue<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token function">calculateKey</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/** 优先级队列中扩展节点. */</span>
<span class="token keyword">void</span> <span class="token function">computeShortestPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">getTopKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">calculateKey</span><span class="token punctuation">(</span>goal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>goal<span class="token punctuation">.</span>rhs <span class="token operator">!=</span> goal<span class="token punctuation">.</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>g <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      node<span class="token punctuation">.</span>g <span class="token operator">=</span> node<span class="token punctuation">.</span>rhs<span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>successor <span class="token punctuation">:</span> node<span class="token punctuation">.</span><span class="token function">getSuccessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">updateNode</span><span class="token punctuation">(</span>successor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      node<span class="token punctuation">.</span>g <span class="token operator">=</span> INFINITY<span class="token punctuation">;</span>
      <span class="token function">updateNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>successor <span class="token punctuation">:</span> node<span class="token punctuation">.</span><span class="token function">getSuccessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">updateNode</span><span class="token punctuation">(</span>successor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/** 重新计算节点的rhs并将其从队列中删除。.
 * 如果节点在局部变得不一致，则使用其新key(re-)将节点插入队列。. */</span>
<span class="token keyword">void</span> <span class="token function">updateNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> start<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    node<span class="token punctuation">.</span>rhs <span class="token operator">=</span> INFINITY<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>predecessor<span class="token punctuation">:</span> node<span class="token punctuation">.</span><span class="token function">getPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      node<span class="token punctuation">.</span>rhs <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>rhs<span class="token punctuation">,</span> predecessor<span class="token punctuation">.</span>g <span class="token operator">+</span> predecessor<span class="token punctuation">.</span><span class="token function">getCostTo</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>
      queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>g <span class="token operator">!=</span> node<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span>
      queue<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token function">calculateKey</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calculateKey</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token function">min</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>g<span class="token punctuation">,</span> node<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span> <span class="token operator">+</span> node<span class="token punctuation">.</span><span class="token function">getHeuristic</span><span class="token punctuation">(</span>goal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>g<span class="token punctuation">,</span> node<span class="token punctuation">.</span>rhs<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <h2>
     <a id="9_140">
     </a>
     9.性质
    </h2>
    <p>
     由于算法上类似于A*， LPA*具有许多相同的属性。
    </p>
    <ul>
     <li>
      对于LPA
      <em>
       的每次运行，每个节点最多展开(访问)两次。每个LPA
      </em>
      运行最多扩展一次局部过一致节点，因此其初始运行(每个节点进入过一致状态)的性能与A*类似，都是最多访问每个节点一次。
     </li>
     <li>
      每次运行时展开的节点key都是单调的不随时间递减的，就像A*的情况一样。
     </li>
     <li>
      启发式信息越丰富(因而越大)(同时仍然满足可接受性标准)，需要扩展的节点就越少。
     </li>
     <li>
      优先级队列实现对性能有重大影响，如在A*中。与效率较低的实现相比，使用斐波那契堆可以显著提高性能。
     </li>
     <li>
     </li>
    </ul>
    <p>
     对于一个A_star实现，它打破了两个具有相等f值的节点之间的联系，而支持具有较小g值的节点(在A*中没有定义)，下面的陈述也是正确的:
    </p>
    <ul>
     <li>
      扩展局部过一致节点的顺序与A*相同。
     </li>
     <li>
      在所有局部过一致的节点中，只有那些代价不超过目标的节点需要扩展，就像A*中的情况一样。
      <br/>
      LPA_star还具有以下特性:
     </li>
     <li>
      当边的代价发生变化时，LPA
      <em>
       的性能优于A
      </em>
      (假设后者是从头开始运行的)，因为只需要再次扩展一部分节点。
     </li>
    </ul>
    <p>
     <font color="red" size="5">
      <strong>
       下文将结合Lifelong Planning A*论文的一个例子简要介绍LPA_star算法的主要过程。
      </strong>
     </font>
    </p>
    <h2>
     <a id="10_154">
     </a>
     10.符号表示
    </h2>
    <p>
     <strong>
      S
     </strong>
     ：地形图中的路径节点的集合，s属于S
    </p>
    <p>
     <strong>
      succ(s)
     </strong>
     ：successors,节点s的后续节点（子代节点）集合，例如节点1，2，3…i按顺序均已被搜索过，那么除了1~i的其它结点均属于succ(i)。
    </p>
    <p>
     <strong>
      pred(s)
     </strong>
     ：predecessors,类比上述，节点s的前代节点（父代节点），与succ(s)的意义刚好相反。
    </p>
    <p>
     <strong>
      c(s,s’)
     </strong>
     ：两节点之间的代价函数，0&lt;c(s,s)≤∞。
    </p>
    <p>
     <strong>
      g
     </strong>
     *
     <strong>
      (s)
     </strong>
     ：节点s到起始点SStart的实际最短距离。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/ebc096aef760f2dd4b3760877fee307a.png">
     </img>
    </div>
    <p>
     <strong>
      g(s)
     </strong>
     ：节点s到起始点的预计最短距离，而g*(s)值是实际的最短距离，这个值是一个预计值，是随着算法求解进程不断变动的，当所有节点的g(s)=rhs(s)时，g(s)的值就是到起始点的实际最短距离，即g(s)=g*(s)。
    </p>
    <p>
     <strong>
      rhs(s)
     </strong>
     ：right hand sides，来自DynamicSWSF-FP算法。rhs值是基于g值的一步前瞻值，因此可能比g值更好地信息反馈。对于s的所有邻接节点，求它们到s的距离加上邻接节点自身的g值，其中最小的那个值作为s的rhs值。具体求法可以见下面的公式：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/35bfbcf8b996aea6f271407e61f90391.png">
     </img>
    </div>
    <p>
     举个例子，图5中左侧网格世界给出的g值。方格A0的rhs值为3，即方格A1+1的gvalue和方格B1+1的g值的最小值。因此，方格A0的g值等于它的rhs值，即为局部一致。这个概念很重要，因为如果所有单元格都是局部一致的，那么所有的g值都等于各自的起始距离。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/276f659cf074f1f16636a4728304dd33.png">
     </img>
    </div>
    <p>
     <strong>
      U
     </strong>
     ：同A_star算法中的优先队列，依据每个节点的Key值进行排序。
     <br/>
     <strong>
      Key[K1,K2]
     </strong>
     ：优先队列排序依据的键值，包含两部分，K1与K2，优先比较K1，若相同则比较K2进行排序。
     <font color="red">
      <strong>
       在rhs(s)=g(s)的情况下，K1大致等同于A_star里的f(s)，K2大致等同于A*里的g(s)，K1与K2的计算方法见下面的图。
      </strong>
     </font>
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/e87c37df2087d63db96ffe71b5991735.png">
     </img>
    </div>
    <p>
     <font color="red">
      <strong>
       当rhs(s)&lt;g(s)时，将g(s)设置为rhs(s)。
      </strong>
     </font>
    </p>
    <p>
     <strong>
      h(s)
     </strong>
     ：同A*中的类似，到目标点的估计距离，在论文中用的是到目标节点的绝对距离进行表示。
    </p>
    <h2>
     <a id="11_193">
     </a>
     11.算法示例推演
    </h2>
    <p>
     论文中以二维平面网格地图作为演示对象，每一个网格与周围八个网格相连（相互之间可以直接到达），黑色网格为障碍。
    </p>
    <p>
     <strong>
      第一次搜索
     </strong>
     ：地形发生变动之前的路径搜索，与A_star搜索基本相同。起点为右上角的点，目标点为左下角的点。第一张图描述了各点的到起始点的最短距离以及各点到目标点的h值。左侧为g_star值（由当前位置到起始点的代价，距离采用曼哈顿计算公式），右侧为h值（由当前位置到目标点的代价）。最开始所有点rhs和g均设为无穷，然后由起始点开始，将起始点的rhs设置为0，然后如上图过程不断迭代，直到获得最短路径。
    </p>
    <p>
     <font color="red">
      <strong>
       在第一次迭代时rhs(s)=g(s)，K1大致等同于A_star里的f(s)，K2大致等同于A_star里的g(s)。此时按照A_star算法进行搜索，搜索的过程是按照key[K1;K2]的优先级进行搜索的。
      </strong>
     </font>
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/67e4c274aa3c90d2b5b5d2af849eedf3.png">
     </img>
    </div>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/7205e3d7e84e931edd16bc677022ae5a.png">
     </img>
    </div>
    <p>
     <strong>
      第二次搜索
     </strong>
     ：当场景中地形状态发生变动，在该例子中，节点(D,1)变为障碍，只改变了三个起始距离，即单元D1、E1和F0。这允许LPA*有效地重新规划最短路径，即使从开始单元到目标单元的最短路径完全改变。
    </p>
    <p>
     <font color="red">
      <strong>
       这是重用以前的规划构建过程的一部分（以g值的形式），而不是以更大的内存需求为代价来调整先前规划的优点。特别是，g值不仅可以用来确定最短路径，而且它们比最短路径本身更容易再次使用。
      </strong>
     </font>
    </p>
    <p>
     首先对该节点进行更新，并将其后代节点置于优先队列中，该节点的变动对父辈节点的状态并无影响。同第一次搜索类似，不断进行迭代直到再次找到到目标位置的最短路径。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/ab68967011dea1ad8dac2ca8fa4b5766.png"/>
    </div>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/948d8469a54be6379a1b4fbeb368ec3a.png"/>
    </div>
    <p>
     在迭代中，第二次到第三次之间为父辈的某一节点突然变为障碍的情况下，造成父辈节点到起点的路径变大。此时，g(s)&lt;rhs(s)，为
     <font color="red">
      <strong>
       局部欠一致
      </strong>
      (Locally Underconsistent)
     </font>
     状态。节点处于这种状态，则当它由优先队列中取出时，将其g值设置为无穷大。接下来的搜索过程，与第一次的搜索过程类似。
    </p>
    <h2>
     <a id="12_221">
     </a>
     12.总结
    </h2>
    <p>
     LPA_star提出了一种解决动态环境下的最短路径搜索方法，但是它针对的是起始点和目标点固定的情况，如果在机器人按照搜索到的最短路径行走过程中，环境中某些节点发生变化，这时如果想获得新的路径，就得以机器人当前节点为起始点，重新用LPA_star算法解算一次，这效率是很低的。针对这种情况，该论文的作者随后提出了D_starLite算法来作为处理动态环境最短路径问题的高效方法。
    </p>
    <h2>
     <a id="13_224">
     </a>
     13.对公式的进一步理解
    </h2>
    <p>
     来源于
     <a href="https://zhuanlan.zhihu.com/p/51114323" rel="nofollow">
      路径规划——Lifelong Planning A*算法
     </a>
    </p>
    <p>
     和A_star算法一样，LPA_star算法采用非负、一致性的启发函数 h(s) 表示当前位置网格点 s 到目标点 Goal 的距离的估计， h(s) 一致性体现在服从以下三角不等式，可以由简单的三角形几何性质可以推出：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/76641633239afa070815e8fab89d1b1f.png"/>
    </div>
    <p>
     其中 s≠Goal 且 s属于succ(s)，如图1所示：
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/ecff1692a3c53d0c5ff599e59448a81c.png"/>
    </div>
    <ul>
     <li>
      <p>
       succ(s)或 children(s) ，表示网格点 s 下一时刻将要移动到的点，相当于 s 点的继承点，对于 Goal 点，有
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          s 
          
         
           u 
          
         
           c 
          
         
           c 
          
         
           ( 
          
         
           G 
          
         
           o 
          
         
           a 
          
         
           l 
          
         
           ) 
          
         
           = 
          
         
           ⊘ 
          
         
        
          succ(Goal)=\oslash
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mord mathit">
            u
           </span>
           <span class="mord mathit">
            c
           </span>
           <span class="mord mathit">
            c
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            G
           </span>
           <span class="mord mathit">
            o
           </span>
           <span class="mord mathit">
            a
           </span>
           <span class="mord mathit" style="margin-right: 0.01968em;">
            l
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            =
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;">
           </span>
           <span class="mord">
            ⊘
           </span>
          </span>
         </span>
        </span>
       </span>
      </p>
     </li>
     <li>
      <p>
       pred(s) 或 parent(s) ，表示前一时刻移动到当前位置 s 点来的网格点，相当于 s 点的前辈点，对于 Start 点，有
       <span class="katex--inline">
        KaTeX parse error: Can't use function '\(' in math mode at position 5: pred\̲(̲Start)=\oslash
       </span>
       ；
      </p>
     </li>
     <li>
      <p>
       g*(s) ，表示 Start 点到当前 s 点的最短路径距离， g(s) 是对g*(s) 值的估计，
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          g 
           
          
            ∗ 
           
          
         
           ( 
          
         
           s 
          
         
           ) 
          
         
        
          g^*(s)
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord">
            <span class="mord mathit" style="margin-right: 0.03588em;">
             g
            </span>
            <span class="msupsub">
             <span class="vlist-t">
              <span class="vlist-r">
               <span class="vlist" style="height: 0.688696em;">
                <span class="" style="top: -3.063em; margin-right: 0.05em;">
                 <span class="pstrut" style="height: 2.7em;">
                 </span>
                 <span class="sizing reset-size6 size3 mtight">
                  <span class="mbin mtight">
                   ∗
                  </span>
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mclose">
            )
           </span>
          </span>
         </span>
        </span>
       </span>
       定义如下：
      </p>
     </li>
    </ul>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/2836bb70874c8787b931e0bececafea0.png"/>
    </div>
    <ul>
     <li>
      rhs(s)被定义为：
     </li>
    </ul>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/b9dcfef67e351c5a4f4dabba24971feb.png"/>
    </div>
    <p>
     其中 g(s’) 是节点 s’ 到起始节点 s_{start} 的代价，类似于A*算法中的 g(n) ， c(s’,s) 表示从节点 s’ 到节点 s 的代价，被称为边缘代价函数。
    </p>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/blog_migrate/357528c473000fcccfd089e582d19962.png"/>
    </div>
    <p>
     在图2的a)中，
     <br/>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        g 
        
       
         ( 
        
       
         s 
        
       
         ) 
        
       
         = 
        
       
         A 
        
       
         + 
        
       
         B 
        
       
      
        g(s)=A+B
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.03588em;">
          g
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;">
         </span>
         <span class="mord mathit">
          A
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.05017em;">
          B
         </span>
        </span>
       </span>
      </span>
     </span>
     <br/>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        r 
        
       
         h 
        
       
         s 
        
       
         ( 
        
       
         s 
        
       
         ) 
        
       
         = 
        
       
         g 
        
       
         ( 
        
        
        
          s 
         
        
          ′ 
         
        
       
         ) 
        
       
         + 
        
       
         c 
        
       
         ( 
        
        
        
          s 
         
        
          ′ 
         
        
       
         , 
        
       
         s 
        
       
         ) 
        
       
         = 
        
       
         A 
        
       
         + 
        
       
         B 
        
       
      
        rhs(s)=g(s&amp;#x27;)+c(s&amp;#x27;,s)=A+B
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.02778em;">
          r
         </span>
         <span class="mord mathit">
          h
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1.00189em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.03588em;">
          g
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord">
          <span class="mord mathit">
           s
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.751892em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mord mtight">
                 <span class="mord mtight">
                  ′
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1.00189em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit">
          c
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord">
          <span class="mord mathit">
           s
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.751892em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mord mtight">
                 <span class="mord mtight">
                  ′
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;">
         </span>
         <span class="mord mathit">
          A
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.05017em;">
          B
         </span>
        </span>
       </span>
      </span>
     </span>
    </p>
    <p>
     此时属于“正常情况”，即 g(s)=rhs(s) ，此时 s 点为局部一致(locally consistent)；
    </p>
    <p>
     在图2的b)中，如果边缘代价函数值 c(s’,s) 由于环境发生改变从 B 变为 ∞ (即自由网格点 s 被障碍物占据)，则有
     <br/>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        g 
        
       
         ( 
        
       
         s 
        
       
         ) 
        
       
         = 
        
       
         A 
        
       
         + 
        
       
         B 
        
       
      
        g(s)=A+B
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.03588em;">
          g
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;">
         </span>
         <span class="mord mathit">
          A
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.05017em;">
          B
         </span>
        </span>
       </span>
      </span>
     </span>
     <br/>
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        r 
        
       
         h 
        
       
         s 
        
       
         ( 
        
       
         s 
        
       
         ) 
        
       
         = 
        
       
         g 
        
       
         ( 
        
        
        
          s 
         
        
          ′ 
         
        
       
         ) 
        
       
         + 
        
       
         c 
        
       
         ( 
        
        
        
          s 
         
        
          ′ 
         
        
       
         , 
        
       
         s 
        
       
         ) 
        
       
         = 
        
       
         A 
        
       
         + 
        
       
         ∞ 
        
       
         = 
        
       
         ∞ 
        
       
      
        rhs(s)=g(s&amp;#x27;)+c(s&amp;#x27;,s)=A+∞=∞
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.02778em;">
          r
         </span>
         <span class="mord mathit">
          h
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1.00189em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit" style="margin-right: 0.03588em;">
          g
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord">
          <span class="mord mathit">
           s
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.751892em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mord mtight">
                 <span class="mord mtight">
                  ′
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1.00189em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathit">
          c
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord">
          <span class="mord mathit">
           s
          </span>
          <span class="msupsub">
           <span class="vlist-t">
            <span class="vlist-r">
             <span class="vlist" style="height: 0.751892em;">
              <span class="" style="top: -3.063em; margin-right: 0.05em;">
               <span class="pstrut" style="height: 2.7em;">
               </span>
               <span class="sizing reset-size6 size3 mtight">
                <span class="mord mtight">
                 <span class="mord mtight">
                  ′
                 </span>
                </span>
               </span>
              </span>
             </span>
            </span>
           </span>
          </span>
         </span>
         <span class="mpunct">
          ,
         </span>
         <span class="mspace" style="margin-right: 0.166667em;">
         </span>
         <span class="mord mathit">
          s
         </span>
         <span class="mclose">
          )
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;">
         </span>
         <span class="mord mathit">
          A
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.222222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord">
          ∞
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          =
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 0.43056em; vertical-align: 0em;">
         </span>
         <span class="mord">
          ∞
         </span>
        </span>
       </span>
      </span>
     </span>
    </p>
    <p>
     这种情况有 ，此时 s 点为局部不一致(locally inconsistent)。
    </p>
    <p>
     局部不一致又分为过一致(Overconsistent)和欠一致(Subconsistent)。
    </p>
    <p>
     当 g(s)&gt;rhs(s) 被称为
     <strong>
      局部过一致
     </strong>
     ，即 s’ 点到 s 点的边缘代价函数 c(s,s’) 值变低，代表网格上障碍物被清除(例如c值从 ∞ 变为 B )或搜索到一条更短的“捷径”。
    </p>
    <p>
     当 g(s)&lt;rhs(s) 被称为
     <strong>
      局部欠一致
     </strong>
     ，当 s 点欠一致时，即 s’ 点到 s 点的边缘代价函数c值变高，代表着自由网格被障碍物所占据，这时 s 点的信息需要被重置，这时候就需要重新搜索计算最短路径。
    </p>
    <ul>
     <li>
      <p>
       Openlist或priority queue，和A*算法一样，表示被搜索网格点的集合，用 key(s) 来对这些网格点进行排序，值得注意的是所有Openlist的点都局部不一致，所有局部不一致的点都在列表上。
      </p>
     </li>
     <li>
      <p>
       key(s)，代表着优先级队列中网格点选择的优先权，key值用于处理局部不一致的网格点， key(s) 由两个元素组成， key(s) 被定义为：
       <br/>
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          k 
          
         
           e 
          
         
           y 
          
         
           ( 
          
         
           s 
          
         
           ) 
          
         
           = 
          
         
           [ 
          
         
           k 
          
         
           1 
          
         
           ( 
          
         
           s 
          
         
           ) 
          
         
           ; 
          
         
           k 
          
         
           2 
          
         
           ( 
          
         
           s 
          
         
           ) 
          
         
           ] 
          
         
        
          key(s)=[k1(s);k2(s)]
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit" style="margin-right: 0.03148em;">
            k
           </span>
           <span class="mord mathit">
            e
           </span>
           <span class="mord mathit" style="margin-right: 0.03588em;">
            y
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            =
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mopen">
            [
           </span>
           <span class="mord mathit" style="margin-right: 0.03148em;">
            k
           </span>
           <span class="mord">
            1
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mpunct">
            ;
           </span>
           <span class="mspace" style="margin-right: 0.166667em;">
           </span>
           <span class="mord mathit" style="margin-right: 0.03148em;">
            k
           </span>
           <span class="mord">
            2
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mclose">
            ]
           </span>
          </span>
         </span>
        </span>
       </span>
       <br/>
       其中：
       <br/>
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          k 
          
         
           1 
          
         
           ( 
          
         
           s 
          
         
           ) 
          
         
           = 
          
         
           m 
          
         
           i 
          
         
           n 
          
          
          
            g 
           
          
            ( 
           
          
            s 
           
          
            ) 
           
          
            , 
           
          
            r 
           
          
            h 
           
          
            s 
           
          
            ( 
           
          
            s 
           
          
            ) 
           
          
         
           + 
          
         
           h 
          
         
           ( 
          
         
           s 
          
         
           , 
          
         
           G 
          
         
           o 
          
         
           a 
          
         
           l 
          
         
           ) 
          
         
        
          k1(s)=min{g(s),rhs(s)}+h(s,Goal)
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit" style="margin-right: 0.03148em;">
            k
           </span>
           <span class="mord">
            1
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            =
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit">
            m
           </span>
           <span class="mord mathit">
            i
           </span>
           <span class="mord mathit">
            n
           </span>
           <span class="mord">
            <span class="mord mathit" style="margin-right: 0.03588em;">
             g
            </span>
            <span class="mopen">
             (
            </span>
            <span class="mord mathit">
             s
            </span>
            <span class="mclose">
             )
            </span>
            <span class="mpunct">
             ,
            </span>
            <span class="mspace" style="margin-right: 0.166667em;">
            </span>
            <span class="mord mathit" style="margin-right: 0.02778em;">
             r
            </span>
            <span class="mord mathit">
             h
            </span>
            <span class="mord mathit">
             s
            </span>
            <span class="mopen">
             (
            </span>
            <span class="mord mathit">
             s
            </span>
            <span class="mclose">
             )
            </span>
           </span>
           <span class="mspace" style="margin-right: 0.222222em;">
           </span>
           <span class="mbin">
            +
           </span>
           <span class="mspace" style="margin-right: 0.222222em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit">
            h
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mpunct">
            ,
           </span>
           <span class="mspace" style="margin-right: 0.166667em;">
           </span>
           <span class="mord mathit">
            G
           </span>
           <span class="mord mathit">
            o
           </span>
           <span class="mord mathit">
            a
           </span>
           <span class="mord mathit" style="margin-right: 0.01968em;">
            l
           </span>
           <span class="mclose">
            )
           </span>
          </span>
         </span>
        </span>
       </span>
       <br/>
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          k 
          
         
           2 
          
         
           ( 
          
         
           s 
          
         
           ) 
          
         
           = 
          
         
           m 
          
         
           i 
          
         
           n 
          
          
          
            g 
           
          
            ( 
           
          
            s 
           
          
            ) 
           
          
            , 
           
          
            r 
           
          
            h 
           
          
            s 
           
          
            ( 
           
          
            s 
           
          
            ) 
           
          
         
        
          k2(s)=min{g(s),rhs(s)}
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit" style="margin-right: 0.03148em;">
            k
           </span>
           <span class="mord">
            2
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord mathit">
            s
           </span>
           <span class="mclose">
            )
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
           <span class="mrel">
            =
           </span>
           <span class="mspace" style="margin-right: 0.277778em;">
           </span>
          </span>
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathit">
            m
           </span>
           <span class="mord mathit">
            i
           </span>
           <span class="mord mathit">
            n
           </span>
           <span class="mord">
            <span class="mord mathit" style="margin-right: 0.03588em;">
             g
            </span>
            <span class="mopen">
             (
            </span>
            <span class="mord mathit">
             s
            </span>
            <span class="mclose">
             )
            </span>
            <span class="mpunct">
             ,
            </span>
            <span class="mspace" style="margin-right: 0.166667em;">
            </span>
            <span class="mord mathit" style="margin-right: 0.02778em;">
             r
            </span>
            <span class="mord mathit">
             h
            </span>
            <span class="mord mathit">
             s
            </span>
            <span class="mopen">
             (
            </span>
            <span class="mord mathit">
             s
            </span>
            <span class="mclose">
             )
            </span>
           </span>
          </span>
         </span>
        </span>
       </span>
      </p>
     </li>
    </ul>
    <p>
     key值之间的比较方式如下：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token function">k1</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;=</span> <span class="token function">k1</span><span class="token punctuation">(</span>s<span class="token string">') or (k1(s)=k1(s'</span><span class="token punctuation">)</span> and <span class="token function">k2</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;=</span> <span class="token function">k2</span><span class="token punctuation">(</span>s'<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">k</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;=</span> <span class="token function">k</span><span class="token punctuation">(</span>s'<span class="token punctuation">)</span>
end
</code></pre>
    <p>
     key值越小，其优先权越高，该点就越先被搜索。
    </p>
    <h3>
     <a id="_295">
     </a>
     伪代码
    </h3>
    <pre><code class="prism language-c">For each s in Graph
    s<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">rhs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span>∞<span class="token punctuation">;</span>局部一致
end <span class="token keyword">for</span> each
startNode<span class="token punctuation">.</span>rhs<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>局部过一致
Forever
    <span class="token function">While</span><span class="token punctuation">(</span>OpenList<span class="token punctuation">.</span><span class="token function">Top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> goal<span class="token punctuation">.</span>key OR goal is incosistent<span class="token punctuation">)</span>
    当OpenList中最优先点的key值小于目标点的key值或者目标点局部不一致时
        currentNode<span class="token operator">=</span>OpenList<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        当前点为OpenList中最优先点，并将U中最优先的网格点删除
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode is overconsistent<span class="token punctuation">)</span>
        如果当前点局部过一致，代表网格上障碍物被清除或搜索到更短的“捷径”
            currentNode<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span>currentNode<span class="token punctuation">.</span><span class="token function">rhs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            令当前点的<span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">rhs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>，使其局部一致
        <span class="token keyword">else</span>
        否则
            currentNode<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span>∞<span class="token punctuation">;</span>
            局部过一致<span class="token function">g</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token function">rhs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>或一致<span class="token function">g</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">rhs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        end <span class="token keyword">if</span>
        <span class="token keyword">for</span> each s in currentNode<span class="token punctuation">.</span>Children<span class="token punctuation">[</span><span class="token punctuation">]</span>
            update s<span class="token punctuation">.</span><span class="token function">rhs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            局部过一致<span class="token function">g</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token function">rhs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>或一致<span class="token function">g</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token function">rhs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        end <span class="token keyword">for</span> each
    End <span class="token keyword">while</span>
    Wait <span class="token keyword">for</span> changes in Graph
    For each connection <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> with changed cost
        Update <span class="token function">connection</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Make v locally inconsistent<span class="token punctuation">;</span>
    end <span class="token keyword">for</span> each
End forever
</code></pre>
    <h2>
     <a id="_328">
     </a>
     参考资料
    </h2>
    <p>
     [1]
     <a href="https://www.wikiwand.com/en/Lifelong_Planning_A*" rel="nofollow">
      Wiki百科：Lifelong Planning A*
     </a>
     <br/>
     [2]
     <a href="https://zhuanlan.zhihu.com/p/51114323" rel="nofollow">
      路径规划——Lifelong Planning A_star 算法
     </a>
     <br/>
     [3]
     <a href="https://blog.csdn.net/a380331382/article/details/83549015">
      LPA* 路径搜索算法介绍
     </a>
     <br/>
     [4]
     <a href="http://www.cs.cmu.edu/afs/.cs.cmu.edu/Web/People/maxim/files/aij04.pdf" rel="nofollow">
      Lifelong planning A∗.pdf
     </a>
     <br/>
     [5]
     <a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201801&amp;filename=1017863612.nh&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVWEyd1JXbU9lRytzcDkyUjA5eEFsU2x5VT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=Mjk4ODlkZk5yWkViUElSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVJMS2VaZWRtRnk3blZMekFWRjI2R2J1K0g=" rel="nofollow">
      徐开放. 基于D_star Lite算法的移动机器人路径规划研究[D]. 哈尔滨工业大学, 2017.
     </a>
     <br/>
     [6]
     <a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201601&amp;filename=1015443378.nh&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVWEyd2MwSU85aksveWZsNENYb2ZRVm4yND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MTA0MzZWTC9PVkYyNkc3ZThIZExMcDVFYlBJUjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTEtlWmVSdUZDamc=" rel="nofollow">
      张浩. 地面移动机器人安全路径规划研究[D]. 安徽工程大学, 2015.
     </a>
    </p>
    <h2>
     <a id="font_colorredfont_336">
     </a>
     <font color="red">
      搜索算法其他文章
     </font>
    </h2>
    <p>
     <a href="https://blog.csdn.net/lqzdreamer/article/details/85158542">
      Field Ｄstar路径规划算法
     </a>
     <br/>
     <a href="https://blog.csdn.net/lqzdreamer/article/details/85108310">
      Dstar Lite路径规划算法
     </a>
     <br/>
     <a href="https://blog.csdn.net/lqzdreamer/article/details/85055569">
      D*路径搜索算法原理解析及Python实现
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6c717a647265616d6572:2f61727469636c652f64657461696c732f3835313735333732" class_="artid" style="display:none">
 </p>
</div>


