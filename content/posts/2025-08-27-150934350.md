---
layout: post
title: "K8S-Configmap资源"
date: 2025-08-27T20:13:04+0800
description: "Configmap 是 k8s 中的资源对象，用于保存非机密性的配置的，数据可以用 key/value 键值对的形式保存，也可通过文件的形式保存。"
keywords: "K8S-Configmap资源"
categories: ['未分类']
tags: ['容器', '云原生', 'Kubernetes']
artid: "150934350"
arturl: "https://blog.csdn.net/weixin_50045291/article/details/150934350"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150934350
    alt: "K8S-Configmap资源"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150934350
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150934350
cover: https://bing.ee123.net/img/rand?artid=150934350
image: https://bing.ee123.net/img/rand?artid=150934350
img: https://bing.ee123.net/img/rand?artid=150934350
---



# K8S-Configmap资源

## 一、Configmap 概述

#### 什么是 Configmap？

Configmap 是 k8s 中的资源对象，用于保存非机密性的配置的，数据可以用 key/value 键值对的形式保存，也可通过文件的形式保存。

![](https://i-blog.csdnimg.cn/direct/dab30fe7f39746abadf0a722bc90bda5.png)

#### Configmap 能解决哪些问题？

**ConfigMap 的主要作用就是为了让镜像和配置文件解耦，以便实现镜像的可移植性和可复用性。**

我们在部署服务的时候，每个服务都有自己的配置文件，如果一台服务器上部署多个服务：nginx、nginx、apache 等，那么这些配置都存在这个节点上，假如一台服务 器不能满足线上高并发的要求，需要对服务器扩容，扩容之后的服务器还是需要部署 多个服务：nginx、nginx、apache，新增加的服务器上还是要管理这些服务的配置， 如果有一个服务出现问题，需要修改配置文件，每台物理节点上的配置都需要修改， 这种方式肯定满足不了线上大批量的配置变更要求。 所以，k8s 中引入了 Configmap 资源对象，可以当成 volume 挂载到 pod 中，实现统一的配置管理。

![](https://i-blog.csdnimg.cn/direct/3491bacdd1934450a0cd2ff702056b3f.png)

2、Configmap 可以做成 Volume，k8s pod 启动之后，通过 volume 形式映射到容器内部指定目录上；

3、容器中应用程序按照原有方式读取容器特定目录上的配置文件。

4、在容器看来，配置文件就像是打包在容器内部特定目录，整个过程对应用没有任何侵入。

#### Configmap 应用场景

1、使用 k8s 部署应用，当你将应用配置写进代码中，更新配置时也需要打包镜像，configmap 可以将配置信息和 docker 镜像**解耦**，以便实现镜像的可移植性和可复用性，因为一个 configMap 其实就是一系列配置信息的集合，可直接注入到 Pod 中给容器使用。configmap 注入方式有两种，**一种将 configMap 做为存储卷，一种是将configMap 通过 env 中 configMapKeyRef 注入到容器中。**

2、使用微服务架构的话，存在多个服务共用配置的情况，如果每个服务中单独一份配置的话，那么更新配置就很麻烦，使用 configmap 可以友好的进行配置共享。

#### 使用 ConfigMap 的限制条件

* ConfigMap 需要在 Pod 启动前创建出来；
* 并且只有当 ConfigMap 和 Pod 处于同一命名空间时，才可以被 Pod 引用；
* **当 Pod 挂载 ConfigMap 绑定的目录时，目录下的目录并不会挂载到 Pod 内，只有目录下的文件会被挂载。**
* ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1MiB。如果你需要保存超出此尺寸限制的数据，可以考虑挂载存储卷或者使用独立的数据库或者文件服务。

### 二、Configmap 创建方法

#### 命令行直接创建

直接在命令行中指定 configmap 参数创建，通过--from-literal 指定参数

```

[root@k8s-master01 ~]# kubectl create configmap nginx-config --from-literal=nginx_port=8080 --from-literal=server_name=myapp.nginx.com
​
[root@k8s-master01 ~]# kubectl get configmap
​
NAME               DATA   AGE
​
kube-root-ca.crt   1      13d
​
nginx-config      2      51s
​
[root@k8s-master01 ~]# kubectl get cm
​
NAME               DATA   AGE
​
kube-root-ca.crt   1      13d
​
nginx-config      2      66s
​
[root@k8s-master01 ~]# kubectl describe configmap nginx-config
​
Name:         nginx-config
Namespace:    default
Labels:       <none>
Annotations:  <none>
​
Data
====
server_name:
----
nginx.jx.com
nginx_port:
----
8080
​
BinaryData
====
​
Events:  <none>
​
###查看创建的configmap的yaml信息
[root@k8s-master01 ~]# kubectl get cm nginx-config -o yaml
apiVersion: v1
data:
  server_name: nginx.jx.com
  nginx_port: "8080"
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-01T06:57:54Z"
  name: nginx-config
  namespace: default
  resourceVersion: "616425"
  uid: 062bd992-202a-4ac3-a578-32542792a43a
```

```


​
```

**创建选项解析：**

```

--allow-missing-template-keys

含义：如果设置为true，当模板中的字段或映射键在数据来源中缺失时，忽略模板中的任何错误。

--append-hash

含义：将configmap的哈希值附加到它的名称后面。

--as-group

含义：指定操作时要模拟的组。这个标志可以重复使用，以指定多个组，用于在操作中进行权限模拟。

--as-uid

含义：指定操作时要模拟的用户ID（UID）。

--as

含义：指定操作时要模拟的用户名。这个用户可以是普通用户或者服务账户，用于在操作中进行权限模拟。

--cache-dir

含义：默认的缓存目录路径。

--certificate-authority

含义：指向证书颁发机构（CA）证书文件的路径，用于验证服务器证书的合法性。

--client-certificate

含义：指向用于TLS（传输层安全协议）的客户端证书文件的路径。

--client-key

含义：指向用于TLS的客户端密钥文件的路径。

--cluster

含义：指定要使用的kubeconfig中的集群名称。kubeconfig是Kubernetes用于配置客户端访问集群的文件。

--context

含义：指定要使用的kubeconfig中的上下文名称。上下文包含了集群、用户和命名空间等信息，用于确定如何与集群进行交互。

--disable-compression

含义：如果设置为true，对发送到服务器的所有请求都不使用响应压缩。

--dry-run

含义：必须是“none”、“server”或“client”之一。如果是“client”策略，仅打印出将要发送到服务器的对象，而不实际执行创建操作；“server”可能在服务器端进行一些验证但不持久化；“none”则是正常执行操作。

--field-manager

含义：用于跟踪字段所有权的管理器名称。

--from-env-file

含义：指定一个文件路径，用于读取以键值对（key=val）形式的行来创建configmap。

--from-file

含义：可以使用文件路径来指定键文件，在这种情况下，文件的基本名称（不含路径）将被用作configmap中的键，文件内容作为值。

--from-literal

含义：指定一个键和一个字面量值，用于插入到configmap中（例如mykey=somevalue）。

--help

含义：显示configmap相关的帮助信息。

--insecure-skip-tls-verify

含义：如果设置为true，将不会检查服务器证书的有效性。这会使你的连接变得不安全，但在某些测试或特殊环境下可能会用到。

--kubeconfig

含义：指向用于命令行接口（CLI）请求的kubeconfig文件的路径。

--log-flush-frequency

含义：日志刷新的最大间隔秒数，即多久将日志缓冲区中的内容刷新输出一次。

--match-server-version

含义：要求服务器版本与客户端版本匹配。

--namespace

含义：如果存在此选项，它指定了这个命令行请求的命名空间范围。命名空间用于在Kubernetes集群中对资源进行隔离和分组。

--output

含义：输出格式。可以是以下之一：（json、yaml、name、go-template、go-template-file、template等），用于指定命令执行结果的输出格式。

--password

含义：用于对API服务器进行基本身份验证的密码。

--profile

含义：要捕获的性能分析（profile）名称。可以是（none、cpu、heap、goroutine、threadcreate、block、mutex）之一，用于对Kubernetes组件的性能进行分析。

--profile-output

含义：指定要将性能分析结果写入的文件名。

--request-timeout

含义：在放弃单个服务器请求之前等待的时间长度。非零值会设置请求超时时间，避免长时间等待无响应的服务器。

--save-config

含义：如果设置为true，当前对象的配置将保存在其注释中。否则，不会保存配置。

--server

含义：Kubernetes API服务器的地址和端口，用于指定客户端连接的服务器位置。

--show-managed-fields

含义：如果设置为true，在以JSON或YAML格式打印对象时，保留managedFields字段。这些字段通常用于记录资源的管理信息。

--template

含义：当-o=go-template、-o=go-template-file等输出格式选项被使用时，指定要使用的模板字符串或模板文件路径。

--tls-server-name

含义：用于服务器证书验证的服务器名称。如果未提供，将使用主机名进行验证。

--token

含义：用于对API服务器进行身份验证的承载令牌（Bearer Token）。

--username

含义：用于对API服务器进行基本身份验证的用户名。

--user

含义：指定要使用的kubeconfig用户的名称。

--validate

含义：必须是以下之一：strict（或true）、warn、ignore（或false），用于指定对资源配置的验证级别。

--vmodule

含义：逗号分隔的pattern=N设置列表，用于基于文件过滤的日志记录（仅适用于特定的日志系统）。

--v

含义：日志级别详细程度的数字表示，用于控制日志输出的信息量。

--warnings-as-errors

含义：将从服务器接收到的警告视为错误，并以非零退出码退出命令执行。
```

#### 通过文件创建（常用）

通过指定文件创建一个 configmap，--from-file=<文件>，若没有定义key，则使用文件名作为key，文件内容作为value。

```

[root@k8s-master01 configmap]# cat nginx.conf
​
server {
​
server_name www.nginx.com;
​
listen 80;
​
root /home/nginx/www/
​
}
​
[root@k8s-master01 configmap]# kubectl create configmap nginx-conf --from-file=www.conf=./nginx.conf 
configmap/nginx-conf created    
​
[root@k8s-master01 configmap]#  kubectl describe configmap nginx-config
​
Name:         nginx-conf
Namespace:    default
Labels:       <none>
Annotations:  <none>
​
Data
====
www.conf:
----
server {
​
server_name www.nginx.com;
​
listen 80;
​
root /home/nginx/www/
​
}
​
​
BinaryData
====
​
Events:  <none>
​
​
[root@k8s-master01 configmap]# kubectl get cm nginx-conf -o yaml
apiVersion: v1
data:
  www.conf: |  
    server {
​
    server_name www.nginx.com;
​
    listen 80;
​
    root /home/nginx/www/
​
    }
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-01T07:12:53Z"
  name: nginx-conf
  namespace: default
  resourceVersion: "618054"
  uid: 3ee6f787-9372-4bda-b0f6-d350b2235d50
  
##www.conf: | 作用是表示www.conf这个可以的内容是多行的。
```

#### 指定目录创建 configmap（常用）

```

[root@k8s-master01 configmap]# mkdir mysql-test
[root@k8s-master01 configmap]# cd mysql-test/
[root@k8s-master01 mysql-test]# echo server_id=1 > mysql.cnf
[root@k8s-master01 mysql-test]# echo server_id=2 > mysql2.cnf
​
[root@k8s-master01 configmap]# kubectl create configmap mysql-cnf --from-file=/root/configmap/mysql-test/
configmap/mysql-cnf created
​
#查看 configmap 详细信息
​
[root@k8s-master01 configmap]# kubectl describe cm mysql-cnf 
Name:         mysql-cnf
Namespace:    default
Labels:       <none>
Annotations:  <none>
​
Data
====
mysql.cnf:
----
server_id=1
​
mysql2.cnf:
----
server_id=2
​
​
BinaryData
====
​
Events:  <none>
​
[root@k8s-master01 configmap]# kubectl get cm mysql-cnf -o yaml
apiVersion: v1
data:
  mysql.cnf: |
    server_id=1
  mysql2.cnf: |
    server_id=2
kind: ConfigMap
metadata:
  creationTimestamp: "2024-02-01T07:16:32Z"
  name: mysql-cnf
  namespace: default
  resourceVersion: "618449"
  uid: 3fc1c8ef-5ddd-477b-bc52-2ecf2de86e25
```

#### ​编写 configmap 资源清单 YAML 文件

```

[
```

```

root@k8s-master01 configmap]# cat mysql-configmap.yaml
​
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql
  labels:
    app: mysql
data:
  master.cnf: |
    [mysqld]
    log-bin
    log_bin_trust_function_creators=1
    lower_case_table_names=1
  slave.cnf: |
    [mysqld]
    super-read-only
    log_bin_trust_function_creators=1
​
#上面中的 | 表示master.cnf文件是多行文件
[root@k8s-master01 configmap]# kubectl get cm mysql -o yaml
apiVersion: v1
data:
  master.cnf: |
    [mysqld]
    log-bin
    log_bin_trust_function_creators=1
    lower_case_table_names=1
  slave.cnf: |
    [mysqld]
    super-read-only
    log_bin_trust_function_creators=1
kind: ConfigMap
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","data":{"master.cnf":"[mysqld]\nlog-bin\nlog_bin_trust_function_creators=1\nlower_case_table_names=1\n","slave.cnf":"[mysqld]\nsuper-read-only\nlog_bin_trust_function_creators=1\n"},"kind":"ConfigMap","metadata":{"annotations":{},"labels":{"app":"mysql"},"name":"mysql","namespace":"default"}}
  creationTimestamp: "2024-02-01T07:39:13Z"
  labels:
    app: mysql
  name: mysql
  namespace: default
  resourceVersion: "620920"
  uid: acad5d26-6692-4c1b-a389-cd37bbe81d7d
```

### 三、使用 Configmap

#### 通过环境变量引入

使用 configMapKeyRef变量

* ```

  #创建一个存储 mysql 配置的 configmap
  ​

  ```

  ```

  [root@k8s-master01 ~]# cat mysql-configmap.yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mysql
    labels:
      app: mysql
  data:
    log: "1"
    lower: "1"
  [root@k8s-master01 ~]# kubectl apply -f mysql-configmap.yaml
  ​
  configmap/mysql created
  ​
  [root@k8s-master01 ~]# kubectl get cm
  ​
  NAME               DATA   AGE
  ​
  kube-root-ca.crt   1      13d
  ​
  mysql              2      82s
  ```

  ```


  ​
  #创建 pod，引用 Configmap 中的内容
  ​


  ```

  ```

  [root@k8s-master01 ~]# cat mysql-pod.yaml
  ​
  apiVersion: v1
  kind: Pod
  metadata:
    name: mysql-pod
  spec:
    containers:
    - name: mysql
      image: busybox:1.28
      imagePullPolicy: IfNotPresent
      command: [ "/bin/sh", "-c", "sleep 3600" ]
      env:
      - name: log_bin #定义环境变量 log_bin
        valueFrom:
          configMapKeyRef:
            name: mysql #指定 configmap 的名字
            key: log #指定 configmap 中的 key
      - name: lower #定义环境变量 lower
        valueFrom:
          configMapKeyRef:
            name: mysql
            key: lower
    restartPolicy: Never
  ```

  ```


  ​#更新资源清单文件
  ​


  ```

  ```

  [root@k8s-master01 ~]# kubectl apply -f mysql-pod.yaml
  ​
  [root@k8s-master01 ~]#  kubectl exec -it mysql-pod -- /bin/sh
  ​
  / # env
  log_bin=1
  KUBERNETES_PORT=tcp://10.10.0.1:443
  KUBERNETES_SERVICE_PORT=443
  HOSTNAME=mysql-pod
  NGINX_SVC_NODEPORT_PORT_8000_TCP_ADDR=10.10.166.16
  SHLVL=1
  HOME=/root
  NGINX_SVC_NODEPORT_PORT_8000_TCP_PORT=8000
  NGINX_SVC_NODEPORT_PORT_8000_TCP_PROTO=tcp
  SERVICE_BLUE_SERVICE_HOST=10.10.157.201
  NGINX_SVC_NODEPORT_SERVICE_HOST=10.10.166.16
  SERVICE_BLUE_SERVICE_PORT=80
  SERVICE_BLUE_PORT=tcp://10.10.157.201:80
  NGINX_SVC_NODEPORT_PORT_8000_TCP=tcp://10.10.166.16:8000
  TERM=xterm
  lower=1
  KUBERNETES_PORT_443_TCP_ADDR=10.10.0.1
  NGINX_SVC_NODEPORT_PORT=tcp://10.10.166.16:8000
  NGINX_SVC_NODEPORT_SERVICE_PORT=8000
  PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
  SERVICE_BLUE_PORT_80_TCP_ADDR=10.10.157.201
  KUBERNETES_PORT_443_TCP_PORT=443
  KUBERNETES_PORT_443_TCP_PROTO=tcp
  SERVICE_BLUE_PORT_80_TCP_PORT=80
  SERVICE_BLUE_PORT_80_TCP_PROTO=tcp
  KUBERNETES_SERVICE_PORT_HTTPS=443
  KUBERNETES_PORT_443_TCP=tcp://10.10.0.1:443
  KUBERNETES_SERVICE_HOST=10.10.0.1
  PWD=/
  SERVICE_BLUE_PORT_80_TCP=tcp://10.10.157.201:80
  ```

  #### 通过环境变量引入

#使用 envfrom变量 ​

```

[root@k8s-master01 ~]# cat  mysql-pod-envfrom.yaml
​
apiVersion: v1
kind: Pod
metadata:
  name: mysql-pod-envfrom
spec:
  containers:
  - name: mysql
    image: busybox:1.28
    imagePullPolicy: IfNotPresent
    command: [ "/bin/sh", "-c", "sleep 3600" ]
    envFrom:
    - configMapRef:
       name: mysql  #指定configmap的名字
  restartPolicy: Never
```

```


​
#更新资源清单文件
​

```

```

[root@k8s-master01 ~]# kubectl apply -f mysql-pod-envfrom.yaml
​
pod/mysql-pod-envfrom created
​
[root@k8s-master01 ~]# kubectl get pods
​
NAME                               READY   STATUS    RESTARTS   AGE
​
mysql-pod                          1/1     Running   0          13m
​
mysql-pod-envfrom                  1/1     Running   0          107s
​
[root@k8s-master01 ~]#  kubectl exec -it mysql-pod-envfrom -c mysql -- /bin/sh
​
/ # env
KUBERNETES_PORT=tcp://10.10.0.1:443
KUBERNETES_SERVICE_PORT=443
HOSTNAME=mysql-pod-envfrom
NGINX_SVC_NODEPORT_PORT_8000_TCP_ADDR=10.10.166.16
SHLVL=1
HOME=/root
NGINX_SVC_NODEPORT_PORT_8000_TCP_PORT=8000
NGINX_SVC_NODEPORT_PORT_8000_TCP_PROTO=tcp
SERVICE_BLUE_SERVICE_HOST=10.10.157.201
NGINX_SVC_NODEPORT_SERVICE_HOST=10.10.166.16
SERVICE_BLUE_SERVICE_PORT=80
SERVICE_BLUE_PORT=tcp://10.10.157.201:80
NGINX_SVC_NODEPORT_PORT_8000_TCP=tcp://10.10.166.16:8000
TERM=xterm
lower=1
KUBERNETES_PORT_443_TCP_ADDR=10.10.0.1
NGINX_SVC_NODEPORT_PORT=tcp://10.10.166.16:8000
NGINX_SVC_NODEPORT_SERVICE_PORT=8000
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
log=1
KUBERNETES_PORT_443_TCP_PORT=443
SERVICE_BLUE_PORT_80_TCP_ADDR=10.10.157.201
KUBERNETES_PORT_443_TCP_PROTO=tcp
SERVICE_BLUE_PORT_80_TCP_PORT=80
SERVICE_BLUE_PORT_80_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP=tcp://10.10.0.1:443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_SERVICE_HOST=10.10.0.1
PWD=/
SERVICE_BLUE_PORT_80_TCP=tcp://10.10.157.201:80
/ # 
```

#### 把 configmap 做成 volume，挂载到 pod（常用）

```

[root@k8s-master01 ~]# cat mysql-configmap.yaml
​
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql
  labels:
    app: mysql
data:
  log: "1"
  lower: "1"
  my.cnf: |
    [mysqld]
    welcome=duoduo
​
[root@k8s-master01 ~]# kubectl apply -f mysql-configmap.yaml
​
configmap/mysql configured
​
#查看详细配置信息
​
[root@k8s-master01 ~]# kubectl describe configmap mysql
​
Name:         mysql
Namespace:    default
Labels:       app=mysql
Annotations:  <none>
​
Data
====
log:
----
1
lower:
----
1
my.cnf:
----
[mysqld]
welcome=duoduo
​
​
BinaryData
====
​
Events:  <none>
​
#创建pod资源清单文件，挂载configmap卷
​
[root@k8s-master01 ~]# cat mysql-pod-volume.yaml
​
apiVersion: v1
kind: Pod
metadata:
  name: mysql-pod-volume
spec:
  containers:
  - name: mysql
    image: busybox:1.28
    imagePullPolicy: IfNotPresent
    command: [ "/bin/sh","-c","sleep 3600" ]
    volumeMounts:
    - name: mysql-config
      mountPath: /tmp/config
  volumes:
  - name: mysql-config
    configMap:
      name: mysql
  restartPolicy: Never
​
[root@k8s-master01 ~]# kubectl apply -f mysql-pod-volume.yaml
​
pod/mysql-pod-volume created
​
[root@k8s-master01 configmap]# kubectl exec -it mysql-pod-volume -- /bin/sh
/ # 
/ # 
/ # 
/ # cd /tmp/config/
/tmp/config # ls
log     lower   my.cnf
/tmp/config # ls -l
total 0
lrwxrwxrwx    1 root     root            10 Feb  1 08:12 log -> ..data/log
lrwxrwxrwx    1 root     root            12 Feb  1 08:12 lower -> ..data/lower
lrwxrwxrwx    1 root     root            13 Feb  1 08:12 my.cnf -> ..data/my.cnf
```

### 四、Configmap 热更新

**仅限于卷的形式，如果是环境变量的形式则不更新！！！**

限于应用程序能够对配置文件进行动态感知。nginx不行，需要在apply之后对pod执行命令：

```

nginx -s reload
```

```

[root@k8s-master01 ~]# kubectl edit configmap mysql
​
#将log:1 变成 log:2
apiVersion:v1
data:
 log:"2"
 lower:"1"
```

重新执行一次资源清单文件

```

[root@k8s-master01 test1]# kubectl apply -f mysql-pod-volume.yaml
​
pod/mysql-pod-volume configured
​
[root@k8s-master01 ~]# kubectl exec -it mysql-pod-volume -- /bin/sh
​
/ # cat /tmp/config/log
​
2/ #
​
#一次构建镜像，通过配置管理中心configmap 实现了 多场景运行
```



