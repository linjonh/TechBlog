---
layout: post
title: "SpringSpringAOP详解,彻底了解切点通知,附有注解和XML开发完整流程"
date: 2025-03-13 15:25:34 +0800
description: "本文详细介绍了SpringAOP机制，彻底了解切点，通知，包括获取增强方法的所有信息，涵盖注解方式以及XML配置方式的完整AOP开发流程"
keywords: "【Spring】SpringAOP详解，彻底了解切点通知，附有注解和XML开发完整流程"
categories: ['Ssm']
tags: ['Xml', 'Spring', 'Java']
artid: "146231880"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146231880
    alt: "SpringSpringAOP详解,彻底了解切点通知,附有注解和XML开发完整流程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146231880
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146231880
cover: https://bing.ee123.net/img/rand?artid=146231880
image: https://bing.ee123.net/img/rand?artid=146231880
img: https://bing.ee123.net/img/rand?artid=146231880
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Spring】SpringAOP详解，彻底了解切点通知，附有注解和XML开发完整流程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="SpringAOP_0">
     </a>
     SpringAOP
    </h2>
    <h3>
     <a id="_2">
     </a>
     概念
    </h3>
    <p>
     <img alt="image-20250313140655748" src="https://i-blog.csdnimg.cn/img_convert/44c93fa6d8f038a92ef5366a22a013bc.png"/>
    </p>
    <h3>
     <a id="_6">
     </a>
     快速入门
    </h3>
    <p>
     需求
    </p>
    <p>
     <img alt="image-20250313140746461" src="https://i-blog.csdnimg.cn/img_convert/7f48efb431e680d4b52acf4dbe097de3.png"/>
    </p>
    <p>
     导入依赖
    </p>
    <p>
     <img alt="image-20250313140802751" src="https://i-blog.csdnimg.cn/img_convert/a396889f9c33eabf39cd1080a3b78c67.png"/>
    </p>
    <p>
     xml文件开启aop支持
    </p>
    <p>
     <img alt="image-20250313140825703" src="https://i-blog.csdnimg.cn/img_convert/165a2701b61edd6232a82ff566f61ce0.png"/>
    </p>
    <p>
     <strong>
      自定义aspect切面类
     </strong>
    </p>
    <p>
     在类上加上@Component和@Aspect
     <br/>
     使用@Pointcut注解来指定要被增强的方法
     <br/>
     使用@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/44bc2071a707440eae9f17656ac12c7a.png"/>
    </p>
    <p>
     这里的@Pointcut注解就定义了一个切点，表示在这些包下所有的方法增强
     <br/>
     需要定义一个没有方法体的方法作为切入点表达式的一个标识
     <br/>
     如果有很多个切点，就需要对应写多个无方法体的方法来做标识
    </p>
    <p>
     结构
    </p>
    <p>
     <img alt="image-20250313141404849" src="https://i-blog.csdnimg.cn/img_convert/efe878a8ba7b78d20e09cddf6a371b83.png"/>
    </p>
    <p>
     service类代码加@Service注解
    </p>
    <p>
     <img alt="image-20250313141416639" src="https://i-blog.csdnimg.cn/img_convert/1b32459fd6104fc77d709b474f46e8db.png">
      <br/>
      <img alt="image-20250313141421238" src="https://i-blog.csdnimg.cn/img_convert/b3ed2f62db0af99c27a531700495f174.png"/>
     </img>
    </p>
    <p>
     测试类只调用deleteAll方法
    </p>
    <p>
     <img alt="image-20250313141429629" src="https://i-blog.csdnimg.cn/img_convert/6d608aec3b0db2387ab7e1ca19b30bbf.png"/>
    </p>
    <p>
     结果输出
    </p>
    <p>
     <img alt="image-20250313141438825" src="https://i-blog.csdnimg.cn/img_convert/d6ce276b1440922a15b6863d648ae110.png"/>
    </p>
    <hr/>
    <h3>
     <a id="_52">
     </a>
     专业名词
    </h3>
    <p>
     <img alt="image-20250313141538636" src="https://i-blog.csdnimg.cn/img_convert/b491c17d1fefb4a6e44cbe919fdb5b5f.png"/>
    </p>
    <p>
     <img alt="image-20250313141646212" src="https://i-blog.csdnimg.cn/img_convert/bbef1f46db28eb18c54a4152b3c7600f.png"/>
    </p>
    <p>
     <strong>
      代理类
     </strong>
    </p>
    <p>
     有了AOP增强的对象,通过.getBean获取的对象不是之前的对象,而是
     <strong>
      代理对象
     </strong>
     <br/>
     那么没有AOP增强的对象通过.getBean获取的对象是之前的对象
    </p>
    <hr/>
    <h3>
     <a id="_65">
     </a>
     切点
    </h3>
    <h4>
     <a id="_67">
     </a>
     切点表达式
    </h4>
    <p>
     <img alt="image-20250313142453221" src="https://i-blog.csdnimg.cn/img_convert/5d2eeb607cc75020be2c95b17be490d4.png"/>
    </p>
    <p>
     <img alt="image-20250313142457652" src="https://i-blog.csdnimg.cn/img_convert/65ca1869615075c5b5a727580f9240f8.png"/>
    </p>
    <p>
     返回值类型,包名,类名,方法名,参数
    </p>
    <p>
     <img alt="image-20250313142544924" src="https://i-blog.csdnimg.cn/img_convert/6b72ae70a75f8bdf424a81f1508bb58f.png"/>
    </p>
    <hr/>
    <h4>
     <a id="_79">
     </a>
     切点函数
    </h4>
    <p>
     @
     <strong>
      annotation
     </strong>
    </p>
    <p>
     可以自定义哪些方法需要增强
    </p>
    <p>
     1.自定义注解@InvokeLog（名称任意）
    </p>
    <p>
     <img alt="image-20250313143110763" src="https://i-blog.csdnimg.cn/img_convert/e3df2fdd887e5bbeb5927d8c8f40cf14.png"/>
    </p>
    <p>
     2.给需要增强的方法上增加我们的注解
    </p>
    <p>
     <img alt="image-20250313143240912" src="https://i-blog.csdnimg.cn/img_convert/6f0657c2c6f8dcfb4a1c09ef506cc2ba.png"/>
    </p>
    <p>
     3.在切面类使用@annotation(自定义注解全类名)
    </p>
    <p>
     <img alt="image-20250313143301383" src="https://i-blog.csdnimg.cn/img_convert/0e65f0a90d03bf63c51823d0f324b96b.png"/>
    </p>
    <hr/>
    <h3>
     <a id="_99">
     </a>
     通知
    </h3>
    <h4>
     <a id="_101">
     </a>
     通知分类
    </h4>
    <p>
     <img alt="image-20250313143600452" src="https://i-blog.csdnimg.cn/img_convert/1bdd3936eb5a593e3ca654c0ab1809a6.png"/>
    </p>
    <p>
     伪代码用于理解执行时机
    </p>
    <p>
     <img alt="image-20250313143649786" src="https://i-blog.csdnimg.cn/img_convert/342af0d24ff7bc94a392eef3754608ec.png"/>
    </p>
    <p>
     <strong>
      环绕通知@Around
     </strong>
    </p>
    <p>
     方法参数获取ProceedingJoinPont对象
     <br/>
     通过对象调用proceed()执行
     <strong>
      目标方法
     </strong>
     <br/>
     然后try-catch
     <br/>
     在任意位置写增强代码
    </p>
    <p>
     <img alt="image-20250313143954587" src="https://i-blog.csdnimg.cn/img_convert/2dfe62db199290165ede2b23bac086f7.png"/>
    </p>
    <p>
     通过给通知方法传递ProceedingJoinPont对象参数
     <br/>
     然后在try-catch中用这个对象调用proceed()方法，也就是增强目标方法
     <br/>
     就可以把增强的方法写在1234任意位置
    </p>
    <hr/>
    <h4>
     <a id="_124">
     </a>
     获取被增强方法的信息
    </h4>
    <p>
     只有获取了被增强方法的信息才能有效的增强方法,而不是简单的输出语句
    </p>
    <p>
     我们可以在
     <strong>
      除了环绕通知外的所有通知方法
     </strong>
     中增加一个JoinPoint类型的参数。
     <br/>
     这个参数封装了被增强方法的相关信息。
     <br/>
     我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/06b580756ba6c69503d3ecff172287ef.png"/>
    </p>
    <p>
     一般通过.getSignature()获取签名封装对象后再去.get其他方法
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/92d679e2e0ce44ebac56f9740545671f.png"/>
    </p>
    <hr/>
    <p>
     <strong>
      获取增强方法的返回值和异常对象
     </strong>
    </p>
    <p>
     需要在方法参数上增加一个对应类型的参数
     <br/>
     并且使用注解的属性进行配置。这样Spring会把你想获取的数据赋值给对应的方法参数。
    </p>
    <p>
     <img alt="image-20250313145437702" src="https://i-blog.csdnimg.cn/img_convert/592b483da15d57570fc9ed137da2c597.png"/>
    </p>
    <p>
     返回值在@AfterReturning里使用,异常对象在@AfterThrowing里使用
     <br/>
     因为注解有多个参数,所以value不能省略了
    </p>
    <p>
     <strong>
      在通知方法中就可以通过传递参数用ret. 和t.去使用获取到的东西了
     </strong>
    </p>
    <hr/>
    <h4>
     <a id="_155">
     </a>
     环绕通知获取信息
    </h4>
    <p>
     <img alt="image-20250313150554592" src="https://i-blog.csdnimg.cn/img_convert/08686c23fa39a40e68f1aca01eeee0da.png"/>
    </p>
    <p>
     该参数的proceed()方法被调用相当于被增强方法被执行
     <br/>
     调用后的返回值就相当于被增强方法的返回值。
    </p>
    <p>
     <strong>
      注意事项
     </strong>
    </p>
    <p>
     如果有返回值,在通知方法也要有返回值
     <br/>
     return的是通知方法的返回值,不是增强方法的返回值,只是获取到了增强方法的返回值通过通知方法返回
     <br/>
     可以进行篡改
    </p>
    <p>
     <img alt="image-20250313150733178" src="https://i-blog.csdnimg.cn/img_convert/7c22c46ec9d544f72fb01a397f3ce45a.png"/>
    </p>
    <h3>
     <a id="AOP_170">
     </a>
     注解方式配置AOP完整流程
    </h3>
    <p>
     结构
    </p>
    <p>
     <img alt="image-20250313150802279" src="https://i-blog.csdnimg.cn/img_convert/4590f31628008c7048d0924b38f2ab4c.png"/>
    </p>
    <p>
     依赖
    </p>
    <p>
     <img alt="image-20250313150820020" src="https://i-blog.csdnimg.cn/img_convert/42a5d6a1efb11f4a2483c0c3fab49504.png"/>
    </p>
    <p>
     xml文件
    </p>
    <p>
     <img alt="image-20250313150827322" src="https://i-blog.csdnimg.cn/img_convert/b446bbe00bd37a339ba7b33ad2612af7.png"/>
    </p>
    <p>
     自定义注解
    </p>
    <p>
     <img alt="image-20250313150835632" src="https://i-blog.csdnimg.cn/img_convert/658cebe359e19bf5683510e89a3ebe10.png"/>
    </p>
    <p>
     切面类
    </p>
    <p>
     <img alt="image-20250313150852915" src="https://i-blog.csdnimg.cn/img_convert/8970c029d2bbf4ebe7f9bea26f573dd3.png"/>
    </p>
    <p>
     实现类
    </p>
    <p>
     <img alt="image-20250313150913473" src="https://i-blog.csdnimg.cn/img_convert/b32b08402a291be47e2932da4c6527b8.png"/>
    </p>
    <p>
     工具类略
    </p>
    <p>
     测试类
    </p>
    <p>
     <img alt="image-20250313150926862" src="https://i-blog.csdnimg.cn/img_convert/5e715a25787619560f29502ccf4f3d53.png"/>
    </p>
    <h4>
     <a id="XMLAOP_202">
     </a>
     XML配置AOP（可跳过）
    </h4>
    <p>
     定义切面类
     <br/>
     没有@Aspect@Pointcut@Around等注解,
     <br/>
     但是要放到spring容器中,要加@Component注解
    </p>
    <p>
     目标类和切面类都要放到容器中
    </p>
    <p>
     <img alt="image-20250313151121278" src="https://i-blog.csdnimg.cn/img_convert/9d85876861c11a4ff6430ca9bbc7942a.png"/>
    </p>
    <p>
     依赖
    </p>
    <p>
     <img alt="image-20250313151139740" src="https://i-blog.csdnimg.cn/img_convert/5910d6694d600032aafbac1e75475894.png"/>
    </p>
    <p>
     xml文件配置
    </p>
    <p>
     <img alt="image-20250313151147224" src="https://i-blog.csdnimg.cn/img_convert/c0b4b74e916524fd846d4329567f6328.png"/>
    </p>
    <hr/>
    <h4>
     <a id="_222">
     </a>
     多切面顺序问题
    </h4>
    <p>
     在实际项目中我们可能会存在配置了多个切面类的情况。这种情况下我们很可能需要控制切面的顺序。
     <br/>
     我们在默认情况下Spring有它自己的排序规则。（按照类名排序）
    </p>
    <p>
     如果是注解方式配置的AOP可以在切面类上加@Order注解来控制顺序。@Order中的属性越小优先级越高。
     <br/>
     如果是XML方式配置的AOP,可以通过调整配置顺序来控制。
    </p>
    <p>
     下面这种配置方式就会先使用CryptAspect里面的增强，在使用APrintLogAspect里的增强
    </p>
    <p>
     <img alt="image-20250313151220505" src="https://i-blog.csdnimg.cn/img_convert/e0e1ce9188baa77ab89f777d6d61f50d.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37393434393633342f:61727469636c652f64657461696c732f313436323331383830" class_="artid" style="display:none">
 </p>
</div>


