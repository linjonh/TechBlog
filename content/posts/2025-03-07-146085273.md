---
layout: post
title: "Java-数据结构栈和队列Stack-Queue"
date: 2025-03-07 20:41:44 +0800
description: "栈(Stack）：是一种特殊的线性表，它只能在表的一端（称为栈顶）进行插入和删除操作。可以将栈理解成一摞盘子，只能从上面进行取走，还放在最上面 栈顶：进行插入和删除的位置栈底： 不能进行插入和删除栈顶的元素会发生改变，但是栈底的元素相对来说是固定的特点：后进先出（LIFO）：先进入栈的元素，会最后一个取出操作的局部性：栈的操作只涉及栈顶元素，不会影响到栈中的其他元素。 主要操作：其中usedSize表示栈中元素的个数  主要操作： 主要操作：判空，为空则返回null，否则返回栈顶元素"
keywords: "【Java---数据结构】栈和队列【Stack & Queue】"
categories: ['未分类']
tags: ['算法', '数据结构', '开发语言', 'Java']
artid: "146085273"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146085273
    alt: "Java-数据结构栈和队列Stack-Queue"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146085273
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146085273
cover: https://bing.ee123.net/img/rand?artid=146085273
image: https://bing.ee123.net/img/rand?artid=146085273
img: https://bing.ee123.net/img/rand?artid=146085273
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Java---数据结构】栈和队列【Stack &amp; Queue】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     栈
    </h2>
    <h2 style="background-color:transparent">
     一. 栈的概念
    </h2>
    <p>
     栈(Stack）：是一种特殊的线性表，它只能在表的一端（称为栈顶）进行插入和删除操作。
    </p>
    <p>
     可以将栈理解成一摞盘子，只能从上面进行取走，还放在最上面
    </p>
    <p class="img-center">
     <img alt="" height="238" src="https://i-blog.csdnimg.cn/direct/862625b16ca74014ad15a314a7eff954.png" width="303"/>
    </p>
    <p>
    </p>
    <p>
     栈顶：进行插入和删除的位置
    </p>
    <p>
     栈底： 不能进行插入和删除
    </p>
    <p>
     栈顶的元素会发生改变，但是栈底的元素相对来说是固定的
    </p>
    <p>
     特点：
    </p>
    <p>
     <strong>
      后进先出（LIFO）：先进入栈的元素，会最后一个取出
     </strong>
    </p>
    <p>
     <strong>
      操作的局部性：栈的操作只涉及栈顶元素，不会影响到栈中的其他元素。
     </strong>
    </p>
    <h2 style="background-color:transparent">
     <strong>
      二. 栈的基本操作
     </strong>
    </h2>
    <h3>
     1. 栈内方法的实现
    </h3>
    <h4 style="background-color:transparent">
     （1）增加
    </h4>
    <pre><code class="language-java">    public void push(int val){
        if(isFull()){
            //扩容
            elem = Arrays.copyOf(elem,elem.length+1);
        }
            elem[usedSize++] = val;
    }</code></pre>
    <p>
     主要操作：
    </p>
    <ol>
     <li>
      先判满，如果满则进行扩容，然后赋值，不满则直接进行赋值
     </li>
    </ol>
    <p>
     其中usedSize表示栈中元素的个数
    </p>
    <h4>
     （2）删除
    </h4>
    <pre><code class="language-java">    public Object  pop(){
        Object o = null;
        if(!isempty()){
//            usedSize表示下一个该放的位置
           o =  elem[usedSize-1];
           usedSize--;
        }else {
             System.out.println("栈为空");
             return null;
        }
        return o;
    }</code></pre>
    <p>
     主要操作：
    </p>
    <ol>
     <li>
      先进行判空，如果栈为空，则返回null,不为空则进行删除操作，删除操作：usedSize--，
     </li>
    </ol>
    <h4>
     （3）获取
    </h4>
    <pre><code class="language-java">    public Object peak(){
        Object o = null;
        if(!isempty()){
            o =  elem[usedSize-1];
        }else {
            System.out.println("栈为空");
            return null;
        }
        return o;
    }</code></pre>
    <p>
     主要操作：
    </p>
    <p>
     判空，为空则返回null，否则返回栈顶元素
    </p>
    <h4>
     （4）判空
    </h4>
    <pre><code class="language-java">    public Boolean isempty(){
        if(usedSize!=0){
            return false;
        }
        return true;
    }</code></pre>
    <p>
     元素为0，则表示为空
    </p>
    <h4>
     （5）判满
    </h4>
    <pre><code class="language-java">    Boolean isFull(){
        if(usedSize&gt;=elem.length){
            return true;
        }
        return false;
    }</code></pre>
    <p>
     如果大于栈的容量，则表示栈满
    </p>
    <h3 style="background-color:transparent">
     2. 栈内方法的使用
    </h3>
    <p>
     push（）：数据入栈
    </p>
    <p>
     pop（）：数据出栈
    </p>
    <p>
     peak（）：查看栈顶元素
    </p>
    <p>
     empty（）：判断栈中是否还有元素
    </p>
    <pre><code class="language-java">public class Text_1 {
    public static void main(String[] args) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        //存放数据
        stack.push(1);
        stack.push(2);
        //删除数据
        stack.pop();//删除最后进来的一个元素
        //获取
        stack.peek();//获取最后一个元素，不删除
        //判断栈是否为空
        stack.empty();
    }
}</code></pre>
    <p>
     通过创建Stack对象，使用Stack内的方法操作
    </p>
    <h2>
     三.  实现方式
    </h2>
    <h3>
     1. 基于数组实现
    </h3>
    <p>
     优点：
    </p>
    <ol>
     <li>
      访问速度快：数组支持随机访问，时间复杂度为O(1)。
     </li>
     <li>
      空间利用率高：不需要额外的指针存储空间。
     </li>
    </ol>
    <p>
     缺点：
    </p>
    <ol>
     <li>
      大小固定：数组的大小在创建时需要预先定义，无法动态扩展。
     </li>
     <li>
      可能浪费空间：如果栈的使用量远小于数组大小，会浪费存储空间。
     </li>
     <li>
      可能栈溢出：如果栈的使用量超过数组大小，会发生栈溢出。
     </li>
    </ol>
    <h3 style="background-color:transparent">
     2. 基于链表实现
    </h3>
    <p>
     优点：
    </p>
    <ol>
     <li>
      动态扩展：链表的大小可以动态变化，不需要预先定义。
     </li>
     <li>
      不会栈溢出：只要内存足够，栈可以无限扩展。
     </li>
    </ol>
    <p>
     缺点：
    </p>
    <ol>
     <li>
      访问速度慢：链表不支持随机访问，每次操作都需要遍历。
     </li>
     <li>
      额外空间开销：每个节点需要额外存储一个指针。
     </li>
    </ol>
    <p class="img-center">
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/ef505c4712084ac7982b3f754cc3c05c.png" width="312"/>
    </p>
    <p>
     <strong>
      单向列表
     </strong>
     ：
    </p>
    <p>
     在单向链表的插入中，分为两种，头插法和尾插法
    </p>
    <p>
     头插法的时间复杂度为O（1）---- 头插法只需要修改头节点的指针和新节点的指针
    </p>
    <p>
     尾插法的时间复杂度为O（n）---- 每次插入操作都需要遍历整个链表以找到最后一个节点。
    </p>
    <p>
     <strong>
      双向链表
     </strong>
     ：
    </p>
    <p>
     双向链表的头插法和尾插法，时间复杂度都为O（1）
    </p>
    <p>
     注意：
     <strong>
      我们一般使用的基于链表的栈都为双向链表
     </strong>
    </p>
    <p>
     <strong>
      总结：
     </strong>
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="height:200px; width:700px">
     <tbody>
      <tr>
       <td>
        不同点
       </td>
       <td style="width:259px">
        基于数组的栈
       </td>
       <td style="width:354px">
        基于链表的栈
       </td>
      </tr>
      <tr>
       <td>
        空间大小
       </td>
       <td style="width:259px">
        预先定义大小，可能浪费空间或溢出
       </td>
       <td style="width:354px">
        动态扩展，不会溢出，但需要额外指针空间
       </td>
      </tr>
      <tr>
       <td>
        访问速度
       </td>
       <td style="width:259px">
        O(1)，访问速度快
       </td>
       <td style="width:354px">
        O(1)，访问速度快，但链表操作稍复杂
       </td>
      </tr>
      <tr>
       <td>
        灵活性
       </td>
       <td style="width:259px">
        固定大小，不适合动态变化
       </td>
       <td style="width:354px">
        动态大小，适合动态变化
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     四. 栈的应用
    </h2>
    <h3 style="background-color:transparent">
     （1）逆波兰数的运算
    </h3>
    <p>
     图分析
    </p>
    <p class="img-center">
     <img alt="" height="393" src="https://i-blog.csdnimg.cn/direct/9f8c5d28f8264251b76a9c0a5a53c0e9.png" width="462"/>
    </p>
    <p>
     <strong>
      主要步骤为：
     </strong>
    </p>
    <ol>
     <li>
      后缀式中的元素依次入栈
     </li>
     <li>
      如果遇到运算符，则取出栈中的两个元素，取出的第一个元素，放在第二位，取出的第二个元素放在第一位，进行运算，
     </li>
     <li>
      运算后得到的结果放入栈内。
     </li>
    </ol>
    <p>
     <strong>
      代码实现
     </strong>
    </p>
    <pre><code class="language-java">public class Text_3 {
    public int evalRPN(String[] tokens){
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        int num = 0;
        for(String s:tokens){
            //检查是不是运算符
            if(!isOperation(s)){
                //字符串类型变为整型
                stack.push(Integer.parseInt(s));
            }else{
                //取出栈里面的数据
                int x2 = stack.pop();
                int x1 = stack.pop();

                switch (s){
                    case "+":
                        num = x1+x2;
                        break;
                    case "-":
                        num = x1-x2;
                        break;
                    case "*":
                        num = x1*x2;
                        break;
                    case  "/":
                        num = x1/x2;
                        break;
                }
                //将运算后的结果返回栈内
                stack.push(num);
            }
        }
        //结果为栈内第一个元素
        return stack.peek();
    }
    public boolean isOperation(String s){
        if(s.equals("+")||s.equals("-")||s.equals("*")||s.equals("/")){
            return true;
        }
        return false;
    }
}</code></pre>
    <h3 style="background-color:transparent">
     （2）用栈得到最小数
    </h3>
    <p>
     <strong>
      最小数不是固定的，会随着添加的数据进行改变
     </strong>
    </p>
    <p>
     图分析：
    </p>
    <p>
     <img alt="" height="742" src="https://i-blog.csdnimg.cn/direct/eb51b73caae54811a7040f29ba38a04a.png" width="993"/>
    </p>
    <p>
     主要步骤：
    </p>
    <p>
     <strong>
      入栈操作：
     </strong>
    </p>
    <ol>
     <li>
      每次执行入栈操作，不管stack是否为空都要进行入栈操作，
     </li>
     <li>
      在入栈的时候，进行判断：如果stack为空（stack栈为空，则minstack栈一定为空），则minstack和stack都要进行入栈操作
     </li>
     <li>
      minstack不为空，需要对入栈的元素进行判断，如果小于minstack栈顶元素，则入栈
     </li>
    </ol>
    <p>
     <strong>
      出栈操作：
     </strong>
    </p>
    <ol>
     <li>
      每次执行出栈操作的时候，stack栈都要执行出栈操作
     </li>
     <li>
      在每次stack出栈的时候，要进行判断，如果出栈的元素和minstack的栈顶元素相同，则minstack也要进行出栈操作
     </li>
    </ol>
    <p>
     <strong>
      代码实现：
     </strong>
    </p>
    <pre><code class="language-java">class MinStack {
    private Stack&lt;Integer&gt; stack;
    private Stack&lt;Integer&gt; minStack;

    public MinStack() {
        stack = new Stack&lt;&gt;();
        minStack  = new Stack&lt;&gt;();
    }
    public void push(int val) {
        if(minStack.empty()){
            //为空，都要入栈
            minStack.push(val);
        }else {
            //不为空进行判断
            if(val&lt;=minStack.peek()){
                minStack.push(val);
            }
        }
        stack.push(val);
    }

    public void pop() {
        if(!stack.empty()){
             int x = stack.pop();
             if(x == minStack.peek()){
                 minStack.pop();
             }
        }
    }

    public int top() {
        if(stack.empty()) {
            return -1;
        }
        return stack.peek();

    }

    public int getMin() {
        if(minStack.empty()){
           return -1;
        }
        return minStack.peek();

    }
}</code></pre>
    <h2 style="background-color:transparent">
     队列
    </h2>
    <h2 style="background-color:transparent">
     一. 队列的概念
    </h2>
    <p>
     队列是一种线性表，只允许在表的一端（队尾，rear）进行插入操作，在另一端（队头，front）进行删除操作。
    </p>
    <p class="img-center">
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/cd40bd4167a24d979eb428e7fa0e30a4.png" width="303"/>
    </p>
    <p>
     类似于现实生活中排队，新来的人总是排在队尾，而排在队头的人会先接受服务然后离开队伍。
    </p>
    <p>
     队头：允许删除的一端
    </p>
    <p>
     队尾：允许插入的一端。
    </p>
    <p>
     特点：
    </p>
    <p>
     <strong>
      先进先出（FIFO）：
     </strong>
     最先进入队列的元素会最先被移除，一种先来先服务的原则。
    </p>
    <h2>
     二. 队列的基本操作
    </h2>
    <h3 style="background-color:transparent">
     1.队列内方法的实现
    </h3>
    <p>
     基于链表的队列实现
    </p>
    <h4>
     （1）入队
    </h4>
    <pre><code class="language-java">  //插入操作 采用头插法
    public void offer(int val){
        ListNode cur = new ListNode(val);
        if(front ==null){
            front = rear = cur;
        }else {
            cur.next= front;
            cur.prev = null;
            front.prev = cur;
            front = cur;
        }
        usedSize++;
    }
</code></pre>
    <p>
     主要步骤：采用头插法
    </p>
    <ol>
     <li>
      <p>
       如果队列为空，将头指针（front）和尾指针（rear）都指向新节点。
      </p>
     </li>
     <li>
      <p>
       否则，使用头插法将新节点插入到链表头部。
      </p>
     </li>
    </ol>
    <h4>
     （2）出队
    </h4>
    <pre><code class="language-java">  public int poll(){

        //为空
        if(front ==null){
            return -1;
        }
        int ret = rear.val;
        //只有一个
        if(front ==rear){
            front = null;
            rear = null;
            usedSize--;
            return ret;
        }
        rear = rear.prev;
        rear.next = null;
        usedSize--;
        return ret;
    }
</code></pre>
    <p>
     主要步骤：
    </p>
    <ol>
     <li>
      <p>
       如果队列中只有一个元素，将头指针和尾指针都置为null；
      </p>
     </li>
     <li>
      <p>
       否则，将rear指针前移一位，并将新的尾指针的next 置为null。
      </p>
     </li>
    </ol>
    <h4>
     （3）获取
    </h4>
    <pre><code class="language-java">  public int peak(){
        if(front ==null){
            return -1;
        }
        return rear.val;
    }</code></pre>
    <h4>
     （4）判空
    </h4>
    <pre><code class="language-java">    public boolean isEmpty(){
        if(usedSize ==0){
            return true;
        }
        return false;
    }</code></pre>
    <p>
     如果队列内元素为空，则返回true
    </p>
    <h3 style="background-color:transparent">
     2. 队列内方法的使用
    </h3>
    <p>
     入队操作：add( )和offer( )
    </p>
    <p>
     出队操作：remove( )和poll( )
    </p>
    <p>
     获取队头元素：peek( )和element（）
    </p>
    <p>
     获取队列元素个数：size( )
    </p>
    <pre><code class="language-java">public class Text_1 {
    public static void main(String[] args) {
        //底层通过链表实现
        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;() ;
        //入队
        queue.add(2);
        queue.offer(1);
        System.out.println(queue);
        //出队
        queue.remove();
        System.out.println(queue);
//        queue.poll();
        //获取队列第一个元素
        System.out.println(queue.peek());
        System.out.println(queue.element());
        //获取队列元素
        System.out.println(queue.size());
    }
}
</code></pre>
    <p>
     通过对Queue接口实例化，这意味着LinkedList类为Queue接口中定义的所有方法都提供了具体的实现。
    </p>
    <h2>
     三. 实现方式
    </h2>
    <h3 style="background-color:transparent">
     1. 基于数组实现
    </h3>
    <p>
     数组实现的队列使用一个固定大小的数组来存储队列中的元素，通过两个指针（队头指针和队尾指针）来管理队列的插入和删除操作。
    </p>
    <p>
     <strong>
      数组实现的队列需要解决“队列溢出”和“队列空间浪费”的问题，所以一般采用循环队列的方式
     </strong>
    </p>
    <p style="background-color:transparent">
     <span style="color:#38d8f0">
      <strong>
       循环队列
      </strong>
     </span>
    </p>
    <p>
     <strong>
      在循环队列中如何区分空和满？
     </strong>
    </p>
    <ol>
     <li>
      <span style="color:#333333">
       通过添加
      </span>
      <span style="color:#333333">
       size
      </span>
      <span style="color:#333333">
       属性记录
      </span>
     </li>
     <li>
      <span style="color:#333333">
       保留一个位置
      </span>
     </li>
    </ol>
    <p>
     其中rear表示插入的位置，front表示删除的位置
    </p>
    <p>
     <img alt="" height="913" src="https://i-blog.csdnimg.cn/direct/efd9c3838031421b87daa01a28fe503b.png" width="1522"/>
    </p>
    <p>
     <strong>
      空队列：
     </strong>
    </p>
    <p>
     当rear==front的时候处于空队列
    </p>
    <p>
     <strong>
      满队列：
     </strong>
    </p>
    <p>
     当（rear+1）%长度 = front
    </p>
    <p>
     注意：
    </p>
    <p>
     在申请空间的时候，一定要在申请大小的基础上加1，因为一个空间不存放数据，用于判断队列的空或满
    </p>
    <p>
     （1）判满
    </p>
    <pre><code class="language-java">    public boolean isFull(){
        if((rear+1)% elem.length ==front){
            return true;
        }
        return false;
    }</code></pre>
    <p>
     （2）判空
    </p>
    <pre><code class="language-java">    public boolean isEmpty(){
        if(rear == front ){
            return true;
        }
        return false;
    }</code></pre>
    <p>
     （3）出队
    </p>
    <pre><code class="language-java">    public boolean deQueue(){
        if(isEmpty()){
            return false;
        }
        elem[front]= 0;
        front = (front+1)%elem.length;
        return true;
    }</code></pre>
    <p>
     主要操作：
    </p>
    <ol>
     <li>
      判空，如果为空则表明无法进行出队操作
     </li>
     <li>
      不为空，则将front下标的元素置为0，下标加1（不能直接加1操作，要取模）
     </li>
    </ol>
    <p>
     （4）入队
    </p>
    <pre><code class="language-java">    public boolean enQueue(int val){
        if(isFull()){
            return false;
        }else {
            elem[rear] = val;
            rear = (rear+1)%elem.length;
        }
        return true;
    }</code></pre>
    <p>
     主要操作：
    </p>
    <ol>
     <li>
      判满，如果满了则不能进行入队操作
     </li>
     <li>
      不满，则将元素赋值在rear下标的位置，下标加1（不能直接加1操作，要取模）
     </li>
    </ol>
    <p>
     （5）获取
    </p>
    <p>
     返回队首元素
    </p>
    <pre><code class="language-java">    public int Front(){
        if(isEmpty()){
            return -1;
        }
        return elem[front];
    }</code></pre>
    <p>
     返回队尾元素
    </p>
    <pre><code class="language-java">    public int Rear(){
        if(isEmpty()){
            return -1;
        }
        int index = 0;
        if(rear ==0){
            index = elem.length-1;
        }else {
            index = rear-1;
        }
        return elem[index];
    }</code></pre>
    <p>
     注意：不为空，才能获取
    </p>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ol>
     <li>
      空间利用率高，通过循环队列设计避免了空间浪费。
     </li>
     <li>
      访问速度快，所有操作的时间复杂度均为
      <strong>
       O(1)
      </strong>
      。
     </li>
    </ol>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ol>
     <li>
      队列大小固定，需要提前定义容量。
     </li>
     <li>
      如果队列容量不足，可能会导致队列溢出。
     </li>
    </ol>
    <h3 style="background-color:transparent">
     2.
     <strong>
      基于链表的队列实现
     </strong>
    </h3>
    <p>
     具体的实现过程上面已经进行了说明
    </p>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ol>
     <li>
      动态扩展，不会出现队列溢出的问题。
     </li>
     <li>
      所有操作的时间复杂度均为
      <strong>
       O(1)
      </strong>
      。
     </li>
    </ol>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ol>
     <li>
      占用空间较大，需要一些空间存放指针
     </li>
    </ol>
    <h2 style="background-color:transparent">
     四. 队列的应用
    </h2>
    <h3>
     （1）
     <a href="https://leetcode.cn/problems/implement-queue-using-stacks/" rel="nofollow" title="用栈实现队列">
     </a>
    </h3>
    <p>
     <img alt="" height="836" src="https://i-blog.csdnimg.cn/direct/aef62c8814db4d05b0af388c10267e8a.png" width="2050"/>
    </p>
    <p>
     主要操作：
    </p>
    <ol>
     <li>
      将元素依次放入stack1，在将stack1中的元素依次放入stack2中，这时候会发现栈顶的元素和队列第一个元素相等
     </li>
    </ol>
    <pre><code class="language-java">class MyQueue {
    Stack&lt;Integer&gt; stack1;
    Stack&lt;Integer&gt; stack2;

    public MyQueue() {
        this.stack1 = new Stack&lt;&gt;();
        this.stack2 = new Stack&lt;&gt;();
    }

    //增加操作
    public void push(int x) {
        stack1.push(x);
    }

    public int pop() {
        if(stack2.isEmpty()){
            while (!stack1.isEmpty()){
                int tmp = stack1.pop();
                stack2.push(tmp); 
            }
        }
        return stack2.pop();
    }

    public int peek() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                int tmp = stack1.pop();
                stack2.push(tmp);
            }
        }
        return stack2.peek();
    }
    public boolean empty() {
        if(stack1.isEmpty()&amp;&amp; stack2.isEmpty()){
            return true;
        }
        return false;
    }
}</code></pre>
    <h3 style="background-color:transparent">
     （2）
     <a href="https://leetcode.cn/problems/implement-stack-using-queues/" rel="nofollow" title="用队列实现栈">
      用队列实现栈
     </a>
    </h3>
    <p>
     <img alt="" height="955" src="https://i-blog.csdnimg.cn/direct/f9808f709f0d4cb78353de1113ad9c2f.png" width="1937"/>
    </p>
    <p>
     主要操作：
    </p>
    <p>
     <strong>
      入队操作：
     </strong>
    </p>
    <p>
     如果两个队列都为空，那么入队到第一个
    </p>
    <p>
     如果一个空，一个不为空，那么元素入队到不为空的队列中
    </p>
    <p>
     <strong>
      出队操作：
     </strong>
    </p>
    <p>
     将元素依次入队到queue1中，在将 queue1中
     <span style="color:#fe2c24">
      <strong>
       size（）-1
      </strong>
     </span>
     <span style="color:#0d0016">
      的
     </span>
     元素依次入队到queue2中，queue1中剩下的这个元素就是栈顶元素
    </p>
    <p>
     代码实现：
    </p>
    <pre><code class="language-java">class MyStack {
    Queue&lt;Integer&gt; queue1;
    Queue&lt;Integer&gt; queue2;

    public MyStack() {
        queue1 = new LinkedList&lt;&gt;();
        queue2 = new LinkedList&lt;&gt;();
    }

    public void push(int x) {
        //如果为空，在que1加，否则那个有数据加到那个
        if(empty()){
            queue1.offer(x);
        }else {
            if(!queue1.isEmpty()){
                queue1.offer(x);
            }else {
                queue2.offer(x);
            }
        }
    }

    public int pop() {
        //删除操作，将最后一个元素前面的所有元素移到另一个队列中储存，
//        最后一个元素不移，删除最后一个元素
        if(empty()){
            return -1;
        }
        if(!queue1.isEmpty()){
            int size = queue1.size();
            while(size-1&gt;0){
                int tmp = queue1.poll();
                queue2.offer(tmp);
                size--;
            }
            return queue1.poll();
        }else {
            int size = queue2.size();
            while(size-1&gt;0){
                int tmp = queue2.poll();
                queue1.offer(tmp);
                size--;
            }
            return queue2.poll();
        }
    }

    public int top() {
        //获取操作，将所有的元素移过去，记住最后一个元素的值，并返回
        if(empty()){
            return -1;
        }
        int tmp= -1;
        if(!queue1.isEmpty()){
            int size = queue1.size();
            while(size&gt;0){
                tmp = queue1.poll();
                queue2.offer(tmp);
                size--;
            }
            return tmp;
        }else {
            int size = queue2.size();
            while(size&gt;0){
                tmp = queue2.poll();
                queue1.offer(tmp);
                size--;
            }
            return tmp;
        }
    }

    public boolean empty() {
        if(queue1.isEmpty()&amp;&amp;queue2.isEmpty()){
            return true;
        }
        return false;
    }
}
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37383538333638372f:61727469636c652f64657461696c732f313436303835323733" class_="artid" style="display:none">
 </p>
</div>


