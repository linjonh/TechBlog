---
layout: post
title: "失败的面试经历"
date: 2025-03-16 19:54:26 +0800
description: "1.封装：将对象内部的属性私有化，外部对象不能够直接访问，但是可以提供一些可以使外部对象操作内部属性的方法。2.继承：类与类之间会有一些相似之处，但也会有一些异处，使得他们与众不同，继承就是在父类的基础上，创建一个与父类有相同之处，但是也可以声明自己独有的方法与属性的对象，这样做可以增加代码的复用，使得维护或扩展更加的方便，灵活。3.多态：一个对象有多种状态，这涉及到了向上或向下转型。"
keywords: "失败的面试经历(ʘ̥∧ʘ̥)"
categories: ['未分类']
tags: ['面试', '职场和发展']
artid: "146266266"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146266266
    alt: "失败的面试经历"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146266266
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146266266
cover: https://bing.ee123.net/img/rand?artid=146266266
image: https://bing.ee123.net/img/rand?artid=146266266
img: https://bing.ee123.net/img/rand?artid=146266266
---

# 失败的面试经历(ʘ̥∧ʘ̥)

## 一.面向对象的三大特性

1.封装：将对象内部的属性私有化，外部对象不能够直接访问，但是可以提供一些可以使外部对象操作内部属性的方法。

2.继承：类与类之间会有一些相似之处，但也会有一些异处，使得他们与众不同，继承就是在父类的基础上，创建一个与父类有相同之处，但是也可以声明自己独有的方法与属性的对象，这样做可以增加代码的复用，使得维护或扩展更加的方便，灵活。

3.多态：一个对象有多种状态，这涉及到了向上或向下转型。  
多态的特点：

  * 对象类型和引用类型之间存在继承关系
  * 引用类型变量的方法属于哪个类，要想知道这个问题，要看运行期间
  * 多态不能执行子类拥有但父类没有的方法
  * 如果子类重写了父类的方法，那么直接执行的是子类重新后的方法，若没重写，则执行的是父类方法

## 二.如何创建线程

1.继承Thread类并重写run()方法

  * 定义Thread类的子类，并重写run()方法，run()方法中的代码就是线程所要执行的任务，所以run()方法被称为执行体(线程体)
  * 创建Thread类的子类的实例对象，就是创建了线程的对象
  * 调用线程对象的start()方法来启动该线程
  * Java不支持多继承

    
    
    package thread;
    
    public class ThreadTest extends Thread{
        String name;
        ThreadTest(String name){
            this.name=name;
        }
    
        @Override
        public void run() {
            System.out.println("this is a thread");
        }
    }
    class StartTest{
        public static void main(String[] args) {
            ThreadTest test=new ThreadTest("thread");
            test.start();
        }
    }
    
    

2.实现Runnable接口配合Thread

  * 定义Runnable接口的实现类，并重写run()方法，run()方法中的代码就是线程所要执行的任务，所以run()方法被称为执行体(线程体)
  * 创建Runnable接口的实现类的对象，使此对象作为Thread的target来创建Thread对象，这个对象才是真正的线程对象
  * 调用线程对象的start()方法来启动线程
  * Runnable接口支持多继承

    
    
    package thread;
    
    public class RunnableTest implements Runnable{
        String name;
        RunnableTest(String name){
            this.name=name;
        }
    
        @Override
        public void run() {
            System.out.println("this is a thread");
        }
    }
    class RunnableStartTest{
        public static void main(String[] args) {
            RunnableTest test=new RunnableTest("thread");
            Thread thread=new Thread(test);
            thread.start();
        }
    }

3.通过Callable和FutureTask创建线程

  * 创建Callable接口的实现类，并重写call()方法，call方法是线程的执行体
  * 创建Callable接口的实现类的实例，然后创建包装了Callable接口的实现类实例的FutureTask类的实例对象，FutureTask对象封装了实现类中的call()方法的返回值(FutureTask是一个包装器，它通过包装Callable接口的实现类来实现，它同时实现了Future和Runnable两个接口)
  * 使用FutureTask对象作为Thread的target来创建实例，此实例对象为线程的对象
  * 调用线程对象的start()方法来启动线程
  * 调用FutureTask对象的get()方法来获取子线程结束的返回值

    
    
    package thread;
    
    import java.util.concurrent.Callable;
    import java.util.concurrent.FutureTask;
    
    public class CallableAndFutureTaskTest implements Callable {
        String name;
        CallableAndFutureTaskTest(String name){
            this.name=name;
        }
    
        @Override
        public Object call() throws Exception {
            System.out.println("this is a thread");
            return null;
        }
    }
    class CallableAndFutureTaskStartTest{
        public static void main(String[] args) throws Exception{
            CallableAndFutureTaskTest test=new CallableAndFutureTaskTest("thread");
            FutureTask futureTask=new FutureTask(test);
            Thread thread=new Thread(futureTask);
            thread.start();
            String result=(String) futureTask.get();
            System.out.println(result);
        }
    }
    

## 三.事物的四大特性(ACID)

1.原子性：事物是最小的执行单位，确保了动作要么完全完成，要么就是完全不起作用  
2.一致性：处理的数据是一致的，例如转账者和收款者的总金额是不变的  
3.隔离性：发生并发访问数据库时，一个事物不会被另一个事物所影响  
4.持久性：一个事务提交之后，他对数据库中数据的影响是持久的，即使出现了数据库障碍也不会影响。

## 四.Get()方法与Post()方法的区别

Get()方法和Post()方法是Http协议中两种常用的请求方法，但是在不同的场景和目的下的使用是不同的。

1.在语义上：Get()方法用于获取和查询资源，而Post()方法更加偏向于修改或创建。这就意味着Get请求拥有等幂性。而Post()方法可能会有副作用，即每次执行都可能产生不同的结果，影响资源的状态。

2.在结构上：Get()方法的请求的参数传递会显示到url上，形成查询字符串(querystring)，而Post()方法的参数在执行体(body)中，Get请求的查询字符串长度会受到url的限制，而Post请求则不会有明确的限制。

3.在缓存上：由于Get请求是等幂的，所以对于Get请求来说，在浏览器中会有缓存来保存数据，这样可以提高Get()方法的获取或查询的效率；而Post请求可能会有副作用，所以并没有缓存机制。

4.在安全性上：本质上Get请求和Post请求都不是绝对安全的，因为Http协议都是明文传输，无论是url,header或者是body都有可能被窃取，所以应该使用Http协议加密传输数据。但是在一些应用场景下，Get方法要比Post方法更加不安全，因为Get方法的参数传递会在url上显示出来，在一些代理日志上或者浏览器的历史上可以被找到，所以在传输一些私密数据的时候应该使用Post方法进行传递。

## 五，数据库(MySQL)的左，右连接以及内连接

1.Left join...on:左连接，以左表为基础，查询左表的所有数据以及满足on关键字后面的条件的右表数据，左连接又称左外连接，是外连接的一种。  
2.Right join...on:右连接，以右表为基础，查询右表的所有数据以及满足on关键字后面的条件的左表数据，右连接又称为右外连接，是外连接的一种。  
3.Inner join...on:内连接，以左右两表为参考对象，查询左右两表同时满足on关键字后面的条件的数据。

MySQL中没有全外连接，所以就不解释了。

首先创建了两个表table_left和table_right.

![](https://i-blog.csdnimg.cn/direct/8d009314f8ff4ac4988f37d69ea9c054.png)

![](https://i-blog.csdnimg.cn/direct/7113dd5dbb674803be40e0096d542ce5.png)

\---------------------------------------------------------------------------------------------------------------------------------

左连接：

    
    
    SELECT * FROM table_left LEFT JOIN table_right ON table_left.id=table_right.id

结果：

![](https://i-blog.csdnimg.cn/direct/c50ad1c447654d88b8047cbdab0821c0.png)

右连接：

    
    
    SELECT * FROM table_left RIGHT JOIN table_right ON table_left.id=table_right.id

结果：

![](https://i-blog.csdnimg.cn/direct/1f52016cfaa34d8d9df07d8389cf397b.png)

内连接：

    
    
    SELECT * FROM table_left INNER JOIN table_right ON table_left.id=table_right.id

结果：

![](https://i-blog.csdnimg.cn/direct/d9e4dc0782514f3eb497f2eb12ef11cf.png)

\---------------------------------------------------------------------------------------------------------------------------------总结一下，这就相当于一个集合A和B

A left B join:A  
A right B join:B  
A inner B join:A∩B

左连接：

![](https://i-blog.csdnimg.cn/direct/e99317093c1f45bd8514dd5df20fde5a.png)

右连接：

![](https://i-blog.csdnimg.cn/direct/e6795f81b5ed4cdcb921e024901e83ac.png)

内连接：

![](https://i-blog.csdnimg.cn/direct/9ea33e57cbae432ab467c371a5c0790e.png)

全连接：

![](https://i-blog.csdnimg.cn/direct/6344ba984870463ba6a0dda52d4ea521.png)

## 六.数据库分表查询中使用到的in关键字可以使用什么代替

一般在做[SQL优化](https://so.csdn.net/so/search?q=SQL%E4%BC%98%E5%8C%96&spm=1001.2101.3001.7020
"SQL优化")的时候讲究使用EXISTS带替代IN的做法，理由是EXISTS执行效率要比IN高。

![2d1876ca1c7bc478809ec24afc81dfe7.png](https://i-blog.csdnimg.cn/blog_migrate/bb3d76b1a6b2575bf5ce1e272a15ba4d.jpeg)

个人理解：

IN表示范围，指某一字段在某一范围之内，这个范围一般使用子查询来获取，由此可知IN子查询返回的结果应该就是这个范围集。

EXISTS表示存在，指至少存在一处，这个条件由EXISTS子查询来完成，但是在这里EXISTS子查询返回的结果却不再是一个结果集，而是一个布尔值(true或false)，其实这个挺好理解的，EXISTS就表示如果子查询能查到值则返回true，则执行EXISTS之前的语句。

具体MySQl的详细介绍请看：[MySQL数据库的详细介绍](https://blog.csdn.net/2302_80464795/article/details/143515883?spm=1001.2014.3001.5501
"MySQL数据库的详细介绍")

\---------------------------------------------------------------------------------------------------------------------------------以上问题都是面试官真实问的面试题，回答的一坨，在事后查询资料加个人理解写的blog，有错误之处还请多包容。



