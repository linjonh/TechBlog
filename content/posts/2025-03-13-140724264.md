---
layout: post
title: "数据结构排序"
date: 2025-03-13 13:18:48 +0800
description: "排序：所谓排序，就是使⼀串记录，按照其中的某个或某些关键字的⼤⼩，递增或递减的排列起来的操作。"
keywords: "数据结构（排序）"
categories: ['未分类']
tags: ['算法', '数据结构', 'C']
artid: "140724264"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=140724264
    alt: "数据结构排序"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=140724264
featuredImagePreview: https://bing.ee123.net/img/rand?artid=140724264
cover: https://bing.ee123.net/img/rand?artid=140724264
image: https://bing.ee123.net/img/rand?artid=140724264
img: https://bing.ee123.net/img/rand?artid=140724264
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构（排序）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
     </p>
    </blockquote>
    <p>
    </p>
    <div>
     <h4>
      文章目录
     </h4>
     <p>
     </p>
    </div>
    <hr/>
    <h2>
     一、排序概念
    </h2>
    <h4>
     1.1 概念
    </h4>
    <ul>
     <li>
      <span style="color:#1f2329">
       排序：所谓排序，就是使⼀串记录，按照其中的某个或某些关键字的⼤⼩，递增或递减的排列起来的操作。
      </span>
     </li>
    </ul>
    <h4>
     1.2 常见的排序算法
    </h4>
    <h4>
     <img alt="" height="437" src="https://i-blog.csdnimg.cn/direct/a79d721a45f34be5a56118443c853386.png" width="752"/>
    </h4>
    <p>
    </p>
    <h2>
     二、实现常见的排序算法
    </h2>
    <h4>
     2.1 直接插入排序
    </h4>
    <pre><code>void InsertSort(int* arr, int n)
{
	for (int i = 0; i &lt; n - 1; i++)
	{
		int end = i;
		int tmp = arr[end + 1];
		while (end &gt;= 0)
		{
			if (arr[end] &gt; tmp)
			{
				arr[end + 1] = arr[end];
				end--;
			}
			else
			{
				break;
			}
			arr[end + 1] = tmp;
		}
	}
}</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <span style="color:#1f2329">
       当插⼊第
      </span>
      <span style="color:#1f2329">
       i(i&gt;=1)
      </span>
      <span style="color:#1f2329">
       个元素时，前⾯的
      </span>
      <span style="color:#1f2329">
       array[0],array[1],…,array[i-1]
      </span>
      <span style="color:#1f2329">
       已经排好序，此时
      </span>
      <span style="color:#1f2329">
       ⽤
      </span>
      <span style="color:#1f2329">
       array[i]
      </span>
      <span style="color:#1f2329">
       的排序码与
      </span>
      <span style="color:#1f2329">
       array[i-1],array[i-2],…
      </span>
      <span style="color:#1f2329">
       的排序码顺序进⾏⽐较，找到插⼊位置
      </span>
      <span style="color:#1f2329">
       即将
      </span>
      <span style="color:#1f2329">
       array[i]
      </span>
      <span style="color:#1f2329">
       插⼊，原来位置上的元素顺序后移：
      </span>
     </li>
    </ul>
    <h4>
     <img alt="" height="710" src="https://i-blog.csdnimg.cn/direct/24385dc5122d4ed1936e8d184285a825.png" width="1200"/>
    </h4>
    <p>
    </p>
    <div>
     <span style="color:#646a73">
      直接插⼊排序的特性总结
     </span>
    </div>
    <ol>
     <li>
      <span style="color:#1f2329">
       元素集合越接近有序，直接插⼊排序算法的时间效率越⾼
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       时间复杂度：O(N^2)
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       空间复杂度：O(1)
      </span>
     </li>
    </ol>
    <p>
    </p>
    <h4>
     2.2 希尔排序
    </h4>
    <pre><code>void ShellSort(int* arr, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		int gap = gap / 3 + 1; //保证最后一次的 gap 是 1。
		for (int i = 0; i &lt; n - gap; i++)
		{
			int end = i;
			int tmp = arr[end+gap];
			while (end &gt;= 0)
			{
				if (arr[end] &gt; tmp)
				{
					arr[end + gap] = arr[end];
					end-=gap;
				}
				else
				{
					break;
				}
				
			}
			arr[end + gap] = tmp;
		}
	}
}</code></pre>
    <ul>
     <li>
      <span style="color:#1f2329">
       希尔排序法⼜称缩⼩增量法。希尔排序法的基本思想是：先选定⼀个整数（通常是gap = n/3+1），把
      </span>
      <span style="color:#1f2329">
       待排序⽂件所有记录分成各组，所有的距离相等的记录分在同⼀组内，并对每⼀组内的记录进⾏排
      </span>
      <span style="color:#1f2329">
       序，然后gap=gap/3+1得到下⼀个整数，再将数组分成各组，进⾏插⼊排序，当gap=1时，就相当于
      </span>
      <span style="color:#1f2329">
       直接插⼊排序。
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       它是在直接插⼊排序算法的基础上进⾏改进⽽来的，综合来说它的效率肯定是要⾼于直接插⼊排序算
      </span>
      <span style="color:#1f2329">
       法的:
      </span>
     </li>
    </ul>
    <p>
    </p>
    <p>
     <img alt="" height="800" src="https://i-blog.csdnimg.cn/direct/ecde5373b52440db8480c64f5fc5da76.png" width="1200"/>
    </p>
    <div>
     <span style="color:#646a73">
      希尔排序的特性总结
     </span>
    </div>
    <ol>
     <li>
      <span style="color:#1f2329">
       希尔排序是对直接插⼊排序的优化。
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       当
      </span>
      <span style="color:#1f2329">
       gap &gt; 1
      </span>
      <span style="color:#1f2329">
       时都是预排序，⽬的是让数组更接近于有序。当
      </span>
      <span style="color:#1f2329">
       gap == 1
      </span>
      <span style="color:#1f2329">
       时，数组已经接近有序
      </span>
      <span style="color:#1f2329">
       的了，这样就会很快。这样整体⽽⾔，可以达到优化的效果。
      </span>
     </li>
    </ol>
    <div>
    </div>
    <h6>
     <span style="color:#1f2329">
      希尔排序的时间复杂度计算
     </span>
    </h6>
    <div>
     <span style="color:#646a73">
      希尔排序的时间复杂度估算：
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      外层循环：
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      外层循环的时间复杂度可以直接给出为：
     </span>
     <span style="color:#1f2329">
      <em>
       O
      </em>
     </span>
     <span style="color:#1f2329">
      (log
     </span>
     <span style="color:#1f2329">
      2
     </span>
     <span style="color:#1f2329">
      <em>
       n
      </em>
     </span>
     <span style="color:#1f2329">
      )
     </span>
     <span style="color:#646a73">
      或者
     </span>
     <span style="color:#1f2329">
      <em>
       O
      </em>
     </span>
     <span style="color:#1f2329">
      (log
     </span>
     <span style="color:#1f2329">
      3
     </span>
     <span style="color:#1f2329">
      <em>
       n
      </em>
     </span>
     <span style="color:#1f2329">
      )
     </span>
     <span style="color:#646a73">
      ，即
     </span>
     <span style="color:#1f2329">
      <em>
       O
      </em>
     </span>
     <span style="color:#1f2329">
      (log
     </span>
     <span style="color:#1f2329">
      <em>
       n
      </em>
     </span>
     <span style="color:#1f2329">
      )
     </span>
    </div>
    <div>
     <span style="color:#646a73">
      内层循环：
     </span>
    </div>
    <p>
     <img alt="" height="387" src="https://i-blog.csdnimg.cn/direct/cd2630da42ab4dcaa08d577aa49eddb0.png" width="939"/>
    </p>
    <p>
    </p>
    <div>
     <span style="color:#646a73">
      假设⼀共有n个数据，合计gap组，则每组为n/gap个；在每组中，插⼊移动的次数最坏的情况下为
     </span>
    </div>
    <div>
     <img alt="" height="40" src="https://i-blog.csdnimg.cn/direct/28c0ab3061254c31852275e712644585.png" width="209">
      <span style="color:#646a73">
       ⼀共是gap组，因此：
      </span>
     </img>
    </div>
    <div>
     <span style="color:#646a73">
      总计最坏情况下移动总数为：
     </span>
     <img alt="" height="40" src="https://i-blog.csdnimg.cn/direct/6d19cf552fce40b8bdfd952a1a8e990b.png" width="247">
     </img>
    </div>
    <p>
     <span style="color:#646a73">
      gap取值有（以除3为例）：n/3 n/9 n/27 ...... 2 1
     </span>
    </p>
    <div>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#646a73">
      当gap为n/3时，移动总数为：
     </span>
     <img alt="" height="31" src="https://i-blog.csdnimg.cn/direct/13d7abc2e0cd4373a435a00a0bc546e2.png" width="98">
     </img>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#646a73">
      当gap为n/9时，移动总数为：
     </span>
     <img alt="" height="42" src="https://i-blog.csdnimg.cn/direct/399b5f96326e481ea2deab30c50c91f8.png" width="287"/>
    </div>
    <div>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#646a73">
      最后⼀躺，gap=1即直接插⼊排序，内层循环排序消耗为n
     </span>
    </div>
    <p>
    </p>
    <div>
     <span style="color:#646a73">
      因此，希尔排序在最初和最后的排序的次数都为n，即前⼀阶段排序次数是逐渐上升的状态，当到达某⼀顶点时，排序次数逐渐下降⾄n，⽽该顶点的计算暂时⽆法给出具体的计算过程
     </span>
    </div>
    <div>
    </div>
    <ul>
     <li>
      <span style="color:#1f2329">
       希尔排序时间复杂度不好计算，因为
      </span>
      <span style="color:#1f2329">
       gap
      </span>
      <span style="color:#1f2329">
       的取值很多，导致很难去计算，因此很多书中给出的希尔排序的时间复杂度都不固定。《数据结构(C语⾔版)》--- 严蔚敏书中给出的时间复杂度为：
      </span>
     </li>
    </ul>
    <p>
     <img alt="" height="314" src="https://i-blog.csdnimg.cn/direct/a5bec444cf1c42d08615ddd330736b1d.png" width="1086"/>
    </p>
    <p>
    </p>
    <h4>
     2.3直接选择排序
    </h4>
    <ol>
     <li>
      <span style="color:#646a73">
       在元素集合 array[i]--array[n-1]
      </span>
      <span style="color:#646a73">
       中选择关键码最⼤(⼩)的数据元素
      </span>
     </li>
     <li>
      <span style="color:#646a73">
       若它不是这组元素中的最后⼀个(第⼀个)元素，则将它与这组元素中的最后⼀个（第⼀个）元素
      </span>
      <span style="color:#646a73">
       交换
      </span>
     </li>
     <li>
      <span style="color:#646a73">
       在剩余的
      </span>
      <span style="color:#646a73">
       array[i]--array[n-2]
      </span>
      <span style="color:#646a73">
       （
      </span>
      <span style="color:#646a73">
       array[i+1]--array[n-1]
      </span>
      <span style="color:#646a73">
       ） 集合中，重复上述步
      </span>
      <span style="color:#646a73">
       骤，直到集合剩余
      </span>
      <span style="color:#646a73">
       1
      </span>
      <span style="color:#646a73">
       个元素
      </span>
     </li>
    </ol>
    <pre><code>void SlelectSort(int* arr, int n)
{
	int begin = 0;
	int end = n - 1;
	while (begin &lt; end)
	{
		int min = begin, max = begin;
		for (int i = begin + 1; i &lt;= end; i++)
		{
			if (arr[i] &lt; min)
			{
				min = i;
			}
			if (arr[i] &gt; max)
			{
				max = i;
			}
		}

		if (max = begin)
		{
			max = min;
		}
		Swap(&amp;arr[min], &amp;arr[begin]);
		Swap(&amp;arr[max], &amp;arr[end]);

		begin++;
		end--;
	}
	
}
</code></pre>
    <p>
     <img alt="" height="800" src="https://i-blog.csdnimg.cn/direct/8f444ba626244d539363ef02cddc5139.png" width="1200"/>
    </p>
    <p>
     <img alt="" height="762" src="https://i-blog.csdnimg.cn/direct/30ad8c0356a44da1845469a4f202aa56.png" width="1200"/>
    </p>
    <p>
    </p>
    <div>
     <span style="color:#646a73">
      直接选择排序的特性总结：
     </span>
    </div>
    <ol>
     <li>
      <span style="color:#1f2329">
       直接选择排序思考⾮常好理解，但是效率不是很好。实际中很少使⽤
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       时间复杂度：
      </span>
      <span style="color:#1f2329">
       <em>
        O
       </em>
      </span>
      <span style="color:#1f2329">
       (
      </span>
      <span style="color:#1f2329">
       <em>
        N
       </em>
      </span>
      <span style="color:#1f2329">
       2
      </span>
      <span style="color:#1f2329">
       )
      </span>
     </li>
     <li>
      <span style="color:#1f2329">
       空间复杂度：
      </span>
      <span style="color:#1f2329">
       <em>
        O
       </em>
      </span>
      <span style="color:#1f2329">
       (1)
      </span>
      <br/>
     </li>
    </ol>
    <p>
     <span style="color:#1f2329">
      未完待续~~~
     </span>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38333936383731332f:61727469636c652f64657461696c732f313430373234323634" class_="artid" style="display:none">
 </p>
</div>


