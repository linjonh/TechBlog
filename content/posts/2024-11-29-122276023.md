---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34363332323836362f:61727469636c652f64657461696c732f313232323736303233"
layout: post
title: "数据挖掘经典算法一K近邻KNN"
date: 2024-11-29 19:10:24 +0800
description: "目录一、算法思想二、算法原理（1）KNN算法原理（2）KNN算法三要素① 分类决策规则② K值的选择"
keywords: "knn搜索算法"
categories: ['未分类']
tags: ['近邻算法', '算法', '数据挖掘', 'Python']
artid: "122276023"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=122276023
  alt: "数据挖掘经典算法一K近邻KNN"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=122276023
featuredImagePreview: https://bing.ee123.net/img/rand?artid=122276023
---

# 数据挖掘经典算法（一）：K近邻（KNN）

**目录**

[一、算法思想](#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3)

[二、算法原理](#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86)

[（1）KNN算法原理](#%EF%BC%881%EF%BC%89KNN%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86)

[（2）KNN算法三要素](#%EF%BC%882%EF%BC%89KNN%E7%AE%97%E6%B3%95%E4%B8%89%E8%A6%81%E7%B4%A0)

[① 分类决策规则](#%E2%91%A0%20%E5%88%86%E7%B1%BB%E5%86%B3%E7%AD%96%E8%A7%84%E5%88%99)

[② K值的选择](#%E2%91%A1%20K%E5%80%BC%E7%9A%84%E9%80%89%E6%8B%A9)

[③ 距离度量](#%E2%91%A2%20%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F)

[（3）KNN实现方法](#%EF%BC%883%EF%BC%89KNN%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95)

[① 构建KD树](#%C2%A0%E2%91%A0%20%E6%9E%84%E5%BB%BAKD%E6%A0%91)

[② KD树的搜索](#%C2%A0%E2%91%A1%20KD%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2)

[③ KD树的分类（预测）](#%E2%91%A2%20KD%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%88%E9%A2%84%E6%B5%8B%EF%BC%89)

[（4）KNN算法之训练样本不平衡情况](#%EF%BC%884%EF%BC%89KNN%E7%AE%97%E6%B3%95%E4%B9%8B%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%83%85%E5%86%B5)

[（5）算法优缺点](#%EF%BC%885%EF%BC%89%E7%AE%97%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9)

[三、算法实验](#%E4%B8%89%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C)

[（1）数据收集与处理](#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%A4%84%E7%90%86)

[（2）实验及结果](#%C2%A0%EF%BC%882%EF%BC%89%E5%AE%9E%E9%AA%8C%E5%8F%8A%E7%BB%93%E6%9E%9C)

---

## 一、算法思想

在讲解K近邻算法之前，我们先通过一个很简单的例子进入主题。在我们日常生活中，我们会遇到很多决策。比如说，我会考虑换什么手机，或者中午吃什么。这个时候我给大家三个方案选择：

1、随便选一个

2、问问周围其他人的选择

3、做一份详细的报告，根据自身的情况量身定制选择方案

相信大部分人都会选择第二个选项，如果选择选项1，意味着你会承担更高的风险，最后选择了一个非常不靠谱的选项。选择选项3你会发现会花费更多的计算成本在一个不是很重要的事件上。

![](https://i-blog.csdnimg.cn/blog_migrate/4412ea9e1e762851ceb028f6782a9619.png)

在我们选择下一台手机品牌时，我们就会先问其他人在用什么！当我们发现身边其他人，用安卓的大于用苹果的，这时我们下一台手机就会考虑安卓手机，这就是K近邻算法（KNN）。总结上面的例子KNN的思想可以总结为：近朱者赤，近墨者黑。

![](https://i-blog.csdnimg.cn/blog_migrate/76e5386b55ef5766604ea269a9394f83.png)

KNN分辨待测样本点类型的方法，如下图。

第一步：先找到待测样本周围最近的已知样本点。

第二步：统计周围已知样本点分布状况。

第三步：将待测样本类别归为优势方。

## 

![](https://i-blog.csdnimg.cn/blog_migrate/1e38017ff5d825dee7dcf8e9c9d522bc.png)

## 

## 二、算法原理

### （1）KNN算法原理

KNN

算法是选择与输入样本在特征空间内

最近邻

的

k

个训练样本并

根据一定的

决策规则

，给出输出结果

。

决策规则：

分类任务：输出结果为k各训练样本中占大多数的类。

回归任务：输出结果为k个训练样本值的平均值。

![](https://i-blog.csdnimg.cn/blog_migrate/3621cf3a703b8fac886cd3594910b44d.png)

### （2）KNN算法三要素

K值的选择、距离度量和分类决策规则是K近邻算法的三要素。

#### ① 分类决策规则

KNN

算法一般是用

多数表决方法

，

即由输入实例的

K

个邻近的多数类决定输入实例的类。这种思想也是经验风险最小化的结果。

训练样本为

(x

i

,

y

i

)

。当输入实例为

x，标记为c，
![](https://i-blog.csdnimg.cn/blog_migrate/4abbebae40961a8afa60b43141d4fee5.png)

是输入实例x的k

近邻训练样本集。

我们定义

训练误差率是

K

近邻训练样本标记与输入标记不一致的比例，误差率表示为：

![](https://i-blog.csdnimg.cn/blog_migrate/17310f0241e2f0966ff32a4ff7d207ca.png)

因此，要使误差率最小化即经验风险最小，就要使上式右端的

![](https://i-blog.csdnimg.cn/blog_migrate/69eb2e5781c0bffb8ec1824eb6b40023.png)

最大，即

K

近邻的标记值尽可能的与输入标记一致

，所以多数表决规则等价于经验风险最小化。

#### ② K值的选择

![](https://i-blog.csdnimg.cn/blog_migrate/19863bb452c35297be8f958d17df34fd.png)

K

取值较小时，模型复杂度高，训练误差会减小，泛化能力减弱；

K

取值较大时，模型复杂度低，训练误差会增大，泛化能力有一定的提高。

KNN

模型的复杂度可以通过对

噪声的容忍度

来理解，若模型对噪声很敏感，则模型的复杂度高；反之，模型的复杂度低。为了更好理解模型复杂度的含义，我们取一个极端，分析

K=1

和

K=“

样本数

”

的模型复杂度。

K=1

时，模型输出的结果受噪声的影响很大。

![](https://i-blog.csdnimg.cn/blog_migrate/98150504105743912bd8bb8755546210.png)

由下图可知，
样本数等于7

，当

K=7

时，不管输入数据的噪声有多大，输出结果都是绿色类，模型对噪声极不敏感，但是模型太过简单，包含的信息太少，也是不可取的。

通过上面两种极端的

K

选取结果可知，

K

值选择应适中，一般来说选择

k

的值是

k = sqrt(N)

，其中

N

代表训练数据集中的样本数，建议采用交叉验证的方法选取合适的

K

值。

![](https://i-blog.csdnimg.cn/blog_migrate/bb45073e2e14269136ee4c75f880f417.png)

#### ③ 距离度量

KNN

算法用距离来度量两个样本间的相似度

，常用的距离表示方法：

1、欧式距离

![](https://i-blog.csdnimg.cn/blog_migrate/0e3d7f53e94884131cef4096d83bca81.png)
![](https://i-blog.csdnimg.cn/blog_migrate/d2208aae2f042673111050bab1243e88.png)

2、曼哈顿距离

![](https://i-blog.csdnimg.cn/blog_migrate/d81eea844712391e6ab4d76c3c79e2b1.png)
![](https://i-blog.csdnimg.cn/blog_migrate/cf6d3755976e314e09bc5ff68a033dd6.png)

### （3）KNN实现方法

实现

k

近邻法时，主要考虑的问题是如何对训练数据进行快速

K

近邻搜索。这在特征空间的维数大及训练数据容量大时尤其必要。

K

近邻法最简单的实现是线性扫描（穷举搜索），即要计算输入实例与每一个训练实例的距离。计算并存储好以后，再查找

K

近邻。

当训练集很大时，计算非常耗时。为了提高

KNN

搜索的效率，可以考虑使用特殊的结构存储训练数据，以减小计算距离的次数。

KD

树

(K-dimension tree)

是一种对

k

维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。

KD

树是是一种二叉树，表示对

k

维空间的一个划分，构造

KD

树相当于不断地用垂直于坐标轴的超平面将

K

维空间切分，构成一系列的

K

维超矩形区域。

KD

树的每个结点对应于一个

K

维超矩形区域。利用

KD

树可以省去对大部分数据点的搜索，从而减少搜索的计算量。

KD

树的

KNN

算法实现包括三部分：

KD

树的构建，

KD

树的搜索和

KD

树的分类。

#### ① 构建KD树

KD

树实质是二叉树，其划分思想是切分使样本复杂度降低最多的特征。

KD

树认为特征方差越大，则该特征的复杂度亦越大，优先对该特征进行切分，切分点是所有实例在该特征的中位数。重复该切分步骤，直到切分后无样本则终止切分，终止时的样本为叶节点。

【

例

】

给定一个二维空间的数据集：

![](https://i-blog.csdnimg.cn/blog_migrate/0e91d739b6def41edd9b08120e476e96.png)

构造KD树的步骤：

1、数据集在维度X与Y上的方差分别为6.9和5.3， 因此首先从X的维度进行划分；

2、数据集在X维度的中位数是5，以平面X=5将空间分为左右两个矩阵；

3、分别对左右两个矩阵的样本在Y维度的中位数进行切分；

4、重复步骤2，3 ，直到无样本，该节点为叶子节点。

数据集在维度

x

与

y

上的方差分别为

6.9

和

5.3

，因此首先从

x

的维度进行划分;

首先按x

坐标排序，选中间值

x=5

做根节点，选出

(5,4)

，以平面

x=5

将空间分为左右两个矩形，所有

x

坐标比

5

小的都在左边，比

5

大的都在右边

![](https://i-blog.csdnimg.cn/blog_migrate/4db8feba98cf2715f185aa572e7999f4.png)

![](https://i-blog.csdnimg.cn/blog_migrate/5e84b6aeb706fb029145e71d2f31fc9c.png)

分别对左右两个矩形的样本在

y

维度的中位数进行切分

;

![](https://i-blog.csdnimg.cn/blog_migrate/1f91674cb90f9d176d98910bfa70095b.png)

![](https://i-blog.csdnimg.cn/blog_migrate/fde18f1bd3dfc26f887280d996b5e788.png)

重复

上述两个

步骤直到无样本，得到最后的

KD

树

![](https://i-blog.csdnimg.cn/blog_migrate/36b8f1b86226fe8e412f02abf0847618.png)

![](https://i-blog.csdnimg.cn/blog_migrate/f40601a5a6ce8c18ecd143069bd415f4.png)

#### ② KD树的搜索

1、将查询数据

Q

从根结点开始

，按照

Q

与各个结点的比较结果向下访问

KD

树

，

直至达到叶子结点

。

其中Q

与结点的比较指的是将

Q

对应于结点中的

k

维度上的值与

m

进行比较，若

Q(k) < m

，则访问左子树，否则访问右子树。达到叶子结点时，计算

Q

与叶子结点上保存的数据之间的距离，记录下最小距离对应的数据点，记为当前“最近邻点”

和最小距离。

（

2

）进行

回溯操作

，该操作是为了找到离

Q

更近的“最近邻点”。即判断未被访问过的分支里是否还有离

Q

更近的点，它们之间的距离小于

最小距离

。

如果

Q

与其父结点下的未被访问过的分支之间的距离小于最小距离，则认为该分支中存在离

Q

更近的数据，进入该结点，进行（

1

）步骤一样的查找过程，如果找到更近的数据点，则更新为当前的“最近邻点”

，并更新

最小距离

。如果

Q

与其父结点下的未被访问过的分支之间的距离大于最小距离，则说明该分支内不存在与

Q

更近的点。

回溯的判断过程是从下往上进行的

，直到回溯到根结点时已经不存在与

P

更近的分支为止。

例如：查询点为

(8.5

,

6.5

)

，比较到子节点

(9, 6)

：

![](https://i-blog.csdnimg.cn/blog_migrate/7ec387391925a558501567c1c2261b3e.png)

通过二叉搜索，顺着搜索路径很快就能找到最邻近的近似点，也就是叶子节点

(9,6)

。而找到的叶子节点并不一定就是最邻近的，最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。为了找到真正的最近邻，还需要进行

‘

回溯

’

操作。

例如：查询点为

(8.5

,

6.5

)

，回溯：

![](https://i-blog.csdnimg.cn/blog_migrate/318151be8123bc62f51aa03e309ec345.png)

当前最近邻点：

(9, 6)

， 最近邻距离：

sqrt(0.5)

回溯：算法沿搜索路径反向查找是否有距离查询点更近的数据点。此例中先从(5,4)

点开始进行二叉查找，然后到达

(7,2)

，最后到达

(9,6)

，此时搜索路径中的节点为大于

(5,4)

和

(7,2)

，小于

(9,6)

，首先以

(9,6)

作为当前最近邻点，计算其到查询点

(8.5

,

6.5

)

的距离为

0.7071

，然后回溯到其父节点

(7,2)

，并判断在该父节点的其他子节点空间中是否有距离查询点更近的数据点。以

(8.5

,

6.5

)

为圆心，以

0.7071

为半径画圆，发现该圆不和超平面

y =2

交割，因此不用进入

(7,2)

节点右子空间中去搜索。

再回溯到

(5,4)

，

以

(8.5

,

6.5

)

为圆心，以

0.7071

为半径画圆

更不会与

x = 5

超平面交割，因此不用进入

(5,4)

左子空间进行查找。至此，搜索路径中的节点已经全部回溯完，结束整个搜索，返回最近邻点

(9,6)

，

最近距离为

0.7071

。

#### ③ KD树的分类（预测）

每一次搜寻与输入样本最近的样本节点，然后忽略该节点，重复同样步骤

K

次，找到与输入样本最近邻的

K

个样本 ，投票法确定输出结果。

当维数较大时，直接利用

k-d

树快速检索的性能急剧下降。假设数据集的维数为

D

，一般来说要求数据的规模

N

满足条件：

N

远大于

2

的

D

次方，才能达到高效的搜索。

### （4）KNN算法之训练样本不平衡情况

若正负样本处于不平衡状态，运用投票决策的

KNN

算法判断输入样本的所属类别：

![](https://i-blog.csdnimg.cn/blog_migrate/fe64cf657a4602b2e9845837d35bc317.png)

结果显示输入样本为绿色类 。原因是

红色类的个数远远小于绿色样本，导致出现的分类错误

。

解决方法：

1、

若分类决策选择

限定半径最近邻法

，即以输入样本为圆心，最大半径

R

的圆内选择出现次数最多的类做为输入样本的类 。如下图，黑色样本的分类结果正确。

![](https://i-blog.csdnimg.cn/blog_migrate/6e90573860099ee0ad4a00011efda459.png)

2、
投票法是默认每个样本的权重相等，我们假定权重与距离成反比，

即距离越大，对结果的影响越小，那么该样本的权重也越小，反之，权重则越大，根据权重对输入样本进行分类

。这种思想与

A

daBoost

算法相似，分类性能好的弱分类器给予一个大的权重 。

![](https://i-blog.csdnimg.cn/blog_migrate/d50bd62523d28084c30ed460ef4bc104.png)

### （5）算法优缺点

**优点：**

1

）算法简单，理论成熟，可用于分类和回归。

2

）对异常值不敏感。

3

）可用于非线性分类。

4

）比较适用于容量较大的训练数据，容量较小的训练数据则很容易出现误分类情况。

5

）

KNN

算法原理是根据邻域的

K

个样本来确定输出类别，因此对于不同类的样本集有交叉或重叠较多的待分样本集来说，

KNN

方法较其他方法更为合适。

**缺点：**

1

）时间复杂度和空间复杂度高。

2

）训练样本不平衡，对稀有类别的预测准确率低。

3

）相比决策树模型，

KNN

模型可解释性不强。

## 三、算法实验

### （1）数据收集与处理

利用爬虫工具，爬取了成都和桂林两地2020年的空气质量数据，经过数据处理分别对两地空气质量进行标签化，最终得到训练集与测试集。

![](https://i-blog.csdnimg.cn/blog_migrate/ab995684eb53a44f1542f66280e50be0.png)

### （2）实验及结果

![](https://i-blog.csdnimg.cn/blog_migrate/6c9d22d66dc3bc4759469848130a671b.png)

我们取不同

k

值

(1~30)

使用

Manhattan

距离计算公式来预测测试集中空气质量，根据实验结果，当

k=12

时，得到的准确率最高；当

k

值大于

20

时，准确率会明显下降。

![](https://i-blog.csdnimg.cn/blog_migrate/7dc18862c36006195fbe9b2aaae7bf8b.png)

我们同样取不同

k

值

(1~30)

使用

Euclidean

距离计算公式来预测测试集中空气质量，根据实验结果，当

k=4

时，得到的准确率最高；当

k

值大于

16

时，准确率会明显下降。

结论：

k

值的选取和距离计算方法对实验结果均有较大的影响，其中

k

值选取一般不能大于

√

样本数

。