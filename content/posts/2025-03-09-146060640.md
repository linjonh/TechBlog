---
layout: post
title: "QT多线程"
date: 2025-03-09 20:44:05 +0800
description: "继承QThread类\t\t \t\t\t\t\t\t通过启动线程，和安全终止线程 。\t\t\t\t\t\t线程优先级\t\t\t\t\t\t\t\t\t\t\t\t\t\t优先级常量\t\t\t\t\t数值\t\t\t\t\t描述\t\t\t\t\t应用场景\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0\t\t\t\t\t空闲优先级：仅在无其他线程运行时才调度。\t\t\t\t\t后台监控、低优先级日志记录等 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1\t\t\t\t\t最低优先级：调度频率低于 。\t\t\t\t\t非关键性后台任务 \t\t\t\t\t\t\t\t\t\t\t"
keywords: "QT多线程"
categories: ['Qt']
tags: ['Qt']
artid: "146060640"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146060640
    alt: "QT多线程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146060640
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146060640
cover: https://bing.ee123.net/img/rand?artid=146060640
image: https://bing.ee123.net/img/rand?artid=146060640
img: https://bing.ee123.net/img/rand?artid=146060640
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     QT多线程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、多线程概念
    </h2>
    <p>
     <strong>
      继承QThread类
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       核心步骤
      </strong>
      ：
      <ul>
       <li>
        <br/>
        定义子类继承
        <code>
         QThread
        </code>
        ，重写
        <code>
         run()
        </code>
        函数实现线程逻辑 。
        <pre><code class="language-cpp">#ifndef IOSTHREAD_H
#define IOSTHREAD_H

//保证能进行中文显示，QT对于中文有些不兼容
#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)
# pragma execution_character_set("utf-8")
#endif

#include &lt;QObject&gt;
#include &lt;QThread&gt;

class IOSThread : public QThread
{
    Q_OBJECT
public:
    explicit IOSThread(QObject *parent = nullptr);

protected:
    void run();

private:

};

#endif</code></pre>
        <pre><code class="language-cpp">#include "Threads/IOSThread.h"
#include "alldata.h"

IOSThread::IOSThread(QObject *parent)
    : QThread(parent)
{

}

void IOSThread::run()
{
    while(1)
    {
        QThread::msleep(1);
    }
}</code></pre>
       </li>
       <li>
        通过
        <code>
         start()
        </code>
        启动线程，
        <code>
         quit()
        </code>
        和
        <code>
         wait()
        </code>
        安全终止线程 。
        <pre><code class="language-cpp">    //Threads
    IOSThread *iosthread;
    qDebug()&lt;&lt;"iosthread 开启线程";
    iosthread = new IOSThread(this);
    // 设置为最高优先级
    iosthread-&gt;start();
    iosthread-&gt;setPriority(QThread::TimeCriticalPriority);
    </code></pre>
       </li>
       <li>
        线程优先级
        <table>
         <thead>
          <tr>
           <th>
            <strong>
             优先级常量
            </strong>
           </th>
           <th>
            <strong>
             数值
            </strong>
           </th>
           <th>
            <strong>
             描述
            </strong>
           </th>
           <th>
            <strong>
             应用场景
            </strong>
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td>
            <code>
             QThread::IdlePriority
            </code>
           </td>
           <td>
            0
           </td>
           <td>
            <strong>
             空闲优先级
            </strong>
            ：仅在无其他线程运行时才调度。
           </td>
           <td>
            后台监控、低优先级日志记录等
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::LowestPriority
            </code>
           </td>
           <td>
            1
           </td>
           <td>
            <strong>
             最低优先级
            </strong>
            ：调度频率低于
            <code>
             LowPriority
            </code>
            。
           </td>
           <td>
            非关键性后台任务
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::LowPriority
            </code>
           </td>
           <td>
            2
           </td>
           <td>
            <strong>
             低优先级
            </strong>
            ：调度频率低于
            <code>
             NormalPriority
            </code>
            。
           </td>
           <td>
            资源占用较低的任务（如数据备份）
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::NormalPriority
            </code>
           </td>
           <td>
            3
           </td>
           <td>
            <strong>
             正常优先级
            </strong>
            ：操作系统的默认优先级。
           </td>
           <td>
            普通用户交互任务
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::HighPriority
            </code>
           </td>
           <td>
            4
           </td>
           <td>
            <strong>
             高优先级
            </strong>
            ：调度频率高于
            <code>
             NormalPriority
            </code>
            。
           </td>
           <td>
            实时数据处理或关键业务逻辑
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::HighestPriority
            </code>
           </td>
           <td>
            5
           </td>
           <td>
            <strong>
             最高优先级
            </strong>
            ：调度频率高于
            <code>
             HighPriority
            </code>
            。
           </td>
           <td>
            高响应要求的任务（如传感器采集）
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::TimeCriticalPriority
            </code>
           </td>
           <td>
            6
           </td>
           <td>
            <strong>
             时间关键优先级
            </strong>
            ：尽可能频繁调度，接近实时系统的优先级。
           </td>
           <td>
            运动控制、高频信号处理等
           </td>
          </tr>
          <tr>
           <td>
            <code>
             QThread::InheritPriority
            </code>
           </td>
           <td>
            7
           </td>
           <td>
            <strong>
             继承优先级
            </strong>
            ：使用创建线程的优先级（默认值）。
           </td>
           <td>
            需要与父线程优先级一致的任务
           </td>
          </tr>
         </tbody>
        </table>
        <strong>
         <code>
          QThread::TimeCriticalPriority的优先级最高
         </code>
        </strong>
        <br/>
       </li>
       <li>
        <p>
         <strong>
          QThread 类提供的延时函数
         </strong>
        </p>
        <strong>
         <code>
          QThread::sleep(n)
         </code>
        </strong>
        ：阻塞当前线程
        <code>
         n
        </code>
        <strong>
         秒
        </strong>
        。
        <br/>
        <strong>
         <code>
          QThread::msleep(n)
         </code>
        </strong>
        ：阻塞当前线程
        <code>
         n
        </code>
        <strong>
         毫秒
        </strong>
        <br/>
        <strong>
         <code>
          QThread::usleep(n)
         </code>
        </strong>
        ：阻塞当前线程
        <code>
         n
        </code>
        <strong>
         微秒
        </strong>
        <br/>
       </li>
       <li>
        示例：子线程执行耗时任务（如循环计算），通过信号通知主线程更新UI 。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       特点
      </strong>
      ：
      <ul>
       <li>
        直接控制线程生命周期，但需注意
        <code>
         run()
        </code>
        函数外部的成员函数默认运行在主线程
       </li>
       <li>
        适用于需要独立线程完成完整任务的场景（如硬件控制）
       </li>
      </ul>
     </li>
    </ul>
    <h2>
     二、
     <strong>
      线程同步与通信机制
     </strong>
    </h2>
    <p>
     <strong>
      全局互斥锁(QMutex\QMutexLocker)
     </strong>
     <br/>
     对于需要全局动作的资源，如在线程中对数据库的增删改查，全局变量（生产数据、板卡、某些必要条件变量等）。
    </p>
    <pre><code class="language-cpp">#include &lt;QMutex&gt;
#include &lt;QDebug&gt;

QMutex mutex; // 全局互斥锁
int shared_counter = 0;

void qt_increment_counter() {
    mutex.lock();
    shared_counter++;
    qDebug() &lt;&lt; "Counter:" &lt;&lt; shared_counter;
    mutex.unlock();
}</code></pre>
    <pre><code class="language-cpp">void qt_safe_increment_counter() {
    QMutexLocker locker(&amp;mutex); // 构造时加锁，析构时解锁
    shared_counter++;
    qDebug() &lt;&lt; "Counter:" &lt;&lt; shared_counter;
}</code></pre>
    <p style="background-color:transparent">
     <strong>
      意事项
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       死锁风险
      </strong>
      ：避免嵌套加锁或忘记解锁，优先使用
      <code>
       lock_guard
      </code>
      /
      <code>
       QMutexLocker
      </code>
      。
     </li>
     <li>
      <strong>
       锁粒度
      </strong>
      ：尽量缩小临界区范围（如不在锁内执行耗时操作）
     </li>
    </ol>
    <p>
     <strong>
      全局互斥锁(QMutex\QMutexLocker)
     </strong>
    </p>
    <p>
     Qt的读写锁（
     <code>
      QReadWriteLock
     </code>
     ）是一种线程同步机制，旨在优化多线程环境下对共享资源的访问效率。其核心原则为：
    </p>
    <ul>
     <li>
      <strong>
       读共享
      </strong>
      ：允许多个线程同时获取读锁（
      <code>
       lockForRead()
      </code>
      ），执行只读操作，互不干扰 。
     </li>
     <li>
      <strong>
       写独占
      </strong>
      ：同一时间仅允许一个线程获取写锁（
      <code>
       lockForWrite()
      </code>
      ），执行写入操作，期间阻塞其他所有读写操作 。
     </li>
     <li>
      <strong>
       写优先策略
      </strong>
      ：默认情况下，写锁请求优先于读锁请求，确保写操作不会被无限延迟
     </li>
    </ul>
    <p style="background-color:transparent">
     <strong>
      锁操作函数
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       读锁
      </strong>
      ：
      <code>
       lockForRead()
      </code>
      阻塞直到获取读锁；
      <code>
       tryLockForRead()
      </code>
      非阻塞尝试获取读锁，可设置超时 。
     </li>
     <li>
      <strong>
       写锁
      </strong>
      ：
      <code>
       lockForWrite()
      </code>
      阻塞直到获取写锁；
      <code>
       tryLockForWrite()
      </code>
      非阻塞尝试获取写锁 。
     </li>
     <li>
      <strong>
       解锁
      </strong>
      ：
      <code>
       unlock()
      </code>
      释放当前持有的读锁或写锁
     </li>
    </ul>
    <pre><code class="language-cpp">// 全局缓冲区和读写锁
QVector&lt;int&gt; buffer;
QReadWriteLock rwLock;

// 数据采集线程（写操作）
void dataAcquisitionThread() {
    QWriteLocker locker(&amp;rwLock);
    buffer.append(newData); // 写入新数据
}

// 数据显示线程（读操作）
void dataDisplayThread() {
    QReadLocker locker(&amp;rwLock);
    for (int val : buffer) qDebug() &lt;&lt; val; // 读取数据
}</code></pre>
    <pre><code class="language-cpp">#include &lt;QReadWriteLock&gt;
#include &lt;QThread&gt;
#include &lt;QDebug&gt;

QReadWriteLock rwLock; // 全局读写锁
int sharedData = 0;    // 共享资源

class ReaderThread : public QThread {
protected:
    void run() override {
        rwLock.lockForRead();  // 手动加读锁
        qDebug() &lt;&lt; "Read data:" &lt;&lt; sharedData;
        rwLock.unlock();       // 必须手动解锁！
    }
};

class WriterThread : public QThread {
protected:
    void run() override {
        rwLock.lockForWrite();  // 手动加写锁
        sharedData++;
        qDebug() &lt;&lt; "Write data:" &lt;&lt; sharedData;
        rwLock.unlock();        // 必须手动解锁！
    }
};</code></pre>
    <p>
     <strong>
      注意事项
      <br/>
     </strong>
     即使是读写锁，在使用过程中也要注意读锁进行锁后，也需要释放，在调用写锁，不然可能也会出现死锁的情况，同时解锁的时候可以尝试try，保证线程的安全释放锁资源。
     <br/>
    </p>
    <pre><code class="language-cpp">void run() {
    rwLock.lockForRead();
    try {
        // 临界区操作
    } catch (...) {
        rwLock.unlock();
        throw;
    }
    rwLock.unlock();
}</code></pre>
    <pre><code class="language-cpp">rwLock.lockForRead();
// 读操作
rwLock.unlock();

rwLock.lockForWrite();
// 写操作
rwLock.unlock();</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35313435373339312f:61727469636c652f64657461696c732f313436303630363430" class_="artid" style="display:none">
 </p>
</div>


