---
layout: post
title: "游戏编程入门5使用键盘和鼠标控制游戏"
date: 2025-01-03 17:02:29 +0800
description: "接上文 游戏编程入门（4）：绘制图形图像本文内容包括：如何有效地检测和"
keywords: "peekmessage 删除鼠标键盘消息"
categories: ['游戏编程入门', '?.游戏编程入门']
tags: ['游戏编程', 'Windows', 'Vc', 'Mfc', 'C']
artid: "73864372"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=73864372
    alt: "游戏编程入门5使用键盘和鼠标控制游戏"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=73864372
featuredImagePreview: https://bing.ee123.net/img/rand?artid=73864372
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     游戏编程入门（5）：使用键盘和鼠标控制游戏
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     接上文
     <a href="http://blog.csdn.net/Jurbo/article/details/73740955#t20" rel="noopener noreferrer" target="_blank">
      游戏编程入门（4）：绘制图形图像
     </a>
    </p>
    <p>
     本文内容包括：
    </p>
    <ul>
     <li>
      如何有效地检测和响应键盘输入
     </li>
     <li>
      如何处理鼠标输入
     </li>
     <li>
      如何开发带有动画图形对象的程序，并且可以使用键盘和鼠标来控制动画图形对象
     </li>
    </ul>
    <hr/>
    <h2 id="用户输入设备">
     用户输入设备
    </h2>
    <p>
     <strong>
      输入设备是允许用户与一个游戏进行交互的物理硬件。
     </strong>
    </p>
    <p>
     所有输入设备都执行相同的操作：
     <strong>
      将用户提供的信息转换为一种计算机可以理解的格式
     </strong>
     。输入设备在用户与游戏之间建立联系。
    </p>
    <p>
     有三种主要的输入设备类型：
    </p>
    <ul>
     <li>
      键盘
     </li>
     <li>
      鼠标
     </li>
     <li>
      游戏杆
     </li>
    </ul>
    <h2 id="键盘输入">
     键盘输入
    </h2>
    <p>
     我们知道，在Win32 API 中大量使用消息来提交有关各种事件的通知，如创建窗口、破坏窗口、激活窗口、使用窗口等，这个相同的信息传递系统也用来传递在键盘上按键的通知。
    </p>
    <p>
     <strong>
      Win32 API 定义了名为 WM_KEYDOWN 和 WM_KEYUP 的消息，只需要按下或释放一个键，它们就会通知你。
     </strong>
    </p>
    <p>
     但是，标准的Windows消息传递系统 传输键盘消息的速度慢的令人难以忍受，而游戏对快速响应的控制要求很高。
    </p>
    <h2 id="跟踪鼠标">
     跟踪鼠标
    </h2>
    <p>
     在移动鼠标的时候，将会引发一系列事件，这些事件与键盘所引发的那些事件非常相似。
    </p>
    <p>
     实际上，Win32 API 包括了一系列用来传送鼠标事件的鼠标消息，与键盘消息传递键盘事件的方式相似。
    </p>
    <p>
     在前面，我们了解到
     <strong>
      Win32键盘消息不适合为游戏提供有效输入的任务。而鼠标消息并不属于这种情况，通过消息处理鼠标事件的Win32方法对游戏很适用。
     </strong>
    </p>
    <p>
     下面是用来
     <strong>
      向Windows程序通报鼠标事件的鼠标消息：
     </strong>
    </p>
    <ul>
     <li>
      WM_MOUSEMOVE：任何鼠标移动
     </li>
     <li>
      WM_LBUTTONDOWN：按下鼠标左键
     </li>
     <li>
      WM_LBUTTONUP：释放鼠标左键
     </li>
     <li>
      WM_RBUTTONDOWN：按下鼠标右键
     </li>
     <li>
      WM_RBUTTONUP：释放鼠标右键
     </li>
     <li>
      WM_MBUTTONDOWN：按下鼠标中键
     </li>
     <li>
      WM_MBUTTONUP：释放鼠标中键
     </li>
    </ul>
    <p>
     <strong>
      实现鼠标拖动功能
     </strong>
     ：单击鼠标的一个按钮，再按下一个按钮，之后释放这个按钮。通过记录 按下和释放鼠标按钮的时间并查看这段时间内的鼠标移动，就可以实现鼠标拖动功能。
    </p>
    <p>
     在前面讲游戏引擎的时候，我们定义了一个HandleEvent( )方法，方法的原型如下：
    </p>
    <pre class="prettyprint"><code class="hljs css"><span class="hljs-tag">LRESULT</span> <span class="hljs-tag">GameEngine</span><span class="hljs-pseudo">::HandleEvent(HWND</span> <span class="hljs-tag">hWindow</span>,<span class="hljs-tag">UINT</span> <span class="hljs-tag">msg</span>,<span class="hljs-tag">WPARAM</span> <span class="hljs-tag">wParam</span>,<span class="hljs-tag">LPARAM</span> <span class="hljs-tag">lParam</span>);</code></pre>
    <p>
     <strong>
      wParam 和 lParam参数是随着每一个Windows消息一起发送的，它们包含了消息专用的信息。
     </strong>
    </p>
    <p>
     鼠标指针的位置是鼠标的一个重要性质，
     <strong>
      对于鼠标消息来说，lParam包含了鼠标指针的XY位置（包含其在低位和高位字节中）。
     </strong>
    </p>
    <p>
     下面这个例子，从WM_MOUSEMOVE 消息处理程序的 lParam 参数中提取鼠标位置：
    </p>
    <pre class="prettyprint"><code class="hljs bash"><span class="hljs-keyword">case</span> WM_MOUSEMOVE:
    WORD x=LOWORD(lParam);
    WORD y=HIWORD(lParam);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre>
    <p>
     而
     <strong>
      鼠标消息的wParam 参数包含有关鼠标按钮状态的信息以及一些键盘信息
     </strong>
     。更具体的说，wParam 使我们知道三个按钮（鼠标左键，中键，右键）中是否有一个处于被按下的状态，是否按下了键盘上的Shift键或Ctrl键。
    </p>
    <p>
     下面是在处理鼠标消息是，用来解释
     <strong>
      wParam 参数值的一些常量：
     </strong>
    </p>
    <ul>
     <li>
      MK_LBUTTON：按下了鼠标左键
     </li>
     <li>
      MK_RBUTTON：按下了鼠标右键
     </li>
     <li>
      MK_MBUTTON：按下了鼠标中键
     </li>
     <li>
      MK_SHIFT：按下了Shift键
     </li>
     <li>
      MK_CONTROL：按下了Ctrl键
     </li>
    </ul>
    <p>
     可以通过检查这些鼠标常量，以便确定在鼠标移动的过程中是否按下了一个按钮或键。
    </p>
    <p>
     实际上，这些常量也可以在wParam 参数中将它们组合在一起，
     <strong>
      要想检查单个标志的存在性，必须使用按位AND 运算符（&amp;）来检查标志是否存在。
     </strong>
    </p>
    <p>
     下面是检查wParam 以查看是否按下鼠标右键的一个例子：
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">if</span>(wParam &amp; HK_RBUTTON)
    <span class="hljs-comment">//按下了鼠标右键</span></code></pre>
    <h2 id="向-游戏引擎-添加输入支持">
     向 游戏引擎 添加输入支持
    </h2>
    <p>
     因为我们已经开发了一个游戏引擎来完成与游戏管理有关的各种任务，所以将用户输入处理结合到游戏引擎中是很有意义的。处理用户输入的某个方面是游戏所特有的，因此必须在每个单独游戏的代码中进行处理。不过，键盘处理和鼠标处理存在一些通用的地方，可以将它们结合到游戏引擎中，从而简化特定游戏代码所需要完成的工作。
    </p>
    <h3 id="添加键盘支持">
     添加键盘支持
    </h3>
    <p>
     在前面我们已经了解到使用消息来处理键盘的标准Windows方法对于游戏来说是不够的（因为太慢了）。
    </p>
    <p>
     <strong>
      处理键盘输入的一种更好的方法是反复检查键盘的状态，查看是否按下了特定的键，然后做出相应的反应。
     </strong>
    </p>
    <p>
     使用这个策略，
     <strong>
      键盘输入处理的很多工作就转移给了游戏代码，这意味着游戏引擎主要只负责调用一个键盘处理函数，使游戏有机会相应按键。
     </strong>
    </p>
    <p>
     下面是这个函数的原型：
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">void</span> HandleKeys();</code></pre>
    <p>
     <strong>
      HandleKeys( ) 函数必须作为游戏代码的一部分提供，因此它不包括在游戏引擎中。如果不希望游戏支持键盘输入，那么只需要使HandleKeys( ) 函数保持为空白即可。
     </strong>
    </p>
    <p>
     当然，游戏引擎必须确定以足够快的速度调用HandleKeys( ) 函数，从而使游戏能够立即响应。
    </p>
    <p>
     <strong>
      这是在游戏引擎代码（GameEngine.cpp）中的WinMain( )函数中实现的
     </strong>
     。下面是对这个函数所作的修改：
    </p>
    <pre class="prettyprint"><code class="hljs coffeescript"><span class="hljs-keyword">if</span>(iTickCount &gt; iTickTrigger)
{
    iTickTrigger = iTickCount + <span class="hljs-attribute">GameEngine</span>::GetEngine<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>GetFrameDelay();
    HandleKeys();
    GameCycle();
}</code></pre>
    <p>
     对WinMain( ) 代码的唯一一处改动是对HandleKeys( )函数的新调用。注意，这个调用刚好在GameCycle( ) 函数之前发生，这表示游戏在每个周期之前都会获得相应键盘输入的机会。
    </p>
    <p>
     不要忘了，处理键盘输入的具体细节是在各个特定的游戏中实现的，也就是在创建自己的HandleKeys( )函数时。
    </p>
    <h3 id="添加鼠标支持">
     添加鼠标支持
    </h3>
    <p>
     要想支持鼠标输入，游戏必须支持以下3个函数，
     <strong>
      它们由游戏引擎在接受到鼠标事件时调用。
     </strong>
    </p>
    <p>
     <strong>
      鼠标处理函数如下
     </strong>
     ：
    </p>
    <pre class="prettyprint"><code class="hljs objectivec"><span class="hljs-keyword">void</span> MouseButtonDown(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-built_in">BOOL</span> bLeft); <span class="hljs-comment">//按下鼠标</span>
<span class="hljs-keyword">void</span> MouseButtonUp(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-built_in">BOOL</span> bLeft);   <span class="hljs-comment">//释放鼠标</span>
boid MouseMove(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);                  <span class="hljs-comment">//鼠标移动</span></code></pre>
    <p>
     <strong>
      要想将鼠标消息与这些鼠标处理函数联系起来，游戏引擎必须检查适当的鼠标消息并作出响应的响应。
     </strong>
    </p>
    <p>
     下面这段代码包括了GameEngine::HandleEvent( )方法的一部分新内容，它们负责
     <strong>
      处理传递到主游戏窗口的鼠标消息
     </strong>
     。
    </p>
    <pre class="prettyprint"><code class="hljs php"><span class="hljs-keyword">CASE</span> WM_LBUTTONDOWN:
    <span class="hljs-comment">//处理按下鼠标左键的事件</span>
    MouseButtonDown(LOWORD(lParam), HIWORD(lParam),<span class="hljs-keyword">TRUE</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">CASE</span> WM_LBUTTONUP:
    <span class="hljs-comment">//处理释放鼠标左键的事件</span>
    MouseButtonUp(LOWORD(lParam), HIWORD(lParam),<span class="hljs-keyword">TRUE</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">CASE</span> WM_RBUTTONDOWN:
    <span class="hljs-comment">//处理按下鼠标右键的事件</span>
    MouseButtonDown(LOWORD(lParam), HIWORD(lParam),<span class="hljs-keyword">FALSE</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">CASE</span> WM_RBUTTONDOWN:
    <span class="hljs-comment">//处理释放鼠标右键的事件</span>
    MouseButtonUp(LOWORD(lParam), HIWORD(lParam),<span class="hljs-keyword">FALSE</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">CASE</span> WM_MOUSEMOVE:
    <span class="hljs-comment">//处理按下鼠标移动的事件</span>
    MouseMove(LOWORD(lParam), HIWORD(lParam));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre>
    <p>
     鼠标按钮函数的最后一个参数是一个布尔值，它标识了事件中是否涉及鼠标左键（TRUE）或鼠标右键（FALSE）
    </p>
    <h3 id="修改-bitmap-类-使-位图透明">
     修改 Bitmap 类 使 位图透明
    </h3>
    <p>
     从技术上讲，这个修改与输入没有任何关系。
    </p>
    <p>
     位图透明，可以使位图不是总显示为方块图形对象（虽然位图都是方块图形对象，但我们不一定必须按照这种方式来绘制）。
    </p>
    <p>
     <strong>
      透明的意思是可以将一种颜色指定为透明色，然后使用这种颜色来表示一个位图的透明部分。在绘制位图时，不会绘制透明色的像素，背景将会透过它显示出来。
     </strong>
    </p>
    <p>
     从创建图形的角度来看，创建带有透明位图的方法是选择一种图形中没有使用的颜色，例如深紫色，然后使用深紫色来填充位图中需要显示为透明的区域。
    </p>
    <p>
     游戏开发群体在透明色的使用上有一些争论。过去，紫色（RGB：255,0, 255）是表示透明的标准颜色。现在，大多数商业3D游戏都使用纯黑色（RGB：0，0, 0）、纯蓝（RGB：0, 0, 255）或中度灰色（RGB：128, 128, 128）作为透明色。
    </p>
    <p>
     <strong>
      本系列所有的例子，都使用紫色作为透明色，但是只要在某个特定游戏的图形中保持一致，就可以任意选择使用没有使用的颜色。
     </strong>
    </p>
    <p>
     <strong>
      在游戏引擎中，实现位图透明的诀窍是扩展现有的 Bitmap::Draw( ) 方法
     </strong>
     ，使之支持透明。这通过添加两个新的参数实现。
    </p>
    <ul>
     <li>
      bTran：布尔值，表示是否将位图绘制为透明的。FALSE：没有使用透明
     </li>
     <li>
      crTransColor：位图的透明色
     </li>
    </ul>
    <p>
     对Draw( ) 的唯一一个重大更改是检查透明参数 bTran ，如果这个参数为TRUE，则使用
     <strong>
      Win32 的 TransparentBlt( ) 函数绘制带有透明的位图
     </strong>
     。否则，就像往常一样使用 BitBlt( ) 函数绘制不带透明的位图。
    </p>
    <p>
     TransparentBlt( ) 函数，需要包括一个名为msimg32.lib的库，记得在工程”-&gt;”设置”-&gt;在”Project Setting”中,”对象/库模块”中，增加Msimg32.lib。
    </p>
    <h2 id="开发-ufo-示例">
     开发 UFO 示例
    </h2>
    <p>
     本文将着重讨论一个名为 UFO 的实例，虽然从技术上讲，这个程序不是一个游戏，但它是到目前为止读者所看到的最接近于游戏的程序。
    </p>
    <p>
     它包括一个可以使用键盘或（和）鼠标控制的飞碟，可以使飞碟在一个位图背景图像上飞行。
    </p>
    <p>
     本程序，在每一个游戏周期都重新绘制位图，因此通过改变位图的位置并不断重新绘制，就创建了UFO移动的效果。
    </p>
    <h3 id="ufo目录结构与效果图">
     UFO目录结构与效果图
    </h3>
    <p>
     <strong>
      UFO目录结构
     </strong>
     ：
    </p>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20170628214851200?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSnVyYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""/>
    </p>
    <p>
     <strong>
      UFO效果图：
     </strong>
    </p>
    <p>
     <img alt="这里写图片描述" src="https://img-blog.csdn.net/20170628214933777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSnVyYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""/>
    </p>
    <h3 id="ufo-源代码">
     UFO 源代码
    </h3>
    <h4 id="resourceh">
     Resource.h
    </h4>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// UFO Resource Identifiers</span>
<span class="hljs-comment">// C++ Header - Resource.h</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Icons                    Range : 1000 - 1999</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> IDI_UFO             1000</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> IDI_UFO_SM          1001</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Bitmaps                  Range : 2000 - 2999</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> IDB_BACKGROUND      2000</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> IDB_SAUCER          2001</span>
</code></pre>
    <h4 id="ufoh">
     UFO.h
    </h4>
    <pre class="prettyprint"><code class="hljs vala"><span class="hljs-preprocessor">#pragma once</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 包含文件</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>
<span class="hljs-preprocessor">#include "Resource.h"</span>
<span class="hljs-preprocessor">#include "GameEngine.h"</span>
<span class="hljs-preprocessor">#include "Bitmap.h"</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 全局变量</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
HINSTANCE   g_hInstance;     <span class="hljs-comment">//程序句柄</span>
GameEngine* g_pGame;         <span class="hljs-comment">//游戏引擎指针</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>   g_iMAXSPEED = <span class="hljs-number">8</span>; <span class="hljs-comment">//飞碟的最大速度即1个游戏周期内在x或y方向上移动的像素</span>
Bitmap*     g_pBackground;   <span class="hljs-comment">//夜晚天空的背景</span>
Bitmap*     g_pSaucer;       <span class="hljs-comment">//飞碟图像</span>
<span class="hljs-keyword">int</span>         g_iSaucerX, g_iSaucerY; <span class="hljs-comment">//飞碟的x,y位置</span>
<span class="hljs-keyword">int</span>         g_iSpeedX, g_iSpeedY;   <span class="hljs-comment">//飞碟的xy速度（即每周期移动的像素）负值即为反方向</span>
</code></pre>
    <h4 id="bitmaph">
     Bitmap.h
    </h4>
    <pre class="prettyprint"><code class="hljs haskell"><span class="hljs-preprocessor">#pragma once</span>

//<span class="hljs-comment">-----------------------------------------------------------------</span>
// 包含的文件
//<span class="hljs-comment">-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>

//<span class="hljs-comment">-----------------------------------------------------------------</span>
// <span class="hljs-type">Bitmap</span> 类
//<span class="hljs-comment">-----------------------------------------------------------------</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Bitmap</span>
{
protected:
  // 成员变量
  <span class="hljs-type">HBITMAP</span> m_hBitmap;          //位图句柄
  int     m_iWidth, m_iHeight;//位图的宽和高

  // 帮助器方法，用来释放与位图有关的内存并清除位图句柄
  void <span class="hljs-type">Free</span><span class="hljs-container">()</span>;

public:
  // 构造函数和析构函数  3个构造函数分别对应一种创建位图的不同方法
  <span class="hljs-type">Bitmap</span><span class="hljs-container">()</span>;
  //从一个文件中创建位图
  <span class="hljs-type">Bitmap</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-type">LPTSTR</span> <span class="hljs-title">szFileName</span>)</span>;
  //从一个资源中创建位图
  <span class="hljs-type">Bitmap</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-type">UINT</span> <span class="hljs-title">uiResID</span>, <span class="hljs-type">HINSTANCE</span> <span class="hljs-title">hInstance</span>)</span>;
  //创建纯色的空白位图
  <span class="hljs-type">Bitmap</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-title">int</span> <span class="hljs-title">iWidth</span>, <span class="hljs-title">int</span> <span class="hljs-title">iHeight</span>, <span class="hljs-type">COLORREF</span> <span class="hljs-title">crColor</span> = <span class="hljs-type">RGB</span>(0, 0, 0)</span>);
  virtual ~<span class="hljs-type">Bitmap</span><span class="hljs-container">()</span>;

  // 常规方法 create<span class="hljs-container">()</span>用来处理加载位图数据并将其创建为一个<span class="hljs-type">GDI</span> 对象，3个<span class="hljs-type">Create</span>分别对应3个构造函数
  <span class="hljs-type">BOOL</span> <span class="hljs-type">Create</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-type">LPTSTR</span> <span class="hljs-title">szFileName</span>)</span>;
  <span class="hljs-type">BOOL</span> <span class="hljs-type">Create</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-type">UINT</span> <span class="hljs-title">uiResID</span>, <span class="hljs-type">HINSTANCE</span> <span class="hljs-title">hInstance</span>)</span>;
  <span class="hljs-type">BOOL</span> <span class="hljs-type">Create</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-title">int</span> <span class="hljs-title">iWidth</span>, <span class="hljs-title">int</span> <span class="hljs-title">iHeight</span>, <span class="hljs-type">COLORREF</span> <span class="hljs-title">crColor</span>)</span>;

  //提供将位图绘制到设备环境上的方法  bTrans=<span class="hljs-type">FALSE</span>，不将位图绘制成透明
  void <span class="hljs-type">Draw</span><span class="hljs-container">(<span class="hljs-type">HDC</span> <span class="hljs-title">hDC</span>, <span class="hljs-title">int</span> <span class="hljs-title">x</span>, <span class="hljs-title">int</span> <span class="hljs-title">y</span>, <span class="hljs-type">BOOL</span> <span class="hljs-title">bTrans</span> = <span class="hljs-type">FALSE</span>,
    <span class="hljs-type">COLORREF</span> <span class="hljs-title">crTransColor</span> = <span class="hljs-type">RGB</span>(255, 0, 255)</span>);

  int  <span class="hljs-type">GetWidth</span><span class="hljs-container">()</span> 
  {
      return m_iWidth; 
  };
  int  <span class="hljs-type">GetHeight</span><span class="hljs-container">()</span> 
  {
      return m_iHeight; 
  };
};
</span></code></pre>
    <h4 id="gameengineh">
     GameEngine.h
    </h4>
    <pre class="prettyprint"><code class="hljs objectivec"><span class="hljs-preprocessor">#pragma once  /*该头文件仅编译一次（因为同一头文件会在许多源文件中多次引用。如</span>
果没有指定编译一次，则编译时出现重定义错误。*/

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 包含的头文件 </span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#include &lt;windows.h&gt;</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Windows函数声明</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>

<span class="hljs-comment">/*WinMain函数应初始化应用程序，显示主窗口，进入一个消息接收一发送循环，
这个循环是应用程序执行的其余部分的顶级控制结构。*/</span> 
<span class="hljs-keyword">int</span> WINAPI        WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, <span class="hljs-keyword">int</span> iCmdShow);
<span class="hljs-comment">//窗口过程，指向一个应用程序定义的窗口过程的指针。                   </span>
LRESULT CALLBACK  WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 游戏事件函数声明 </span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-built_in">BOOL</span> GameInitialize(HINSTANCE hInstance);<span class="hljs-comment">//初始化游戏 </span>
<span class="hljs-keyword">void</span> GameStart(HWND hWindow);            <span class="hljs-comment">//启动游戏</span>
<span class="hljs-keyword">void</span> GameEnd();                          <span class="hljs-comment">//结束游戏</span>
<span class="hljs-keyword">void</span> GameActivate(HWND hWindow);         <span class="hljs-comment">//激活游戏 </span>
<span class="hljs-keyword">void</span> GameDeactivate(HWND hWindow);       <span class="hljs-comment">//停用游戏 </span>
<span class="hljs-keyword">void</span> GamePaint(HDC hDC);                 <span class="hljs-comment">//绘制游戏 </span>
<span class="hljs-keyword">void</span> GameCycle();                        <span class="hljs-comment">//循环游戏</span>

<span class="hljs-comment">//键盘与鼠标处理函数 </span>
<span class="hljs-keyword">void</span> HandleKeys();                             <span class="hljs-comment">//键盘处理函数</span>
<span class="hljs-keyword">void</span> MouseButtonDown(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">BOOL</span> bLeft);<span class="hljs-comment">//按下鼠标</span>
<span class="hljs-keyword">void</span> MouseButtonUp(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">BOOL</span> bLeft);  <span class="hljs-comment">//释放鼠标</span>
<span class="hljs-keyword">void</span> MouseMove(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);                  <span class="hljs-comment">//鼠标移动</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// GameEngine 类</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
class GameEngine
{
protected:
  <span class="hljs-comment">//成员变量</span>
  <span class="hljs-keyword">static</span> GameEngine*  m_pGameEngine; <span class="hljs-comment">//指向自身的静态指针，用于游戏程序的外部访问</span>
  HINSTANCE           m_hInstance;           <span class="hljs-comment">//应用程序实例</span>
  HWND                m_hWindow;             <span class="hljs-comment">//主窗口句柄</span>
  TCHAR               m_szWindowClass[<span class="hljs-number">32</span>];   <span class="hljs-comment">//窗口类的名称</span>
  TCHAR               m_szTitle[<span class="hljs-number">32</span>];         <span class="hljs-comment">//主游戏窗口的名称</span>
  WORD                m_wIcon, m_wSmallIcon; <span class="hljs-comment">//游戏的两个程序图标的数字ID</span>
  <span class="hljs-keyword">int</span>                 m_iWidth, m_iHeight;   <span class="hljs-comment">//游戏屏幕的宽度和高度</span>
  <span class="hljs-keyword">int</span>                 m_iFrameDelay;         <span class="hljs-comment">//游戏周期之间的间隔，单位是ms</span>
  <span class="hljs-built_in">BOOL</span>                m_bSleep;              <span class="hljs-comment">//表示游戏是否在休眠</span>

public:
  <span class="hljs-comment">//构造函数和析构函数</span>

  <span class="hljs-comment">//游戏引擎构造函数使用默认的屏幕大小（640*480）创建游戏，这是实际的游戏区</span>
          GameEngine(HINSTANCE hInstance, LPTSTR szWindowClass, LPTSTR szTitle,
            WORD wIcon, WORD wSmallIcon, <span class="hljs-keyword">int</span> iWidth = <span class="hljs-number">640</span>, <span class="hljs-keyword">int</span> iHeight = <span class="hljs-number">480</span>);
  virtual ~GameEngine();

  <span class="hljs-comment">//常规方法</span>

  <span class="hljs-comment">//在引擎外部使用这个静态方法访问指向引擎的静态指针 </span>
  <span class="hljs-keyword">static</span> GameEngine*  GetEngine() 
  { 
         <span class="hljs-keyword">return</span> m_pGameEngine; 
  };
  <span class="hljs-comment">//创建引擎后，初始化游戏程序 </span>
  <span class="hljs-built_in">BOOL</span>                Initialize(<span class="hljs-keyword">int</span> iCmdShow);
  <span class="hljs-comment">//处理引擎内的标准Windows事件 </span>
  LRESULT             HandleEvent(HWND hWindow, UINT msg, WPARAM wParam,
  LPARAM lParam);
  <span class="hljs-keyword">void</span>                ErrorQuit(LPTSTR szErrorMsg);

 <span class="hljs-comment">//访问方法</span>
  HINSTANCE GetInstance() 
  { 
            <span class="hljs-keyword">return</span> m_hInstance; 
  };
  HWND      GetWindow() 
  { 
            <span class="hljs-keyword">return</span> m_hWindow; 
  };
  <span class="hljs-keyword">void</span>      SetWindow(HWND hWindow) 
  { 
            m_hWindow = hWindow; 
  };
  LPTSTR    GetTitle() 
  { 
            <span class="hljs-keyword">return</span> m_szTitle; 
  };
  WORD      GetIcon() 
  { 
            <span class="hljs-keyword">return</span> m_wIcon; 
  };
  WORD      GetSmallIcon() 
  {
             <span class="hljs-keyword">return</span> m_wSmallIcon; 
  };
  <span class="hljs-keyword">int</span>       GetWidth() 
  {
             <span class="hljs-keyword">return</span> m_iWidth; 
  };
  <span class="hljs-keyword">int</span>       GetHeight() 
  { 
            <span class="hljs-keyword">return</span> m_iHeight; 
  };
  <span class="hljs-keyword">int</span>       GetFrameDelay() 
  { 
            <span class="hljs-keyword">return</span> m_iFrameDelay; 
  };
  <span class="hljs-comment">//指定帧速率，当值为30时会使游戏以30帧/秒的速率运行</span>
  <span class="hljs-keyword">void</span>      SetFrameRate(<span class="hljs-keyword">int</span> iFrameRate) 
  { 
            m_iFrameDelay = <span class="hljs-number">1000</span> /iFrameRate; 
  };
  <span class="hljs-built_in">BOOL</span>      GetSleep() 
  { 
            <span class="hljs-keyword">return</span> m_bSleep; 
  };
  <span class="hljs-keyword">void</span>      SetSleep(<span class="hljs-built_in">BOOL</span> bSleep) 
  { 
            m_bSleep = bSleep; 
  };
};
</code></pre>
    <h4 id="ufocpp">
     UFO.cpp
    </h4>
    <pre class="prettyprint"><code class="hljs lasso"><span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 包含的文件</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-variable">#include</span> <span class="hljs-string">"UFO.h"</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 游戏事件函数</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>

<span class="hljs-comment">// 初始化游戏</span>
BOOL GameInitialize(HINSTANCE hInstance)
{
  <span class="hljs-comment">// 创建游戏引擎</span>
  g_pGame <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> GameEngine(hInstance, TEXT(<span class="hljs-string">"UFO"</span>),
    TEXT(<span class="hljs-string">"UFO"</span>), IDI_UFO, IDI_UFO_SM, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>);
  <span class="hljs-keyword">if</span> (g_pGame <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">// 设置帧率</span>
  g_pGame<span class="hljs-subst">-&gt;</span>SetFrameRate(<span class="hljs-number">30</span>);

  <span class="hljs-comment">// 存储程序句柄</span>
  g_hInstance <span class="hljs-subst">=</span> hInstance;

  <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
}

<span class="hljs-comment">// 开始游戏</span>
<span class="hljs-literal">void</span> GameStart(HWND hWindow)
{
  <span class="hljs-comment">// 创建并加载背景和飞碟位图</span>
  HDC hDC <span class="hljs-subst">=</span> GetDC(hWindow);
  g_pBackground <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> Bitmap(hDC, IDB_BACKGROUND, g_hInstance);
  g_pSaucer <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> Bitmap(hDC, IDB_SAUCER, g_hInstance);

  <span class="hljs-comment">// 设置初始的飞碟位置和速度（飞碟最初稳定停放在屏幕中央）</span>
  g_iSaucerX <span class="hljs-subst">=</span> <span class="hljs-number">250</span> <span class="hljs-subst">-</span> (g_pSaucer<span class="hljs-subst">-&gt;</span>GetWidth() <span class="hljs-subst">/</span> <span class="hljs-number">2</span>);
  g_iSaucerY <span class="hljs-subst">=</span> <span class="hljs-number">200</span> <span class="hljs-subst">-</span> (g_pSaucer<span class="hljs-subst">-&gt;</span>GetHeight() <span class="hljs-subst">/</span> <span class="hljs-number">2</span>);
  g_iSpeedX <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 将飞碟的速度设置为0，它就不会动</span>
  g_iSpeedY <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 游戏结束</span>
<span class="hljs-literal">void</span> GameEnd()
{
  <span class="hljs-comment">// Cleanup the background and saucer bitmaps</span>
  delete g_pBackground;
  delete g_pSaucer;

  <span class="hljs-comment">// Cleanup the game engine</span>
  delete g_pGame;
}

<span class="hljs-literal">void</span> GameActivate(HWND hWindow)
{
}

<span class="hljs-literal">void</span> GameDeactivate(HWND hWindow)
{
}

<span class="hljs-comment">// 绘制游戏</span>
<span class="hljs-literal">void</span> GamePaint(HDC hDC)
{
  <span class="hljs-comment">// 绘制背景和飞碟位图</span>

  <span class="hljs-comment">// 背景是在游戏屏幕的原点绘制的</span>
  g_pBackground<span class="hljs-subst">-&gt;</span>Draw(hDC, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 飞碟则是再度昂前位置绘制的，使用默认的透明色（紫色）来绘制带透明的飞碟</span>
  g_pSaucer<span class="hljs-subst">-&gt;</span>Draw(hDC, g_iSaucerX, g_iSaucerY, <span class="hljs-literal">TRUE</span>);
}

<span class="hljs-comment">// 游戏循环</span>
<span class="hljs-literal">void</span> GameCycle()
{
  <span class="hljs-comment">// 更新飞碟的位置 min()，max()用来确定飞碟停留在屏幕的范围内</span>
  g_iSaucerX <span class="hljs-subst">=</span> <span class="hljs-keyword">min</span>(<span class="hljs-number">500</span> <span class="hljs-subst">-</span> g_pSaucer<span class="hljs-subst">-&gt;</span>GetWidth(), <span class="hljs-keyword">max</span>(<span class="hljs-number">0</span>, g_iSaucerX <span class="hljs-subst">+</span> g_iSpeedX));
  g_iSaucerY <span class="hljs-subst">=</span> <span class="hljs-keyword">min</span>(<span class="hljs-number">320</span>, <span class="hljs-keyword">max</span>(<span class="hljs-number">0</span>, g_iSaucerY <span class="hljs-subst">+</span> g_iSpeedY));

  <span class="hljs-comment">// 强制重新绘制，以便重新绘制飞碟，达到飞碟移动的效果</span>
  InvalidateRect(g_pGame<span class="hljs-subst">-&gt;</span>GetWindow(), <span class="hljs-built_in">NULL</span>, <span class="hljs-literal">FALSE</span>);
}

<span class="hljs-comment">// 键盘处理函数</span>
<span class="hljs-literal">void</span> HandleKeys()
{
  <span class="hljs-comment">// 响应方向键按键事件，更改飞碟的速度  GetAsyncKeyState()获得键盘上任何键的状态</span>
  <span class="hljs-keyword">if</span> (GetAsyncKeyState(VK_LEFT) <span class="hljs-subst">&lt;</span> <span class="hljs-number">0</span>)
    g_iSpeedX <span class="hljs-subst">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-attribute">-g_iMAXSPEED</span>, <span class="hljs-subst">--</span>g_iSpeedX);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GetAsyncKeyState(VK_RIGHT) <span class="hljs-subst">&lt;</span> <span class="hljs-number">0</span>)
    g_iSpeedX <span class="hljs-subst">=</span> <span class="hljs-keyword">min</span>(g_iMAXSPEED, <span class="hljs-subst">++</span>g_iSpeedX);
  <span class="hljs-keyword">if</span> (GetAsyncKeyState(VK_UP) <span class="hljs-subst">&lt;</span> <span class="hljs-number">0</span>)
    g_iSpeedY <span class="hljs-subst">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-attribute">-g_iMAXSPEED</span>, <span class="hljs-subst">--</span>g_iSpeedY);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GetAsyncKeyState(VK_DOWN) <span class="hljs-subst">&lt;</span> <span class="hljs-number">0</span>)
    g_iSpeedY <span class="hljs-subst">=</span> <span class="hljs-keyword">min</span>(g_iMAXSPEED, <span class="hljs-subst">++</span>g_iSpeedY);
}

<span class="hljs-comment">// 释放鼠标</span>
<span class="hljs-literal">void</span> MouseButtonDown(int x, int y, BOOL bLeft)
{
  <span class="hljs-comment">// 左键</span>
  <span class="hljs-keyword">if</span> (bLeft)
  {
    <span class="hljs-comment">// 将飞碟设置为当前的鼠标位置</span>
    g_iSaucerX <span class="hljs-subst">=</span> x <span class="hljs-subst">-</span> (g_pSaucer<span class="hljs-subst">-&gt;</span>GetWidth() <span class="hljs-subst">/</span> <span class="hljs-number">2</span>);
    g_iSaucerY <span class="hljs-subst">=</span> y <span class="hljs-subst">-</span> (g_pSaucer<span class="hljs-subst">-&gt;</span>GetHeight() <span class="hljs-subst">/</span> <span class="hljs-number">2</span>);
  }
  <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 右键</span>
  {
    <span class="hljs-comment">// 将飞碟的速度设置为0</span>
    g_iSpeedX <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
    g_iSpeedY <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
  }
}

<span class="hljs-comment">// 按下鼠标</span>
<span class="hljs-literal">void</span> MouseButtonUp(int x, int y, BOOL bLeft)
{
}

<span class="hljs-comment">// 移动鼠标</span>
<span class="hljs-literal">void</span> MouseMove(int x, int y)
{
}
</code></pre>
    <h4 id="bitmapcpp">
     Bitmap.cpp
    </h4>
    <pre class="prettyprint"><code class="hljs objectivec"><span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 包含的文件</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#include "Bitmap.h"</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Bitmap 的构造函数和析构函数</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
Bitmap::Bitmap()
  : m_hBitmap(<span class="hljs-literal">NULL</span>), m_iWidth(<span class="hljs-number">0</span>), m_iHeight(<span class="hljs-number">0</span>)
{
}

<span class="hljs-comment">// 从一个文件中创建位图</span>
Bitmap::Bitmap(HDC hDC, LPTSTR szFileName)
  : m_hBitmap(<span class="hljs-literal">NULL</span>), m_iWidth(<span class="hljs-number">0</span>), m_iHeight(<span class="hljs-number">0</span>)
{
  Create(hDC, szFileName);
}

<span class="hljs-comment">// 从一个资源中创建位图</span>
Bitmap::Bitmap(HDC hDC, UINT uiResID, HINSTANCE hInstance)
  : m_hBitmap(<span class="hljs-literal">NULL</span>), m_iWidth(<span class="hljs-number">0</span>), m_iHeight(<span class="hljs-number">0</span>)
{
  Create(hDC, uiResID, hInstance);
}

<span class="hljs-comment">// 创建纯色的空白位图</span>
Bitmap::Bitmap(HDC hDC, <span class="hljs-keyword">int</span> iWidth, <span class="hljs-keyword">int</span> iHeight, COLORREF crColor)
  : m_hBitmap(<span class="hljs-literal">NULL</span>), m_iWidth(<span class="hljs-number">0</span>), m_iHeight(<span class="hljs-number">0</span>)
{
  Create(hDC, iWidth, iHeight, crColor);
}

Bitmap::~Bitmap()
{
  Free();
}

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Bitmap 帮助器方法，用来释放与位图有关的内存并清除位图句柄</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-keyword">void</span> Bitmap::Free()
{
  <span class="hljs-comment">// 若位图句柄有效（即存在）</span>
  <span class="hljs-keyword">if</span> (m_hBitmap != <span class="hljs-literal">NULL</span>)
  {
    <span class="hljs-comment">//删除GDI 位图图像并清除句柄</span>
    DeleteObject(m_hBitmap);
    m_hBitmap = <span class="hljs-literal">NULL</span>;
  }
}

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Bitmap 常规方法，3个Create()和Draw()</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-built_in">BOOL</span> Bitmap::Create(HDC hDC, LPTSTR szFileName)
{
  <span class="hljs-comment">// 清空以前的任何位图信息（使用于对不同的位图重复使用同一个Bitmap对象的情况）</span>
  Free();

  <span class="hljs-comment">// 打开文件</span>
  HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>,
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="hljs-literal">NULL</span>);
  <span class="hljs-comment">//检查得到的文件句柄以确保顺利打开文件</span>
  <span class="hljs-keyword">if</span> (hFile == INVALID_HANDLE_VALUE)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">// 从文件中读 位图的 文件头（文件头包含位图文件本身的信息）</span>
  BITMAPFILEHEADER  bmfHeader;
  DWORD             dwBytesRead;
  <span class="hljs-built_in">BOOL</span> bOK = ReadFile(hFile, &amp;bmfHeader, <span class="hljs-keyword">sizeof</span>(BITMAPFILEHEADER),
    &amp;dwBytesRead, <span class="hljs-literal">NULL</span>);
  <span class="hljs-comment">// 进行检查，确保正确读取</span>
  <span class="hljs-keyword">if</span> ((!bOK) || (dwBytesRead != <span class="hljs-keyword">sizeof</span>(BITMAPFILEHEADER)) ||
    (bmfHeader<span class="hljs-variable">.bfType</span> != <span class="hljs-number">0x4D42</span>))
  {
    CloseHandle(hFile);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;
  }

  BITMAPINFO* pBitmapInfo = (new BITMAPINFO);
  <span class="hljs-keyword">if</span> (pBitmapInfo != <span class="hljs-literal">NULL</span>)
  {
    <span class="hljs-comment">// 从文件中读 位图的 信息头部</span>
    bOK = ReadFile(hFile, pBitmapInfo, <span class="hljs-keyword">sizeof</span>(BITMAPINFOHEADER),
      &amp;dwBytesRead, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> ((!bOK) || (dwBytesRead != <span class="hljs-keyword">sizeof</span>(BITMAPINFOHEADER)))
    {
      CloseHandle(hFile);
      Free();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;
    }

    <span class="hljs-comment">//  存储位图的宽度和高度</span>
    m_iWidth = (<span class="hljs-keyword">int</span>)pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biWidth</span>;
    m_iHeight = (<span class="hljs-keyword">int</span>)pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biHeight</span>;

    <span class="hljs-comment">/* 计算biSizeImage填充回去，是增加的代码
  （因为无压缩BMP文件的pBitmapInfo-&gt;bmiHeader.biSizeImage 里面的值不一定是图像的真实大小,
    可能是0或者随意的值。所以需要重新计算
    */</span>
    pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biSizeImage</span> =
    m_iHeight*m_iWidth*((<span class="hljs-keyword">int</span>)pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biBitCount</span>)/<span class="hljs-number">8</span>;

    <span class="hljs-comment">// 复制图像数据，调用CreateDIBSection()以从原始位图数据中获得一个GDI 位图对象的句柄</span>
    PBYTE pBitmapBits;
    m_hBitmap = CreateDIBSection(hDC, pBitmapInfo, DIB_RGB_COLORS,
      (PVOID*)&amp;pBitmapBits, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> ((m_hBitmap != <span class="hljs-literal">NULL</span>) &amp;&amp; (pBitmapBits != <span class="hljs-literal">NULL</span>))
    {
      SetFilePointer(hFile, bmfHeader<span class="hljs-variable">.bfOffBits</span>, <span class="hljs-literal">NULL</span>, FILE_BEGIN);
      bOK = ReadFile(hFile, pBitmapBits, pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biSizeImage</span>,
        &amp;dwBytesRead, <span class="hljs-literal">NULL</span>);
      <span class="hljs-keyword">if</span> (bOK)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
    }
  }

  <span class="hljs-comment">// 读取数据的过程中发生错误时释放位图内存</span>
  Free();
  <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;
}

<span class="hljs-comment">//从一个资源中加载位图并将其创建为一个GDI 对象</span>
<span class="hljs-built_in">BOOL</span> Bitmap::Create(HDC hDC, UINT uiResID, HINSTANCE hInstance)
{
  <span class="hljs-comment">// Free any previous DIB info</span>
  Free();

  <span class="hljs-comment">// 找到位图资源</span>
  HRSRC hResInfo = FindResource(hInstance, MAKEINTRESOURCE(uiResID), RT_BITMAP);
  <span class="hljs-keyword">if</span> (hResInfo == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">// 将位图资源加载到内存中</span>
  HGLOBAL hMemBitmap = LoadResource(hInstance, hResInfo);
  <span class="hljs-keyword">if</span> (hMemBitmap == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">// 锁定资源，以便访问其原始数据</span>
  PBYTE pBitmapImage = (BYTE*)LockResource(hMemBitmap);
  <span class="hljs-keyword">if</span> (pBitmapImage == <span class="hljs-literal">NULL</span>)
  {
    FreeResource(hMemBitmap);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;
  }

  <span class="hljs-comment">// 存储位图的宽度和高度</span>
  BITMAPINFO* pBitmapInfo = (BITMAPINFO*)pBitmapImage;
  m_iWidth = (<span class="hljs-keyword">int</span>)pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biWidth</span>;
  m_iHeight = (<span class="hljs-keyword">int</span>)pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biHeight</span>;

  <span class="hljs-comment">/* 计算biSizeImage填充回去，是增加的代码
  （因为无压缩BMP文件的pBitmapInfo-&gt;bmiHeader.biSizeImage 里面的值不一定是图像的真实大小,
    可能是0或者随意的值。所以需要重新计算
  */</span>
  pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biSizeImage</span> =
   m_iHeight*m_iWidth*((<span class="hljs-keyword">int</span>)pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biBitCount</span>)/<span class="hljs-number">8</span>;

 <span class="hljs-comment">// 复制图像数据，并以此为基础使用CreateDIBSection获得一个位图句柄</span>
  PBYTE pBitmapBits;
  m_hBitmap = CreateDIBSection(hDC, pBitmapInfo, DIB_RGB_COLORS,
    (PVOID*)&amp;pBitmapBits, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> ((m_hBitmap != <span class="hljs-literal">NULL</span>) &amp;&amp; (pBitmapBits != <span class="hljs-literal">NULL</span>))
  {
    <span class="hljs-keyword">const</span> PBYTE pTempBits = pBitmapImage + pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biSize</span> +
      pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biClrUsed</span> * <span class="hljs-keyword">sizeof</span>(RGBQUAD);
    CopyMemory(pBitmapBits, pTempBits, pBitmapInfo-&gt;bmiHeader<span class="hljs-variable">.biSizeImage</span>);

    <span class="hljs-comment">// 解锁并释放位图资源</span>
    UnlockResource(hMemBitmap);
    FreeResource(hMemBitmap);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
  }

  <span class="hljs-comment">// 在发生错误时执行一些清理工作</span>
  UnlockResource(hMemBitmap);
  FreeResource(hMemBitmap);
  Free();
  <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;
}

<span class="hljs-comment">//创建纯色的空白位图并将其创建为一个GDI 对象</span>
<span class="hljs-built_in">BOOL</span> Bitmap::Create(HDC hDC, <span class="hljs-keyword">int</span> iWidth, <span class="hljs-keyword">int</span> iHeight, COLORREF crColor)
{
  <span class="hljs-comment">// 创建纯色的位图</span>
  m_hBitmap = CreateCompatibleBitmap(hDC, iWidth, iHeight);
  <span class="hljs-keyword">if</span> (m_hBitmap == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">// 设置宽度和高度</span>
  m_iWidth = iWidth;
  m_iHeight = iHeight;

  <span class="hljs-comment">// 创建一个兼容的设备环境用以包含要绘制的位图</span>
  HDC hMemDC = CreateCompatibleDC(hDC);

  <span class="hljs-comment">// 创建一个指定颜色的纯白画刷用以填充位图</span>
  HBRUSH hBrush = CreateSolidBrush(crColor);

  <span class="hljs-comment">// 将位图选入设备环境</span>
  HBITMAP hOldBitmap = (HBITMAP)SelectObject(hMemDC, m_hBitmap);

  <span class="hljs-comment">// 用纯色画刷填充位图</span>
  RECT rcBitmap = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m_iWidth, m_iHeight };
  FillRect(hMemDC, &amp;rcBitmap, hBrush);

  <span class="hljs-comment">// 清理图形对象</span>
  SelectObject(hMemDC, hOldBitmap);
  DeleteDC(hMemDC);
  DeleteObject(hBrush);

  <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
}

<span class="hljs-comment">//绘制位图</span>
<span class="hljs-keyword">void</span> Bitmap::Draw(HDC hDC, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">BOOL</span> bTrans, COLORREF crTransColor)
{
    <span class="hljs-comment">// 确保位图句柄有效</span>
  <span class="hljs-keyword">if</span> (m_hBitmap != <span class="hljs-literal">NULL</span>)
  {
    <span class="hljs-comment">// 创建一个兼容的设备环境来临时存储位图</span>
    HDC hMemDC = CreateCompatibleDC(hDC);

    <span class="hljs-comment">// 将位图选入设备环境中</span>
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(hMemDC, m_hBitmap);

    <span class="hljs-comment">// </span>
    <span class="hljs-keyword">if</span> (bTrans)
      TransparentBlt(hDC, x, y, GetWidth(), GetHeight(), hMemDC, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        GetWidth(), GetHeight(), crTransColor);
    <span class="hljs-keyword">else</span>
      BitBlt(hDC, x, y, GetWidth(), GetHeight(), hMemDC, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SRCCOPY);

    <span class="hljs-comment">// 清理临时设备环境</span>
    SelectObject(hMemDC, hOldBitmap);
    DeleteDC(hMemDC);
  }
}
</code></pre>
    <h4 id="gameenginecpp">
     GameEngine.cpp
    </h4>
    <pre class="prettyprint"><code class="hljs objectivec"><span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 包含的头文件</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-preprocessor">#include "GameEngine.h"</span>

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// 初始化静态的游戏指针</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
GameEngine *GameEngine::m_pGameEngine = <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Windows函数  </span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-keyword">int</span> WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
  PSTR szCmdLine, <span class="hljs-keyword">int</span> iCmdShow)
{
  MSG         msg;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>  iTickTrigger = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span>         iTickCount;

  <span class="hljs-keyword">if</span> (GameInitialize(hInstance)) <span class="hljs-comment">//通过调用GameInitialize()初始化游戏 </span>
  {
    <span class="hljs-comment">// 初始化游戏引擎</span>
    <span class="hljs-keyword">if</span> (!GameEngine::GetEngine()-&gt;Initialize(iCmdShow))
      <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

    <span class="hljs-comment">// 进入主消息循环 </span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">TRUE</span>)
    {
      <span class="hljs-keyword">if</span> (PeekMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PM_REMOVE))
      {
        <span class="hljs-comment">// 处理消息 </span>
        <span class="hljs-keyword">if</span> (msg<span class="hljs-variable">.message</span> == WM_QUIT)
          <span class="hljs-keyword">break</span>;
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
      }
      <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 这段代码创建游戏的计时机制</span>
      {
        <span class="hljs-comment">// 确保游戏引擎没有休眠 </span>
        <span class="hljs-keyword">if</span> (!GameEngine::GetEngine()-&gt;GetSleep())
        {
          <span class="hljs-comment">// 检查滴答计数，查看是否过了一个游戏周期 </span>
          iTickCount = GetTickCount();
          <span class="hljs-keyword">if</span> (iTickCount &gt; iTickTrigger)
          {
            iTickTrigger = iTickCount +
              GameEngine::GetEngine()-&gt;GetFrameDelay();
            HandleKeys();    <span class="hljs-comment">//键盘处理函数</span>
            GameCycle();
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)msg<span class="hljs-variable">.wParam</span>;
  }

  <span class="hljs-comment">// 结束游戏</span>
  GameEnd();

  <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
}

LRESULT CALLBACK WndProc(HWND hWindow, UINT msg, WPARAM wParam, LPARAM lParam)
{
  <span class="hljs-comment">// 将所有Windows消息传递给游戏引擎</span>
  <span class="hljs-keyword">return</span> GameEngine::GetEngine()-&gt;HandleEvent(hWindow, msg, wParam, lParam);
}

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// GameEngine的构造函数和析构函数 </span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>
GameEngine::GameEngine(HINSTANCE hInstance, LPTSTR szWindowClass,
  LPTSTR szTitle, WORD wIcon, WORD wSmallIcon, <span class="hljs-keyword">int</span> iWidth, <span class="hljs-keyword">int</span> iHeight)
{
  <span class="hljs-comment">// 设置游戏引擎的成员变量</span>
  m_pGameEngine = <span class="hljs-keyword">this</span>;
  m_hInstance = hInstance;
  m_hWindow = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">if</span> (lstrlen(szWindowClass) &gt; <span class="hljs-number">0</span>)
    lstrcpy(m_szWindowClass, szWindowClass);
  <span class="hljs-keyword">if</span> (lstrlen(szTitle) &gt; <span class="hljs-number">0</span>)
    lstrcpy(m_szTitle, szTitle);
  m_wIcon = wIcon;
  m_wSmallIcon = wSmallIcon;
  m_iWidth = iWidth;
  m_iHeight = iHeight;
  m_iFrameDelay = <span class="hljs-number">50</span>;   <span class="hljs-comment">// 默认为20帧每秒（50ms/1000=20帧/秒）</span>
  m_bSleep = <span class="hljs-literal">TRUE</span>;
}

GameEngine::~GameEngine()
{
}

<span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-comment">// Game Engine 常规方法</span>
<span class="hljs-comment">//-----------------------------------------------------------------</span>

<span class="hljs-comment">//Initialize方法处理一些通常在WinMain()中执行的杂乱方法</span>
<span class="hljs-built_in">BOOL</span> GameEngine::Initialize(<span class="hljs-keyword">int</span> iCmdShow)
{
  WNDCLASSEX    wndclass;

  <span class="hljs-comment">// 创建主窗口的窗口类</span>
  wndclass<span class="hljs-variable">.cbSize</span>         = <span class="hljs-keyword">sizeof</span>(wndclass);
  wndclass<span class="hljs-variable">.style</span>          = CS_HREDRAW | CS_VREDRAW;
  wndclass<span class="hljs-variable">.lpfnWndProc</span>    = WndProc;
  wndclass<span class="hljs-variable">.cbClsExtra</span>     = <span class="hljs-number">0</span>;
  wndclass<span class="hljs-variable">.cbWndExtra</span>     = <span class="hljs-number">0</span>;
  wndclass<span class="hljs-variable">.hInstance</span>      = m_hInstance;
  wndclass<span class="hljs-variable">.hIcon</span>          = LoadIcon(m_hInstance,
    MAKEINTRESOURCE(GetIcon()));
  wndclass<span class="hljs-variable">.hIconSm</span>        = LoadIcon(m_hInstance,
    MAKEINTRESOURCE(GetSmallIcon()));
  wndclass<span class="hljs-variable">.hCursor</span>        = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);
  wndclass<span class="hljs-variable">.hbrBackground</span>  = (HBRUSH)(COLOR_WINDOW + <span class="hljs-number">1</span>);
  wndclass<span class="hljs-variable">.lpszMenuName</span>   = <span class="hljs-literal">NULL</span>;
  wndclass<span class="hljs-variable">.lpszClassName</span>  = m_szWindowClass;

  <span class="hljs-comment">// 注册窗口类</span>
  <span class="hljs-keyword">if</span> (!RegisterClassEx(&amp;wndclass))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">/* 根据游戏大小计算窗口大小和位置 （这段代码允许确定实际游戏屏幕的确切大小，
  这个大小与整个应用程序窗口的大小不同） */</span>
  <span class="hljs-keyword">int</span> iWindowWidth = m_iWidth + GetSystemMetrics(SM_CXFIXEDFRAME) * <span class="hljs-number">2</span>,
      iWindowHeight = m_iHeight + GetSystemMetrics(SM_CYFIXEDFRAME) * <span class="hljs-number">2</span> +
        GetSystemMetrics(SM_CYCAPTION);
  <span class="hljs-keyword">if</span> (wndclass<span class="hljs-variable">.lpszMenuName</span> != <span class="hljs-literal">NULL</span>)
    iWindowHeight += GetSystemMetrics(SM_CYMENU);
  <span class="hljs-keyword">int</span> iXWindowPos = (GetSystemMetrics(SM_CXSCREEN) - iWindowWidth) / <span class="hljs-number">2</span>,
      iYWindowPos = (GetSystemMetrics(SM_CYSCREEN) - iWindowHeight) / <span class="hljs-number">2</span>;

  <span class="hljs-comment">// 创建窗口 </span>
  m_hWindow = CreateWindow(m_szWindowClass, m_szTitle, WS_POPUPWINDOW |
    WS_CAPTION | WS_MINIMIZEBOX, iXWindowPos, iYWindowPos, iWindowWidth,
    iWindowHeight, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, m_hInstance, <span class="hljs-literal">NULL</span>);
  <span class="hljs-keyword">if</span> (!m_hWindow)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;

  <span class="hljs-comment">// 显示和更新窗口 </span>
  ShowWindow(m_hWindow, iCmdShow);
  UpdateWindow(m_hWindow);

  <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;
}

<span class="hljs-comment">// 接受并处理通常在WinProc()中处理的消息</span>
LRESULT GameEngine::HandleEvent(HWND hWindow, UINT msg, WPARAM wParam, LPARAM lParam)
{
  <span class="hljs-comment">// 将Windows消息传递给游戏引擎成员函数 </span>
  <span class="hljs-keyword">switch</span> (msg)
  {
    <span class="hljs-keyword">case</span> WM_CREATE:
      <span class="hljs-comment">// 设置游戏窗口并开始游戏 </span>
      SetWindow(hWindow);
      GameStart(hWindow);    <span class="hljs-comment">//响应WM_CREATE消息，开始游戏</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_SETFOCUS:
      <span class="hljs-comment">// 激活游戏并更新休眠状态 </span>
      GameActivate(hWindow);
      SetSleep(<span class="hljs-literal">FALSE</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_KILLFOCUS:
      <span class="hljs-comment">// 停用游戏并更新休眠状态 </span>
      GameDeactivate(hWindow);
      SetSleep(<span class="hljs-literal">TRUE</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_PAINT:
      HDC         hDC;
      PAINTSTRUCT ps;
      hDC = BeginPaint(hWindow, &amp;ps);

      <span class="hljs-comment">// 绘制游戏</span>
      GamePaint(hDC);

      EndPaint(hWindow, &amp;ps);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_LBUTTONDOWN:
      <span class="hljs-comment">// 处理按下鼠标左键的事件</span>
      MouseButtonDown(LOWORD(lParam), HIWORD(lParam), <span class="hljs-literal">TRUE</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_LBUTTONUP:
      <span class="hljs-comment">// 处理释放鼠标左键的事件</span>
      MouseButtonUp(LOWORD(lParam), HIWORD(lParam), <span class="hljs-literal">TRUE</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_RBUTTONDOWN:
      <span class="hljs-comment">// 处理按下鼠标右键的事件</span>
      MouseButtonDown(LOWORD(lParam), HIWORD(lParam), <span class="hljs-literal">FALSE</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_RBUTTONUP:
      <span class="hljs-comment">// 处理按下鼠标左键的事件</span>
      MouseButtonUp(LOWORD(lParam), HIWORD(lParam), <span class="hljs-literal">FALSE</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_MOUSEMOVE:
      <span class="hljs-comment">// 处理鼠标移动的事件</span>
      MouseMove(LOWORD(lParam), HIWORD(lParam));
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> WM_DESTROY:
      <span class="hljs-comment">// 结束游戏并退出应用程序 </span>
      GameEnd();
      PostQuitMessage(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> DefWindowProc(hWindow, msg, wParam, lParam);
}

<span class="hljs-keyword">void</span> GameEngine::ErrorQuit(LPTSTR szErrorMsg)
{
  MessageBox(GetWindow(), szErrorMsg, TEXT(<span class="hljs-string">"Critical Error"</span>), MB_OK | MB_ICONERROR);
  PostQuitMessage(<span class="hljs-number">0</span>);
}
</code></pre>
    <h2 id="源代码-下载">
     源代码 下载
    </h2>
    <p>
     <a href="http://pan.baidu.com/s/1ge2Vzr1" rel="nofollow noopener noreferrer" target="_blank">
      http://pan.baidu.com/s/1ge2Vzr1
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874:7470733a2f2f626c6f672e6373646e2e6e65742f4a7572626f:2f61727469636c652f64657461696c732f3733383634333732" class_="artid" style="display:none">
 </p>
</div>


