---
layout: post
title: "分布式-ID-设计方案"
date: 2025-03-05 21:07:53 +0800
description: "分布式ID设计方案在分布式系统中至关重要，它必须满足全局唯一性、可扩展性、排序性（有时）、避免碰撞、去中心化、可用性和紧凑性等多个要求。"
keywords: "分布式 ID 设计方案"
categories: ['未分类']
tags: ['分布式']
artid: "146053082"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053082
    alt: "分布式-ID-设计方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053082
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053082
cover: https://bing.ee123.net/img/rand?artid=146053082
image: https://bing.ee123.net/img/rand?artid=146053082
img: https://bing.ee123.net/img/rand?artid=146053082
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     分布式 ID 设计方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="">
     分布式ID设计方案在分布式系统中至关重要，它必须满足全局唯一性、可扩展性、排序性（有时）、避免碰撞、去中心化、可用性和紧凑性等多个要求。以下是一些常见的分布式ID设计方案：
    </p>
    <h4>
     一、UUID（通用唯一标识符）
    </h4>
    <ul>
     <li>
      <p id="">
       <strong>
        核心思想
       </strong>
       ：UUID是基于时间戳、节点（通常是MAC地址）等信息生成的128位唯一标识符。
      </p>
     </li>
     <li>
      <p id="">
       <strong>
        优点
       </strong>
       ：
      </p>
      <ul>
       <li>
        本地生成，不依赖于网络，性能高。
       </li>
       <li>
        全局唯一，碰撞概率极低。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        长度较长（16字节/128位），不易存储。
       </li>
       <li>
        无序性可能导致数据库索引效率低下。
       </li>
       <li>
        基于MAC地址生成可能泄露用户位置信息。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        适用场景
       </strong>
       ：适用于需要全局唯一标识符但不要求有序性的场景，如日志记录、临时文件命名等。
      </p>
     </li>
    </ul>
    <h4>
     二、数据库自增ID
    </h4>
    <ul>
     <li>
      <p id="">
       <strong>
        核心思想
       </strong>
       ：在分布式环境中，可以使用数据库的自增ID功能来生成唯一ID。但为了避免单点故障和性能瓶颈，通常需要在多台机器上部署数据库，并为每台机器设置不同的初始值和步长。
      </p>
     </li>
     <li>
      <p id="">
       <strong>
        优点
       </strong>
       ：实现简单，易于理解。
      </p>
     </li>
     <li>
      <p id="">
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        数据库压力较大，每次获取ID都需要访问数据库。
       </li>
       <li>
        扩容时步长和初始值需要重新设置，维护成本高。
       </li>
       <li>
        ID虽然趋势递增，但无法保证严格递增。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        适用场景
       </strong>
       ：适用于分库分表后低并发、低负载的场景。
      </p>
     </li>
    </ul>
    <h4>
     三、Redis自增机制
    </h4>
    <ul>
     <li>
      <p id="">
       <strong>
        核心思想
       </strong>
       ：利用Redis的单线程特性和原子操作来保证ID的唯一性和有序性。可以通过集群部署来提高并发性能，但需要注意步长和扩容问题。
      </p>
     </li>
     <li>
      <p id="">
       <strong>
        优点
       </strong>
       ：
      </p>
      <ul>
       <li>
        性能较高，可以满足高并发需求。
       </li>
       <li>
        有序性较好，有利于数据库索引。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        依赖于Redis组件，增加了系统复杂性。
       </li>
       <li>
        扩容时步长改变，可能导致ID不连续。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        适用场景
       </strong>
       ：适用于需要高并发、有序ID的场景，但需要注意扩容问题。
      </p>
     </li>
    </ul>
    <h4>
     四、Snowflake算法
    </h4>
    <ul>
     <li>
      <p id="">
       <strong>
        核心思想
       </strong>
       ：Twitter开源的分布式ID生成算法，将64位分为时间戳、机器ID和序列号三部分。通过时间戳保证趋势递增，通过机器ID区分不同机器，通过序列号区分同一毫秒内的不同ID。
      </p>
     </li>
     <li>
      <p id="">
       <strong>
        优点
       </strong>
       ：
      </p>
      <ul>
       <li>
        高性能，高并发，分布式，可伸缩。
       </li>
       <li>
        ID趋势递增，有利于数据库索引。
       </li>
       <li>
        不依赖于第三方服务，可用性高。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        强依赖机器时钟，时钟回拨可能导致ID重复。
       </li>
       <li>
        需要自定义实现，增加了开发成本。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        适用场景
       </strong>
       ：适用于中大型公司、有高并发生成唯一ID的场景。可以通过自研加入时钟回拨解决方案、多机房方案等，满足生产级需求。
      </p>
     </li>
    </ul>
    <h4>
     五、分段步长模式
    </h4>
    <ul>
     <li>
      <p id="">
       <strong>
        核心思想
       </strong>
       ：从数据库获取一个号段范围的ID（如[1,1000]），加载到内存中生成自增ID。当ID用完后再去数据库获取新的号段。
      </p>
     </li>
     <li>
      <p id="">
       <strong>
        优点
       </strong>
       ：
      </p>
      <ul>
       <li>
        减少了数据库访问次数，提高了性能。
       </li>
       <li>
        ID趋势递增，有利于数据库索引。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        依赖于数据库实现，数据库宕机可能影响ID生成。
       </li>
       <li>
        扩容时需要注意号段的重叠和浪费问题。
       </li>
      </ul>
     </li>
     <li>
      <p id="">
       <strong>
        适用场景
       </strong>
       ：适用于需要高性能、趋势递增ID的场景，但需要注意数据库的稳定性和扩容问题。
      </p>
     </li>
    </ul>
    <h4>
     六、其他方案
    </h4>
    <p id="">
     除了上述方案外，还有一些其他方案如百度Uidgenerator、美团Leaf、滴滴TinyID等，它们都是在Snowflake算法的基础上进行改进和优化，以满足不同场景的需求。这些方案通常具有更高的性能和更灵活的配置选项，但也需要更多的开发和维护工作。
    </p>
    <h4>
     七、选择方案的考虑因素
    </h4>
    <p id="">
     在选择分布式ID设计方案时，需要考虑以下因素：
    </p>
    <ul>
     <li>
      <strong>
       吞吐量需求
      </strong>
      ：如果系统需要每秒生成数百万个ID，Snowflake或Redis-based方案可能更合适。
     </li>
     <li>
      <strong>
       有序性需求
      </strong>
      ：如果ID需要按时间排序，可以考虑Snowflake或KSUID等方案。
     </li>
     <li>
      <strong>
       存储限制
      </strong>
      ：如果存储大小至关重要，可以选择更紧凑的格式，如Snowflake ID。
     </li>
     <li>
      <strong>
       元数据需求
      </strong>
      ：如果需要在ID中包含元数据（如时间戳或机器ID），可以选择Snowflake ID或自定义哈希方案。
     </li>
     <li>
      <strong>
       系统复杂性
      </strong>
      ：如果希望降低系统复杂性，可以选择UUID或数据库自增ID等方案。但需要注意这些方案可能带来的性能瓶颈或扩容问题。
     </li>
    </ul>
    <p id="">
     综上所述，分布式ID设计方案的选择需要根据具体场景和需求进行权衡和取舍。在实际应用中，可以结合多种方案的优势来构建满足自身需求的分布式ID生成系统。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f6375697368756a69616e5f323030332f:61727469636c652f64657461696c732f313436303533303832" class_="artid" style="display:none">
 </p>
</div>


