---
layout: post
title: "TCP并发服务器"
date: 2025-03-10 12:00:56 +0800
description: "服务器在同一时刻只能响应一个客户端的需求。：服务器在同一时刻可以响应多个客户端的需求。"
keywords: "TCP并发服务器"
categories: ['未分类']
tags: ['运维', '服务器']
artid: "146149445"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146149445
    alt: "TCP并发服务器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146149445
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146149445
cover: https://bing.ee123.net/img/rand?artid=146149445
image: https://bing.ee123.net/img/rand?artid=146149445
img: https://bing.ee123.net/img/rand?artid=146149445
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     TCP并发服务器
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      单循环服务器
     </strong>
     ：服务器在同一时刻只能响应一个客户端的需求。
    </p>
    <p>
     <strong>
      并发服务器
     </strong>
     ：服务器在同一时刻可以响应多个客户端的需求。
    </p>
    <h2>
     构建TCP服务器的方法：
    </h2>
    <p>
     <img alt="" height="396" src="https://i-blog.csdnimg.cn/direct/f86893ca280e43e79c3724104ab9d161.png" width="772"/>
    </p>
    <p>
     <strong>
      IO多路复用的函数接口
     </strong>
     [select()  poll() epoll()]
    </p>
    <h3>
     1.多进程实现TCP并发服务器
    </h3>
    <pre><code>#include &lt;stdio.h&gt;
#include "head.h"

#define LISTEN_CLI__MAX_CNT 1024

int init_tcp_ser(const char *ip, unsigned short port)
{
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd &lt; 0)
	{
		perror("fail socket");
		return -1;
	}
	
	struct sockaddr_in ser;
	ser.sin_family = AF_INET;
	ser.sin_port = htons(port);
	ser.sin_addr.s_addr = inet_addr(ip);
	int ret = bind(sockfd, (struct sockaddr *)&amp;ser, sizeof(ser));
	if (ret &lt; 0)
	{
		perror("fail bind");
		return -1;
	}
	
	ret = listen(sockfd, LISTEN_CLI__MAX_CNT);
	if (ret &lt; 0)
	{
		perror("fail listen");
		return -1;
	}

	return sockfd;
}

void handler(int signum)
{
	wait(NULL);
}

int main(int argc, const char *argv[])
{
	struct sockaddr_in cli;
	
	socklen_t clilen = sizeof(cli);
	
	signal(SIGCHLD, handler);
	int sockfd = init_tcp_ser("192.168.1.179", 50000);
	if (sockfd &lt; 0)
	{
		return -1;
	}

	while (1)
	{
	
		int connfd = accept(sockfd, (struct sockaddr *)&amp;cli, &amp;clilen);
		if (connfd &lt; 0)
		{
			perror("fail accept");
			return -1;
		}
		pid_t pid = fork();
		if (pid &gt; 0)
		{
		}
		else if (0 == pid)
		{
			char buff[1024] = {0};
			while (1)
			{
				memset(buff, 0, sizeof(buff));
				size_t size = recv(connfd, buff, sizeof(buff), 0);
				if (size &lt; 0)
				{
					perror("fail recv");
					exit(1);
				}
				else if (0 == size) // closed
				{
					break;
				}
				printf("[%s : %d][%ld] %s\n", inet_ntoa(cli.sin_addr), ntohs(cli.sin_port), size, buff);
				strcat(buff, "---&gt;ok");
				size = send(connfd, buff, strlen(buff), 0);
				if (size &lt; 0)
				{
					perror("fail send");
					exit(1);
				}
			}
			exit(0);
		}
		else
		{
			perror("fail fork");
			return -1;
		}
	}

	return 0;
}</code></pre>
    <h3>
     2.多线程实现TCP并发服务器
    </h3>
    <pre><code>#include &lt;stdio.h&gt;
#include "head.h"

#define LISTEN_CLI__MAX_CNT 1024

int init_tcp_ser(const char *ip, unsigned short port)
{
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd &lt; 0)
	{
		perror("fail socket");
		return -1;
	}
	
	struct sockaddr_in ser;
	ser.sin_family = AF_INET;
	ser.sin_port = htons(port);
	ser.sin_addr.s_addr = inet_addr(ip);
	int ret = bind(sockfd, (struct sockaddr *)&amp;ser, sizeof(ser));
	if (ret &lt; 0)
	{
		perror("fail bind");
		return -1;
	}
	
	ret = listen(sockfd, LISTEN_CLI__MAX_CNT);
	if (ret &lt; 0)
	{
		perror("fail listen");
		return -1;
	}

	return sockfd;
}


void *do_communicate(void *arg)
{
	char buff[1024] = {0};
	int connfd = *(int *)arg;
	while (1)
	{
		memset(buff, 0, sizeof(buff));
		size_t size = recv(connfd, buff, sizeof(buff), 0);
		if (size &lt; 0)
		{
			perror("fail recv");
			return NULL;
		}
		else if (0 == size)
		{
			break;
		}
		printf("%s\n", buff);
		strcat(buff, "----&gt;ok");
		size = send(connfd, buff, strlen(buff), 0);
		if (size &lt; 0)
		{
			perror("fail send");
			return NULL;
		}
	}

	return NULL;
}


int main(int argc, const char *argv[])
{
	struct sockaddr_in cli;
	pthread_t tid;

	socklen_t clilen = sizeof(cli);
	
	int sockfd = init_tcp_ser("192.168.1.179", 50000);
	if (sockfd &lt; 0)
	{
		return -1;
	}

	while (1)
	{
	
		int connfd = accept(sockfd, (struct sockaddr *)&amp;cli, &amp;clilen);
		if (connfd &lt; 0)
		{
			perror("fail accept");
			return -1;
		}
		
		pthread_create(&amp;tid, NULL, do_communicate, &amp;connfd);
		pthread_detach(tid);
	}

	return 0;
}</code></pre>
    <h3>
     3.IO多路复用
    </h3>
    <p>
     <img alt="" height="318" src="https://i-blog.csdnimg.cn/direct/d7371a379a494408bccff2d4830a0f3e.png" width="812"/>
    </p>
    <p>
     <img alt="" height="637" src="https://i-blog.csdnimg.cn/direct/b8586cb2a4694989aa95ae9ccebc50a1.png" width="1720"/>
    </p>
    <h4>
     方法：
     <img alt="" height="178" src="https://i-blog.csdnimg.cn/direct/4d26dc1b71b34a758c43335f3eeb215c.png" width="640"/>
    </h4>
    <h2>
     select(),poll(),epoll()函数接口的优缺点
    </h2>
    <p class="img-center">
     <img alt="" height="661" src="https://i-blog.csdnimg.cn/direct/dad62adaf20e4c15b244a5c63019f4a0.png" width="1155"/>
    </p>
    <h4>
     函数接口： select()
    </h4>
    <blockquote>
     <p>
      <img alt="" height="542" src="https://i-blog.csdnimg.cn/direct/49e6d020b9914b24a42cd710a6800bac.png" width="778"/>
     </p>
    </blockquote>
    <hr/>
    <blockquote>
     <p>
      void
      <strong>
       FD_CLR
      </strong>
      (int fd, fd_set *set);
      <br/>
      将fd从文件描述符集合中清除
      <br/>
      <br/>
      int
      <strong>
       FD_ISSET
      </strong>
      (int fd, fd_set *set);
      <br/>
      判断文件描述符fd是否仍在文件描述符集合中
      <br/>
      <br/>
      void
      <strong>
       FD_SET
      </strong>
      (int fd, fd_set *set);
      <br/>
      将fd加入文件描述符集合中
      <br/>
      <br/>
      void
      <strong>
       FD_ZERO
      </strong>
      (fd_set *set);
      <br/>
      文件描述符集合清0
     </p>
    </blockquote>
    <h4>
     具体代码实现 ：用select实现数据的接受(并发实现从管道读数据和从终端读数据)
    </h4>
    <pre><code>#include &lt;stdio.h&gt;
#include "head.h"

#define LISTEN_CLI__MAX_CNT 1024

int init_tcp_ser(const char *ip, unsigned short port)
{
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd &lt; 0)
	{
		perror("fail socket");
		return -1;
	}
	
	struct sockaddr_in ser;
	ser.sin_family = AF_INET;
	ser.sin_port = htons(port);
	ser.sin_addr.s_addr = inet_addr(ip);
	int ret = bind(sockfd, (struct sockaddr *)&amp;ser, sizeof(ser));
	if (ret &lt; 0)
	{
		perror("fail bind");
		return -1;
	}
	
	ret = listen(sockfd, LISTEN_CLI__MAX_CNT);
	if (ret &lt; 0)
	{
		perror("fail listen");
		return -1;
	}

	return sockfd;
}



int main(int argc, const char *argv[])
{
	struct sockaddr_in cli;
	pthread_t tid;
	int maxfd = -1;
	char buff[1024] = {0};

	socklen_t clilen = sizeof(cli);
	
	int sockfd = init_tcp_ser("192.168.1.158", 50000);
	if (sockfd &lt; 0)
	{
		return -1;
	}
	
	fd_set tmpfds;
	fd_set rdfds;
	FD_ZERO(&amp;rdfds);

	FD_SET(sockfd, &amp;rdfds);
	maxfd = maxfd &gt; sockfd ? maxfd : sockfd;

	
	while (1)
	{
		tmpfds = rdfds;
		int cnt = select(maxfd+1, &amp;tmpfds, NULL, NULL, NULL);
		if (cnt &lt; 0)
		{
			perror("fail select");
			return -1;
		}

		for (int i = 0; i &lt;= maxfd; i++)
		{
			if (FD_ISSET(i, &amp;tmpfds))
			{
				if (i == sockfd)
				{
					int connfd = accept(sockfd, (struct sockaddr *)&amp;cli, &amp;clilen);
					if (connfd &lt; 0)
					{
						perror("fail accept");
						continue;
					}
					FD_SET(connfd, &amp;rdfds);
					maxfd = maxfd &gt; connfd ? maxfd : connfd;

					printf("[%s : %d] online\n", inet_ntoa(cli.sin_addr), ntohs(cli.sin_port));
				}
				else
				{
					//connfd
					memset(buff, 0, sizeof(buff));
					ssize_t size = recv(i, buff, sizeof(buff), 0);
					if (size &lt; 0)
					{
						perror("fail recv");
						FD_CLR(i, &amp;rdfds);
						close(i);
						continue;
					}
					else if (0 == size)
					{
						FD_CLR(i, &amp;rdfds);
						close(i);
						continue;	
					}
					printf("%s\n", buff);
					strcat(buff, "----ok");
					size = send(i, buff, strlen(buff), 0);
					if (size &lt; 0)
					{
						perror("fail send");
						FD_CLR(i, &amp;rdfds);
						close(i);
						continue;
						
					}
				
				}
			}
		
		}

	
	}

	return 0;
}</code></pre>
    <p>
    </p>
    <h4>
     select()函数接口的不足处：
    </h4>
    <p>
     <img alt="" height="166" src="https://i-blog.csdnimg.cn/direct/1dea7d8a0d924d0f83154f5912029814.png" width="1150"/>
    </p>
    <h3>
     函数接口：poll();
    </h3>
    <blockquote>
     <p>
      <strong>
       poll
      </strong>
      <br/>
      int
      <strong>
       poll(
      </strong>
      struct pollfd *fds, nfds_t nfds, int timeout);
      <br/>
      <strong>
       功能:
      </strong>
      <br/>
      监听文件描述符集合中的事件
      <br/>
      <strong>
       参数:
      </strong>
      <br/>
      <strong>
       fds
      </strong>
      :文件描述符集合事件数组首地址
      <br/>
      <strong>
       nfds
      </strong>
      :事件个数
      <br/>
      <strong>
       timeout
      </strong>
      :超时时间
      <br/>
      <strong>
       返回值:
      </strong>
      <br/>
      成功返回产生事件的文件描述符个数
      <br/>
      失败返回-1
      <br/>
      超时时间到达仍没有产生事件返回0
     </p>
     <p>
      <strong>
       结构体:
      </strong>
      <br/>
      struct
      <strong>
       pollfd
      </strong>
      {
      <!-- -->
      <br/>
      int   fd;         /* file descriptor */
      <br/>
      short events;     /* requested events */
      <br/>
      short revents;    /* returned events */
      <br/>
      };
      <br/>
     </p>
    </blockquote>
    <h3>
     函数接口epoll();
    </h3>
    <p>
     <strong>
      epoll模型
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       epoll模型：
      </strong>
      <br/>
      1
      <strong>
       ）epoll_create
      </strong>
      创建epoll文件描述符集合
      <br/>
      2）
      <strong>
       epoll_ctl
      </strong>
      添加关注的文件描述符
      <br/>
      3）
      <strong>
       epoll_wait
      </strong>
      监控io事件
      <br/>
      4）
      <strong>
       epoll_ctl
      </strong>
      从事件集合中删除完成的文件描述符
     </p>
    </blockquote>
    <p>
     <strong>
      epoll_create()
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       epoll_create
      </strong>
      <br/>
      int
      <strong>
       epoll_create
      </strong>
      (int size);
      <br/>
      <strong>
       功能:
      </strong>
      <br/>
      创建一个监听事件表(内核中)
      <br/>
      <strong>
       参数:
      </strong>
      <br/>
      <strong>
       size:
      </strong>
      监听事件最大个数
      <br/>
      <strong>
       返回值:
      </strong>
      <br/>
      <strong>
       成功
      </strong>
      返回非负值：表示epoll事件表对象（句柄）
      <br/>
      <strong>
       失败
      </strong>
      返回-1
     </p>
    </blockquote>
    <p>
     <strong>
      epoll_ctl()
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       epoll_ctl
      </strong>
      <br/>
      int
      <strong>
       epoll_ctl
      </strong>
      (int epfd, int op, int fd, struct epoll_event *event);
      <br/>
      <strong>
       功能:
      </strong>
      <br/>
      在监听事件表中新增一个事件
      <br/>
      <strong>
       参数:
      </strong>
      <br/>
      <strong>
       epfd:
      </strong>
      事件表文件描述符
      <br/>
      <strong>
       op
      </strong>
     </p>
     <p>
      <strong>
      </strong>
      EPOLL_CTL_ADD
      <strong>
       新增事件
      </strong>
      <br/>
      EPOLL_CTL_MOD
      <strong>
       修改事件
      </strong>
      <br/>
      EPOLL_CTL_DEL
      <strong>
       删除事件
      </strong>
      <br/>
      <strong>
       fd
      </strong>
      :文件描述符
      <br/>
      <strong>
       events:
      </strong>
      事件相关结构体
      <br/>
      <strong>
       返回值:
      </strong>
      <br/>
      成功返回0
      <br/>
      失败返回-1
      <br/>
      <strong>
       结构体说明
      </strong>
      <br/>
      typedef union
      <strong>
       epoll_data
      </strong>
      {
      <!-- -->
      <br/>
      void        *ptr;
      <br/>
      int          fd;
      <br/>
      uint32_t     u32;
      <br/>
      uint64_t     u64;
      <br/>
      }
      <strong>
       epoll_data_t;
      </strong>
     </p>
     <p>
      struct
      <strong>
       epoll_event
      </strong>
      {
      <!-- -->
      <br/>
      uint32_t
      <strong>
       events
      </strong>
      ;      /* Epoll events */
      <br/>
      epoll_data_t
      <strong>
       data
      </strong>
      ;        /* User data variable */
      <br/>
      };
     </p>
     <p>
      <strong>
       events:
      </strong>
      <br/>
      EPOLLIN        读事件
      <br/>
      EPOLLOUT    写事件
      <br/>
      EPOLLET        边沿触发
      <br/>
      LT                    水平触发
     </p>
    </blockquote>
    <h4>
     用epoll()实现并发的从终端与管道文件中读取数据
    </h4>
    <pre><code class="hljs">#include "../head.h"

#define EPOLL_FD_MAX 2

int epoll_fd_add(int epfds, int fd, uint32_t events)
{
	struct epoll_event ev;
	ev.events = events;
	ev.data.fd = fd;
	int ret = epoll_ctl(epfds, EPOLL_CTL_ADD, fd, &amp;ev);
	if (ret &lt; 0)
	{
		perror("fail epoll_ctl add");
		return -1;
	}
	
	return 0;
}

int main(int argc, const char *argv[])
{
	char buff[1024] = {0};

	//保存epoll_wait返回的到达事件的结果
	struct epoll_event evs[EPOLL_FD_MAX];

	mkfifo("./myfifo", 0664);
	
	int fifofd = open("./myfifo", O_RDONLY);
	if (fifofd &lt; 0)
	{
		perror("fail open fifo");
		return -1;
	}
	
	//1 创建文件描述符集合
	int epfds = epoll_create(EPOLL_FD_MAX);
	if (epfds &lt; 0)
	{
		perror("fail epoll_create");
		return -1;
	}
	
	//2 添加关注的文件描述符
	
	epoll_fd_add(epfds, 0, EPOLLIN);
	epoll_fd_add(epfds, fifofd, EPOLLIN);

	//3. 使用epoll_wait开始监测
	while (1)
	{
		int cnt = epoll_wait(epfds, evs, EPOLL_FD_MAX, -1);
		if (cnt &lt; 0)
		{
			perror("fail epoll_wait");
			return -1;
		}
		for (int i = 0; i &lt; cnt; i++)
		{
			if (0 == evs[i].data.fd)
			{
				fgets(buff, sizeof(buff), stdin);
				printf("STDIN: %s\n", buff);

			}
			else if (fifofd == evs[i].data.fd)
			{
				memset(buff, 0, sizeof(buff));
				read(fifofd, buff, sizeof(buff));
				printf("FIFO: %s\n", buff);

			}
		}

	}
	close(fifofd);
	return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313332323536322f:61727469636c652f64657461696c732f313436313439343435" class_="artid" style="display:none">
 </p>
</div>


