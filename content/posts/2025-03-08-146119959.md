---
layout: post
title: "Unity开发CanvasGroup组件介绍和应用"
date: 2025-03-08 23:23:21 +0800
description: "1、常用属性介绍2、CanvasGroup的alpha和UI自身的alpha的异同3、CanvasGroup的alpha和UI的visible的异同4、CanvasGroup的blocksRaycasts和interactable之间的异同，及其应用"
keywords: "Unity开发——CanvasGroup组件介绍和应用"
categories: ['编程开发', '功能方法', 'Unity']
tags: ['功能方法', 'Unity', 'C']
artid: "146119959"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146119959
    alt: "Unity开发CanvasGroup组件介绍和应用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146119959
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146119959
cover: https://bing.ee123.net/img/rand?artid=146119959
image: https://bing.ee123.net/img/rand?artid=146119959
img: https://bing.ee123.net/img/rand?artid=146119959
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity开发——CanvasGroup组件介绍和应用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      CanvasGroup是Unity中用于控制UI的透明度、交互性和渲染顺序的组件。
     </strong>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/966ae095b12b4ff3801f293277b4267a.png"/>
    </p>
    <h4>
     一、常用属性的解释
    </h4>
    <h5>
     1、alpha
     <strong>
      ：
     </strong>
     控制UI的透明度
    </h5>
    <p>
     类型：float，0.0 ~1.0，
    </p>
    <p>
     其中 0.0 完全透明，1.0 完全不透明。
    </p>
    <p>
     通过调整alpha值可以实现UI的淡入淡出效果，可以参考本人的另一篇文章：
    </p>
    <p>
     <a class="link-info" href="https://blog.csdn.net/weixin_43908355/article/details/145816771" title="Unity功能——设置提示面板的显示与掩藏">
      Unity功能——设置提示面板的显示与掩藏
     </a>
    </p>
    <h5>
     2、blocksRaycasts：控制UI是否阻挡射线（Raycasts）
    </h5>
    <p>
     （1）类型：bool，true/false，
    </p>
    <p>
     （2）true时会阻挡射线，false时不会阻挡射线。
    </p>
    <p>
     （3）用户不对该UI后面的UI进行射线检测，可将值设置为true；
    </p>
    <h5>
     3、interactable：控制UI是否可交互（如点击、拖动等）
    </h5>
    <p>
     （1）类型：bool，true/false，
    </p>
    <p>
     （2）true时会响应用户输入，false时将忽略用户输入。
    </p>
    <p>
     （3）用户不对该UI进行交互，可将值设置为false；
    </p>
    <h5>
     4、ignoreParentGroups：控制UI是否忽略父级CanvasGroup的设置
    </h5>
    <p>
     （1）类型：bool，true/false，
    </p>
    <p>
     （2）true时将忽略其父级CanvasGroup的alpha和interactable设置，false时会受到父级CanvasGroup的设置影响。
    </p>
    <p>
     （3）用户要独立控制UI的透明度和交互性，可将值设置为true；
    </p>
    <h4>
     二、组件的alpha属性和UI的alpha属性的异同
    </h4>
    <h5>
     1、相同点：
    </h5>
    <p>
     在视觉上是一样的，都可控制UI能不能被用户看到，也仅是控制物体的不透明度；
    </p>
    <p>
     在交互上，都不会影响UI的交互性，都可正常进行交互事件；
    </p>
    <p>
     在射线检测上，也都不会改变UI对射线的阻挡特性；
    </p>
    <h5>
     2、不同点：
    </h5>
    <h6>
     （1）作用范围不同
    </h6>
    <p>
     直接设置 UI 元素的alpha值，只会影响该单个UI元素的透明度，其父子元素不会受到影响。
    </p>
    <p>
     而CanvasGroup组件可以控制其所在UI及其所有子对象的透明度。组件所在的UI对象以及它包含的所有子物体（如按钮、文本框等）都会统一改变透明度。
    </p>
    <h6>
     （2）性能影响不同
    </h6>
    <p>
     直接设置单个UI的alpha值，性能开销相对较小，因为只涉及到对单个对象的属性修改。
    </p>
    <p>
     当使用CanvasGroup时，会影响多个子对象，Unity需要处理更多的渲染和交互状态更新，
    </p>
    <p>
     性能开销相对较大，尤其是在子对象数量较多的情况下。不过，在大多数正常场景下，这种开销通常是可以接受的。
    </p>
    <h4>
     三、组件的alpha属性和UI的visible属性的异同
    </h4>
    <h5>
     1、相同点：
    </h5>
    <p>
     在视觉上是一样的，都可控制UI能不能被用户看到；
    </p>
    <h5>
     2、不同点：
    </h5>
    <h6>
     <span style="color:#494949">
      （1）直接设置UI的visible值为false后，UI将完全不响应任何事件；
     </span>
    </h6>
    <p>
     因为visible为false，背包及其内部子物体都不会被渲染出来，更不会被交互；
    </p>
    <h6>
     <span style="color:#494949">
      （2）而通过设置CanvasGroup组件的alpha值，
     </span>
     <span style="color:#494949">
      只是影响视觉效果，不影响事件交互。
     </span>
    </h6>
    <p>
     <span style="color:#494949">
      故
     </span>
     即使aplha值为0，对UI及其子物体的拖拽移动，修改等任何事件都会正常执行​
     <span style="color:#494949">
      。
     </span>
    </p>
    <h4>
     四、（重点）blocksRaycasts和interactable之间的区别和使用场景
    </h4>
    <p>
     下面提到的自身，包括挂载组件的UI以及UI内部的其他子对象。
    </p>
    <h5>
     1、异同
    </h5>
    <p>
     相同：都会影响UI自身的交互；
    </p>
    <p>
     不同：
    </p>
    <p>
     Interactable是影响（自身的）输入事件，影响交互状态；
    </p>
    <p>
     BlocksRaycasts是影响（自身和自身以外后面的UI的）射线事件，影响射线检测状态。
    </p>
    <h5>
     2、使用环境
    </h5>
    <p>
     以背包面板为例，
    </p>
    <h6>
     （1）状态说明如下：
    </h6>
    <p>
     1）
     <strong>
      <span style="color:#1c7331">
       仅背包上挂载CanvasGroup组件；
      </span>
     </strong>
    </p>
    <p>
     2）可通过
     <strong>
      <span style="color:#1c7331">
       键盘输入
      </span>
     </strong>
     事件，往
     <span style="color:#494949">
      背包内部
     </span>
     <strong>
      <span style="color:#1c7331">
       物品格里增减物品
      </span>
     </strong>
     ；
    </p>
    <p>
     3）
     <span style="color:#1c7331">
      <strong>
       背包
      </strong>
     </span>
     、
     <strong>
      <span style="color:#1c7331">
       物品格里的物品
      </span>
     </strong>
     、
     <span style="color:#1c7331">
      <strong>
       背包后面的物品X
      </strong>
     </span>
     都能进行
     <span style="color:#1c7331">
      <strong>
       鼠标点击移动
      </strong>
     </span>
     操作时，
    </p>
    <p>
     <span style="color:#494949">
      4）点击
     </span>
     <span style="color:#1c7331">
      <strong>
       重叠
      </strong>
     </span>
     <span style="color:#494949">
      处
     </span>
     ，通常会
     <strong>
      <span style="color:#1c7331">
       优先处理最上层
      </span>
     </strong>
     的元素：
     <strong>
      <span style="color:#1c7331">
       物品&gt;物品格&gt;背包&gt;物品X
      </span>
     </strong>
     <span style="color:#494949">
      ；
     </span>
    </p>
    <p>
     4）由于
     <span style="color:#1c7331">
      <strong>
       背包的visible值为false
      </strong>
     </span>
     ，完全
     <span style="color:#1c7331">
      <strong>
       不响应任何事件，
      </strong>
     </span>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       而CanvasGroup组件的alpha值只影响视觉效果，不影响任何用户事件。
      </span>
     </strong>
    </p>
    <p>
     若visible为false，无论CanvasGroup设置什么样，物体X怎么也不会被背包遮挡，能被射线检测到，可被鼠标拖动。
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       故这里默认背包的visible值为true
      </strong>
     </span>
     ，通过
     <span style="color:#1c7331">
      <strong>
       CanvasGroup的alpha值控制背包显示掩藏
      </strong>
     </span>
     。
    </p>
    <h6>
     （2）情况分析：
    </h6>
    <h6>
     <strong>
      1）Interactable为true，BlocksRaycasts为true：
     </strong>
    </h6>
    <p>
     Interactable为true，
    </p>
    <p>
     表示背包及子物体的交互事件可正常执行，鼠标键盘事件背包及子物体都可被接收。
    </p>
    <p>
     blocksRaycasts为true：
    </p>
    <p>
     在检测鼠标点击时，射线会首先命中背包面板，鼠标点击事件会优先被背包面板接收并处理，而不会触发后面物体 X 的点击拖动事件。
    </p>
    <p>
     无论alpha值是不是为0，背包面板是不是不可见，都会认为背包面板仍然存在并会阻挡射线，
     <strong>
      交互逻辑上优先响应背包面板
     </strong>
     ：
    </p>
    <p>
     故鼠标点击背包/物品X：
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       背包面板可被鼠标拖动；背包里的物品也可以正常被鼠标移动；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       也可正常通过键盘事件，往内部物品格里进行增减物品；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       物体X被背包遮挡，不会被射线检测到，无法被鼠标拖动；
      </span>
     </strong>
    </p>
    <h6>
     <strong>
      2）Interactable为true，BlocksRaycasts为false：
     </strong>
    </h6>
    <p>
     interactable为true，
    </p>
    <p>
     表明背包及其子元素，理论上可以接受交互事件；
    </p>
    <p>
     但blocksRaycasts为false，
    </p>
    <p>
     背包面板不会阻挡射线检测，射线会直接穿透背包面板，命中其后面的物体X。
    </p>
    <p>
     无论alpha值是不是为1，背包面板是不是可见，交互逻辑上只响应物体X的射线检测事件，
    </p>
    <p>
     不过键盘的事件不是由射线检测判断触发，背包里的物品正常接收键盘事件；
    </p>
    <p>
     故鼠标点击背包/物品X：
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       背包面板不能被鼠标拖动；背包里的物品无法被鼠标移动；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       但可正常通过键盘事件，往内部物品格里进行增减物品；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       物体X不会被背包遮挡，可以被射线检测到，被鼠标拖动；
      </span>
     </strong>
    </p>
    <h6>
     3）Interactable为false，BlocksRaycasts为true：
    </h6>
    <p>
     blocksRaycasts为true
    </p>
    <p>
     在检测鼠标点击时，射线会首先命中背包面板，鼠标点击事件会优先被背包面板接收并处理，而不会触发后面物体 X 的点击拖动事件。
    </p>
    <p>
     但Interactable为false
    </p>
    <p>
     背包及其子元素的交互层面被设置为不可用状态，背包上的任何交互事件都不会被接受触发。
    </p>
    <p>
     因此背包子物体的键盘事件不会被触发；同时即使背包及其子物体接收了鼠标的射线检测，也不会触发鼠标事件。
    </p>
    <p>
     故鼠标点击背包/物品X：
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       背包面板不能被鼠标拖动；背包里的物品无法被鼠标移动；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       通过键盘事件，也不能往内部物品格里进行增减物品；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       物体X会被背包遮挡，不会被射线检测到，无法被鼠标拖动；
      </span>
     </strong>
    </p>
    <h6>
     4）Interactable为false，BlocksRaycasts为false：
    </h6>
    <p>
     blocksRaycasts为false
    </p>
    <p>
     背包面板不会阻挡射线检测，射线会直接穿透背包面板，命中其后面的物体X。交互逻辑上只响应物体X的射线检测事件。
    </p>
    <p>
     Interactable为false
    </p>
    <p>
     背包及其子元素的交互层面被设置为不可用状态，背包上的任何交互事件都不会被接受触发。
    </p>
    <p>
     因此背包和子物体的鼠标事件，以及子物体的键盘事件都不会被触发。
    </p>
    <p>
     故鼠标点击背包/物品X：
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       背包面板不能被鼠标拖动；背包里的物品无法被鼠标移动；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       通过键盘事件，也不能往内部物品格里进行增减物品；
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#1c7331">
       物体X不会被背包遮挡，可以被射线检测到，被鼠标拖动；
      </span>
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333930383335352f:61727469636c652f64657461696c732f313436313139393539" class_="artid" style="display:none">
 </p>
</div>


