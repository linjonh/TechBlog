---
layout: post
title: "LeetCode-移动零"
date: 2025-03-13 11:07:18 +0800
description: "给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。"
keywords: "LeetCode-移动零"
categories: ['未分类']
tags: ['职场和发展', '算法', 'Leetcode']
artid: "146225141"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146225141
    alt: "LeetCode-移动零"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146225141
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146225141
cover: https://bing.ee123.net/img/rand?artid=146225141
image: https://bing.ee123.net/img/rand?artid=146225141
img: https://bing.ee123.net/img/rand?artid=146225141
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LeetCode-移动零
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、题目描述
    </h2>
    <blockquote>
     <p>
      给定一个数组
      <code>
       nums
      </code>
      ，编写一个函数将所有
      <code>
       0
      </code>
      移动到数组的末尾，同时保持非零元素的相对顺序。
     </p>
     <p>
      <strong>
       请注意
      </strong>
      ，必须在不复制数组的情况下原地对数组进行操作。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1:
      </strong>
     </p>
     <pre><strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>
<strong>输出:</strong> <code>[1,3,12,0,0]</code>
</pre>
     <p>
      <strong>
       示例 2:
      </strong>
     </p>
     <pre><strong>输入:</strong> nums = <code>[0]</code>
<strong>输出:</strong> 
<code>[0]</code></pre>
    </blockquote>
    <h2>
     二、解题思路
    </h2>
    <p>
     题目要求必须原地操作，不能复制数组。比如示例里的数组是[0,1,0,3,12]，处理后变[1,3,12,0,0]。
    </p>
    <p>
     看起来非零元素的顺序要保持不变，然后把零都放到后面。
    </p>
    <p>
     可能的一个思路是，用双指针的方法。比如，一个指针用来遍历数组，另一个指针记录当前非零元
    </p>
    <p>
     素应该放的位置。然后每次遇到非零元素，就把它放到前面的位置，最后剩下的位置补零。初始化
    </p>
    <p>
     一个指针j=0。然后遍历数组，当遇到nums[i]不等于零的时候，就把nums[j]设置为nums[i]，然后j
    </p>
    <p>
     加一。这样遍历完一遍之后，所有非零元素都被移到了前面，顺序不变。之后剩下的位置j到末尾
    </p>
    <p>
     都设置为零。这个方法应该可行，而且时间复杂度是O(n)，空间复杂度是O(1)，符合要求。
    </p>
    <p>
     如例子中的第一个例子，遍历的时候，i从0开始。当i=0的时候，元素是0，跳过。i=1的时候元素是
    </p>
    <p>
     1，放到nums[0]，j变成1。i=2的时候是0，跳过。i=3的时候是3，放到nums[1]，j变成2。i=4的时
    </p>
    <p>
     候是12，放到nums[2]，j变成3。然后遍历结束后，从j=3的位置开始，将后面的元素都设为0。所
    </p>
    <p>
     以原数组被修改为1,3,12,0,0，符合要求。
    </p>
    <p>
     原数组是[1,2,3,0,4]。处理过程：
    </p>
    <blockquote>
     <p>
      i=0，nums[i]=1，赋值给j=0，j=1。
     </p>
     <p>
      i=1，nums[i]=2，赋值给j=1，j=2。
     </p>
     <p>
      i=2，nums[i]=3，赋值给j=2，j=3。
     </p>
     <p>
      i=3，nums[i]=0，跳过。
     </p>
     <p>
      i=4，nums[i]=4，赋值给j=3，j=4。
     </p>
    </blockquote>
    <p>
     遍历结束后，j=4，此时n=5，所以剩下的位置是4到4，即nums[4]=0。这时候数组变成了
    </p>
    <p>
     [1,2,3,4,0]。原来的那个0在索引3的位置，已经被覆盖了，原来的数组中的4被移动到了索引3的位
    </p>
    <p>
     置，然后索引4的位置被置零。
    </p>
    <p>
     原问题要求将所有零移动到末尾，非零元素的相对顺序不变。原来的数组中的零是位于索引3的位
    </p>
    <p>
     置，处理后，数组是[1,2,3,4,0]，这样确实符合要求。那这个方法是可行的。比如原来的4在索引4
    </p>
    <p>
     的位置，现在被移动到了索引3的位置，后面被置零。当i=4的时候，此时j=3，所以nums[3]=4，而
    </p>
    <p>
     原来的nums[3]是0，所以没有问题。然后遍历结束后，将j=4的位置置零，即nums[4]=0。这样处
    </p>
    <p>
     理后的结果是正确的。
    </p>
    <h2>
     三、大致步骤
    </h2>
    <blockquote>
     <p>
      1. 初始化j=0。
     </p>
     <p>
      2. 遍历数组，i从0到n-1。
     </p>
     <p>
      3. 如果nums[i]不等于0，就将nums[j] = nums[i]，然后j自增。
     </p>
     <p>
      4. 遍历结束后，将j到n-1的位置都置为0。
     </p>
    </blockquote>
    <p>
     想到这里，假设数组是[1,0,2,0,3]，当i=0时，nums[j=0]=1，j=1。i=1的时候是0，跳过。i=2的时候
    </p>
    <p>
     是2，此时j=1，所以nums[1]=2，j=2。这样原来的nums[1]的0就被覆盖了。但这样没问题，因为之
    </p>
    <p>
     后会把后面的位置都置零。 所以这个方法是可行的。
    </p>
    <p>
     要解决将数组中的所有零移动到末尾并保持非零元素顺序的问题，可以使用双指针方法。具体思路
    </p>
    <p>
     是遍历数组，将非零元素依次移到数组前面，然后将剩余位置填充为零。这种方法确保了原地操作
    </p>
    <p>
     且时间复杂度为O(n)。
    </p>
    <h2>
     四、方法思路
    </h2>
    <blockquote>
     <ol>
      <li>
       <p>
        <strong>
         双指针遍历
        </strong>
        ：使用指针
        <code>
         j
        </code>
        来记录当前非零元素应放置的位置。遍历数组，当遇到非零元素时，将其移到
        <code>
         j
        </code>
        的位置，并递增
        <code>
         j
        </code>
        。
       </p>
      </li>
      <li>
       <p>
        <strong>
         填充零
        </strong>
        ：遍历结束后，所有非零元素已移到数组前面，剩余位置从
        <code>
         j
        </code>
        开始填充零。
       </p>
      </li>
     </ol>
    </blockquote>
    <h2>
     五、解决代码
    </h2>
    <pre><code class="language-cpp">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int j = 0;
        // 将非零元素移动到数组前面
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        // 将剩余位置填充为零
        while (j &lt; nums.size()) {
            nums[j++] = 0;
        }
    }
};</code></pre>
    <p>
     以上就是，这道题的全解啦！！！！关注博主，持续分享力扣算法题。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35363836393132302f:61727469636c652f64657461696c732f313436323235313431" class_="artid" style="display:none">
 </p>
</div>


