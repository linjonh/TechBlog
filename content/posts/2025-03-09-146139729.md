---
layout: post
title: "Leetcode-刷题记录-05-普通数组"
date: 2025-03-09 22:22:59 +0800
description: "本系列为笔者的 Leetcode 刷题记录，顺序为 Hot 100 题官方顺序，根据标签命名，记录笔者总结的做题思路，附部分代码解释和疑问解答。"
keywords: "Leetcode 刷题记录 05 —— 普通数组"
categories: ['未分类']
tags: ['职场和发展', '算法', '笔记', '哈希算法', 'Leetcode', 'C']
artid: "146139729"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146139729
    alt: "Leetcode-刷题记录-05-普通数组"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146139729
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146139729
cover: https://bing.ee123.net/img/rand?artid=146139729
image: https://bing.ee123.net/img/rand?artid=146139729
img: https://bing.ee123.net/img/rand?artid=146139729
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Leetcode 刷题记录 05 —— 普通数组
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     本系列为笔者的
     <a href="https://so.csdn.net/so/search?q=Leetcode%20%E5%88%B7%E9%A2%98&amp;spm=1001.2101.3001.7020" title="Leetcode 刷题">
      Leetcode 刷题
     </a>
     记录，顺序为 Hot 100 题官方顺序，根据标签命名，记录笔者总结的做题思路，附部分代码解释和疑问解答。
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h4 id="01%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C" name="01%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">
     01 最大子数组和
    </h4>
    <p>
     <img alt="" height="109" src="https://i-blog.csdnimg.cn/direct/bfb3d2415bc6458c9481c1c431b87ea6.png" width="870"/>
    </p>
    <p>
     <img alt="" height="367" src="https://i-blog.csdnimg.cn/direct/128ca504f1e54503a4efd8f843936895.png" width="880"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%8D%A1%E8%BE%BE%E5%B0%BC%E7%AE%97%E6%B3%95%EF%BC%89" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%8D%A1%E8%BE%BE%E5%B0%BC%E7%AE%97%E6%B3%95%EF%BC%89">
     方法一：动态规划（卡达尼算法）
    </h5>
    <ul>
     <li>
      <p>
       声明
       <code>
        pre
       </code>
       ，存储
       <code>
        x
       </code>
       之前的最大子数组和，
       <code>
        pre = max(pre+x, x)
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int pre = 0, ans = nums[0];
        for(const auto&amp; x: nums){
            pre = max(pre+x, x);
            ans = max(ans, pre);
        }
        return ans;
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BA%8C%E5%88%86%20%2B%20%E9%80%92%E6%8E%A8" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BA%8C%E5%88%86%20%2B%20%E9%80%92%E6%8E%A8">
     方法二：二分 + 递推
    </h5>
    <ul>
     <li>
      <p>
       建立结构体
       <code>
        Status
       </code>
       ，包含
       <code>
        iSum, lSum, rSum, mSum
       </code>
      </p>
     </li>
     <li>
      <p>
       <img alt="" height="157" src="https://i-blog.csdnimg.cn/direct/670e7b9525374f649fc7253440f31efe.png" width="771"/>
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       采用二分，不断切割区间
       <code>
        [l, r]
       </code>
       ，进行递归，快速下降后缓慢回升
      </p>
     </li>
     <li>
      <p>
       注：
       <code>
        if(l == r) return (Status) {a[l], a[l], a[l], a[l]};
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    struct Status{
        int iSum, lSum, rSum, mSum;
    };

    //缓慢回升：递推
    Status pushUp(Status l, Status r){
        int iSum = l.iSum + r.iSum;
        int lSum = max(l.lSum, l.iSum + r.lSum);
        int rSum = max(r.rSum, r.iSum + l.rSum);
        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);
        return (Status) {iSum, lSum, rSum, mSum};
    }

    //快速下降：二分
    Status get(vector&lt;int&gt;&amp; a, int l, int r){
        if(l == r) return (Status) {a[l], a[l], a[l], a[l]};

        int m = (l + r) &gt;&gt; 1;
        Status lSub = get(a, l, m);
        Status rSub = get(a, m + 1, r);
        return pushUp(lSub, rSub);
    }

    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        return get(nums, 0, nums.size() - 1).mSum;
    }
};</code></pre>
    <h4 id="02%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4" name="02%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">
     02 合并区间
    </h4>
    <p>
     <img alt="" height="73" src="https://i-blog.csdnimg.cn/direct/cd89bf43ba3441c2b17d40f787ea2370.png" width="880"/>
    </p>
    <p>
     <img alt="" height="277" src="https://i-blog.csdnimg.cn/direct/1e2e31f5d13544a387680843672cbe31.png" width="875"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8E%92%E5%BA%8F" name="%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8E%92%E5%BA%8F">
     方法：排序
    </h5>
    <ul>
     <li>
      <p>
       <code>
        sort
       </code>
       原数组
      </p>
     </li>
     <li>
      <p>
       <img alt="" height="184" src="https://i-blog.csdnimg.cn/direct/4d74a132229e440b9b4c2505a880360e.png" width="823"/>
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       判断
       <code>
        merged.back()[1] &lt; L
       </code>
       ，若成立，则添加区间，若不成立，则更新原区间右端点
      </p>
     </li>
     <li>
      <p>
       注：
       <code>
        if(intervals.size() == 0) return {};
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.size() == 0) return {};
        sort(intervals.begin(), intervals.end());

        vector&lt;vector&lt;int&gt;&gt; merged;
        for(int i=0; i&lt;intervals.size(); ++i){
            int L = intervals[i][0];
            int R = intervals[i][1];
            if(!merged.size() || merged.back()[1] &lt; L) merged.push_back({L, R});
            else merged.back()[1] = max(merged.back()[1], R);
        }
        return merged;
    }
};</code></pre>
    <h4 id="03%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84" name="03%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84">
     03 轮转数组
    </h4>
    <p>
     <img alt="" height="45" src="https://i-blog.csdnimg.cn/direct/21a3aed4b37748c9b1bab7ecf9739b98.png" width="872"/>
    </p>
    <p>
     <img alt="" height="406" src="https://i-blog.csdnimg.cn/direct/b5e9787c259741a4b7b8d27b1200f03c.png" width="870"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%96%B0%E5%BB%BA%E6%95%B0%E7%BB%84" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%96%B0%E5%BB%BA%E6%95%B0%E7%BB%84" style="background-color:transparent">
     方法：新建数组
    </h5>
    <ul>
     <li>
      <p>
       建立新数组
       <code>
        newArr(n)
       </code>
       ，存储轮转结果
       <code>
        newArr[(i+k)%n] = nums[i];
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;int&gt; newArr(n);
        for(int i=0; i&lt;n; ++i){
            newArr[(i+k)%n] = nums[i];
        }
        nums.assign(newArr.begin(), newArr.end());
    }
};</code></pre>
    <p>
     <code>
      nums.assign(newArr.begin(), newArr.end())
     </code>
     意味着用
     <code>
      newArr
     </code>
     中由
     <code>
      begin()
     </code>
     和
     <code>
      end()
     </code>
     界定的元素范围替换
     <code>
      nums
     </code>
     中原有的元素。
    </p>
    <h4 id="04%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF" name="04%20%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF">
     04 除自身以外数组的乘积
    </h4>
    <p>
     <img alt="" height="170" src="https://i-blog.csdnimg.cn/direct/e290894bd8c94a14b9574c96b3a32816.png" width="871"/>
    </p>
    <p>
     <img alt="" height="238" src="https://i-blog.csdnimg.cn/direct/9ee49d7a90194a4a85a21a1b64321695.png" width="871"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B7%A6%E5%8F%B3%E4%B9%98%E7%A7%AF%E5%88%97%E8%A1%A8" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B7%A6%E5%8F%B3%E4%B9%98%E7%A7%AF%E5%88%97%E8%A1%A8">
     方法一：左右乘积列表
    </h5>
    <ul>
     <li>
      <p>
       建立两个数组
       <code>
        leftSup(n)
       </code>
       和
       <code>
        rightSup(n)
       </code>
       ，存储
       <code>
        i
       </code>
       左侧和右侧元素乘积
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        
        vector&lt;int&gt; leftSup(n);
        leftSup[0] = 1;
        for(int i=1; i&lt;n; ++i){
            leftSup[i] = leftSup[i-1] * nums[i-1];
        }
        
        vector&lt;int&gt; rightSup(n);
        rightSup[n-1] = 1;
        for(int i=n-2; i&gt;=0; --i){
            rightSup[i] = rightSup[i+1] * nums[i+1];
        }
        
        vector&lt;int&gt; ans(n);
        for(int i=0; i&lt;n; ++i){
            ans[i] = leftSup[i] * rightSup[i];
        }
        return ans;
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B7%A6%E5%8F%B3%E4%B9%98%E7%A7%AF%E5%88%97%E8%A1%A8Plus" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B7%A6%E5%8F%B3%E4%B9%98%E7%A7%AF%E5%88%97%E8%A1%A8Plus">
     方法二：左右乘积列表Plus
    </h5>
    <ul>
     <li>
      <p>
       建立一个数组
       <code>
        ans(n)
       </code>
       ，初始存储
       <code>
        i
       </code>
       左侧元素乘积
      </p>
     </li>
     <li>
      <p>
       从右至左，计算
       <code>
        ans(n)
       </code>
       最终值
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; ans(n);
        
        ans[0] = 1;
        for(int i=1; i&lt;n; ++i){
            ans[i] = ans[i-1] * nums[i-1];
        }
        
        int R = 1;
        for(int i=n-1; i&gt;=0; --i){
            ans[i] = ans[i] * R;
            R *= nums[i];
        }
        return ans;
    }
};</code></pre>
    <h4 id="05%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0" name="05%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">
     05 缺失的第一个正数
    </h4>
    <p>
     <img alt="" height="84" src="https://i-blog.csdnimg.cn/direct/6cf5d0f5cfda43dfbdbcdd768ced3276.png" width="861"/>
    </p>
    <p>
     <img alt="" height="439" src="https://i-blog.csdnimg.cn/direct/7143a2da6db343159d79f04a7ed5e05e.png" width="872"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84">
     方法一：哈希映射
    </h5>
    <p>
     时间复杂度 O(n)、空间复杂度 O(n)
    </p>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9E%9A%E4%B8%BE" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9E%9A%E4%B8%BE">
     方法二：枚举
    </h5>
    <p>
     时间复杂度 O(n^2)、空间复杂度 O(1)
    </p>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E6%95%B0%E7%BB%84%E6%94%B9%E9%80%A0%E5%93%88%E5%B8%8C%E8%A1%A8" name="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E6%95%B0%E7%BB%84%E6%94%B9%E9%80%A0%E5%93%88%E5%B8%8C%E8%A1%A8">
     方法三：数组改造哈希表
    </h5>
    <p>
     时间复杂度 O(n)、空间复杂度 O(1)
    </p>
    <ul>
     <li>
      <p>
       遍历数组，所有复数改为
       <code>
        n + 1
       </code>
      </p>
     </li>
     <li>
      <p>
       遍历数组，判断
       <code>
        abs(nums[i]) &lt;= n
       </code>
       ，执行
       <code>
        nums[flag - 1] = -abs(nums[flag - 1]);
       </code>
      </p>
     </li>
     <li>
      <p>
       遍历数组，若每个数都是负数，则答案为
       <code>
        n + 1
       </code>
       ，否则为第一个整数位置加一
      </p>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="296" src="https://i-blog.csdnimg.cn/direct/2ad16b17738d48b887331ad710920081.png" width="711"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        
        //改负数
        for(int i=0; i&lt;n; ++i){
            if(nums[i] &lt;= 0) nums[i] = n + 1;
        }
        
        //添负号
        for(int i=0; i&lt;n; ++i){
            int flag = abs(nums[i]);
            if(flag &lt;= n) nums[flag - 1] = -abs(nums[flag - 1]);
        }
        
        for(int i=0; i&lt;n; ++i){
            if(nums[i] &gt; 0) return i + 1; //精髓在负号
        }
        return n + 1;
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E7%BD%AE%E6%8D%A2" name="%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E7%BD%AE%E6%8D%A2">
     方法四：置换
    </h5>
    <ul>
     <li>
      <p>
       遍历数组，判断
       <code>
        nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]
       </code>
       ，交换两数，执行
       <code>
        swap(nums[nums[i] - 1], nums[i])
       </code>
      </p>
     </li>
     <li>
      <p>
       遍历数组，若
       <code>
        nums[i] != i + 1
       </code>
       ，则答案为
       <code>
        i + 1
       </code>
       , 否则为
       <code>
        n + 1
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
         int n = nums.size();
        
        for(int i=0; i&lt;n; ++i){
            while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]){
                swap(nums[nums[i] - 1], nums[i]);
            }
        }
        
        for(int i=0; i&lt;n; ++i){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        return n + 1;
    }
};</code></pre>
    <p>
     ① 为什么
     <code>
      nums[nums[i] - 1] != nums[i]
     </code>
     改成
     <code>
      nums[i] - 1 != i
     </code>
     会导致执行超过时间限制？
    </p>
    <p>
     <code>
      nums[nums[i] - 1] != nums[i]
     </code>
     可能是位置不同但数值相同，导致无限循环交换。
    </p>
    <p>
     ② 为什么
     <code>
      nums[i] != i + 1
     </code>
     改成
     <code>
      nums[i] - 1 != i
     </code>
     会导致执行错误？
    </p>
    <p>
     以
     <code>
      nums[i] - 1
     </code>
     作为索引进行比较时，可能会涉及到为负数或超出范围的索引，若
     <code>
      nums[i]
     </code>
     是负数或
     <code>
      0
     </code>
     ，
     <code>
      nums[i] - 1
     </code>
     是非法索引，可能导致未定义行为。
    </p>
    <blockquote>
     <p>
      文章部分代码来源于力扣（LeetCode）
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6c616e676f5f4c472f:61727469636c652f64657461696c732f313436313339373239" class_="artid" style="display:none">
 </p>
</div>


