---
layout: post
title: "第八节红黑树初阶"
date: 2025-03-09 12:51:29 +0800
description: "【本节要点】红黑树概念、红黑树性质、红黑树结点定义、红黑树结构、红黑树插入操作的分析。"
keywords: "红黑树"
categories: ['数据结构']
tags: ['算法', '数据结构', '开发语言', 'C']
artid: "146128565"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146128565
    alt: "第八节红黑树初阶"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146128565
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146128565
cover: https://bing.ee123.net/img/rand?artid=146128565
image: https://bing.ee123.net/img/rand?artid=146128565
img: https://bing.ee123.net/img/rand?artid=146128565
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     第八节：红黑树（初阶）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/a018e8e3d929475f932040b0a30efae7.gif"/>
    </p>
    <blockquote>
     <p>
      【本节要点】
     </p>
     <ul>
      <li>
       红黑树概念
      </li>
      <li>
       红黑树性质
      </li>
      <li>
       红黑树结点定义
      </li>
      <li>
       红黑树结构
      </li>
      <li>
       红黑树插入操作的分析
      </li>
     </ul>
    </blockquote>
    <h2>
     一、红黑树的概念与性质
    </h2>
    <h3>
     1.1 红黑树的概念
    </h3>
    <div>
     <span style="color:#777777">
      <strong>
       红黑树
      </strong>
     </span>
     <span style="color:#777777">
      ，是一种
     </span>
     <span style="color:#777777">
      <strong>
       二叉搜索树
      </strong>
     </span>
     <span style="color:#777777">
      ，但
     </span>
     <span style="color:#777777">
      <strong>
       在每个结点上增加一个存储位表示结点的颜色，可以是
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       Red和
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       Black
      </strong>
     </span>
     <span style="color:#777777">
      。 通过对
     </span>
     <span style="color:#777777">
      <strong>
       任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       径会比其他路径长出俩倍
      </strong>
     </span>
     <span style="color:#777777">
      ，因而是
     </span>
     <span style="color:#777777">
      <strong>
       接近平衡
      </strong>
     </span>
     <span style="color:#777777">
      的。
     </span>
    </div>
    <div>
     <pre><code class="language-bash">红黑树构造：
 
          [10(黑)] 
          /        \
       [5(红)]     [20(黑)]
      /     \       /     \
    [3(黑)] [8(黑)] [15(红)] [25(红)]
     /  \    /  \     /  \    /  \
   NIL NIL  NIL NIL  NIL NIL NIL NIL</code></pre>
    </div>
    <h3>
     1.2 红黑树的性质
    </h3>
    <ul>
     <li>
      <span style="color:#777777">
       1.
      </span>
      <span style="color:#777777">
       <strong>
        每个结点不是红色就是黑色
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#777777">
       2.
      </span>
      <span style="color:#777777">
       <strong>
        根节点是黑色的
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#777777">
       3.
      </span>
      <span style="color:#777777">
       <strong>
        如果一个节点是红色的，则它的两个孩子结点是黑色的
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#777777">
       4.
      </span>
      <span style="color:#777777">
       <strong>
        对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含
       </strong>
      </span>
      <span style="color:#fe2c24">
       <strong>
        相同数目的黑色结点
       </strong>
      </span>
     </li>
     <li>
      <span style="color:#777777">
       5.
      </span>
      <span style="color:#777777">
       <strong>
        每个
       </strong>
      </span>
      <span style="color:#fe2c24">
       <strong>
        叶子结点都是黑色
       </strong>
      </span>
      <span style="color:#777777">
       <strong>
        的
       </strong>
      </span>
      <span style="color:#777777">
       <strong>
        (
       </strong>
      </span>
      <span style="color:#777777">
       <strong>
        此处的叶子结点指的是空结点
       </strong>
      </span>
      <span style="color:#777777">
       <strong>
        )
       </strong>
      </span>
     </li>
    </ul>
    <p>
     以上五点性质可以保证：
     <span style="color:#777777">
      <strong>
       其最长路径中节点个数不会超过最短路径节点
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       个数的两倍。
      </strong>
     </span>
    </p>
    <h2>
     二、红黑树结点定义
    </h2>
    <pre><code class="language-cpp">// 结点的颜色
enum Colour
{
	RED,
	BLACK,
};
 
// 红黑树结点的定义
template&lt;class K, class V&gt;
struct RBTreeNode
{
	pair&lt;K, V&gt; _kv;            // 结点的键值对
	RBTreeNode&lt;K, V&gt;* _left;   // 结点的左孩子
	RBTreeNode&lt;K, V&gt;* _right;  // 结点的右孩子
	RBTreeNode&lt;K, V&gt;* _parent; // 结点的双亲（红黑树需要旋转，为了实现简单所以给出该结点）
	Colour _col;               // 结点的颜色

    // 结点的构造函数
	RBTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_kv(kv)
		, _left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _col(RED)
	{}
};
</code></pre>
    <p>
     注意：红黑树定义结点时，默认结点颜色为红色，这一设计选择直接增加红黑树的平衡维护效率和整体性能，大大减少时间复杂度。
    </p>
    <h2>
     三、红黑树的结构
    </h2>
    <pre><code class="language-bash">// 以本数组为例
num[3, 5, 8, 10, 15, 20, 25]</code></pre>
    <pre><code class="language-bash">红黑树构造：
 
          [10(黑)] 
          /        \
       [5(红)]     [20(黑)]
      /     \       /     \
    [3(黑)] [8(黑)] [15(红)] [25(红)]
     /  \    /  \     /  \    /  \
   NIL NIL  NIL NIL  NIL NIL NIL NIL</code></pre>
    <p>
     <strong>
      图示说明
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        根结点标记
       </strong>
       ：根结点
       <code>
        10
       </code>
       为黑色，符合
       <strong>
        性质2
       </strong>
       （根结点必黑）
      </p>
     </li>
     <li>
      <p>
       <strong>
        红色结点规则：
       </strong>
       红色结点
       <code>
        5
       </code>
       、
       <code>
        15
       </code>
       、
       <code>
        25
       </code>
       的子结点均为黑色，满足
       <strong>
        性质3
       </strong>
       （红色结点不连续）
      </p>
     </li>
     <li>
      <p>
       <strong>
        黑高一致性验证：
       </strong>
       从根结点到任意 NIL 的路径黑色结点数均为
       <strong>
        2
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        NIL结点处理：
       </strong>
       所有叶子结点显式标记为 NIL（黑色），符合
       <strong>
        性质5
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        最长/最短路径对比
       </strong>
      </p>
      <table>
       <thead>
        <tr>
         <th>
          路径类型
         </th>
         <th>
          示例路径
         </th>
         <th>
          结点数
         </th>
         <th>
          比例
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          <strong>
           最短路径
          </strong>
         </td>
         <td>
          10→20→NIL
         </td>
         <td>
          2
         </td>
         <td>
          1:1
         </td>
        </tr>
        <tr>
         <td>
          <strong>
           最长路径
          </strong>
         </td>
         <td>
          10→5→3→NIL
         </td>
         <td>
          3
         </td>
         <td>
          1.5:1
         </td>
        </tr>
        <tr>
         <td>
          <strong>
           理论极限
          </strong>
         </td>
         <td>
          红黑交替路径（未出现）
         </td>
         <td>
          ≤4
         </td>
         <td>
          ≤2:1
         </td>
        </tr>
       </tbody>
      </table>
     </li>
    </ol>
    <h2>
     四、红黑树的插入操作
    </h2>
    <pre><code class="language-bash">                              [开始插入新结点Z]
                                      │
                                      ▼
                       ┌─────────执行标准BST插入─────────┐
                       │                                │
                       ▼                                ▼
                  [Z设为红色]                   [保持BST性质]
                       │
                       ▼
             ┌─────父结点P是否为红色？─────┐
             │                            │
             ▼ (是)                       ▼ (否)
    [存在双红冲突需处理]               [插入完成]
             │
             ▼
   ┌────叔结点U的颜色？────┐
   │                      │
   ▼ (红色)               ▼ (黑色/NIL)
[Case1: 颜色翻转]     [判断冲突结构类型]
   │                      │
   ▼                      ├─────────────────────────┐
[将P、U设为黑色]           ▼                         ▼
   │               [Z-P-G呈三角型]            [Z-P-G呈直线型]
   ▼                      │                         │
[将G设为红色]        [Case2: 旋转父结点]      [Case3: 旋转祖父结点]
   │                      │                         │
   ▼                      ▼                         ▼
[以G为新Z向上回溯]   [转为直线型冲突]         [交换颜色并旋转]
                                           
                                                    │
                                                    ▼
                                                [调整完成]
                                                    │
                                                    ▼
                                           [最终确保根结点为黑]</code></pre>
    <h3>
     <strong>
      4.1 基本BST插入阶段
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       插入位置遵循二叉搜索树规则
      </p>
     </li>
     <li>
      <p>
       新结点初始颜色必须为
       <strong>
        红色
       </strong>
       （最小化规则破坏）
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      4.2 冲突检测阶段
     </strong>
    </h3>
    <ul>
     <li>
      要素1：父结点状态判断
     </li>
     <li>
      要素2：叔结点颜色判定
     </li>
     <li>
      要素3：冲突结构类型识别
     </li>
    </ul>
    <h3>
     <strong>
      4.3  典型场景演练
     </strong>
    </h3>
    <blockquote>
     <p>
      <strong>
       场景1：叔结点为红（Case1）
      </strong>
     </p>
     <pre><code class="language-bash">         G(黑)                 G(红)
        /   \     颜色翻转     /   \
      P(红) U(红)  →       P(黑) U(黑)
      /                   /
    Z(红)              Z(红)</code></pre>
     <p>
     </p>
     <p>
      <strong>
       检测要点
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        确认U存在且为红
       </p>
      </li>
      <li>
       <p>
        将冲突标记上移给G
       </p>
      </li>
      <li>
       <p>
        继续以G作为新Z向上检测
       </p>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       场景2：叔结点为黑-三角型（Case2）
      </strong>
     </p>
     <pre><code class="language-bash">     G(黑)            G(黑)
    /               /
  P(红)   →      Z(红)
    \           /
    Z(红)     P(红)</code></pre>
     <p>
     </p>
     <p>
      <strong>
       检测要点
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        判断Z是P的右子结点
       </p>
      </li>
      <li>
       <p>
        识别为三角型冲突
       </p>
      </li>
      <li>
       <p>
        转换为直线型处理
       </p>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       场景3：叔结点为黑-直线型（Case3）
      </strong>
     </p>
     <pre><code class="language-bash">      G(黑)             P(黑)
     /               /   \
   P(红)   →      Z(红) G(红)
   /
 Z(红)</code></pre>
     <p>
     </p>
     <p>
      <strong>
       检测要点
      </strong>
      ：
     </p>
     <ul>
      <li>
       <p>
        确认Z是P的左子结点
       </p>
      </li>
      <li>
       <p>
        直接触发祖父旋转
       </p>
      </li>
      <li>
       <p>
        完成颜色交换
       </p>
      </li>
     </ul>
    </blockquote>
    <h3>
     4.4 总结
    </h3>
    <p>
     冲突检测阶段通过
     <strong>
      三级条件筛选
     </strong>
     （父结点状态→叔结点颜色→冲突结构类型），将复杂的平衡问题分解为可控的局部操作。这种分层检测机制：
    </p>
    <ol>
     <li>
      确保
      <strong>
       90%以上的插入操作
      </strong>
      只需1次检测即可完成
     </li>
     <li>
      将最坏情况的时间复杂度严格控制在
      <strong>
       O(log n)
      </strong>
     </li>
     <li>
      为后续的旋转/颜色调整提供精准的操作依据
     </li>
    </ol>
    <p>
     该设计体现了红黑树
     <strong>
      "以检测换计算，以分类求高效"
     </strong>
     的核心优化思想，是其能在大规模数据场景下保持卓越性能的关键所在。
    </p>
    <hr/>
    <p>
     以上就是
     <strong>
      红黑树初阶知识
     </strong>
     的了解，接下来我会
     <strong>
      继续更新红黑树进阶
     </strong>
     ：
     <strong>
      红黑树的模拟实现
     </strong>
     、使用红黑树底层对
     <strong>
      map和set容器的模拟实现。
      <span style="color:#956fe7">
       制作不易，请大家多多点赞收藏啦！！
      </span>
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="562" src="https://i-blog.csdnimg.cn/direct/9fbea464eceb4cd28314c09d28a857c9.jpeg" width="1000"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f73687569627578696e676161612f:61727469636c652f64657461696c732f313436313238353635" class_="artid" style="display:none">
 </p>
</div>


