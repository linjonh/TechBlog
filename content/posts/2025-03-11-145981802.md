---
layout: post
title: "Python-计算机视觉处理Opencv二值化,阈值法,反阈值法,截断阈值法,OTSU阈值法"
date: 2025-03-11 15:26:34 +0800
description: "在计算机视觉处理中，二值化是一种重要的图像处理技术，用于将灰度图像转换为仅包含黑白两种颜色的图像。常见的二值化方法包括阈值法，它通过设置一个固定的阈值，将灰度值高于该值的像素设为白色，低于该值的设为黑色；反阈值法则是相反的过程，将低于阈值的像素设为白色，而高于阈值的设为黑色；截断阈值法则将高于阈值的像素值保持不变，低于阈值的像素设为黑色。此外，OTSU阈值法是一种自适应阈值技术，它根据图像的灰度直方图自动选择最佳阈值，从而有效分离前景与背景，尤其在光照和对比度变化较大时表现出色。"
keywords: "Python----计算机视觉处理（Opencv：二值化，阈值法，反阈值法，截断阈值法，OTSU阈值法）"
categories: ['图像处理', 'Python', 'Opencv']
tags: ['计算机视觉', '人工智能', 'Python', 'Opencv']
artid: "145981802"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145981802
    alt: "Python-计算机视觉处理Opencv二值化,阈值法,反阈值法,截断阈值法,OTSU阈值法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145981802
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145981802
cover: https://bing.ee123.net/img/rand?artid=145981802
image: https://bing.ee123.net/img/rand?artid=145981802
img: https://bing.ee123.net/img/rand?artid=145981802
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python----计算机视觉处理（Opencv：二值化，阈值法，反阈值法，截断阈值法，OTSU阈值法）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、二值化
    </h2>
    <p>
     二值化，顾名思义，就是将某张图像的像素改成只有两个值，其操作的图像也必须是灰度图。也就是 说，二值化的过程，就是将一张灰度图上的像素根据某种规则修改为0和maxval（maxval表示最大值， 一般为255，显示白色）两种像素值，使图像呈现黑白的效果，能够帮助我们更好地分析图像中的形 状、边缘和轮廓等特征
    </p>
    <blockquote>
     <p>
      二值化图：就是将图像中的像素改成只有两种值，其操作的图像必须是灰度图。
     </p>
    </blockquote>
    <h2>
     二、阈值法
    </h2>
    <p>
     <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/9cf2fd2eafc644ea86ed2894119d9aaa.jpeg" width="330">
      <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/b9026f996b3a43219813719323c8cf67.jpeg" width="330"/>
     </img>
    </p>
    <p>
     阈值法(THRESH_BINARY)： 通过设置一个阈值，将灰度图 中的每一个像素值与该阈值进 行比较，小于等于阈值的像素 就被设置为0（黑），大于阈 值的像素就被设置为maxval。
    </p>
    <h3>
     2.1、实现过程
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     <p>
      设置  阈值  最大值
     </p>
    </blockquote>
    <pre><code class="language-python">thresh=127
maxval=255</code></pre>
    <blockquote>
     <p>
      做出操作
     </p>
    </blockquote>
    <pre><code class="language-python">img_thresh=np.zeros((1067,800),np.uint8)
for i in range(1067):
    for j in range(800):
        if img_gray[i,j] &gt; thresh:
            img_thresh[i,j]=maxval
        else:
            img_thresh[i,j]=0</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h3>
     2.2、内置函数
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     利用函数threshold
    </blockquote>
    <pre><code class="language-python">ret,img_thresh=cv2.threshold(img_gray,127,255,cv2.THRESH_BINARY)</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h2>
     三、反阈值法
    </h2>
    <p>
     <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/4f9f49d7dd824bd89b310b4a916a2bbe.jpeg" width="330">
      <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/a8d708765bf64fc9bf8154f4fed5e1c3.jpeg" width="330"/>
     </img>
    </p>
    <p>
     反阈值法(THRESH_BINARY_INV)： 与阈值法相反。反阈值法是当灰度 图的像素值大于阈值时，该像素值 将会变成0（黑），当灰度图的像 素值小于等于阈值时，该像素值将 会变成maxval。
    </p>
    <h3>
     3.1、实现过程
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     <p>
      设置  阈值  最大值
     </p>
    </blockquote>
    <pre><code class="language-python">thresh=127
maxval=255</code></pre>
    <blockquote>
     <p>
      做出操作
     </p>
    </blockquote>
    <pre><code class="language-python">img_thresh=np.zeros((1067,800),np.uint8)
for i in range(1067):
    for j in range(800):
        if img_gray[i,j] &gt; thresh:
            img_thresh[i,j]=0
        else:
            img_thresh[i,j]=maxval</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h3>
     3.2、内置函数
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     利用函数threshold
    </blockquote>
    <pre><code class="language-python">ret,img_thresh=cv2.threshold(img_gray,127,255,cv2.THRESH_BINARY_INV)</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h2>
     四、截断阈值法
    </h2>
    <p>
     <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/e955fce86d244013b80807a998953ea8.jpeg" width="330">
      <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/1c6e2ec9accb4bba82147822e64e2abb.jpeg" width="330"/>
     </img>
    </p>
    <p>
     截断阈值法(THRESH_TRUNC)： 指将灰度图中的所有像素与阈 值进行比较，像素值大于阈值 的部分将会被修改为阈值，小 于等于阈值的部分不变。换句 话说，经过截断阈值法处理过 的二值化图中的最大像素值就 是阈值。
    </p>
    <h3>
     4.1、实现过程
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     <p>
      设置  阈值  最大值
     </p>
    </blockquote>
    <pre><code class="language-python">thresh=127
maxval=255</code></pre>
    <blockquote>
     <p>
      做出操作
     </p>
    </blockquote>
    <pre><code class="language-python">img_thresh=np.zeros((1067,800),np.uint8)
for i in range(1067):
    for j in range(800):
        if img_gray[i,j] &gt; thresh:
            img_thresh[i,j]=thresh</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h3>
     4.2、内置函数
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     利用函数threshold
    </blockquote>
    <pre><code class="language-python">ret,img_thresh1=cv2.threshold(img_gray,127,255,cv2.THRESH_TRUNC)</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h2>
     五、OTSU阈值法
    </h2>
    <p>
     <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/e9be0738f3284a54b76d91cd75a1b41e.jpeg" width="330">
      <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/59aea4cc85e44ad8a4471d31143f48b6.jpeg" width="330"/>
     </img>
    </p>
    <p>
     OTSU阈值法：OTSU算法是通过一个值将这张图分前景色和背景色（也就是灰 度图中小于这个值的是一类，大于这个值的是一类），通过统计学方法（最大类 间方差）来验证该值的合理性，当根据该值进行分割时，使用最大类间方差计算 得到的值最大时，该值就是二值化算法中所需要的阈值。通常该值是从灰度图中 的最小值加1开始进行迭代计算，直到灰度图中的最大像素值减1，然后把得到的 最大类间方差值进行比较，来得到二值化的阈值。
    </p>
    <p>
     <img alt="" height="686" src="https://i-blog.csdnimg.cn/direct/a08305755ce04137b1442ce0efe46486.png" width="1607"/>
    </p>
    <p>
     g就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别就越大，效果就越好。OTSU算 法就是在灰度图的像素值范围内遍历阈值T，使得g最大，基本上双峰图片的阈值T在两峰之间的谷底。
    </p>
    <p>
     通过OTSU算法得到阈值之后，就可以结合上面的方法根据该阈值进行二值化，在本实验中有 THRESH_OTSU和THRESH_INV_OTSU两种方法，就是在计算出阈值后结合了阈值法和反阈值法
    </p>
    <blockquote>
     <p>
      注意：
     </p>
     <p>
      使用OTSU算法计算阈值时，组件中的thresh参数将不再有任何作用。
     </p>
    </blockquote>
    <h3>
     5.1、实现过程
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import numpy as np
import cv2</code></pre>
    <blockquote>
     <p>
      读取图片
     </p>
    </blockquote>
    <pre><code class="language-python">image_np = cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">image_gray = cv2.cvtColor(image_np, cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     <p>
      取数组最大最小行数列数
     </p>
    </blockquote>
    <pre><code class="language-python"># 使用np数组的min()函数去获取数组中的最小值
min_value = image_gray.min()

# 使用np数组的max()函数去获取数组中的最大值
max_value = image_gray.max()

# 使用np数组的shape属性获取灰度图的高度和宽度
image_shape = image_gray.shape

# 设置最大值
maxval = 255</code></pre>
    <blockquote>
     <p>
      生成一个二值化模板图
     </p>
    </blockquote>
    <pre><code class="language-python">image_thresh = np.zeros((image_shape[0], image_shape[1]), dtype=np.uint8)</code></pre>
    <blockquote>
     <p>
      定义计算最大类间方差公式中所用的变量
     </p>
    </blockquote>
    <pre><code class="language-python">n_0 = 0
n_1 = 0
w_0 = 0
w_1 = 0
u_0 = 0
u_1 = 0
u = 0
rows = image_shape[0]
cols = image_shape[1]


# 定义一个字典，用来存储每一个阈值所对应的最大类间方差，方便后面获取合适的阈值
var = {}</code></pre>
    <blockquote>
     <p>
      建立循环求值
     </p>
    </blockquote>
    <pre><code class="language-python">for t in range(min_value + 1, max_value, 1):
    # 定义一个列表用来存储前景像素点
    foreground = []

    # 定义一个列表用来存储后景像素点
    background = []

    # 定义一个变量用来存储前景的像素值的总数
    forepix = 0

    # 定义一个变量用来存储后景的像素值的总数
    backpix = 0

    # 定义一个变量用来求灰度图中所有的像素值的和
    pix = 0

    # 使用嵌套的for循环去遍历灰度图，用来区分在当前阈值下哪些点是前景点，哪些点是背景点
    for i in range(image_shape[0]):
        for j in range(image_shape[1]):
            # 将灰度图的每个像素点去和阈值进行比较，如果大于阈值就是前景像素点
            if image_gray[i, j] &gt; t:
                # 将前景像素点放到列表，方便后续去计算个数
                foreground.append([i, j])
                # 求前景像素点的总像素值
                forepix += image_gray[i, j]
                # 将该像素点的像素值加到pix里，用来统计图像的总像素值
                pix += image_gray[i, j]
            else:
                # 将后景像素点放到列表，方便后续去计算个数
                background.append([i, j])
                # 求后景像素点的总像素值
                backpix += image_gray[i, j]
                # 将该像素点的像素值加到pix里，用来统计图像的总像素值
                pix += image_gray[i, j]
    # 获取前景像素点数
    n_0 = len(foreground)
    # 获取背景像素点数
    n_1 = len(background)
    # 通过计算获取w0
    w_0 = n_0 / (image_shape[0] * image_shape[1])
    # 通过计算获取w1
    w_1 = n_1 / (image_shape[0] * image_shape[1])
    # 通过计算获取前景的平均像素值
    u_0 = forepix / n_0
    # 通过计算获取背景的平均像素值
    u_1 = backpix / n_1
    # 通过计算获取整幅图的平均像素值
    u = pix / (image_shape[0] * image_shape[1])

    # 通过最大类间方差公式去计算当前阈值下的最大类间方差的结果
    g = w_0 * ((u_0 - u) ** 2) + w_1 * ((u_1 - u) ** 2)

    # 将获取到的最大类间方差值和对于的阈值一块存储到字典中，方便后续选出最大值
    var[t] = g</code></pre>
    <blockquote>
     <p>
      进行二值化操作
     </p>
    </blockquote>
    <pre><code class="language-python">thresh = max(var, key=var.get)

# 使用一个嵌套循环去进行二值化操作
for i in range(image_shape[0]):
    for j in range(image_shape[1]):
        # 使用if判断灰度图中的第i行第j列的像素点的像素值与阈值的大小关系
        # 如果灰度图的第i行第j列比阈值大，就将该像素设置为maxval
        if image_gray[i, j] &gt; thresh:
            image_thresh[i, j] = maxval
        # 否则的话，就设置为0
        else:
            image_thresh[i, j] = 0</code></pre>
    <blockquote>
     <p>
      显示结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('image_thresh', image_thresh)
cv2.waitKey(0)</code></pre>
    <h3 style="background-color:transparent">
     5.2、内置函数
    </h3>
    <blockquote>
     <p>
      导入模块
     </p>
    </blockquote>
    <pre><code class="language-python">import cv2
import numpy as np</code></pre>
    <blockquote>
     <p>
      读取图像
     </p>
    </blockquote>
    <pre><code class="language-python">img=cv2.imread('light.jpg')</code></pre>
    <blockquote>
     <p>
      图像灰度化
     </p>
    </blockquote>
    <pre><code class="language-python">img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</code></pre>
    <blockquote>
     利用函数threshold
    </blockquote>
    <pre><code class="language-python"># 注意：OTSU在使用时候，需要配合其他的二值化方法去进行，其模式就是 cv2.THRESH_OTSU + 要二值化的方法的参数
ret, image_thresh = cv2.threshold(image_gray, thresh, maxval, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</code></pre>
    <blockquote>
     <p>
      得出结果
     </p>
    </blockquote>
    <pre><code class="language-python">cv2.imshow('img_thresh',img_thresh)
cv2.waitKey(0)</code></pre>
    <h2>
     六、其余二值化方法
    </h2>
    <h3>
     6.1、低阈值零处理
    </h3>
    <p>
     低阈值零处理(THRESH_TOZERO)： 就是像素值小于等于阈值的部分被置 为0（也就是黑色），大于阈值的部 分不变。
    </p>
    <h3>
     6.2、超阈值零处理
    </h3>
    <p>
     超阈值零处理(THRESH_TOZERO_INV): 就是将灰度图中的每个像素与阈值进行 比较，像素值大于阈值的部分置为0 （也就是黑色），像素值小于等于阈值 的部分不变。
    </p>
    <h2>
     七、库函数
    </h2>
    <h3>
     7.1、threshold()
    </h3>
    <p>
     将固定级别的阈值应用于每个数组元素。
    </p>
    <p>
     该函数将固定级别的阈值应用于多通道数组。该函数通常用于从灰度图像中获取双层（二进制）图像（
     <a href="https://docs.opencv.org/4.11.0/d2/de8/group__core__array.html#ga303cfb72acf8cbb36d884650c09a3a97" rel="nofollow" title="compare">
      compare
     </a>
     也可用于此目的）或用于去除噪声，即过滤掉值太小或太大的像素。该函数支持多种类型的阈值。它们由 type parameter 确定。
    </p>
    <p>
     此外，特殊值
     <a href="https://docs.opencv.org/4.11.0/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff" rel="nofollow" title="THRESH_OTSU">
      THRESH_OTSU
     </a>
     或
     <a href="https://docs.opencv.org/4.11.0/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a22ffcf680811aed95be6c7f5cd809621" rel="nofollow" title="THRESH_TRIANGLE">
      THRESH_TRIANGLE
     </a>
     可以与上述值之一结合使用。在这些情况下，该函数使用 Otsu 或 Triangle 算法确定最佳阈值，并使用它而不是指定的阈值。
    </p>
    <blockquote>
     <p>
      注意
     </p>
     <p>
      目前，Otsu 和 Triangle 方法仅针对 8 位单通道图像实现。
     </p>
    </blockquote>
    <pre><code class="language-python">cv.threshold(src, thresh, maxval, type[, dst]) -&gt;retval, dst</code></pre>
    <table border="1" cellpadding="1" cellspacing="1" style="width:666px">
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        src
       </td>
       <td>
        输入数组 （多通道、8 位或 32 位浮点）
       </td>
      </tr>
      <tr>
       <td>
        thresh
       </td>
       <td>
        <p style="margin-right:15px; text-align:start">
         <span style="background-color:var(--memdef-title-background-color)">
          <span style="color:#000000">
           阈值
          </span>
         </span>
        </p>
       </td>
      </tr>
      <tr>
       <td>
        maxval
       </td>
       <td>
        Maximum 值，用于
        <a href="https://docs.opencv.org/4.11.0/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59" rel="nofollow" title="THRESH_BINARY">
         THRESH_BINARY
        </a>
        和
        <a href="https://docs.opencv.org/4.11.0/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754" rel="nofollow" title="THRESH_BINARY_INV">
         THRESH_BINARY_INV
        </a>
        阈值类型。
       </td>
      </tr>
      <tr>
       <td>
        type
       </td>
       <td>
        阈值类型
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
     </p>
     <p>
      注意：
     </p>
     <p>
      该方法有两个返回值retval、dst
     </p>
    </blockquote>
    <blockquote>
     <p>
      阈值作的类型
     </p>
     <p class="img-center">
      <img alt="" height="663" src="https://i-blog.csdnimg.cn/img_convert/18961ba69609dd991f4e8d91ee369507.png" width="513"/>
     </p>
    </blockquote>
    <table border="1">
     <tbody>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        THRESH_BINARY
        <div>
         Python: cv.THRESH_BINARY
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           阈值法
          </span>
         </strong>
        </div>
       </td>
       <td>
        <img alt="" height="90" src="https://i-blog.csdnimg.cn/direct/6ddb57c748b34dfb97045ed89bfd653b.png" width="489"/>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754" name="ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754">
        </a>
        THRESH_BINARY_INV
        <div>
         Python: cv.THRESH_BINARY_INV
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           反阈值法
          </span>
         </strong>
        </div>
       </td>
       <td>
        <img alt="" height="82" src="https://i-blog.csdnimg.cn/direct/c3dad95f5bcb491b8b1ee1270758d2f5.png" width="495"/>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8" name="ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8">
        </a>
        THRESH_TRUNC
        <div>
         Python: cv.THRESH_TRUNC
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           截断阈值法
          </span>
         </strong>
        </div>
       </td>
       <td>
        <img alt="" height="78" src="https://i-blog.csdnimg.cn/direct/0f4269d5399a4604835403d7ebfdfb27.png" width="531"/>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98" name="ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98">
        </a>
        THRESH_TOZERO
        <div>
         Python: cv.THRESH_TOZERO
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           低阈值零处理
          </span>
         </strong>
        </div>
       </td>
       <td>
        <img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/b30d2b299fc04d649afd1f4a06cd54b8.png" width="513"/>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50" name="ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50">
        </a>
        THRESH_TOZERO_INV
        <div>
         Python: cv.THRESH_TOZERO_INV
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           超阈值零处理
          </span>
         </strong>
        </div>
       </td>
       <td>
        <img alt="" height="73" src="https://i-blog.csdnimg.cn/direct/b2524a8d049f44de8739782b837ba44e.png" width="514"/>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576a8e723ef461a5349c391032aee325fe15" name="ggaa9e58d2860d4afa658ef70a9b1115576a8e723ef461a5349c391032aee325fe15">
        </a>
        THRESH_MASK
        <div>
         Python: cv.THRESH_MASK
        </div>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff" name="ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff">
        </a>
        THRESH_OTSU
        <div>
         Python: cv.THRESH_OTSU
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           OTSU阈值法
          </span>
         </strong>
        </div>
       </td>
       <td>
        flag 中，使用 Otsu 算法选择最佳阈值
       </td>
      </tr>
      <tr>
       <td style="vertical-align:top; white-space:nowrap">
        <a id="ggaa9e58d2860d4afa658ef70a9b1115576a22ffcf680811aed95be6c7f5cd809621" name="ggaa9e58d2860d4afa658ef70a9b1115576a22ffcf680811aed95be6c7f5cd809621">
        </a>
        THRESH_TRIANGLE
        <div>
         Python: cv.THRESH_TRIANGLE
        </div>
        <div>
         <strong>
          <span style="color:#0d0016">
           Triangle阈值法
          </span>
         </strong>
        </div>
       </td>
       <td>
        标志，使用 Triangle 算法选择最佳阈值
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36343131303538392f:61727469636c652f64657461696c732f313435393831383032" class_="artid" style="display:none">
 </p>
</div>


