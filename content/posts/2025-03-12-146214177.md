---
layout: post
title: "学习笔记逆向工程核心原理03.abexcrackme-2函数的调用约定视频讲座-Tut.ReverseMe1"
date: 2025-03-12 20:30:39 +0800
description: "也就是说，进程运行时确定栈内存的大小（与malloc/new动态分配内存不同）。"
keywords: "【学习笔记】《逆向工程核心原理》03.abex‘crackme-2、函数的调用约定、视频讲座-Tut.ReverseMe1"
categories: ['未分类']
tags: ['逆向工程', '逆向', '笔记', '学习', 'Vb', 'Crackme']
artid: "146214177"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146214177
    alt: "学习笔记逆向工程核心原理03.abexcrackme-2函数的调用约定视频讲座-Tut.ReverseMe1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146214177
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146214177
cover: https://bing.ee123.net/img/rand?artid=146214177
image: https://bing.ee123.net/img/rand?artid=146214177
img: https://bing.ee123.net/img/rand?artid=146214177
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【学习笔记】《逆向工程核心原理》03.abex‘crackme-2、函数的调用约定、视频讲座-Tut.ReverseMe1
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <br/>
    <strong>
     思维导图
    </strong>
    <br/>
    <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2e848308ec1544d0af9104ba4724f183.png">
     <p>
     </p>
     <h2>
      <a id="abexcrackme2_3">
      </a>
      abex’crackme-2
     </h2>
     <p>
      运行这个程序
      <br/>
      <img alt="Pasted image 20250312125103" src="https://i-blog.csdnimg.cn/img_convert/13fe1f6e2c09af3c0d3eb75eba57c501.png">
       <br/>
       要求我们输入正确的账户与序列号
      </img>
     </p>
     <h3>
      <a id="1_Visual_Basic_8">
      </a>
      1. Visual Basic文件的特征
     </h3>
     <blockquote>
      <p>
       Visual Basic（VB）文件现在已经不太常见了，尤其是在现代开发环境中。微软早在 2008 年就停止了对 VB6（经典 Visual Basic）的官方支持，而 VB.NET 作为 .NET 生态的一部分，虽然仍然在维护，但在开发者社区中的使用率已经大幅下降
      </p>
     </blockquote>
     <p>
      此crackme是由 Visual Basic编写而成的。所以我们可以先了解一下其特征
     </p>
     <h4>
      <a id="11_VB_12">
      </a>
      1.1. VB专用引擎
     </h4>
     <p>
      VB文件使用名为
      <code>
       MSVBVM60.dll
      </code>
      （MicrosoftVisual BasicVirtual Machine6.0)的VB专用引擎（也称为TheThunder Runtime Engine)。
      <br/>
      举个使用VB引擎的例子，显示消息框时，VB代码中要调用
      <code>
       MsgBox
      </code>
      函数。其实，VB编辑器真正调用的是
      <code>
       MSVBVM60.dll
      </code>
      里的
      <code>
       rtcMsgBox
      </code>
      函数，在该函数内部通过调用
      <code>
       user32.dll
      </code>
      里的
      <code>
       MessageBoxW
      </code>
      函数（Win32API）来工作（也可以在VB代码中直接调用
      <code>
       user32.dll
      </code>
      里的
      <code>
       MessageBoxW
      </code>
      。
     </p>
     <h4>
      <a id="12__15">
      </a>
      1.2. 本地代码与伪代码
     </h4>
     <p>
      根据使用的编译选项的不同，VB文件可以编译为
      <strong>
       本地代码
      </strong>
      （Ncode）与
      <strong>
       伪代码
      </strong>
      （Pcode)。
      <br/>
      <strong>
       本地代码一般使用易于调试器解析的IA-32指令
      </strong>
      <br/>
      <strong>
       伪代码是一种解释器（Interpreter）语言
      </strong>
      ，它使用由VB引擎实现虚拟机并可自解析的指令（字节码）。因此，若想准确解析VB的伪代码，就需要分析VB引擎并实现模拟器。
     </p>
     <h4>
      <a id="13__19">
      </a>
      1.3. 事件处理程序
     </h4>
     <p>
      VB主要用来编写GUI程序，IDE用户界面本身也最适合于GUI编程。由于VB程序采用Windows操作系统的事件驱动方式工作，所以在
      <code>
       main
      </code>
      或
      <code>
       WinMain
      </code>
      中并不存在用户代码（希望调试的代码），用户代码存在于各个事件处理程序（eventhandler）之中。
      <br/>
      就上述abex’crackme ，用户代码在点击Check按钮时触发的事件处理程序内。
     </p>
     <h4>
      <a id="14__23">
      </a>
      1.4. 未文档化的结构体
     </h4>
     <p>
      VB中使用的各种信息（Dialog、Control、Form、Module、Function等）以结构体形式保存在文件内部。由于微软未正式公开这种结构体信息，所以调试VB文件会难一些。
     </p>
     <h3>
      <a id="2__26">
      </a>
      2. 开始调试
     </h3>
     <p>
      首先在EP代码中找到调用VB引擎的主函数
      <code>
       ThunRTMain()
      </code>
      <br/>
      <img alt="Pasted image 20250312130223" src="https://i-blog.csdnimg.cn/img_convert/e5db61c9e2fd8f6ff2da0815396109ba.png"/>
     </p>
     <pre><code class="prism language-c"><span class="token number">00401232</span>   $<span class="token operator">-</span> FF25 A0104000 jmp     dword ptr ds<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">0x4010A0</span><span class="token punctuation">]</span>          <span class="token punctuation">;</span>  msvbvm60<span class="token punctuation">.</span>ThunRTMain
<span class="token number">00401238</span> <span class="token operator">&gt;</span> $  <span class="token number">68</span> <span class="token number">141E4000</span>   push    <span class="token number">0x401E14</span>
<span class="token number">0040123</span>D   <span class="token punctuation">.</span>  E8 F0FFFFFF   call    <span class="token number">00401232</span>                         <span class="token punctuation">;</span>  <span class="token operator">&lt;</span>jmp<span class="token punctuation">.</span><span class="token operator">&amp;</span>MSVBVM60<span class="token punctuation">.</span>#<span class="token number">100</span><span class="token operator">&gt;</span>
</code></pre>
     <p>
      分析一下几条命令
      <br/>
      <code>
       00401238
      </code>
      是EP的地址、命令
      <code>
       push 0x401E14
      </code>
      把
      <code>
       RT_MainStruct
      </code>
      结构体的地址
      <code>
       401E14
      </code>
      压入栈。
      <br/>
      然后
      <code>
       call 00401232
      </code>
      调用
      <code>
       401232
      </code>
      处的指令。 即会跳转到VB引擎的主函数
      <code>
       ThunRTMain()
      </code>
      （前面压入栈的401E14 的值作为
      <code>
       ThunRTMain()
      </code>
      的参数）
     </p>
     <p>
      这就是VB文件的全部启动代码，非常简单
     </p>
     <h4>
      <a id="21__39">
      </a>
      2.1. 间接调用
     </h4>
     <p>
      <code>
       40123D
      </code>
      地址处的
      <code>
       CALL 401232
      </code>
      命令用于调用
      <code>
       ThunRTMain
      </code>
      函数，这里使用了较为特别的技法。
      <strong>
       不是直接转到
       <code>
        MSVBVM60.dll
       </code>
       里的
       <code>
        ThunRTMain
       </code>
       函数，而是通过中间
       <code>
        401232
       </code>
       地址处的
       <code>
        JMP
       </code>
       命令跳转
      </strong>
      。
     </p>
     <p>
      <strong>
       这是VC++ 、VB编译器中常用的间接调用法
      </strong>
     </p>
     <blockquote>
      <p>
       <code>
        4010A0
       </code>
       地址是IAT(Import Address Table，导入地址表)区域，包含着
       <code>
        MSVBVM60.ThunRTMain
       </code>
       函数的实际地址
       <img alt="Pasted image 20250312131429" src="https://i-blog.csdnimg.cn/img_convert/e54a9dd7fe267b0b0645eed54b4f4c43.png"/>
      </p>
     </blockquote>
     <h4>
      <a id="22_RT_MainStruct_46">
      </a>
      2.2. RT_MainStruct结构体
     </h4>
     <p>
      要注意的是
      <code>
       ThunRTMain
      </code>
      函数的参数
      <code>
       RT_MainStruct
      </code>
      结构体。这里，
      <code>
       RT_MainStruct
      </code>
      结构体存在于
      <code>
       401E14
      </code>
      地址处，如图所示。
      <br/>
      <img alt="Pasted image 20250312131808" src="https://i-blog.csdnimg.cn/img_convert/7e39cea3553c38150ae36ad720eb400f.png">
       <br/>
       微软未公开
       <code>
        RT_MainStruct
       </code>
       ，但是有国外的逆向分析高手已经完成了对
       <code>
        RTMainStruct
       </code>
       结构体的分析，并公布在网络上。
       <br/>
       <code>
        RT_MainStruct
       </code>
       结构体的成员是其他结构体的地址。也就是说，VB引擎通过参数传递过来的
       <code>
        RT_MainStruct
       </code>
       结构体获取程序运行需要的所有信息。此处省略对RT_MainStruct结构体的详细说明。
      </img>
     </p>
     <h4>
      <a id="23_ThunRTMain_52">
      </a>
      2.3. ThunRTMain()函数
     </h4>
     <p>
      图中显示了
      <code>
       ThunRTMain
      </code>
      代码的开始部分，可以看到
      <strong>
       内存地址完全不同
      </strong>
      了。这是
      <code>
       MSVBVM60.dII
      </code>
      模块的地址区域。换言之，我们分析的不是程序代码，而是VB引擎代码（现在还不需要分析如此庞大的代码）
      <br/>
      <img alt="Pasted image 20250312132133" src="https://i-blog.csdnimg.cn/img_convert/392b94c30afd19fbf80d353a4649ce52.png"/>
     </p>
     <h3>
      <a id="3_crackme_56">
      </a>
      3. 分析crackme
     </h3>
     <p>
      当前我们很难直接去分析
      <code>
       RT_MainStruct
      </code>
      结构体。 需要找一个更简单的方法
      <br/>
      我们可以通过程序提示的字符串入手。因为程序会提示错误后的信息
      <br/>
      <img alt="Pasted image 20250312132335" src="https://i-blog.csdnimg.cn/img_convert/3cafcd6fdcefdd9da0c18ea2a65f5de5.png"/>
     </p>
     <h4>
      <a id="31__60">
      </a>
      3.1. 检索字符串
     </h4>
     <p>
      <strong>
       查找-&gt;所有参考字符串
      </strong>
      <br/>
      <img alt="Pasted image 20250312132920" src="https://i-blog.csdnimg.cn/img_convert/be6ac9b2020e723094b8ab604c388626.png"/>
      <br/>
      双击跳转
      <br/>
      <img alt="Pasted image 20250312133052" src="https://i-blog.csdnimg.cn/img_convert/695a47fdb861e33926051def1a0eca4c.png"/>
      <br/>
      我们这里找到了消息提示的调用函数
      <br/>
      根据逻辑判断。看到是会根据我们的
      <code>
       name
      </code>
      生成一个序列号。然后判断是否正确，然后回显信息
      <br/>
      这里我们往上翻 去找一下那个判断语句，而
      <strong>
       判断语句一般就是一个跳转命令
      </strong>
      <br/>
      <img alt="Pasted image 20250312135505" src="https://i-blog.csdnimg.cn/img_convert/f382d9d40e433e4277d1d101876fab53.png"/>
      <br/>
      通过上面
      <code>
       call dword ptr ds:[0x401058]
      </code>
      命令调用
      <code>
       __vbaVarTstEq
      </code>
      函数比较（TEST命令）返回值（AX）后，由
      <code>
       403332
      </code>
      地址的条件转移指令（JE指令）决定执行“真”代码还是“假”代码。
     </p>
     <blockquote>
      <p>
       <strong>
        TEST:逻辑比较(Logical Compare)
       </strong>
       <br/>
       与bit-wiselogical“AND’一样（仅改变EFLAGS寄存器而不改变操作数的值)若2个操作数中一个为0，则AND运算结果被置为0-&gt;ZF=1。
      </p>
     </blockquote>
     <blockquote>
      <p>
       <strong>
        JE：条件转移指令（Jumpif equal)
       </strong>
       <br/>
       若ZF=1，则跳转。
      </p>
     </blockquote>
     <h4>
      <a id="32__76">
      </a>
      3.2. 查找字符串地址
     </h4>
     <p>
      我们现在已经找到了比较函数
      <code>
       __vbaVarTstEq
      </code>
      的地址，那么上面的两个push 就是传入的函数参数
      <br/>
      <img alt="Pasted image 20250312135935" src="https://i-blog.csdnimg.cn/img_convert/222ac71493026b057409ee7287d4e833.png"/>
      <br/>
      我们先调试到比较函数地址
      <code>
       403329
      </code>
      处
      <br/>
      我们观察上面的两处指令
      <br/>
      <img alt="Pasted image 20250312144711" src="https://i-blog.csdnimg.cn/img_convert/367e4233e60c9af1e91427810d588f80.png"/>
      <br/>
      这里
      <code>
       SS:[EBP-44]
      </code>
      指的是栈内地址。它恰好就是函数声明中的局部对象的地址（局部对象存储再栈区）
      <br/>
      下面信息显示了栈内地址为
      <code>
       19f288
      </code>
     </p>
     <p>
      我们可以通过 选中地址，然后在数据框中跟随地址 即可查看对应的内存地址
      <br/>
      <img alt="Pasted image 20250312145117" src="https://i-blog.csdnimg.cn/img_convert/8671b808dffcd4c3a6f4ea7baf1a216e.png"/>
      <br/>
      查看存储在栈中的内存地址
      <br/>
      <img alt="Pasted image 20250312145220" src="https://i-blog.csdnimg.cn/img_convert/2386607c418377868ae4437a27b8ad04.png"/>
      <br/>
      这里与C++的string类一样，VB 字符串使用可变长度的字符串类型。 如图，
      <strong>
       直接显示的不是字符串，而是16字节大小的数据
      </strong>
      （这就是VB中使用的字符串对象）
      <br/>
      不同的值被这样统一起来，
      <strong>
       仅方框显示的值是不同的
      </strong>
      ，看上去
      <strong>
       就像内存地址一样
      </strong>
      （可变长度字符串类型内部持有实际动态分配的字符串缓存地址）
     </p>
     <p>
      我们右键选择ASCII数据类型 即可查看到我们
      <strong>
       实际输入的值
      </strong>
      与
      <strong>
       进行对比的值
      </strong>
      <br/>
      <img alt="Pasted image 20250312145934" src="https://i-blog.csdnimg.cn/img_convert/baa526afafbf08a1fb0c7ca312380c4c.png"/>
      <br/>
      切回来选择这个
      <br/>
      <img alt="Pasted image 20250312150014" src="https://i-blog.csdnimg.cn/img_convert/1fda6f0967e084d85bb5bf52aa371ece.png"/>
     </p>
     <p>
      <img alt="Pasted image 20250312150408" src="https://i-blog.csdnimg.cn/img_convert/bff5e3b746bf7a7411e8dc6af23845ab.png"/>
      <br/>
      如图
      <br/>
      EAX
      <code>
       19f298
      </code>
      是我们输入的值 123456 字符串所在的地址是
      <code>
       66145c
      </code>
      <br/>
      EDX
      <code>
       19f288
      </code>
      是实际的序列号 C795D8D6 字符串所在地址是
      <code>
       6615c4
      </code>
      <br/>
      我们可以查看一下
      <br/>
      <img alt="Pasted image 20250312150812" src="https://i-blog.csdnimg.cn/img_convert/70810f89691b8bcfc8efd7decff4a57f.png"/>
     </p>
     <blockquote>
      <p>
       VB默认使用基于Unicode的可变长度字符串对象。可变长度字符串对象会根据需要在内部随时动态分配/释放内存。因此，每次运行时字符串的地址会有所不同。此外，调试时无法一眼看全实际字符串，这也是调试的困难之一。
      </p>
     </blockquote>
     <p>
      下面我们运行程序 输入对应的名字与序列号即可弹出正确的信息
      <br/>
      <img alt="Pasted image 20250312151122" src="https://i-blog.csdnimg.cn/img_convert/f09151ae51a56a22e086085a7bb95521.png"/>
     </p>
     <h4>
      <a id="33_Serial_108">
      </a>
      3.3. 生成Serial的算法
     </h4>
     <p>
      这里我们探讨一下生成序列号的算法。 我们只知道了
      <code>
       c1trus
      </code>
      对应的序列号是
      <code>
       C795D8D6
      </code>
      <br/>
      那我们想批量生成序列号，肯定需要知道其算法
     </p>
     <p>
      <strong>
       查找函数开始部分
      </strong>
      <br/>
      我们上面找到了一个
      <strong>
       条件转移的代码
      </strong>
      。 那个应该就是check后进行的操作。当我们点击check后，这个计算序列号的函数就会被调用执行。然后就会进行对比，并弹出消息框
     </p>
     <p>
      所以我们应该往上一点点找函数开始的部分。
      <br/>
      而且结合 [[07.栈帧]]中的知识。我们知道在执行函数之前会生成栈帧
      <br/>
      通常命令是
      <code>
       PUSH EBP
      </code>
      然后
      <code>
       MOV EBP，ESP
      </code>
      <br/>
      那我们就着重看这个命令，也可以直接查找。
      <br/>
      很容易就找到了生成栈帧的代码
      <br/>
      <img alt="Pasted image 20250312152114" src="https://i-blog.csdnimg.cn/img_convert/23cc73484cc04f121a9415fbd79822a9.png"/>
      <br/>
      可以发现上面有大量的 nop命令
     </p>
     <blockquote>
      <p>
       VB文件的函数之间存在着NOP指令（图8-14的402ECC~402ECF地址区)。NOP:NoOperation,不执行任何动作的指令（只消耗CPU时钟)。
      </p>
     </blockquote>
     <p>
      为了方便分析代码。我们先在此处下断点
     </p>
     <h4>
      <a id="34__125">
      </a>
      3.4. 预测代码
     </h4>
     <p>
      如果你有经验，就可以预测出生成序列号的方法，若是win32API程序
      <br/>
      则一般有一下特点
     </p>
     <ul>
      <li>
       读取Name字符串（使用
       <code>
        GetWindowsText
       </code>
       、
       <code>
        GetDlgItemText
       </code>
       等API）
      </li>
      <li>
       启动循环，对字符进行加密（
       <code>
        XOR
       </code>
       <code>
        ADD
       </code>
       <code>
        SUB
       </code>
       等）
       <br/>
       VB引擎编写的文件也有类似的规律，如果正确的化，我们从断点处开始调试，查找到读取
       <code>
        name
       </code>
       字符串的那部分后，紧接着就是加密循环
      </li>
     </ul>
     <h4>
      <a id="35_name_131">
      </a>
      3.5. 读取name字符串的代码
     </h4>
     <p>
      开始调试后我们会遇到好几个
      <code>
       call
      </code>
      <br/>
      直到调试到第四个
      <code>
       call
      </code>
      <br/>
      <img alt="Pasted image 20250312153525" src="https://i-blog.csdnimg.cn/img_convert/39c3ae18cc61b473c9fb8906b8fad09d.png"/>
      <br/>
      上面的
      <code>
       lea edx,dword ptr ss:[ebp-0x88]
      </code>
      指令把函数的局部对象
      <code>
       ss:[ebp-0x88]
      </code>
      地址传递给了函数的参数。 我们可以看一下这个地址
      <br/>
      <img alt="Pasted image 20250312160419" src="https://i-blog.csdnimg.cn/img_convert/c873187027610a9e9f6546d3c0aba73a.png"/>
     </p>
     <blockquote>
      <p>
       因为要查找的是Name字符串，在VB中，字符串使用字符串对象（这与C语言使用char数组不同）我们很难认出实际的字符串，所以需要调整一下
       <strong>
        地址视图的模式
       </strong>
      </p>
     </blockquote>
     <p>
      然后继续调试到
      <code>
       call
      </code>
      函数之后
      <br/>
      <img alt="Pasted image 20250312160732" src="https://i-blog.csdnimg.cn/img_convert/46f5608db07f9d970d86a248f4df8175.png"/>
      <br/>
      这里我们可以可以看到
      <code>
       name
      </code>
      字符串的值了。 其地址就是
      <code>
       19F244
      </code>
      就是
      <code>
       EBP-88
      </code>
     </p>
     <h4>
      <a id="36__143">
      </a>
      3.6. 加密循环
     </h4>
     <p>
      继续调试就会遇到以下循环。一系列的循环语句
      <br/>
      <img alt="Pasted image 20250312161137" src="https://i-blog.csdnimg.cn/img_convert/8289741f244932565e7169903a9d8dbe.png"/>
      <br/>
      <img alt="Pasted image 20250312161215" src="https://i-blog.csdnimg.cn/img_convert/83b4ae057516c69b0ecda2c2ac3e013c.png"/>
      <br/>
      <img alt="Pasted image 20250312161305" src="https://i-blog.csdnimg.cn/img_convert/40826f152ec080f2506ccd6962c6073a.png"/>
     </p>
     <p>
      简单讲解上述循环的动作原理，就像在链表中使用next指针引用下一个元素一样，
      <br/>
      <code>
       __vbaVarForInit
      </code>
      、
      <code>
       __vbaVarForNext
      </code>
      可以使逆向分析人员在字符串对象中逐个引I用字符。并且设置loopcount（EBX）使其按指定次数运转循环。
     </p>
     <blockquote>
      <p>
       实测仅使用接收的Name字符串中的前4个字符。在代码内检查字符串的长度，若少于4个字符，就会弹出错误消息框。
      </p>
     </blockquote>
     <h4>
      <a id="37__154">
      </a>
      3.7. 加密方法
     </h4>
     <p>
      这里太难整了。我先跳过了。等以后再来分析
     </p>
     <h2>
      <a id="_157">
      </a>
      函数的调用约定
     </h2>
     <h3>
      <a id="1__158">
      </a>
      1. 函数调用约定
     </h3>
     <p>
      CallingConvention译成中文是“函数调用约定”，
      <strong>
       它是对函数调用时如何传递参数的一种约定
      </strong>
      。
      <br/>
      通过前面的学习已经知道，调用函数前要先把参数压人栈然后再传递给函数。
      <strong>
       栈就是定义在进程中的一段内存空间，向下（低地址方向）扩展，且其大小被记录在PE头中
      </strong>
      。也就是说，进程运行时确定栈内存的大小（与malloc/new动态分配内存不同）。
     </p>
     <p>
      <strong>
       提问1
      </strong>
      .函数执行完成后，栈中的参数如何处理？
      <br/>
      <strong>
       回答1
      </strong>
      .不用管。
      <br/>
      由于只是临时使用存储在栈中的值，即使不再使用，清除工作也会浪费CPU资源。下一次再向栈存人其他值时，原有值会被自然覆盖掉，并且栈内存是固定的，所以既不能也没必要释放内存。
      <br/>
      <strong>
       提问2
      </strong>
      .函数执行完毕后，ESP值如何变化？
      <br/>
      <strong>
       回答2
      </strong>
      .ESP值要恢复到函数调用之前，这样可引用的栈大小才不会缩减。栈内存是固定的，ESP用来指示栈的当前位置，若ESP指向栈底，则无法再使用该栈。函数调用后如何处理ESP，这就是函数调用约定要解决的问题。主要的函数调用约定如下。
      <br/>
      <code>
       cdecl
      </code>
      <br/>
      <code>
       stdcall
      </code>
      <br/>
      <code>
       fastcall
      </code>
      <br/>
      应用程序的调试中，cdecl与stdcall的区别非常明显。不管采用哪种方式，通过栈来传递参数的基本概念都是一样的。
     </p>
     <blockquote>
      <p>
       <strong>
        调用者
       </strong>
       ——调用函数的一方。
       <br/>
       <strong>
        被调用者
       </strong>
       ——被调用的函数。
       <br/>
       比如在
       <code>
        main
       </code>
       函数中调用
       <code>
        printf
       </code>
       函数时，调用者为
       <code>
        main
       </code>
       ，被调用者为
       <code>
        printf
       </code>
      </p>
     </blockquote>
     <h4>
      <a id="11_cdecl_176">
      </a>
      1.1. cdecl
     </h4>
     <p>
      cdecl是主要在C语言中使用的方式，调用者负责处理栈
      <br/>
      示例代码
     </p>
     <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc <span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     <p>
      编译后进行调试
      <br/>
      <img alt="Pasted image 20250312184125" src="https://i-blog.csdnimg.cn/img_convert/44271a91fe90dea5ef44925ecb365085.png"/>
      从图中
      <code>
       401013~40101C
      </code>
      地址间的代码可以发现，
      <code>
       add
      </code>
      函数的参数
      <code>
       1、2
      </code>
      以逆序方式压人栈，
      <br/>
      调用
      <code>
       add
      </code>
      函数（401000）后，使用
      <code>
       ADD ESP,8
      </code>
      命令整理栈。调用者
      <code>
       main
      </code>
      函数直接清理其压人栈的函数参数，
      <strong>
       这样的方式即是cdecl
      </strong>
      。
     </p>
     <blockquote>
      <p>
       cdecl方式的好处在于，它可以像C语言的
       <code>
        printf
       </code>
       函数一样，
       <strong>
        向被调用函数传递长度可变的参数
       </strong>
       。这种长度可变的参数在其他调用约定中很难实现。
      </p>
     </blockquote>
     <h4>
      <a id="12_stdcall_196">
      </a>
      1.2. stdcall
     </h4>
     <p>
      stdcall方式常用于Win32API，该方式由被调用者清理栈。前面讲解过C语言默认的函数调用方式为cdecl。若想使用stdcall方式编译源码，只要使用
      <code>
       _stdcall
      </code>
      关键字即可
      <br/>
      示例代码
     </p>
     <pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span>
<span class="token keyword">int</span> _stdcall <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc <span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     <p>
      生成exe然后进行调试
      <br/>
      从图中的代码可以看到，在
      <code>
       main
      </code>
      函数中调用
      <code>
       add
      </code>
      函数后，
      <strong>
       省略了清理栈的代码
      </strong>
      （
      <code>
       ADD ESP,8
      </code>
      )。栈的清理工作由
      <code>
       add
      </code>
      函数中最后（40100A）的
      <code>
       RETN 8
      </code>
      命令来执行。
      <code>
       RETN 8
      </code>
      命令的含义为
      <code>
       RETN+POP 8
      </code>
      字节，即返回后使ESP增加到指定大小
      <br/>
      <img alt="Pasted image 20250312184056" src="https://i-blog.csdnimg.cn/img_convert/a869434f5bbb73530c2d383c7bae883c.png"/>
     </p>
     <p>
      像这样
      <strong>
       在被调用者
       <code>
        add
       </code>
       函数内部清理栈的方式即为stdcall方式
      </strong>
      。
      <br/>
      stdcall方式的好处在于，被调用者函数内部存在着栈清理代码，与每次调用函数时都要用
      <code>
       ADD ESP,XXX
      </code>
      命令的cdecl方式相比，
      <strong>
       代码尺寸要小
      </strong>
      。
      <br/>
      虽然Win32API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。这是为了获得更好的兼容性，使C语言之外的其他语言（Delphi(Pascal)、VisualBasic等）也能直接调用API。
     </p>
     <h4>
      <a id="13_fastcall_218">
      </a>
      1.3. fastcall
     </h4>
     <p>
      fastcall方式与stdcall方式基本类似，但该方式
      <strong>
       通常会使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前2个）
      </strong>
      。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。
      <br/>
      顾名思义，fastcall方式的
      <strong>
       优势在于可以实现对函数的快速调用
      </strong>
      （从CPU的立场看，访问寄存器的速度要远比内存快得多）。单
      <strong>
       从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器
      </strong>
      。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外，如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。
     </p>
     <h2>
      <a id="TutReverseMe1_222">
      </a>
      视频讲座-Tut.ReverseMe1
     </h2>
     <p>
      一位名叫Lena的人在 http://www.tuts4you.com/ 公示板上贴了40个crackme讲座，以帮助初学者学习代码逆向分析技术。这些讲座非常受欢迎，因为所有讲座都以Flash视频形式呈现出来，且让学习者感到非常亲切。各位可以链接到tuts4you网站观看这些视频讲座，这对学习代码逆向分析技术非常有帮助。
     </p>
     <h3>
      <a id="1__224">
      </a>
      1. 运行
     </h3>
     <p>
      运行要破解的程序 给我们了两条信息
      <br/>
      <img alt="Pasted image 20250312185009" src="https://i-blog.csdnimg.cn/img_convert/9f02e9a5211ed32cc76fb875cfabc556.png"/>
      <br/>
      就是说叫我们 去除提示框 并找到正确的注册码
     </p>
     <h3>
      <a id="2__228">
      </a>
      2. 分析
     </h3>
     <h4>
      <a id="21__229">
      </a>
      2.1. 去除消息框
     </h4>
     <p>
      打开后发现也是用VB编写的软件，因为我们在EP中发现了
      <code>
       ThunRTMain
      </code>
      <br/>
      <img alt="Pasted image 20250312185606" src="https://i-blog.csdnimg.cn/img_convert/b67c642622719fadd7f6a94358d259b8.png"/>
     </p>
     <p>
      而且我们知道VB中调用消息框的函数是
      <code>
       rtcMsgBox
      </code>
      <br/>
      然后我们在调用模块中去查找，可以发现有三次调用此函数
      <br/>
      <img alt="Pasted image 20250312190237" src="https://i-blog.csdnimg.cn/img_convert/3d2f2c80a173738b41f5f861aeb1a967.png"/>
      <br/>
      在每一处调用都设置一个断点
      <br/>
      <img alt="Pasted image 20250312190333" src="https://i-blog.csdnimg.cn/img_convert/5e5682bd1e8f2d41fd299af027d94eac.png"/>
      <br/>
      然后运行程序
      <br/>
      发现程序在
      <code>
       402CFE
      </code>
      处断了下来，此时应该就是要调用函数进行显示消息了。那么上面多半就有要显示的消息。果不其然，上面确实可以发现将要显示的消息
      <br/>
      <img alt="Pasted image 20250312190608" src="https://i-blog.csdnimg.cn/img_convert/b5d694681bc459a4dae83b9bbdd0b49f.png"/>
     </p>
     <p>
      然后我们继续运行，我们找一下程序中点击
      <code>
       nag?
      </code>
      按钮后的断点在哪里
      <br/>
      发现还是断在了
      <code>
       402CFE
      </code>
      处。那么我们只要对这一处进行修复即可
      <br/>
      <img alt="Pasted image 20250312190941" src="https://i-blog.csdnimg.cn/img_convert/11ead65eb775dffafda145f91c4a351f.png"/>
     </p>
     <h4>
      <a id="22__245">
      </a>
      2.2. 打补丁去除消息框
     </h4>
     <h5>
      <a id="221__246">
      </a>
      2.2.1. 第一次尝试
     </h5>
     <p>
      我们先修改
      <code>
       402CFE
      </code>
      处的call命令
      <br/>
      原来的
      <br/>
      <img alt="Pasted image 20250312191210" src="https://i-blog.csdnimg.cn/img_convert/2cd3ae443de5afbd2ab7f3df6f6ffc75.png"/>
      <br/>
      修改后的
      <br/>
      <img alt="Pasted image 20250312191249" src="https://i-blog.csdnimg.cn/img_convert/3db1eb1ad63651d3481115f2c0ba3db5.png"/>
      <br/>
      <code>
       402CFE
      </code>
      地址处的
      <code>
       ADD ESP，14
      </code>
      命令的含义是，按照传递给
      <code>
       rtcMsgBox
      </code>
      参数的大小（14）清理栈。并用NOP填充其余2个字节，以保证代码不会乱（原来CALL命令的大小为5字节，ADD命令用3个字节，还余下2个字节）。
      <br/>
      看上去没有什么问题，但结果却“发生错误”。原因在于没有正确处理
      <code>
       rtcMsgBox
      </code>
      函数的返回值（EAX寄存器)。
     </p>
     <p>
      如图，在
      <code>
       402CFE
      </code>
      地址处调用
      <code>
       rtcMsgBox
      </code>
      函数后，
      <code>
       402D0C
      </code>
      地址处将返回值（EAX）存储到特定变量（EBP-9C）。此处消息框的返回值应该是1（表示“确定”按钮）。若存储的为1之外的值，则表示程序终止。那么最好试试其他方法。
      <br/>
      <img alt="Pasted image 20250312191746" src="https://i-blog.csdnimg.cn/img_convert/b77e32293ab45b48f5d5defef518dd67.png"/>
     </p>
     <blockquote>
      <p>
       (
       <strong>
        1)可以修改402CFE地址处的指令，如下所示。
       </strong>
       <br/>
       <code>
        ADD ESP,14
       </code>
       (Instruction:83C414)
       <br/>
       <code>
        MOV EAX,1
       </code>
       (Instruction:B801000000)
      </p>
      <p>
       以上两行汇编代码产生的结果与调用
       <code>
        rtcMsgBox
       </code>
       函数后用户按“确定”按钮的结果相同（栈与返回值相同)。之所以没有这样做是
       <strong>
        因为指令长度不合适
       </strong>
       。
       <strong>
        源文件
        <code>
         402CFE
        </code>
        地址处的命令长度为5字节，但上面2行汇编命令的长度为8个字节，因此会侵占到后面的代码
       </strong>
       。
      </p>
      <p>
       <strong>
        (2)x86（IA-32）系统中使用EAX寄存器传递函数的返回值。
       </strong>
      </p>
     </blockquote>
     <h5>
      <a id="222__266">
      </a>
      2.2.2. 第二次尝试
     </h5>
     <p>
      在断点处向上看可以发现
      <code>
       402C17
      </code>
      处表示函数开始的栈帧
      <br/>
      <img alt="Pasted image 20250312192122" src="https://i-blog.csdnimg.cn/img_convert/ef92db62e9c0fa72324ad640d0ad63de.png"/>
      <br/>
      <code>
       402CFE
      </code>
      的
      <code>
       rtcMsgBox
      </code>
      函数调用代码也是属于其他函数内部的代码。
      <strong>
       所以如果上层函数无法调用，或直接返回，最终将不会调用
       <code>
        rtcMsgBox
       </code>
       函数
      </strong>
      。像下面这样修改
      <code>
       401C17
      </code>
      处的指令（使用AssembleSpace指令）。
      <br/>
      <strong>
       原来的
      </strong>
      <br/>
      <img alt="Pasted image 20250312192226" src="https://i-blog.csdnimg.cn/img_convert/c9b4543acc1609e489f6ae4ca29bb78b.png"/>
      <br/>
      <strong>
       修改后
      </strong>
      <br/>
      <img alt="Pasted image 20250312192322" src="https://i-blog.csdnimg.cn/img_convert/eb35b553d57a19d9819844f258c32ea3.png"/>
     </p>
     <blockquote>
      <p>
       要根据传递给函数的参数大小跳转栈 （RETN XX）
      </p>
     </blockquote>
     <p>
      然后运行 发现就去除了消息框
     </p>
     <h5>
      <a id="223_401C17__277">
      </a>
      2.2.3. 如何查看401C17 函数的参数个数
     </h5>
     <p>
      首先找到
      <code>
       402C17
      </code>
      处函数的返回地址，在
      <code>
       402C17
      </code>
      下个断点，并运行到这里
      <br/>
      <img alt="Pasted image 20250312195055" src="https://i-blog.csdnimg.cn/img_convert/2197baa5fa0905f4f321e067661a3a28.png"/>
      <br/>
      然后可以在栈空间看到返回的地址是
      <code>
       7401E5A9
      </code>
      <br/>
      goto过去看返回地址上一条命令。即执行此命令后就完成
      <code>
       402C17
      </code>
      函数。并返回地址到
      <code>
       7401E5A9
      </code>
      <br/>
      <img alt="Pasted image 20250312195415" src="https://i-blog.csdnimg.cn/img_convert/04a4ddb2066f93bf4ea490682e8ea8e3.png"/>
      <br/>
      如图所示 返回地址
      <code>
       （7401E5A9)
      </code>
      。该代码区域是
      <code>
       MSVBVM50.dll
      </code>
      模块区域。执行
      <code>
       7401E5A7
      </code>
      地址处的
      <code>
       CALL EAX
      </code>
      指令后即返回
      <code>
       7401E5A9
      </code>
      地址处。再次运行调试器（Ctrl+F2)，在
      <code>
       7401E5A7
      </code>
      地址处设置断点后运行程序（F9)，可以
      <strong>
       得知EAX的值为402656
      </strong>
      <br/>
      <img alt="Pasted image 20250312195550" src="https://i-blog.csdnimg.cn/img_convert/64f5e4fdc339416998defa0e400375f8.png"/>
     </p>
     <p>
      此时会进入一个函数内部，并跳转到
      <code>
       402656
      </code>
      地址处，
      <br/>
      <img alt="Pasted image 20250312195843" src="https://i-blog.csdnimg.cn/img_convert/16ccc5f76a80da62cebd7c8602ddbc74.png"/>
      <br/>
      然后我们使用
      <code>
       ctrl+f9
      </code>
      发现最后会回到
      <code>
       402C17
      </code>
      地址处
      <br/>
      所以调用
      <code>
       call eax
      </code>
      就是在调用
      <code>
       402c17
      </code>
      地址处的函数，那么我们只要确认
      <code>
       CALL EAX
      </code>
      命令（7401E5A7）调用前后的栈地址即可得知
      <code>
       402C17
      </code>
      函数参数的个数（因使用的是stdcall调用方式，所以栈由被调用者负责清理）
     </p>
     <p>
      调用之前的地址 19fab8
      <br/>
      <img alt="Pasted image 20250312200339" src="https://i-blog.csdnimg.cn/img_convert/6fdda48459f2c1a775deb13cbe89682d.png"/>
      <br/>
      调用之后的地址 19fab4
      <br/>
      <img alt="Pasted image 20250312200433" src="https://i-blog.csdnimg.cn/img_convert/fe08cd18dd297cb64af3e18ca10f3e41.png"/>
      <br/>
      相差4
     </p>
     <h4>
      <a id="23__297">
      </a>
      2.3. 查找注册码
     </h4>
     <p>
      首先先定位到注册码判断的命令位置处
      <br/>
      字符串找关键字符
      <br/>
      <img alt="Pasted image 20250312200613" src="https://i-blog.csdnimg.cn/img_convert/404d028300c772951c4e17b1984e636e.png"/>
      <br/>
      跳转过去，往上找判断语句
      <br/>
      <img alt="Pasted image 20250312200804" src="https://i-blog.csdnimg.cn/img_convert/d52b47403d03f48efd0fa89fe4be9e8b.png"/>
      <br/>
      这里发现调用了
      <code>
       __vbaStrCmp
      </code>
      函数。
      <code>
       __vbaStrCmp
      </code>
      API是VB中用于比较字符串的函数。这里大概率就是与上面压入栈中的参数
      <code>
       I'mlena151
      </code>
      进行比较
      <br/>
      我们输入进行验证
      <br/>
      <img alt="Pasted image 20250312201027" src="https://i-blog.csdnimg.cn/img_convert/175a548cd06ba57052e0e3dc80a0eb61.png"/>
      <br/>
      成功了
     </p>
     <p>
      PS：笔记仅记录自己学习。里面有大量书中原文。如有侵权，请联系我删除。
     </p>
    </img>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35353334393439302f:61727469636c652f64657461696c732f313436323134313737" class_="artid" style="display:none">
 </p>
</div>


