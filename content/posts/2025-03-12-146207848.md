---
layout: post
title: "大一新生备战蓝桥杯ccB组2024年省赛真题解题心得分享"
date: 2025-03-12 22:21:02 +0800
description: "这个题用点像小学奥数，直接手算就行。"
keywords: "大一新生备战蓝桥杯c/c++B组——2024年省赛真题解题+心得分享"
categories: ['未分类']
tags: ['蓝桥杯', 'C', 'C']
artid: "146207848"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146207848
    alt: "大一新生备战蓝桥杯ccB组2024年省赛真题解题心得分享"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146207848
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146207848
cover: https://bing.ee123.net/img/rand?artid=146207848
image: https://bing.ee123.net/img/rand?artid=146207848
img: https://bing.ee123.net/img/rand?artid=146207848
---

# 大一新生备战蓝桥杯c/c++B组——2024年省赛真题解题+心得分享

## 一，握手问题

![](https://i-blog.csdnimg.cn/direct/c21c8a5c7d2b47b687c77b8d25186d28.png)

这个题用点像小学奥数，直接手算就行

**答案：1204**

## 二，小球反弹

![](https://i-blog.csdnimg.cn/direct/df253dbb33c04f8d9403b31f8c39b73e.png)

这个题思路简单，但是运行会显示超时。在思考思考，后续补代码。

##

## **三，好数**

![](https://i-blog.csdnimg.cn/direct/3f5d4adbbcb74355b6536950facdcd8b.png)

### 思路一：

    
    
    #include <iostream>
    using namespace std;
    
    bool isGoodNumber(int n) {
        for(int i = 1; n > 0; i++) // 从最低位开始，i表示当前是第几位，i++位数加1
        {
            int digit = n % 10;  // 取出当前位的数字
            if ((i % 2 == 1 && digit % 2 != 1) || (i % 2 == 0 && digit % 2 != 0)) {
                return false;  // 如果当前位不满足条件，返回false
            }
            n = n / 10;  // 去掉最低位
             // 位数加1
        }
        return true;  // 所有位都满足条件，返回true
    }
    
    int main() {
        int N;
        cin >> N;
    
        int count = 0;
        for (int n = 1; n <= N; n++) {
            if (isGoodNumber(n)) {
                count++;  // 如果是好数，计数器加1
            }
        }
    
        cout << count;
        return 0;
    }

### 思路二：

    
    
    #include <iostream>
    using namespace std;
    
    int main() {
        int N;
        cin >> N;
    
        int count = 0;  // 记录“好数”的数量
    
        for (int n = 1; n <= N; n++) {
            int temp = n;  // 使用临时变量，避免修改外层循环的 n
            bool isGood = true;  // 假设当前数字是“好数”
            int i = 1;  // 位数计数器，从最低位开始
    
            while (temp > 0) {
                int digit = temp % 10;  // 取出当前位的数字
    
                // 检查当前位是否满足条件
                if ((i % 2 == 1 && digit % 2 != 1) || (i % 2 == 0 && digit % 2 != 0)) {
                    isGood = false;  // 如果某一位不满足条件，标记为不是“好数”
                    break;  // 跳出内层循环
                }
    
                temp = temp / 10;  // 去掉最低位
                i++;  // 位数加1
            }
    
            if (isGood) {
                count++;  // 如果当前数字是“好数”，计数器加1
            }
        }
    
        cout << count;  // 输出“好数”的数量
        return 0;
    }

解释代码

  1. **临时变量`temp`**：

     * 在内层循环中，使用 `temp` 来保存当前正在检查的数字，避免修改外层循环的 `n`。

  2. **标志变量`isGood`**：

     * 初始值为 `true`，假设当前数字是“好数”。

     * 如果某一位不满足条件，将 `isGood` 设置为 `false` 并跳出内层循环。

  3. **位数计数器`i`**：

     * 从最低位开始，逐位检查数字的每一位是否满足“好数”的条件。

  4. **条件判断** ：

     * 如果当前位是奇数位（`i % 2 == 1`），则检查数字是否为奇数（`digit % 2 == 1`）。

     * 如果当前位是偶数位（`i % 2 == 0`），则检查数字是否为偶数（`digit % 2 == 0`）。

  5. **计数** ：

     * 如果当前数字是“好数”，则增加计数器 `count`。

####

## 四，R格式

![](https://i-blog.csdnimg.cn/direct/ae1e46b5084046d49f843b12085b3232.png)

### 思路：

    
    
    #include <iostream>   // 用于输入输出操作
    #include <cmath>      // 提供pow()和round()数学函数
    using namespace std;
    
    int main() {
        int n;            // 转换参数n，必须是整数
        double d;         // 待转换的浮点数d，题目保证d>0
        
        // 输入处理：按顺序读取整数n和浮点数d
        cin >> n >> d;    // 示例输入：3 9.14
        
        // 计算 d * 2^n（使用pow函数计算2的n次方）
        double m = d * pow(2, n); // 示例计算：9.14 * 8 = 73.12
        
        // 四舍五入到最近的整数，使用long long避免溢出
        long long ans = round(m); // 示例结果：round(73.12) = 73
        
        // 输出最终结果
        cout << ans << endl; // 正确输出应为整数73
        
        return 0;
    }

这个代码只通过了50%，我还没找到问题出在哪。

### 补充：C++数学库常用函数

  1. 绝对值函数用abs（）函数实现
  2. 四舍五入操作用round（）函数实现
  3. 计算平方根用sqrt（）函数实现
  4. 计算幂次方用pow（）函数实现

## 五，宝石组合

![](https://i-blog.csdnimg.cn/direct/cf23d342b2034e4db18756a8423c348e.png)

    
    
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <cmath>
    using namespace std;
    
    const int N = 1e5 + 1; //定义一个常数 N,，表示数组大小的上线为100001
    int s[N]; //定义整数数组s，用于存储输入的宝石的闪亮度
    int n; //存储宝石的数量
    vector<int> d[N]; 
    
    int main() {
        cin >> n;
    //遍历0到n-1，读取宝石的闪亮度，存储到数组s中
        for (int i = 0; i < n; i++) {
            cin >> s[i];
        }
        sort(s, s + n);//对数组s中的宝石闪亮度进行升序排序
    //找出数组s中每个元素的约数，将具有相同约数的数组元素vector数组 d中
        for (int i = 0; i < n; i++) {
            for (int j = 1; j <= sqrt(s[i]); j++) {
                if (s[i] % j == 0) {
                    d[j].push_back(s[i]);
                    if (s[i] / j != j) {
                        d[s[i] / j].push_back(s[i]);
                    }
                }
            }
        }
    //在存储具有相同约数的宝石闪亮度的vector数组d中，寻找第一个元素个数大于等于3的
        for (int i = N - 1; i >= 0; i--) {
            if (d[i].size() >= 3) {
                cout << d[i][0];
                for (int j = 1; j < 3; j++) {
                    cout << " " << d[i][j];
                }
                break;
            }
        }
        return 0;
    }

## 六，数字接龙

![](https://i-blog.csdnimg.cn/direct/4e4cdcfaf81c4de58b5e60321e5d8112.png)

![](https://i-blog.csdnimg.cn/direct/71af5afa7f4c4cc9ab18a643ac76a5f1.png)

这道题主要用到矩阵，我还没学，这周会继续补充。

## 七，爬山

![](https://i-blog.csdnimg.cn/direct/4c5d479828854eb58ba2e06e4fc49af6.png)

## 八，拔河

![](https://i-blog.csdnimg.cn/direct/1b42eb834e724e49958a6f016c247bc6.png)

最后两题有一点思路，但没办法完全写出来，后续会补。



