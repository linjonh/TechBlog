---
layout: post
title: "图论part2200.-岛屿数量695.-岛屿的最大面积"
date: 2025-03-12 21:09:27 +0800
description: "【代码】图论part2｜200. 岛屿数量、695. 岛屿的最大面积。"
keywords: "图论part2｜200. 岛屿数量、695. 岛屿的最大面积"
categories: ['代码随想录']
tags: ['算法', '深度优先', '图论']
artid: "146214871"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146214871
    alt: "图论part2200.-岛屿数量695.-岛屿的最大面积"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146214871
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146214871
cover: https://bing.ee123.net/img/rand?artid=146214871
image: https://bing.ee123.net/img/rand?artid=146214871
img: https://bing.ee123.net/img/rand?artid=146214871
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     图论part2｜200. 岛屿数量、695. 岛屿的最大面积
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     200、岛屿数量
    </h2>
    <ul>
     <li>
      🔗：
      <a href="https://leetcode.cn/problems/number-of-islands/description/" rel="nofollow" title="200. 岛屿数量 - 力扣（LeetCode）">
       200. 岛屿数量 - 力扣（LeetCode）
      </a>
     </li>
     <li>
      思路：
      <ul>
       <li>
        1. 深度优先算法
        <ul>
         <li>
          二叉树中dfs要素：1、访问左右相邻子节点 2、判断base case（终止条件）
         </li>
         <li>
          参考二叉树中的dfs看网格问题
         </li>
         <li>
          1. 网格的相邻节点：上下左右4个
         </li>
         <li>
          2.终止条件：超出格子的范围（--对应二叉树中全部为null的base case）
         </li>
         <li>
          3. 关键！！
          <strong>
           避免重复遍历，做过的格子需要进行标记
          </strong>
         </li>
        </ul>
       </li>
       <li>
        2. 广度优先算法
        <ul>
         <li>
          扫描整个二维网格，遇到为1的格子，加入队列当中，进行广度搜索
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      代码
      <ul>
       <li>
        深度优先算法
       </li>
       <li>
        <pre><code class="language-java">class Solution {

    public int numIslands(char[][] grid) {
        int area = 0;
        for(int i=0; i&lt;grid.length; i++){
            for(int j=0; j&lt;grid[0].length; j++){
                if(grid[i][j] == '1'){
                    area++;
                    dfs(grid, i, j);
                }
            }
        }
        return area;
    }

    private void dfs(char[][] grid, int r, int c){
        if(!isArea(grid,r,c)){
            return;
        }
        if(grid[r][c] != '1'){
            return;
        }
        grid[r][c] = '2';

        dfs(grid, r-1, c);
        dfs(grid, r, c-1);
        dfs(grid, r+1, c);
        dfs(grid, r, c+1);
    }

    boolean isArea(char[][] grid, int r, int c){
        return 0&lt;=r &amp;&amp; r &lt; grid.length 
                &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length;
    }
}</code></pre>
       </li>
       <li>
        广度优先算法
        <ul>
         <li>
          <pre><code class="language-java">class Solution {
    /**
    广度优先搜索bfs
    扫描整个二维网络，如果一个位置为1，加入队列，进行广度优先搜索
     */
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0){
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int nums_islands = 0;

        for(int r=0; r &lt; nr; ++r){
            for(int c = 0; c&lt;nc; ++c){
                if(grid[r][c] == '1'){
                    ++nums_islands;
                    grid[r][c] = '2';
                    Queue&lt;Integer&gt; neighbors = new LinkedList&lt;&gt;();
                    neighbors.add(r * nc + c);
                    while(!neighbors.isEmpty()){
                        int id = neighbors.remove();
                        int row = id / nc;
                        int col = id % nc;
                        if (row - 1 &gt;= 0 &amp;&amp; grid[row-1][col] == '1') {
                            grid[row-1][col] = '2';
                            neighbors.add((row-1) * nc + col);
                        }
                        if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == '1') {
                            grid[row+1][col] = '2';
                            neighbors.add((row+1) * nc + col);
                        }
                        if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == '1') {
                            neighbors.add(row * nc + col-1);
                            grid[row][col-1] = '2';
                        }
                        if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == '1') {
                            neighbors.add(row * nc + col+1);
                            grid[row][col+1] = '2';
                        }                      
                    }
                }
            }
        }
        return nums_islands;
    }</code></pre>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <h2>
     695. 岛屿的最大面积
    </h2>
    <ul>
     <li>
      🔗：
      <a href="https://leetcode.cn/problems/max-area-of-island/description/" rel="nofollow" title="695. 岛屿的最大面积 - 力扣（LeetCode）">
       695. 岛屿的最大面积 - 力扣（LeetCode）
      </a>
     </li>
     <li>
      思路：深度优先搜索
     </li>
     <li>
      代码：
      <pre><code class="language-java">class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        if(grid.length==0||grid[0].length==0){
            return 0;
        }

        int res = 0;
        for(int r=0; r&lt;grid.length; r++){
            for(int c=0; c&lt;grid[0].length; c++){
                if(grid[r][c]==1){
                    int a = area(grid, r, c);
                    res = Math.max(res,a);
                }
            }
        }
        return res;
    }

    int area(int[][] grid, int r, int c){
        if (!(0 &lt;= r &amp;&amp; r &lt; grid.length 
            &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length)) {
            return 0;
        }
        if(grid[r][c] != 1){
            return 0;
        }

        grid[r][c] = 2;
        return 1 
            + area(grid, r-1, c)
            + area(grid, r+1, c)
            + area(grid, r, c-1)
            + area(grid, r, c+1);
    }
}</code></pre>
      <p>
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36323537323536372f:61727469636c652f64657461696c732f313436323134383731" class_="artid" style="display:none">
 </p>
</div>


