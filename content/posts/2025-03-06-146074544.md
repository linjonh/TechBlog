---
layout: post
title: "lodash手写源码-cloneDeep,debounce,throttle"
date: 2025-03-06 17:47:48 +0800
description: "深拷贝对象用于创建一个对象或数组的深拷贝，即递归地复制对象及其所有嵌套的属性，新对象与原对象在内存中是完全独立的。"
keywords: "lodash手写源码-cloneDeep,debounce,throttle"
categories: ['Loadsh']
tags: ['笔记', '学习', 'Loadsh']
artid: "146074544"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146074544
    alt: "lodash手写源码-cloneDeep,debounce,throttle"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146074544
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146074544
cover: https://bing.ee123.net/img/rand?artid=146074544
image: https://bing.ee123.net/img/rand?artid=146074544
img: https://bing.ee123.net/img/rand?artid=146074544
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     lodash手写源码-cloneDeep,debounce,throttle
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong style="color:#4f4f4f; font-size:18px; font-weight:bold">
      一、源码地址
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       GitHub 地址
      </strong>
      :
      <a href="https://github.com/lodash/lodash" title="GitHub - lodash/lodash: A modern JavaScript utility library delivering modularity, performance, &amp; extras.">
       GitHub - lodash/lodash: A modern JavaScript utility library delivering modularity, performance, &amp; extras.
      </a>
     </li>
     <li>
      <strong>
       官方文档地址
      </strong>
      :
      <a href="https://lodash.com/docs/" rel="nofollow" title="Lodash 官方文档">
       Lodash 官方文档
      </a>
     </li>
    </ul>
    <h4>
     <a name="t1">
     </a>
     <a id="_10">
     </a>
     二、函数介绍
    </h4>
    <p>
     <code>
      _.cloneDeep
     </code>
     - 深拷贝对象
    </p>
    <p>
     用于创建一个对象或数组的深拷贝，即递归地复制对象及其所有嵌套的属性，
     <span style="color:#fe2c24">
      新对象与原对象在内存中是完全独立的。
     </span>
    </p>
    <p>
    </p>
    <h5>
     浅拷贝
    </h5>
    <p>
     浅拷贝创建一个新对象，新对象的属性会
     <span style="color:#fe2c24">
      直接复制原对象的属性
     </span>
     。但对于引用类型的属性，浅拷贝仅仅复制其
     <span style="color:#fe2c24">
      引用
     </span>
     ，而不是复制实际的对象。这意味着新对象和原对象中的引用类型属性会指向
     <span style="color:#fe2c24">
      同一个内存地址
     </span>
     ，
     <span style="color:#fe2c24">
      修改其中一个对象的引用类型属性会影响到另一个对象
     </span>
     。
    </p>
    <ul>
     <li>
      <strong>
       使用
       <code>
        Object.assign()
       </code>
      </strong>
      ：用于将一个或多个源对象的所有可枚举属性复制到目标对象。
     </li>
    </ul>
    <pre><code class="language-javascript">const original = { a: 1, b: { c: 2 } };
const shallowCopy = Object.assign({}, original);

// 修改浅拷贝对象的引用类型属性
shallowCopy.b.c = 3;

console.log(original.b.c); // 输出: 3，说明原对象也被修改了</code></pre>
    <ul>
     <li>
      <strong>
       使用扩展运算符
      </strong>
      ：是一种更简洁的对象复制方式。
     </li>
    </ul>
    <pre><code class="language-javascript">const original = { a: 1, b: { c: 2 } };
const shallowCopy = { ...original };

shallowCopy.b.c = 3;
console.log(original.b.c); // 输出: 3</code></pre>
    <h5>
     深拷贝
    </h5>
    <p>
     深拷贝同样创建一个新对象，并且会
     <span style="color:#fe2c24">
      递归
     </span>
     地复制原对象的所有属性，包括嵌套的引用类型属性。这会在内存中创建一个完全独立的对象，新对象和原对象在内存中没有共享的部分，修
     <span style="color:#fe2c24">
      改新对象不会影响原对象
     </span>
     。
    </p>
    <ul>
     <li>
      <strong>
       使用
       <code>
        JSON.parse(JSON.stringify())
       </code>
      </strong>
      ：这种方法简单直接，但有局限性，比如不能处理函数、正则表达式等特殊对象。
     </li>
    </ul>
    <pre><code class="language-javascript">const original = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.b.c = 3;
console.log(original.b.c); // 输出: 2，原对象未被修改</code></pre>
    <ul>
     <li>
      <strong>
       手写递归函数
      </strong>
      ：可以处理各种类型的对象，但实现相对复杂。
     </li>
    </ul>
    <p>
     <code>
      _.debounce
     </code>
     - 防抖函数
    </p>
    <p>
     防抖函数用于限制一个函数
     <span style="color:#fe2c24">
      在一定时间内只能被调用一次
     </span>
     。当持续触发事件时，在规定时间内没有再次触发事件，函数才会执行；如果在规定时间内
     <span style="color:#fe2c24">
      再次触发事件，则重新计时
     </span>
     。
    </p>
    <p>
     <code>
      _.throttle
     </code>
     - 节流函数
    </p>
    <p>
     节流函数用于限制一个函数在一定时间内只能被调用一次。当持续触发事件时，
     <span style="color:#fe2c24">
      在规定时间内，函数只会执行一次
     </span>
     ，之后在这个时间间隔内
     <span style="color:#fe2c24">
      再次触发事件，函数不会执行
     </span>
     。
    </p>
    <h4>
     三、手写代码
    </h4>
    <p>
     <code>
      _.cloneDeep
     </code>
    </p>
    <pre><code class="language-javascript">function cloneDeep(obj) {
    if (typeof obj!== 'object' || obj === null) {
        return obj;
    }

    let clone = Array.isArray(obj)? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            clone[key] = cloneDeep(obj[key]);
        }
    }
    return clone;
}

// 测试
const original = { a: 1, b: { c: 2 } };
const cloned = cloneDeep(original);
console.log(cloned); </code></pre>
    <p>
     <code>
      _.debounce
     </code>
    </p>
    <pre><code class="language-javascript">function debounce(func, delay) {
    let timer = null;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            func.apply(context, args);
        }, delay);
    };
}

// 测试
function myFunction() {
    console.log('Function called');
}

const debouncedFunction = debounce(myFunction, 1000);
debouncedFunction(); 
debouncedFunction(); </code></pre>
    <p>
     <code>
      _.throttle
     </code>
    </p>
    <pre><code class="language-javascript">function throttle(func, delay) {
    // 记录上一次执行函数的时间，初始值为 0
    let lastTime = 0;

    // 返回一个新的函数，这个新函数就是节流后的函数
    return function() {
        // 获取当前的时间戳
        const now = Date.now();
        // 如果当前时间与上一次执行时间的差值大于等于设定的延迟时间
        if (now - lastTime &gt;= delay) {
            // 调用传入的原始函数，并使用 apply 方法绑定正确的 this 值和参数
            func.apply(this, arguments);
            // 更新上一次执行函数的时间为当前时间
            lastTime = now;
        }
    };
}

// 示例使用
function sayHello() {
    console.log('Hello!');
}

// 创建一个节流后的函数，每 2000 毫秒（2 秒）执行一次
const throttledSayHello = throttle(sayHello, 2000);

// 模拟频繁调用
setInterval(throttledSayHello, 200);
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36393036373030332f:61727469636c652f64657461696c732f313436303734353434" class_="artid" style="display:none">
 </p>
</div>


