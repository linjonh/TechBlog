---
layout: post
title: "Spring-Boot-HikariCP数据库连接池入门"
date: 2025-03-10 17:04:33 +0800
description: "在我们的项目中，数据库连接池基本是必不可少的组件。在目前数据库连接池的选型中，主要是Druid，为监控而生的数据库连接池。HikariCP，号称性能最好的数据库连接池。至于怎么选择，两者都非常优秀，不用过多纠结。Spring Boot 2.X 版本，默认采用 HikariCP。阿里大规模采用 Druid。《Druid 连接池介绍》《为什么 HikariCP 被号称为性能最好的 Java 数据库连接池，如何配置使用》，一个小小的“撕逼”。"
keywords: "Spring Boot HikariCP数据库连接池入门"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['Java']
artid: "146158741"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146158741
    alt: "Spring-Boot-HikariCP数据库连接池入门"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146158741
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146158741
cover: https://bing.ee123.net/img/rand?artid=146158741
image: https://bing.ee123.net/img/rand?artid=146158741
img: https://bing.ee123.net/img/rand?artid=146158741
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring Boot HikariCP数据库连接池入门
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="1__4">
     </a>
     1. 概述
    </h4>
    <p>
     在我们的项目中，数据库连接池基本是必不可少的组件。在目前数据库连接池的选型中，主要是
    </p>
    <ul>
     <li>
      <a href="https://github.com/alibaba/druid" title="Druid">
       Druid
      </a>
      ，为
      <strong>
       监控
      </strong>
      而生的数据库连接池。
     </li>
     <li>
      <a href="https://github.com/brettwooldridge/HikariCP" title="HikariCP">
       HikariCP
      </a>
      ，号称
      <strong>
       性能
      </strong>
      最好的数据库连接池。
     </li>
    </ul>
    <p>
     至于怎么选择，两者都非常优秀，不用过多纠结。
    </p>
    <ul>
     <li>
      Spring Boot 2.X 版本，默认采用 HikariCP 。
     </li>
     <li>
      阿里大规模采用 Druid 。
     </li>
    </ul>
    <p>
     当然，如下有一些资料，胖友可以阅读参考：
    </p>
    <ul>
     <li>
      <a href="https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D" title="《Druid 连接池介绍》">
       《Druid 连接池介绍》
      </a>
     </li>
     <li>
      <a href="https://blog.csdn.net/clementad/article/details/46928621" title="《为什么 HikariCP 被号称为性能最好的 Java 数据库连接池，如何配置使用》">
       《为什么 HikariCP 被号称为性能最好的 Java 数据库连接池，如何配置使用》
      </a>
     </li>
     <li>
      <a href="https://github.com/brettwooldridge/HikariCP/issues/232" title="《alibaba/druid pool analysis》">
       《alibaba/druid pool analysis》
      </a>
      ，一个小小的“撕逼”。
     </li>
    </ul>
    <p>
     下面，我们来进行 HikariCP 和 Druid 的入门，会配置单数据源和多数据源情况下的连接池。
    </p>
    <h3>
     <a id="2_HikariCP__24">
     </a>
     2. HikariCP 单数据源
    </h3>
    <blockquote>
     <p>
      示例代码对应仓库：
      <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-19/lab-19-datasource-pool-hikaricp-single" title="lab-19-datasource-pool-hikaricp-single">
       lab-19-datasource-pool-hikaricp-single
      </a>
      。
     </p>
    </blockquote>
    <p>
     在本小节，我们会使用配置一个数据源的 HikariCP 连接池。
    </p>
    <blockquote>
     <p>
      艿艿：推荐入门后，可以看看 HikariCP 的文档：
      <a href="https://github.com/brettwooldridge/HikariCP/wiki" title="https://github.com/brettwooldridge/HikariCP/wiki">
       https://github.com/brettwooldridge/HikariCP/wiki
      </a>
      。
     </p>
    </blockquote>
    <h4>
     <a id="21__33">
     </a>
     2.1 引入依赖
    </h4>
    <p>
     在
     <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-19/lab-19-datasource-pool-hikaricp-single/pom.xml" title="pom.xml">
      pom.xml
     </a>
     文件中，引入相关依赖
    </p>
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;lab-19-datasource-pool-hikaricp-single&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!-- 实现对数据库连接池的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt; &lt;!-- 本示例，我们使用 MySQL --&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.48&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 方便等会写单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
    <ul>
     <li>
      无需主动引入 HikariCP 的依赖。因为在 Spring Boot 2.X 中，
      <code>
       spring-boot-starter-jdbc
      </code>
      默认引入
      <a href="https://mvnrepository.com/artifact/com.zaxxer/HikariCP" rel="nofollow" title="com.zaxxer.HikariCP">
       com.zaxxer.HikariCP
      </a>
      依赖。
     </li>
    </ul>
    <h4>
     <a id="22__75">
     </a>
     2.2 应用配置文件
    </h4>
    <p>
     在
     <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-19/lab-19-datasource-pool-hikaricp-single/src/main/resources/application.yaml" title="application.yml">
      application.yml
     </a>
     中，添加 HikariCP 配置，如下：
    </p>
    <pre><code>spring:
  # datasource 数据源配置内容，对应 DataSourceProperties 配置属性类
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
    driver-class-name: com.mysql.jdbc.Driver
    username: root # 数据库账号
    password: # 数据库密码
    # HikariCP 自定义配置，对应 HikariConfig 配置属性类
    hikari:
      minimum-idle: 10 # 池中维护的最小空闲连接数，默认为 10 个。
      maximum-pool-size: 10 # 池中最大连接数，包括闲置和使用中的连接，默认为 10 个。
</code></pre>
    <ul>
     <li>
      在
      <code>
       spring.datasource
      </code>
      配置项下，我们可以添加数据源的
      <strong>
       通用
      </strong>
      配置。
     </li>
     <li>
      在
      <code>
       spring.datasource.hikari
      </code>
      配置项下，我们可以添加 HikariCP 连接池的
      <strong>
       自定义
      </strong>
      配置。然后
      <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration.java#L72-L92" title="DataSourceConfiguration.Hikari">
       DataSourceConfiguration.Hikari
      </a>
      会自动化配置 HikariCP 连接池。
     </li>
    </ul>
    <p>
     HikariCP 更多配置项，可以看看如下表格：s
    </p>
    <blockquote>
     <p>
      FROM
      <a href="https://blog.csdn.net/qq_32953079/article/details/81502237" title="《HikariCP 连接池及其在 Spring Boot 中的配置》">
       《HikariCP 连接池及其在 Spring Boot 中的配置》
      </a>
     </p>
    </blockquote>
    <p>
     配置项
    </p>
    <p>
     描述
    </p>
    <p>
     构造器默认值
    </p>
    <p>
     默认配置validate之后的值
    </p>
    <p>
     validate重置
    </p>
    <p>
     autoCommit
    </p>
    <p>
     自动提交从池中返回的连接
    </p>
    <p>
     true
    </p>
    <p>
     true
    </p>
    <p>
     -
    </p>
    <p>
     connectionTimeout
    </p>
    <p>
     等待来自池的连接的最大毫秒数
    </p>
    <p>
     SECONDS.toMillis(30) = 30000
    </p>
    <p>
     30000
    </p>
    <p>
     如果小于250毫秒，则被重置回30秒
    </p>
    <p>
     idleTimeout
    </p>
    <p>
     连接允许在池中闲置的最长时间
    </p>
    <p>
     MINUTES.toMillis(10) = 600000
    </p>
    <p>
     600000
    </p>
    <p>
     如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒
    </p>
    <p>
     maxLifetime
    </p>
    <p>
     池中连接最长生命周期
    </p>
    <p>
     MINUTES.toMillis(30) = 1800000
    </p>
    <p>
     1800000
    </p>
    <p>
     如果不等于0且小于30秒则会被重置回30分钟
    </p>
    <p>
     connectionTestQuery
    </p>
    <p>
     如果您的驱动程序支持JDBC4，我们强烈建议您不要设置此属性
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     minimumIdle
    </p>
    <p>
     池中维护的最小空闲连接数
    </p>
    <p>
     -1
    </p>
    <p>
     10
    </p>
    <p>
     minIdle&lt;0或者minIdle&gt;maxPoolSize,则被重置为maxPoolSize
    </p>
    <p>
     maximumPoolSize
    </p>
    <p>
     池中最大连接数，包括闲置和使用中的连接
    </p>
    <p>
     -1
    </p>
    <p>
     10
    </p>
    <p>
     如果maxPoolSize小于1，则会被重置。当minIdle&lt;=0被重置为DEFAULT_POOL_SIZE则为10;如果minIdle&gt;0则重置为minIdle的值
    </p>
    <p>
     metricRegistry
    </p>
    <p>
     该属性允许您指定一个 Codahale / Dropwizard
     <code>
      MetricRegistry
     </code>
     的实例，供池使用以记录各种指标
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     healthCheckRegistry
    </p>
    <p>
     该属性允许您指定池使用的Codahale / Dropwizard HealthCheckRegistry的实例来报告当前健康信息
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     poolName
    </p>
    <p>
     连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置
    </p>
    <p>
     null
    </p>
    <p>
     HikariPool-1
    </p>
    <p>
     -
    </p>
    <p>
     initializationFailTimeout
    </p>
    <p>
     如果池无法成功初始化连接，则此属性控制池是否将
     <code>
      fail fast
     </code>
    </p>
    <p>
     1
    </p>
    <p>
     1
    </p>
    <p>
     -
    </p>
    <p>
     isolateInternalQueries
    </p>
    <p>
     是否在其自己的事务中隔离内部池查询，例如连接活动测试
    </p>
    <p>
     false
    </p>
    <p>
     false
    </p>
    <p>
     -
    </p>
    <p>
     allowPoolSuspension
    </p>
    <p>
     控制池是否可以通过JMX暂停和恢复
    </p>
    <p>
     false
    </p>
    <p>
     false
    </p>
    <p>
     -
    </p>
    <p>
     readOnly
    </p>
    <p>
     从池中获取的连接是否默认处于只读模式
    </p>
    <p>
     false
    </p>
    <p>
     false
    </p>
    <p>
     -
    </p>
    <p>
     registerMbeans
    </p>
    <p>
     是否注册JMX管理Bean（
     <code>
      MBeans
     </code>
     ）
    </p>
    <p>
     false
    </p>
    <p>
     false
    </p>
    <p>
     -
    </p>
    <p>
     catalog
    </p>
    <p>
     为支持
     <code>
      catalog
     </code>
     概念的数据库设置默认
     <code>
      catalog
     </code>
    </p>
    <p>
     driver default
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     connectionInitSql
    </p>
    <p>
     该属性设置一个SQL语句，在将每个新连接创建后，将其添加到池中之前执行该语句。
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     driverClassName
    </p>
    <p>
     HikariCP将尝试通过仅基于jdbcUrl的DriverManager解析驱动程序，但对于一些较旧的驱动程序，还必须指定driverClassName
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     transactionIsolation
    </p>
    <p>
     控制从池返回的连接的默认事务隔离级别
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     validationTimeout
    </p>
    <p>
     连接将被测试活动的最大时间量
    </p>
    <p>
     SECONDS.toMillis(5) = 5000
    </p>
    <p>
     5000
    </p>
    <p>
     如果小于250毫秒，则会被重置回5秒
    </p>
    <p>
     leakDetectionThreshold
    </p>
    <p>
     记录消息之前连接可能离开池的时间量，表示可能的连接泄漏
    </p>
    <p>
     0
    </p>
    <p>
     0
    </p>
    <p>
     如果大于0且不是单元测试，则进一步判断：(leakDetectionThreshold &lt; SECONDS.toMillis(2) or (leakDetectionThreshold &gt; maxLifetime &amp;&amp; maxLifetime &gt; 0)，会被重置为0 . 即如果要生效则必须&gt;0，而且不能小于2秒，而且当maxLifetime &gt; 0时不能大于maxLifetime
    </p>
    <p>
     dataSource
    </p>
    <p>
     这个属性允许你直接设置数据源的实例被池包装，而不是让HikariCP通过反射来构造它
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     schema
    </p>
    <p>
     该属性为支持模式概念的数据库设置默认模式
    </p>
    <p>
     driver default
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     threadFactory
    </p>
    <p>
     此属性允许您设置将用于创建池使用的所有线程的java.util.concurrent.ThreadFactory的实例。
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <p>
     scheduledExecutor
    </p>
    <p>
     此属性允许您设置将用于各种内部计划任务的java.util.concurrent.ScheduledExecutorService实例
    </p>
    <p>
     null
    </p>
    <p>
     null
    </p>
    <p>
     -
    </p>
    <h4>
     <a id="23_Application_358">
     </a>
     2.3 Application
    </h4>
    <p>
     创建
     <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-19/lab-19-datasource-pool-hikaricp-single/src/main/java/cn/iocoder/springboot/lab19/datasourcepool/Application.java" title="Application.java">
      Application.java
     </a>
     类，配置
     <code>
      @SpringBootApplication
     </code>
     注解即可。代码如下：
    </p>
    <pre><code>@SpringBootApplication
public class Application implements CommandLineRunner {

    private Logger logger = LoggerFactory.getLogger(Application.class);

    @Autowired
    private DataSource dataSource;

    public static void main(String[] args) {
        // 启动 Spring Boot 应用
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) {
        try (Connection conn = dataSource.getConnection()) {
            // 这里，可以做点什么
            logger.info("[run][获得连接：{}]", conn);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}
</code></pre>
    <p>
     通过实现
     <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-command-line-runner" rel="nofollow" title="CommandLineRunner">
      CommandLineRunner
     </a>
     接口，应用启动完成后，回调
     <code>
      #run(String... args)
     </code>
     方法，输出下 Connection 信息。执行日志如下：
    </p>
    <pre><code>2019-11-12 11:15:32.303  INFO 41198 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2019-11-12 11:15:32.472  INFO 41198 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2019-11-12 11:15:32.473  INFO 41198 --- [           main] c.i.s.lab19.datasourcepool.Application   : [run][获得连接：HikariProxyConnection@1561745898 wrapping com.mysql.jdbc.JDBC4Connection@793138bd]
</code></pre>
    <ul>
     <li>
      可以看到，HikariDataSource 成功初始化
     </li>
    </ul>
    <h4>
     <a id="3_HikariCP__396">
     </a>
     3. HikariCP 多数据源
    </h4>
    <ul>
     <li>
      <blockquote>
       <p>
        示例代码对应仓库：
        <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-19/lab-19-datasource-pool-hikaricp-multiple" title="lab-19-datasource-pool-hikaricp-multiple">
         lab-19-datasource-pool-hikaricp-multiple
        </a>
        。
       </p>
      </blockquote>
      <p>
       在本小节，我们会使用配置
       <strong>
        两个
       </strong>
       数据源的 HikariCP 连接池。
      </p>
      <h4>
       <a id="31__402">
       </a>
       3.1 引入依赖
      </h4>
      <p>
       和
       <a href="https://www.iocoder.cn/Spring-Boot/datasource-pool/#" rel="nofollow" title="「2.1 引入依赖」">
        「2.1 引入依赖」
       </a>
       是一致。
      </p>
      <h4>
       <a id="32__406">
       </a>
       3.2 应用配置文件
      </h4>
      <p>
       在
       <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-19/lab-19-datasource-pool-hikaricp-multiple/src/main/resources/application.yaml" title="application.yml">
        application.yml
       </a>
       中，添加 HikariCP 配置，如下：
      </p>
     </li>
     <li>
      <pre><code>  spring:
    # datasource 数据源配置内容
    datasource:
      # 订单数据源配置
      orders:
        url: jdbc:mysql://127.0.0.1:3306/test_orders?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
        driver-class-name: com.mysql.jdbc.Driver
        username: root
        password:
        # HikariCP 自定义配置，对应 HikariConfig 配置属性类
        hikari:
          minimum-idle: 20 # 池中维护的最小空闲连接数，默认为 10 个。
          maximum-pool-size: 20 # 池中最大连接数，包括闲置和使用中的连接，默认为 10 个。
      # 用户数据源配置
      users:
        url: jdbc:mysql://127.0.0.1:3306/test_users?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
        driver-class-name: com.mysql.jdbc.Driver
        username: root
        password:
        # HikariCP 自定义配置，对应 HikariConfig 配置属性类
        hikari:
          minimum-idle: 15 # 池中维护的最小空闲连接数，默认为 10 个。
          maximum-pool-size: 15 # 池中最大连接数，包括闲置和使用中的连接，默认为 10 个。
</code></pre>
     </li>
     <li>
      <p>
       我们在
       <code>
        spring.datasource
       </code>
       配置项下，定义了
       <code>
        orders
       </code>
       和
       <code>
        users
       </code>
       两个数据源的配置。而每个数据源的配置，和我们在
       <a href="https://www.iocoder.cn/Spring-Boot/datasource-pool/#" rel="nofollow" title="「2.2 应用配置文件」">
        「2.2 应用配置文件」
       </a>
       是一致的。3.3 数据源配置类
      </p>
     </li>
     <li>
      <h5>
       <a id="331__435">
       </a>
       3.3.1 错误的示例
      </h5>
      <p>
       在网上，我们会看到这样配置多个数据源的配置类。代码如下：
      </p>
      <p>
       @Bean(name = “ordersDataSource”)
       <br/>
       @ConfigurationProperties(prefix = “spring.datasource.orders”)
       <br/>
       public DataSource ordersDataSource() {
       <!-- -->
       <br/>
       return DataSourceBuilder.create().build();
       <br/>
       }
      </p>
      <p>
       @Bean(name = “usersDataSource”)
       <br/>
       @ConfigurationProperties(prefix = “spring.datasource.users”)
       <br/>
       public DataSource ordersDataSource() {
       <!-- -->
       <br/>
       return DataSourceBuilder.create().build();
       <br/>
       }
      </p>
     </li>
     <li>
      <p>
       实际上，这样做的话，在部分场景下，会存在问题，这是为什么呢？
      </p>
     </li>
     <li>
      <p>
       我们先来理解这段程序的用途。以
       <code>
        #ordersDataSource()
       </code>
       方法为例子：
      </p>
      <ul>
       <li>
        <code>
         DataSourceBuilder.create().build()
        </code>
        代码段，会创建一个 DataSource 数据源。
       </li>
       <li>
        搭配上
        <code>
         @Bean(name = "ordersDataSource")
        </code>
        注解，会创建一个名字为
        <code>
         "ordersDataSource"
        </code>
        的 DataSource Bean 。这里，我们使用 HikariCP ，所以返回的是 HikariDataSource Bean 。
       </li>
       <li>
        <code>
         @ConfigurationProperties(prefix = "spring.datasource.orders")
        </code>
        注解，会将
        <code>
         "spring.datasource.orders"
        </code>
        配置项，逐个属性赋值给 DataSource Bean 。
       </li>
      </ul>
     </li>
     <li>
      <p>
       看起来貌似没问题，但是如果每个数据源如果有 HikariCP 的
       <code>
        "hikari"
       </code>
       自定义配置项时，
       <strong>
        它的自定义配置项无法设置到 HikariDataSource Bean 中
       </strong>
       。因为，
       <code>
        "spring.datasource.orders.hikari"
       </code>
       是
       <code>
        "spring.datasource.orders"
       </code>
       的
       <strong>
        第二层
       </strong>
       属性。而
       <a href="https://github.com/openbouquet/HikariCP/blob/master/src/main/java/com/zaxxer/hikari/HikariDataSource.java" title="HikariDataSource">
        HikariDataSource
       </a>
       的
       <a href="https://github.com/openbouquet/HikariCP/blob/master/src/main/java/com/zaxxer/hikari/HikariConfig.java" title="配置属性">
        配置属性
       </a>
       在
       <strong>
        第一层
       </strong>
       ，这就导致无法正确的设置。
      </p>
     </li>
    </ul>
    <p>
     虽然存在该问题，但是大多数项目，我们并不会自定义 HikariCP 的
     <code>
      "hikari"
     </code>
     配置项，所以这个问题就偷偷藏起来，**“不存在”**了。
    </p>
    <h5>
     <a id="332__461">
     </a>
     3.3.2 正确的示例
    </h5>
    <p>
     当然，作为入门的示例，艿艿还是希望提供正确的做法。
    </p>
    <p>
     在
     <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-19/lab-19-datasource-pool-hikaricp-multiple/src/main/java/cn/iocoder/springboot/lab19/datasourcepool/config" title="cn.iocoder.springboot.lab19.datasourcepool.config">
      cn.iocoder.springboot.lab19.datasourcepool.config
     </a>
     包路径下，我们会创建
     <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-19/lab-19-datasource-pool-hikaricp-multiple/src/main/java/cn/iocoder/springboot/lab19/datasourcepool/config/DataSourceConfig.java" title="DataSourceConfig">
      DataSourceConfig
     </a>
     配置类。代码如下：
    </p>
    <pre><code>// DataSourceConfig.java

@Configuration
public class DataSourceConfig {

    /**
     * 创建 orders 数据源的配置对象
     */
    @Primary
    @Bean(name = "ordersDataSourceProperties")
    @ConfigurationProperties(prefix = "spring.datasource.orders") // 读取 spring.datasource.orders 配置到 DataSourceProperties 对象
    public DataSourceProperties ordersDataSourceProperties() {
        return new DataSourceProperties();
    }

    /**
     * 创建 orders 数据源
     */
    @Bean(name = "ordersDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.orders.hikari") // 读取 spring.datasource.orders 配置到 HikariDataSource 对象
    public DataSource ordersDataSource() {
        // &lt;1.1&gt; 获得 DataSourceProperties 对象
        DataSourceProperties properties =  this.ordersDataSourceProperties();
        // &lt;1.2&gt; 创建 HikariDataSource 对象
        return createHikariDataSource(properties);
    }

    /**
     * 创建 users 数据源的配置对象
     */
    @Bean(name = "usersDataSourceProperties")
    @ConfigurationProperties(prefix = "spring.datasource.users") // 读取 spring.datasource.users 配置到 DataSourceProperties 对象
    public DataSourceProperties usersDataSourceProperties() {
        return new DataSourceProperties();
    }

    /**
     * 创建 users 数据源
     */
    @Bean(name = "usersDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.users.hikari")
    public DataSource usersDataSource() {
        // 获得 DataSourceProperties 对象
        DataSourceProperties properties =  this.usersDataSourceProperties();
        // 创建 HikariDataSource 对象
        return createHikariDataSource(properties);
    }

    private static HikariDataSource createHikariDataSource(DataSourceProperties properties) {
        // 创建 HikariDataSource 对象
        HikariDataSource dataSource = properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
        // 设置线程池名
        if (StringUtils.hasText(properties.getName())) {
            dataSource.setPoolName(properties.getName());
        }
        return dataSource;
    }

}
</code></pre>
    <ul>
     <li>
      这块代码，我们是参考 Spring Boot
      <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration.java#L72-L92" title="DataSourceConfiguration.Hikari">
       DataSourceConfiguration.Hikari
      </a>
      配置类来实现的。
     </li>
     <li>
      <code>
       #ordersDataSourceProperties()
      </code>
      方法，创建
      <code>
       "orders"
      </code>
      数据源的 DataSourceProperties 配置对象。
      <ul>
       <li>
        <a href="http://www.yihaomen.com/article/java/581.htm" rel="nofollow" title="@Primary">
         @Primary
        </a>
        注解，保证项目中有一个
        <strong>
         主
        </strong>
        的 DataSourceProperties Bean 。
       </li>
       <li>
        <code>
         new DataSourceProperties()
        </code>
        代码段，会创建一个 DataSourceProperties 数据源的配置对象。
       </li>
       <li>
        搭配上
        <code>
         @Bean(name = "ordersDataSourceProperties")
        </code>
        注解，会创建一个名字为
        <code>
         "ordersDataSourceProperties"
        </code>
        的 DataSourceProperties Bean 。
       </li>
       <li>
        <code>
         @ConfigurationProperties(prefix = "spring.datasource.orders")
        </code>
        注解，会将
        <code>
         "spring.datasource.orders"
        </code>
        配置项，逐个属性赋值给 DataSourceProperties Bean 。
       </li>
      </ul>
     </li>
     <li>
      <code>
       #ordersDataSource()
      </code>
      方法，创建
      <code>
       orders
      </code>
      数据源。
      <ul>
       <li>
        <code>
         &lt;1.1&gt;
        </code>
        处，调用
        <code>
         #ordersDataSourceProperties()
        </code>
        方法，获得
        <code>
         orders
        </code>
        数据源的 DataSourceProperties 。
       </li>
       <li>
        <code>
         &lt;1.2&gt;
        </code>
        处，调用
        <code>
         #createHikariDataSource(DataSourceProperties properties)
        </code>
        方法，创建 HikariDataSource 对象。这样，
        <code>
         "spring.datasource.orders"
        </code>
        配置项，逐个属性赋值给 HikariDataSource Bean 。
       </li>
       <li>
        搭配上
        <code>
         @Bean(name = "ordersDataSource")
        </code>
        注解，会创建一个名字为
        <code>
         "ordersDataSource"
        </code>
        的 HikariDataSource Bean 。
       </li>
       <li>
        <code>
         @ConfigurationProperties(prefix = "spring.datasource.orders.hikari")
        </code>
        注解，会将 HikariCP 的
        <code>
         "spring.datasource.orders.hikari"
        </code>
        自定义配置项，逐个属性赋值给 HikariDataSource Bean 。
       </li>
      </ul>
     </li>
     <li>
      <code>
       users
      </code>
      数据源的配置，同上，就不重复解释了。
     </li>
    </ul>
    <h4>
     <a id="34_Application_540">
     </a>
     3.4 Application
    </h4>
    <p>
     创建
     <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-19/lab-19-datasource-pool-hikaricp-multiple/src/main/java/cn/iocoder/springboot/lab19/datasourcepool/Application.java" title="Application.java">
      Application.java
     </a>
     类，配置
     <code>
      @SpringBootApplication
     </code>
     注解即可。代码如下：
    </p>
    <pre><code>@SpringBootApplication
public class Application implements CommandLineRunner {

    private Logger logger = LoggerFactory.getLogger(Application.class);

    @Resource(name = "ordersDataSource")
    private DataSource ordersDataSource;

    @Resource(name = "usersDataSource")
    private DataSource usersDataSource;

    public static void main(String[] args) {
        // 启动 Spring Boot 应用
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) {
        // orders 数据源
        try (Connection conn = ordersDataSource.getConnection()) {
            // 这里，可以做点什么
            logger.info("[run][ordersDataSource 获得连接：{}]", conn);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        // users 数据源
        try (Connection conn = usersDataSource.getConnection()) {
            // 这里，可以做点什么
            logger.info("[run][usersDataSource 获得连接：{}]", conn);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

}
</code></pre>
    <p>
     执行日志如下：
    </p>
    <pre><code>2019-11-12 15:30:35.060  INFO 45868 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2019-11-12 15:30:35.365  INFO 45868 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2019-11-12 15:30:35.367  INFO 45868 --- [           main] c.i.s.lab19.datasourcepool.Application   : [run][ordersDataSource 获得连接：HikariProxyConnection@1041547629 wrapping com.mysql.jdbc.JDBC4Connection@3c989952]
2019-11-12 15:30:35.371  INFO 45868 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...
2019-11-12 15:30:35.376  INFO 45868 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.
2019-11-12 15:30:35.376  INFO 45868 --- [           main] c.i.s.lab19.datasourcepool.Application   : [run][usersDataSource 获得连接：HikariProxyConnection@795748540 wrapping com.mysql.jdbc.JDBC4Connection@7c098bb3]
</code></pre>
    <ul>
     <li>
      可以看到，两个 HikariDataSource 成功初始化。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f417365356771652f:61727469636c652f64657461696c732f313436313538373431" class_="artid" style="display:none">
 </p>
</div>


