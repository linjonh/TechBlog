---
layout: post
title: "分布式系统设计架构能力"
date: 2025-03-06 17:39:46 +0800
description: "通过深入理解上述技术点，并结合实际场景灵活运用，能够设计出高可用、可扩展的分布式系统。"
keywords: "分布式系统设计（架构能力）"
categories: ['未分类']
tags: ['架构', 'Java']
artid: "146076221"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146076221
    alt: "分布式系统设计架构能力"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146076221
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146076221
cover: https://bing.ee123.net/img/rand?artid=146076221
image: https://bing.ee123.net/img/rand?artid=146076221
img: https://bing.ee123.net/img/rand?artid=146076221
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     分布式系统设计（架构能力）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     <strong>
      一、微服务架构
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        服务治理
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Nacos 注册中心（AP模式）
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           CAP选择
          </strong>
          ：Nacos 默认采用 AP 模式（可用性 + 分区容忍性），通过心跳检测实现服务健康管理。
         </li>
         <li>
          <strong>
           服务发现
          </strong>
          ：客户端定时拉取服务列表，支持权重路由和元数据过滤。
         </li>
         <li>
          <strong>
           配置管理
          </strong>
          ：通过
          <code>
           dataId
          </code>
          和
          <code>
           group
          </code>
          动态推送配置，支持灰度发布。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          Sentinel 熔断规则持久化
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           规则存储
          </strong>
          ：将流控、熔断规则持久化到 Nacos/ZooKeeper，避免重启丢失。
         </li>
         <li>
          <strong>
           动态更新
          </strong>
          ：通过
          <code>
           DataSource
          </code>
          接口监听配置中心变化，实时生效。
         </li>
        </ul>
        <pre><code class="language-java">// 示例：Sentinel 规则持久化到 Nacos 
ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = new NacosDataSource&lt;&gt;( nacosServerAddr, groupId, dataId, source -&gt; JSON.parseObject(source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() {}) ); FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</code></pre>
        <p>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分布式事务
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Seata AT模式
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           两阶段流程
          </strong>
          ：
          <ol>
           <li>
            <strong>
             一阶段
            </strong>
            ：执行业务 SQL，生成 UNDO_LOG（数据快照）。
           </li>
           <li>
            <strong>
             二阶段
            </strong>
            ：提交时删除 UNDO_LOG；回滚时通过 UNDO_LOG 恢复数据。
           </li>
          </ol>
         </li>
         <li>
          <strong>
           全局锁
          </strong>
          ：TC（事务协调器）通过全局锁避免脏写。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          最大努力通知型事务
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           适用场景
          </strong>
          ：跨系统最终一致性（如支付成功后通知商户）。
         </li>
         <li>
          <strong>
           实现步骤
          </strong>
          ：
          <ol>
           <li>
            本地事务提交后，异步发送通知消息。
           </li>
           <li>
            消息队列保证至少一次投递，接收方需幂等处理。
           </li>
          </ol>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        网关设计
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Spring Cloud Gateway 过滤器链
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           核心过滤器
          </strong>
          ：
          <ul>
           <li>
            <code>
             GlobalFilter
            </code>
            ：全局过滤（如鉴权、日志）。
           </li>
           <li>
            <code>
             GatewayFilter
            </code>
            ：路由级过滤（如添加请求头）。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           自定义过滤器
          </strong>
          ：
          <pre><code class="language-java">@Component 
public class AuthFilter implements GlobalFilter { 
    @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { 
        if (!checkAuth(exchange.getRequest())) { 
            return exchange.getResponse().setComplete(); 
            // 拦截 
        } 
    return chain.filter(exchange); } }</code></pre>
          <p>
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          动态路由配置
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           基于Nacos
          </strong>
          ：监听 Nacos 配置变化，刷新路由表。
         </li>
         <li>
          <strong>
           API 动态更新
          </strong>
          ：通过
          <code>
           RouteDefinitionRepository
          </code>
          接口实现。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      二、中间件核心
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        Redis
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          集群模式
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           Cluster分片
          </strong>
          ：
          <ul>
           <li>
            16384个哈希槽，每个节点负责部分槽位。
           </li>
           <li>
            客户端路由：通过
            <code>
             CRC16(key) % 16384
            </code>
            计算槽位。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           Codis方案
          </strong>
          ：
          <ul>
           <li>
            代理层（Codis-Proxy）负责分片，依赖 ZooKeeper 维护元数据。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          持久化策略
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           RDB
          </strong>
          ：定时快照，恢复快但可能丢失数据。
         </li>
         <li>
          <strong>
           AOF
          </strong>
          ：追加日志，数据安全但文件较大。
         </li>
         <li>
          <strong>
           混合模式
          </strong>
          ：RDB 全量 + AOF 增量（Redis 4.0+）。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          缓存问题解决方案
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           穿透
          </strong>
          ：布隆过滤器（
          <code>
           RedissonBloomFilter
          </code>
          ）拦截无效请求。
         </li>
         <li>
          <strong>
           击穿
          </strong>
          ：互斥锁（
          <code>
           SET key value NX PX 3000
          </code>
          ）防止并发重建。
         </li>
         <li>
          <strong>
           雪崩
          </strong>
          ：随机过期时间（基础过期时间 + 随机偏移量）。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Kafka
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          ISR机制
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           In-Sync Replicas
          </strong>
          ：与 Leader 保持同步的副本集合。
         </li>
         <li>
          <strong>
           Leader选举
          </strong>
          ：当 Leader 失效时，从 ISR 中选择新 Leader。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          零拷贝技术
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           sendfile系统调用
          </strong>
          ：数据直接从磁盘文件传输到网卡，绕过用户态。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          Exactly-Once语义
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           幂等生产者
          </strong>
          ：通过 PID + Sequence Number 去重。
         </li>
         <li>
          <strong>
           事务消息
          </strong>
          ：跨分区原子性写入（需配合事务协调器）。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        RocketMQ
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          事务消息流程
         </strong>
        </p>
        <ol>
         <li>
          发送半消息（对消费者不可见）。
         </li>
         <li>
          执行本地事务，提交或回滚。
         </li>
         <li>
          Broker 根据事务状态提交或丢弃消息。
         </li>
        </ol>
       </li>
       <li>
        <p>
         <strong>
          顺序消息实现
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           MessageQueueSelector
          </strong>
          ：通过相同选择策略（如订单ID哈希）将消息发送到同一队列。
         </li>
         <li>
          消费者单线程顺序消费。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      三、高可用设计
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        限流降级
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          滑动窗口算法
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           实现
          </strong>
          ：将时间划分为多个小窗口，统计窗口内请求量。
         </li>
         <li>
          <strong>
           优势
          </strong>
          ：比固定窗口更平滑，避免临界突发流量。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          令牌桶实现（Resilience4j）
         </strong>
        </p>
        <pre><code class="language-java">// 配置每秒10个令牌 
RateLimiterConfig config = RateLimiterConfig
    .custom()                     
    .limitRefreshPeriod(Duration.ofSeconds(1)) 
    .limitForPeriod(10) 
    .build(); 
RateLimiter limiter = RateLimiter.of("apiLimiter", config);</code></pre>
        <p>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        容灾方案
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          同城双活
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           数据同步
          </strong>
          ：基于数据库主从复制或 DRBD 块级同步。
         </li>
         <li>
          <strong>
           流量切换
          </strong>
          ：DNS 或负载均衡器（如 Nginx）切换流量。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          异地多活
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           单元化路由
          </strong>
          ：按用户 ID 哈希路由到指定机房（如用户A固定访问北京机房）。
         </li>
         <li>
          <strong>
           数据最终一致
          </strong>
          ：通过消息队列异步同步数据。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        压测实战
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          JMeter全链路压测
         </strong>
        </p>
        <ol>
         <li>
          <strong>
           脚本录制
          </strong>
          ：使用 JMeter 代理服务器录制用户操作。
         </li>
         <li>
          <strong>
           参数化
          </strong>
          ：CSV 文件驱动多用户登录（不同账号）。
         </li>
         <li>
          <strong>
           分布式压测
          </strong>
          ：控制机（Master）调度多台压力机（Slave）。
         </li>
         <li>
          <strong>
           监控指标
          </strong>
          ：TPS、响应时间、错误率、资源利用率（CPU/内存）。
         </li>
        </ol>
       </li>
       <li>
        <p>
         <strong>
          结果分析
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           瓶颈定位
          </strong>
          ：数据库慢 SQL、线程池满、缓存命中率低。
         </li>
         <li>
          <strong>
           优化建议
          </strong>
          ：增加索引、调整线程池参数、预热缓存。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      四、总结与实战案例
     </strong>
    </h5>
    <p>
     <strong>
      案例：电商大促系统设计
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       挑战
      </strong>
      ：秒杀场景下的高并发（10万QPS）、数据一致性。
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：
      <ol>
       <li>
        <strong>
         流量削峰
        </strong>
        ：MQ 队列缓冲请求，异步处理订单。
       </li>
       <li>
        <strong>
         库存扣减
        </strong>
        ：Redis Lua 脚本保证原子性，异步同步到数据库。
       </li>
       <li>
        <strong>
         降级策略
        </strong>
        ：核心功能（下单）优先，非核心功能（推荐）降级。
       </li>
      </ol>
     </li>
    </ul>
    <p>
     通过深入理解上述技术点，并结合实际场景灵活运用，能够设计出高可用、可扩展的分布式系统。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7171313334343639313732372f:61727469636c652f64657461696c732f313436303736323231" class_="artid" style="display:none">
 </p>
</div>


