---
layout: post
title: "Spring-构造器注入和setter注入的比较"
date: 2025-03-07 18:24:33 +0800
description: "在 Spring 框架中，构造器注入（Constructor Injection）和 Setter 注入（Setter Injection）是实现依赖注入（DI）的两种主要方式。它们的核心区别在于依赖注入的时机、代码设计理念以及适用场景。以下是两者的详细比较：优点：不可变性：依赖字段可声明为 ，确保线程安全和对象状态一致性。明确性：强制要求所有必需依赖，避免 。代码简洁性：结合 Lombok 的 ，可自动生成构造方法。兼容测试：易于在单元测试中手动注入依赖。缺点：灵活性不足：对可选依赖支持较弱，需通过重载构"
keywords: "Spring 构造器注入和setter注入的比较"
categories: ['未分类']
tags: ['Spring', 'Log', 'Java']
artid: "146102344"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146102344
    alt: "Spring-构造器注入和setter注入的比较"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146102344
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146102344
cover: https://bing.ee123.net/img/rand?artid=146102344
image: https://bing.ee123.net/img/rand?artid=146102344
img: https://bing.ee123.net/img/rand?artid=146102344
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring 构造器注入和setter注入的比较
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、比较说明
    </h2>
    <p>
     在 Spring 框架中，构造器注入（Constructor Injection）和 Setter 注入（Setter Injection）是实现依赖注入（DI）的两种主要方式。它们的核心区别在于依赖注入的时机、代码设计理念以及适用场景。以下是两者的详细比较：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 核心区别
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         特性
        </strong>
       </th>
       <th>
        <strong>
         构造器注入
        </strong>
       </th>
       <th>
        <strong>
         Setter 注入
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         注入方式
        </strong>
       </td>
       <td>
        通过类的构造方法注入依赖。
       </td>
       <td>
        通过 Setter 方法注入依赖。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         依赖不可变性
        </strong>
       </td>
       <td>
        依赖通常声明为
        <code>
         final
        </code>
        ，确保对象创建后不可变。
       </td>
       <td>
        依赖可变，可在对象生命周期中修改。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         依赖必要性
        </strong>
       </td>
       <td>
        强制要求依赖，适用于必需依赖。
       </td>
       <td>
        可选依赖，允许部分依赖为
        <code>
         null
        </code>
        。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         初始化完整性
        </strong>
       </td>
       <td>
        对象创建时即完成依赖注入，保证完全初始化。
       </td>
       <td>
        对象可能处于“部分初始化”状态（依赖未完全注入）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         循环依赖处理
        </strong>
       </td>
       <td>
        无法解决构造器级别的循环依赖（Spring 会抛出异常）。
       </td>
       <td>
        可通过延迟注入解决循环依赖。
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 优缺点对比
     </strong>
    </h4>
    <h5>
     <strong>
      构造器注入
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        优点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          不可变性
         </strong>
         ：依赖字段可声明为
         <code>
          final
         </code>
         ，确保线程安全和对象状态一致性。
        </p>
       </li>
       <li>
        <p>
         <strong>
          明确性
         </strong>
         ：强制要求所有必需依赖，避免
         <code>
          NullPointerException
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          代码简洁性
         </strong>
         ：结合 Lombok 的
         <code>
          @RequiredArgsConstructor
         </code>
         ，可自动生成构造方法。
        </p>
       </li>
       <li>
        <p>
         <strong>
          兼容测试
         </strong>
         ：易于在单元测试中手动注入依赖。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          灵活性不足
         </strong>
         ：对可选依赖支持较弱，需通过重载构造方法实现。
        </p>
       </li>
       <li>
        <p>
         <strong>
          循环依赖限制
         </strong>
         ：无法处理构造器级别的循环依赖。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      Setter 注入
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        优点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          灵活性高
         </strong>
         ：支持可选依赖，允许动态重新配置依赖。
        </p>
       </li>
       <li>
        <p>
         <strong>
          解决循环依赖
         </strong>
         ：Spring 容器可处理 Setter 注入的循环依赖。
        </p>
       </li>
       <li>
        <p>
         <strong>
          向后兼容
         </strong>
         ：适合逐步迁移旧代码到依赖注入模式。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        缺点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          状态不稳定
         </strong>
         ：对象可能在未完全初始化时被使用（如缺少必需依赖）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          线程安全风险
         </strong>
         ：依赖可变性可能导致多线程环境下的问题。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 适用场景
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         场景
        </strong>
       </th>
       <th>
        <strong>
         推荐方式
        </strong>
       </th>
       <th>
        <strong>
         理由
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         必需依赖
        </strong>
       </td>
       <td>
        构造器注入
       </td>
       <td>
        强制依赖不可为空，确保对象完全初始化。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         可选依赖
        </strong>
       </td>
       <td>
        Setter 注入
       </td>
       <td>
        允许依赖为
        <code>
         null
        </code>
        ，或通过默认值处理。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         不可变对象
        </strong>
       </td>
       <td>
        构造器注入
       </td>
       <td>
        结合
        <code>
         final
        </code>
        字段，保证线程安全。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         循环依赖
        </strong>
       </td>
       <td>
        Setter 注入
       </td>
       <td>
        Spring 容器支持通过 Setter 解决循环依赖。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         遗留代码迁移
        </strong>
       </td>
       <td>
        Setter 注入
       </td>
       <td>
        逐步引入依赖注入，无需修改现有构造方法。
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      4. 代码示例
     </strong>
    </h4>
    <h5>
     <strong>
      构造器注入
     </strong>
    </h5>
    <p>
     java
    </p>
    <p>
     复制
    </p>
    <pre>@Component
public class OrderService {
    private final PaymentService paymentService; // final 字段

    @Autowired // Spring 4.3+ 可省略单构造器的 @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}</pre>
    <h5>
     <strong>
      Setter 注入
     </strong>
    </h5>
    <p>
     java
    </p>
    <p>
     复制
    </p>
    <pre>@Component
public class UserService {
    private EmailService emailService;

    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}</pre>
    <hr/>
    <h4>
     <strong>
      5. 现代实践建议
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        优先使用构造器注入
       </strong>
       ：Spring 官方推荐构造器注入作为默认选择，尤其在 Spring 4.x+ 中，因其对不可变性和安全性的支持。
      </p>
     </li>
     <li>
      <p>
       <strong>
        结合 Lombok 简化代码
       </strong>
       ：使用
       <code>
        @RequiredArgsConstructor
       </code>
       自动生成构造方法，减少样板代码。
      </p>
     </li>
     <li>
      <p>
       <strong>
        谨慎处理循环依赖
       </strong>
       ：循环依赖通常是设计问题的信号，应优先通过重构解决，而非依赖 Setter 注入。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     构造器注入和 Setter 注入各有优劣，选择取决于具体需求：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        构造器注入
       </strong>
       ：适用于强制依赖、不可变对象和高安全性场景。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Setter 注入
       </strong>
       ：适用于可选依赖、动态配置或遗留代码迁移。
      </p>
     </li>
    </ul>
    <p>
     在实际项目中，可以混合使用两者，但应以构造器注入为主，遵循“依赖明确、状态可靠”的设计原则。
    </p>
    <h2>
     二、最佳实践
    </h2>
    <p>
     在 Spring 的构造器注入中，将依赖字段声明为
     <code>
      final
     </code>
     可以增强线程安全和对象状态一致性，这主要归功于
     <strong>
      Java 内存模型（JMM）对
      <code>
       final
      </code>
      字段的特殊处理
     </strong>
     和
     <strong>
      不可变性（Immutability）
     </strong>
     的设计原则。以下是具体原因：
    </p>
    <hr/>
    <h4>
     <strong>
      1.
      <code>
       final
      </code>
      字段的内存可见性保证
     </strong>
    </h4>
    <p>
     根据 Java 内存模型（JSR-133）的规范：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        初始化安全性
       </strong>
       ：当一个对象被正确构造（即构造方法没有发生
       <code>
        this
       </code>
       引用逸出）时，所有线程在访问该对象的
       <code>
        final
       </code>
       字段时，
       <strong>
        无需同步
       </strong>
       即可看到构造方法中初始化的值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        禁止指令重排序
       </strong>
       ：JVM 会对
       <code>
        final
       </code>
       字段的写操作插入内存屏障，确保构造方法中对
       <code>
        final
       </code>
       字段的赋值操作不会被重排序到对象引用发布之后。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      示例
     </strong>
    </h5>
    <p>
     java
    </p>
    <p>
     复制
    </p>
    <pre>public class OrderService {
    private final PaymentService paymentService; // final 字段

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService; // 初始化 final 字段
    }
}</pre>
    <ul>
     <li>
      <p>
       当一个线程创建
       <code>
        OrderService
       </code>
       对象后，其他线程在访问
       <code>
        paymentService
       </code>
       时，一定能看到构造方法中初始化的值，不会出现未初始化或部分初始化的状态。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      2. 不可变性（Immutability）
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        字段不可变
       </strong>
       ：
       <code>
        final
       </code>
       字段一旦被赋值，其引用不能再被修改（即不能通过
       <code>
        setter
       </code>
       或其他方法重新赋值）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        状态一致性
       </strong>
       ：对象的状态（依赖的组件）在构造完成后即固定，不会因后续代码的意外修改而破坏一致性。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      对比 Setter 注入
     </strong>
    </h5>
    <p>
     java
    </p>
    <p>
     复制
    </p>
    <pre>public class UserService {
    private EmailService emailService; // 非 final 字段

    public void setEmailService(EmailService emailService) {
        this.emailService = emailService; // 可能被多次调用或并发修改
    }
}</pre>
    <ul>
     <li>
      <p>
       <strong>
        线程安全问题
       </strong>
       ：如果多线程同时调用
       <code>
        setEmailService
       </code>
       ，可能导致竞态条件（Race Condition），最终
       <code>
        emailService
       </code>
       的值可能不一致。
      </p>
     </li>
     <li>
      <p>
       <strong>
        状态不一致
       </strong>
       ：对象可能在某个时刻处于“部分初始化”状态（例如，依赖未完全注入）。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 避免
      <code>
       this
      </code>
      引用逸出
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        构造器注入的天然优势
       </strong>
       ：在构造方法中完成依赖注入，可以避免在对象未完全初始化前暴露
       <code>
        this
       </code>
       引用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         final
        </code>
        字段的强制约束
       </strong>
       ：必须在构造方法中完成
       <code>
        final
       </code>
       字段的初始化，否则代码无法编译。这强制开发者保证依赖的完整性。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      反例（Setter 注入中的风险）
     </strong>
    </h5>
    <p>
     java
    </p>
    <p>
     复制
    </p>
    <pre>public class UserService {
    private EmailService emailService;

    public UserService() {
        // 构造方法中可能提前暴露 this 引用（错误实践）
        SomeRegistry.register(this); // 此时 emailService 尚未初始化！
    }

    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}</pre>
    <ul>
     <li>
      <p>
       如果其他线程通过
       <code>
        SomeRegistry
       </code>
       获取到未完全初始化的
       <code>
        UserService
       </code>
       实例，可能导致
       <code>
        NullPointerException
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      4. 实际场景中的线程安全
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        无状态服务
       </strong>
       ：Spring 中的 Bean 默认是单例的，如果 Bean 是无状态的（例如仅依赖其他组件），结合
       <code>
        final
       </code>
       字段的不可变性，天然支持多线程并发访问。
      </p>
     </li>
     <li>
      <p>
       <strong>
        无需额外同步
       </strong>
       ：由于依赖不可变，无需使用
       <code>
        synchronized
       </code>
       或
       <code>
        volatile
       </code>
       等同步机制。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      对比 Setter 注入的线程安全成本
     </strong>
    </h5>
    <p>
     java
    </p>
    <p>
     复制
    </p>
    <pre>public class UserService {
    private volatile EmailService emailService; // 需要 volatile 保证可见性

    public synchronized void setEmailService(EmailService emailService) {
        this.emailService = emailService; // 需要同步锁保证原子性
    }
}</pre>
    <ul>
     <li>
      <p>
       为了线程安全，Setter 注入可能需要额外的同步机制，增加了代码复杂性和性能开销。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     通过构造器注入将依赖字段声明为
     <code>
      final
     </code>
     ，可以从以下层面保证线程安全和状态一致性：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        内存可见性
       </strong>
       ：JMM 确保
       <code>
        final
       </code>
       字段的初始化值对所有线程立即可见。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不可变性
       </strong>
       ：依赖引用不可修改，消除竞态条件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        初始化完整性
       </strong>
       ：强制依赖在对象创建时完成注入，避免部分初始化状态。
      </p>
     </li>
    </ol>
    <p>
     因此，
     <strong>
      构造器注入 +
      <code>
       final
      </code>
      字段
     </strong>
     是 Spring 中实现线程安全依赖注入的最佳实践。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f33373134353834342f:61727469636c652f64657461696c732f313436313032333434" class_="artid" style="display:none">
 </p>
</div>


