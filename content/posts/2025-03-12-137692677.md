---
layout: post
title: "2020年蓝桥杯第十一届CC大学B组第一次真题及代码"
date: 2025-03-12 23:02:05 +0800
description: "2020年蓝桥杯第十一届C&C++大学B组（第一次）真题及代码（1A：跑步训练（填空5分_模拟） 2B：纪念日（填空5分_日期计算） 3C：合并检测（填空10分_数学） 4D：REPEAT程序（填空10分_模拟） 5E：矩阵（填空15分_dp） 6F：整除序列（编程题15分） 7G：解码（编程题20分） 8H：走方格（编程题20分） 9I：整数拼接（编程题25分） 10J：网络分析（编程题25分））"
keywords: "2020年蓝桥杯第十一届C&C++大学B组（第一次）真题及代码"
categories: ['蓝桥杯CC真题']
tags: ['蓝桥杯', 'C', 'C']
artid: "137692677"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=137692677
    alt: "2020年蓝桥杯第十一届CC大学B组第一次真题及代码"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=137692677
featuredImagePreview: https://bing.ee123.net/img/rand?artid=137692677
cover: https://bing.ee123.net/img/rand?artid=137692677
image: https://bing.ee123.net/img/rand?artid=137692677
img: https://bing.ee123.net/img/rand?artid=137692677
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     2020年蓝桥杯第十一届C&amp;C++大学B组（第一次）真题及代码
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="1A%EF%BC%9A%E7%BB%84%E9%98%9F%EF%BC%88%E5%A1%AB%E7%A9%BA5%E5%88%86_%E6%89%8B%E7%AE%97%EF%BC%89-toc" style="margin-left:0px">
     <a href="#1A%EF%BC%9A%E7%BB%84%E9%98%9F%EF%BC%88%E5%A1%AB%E7%A9%BA5%E5%88%86_%E6%89%8B%E7%AE%97%EF%BC%89" rel="nofollow">
      1A：跑步训练（填空5分_模拟）
     </a>
    </p>
    <p id="2B%EF%BC%9A%E7%BA%AA%E5%BF%B5%E6%97%A5%EF%BC%88%E5%A1%AB%E7%A9%BA5%E5%88%86_%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97%EF%BC%89-toc" style="margin-left:0px">
     <a href="#2B%EF%BC%9A%E7%BA%AA%E5%BF%B5%E6%97%A5%EF%BC%88%E5%A1%AB%E7%A9%BA5%E5%88%86_%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97%EF%BC%89" rel="nofollow">
      2B：纪念日（填空5分_日期计算）
     </a>
    </p>
    <p id="C%EF%BC%9A%E5%88%B7%E9%A2%98%E7%BB%9F%E8%AE%A1-toc" style="margin-left:0px">
     <a href="#C%EF%BC%9A%E5%88%B7%E9%A2%98%E7%BB%9F%E8%AE%A1" rel="nofollow">
      3C：合并检测（填空10分_数学）
     </a>
    </p>
    <p id="D%EF%BC%9A%E4%BF%AE%E5%89%AA%E7%81%8C%E6%9C%A8-toc" style="margin-left:0px">
     <a href="#D%EF%BC%9A%E4%BF%AE%E5%89%AA%E7%81%8C%E6%9C%A8" rel="nofollow">
      4D：REPEAT程序（填空10分_模拟）
     </a>
    </p>
    <p id="E%EF%BC%9AX%E8%BF%9B%E5%88%B6%E5%87%8F%E6%B3%95-toc" style="margin-left:0px">
     <a href="#E%EF%BC%9AX%E8%BF%9B%E5%88%B6%E5%87%8F%E6%B3%95" rel="nofollow">
      5E：矩阵（填空15分_dp）
     </a>
    </p>
    <p id="F%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%90%E7%9F%A9%E9%98%B5-toc" style="margin-left:0px">
     <a href="#F%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%90%E7%9F%A9%E9%98%B5" rel="nofollow">
      6F：整除序列（编程题15分）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2B%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2B%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89" rel="nofollow">
      解析代码（模拟）
     </a>
    </p>
    <p id="G%EF%BC%9A%E7%A7%AF%E6%9C%A8%E7%94%BB-toc" style="margin-left:0px">
     <a href="#G%EF%BC%9A%E7%A7%AF%E6%9C%A8%E7%94%BB" rel="nofollow">
      7G：解码（编程题20分）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88dp%2B%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88dp%2B%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89" rel="nofollow">
      解析代码（二叉树的数组遍历）
     </a>
    </p>
    <p id="I%EF%BC%9A%E6%9D%8E%E7%99%BD%E6%89%93%E9%85%92%E5%8A%A0%E5%BC%BA%E7%89%88-toc" style="margin-left:0px">
     <a href="#I%EF%BC%9A%E6%9D%8E%E7%99%BD%E6%89%93%E9%85%92%E5%8A%A0%E5%BC%BA%E7%89%88" rel="nofollow">
      8H：走方格（编程题20分）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%811%EF%BC%88dp%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%811%EF%BC%88dp%EF%BC%89" rel="nofollow">
      解析代码（dp）
     </a>
    </p>
    <p id="9I%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E7%BC%96%E7%A8%8B%E9%A2%9825%E5%88%86%EF%BC%89-toc" style="margin-left:0px">
     <a href="#9I%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E7%BC%96%E7%A8%8B%E9%A2%9825%E5%88%86%EF%BC%89" rel="nofollow">
      9I：整数拼接（编程题25分）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E6%95%B0%E5%AD%A6%2B%E8%B4%AA%E5%BF%83%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E6%95%B0%E5%AD%A6%2B%E8%B4%AA%E5%BF%83%EF%BC%89" rel="nofollow">
      解析代码1（暴力_超时）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%812%EF%BC%88%E6%95%B0%E5%AD%A6%2B%E5%93%88%E5%B8%8C%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%812%EF%BC%88%E6%95%B0%E5%AD%A6%2B%E5%93%88%E5%B8%8C%EF%BC%89" rel="nofollow">
      解析代码2（数学+哈希）
     </a>
    </p>
    <p id="10J%EF%BC%9A%E7%81%B5%E8%83%BD%E4%BC%A0%E8%BE%93%EF%BC%88%E7%BC%96%E7%A8%8B%E9%A2%9825%E5%88%86%EF%BC%89-toc" style="margin-left:0px">
     <a href="#10J%EF%BC%9A%E7%81%B5%E8%83%BD%E4%BC%A0%E8%BE%93%EF%BC%88%E7%BC%96%E7%A8%8B%E9%A2%9825%E5%88%86%EF%BC%89" rel="nofollow">
      10J：网络分析（编程题25分）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E5%89%8D%E7%BC%80%E5%92%8C%2B%E8%B4%AA%E5%BF%83%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E5%89%8D%E7%BC%80%E5%92%8C%2B%E8%B4%AA%E5%BF%83%EF%BC%89" rel="nofollow">
      解析代码1（普通并查集_超时）
     </a>
    </p>
    <p id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%812%EF%BC%88%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86_%E6%AD%A3%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px">
     <a href="#%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%812%EF%BC%88%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86_%E6%AD%A3%E8%A7%A3%EF%BC%89" rel="nofollow">
      解析代码2（带权并查集_正解）
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h2 id="1A%EF%BC%9A%E7%BB%84%E9%98%9F%EF%BC%88%E5%A1%AB%E7%A9%BA5%E5%88%86_%E6%89%8B%E7%AE%97%EF%BC%89">
     1A：跑步训练（填空5分_模拟）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      小明要做一个跑步训练。
      <br/>
      初始时，小明充满体力，体力值计为 10000 。如果小明跑步，每分钟损耗 600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。
      <br/>
      小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0 ，他就停止锻炼。
      <br/>
      请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。
     </p>
    </blockquote>
    <p>
     <strong>
      题目解析：
     </strong>
    </p>
    <p>
     首先求出每秒的损耗，之后模拟跑步休息的锻炼过程就可以，答案3880
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
	int power = 10000;
	int minute = 0;
	while (power &gt;= 600) // 两分钟-300
	{
		minute += 2;
		power -= 300;
	}
	//cout &lt;&lt; power &lt;&lt; endl; // 600体力跑60秒，剩余的体力还能跑 power / 10 秒
	cout &lt;&lt; minute * 60 + power / 10 &lt;&lt; endl; // 以秒输出，答案3880
	return 0;
}</code></pre>
    <hr/>
    <h2 id="2B%EF%BC%9A%E7%BA%AA%E5%BF%B5%E6%97%A5%EF%BC%88%E5%A1%AB%E7%A9%BA5%E5%88%86_%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97%EF%BC%89">
     2B：纪念日（填空5分_日期计算）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      <strong>
      </strong>
      2020 年 7 月 1 日是中国 共 产 党 成立 99 周年纪念日。
      <br/>
      中国 共 产 党 成立于 1921 年 7 月 23 日。
      <br/>
      请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共包含多少分钟？
     </p>
    </blockquote>
    <p>
     <strong>
      题目分析：
     </strong>
     打开计算器，答案52038720
    </p>
    <p>
     <img alt="" height="398" src="https://i-blog.csdnimg.cn/blog_migrate/238f98d3546fc227694a77be4d6f6001.png" width="311">
      <img alt="" height="328" src="https://i-blog.csdnimg.cn/blog_migrate/d5d02a6e6f6179c4bd872acf8cae48a2.png" width="364"/>
     </img>
    </p>
    <p>
     贴个代码：
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int yearDay(int year)
{
	if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))
	{
		return 366;
	}
	return 365;
}
int main()
{
	int time = 0;
	for (int i = 1922; i &lt;= 2020; ++i)
	{
		time += yearDay(i);
	}
	time -= 22;
	cout &lt;&lt; time * 24 * 60 &lt;&lt; endl;
	return 0;
}</code></pre>
    <hr/>
    <h2 id="C%EF%BC%9A%E5%88%B7%E9%A2%98%E7%BB%9F%E8%AE%A1">
     3C：合并检测（填空10分_数学）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情， A 国准备给大量民众进病毒核酸检测。
      <br/>
      然而，用于检测的试剂盒紧缺。为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（ k 个）采集的标本放到同一个试剂盒中进行检测。如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看，如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用了 k+1 个试剂盒完成了 k 个人的检测。
      <br/>
      A 国估计被测的民众的感染率大概是 1，呈均匀分布。请问 k 取多少能最节省试剂盒？
     </p>
    </blockquote>
    <p>
     <strong>
      题目解析：感染率是1%
     </strong>
     <strong>
      。。。加个百分号这么难。。。。。。答案10
     </strong>
    </p>
    <p>
     核心思路：假设总人数为100人，那么就有，对于k枚举 1~100 的范围内
    </p>
    <p>
     （1）对于 总人数100%k==0 的情况：需要的总的试剂盒为：（100/i）+ i
    </p>
    <p>
     解释：（100/i）：100个人中每次分为i个人 为 1组，那么总共就分为了 100/i组
    </p>
    <p>
     解释： +i是因为 它有1%的阳性率，（概率呈均匀分布）那么这100个人中就必定有人为阳性，那么就需要对，患阳性的那一组重新进行i个人的检测
    </p>
    <p>
     （2）对于 总人数100%k!=0 的情况：需要的总的试剂盒为：（100/i）+ 1 + i
    </p>
    <p>
     解释：对于除不尽的情况需要进行+1 处理，即被分为了（100/i）+1组，剩下的的解释就与上面相同
    </p>
    <pre><code class="language-cpp">
<code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
	int ans = 0;
	int sum = 0x3f3f3f3f; // 初始化为一个很大的数，因为要求的是小于的情况
	for (int i = 1; i &lt;= 100; i++) // 枚举所有的检测数 
	{
		if (100 % i == 0)
		{
			if (100 / i + i &lt; sum)
			{
				sum = 100 / i + i;
				ans = i; // 题目要求的是被分为多少组是最小的，所以需要进行记录
			}
		}
		else
		{
			if (100 / i + 1 + i &lt; sum)
			{
				sum = 100 / i + 1 + i;
				ans = i; // 记录当前最小的检测数
			}
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}</code></code></pre>
    <hr/>
    <h2 id="D%EF%BC%9A%E4%BF%AE%E5%89%AA%E7%81%8C%E6%9C%A8">
     4D：REPEAT程序（填空10分_模拟）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      附件 prog.txt 中是一个用某种语言写的程序。
      <br/>
      其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。
      <br/>
      例如如下片段：
     </p>
     <pre><code class="language-cpp">REPEAT 2:
 A = A + 4
  REPEAT 5:
  REPEAT 6:
   A = A + 5
  A = A + 7
 A = A + 8
A = A + 9</code></pre>
     <p>
      该片段中从 A = A + 4 所在的行到 A = A + 8 所在的行都在第一行的循环两次中。
      <br/>
      REPEAT 6: 所在的行到 A = A + 7 所在的行都在 REPEAT 5: 循环中。
      <br/>
      A = A + 5 实际总共的循环次数是 2 × 5 × 6 = 60 次。
      <br/>
      请问该程序执行完毕之后，A 的值是多少？
     </p>
    </blockquote>
    <p>
     题目解析：
    </p>
    <p>
     从题目中看出REPEAT就是一个for循环，后面的数字就是循环次数，循环控制的范围由缩进表达。然后模拟出题就可以。
    </p>
    <p>
     答案403
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
	int a = 0;
	for (int i = 0; i &lt; 2; i++) // 枚举所有的检测数 
	{
		a += 4;
		for (int j = 0; j &lt; 5; ++j)
		{
			for (int k = 0; k &lt; 6; ++k)
			{
				a += 5;
			}
			a += 7;
		}
		a += 8;
	}
	a += 9;
	cout &lt;&lt; a &lt;&lt; endl; // 答案403
	return 0;
}</code></pre>
    <hr/>
    <h2 id="E%EF%BC%9AX%E8%BF%9B%E5%88%B6%E5%87%8F%E6%B3%95">
     5E：矩阵（填空15分_dp）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      <strong>
      </strong>
      把 1∼2020 放在 2×1010 的矩阵里。要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？
      <br/>
      答案很大，你只需要给出方案数除以 2020 的余数即可。
     </p>
    </blockquote>
    <p>
     <strong>
      题目解析：
     </strong>
    </p>
    <p style="margin-left:0">
     <span style="color:#4d4d4d">
      <span style="background-color:#ffffff">
       f [ i ] [ j ]：第一行放 i 个数字，第二行放 j 个数字的方案数量；
      </span>
     </span>
    </p>
    <ol style="margin-left:0">
     <li>
      将当前数放在第一行：f [ i ] [ j ] += f[ i - 1] [ j ]；
     </li>
     <li>
      将当前数放在第二行：f [ i ] [ j ] += f[ i ] [ j - 1 ]；
     </li>
    </ol>
    <p>
     答案：1340
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int f[1020][1020];
int main()
{
	f[0][0] = 1; // 两行一个数字都不放，也是一种方案
	for (int i = 0; i &lt;= 1010; i++)
	{
		for (int j = 0; j &lt;= i; j++)
		{
			if (i - 1 &gt;= j) // 转移前的状态也要合法，即第一行的数量不小于第二行的数量
				f[i][j] += f[i - 1][j] % 2020;
			if (j - 1 &gt;= 0)
				f[i][j] += f[i][j - 1] % 2020;
		}
	}
	cout &lt;&lt; f[1010][1010] &lt;&lt; endl; // 答案1340
	return 0;
}</code></pre>
    <hr/>
    <h2 id="F%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%90%E7%9F%A9%E9%98%B5">
     6F：整除序列（编程题15分）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。
     </p>
     <p>
      <br/>
      【输入格式】
      <br/>
      输入一行包含一个整数 n。
      <br/>
      【输出格式】
      <br/>
      输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。
     </p>
     <p>
      <br/>
      【评测用例规模与约定】
      <br/>
      对于 80% 的评测用例，1 ≤ n ≤ 10^9。
      <br/>
      对于所有评测用例，1 ≤ n ≤ 10^18。
     </p>
    </blockquote>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2B%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89">
     解析代码（模拟）
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
	long long n = 0;
	cin &gt;&gt; n;
	while (n &gt;= 1)
	{
		cout &lt;&lt; n &lt;&lt; " ";
		//n &gt;&gt;= 1;
		n /= 2;
	}
	return 0;
}</code></pre>
    <hr/>
    <h2 id="G%EF%BC%9A%E7%A7%AF%E6%9C%A8%E7%94%BB">
     7G：解码（编程题20分）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      小明有一串很长的英文字母，可能包含大写和小写。在这串字母中，有很多连续的是重复的。小明想了一个办法将这串字母表达得更短：将连续的几个相同字母写成字母 + 出现次数的形式。
     </p>
     <p>
      例如，连续的 5 个 a，即 aaaaa，小明可以简写成 a5（也可能简写成 a4a、aa3a 等）。
     </p>
     <p>
      对于这个例子：HHHellllloo，小明可以简写成 H3el5o2。
     </p>
     <p>
      为了方便表达，小明不会将连续的超过 9 个相同的字符写成简写的形式。
     </p>
     <p>
      现在给出简写后的字符串，请帮助小明还原成原来的串。
     </p>
     <p>
     </p>
     <p>
      <strong>
       输入格式
      </strong>
      <br/>
      输入一行包含一个字符串。
     </p>
     <p>
      <strong>
       输出格式
      </strong>
      <br/>
      输出一个字符串，表示还原后的串。
     </p>
     <p>
     </p>
     <p>
      <strong>
       样例输入
      </strong>
      <br/>
      H3el5o2
     </p>
     <p>
      <strong>
       样例输出
      </strong>
      <br/>
      HHHellllloo
     </p>
     <p>
      <strong>
       数据范围
      </strong>
      <br/>
      对于所有评测用例，字符串由大小写英文字母和数字组成，长度不超过100。
      <br/>
      请注意原来的串长度可能超过 100。
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      题目解析：直接模拟即可。
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
	string str;
	cin &gt;&gt; str;
	int n = str.size();
	for (int i = 0; i &lt; n; ++i)
	{
		int n = (str[i] - '0');
		if (n &gt;= 0 &amp;&amp; n &lt;= 9)
		{
			for (int j = 0; j &lt; n - 1; ++j) // 之前已经输出一个了
			{
				cout &lt;&lt; str[i - 1];
			}
		}
		else
		{
			cout &lt;&lt; str[i];
		}
	}
	return 0;
}</code></pre>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88dp%2B%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89">
     解析代码（二叉树的数组遍历）
    </h3>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 10;
long long arr[N];

int main()
{
	int n;
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; arr[i];
	}
	int maxv = -INF;
	int depth = 1, res = 1;
	for (int i = 1; i &lt;= n; i *= 2)
	{
		long long s = 0; // 完全二叉树每层的开头为2^(n-1)，结尾则是 2^n - 1
		for (int j = i; j &lt;= i * 2 - 1 &amp;&amp; j &lt;= n; j++) // j++就是同一层的下一个
		{
			s += arr[j];
		}
		if (s &gt; maxv)
		{
			maxv = s;
			res = depth;
		}
		depth++;
	}
	cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}</code></pre>
    <hr/>
    <h2 id="I%EF%BC%9A%E6%9D%8E%E7%99%BD%E6%89%93%E9%85%92%E5%8A%A0%E5%BC%BA%E7%89%88">
     8H：走方格（编程题20分）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      在平面上有一些二维的点阵。
      <br/>
      这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。
      <br/>
      现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。
      <br/>
      注意，如果行号和列数都是偶数，不能走入这一格中。
      <br/>
      问有多少种方案。
     </p>
     <p>
      <br/>
      【输入格式】
      <br/>
      输入一行包含两个整数 n, m。
      <br/>
      【输出格式】
      <br/>
      输出一个整数，表示答案。
     </p>
     <p>
      <img alt="" height="268" src="https://i-blog.csdnimg.cn/blog_migrate/b2b8b18a4c30739918f3b4ecc66f4869.png" width="173">
       <br/>
       【评测用例规模与约定】
       <br/>
       对于所有评测用例，1≤n≤30,1≤m≤30。
      </img>
     </p>
    </blockquote>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%811%EF%BC%88dp%EF%BC%89">
     解析代码（dp）
    </h3>
    <p>
     题目解析：简单的dp，dp [ i ] [ j ] 表示走到第 n 行第 m 列的方案数
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main()
{
	int n = 0, m = 0;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));
	// dp [ i ] [ j ] 表示走到第 n 行第 m 列的方案数
	dp[0][1] = 1;
	for (int i = 1; i &lt;= n; ++i)
	{
		for (int j = 1; j &lt;= m; ++j)
		{
			if (i % 2 == 1 || j % 2 == 1)
			{
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}
	}
	cout &lt;&lt; dp[n][m] &lt;&lt; endl;
	return 0;
}</code></pre>
    <hr/>
    <h2 id="9I%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E7%BC%96%E7%A8%8B%E9%A2%9825%E5%88%86%EF%BC%89">
     9I：整数拼接（编程题25分）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
      <img alt="" height="763" src="https://i-blog.csdnimg.cn/blog_migrate/692febb96766d942b429790e709fdaff.png" width="1200"/>
     </p>
     <p>
      样例输入
     </p>
     <pre>4 2
1 2 3 4
</pre>
     <p>
      样例输出
     </p>
     <pre>6</pre>
     <p>
      【评测用例规模与约定】
      <br/>
      对于 30% 的评测用例，1≤n≤1000，1≤K≤20，1≤Ai≤10^4。
      <br/>
      对于所有评测用例，1≤n≤10^5，1≤K≤10^5，1≤Ai≤10^9。
     </p>
    </blockquote>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E6%95%B0%E5%AD%A6%2B%E8%B4%AA%E5%BF%83%EF%BC%89">
     解析代码1（暴力_超时）
    </h3>
    <p>
     <strong>
      题目解析：
     </strong>
     暴力模拟：（时间超限，过了0个民间测试用例。。。）
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
	int n = 0, k = 0;
	cin &gt;&gt; n &gt;&gt; k;
	vector&lt;int&gt; arr(n);
	for (int i = 0; i &lt; n; ++i)
	{
		cin &gt;&gt; arr[i];
	}
	int cnt = 0;
	for (int i = 0; i &lt; n; ++i)
	{
		for (int j = 0; j &lt; n; ++j)
		{
			if (i == j)
				continue;
			string tmp1 = to_string(arr[i]);
			string tmp2 = to_string(arr[j]);
			string tmp = tmp1 + tmp2;
			long long x = atoi(tmp.c_str());
			if (x % k == 0)
				++cnt;
		}
	}
	cout &lt;&lt; cnt &lt;&lt; endl;
	return 0;
}</code></pre>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%812%EF%BC%88%E6%95%B0%E5%AD%A6%2B%E5%93%88%E5%B8%8C%EF%BC%89">
     解析代码2（数学+哈希）
    </h3>
    <p>
     根据题意可推出，A与B拼接可以推出等式 A + 10 ^ x + B ，题目可以翻译成是求A + 10 ^ x + B % K == 0的个数。
    </p>
    <p>
     通过观察等式A + 10 ^ x ^ +B % K == 0进行等价变形，变成(A + 10 ^ x) % K = -B % K ，并且B与x正相关，则可以用一个哈希表存起来A + 10x，用空间换时间，那么我们的两重循环就可以换成一个只枚举A，调用哈希只需要O(1)的时间，到现在看来题目就迎刃而解了，此时时间复杂度为O(n)。补充： - B % K == (K - (B % K)) % K（感兴趣的话百度了解一下）
    </p>
    <pre><code class="language-cpp">//#include&lt;bits/stdc++.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
const int N = 100010;
typedef long long ll;
ll arr[N], hash_table[11][N];
int main()
{
	int n = 0, k = 0;
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; ++i)
	{
		cin &gt;&gt; arr[i];
		ll t = arr[i] % k;
		for (int j = 0; j &lt; 11; ++j)
		{
			hash_table[j][t]++;
			t = t * 10 % k;
		}
	}
	ll res = 0;
	for (int i = 0; i &lt; n; ++i)
	{
		int len = to_string(arr[i]).size();
		res += hash_table[len][(k - (arr[i] % k)) % k];
		ll t = arr[i] % k;
		while (len--)
		{
			t = t * 10 % k;
		}
		if (t % k == (k - (arr[i] % k)) % k)
			--res; //判重 如果查找到的值包括自己，减掉自己
	}
	cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}</code></pre>
    <hr/>
    <h2 id="10J%EF%BC%9A%E7%81%B5%E8%83%BD%E4%BC%A0%E8%BE%93%EF%BC%88%E7%BC%96%E7%A8%8B%E9%A2%9825%E5%88%86%EF%BC%89">
     10J：网络分析（编程题25分）
    </h2>
    <blockquote>
     <p>
      <strong>
       题目描述：
      </strong>
     </p>
     <p>
      小明正在做一个网络实验。
      <br/>
      他设置了 n 台电脑，称为节点，用于收发和存储数据。
      <br/>
      初始时，所有节点都是独立的，不存在任何连接。
      <br/>
      小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信了。两个节点如果存在网线连接，称为相邻。
      <br/>
      小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储下来。一条信息只存储一次。
      <br/>
      给出小明连接和测试的过程，请计算出每个节点存储信息的大小。
     </p>
     <p>
      <br/>
      <strong>
       【输入格式】
      </strong>
      <br/>
      输入的第一行包含两个整数 n,m，分别表示节点数量和操作数量。节点从1 至 n 编号。
      <br/>
      接下来 m 行，每行三个整数，表示一个操作。
      <br/>
      如果操作为 1 a b，表示将节点 a 和节点 b 通过网线连接起来。当 a=b 时，表示连接了一个自环，对网络没有实质影响。
      <br/>
      如果操作为 2 p t，表示在节点 p 上发送一条大小为 t 的信息。
     </p>
     <p>
      <br/>
      <strong>
       【输出格式】
      </strong>
      <br/>
      输出一行，包含 n 个整数，相邻整数之间用一个空格分割，依次表示进行
      <br/>
      完上述操作后节点 1 至节点 n 上存储信息的大小。
     </p>
     <p>
     </p>
     <p>
     </p>
     <p>
      <strong>
       【样例输入】
      </strong>
     </p>
     <pre>4 8
1 1 2
2 1 10
2 3 5
1 4 1
2 2 2
1 1 2
1 2 4
2 2 1
</pre>
     <p>
      <strong>
       【样例输出】
      </strong>
     </p>
     <pre>13 13 5 3</pre>
     <p>
      <br/>
      <strong>
       【评测用例规模与约定】
      </strong>
      <br/>
      对于 30% 的评测用例，1≤n≤20，1≤m≤100。
      <br/>
      对于 50% 的评测用例，1≤n≤100，1≤m≤1000。
      <br/>
      对于 70% 的评测用例，1≤n≤1000，1≤m≤10000。
      <br/>
      对于所有评测用例，1≤n≤10000，1≤m≤100000，1≤t≤100。
     </p>
    </blockquote>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%EF%BC%88%E5%89%8D%E7%BC%80%E5%92%8C%2B%E8%B4%AA%E5%BF%83%EF%BC%89">
     解析代码1（普通并查集_超时）
    </h3>
    <p>
     <strong>
      暴力做法：
     </strong>
     观察题意有两个操作：
    </p>
    <ol>
     <li>
      将两个点合并。
     </li>
     <li>
      将a点所在的集合全部点都加上t。
     </li>
    </ol>
    <p>
     首先先说下暴力做法，连接用普通并查集维护，然后对于每次要加上权值时，遍历集合每个点即可。时间复杂度是O(n*m),显然是会超时的，但是得到的分数非常可观，能拿70%的分数。
    </p>
    <pre><code class="language-cpp">//#include &lt;bits/stdc++.h&gt;
#include &lt;iostream&gt;
using namespace std;
const int N = 10010;
int w[N], p[N];
int Find(int x)
{
	if (x != p[x])
		p[x] = Find(p[x]);
	return p[x];
}
void Union(int a, int b)
{
	int x = Find(a);
	int y = Find(b);
	if (x != y) p[x] = y;
}
int main()
{
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
	{
		p[i] = i;
	}
	for (int i = 0; i &lt; m; ++i)
	{
		int a, b, c;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
		if (a == 1)
		{
			Union(b, c);
		}
		else
		{
			int x = Find(b);
			for (int i = 1; i &lt;= n; ++i)
			{
				if (x == Find(i))
					w[i] += c;
			}
		}
	}
	for (int i = 1; i &lt;= n; ++i)
	{
		cout &lt;&lt; w[i] &lt;&lt; " ";
	}
	return 0;
}</code></pre>
    <hr/>
    <h3 id="%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%812%EF%BC%88%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86_%E6%AD%A3%E8%A7%A3%EF%BC%89">
     解析代码2（带权并查集_正解）
    </h3>
    <p>
     本题正解是用带权并查集做，根据题意的两个操作来看：1.将两个点合并。2.将a点所在的集合全部点都加上t。如果我们要优化时间的话，能下手的就只有第二个操作了。
    </p>
    <p>
     那首先我们定义，每个结点的权值就是到根节点权值和。那我们第二个操作可以看成是，每次在a点所在集合的根节点加上t。那我们这样定义可以保证每个点权值都正确吗？答案是可以的，我们并查集存在路径压缩的操作，所以权值和是可以通过路径压缩来维护。那这样我们每次添加的时候，就只需要让根结点添加即可，时间复杂度就从O(nm) 降到了O(n).
    </p>
    <p>
     还没完，我们现在需要根据上边的新定义，来保证我们的压缩路径和结点合并的合法性。
    </p>
    <p>
     先看结点合并，当我们两个结点合并的时候是意味着我们两个树会进行合并，比如下面这个例子，如果权值为5的根结点要合并到权值为4的根节点上，那根据我们上边的定义，那权值为5的根结点将会全部加上4，那这显然就不对了。那要解决这个问题的话，我们可以让5的权值减去4，这样就能保证合法。合并起来的话，权值依旧不变。
    </p>
    <p>
     <img alt="" height="268" src="https://i-blog.csdnimg.cn/blog_migrate/521d572f137d1d9120356949535f9934.png" width="557"/>
    </p>
    <p>
     接下来就是处理路径压缩了，那对于我们的x结点有三种情况，第一种x就是根结点，这种情况我们就直接返回即可，第二种就是x的父节点就是根节点，那这种情况我们也是直接退出（并查集最多压缩成两层，不清楚的话就需要去复习下基础并查集了）。最后一种就是我们要处理的，x经过若干层才到根结点。那我们压缩路径要做的就是让x直接指向根节点，在这种情况下，那随着我们压缩路径，x最终变成第三层，那我们此时的x权值就要更新成，d[x] += d[p[x]](加上x父亲指向上边结点的权值）。
    </p>
    <p>
     <img alt="" height="360" src="https://i-blog.csdnimg.cn/blog_migrate/76f7e9622db9627bfb90e95156871176.png" width="259"/>
    </p>
    <p>
     那到此为止，细节处理完毕，直接coding解决。最终时间复杂度O(N*logN)
     <s>
      并查集的压缩路径时间为logn，但是一般实际运行速度可以看成O(1)
     </s>
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">//#include &lt;bits/stdc++.h&gt;
#include &lt;iostream&gt;
using namespace std;
const int N = 10010;
int p[N], d[N];
int Find(int x)
{
	if (p[x] == x || p[p[x]] == p[x])
		return p[x];
	int r = Find(p[x]);
	d[x] += d[p[x]];
	p[x] = r;
	return r;
}
int main()
{
	int n = 0, m = 0;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; ++i)
	{
		p[i] = i;
	}
	while (m--)
	{
		int a, b, t;
		cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;
		if (t == 1)
		{
			a = Find(a), b = Find(b);
			if (a != b)
			{
				d[a] -= d[b]; //合并时，a结点的权值要减去b结点的权值
				p[a] = b;
			}
		}
		else
		{
			a = Find(a);
			d[a] += b; // 直接往根结点上加权
		}
	}
	for (int i = 1; i &lt;= n; ++i)
	{
		if (Find(i) == i) // 如果是根结点，权值就为自己
			printf("%d ", d[i]);
		else // 如果不是根结点，权值需要加上根节点的值
			printf("%d ", d[i] + d[Find(i)]);
	}
	return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f47527274782f:61727469636c652f64657461696c732f313337363932363737" class_="artid" style="display:none">
 </p>
</div>


