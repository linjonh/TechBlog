---
layout: post
title: "Ansible-核心模块与实操练习"
date: 2025-08-27T22:01:11+0800
description: "本文介绍了Ansible核心模块的功能与实操练习，主要内容包括： Ansible模块基础：模块的幂等性特性、安装第三方模块的方法以及基本语法格式。 常用核心模块详解： 文件操作模块（copy、file、template等） 软件包管理模块（yum、yum_repository） 系统管理模块（user、service、firewalld等） 存储管理模块（parted、filesystem、mount等） 网络与工具模块（get_url、debug等） 三个典型实操练习： 部署httpd服务 创建分区并挂载"
keywords: "Ansible 核心模块与实操练习"
categories: ['未分类']
tags: ['运维', '网络', '前端', 'Linux', 'Chrome', 'Ansible']
artid: "150935761"
arturl: "https://blog.csdn.net/t_suifeng/article/details/150935761"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150935761
    alt: "Ansible-核心模块与实操练习"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150935761
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150935761
cover: https://bing.ee123.net/img/rand?artid=150935761
image: https://bing.ee123.net/img/rand?artid=150935761
img: https://bing.ee123.net/img/rand?artid=150935761
---



# Ansible 核心模块与实操练习

## Ansible 核心模块与实操练习

### 一、Ansible 模块基础

#### 1.1 模块核心特性

* **幂等性**：多数模块支持幂等操作（多次执行结果一致，避免重复操作或系统异常）。

* **安装第三方模块**：通过 ansible-galaxy 工具安装，命令如下：

```
# 安装 community-general 模块集

ansible-galaxy collection install http://ansible.example.com/materials/community-general-6.3.0.tar.gz -p collections/

# 安装 ansible-posix 模块集

ansible-galaxy collection install http://ansible.example.com/materials/ansible-posix-1.5.1.tar.gz -p collections/
```

* **查看已安装模块**：

```
ansible-doc -l # 列出系统中所有已安装的 Ansible 模块

```

#### 1.2 模块语法格式

```
ansible [受控主机名/组名] -m [模块名] -a '[模块参数键值对]'

```

### 二、常用核心模块详解

#### 2.1 文件操作模块

##### （1）copy 模块

* **功能**：将本地文件复制到受控主机，支持设置权限、所有者、备份等。

* **关键参数**：

* + src：本地源文件 / 目录路径（相对路径或绝对路径，目录加 / 仅复制内容，不加复制目录本身）；

* + dest：远程目标路径（必须为绝对路径）；

* + owner：远程文件的所有者（如 root）；

* + group：远程文件的所属组（如 student）；

* + mode：远程文件的权限（如 0644 或 u=rwx,g=rx,o=rx）；

* + backup：复制前备份远程同名文件（yes/no，默认 no）。

* **实操示例**：
* 将本地 /etc/fstab 复制到 node1 的 /var/tmp 目录：

```
ansible node1 -m copy -a 'src=/etc/fstab dest=/var/tmp/fstab'

```

* 复制文件并指定所有者、所属组和权限：

```
ansible node1 -m copy -a 'src=/etc/fstab dest=/var/tmp/fstab owner=root group=student mode=0644'

```

##### （2）file 模块

* **功能**：管理文件 / 目录的属性，包括创建、删除、修改权限、设置链接、调整 SELinux 上下文等。

* **关键参数**：

* + path：目标文件 / 目录的路径（必须为绝对路径）；

* + state：目标状态（directory 创目录、touch 创文件、link 创软链接、hard 创硬链接、absent 删除）；

* + owner/group：所有者 / 所属组；

* + mode：权限（如 0755 或 g+w）；

* + setype：SELinux 安全上下文类型（如 samba_share_t）；

* + src：创建链接时的源文件路径（仅 state=link/hard 时需设置）。

* **实操示例**：
* 在 node1 上创建 /tmp/abc 文件：

```
ansible node1 -m file -a 'path=/tmp/abc state=touch'

```

* 创建 /tmp/aa 目录并设置权限：

```
ansible node1 -m file -a 'path=/tmp/aa state=directory mode=0755'

```

* 为 /tmp/bbb 创建软链接 /tmp/aa：

```
ansible node1 -m file -a 'src=/tmp/bbb dest=/tmp/aa state=link'

```

* 修改 /tmp/fstab 的 SELinux 上下文为 samba_share_t：

```
ansible node1 -m file -a 'path=/tmp/fstab setype=samba_share_t'

```

##### （3）template 模块

* **功能**：复制带 Jinja2 变量的模板文件到受控主机，支持配置文件动态生成（如根据主机名、IP 调整配置）。

* **关键参数**：

* + src：本地模板文件路径（如 /usr/share/doc/httpd/httpd-vhosts.conf）；

* + dest：远程目标路径；

* + owner/group/mode：同 copy 模块；

* + validate：复制后、生效前执行语法校验命令（如 httpd -t -f %s，%s 指代目标文件）。

* **实操示例**：

复制 httpd 虚拟主机模板到 node1 的配置目录，并设置权限：

```
ansible node1 -m template -a 'src=/usr/share/doc/httpd/httpd-vhosts.conf dest=/etc/httpd/conf.d/httpd-vhosts.conf owner=root group=root mode=0644'
```

##### （4）replace 模块

* **功能**：按正则表达式匹配文件内容，并替换为指定字符串，支持备份原文件。

* **关键参数**：

* + path：目标文件路径；

* + regexp：待匹配的正则表达式（如 /var/www）；

* + replace：替换后的内容（如 /www）；

* + backup：替换前备份原文件（yes/no）。

* **实操示例**：

将 node1 上 /tmp/test 文件中的 “ab” 替换为 “xx”，并备份原文件：

```
ansible node1 -m replace -a 'path=/tmp/test regexp="ab" replace="xx" backup=yes'

```

##### （5）fetch 模块

* **功能**：从受控主机拉取文件到控制节点（仅支持文件，不支持目录），默认按 “主机名 / 文件路径” 存储。

* **关键参数**：

* + src：远程源文件路径（必须为绝对路径，且是文件）；

* + dest：控制节点的存储目录（绝对路径）；

* + flat：简化存储路径（yes 时直接存到 dest 目录，不创建主机名子目录）。

* **实操示例**：
* 拉取 node1 的 /etc/fstab 到控制节点 /tmp，按 “/tmp/node1/etc/fstab” 存储：

```
ansible node1 -m fetch -a 'src=/etc/fstab dest=/tmp'

```

* 拉取文件并简化路径为 /tmp/fstab：

```
ansible node1 -m fetch -a 'src=/etc/fstab dest=/tmp/flat=yes'

```

#### 2.2 软件包管理模块

##### （1）yum 模块

* **功能**：用于 RHEL/CentOS/Rocky Linux 等系统，管理 RPM 软件包（安装、卸载、更新）。

* **关键参数**：

* + name：包名（单个包如 httpd，多个包用逗号分隔如 httpd,nginx）；

* + state：包状态（present/installed 安装、latest 安装最新版、absent/removed 卸载）。

* **实操示例**：
* 在 node1 上安装 httpd：

```
ansible node1 -m yum -a 'name=httpd state=installed'

```

* 卸载 node1 上的 httpd：

```
ansible node1 -m yum -a 'name=httpd state=removed'

```

##### （2）yum_repository 模块

* **功能**：在受控主机上配置 YUM 仓库（生成 .repo 文件）。

* **关键参数**：

* + file：.repo 文件名（如 server，最终路径为 /etc/yum.repos.d/server.repo）；

* + name：仓库标识（.repo 文件中 [ ] 内的名称，如 BaseOS）；

* + description：仓库描述（注释信息）；

* + baseurl：仓库地址（如 [http://ansible.example.com/rhel9/BaseOS](http://ansible.example.com/rhel9/BaseOS "http://ansible.example.com/rhel9/BaseOS")）；

* + enabled：是否启用仓库（yes/no）；

* + gpgcheck：是否校验 GPG 签名（yes/no）。

* **实操示例**：

在 node1 上配置 RHEL9 BaseOS 仓库：

```
ansible node1 -m yum_repository -a 'file=server name=a description=aa baseurl=http://ansible.example.com/rhel9/BaseOS enabled=yes gpgcheck=no'

ansible node1 -m yum_repository -a 'file=server name=aa description=aaa baseurl=http://ansible.example.com/rhel9/AppStream enabled=yes gpgcheck=no'
```

##### 2.3 系统管理模块

##### （1）user 模块

* **功能**：管理系统用户（创建、修改、删除、设置密码、调整权限等）。

* **关键参数**：

* + name：用户名（必填，如 newbie）；

* + uid：用户 UID（如 4000）；

* + password：加密后的密码（需用 openssl passwd -1 密码 生成，如 $1$kinHW5tt$wPKePKs27g.NWDmbSc/D90）；

* + state：present 创建、absent 删除；

* + createhome：是否创建家目录（yes/no，默认 yes）；

* + update_password：密码更新策略（always 总是更新、on_create 仅创建时设置）；

* + shell：用户登录 shell（如 /bin/bash、/sbin/nologin）。

* **实操示例**：
* 在 node1 上创建 UID 为 4000 的用户 newbie：

```
ansible node1 -m user -a 'name=newbie uid=4000 state=present'

```

* 为用户 sl 设置密码（仅创建时生效）：

```
ansible node1 -m user -a 'name=sl state=present password="$1$kinHW5tt$wPKePKs27g.NWDmbSc/D90" update_password=on_create'

```

##### （2）service 模块

* **功能**：管理系统服务（启动、停止、重启、重载配置、设置开机自启）。

* **关键参数**：

* + name：服务名（如 httpd、firewalld）；

* + state：服务状态（started 启动、stopped 停止、restarted 重启、reloaded 重载配置）；

* + enabled：是否开机自启（yes/no）。

* **实操示例**：

在 node1 上启动 httpd 服务并设置开机自启：

```
ansible node1 -m service -a 'name=httpd state=started enabled=yes'

```

##### （3）firewalld 模块

* **功能**：管理 firewalld 防火墙规则（开放端口 / 服务、设置富规则、配置区域等）。

* **关键参数**：

* + service：开放的服务名（如 http、ssh，需 firewalld 预定义）；

* + port：开放的端口（如 8080/tcp、53/udp）；

* + permanent：规则是否永久生效（yes/no，默认 no，永久规则需重启 firewalld 或用 immediate=yes 立即生效）；

* + state：enabled 添加规则、disabled 删除规则；

* + immediate：是否立即应用规则（yes/no，配合 permanent=yes 使用）；

* + rich_rule：富规则（精细控制，如允许特定网段访问）。

* **实操示例**：
* 允许 http 服务永久生效并立即应用：

```
ansible node1 -m firewalld -a 
'service=http 
permanent=yes 
state=enabled 
immediate=yes'
```

* 允许 [192.168.100.0/24](http://192.168.100.0/24 "192.168.100.0/24") 网段访问 http 服务：

```
ansible node1 -m firewalld -a 
'zone=public 
rich_rule="rule family=ipv4 source address=192.168.100.0/24 service name=http accept" permanent=yes 
state=enabled 
immediate=yes'
```

##### （4）cron 模块

* **功能**：管理系统定时任务（添加、删除、修改）。

* **关键参数**：

* + name：任务名称（唯一标识，删除时需指定）；

* + user：执行任务的用户（如 root、sl）；

* + job：任务命令（如 test ab、/usr/bin/[backup.sh](http://backup.sh "backup.sh")）；

* + minute/hour/day/month/weekday：时间参数（分别对应分、时、日、月、周，* 表示所有，*/5 表示每 5 单位）；

* + state：present 添加、absent 删除。

* **实操示例**：

为 sl 用户添加 “每 5 分钟执行 test ab” 的定时任务：

```
ansible node1 -m cron -a 
'name=test_ab 
user=sl 
minute="*/5" 
job="test ab" 
state=present'
```

##### 

#### 2.4 存储管理模块

##### （1）parted 模块

* **功能**：管理磁盘分区（创建、删除分区，支持 MBR 和 GPT 分区表）。

* **关键参数**：

* + device：磁盘路径（如 /dev/vdb、/dev/sdc）；

* + number：分区号（如 1、2）；

* + part_type：分区类型（primary 主分区、logical 逻辑分区，MBR 最多 4 个主分区）；

* + part_start：分区起始位置（如 10MiB、1GiB）；

* + part_end：分区结束位置（如 1010MiB、5GiB）；

* + state：present 创建分区、absent 删除分区。

* **实操示例**：

在 node2 的 /dev/vdb 上创建 1000MiB 的主分区（起始 10MiB，结束 1010MiB）：

```
ansible node2 -m parted -a 
'device=/dev/vdb 
number=1 
part_type=primary 
part_start=10MiB 
part_end=1010MiB 
state=present'
```

##### （2）filesystem 模块

* **功能**：格式化磁盘分区为指定文件系统（如 ext4、xfs、btrfs）。

* **关键参数**：

* + dev：分区 / 设备路径（如 /dev/vdb1、/dev/datastorage/database）；

* + fstype：文件系统类型（ext4、xfs、btrfs 等）；

* + force：强制格式化（yes/no，默认 no，谨慎使用，会清空数据）。

* **实操示例**：

将 node2 的 /dev/vdb1 格式化为 ext4 文件系统：

```
ansible node2 -m filesystem -a 'dev=/dev/vdb1 fstype=ext4'

```

##### （3）mount 模块

* **功能**：管理文件系统挂载（临时挂载、永久挂载到 /etc/fstab）。

* **关键参数**：

* + path：挂载点路径（如 /testdir、/lv，需提前创建）；

* + src：设备 / 分区路径或 UUID（UUID 更稳定，如 UUID=c06d4819-fa79-4218-ae6f-6cd33176f4cd）；

* + fstype：文件系统类型（需与格式化类型一致）；

* + state：mounted 挂载并写入 /etc/fstab、unmounted 卸载、present 仅写入 /etc/fstab 不挂载。

* **实操示例**：

将 node2 的 /dev/vdb1（UUID 为 c06d4819-fa79-4218-ae6f-6cd33176f4cd）永久挂载到 /testdir：

```
ansible node2 -m mount -a 
'src="UUID=c06d4819-fa79-4218-ae6f-6cd33176f4cd" 
path=/testdir 
fstype=ext4 
state=mounted'
```

##### （4）lvg 模块

* **功能**：管理 LVM 卷组（创建、扩展、删除卷组，添加 / 移除物理卷）。

* **关键参数**：

* + vg：卷组名（如 datastorage）；

* + pvs：物理卷列表（如 /dev/vdb3、/dev/sdc1，多个用逗号分隔）；

* + pesize：PE（物理扩展单元）大小（如 4MiB、8MiB，默认 4MiB）；

* + state：present 创建卷组、absent 删除卷组、extended 扩展卷组（添加物理卷）。

* **实操示例**：

在 node3 上创建卷组 datastorage，使用物理卷 /dev/vdb3：

```
ansible node3 -m lvg -a 'vg=datastorage pvs=/dev/vdb3'

```

##### （5）lvol 模块

* **功能**：管理 LVM 逻辑卷（创建、扩展、缩小、删除逻辑卷）。

* **关键参数**：

* + lv：逻辑卷名（如 database）；

* + vg：所属卷组名（如 datastorage）；

* + size：逻辑卷大小（如 800M、2GiB，扩展时可加 + 如 +500M）；

* + resizefs：扩展 / 缩小时是否同步调整文件系统（yes/no，默认 no，扩展时建议设为 yes）；

* + state：present 创建、absent 删除、resized 调整大小。

* **实操示例**：
* 在 node3 的 datastorage 卷组上创建 800M 的逻辑卷 database：

```
ansible node3 -m lvol -a 'lv=database size=800M vg=datastorage'

```

* 将逻辑卷 database 扩展到 1600M，并同步扩展文件系统：

```
ansible node3 -m lvol -a 'lv=database size=1600M vg=datastorage resizefs=yes'

```

#### 2.5 网络与工具模块

##### （1）get_url 模块

* **功能**：从 HTTP/HTTPS/FTP 服务器下载文件到受控主机。

* **关键参数**：

* + url：下载地址（如 [http://ansible.example.com/files/test.tar.gz](http://ansible.example.com/files/test.tar.gz "http://ansible.example.com/files/test.tar.gz")）；

* + dest：受控主机的目标路径（绝对路径，如 /tmp/test.tar.gz）；

* + owner/group/mode：同 copy 模块；

* + backup：目标文件存在时是否备份（yes/no）；

* + validate_certs：HTTPS 下载时是否校验证书（yes/no，默认 yes）。

* **实操示例**：

下载文件到 node1 的 /tmp 目录：

```
ansible node1 -m get_url -a 
'url=http://ansible.example.com/files/test.tar.gz 
dest=/tmp/test.tar.gz'
```

##### （2）sefcontext 模块

* **功能**：管理 SELinux 安全上下文规则（永久生效，区别于 file 模块的临时调整）。

* **关键参数**：

* + target：目标路径正则（如 /share(/.*)? 表示 /share 及子目录）；

* + setype：SELinux 上下文类型（如 httpd_sys_content_t、samba_share_t）；

* + state：present 添加规则、absent 删除规则。

* **实操示例**：

为 node1 的 /share 目录及子目录添加永久 SELinux 规则（类型为 samba_share_t）：

```
ansible node1 -m sefcontext -a 'target="/share(/.*)?" setype=samba_share_t state=present'

# 应用规则（配置后需执行，否则不生效）

ansible node1 -m shell -a 'restorecon -Rv /share'
```

##### （4）debug 模块

* **功能**：输出调试信息（打印变量值、自定义消息，用于 Playbook 排错）。

* **关键参数**：

* + msg：自定义消息（如 "httpd service started successfully"）；

* + var：待打印的变量（如 ansible_hostname、result，无需加引号）；

* + verbosity：调试级别（0-4，级别越高输出越详细，默认 0）。

* **实操示例**：
* 输出自定义成功消息：

```
ansible node1 -m debug -a 'msg="httpd service started successfully"'

```

* 打印 node1 的主机名变量：

```
ansible node1 -m debug -a 'var=ansible_hostname'

```

### 三、Ansible 实操练习

#### 3.1 练习 1：Node1 部署 httpd 服务

**目标**：安装 httpd 服务，网页文件存于 /www，通过 curl http://node1 访问到内容 welcome to luoqi。

* **安装 httpd 服务**：

```
ansible node1 -m yum -a 'name=httpd state=present'

```

* **配置防火墙**

```
ansible node1 -m firewalld -a 
'service=http 
permanent=yes 
state=enabled 
immediate=yes'


```

* **创建网页目录并设置 SELinux 上下文**（确保 httpd 有权访问）：

```
ansible node1 -m file -a 
'path=/www 
state=directory 
setype=httpd_sys_content_t'
```

* **生成网页文件**（内容为 welcome to luoqi）：

```
ansible node1 -m copy -a 
'content="welcome to luoqi" 
dest=/www/index.html'

ansible node1 -m file -a 
'path=/www/index.html 
setype="httpd_sys_content_t"'
```

* **修改 httpd 配置**（将默认根目录 /var/www 替换为 /www，并备份原配置）：

```
ansible node1 -m replace -a 
'path=/etc/httpd/conf/httpd.conf 
regexp="/var/www" 
replace="/www" 
backup=yes'

ansible node1 -m replace -a 
'path=/etc/httpd/conf/httpd.conf 
regexp="/www/html" 
replace="/www" 
backup=yes'
```

* **启动 httpd 并设置开机自启**：

```
ansible node1 -m service -a 'name=httpd state=started enabled=yes'

```

* **验证结果**：

在控制节点执行以下命令，预期返回 welcome to luoqi：

```
curl http://node1
```

```
![](https://i-blog.csdnimg.cn/direct/bd25b7f5db18469f9079ec5ac3e41b2a.png)
```

#### 3.2 练习 2：Node2 创建分区并挂载

**目标**：在 node2 上创建 1000MiB 分区，格式化为 ext4，永久挂载到 /testdir。

* **创建磁盘分区**（假设使用空闲磁盘 /dev/vdb，分区号 1，起始 10MiB，结束 1010MiB）：

```
ansible node2 -m parted -a 
'device=/dev/vdb 
number=1 
part_type=primary 
part_start=10MiB 
part_end=1010MiB 
state=present'
```

* **格式化分区为 ext4**：

```
ansible node2 -m filesystem -a 'dev=/dev/vdb1 fstype=ext4'

```

* **创建挂载点** **/testdir**：

```
ansible node2 -m file -a 'path=/testdir state=directory mode=0755'

```

* **查看分区 UUID**（永久挂载推荐用 UUID，避免磁盘路径变化导致挂载失败）：

```
ansible node2 -m shell -a 'blkid /dev/vdb1'

# 记录输出的 UUID，示例：UUID=c06d4819-fa79-4218-ae6f-6cd33176f4cd
```

* **永久挂载分区**（写入 /etc/fstab 并立即挂载）：

```
ansible node2 -m mount -a 
'src="UUID=c06d4819-fa79-4218-ae6f-6cd33176f4cd" 
path=/testdir 
fstype=ext4 
state=mounted'
```

* **验证结果**：

执行以下命令，查看 /dev/vdb1 是否挂载到 /testdir：

```
ansible node2 -m shell -a 'df -Th'
```

```
![](https://i-blog.csdnimg.cn/direct/ffac8d7148ab43d598fd4a0c9cc912df.png)
```

#### 3.3 练习 3：Node3 创建 LVM 并挂载

**目标**：在 node3 上创建卷组 datastorage、逻辑卷 database（800M），格式化为 xfs，永久挂载到 /lv。

* **创建物理卷分区**（假设使用 /dev/vdb，创建分区 3，大小足够容纳 800M 逻辑卷）：

```
ansible node3 -m parted -a 
'device=/dev/vdb 
number=3 
part_type=primary 
part_start=2530MiB 
part_end=4530MiB 
state=present'
```

* **创建卷组** **datastorage**（使用分区 /dev/vdb3）：

```
ansible node3 -m lvg -a 'vg=datastorage pvs=/dev/vdb3'

```

* **创建逻辑卷** **database**（大小 800M，属于 datastorage 卷组）：

```
ansible node3 -m lvol -a 'lv=database size=800M vg=datastorage'

```

* **格式化逻辑卷为 xfs**：

```
ansible node3 -m filesystem -a 'dev=/dev/datastorage/database fstype=xfs'

```

* **创建挂载点** **/lv**：

```
ansible node3 -m file -a 'path=/lv state=directory mode=0755'

```

* **查看逻辑卷 UUID**：

```
ansible node3 -m shell -a 'blkid /dev/datastorage/database'

# 记录 UUID，示例：UUID=d2e22769-1a3f-40fc-b25c-cf8025b9f0b1
```

* **永久挂载逻辑卷**：

```
ansible node3 -m mount -a 
'src="UUID=d2e22769-1a3f-40fc-b25c-cf8025b9f0b1" 
path=/lv 
fstype=xfs 
state=mounted'
```

* **验证结果**：

执行以下命令，查看 /dev/mapper/datastorage-database 是否挂载到 /lv：

```
ansible node3 -m shell -a 'df -Th'
```

```
![](https://i-blog.csdnimg.cn/direct/af51cca5bff04dc99eefecb8482b122d.png)
```



