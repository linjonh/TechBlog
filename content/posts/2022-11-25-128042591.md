---
layout: post
title: "开源蓝牙协议栈-Zephyr_polling简介"
date: 2022-11-25 18:30:48 +0800
description: "本文介绍了基于ZephyrProject的蓝牙Host协议栈Zephyr_polling，强调了针对"
keywords: "开源蓝牙协议栈"
categories: ['蓝牙', 'Zephyr']
tags: ['蓝牙']
artid: "128042591"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=128042591
    alt: "开源蓝牙协议栈-Zephyr_polling简介"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=128042591
featuredImagePreview: https://bing.ee123.net/img/rand?artid=128042591
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     开源蓝牙协议栈-Zephyr_polling简介
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_1">
     </a>
     简介
    </h2>
    <p>
     本项目是基于
     <a href="https://www.zephyrproject.org/" rel="nofollow">
      Zephyr Project
     </a>
     进行二次开发的，去除了OS调度部分，只保留了Bluetooth的Host协议栈。项目地址：
     <a href="https://github.com/bobwenstudy/zephyr_polling">
      bobwenstudy/zephyr_polling (github.com)
     </a>
     。文档地址：
     <a href="https://zephyr-polling.readthedocs.io/en/latest/" rel="nofollow">
      Welcome to Zephyr_polling’s documentation!
     </a>
     。
    </p>
    <p>
     一般蓝牙协议栈分为Host和Controller两个部分，根据是否包含BR/EDR还是LE，分为如下形式。
    </p>
    <p>
     <img alt="image-20221124185342589" src="https://i-blog.csdnimg.cn/blog_migrate/327e538153b7aa0a46cb5f9bf863f041.png"/>
    </p>
    <p>
     作为一个蓝牙芯片协议栈开发者，既做过Controller也做过Host，同时在多家公司任职过，接触过包括rwip\ceva\bluedroid\bluez\btstack\nimble\softdevice以及各种自定义协议栈（擅长的不多，哈哈），总体就是各个协议栈都有各自的写法，不管是代码风格还是环境都各不相同。
    </p>
    <p>
     <strong>
      Controller侧
     </strong>
     ，虽然Controller要实现RF操作，和硬件行为强相关，不可避免代码差异大。但是Spec有明确规定HCI接口，大家都有一个标准可以遵循，API相对统一，从A切换B其实只要有HCI接口就能方便的使用。
    </p>
    <p>
     如下图所示，Host和Controller之间通过HCI连接，对于BLE而言只有C/E、ACL、ISO这4个通道。
    </p>
    <p>
     <img alt="image-20221124185611408" src="https://i-blog.csdnimg.cn/blog_migrate/66e1069d2566d09b102551a3bfb64303.png"/>
    </p>
    <p>
     <strong>
      Host侧
     </strong>
     ，Spec只是规定了行为并没有规定接口，那就是天马行空，各家方案的API差异很大，学习成本较高，并且迁移成本也高，而且文档基本上都是靠代码、例程来学习，有些API还不是很友好。
    </p>
    <p>
     现行的开源Host协议栈还是比较多的，下面做一个简单的介绍：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        名称
       </th>
       <th>
        开源协议
       </th>
       <th>
        双模支持
       </th>
       <th>
        持续维护
       </th>
       <th>
        OS/轮询
       </th>
       <th>
        备注
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <a href="https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/refs/heads/master" rel="nofollow">
         bluedroid
        </a>
       </td>
       <td>
        开源免费
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
       <td>
        OS
       </td>
       <td>
        Android所使用的蓝牙协议栈，功能比较全，但是Profile层是在Java实现的，所以有个JNI层，相应的行为就复杂了一些。
       </td>
      </tr>
      <tr>
       <td>
        <a href="http://www.bluez.org/" rel="nofollow">
         BlueZ
        </a>
       </td>
       <td>
        开源免费
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
       <td>
        OS
       </td>
       <td>
        Linux系统所使用的蓝牙协议栈，没深入理解，但是bluedroid的是从blueZ演变过来的，记得Android4.0之前用的还是blueZ，后面改成了bluedroid。
       </td>
      </tr>
      <tr>
       <td>
        <a href="https://www.zephyrproject.org/" rel="nofollow">
         Zephyr
        </a>
       </td>
       <td>
        开源免费
       </td>
       <td>
        是(经典蓝牙实现较少)
       </td>
       <td>
        是
       </td>
       <td>
        OS
       </td>
       <td>
        本文所基于的协议栈，蓝牙之前其中的一个部分，包含Controller的实现，API很不错，目前很火的开源协议栈，没事大家可以上去学点东西，后面详细来讲。
       </td>
      </tr>
      <tr>
       <td>
        <a href="https://github.com/bluekitchen/btstack">
         btstack
        </a>
       </td>
       <td>
        商业收费
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
       <td>
        轮询
       </td>
       <td>
        整体就是为了满足低成本方案设计来做的，没有OS需求，协议栈的调度就是轮询架构，可以轻易的porting到任何平台中，功能也全，本项目的架构也是参考这一项目来实现的。里面有很多芯片的Porting实现。
       </td>
      </tr>
      <tr>
       <td>
        <a href="https://github.com/apache/mynewt-nimble">
         nimble
        </a>
       </td>
       <td>
        开源免费
       </td>
       <td>
        BLE
       </td>
       <td>
        是
       </td>
       <td>
        OS
       </td>
       <td>
        没深入了解，不过很久没维护了，最近突然又开始维护了，好像是乐鑫开始用他们的方案。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     从上述可以看出，除了btstack在设计之处就是为了方便Porting存在的，其他方案都是捆绑了自己的OS。
    </p>
    <p>
     这块其实做的比较好的还是btstack，不过其商业是收费的，文档这块其实也不太多，同时其是极简实现的方案，所以使用体验上并不是很舒服，数据缓存之类都需要在应用层做。
    </p>
    <h2>
     <a id="_35">
     </a>
     改动说明
    </h2>
    <p>
     作为一个芯片开发人员，国内大多数芯片方案还是资源受限的平台，不管对于Code Size，RAM Size都非常敏感；同时对于低功耗设计，Retention RAM的大小也至关重要。上述协议栈在各自的领域都做的不错，但是对于国内市场需要开源免费、API友好、Code/RAM/Retention Size精简的需要来讲，多少还是有一些缺陷的。
    </p>
    <p>
     基于这一现状，基于Zephyr的蓝牙子系统，保留其API和蓝牙协议实现，做出如下调整：
    </p>
    <ul>
     <li>
      调度方式，由原本基于Zephyr OS调度，调整为轮询调度方式，以便于后续移植到其他平台，并减少对CPU mips的占用。
     </li>
     <li>
      buffer管理，移除关于多thread的操作，保留pool和net_buf设计。
     </li>
     <li>
      配置系统，保留kconfig配置架构，支持.h单独配置方式，简化配置复杂度。
     </li>
     <li>
      存储系统，由原本的setting架构调整为简易的kv结构。
     </li>
     <li>
      系统架构，调整为btstack架构。
     </li>
     <li>
      hci操作，原本有很多同步操作，调整为异步操作。
     </li>
     <li>
      Retention RAM分离，Zephyr本身需要的RAM还是比较大的，将pool等大块memory调整为非retention设计，以便低成本方案移植需要。
     </li>
     <li>
      API，移除同步操作接口，其他接口全部保留。
     </li>
     <li>
      代码风格，依然基于.clang-format来格式化代码，但是zephyr蓝牙部分的代码风格和他OS说明好像并不相同，所以重新定义了一个我自己舒服的格式。
     </li>
     <li>
      编译系统，全部基于makefile来组织编译，方便大家移植。
     </li>
    </ul>
    <h2>
     <a id="_54">
     </a>
     系统架构
    </h2>
    <p>
     蓝牙协议栈为Zephyr的结构，系统总体架构参考Btstack的实现，总体结构如下图所示。
    </p>
    <p>
     <img alt="image-20221125111329111" src="https://i-blog.csdnimg.cn/blog_migrate/8ecae0fcd4213798a9f9a91fd50562d8.png"/>
    </p>
    <p>
     如上图所示，系统主要分为5个部分，代码结构如下所示：
    </p>
    <ul>
     <li>
      <strong>
       chipset
      </strong>
      ：各家厂商在使用之前需要进行一些配置，有些是因为芯片是rom化版本，需要加载patch，有些要配置RF参数，有些要配置蓝牙地址等。
     </li>
     <li>
      <strong>
       example
      </strong>
      ：各种蓝牙例程，基本是照搬zephyr的来，当然会加入一些新的case。
     </li>
     <li>
      <strong>
       platform
      </strong>
      ：移植时重点关注的部分，蓝牙协议栈运行需要用到一些平台资源，不同平台有不同实现方式，主要包括log、timer、storage_kv和HCI接口的实现。
     </li>
     <li>
      <strong>
       porting
      </strong>
      ：程序的主入口，这些会将platform/chipset和协议栈接口进行绑定，并启动example，最后对协议栈进行调度。
     </li>
     <li>
      <strong>
       src
      </strong>
      ：zephyr的蓝牙协议栈部分，具体实现蓝牙协议栈的具体细节。
     </li>
    </ul>
    <pre><code class="prism language-shell">zephyr_polling
 ├── chipset
 │   ├── csr8510_usb
 │   └── csr8910_uart
 ├── example
 │   ├── beacon
 │   ├── broadcaster
 │   ├── central
 │   ├── observer
 │   ├── peripheral
 │   <span class="token punctuation">..</span>.
 ├── platform
 │   └── windows
 │   <span class="token punctuation">..</span>.
 ├── porting
 │   ├── windows_libusb_win32
 │   └── windows_serial
 │   <span class="token punctuation">..</span>.
 └── src
     <span class="token punctuation">..</span>.
</code></pre>
    <h2>
     <a id="_95">
     </a>
     使用说明
    </h2>
    <h3>
     <a id="_97">
     </a>
     环境搭建
    </h3>
    <p>
     目前暂时只支持Windows编译，最终生成exe，可以直接在PC上跑。
    </p>
    <p>
     目前需要安装如下环境：
    </p>
    <ul>
     <li>
      <a href="http://www.python.org/getit/" rel="nofollow">
       Python3
      </a>
      ，用于Kconfig，代码格式化，RAM&amp;ROM分析等，编译工具类都用这个。
     </li>
     <li>
      GCC环境，笔者用的msys64+mingw，用于编译生成exe，参考这个文章安装即可。
      <a href="https://www.cnblogs.com/milton/p/11808091.html" rel="nofollow">
       Win7下msys64安装mingw工具链 - Milton - 博客园 (cnblogs.com)
      </a>
      。
     </li>
    </ul>
    <h4>
     <a id="Python_108">
     </a>
     Python环境准备
    </h4>
    <p>
     python装好后，还需要安装一些环境，运行
     <code>
      python_require_env.py
     </code>
     脚本就会安装所有所需的python环境。
    </p>
    <pre><code class="prism language-shell">python python_require_env.py
</code></pre>
    <h3>
     <a id="_120">
     </a>
     编译说明
    </h3>
    <p>
     本项目都是由makefile组织编译的，编译整个项目只需要执行
     <code>
      make all
     </code>
     即可，调用
     <code>
      make help
     </code>
     可以查看帮助。
    </p>
    <p>
     根据具体需要可以调整一些参数，目前Makefile支持如下参数配置。
    </p>
    <ul>
     <li>
      <strong>
       APP
      </strong>
      ：选择example中的例程，默认选择为
      <code>
       beacon
      </code>
      。
     </li>
     <li>
      <strong>
       PORT
      </strong>
      ：选择porting中的环境，也就是当前平台和HCI接口类型，默认选择为
      <code>
       windows_libusb_win32
      </code>
      。
     </li>
     <li>
      <strong>
       CHIPSET
      </strong>
      ：选择chipset中的芯片种类，默认选择为
      <code>
       csr8510_usb
      </code>
      。
     </li>
    </ul>
    <p>
     也就是可以通过如下指令来编译工程：
    </p>
    <pre><code class="prism language-shell"><span class="token function">make</span> all <span class="token assign-left variable">APP</span><span class="token operator">=</span>beacon <span class="token assign-left variable">PORT</span><span class="token operator">=</span>windows_libusb_win32 <span class="token assign-left variable">CHIPSET</span><span class="token operator">=</span>csr8510_usb
</code></pre>
    <h3>
     <a id="HCI_Dongle_140">
     </a>
     HCI Dongle部署
    </h3>
    <p>
     在PC环境下，常见的设备有USB设备和UART设备，下面分别对这两个设备进行部署。
    </p>
    <h4>
     <a id="USB_144">
     </a>
     USB设备使用
    </h4>
    <p>
     为了能操作这些USB蓝牙dongle，默认使用的驱动是蓝牙的驱动。所以需要更改设备所使用的驱动。
    </p>
    <ul>
     <li>
      Step1：下载
      <a href="https://zadig.akeo.ie/" rel="nofollow">
       Zadig
      </a>
      。
     </li>
     <li>
      Step2：菜单栏点击Options -&gt; List All Devices。
     </li>
    </ul>
    <p>
     <img alt="image-20221125133827682" src="https://i-blog.csdnimg.cn/blog_migrate/23d50e40027fa827c9925ac9147f2af3.png"/>
    </p>
    <ul>
     <li>
      Step3：通过下拉选中当前连接的蓝牙dongle，更换设备driver为
      <code>
       libusb-win32
      </code>
      ，如下图所示，过一会就换好驱动了。
     </li>
    </ul>
    <p>
     <img alt="image-20221125133953130" src="https://i-blog.csdnimg.cn/blog_migrate/a8837744d5f1759b3db59dc18bcdb103.png"/>
    </p>
    <h4>
     <a id="UART_159">
     </a>
     UART设备使用
    </h4>
    <p>
     这个直接看以下设备的串口号，在代码里面配置好后就可以正常使用了。（这块还没做，准备放在Makefile中操作）
    </p>
    <h3>
     <a id="_167">
     </a>
     支持芯片列表
    </h3>
    <p>
     makefile中配置
     <strong>
      CHIPSET
     </strong>
     ，后续不断完善。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        chipset
       </th>
       <th>
        接口
       </th>
       <th>
        蓝牙版本
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <a href="https://detail.tmall.com/item.htm?abbucket=2&amp;id=534662513906&amp;ns=1&amp;spm=a230r.1.14.1.2f6811a37qFFQU&amp;skuId=4910946697067" rel="nofollow">
         csr8510_usb
        </a>
       </td>
       <td>
        USB
       </td>
       <td>
        4.0
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="_181">
     </a>
     蓝牙配置
    </h2>
    <p>
     用的就是zephyr的Kconfig配置，使用办法就是输入如下指令：
    </p>
    <pre><code class="prism language-shell"><span class="token function">make</span> menuconfig
</code></pre>
    <p>
     和zephyr一样，支持持久化配置和临时配置，各个example里面有一个
     <code>
      prj.conf
     </code>
     作为特定应用的永久化配置，当然使用过程中可以随时通过menuconfig调整配置，但是注意需要保存时，将差异保存在
     <code>
      prj.conf
     </code>
     中，不然下次clean后会失效。Kconfig的使用说明可以参考：
     <a href="https://blog.csdn.net/wenbo13579/article/details/127464764">
      从零到一搭建Kconfig配置系统
     </a>
     。
    </p>
    <p>
     kconfig生成的
     <code>
      autoconfig.h
     </code>
     保存在output目录下。
    </p>
    <p>
     <img alt="image-20221125141858546" src="https://i-blog.csdnimg.cn/blog_migrate/952bf4319a621ee426012eeb04a8398d.png"/>
    </p>
    <p>
     <strong>
      注意
     </strong>
     ：考虑到部分项目不想使用kconfig的配置方案，生成
     <code>
      autoconfig.h
     </code>
     的使用在
     <code>
      src\bt_config.h
     </code>
     中通过include导入，也就是说可以在其他环境下生成好
     <code>
      autoconfig.h
     </code>
     ，而后将生成的
     <code>
      autoconfig.h
     </code>
     保存在
     <code>
      src
     </code>
     目录下即可。
    </p>
    <h2>
     <a id="_199">
     </a>
     调试
    </h2>
    <h3>
     <a id="_201">
     </a>
     日志系统
    </h3>
    <p>
     参考btstack，系统支持多种debug方式，生成的日志文件保存在output/log目录下：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        名称
       </th>
       <th>
        分析软件
       </th>
       <th>
        备注
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        btsnoop(.cfa)
       </td>
       <td>
        frontline/eclipse
       </td>
       <td>
        分析蓝牙协议最好的一个协议存储格式
       </td>
      </tr>
      <tr>
       <td>
        packet_logger(.pklg)
       </td>
       <td>
        wireshark
       </td>
       <td>
        暂不支持，苹果推出的一个日志分析格式，支持log+协议分析
       </td>
      </tr>
      <tr>
       <td>
        日志(.log)
       </td>
       <td>
        文本编辑器
       </td>
       <td>
        将终端的日志保存成文件，方便离线分析
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <img alt="image-20221125112900757" src="https://i-blog.csdnimg.cn/blog_migrate/2ef977d1a87addf53210ab99c7000b55.png"/>
    </p>
    <h3>
     <a id="RAM_ReportROM_Report_213">
     </a>
     RAM_Report&amp;ROM_Report
    </h3>
    <p>
     参考zephyr，对生成的elf进行分析，最终会生成ram.json和rom.json。这两个文件也可以导入到nordic的vscode环境下，可以借助其图形化工具进行分析。
    </p>
    <p>
     <strong>
      注意
     </strong>
     ：windows环境暂时不可用，只能对elf进行分析。
    </p>
    <p>
     <img alt="image-20221125112930355" src="https://i-blog.csdnimg.cn/blog_migrate/e465dfd3e351344e9af3fa4407d8ce63.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f77656e626f31333537392f:61727469636c652f64657461696c732f313238303432353931" class_="artid" style="display:none">
 </p>
</div>


