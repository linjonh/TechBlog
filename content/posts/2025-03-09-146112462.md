---
layout: post
title: "Java数据结构第二十期解构排序算法的艺术与科学二"
date: 2025-03-09 00:42:52 +0800
description: "这种选择排序的思路是从首尾找，起始两个值接收下标都为0，利用i去遍历数组，找出最大值与最小值下标，再让left下标的值与MinIndex下标的值交换，right下标的值与MaxIndex下标的值交换。无论是递归左边还是右边，与上面的过程都是一样的。与上面的方法类似，我们依然是以6为基准值，把6存进tmp中，right向左移动，遇到比6小的数，把6之前的位置填上；但我们一运行，就会发现，排序出现了问题，这是因为，如果最大值或最小值本身就在首尾，那么一交换，最大值或最小值就会跑掉，，所以我们还需要判断一下。"
keywords: "Java数据结构第二十期：解构排序算法的艺术与科学(二)"
categories: ['Java']
tags: ['算法', '数据结构', '排序算法']
artid: "146112462"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146112462
    alt: "Java数据结构第二十期解构排序算法的艺术与科学二"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146112462
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146112462
cover: https://bing.ee123.net/img/rand?artid=146112462
image: https://bing.ee123.net/img/rand?artid=146112462
img: https://bing.ee123.net/img/rand?artid=146112462
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java数据结构第二十期：解构排序算法的艺术与科学(二)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9c8e9ae34d5043a4804e86a086cf6ed2.gif"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/c63f0978c8eb49409eb33c9ee988d52c.jpeg"/>
    </p>
    <p class="img-center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/ea5e038a9c1e461986afff372c673c08.gif"/>
    </p>
    <blockquote>
     <p style="text-align:center">
      <strong>
       <span style="color:#fe2c24">
        专栏：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927/category_12839364.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=12839364&amp;sharerefer=PC&amp;sharesource=2401_85198927&amp;sharefrom=from_link" title="Java数据结构秘籍">
         Java数据结构秘籍
        </a>
       </span>
      </strong>
     </p>
     <p style="text-align:center">
      <strong>
       <span style="color:#fe2c24">
        个人主页：
        <a class="link-info" href="https://blog.csdn.net/2401_85198927?spm=1000.2115.3001.5343" title="手握风云">
         手握风云
        </a>
       </span>
      </strong>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0" name="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">
     一、常见排序算法的实现
    </h2>
    <h3 id="1.1.%20%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" name="1.1.%20%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">
     1.1. 直接选择排序
    </h3>
    <p>
     每⼀次从待排序的数据元素中选出最小的⼀个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。第一轮，先让j下标遍历出数组中最小的元素，再利用MinIndex存放最小的下标，利用最小值与i下标的元素进行交换；第二轮，依然让j下标遍历出待排序中最小的元素，再利用MinIndex存放最小的下标，利用最小值与i下标的元素进行交换……知道i走到最后一个元素，这样就能保证i之前的元素全部是有序的。
    </p>
    <p class="img-center">
     <img alt="" height="233" src="https://i-blog.csdnimg.cn/direct/1b4a1d3d6c3e40fc9bf6aad0da8eb6e3.png" width="374"/>
    </p>
    <p>
     <img alt="" height="225" src="https://i-blog.csdnimg.cn/direct/42709580d2ab4456ad29c8581c25cf13.png" width="678"/>
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void SelectSort(int[] array){
        for (int i = 0; i &lt; array.length; i++) {
            int MinIndex = i;
            for (int j = i+1; j &lt; array.length; j++) {
                if(array[MinIndex] &gt; array[j]){
                    MinIndex = j;
                }
            }
            swap(array,MinIndex,i);
        }
    }

    private void swap(int[] array,int i,int j){
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }

    public void DisOrder(int[] array) {
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(100);
        }
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        int[] array = new int[6];
        Sort sort = new Sort();
        sort.DisOrder(array);
        System.out.println("排序前：" + Arrays.toString(array));

        sort.SelectSort(array);
        System.out.println("排序后："+Arrays.toString(array));
    }
}</code></pre>
    <p class="img-center">
     <img alt="" height="180" src="https://i-blog.csdnimg.cn/direct/59a2475749514112afb33a4a022dd7a7.png" width="594"/>
    </p>
    <p>
     直接选择排序是不稳定的。空间上，没有使用额外的空间，空间复杂度为
     <img alt="O(n) =1" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%20%3D1">
      。时间上，
     </img>
    </p>
    <p>
     直接选择排序还有另外一种思路。与上面的方法不同的是，我们需要两个值MinIndex接收最小值下标和MaxIndex来接收最大值下标，再额外定义两个指针left和right。这种选择排序的思路是从首尾找，起始两个值接收下标都为0，利用i去遍历数组，找出最大值与最小值下标，再让left下标的值与MinIndex下标的值交换，right下标的值与MaxIndex下标的值交换。接着再让left向左移动，right向右移动，直到相遇，循环结束
    </p>
    <p class="img-center">
     <img alt="" height="244" src="https://i-blog.csdnimg.cn/direct/5165c34c0ebf4d9989a944c21fcdca07.png" width="798"/>
    </p>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void DisOrder(int[] array) {
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(100);
        }
    }

    public void SelectSort(int[] array) {
        int left = 0, right = array.length - 1;
        while (left &lt; right) {
            int MinIndex = left, MaxIndex = left;
            for (int i = left + 1; i &lt;= right; i++) {
                if (array[i] &lt; array[MinIndex]) {
                    MinIndex = i;
                }
                if (array[i] &gt; array[MaxIndex]) {
                    MaxIndex = i;
                }
            }
            swap(array, MinIndex, left);
            swap(array, MaxIndex, right);
            left++;
            right--;
        }
    }

    private void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前：" + Arrays.toString(array));
        sort.SelectSort(array);
        System.out.println("排序后：" + Arrays.toString(array));
    }
}</code></pre>
    <p class="img-center">
     <img alt="" height="145" src="https://i-blog.csdnimg.cn/direct/bbc9444d5857486fa52378d67ffc8bf4.png" width="529"/>
    </p>
    <p>
     但我们一运行，就会发现，排序出现了问题，这是因为，如果最大值或最小值本身就在首尾，那么一交换，最大值或最小值就会跑掉，，所以我们还需要判断一下。
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void DisOrder(int[] array) {
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(100);
        }
    }

    public void SelectSort(int[] array) {
        int left = 0, right = array.length - 1;
        while (left &lt; right) {
            int MinIndex = left, MaxIndex = left;
            for (int i = left + 1; i &lt;= right; i++) {
                if (array[i] &lt; array[MinIndex]) {
                    MinIndex = i;
                }
                if (array[i] &gt; array[MaxIndex]) {
                    MaxIndex = i;
                }
            }
            swap(array, MinIndex, left);
            /*if (left == MaxIndex) {
                MaxIndex = MinIndex;
            }*/
            swap(array, MaxIndex, right);
            left++;
            right--;
        }
    }

    private void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前：" + Arrays.toString(array));
        sort.SelectSort(array);
        System.out.println("排序后：" + Arrays.toString(array));
    }
}</code></pre>
    <h3 id="1.2.%20%E5%A0%86%E6%8E%92%E5%BA%8F" name="1.2.%20%E5%A0%86%E6%8E%92%E5%BA%8F">
     1.2. 堆排序
    </h3>
    <p>
     堆排序是指利⽤堆积树这种数据结构所设计的⼀种排序算法，它是选择排序的⼀ 种，通过堆来进⾏选择数据。需要注意的是排升序要建大堆，排降序建小堆。
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void HeapSort(int[] array) {
        CreateHeap(array);
        int end = array.length - 1;
        while(end &gt; 0){
            swap(array,0,end);
            ShiftDown(array,0,end);
            end--;
        }
    }

    private void CreateHeap(int[] array) {
        for (int parent = (array.length - 1 - 1) / 2; parent &gt;= 0; parent--) {
            ShiftDown(array, parent, array.length);
        }
    }

    private void ShiftDown(int[] array, int parent, int length) {
        int child = 2 * parent + 1;
        while (child &lt; length) {
            if (child + 1 &lt; length &amp;&amp; array[child] &lt; array[child + 1]) {
                child++;
            }
            if (array[child] &gt; array[parent]) {
                swap(array,parent,child);
                parent = child;
                child = 2 * parent + 1;
            } else {
                break;
            }
        }
    }

    private void swap(int[] array,int i,int j){
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }

    public void DisOrder(int[] array){
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(1,100);
        }
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Solution {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前："+ Arrays.toString(array));
        sort.HeapSort(array);
        System.out.println("排序前："+ Arrays.toString(array));
    }
}</code></pre>
    <p>
     堆排序使⽤堆来选数，效率就⾼了很多。但堆排序是不稳定的，时间复杂度为
     <img alt="O(n)=nlogn" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3Dnlogn"/>
     ，空间复杂度为
     <img alt="O(n)=1" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3D1"/>
     。
    </p>
    <h3 id="1.3.%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" name="1.3.%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">
     1.3. 冒泡排序
    </h3>
    <p>
     定义下标j，比较array[j]与array[j+1]的值，如果array[j] &gt; array[j+1]，则交换两数的位置。我们还可以进行一个优化，如果数组本身就是有序，或者没有走完所有的趟数就已经有序，那么后面就不用再比较了。
    </p>
    <p>
     <img alt="" height="174" src="https://i-blog.csdnimg.cn/direct/726aa4e79a854357ba3780e4cfc36dd6.png" width="1296"/>
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void DisOrder(int[] array) {
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(1, 100);
        }
    }

    public void BubbleSort(int[] array) {
        //表示交换的趟数
        for (int i = 0; i &lt; array.length-1; i++) {
            boolean flg = false;
            for (int j = 0; j &lt; array.length-1-i; j++) {
                if(array[j] &gt; array[j+1]){
                    swap(array,j,j+1);
                    flg = true;
                }
            }
            if(!flg){
                break;
            }
        }
    }

    private void swap(int[] array,int i,int j){
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前："+Arrays.toString(array));
        sort.BubbleSort(array);
        System.out.println("排序后："+Arrays.toString(array));
    }
}
</code></pre>
    <p>
     冒泡排序是稳定的。时间复杂度：
     <img alt="O(n)=n^{2}" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3Dn%5E%7B2%7D"/>
     ，空间复杂度：
     <img alt="O(n)=1" class="mathcode" src="https://latex.csdn.net/eq?O%28n%29%3D1"/>
     。
    </p>
    <h3 id="1.4.%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" name="1.4.%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">
     1.4. 快速排序
    </h3>
    <p>
     快速排序是Hoare于1962年提出的⼀种⼆叉树结构的交换排序⽅法，其基本思想为：任取待排序元素 序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列。
    </p>
    <p>
     我们需要定义两个指针left和right，假设以6作为基准值，left向左移动，遇到比6大的数停下；right向右移动，遇到比6小的数停下，然后交换两个元素。当两个指针相遇时，再与基准值进行交换。这样就能保证6左边都是比6小的数，6右边都是比6大的数。按照这个过程再次进行，，构成递归的条件，直到分离出只含一个值的子序列。这样就构成了如下图所示的二叉树结构。
    </p>
    <p>
     <img alt="" height="323" src="https://i-blog.csdnimg.cn/direct/d2fd2d33923e4ebfafce99c249c9d3b7.png" width="1002"/>
    </p>
    <p class="img-center">
     <img alt="" height="280" src="https://i-blog.csdnimg.cn/direct/fd912db5c82a46799c178da531541446.png" width="408"/>
    </p>
    <pre><code class="language-java">public class Sort {

    public void QuickSort(int[] array){

    }

    public void Quick(int[] array,int start,int end){
        if(start &gt;= end){//如果结点的右子树为空，就不用遍历右边
            return;
        }
        int par = partition(array,start,end);
        Quick(array,start,par-1);
        Quick(array,par+1,end);
        //当start==end时，递归条件结束
    }

    private int partition(int[] array, int left, int right) {
        return -1;
    }
}</code></pre>
    <p>
     我们接下来要思考的问题是如何写partition这个方法。无论是递归左边还是右边，与上面的过程都是一样的。只要left下标的值比基准值小，left右移；只要right下标的值比基准值大，right右移。这里我们还需要注意里层的while循环，指针不能越界。
    </p>
    <pre><code class="language-java">    private int partition(int[] array, int left, int right) {
        int i = left;
        int tmp = array[left];
        while(left &lt; right){
            while(left &lt; right &amp;&amp; array[right] &gt;= tmp){
                right--;
            }
            while(left &lt; right &amp;&amp; array[left] &lt;= tmp){
                left++;
            }
            swap(array,left,right);
        }
        swap(array,left,i);
        return left;
    }</code></pre>
    <p>
     完整代码实现：
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void DisOrder(int[] array){
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(1,40);
        }
    }

    public void QuickSort(int[] array){
        Quick(array,0,array.length-1);
    }

    public void Quick(int[] array,int start,int end){
        if(start &gt;= end){//如果结点的右子树为空，就不用遍历右边
            return;
        }
        int par = partition(array,start,end);
        Quick(array,start,par-1);
        Quick(array,par+1,end);
        //当start==end时，递归条件结束
    }

    private int partition(int[] array, int left, int right) {
        int i = left;
        int tmp = array[left];
        while(left &lt; right){
            while(left &lt; right &amp;&amp; array[right] &gt;= tmp){
                right--;
            }
            while(left &lt; right &amp;&amp; array[left] &lt;= tmp){
                left++;
            }
            swap(array,left,right);
        }
        swap(array,left,i);
        return left;
    }

    private void swap(int[] array,int i,int j){
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前："+Arrays.toString(array));
        sort.QuickSort(array);
        System.out.println("排序后："+Arrays.toString(array));
    }
}
</code></pre>
    <p>
     这里解释一下为什么先让right移动，防止越过某些值。这里我们还需要注意，&gt;=或&lt;=的等号不能省略，如果left和right的值与基准值相等，那么就不会进入内层的while循环，导致外层的while循环陷入死循环。
    </p>
    <p class="img-center">
     <img alt="" height="121" src="https://i-blog.csdnimg.cn/direct/4eb3aa0d7f2f4a8eae98e81f7efa3045.png" width="363"/>
    </p>
    <p>
     快速排序是不稳定的。快速排序的时间复杂度通常是指最好情况下，因为我们经常对快速排序进行优化。
    </p>
    <p>
     快速排序还有一种做法——挖坑法。与上面的方法类似，我们依然是以6为基准值，把6存进tmp中，right向左移动，遇到比6小的数，把6之前的位置填上；left向右移动，遇到比6大的数，把5之前的位置填上……我们只需要对上面的代码进行修改就可以。
    </p>
    <p>
     <img alt="" height="304" src="https://i-blog.csdnimg.cn/direct/ac84a6acd6e044b49be451f1f477fd0c.png" width="1408"/>
    </p>
    <pre><code class="language-java">import java.util.Random;

public class Sort {
    public void DisOrder(int[] array){
        Random ran = new Random();
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = ran.nextInt(1,40);
        }
    }

    public void QuickSort(int[] array){
        Quick(array,0,array.length-1);
    }

    public void Quick(int[] array,int start,int end){
        if(start &gt;= end){//如果结点的右子树为空，就不用遍历右边
            return;
        }
        int par = partition(array,start,end);
        Quick(array,start,par-1);
        Quick(array,par+1,end);
        //当start==end时，递归条件结束
    }

    private int partition(int[] array, int left, int right) {
        int i = left;
        int tmp = array[left];
        while(left &lt; right){
            while(left &lt; right &amp;&amp; array[right] &gt;= tmp){
                right--;
            }
            array[left] = array[right];
            while(left &lt; right &amp;&amp; array[left] &lt;= tmp){
                left++;
            }
            array[right] = array[left];
        }
        array[left] = tmp;
        return left;
    }

}
</code></pre>
    <pre><code class="language-java">import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        Sort sort = new Sort();
        int[] array = new int[6];
        sort.DisOrder(array);
        System.out.println("排序前："+ Arrays.toString(array));
        sort.QuickSort(array);
        System.out.println("排序后："+ Arrays.toString(array));
    }
}</code></pre>
    <p>
     我们接下来思考一下快排的优化。我们先来看第一种三数取中法。我们找出start和end的中位数，让二叉树的形状尽量不要出现单分支的情况。那我们怎么再这段区间里面去找中位数呢？我们可以通过下标来找
    </p>
    <p class="img-center">
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/a8392d279137465989876bff5589e7b0.png" width="289"/>
    </p>
    <pre><code class="language-java">    private static int midNum(int[] array, int left, int right) {
        int mid = (left+right)/2;
        if(array[left] &lt; array[right]) {
            if(array[mid] &lt; array[left]) {
                return left;
            }else if(array[mid] &gt; array[right]) {
                return right;
            }else {
                return mid;
            }
        }else {
            if(array[mid] &gt; array[left]) {
                return left;
            }else if(array[mid] &lt; array[right]) {
                return right;
            }else {
                return mid;
            }
        }
    }</code></pre>
    <p>
     第二种，递归到⼩的⼦区间时，可以考虑使⽤插⼊排序。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38353139383932372f:61727469636c652f64657461696c732f313436313132343632" class_="artid" style="display:none">
 </p>
</div>


