---
layout: post
title: "常用的分布式ID设计方案"
date: 2025-03-05 21:07:16 +0800
description: "分布式ID设计需权衡性能、有序性、可用性和复杂度。Snowflake及其衍生方案（如Leaf）是通用性最强的选择，而号段模式适合数据库友好的场景。最终选型应基于业务实际需求，结合团队技术栈和运维能力，确保系统的稳定性和扩展性。"
keywords: "常用的分布式ID设计方案"
categories: ['未分类']
tags: ['Spring', 'Java', 'Cloud']
artid: "146053072"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053072
    alt: "常用的分布式ID设计方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053072
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053072
cover: https://bing.ee123.net/img/rand?artid=146053072
image: https://bing.ee123.net/img/rand?artid=146053072
img: https://bing.ee123.net/img/rand?artid=146053072
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     常用的分布式ID设计方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     分布式系统中生成唯一ID是常见需求，尤其在微服务、分库分表等场景下，需要满足
     <strong>
      全局唯一、有序递增、高可用、低延迟
     </strong>
     等特性。以下是七种主流方案及其核心逻辑：
    </p>
    <hr/>
    <h4>
     一、数据库自增ID
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：利用数据库自增主键（如MySQL的
     <code>
      AUTO_INCREMENT
     </code>
     ）生成连续ID。
     <br/>
     <strong>
      优化方案
     </strong>
     ：
    </p>
    <ul>
     <li>
      ​
      <strong>
       单数据库多实例
      </strong>
      ：不同实例设置不同自增步长（
      <code>
       auto_increment_increment
      </code>
      和
      <code>
       auto_increment_offset
      </code>
      ）。
     </li>
     <li>
      ​
      <strong>
       分片号段模式
      </strong>
      ：每次从数据库批量获取ID段（如1~1000），应用内存中分配。
      <br/>
      <strong>
       优点
      </strong>
      ：简单易用、ID连续递增。
      <br/>
      <strong>
       缺点
      </strong>
      ：依赖数据库性能，扩展性差，存在单点故障风险。
      <br/>
      <strong>
       适用场景
      </strong>
      ：小型系统、单数据库架构。
     </li>
    </ul>
    <hr/>
    <h4>
     二、UUID
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：基于时间、MAC地址、随机数生成128位唯一字符串（如
     <code>
      550e8400-e29b-41d4-a716-446655440000
     </code>
     ）。
     <br/>
     <strong>
      优点
     </strong>
     ：本地生成、无网络开销、无重复风险。
     <br/>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      无序性导致数据库索引效率低（B+树分裂频繁）。
     </li>
     <li>
      长度过长（36字符），存储和传输效率低。
      <br/>
      <strong>
       适用场景
      </strong>
      ：临时标识、低并发且无需排序的场景。
     </li>
    </ul>
    <hr/>
    <h4>
     三、Redis生成ID
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：利用Redis单线程特性，通过
     <code>
      INCR
     </code>
     或
     <code>
      INCRBY
     </code>
     命令生成递增ID。
     <br/>
     <strong>
      优化方案
     </strong>
     ：
    </p>
    <ul>
     <li>
      ​
      <strong>
       集群分片
      </strong>
      ：每个Redis实例分配独立步长（类似数据库多实例）。
     </li>
     <li>
      ​
      <strong>
       Lua脚本原子操作
      </strong>
      ：批量获取ID段，减少网络开销。
      <br/>
      <strong>
       优点
      </strong>
      ：性能高于数据库（10万+ QPS），可扩展性强。
      <br/>
      <strong>
       缺点
      </strong>
      ：需维护Redis集群，持久化策略影响数据可靠性。
      <br/>
      <strong>
       适用场景
      </strong>
      ：高并发但对ID连续性要求不高的场景。
     </li>
    </ul>
    <hr/>
    <h4>
     四、Snowflake算法（雪花算法）
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：由Twitter提出的64位ID结构，包含时间戳、机器ID、序列号：
    </p>
    <pre><code>0 | 41位时间戳 | 10位机器ID | 12位序列号</code></pre>
    <ul>
     <li>
      ​
      <strong>
       时间戳
      </strong>
      ：毫秒级时间差（自定义起始时间，如2020-01-01）。
     </li>
     <li>
      ​
      <strong>
       机器ID
      </strong>
      ：通过ZooKeeper、配置中心或IP哈希分配。
     </li>
     <li>
      ​
      <strong>
       序列号
      </strong>
      ：同一毫秒内的并发序列（支持4096/ms）。
      <br/>
      <strong>
       优点
      </strong>
      ：本地生成、性能高（单机万级QPS）、ID有序。
      <br/>
      <strong>
       缺点
      </strong>
      ：依赖时钟同步（时钟回拨导致重复ID）。
      <br/>
      <strong>
       解决方案
      </strong>
      ：
     </li>
     <li>
      关闭NTP同步（不推荐）。
     </li>
     <li>
      记录上次生成时间戳，检测到回拨时等待或报警。
      <br/>
      <strong>
       适用场景
      </strong>
      ：分布式系统、分库分表场景。
     </li>
    </ul>
    <hr/>
    <h4>
     五、Leaf算法
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：美团开源的分布式ID生成服务，整合
     <strong>
      Snowflake
     </strong>
     和
     <strong>
      号段模式
     </strong>
     。
     <br/>
     <strong>
      两种模式
     </strong>
     ：
    </p>
    <ol>
     <li>
      ​
      <strong>
       Leaf-Snowflake
      </strong>
      ：优化时钟回拨问题，通过ZooKeeper协调Worker ID。
     </li>
     <li>
      ​
      <strong>
       Leaf-Segment
      </strong>
      ：基于数据库号段预分配，双Buffer异步更新。
      <br/>
      <strong>
       优点
      </strong>
      ：高可用、支持监控和管理后台。
      <br/>
      <strong>
       缺点
      </strong>
      ：需独立部署服务，增加系统复杂度。
      <br/>
      <strong>
       适用场景
      </strong>
      ：中大型企业级应用。
     </li>
    </ol>
    <hr/>
    <h4>
     六、TinyID（百度）
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：基于数据库号段模式，支持HTTP和RPC两种接入方式。
     <br/>
     <strong>
      核心优化
     </strong>
     ：
    </p>
    <ul>
     <li>
      ​
      <strong>
       多号段缓存
      </strong>
      ：提前加载多个号段，避免分配延迟。
     </li>
     <li>
      ​
      <strong>
       动态步长调整
      </strong>
      ：根据历史QPS自动调整号段大小。
      <br/>
      <strong>
       优点
      </strong>
      ：高吞吐、低延迟。
      <br/>
      <strong>
       缺点
      </strong>
      ：依赖数据库和中心化服务。
      <br/>
      <strong>
       适用场景
      </strong>
      ：电商、金融等高并发业务。
     </li>
    </ul>
    <hr/>
    <h4>
     七、MongoDB ObjectId
    </h4>
    <p>
     <strong>
      原理
     </strong>
     ：12字节（24字符）的十六进制字符串，结构如下：
    </p>
    <pre><code>4字节时间戳 | 5字节机器ID | 3字节进程ID | 4字节计数器</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：无需中心化服务，内置分布式支持。
     <br/>
     <strong>
      缺点
     </strong>
     ：无序性、长度较长。
     <br/>
     <strong>
      适用场景
     </strong>
     ：MongoDB数据库集成场景。
    </p>
    <hr/>
    <h4>
     方案对比与选型建议
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        ​
        <strong>
         方案
        </strong>
        ​
       </th>
       <th>
        ​
        <strong>
         有序性
        </strong>
        ​
       </th>
       <th>
        ​
        <strong>
         性能
        </strong>
        ​
       </th>
       <th>
        ​
        <strong>
         复杂度
        </strong>
        ​
       </th>
       <th>
        ​
        <strong>
         适用场景
        </strong>
        ​
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        数据库自增ID
       </td>
       <td>
        ✔️
       </td>
       <td>
        低
       </td>
       <td>
        低
       </td>
       <td>
        单数据库、小规模系统
       </td>
      </tr>
      <tr>
       <td>
        UUID
       </td>
       <td>
        ❌
       </td>
       <td>
        高
       </td>
       <td>
        低
       </td>
       <td>
        临时标识、低并发场景
       </td>
      </tr>
      <tr>
       <td>
        Redis
       </td>
       <td>
        ✔️
       </td>
       <td>
        高
       </td>
       <td>
        中
       </td>
       <td>
        高并发、非强连续场景
       </td>
      </tr>
      <tr>
       <td>
        Snowflake
       </td>
       <td>
        ✔️
       </td>
       <td>
        极高
       </td>
       <td>
        中
       </td>
       <td>
        分布式系统、分库分表
       </td>
      </tr>
      <tr>
       <td>
        Leaf
       </td>
       <td>
        ✔️
       </td>
       <td>
        高
       </td>
       <td>
        高
       </td>
       <td>
        企业级应用、需高可用
       </td>
      </tr>
      <tr>
       <td>
        TinyID
       </td>
       <td>
        ✔️
       </td>
       <td>
        高
       </td>
       <td>
        高
       </td>
       <td>
        高并发、动态调整需求
       </td>
      </tr>
      <tr>
       <td>
        MongoDB ObjectId
       </td>
       <td>
        ❌
       </td>
       <td>
        高
       </td>
       <td>
        低
       </td>
       <td>
        MongoDB集成场景
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      选型原则
     </strong>
     ：
    </p>
    <ol>
     <li>
      ​
      <strong>
       业务需求
      </strong>
      ：是否需要有序性（影响数据库索引效率）？
     </li>
     <li>
      ​
      <strong>
       并发量级
      </strong>
      ：是否需支持每秒数万级ID生成？
     </li>
     <li>
      ​
      <strong>
       系统架构
      </strong>
      ：是否已存在ZooKeeper、Redis等中间件？
     </li>
     <li>
      ​
      <strong>
       容灾能力
      </strong>
      ：能否接受单点故障或时钟回拨风险？
     </li>
    </ol>
    <hr/>
    <h4>
     实战示例：Snowflake的Java实现
    </h4>
    <pre><code>public class SnowflakeIdGenerator {
    private final long twepoch = 1625097600000L; // 2021-07-01 00:00:00
    private final long workerIdBits = 5L;
    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);
    private final long sequenceBits = 12L;
    private final long workerIdShift = sequenceBits;
    private final long timestampShift = sequenceBits + workerIdBits;
    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);

    private long workerId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;

    public SnowflakeIdGenerator(long workerId) {
        if (workerId &gt; maxWorkerId || workerId &lt; 0) {
            throw new IllegalArgumentException("Worker ID超出范围");
        }
        this.workerId = workerId;
    }

    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        if (timestamp &lt; lastTimestamp) {
            throw new RuntimeException("时钟回拨，拒绝生成ID");
        }
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) &amp; sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        lastTimestamp = timestamp;
        return ((timestamp - twepoch) &lt;&lt; timestampShift)
                | (workerId &lt;&lt; workerIdShift)
                | sequence;
    }

    private long tilNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp &lt;= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}</code></pre>
    <hr/>
    <h4>
     总结
    </h4>
    <p>
     分布式ID设计需权衡
     <strong>
      性能、有序性、可用性和复杂度
     </strong>
     。Snowflake及其衍生方案（如Leaf）是通用性最强的选择，而号段模式适合数据库友好的场景。最终选型应基于业务实际需求，结合团队技术栈和运维能力，确保系统的稳定性和扩展性。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f6c6531323334353637383933343639342f:61727469636c652f64657461696c732f313436303533303732" class_="artid" style="display:none">
 </p>
</div>


