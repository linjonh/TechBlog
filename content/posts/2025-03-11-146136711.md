---
layout: post
title: "Linux第18节-重定向与文件IO的基本认识"
date: 2025-03-11 20:53:12 +0800
description: "增删查改对文件的管理即：先描述再组织！默认情况下，C/C++会打开三个标准流(输入，输出，错误) --- > 一个进程可以打开多个文件；当以\"w\"的形式读取一个文件的时候，如果该文件不存在，会创建一个新文件；此时创建文件的时候，默认是在当前路径下创建文件！(什么是当前路径？即当前该进程运行的时候，所对应的路径！当前路径：当前进程的cwd路径！如果我们想要改变当前的工作路径，可以通过系统调用接口chdir来实现！如下所示：此时新创建的文件就会在我们chdir指定的路径中！fopenfopen。"
keywords: "Linux第18节 --- 重定向与文件IO的基本认识"
categories: ['未分类']
tags: ['运维', '算法', '服务器', '学习', 'Vim', 'Linux', 'C']
artid: "146136711"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146136711
    alt: "Linux第18节-重定向与文件IO的基本认识"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146136711
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146136711
cover: https://bing.ee123.net/img/rand?artid=146136711
image: https://bing.ee123.net/img/rand?artid=146136711
img: https://bing.ee123.net/img/rand?artid=146136711
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux第18节 --- 重定向与文件IO的基本认识
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、引入一些文件的共识原理：
    </h2>
    <ol>
     <li>
      <strong>
       文件 = 内容 + 属性；
      </strong>
     </li>
     <li>
      <strong>
       文件分为打开的文件和没被打开的文件；
      </strong>
     </li>
     <li>
      <strong>
       打开的文件是谁打开的？（进程！）因此本质上是研究进程和文件之间的关系！
      </strong>
     </li>
     <li>
      <strong>
       没打开的文件在哪里放着？（磁盘上！）此时我们应该关注什么问题？（没有被打开的文件非常多，文件如何被分门别类的放置好，即文件应该如何存储？---&gt; 这样做的目的是方便我们快速的找到文件并进行
       <span style="color:#fe2c24">
        增删查改
       </span>
       的工作！）
      </strong>
     </li>
    </ol>
    <p>
     <span style="color:#ff9900">
      <strong>
       文件被打开，首要的是必须被加载到对应的内存当中(理想情况是内容和属性都加载，但是属性是必须的，内容如果不进行读取等操作可以不加载)；
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#ff9900">
      <strong>
       一个进程可以打开多个文件；
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="177" src="https://i-blog.csdnimg.cn/direct/adee01e4d4674135a6890e8ab61757ac.png" width="2178"/>
    </p>
    <p>
     对文件的管理即：先描述再组织！
    </p>
    <p>
     默认情况下，C/C++会打开三个标准流(输入，输出，错误) --- &gt; 一个进程可以打开多个文件；
    </p>
    <p>
     当以"w"的形式读取一个文件的时候，如果该文件不存在，会创建一个新文件；
    </p>
    <p>
     <img alt="" height="637" src="https://i-blog.csdnimg.cn/direct/165a538acf9a4543a3f986f5c40dbacf.png" width="1003"/>
    </p>
    <p>
     此时创建文件的时候，默认是在当前路径下创建文件！(什么是当前路径？)
    </p>
    <p>
     即当前该进程运行的时候，所对应的路径！
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       这里我们可以通过proc目录下的cwd查看当前进程的当前路径！
      </strong>
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="259" src="https://i-blog.csdnimg.cn/direct/183d9fd496a740a1be0eb8358a43aa60.png" width="500"/>
    </p>
    <p>
     当前路径：当前进程的cwd路径！
    </p>
    <p>
     如果我们想要改变当前的工作路径，可以通过系统调用接口chdir来实现！
    </p>
    <p>
     如下所示：
    </p>
    <p class="img-center">
     <img alt="" height="744" src="https://i-blog.csdnimg.cn/direct/66d8ab4e384a4df19d59edee41919d40.png" width="500"/>
    </p>
    <p>
     此时新创建的文件就会在我们chdir指定的路径中！
    </p>
    <p>
     接下来我们介绍两个C语言中关于文件的函数：
    </p>
    <h3>
     <strong>
      1、
      <code>
       fopen
      </code>
      函数：打开文件
     </strong>
    </h3>
    <p>
     <code>
      fopen
     </code>
     用于打开文件并建立文件流，其原型为：
    </p>
    <pre><code class="language-cpp">FILE *fopen(const char *filename, const char *mode);  </code></pre>
    <ul>
     <li>
      <strong>
       参数
      </strong>
      ：
      <ul>
       <li>
        <code>
         filename
        </code>
        ：文件名（含路径），需注意路径中的转义字符（如
        <code>
         C:\\file.txt
        </code>
        需写成
        <code>
         "C:\\\\file.txt"
        </code>
        ） 。
        <br/>
       </li>
       <li>
        <code>
         mode
        </code>
        ：文件打开模式，决定读写权限和操作方式（见下表）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回值
      </strong>
      ：成功返回
      <code>
       FILE
      </code>
      指针，失败返回
      <code>
       NULL
      </code>
      ，需通过判断返回值确保文件打开成功 。
     </li>
    </ul>
    <p>
     2.
     <strong>
      文件打开模式
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="276" src="https://i-blog.csdnimg.cn/direct/b4cd23e9ebd04883942a33c57bd217e2.png" width="400"/>
    </p>
    <ul>
     <li>
      <strong>
       注意事项
      </strong>
      ：
      <ul>
       <li>
        <code>
         "r"
        </code>
        模式下文件不存在会失败，而
        <code>
         "w"
        </code>
        和
        <code>
         "a"
        </code>
        会自动创建文件 。
        <br/>
       </li>
       <li>
        二进制模式（
        <code>
         b
        </code>
        ）用于非文本数据（如图片、结构体），避免编码转换问题 。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     总结：w方法在写入前会对文件进行清空！
    </p>
    <p>
     <img alt="" height="396" src="https://i-blog.csdnimg.cn/direct/55cef4ed32da4f8ca6bc71bded34863c.png" width="973"/>
    </p>
    <p>
     类似的，在之前我们使用的输出重定向也是以 "w"的形式进行写入的！
    </p>
    <h3>
     <strong>
      2、
      <code>
       fwrite
      </code>
      函数：写入数据
     </strong>
    </h3>
    <h5>
     1.
     <strong>
      功能与原型
     </strong>
    </h5>
    <p>
     <code>
      fwrite
     </code>
     用于将数据块写入文件，支持二进制操作，其原型为：
    </p>
    <pre><code class="language-cpp">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);  </code></pre>
    <ul>
     <li>
      <strong>
       参数
      </strong>
      ：
      <ul>
       <li>
        <code>
         ptr
        </code>
        ：待写入数据的指针（如数组、结构体地址）。
       </li>
       <li>
        <code>
         size
        </code>
        ：单个数据块的字节数（如
        <code>
         sizeof(int)
        </code>
        ）。
       </li>
       <li>
        <code>
         nmemb
        </code>
        ：数据块数量。
       </li>
       <li>
        <code>
         stream
        </code>
        ：由
        <code>
         fopen
        </code>
        返回的文件指针 。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回值
      </strong>
      ：实际写入的数据块数目，若与
      <code>
       nmemb
      </code>
      不同可能表示错误 。
     </li>
    </ul>
    <p>
     写入字符串的时候，如果写入的字符包含\0，此时就会以乱码的形式显示！
    </p>
    <p>
     <img alt="" height="193" src="https://i-blog.csdnimg.cn/direct/c5f287a469c242ada7fded307c5d6d26.png" width="1345"/>
    </p>
    <p>
     因此我们写入字符串的时候不要带\0！！！
    </p>
    <p>
     带\0是C语言的规定，但是对于写入到文件的内容来说，是需要其他人或软件或语言来读取的，这种读取和C语言的规定没有关系！
    </p>
    <p>
     a方式写入是在文本末尾追加的形式写入！如果该文件不存在此时也会创建文件！
    </p>
    <p>
     对于重定向：&gt;是以w的方式打开         &gt;&gt;是以a的方式打开！
    </p>
    <h2>
     二、认识文件的系统调用
    </h2>
    <p>
     <strong>
      <img alt="" height="511" src="https://i-blog.csdnimg.cn/direct/5f7869965a174becb375422b7988e484.png" width="1725"/>
     </strong>
    </p>
    <p>
     <strong>
      这里，当我们的文件还没有被加载的时候，是存放在磁盘当中的，因此访问磁盘文件，实际上就是访问硬件！
     </strong>
    </p>
    <p>
     <strong>
      而用户如果需要访问硬件，那么只能经过操作系统；
     </strong>
    </p>
    <p>
     <strong>
      而操作系统不相信用户，因此只能通过系统调用接口来进行访问；
     </strong>
    </p>
    <p>
     <strong>
      此时的printf/fprintf/fscanf/fwrite等库函数实际上底层调用的就是系统调用接口！
     </strong>
    </p>
    <p>
     <img alt="" height="93" src="https://i-blog.csdnimg.cn/direct/626feb70b68b46088c62ad0607b66df9.png" width="925"/>
    </p>
    <p>
     上面一个函数经常用于当前文件已经存在，我们要对其进行写入；
    </p>
    <p>
     下面一个函数经常用于当前文件不存在，此时我们要进行写入的时候需要调整其权限！
    </p>
    <p>
     使用open的示例代码：
    </p>
    <p>
     <img alt="" height="418" src="https://i-blog.csdnimg.cn/direct/c772778bbd984da6b2962b115d9ee969.png" width="808"/>
    </p>
    <p>
     <img alt="" height="268" src="https://i-blog.csdnimg.cn/direct/bcda09f805b0400bbaba23e000be5357.png" width="780"/>
    </p>
    <p>
     注意点一：如果该文件不存在，此时我们还需要 + O_CREAT这个选项；
    </p>
    <p>
     这时候显示的代码权限完全不正确！
    </p>
    <p>
     这是因为在Linux中，如果我们新建文件，必须要指定文件的权限！
    </p>
    <p>
     所以此时我们还需要第三个参数！
    </p>
    <p class="img-center">
     <img alt="" height="441" src="https://i-blog.csdnimg.cn/direct/9e4e50e7569a4071af5fea9925d7fe04.png" width="400"/>
    </p>
    <p>
     <img alt="" height="217" src="https://i-blog.csdnimg.cn/direct/0d48fc7c854b47739f018f740505b191.png" width="771"/>
    </p>
    <p>
     但是这里当我们指定权限为666的时候，最后的权限结果却为664！
    </p>
    <p>
     这是因为还存在权限掩码！
    </p>
    <p>
     因为我们可以调用一个系统调用接口为umask来改变当前进行的掩码！
    </p>
    <p class="img-center">
     <img alt="" height="212" src="https://i-blog.csdnimg.cn/direct/2e8f37afd42c42238582e35d36511b01.png" width="400"/>
    </p>
    <p>
     该设置不会影响这个系统，但是会影响该进程！
    </p>
    <p>
     open成功后返回的整数是文件描述符！
    </p>
    <p>
     如果我们想覆盖式写入:可以采用下面这个宏：
     <span style="color:#fe2c24">
      <strong>
       <code>
        O_TRUNC；
       </code>
      </strong>
     </span>
    </p>
    <p>
     <strong>
      <code>
       如果我们想追加写入，可以采用下面这种形式：
       <span style="color:#fe2c24">
        O_APPEND
       </span>
      </code>
     </strong>
     <span style="color:#fe2c24">
      <strong>
       <code>
        ；
       </code>
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/ef1154028b7c41ba9d0f90f2fb00d117.png" width="1009"/>
    </p>
    <p>
     因此此时我们可以推断出：对于上面的C语言类型的fopen，封装的系统调用一定是按照下面的形式进行的！
    </p>
    <p>
     <img alt="" height="885" src="https://i-blog.csdnimg.cn/direct/f889e565356a454a9798a03bede7e394.png" width="1213"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       当一个进程打开多个文件的时候，此时需要对该文件进行组织！
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       即先描述再组织，这里也就是struct_file（描述已打开的文件的信息）；
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       struct_file里面包含了该的大部分信息；
      </strong>
     </span>
    </p>
    <p>
     deepseek解释如下：
    </p>
    <p>
     在Linux内核中，
     <strong>
      <code>
       struct file
      </code>
     </strong>
     是表示
     <strong>
      已打开文件
     </strong>
     的核心数据结构，用于管理文件在进程中的动态状态。以下是其关键特性的详细解析：
    </p>
    <ol>
     <li>
      <strong>
       基本定义
      </strong>
      <ul>
       <li>
        <code>
         struct file
        </code>
        定义在
        <code>
         include/linux/fs.h
        </code>
        中，内核在调用
        <code>
         open()
        </code>
        打开文件时创建该结构体，关闭文件后释放 。
        <br/>
       </li>
       <li>
        <strong>
         核心作用
        </strong>
        ：
        <ul>
         <li>
          跟踪文件的
          <strong>
           打开状态
          </strong>
          （如读写位置、权限模式等）。
         </li>
         <li>
          关联文件操作函数（如
          <code>
           read
          </code>
          、
          <code>
           write
          </code>
          ），通过
          <code>
           file_operations
          </code>
          结构体实现。
         </li>
         <li>
          存储进程与文件交互的上下文信息（如缓冲区、私有数据） 。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     在进程task_struct结构体里面。包含了下面这个指针：
     <span style="color:#fe2c24">
      <strong>
       struct files_struct *files(包含的是打开文件的信息)
      </strong>
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/682fda963a2d414ebf19d2faea5511d7.png" width="400"/>
    </p>
    <p>
     <img alt="" height="955" src="https://i-blog.csdnimg.cn/direct/eea0d20233494d1084978413af80a866.png" width="2356"/>
    </p>
    <p>
     这里的
     <span style="color:#fe2c24">
      <strong>
       struct files_struct *files是一个指向指针数组的指针！
      </strong>
     </span>
    </p>
    <p>
     即
     <span style="color:#fe2c24">
      <strong>
       struct files_struct *files指向一个表，该表称为文件描述表；
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       里面存放的是已经打开的文件的信息，即struct_file;
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="76" src="https://i-blog.csdnimg.cn/direct/26d12fd600044e1bb2d8a3e4bf70ea02.png" width="1104"/>
    </p>
    <p>
     当我们调用open的时候，返回的对象是一个int类型；该返回值实际上就是文件描述符表的下标！
    </p>
    <p>
     结论：fd的返回值本质上是数组的下标！
    </p>
    <p>
     此时无论是write / close实际上都是对这个下标对应的空间进行管理！
    </p>
    <p>
     右边的struct file也需要用双链表进行联系！
    </p>
    <p class="img-center">
     <img alt="" height="329" src="https://i-blog.csdnimg.cn/direct/f68a19ff8cfc4aa794ce52105158d32f.png" width="480"/>
    </p>
    <p>
     用户自己用的时候，默认的第一个文件描述符是3！(失败返回-1）
    </p>
    <p class="img-center">
     <img alt="" height="116" src="https://i-blog.csdnimg.cn/direct/114aa1699e204fcca3d42128216fd751.png" width="400"/>
    </p>
    <p>
     0，1，2在系统打开的时候，已经被默认占用了！
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       操作系统中，只认fd！而其他的例如stdin，stdout，stderr都是C语言规定的！本质上只是再封装！
      </strong>
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="133" src="https://i-blog.csdnimg.cn/direct/57108bd00e1e4f02b8014e53c58dffbc.png" width="200"/>
    </p>
    <p>
     <img alt="" height="105" src="https://i-blog.csdnimg.cn/direct/23a13de60cef42dc93552b540da8ba3d.png" width="646"/>
    </p>
    <p>
     这里我们直接往1里面进行写入，实际上效果与printf没有区别！
    </p>
    <p>
     （直接往2里面写效果也一样！）
    </p>
    <p>
     接下来我们再尝试fd = 0的情况：
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/9f6e7525ccfb401bae2cb768719563da.png" width="703"/>
    </p>
    <p>
     这里我们按照读取字符串的形式来读取，保险起见将字符数组最后一个元素设置为\0，方便操作系统能识别到是字符串！（最终效果和scanf一样！）
    </p>
    <p>
     结论：stdin，stdout，stderr不是系统的特性！是操作系统的特性！系统会默认打开键盘和显示器！
    </p>
    <h3>
     问题：C语言中的FILE实际上是什么？
    </h3>
    <p>
     答：本质是C库自己封装的一个结构体！（这个结构体里面必须包含文件描述符！！！）
    </p>
    <p class="img-center">
     <img alt="" height="122" src="https://i-blog.csdnimg.cn/direct/f40a968d6fde477aab309908fd00f302.png" width="480"/>
    </p>
    <p>
     这里我们可以通过-&gt;来查看对应的文件描述符！！！
    </p>
    <p>
     _fileno实际上就是我们对应的文件描述符
    </p>
    <p>
     运行结果如下所示：
    </p>
    <p class="img-center">
     <img alt="" height="112" src="https://i-blog.csdnimg.cn/direct/09d09703b89f41dc87fea474e530c696.png" width="480"/>
    </p>
    <p>
     问题：当我们用close(1)将显示器关闭，此时再输出会出现什么结果？
    </p>
    <p>
     <img alt="" height="276" src="https://i-blog.csdnimg.cn/direct/0decc080ab3b4ee7ab17961899af9e36.png" width="828"/>
    </p>
    <p>
     此时printf无法打印正常的结果！(但是fprint会打印结果！)
    </p>
    <p>
     printf返回值为打印的字符的个数！
    </p>
    <p>
     fprint能打印出来的是因为其文件描述符指定的是2号！1号被关闭与它没影响！
    </p>
    <p>
     <img alt="" height="898" src="https://i-blog.csdnimg.cn/direct/bb67191d26e34186860cdcdb54182ae8.png" width="1174"/>
    </p>
    <p>
     struct file里面为了记录该文件被几个进程调用，此时会有一个变量count！
    </p>
    <p>
     count是为了实现引用计数！
    </p>
    <p>
     <img alt="" height="550" src="https://i-blog.csdnimg.cn/direct/b439cb05399343859ecb01bdf6500b43.png" width="1506"/>
    </p>
    <p>
     此时有几个文件描述符指向，对应的count就会有多少；
    </p>
    <p>
     因此此时每close一个，对应的count --；
    </p>
    <p>
     当count = 0；此时文件描述符表就会对该空间进行回收 + 数组下标置空！
    </p>
    <h2>
     三、重定向和缓冲区
    </h2>
    <p class="img-center">
     <img alt="" height="315" src="https://i-blog.csdnimg.cn/direct/efdf2e04aa274586b9951bf0f9fe0c63.png" width="500"/>
    </p>
    <p>
     当我们尝试创建一个文件并往里面写入东西时，如果我们先将close(0),即将键盘输入关闭，此时printf输出的fd即为0！
    </p>
    <p>
     若close(1)，此时printf无法在显示器上打印！
    </p>
    <p class="img-center">
     <img alt="" height="619" src="https://i-blog.csdnimg.cn/direct/27dad37a62db4884928ec37e7b208d5f.png" width="500"/>
    </p>
    <p>
     如果我们将2关闭，即close(2)，此时printf会正常打印，且打印结果为2！
    </p>
    <p>
     因此此时我们可以得到一下结论：
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       文件描述符对应的分配规则是什么？
      </strong>
     </span>
    </p>
    <p>
     <strong>
      从0下标开始，依次寻找从0开始的最小数组下标位置，它的下标就是新文件的文件描述符；
     </strong>
    </p>
    <p>
     接下来我们做一个测试：close(1)，然后依次往显示器中写入，看最终的结果是什么？
    </p>
    <p class="img-center">
     <img alt="" height="663" src="https://i-blog.csdnimg.cn/direct/1d5da76520394cce9bf8152e8ab57bc1.png" width="500"/>
    </p>
    <p class="img-center">
     <img alt="" height="258" src="https://i-blog.csdnimg.cn/direct/72a442451b6d43a3bba5a0350dde046e.png" width="400"/>
    </p>
    <p>
     此时我们可以发现：最终应该显示在显示器中的文件，却写入到文件中！
    </p>
    <p>
     本来应该写入到显示器中的文件，最后却写入到文件中！这个现象叫做输出重定向！
    </p>
    <p>
     解释现象：因为刚开始我们就进行了close(1)，因此此时创建的fd就是1！然后我们在write在1中写入也就是在fd中写入！最终写入到文件中！
     <img alt="" height="592" src="https://i-blog.csdnimg.cn/direct/8ced9b14879046458e3edd013570b4ca.png" width="1342"/>
    </p>
    <p>
     整体的流程如上所示：主要是对应的文件描述符表的1号下标中的显示器替换为此时我们的log.txt!
    </p>
    <h3>
     重定向的系统调用接口
    </h3>
    <p>
     共有dup1，dup2和dup3，其中最常用的是dup2！
    </p>
    <p class="img-center">
     <img alt="" height="247" src="https://i-blog.csdnimg.cn/direct/b33247d5f6bb42f3b7a3efbd221a79c3.png" width="500"/>
    </p>
    <p>
     思路：此时我们仅需要将三号的对应的文件的地址覆盖到一号即可；
    </p>
    <p>
     <strong>
      <code>
       dup2
      </code>
      函数
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="107" src="https://i-blog.csdnimg.cn/direct/32b6bfa8e35c4059b7d4f7a3032cf2ef.png" width="400"/>
    </p>
    <p>
     newfd最终会被oldfd所覆盖！ (这里的newfd为1，oldfd为log.txt)
    </p>
    <p>
     实际上是文件描述符对应的指针内容进行了拷贝！
    </p>
    <p class="img-center">
     <img alt="" height="350" src="https://i-blog.csdnimg.cn/direct/7191c6c71e1e44dc9e3e614d1c67a659.png" width="360"/>
    </p>
    <p>
     这里我们通过重定向可以实现和之前一样的效果！
    </p>
    <p class="img-center">
     <img alt="" height="331" src="https://i-blog.csdnimg.cn/direct/56544559729b483a85d1d182bfcf52b0.png" width="360"/>
    </p>
    <p>
     这里我们再将对应的fd设置为O_APPEND，即为追加重定向！
    </p>
    <p>
     <img alt="" height="151" src="https://i-blog.csdnimg.cn/direct/4c0b4948094945cca4d9ef98a789ac19.png" width="807"/>
    </p>
    <p>
     这里对于read系统调用接口：count指的是期望读取的字节格式；
    </p>
    <p>
     返回值为实际上读取的字节个数！
    </p>
    <p>
     输入重定向：默认从键盘读取数据，然后改成从文本中读取数据；
    </p>
    <p class="img-center">
     <img alt="" height="342" src="https://i-blog.csdnimg.cn/direct/99527d570a2c4ca08e5d53f312fcd1f2.png" width="500"/>
    </p>
    <p class="img-center">
     <img alt="" height="61" src="https://i-blog.csdnimg.cn/direct/76c166a5c765486bbdae1b94bc7f2aff.png" width="400"/>
    </p>
    <p>
     我们通过dup2将fd重定向到键盘中，然后此时通过read要从键盘当中读取，直接变成了从文件当中读取！
    </p>
    <p>
     效果与我们之前通过cat实现的输入重定向一样：
    </p>
    <p class="img-center">
     <img alt="" height="158" src="https://i-blog.csdnimg.cn/direct/46fa413f8b8140448d808ab2db10e8de.png" width="400"/>
    </p>
    <p>
     问题：重定向会影响程序替换吗？
    </p>
    <p>
     <img alt="" height="865" src="https://i-blog.csdnimg.cn/direct/d9608279f3ec47168077ca70285f533e.png" width="2358"/>
    </p>
    <p>
     当我们进行重定向得到时候，实际上改变的都是左侧的内核数据结构！和右边的对应的进程的结构无关！
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       问题：标准输出stdout和标准错误stderr有什么区别？
      </strong>
     </span>
    </p>
    <p>
     假设当前我们有如下所示的代码：
    </p>
    <p class="img-center">
     <img alt="" height="235" src="https://i-blog.csdnimg.cn/direct/dc5b347d9db9417581b98e78f782d655.png" width="360"/>
    </p>
    <p>
     如果我们正常进行打印:
    </p>
    <p class="img-center">
     <img alt="" height="224" src="https://i-blog.csdnimg.cn/direct/22eb422e49b142b1a9b8b6c40502b362.png" width="360"/>
    </p>
    <p>
     在显示器上两个结果都能显示；
    </p>
    <p>
     如果我们进行重定向：
    </p>
    <p class="img-center">
     <img alt="" height="189" src="https://i-blog.csdnimg.cn/direct/97d7441a16864a129699fcc61688ab59.png" width="360"/>
    </p>
    <p>
     结果为：只有stdout的内容会被重定向到文件中；stderr的内容打印在显示器中；
    </p>
    <p class="img-center">
     <img alt="" height="526" src="https://i-blog.csdnimg.cn/direct/184c6cdbd5d441fa98bfe82a4bcae816.png" width="400"/>
    </p>
    <p>
     这是因为这里只有显示器1被重定向！显示器2没有!
    </p>
    <p>
     接下来我们可以尝试这样子进行重定向：
    </p>
    <p class="img-center">
     <img alt="" height="134" src="https://i-blog.csdnimg.cn/direct/214527c0b59b48d9b96a04c87d80c121.png" width="500"/>
    </p>
    <pre><code class="language-bash">./mytest 1&gt;normal.log 2&gt;err.log</code></pre>
    <p>
     实际上是分别对1和2进行了重定向！
    </p>
    <p>
     我们还可以下面这种方式进行写入：
    </p>
    <p class="img-center">
     <img alt="" height="303" src="https://i-blog.csdnimg.cn/direct/efd9bc8d0a114bafa0f573a75ae3b883.png" width="600"/>
    </p>
    <p>
     2&gt;&amp;1（把1号文件描述符对应的内容写入到2号文件描述符当中！）
    </p>
    <p>
     刚开始1已经写入到all.log当中，然后此时对应的内容写入到2当中！（2和1一样！）
    </p>
    <h4>
     <strong>
      <code>
       2&gt;&amp;1
      </code>
      的语法解析（deepseek）
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       <code>
        &gt;
       </code>
      </strong>
      ：表示输出重定向。例如
      <code>
       &gt; file
      </code>
      默认将 stdout（fd=1）重定向到文件。
     </li>
     <li>
      <strong>
       <code>
        2&gt;
       </code>
      </strong>
      ：表示将 stderr（fd=2）重定向到指定目标。
     </li>
     <li>
      <strong>
       <code>
        &amp;1
       </code>
      </strong>
      ：
      <code>
       &amp;
      </code>
      符号表示后面的
      <code>
       1
      </code>
      是文件描述符（而非普通文件名）。
      <code>
       &amp;1
      </code>
      指代当前 stdout 指向的位置。
      <br/>
     </li>
    </ul>
    <h2>
     四、如何理解一下Linux中的一切皆文件？
    </h2>
    <p>
     <img alt="" height="931" src="https://i-blog.csdnimg.cn/direct/bb74c2ba85d143d68fe3c528f61c2ff4.png" width="1614"/>
    </p>
    <p>
     我们从下面往上面看：
    </p>
    <ul>
     <li>
      <strong>
       当前我们的计算机有各种不同的零件，操作系统可以对这些硬件进行描述，即struct_device，在这些结构体中主要包括硬件的输入（read）和输出（write） --- 如果有哪些硬件没有对应的方法，我们可以将其设置为空！；
      </strong>
     </li>
     <li>
      <strong>
       而struct device这一层，实际上就是驱动层！
      </strong>
     </li>
     <li>
      <strong>
       对于已打开的文件，会有一个对应的结构体struct file，而在这个结构体当中，有一个指向操作函数表的指针ops；
      </strong>
     </li>
     <li>
      <strong>
       操作函数表operation_func中包含了一些文件和设备的具体操作，与struct_device对应！
      </strong>
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="149" src="https://i-blog.csdnimg.cn/direct/c51f75f6d376424f8edbc7e18b7fa219.png" width="400"/>
    </p>
    <p>
     <span style="color:#ff9900">
      <strong>
       因此当我们调用read这样的一个系统调用函数的时候，实际上是从task_struct结构体内获取到files的地址，即文件描述符表，根据对应的fd获取到对应数组位置上的指针，通过指针找到对应的struct file，而在struct file这个结构体中包含了调用函数的指针，再通过调用函数的指针ops找到对应驱动的读写方法！
      </strong>
     </span>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34373730323931372f:61727469636c652f64657461696c732f313436313336373131" class_="artid" style="display:none">
 </p>
</div>


