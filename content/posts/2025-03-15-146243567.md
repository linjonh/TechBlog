---
layout: post
title: "沐数科技数据开发岗笔试题2025"
date: 2025-03-15 18:04:08 +0800
description: "与数据库中的主键（Primary Key）​有所不同，业务主键（Business Key）​是业务层面的唯一标识，通常由业务规则决定，例如，订单号、订单明细号，身份证号等。用户授信表（table_credit）：包含用户ID（uid）、授信申请时间（credit_submit_time_local）、授信状态（credit_status）。：在正态分布中，大约68%的数据值落在距离均值一个标准差的范围内，约95%的数据值落在两个标准差的范围内，而约99.7%的数据值落在三个标准差的范围内。"
keywords: "沐数科技数据开发岗笔试题2025"
categories: ['面试']
tags: ['面试', '沐数一下', '数据开发']
artid: "146243567"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146243567
    alt: "沐数科技数据开发岗笔试题2025"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146243567
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146243567
cover: https://bing.ee123.net/img/rand?artid=146243567
image: https://bing.ee123.net/img/rand?artid=146243567
img: https://bing.ee123.net/img/rand?artid=146243567
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     沐数科技数据开发岗笔试题2025
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <span style="color:#ed7976">
      描述性统计
     </span>
    </h3>
    <h4>
     <span style="color:#ed7976">
      标准差
     </span>
    </h4>
    <p>
     <img alt="" height="155" src="https://i-blog.csdnimg.cn/direct/2d52abdc77c94aa2983bf40c7fa2701a.png" width="673"/>
    </p>
    <p>
     答案: A
    </p>
    <p>
     解析:
    </p>
    <p>
     标准差
    </p>
    <p>
     衡量数据集中数值变化或离散程度的一种度量。它反映了数据集中的各个数值与数据集的平均值（均值）之间的偏离程度。
     <strong>
      <span style="color:#ed7976">
       标准差越大，表明数据的分布越分散；标准差越小，表明数据越集中
      </span>
     </strong>
     。
    </p>
    <p>
     <img alt="" height="492" src="https://i-blog.csdnimg.cn/direct/dc0f777030654c94b0435261283f3cd9.png" width="564"/>
    </p>
    <p>
     标准差的取值范围是[0, +∞)
    </p>
    <p>
     标准差是方差的平方根
    </p>
    <p>
     在有限的数据集中，标准差不可能大于数据集中的最大值与最小值之差的一半
    </p>
    <p>
    </p>
    <p>
     均值, 即平均值
    </p>
    <p>
     <span style="color:#ed7976">
      <strong>
       正态分布
      </strong>
     </span>
    </p>
    <p>
     也被称为高斯分布（Gaussian distribution）
    </p>
    <p>
     <strong>
      特征
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        对称性
       </strong>
       ：正态分布曲线关于均值对称，均值所在的垂直线将曲线分为两个镜像部分。
      </p>
     </li>
     <li>
      <p>
       <strong>
        钟形曲线
       </strong>
       ：分布曲线呈现为钟形，均值处达到最高点，向两侧逐渐降低。
      </p>
     </li>
     <li>
      <p>
       <strong>
        均值、中位数和众数相等
       </strong>
       ：在正态分布中，均值（平均值）、中位数（数据中间值）和众数（出现次数最多的值）是相等的。
      </p>
     </li>
     <li>
      <p>
       <strong>
        68-95-99.7规则
       </strong>
       ：在正态分布中，大约68%的数据值落在距离均值一个标准差的范围内，约95%的数据值落在两个标准差的范围内，而约99.7%的数据值落在三个标准差的范围内。
      </p>
     </li>
    </ol>
    <p>
     <img alt="" height="230" src="https://i-blog.csdnimg.cn/direct/0b0de0a7c0ad4151811ed9a2a56cb8a2.png" width="415"/>
    </p>
    <h4>
     <span style="color:#ed7976">
      中位数
     </span>
    </h4>
    <p>
     <img alt="" height="130" src="https://i-blog.csdnimg.cn/direct/ede3af6618eb4b4d93a5530ef4bc06b1.png" width="683"/>
    </p>
    <p>
     答案: B
    </p>
    <p>
     解析:
    </p>
    <p>
     A. 所有数据的平均值,  是所有数据值加起来除以数据个数得到的值。
    </p>
    <p>
     C. 最小值和最大值的平均值, 这通常被称为数据集的中点（Midrange）
    </p>
    <p>
     D. 数据按降序排列后的第一个值, 这个值实际上是数据集的最大值（Maximum）
    </p>
    <h3>
     <span style="color:#ed7976">
      数据探查
     </span>
    </h3>
    <h4>
     <span style="color:#ed7976">
      数据清洗
     </span>
    </h4>
    <p>
     <img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/ac69610adb2047f0915b67646ef4cdde.png" width="648"/>
    </p>
    <p>
     答案: C
    </p>
    <p>
     解析:
    </p>
    <p>
     数据清洗的步骤
    </p>
    <p>
     <strong>
      检查缺失值和异常值&gt;&gt;数据格式化&gt;&gt;数据合并&gt;&gt;生成报告
     </strong>
    </p>
    <p>
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/a77aa762ea834c749e22d81ee80d6f22.png" width="676"/>
    </p>
    <h4>
     <span style="color:#ed7976">
      检查数据分布
     </span>
    </h4>
    <p>
     <img alt="" height="156" src="https://i-blog.csdnimg.cn/direct/f6fb8330609f4d76b494f60fa6197c57.png" width="682"/>
    </p>
    <p>
     答案: B
    </p>
    <p>
     解析:
    </p>
    <p>
     A.
     <strong>
      折线图
     </strong>
     （Line Chart）
    </p>
    <ul>
     <li>
      <p>
       用于展示数据随时间或有序类别变化的趋势。
      </p>
     </li>
     <li>
      <p>
       适合展示连续数据和时间序列数据的变化情况。
      </p>
     </li>
     <li>
      <p>
       可以清晰地显示数据的增减变化和预测未来的趋势。
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="322" src="https://i-blog.csdnimg.cn/direct/8b64904a6d7e47b1896833f360295bc0.png" width="372"/>
    </p>
    <p>
     B.
     <strong>
      直方图
     </strong>
     （Histogram）
    </p>
    <ul>
     <li>
      <p>
       用于展示数据分布的情况。
      </p>
     </li>
     <li>
      <p>
       通过将数据分成若干个区间（bins），展示每个区间内数据的频率或数量。
      </p>
     </li>
     <li>
      <p>
       适合检查数据的分布形态，如是否接近正态分布，以及数据的集中趋势和离散程度。
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="267" src="https://i-blog.csdnimg.cn/direct/b8a6c78ea6b449bd8e01bbf5db0cd588.png" width="356"/>
    </p>
    <p>
     C.
     <strong>
      散点图
     </strong>
     （Scatter Plot）
    </p>
    <ul>
     <li>
      <p>
       用于展示两个变量之间的关系。
      </p>
     </li>
     <li>
      <p>
       通过在二维平面上绘制点，可以观察两个变量之间是否存在相关性。
      </p>
     </li>
     <li>
      <p>
       适合探索变量之间的相关性、趋势和模式。
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="301" src="https://i-blog.csdnimg.cn/direct/8f8f04303e9f4c00be0cb5af7987c1ad.png" width="378"/>
    </p>
    <p>
     D.
     <strong>
      热力图
     </strong>
     （Heatmap）
    </p>
    <ul>
     <li>
      <p>
       用颜色变化来展示矩阵或表格中数据的大小。
      </p>
     </li>
     <li>
      <p>
       适合展示两个类别变量之间的关系，如时间序列数据的周期性变化。
      </p>
     </li>
     <li>
      <p>
       常用于展示数据的密度或强度，如地理热力图、用户行为热力图等。
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="287" src="https://i-blog.csdnimg.cn/direct/ba97798f48e240d2adbe8cc6156c34db.png" width="345"/>
    </p>
    <h4>
     <span style="color:#ed7976">
      主键
     </span>
    </h4>
    <p>
     <img alt="" height="158" src="https://i-blog.csdnimg.cn/direct/7592db00a284446f8142cd6148663007.png" width="681"/>
    </p>
    <p>
     答案: A
    </p>
    <p>
     解析:
    </p>
    <p>
     主键约束: 唯一且非空
    </p>
    <h4>
     <span style="color:#ed7976">
      主键
     </span>
    </h4>
    <p>
     <img alt="" height="196" src="https://i-blog.csdnimg.cn/direct/8e108498996e49ffae683f63c13df03a.png" width="676"/>
    </p>
    <p>
     答案: A
    </p>
    <p>
     解析:
    </p>
    <p>
     A.
    </p>
    <ol>
     <li>
      <p>
       <strong>
        业务逻辑错误
       </strong>
       ：逻辑主键用于确保数据的一致性和准确性。如果主键不唯一，可能会插入重复的记录，导致业务逻辑错误。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据扩散
       </strong>
       ：在数据扩散（Data Replication）过程中，如果主键不唯一，可能会导致数据不一致，因为相同的主键值可能会被复制到多个位置。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据不一致
       </strong>
       ：由于重复的主键值，可能会导致数据更新或删除操作影响到错误的记录，从而造成数据不一致。
      </p>
     </li>
    </ol>
    <p>
     数据扩散（Data Replication）是将数据从一个位置复制到另一个位置的过程，以确保数据的可用性、冗余和容错性
    </p>
    <p>
     <img alt="" height="192" src="https://i-blog.csdnimg.cn/direct/239812853e814d0597775cd819146b04.png" width="678"/>
    </p>
    <p>
     B.  主键不唯一  可能因为重复值导致索引效率降低。
    </p>
    <p>
     C. 主键不唯一，查询操作仍然可以关联到数据，只是可能会关联到多条记录，而不是预期的单条记录。
    </p>
    <p>
     D. 相反，主键的定义就是为了确保唯一性，如果违反了这一约束，数据库通常会报错，需要手动干预来解决重复主键的问题。
    </p>
    <h4>
     <span style="color:#ed7976">
      连续型变量
     </span>
    </h4>
    <p>
     <img alt="" height="143" src="https://i-blog.csdnimg.cn/direct/5b6b2345dc5349489e2c50f3541be97a.png" width="682"/>
    </p>
    <p>
     答案: D
    </p>
    <p>
     解析:
    </p>
    <p>
     <span style="color:#ed7976">
      <strong>
       连续型变量
      </strong>
     </span>
     （Continuous Variable）是指可以在无限或有限的区间内取任意值的变量。
    </p>
    <p>
     <span style="color:#ed7976">
      <strong>
       离散型变量
      </strong>
     </span>
     （Discrete Variable）只能取有限个或可数无限个值，如人数、车辆数、产品数量等
    </p>
    <p>
     <span style="color:#ed7976">
      <strong>
       连续型变量的离群点
      </strong>
     </span>
     （Outliers）是指在数据集中与其他数据点明显不同或者异常的数据点。这些数据点可能比其他数据点要
     <strong>
      远离数据集的中心
     </strong>
     ，或者具
     <strong>
      <span style="color:#ed7976">
       有异常的数值
      </span>
     </strong>
     。离群点可能是由于数据采集错误、异常事件、测量误差或者其他未知因素引起的。离群点的存在可以对数据分析和统计建模产生重要影响，因为它们可能导致模型不准确或者产生误导性的结果。
    </p>
    <p>
     <span style="color:#ed7976">
      <strong>
       数据缺失值
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="175" src="https://i-blog.csdnimg.cn/direct/65a84a140b084ec99497656fdd6eab78.png" width="682"/>
    </p>
    <p>
     答案: B
    </p>
    <p>
     解析:
    </p>
    <p>
     A.
     <span style="color:#ed7976">
      <strong>
       用前一天的数据填充缺失值
      </strong>
     </span>
     ：
    </p>
    <ul>
     <li>
      <p>
       这种方法假设数据
       <strong>
        在短期内是稳定的
       </strong>
       ，前一天的数据可以作为当天数据的合理代理。这种方法简单易行，但可能
       <strong>
        <span style="color:#0d0016">
         不适用于数据波动较大的情况
        </span>
       </strong>
       。
      </p>
     </li>
    </ul>
    <p>
     B.
     <span style="color:#ed7976">
      <strong>
       检查缺失值是否集中在特定的时间段
      </strong>
     </span>
     ：
    </p>
    <ul>
     <li>
      <p>
       通过检查缺失值的分布，可以了解数据缺失是否具有某种模式。例如，如果缺失值集中在特定的时间段，可能表明数据收集过程中存在系统性问题，如设备故障或节假日效应。这种方法有助于识别数据缺失的原因，从而采取更有针对性的处理措施。
      </p>
     </li>
    </ul>
    <p>
     C.
     <span style="color:#ed7976">
      <strong>
       删除所有包含缺失值的日期
      </strong>
     </span>
     ：
    </p>
    <ul>
     <li>
      <p>
       删除包含缺失值的日期可以简化分析，但
       <strong>
        可能会导致信息损失
       </strong>
       ，特别是如果缺失值较多时。这种方法适用于缺失值较少且删除后不会对分析结果产生显著影响的情况。
      </p>
     </li>
    </ul>
    <p>
     D.
     <span style="color:#ed7976">
      <strong>
       插值法填充所有缺失值
      </strong>
     </span>
     ：
    </p>
    <ul>
     <li>
      <p>
       插值法（如线性插值、多项式插值等）通过使用数据集中的其他数据点来
       <strong>
        估计缺失值
       </strong>
       。这种方法可以保留更多的数据信息，但
       <strong>
        插值的准确性依赖于数据的分布和趋势
       </strong>
       。插值可能不适用于缺失值较多或缺失模式不规则的情况。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      线性差值
     </strong>
     : 如果两个已知数据点之间的数据变化是线性的，即在这两个点之间，数据的变化率是恒定的。
    </p>
    <p>
     <img alt="" height="177" src="https://i-blog.csdnimg.cn/direct/68e22086f94340bbaf8326be191a7bea.png" width="667"/>
    </p>
    <p>
     <strong>
      多项式插值
     </strong>
     : 使用一个多项式函数来通过所有已知的数据点。这种方法可以提供比线性插值更复杂的数据模型，适用于数据变化更复杂的情况。
    </p>
    <p>
     <img alt="" height="269" src="https://i-blog.csdnimg.cn/direct/05619d4a4fd0416e8729e7b2494296c1.png" width="681"/>
    </p>
    <p>
     <img alt="" height="141" src="https://i-blog.csdnimg.cn/direct/f64b2f4b65e5422998e2b123aaecee15.png" width="672"/>
    </p>
    <h4>
     <span style="color:#ed7976">
      <strong>
       业务
      </strong>
     </span>
    </h4>
    <p>
     10.实操题
    </p>
    <p>
     销售订单表
    </p>
    <p>
     <img alt="" height="279" src="https://i-blog.csdnimg.cn/direct/03e5f640876e4c69992262f4963a57ce.png" width="683"/>
    </p>
    <p>
     订单明细表
    </p>
    <p>
     <img alt="" height="734" src="https://i-blog.csdnimg.cn/direct/625f8c195a874297bcebfa96ec1ce0be.png" width="620"/>
    </p>
    <p>
     <img alt="" height="480" src="https://i-blog.csdnimg.cn/direct/096095c3b4224723b22d71dd308d75ff.png" width="672"/>
    </p>
    <p>
     【备注】 - ​业务主键（Business Key）​：指在业务逻辑中唯一标识一条记录的字段或字段组合。与数据库中的主键（Primary Key）​有所不同，业务主键（Business Key）​是业务层面的唯一标识，通常由业务规则决定，例如，订单号、订单明细号，身份证号等
    </p>
    <p>
     【问题】 仅基于这份数据，以下哪些说法正确？（多选）
    </p>
    <p>
     A. order 表的业务主键存在空值缺失情况
    </p>
    <p>
     B. order 表的数据时间范围为 从 2009 ~ 2012 年的订单数据
    </p>
    <p>
     C. order_detail 缺少一个明确的业务主键字段，但是存在业务主键字段组合（order_id + product_id）
    </p>
    <p>
     D. 华北区中，订单最多的客户（customer）是 SAVEA，Owner 都是 苏先生，一共有16笔订单
    </p>
    <p>
     E. 一共有77个产品，都有被卖出去；其中单价最高的是 绿茶，其单价为 263.5
    </p>
    <p>
     答案: A, C, D, E
    </p>
    <p>
     解析:
    </p>
    <p>
     B. order 表显示的订单日期从
     <code>
      2010/8/12
     </code>
     开始，一直到
     <code>
      2010/10/8
     </code>
     结束
    </p>
    <h4>
     <span style="color:#ed7976">
      沐数一下
     </span>
    </h4>
    <p>
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/53428e320114414bbe11e24789040b8e.png" width="601"/>
    </p>
    <p>
     答案: B、C、D、G、H
    </p>
    <p>
     解析:
    </p>
    <p>
     选项 A 提供数据存储服务，通常不是探查报告的直接功能，而是数据管理系统或数据库的角色。
    </p>
    <h4>
     <span style="color:#ed7976">
      沐数一下
     </span>
    </h4>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/direct/cfd49cff3d4846c8a30758bf38ff029a.png" width="523"/>
    </p>
    <p>
     答案: B, C, D
    </p>
    <p>
     解析:
    </p>
    <p>
     A 存储数据表的所有数据，通常不是探查报告的直接功能，而是数据库或数据存储系统的角色。
    </p>
    <p>
     E 对数据表中的值进行清洗和标准化，虽然探查报告可能提供一些数据清洗和标准化的指导，但直接进行这些操作通常需要其他工具或过程。
    </p>
    <h4>
     <span style="color:#ed7976">
      沐数一下
     </span>
    </h4>
    <p>
     <img alt="" height="256" src="https://i-blog.csdnimg.cn/direct/a95d4be4f5a34400a869d382294e9c04.png" width="506"/>
    </p>
    <p>
     答案: A, B, C, D, E
    </p>
    <p>
    </p>
    <h3 style="background-color:transparent">
     <span style="color:#ed7976">
      SQL
     </span>
    </h3>
    <p>
     <img alt="" height="224" src="https://i-blog.csdnimg.cn/direct/86b9cbac866741bb919d6f6a2e92e308.png" width="682"/>
    </p>
    <p>
     解析实操题:
    </p>
    <pre><code>SELECT 
    s.country,
    p.product_id,
    p.product_name,
    SUM(s.amount) AS total_sales
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
WHERE 
    s.country IN ('法国', '英国')
    AND s.sale_date BETWEEN '2020-09-01' AND '2020-09-30'
GROUP BY 
    s.country,
    p.product_id,
    p.product_name
ORDER BY 
    s.country,
    p.product_id;</code></pre>
    <p>
     输出示例
    </p>
    <p>
     <img alt="" height="433" src="https://i-blog.csdnimg.cn/direct/5b71124863d14b3dacf0c02963e728d3.png" width="493"/>
    </p>
    <p>
     解析填空题
    </p>
    <pre><code>SELECT 
    p.product_name,
    ROUND(SUM(s.amount), 0) AS total_sales
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
WHERE 
    s.country = '英国'
    AND s.sale_date BETWEEN '2020-09-01' AND '2020-09-30'
GROUP BY 
    p.product_name
ORDER BY 
    total_sales DESC
FETCH FIRST 1 ROW ONLY;</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="187" src="https://i-blog.csdnimg.cn/direct/e3d6ba47566b405db056fe4fdd16aec3.png" width="679"/>
    </p>
    <p>
     解析:
    </p>
    <p>
     实操题
    </p>
    <pre><code>SELECT 
    s.country,
    SUM(s.amount) AS total_sales,
    CASE 
        WHEN SUM(s.amount) &gt; 10000 THEN '合格'
        ELSE '不合格'
    END AS performance
FROM 
    sales s
GROUP BY 
    s.country
ORDER BY 
    s.country;</code></pre>
    <p>
     填空题
    </p>
    <pre><code>SELECT 
    s.country,
    ROUND(SUM(s.amount), 0) AS total_sales
FROM 
    sales s
GROUP BY 
    s.country
ORDER BY 
    total_sales DESC
FETCH FIRST 1 ROW ONLY;</code></pre>
    <p>
     <img alt="" height="204" src="https://i-blog.csdnimg.cn/direct/ebb70b8152f74cbf9cfe72d85d67ca10.png" width="680"/>
    </p>
    <p>
     解析:
    </p>
    <p>
     <strong>
      实操题
     </strong>
    </p>
    <pre><code>SELECT
    p.product_name AS "产品名称",
    SUM(s.sales_amount) AS "销售金额",
    ROUND(SUM(s.sales_amount) / total_sales.total_amount * 100, 2) AS "占比"
FROM
    sales s
JOIN
    products p ON s.product_id = p.product_id
CROSS JOIN
    (SELECT SUM(sales_amount) AS total_amount FROM sales) total_sales
GROUP BY
    p.product_name, total_sales.total_amount
HAVING
    ROUND(SUM(s.sales_amount) / total_sales.total_amount * 100, 2) &gt;= 10
ORDER BY
    "占比" DESC;</code></pre>
    <p>
     <code>
      CROSS JOIN
     </code>
     的作用是将
     <code>
      sales
     </code>
     表中的每一行与
     <code>
      total_sales
     </code>
     子查询的结果（即总销售金额）进行笛卡尔积连接。这意味着每一行
     <code>
      sales
     </code>
     数据都会与
     <code>
      total_sales
     </code>
     中的总金额进行组合，从而使得每一行都可以访问总销售金额。
    </p>
    <p>
     <strong>
      填空题
     </strong>
    </p>
    <pre><code>WITH ProductSales AS (
    SELECT
        p.product_name,
        SUM(s.sales_amount) AS total_sales_amount,
        ROUND(SUM(s.sales_amount) / total_sales.total_amount * 100, 2) AS sales_percentage
    FROM
        sales s
    JOIN
        products p ON s.product_id = p.product_id
    CROSS JOIN
        (SELECT SUM(sales_amount) AS total_amount FROM sales) total_sales
    GROUP BY
        p.product_name, total_sales.total_amount
    HAVING
        ROUND(SUM(s.sales_amount) / total_sales.total_amount * 100, 2) &gt;= 10
),
RankedProducts AS (
    SELECT
        sales_percentage,
        DENSE_RANK() OVER (ORDER BY sales_percentage DESC) AS rank
    FROM
        ProductSales
)
SELECT
    COUNT(*) AS product_count,
    MAX(CASE WHEN rank = 3 THEN sales_percentage END) AS third_largest_percentage
FROM
    RankedProducts;</code></pre>
    <p>
     <img alt="" height="125" src="https://i-blog.csdnimg.cn/direct/8cae3fb762c54c5899a3731bcd6f2301.png" width="675"/>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="265" src="https://i-blog.csdnimg.cn/direct/149dbf4ae2504fdfb4c80050b30cadab.png" width="679"/>
    </p>
    <p>
     解析:
    </p>
    <p>
     实操题
    </p>
    <pre><code>SELECT 
    CASE 
        WHEN age &lt; 25 THEN '25岁以下'
        WHEN age &gt;= 25 AND age &lt; 30 THEN '25-30岁'
        WHEN age &gt;= 30 AND age &lt; 35 THEN '30-35岁'
        WHEN age &gt;= 35 AND age &lt; 40 THEN '35-40岁'
        WHEN age &gt;= 40 AND age &lt; 45 THEN '40-45岁'
        WHEN age &gt;= 45 AND age &lt; 50 THEN '45-50岁'
        WHEN age &gt;= 50 AND age &lt; 55 THEN '50-55岁'
        WHEN age &gt;= 55 THEN '55岁及以上'
        ELSE '异常情况'
    END AS age_group,
    COUNT(*) AS num_employees
FROM employees
WHERE age IS NOT NULL AND age &gt; 0
GROUP BY 
    CASE 
        WHEN age &lt; 25 THEN '25岁以下'
        WHEN age &gt;= 25 AND age &lt; 30 THEN '25-30岁'
        WHEN age &gt;= 30 AND age &lt; 35 THEN '30-35岁'
        WHEN age &gt;= 35 AND age &lt; 40 THEN '35-40岁'
        WHEN age &gt;= 40 AND age &lt; 45 THEN '40-45岁'
        WHEN age &gt;= 45 AND age &lt; 50 THEN '45-50岁'
        WHEN age &gt;= 50 AND age &lt; 55 THEN '50-55岁'
        WHEN age &gt;= 55 THEN '55岁及以上'
        ELSE '异常情况'
    END
ORDER BY 
    CASE 
        WHEN age_group = '25岁以下' THEN 1
        WHEN age_group = '25-30岁' THEN 2
        WHEN age_group = '30-35岁' THEN 3
        WHEN age_group = '35-40岁' THEN 4
        WHEN age_group = '40-45岁' THEN 5
        WHEN age_group = '45-50岁' THEN 6
        WHEN age_group = '50-55岁' THEN 7
        WHEN age_group = '55岁及以上' THEN 8
        ELSE 9
    END;</code></pre>
    <p>
     填空题
    </p>
    <pre><code>WITH AgeDistribution AS (
    SELECT 
        CASE 
            WHEN age &lt; 25 THEN '25岁以下'
            WHEN age &gt;= 25 AND age &lt; 30 THEN '25-30岁'
            WHEN age &gt;= 30 AND age &lt; 35 THEN '30-35岁'
            WHEN age &gt;= 35 AND age &lt; 40 THEN '35-40岁'
            WHEN age &gt;= 40 AND age &lt; 45 THEN '40-45岁'
            WHEN age &gt;= 45 AND age &lt; 50 THEN '45-50岁'
            WHEN age &gt;= 50 AND age &lt; 55 THEN '50-55岁'
            WHEN age &gt;= 55 THEN '55岁及以上'
            ELSE '异常情况'
        END AS age_group,
        COUNT(*) AS num_employees
    FROM employees
    WHERE age IS NOT NULL AND age &gt; 0
    GROUP BY 
        CASE 
            WHEN age &lt; 25 THEN '25岁以下'
            WHEN age &gt;= 25 AND age &lt; 30 THEN '25-30岁'
            WHEN age &gt;= 30 AND age &lt; 35 THEN '30-35岁'
            WHEN age &gt;= 35 AND age &lt; 40 THEN '35-40岁'
            WHEN age &gt;= 40 AND age &lt; 45 THEN '40-45岁'
            WHEN age &gt;= 45 AND age &lt; 50 THEN '45-50岁'
            WHEN age &gt;= 50 AND age &lt; 55 THEN '50-55岁'
            WHEN age &gt;= 55 THEN '55岁及以上'
            ELSE '异常情况'
        END
),
Ranking AS (
    SELECT age_group, num_employees,
           RANK() OVER (ORDER BY num_employees DESC) AS rank
    FROM AgeDistribution
)
SELECT 
    age_group,
    num_employees
FROM Ranking
WHERE rank = 2;

SELECT COUNT(*) AS num异常
FROM employees
WHERE age IS NULL OR age &lt;= 0;</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="195" src="https://i-blog.csdnimg.cn/direct/baa0b79d1e7e4dea95b34e65664ea156.png" width="681"/>
    </p>
    <pre><code>SELECT 
    reason,
    COUNT(*) AS num_people,
    RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking
FROM new_hires
GROUP BY reason
ORDER BY ranking;</code></pre>
    <p>
     填空题
    </p>
    <pre><code>SELECT reason, COUNT(*) AS num_people
FROM new_hires
GROUP BY reason
ORDER BY COUNT(*) DESC
FETCH FIRST 1 ROW ONLY OFFSET 3 ROWS;</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="182" src="https://i-blog.csdnimg.cn/direct/a16d0611381c421bb83906d22335fcad.png" width="682"/>
    </p>
    <p>
     解析:
    </p>
    <p>
     实操题
    </p>
    <pre><code>SELECT
    YEAR(resignation_date) AS resignation_year,
    COUNT(employee_id) AS num_resignations,
    SUM(COUNT(employee_id)) OVER (ORDER BY YEAR(resignation_date)) AS cumulative_resignations
FROM employee_resignations
GROUP BY YEAR(resignation_date)
ORDER BY resignation_year;</code></pre>
    <p>
     窗口函数
     <code>
      SUM(...) OVER (...)
     </code>
     的行为。它不是在对整个结果集进行求和，而是在对结果集的每个分组（由
     <code>
      GROUP BY
     </code>
     定义）进行求和。
    </p>
    <p>
     <code>
      OVER (ORDER BY YEAR(resignation_date))
     </code>
     定义了窗口函数的操作范围，即按照
     <code>
      resignation_date
     </code>
     的年份进行排序
    </p>
    <p>
     填空题
    </p>
    <pre><code>WITH ResignationStats AS (
    SELECT
        YEAR(resignation_date) AS resignation_year,
        COUNT(employee_id) AS num_resignations,
        SUM(COUNT(employee_id)) OVER (ORDER BY YEAR(resignation_date)) AS cumulative_resignations
    FROM employee_resignations
    GROUP BY YEAR(resignation_date)
)
SELECT 
    resignation_year,
    num_resignations
FROM ResignationStats
WHERE cumulative_resignations &gt; 100
ORDER BY resignation_year
FETCH FIRST 1 ROW ONLY;</code></pre>
    <p>
     <img alt="" height="221" src="https://i-blog.csdnimg.cn/direct/1840b64d122d46a7b2d914b66094890c.png" width="674"/>
    </p>
    <p>
     解析:
    </p>
    <p>
     实操题
    </p>
    <pre><code>SELECT 
    AVG(CASE WHEN class = 'Class1' THEN score ELSE NULL END) AS class1_avg,
    AVG(CASE WHEN class = 'Class2' THEN score ELSE NULL END) AS class2_avg,
    AVG(CASE WHEN class = 'Class1' THEN score ELSE NULL END) 
    - AVG(CASE WHEN class = 'Class2' THEN score ELSE NULL END) AS difference
FROM 
    scores
WHERE 
    course = 'data_visualization';</code></pre>
    <p>
     填空题
    </p>
    <pre><code>SELECT 
    ROUND(AVG(CASE WHEN class = 'Class1' THEN score ELSE NULL END) 
    - AVG(CASE WHEN class = 'Class2' THEN score ELSE NULL END), 2) AS difference
FROM 
    scores
WHERE 
    course = 'data_visualization';</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="165" src="https://i-blog.csdnimg.cn/direct/7e5f56e201f149f4b69399a08852e876.png" width="670"/>
    </p>
    <p>
     解析:
    </p>
    <p>
     实操题
    </p>
    <p>
     Oracle 12c及更高版本支持
     <code>
      FILTER
     </code>
     子句, 用于在聚合函数中过滤数据
    </p>
    <pre><code>SELECT 
    class,
    AVG(score) OVER (PARTITION BY class) AS avg_score,
    COUNT(*) FILTER (WHERE score &lt; AVG(score) OVER (PARTITION BY class)) 
    AS below_avg_count
FROM 
    scores
WHERE 
    course = 'sql'
GROUP BY 
    class;</code></pre>
    <p>
     Oracle 12c版本以下&gt;&gt;使用子查询和
     <code>
      CASE
     </code>
     语句来实现相同的功能
    </p>
    <pre><code>SELECT 
    class,
    AVG(score) AS avg_score,
    (SELECT COUNT(*) FROM scores s2 WHERE s2.class = s.class 
    AND s2.score &lt; s.avg_score) AS below_avg_count
FROM 
    scores s
WHERE 
    s.course = 'sql'
GROUP BY 
    class;</code></pre>
    <p>
     子查询中的
     <code>
      s2.class = s.class
     </code>
     确保了子查询只考虑与外部查询中当前处理的班级相同的记录。换句话说，对于每个班级，子查询都会计算该班级中成绩低于班级平均分的学生人数。
    </p>
    <p>
     填空题
    </p>
    <pre><code>SELECT 
    class,
    AVG(score) AS avg_score,
    COUNT(*) FILTER (WHERE score &lt; AVG(score) OVER (PARTITION BY class)) 
    AS below_avg_count
FROM 
    scores
WHERE 
    course = 'sql'
GROUP BY 
    class
ORDER BY 
    avg_score ASC
FETCH FIRST 1 ROW ONLY;</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="263" src="https://i-blog.csdnimg.cn/direct/aa22193b545d4f88b1c5ef4b8d71d963.png" width="678"/>
    </p>
    <p>
     解析
    </p>
    <p>
     实操题思路
    </p>
    <p>
     使用两个CTE表达式&gt;&gt;计算出每月销售额; 计算去年同月的销售额, 计算上个月的销售额
    </p>
    <p>
     主查询&gt;&gt;计算同比增长率, 环比增长率, 提取需要的字段
    </p>
    <p>
     <strong>
      数据范围
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       确保
       <code>
        sales_data
       </code>
       表中包含2019年和2020年的数据，否则同比计算可能不准确
      </p>
     </li>
    </ul>
    <pre><code>WITH MonthlySales AS (
    -- 假设原始数据表为 sales_data, 包含 sale_date 和 amount 字段
    SELECT
        TO_CHAR(sale_date, 'YYYY') AS sale_year,
        TO_CHAR(sale_date, 'MM') AS sale_month,
        SUM(amount) AS total_sales
    FROM sales_data
    WHERE sale_date &gt;= TO_DATE('2019-01-01', 'YYYY-MM-DD')  -- 包含2019年数据
      AND sale_date &lt; TO_DATE('2021-01-01', 'YYYY-MM-DD')   -- 包含2020年数据
    GROUP BY TO_CHAR(sale_date, 'YYYY'), TO_CHAR(sale_date, 'MM')
),
CTE AS (
    SELECT
        sale_year,
        sale_month,
        total_sales,
        LAG(total_sales, 12) OVER (ORDER BY sale_year, sale_month) AS prev_year_sales, 
        -- 去年同月销售额
        LAG(total_sales, 1) OVER (ORDER BY sale_year, sale_month) AS prev_month_sales  
        -- 上月销售额
    FROM MonthlySales
)
SELECT
    sale_year AS 年份,
    sale_month AS 月份,
    total_sales AS 销售额,
    -- 计算同比增长率
    CASE
        WHEN prev_year_sales IS NOT NULL AND prev_year_sales &lt;&gt; 0 THEN
            (total_sales - prev_year_sales) / prev_year_sales
        ELSE
            NULL
    END AS 同比,
    -- 计算环比增长率
    CASE
        WHEN prev_month_sales IS NOT NULL AND prev_month_sales &lt;&gt; 0 THEN
            (total_sales - prev_month_sales) / prev_month_sales
        ELSE
            NULL
    END AS 环比
FROM CTE
WHERE sale_year = '2020'  -- 只输出2020年的结果
ORDER BY sale_year, sale_month;</code></pre>
    <p>
     填空题
    </p>
    <p>
     在主查询的where过滤条件增加月份的过滤, 注意格式&gt;&gt;round, to_char(number, format)
    </p>
    <pre><code>WITH MonthlySales AS (
    -- 假设原始数据表为 sales_data, 包含 sale_date 和 amount 字段
    SELECT
        TO_CHAR(sale_date, 'YYYY') AS sale_year,
        TO_CHAR(sale_date, 'MM') AS sale_month,
        SUM(amount) AS total_sales
    FROM sales_data
    WHERE sale_date &gt;= TO_DATE('2019-01-01', 'YYYY-MM-DD')  -- 包含2019年数据
      AND sale_date &lt; TO_DATE('2021-01-01', 'YYYY-MM-DD')   -- 包含2020年数据
    GROUP BY TO_CHAR(sale_date, 'YYYY'), TO_CHAR(sale_date, 'MM')
),
CTE AS (
    SELECT
        sale_year,
        sale_month,
        total_sales,
        LAG(total_sales, 12) OVER (ORDER BY sale_year, sale_month) AS prev_year_sales, 
        -- 去年同月销售额
        LAG(total_sales, 1) OVER (ORDER BY sale_year, sale_month) AS prev_month_sales  
        -- 上月销售额
    FROM MonthlySales
)
SELECT
    ROUND(total_sales) AS 销售额,  -- 四舍五入到整数
    TO_CHAR(
        CASE
            WHEN prev_year_sales IS NOT NULL AND prev_year_sales &lt;&gt; 0 THEN
                (total_sales - prev_year_sales) / prev_year_sales * 100
            ELSE
                NULL
        END, '999.99') || '%' AS 同比,  -- 同比增长率，保留2位小数百分比
    TO_CHAR(
        CASE
            WHEN prev_month_sales IS NOT NULL AND prev_month_sales &lt;&gt; 0 THEN
                (total_sales - prev_month_sales) / prev_month_sales * 100
            ELSE
                NULL
        END, '999.99') || '%' AS 环比  -- 环比增长率，保留2位小数百分比
FROM CTE
WHERE sale_year = '2020' AND sale_month = '09';  -- 只查询2020年9月的数据</code></pre>
    <p>
     <img alt="" height="448" src="https://i-blog.csdnimg.cn/direct/3de0fa16f52a438d941ecf0ea2290023.png" width="609"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="436" src="https://i-blog.csdnimg.cn/direct/196341d56cef4a9ba139468921dddb5b.png" width="679"/>
    </p>
    <p>
     解析
    </p>
    <p>
     实操题
    </p>
    <pre><code>WITH RankedResults AS (
    SELECT
        employee_id,
        employee_name,
        statistics,
        sql_score,
        python,
        data_visualization,
        mathematics,
        exam_date,
        (statistics + sql_score + python + data_visualization + mathematics) 
        AS total_score,
        CASE
            WHEN statistics &gt;= 60 AND sql_score &gt;= 60 AND python &gt;= 60 
                AND data_visualization &gt;= 60 AND total_score &gt;= 300 THEN 'pass'
            ELSE 'fail'
        END AS final_result,
        ROW_NUMBER() OVER (PARTITION BY employee_id, final_result 
                            ORDER BY total_score DESC) AS rn
    FROM exam_results
)
SELECT
    employee_id AS 员工ID,
    employee_name AS 人员姓名,
    statistics AS statistics得分,
    sql_score AS SQL得分,
    python AS python得分,
    data_visualization AS data_visualization得分,
    mathematics AS mathematics得分,
    total_score AS 总分,
    exam_date AS 考核时间,
    final_result AS 最终考核结果
FROM RankedResults
WHERE rn = 1  -- 取每个员工通过或未通过中总分最高的记录
ORDER BY employee_id;</code></pre>
    <p>
     <img alt="" height="233" src="https://i-blog.csdnimg.cn/direct/d29eadcd42c149c38837b7cbf85e1654.png" width="652"/>
    </p>
    <p>
     <img alt="" height="198" src="https://i-blog.csdnimg.cn/direct/e0602ad84069496d9267cefdf43bfc9d.png" width="673"/>
    </p>
    <p>
     填空题
    </p>
    <p>
     <img alt="" height="454" src="https://i-blog.csdnimg.cn/direct/9c040a2dc7024dc781e2c358bee6d4a6.png" width="503"/>
    </p>
    <p>
     <img alt="" height="271" src="https://i-blog.csdnimg.cn/direct/904254d859674f0f9a4f36b78023f7a8.png" width="674"/>
    </p>
    <p>
     <img alt="" height="421" src="https://i-blog.csdnimg.cn/direct/d6e460faa86f4b7d9fd7b1fc934711ed.png" width="472"/>
    </p>
    <p>
     <img alt="" height="598" src="https://i-blog.csdnimg.cn/direct/b71bc1c9001e417f9ebcb3d0f0a5d376.png" width="676"/>
    </p>
    <p>
     <img alt="" height="444" src="https://i-blog.csdnimg.cn/direct/641eefce60f34908ad111a72e9000ad2.png" width="471"/>
    </p>
    <p>
     解析
    </p>
    <p>
     实操题
    </p>
    <pre><code>SELECT 
    ec.COUNTRY AS 国家,
    ep.PRODUCTID AS 产品ID,
    ep.PRODUCTNAME AS 产品名称,
    SUM(ep.PRICE * eo.SALE_AMOUNT) AS 销售金额
FROM 
    e_product ep
LEFT JOIN e_order eo ON ep.PRODUCTID = eo.PRODUCTID
LEFT JOIN e_customer ec ON eo.CUSTOMID = ec.CUSTOMID
WHERE 
    SUBSTR(eo.ZTIME, 1, 7) = '2020-09'
    AND ec.COUNTRY IN ('法国', '英国')
GROUP BY 
    ec.COUNTRY, ep.PRODUCTID, ep.PRODUCTNAME
ORDER BY 
    ec.COUNTRY, ep.PRODUCTID;</code></pre>
    <p>
     填空题
    </p>
    <pre><code>SELECT 
    ep.PRODUCTNAME AS 产品名称,
    ROUND(SUM(ep.PRICE * eo.SALE_AMOUNT)) AS 销售金额
FROM 
    e_customer ec
JOIN e_order eo ON ec.CUSTOMID = eo.CUSTOMID
JOIN e_product ep ON eo.PRODUCTID = ep.PRODUCTID
WHERE 
    ec.COUNTRY = '英国'
    AND TO_CHAR(eo.ZTIME, 'YYYY-MM') = '2020-09'
GROUP BY 
    ep.PRODUCTNAME
ORDER BY 
    SUM(ep.PRICE * eo.SALE_AMOUNT) DESC
FETCH FIRST 1 ROW ONLY;</code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="353" src="https://i-blog.csdnimg.cn/direct/2aa51ada1c7b45fe84c789bfabb12b4e.png" width="406"/>
    </p>
    <pre><code>SELECT 
    DATE(t1.register_time_bj) AS stat_date,  -- 将登录时间转换为日期格式，作为统计日期
    t1.channel,  -- 用户登录的渠道
    COUNT(DISTINCT CASE 
        WHEN t2.credit_submit_time_local BETWEEN t1.register_time_bj AND DATE_ADD(t1.register_time_bj, INTERVAL 3 DAY) 
        THEN t1.uid 
    END) AS credit_submit_cnt,  -- 计算在用户登录后3天内提交授信申请的用户数量
    COUNT(DISTINCT CASE 
        WHEN t2.credit_submit_time_local BETWEEN t1.register_time_bj AND DATE_ADD(t1.register_time_bj, INTERVAL 3 DAY) 
        AND t2.credit_status = 'success' 
        THEN t1.uid 
    END) AS credit_succ_cnt  -- 计算在用户登录后3天内成功授信的用户数量
FROM 
    table_register t1
LEFT JOIN 
    table_credit t2 ON t1.uid = t2.uid  -- 通过用户ID连接两个表
WHERE 
    DATE(t1.register_time_bj) &gt;= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)  -- 筛选最近一个月的数据
GROUP BY 
    DATE(t1.register_time_bj), t1.channel  -- 按日期和渠道聚合
ORDER BY 
    stat_date, t1.channel;  -- 按日期和渠道排序</code></pre>
    <p>
     . 确定数据来源和字段
     <br/>
     用户登录表（table_register）：包含用户ID（uid）、登录时间（register_time_bj）、渠道（channel）。
     <br/>
     用户授信表（table_credit）：包含用户ID（uid）、授信申请时间（credit_submit_time_local）、授信状态（credit_status）。
     <br/>
     2. 确定时间范围
     <br/>
     使用DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)来获取当前日期前一个月的日期，确保只统计最近一个月的数据。
     <br/>
     3. 连接两个表
     <br/>
     使用LEFT JOIN连接table_register和table_credit表，通过uid字段连接。这样可以确保即使某些用户没有授信记录，也能在结果中显示他们的登录信息。
     <br/>
     4. 筛选符合条件的记录
     <br/>
     使用WHERE子句筛选出登录时间在最近一个月内的记录。
     <br/>
     5. 计算授信申请和成功授信的用户数量
     <br/>
     使用COUNT(DISTINCT CASE WHEN ... THEN ... END)结构来计算：
     <br/>
     授信申请用户数量（credit_submit_cnt）：计算在用户登录后3天内提交授信申请的用户数量。
     <br/>
     成功授信用户数量（credit_succ_cnt）：计算在用户登录后3天内成功授信的用户数量。
     <br/>
     6. 聚合和排序结果
     <br/>
     使用GROUP BY子句按日期和渠道对结果进行聚合。
     <br/>
     使用ORDER BY子句按日期和渠道对结果进行排序。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34303132313236342f:61727469636c652f64657461696c732f313436323433353637" class_="artid" style="display:none">
 </p>
</div>


