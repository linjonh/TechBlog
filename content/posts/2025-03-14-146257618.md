---
layout: post
title: "C11多线程,锁与条件变量"
date: 2025-03-14 17:49:05 +0800
description: "C++11多线程，条件变量，互斥锁的学习笔记"
keywords: "C++11多线程，锁与条件变量"
categories: ['C']
tags: ['条件变量', '多线程', '互斥锁', 'Java', 'C', 'C']
artid: "146257618"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257618
    alt: "C11多线程,锁与条件变量"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257618
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257618
cover: https://bing.ee123.net/img/rand?artid=146257618
image: https://bing.ee123.net/img/rand?artid=146257618
img: https://bing.ee123.net/img/rand?artid=146257618
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++11多线程，锁与条件变量
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <div align="center">
     <img src="https://i-blog.csdnimg.cn/direct/d4babccb42bb4596928b030de7371f48.jpeg#pic_center" width="100">
     </img>
    </div>
    <center>
     <strong>
      <font color="red">
       🍑个人主页：Jupiter.
      </font>
     </strong>
    </center>
    <center>
     <strong>
      <font color="red">
       🚀 所属专栏：C++学习笔记
      </font>
     </strong>
    </center>
    <center>
     <strong>
      <font color="gren">
       欢迎大家点赞收藏评论😊
      </font>
     </strong>
    </center>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1be8fa655d014659ab7b34b4e1695c5a.gif#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6d40a7ef5b4049b584d8f33e81c9da06.jpeg#pic_center"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_15">
     </a>
     <code>
      线程库
     </code>
    </h2>
    <h3>
     <a id="1_thread_18">
     </a>
     <code>
      1. thread类的简单介绍
     </code>
    </h3>
    <p>
     <a href="https://legacy.cplusplus.com/reference/thread/thread/?kw=thread" rel="nofollow">
      官方文档链接
     </a>
    </p>
    <h4>
     <a id="11constructor_22">
     </a>
     1.1constructor构造函数
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/06fa7d5dd1cd44dab906059ec9efb3e2.png"/>
    </p>
    <ol>
     <li>
      <code>
       thread类是防拷贝的，不允许拷贝构造以及赋值，但是可以移动构造和移动赋值，即将一个 线程对象关联线程的状态转移给其他线程对象，转移期间不意向线程的执行。
      </code>
     </li>
     <li>
      当创建一个线程对象后，没有提供线程函数，该对象实际没有对应任何线程。
     </li>
    </ol>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 std<span class="token double-colon punctuation">::</span>thread t1<span class="token punctuation">;</span>
 cout <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="3">
     <li>
      当创建一个线程对象后，并且给线程关联线程函数，该线程就被启动，与主线程一起运行。
      <br/>
      线程函数一般情况下可按照以下三种方式提供：
     </li>
    </ol>
    <ul>
     <li>
      函数指针
     </li>
     <li>
      lambda表达式
     </li>
     <li>
      函数对象
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">ThreadFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread1"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TF</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread3"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 线程函数为函数指针</span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>ThreadFunc<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 线程函数为lambda表达式</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 线程函数为函数对象</span>
	TF tf<span class="token punctuation">;</span>
	thread <span class="token function">t3</span><span class="token punctuation">(</span>tf<span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="4">
     <li>
      可以通过jionable()函数判断线程是否是有效的，如果是以下任意情况，则线程无效
     </li>
    </ol>
    <ul>
     <li>
      采用无参构造函数构造的线程对象
     </li>
     <li>
      线程对象的状态已经转移给其他线程对象
     </li>
     <li>
      线程已经调用jion或者detach结束
     </li>
    </ul>
    <p>
     <em>
      <strong>
       面试题：并发与并行的区别？
      </strong>
     </em>
    </p>
    <ul>
     <li>
      并发：并发是指两个或多个事件在同一时间间隔内发生，但并不意味着在同一时间点同时运行。在并发处理中，任务被分配到不同的时间点由处理器进行处理，宏观上看起来像是同时处理多个任务，但实际上在微观层面，CPU是在多个线程之间快速交替执行的。
     </li>
     <li>
      并行：并行则是指两个或多个事件在同一时刻发生，即在同一时间点任务一定是同时运行的。在并行处理中，每个任务被分配给不同的处理器独立完成，多个处理器可以同时处理多个线程任务。
     </li>
    </ul>
    <h4>
     <a id="12__90">
     </a>
     <code>
      1.2 线程函数参数
     </code>
    </h4>
    <p>
     线程函数的参数是以
     <code>
      值拷贝
     </code>
     的方式拷贝到
     <code>
      线程栈空间
     </code>
     中的，因此：即使线程参数为引用类型，在线程中修改后也不能修改外部实参，因为其实际引用的是线程栈中的拷贝，而不是外部实参。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f12abfd3904d42e1b137d43ffe12268d.png"/>
    </p>
    <p>
     解决方法：
    </p>
    <ol>
     <li>
      将x与mtx的地址传过去，用指针接收；
     </li>
     <li>
      第二种解决方案，用c++11提供的ref
     </li>
    </ol>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">ThreadFunc1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	x <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">ThreadFunc2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">*</span>x <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token comment">// 在线程函数中对a修改，不会影响外部实参，因为：线程函数参数虽然是引用方式，但其实际</span>
	<span class="token comment">//引用的是线程栈中的拷贝</span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>ThreadFunc1<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//会报错</span>
	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	
	<span class="token comment">// 如果想要通过形参改变外部实参时，必须借助std::ref()函数</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>ThreadFunc1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	
	<span class="token comment">// 地址的拷贝</span>
	thread <span class="token function">t3</span><span class="token punctuation">(</span>ThreadFunc2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     当传入的是
     <code>
      ref(x)
     </code>
     与ref(mtx)的时候，在pthread_create接收参数的时候，实际上推导出来是接受到的是实参的引用，中间就没有产生拷贝，所以解决了问题。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/27eb8afe24cb47a994b15061d354b761.png#pic_center"/>
    </p>
    <ul>
     <li>
      如果想要通过形参改变外部实参时，必须借助
      <code>
       std::ref()函数
      </code>
     </li>
     <li>
      <code>
       注意
      </code>
      ：如果是类成员函数作为线程参数时，必须将this作为线程函数参数。
     </li>
    </ul>
    <h4>
     <a id="2_atomic_139">
     </a>
     <code>
      2. 原子性操作库(atomic)
     </code>
    </h4>
    <p>
     多线程最主要的问题是共享数据带来的问题(即线程安全)。如果共享数据都是只读的，那么没问题，因为只读操作不会影响到数据，更不会涉及对数据的修改，所以所有线程都会获得同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多潜在的麻烦。比如：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//全局变量   共享资源</span>

<span class="token comment">//不加锁是存在线程安全的问题</span>
<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		x<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">//对共享资源进行修改</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     C++98中传统的解决方式：可以对共享修改的数据可以加锁保护。
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//加锁</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		x<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//解锁</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     虽然加锁可以解决，但是加锁有一个
     <code>
      缺陷
     </code>
     就是：只要一个线程在对sum++时，其他线程就会被阻塞，会影响程序运行的效率，而且锁如果控制不好，还容易造成死锁。
    </p>
    <p>
     因此C++11中引入了原子操作。所谓原子操作：即不可被中断的一个或一系列操作，C++11引入的原子操作类型，使得线程间数据的同步变得非常高效。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b0c34d4b538a4460af8329a6253470bb.png#pic_center">
      <br/>
      注意：需要使用以上原子操作变量时，必须添加头文件
      <code>
       #include &lt;atomic&gt;
      </code>
     </img>
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">inlcude</span><span class="token expression"><span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;atomic&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		x<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在C++11中，程序员不需要对原子类型变量进行加锁解锁操作，线程能够对原子类型变量互斥的访问。更为普遍的，程序员可以使用atomic类模板，定义出需要的任意原子类型。
    </p>
    <pre><code class="prism language-cpp">atmoic<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> t<span class="token punctuation">;</span>    <span class="token comment">// 声明一个类型为T的原子类型变量t</span>
</code></pre>
    <p>
     注意：原子类型通常属于"资源型"数据，多个线程只能访问单个原子类型的拷贝，因此在C++11中，原子类型只能从其模板参数中进行构造，
     <code>
      不允许原子类型进行拷贝构造、移动构造以及operator=等，为了防止意外，标准库已经将atmoic模板类中的拷贝构造、移动构造、赋值运算符重载默认删除掉了。
     </code>
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">a1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//atomic&lt;int&gt; a2(a1);   // 编译失败</span>
 atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//a2 = a1;               // 编译失败</span>
 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="3_lock_guardunique_lock_246">
     </a>
     <code>
      3. lock_guard与unique_lock
     </code>
    </h4>
    <p>
     在多线程环境下，如果想要保证某个变量的安全性，只要将其设置成对应的原子类型即可，即高效又不容易出现死锁问题。但是有些情况下，我们可能需要保证一段代码的安全性，那么就只能通过锁的方式来进行控制。
    </p>
    <p>
     锁控制不好时，可能会造成死锁，最常见的比如在锁中间代码返回，或者在锁的范围内抛异常。因此：C++11采用
     <code>
      RAII
     </code>
     的方式对锁进行了封装，即
     <code>
      lock_guard
     </code>
     和
     <code>
      unique_lock
     </code>
     。
    </p>
    <h4>
     <a id="31_mutex_253">
     </a>
     <code>
      3.1 mutex的种类
     </code>
    </h4>
    <p>
     在C++11中，Mutex总共包了四个互斥量的种类：
    </p>
    <ol>
     <li>
      <strong>
       std::mutex
      </strong>
      <br/>
      C++11提供的最基本的互斥量，该类的对象之间不能拷贝，也不能进行移动。mutex最常用的三个函数：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1ca9d963752e40e39b9c8f2144dedeae.png">
       <br/>
       注意，线程函数调用lock()时，可能会发生以下三种情况：
      </img>
     </li>
    </ol>
    <ul>
     <li>
      如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁
     </li>
     <li>
      如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住
     </li>
     <li>
      如果当前互斥量被当前调用线程 再次 锁住（这在大多数互斥量实现中是不可能的，因为标准互斥量不允许同一个线程多次锁定），则确实可能产生死锁。但是，对于 std::recursive_mutex 和 std::recursive_timed_mutex，同一个线程可以多次锁定互斥量而不会导致死锁，因为这些互斥量被设计为支持递归锁定。
     </li>
    </ul>
    <p>
     线程函数调用try_lock()时，可能会发生以下三种情况：
    </p>
    <ul>
     <li>
      如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量
     </li>
     <li>
      如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉
     </li>
     <li>
      如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)，但是，对于 std::recursive_mutex 和 std::recursive_timed_mutex，同一个线程可以多次锁定互斥量而不会导致死锁，因为这些互斥量被设计为支持递归锁定。
     </li>
    </ul>
    <ol start="2">
     <li>
      <strong>
       std::recursive_mutex
      </strong>
     </li>
    </ol>
    <p>
     其允许同一个线程对互斥量多次上锁（即
     <code>
      递归上锁
     </code>
     ），来获得对互斥量对象的多层所有权，释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

recursive_mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		x<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <em>
      <strong>
       recursive_mutex解决的问题
      </strong>
     </em>
    </p>
    <p>
     支持递归调用
    </p>
    <ul>
     <li>
      在递归函数或多层嵌套函数中，如果需要对同一个互斥锁进行多次加锁和解锁操作，使用普通的互斥锁（如std::mutex）可能会导致死锁或未定义行为，因为普通互斥锁不允许同一个线程多次锁定。
     </li>
     <li>
      recursive_mutex则允许同一个线程多次获取同一个锁而不会导致死锁，因为它内部维护了一个计数器，每次获取锁时计数器加1，释放锁时计数器减1，只有当计数器归零时锁才会真正释放。
     </li>
    </ul>
    <ol start="3">
     <li>
      <strong>
       std::timed_mutex
      </strong>
      <br/>
      timed_mutex比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until() 。
     </li>
    </ol>
    <p>
     <strong>
      try_lock_for()
     </strong>
    </p>
    <ul>
     <li>
      功能：尝试在给定的时间段内获取锁。
     </li>
     <li>
      参数：接受一个表示时间范围的
      <code>
       std::chrono::duration
      </code>
      对象。
     </li>
     <li>
      行为：
      <ul>
       <li>
        如果在指定时间内锁被成功获取，则返回 true。
       </li>
       <li>
        如果在指定时间内锁没有被获取（即超时），则返回 false。
       </li>
       <li>
        在等待期间，如果其他线程释放了锁，则当前线程可能会获取该锁。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      try_lock_until()
     </strong>
    </p>
    <ul>
     <li>
      功能：尝试在指定的时间点之前获取锁。
     </li>
     <li>
      参数：接受一个表示时间点的
      <code>
       std::chrono::time_point
      </code>
      对象。
     </li>
     <li>
      行为：
      <ul>
       <li>
        如果在指定时间点之前锁被成功获取，则返回 true。
       </li>
       <li>
        如果在指定时间点到达时锁还没有被获取，则返回 false。
       </li>
       <li>
        与 try_lock_for() 类似，在等待期间，如果其他线程释放了锁，则当前线程可能会获取该锁。
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>timed_mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">try_lock_example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> timeout <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1秒超时</span>
    <span class="token comment">// 尝试在1秒内获取锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mtx<span class="token punctuation">.</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//.........</span>
        <span class="token comment">//........ 模拟一些工作</span>
        mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//.........</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">try_lock_until_example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> timeout_point <span class="token operator">=</span> now <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1秒后超时</span>

    <span class="token comment">// 尝试在指定时间点之前获取锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mtx<span class="token punctuation">.</span><span class="token function">try_lock_until</span><span class="token punctuation">(</span>timeout_point<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//........... 模拟一些工作</span>
        mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//.......   </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>try_lock_example<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>try_lock_until_example<span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="4">
     <li>
      <strong>
       std::recursive_timed_mutex
      </strong>
      <br/>
      了解。
     </li>
    </ol>
    <h4>
     <a id="32_lock_guard_379">
     </a>
     <code>
      3.2 lock_guard
     </code>
    </h4>
    <p>
     <strong>
      lock_guard的模拟实现
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//lock_guard模拟实现</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Lock</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">LockGruad</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">LockGruad</span><span class="token punctuation">(</span>Lock<span class="token operator">&amp;</span> lk<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_lk</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_lk<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">LockGruad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Lock _lk<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     通过上述代码可以看到，lock_guard类模板主要是通过RAII的方式，对其管理的互斥量进行了封装，在需要加锁的地方，只需要用上述介绍的任意互斥体实例化一个lock_guard，调用构造函数成功上锁，出作用域前，lock_guard对象要被销毁，调用析构函数自动解锁，可以有效避免死锁问题。
    </p>
    <p>
     可以用局部域去控制锁的生命周期；+
     <code>
      { }
     </code>
     即可
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5a9c52613dd5493284270918fba87820.png"/>
    </p>
    <p>
     <code>
      lock_guard的缺陷
     </code>
     ：太单一，用户没有办法对该锁进行控制，因此C++11又提供了 unique_lock。
    </p>
    <h4>
     <a id="33_unique_lock_413">
     </a>
     <code>
      3.3 unique_lock
     </code>
    </h4>
    <p>
     与lock_gard类似，unique_lock类模板也是采用RAII的方式对锁进行了封装，并且也是以独占所有权的方式管理mutex对象的上锁和解锁操作，即其对象之间不能发生拷贝。在构造(或移动(move)赋值)时，unique_lock 对象需要传递一个 Mutex 对象作为它的参数，新创建的
     <br/>
     unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。使用以上类型互斥量实例化unique_lock的对象时，自动调用构造函数上锁，unique_lock对象销毁时自动调用析构函数解锁，可以很方便的防止死锁问题。
    </p>
    <p>
     与lock_guard不同的是，unique_lock更加的灵活，提供了更多的成员函数：
    </p>
    <ul>
     <li>
      上锁/解锁操作：
      <code>
       lock
      </code>
      、
      <code>
       try_lock
      </code>
      、
      <code>
       try_lock_for
      </code>
      、
      <code>
       try_lock_until
      </code>
      和
      <code>
       unlock
      </code>
     </li>
     <li>
      修改操作：移动赋值、交换(
      <code>
       swap
      </code>
      ）：与另一个unique_lock对象互换所管理的互斥量所有权)、释放(release：返回它所管理的互斥量对象的指针，并释放所有权)
     </li>
     <li>
      获取属性：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、mutex(返回当前unique_lock所管理的互斥量的指针)。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1c159a9117af45609051fce6563d9bbf.png"/>
    </p>
    <pre><code class="prism language-cpp">
<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//.....</span>
		<span class="token comment">//假设这里面有部分代码是不需要加锁的，如果使用的是lock_guard就不能很好的控制</span>
		<span class="token comment">//....</span>
		lk<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		x<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span>Print<span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <h4>
     <a id="4___455">
     </a>
     <code>
      4. 条件变量的使用以及面试题
     </code>
    </h4>
    <p>
     <strong>
      condition_variable的使用
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       构造
      </strong>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e8a1c511fb3b4bf5acc0dd4a76e0454f.png"/>
     </li>
     <li>
      <strong>
       成员函数的使用
      </strong>
     </li>
    </ol>
    <p>
     <strong>
      wait
     </strong>
    </p>
    <ul>
     <li>
      功能：等待条件变量被通知。
     </li>
     <li>
      用法：通常与 std::unique_lockstd::mutex 或 std::lock_guardstd::mutex 一起使用，以在等待期间释放互斥锁。
     </li>
     <li>
      示例：
      <code>
       cv.wait(lck);
      </code>
      其中 cv 是条件变量，lck 是锁对象。
     </li>
    </ul>
    <p>
     <strong>
      wait_for
     </strong>
    </p>
    <ul>
     <li>
      功能：等待条件变量被通知或直到指定的超时时间到达。
     </li>
     <li>
      用法：接受一个表示超时时间的 std::chrono::duration 对象。
     </li>
     <li>
      返回值：如果因为超时而返回，则返回一个 std::cv_status 枚举值，指示等待是否因为超时（std::cv_status::timeout）或其他原因（如被通知）而结束。
     </li>
     <li>
      示例：
      <code>
       std::cv_status status = cv.wait_for(lck, std::chrono::seconds(1));
      </code>
     </li>
    </ul>
    <p>
     <strong>
      wait_until
     </strong>
    </p>
    <ul>
     <li>
      功能：等待条件变量被通知或直到指定的时间点到达。
     </li>
     <li>
      用法：接受一个表示绝对时间点的 std::chrono::time_point 对象。
     </li>
     <li>
      返回值：与 wait_for 类似，返回一个 std::cv_status 枚举值。
     </li>
     <li>
      示例：auto timeout = std::chrono::steady_clock::now() + std::chrono::seconds(1); std::cv_status status = cv.wait_until(lck, timeout);
     </li>
    </ul>
    <p>
     <strong>
      notify_one
     </strong>
    </p>
    <ul>
     <li>
      功能：通知一个等待该条件变量的线程。
     </li>
     <li>
      用法：如果有多个线程在等待，则选择其中一个进行通知（具体选择哪个线程是未定义的）。
     </li>
     <li>
      示例：
      <code>
       cv.notify_one();
      </code>
     </li>
    </ul>
    <p>
     <strong>
      notify_all
     </strong>
    </p>
    <ul>
     <li>
      功能：通知所有等待该条件变量的线程。
     </li>
     <li>
      用法：唤醒所有等待该条件变量的线程。
     </li>
     <li>
      示例：
      <code>
       cv.notify_all();
      </code>
     </li>
    </ul>
    <p>
     <em>
      <strong>
       面试题目：支持两个线程交替打印，一个打印奇数，一个打印偶数
      </strong>
     </em>
    </p>
    <p>
     本节主要演示了condition_variable的使用，condition_variable熟悉我们linux课程已经讲过了，他们
     <br/>
     用来进行线程之间的互相通知。condition_variable和Linux posix的条件变量并没有什么大的区别，主
     <br/>
     要还是面向对象实现的。
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">two_thread_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
	condition_variable c<span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
			c<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">bool</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 偶数</span>
			c<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
			c<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">bool</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token operator">!</span>flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 奇数</span>
			flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			c<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">two_thread_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <hr/>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373530393736322f:61727469636c652f64657461696c732f313436323537363138" class_="artid" style="display:none">
 </p>
</div>


