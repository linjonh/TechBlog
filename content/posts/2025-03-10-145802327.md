---
layout: post
title: "Docker篇"
date: 2025-03-10 18:38:06 +0800
description: "自定义网络模式，docker提供了三种自定义网络驱动：bridgeoverlaymacvlanbridge驱动类似默认的bridge网络模式，但增加了一些新的功能，overlay和macvlan是用于创建跨主机网络建议使用自定义的网络来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。5.4.1自定义桥接网络在建立自定以网络时，默认使用桥接模式桥接默认是单调递增桥接也支持自定义子网和网关\"IPAM\": {"
keywords: "Docker篇"
categories: ['未分类']
tags: ['网络', '服务器', 'Linux']
artid: "145802327"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145802327
    alt: "Docker篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145802327
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145802327
cover: https://bing.ee123.net/img/rand?artid=145802327
image: https://bing.ee123.net/img/rand?artid=145802327
img: https://bing.ee123.net/img/rand?artid=145802327
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Docker篇
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     1.docker环境搭建：
    </h4>
    <h6>
     1.1软件仓库的配置rhel9：
    </h6>
    <p>
     #cd/etc/yum.repos.d
    </p>
    <p>
     #vim docker.repo
    </p>
    <p>
     [docker]
     <br/>
     name=docker-ce
     <br/>
     baseurl=https://mirrors.aliyun.com/docker-ce/linux/rhel/9/x86_64/stable
     <br/>
     gpgcheck=0
    </p>
    <h6>
     1.2安装docker并且启动服务
    </h6>
    <p>
     yum install -y docker-ce
    </p>
    <p>
     #编辑docker启动文件，设定其使用iptables的网络设定方式，默认使用nftables
     <br/>
     [root@docker ~]# vim /usr/lib/systemd/system/docker.service
     <br/>
     ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --iptables=true
    </p>
    <p>
     # systemctl  enable --now docker
     <br/>
     # docker info
    </p>
    <p>
     在rhel7中 需要
    </p>
    <p>
     ]# vim /etc/sysctl.d/docker.conf
     <br/>
     net.bridge.bridge-nf-call-iptables = 1
     <br/>
     net.bridge.bridge-nf-call-ip6tables = 1
     <br/>
     net.ipv4.ip_forward = 1
    </p>
    <p>
     ]# sysctl --system
     <br/>
     ]# systemctl  restart docker
    </p>
    <h6>
     2.1Docker镜像管理
    </h6>
    <p>
     [root@Docker-node1 ~]# docker search  nginx
     <br/>
     NAME           DESCRIPTION                                      STARS     OFFICIAL
     <br/>
     nginx          Official build of Nginx.                         20094     [OK]
     <br/>
     @@@省略内容
    </p>
    <table>
     <tbody>
      <tr>
       <td>
        NAME
       </td>
       <td>
        镜像名称
       </td>
      </tr>
      <tr>
       <td>
        DESCRIPTION
       </td>
       <td>
        镜像说明
       </td>
      </tr>
      <tr>
       <td>
        STARS
       </td>
       <td>
        点赞数量
       </td>
      </tr>
      <tr>
       <td>
        OFFICIAL
       </td>
       <td>
        是否是官方的
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     #从镜像仓库中拉取镜像（拉取速度较慢）
     <br/>
     [root@Docker-node1 ~]# docker pull busybox
     <br/>
     [root@Docker-node1 ~]# docker pull nginx:1.26-alpine
    </p>
    <p>
     #查看本地镜像
     <br/>
     [root@Docker-node1 ~]# docker images
     <br/>
     REPOSITORY                        TAG           IMAGE ID       CREATED         SIZE
     <br/>
     nginx                             latest        900dca2a61f5   7 weeks ago     188MB
     <br/>
     nginx                             1.26-alpine   b32ed582bddb   7 weeks ago     43.2MB
     <br/>
     ubuntu                            latest        35a88802559d   2 months ago    78.1MB
     <br/>
     busybox                           latest        65ad0d468eb1   15 months ago   4.26MB
     <br/>
     centos                            7             eeb6ee3f44bd   2 years ago     204MB
     <br/>
     centos                            latest        5d0da3dc9764   2 years ago     231MB
     <br/>
     gcr.io/distroless/base-debian12   latest        7273f3276b21   N/A             20.7MB
     <br/>
     gcr.io/distroless/base-debian11   latest        2a6de77407bf   N/A             20.6MB
    </p>
    <p>
     #查看镜像信息
    </p>
    <p>
     [root@Docker-node1 ~]# docker image inspect nginx:1.26-alpine
    </p>
    <p>
     导出镜像
    </p>
    <p>
     [root@Docker-node1 ~]# docker image save nginx:latest -o nginx-latest.tar.gz
     <br/>
     [root@Docker-node1 ~]# docker image save nginx:latest nginx:1.26-alpine -o nginx.tag.gz
    </p>
    <p>
     保存所有镜像
     <br/>
     [root@Docker-node1 ~]# docker save  `docker images | awk 'NR&gt;1{print $1":"$2}'` -o images.tar.gz （-o指定导出镜像位置，可以同时导出多个镜像到一个文件，指定.tar.gz可以导出并压缩）
    </p>
    <p>
     删除镜像：
    </p>
    <p>
     [root@Docker-node1 ~]# docker rmi nginx:latest
    </p>
    <p>
     删除所有镜像
     <br/>
     [root@Docker-node1 ~]# docker rmi  `docker images | awk 'NR&gt;1{print $1":"$2}'`
    </p>
    <h6>
     2.2启动容器
    </h6>
    <p>
     [root@Docker-node1 ~]# docker run  -d --name mario -p 80:8080 timinglee/mario
     <br/>
     [root@Docker-node1 ~]# docker run -it --name centos7 centos:7
     <br/>
     [root@3ba22e59734f /]#    #进入到容器中，按&lt;ctrl&gt;+&lt;d&gt;退出并停止容器，#按&lt;ctrl&gt;+&lt;pq&gt;退出但不停止容器
    </p>
    <p>
     #重新进入容器
     <br/>
     [root@docker ~]# docker attach centos7
     <br/>
     [root@3ba22e59734f /]#
    </p>
    <p>
     #在容器中执行命令
     <br/>
     [root@docker ~]# docker exec -it  test ifconfig
     <br/>
     lo        Link encap:Local Loopback
     <br/>
     inet addr:127.0.0.1  Mask:255.0.0.0
     <br/>
     inet6 addr: ::1/128 Scope:Host
     <br/>
     UP LOOPBACK RUNNING  MTU:65536  Metric:1
     <br/>
     RX packets:0 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:1000
     <br/>
     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
    </p>
    <p>
     -d            #后台运行
     <br/>
     -i            #交互式运行
     <br/>
     -t            #打开一个终端
     <br/>
     --name        #指定容器名称
     <br/>
     -p            #端口映射 -p 80：8080    把容器8080端口映射到本机80端口
     <br/>
     --rm        #容器停止自动删除容器
     <br/>
     --network     #指定容器使用的网络
    </p>
    <h6>
     2.3容器进程查看
    </h6>
    <p>
     [root@Docker-node1 ~]# docker ps                    #查看当前运行容器
     <br/>
     [root@Docker-node1 ~]# docker ps -a                    #查看所有容器
     <br/>
     [root@Docker-node1 ~]# docker inspect busybox        #查看容器运行的详细信息
    </p>
    <h6>
     2.4停止和运行容器
    </h6>
    <p>
     [root@Docker-node1 ~]# docker stop b-怕usybox            #停止容器
     <br/>
     [root@Docker-node1 ~]# docker kill busybox            #杀死容器，可以使用信号
     <br/>
     [root@Docker-node1 ~]# docker start busybox            #开启停止的容器
    </p>
    <h6>
     2.5删除容器
    </h6>
    <p>
     [root@Docker-node1 ~]# docker rm centos7            #删除停止的容器
    </p>
    <p>
     [root@Docker-node1 ~]# docker rm -f busybox            #删除运行的容器
    </p>
    <p>
     [root@Docker-node1 ~]# docker container prune -f    #删除所有停止的容器
    </p>
    <h6>
     2.6容器内容提交
    </h6>
    <p>
     默认情况下，容器被删除后，在容器中的所有操作都会被清理，包括要保存的文件
    </p>
    <p>
     如果想永久保存，那么我们需要把动作提交，提交后会生成新的镜像
    </p>
    <p>
     当我们在运行新镜像后即可看到我们提交的内容
    </p>
    <p>
     [root@Docker-node1 ~]# docker run -it --name test busybox
     <br/>
     / # touch leefile                                            #在容器中建立文件
     <br/>
     / # ls
     <br/>
     bin      etc      leefile  lib64    root     tmp      var
     <br/>
     dev      home     lib      proc     sys      usr
     <br/>
     / #
     <br/>
     [root@Docker-node1 ~]# docker rm test    #删掉容器后
     <br/>
     test
     <br/>
     [root@Docker-node1 ~]# docker run -it --name test busybox    #删掉容器后开启新的容器文件不存在
     <br/>
     / # ls
     <br/>
     bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    usr    var
     <br/>
     / #
    </p>
    <p>
     [root@Docker-node1 ~]# docker commit -m "add leefile" test  busybox:v1
     <br/>
     sha256:c8ff62b7480c951635acb6064acdfeb25282bd0c19cbffee0e51f3902cbfa4bd
     <br/>
     [root@Docker-node1 ~]# docker images
     <br/>
     REPOSITORY                        TAG           IMAGE ID       CREATED          SIZE
     <br/>
     busybox                           v1            c8ff62b7480c   12 seconds ago   4.26MB
    </p>
    <p>
     [root@Docker-node1 ~]# docker image history busybox:v1
     <br/>
     IMAGE          CREATED         CREATED BY                          SIZE      COMMENT
     <br/>
     c8ff62b7480c   2 minutes ago   sh                                  17B       add leefile
     <br/>
     65ad0d468eb1   15 months ago   BusyBox 1.36.1 (glibc), Debian 12   4.26MB
    </p>
    <p>
     此方法企业一般不用 企业一般写dockerfile构建镜像
    </p>
    <h6>
     2.7系统中文件和容器中文件传输
    </h6>
    <p>
     [root@Docker-node1 ~]# docker cp  test2:/leefile /mnt        #把容器中的文件复制到本机
     <br/>
     Successfully copied 1.54kB to /mnt
     <br/>
     [root@Docker-node1 ~]# docker cp /etc/fstab  test2:/fstab    #把本机文件复制到容器中
     <br/>
     查看容器内部日志：docker logs web
    </p>
    <h5>
     2.dockers镜像的构建
    </h5>
    <h6>
     2.1镜像获取方式：
    </h6>
    <ul>
     <li>
      <p>
       本镜像通常由软件官方提供
      </p>
     </li>
     <li>
      <p>
       企业镜像可以用官方镜像+Dockerfile来生成
      </p>
     </li>
     <li>
      <p>
       系统关于镜像的获取动作有两种：
      </p>
      <ul>
       <li>
        <p>
         docker pull 镜像地址
        </p>
       </li>
       <li>
        <p>
         docker load –i 本地镜像包
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     2.2构建参数
    </h6>
    <table>
     <thead>
      <tr>
       <th>
        FROM
       </th>
       <th>
        指定base镜像 eg：FROM busybox:version
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         COPY
        </strong>
       </td>
       <td>
        <strong>
         复制文件 eg：COPY file /file 或者 COPY [“file”,”/”]
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         MAINTAINER
        </strong>
       </td>
       <td>
        <strong>
         指定作者信息，比如邮箱 eg：MAINTAINER
         <a href="mailto:user@example.com" rel="nofollow">
          user@example.com
         </a>
        </strong>
        在最新版的docker中用LABEL KEY="VALUE"代替
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         ADD
        </strong>
       </td>
       <td>
        <strong>
         功能和copy相似，指定压缩文件或url eg: ADD test.tar /mnt 或者 eg：ADD
         <a href="http://ip/test.tar" rel="nofollow" title="http://ip/test.tar">
          http://ip/test.tar
         </a>
         /mnt
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         ENV
        </strong>
       </td>
       <td>
        <strong>
         指定环境变量 eg：ENV FILENAME test
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         EXPOSE
        </strong>
       </td>
       <td>
        <strong>
         暴漏容器端口 eg：EXPOSE 80
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         VOLUME
        </strong>
       </td>
       <td>
        <strong>
         申明数据卷，通常指数据挂载点 eg：VOLUME [“/var/www/html”]
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         WORKDIR
        </strong>
       </td>
       <td>
        <strong>
         切换路径 eg：WORKDIR /mnt
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         RUN
        </strong>
       </td>
       <td>
        <strong>
         在容器中运行的指令 eg: touch file
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         CMD
        </strong>
       </td>
       <td>
        <strong>
         在启动容器时自动运行动作可以被覆盖 eg：CMD echo $FILENAME 会调用shell解析 eg：CMD [“/bin/sh”,”-c”,“echo $FILENAME”] 不调用shell解析
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         ENTRYPOINT
        </strong>
       </td>
       <td>
        <strong>
         和CMD功能和用法类似，但动作不可被覆盖
        </strong>
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     3.docker公有仓库和私有仓库
    </h5>
    <p>
     <strong>
      Docker Hub
     </strong>
     是 Docker 官方提供的一个公共的镜像仓库服务。
    </p>
    <p>
     它是 Docker 生态系统中最知名和广泛使用的镜像仓库之一，拥有大量的官方和社区贡献的镜像。
    </p>
    <p>
     以下是 Docker Hub 的一些关键特点和优势：
    </p>
    <ol>
     <li>
      <p>
       丰富的镜像资源：涵盖了各种常见的操作系统、编程语言运行时、数据库、Web 服务器等众多应用的镜像。
      </p>
      <ul>
       <li>
        <p>
         例如，您可以轻松找到 Ubuntu、CentOS 等操作系统的镜像，以及 MySQL、Redis 等数据库的镜像。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       官方支持：提供了由 Docker 官方维护的一些重要镜像，确保其质量和安全性。
      </p>
     </li>
     <li>
      <p>
       社区贡献：开发者们可以自由上传和分享他们创建的镜像，促进了知识和资源的共享。
      </p>
     </li>
     <li>
      <p>
       版本管理：对于每个镜像，通常都有多个版本可供选择，方便用户根据需求获取特定版本。
      </p>
     </li>
     <li>
      <p>
       便于搜索：用户可以通过关键词轻松搜索到所需的镜像。
      </p>
     </li>
    </ol>
    <h6>
     docker hub的使用方法：
    </h6>
    <p>
     #登陆官方仓库
     <br/>
     [root@docker ~]# docker login
     <br/>
     Log in with your Docker ID or email address to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com/ to create one.
     <br/>
     You can log in with your password or a Personal Access Token (PAT). Using a limited-scope PAT grants better security and is required for organizations using SSO. Learn more at https://docs.docker.com/go/access-tokens/
    </p>
    <p>
     Username: timinglee
     <br/>
     Password:
     <br/>
     WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
     <br/>
     Configure a credential helper to remove this warning. See
     <br/>
     https://docs.docker.com/engine/reference/commandline/login/#credential-stores
    </p>
    <p>
     Login Succeeded
    </p>
    <p>
     #登陆信息保存位置
     <br/>
     [root@docker ~]# cd .docker/
     <br/>
     [root@docker .docker]# ls
     <br/>
     config.json
     <br/>
     [root@docker .docker]# cat config.json
     <br/>
     {
     <!-- -->
     <br/>
     "auths": {
     <!-- -->
     <br/>
     "https://index.docker.io/v1/": {
     <!-- -->
     <br/>
     "auth": "dGltaW5nbGVlOjY3NTE1MTVtaW5nemxu"
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     [root@docker ~]# docker tag gcr.io/distroless/base-debian11:latest  timinglee/base-debian11:latest
     <br/>
     [root@docker ~]# docker push  timinglee/base-debian11:latest
     <br/>
     The push refers to repository [docker.io/timinglee/base-debian11]
     <br/>
     6835249f577a: Pushed
     <br/>
     24aacbf97031: Pushed
     <br/>
     8451c71f8c1e: Pushed
     <br/>
     2388d21e8e2b: Pushed
     <br/>
     c048279a7d9f: Pushed
     <br/>
     1a73b54f556b: Pushed
     <br/>
     2a92d6ac9e4f: Pushed
     <br/>
     bbb6cacb8c82: Pushed
     <br/>
     ac805962e479: Pushed
     <br/>
     af5aa97ebe6c: Pushed
     <br/>
     4d049f83d9cf: Pushed
     <br/>
     9ed498e122b2: Pushed
     <br/>
     577c8ee06f39: Pushed
     <br/>
     5342a2647e87: Pushed
     <br/>
     latest: digest: sha256:f8179c20f1f2b1168665003412197549bd4faab5ccc1b140c666f9b8aa958042 size: 3234
     <br/>
    </p>
    <p>
     镜像拉取pull原理：docker客户端向index发送镜像拉取请求，index向客户端提供token和registry的位置，然后去找到registry做认证，registry向index确认docker客户端的合法性，index确认docker客户端合法，然后确认请求传递镜像到客户端
    </p>
    <p>
     镜像上传push原理：docker客户端向index发送镜像上传请求，index向客户端发送认证token和registry位置，客户端拿着token去和registry做认证，registry向index确认docker客户端的合法性 index确认合法 然后根据客户端请求上传镜像
    </p>
    <h6>
     docker registry私有仓库：
    </h6>
    <p>
     docker hub虽然方便，但是还是有限制
    </p>
    <ul>
     <li>
      <p>
       需要internet连接，速度慢
      </p>
     </li>
     <li>
      <p>
       所有人都可以访问
      </p>
     </li>
     <li>
      <p>
       由于安全原因企业不允许将镜像放到外网
      </p>
     </li>
    </ul>
    <p>
     搭建简单的私有仓库
    </p>
    <p>
     <a href="https://hub.docker.com/_/registry?tab=tags" rel="nofollow" title="registry">
      registry
     </a>
     的配置（在/etc/docker/daemon.json）
    </p>
    <p>
     1.下载Registry镜像
    </p>
    <p>
     docker pull registry
    </p>
    <p>
     2.开启Registry（私有仓库）
    </p>
    <p>
     docker run -d -p 5000：5000 --restart=always --name registry registry
    </p>
    <p>
     知识点：1、了解到
     <a href="https://hub.docker.com/_/registry?tab=tags" rel="nofollow" title="registry">
      registry
     </a>
     它的默认端口是5000；2、简单了解--restart=always的使用，它的含义是容器出现故障时默认无限次的尝试重启。
    </p>
    <p>
     3.上传镜像到私有仓库中
    </p>
    <p>
     #docker在上传的过程中默认使用https，但是我们并没有建立https认证需要的认证文件所以会报错，所以先配置非加密端口
    </p>
    <p>
     vim/etc/docker/daemon.json
    </p>
    <p>
     {
     <!-- -->
     <br/>
     "insecure-registries" : ["http://172.25.254.100:5000"]
     <br/>
     }
     <br/>
     systemctl restart docker
    </p>
    <p>
     #注意：1、push前需要给将要上传的镜像打tag；2、push时需要给镜像指定tag标签，否则会push失败。
    </p>
    <p>
     首先给上传的镜像打上标签 docker tag busybox:latest  172.25.254.100:5000/busybox:latest
    </p>
    <p>
     然后docker images查看镜像是否成功打上标签
    </p>
    <p>
     然后在push ：docker push 172.25.254.100:5000/busybox:latest
    </p>
    <p>
     查看是否上传成功：curl 172.25.254.100：5000/v2/_catalog
    </p>
    <p>
     {"repositories":["busybox"]}
    </p>
    <h6>
     4.构建企业级docker harbor
    </h6>
    <p>
     Harbor 是由vmware公司开源的企业级 Docker Registry 项目。
    </p>
    <p>
     它提供了以下主要功能和特点：
    </p>
    <ol>
     <li>
      <p>
       基于角色的访问控制（RBAC）：可以为不同的用户和用户组分配不同的权限，增强了安全性和管理的灵活性。
      </p>
     </li>
     <li>
      <p>
       镜像复制：支持在不同的 Harbor 实例之间复制镜像，方便在多个数据中心或环境中分发镜像。
      </p>
     </li>
     <li>
      <p>
       图形化用户界面（UI）：提供了直观的 Web 界面，便于管理镜像仓库、项目、用户等。
      </p>
     </li>
     <li>
      <p>
       审计日志：记录了对镜像仓库的各种操作，有助于追踪和审查活动。
      </p>
     </li>
     <li>
      <p>
       垃圾回收：可以清理不再使用的镜像，节省存储空间。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <p>
     部署企业级harbor仓库首先要做加密认证
    </p>
    <p>
     #openssl req -newkey  rsa:4096 \
     <br/>
     -nodes -sha256 -keyout certs/timinglee.org.key \
     <br/>
     -addext "subjectAltName = DNS:
     <span style="color:#fe2c24">
      reg.timinglee.org"
     </span>
     \        #指定备用名称
     <br/>
     -x509 -days 365 -out certs/timinglee.org.crt
    </p>
    <p>
     mkdir /data/创建一个目录 将证书考入这个目录下面
    </p>
    <p>
     cp /root/certs/ /data/ -r
    </p>
    <p>
     [root@docker ~]# tar zxf harbor-offline-installer-v2.5.4.tgz
    </p>
    <p>
     [root@docker ~]# ls
     <br/>
     anaconda-ks.cfg  certs   harbor-offline-installer-v2.5.4.tgz
     <br/>
     auth             harbor
     <br/>
     [root@docker ~]# cd harbor/
    </p>
    <p style="text-align:center">
     <br/>
     [root@docker harbor]# cp harbor.yml.tmpl harbor.yml
     <br/>
     [root@docker harbor]# vim harbor.yml
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6c91b1e8943f4892bce14cd28c7e4bf6.png"/>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/02572c4a70504cedb1d4672c014dead0.png"/>
    </p>
    <p>
     hostname: reg.timinglee.org
     <br/>
     certificate: /data/certs/timinglee.org.crt
     <br/>
     private_key: /data/certs/timinglee.org.key
     <br/>
     harbor_admin_password: lee
    </p>
    <p>
     [root@docker harbor]# ./install.sh --help
    </p>
    <p>
     <br/>
     Please set --with-notary                 #证书签名
     <br/>
     Please set --with-trivy                  #安全扫描
     <br/>
     Please set --with-chartmuseum if needs enable Chartmuseum in Harbor
    </p>
    <p>
     <br/>
     [root@docker harbor]# ./install.sh --with-chartmuseum
    </p>
    <p>
     可以通过访问ip或域名进入harbor 如果windows上需要对此ip进行解析
    </p>
    <p>
     目录：C:\Windows\System32\drivers\etc\hosts
    </p>
    <p>
     #管理harbor的容器
     <br/>
     [root@docker harbor]# docker compose stop
     <br/>
     [root@docker harbor]# docker compose  up -d
    </p>
    <p>
     管理仓库：
    </p>
    <p>
     #docker login reg.timinglee.org
    </p>
    <p>
     user：
    </p>
    <p>
     passwd：
    </p>
    <p>
     [root@docker harbor]# docker tag busybox:latest  reg.timinglee.org/timinglee/busybox:latest
     <br/>
     [root@docker harbor]# docker push reg.timinglee.org/timinglee/busybox:latest
     <br/>
     The push refers to repository [reg.timinglee.org/timinglee/busybox]
     <br/>
     d51af96cf93e: Pushed
     <br/>
     latest: digest: sha256:28e01ab32c9dbcbaae96cf0d5b472f22e231d9e603811857b295e61197e40a9b size: 527
    </p>
    <p>
     docker的weBUI工具：导入开源镜像包1panel-v1.10.13-lts-linux-amd64.tar.gz
    </p>
    <p>
     sh install.sh
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f284e68020b946698f52e593204903e1.png"/>
    </p>
    <p>
     1ptctl user-info
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/dcd37e3f2a9548949018c1fd4743646c.png"/>
    </p>
    <h6>
     5.docker网络
    </h6>
    <p>
     ocker的镜像是令人称道的地方，但网络功能还是相对薄弱的部分
    </p>
    <p>
     docker安装后会自动创建3种网络：bridge、host、none
    </p>
    <p>
     [root@docker harbor]# docker network ls
     <br/>
     NETWORK ID     NAME      DRIVER    SCOPE
     <br/>
     2a93d6859680   bridge    bridge    local
     <br/>
     4d81ddd9ed10   host      host      local
     <br/>
     8c8c95f16b68   none      null      local
    </p>
    <h6>
     5.1docker bridge网络
    </h6>
    <p>
     [root@docker mnt]# ip link show type bridge
     <br/>
     3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default
     <br/>
     link/ether 02:42:5f:e2:34:6c brd ff:ff:ff:ff:ff:ff
    </p>
    <ul>
     <li>
      <p>
       bridge模式下容器没有一个公有ip，只有宿主机可以直接访问，外部主机是不可见的。
      </p>
     </li>
     <li>
      <p>
       容器通过宿主机的NAT规则后可以访问外网
      </p>
     </li>
    </ul>
    <h6>
     5.2docker原生网络host
    </h6>
    <p>
     host网络模式需要在容器创建时指定 --network=host
    </p>
    <p>
     host模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性
    </p>
    <pre>[root@docker ~]# docker run -it --name test  --network host busybox</pre>
    <pre>/ # ifconfig</pre>
    <pre>docker0   Link encap:Ethernet  HWaddr 02:42:5F:E2:34:6C</pre>
    <pre>          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</pre>
    <pre>          inet6 addr: fe80::42:5fff:fee2:346c/64 Scope:Link</pre>
    <pre>          UP BROADCAST MULTICAST  MTU:1500  Metric:1</pre>
    <pre>          RX packets:21264 errors:0 dropped:0 overruns:0 frame:0</pre>
    <pre>          TX packets:27359 errors:0 dropped:0 overruns:0 carrier:0</pre>
    <pre>          collisions:0 txqueuelen:0</pre>
    <pre>          RX bytes:1497364 (1.4 MiB)  TX bytes:215202367 (205.2 MiB)</pre>
    <pre>​</pre>
    <pre>eth0      Link encap:Ethernet  HWaddr 00:0C:29:EC:FC:D3</pre>
    <pre>          inet addr:172.25.254.100  Bcast:172.25.254.255  Mask:255.255.255.0</pre>
    <pre>          inet6 addr: fe80::30b2:327e:b13a:31cf/64 Scope:Link</pre>
    <pre>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</pre>
    <pre>          RX packets:1902507 errors:0 dropped:0 overruns:0 frame:0</pre>
    <pre>          TX packets:831640 errors:0 dropped:0 overruns:0 carrier:0</pre>
    <pre>          collisions:0 txqueuelen:1000</pre>
    <pre>          RX bytes:2202443300 (2.0 GiB)  TX bytes:849412124 (810.0 MiB)</pre>
    <pre>​</pre>
    <pre>lo        Link encap:Local Loopback</pre>
    <pre>          inet addr:127.0.0.1  Mask:255.0.0.0</pre>
    <pre>          inet6 addr: ::1/128 Scope:Host</pre>
    <pre>          UP LOOPBACK RUNNING  MTU:65536  Metric:1</pre>
    <pre>          RX packets:11819 errors:0 dropped:0 overruns:0 frame:0</pre>
    <pre>          TX packets:11819 errors:0 dropped:0 overruns:0 carrier:0</pre>
    <pre>          collisions:0 txqueuelen:1000</pre>
    <pre>          RX bytes:1279944 (1.2 MiB)  TX bytes:1279944 (1.2 MiB)</pre>
    <pre>​如果公用一个网络，那么所有的网络资源都是公用的，比如启动了nginx容器那么真实主机的80端口被占用，在启动第二个nginx容器就会失败 </pre>
    <h6>
     5.3docker原生网络none
    </h6>
    <p>
     none模式是指禁用网络功能，只有lo接口，在容器创建时使用
    </p>
    <p>
     --network=none指定。
    </p>
    <p>
     [root@docker ~]# docker run -it --name test --rm --network none  busybox
     <br/>
     / # ifconfig
     <br/>
     lo        Link encap:Local Loopback
     <br/>
     inet addr:127.0.0.1  Mask:255.0.0.0
     <br/>
     inet6 addr: ::1/128 Scope:Host
     <br/>
     UP LOOPBACK RUNNING  MTU:65536  Metric:1
     <br/>
     RX packets:0 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:1000
     <br/>
     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
    </p>
    <h6>
     5.4docker自定义网络
    </h6>
    <p>
     自定义网络模式，docker提供了三种自定义网络驱动：
    </p>
    <ul>
     <li>
      <p>
       bridge
      </p>
     </li>
     <li>
      <p>
       overlay
      </p>
     </li>
     <li>
      <p>
       macvlan
      </p>
     </li>
    </ul>
    <p>
     bridge驱动类似默认的bridge网络模式，但增加了一些新的功能，
    </p>
    <p>
     overlay和macvlan是用于创建跨主机网络
    </p>
    <p>
     建议使用自定义的网络来控制哪些容器可以相互通信，还可以自动DNS解析容器名称到IP地址。
    </p>
    <h6>
    </h6>
    <p>
     5.4.1自定义桥接网络
    </p>
    <p>
     在建立自定以网络时，默认使用桥接模式
    </p>
    <p>
     [root@docker ~]# docker network create my_net1
     <br/>
     f2aae5ce8ce43e8d1ca80c2324d38483c2512d9fb17b6ba60d05561d6093f4c4
     <br/>
     [root@docker ~]# docker network ls
     <br/>
     NETWORK ID     NAME      DRIVER    SCOPE
     <br/>
     2a93d6859680   bridge    bridge    local
     <br/>
     4d81ddd9ed10   host      host      local
     <br/>
     f2aae5ce8ce4   my_net1   bridge    local
     <br/>
     8c8c95f16b68   none      null      local
    </p>
    <p>
     桥接默认是单调递增
    </p>
    <p>
     root@docker ~]# ifconfig
     <br/>
     br-f2aae5ce8ce4: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
     <br/>
     inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
     <br/>
     ether 02:42:70:57:f2:82  txqueuelen 0  (Ethernet)
     <br/>
     RX packets 21264  bytes 1497364 (1.4 MiB)
     <br/>
     RX errors 0  dropped 0  overruns 0  frame 0
     <br/>
     TX packets 27359  bytes 215202367 (205.2 MiB)
     <br/>
     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
    </p>
    <p>
     docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
     <br/>
     inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
     <br/>
     inet6 fe80::42:5fff:fee2:346c  prefixlen 64  scopeid 0x20&lt;link&gt;
     <br/>
     ether 02:42:5f:e2:34:6c  txqueuelen 0  (Ethernet)
     <br/>
     RX packets 21264  bytes 1497364 (1.4 MiB)
     <br/>
     RX errors 0  dropped 0  overruns 0  frame 0
     <br/>
     TX packets 27359  bytes 215202367 (205.2 MiB)
     <br/>
     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
    </p>
    <p>
     桥接也支持自定义子网和网关
    </p>
    <p>
     [root@docker ~]# docker network create my_net2 --subnet 192.168.0.0/24 --gateway 192.168.0.100
     <br/>
     7e77cd2e44c64ff3121a1f1e0395849453f8d524d24b915672da265615e0e4f9
     <br/>
     [root@docker ~]# docker network  inspect my_net2
     <br/>
     [
     <br/>
     {
     <!-- -->
     <br/>
     "Name": "my_net2",
     <br/>
     "Id": "7e77cd2e44c64ff3121a1f1e0395849453f8d524d24b915672da265615e0e4f9",
     <br/>
     "Created": "2024-08-17T17:05:19.167808342+08:00",
     <br/>
     "Scope": "local",
     <br/>
     "Driver": "bridge",
     <br/>
     "EnableIPv6": false,
     <br/>
     "IPAM": {
     <!-- -->
     <br/>
     "Driver": "default",
     <br/>
     "Options": {},
     <br/>
     "Config": [
     <br/>
     {
     <!-- -->
     <br/>
     "Subnet": "192.168.0.0/24",
     <br/>
     "Gateway": "192.168.0.100"
     <br/>
     }
     <br/>
     ]
     <br/>
     },
     <br/>
     "Internal": false,
     <br/>
     "Attachable": false,
     <br/>
     "Ingress": false,
     <br/>
     "ConfigFrom": {
     <!-- -->
     <br/>
     "Network": ""
     <br/>
     },
     <br/>
     "ConfigOnly": false,
     <br/>
     "Containers": {},
     <br/>
     "Options": {},
     <br/>
     "Labels": {}
     <br/>
     }
     <br/>
     ]
    </p>
    <h6>
     5.4.2为什么要自定义桥接
    </h6>
    <p>
     多容器之间如何互访？通过ip可以，但是有什么问题？
    </p>
    <p>
     [root@docker ~]# docker run  -d --name web1 nginx
     <br/>
     d5da7eaa913fa6cdd2aa9a50561042084eca078c114424cb118c57eeac473424
     <br/>
     [root@docker ~]# docker run  -d --name web2 nginx
     <br/>
     0457a156b02256915d4b42f6cc52ea71b18cf9074ce550c886f206fef60dfae5
     <br/>
     [root@docker ~]# docker inspect  web1
     <br/>
     "Networks": {
     <!-- -->
     <br/>
     "bridge": {
     <!-- -->
     <br/>
     "IPAMConfig": null,
     <br/>
     "Links": null,
     <br/>
     "Aliases": null,
     <br/>
     "MacAddress": "02:42:ac:11:00:03",
     <br/>
     "DriverOpts": null,
     <br/>
     "NetworkID": "2a93d6859680b45eae97e5f6232c3b8e070b1ec3d01852b147d2e1385034bce5",
     <br/>
     "EndpointID": "4d54b12aeb2d857a6e025ee220741cbb3ef1022848d58057b2aab544bd3a4685",
     <br/>
     "Gateway": "172.17.0.1",
     <br/>
     "IPAddress": "172.17.0.2",        #注意ip信息
     <br/>
     "IPPrefixLen": 16,
     <br/>
     "IPv6Gateway": "",
     <br/>
     "GlobalIPv6Address": "",
     <br/>
     "GlobalIPv6PrefixLen": 0,
     <br/>
     "DNSNames": null
    </p>
    <p>
     [root@docker ~]# docker inspect  web1
     <br/>
     "Networks": {
     <!-- -->
     <br/>
     "bridge": {
     <!-- -->
     <br/>
     "IPAMConfig": null,
     <br/>
     "Links": null,
     <br/>
     "Aliases": null,
     <br/>
     "MacAddress": "02:42:ac:11:00:03",
     <br/>
     "DriverOpts": null,
     <br/>
     "NetworkID": "2a93d6859680b45eae97e5f6232c3b8e070b1ec3d01852b147d2e1385034bce5",
     <br/>
     "EndpointID": "4d54b12aeb2d857a6e025ee220741cbb3ef1022848d58057b2aab544bd3a4685",
     <br/>
     "Gateway": "172.17.0.1",
     <br/>
     "IPAddress": "172.17.0.3",        #注意ip信息
     <br/>
     "IPPrefixLen": 16,
     <br/>
     "IPv6Gateway": "",
     <br/>
     "GlobalIPv6Address": "",
     <br/>
     "GlobalIPv6PrefixLen": 0,
     <br/>
     "DNSNames": null
     <br/>
     <br/>
     #关闭容器后重启容器，启动顺序调换
     <br/>
     [root@docker ~]# docker stop web1 web2
     <br/>
     web1
     <br/>
     web2
     <br/>
     [root@docker ~]# docker start web2
     <br/>
     web2
     <br/>
     [root@docker ~]# docker start web1
     <br/>
     web1
    </p>
    <p>
     #我们会发容器ip颠倒
    </p>
    <p>
     docker引擎在分配ip时时根据容器启动顺序分配到，谁先启动谁用，是动态变更的
    </p>
    <p>
     多容器互访用ip很显然不是很靠谱，那么多容器访问一般使用容器的名字访问更加稳定
    </p>
    <p>
     docker原生网络是不支持dns解析的，自定义网络中内嵌了dns
    </p>
    <h6>
     5.4.3如何让不同的自定义网络互通
    </h6>
    <p>
     在其中一个容器中加上另一个容器的一块网卡
    </p>
    <p>
     [root@docker ~]# docker run -d  --name web1 --network my_net1 nginx
     <br/>
     [root@docker ~]# docker run  -it --name test --network my_net2 busybox
     <br/>
     / # ifconfig
     <br/>
     eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:00:01
     <br/>
     inet addr:192.168.0.1  Bcast:192.168.0.255  Mask:255.255.255.0
     <br/>
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     <br/>
     RX packets:36 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:0
     <br/>
     RX bytes:5244 (5.1 KiB)  TX bytes:0 (0.0 B)
    </p>
    <p>
     lo        Link encap:Local Loopback
     <br/>
     inet addr:127.0.0.1  Mask:255.0.0.0
     <br/>
     inet6 addr: ::1/128 Scope:Host
     <br/>
     UP LOOPBACK RUNNING  MTU:65536  Metric:1
     <br/>
     RX packets:0 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:1000
     <br/>
     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
    </p>
    <p>
     / # ping 172.18.0.2
     <br/>
     PING 172.18.0.2 (172.18.0.2): 56 data bytes
    </p>
    <p>
     [root@docker ~]# docker network connect my_net1 test
    </p>
    <p>
     #在上面test容器中加入网络eth1
     <br/>
     / # ifconfig
     <br/>
     eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:00:01
     <br/>
     inet addr:192.168.0.1  Bcast:192.168.0.255  Mask:255.255.255.0
     <br/>
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     <br/>
     RX packets:45 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:0
     <br/>
     RX bytes:5879 (5.7 KiB)  TX bytes:602 (602.0 B)
    </p>
    <p>
     eth1      Link encap:Ethernet  HWaddr 02:42:AC:12:00:03
     <br/>
     inet addr:172.18.0.3  Bcast:172.18.255.255  Mask:255.255.0.0
     <br/>
     UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
     <br/>
     RX packets:15 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:0
     <br/>
     RX bytes:2016 (1.9 KiB)  TX bytes:0 (0.0 B)
    </p>
    <p>
     lo        Link encap:Local Loopback
     <br/>
     inet addr:127.0.0.1  Mask:255.0.0.0
     <br/>
     inet6 addr: ::1/128 Scope:Host
     <br/>
     UP LOOPBACK RUNNING  MTU:65536  Metric:1
     <br/>
     RX packets:4 errors:0 dropped:0 overruns:0 frame:0
     <br/>
     TX packets:4 errors:0 dropped:0 overruns:0 carrier:0
     <br/>
     collisions:0 txqueuelen:1000
     <br/>
     RX bytes:212 (212.0 B)  TX bytes:212 (212.0 B)
    </p>
    <h6>
     5.4.4joined容器网络
    </h6>
    <p>
     Joined容器一种较为特别的网络模式，•在容器创建时使用--network=container:vm1指定。（vm1指定的是运行的容器名）
    </p>
    <p>
     处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用localhost高效快速通信。
    </p>
    <p>
     利用容器部署phpmyadmin管理mysql
    </p>
    <p>
     #运行phpmysqladmin
     <br/>
     [root@docker ~]# docker run -d --name mysqladmin --network my_net1 \
     <br/>
     -e PMA_ARBITRARY=1 \                #在web页面中可以手动输入数据库地址和端口
     <br/>
     -p 80:80 phpmyadmin:latest
    </p>
    <p>
     #运行数据库
    </p>
    <p>
     root@docker ~]# docker run  -d --name mysql \
     <br/>
     -e MYSQL_ROOT_PASSWORD='lee' \                    #设定数据库密码
     <br/>
     --network container:mysqladmin  \                #把数据库容器添加到phpmyadmin容器中
     <br/>
     mysql:5.7
    </p>
    <p>
     开启的phpmyadmin容器中是没有数据库的
    </p>
    <p>
     这里填写的localhost:3306是因为mysql容器和phpmyadmin容器公用一个网络站
    </p>
    <h6>
     Docker compose
    </h6>
    <p>
     Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。
    </p>
    <p>
     用来帮助你在 Docker 中同时管理多个容器。你可以把它想象成一个“一键启动”按钮，让你轻松运行多个相关的服务
    </p>
    <p>
     其是官方的一个开源项目，托管到github上
    </p>
    <p>
     Docker compose可以理解为shell脚本 一次性执行多个容器启动命令
    </p>
    <p>
     <strong>
      主要功能
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        定义服务
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用 YAML 格式的配置文件来定义一组相关的容器服务。每个服务可以指定镜像、端口映射、环境变量、存储卷等参数。
        </p>
       </li>
       <li>
        <p>
         例如，可以在配置文件中定义一个 Web 服务和一个数据库服务，以及它们之间的连接关系。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        一键启动和停止
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过一个简单的命令，可以启动或停止整个应用程序所包含的所有容器。这大大简化了多容器应用的部署和管理过程。
        </p>
       </li>
       <li>
        <p>
         例如，使用
         <code>
          docker-compose up
         </code>
         命令可以启动配置文件中定义的所有服务，使用
         <code>
          docker-compose down
         </code>
         命令可以停止并删除这些服务。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        服务编排
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         可以定义容器之间的依赖关系，确保服务按照正确的顺序启动和停止。例如，可以指定数据库服务必须在 Web 服务之前启动。
        </p>
       </li>
       <li>
        <p>
         支持网络配置，使不同服务的容器可以相互通信。可以定义一个自定义的网络，将所有相关的容器连接到这个网络上。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        环境变量管理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         可以在配置文件中定义环境变量，并在容器启动时传递给容器。这使得在不同环境（如开发、测试和生产环境）中使用不同的配置变得更加容易。
        </p>
       </li>
       <li>
        <p>
         例如，可以定义一个数据库连接字符串的环境变量，在不同环境中可以设置不同的值。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      工作原理
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        读取配置文件
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Docker Compose 读取 YAML 配置文件，解析其中定义的服务和参数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        创建容器
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据配置文件中的定义，Docker Compose 调用 Docker 引擎创建相应的容器。它会下载所需的镜像（如果本地没有），并设置容器的各种参数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        管理容器生命周期
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Docker Compose 监控容器的状态，并在需要时启动、停止、重启容器。
        </p>
       </li>
       <li>
        <p>
         它还可以处理容器的故障恢复，例如自动重启失败的容器。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      Docker Compose 中的管理层
     </strong>
    </p>
    <ol>
     <li>
      <p>
       服务 (service) 一个应用的容器，实际上可以包括若干运行相同镜像的容器实例
      </p>
     </li>
     <li>
      <p>
       项目 (project) 由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义
      </p>
     </li>
     <li>
      <p>
       容器（container）容器是服务的具体实例，每个服务可以有一个或多个容器。容器是基于服务定义的镜像创建的运行实例
      </p>
     </li>
    </ol>
    <p>
     Docker compose常用命令参数
    </p>
    <p>
     docker compose up 启动时默认找的文件是 docker-compose.yml
    </p>
    <p>
     要是没有 需要指定文件名 ：docker compose -f 文件名 up -d
    </p>
    <p>
     docker compose stop停止正在运行的服务
    </p>
    <p>
     docker compose down停止并删除正在运行的服务
    </p>
    <p>
     docker compose start启动已存在的服务但是不会创建新的服务
    </p>
    <p>
     docker compose restart 重启服务
    </p>
    <p>
     Docker compose ps服务状态查看（注意：必须要进入.yml存在的目录才能查看）
    </p>
    <p>
     docker compose logs 查看服务的日志输出
    </p>
    <p>
     docker-compose exec 在正在运行的容器中执行命令
    </p>
    <p>
     services:
     <br/>
     test:
     <br/>
     image: busybox
     <br/>
     command: ["/bin/sh","-c","sleep 3000"]
     <br/>
     restart: always
     <br/>
     container_name: busybox1
    </p>
    <p>
     [root@docker test]# docker compose -f test.yml  up -d
     <br/>
     [root@docker test]# docker compose  -f test.yml  exec  test sh
     <br/>
     / #
    </p>
    <p>
     <code>
      docker-compose pull
     </code>
     ：拉取配置文件中定义的服务所使用的镜像
    </p>
    <p>
     [root@docker test]# docker compose -f test.yml pull
     <br/>
     [+] Pulling 2/2
     <br/>
     ✔ test Pulled
     <br/>
     ✔ ec562eabd705 Pull complete
    </p>
    <h6>
     Docker compose build
    </h6>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f6878646378792f:61727469636c652f64657461696c732f313435383032333237" class_="artid" style="display:none">
 </p>
</div>


