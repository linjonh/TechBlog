---
layout: post
title: "从0开始,手搓Tomcat"
date: 2025-03-08 22:25:27 +0800
description: "Tomcat 是一款开源的、轻量级的 Web 服务器，它不仅能够提供 HTTP 服务，还能够运行 Java Servlet 和 JavaServer Pages（JSP）。对于许多开发者来说，理解 Tomcat 的目录结构以及如何在该结构中组织应用，往往是入门的第一步。在一个实现具体操作的Servlet类中，具有如下图的继承关系是所有 Servlet 的基本接口。任何自定义的 Servlet 都必须实现这个接口或者继承一个实现了它的类。"
keywords: "从0开始，手搓Tomcat"
categories: ['未分类']
tags: ['前端', 'Tomcat', 'Firefox']
artid: "146124071"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146124071
    alt: "从0开始,手搓Tomcat"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146124071
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146124071
cover: https://bing.ee123.net/img/rand?artid=146124071
image: https://bing.ee123.net/img/rand?artid=146124071
img: https://bing.ee123.net/img/rand?artid=146124071
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     从0开始，手搓Tomcat
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="g9OH-1741443527651">
     一、什么是Tomcat
    </h2>
    <p>
     Tomcat 是一款开源的、轻量级的 Web 服务器，它不仅能够提供 HTTP 服务，还能够运行 Java Servlet 和 JavaServer Pages（JSP）。对于许多开发者来说，理解 Tomcat 的目录结构以及如何在该结构中组织应用，往往是入门的第一步。
    </p>
    <h3 id="MBoO-1741443527655">
     1、Tomcat目录结构
    </h3>
    <p>
     Tomcat 的目录结构相对简单，但每个目录和文件都有其明确的用途。
    </p>
    <p>
     <img alt="" height="830" src="https://i-blog.csdnimg.cn/direct/ee12db7c546e4da284a22ca79db27f61.png" width="819"/>
    </p>
    <h4 id="O9bW-1741443527660">
     1. bin 目录
    </h4>
    <p>
     bin 目录包含启动和停止 Tomcat 所需的脚本。它的内容包括：
    </p>
    <p>
     startup.sh/startup.bat：启动 Tomcat。
    </p>
    <p>
     shutdown.sh/shutdown.bat：停止 Tomcat。
    </p>
    <p>
     catalina.sh/catalina.bat：Tomcat 启动时的核心脚本，包含了一些启动参数的设置。
    </p>
    <p>
     setenv.sh/setenv.bat：用于设置 Tomcat 环境变量，通常用于配置 Java 堆大小、日志设置等。
    </p>
    <h4 id="2yOs-1741443527672">
     2. conf 目录
    </h4>
    <p>
     conf 目录包含 Tomcat 的核心配置文件，这些文件直接影响 Tomcat 的行为。常见的配置文件有：
    </p>
    <p>
     server.xml：Tomcat 的主要配置文件，定义了服务器的端口、连接器、虚拟主机等。
    </p>
    <p>
     web.xml：Web 应用的默认部署描述符。
    </p>
    <p>
     context.xml：为每个 Web 应用提供额外的配置。
    </p>
    <h4 id="DOhY-1741443527682">
     3. lib 目录
    </h4>
    <p>
     lib 目录存放 Tomcat 运行时所需要的 Java 类库和 JAR 包，包括：
    </p>
    <p>
     servlet-api.jar：Java Servlet API 的实现。
    </p>
    <p>
     jsp-api.jar：Java Server Pages（JSP）API 的实现。
    </p>
    <p>
     其他第三方库和 Tomcat 特有的库文件。
    </p>
    <h4 id="SuLw-1741443527692">
     4. logs 目录
    </h4>
    <p>
     logs 目录用于存储 Tomcat 启动、运行过程中的日志文件。常见的日志文件有：
    </p>
    <p>
     catalina.out：Tomcat 启动和运行时的主要日志文件。
    </p>
    <p>
     localhost_access_log.*.txt：记录每个请求的访问日志。
    </p>
    <h4 id="s3Ly-1741443527700">
     5. webapps 目录
    </h4>
    <p>
     webapps 目录是 Tomcat 的应用目录，所有部署的 Web 应用都应该放在此目录下。每个应用通常以一个文件夹的形式存在，目录中包含了应用的 WEB-INF 和 META-INF 等文件夹。
    </p>
    <h4 id="4OdQ-1741443527704">
     6. work 目录
    </h4>
    <p>
     work 目录用于存放 Tomcat 编译 JSP 文件后的中间文件。每当 Tomcat 运行一个 JSP 文件时，都会将其编译成 Java 类文件并存放在这个目录中。
    </p>
    <h4 id="8hlG-1741443527708">
     7. temp 目录
    </h4>
    <p>
     temp 目录是 Tomcat 用来存放临时文件的地方。例如，Tomcat 会将文件上传的内容存放在该目录中，处理过程中生成的临时数据也会保存在这里。
    </p>
    <h3 id="PeU0-1741443527712">
     2、Tomcat的工作目录
    </h3>
    <p>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/a9dd76380e15444f89ffc726c037a510.png" width="552"/>
    </p>
    <p>
     在apache的Tomcat中，工作目录可以简化成上图，即在webapps中进行资源的访问。资源的访问可以简单的理解为对网页的操作。
    </p>
    <h2 id="Zt4K-1741443527717">
     二、Tomcat工作原理简介
    </h2>
    <h3 id="01jV-1741443527719">
     1、Tomcat中Servlet的生命周期
    </h3>
    <p>
     在一个实现具体操作的Servlet类中，具有如下图的继承关系
    </p>
    <p>
     <img alt="" height="517" src="https://i-blog.csdnimg.cn/direct/539619dc1da946a385996a4edf87ad9e.png" width="272"/>
    </p>
    <p>
     <strong>
      javax.servlet.Servlet
     </strong>
     是所有 Servlet 的基本接口。任何自定义的 Servlet 都必须实现这个接口或者继承一个实现了它的类。该接口定义了 Servlet 的生命周期方法，例如 init(), service(), 和 destroy()，这些方法体现了Servlet的生命周期
    </p>
    <p>
     <strong>
      init(..)
     </strong>
     ：当servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来
    </p>
    <p>
     <strong>
      service(...)
     </strong>
     ：每当请求Servlet时，Servlet容器就会调用这个方法service(...)
    </p>
    <p>
     <strong>
      destroy(...)
     </strong>
     ：当要销毁Servlet时，Servlet容器就会调用这个方法
    </p>
    <p>
     <strong>
      getservletInfo(...)
     </strong>
     ：这个方法会返回Servlet的一段描述，可以返回一段字符串。
    </p>
    <p>
     <strong>
      getServletconfig(...)
     </strong>
     ：这个方法会返回由Servlet容器传给init()方法的Servletconfig对象。
    </p>
    <p>
     <strong>
      javax.servlet.GenericServlet
     </strong>
     是 Servlet 接口的一个抽象实现类。它实现了 Servlet 接口，但提供了空实现的 service() 方法。通常，自定义的 Servlet 会继承 GenericServlet，并重写 service() 方法来处理客户端请求。
    </p>
    <p>
     <strong>
      javax.servlet.http.HttpServlet
     </strong>
     是处理 HTTP 请求的抽象类，继承自 GenericServlet。大多数 Web 应用中的 Servlet 会继承 HttpServlet，因为它提供了简化的 HTTP 请求处理方法，如 doGet(), doPost(), doPut() 和 doDelete()，这些方法可以根据请求类型进行重写。同时 HttpServlet 中重写了service() 方法，对于不同的请求进行判断并划分到不同的操作中，将其拆分成doGet()方法和doPost()等七种方法，其目的是为了更好的匹配http请求。
    </p>
    <h3 id="aleP-1741443587497">
     2、Tomcat对待资源
    </h3>
    <p>
     Tomcat将资源分为动态资源和静态资源。
    </p>
    <h4 id="9QEl-1741443587501">
     1.静态资源
    </h4>
    <p>
     指内容在服务器上不会发生变化的资源，通常这些资源由服务器直接提供给客户端，不需要任何动态处理。常见的静态资源有：
    </p>
    <ul>
     <li>
      HTML 文件：静态的网页内容，直接通过浏览器访问即可展示。
     </li>
     <li>
      CSS 文件：样式表文件，用于定义网页的外观。
     </li>
     <li>
      JavaScript 文件：脚本文件，用于网页的交互行为。
     </li>
     <li>
      图片文件：如 PNG、JPEG、GIF、SVG 等图片文件。
     </li>
     <li>
      字体文件：例如 .woff, .ttf 等字体文件。
     </li>
     <li>
      视频文件：如 .mp4, .avi 等文件。
     </li>
    </ul>
    <p>
     <strong>
      Tomcat 处理静态资源的方式：
     </strong>
    </p>
    <p>
     Tomcat 会直接通过文件系统（例如 /webapps/ROOT 目录）读取静态资源，然后返回给客户端。静态资源通常会被配置在 Web 应用的 webapps 目录下。
    </p>
    <p>
     默认情况下，Tomcat 会直接将这些资源返回给客户端，除非配置了 URL 映射或者过滤器，否则不涉及任何额外的处理逻辑。
    </p>
    <h4 id="pIeH-1741443601209">
     2.动态资源
    </h4>
    <p>
     动态资源 是指在客户端请求时，服务器需要根据请求的不同，动态生成或者处理后才返回的内容。这类资源的内容是可变的，通常与用户的输入、数据库等外部数据源有关。动态资源的常见形式包括：
    </p>
    <ul>
     <li>
      Servlet：通过 Java 编写的后端代码，接收客户端请求并生成响应内容。
     </li>
     <li>
      JSP (JavaServer Pages)：与 Servlet 类似，但通过模板方式生成 HTML 内容。JSP 是动态生成 HTML 页面的一种方法。
     </li>
     <li>
      RESTful API：通常由 Servlet 或其他 Java 后端框架实现，用于为前端应用提供数据接口。
     </li>
     <li>
      WebSocket：允许在客户端与服务器之间进行双向通信的技术。
     </li>
    </ul>
    <p>
     <strong>
      Tomcat 处理动态资源的方式
     </strong>
     ：
    </p>
    <p>
     Tomcat 会将动态请求交给相应的 Servlet 或 JSP 进行处理。Servlet/JSP 会根据请求生成动态内容。请求 URL 会映射到特定的 Servlet 或 JSP，Tomcat 通过 web.xml 或注解来配置这些映射。
    </p>
    <p>
     动态资源通常通过 Servlet 或 JSP 来生成 HTTP 响应，这些响应可以是 HTML、JSON、XML 等格式，具体取决于请求和后端代码的逻辑。
    </p>
    <h4 id="J2NV-1741443628399">
     3.两种资源的区别
    </h4>
    <table>
     <tbody>
      <tr>
       <td>
        <p>
         资源类型
        </p>
       </td>
       <td>
        <p>
         需要服务器处理
        </p>
       </td>
       <td>
        <p>
         变化性
        </p>
       </td>
       <td>
        <p>
         典型示例
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         静态资源
        </p>
       </td>
       <td>
        <p>
         无
        </p>
       </td>
       <td>
        <p>
         不变
        </p>
       </td>
       <td>
        <p>
         HTML、CSS、JavaScript、图片、视频等
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         动态资源
        </p>
       </td>
       <td>
        <p>
         需要处理
        </p>
       </td>
       <td>
        <p>
         可变
        </p>
       </td>
       <td>
        <p>
         Servlet、JSP、REST API、WebSocket 等
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
     静态资源 直接由 Tomcat 提供，客户端请求时无需任何额外的动态处理。
    </p>
    <p>
     动态资源 需要通过 Servlet 或 JSP 等方式在服务器端进行处理，然后生成响应内容返回给客户端。
    </p>
    <h3 id="dis4-1741443644400">
     3、Tomcat的核心——Servlet容器
    </h3>
    <p>
     Tomcat的核心是servlet容器，本质是一个hashmap，Key值是servlet的访问路径，Value值是一般为servlet对象。在启动tomcat时，动态资源加载到servlet容器中
    </p>
    <p>
     http请求打到servlet容器中，进行key值对比，如果访问动态资源，则调用servlet对象
    </p>
    <p>
     需要注意的一点是，在Tomcat启动时，就需要把动态资源加载到Servlet容器中。
    </p>
    <p>
     <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/da4a246219da43e3b775238208466328.png" width="1185"/>
    </p>
    <h3 id="CyxV-1741443644409">
     4、Tomcat处理http请求
    </h3>
    <p>
     Tomcat 生成一个socket对象，用于接收和处理http请求，从请求中解析出请求类型和需要的资源，交给Servlet容器中的Servlet对象去处理
    </p>
    <p>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/c79ee05251b0493191a90b6f0b2d0e99.png" width="1491"/>
    </p>
    <h2 id="c7NR-1741443644414">
     三、简易Tomcat实现
    </h2>
    <h3 id="MKLV-1741443644416">
     1、目录结构
    </h3>
    <p>
     <img alt="" height="620" src="https://i-blog.csdnimg.cn/direct/16054f96ec9849a2806d3f2ed6edf5aa.png" width="454"/>
    </p>
    <p>
     这样设计为区分不同功能的Java文件。
    </p>
    <p>
     需要指出的是，这里创建项目不是普通的Java项目，需要选择Maven项目，只需设置项目名称即可，其他默认即可，项目名不要有中文。
    </p>
    <p>
     <img alt="" height="567" src="https://i-blog.csdnimg.cn/direct/dd7317f9313d4a8cae176c6985175db7.png" width="952"/>
    </p>
    <h3 id="aPm2-1741443644424">
     2、实现继承关系
    </h3>
    <p>
     Servlet接口
    </p>
    <pre><code class="language-java">package com.tom2.servlet;

import com.tom2.servlet.Re.HttpRequest;
import com.tom2.servlet.Re.HttpResponse;

public interface Servlet {
    public abstract void init();
    public abstract void destory();
    public abstract void service(HttpRequest request, HttpResponse response) throws Exception;
}</code></pre>
    <p>
     GenericServlet抽象类
    </p>
    <pre><code class="language-java">package com.tom2.servlet;

import com.tom2.servlet.Re.HttpRequest;
import com.tom2.servlet.Re.HttpResponse;

public abstract class GenericServlet implements Servlet{

    @Override
    public void init() {
        System.out.println("genservlet 的init");
    }

    @Override
    public void destory() {
        System.out.println("genservlet 的destory");
    }
}</code></pre>
    <p>
     HttpServlet 抽象类
    </p>
    <pre><code class="language-java">package com.tom2.servlet;

import com.tom2.servlet.Re.HttpRequest;
import com.tom2.servlet.Re.HttpResponse;

public abstract class HttpServlet extends GenericServlet{
    @Override
    public void service(HttpRequest request, HttpResponse response) throws Exception {
        if(request.getMethod().equals("GET")){
            doGet(request,response);
        }else if(request.getMethod().equals("POST")){
            doPost(request,response);
        }
    }

    public abstract void doGet(HttpRequest request, HttpResponse response) throws Exception;
    public abstract void doPost(HttpRequest request, HttpResponse response) throws Exception;

}</code></pre>
    <p>
     HttpRequest 和 HttpResponse
    </p>
    <pre><code class="language-java">package com.tom2.servlet.Re;

public class HttpRequest {
    private String path;
    private String method;

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getMethod() {
        return method;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    @Override
    public String toString() {
        return "HttpRequest{" +
                "path='" + path + '\'' +
                ", method='" + method + '\'' +
                '}';
    }
}

package com.tom2.servlet.Re;

import java.io.IOException;
import java.io.OutputStream;

public class HttpResponse {
    private OutputStream outputStream;

    public  HttpResponse(OutputStream outputStream){
        this.outputStream=outputStream;
    }

    public void writeResponse(String context) throws IOException {
        outputStream.write(context.getBytes());
    }

}</code></pre>
    <h3 id="8zYq-1741443825286">
     3、工具类
    </h3>
    <p>
     SearchClassUtil ：利用反射进行类信息的查找。扫描指定的 Java 包目录，查找所有 .class 文件，并提取每个 .class 文件的全类名，将这些类名存储在一个 List 列表中。
    </p>
    <pre><code class="language-java">package com.tom2.Util;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * 扫描 com.qcby.webapps 目录下的 Java 文件并获取每个类的全名
 */
public class SearchClassUtil {
    public static List&lt;String&gt; classPaths = new ArrayList&lt;String&gt;();
    public static List&lt;String&gt; searchClass() {
        // 需要扫描的包名
        String basePack = "com.tom2.webapps";
        // 将包名转换为路径格式
        String classPath = SearchClassUtil.class.getClassLoader().getResource("").getPath();

        basePack = basePack.replace(".", File.separator);

        if(classPath.startsWith("file:")){
            classPath.substring(5);
        }
        String searchPath = classPath + basePack;

        // 确保路径在开发环境和打包后的环境下都能正确处理
        File searchDir = new File(searchPath);
        if (!searchDir.exists()) {
            // 如果路径不存在，尝试扫描 target/classes 目录
            searchPath = "target/classes"+File.separator+basePack;
            searchDir = new File(searchPath);
        }

        // 调用 doPath 方法递归扫描文件
        doPath(searchDir, classPath);

        // 返回扫描到的类路径列表
        return classPaths;
    }

    /**
     * 递归处理文件，找到 .class 文件并将其全类名添加到 classPaths 列表中
     */
    private static void doPath(File file, String classpath) {
        if (file.isDirectory()) {
            // 如果是目录，递归处理子目录
            File[] files = file.listFiles();
            if (files != null) {
                for (File f1 : files) {
                    doPath(f1, classpath);
                }
            }
        } else {
            // 如果是 .class 文件，提取类名
            if (file.getName().endsWith(".class")) {
                // 修正路径替换：不使用 replaceFirst，而直接使用 replace
                String path = file.getPath()
                        .replace(classpath, "") // 直接使用 classpath，不再替换 "/" 为 File.separator
                        .replace(File.separator, ".")
                        .replace(".class", "");
                if(path.startsWith("targetes.")){
                    path = path.substring("targetes.".length());
                }

                // 将类名添加到 classPaths 列表
                classPaths.add(path);
            }
        }
    }

    public static void main(String[] args) {
        List&lt;String&gt; classes = SearchClassUtil.searchClass();
        for (String s : classes) {
            System.out.println(s);
        }
    }
}</code></pre>
    <p>
     WebServlet：注解
    </p>
    <pre><code class="language-java">package com.tom2.Util;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface WebServlet {
    String urlMapping() default "";
}</code></pre>
    <p>
     ResponseUtil
    </p>
    <pre><code class="language-java">package com.tom2.Util;

public class ResponseUtil {
    public  static  final String responseHeader200 = "HTTP/1.1 200 \r\n"+
            "Content-Type:text/html; charset=utf-8 \r\n"+"\r\n";

    public static String getResponseHeader404(){
        return "HTTP/1.1 404 \r\n"+
                "Content-Type:text/html; charset=utf-8 \r\n"+"\r\n" + "404";
    }

    public static String getResponseHeader200(String context){
        return "HTTP/1.1 200 \r\n"+
                "Content-Type:text/html; charset=utf-8 \r\n"+"\r\n" + context;
    }
}</code></pre>
    <h3 id="VuoP-1741443866323">
     5、模拟Servlet容器
    </h3>
    <p>
     SearchServlet
    </p>
    <pre><code class="language-java">package com.tom2;

import com.tom2.Util.SearchClassUtil;
import com.tom2.Util.WebServlet;
import com.tom2.servlet.HttpServlet;
import java.util.*;

public class SearchServlet {
    public static Map&lt;String, HttpServlet&gt; servletmap = new HashMap&lt;&gt;();

    static {
        List&lt;String&gt; classpath = SearchClassUtil.searchClass();
        for(String path:classpath){
            System.out.println(path);
        }
        for(String path:classpath){
            try{
                Class clazz = Class.forName(path);
                WebServlet webServlet = (WebServlet) clazz.getDeclaredAnnotation(WebServlet.class);
                HttpServlet httpServlet = (HttpServlet) clazz.getDeclaredConstructor().newInstance();
                servletmap.put(webServlet.urlMapping(),httpServlet);
            }catch(Exception e){
                e.printStackTrace();
            }

        }
    }

}</code></pre>
    <h3 id="7fQn-1741443875978">
     6、动态资源
    </h3>
    <p>
     Login
    </p>
    <pre><code class="language-java">package com.tom2.webapps.myweb;

import com.tom2.Util.WebServlet;
import com.tom2.servlet.HttpServlet;
import com.tom2.servlet.Re.HttpRequest;
import com.tom2.servlet.Re.HttpResponse;
@WebServlet(urlMapping = "/login")
public class Login extends HttpServlet {
    @Override
    public void doGet(HttpRequest request, HttpResponse response) throws Exception {
        System.out.println("俺是login的doGet");
    }

    @Override
    public void doPost(HttpRequest request, HttpResponse response) throws Exception {

    }
}</code></pre>
    <p>
     Show
    </p>
    <pre><code class="language-java">package com.tom2.webapps.myweb;
import com.tom2.Util.ResponseUtil;
import com.tom2.Util.WebServlet;
import com.tom2.servlet.HttpServlet;
import com.tom2.servlet.Re.HttpRequest;
import com.tom2.servlet.Re.HttpResponse;
@WebServlet(urlMapping = "/show")
public class Show extends HttpServlet {
    @Override
    public void doGet(HttpRequest request, HttpResponse response) throws Exception {
        response.writeResponse(ResponseUtil.getResponseHeader200("俺是Show的doGet"));
    }

    @Override
    public void doPost(HttpRequest request, HttpResponse response) throws Exception {

    }
}</code></pre>
    <h3 id="BCQK-1741443899689">
     7、主方法
    </h3>
    <p>
     MyTomcat
    </p>
    <pre><code class="language-java">package com.tom2;

import com.tom2.servlet.HttpServlet;
import com.tom2.servlet.Re.HttpRequest;
import com.tom2.servlet.Re.HttpResponse;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class MyTomcat {
    private static HttpRequest httpRequest = new HttpRequest();

    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(8080);
        while(true){
            Socket socket = serverSocket.accept();
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream = socket.getOutputStream();
            HttpResponse httpResponse = new HttpResponse(outputStream);

            int len = 0;
            while(len==0){
                len = inputStream.available();
            }
            byte[] bytes = new byte[len];
            inputStream.read(bytes);
            String context = new String(bytes);
            System.out.println(context);
            if(context.equals("")){
                System.out.println("空请求");
            }else{
                String line1 = context.split("\\n")[0];
                String method = line1.split("\\s")[0];
                String path = line1.split("\\s")[1];
                httpRequest.setMethod(method);
                httpRequest.setPath(path);
            }
            System.out.println(SearchServlet.servletmap.containsKey(httpRequest.getPath()));
            if(SearchServlet.servletmap.containsKey(httpRequest.getPath())){
                HttpServlet httpServlet = SearchServlet.servletmap.get(httpRequest.getPath());
                httpServlet.service(httpRequest,httpResponse);
            }
        }
    }
}</code></pre>
    <h3 id="y267-1741443912768">
     8、模拟效果
    </h3>
    <p>
     在浏览器地址栏中输入：localhost:8080/login
    </p>
    <p>
     <img alt="" height="1029" src="https://i-blog.csdnimg.cn/direct/9de0966fb5b949ca91f6436b995bea0c.png" width="1920"/>
    </p>
    <p>
     在浏览器地址栏中输入：localhost:8080/show
    </p>
    <p>
     <img alt="" height="1029" src="https://i-blog.csdnimg.cn/direct/cdd62d836c80459bae50c8cb758843f8.png" width="1920"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37353236303039392f:61727469636c652f64657461696c732f313436313234303731" class_="artid" style="display:none">
 </p>
</div>


