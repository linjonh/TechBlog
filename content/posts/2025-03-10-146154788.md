---
layout: post
title: "MATLAB并行计算加速,用-parfor-和-spmd-榨干多核CPU性能"
date: 2025-03-10 15:10:19 +0800
description: "在需要处理大规模数据或复杂计算的场景中，MATLAB的并行计算工具箱（Parallel Computing Toolbox）可让程序运行速度成倍提升。parfor（并行循环）和spmd（单程序多数据）是两个核心工具，本文将结合性能加速原理、代码实战和避坑指南，助你彻底掌握多核性能优化技巧。"
keywords: "MATLAB并行计算加速，用 parfor 和 spmd 榨干多核CPU性能"
categories: ['未分类']
tags: ['开发语言', 'Matlab']
artid: "146154788"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146154788
    alt: "MATLAB并行计算加速,用-parfor-和-spmd-榨干多核CPU性能"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146154788
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146154788
cover: https://bing.ee123.net/img/rand?artid=146154788
image: https://bing.ee123.net/img/rand?artid=146154788
img: https://bing.ee123.net/img/rand?artid=146154788
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MATLAB并行计算加速，用 parfor 和 spmd 榨干多核CPU性能
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在需要处理大规模数据或复杂计算的场景中，MATLAB的并行计算工具箱（Parallel Computing Toolbox）可让程序运行速度成倍提升。
     <code>
      parfor
     </code>
     （并行循环）和
     <code>
      spmd
     </code>
     （单程序多数据）是两个核心工具，本文将结合
     <strong>
      性能加速原理
     </strong>
     、
     <strong>
      代码实战
     </strong>
     和
     <strong>
      避坑指南
     </strong>
     ，助你彻底掌握多核性能优化技巧。
    </p>
    <h3>
     一、
     <strong>
      并行计算基础配置
     </strong>
    </h3>
    <h4>
     1. 启动与关闭并行池
    </h4>
    <ul>
     <li>
      <strong>
       手动启动
      </strong>
      ：
      <pre><code>parpool;       % 启动默认配置的并行池（一般为核心数）
parpool(4);    % 指定4个worker进程
</code></pre>
     </li>
     <li>
      <strong>
       自动关闭
      </strong>
      ：
      <pre><code>delete(gcp('nocreate'));  % 关闭当前所有并行池</code></pre>
     </li>
    </ul>
    <h4>
     2. 硬件资源确认
    </h4>
    <ul>
     <li>
      <strong>
       查看可用核心数
      </strong>
      ：
      <pre><code>numWorkers = parcluster('local').NumWorkers;  % 返回可用的最大worker数</code></pre>
     </li>
    </ul>
    <hr/>
    <h3>
     二、
     <strong>
      parfor：并行循环的黄金法则
     </strong>
    </h3>
    <h4>
     1. 适用条件
    </h4>
    <ul>
     <li>
      循环迭代相互独立，无数据依赖。
     </li>
     <li>
      循环体足够耗时（单次循环耗时&gt;毫秒级）。
     </li>
    </ul>
    <h4>
     2. 基础用法
    </h4>
    <p>
     将普通
     <code>
      for
     </code>
     循环替换为
     <code>
      parfor
     </code>
     ：
    </p>
    <pre><code>% 定义一个耗时函数
function result = timeConsumingFunc(x)
    % 模拟耗时操作，例如进行大量的循环
    for j = 1:100000
        % 这里可以是任何需要时间的计算
        temp = x * j;
    end
    result = x;
end

% 串行代码计时
tic;
results_serial = zeros(1, 1000);
for i = 1:10000
    results_serial(i) = timeConsumingFunc(i);  
end
serial_time = toc;

% 并行代码计时
tic;
results_parallel = zeros(1, 1000);
parfor i = 1:10000
    results_parallel(i) = timeConsumingFunc(i);  
end
parallel_time = toc;

% 输出结果
fprintf('串行代码执行时间: %.6f 秒\n', serial_time);
fprintf('并行代码执行时间: %.6f 秒\n', parallel_time);
</code></pre>
    <p>
     <img alt="" height="54" src="https://i-blog.csdnimg.cn/direct/4eea44aae38a43f380d2564174968039.png" width="351">
     </img>
    </p>
    <h4>
     3.
     <strong>
      变量分类（关键！）
     </strong>
    </h4>
    <p>
     <strong>
      变量类型决定了是否可并行化：
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         分类
        </strong>
       </th>
       <th>
        <strong>
         解释
        </strong>
       </th>
       <th>
        <strong>
         示例
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        Loop Variable
       </td>
       <td>
        每次迭代独立（自动处理）
       </td>
       <td>
        <code>
         i
        </code>
        in
        <code>
         parfor i=1:N
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Sliced Variable
       </td>
       <td>
        按索引独立切分的数组（自动广播）
       </td>
       <td>
        <code>
         results(i)
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Broadcast
       </td>
       <td>
        所有worker共享的只读变量
       </td>
       <td>
        常量参数、大型查找表
       </td>
      </tr>
      <tr>
       <td>
        Temporary
       </td>
       <td>
        在单个迭代内创建和销毁的变量
       </td>
       <td>
        循环中的中间计算结果
       </td>
      </tr>
      <tr>
       <td>
        Reduction
       </td>
       <td>
        从各迭代聚合结果的变量（需满足结合律）
       </td>
       <td>
        <code>
         sum
        </code>
        ,
        <code>
         max
        </code>
        ,
        <code>
         end
        </code>
        操作
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      避坑案例
     </strong>
     ：无法切分的变量会报错
    </p>
    <pre><code>% 错误：parfor无法识别数组索引方式
parfor i = 1:N
    A(:,i) = computeColumn(i);  % ❌ A被视为整个数组（非Slice变量）
end

% 正确：预分配切片变量
B = zeros(M,N);
parfor i = 1:N
    B(:,i) = computeColumn(i);  % ✅ B已被正确切分
end
</code></pre>
    <hr/>
    <h3>
     三、
     <strong>
      spmd：灵活的任务分发与协作
     </strong>
    </h3>
    <h4>
     1. 核心优势
    </h4>
    <ul>
     <li>
      <strong>
       数据划分灵活
      </strong>
      ：手动控制每个worker处理的数据块。
     </li>
     <li>
      <strong>
       worker间通信
      </strong>
      ：支持
      <code>
       labSend
      </code>
      和
      <code>
       labReceive
      </code>
      传递数据。
     </li>
    </ul>
    <h4>
     2. 基础应用
    </h4>
    <p>
     将数据分布到不同worker独立计算：
    </p>
    <pre><code>spmd
    % 每个worker获取数据区块
    workerID = labindex;       % 当前worker编号（1到N）
    totalWorkers = numlabs;    % 总worker数
    
    % 手动划分数据块
    chunkSize = ceil(N / totalWorkers);
    startIdx = (workerID-1)*chunkSize + 1;
    endIdx = min(workerID*chunkSize, N);
    
    % 各worker处理自己的数据块
    localResult = processChunk(data(startIdx:endIdx));
end

% 收集各worker的结果（每个worker的localResult存在chunk{1}, chunk{2}...）
globalResult = [localResult{:}];
</code></pre>
    <h4>
     3. 常见模式
    </h4>
    <p>
     例子
    </p>
    <pre><code>% 定义耗时操作函数
function result = timeConsumingFunction(x)
    % 模拟耗时操作，多次乘法
    for iter = 1:1000
        x = x * 1.001;
    end
    result = x;
end

% 串行代码计时
tic;
matrixSize = 1000;
serialMatrix = rand(matrixSize);
for row = 1:matrixSize
    for col = 1:matrixSize
        serialMatrix(row, col) = timeConsumingFunction(serialMatrix(row, col));
    end
end
serialTime = toc;

% 并行代码计时
tic;
if ~exist('gcp', 'file') || isempty(gcp('nocreate'))
    parpool('local');
end
parallelMatrix = rand(matrixSize);
spmd
    % 获取当前工作进程编号
    localLab = labindex;
    % 计算每个工作进程处理的行数
    rowsPerLab = ceil(matrixSize / numlabs);
    startRow = (localLab - 1) * rowsPerLab + 1;
    endRow = min(localLab * rowsPerLab, matrixSize);
    localMatrix = parallelMatrix(startRow:endRow, :);
    % 对局部矩阵进行耗时操作
    [rows, cols] = size(localMatrix);
    for row = 1:rows
        for col = 1:cols
            localMatrix(row, col) = timeConsumingFunction(localMatrix(row, col));
        end
    end
    % 将处理后的局部矩阵发送回客户端
    parallelMatrix(startRow:endRow, :) = localMatrix;
end
parallelTime = toc;

% 输出结果
fprintf('串行代码执行时间: %.6f 秒\n', serialTime);
fprintf('spmd 并行代码执行时间: %.6f 秒\n', parallelTime);

% 检查结果是否一致
if isequal(serialMatrix, parallelMatrix)
    fprintf('串行和并行结果一致。\n');
else
    fprintf('串行和并行结果不一致。\n');
end</code></pre>
    <p>
     <img alt="" height="78" src="https://i-blog.csdnimg.cn/direct/8c7c65d3804144d0839e031eee531448.png" width="396">
     </img>
    </p>
    <hr/>
    <h3>
     四、
     <strong>
      性能对比：parfor vs spmd
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         特性
        </strong>
       </th>
       <th>
        <strong>
         parfor
        </strong>
       </th>
       <th>
        <strong>
         spmd
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        简单数据并行（无迭代依赖）
       </td>
       <td>
        复杂任务划分、需要显式通信的场景
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         编程复杂度
        </strong>
       </td>
       <td>
        低（自动分配）
       </td>
       <td>
        高（手动控制）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据分布
        </strong>
       </td>
       <td>
        隐式切分（根据循环索引）
       </td>
       <td>
        显式通过
        <code>
         codistributed
        </code>
        分配
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         资源利用效率
        </strong>
       </td>
       <td>
        更适用于粗粒度任务（循环体耗时较长）
       </td>
       <td>
        适用于细粒度任务
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         内存消耗
        </strong>
       </td>
       <td>
        可能复制较多数据到worker
       </td>
       <td>
        可手动优化数据分布减少内存占用
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     五、
     <strong>
      性能优化技巧
     </strong>
    </h3>
    <h4>
     1.
     <strong>
      减少数据传输负载
     </strong>
    </h4>
    <ul>
     <li>
      使用
      <code>
       Parallel Computing Toolbox
      </code>
      的分布式数组（如
      <code>
       distributed
      </code>
      和
      <code>
       codistributed
      </code>
      ）。
     </li>
     <li>
      避免在循环中频繁传输大数组。
     </li>
    </ul>
    <h4>
     2.
     <strong>
      平衡任务分配
     </strong>
    </h4>
    <ul>
     <li>
      确保各worker的计算量接近，避免“拖后腿”。
     </li>
     <li>
      <strong>
       动态调度
      </strong>
      （针对任务不均的情况）：
      <pre><code>% 取消worker的命令行输出
parfor i = 1:N
    evalc('timeConsumingFunc(i)');  % 静默执行
end
</code></pre>
     </li>
    </ul>
    <h4>
     3.
     <strong>
      抑制不必要的输出
     </strong>
    </h4>
    <p>
     关闭worker的冗余输出提升性能：
    </p>
    <pre><code>% 取消worker的命令行输出
parfor i = 1:N
    evalc('timeConsumingFunc(i)');  % 静默执行
end
</code></pre>
    <hr/>
    <h3>
     六、
     <strong>
      避坑指南：常见错误与解法
     </strong>
    </h3>
    <h4>
     1.
     <strong>
      并行开销过高
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       症状
      </strong>
      ：并行后速度反而下降。
     </li>
     <li>
      <strong>
       对策
      </strong>
      ：确保每次迭代计算时间足够长（&gt;100毫秒）。
     </li>
    </ul>
    <h4>
     2.
     <strong>
      内存溢出（Out of Memory）
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       解法
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         distributed
        </code>
        分割数据集。
       </li>
       <li>
        设置更大的JVM堆内存（
        <code>
         memory
        </code>
        命令）。
       </li>
       <li>
        清理不再需要的变量（
        <code>
         clear
        </code>
        ）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     3.
     <strong>
      无法在parfor中调用外部函数
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       解法
      </strong>
      ：将被调函数添加到
      <code>
       AddAttachedFiles
      </code>
      （针对云集群）。
      <pre><code>c = parcluster;c.addAttachedFiles('myUtilityFunc.m');</code></pre>
     </li>
    </ul>
    <hr/>
    <h3>
    </h3>
    <h3>
     七、
     <strong>
      性能评估工具
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        时间测量
       </strong>
       ：
      </p>
      <pre><code>tic;
parfor ... 
toc;  % 显示并行耗时
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        任务监控
       </strong>
       ：
      </p>
      <pre><code>% 查看并行池状态
disp(parcluster('local'));

% 使用Profile查看并行负载分布
mpiprofile on;
parfor ...
mpiprofile viewer;
</code></pre>
     </li>
    </ul>
    <hr/>
    <p>
     掌握上述技巧后，您可以将MATLAB的并行计算能力发挥到极致。
     <strong>
      关键策略总结
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       粗粒度优先
      </strong>
      ：优先用
      <code>
       parfor
      </code>
      处理简单循环，易上手且效果显著。
     </li>
     <li>
      <strong>
       精细控制
      </strong>
      ：需要复杂通信或数据分配时切换到
      <code>
       spmd
      </code>
      。
     </li>
     <li>
      <strong>
       持续监测
      </strong>
      ：通过工具评估加速比，确保资源高效利用。
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33313236383735392f:61727469636c652f64657461696c732f313436313534373838" class_="artid" style="display:none">
 </p>
</div>


