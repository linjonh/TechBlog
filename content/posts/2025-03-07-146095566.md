---
layout: post
title: "langchain系列九-LangGraph-子图详解"
date: 2025-03-07 15:15:55 +0800
description: "本文主要说明LangGraph的子图代码实现以及原理简介，涉及到子图通信、人机交互、历史回溯、子图更改state、更改节点、更改子图等内容，本文也是作为多智能体的铺垫。多智能体结束后，本系列文章也就结束了。"
keywords: "langchain系列（九）- LangGraph 子图详解"
categories: ['大语言模型']
tags: ['Langgraph', 'Langchain']
artid: "146095566"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146095566
    alt: "langchain系列九-LangGraph-子图详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146095566
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146095566
cover: https://bing.ee123.net/img/rand?artid=146095566
image: https://bing.ee123.net/img/rand?artid=146095566
img: https://bing.ee123.net/img/rand?artid=146095566
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     langchain系列（九）- LangGraph 子图详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%AF%BC%E8%AF%BB" name="%E4%B8%80%E3%80%81%E5%AF%BC%E8%AF%BB">
     一、导读
    </h2>
    <p>
     环境：OpenEuler、Windows 11、WSL 2、Python 3.12.3 langchain 0.3 langgraph 0.2
    </p>
    <p>
     背景：前期忙碌的开发阶段结束，需要沉淀自己的应用知识，过一遍LangGraph
    </p>
    <p>
     时间：20250307
    </p>
    <p>
     说明：技术梳理，LangGraph 的多代理（多智能体）可以基于子图实现，此处对子图进行说明，案例基于官方文档进行部分的修改
    </p>
    <p>
     官方文档地址：
     <a href="https://langchain-ai.github.io/langgraph/how-tos/subgraphs-manage-state/" rel="nofollow" title="LangGraph 子图实现">
      LangGraph 子图实现
     </a>
    </p>
    <h2 id="%C2%A0%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E" name="%C2%A0%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E">
     二、原理说明
    </h2>
    <h3 id="1%E3%80%81%E7%AE%80%E4%BB%8B" name="1%E3%80%81%E7%AE%80%E4%BB%8B">
     1、简介
    </h3>
    <p>
     子图允许构建具有多个组件的复杂系统，这些组件本身是图。使用子图的常见用例是构建多代理系统。子图其本质就是一个节点，只不过该节点是一个图而已。由此可知：也有孙子图、曾孙子图等
    </p>
    <p>
     在添加子图时，主要问题是父图和子图如何进行通信，即它们如何在图执行期间相互传递状态。这里有两种情况：
    </p>
    <p>
     父图和子图共享
     <strong>
      state
     </strong>
     。在这种情况下，您可以添加一个编译后的子图节点
    </p>
    <p>
     父图和子图具有不同的
     <strong>
      state
     </strong>
     。在这种情况下，您必须添加一个调用子图的节点函数：当父图和子图具有不同的状态模式时，这在调用子图之前或之后需要转换状态时很有用
    </p>
    <h3 id="2%E3%80%81%E5%AD%90%E5%9B%BE%E5%9B%BE%E7%A4%BA" name="2%E3%80%81%E5%AD%90%E5%9B%BE%E5%9B%BE%E7%A4%BA">
     2、子图图示
    </h3>
    <p>
     主节点具有选择性，分别是subgraph1、subgraph2
    </p>
    <p>
     <img alt="" height="818" src="https://i-blog.csdnimg.cn/direct/a021549822cc40ad9ee8cbe682f7cdec.png" width="1177"/>
    </p>
    <h3 id="3%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" name="3%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">
     3、使用说明
    </h3>
    <p>
     一种常见的情况是父图和子图通过共享state进行通信。例如，在多代理系统中，代理通常通过共享的state进行通信。
    </p>
    <p>
     如果你的子图与父图共享state，你可以按照以下步骤将其添加到父图中：
    </p>
    <p>
     定义子图工作流（如下例中的subgraph_builder）并进行编译
    </p>
    <p>
     在定义父图工作流时，将编译后的子图传递给.add_node方法
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" name="%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">
     三、基础代码实现
    </h2>
    <h3 id="1%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD" name="1%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD">
     1、实现功能
    </h3>
    <p>
     开始节点进行意图分类，如果天气相关则走天气相关的子图；否则走智能助手节点。
    </p>
    <h3 id="2%E3%80%81Graph%20%E5%9B%BE%E7%A4%BA" name="2%E3%80%81Graph%20%E5%9B%BE%E7%A4%BA">
     2、Graph 图示
    </h3>
    <p>
     <img alt="" height="482" src="https://i-blog.csdnimg.cn/direct/64034c2f416d4a7b83cb412f4a268f1a.png" width="405"/>
    </p>
    <h3 id="3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" name="3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">
     3、代码实现
    </h3>
    <pre><code class="language-python">from langgraph.graph import StateGraph, END, START, MessagesState
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from typing import Literal
from langgraph.checkpoint.memory import MemorySaver

@tool
def get_weather(city: str):
    """获取天气信息"""
    return f"{city}，晴空万里，阳光明媚!"

# 添加记忆存储
memory = MemorySaver()

# 配置信息，用于记录对话记录
config = {"configurable": {"thread_id": "1"}}


# 指定大模型的API Key 等相关信息
llm = ChatOpenAI(
    base_url="https://lxxxxx.enovo.com/v1/", 
    api_key="sxxxxxxxwW",
    model_name="qwen2.5-instruct"
    )


# 绑定工具
model = raw_model.bind_tools([get_weather])

# 子图的state
class SubGraphState(MessagesState):
    city: str

# 识别地点（城市）
def model_node(state: SubGraphState):
    system_message = """用户的问题是某个地方的天气问题，请辨别具体城市名称，并输出城市名称。"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    result = raw_model.invoke(messages)
    return {"city": result.content}

# 天气工具节点
def weather_node(state: SubGraphState):
    result = get_weather.invoke({"city": state["city"]})
    return {"messages": [{"role": "assistant", "content": result}]}

# 子图的添加节点、边以及编译图
subgraph = StateGraph(SubGraphState)
subgraph.add_node(model_node)
subgraph.add_node(weather_node)
subgraph.add_edge(START, "model_node")
subgraph.add_edge("model_node", "weather_node")
subgraph.add_edge("weather_node", END)
subgraph = subgraph.compile()

# 意图分类state
class RouterState(MessagesState):
    route: Literal["天气", "其他"]

# 意图分类节点
def router_node(state: RouterState):
    system_message = """用户输入与天气相关则输出"天气"，与天气无关返回"其他”"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    route = raw_model.invoke(messages)
    return {"route": route.content}

# 智能助手节点
def normal_llm_node(state: RouterState):
    response = raw_model.invoke(state["messages"])
    return {"messages": [response]}

# 选择边函数
def route_after_prediction(state: RouterState):
    if state["route"] == "天气":
        return "weather_graph"
    else:
        return "normal_llm_node"

# 父图的添加边、节点以及编译父图
graph = StateGraph(RouterState)
graph.add_node(router_node)
graph.add_node(normal_llm_node)
# 将子图作为一个节点添加到父图中
graph.add_node("weather_graph", subgraph)
graph.add_edge(START, "router_node")
graph.add_conditional_edges("router_node", route_after_prediction)
graph.add_edge("normal_llm_node", END)
graph.add_edge("weather_graph", END)
graph = graph.compile(checkpointer=memory)


# 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)

# 设置聊天退出方法
while True:
    try:
        user_input = input("User: ")
        if user_input.lower() in ["quit", "exit", "q"]:
            print("Goodbye!")
            break

        stream_graph_updates(user_input)
    except Exception as e:
        print(e)
        user_input = "What do you know about LangGraph?"
        print("User: " + user_input)
        stream_graph_updates(user_input)
        break</code></pre>
    <h3 id="4%E3%80%81%E8%BE%93%E5%87%BA" name="4%E3%80%81%E8%BE%93%E5%87%BA">
     4、输出
    </h3>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      Assistant: 北京，晴空万里，阳光明媚!
      <br/>
      User: hi
      <br/>
      Assistant: Hello! How can I assist you today?
      <br/>
      User: 天津的天气怎么样
      <br/>
      Assistant: 天津，晴空万里，阳光明媚!
     </p>
    </blockquote>
    <h3 id="5%E3%80%81%E5%88%86%E6%9E%90" name="5%E3%80%81%E5%88%86%E6%9E%90">
     5、分析
    </h3>
    <p>
     据上述输出可知，询问天气则会返回相关信息；其他对话内容会按照普通助手功能回复。
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92" name="%E5%9B%9B%E3%80%81%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92">
     四、人机交互
    </h2>
    <h3 id="1%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD" name="1%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD">
     1、实现中断
    </h3>
    <p>
     子图实现中断仅需在编译的时候添加
     <strong>
      interrupt_before=["节点名称"]
     </strong>
     ，修改如下：
    </p>
    <pre><code class="language-python">subgraph = subgraph.compile(interrupt_before=["weather_node"])</code></pre>
    <p>
     这样修改就会导致在
     <strong>
      weather_node
     </strong>
     发生中断，且输出值为
     <strong>
      {'__interrupt__': ()}
     </strong>
     ，所以判断该dict是否存在__interrupt__即可。
    </p>
    <p>
     调用图的地方进行判断，如下：
    </p>
    <pre><code class="language-python">def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)</code></pre>
    <p>
     循环输出内容如下：
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      User:
     </p>
    </blockquote>
    <h3 id="2%E3%80%81%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%EF%BC%88%E7%88%B6%E5%9B%BE%EF%BC%89" name="2%E3%80%81%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%EF%BC%88%E7%88%B6%E5%9B%BE%EF%BC%89">
     2、历史状态（父图）
    </h3>
    <p>
     由于此时运行状态已经到了
     <strong>
      while True:
     </strong>
     ，所以此时也不存在graph等变量信息。
    </p>
    <p>
     所以，想要实现人机交互，需要在输出
     <strong>
      中断
     </strong>
     的地方即：
     <strong>
      print("中断")
     </strong>
     ，下方执行逻辑并恢复状态
    </p>
    <p>
     添加如下代码，来查看所有的历史节点
    </p>
    <pre><code class="language-python">for h in graph.get_state_history(config=config):
    print(h.next)
else:
    print("遍历结束")</code></pre>
    <p>
     其输出信息如下：
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      ('weather_graph',)
      <br/>
      ('router_node',)
      <br/>
      ('__start__',)
      <br/>
      遍历结束
      <br/>
      User:
     </p>
    </blockquote>
    <h3 id="3%E3%80%81%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%EF%BC%88%E5%AD%90%E5%9B%BE%EF%BC%89" name="3%E3%80%81%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%EF%BC%88%E5%AD%90%E5%9B%BE%EF%BC%89">
     3、历史状态（子图）
    </h3>
    <p>
     显然，存在问题，由上述的Graph图示可知，该问题到达了
     <strong>
      model_node
     </strong>
     节点，但是遍历却没有。该问题是由于子图的问题。如何查询所有的遍历呢？weather_graph是子图，可以先获取子图的state，然后再遍历子图的历史记录，方法如下
    </p>
    <pre><code class="language-python"># 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
            for h in graph.get_state_history(config): 
                print(h.next)
                if h.next == ("weather_graph",):
                    weather_graph_state = h.tasks[0].state
            for h in graph.get_state_history(weather_graph_state):
                print(h.next)
                if h.next == ("model_node",):
                    model_node_state = h

            print(model_node_state.next)
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)</code></pre>
    <p>
     此处代码为了遍历所有，并未将判断后就停止遍历
    </p>
    <p>
     输出内容
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      ('weather_graph',)
      <br/>
      ('router_node',)
      <br/>
      ('__start__',)
      <br/>
      ('weather_node',)
      <br/>
      ('model_node',)
      <br/>
      ('__start__',)
      <br/>
      ('model_node',)
      <br/>
      User:
     </p>
    </blockquote>
    <p>
     最开始打印的是父图的节点信息，获得子图的state后，定义为weather_graph_state，之后遍历
     <strong>
      weather_graph_state
     </strong>
     的历史记录，找到指定的
     <strong>
      model_node
     </strong>
     ，抵达目标历史记录定位。
    </p>
    <h3 id="4%E3%80%81%E5%8E%86%E5%8F%B2%E5%9B%9E%E6%BA%AF" name="4%E3%80%81%E5%8E%86%E5%8F%B2%E5%9B%9E%E6%BA%AF">
     4、历史回溯
    </h3>
    <p>
     实现时空穿梭，此时如果在
     <strong>
      print(model_node_state.next)
     </strong>
     下添加
     <strong>
      stream_graph_updates(user_input)
     </strong>
     ，如果
     <strong>
      user_input
     </strong>
     发生变化，则按照逻辑去执行，反之实现死循环，部分代码如下：
    </p>
    <pre><code class="language-python"># 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
            for h in graph.get_state_history(config): 
                print(h.next)
                if h.next == ("weather_graph",):
                    weather_graph_state = h.tasks[0].state
            for h in graph.get_state_history(weather_graph_state):
                print(h.next)
                if h.next == ("model_node",):
                    model_node_state = h

            print(model_node_state.next)

            stream_graph_updates(user_input)
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)</code></pre>
    <p>
     输出内容如下
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      ('weather_graph',)
      <br/>
      ('router_node',)
      <br/>
      ('__start__',)
      <br/>
      ('weather_node',)
      <br/>
      ('model_node',)
      <br/>
      ('__start__',)
      <br/>
      ('model_node',)
      <br/>
      中断
      <br/>
      ('weather_graph',)
      <br/>
      ('router_node',)
      <br/>
      ('__start__',)
      <br/>
      ('weather_graph',)
      <br/>
      ('router_node',)
      <br/>
      ('__start__',)
      <br/>
      ('weather_node',)
      <br/>
      ('model_node',)
      <br/>
      ('__start__',)
      <br/>
      ('model_node',)
      <br/>
      中断
      <br/>
      ('weather_graph',)
      <br/>
      ('router_node',)
      <br/>
      ('__start__',)
      <br/>
      ('weather_graph',)
     </p>
     <p>
      。。。
     </p>
    </blockquote>
    <p>
     此处添加自己的逻辑，可以实现如果出现错误，实现自动回溯功能
    </p>
    <h3 id="5%E3%80%81%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81" name="5%E3%80%81%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81">
     5、整体代码
    </h3>
    <pre><code class="language-python">from langgraph.graph import StateGraph, END, START, MessagesState
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from typing import Literal
from langgraph.checkpoint.memory import MemorySaver

@tool
def get_weather(city: str):
    """获取天气信息"""
    return f"{city}，晴空万里，阳光明媚!"

# 添加记忆存储
memory = MemorySaver()

# 配置信息，用于记录对话记录
config = {"configurable": {"thread_id": "1"}}


# 指定大模型的API Key 等相关信息
llm = ChatOpenAI(
    base_url="https://lxxxxx.enovo.com/v1/", 
    api_key="sxxxxxxxwW",
    model_name="qwen2.5-instruct"
 
    )

# 绑定工具
model = raw_model.bind_tools([get_weather])

# 子图的state
class SubGraphState(MessagesState):
    city: str

# 识别地点（城市）
def model_node(state: SubGraphState):
    system_message = """用户的问题是某个地方的天气问题，请辨别具体城市名称，并输出城市名称。"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    result = raw_model.invoke(messages)
    return {"city": result.content}

# 天气工具节点
def weather_node(state: SubGraphState):
    result = get_weather.invoke({"city": state["city"]})
    return {"messages": [{"role": "assistant", "content": result}]}

# 子图的添加节点、边以及编译图
subgraph = StateGraph(SubGraphState)
subgraph.add_node(model_node)
subgraph.add_node(weather_node)
subgraph.add_edge(START, "model_node")
subgraph.add_edge("model_node", "weather_node")
subgraph.add_edge("weather_node", END)
# subgraph = subgraph.compile()
subgraph = subgraph.compile(interrupt_before=["weather_node"])

# 意图分类state
class RouterState(MessagesState):
    route: Literal["天气", "其他"]

# 意图分类节点
def router_node(state: RouterState):
    system_message = """用户输入与天气相关则输出"天气"，与天气无关返回"其他”"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    route = raw_model.invoke(messages)
    return {"route": route.content}

# 智能助手节点
def normal_llm_node(state: RouterState):
    response = raw_model.invoke(state["messages"])
    return {"messages": [response]}

# 选择边函数
def route_after_prediction(state: RouterState):
    if state["route"] == "天气":
        return "weather_graph"
    else:
        return "normal_llm_node"

# 父图的添加边、节点以及编译父图
graph = StateGraph(RouterState)
graph.add_node(router_node)
graph.add_node(normal_llm_node)
# 将子图作为一个节点添加到父图中
graph.add_node("weather_graph", subgraph)
graph.add_edge(START, "router_node")
graph.add_conditional_edges("router_node", route_after_prediction)
graph.add_edge("normal_llm_node", END)
graph.add_edge("weather_graph", END)
graph = graph.compile(checkpointer=memory)


# 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
            for h in graph.get_state_history(config): 
                print(h.next)
                if h.next == ("weather_graph",):
                    weather_graph_state = h.tasks[0].state
            for h in graph.get_state_history(weather_graph_state):
                print(h.next)
                if h.next == ("model_node",):
                    model_node_state = h

            print(model_node_state.next)

            stream_graph_updates(user_input)
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)

# 设置聊天退出方法
while True:
    try:
        user_input = input("User: ")
        if user_input.lower() in ["quit", "exit", "q"]:
            print("Goodbye!")
            break

        stream_graph_updates(user_input)
    except Exception as e:
        print(e)
        user_input = "What do you know about LangGraph?"
        print("User: " + user_input)
        stream_graph_updates(user_input)
        break</code></pre>
    <h2 id="%E4%BA%94%E3%80%81%E5%AD%90%E5%9B%BE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%94%B9" name="%E4%BA%94%E3%80%81%E5%AD%90%E5%9B%BE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%94%B9">
     五、子图状态更改
    </h2>
    <p>
     我会询问北京天气怎么，通过中断，将其
     <strong>
      state
     </strong>
     中的
     <strong>
      city
     </strong>
     的
     <strong>
      value
     </strong>
     修改为
     <strong>
      天津
     </strong>
     ，实现该demo的功能。
    </p>
    <p>
     <em>
      此处我会将部分代码修改，因为上述代码本身为了能够清晰明了的展示其功能
     </em>
    </p>
    <h3 id="1%E3%80%81%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81" name="1%E3%80%81%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81">
     1、修改状态
    </h3>
    <p>
     城市获取的节点是
     <strong>
      model_node
     </strong>
     ，通过人机交互回溯到该节点，并更新该历史状态中的
     <strong>
      city
     </strong>
     信息。
    </p>
    <p>
     获取当前状态
    </p>
    <pre><code class="language-python">state = graph.get_state(config)</code></pre>
    <p>
     将
     <strong>
      city
     </strong>
     对应的
     <strong>
      value
     </strong>
     修改为
     <strong>
      天津
     </strong>
    </p>
    <pre><code class="language-python">graph.update_state(state.tasks[0].state, {"city": "天津"})</code></pre>
    <p>
     部分代码如下
    </p>
    <pre><code class="language-python"># 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
            for h in graph.get_state_history(config): 
                if h.next == ("weather_graph",):
                    weather_graph_state = h.tasks[0].state
                    break
            for h in graph.get_state_history(weather_graph_state):
                if h.next == ("model_node",):
                    state = graph.get_state(config)
                    graph.update_state(state.tasks[0].state, {"city": "天津"})
                    break
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)</code></pre>
    <p>
     该段代码实现了将第一个
     <strong>
      task
     </strong>
     的
     <strong>
      city
     </strong>
     值，修改为
     <strong>
      天津
     </strong>
    </p>
    <h3 id="2%E3%80%81%E6%81%A2%E5%A4%8D%E6%89%A7%E8%A1%8C" name="2%E3%80%81%E6%81%A2%E5%A4%8D%E6%89%A7%E8%A1%8C">
     2、恢复执行
    </h3>
    <p>
     因为此节点不需要输入信息，故而此处输入信息为
     <strong>
      None
     </strong>
     ，代码如下
    </p>
    <pre><code class="language-python"># 恢复执行graph
def update_city():
    for event in graph.stream(None, config=config, stream_mode="updates"):
        print(event.get("weather_graph").get("messages")[-1].content)</code></pre>
    <p>
     此函数在
     <strong>
      graph.update_state(state.tasks[0].state, {"city": "天津"})
     </strong>
     添加
     <strong>
      update_city()
     </strong>
    </p>
    <pre><code class="language-python">graph.update_state(state.tasks[0].state, {"city": "天津"})
update_city()</code></pre>
    <h3 id="3%E3%80%81%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81" name="3%E3%80%81%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81">
     3、整体代码
    </h3>
    <pre><code class="language-python">from langgraph.graph import StateGraph, END, START, MessagesState
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from typing import Literal
from langgraph.checkpoint.memory import MemorySaver

@tool
def get_weather(city: str):
    """获取天气信息"""
    return f"{city}，晴空万里，阳光明媚!"

# 添加记忆存储
memory = MemorySaver()

# 配置信息，用于记录对话记录
config = {"configurable": {"thread_id": "1"}}


# 指定大模型的API Key 等相关信息
llm = ChatOpenAI(
    base_url="https://lxxxxx.enovo.com/v1/", 
    api_key="sxxxxxxxwW",
    model_name="qwen2.5-instruct"
    )

# 绑定工具
model = raw_model.bind_tools([get_weather])

# 子图的state
class SubGraphState(MessagesState):
    city: str

# 识别地点（城市）
def model_node(state: SubGraphState):
    system_message = """用户的问题是某个地方的天气问题，请辨别具体城市名称，并输出城市名称。"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    result = raw_model.invoke(messages)
    return {"city": result.content}

# 天气工具节点
def weather_node(state: SubGraphState):
    result = get_weather.invoke({"city": state["city"]})
    return {"messages": [{"role": "assistant", "content": result}]}

# 子图的添加节点、边以及编译图
subgraph = StateGraph(SubGraphState)
subgraph.add_node(model_node)
subgraph.add_node(weather_node)
subgraph.add_edge(START, "model_node")
subgraph.add_edge("model_node", "weather_node")
subgraph.add_edge("weather_node", END)
# subgraph = subgraph.compile()
subgraph = subgraph.compile(interrupt_before=["weather_node"])

# 意图分类state
class RouterState(MessagesState):
    route: Literal["天气", "其他"]

# 意图分类节点
def router_node(state: RouterState):
    system_message = """用户输入与天气相关则输出"天气"，与天气无关返回"其他”"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    route = raw_model.invoke(messages)
    return {"route": route.content}

# 智能助手节点
def normal_llm_node(state: RouterState):
    response = raw_model.invoke(state["messages"])
    return {"messages": [response]}

# 选择边函数
def route_after_prediction(state: RouterState):
    if state["route"] == "天气":
        return "weather_graph"
    else:
        return "normal_llm_node"

# 父图的添加边、节点以及编译父图
graph = StateGraph(RouterState)
graph.add_node(router_node)
graph.add_node(normal_llm_node)
# 将子图作为一个节点添加到父图中
graph.add_node("weather_graph", subgraph)
graph.add_edge(START, "router_node")
graph.add_conditional_edges("router_node", route_after_prediction)
graph.add_edge("normal_llm_node", END)
graph.add_edge("weather_graph", END)
graph = graph.compile(checkpointer=memory)

# 恢复执行graph
def update_city():
    for event in graph.stream(None, config=config, stream_mode="updates"):
        print(event.get("weather_graph").get("messages")[-1].content)

# 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
            for h in graph.get_state_history(config): 
                if h.next == ("weather_graph",):
                    weather_graph_state = h.tasks[0].state
                    break
            for h in graph.get_state_history(weather_graph_state):
                if h.next == ("model_node",):
                    state = graph.get_state(config)
                    # state.values["city"] = "天津"
                    graph.update_state(state.tasks[0].state, {"city": "天津"})
                    update_city()
                    break
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)

# 设置聊天退出方法
while True:
    try:
        user_input = input("User: ")
        if user_input.lower() in ["quit", "exit", "q"]:
            print("Goodbye!")
            break

        stream_graph_updates(user_input)
    except Exception as e:
        print(e)
        user_input = "What do you know about LangGraph?"
        print("User: " + user_input)
        stream_graph_updates(user_input)
        break</code></pre>
    <p>
     输出内容
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      天津，晴空万里，阳光明媚!
      <br/>
      User:
     </p>
    </blockquote>
    <h3 id="4%E3%80%81%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9" name="4%E3%80%81%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9">
     4、更新节点
    </h3>
    <p>
     指定节点，指定输出内容
    </p>
    <p>
     只需将
    </p>
    <pre><code class="language-python">graph.update_state(state.tasks[0].state, {"city": "天津"})</code></pre>
    <p>
     替换为
    </p>
    <pre><code class="language-python">graph.update_state(
    state.tasks[0].state,
    {"messages": [{"role": "assistant", "content": "天津，晴空万里，阳光明媚!"}]},
    as_node="weather_node",
)</code></pre>
    <p>
     输出内容
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      天津，晴空万里，阳光明媚!
      <br/>
      User:
     </p>
    </blockquote>
    <h3 id="5%E3%80%81%E6%9B%B4%E6%96%B0%E5%AD%90%E5%9B%BE" name="5%E3%80%81%E6%9B%B4%E6%96%B0%E5%AD%90%E5%9B%BE">
     5、更新子图
    </h3>
    <p>
     指定子图（子图本质就是一个节点），指定输出内容
    </p>
    <p>
     由于是针对整个子图操作，所以不再需要
     <strong>
      update_city
     </strong>
     方法，部分代码如下
    </p>
    <pre><code class="language-python">for h in graph.get_state_history(weather_graph_state):
    if h.next == ("model_node",):
        graph.update_state(
            config,
            {"messages": [{"role": "assistant", "content": "天津，晴空万里，阳光明媚!"}]},
            as_node="weather_graph",
        )
        messages = graph.get_state(config).values["messages"]
        print(messages[-1].content)
        break</code></pre>
    <p>
     输出内容
    </p>
    <blockquote>
     <p>
      User: 北京天气怎么样
      <br/>
      中断
      <br/>
      天津，晴空万里，阳光明媚!
      <br/>
      User:
     </p>
    </blockquote>
    <p>
     由于此处代码变化有些多，此处提供完整代码
    </p>
    <pre><code class="language-python">from langgraph.graph import StateGraph, END, START, MessagesState
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from typing import Literal
from langgraph.checkpoint.memory import MemorySaver

@tool
def get_weather(city: str):
    """获取天气信息"""
    return f"{city}，晴空万里，阳光明媚!"

# 添加记忆存储
memory = MemorySaver()

# 配置信息，用于记录对话记录
config = {"configurable": {"thread_id": "1"}}


# 指定大模型的API Key 等相关信息
llm = ChatOpenAI(
    base_url="https://lxxxxx.enovo.com/v1/", 
    api_key="sxxxxxxxwW",
    model_name="qwen2.5-instruct"
    )

# 绑定工具
model = raw_model.bind_tools([get_weather])

# 子图的state
class SubGraphState(MessagesState):
    city: str

# 识别地点（城市）
def model_node(state: SubGraphState):
    system_message = """用户的问题是某个地方的天气问题，请辨别具体城市名称，并输出城市名称。"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    result = raw_model.invoke(messages)
    return {"city": result.content}

# 天气工具节点
def weather_node(state: SubGraphState):
    result = get_weather.invoke({"city": state["city"]})
    return {"messages": [{"role": "assistant", "content": result}]}

# 子图的添加节点、边以及编译图
subgraph = StateGraph(SubGraphState)
subgraph.add_node(model_node)
subgraph.add_node(weather_node)
subgraph.add_edge(START, "model_node")
subgraph.add_edge("model_node", "weather_node")
subgraph.add_edge("weather_node", END)
# subgraph = subgraph.compile()
subgraph = subgraph.compile(interrupt_before=["weather_node"])

# 意图分类state
class RouterState(MessagesState):
    route: Literal["天气", "其他"]

# 意图分类节点
def router_node(state: RouterState):
    system_message = """用户输入与天气相关则输出"天气"，与天气无关返回"其他”"""
    messages = [{"role": "system", "content": system_message}] + state["messages"]
    route = raw_model.invoke(messages)
    return {"route": route.content}

# 智能助手节点
def normal_llm_node(state: RouterState):
    response = raw_model.invoke(state["messages"])
    return {"messages": [response]}

# 选择边函数
def route_after_prediction(state: RouterState):
    if state["route"] == "天气":
        return "weather_graph"
    else:
        return "normal_llm_node"

# 父图的添加边、节点以及编译父图
graph = StateGraph(RouterState)
graph.add_node(router_node)
graph.add_node(normal_llm_node)
# 将子图作为一个节点添加到父图中
graph.add_node("weather_graph", subgraph)
graph.add_edge(START, "router_node")
graph.add_conditional_edges("router_node", route_after_prediction)
graph.add_edge("normal_llm_node", END)
graph.add_edge("weather_graph", END)
graph = graph.compile(checkpointer=memory)

# 恢复执行graph
def update_city():
    for event in graph.stream(None, config=config, stream_mode="updates"):
        print(event)
        print(event.get("weather_graph").get("messages")[-1].content)

# 以流式调用图
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}, config=config, stream_mode="updates"):
        if "__interrupt__" in event:
            print("中断")
            for h in graph.get_state_history(config): 
                if h.next == ("weather_graph",):
                    weather_graph_state = h.tasks[0].state
                    break
            for h in graph.get_state_history(weather_graph_state):
                if h.next == ("model_node",):
                    graph.update_state(
                        config,
                        {"messages": [{"role": "assistant", "content": "天津，晴空万里，阳光明媚!"}]},
                        as_node="weather_graph",
                    )
                    messages = graph.get_state(config).values["messages"]
                    print(messages[-1].content)
                    break
        elif event.get("router_node"):
            continue
        else:
            for value in event.values():
                print("Assistant:", value["messages"][-1].content)

# 设置聊天退出方法
while True:
    try:
        user_input = input("User: ")
        if user_input.lower() in ["quit", "exit", "q"]:
            print("Goodbye!")
            break

        stream_graph_updates(user_input)
    except Exception as e:
        print(e)
        user_input = "What do you know about LangGraph?"
        print("User: " + user_input)
        stream_graph_updates(user_input)
        break</code></pre>
    <p>
     六、综述
    </p>
    <p>
     1、子图是父图的节点，可是孙图绝不是父图的节点
    </p>
    <p>
     2、愚公移山 ：子子孙孙，无穷尽也
    </p>
    <p>
     3、子图的使用基本是在多智能体中使用
    </p>
    <p>
     4、通信尽量使用state，避免函数调用
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f666f72657665726375692f:61727469636c652f64657461696c732f313436303935353636" class_="artid" style="display:none">
 </p>
</div>


