---
layout: post
title: "算法数组链表栈队列树"
date: 2025-03-14 00:02:39 +0800
description: "很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~"
keywords: "【算法】数组、链表、栈、队列、树"
categories: ['算法']
tags: ['算法', '数据结构']
artid: "146236552"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146236552
    alt: "算法数组链表栈队列树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146236552
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146236552
cover: https://bing.ee123.net/img/rand?artid=146236552
image: https://bing.ee123.net/img/rand?artid=146236552
img: https://bing.ee123.net/img/rand?artid=146236552
---

# 【算法】数组、链表、栈、队列、树

![头像](https://i-blog.csdnimg.cn/direct/621057c10592434099cf0e6395de3624.png)
⭐️个人主页：[@小羊 ](https://blog.csdn.net/2301_78843337?type=blog) ⭐️所属专栏：[Linux
](https://blog.csdn.net/2301_78843337/category_12775851.html)
很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~

![动图描述](https://img-
blog.csdnimg.cn/direct/e678d5c05144448f9c9233bf292616a1.gif)

* * *

## 持续更新中…

* * *

### 数组、链表

#### 点击消除

  * [**AB5 点击消除**](https://www.nowcoder.com/practice/8d3643ec29654cf8908b5cf3a0479fd5?tpId=308&tqId=40462&ru=/exam/oj)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/954999fdd38240dd8820a31b76d91b8d.png)  
这个题很容易想到用“栈”，但是创建一个`stack`最后还要转换成字符串，可以用`string`代替栈。  
`string`的接口很多且实用，常见的接口基本都有：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/10a53e335af44e3a877cff7afb7f6093.png)

这个题比较坑的是它说如果字符串为空串则返回0，谁想到返回的是`"0"`，我试着返回`0`咋都过不去，最后吐了！都怪我太年轻了！

    
    
    #include <iostream>
    using namespace std;
    
    int main() 
    {
        string str, st;
        cin >> str;
        for (char ch : str)
        {
            if (!st.empty() && st.back() == ch)
            {
                st.pop_back();
                continue;
            }
            st.push_back(ch);
        }
        cout << (st.empty() ? "0" : st);
        return 0;
    }
    

* * *

#### 环形链表

  * [**Leetcode——环形链表**](https://leetcode.cn/problems/linked-list-cycle/description/)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d992c857404d4172a58d66dbd01cd3f0.png)

**快慢指针法：**
快指针和慢指针初始时指向头节点，当快指针指向和快指针指向节点内的`next`指针不为空时，快指针一次走两步，慢指针一次走一步，快指针入环后走N圈后慢指针入环，当快指针和慢指针相等时说明存在环，如果出循环则说明不存在环。

关键的地方是**快指针一次走两步，慢指针一次走一步** ，如果存在环则快指针和慢指针一定会相遇。为什么一定会相遇呢？  
如果存在环，假设当慢指针入环时快指针距离此时慢指针的位置为N，则接下来每当快指针追赶慢指针一次，它们的距离就减一，直到减为0，此时快慢指针就相遇了。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b765eec7278845c5812e97bb3d40a592.png)

    
    
    bool hasCycle(struct ListNode *head) {
        struct ListNode* fast = head, *slow = head;
        while (fast && fast->next)
        {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow)
            {
                return true;
            }
        }
        return false;
    }
    

* * *

#### 环形链表 II

  * [**Leetcode——环形链表 II**](https://leetcode.cn/problems/linked-list-cycle-ii/)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b42140a3c15d4279ae4f8f9216a9b28f.png)

还是快慢指针，当快慢指针相遇时我们让`meet`指针指向相遇时的节点，然后让头指针`head`和`meet`指针一步步地向后走，当两指针相遇时指向的节点就是链表开始入环的第一个节点。为什么这两个指针一定会相遇在链表开始入环的第一个节点？

假设头指针距离链表开始入环的第一个节点的长度为L，`meet`指针相距链表开始入环的第一个节点的距离是N，环的长度为C，当慢指针入环时快指针走了x圈，因为快指针的速度是慢指针的2倍，那我们可以得到下面的等式：

  * **2(L + N) = L + X*C + N**

化简得：**L = X*C - N** ，由这个等式可以得出`head`和`meet`相遇是必然的。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f5d5f7f2e695477480029aff913a1369.png)

    
    
    struct ListNode *detectCycle(struct ListNode *head) {
        struct ListNode* fast = head, *slow = head;
        while (fast && fast->next)
        {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow)
            {
                struct ListNode* meet = fast;
                while (head != meet)
                {
                    head = head->next;
                    meet = meet->next;
                }
                return meet;
            }
        }
        return NULL;
    }
    

* * *

### 栈、队列

### 树

* * *

本篇文章的分享就到这里了，如果您觉得在本文有所收获，还请留下您的三连支持哦~

![头像](https://img-
blog.csdnimg.cn/img_convert/ef07608f8c5523995a3671f982ca95bd.jpeg)



