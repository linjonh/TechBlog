---
layout: post
title: "JS采集数据爬虫-Fetch-API-和-XMLHttpRequest-有什么区别"
date: 2025-03-07 00:45:19 +0800
description: "Fetch API是现代开发的首选，适用于新项目或需要重构的项目。它更简洁、功能更强大，且与现代 JavaScript 的特性（如 Promise、async/await）无缝集成。更适合一些需要兼容旧浏览器的项目，或者在一些遗留代码中继续使用。但在新项目中，建议优先考虑Fetch API。"
keywords: "JS采集数据爬虫-Fetch API 和 XMLHttpRequest 有什么区别？"
categories: ['未分类']
tags: ['爬虫', '开发语言', 'Js', 'Javascript']
artid: "146083753"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146083753
    alt: "JS采集数据爬虫-Fetch-API-和-XMLHttpRequest-有什么区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146083753
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146083753
cover: https://bing.ee123.net/img/rand?artid=146083753
image: https://bing.ee123.net/img/rand?artid=146083753
img: https://bing.ee123.net/img/rand?artid=146083753
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JS采集数据爬虫-Fetch API 和 XMLHttpRequest 有什么区别？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <code>
      Fetch API
     </code>
     和
     <code>
      XMLHttpRequest
     </code>
     都是用于在客户端发起网络请求的工具，但它们在设计、使用方式、功能特性等方面存在显著区别。以下是两者的详细对比：
    </p>
    <h4>
     1.
     <strong>
      设计与理念
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch API
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是现代的网络请求 API，设计上更简洁、更符合现代 JavaScript 的编程范式。
        </p>
       </li>
       <li>
        <p>
         基于
         <strong>
          Promise
         </strong>
         ，支持异步操作，代码更简洁，易于阅读和维护。
        </p>
       </li>
       <li>
        <p>
         采用链式调用和
         <code>
          async/await
         </code>
         ，使得异步代码更接近同步代码的写法。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是早期的网络请求 API，设计上较为复杂，需要手动处理各种状态。
        </p>
       </li>
       <li>
        <p>
         不支持 Promise，依赖于回调函数来处理异步操作，容易导致回调地狱（callback hell）。
        </p>
       </li>
       <li>
        <p>
         需要手动检查
         <code>
          readyState
         </code>
         和
         <code>
          status
         </code>
         ，代码冗长且易出错。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     2.
     <strong>
      使用方式
     </strong>
    </h4>
    <h5>
     Fetch API：
    </h5>
    <p>
     JavaScript复制
    </p>
    <pre><code>fetch('https://api.example.com/data')
  .then(response =&gt; {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json(); // 或 response.text()、response.blob()
  })
  .then(data =&gt; {
    console.log(data);
  })
  .catch(error =&gt; {
    console.error('Fetch error:', error);
  });</code></pre>
    <ul>
     <li>
      <p>
       使用
       <code>
        Promise
       </code>
       ，支持链式调用。
      </p>
     </li>
     <li>
      <p>
       可以通过
       <code>
        .json()
       </code>
       、
       <code>
        .text()
       </code>
       、
       <code>
        .blob()
       </code>
       等方法直接处理响应体。
      </p>
     </li>
     <li>
      <p>
       错误处理通过
       <code>
        .catch()
       </code>
       实现。
      </p>
     </li>
    </ul>
    <h5>
     XMLHttpRequest：
    </h5>
    <p>
     JavaScript复制
    </p>
    <pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true); // 第三个参数为 true 表示异步
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
    console.log(xhr.responseText); // 处理返回的数据
  } else if (xhr.readyState === 4) {
    console.error('Request failed with status:', xhr.status);
  }
};
xhr.send();</code></pre>
    <ul>
     <li>
      <p>
       需要手动设置请求方法和 URL。
      </p>
     </li>
     <li>
      <p>
       通过
       <code>
        onreadystatechange
       </code>
       事件监听请求状态变化。
      </p>
     </li>
     <li>
      <p>
       需要手动检查
       <code>
        readyState
       </code>
       和
       <code>
        status
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       错误处理需要在回调中手动实现。
      </p>
     </li>
    </ul>
    <h4>
     3.
     <strong>
      功能特性
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch API
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Promise 支持
         </strong>
         ：基于 Promise，可以使用
         <code>
          async/await
         </code>
         ，代码更简洁。
        </p>
       </li>
       <li>
        <p>
         <strong>
          默认行为
         </strong>
         ：默认不发送跨域请求（CORS），需要服务器支持。
        </p>
       </li>
       <li>
        <p>
         <strong>
          请求和响应对象
         </strong>
         ：提供了更丰富的
         <code>
          Request
         </code>
         和
         <code>
          Response
         </code>
         对象，支持多种响应类型（如 JSON、Blob、ArrayBuffer 等）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          错误处理
         </strong>
         ：只有在请求无法发出时才触发
         <code>
          .catch()
         </code>
         ，网络错误（如 404、500）不会触发
         <code>
          .catch()
         </code>
         ，需要手动检查
         <code>
          response.ok
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          全局拦截
         </strong>
         ：可以通过
         <code>
          Response
         </code>
         对象的
         <code>
          .clone()
         </code>
         方法实现全局拦截。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          回调机制
         </strong>
         ：依赖回调函数，代码可读性较差。
        </p>
       </li>
       <li>
        <p>
         <strong>
          状态码检查
         </strong>
         ：需要手动检查
         <code>
          readyState
         </code>
         和
         <code>
          status
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          跨域限制
         </strong>
         ：同样受限于 CORS，但处理方式更复杂。
        </p>
       </li>
       <li>
        <p>
         <strong>
          错误处理
         </strong>
         ：需要在回调中手动处理错误。
        </p>
       </li>
       <li>
        <p>
         <strong>
          功能限制
         </strong>
         ：不支持
         <code>
          Promise
         </code>
         ，无法直接处理 JSON 等复杂数据类型。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     4.
     <strong>
      兼容性
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch API
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是现代浏览器的特性，不支持 IE 浏览器。
        </p>
       </li>
       <li>
        <p>
         在旧版本浏览器中可以通过
         <code>
          polyfill
         </code>
         （如
         <code>
          whatwg-fetch
         </code>
         ）来兼容。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         兼容性极好，支持几乎所有浏览器，包括 IE。
        </p>
       </li>
       <li>
        <p>
         适合需要兼容旧浏览器的项目。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     5.
     <strong>
      性能与效率
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch API
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         性能优化较好，支持 HTTP/2 和缓存策略。
        </p>
       </li>
       <li>
        <p>
         基于 Promise 的异步处理机制更高效。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         性能稍逊，尤其是在处理大量异步请求时。
        </p>
       </li>
       <li>
        <p>
         代码复杂度较高，可能导致性能瓶颈。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     6.
     <strong>
      社区与生态
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch API
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         是现代开发的推荐方式，社区支持良好。
        </p>
       </li>
       <li>
        <p>
         更容易与其他现代 JavaScript 框架（如 React、Vue、Angular）集成。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         逐渐被现代开发淘汰，但在一些旧项目中仍然广泛使用。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch API
       </strong>
       是现代开发的首选，适用于新项目或需要重构的项目。它更简洁、功能更强大，且与现代 JavaScript 的特性（如 Promise、async/await）无缝集成。
      </p>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest
       </strong>
       更适合一些需要兼容旧浏览器的项目，或者在一些遗留代码中继续使用。但在新项目中，建议优先考虑
       <code>
        Fetch API
       </code>
       。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f7869616f79616f3936312f:61727469636c652f64657461696c732f313436303833373533" class_="artid" style="display:none">
 </p>
</div>


