---
layout: post
title: "32-两数之和-II-输入有序数组"
date: 2025-03-12 22:58:37 +0800
description: "给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。"
keywords: "32- 两数之和 II - 输入有序数组"
categories: ['每日一刷']
tags: ['算法', '数据结构']
artid: "146217317"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146217317
    alt: "32-两数之和-II-输入有序数组"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146217317
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146217317
cover: https://bing.ee123.net/img/rand?artid=146217317
image: https://bing.ee123.net/img/rand?artid=146217317
img: https://bing.ee123.net/img/rand?artid=146217317
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     32- 两数之和 II - 输入有序数组
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 你所设计的解决方案必须只使用常量级的额外空间。
    </p>
    <h4>
     方法一：双指针法
    </h4>
    <p>
     双指针法是处理有序数组中两数之和问题的经典方法，利用数组的有序性，通过两个指针从数组两端向中间移动来寻找符合条件的两个数。
    </p>
    <pre><code class="language-TypeScript">function twoSum(numbers: number[], target: number): number[] {
    let left = 0;
    let right = numbers.length - 1;

    while (left &lt; right) {
        const currentSum = numbers[left] + numbers[right];
        if (currentSum === target) {
            return [left + 1, right + 1];
        } else if (currentSum &lt; target) {
            left++;
        } else {
            right--;
        }
    }
    return [];
}
</code></pre>
    <h5>
     复杂度分析
    </h5>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：(O(n))，其中 n 是数组的长度。因为两个指针最多遍历数组一次。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：(O(1))，只使用了常数级的额外空间来存储两个指针。
     </li>
    </ul>
    <h4>
     方法二：二分查找法
    </h4>
    <p>
     对于数组中的每个元素
     <code>
      numbers[i]
     </code>
     ，我们可以使用二分查找在剩余的元素中查找是否存在
     <code>
      target - numbers[i]
     </code>
     。
    </p>
    <pre><code class="language-TypeScript">function twoSum(numbers: number[], target: number): number[] {
    for (let i = 0; i &lt; numbers.length; i++) {
        const complement = target - numbers[i];
        let left = i + 1;
        let right = numbers.length - 1;

        while (left &lt;= right) {
            const mid = Math.floor((left + right) / 2);
            if (numbers[mid] === complement) {
                return [i + 1, mid + 1];
            } else if (numbers[mid] &lt; complement) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return [];
}
</code></pre>
    <h5>
     复杂度分析
    </h5>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：(O(n log n))，对于数组中的每个元素，都需要进行一次二分查找，二分查找的时间复杂度是 (O(log n))，所以总的时间复杂度是 (O(n log n))。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：(O(1))，只使用了常数级的额外空间来存储二分查找所需的指针。
     </li>
    </ul>
    <h4>
     方法三：哈希表法
    </h4>
    <p>
     虽然本题要求使用常量级的额外空间，但哈希表法也是解决两数之和问题的常见思路，这里也给出实现以供参考。我们可以遍历数组，对于每个元素
     <code>
      numbers[i]
     </code>
     ，检查
     <code>
      target - numbers[i]
     </code>
     是否在哈希表中，如果存在则返回对应的下标，否则将当前元素及其下标存入哈希表。
    </p>
    <pre><code class="language-TypeScript">function twoSum(numbers: number[], target: number): number[] {
    const hashMap = new Map&lt;number, number&gt;();
    for (let i = 0; i &lt; numbers.length; i++) {
        const complement = target - numbers[i];
        if (hashMap.has(complement)) {
            return [hashMap.get(complement)! + 1, i + 1];
        }
        hashMap.set(numbers[i], i);
    }
    return [];
}
</code></pre>
    <h5>
     复杂度分析
    </h5>
    <ul>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：(O(n))，只需要遍历数组一次，每次查找哈希表的时间复杂度是 \(O(1)\)。
     </li>
     <li>
      <strong>
       空间复杂度
      </strong>
      ：(O(n))，主要用于存储哈希表，最坏情况下需要存储数组中的所有元素。
     </li>
    </ul>
    <p>
     你可以使用以下方式测试这些函数：
    </p>
    <pre><code class="language-TypeScript">const numbers = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(numbers, target));
</code></pre>
    <p>
     综上所述，双指针法是本题的最优解法，时间复杂度和空间复杂度都较为优秀。
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f687179313938392f:61727469636c652f64657461696c732f313436323137333137" class_="artid" style="display:none">
 </p>
</div>


