---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38363131323631302f:61727469636c652f64657461696c732f313436323130303639"
layout: post
title: "数据结构ArrayList顺序表"
date: 2025-03-14 00:18:44 +08:00
description: "介绍了数据结构在面向对象体系中的特点，整理归纳好了ArrayList类里面从构造、遍历、获取、查找、比较、修改、插入、删除、截取到清空一系列常用方法的使用与说明"
keywords: "【数据结构】ArrayList顺序表"
categories: ['未分类']
tags: ['数据结构', '学习', 'Java']
artid: "146210069"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146210069
    alt: "数据结构ArrayList顺序表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146210069
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146210069
cover: https://bing.ee123.net/img/rand?artid=146210069
image: https://bing.ee123.net/img/rand?artid=146210069
img: https://bing.ee123.net/img/rand?artid=146210069
---

# 【数据结构】ArrayList顺序表

---

[面向对象前置知识](https://blog.csdn.net/2401_86112610/article/details/145645498?spm=1011.2415.3001.5331 "面向对象前置知识")

![](https://i-blog.csdnimg.cn/direct/efe848eb6e314fdf8af2b85dff166f54.jpeg)

​

* **class(类)是一种
  类型
  ，用class(类)可以创建
  类变量**
  ，
  **类变量里存储变量与方法**
  ，创建类变量时都有开辟空间，类变量里的存储的
  **成员变量都存储在堆区**
  ，类变量里存储的
  **成员方法都存储在方法区**
  ，
  类变量本身也是个变量存有空间
  ，它里面存储这些成员变量与成员方法，不过类变量开辟的存储空间有部分在堆上(变量)，有部分在方法区上(方法)，是在两个不同区域开辟空间创建来的变量，

  类变量创建后相应地它也有
  **哈希值**

  ，指向创建的这个类变量，能访问这个类变量的所有
* 类变量创建好后，
  **类变量也可作为一种类型，以此类变量为类型创建**

  **似复刻变量**
  ，似复刻变量
  **按照类变量里的非静态变量模具变量创建
  复制变量
  、在堆上开辟空间存储有类变量里的静态变量、类变量里的所有方法的访问
  路径信息**
  ，用类变量创建的似复刻变量在
  **堆区**
  ，复刻变量里存储复制变量与访问类变量路径信息两块内容，

  创建好似复刻变量后，相应地有指向此似复刻变量的
  **哈希值**

  ，能访问与管理到此似复刻变量的所有内容
  ，
  **似复刻变量的存哈希值引用类型与类变量存哈希值引用类型是共用的，因为它们最终的指向对象类型都是相同的**

----------------------------------------------

> ## 一、数据结构的 面向对象性

### 1.面向 似复刻变量对象引用

以引用的形式面向似复刻变量对象，将它们

**引用组群管理起来**
的结构就是各种各样的数据结构
，
**似复刻变量对象引用**
是数据存储的目标单位元，以数组直接存放管理似复刻变量对象引用的结构就是顺序表

---

### 2. 下层存储引用 的特点

同次中全部管理的是相同类变量类型的似复刻变量，因此
**存储的目标单位元引用都是相同的一个引用类型在一次中

，所以用**


**<统一似复刻变量对象引用类型的**

**泛型>来统一化结构里的单位元引用类型**
，<泛型化又统一化>是面向似复刻变量对象的数据结构的特点，因为向上转型能保存子类信息所以
**将似复刻变量对象引用的存储统一用Object类变量的似复刻变量引用向上转型式存储**
，
**数据结构的
引用存储格式就能统一化创建存储
了**

---

### 3. 上层管理引用

似复刻变量引用作为存储数据对象存储在成组织的个个Object引用变量中，同时需要一个管理存储整体的管理这些存储引用变量的引用，即上层的管理引用管理下层的存储引用，
**上层的管理引用其实是下层存储引用作为非静态复制变量所对类变量的实例化似复刻变量引用**
，上层的管理引用是似复刻变量，
**下层的存储引用是似复刻变量里的非静态成员**
，这样对它管理的，
**所属的类变量就是
数据结构的类变量**
，
有很多种数据结构有很多种对应的类变量类
，
**对着它的一个类变量创建似复刻变量就是创建这个类变量对应的一个数据结构**

---

### 4.数据结构的 类

*数据结构的类变量一般有
**继承**
别的一个类、实现很多的
**接口**
，里面有对应的
**非静态存储引用成员**
作着模板、也有
**静态成员**
、有很多操作非静态存储引用成员的
**方法**
(增删查改这些)，方法有很多是连接接口去
**重写**
对应实现有的，*
因为
**存储引用们的类型相互之间必须是统一一种的**
，所以
**类变量的似复刻变量那边就一定有指定一种它里面存储引用的类型—>
类<T或具体类型>**
，因为存储引用类型统一了，
**操作存储引用的方法也必须是统一类型的—>
方法(E或具体类型)**
，会有很多其它也要跟着统一类型的

---

> ## 二、ArrayList类变量里的方法

### **1.构造**

> #### **1.1 无参构造** ：
>
> **new
> ArrayList<E>()
> ;**
>
> **—> return
> ArrayList**
>
> **构造出一个里面存储引用的复制变量0存储引用容量的顺序表的似复刻变量
> ，
> 0
> 存储引用容量的复制变量在后面通过调用
> add
> 等会进行增扩空间放引用**

> #### **1.2 并表构造** ：
>
> **new
> ArrayList<E>(Collection)
> ;**
>
> **—> return
> ArrayList**
>
> **往c里面向下搜索到存储引用的表的存储引用复制并到创的新的存储引用数组成员在此新的构造顺序表的似复刻变量里
> ，这里是创建新的存储引用数组的
> 浅拷贝
> ，存储引用复制到新的存储引用数组里
> 还是共享着同一实例**

对Collection c的要求：
**ArrayList(Collection<? extends E> c)**

ArrayList类变量里的构造方法设置的
**形参类型为Collection接口变量**
(用来接收传来的Collection及其下面接口、类实现的似复刻变量)，和ArrayList类变量一样，它也有指定统一引用类型的，
**把两个<>写一起一个里面写**
，
**通配符?是Collection的指定引用类型，E是ArrayList的指定引用类型**
，extend说明?继承于E即
**Collection的指定引用类型要继承于ArrayList的指定引用类型的**

> #### 1.3 定容构造 ：
>
> **new
> ArrayList<E>(int)
> ;**
>
> **—> return
> ArrayList**
>
> **指定初始顺序表的似复刻变量里复制的存储引用单位的个数创建构造**

---

### **2.遍历**

#### 2.1迭代器遍历

**实现原理**
：

数据结构里的
**所有集合实现类往上最上层都间接连接着
Iterable接口**
，Iterable(可迭代的)接口里
**有以迭代器接口变量Iterator为返回值
获得迭代器接口变量的抽象方法**
，
Iterable接口往下继承下去每一层都有对应的重写实现方法来重写上制造出具体对应为本层迭代的迭代器获取方法
(接口继承层没重写继续抽象的就没实现抽象传下去)，到具体的集合实现类(或有实现它的抽象类)时，会在
**要实现迭代器的那层类里定义一个
主动连接上Iterator接口的内部类**
(外部类里是一直都没有往下继承有Iterator接口的)，重写获取Iterator迭代器接口变量方法的部分内部，通过
**实例化
返回此实现上Iterator接口的内部类的似复刻变量去
返回值接转向上转型

得到重写对应为本层迭代的迭代器似复刻变量**
，就可用它迭代本层类了

在
**List接口
里有多加上
获取ListIterator列表迭代器接口变量的抽象方法**
，相对应地在后面的所有实现List接口的表数据结构实现类都会有相应的获取列表迭代器的重写实现上方法，在那层实现类里相对应的有定义连接ListIterator列表迭代器接口的内部类，在重写方法里面实例化此内部类返回向上转型成迭代本层类的迭代器

**ListIterator迭代器接口
继承于
Iterator迭代器接口**
，ListIterator里面的抽象方法比Iterator多，对应实现后的ListIterator迭代器接口似复刻变量里的方法自然比Iterator迭代器接口的似复刻变量里的方法多：

##### 2.1.1Iterator迭代器

> ###### **2.1.1.1 获取 ：**
>
> **arraylist.
> iterator()
> ;**
>
> **—> return
> Iterator<E>**
>
> **获取迭代器接口实例似复刻变量
> ，
> 往后只有移除的单向遍历迭代器
> ，适用于
> Collection
> 接口下实现的类**

> ###### **2.1.1.2 判空(后) ：**
>
> **it.
> hasNext()
> ;**
>
> **—> return
> boolean**
>
> **判断当前索引后一个位置是否有引用**

> **2.1.1.3
> 遍历(后)
> ：**
>
> **it.
> next()
> ;**
>
> **—> return
> E**
>
> **迭代器索引后移并获取引用**

> **2.1.1.4
> 删除
> ：
>   
> it.
> remove()
> ;**
>
> **—> return
> void**
>
> **删除迭代器当前索引位置的引用**

----------------------------------------------

##### 2.1.2ListIterator迭代器

> ###### **2.1.2.1 获取 ：**
>
> **arraylist.
> listIterator()
> ;**
>
> **—> return
> ListIterator<E>**
>
> **获取列表迭代器接口的实例似复刻变量
> ，
> 增了往前修改插入的双向遍历列表迭代器
> ，适用于
> List
> 接口下实现的类**

> ###### **2.1.2.2 判空(前) ：**
>
> **lit.
> hasPrevious()
> ;**
>
> **—> return
> boolean**
>
> **判断当前索引前一个位置是否有引用**

> ###### **2.1.2.3 遍历(前) ：**
>
> **lit.
> previous()
> ;**
>
> **—> return
> E**
>
> **列表迭代器索引前移并获取引用**

> ###### **2.1.2.4 修改 ：**
>
> **lit.
> set(E1)
> ;**
>
> **—> return
> E2**
>
> **修改当前位置引用为指定引用
> ，并返回原来被修改前的存储引用**

> ###### **2.1.2.5 插入 ：**
>
> **lit.
> add(E)
> ;**
>
> **—> return
> boolean**
>
> **往迭代器遍历方向位置后插入一个引用E**

----------------------------------------------

> #### **2.2 foreach遍历 ：**
>
> **for(E x : arraylist) { x }**
>
> **将列表里的存储引用一次次全部取出来存放到E引用遍历使用**

----------------------------------------------

> #### **2.3 for循环遍历 ：**
>
> **for (int i = 0; i < arraylist.size(); i++) {
>   
> arraylist.get(i)
>   
> }**

---

> ### **3. 获取 ：**
>
> **arraylist.
> get(index)
> ;**
>
> **—> return
> E**
>
> **获取指定索引的那个存储引用**

---

### **4.查找**

> #### **4.1 从前往后查找 ：**
>
> **arraylist.
> indexOf(Object o)
> ;**
>
> **—> return
> index**
>
> **从前往后查找第一个引用对象里内容相同的引用
> ，并返回它的下标**

> #### **4.2 从后往前查找 ：**
>
> **arraylist.
> lastIndexOf(Object o)
> ;**
>
> **—> return
> index**
>
> **从后往前查找第一个引用对象里内容相同的引用
> ，并返回它的下标**

---

> ### **5. 比较 ：**
>
> **arraylist.
> contains(Object o)
> ;**
>
> **—> return
> boolean**
>
> **判断指定引用的对象里内容在列表里是否有存在**

---

> ### **6. 修改 ：**
>
> **arraylist.
> set(index,E1)
> ;**
>
> **—> return
> E2**
>
> **将指定索引的那个存储引用修改为指定引用
> ，并返回原来的那个被修改的引用**

---

### **7.插入**

#### 7.1插一个引用(重载位置)

* **重载：add(插入哪个位置)**

> ##### **7.1.1 尾插 ：**
>
> **arraylist.
> add(E)
> ;**
>
> **—> return
> boolean**
>
> **将引用尾插到存储引用中**

> ##### **7.1.2 指定位置插 ：**
>
> **arraylist.
> add(index,E)
> ;**
>
> **—> return
> void**
>
> **将引用插入到存储引用指定索引的位置上
> (指定索引的那个引用往
> 前插
> )，一定成功的所以无返回值**

----------------------------------------------

> #### **7.2 并表插引用 ：**
>
> **arraylist.
> addAll(Collection)
> ;**
>
> **—> return
> boolean**
>
> **将另一个集合类里的存储引用全部尾插到此存储引用中
> ，也是默认
> 浅拷贝
> ，也是有
> ArrayList(Collection<? extends E> c)
> 要求**

---

### **8.删除(重载指定)**

* **重载：remove(怎么指定删)**

> #### **8.1 指定索引删 ：**
>
> **arraylist.
> remove(index)
> ;**
>
> **—> return
> E**
>
> **将存储引用里指定索引的那个引用删除
> ，并返回此删除掉的引用**

> #### **8.2 对象搜索删 ：**
>
> **arraylist.
> remove(Object o)
> ;**
>
> **—> return
> boolean**
>
> **将此引用指向的对象与存储引用指向的对象存储内容比较相同删引用
> ，删除第一个遇到的存储引用对象里面存储内容相同的引用**

---

> ### **9. 截取 ：**
>
> **arraylist.
> subList(index1,index2)
> ;**
>
> **—> return
> List<E>**
>
> **将存储引用指定下标范围的部分截取复制到新创建的列表似复刻变量存储引用数组中
> ，返回这个
> 新创建
> 的列表，是
> 浅拷贝
> 把引用复制，指向的实例还是同一的**

---

> ### **10. 清空 ：**
>
> **arraylist.
> clear()
> ;**
>
> **—> return
> void**
>
> **把当前存储引用里的值全部置为null**