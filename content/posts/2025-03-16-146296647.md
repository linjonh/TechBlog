---
layout: post
title: "itsdangerous加解密源码分析BUG汇总"
date: 2025-03-16 23:42:56 +0800
description: "这是我这两天的思考早知道密码学的课就不旷那么多了纯个人见解如需转载，标记出处"
keywords: "itsdangerous加解密源码分析|BUG汇总"
categories: ['未分类']
tags: ['数字签名', 'Itsdangeous']
artid: "146296647"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296647
    alt: "itsdangerous加解密源码分析BUG汇总"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296647
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296647
cover: https://bing.ee123.net/img/rand?artid=146296647
image: https://bing.ee123.net/img/rand?artid=146296647
img: https://bing.ee123.net/img/rand?artid=146296647
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     itsdangerous加解密源码分析|BUG汇总
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      这是我这两天的思考
     </p>
     <p>
      早知道密码学的课就不旷那么多了
     </p>
     <p>
      纯个人见解
     </p>
     <p>
      如需转载，标记出处
     </p>
    </blockquote>
    <p>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D" name="%E4%B8%80%E3%80%81%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D">
     一、官网介绍
    </h2>
    <p>
     <a href="https://itsdangerous.palletsprojects.com/en/stable/" rel="nofollow" title="ItsDangerous — ItsDangerous Documentation (2.2.x)">
      ItsDangerous — ItsDangerous Documentation (2.2.x)
     </a>
    </p>
    <blockquote>
     <p>
      有时，你需要将一些数据发送到不受信任的环境，再将其取回。为了安全，必须对数据进行签名以检测更改。
     </p>
     <p>
      有了只有你知道的密钥，你就可以对数据进行
      <strong>
       加密签名
      </strong>
      并将其交给其他人。取回数据时，可以确保没有人篡改它。
     </p>
     <p>
      接收方可以看到数据，但除非他们也有你的密钥，否则无法改数据。
     </p>
     <p>
      必须将密钥保密且复杂
     </p>
     <p>
     </p>
     <p>
      安装
      <br/>
      pip install -U itsdangerous
     </p>
    </blockquote>
    <h2 id="%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BE%8B%E4%BB%A3%E7%A0%81" name="%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BE%8B%E4%BB%A3%E7%A0%81">
     二、事例代码
    </h2>
    <p>
     只截取部分分析代码
    </p>
    <p>
     1.加解密工具
    </p>
    <pre><code class="language-python">#加密
def generic_openid(openid):

    s = Serializer(secret_key=settings.SECRET_KEY, expires_in=3600)
    access_token = s.dumps({'openid': openid})

    # 将bytes类型的数据转换为 str
    return access_token.decode()

# 解密
def check_access_token(token):
    s = Serializer(secret_key=settings.SECRET_KEY, expires_in=3600)
    try:
        result=s.loads(token)
    except Exception:
        return None
    else:
        return result.get('openid')

</code></pre>
    <p>
     2.功能(判断用户是否绑定，如果没有绑定，hash加密openid生成token给前端，前端收集用户填写的信息，传输时把用户信息＋token一起传递给后端
    </p>
    <pre><code class="language-python">#根据openid进行查询判断用户是否已经绑定
        try:
            qquser = OAuthQQUser.objects.get(openid=openid)
        except OAuthQQUser.DoesNotExist:
            # 不存在
            # 5. 如果没有绑定过，则需要绑定

            access_token = makeToken(openid,3600)
            #前端拿着这个凭证去进行绑定
            response = JsonResponse({'code': 400, 'access_token': access_token})
            return response
        else:
            # 存在
            #如果绑定过，则直接登录</code></pre>
    <p>
     我认为这里的token是一个hash算法生成的签名＋原数据的拼接，它在前端解不开，只能在我的后端解开，这个功能就是为了给前端一个通行证，你可以把自己的用户信息比如邮箱绑定发给我，我后端根据返回来的token来验证是否这个绑定是我想给的用户本人。全程只使用一个密钥加解密，也就是对称加密
    </p>
    <p>
    </p>
    <h4 id="%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A" name="%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A">
     源码分析：
    </h4>
    <h5 id="%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0dump%E6%BA%90%E7%A0%81%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B%EF%BC%9A" name="%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0dump%E6%BA%90%E7%A0%81%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B%EF%BC%9A">
     加密函数dump源码使用的函数如下：
    </h5>
    <p>
     dump做了两个主要工作，创建头部，生成签名
    </p>
    <p>
     <img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/77375a0dd2d24282844c8118f1828c35.png" width="772"/>
    </p>
    <p>
     他在头部里放了这个签名有了什么算法（这里用的是默认算法，HS512)
     <img alt="" height="70" src="https://i-blog.csdnimg.cn/direct/512cf73ca4ea4c6cb5b0555940ea43f8.png" width="672"/>
    </p>
    <p>
     <img alt="" height="135" src="https://i-blog.csdnimg.cn/direct/fbe452e56a2347a78cc99b3a0f68c89e.png" width="675"/>
    </p>
    <p>
     make_signer 函数生成一个签名者对象（signer）。根据当前的 secret_key以及其他salt、algorithm来返回一个用于签名的实例
    </p>
    <p>
     <img alt="" height="539" src="https://i-blog.csdnimg.cn/direct/66202b2bd7a7475399c220297df93946.png" width="671"/>
    </p>
    <p>
     对传入的数据进行签名，返回拼接了签名的数据字符串（原始数据 + 分隔符 + 签名）
    </p>
    <p>
     want_bytes格式化字符串，将其编码成字节
    </p>
    <p>
     <img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/5c5d95c6c5cd47be925d84d8418c6287.png" width="929"/>
    </p>
    <h5 id="%E8%A7%A3%E5%AF%86" name="%E8%A7%A3%E5%AF%86">
     解密
    </h5>
    <p>
     这里先使用make_signer()函数获取验签用的算法
    </p>
    <h5 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="418" src="https://i-blog.csdnimg.cn/direct/697a000d04454adbb8fe8f242c84f4d3.png" width="960"/>
    </h5>
    <p>
     重点是这个unsign函数
    </p>
    <p>
     它对签名过的数据进行验签，返回原始数据
    </p>
    <p>
     signed_value: 已签名的数据= 原始数据 + 分隔符 + 签名
    </p>
    <h5 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="317" src="https://i-blog.csdnimg.cn/direct/b290de1d8bae4430a5080a9729cab562.png" width="834"/>
    </h5>
    <p>
     先判断签名格式。如果签名被篡改（格式不对），捕获异常并返回 False
    </p>
    <p>
     <img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/3239851d8e7d407ab4cf94f28e510f33.png" width="688"/>
    </p>
    <p>
     将拆分下来的数据openid生成新的签名，将原先的签名和新的作比较看是都相同
    </p>
    <p>
     <img alt="" height="183" src="https://i-blog.csdnimg.cn/direct/3b6c06ea6cae49ac8f355b651d7b0316.png" width="838"/>
    </p>
    <h4 id="%E5%85%B3%E4%BA%8E%E7%AD%BE%E5%90%8D%EF%BC%9A" name="%E5%85%B3%E4%BA%8E%E7%AD%BE%E5%90%8D%EF%BC%9A">
    </h4>
    <h5 id="" name="">
    </h5>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81itsdangerousBUG%E6%B1%87%E6%80%BB" name="%E4%BA%8C%E3%80%81itsdangerousBUG%E6%B1%87%E6%80%BB">
     二、itsdangerousBUG汇总
    </h2>
    <p>
    </p>
    <h3 id="1.ImportError%3A%20cannot%20import%20name%20%E2%80%98TimedJSONWebSignatureSerializer%E2%80%98%20from%20%E2%80%98itsdangerous%E2%80%98%C2%A0" name="1.ImportError%3A%20cannot%20import%20name%20%E2%80%98TimedJSONWebSignatureSerializer%E2%80%98%20from%20%E2%80%98itsdangerous%E2%80%98%C2%A0">
     1.ImportError: cannot import name ‘TimedJSONWebSignatureSerializer‘ from ‘itsdangerous‘
    </h3>
    <blockquote>
     <p>
      之前都正常导入
     </p>
     <p>
      from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
     </p>
     <p>
      今天importerror
     </p>
    </blockquote>
    <p>
    </p>
    <h3 id="%E5%8E%9F%E5%9B%A0%EF%BC%9A" name="%E5%8E%9F%E5%9B%A0%EF%BC%9A">
     原因：
    </h3>
    <p>
     <strong>
      itsdangerous 库在高版本中已经移除了
      <code>
       TimedJSONWebSignatureSerializer
      </code>
     </strong>
     ，所以导致导入失败。
    </p>
    <p>
     <code>
      TimedJSONWebSignatureSerializer
     </code>
     是 itsdangerous 早期版本的 API，用来生成带有效期的 token。从
     <strong>
      itsdangerous 2.0
     </strong>
     开始，这个类被
     <strong>
      移除或不推荐使用
     </strong>
     ，官方推荐使用其他方式生成/验证 token（如
     <code>
      URLSafeTimedSerializer
     </code>
     ）。
    </p>
    <p>
     解决办法：
    </p>
    <h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%99%8D%E7%BA%A7%20itsdangerous%20%E5%88%B0%201.1.0%EF%BC%88%E6%88%91%E8%87%AA%E5%B7%B1%E7%94%A8%E7%9A%84%E8%BF%99%E4%B8%AA%EF%BC%89" name="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%99%8D%E7%BA%A7%20itsdangerous%20%E5%88%B0%201.1.0%EF%BC%88%E6%88%91%E8%87%AA%E5%B7%B1%E7%94%A8%E7%9A%84%E8%BF%99%E4%B8%AA%EF%BC%89">
     解决方法一：
     <strong>
      降级 itsdangerous 到 1.1.0（我自己用的这个）
     </strong>
    </h4>
    <p>
     降级 itsdangerous：
    </p>
    <pre><code class="language-python">pip install itsdangerous==1.1.0</code></pre>
    <h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%20URLSafeTimedSerializer%20%E6%9B%BF%E4%BB%A3" name="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%20URLSafeTimedSerializer%20%E6%9B%BF%E4%BB%A3">
     解决方法二：
     <strong>
      使用 URLSafeTimedSerializer 替代
     </strong>
    </h4>
    <p>
     如果不想降级，改用推荐的新写法：
    </p>
    <pre><code class="language-python">
from itsdangerous import URLSafeTimedSerializer 
# 初始化 
serializer = URLSafeTimedSerializer(secret_key='your-secret-key') 
# 生成 
token token = serializer.dumps({'user_id': 123}) 
# 验证 
token try: data = serializer.loads(token, max_age=3600) 
# 3600秒有效期 
print(data) 
except Exception as e: 
print('Token 验证失败:', e)</code></pre>
    <p>
    </p>
    <pre></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323530345f39303236363737332f:61727469636c652f64657461696c732f313436323936363437" class_="artid" style="display:none">
 </p>
</div>


