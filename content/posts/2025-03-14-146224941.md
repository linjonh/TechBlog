---
layout: post
title: "算法随笔_74-不同路径_1"
date: 2025-03-14 12:37:33 +0800
description: "不同路径_1，动态规划，组合数学"
keywords: "算法随笔_74: 不同路径_1"
categories: ['未分类']
tags: ['算法', '数据结构', 'Python']
artid: "146224941"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146224941
    alt: "算法随笔_74-不同路径_1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146224941
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146224941
cover: https://bing.ee123.net/img/rand?artid=146224941
image: https://bing.ee123.net/img/rand?artid=146224941
img: https://bing.ee123.net/img/rand?artid=146224941
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     算法随笔_74: 不同路径_1
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     上一篇:
     <a href="https://blog.csdn.net/m0_70494097/article/details/146211738" title="算法随笔_73: 跳跃游戏-CSDN博客">
      算法随笔_73: 跳跃游戏-CSDN博客
     </a>
    </p>
    <p>
     =====
    </p>
    <p>
     题目描述如下:
    </p>
    <p>
     一个机器人位于一个
     <code>
      m x n
     </code>
     <em>
     </em>
     网格的左上角 （起始点在下图中标记为 “Start” ）。
    </p>
    <p>
     机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
    </p>
    <p>
     问总共有多少条不同的路径？
    </p>
    <p>
     示例 1：
     <br/>
     输入：m = 3, n = 2
     <br/>
     输出：3
     <br/>
     解释：
     <br/>
     从左上角开始，总共有 3 条路径可以到达右下角。
     <br/>
     1. 向右 -&gt; 向下 -&gt; 向下
     <br/>
     2. 向下 -&gt; 向下 -&gt; 向右
     <br/>
     3. 向下 -&gt; 向右 -&gt; 向下
    </p>
    <p>
     =====
    </p>
    <p>
     算法思路:
    </p>
    <p>
     <strong>
      方法1:
     </strong>
    </p>
    <p>
     我们可以使用动态规划解决此问题。我们设res(i, j)表示从左上角到达第i行j列的格子所用的路径数。那么递推关系如下:
    </p>
    <p>
     res(i, j)=res(i, j-1)+res(i-1,j)
    </p>
    <p>
     我们可以从左上角开始遍历网格，按行遍历。设res(0, 0)=1。
    </p>
    <p>
     时间复杂度为O(mn)。下面是Python代码实现:
    </p>
    <pre><code class="hljs">class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        res= [[0 for _ in range(n)] for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if i==0 and j==0:
                    res[i][j]=1
                    continue
                fromL=res[i][j-1] if j&gt;0 else 0
                fromT=res[i-1][j] if i&gt;0 else 0
                res[i][j]=fromL+fromT
        return res[m-1][n-1]</code></pre>
    <p>
     <strong>
      方法2
     </strong>
     :
    </p>
    <p>
     我们还可以通过组合数学方式通过计算得出。我们从左上角移动到右下角，向右走需要n-1步，向下走需要m-1步，总共需要走m+n-2步。那么我们需要从m+n-2里面找出n-1个数的全部组合数C(m+n-2, n-1)即为最终答案。
    </p>
    <p>
     假如我们总共需要走10步。向右总共需要走2步。那在哪2步需要向右走呢？那就是从1至10这10个数里取2个数的全部方案C(10, 2)即为最终答案。
    </p>
    <p>
     在Python 3里可以使用comb(m + n - 2, n - 1)直接计算得出。下面是Python代码实现:
    </p>
    <pre><code class="hljs">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        return comb(m + n - 2, n - 1)</code></pre>
    <p>
     关键词: 动态规划，组合数学
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37303439343039372f:61727469636c652f64657461696c732f313436323234393431" class_="artid" style="display:none">
 </p>
</div>


