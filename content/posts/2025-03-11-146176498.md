---
layout: post
title: "关于VueReact中Diffing算法以及key的作用"
date: 2025-03-11 13:48:25 +0800
description: "关于Vue/React中Diffing算法以及key的作用"
keywords: "关于Vue/React中Diffing算法以及key的作用"
categories: ['前端知识']
tags: ['Vue', 'React', 'Javascript']
artid: "146176498"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146176498
    alt: "关于VueReact中Diffing算法以及key的作用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146176498
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146176498
cover: https://bing.ee123.net/img/rand?artid=146176498
image: https://bing.ee123.net/img/rand?artid=146176498
img: https://bing.ee123.net/img/rand?artid=146176498
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     关于Vue/React中Diffing算法以及key的作用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     最近在学习React和复习Vue相关知识的时候，又重新学习到了两者在循环遍历时key的相关知识内容，正好记录复习一下。
    </p>
    <h2 id="1.%20DIffing%E7%AE%97%E6%B3%95" name="1.%20DIffing%E7%AE%97%E6%B3%95">
     1. DIffing算法
    </h2>
    <p>
     首先React和Vue作为两个前端目前比较热门的框架，两个框架都实现的是将虚拟DOM转换为真实DOM并渲染到页面上，并且有着相当高的效率，一提到效率我们就得先讲解一下两者框架的虚拟DOM中的
     <strong>
      Diffing算法
     </strong>
     。
    </p>
    <h3 id="%C2%A01.1%20React%E4%B8%AD%E7%9A%84Diffing%E7%AE%97%E6%B3%95" name="%C2%A01.1%20React%E4%B8%AD%E7%9A%84Diffing%E7%AE%97%E6%B3%95">
     1.1 React中的Diffing算法
    </h3>
    <p>
     React 采用的是一种叫做
     <strong>
      虚拟 DOM (Virtual DOM)
     </strong>
     的技术，在进行 UI 更新时，React 会先创建一棵虚拟 DOM 树，然后在更新时通过
     <strong>
      diffing
     </strong>
     算法比较旧的虚拟 DOM 和新的虚拟 DOM。React 的 diffing 算法遵循一些优化原则来高效地进行比较。
    </p>
    <p>
     <strong>
      核心原则
     </strong>
    </p>
    <p>
     1.
     <strong>
      单向数据流
     </strong>
     ：
    </p>
    <p>
     React 通过单向数据流来简化 diffing 操作，即所有组件的状态和属性变化都会导致重新渲染。这使得 React 可以将整个应用的变化分解成小的组件更新，方便进行优化。
    </p>
    <p>
     2.
     <strong>
      元素类型不同
     </strong>
     ：
    </p>
    <p>
     如果新旧两个虚拟 DOM 节点的类型不同，React 会直接销毁旧节点并创建一个新节点。例如，如果你从 &lt;div&gt; 改为 &lt;span&gt;，React 就会认为它们是两个完全不同的元素。
    </p>
    <p>
     3.
     <strong>
      相同类型的元素比较子节点
     </strong>
     ：
    </p>
    <p>
     如果新旧节点类型相同，React 会比较它们的子节点。React 通过
     <strong>
      深度优先遍历
     </strong>
     来更新树的不同部分，递归地比较子节点，进行最小更新。
    </p>
    <p>
     4.
     <strong>
      节点复用与排序优化
     </strong>
     ：
    </p>
    <p>
     React 假设相同类型的元素之间不会改变顺序。因此，对于相同类型的兄弟节点，React 会尽量复用它们。如果节点的顺序变化较大，React 会做出必要的调整来减少重渲染。
    </p>
    <p>
     5.
     <strong>
      Keys
     </strong>
     ：
    </p>
    <p>
     React 使用 key 来标识节点在列表中的位置，key 主要用于优化同级元素的更新。当有 key 时，React 会利用它们来决定哪些节点可以复用，从而避免不必要的删除和插入操作。
    </p>
    <p>
     <strong>
      Diffing 过程简述：
     </strong>
    </p>
    <p>
     • React 首先通过
     <strong>
      浅比较
     </strong>
     组件的 props 和 state，决定是否需要更新。
    </p>
    <p>
     • 如果更新必要，React 会根据节点类型判断是否是完全不同的节点（例如标签不同）还是只是部分变化（例如文本内容变化）。
    </p>
    <p>
     • 对于相同类型的节点，React 会比较子节点，并递归处理每一层的变化，采用 O(n) 的时间复杂度进行节点更新。
    </p>
    <h3 id="1.2%20Vue%E4%B8%AD%E7%9A%84Diffing%E7%AE%97%E6%B3%95" name="1.2%20Vue%E4%B8%AD%E7%9A%84Diffing%E7%AE%97%E6%B3%95">
     1.2 Vue中的Diffing算法
    </h3>
    <p>
     Vue 的 diffing 算法也基于虚拟 DOM，但与 React 略有不同，Vue 的 diffing 更加注重性能优化，尤其是在节点更新的过程中。Vue 的实现依赖于其响应式系统和模板编译器，因此它的 diffing 算法可能会和 React 在一些细节上有所区别。
    </p>
    <p>
     <strong>
      核心原则
     </strong>
    </p>
    <p>
     1.
     <strong>
      虚拟 DOM 与响应式系统
     </strong>
     ：
    </p>
    <p>
     Vue 通过数据驱动视图的更新，采用响应式系统，当数据变化时，Vue 会自动触发组件的更新。Vue 的 diffing 算法基于它的
     <strong>
      虚拟 DOM
     </strong>
     实现，Vue 会在每次更新时构建一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行对比。
    </p>
    <p>
     2.
     <strong>
      浅比较
     </strong>
     ：
    </p>
    <p>
     Vue 采用的是
     <strong>
      浅比较
     </strong>
     ，与 React 类似。当虚拟 DOM 中的节点发生变化时，Vue 会只对节点的属性、事件等进行比较。如果节点类型不同，Vue 会重新创建节点。
    </p>
    <p>
     3.
     <strong>
      “就地更新”与“节点复用”
     </strong>
     ：
    </p>
    <p>
     Vue 使用了一种
     <strong>
      就地更新
     </strong>
     的策略，尽量避免无意义的 DOM 操作。如果某些节点的变化不会影响 DOM，Vue 会选择不更新这些节点，只更新发生变化的部分。Vue 会尽量保留现有节点，避免不必要的重渲染。
    </p>
    <p>
     4.
     <strong>
      动态节点与静态节点分离
     </strong>
     ：
    </p>
    <p>
     Vue 会对节点进行分类，将
     <strong>
      静态节点
     </strong>
     和
     <strong>
      动态节点
     </strong>
     分离。静态节点不会被重新渲染，而动态节点会根据数据的变化进行更新。Vue 会通过
     <strong>
      树的比较
     </strong>
     来优化更新过程，从而减少不必要的操作。
    </p>
    <p>
     5.
     <strong>
      Keys
     </strong>
     ：
    </p>
    <p>
     Vue 也支持使用 key 来优化 diffing 算法。当同一层级的节点发生变化时，Vue 会通过 key 来识别并更新节点的位置，以便提高渲染效率。
    </p>
    <p>
     <strong>
      Diffing 过程简述：
     </strong>
    </p>
    <p>
     • Vue 会通过构建新的虚拟 DOM 树并与旧的虚拟 DOM 树进行比较。
    </p>
    <p>
     • 在比较过程中，Vue 会对比节点的
     <strong>
      类型、属性、事件等
     </strong>
     ，如果类型不同，Vue 会销毁旧节点并创建新节点。
    </p>
    <p>
     • 对于相同类型的节点，Vue 会利用它的
     <strong>
      优化策略
     </strong>
     （如静态节点的保留、动态节点的更新）来决定哪些节点需要更新。
    </p>
    <p>
     • Vue 会依赖 key 来帮助优化同级节点的更新。
    </p>
    <h3 id="1.3%20%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" name="1.3%20%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94">
     1.3 两者对比
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <p>
         <strong>
          特性
         </strong>
        </p>
       </th>
       <th>
        <p>
         <strong>
          React
         </strong>
        </p>
       </th>
       <th>
        <p>
         <strong>
          Vue
         </strong>
        </p>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <p>
         <strong>
          虚拟 DOM
         </strong>
        </p>
       </td>
       <td>
        <p>
         是的，React 使用虚拟 DOM，进行最小化的 DOM 更新
        </p>
       </td>
       <td>
        <p>
         是的，Vue 使用虚拟 DOM，并通过响应式系统触发更新
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <strong>
          浅比较
         </strong>
        </p>
       </td>
       <td>
        <p>
         是的，React 通过浅比较来决定是否更新节点
        </p>
       </td>
       <td>
        <p>
         是的，Vue 也通过浅比较来判断节点的变化
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <strong>
          节点类型变化
         </strong>
        </p>
       </td>
       <td>
        <p>
         类型不同的节点会完全重新渲染
        </p>
       </td>
       <td>
        <p>
         同 React，类型不同的节点会完全重新渲染
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <strong>
          子节点比较
         </strong>
        </p>
       </td>
       <td>
        <p>
         对于相同类型的节点，会比较子节点并递归更新
        </p>
       </td>
       <td>
        <p>
         同样，Vue 会递归比较子节点，尤其注重静态与动态节点的区分
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <strong>
          key 的使用
         </strong>
        </p>
       </td>
       <td>
        <p>
         使用 key 来优化列表更新，帮助避免不必要的 DOM 操作
        </p>
       </td>
       <td>
        <p>
         使用 key 来优化同层节点的更新
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <strong>
          更新优化
         </strong>
        </p>
       </td>
       <td>
        <p>
         React 假设节点顺序不会频繁变化，利用双指针算法减少更新
        </p>
       </td>
       <td>
        <p>
         Vue 更加注重节点复用和静态节点的分离，优化树的
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h2 id="2.%20React%2FVue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8(key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86)" name="2.%20React%2FVue%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8(key%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86)">
     2. React/Vue中key的作用(key的内部原理)
    </h2>
    <p>
     当数据发生变化时，React会根据新的数据生成新的虚拟DOM，随后React进行diff算法比较，主要规则如下：
    </p>
    <p>
     a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
    </p>
    <p>
     (1) 若虚拟DOM中内容没变，直接使用之前的真实DOM
    </p>
    <p>
     (2) 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉旧的真实DOM
    </p>
    <p>
     b. 旧虚拟DOM中未找到与新虚拟DOM相同的key：
    </p>
    <p>
     根据数据创建新的真实DOM，随后渲染到页面
    </p>
    <p>
     但是如果我们简单的使用index作为key的话，那么请看以下代码：
    </p>
    <pre><code class="language-javascript">class Person extends React.Component {
        state = {
            persons: [
                {id:1, name: 'stephen', age:18},
                {id:2, name: 'Jack', age:21}
            ]
        }

        render() {
            return (
                &lt;div&gt;
                    &lt;h2&gt;Show Informations&lt;/h2&gt;
                    &lt;button onClick={this.add}&gt;Add James&lt;/button&gt;
                    &lt;ul&gt;
                        {
                            this.state.persons.map((person, index) =&gt; {
                                return &lt;li key={index}&gt;{person.name} -- {person.age}&lt;/li&gt;
                            })
                        }
                    &lt;/ul&gt;
                &lt;/div&gt;
            )
        }

        add = () =&gt; {
            const {persons} = this.state
            const p = {id: persons.length+1, name: 'James', age: 20}
            {/* 注意此时的添加顺序是逆序的 */}
            this.setState({persons: [p, ...persons]})
        }
    }

    ReactDOM.render(&lt;Person/&gt;, document.getElementById('test'))</code></pre>
    <p>
     并且请注意我此时添加的顺序是
     <strong>
      逆序
     </strong>
     的，那么React在生成虚拟DOM进行diffing算法对比时就会出现问题：
    </p>
    <p>
     <img alt="" height="648" src="https://i-blog.csdnimg.cn/direct/a8998946313947609454dff4941ed4b4.png" width="1264"/>
    </p>
    <p>
     当进行Diffing对比时，按照规则对比key时，发现对应不上，也就是说React又重新帮我们重新创建出三个虚拟DOM，其实我们只添加了一条数据但是却要创建多个虚拟DOM，如果我们本身的数据量很大，那么带来了一定的资源浪费，这是我们需要避免的。
    </p>
    <p>
     但是其实有人也发现了：那如果我不逆序添加不就没有问题了吗，对于上述例子来说这种说法是正确的。但是问题又来了，这仅仅是数据的展示，如果每一个&lt;li&gt;标签下又存在一个&lt;input&gt;标签，我们需要为每一个&lt;li&gt;标签添加对应的&lt;input&gt;值，如果此时我们使用index作为key，后续生成新的DOM时会发现原先对应的数据顺序全部混乱，这在我们开发时是十分重大错误。产生这个原因在于我上述所讲到的React 在diffing算法时的原理，按照每一个标签进行渲染。
    </p>
    <h2 id="3.%20%E6%AD%A3%E7%A1%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" name="3.%20%E6%AD%A3%E7%A1%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">
     3. 正确解决方案
    </h2>
    <p>
     我们在开发过程中使用key尽量避免用index以免产生错误或者效率问题。我们应该选用数据的唯一标识，例如后端服务器传回来的data中，可能会含有Primary Key的字段，那么我们可以使用该字段作为key来避免一些问题的出现，以下是合理代码的改造：
    </p>
    <pre><code class="language-javascript">class Person extends React.Component {
        state = {
            persons: [
                {id:1, name: 'stephen', age:18},
                {id:2, name: 'jack', age:21}
            ]
        }

        render() {
            return (
                &lt;div&gt;
                    &lt;h2&gt;Show Informations&lt;/h2&gt;
                    &lt;button onClick={this.add}&gt;Add James&lt;/button&gt;
                    &lt;ul&gt;
                        {
                            this.state.persons.map((person) =&gt; {
                                return &lt;li key={person.id}&gt;{person.name} -- {person.age}&lt;/li&gt;
                            })
                        }
                    &lt;/ul&gt;
                &lt;/div&gt;
            )
        }

        add = () =&gt; {
            const {persons} = this.state
            const p = {id: persons.length+1, name: 'James', age: 20}
            this.setState({persons: [p, ...persons]})
        }
    }

    ReactDOM.render(&lt;Person/&gt;, document.getElementById('test'))</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36313439323837312f:61727469636c652f64657461696c732f313436313736343938" class_="artid" style="display:none">
 </p>
</div>


