---
layout: post
title: "Java常见面试技术点整理讲解后端框架整理中,未完成"
date: 2025-03-10 09:55:49 +0800
description: "主要用于规整Java后端各种框架，面试使用及原理相关问题。"
keywords: "Java常见面试技术点整理讲解——后端框架（整理中，未完成）"
categories: ['技术积累']
tags: ['面试', 'Spring', 'Spring', 'Servlet', 'Sentinel', 'Java', 'Cloud', 'Boot']
artid: "146144846"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146144846
    alt: "Java常见面试技术点整理讲解后端框架整理中,未完成"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146144846
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146144846
cover: https://bing.ee123.net/img/rand?artid=146144846
image: https://bing.ee123.net/img/rand?artid=146144846
img: https://bing.ee123.net/img/rand?artid=146144846
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java常见面试技术点整理讲解——后端框架（整理中，未完成）
    </h1>
   </div>
  </div>
 </div>
 <a data-report-click='{"spm":"1001.2101.3001.8632"}' data-report-query="spm=1001.2101.3001.8632" data-report-view='{"spm":"1001.2101.3001.8632"}' href="https://activity.csdn.net/writing?id=10820" id="creatActivityHref" style="display:block;margin-top:16px;font-size:16px;color:#5094d5;font-weight:500" target="_blank">
  #“学C++，赢好礼”——侯捷C++系列精品课学习笔记征文活动#
 </a>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p name="%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6">
     前言：
    </p>
    <p>
     对于后端常用框架的技术整理，其实框架在平时就是会用就行，但面试时多半需要描述实现原理，这个要靠自己理解，不推荐死记硬背。
    </p>
    <p>
     这篇和另外几篇文章区分开，主要用于规整Java后端各种框架，面试使用及原理相关问题。
    </p>
    <h2 id="%E4%B8%80%EF%BC%9ASpring" name="%E4%B8%80%EF%BC%9ASpring">
     一：Spring
    </h2>
    <p>
     Spring是一个轻量级开源的后端框架，是为Java应用程序提供基础性服务的一套框架。核心功能为IOC容器管理和AOP面向切面编程。
    </p>
    <h3 id="1%EF%BC%9ASpring%20IOC%E7%9A%84%E7%90%86%E8%A7%A3" name="1%EF%BC%9ASpring%20IOC%E7%9A%84%E7%90%86%E8%A7%A3">
     1：Spring IOC的理解
    </h3>
    <blockquote>
     <p>
      总：控制反转，即原来的对象是由使用者控制(手动new创建)，有了Spring之后，可以把整个对象交给Spring来帮我们管理。降低代码耦合性。
     </p>
     <p>
      容器：存储Bean对象，底层使用map结构来存储。singletonObjects存放完整的Bean对象。
     </p>
     <p>
      （可引出Bean的生命周期，从创建到销毁的过程都是容器管理。生命周期可引出循环依赖问题，进而可引出三级缓存处理及原理。）
     </p>
    </blockquote>
    <p>
     BeanFactory：基础容器，提供基础DI功能，延迟加载（使用时才实例化Bean）
    </p>
    <p>
     ApplicationContext（更常用）：扩展自BeanFactory，支持更多企业级功能（AOP、事件、国际化等）预加载单例Bean（容器启动时实例化所有非懒加载的Bean）。通常说的容器就指这个。
    </p>
    <p>
     如果直接使用BeanFactory创建Bean，需手动提供IOC加载过程的所需资源，如BeanDifinition。
    </p>
    <p>
     而ApplicationContext则封装了整个IOC的加载过程，更加自动。
    </p>
    <p>
     1：实例化容器对象
    </p>
    <ul>
     <li>
      ClassPathXmlApplicationContext：基于 XML 配置的应用程序上下文实现。它从类路径中加载 XML 配置文件，这些文件包含了 Spring Bean 的定义和配置信息。开发人员需要在 XML 文件中使用特定的标签（如 &lt;bean&gt;）来定义和配置 Spring Bean。
     </li>
     <li>
      AnnotationConfigApplicationContext：基于注解配置的应用程序上下文实现。它不需要 XML 配置文件，而是使用配置类（例如通过 @Configuration 注解标记的类）来定义和配置 Spring Bean。这种方式将配置信息直接嵌入到 Java 代码中。
     </li>
    </ul>
    <p>
     通过构造函数初始化容器，触发核心方法 refresh() 创建并启动容器。
    </p>
    <pre><code class="language-java">//Spring容器创建流程
//1: 使用AnnotationConfigApplicationContext（类.class）  ClassPathXmlApplicationContext（管理Bean的XML文件） 创建
AnnotationConfigApplicationContext annotationContext = new AnnotationConfigApplicationContext(Empvo.class);
ClassPathXmlApplicationContext classPathContext = new ClassPathXmlApplicationContext("XXX.xml");</code></pre>
    <p>
     二者都会调用核心方法refresh，区别于配置方式不同(xml，注解)，前置准备有所不同，但都是
    </p>
    <p>
     读取和扫描文件或配置类，处理一些初始化和环境的设置。之后Spring会统一进行处理。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/9ef85634a53242b28c6fc5d7fca7ee94.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b680c88118324aec888675edb4c7583a.png"/>
    </p>
    <p>
     2：加载配置与注册Bean定义
    </p>
    <p>
     不论通过何种方式（解析XML、Java Config、注解如@ComponentScan等），解析获取的Bean对象，Spring会把bean的配置信息（如BeanCLass、scope等）统一存储在：
    </p>
    <p>
     BeanDefinition对象中，需注意该对象是一个接口，封装了所有Bean的定义信息，后续创建Bean就需要根据这些定义信息来创建，即想要创建Bean，先要注册BeanDefinition。
    </p>
    <p>
     AbstractBeanDefinition是BeanDefinition接口的一个抽象实现类，该抽象类及其子类用于在Spring容器内部管理和操作Bean的元数据，如Bean的实例化、属性注入和初始化等。
    </p>
    <p>
     所以，一个Bean会对应一个BeanDefinition，之后所有的BeanDefinition会存储到BeanFactory的beanDefinitionMap中，使用ConcurrentHashMap进行存储，用bean的名称作为键，对象作为值。
    </p>
    <p>
     3：创建Bean
    </p>
    <p>
     在循环BeanDefinition创建Bean之前，Spring容器会判断这个Bean：
    </p>
    <p>
     是否懒加载（xml设置：lazy-init="true"，注解设置：@Lazy，可加在配置类或@Bean方法上）。
    </p>
    <p>
     是否多例（xml设置：scope="prototype"，注解设置：@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)即可）。
    </p>
    <p>
     且判断不为抽象类。
    </p>
    <p>
     懒加载表示只有在使用时才创建。
    </p>
    <p>
     Spring容器Bean默认是单例的，如果设置多例，则只在使用时创建，且每次都重新创建实例。
    </p>
    <hr/>
    <p>
     创建Bean：
    </p>
    <p>
     创建Bean实例的过程包括实例化Bean对象、注入依赖、调用生命周期回调方法等。
    </p>
    <p>
     首先循环beanDefinitionMap，根据名称调用getBean(beanName) ，doGetBean(beanName)
    </p>
    <p>
     之后会调用 getSingleton(beanName) 判断单例池是否实例化过。如果没有则创建Bean实例。
    </p>
    <blockquote>
     <p>
      1：实例化Bean
     </p>
     <p>
      创建Bean的关键方法，createBean(beanName,mbd,args)，doCreateBean()实例化。
     </p>
     <p>
      通过createBeanInstance()创建Bean实例，实例化时使用构造方法或者工厂方法，底层是通过反射获取对象。
     </p>
     <p>
      先根据BeanName获取到BeanDefinition实例，然后通过 getBeanClass() 获取到Class&lt;&gt;实例，随后使用Class实例的无参构造创建Bean对象实例：getConstractor().newInstance()；
     </p>
     <p>
      此时创建的Bean称为纯净Bean（未完成）。
     </p>
     <p>
      2：属性注入
     </p>
     <p>
      创建Bean实例后，Spring容器会根据BeanDefinition中的信息来配置Bean，例如设置属性值、注入依赖等。尤其是处理@Autowired，此时会再走到 getBean 方法处，尝试从单例池获取，获取不到就创建。因为之前创建的纯净Bean依赖这个实例。（引出循环依赖问题）。
     </p>
     <p>
      3：初始化Bean
     </p>
     <p>
      随后，Spring容器会调用Bean的初始化方法来完成Bean的初始化。共有三种不同的方式。
     </p>
     <p>
      注意如果同时配置，执行有先后顺序（销毁时顺序相反）：
     </p>
     <p>
      ——》在指定方法上使用注解：@PostConstruct
     </p>
     <p>
      ——》实现 InitializingBean 接口的：afterPropertiesSet () 方法
     </p>
     <p>
      ——》xml方式在Bean标签处添加：init-method指定的方法 或 @Bean()添加init-method属性
     </p>
     <p>
      4：最后，会将Bean放在单例池 singletonObjects 下。
     </p>
    </blockquote>
    <p>
     以下是使用ApplicationContext.getBean()，体现创建Bean的过程。
    </p>
    <pre><code class="language-java">public Object getBean(String name) throws BeansException {
      this.assertBeanFactoryActive();
      //底层也是调用BeanFactory的方法
      //这里使用的是简单工厂模式，根据标识返回不同的对象。最后使用多态接收。
      return this.getBeanFactory().getBean(name);
}</code></pre>
    <hr/>
    <p>
     创建后的Bean会放在单例池中：DefaultSingletonBeanRegistry类下的 singletonObjects 集合。
    </p>
    <p>
     存储结构为ConcurrentHashMap&lt;beanName, Object&gt;，其中键是Bean的名称（ID），值是对应的Bean实例对象。
    </p>
    <p>
     Spring容器在启动时会创建好所有单例Bean的实例，并将其存储在单例池中。当客户端请求获取单例Bean时，Spring容器会直接从单例池中获取已经创建好的Bean实例，而不需要每次都重新创建。
    </p>
    <h3 id="2%EF%BC%9ADI%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%C2%A0" name="2%EF%BC%9ADI%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%C2%A0">
     2：DI 依赖注入
    </h3>
    <p>
     在需要使用Spring容器对象时，可将对应的属性值注入到具体的对象中，依赖注入有三种方式：
    </p>
    <hr/>
    <p>
     构造器注入：通过类的构造方法传递依赖对象
    </p>
    <p>
     将一个配置类的方法添加@Bean注解，在返回的对象中设置一个final对象，通过构造器赋值。
    </p>
    <p>
     官方推荐使用构造器注入，因为它强制依赖不可变，并且保证完全初始化的对象。符合不可变对象设计原则。好处是有助于保持代码的清晰和可测试性。缺点是不够灵活，不够简洁。
    </p>
    <hr/>
    <p>
     Setter注入：通过类的 Setter 方法设置依赖对象
    </p>
    <p>
     在XML中配置需注入的属性位置及信息，在指定类下创建set方法，并添加 @Autowired 注解。
    </p>
    <p>
     Setter注入方式，相比构造器更加灵活，依赖对象可以在对象创建后动态设置。但需谨慎使用，仅在依赖可能变化的场景使用。对象可能在未完全初始化时被使用（需注意空指针问题）。
    </p>
    <hr/>
    <p>
     字段注入：使用注解，直接通过字段或成员变量注入依赖，无需构造方法或 Setter。
    </p>
    <p>
     使用@Autowired（Spring注解） 或 @Resourse（JSR-250规范，Java EE注解），注入对象。
    </p>
    <p>
     目前使用较多的一种方式，代码简介，适合快速开发。通过反射进行注入，有两种注入方式：
    </p>
    <p>
     @Autowired 默认按类型注入，可配合 @Qualifier 按名称注入。
    </p>
    <p>
     @Resource 默认按名称注入，找不到名称时按类型注入。
    </p>
    <p>
     该方式缺点是依赖关系不明确，需避免重复依赖。单元测试不方便。
    </p>
    <h3 id="3%EF%BC%9ABean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" name="3%EF%BC%9ABean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">
     3：Bean的生命周期
    </h3>
    <p>
     总：总体分为以下几个环节，其中可以通过 BeanPostProcessor 插入扩展逻辑（贯穿全流程）
    </p>
    <blockquote>
     <p>
      实例化 → 属性注入 → Aware → 前置处理 → 初始化 → 后置处理 → 使用 → 销毁
     </p>
    </blockquote>
    <p>
     下面是各个环节详细描述：
    </p>
    <h4 id="1%EF%BC%9ABean%E5%8A%A0%E8%BD%BD%E5%AE%9A%E4%B9%89" name="1%EF%BC%9ABean%E5%8A%A0%E8%BD%BD%E5%AE%9A%E4%B9%89">
     1：Bean加载定义
    </h4>
    <p>
     容器解析、读取、扫描配置，生成BeanDifinition实例并注册到BeanFactory的map中。
    </p>
    <h4 id="2%EF%BC%9ABeanFactoryPostProcessor%E5%A4%84%E7%90%86" name="2%EF%BC%9ABeanFactoryPostProcessor%E5%A4%84%E7%90%86">
     2：BeanFactoryPostProcessor处理
    </h4>
    <p>
     该对象是Spring容器的一个扩展点，允许在Bean实例化之前修改Bean的定义（BeanDefinition），
    </p>
    <p>
     通常用于在应用程序上下文加载时调整配置，比如修改属性值、添加属性等。
    </p>
    <p>
     常见场景有：
    </p>
    <p>
     <strong>
      1：解析配置文件占位符
     </strong>
    </p>
    <p>
     解析配置文件（如 application.properties）中的 ${...} 占位符
    </p>
    <pre><code class="language-XML">&lt;bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;
    &lt;property name="location" value="classpath:config.properties"/&gt;
&lt;/bean&gt;
</code></pre>
    <p>
     <strong>
      ‌2：动态覆盖 Bean 定义
     </strong>
    </p>
    <p>
     根据环境变量或条件修改 Bean 的元数据（如类名、作用域、属性值）。
    </p>
    <pre><code class="language-java">public class DynamicBeanProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        BeanDefinition beanDef = beanFactory.getBeanDefinition("dataSource");
        beanDef.getPropertyValues().add("url", "jdbc:new-url");
    }
}
</code></pre>
    <p>
     <strong>
      3：根据条件注册或移除Bean
     </strong>
    </p>
    <p>
     根据运行时条件（如系统参数）动态注册或移除 Bean。
    </p>
    <pre><code class="language-java">public class ConditionalBeanProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        if (!System.getProperty("env").equals("prod")) {
            ((BeanDefinitionRegistry) beanFactory).removeBeanDefinition("prodOnlyBean");
        }
    }
}
</code></pre>
    <p>
     其他还有：Profile 激活扩展、配置类增强、自定义注解解析等场景。
    </p>
    <h4 id="3%EF%BC%9ABean%E5%AE%9E%E4%BE%8B%E5%8C%96" name="3%EF%BC%9ABean%E5%AE%9E%E4%BE%8B%E5%8C%96">
     3：Bean实例化
    </h4>
    <p>
     通过反射原理，从构造方法或工厂方法实例化Bean，优先尝试从单例池获取Bean实例，获取不到则进行创建。
    </p>
    <h4 id="4%EF%BC%9A%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5" name="4%EF%BC%9A%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5">
     4：属性注入
    </h4>
    <p>
     通过populateBean() 方法，注入Bean的属性和依赖：
    </p>
    <p>
     调用 postProcessProperties() 方法注入依赖，例如@Autowired；
    </p>
    <p>
     调用 applyPropertyValues() 方法设置属性值，例如@Value;
    </p>
    <p>
     这个节点可以引出循环依赖问题，进而可以引出三级缓存处理。
    </p>
    <pre><code class="language-java">// 简化版源码逻辑
protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
    // 1. 处理 @Autowired/@Value 注解
    if (hasInstAwareBpps) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
                // 触发注解注入
                ((InstantiationAwareBeanPostProcessor) bp).postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
            }
        }
    }

    // 2. 处理 XML/Java Config 显式属性定义
    applyPropertyValues(beanName, mbd, bw, pvs);
}
</code></pre>
    <h4 id="5%EF%BC%9AAware%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83" name="5%EF%BC%9AAware%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83">
     5：Aware接口回调
    </h4>
    <p>
     属性注入完成后，调用invokeAwareMethod()方法，实现接口可设置Bean的上下文信息，完成对象的属性设置。常见的例如有：
    </p>
    <p>
     BeanNameAware  =&gt;  setBeanName()
    </p>
    <p>
     BeanClassLoaderAware  =&gt;  setBeanClassLoader()
    </p>
    <p>
     BeanFactoryAware  =&gt;  setBeanFactory()
    </p>
    <p>
     ApplicationContextAware  =&gt;  setApplicationContextAware()    需注意此时容器未初始化。
    </p>
    <h4 id="6%EF%BC%9ABeanPostProcessor%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86" name="6%EF%BC%9ABeanPostProcessor%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86">
     6：BeanPostProcessor前置处理
    </h4>
    <p>
     执行所有，实现了BeanPostProcessor下的 postProcessBeforeInitialization() 方法。
    </p>
    <pre><code class="language-java">@Component
public class LoggingBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        System.out.println("🟡 前置处理 Bean: " + beanName + " | 类型: " + bean.getClass());
        // 可在此修改 Bean 属性或返回代理对象
        return bean;
    }
}
</code></pre>
    <p>
     场景运用场景，日志监控（耗时），属性校验（是否非空）等。
    </p>
    <p>
     以及做其他个性化操作，但是要注意，避免在其中执行耗时操作（影响启动速度）。
    </p>
    <h4 id="7%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95" name="7%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">
     7：初始化方法
    </h4>
    <p>
     前置处理完成后，调用初始化方法，并判断是否实现了InitializingBean，如果有则调用afterPropertiesSet() 方法，如果没有则不调用。
    </p>
    <pre><code class="language-java">AbstractAutowireCapableBeanFactory#initializeBean() {
    // 1️⃣ BeanPostProcessor 前置处理
    applyBeanPostProcessorsBeforeInitialization();

    // 2️⃣ 执行 InitializingBean 逻辑（核心阶段）
    invokeInitMethods() {
        if (bean instanceof InitializingBean) {
            ((InitializingBean) bean).afterPropertiesSet();
        }
        // 3️⃣ 执行自定义 init-method（XML/Java Config 定义）
        invokeCustomInitMethod();
    }

    // 4️⃣ BeanPostProcessor 后置处理
    applyBeanPostProcessorsAfterInitialization();
}
</code></pre>
    <p>
     调用初始化有三种方式，且有先后顺序，推荐使用 @PostConstruct 注解方式
    </p>
    <pre><code class="language-java">@Service
public class PaymentService implements InitializingBean {
    // 组合使用三种初始化方式
    @PostConstruct
    public void validateConfig() {
        System.out.println("🟢 @PostConstruct 优先执行");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("🟠 InitializingBean 次之执行");
    }

    @Bean(initMethod = "initMethod")
    public void initMethod() {
        System.out.println("🔵 init-method 最后执行");
    }
}
</code></pre>
    <p>
     避免在 afterPropertiesSet() 执行数据库连接等阻塞操作，可结合 @Lazy 注解优化启动速度。
    </p>
    <h4 id="8%EF%BC%9ABeanPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86" name="8%EF%BC%9ABeanPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86">
     8：BeanPostProcessor后置处理
    </h4>
    <p>
     执行所有，实现了BeanPostProcessor下的 postProcessAfterInitialization() 方法。
    </p>
    <p>
     Spring的AOP动态代理，就是在此处实现的。
    </p>
    <pre><code class="language-java">@Component
public class LoggingBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("🟡 后置处理 Bean: " + beanName + " | 类型: " + bean.getClass());
        // 可在此生成代理对象，例如AOP动态代理
        return bean;
    }
}
</code></pre>
    <h4 id="9%EF%BC%9ABean%E5%B0%B1%E7%BB%AA" name="9%EF%BC%9ABean%E5%B0%B1%E7%BB%AA">
     9：Bean就绪
    </h4>
    <p>
     完成的Bean对象，被放入容器中，可通过依赖注入，或直接 getBean() 的方式来进行对象的获取及使用。
    </p>
    <h4 id="10%EF%BC%9A%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5" name="10%EF%BC%9A%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5">
     10：销毁阶段
    </h4>
    <p>
     容器关闭或手动调用close方法时，执行销毁流程。如果提供了多个销毁方法，按照顺序执行。
    </p>
    <p>
     注意在执行销毁方法前，会优先执行：
    </p>
    <p>
     DestructionAwareBeanPostProcessor（接口）下的 postProcessBeforeDestruction 方法。
    </p>
    <pre><code class="language-java">@Component
public class DemoApplicationTests implements DestructionAwareBeanPostProcessor {
    @Override
    public void postProcessBeforeDestruction(Object o, String s) throws BeansException {
        //销毁前置处理，优先执行
    }
}</code></pre>
    <p>
     之后，按照顺序执行提供的销毁方法。三种方式分别为：
    </p>
    <p>
     @PreDestroy 注解方法，优先执行
    </p>
    <p>
     实现DisposableBean接口，重写方法destroy()，次之执行
    </p>
    <p>
     自定义销毁方法，如XML：destroy-method="customDestroy"，或@Bean(destroyMethod = "customDestroy")，最后执行。
    </p>
    <pre><code class="language-java">// 实现销毁逻辑的三种方式
public class DemoBean implements DisposableBean {
    @PreDestroy
    public void preDestroy() {
        System.out.println("1注解方式优先执行，@PreDestroy 方法");
    }

    @Override
    public void destroy() {
        System.out.println("2接口实现次之执行，DisposableBean#destroy()");
    }

    //注解或XML配置的自定义方法，最后执行
    public void xmlDestroy() {
        System.out.println("XML 配置的 destroy-method");
    }
    
    @Bean(destroyMethod = "customDestroy")
    public ExampleBean exampleBean() { 
        return new ExampleBean(); 
    }

}

// 测试销毁流程
public class App {
    public static void main(String[] args) {
        ConfigurableApplicationContext ctx = SpringApplication.run(App.class);
        ctx.close(); // 触发销毁
    }
}
</code></pre>
    <p>
     Spring 不触发Prototype作用域（多例）的 Bean，需手动触发多例Bean的销毁。
    </p>
    <p>
     例如：BeanFactory.destroyBean(beanInstance) 。
    </p>
    <p>
     若某个销毁方法抛出异常，Spring 会记录错误（WARN 级别）但‌继续执行后续销毁逻辑‌。
    </p>
    <p>
     若未显式指定 destroyMethod，Spring 会自动检测 close() 或 shutdown() 方法（可通过 @Bean(destroyMethod = "") 禁用）。
    </p>
    <h3 id="4%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98" name="4%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98">
     4：循环依赖及三级缓存
    </h3>
    <blockquote>
     <p>
      前文提过，在Bean实例化之后，属性注入阶段，可能发生循环依赖问题。
     </p>
     <p>
      总：循环依赖问题是：A引用B，B引用A，造成一直实例化并注入依赖的过程。
     </p>
     <p>
      处理方式：三级缓存，提前暴露对象，AOP
     </p>
    </blockquote>
    <p>
     三级缓存其实就是不同的三个Map集合，用于存放不同Bean的相关对象。
    </p>
    <table align="center" border="1">
     <thead>
      <tr>
       <th>
        ‌缓存级别
       </th>
       <th>
        存储内容
       </th>
       <th>
        作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        一级缓存‌（singletonObjects）
       </td>
       <td>
        完整的单例Bean
       </td>
       <td>
        对外提供可用的Bean
       </td>
      </tr>
      <tr>
       <td>
        二级缓存‌（earlySingletonObjects）
       </td>
       <td>
        提前暴露的未初始化Bean（半成品）
       </td>
       <td>
        临时存储，解决循环依赖的核心
       </td>
      </tr>
      <tr>
       <td>
        ‌三级缓存‌（singletonFactories）
       </td>
       <td>
        Bean工厂（ObjectFactory）
       </td>
       <td>
        早期引用，处理动态代理逻辑
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     三级缓存：Map&lt;BeanName, () -&gt; getEarlyBeanReference()&gt;
    </p>
    <p>
     二级缓存：Map&lt;BeanName, 原始对象/代理对象&gt;
    </p>
    <p>
     一级缓存：Map&lt;BeanName, 完全体Bean&gt;
    </p>
    <p>
     解决思路：在B引用A时候，此时其实A已经实例化了，但未初始化，所以可以设法先拿到A的实例化对象，将B初始化完成之后，再将A的属性补全。
    </p>
    <p>
     所以，循环依赖的核心处理逻辑就是：将Bean的‌实例化‌与‌初始化‌分离，三级缓存作为中间态解决依赖注入时序问题。
    </p>
    <p>
     为什么要三级缓存：三级缓存的设计是为了效率和正确性，避免重复创建和保证单例。三级缓存催在的意义是保证在整个容器的运行过程中同名的Bean对象只能有一个。
    </p>
    <p>
     若Bean需要AOP代理，三级缓存的ObjectFactory会‌提前生成代理对象‌，确保依赖注入的正确性。
    </p>
    <p>
     Spring 之所以需要三级缓存而不是简单的二级缓存，主要原因在于AOP代理和Bean的早期引用问题。二级缓存虽然可以解决循环依赖的问题，但在涉及到动态代理（AOP)时，直接使用二级缓存不做任何处理会导致我们拿到的Bean是未代理的原始对象。如果二级缓存内存放的都是代理对象，则违反了Bean的生命周期。（正常代理对象的生成是在后置处理器）
    </p>
    <hr/>
    <p>
     所以，针对循环依赖问题，所有创建的Bean都要优先放到三级缓存中，后续向一二级缓存提升。
    </p>
    <p>
     针对上述问题，调整后的实例化和属性注入流程为：
    </p>
    <h4 id="1%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96A" name="1%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96A">
     1：实例化A
    </h4>
    <p>
     A实例化完毕后，但未进行属性注入时，将创建A的ObjectFactory并存入三级缓存。
    </p>
    <pre><code class="language-java">// 源码位置：AbstractAutowireCapableBeanFactory
addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, bean, beanDefinition));</code></pre>
    <p>
     Lambda表达式即为ObjectFactory，该对象只负责生成Bean的早期引用（非BeanFactory）。
    </p>
    <p>
     注意需优先判断对象是否需要被代理，如果是代理对象，则覆盖原来对象，重新创建。
    </p>
    <pre><code class="language-java">// 伪代码：AbstractAutoProxyCreator
protected Object getEarlyBeanReference(String beanName, Object bean) {
    //...
    return wrapIfNecessary(bean, beanName);
}</code></pre>
    <p>
     随后进行三级缓存的操作，注意有其他的后续操作。
    </p>
    <pre><code class="language-java">// DefaultSingletonBeanRegistry
protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
    synchronized (this.singletonObjects) {    //加锁，确保三级缓存-二级缓存的原子性
        if (!this.singletonObjects.containsKey(beanName)) {
            this.singletonFactories.put(beanName, singletonFactory); // 存入三级缓存
            this.earlySingletonObjects.remove(beanName);   //清除二级缓存
            this.registeredSingletons.add(beanName);  //记录所有单例Bean的注册状态
        }
    }
}
</code></pre>
    <p>
     上述涉及到几个知识点：
    </p>
    <p>
     1：加锁，为了保证三级缓存到二级缓存的唯一性，避免并发问题。
    </p>
    <p>
     2：earlySingletonObjects.remove(beanName)，清除二级缓存。是为了保证获取的是最新的早期对象。比如AOP代理对象的唯一性、多个线程的并发安全。
    </p>
    <p>
     3：registeredSingletons.add(beanName)，将当前正在创建的 Bean 名称（
     <code>
      beanName
     </code>
     ）添加到一个‌有序集合‌中，记录所有已注册的单例 Bean。使用LinkedHashSet有序存储，为了保证销毁时逆序执行。
    </p>
    <pre><code class="language-java">// 源码参考：DefaultSingletonBeanRegistry
public void destroySingletons() {
    String[] singletonNames = this.registeredSingletons.toArray(new String);
    for (int i = singletonNames.length - 1; i &gt;= 0; i--) {
        destroySingleton(singletonNames[i]); // 逆序销毁
    }
}</code></pre>
    <h4 id="2%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96B" name="2%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96B">
     2：初始化B
    </h4>
    <p>
     A依赖于B，此时按照顺序从1、2、3级缓存查找，如果没有则进入B的创建流程（实例化并放入三级缓存中）
    </p>
    <p>
     之后进行属性注入，发现依赖于A，此时从1、2、3级缓存查找A，发现此时A在三级缓存。
    </p>
    <p>
     从三级缓存中获取A的早期对象，getSingleton("a")。
    </p>
    <pre><code class="language-java">// 源码位置：DefaultSingletonBeanRegistry#getSingleton()
public Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);  // ① 查一级缓存
    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);  // ② 查二级缓存
            if (singletonObject == null &amp;&amp; allowEarlyReference) {
                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);  // ③ 查三级缓存
                if (singletonFactory != null) {
                    // 命中三级缓存，触发后续操作...
                }
            }
        }
    }
    return singletonObject;
}</code></pre>
    <p>
     注意在这之后，还会调用 getEarlyBeanReference() 判断是否代理，确保代理对象的一致性。
    </p>
    <p>
     随后，将 A 的早期引用存入二级缓存，清空三级缓存。后续都从二级缓存获取A的引用。
    </p>
    <pre><code class="language-java">// 源码位置：DefaultSingletonBeanRegistry#getSingleton()
if (singletonFactory != null) {
    singletonObject = singletonFactory.getObject();  // 生成早期引用
    this.earlySingletonObjects.put(beanName, singletonObject);  // ⑤ 存入二级缓存
    this.singletonFactories.remove(beanName);         // ⑥ 清空三级缓存
}</code></pre>
    <p>
     最后，B 完成属性注入和初始化，并存入一级缓存。添加锁，避免出现后续A获取不到B的情况。
    </p>
    <pre><code class="language-java">// 源码位置：DefaultSingletonBeanRegistry#addSingleton()
protected void addSingleton(String beanName, Object singletonObject) {
    synchronized (this.singletonObjects) {
        this.singletonObjects.put(beanName, singletonObject);  // ⑦ 写入一级缓存
        this.singletonFactories.remove(beanName);  //清除该Bean三级缓存
        this.earlySingletonObjects.remove(beanName);  //清除该Bean二级缓存
        this.registeredSingletons.add(beanName);  //实例化Bean记录
    }
}</code></pre>
    <h4 id="3%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96A" name="3%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96A">
     3：初始化A
    </h4>
    <p>
     当 B 通过 addSingleton 完成初始化后，返回到 A 的 populateBean 方法继续执行。
    </p>
    <p>
     B已初始化成功并存入一级缓存，还需补充A的属性注入及初始化。（注意此时A的引用在二级缓存中，在上述B的属性注入过程中，从三级缓存提升）
    </p>
    <p>
     之后，A注入B，完成自身初始化。并存入一级缓存，清空二三级缓存。添加锁。
    </p>
    <pre><code class="language-java">// DefaultSingletonBeanRegistry#getSingleton
public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
    synchronized (this.singletonObjects) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            // 标记Bean正在创建（防止重复进入）
            beforeSingletonCreation(beanName);
            try {
                // 关键恢复点：B完成初始化后返回此处
                singletonObject = singletonFactory.getObject();
            }
            finally {
                afterSingletonCreation(beanName);
            }
            // 存入一级缓存
            addSingleton(beanName, singletonObject);
        }
        return singletonObject;
    }
}</code></pre>
    <p>
     至此，A和B都完成了初始化，且都存入一级缓存中。后续其他Bean注入AB也会直接查询获取。
    </p>
    <p>
     补充：构造器注入‌无法解决循环依赖（需使用Setter/字段注入），或添加@Lazy注解延迟加载。
    </p>
    <p>
     非单例Bean（如prototype）无法解决循环依赖。
    </p>
    <p>
     注意清空二级、三级缓存，都指的是清空当前Bean的实例，并非整个缓存数据。
    </p>
    <p>
     缓存操作的代码，获取实例，或缓存创建删除，全部都会加同步锁，避免不一致情况。
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%EF%BC%9ASpring%20MVC" name="%E4%BA%8C%EF%BC%9ASpring%20MVC">
     二：Spring MVC
    </h2>
    <p>
    </p>
    <h2 id="%E4%B8%89%EF%BC%9AMyBatis" name="%E4%B8%89%EF%BC%9AMyBatis">
     三：MyBatis
    </h2>
    <p>
     MyBatis是一个开源的，半自动的ORM持久层框架，主要用于简化数据库操作，将 Java 对象与数据库表中的记录进行映射。支持普通sql，关联查询，嵌套查询等。
    </p>
    <p>
     它的核心思想是让开发者通过更简单的方式操作数据库，同时保留对 SQL 语句的完全控制权，避免了传统 JDBC 代码的复杂性。
    </p>
    <h3 id="1%EF%BC%9A%23%E5%92%8C%24%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB" name="1%EF%BC%9A%23%E5%92%8C%24%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB">
     1：#和$符的区别
    </h3>
    <blockquote>
     <p>
      总：两者均为Mybatis框架的，用于动态 SQL 参数替换的实现。
     </p>
     <p>
      设计初衷：
     </p>
     <p>
      #{} 用于处理‌数据值‌（如字符串、数字）
     </p>
     <p>
      ${} 用于处理‌SQL 结构‌（如动态表名、列名、排序字段）
     </p>
    </blockquote>
    <p>
     #符是预编译占位符，在执行时，会将sql中的#{}替换为 ? 号，之后调用 PreparedStatement 的set方法进行赋值。可以有效防止sql注入。操作数据优先使用该方式。
    </p>
    <p>
     #是参数占位符，会替换为？号，并加双引号。
    </p>
    <p>
     它是在编译期替换为？号，变量的替换是在DBMS数据库中。
    </p>
    <p>
     适用场景：普通参数操作，如where id = #{id}
    </p>
    <hr/>
    <p>
     $符是字符串替换，在处理时，就只是把 $() 替换为变量的值，不防sql注入，语句不加双引号。
    </p>
    <p>
     sql语句变量的替换是在动态sql解析阶段。
    </p>
    <p>
     存在sql注入问题，在预编译之前变量可被替换。
    </p>
    <p>
     适用场景：动态表名、列名、排序字段（如 ORDER BY ${sortField}）
    </p>
    <pre><code class="language-java">&lt;!-- 高危操作：用户输入直接拼接 --&gt;
&lt;select id="login" resultType="User"&gt;
    SELECT * FROM user 
    WHERE username = '${username}' AND password = '${password}'
&lt;/select&gt;
&lt;!-- 若 username = "admin' --"，会绕过密码验证！ --&gt;
</code></pre>
    <p>
    </p>
    <h2 id="%E5%9B%9B%EF%BC%9ASpringBoot" name="%E5%9B%9B%EF%BC%9ASpringBoot">
     四：SpringBoot
    </h2>
    <p>
     SpringBoot的原则是：约定大于配置
    </p>
    <p>
     Spring框架需要大量的配置，而SpringBoot引入自动配置的概念，使项目搭建运行更容易快捷。SpringBoot本身并不提供Spring框架的核心特性及扩展功能，只是用于快速，敏捷的开发新一代基于Spring框架的应用程序。
    </p>
    <p>
     对使用者来说，项目初始化方式变了，配置文件变了，以及不需要单独安装tomcat这类服务器了，使用maven或gradle项目管理工具，打出jar包即可快速运行。但核心的业务逻辑和业务流程实现没有变化。
    </p>
    <p>
    </p>
    <p>
     持续整理中
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6e5f416c6f6e65542f:61727469636c652f64657461696c732f313436313434383436" class_="artid" style="display:none">
 </p>
</div>


