---
layout: post
title: "手写简易Tomcat核心实现深入理解Servlet容器原理"
date: 2025-03-08 21:39:08 +0800
description: "通过实现这个简易Tomcat，我们深入理解了：Servlet容器的启动流程请求-响应生命周期管理注解驱动与反射的应用HTTP协议的基础解析。"
keywords: "手写简易Tomcat核心实现：深入理解Servlet容器原理"
categories: ['未分类']
tags: ['Tomcat', 'Servlet', 'Java']
artid: "146123304"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123304
    alt: "手写简易Tomcat核心实现深入理解Servlet容器原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123304
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123304
cover: https://bing.ee123.net/img/rand?artid=146123304
image: https://bing.ee123.net/img/rand?artid=146123304
img: https://bing.ee123.net/img/rand?artid=146123304
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     手写简易Tomcat核心实现：深入理解Servlet容器原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     本文将基于Java实现一个极简版Tomcat，通过代码逐层剖析Servlet容器的工作原理。读者将掌握HTTP协议解析、注解驱动开发、反射机制、类加载等核心技术。
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88" name="%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88">
     一、Tomcat概况
    </h2>
    <h3 id="1.%20tomcat%E5%85%A8%E5%B1%80%E5%9B%BE" name="1.%20tomcat%E5%85%A8%E5%B1%80%E5%9B%BE">
     1. tomcat全局图
    </h3>
    <p>
     <img alt="" height="588" src="https://i-blog.csdnimg.cn/direct/69244e26be7f452b94c94efe9b35a456.png" width="1487"/>
    </p>
    <h3 id="2.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88" name="2.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88">
     2.项目结构概览
    </h3>
    <pre><code>src
├── com.qcby
│   ├── MyTomcat.java          // 服务启动类
│   └── ServletConfigMapping.java // Servlet配置映射
├── com.qcby.util
│   ├── ResponseUtil.java      // HTTP响应工具
│   ├── SearchClassUtil.java   // 类扫描工具
│   └── WebServlet.java        // 自定义注解
└── com.qcby.webapps
    ├── myweb                  // 示例Servlet
    └── servlet                // Servlet核心实现</code></pre>
    <h2 id="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3" name="%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3">
     二、实现步骤详解
    </h2>
    <h3 id="2.1%20%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%8C%85%EF%BC%88com.qcby.util%EF%BC%89" name="2.1%20%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%8C%85%EF%BC%88com.qcby.util%EF%BC%89">
     <strong>
      2.1 基础工具包（com.qcby.util）
     </strong>
    </h3>
    <h4 id="2.1.1%20ResponseUtil%EF%BC%9AHTTP%E5%93%8D%E5%BA%94%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7" name="2.1.1%20ResponseUtil%EF%BC%9AHTTP%E5%93%8D%E5%BA%94%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7">
     2.1.1 ResponseUtil：HTTP响应生成工具
    </h4>
    <pre><code class="language-java">package com.qcby.util;

public class ResponseUtil {
    // 200响应头模板
    public static final String responseHeader200 = 
        "HTTP/1.1 200 \r\nContent-Type:text/html; charset=utf-8 \r\n\r\n";
    
    // 生成404响应
    public static String getResponseHeader404(){
        return "HTTP/1.1 404 \r\nContent-Type:text/html; charset=utf-8 \r\n\r\n404";
    }
    
    // 生成带内容的200响应
    public static String getResponseHeader200(String context){
        return responseHeader200 + context;
    }
}</code></pre>
    <p>
     <strong>
      核心作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       标准化HTTP响应格式
      </p>
     </li>
     <li>
      <p>
       提供快速构建响应的静态方法
      </p>
     </li>
     <li>
      <p>
       支持200/404状态码生成
      </p>
     </li>
    </ul>
    <h4 id="2.1.2%C2%A0SearchClassUtil%EF%BC%9A%E7%B1%BB%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7" name="2.1.2%C2%A0SearchClassUtil%EF%BC%9A%E7%B1%BB%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7">
     2.1.2
     <strong>
      SearchClassUtil：类扫描工具
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.util;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**'
 * 扫描com.qcby.webapps目录下面的文件，获取每一个Java文件的全类名
 */
public class SearchClassUtil {
    public static List&lt;String&gt; classPaths = new ArrayList&lt;String&gt;();

    public static List&lt;String&gt; searchClass(){
        //需要扫描的包名
        String basePack = "com.qcby.webapps.myweb";
        //将获取到的包名转换为路径
        String classPath = SearchClassUtil.class.getResource("/").getPath();
        basePack =  basePack.replace(".", File.separator);
        String searchPath = classPath + basePack;
        doPath(new File(searchPath),classPath);
        //这个时候我们已经得到了指定包下所有的类的绝对路径了。我们现在利用这些绝对路径和java的反射机制得到他们的类对象
        return classPaths;
    }

    /**
     * 该方法会得到所有的类，将类的绝对路径写入到classPaths中
     * @param file
     */
    private static void doPath(File file,String classpath) {
        if (file.isDirectory()) {//文件夹
            //文件夹我们就递归
            File[] files = file.listFiles();
            for (File f1 : files) {
                doPath(f1,classpath);
            }
        } else {//标准文件
            //标准文件我们就判断是否是class文件
            if (file.getName().endsWith(".class")) {
                String path = file.getPath().replace(classpath.replace("/","\\").
                                replaceFirst("\\\\",""),"").replace("\\",".").
                        replace(".class","");
                //如果是class文件我们就放入我们的集合中。
                classPaths.add(path);
            }
        }
    }

    public static void main(String[] args) {
        List&lt;String&gt; classes = SearchClassUtil.searchClass();
        for (String s: classes) {
            System.out.println(s);
        }
    }
}

</code></pre>
    <p>
     <strong>
      核心作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       递归扫描指定包路径
      </p>
     </li>
     <li>
      <p>
       转换.class文件为全限定类名
      </p>
     </li>
     <li>
      <p>
       支持动态类加载的基础
      </p>
     </li>
    </ul>
    <h4 id="2.1.3%C2%A0WebServlet%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3" name="2.1.3%C2%A0WebServlet%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">
     2.1.3
     <strong>
      WebServlet：自定义注解
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.util;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Retention(RetentionPolicy.RUNTIME)//源文件阶段保留
@Target(ElementType.TYPE)//表明@WebSerlet注解是写在类上
public @interface WebServlet {

    //String path=null;
    String urlMapping() default "" ;
}
</code></pre>
    <p>
     <strong>
      核心作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       替代XML配置的注解式声明
      </p>
     </li>
     <li>
      <p>
       建立Servlet与URL的映射关系
      </p>
     </li>
     <li>
      <p>
       运行时（
       <code>
        RUNTIME
       </code>
       ）保留策略支持反射读取可读取注解信息
      </p>
     </li>
    </ul>
    <h3 id="2.2%20Servlet%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%8C%85%EF%BC%88com.qcby.webapps.servlet%EF%BC%89" name="2.2%20Servlet%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%8C%85%EF%BC%88com.qcby.webapps.servlet%EF%BC%89">
     2.2 Servlet核心实现包（com.qcby.webapps.servlet）
    </h3>
    <h4 id="2.2.1%C2%A0HttpServletRequest%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1" name="2.2.1%C2%A0HttpServletRequest%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1">
     2.2.1
     <strong>
      HttpServletRequest：请求对象
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.webapps.servlet.req;

public class HttpServletRequest {
    private String path;
    private String method;


    public String getPath(){return path;
    }

    public void setPath(String path){this.path=path;}
    public String getMethod(){return method;}
    public void setMethod(String method){this.method=method;}
}
</code></pre>
    <ul>
     <li>
      <p>
       职责分离：请求封装客户端数据，响应处理输出流
      </p>
     </li>
    </ul>
    <h4 id="2.2.2%C2%A0HttpServletResponse%EF%BC%9A%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1" name="2.2.2%C2%A0HttpServletResponse%EF%BC%9A%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1">
     2.2.2
     <strong>
      HttpServletResponse：响应对象
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.webapps.servlet.req;

import java.io.IOException;
import java.io.OutputStream;

public class HttpServletResponse {
    private OutputStream outputStream;
    public HttpServletResponse(OutputStream outputStream ){
        this.outputStream=outputStream;
    }
    public void writeServlet(String context) throws IOException{
        outputStream.write(context.getBytes());
    }

}
</code></pre>
    <h4 id="2.2.3%C2%A0Servlet%E6%8E%A5%E5%8F%A3" name="2.2.3%C2%A0Servlet%E6%8E%A5%E5%8F%A3">
     2.2.3
     <strong>
      Servlet接口
     </strong>
    </h4>
    <p class="img-center">
     <img alt="" height="500" src="https://i-blog.csdnimg.cn/direct/00636a16e1874edd9b6f24c64cb99039.png" width="743"/>
    </p>
    <pre><code class="language-java">package com.qcby.webapps.servlet;

import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;

public interface Servlet&lt;response&gt; {
    public void init();
    public void service(HttpServletRequest request, HttpServletResponse response) throws IOException;
    public void destroy();

}
</code></pre>
    <h4 id="2.2.4%C2%A0GenericServlet%E6%8A%BD%E8%B1%A1%E7%B1%BB" name="2.2.4%C2%A0GenericServlet%E6%8A%BD%E8%B1%A1%E7%B1%BB">
     <strong>
      2.2.4 GenericServlet抽象类
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.webapps.servlet;


public abstract  class GenericServlet implements  Servlet {
    public void init(){
        System.out.println("------初始化servlet------");
    }
    public void destroy(){
        System.out.println("------实现servlet对象的销毁------");
    }

}
</code></pre>
    <h4 id="2.2.5%C2%A0HttpServlet%E5%AE%9E%E7%8E%B0%E7%B1%BB" name="2.2.5%C2%A0HttpServlet%E5%AE%9E%E7%8E%B0%E7%B1%BB">
     2.2.5
     <strong>
      HttpServlet实现类
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.webapps.servlet;

import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;

public  abstract  class HttpServlet extends GenericServlet{

    public void service(HttpServletRequest request, HttpServletResponse response) throws IOException {

        if(request.getMethod().equals("GET")){
            doGet(request,response);
        }
        else{
            doPost(request,response);
        }
    }
    protected  abstract  void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException;


    protected  abstract  void doPost(HttpServletRequest request,HttpServletResponse response) throws IOException;

}
</code></pre>
    <ul>
     <li>
      <p>
       设计模式：模板方法模式处理HTTP方法分发
      </p>
     </li>
     <li>
      <p>
       继承体系：
       <code>
        HttpServlet -&gt; GenericServlet -&gt; Servlet
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      核心作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       构建完整的Servlet生命周期
      </p>
     </li>
     <li>
      <p>
       实现HTTP方法的分发机制
      </p>
     </li>
     <li>
      <p>
       提供请求响应的标准接口
      </p>
     </li>
    </ul>
    <h3 id="2.3%20%E4%B8%9A%E5%8A%A1Servlet%E5%AE%9E%E7%8E%B0%EF%BC%88com.qcby.webapps.myweb%EF%BC%89" name="2.3%20%E4%B8%9A%E5%8A%A1Servlet%E5%AE%9E%E7%8E%B0%EF%BC%88com.qcby.webapps.myweb%EF%BC%89">
     2.3 业务Servlet实现（com.qcby.webapps.myweb）
    </h3>
    <h4 id="2.3.1%20LoginServlet" name="2.3.1%20LoginServlet">
     2.3.1 LoginServlet
    </h4>
    <pre><code class="language-java">package com.qcby.webapps.myweb;

import com.qcby.util.ResponseUtil;
import com.qcby.util.WebServlet;
import com.qcby.webapps.servlet.HttpServlet;
import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;
@WebServlet(urlMapping = "/login")
public class LoginServlet  extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        System.out.println("我是login的doGet方法");
        response.writeServlet(ResponseUtil.getResponseHeader200("hello"));
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {

    }
}
</code></pre>
    <h4 id="2.3.2%C2%A0ShowServlet" name="2.3.2%C2%A0ShowServlet">
     2.3.2
     <strong>
      ShowServlet
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby.webapps.myweb;

import com.qcby.util.ResponseUtil;
import com.qcby.util.WebServlet;

import com.qcby.webapps.servlet.HttpServlet;
import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;


@WebServlet(urlMapping="/show")
public class ShowServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        // GET请求处理逻辑
        System.out.println("我是show");
        response.writeServlet(ResponseUtil.getResponseHeader200("show"));
    }


    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        // POST请求处理逻辑
    }
}</code></pre>
    <p>
     <strong>
      核心作用
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       演示具体业务实现
      </p>
     </li>
     <li>
      <p>
       展示注解驱动的路由配置
      </p>
     </li>
     <li>
      <p>
       体现模板方法模式的应用
      </p>
     </li>
    </ul>
    <h3 id="2.4%C2%A0%E6%A0%B8%E5%BF%83%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%EF%BC%88com.qcby%EF%BC%89" name="2.4%C2%A0%E6%A0%B8%E5%BF%83%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%EF%BC%88com.qcby%EF%BC%89">
     2.4 核心控制模块（com.qcby）
    </h3>
    <h4 id="2.4.1%20ServletConfigMapping%EF%BC%9AServlet%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83" name="2.4.1%20ServletConfigMapping%EF%BC%9AServlet%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83">
     <strong>
      2.4.1 ServletConfigMapping：Servlet配置中心
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby;

import com.qcby.util.SearchClassUtil;
import com.qcby.util.WebServlet;
import com.qcby.webapps.servlet.HttpServlet;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ServletConfigMapping {

    public static Map&lt;String, HttpServlet&gt; servletMap =new HashMap&lt;&gt;();
    static{
        List&lt;String&gt; classNames = SearchClassUtil.searchClass();
        for (String path:classNames){
            try{
                Class clazz =Class.forName(path);
                WebServlet webServlet =(WebServlet) clazz.getDeclaredAnnotation(WebServlet.class);
                HttpServlet servlet =(HttpServlet) clazz.newInstance();
                servletMap.put(webServlet.urlMapping(), servlet);
                System.out.println(servletMap);

            }catch (Exception e){
                e.printStackTrace();
            }
        }
    }

}
</code></pre>
    <p>
     <strong>
      核心流程
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       静态初始化块在类加载时执行
      </p>
     </li>
     <li>
      <p>
       使用SearchClassUtil扫描所有类
      </p>
     </li>
     <li>
      <p>
       通过反射获取注解信息
      </p>
     </li>
     <li>
      <p>
       实例化Servlet并建立URL映射
      </p>
     </li>
    </ol>
    <h4 id="2.4.2%20MyTomcat%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E5%8F%A3" name="2.4.2%20MyTomcat%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E5%8F%A3">
     <strong>
      2.4.2 MyTomcat：服务器入口
     </strong>
    </h4>
    <pre><code class="language-java">package com.qcby;

import com.qcby.webapps.servlet.HttpServlet;
import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

import static com.qcby.ServletConfigMapping.servletMap;

public class MyTomcat {
    static HttpServletRequest request =new HttpServletRequest();

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket =new ServerSocket(8081);
        while (true){
            Socket socket =serverSocket.accept();
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream =socket.getOutputStream();
            HttpServletResponse response= new HttpServletResponse(outputStream);

            int count = 0;
            while (count == 0){
                count = inputStream.available();
        }

            byte[] bytes = new byte[count];
            inputStream.read(bytes);
            String Context = new String(bytes);
            System.out.println(Context);

            //解析数据
            if(Context.equals("")){
                System.out.println("你输入了一个空请求");
            }else {
                String firstLine = Context.split("\\n")[0]; //根据换行来获取第一行数据
                request.setPath(firstLine.split("\\s")[1]);
                request.setMethod(firstLine.split("\\s")[0]);
            }



            if(servletMap.containsKey(request.getPath())){
                System.out.println("存在于HashMap中");
                HttpServlet servlet=ServletConfigMapping.servletMap.get(request.getPath());
                servlet.service(request,response);
            } else {
                System.out.println("不存在于HashMap中");
            }



        }

}}
</code></pre>
    <p>
     <strong>
      核心流程
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       创建ServerSocket监听8081端口
      </p>
     </li>
     <li>
      <p>
       循环接受客户端连接
      </p>
     </li>
     <li>
      <p>
       解析HTTP请求首行
      </p>
     </li>
     <li>
      <p>
       根据路径查找对应的Servlet
      </p>
     </li>
     <li>
      <p>
       调用service方法处理请求
      </p>
     </li>
     <li>
      <p>
       返回404响应处理异常路径
      </p>
     </li>
    </ol>
    <h3 id="2.5%20%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%85%A8%E6%99%AF%E5%9B%BE" name="2.5%20%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%85%A8%E6%99%AF%E5%9B%BE">
     2.5 运行流程全景图
    </h3>
    <pre><code class="language-java">启动流程：
1. MyTomcat.main()启动
2. ServletConfigMapping静态块初始化
   → SearchClassUtil扫描类
   → 反射创建Servlet实例
   → 建立URL映射表

请求处理流程：
客户端请求 → ServerSocket接收 → 解析请求路径 → 
查找Servlet映射 → 调用service() → 执行doGet/doPost → 
生成响应 → 返回客户端</code></pre>
    <h3 id="2.6%20%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3" name="2.6%20%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">
     2.6 关键设计思想
    </h3>
    <h4 id="2.6.1%20%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%9A" name="2.6.1%20%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%9A">
     <strong>
      2.6.1 控制反转
     </strong>
     ：
    </h4>
    <ul>
     <li>
      Servlet实例由容器创建
     </li>
     <li>
      开发者通过注解声明路由
     </li>
    </ul>
    <h4 id="2.6.2%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9A" name="2.6.2%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9A">
     <strong>
      2.6.2 反射机制
     </strong>
     ：
    </h4>
    <ul>
     <li>
      动态加载类文件
     </li>
     <li>
      读取注解配置信息
     </li>
    </ul>
    <h4 id="2.6.3%20%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9A" name="2.6.3%20%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9A">
     <strong>
      2.6.3 模板方法模式
     </strong>
     ：
    </h4>
    <ul>
     <li>
      HttpServlet定义处理骨架
     </li>
     <li>
      子类实现具体业务逻辑
     </li>
    </ul>
    <h4 id="2.6.4%20%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BB%EF%BC%9A" name="2.6.4%20%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BB%EF%BC%9A">
     <strong>
      2.6.4 职责分离
     </strong>
     ：
    </h4>
    <ul>
     <li>
      Request/Response对象封装协议细节
     </li>
     <li>
      Util类处理通用逻辑
     </li>
    </ul>
    <h2 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" name="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">
     三、总结
    </h2>
    <p>
     通过实现这个简易Tomcat，我们深入理解了：
    </p>
    <ol>
     <li>
      <p>
       Servlet容器的启动流程
      </p>
     </li>
     <li>
      <p>
       请求-响应生命周期管理
      </p>
     </li>
     <li>
      <p>
       注解驱动与反射的应用
      </p>
     </li>
     <li>
      <p>
       HTTP协议的基础解析
      </p>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313039363130312f:61727469636c652f64657461696c732f313436313233333034" class_="artid" style="display:none">
 </p>
</div>


