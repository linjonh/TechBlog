---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38323931313736382f:61727469636c652f64657461696c732f313436323635393031"
layout: post
title: "1操作系统引论"
date: 2025-03-15 19:06:10 +08:00
description: "操作系统学习引论，这部分是以硬件为主，下一个是软件为主。这些讲完才是正式的知识点。但不代表这部分知识点不重要。操作系统一周最多3篇内容，至少1篇内容。"
keywords: "1、操作系统引论"
categories: ['操作系统']
tags: ['考研', '程序人生', '嵌入式硬件', 'Servlet', 'Microsoft', 'Java', 'C']
artid: "146265901"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146265901
    alt: "1操作系统引论"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146265901
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146265901
cover: https://bing.ee123.net/img/rand?artid=146265901
image: https://bing.ee123.net/img/rand?artid=146265901
img: https://bing.ee123.net/img/rand?artid=146265901
---

# 1、操作系统引论

## 一、操作系统

> 会使用linux系统
>   
> 建议大家先学会linux的基础指令，
> [可以看菜鸟教程网站](https://www.runoob.com/linux/linux-tutorial.html)
> 进行学习。

### 1、各种定义

* 操作系统定义
  + 管理计算机的
    **硬件**
    和
    **软件**
    资源， 能对各类作业进行
    **调度**
    ，方便用户使用计算机的
    **程序集合**
    。
  + 操作系统运行在
    **内核态（也叫管态，核心态）**
    。在这个状态，操作系统可以对所有的硬件访问。

> **注意**
> ：操作系统是最基础的
> **软件**
> 。

* 用户接口程序定义
  + 用户接口程序有
    `shell和GUI`
    - shell：用户与操作系统交互的程序，基于
      **文本**
      的是shell。
    - GUI：用户与操作系统交互的程序，基于
      **图标**
      的是GUI。

> **注意**
> ：用户接口程序并不属于操作系统。

* 信息
  + 位（bit）+ 上下文（context）= 信息
    - 位（Bit） 是计算机中最小的数据单位，表示一个二进制的
      **0 或 1**
      。
    - 上下文 是数据所处的环境或规则，决定了
      **如何解释这些位**
      。
  + ASCII码构成的文件就是文本文件
  + 其余是二进制文件
* 内核态和用户态
  + 内核态：
    - 操作系统的“核心大脑”，权限高但需谨慎操作。
  + 用户态：
    - 普通程序的“沙箱”，权限受限但
      **安全**
      。
      * 所以操作系统会把
        **一部分代码**
        放在
        **内核态**
        ，
        **另一部分**
        放在
        **用户态**
        来
        **保证安全**
        。
* 程序接口
  + 普通用户无法直接使用程序接口，而是使用
    `系统调用`
    来用程序接口。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0098a37e975a46eb8637315683cb6928.png)

### 2、程序被其他程序翻译成不同格式

在linux的gcc编译器下。我们有一些对文件的操作。
**操作系统和编译器是辅助关系**
。

> 这些操作是【巧妙记忆：ESc iso】
>   
> ①预处理阶段：
>
> * 使用
>   `gcc -E xxx.c -o xxx.i`
>   命令
> * **作用**
>   ：处理 #include、#define、#ifdef 等预处理指令。
>
> ②编译阶段：
>
> * 使用
>   `gcc -S xxx.i -o xxx.s`
>   命令
> * **作用**
>   ：将预处理后的代码转换为汇编代码。
>
> ③汇编阶段：
>
> * 使用
>   `gcc -c xxx.s -o xxx.o`
>   命令
> * **作用**
>   ：将汇编代码转换为机器码（二进制目标文件）。
>
> ④链接阶段：
>
> * 使用
>   `gcc xxx.o -o xxxx`
>   命令
> * **作用**
>   ：将目标文件与库文件（如 libc.so）链接，生成可执行文件。

如果我们使用
`world.c`
文件进行以上操作。那这4个阶段将构成编译系统（compilation system）。那么命令的执行过程如下图：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b24b729cc9d744e0a5521a47311c4c4c.png)

### 3、面临的问题

当一个代码输入到操作系统上，我们的硬盘【不同的用户，硬盘的来源是不同的，材质会不同等等】该如何读取呢？等等。
  
所以我们就需要用到操作系统的4个重大部分，也是未来学习的过程中重点知识。

* **运行任务的管理**
  ：进程和线程、调度和同步机制
* **运行任务的存储管理**
  ：内存管理
* **运行任务的外设管理**
  ：I/O设备
* **存储数据设备的管理**
  ：文件管理

## 二、硬件

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5626924966f541ffbc6d813cf6481385.png)
  
上面这张就是一个硬件分布图【看看就行了，不要死记硬背】。

### 1、CPU

中央处理单元（CPU），简称
**处理器**
。

* **CPU作用**
  ：处理和执行指令。
* **CPU的寄存器**
  ：存储下一条要执行的指令。
  + 通用寄存器
  + **程序计数器**
    （
    **PC**
    ）
    - 作用：存储下一条要执行的指令的
      **内存地址**
      。
  + **堆栈指针**
    （
    **SP**
    ）
    - 作用：
      **指向当前堆栈的顶部地址**
      ，管理函数调用时的栈操作。
      **能保护信息和恢复信息**
      。
  + **指令寄存器（IR）**
    - 作用：存放
      **当前执行指令**
      。
  + **状态寄存器（FLAGS）**
    - 作用：记录
      **运算结果状态**
      （如零标志ZF、进位标志CF）。
    - PSW：并不是一直需要保存，而是运行状态才需要。在记录状态【已经没有运行了】不用。
* **CPU的算术逻辑单元ALU**
  + 作用：执行算术和逻辑运算。
* **指令集架构**
  + 处理器想要处理一条指令，也需要通过一定的规则，这个规则就是指令集架构。
  + 指令类型如下：
    - 加载指令：用于将
      **数据从内存加载到寄存器**
      中。
    - 存储指令：用于将
      **数据从寄存器存回到内存**
      中。
    - 运算指令：用于对
      **来自寄存器和内存的操作数进行运算**
      ，例如 add 指令将两个操作数相加并将结果保存在寄存器或内存中。
* **CPU的流水线**
  + 当CPU正在
    **执行**
    第N条指令时，它可以同时
    **解码**
    第N+1条指令，并
    **读取**
    第N+2条指令，这种形式就叫
    `流水线`
    。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/21fb07b7b0434b789f89e27f7c4f4740.png)
* **CPU的超标量**
  + **CPU中可以有多个执行单元，例如一个做加法运算，一个做乘法运算。在它们做运算的时候，把许多取指单元和解码单元放入缓存区（cache）中，等到某一个执行单元有空了，就把缓存区中的它们拿一个出来执行**
    。虽然看起来指令乱序了，实际上工作人员肯定设计方法来有序进行。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/13eeeb3fa8a84154a16c29829d310805.png)

### 2、内存

**理想情况**
下，内存应该是非常快速的（比执行一条指令还要快，以避免拖慢CPU的执行效率），同时容量足够大且成本低廉。然而，当前的技术手段无法同时满足这三个要求。因此，
**存储系统采用了一种分层次的结构来解决这个问题**
。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0e5b2c5e66a549968a94f86f19d3905a.png)

#### 2.1、 **寄存器**

* 寄存器与CPU同样的材质，跟CPU一样快

#### 2.2、 **高速缓存（Cache）**

* 位于CPU与主存（内存）之间的超高速临时存储器，由SRAM构成，用于
  **减少CPU访问数据的延迟**
  。
* **局部性原理**
  ：
  + 是指：CPU访问存储器的时候，无论是读指令还是存取数据，所访问的存储单元都被区域聚集到一个连续区域中了。也就是说
    **程序具有访问局部区域里的数据和代码的趋势**
    。

#### 2.3、 **主存**

* 主存是指计算机中用
  **于临时存储正在运行的程序和数据的硬件部件**
  ，属于
  **RAM（随机存取存储器）**
  。断电后数据丢失（易失性）。
* **ROM**
  （
  **只读存储器**
  ） 断电后不数据丢失，一旦ROM存储了数据，那么数据就不能被修改了。
* EEPROM（电可擦可编程只读存储器）和 闪存（Flash Memory）与ROM不同，
  **支持数据的擦除和重新写入**
  【
  **重写数据来修正程序错误**
  】。
* CMOS（Complementary Metal-Oxide Semiconductor，互补金属氧化物半导体） 存储器
  + 作用：
    **存储**
    BIOS/UEFI设置（如启动顺序、日期时间、硬件参数）。
    **确保即使在电源关闭后也能持续追踪这些关键数据**
    。
  + 特性：易失性存储器，依赖\*\*纽扣电池（CR2032）\*\*维持数据（
    **断电后不丢失**
    ）。

#### 2.4、磁盘

> 在
> **市面上的磁盘有2类**
> ，我们先看
> **机械磁盘**
> ，然后看
> **固态磁盘**
> 。
>   
> [推荐观看这个视频，用的《CSAPP》书讲解](https://www.bilibili.com/video/BV1J44y1C7RR/?spm_id_from=333.337.search-card.all.click&vd_source=c6d25b8c148a15b1c45b8da5d613a042)

##### 2.4.1、机械磁盘（HDD）

###### 主体结构介绍

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c8060a186aac4239acef4ba4699e7953.png)

* 盘片（platter）：上图中的圆盘就是盘片。上面有磁性的记录材料，可以
  **记录数据**
  。
  + 盘面（surface）：每个盘片有2个面 ，这个面就是盘面。
* 主轴（spindle）：可以旋转。主轴带动盘片以固定的速率高速旋转。
* 读/写头：来读写盘面表面存储的数据。上下盘面都有一个读/写头.
  + **所有的读写头都是一起运动的，垂直并列**
    。
* 磁盘臂：通过磁盘臂的运动就可以运行读写数据的行为了。如果需要读取目标文件，盘面就会旋转起来。
  + 寻找位置的这个过程【不包括旋转】叫
    **寻道**
    。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dce4c36866554f808121b088d8983973.png)

###### 细节分析

> 先是磁道

* 磁道：盘面的表面划分了一圈圈的磁道
  + 扇区：磁道里面有许多扇区。
    - 扇区与扇区之间有一些
      **小间隙**
      ，
      **存储的不是 数据 而是 标识信息**
      。
        
      ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/300e45ca3e3c4767879c27f6588044ce.png)

> 然后单位

* byte是字节单位，不要理解成比特bit了。
* 在I/O设备里的单位是不同的。如下图
    
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5a9db14b6ad94794a6f125c4ba44af93.png)
    
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0673004997bd405f9e06b43c297239cf.png)

> 然后对扇区的访问时间主要分布为3个部分

扇区访问时间 = 寻道时间+旋转时间+传送时间

* 寻道时间：磁盘臂寻道过程的时间。
* 旋转时间：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间
* 传送时间：完成传输所请求的数据所需要的时间。

> 单位

* 扇区： 硬盘的最小读写单元
* 块/簇： 是操作系统针对硬盘读写的最小单元
* page： 是内存与操作系统之间操作的最小单元。

##### 2.4.2、固态硬盘（SSD）

在现在的电脑几乎都是固态硬盘了。固态硬盘的缺陷就是容易磨损。
[推荐看这个视频了解](https://www.bilibili.com/video/BV1Fg411V7LN?spm_id_from=333.788.player.switch&vd_source=c6d25b8c148a15b1c45b8da5d613a042)
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2014858690da4a4c8bb7e8856d5c32c3.png)

* 固态硬盘由一个或多个
  `闪存芯片`
  构成的。
  + 使用闪存芯片 取代了 传统的机械臂转动和盘片旋转方式。
* 闪存转换站（FTL）
  + 功能与磁盘控制器类似：都是将
    **操作系统对逻辑块的请求**
    翻译成
    **对底层物理设备的访问**
    。
* **固态硬盘的擦除操作**
  + 固态硬盘除了读/写操作，还多了擦除操作。
  + 但是擦除
    **只能把1 变成 0 ，而不能把0 变成1**
    。 所以每一个page在放入数据前都是 1 。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3962296a36e7485392c53074b2b2573a.png)

### 3、I/O设备

#### 3.1、定义

I/O设备就是可以
**将数据输入到计算机**
或者
**可以接收计算机输出数据的外部设备**
， 属于计算机的
**硬件**
部分。

#### 3.2、分类

##### 3.2.1、按使用特性分类

* **人机交互类 外部设备**
  ：数据传输慢---->用于人机交互
* **存储设备**
  ：数据传输快---->用于数据存储
* **网络通信设备**
  ：数据传输介于2者之间---->用于网络通信

##### 3.2.2、按传输速率分类

* **低速设备**
  ：每秒几个到几百字节
* **中速设备**
  ：每秒千到万字节
* **高速设备**
  ：每秒可以到千兆字节

##### 3.2.3、按信息交换的单位

* **块设备**
  ：传输速率较高，可寻址，即对它可随机地读/写任一块。
* **字符设备**
  ：传输速率较慢，不可寻址。在输入/输出时，常采用中断驱动方式。

### 4、设备控制器和设备驱动器

**设备控制器【硬件】**
：负责
**直接控制物理设备**
，
**能够接收并执行来自操作系统的指令**
。
  
**设备驱动器【软件】**
：设备控制器
**通过设备驱动器利用中断与操作系统通信**
。

### 5、实现输入和输出的方式有三种

* **忙等待**
  ：一直循环直到需要的条件满足。会一直占据CPU，CPU一直轮询I/O设备直到I/O操作完成。
* **设备驱动程序启动设备并且让该设备在操作完成时发生中断**
  ，设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备操作完成时，它发出一个
  **中断**
  通知操作完成。
  + ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dc0a1ac1c2e64003b08dcd21b5ef0a1c.png)
* **引入DMA控制器**
  ，代替CPU直接管理I/O设备与内存之间的数据传输。【直接存储器访问(Direct Memory Access, DMA) 芯片】