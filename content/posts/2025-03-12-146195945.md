---
layout: post
title: "聊聊langchain4j的AiServicesAutoConfig"
date: 2025-03-12 09:15:00 +0800
description: "本文主要研究一下langchain4j-spring-boot-starter的AiServicesAutoConfig。"
keywords: "聊聊langchain4j的AiServicesAutoConfig"
categories: ['未分类']
tags: ['人工智能']
artid: "146195945"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146195945
    alt: "聊聊langchain4j的AiServicesAutoConfig"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146195945
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146195945
cover: https://bing.ee123.net/img/rand?artid=146195945
image: https://bing.ee123.net/img/rand?artid=146195945
img: https://bing.ee123.net/img/rand?artid=146195945
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     聊聊langchain4j的AiServicesAutoConfig
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     序
    </h2>
    <p>
     本文主要研究一下langchain4j-spring-boot-starter的AiServicesAutoConfig
    </p>
    <h2>
     <a id="LangChain4jAutoConfig_3">
     </a>
     LangChain4jAutoConfig
    </h2>
    <p>
     dev/langchain4j/spring/LangChain4jAutoConfig.java
    </p>
    <pre><code>@AutoConfiguration
@Import({
        AiServicesAutoConfig.class,
        RagAutoConfig.class,
        AiServiceScannerProcessor.class
})
public class LangChain4jAutoConfig {
}
</code></pre>
    <blockquote>
     <p>
      LangChain4jAutoConfig自动import了AiServicesAutoConfig、RagAutoConfig、AiServiceScannerProcessor
     </p>
    </blockquote>
    <h2>
     <a id="AiServiceScannerProcessor_17">
     </a>
     AiServiceScannerProcessor
    </h2>
    <p>
     dev/langchain4j/service/spring/AiServiceScannerProcessor.java
    </p>
    <pre><code>@Component
public class AiServiceScannerProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {

    private Environment environment;

    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        ClassPathAiServiceScanner scanner = new ClassPathAiServiceScanner(registry, false);
        Set&lt;String&gt; basePackages = getBasePackages((ConfigurableListableBeanFactory) registry);
        scanner.scan(StringUtils.toStringArray(basePackages));

        removeAiServicesWithInactiveProfiles(registry);
    }

    private Set&lt;String&gt; getBasePackages(ConfigurableListableBeanFactory beanFactory) {
        Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();

        // AutoConfiguration
        List&lt;String&gt; autoConfigPackages = AutoConfigurationPackages.get(beanFactory);
        basePackages.addAll(autoConfigPackages);

        // ComponentScan
        addComponentScanPackages(beanFactory, basePackages);

        return basePackages;
    }

    private void addComponentScanPackages(ConfigurableListableBeanFactory beanFactory, Set&lt;String&gt; collectedBasePackages) {
        for (String beanName : beanFactory.getBeanNamesForAnnotation(ComponentScan.class)) {
            Class&lt;?&gt; beanClass = beanFactory.getType(beanName);
            if (beanClass != null) {
                Set&lt;ComponentScan&gt; componentScans = AnnotatedElementUtils.getMergedRepeatableAnnotations(beanClass, ComponentScan.class);
                for (ComponentScan componentScan : componentScans) {
                    Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();
                    for (String pkg : componentScan.basePackages()) {
                        String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
                                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
                        Collections.addAll(basePackages, tokenized);
                    }
                    for (Class&lt;?&gt; clazz : componentScan.basePackageClasses()) {
                        basePackages.add(ClassUtils.getPackageName(clazz));
                    }
                    if (basePackages.isEmpty()) {
                        basePackages.add(ClassUtils.getPackageName(beanClass));
                    }
                    collectedBasePackages.addAll(basePackages);
                }
            }
        }
    }

    private void removeAiServicesWithInactiveProfiles(BeanDefinitionRegistry registry) {
        Arrays.stream(registry.getBeanDefinitionNames())
                .filter(beanName -&gt; {
                    try {
                        BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);
                        if (beanDefinition.getBeanClassName() != null) {
                            Class&lt;?&gt; beanClass = Class.forName(beanDefinition.getBeanClassName());
                            if (beanClass.isAnnotationPresent(AiService.class)
                                    &amp;&amp; beanClass.isAnnotationPresent(Profile.class)) {
                                Profile profileAnnotation = beanClass.getAnnotation(Profile.class);
                                String[] profiles = profileAnnotation.value();
                                return !environment.matchesProfiles(profiles);
                            }
                        }
                    } catch (ClassNotFoundException e) {
                        // should not happen
                    }

                    return false;
                }).forEach(registry::removeBeanDefinition);
    }

    @Override
    public void setEnvironment(Environment environment) {
        this.environment = environment;
    }
}
</code></pre>
    <blockquote>
     <p>
      AiServiceScannerProcessor实现了BeanDefinitionRegistryPostProcessor接口，其postProcessBeanDefinitionRegistry通过ClassPathAiServiceScanner去扫描@AiService注解的类
     </p>
    </blockquote>
    <h3>
     <a id="ClassPathAiServiceScanner_101">
     </a>
     ClassPathAiServiceScanner
    </h3>
    <p>
     dev/langchain4j/service/spring/ClassPathAiServiceScanner.java
    </p>
    <pre><code>class ClassPathAiServiceScanner extends ClassPathBeanDefinitionScanner {

    ClassPathAiServiceScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {
        super(registry, useDefaultFilters);
        addIncludeFilter(new AnnotationTypeFilter(AiService.class));
    }

    @Override
    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();
        return annotationMetadata.isInterface() &amp;&amp; annotationMetadata.isIndependent();
    }
}
</code></pre>
    <blockquote>
     <p>
      ClassPathAiServiceScanner继承了ClassPathBeanDefinitionScanner，其构造器新增了AiService类型的AnnotationTypeFilter，其isCandidateComponent要求被扫描到的类是接口，而且是独立的(top-level的class或者是静态内部class)
     </p>
    </blockquote>
    <h3>
     <a id="ClassPathBeanDefinitionScanner_120">
     </a>
     ClassPathBeanDefinitionScanner
    </h3>
    <p>
     org/springframework/context/annotation/ClassPathBeanDefinitionScanner.java
    </p>
    <pre><code>	protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
		Assert.notEmpty(basePackages, "At least one base package must be specified");
		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
		for (String basePackage : basePackages) {
			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
			for (BeanDefinition candidate : candidates) {
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
				if (candidate instanceof AbstractBeanDefinition abstractBeanDefinition) {
					postProcessBeanDefinition(abstractBeanDefinition, beanName);
				}
				if (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);
				}
				if (checkCandidate(beanName, candidate)) {
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder =
							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
					beanDefinitions.add(definitionHolder);
					registerBeanDefinition(definitionHolder, this.registry);
				}
			}
		}
		return beanDefinitions;
	}

	protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
	}	
</code></pre>
    <blockquote>
     <p>
      扫描出来是ScannedGenericBeanDefinition(
      <code>
       既是AbstractBeanDefinition类型，也实现了AnnotatedBeanDefinition接口
      </code>
      )，先执行下postProcessBeanDefinition，再执行下AnnotationConfigUtils.processCommonDefinitionAnnotations处理@Lazy、@Primary、@DependsOn、@Role、@Description逻辑，最后通过checkCandidate判断是否要注册beanDefinition，是则调用registerBeanDefinition通过BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry)注册到registry
     </p>
    </blockquote>
    <h2>
     <a id="AiServicesAutoConfig_157">
     </a>
     AiServicesAutoConfig
    </h2>
    <p>
     dev/langchain4j/service/spring/AiServicesAutoConfig.java
    </p>
    <pre><code>public class AiServicesAutoConfig implements ApplicationEventPublisherAware {

    private static final Logger log = LoggerFactory.getLogger(AiServicesAutoConfig.class);

    private ApplicationEventPublisher eventPublisher;

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    @Bean
    BeanFactoryPostProcessor aiServicesRegisteringBeanFactoryPostProcessor() {
        return beanFactory -&gt; {

            // all components available in the application context
            String[] chatLanguageModels = beanFactory.getBeanNamesForType(ChatLanguageModel.class);
            String[] streamingChatLanguageModels = beanFactory.getBeanNamesForType(StreamingChatLanguageModel.class);
            String[] chatMemories = beanFactory.getBeanNamesForType(ChatMemory.class);
            String[] chatMemoryProviders = beanFactory.getBeanNamesForType(ChatMemoryProvider.class);
            String[] contentRetrievers = beanFactory.getBeanNamesForType(ContentRetriever.class);
            String[] retrievalAugmentors = beanFactory.getBeanNamesForType(RetrievalAugmentor.class);
            String[] moderationModels = beanFactory.getBeanNamesForType(ModerationModel.class);

            Set&lt;String&gt; toolBeanNames = new HashSet&lt;&gt;();
            List&lt;ToolSpecification&gt; toolSpecifications = new ArrayList&lt;&gt;();
            for (String beanName : beanFactory.getBeanDefinitionNames()) {
                try {
                    String beanClassName = beanFactory.getBeanDefinition(beanName).getBeanClassName();
                    if (beanClassName == null) {
                        continue;
                    }
                    Class&lt;?&gt; beanClass = Class.forName(beanClassName);
                    for (Method beanMethod : beanClass.getDeclaredMethods()) {
                        if (beanMethod.isAnnotationPresent(Tool.class)) {
                            toolBeanNames.add(beanName);
                            try {
                                toolSpecifications.add(ToolSpecifications.toolSpecificationFrom(beanMethod));
                            } catch (Exception e) {
                                log.warn("Cannot convert %s.%s method annotated with @Tool into ToolSpecification"
                                        .formatted(beanClass.getName(), beanMethod.getName()), e);
                            }
                        }
                    }
                } catch (Exception e) {
                    // TODO
                }
            }

            String[] aiServices = beanFactory.getBeanNamesForAnnotation(AiService.class);
            for (String aiService : aiServices) {
                Class&lt;?&gt; aiServiceClass = beanFactory.getType(aiService);

                GenericBeanDefinition aiServiceBeanDefinition = new GenericBeanDefinition();
                aiServiceBeanDefinition.setBeanClass(AiServiceFactory.class);
                aiServiceBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(aiServiceClass);
                MutablePropertyValues propertyValues = aiServiceBeanDefinition.getPropertyValues();

                AiService aiServiceAnnotation = aiServiceClass.getAnnotation(AiService.class);

                addBeanReference(
                        ChatLanguageModel.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.chatModel(),
                        chatLanguageModels,
                        "chatModel",
                        "chatLanguageModel",
                        propertyValues
                );

                addBeanReference(
                        StreamingChatLanguageModel.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.streamingChatModel(),
                        streamingChatLanguageModels,
                        "streamingChatModel",
                        "streamingChatLanguageModel",
                        propertyValues
                );

                addBeanReference(
                        ChatMemory.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.chatMemory(),
                        chatMemories,
                        "chatMemory",
                        "chatMemory",
                        propertyValues
                );

                addBeanReference(
                        ChatMemoryProvider.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.chatMemoryProvider(),
                        chatMemoryProviders,
                        "chatMemoryProvider",
                        "chatMemoryProvider",
                        propertyValues
                );

                addBeanReference(
                        ContentRetriever.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.contentRetriever(),
                        contentRetrievers,
                        "contentRetriever",
                        "contentRetriever",
                        propertyValues
                );

                addBeanReference(
                        RetrievalAugmentor.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.retrievalAugmentor(),
                        retrievalAugmentors,
                        "retrievalAugmentor",
                        "retrievalAugmentor",
                        propertyValues
                );

                addBeanReference(
                        ModerationModel.class,
                        aiServiceAnnotation,
                        aiServiceAnnotation.moderationModel(),
                        moderationModels,
                        "moderationModel",
                        "moderationModel",
                        propertyValues
                );

                if (aiServiceAnnotation.wiringMode() == EXPLICIT) {
                    propertyValues.add("tools", toManagedList(asList(aiServiceAnnotation.tools())));
                } else if (aiServiceAnnotation.wiringMode() == AUTOMATIC) {
                    propertyValues.add("tools", toManagedList(toolBeanNames));
                } else {
                    throw illegalArgument("Unknown wiring mode: " + aiServiceAnnotation.wiringMode());
                }

                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
                registry.removeBeanDefinition(aiService);
                registry.registerBeanDefinition(lowercaseFirstLetter(aiService), aiServiceBeanDefinition);

                if (eventPublisher != null) {
                    eventPublisher.publishEvent(new AiServiceRegisteredEvent(this, aiServiceClass, toolSpecifications));
                }
            }
        };
    }

    //......
}
</code></pre>
    <blockquote>
     <p>
      AiServicesAutoConfig是个import类，它定义了aiServicesRegisteringBeanFactoryPostProcessor，在postProcessBeanFactory的时候获取ChatLanguageModel、StreamingChatLanguageModel、ChatMemory、ChatMemoryProvider、ContentRetriever、RetrievalAugmentor、解析bean注解@Tool的方法、解析标注@AiService的bean，然后给它添加beanReference，之后先removeBeanDefinition再把填充好属性的aiServiceBeanDefinition(
      <code>
       AiServiceFactory
      </code>
      )重新注册上去，最后发布AiServiceRegisteredEvent事件。
     </p>
    </blockquote>
    <h3>
     <a id="AiServiceFactory_314">
     </a>
     AiServiceFactory
    </h3>
    <p>
     dev/langchain4j/service/spring/AiServiceFactory.java
    </p>
    <pre><code>class AiServiceFactory implements FactoryBean&lt;Object&gt; {

    private final Class&lt;Object&gt; aiServiceClass;
    private ChatLanguageModel chatLanguageModel;
    private StreamingChatLanguageModel streamingChatLanguageModel;
    private ChatMemory chatMemory;
    private ChatMemoryProvider chatMemoryProvider;
    private ContentRetriever contentRetriever;
    private RetrievalAugmentor retrievalAugmentor;
    private ModerationModel moderationModel;
    private List&lt;Object&gt; tools;

    public AiServiceFactory(Class&lt;Object&gt; aiServiceClass) {
        this.aiServiceClass = aiServiceClass;
    }

    public void setChatLanguageModel(ChatLanguageModel chatLanguageModel) {
        this.chatLanguageModel = chatLanguageModel;
    }

    public void setStreamingChatLanguageModel(StreamingChatLanguageModel streamingChatLanguageModel) {
        this.streamingChatLanguageModel = streamingChatLanguageModel;
    }

    public void setChatMemory(ChatMemory chatMemory) {
        this.chatMemory = chatMemory;
    }

    public void setChatMemoryProvider(ChatMemoryProvider chatMemoryProvider) {
        this.chatMemoryProvider = chatMemoryProvider;
    }

    public void setContentRetriever(ContentRetriever contentRetriever) {
        this.contentRetriever = contentRetriever;
    }

    public void setRetrievalAugmentor(RetrievalAugmentor retrievalAugmentor) {
        this.retrievalAugmentor = retrievalAugmentor;
    }

    public void setModerationModel(ModerationModel moderationModel) {
        this.moderationModel = moderationModel;
    }

    public void setTools(List&lt;Object&gt; tools) {
        this.tools = tools;
    }

    @Override
    public Object getObject() {

        AiServices&lt;Object&gt; builder = AiServices.builder(aiServiceClass);

        if (chatLanguageModel != null) {
            builder = builder.chatLanguageModel(chatLanguageModel);
        }

        if (streamingChatLanguageModel != null) {
            builder = builder.streamingChatLanguageModel(streamingChatLanguageModel);
        }

        if (chatMemory != null) {
            builder.chatMemory(chatMemory);
        }

        if (chatMemoryProvider != null) {
            builder.chatMemoryProvider(chatMemoryProvider);
        }

        if (retrievalAugmentor != null) {
            builder = builder.retrievalAugmentor(retrievalAugmentor);
        } else if (contentRetriever != null) {
            builder = builder.contentRetriever(contentRetriever);
        }

        if (moderationModel != null) {
            builder = builder.moderationModel(moderationModel);
        }

        if (!isNullOrEmpty(tools)) {
            for (Object tool : tools) {
                if (isAopProxy(tool)) {
                    builder = builder.tools(aopEnhancedTools(tool));
                } else {
                    builder = builder.tools(tool);
                }
            }
        }

        return builder.build();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return aiServiceClass;
    }

    @Override
    public boolean isSingleton() {
        return true; // TODO
    }

    //......
}
</code></pre>
    <blockquote>
     <p>
      AiServiceFactory实现了FactoryBean接口，其getObject主要通过AiServices.builder(aiServiceClass)来进行构建，默认实现类是DefaultAiServices，它通过Proxy.newProxyInstance来创建实现类，InvocationHandler的实现主要是处理systemMessage、userMessage、构建chatMemory、toolExecutionContext，最后构建ChatRequest，通过context.chatModel.chat(chatRequest)执行请求，然后解析和适配输出。
     </p>
    </blockquote>
    <h2>
     <a id="_424">
     </a>
     小结
    </h2>
    <p>
     langchain4j-spring-boot-starter的LangChain4jAutoConfig自动import了AiServicesAutoConfig、RagAutoConfig、AiServiceScannerProcessor，其中AiServiceScannerProcessor会扫描标注@AiService的类注册到BeanDefinitionRegistry，之后AiServicesAutoConfig会在postProcessBeanFactory的时候填充好相关属性，然后移除掉之前定义的BeanDefinition，把填充好属性的aiServiceBeanDefinition(
     <code>
      AiServiceFactory
     </code>
     )重新注册上去。
    </p>
    <h2>
     <a id="doc_427">
     </a>
     doc
    </h2>
    <ul>
     <li>
      <a href="https://github.com/langchain4j/langchain4j-spring">
       langchain4j-spring
      </a>
     </li>
    </ul>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f68656c6c6f5f656a62332f:61727469636c652f64657461696c732f313436313935393435" class_="artid" style="display:none">
 </p>
</div>


