---
layout: post
title: "linux学习十三shell编程文字,变量,循环,条件,调试"
date: 2025-03-11 19:17:42 +0800
description: "Shell编程就像掌握了一套智能厨房管理系统，通过：📜 编写自动化菜谱（脚本）⚡ 批量处理食材（文件操作）🔔 设置烹饪提醒（定时任务）🛡️ 监控厨房安全（系统监控）让你从重复劳动中解放，成为高效能的\"数字大厨\"！👨🍳💻Linux 上 Shell 编程中的文字在 Linux 环境中，shell 脚本是系统作和应用程序开发的重要组成部分。shell 脚本的一个关键方面是使用 Literals。在计算机科学和 shell 编程中，术语“literal”是指在源代码中表示固定值的表示法。"
keywords: "linux学习(十三)(shell编程(文字,变量,循环,条件,调试))"
categories: ['未分类']
tags: ['运维', '学习', 'Linux']
artid: "146174914"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146174914
    alt: "linux学习十三shell编程文字,变量,循环,条件,调试"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146174914
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146174914
cover: https://bing.ee123.net/img/rand?artid=146174914
image: https://bing.ee123.net/img/rand?artid=146174914
img: https://bing.ee123.net/img/rand?artid=146174914
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     linux学习(十三)(shell编程(文字,变量,循环,条件,调试))
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="shell-programming">
     Shell 编程
    </h2>
    <p>
     Shell 编程，也称为 shell 脚本，是 Linux作系统不可或缺的一部分。shell 脚本实质上是系统 shell 执行的程序。虽然它可能不如 C 或 C++ 等编译语言强大，但 shell 编程对于管理级任务、自动执行重复性任务和系统监控非常有效。
    </p>
    <p>
     大多数 Linux 发行版都带有 bash （Bourne Again Shell） 作为默认 shell，它不仅是一个出色的命令行 shell，也是一种出色的脚本语言。Shell 脚本通常是在文本编辑器中编写的，然后可以直接从 Linux 命令行运行。
    </p>
    <p>
     bash shell 脚本的简单示例：
    </p>
    <pre><code>#!/bin/bash
# My first script
echo "Hello, World!"
</code></pre>
    <p>
     'echo' 命令将其参数（在本例中为 “Hello， World！”）打印到终端。
    </p>
    <h4>
     🍳
     <strong>
      Shell编程就像写菜谱
     </strong>
    </h4>
    <p>
     <strong>
      核心概念：
     </strong>
     把复杂的厨房工作写成步骤清单（脚本），让电脑这个"智能厨师"自动执行
    </p>
    <hr/>
    <h4>
     📝
     <strong>
      基础菜谱结构（脚本示例）
     </strong>
    </h4>
    <p>
    </p>
    <pre><code>#!/bin/bash
# 自动备份菜谱
echo "开始备份..."
cp -v /菜谱/*.txt /备份/  # 复制所有菜谱到备份目录
echo "备份完成！记得尝新菜哦~"</code></pre>
    <p>
     <strong>
      逐行解释：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <code>
        #!/bin/bash
       </code>
       → 指定用Bash厨具（解释器）
      </p>
     </li>
     <li>
      <p>
       <code>
        # 注释
       </code>
       → 给厨师的提醒笔记（不执行）
      </p>
     </li>
     <li>
      <p>
       <code>
        echo
       </code>
       → 厨房喇叭（输出信息）
      </p>
     </li>
     <li>
      <p>
       <code>
        cp -v
       </code>
       → 复制文件并语音播报进度
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     🛠️
     <strong>
      常用厨房工具（命令）
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        工具
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         变量
        </strong>
       </td>
       <td>
        食材储物罐
       </td>
       <td>
        <code>
         菜名="红烧肉"
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         循环
        </strong>
       </td>
       <td>
        批量处理食材
       </td>
       <td>
        <code>
         for 肉 in 猪肉 牛肉; do 焯水 $肉; done
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         条件判断
        </strong>
       </td>
       <td>
        火候控制
       </td>
       <td>
        <code>
         if [ 温度 -gt 100 ]; then 调小火; fi
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         函数
        </strong>
       </td>
       <td>
        预制调料包
       </td>
       <td>
        <code>
         切菜() { echo "正在切$1..." }
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     🌰
     <strong>
      实用菜谱案例
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      自动清理过期菜品（删除旧文件）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>#!/bin/bash
# 删除7天前的日志
find /var/log -name "*.log" -mtime +7 -exec rm {} \;
echo "过期日志清理完毕！"</code></pre>
    <pre><code>这个命令的作用是在 /var/log 目录下查找所有修改时间超过 7 天的 .log 文件，并删除它们。

具体解析：

find /var/log —— 在 /var/log 目录及其子目录中查找文件。
-name "*.log" —— 只匹配 .log 结尾的文件。
-mtime +7 —— 找出最后修改时间超过 7 天的文件（+7 表示“7 天前及更早”）。
-exec rm {} \; —— 对找到的文件执行 rm 命令，即删除这些文件（{} 代表找到的文件，\; 表示 -exec 命令的结束）。
简单来说，这个命令就是清理 7 天前的日志文件，防止日志堆积占用磁盘空间。</code></pre>
    <h5>
     2️⃣
     <strong>
      智能煮饭定时器（计划任务）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>#!/bin/bash
煮饭时间=40  # 分钟

echo "⏰ 开始煮饭，设定${煮饭时间}分钟"
sleep ${煮饭时间}m &amp;&amp; speak "饭煮好啦！" </code></pre>
    <pre><code>m 表示“分钟”，例如 sleep 30m 就会让程序暂停 30 分钟。</code></pre>
    <h5>
     3️⃣
     <strong>
      食材库存检查（监控磁盘）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>#!/bin/bash
使用率=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')

if [ $使用率 -gt 90 ]; then
   echo "⚠️ 厨房快满了！当前使用率: ${使用率}%"
else
   echo "✅ 存储空间充足: ${使用率}%"
fi</code></pre>
    <pre><code>使用率=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')

df -h /：查看 / 目录的磁盘使用情况，-h 让结果以人类可读的格式显示（比如 GB、MB）。
awk 'NR==2 {print $5}'：提取第二行的第五列，通常是使用率（比如 85%）。
tr -d '%'：去掉 % 符号，使它变成纯数字（方便后续比较）。
if [ $使用率 -gt 90 ]; then

判断使用率是否大于 90%（如果 使用率 超过 90，就表示存储快满了）。
echo "⚠️ 厨房快满了！当前使用率: ${使用率}%"

如果磁盘使用率超过 90%，就打印警告消息 “⚠️ 厨房快满了！”（这里把磁盘比作“厨房”很有趣😆）。
else echo "✅ 存储空间充足: ${使用率}%"

如果使用率低于 90%，就打印**“✅ 存储空间充足”**，说明还有足够的磁盘空间。</code></pre>
    <hr/>
    <h4>
     🔧
     <strong>
      厨房安全须知（最佳实践）
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        先试菜再上桌
       </strong>
       ：用
       <code>
        bash -x 脚本.sh
       </code>
       调试
      </p>
     </li>
     <li>
      <p>
       <strong>
        小心刀具
       </strong>
       ：用
       <code>
        set -e
       </code>
       遇到错误立即停止
      </p>
     </li>
     <li>
      <p>
       <strong>
        标记食材
       </strong>
       ：变量用
       <code>
        ${变量}
       </code>
       包裹更安全
      </p>
     </li>
     <li>
      <p>
       <strong>
        定期维护
       </strong>
       ：用
       <code>
        shellcheck
       </code>
       检查脚本语法
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     💡
     <strong>
      高级烹饪技巧
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        食材组合
       </strong>
       （管道操作）：
      </p>
      <pre><code># 找出所有图片并打包
find . -name "*.jpg" | xargs tar -czvf photos.tar.gz</code></pre>
      <pre><code>find . -name "*.jpg"

在当前目录（.）及其所有子目录中，查找扩展名为 .jpg 的文件。
| xargs tar -czvf photos.tar.gz
xargs 是一个构造命令参数列表并执行命令的工具。

在 find . -name "*.jpg" | xargs tar -czvf photos.tar.gz 这个命令中，find 找到的 .jpg 文件名会通过 | 传递给 xargs，然后 xargs 把这些文件名作为参数拼接到 tar -czvf photos.tar.gz 后面，最终执行 tar 命令进行压缩。

为什么要用 xargs？
find 默认会把所有匹配的文件名逐行输出，但 tar 需要文件名作为参数放在同一行。
xargs 自动把多行输出转换成一行参数列表，避免 tar 处理不了文件名的问题。
比 find ... -exec 更高效，因为 xargs 只执行一次 tar，而 -exec 默认对每个文件执行一次（除非用 +）。

|（管道符）把 find 找到的 .jpg 文件列表传递给 xargs，然后交给 tar 处理。
tar -czvf photos.tar.gz
c（create）：创建一个新的压缩包。
z（gzip）：使用 gzip 进行压缩。
v（verbose）：显示打包过程，列出正在添加的文件。
f photos.tar.gz：指定输出文件名 photos.tar.gz。</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        万能锅具
       </strong>
       （Here Document）：
      </p>
      <pre><code>cat &lt;&lt;EOF &gt; 菜单.txt
今日特价：
1. ${招牌菜}
2. 时令蔬菜
EOF</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        秘密配方
       </strong>
       （环境变量）：
      </p>
      <pre><code>export 秘制酱料="酱油:糖=3:1"
./烹饪脚本.sh  # 子脚本也能使用这个配方</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <p>
     <strong>
      总结：
     </strong>
     Shell编程就像掌握了一套智能厨房管理系统，通过：
    </p>
    <ul>
     <li>
      <p>
       📜 编写自动化菜谱（脚本）
      </p>
     </li>
     <li>
      <p>
       ⚡ 批量处理食材（文件操作）
      </p>
     </li>
     <li>
      <p>
       🔔 设置烹饪提醒（定时任务）
      </p>
     </li>
     <li>
      <p>
       🛡️ 监控厨房安全（系统监控）
      </p>
     </li>
    </ul>
    <p>
     让你从重复劳动中解放，成为高效能的"数字大厨"！ 👨🍳💻
    </p>
    <h2 id="literals-in-shell-programming-on-linux" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        Linux 上 Shell 编程中的文字
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在 Linux 环境中，shell 脚本是系统作和应用程序开发的重要组成部分。shell 脚本的一个关键方面是使用 Literals。在计算机科学和 shell 编程中，术语“literal”是指在源代码中表示固定值的表示法。在 shell 脚本中，这些固定值可以包括字符串文本、数字文本或布尔值。在阅读和理解现有脚本或编写新脚本时，了解如何以及何时使用这些文本至关重要。下面列出了 Linux 下的一些基本 shell 脚本文字：
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       字符串文字：可以通过将文本括在单引号或双引号之间来定义它们。例如，'Hello， world！' 或 “Hello， world！”。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       数字文本：它们表示数字序列。例如，25、100 或 1234。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       布尔文本：在大多数 Linux shell 脚本中，1 表示 true，0 表示 false。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       请注意您使用的文本类型，因为它会显著影响您的脚本、代码的可读性及其整体功能。
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">#!/bin/bash
# Example of literals in shell script
 
StringLiteral="This is a string literal"
NumericLiteral=125
echo $StringLiteral
echo $NumericLiteral</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此示例中， and 是文本 和 用于打印它们。
       <code>
        StringLiteral
       </code>
       <code>
        NumericLiteral
       </code>
       <code>
        e cho
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       永远记住，在 Linux 中编写 shell 脚本时，对文本的良好理解是基础。
      </span>
     </span>
    </p>
    <p>
     <strong>
      Shell脚本中的“文字”（字面量）其实就是你直接写出来的固定值
     </strong>
     ，就像我们说话时直接提到的具体内容。比如：
    </p>
    <hr/>
    <h4>
     1️⃣ ​
     <strong>
      字符串字面量（文字）​
     </strong>
    </h4>
    <p>
     就是直接写出来的文字，像把一句话装进盒子里。有两种包装方式：
    </p>
    <ul>
     <li>
      ​
      <strong>
       单引号盒子 ' '
      </strong>
      ：盒子里的内容会完全保持不变
      <pre><code>name='小明 $100'   # $符号和数字都会原样保存</code></pre>
     </li>
     <li>
      ​
      <strong>
       双引号盒子 " "
      </strong>
      ：盒子里的内容可以“透气”，能识别里面的变量和特殊符号
      <pre><code>money=100
name="小明有 ¥$money"  # 输出：小明有 ¥100</code></pre>
     </li>
    </ul>
    <p>
     <strong>
      举个栗子
     </strong>
     🌰：
    </p>
    <pre><code>echo '今天是$HOSTNAME'  # 输出：今天是$HOSTNAME
echo "今天是$HOSTNAME"  # 输出：今天是你的电脑名称</code></pre>
    <hr/>
    <h4>
     2️⃣ ​
     <strong>
      数字字面量（文字）​
     </strong>
    </h4>
    <p>
     直接写数字，但要注意 ​
     <strong>
      Shell默认所有内容都是字符串
     </strong>
     ，想计算需要特殊处理：
    </p>
    <pre><code>age=25          # 直接写数字
sum=$((10+15)) # 需要$(( ))才能计算</code></pre>
    <p>
     <strong>
      错误示范
     </strong>
     ❌：
    </p>
    <pre><code>result=10+20    # 这不会计算，会被当作字符串"10+20"</code></pre>
    <hr/>
    <h4>
     3️⃣ ​
     <strong>
      布尔字面量（文字）​
     </strong>
    </h4>
    <p>
     Shell用 ​
     <strong>
      命令执行是否成功
     </strong>
     表示真假：
    </p>
    <ul>
     <li>
      ​
      <strong>
       0 表示真
      </strong>
      ​（True）→ 因为命令执行成功时返回0
     </li>
     <li>
      ​
      <strong>
       非0 表示假
      </strong>
      ​（False）→ 不同的数字代表不同的错误类型
     </li>
    </ul>
    <p>
     <strong>
      举个栗子
     </strong>
     🌰：
    </p>
    <pre><code>if grep "hello" file.txt; then
   # 如果找到"hello"（返回0），执行这里
else
   # 如果没找到（返回1），执行这里
fi</code></pre>
    <hr/>
    <h4>
     📝 ​
     <strong>
      重点总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        示例
       </th>
       <th>
        特点说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        字符串
       </td>
       <td>
        <code>
         name="小明"
        </code>
       </td>
       <td>
        单引号严格，双引号灵活
       </td>
      </tr>
      <tr>
       <td>
        数字
       </td>
       <td>
        <code>
         count=42
        </code>
       </td>
       <td>
        直接写数字，计算需特殊符号
       </td>
      </tr>
      <tr>
       <td>
        布尔
       </td>
       <td>
        <code>
         成功返回0
        </code>
       </td>
       <td>
        与常见编程语言相反，特别注意
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <p>
     <strong>
      小练习
     </strong>
     ✍️：
    </p>
    <pre><code># 观察以下代码的区别
num=5+3
echo $num        # 输出什么？
echo $((num))    # 输出什么？
echo $(($num))   # 又会输出什么？</code></pre>
    <p>
     通过理解这些直接写出来的“文字”，你就能更自如地控制Shell脚本的行为了！
    </p>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        代码
       </th>
       <th>
        解析
       </th>
       <th>
        输出
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         echo $num
        </code>
       </td>
       <td>
        <code>
         num="5+3"
        </code>
        ，所以直接输出
        <code>
         5+3
        </code>
       </td>
       <td>
        <code>
         5+3
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         echo $((num))
        </code>
       </td>
       <td>
        <code>
         num
        </code>
        里是字符串
        <code>
         "5+3"
        </code>
        ，不能计算，会报错
       </td>
       <td>
        <strong>
         报错
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         echo $(($num))
        </code>
       </td>
       <td>
        <code>
         $(("5+3"))
        </code>
        ，Bash 解析并计算
        <code>
         5+3
        </code>
       </td>
       <td>
        <code>
         8
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h2 id="variables-in-shell-programming-on-linux">
     Linux 上 Shell 编程中的变量
    </h2>
    <p>
     在 Linux 上的 Shell 编程上下文中，变量是可以存储系统数据或用户定义数据的字符串。它是一个符号名称，分配给一定量的存储空间，该空间量可以在程序执行期间更改其值。变量在任何编程范式中都起着至关重要的作用，shell 脚本也不例外。
    </p>
    <p>
     变量分为两大类：
     <strong>
      系统变量和
     </strong>
     <strong>
      用户定义的变量
     </strong>
     。系统变量由 Linux 系统本身创建和维护。示例包括 PATH、HOME 和 PWD。另一方面，用户定义的变量由用户创建和控制。
    </p>
    <p>
     shell 脚本中的变量由 '=' （等于） 运算符定义，可以通过在变量名称前加上 '$' （美元） 符号来检索该值。
    </p>
    <pre><code># Create a User-Defined Variable
MY_VARIABLE="Hello World"

# Print the value of the Variable
echo $MY_VARIABLE  # Output: Hello World</code></pre>
    <h4>
     🏷️
     <strong>
      Shell变量就像厨房的储物罐
     </strong>
    </h4>
    <p>
     <strong>
      核心概念：
     </strong>
     给不同的食材（数据）贴上标签（变量名），方便随时取用和修改
    </p>
    <hr/>
    <h4>
     🧂
     <strong>
      变量使用基础
     </strong>
    </h4>
    <p>
    </p>
    <pre><code>食材="盐"          # 贴上标签（变量赋值）
echo "请加${食材}"  # 使用时要加${}（防止混淆）
=&gt; 请加盐</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     🥫
     <strong>
      变量分类（储物柜类型）
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        变量类型
       </th>
       <th>
        特点
       </th>
       <th>
        示例
       </th>
       <th>
        查看方式
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         系统变量
        </strong>
       </td>
       <td>
        厨房自带，全大写
       </td>
       <td>
        <code>
         $HOME
        </code>
        （你的厨房位置）
       </td>
       <td>
        <code>
         env
        </code>
        或
        <code>
         printenv
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         用户变量
        </strong>
       </td>
       <td>
        厨师自定义，建议小写
       </td>
       <td>
        <code>
         $菜谱
        </code>
       </td>
       <td>
        <code>
         echo $菜谱
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         环境变量
        </strong>
       </td>
       <td>
        子厨房也能用
       </td>
       <td>
        <code>
         $PATH
        </code>
        （工具位置）
       </td>
       <td>
        <code>
         export
        </code>
        显示
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         局部变量
        </strong>
       </td>
       <td>
        只在当前厨房有效
       </td>
       <td>
        函数内定义的变量
       </td>
       <td>
        无法直接查看
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     🛠️
     <strong>
      变量使用技巧
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      避免标签混淆
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 错误示范（标签贴错位置）
数量=5
echo "需要$数量斤肉"  # 输出：需要5斤肉（正确）
echo "需要$数量斤肉"   # 输出：需要斤肉（$数量斤被误解析）</code></pre>
    <h4>
     <strong>
      错误示范的代码
     </strong>
     ,
     <strong>
      问题出在哪里？
     </strong>
    </h4>
    <ul>
     <li>
      <code>
       $数量
      </code>
      代表变量
      <code>
       数量
      </code>
      ，它的值是
      <code>
       5
      </code>
      。
     </li>
     <li>
      但
      <strong>
       <code>
        $数量斤
       </code>
       在
       <code>
        bash
       </code>
       里会被当作一个新的变量
       <code>
        数量斤
       </code>
       ，而不是
       <code>
        $数量
       </code>
       加上
       <code>
        斤
       </code>
      </strong>
      。
     </li>
     <li>
      <strong>
       如果
       <code>
        数量斤
       </code>
       这个变量没有被定义，Bash 会解析为空字符串
      </strong>
      ，导致
      <code>
       "需要$数量斤肉"
      </code>
      变成
      <code>
       "需要斤肉"
      </code>
      。
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      设置只读调料瓶
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>readonly 秘方="酱油3勺"
秘方="醋2勺"  # 报错：秘方是只读变量</code></pre>
    <pre></pre>
    <h5>
     3️⃣
     <strong>
      让子厨房继承变量
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>export 公用调料="胡椒粉"  # 其他厨房脚本也能使用</code></pre>
    <hr/>
    <h4>
     🌰
     <strong>
      实战菜谱示例
     </strong>
    </h4>
    <h5>
     自动备份菜谱
    </h5>
    <p>
    </p>
    <pre><code>#!/bin/bash
备份目录="/厨房/菜谱备份"
今日菜单=$(date +%Y%m%d).txt

echo "正在备份今日菜单..."
cp 今日菜单.txt "${备份目录}/${今日菜单}"
echo "备份完成！存放于：${备份目录}/${今日菜单}"</code></pre>
    <hr/>
    <h4>
     ⚠️
     <strong>
      厨房安全须知
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        标签规则
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         不能以数字开头：
         <code>
          1号罐=盐
         </code>
         ❌ →
         <code>
          罐1=盐
         </code>
         ✅
        </p>
       </li>
       <li>
        <p>
         避免特殊字符：
         <code>
          调料-油=花生油
         </code>
         ❌ →
         <code>
          调料油=花生油
         </code>
         ✅
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        赋值禁忌
       </strong>
       ：
      </p>
      <pre><code>食材 = "盐"   # 等号两边不能有空格 ❌
食材="盐"     # 正确 ✅</code></pre>
     </li>
     <li>
      <p>
       <strong>
        空值处理
       </strong>
       ：
      </p>
      <pre><code>echo "缺货: ${库存:-无}"  # 库存为空时显示"无"</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     💡
     <strong>
      高级调味技巧
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        字符串切割
       </strong>
       ：
      </p>
      <pre><code>完整菜名="红烧肉.jpg"
echo ${完整菜名%.*}  # 输出：红烧肉（去掉后缀）</code></pre>
     </li>
     <li>
      <p>
       <strong>
        变量计算
       </strong>
       ：
      </p>
      <pre><code>鸡蛋=5
鸡蛋=$((鸡蛋 + 3))  # 现在有8个鸡蛋</code></pre>
     </li>
     <li>
      <p>
       <strong>
        命令结果存变量
       </strong>
       ：
      </p>
      <pre><code>当前温度=$(sensors | grep 'CPU temp' | awk '{print $3}')
echo "CPU温度: ${当前温度}"</code></pre>
     </li>
    </ul>
    <hr/>
    <p>
     <strong>
      总结：
     </strong>
     Shell变量就像智能厨房的标签系统：
    </p>
    <ul>
     <li>
      <p>
       🏷️
       <strong>
        命名
       </strong>
       ：用有意义的标签方便管理
      </p>
     </li>
     <li>
      <p>
       🔒
       <strong>
        作用域
       </strong>
       ：分清私房调料和公共调料
      </p>
     </li>
     <li>
      <p>
       🛡️
       <strong>
        保护
       </strong>
       ：重要配方设为只读
      </p>
     </li>
     <li>
      <p>
       🔄
       <strong>
        灵活使用
       </strong>
       ：支持动态修改和计算
      </p>
     </li>
    </ul>
    <p>
     掌握这些技巧，让你的Shell脚本像米其林大厨一样高效有序！ 👨🍳💻
    </p>
    <p>
    </p>
    <p>
     <code>
      export
     </code>
     的作用是
     <strong>
      让变量在子进程中也可用
     </strong>
     。
     <br/>
     ✅ 变量在
     <code>
      export
     </code>
     之后仍然是当前 shell 的变量，但子进程也能访问。
     <br/>
     ✅
     <code>
      export
     </code>
     变量在新终端不会自动生效，除非写入
     <code>
      ~/.bashrc
     </code>
     或
     <code>
      ~/.bash_profile
     </code>
     。
     <br/>
     ✅
     <code>
      unset
     </code>
     可以删除
     <code>
      export
     </code>
     变量。
    </p>
    <hr/>
    <p>
     💡
     <strong>
      一句话总结
     </strong>
     ：
     <code>
      export
     </code>
     让变量变成
     <strong>
      环境变量
     </strong>
     ，这样它可以在
     <strong>
      当前 shell 及所有子进程
     </strong>
     中使用，但
     <strong>
      不会影响新的终端
     </strong>
     ，要让它永久生效，必须写入
     <code>
      ~/.bashrc
     </code>
     或
     <code>
      ~/.bash_profile
     </code>
     。🚀
    </p>
    <h2 id="loops" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        循环
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       shell 编程中的循环是一个基本概念，它允许根据给定条件一遍又一遍地执行某个代码块。它们对于自动执行重复性任务至关重要，从而提高编码过程的效率且不易出错。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在 Linux 中，shell 脚本通常使用三种类型的循环 - for、while 和 until。
      </span>
     </span>
    </p>
    <ul style="margin-left:0; margin-right:0">
     <li>
      <code>
       for
      </code>
      Loop 迭代项目列表并对每个项目执行作。
     </li>
     <li>
      <code>
       while
      </code>
      只要控制条件保持 true，loop 就会执行命令。
     </li>
     <li>
      <code>
       until
      </code>
      loop 运行命令，直到 control condition 变为 true。
     </li>
    </ul>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       以下是 bash/shell 中的一个简单的 for 循环示例：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">for i in 1 2 3
do
   echo "$i"
done</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       这将输出：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">1
2
3</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       这只是 Linux 中 shell 编程中循环的表面。如果明智地使用这些结构，可以增强您的脚本并为有效的脚本编写和自动化开辟许多领域。
      </span>
     </span>
    </p>
    <p>
     好的，我来用最生活化的方式解释 Shell 中的循环，就像教朋友做菜时的步骤说明：
    </p>
    <hr/>
    <h4>
     ​
     <strong>
      循环就像「重复做某件事的规则」​
     </strong>
    </h4>
    <p>
     想象你要做以下事情：
     <br/>
     1️⃣ ​
     <strong>
      按清单买水果
     </strong>
     → 用
     <code>
      for
     </code>
     循环
     <br/>
     2️⃣ ​
     <strong>
      洗碗直到洗完
     </strong>
     → 用
     <code>
      while
     </code>
     循环
     <br/>
     3️⃣ ​
     <strong>
      等快递直到门铃响
     </strong>
     → 用
     <code>
      until
     </code>
     循环
    </p>
    <hr/>
    <h4>
     1️⃣ ​**
     <code>
      for
     </code>
     循环：按固定清单办事**
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：你有一张购物清单，要依次买上面的每样东西
     <br/>
     <strong>
      语法
     </strong>
     ：
    </p>
    <pre><code>for 物品 in 苹果 香蕉 橘子   # 清单可以是数字/文件名等
do
    echo "现在买：$物品"     # 对每个物品执行操作
done</code></pre>
    <p>
     <strong>
      示例
     </strong>
     ：
    </p>
    <pre><code>for fruit in 苹果 香蕉 橘子
do
   echo "买了 $fruit"
done</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇
    </p>
    <pre><code>买了 苹果  
买了 香蕉  
买了 橘子</code></pre>
    <p>
     <strong>
      小技巧
     </strong>
     ：快速生成数字序列
    </p>
    <pre><code>for i in {1..5}         # 输出1到5
for i in $(seq 1 2 10) # 输出1 3 5 7 9（步长2）</code></pre>
    <hr/>
    <h4>
     2️⃣ ​**
     <code>
      while
     </code>
     循环：只要条件成立，就一直做**
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：洗碗时，只要还有脏碗，就继续洗
     <br/>
     <strong>
      语法
     </strong>
     ：
    </p>
    <pre><code>while [ 条件 ]       # 条件为真（返回0）时执行
do
    echo "正在洗碗..."
    更新条件         # 必须修改条件，否则无限循环！
done</code></pre>
    <p>
     <strong>
      示例
     </strong>
     ​（倒计时3秒）：
    </p>
    <pre><code>counter=3
while [ $counter -gt 0 ]  # -gt 表示大于
do
   echo "倒计时：$counter"
   counter=$((counter-1)) # 修改条件变量
done</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇
    </p>
    <pre><code>倒计时：3  
倒计时：2  
倒计时：1</code></pre>
    <p>
     <strong>
      ⚠️ 重点
     </strong>
     ：条件里的方括号
     <code>
      [ ]
     </code>
     两边必须有空格！
    </p>
    <hr/>
    <h4>
     3️⃣ ​**
     <code>
      until
     </code>
     循环：一直做，直到条件成立**
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：等快递时，每隔5分钟查一次，直到快递到了
     <br/>
     <strong>
      语法
     </strong>
     ：
    </p>
    <pre><code>until [ 条件 ]       # 条件为假（返回非0）时执行
do
    echo "快递还没到"
    更新条件
done</code></pre>
    <p>
     <strong>
      示例
     </strong>
     ​（从5减到0停止）：
    </p>
    <pre><code>counter=5
until [ $counter -eq 0 ]  # -eq 表示等于
do
   echo "剩余次数：$counter"
   counter=$((counter-1))
done</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇
    </p>
    <pre><code>剩余次数：5  
剩余次数：4  
剩余次数：3  
剩余次数：2  
剩余次数：1</code></pre>
    <hr/>
    <h4>
     ​
     <strong>
      三种循环对比表
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        循环类型
       </th>
       <th>
        执行时机
       </th>
       <th>
        常用场景
       </th>
       <th>
        类比
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         for
        </code>
       </td>
       <td>
        按已知清单逐个处理
       </td>
       <td>
        遍历文件、数字序列
       </td>
       <td>
        按购物清单买东西
       </td>
      </tr>
      <tr>
       <td>
        <code>
         while
        </code>
       </td>
       <td>
        ​
        <strong>
         只要
        </strong>
        条件成立就执行
       </td>
       <td>
        不确定次数的重复操作
       </td>
       <td>
        洗碗直到没有脏碗
       </td>
      </tr>
      <tr>
       <td>
        <code>
         until
        </code>
       </td>
       <td>
        ​
        <strong>
         直到
        </strong>
        条件成立才停止
       </td>
       <td>
        等待某个状态变化
       </td>
       <td>
        等快递直到门铃响
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <p>
     <strong>
      小练习
     </strong>
     ✍️：
     <br/>
     猜猜这段代码会输出什么？
    </p>
    <pre><code>for num in 3 1 4
do
   while [ $num -gt 0 ]
   do
      echo -n "$num "
      num=$((num-1))
   done
done</code></pre>
    <p>
     <strong>
      答案
     </strong>
     ：
    </p>
    <pre><code>3 2 1 1 4 3 2 1</code></pre>
    <p>
     （解释：外层
     <code>
      for
     </code>
     循环依次处理3→1→4，每个数字内层
     <code>
      while
     </code>
     循环减到0停止）
    </p>
    <h2 id="conditionals-in-shell-programming" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        Shell 编程中的条件语句
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux Shell 编程中的条件语句允许脚本根据条件做出决策。这些是任何编程语言不可或缺的一部分，就像 C、Python、JavaScript 等其他语言一样，Linux Shell 也提供条件语句。条件语句可以定义为 shell 脚本的组成部分，它根据给定的条件引导解释器进入正确的执行路径。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在 shell 中，用于条件语句的主要命令是 、 、 （else if） 和 。这些命令用于基于条件测试结果的流程控制，条件测试可以评估字符串变量、算术测试或流程状态的值。
       <code>
        if
       </code>
       <code>
        elif
       </code>
       <code>
        else
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       以下是它们工作原理的简单说明：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">#!/bin/sh
a=10
b=20

if [ $a -lt 20 ]
then
   echo "a is less than b"
elif [ $a -gt 20 ]
then
   echo "a is greater than b"
else
   echo "a is equal to b"
fi</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在上面的脚本中，正在检查语句内的条件。如果条件为 ，则执行语句中的代码块，否则，它将移动到条件，依此类推。如果这些条件都不满足，则将执行语句中的代码块。
       <code>
        if
       </code>
       <code>
        true
       </code>
       <code>
        if
       </code>
       <code>
        elif
       </code>
       <code>
        else
       </code>
      </span>
     </span>
    </p>
    <h4>
     🌦️
     <strong>
      Shell条件语句就像天气决策指南
     </strong>
    </h4>
    <p>
     <strong>
      核心概念：
     </strong>
     根据不同的天气条件（判断条件），决定今天要做什么（执行不同代码块）
    </p>
    <hr/>
    <h5>
     📝
     <strong>
      基础天气预报结构
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>#!/bin/bash
温度=25

if [ $温度 -lt 10 ]; then
   echo "❄️ 穿羽绒服！"
elif [ $温度 -lt 20 ]; then
   echo "🍂 穿外套吧"
else
   echo "☀️ 短袖出门~"
fi</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     🌈
     <strong>
      天气判断要素解析
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        条件符号
       </th>
       <th>
        含义
       </th>
       <th>
        示例
       </th>
       <th>
        生活类比
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         -lt
        </code>
       </td>
       <td>
        小于（&lt;）
       </td>
       <td>
        <code>
         [ $温度 -lt 30 ]
        </code>
       </td>
       <td>
        温度低于30度
       </td>
      </tr>
      <tr>
       <td>
        <code>
         -gt
        </code>
       </td>
       <td>
        大于（&gt;）
       </td>
       <td>
        <code>
         [ $电量 -gt 20 ]
        </code>
       </td>
       <td>
        电量高于20%
       </td>
      </tr>
      <tr>
       <td>
        <code>
         -eq
        </code>
       </td>
       <td>
        等于（==）
       </td>
       <td>
        <code>
         [ $星期 -eq 1 ]
        </code>
       </td>
       <td>
        周一
       </td>
      </tr>
      <tr>
       <td>
        <code>
         -ne
        </code>
       </td>
       <td>
        不等于（!=）
       </td>
       <td>
        <code>
         [ $天气 != "雨" ]
        </code>
       </td>
       <td>
        不是雨天
       </td>
      </tr>
      <tr>
       <td>
        <code>
         -le
        </code>
       </td>
       <td>
        小于等于（&lt;=）
       </td>
       <td>
        <code>
         [ $年龄 -le 18 ]
        </code>
       </td>
       <td>
        未成年人
       </td>
      </tr>
      <tr>
       <td>
        <code>
         -ge
        </code>
       </td>
       <td>
        大于等于（&gt;=）
       </td>
       <td>
        <code>
         [ $身高 -ge 120 ]
        </code>
       </td>
       <td>
        身高120cm以上
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     🌰
     <strong>
      真实生活场景案例
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      文件备份检查
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>if [ -f "/data/备份.zip" ]; then
   echo "✅ 备份存在"
else
   echo "⚠️ 警告：未找到备份文件！"
   exit 1
fi</code></pre>
    <h5>
     2️⃣
     <strong>
      用户输入判断
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>read -p "今天要带伞吗？(y/n): " 选择
if [ "$选择" = "y" ]; then
   echo "🌂 记得放包里"
elif [ "$选择" = "n" ]; then
   echo "☀️ 享受晴天吧"
else
   echo "输入错误，请重新选择"
fi</code></pre>
    <h5>
     3️⃣
     <strong>
      多条件组合
     </strong>
    </h5>
    <p>
    </p>
    <pre><code>if [ $时间 -gt 6 -a $时间 -lt 18 ]; then
   echo "现在是白天"
elif [ $时间 -lt 6 -o $时间 -ge 18 ]; then
   echo "现在是夜晚"
fi</code></pre>
    <hr/>
    <h4>
     ⚠️
     <strong>
      天气预测注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        空格敏感
       </strong>
       → 方括号两边必须有空格
       <br/>
       ❌错误：
       <code>
        [$温度&lt;25]
       </code>
       <br/>
       ✅正确：
       <code>
        [ $温度 -lt 25 ]
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        变量防护
       </strong>
       → 用双引号包裹变量防止空值
       <br/>
       ❌危险：
       <code>
        [ $文件名 == "test" ]
       </code>
       <br/>
       ✅安全：
       <code>
        [ "$文件名" == "test" ]
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        逻辑运算符
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <code>
          -a
         </code>
         → 且（and）
        </p>
       </li>
       <li>
        <p>
         <code>
          -o
         </code>
         → 或（or）
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     💡
     <strong>
      高级天气预测技巧
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        文件测试
       </strong>
       ：
      </p>
      <pre><code>if [ -d "/data" ]; then  # 检查是否是目录
   echo "找到数据仓库"
fi</code></pre>
     </li>
     <li>
      <p>
       <strong>
        字符串比较
       </strong>
       ：
      </p>
      <pre><code>if [ "$OSTYPE" = "linux-gnu" ]; then
   echo "Linux系统"
fi</code></pre>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>$OSTYPE 是一个系统变量

OSTYPE 变量存储了当前操作系统的类型，比如：
在 Linux 上，echo $OSTYPE 通常输出 linux-gnu
在 macOS 上，echo $OSTYPE 通常输出 darwin
在 Windows（WSL）上，可能输出 linux-gnu</code></pre>
    <ul>
     <li>
      <ul>
      </ul>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       <strong>
        数学运算
       </strong>
       ：
      </p>
      <pre><code>if (( 温度 &gt; 30 )); then  # 双括号支持数学表达式
   echo "高温预警！"
fi</code></pre>
     </li>
    </ul>
    <hr/>
    <p>
     <strong>
      总结：
     </strong>
     Shell条件语句就像智能天气预报系统，通过：
    </p>
    <ul>
     <li>
      <p>
       🌧️
       <strong>
        基础判断
       </strong>
       → 单条件决策
      </p>
     </li>
     <li>
      <p>
       ⛅
       <strong>
        多级判断
       </strong>
       → 处理复杂天气变化
      </p>
     </li>
     <li>
      <p>
       🌈
       <strong>
        组合条件
       </strong>
       → 应对特殊天气组合
       <br/>
       让你的脚本具备智能决策能力！
      </p>
     </li>
    </ul>
    <h2 id="debugging-in-shell-programming-under-linux" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        在 Linux 下进行 Shell 编程调试
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 是一个强大而灵活的作系统，许多开发人员和系统管理员都喜欢它的多功能性和强大功能。特别是，Linux 中的 shell 编程允许您高效地自动执行任务和管理系统。但是，鉴于 shell 脚本的复杂性，调试是处理错误和提高代码性能的一项基本技能。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在 shell 脚本中遇到问题时，您可以在 Linux 环境中使用多种调试工具。这些有助于检测、跟踪和修复 shell 脚本中的错误或错误。其中一些调试工具包括 bash shell 的 （or ） 选项，这些选项允许执行跟踪。其他工具（如 ， command），甚至利用外部调试工具（如 ）也可能非常有效。
       <code>
        -x
       </code>
       <code>
        -v
       </code>
       <code>
        trap
       </code>
       <code>
        set
       </code>
       <code>
        shellcheck
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       考虑使用 -x 选项打开 shell 脚本以进行执行跟踪，如下所示：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">#!/bin/bash -x</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       或者，您可以直接从命令行在调试模式下运行脚本。
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">bash -x script.sh</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       这些调试工具和选项可以极大地帮助您使脚本更加防错和高效。
      </span>
     </span>
    </p>
    <p>
     我来用生活中「修理东西」的场景，帮你理解 Shell 脚本调试的套路：
    </p>
    <hr/>
    <h4>
     ​
     <strong>
      调试就像修漏水的水管
     </strong>
    </h4>
    <p>
     想象你家的水管漏水，但不知道哪里破了。你会：
     <br/>
     1️⃣ ​
     <strong>
      看水从哪流出来
     </strong>
     → 用
     <code>
      -x
     </code>
     选项看脚本执行流程
     <br/>
     2️⃣ ​
     <strong>
      分段检查水管
     </strong>
     → 用
     <code>
      set -x
     </code>
     和
     <code>
      set +x
     </code>
     局部调试
     <br/>
     3️⃣ ​
     <strong>
      用检测仪找裂缝
     </strong>
     → 用
     <code>
      shellcheck
     </code>
     工具提前发现隐患
    </p>
    <hr/>
    <h4>
     1️⃣ ​
     <strong>
      ​「全程监控」模式：
      <code>
       bash -x
      </code>
      或
      <code>
       #!/bin/bash -x
      </code>
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：像摄像头一样记录脚本每一步的执行过程
     <br/>
     <strong>
      示例
     </strong>
     ：调试一个打印数字的脚本
    </p>
    <pre><code>#!/bin/bash -x  # 关键在这里！
for i in 1 2 3
do
  echo "Number: $i"
done</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇（带
     <code>
      +
     </code>
     的行是调试信息）
    </p>
    <pre><code>+ for i in 1 2 3
+ echo 'Number: 1'
Number: 1
+ for i in 1 2 3
+ echo 'Number: 2'
Number: 2
+ for i in 1 2 3
+ echo 'Number: 3'
Number: 3</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：快速定位脚本卡在哪里，观察变量值变化
    </p>
    <hr/>
    <h4>
     2️⃣ ​
     <strong>
      ​「局部放大镜」调试：
      <code>
       set -x
      </code>
      和
      <code>
       set +x
      </code>
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：只检查脚本的某一段代码，避免信息过多
     <br/>
     <strong>
      示例
     </strong>
     ：只监控循环部分
    </p>
    <pre><code>#!/bin/bash
echo "开始执行"
set -x  # 从这里开始记录
for i in {1..2}
do
  echo "第 $i 次循环"
done
set +x  # 到这里停止记录
echo "执行结束"</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇
    </p>
    <pre><code>开始执行
+ for i in '{1..2}'
+ echo '第 1 次循环'
第 1 次循环
+ for i in '{1..2}'
+ echo '第 2 次循环'
第 2 次循环
+ set +x
执行结束</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：长脚本中重点排查某段代码
    </p>
    <hr/>
    <h4>
     3️⃣ ​
     <strong>
      ​「智能安检仪」：
      <code>
       shellcheck
      </code>
      工具
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：像机场安检机，提前发现脚本中的隐患
     <br/>
     <strong>
      安装
     </strong>
     ：
     <code>
      sudo apt install shellcheck
     </code>
     （Debian/Ubuntu）
     <br/>
     <strong>
      使用
     </strong>
     ：
    </p>
    <pre><code>shellcheck 你的脚本.sh</code></pre>
    <p>
     <strong>
      示例
     </strong>
     ：检查一个未引用的变量
    </p>
    <pre><code># 问题脚本 test.sh
name=Kk
if [ $name == "Kk" ]  # 这里$name没加引号！
then
  echo "YES"
fi</code></pre>
    <p>
     运行
     <code>
      shellcheck test.sh
     </code>
     会提示：
    </p>
    <pre><code>Line 2: if [ $name == "Kk" ]  
         ^-- SC2077: 建议给$name加双引号，避免空格导致错误</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：提前发现语法错误、不安全代码
    </p>
    <hr/>
    <h4>
     4️⃣ ​
     <strong>
      ​「紧急刹车」调试：
      <code>
       trap
      </code>
      命令
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：在脚本出错时自动触发调试（类似汽车碰撞时弹气囊）
     <br/>
     <strong>
      示例
     </strong>
     ：任何命令失败时打印错误行
    </p>
    <pre><code>#!/bin/bash
trap 'echo "出错啦！在行号: $LINENO"' ERR  # 捕获错误信号
echo "第一步正常"
ls 不存在的文件    # 这里会报错
echo "第二步正常"  # 不会执行到这里</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇
    </p>
    <pre><code>第一步正常
ls: 无法访问'不存在的文件': 没有那个文件或目录
出错啦！在行号: 4</code></pre>
    <p>
     <strong>
      适用场景
     </strong>
     ：捕捉脚本崩溃前的状态
    </p>
    <hr/>
    <h4>
     5️⃣ ​
     <strong>
      ​「人工检查」技巧：
      <code>
       echo
      </code>
      打印变量
     </strong>
    </h4>
    <p>
     <strong>
      作用
     </strong>
     ：像用便签纸标记重要位置，手动确认变量值
     <br/>
     <strong>
      示例
     </strong>
     ：检查循环变量
    </p>
    <pre><code>for user in "Tom" "Jerry"
do
  echo "调试点：当前用户是 $user" &gt;&amp;2  # &gt;&amp;2 表示输出到错误流
  # ...其他代码...
done</code></pre>
    <p>
     <strong>
      输出
     </strong>
     👇
    </p>
    <pre><code>调试点：当前用户是 Tom
调试点：当前用户是 Jerry</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：简单粗暴有效，适合快速测试
    </p>
    <hr/>
    <h4>
     ​
     <strong>
      调试工具对比表
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        适用阶段
       </th>
       <th>
        优点
       </th>
       <th>
        类比
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         bash -x
        </code>
       </td>
       <td>
        运行时调试
       </td>
       <td>
        全局跟踪执行流程
       </td>
       <td>
        水管全段摄像头
       </td>
      </tr>
      <tr>
       <td>
        <code>
         set -x
        </code>
       </td>
       <td>
        运行时调试
       </td>
       <td>
        局部精准检查
       </td>
       <td>
        手电筒照特定区域
       </td>
      </tr>
      <tr>
       <td>
        <code>
         shellcheck
        </code>
       </td>
       <td>
        写代码时
       </td>
       <td>
        提前预防错误
       </td>
       <td>
        施工前的设计检查
       </td>
      </tr>
      <tr>
       <td>
        <code>
         trap
        </code>
       </td>
       <td>
        运行时错误处理
       </td>
       <td>
        捕捉崩溃瞬间状态
       </td>
       <td>
        汽车黑匣子
       </td>
      </tr>
      <tr>
       <td>
        <code>
         echo
        </code>
       </td>
       <td>
        任何情况
       </td>
       <td>
        灵活直观
       </td>
       <td>
        贴便签做标记
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <p>
     <strong>
      调试小贴士
     </strong>
     💡：
    </p>
    <ol>
     <li>
      遇到无限循环时，按
      <code>
       Ctrl + C
      </code>
      强制终止
     </li>
     <li>
      变量赋值后立即用
      <code>
       echo
      </code>
      确认值是否正确
     </li>
     <li>
      复杂脚本用
      <code>
       #
      </code>
      注释掉部分代码，分段测试
     </li>
     <li>
      错误信息别怕，先看行号，再检查附近代码
     </li>
    </ol>
    <p>
     <strong>
      练习
     </strong>
     ：写一个错误脚本（比如计算 1+2 但结果错误），用以上方法调试并修复它！
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f736f6c6f6d6f6e7a772f:61727469636c652f64657461696c732f313436313734393134" class_="artid" style="display:none">
 </p>
</div>


