---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303439303531302f:61727469636c652f64657461696c732f313435383733313933"
layout: post
title: "操作系统-2.1-cpu管理的初步了解"
date: 2025-03-07 19:52:34 +0800
description: "在并发执行中，CPU需要在多个进程之间切换。切换时，不仅要修改程序计数器（PC），还需要保存和恢复进程的上下文（如寄存器的值）。这种切换机制是操作系统管理CPU的核心功能之一。进程的概念当程序开始执行时，它就变成了一个“进程”。进程是运行中的程序，与静态的程序不同，它需要记录当前的执行状态（如寄存器的值、程序计数器的值等）。这些状态信息存储在进程控制块（PCB）中。进程的概念用于描述运行中的程序，并支持并发执行。"
keywords: "操作系统 2.1-cpu管理的初步了解"
categories: ['未分类']
tags: ['算法', 'Java', 'C']
artid: "145873193"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145873193
    alt: "操作系统-2.1-cpu管理的初步了解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145873193
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145873193
cover: https://bing.ee123.net/img/rand?artid=145873193
image: https://bing.ee123.net/img/rand?artid=145873193
img: https://bing.ee123.net/img/rand?artid=145873193
---

# 操作系统 2.1-cpu管理的初步了解

## 使用CPU

![](https://i-blog.csdnimg.cn/direct/2309804467774b3dae231807d6b611b0.png)

![](https://i-blog.csdnimg.cn/direct/010bfbf4700b4e67a987d24cd0746400.png)

首先管理cpu首先要使用cpu。CPU的工作基于冯·诺依曼体系结构，程序存储在内存中，CPU通过程序计数器（PC）获取指令地址，从内存中取出指令并执行。
**CPU的工作过程是自动的，只要给定初始地址（PC的初值），CPU就会不断取指、执行。**

所以我们只要给给pc附上初值，计算机就会自动运行。

## **单程序执行的局限性**

![](https://i-blog.csdnimg.cn/direct/8bd66fc9a7b640689261d470dcfe6f47.png)

程序的主要功能是计算从1到用户输入的数字（通过命令行参数传入）的累加和，并输出结果。以下是程序的代码：

```cpp
int main(int argc, char* argv[])
{
    int i, to, sum = 0;
    to = atoi(argv[1]);
    for(i = 1; i <= to; i++)
    {
        sum = sum + i;
        // fprintf(fp, "%d", sum); // 这行被注释掉了
    }
    // fprintf(fp, "%d", sum); // 这行也被注释掉了
}
```

图中展示了两种情况的执行时间：

1. **没有使用
   `fprintf`
   的情况**
   ：

   * 命令行执行：
     `sum 10000000`
   * 执行时间：0.015秒
   * 由于循环执行了1000万次，所以每次循环的执行时间大约是 (0.015 \times 10^7) 秒。
2. **使用
   `fprintf`
   的情况**
   ：

   * 命令行执行：
     `sum 1000`
   * 执行时间：0.859秒
   * 由于循环执行了1000次，所以每次循环的执行时间大约是 (0.859 \times 10^3) 秒。

两种情况下每次循环的执行时间比值，即 5.7×10^5:1。这个比值表明，当程序中包含
`fprintf`
语句时，每次循环的执行时间显著增加，
**这是因为
`fprintf`
涉及到文件I/O操作**
，而文件I/O操作通常比内存操作要慢得多。

所以这就出现了一个问题：

如果只运行一个程序，CPU的利用率会很低。

例如，当程序中包含I/O操作（如磁盘读写）时，
**CPU需要等待I/O完成才能继续执行，导致CPU大部分时间处于空闲状态**
。

## **引入多道程序的概念**

![](https://i-blog.csdnimg.cn/direct/0fddfb2da5b140efa6bfbeaf29639928.png)

**解决方案**
：

**程序执行流程**
：

程序首先执行一系列指令，如
`mov ax, [100]`
（将内存地址100处的值移动到寄存器ax中）、
`mov bx, [101]`
（将内存地址101处的值移动到寄存器bx中）和
`add ax, bx`
（将寄存器ax和bx的值相加，结果存回ax）。

接着，程序执行到指令
`53: 启动磁盘读写`
，这里程序需要等待磁盘I/O操作完成。

**磁盘I/O操作的影响**
：

当程序执行到磁盘读写操作时，由于磁盘操作相对较慢，程序需要等待磁盘操作完成才能继续执行后续指令（图中标记为
`54: xxxx`
的未知指令）。在等待磁盘操作完成期间，CPU实际上处于空闲状态，这导致CPU资源的浪费。

**多程序执行的情境**
：

当一个程序在等待磁盘I/O操作时，其他程序也因为同样的原因处于等待状态，导致整个系统的效率降低。这种等待磁盘I/O操作的情况在多程序环境中尤为突出，因为每个程序可能都需要访问磁盘，从而导致多个程序连续等待，增加了等待时间。

为了提高CPU利用率，可以同时在内存中加载多个程序，并让CPU交替执行这些程序。

**当一个程序因I/O操作而暂停时，CPU可以切换到另一个程序继续执行。**
这种交替执行的方式称为“并发”。

**并发执行的优势**

**提高CPU利用率**
：CPU不再因等待I/O操作而空闲，而是切换到其他程序继续工作。

**提高任务执行效率**
：多个程序并发执行，整体任务完成时间缩短。

**带动外设工作**
：CPU的高效工作也会带动其他外设（如磁盘、打印机等）的高效利用。

## **切换机制**

![](https://i-blog.csdnimg.cn/direct/1534949b9f564a0f915f5a625abd7a68.png)

![](https://i-blog.csdnimg.cn/direct/526dae26fc2a46698df107dad87fe831.png)

### 程序切换的背景

在多任务操作系统中，CPU需要在多个程序之间切换，以实现并发执行。
**这种切换不仅仅是改变程序计数器（PC）的值，还需要保存和恢复每个程序的执行状态**
。

1. **程序1和程序2的指令**
   ：

   * 程序1从地址50开始执行，指令包括
     `mov ax, 1`
     、
     `mov bx, 1`
     和
     `add ax, bx`
     。
   * 程序2从地址200开始执行，指令包括
     `mov ax, 10`
     、
     `mov bx, 10`
     和
     `add ax, bx`
     。
2. **程序切换**
   ：

   * 当程序1执行到某一点时，操作系统可能会决定切换到程序2执行。
   * 切换时，需要保存程序1的当前状态（包括PC和其他寄存器的值），以便之后可以恢复执行。
3. **PCB（进程控制块）**
   ：

   * 每个程序都有一个PCB，用于存储程序的执行状态，包括PC、寄存器的值等。
   * 当程序1被切换出去时，其PC值（53）和其他寄存器的值（如ax=2, bx=1）需要保存在对应的PCB中。
   * 当程序1再次被切换回来时，操作系统需要从其PCB中恢复这些值，以便从上次中断的地方继续执行。

### 切换机制的详细步骤

1. **保存当前程序的状态**
   ：

   * 当操作系统决定从程序1切换到程序2时，首先需要保存程序1的当前状态，包括PC值和其他寄存器的值。
2. **加载下一个程序的状态**
   ：

   * 然后，操作系统加载程序2的状态，包括设置PC值和其他寄存器的值，以便程序2可以从正确的位置开始执行。
3. **执行程序2**
   ：

   * 程序2开始执行，直到操作系统再次决定切换。
4. **恢复程序1的状态**
   ：

   * 当程序1再次被切换回来时，操作系统从其PCB中恢复保存的状态，包括PC值和其他寄存器的值。

### 总结

在并发执行中，CPU需要在多个进程之间切换。切换时，不仅要修改程序计数器（PC），还需要保存和恢复进程的上下文（如寄存器的值）。这种切换机制是操作系统管理CPU的核心功能之一。

## **进程的概念**

![](https://i-blog.csdnimg.cn/direct/340f5ab958054ea89af696c6cfcc6a5b.png)

### 引入“进程”概念

1. **运行的程序和静态程序不一样**
   ：

   * 静态程序是指存储在磁盘上未被执行的程序，它们不占用系统资源，也没有执行状态。
   * 运行的程序则是指那些正在内存中执行的程序，它们占用CPU时间和其他资源，并且具有执行状态。
2. **需要描述这些不一样**
   ：

   * 由于运行的程序和静态程序之间存在差异，需要有一种方式来描述这些差异。
   * 这些差异包括程序的执行状态、资源占用情况等。
3. **程序 + 所有这些不一样 → 一个概念**
   ：

   * **将程序本身及其执行状态结合起来，形成了一个新的概念，即“进程”。**
   * 进程是程序的一次执行过程，它不仅包含程序代码，还包括程序的执行状态和资源占用情况。
4. **所有的不一样都表现在PCB中**
   ：

   * PCB（进程控制块）是操作系统用来记录进程信息的数据结构。
   * PCB中包含了进程的所有状态信息，如程序计数器（PC）、寄存器值（如ax、bx等）、内存管理信息等。

### 进程的特点

1. **进程是进行（执行）中的程序**
   ：

   * 进程是程序的执行实例，它具有开始和结束，而程序本身是静态的代码，没有开始和结束的概念。
2. **进程会走走停停**
   ：

   * 进程在执行过程中可能会因为等待I/O操作、资源竞争等原因而暂停执行（即“停”）。
   * 这种走走停停的状态对于静态程序是没有意义的，因为静态程序没有执行状态。
3. **进程需要记录ax, bx, ...**
   ：

   * 进程在执行过程中需要记录其状态信息，如寄存器的值（ax、bx等），以便在进程被切换时能够保存状态，并在恢复执行时能够从正确的位置继续执行。
   * 静态程序不需要记录这些信息，因为它们没有执行状态。

### 总结

**当程序开始执行时，它就变成了一个“进程”。**
进程是运行中的程序，与静态的程序不同，它需要记录当前的执行状态（如寄存器的值、程序计数器的值等）。这些状态信息存储在进程控制块（PCB）中。进程的概念用于描述运行中的程序，并支持并发执行。

![](https://i-blog.csdnimg.cn/img_convert/5cb8f26318818f24faeb2b5e82ad001e.jpeg)