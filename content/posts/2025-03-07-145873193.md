---
layout: post
title: "操作系统-2.1-cpu管理的初步了解"
date: 2025-03-07 19:52:34 +0800
description: "在并发执行中，CPU需要在多个进程之间切换。切换时，不仅要修改程序计数器（PC），还需要保存和恢复进程的上下文（如寄存器的值）。这种切换机制是操作系统管理CPU的核心功能之一。进程的概念当程序开始执行时，它就变成了一个“进程”。进程是运行中的程序，与静态的程序不同，它需要记录当前的执行状态（如寄存器的值、程序计数器的值等）。这些状态信息存储在进程控制块（PCB）中。进程的概念用于描述运行中的程序，并支持并发执行。"
keywords: "操作系统 2.1-cpu管理的初步了解"
categories: ['未分类']
tags: ['算法', 'Java', 'C']
artid: "145873193"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145873193
    alt: "操作系统-2.1-cpu管理的初步了解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145873193
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145873193
cover: https://bing.ee123.net/img/rand?artid=145873193
image: https://bing.ee123.net/img/rand?artid=145873193
img: https://bing.ee123.net/img/rand?artid=145873193
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统 2.1-cpu管理的初步了解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     使用CPU
    </h2>
    <p>
     <img alt="" height="487" src="https://i-blog.csdnimg.cn/direct/2309804467774b3dae231807d6b611b0.png" width="996"/>
    </p>
    <p>
     <img alt="" height="585" src="https://i-blog.csdnimg.cn/direct/010bfbf4700b4e67a987d24cd0746400.png" width="1090"/>
    </p>
    <p>
     首先管理cpu首先要使用cpu。CPU的工作基于冯·诺依曼体系结构，程序存储在内存中，CPU通过程序计数器（PC）获取指令地址，从内存中取出指令并执行。
     <strong>
      CPU的工作过程是自动的，只要给定初始地址（PC的初值），CPU就会不断取指、执行。
     </strong>
    </p>
    <p>
     所以我们只要给给pc附上初值，计算机就会自动运行。
    </p>
    <p>
    </p>
    <h2>
     <strong>
      单程序执行的局限性
     </strong>
    </h2>
    <p>
     <img alt="" height="479" src="https://i-blog.csdnimg.cn/direct/8bd66fc9a7b640689261d470dcfe6f47.png" width="952"/>
    </p>
    <p>
     程序的主要功能是计算从1到用户输入的数字（通过命令行参数传入）的累加和，并输出结果。以下是程序的代码：
    </p>
    <pre><code class="language-cpp">int main(int argc, char* argv[])
{
    int i, to, sum = 0;
    to = atoi(argv[1]);
    for(i = 1; i &lt;= to; i++)
    {
        sum = sum + i;
        // fprintf(fp, "%d", sum); // 这行被注释掉了
    }
    // fprintf(fp, "%d", sum); // 这行也被注释掉了
}</code></pre>
    <p>
     图中展示了两种情况的执行时间：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        没有使用
        <code>
         fprintf
        </code>
        的情况
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         命令行执行：
         <code>
          sum 10000000
         </code>
        </p>
       </li>
       <li>
        <p>
         执行时间：0.015秒
        </p>
       </li>
       <li>
        <p>
         由于循环执行了1000万次，所以每次循环的执行时间大约是 (0.015 \times 10^7) 秒。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        使用
        <code>
         fprintf
        </code>
        的情况
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         命令行执行：
         <code>
          sum 1000
         </code>
        </p>
       </li>
       <li>
        <p>
         执行时间：0.859秒
        </p>
       </li>
       <li>
        <p>
         由于循环执行了1000次，所以每次循环的执行时间大约是 (0.859 \times 10^3) 秒。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     两种情况下每次循环的执行时间比值，即 5.7×10^5:1。这个比值表明，当程序中包含
     <code>
      fprintf
     </code>
     语句时，每次循环的执行时间显著增加，
     <strong>
      这是因为
      <code>
       fprintf
      </code>
      涉及到文件I/O操作
     </strong>
     ，而文件I/O操作通常比内存操作要慢得多。
    </p>
    <p>
     所以这就出现了一个问题：
    </p>
    <p>
     如果只运行一个程序，CPU的利用率会很低。
    </p>
    <p>
     例如，当程序中包含I/O操作（如磁盘读写）时，
     <strong>
      CPU需要等待I/O完成才能继续执行，导致CPU大部分时间处于空闲状态
     </strong>
     。
    </p>
    <p>
    </p>
    <h2 style="background-color:transparent">
     <strong>
      引入多道程序的概念
     </strong>
    </h2>
    <p>
     <img alt="" height="585" src="https://i-blog.csdnimg.cn/direct/0fddfb2da5b140efa6bfbeaf29639928.png" width="1015"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      解决方案
     </strong>
     ：
    </p>
    <p>
     <strong>
      程序执行流程
     </strong>
     ：
    </p>
    <p>
     程序首先执行一系列指令，如
     <code>
      mov ax, [100]
     </code>
     （将内存地址100处的值移动到寄存器ax中）、
     <code>
      mov bx, [101]
     </code>
     （将内存地址101处的值移动到寄存器bx中）和
     <code>
      add ax, bx
     </code>
     （将寄存器ax和bx的值相加，结果存回ax）。
    </p>
    <p>
     接着，程序执行到指令
     <code>
      53: 启动磁盘读写
     </code>
     ，这里程序需要等待磁盘I/O操作完成。
    </p>
    <p>
     <strong>
      磁盘I/O操作的影响
     </strong>
     ：
    </p>
    <p>
     当程序执行到磁盘读写操作时，由于磁盘操作相对较慢，程序需要等待磁盘操作完成才能继续执行后续指令（图中标记为
     <code>
      54: xxxx
     </code>
     的未知指令）。在等待磁盘操作完成期间，CPU实际上处于空闲状态，这导致CPU资源的浪费。
    </p>
    <p>
     <strong>
      多程序执行的情境
     </strong>
     ：
    </p>
    <p>
     当一个程序在等待磁盘I/O操作时，其他程序也因为同样的原因处于等待状态，导致整个系统的效率降低。这种等待磁盘I/O操作的情况在多程序环境中尤为突出，因为每个程序可能都需要访问磁盘，从而导致多个程序连续等待，增加了等待时间。
    </p>
    <p>
    </p>
    <p>
     为了提高CPU利用率，可以同时在内存中加载多个程序，并让CPU交替执行这些程序。
    </p>
    <p>
     <strong>
      当一个程序因I/O操作而暂停时，CPU可以切换到另一个程序继续执行。
     </strong>
     这种交替执行的方式称为“并发”。
    </p>
    <p>
     <strong>
      并发执行的优势
     </strong>
    </p>
    <p>
     <strong>
      提高CPU利用率
     </strong>
     ：CPU不再因等待I/O操作而空闲，而是切换到其他程序继续工作。
    </p>
    <p>
     <strong>
      提高任务执行效率
     </strong>
     ：多个程序并发执行，整体任务完成时间缩短。
    </p>
    <p>
     <strong>
      带动外设工作
     </strong>
     ：CPU的高效工作也会带动其他外设（如磁盘、打印机等）的高效利用。
    </p>
    <p>
    </p>
    <h2>
     <strong>
      切换机制
     </strong>
    </h2>
    <p>
     <img alt="" height="483" src="https://i-blog.csdnimg.cn/direct/1534949b9f564a0f915f5a625abd7a68.png" width="878"/>
    </p>
    <p>
     <img alt="" height="581" src="https://i-blog.csdnimg.cn/direct/526dae26fc2a46698df107dad87fe831.png" width="1002"/>
    </p>
    <p>
    </p>
    <h3 style="background-color:transparent">
     程序切换的背景
    </h3>
    <p>
     在多任务操作系统中，CPU需要在多个程序之间切换，以实现并发执行。
     <strong>
      这种切换不仅仅是改变程序计数器（PC）的值，还需要保存和恢复每个程序的执行状态
     </strong>
     。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        程序1和程序2的指令
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         程序1从地址50开始执行，指令包括
         <code>
          mov ax, 1
         </code>
         、
         <code>
          mov bx, 1
         </code>
         和
         <code>
          add ax, bx
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         程序2从地址200开始执行，指令包括
         <code>
          mov ax, 10
         </code>
         、
         <code>
          mov bx, 10
         </code>
         和
         <code>
          add ax, bx
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        程序切换
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当程序1执行到某一点时，操作系统可能会决定切换到程序2执行。
        </p>
       </li>
       <li>
        <p>
         切换时，需要保存程序1的当前状态（包括PC和其他寄存器的值），以便之后可以恢复执行。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        PCB（进程控制块）
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每个程序都有一个PCB，用于存储程序的执行状态，包括PC、寄存器的值等。
        </p>
       </li>
       <li>
        <p>
         当程序1被切换出去时，其PC值（53）和其他寄存器的值（如ax=2, bx=1）需要保存在对应的PCB中。
        </p>
       </li>
       <li>
        <p>
         当程序1再次被切换回来时，操作系统需要从其PCB中恢复这些值，以便从上次中断的地方继续执行。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     切换机制的详细步骤
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        保存当前程序的状态
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当操作系统决定从程序1切换到程序2时，首先需要保存程序1的当前状态，包括PC值和其他寄存器的值。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        加载下一个程序的状态
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         然后，操作系统加载程序2的状态，包括设置PC值和其他寄存器的值，以便程序2可以从正确的位置开始执行。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        执行程序2
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         程序2开始执行，直到操作系统再次决定切换。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        恢复程序1的状态
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当程序1再次被切换回来时，操作系统从其PCB中恢复保存的状态，包括PC值和其他寄存器的值。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     总结
    </h3>
    <p>
     在并发执行中，CPU需要在多个进程之间切换。切换时，不仅要修改程序计数器（PC），还需要保存和恢复进程的上下文（如寄存器的值）。这种切换机制是操作系统管理CPU的核心功能之一。
    </p>
    <p>
    </p>
    <h2>
     <strong>
      进程的概念
     </strong>
    </h2>
    <p>
     <img alt="" height="595" src="https://i-blog.csdnimg.cn/direct/340f5ab958054ea89af696c6cfcc6a5b.png" width="1044"/>
    </p>
    <h3>
     引入“进程”概念
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        运行的程序和静态程序不一样
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         静态程序是指存储在磁盘上未被执行的程序，它们不占用系统资源，也没有执行状态。
        </p>
       </li>
       <li>
        <p>
         运行的程序则是指那些正在内存中执行的程序，它们占用CPU时间和其他资源，并且具有执行状态。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        需要描述这些不一样
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         由于运行的程序和静态程序之间存在差异，需要有一种方式来描述这些差异。
        </p>
       </li>
       <li>
        <p>
         这些差异包括程序的执行状态、资源占用情况等。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        程序 + 所有这些不一样 → 一个概念
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          将程序本身及其执行状态结合起来，形成了一个新的概念，即“进程”。
         </strong>
        </p>
       </li>
       <li>
        <p>
         进程是程序的一次执行过程，它不仅包含程序代码，还包括程序的执行状态和资源占用情况。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        所有的不一样都表现在PCB中
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         PCB（进程控制块）是操作系统用来记录进程信息的数据结构。
        </p>
       </li>
       <li>
        <p>
         PCB中包含了进程的所有状态信息，如程序计数器（PC）、寄存器值（如ax、bx等）、内存管理信息等。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     进程的特点
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        进程是进行（执行）中的程序
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         进程是程序的执行实例，它具有开始和结束，而程序本身是静态的代码，没有开始和结束的概念。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        进程会走走停停
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         进程在执行过程中可能会因为等待I/O操作、资源竞争等原因而暂停执行（即“停”）。
        </p>
       </li>
       <li>
        <p>
         这种走走停停的状态对于静态程序是没有意义的，因为静态程序没有执行状态。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        进程需要记录ax, bx, ...
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         进程在执行过程中需要记录其状态信息，如寄存器的值（ax、bx等），以便在进程被切换时能够保存状态，并在恢复执行时能够从正确的位置继续执行。
        </p>
       </li>
       <li>
        <p>
         静态程序不需要记录这些信息，因为它们没有执行状态。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     总结
    </h3>
    <p>
     <strong>
      当程序开始执行时，它就变成了一个“进程”。
     </strong>
     进程是运行中的程序，与静态的程序不同，它需要记录当前的执行状态（如寄存器的值、程序计数器的值等）。这些状态信息存储在进程控制块（PCB）中。进程的概念用于描述运行中的程序，并支持并发执行。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="1080" src="https://i-blog.csdnimg.cn/img_convert/5cb8f26318818f24faeb2b5e82ad001e.jpeg" width="1920"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303439303531302f:61727469636c652f64657461696c732f313435383733313933" class_="artid" style="display:none">
 </p>
</div>


