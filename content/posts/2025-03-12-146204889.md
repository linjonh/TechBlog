---
layout: post
title: "Linux进程地址空间"
date: 2025-03-12 22:58:01 +0800
description: "Linux系统编程"
keywords: "[Linux]进程地址空间"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "146204889"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146204889
    alt: "Linux进程地址空间"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146204889
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146204889
cover: https://bing.ee123.net/img/rand?artid=146204889
image: https://bing.ee123.net/img/rand?artid=146204889
img: https://bing.ee123.net/img/rand?artid=146204889
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [Linux]进程地址空间
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-kimbie-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <p>
     该图是虚拟地址：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/df53dc4995dc4bdba381a99c0640cdda.png"/>
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> g_val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//child,子进程肯定先跑完，也就是子进程先修改，完成之后，父进程再读取</span>
		g_val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child[%d]: %d : %p\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> g_val<span class="token punctuation">,</span> <span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//parent</span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent[%d]: %d : %p\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> g_val<span class="token punctuation">,</span> <span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">// 结果</span>
<span class="token comment">//与环境相关，观察现象即可</span>
child<span class="token punctuation">[</span><span class="token number">3046</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token operator">:</span> <span class="token number">0x80497e8</span>
parent<span class="token punctuation">[</span><span class="token number">3045</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">0x80497e8</span>
</code></pre>
    <p>
     变量内容不一样,所以父子进程输出的变量绝对不是同一个变量
    </p>
    <p>
     但地址值是一样的，说明，该地址绝对不是物理地址！
    </p>
    <p>
     在Linux地址下，这种地址叫做虚拟地址
    </p>
    <p>
     <strong>
      我们在用C/C++语言所看到的地址，全部都是虚拟地址！物理地址，用户一概看不到，由OS统一管理
     </strong>
    </p>
    <p>
     在操作系统中，子进程和父进程的虚拟地址空间在创建时是相同的，但它们的物理内存映射可能不同，具体取决于操作系统的内存管理机制。
    </p>
    <p>
     <strong>
      1、fork() 创建子进程时的行为
     </strong>
    </p>
    <p>
     当父进程通过 fork() 创建子进程时，子进程会复制父进程的虚拟地址空间：
    </p>
    <ol>
     <li>
      虚拟地址相同：子进程的代码段、数据段、堆栈等逻辑地址布局与父进程完全一致。
     </li>
     <li>
      物理内存分离：初始时，父子进程的虚拟地址映射到相同的物理内存页，但这些页会被标记为只读（写时复制的优化）。
     </li>
    </ol>
    <p>
     假设父进程有一个变量 int x = 10，地址为 0x1000：
     <br/>
     子进程的 x 也会看到地址 0x1000，但物理内存此时是共享的。
     <br/>
     当父进程或子进程尝试修改 x 时，操作系统会触发写时复制，为修改者分配新的物理页，此时两者的物理内存分离，但虚拟地址仍相同。
    </p>
    <p>
     <strong>
      2、写时拷贝
     </strong>
    </p>
    <ol>
     <li>
      <p>
       核心思想
       <br/>
       共享而非复制：初始时，多个进程（或对象）共享同一份物理内存数据。
       <br/>
       按需拷贝：只有当某个进程尝试写入共享内存时，系统才会真正复制该内存区域，并为写入者分配独立的物理内存副本。
       <br/>
       目的：避免无意义的物理内存复制，提升性能。
       <br/>
       触发条件：当父进程或子进程尝试写入共享内存页时。
       <br/>
       结果：修改者获得独立的物理页，虚拟地址保持不变。
      </p>
     </li>
     <li>
      <p>
       典型场景：fork() 创建子进程
       <br/>
       传统方式：fork() 直接复制父进程全部内存到子进程，导致大量内存拷贝（即使数据未被修改）。
      </p>
     </li>
    </ol>
    <p>
     COW 优化：
     <br/>
     共享阶段：fork() 后，父子进程共享所有内存页，但将内存页标记为只读。
     <br/>
     触发拷贝：当任一进程尝试写入共享页时，触发页错误（Page Fault）。
     <br/>
     内核介入：操作系统检测到写操作，分配新的物理页，复制原页内容到新页，并修改进程的页表映射。
     <br/>
     完成写入：进程继续执行写入操作，但此时操作的是独立的物理页。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/48ea7784eb6e4f9c9080fdf593b2c4a1.png"/>
    </p>
    <ol start="3">
     <li>
      虚拟地址空间的独立性
      <br/>
      进程隔离：每个进程的虚拟地址空间是操作系统分配的独立逻辑视图，彼此隔离。
      <br/>
      物理内存映射不同：即使虚拟地址相同，实际物理内存可能完全不同（如父子进程修改共享页后）。
     </li>
    </ol>
    <p>
     创建进程，本质是系统多了一个进程，因此需要管理进程
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fdc1377b5c6542e58a39b9bd92c9854a.png">
      <br/>
      同一个变量，地址相同，其实是虚拟地址相同，内容不同其实是被映射到了不同的物理地址
     </img>
    </p>
    <p>
     Linux为什么要有地址空间？Linux 进程地址空间的设计是操作系统内存管理的核心机制，其核心目标是为进程提供内存保护、隔离和抽象，同时确保系统稳定性和资源的高效利用。
    </p>
    <p>
     <strong>
      1、内存保护：杜绝系统级越界问题
     </strong>
    </p>
    <p>
     虚拟地址空间的隔离性：
     <br/>
     每个进程拥有独立的虚拟地址空间，通过页表映射到物理内存。进程只能访问其虚拟地址范围内被明确分配的内存区域。
    </p>
    <p>
     页表的权限控制：
     <br/>
     页表中每个内存页标记了读（R）、写（W）、执行（X）权限。例如：
     <br/>
     代码段（.text）标记为 R-X（可读、可执行，不可写），防止恶意代码篡改程序逻辑。
     <br/>
     数据段（.data）标记为 RW-（可读、可写，不可执行），防止数据段被当作代码执行（防范缓冲区溢出攻击）。
    </p>
    <p>
     非法访问示例：
     <br/>
     若进程尝试通过野指针写入未分配的地址（如
     <em>
      (int
     </em>
     )0xdeadbeef = 42），页表中无对应物理页映射，触发段错误（Segmentation Fault），操作系统直接终止进程。
    </p>
    <p>
     内核空间的保护：
     <br/>
     内核内存（如 0xC0000000 以上的高地址空间）在所有进程的虚拟地址中共享，但用户态进程无权访问。任何用户态程序尝试访问内核地址会触发权限异常，确保内核安全。
    </p>
    <p>
     <strong>
      2、内存抽象：进程视角的“独占内存”
     </strong>
    </p>
    <p>
     (1) 一致的虚拟空间布局
     <br/>
     所有进程的虚拟地址空间范围相同：
     <br/>
     例如，在 32 位系统中，每个进程“认为”自己拥有完整的 0x00000000 到 0xFFFFFFFF 地址空间，包含代码段、数据段、堆、栈等区域。
     <br/>
     实际物理内存映射不同：
     <br/>
     进程 A 的栈地址 0x7ffffff0000 可能映射到物理页 X，而进程 B 的同栈地址映射到物理页 Y。
     <br/>
     这种抽象让程序无需关心物理内存的实际分配，简化开发。
    </p>
    <p>
     (2) 进程的“独占内存”假象
     <br/>
     独立的内存视图：
     <br/>
     进程认为自己是系统中唯一运行的实体，所有内存区域（代码、堆、栈）均为自己独占。
     <br/>
     实际资源共享：
     <br/>
     多个进程的代码段可能通过写时拷贝（COW）共享同一物理内存（如 fork() 后的父子进程）。
     <br/>
     动态链接库（如 libc.so）被加载到固定虚拟地址，多个进程共享同一物理内存副本。
    </p>
    <p>
     <strong>
      3、进程独立性：解耦调度与内存管理
     </strong>
    </p>
    <p>
     (1) 内存管理与进程调度的分离
     <br/>
     虚拟地址空间使物理内存管理透明化：
     <br/>
     进程调度器只需关注 CPU 时间片的分配，无需关心进程内存的物理位置。
     <br/>
     内存管理器通过页表动态分配物理页，甚至可以换出（Swap Out）不活跃进程的内存到磁盘，而不影响进程的虚拟地址视图。
    </p>
    <p>
     (2) 灵活的内存分配
     <br/>
     按需分配物理内存：
     <br/>
     进程申请内存（如 malloc()）时，操作系统仅分配虚拟地址，物理内存的分配延迟到实际写入时（通过 COW 或缺页中断）。
    </p>
    <p>
     示例：
     <br/>
     进程调用 malloc(1GB)，系统立即分配虚拟地址范围，但物理内存可能仅在进程实际写入时逐步分配。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/38f69e8170d04400bad20e2edf040467.png"/>
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313330343938312f:61727469636c652f64657461696c732f313436323034383839" class_="artid" style="display:none">
 </p>
</div>


