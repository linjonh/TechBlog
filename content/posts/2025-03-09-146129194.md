---
layout: post
title: "IMX6ULL驱动开发Linux篇02移植Rootfs"
date: 2025-03-09 11:18:48 +0800
description: "root=/dev/nfs nfsroot=[服务器IP]:[根文件系统路径],[NFS 选项] ip=[客户端IP]:[服务器IP]:[网关IP]:[子网掩码]:[主机名]:[设备]:[自动配置]:[DNS0]:[DNS1]客户端 IP 地址是开发板的 IP，需与服务器同一网段，且未被占用，我选择了 192.168.137.4，这个IP有没有效，很简单，跑到主机上ping一下，根文件系统的存放路径例，笔者的是 /home/charliechen/linux/nfs/rootfs。我们还需要图形化微操。"
keywords: "IMX6ULL驱动开发Linux篇02——移植Rootfs"
categories: ['从0开始的学习Armv7A', 'Imx']
tags: ['驱动开发', '移植', '教程', '学习', '内核', 'Rootfs', 'Linux']
artid: "146129194"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146129194
    alt: "IMX6ULL驱动开发Linux篇02移植Rootfs"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146129194
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146129194
cover: https://bing.ee123.net/img/rand?artid=146129194
image: https://bing.ee123.net/img/rand?artid=146129194
img: https://bing.ee123.net/img/rand?artid=146129194
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     IMX6ULL驱动开发Linux篇02——移植Rootfs
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="%E7%BC%96%E8%AF%91rootfs" name="%E7%BC%96%E8%AF%91rootfs">
     编译rootfs
    </h3>
    <p>
     我们下面做的活就是移植rootfs，咱们打算是从NFS上走（网络文件系统）。笔者使用的rootfs是走的1.29.0的版本，之后要作点魔改。
    </p>
    <p>
     首先就是取消我们的shell限制，好像这里的源码写的稍微有点问题——就是支持Unicode了但是shell打印字符的时候还是会查ASCII码来比较，如果是纯英文选手那没关系
    </p>
    <p>
     修改libbb/printable_string.c下的printable_string函数
    </p>
    <pre><code class="language-cpp">const char* FAST_FUNC printable_string(uni_stat_t *stats, const char *str)
{
    char *dst;
    const char *s;
​
    s = str;
    while (1) {
        unsigned char c = *s;
        if (c == '\0') {
            /* 99+% of inputs do not need conversion */
            if (stats) {
                stats-&gt;byte_count = (s - str);
                stats-&gt;unicode_count = (s - str);
                stats-&gt;unicode_width = (s - str);
            }
            return str;
        }
        if (c &lt; ' ')
            break;
        s++;
    }
​
#if ENABLE_UNICODE_SUPPORT
    dst = unicode_conv_to_printable(stats, str);
#else
    {
        char *d = dst = xstrdup(str);
        while (1) {
            unsigned char c = *d;
            if (c == '\0')
                break;
            if (c &lt; ' ')
                *d = '?';
            d++;
        }
        if (stats) {
            stats-&gt;byte_count = (d - dst);
            stats-&gt;unicode_count = (d - dst);
            stats-&gt;unicode_width = (d - dst);
        }
    }
#endif
    return auto_string(dst);
}</code></pre>
    <p>
     修改libbb/unicode.c
    </p>
    <pre><code class="language-cpp">static char* FAST_FUNC unicode_conv_to_printable2(uni_stat_t *stats, const char *src, unsigned width, int flags)
{
    char *dst;
    unsigned dst_len;
    unsigned uni_count;
    unsigned uni_width;
​
    if (unicode_status != UNICODE_ON) {
        char *d;
        if (flags &amp; UNI_FLAG_PAD) {
            d = dst = xmalloc(width + 1);
            while ((int)--width &gt;= 0) {
                unsigned char c = *src;
                if (c == '\0') {
                    do
                        *d++ = ' ';
                    while ((int)--width &gt;= 0);
                    break;
                }
                // 改了这个！！！把后面小于0x7F的部分删掉
                *d++ = (c &gt;= ' ') ? c : '?';
                src++;
            }
            *d = '\0';
        } else {
            d = dst = xstrndup(src, width);
            while (*d) {
                unsigned char c = *d;
                if (c &lt; ' ' || c &gt;= 0x7f)
                    *d = '?';
                d++;
            }
        }
        if (stats) {
            stats-&gt;byte_count = (d - dst);
            stats-&gt;unicode_count = (d - dst);
            stats-&gt;unicode_width = (d - dst);
        }
        return dst;
    }
    ...</code></pre>
    <p>
     然后就是尝试编译了
    </p>
    <pre>make  ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- defconfig</pre>
    <p>
     我们还需要图形化微操。第一个事情是检查——检查我们是动态库编译：
    </p>
    <p>
     <img alt="" height="625" src="https://i-blog.csdnimg.cn/direct/c0319592837849ac9d37cf0a5271fb62.png" width="1433"/>
    </p>
    <p>
     第二个事情是使用vi风格的命令行
    </p>
    <p>
     <img alt="" height="603" src="https://i-blog.csdnimg.cn/direct/dca0c819dc5f4ae7af863d2f69edff7a.png" width="1383"/>
    </p>
    <p>
     第三个事情是采取比较全面的编译
    </p>
    <p>
     <img alt="" height="604" src="https://i-blog.csdnimg.cn/direct/3e24b24bb319485fbe74334a1506b197.png" width="1386"/>
    </p>
    <p>
     以及确保我们的mdev是选中的
    </p>
    <p>
     <img alt="" height="603" src="https://i-blog.csdnimg.cn/direct/b2e2bda6352f4b9ca51a6e335abaccca.png" width="1384"/>
    </p>
    <p>
     最后使能Unicode
    </p>
    <p>
     <img alt="" height="602" src="https://i-blog.csdnimg.cn/direct/ab02453b25aa4422b554e979b6fe0536.png" width="1383"/>
    </p>
    <pre>make  ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12
make  ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- CONFIG_PREFIX=/home/charliechen/linux/nfs/rootfs install</pre>
    <p>
     install的时候，需要安装到我们挂载nfs的位置上
    </p>
    <h3 id="%E6%B7%BB%E5%8A%A0lib%E5%BA%93" name="%E6%B7%BB%E5%8A%A0lib%E5%BA%93">
     添加lib库
    </h3>
    <p>
     原本的rootfs非常稀少，需要我们自己添加lib，我们把编译器中使用到的库复制粘贴一下：
    </p>
    <p>
     先进入自己家的arm-gcc下的
     <code>
      arm-linux-gnueabihf/libc/lib
     </code>
     ，拷贝所有的库
    </p>
    <pre>cp *so* *.a /home/charliechen/linux/nfs/rootfs/lib/ -d </pre>
    <p>
     以及
     <code>
      arm-linux-gnueabihf/lib
     </code>
    </p>
    <pre>cp *so* *.a /home/charliechen/linux/nfs/rootfs/lib/ -d </pre>
    <p>
     我们在rootfs下的usr目录下新建一个lib目录，然后到
     <code>
      arm-linux-gnueabihf/libc/usr/lib
     </code>
     下拷贝
    </p>
    <pre>cp *so* *.a /home/charliechen/linux/nfs/rootfs/usr/lib/ -d </pre>
    <pre>charliechen@ubuntu:~/linux/nfs/rootfs$ du lib usr/lib/ -sh
59M lib
67M usr/lib/</pre>
    <p>
     OK，我们下一步就是设置一下板子的bootargs
    </p>
    <pre>bootargs=console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.137.10:/home/charliechen/linux/nfs/rootfs,proto=tcp rw ip=192.168.137.4:192.168.137.10:192.168.137.1:255.255.255.0::eth0:off</pre>
    <p>
     Documentation/filesystems/nfs/nfsroot.txt下是有告诉你如何如何使用nfs挂载的，笔者这里整理一下：
    </p>
    <pre>root=/dev/nfs nfsroot=[服务器IP]:[根文件系统路径],[NFS 选项] ip=[客户端IP]:[服务器IP]:[网关IP]:[子网掩码]:[主机名]:[设备]:[自动配置]:[DNS0]:[DNS1]</pre>
    <ul>
     <li>
      <p>
       服务器 IP 地址是存放根文件系统的主机 IP，例如 我的就是Ubuntu嘛！192.168.137.10，麻烦自己在ubuntu主机上ifconfig一下
      </p>
     </li>
     <li>
      <p>
       根文件系统的存放路径例，笔者的是 /home/charliechen/linux/nfs/rootfs。
      </p>
     </li>
     <li>
      <p>
       NFS 选项一般不设置，但是这里我们强调使用proto=tcp rw，表达使用TCP协议来完成挂载
      </p>
     </li>
     <li>
      <p>
       客户端 IP 地址是开发板的 IP，需与服务器同一网段，且未被占用，我选择了 192.168.137.4，这个IP有没有效，很简单，跑到主机上ping一下，
       <strong>
        要求是没有人应答，说明没有人占用这个IP，这个IP就可以被分配到板子上
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       网关地址，参考我咋搞uboot的，这里沿用 192.168.137.1。
      </p>
     </li>
     <li>
      <p>
       子网掩码例如 255.255.255.0。
      </p>
     </li>
     <li>
      <p>
       主机名一般不设置，可留空。
      </p>
     </li>
     <li>
      <p>
       设备名是网卡名称，例如 eth0、eth1。本例中使用 ENET2，对应 eth0。
      </p>
     </li>
     <li>
      <p>
       自动配置一般设为 off。
      </p>
     </li>
     <li>
      <p>
       DNS 服务器 IP 一般不使用，可留空。
      </p>
     </li>
    </ul>
    <p>
     完事，启动一下
    </p>
    <p>
     <img alt="" height="491" src="https://i-blog.csdnimg.cn/direct/d375e0c4ca4e44afb40fe47fe95949c4.png" width="1316"/>
    </p>
    <p>
     Oh，出现这个问题了，需要我们补充一下rcS
    </p>
    <pre>#!/bin/sh
​
PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib
export PATH LD_LIBRARY_PATH
mount -a
mkdir -p /dev/pts
mount -t devpts devpts /dev/pts
​
echo /sbin/mdev &gt; /proc/sys/kernel/hotplug
mdev -s</pre>
    <p>
     我们很快还有了新的错误，一个个来
    </p>
    <pre>mount: can't read '/etc/fstab': No such file or directory
/etc/init.d/rcS: line 10: can't create /proc/sys/kernel/hotplug: nonexistent directory
mdev: /sys/dev: No such file or directory
​</pre>
    <h3 id="%E5%88%9B%E5%BB%BAfstab%E6%96%87%E4%BB%B6" name="%E5%88%9B%E5%BB%BAfstab%E6%96%87%E4%BB%B6">
     创建fstab文件
    </h3>
    <p>
     这个笔者跟之有交集是很早的事情了，当时沉迷Arch，就因为这个文件把系统搞崩过，这个文件实际上就是告知自动挂载的分区
    </p>
    <p>
     创建/etc/fstab文件
    </p>
    <pre>proc    /proc   proc    defaults    0   0
tmpfs   /tmp    tmpfs   defaults    0   0
sysfs   /sys    sysfs   defaults    0   0</pre>
    <h3 id="%E5%88%9B%E5%BB%BA%2Fetc%2Finittab%E6%96%87%E4%BB%B6" name="%E5%88%9B%E5%BB%BA%2Fetc%2Finittab%E6%96%87%E4%BB%B6">
     创建/etc/inittab文件
    </h3>
    <p>
     init 程序会读取/etc/inittab这个文件做一些事情，我们也要这样做。
    </p>
    <pre>::sysinit:/etc/init.d/rcS
console::askfirst:-/bin/sh
::restart:/sbin/init
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
::shutdown:/sbin/swapoff -a</pre>
    <h3 id="%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9D%BF%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%8B" name="%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9D%BF%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%8B">
     启动开发板检查一下
    </h3>
    <pre>VFS: Mounted root (nfs filesystem) on device 0:15.
devtmpfs: mounted
Freeing unused kernel memory: 400K (8090e000 - 80972000)
​
Please press Enter to activate this console. 
/ # 
​</pre>
    <p>
     没有问题，我们下面做其他测试
    </p>
    <h3 id="%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B7%91" name="%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B7%91">
     测试一下程序能不能跑
    </h3>
    <pre>#include &lt;stdio.h&gt; 
   
int main(void) 
{ 
    while(1) { 
        printf("Hello!!! My Really Tiny Linux!!!\r\n"); 
        sleep(2); 
    } 
    return 0; 
}</pre>
    <pre>charliechen@ubuntu:~/IMX6ULL_Programming_Code/test/rfs$ arm-linux-gnueabihf-gcc hello.c -o hello
charliechen@ubuntu:~/IMX6ULL_Programming_Code/test/rfs$ ls
hello  hello.c
charliechen@ubuntu:~/IMX6ULL_Programming_Code/test/rfs$ file hello
hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 2.6.31, BuildID[sha1]=93e70461bd94c25c5d7aa8a1663265cbc753f128, not stripped</pre>
    <p>
     测试一下
    </p>
    <pre>/ # ls
bin      etc      lib      mnt      root     sys      usr
dev      hello    linuxrc  proc     sbin     tmp
/ # ./hello 
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
Hello!!! My Really Tiny Linux!!!
​</pre>
    <h3 id="%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B%E4%B8%AD%E6%96%87" name="%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B%E4%B8%AD%E6%96%87">
     测试一下中文
    </h3>
    <pre>/ # mkdir 你好！
/ # ls
bin        etc        linuxrc    proc       sbin       tmp        你好！
dev        lib        mnt        root       sys        usr
/ 
/ # cd 你好！
/你好！ # ls
/你好！ # cd ..
/ # ls
bin        etc        linuxrc    proc       sbin       tmp        你好！
dev        lib        mnt        root       sys        usr</pre>
    <p>
     OK,基本完事了！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f636861726c69653131343531343139312f:61727469636c652f64657461696c732f313436313239313934" class_="artid" style="display:none">
 </p>
</div>


