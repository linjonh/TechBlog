---
layout: post
title: "Spring-事务和事务传播机制"
date: 2025-03-10 22:52:04 +0800
description: "NESTED 是如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行，所以说 A 和 B 不是同一个事务，那么当 B 的一个方法出现异常时进行回滚，另一个 A 调用的方法是不受影响的，也印证了这两个不是同一个事务，确实是创建了一个嵌套事务。一个事务的操作流程包括了，开启事务，执行事务操作，提交事务或回滚事务，对于回滚事务来说，如果程序在执行过程中出现了错误，那么此时就需要执行回滚事务。此时就是无论 A 有没有事务， B 都新创建事务，所以当 B 的一个方法有异常时，是不会影响其他方法的。"
keywords: "Spring 事务和事务传播机制"
categories: ['面试', '阿里巴巴', '学习路线']
tags: ['Spring', 'Java', 'Android']
artid: "146166170"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146166170
    alt: "Spring-事务和事务传播机制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146166170
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146166170
cover: https://bing.ee123.net/img/rand?artid=146166170
image: https://bing.ee123.net/img/rand?artid=146166170
img: https://bing.ee123.net/img/rand?artid=146166170
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring 事务和事务传播机制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="1__4">
     </a>
     1. 事务的回顾
    </h3>
    <p>
     在 MySQL 学习阶段，已经了解到了事务是一组操作的集合，也就是把所有的操作作为一个整体，一起向数据库提交或者撤销操作，要么同时成功，要么同时失败
    </p>
    <p>
     一个事务的操作流程包括了，开启事务，执行事务操作，提交事务或回滚事务，对于回滚事务来说，如果程序在执行过程中出现了错误，那么此时就需要执行回滚事务
    </p>
    <h3>
     <a id="2__11">
     </a>
     2. 事务的实现方式
    </h3>
    <h4>
     <a id="21__14">
     </a>
     2.1. 编程式事务
    </h4>
    <p>
     Spring 手动操作事务和 MySQL 操作事务类似，也是分为开启事务，提交事务，回滚事务等三个操作，需要用到 DataSourceTransactionManager （事务管理器）来进行上述事务的操作，还需要用到 TransactionDefinition（事务的属性，获取事务时需要把这个类的对象传进去）
    </p>
    <pre><code>@RestController
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;

    @Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;

    @Autowired
    private TransactionDefinition transactionDefinition;

    @RequestMapping("/registy")
    public String registy(String name, String password) {
        //开启事务，获取一个状态，之后回滚就回滚到了这个状态
        TransactionStatus transaction = dataSourceTransactionManager.getTransaction(transactionDefinition);
        Integer reuslt = userService.insert(name, password);
        //提交事务（提交的是之前获取的状态）
        dataSourceTransactionManager.commit(transaction);
        return "注册成功";
    }
}
</code></pre>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/049eca6784df88a0f7fd636f6d812036.png"/>
    </p>
    <p>
     测试之后数据也是正常更新了
    </p>
    <p>
     回滚的话调用的是 rollback 方法，再次进行插入数据，数据就没有更新，不过自增 id 还是变成了 3，对比提交事务的日志可以看出，这次没有提交事务的信息了
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/54fdf48e1d1b6ab48bf0fa116b67e088.png"/>
    </p>
    <h4>
     <a id="22__49">
     </a>
     2.2. 声明式事务
    </h4>
    <p>
     上面的方式是比较麻烦的，需要自己写一大堆信息，来看声明式事务是如何操作的
    </p>
    <p>
     首先需要添加依赖：
    </p>
    <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
    <p>
     只需在要执行的方法上添加
     <code>
      @Transactional
     </code>
     注解，添加之后，如果没有发生异常就正常执行，如果发生了异常就回滚事务
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/4870bc50eb13e54f21eba36dc6da5f0e.png"/>
    </p>
    <p>
     来看异常的情况：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c31dfe3d354f900ddf68cef995ceb57d.png"/>
    </p>
    <p>
     这时事务就没有提交，进行了回滚
    </p>
    <h3>
     <a id="3_Transactional_70">
     </a>
     3. @Transactional
    </h3>
    <p>
     <code>
      @Transactional
     </code>
     可以用来修饰方法或类，修饰方法时，只有修饰 public 方法时才生效，修饰其他方法时不会报错，但也不生效，修饰类时，对该类中所有的 public 方法都生效
    </p>
    <p>
     在目标方法执行开始之前会自动开启事务，执行结束之后会自动提交事务，如果方法执行过程中出现异常且异常未被捕获，就进行事务回滚操作
    </p>
    <p>
     例如，把上面的异常代码 catch 起来，事务就正常提交了
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/4683dad51bf4b155e41db16a84c49990.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c8e309cc2230bd73069e6ae4bf2317fb.png"/>
    </p>
    <p>
     但是如果捕获之后又进行抛出，那么事务还是会回滚的
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/461754f95f1d372957efbc427da1487e.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/586f02083caec348fce4a4450f94e1d6.png"/>
    </p>
    <p>
     还可以通过调用 setRollbackOnly 方法进行手动回滚
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/f9a309168113b5dee06418208a04fa80.png"/>
    </p>
    <p>
     这样的话把异常捕获之后还可以回滚事务
    </p>
    <h4>
     <a id="31_rollbackFor_95">
     </a>
     3.1. rollbackFor
    </h4>
    <p>
     <code>
      @Transactional
     </code>
     默认只在遇到 RuntimeException 和 Error 时才进行回滚，非运行时异常就不会滚，来演示一下发生非运行异常时的情况：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/87d3adc213c0720132e7fab623df23b9.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a68f68b9a8ece16832cc8dfb65051acd.png"/>
    </p>
    <p>
     虽然此时抛出了异常，但是事务还是提交了，并没有进行回滚，可以通过设置
     <code>
      @Transactional
     </code>
     注解的 rollbackFor 属性来指定那些异常要回滚
    </p>
    <p>
     把 rollbackFor 设置为 Exception.class，表示 Exception 底下的子类异常都会发生回滚
    </p>
    <pre><code>@Transactional(rollbackFor = Exception.class)
@RequestMapping("/r3")
public String r3(String name, String password) throws IOException {
    Integer reuslt = userService.insert(name, password);
    if (true) {
        throw new IOException();
    }
    return "注册成功";
}
</code></pre>
    <p>
     此时再次测试，事务就回滚了
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/dd9391d00618247a6b634b535cc50f85.png"/>
    </p>
    <h4>
     <a id="32_isolation_121">
     </a>
     3.2. isolation
    </h4>
    <p>
     <code>
      @Transactional
     </code>
     注解的 isolation 属性是可以设置事务的隔离级别的，参数类型是一个 Isolation 的枚举类，依次表示当前数据库默认使用的隔离级别和事务的四种隔离级别
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/6a8177b80bdf5c8d06b5e55a1462561a.png"/>
    </p>
    <p>
     可以根据需要进行设置
    </p>
    <pre><code>//设置事务的隔离级别
@Transactional(isolation = Isolation.DEFAULT)
@RequestMapping("/r4")
public String r4(String name, String password) throws IOException {
    Integer reuslt = userService.insert(name, password);
    if (true) {
        throw new IOException();
    }
    return "注册成功";
}
</code></pre>
    <h3>
     <a id="4__140">
     </a>
     4. 事务传播机制
    </h3>
    <p>
     事务传播机制是指在多个事务方法相互调用时，定义事务如何在这些方法之间传播的规则，也就是延用调用方法的事务还是再重新开启一个新事务
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/3f589e5f7a4dad56dbe9f1593867016c.png"/>
    </p>
    <p>
     Spring 事务的传播机制有以下七种
    </p>
    <p>
     <strong>
      事务传播机制
     </strong>
    </p>
    <p>
     <strong>
      描述
     </strong>
    </p>
    <p>
     <strong>
      理解（有 A,B 两个方法，A 调用 B 对于 B 来说）
     </strong>
    </p>
    <ol>
     <li>
      Propagation.REQUIRED
     </li>
    </ol>
    <p>
     默认的事务传播级别。如果当前存在事务，则加入该事务。如果当前没有事务，则创建一个新的事务。
    </p>
    <p>
     A 有事务就用 A 的，没有 B 就再开启新的
    </p>
    <ol>
     <li>
      Propagation.SUPPORTS
     </li>
    </ol>
    <p>
     如果当前存在事务，则加入该事务。如果当前没有事务，则以非事务的方式继续运行。
    </p>
    <p>
     A 没有事务就算了，B 就按照没有事务的方式执行
    </p>
    <ol>
     <li>
      Propagation.MANDATORY
     </li>
    </ol>
    <p>
     如果当前存在事务，则加入该事务。如果当前没有事务，则抛出异常。
    </p>
    <p>
     如果 A 没有事务，就抛出异常
    </p>
    <ol>
     <li>
      Propagation.REQUIRES_NEW
     </li>
    </ol>
    <p>
     如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。
    </p>
    <p>
     不管 A 有没有事务，B 都要开启新事务
    </p>
    <ol>
     <li>
      Propagation.NOT_SUPPORTED
     </li>
    </ol>
    <p>
     以非事务方式运行，如果当前存在事务，则把当前事务挂起（不用）。
    </p>
    <p>
     不管 A 有没有事务，B 都以非事务方式执行
    </p>
    <ol>
     <li>
      Propagation.NEVER
     </li>
    </ol>
    <p>
     以非事务方式运行，如果当前存在事务，则抛出异常。
    </p>
    <p>
     B 以非事务方式执行，如果 A 有事务就抛出异常
    </p>
    <ol>
     <li>
      Propagation.NESTED
     </li>
    </ol>
    <p>
     如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED。
    </p>
    <p>
     如果 A 有事务，B 就创建一个嵌套事务，如果没有就创建新的
    </p>
    <h4>
     <a id="41_REQUIRED_197">
     </a>
     4.1. REQUIRED
    </h4>
    <p>
     把 UserService 和 LogService 的两个方法都设置为 REQUIRED
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/ece53d68c53eab524daad5d57139b8a3.png"/>
    </p>
    <pre><code>@Slf4j
@RestController
@RequestMapping("/propaga")
public class PropagationController {
    @Autowired
    private UserService userService;
    @Autowired
    private LogService logService;

    @Transactional
    @RequestMapping("/r1")
    public String registy(String name, String password) {
        userService.insert(name, password);
        logService.insertLog(name,"用户注册");
        return "注册成功";
    }
}
</code></pre>
    <p>
     在 PropagationController 中进行调用，此时 registy 就相当于 A ，调用的两个方法相当于 B，运行之后，如果其中一个方法发生异常，那么 registy 方法的整个事务都会回滚，也就是他们都用的是 A 的事务
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/09e390b6f7c539438b634ef246938185.png"/>
    </p>
    <h4>
     <a id="42_REQUIRES_NEW_225">
     </a>
     4.2. REQUIRES_NEW
    </h4>
    <p>
     把 UserService 和 LogService 的两个方法都设置为 REQUIRES_NEW
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/47a720b6c34db05a06e5076514e39eec.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/ca22384a6887948399929d2b3c3f7393.png"/>
    </p>
    <p>
     此时就是无论 A 有没有事务， B 都新创建事务，所以当 B 的一个方法有异常时，是不会影响其他方法的
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/d1c2112869b8faf5cd5edb5d7c52f14d.png"/>
    </p>
    <h4>
     <a id="43_NEVER_237">
     </a>
     4.3. NEVER
    </h4>
    <p>
     如果设置为 NEVER 的话，A 调用 B，A 如果存在事务，就会报错
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/7cd498bb2c08eb3a1ed26c7f975f716a.png"/>
    </p>
    <p>
     把 A 的事务取消掉就不会报错了
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/222e96f6f447037d23cb3a87298f90e1.png"/>
    </p>
    <h4>
     <a id="44_NESTED_247">
     </a>
     4.4. NESTED
    </h4>
    <p>
     NESTED 是如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行，所以说 A 和 B 不是同一个事务，那么当 B 的一个方法出现异常时进行回滚，另一个 A 调用的方法是不受影响的，也印证了这两个不是同一个事务，确实是创建了一个嵌套事务
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/ac16c427e025c6c3693514ecd53cfa1e.png"/>
    </p>
    <p>
     和 REQUIRED 不同的是，那里用的是同一个事务，其中一个回滚，都要回滚，这里可以只是自己的事务进行回滚，也就是实现局部回滚
    </p>
    <p>
     <a href="https://blog.csdn.net/2202_76097976type=lately" title="主页">
      主页
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343832353639392f:61727469636c652f64657461696c732f313436313636313730" class_="artid" style="display:none">
 </p>
</div>


