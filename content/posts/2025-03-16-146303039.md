---
layout: post
title: "SpringBoot启动过程有哪些步骤源码详细分析"
date: 2025-03-16 23:34:00 +0800
description: "构造SpringApplication对象->调用run方法（准备Environment-打印Banner->创建Spring容器->预处理Spring容器->刷新Spring容器。下面构建完SpringApplication之后开始调用run方法，在这个过程中，又会做哪些事情呢，咱们接着往下看。，用于在应用启动的早期阶段（如配置中心加载）注册组件。这些监听器用于响应应用事件（如上下文启动、失败等）。：干预 Bean 的创建过程（如 AOP 代理）。方法，用于启动后执行自定义逻辑（如数据初始化）。"
keywords: "SpringBoot启动过程有哪些步骤（源码详细分析）"
categories: ['Spring']
tags: ['Spring', 'Spring', 'Java', 'Boot']
artid: "146303039"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146303039
    alt: "SpringBoot启动过程有哪些步骤源码详细分析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146303039
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146303039
cover: https://bing.ee123.net/img/rand?artid=146303039
image: https://bing.ee123.net/img/rand?artid=146303039
img: https://bing.ee123.net/img/rand?artid=146303039
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringBoot启动过程有哪些步骤（源码详细分析）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <ol>
     <li>
      <h4>
       <strong>
        构造SpringApplication对象
       </strong>
      </h4>
     </li>
    </ol>
    <p>
     我们从这里开始源码的解读
    </p>
    <p>
     <img alt="" height="245" src="https://i-blog.csdnimg.cn/direct/5d924cbb14844c4ba5b0bf1b3ae5bf22.png" width="1042"/>
    </p>
    <p>
     通过run方法会生成一个
     <strong>
      SpringApplication对象
     </strong>
    </p>
    <pre><code class="language-java">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}</code></pre>
    <p>
     我们进入s
     <strong>
      pringApplication方法里面，
     </strong>
     接着往下看，这个对象在构造的过程中做了哪些事情？
    </p>
    <pre><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, "PrimarySources must not be null");
//表示传入的配置类
		this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
//1.推测web应用类型（NONE,PEACTIVE,SERVLET）
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
//2.从spring.factories中获取BootstrapRegistryInitializer对象
		this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();
//3.从spring.factories中获取ApplicationContextInitializer对象
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
//4.从spring.factories中获取ApplicationListener对象 监听事件 
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
//5.推测出Main类（main()方法所在的类）
		this.mainApplicationClass = deduceMainApplicationClass();
	}

	private List&lt;BootstrapRegistryInitializer&gt; getBootstrapRegistryInitializersFromSpringFactories() {
		ArrayList&lt;BootstrapRegistryInitializer&gt; initializers = new ArrayList&lt;&gt;();
		getSpringFactoriesInstances(Bootstrapper.class).stream()
				.map((bootstrapper) -&gt; ((BootstrapRegistryInitializer) bootstrapper::initialize))
				.forEach(initializers::add);
		initializers.addAll(getSpringFactoriesInstances(BootstrapRegistryInitializer.class));
		return initializers;
	}</code></pre>
    <blockquote>
     <ol>
      <li>
       <p>
        <strong>
         推断应用类型：
         <code>
          this.webApplicationType = WebApplicationType.deduceFromClasspath()
         </code>
        </strong>
       </p>
       <ul>
        <li>
         <p>
          通过类路径判断应用类型：
         </p>
         <ul>
          <li>
           <p>
            <span style="color:#fe2c24">
             <strong>
              <code>
               SERVLET
              </code>
             </strong>
             ：存在 Servlet API 和
             <code>
              DispatcherServlet
             </code>
             （传统 Spring MVC）。
            </span>
           </p>
          </li>
          <li>
           <p>
            <span style="color:#fe2c24">
             <strong>
              <code>
               REACTIVE
              </code>
             </strong>
             ：存在 Spring WebFlux 的
             <code>
              DispatcherHandler
             </code>
             。
            </span>
           </p>
          </li>
          <li>
           <p>
            <span style="color:#fe2c24">
             <strong>
              <code>
               NONE
              </code>
             </strong>
             ：非 Web 应用。
            </span>
           </p>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         加载引导注册初始化器：
         <code>
          this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories()
         </code>
        </strong>
       </p>
       <ul>
        <li>
         <p>
          从
          <code>
           META-INF/spring.factories
          </code>
          加载
          <code>
           BootstrapRegistryInitializer
          </code>
          实现类。
         </p>
        </li>
        <li>
         <p>
          <span style="color:#fe2c24">
           用于在引导阶段（如配置中心加载）注册自定义组件
          </span>
          。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         设置初始化器：
         <code>
          setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class))
         </code>
        </strong>
       </p>
       <ul>
        <li>
         <p>
          通过
          <code>
           SpringFactoriesLoader
          </code>
          加载所有
          <code>
           ApplicationContextInitializer
          </code>
          实现类并实例化。
         </p>
        </li>
        <li>
         <p>
          这些初始化器会在
          <code>
           ApplicationContext
          </code>
          刷新前执行（如修改环境变量、注册 Bean）。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         设置监听器：
         <code>
          setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))
         </code>
        </strong>
       </p>
       <ul>
        <li>
         <p>
          加载所有
          <code>
           ApplicationListener
          </code>
          实现类并实例化。
         </p>
        </li>
        <li>
         <p>
          这些监听器用于响应应用事件（如上下文启动、失败等）。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         推断主应用类：
         <code>
          this.mainApplicationClass = deduceMainApplicationClass()
         </code>
        </strong>
       </p>
       <ul>
        <li>
         <p>
          通过分析调用栈找到包含
          <code>
           main
          </code>
          方法的类（即启动类）。
         </p>
        </li>
        <li>
         <p>
          用于日志输出或某些需要主类的场景。
         </p>
        </li>
       </ul>
      </li>
     </ol>
     <p>
     </p>
    </blockquote>
    <p>
     以上是构建SpringApplication所需要完成的一些事情
    </p>
    <p>
     下面构建完SpringApplication之后开始调用run方法，在这个过程中，又会做哪些事情呢，咱们接着往下看
    </p>
    <pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
//1.创建引导启动器，类似一个SpplicationContext，可以往里面添加一些对象，后续过程中（刷新）
		DefaultBootstrapContext bootstrapContext = createBootstrapContext();
		ConfigurableApplicationContext context = null;
		configureHeadlessProperty();
//2.从spring.factories中获取SpringApplicationRunListeners对象
//默认会拿到一个EventPoblishingRunListener，它会启动过程的各个阶段发布对应的Application
		SpringApplicationRunListeners listeners = getRunListeners(args);
3.发布ApplicationStartingEvent
		listeners.starting(bootstrapContext, this.mainApplicationClass);
		try {
//4.将run()的参数封装为DefaultApplicationArguments对象
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
//5.准备Environment
//将包括操作系统，JVM，ServletContext,properties,yaml，Ncos等等配置放入这个对象，是典型的key，value格式
//会发布一个ConfigurableEnvironmentPreParedEvent事件，表示环境已经准备好了，
			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
//默认spring.beaninfo.ignore=true,表示不需要jkd缓存beanInfo信息，Spring自己会缓存
			configureIgnoreBeanInfo(environment);
//打印Banner图片
			Banner printedBanner = printBanner(environment);
//6.根据类型创建Spring容器
			context = createApplicationContext();
			context.setApplicationStartup(this.applicationStartup);
//预处理Spring容器：
//7.利用SpringApplicationContextInitaializer初始化Spring容器
//8.发布SpringApplicationContextInitaializerEvent
//9.关闭DefaultBootstrapContext
//10.注册primarySources类，就是run方法存入进来的配置类
//11.发布ApplicationPreparedEvent事件，表示Spring容器已经准备好了
			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
//12.启动Spring容器，会解析配置类，扫描，启动WebServer,比如tomcat
			refreshContext(context);
//空方法，可以重新这个方法，完成自己的一些扩展
			afterRefresh(context, applicationArguments);
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
13.发布ApplicationStartedEvent，表示Spring容器已经启动
			listeners.started(context);
//14.从Spring容器中获取ApplicationRunner和ConmmandLinneRunner,并执行其run方法
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
//15.如果出现失败，会发布ApplicationFailedRvent事件，
			handleRunFailure(context, ex, listeners);
			throw new IllegalStateException(ex);
		}
	try {
			listeners.running(context);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, null);
			throw new IllegalStateException(ex);
		}
		return context;</code></pre>
    <p>
     <span style="color:#1c7331">
      <strong>
       以下具体分析解释：
      </strong>
     </span>
    </p>
    <h5>
     <strong>
      1. 启动计时与监控
     </strong>
    </h5>
    <pre><code class="language-java">StopWatch stopWatch = new StopWatch();
stopWatch.start();</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：使用
       <code>
        StopWatch
       </code>
       记录应用启动耗时，用于后续日志输出。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      2. 初始化引导上下文
     </strong>
    </h5>
    <pre><code class="language-java">DefaultBootstrapContext bootstrapContext = createBootstrapContext();</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：创建
       <code>
        BootstrapContext
       </code>
       ，用于在应用启动的早期阶段（如配置中心加载）注册组件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        底层机制
       </strong>
       ：通过
       <code>
        BootstrapRegistryInitializer
       </code>
       实现自定义初始化逻辑（如加载外部配置）。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      3. 配置 Headless 模式
     </strong>
    </h5>
    <pre><code class="language-java">configureHeadlessProperty();</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：强制设置
       <code>
        java.awt.headless=true
       </code>
       ，即使服务器没有图形界面或显示设备，也能正常运行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        适用场景
       </strong>
       ：处理图像生成、字体计算等操作（如 PDF 导出）。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      4. 获取并触发启动监听器
     </strong>
    </h5>
    <pre><code class="language-java">SpringApplicationRunListeners listeners = getRunListeners(args);
listeners.starting(bootstrapContext, this.mainApplicationClass);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         getRunListeners
        </code>
       </strong>
       ：从
       <code>
        META-INF/spring.factories
       </code>
       加载所有
       <code>
        SpringApplicationRunListener
       </code>
       实现类（如
       <code>
        EventPublishingRunListener
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         listeners.starting()
        </code>
       </strong>
       ：触发
       <code>
        ApplicationStartingEvent
       </code>
       事件，通知监听器应用开始启动。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      5. 准备应用环境
     </strong>
    </h5>
    <pre><code class="language-java">ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         ApplicationArguments
        </code>
       </strong>
       ：封装命令行参数（
       <code>
        --key=value
       </code>
       格式），提供便捷的访问接口。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         prepareEnvironment
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         创建
         <code>
          ConfigurableEnvironment
         </code>
         （如
         <code>
          StandardServletEnvironment
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         加载配置文件（
         <code>
          application.properties
         </code>
         /
         <code>
          application.yml
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         触发
         <code>
          ApplicationEnvironmentPreparedEvent
         </code>
         事件，允许监听器修改环境配置（如
         <code>
          ConfigFileApplicationListener
         </code>
         加载配置文件）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      6. 忽略 BeanInfo 类
     </strong>
    </h5>
    <pre><code class="language-java">configureIgnoreBeanInfo(environment);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：跳过对
       <code>
        BeanInfo
       </code>
       类的扫描，避免某些 JDK 类的元数据解析问题（如
       <code>
        java.beans.Introspector
       </code>
       ）。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      7. 打印 Banner
     </strong>
    </h5>
    <pre><code class="language-java">Banner printedBanner = printBanner(environment);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：根据配置输出启动 Banner（默认或自定义），可通过
       <code>
        spring.banner.location
       </code>
       指定 Banner 文件。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      8. 创建应用上下文
     </strong>
    </h5>
    <pre><code class="language-java">context = createApplicationContext();</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        根据应用类型
       </strong>
       （Servlet/Reactive/None）创建对应的
       <code>
        ConfigurableApplicationContext
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Servlet
         </strong>
         ：
         <code>
          AnnotationConfigServletWebServerApplicationContext
         </code>
        </p>
       </li>
       <li>
        <p>
         <strong>
          Reactive
         </strong>
         ：
         <code>
          AnnotationConfigReactiveWebServerApplicationContext
         </code>
        </p>
       </li>
       <li>
        <p>
         <strong>
          None
         </strong>
         ：
         <code>
          AnnotationConfigApplicationContext
         </code>
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      9. 准备上下文
     </strong>
    </h5>
    <pre><code class="language-java">prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        关键操作
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         将
         <code>
          Environment
         </code>
         绑定到上下文。
        </p>
       </li>
       <li>
        <p>
         执行
         <code>
          ApplicationContextInitializer
         </code>
         初始化器（如设置上下文 ID、注册 Bean）。
        </p>
       </li>
       <li>
        <p>
         触发
         <code>
          ApplicationContextInitializedEvent
         </code>
         事件。
        </p>
       </li>
       <li>
        <p>
         注册主配置类（
         <code>
          primarySources
         </code>
         ）和命令行参数 Bean。
        </p>
       </li>
       <li>
        <p>
         加载所有
         <code>
          BeanDefinitionLoader
         </code>
         （如主类、XML 配置等）。
        </p>
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      10. 刷新上下文（核心步骤）
     </strong>
    </h5>
    <pre><code class="language-java">refreshContext(context);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：调用
       <code>
        AbstractApplicationContext.refresh()
       </code>
       ，完成 Spring 容器的初始化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关键子流程
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         <strong>
          准备 BeanFactory
         </strong>
         ：注册必要的 Bean（如
         <code>
          environment
         </code>
         、
         <code>
          applicationArguments
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          执行
          <code>
           BeanFactoryPostProcessor
          </code>
         </strong>
         ：处理配置类的解析（如
         <code>
          @Configuration
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          注册
          <code>
           BeanPostProcessor
          </code>
         </strong>
         ：干预 Bean 的创建过程（如 AOP 代理）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          初始化消息源、事件广播器
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          创建并初始化所有单例 Bean
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          启动 Web 服务器
         </strong>
         （如 Tomcat、Netty）。
        </p>
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      11. 启动后回调
     </strong>
    </h5>
    <pre><code class="language-java">afterRefresh(context, applicationArguments);
listeners.started(context);
callRunners(context, applicationArguments);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         afterRefresh
        </code>
       </strong>
       ：空方法，留给子类扩展。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         listeners.started()
        </code>
       </strong>
       ：触发
       <code>
        ApplicationStartedEvent
       </code>
       ，通知监听器应用已启动。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         callRunners
        </code>
       </strong>
       ：执行所有
       <code>
        ApplicationRunner
       </code>
       和
       <code>
        CommandLineRunner
       </code>
       的
       <code>
        run()
       </code>
       方法，用于启动后执行自定义逻辑（如数据初始化）。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      12. 完成启动
     </strong>
    </h5>
    <pre><code class="language-java">stopWatch.stop();
new StartupInfoLogger(...).logStarted(...);
listeners.ready(context);</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        记录启动耗时
       </strong>
       ：输出到日志。
      </p>
     </li>
     <li>
      <p>
       <strong>
        触发
        <code>
         ApplicationReadyEvent
        </code>
       </strong>
       ：通知应用已完全就绪（与
       <code>
        ApplicationStartedEvent
       </code>
       的区别在于，此时所有 Bean 已就绪）。
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      13. 异常处理
     </strong>
    </h5>
    <pre><code class="language-java">catch (Throwable ex) {
    handleRunFailure(context, ex, listeners);
    throw new IllegalStateException(ex);
}</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         handleRunFailure
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         触发
         <code>
          ApplicationFailedEvent
         </code>
         事件。
        </p>
       </li>
       <li>
        <p>
         关闭应用上下文（如果已创建）。
        </p>
       </li>
       <li>
        <p>
         输出错误日志。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     总结一下 SpringBoot启动过程步骤大致是：
    </p>
    <p>
     构造SpringApplication对象-&gt;调用run方法（准备Environment-打印Banner-&gt;创建Spring容器-&gt;预处理Spring容器-&gt;刷新Spring容器
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f67676a6b6c6e636666642f:61727469636c652f64657461696c732f313436333033303339" class_="artid" style="display:none">
 </p>
</div>


