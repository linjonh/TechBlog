---
layout: post
title: "C继承"
date: 2025-03-13 01:25:10 +0800
description: "派生类的构成必须调用基类的构造函数，但是基类的构成函数私有化以后，派生类看不见就不能调用了，那么派生类就无法实例化出对象。，则整个继承体系里面只有一个这样的成员。不想在类外直接使用，又想在派生类中被继承使用，则使用。析构函数，但是不需要显示调用基类的析构函数了，在派生类构造函数的初始化列表里面显示的调用。基类::基类成员 显示的访问基类的同名成员。基类的private成员变量。基类的private成员变量。屏蔽基类对同名成员的直接访问。protected限定保护。protected限定保护。"
keywords: "【C++】继承"
categories: ['未分类']
tags: ['C']
artid: "146056477"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146056477
    alt: "C继承"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146056477
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146056477
cover: https://bing.ee123.net/img/rand?artid=146056477
image: https://bing.ee123.net/img/rand?artid=146056477
img: https://bing.ee123.net/img/rand?artid=146056477
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【C++】继承
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     <span style="color:#0d0016">
      继承
     </span>
    </h2>
    <h3>
     <span style="color:#0d0016">
      继承定义
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1.
      </span>
      <strong>
       <span style="color:#fe2c24">
        C++面向对象有三大特性
       </span>
      </strong>
      <span style="color:#0d0016">
       ：
      </span>
      <strong>
       <span style="color:#fe2c24">
        封装
       </span>
      </strong>
      <span style="color:#0d0016">
       、
      </span>
      <strong>
       <span style="color:#fe2c24">
        继承
       </span>
      </strong>
      <span style="color:#0d0016">
       、
      </span>
      <strong>
       <span style="color:#fe2c24">
        多态
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       2.
      </span>
      <strong>
       <span style="color:#fe2c24">
        继承机制
       </span>
      </strong>
      <span style="color:#0d0016">
       可以使代码
      </span>
      <strong>
       <span style="color:#fe2c24">
        重复使用
       </span>
      </strong>
      <span style="color:#0d0016">
       ，允许在
      </span>
      <strong>
       <span style="color:#fe2c24">
        保持原有类特性
       </span>
      </strong>
      <span style="color:#0d0016">
       的基础上进行
      </span>
      <span style="color:#fe2c24">
       <strong>
        拓展
       </strong>
      </span>
      <span style="color:#0d0016">
       ，增加
      </span>
      <strong>
       <span style="color:#fe2c24">
        新的成员函数
       </span>
      </strong>
      <span style="color:#0d0016">
       或者
      </span>
      <strong>
       <span style="color:#fe2c24">
        成员变量
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
    </blockquote>
    <h3>
     <span style="color:#0d0016">
      继承的格式
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1. 下面我们看到
      </span>
      <span style="color:#fe2c24">
       <strong>
        Person
       </strong>
      </span>
      <span style="color:#0d0016">
       是
      </span>
      <span style="color:#fe2c24">
       <strong>
        基类
       </strong>
      </span>
      <span style="color:#0d0016">
       ，也称作
      </span>
      <strong>
       <span style="color:#fe2c24">
        父类
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
      <strong>
       <span style="color:#fe2c24">
        Student
       </span>
      </strong>
      <span style="color:#0d0016">
       是
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       ，也称作
      </span>
      <strong>
       <span style="color:#fe2c24">
        子类
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       2. 继承类的格式如下：
      </span>
      <strong>
       <span style="color:#fe2c24">
        class 派生类:继承方式 基类
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="355" src="https://i-blog.csdnimg.cn/direct/9924f0b4dc66498aa072e6afd5096df2.png" width="556"/>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class Students
{
public:
    void identity()
    {
        //
    }
    void studying()
    {
        //
    }
protected:
    string _name;
    string _address;
    string _tele;
    int _age;
    int _id;
};
class Teachers
{
public:
    void identity()
    {
        //
    }
    void teaching()
    {
        //
    }
private:
    string _name;
    string _address;
    string _tele;
    int _age;
    int _id;
};

//下⾯我们公共的成员都放到Person类中，Student和teacher都继承Person，就可以复⽤这些成员，就
不需要重复定义了，省去了很多⿇烦。

class Person
{
public:
    void identity()
    {
        //
    }
private:
    string _name;
    string _address;
    string _tele;
    int _age;
    int _id;
};
class Students:public Person
{
public:
    void studying()
    {
        //
    }
};
class Teachers:public Person
{
public:
    void teaching()
    {
        //
    }
};</code></pre>
    <h3>
     <span style="color:#0d0016">
      继承的方式
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1. 由于
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#0d0016">
       存在
      </span>
      <strong>
       <span style="color:#fe2c24">
        3种成员变量
       </span>
      </strong>
      <span style="color:#0d0016">
       ，而
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       也存在
      </span>
      <strong>
       <span style="color:#fe2c24">
        3种继承方式
       </span>
      </strong>
      <span style="color:#0d0016">
       ，所以存在
      </span>
      <strong>
       <span style="color:#fe2c24">
        9种不同情况
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       2.
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类的private成员变量
       </span>
      </strong>
      <span style="color:#0d0016">
       ，无论以哪种方式继承，
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类中都不可见
       </span>
      </strong>
      <span style="color:#0d0016">
       。不可见指的是：逻辑上成员变量
      </span>
      <strong>
       <span style="color:#fe2c24">
        发生了继承
       </span>
      </strong>
      <span style="color:#0d0016">
       ，但是语法上成员变量在类内、类外都
      </span>
      <strong>
       <span style="color:#fe2c24">
        不能直接使用
       </span>
      </strong>
      <span style="color:#0d0016">
       ，
      </span>
      <strong>
       <span style="color:#fe2c24">
        但是可以通过调用基类的public函数来间接使用
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       3. 如果
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类成员
       </span>
      </strong>
      <span style="color:#0d0016">
       不想在类外直接使用，又想在派生类中被继承使用，则使用
      </span>
      <strong>
       <span style="color:#fe2c24">
        protected限定保护
       </span>
      </strong>
      <span style="color:#0d0016">
       ，即
      </span>
      <strong>
       <span style="color:#fe2c24">
        protected限定保护
       </span>
      </strong>
      <span style="color:#0d0016">
       是因为
      </span>
      <strong>
       <span style="color:#fe2c24">
        继承
       </span>
      </strong>
      <span style="color:#0d0016">
       才出现的。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       4.
      </span>
      <strong>
       <span style="color:#fe2c24">
        大小规则
       </span>
      </strong>
      <span style="color:#0d0016">
       ：
      </span>
      <strong>
       <span style="color:#fe2c24">
        public&gt;protected&gt;private
       </span>
      </strong>
      <span style="color:#0d0016">
       ，除了
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类的private成员变量
       </span>
      </strong>
      <span style="color:#0d0016">
       ，其他成员变量的
      </span>
      <strong>
       <span style="color:#fe2c24">
        规则
       </span>
      </strong>
      <span style="color:#0d0016">
       ：
      </span>
      <strong>
       <span style="color:#fe2c24">
        取两者中更小的那个
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       5.
      </span>
      <span style="color:#1f2329">
       使用
      </span>
      <strong>
       <span style="color:#fe2c24">
        关键字class
       </span>
      </strong>
      <span style="color:#1f2329">
       时默认的继承方式是
      </span>
      <strong>
       <span style="color:#fe2c24">
        private
       </span>
      </strong>
      <span style="color:#1f2329">
       ，使用
      </span>
      <strong>
       <span style="color:#fe2c24">
        关键字struct
       </span>
      </strong>
      <span style="color:#1f2329">
       时默认的继承方式是
      </span>
      <strong>
       <span style="color:#fe2c24">
        public
       </span>
      </strong>
      <span style="color:#1f2329">
       ，不过最好
      </span>
      <strong>
       <span style="color:#fe2c24">
        显示的
       </span>
      </strong>
      <span style="color:#0d0016">
       写出继承方式
      </span>
      <span style="color:#1f2329">
       。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       6. 在实际运用中
      </span>
      <strong>
       <span style="color:#fe2c24">
        一般使用
       </span>
      </strong>
      <span style="color:#1f2329">
       都是
      </span>
      <strong>
       <span style="color:#fe2c24">
        public继承
       </span>
      </strong>
      <span style="color:#1f2329">
       ，几乎
      </span>
      <strong>
       <span style="color:#fe2c24">
        很少使用protetced/private继承
       </span>
      </strong>
      <span style="color:#1f2329">
       ，因为
      </span>
      <strong>
       <span style="color:#fe2c24">
        protetced/private继承
       </span>
      </strong>
      <span style="color:#1f2329">
       下来的成员都只能在派生类的
      </span>
      <strong>
       <span style="color:#fe2c24">
        类里面使用
       </span>
      </strong>
      <span style="color:#1f2329">
       ，实际中扩展维护性不强。
      </span>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="198" src="https://i-blog.csdnimg.cn/direct/407201f2059845e9a25e207e605357d8.png" width="349"/>
    </p>
    <p class="img-center">
     <img alt="" height="212" src="https://i-blog.csdnimg.cn/direct/7848fc7ea5514c3fac87804888a77d50.png" width="375"/>
    </p>
    <p class="img-center">
     <img alt="" height="292" src="https://i-blog.csdnimg.cn/direct/5b561e62da6b49b490e78589d5593506.png" width="1432"/>
    </p>
    <h3>
     <span style="color:#0d0016">
      基类和派生类的转换
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1.
      </span>
      <span style="color:#fe2c24">
       <strong>
        public继承的派生类对象
       </strong>
      </span>
      <span style="color:#1f2329">
       可以赋值给
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类的指针
       </span>
      </strong>
      <span style="color:#1f2329">
       和
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类的引用
       </span>
      </strong>
      <span style="color:#0d0016">
       ，又称之为
      </span>
      <strong>
       <span style="color:#fe2c24">
        切片
       </span>
      </strong>
      <span style="color:#1f2329">
       或者
      </span>
      <strong>
       <span style="color:#fe2c24">
        切
       </span>
      </strong>
     </p>
     <div>
      <strong>
       <span style="color:#fe2c24">
        割
       </span>
      </strong>
      <span style="color:#1f2329">
       ，寓意
      </span>
      <span style="color:#fe2c24">
       <strong>
        把派生类中基类那部分切出来
       </strong>
      </span>
      <span style="color:#1f2329">
       ，
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类指针
       </span>
      </strong>
      <span style="color:#1f2329">
       或
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类引用
       </span>
      </strong>
      <span style="color:#1f2329">
       指向的是
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类中切出来的基类那部分
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       2.
      </span>
      <span style="color:#fe2c24">
       <strong>
        基类对象不能赋值给派生类对象
       </strong>
      </span>
      <span style="color:#1f2329">
       。
      </span>
     </div>
    </blockquote>
    <p class="img-center">
     <img alt="" height="241" src="https://i-blog.csdnimg.cn/direct/be8ff63853114b349a7e7e3d37168bdf.png" width="435"/>
    </p>
    <pre><code class="language-cpp">class Person
{
protected :
    string _name; // 姓名
    string _sex; // 性别
    int _age; // 年龄
};
class Student : public Person
{
public :
    int _id; // 学号
};
int main()
{
    Student sobj;
    // 1.派⽣类对象可以赋值给基类的指针或引⽤
    Person* pp = &amp;sobj;
    Person&amp; rp = sobj;
    // 派⽣类对象可以赋值给基类的对象是通过调⽤后⾯会讲解的基类的拷⻉构造完成的
    Person pobj = sobj;
    //2.基类对象不能赋值给派⽣类对象，这⾥会编译报错
    sobj = pobj;
    return 0;
}</code></pre>
    <h2>
     <span style="color:#0d0016">
      继承中的作用域
     </span>
    </h2>
    <h3>
     <span style="color:#0d0016">
      隐藏规则
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1.
      </span>
      <span style="color:#1f2329">
       在
      </span>
      <strong>
       <span style="color:#fe2c24">
        继承
       </span>
      </strong>
      <span style="color:#1f2329">
       体系中，
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#1f2329">
       和
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#1f2329">
       都有
      </span>
      <strong>
       <span style="color:#fe2c24">
        独立的作用域
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       2.
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#1f2329">
       和
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#1f2329">
       中有
      </span>
      <strong>
       <span style="color:#fe2c24">
        同名成员
       </span>
      </strong>
      <span style="color:#1f2329">
       ，
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类成员
       </span>
      </strong>
      <span style="color:#1f2329">
       将
      </span>
      <strong>
       <span style="color:#fe2c24">
        屏蔽基类对同名成员的直接访问
       </span>
      </strong>
      <span style="color:#1f2329">
       ，这种情况叫
      </span>
      <strong>
       <span style="color:#fe2c24">
        隐藏
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </p>
     <div>
      <span style="color:#1f2329">
       3. 在
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类成员函数
       </span>
      </strong>
      <span style="color:#1f2329">
       中，可以使用
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类::基类成员 显示的访问基类的同名成员
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       4. 如果是
      </span>
      <strong>
       <span style="color:#fe2c24">
        成员函数的隐藏
       </span>
      </strong>
      <span style="color:#1f2329">
       ，只需要
      </span>
      <strong>
       <span style="color:#fe2c24">
        函数名相同
       </span>
      </strong>
      <span style="color:#1f2329">
       就构成隐藏。
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       5. 所以继承体系里面最好
      </span>
      <strong>
       <span style="color:#fe2c24">
        不要定义同名的成员
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </div>
    </blockquote>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Person
{
protected:
    int _num=1;
};
class Student:public Person
{
public:
    void Print()
    {
        cout&lt;&lt;_num&lt;&lt;endl;
    }
protected:
    int _num=11;
};
int main()
{
    Student st1;
    st1.Print();
    return 0;
}
//11</code></pre>
    <p class="img-center">
     <img alt="" height="811" src="https://i-blog.csdnimg.cn/direct/e2d3d2a4febd417e9afab5ffd13a2d1f.png" width="1348"/>
    </p>
    <h2 style="background-color:transparent">
     <span style="color:#0d0016">
      派生类的默认成员函数
     </span>
    </h2>
    <p class="img-center">
     <img alt="" height="262" src="https://i-blog.csdnimg.cn/direct/82c4e26bd6224bc1911defa84bb9b6b8.png" width="827"/>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1.
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的构造函数必须调用
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#0d0016">
       的构造函数去
      </span>
      <strong>
       <span style="color:#fe2c24">
        初始化基类
       </span>
      </strong>
      <span style="color:#0d0016">
       的那一部分成员，需要在
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       构造函数的初始化列表
      </span>
      <strong>
       <span style="color:#fe2c24">
        显式调用
       </span>
      </strong>
      <span style="color:#0d0016">
       ，
       <strong>
       </strong>
       即把
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#0d0016">
       当成
      </span>
      <strong>
       <span style="color:#fe2c24">
        一个整体
       </span>
      </strong>
      <span style="color:#0d0016">
       。此时
      </span>
      <strong>
       <span style="color:#fe2c24">
        既需要
       </span>
      </strong>
      <span style="color:#0d0016">
       写基类的构造函数，
      </span>
      <strong>
       <span style="color:#fe2c24">
        又需要
       </span>
      </strong>
      <span style="color:#0d0016">
       写派生类的构造函数，
      </span>
      <strong>
       <span style="color:#fe2c24">
        还需要
       </span>
      </strong>
      <span style="color:#0d0016">
       在派生类构造函数的初始化列表里面显示的调用。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       2.
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的拷贝构造函数
      </span>
      <span style="color:#1f2329">
       必须调用
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#0d0016">
       的拷贝构造
      </span>
      <span style="color:#1f2329">
       完成
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#0d0016">
       的那一部分成员的
      </span>
      <strong>
       <span style="color:#fe2c24">
        拷贝
       </span>
      </strong>
      <span style="color:#1f2329">
       ，
      </span>
      <span style="color:#0d0016">
       需要在
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       拷贝构造函数的初始化列表
      </span>
      <strong>
       <span style="color:#fe2c24">
        显式调用
       </span>
      </strong>
      <span style="color:#0d0016">
       ，
       <strong>
       </strong>
       即把
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类
       </span>
      </strong>
      <span style="color:#0d0016">
       当成
      </span>
      <strong>
       <span style="color:#fe2c24">
        一个整体
       </span>
      </strong>
      <span style="color:#0d0016">
       。如果
      </span>
      <strong>
       <span style="color:#fe2c24">
        没有
       </span>
      </strong>
      <span style="color:#0d0016">
       资源的开辟消耗，那么可以
      </span>
      <strong>
       <span style="color:#fe2c24">
        直接使用
       </span>
      </strong>
      <span style="color:#0d0016">
       默认拷贝构造函数，但是如果
      </span>
      <strong>
       <span style="color:#fe2c24">
        存在
       </span>
      </strong>
      <span style="color:#0d0016">
       资源的开辟消耗，那么就需要
      </span>
      <strong>
       <span style="color:#fe2c24">
        自己写
       </span>
      </strong>
      <span style="color:#0d0016">
       拷贝构造函数，
      </span>
      <strong>
       <span style="color:#fe2c24">
        像构造函数一样
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       3.
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的赋值重载函数的各种情况和
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的拷贝构造函数
      </span>
      <strong>
       <span style="color:#fe2c24">
        相同
       </span>
      </strong>
      <span style="color:#0d0016">
       ，而且
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的赋值重载函数
      </span>
      <strong>
       <span style="color:#fe2c24">
        隐藏了基类
       </span>
      </strong>
      <span style="color:#0d0016">
       的赋值重载函数，
      </span>
      <span style="color:#1f2329">
       所以
      </span>
      <strong>
       <span style="color:#fe2c24">
        显示调用基类的赋值运算符
       </span>
      </strong>
      <span style="color:#0d0016">
       时
      </span>
      <span style="color:#1f2329">
       ，需要
      </span>
      <strong>
       <span style="color:#fe2c24">
        指定基类作用域
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       4.
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的析构函数的各种情况和
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#0d0016">
       的析构函数
      </span>
      <strong>
       <span style="color:#fe2c24">
        相同
       </span>
      </strong>
      <span style="color:#0d0016">
       。如果
      </span>
      <strong>
       <span style="color:#fe2c24">
        存在
       </span>
      </strong>
      <span style="color:#0d0016">
       资源的开辟消耗，那么就需要
      </span>
      <strong>
       <span style="color:#fe2c24">
        自己写
       </span>
      </strong>
      <span style="color:#0d0016">
       析构函数，但是不需要显示调用基类的析构函数了，
      </span>
      <strong>
       <span style="color:#fe2c24">
        系统会自动调用
       </span>
      </strong>
      <span style="color:#0d0016">
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       5.
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#1f2329">
       对象初始化
      </span>
      <strong>
       <span style="color:#fe2c24">
        先调用基类构造再调派生类构造
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
      <strong>
       <span style="color:#fe2c24">
        派生类
       </span>
      </strong>
      <span style="color:#1f2329">
       对象析构清理
      </span>
      <strong>
       <span style="color:#fe2c24">
        先调用派生类析构再调基类的析构
       </span>
      </strong>
      <span style="color:#1f2329">
       。
      </span>
     </p>
    </blockquote>
    <pre><code class="language-cpp">//构造函数
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Person
{
public:
    Person(const char* name)
        :_name(name)
        {}
protected:
    string _name;
};
class Student:public Person
{
public:
    Student(int id,const char* address,const char* name)
    :_id(id)
    ,_address(address)
    ,Person(name)
    {}
protected:
    int _id;
    string _address;
};
int main()
{
    Student s1(20,"jiangxi","hsy");
    return 0;
}</code></pre>
    <p class="img-center">
     <img alt="" height="295" src="https://i-blog.csdnimg.cn/direct/755fc5bee9c542e49efe745b39f71564.png" width="840"/>
    </p>
    <h2 style="background-color:transparent">
     <span style="color:#1f2329">
      实现一个不能被继承的类
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1. 方法一：
      </span>
      <strong>
       <span style="color:#fe2c24">
        基类的构造函数私有化
       </span>
      </strong>
      <span style="color:#1f2329">
       ，派生类的构成必须调用基类的构造函数，但是基类的构成函数私有化以后，派生类看不见就不能调用了，那么派生类就无法实例化出对象。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       2. 方法二：
      </span>
      <span style="color:#fe2c24">
       <strong>
        C++11
       </strong>
      </span>
      <span style="color:#1f2329">
       新增了一个
      </span>
      <strong>
       <span style="color:#fe2c24">
        final关键字
       </span>
      </strong>
      <span style="color:#1f2329">
       ，
      </span>
      <span style="color:#1f2329">
       派生类就不能继承了。
      </span>
     </p>
    </blockquote>
    <pre><code class="language-cpp">class Person final
{
public:
    Person(const char* name)
        :_name(name)
        {}
protected:
    string _name;
};</code></pre>
    <h2 style="background-color:transparent">
     <span style="color:#0d0016">
      继承与友元
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1. 友元关系
      </span>
      <strong>
       <span style="color:#fe2c24">
        不能继承
       </span>
      </strong>
      <span style="color:#0d0016">
       ，也就是说基类友元
      </span>
      <strong>
       <span style="color:#fe2c24">
        不能访问
       </span>
      </strong>
      <span style="color:#0d0016">
       派生类私有和保护成员 。
      </span>
     </p>
    </blockquote>
    <h2 style="background-color:transparent">
     <span style="color:#0d0016">
      继承与静态成员
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#1f2329">
       1. 基类定义了
      </span>
      <span style="color:#fe2c24">
       <strong>
        static静态成员
       </strong>
      </span>
      <span style="color:#1f2329">
       ，则整个继承体系里面只有一个这样的成员。无论派生出多少个派生类，都只有一个
      </span>
      <span style="color:#fe2c24">
       <strong>
        static
       </strong>
      </span>
      <span style="color:#1f2329">
       成员实例。
      </span>
     </p>
    </blockquote>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Person
{
public:
    string _name;
    static int _count;
};
int Person::_count = 0;
class Student : public Person
{
protected:
    int _stuNum;
};
int main()
{
    Person p;
    Student s;
    // 这⾥的运⾏结果可以看到⾮静态成员_name的地址是不⼀样的
    // 说明派⽣类继承下来了，⽗派⽣类对象各有⼀份
    cout &lt;&lt; &amp;p._name &lt;&lt; endl;
    cout &lt;&lt; &amp;s._name &lt;&lt; endl;
    // 这⾥的运⾏结果可以看到静态成员_count的地址是⼀样的
    // 说明派⽣类和基类共⽤同⼀份静态成员
    cout &lt;&lt; &amp;p._count &lt;&lt; endl;
    cout &lt;&lt; &amp;s._count &lt;&lt; endl;
    // 公有的情况下，⽗派⽣类指定类域都可以访问静态成员
    cout &lt;&lt; Person::_count &lt;&lt; endl;
    cout &lt;&lt; Student::_count &lt;&lt; endl;
    return 0;
}</code></pre>
    <p>
     <img alt="" height="1290" src="https://i-blog.csdnimg.cn/direct/0af7124577be473982d7d96b66373a41.png" width="2112"/>
    </p>
    <h2 style="background-color:transparent">
     <span style="color:#0d0016">
      多继承
     </span>
    </h2>
    <blockquote>
     <p>
      1.
      <span style="color:#1f2329">
       单继承：一个派生类
      </span>
      <strong>
       <span style="color:#fe2c24">
        只有一个直接基类
       </span>
      </strong>
      <span style="color:#1f2329">
       时称这个
      </span>
      <strong>
       <span style="color:#fe2c24">
        继承关系
       </span>
      </strong>
      <span style="color:#1f2329">
       为单继承。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       2. 多继承：一个派生类有
      </span>
      <strong>
       <span style="color:#fe2c24">
        两个或以上直接基类
       </span>
      </strong>
      <span style="color:#1f2329">
       时称这个继承关系为多继承。
      </span>
     </p>
     <p>
      <span style="color:#1f2329">
       3. 会出现
      </span>
      <span style="color:#fe2c24">
       <strong>
        菱形继承
       </strong>
      </span>
      <span style="color:#1f2329">
       ，有数据冗余和二义性的问题。
      </span>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="268" src="https://i-blog.csdnimg.cn/direct/ddb6dcd2344a483aa58db879bddb84ec.png" width="433"/>
    </p>
    <p class="img-center">
     <img alt="" height="220" src="https://i-blog.csdnimg.cn/direct/e01c2d9acd68408e9a01450943fa7c55.png" width="492"/>
    </p>
    <p class="img-center">
     <img alt="" height="351" src="https://i-blog.csdnimg.cn/direct/0cf5b10646a44e20bf9ad4ddb9159a3d.png" width="691"/>
    </p>
    <p class="img-center">
     <img alt="" height="476" src="https://i-blog.csdnimg.cn/direct/becfd937e9274038a7fe80702c815e35.png" width="470"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f687379313630333931343639312f:61727469636c652f64657461696c732f313436303536343737" class_="artid" style="display:none">
 </p>
</div>


