---
layout: post
title: "通过USB数据线实现Android端与PC端的通信"
date: 2025-01-14 15:07:58 +0800
description: "Android端与PC通信之 Socket  ONE Goal ,ONE Passion! 给浦发银"
keywords: "通过usb 口访问android目录"
categories: ['通信']
tags: ['通信', 'Usb']
artid: "50072665"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=50072665
    alt: "通过USB数据线实现Android端与PC端的通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=50072665
featuredImagePreview: https://bing.ee123.net/img/rand?artid=50072665
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     通过USB数据线实现Android端与PC端的通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4 id="android端与pc通信之-socket">
     Android端与PC通信之 Socket
    </h4>
    <blockquote>
     <p>
      ONE Goal ,ONE Passion!
     </p>
    </blockquote>
    <pre><code> 给浦发银行做的一个项目,其中最让人头疼的一点是,要求必须使用usb数据线进行数据的交互.这就遇到两个问题:
 1.由于每个pc端的ip不同 然而 pad端ip="127.0.0.1",所以pad(android端)不能作为client端.要让pc作为client端主动发起请求连接.

 2.使用模拟器时通信一切正常,可是使用了pad进行测试时根本无法通信,问了公司老大,查了一些资料终于找到了其中的解决办法.

 使用虚拟机可以的原因也许是:虚拟机运行在pc电脑上,虚拟机内部做了一些处理. 可是使用真机时需要将pc上的端口转发来作为请求端口,这就需要是用adb命令进行转发操作
</code></pre>
    <h5 id="第一-pc端转发操作">
     第一. pc端转发操作:
    </h5>
    <pre><code>   先做准备工作.将我们的adb路径配置到path中,否则的话会报错的.以为执行adb命令不是系统级别,是不能执行的一般我们的sdk中都有adb.exe文件.在sdk/platform-tools下.
   提供adb下载:http://download.csdn.net/detail/fengltxx/9305923
</code></pre>
    <p>
     1,先执行adb命令 这些命令在cmd命令行也可以执行
    </p>
    <pre class="prettyprint"><code class="hljs avrasm">//这句adb命令可以不用.执行下面两句也可以实现转发.只是为了避免重复开启service所以在转发端口前先stop一下 
Runtime<span class="hljs-preprocessor">.getRuntime</span>()<span class="hljs-preprocessor">.exec</span>(<span class="hljs-string">"adb shell am broadcast -a NotifyServiceStop"</span>)<span class="hljs-comment">;</span>
//转发的关键代码
Runtime<span class="hljs-preprocessor">.getRuntime</span>()<span class="hljs-preprocessor">.exec</span>(<span class="hljs-string">"adb forward tcp:5000 tcp:13000"</span>)<span class="hljs-comment">;</span>
Runtime<span class="hljs-preprocessor">.getRuntime</span>()<span class="hljs-preprocessor">.exec</span>(<span class="hljs-string">"adb shell am broadcast -a NotifyServiceStart"</span>)<span class="hljs-comment">;</span></code></pre>
    <p>
     2,接下来就和普通的socket通信没有什么区别了
    </p>
    <pre class="prettyprint"><code class="hljs cs"><span class="hljs-keyword">try</span> {
            final Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">5000</span>);

            <span class="hljs-comment">// 得到socket管道中的输出流--------------像手机端写数据</span>
            final BufferedOutputStream <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> BufferedOutputStream(client
                    .getOutputStream());
            <span class="hljs-comment">// 得到socket管道中的输人流--------------读取手机端的数据</span>
            final BufferedInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> BufferedInputStream(client
                    .getInputStream());

            <span class="hljs-comment">// 开启子线程去读去数据</span>

            <span class="hljs-keyword">new</span> Thread() {
                @Override
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {

                    <span class="hljs-keyword">try</span> {
                        String readMsg = <span class="hljs-string">""</span>;
                        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                            <span class="hljs-keyword">try</span> {
                                <span class="hljs-keyword">if</span> (!client.isConnected()) {
                                    <span class="hljs-keyword">break</span>;
                                }
   <span class="hljs-comment">// 读到后台发送的消息 然后去处理</span>
                                readMsg = readMsgFromSocket(<span class="hljs-keyword">in</span>);
                                <span class="hljs-keyword">if</span> (readMsg.length() == <span class="hljs-number">0</span>) {

    <span class="hljs-keyword">break</span>;
                                }
                            }           
                    <span class="hljs-comment">// 将要返回的数据发送给pc </span>
              <span class="hljs-keyword">out</span>.write((readMsg + <span class="hljs-string">"1"</span>).getBytes());
            <span class="hljs-keyword">out</span>.flush();

                            } <span class="hljs-keyword">catch</span> (Exception e) {
                                e.printStackTrace();
                            }
                        }
                        <span class="hljs-keyword">in</span>.close();
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        e.printStackTrace();
                    } <span class="hljs-keyword">finally</span> {
                    }

                }
            }.start();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
  <span class="hljs-comment">//一个读取输入流的方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">readMsgFromSocket</span>(InputStream <span class="hljs-keyword">in</span>) {

        String msg = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">byte</span>[] tempbuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">int</span> numReadedBytes = <span class="hljs-keyword">in</span>.read(tempbuffer, <span class="hljs-number">0</span>, tempbuffer.length);
            msg = <span class="hljs-keyword">new</span> String(tempbuffer, <span class="hljs-number">0</span>, numReadedBytes, <span class="hljs-string">"utf-8"</span>);

        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> msg;
    }
</code></pre>
    <h5 id="第二-android端关键代码">
     第二 android端关键代码:
    </h5>
    <pre><code>  android端其实就方便多了,作为服务端我们只需要监听端口就可以了.
  关键代码如下:
</code></pre>
    <pre class="prettyprint"><code class="hljs axapta">
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketServerThread</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Thread</span> {<!-- --></span>

        @Override
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() {
            <span class="hljs-keyword">try</span> {
                Log.d(<span class="hljs-string">"fy"</span>, <span class="hljs-string">"等待连接"</span>);
                System.out.println(<span class="hljs-string">"---------socket 通信线程----等待连接"</span>);
                serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">13000</span>);

                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {

                    <span class="hljs-keyword">client</span> = serverSocket.accept();

                    out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">client</span>.getOutputStream());



                    <span class="hljs-comment">// 开启子线程去读去数据</span>
                    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SocketReadThread(<span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">client</span>.getInputStream()))).start();<span class="hljs-comment">//另外开启一个线程去读数据</span>

                }
            } <span class="hljs-keyword">catch</span> (IOException e) {
                e.printStackTrace();

            }
        }

<span class="hljs-comment">//   暴露给外部调用写入流的方法  如:SocketServerThread.SendMsg(str)</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> SendMsg(String msg) {

            String msg_1 = msg;      <span class="hljs-comment">//回写给银行的数据</span>
            <span class="hljs-keyword">try</span> {

                out.write(msg_1.getBytes(<span class="hljs-string">"UTF-8"</span>));
                out.flush();

            } <span class="hljs-keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }

        }


        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketReadThread</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Runnable</span> {<!-- --></span>

            <span class="hljs-keyword">private</span> BufferedInputStream in;

            <span class="hljs-keyword">public</span> SocketReadThread(BufferedInputStream inStream) throws IOException {

                <span class="hljs-keyword">this</span>.in = inStream;
            }

            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() {
                <span class="hljs-keyword">try</span> {
                    String readMsg = <span class="hljs-string">""</span>;
                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">client</span>.isConnected()) {
                                <span class="hljs-keyword">break</span>;
                            }

                            <span class="hljs-comment">//   读到后台发送的消息  然后去处理</span>
                            currCMD = readMsgFromSocket(in);
                            <span class="hljs-comment">//    处理读到的消息(主要是身份证信息),然后保存在sp中;</span>

                            <span class="hljs-keyword">if</span> (currCMD.length() == <span class="hljs-number">0</span>) {



                                <span class="hljs-keyword">break</span>;
                            }
                            <span class="hljs-keyword">if</span> (readMsg .equals(<span class="hljs-string">"0002"</span>)) {  
                            }
          <span class="hljs-comment">//  将要返回的数据发送给 pc</span>
                            out.write((readMsg + <span class="hljs-string">"flag"</span>).getBytes());
                            out.flush();


  } <span class="hljs-keyword">catch</span> (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    in.close();
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                } <span class="hljs-keyword">finally</span> {
                }
            }

            <span class="hljs-keyword">public</span> String readMsgFromSocket(InputStream in) {
                <span class="hljs-keyword">int</span> MAX_BUFFER_BYTES = <span class="hljs-number">2048</span>;
                String msg = <span class="hljs-string">""</span>;
                <span class="hljs-keyword">byte</span>[] tempbuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[MAX_BUFFER_BYTES];
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">int</span> numReadedBytes = in.read(tempbuffer, <span class="hljs-number">0</span>, tempbuffer.length);
                    msg = <span class="hljs-keyword">new</span> String(tempbuffer, <span class="hljs-number">0</span>, numReadedBytes, <span class="hljs-string">"utf-8"</span>);

                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
                <span class="hljs-keyword">return</span> msg;
            }
        }
    }
<span class="hljs-comment">//有一些变量的声明没有给出来,很简单的东西不在写了.</span></code></pre>
    <h6 id="终于搞定了把这快搞定浦发的项目基本就ok了终于能歇歇了哦忘记一点如果看端口有没有转发成功可以通过cmd命令行查看">
     终于搞定了.把这快搞定浦发的项目基本就ok了.终于能歇歇了.哦!忘记一点.如果看端口有没有转发成功可以通过cmd命令行查看.
    </h6>
    <pre class="prettyprint"><code class="hljs 1c">netstat -ano <span class="hljs-string">| findstr "</span><span class="hljs-number">80</span><span class="hljs-string">" （注80是你想要看查看的端口号）</span></code></pre>
    <p>
     如图则恭喜我们转发成功
     <br/>
     <img alt="转发成功" src="https://img-blog.csdn.net/20151127170833236" title=""/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f66656e676c747878:2f61727469636c652f64657461696c732f3530303732363635" class_="artid" style="display:none">
 </p>
</div>


