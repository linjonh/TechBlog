---
layout: post
title: "Redis原理篇-线程IO模型和通信协议待补充"
date: 2025-03-16 20:03:18 +0800
description: "Redis是单线程为什么还能那么快？因为它的所有数据都在内存中，所有的运算都是内存级别的运算。Redis是单线程，为什么还能处理那么多并发客户端链接？"
keywords: "Redis原理篇-线程IO模型和通信协议（待补充）"
categories: ['未分类']
tags: ['缓存', '数据库', 'Redis']
artid: "146298182"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146298182
    alt: "Redis原理篇-线程IO模型和通信协议待补充"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146298182
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146298182
cover: https://bing.ee123.net/img/rand?artid=146298182
image: https://bing.ee123.net/img/rand?artid=146298182
img: https://bing.ee123.net/img/rand?artid=146298182
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis原理篇-线程IO模型和通信协议（待补充）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     线程IO模型
    </h2>
    <p>
     Redis是单线程为什么还能那么快？
    </p>
    <p>
     因为它的所有数据都在内存中，所有的运算都是内存级别的运算。
    </p>
    <p>
     Redis是单线程，为什么还能处理那么多并发客户端链接？
    </p>
    <p>
     “多路复用”、非阻塞IO等，原理如下：
    </p>
    <h3>
     非阻塞IO
    </h3>
    <p>
     在套接字对象上提供一个选项Non_Blocking，当这个选项打开时，读写方法不会阻塞，能读多少读多少，能写多少写多少。能读多少取决于内核为套接字分配的读缓冲区的数据字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲字节数。读写方法都会通过返回值告知程序实际读写了多少字节。
    </p>
    <h3>
     事件轮询（多路复用）
    </h3>
    <p>
     有了非阻塞IO，保证了读写不阻塞，但是什么时候下一次读，什么时候下一次写，此时就需要时间轮询来解决了。
    </p>
    <p>
     最简单的事件轮询API就是select函数，它是操作系统提供给用户程序的API，输入是读写描述符列表read_fds&amp;write_fds，输出是与之对应的可读写事件。同时还提供一个timeout参数，如果没有任何事件到来，那么就多多等待timeout的值的时间，线程处于阻塞状态。
    </p>
    <p>
     我们通过select系统同时处理多个通道描述符的读写事件，因此我们将这类系统调用称之为多路复用API。现代OS的多路复用API早已不再使用select系统调用，而是使用epoll（Linux）和kqueue（FreeBSD和macosx）。
    </p>
    <h3>
     指令队列
    </h3>
    <p>
     Redis会将每个客户端套接字都关联一个指令队列，客户端的指令通过队列来排队进行处理，先到先服务。
    </p>
    <h3>
     响应队列
    </h3>
    <p>
     Redis同样也是为每个客户端套接字关联一个响应队列。Redis服务器通过响应队列来将指令的返回结果回复给客户端。
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2>
     通信协议
    </h2>
    <p>
     resp是Redis序列化协议
     <span style="color:#fe2c24">
      Re
     </span>
     dis
     <span style="color:#fe2c24">
      S
     </span>
     erialization
     <span style="color:#fe2c24">
      P
     </span>
     rotocol的简写。它是一种只管的文本协议，优势在于实现过程异常简单，解析性能极好。（Redis作者认为数据库系统的瓶颈一般不在于网络流量，而在于数据库自身的内部处理上，所以即使Redis使用了浪费流量的文本协议，但是依然可以取得极高的访问性能）。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33323437333532332f:61727469636c652f64657461696c732f313436323938313832" class_="artid" style="display:none">
 </p>
</div>


