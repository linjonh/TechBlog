---
layout: post
title: "C模板进阶"
date: 2025-03-15 09:58:30 +0800
description: "优点：模板复用了代码，节省资源，更快的迭代开发增强了代码的灵活性缺陷模板会导致代码膨胀问题，也会导致编译时间变长出现模板编译错误时，错误信息非常凌乱，不易定位错误模板进阶就到这里结束了接下来进入继承，写的不好的地方欢迎大家指出。"
keywords: "C+模板进阶"
categories: ['未分类']
tags: ['C']
artid: "146128797"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146128797
    alt: "C模板进阶"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146128797
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146128797
cover: https://bing.ee123.net/img/rand?artid=146128797
image: https://bing.ee123.net/img/rand?artid=146128797
img: https://bing.ee123.net/img/rand?artid=146128797
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C+模板进阶
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0" name="%E4%B8%80%E3%80%81%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">
     一、非类型模板参数
    </h2>
    <pre><code class="language-cpp">#define N 10;
template&lt;class T&gt;
class Stack
{
private:
	T _a[N];
};</code></pre>
    <pre><code class="language-cpp">Stack&lt;int&gt; st1;//10
Stack&lt;int&gt; st2;//100</code></pre>
    <p>
     你看这里N已经define写死了，但是我想让st1和st2开辟不同大小的空间怎么办，
    </p>
    <pre><code class="language-cpp">#define N 10000;</code></pre>
    <p>
     像我们这里把N扩大到10000，但是我们又用不了这么多空间，这还会造成资源浪费，所以C++引入了一个叫非类型模板参数
    </p>
    <pre><code class="language-cpp">template&lt;class T,size_t N&gt;
class Stack
{
private:
	T _a[N];
};</code></pre>
    <pre><code class="language-cpp">	Stack&lt;int,10&gt; st1;//10
	Stack&lt;int,100&gt; st2;//100</code></pre>
    <p>
     这是一个常量，常量才能控制数组的大小，像我们输入值这种都是不行的
    </p>
    <p>
     像如果我们是变量的时候，编译器在编译的时候要实例化，实例化我们又不知道实例化出多少，数组我们也不知到去开多大
    </p>
    <p>
     像char，int，short这些整型家族的才可以
    </p>
    <p>
    </p>
    <p>
     <strong>
      函数模板的特化
     </strong>
    </p>
    <p>
     <strong>
      步骤
     </strong>
    </p>
    <p>
     <strong>
      1.必须要先有一个基础的函数模板
     </strong>
    </p>
    <p>
     <strong>
      2.关键字template后面接一对空的尖括号&lt;&gt;
     </strong>
    </p>
    <p>
     <strong>
      3.函数名后跟一对尖括号，尖括号中指定需要特化的类型
     </strong>
    </p>
    <p>
     <strong>
      4.函数形参表:必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误
     </strong>
    </p>
    <h3 id="%E4%BA%8C%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96" name="%E4%BA%8C%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96">
     二、类模板的特化
    </h3>
    <p>
     模板特化：针对某些类型进行特殊化处理
    </p>
    <pre><code class="language-cpp">template&lt;class T1, class T2&gt;
class Data
{
public:
	Data()
	{
		cout &lt;&lt; "Data&lt;T1,T2&gt;" &lt;&lt; endl;
	}
private:
	T1 d1;
	T2 d2;
};</code></pre>
    <pre><code class="language-cpp">template&lt;&gt;
class Data&lt;int,double&gt;
{
public:
	Data()
	{
		cout &lt;&lt; "Data&lt;int,double&gt;" &lt;&lt; endl;
	}
};</code></pre>
    <pre><code class="language-cpp">Data&lt;int, int&gt; d1;
Data&lt;int, double&gt; d2;</code></pre>
    <p>
     我们把下面一个类叫作上面一个类的特化
    </p>
    <p>
     是int，double走下面这个最匹配的，其他的走上面那个
    </p>
    <p>
     <img alt="" height="75" src="https://i-blog.csdnimg.cn/direct/953bc8d6676b4ecb8772f3c875391380.png" width="289"/>
    </p>
    <p>
     这个特化叫作
     <strong>
      全特化
     </strong>
    </p>
    <p>
     还有一个叫
     <strong>
      偏特化
     </strong>
     ，特化部分
    </p>
    <pre><code class="language-cpp">template&lt;class T1&gt;
class Data&lt;T1,int&gt;
{
public:
	Data()
	{
		cout &lt;&lt; "Data&lt;T1,int&gt;" &lt;&lt; endl;
	}

};</code></pre>
    <p>
     还可以弄指针
    </p>
    <pre><code class="language-cpp">template&lt;class T1, class T2&gt;
class Data&lt;T1*, T2*&gt;
{
public:
	Data()
	{
		cout &lt;&lt; "Data&lt;T1*, T2*&gt;" &lt;&lt; endl;
	}

};</code></pre>
    <p>
     <strong>
      注意:有最匹配的会找最匹配的
     </strong>
    </p>
    <p>
     那么函数模板特化呢，这里我复用一下上一篇文章的代码
    </p>
    <pre><code class="language-cpp">class Date
{
public:
    Date(int year = 1900, int month = 1, int day = 1)
        : _year(year)
        , _month(month)
        , _day(day)
    {}

    bool operator&lt;(const Date&amp; d) const
    {
        return (_year &lt; d._year) ||
            (_year == d._year &amp;&amp; _month &lt; d._month) ||
            (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day);
    }

    bool operator&gt;(const Date&amp; d) const
    {
        return (_year &gt; d._year) ||
            (_year == d._year &amp;&amp; _month &gt; d._month) ||
            (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day);
    }

    friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);
private:
    int _year;
    int _month;
    int _day;
};

ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)
{
    _cout &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
    return _cout;
}
</code></pre>
    <pre><code class="language-cpp">template &lt;class T&gt;
bool Less(T x, T y)
{
		return x &lt; y;
}
template &lt;&gt;
bool Less&lt;Date*&gt;(Date*  x, Date* y)
{
	return *x &lt; *y;
};
int main()
{
	Date* a1 = new Date(2025, 3, 9);
	Date* a2 = new Date(2025, 3, 10);
	cout &lt;&lt; Less(a1,a2) &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     这样就是函数的模板特化了
    </p>
    <p>
     或者我们也不用写这个写一个函数的重载就行了
    </p>
    <h4 id="%E4%B8%89%E3%80%81%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91" name="%E4%B8%89%E3%80%81%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91">
     三、模板的分离编译
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
template&lt;class T&gt;
T Add(const T&amp; left, const T&amp; right);</code></pre>
    <p>
     <img alt="" height="213" src="https://i-blog.csdnimg.cn/direct/dad77086bf9c4341ae86608cc5360265.png" width="320"/>
    </p>
    <pre><code class="language-cpp">#include "stack.h"
template&lt;class T&gt;
T Add(const T&amp; left, const T&amp; right)
{
	cout &lt;&lt; "T Add(const T&amp; left, const T&amp; right)" &lt;&lt; endl;
	return left + right;
}</code></pre>
    <pre><code class="language-cpp">#include "stack.h"
template&lt;class T&gt;
T Add(const T&amp; left, const T&amp; right)
{
	cout &lt;&lt; "T Add(const T&amp; left, const T&amp; right)" &lt;&lt; endl;
	return left + right;
}</code></pre>
    <pre><code class="language-cpp">#include "stack.h"
int main()
{
	Add(1, 2);
}
</code></pre>
    <p>
     <img alt="" height="66" src="https://i-blog.csdnimg.cn/direct/97856e91e4d848a79e0b6edfff6afd28.png" width="1418"/>
    </p>
    <p>
     这样的声明和定义分离就会报所谓的链接错误
    </p>
    <p>
     好让我们分析一下其中的原因
    </p>
    <p>
     编译器运行代码一般分为四个阶段
    </p>
    <p>
     1.预处理 像是头文件的展开/宏替换....
    </p>
    <p>
     2.编译 检查语法生成汇编代码
    </p>
    <p>
     3.汇编 汇编代码转成二进制机器码
    </p>
    <p>
     4.链接
    </p>
    <p>
     链接的时候它就需要去call这个地址，跳到这个地址，但是在.cpp文件中，只包含了stack.h的头文件，相当于只包含了声明，而没有给你定义，就是相当于你买房子给你你图纸没有给你房子，然而给了你声明就让你去其他文件去找地址
    </p>
    <p>
     <img alt="" height="270" src="https://i-blog.csdnimg.cn/direct/5bb7cc62681340f5942d4342fd0112de.png" width="744"/>
    </p>
    <p>
     但是我们会发现Add找不到，因为stack.cpp因为Add没有实例化，没有Add的地址
    </p>
    <p>
     我template.cpp知道要实例化成什么，但是没有定义
    </p>
    <p>
     就相当于一种沟通不畅，template有图纸有需求就是没有房子，stack.cpp有房子有图纸就是有毛坯房就是不知道装修成什么样子装修在哪，在两个文件中，倘若我stack.cpp实例化了，那就有了具体的地址，我template手上有声明了就知道到哪里去找它了
    </p>
    <p>
     <strong>
      解决方案1
     </strong>
    </p>
    <p>
     <strong>
      显示实例化
     </strong>
    </p>
    <pre><code class="language-cpp">template
int Add&lt;int&gt;(const int&amp; left, const int&amp; right);</code></pre>
    <p>
     这是一种解决方案，但是有一种弊端
    </p>
    <pre><code class="language-cpp">Add(1.1, 2.2);</code></pre>
    <p>
     <img alt="" height="57" src="https://i-blog.csdnimg.cn/direct/3f54ec3ccb714fac82f38b7b63e93a35.png" width="1389"/>
    </p>
    <p>
     显示实例化这种方法可行但是不好用换一种类型又要写一种了；
    </p>
    <p>
     我们连类一起看一下
    </p>
    <p>
     这是stack.h里面的
    </p>
    <pre><code class="language-cpp">template&lt;class T&gt;
class stack
{
public:
	void push(const T&amp; x);
private:
	T* _a;
	int _top;
	int _capacity;
}</code></pre>
    <p>
     这是stack.cpp里面的
    </p>
    <pre><code class="language-cpp">template&lt;class T&gt;
void stack&lt;T&gt;::push(const T&amp; x)
{
	cout &lt;&lt; "void push(const T&amp; x)" &lt;&lt; endl;
}</code></pre>
    <pre><code class="language-cpp">stack&lt;int&gt; st;
st.push(1);</code></pre>
    <p>
     也是一样的结果
    </p>
    <pre><code class="language-cpp">template
class stack&lt;int&gt;;</code></pre>
    <p>
     也是不好用的
    </p>
    <p>
     <strong>
      解决方案二
     </strong>
    </p>
    <p>
     不分离
    </p>
    <p>
     我们直接把stack.cpp删掉，把声明和定义全都放到一起
    </p>
    <p>
     <img alt="" height="565" src="https://i-blog.csdnimg.cn/direct/891be3b412ce4fb8baebd40631cbf0e2.png" width="602"/>
    </p>
    <p>
     声明和定义全都放在一起，我stack.h在编译的时候一开，直接就能实例化了
    </p>
    <h5 id="%E5%9B%9B%E3%80%81%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93" name="%E5%9B%9B%E3%80%81%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93">
     四、模板总结
    </h5>
    <p>
     优点：模板复用了代码，节省资源，更快的迭代开发
    </p>
    <p>
     增强了代码的灵活性
    </p>
    <p>
     缺陷
    </p>
    <p>
     模板会导致代码膨胀问题，也会导致编译时间变长
    </p>
    <p>
     出现模板编译错误时，错误信息非常凌乱，不易定位错误
    </p>
    <p>
    </p>
    <p>
     <strong>
      模板进阶就到这里结束了接下来进入继承，写的不好的地方欢迎大家指出
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343036383238372f:61727469636c652f64657461696c732f313436313238373937" class_="artid" style="display:none">
 </p>
</div>


