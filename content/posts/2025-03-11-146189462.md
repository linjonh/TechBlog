---
layout: post
title: "golang-高性能的-MySQL-数据导出"
date: 2025-03-11 21:36:02 +0800
description: "数据库负载：大量数据查询会增加数据库的CPU、内存和I/O负担，可能影响其他操作。网络传输：大数据量传输会占用大量带宽，导致网络延迟或超时。服务器内存: 消耗太大,影响其他业务运行。"
keywords: "golang 高性能的 MySQL 数据导出"
categories: ['未分类']
tags: ['开发语言', 'Mysql', 'Golang']
artid: "146189462"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146189462
    alt: "golang-高性能的-MySQL-数据导出"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146189462
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146189462
cover: https://bing.ee123.net/img/rand?artid=146189462
image: https://bing.ee123.net/img/rand?artid=146189462
img: https://bing.ee123.net/img/rand?artid=146189462
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     golang 高性能的 MySQL 数据导出
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="_2">
     </a>
     背景:
    </h3>
    <p>
     <strong>
      需求
     </strong>
    </p>
    <ul>
     <li>
      我在工作的使用收到一个导出数据数据的需求,导出为Excel文件
     </li>
    </ul>
    <p>
     <strong>
      处理
     </strong>
    </p>
    <ol>
     <li>
      我先查阅了网上的文档,他们提供的方案都是分页查询的方式
      <ul>
       <li>
        不使用一次查询全表数据的原因是如果数据量特别庞大的情况下会消耗 MySQL 的大量内存空间,造成服务器卡顿,影响服务性能
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      确定分页大小
     </strong>
    </p>
    <ul>
     <li>
      <p>
       选择合适的分页大小
      </p>
      <ul>
       <li>
        分页太大的问题: 浪费内存,造成服务器卡顿
       </li>
       <li>
        分页太小: 查询次数太多,导出慢
       </li>
      </ul>
     </li>
     <li>
      <p>
       我从 100 大小开始,每次增加 100, 一直增加到 4000的分页大小
       <br/>
       <strong>
        发现导出的性能先递增,到两千后变化就不大了;所以我选择两千的分页大小
       </strong>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      bug: 数据导出超时
     </strong>
    </p>
    <ul>
     <li>
      当测试测的时候出现导出超时的问题,就给我提了一个 bug
     </li>
    </ul>
    <p>
     <strong>
      问题分析:
     </strong>
    </p>
    <ol>
     <li>
      测试时未使用任何筛选字段,导出全表数据 200 万条
     </li>
     <li>
      前端的超时时间 1 分钟(我试了一下,导出全表的数据需要 5 分钟
     </li>
    </ol>
    <h3>
     <a id="_25">
     </a>
     任务
    </h3>
    <ul>
     <li>
      解决超时问题,即使导出全表数据也不能超时
     </li>
    </ul>
    <h3>
     <a id="_29">
     </a>
     行动
    </h3>
    <h5>
     <a id="_30">
     </a>
     单元测试
    </h5>
    <ul>
     <li>
      我对代码进行单元测试,看各阶段耗时情况
      <ul>
       <li>
        发现查询耗时4min40s
       </li>
       <li>
        数据处理与传输 20s
       </li>
      </ul>
     </li>
    </ul>
    <p>
     数据查询耗时占了约 93%; 核心优化数据查询
    </p>
    <h5>
     <a id="_38">
     </a>
     分页查询的问题
    </h5>
    <pre><code class="prism language-sql"><span class="token comment">-- 分页查询</span>
<span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">OFFSET</span> m <span class="token keyword">LIMIT</span> n
</code></pre>
    <p>
     但是你使用
     <code>
      EXPLAIN
     </code>
     语句就会发现分页查询是全表扫描,没有走任何索引逻辑
    </p>
    <ul>
     <li>
      他的逻辑是从数据的第一条开始扫描,把前面扫描到的 m 条数据都丢弃掉然后取有面的 n 条数据
     </li>
     <li>
      所以 m 越大(page 越大);查询越慢
     </li>
    </ul>
    <h6>
     <a id="_48">
     </a>
     深度分页的耗时情况
    </h6>
    <pre><code class="prism language-sql"><span class="token comment">--浅分页(耗时 15ms)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">OFFSET</span> <span class="token number">2000</span> <span class="token keyword">LIMIT</span> <span class="token number">2000</span>

<span class="token comment">--深度分页(耗时 1.12s)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">OFFSET</span> <span class="token number">200000</span> <span class="token keyword">LIMIT</span> <span class="token number">2000</span>
</code></pre>
    <h4>
     <a id="_57">
     </a>
     优化分页查询的查询性能
    </h4>
    <h5>
     <a id="1_4s_59">
     </a>
     方案1: 偏移分页(查询耗时:4s)
    </h5>
    <p>
     原理是使用
     <code>
      WHERE id&gt;m
     </code>
     代替
     <code>
      OFFSET m
     </code>
     ,查询直接走主键索引确定数据位置
    </p>
    <pre><code class="prism language-sql"><span class="token comment">--偏移分页</span>
<span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> m <span class="token keyword">LIMIT</span> n
</code></pre>
    <ul>
     <li>
      <code>
       EXPLAIN
      </code>
      的结果是 range 类型
     </li>
    </ul>
    <p>
     代码示例:
    </p>
    <pre><code class="prism language-go">	<span class="token comment">// 定义分页参数</span>
	starId <span class="token operator">:=</span> <span class="token number">0</span>
	pageSize <span class="token operator">:=</span> <span class="token number">2000</span>
	<span class="token comment">// 定义查询条件</span>
	<span class="token keyword">var</span> users <span class="token punctuation">[</span><span class="token punctuation">]</span>User
	<span class="token comment">// 执行分页查询</span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
		result <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Limit</span><span class="token punctuation">(</span>pageSize<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span><span class="token string">"id &gt;= ?"</span><span class="token punctuation">,</span> starId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>users<span class="token punctuation">)</span>
		<span class="token keyword">if</span> result<span class="token punctuation">.</span>Error <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"err5:"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span>Error<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span> <span class="token operator">&lt;</span> pageSize <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		starId <span class="token operator">=</span> users<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Id
	<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      整个查询耗时 4s (本地测试),查询性能提高 70 倍
     </li>
     <li>
      导出总耗时: 24s(数据查询耗时:4s; 数据处理与传输耗时 20s)
     </li>
    </ul>
    <h5>
     <a id="2_15s_93">
     </a>
     方案2: 快照导出(查询耗时:1.5s)
    </h5>
    <p>
     因为我之前有做过使用
     <a href="https://github.dev/dengjiayue/mysqldump/blob/master/mysqldump.go" rel="nofollow">
      go 实现 MySQLdump
     </a>
     的项目
     <br/>
     项目地址:
     <a href="https://github.dev/dengjiayue/mysqldump/blob/master/mysqldump.go" rel="nofollow">
      https://github.dev/dengjiayue/mysqldump/blob/master/mysqldump.go
     </a>
    </p>
    <p>
     与这边的数据导出的逻辑非常类似;
    </p>
    <p>
     我参考我之前 MySQLdump 的导出逻辑进行进一步优化
    </p>
    <p>
     代码示例:
    </p>
    <pre><code class="prism language-go">data<span class="token punctuation">,</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token string">"select * from users"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"err1:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> data<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	columns<span class="token punctuation">,</span> err <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Columns</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[error] %v \n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	l <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>columns<span class="token punctuation">)</span>

	val <span class="token operator">:=</span> <span class="token operator">&amp;</span>User<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	valPointer <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span>
	valPointer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">.</span>Id
	valPointer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">.</span>Name
	valPointer<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">.</span>Tag
	valPointer<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">.</span>Phone
	valPointer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">.</span>Create_time

	<span class="token comment">//计数</span>
	num <span class="token operator">:=</span> <span class="token number">0</span>

	<span class="token keyword">for</span> data<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		err <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span>valPointer<span class="token operator">...</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"err5:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      这边我使用了类似查询全表数据的逻辑
     </li>
    </ul>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
</code></pre>
    <p>
     实际上原生的 sql 包是对查询进行了处理的;并不是一次性获取所有的数据
    </p>
    <ul>
     <li>
      MySQL 会准备好返回的数据的快照(但是不会传输给服务端)
     </li>
     <li>
      服务端使用 Next 命令(获取 MySQL 结果集中的一行数据)
     </li>
     <li>
      然后再 Scan读取到对象中
     </li>
    </ul>
    <p>
     这种方法的优势:
    </p>
    <ol>
     <li>
      只需要一次查询命令
     </li>
     <li>
      一行一行流式读取的,不会一次性占用很多的内存
     </li>
    </ol>
    <ul>
     <li>
      整个查询耗时 1.5s (本地测试),查询性能提高 200 倍
     </li>
     <li>
      导出总耗时: 21.5s(数据查询耗时:1.5s; 数据处理与传输耗时 20s)
     </li>
    </ul>
    <h4>
     <a id="_151">
     </a>
     其他优化
    </h4>
    <h5>
     <a id="_153">
     </a>
     异步处理+流式对象储存
    </h5>
    <p>
     开两个协程
    </p>
    <ul>
     <li>
      一个只用于查询数据,将查询到的数据放到 chan 中
     </li>
     <li>
      一个只用于处理数据并传输: 从 chan 中读取数据,并生成 Excel 的二进制数据,然后传输到对象储存
     </li>
    </ul>
    <p>
     我选择对象储存有两个原因:
    </p>
    <ul>
     <li>
      避免客户端长时间等待接收数据
     </li>
     <li>
      实现一个导出列表: 可以查看到每次导出的记录,与导出的状态(已完成,未完成,失败);避免用户等待久了多次点击导出接口,同时可以复用之前的导出记录(前面一个导出了一次,另一个人刚好也需要,就可以直接下载,不需要二次导出)
     </li>
    </ul>
    <h3>
     <a id="_163">
     </a>
     结果
    </h3>
    <ul>
     <li>
      200 万数据的导出时间缩短到 15s(查询耗时:1.5s;处理传输耗时 13.5s)
     </li>
    </ul>
    <p>
     整体导出性能提升 20 倍(原导出时间 5min)
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f64656e676a69617975652f:61727469636c652f64657461696c732f313436313839343632" class_="artid" style="display:none">
 </p>
</div>


