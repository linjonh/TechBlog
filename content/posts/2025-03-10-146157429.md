---
layout: post
title: "根据身高重建队列力扣-406"
date: 2025-03-10 16:27:07 +0800
description: "当他把【6，1】插入到【7，1】前面的话，不会影响【7，1】前面只有一个大于等于他的情况，所以说从大到小排序。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。"
keywords: "根据身高重建队列力扣--406"
categories: ['贪心算法', '算法']
tags: ['算法', '数据结构', 'Leetcode']
artid: "146157429"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146157429
    alt: "根据身高重建队列力扣-406"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146157429
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146157429
cover: https://bing.ee123.net/img/rand?artid=146157429
image: https://bing.ee123.net/img/rand?artid=146157429
img: https://bing.ee123.net/img/rand?artid=146157429
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     根据身高重建队列力扣--406
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E9%A2%98%E7%9B%AE" name="%E9%A2%98%E7%9B%AE">
     题目
    </h2>
    <p>
     假设有打乱顺序的一群人站成一个队列，数组
     <code>
      people
     </code>
     表示队列中一些人的属性（不一定按顺序）。每个
     <code>
      people[i] = [hi, ki]
     </code>
     表示第
     <code>
      i
     </code>
     个人的身高为
     <code>
      hi
     </code>
     ，前面
     <strong>
      正好
     </strong>
     有
     <code>
      ki
     </code>
     个身高大于或等于
     <code>
      hi
     </code>
     的人。
    </p>
    <p>
     请你重新构造并返回输入数组
     <code>
      people
     </code>
     所表示的队列。返回的队列应该格式化为数组
     <code>
      queue
     </code>
     ，其中
     <code>
      queue[j] = [hj, kj]
     </code>
     是队列中第
     <code>
      j
     </code>
     个人的属性（
     <code>
      queue[0]
     </code>
     是排在队列前面的人）。
    </p>
    <p>
    </p>
    <ul>
    </ul>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><strong>输入：</strong>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
<strong>输出：</strong>[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
<strong>解释：</strong>
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><strong>输入：</strong>people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
<strong>输出：</strong>[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</pre>
    <h2 id="%E6%80%9D%E8%B7%AF" name="%E6%80%9D%E8%B7%AF">
     思路
    </h2>
    <p>
     本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。
    </p>
    <p>
     <span style="background-color:#ffd900">
      先按照h排序还是k排序呢？
     </span>
    </p>
    <p>
     按照k排序 ，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。
    </p>
    <p>
     所以按照身高排序，从大到小排序
    </p>
    <p>
     <img alt="" height="615" src="https://i-blog.csdnimg.cn/direct/265c435815e64849a3f8ec8526e808b1.png" width="1307"/>
    </p>
    <p>
     插入的过程：
    </p>
    <ul>
     <li>
      插入[7,0]：[[7,0]]
     </li>
     <li>
      插入[7,1]：[[7,0],[7,1]]
     </li>
     <li>
      插入[6,1]：[[7,0],[6,1],[7,1]]
     </li>
     <li>
      插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
     </li>
     <li>
      插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
     </li>
     <li>
      插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
     </li>
    </ul>
    <p>
     当他把【6，1】插入到【7，1】前面的话，不会影响【7，1】前面只有一个大于等于他的情况，所以说从大到小排序
    </p>
    <h2 id="%E4%BB%A3%E7%A0%81" name="%E4%BB%A3%E7%A0%81">
     代码
    </h2>
    <pre><code class="language-java">class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(a,b)-&gt;{
            if(a[0]==b[0]) return a[1]-b[1];
            return b[0] - a[0];});
        
        LinkedList&lt;int []&gt;que=new LinkedList&lt;&gt;();
        for (int[] p : people) {
            que.add(p[1],p);   //Linkedlist.add(index, value)，会將value插入到指定index里。
        }
        
         return que.toArray(new int[people.length][]);
    }
}</code></pre>
    <p id="%E5%8C%BF%E5%90%8D%C2%A0Comparator%C2%A0%E5%AE%9E%E7%8E%B0" name="%E5%8C%BF%E5%90%8D%C2%A0Comparator%C2%A0%E5%AE%9E%E7%8E%B0">
     匿名
     <code>
      Comparator
     </code>
     实现
    </p>
    <pre><code class="language-java">(a, b) -&gt; {
    if (a[0] == b[0]) return a[1] - b[1];
    return b[0] - a[0];
}
</code></pre>
    <p>
     这是一个 Lambda 表达式，用于实现
     <code>
      Comparator
     </code>
     接口。
     <code>
      a
     </code>
     和
     <code>
      b
     </code>
     是
     <code>
      people
     </code>
     数组中的两个元素，每个元素都是一个长度为 2 的一维数组，分别代表一个人的身高
     <code>
      h
     </code>
     和前面身高大于等于自己的人数
     <code>
      k
     </code>
     。
    </p>
    <p>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         if (a[0] == b[0]) return a[1] - b[1];
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        这行代码的作用是当两个人的身高
        <code>
         h
        </code>
        相等时，按照
        <code>
         k
        </code>
        值进行升序排序。
       </li>
       <li>
        <code>
         a[1] - b[1]
        </code>
        的结果决定了
        <code>
         a
        </code>
        和
        <code>
         b
        </code>
        的相对顺序：
        <ul>
         <li>
          如果
          <code>
           a[1] - b[1] &lt; 0
          </code>
          ，说明
          <code>
           a[1]
          </code>
          小于
          <code>
           b[1]
          </code>
          ，
          <code>
           a
          </code>
          会排在
          <code>
           b
          </code>
          前面。
         </li>
         <li>
          如果
          <code>
           a[1] - b[1] &gt; 0
          </code>
          ，说明
          <code>
           a[1]
          </code>
          大于
          <code>
           b[1]
          </code>
          ，
          <code>
           a
          </code>
          会排在
          <code>
           b
          </code>
          后面。
         </li>
         <li>
          如果
          <code>
           a[1] - b[1] == 0
          </code>
          ，说明
          <code>
           a[1]
          </code>
          等于
          <code>
           b[1]
          </code>
          ，
          <code>
           a
          </code>
          和
          <code>
           b
          </code>
          的相对顺序不变。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         return b[0] - a[0];
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        这行代码的作用是当两个人的身高
        <code>
         h
        </code>
        不相等时，按照
        <code>
         h
        </code>
        值进行降序排序。
       </li>
       <li>
        <code>
         b[0] - a[0]
        </code>
        的结果决定了
        <code>
         a
        </code>
        和
        <code>
         b
        </code>
        的相对顺序：
        <ul>
         <li>
          如果
          <code>
           b[0] - a[0] &lt; 0
          </code>
          ，说明
          <code>
           b[0]
          </code>
          小于
          <code>
           a[0]
          </code>
          ，
          <code>
           b
          </code>
          会排在
          <code>
           a
          </code>
          后面。
         </li>
         <li>
          如果
          <code>
           b[0] - a[0] &gt; 0
          </code>
          ，说明
          <code>
           b[0]
          </code>
          大于
          <code>
           a[0]
          </code>
          ，
          <code>
           b
          </code>
          会排在
          <code>
           a
          </code>
          前面。
         </li>
         <li>
          如果
          <code>
           b[0] - a[0] == 0
          </code>
          ，这种情况不会出现，因为前面已经处理了
          <code>
           a[0] == b[0]
          </code>
          的情况。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303131333131332f:61727469636c652f64657461696c732f313436313537343239" class_="artid" style="display:none">
 </p>
</div>


