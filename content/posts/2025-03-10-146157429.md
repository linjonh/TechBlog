---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303131333131332f:61727469636c652f64657461696c732f313436313537343239"
layout: post
title: "根据身高重建队列力扣-406"
date: 2025-03-10 16:27:07 +0800
description: "当他把【6，1】插入到【7，1】前面的话，不会影响【7，1】前面只有一个大于等于他的情况，所以说从大到小排序。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。"
keywords: "根据身高重建队列力扣--406"
categories: ['贪心算法', '算法']
tags: ['算法', '数据结构', 'Leetcode']
artid: "146157429"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146157429
    alt: "根据身高重建队列力扣-406"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146157429
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146157429
cover: https://bing.ee123.net/img/rand?artid=146157429
image: https://bing.ee123.net/img/rand?artid=146157429
img: https://bing.ee123.net/img/rand?artid=146157429
---

# 根据身高重建队列力扣--406

---

## 题目

假设有打乱顺序的一群人站成一个队列，数组
`people`
表示队列中一些人的属性（不一定按顺序）。每个
`people[i] = [hi, ki]`
表示第
`i`
个人的身高为
`hi`
，前面
**正好**
有
`ki`
个身高大于或等于
`hi`
的人。

请你重新构造并返回输入数组
`people`
所表示的队列。返回的队列应该格式化为数组
`queue`
，其中
`queue[j] = [hj, kj]`
是队列中第
`j`
个人的属性（
`queue[0]`
是排在队列前面的人）。



**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

```

**示例 2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

## 思路

本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。

先按照h排序还是k排序呢？

按照k排序 ，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。

所以按照身高排序，从大到小排序

![](https://i-blog.csdnimg.cn/direct/265c435815e64849a3f8ec8526e808b1.png)

插入的过程：

* 插入[7,0]：[[7,0]]
* 插入[7,1]：[[7,0],[7,1]]
* 插入[6,1]：[[7,0],[6,1],[7,1]]
* 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
* 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
* 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

当他把【6，1】插入到【7，1】前面的话，不会影响【7，1】前面只有一个大于等于他的情况，所以说从大到小排序

## 代码

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(a,b)->{
            if(a[0]==b[0]) return a[1]-b[1];
            return b[0] - a[0];});
        
        LinkedList<int []>que=new LinkedList<>();
        for (int[] p : people) {
            que.add(p[1],p);   //Linkedlist.add(index, value)，会將value插入到指定index里。
        }
        
         return que.toArray(new int[people.length][]);
    }
}
```

匿名
`Comparator`
实现

```java
(a, b) -> {
    if (a[0] == b[0]) return a[1] - b[1];
    return b[0] - a[0];
}

```

这是一个 Lambda 表达式，用于实现
`Comparator`
接口。
`a`
和
`b`
是
`people`
数组中的两个元素，每个元素都是一个长度为 2 的一维数组，分别代表一个人的身高
`h`
和前面身高大于等于自己的人数
`k`
。

* **`if (a[0] == b[0]) return a[1] - b[1];`**
  ：

  + 这行代码的作用是当两个人的身高
    `h`
    相等时，按照
    `k`
    值进行升序排序。
  + `a[1] - b[1]`
    的结果决定了
    `a`
    和
    `b`
    的相对顺序：
    - 如果
      `a[1] - b[1] < 0`
      ，说明
      `a[1]`
      小于
      `b[1]`
      ，
      `a`
      会排在
      `b`
      前面。
    - 如果
      `a[1] - b[1] > 0`
      ，说明
      `a[1]`
      大于
      `b[1]`
      ，
      `a`
      会排在
      `b`
      后面。
    - 如果
      `a[1] - b[1] == 0`
      ，说明
      `a[1]`
      等于
      `b[1]`
      ，
      `a`
      和
      `b`
      的相对顺序不变。
* **`return b[0] - a[0];`**
  ：

  + 这行代码的作用是当两个人的身高
    `h`
    不相等时，按照
    `h`
    值进行降序排序。
  + `b[0] - a[0]`
    的结果决定了
    `a`
    和
    `b`
    的相对顺序：
    - 如果
      `b[0] - a[0] < 0`
      ，说明
      `b[0]`
      小于
      `a[0]`
      ，
      `b`
      会排在
      `a`
      后面。
    - 如果
      `b[0] - a[0] > 0`
      ，说明
      `b[0]`
      大于
      `a[0]`
      ，
      `b`
      会排在
      `a`
      前面。
    - 如果
      `b[0] - a[0] == 0`
      ，这种情况不会出现，因为前面已经处理了
      `a[0] == b[0]`
      的情况。