---
arturl_encode: "6874747073:3a2f2f626c6f672e6373646e2e6e65742f68786a5f3638362f:61727469636c652f64657461696c732f313436323134353133"
layout: post
title: "c的stl中有哪几种map容器,都有什么应用场景"
date: 2025-03-12 20:43:25 +08:00
description: "在 C++ STL（标准模板库）中，有四种与  相关的容器，分别是 、、 和 ，下面将详细介绍它们的特点和应用场景。综上所述，选择使用哪种  容器取决于具体的应用场景，需要综合考虑元素的顺序要求、键的唯一性以及对查找、插入和删除操作的性能要求等因素。"
keywords: "c++的stl中有哪几种map容器，都有什么应用场景？"
categories: ['未分类']
tags: ['算法']
artid: "146214513"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146214513
    alt: "c的stl中有哪几种map容器,都有什么应用场景"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146214513
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146214513
cover: https://bing.ee123.net/img/rand?artid=146214513
image: https://bing.ee123.net/img/rand?artid=146214513
img: https://bing.ee123.net/img/rand?artid=146214513
---

# c++的stl中有哪几种map容器，都有什么应用场景？

在 C++ STL（标准模板库）中，有四种与
`map`
相关的容器，分别是
`std::map`
、
`std::multimap`
、
`std::unordered_map`
和
`std::unordered_multimap`
，下面将详细介绍它们的特点和应用场景。

#### 1. `std::map`

* **特点**
  + **有序性**
    ：
    `std::map`
    基于红黑树（一种自平衡的二叉搜索树）实现，它会根据键（key）的大小对元素进行自动排序，默认使用
    `std::less<Key>`
    比较函数，键的类型必须支持该比较操作。
  + **键的唯一性**
    ：每个键在
    `std::map`
    中是唯一的，插入相同键的元素时，新元素会覆盖旧元素。
  + **查找、插入和删除操作的时间复杂度**
    ：平均和最坏情况下的时间复杂度均为 \(O(log n)\)，其中 n 是容器中元素的数量。
* **应用场景**
  + **需要有序存储键值对的场景**
    ：例如，在实现一个字典程序时，需要按照字母顺序对单词进行排序和查找，使用
    `std::map`
    可以方便地实现这一功能。
  + **对元素顺序有要求的统计场景**
    ：统计不同年龄段的人数，键为年龄，值为对应年龄的人数，使用
    `std::map`
    可以让结果按照年龄从小到大排序，便于查看和分析。

#### 2. `std::multimap`

* **特点**
  + **有序性**
    ：和
    `std::map`
    一样，
    `std::multimap`
    也是基于红黑树实现的，会根据键的大小对元素进行排序。
  + **键的可重复性**
    ：允许存储多个具有相同键的元素，这是它与
    `std::map`
    的主要区别。
  + **查找、插入和删除操作的时间复杂度**
    ：同样为 \(O(log n)\)。
* **应用场景**
  + **需要存储重复键的映射关系场景**
    ：在一个学生成绩管理系统中，一个课程可能有多个学生取得相同的成绩，此时可以使用
    `std::multimap`
    来存储课程成绩和学生的映射关系，键为成绩，值为学生信息。
  + **事件调度系统**
    ：在事件调度系统中，多个事件可能会在同一时间点触发，使用
    `std::multimap`
    可以将时间点作为键，事件作为值，方便按照时间顺序对事件进行管理和调度。

#### 3. `std::unordered_map`

* **特点**
  + **无序性**
    ：
    `std::unordered_map`
    基于哈希表实现，它不会对元素进行排序，元素的存储顺序是由哈希函数决定的。
  + **键的唯一性**
    ：每个键在
    `std::unordered_map`
    中是唯一的，插入相同键的元素时，新元素会覆盖旧元素。
  + **查找、插入和删除操作的时间复杂度**
    ：平均情况下为 \(O(1)\)，但在最坏情况下（哈希冲突严重）可能达到 \(O(n)\)。
* **应用场景**
  + **需要快速查找键值对的场景**
    ：在缓存系统中，需要快速根据键查找对应的值，使用
    `std::unordered_map`
    可以在常数时间内完成查找操作，提高系统的性能。
  + **数据统计和计数场景**
    ：统计一段文本中每个单词的出现次数，使用
    `std::unordered_map`
    可以快速地更新和查找每个单词的计数。

#### 4. `std::unordered_multimap`

* **特点**
  + **无序性**
    ：基于哈希表实现，元素无序存储。
  + **键的可重复性**
    ：允许存储多个具有相同键的元素。
  + **查找、插入和删除操作的时间复杂度**
    ：平均情况下为 \(O(1)\)，最坏情况下为 \(O(n)\)。
* **应用场景**
  + **需要存储重复键且对查找速度有要求的场景**
    ：在一个电商系统中，统计每个商品分类下的所有商品，一个商品可能属于多个分类，使用
    `std::unordered_multimap`
    可以快速地根据分类查找商品，同时允许一个分类下有多个商品。
  + **图的邻接表表示**
    ：在图的表示中，一个顶点可能有多个相邻顶点，使用
    `std::unordered_multimap`
    可以高效地存储顶点和其相邻顶点的关系。

综上所述，选择使用哪种
`map`
容器取决于具体的应用场景，需要综合考虑元素的顺序要求、键的唯一性以及对查找、插入和删除操作的性能要求等因素。