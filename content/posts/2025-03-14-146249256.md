---
layout: post
title: "使用Composer实现自动加载类"
date: 2025-03-14 09:33:08 +0800
description: "通过以上步骤，已经成功地将 Composer 集成到自定义 PHP 框架中，并在控制器类中使用了 Composer 安装的包（如 Monolog 和 Guzzle）。以下是关键点的回顾：Composer 初始化：使用初始化项目，并通过安装所需的包。自动加载配置：在中配置autoload，并使用 PSR-4 标准组织代码。命名空间使用：通过定义命名空间，使类的组织更为规范，并利用 Composer 的自动加载功能简化类的引入。"
keywords: "使用Composer实现自动加载类"
categories: ['Php']
tags: ['Studio', 'Composer', 'Android', 'Android']
artid: "146249256"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146249256
    alt: "使用Composer实现自动加载类"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146249256
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146249256
cover: https://bing.ee123.net/img/rand?artid=146249256
image: https://bing.ee123.net/img/rand?artid=146249256
img: https://bing.ee123.net/img/rand?artid=146249256
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     使用Composer实现自动加载类
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     原文地址：
     <a href="https://mp.weixin.qq.com/s/i0UEr1Zq-tC2ZGm8CUv8gA" rel="nofollow" title="使用Composer实现自动加载类">
      使用Composer实现自动加载类
     </a>
     更多内容请关注：
     <strong>
      <strong>
       <strong>
        <strong>
         <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0MTYyNjcyNg==&amp;action=getalbum&amp;album_id=3803959988091994113#wechat_redirect" rel="nofollow" title="智想天开">
          智想天开
         </a>
        </strong>
       </strong>
      </strong>
     </strong>
    </p>
    <h3>
     1. 初始化 Composer 并安装所需的依赖
    </h3>
    <p>
     首先，确保的开发环境中已安装 Composer。如果尚未安装，可以参考 Composer 官方安装指南 进行安装。
    </p>
    <h4>
     步骤：
    </h4>
    <ol>
     <li>
      <p>
       初始化 Composer 项目
      </p>
      <p>
       在的项目根目录（例如
       <code>
        my_framework/
       </code>
       ）下运行以下命令以初始化 Composer 项目：
      </p>
      <pre>cd my_framework
composer init
</pre>
      <p>
       该命令会引导您完成
       <code>
        composer.json
       </code>
       文件的创建过程。
      </p>
     </li>
     <li>
      <p>
       安装所需的 Composer 包
      </p>
      <p>
       假设在控制器中使用一个日志库，例如 Monolog。运行以下命令来安装 Monolog：
      </p>
      <pre>composer require monolog/monolog
</pre>
      <p>
       这将下载 Monolog 并将其添加到
       <code>
        composer.json
       </code>
       的
       <code>
        require
       </code>
       部分，同时生成或更新
       <code>
        vendor/
       </code>
       目录和
       <code>
        autoload.php
       </code>
       文件。
      </p>
     </li>
    </ol>
    <hr/>
    <h3>
     2. 配置自动加载（Autoloading）
    </h3>
    <p>
     Composer 提供了强大的自动加载功能，可以根据
     <code>
      composer.json
     </code>
     中的配置自动加载框架类和控制器类。通过使用命名空间（Namespace），可以更好地组织和管理代码。
    </p>
    <h4>
     步骤：
    </h4>
    <ol>
     <li>
      <p>
       定义命名空间
      </p>
      <p>
       假设框架命名空间为
       <code>
        MyFramework
       </code>
       ，控制器命名空间为
       <code>
        MyFrameworkControllers
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       更新
       <code>
        composer.json
       </code>
      </p>
      <p>
       打开项目根目录下的
       <code>
        composer.json
       </code>
       文件，并添加
       <code>
        autoload
       </code>
       部分：
      </p>
      <pre><code class="hljs">{
    "name": "yourname/my_framework",
    "description": "A simple PHP framework example",
    "type": "project",
    "require": {
        "monolog/monolog": "^2.0"
    },
    "autoload": {
        "psr-4": {
            "MyFramework\": ""
        }
    }
}</code></pre>
      <p>
       说明：
      </p>
      <ul>
       <li>
        <p>
         psr-4：PSR-4 是一种自动加载标准，允许基于命名空间和目录结构自动加载类。
        </p>
       </li>
       <li>
        <p>
         <code>
          "MyFramework\": ""
         </code>
         ：表示命名空间
         <code>
          MyFramework
         </code>
         对应项目根目录。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       生成自动加载文件
      </p>
      <p>
       运行以下命令以更新 Composer 的自动加载配置：
      </p>
      <pre>composer dump-autoload
</pre>
      <p>
       这将生成或更新
       <code>
        vendor/autoload.php
       </code>
       文件，确保框架类和控制器类可以被自动加载。
      </p>
     </li>
    </ol>
    <hr/>
    <h3>
     3. 调整框架目录结构
    </h3>
    <p>
     为了更好地支持命名空间和自动加载，调整框架目录结构如下：
    </p>
    <pre>my_framework/
├── composer.json
├── composer.lock
├── vendor/
├── index.php
├── src/
│   ├── Router.php
│   └── Controller.php
└── src/Controllers/
    └── HomeController.php
</pre>
    <h4>
     说明：
    </h4>
    <ul>
     <li>
      <p>
       src/：存放框架的核心类。
      </p>
     </li>
     <li>
      <p>
       src/Controllers/：存放控制器类。
      </p>
     </li>
     <li>
      <p>
       命名空间对应目录结构：
       <code>
        MyFramework
       </code>
       对应
       <code>
        src/
       </code>
       ，
       <code>
        MyFrameworkControllers
       </code>
       对应
       <code>
        src/Controllers/
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     4. 在控制器中使用 Composer 包
    </h3>
    <p>
     现在，可以在控制器中使用通过 Composer 安装的包。以使用 Monolog 作为示例。
    </p>
    <h4>
     步骤：
    </h4>
    <ol>
     <li>
      <p>
       修改
       <code>
        index.php
       </code>
       以使用 Composer 自动加载
      </p>
      <pre><code class="hljs">&lt;?php
// index.php

// 启用错误报告（开发阶段使用，生产环境请关闭）
ini_set('display_errors', 1);
error_reporting(E_ALL);

// 自动加载 Composer 及框架类
require __DIR__ . '/vendor/autoload.php';

// 使用命名空间
use MyFrameworkRouter;

// 获取请求的 URI 和方法
$requestUri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$requestMethod = $_SERVER['REQUEST_METHOD'];

// 实例化路由器并添加路由
$router = new Router();

// 定义路由规则
$router-&gt;add('GET', '/', 'ControllersHomeController@index');
$router-&gt;add('GET', '/about', 'ControllersHomeController@about');
$router-&gt;add('POST', '/submit', 'ControllersHomeController@submit');

// 处理请求
$router-&gt;dispatch($requestMethod, $requestUri);
?&gt;</code></pre>
     </li>
     <li>
      <p>
       更新
       <code>
        Router.php
       </code>
       以使用命名空间
      </p>
      <p>
       创建
       <code>
        src/Router.php
       </code>
       并添加命名空间：
      </p>
      <pre><code class="hljs">&lt;?php
// src/Router.php

namespace MyFramework;

class Router
{
    private $routes = [];

    /**
     * 添加路由规则
     *
     * @param string $method HTTP 方法（GET, POST, etc.）
     * @param string $uri 请求的 URI
     * @param string $action 控制器和方法，例如 'HomeController@index'
     */
    public function add($method, $uri, $action)
    {
        $this-&gt;routes[] = [
            'method'  =&gt; strtoupper($method),
            'uri'     =&gt; $uri,
            'action'  =&gt; $action
        ];
    }

    /**
     * 分发请求到相应的控制器方法
     *
     * @param string $requestMethod HTTP 方法
     * @param string $requestUri 请求的 URI
     */
    public function dispatch($requestMethod, $requestUri)
    {
        foreach ($this-&gt;routes as $route) {
            if ($route['method'] === strtoupper($requestMethod) &amp;&amp; $route['uri'] === $requestUri) {
                $this-&gt;executeAction($route['action']);
                return;
            }
        }
        // 如果没有匹配的路由，返回 404
        $this-&gt;sendNotFound();
    }

    /**
     * 执行控制器的方法
     *
     * @param string $action 控制器和方法，例如 'HomeController@index'
     */
    private function executeAction($action)
    {
        list($controllerName, $method) = explode('@', $action);
        $fullControllerName = "MyFramework\Controllers\$controllerName";
        if (class_exists($fullControllerName)) {
            $controller = new $fullControllerName();
            if (method_exists($controller, $method)) {
                call_user_func([$controller, $method]);
                return;
            }
        }
        // 如果控制器或方法不存在，返回 404
        $this-&gt;sendNotFound();
    }

    /**
     * 发送 404 响应
     */
    private function sendNotFound()
    {
        header("HTTP/1.0 404 Not Found");
        echo "404 Not Found";
    }
}
?&gt;</code></pre>
     </li>
     <li>
      <p>
       更新
       <code>
        Controller.php
       </code>
       以使用命名空间
      </p>
      <p>
       创建
       <code>
        src/Controller.php
       </code>
       并添加命名空间：
      </p>
      <pre><code class="hljs">&lt;?php
// src/Controller.php

namespace MyFramework;

class Controller
{
    // 在这里可以添加公共的方法或属性
}
?&gt;</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       更新控制器类以使用 Composer 包
      </p>
      <p>
       创建
       <code>
        src/Controllers/HomeController.php
       </code>
       并使用 Monolog：
      </p>
      <pre><code class="hljs">&lt;?php
// src/Controllers/HomeController.php

namespace MyFrameworkControllers;

use MyFrameworkController;
use MonologLogger;
use MonologHandlerStreamHandler;

class HomeController extends Controller
{
    private $logger;

    public function __construct()
    {
        // 创建一个日志通道
        $this-&gt;logger = new Logger('home');
        $this-&gt;logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/../../logs/app.log', Logger::DEBUG));
    }

    /**
     * 主页方法
     */
    public function index()
    {
        $this-&gt;logger-&gt;info("访问主页");
        echo "&lt;h1&gt;欢迎来到主页！&lt;/h1&gt;";
    }

    /**
     * 关于页面方法
     */
    public function about()
    {
        $this-&gt;logger-&gt;info("访问关于页面");
        echo "&lt;h1&gt;关于我们&lt;/h1&gt;&lt;p&gt;这是关于页面。&lt;/p&gt;";
    }

    /**
     * 联系我们页面方法
     */
    public function contact()
    {
        $this-&gt;logger-&gt;info("访问联系我们页面");
        echo "&lt;h1&gt;联系我们&lt;/h1&gt;&lt;p&gt;这是联系我们页面。&lt;/p&gt;";
    }

    /**
     * 处理表单提交的方法
     */
    public function submit()
    {
        // 处理 POST 数据
        $data = $_POST;
        $this-&gt;logger-&gt;info("表单提交", $data);
        echo "&lt;h1&gt;表单已提交&lt;/h1&gt;";
        echo "&lt;pre&gt;";
        print_r($data);
        echo "&lt;/pre&gt;";
    }
}
?&gt;</code></pre>
      <p>
       说明：
      </p>
      <ul>
       <li>
        <p>
         Monolog 使用：在控制器构造函数中初始化 Monolog 记录器，并将日志写入
         <code>
          logs/app.log
         </code>
         文件。
        </p>
       </li>
       <li>
        <p>
         日志记录：在每个方法中记录访问日志和表单提交数据。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       创建日志目录
      </p>
      <p>
       为了让 Monolog 能够写入日志文件，需要创建一个
       <code>
        logs/
       </code>
       目录并确保 PHP 有写入权限。
      </p>
      <pre>mkdir logs
chmod 755 logs
</pre>
     </li>
    </ol>
    <hr/>
    <h3>
     5. 完整示例代码
    </h3>
    <p>
     以下是调整后的完整框架代码，包括 Composer 集成和使用 Monolog 的控制器。
    </p>
    <h4>
     目录结构
    </h4>
    <pre>my_framework/
├── composer.json
├── composer.lock
├── vendor/
├── index.php
├── src/
│   ├── Router.php
│   └── Controller.php
├── src/Controllers/
│   └── HomeController.php
└── logs/
    └── app.log
</pre>
    <h4>
     1.
     <code>
      composer.json
     </code>
    </h4>
    <p>
     初始化后可能类似于：
    </p>
    <pre><code class="hljs">{
    "name": "yourname/my_framework",
    "description": "A simple PHP framework example with Composer integration",
    "type": "project",
    "require": {
        "monolog/monolog": "^2.0"
    },
    "autoload": {
        "psr-4": {
            "MyFramework\": "src/"
        }
    }
}</code></pre>
    <h4>
     2.
     <code>
      index.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// index.php

// 启用错误报告（开发阶段使用，生产环境请关闭）
ini_set('display_errors', 1);
error_reporting(E_ALL);

// 自动加载 Composer 及框架类
require __DIR__ . '/vendor/autoload.php';

// 使用命名空间
use MyFrameworkRouter;

// 获取请求的 URI 和方法
$requestUri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$requestMethod = $_SERVER['REQUEST_METHOD'];

// 实例化路由器并添加路由
$router = new Router();

// 定义路由规则
$router-&gt;add('GET', '/', 'HomeController@index');
$router-&gt;add('GET', '/about', 'HomeController@about');
$router-&gt;add('GET', '/contact', 'HomeController@contact');
$router-&gt;add('POST', '/submit', 'HomeController@submit');

// 处理请求
$router-&gt;dispatch($requestMethod, $requestUri);
?&gt;</code></pre>
    <h4>
     3.
     <code>
      src/Router.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Router.php

namespace MyFramework;

class Router
{
    private $routes = [];

    /**
     * 添加路由规则
     *
     * @param string $method HTTP 方法（GET, POST, etc.）
     * @param string $uri 请求的 URI
     * @param string $action 控制器和方法，例如 'HomeController@index'
     */
    public function add($method, $uri, $action)
    {
        $this-&gt;routes[] = [
            'method'  =&gt; strtoupper($method),
            'uri'     =&gt; $uri,
            'action'  =&gt; $action
        ];
    }

    /**
     * 分发请求到相应的控制器方法
     *
     * @param string $requestMethod HTTP 方法
     * @param string $requestUri 请求的 URI
     */
    public function dispatch($requestMethod, $requestUri)
    {
        foreach ($this-&gt;routes as $route) {
            if ($route['method'] === strtoupper($requestMethod) &amp;&amp; $route['uri'] === $requestUri) {
                $this-&gt;executeAction($route['action']);
                return;
            }
        }
        // 如果没有匹配的路由，返回 404
        $this-&gt;sendNotFound();
    }

    /**
     * 执行控制器的方法
     *
     * @param string $action 控制器和方法，例如 'HomeController@index'
     */
    private function executeAction($action)
    {
        list($controllerName, $method) = explode('@', $action);
        $fullControllerName = "MyFramework\Controllers\$controllerName";
        if (class_exists($fullControllerName)) {
            $controller = new $fullControllerName();
            if (method_exists($controller, $method)) {
                call_user_func([$controller, $method]);
                return;
            }
        }
        // 如果控制器或方法不存在，返回 404
        $this-&gt;sendNotFound();
    }

    /**
     * 发送 404 响应
     */
    private function sendNotFound()
    {
        header("HTTP/1.0 404 Not Found");
        echo "404 Not Found";
    }
}
?&gt;</code></pre>
    <h4>
     4.
     <code>
      src/Controller.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Controller.php

namespace MyFramework;

class Controller
{
    // 在这里可以添加公共的方法或属性
}
?&gt;</code></pre>
    <h4>
     5.
     <code>
      src/Controllers/HomeController.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Controllers/HomeController.php

namespace MyFrameworkControllers;

use MyFrameworkController;
use MonologLogger;
use MonologHandlerStreamHandler;

class HomeController extends Controller
{
    private $logger;

    public function __construct()
    {
        // 创建一个日志通道
        $this-&gt;logger = new Logger('home');
        $this-&gt;logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/../../logs/app.log', Logger::DEBUG));
    }

    /**
     * 主页方法
     */
    public function index()
    {
        $this-&gt;logger-&gt;info("访问主页");
        echo "&lt;h1&gt;欢迎来到主页！&lt;/h1&gt;";
    }

    /**
     * 关于页面方法
     */
    public function about()
    {
        $this-&gt;logger-&gt;info("访问关于页面");
        echo "&lt;h1&gt;关于我们&lt;/h1&gt;&lt;p&gt;这是关于页面。&lt;/p&gt;";
    }

    /**
     * 联系我们页面方法
     */
    public function contact()
    {
        $this-&gt;logger-&gt;info("访问联系我们页面");
        echo "&lt;h1&gt;联系我们&lt;/h1&gt;&lt;p&gt;这是联系我们页面。&lt;/p&gt;";
    }

    /**
     * 处理表单提交的方法
     */
    public function submit()
    {
        // 处理 POST 数据
        $data = $_POST;
        $this-&gt;logger-&gt;info("表单提交", $data);
        echo "&lt;h1&gt;表单已提交&lt;/h1&gt;";
        echo "&lt;pre&gt;";
        print_r($data);
        echo "&lt;/pre&gt;";
    }
}
?&gt;</code></pre>
    <h4>
     6. 创建日志目录
    </h4>
    <p>
     确保有一个
     <code>
      logs/
     </code>
     目录，并且 PHP 有权限写入日志文件：
    </p>
    <pre>mkdir logs
chmod 755 logs
</pre>
    <hr/>
    <h3>
     6. 添加新路由和控制器
    </h3>
    <p>
     假设添加一个新的路由
     <code>
      /users
     </code>
     ，并调用一个新的控制器方法
     <code>
      UsersController@list
     </code>
     ，同时使用 Composer 安装的另一个包，例如 Guzzle HTTP 进行 HTTP 请求。
    </p>
    <h4>
     步骤：
    </h4>
    <ol>
     <li>
      <p>
       安装 Guzzle
      </p>
      <pre>composer require guzzlehttp/guzzle
</pre>
     </li>
     <li>
      <p>
       创建新的控制器
      </p>
      <p>
       创建
       <code>
        src/Controllers/UsersController.php
       </code>
       ：
      </p>
      <pre><code class="hljs">&lt;?php
// src/Controllers/UsersController.php

namespace MyFrameworkControllers;

use MyFrameworkController;
use GuzzleHttpClient;
use MonologLogger;
use MonologHandlerStreamHandler;

class UsersController extends Controller
{
    private $logger;
    private $client;

    public function __construct()
    {
        // 初始化日志
        $this-&gt;logger = new Logger('users');
        $this-&gt;logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/../../logs/app.log', Logger::DEBUG));

        // 初始化 Guzzle 客户端
        $this-&gt;client = new Client();
    }

    /**
     * 用户列表方法
     */
    public function list()
    {
        $this-&gt;logger-&gt;info("请求用户列表");

        try {
            // 示例：从外部 API 获取用户数据
            $response = $this-&gt;client-&gt;request('GET', 'https://jsonplaceholder.typicode.com/users');
            $users = json_decode($response-&gt;getBody(), true);

            echo "&lt;h1&gt;用户列表&lt;/h1&gt;";
            echo "&lt;ul&gt;";
            foreach ($users as $user) {
                echo "&lt;li&gt;" . htmlspecialchars($user['name']) . " (" . htmlspecialchars($user['email']) . ")&lt;/li&gt;";
            }
            echo "&lt;/ul&gt;";
        } catch (Exception $e) {
            $this-&gt;logger-&gt;error("获取用户列表失败", ['error' =&gt; $e-&gt;getMessage()]);
            echo "&lt;h1&gt;无法获取用户列表&lt;/h1&gt;";
        }
    }
}
?&gt;</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       添加新路由
      </p>
      <p>
       打开
       <code>
        index.php
       </code>
       并添加新路由：
      </p>
      <pre>// index.php 中的路由定义部分
$router-&gt;add('GET', '/users', 'UsersController@list');
</pre>
     </li>
     <li>
      <p>
       测试新路由
      </p>
      <p>
       重新启动 PHP 内置服务器（如果已经在运行，无需重新启动），然后访问 http://localhost:8000/users。您应该会看到一个用户列表，数据来自外部 API，并且操作被记录在
       <code>
        logs/app.log
       </code>
       文件中。
      </p>
     </li>
    </ol>
    <hr/>
    <h3>
     7. 完整代码示例
    </h3>
    <p>
     以下是更新后的完整框架代码，包括 Composer 集成和在控制器中使用 Composer 包的示例。
    </p>
    <h4>
     目录结构
    </h4>
    <pre>my_framework/
├── composer.json
├── composer.lock
├── vendor/
├── index.php
├── src/
│   ├── Router.php
│   └── Controller.php
├── src/Controllers/
│   ├── HomeController.php
│   └── UsersController.php
└── logs/
    └── app.log
</pre>
    <h4>
     1.
     <code>
      composer.json
     </code>
    </h4>
    <pre><code class="hljs">{
    "name": "yourname/my_framework",
    "description": "A simple PHP framework example with Composer integration",
    "type": "project",
    "require": {
        "monolog/monolog": "^2.0",
        "guzzlehttp/guzzle": "^7.0"
    },
    "autoload": {
        "psr-4": {
            "MyFramework\": "src/"
        }
    }
}</code></pre>
    <h4>
     2.
     <code>
      index.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// index.php

// 启用错误报告（开发阶段使用，生产环境请关闭）
ini_set('display_errors', 1);
error_reporting(E_ALL);

// 自动加载 Composer 及框架类
require __DIR__ . '/vendor/autoload.php';

// 使用命名空间
use MyFrameworkRouter;

// 获取请求的 URI 和方法
$requestUri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$requestMethod = $_SERVER['REQUEST_METHOD'];

// 实例化路由器并添加路由
$router = new Router();

// 定义路由规则
$router-&gt;add('GET', '/', 'HomeController@index');
$router-&gt;add('GET', '/about', 'HomeController@about');
$router-&gt;add('GET', '/contact', 'HomeController@contact');
$router-&gt;add('POST', '/submit', 'HomeController@submit');
$router-&gt;add('GET', '/users', 'UsersController@list'); // 新增用户列表路由

// 处理请求
$router-&gt;dispatch($requestMethod, $requestUri);
?&gt;</code></pre>
    <h4>
     3.
     <code>
      src/Router.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Router.php

namespace MyFramework;

class Router
{
    private $routes = [];

    /**
     * 添加路由规则
     *
     * @param string $method HTTP 方法（GET, POST, etc.）
     * @param string $uri 请求的 URI
     * @param string $action 控制器和方法，例如 'HomeController@index'
     */
    public function add($method, $uri, $action)
    {
        $this-&gt;routes[] = [
            'method'  =&gt; strtoupper($method),
            'uri'     =&gt; $uri,
            'action'  =&gt; $action
        ];
    }

    /**
     * 分发请求到相应的控制器方法
     *
     * @param string $requestMethod HTTP 方法
     * @param string $requestUri 请求的 URI
     */
    public function dispatch($requestMethod, $requestUri)
    {
        foreach ($this-&gt;routes as $route) {
            if ($route['method'] === strtoupper($requestMethod) &amp;&amp; $route['uri'] === $requestUri) {
                $this-&gt;executeAction($route['action']);
                return;
            }
        }
        // 如果没有匹配的路由，返回 404
        $this-&gt;sendNotFound();
    }

    /**
     * 执行控制器的方法
     *
     * @param string $action 控制器和方法，例如 'HomeController@index'
     */
    private function executeAction($action)
    {
        list($controllerName, $method) = explode('@', $action);
        $fullControllerName = "MyFramework\Controllers\$controllerName";
        if (class_exists($fullControllerName)) {
            $controller = new $fullControllerName();
            if (method_exists($controller, $method)) {
                call_user_func([$controller, $method]);
                return;
            }
        }
        // 如果控制器或方法不存在，返回 404
        $this-&gt;sendNotFound();
    }

    /**
     * 发送 404 响应
     */
    private function sendNotFound()
    {
        header("HTTP/1.0 404 Not Found");
        echo "404 Not Found";
    }
}
?&gt;</code></pre>
    <h4>
     4.
     <code>
      src/Controller.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Controller.php

namespace MyFramework;

class Controller
{
    // 在这里可以添加公共的方法或属性
}
?&gt;</code></pre>
    <h4>
     5.
     <code>
      src/Controllers/HomeController.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Controllers/HomeController.php

namespace MyFrameworkControllers;

use MyFrameworkController;
use MonologLogger;
use MonologHandlerStreamHandler;

class HomeController extends Controller
{
    private $logger;

    public function __construct()
    {
        // 创建一个日志通道
        $this-&gt;logger = new Logger('home');
        $this-&gt;logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/../../logs/app.log', Logger::DEBUG));
    }

    /**
     * 主页方法
     */
    public function index()
    {
        $this-&gt;logger-&gt;info("访问主页");
        echo "&lt;h1&gt;欢迎来到主页！&lt;/h1&gt;";
    }

    /**
     * 关于页面方法
     */
    public function about()
    {
        $this-&gt;logger-&gt;info("访问关于页面");
        echo "&lt;h1&gt;关于我们&lt;/h1&gt;&lt;p&gt;这是关于页面。&lt;/p&gt;";
    }

    /**
     * 联系我们页面方法
     */
    public function contact()
    {
        $this-&gt;logger-&gt;info("访问联系我们页面");
        echo "&lt;h1&gt;联系我们&lt;/h1&gt;&lt;p&gt;这是联系我们页面。&lt;/p&gt;";
    }

    /**
     * 处理表单提交的方法
     */
    public function submit()
    {
        // 处理 POST 数据
        $data = $_POST;
        $this-&gt;logger-&gt;info("表单提交", $data);
        echo "&lt;h1&gt;表单已提交&lt;/h1&gt;";
        echo "&lt;pre&gt;";
        print_r($data);
        echo "&lt;/pre&gt;";
    }
}
?&gt;</code></pre>
    <h4>
     6.
     <code>
      src/Controllers/UsersController.php
     </code>
    </h4>
    <pre><code class="hljs">&lt;?php
// src/Controllers/UsersController.php

namespace MyFrameworkControllers;

use MyFrameworkController;
use GuzzleHttpClient;
use MonologLogger;
use MonologHandlerStreamHandler;

class UsersController extends Controller
{
    private $logger;
    private $client;

    public function __construct()
    {
        // 初始化日志
        $this-&gt;logger = new Logger('users');
        $this-&gt;logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/../../logs/app.log', Logger::DEBUG));

        // 初始化 Guzzle 客户端
        $this-&gt;client = new Client();
    }

    /**
     * 用户列表方法
     */
    public function list()
    {
        $this-&gt;logger-&gt;info("请求用户列表");

        try {
            // 示例：从外部 API 获取用户数据
            $response = $this-&gt;client-&gt;request('GET', 'https://jsonplaceholder.typicode.com/users');
            $users = json_decode($response-&gt;getBody(), true);

            echo "&lt;h1&gt;用户列表&lt;/h1&gt;";
            echo "&lt;ul&gt;";
            foreach ($users as $user) {
                echo "&lt;li&gt;" . htmlspecialchars($user['name']) . " (" . htmlspecialchars($user['email']) . ")&lt;/li&gt;";
            }
            echo "&lt;/ul&gt;";
        } catch (Exception $e) {
            $this-&gt;logger-&gt;error("获取用户列表失败", ['error' =&gt; $e-&gt;getMessage()]);
            echo "&lt;h1&gt;无法获取用户列表&lt;/h1&gt;";
        }
    }
}
?&gt;</code></pre>
    <h4>
     7. 创建日志目录
    </h4>
    <p>
     确保有一个
     <code>
      logs/
     </code>
     目录，并且 PHP 有权限写入日志文件：
    </p>
    <pre>mkdir logs
chmod 755 logs
</pre>
    <hr/>
    <h3>
     8. 测试框架
    </h3>
    <ol>
     <li>
      <p>
       启动本地服务器
      </p>
      <p>
       使用 PHP 内置服务器进行测试。在项目根目录下运行以下命令：
      </p>
      <pre>php -S localhost:8000
</pre>
     </li>
     <li>
      <p>
       访问不同的路由
      </p>
      <ul>
       <li>
        <p>
         主页: http://localhost:8000/
        </p>
       </li>
       <li>
        <p>
         关于页面: http://localhost:8000/about
        </p>
       </li>
       <li>
        <p>
         联系我们页面: http://localhost:8000/contact
        </p>
       </li>
       <li>
        <p>
         用户列表页面: http://localhost:8000/users
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       测试表单提交
      </p>
      <p>
       创建一个简单的 HTML 表单，提交到
       <code>
        /submit
       </code>
       。
      </p>
      <pre><code class="hljs">&lt;!-- save as form.html in project root --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;表单提交&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;提交表单&lt;/h1&gt;
    &lt;form action="/submit" method="POST"&gt;
        &lt;label for="name"&gt;姓名:&lt;/label&gt;
        &lt;input type="text" id="name" name="name" required&gt;&lt;br&gt;&lt;br&gt;
        &lt;label for="email"&gt;邮箱:&lt;/label&gt;
        &lt;input type="email" id="email" name="email" required&gt;&lt;br&gt;&lt;br&gt;
        &lt;button type="submit"&gt;提交&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p>
       然后访问 http://localhost:8000/form.html，填写表单并提交，将看到提交的数据被输出，并且日志记录在
       <code>
        logs/app.log
       </code>
       文件中。
      </p>
     </li>
    </ol>
    <hr/>
    <h3>
     9. 总结
    </h3>
    <p>
     通过以上步骤，已经成功地将 Composer 集成到自定义 PHP 框架中，并在控制器类中使用了 Composer 安装的包（如 Monolog 和 Guzzle）。以下是关键点的回顾：
    </p>
    <ol>
     <li>
      <p>
       Composer 初始化：使用
       <code>
        composer init
       </code>
       初始化项目，并通过
       <code>
        composer require
       </code>
       安装所需的包。
      </p>
     </li>
     <li>
      <p>
       自动加载配置：在
       <code>
        composer.json
       </code>
       中配置
       <code>
        autoload
       </code>
       ，并使用 PSR-4 标准组织代码。
      </p>
     </li>
     <li>
      <p>
       命名空间使用：通过定义命名空间，使类的组织更为规范，并利用 Composer 的自动加载功能简化类的引入。
      </p>
     </li>
     <li>
      <p>
       控制器集成 Composer 包：在控制器中引入和使用 Composer 安装的包，扩展框架的功能。
      </p>
     </li>
     <li>
      <p>
       日志记录与外部 API：示例展示了如何使用 Monolog 记录日志，以及如何使用 Guzzle 进行外部 HTTP 请求。
      </p>
     </li>
    </ol>
    <h4>
     进一步扩展
    </h4>
    <p>
     为了使框架更加完善，可以考虑以下扩展：
    </p>
    <ul>
     <li>
      <p>
       动态路由支持：支持带参数的动态路由，如
       <code>
        /user/{id}
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       中间件机制：添加中间件以处理认证、授权、日志记录等功能。
      </p>
     </li>
     <li>
      <p>
       视图模板集成：集成模板引擎（如 Twig 或 Blade）以分离视图和逻辑。
      </p>
     </li>
     <li>
      <p>
       依赖注入容器：实现或集成依赖注入容器，提高代码的可测试性和可维护性。
      </p>
     </li>
     <li>
      <p>
       错误和异常处理：实现统一的错误和异常处理机制，提供友好的错误页面。
      </p>
     </li>
    </ul>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f54696e6159754e756f2f:61727469636c652f64657461696c732f313436323439323536" class_="artid" style="display:none">
 </p>
</div>


