---
layout: post
title: "iOS底层原理系列02-深入了解Objective-C"
date: 2025-03-13 00:28:35 +0800
description: "对于自定义类，其内存结构会更复杂，包含从父类继承的变量和自己声明的变量。int _age;@end包含从NSObject继承的isa指针（8字节）包含一个int类型变量_age（4字节）包含一个double类型变量_height（8字节）包含一个NSString*类型的_name指针（由于@property自动合成，8字节）理论上总大小为：8 + 4 + 8 + 8 = 28字节。但实际分配会考虑内存对齐，可能会是32字节。特性+load调用时机程序启动加载类和分类时。"
keywords: "iOS底层原理系列02-深入了解Objective-C"
categories: ['Ios']
tags: ['Ios', 'Cocoa', 'C']
artid: "146218631"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146218631
    alt: "iOS底层原理系列02-深入了解Objective-C"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146218631
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146218631
cover: https://bing.ee123.net/img/rand?artid=146218631
image: https://bing.ee123.net/img/rand?artid=146218631
img: https://bing.ee123.net/img/rand?artid=146218631
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     iOS底层原理系列02-深入了解Objective-C
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="1_ObjectiveC_0">
     </a>
     1. Objective-C的本质
    </h2>
    <p>
     用Objective-C编写的代码，底层其实都是C\C++代码
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/12515c3c54b649c3b5122d80035b4fc1.png#pic_center"/>
    </p>
    <p>
     所以Objective-C面向对象都是基于 C\C++的数据结构(结构体)实现的。
    </p>
    <p>
     Objective-C并非像其他语言那样在编译期完全确定程序的行为，而是将许多决策推迟到运行时进行，这种特性被称为
     <strong>
      动态性
     </strong>
     ，这是其区别于C++等静态语言的关键特性。
    </p>
    <p>
     Objective-C的动态特性由
     <strong>
      Runtime
     </strong>
     系统提供支持。Runtime系统是一套C和汇编编写的API，是Objective-C面向对象和动态特性的基础。
    </p>
    <pre><code class="prism language-c"><span class="token comment">// Objective-C程序最终会被编译为C语言代码</span>
<span class="token comment">// 例如，一个简单的方法调用</span>
<span class="token punctuation">[</span>object method<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 会被编译为</span>
<span class="token function">objc_msgSend</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> @<span class="token function">selector</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     这种消息发送机制（而非直接的函数调用）赋予了Objective-C强大的动态特性和灵活性。
    </p>
    <h2>
     <a id="2_OC_24">
     </a>
     2. OC对象
    </h2>
    <h3>
     <a id="21__26">
     </a>
     2.1 本质
    </h3>
    <p>
     Objective-C对象在底层实际上是一个结构体，这个结构体的定义在runtime源码中：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">objc_object</span> <span class="token punctuation">{<!-- --></span>
    Class isa<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">objc_object</span> <span class="token operator">*</span>id<span class="token punctuation">;</span>
</code></pre>
    <p>
     所有OC对象都包含一个
     <code>
      isa
     </code>
     指针，指向该对象所属的类。这个
     <code>
      isa
     </code>
     指针是实现OC运行时动态特性的关键。
    </p>
    <h3>
     <a id="22_OC_40">
     </a>
     2.2 OC对象的种类
    </h3>
    <h4>
     <a id="221_instance_42">
     </a>
     2.2.1 instance对象
    </h4>
    <p>
     Instance对象就是我们平时编程中最常见的实例对象。ininstance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象。
    </p>
    <pre><code class="prism language-objective-c">NSObject *obj = [[NSObject alloc] init];
</code></pre>
    <p>
     这里的
     <code>
      obj
     </code>
     就是一个instance对象。
    </p>
    <p>
     instance对象存储着：
    </p>
    <ul>
     <li>
      isa指针
     </li>
     <li>
      其他成员变量
     </li>
    </ul>
    <h4>
     <a id="222_class_57">
     </a>
     2.2.2 class对象
    </h4>
    <p>
     Class对象是由编译器创建的，每个类只有一个Class对象。获取Class对象的方法有：
    </p>
    <pre><code class="prism language-objective-c">// 方法1：通过类名获取
Class cls1 = [NSObject class];

// 方法2：通过实例对象获取
NSObject *obj = [[NSObject alloc] init];
Class cls2 = [obj class];

// 方法3：通过runtime方法获取
Class cls3 = object_getClass(obj);
</code></pre>
    <p>
     Class对象存储着：
    </p>
    <ul>
     <li>
      isa指针
     </li>
     <li>
      superClass指针
     </li>
     <li>
      实例方法列表（instance method）
     </li>
     <li>
      成员变量列表（ivar）
     </li>
     <li>
      协议列表（protocol）
     </li>
     <li>
      属性列表（@property）
     </li>
    </ul>
    <h4>
     <a id="223_metaclass_82">
     </a>
     2.2.3 meta-class对象（元类对象）
    </h4>
    <p>
     Meta-Class对象也是一个Class对象，每个类在内存中有且只有一个meta-class对象。
    </p>
    <p>
     Meta-Class存储着：
    </p>
    <ul>
     <li>
      isa指针
     </li>
     <li>
      superClass指针
     </li>
     <li>
      类方法列表
     </li>
     <li>
      类属性列表
     </li>
    </ul>
    <p>
     获取Meta-Class对象：
    </p>
    <pre><code class="prism language-objective-c">Class cls = [NSObject class];
Class metaCls = object_getClass(cls);
</code></pre>
    <h2>
     <a id="3_isa_100">
     </a>
     3. isa指针与类指针链
    </h2>
    <p>
     OC中的对象结构通过isa指针形成了一个完整的指针链。这个指针链是OC面向对象实现和消息传递机制的基础。
    </p>
    <h3>
     <a id="31_isa_104">
     </a>
     3.1 isa指针
    </h3>
    <p>
     在OC中，每个对象都有一个isa指针，指向该对象的类信息。但实际上，在64位架构中，isa指针进行了优化，不再是直接指向Class对象的指针，而是使用了一种叫做
     <strong>
      指针位域
     </strong>
     的技术，即用一个64位的值来存储更多信息。
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 简化的64位架构isa定义</span>
<span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uintptr_t</span> nonpointer        <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否启用指针位域优化</span>
    <span class="token class-name">uintptr_t</span> has_assoc         <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否有关联对象</span>
    <span class="token class-name">uintptr_t</span> has_cxx_dtor      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否有C++析构函数</span>
    <span class="token class-name">uintptr_t</span> shiftcls          <span class="token operator">:</span> <span class="token number">33</span><span class="token punctuation">;</span> <span class="token comment">// 存储Class、Meta-Class信息</span>
    <span class="token comment">// ...其他位域</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     从64bit开始，isa需要进行一次位运算，才能计算Class指针的真实地址，需要进行位运算：
    </p>
    <pre><code class="prism language-objective-c">Class cls = object_getClass(obj);
// 实际底层会进行位运算提取class指针
// 伪代码：isa &amp; ISA_MASK
</code></pre>
    <h3>
     <a id="32__127">
     </a>
     3.2 类指针链
    </h3>
    <p>
     Objective-C中的类指针链主要有两条：
    </p>
    <ol>
     <li>
      <strong>
       isa指针链
      </strong>
      ：实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向根元类对象（通常是NSObject的元类）。根元类对象的isa指向自己，形成闭环。
     </li>
     <li>
      <strong>
       superclass指针链
      </strong>
      ：子类的superclass指向父类，直到根类（通常是NSObject），根类的superclass为nil。而元类的superclass指向父类的元类，根元类的superclass指向根类对象。
     </li>
    </ol>
    <p>
     这两条链共同构成了Objective-C的继承体系和消息传递机制的基础。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8c06b73656bf4d3d8f7192fdf71453f2.png#pic_center"/>
    </p>
    <h2>
     <a id="4__137">
     </a>
     4. 类与对象的内存结构
    </h2>
    <p>
     为了深入理解OC的对象模型，我们需要了解其内存结构。
    </p>
    <h3>
     <a id="41_NSObject_141">
     </a>
     4.1 NSObject对象的内存结构
    </h3>
    <p>
     NSObject是OC中的根类，大多数OC类都继承自NSObject。NSObject的定义非常简单：
    </p>
    <pre><code class="prism language-objective-c">@interface NSObject &lt;NSObject&gt; {
    Class isa;
}
// 方法声明...
@end
</code></pre>
    <p>
     从这个定义可以看出，NSObject只包含一个Class类型的isa指针。所以，一个NSObject实例对象的大小就是一个指针的大小：在64位系统上是8字节，在32位系统上是4字节。
    </p>
    <p>
     验证NSObject对象大小：
    </p>
    <pre><code class="prism language-objective-c">NSObject *obj = [[NSObject alloc] init];
NSLog(@"NSObject实例对象大小：%zd", class_getInstanceSize([NSObject class]));
NSLog(@"NSObject实际分配大小：%zd", malloc_size((__bridge const void *)obj));
</code></pre>
    <p>
     这两个打印结果可能不同：
    </p>
    <ul>
     <li>
      <code>
       class_getInstanceSize
      </code>
      返回理论上的大小（8字节）
     </li>
     <li>
      <code>
       malloc_size
      </code>
      返回实际分配的大小（可能是16字节）
     </li>
    </ul>
    <p>
     这是因为内存分配遵循内存对齐规则，且系统会分配一个更合理的内存大小来存储对象。
    </p>
    <h3>
     <a id="42__170">
     </a>
     4.2 自定义类的内存结构
    </h3>
    <p>
     对于自定义类，其内存结构会更复杂，包含从父类继承的变量和自己声明的变量。
    </p>
    <pre><code class="prism language-objective-c">@interface Person : NSObject {
    int _age;
    double _height;
}
@property (nonatomic, copy) NSString *name;
@end
</code></pre>
    <p>
     对于上面的Person类：
    </p>
    <ul>
     <li>
      包含从NSObject继承的isa指针（8字节）
     </li>
     <li>
      包含一个int类型变量_age（4字节）
     </li>
     <li>
      包含一个double类型变量_height（8字节）
     </li>
     <li>
      包含一个NSString*类型的_name指针（由于@property自动合成，8字节）
     </li>
    </ul>
    <p>
     理论上总大小为：8 + 4 + 8 + 8 = 28字节。但实际分配会考虑内存对齐，可能会是32字节。
    </p>
    <h3>
     <a id="43__192">
     </a>
     4.3 类对象的内存结构
    </h3>
    <p>
     类对象（Class）是一个复杂的结构，在runtime源码中定义如下：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">objc_class</span> <span class="token punctuation">{<!-- --></span>
    Class isa<span class="token punctuation">;</span>  <span class="token comment">// 指向Meta-Class</span>
    Class superclass<span class="token punctuation">;</span>  <span class="token comment">// 指向父类</span>
    <span class="token class-name">cache_t</span> cache<span class="token punctuation">;</span>  <span class="token comment">// 方法缓存</span>
    <span class="token class-name">class_data_bits_t</span> bits<span class="token punctuation">;</span>  <span class="token comment">// 存储类的详细信息</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     其中的
     <code>
      bits
     </code>
     成员是一个指向类详细信息的指针，包含：
    </p>
    <ul>
     <li>
      方法列表
     </li>
     <li>
      协议列表
     </li>
     <li>
      属性列表
     </li>
     <li>
      实例变量布局
     </li>
    </ul>
    <h2>
     <a id="5__212">
     </a>
     5. 内存布局与对齐规则
    </h2>
    <h3>
     <a id="51__214">
     </a>
     5.1 内存对齐
    </h3>
    <p>
     内存对齐是CPU访问内存的规则，合理的内存对齐可以提高内存访问效率。
    </p>
    <p>
     OC中的内存对齐规则遵循C语言的规定：
    </p>
    <ol>
     <li>
      每个成员变量的地址必须是其自身大小的整数倍
     </li>
     <li>
      整个结构体的大小必须是其最大成员变量大小的整数倍
     </li>
    </ol>
    <p>
     例如，对于以下结构体：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Example</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> a<span class="token punctuation">;</span>     <span class="token comment">// 1字节</span>
    <span class="token keyword">double</span> b<span class="token punctuation">;</span>   <span class="token comment">// 8字节</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>      <span class="token comment">// 4字节</span>
    <span class="token keyword">short</span> d<span class="token punctuation">;</span>    <span class="token comment">// 2字节</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     在64位系统上，其内存布局为：
    </p>
    <ul>
     <li>
      a: 占用1字节，但会因为b的对齐要求补齐到8字节
     </li>
     <li>
      b: 占用8字节
     </li>
     <li>
      c: 占用4字节
     </li>
     <li>
      d: 占用2字节，但会因为整体对齐要求补齐到8字节
     </li>
    </ul>
    <p>
     因此总大小为24字节，而非理论上的15字节。
    </p>
    <h3>
     <a id="52_OC_243">
     </a>
     5.2 OC对象的内存布局
    </h3>
    <p>
     OC使用Compact Model来优化对象的内存布局，即尽可能将小的实例变量放在一起，减少因对齐导致的内存浪费。
    </p>
    <p>
     例如，对于以下类：
    </p>
    <pre><code class="prism language-objective-c">@interface OptimizedLayout : NSObject {
    char a;
    int b;
    short c;
    double d;
}
@end
</code></pre>
    <p>
     编译器会重新排列这些变量的顺序，以最大限度地减少内存浪费：
    </p>
    <pre><code>isa (8字节)
d (8字节)
b (4字节)
c (2字节)
a (1字节)
padding (1字节，保证整体为8的倍数)
</code></pre>
    <p>
     可以通过runtime API查看实例变量的内存布局：
    </p>
    <pre><code class="prism language-objective-c">unsigned int count;
Ivar *ivars = class_copyIvarList([OptimizedLayout class], &amp;count);
for (int i = 0; i &lt; count; i++) {
    Ivar ivar = ivars[i];
    NSLog(@"%s offset: %td", ivar_getName(ivar), ivar_getOffset(ivar));
}
free(ivars);
</code></pre>
    <h2>
     <a id="6_Category_282">
     </a>
     6. Category（分类）
    </h2>
    <p>
     Category是Objective-C中一个强大的特性，允许开发者向现有类添加方法，而无需继承或修改原始类的源代码。
    </p>
    <h3>
     <a id="61_Category_286">
     </a>
     6.1 Category的底层结构
    </h3>
    <p>
     在Runtime中，Category被定义为
     <code>
      struct category_t
     </code>
     结构体：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">category_t</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>  <span class="token comment">// 类名</span>
    <span class="token class-name">classref_t</span> cls<span class="token punctuation">;</span>    <span class="token comment">// 类引用</span>
    <span class="token keyword">struct</span> <span class="token class-name">method_list_t</span> <span class="token operator">*</span>instanceMethods<span class="token punctuation">;</span>  <span class="token comment">// 实例方法列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">method_list_t</span> <span class="token operator">*</span>classMethods<span class="token punctuation">;</span>     <span class="token comment">// 类方法列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">protocol_list_t</span> <span class="token operator">*</span>protocols<span class="token punctuation">;</span>      <span class="token comment">// 协议列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">property_list_t</span> <span class="token operator">*</span>instanceProperties<span class="token punctuation">;</span>  <span class="token comment">// 实例属性列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">property_list_t</span> <span class="token operator">*</span>_classProperties<span class="token punctuation">;</span>    <span class="token comment">// 类属性列表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     注意，这个结构体中没有定义实例变量列表。这就是为什么Category
     <strong>
      不能直接添加实例变量
     </strong>
     ，但可以添加方法、属性和协议。
    </p>
    <p>
     为什么不设计实例变量列表？
    </p>
    <ul>
     <li>
      <p>
       <strong>
        内存布局问题
       </strong>
       ：Category 是在运行时添加到已有类上的，当 Category 加载时，原始类的内存布局已经确定。如果允许 Category 添加实例变量，会改变类对象的内存布局，这会导致已存在的对象实例内存结构无法兼容。
      </p>
     </li>
     <li>
      <p>
       <strong>
        设计目的不同
       </strong>
       ：Category 的主要目的是扩展类的行为（添加方法），而不是修改类的结构。这是 OC 语言设计的一个权衡
      </p>
     </li>
    </ul>
    <h3>
     <a id="62_Category_310">
     </a>
     6.2 Category的加载处理过程
    </h3>
    <p>
     Category的加载过程是由runtime在启动时完成的，主要步骤如下：
    </p>
    <ul>
     <li>
      通过Runtime加载某个类的所有Category数据
     </li>
     <li>
      把所有的Category的方法、属性、协议合并到一个大数组中，后面参与编译的Category数据会在数组前面
     </li>
     <li>
      将合并后的分类数据插入到原类的方法列表前面。
     </li>
    </ul>
    <p>
     这也是为什么Category中的方法能够覆盖原类方法的原因 - 因为它们会被放在方法列表前面，先被查找到。
    </p>
    <h3>
     <a id="63__320">
     </a>
     6.3 如何给分类加成员变量
    </h3>
    <p>
     虽然Category不能直接添加实例变量，但可以通过
     <strong>
      关联对象
     </strong>
     （Associated Objects）间接实现类似的功能。
    </p>
    <pre><code class="prism language-objective-c">// Person+Extension.h
@interface Person (Extension)
@property (nonatomic, copy) NSString *nickname;
@end

// Person+Extension.m
#import &lt;objc/runtime.h&gt;

static char NicknameKey;

@implementation Person (Extension)
- (void)setNickname:(NSString *)nickname {
    objc_setAssociatedObject(self, &amp;NicknameKey, nickname, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (NSString *)nickname {
    return objc_getAssociatedObject(self, &amp;NicknameKey);
}
@end
</code></pre>
    <h3>
     <a id="64__346">
     </a>
     6.4 关联对象的原理
    </h3>
    <p>
     关联对象的原理是通过一个全局的哈希表（AssociationsHashMap）来存储关联对象，该哈希表以
     <strong>
      对象的地址
     </strong>
     为键，对应一个二级哈希表（ObjectAssociationMap），二级哈希表以
     <strong>
      关联的key
     </strong>
     为键，AssociationValue为值。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3ef819697cd543a982779e1b26949669.png#pic_center"/>
    </p>
    <p>
     关联对象的实现依赖以下关键函数：
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 设置关联对象</span>
<span class="token keyword">void</span> <span class="token function">objc_setAssociatedObject</span><span class="token punctuation">(</span>id object<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> id value<span class="token punctuation">,</span> objc_AssociationPolicy policy<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取关联对象</span>
id <span class="token function">objc_getAssociatedObject</span><span class="token punctuation">(</span>id object<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 移除所有关联对象</span>
<span class="token keyword">void</span> <span class="token function">objc_removeAssociatedObjects</span><span class="token punctuation">(</span>id object<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     关联策略（objc_AssociationPolicy）决定了关联对象的存储和内存管理方式，类似于属性特性：
    </p>
    <ul>
     <li>
      <code>
       OBJC_ASSOCIATION_ASSIGN
      </code>
      ：弱引用，不持有关联对象
     </li>
     <li>
      <code>
       OBJC_ASSOCIATION_RETAIN_NONATOMIC
      </code>
      ：强引用，非原子性
     </li>
     <li>
      <code>
       OBJC_ASSOCIATION_COPY_NONATOMIC
      </code>
      ：复制，非原子性
     </li>
     <li>
      <code>
       OBJC_ASSOCIATION_RETAIN
      </code>
      ：强引用，原子性
     </li>
     <li>
      <code>
       OBJC_ASSOCIATION_COPY
      </code>
      ：复制，原子性
     </li>
    </ul>
    <p>
     注意：关联对象是在对象层面而非类层面，因此即使通过关联对象实现的属性，其行为和真正的实例变量还是有差异的。此外，它们在内存上的管理也是独立的，不会随着对象释放自动移除，需要显式调用
     <code>
      objc_removeAssociatedObjects
     </code>
     。
    </p>
    <h2>
     <a id="7_loadinitialize_375">
     </a>
     7. load和initialize的区别
    </h2>
    <p>
     <code>
      +load
     </code>
     和
     <code>
      +initialize
     </code>
     是OC中两个重要的类方法，用于类的初始化，但它们的调用时机和特点存在显著差异。
    </p>
    <h3>
     <a id="71_load_379">
     </a>
     7.1 +load方法
    </h3>
    <p>
     <code>
      +load
     </code>
     方法在程序启动加载类和分类时调用。特点：
    </p>
    <ol>
     <li>
      在
      <code>
       main()
      </code>
      函数执行前调用
     </li>
     <li>
      每个类和分类的
      <code>
       +load
      </code>
      方法只会调用一次
     </li>
    </ol>
    <p>
     调用顺序：
    </p>
    <ol>
     <li>
      父类的
      <code>
       +load
      </code>
      方法会在子类之前调用
     </li>
     <li>
      分类的
      <code>
       +load
      </code>
      方法会在类的
      <code>
       +load
      </code>
      方法之后调用
     </li>
     <li>
      通过
      <strong>
       函数地址直接调用
      </strong>
      ，不走消息发送机制
     </li>
    </ol>
    <pre><code class="prism language-objective-c">+ (void)load {
    NSLog(@"%@ +load", self);
}
</code></pre>
    <h3>
     <a id="72_initialize_398">
     </a>
     7.2 +initialize方法
    </h3>
    <p>
     <code>
      +initialize
     </code>
     方法在类第一次接收到消息时调用。特点：
    </p>
    <ol>
     <li>
      懒加载，在类第一次收到消息时调用，而非程序启动时
     </li>
     <li>
      由于懒加载特性，可能永远不会被调用
     </li>
     <li>
      遵循继承规则，如果子类没有实现，会调用父类的实现
     </li>
     <li>
      通过
      <strong>
       消息发送
      </strong>
      调用，遵循消息发送机制
     </li>
     <li>
      每个类只会初始化一次，但父类的
      <code>
       +initialize
      </code>
      可能被调用多次（当子类没有实现时）
     </li>
     <li>
      如果分类实现了
      <code>
       +initialize
      </code>
      ，会覆盖原类的
      <code>
       +initialize
      </code>
     </li>
    </ol>
    <pre><code class="prism language-objective-c">+ (void)initialize {
    if (self == [MyClass class]) {
        // 确保只在本类而非子类调用时执行
        NSLog(@"%@ +initialize", self);
    }
}
</code></pre>
    <h3>
     <a id="73__418">
     </a>
     7.3 对比总结
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        +load
       </th>
       <th>
        +initialize
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        调用时机
       </td>
       <td>
        程序启动加载类和分类时
       </td>
       <td>
        第一次向类发送消息时
       </td>
      </tr>
      <tr>
       <td>
        调用方式
       </td>
       <td>
        直接函数调用
       </td>
       <td>
        消息发送
       </td>
      </tr>
      <tr>
       <td>
        调用顺序
       </td>
       <td>
        父类-&gt;子类-&gt;分类
       </td>
       <td>
        不确定
       </td>
      </tr>
      <tr>
       <td>
        是否必被调用
       </td>
       <td>
        是
       </td>
       <td>
        否（懒加载）
       </td>
      </tr>
      <tr>
       <td>
        继承性
       </td>
       <td>
        不遵循继承规则
       </td>
       <td>
        遵循继承规则
       </td>
      </tr>
      <tr>
       <td>
        线程安全
       </td>
       <td>
        保证线程安全
       </td>
       <td>
        不保证线程安全
       </td>
      </tr>
      <tr>
       <td>
        应用场景
       </td>
       <td>
        无需考虑依赖关系的纯粹初始化
       </td>
       <td>
        需要用到runtime信息的初始化工作
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="8_KVOKVC_430">
     </a>
     8. KVO和KVC
    </h2>
    <p>
     KVO（Key-Value Observing）和KVC（Key-Value Coding）是OC中两个强大的设计模式，为开发者提供了处理对象属性的灵活方式。
    </p>
    <h3>
     <a id="81_KVOKeyValue_Observing_434">
     </a>
     8.1 KVO（Key-Value Observing）
    </h3>
    <p>
     KVO的全称是Key-Value Observing，俗称“键值监听”，是一种观察者模式，允许对象监听其他对象特定属性的变化，并在变化时收到通知。
    </p>
    <h4>
     <a id="811_KVO_438">
     </a>
     8.1.1 KVO的使用
    </h4>
    <pre><code class="prism language-objective-c">// 注册观察者
[person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];

// 实现观察者方法
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if ([keyPath isEqualToString:@"name"]) {
        NSString *oldName = [change objectForKey:NSKeyValueChangeOldKey];
        NSString *newName = [change objectForKey:NSKeyValueChangeNewKey];
        NSLog(@"名字从 %@ 变为 %@", oldName, newName);
    }
}

// 移除观察者
[person removeObserver:self forKeyPath:@"name"];
</code></pre>
    <h4>
     <a id="812_KVO_457">
     </a>
     8.1.2 KVO的底层实现
    </h4>
    <p>
     KVO的底层实现依赖于Runtime机制和isa-swizzling技术：
    </p>
    <ol>
     <li>
      当对一个对象的属性注册观察者时，系统会动态创建该对象所属类的一个子类（NSKVONotifying_XXX）
     </li>
     <li>
      重写被观察属性的setter方法，在其中添加通知机制
     </li>
     <li>
      修改对象的isa指针，指向新创建的子类
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bd68af3415fe4b9cb5c2d78e321042cb.png#pic_center"/>
     </li>
    </ol>
    <p>
     可以通过以下代码验证KVO的实现原理：
    </p>
    <pre><code class="prism language-objective-c">Person *person = [[Person alloc] init];
NSLog(@"注册KVO前: %@ %@", object_getClass(person), [person class]);
    
[person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:nil];
NSLog(@"注册KVO后: %@ %@", object_getClass(person), [person class]);
    
// 输出结果:
// 注册KVO前: Person Person
// 注册KVO后: NSKVONotifying_Person Person
</code></pre>
    <p>
     注意：
     <code>
      object_getClass()
     </code>
     返回对象的真实类型（isa指向的类），而
     <code>
      [person class]
     </code>
     被重写以返回原始类型。
    </p>
    <h3>
     <a id="82_KVCKeyValue_Coding_482">
     </a>
     8.2 KVC（Key-Value Coding）
    </h3>
    <p>
     KVC的全称是Key-Value Coding，俗称“键值编码”，KVC提供了一种使用字符串标识符访问对象属性的机制，而不需要通过调用特定的访问器方法。
    </p>
    <h5>
     <a id="821_KVC_486">
     </a>
     8.2.1 KVC的使用
    </h5>
    <pre><code class="prism language-objective-c">// 设置值
[person setValue:@"张三" forKey:@"name"];
[person setValue:@25 forKeyPath:@"address.number"];

// 获取值
NSString *name = [person valueForKey:@"name"];
NSNumber *number = [person valueForKeyPath:@"address.number"];
</code></pre>
    <p>
     <code>
      forKeyPath:
     </code>
     方法支持点语法，可以访问对象的嵌套属性。
    </p>
    <h5>
     <a id="822_KVC_500">
     </a>
     8.2.2 KVC的底层实现
    </h5>
    <p>
     当使用
     <code>
      setValue:forKey:
     </code>
     方法时，KVC的搜索顺序如下：
    </p>
    <ol>
     <li>
      <p>
       搜索
       <code>
        set&lt;Key&gt;:
       </code>
       或
       <code>
        set&lt;Key&gt;
       </code>
       方法
      </p>
     </li>
     <li>
      <p>
       如果未找到，则搜索
       <code>
        _set&lt;Key&gt;:
       </code>
       方法
      </p>
     </li>
     <li>
      <p>
       如果仍未找到且类实现了
      </p>
      <pre><code>accessInstanceVariablesDirectly
</code></pre>
      <p>
       方法（默认返回YES），则按以下顺序直接访问实例变量：
      </p>
      <ul>
       <li>
        <code>
         _&lt;key&gt;
        </code>
       </li>
       <li>
        <code>
         _is&lt;Key&gt;
        </code>
       </li>
       <li>
        <code>
         &lt;key&gt;
        </code>
       </li>
       <li>
        <code>
         is&lt;Key&gt;
        </code>
       </li>
      </ul>
     </li>
     <li>
      <p>
       如果仍未找到，调用
       <code>
        setValue:forUndefinedKey:
       </code>
       方法（默认抛出异常）
      </p>
     </li>
    </ol>
    <p>
     同样，
     <code>
      valueForKey:
     </code>
     方法也有类似的搜索顺序。
    </p>
    <h5>
     <a id="823_KVC_525">
     </a>
     8.2.3 KVC与集合操作
    </h5>
    <p>
     KVC还提供了强大的集合操作符，用于处理集合对象：
    </p>
    <pre><code class="prism language-objective-c">// 获取数组所有元素的age属性的平均值
NSNumber *avgAge = [persons valueForKeyPath:@"@avg.age"];

// 获取数组所有元素的name属性的集合
NSArray *names = [persons valueForKeyPath:@"@distinctUnionOfObjects.name"];
</code></pre>
    <p>
     常用的集合操作符包括：
    </p>
    <ul>
     <li>
      <code>
       @count
      </code>
      ：计数
     </li>
     <li>
      <code>
       @sum
      </code>
      、
      <code>
       @avg
      </code>
      、
      <code>
       @max
      </code>
      、
      <code>
       @min
      </code>
      ：数学运算
     </li>
     <li>
      <code>
       @unionOfObjects
      </code>
      、
      <code>
       @distinctUnionOfObjects
      </code>
      ：对象合并
     </li>
    </ul>
    <h2>
     <a id="9_block_545">
     </a>
     9. block
    </h2>
    <p>
     Block是OC中一种强大的语言特性，允许开发者创建匿名函数并能够捕获上下文变量。
    </p>
    <h3>
     <a id="91_block_549">
     </a>
     9.1 block本质
    </h3>
    <p>
     block的本质是一个OC对象，内部也有isa指针。
    </p>
    <p>
     block是封装了函数调用和函数调用环境的OC对象
    </p>
    <p>
     这个结构体的定义如下：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Block_layout</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token operator">*</span>isa<span class="token punctuation">;</span>  <span class="token comment">// 指向所属类的指针</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>  <span class="token comment">// 标志位，用于表示block的类型和其他属性</span>
    <span class="token keyword">int</span> reserved<span class="token punctuation">;</span>  <span class="token comment">// 保留字段</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>invoke<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 函数指针，指向block的实现代码</span>
    <span class="token keyword">struct</span> <span class="token class-name">Block_descriptor</span> <span class="token operator">*</span>descriptor<span class="token punctuation">;</span>  <span class="token comment">// 描述block的附加信息</span>
    <span class="token comment">// 捕获的变量</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="92__570">
     </a>
     9.2 变量捕获
    </h3>
    <p>
     Block可以捕获其外部作用域的变量，但捕获机制因变量类型而异：
    </p>
    <ol>
     <li>
      <strong>
       局部auto变量
      </strong>
      ：值捕获，block内部会创建一个变量副本
     </li>
     <li>
      <strong>
       局部static变量
      </strong>
      ：指针捕获，可以在block内修改
     </li>
     <li>
      <strong>
       全局变量
      </strong>
      ：不捕获，直接访问
     </li>
     <li>
      <strong>
       OC对象
      </strong>
      ：指针捕获，并根据属性特性增加引用计数
     </li>
    </ol>
    <pre><code class="prism language-objective-c">int val = 10;  // 局部auto变量
static int staticVal = 20;  // 局部static变量
__block int blockVal = 30;  // __block变量

void (^testBlock)(void) = ^{
    val = 100;  // 错误：无法修改捕获的自动变量
    staticVal = 200;  // 正确：可以修改静态变量
    blockVal = 300;  // 正确：可以修改__block变量
};
</code></pre>
    <p>
     使用
     <code>
      __block
     </code>
     修饰符可以使局部变量在block内部可修改。其原理是将变量包装到一个结构体中，然后通过指针访问这个结构体。
    </p>
    <h3>
     <a id="93_block_593">
     </a>
     9.3 block类型
    </h3>
    <p>
     根据block捕获变量的情况，block可以分为三种类型：
    </p>
    <ol>
     <li>
      <strong>
       全局block
      </strong>
      （
      <code>
       _NSConcreteGlobalBlock
      </code>
      ）：没有捕获任何变量，或者只捕获全局变量、静态变量
     </li>
     <li>
      <strong>
       栈block
      </strong>
      （
      <code>
       _NSConcreteStackBlock
      </code>
      ）：捕获了自动变量，存储在栈上，函数返回时会被销毁
     </li>
     <li>
      <strong>
       堆block
      </strong>
      （
      <code>
       _NSConcreteMallocBlock
      </code>
      ）：从栈Block复制到堆上的Block，会持久存在直到引用计数为0
     </li>
    </ol>
    <h3>
     <a id="94_blockcopy_601">
     </a>
     9.4 block的copy
    </h3>
    <p>
     在ARC下，编译器会在必要的情况下自动将栈Block复制到堆上，这些情况包括：
    </p>
    <ol>
     <li>
      将block作为参数传递给方法或函数
     </li>
     <li>
      将block赋值给__strong指针时
     </li>
     <li>
      block作为Cocoa API中方法名含有usingBlock的方法参数时
     </li>
     <li>
      block作为GCD API的方法参数时
     </li>
    </ol>
    <p>
     在MRC下，需要手动调用
     <code>
      Block_copy()
     </code>
     或
     <code>
      [block copy]
     </code>
     来将栈Block复制到堆上。
    </p>
    <pre><code>// MRC下block属性的建议写法
@property (copy, nonatomic) void (^block)(void);

// ARC下block属性的建议写法
@property (strong, nonatomic) void (^block)(void);
@property (copy, nonatomic) void (^block)(void);

</code></pre>
    <h3>
     <a id="95__622">
     </a>
     9.5 内存管理
    </h3>
    <p>
     Block的内存管理在ARC和MRC下有所不同：
    </p>
    <p>
     <strong>
      ARC下的内存管理：
     </strong>
    </p>
    <ul>
     <li>
      编译器自动管理Block的引用计数
     </li>
     <li>
      自动在必要时复制栈Block到堆上
     </li>
     <li>
      捕获的对象会被Block强引用（除非使用
      <code>
       __weak
      </code>
      或
      <code>
       __unsafe_unretained
      </code>
      修饰）
     </li>
    </ul>
    <p>
     <strong>
      MRC下的内存管理：
     </strong>
    </p>
    <ul>
     <li>
      需要手动调用
      <code>
       copy
      </code>
      和
      <code>
       release
      </code>
      来管理Block的引用计数
     </li>
     <li>
      栈Block需要手动复制到堆上
     </li>
     <li>
      捕获的对象默认不会被Block强引用
     </li>
    </ul>
    <h3>
     <a id="96_block__forwarding_638">
     </a>
     9.6 block的__forwarding指针
    </h3>
    <p>
     在block被复制到堆上时，会有一个
     <code>
      __forwarding
     </code>
     指针确保无论是在栈上还是堆上都能访问到正确的block：
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Block_byref</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token operator">*</span>isa<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Block_byref</span> <span class="token operator">*</span>forwarding<span class="token punctuation">;</span>  <span class="token comment">// 指向自身或堆上的副本</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dispose<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> captured_variable<span class="token punctuation">;</span>  <span class="token comment">// 捕获的变量</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     这个指针的作用是：
    </p>
    <ul>
     <li>
      对于栈Block，
      <code>
       __forwarding
      </code>
      指向堆block
     </li>
     <li>
      对于堆Block，
      <code>
       __forwarding
      </code>
      指向自身
     </li>
    </ul>
    <p>
     这样，无论通过栈Block还是堆Block访问捕获的变量，都会通过
     <code>
      __forwarding
     </code>
     指针找到堆上的值，保证一致性。
    </p>
    <h3>
     <a id="97__660">
     </a>
     9.7 解决循环引用
    </h3>
    <p>
     当block捕获了self或其他对象，并且这些对象也持有block时，会导致循环引用。解决方法有：
    </p>
    <p>
     <strong>
      __weak修饰符
     </strong>
     （ARC下）：创建一个弱引用，不增加引用计数
    </p>
    <pre><code class="prism language-objective-c">__weak typeof(self) weakSelf = self;
self.block = ^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    [strongSelf doSomething];
};
</code></pre>
    <p>
     <strong>
      __unsafe_unretained修饰符
     </strong>
     （ARC下）：创建一个不安全的弱引用，可能导致悬挂指针
    </p>
    <pre><code class="prism language-objective-c">__unsafe_unretained typeof(self) unsafeObj = self;
self.block = ^{
    [unsafeObj doSomething];
};
</code></pre>
    <p>
     <strong>
      __block修饰符
     </strong>
     （MRC下）：在Block执行完毕后将捕获的变量置nil
    </p>
    <pre><code class="prism language-objective-c">__block typeof(self) blockSelf = self;
self.block = ^{
    [blockSelf doSomething];
    blockSelf = nil;
};
</code></pre>
    <h3>
     <a id="_693">
     </a>
     总结
    </h3>
    <p>
     本文深入探讨了Objective-C的底层实现机制，从对象和类的本质，再到Category和Block等高级特性。通过理解这些底层知识，我们可以更好地利用Objective-C的强大特性，也能更好地理解和解决开发中遇到的问题。
    </p>
    <p>
     Objective-C的动态性和灵活性使其成为一门强大的编程语言，即使在Swift逐渐成为iOS开发主流语言的今天，理解Objective-C的底层原理对于掌握iOS开发依然至关重要。通过学习这些内容，将能够更深入地理解iOS系统的工作原理，开发出更高效、更稳定的应用程序。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6a7364303931352f:61727469636c652f64657461696c732f313436323138363331" class_="artid" style="display:none">
 </p>
</div>


