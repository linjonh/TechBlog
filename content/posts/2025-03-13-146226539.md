---
layout: post
title: "JVM-调优"
date: 2025-03-13 11:41:01 +0800
description: "JVM调优后需要综合观察内存、GC、CPU、吞吐量、线程、I/O等指标，并结合GC日志、JVM工具进行深入分析，确保优化有效果，并且不会引入新的问题。"
keywords: "JVM 调优"
categories: ['未分类']
tags: ['Jvm']
artid: "146226539"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146226539
    alt: "JVM-调优"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146226539
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146226539
cover: https://bing.ee123.net/img/rand?artid=146226539
image: https://bing.ee123.net/img/rand?artid=146226539
img: https://bing.ee123.net/img/rand?artid=146226539
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM 调优
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在生产环境中，JVM 调优是确保 Java 应用程序性能和稳定性的重要步骤。调优的目标通常是减少垃圾回收的时间、降低内存使用和提高应用程序的吞吐量。以下是一些常见的 JVM 调优策略和方法。
    </p>
    <p>
     <strong>
      选择合适的垃圾收集器
     </strong>
     <br/>
     -XX:+UseG1GC
    </p>
    <p>
     <strong>
      调整堆内存大小，通过调整堆内存的大小，可以控制应用程序的性能
     </strong>
     <br/>
     设置初始堆大小：-Xms512m
     <br/>
     设置最大堆大小：-Xmx2048m
     <br/>
     设置年轻代大小：-Xmn256m
     <br/>
     一般推荐将初始堆和最大堆的比值设置为 1:2 或 1:3。
    </p>
    <p>
     <strong>
      调整垃圾收集参数
     </strong>
     <br/>
     设置新生代和老年代的比例：-XX:NewRatio=3 # 新生代与老年代的比例
     <br/>
     设置 Survivor 区的大小：-XX:SurvivorRatio=8 # Eden 区与 Survivor 区的比例
     <br/>
     设置最大 GC 停顿时间（对于 G1 GC）：-XX:MaxGCPauseMillis=200
    </p>
    <p>
     <strong>
      定期监控和分析 JVM 的运行状态，使用各种工具来观察性能和内存使用情况
     </strong>
     <br/>
     JVisualVM：Java 自带的可视化监控工具，可以用来查看内存、线程、CPU 使用情况。
     <br/>
     JConsole：用于监控 Java 应用的图形界面工具。
     <br/>
     GC 日志：启用 GC 日志以分析垃圾收集的性能，-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log。
     <br/>
     使用 Java Flight Recorder：这是一个强大的性能监控工具，可以提供深入的性能分析。
    </p>
    <p>
     <strong>
      代码的优化可以显著减少内存使用和垃圾回收的压力
     </strong>
     <br/>
     减少对象创建：尽量复用对象，避免频繁创建短命对象。
     <br/>
     使用合适的数据结构：选择合适的集合类，例如 ArrayList vs LinkedList，并根据需求选择合适的实现。
     <br/>
     避免内存泄漏：定期检查代码中是否存在内存泄漏，例如未清理的缓存、静态集合中的对象引用等。
     <br/>
     设置线程数，在多线程应用中，合理配置线程数可以提高性能。
     <br/>
     设置最大线程数（取决于应用和服务器的具体情况）。-XX:ParallelGCThreads=4 # 设置并行 GC 线程数`
    </p>
    <p>
     <strong>
      使用 JDK 8 及之后的版本的特性
     </strong>
     <br/>
     Metaspace：Java 8 之后，类元数据存储在本地内存中，避免了旧版本中永久代的限制。可以通过设置 Metaspace 大小来优化性能。-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m
     <br/>
     测试与迭代：调优是一个迭代过程。在生产环境中，测试是非常重要的步骤：
     <br/>
     负载测试：在类似生产环境中进行负载测试，以观察系统在高负载情况下的表现。
     <br/>
     逐步调整：每次只调整一个参数，观察性能变化，再进行下一步调整。
    </p>
    <p>
     JVM调优后，主要需要观察以下性能指标，以确保优化达到了预期效果：
    </p>
    <h2>
     <a id="1__36">
     </a>
     1.
     <strong>
      内存使用情况
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       堆内存（Heap Memory）
      </strong>
      ：观察堆内存的分配和使用情况，关注年轻代（Young Gen）、老年代（Old Gen）和永久代/元空间（PermGen/Metaspace）的使用是否稳定，是否存在频繁的Full GC。
     </li>
     <li>
      <strong>
       非堆内存（Non-Heap Memory）
      </strong>
      ：如Metaspace、Code Cache等，避免内存泄漏或过度消耗。
     </li>
     <li>
      <strong>
       直接内存（Direct Memory）
      </strong>
      ：如果使用了Netty、ByteBuffer等直接内存分配，需要监控
      <code>
       sun.nio.MaxDirectMemorySize
      </code>
      的使用情况，避免OutOfMemoryError。
     </li>
    </ul>
    <h2>
     <a id="2_GC_40">
     </a>
     2.
     <strong>
      GC（垃圾回收）情况
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       GC频率
      </strong>
      ：年轻代（Minor GC）和老年代（Major/Full GC）的触发频率是否合理，避免过于频繁。
     </li>
     <li>
      <strong>
       GC停顿时间
      </strong>
      ：尤其是Full GC的停顿时间，是否影响业务请求的响应时间。
     </li>
     <li>
      <strong>
       GC回收效率
      </strong>
      ：查看每次GC回收的内存大小，判断是否有效。
     </li>
     <li>
      <strong>
       GC日志分析
      </strong>
      ：观察GC日志，确定GC策略是否合适（如G1、CMS、ZGC等），是否出现STW（Stop The World）过长的情况。
     </li>
    </ul>
    <h2>
     <a id="3_CPU_45">
     </a>
     3.
     <strong>
      线程与CPU使用
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       线程数
      </strong>
      ：监控JVM中的活跃线程数，是否存在线程泄漏或过度创建。
     </li>
     <li>
      <strong>
       CPU使用率
      </strong>
      ：
      <ul>
       <li>
        观察是否存在GC占用CPU过高的情况（如高并发应用可能导致CPU占用率过高）。
       </li>
       <li>
        分析是否有线程死锁、线程占用过多CPU的问题（可以使用
        <code>
         jstack
        </code>
        查看线程堆栈）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       上下文切换
      </strong>
      ：频繁的线程切换会影响性能，需要分析是否因锁竞争、GC等导致。
     </li>
    </ul>
    <h2>
     <a id="4_TPSQPS_51">
     </a>
     4.
     <strong>
      吞吐量（TPS/QPS）
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       吞吐量变化
      </strong>
      ：调优前后TPS/QPS是否有提升，是否达到了预期优化目标。
     </li>
     <li>
      <strong>
       请求响应时间
      </strong>
      ：如API接口的P99、P95、P50等响应时间是否有明显优化。
     </li>
     <li>
      <strong>
       系统吞吐瓶颈
      </strong>
      ：分析是否因为GC、内存、线程池等导致吞吐量受限。
     </li>
    </ul>
    <h2>
     <a id="5__55">
     </a>
     5.
     <strong>
      类加载与元空间
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       类加载次数
      </strong>
      ：是否存在类加载过于频繁的问题，可能导致元空间（Metaspace）占用过高，触发Full GC。
     </li>
     <li>
      <strong>
       元空间大小
      </strong>
      ：观察是否有元空间（Metaspace）溢出，可能需要调整
      <code>
       -XX:MetaspaceSize
      </code>
      。
     </li>
    </ul>
    <h2>
     <a id="6_IO_58">
     </a>
     6.
     <strong>
      I/O性能
     </strong>
    </h2>
    <ul>
     <li>
      <strong>
       磁盘I/O
      </strong>
      ：如果应用涉及大量文件操作（如日志、缓存），需要观察I/O读写速度，避免GC导致I/O阻塞。
     </li>
     <li>
      <strong>
       网络I/O
      </strong>
      ：如果涉及RPC调用（如Dubbo、gRPC）或数据库访问（如MySQL、Redis），需要分析调用延迟是否受JVM调优影响。
     </li>
    </ul>
    <h2>
     <a id="7_JVM_61">
     </a>
     7.
     <strong>
      JVM指标监控工具
     </strong>
    </h2>
    <ul>
     <li>
      <code>
       jstat
      </code>
      ：观察GC情况，如
      <code>
       jstat -gcutil &lt;pid&gt; 1000
      </code>
      。
     </li>
     <li>
      <code>
       jstack
      </code>
      ：分析线程状态，查看是否有死锁。
     </li>
     <li>
      <code>
       jmap
      </code>
      ：分析堆内存使用情况，如
      <code>
       jmap -heap &lt;pid&gt;
      </code>
      。
     </li>
     <li>
      <code>
       GC日志
      </code>
      ：结合
      <code>
       -Xlog:gc*
      </code>
      或
      <code>
       -verbose:gc
      </code>
      分析GC情况。
     </li>
     <li>
      <strong>
       监控平台
      </strong>
      ：使用Prometheus + Grafana、Arthas、JConsole、VisualVM等监控JVM性能。
     </li>
    </ul>
    <h2>
     <a id="_67">
     </a>
     总结
    </h2>
    <p>
     JVM调优后需要综合观察
     <strong>
      内存、GC、CPU、吞吐量、线程、I/O等指标
     </strong>
     ，并结合
     <strong>
      GC日志、JVM工具
     </strong>
     进行深入分析，确保优化有效果，并且不会引入新的问题。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34313839333530352f:61727469636c652f64657461696c732f313436323236353339" class_="artid" style="display:none">
 </p>
</div>


