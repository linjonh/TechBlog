---
layout: post
title: "蓝桥杯单片机第十一届省赛"
date: 2025-03-12 21:25:29 +0800
description: "将ucLed取反的值赋给P0开启锁存器 y4关闭锁存器 y4开始--发送写入地址--等待应答--发送写入位置--等待应答-- while(num--)来逐个将数据写入（加入延时保证稳定性）--终止不用NE555时，不要短接，否则按键会失效"
keywords: "【蓝桥杯单片机】第十一届省赛"
categories: ['蓝桥杯']
tags: ['嵌入式硬件']
artid: "146123545"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123545
    alt: "蓝桥杯单片机第十一届省赛"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123545
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123545
cover: https://bing.ee123.net/img/rand?artid=146123545
image: https://bing.ee123.net/img/rand?artid=146123545
img: https://bing.ee123.net/img/rand?artid=146123545
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【蓝桥杯单片机】第十一届省赛
    </h1>
   </div>
   <div class="article-resource-info-box">
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、真题
    </h2>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2ba351926f4e45bc957fb77220d20f1b.png">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/b744dc38a2c34b108c117c57dba8f634.png">
       <img alt="" src="https://i-blog.csdnimg.cn/direct/4090d7038a7a402d8ff0d5d2f8b86193.png">
        <img alt="" src="https://i-blog.csdnimg.cn/direct/f44cc821e86149e3adab2fffa506547c.png"/>
       </img>
      </img>
     </img>
    </p>
    <h2>
     二、创建工程
    </h2>
    <h3>
     1.在C盘以外的盘新建文件夹，并在文件夹里面创建两个文件夹Driver 和Project
     <img alt="" height="248" src="https://i-blog.csdnimg.cn/direct/044e320a6318494bb911abfa9e53e640.png" width="822"/>
    </h3>
    <h3>
     2.打开keil软件，在新建工程并选择刚刚建好的project文件夹，以准考证号命名
    </h3>
    <p>
     <img alt="" height="588" src="https://i-blog.csdnimg.cn/direct/4c74380d74af47c1a4e4968560378241.png" width="948"/>
    </p>
    <h3>
     3.选择对应的芯片型号
    </h3>
    <p>
     <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/9a368df61ae44c99b62f4a7cf53a079b.png" width="782"/>
    </p>
    <p>
     <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/b526eb7c88bb486c8956894eaec19817.png" width="782"/>
    </p>
    <h3>
     4.选择否，即不创建启动文件
    </h3>
    <p>
     <img alt="" height="215" src="https://i-blog.csdnimg.cn/direct/7535f917eb944da49ff70f6807dbd1b8.png" width="541"/>
    </p>
    <h3>
     5.勾上生成hex文件的功能
    </h3>
    <p>
     <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/83dee71c0d7244b0bab11ab091928b34.png" width="782"/>
    </p>
    <h3>
     6.添加头文件路径
    </h3>
    <p>
     <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/bde6068ee4d24767b2bea8fba5850297.png" width="782"/>
    </p>
    <h3>
     三、模块构建
    </h3>
    <h3>
    </h3>
    <h3>
     1.编写初始化函数(init.c)
    </h3>
    <h2>
     <a name="t3">
     </a>
     <a name="t3">
     </a>
     void Cls_Peripheral(void);
    </h2>
    <ol>
     <li>
      关闭led    led对应的锁存器由Y4C控制
     </li>
     <li>
      关闭
      <a href="https://so.csdn.net/so/search?q=%E8%9C%82%E9%B8%A3%E5%99%A8&amp;spm=1001.2101.3001.7020" title="蜂鸣器">
       蜂鸣器
      </a>
      和继电器 由Y5C控制
     </li>
    </ol>
    <h2>
     2.编写LED函数（led.c）
    </h2>
    <h3>
     <a name="t5">
     </a>
     <a name="t5">
     </a>
     void Led_Disp(unsigned char ucLed);
    </h3>
    <ol>
     <li>
      <p>
       将ucLed
       <strong>
        取反
       </strong>
       的值赋给P0
      </p>
     </li>
     <li>
      <p>
       开启
       <a href="https://so.csdn.net/so/search?q=%E9%94%81%E5%AD%98%E5%99%A8&amp;spm=1001.2101.3001.7020" title="锁存器">
        锁存器
       </a>
       <span style="color:#fe2c24">
        y4
       </span>
      </p>
     </li>
     <li>
      <p>
       关闭锁存器 y4
      </p>
     </li>
    </ol>
    <h3>
     3.编写数码管函数（seg.c）
    </h3>
    <h3>
     void Seg_Tran(unsigned char *pucSeg_Buf,unsigned char *pucSeg_Code);
    </h3>
    <h4>
     （1）段码转换函数
    </h4>
    <ul>
     <li>
      定义两个变量i,j
     </li>
     <li>
      for循环加Switch语句进行段码转换,在资源数据包查找段码表，并根据题目要求进行段码转换
     </li>
     <li>
      注意添加空格代表都不显示
     </li>
     <li>
      <span style="color:#fe2c24">
       注意8+4是C 不是A
      </span>
     </li>
    </ul>
    <h3>
     void Seg_Disp(unsigned char *pucSeg_Code,unsigned char ucSeg_Pos)；
    </h3>
    <h4>
     （2）数码管显示函数
    </h4>
    <ul>
     <li>
      要对数码管进行消隐
      <span style="color:#fe2c24">
       y7
      </span>
     </li>
     <li>
      显示的位置
      <span style="color:#fe2c24">
       y6
      </span>
     </li>
     <li>
      显示的内容
      <span style="color:#fe2c24">
       y7
      </span>
     </li>
    </ul>
    <h3>
     4. 编写矩阵键盘代码(key.c)
    </h3>
    <h3>
     unsigned char Key_Read_KBD(void)；
    </h3>
    <ol>
     <li>
      有返回值
     </li>
     <li>
      16个按键，要用
      <span style="color:#fe2c24">
       十六位数据类型 unsigned int
      </span>
     </li>
     <li>
      依次将每一列设置为低电平，读取P3的
      <span style="color:#fe2c24">
       低四位（&amp;0x0f）
      </span>
      存储到变量Key_New里,
      <span style="color:#fe2c24">
       不
       <strong>
        要忘记每个都左移4位,然后记得|
       </strong>
      </span>
     </li>
     <li>
      用Switch语句将按键按下后的值进行判断（Key_New取反 便于理解）
     </li>
     <li>
      返回对应按键的值
     </li>
     <li>
      不要忘记default 返回都没有按下的值 设为0
     </li>
    </ol>
    <h3>
     5.编写ADC代码
    </h3>
    <h3>
     unsigned char PCF8591_ADC(void)；
    </h3>
    <ol>
     <li>
      定义SCL,SDA
     </li>
     <li>
      有
      <strong>
       <span style="color:#fe2c24">
        返回值类型
       </span>
      </strong>
     </li>
     <li>
      <span style="color:#fe2c24">
       添加"intrins.h"头文件,接触nop错误
      </span>
     </li>
     <li>
      定义变量用于存储采集的电压
     </li>
     <li>
      写入流程：开始--发送写入地址--等待应答--发送电位器地址--等待应答
     </li>
     <li>
      读取流程：开始--发送读取地址--等待应答--
      <span style="color:#be191c">
       <strong>
        变量接收数据
       </strong>
      </span>
      --
      <span style="color:#4da8ee">
       <strong>
        发送应答1--终止
       </strong>
      </span>
     </li>
     <li>
      读取地址为0x91 写入地址为0x90
     </li>
     <li>
      电位器地址为0x43
     </li>
     <li>
      不要忘记把
      <span style="color:#a2e043">
       <strong>
        temp返回
       </strong>
      </span>
     </li>
    </ol>
    <h3>
     6.编写AT24C02代码
    </h3>
    <h3>
     void EEPROM_Read(unsigned char *pucBuf,unsigned char addr,unsigned char num)；
    </h3>
    <ul>
     <li>
      读取流程：开始--
      <span style="color:#4da8ee">
       <strong>
        发送写入地址
       </strong>
      </span>
      --等待应答--
      <span style="color:#be191c">
       <strong>
        发送写入位置
       </strong>
      </span>
      -
      <span style="color:#0d0016">
       等待应答--开始--发送读取地址--等待应答--while(num--)来逐个存储读取的数据--if判断num是否为0--
      </span>
      <span style="color:#fe2c24">
       <strong>
        终止
       </strong>
      </span>
     </li>
    </ul>
    <h3>
     void EEPROM_Write(unsigned char *pucBuf,unsigned char addr,unsigned char num)
    </h3>
    <ul>
     <li>
      <p>
       开始--发送写入地址--等待应答--发送写入位置--等待应答--
       <span style="color:#0d0016">
        while(num--)来逐个将数据写入（加入延时保证稳定性）--
       </span>
       <span style="color:#fe2c24">
        终止
       </span>
      </p>
     </li>
    </ul>
    <h3>
     7.定时器函数编写
    </h3>
    <h3>
     void Timer0Init(void);
    </h3>
    <ol>
     <li>
      在sti-isp软件中生成定时长度为1ms的c代码,直接复制
     </li>
     <li>
      不要忘记打开定时器0的开关和定时器总开关
     </li>
    </ol>
    <h2>
     四、主函数代码
    </h2>
    <h3>
     1.添加好所有头文件在主函数和工程文件夹中
    </h3>
    <h3>
     2.外设初始化，定时器初始化，打开中断总开关
    </h3>
    <h3>
     3.数码管函数编写
    </h3>
    <ul>
     <li>
      定义数组和变量，数组分别为12为和8位，不加*  变量赋初值为0
     </li>
     <li>
      编写Seg_Proc();函数
     </li>
     <li>
      添加时间变量在定时器0中断进行自加
     </li>
     <li>
      200ms
     </li>
     <li>
      动态显示添加到中断里
     </li>
     <li>
      判断模式
     </li>
     <li>
      数码管转换函数不要忘
     </li>
    </ul>
    <h3>
     4.ADC函数编写
    </h3>
    <ul>
     <li>
      时间200
     </li>
     <li>
      将读取的值赋值给变量，实际的值需要除以51.0是真实电压值
     </li>
    </ul>
    <h3>
     5.按键函数编写
    </h3>
    <ul>
     <li>
      <p>
       不用NE555时，不要短接，否则按键会失效
      </p>
     </li>
    </ul>
    <h3>
     6.led函数编写
    </h3>
    <ul>
     <li>
      200ms
     </li>
     <li>
      最后不要忘记调用led显示函数
     </li>
    </ul>
    <h2 style="background-color:transparent">
     五、难点解析
    </h2>
    <h3>
     1.关于EEPROM 的断电保存
    </h3>
    <h3>
     2.触发条件
    </h3>
    <h3>
     3.指示灯 用到了ulms
    </h3>
    <h3>
     4.无效按键的触发
    </h3>
    <h2>
     六、主函数代码
    </h2>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "seg.h"
#include "led.h"
#include "init.h"
#include "key.h"
#include "iic.h"
#include "tim.h"
//Seg
unsigned char pucSeg_Buf[12],pucSeg_Code[8],ucSeg_Pos=0;
//ADC
unsigned char ucADC=0;
float ADC_Pram=0;
unsigned int uicount=0;
unsigned char ucADC_Old=0;
//led
unsigned char ucLed=0;
//key
unsigned char Key_Val=0,Key_Val_Old=0;
unsigned int uiError=0;
//EEPROM
unsigned char EEPROM_Buf[2];
//timer
unsigned long ulms=0;
unsigned long ulled=0;
unsigned int uiSeg_Dly=0;
unsigned int uiADC_Dly=0;
unsigned int uiKey_Dly=0;
unsigned int uiLed_Dly=0;

//function
void Seg_Proc(void);
void ADC_Proc(void);
void Key_Proc(void);
void Led_Proc(void);
 
//mode
unsigned char Disp_Mode=0;

void main(void)
{
	Cls_Peripheral();
	EEPROM_Read(EEPROM_Buf,0x00,1);
	ADC_Pram=EEPROM_Buf[0]/10.0;
	Timer0Init();
	EA=1;
	while(1)
	{
		Seg_Proc();
		ADC_Proc();
		Key_Proc();
		Led_Proc();
	}
}
void Led_Proc(void)
{
	if(uiLed_Dly&lt;200)
	return;
	uiLed_Dly=0;
	
	if(((ucADC/51.0)&lt;ADC_Pram)&amp;&amp;(ulms-ulled&gt;5000))
	{
		ucLed|=0x01;
	}
	else
		
	{
	  ucLed&amp;=~0x01;
	}
	if(uicount%2==0)
	{
		ucLed&amp;=~0x02;
	}
	else
	{
	  ucLed|=0x02;
	}
	if(uiError&gt;=3)
	{
		ucLed|=0x04;
	}
	else
	{
	  ucLed&amp;=~0x04;
	}
	Led_Disp(ucLed);
}

void Seg_Proc(void)
{
	if(uiSeg_Dly&lt;200)
	return;
	uiSeg_Dly=0;
	if(Disp_Mode==0)
	{
		sprintf(pucSeg_Buf,"U    %4.2f",ucADC/51.0);
	}
	else if(Disp_Mode==1)
	{
		sprintf(pucSeg_Buf,"P    %4.2f",ADC_Pram);
	}
	else
	{
		sprintf(pucSeg_Buf,"N%7u",uicount);
	}
	Seg_Tran(pucSeg_Buf,pucSeg_Code);
}
void ADC_Proc(void)
{
	if(uiADC_Dly&lt;500)
	return;
	uiADC_Dly=0;
	ucADC=PCF8591_ADC();
	if(((ucADC_Old/51.0)&gt;ADC_Pram)&amp;&amp;((ucADC/51.0)&lt;=ADC_Pram))
	{
		uicount++;
		ulled=ulms;
	}
	if(((ucADC_Old/51.0)&lt;ADC_Pram)&amp;&amp;((ucADC/51.0)&gt;=ADC_Pram))
	{
		ulled=ulms;
	}
	ucADC_Old=ucADC;
}
void Key_Proc(void)
{
	if(uiKey_Dly&lt;20)
	return;
	uiKey_Dly=0;
	
	Key_Val=Key_Read_KBD();
	if(Key_Val==Key_Val_Old)
		return;
	switch (Key_Val)
	{
		case 12:
			uiError=0;
			Disp_Mode=(Disp_Mode+1)%3;
		if(Disp_Mode==2)
		{
			EEPROM_Buf[0]=(unsigned char)(ADC_Pram*10);
			EEPROM_Write(EEPROM_Buf,0x00,1);
		}
			break;
		case 13:
			if(Disp_Mode==2)
			{
				uiError=0;
				uicount=0;
			}
			else
			{
				uiError++;
			}
		case 16:
			if(Disp_Mode==1)
			{
				uiError=0;
				if(ADC_Pram&gt;=5)
				{
					ADC_Pram=0;
				}
				else
				{
				ADC_Pram+=0.5;
				}
			}
			else
			{
				uiError++;
			}
			break;
			case 17:
			if(Disp_Mode==1)
			{
				uiError=0;
				if(ADC_Pram&lt;=0.0)
				{
					ADC_Pram=5.0;
				}
				else
				{
				ADC_Pram-=0.5;
				}
			}
			else
			{
				uiError++;
			}
			break;
	}
		Key_Val_Old=Key_Val;
}
void Time_0(void) interrupt 1
{
	ulms++;
	uiSeg_Dly++;
	uiADC_Dly++;
	uiKey_Dly++;
	uiLed_Dly++;
	if(ulms%2==0)
	{
		ucSeg_Pos=(ucSeg_Pos+1)%8;
		Seg_Disp(pucSeg_Code,ucSeg_Pos);
	}
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393630383939382f:61727469636c652f64657461696c732f313436313233353435" class_="artid" style="display:none">
 </p>
</div>


