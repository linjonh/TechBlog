---
layout: post
title: "Framework系列之ClientUIManager和UIPanel模块介绍"
date: 2025-03-06 22:14:30 +0800
description: "打开UI</summary>/// <typeparam name=\"T\">UI类型</typeparam>/// <summary>隐藏UI（不销毁）"
keywords: "【Framework系列之Client】UIManager和UIPanel模块介绍"
categories: ['Framework']
tags: ['游戏', 'Unity']
artid: "145995623"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145995623
    alt: "Framework系列之ClientUIManager和UIPanel模块介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145995623
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145995623
cover: https://bing.ee123.net/img/rand?artid=145995623
image: https://bing.ee123.net/img/rand?artid=145995623
img: https://bing.ee123.net/img/rand?artid=145995623
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Framework系列之Client】UIManager和UIPanel模块介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     今天来介绍一下UIManager和UIPanel模块，话不多说直接开始。
    </p>
    <p>
    </p>
    <h3>
     UIManager
    </h3>
    <h4>
     功能介绍
    </h4>
    <p>
     UIManager是管理UIPanel的唯一模块，UIManager的主要功能包括：
    </p>
    <ul>
     <li>
      提供打开、隐藏、关闭UIPanel的相关接口。
     </li>
     <li>
      负责UIPanel对象的创建以及初始化。
     </li>
     <li>
      负责储存UIPanel对象实例。
     </li>
    </ul>
    <p>
     UIManager提供了打开、隐藏、关闭UIPanel的泛型接口，通过传入UIPanel的子类型，就可以对其进行相应的操作。接口代码如下：
    </p>
    <pre><code class="language-cs">/// &lt;summary&gt;打开UI&lt;/summary&gt;
/// &lt;typeparam name="T"&gt;UI类型&lt;/typeparam&gt;
public void OpenUI&lt;T&gt;(Action pCallback = null) where T : Component

/// &lt;summary&gt;隐藏UI（不销毁）&lt;/summary&gt;
/// &lt;typeparam name="T"&gt;UI类型&lt;/typeparam&gt;
public void HideUI&lt;T&gt;()

/// &lt;summary&gt;关闭UI（销毁）&lt;/summary&gt;
/// &lt;typeparam name="T"&gt;UI类型&lt;/typeparam&gt;
public void CloseUI&lt;T&gt;()
</code></pre>
    <p>
     UIManager内以键值对的方式存储UIPanel，当调用OpenUI时会先判断是否存在该UIPanel，如果没有则会加载创建并存储下来。示例代码如下：
    </p>
    <pre><code class="language-cs">public class UIManager : ManagerBase&lt;UIManager&gt;
{
	private Dictionary&lt;string, GameObject&gt; mUIDictionary = new Dictionary&lt;string, GameObject&gt;();
	
	/// &lt;summary&gt;打开UI&lt;/summary&gt;
	/// &lt;typeparam name="T"&gt;UI类型&lt;/typeparam&gt;
	public void OpenUI&lt;T&gt;(Action pCallback = null) where T : Component
	{
		string uiName = GetUIName&lt;T&gt;();
		GameObject uiGameObject = null;
		if (!mUIDictionary.TryGetValue(uiName, out uiGameObject))
		{
			uiGameObject = InstantiateUI&lt;T&gt;();
			if (uiGameObject == null)
			{
				ManagerCollection.LoadManager.LoadAssetAsync(uiName, (bool pIsSucceeded) =&gt;
				{
					OpenUI&lt;T&gt;(pCallback);
				});
			}
			else
			{
				uiGameObject.SetActive(true);
				pCallback?.Invoke();
			}
		}
		else
		{
			uiGameObject.SetActive(true);
			pCallback?.Invoke();
		}
	}
	
	/// &lt;summary&gt;实例化UI&lt;/summary&gt;
	/// &lt;param name="uiName"&gt;面板名称&lt;/param&gt;
	/// &lt;param name="gameObjectAsset"&gt;资源&lt;/param&gt;
	/// &lt;returns&gt;面板对象&lt;/returns&gt;
	private GameObject InstantiateUI&lt;T&gt;() where T : Component
	{
		GameObject uiGameObject = null;

		string uiName = GetUIName&lt;T&gt;();
		GameObject gameObjectAsset = ManagerCollection.ResourceManager.GetGameObject(uiName);
		if (gameObjectAsset != null)
		{
			uiGameObject = GameObject.Instantiate(gameObjectAsset);
			IPanelBase panelBase = uiGameObject.AddComponent&lt;T&gt;() as IPanelBase;
			panelBase.Init();

			uiGameObject.transform.SetParent(mCanvasDictionary[panelBase.CanvasType], false);
			uiGameObject.transform.localScale = Vector3.one;
			uiGameObject.transform.localRotation = Quaternion.identity;
			mUIDictionary.Add(uiName, uiGameObject);
		}

		return uiGameObject;
	}
}
</code></pre>
    <h4>
     设计思路
    </h4>
    <p>
     先说一下UIManager为什么采用泛型接口的设计，而不是通过string作为参数来传递UIPanel的名称。这么做的主要原因是为了正确的获取面板名称。泛型接口通过传递的UIPanel类型来获取名称，这样做的好处在于，在代码编译阶段就可以利用编译器（如VS，VSCode）检测判断类型是否正确，并且可以通过UIPanel类型正确的获取UIPanel的名称。而采用string作为参数传递UIPanel名称，则需要在运行时才能判断UIPanel名称是否正确。所泛型接口能更好的确保代码的正确性。
    </p>
    <p>
     再说一下InstantiateUI方法中为什么用AddComponent的方式添加UIPanel脚本。原因在于游戏框架被分为Client、Server、Desgin、Resource多个工程，前端和美术在各自的工程项目中开发，流程是美术在Resource工程中制作Prefab资源，制作完成后由程序同步到Client工程中开发脚本逻辑。由于美术在Resource工程中并不会涉及到脚本文件，为了避免不必要的同步，所以在运行时创建UIPanel实例时绑定脚本。
    </p>
    <p>
    </p>
    <h3>
     UIPanel模块
    </h3>
    <h4>
     功能介绍
    </h4>
    <p>
     UIPanel借鉴了MVC的设计模式，UIPanel分为PanelBase、ControllerBase、ViewBase三个部分，在创建一个新UIPanel时需分别创建三个子类，并继承上面各自的基类。示例代码如下：
    </p>
    <pre><code class="language-cs">/// &lt;summary&gt;UI面板类&lt;/summary&gt;
public class UIPanel : PanelBase&lt;UIPanelController, UIPanelView&gt;
{
	protected override void OnInit(){}
}

/// &lt;summary&gt;UI面板Controller类&lt;/summary&gt;
public class UIPanelController : ControllerBase&lt;UIPanelView&gt;
{
	protected override void OnInit(){}
}

/// &lt;summary&gt;UI面板View类&lt;/summary&gt;
public class UIPanelView : ViewBase&lt;UIController&gt;
{
	protected override void OnInit(){}
}</code></pre>
    <p>
     Panel部分的主要功能有：
    </p>
    <ul>
     <li>
      Panel作为面板的主类，Panel类名作为面板的名称。在UIManager调用泛型接口时，传入Panel类型，如上面代码的UIPanel。
     </li>
     <li>
      负责Controller和View的创建初始化。
     </li>
    </ul>
    <p>
     Controller部分的主要功能和主要职责有：
    </p>
    <ul>
     <li>
      Controller主要负责面板的逻辑部分代码，处理UI响应、事件响应。
     </li>
     <li>
      ControllerBase提供了相关UI组件事件响应的接口。
     </li>
    </ul>
    <p>
     示例代码如下：
    </p>
    <pre><code class="language-cs">protected void RegisterButton(string pGameObjectName, ExButton.EnumCallbackType pCallbackType, Action pCallback)

protected void RegisterSlider(string pGameObjectName, ExSlider.EnumCallbackType pCallbackType, Action&lt;float&gt; pCallback)

protected void RegisterToggle(string pGameObjectName, ExToggle.EnumCallbackType pCallbackType, Action&lt;bool&gt; pCallback)</code></pre>
    <p>
     View部分的主要功能和职责有：
    </p>
    <ul>
     <li>
      View主要负责面板显示部分的代码。
     </li>
     <li>
      View储存持有代码中需要用到UI对象。
     </li>
     <li>
      View提供获取UI对象和组件的相关接口。
     </li>
    </ul>
    <p>
     示例代码如下：
    </p>
    <pre><code class="language-cs">public class ViewBase&lt;C&gt; : UIBase, IViewBase
    where C : IControllerBase
{
    private C mControllerBase;
	
	[SerializeField]
	private List&lt;GameObject&gt; mGameObjectList = new List&lt;GameObject&gt;();
	
	public GameObject GetGameObject(string pGameObjectName)
	
	public T GetComponent&lt;T&gt;(string pGameObjectName)
}</code></pre>
    <h4>
     设计思路
    </h4>
    <p>
     UIPanel借鉴了MVC的设计模式，将UI面板中逻辑处理和界面显示两大部分的代码分开，让代码更加的清晰，从而便于开发与维护。虽然Controller和View可以相互的访问，但在实际开发中还是遵从Controller驱动View的思路来开发。UIPanel先在Controller处理UI响应、事件响应相关逻辑，完成后在View设置相关显示。
    </p>
    <p>
    </p>
    <h3>
     相关文档链接
    </h3>
    <p>
     工程源代码：
     <a href="https://gitee.com/huoyixian/release-framework-client" rel="nofollow" title="https://gitee.com/huoyixian/release-framework-client">
      https://gitee.com/huoyixian/release-framework-client
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f68756f79697869616e2f:61727469636c652f64657461696c732f313435393935363233" class_="artid" style="display:none">
 </p>
</div>


