---
layout: post
title: "软件设计23-种设计模式解析与实践指南"
date: 2025-03-10 09:52:33 +0800
description: "掌握多种设计模式，能够让开发者在面对不同的项目需求时，灵活地选择合适的模式，从而提高软件的质量和开发效率。设计模式（Design Pattern）是软件开发中反复出现的问题的解决方案，由 Erich Gamma 等四人组（GoF）在 1994 年系统化提出。文档编辑器（树形结构管理 + 格式装饰 + 保存策略 + 实时预览）。"
keywords: "【软件设计】23 种设计模式解析与实践指南"
categories: ['软件工程', '编程框架', '数据结构与算法']
tags: ['软件工程', '设计模式', '数据结构']
artid: "146143684"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146143684
    alt: "软件设计23-种设计模式解析与实践指南"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146143684
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146143684
cover: https://bing.ee123.net/img/rand?artid=146143684
image: https://bing.ee123.net/img/rand?artid=146143684
img: https://bing.ee123.net/img/rand?artid=146143684
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【软件设计】23 种设计模式解析与实践指南
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3 style="background-color:transparent">
     引言
    </h3>
    <p>
     设计模式（Design Pattern）是软件开发中反复出现的问题的解决方案，由 Erich Gamma 等四人组（GoF）在 1994 年系统化提出。
    </p>
    <p>
     在软件开发领域，设计模式是解决常见软件设计问题的可复用方案。它们就像是建筑师手中的蓝图，帮助开发者构建高效、可维护和可扩展的软件系统。掌握多种设计模式，能够让开发者在面对不同的项目需求时，灵活地选择合适的模式，从而提高软件的质量和开发效率。
    </p>
    <p>
     <img alt="" height="893" src="https://i-blog.csdnimg.cn/direct/16aad88682394f9e8216fade43b8c760.png" width="1892"/>
    </p>
    <h3>
     <strong>
      一、设计模式分类
     </strong>
    </h3>
    <p>
     <img alt="" height="1053" src="https://i-blog.csdnimg.cn/direct/f208ef0cc10f4450aea76a584af5a23b.png" width="2128"/>
    </p>
    <table>
     <thead>
      <tr>
       <th style="width: 116px;">
        分类
       </th>
       <th style="width: 572px;">
        设计模式名称
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="width:116px">
        创建型模式
       </td>
       <td style="width:572px">
        单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
       </td>
      </tr>
      <tr>
       <td style="width:116px">
        结构型模式
       </td>
       <td style="width:572px">
        适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式、代理模式
       </td>
      </tr>
      <tr>
       <td style="width:116px">
        行为型模式
       </td>
       <td style="width:572px">
        责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式
       </td>
      </tr>
     </tbody>
    </table>
    <h3 style="background-color:transparent">
     <strong>
      二、定义与描述
     </strong>
    </h3>
    <p>
     <img alt="" height="1002" src="https://i-blog.csdnimg.cn/direct/2c4ffb7a757a4be5b4b3677a39c08c93.png" width="2000"/>
    </p>
    <table>
     <thead>
      <tr>
       <th style="width: 112px;">
        <strong>
         设计模式
        </strong>
       </th>
       <th style="width: 152px;">
        <strong>
         定义与描述
        </strong>
       </th>
       <th>
        <strong>
         抽象背景
        </strong>
       </th>
       <th>
        <strong>
         适用场景与现实问题解决
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="width:112px">
        <strong>
         单例模式
        </strong>
       </td>
       <td style="width:152px">
        确保类仅有一个实例，提供全局访问点
       </td>
       <td>
        资源管理（如日志、配置、数据库连接）
       </td>
       <td>
        任务管理器、打印机队列（全局唯一控制）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         工厂方法模式
        </strong>
       </td>
       <td style="width:152px">
        定义创建对象的接口，子类决定实例化哪个类
       </td>
       <td>
        统一对象创建接口，应对产品族扩展
       </td>
       <td>
        框架扩展（Spring BeanFactory）、日志系统多实现
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         抽象工厂模式
        </strong>
       </td>
       <td style="width:152px">
        提供创建相关或依赖对象的接口，无需指定具体类
       </td>
       <td>
        管理产品族，保证客户端与具体实现解耦
       </td>
       <td>
        跨平台 UI 组件（如按钮、文本框）创建
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         建造者模式
        </strong>
       </td>
       <td style="width:152px">
        将复杂对象的构建与表示分离，允许相同构建过程创建不同表示
       </td>
       <td>
        分步构建复杂对象（如配置文件、SQL 查询）
       </td>
       <td>
        游戏角色创建（属性分步设置）、套餐组合（如汉堡套餐）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         原型模式
        </strong>
       </td>
       <td style="width:152px">
        通过复制现有实例创建新对象
       </td>
       <td>
        对象创建成本高（如数据库连接池预热）
       </td>
       <td>
        快速克隆对象（如游戏存档、缓存数据）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         适配器模式
        </strong>
       </td>
       <td style="width:152px">
        转换类接口，使其能协同工作
       </td>
       <td>
        旧系统与新接口兼容（如不同支付方式）
       </td>
       <td>
        第三方 API 集成（支付网关适配不同银行接口）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         桥接模式
        </strong>
       </td>
       <td style="width:152px">
        分离抽象与实现，使两者独立变化
       </td>
       <td>
        多维度扩展（如形状与颜色）
       </td>
       <td>
        跨平台开发（操作系统与 GUI 组件解耦）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         组合模式
        </strong>
       </td>
       <td style="width:152px">
        将对象组合成树形结构以表示整体 - 部分层次
       </td>
       <td>
        统一处理单个对象与组合对象
       </td>
       <td>
        文件系统目录管理、企业组织架构表示
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         装饰器模式
        </strong>
       </td>
       <td style="width:152px">
        动态添加职责，不改变原类结构
       </td>
       <td>
        功能扩展（如咖啡加配料）
       </td>
       <td>
        日志增强（记录执行时间、异常信息）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         外观模式
        </strong>
       </td>
       <td style="width:152px">
        提供统一接口简化子系统交互
       </td>
       <td>
        复杂系统对外暴露简单接口
       </td>
       <td>
        支付系统封装（整合银行、风控、日志等模块）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         享元模式
        </strong>
       </td>
       <td style="width:152px">
        共享大量细粒度对象以节省内存
       </td>
       <td>
        内存优化（如文本编辑器字符渲染）
       </td>
       <td>
        游戏角色池（复用相同模型的角色）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         代理模式
        </strong>
       </td>
       <td style="width:152px">
        控制对真实对象的访问
       </td>
       <td>
        延迟加载、访问控制（如权限验证）
       </td>
       <td>
        虚拟代理（图片懒加载）、远程代理（跨网络调用）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         责任链模式
        </strong>
       </td>
       <td style="width:152px">
        将请求沿处理链传递，直到有对象处理它
       </td>
       <td>
        请求处理者动态组合（如审批流程）
       </td>
       <td>
        请假审批链（主管→部门经理→CEO）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         命令模式
        </strong>
       </td>
       <td style="width:152px">
        将请求封装为对象，支持撤销、排队等操作
       </td>
       <td>
        操作封装与参数化（如 GUI 命令）
       </td>
       <td>
        游戏操作记录（支持撤销 / 重做）、任务队列
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         解释器模式
        </strong>
       </td>
       <td style="width:152px">
        定义语言的文法及解释器
       </td>
       <td>
        特定领域语言解析（如正则表达式）
       </td>
       <td>
        数学表达式计算、自定义配置语言解析
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         迭代器模式
        </strong>
       </td>
       <td style="width:152px">
        提供顺序访问聚合对象元素的方法
       </td>
       <td>
        遍历方式与数据结构解耦
       </td>
       <td>
        集合遍历（如 Java 的 Iterator）、树结构遍历
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         中介者模式
        </strong>
       </td>
       <td style="width:152px">
        用中介对象封装对象间交互
       </td>
       <td>
        减少对象间直接依赖（如 MVC 中的 Controller）
       </td>
       <td>
        聊天室消息转发、UI 组件交互（按钮与文本框解耦）
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         备忘录模式
        </strong>
       </td>
       <td style="width:152px">
        捕获并恢复对象状态
       </td>
       <td>
        状态保存与恢复（如游戏存档）
       </td>
       <td>
        编辑器撤销功能、数据库事务回滚
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         观察者模式
        </strong>
       </td>
       <td style="width:152px">
        对象状态变化时通知依赖它的对象
       </td>
       <td>
        发布 - 订阅机制（如事件监听）
       </td>
       <td>
        股票价格实时更新、消息推送系统
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         状态模式
        </strong>
       </td>
       <td style="width:152px">
        对象行为随状态改变而变化
       </td>
       <td>
        状态驱动的行为（如订单状态机）
       </td>
       <td>
        电梯状态控制（运行 / 停止 / 维修）、工作流引擎
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         策略模式
        </strong>
       </td>
       <td style="width:152px">
        定义算法族，允许在运行时选择算法
       </td>
       <td>
        算法动态切换（如排序策略）
       </td>
       <td>
        支付方式选择（支付宝 / 微信 / 信用卡）、日志级别控制
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         模板方法模式
        </strong>
       </td>
       <td style="width:152px">
        定义操作步骤，子类实现具体步骤
       </td>
       <td>
        流程固定但部分步骤可变（如数据处理流程）
       </td>
       <td>
        电商订单处理流程（支付→发货→通知）、测试用例基类
       </td>
      </tr>
      <tr>
       <td style="width:112px">
        <strong>
         访问者模式
        </strong>
       </td>
       <td style="width:152px">
        封装作用于对象结构的操作
       </td>
       <td>
        数据结构与操作分离（如报表生成）
       </td>
       <td>
        编译器语法树遍历、XML 文档解析
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     三、综合对比
    </h3>
    <table>
     <thead>
      <tr>
       <th style="width: 100px;">
        <strong>
         设计模式
        </strong>
       </th>
       <th style="width: 95px;">
        <strong>
         优点
        </strong>
       </th>
       <th style="width: 89px;">
        <strong>
         缺点
        </strong>
       </th>
       <th>
        <strong>
         升级版
        </strong>
       </th>
       <th style="width: 104px;">
        <strong>
         线程安全支持
        </strong>
       </th>
       <th style="width: 170px;">
        <strong>
         核心应用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="width:100px">
        <strong>
         单例模式
        </strong>
       </td>
       <td style="width:95px">
        控制实例数量，节省资源
       </td>
       <td style="width:89px">
        全局状态影响测试，扩展性差
       </td>
       <td>
        枚举单例、线程安全懒加载
       </td>
       <td style="width:104px">
        需手动实现
       </td>
       <td style="width:170px">
        日志系统、配置管理、数据库连接池
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         工厂方法模式
        </strong>
       </td>
       <td style="width:95px">
        解耦对象创建与使用，支持扩展
       </td>
       <td style="width:89px">
        子类爆炸问题
       </td>
       <td>
        结合依赖注入
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        框架扩展（Spring BeanFactory）、日志系统多实现
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         抽象工厂模式
        </strong>
       </td>
       <td style="width:95px">
        统一管理产品族，保证兼容性
       </td>
       <td style="width:89px">
        新增产品类型需修改抽象类
       </td>
       <td>
        泛型工厂
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        跨平台 UI 组件（按钮、文本框）创建
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         建造者模式
        </strong>
       </td>
       <td style="width:95px">
        分步构建复杂对象，灵活性高
       </td>
       <td style="width:89px">
        增加类数量
       </td>
       <td>
        流式 API
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        游戏角色创建、套餐组合（汉堡 + 饮料）
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         原型模式
        </strong>
       </td>
       <td style="width:95px">
        快速克隆对象，减少创建成本
       </td>
       <td style="width:89px">
        深拷贝可能引发性能问题
       </td>
       <td>
        序列化克隆
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        游戏存档、缓存数据快速复制
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         适配器模式
        </strong>
       </td>
       <td style="width:95px">
        兼容不兼容接口，复用旧代码
       </td>
       <td style="width:89px">
        增加一层间接性
       </td>
       <td>
        双向适配器
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        第三方 API 集成（支付网关适配不同银行）
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         桥接模式
        </strong>
       </td>
       <td style="width:95px">
        分离抽象与实现，支持独立扩展
       </td>
       <td style="width:89px">
        设计复杂度高
       </td>
       <td>
        结合依赖注入
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        跨平台开发（操作系统与 GUI 组件解耦）
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         组合模式
        </strong>
       </td>
       <td style="width:95px">
        统一处理单个对象与组合对象
       </td>
       <td style="width:89px">
        树形结构遍历可能复杂
       </td>
       <td>
        透明组合
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        文件系统目录管理、企业组织架构表示
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         装饰器模式
        </strong>
       </td>
       <td style="width:95px">
        动态扩展功能，不改变原类结构
       </td>
       <td style="width:89px">
        多层装饰影响性能
       </td>
       <td>
        链式调用、注解增强
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        日志增强（记录执行时间、异常信息）
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         外观模式
        </strong>
       </td>
       <td style="width:95px">
        简化子系统交互，降低依赖
       </td>
       <td style="width:89px">
        可能成为性能瓶颈
       </td>
       <td>
        微服务网关
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        支付系统封装（整合银行、风控、日志）
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         享元模式
        </strong>
       </td>
       <td style="width:95px">
        共享对象节省内存
       </td>
       <td style="width:89px">
        增加系统复杂度
       </td>
       <td>
        结合缓存机制
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        游戏角色池（复用相同模型）、文本编辑器字符渲染
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         代理模式
        </strong>
       </td>
       <td style="width:95px">
        控制访问，支持延迟加载
       </td>
       <td style="width:89px">
        增加代理类
       </td>
       <td>
        动态代理（如 Java 反射）
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        图片懒加载、远程服务调用
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         责任链模式
        </strong>
       </td>
       <td style="width:95px">
        请求处理者动态组合，扩展性强
       </td>
       <td style="width:89px">
        可能导致请求未被处理
       </td>
       <td>
        动态责任链
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        请假审批链（主管→部门经理→CEO）
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         命令模式
        </strong>
       </td>
       <td style="width:95px">
        支持撤销、重做、日志记录
       </td>
       <td style="width:89px">
        命令类数量多
       </td>
       <td>
        结合备忘录模式
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        游戏操作记录、任务队列
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         解释器模式
        </strong>
       </td>
       <td style="width:95px">
        自定义语言解析灵活
       </td>
       <td style="width:89px">
        复杂文法性能差
       </td>
       <td>
        结合语法树优化
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        数学表达式计算、配置语言解析
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         迭代器模式
        </strong>
       </td>
       <td style="width:95px">
        遍历方式与数据结构解耦
       </td>
       <td style="width:89px">
        可能限制遍历方式
       </td>
       <td>
        双向迭代器
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        集合遍历（Java Iterator）、树结构遍历
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         中介者模式
        </strong>
       </td>
       <td style="width:95px">
        减少对象间直接依赖
       </td>
       <td style="width:89px">
        中介者可能过度复杂
       </td>
       <td>
        事件总线
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        聊天室消息转发、UI 组件交互
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         备忘录模式
        </strong>
       </td>
       <td style="width:95px">
        保存与恢复对象状态
       </td>
       <td style="width:89px">
        内存消耗大
       </td>
       <td>
        差异存储
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        编辑器撤销功能、数据库事务回滚
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         观察者模式
        </strong>
       </td>
       <td style="width:95px">
        支持发布 - 订阅机制，松耦合
       </td>
       <td style="width:89px">
        通知顺序难以控制
       </td>
       <td>
        响应式编程（RxJava）
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        股票价格更新、消息推送系统
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         状态模式
        </strong>
       </td>
       <td style="width:95px">
        状态驱动行为，避免条件判断
       </td>
       <td style="width:89px">
        状态类数量多
       </td>
       <td>
        状态机框架
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        电梯状态控制、工作流引擎
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         策略模式
        </strong>
       </td>
       <td style="width:95px">
        动态切换算法，扩展性强
       </td>
       <td style="width:89px">
        客户端需了解所有策略
       </td>
       <td>
        策略工厂
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        支付方式选择、日志级别控制
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         模板方法模式
        </strong>
       </td>
       <td style="width:95px">
        固定流程，子类实现细节
       </td>
       <td style="width:89px">
        子类必须实现所有抽象方法
       </td>
       <td>
        钩子方法增强
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        订单处理流程（支付→发货→通知）、测试用例基类
       </td>
      </tr>
      <tr>
       <td style="width:100px">
        <strong>
         访问者模式
        </strong>
       </td>
       <td style="width:95px">
        数据结构与操作分离
       </td>
       <td style="width:89px">
        新增操作需修改所有访问者
       </td>
       <td>
        双分派机制
       </td>
       <td style="width:104px">
        无
       </td>
       <td style="width:170px">
        编译器语法树遍历、XML 文档解析
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     四、综合应用
    </h3>
    <h4 style="background-color:transparent">
     <strong>
      (一)、
     </strong>
     文档编辑器
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：
     <strong>
      组合模式 + 装饰器模式 + 策略模式 + 观察者模式
     </strong>
    </p>
    <p>
     文档编辑器（树形结构管理 + 格式装饰 + 保存策略 + 实时预览）
    </p>
    <pre><code class="language-java">// 组合模式：文档结构
interface DocumentComponent {
    void print();
    void accept(Visitor visitor);
}

class TextElement implements DocumentComponent {
    private String content;
    public TextElement(String content) { this.content = content; }
    public void print() { System.out.println(content); }
    public void accept(Visitor visitor) { visitor.visit(this); }
}

class CompositeElement implements DocumentComponent {
    private List&lt;DocumentComponent&gt; children = new ArrayList&lt;&gt;();
    public void add(DocumentComponent component) { children.add(component); }
    public void print() { children.forEach(DocumentComponent::print); }
    public void accept(Visitor visitor) { visitor.visit(this); }
}

// 装饰器模式：格式增强
abstract class FormatDecorator implements DocumentComponent {
    protected DocumentComponent component;
    public FormatDecorator(DocumentComponent component) { this.component = component; }
    public abstract void print();
    public void accept(Visitor visitor) { component.accept(visitor); }
}

class BoldDecorator extends FormatDecorator {
    public BoldDecorator(DocumentComponent component) { super(component); }
    public void print() { System.out.printf("&lt;b&gt;%s&lt;/b&gt;", component); }
}

// 策略模式：保存策略
interface SaveStrategy {
    void save(DocumentComponent doc);
}

class HtmlSaveStrategy implements SaveStrategy {
    public void save(DocumentComponent doc) {
        System.out.println("Saving as HTML...");
        doc.accept(new HtmlVisitor());
    }
}

// 观察者模式：实时预览
interface Observer {
    void update(DocumentComponent doc);
}

class PreviewWindow implements Observer {
    public void update(DocumentComponent doc) {
        System.out.println("Preview updated:");
        doc.print();
    }
}

class DocumentManager implements Subject {
    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();
    private DocumentComponent document;
    
    public void attach(Observer observer) { observers.add(observer); }
    public void notifyObservers() { observers.forEach(o -&gt; o.update(document)); }
    
    public void setDocument(DocumentComponent doc) {
        this.document = doc;
        notifyObservers();
    }
}</code></pre>
    <p>
     <strong>
      类图：
     </strong>
    </p>
    <p>
     <img alt="" height="761" src="https://i-blog.csdnimg.cn/direct/af292683fc8842dca285b51c0a7d764e.png" width="1148"/>
    </p>
    <p>
     <strong>
      时序图：
     </strong>
    </p>
    <p>
     <img alt="" height="836" src="https://i-blog.csdnimg.cn/direct/18e535f7c98d48c3ad2d18770a133f01.png" width="1411"/>
    </p>
    <p>
     <strong>
      典型组合方案
     </strong>
     ：
    </p>
    <p>
     <strong>
      树形结构 + 动态扩展
     </strong>
     ：组合模式 + 装饰器模式
    </p>
    <p>
     <strong>
      流程控制 + 算法选择
     </strong>
     ：责任链模式 + 策略模式
    </p>
    <p>
     <strong>
      数据遍历 + 操作分离
     </strong>
     ：迭代器模式 + 访问者模式
    </p>
    <h4 style="background-color:transparent">
     <strong>
      (二)、
     </strong>
     电商订单处理
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：
     <strong>
      组合模式 + 责任链模式 + 策略模式
     </strong>
    </p>
    <p>
     电商订单处理（订单拆分 → 多级审批 → 支付方式选择）
    </p>
    <pre><code class="language-java">// 组合模式：订单结构
class OrderComponent {
    protected double amount;
    public abstract void process();
}

class CompositeOrder extends OrderComponent {
    private List&lt;OrderComponent&gt; children = new ArrayList&lt;&gt;();
    public void add(OrderComponent child) { children.add(child); }
    public void process() {
        children.forEach(OrderComponent::process);
    }
}

// 责任链模式：审批链
abstract class Approver {
    protected Approver successor;
    public void setSuccessor(Approver successor) { this.successor = successor; }
    public abstract void approve(OrderComponent order);
}

class ManagerApprover extends Approver {
    public void approve(OrderComponent order) {
        if (order.amount &lt; 1000) {
            System.out.println("Manager approved");
        } else if (successor != null) {
            successor.approve(order);
        }
    }
}

// 策略模式：支付方式
interface PaymentStrategy {
    void pay(double amount);
}

class CreditCardStrategy implements PaymentStrategy {
    public void pay(double amount) {
        System.out.printf("Paid $%.2f via Credit Card%n", amount);
    }
}</code></pre>
    <p>
     <strong>
      类图：
     </strong>
     <img alt="" height="409" src="https://i-blog.csdnimg.cn/direct/6dc94d35c4be4898acbdddaf1c511d6b.png" width="1214"/>
    </p>
    <p>
     <strong>
      时序图：
     </strong>
    </p>
    <p>
     <img alt="" height="834" src="https://i-blog.csdnimg.cn/direct/12febd45947f40539590c97569d860c7.png" width="687"/>
    </p>
    <p>
    </p>
    <h4>
     <strong>
      (三)、
     </strong>
     文件系统遍历
    </h4>
    <p>
     <strong>
      场景
     </strong>
     ：
     <strong>
      组合模式 + 迭代器模式 + 访问者模式
     </strong>
    </p>
    <p>
     文件系统遍历（目录结构 → 迭代访问 → 统计文件信息）
    </p>
    <pre><code class="language-java">// 组合模式：文件系统节点
interface FileSystemNode {
    void accept(FileVisitor visitor);
}

class File implements FileSystemNode {
    private String name;
    public void accept(FileVisitor visitor) { visitor.visit(this); }
}

class Directory implements FileSystemNode {
    private List&lt;FileSystemNode&gt; children = new ArrayList&lt;&gt;();
    public void add(FileSystemNode node) { children.add(node); }
    public void accept(FileVisitor visitor) {
        visitor.visit(this);
        children.forEach(n -&gt; n.accept(visitor));
    }
}

// 迭代器模式：遍历器
class FileSystemIterator implements Iterator&lt;FileSystemNode&gt; {
    private Stack&lt;FileSystemNode&gt; stack = new Stack&lt;&gt;();
    
    public FileSystemIterator(FileSystemNode root) {
        stack.push(root);
    }
    
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    public FileSystemNode next() {
        FileSystemNode node = stack.pop();
        if (node instanceof Directory) {
            ((Directory) node).getChildren().forEach(stack::push);
        }
        return node;
    }
}

// 访问者模式：文件统计
class FileVisitor {
    public void visit(File file) {
        System.out.println("File: " + file.getName());
    }
    
    public void visit(Directory directory) {
        System.out.println("Directory: " + directory.getName());
    }
}</code></pre>
    <p>
     <strong>
      类图：
     </strong>
    </p>
    <p>
     <img alt="" height="907" src="https://i-blog.csdnimg.cn/direct/f8135c2727c0426297de7af44cc321bd.png" width="907"/>
    </p>
    <p>
     <strong>
      时序图：
     </strong>
    </p>
    <p>
     <img alt="" height="827" src="https://i-blog.csdnimg.cn/direct/995eb4e1c5094e3ea35ab7b752ff8dfa.png" width="1417"/>
    </p>
    <p>
     <strong>
      典型组合方案
     </strong>
     ：
    </p>
    <p>
     <strong>
      树形结构 + 动态扩展
     </strong>
     ：组合模式 + 装饰器模式
    </p>
    <p>
     <strong>
      流程控制 + 算法选择
     </strong>
     ：责任链模式 + 策略模式
    </p>
    <p>
     <strong>
      数据遍历 + 操作分离
     </strong>
     ：迭代器模式 + 访问者模式
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f776e6d32332f:61727469636c652f64657461696c732f313436313433363834" class_="artid" style="display:none">
 </p>
</div>


