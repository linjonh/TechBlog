---
layout: post
title: "嵌入式八股C语言-变量与运算符篇"
date: 2025-03-07 14:51:04 +0800
description: "最全嵌入式八股收录"
keywords: "嵌入式八股C语言---变量与运算符篇"
categories: ['嵌入式八股']
tags: ['单片机', 'Stm', 'C']
artid: "146095759"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146095759
    alt: "嵌入式八股C语言-变量与运算符篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146095759
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146095759
cover: https://bing.ee123.net/img/rand?artid=146095759
image: https://bing.ee123.net/img/rand?artid=146095759
img: https://bing.ee123.net/img/rand?artid=146095759
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     嵌入式八股C语言---变量与运算符篇
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     变量
    </h2>
    <ol>
     <li>
      全局变量与局部变量重名
      <br/>
      可以的 此时全局变量就失效了
     </li>
     <li>
      全局变量能否放在头文件中
      <br/>
      没有问题,但不太推荐
     </li>
    </ol>
    <ul>
     <li>
      2.1做法一:
      <br/>
      如果是不小心重名了,但是实际上这俩变量根本没任何关系,那就用static修饰,这样变量的作用域就会限制在本文件内,此时每个.c文件的变量都独立的 没关系
     </li>
     <li>
      2.2做法二:
      <br/>
      只有一个头文件初始化了这个全局变量,别的头文件没初始化就行;
      <br/>
      做法二涉及到了
      <strong>
       符号决议 + 试探性定义
      </strong>
      (链接的时候的事情,后面细讲)
      <br/>
      我们在linux中运行如下代码
     </li>
    </ul>
    <pre><code class="prism language-c">        <span class="token comment">// a.h</span>
        <span class="token comment">// int global_K = 10;</span>
        <span class="token comment">// b.c</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"a.h"</span></span>
        <span class="token keyword">int</span> global_k<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\r\n"</span><span class="token punctuation">,</span>global_k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 打印的值是20</span>
</code></pre>
    <p>
     当然这个也看具体编译和链接的实现,作者在windows下这么干就直接报错了…
    </p>
    <ul>
     <li>
      2.3做法三:
      <br/>
      在需要用到全局变量的头文件中extern 声明
      <br/>
      最好还是头文件声明 + 源文件定义啦
     </li>
    </ul>
    <ol start="3">
     <li>
      变量的 存储类型 作用域 生命周期 链接属性
     </li>
    </ol>
    <ul>
     <li>
      3.1存储类型
      <br/>
      变量的存储类型决定于我们前面的存储类关键字 不同的存储类关键字决定了变量定义在不同位置(这也是为啥这几个关键字不能一起用)
      <br/>
      auto: 放在栈中 局部变量 随着函数调用结束就销毁了
      <br/>
      static: 放在静态存储区: BSS段(未初始化的静态变量) / 放在数据段(初始化的静态变量)
      <br/>
      register: 建议编译器放在寄存器中–此时不能对变量做求址运算
      <br/>
      extern: 声明了变量的链接属性
     </li>
     <li>
      3.2作用域
      <br/>
      变量的有效范围
      <ul>
       <li>
        局部变量(不管static修饰不修饰)
        <br/>
        作用域就限定在函数(或者说花括号里)死死的
        <br/>
        int main()
        <br/>
        { // 直接就报错了
        <br/>
        {
        <!-- -->
        <br/>
        int i;
        <br/>
        }
        <br/>
        printf(“%d\r\n”,global_k,i);
        <br/>
        }
       </li>
       <li>
        全局变量
        <br/>
        默认作用域是整个文件(a.c 定义 b.c只要extern了同名变量就能用)
        <br/>
        也可以static修饰限制到a.c本身
       </li>
      </ul>
     </li>
     <li>
      3.3生命周期
      <br/>
      变量的一生无非是: 创建-&gt;存在-&gt;销毁
      <br/>
      全局变量生命周期:和程序一样
      <br/>
      栈上的局部变量生命周期:随着函数调用结束结束了
      <br/>
      堆上变量的生命周期:由程序员管理
     </li>
     <li>
      3.4链接属性
      <br/>
      外部链接属性 / 内部链接属性 / 无链接属性
      <br/>
      外部链接属性: 全局变量 / 函数
      <br/>
      内部链接属性: static 修饰的 变量/函数 只能在本文件内部
      <br/>
      无链接属性: 局部变量不能被链接
      <br/>
      <strong>
       所以存储类关键字实现上决定了变量的存储类型 / 作用域 / 生命周期
      </strong>
     </li>
    </ul>
    <h2>
     <a id="_60">
     </a>
     运算符
    </h2>
    <ol>
     <li>
      <p>
       优先级
       <br/>
       不用死记硬背 但是得知道最基本的
      </p>
      <ul>
       <li>
        比如最高的是 () [] -&gt; .
       </li>
       <li>
        &amp; 和 * 是第二高的,不是第一高的！
       </li>
      </ul>
     </li>
     <li>
      <p>
       分析组合起来的运算符
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b0a0a0db5adb43768da2b5b36438d301.png"/>
      </p>
      <p>
       int (*p)(int ,int );
       <br/>
       // 这是一个指针 名字叫p
       <br/>
       // 往右看(是个括号) 所以这个指针指向一个函数
       <br/>
       // 函数的返回值是int
       <br/>
       // 传入的参数是int 类型
      </p>
     </li>
     <li>
      <p>
       "="运算符的返回值
       <br/>
       比如 while(a = b); // 不仅把值赋给了a 还会有一个返回值
       <br/>
       <strong>
        返回值是等号左边的变量的值
       </strong>
      </p>
     </li>
     <li>
      <p>
       " ++运算符"
       <br/>
       a++ 等价于 a = a + 1; //需要又一个temp存储临时结果
       <br/>
       ++a 是直接对a操作 不用临时变量 效果更好
       <br/>
       <strong>
        不过我能想到的 一般编译器也就想到做好优化了
       </strong>
      </p>
     </li>
     <li>
      <p>
       强制类型转换
      </p>
     </li>
    </ol>
    <ul>
     <li>
      5.1指针的强制转换
      <br/>
      这里后面指针在细细分析 毕竟指针的 +1 太有说法了
     </li>
     <li>
      5.2隐式类型转换–感觉和编译器有关系
      <br/>
      规则:从低精度向高精度、从有符号数向无符号数方向转换
      <br/>
      // 在算数运算中,所有比int小的都转换int进行计算 如果转int不够就转unsigned int计算
     </li>
    </ul>
    <pre><code class="prism language-c">        <span class="token keyword">void</span> <span class="token function">compare_data1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span>  <span class="token comment">// 打印的是这个 因为是按照int去做操作的(看汇编代码)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a &lt; b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a &gt; b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>  
        <span class="token keyword">void</span> <span class="token function">compare_data2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a &lt; b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">// 实际打印是这个 因为都转为了无符号数</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a &gt; b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>  
</code></pre>
    <p>
     借着博客这里的答案来说:https://www.cnblogs.com/MinPage/p/14117237.html
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fc811f16fc3944e6ace7de8616b1925c.png"/>
    </p>
    <ol start="6">
     <li>
      短路求值
      <br/>
      对于 || 运算符 从左向右运算 只要有一个为真 后面的就不算了
      <br/>
      对于 &amp;&amp; 运算符 从左向右运算 只要有一个为假 后面的就不算了
     </li>
     <li>
      左值与右值
     </li>
    </ol>
    <ul>
     <li>
      什么是左值、右值、对象、副作用、未定义行为
      <ul>
       <li>
        左值:等于号左边的 一般来说值可以改变 就把左值当做
        <strong>
         一块内存的别名
        </strong>
        就行
       </li>
       <li>
        右值:表达式 具体的值往往运行期间才可以确定
       </li>
       <li>
        未定义行为: 数据访问越界 / 重复释放内存 / 直接操作未初始化的局部变量
       </li>
      </ul>
     </li>
     <li>
      什么是结合性、左结合、右结合？
      <br/>
      结合性决定了当一个表达式中出现多个具有相同优先级的运算符时，这些运算符是如何组合的
      <br/>
      左结合意味着相同优先级的运算符会从左向右计算。
      <br/>
      右结合意味着相同优先级的运算符会从右向左计算。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353733313834352f:61727469636c652f64657461696c732f313436303935373539" class_="artid" style="display:none">
 </p>
</div>


