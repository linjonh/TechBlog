---
layout: post
title: "498.-对角线遍历"
date: 2025-08-30T15:45:02+0800
description: "498. 对角线遍历"
keywords: "498. 对角线遍历"
categories: ['未分类']
tags: ['C']
artid: "151020493"
arturl: "https://blog.csdn.net/weixin_45256307/article/details/151020493"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151020493
    alt: "498.-对角线遍历"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151020493
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151020493
cover: https://bing.ee123.net/img/rand?artid=151020493
image: https://bing.ee123.net/img/rand?artid=151020493
img: https://bing.ee123.net/img/rand?artid=151020493
---



# 498. 对角线遍历



### 498. 对角线遍历

---

题目链接：[498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/description/)

***代码如下：***

```cpp
class Solution {
public:
	vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
		int m = mat.size(), n = mat[0].size();
		vector<int> res;
		res.reserve(m * n); // 预分配空间
		for (int k = 0;k < m + n - 1;k++) {
			int min_j = max(k - m + 1, 0);
			int max_j = min(k, n - 1);
			
			if (k % 2 == 0) {
				//偶数从左到右
				for (int j = min_j;j <= max_j;j++) {
					res.push_back(mat[k - j][j]);
				}
			}
			else {
				//奇数从右到左
				for (int j = max_j;j >= min_j;j--) {
					res.push_back(mat[k - j][j]);
				}
			}
		}
		return res;
	}
};

```



