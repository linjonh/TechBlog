---
layout: post
title: "redis使用redis作为缓存时所注意事项"
date: 2025-03-09 17:24:45 +0800
description: "使用redis作为缓存时需要注意的事项"
keywords: "【redis】使用redis作为缓存时所注意事项"
categories: ['Redis']
tags: ['缓存', 'Redis']
artid: "146135187"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146135187
    alt: "redis使用redis作为缓存时所注意事项"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146135187
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146135187
cover: https://bing.ee123.net/img/rand?artid=146135187
image: https://bing.ee123.net/img/rand?artid=146135187
img: https://bing.ee123.net/img/rand?artid=146135187
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【redis】使用redis作为缓存时所注意事项
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     缓存更新策略
    </h2>
    <p>
     在 Redis 缓存中，缓存的更新策略主要有**定期生成（定时更新）
     <strong>
      和
     </strong>
     实时生成（即时更新）**两种方式。不同的策略适用于不同的业务场景，涉及性能、数据一致性和系统负载等方面的权衡。
    </p>
    <hr/>
    <h3>
     <strong>
      1. 定期生成（定时更新）
     </strong>
    </h3>
    <h5>
     <strong>
      是什么？
     </strong>
    </h5>
    <p>
     定期生成指的是按照
     <strong>
      固定的时间间隔
     </strong>
     ，主动更新缓存，而不是在数据发生变化时立即更新。这种方式适用于数据变化不频繁、对实时性要求不高的场景。
    </p>
    <h4>
     <strong>
      优点：
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      降低数据库压力
     </strong>
     ：缓存可以批量更新，避免频繁查询数据库。
     <br/>
     ✅
     <strong>
      提高查询性能
     </strong>
     ：查询时直接读取缓存，响应速度快。
     <br/>
     ✅
     <strong>
      数据一致性较好
     </strong>
     （相对于长期不更新的缓存）：定期更新可以保证数据不会长期过时。
    </p>
    <h4>
     <strong>
      缺点：
     </strong>
    </h4>
    <p>
     ❌
     <strong>
      数据可能不够实时
     </strong>
     ：在缓存下一次更新前，数据可能已经变化，但缓存仍然返回旧数据。
     <br/>
     ❌
     <strong>
      不适合高实时性业务
     </strong>
     ：如果业务需要频繁变更数据，定期更新可能导致缓存数据滞后。
     <br/>
     ❌
     <strong>
      可能会引起短时流量冲击
     </strong>
     ：如果所有缓存数据同时更新，可能会对数据库造成瞬间压力。
    </p>
    <h4>
     <strong>
      常见实现方式：
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        定时任务更新缓存
       </strong>
       （
       <strong>
        Time-based Refresh
       </strong>
       ）
      </p>
      <ul>
       <li>
        使用
        <strong>
         Spring Task、Quartz、Crontab
        </strong>
        等定时任务，每隔一段时间刷新缓存。
       </li>
       <li>
        例如，每 10 分钟更新一次缓存：
        <pre><code class="language-java">@Scheduled(fixedRate = 600000) // 每 10 分钟执行一次
public void updateCache() {
    // 查询数据库并更新缓存
    List&lt;Data&gt; dataList = databaseService.getData();
    redisTemplate.opsForValue().set("cache:data", dataList);
}
</code></pre>
        <p>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数据库变更时触发缓存更新
       </strong>
       （
       <strong>
        Database-triggered Refresh
       </strong>
       ）
      </p>
      <ul>
       <li>
        监听
        <strong>
         数据库变更事件（MySQL Binlog、PostgreSQL 触发器）
        </strong>
        ，检测到数据变化后批量刷新缓存。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        异步任务更新
       </strong>
      </p>
      <ul>
       <li>
        使用消息队列（Kafka、RabbitMQ）通知服务更新缓存，避免定时任务导致的瞬时数据库压力过大。
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <p>
     📌 统计数据、排行榜、热门商品列表等（更新频率较低，数据稍有延迟也无大问题）。
     <br/>
     📌 日志分析、报表数据等（数据量大，但对实时性要求不高）。
    </p>
    <hr/>
    <h3>
     <strong>
      2. 实时生成（即时更新）
     </strong>
    </h3>
    <h5>
     <strong>
      是什么？
     </strong>
    </h5>
    <p>
     实时生成指的是
     <strong>
      数据发生变更时立即更新缓存
     </strong>
     ，确保缓存数据始终是最新的。这种方式适用于
     <strong>
      对数据一致性要求高、变更较频繁
     </strong>
     的场景。
    </p>
    <h4>
     <strong>
      优点：
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      数据实时性高
     </strong>
     ：缓存的数据始终与数据库保持一致，适用于高实时性需求的应用。
     <br/>
     ✅
     <strong>
      避免缓存不一致问题
     </strong>
     ：数据库变更后立即同步缓存，减少数据不匹配的情况。
    </p>
    <h4>
     <strong>
      缺点：
     </strong>
    </h4>
    <p>
     ❌
     <strong>
      更新成本高
     </strong>
     ：每次数据变更都需要更新缓存，可能会导致数据库压力增大。
     <br/>
     ❌
     <strong>
      可能导致缓存频繁更新
     </strong>
     ：对于高频变更的数据，频繁更新可能会导致 Redis 负载过重，甚至影响整体性能。
     <br/>
     ❌
     <strong>
      并发问题
     </strong>
     ：多个并发请求可能会导致
     <strong>
      缓存不一致
     </strong>
     或
     <strong>
      缓存击穿
     </strong>
     ，需要加锁或使用双写策略。
    </p>
    <h4>
     <strong>
      常见实现方式：
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        数据库更新时主动更新缓存
       </strong>
       （
       <strong>
        Write-through Strategy
       </strong>
       ）
      </p>
      <ul>
       <li>
        在 **数据更新（新增、修改、删除）**时，
        <strong>
         同时更新数据库和缓存
        </strong>
        ：
        <pre><code class="language-java">public void updateData(Data data) {
    databaseService.updateData(data); // 更新数据库
    redisTemplate.opsForValue().set("cache:data:" + data.getId(), data); // 同步更新缓存
}
</code></pre>
        <p>
        </p>
       </li>
       <li>
        适用于数据变更不频繁，且一致性要求较高的场景。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        缓存淘汰（Cache Eviction）
       </strong>
      </p>
      <ul>
       <li>
        在数据库更新后，
        <strong>
         删除缓存
        </strong>
        ，让下一次查询时重新加载数据：
        <pre><code class="language-java">public void updateData(Data data) {
    databaseService.updateData(data); // 更新数据库
    redisTemplate.delete("cache:data:" + data.getId()); // 删除缓存
}
</code></pre>
        <p>
        </p>
       </li>
       <li>
        适用于
        <strong>
         缓存数据不是热点
        </strong>
        ，数据变更后不需要立即被查询的情况。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        订阅数据库变更
       </strong>
       （
       <strong>
        Event-based Strategy
       </strong>
       ）
      </p>
      <ul>
       <li>
        使用
        <strong>
         消息队列（Kafka、RabbitMQ）
        </strong>
        或
        <strong>
         Redis 订阅/发布机制
        </strong>
        ，监听数据库变更事件，变更后更新缓存。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分布式锁（避免缓存并发写入问题）
       </strong>
      </p>
      <ul>
       <li>
        解决多个请求同时更新缓存导致数据不一致的问题：
        <pre><code class="language-java">RLock lock = redissonClient.getLock("cache:lock:data:" + data.getId());
try {
    if (lock.tryLock(5, TimeUnit.SECONDS)) {
        databaseService.updateData(data);
        redisTemplate.opsForValue().set("cache:data:" + data.getId(), data);
    }
} finally {
    lock.unlock();
}
</code></pre>
        <p>
        </p>
       </li>
       <li>
        适用于高并发写入场景，防止缓存同时被多个请求覆盖。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <p>
     📌 订单系统、支付系统、库存管理等（数据必须实时更新，不能有延迟）。
     <br/>
     📌 直播、弹幕系统（数据实时变化，需要确保一致性）。
    </p>
    <hr/>
    <h3>
     <strong>
      总结：定期生成 vs. 实时生成
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        策略
       </th>
       <th>
        <strong>
         定期生成（定时更新）
        </strong>
       </th>
       <th>
        <strong>
         实时生成（即时更新）
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         数据实时性
        </strong>
       </td>
       <td>
        低（有一定延迟）
       </td>
       <td>
        高（数据库更新即缓存更新）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据库压力
        </strong>
       </td>
       <td>
        低（定期批量更新）
       </td>
       <td>
        高（频繁更新缓存）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         缓存命中率
        </strong>
       </td>
       <td>
        高（查询时直接命中缓存）
       </td>
       <td>
        可能较低（某些情况需删除缓存）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        排行榜、统计数据、报表等
       </td>
       <td>
        订单、库存、支付等高一致性业务
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       定期生成（定时更新）
      </strong>
      适用于
      <strong>
       数据变化不频繁
      </strong>
      、
      <strong>
       对实时性要求不高
      </strong>
      的场景，如排行榜、日志分析等。
     </li>
     <li>
      <strong>
       实时生成（即时更新）
      </strong>
      适用于
      <strong>
       数据变化频繁
      </strong>
      、
      <strong>
       对一致性要求高
      </strong>
      的场景，如支付、库存、订单管理等。
     </li>
     <li>
      在实际应用中，可以
      <strong>
       结合两种策略
      </strong>
      ，例如：
      <ul>
       <li>
        <strong>
         定期更新 + 变更触发更新
        </strong>
        ：大部分数据定期刷新，关键数据实时更新。
       </li>
       <li>
        <strong>
         读时更新 + 写时淘汰
        </strong>
        ：查询时自动更新缓存，写入时删除缓存，防止数据不一致。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     合理选择缓存更新策略，可以有效提升系统性能，降低数据库压力，并保证数据的一致性。
    </p>
    <p>
     Redis 作为缓存，存储空间有限，因此需要淘汰数据来保证新数据的存入。Redis 提供了多种
     <strong>
      缓存淘汰策略（Eviction Policy）
     </strong>
     ，用于决定哪些数据需要被删除。下面介绍几种常见的淘汰策略，包括它们的适用场景和优缺点。
    </p>
    <hr/>
    <h2 style="background-color:transparent">
     缓存淘汰策略
    </h2>
    <h3 style="background-color:transparent">
     <strong>
      1. 不淘汰策略
     </strong>
    </h3>
    <h4>
     <strong>
      1.1 noeviction（拒绝写入）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <p>
     当 Redis 内存占满时，不会删除任何已有数据，而是直接返回错误，拒绝新的写入请求。
    </p>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于
      <strong>
       严格不能丢数据
      </strong>
      的场景，如任务队列（消息队列）、金融交易等。
     </li>
     <li>
      适用于 Redis 作为
      <strong>
       纯数据存储
      </strong>
      而非缓存时。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      数据不会被误删除
     </strong>
     ，保证数据完整性。
     <br/>
     ❌
     <strong>
      可能导致写入失败
     </strong>
     ，影响系统稳定性。
    </p>
    <hr/>
    <h3>
     <strong>
      2. 基于 TTL（过期时间）的淘汰策略
     </strong>
    </h3>
    <h4>
     <strong>
      2.1 volatile-lru（最近最少使用，TTL 限定）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <ul>
     <li>
      只淘汰**设置了过期时间（TTL）**的键。
     </li>
     <li>
      在这些键中，优先删除最近最少使用（LRU, Least Recently Used）的数据。
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于
      <strong>
       部分数据可丢弃
      </strong>
      的场景，比如 session、短期缓存数据。
     </li>
     <li>
      适用于需要
      <strong>
       自动过期控制
      </strong>
      ，但仍希望尽可能保留热点数据的情况。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      优先保留常用数据，减少缓存击穿的概率。
     </strong>
     <br/>
     ❌
     <strong>
      如果大部分 key 没有 TTL，可能导致 Redis 直接拒绝写入（相当于 noeviction）。
     </strong>
    </p>
    <hr/>
    <h4>
     <strong>
      2.2 volatile-ttl（优先淘汰即将过期的键）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <ul>
     <li>
      只淘汰**设置了过期时间（TTL）**的键。
     </li>
     <li>
      其中
      <strong>
       剩余寿命最短
      </strong>
      的键优先被删除。
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于对数据有明确的生命周期需求的业务，如订单缓存、验证码缓存等。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      优先删除即将过期的数据，保证短期缓存的更新。
     </strong>
     <br/>
     ❌
     <strong>
      可能误删仍然有价值的热点数据。
     </strong>
    </p>
    <hr/>
    <h3>
     <strong>
      3. 基于数据访问频率的淘汰策略
     </strong>
    </h3>
    <h4>
     <strong>
      3.1 allkeys-lru（全局最近最少使用）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       无视 TTL
      </strong>
      ，从所有键中（包括没有设置 TTL 的键），优先淘汰
      <strong>
       最近最少使用
      </strong>
      的键。
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于
      <strong>
       热点数据更新频繁
      </strong>
      的场景，如推荐系统、排行榜、搜索结果缓存等。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      可以确保常用数据长期保留，提高缓存命中率。
     </strong>
     <br/>
     ❌
     <strong>
      如果热点数据突然减少访问，可能会被错误淘汰。
     </strong>
    </p>
    <hr/>
    <h4>
     <strong>
      3.2 allkeys-random（全局随机淘汰）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       无视 TTL
      </strong>
      ，在所有 key 中
      <strong>
       随机删除
      </strong>
      某些数据。
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于
      <strong>
       缓存数据均匀访问
      </strong>
      ，不需要特定优先级的场景。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      简单高效，减少淘汰策略的计算开销。
     </strong>
     <br/>
     ❌
     <strong>
      不够智能，可能淘汰热点数据，降低缓存命中率。
     </strong>
    </p>
    <hr/>
    <h3>
     <strong>
      4. 基于数据访问频次的淘汰策略
     </strong>
    </h3>
    <h4>
     <strong>
      4.1 volatile-lfu（基于访问频率，TTL 限定）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       只淘汰设置了 TTL 的 key
      </strong>
      。
     </li>
     <li>
      <strong>
       访问次数最少的键
      </strong>
      优先被删除（LFU, Least Frequently Used）。
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于
      <strong>
       需要根据访问次数保留数据
      </strong>
      的业务，如热点文章缓存、用户历史记录等。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      能够长期保留高频访问数据，淘汰低频数据。
     </strong>
     <br/>
     ❌
     <strong>
      如果大部分数据没有 TTL，可能导致 Redis 拒绝写入（类似 noeviction）。
     </strong>
    </p>
    <hr/>
    <h4>
     <strong>
      4.2 allkeys-lfu（全局最不常使用淘汰）
     </strong>
    </h4>
    <h5>
     <strong>
      概念：
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       无视 TTL
      </strong>
      ，从所有键中
      <strong>
       优先淘汰访问次数最少的键
      </strong>
      。
     </li>
    </ul>
    <h5>
     <strong>
      适用场景：
     </strong>
    </h5>
    <ul>
     <li>
      适用于
      <strong>
       热点数据访问有明显差异
      </strong>
      的情况，如新闻热点推荐、热门产品缓存等。
     </li>
    </ul>
    <h5>
     <strong>
      优缺点：
     </strong>
    </h5>
    <p>
     ✅
     <strong>
      能保留长期热点数据，提高缓存命中率。
     </strong>
     <br/>
     ❌
     <strong>
      短期热点数据可能无法及时替换，导致数据更新滞后。
     </strong>
    </p>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        策略
       </th>
       <th>
        机制
       </th>
       <th>
        适用场景
       </th>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         noeviction
        </strong>
       </td>
       <td>
        拒绝写入
       </td>
       <td>
        不能丢数据（消息队列、金融）
       </td>
       <td>
        数据安全
       </td>
       <td>
        容易写满导致错误
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         volatile-lru
        </strong>
       </td>
       <td>
        仅淘汰 TTL 数据，LRU
       </td>
       <td>
        需自动过期，保留热点数据
       </td>
       <td>
        减少缓存击穿
       </td>
       <td>
        仅适用于部分数据有 TTL
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         volatile-ttl
        </strong>
       </td>
       <td>
        仅淘汰 TTL 数据，剩余寿命短的优先
       </td>
       <td>
        订单缓存、验证码
       </td>
       <td>
        优先清理即将失效的缓存
       </td>
       <td>
        可能误删热点数据
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         allkeys-lru
        </strong>
       </td>
       <td>
        全局 LRU 淘汰
       </td>
       <td>
        访问频率高的缓存（推荐系统）
       </td>
       <td>
        提高缓存命中率
       </td>
       <td>
        可能误删突然冷却的热点数据
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         allkeys-random
        </strong>
       </td>
       <td>
        随机淘汰
       </td>
       <td>
        数据访问均匀的缓存
       </td>
       <td>
        计算开销小
       </td>
       <td>
        可能淘汰重要数据
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         volatile-lfu
        </strong>
       </td>
       <td>
        仅淘汰 TTL 数据，访问最少的优先
       </td>
       <td>
        需要根据访问频率保留数据
       </td>
       <td>
        长期热点数据保留
       </td>
       <td>
        仅适用于有 TTL 的 key
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         allkeys-lfu
        </strong>
       </td>
       <td>
        全局 LFU 淘汰
       </td>
       <td>
        热点明显的数据（新闻、直播）
       </td>
       <td>
        缓存命中率高
       </td>
       <td>
        短期热点更新慢
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <strong>
      如何选择淘汰策略？
     </strong>
    </h3>
    <h4>
     <strong>
      1. 数据不能丢失（消息队列、金融）
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      noeviction
     </strong>
     （拒绝写入）
    </p>
    <h4>
     <strong>
      2. 仅淘汰过期数据（业务数据自动失效）
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      volatile-lru
     </strong>
     （保留热点）
     <br/>
     ✅
     <strong>
      volatile-ttl
     </strong>
     （优先清理快过期数据）
    </p>
    <h4>
     <strong>
      3. 需要智能保留高频访问数据
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      allkeys-lru
     </strong>
     （最近最少使用淘汰）
     <br/>
     ✅
     <strong>
      allkeys-lfu
     </strong>
     （最少使用淘汰）
    </p>
    <h4>
     <strong>
      4. 访问数据均匀，不关心淘汰顺序
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      allkeys-random
     </strong>
     （随机删除）
    </p>
    <h4>
     <strong>
      5. 业务需要权衡 LRU 和 LFU
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       短期热点多
      </strong>
      ，选
      <strong>
       LRU
      </strong>
     </li>
     <li>
      <strong>
       长期热点多
      </strong>
      ，选
      <strong>
       LFU
      </strong>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      结论
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       如果数据有 TTL，且希望优先淘汰冷数据
      </strong>
      ，选
      <strong>
       volatile-lru / volatile-lfu
      </strong>
      。
     </li>
     <li>
      <strong>
       如果所有数据都可以被淘汰
      </strong>
      ，选
      <strong>
       allkeys-lru / allkeys-lfu
      </strong>
      。
     </li>
     <li>
      <strong>
       如果只允许写满后拒绝写入
      </strong>
      ，选
      <strong>
       noeviction
      </strong>
      。
     </li>
     <li>
      <strong>
       如果对淘汰规则无特别要求
      </strong>
      ，选
      <strong>
       allkeys-random
      </strong>
      。
     </li>
    </ul>
    <p>
     正确选择淘汰策略，可以有效提高缓存命中率，降低数据库压力，保障系统稳定性。
    </p>
    <h2>
     常见缓存问题
    </h2>
    <p>
     在 Redis 中，缓存预热、缓存穿透、缓存雪崩和缓存击穿是常见的缓存问题。下面分别描述它们的概念及解决方案：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 缓存预热（Cache Warming）
     </strong>
    </h4>
    <h5>
     <strong>
      是什么？
     </strong>
    </h5>
    <p>
     缓存预热是指在系统启动或运行之前，提前将热点数据加载到缓存中，以减少数据库的查询压力，提高系统访问速度。
    </p>
    <h5>
     <strong>
      如何解决？
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       手动加载
      </strong>
      ：在服务启动时，手动将热点数据写入缓存。
     </li>
     <li>
      <strong>
       定时刷新
      </strong>
      ：通过定时任务（如 Spring Task、Quartz 等）定期加载热点数据到缓存。
     </li>
     <li>
      <strong>
       数据变更同步
      </strong>
      ：监听数据库更新（如 MySQL binlog、Redis 订阅发布机制），在数据变化时同步更新缓存。
     </li>
     <li>
      <strong>
       批量加载
      </strong>
      ：使用 Redis 的
      <code>
       pipeline
      </code>
      或
      <code>
       mset
      </code>
      命令批量写入缓存，提高加载效率。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      2. 缓存穿透（Cache Penetration）
     </strong>
    </h4>
    <h5>
     <strong>
      是什么？
     </strong>
    </h5>
    <p>
     缓存穿透指的是大量请求查询
     <strong>
      不存在的数据
     </strong>
     ，导致每次请求都要查询数据库，缓存完全失效，给数据库带来巨大压力。
    </p>
    <h5>
     <strong>
      如何解决？
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       缓存空值
      </strong>
      ：如果查询的数据不存在，可以将空值（如
      <code>
       null
      </code>
      或
      <code>
       {}
      </code>
      ）存入缓存，并设置较短的过期时间，避免重复查询数据库。
     </li>
     <li>
      <strong>
       布隆过滤器（Bloom Filter）
      </strong>
      ：使用布隆过滤器提前判断某个 key 是否可能存在，如果一定不存在，则直接返回，不查询数据库。
     </li>
     <li>
      <strong>
       参数校验
      </strong>
      ：在请求层对参数进行校验，避免无效请求进入系统。
     </li>
     <li>
      <strong>
       限流与黑名单
      </strong>
      ：对异常请求 IP 进行封禁或限流，避免恶意攻击。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 缓存雪崩（Cache Avalanche）
     </strong>
    </h4>
    <h5>
     <strong>
      是什么？
     </strong>
    </h5>
    <p>
     缓存雪崩指的是
     <strong>
      大量缓存同时失效
     </strong>
     ，导致短时间内大量请求直接打到数据库，造成数据库压力激增，甚至宕机。
    </p>
    <h5>
     <strong>
      如何解决？
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       缓存过期时间随机化
      </strong>
      ：为缓存设置
      <strong>
       不同的过期时间
      </strong>
      ，避免大量缓存同时失效，例如使用
      <code>
       TTL = 基础时间 ± 随机时间
      </code>
      。
     </li>
     <li>
      <strong>
       热点数据提前预加载
      </strong>
      ：在缓存即将过期前，主动刷新缓存，保证热点数据始终可用。
     </li>
     <li>
      <strong>
       双层缓存
      </strong>
      ：使用
      <strong>
       Redis + 本地缓存（如 Caffeine、Guava Cache）
      </strong>
      ，降低对 Redis 的依赖。
     </li>
     <li>
      <strong>
       流量削峰
      </strong>
      ：
      <ul>
       <li>
        <strong>
         限流
        </strong>
        ：使用限流算法（如令牌桶、漏桶）限制访问速率。
       </li>
       <li>
        <strong>
         降级
        </strong>
        ：当数据库压力过大时，返回默认值或降级处理。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      4. 缓存击穿（Cache Breakdown）
     </strong>
    </h4>
    <h5>
     <strong>
      是什么？
     </strong>
    </h5>
    <p>
     缓存击穿指的是
     <strong>
      某个热点 key 突然失效
     </strong>
     ，导致大量并发请求直接打到数据库，造成数据库短时间内压力剧增。
    </p>
    <h5>
     <strong>
      如何解决？
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       设置热点数据永不过期
      </strong>
      ：对于热点数据，直接不设置过期时间，而是由业务逻辑主动更新缓存。
     </li>
     <li>
      <strong>
       互斥锁（分布式锁）
      </strong>
      ：
      <ul>
       <li>
        当缓存失效时，多个请求只允许
        <strong>
         一个线程查询数据库并更新缓存
        </strong>
        ，其他线程等待缓存更新完成后再读取。
       </li>
       <li>
        具体实现：使用
        <code>
         SETNX
        </code>
        （Redis 分布式锁） 或 Redisson。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       提前刷新缓存
      </strong>
      ：
      <ul>
       <li>
        通过异步线程提前更新即将过期的热点缓存，防止突然失效。
       </li>
       <li>
        例如：使用
        <code>
         Redis + 过期监听
        </code>
        ，在 key 即将过期前主动更新缓存。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        问题
       </th>
       <th>
        现象
       </th>
       <th>
        解决方案
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         缓存预热
        </strong>
       </td>
       <td>
        缓存刚启动时，没有数据
       </td>
       <td>
        手动加载、定时刷新、监听数据变更
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         缓存穿透
        </strong>
       </td>
       <td>
        查询的 key 在数据库中不存在，每次都查数据库
       </td>
       <td>
        缓存空值、布隆过滤器、参数校验、黑名单
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         缓存雪崩
        </strong>
       </td>
       <td>
        大量 key 同时失效，数据库压力激增
       </td>
       <td>
        过期时间随机化、双层缓存、限流、降级
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         缓存击穿
        </strong>
       </td>
       <td>
        某个热点 key 失效，大量请求打到数据库
       </td>
       <td>
        热点数据永不过期、分布式锁、提前刷新
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     这四个缓存问题都是分布式系统中必须重点关注的，合理的缓存策略可以有效提升系统的性能和稳定性。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f796963616e323538302f:61727469636c652f64657461696c732f313436313335313837" class_="artid" style="display:none">
 </p>
</div>


