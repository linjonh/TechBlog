---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353739333734352f:61727469636c652f64657461696c732f313436323835343831"
layout: post
title: "软考中级设计模式实战宝典核心意图解析适用场景完整源码下载高频题库"
date: 2025-03-15 21:11:53 +08:00
description: "逐条解析23种设计模式的核心意图与适用场景，搭配UML类图快速理解模式本质，告别抽象理论。  "
keywords: "软考中级设计模式实战宝典：核心意图解析+适用场景+完整源码下载+高频题库"
categories: ['软件设计师']
tags: ['设计模式']
artid: "146285481"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146285481
    alt: "软考中级设计模式实战宝典核心意图解析适用场景完整源码下载高频题库"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146285481
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146285481
cover: https://bing.ee123.net/img/rand?artid=146285481
image: https://bing.ee123.net/img/rand?artid=146285481
img: https://bing.ee123.net/img/rand?artid=146285481
---

# 软考中级设计模式实战宝典：核心意图解析+适用场景+完整源码下载+高频题库

[#新星杯·14天创作挑战营·第9期#](https://activity.csdn.net/writing?id=10858)

**简介**
：

---

备战软考中级软件设计师，设计模式模块占分高、考点深？本文专为高效备考打造！

* **直击考点**
  ：逐条解析23种设计模式的
  **核心意图**
  与
  **适用场景**
  ，搭配UML类图快速理解模式本质，告别抽象理论。
* **代码实战**
  ：提供
  **Java语言示例源码**
  （附完整下载链接），通过真实场景还原设计模式应用，助你打通理论与编码的断层。
* **提分利器**
  ：精选历年高频考题+原创模拟题库，覆盖
  **创建型、结构型、行为型**
  三大类模式，附详细答案解析，考前冲刺必备。
* **应试技巧**
  ：总结判卷标准与答题模板，教你避开“只懂模式不会答题”的坑，精准锁定得分点。

**适合人群**
：时间紧迫的软考冲刺者、设计模式基础薄弱的开发者、需快速掌握模式实战应用的编程学习者。

👉
**立即学习**
：下载源码文件，搭配练习题查漏补缺，一次过关！

---

## 一、设计模式基本概念

### 分类

创建模式：5种

结构模式：7种

行为模式：11种

![](https://i-blog.csdnimg.cn/img_convert/6a4e99d4983a9facc30dfcdff7d53bc7.png)

### 需求

设计模式的核心在于提供相关的解决方案，使可以\*\*复用成功的设计和体系结构\*\*

### 4个要素

模式名称

问题

解决方案

效果

### 二十三种设计模式

注意：终结为中介

结构型记忆方案：桥代理组装适配器，享元回家装饰外观

![](https://i-blog.csdnimg.cn/img_convert/62117dd17b2594f093fdbef4eb408b55.png)

### 例题

![](https://i-blog.csdnimg.cn/img_convert/9b5018193ab56cb3fd8c290920f0662d.png)

## 二、创建型设计模式

> 类：
>
> 工厂方法（factory method）
>
> 对象：
>
> 抽象工厂（abstract factory ）
>
> 单例（Singleton）
>
> 原型（prototype）
>
> 生成器（Builder ）

### 扩展：简单工厂模式（Simple Factory）

1. 别名：静态工厂方法（static factory method）
2. 定义一个工厂类，它可以
   **根据参数的不同，返回不同类的实例**
   。把创建的实例通常具有
   **共同的父类**
3. 缺点：违反了开闭原则
4. UML图

![](https://i-blog.csdnimg.cn/img_convert/8fe1ba9436a7c00c5d3ea136b43fa098.png)

```java
public class SimpleFactory {


    public static void main(String[] args) {
        
        Product  productA= Factroy.createProduct("A");
        productA.info(); // 输出结果A
        Product  productB= Factroy.createProduct("B");
        productB.info(); // 输出结果B

    }
}
// 简单工厂
class Factroy{
    public static Product createProduct(String type){
        Product product = null;
        switch (type){
            case "A":
                product= new ProductA();
                break;
            case "B":
                product = new ProductB();
                break;
            default:
                System.out.println("error");
                break;
        }
        return  product;
    }
}

// 产品
abstract class Product{
    abstract void info();
}
// 基本产品A
class ProductA extends  Product{
    @Override
    void info() {
        System.out.println("A");
    }
}
// 基本产品B
class ProductB extends  Product{
    @Override
    void info() {
        System.out.println("B");
    }
}





```

### 工厂方法模式（Factory Method）

1. 意图：
   **定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例延迟到其子类**
2. 适用性

![](https://i-blog.csdnimg.cn/img_convert/eab2ba2bb4ec62b924c64229bfbd0e83.png)

3. UML图

![](https://i-blog.csdnimg.cn/img_convert/ecf266248717270618675c8d82704ba6.png)

```java
package factoryMethod;


public class FactoryMethod{
    public static void main(String[] args) {
        Product productA= new FactoryA().createProdcut();
        productA.info();
        Product productB=  new FactoryB().createProdcut();
        productB.info();


    }
}


// 产品类
interface Product {
    void info();
}
// 工厂类
interface Factory{
    Product createProdcut();
}
//具体产品1
class  ProductA implements Product{
    public void info(){
        System.out.println("A");
    }

}
// 具体工厂A
class FactoryA implements Factory{
    @Override
    public Product createProdcut(){
        return  new ProductA();
    }
}

//具体产品1
class  ProductB implements Product{
    public void info(){
        System.out.println("B");
    }

}
// 具体工厂A
class FactoryB implements Factory{
    @Override
    public Product createProdcut(){
        return  new ProductB();
    }
}



```

### 抽象工厂模式（Abstract Factory）

1. 意图：提供一个创建一条相关或下相互依赖对象的接口，而无须指定它们具体的类
2. 适用性

![](https://i-blog.csdnimg.cn/img_convert/a69ce693ca2ae6342d2847c7b07c7701.png)

3. UML图

![](https://i-blog.csdnimg.cn/img_convert/fbe5e8ecbc106206ae965a83320810cc.png)

```java
package AbstractFactory;

public class Client {
    public static void main(String[] args) {
        AbstractFactory factory1 = new Factory1();
        factory1.createProductA().info();
        factory1.createProductB().info();
        
        AbstractFactory factory2 = new Factory2();
        factory2.createProductA().info();
        factory2.createProductB().info();
    }
}

// 抽象工厂
interface AbstractFactory{
    AbstractProductA createProductA();
    AbstractProductB createProductB();


}

// 具体工厂1生产A1和B1产品
class Factory1 implements AbstractFactory{

    @Override
    public AbstractProductA createProductA() {
        return new ProductA1();
    }

    @Override
    public AbstractProductB createProductB() {
        return new ProductB1();
    }
}
// 具体工厂2生产A2和B2产品
class Factory2 implements  AbstractFactory{

    @Override
    public AbstractProductA createProductA() {
        return new ProductA2();
    }

    @Override
    public AbstractProductB createProductB() {
        return new ProductB2();
    }
}


// 抽象产品A
interface AbstractProductA{
    void info();
}
// A1
class  ProductA1 implements AbstractProductA{
    @Override
    public void info(){
        System.out.println("A1");
    }
}
// A2

class  ProductA2 implements AbstractProductA{
    @Override
    public void info(){
        System.out.println("A2");
    }
}
// 抽象产品B
interface  AbstractProductB{
    void info();
}
// B1
class  ProductB1 implements AbstractProductB{
    @Override
    public void info(){
        System.out.println("B1");
    }
}
// B2
class  ProductB2 implements AbstractProductB{
    @Override
    public void info(){
        System.out.println("B2");
    }
}

```

4. 例题1

![](https://i-blog.csdnimg.cn/img_convert/435b884a0a9bf72d4c5b3a404db508f4.png)

5. 例题2

![](https://i-blog.csdnimg.cn/img_convert/88a27c804f385c079c29b6938bb70ae4.png)

### 生成器模式（Builder）

1. 意图：将一个\*\*
   **，使得**
   同样的构建可以创建不同的表示\*\*
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/6b99584a883d5ee914b699e8cf8337ea.png)

3. UML图

![](https://i-blog.csdnimg.cn/img_convert/2fe3fcbde0fb8ffb58150ad3ad05024e.png)

```
1. 解释：

```

![](https://i-blog.csdnimg.cn/img_convert/cf21ff55c9ff8db16eb374616b870f4f.png)

```java
package Builder;

import com.sun.org.apache.xpath.internal.XPathAPI;

import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        Director director  = new Director();
        // 装配产品1
        Builder builder1= new ConcreteBuilder1();
        director.Construct(builder1);
        builder1.getResult().show();

        // 装配产品2
        Builder builder2 = new ConcreteBuilder2();
        director.Construct(builder2);
        builder2.getResult().show();

    }
}

// 产品
class Product{
    List<String> parts = new ArrayList<>();
    // 添加零件
    public  void add(String part){
        parts.add(part);
    }
    // 打印零件
    public void show(){
        System.out.println("================");
        for (String part : parts) {
            System.out.println(part);
        }
        System.out.println("================");

    }
}
// 抽象生成器
interface  Builder{
    void builbderPart();
    Product getResult();
}
// 具体生成器

 class ConcreteBuilder1 implements  Builder{
  private  Product product = new Product();

     @Override
     public void builbderPart() {
         product.add("零件A1");
         product.add("零件B1");
     }

     @Override
     public Product getResult() {
         return this.product;
     }
 }
// 具体生成器
class ConcreteBuilder2 implements  Builder{
    private  Product product = new Product();

    @Override
    public void builbderPart() {
        product.add("零件A2");
        product.add("零件B2");
    }

    @Override
    public Product getResult() {
        return this.product;
    }
}
// 导演：使用生成器
class Director{
    
    // 构建装配方式
    public void Construct(Builder builder){
        builder.builbderPart();
    }

}

```

4. 例题1

![](https://i-blog.csdnimg.cn/img_convert/99aeb1f27e9672d7cfe501340cbbf7b4.png)

5. 例题2

![](https://i-blog.csdnimg.cn/img_convert/c826562c779ba04e48f8f9c7a8f5e088.png)

6. 例题3
   1. 答案：ACAD

![](https://i-blog.csdnimg.cn/img_convert/dd5a9c634794c70cef594fa882451a79.png)

A选项：为原型模式

![](https://i-blog.csdnimg.cn/img_convert/8e52f4ab5b3bf74eba4e18b17c97ad8c.png)

### 原型模式（Prototype）

1. 意图：用原型实例指定创建对象的种类，并且通过\*\*复制\*\*这些原型创建新的对象。
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/3bb171f8b4bb1eccf61ad5949bfa4062.png)

3. UML图：
   1. 解释：

![](https://i-blog.csdnimg.cn/img_convert/b9d768ce9acb8e1622a876eacc450ef2.png)

![](https://i-blog.csdnimg.cn/img_convert/6d7284fea006e003e3a917f1b4831101.png)

```java
package protoType;

public class Client {
    public static void main(String[] args) {
        Prodcut prodcut = new Prodcut("产品1",1.11);
        System.out.println(prodcut.toString());
        Prodcut clone = (Prodcut) prodcut.clone();
        System.out.println(clone.toString());
    }
}
interface ProtoType{
    Object clone();
}
// 克隆产品类
class  Prodcut  implements  ProtoType{
    private  String name ;
    private  double weight;
    public Prodcut(){

    }



    public Prodcut(String name, double weight){
        this.name =name;
        this.weight=weight;
    }


    @Override
    public Object clone() {
        Prodcut prodcut = new Prodcut(this.name,this.weight);

        return prodcut;
    }

    @Override
    public String toString() {
        return "Prodcut{" +
                "name='" + name + '\'' +
                ", weight=" + weight +
                '}';
    }


}

```

### 单例模式（Singleton）

1. 意图：\*\* 一个类只产生一个实例\*\*
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/8c766b349f6e56510216b6659adb831e.png)

3. UML图：

![](https://i-blog.csdnimg.cn/img_convert/2f708d883e49bfbd590fe8b0cfc991bb.png)

![](https://i-blog.csdnimg.cn/img_convert/ce70c121e9cc035daa1e75ee0107a23a.png)

```java
package Singleton;

public class Test {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.uniqueInstance();
        Singleton singleton2 = Singleton.uniqueInstance();
        singleton2.setNum(1);
        System.out.println(singleton1.toString());
        singleton2.setNum(3);
        System.out.println(singleton2.toString());
        System.out.println(singleton2.toString());
    }
}

class  Singleton{
    private  int num;
    private static Singleton singleton;
    private  Singleton(){

    }

    public void setNum(int num) {
        this.num = num;
    }
    // 入口
    public static  Singleton uniqueInstance(){
        if (singleton==null) {
            singleton = new Singleton();
        }
        return singleton;
    }
    @Override
    public String toString() {
        return "Singleton{" +
                "num=" + num +
                '}';
    }
}


```

4. 例题1

![](https://i-blog.csdnimg.cn/img_convert/60b77a66e905ac45e712ff841a02b040.png)

5. 例题2

![](https://i-blog.csdnimg.cn/img_convert/9c5b5ba7b075ca7b8abf9d8eaabb6150.png)

6. 例题3

![](https://i-blog.csdnimg.cn/img_convert/0681142fb15e66729aa6e319b00e2d66.png)

## 三、结构型设计模式

> 类：
>
> 适配器模式
>
> 对象：
>
> 适配器模式
>
> 代理模式
>
> 桥接模式
>
> 组合模式
>
> 装饰模式
>
> 外观模式
>
> 享元模式

1. 考过次数（2022年以前）

![](https://i-blog.csdnimg.cn/img_convert/a0c430f947ad624864071617307810fd.png)

### 适配器模式（Adapter）

1. 意图：将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。
   1. 例如：USB接口转成type-C接口
2. **适用**
   性：

![](https://i-blog.csdnimg.cn/img_convert/f20c6235bd06253028d7748f56904dc8.png)

4. 扩展：
   **多态的缺点：使用不了子类特有的方法**

#### 类模式（了解）

3. 类模式适用多重继承对一个接口与另一个接口进行匹配。
4. UML图

![](https://i-blog.csdnimg.cn/img_convert/11ec3dc109741513ba7399759ba2dd87.png)

#### 对象模式

1. **对象适配器依赖于对象组合**
2. UML图

![](https://i-blog.csdnimg.cn/img_convert/735180d38cdb35c838a43de6a29fcbe1.png)

![](https://i-blog.csdnimg.cn/img_convert/1084fb60f66493708856d9689e3e939b.png)

```java
 package adapter;

public class client {
    public static void main(String[] args) {
        Target adapter = new Adapter();
        adapter.request();
    }
}

// 目标
class Target{
    public void request(){
        System.out.println("USB接口");
    }
}
// 通过适配器适配让USB类型接口可以转换成Type—C接口
class Adapter extends Target{
    private  Adaptee adaptee = new Adaptee();
    @Override
    public void request(){
            adaptee.SpecificRequest();
    }
}
// 被适配
class Adaptee{
    public void SpecificRequest(){
        System.out.println("Type—C接口");
    }
}

```

#### 例题

![](https://i-blog.csdnimg.cn/img_convert/a88405ab2abd83c1c7c23a29eb0082f0.png)

### 桥接模式（Bridge）

1. 意图：
   **将抽象部分与其实现部分分离，使它们都可以独立地变化**
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/4fe157fd02bcc354f4bb936daeef2f53.png)

3. 理解：比如说抽象产品有产品A和产品B和产品C，但是产品ABC又分出了红色、黄色、绿色三中，直接适用继承的话，耦合度太高了。
   1. 所以我们将颜色抽象分离出来，分别设置各种颜色，并在抽象产品中留出设置颜色的类。就可以将产品和颜色桥接在在一起了。

![](https://i-blog.csdnimg.cn/img_convert/5b3ae6b2f21902b0e60d878924ab463f.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/d585f721ee5771d4b7d8f6e69031f790.png)

![](https://i-blog.csdnimg.cn/img_convert/19beafe6f06942c0471b5048190486b3.png)

```java
package Bridge;

public class Test {
    public static void main(String[] args) {
        AbstractProduct productA = new ProductA();
        productA.setName("apple");
        productA.setColor(new Red());
        productA.Operation();
    }
}
//抽象产品
abstract class  AbstractProduct{
    private  String name;
    // 受保护的
    protected Color color= null;

    public void setName(String name) {
        this.name = name;
    }

    public void setColor(Color color) {
        this.color = color;
    }

    public String getName() {
        return name;
    }

    abstract void Operation();

}

// 具体产品

class  ProductA extends  AbstractProduct{

    @Override
    void Operation() {
        color.OperationImp(getName());
    }
}
// 依赖抽象产品的一部分：例如：手机中的颜色
interface  Color{
    // 行为实现
    void OperationImp(String name);
}
class  Red implements  Color{

    @Override
    public void OperationImp(String name) {
        System.out.println(name +":Red");
    }
}

class  Green implements  Color{

    @Override
    public void OperationImp(String name) {
        System.out.println(name +":Green");
    }
}


```

5. 例题1
   1. 答案：AD

![](https://i-blog.csdnimg.cn/img_convert/d08efbbb6b7b094b3452d2ff73b90be3.png)

6. 例题2
   1. 答案：DABA

![](https://i-blog.csdnimg.cn/img_convert/d75c141c054f7a54629d1817d522d534.png)

![](https://i-blog.csdnimg.cn/img_convert/40d07ae973b39dc300937905b0c5b59d.png)

7. 例题3
   1. 答案：CDAB

![](https://i-blog.csdnimg.cn/img_convert/34d7247591e6ee48bd32e5c9f857aeb8.png)

![](https://i-blog.csdnimg.cn/img_convert/977411945773809fdd2aa1f12effb34e.png)

### 组合模式（Composite）

1. 意图：将对象组合成树结构以表示“
   **部分-整体**
   ”的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性。
2. 理解：文件和文件夹。文件夹包含文件。文件夹是整体，文件时部分。

![](https://i-blog.csdnimg.cn/img_convert/05ceae4e4d2781c85f25cb9cfc2f376c.png)

3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/c3d8ac5726e7f8e3a794377a68445223.png)

4. UML图

![](https://i-blog.csdnimg.cn/img_convert/8043e7052bdbde8d2cd94deca1d29ff5.png)

![](https://i-blog.csdnimg.cn/img_convert/8497b79587b577090f95b4ec3be49e0a.png)

```java
package composite;

import java.util.ArrayList;
import java.util.List;

public class Client {
    public static void main(String[] args) {
        AbstractFile abstractFile = new Folder("/");
        AbstractFile folder1 = new Folder("folder1");
        AbstractFile folder2 = new Folder("folder2");
        AbstractFile file1 = new File("file2");
        AbstractFile file2 = new File("file2");
        abstractFile.add(folder1);
        abstractFile.add(file1);

        folder1.add(folder2);
        folder1.add(file2);

        AbstractFile folder3 = new Folder("folder3");
        AbstractFile file3 = new File("file");
        folder2.add(folder3);
        folder2.add(file3);
        printFileName(abstractFile);

    }
    // 遍历文件名
    public static void  printFileName(AbstractFile abstractFile){
        abstractFile.print();
        List<AbstractFile> child = abstractFile.getChild();
        if(child==null){
            return;
        }
        for (AbstractFile file : child) {
         printFileName(file);
        }
    }
}

abstract  class  AbstractFile{
    protected  String name;
    public AbstractFile(){

    }
    public AbstractFile(String name){
        this.name=name;
    }
    public void print(){
        System.out.println(name);
    }
    // 添加文件或文件夹
    public abstract  boolean add(AbstractFile abstractFile);
    // 删除文件或文件夹
    public  abstract  boolean remove(AbstractFile abstractFile);
    // 获取文件夹中的文件和文件夹
    public abstract List<AbstractFile> getChild();

}

// 文件架
class  Folder extends  AbstractFile{
    public Folder(String name){
        super(name);
    }
    private List<AbstractFile> abstractFileList = new ArrayList<>();

    @Override
    public boolean add(AbstractFile abstractFile) {
        return abstractFileList.add(abstractFile);
    }

    @Override
    public boolean remove(AbstractFile abstractFile) {
        return abstractFile.remove(abstractFile);
    }

    @Override
    public List<AbstractFile> getChild() {
        return  abstractFileList;
    }
}

class  File extends AbstractFile{
    public  File(String name){
        super(name);
    }
    @Override
    public boolean add(AbstractFile abstractFile) {
        return false;
    }

    @Override
    public boolean remove(AbstractFile abstractFile) {
        return false;
    }

    @Override
    public List<AbstractFile> getChild() {
        return null;
    }
}

```

5. 例题1

![](https://i-blog.csdnimg.cn/img_convert/a15c008a2f86b567d77c47f4ed098468.png)

6. 例题2

![](https://i-blog.csdnimg.cn/img_convert/950842be0b08ecb4ec2e58c7e2cbc648.png)

7. 例题3

![](https://i-blog.csdnimg.cn/img_convert/590343c691c1a65a899733bfe77ae92d.png)

### 装饰器模式（Decorator）

1. 意图：动态地给一个对象\*\*添加一些额外的职责\*\*，就增加功能而言，该模式比生成模块更加灵活。
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/02183e2216e6667ad26bc2c145537b9a.png)

3. UML图：

![](https://i-blog.csdnimg.cn/img_convert/4ce59d0d5ec848b5c92aeeda492ca0c8.png)

![](https://i-blog.csdnimg.cn/img_convert/3e60f21cb41214fc90d3d144ac846f36.png)

```java
package decorator;

public class Client {
    public static void main(String[] args) {

        new ConcreteDecoraterB(new ConcreteDecoraterA(new Student("张三"))).Operation();
    }
}

// 第一步创建人的抽象类
abstract class Person{
    String name;
    public Person(){

    }
    public Person(String name){
        this.name = name;
    }

    // 职责
    abstract  void Operation();
}

// 学生类
class  Student extends Person{
    public Student(){

    }
    public Student(String name){
        super(name);
    }

    @Override
    void Operation() {
        System.out.print("张三"+"学生的职责为：学习");
    }
}

// 第三步：创建抽象适配器类并继承Person
abstract  class Decorater extends Person{
    protected  Person person ;
  public Decorater (){

  }
  public Decorater(Person  person ){
        this.person =person;
  }

}
// 具体的职责类
class ConcreteDecoraterA extends  Decorater{
    public ConcreteDecoraterA(Person person){
        super(person);
    }

    @Override
    void Operation() {
        person.Operation();
        System.out.print("   快乐");
    }
}
class ConcreteDecoraterB extends  Decorater{
    public ConcreteDecoraterB(Person person){
        super(person);
    }

    @Override
    void Operation() {
        person.Operation();
        System.out.print("   睡觉");
    }
}

```

4. 例题1

![](https://i-blog.csdnimg.cn/img_convert/5ac952c1fd0d9c26d681c9a520576f13.png)

### 外观模式（Facade）

1. 意图：
   **为子系统中的一组接口提供一个一致的界面**
   。Facade模式定义了一个高层接口，这个接口使得这个子系统更加容易适用。
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/ca810d377ffeb444434b7a68c893fe56.png)

3. UML

![](https://i-blog.csdnimg.cn/img_convert/0f5619b96b984ca1ca2954d061f9b321.png)

![](https://i-blog.csdnimg.cn/img_convert/0eaf351a9fc6019fe33cb7863848d540.png)

```java
 package facade;

public class Test {
    public static void main(String[] args) {
        // 可以通过一个外观类直接适用子系统的方法
        Facade facade = new Facade();
        facade.print1();
        facade.print2();
        facade.print3();

    }
}

// 外观类
class Facade{
    SubSystem1 subSystem1;
    SubSystem2 subSystem2;
    SubSystem3 subSystem3;
    public Facade(){
        // 初始哈子系统
        subSystem1 = new SubSystem1();
        subSystem2=new SubSystem2();
        subSystem3 = new SubSystem3();
    }
    public void print1(){
        subSystem1.printA();
    }
    public void print2(){
        subSystem2.printA();
    }
    public void print3(){
        subSystem3.printA();
    }

}
// 子系统类1
class SubSystem1{
    // 有一个打印方法
    public void printA(){
        System.out.println("subSystem1");
    }
}
// 子系统类2
class SubSystem2{
    // 有一个打印方法
    public void printA(){
        System.out.println("subSystem2");
    }
}
// 子系统类3
class SubSystem3{
    // 有一个打印方法
    public void printA(){
        System.out.println("subSystem3");
    }
}




```

4. 例题1

![](https://i-blog.csdnimg.cn/img_convert/73cfbef23450268a59fb848b76ce8bb8.png)

5. 例题2

![](https://i-blog.csdnimg.cn/img_convert/2c244a33c064fa7aae0f4d7372b894b7.png)

### 享元模式（Flyweight）

1. 意图：运用
   **共享技术**
   有效地支持
   **大量**
   细颗粒度
   **的对象**
   。
2. 理解：在享元工厂中写一个方法，如果没有该对象没有创建过就new一个，如果创建过了就将对象复制给它。
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/c8966b3677ef65228fc7cf854d4049c7.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/8fcf40d1391f52990b32b7b09bf0710e.png)

```java
package flyweight;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class Client {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();

        Product red = factory.getFlyweight("red");
        Product red1 = factory.getFlyweight("red");
        Product red2 = factory.getFlyweight("red");
        Product red3 = factory.getFlyweight("red");
        System.out.println(red);
        System.out.println(red1);
        System.out.println(red2);
        System.out.println(red3);
        /**
         * 
         * 
         * 结果：都是一个对象
         flyweight.Canvas@4554617c
         flyweight.Canvas@4554617c
         flyweight.Canvas@4554617c
         flyweight.Canvas@4554617c
         */
        /
    }
}


// 抽象产品的享元类
abstract class  Product{
    protected String name;
    protected String color;
    public Product(){

    }
    public Product(String color){
        this.color = color;
    }
    abstract void operation();
}
// 画布
class Canvas extends  Product{
    public Canvas(String color){
        super(color);
    }

    @Override
    void operation() {
        System.out.println("画布的颜色为："+color);
    }
}


// 享元工厂
class  FlyweightFactory{
    Map<String, Product> map = new HashMap<>();
    public Product getFlyweight(String color){
        if (!map.containsKey(color)){
            map.put(color,new Canvas(color));
        }
        return map.get(color);
    }
}

```

5. 例题1

![](https://i-blog.csdnimg.cn/img_convert/a838adedbbcf16a8398a3ad7936baf52.png)

### 代理模式（Proxy）

1. 意图：为其他对象提供一种代理以
   **控制对这个对象的访问**
   。
2. 例如：商品代购（你代理我去做这件事）
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/949fc257b57f0701b6c58a4515a54956.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/d270df77c38edfc33b3cc70955daaf88.png)

```java
 package proxy;

public class Client {
    public static void main(String[] args) {
        Subject proxy = new Proxy(new RealSubJect());
        proxy.Request();
    }
}
interface Subject{
    void Request();
}

// 买家
class  RealSubJect implements  Subject{

    @Override
    public void Request() {
        System.out.println("买车");
    }
}
// 代理商收到请求，代替行为
class Proxy implements  Subject{
    Subject realSubJect ;
    public Proxy(Subject subject){
        this.realSubJect= subject;

    }

    @Override
    public void Request() {
        realSubJect.Request();
    }
}


```

5. 例题1

![](https://i-blog.csdnimg.cn/img_convert/963852f2846569d5fbf9d2c00ac1020a.png)

## 三、行为性设计模式

1. 考点分布（2021年前）

![](https://i-blog.csdnimg.cn/img_convert/b013f7c6bfd441aa12c56d2304bc9d3d.png)

### 责任链模式（chain Responsibility）

1. 意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者间的耦合关系，
   **将这些对象联系成一条链，并沿着这条链传递请求，直到有一个对象处理它位置。**
2. 例如：学生找辅导员批请假条，时间在1天内，可以通过，1到7天，需要院长，7天到30天需要校长。

![](https://i-blog.csdnimg.cn/img_convert/c3a4b724c191cd40230c452b5b1147ae.png)

3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/c6949d224fb67e897605ce198749365f.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/8aaacb376c77acb51b56d6ef999181fd.png)

![](https://i-blog.csdnimg.cn/img_convert/03497e59482ae1acca89c4fd1ac0b3e8.png)

```java
package chainResponsibility;

public class Client {
    public static void main(String[] args) {
        // 教师<院长<校长
        Handle handle  = new Teacher(1, new Teacher(7,new Teacher(30,null)));
        handle.handleRequest(31);
    }
}



abstract class Handle{
    protected  Handle handle;
    protected int day;
    public Handle(){

    }
    public Handle (int day ,Handle handle){
        this.handle = handle;
        this.day = day;
    }
    abstract void handleRequest(int day);
}
// 学校领导
class Teacher extends Handle{
        public Teacher(int day ,Handle handle){
            this.day = day;
            this.handle = handle;
        }

    @Override
    void handleRequest(int day) {
        if(day  <=this.day){

            System.out.println("审核过");

        }else{
            if (handle!=null){
                System.out.println("===============");
                System.out.println(this.handle);
                System.out.println(this.day);
                System.out.println("===============");
                handle.handleRequest(day);
            }else{
                System.out.println("无法审批");
            }
        }

    }
}

```

5. 代码结果示例

![](https://i-blog.csdnimg.cn/img_convert/0471eeda65c4eea0faf6671bc8f2444e.png)

### 命令模式（Command）

1. 意图：
   **将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化**
   ，对请求排队或记录请求日志以及支持可撤销的操作。
2. 理解：请求者—>给一个具体的命令---->接收者对请求操作。
   1. 例如：遥控器发出开关机请求，电视机作为接收者执行开关机
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/971d914423791c6140d7461b487cec05.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/58264691d7939c71cf91319ae3143327.png)

```java
package command;

import com.sun.org.apache.regexp.internal.RE;

public class Client {

    public static void main(String[] args) {
        Invoker invoker = new Invoker();
        Receiver receiver = new Receiver();

        OffConcreteCommand offConcreteCommand  = new OffConcreteCommand(receiver);
        OnConcreteCommand onConcreteCommand = new OnConcreteCommand(receiver);

        invoker.setCommand(offConcreteCommand);
        invoker.call();// 关机


    }
}
//遥控器
class  Invoker{
    protected  Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public Command getCommand() {
        return command;
    }
    public void call(){
        command.Execute();
    }
}
// 命令接口
abstract class Command{
    protected   Receiver receiver;
    public Command(Receiver receiver){
        this.receiver = receiver;
    }

    public void setReceiver(Receiver receiver) {
        this.receiver = receiver;
    }

    // 执行方法
    abstract void  Execute();
}
// 开机具体命令类
class OnConcreteCommand extends Command{


    public OnConcreteCommand(Receiver receiver) {
        super(receiver);
    }

    @Override
    public void Execute() {
        receiver.action("on");

    }
}
// 关机
class OffConcreteCommand extends Command{


    public OffConcreteCommand(Receiver receiver) {
        super(receiver);
    }

    @Override
    public void Execute() {
        receiver.action("off");
    }
}

// 电视机
class  Receiver{
    public void action(String command){
        if (command=="on") {
            System.out.println("开机");
        } else if (command=="off") {
            System.out.println("关机");
        }else{
            System.out.println("错误命令");
        }

    }
}

```

5. 例题1

![](https://i-blog.csdnimg.cn/img_convert/173f143f5ce404a13a8eaac33666e595.png)

6. 例题2

![](https://i-blog.csdnimg.cn/img_convert/782509a7ca5af90d1672afd2fb253920.png)

![](https://i-blog.csdnimg.cn/img_convert/4d1ae928cecc4e990b94916f38df79ab.png)

### 解释器模式（Interpreter）

1. 意图：
   **给定一个语言，定义它的文法的一种表示，并定义一个解释器**
   ，这个解释器适用该表示来解析语言中句子。
2. 例如：程序设计语言中的，
   **上下文无关文法**
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/749a8dbf5f31c3a5e1282786699a89f5.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/6f1c4f4aad319edd4ed041062938f2b2.png)

![](https://i-blog.csdnimg.cn/img_convert/ea6a09e2e22437d9e716168ec0c31dc0.png)

5. 示例代码：

```java
package interpreter;

import java.util.HashSet;
import java.util.Set;

public class Client {
    public static void main(String[] args) {
        Context context = new Context();
        context.check("A区的老师");
        context.check("C区的小孩");
        context.check("f区的小孩");

    }
}
// 上下文环境
class Context{
    String[] region =  {"A区","B区","C区"};
    String[] person ={"小孩","青年","老师"};
    private  NoterminalExpression noterminalExpression;
    private TerminalExpression regionCheck;
    private TerminalExpression persionCheck;
    public Context(){
        regionCheck = new TerminalExpression(region);
        persionCheck =new TerminalExpression(person);
        noterminalExpression = new NoterminalExpression(regionCheck,persionCheck);
    }
    public void check(String info){
        if (noterminalExpression.interpreter(info)) {
            System.out.println("success");
        }else{
            System.out.println("error");
        }



    }
}




abstract class AbstractExpression{
    abstract  boolean interpreter(String info);

}


class NoterminalExpression extends  AbstractExpression{
    private  TerminalExpression region ;
    private TerminalExpression person;
    public NoterminalExpression(TerminalExpression region,TerminalExpression person){
        this.person = person;
        this.region  = region;
    }


    @Override
    boolean interpreter(String info) {
        String[]  checks = info.split("的");


        return region.interpreter(checks[0]) && person.interpreter(checks[1]);
    }
}


// 终结符
class TerminalExpression extends  AbstractExpression{

    private Set<String> strings = new HashSet<>();
    public TerminalExpression (String[] strs){
        for (String str : strs) {
            strings.add(str);
        }

    }

    @Override
    boolean interpreter(String info) {
        return strings.contains(info);
    }
}


```

![](https://i-blog.csdnimg.cn/img_convert/b4d9bc84e1a4fa0f67143dccac7bdb1a.png)

### 迭代器（Iterator）

1. 意图：用一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象大的内部表示。
2. 例如：Java中集合的迭代器

```java
package Interator;

import java.time.Period;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        Set<Person> people = new HashSet<>();

        people.add(new Person("张三",13));
        people.add(new Person("李四",33));
        people.add(new Person("王五",32));
        Iterator<Person> iterator = people.iterator();
        while(iterator.hasNext()){
            Person next = iterator.next();
            System.out.println(next.toString());
        }
    }
}

// 对象类
class  Person{
    private  String name;
    private int age;
    public Person(){

    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;

    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

```

![](https://i-blog.csdnimg.cn/img_convert/1587e1c8a52a8d148b02e1ee20546020.png)

3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/94c82a8c73ebc884580cbf2e290687bb.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/67cf0f910610a607e33c5ff433747448.png)

5. 实例代码：

```java
package Interator;

public class Test {
    public static void main(String[] args) {
        Person[] people =  {
                new Person("张三",1),
                new Person("李四",12),
                new Person("王五",13),
               
        };
        ConcreteAggregate concreteAggregate = new ConcreteAggregate(people);
        Interator iterator = concreteAggregate.createIterator();
        while (iterator.haxNext()){
            System.out.println(iterator.next());
        }
    }
}

// 对象类
class  Person{
    private  String name;
    private int age;
    public Person(){

    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;

    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

// 迭代器接口
abstract class   Interator{
    protected int index=0;
    protected Aggregate aggregate;
    public Interator(Aggregate aggregate){
        this.aggregate= aggregate;
    }


    abstract boolean haxNext();
    abstract  Object next();

}

// 具体迭代器
class  ConcreteInterator extends Interator{


    public ConcreteInterator(Aggregate aggregate) {
        super(aggregate);
    }

    @Override
    boolean haxNext() {
        
        return aggregate.objects.length!=0 && index<aggregate.objects.length;
    }

    @Override
    Object next() {

        return aggregate.objects[index++];
    }
}


abstract  class Aggregate{
    protected Object[] objects;
    abstract Interator createIterator();
    public  Aggregate(Object[] objects){
        this.objects = objects;
    }

}
class ConcreteAggregate  extends Aggregate{

    public ConcreteAggregate(Object[] objects){
        super(objects);
    }

    @Override
    Interator createIterator() {
        return new ConcreteInterator(this);
    }
}

```

![](https://i-blog.csdnimg.cn/img_convert/7312a5ed753200361506f8548c5ae4d2.png)

### 中介者（Mediator）

1. 意图：
   **用一个中介对象来封装一系列的对象交互**
   ，中介者使各个对象不需要显式相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
2. 适用场景：

![](https://i-blog.csdnimg.cn/img_convert/645093a7ed171eb6d9d7fd438ec074ab.png)

3. 适用中介者模式后的场景

![](https://i-blog.csdnimg.cn/img_convert/769938a6885496908ceba1b2b74546fb.png)

4. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/b92d25809bf1a9e2ea5a65f80fe1d0bc.png)

5. UML图

![](https://i-blog.csdnimg.cn/img_convert/fbf3aa1569485f5095b3636498c16d07.png)

6. 示例代码

```java
package mediator;

import com.sun.org.apache.xpath.internal.operations.Neg;

import java.util.Random;

public class Test {

    public static void main(String[] args) {

      Student a=  new Student("1");
        Student b=           new Student("2");
        Student c=          new Student("3");
        Student d=         new Student("4");
        Student[] students = {
               a,b,c,d
        };
        ConcreteMediator mediator = new ConcreteMediator(students);

        a.send("22222","2");
        mediator.showList();

    }
}

// 同事类
abstract class  Colleague{
    protected Mediator mediator;
    protected String id;
    protected String info;



    abstract void send(String info,String  ColleaGueId);


}
class Student extends  Colleague{
    public Student (String id){
        this.id = id;
    }




    public void setId(String id) {
        this.id = id;
    }

    public void setInfo(String info) {
        this.info = info;
    }

    public String getId() {
        return id;
    }

    public String getInfo() {
        return info;
    }



    @Override
    void send(String info, String ColleaGueId) {

        mediator.forward(info,ColleaGueId);
    }

}
// 中介者类
abstract class Mediator{
    protected Colleague[] colleagues;
    public Mediator (){

    }
    public Mediator(Colleague[] colleagues){
        this.colleagues = colleagues;
    }
     abstract public void forward(String info,String  ColleaGueId);

}
class ConcreteMediator extends  Mediator{

    public ConcreteMediator(Colleague[] colleagues){
        this.colleagues = colleagues;
        for (Colleague colleague : colleagues) {

            colleague.mediator =this;
        }

    }
    public void showList(){
        for (Colleague colleague : colleagues) {
            System.out.println(colleague.id +":"+colleague.info);
        }
    }
    @Override
    public void forward(String info, String ColleaGueId) {
        for (Colleague colleague : colleagues) {
            if (colleague.id==ColleaGueId){
                colleague.info = info;
                System.out.println("id为"+colleague.id +"以收到消息，消息为："+colleague.info);
            }
        }
    }
}

```

![](https://i-blog.csdnimg.cn/img_convert/05e3075effb3ce78be520dfc36ccbdbf.png)

7. 例题1

![](https://i-blog.csdnimg.cn/img_convert/4dbecdd8e100256a4c13a9a571694337.png)

![](https://i-blog.csdnimg.cn/img_convert/2ae23620d0ed2eb1bfec19ecf18cec82.png)

### 备忘录模式（Memento）

1. 意图：
   **在不破环封装性的前提下捕获一个对象的内部状态并在对象之外保存这个状态**
   。这样以后就可以将对象恢复到原先保存的状态。
2. 例如：虚拟机中的系统快照。
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/796fc37c562e7dad4d172d32629fc557.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/222a3380d20b6f22327c7d8c50ecc5f4.png)

5. 示例代码：

```java
package memento;

import com.sun.org.apache.xpath.internal.operations.Or;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        Originator originator = new Originator();
        List<Memento> mementos = new ArrayList<>();
        mementos.add(originator.createMemento());


        for (Memento memento : mementos) {
            System.out.println(memento.getState());
        }
        System.out.println("==========================");
        // 假设将原发器状态设置为2.0后，有需要改回1.0
        originator.setState("2.0");
        mementos.add(originator.createMemento());
        for (Memento memento : mementos) {
            System.out.println(memento.getState());
        }
        System.out.println("===========================");
        System.out.println("当前原发器的状态为："+originator.getState());
        System.out.println("===============");

        // 改为1.0
        originator.setMemento(mementos.get(0));
        System.out.println("当前原发器的状态为："+originator.getState());
        
    }

}

// 原发器（需要备忘录的对象）
class Originator{
    private String state;
    public Originator(){
        this.state = "1.0";
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public void setMemento(Memento memento) {
       this.state =memento.getState();
    }
    public Memento createMemento(){
        return  new Memento(state);
    }
}

// 备忘录
class Memento{
    private String state;
    public Memento(){

    }
    public Memento(String state){
        this.state = state;
    }

    public String getState() {
        return state;
    }
}


```

![](https://i-blog.csdnimg.cn/img_convert/6540378039c355bd0fe1c426c024410f.png)

### 观察者模式（Observer）

1. 意图：
   **定义对象间的一种一对多的依赖联系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新**
   。
2. 例如：博主和粉丝之间的关系，粉丝订阅了博主，当博主内容更新时，会通知所有的粉丝。
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/73768a44416220cf091ba992a341711a.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/2f5ccc56886b28936ebeab5684d654e1.png)

5. 示例代码：

```java
package observer;

import java.lang.invoke.ConstantCallSite;
import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        ConcreteSubject concreteSubject = new ConcreteSubject();
        ConcreteObserver c1= new ConcreteObserver();
        ConcreteObserver c2= new ConcreteObserver();
        ConcreteObserver c3= new ConcreteObserver();

        concreteSubject.add(c1);
        concreteSubject.add(c2);
        concreteSubject.add(c3);

        for (ConcreteObserver concreteObserver : concreteSubject.list) {
            System.out.println(concreteObserver.getState());
        }
        System.out.println("======================");
        concreteSubject.setState("更新了，同志们");
        concreteSubject.notifyObserver();
        for (ConcreteObserver concreteObserver : concreteSubject.list) {
            System.out.println(concreteObserver.getState());
        }

    }
}

// 观察者抽象接口
interface    Observer{
  void update();

}
class  ConcreteObserver implements Observer{
    private  String state;
    private ConcreteSubject subject;

    @Override
    public void update() {
        System.out.println("状态更新了");
      this.state = subject.getState();
    }


    public void setSubject(ConcreteSubject subject) {
        this.subject = subject;
    }

    public String getState() {
        return state;
    }
}

interface Subject{
    void add(ConcreteObserver concreteObserver);
    boolean remove(ConcreteObserver concreteObserver);

    void notifyObserver();

}
class  ConcreteSubject implements  Subject{
    private  String state;
    List<ConcreteObserver> list ;
    public ConcreteSubject(){
        list = new ArrayList<>();
    }


    @Override
    public void add(ConcreteObserver concreteObserver) {

        list.add(concreteObserver);
    }

    @Override
    public boolean remove(ConcreteObserver concreteObserver) {
        return list.remove(concreteObserver);
    }

    @Override
    public void notifyObserver() {
        for (ConcreteObserver concreteObserver : list) {
            concreteObserver.setSubject(this);
            concreteObserver.update();
        }


    }

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}


```

![](https://i-blog.csdnimg.cn/img_convert/cd5210728055eb5a2b1e89f1d0626d92.png)

6. 例题1

![](https://i-blog.csdnimg.cn/img_convert/9431952e972fb817c47c30e0bcaa6b24.png)

7. 例题2

![](https://i-blog.csdnimg.cn/img_convert/d5303ca9ef18b495d21467daad32091d.png)

8. 例题3

![](https://i-blog.csdnimg.cn/img_convert/d7708484df318d420354c8dba664060a.png)

9. 例题4

![](https://i-blog.csdnimg.cn/img_convert/8721366cf93f8be1f974a6f3ddd50940.png)

10. 例题5

![](https://i-blog.csdnimg.cn/img_convert/673f4fb88a5d1da6e3927e245bb1619f.png)
![](https://i-blog.csdnimg.cn/img_convert/da1688ee94620399961b00c397c3505a.png)

11. 例题6

![](https://i-blog.csdnimg.cn/img_convert/2c5d3b7282fa9e12a6e5c7927888b097.png)

### 状态（state）

1. 意图：
   **允许一个对象在其内部状态改变时改变它的行为**
   ，对象看起来似乎修改了它的类
   1. 注意：这个模式时被动改变
2. 例如：自动贩卖机
   1. 有货》》可以卖
   2. 无货》补货
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/9d5d52a8ffd2897f1dc472548f3017d6.png)

4. UML图

![](https://i-blog.csdnimg.cn/img_convert/4ca5034566de4640e2ce5cf09c55c041.png)

5. 示例代码

```java
package state;

import java.util.Objects;
import java.util.Timer;
import java.util.logging.Handler;

public class Test {
    public static void main(String[] args) throws InterruptedException {
        Contenxt contenxt = new Contenxt(3);
        contenxt.Request();
        contenxt.Request();
        contenxt.Request();
        contenxt.Request();
        contenxt.Request();
    }
}


// 抽象状态类
abstract class  State{
    abstract void handle() throws InterruptedException;
}
// 有货
class  HaveProductConcreteState extends  State{
    private Contenxt contenxt;
    public HaveProductConcreteState (Contenxt contenxt){
        this.contenxt =contenxt;
    }

    @Override
    void handle() {

        System.out.println("售卖产品中");
        contenxt.setProductNumber(contenxt.productNumber-1);


    }
}
class NoProductConcreteState extends State{
    private Contenxt contenxt;
    public NoProductConcreteState (Contenxt contenxt){
        this.contenxt =contenxt;
    }



    @Override
    void handle() throws InterruptedException {
        System.out.println("暂无余货");
        System.out.println("补货中");
        Thread.sleep(5000);
        contenxt.setProductNumber(3);
        System.out.println("补货完成");

//        new Thread(()->{
//            try {
//
//            } catch (InterruptedException e) {
//                throw new RuntimeException(e);
//            }
//        }).start();
    }
}
// 售卖机
class Contenxt{
    int productNumber ;
    private State state;

    public Contenxt(int productNumber){
        this.productNumber = productNumber;

    }
    // 卖
    public void Request() throws InterruptedException {
        if(productNumber>=1){
           state= new HaveProductConcreteState(this);

        }else{
          state = new NoProductConcreteState(this);

        }
        state.handle();
    }

    public void setProductNumber(int productNumber) {
        this.productNumber = productNumber;
    }
}

```

![](https://i-blog.csdnimg.cn/img_convert/2fa7798cb78f47f4d9a153cb18625b4a.png)

6. 例题1

![](https://i-blog.csdnimg.cn/img_convert/b087f2140d49e1aa468bc131654f5ba1.png)

7. 例题2

![](https://i-blog.csdnimg.cn/img_convert/904d3273d837bdfc7ea600479f2ad2a8.png)

![](https://i-blog.csdnimg.cn/img_convert/e22342a4844c9b7218f95e236793ad74.png)

### 策略模式（Strategy）

1. 意图：
   **定义一系类的算法，把它们一个个封装起来，时它们可以相互替换**
   ，此模式使得算法可以独立于使用它们的客户而变化。
2. 例如：付款方式：
   1. 微信支付
   2. 支付宝支付
   3. 现金支付
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/48d20d3ac4ce43239c775f3f9546e2df.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/68bd37da093c26691d345b9956e581dd.png)

5. 示例代码：

```java
package strategy;

public class Test {
    public static void main(String[] args) {
        Context context = new Context();
        // 加法策略
        Strategy add = new AddSteategy();
        context.setStrategy(add);
        context.ContextInterface(1,1);
        // 减法策略
        Strategy  sub = new SubSteategy();
        context.setStrategy(sub);
        context.ContextInterface(1,1);


    }
}


class  Context{
    private Strategy strategy;
    public  Context(){

    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public  Context(Strategy strategy){
        this.strategy= strategy;
    }
    public void ContextInterface(int a,int b){
        strategy.AlgorthmInterface(a,b);
    }
}
// 抽象策略
abstract class Strategy{


    abstract  void AlgorthmInterface(int a,int b);
}
// 加法add
class AddSteategy extends  Strategy{

    @Override
    void AlgorthmInterface(int a,int b) {
        System.out.println(a+b);
    }
}

// 减法sub
class SubSteategy extends  Strategy{

    @Override
    void AlgorthmInterface(int a,int b) {
        System.out.println(a-b);
    }
}



```

![](https://i-blog.csdnimg.cn/img_convert/d7f8240a7507f2ab0a8f3b1586bf66d2.png)

6. 例题1：

![](https://i-blog.csdnimg.cn/img_convert/4f5e26daa54b6896fd174ef26e6576f2.png)

7. 例题2

![](https://i-blog.csdnimg.cn/img_convert/4f9a196da97aca3b63ece0ceb69b3985.png)

8.例题3：

![](https://i-blog.csdnimg.cn/img_convert/3c72e0a1fdc55ee759210fbcd1ef34da.png)

### 模板方法（Template Method）

1. 意图：
   **定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构**
   。即可重定义该算法的某些特定步骤：
2. 例如：例如：上课和下课对于学生和老师都是一样的，但是在课上的行为，二者就是不同的了。
3. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/676146f5bb7fd4e8e5f89625037503e6.png)

4. UML图：

![](https://i-blog.csdnimg.cn/img_convert/b25a816e83c3c2d046464e2069292458.png)

5. 示例代码：

```java
package templateMethod;

public class Test {
    public static void main(String[] args) {
        Student student = new Student();
        student.templateMethod();
    }
}
abstract class ClassUp{
     void templateMethod(){
         System.out.println("上课");
         primitiveOperation1();

         System.out.println("下课");
         primitiveOperation2();
     }
     abstract  void primitiveOperation1();
     abstract  void primitiveOperation2();
}
// 学生
class Student extends  ClassUp{

    @Override
    void primitiveOperation1() {
        // 课中
        System.out.println("学生要：听课、做笔记");
    }

    @Override
    void primitiveOperation2() {
// 课后
        System.out.println("学生要：整理笔记、完成作业，复习");
    }
}


```

![](https://i-blog.csdnimg.cn/img_convert/fec15e49da620695107927e98a82bafe.png)

### 访问者模式（Visitor）

1. 意图：表示一个作用于某对象结构中的各个元素的操作，它允许在不允许各元素的类的前提下定义作用于这些元素的新操作。
2. 适用性：

![](https://i-blog.csdnimg.cn/img_convert/7ea48f240352d4de8314492101fce101.png)

3. UML图：

![](https://i-blog.csdnimg.cn/img_convert/4220499e33c0ac25080d350c51bde829.png)

问它

![](https://i-blog.csdnimg.cn/img_convert/7262d328de7498d6d5e007459952f6c6.png)

![](https://i-blog.csdnimg.cn/img_convert/4f39367108f9dc9daa1afb23d8a6c42b.png)

4. 示例代码：

```java
package visitor;

import java.util.ArrayList;
import java.util.List;

public class Client {
    public static void main(String[] args) {

        List<Person> list = new ArrayList<>();
        list.add(new Student("张三",11));
        list.add(new Student("李四",13));
        list.add(new Student("王五",12));
        list.add(new Teacher("王老师",32));
        list.add(new Teacher("张老师",42));
        list.add(new Teacher("谢老师",52));
        PersonStructure personStructure = new PersonStructure(list);

        // 访问者1初始化
        ConcreteVisitor1 visitor1 = new ConcreteVisitor1();
        personStructure.visitor(visitor1);

        // 总年龄：
        System.out.println("学生总年龄："+visitor1.getStudentAgeSum());
        System.out.println("老师总年龄："+visitor1.getTeacherAgeSum());
    }
}

abstract  class Visitor{
    abstract void VisitorStudent(Student student);
    abstract  void VisitorTeacher(Teacher teacher);

}

// 访问者1
class ConcreteVisitor1 extends  Visitor{
   private int studentAgeSum=0;
   private int teacherAgeSum =0;

    public int getStudentAgeSum() {
        return studentAgeSum;
    }

    public int getTeacherAgeSum() {
        return teacherAgeSum;
    }

    @Override
    void VisitorStudent(Student student) {
        // 求访问学生的年龄总和
        studentAgeSum+=student.getAge();


    }

    @Override
    void VisitorTeacher(Teacher teacher) {
        // 求访问老师的年龄总和
        teacherAgeSum+=teacher.getAge();

    }
}
abstract class   Person{
    private String name;
    private int age;
    public Person(){

    }
    public Person(String name,int age){
        this.name =name;
        this.age =age;
    }
    abstract void Accept(Visitor visitor);

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

// 学生
class  Student extends Person{
    public Student(String name,int age){
       super(name,age);
    }

    @Override
    void Accept(Visitor visitor) {
        visitor.VisitorStudent(this);
    }
}
class Teacher extends Person{
    public Teacher(String name,int age){
        super(name,age);
    }


    @Override
    void Accept(Visitor visitor) {
        visitor.VisitorTeacher(this);
    }
}

// 对象结构
class  PersonStructure{
    private List<Person> people;
    public PersonStructure (){

    }
    public PersonStructure(List<Person> list){
        this.people = list;
    }
    public void visitor(Visitor visitor){
        for (Person person : people) {
            person.Accept(visitor);
        }

    }
}


```

![](https://i-blog.csdnimg.cn/img_convert/796bbfba3d2aeb8af707a33cc6d427ad.png)

5. 例题1：

![](https://i-blog.csdnimg.cn/img_convert/9045f449e7291b37696bc1aaa48d0d70.png)

6. 例题2

![](https://i-blog.csdnimg.cn/img_convert/cbc8041266b745648702e298380cf8a0.png)
![](https://i-blog.csdnimg.cn/img_convert/78913cc23dd0b61cee70d5939d6d6ae3.png)

## 四、综合题

1. 题1

![](https://i-blog.csdnimg.cn/img_convert/66a9097a168c74e0999578ab4bcfc985.png)

2. 题2

![](https://i-blog.csdnimg.cn/img_convert/fc058a3952b4f43c314162dabb58a5b5.png)

3. 题3

![](https://i-blog.csdnimg.cn/img_convert/21d4b95df2f4f16b85bc1aa9b11f60cf.png)

4. 题4

![](https://i-blog.csdnimg.cn/img_convert/356fe3aa948aa319357119bb4063d3fd.png)

5. 题5

![](https://i-blog.csdnimg.cn/img_convert/71fccf5ea5e4d7edf12016a6d59d6f08.png)

6. 题6

![](https://i-blog.csdnimg.cn/img_convert/7b6d5d34cce908307087ecb6aa1088fc.png)

7. 题7

![](https://i-blog.csdnimg.cn/img_convert/840336f259c9c2d28de4de80b489c9b3.png)

8. 题8

![](https://i-blog.csdnimg.cn/img_convert/ad974b3d3efe43251a67b4ad7ef1d26d.png)