---
layout: post
title: "LeetCode-Hot100刷题反转链表迭代递归"
date: 2025-03-09 22:54:31 +0800
description: "处理到链表末尾时直接返回。"
keywords: "LeetCode Hot100刷题——反转链表（迭代+递归）"
categories: ['未分类']
tags: ['链表', '算法', 'Leetcode']
artid: "146128402"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146128402
    alt: "LeetCode-Hot100刷题反转链表迭代递归"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146128402
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146128402
cover: https://bing.ee123.net/img/rand?artid=146128402
image: https://bing.ee123.net/img/rand?artid=146128402
img: https://bing.ee123.net/img/rand?artid=146128402
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LeetCode Hot100刷题——反转链表（迭代+递归）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     206.反转链表
    </h2>
    <p>
     给你单链表的头节点
     <code>
      head
     </code>
     ，请你反转链表，并返回反转后的链表。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/6524f17e69e792146a95240296b160eb.jpeg" width="542"/>
    </p>
    <pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
</pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/bc193527cef36c92fe708f16ce3cd575.jpeg" width="182"/>
    </p>
    <pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
</pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      链表中节点的数目范围是
      <code>
       [0, 5000]
      </code>
     </li>
     <li>
      <code>
       -5000 &lt;= Node.val &lt;= 5000
      </code>
     </li>
    </ul>
    <p>
    </p>
    <p>
     反转链表通常有两种方法：迭代法和递归法。
    </p>
    <p>
    </p>
    <h2>
     迭代法（双指针）
    </h2>
    <p>
     假设原来的链表是1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null，反转后变成null&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5。那在迭代的时候，初始状态应该是prev=null，current=head。然后循环处理每个节点：
    </p>
    <p>
     在循环中，首先保存当前节点的下一个节点nextTemp，然后把当前节点的next指向prev。接着prev移动到current的位置，current移动到nextTemp的位置。直到current为null，此时prev就是新的头节点。
    </p>
    <p>
     <strong>
      实现代码：
     </strong>
    </p>
    <pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode current = head;
        ListNode prev = null;
        while (current != null) {
            ListNode nextTemp = current.next; // 保存下一个节点
            current.next = prev; /// 反转指针
            prev = current; // 前移prev
            current = nextTemp; // 前移current
        }
        return prev; // prev即为新链表的头结点
    }
}</code></pre>
    <p>
     <strong>
      步骤解释：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        初始化指针
       </strong>
       ：使用两个指针
       <code>
        prev
       </code>
       和
       <code>
        current
       </code>
       ，初始时
       <code>
        prev
       </code>
       为
       <code>
        null
       </code>
       ，
       <code>
        current
       </code>
       指向头节点
       <code>
        head
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        遍历链表
       </strong>
       ：在
       <code>
        current
       </code>
       不为
       <code>
        null
       </code>
       时循环处理每个节点。
      </p>
      <ul>
       <li>
        <p>
         <strong>
          保存下一个节点
         </strong>
         ：临时存储
         <code>
          current.next
         </code>
         到
         <code>
          nextTemp
         </code>
         ，防止反转指针后丢失后续节点。
        </p>
       </li>
       <li>
        <p>
         <strong>
          反转指针
         </strong>
         ：将当前节点
         <code>
          current
         </code>
         的
         <code>
          next
         </code>
         指向
         <code>
          prev
         </code>
         ，完成当前节点的反转。
        </p>
       </li>
       <li>
        <p>
         <strong>
          移动指针
         </strong>
         ：将
         <code>
          prev
         </code>
         移动到当前
         <code>
          current
         </code>
         的位置，
         <code>
          current
         </code>
         移动到之前保存的
         <code>
          nextTemp
         </code>
         位置。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        返回新头节点
       </strong>
       ：当循环结束时，
       <code>
        current
       </code>
       为
       <code>
        null
       </code>
       ，
       <code>
        prev
       </code>
       指向原链表的最后一个节点，即反转后的新头节点。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <h2>
     递归法
    </h2>
    <p>
     <strong>
      递归方法的步骤如下：
     </strong>
    </p>
    <ol>
     <li>
      递归终止条件：当前节点为空或下一个子节点为空，返回当前节点
     </li>
     <li>
      递归反转后续链表，得到反转后的头结点
     </li>
     <li>
      将当前节点的下一个节点的next指向当前节点，形成反转
     </li>
     <li>
      将当前节点的next设为null，断开原来的连接
     </li>
     <li>
      返回反转后的头结点
     </li>
    </ol>
    <p>
    </p>
    <p>
     <strong>
      实现代码
     </strong>
    </p>
    <pre><code class="language-java">class Solution {
    public ListNode reverseList(ListNode head) {
        // 递归法
        // 递归终止条件，空链表或单链表无需反转
        if (head == null || head.next == null) {
            return head;
        }

        // 递归反转后续链表，得到新头结点
        ListNode newHead = reverseList(head.next);

        // 调整指针方向，将当前节点的下一个节点的next指向自己
        head.next.next = head;

        // 断开当前节点的原指向，防止循环
        head.next = null;

        // 返回新头结点
        return newHead;
    }
}</code></pre>
    <p>
     <strong>
      示例分析
     </strong>
    </p>
    <p>
     <strong>
      1. 递归调用栈展开
     </strong>
    </p>
    <p>
     递归从头部节点
     <code>
      1
     </code>
     开始，逐层深入，直到链表末尾的节点
     <code>
      5
     </code>
     。以下是调用栈的展开过程：
    </p>
    <pre>reverseList(1) → reverseList(2) → reverseList(3) → reverseList(4) → reverseList(5)</pre>
    <p>
     <strong>
      终止条件触发
     </strong>
     ：当调用
     <code>
      reverseList(5)
     </code>
     时，
     <code>
      5.next == null
     </code>
     ，直接返回
     <code>
      5
     </code>
     （此时
     <code>
      newHead = 5
     </code>
     ）。
    </p>
    <p>
    </p>
    <p>
     <strong>
      2. 递归回溯与指针调整
     </strong>
    </p>
    <p>
    </p>
    <p>
     递归开始逐层回溯，每层处理当前节点并调整指针方向：
    </p>
    <p>
     <strong>
      层 4（
      <code>
       head = 4
      </code>
      ）
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        输入链表状态
       </strong>
       ：
       <code>
        4 → 5
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        操作步骤
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         收到下层返回的
         <code>
          newHead = 5
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          调整指针
         </strong>
         ：
         <code>
          4.next.next = 4
         </code>
         →
         <code>
          5.next = 4
         </code>
         （形成
         <code>
          5 → 4
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          断开原链
         </strong>
         ：
         <code>
          4.next = null
         </code>
         （防止
         <code>
          4 → 5
         </code>
         循环）。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        输出链表状态
       </strong>
       ：
       <code>
        5 → 4 → null
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        返回
       </strong>
       ：
       <code>
        newHead = 5
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      层 3（
      <code>
       head = 3
      </code>
      ）
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        输入链表状态
       </strong>
       ：
       <code>
        3 → 4 → null
       </code>
       （原链未修改时，
       <code>
        3.next
       </code>
       仍指向
       <code>
        4
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        操作步骤
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         收到下层返回的
         <code>
          newHead = 5
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          调整指针
         </strong>
         ：
         <code>
          3.next.next = 3
         </code>
         →
         <code>
          4.next = 3
         </code>
         （形成
         <code>
          5 → 4 → 3
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          断开原链
         </strong>
         ：
         <code>
          3.next = null
         </code>
         。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        输出链表状态
       </strong>
       ：
       <code>
        5 → 4 → 3 → null
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        返回
       </strong>
       ：
       <code>
        newHead = 5
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      层 2（
      <code>
       head = 2
      </code>
      ）
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        输入链表状态
       </strong>
       ：
       <code>
        2 → 3 → null
       </code>
       （原链未修改时，
       <code>
        2.next
       </code>
       指向
       <code>
        3
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        操作步骤
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         收到下层返回的
         <code>
          newHead = 5
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          调整指针
         </strong>
         ：
         <code>
          2.next.next = 2
         </code>
         →
         <code>
          3.next = 2
         </code>
         （形成
         <code>
          5 → 4 → 3 → 2
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          断开原链
         </strong>
         ：
         <code>
          2.next = null
         </code>
         。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        输出链表状态
       </strong>
       ：
       <code>
        5 → 4 → 3 → 2 → null
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        返回
       </strong>
       ：
       <code>
        newHead = 5
       </code>
      </p>
     </li>
    </ul>
    <p>
     <strong>
      层 1（
      <code>
       head = 1
      </code>
      ）
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        输入链表状态
       </strong>
       ：
       <code>
        1 → 2 → null
       </code>
       （原链未修改时，
       <code>
        1.next
       </code>
       指向
       <code>
        2
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        操作步骤
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         收到下层返回的
         <code>
          newHead = 5
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         <strong>
          调整指针
         </strong>
         ：
         <code>
          1.next.next = 1
         </code>
         →
         <code>
          2.next = 1
         </code>
         （形成
         <code>
          5 → 4 → 3 → 2 → 1
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          断开原链
         </strong>
         ：
         <code>
          1.next = null
         </code>
         。
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        输出链表状态
       </strong>
       ：
       <code>
        5 → 4 → 3 → 2 → 1 → null
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        返回
       </strong>
       ：
       <code>
        newHead = 5
       </code>
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      总结
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        递归终止条件
       </strong>
       ：处理到链表末尾时直接返回。
      </p>
     </li>
     <li>
      <p>
       <strong>
        递归分解问题
       </strong>
       ：假设后续链表已反转，只需调整当前节点和下一个节点的指针。
      </p>
     </li>
     <li>
      <p>
       <strong>
        指针操作
       </strong>
       ：通过
       <code>
        head.next.next = head
       </code>
       和
       <code>
        head.next = null
       </code>
       完成局部反转并断开原链。
      </p>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373032313931332f:61727469636c652f64657461696c732f313436313238343032" class_="artid" style="display:none">
 </p>
</div>


