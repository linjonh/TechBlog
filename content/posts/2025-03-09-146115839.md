---
layout: post
title: "liunx学习四文本处理stdout-stderr,Cut,paste,sort,tr,head,Tail,join,Split,grep,..."
date: 2025-03-09 11:29:11 +0800
description: "程序正常排水管 → 用。"
keywords: "liunx学习(四)(文本处理(stdout stderr,Cut,paste,sort,tr,head,Tail,join,Split,grep,...))"
categories: ['未分类']
tags: ['开发语言', '学习', 'Linux']
artid: "146115839"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146115839
    alt: "liunx学习四文本处理stdout-stderr,Cut,paste,sort,tr,head,Tail,join,Split,grep,..."
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146115839
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146115839
cover: https://bing.ee123.net/img/rand?artid=146115839
image: https://bing.ee123.net/img/rand?artid=146115839
img: https://bing.ee123.net/img/rand?artid=146115839
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     liunx学习(四)(文本处理(stdout stderr,Cut,paste,sort,tr,head,Tail,join,Split,grep,...))
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     我们可以用
     <strong>
      “文字处理流水线”
     </strong>
     的比喻来理解 Linux 的文本处理工具，让你像工厂加工零件一样高效处理文本数据：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 核心工具分工
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        工具
       </th>
       <th>
        比喻
       </th>
       <th>
        核心功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         <code>
          grep
         </code>
        </strong>
       </td>
       <td>
        <strong>
         关键词扫描仪
        </strong>
       </td>
       <td>
        快速过滤包含特定关键词的行
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          sed
         </code>
        </strong>
       </td>
       <td>
        <strong>
         批量替换机器人
        </strong>
       </td>
       <td>
        自动查找并替换文本内容
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          awk
         </code>
        </strong>
       </td>
       <td>
        <strong>
         数据分拣大师
        </strong>
       </td>
       <td>
        按列处理结构化数据（如CSV）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          cut
         </code>
        </strong>
       </td>
       <td>
        <strong>
         剪刀手
        </strong>
       </td>
       <td>
        按列或字符位置裁剪文本
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 实战场景演示
     </strong>
    </h4>
    <h5 style="background-color:transparent">
     <strong>
      场景1：用
      <code>
       grep
      </code>
      找日志中的错误
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 在日志中搜索 "ERROR" 关键词（像用放大镜找特定文字）
grep "ERROR" app.log
# 高级用法：忽略大小写 (-i)，显示行号 (-n)
grep -i -n "critical" system.log</code></pre>
    <pre></pre>
    <h5>
     <strong>
      场景2：用
      <code>
       sed
      </code>
      批量修改配置
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 将文件中的 "旧密码" 全部替换为 "新密码"
sed 's/旧密码/新密码/g' config.txt &gt; new_config.txt
# 直接修改原文件（-i 选项）
sed -i 's/192.168.1.1/10.0.0.1/g' network.conf</code></pre>
    <pre></pre>
    <h5 style="background-color:transparent">
     <strong>
      场景3：用
      <code>
       awk
      </code>
      分析销售数据
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 提取 CSV 文件的第2列（金额），并计算总和
awk -F ',' '{sum += $2} END {print "总销售额:", sum}' sales.csv
# 打印第1列（产品名）和第3列（销量），按销量排序
awk -F ',' '{print $1, $3}' sales.csv | sort -k2 -n</code></pre>
    <pre></pre>
    <h5>
     <strong>
      场景4：用
      <code>
       cut
      </code>
      裁剪用户列表
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 提取 /etc/passwd 中的用户名（第1列，冒号分隔）
cut -d ':' -f1 /etc/passwd
# 截取日志时间戳（前20个字符）
cut -c1-20 access.log</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      3. 图形编辑器对比
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        编辑器
       </th>
       <th>
        比喻
       </th>
       <th>
        特点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         gedit
        </strong>
       </td>
       <td>
        智能写字板
       </td>
       <td>
        简单易用，适合新手
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         nano
        </strong>
       </td>
       <td>
        迷你便签
       </td>
       <td>
        命令行下的基础编辑器
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         vim
        </strong>
       </td>
       <td>
        瑞士军刀编辑器
       </td>
       <td>
        功能强大，学习曲线陡峭
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      4. 组合使用示例
     </strong>
    </h4>
    <h5>
     <strong>
      分析网站访问日志
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 找出访问量最高的前5个IP地址
cat access.log | awk '{print $1}' | sort | uniq -c | sort -nr | head -5</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        步骤分解
       </strong>
       ：
      </p>
      <ol>
       <li>
        <p>
         <code>
          cat
         </code>
         读取日志文件
        </p>
       </li>
       <li>
        <p>
         <code>
          awk
         </code>
         提取第1列（IP地址）
        </p>
       </li>
       <li>
        <p>
         <code>
          sort
         </code>
         排序相同IP相邻
        </p>
       </li>
       <li>
        <p>
         <code>
          uniq -c
         </code>
         统计每个IP出现次数
        </p>
       </li>
       <li>
        <p>
         <code>
          sort -nr
         </code>
         按访问量倒序
        </p>
       </li>
       <li>
        <p>
         <code>
          head -5
         </code>
         显示前5名
        </p>
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      5. 为什么需要这些工具？
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        需求场景
       </th>
       <th>
        适用工具
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         快速定位错误
        </strong>
       </td>
       <td>
        <code>
         grep
        </code>
       </td>
       <td>
        <code>
         grep "OutOfMemory" java.log
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         批量修改配置
        </strong>
       </td>
       <td>
        <code>
         sed
        </code>
       </td>
       <td>
        <code>
         sed -i 's/enabled=false/enabled=true/g' *.conf
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         报表数据统计
        </strong>
       </td>
       <td>
        <code>
         awk
        </code>
       </td>
       <td>
        <code>
         awk '{sum += $3} END {print sum}' data.txt
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         提取特定字段
        </strong>
       </td>
       <td>
        <code>
         cut
        </code>
       </td>
       <td>
        <code>
         cut -d ',' -f2-4 input.csv
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        备份原文件
       </strong>
       ：使用
       <code>
        sed -i
       </code>
       或批量操作前，先备份：
      </p>
      <pre><code>cp important.txt important.txt.bak</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        正则表达式测试
       </strong>
       ：复杂替换先用
       <code>
        echo
       </code>
       测试：
      </p>
      <pre><code>echo "hello 123" | sed 's/[0-9]\+/NUMBERS/'</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        处理空格/特殊字符
       </strong>
       ：用引号包裹变量和路径：
      </p>
      <pre><code>grep "special file" "my document.txt"</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         grep
        </code>
       </strong>
       ：文字扫描仪，专找关键词
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         sed
        </code>
       </strong>
       ：替换机器人，批量改内容
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         awk
        </code>
       </strong>
       ：数据分拣机，表格处理专家
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         cut
        </code>
       </strong>
       ：精准剪刀手，按列裁剪文本
      </p>
     </li>
    </ul>
    <p>
     掌握这些工具，你就能像工厂流水线一样高效处理海量文本！ 📊🔧
    </p>
    <p>
     我们可以用
     <strong>
      “厨房的水槽和漏水报警器”
     </strong>
     的比喻来理解 Linux 的
     <code>
      stdout
     </code>
     和
     <code>
      stderr
     </code>
     ，让你像管理厨房流水一样控制程序的输出：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 核心概念
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        名称
       </th>
       <th>
        比喻
       </th>
       <th>
        作用
       </th>
       <th>
        默认流向
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         stdout
        </strong>
       </td>
       <td>
        <strong>
         正常排水管
        </strong>
       </td>
       <td>
        输出程序正常结果
       </td>
       <td>
        终端屏幕
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         stderr
        </strong>
       </td>
       <td>
        <strong>
         漏水报警器
        </strong>
       </td>
       <td>
        输出错误和警告信息
       </td>
       <td>
        终端屏幕
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 工作场景
     </strong>
    </h4>
    <p>
     假设你正在用
     <strong>
      “智能电饭煲”
     </strong>
     （程序）做饭：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        正常流程（stdout）
       </strong>
       ：
      </p>
      <pre><code>电饭煲 &gt;&gt; 煮饭进度：50%... 100%... 饭已煮好！</code></pre>
      <pre></pre>
      <p>
       → 这些信息通过
       <strong>
        排水管
       </strong>
       （stdout）流到屏幕。
      </p>
     </li>
     <li>
      <p>
       <strong>
        异常情况（stderr）
       </strong>
       ：
      </p>
      <pre><code>电饭煲 !! 警报：水量不足！  
电饭煲 !! 错误：未检测到内胆！</code></pre>
      <pre></pre>
      <p>
       → 这些信息通过
       <strong>
        报警器
       </strong>
       （stderr）单独报告到屏幕。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 重定向操作
     </strong>
    </h4>
    <h5>
     <strong>
      (1) 分开收集正常排水和漏水
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 把正常进度存到日志，错误警报存到错误文件
电饭煲 &gt; 煮饭日志.txt 2&gt; 错误记录.txt</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          煮饭日志.txt
         </code>
         ：包含“煮饭进度：50%...”
        </p>
       </li>
       <li>
        <p>
         <code>
          错误记录.txt
         </code>
         ：包含“水量不足！”
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      (2) 合并排水管和报警器
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 所有信息（正常+错误）都导入同一个文件
电饭煲 &amp;&gt; 完整记录.txt</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        适用场景
       </strong>
       ：需要完整记录所有输出时。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      (3) 静默处理
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 丢弃所有正常输出和错误（类似关闭排水和报警）
电饭煲 &gt; /dev/null 2&gt;&amp;1</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        比喻
       </strong>
       ：维修时不关心正常流程，也不处理警报。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      4. 实际命令示例
     </strong>
    </h4>
    <h5>
     <strong>
      查找文件时分离结果和错误
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 正常结果存 found.txt，错误信息存 errors.log
find / -name "*.conf" &gt; found.txt 2&gt; errors.log</code></pre>
    <h4>
     <strong>
      1.
      <code>
       find / -name "*.conf"
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <code>
       find
      </code>
      ：Linux 命令，用于在指定路径下查找文件和目录。
     </li>
     <li>
      <code>
       /
      </code>
      ：根目录，表示从整个系统的根目录开始搜索（即搜索所有目录）。
     </li>
     <li>
      <code>
       -name "*.conf"
      </code>
      ：
      <ul>
       <li>
        <code>
         -name
        </code>
        选项表示按文件名搜索。
       </li>
       <li>
        <code>
         "*.conf"
        </code>
        表示匹配
        <strong>
         所有以
         <code>
          .conf
         </code>
         结尾的文件
        </strong>
        （
        <code>
         *
        </code>
        代表通配符，匹配任意字符）。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     👉
     <strong>
      这一部分的作用
     </strong>
     ：在整个系统中查找所有
     <code>
      .conf
     </code>
     配置文件。
    </p>
    <hr/>
    <h4>
     <strong>
      2.
      <code>
       &gt; found.txt
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <code>
       &gt;
      </code>
      ：
      <strong>
       标准输出（stdout）重定向符
      </strong>
      ，表示将
      <strong>
       正常的输出
      </strong>
      写入指定的文件。
     </li>
     <li>
      <code>
       found.txt
      </code>
      ：要保存搜索结果的文件。
     </li>
    </ul>
    <p>
     👉
     <strong>
      这一部分的作用
     </strong>
     ：将
     <code>
      find
     </code>
     命令成功找到的
     <code>
      .conf
     </code>
     文件路径
     <strong>
      保存到
      <code>
       found.txt
      </code>
     </strong>
     ，不会显示在终端上。
    </p>
    <p>
     <strong>
      示例
     </strong>
     ： 假设系统中有
     <code>
      /etc/nginx/nginx.conf
     </code>
     和
     <code>
      /home/user/app.conf
     </code>
     ，那么
     <code>
      found.txt
     </code>
     的内容可能是：
    </p>
    <pre><code>/etc/nginx/nginx.conf /home/user/app.conf</code></pre>
    <hr/>
    <h4>
     <strong>
      3.
      <code>
       2&gt; errors.log
      </code>
     </strong>
    </h4>
    <ul>
     <li>
      <code>
       2&gt;
      </code>
      ：
      <strong>
       标准错误（stderr）重定向符
      </strong>
      ，表示将
      <strong>
       错误信息
      </strong>
      写入指定的文件。
      <ul>
       <li>
        <code>
         2
        </code>
        代表
        <strong>
         标准错误（stderr）
        </strong>
        ，
        <code>
         &gt;
        </code>
        代表
        <strong>
         重定向
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <code>
       errors.log
      </code>
      ：用于存储
      <code>
       find
      </code>
      命令的错误信息。
     </li>
    </ul>
    <p>
     👉
     <strong>
      这一部分的作用
     </strong>
     ：如果
     <code>
      find
     </code>
     命令在搜索过程中遇到权限不足等错误，这些错误信息
     <strong>
      不会显示在终端，而是写入
      <code>
       errors.log
      </code>
     </strong>
     。
    </p>
    <p>
     <strong>
      示例
     </strong>
     ： 如果某些目录无法访问（比如
     <code>
      /root/
     </code>
     需要超级用户权限），那么
     <code>
      errors.log
     </code>
     的内容可能是：
    </p>
    <pre><code>find: ‘/root’: Permission denied find: ‘/var/log/private’: Permission denied</code></pre>
    <hr/>
    <h3>
     <strong>
      最终效果
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       成功找到的
       <code>
        .conf
       </code>
       文件
      </strong>
      的路径保存在
      <code>
       found.txt
      </code>
      。
     </li>
     <li>
      <strong>
       权限错误或无法访问的目录
      </strong>
      的错误信息保存在
      <code>
       errors.log
      </code>
      。
     </li>
     <li>
      终端不会显示任何信息。
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      扩展知识
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         符号
        </strong>
       </th>
       <th>
        <strong>
         作用
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         &gt;
        </code>
       </td>
       <td>
        <strong>
         重定向 stdout
        </strong>
        （标准输出）到文件（覆盖原文件）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         &gt;&gt;
        </code>
       </td>
       <td>
        <strong>
         重定向 stdout
        </strong>
        （标准输出）到文件（
        <strong>
         追加
        </strong>
        到文件末尾）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         2&gt;
        </code>
       </td>
       <td>
        <strong>
         重定向 stderr
        </strong>
        （标准错误）到文件（覆盖原文件）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         2&gt;&gt;
        </code>
       </td>
       <td>
        <strong>
         重定向 stderr
        </strong>
        （标准错误）到文件（
        <strong>
         追加
        </strong>
        到文件末尾）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         &amp;&gt;
        </code>
       </td>
       <td>
        <strong>
         同时重定向 stdout 和 stderr
        </strong>
        到文件（覆盖原文件）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         &amp;&gt;&gt;
        </code>
       </td>
       <td>
        <strong>
         同时重定向 stdout 和 stderr
        </strong>
        到文件（
        <strong>
         追加
        </strong>
        到文件末尾）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <strong>
      更高级用法
     </strong>
    </h3>
    <p>
     如果想要
     <strong>
      同时
     </strong>
     把输出和错误存入
     <strong>
      同一个
     </strong>
     文件：
    </p>
    <pre><code>find / -name "*.conf" &amp;&gt; output.log</code></pre>
    <p>
     或者：
    </p>
    <pre><code>find / -name "*.conf" &gt; output.log 2&gt;&amp;1</code></pre>
    <p>
     这样
     <code>
      output.log
     </code>
     里
     <strong>
      既有正常的结果，也有错误信息
     </strong>
     。
    </p>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <code>
       find / -name "*.conf"
      </code>
      ：查找所有
      <code>
       .conf
      </code>
      文件。
     </li>
     <li>
      <code>
       &gt; found.txt
      </code>
      ：将搜索到的结果保存到
      <code>
       found.txt
      </code>
      。
     </li>
     <li>
      <code>
       2&gt; errors.log
      </code>
      ：将错误信息保存到
      <code>
       errors.log
      </code>
      ，而不是显示在终端。
     </li>
    </ul>
    <p>
     你可以试着运行这个命令，并查看
     <code>
      found.txt
     </code>
     和
     <code>
      errors.log
     </code>
     的内容，看看它们是否符合你的预期！🚀
    </p>
    <h5>
     <strong>
      调试脚本时合并输出
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 所有信息输出到终端并保存到日志
./我的脚本.sh 2&gt;&amp;1 | tee debug.log</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      为什么需要区分两者？
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        精准排错
       </strong>
       ：快速定位错误信息，不受正常输出干扰。
      </p>
     </li>
     <li>
      <p>
       <strong>
        灵活处理
       </strong>
       ：正常日志可长期保存，错误信息单独报警。
      </p>
     </li>
     <li>
      <p>
       <strong>
        用户体验
       </strong>
       ：在终端中，错误信息通常用红色显示，更醒目。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      常见问题解答
     </strong>
    </h4>
    <h5>
     <strong>
      Q1：为什么错误信息不能用
      <code>
       &gt;
      </code>
      捕获？
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        答
       </strong>
       ：
       <code>
        &gt;
       </code>
       默认只处理 stdout，而错误信息走 stderr 通道，需用
       <code>
        2&gt;
       </code>
       。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      Q2：
      <code>
       2&gt;&amp;1
      </code>
      是什么意思？
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        答
       </strong>
       ：将 stderr（错误）合并到 stdout（正常输出）的流向，实现统一处理。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      Q3：如何同时显示并保存输出？
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        答
       </strong>
       ：用
       <code>
        tee
       </code>
       命令（类似分流水管）：
      </p>
      <pre><code>./程序.sh 2&gt;&amp;1 | tee 完整日志.txt  # 屏幕显示+文件保存
总结</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        stdout
       </strong>
       ：程序正常排水管 → 用
       <code>
        &gt;
       </code>
       或
       <code>
        &gt;&gt;
       </code>
       管理
      </p>
     </li>
     <li>
      <p>
       <strong>
        stderr
       </strong>
       ：程序漏水报警器 → 用
       <code>
        2&gt;
       </code>
       或
       <code>
        2&gt;&gt;
       </code>
       管理
      </p>
     </li>
     <li>
      <p>
       <strong>
        合并控制
       </strong>
       ：用
       <code>
        &amp;&gt;
       </code>
       或
       <code>
        2&gt;&amp;1
       </code>
       统一处理
      </p>
     </li>
    </ul>
    <p>
     像管理厨房水流一样掌控程序输出，让调试和日志管理更高效！ 🚰🚨
    </p>
    <h5>
    </h5>
    <p>
     我们可以用
     <strong>
      “精准剪刀手”
     </strong>
     的比喻来理解
     <strong>
      <code>
       cut
      </code>
     </strong>
     命令，让你像裁剪布料一样切割文本数据，只保留需要的部分：
    </p>
    <hr/>
    <h4 style="background-color:transparent">
     <strong>
      1. 核心功能 —— 按需裁剪
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        场景
       </th>
       <th>
        比喻
       </th>
       <th>
        <code>
         cut
        </code>
        的作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         提取列
        </strong>
       </td>
       <td>
        从布料上剪下第二列花纹
       </td>
       <td>
        从 CSV 文件中提取第二列数据
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         截取字符
        </strong>
       </td>
       <td>
        剪下布料的前5厘米
       </td>
       <td>
        截取每行前5个字符
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         分隔字段
        </strong>
       </td>
       <td>
        按布料上的标记线裁剪
       </td>
       <td>
        按逗号/冒号等符号分割字段
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 常用操作演示
     </strong>
    </h4>
    <h5>
     <strong>
      场景1：按分隔符提取列（如CSV）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 原始数据：姓名,年龄,城市
echo "张三,30,北京
李四,25,上海" &gt; 用户信息.csv

# 剪下第二列（年龄）
cut -d ',' -f2 用户信息.csv
# 输出：
# 30
# 25</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        参数解释
       </strong>
       ：
       <br/>
       <code>
        -d ','
       </code>
       → 按逗号分列（Delimiter）
       <br/>
       <code>
        -f2
       </code>
       → 取第2列（Field）
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      场景2：截取固定位置字符
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 原始数据：固定宽度日志
echo "2023-08-25 10:00 ERROR: Disk full
2023-08-25 10:05 INFO: Backup completed" &gt; system.log

# 剪下每行的前10个字符（日期）
cut -c1-10 system.log
# 输出：
# 2023-08-25
# 2023-08-25</code></pre>
    <pre></pre>
    <ul>
     <li>
      <p>
       <strong>
        参数解释
       </strong>
       ：
       <br/>
       <code>
        -c1-10
       </code>
       → 截取第1到第10个字符（Character）
      </p>
     </li>
    </ul>
    <hr/>
    <h5>
     <strong>
      场景3：提取多个字段
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 提取第1列和第3列（姓名和城市）
cut -d ',' -f1,3 用户信息.csv
# 输出：
# 张三,北京
# 李四,上海</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      3. 组合使用技巧
     </strong>
    </h4>
    <h5>
     <strong>
      分析系统用户
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 提取 /etc/passwd 中的用户名（第1列，冒号分隔）
cut -d ':' -f1 /etc/passwd
# 输出示例：
# root
# bin
# daemon</code></pre>
    <pre></pre>
    <h5>
     <strong>
      处理命令输出
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 查看当前目录文件的权限（ls -l 的第1列）
ls -l | cut -d ' ' -f1
# 输出示例：
# drwxr-xr-x
# -rw-r--r--</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        分隔符匹配
       </strong>
       ：
       <br/>
       确保
       <code>
        -d
       </code>
       指定的分隔符与数据一致（如 CSV 用逗号，日志用空格）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        字段编号从1开始
       </strong>
       ：
       <br/>
       <code>
        -f1
       </code>
       是第一列，不是第0列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        处理空格问题
       </strong>
       ：
       <br/>
       多个连续空格可能被识别为一个分隔符，建议用
       <code>
        tr
       </code>
       命令压缩空格：
      </p>
      <pre><code>ls -l | tr -s ' ' | cut -d ' ' -f3  # 提取文件所属用户</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <p>
     <code>
      cut
     </code>
     就像
     <strong>
      “文本剪刀手”
     </strong>
     —— 按列裁剪、按符号分割、按位置截取，轻松提取结构化数据！ ✂️📊
    </p>
    <p>
    </p>
    <p>
     我们可以用
     <strong>
      “并排粘合纸张”
     </strong>
     的比喻来理解
     <strong>
      <code>
       paste
      </code>
     </strong>
     命令，让你像整理表格一样轻松合并文件内容：
    </p>
    <hr/>
    <h4>
     <strong>
      1.
      <code>
       paste
      </code>
      的核心功能
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        场景
       </th>
       <th>
        比喻
       </th>
       <th>
        <code>
         paste
        </code>
        的作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         合并两列数据
        </strong>
       </td>
       <td>
        将两页纸并排粘贴成表格
       </td>
       <td>
        将两个文件的内容按列合并
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         自定义分隔符
        </strong>
       </td>
       <td>
        用不同胶水分隔列
       </td>
       <td>
        用指定符号（如逗号、竖线）分隔
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         处理不等长文件
        </strong>
       </td>
       <td>
        空位补白纸
       </td>
       <td>
        行数不同时，空白位置留空
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 基础用法演示
     </strong>
    </h4>
    <h5>
     <strong>
      场景1：简单合并两文件
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 文件1：姓名
cat names.txt
张三
李四
王五

# 文件2：电话号码
cat phones.txt
13800138000
13900139000

# 并排粘贴（默认用制表符分隔）
paste names.txt phones.txt
张三    13800138000
李四    13900139000
王五                    # 电话号码文件少一行，第三行留空</code></pre>
    <pre></pre>
    <h5>
     <strong>
      场景2：指定分隔符
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 用逗号分隔列（适合生成CSV）
paste -d ',' names.txt phones.txt
张三,13800138000
李四,13900139000
王五,                  # 空数据保留逗号</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      3. 高级技巧
     </strong>
    </h4>
    <h5>
     <strong>
      合并多个文件
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 合并三个文件（姓名、电话、邮箱）
paste -d '|' names.txt phones.txt emails.txt
张三|13800138000|zhangsan@example.com
李四|13900139000|lisi@example.com
王五||wangwu@example.com    # 电话为空</code></pre>
    <pre></pre>
    <h5>
     <strong>
      与
      <code>
       cut
      </code>
      命令配合使用
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 提取用户名并合并登录时间
cut -d ':' -f1 /etc/passwd &gt; users.txt
date "+%Y-%m-%d" &gt; date.txt
paste -d ' ' users.txt date.txt
root 2024-05-30
bin 2024-05-30
daemon 2024-05-30
...</code></pre>
    <h3>
     <strong>
      第一行：提取用户名
     </strong>
    </h3>
    <pre><code>cut -d ':' -f1 /etc/passwd &gt; users.txt</code></pre>
    <p>
     <strong>
      解析：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       cut
      </code>
      ：Linux 里的
      <strong>
       文本切割命令
      </strong>
      ，用于按列提取数据。
     </li>
     <li>
      <code>
       -d ':'
      </code>
      ：
      <strong>
       指定分隔符
      </strong>
      （delimiter）为
      <code>
       :
      </code>
      ，即数据是用
      <code>
       :
      </code>
      分隔的。
     </li>
     <li>
      <code>
       -f1
      </code>
      ：
      <strong>
       提取第 1 列
      </strong>
      （即用户名）。
     </li>
     <li>
      <code>
       /etc/passwd
      </code>
      ：
      <strong>
       Linux 系统的用户信息文件
      </strong>
      ，存储着用户账户信息，每一行表示一个用户，格式如下：
      <pre><code>root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/usr/sbin/nologin daemon:x:2:2:daemon:/sbin:/usr/sbin/nologin</code></pre>
      其中，
      <code>
       :
      </code>
      分隔的第一列是用户名：
      <ul>
       <li>
        <pre><code>root
bin
daemon
...</code></pre>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      输出
      <code>
       users.txt
      </code>
      文件内容（示例）：
     </strong>
    </p>
    <pre><code>root bin daemon ...</code></pre>
    <p>
    </p>
    <p>
     👉
     <strong>
      这一行的作用
     </strong>
     ：从
     <code>
      /etc/passwd
     </code>
     提取
     <strong>
      所有用户名
     </strong>
     ，并存入
     <code>
      users.txt
     </code>
     。
    </p>
    <hr/>
    <h3>
     <strong>
      第二行：获取当前日期
     </strong>
    </h3>
    <pre><code>date "+%Y-%m-%d" &gt; date.txt</code></pre>
    <p>
    </p>
    <p>
     <strong>
      解析：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       date
      </code>
      ：Linux 命令，
      <strong>
       显示当前系统时间
      </strong>
      。
     </li>
     <li>
      <code>
       "+%Y-%m-%d"
      </code>
      ：
      <ul>
       <li>
        <code>
         %Y
        </code>
        ：4 位数的年份（如
        <code>
         2024
        </code>
        ）。
       </li>
       <li>
        <code>
         %m
        </code>
        ：2 位数的月份（如
        <code>
         03
        </code>
        ）。
       </li>
       <li>
        <code>
         %d
        </code>
        ：2 位数的日期（如
        <code>
         08
        </code>
        ）。
       </li>
      </ul>
     </li>
     <li>
      <code>
       &gt; date.txt
      </code>
      ：
      <ul>
       <li>
        <code>
         &gt;
        </code>
        表示
        <strong>
         重定向
        </strong>
        ，即把
        <code>
         date
        </code>
        命令的
        <strong>
         输出保存到
         <code>
          date.txt
         </code>
         文件
        </strong>
        。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      示例：
     </strong>
     如果今天是
     <strong>
      2024 年 5 月 30 日
     </strong>
     ，
     <code>
      date.txt
     </code>
     的内容就是：
    </p>
    <pre><code>2024-05-30</code></pre>
    <p>
     👉
     <strong>
      这一行的作用
     </strong>
     ：获取
     <strong>
      今天的日期
     </strong>
     ，并存入
     <code>
      date.txt
     </code>
     。
    </p>
    <hr/>
    <h3>
     <strong>
      第三行：合并用户名和日期
     </strong>
    </h3>
    <pre><code>paste -d ' ' users.txt date.txt</code></pre>
    <p>
    </p>
    <p>
     <strong>
      解析：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       paste
      </code>
      ：Linux 命令，用于
      <strong>
       按列合并文件
      </strong>
      。
     </li>
     <li>
      <code>
       -d ' '
      </code>
      ：
      <ul>
       <li>
        <code>
         -d
        </code>
        选项用于
        <strong>
         指定列之间的分隔符
        </strong>
        。
       </li>
       <li>
        <code>
         ' '
        </code>
        代表
        <strong>
         用空格作为分隔符
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <code>
       users.txt date.txt
      </code>
      ：
      <ul>
       <li>
        把
        <code>
         users.txt
        </code>
        和
        <code>
         date.txt
        </code>
        按行合并。
       </li>
       <li>
        <code>
         users.txt
        </code>
        的每一行（用户名）和
        <code>
         date.txt
        </code>
        的每一行（日期）合并。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      示例：
     </strong>
     假设：
    </p>
    <ul>
     <li>
      <code>
       users.txt
      </code>
      :
      <pre><code>root bin daemon</code></pre>
     </li>
     <li>
      <code>
       date.txt
      </code>
      :
      <pre><code>2024-05-30 2024-05-30 2024-05-30</code></pre>
     </li>
    </ul>
    <p>
     执行
     <code>
      paste -d ' ' users.txt date.txt
     </code>
     后的输出：
    </p>
    <pre><code>root 2024-05-30 bin 2024-05-30 daemon 2024-05-30 ...</code></pre>
    <p>
     👉
     <strong>
      这一行的作用
     </strong>
     ：
     <strong>
      把用户名和当前日期拼接在一起
     </strong>
     ，形成
     <strong>
      用户登录记录格式
     </strong>
     。
    </p>
    <hr/>
    <h4>
     <strong>
      4. 注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        行数不一致
       </strong>
       ：
       <br/>
       若文件行数不同，
       <code>
        paste
       </code>
       会保留所有行，缺失数据的位置留空。
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认分隔符
       </strong>
       ：
       <br/>
       默认用
       <strong>
        制表符（Tab）
       </strong>
       分隔列，可用
       <code>
        -d
       </code>
       指定其他符号（如
       <code>
        ,
       </code>
       <code>
        :
       </code>
       <code>
        |
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        输入来源
       </strong>
       ：
       <br/>
       可合并文件，也可直接处理命令输出（通过管道）：
      </p>
      <pre><code>ls | paste -d ',' - - -  # 将文件列表按3列排版
file1.txt,file2.txt,file3.txt
image.jpg,document.pdf,music.mp3</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <p>
     <code>
      paste
     </code>
     就像
     <strong>
      “数据双面胶”
     </strong>
     —— 轻松将多个文件或文本流并排粘合，快速生成表格化数据！ 📄📄➡️📊
    </p>
    <h2 id="tr-command">
     排序
    </h2>
    <p>
     我们可以用
     <strong>
      “图书管理员整理书架”
     </strong>
     的比喻来理解
     <code>
      sort
     </code>
     命令，让你像整理书籍一样轻松排序文本内容：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 核心功能 —— 灵活排序
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        场景
       </th>
       <th>
        比喻
       </th>
       <th>
        <code>
         sort
        </code>
        的作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         字母排序
        </strong>
       </td>
       <td>
        按书名首字母排列书籍
       </td>
       <td>
        将文本按字典顺序排列
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数字排序
        </strong>
       </td>
       <td>
        按书籍出版年份排序
       </td>
       <td>
        识别数字并按大小排序（需加
        <code>
         -n
        </code>
        ）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         倒序排列
        </strong>
       </td>
       <td>
        从Z到A排列书名
       </td>
       <td>
        用
        <code>
         -r
        </code>
        反向排序
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         混合排序
        </strong>
       </td>
       <td>
        先按分类再按年份排序
       </td>
       <td>
        多条件排序（如
        <code>
         -k2,2n
        </code>
        按第二列数字排序）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 基础用法演示
     </strong>
    </h4>
    <h5>
     <strong>
      场景1：简单整理单词表
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 原始文件 words.txt
cat words.txt
apple
Banana
cherry
date

# 默认按字母排序（注意大写优先）
sort words.txt
Banana
apple
cherry
date</code></pre>
    <h5>
     <strong>
      场景2：处理数字（如成绩单）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 原始文件 scores.txt
cat scores.txt
张三 85
李四 92
王五 78

# 按分数从高到低排序（-n数字排序，-r倒序）
sort -k2 -nr scores.txt
李四 92
张三 85
王五 78</code></pre>
    <hr/>
    <h4>
     <strong>
      3. 高级技巧
     </strong>
    </h4>
    <h5>
     <strong>
      去重整理（类似剔除重复书籍）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 文件中有重复行
cat duplicates.txt
苹果
香蕉
苹果
橘子

# 排序并去重（-u 选项）
sort -u duplicates.txt
香蕉
橘子
苹果</code></pre>
    <h5>
     <strong>
      按月份排序（整理月度报告）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 原始文件 months.txt
cat months.txt
March
January
December
July

# 按月份顺序排序（-M 识别月份缩写）
sort -M months.txt
January
March
July
December</code></pre>
    <hr/>
    <h4>
     <strong>
      4. 保存整理结果
     </strong>
    </h4>
    <h5>
     <strong>
      重定向到新文件（不修改原文件）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 整理书籍列表并另存为新文件
sort 杂乱书单.txt &gt; 整齐书单.txt</code></pre>
    <h5>
     <strong>
      直接覆盖原文件
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 整理后替换原文件（-o 选项更安全）
sort -o 原文件.txt 原文件.txt</code></pre>
    <hr/>
    <h4>
     <strong>
      避坑指南
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        数字排序陷阱
       </strong>
       ：
       <br/>
       默认按字符排序（如100会排在2前面），
       <strong>
        必须用
        <code>
         -n
        </code>
        正确排序数字
       </strong>
       ：
      </p>
      <pre><code>sort -n numbers.txt  # 正确：1,2,10,100</code></pre>
     </li>
     <li>
      <p>
       <strong>
        跨列排序
       </strong>
       ：
       <br/>
       用
       <code>
        -k
       </code>
       指定列（如
       <code>
        -k3
       </code>
       按第三列排序），结合
       <code>
        -t
       </code>
       指定分隔符：
      </p>
      <pre><code># 按CSV文件第三列数字排序
sort -t ',' -k3n data.csv
#按数值排序，而不是按字典序。
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        处理中文排序
       </strong>
       ：
       <br/>
       默认按编码排序可能不直观，可设置本地化：
      </p>
      <pre><code>LC_ALL=C sort file.txt  # 按字节排序（快速）
LC_ALL=zh_CN.UTF-8 sort file.txt  # 按中文拼音排序（需系统支持）</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <p>
     <code>
      sort
     </code>
     就像
     <strong>
      “智能图书管理员”
     </strong>
     —— 按字母、数字、月份灵活排序，还能去重分列，让杂乱数据瞬间井然有序！ 📚🔢
    </p>
    <h2 id="tr-command" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        tr-命令
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 中的命令是用于翻译或替换字符的命令行实用程序。它从标准输入读取并写入标准输出。虽然通常用于翻译应用程序，但在 Linux 的文本处理方面具有多种功能。从替换字符列表到删除或压缩字符重复，为基于流的文本作提供了强大的工具。
       <code>
        tr
       </code>
       <code>
        tr
       </code>
       <code>
        tr
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       下面是一个基本的用法示例：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">echo 'hello' | tr 'a-z' 'A-Z'</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此示例中，用于将小写 'hello' 转换为大写 'HELLO'。它是 Linux 环境中文本处理任务的必备工具。
       <code>
        tr
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      tr
     </code>
     是 Linux 中一个简单但强大的文本处理工具，它的核心功能是
     <strong>
      对字符进行替换、删除或压缩
     </strong>
     。你可以把它想象成一个“字符魔术师”——你告诉它要改什么、删什么，它就能快速处理文本中的字符。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一段文字，比如
     <code>
      hello
     </code>
     ，想对它做一些修改：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        替换字符
       </strong>
       ：把小写字母全部变成大写（
       <code>
        hello
       </code>
       →
       <code>
        HELLO
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        删除字符
       </strong>
       ：删掉所有数字（
       <code>
        h3ll0
       </code>
       →
       <code>
        hll
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        压缩重复字符
       </strong>
       ：把连续的空格变成单个空格（
       <code>
        Hello   World
       </code>
       →
       <code>
        Hello World
       </code>
       ）。
      </p>
     </li>
    </ol>
    <p>
     这些操作都可以用
     <code>
      tr
     </code>
     一行命令搞定！
    </p>
    <hr/>
    <h4>
     <strong>
      具体功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      替换字符
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        tr '原字符' '新字符'
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        例子
       </strong>
       ：
      </p>
      <p>
      </p>
     </li>
    </ul>
    <pre><code>echo "hello" | tr 'a-z' 'A-Z'  # 小写转大写 → HELLO
echo "abc" | tr 'abc' '123'    # 替换字符 → 123</code></pre>
    <h5>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        tr -d '要删除的字符'
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        例子
       </strong>
       ：
      </p>
      <pre><code>echo "h3ll0" | tr -d '0-9'  # 删除所有数字 → hll
echo "Hello!" | tr -d '!'    # 删除感叹号 → Hello</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      压缩重复字符
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        tr -s '要压缩的字符'
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        例子
       </strong>
       ：
      </p>
      <pre><code>echo "Hello   World" | tr -s ' '  # 压缩连续空格 → Hello World
echo "woooow" | tr -s 'o'        # 压缩重复的 o → wow</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        替换
       </strong>
       ：就像把一篇英文文章里的所有逗号换成句号。
      </p>
     </li>
     <li>
      <p>
       <strong>
        删除
       </strong>
       ：像用橡皮擦掉文本中所有数字。
      </p>
     </li>
     <li>
      <p>
       <strong>
        压缩
       </strong>
       ：把“我我我我要要要吃饭”压缩成“我要吃饭”。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <code>
        tr
       </code>
       <strong>
        只能处理字符
       </strong>
       ，不能直接操作文件，所以通常结合管道符
       <code>
        |
       </code>
       或输入重定向使用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持范围
       </strong>
       ：比如
       <code>
        a-z
       </code>
       表示所有小写字母，
       <code>
        0-9
       </code>
       表示所有数字。
      </p>
     </li>
     <li>
      <p>
       <strong>
        经典用途
       </strong>
       ：处理日志、格式化文本、数据清洗等。
      </p>
     </li>
    </ul>
    <p>
     试试这个命令，感受它的便捷吧！
    </p>
    <pre><code>echo "Test 123 Text" | tr -d '0-9' | tr 'a-z' 'A-Z'
# 输出：TEST  TEXT（删掉数字并转大写）</code></pre>
    <h2 id="head-command" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        head 命令
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 中的命令是一个文本处理实用程序，允许用户输出文件的第一部分（或“头”）。它通常用于预览文件的开头，而无需将整个文档加载到内存中，这可以作为快速检查非常大文件中的数据的有效方法。默认情况下，该命令将每个文件的前 10 行打印到标准输出，这是大多数系统中的终端。
       <code>
        head
       </code>
       <code>
        head
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">head file.txt</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       可以使用选项自定义输出行数。例如，要显示前 5 行，我们使用 option 后跟行数：
       <code>
        -n
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">head -n 5 file.txt</code></pre>
    <p>
    </p>
    <p>
     我们可以用
     <strong>
      “快速翻阅书的前几页”
     </strong>
     的比喻来理解
     <code>
      head
     </code>
     命令，让你像浏览书籍目录一样快速预览文件内容：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 核心功能 —— 预览文件开头
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        场景
       </th>
       <th>
        比喻
       </th>
       <th>
        <code>
         head
        </code>
        的作用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         日志预览
        </strong>
       </td>
       <td>
        只看日记的前几篇
       </td>
       <td>
        查看日志文件的前10行（默认）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据检查
        </strong>
       </td>
       <td>
        快速扫一眼表格的标题行
       </td>
       <td>
        确认CSV文件的列名和格式
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         大文件处理
        </strong>
       </td>
       <td>
        避免打开巨型百科全书
       </td>
       <td>
        仅加载文件开头，节省内存和时间
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      2. 基础用法演示
     </strong>
    </h4>
    <h5>
     <strong>
      默认查看前10行
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 预览系统日志的前10行（像翻开书的前10页）
head /var/log/syslog</code></pre>
    <pre></pre>
    <h5>
     <strong>
      自定义行数（比如看前3行）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 只看“用户名单.csv”的前3行（标题+2条数据）
head -n 3 用户名单.csv
姓名,年龄,城市
张三,30,北京
李四,25,上海</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      3. 高级技巧
     </strong>
    </h4>
    <h5>
     <strong>
      结合其他命令（管道操作）
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 列出当前目录文件，取前5个结果
ls -l | head -n5
总用量 16
-rw-r--r-- 1 user user  120 5月 30 10:00 笔记.txt
-rw-r--r-- 1 user user 1024 5月 30 09:30 报告.pdf
drwxr-xr-x 2 user user 4096 5月 29 15:00 图片
快速检查脚本开头</code></pre>
    <pre></pre>
    <h5>
     <strong>
      快速检查脚本开头
     </strong>
    </h5>
    <p>
    </p>
    <pre><code># 查看脚本的前2行（确认解释器路径）
head -n2 自动备份.sh
#!/bin/bash
# 这是一个自动备份脚本</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      4. 注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        只读不写
       </strong>
       ：
       <code>
        head
       </code>
       仅用于查看，
       <strong>
        不会修改原文件
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        处理二进制文件慎用
       </strong>
       ：预览二进制文件（如图片、压缩包）会显示乱码。
      </p>
     </li>
     <li>
      <p>
       <strong>
        负数行数（扩展功能）
       </strong>
       ：
       <br/>
       某些系统支持
       <code>
        -n -5
       </code>
       表示“显示除最后5行外的所有内容”（但非所有Linux版本通用）。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      对比
      <code>
       tail
      </code>
      命令
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         head
        </code>
       </strong>
       ：关注开头（书的封面和目录）
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         tail
        </code>
       </strong>
       ：关注结尾（书的结局和附录）
      </p>
     </li>
     <li>
      <p>
       <strong>
        组合使用
       </strong>
       ：
      </p>
      <pre><code># 查看文件的第11-20行（先取前20行，再取后10行）
head -n20 大文件.txt | tail -n10</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      一句话总结
     </strong>
    </h4>
    <p>
     <code>
      head
     </code>
     就像
     <strong>
      “快速翻书助手”
     </strong>
     —— 一键查看文件开头，避免淹没在数据海洋中，帮你高效锁定关键信息！ 📖👀
    </p>
    <h2 id="tail-command" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        Tail 命令
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 中的命令是用于文本处理的实用程序。从根本上说，它用于输出文件的最后一部分。该命令从标准输入或文件中读取数据，并将最后的字节、行、块、字符或字输出到标准输出（或其他文件）。默认情况下，将每个文件的最后 10 行返回到标准输出。当用户对文本文件中的最新条目（如日志文件）感兴趣时，此命令很常见。
       <code>
        tail
       </code>
       <code>
        N
       </code>
       <code>
        tail
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       以下是 tail 命令的使用示例：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">tail /var/log/syslog</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在上面的示例中，该命令将打印文件的最后 10 行。这在检查最新的系统日志条目时特别有用。
       <code>
        tail
       </code>
       <code>
        /var/log/syslog
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      tail
     </code>
     是 Linux 中一个非常实用的命令，它的核心功能是
     <strong>
      快速查看文件末尾的内容
     </strong>
     。你可以把它想象成“直接翻到书的最后几页”——不用从头开始读，直接看最新添加的部分。特别适合用来
     <strong>
      实时监控日志、检查文件更新
     </strong>
     等场景。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一个不断更新的日记（比如系统日志），里面记录了最近发生的事情。但日记太长了，你只关心
     <strong>
      今天最后写了什么
     </strong>
     。这时候：
    </p>
    <ul>
     <li>
      <p>
       <code>
        tail
       </code>
       会直接显示日记的最后几行（默认显示最后10行）。
      </p>
     </li>
     <li>
      <p>
       如果日记还在实时更新（比如每秒新增一行），
       <code>
        tail
       </code>
       甚至可以像“监控摄像头”一样，持续显示新内容。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      基本功能 &amp; 经典用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      查看文件的最后几行
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：显示文件最后10行。
      </p>
      <pre><code>tail /var/log/syslog  # 查看系统日志的最后10行</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      指定显示的行数
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -n
       </code>
       参数自定义行数（比如最后20行）：
      </p>
      <pre><code>tail -n 20 /var/log/syslog  # 显示最后20行</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      实时监控文件更新（日志追踪）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -f
       </code>
       参数实时“跟随”文件变化（按
       <code>
        Ctrl+C
       </code>
       退出）：
      </p>
      <pre><code>tail -f /var/log/syslog  # 实时显示日志的新内容</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      同时监控多个文件
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       同时跟踪多个文件的更新（显示时会标注文件名）：
      </p>
      <pre><code>tail -f /var/log/syslog /var/log/auth.log  # 监控系统日志和登录日志</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        查日志
       </strong>
       ：像查看微信聊天记录的“最新几条消息”。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实时监控
       </strong>
       ：像在直播间里，不断滚动显示观众的新评论。
      </p>
     </li>
     <li>
      <p>
       <strong>
        指定行数
       </strong>
       ：比如老师让你“背诵课文最后3句”，而不是整篇课文。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        检查最近的服务错误
       </strong>
       ：
      </p>
      <pre><code>tail -n 50 /var/log/nginx/error.log  # 看最近50条Nginx错误日志</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        实时调试程序输出
       </strong>
       ：
      </p>
      <pre><code>tail -f /path/to/your/app.log  # 实时观察程序打印的日志</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        快速验证文件是否更新
       </strong>
       ：
      </p>
      <pre><code>tail -n 1 data.csv  # 查看CSV文件的最后一行，确认新数据是否写入</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       如果文件需要权限（如系统日志），可能需要用
       <code>
        sudo
       </code>
       ：
      </p>
      <pre><code>sudo tail /var/log/syslog</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <code>
        -F
       </code>
       和
       <code>
        -f
       </code>
       的区别：
       <code>
        -F
       </code>
       更强大，即使文件被删除后重新创建（如日志轮转），它也能继续追踪。
      </p>
     </li>
     <li>
      <p>
       组合其他命令使用（比如
       <code>
        grep
       </code>
       ）：
      </p>
      <pre><code>tail -f /var/log/syslog | grep "error"  # 实时过滤出包含“error”的日志</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h2 id="join-command-in-text-processing-on-linux" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        Linux 上文本处理中的 join 命令
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       <code>
        join
       </code>
       是 Linux 中一个强大的文本处理命令。它允许你将两个文件的行合并到一个公共字段上，其工作方式类似于 SQL 中的 'Join'作。当您处理大量数据时，它特别有用。具体来说，使用两个文件中的行来形成包含以有意义的方式相关的行对的行。
       <code>
        join
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       例如，如果您有两个文件，其中包含一个项目列表，一个包含成本，另一个包含数量，则可以使用合并这两个文件，以便每个项目在同一行上具有成本和数量。
       <code>
        join
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code"># Syntax
join file1.txt file2.txt</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       请注意，只有当文件排序时，命令才能正常工作。 了解提供的所有选项和标志以在文本处理任务中有效使用至关重要。
       <code>
        join
       </code>
       <code>
        join
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
    <p>
     <code>
      join
     </code>
     是 Linux 中一个用于
     <strong>
      合并两个文件内容
     </strong>
     的命令，它的功能类似于 Excel 的
     <code>
      VLOOKUP
     </code>
     或 SQL 中的
     <code>
      JOIN
     </code>
     操作。简单来说，就是根据两个文件中
     <strong>
      共有的某一列
     </strong>
     （比如ID、名称等），把两个文件的内容“拼接到一起”。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有两个表格：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        文件1
       </strong>
       ：记录商品名称和价格
      </p>
      <pre><code>苹果 5元
香蕉 3元
橘子 4元</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        文件2
       </strong>
       ：记录商品名称和库存
      </p>
      <pre><code>苹果 100个
香蕉 200个
橘子 150个</code></pre>
      <pre></pre>
     </li>
    </ol>
    <p>
     你想把这两个文件合并成一个完整的表格：
    </p>
    <pre><code>苹果 5元 100个
香蕉 3元 200个
橘子 4元 150个</code></pre>
    <pre></pre>
    <p>
     这就是
     <code>
      join
     </code>
     的作用——根据共同的字段（这里是“商品名称”），将两个文件的数据合并到一行。
    </p>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基本合并
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        join 文件1 文件2
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        要求
       </strong>
       ：两个文件必须
       <strong>
        按共同列排序
       </strong>
       （默认以第一列为共同列）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code>join prices.txt stock.txt
# 输出：
# 苹果 5元 100个
# 香蕉 3元 200个
# 橘子 4元 150个</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      指定共同列
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       如果共同列不是第一列，可以用
       <code>
        -1
       </code>
       和
       <code>
        -2
       </code>
       指定：
      </p>
      <pre><code># 文件1的共同列是第2列，文件2的共同列是第3列
join -1 2 -2 3 file1.txt file2.txt</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      处理未匹配的行
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       默认只显示匹配成功的行，如果想保留未匹配的行：
      </p>
      <pre><code>join -a 1 file1.txt file2.txt  # 保留文件1中未匹配的行
join -a 2 file1.txt file2.txt  # 保留文件2中未匹配的行
join -a 1 -a 2 file1.txt file2.txt  # 保留所有未匹配的行</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      自定义分隔符
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       如果文件不是用空格分隔（比如用逗号），用
       <code>
        -t
       </code>
       指定：
      </p>
      <pre><code>join -t ',' file1.csv file2.csv</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        合并成绩单
       </strong>
       ：把“学生姓名+数学成绩”和“学生姓名+语文成绩”合并成一张总表。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据关联
       </strong>
       ：像网购时，把“订单号+商品ID”和“商品ID+商品名称”关联起来，显示完整信息。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        合并日志文件
       </strong>
       ：
      </p>
      <pre><code>join server1.log server2.log  # 按时间戳合并两台服务器的日志</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        关联用户信息
       </strong>
       ：
      </p>
      <pre><code># 文件1：user_id 姓名
# 文件2：user_id 邮箱
join users.txt emails.txt &gt; user_details.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        处理CSV文件
       </strong>
       ：
      </p>
      <pre><code>join -t ',' -1 1 -2 1 data1.csv data2.csv  # 合并两个CSV文件的第一列
</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        必须提前排序
       </strong>
       ：
       <br/>
       <code>
        join
       </code>
       要求两个文件按共同列排序，否则会失败！可以用
       <code>
        sort
       </code>
       命令先排序：
      </p>
      <pre><code>sort file1.txt &gt; file1_sorted.txt
sort file2.txt &gt; file2_sorted.txt
join file1_sorted.txt file2_sorted.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         共同列默认是第一列。
        </p>
       </li>
       <li>
        <p>
         默认输出格式：共同列 + 文件1的剩余列 + 文件2的剩余列。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        局限性
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果两个文件有重复的共同列，结果可能不符合预期。
        </p>
       </li>
       <li>
        <p>
         复杂合并需求（如多列关联）可能需要结合
         <code>
          awk
         </code>
         或
         <code>
          paste
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       如果不确定文件是否排序，先用
       <code>
        sort
       </code>
       处理。
      </p>
     </li>
     <li>
      <p>
       用
       <code>
        -v 1
       </code>
       或
       <code>
        -v 2
       </code>
       可以
       <strong>
        只显示未匹配的行
       </strong>
       （反向检查）。
      </p>
     </li>
     <li>
      <p>
       结合
       <code>
        cut
       </code>
       、
       <code>
        awk
       </code>
       等命令，可以进一步处理合并后的输出。
      </p>
     </li>
    </ul>
    <p>
     试试这个完整流程：
    </p>
    <pre><code># 准备文件
echo -e "苹果 5元\n香蕉 3元\n橘子 4元" &gt; prices.txt
echo -e "苹果 100个\n香蕉 200个\n橘子 150个" &gt; stock.txt

# 排序文件（如果未排序）
sort prices.txt &gt; prices_sorted.txt
sort stock.txt &gt; stock_sorted.txt

# 合并文件
join prices_sorted.txt stock_sorted.txt
# 输出：
# 苹果 5元 100个
# 香蕉 3元 200个
# 橘子 4元 150个</code></pre>
    <pre></pre>
    <p>
    </p>
    <h2 id="linux-text-processing-split-command" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        Linux 文本处理：Split 命令
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 提供了一组广泛的工具来作文本数据。顾名思义，其中一种实用程序是用于将大文件拆分为较小文件的命令。Linux 中的命令根据用户指定的行或字节将文件分成多个相等的部分。
       <code>
        split
       </code>
       <code>
        split
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       这是一个有用的命令，因为它具有实际适用性。例如，如果您有一个大型数据文件，由于其大小而无法有效使用，则可以使用 split 命令将文件分解为更易于管理的部分。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       该命令的基本语法是：
       <code>
        split
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">split [options] [input [prefix]]</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       默认情况下，该命令将文件划分为多个较小的文件，每个文件 1000 行。如果未提供 input 文件，或者如果它作为 - 给出，则它会从标准输入中读取。
       <code>
        split
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       例如，要将名为 'bigfile.txt' 的文件拆分为每个 500 行的文件，命令为：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">split -l 500 bigfile.txt </code></pre>
    <p>
    </p>
    <p>
     <code>
      split
     </code>
     是 Linux 中一个非常实用的文件分割工具，它的作用就像
     <strong>
      把一本厚书拆分成多个小册子
     </strong>
     。当你有一个超大文件（比如日志、数据集），直接打开或传输很不方便时，
     <code>
      split
     </code>
     能快速将它切成多个小文件，每个小文件按顺序编号，方便后续处理。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一个 3000 页的小说（文件），想分成 3 本 1000 页的小册子：
    </p>
    <ul>
     <li>
      <p>
       <code>
        split
       </code>
       会自动将文件按指定大小（比如每 1000 行或 100MB）切割。
      </p>
     </li>
     <li>
      <p>
       切割后的文件会按顺序命名为
       <code>
        xaa
       </code>
       、
       <code>
        xab
       </code>
       、
       <code>
        xac
       </code>
       （类似“分册1、分册2、分册3”）。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      按行数分割
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        split -l 行数 大文件 输出文件名前缀
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code>split -l 500 bigfile.txt  # 将 bigfile.txt 按每500行切割，生成 xaa、xab...
split -l 1000 access.log log_part_  # 自定义前缀为 log_part_，生成 log_part_aa、log_part_ab...</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      按文件大小分割
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        split -b 大小 大文件 输出文件名前缀
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code>split -b 100M video.mp4  # 将视频文件按每100MB切割
split -b 1G data.tar.gz  # 按每1GB切割大压缩包</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      合并分割后的文件
     </strong>
    </h5>
    <p>
     切割后的文件可以随时用
     <code>
      cat
     </code>
     合并还原：
    </p>
    <pre><code>cat xaa xab xac &gt; original_bigfile.txt  # 按顺序拼接所有分块
</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        分割日志
       </strong>
       ：像把一年的日记按月份拆分成12个文件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        传输大文件
       </strong>
       ：像把一部电影分成多个小文件，方便用U盘分次拷贝。
      </p>
     </li>
     <li>
      <p>
       <strong>
        并行处理
       </strong>
       ：像把任务清单拆成多份，分给不同人同时处理。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        分割日志文件
       </strong>
       ：
      </p>
      <pre><code>split -l 5000 server.log  # 将日志按每5000行切割，用于分批分析</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        切割大压缩包
       </strong>
       （方便上传下载）：
      </p>
      <pre><code>split -b 500M huge_backup.zip  # 按500MB切割，生成 xaa、xab...</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        处理CSV数据集
       </strong>
       ：
      </p>
      <pre><code>split -l 10000 data.csv data_part_  # 按每1万行切割，生成 data_part_aa、data_part_ab...</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         不指定前缀时，输出文件名为
         <code>
          xaa
         </code>
         、
         <code>
          xab
         </code>
         、
         <code>
          xac
         </code>
         ...（按字母顺序）。
        </p>
       </li>
       <li>
        <p>
         默认按
         <strong>
          行数
         </strong>
         切割（每1000行），或按
         <strong>
          字节数
         </strong>
         切割（如果用了
         <code>
          -b
         </code>
         ）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        按大小分割时的单位
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          -b 100K
         </code>
         表示 100KB，
         <code>
          -b 1M
         </code>
         表示 1MB，
         <code>
          -b 2G
         </code>
         表示 2GB。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        二进制文件 vs 文本文件
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         切割文本文件建议用
         <code>
          -l
         </code>
         （按行），避免切断一行内容。
        </p>
       </li>
       <li>
        <p>
         切割二进制文件（如图片、压缩包）必须用
         <code>
          -b
         </code>
         （按字节）。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       用
       <code>
        --verbose
       </code>
       可以看到分割过程的实时反馈。
      </p>
     </li>
     <li>
      <p>
       合并文件时，
       <strong>
        必须按字母顺序拼接
       </strong>
       （如
       <code>
        xaa xab xac
       </code>
       ），否则内容会错乱。
      </p>
     </li>
     <li>
      <p>
       结合
       <code>
        split
       </code>
       和
       <code>
        cat
       </code>
       ，可以轻松实现“分卷压缩”功能。
      </p>
     </li>
    </ul>
    <p>
     试试这个完整示例：
    </p>
    <pre><code># 创建一个示例文件（共6行）
echo -e "Line1\nLine2\nLine3\nLine4\nLine5\nLine6" &gt; demo.txt

# 按每2行切割，自定义前缀为 part_
split -l 2 demo.txt part_

# 查看分割结果
ls part_*  # 输出 part_aa part_ab part_ac
cat part_aa  # 输出 Line1 Line2
cat part_ab  # 输出 Line3 Line4
cat part_ac  # 输出 Line5 Line6

# 合并还原
cat part_aa part_ab part_ac &gt; restored.txt</code></pre>
    <pre></pre>
    <h2 id="pipe-commands" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        管道命令
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       管道 （） 是 Linux 中的一项强大功能，用于将两个或多个命令连接在一起。此机制允许将一个命令的输出作为输入“管道”到另一个命令。关于文本处理，使用 pipe 特别有用，因为它允许您作、分析和转换文本数据，而无需创建中间文件或程序。
       <code>
        |
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       下面是一个简单的示例，通过管道输入两个命令和 ， 以列出当前目录中的所有文本文件：
       <code>
        ls
       </code>
       <code>
        grep
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">ls | grep '\.txt$'</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此示例中，列出当前目录中的文件，并筛选掉任何不以 .管道命令 获取 的输出并将其用作 的输入 。整个命令的输出是当前目录中的文本文件列表。
       <code>
        ls
       </code>
       <code>
        grep '\.txt$'
       </code>
       <code>
        .txt
       </code>
       <code>
        |
       </code>
       <code>
        ls
       </code>
       <code>
        grep '\.txt$'
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      管道（|）
     </code>
     是 Linux 中一个神奇的“连接器”，它的作用就像
     <strong>
      流水线上的传送带
     </strong>
     ——把前一个命令的输出，直接传给后一个命令作为输入。这样一来，多个命令可以串联起来，像工厂流水线一样协作处理数据，
     <strong>
      无需手动保存中间结果
     </strong>
     ，效率极高！
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你想把一堆苹果加工成苹果汁：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        第一步
       </strong>
       ：清洗苹果（对应命令
       <code>
        清洗
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        第二步
       </strong>
       ：榨汁（对应命令
       <code>
        榨汁
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        第三步
       </strong>
       ：装瓶（对应命令
       <code>
        装瓶
       </code>
       ）。
      </p>
     </li>
    </ol>
    <p>
     用管道符
     <code>
      |
     </code>
     连接这些步骤，就像把三个机器用传送带连起来：
    </p>
    <pre><code>清洗苹果 | 榨汁 | 装瓶</code></pre>
    <pre></pre>
    <p>
     最终直接得到瓶装苹果汁，中间不需要手动搬运半成品！
    </p>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基础使用
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        命令A | 命令B
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：将命令A的输出，直接传给命令B处理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code>ls | grep '.txt$'     # 列出当前目录下的所有txt文件
cat log.txt | wc -l   # 统计log.txt文件的行数</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      多级管道
     </strong>
    </h5>
    <p>
     可以串联多个命令，形成复杂处理流程：
    </p>
    <pre><code>cat log.txt | grep "error" | sort | uniq -c
# 分解步骤：
# 1. 读取文件 → 2. 过滤含"error"的行 → 3. 排序 → 4. 统计重复次数</code></pre>
    <pre></pre>
    <h5>
     3️⃣
     <strong>
      实时监控
     </strong>
    </h5>
    <p>
     结合
     <code>
      tail -f
     </code>
     实时处理动态更新的文件（如日志）：
    </p>
    <pre><code>tail -f /var/log/syslog | grep "fail"
# 实时监控系统日志，只显示包含“fail”的行</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        筛选文件
       </strong>
       ：像用筛子过滤沙子，只保留符合条件的小颗粒。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据流水线
       </strong>
       ：像快递分拣系统，包裹（数据）经过扫描、分类、打包等多个环节。
      </p>
     </li>
     <li>
      <p>
       <strong>
        实时报警
       </strong>
       ：像监控摄像头检测到异常时，自动触发警报。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <p>
    </p>
    <p>
     💡
     <strong>
      示例
     </strong>
    </p>
    <pre></pre>
    <p>
     sh
    </p>
    <p>
     复制编辑
    </p>
    <p>
     <code>
      find . -name "*.py"
     </code>
    </p>
    <p>
     🌟
     <strong>
      可能的输出
     </strong>
    </p>
    <pre></pre>
    <p>
     bash
    </p>
    <p>
     复制编辑
    </p>
    <p>
     <code>
      ./main.py ./src/utils.py ./tests/test.py
     </code>
    </p>
    <hr/>
    <h3>
     <strong>
      2️⃣
      <code>
       |
      </code>
      （管道）
     </strong>
    </h3>
    <p>
     <strong>
      管道
      <code>
       |
      </code>
      把前一个命令的输出，作为下一个命令的输入。
     </strong>
    </p>
    <p>
    </p>
    <hr/>
    <h3>
     <strong>
      3️⃣
      <code>
       xargs wc -l
      </code>
     </strong>
    </h3>
    <p>
     📌
     <strong>
      <code>
       xargs
      </code>
      作用
     </strong>
     ：把前面
     <code>
      find
     </code>
     的输出（文件列表）当作参数传递给
     <code>
      wc -l
     </code>
     。
    </p>
    <p>
     📌
     <strong>
      <code>
       wc -l
      </code>
      作用
     </strong>
     ：统计文件的
     <strong>
      行数
     </strong>
     （
     <code>
      -l
     </code>
     代表
     <code>
      line count
     </code>
     ）。
    </p>
    <p>
     💡
     <strong>
      示例
     </strong>
    </p>
    <pre></pre>
    <p>
     sh
    </p>
    <p>
     复制编辑
    </p>
    <p>
     <code>
      wc -l main.py src/utils.py tests/test.py
     </code>
    </p>
    <p>
     🌟
     <strong>
      可能的输出
     </strong>
    </p>
    <pre></pre>
    <p>
     bash
    </p>
    <p>
     复制编辑
    </p>
    <p>
     <code>
      120 main.py 80 src/utils.py 60 tests/test.py 260 total
     </code>
    </p>
    <p>
    </p>
    <h2>
     <strong>
      🔹 可能的问题 &amp; 解决方案
     </strong>
    </h2>
    <p>
     ❌
     <strong>
      问题：文件名包含空格或特殊字符
     </strong>
    </p>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      🎯 你学到了什么？
     </strong>
    </h4>
    <p>
    </p>
    <hr/>
    <h2>
     <strong>
      🔹 总结
     </strong>
    </h2>
    <pre></pre>
    <p>
     sh
    </p>
    <p>
     复制编辑
    </p>
    <p>
     <code>
      find . -name "*.py" | xargs wc -l
     </code>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        部分
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         find . -name "*.py"
        </code>
       </td>
       <td>
        查找当前目录及子目录下所有 Python 文件
       </td>
      </tr>
      <tr>
       <td>
        `
       </td>
       <td>
        `
       </td>
      </tr>
      <tr>
       <td>
        <code>
         xargs wc -l
        </code>
       </td>
       <td>
        统计所有 Python 文件的行数
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <ol>
     <li>
      <p>
       <strong>
        查找特定进程
       </strong>
       ：
      </p>
      <pre><code>ps aux | grep nginx  # 查找所有与nginx相关的进程</code></pre>
      <pre></pre>
      <p>
       <strong>
        统计代码行数
       </strong>
       ：
      </p>
      <pre><code>find . -name "*.py" | xargs wc -l  # 统计当前目录下所有Python文件的总行数</code></pre>
      <h2>
       <strong>
        🔹 逐部分解析
       </strong>
      </h2>
      <h5>
      </h5>
      <pre><code class="hljs">find . -name "*.py"
📌 find 命令用于查找文件，这里的参数是：
. 👉 在 当前目录（以及所有子目录）中查找-name "*.py" 👉 文件名匹配 .py 结尾（即所有 Python 文件）

这里 find 命令的输出是一系列 .py 文件路径，
xargs 负责把这些路径传递给 wc -l 进行行数统计。
120 main.py 👉 main.py 里有 120 行
80 src/utils.py 👉 src/utils.py 里有 80 行
60 tests/test.py 👉 tests/test.py 里有 60 行
260 total 👉 所有 Python 文件的总行数
问题：xargs 默认按空格分割，遇到文件名有空格时可能会出错。</code></pre>
      <p>
      </p>
     </li>
     <li>
      <strong>
       解决方案
      </strong>
      ：用
      <code>
       find
      </code>
      的
      <code>
       -print0
      </code>
      和
      <code>
       xargs -0
      </code>
      组合，避免分割错误：
     </li>
     <li>
      <p>
      </p>
      <pre><code class="hljs">find . -name "*.py" -print0 | xargs -0 wc -l

-print0 让 find 以 NULL 分隔符 输出文件名，xargs -0 让 xargs 以 NULL 读取文件名。</code></pre>
      <p>
      </p>
      <pre><code class="hljs">find 可以递归查找文件。
|（管道） 可以连接命令，让前一个命令的输出成为下一个命令的输入。
xargs 用于构造命令参数。
wc -l 统计行数，-l 代表 line count。
find . -name "*.py" | xargs wc -l 用于 统计所有 Python 文件的行数。
避免空格问题 用 find . -name "*.py" -print0 | xargs -0 wc -l。</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       <strong>
        批量重命名文件
       </strong>
       ：
      </p>
      <pre><code>ls *.jpg | sed 's/^/mv &amp; &amp;_backup/' | sh  # 给所有jpg文件添加_backup后缀</code></pre>
     </li>
    </ol>
    <p>
    </p>
    <h4>
     <strong>
      <code>
       sed 's/^/mv &amp; &amp;_backup/'
      </code>
     </strong>
    </h4>
    <p>
     📌
     <strong>
      <code>
       sed
      </code>
      （流编辑器）用于修改文本
     </strong>
     ，这里的
     <code>
      s/^/mv &amp; &amp;_backup/
     </code>
     规则可以拆解如下：
    </p>
    <h5>
     <strong>
      🔸
      <code>
       s/^/.../
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <code>
       s/.../.../
      </code>
      👉
      <strong>
       替换（substitute）
      </strong>
     </li>
     <li>
      <code>
       ^
      </code>
      👉
      <strong>
       匹配行首
      </strong>
     </li>
     <li>
      <code>
       &amp;
      </code>
      👉
      <strong>
       表示整个匹配到的文本
      </strong>
     </li>
     <li>
      <code>
       mv &amp; &amp;_backup
      </code>
      👉
      <strong>
       在每一行的前面加上
       <code>
        mv
       </code>
       ，并在后面加上
       <code>
        _backup
       </code>
      </strong>
     </li>
    </ul>
    <p>
    </p>
    <h4>
     <strong>
      <code>
       | sh
      </code>
     </strong>
    </h4>
    <p>
     📌
     <strong>
      <code>
       sh
      </code>
      让
      <code>
       sed
      </code>
      生成的命令执行
     </strong>
     。
    </p>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        管道是单向的
       </strong>
       ：数据只能从左到右传递，不能逆向。
      </p>
     </li>
     <li>
      <p>
       <strong>
        只传递标准输出
       </strong>
       ：如果命令A有错误输出（如
       <code>
        stderr
       </code>
       ），需要用
       <code>
        2&gt;&amp;1
       </code>
       重定向：
      </p>
      <pre><code>commandA 2&gt;&amp;1 | commandB  # 将错误输出也传给commandB</code></pre>
     </li>
    </ol>
    <p>
     <code>
      2&gt;&amp;1
     </code>
     <strong>
      把
      <code>
       stderr
      </code>
      重定向到
      <code>
       stdout
      </code>
     </strong>
     ，这样
     <code>
      commandA
     </code>
     的所有输出都合并成
     <strong>
      标准输出
     </strong>
     。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        性能优化
       </strong>
       ：避免在管道中处理超大文件时内存溢出，可结合
       <code>
        xargs
       </code>
       分块处理。
      </p>
     </li>
    </ol>
    <p>
    </p>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       管道符
       <code>
        |
       </code>
       在键盘上的位置通常是
       <code>
        Shift+\
       </code>
       （反斜杠键）。
      </p>
     </li>
     <li>
      <p>
       结合
       <code>
        &gt;
       </code>
       或
       <code>
        &gt;&gt;
       </code>
       可以将最终结果保存到文件：
      </p>
      <pre><code class="hljs">ls | grep '.txt$' &gt; txt_files.txt  # 将结果保存到txt_files.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       管道是 Linux 哲学“
       <strong>
        一个命令只做一件事，并做好
       </strong>
       ”的完美体现，灵活组合小命令，能解决复杂问题！
      </p>
     </li>
    </ul>
    <p>
     试试这个命令，感受管道的魅力吧！
    </p>
    <pre><code class="hljs">curl https://example.com | grep "title" | sed 's/&lt;[^&gt;]*&gt;//g'
# 分解步骤：
# 1. 下载网页 → 2. 过滤出标题行 → 3. 去掉HTML标签</code></pre>
    <p>
    </p>
    <pre><code class="hljs"> sed 's/&lt;[^&gt;]*&gt;//g'
📌 作用：使用 sed 删除 HTML 标签，保留纯文本。

🔍 解析 s/&lt;[^&gt;]*&gt;//g

s/.../.../g：替换模式
s：表示替换
/：分隔符
&lt;[^&gt;]*&gt;：匹配HTML 标签
&lt;：匹配开头的 &lt;
[^&gt;]*：匹配任意字符（除 &gt; 之外的）
&gt;：匹配结尾的 &gt;
//：替换为空（删除匹配内容）
g：全局替换</code></pre>
    <ul>
     <li>
      <ul>
       <li>
       </li>
      </ul>
     </li>
    </ul>
    <pre></pre>
    <h2 id="tee-in-text-processing" style="margin-left:0.625rem; margin-right:0px; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        文本处理中的 T 形
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       <code>
        tee
       </code>
       是 Linux 系统中广泛使用的命令，属于文本处理工具的范畴。它执行双重功能：命令从标准输入读取并写入标准输出和文件。此作的名称来源于管道中的 T 型分流器，它将水流分成两个方向，与命令的功能平行。
       <code>
        tee
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 中文本处理的基本语法是：
       <code>
        tee
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">command | tee file</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此构造中，'command' 表示从中读取输出的命令，而 'file' 表示写入输出的文件。对于想要记录其终端业务的用户来说，这是一个非常有用的命令，因为它既可以在终端中查看结果，也可以同时将输出存储在文件中。
       <code>
        tee
       </code>
       <code>
        tee
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      tee
     </code>
     是 Linux 中一个非常实用的“
     <strong>
      分流器
     </strong>
     ”命令，它的核心功能是
     <strong>
      同时将数据送到两个地方
     </strong>
     ：既在终端显示结果，又将结果保存到文件。就像现实中的“三通水管”——水流（数据）进来后，分叉流向两个方向。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你正在给朋友讲电话，同时想录音备份对话：
    </p>
    <ul>
     <li>
      <p>
       你的耳朵听到声音（类似终端显示输出）。
      </p>
     </li>
     <li>
      <p>
       录音设备同时保存声音到文件（类似写入文件）。
      </p>
     </li>
     <li>
      <p>
       <code>
        tee
       </code>
       就是那个“电话录音器”，让你
       <strong>
        边听边录
       </strong>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基础使用：显示并保存输出
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        命令 | tee 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：将命令的输出
       <strong>
        同时显示在屏幕
       </strong>
       并
       <strong>
        保存到文件
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">ls -l | tee file_list.txt  # 列出文件详情，同时保存到 file_list.txt
ping google.com | tee ping.log  # 测试网络连通性，实时查看并记录日志</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      追加内容到文件（不覆盖）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       默认会覆盖文件，用
       <code>
        -a
       </code>
       参数追加内容：
      </p>
      <pre><code class="hljs">echo "新内容" | tee -a log.txt  # 在 log.txt 末尾追加，而不是覆盖</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      同时处理多个管道
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <code>
        tee
       </code>
       可以连接多个后续命令：
      </p>
      <pre><code class="hljs">ls | tee files.txt | grep '.txt'  # 保存所有文件列表到 files.txt，同时过滤出 txt 文件</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      分割输出到多个文件
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       一次性保存到多个文件：
      </p>
      <pre><code class="hljs">echo "重要数据" | tee file1.txt file2.txt  # 同时写入 file1 和 file2</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        备份对话
       </strong>
       ：像开会时一边听讲，一边记笔记。
      </p>
     </li>
     <li>
      <p>
       <strong>
        监控并记录
       </strong>
       ：像工厂流水线上，摄像头同时监控画面和存储录像。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据分发
       </strong>
       ：像快递中心将包裹同时发往两个不同的目的地。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        调试脚本并保存日志
       </strong>
       ：
      </p>
      <pre><code class="hljs">./run_script.sh | tee script.log  # 实时查看脚本输出，同时记录到文件</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        安装软件时查看进度并保存信息
       </strong>
       ：
      </p>
      <pre><code class="hljs">sudo apt install nginx | tee install.log  # 安装过程实时显示，日志保存到 install.log</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        同时处理和分析数据
       </strong>
       ：
      </p>
      <pre><code class="hljs">cat data.csv | tee raw_data.csv | awk '{print $1}' &gt; column1.txt  # 保存原始数据，并提取第一列</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        覆盖风险
       </strong>
       ：默认会覆盖目标文件，谨慎操作（必要时用
       <code>
        -a
       </code>
       追加）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        权限问题
       </strong>
       ：若写入受保护的文件（如系统日志），需结合
       <code>
        sudo
       </code>
       ：
      </p>
      <pre><code class="hljs">echo "配置更新" | sudo tee /etc/config  # 用 sudo 提升写入权限</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        二进制文件慎用
       </strong>
       ：
       <code>
        tee
       </code>
       适合处理文本，处理二进制文件（如图片）可能损坏数据。
      </p>
     </li>
    </ol>
    <hr/>
    <h4 style="background-color:transparent">
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       结合
       <code>
        tee
       </code>
       和
       <code>
        grep
       </code>
       可以实时过滤并保存日志：
      </p>
      <pre><code class="hljs">tail -f /var/log/syslog | tee full.log | grep "error"  # 保存完整日志，同时只显示错误信息</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       用
       <code>
        tee
       </code>
       备份管道数据：
      </p>
      <pre><code class="hljs">tar czvf - my_folder | tee backup.tar.gz | md5sum &gt; checksum.txt  # 压缩文件夹并生成校验码</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       若想完全静默保存（不显示在终端），可以重定向到
       <code>
        /dev/null
       </code>
       ：
      </p>
      <pre><code class="hljs">ls | tee files.txt &gt; /dev/null  # 保存到文件，但不显示在屏幕</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个例子，感受
     <code>
      tee
     </code>
     的便捷：
    </p>
    <pre><code class="hljs"># 生成随机数，统计数量并保存原始数据
seq 1 100 | shuf | tee random_numbers.txt | wc -l
# 输出：100（同时 random_numbers.txt 保存了乱序的1-100）</code></pre>
    <h2 id="introduction-to-nl-number-lines" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        NL （Number Lines） 简介
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       <code>
        nl
       </code>
       command 是用于对文本文件中的行进行编号的实用程序。也称为“数字线”，当您需要概述文件中某些行的位置时，它会很方便。默认情况下， nl 仅对非空行进行编号，但可以根据用户的需要修改此行为。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       它遵循如下语法：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">nl [options] [file_name]</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       如果未指定文件，将等待来自用户终端 （stdin） 的输入。其清晰易读的输出使其成为任何 Linux 用户文本处理工具包的重要组成部分。
       <code>
        nl
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      nl
     </code>
     是 Linux 中一个简单但实用的命令，专门用于
     <strong>
      给文本文件的行添加行号
     </strong>
     。你可以把它想象成“自动给书的每一页加页码”——无论是代码、日志还是普通文本，
     <code>
      nl
     </code>
     能快速标注每一行的位置，方便定位和引用。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一份待办清单：
    </p>
    <pre><code class="hljs">买菜
洗衣服
（空行）
写报告</code></pre>
    <pre></pre>
    <p>
     用
     <code>
      nl
     </code>
     处理后，会自动给非空行加上编号：
    </p>
    <pre><code class="hljs">     1  买菜
     2  洗衣服
     3  写报告</code></pre>
    <pre></pre>
    <p>
     （空行被跳过，但可以通过选项强制编号）
    </p>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基本行号标注
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        nl 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：仅对
       <strong>
        非空行
       </strong>
       编号，空行跳过。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">nl todo.txt
# 输出：
#     1  买菜
#     2  洗衣服
# 
#     3  写报告</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      强制对所有行编号（包括空行）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -b a
       </code>
       参数：
      </p>
      <pre><code class="hljs">nl -b a todo.txt
# 输出：
#     1  买菜
#     2  洗衣服
#     3  
#     4  写报告</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      自定义行号格式
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       调整行号的对齐、位数和分隔符：
      </p>
      <pre><code class="hljs">nl -n rz -w 3 -s ") " todo.txt
# 输出：
# 001) 买菜
# 002) 洗衣服
# 003) 写报告</code></pre>
      <pre></pre>
      <ul>
       <li>
        <p>
         <code>
          -n rz
         </code>
         ：右对齐，补零（如
         <code>
          001
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         <code>
          -w 3
         </code>
         ：行号占3位宽度。
        </p>
       </li>
       <li>
        <p>
         <code>
          -s ") "
         </code>
         ：行号后跟右括号和空格。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      指定起始行号
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -v
       </code>
       设置起始值：
      </p>
      <pre><code class="hljs">nl -v 10 todo.txt  # 行号从10开始
# 输出：
#    10  买菜
#    11  洗衣服
# 
#    12  写报告</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        代码调试
       </strong>
       ：像在书本侧边栏标注行号，方便快速找到错误位置。
      </p>
     </li>
     <li>
      <p>
       <strong>
        日志分析
       </strong>
       ：像给会议记录每段加序号，讨论时直接说“看第5行”。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据整理
       </strong>
       ：像给清单条目编号，避免口头沟通时混淆顺序。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        标注脚本代码行号
       </strong>
       ：
      </p>
      <pre><code class="hljs">nl myscript.sh  # 显示脚本内容并标注非空行号</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        统计文件实际内容行数
       </strong>
       ：
      </p>
      <pre><code class="hljs">nl -b a file.txt | tail -n 1  # 显示总行数（包括空行）</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        生成带序号的任务列表
       </strong>
       ：
      </p>
      <pre><code class="hljs">echo -e "Task1\n\nTask2" | nl -b a -s ". "  # 输出：
# 1. Task1
# 2. 
# 3. Task2</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        空行处理
       </strong>
       ：默认跳过空行，需用
       <code>
        -b a
       </code>
       包含空行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        输入来源
       </strong>
       ：若不指定文件，
       <code>
        nl
       </code>
       会等待键盘输入（按
       <code>
        Ctrl+D
       </code>
       结束输入）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        结合管道
       </strong>
       ：可与其他命令联用，如
       <code>
        cat file.txt | nl
       </code>
       。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       对比
       <code>
        cat -n
       </code>
       ：
       <code>
        cat -n
       </code>
       会给所有行编号（包括空行），但格式较简单；
       <code>
        nl
       </code>
       更灵活可控。
      </p>
     </li>
     <li>
      <p>
       复杂排版：用
       <code>
        -n
       </code>
       （对齐方式）、
       <code>
        -w
       </code>
       （行号宽度）、
       <code>
        -s
       </code>
       （分隔符）组合自定义格式。
      </p>
     </li>
     <li>
      <p>
       快速定位：用
       <code>
        nl
       </code>
       +
       <code>
        grep
       </code>
       快速跳转到特定行：
      </p>
      <pre><code class="hljs">nl todo.txt | grep "写报告"  # 输出：     3  写报告</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个完整示例：
    </p>
    <pre><code class="hljs"># 创建一个测试文件
echo -e "苹果\n\n香蕉\n橘子" &gt; fruits.txt

# 给所有行（包括空行）编号，格式为 "行号: 内容"
nl -b a -n ln -s ": " fruits.txt
# 输出：
# 1: 苹果
# 2: 
# 3: 香蕉
# 4: 橘子</code></pre>
    <h5>
    </h5>
    <pre><code class="hljs"> -n ln
📌 作用：行号的对齐方式设为左对齐。

💡 -n 指定行号格式：

ln（left）：左对齐
rn（right）：右对齐（默认）
rz（右对齐，补零）</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h2 id="wc---text-processing" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        WC - 文本处理
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       该命令是 Unix 或 Linux 中常用的工具，它允许用户计算文件或从标准输入管道传输的数据中的字节、字符、单词和行数。这个名字代表 'word count'，但它的作用远不止计算单词。的常见用法包括跟踪程序输出、计算代码行数等。它是分析精细和更大比例文本的宝贵工具。
       <code>
        wc
       </code>
       <code>
        wc
       </code>
       <code>
        wc
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       以下是 Linux 中的基本使用示例：
       <code>
        wc
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">wc myfile.txt</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       此命令将输出 中的行数、单词数和字符数。输出按以下顺序显示：行数、字数、字符数，后跟文件名。
       <code>
        myfile.txt
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
    <p>
     <code>
      wc
     </code>
     是 Linux 中一个简单但强大的“
     <strong>
      文本统计器
     </strong>
     ”，它的核心功能是
     <strong>
      快速统计文件的“行数、单词数、字节数”
     </strong>
     。你可以把它想象成“自动计数器”——无论是代码、日志还是普通文本，
     <code>
      wc
     </code>
     能一键告诉你这份文件有多“厚”、多“复杂”。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一篇英文作文：
    </p>
    <pre><code class="hljs">I have a cat.
It is very cute.</code></pre>
    <pre></pre>
    <p>
     用
     <code>
      wc
     </code>
     统计后，它会告诉你：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        3 行
       </strong>
       （两行文字 + 末尾空行）
      </p>
     </li>
     <li>
      <p>
       <strong>
        7 个单词
       </strong>
       （I, have, a, cat, It, is, very, cute）
      </p>
     </li>
     <li>
      <p>
       <strong>
        30 个字节
       </strong>
       （每个字母、空格、换行符都算字节）
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基本统计（行数、单词数、字节数）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        wc 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：输出
       <strong>
        行数 单词数 字节数 文件名
       </strong>
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">wc story.txt
# 输出：3  7  30 story.txt</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      指定统计类型
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        只统计行数
       </strong>
       （适合数代码行数）：
      </p>
      <pre><code class="hljs">wc -l story.txt  # 输出：3 story.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        只统计单词数
       </strong>
       （比如文章字数）：
      </p>
      <pre><code class="hljs">wc -w story.txt  # 输出：7 story.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        只统计字节数
       </strong>
       （查看文件大小）：
      </p>
      <pre><code class="hljs">wc -c story.txt  # 输出：30 story.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        统计字符数
       </strong>
       （处理多语言文本时更准确）：
      </p>
      <pre><code class="hljs">wc -m story.txt  # 输出：30 story.txt（英文和中文混合时，字节≠字符）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      统计多个文件
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       批量统计并显示总计：
      </p>
      <pre><code class="hljs">wc *.txt  # 统计所有txt文件，最后一行显示总和</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      结合管道符
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       统计其他命令的输出：
      </p>
      <pre><code class="hljs">ls | wc -l  # 统计当前目录下的文件数量
cat log.txt | grep "error" | wc -l  # 统计日志中“error”出现的次数</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        数行数
       </strong>
       ：像翻书页数总页数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数字数
       </strong>
       ：像老师检查作文是否达到 800 字要求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        算大小
       </strong>
       ：像快递员称包裹重量，判断是否超重。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        统计代码行数
       </strong>
       ：
      </p>
      <pre><code class="hljs">wc -l *.py  # 查看所有Python文件的行数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        检查日志错误次数
       </strong>
       ：
      </p>
      <pre><code class="hljs">grep "ERROR" app.log | wc -l  # 统计错误日志的行数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        计算文本字数
       </strong>
       ：
      </p>
      <pre><code class="hljs">wc -w essay.txt  # 输出文章总单词数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        查看文件大小（字节）
       </strong>
       ：
      </p>
      <pre><code class="hljs">wc -c image.jpg  # 输出图片的字节大小</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        字节 vs 字符
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         英文字符：1 字符 = 1 字节。
        </p>
       </li>
       <li>
        <p>
         中文/特殊字符：1 字符可能占 2-4 字节（如 UTF-8 编码）。
        </p>
       </li>
       <li>
        <p>
         用
         <code>
          -m
         </code>
         统计字符数更准确（如
         <code>
          wc -m 中文.txt
         </code>
         ）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        隐藏文件
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         统计文件数量时，默认不包含隐藏文件（以
         <code>
          .
         </code>
         开头的文件），需要明确指定：
        </p>
        <pre><code class="hljs">ls -a | wc -l  # 统计包括隐藏文件的数量</code></pre>
        <pre></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        空行统计
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         空行也会被计入行数（
         <code>
          -l
         </code>
         ），但不会增加单词数（
         <code>
          -w
         </code>
         ）。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       组合使用选项：
      </p>
      <pre><code class="hljs">wc -lw file.txt  # 同时统计行数和单词数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       快速查看当前目录文件数量：
      </p>
      <pre><code class="hljs">ls | wc -l  # 统计文件总数（不包括隐藏文件）</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       统计文件夹内所有文件的总行数：
      </p>
      <pre><code class="hljs">find . -name "*.js" | xargs wc -l  # 统计所有JS代码的总行数</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个例子，感受
     <code>
      wc
     </code>
     的便捷：
    </p>
    <pre><code class="hljs"># 创建一个测试文件
echo -e "Hello World\n你好，世界\n2024" &gt; test.txt

# 统计行数、单词数、字符数
wc test.txt
# 输出：3  4  25 test.txt

# 只统计字符数（注意中文占多个字节）
wc -m test.txt  # 输出：15 test.txt（"你好，世界" 占 5 个字符）</code></pre>
    <pre></pre>
    <h2 id="expand-in-text-processing" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        在文本处理中扩展
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Expand 是 Unix 和类 Unix作系统中的命令行实用程序，可将制表符转换为空格。在处理文件输出时，它可能是必不可少的工具，因为格式可能会因选项卡而受到干扰。这在使用 Linux shell 脚本时特别有用，因为 Tab 键间距在不同的系统或文本编辑器上可能不同，从而导致格式不一致。使用空格的一致缩进可以大大提高代码的可读性。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       默认情况下，该命令将制表符转换为 8 个空格。下面是一个示例用法：
       <code>
        expand
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">expand filename
</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此示例中，是要将制表符转换为空格的文件的名称。运行命令后，Tab 键转换的内容将打印为标准输出。
       <code>
        filename
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       要指定每个选项卡的空格数，可以按如下方式使用该选项：
       <code>
        -t
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">expand -t 4 filename</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此示例中，中的每个制表符将替换为 4 个空格。然后，输出将显示在控制台上。
       <code>
        filename
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
    <p>
     <code>
      expand
     </code>
     是 Linux 中一个专门用来
     <strong>
      把制表符（Tab）转换成空格
     </strong>
     的命令。你可以把它想象成“文本格式化工具”——它能解决因不同环境下 Tab 键显示不一致导致的排版混乱问题，尤其适合强迫症患者和需要严格代码格式的场景！
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一份用 Tab 缩进的代码：
    </p>
    <pre><code class="hljs">def hello():
→print("Hello")  # → 表示按了一次 Tab 键
→print("World")</code></pre>
    <pre></pre>
    <p>
     不同编辑器可能将 Tab 显示为 4 个或 8 个空格，导致代码换行错乱。用
     <code>
      expand
     </code>
     统一换成空格后：
    </p>
    <pre><code class="hljs">def hello():
    print("Hello")  # 4 个空格
    print("World")</code></pre>
    <pre></pre>
    <p>
     无论在哪里打开，缩进都整整齐齐！
    </p>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基本转换（默认替换为 8 空格）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        expand 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：将 Tab 转为 8 个空格，结果输出到屏幕（不修改原文件）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">expand code.py  # 输出转换后的内容</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      自定义空格数量
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -t
       </code>
       指定每个 Tab 替换为几个空格：
      </p>
      <pre><code class="hljs">expand -t 4 code.py  # 每个 Tab → 4 空格（Python 常用）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      处理多个文件
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       批量转换并保存结果（需配合重定向）：
      </p>
      <pre><code class="hljs">expand -t 2 file1.txt file2.txt &gt; formatted_files  # 合并转换后的内容</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      仅转换行首的 Tab
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -i
       </code>
       参数只处理行首的 Tab（保留行中的 Tab）：
      </p>
      <pre><code class="hljs">expand -i -t 4 data.txt  # 仅缩进对齐，保留行内 Tab（如表格数据）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        统一格式
       </strong>
       ：像把不同品牌的衣架换成统一样式，让衣柜整齐划一。
      </p>
     </li>
     <li>
      <p>
       <strong>
        跨平台协作
       </strong>
       ：像把不同单位的尺寸统一为厘米，避免设计图尺寸混乱。
      </p>
     </li>
     <li>
      <p>
       <strong>
        代码规范
       </strong>
       ：像严格规定“每级缩进必须用4空格”，确保团队代码风格一致。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        格式化代码缩进
       </strong>
       ：
      </p>
      <pre><code class="hljs">expand -t 4 old_code.py &gt; new_code.py  # 生成用4空格缩进的新文件</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        检查文件中的隐藏 Tab
       </strong>
       ：
      </p>
      <pre><code class="hljs">cat -A file.txt  # 显示特殊字符（^I 代表 Tab）
expand -t 4 file.txt | cat -A  # 确认所有 ^I 是否替换成了空格</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        与其他命令结合使用
       </strong>
       ：
      </p>
      <pre><code class="hljs">grep "ERROR" log.txt | expand -t 2  # 过滤错误日志并转换缩进</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        不修改原文件
       </strong>
       ：默认只输出到屏幕，需用
       <code>
        &gt;
       </code>
       重定向保存：
      </p>
      <pre><code class="hljs">expand -t 4 input.txt &gt; output.txt  # 保存转换后的内容</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        混合缩进处理
       </strong>
       ：如果文件中混合了 Tab 和空格，建议先用
       <code>
        expand
       </code>
       统一处理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        逆向操作
       </strong>
       ：如果想将空格转回 Tab，可用
       <code>
        unexpand
       </code>
       命令：
      </p>
      <pre><code class="hljs">unexpand -t 4 formatted.txt  # 将4空格转回 Tab</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       用
       <code>
        cat -T
       </code>
       可显示文件中的 Tab（显示为
       <code>
        ^I
       </code>
       ）：
      </p>
      <pre><code class="hljs">cat -T file.txt  # 找出隐藏的 Tab</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       在脚本中预格式化：
      </p>
      <pre><code class="hljs">#!/bin/bash
expand -t 4 "$1" | grep "pattern"  # 处理输入文件并搜索</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       快速测试效果：
      </p>
      <pre><code class="hljs">echo -e "→Apple\t→Banana" | expand -t 4  # 输出：    Apple    Banana</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个完整示例：
    </p>
    <pre><code class="hljs"># 创建含 Tab 的测试文件
echo -e "→水果列表：\n→苹果\n→香蕉" | sed 's/→/\t/g' &gt; fruits.txt

# 查看原始 Tab（显示为 ^I）
cat -T fruits.txt  # 输出：^I水果列表：^I^I苹果...

# 转换为 4 空格
expand -t 4 fruits.txt
# 输出：
#    水果列表：
#    苹果
#    香蕉</code></pre>
    <h2 id="unexpand-in-text-processing" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        在文本处理中展开
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       Linux 中的命令是处理文本处理时的重要工具。它主要用于将空格转换为文件中的制表符或从终端输出。此命令的工作原理是将空格替换为制表符，使文档或输出更加连贯和整洁。它主要用于设置结构的格式，尤其是在编程脚本中，其中使用 tabs 缩进是一种常见的做法。
       <code>
        unexpand
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       使用命令的示例：
       <code>
        unexpand
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">unexpand -t 4 file.txt</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       “-t 4” 开关告诉 unexpand 将 中的每四个空格替换为一个制表符。
       <code>
        file.txt
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      unexpand
     </code>
     是 Linux 中与
     <code>
      expand
     </code>
     对应的“
     <strong>
      逆向格式化工具
     </strong>
     ”——它专门
     <strong>
      把空格转换回制表符（Tab）
     </strong>
     。你可以把它想象成“文本压缩器”：将连续的空格缩成一个 Tab，让文件更紧凑，尤其适合需要节省空间或遵循 Tab 缩进规范的场景（比如某些编程风格要求必须用 Tab 缩进）。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一份用 4 个空格缩进的代码：
    </p>
    <pre><code class="hljs">def hello():
    print("Hello")  # 缩进是 4 个空格
    print("World")</code></pre>
    <pre></pre>
    <p>
     用
     <code>
      unexpand
     </code>
     处理后，4 个空格会被替换成一个 Tab（显示为
     <code>
      →
     </code>
     ）：
    </p>
    <pre><code class="hljs">def hello():
→print("Hello")  # → 表示一个 Tab
→print("World")</code></pre>
    <pre></pre>
    <p>
     这样文件体积更小，且符合 Tab 缩进规范！
    </p>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基本转换（默认仅处理行首空格）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        unexpand 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：仅将
       <strong>
        行首
       </strong>
       的连续空格转为 Tab（每个 Tab 默认替换 8 空格）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">unexpand code.py  # 转换行首空格为 Tab，输出到屏幕</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      自定义空格数量
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -t
       </code>
       指定“多少个空格换一个 Tab”：
      </p>
      <pre><code class="hljs">unexpand -t 4 code.py  # 每 4 个空格 → 1 个 Tab</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      处理所有空格（不仅是行首）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -a
       </code>
       参数转换
       <strong>
        行中所有符合条件的空格
       </strong>
       ：
      </p>
      <pre><code class="hljs">unexpand -a -t 4 data.txt  # 全文件中的 4 空格都转 Tab</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      批量处理并保存
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       转换多个文件并输出到新文件：
      </p>
      <pre><code class="hljs">unexpand -t 4 file1.py file2.py &gt; tab_indented_files  # 合并结果</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        压缩空间
       </strong>
       ：像把散装饼干重新装进密封袋，节省存储空间。
      </p>
     </li>
     <li>
      <p>
       <strong>
        统一规范
       </strong>
       ：像把不同地区的电压统一转换，适配本地电器。
      </p>
     </li>
     <li>
      <p>
       <strong>
        代码风格
       </strong>
       ：像团队规定必须用 Tab 缩进，将历史代码中的空格批量替换。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        将 Python 空格缩进转为 Tab
       </strong>
       ：
      </p>
      <pre><code class="hljs">unexpand -t 4 space_code.py &gt; tab_code.py  # 生成 Tab 缩进的新文件</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        处理混合缩进的配置文件
       </strong>
       ：
      </p>
      <pre><code class="hljs">unexpand -a -t 2 config.yml  # 将全文中每 2 个空格转 Tab</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        快速压缩日志文件
       </strong>
       ：
      </p>
      <pre><code class="hljs">unexpand -t 4 log.txt | gzip &gt; log.tar.gz  # 转换后压缩，节省空间</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        默认只处理行首
       </strong>
       ：不加
       <code>
        -a
       </code>
       时，仅转换行首空格（保留行内的空格）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不修改原文件
       </strong>
       ：默认输出到屏幕，需用
       <code>
        &gt;
       </code>
       保存结果：
      </p>
      <pre><code class="hljs">unexpand -t 4 input.txt &gt; output.txt  # 保存转换后的文件</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        混合缩进问题
       </strong>
       ：如果文件中混用 Tab 和空格，建议先用
       <code>
        expand
       </code>
       统一为空格，再用
       <code>
        unexpand
       </code>
       转换。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       用
       <code>
        cat -T
       </code>
       查看文件中的 Tab（显示为
       <code>
        ^I
       </code>
       ）：
      </p>
      <pre><code class="hljs">cat -T file.py  # 显示所有 Tab（→ 会变成 ^I）</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        逆向操作
       </strong>
       ：若想将 Tab 转回空格，用
       <code>
        expand
       </code>
       命令：
      </p>
      <pre><code class="hljs">expand -t 4 tab_file.py  # 将 Tab 转为 4 空格</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       快速测试效果：
      </p>
      <pre><code class="hljs">echo "    Hello World" | unexpand -t 4  # 输出：→Hello World</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个完整示例：
    </p>
    <pre><code class="hljs"># 创建用 4 空格缩进的测试文件
echo -e "def test():\n    print('OK')" &gt; space_code.py

# 转换为 Tab 缩进（4 空格 → 1 Tab）
unexpand -t 4 space_code.py &gt; tab_code.py

# 查看结果中的 Tab（显示为 ^I）
cat -T tab_code.py
# 输出：def test():^Iprint('OK')</code></pre>
    <pre></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
    <h2 id="uniq" style="margin-left:.625rem; margin-right:0; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        统一
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在 Linux 中，是一个非常有用的文本处理命令行程序。它通过比较或过滤掉相邻的重复行来帮助检查和作文本文件。无论您是处理数据列表还是大型文本文档，该命令都允许您查找和过滤掉重复的行，甚至提供文件中每个唯一行的计数。请务必记住，只会删除彼此相邻的重复项，因此为了充分利用此命令，通常首先使用命令对数据进行排序。
       <code>
        uniq
       </code>
       <code>
        uniq
       </code>
       <code>
        uniq
       </code>
       <code>
        sort
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       使用的示例是：
       <code>
        uniq
       </code>
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">sort names.txt | uniq</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       在此示例中， 是一个包含名称列表的文件。该命令对文件中的所有行进行排序，然后该命令删除所有重复的行。生成的输出将是 中的唯一名称列表。
       <code>
        names.txt
       </code>
       <code>
        sort
       </code>
       <code>
        uniq
       </code>
       <code>
        names.txt
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
    </p>
    <p>
     <code>
      uniq
     </code>
     是 Linux 中一个实用的“
     <strong>
      去重小助手
     </strong>
     ”，专门用于
     <strong>
      处理相邻的重复行
     </strong>
     。它的核心功能是
     <strong>
      删除连续的重复行
     </strong>
     或
     <strong>
      统计重复次数
     </strong>
     ，就像整理书架上重复的书本，让内容更简洁清晰。
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一个购物清单，不小心重复写了几次：
    </p>
    <pre><code class="hljs">苹果
苹果
香蕉
橘子
橘子
橘子</code></pre>
    <pre></pre>
    <p>
     用
     <code>
      uniq
     </code>
     处理后，相邻的重复行会被合并：
    </p>
    <pre><code class="hljs">苹果
香蕉
橘子</code></pre>
    <pre></pre>
    <p>
     （注意：如果重复行不相邻，
     <code>
      uniq
     </code>
     不会处理！需要先用
     <code>
      sort
     </code>
     排序）
    </p>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基础去重（仅处理相邻重复行）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        uniq 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：删除
       <strong>
        连续重复的行
       </strong>
       ，保留唯一一行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">uniq list.txt  # 直接去重（需确保重复行相邻）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      先排序再去重（经典组合）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       结合
       <code>
        sort
       </code>
       命令处理任意位置的重复行：
      </p>
      <pre><code class="hljs">sort shopping_list.txt | uniq  # 先排序，再去重（输出全局唯一行）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      统计重复次数
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -c
       </code>
       参数显示每行重复的次数：
      </p>
      <pre><code class="hljs">uniq -c log.txt  # 输出：
#   3 苹果
#   1 香蕉
#   2 橘子</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      仅显示重复行
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -d
       </code>
       只保留重复过的行：
      </p>
      <pre><code class="hljs">uniq -d list.txt  # 输出：苹果、橘子（香蕉不重复，被过滤）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     5️⃣
     <strong>
      忽略大小写
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -i
       </code>
       参数让大小写视为相同：
      </p>
      <pre><code class="hljs">echo -e "Apple\napple\nBanana" | uniq -i  # 输出：Apple、Banana</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        整理书单
       </strong>
       ：像把重复购买的书籍清单合并成一本。
      </p>
     </li>
     <li>
      <p>
       <strong>
        统计投票
       </strong>
       ：像计票时合并相同选项的票数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        清理日志
       </strong>
       ：像删除服务器日志中连续出现的相同错误。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        统计访问日志的独立 IP
       </strong>
       ：
      </p>
      <pre><code class="hljs">cat access.log | awk '{print $1}' | sort | uniq -c  # 统计每个IP的访问次数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        清理重复的待办事项
       </strong>
       ：
      </p>
      <pre><code class="hljs">sort todo.txt | uniq &gt; cleaned_todo.txt  # 生成去重后的清单</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        查找重复文件内容
       </strong>
       ：
      </p>
      <pre><code class="hljs">sort files.txt | uniq -d  # 找出所有重复的文件名</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        必须排序
       </strong>
       ：
       <br/>
       <code>
        uniq
       </code>
       只能处理
       <strong>
        相邻的重复行
       </strong>
       ，因此通常需要先用
       <code>
        sort
       </code>
       排序：
      </p>
      <pre><code class="hljs">sort file.txt | uniq  # 正确用法</code></pre>
      <pre></pre>
      <ul>
       <li>
        <p>
         直接
         <code>
          uniq file.txt
         </code>
         可能漏掉非相邻的重复行！
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        与
        <code>
         sort -u
        </code>
        的区别
       </strong>
       ：
       <br/>
       <code>
        sort -u
       </code>
       也能去重，但功能不同：
      </p>
      <pre><code class="hljs">sort -u file.txt      # 排序后直接去重（结果等效于 sort | uniq）
sort file.txt | uniq  # 可结合 uniq 的其他功能（如统计次数）</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        保留原顺序
       </strong>
       ：
       <br/>
       如果不想打乱原文件顺序，但要去重，需用其他方法（如
       <code>
        awk
       </code>
       ）。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       快速去重并保存：
      </p>
      <pre><code class="hljs">sort input.txt | uniq &gt; output.txt  # 经典组合</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       仅显示唯一行（不重复的行）：
      </p>
      <pre><code class="hljs">sort file.txt | uniq -u  # 找出从未重复过的行</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       处理 CSV 文件中的重复数据：
      </p>
      <pre><code class="hljs">cut -d ',' -f 1 data.csv | sort | uniq -c  # 统计第一列的重复次数</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个例子，感受
     <code>
      uniq
     </code>
     的便捷：
    </p>
    <pre><code class="hljs"># 创建一个测试文件
echo -e "苹果\n苹果\n香蕉\n橘子\n橘子\n橘子" &gt; fruits.txt

# 直接去重（因重复行相邻，有效）
uniq fruits.txt
# 输出：
# 苹果
# 香蕉
# 橘子

# 统计重复次数
uniq -c fruits.txt
# 输出：
# 2 苹果
# 1 香蕉
# 3 橘子</code></pre>
    <pre></pre>
    <h2 id="grep-in-text-processing" style="background-color:transparent; margin-left:0.625rem; margin-right:0px; text-align:start">
     <strong>
      <span style="color:var(--tw-prose-headings)">
       <span style="background-color:#ffffff">
        文本处理中的 GREP
       </span>
      </span>
     </strong>
    </h2>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       GREP（全局正则表达式打印）被认为是类 Unix作系统（包括 Linux）文本处理领域的重要工具。它是一个强大的实用程序，用于搜索和过滤与给定模式匹配的文本。当它识别到与模式匹配的行时，它会将该行打印到屏幕上，从而提供了一种在文件中查找文本的有效编码方法。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       GREP 是许多 shell 脚本、bash 命令和命令行作的重要组成部分，是每个 Linux 发行版中预装的多功能工具。它包含三个主要部分 - 格式、作和正则表达式。多年来，它已有效地用于多种编程语言和数据科学应用程序。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       以下是简单 GREP 命令的示例：
      </span>
     </span>
    </p>
    <pre class="has" style="margin-left:0; margin-right:0; text-align:start"><code class="language-astro-code">grep "pattern" fileName</code></pre>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       此命令将在文件中搜索指定的模式，并将该行打印到终端。
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       还有一个替代 - .
       <code>
        grep
       </code>
       <code>
        ripgrep
       </code>
      </span>
     </span>
    </p>
    <p style="margin-left:.5rem; margin-right:0; text-align:start">
     <span style="color:#374151">
      <span style="background-color:#ffffff">
       <code>
        ripgrep
       </code>
       是一个速度极快的文本处理器，支持并扩展了它的所有功能。
       <code>
        grep
       </code>
      </span>
     </span>
    </p>
    <p>
     <code>
      grep
     </code>
     是 Linux 中一个
     <strong>
      文本搜索神器
     </strong>
     ，它的核心功能是
     <strong>
      在文件中快速查找包含特定关键词或模式的行
     </strong>
     。你可以把它想象成“文本探测器”——无论是日志文件、代码还是文档，只要告诉它要找什么，它就能瞬间定位目标！
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一本电话簿（文件），想找所有姓“张”的人：
    </p>
    <pre><code class="hljs">张三 13800138000
李四 13912345678
张伟 13500000000</code></pre>
    <pre></pre>
    <p>
     用
     <code>
      grep
     </code>
     搜索“张”，它会立刻返回：
    </p>
    <pre><code class="hljs">张三 13800138000
张伟 13500000000</code></pre>
    <pre></pre>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基础搜索
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        grep "关键词" 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：输出包含关键词的
       <strong>
        整行内容
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">grep "error" log.txt    # 在 log.txt 中查找包含 "error" 的行
grep "TODO" code.py    # 在代码中查找所有待办标记</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      高级搜索（正则表达式）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       支持复杂模式匹配（如模糊搜索、范围匹配）：
      </p>
      <pre><code class="hljs">grep "^2024" dates.txt    # 查找以 2024 开头的行（如日期）
grep "[Aa]pple" fruits.txt  # 匹配 Apple 或 apple
grep "user[0-9]" data.txt  # 查找 user0、user1...user9</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     3️⃣
     <strong>
      常用参数
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        忽略大小写
       </strong>
       ：
       <code>
        -i
       </code>
      </p>
      <pre><code class="hljs">grep -i "apple" file.txt  # 匹配 Apple、APPLE、apple...</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        显示行号
       </strong>
       ：
       <code>
        -n
       </code>
      </p>
      <pre><code class="hljs">grep -n "bug" code.py  # 输出：行号:代码内容</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        统计匹配次数
       </strong>
       ：
       <code>
        -c
       </code>
      </p>
      <pre><code class="hljs">grep -c "success" log.txt  # 输出匹配到的行数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        递归搜索目录
       </strong>
       ：
       <code>
        -r
       </code>
      </p>
      <pre><code class="hljs">grep -r "function" ./src  # 在 src 目录下所有文件中搜索</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      反向搜索（排除匹配行）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -v
       </code>
       过滤
       <strong>
        不包含
       </strong>
       关键词的行：
      </p>
      <pre><code class="hljs">grep -v "debug" log.txt  # 输出所有不含 "debug" 的行</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        查日志
       </strong>
       ：像用 Ctrl+F 在网页中搜索关键词。
      </p>
     </li>
     <li>
      <p>
       <strong>
        找代码
       </strong>
       ：像在书里用荧光笔标记重点段落。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数据清洗
       </strong>
       ：像从一堆卡片中挑出符合要求的。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        快速定位程序崩溃原因
       </strong>
       ：
      </p>
      <pre><code class="hljs">grep -n "Exception" server.log  # 显示错误发生的行号及内容</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        统计 API 调用次数
       </strong>
       ：
      </p>
      <pre><code class="hljs">grep -c "/api/v1/login" access.log  # 统计登录接口的调用次数</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        搜索多个文件
       </strong>
       ：
      </p>
      <pre><code class="hljs">grep "deprecated" *.java  # 在所有 Java 文件中查找过时代码</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        组合其他命令
       </strong>
       ：
      </p>
      <pre><code class="hljs">ps aux | grep "nginx"     # 查找所有 nginx 进程
history | grep "ssh"      # 查找历史命令中的 ssh 记录</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        默认区分大小写
       </strong>
       ：搜索 "Error" 不会匹配 "ERROR"，需用
       <code>
        -i
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        特殊字符转义
       </strong>
       ：搜索
       <code>
        .
       </code>
       、
       <code>
        *
       </code>
       等正则符号时，需加反斜杠转义：
      </p>
      <pre><code class="hljs">grep "192\.168\.1\.1" log.txt  # 搜索 IP 地址</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        性能优化
       </strong>
       ：大文件搜索时，可用
       <code>
        fgrep
       </code>
       （固定字符串搜索，速度更快）。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       使用
       <code>
        --color=auto
       </code>
       高亮显示匹配内容（默认已启用）：
      </p>
      <pre><code class="hljs">grep "warning" log.txt --color=auto</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       结合管道符实时过滤：
      </p>
      <pre><code class="hljs">tail -f log.txt | grep "INFO"  # 实时监控并过滤日志</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       快速生成摘要：
      </p>
      <pre><code class="hljs">grep -o "user_[0-9]*" log.txt | sort | uniq -c  # 统计不同用户的出现次数</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      升级版工具：ripgrep (
      <code>
       rg
      </code>
      )
     </strong>
    </h4>
    <p>
     <code>
      ripgrep
     </code>
     是
     <code>
      grep
     </code>
     的现代替代品，速度更快、功能更强：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        默认递归搜索目录
       </strong>
       （无需
       <code>
        -r
       </code>
       参数）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自动忽略.gitignore中的文件
       </strong>
       （如排除编译产物）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        语法更简洁
       </strong>
       ：
      </p>
      <pre><code class="hljs">rg "pattern"          # 当前目录递归搜索
rg -i "error" log/    # 忽略大小写，搜索 log 目录
rg -t py "TODO"       # 仅在 Python 文件中搜索</code></pre>
      <pre></pre>
     </li>
    </ul>
    <p>
     试试这个例子，感受
     <code>
      grep
     </code>
     的高效：
    </p>
    <pre><code class="hljs"># 创建测试文件
echo -e "Apple\nbanana\nCherry\n12345" &gt; test.txt

# 搜索包含字母a的行（不区分大小写）
grep -i "a" test.txt
# 输出：
# Apple
# banana
# Cherry</code></pre>
    <pre></pre>
    <h2 id="awk---text-processing">
     awk - 文本处理
    </h2>
    <p>
     awk 是一种功能强大的文本处理语言，广泛用于类 Unix作系统，包括 Linux。awk 以其三位原始开发人员 - Alfred Aho、Peter Weinberger 和 Brian Kernighan 命名，擅长对文本文件执行作，例如排序、过滤和报告生成。
    </p>
    <p>
     该语言包含脚本中的一组命令，用于定义模式-作对。从本质上讲，awk 逐行读取输入文件，识别与脚本中指定的匹配模式，并因此对这些匹配项执行作。
    </p>
    <p>
     虽然 awk 是一种具有变量、表达式和控制结构的完整语言，但它最常用作 bash shell 脚本中的单行命令，利用其多功能的文本作功能。
    </p>
    <p>
     下面是一个如何使用 awk 打印文件每行的前两个字段的示例：
    </p>
    <pre><code>awk '{print $1,$2}' filename
</code></pre>
    <p>
     这将显示 'filename' 中每行的第一个和第二个字段 （通常用空格分隔）。
    </p>
    <p>
     <code>
      awk
     </code>
     是 Linux 中一个
     <strong>
      超级强大的文本处理工具
     </strong>
     ，它的核心功能是
     <strong>
      按列处理结构化文本
     </strong>
     （比如日志、表格数据）。你可以把它想象成“
     <strong>
      数据手术刀
     </strong>
     ”——无论是提取特定列、过滤数据，还是做统计计算，
     <code>
      awk
     </code>
     都能轻松搞定！
    </p>
    <hr/>
    <h4>
     <strong>
      通俗解释
     </strong>
    </h4>
    <p>
     假设你有一个学生成绩表（每列用空格分隔）：
    </p>
    <pre><code class="hljs">张三 90 85
李四 78 92
王五 88 76</code></pre>
    <pre></pre>
    <p>
     用
     <code>
      awk
     </code>
     可以：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        提取第一列
       </strong>
       （姓名）：
       <code>
        awk '{print $1}'
       </code>
      </p>
      <pre><code class="hljs">张三
李四
王五</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        计算每个人的总分
       </strong>
       ：
       <code>
        awk '{print $1, $2+$3}'
       </code>
      </p>
      <pre><code class="hljs">张三 175
李四 170
王五 164</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      核心功能 &amp; 用法
     </strong>
    </h4>
    <h5>
     1️⃣
     <strong>
      基础列提取
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        语法
       </strong>
       ：
       <code>
        awk '{print $列号}' 文件名
       </code>
      </p>
     </li>
     <li>
      <p>
       <strong>
        默认行为
       </strong>
       ：按
       <strong>
        空格/Tab
       </strong>
       分割列，
       <code>
        $1
       </code>
       代表第一列，
       <code>
        $0
       </code>
       代表整行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk '{print $1, $3}' data.txt  # 输出第1列和第3列
awk '{print $NF}' data.txt     # 输出最后一列（NF表示总列数）</code></pre>
      <pre></pre>
     </li>
    </ul>
    <h5>
     2️⃣
     <strong>
      指定分隔符
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       用
       <code>
        -F
       </code>
       指定列分隔符（如逗号、冒号）：
      </p>
      <p>
      </p>
     </li>
    </ul>
    <pre><code class="hljs">awk -F ',' '{print $2}' users.csv  # 按逗号分列，提取第2列
awk -F ':' '{print $1}' /etc/passwd  # 提取系统用户名称</code></pre>
    <h5>
    </h5>
    <ul>
     <li>
      <p>
       只处理符合条件的行：
      </p>
      <pre><code class="hljs">awk '$2 &gt; 80 {print $1}' scores.txt  # 输出第二列大于80的行的姓名
awk '/error/ {print}' log.txt        # 输出包含 "error" 的行</code></pre>
      <h5>
      </h5>
      <pre><code class="hljs">2️⃣ '$2 &gt; 80 {print $1}'
📌 这个部分是 awk 的脚本逻辑**，解释如下：

🔹 $2 &gt; 80：

$2 表示 第二列（假设第一列是名字，第二列是分数）。
&gt; 80 表示筛选分数大于 80 的行。
🔹 {print $1}：

{} 表示要执行的操作。
print $1 表示打印第一列（即姓名）。</code></pre>
      <p>
      </p>
     </li>
    </ul>
    <h5>
     4️⃣
     <strong>
      统计与计算
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       内置变量和计算功能：
      </p>
      <pre><code class="hljs"># 统计文件总行数
awk 'END {print NR}' data.txt  # NR 是已处理的总行数

# 计算第二列平均值
awk '{sum+=$2} END {print sum/NR}' data.txt</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      日常场景类比
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        提取数据
       </strong>
       ：像从 Excel 表格中复制特定列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        过滤信息
       </strong>
       ：像用筛子过滤出符合标准的颗粒。
      </p>
     </li>
     <li>
      <p>
       <strong>
        生成报告
       </strong>
       ：像自动汇总表格中的总和、平均值。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      常用场景示例
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        提取日志中的时间戳和错误码
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk '{print $1, $5}' access.log  # 假设第1列是时间，第5列是状态码</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        统计 CSV 文件的总销售额
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk -F ',' '{sum += $3} END {print sum}' sales.csv  # 第3列是金额</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        过滤出 CPU 使用率超过 80% 的进程
       </strong>
       ：
      </p>
      <pre><code class="hljs">ps aux | awk '$3 &gt; 80 {print $11}'  # $3是CPU%，$11是进程名</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        格式化输出
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk '{printf "姓名:%s 总分:%d\n", $1, $2+$3}' scores.txt
# 输出：
# 姓名:张三 总分:175
# 姓名:李四 总分:170</code></pre>
      <pre></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        默认分隔符是空格/Tab
       </strong>
       ：如果数据用其他符号分隔（如逗号），必须用
       <code>
        -F
       </code>
       指定。
      </p>
     </li>
     <li>
      <p>
       <strong>
        列号从1开始
       </strong>
       ：
       <code>
        $1
       </code>
       是第一列，
       <code>
        $0
       </code>
       是整行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        大小写敏感
       </strong>
       ：
       <code>
        awk
       </code>
       区分大小写，
       <code>
        Error
       </code>
       和
       <code>
        error
       </code>
       不同。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      小贴士
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        快速查看文件结构
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk '{print NF}' file.txt  # 显示每行的列数（检查是否一致）</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        批量替换文本
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk '{gsub("old","new",$2); print}' file.txt  # 将第2列的old替换为new</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        处理复杂日志
       </strong>
       ：
      </p>
      <pre><code class="hljs"># 提取时间在 "2024-01-01" 之后的错误日志
awk '/ERROR/ &amp;&amp; $1 &gt; "2024-01-01" {print}' app.log</code></pre>
      <pre></pre>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      进阶技巧
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        BEGIN 和 END 块
       </strong>
       ：
      </p>
      <pre><code class="hljs"># 在开头和结尾执行操作（如添加表头）
awk 'BEGIN {print "姓名 总分"} {print $1, $2+$3} END {print "---结束---"}' scores.txt</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        使用外部变量
       </strong>
       ：
      </p>
      <pre><code class="hljs">threshold=80
awk -v t=$threshold '$2 &gt; t {print}' data.txt  # 用变量传递阈值</code></pre>
      <pre></pre>
     </li>
     <li>
      <p>
       <strong>
        多条件组合
       </strong>
       ：
      </p>
      <pre><code class="hljs">awk '$2 &gt; 80 &amp;&amp; $3 &lt; 90 {print $1}' scores.txt  # 第二列&gt;80且第三列&lt;90的行</code></pre>
      <pre></pre>
     </li>
    </ol>
    <p>
     试试这个例子，感受
     <code>
      awk
     </code>
     的威力：
    </p>
    <pre><code class="hljs"># 创建测试文件
echo -e "苹果 5 20\n香蕉 3 15\n橘子 4 18" &gt; fruits.txt

# 计算每种水果的总价（数量*单价）
awk '{total = $2 * $3; print $1 " 总价：" total "元"}' fruits.txt
# 输出：
# 苹果 总价：100元
# 香蕉 总价：45元
# 橘子 总价：72元</code></pre>
    <pre></pre>
    <ul>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f736f6c6f6d6f6e7a772f:61727469636c652f64657461696c732f313436313135383339" class_="artid" style="display:none">
 </p>
</div>


