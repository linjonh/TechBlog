---
layout: post
title: "elasticsearch学习"
date: 2025-03-04 16:58:21 +0800
description: "Elasticsearch:分布式，RESTful风格的搜索和分析。REST：资源状态转换，路径是对资源的定位，方法是对资源的操作。GET，POST，PUT，DELETE，HEAD，get和head无论对资源操作多少次都不会改变资源的状态。get，put，delete，head都是幂等性的。安装目录：D:/software/elasticserch-7.12.0启动： 双击 安装目录/elasticserch-7.12.0/bin/elasticsearch.bat9300 ：集群间组..."
keywords: "elasticsearch学习"
categories: ['未分类']
tags: ['大数据', 'Elasticsearch', 'Data', 'Big']
artid: "122089822"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=122089822
    alt: "elasticsearch学习"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=122089822
featuredImagePreview: https://bing.ee123.net/img/rand?artid=122089822
cover: https://bing.ee123.net/img/rand?artid=122089822
image: https://bing.ee123.net/img/rand?artid=122089822
img: https://bing.ee123.net/img/rand?artid=122089822
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     elasticsearch学习
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Elasticsearch:分布式，RESTful风格的搜索和分析。REST：资源状态转换，路径是对资源的定位，方法是对资源的操作。GET，POST，PUT，DELETE，HEAD，get和head无论对资源操作多少次都不会改变资源的状态（都是对资源的获取，不同在于head返回体没有内容）。 get，put，delete，head都是幂等性的。
    </p>
    <p>
     安装目录：D:/software/elasticserch-7.12.0
    </p>
    <p>
     启动：  双击   安装目录/elasticserch-7.12.0/bin/elasticsearch.bat
    </p>
    <p>
     9300  ：集群间组件通信端口    9200 ：浏览器访问端口
    </p>
    <p>
     ES是面向文档型数据库，一条数据就是一个文档。
    </p>
    <p>
     <img alt="" height="168" src="https://i-blog.csdnimg.cn/blog_migrate/f9a4251801f9ac939f55fa5adaed919b.png" width="593"/>
    </p>
    <p>
     ES 里的Index可以看做一个库，而Types相当于表，Documents则相当于表的行。
     <br/>
     这里Types 的概念已经被逐渐弱化，Elasticsearch 6.X中，一个index下已经只能包含一个type，Elasticsearch 7.X中, Type 的概念已经被删除了。
     <br/>
     mysql使用正排（正向）索引，检索内容，以文件id关联内容；
     <br/>
     es使用倒排索引 ，以内容关联文件id；
    </p>
    <p>
     <img alt="" height="334" src="https://i-blog.csdnimg.cn/blog_migrate/d4f7cbac002d37afa0a930426dacd194.png" width="421"/>
    </p>
    <p>
     所有的分片放在一起就是一个完整的索引数据。
    </p>
    <p>
     数据
     <span style="color:#fe2c24">
      存放
     </span>
     的路由计算公式：hash（id）%主分片数量
    </p>
    <p>
     <img alt="" height="310" src="https://i-blog.csdnimg.cn/blog_migrate/e4c639e06673a78f65f8ed4fc180e3d1.png" width="649"/>
    </p>
    <p>
     数据获取：采用分片控制，用户可以访问任意一个节点获取数据，该节点称之为协调节点。
     <br/>
     道理上采用轮询机制获取数据，但该协调节点有权利将请求转发到下一个节点。
    </p>
    <p>
     用户保存数据流程：
    </p>
    <p>
     <img alt="" height="415" src="https://i-blog.csdnimg.cn/blog_migrate/ec269a300a60a918fc943b548beb1565.png" width="690"/>
    </p>
    <p>
     当然有参数可以修改保存响应流程。当主分片保存完成之后就可以返回响应。
    </p>
    <p>
     用户数据读取过程：
    </p>
    <p>
     <img alt="" height="348" src="https://i-blog.csdnimg.cn/blog_migrate/8f0c7f1d9c3287093d4dbbbcdf81dad1.png" width="751"/>
    </p>
    <p>
     更新流程读流程的结合：
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       ES准实时原理
      </strong>
     </span>
    </p>
    <p>
     <strong>
      写入过程 1.0 （不完善）
     </strong>
    </p>
    <ol>
     <li>
      不断将 Document 写入到 In-memory buffer （内存缓冲区）。
     </li>
     <li>
      当满足一定条件后内存缓冲区中的 Documents 刷新到磁盘。
     </li>
     <li>
      生成新的 segment 以及一个 Commit point 提交点。
     </li>
     <li>
      这个 segment 就可以像其他 segment 一样被读取了。
     </li>
    </ol>
    <p>
     画图如下：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="714" src="https://i-blog.csdnimg.cn/img_convert/575ff1ce3126e49fc649eb71b9e8793c.png" width="988"/>
    </p>
    <p>
     将文件刷新到磁盘是非常耗费资源的，而且在内存缓冲区和磁盘中间存在一个高速缓存（cache），一旦文件进入到 cache 就可以像磁盘上的 segment 一样被读取了。
    </p>
    <p>
     <strong>
      写入过程 2.0
     </strong>
    </p>
    <ol>
     <li>
      不断将 Document 写入到 In-memory buffer （内存缓冲区）。
     </li>
     <li>
      当满足一定条件后内存缓冲区中的 Documents 刷新到 高速缓存（
      <strong>
       cache
      </strong>
      ）。
     </li>
     <li>
      生成新的 segment ，这个 segment 还在 cache 中。
     </li>
     <li>
      这时候还没有 commit ，但是已经可以被读取了。
     </li>
    </ol>
    <p>
     画图如下：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="848" src="https://i-blog.csdnimg.cn/img_convert/61538285f3054bfc0a16483b8704bda4.png" width="954"/>
    </p>
    <p>
     数据从 buffer 到 cache 的过程是定期每秒刷新一次。所以新写入的 Document 最慢 1 秒就可以在 cache 中被搜索到。
    </p>
    <p>
     而 Document 从 buffer 到 cache 的过程叫做
     <strong>
      ?refresh
     </strong>
     。
     <span style="color:#fe2c24">
      一般是 1 秒刷新一次，不需要进行额外修改。当然，如果有修改的需要，
     </span>
     可以参考文末的相关资料。这也就是为什么说 Elasticsearch 是
     <strong>
      准实时
     </strong>
     的。
    </p>
    <p>
     使文档立即可见：
    </p>
    <p>
     Cloud Studio代码运行
    </p>
    <pre><code>PUT /test/_doc/1?refresh
{"test": "test"}

// 或者
PUT /test/_doc/2?refresh=true
{"test": "test"}
</code></pre>
    <p>
     <strong>
      Translog 事务日志
     </strong>
    </p>
    <p>
     此处可以联想 Mysql 的 binlog， ES 中也存在一个 translog 用来失败恢复。
    </p>
    <ol>
     <li>
      Document 不断写入到 In-memory buffer，此时也会追加 translog。
     </li>
     <li>
      当 buffer 中的数据每秒 refresh 到 cache 中时，translog 并没有进入到刷新到磁盘，是持续追加的。
     </li>
     <li>
      translog 每隔 5s 会 fsync 到磁盘。
     </li>
     <li>
      translog 会继续累加变得越来越大，当 translog 大到一定程度或者每隔一段时间，会执行 flush。
     </li>
    </ol>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="834" src="https://i-blog.csdnimg.cn/img_convert/dcd53f1e68ec42c65a1d6028b2913b49.png" width="1080"/>
    </p>
    <p>
     flush 操作会分为以下几步执行：
    </p>
    <ol>
     <li>
      buffer 被清空。
     </li>
     <li>
      记录 commit point。
     </li>
     <li>
      cache 内的 segment 被 fsync 刷新到磁盘。
     </li>
     <li>
      translog 被删除。
     </li>
    </ol>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="900" src="https://i-blog.csdnimg.cn/img_convert/c88e8e3d2d45d9518026bda24b7b0b96.png" width="1080"/>
    </p>
    <p>
     值得注意的是：
    </p>
    <ol>
     <li>
      translog 每 5s 刷新一次磁盘，所以故障重启，可能会丢失 5s 的数据。
     </li>
     <li>
      translog 执行 flush 操作，默认 30 分钟一次，或者 translog 太大 也会执行。
     </li>
    </ol>
    <p>
     手动执行flush：
    </p>
    <p>
     Cloud Studio代码运行
    </p>
    <pre><code>POST /my-index-000001/_flush
</code></pre>
    <p>
     <strong>
      3
     </strong>
    </p>
    <p>
     <strong>
      删除和更新
     </strong>
    </p>
    <p>
     segment 不可改变，所以 docment 并不能从之前的 segment 中移除或更新。
    </p>
    <p>
     所以每次 commit， 生成 commit point 时，会有一个 .del 文件，里面会列出被删除的 document（逻辑删除）。
    </p>
    <p>
     而查询时，获取到的结果在返回前会经过 .del 过滤。
    </p>
    <p>
     更新时，也会标记旧的 docment 被删除，写入到 .del 文件，同时会写入一个新的文件。此时查询会查询到两个版本的数据，但在返回前会被移除掉一个。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="846" src="https://i-blog.csdnimg.cn/img_convert/84300044cc15e94349b91794428f6ef6.png" width="1080"/>
    </p>
    <p>
     <strong>
      4
     </strong>
    </p>
    <p>
     <strong>
      segment 合并
     </strong>
    </p>
    <p>
     每 1s 执行一次 refresh 都会将内存中的数据创建一个 segment。
    </p>
    <p>
     segment 数目太多会带来较大的麻烦。每一个 segment 都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个 segment ；所以 segment 越多，搜索也就越慢。
    </p>
    <p>
     在 ES 后台会有一个线程进行 segment 合并：
    </p>
    <ol>
     <li>
      refresh操作会创建新的 segment 并打开以供搜索使用。
     </li>
     <li>
      合并进程选择一小部分大小相似的 segment，并且在后台将它们合并到更大的 segment 中。这并不会中断索引和搜索。
     </li>
     <li>
      当合并结束，老的 segment 被删除 说明合并完成时的活动：
      <ol>
       <li>
        新的 segment 被刷新（flush）到了磁盘。 写入一个包含新 segment 且排除旧的和较小的 segment的新 commit point。
       </li>
       <li>
        新的 segment 被打开用来搜索。
       </li>
       <li>
        老的 segment 被删除。
       </li>
      </ol>
     </li>
    </ol>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="251" src="https://i-blog.csdnimg.cn/img_convert/3c18483a87efc9739195a958298860b2.png" width="1080"/>
    </p>
    <p>
     物理删除：
    </p>
    <p>
     在 segment merge 这块，那些被逻辑删除的 document 才会被真正的物理删除。
    </p>
    <p>
     <strong>
      5
     </strong>
    </p>
    <p>
     <strong>
      总结
     </strong>
    </p>
    <p>
     主要介绍了内部写入和删除的过程，需要了解 refresh、fsync、flush、.del、segment merge 等名词的具体含义。
    </p>
    <p>
     完整画图如下：
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="855" src="https://i-blog.csdnimg.cn/img_convert/af9787581fcdc6ab669b3367e3741dcf.png" width="1080"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32373631303634372f:61727469636c652f64657461696c732f313232303839383232" class_="artid" style="display:none">
 </p>
</div>


