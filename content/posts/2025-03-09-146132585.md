---
layout: post
title: "Clist类的使用及模拟实现"
date: 2025-03-09 21:41:00 +0800
description: "list在底层是双向链表，能够进行动态内存分配，与其他容器相比，list的插入删除要更高效。1、list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。2、list的底层是带头双向循环链表结构，在节点中通过指针指向其前一个元素和后一个元素。3、与其他的序列式容器相比(array，vector，deque等)，list通常在任意位置进行插入、移除元素的效率更高。list最大的缺陷是不支持任意位置的随机访问list和vector一样也是类模板。"
keywords: "C++—list类的使用及模拟实现"
categories: ['未分类']
tags: ['开发语言', 'C']
artid: "146132585"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146132585
    alt: "Clist类的使用及模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146132585
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146132585
cover: https://bing.ee123.net/img/rand?artid=146132585
image: https://bing.ee123.net/img/rand?artid=146132585
img: https://bing.ee123.net/img/rand?artid=146132585
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++—list类的使用及模拟实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1%E3%80%81list%E7%9A%84%E4%BB%8B%E7%BB%8D" name="1%E3%80%81list%E7%9A%84%E4%BB%8B%E7%BB%8D">
     1、list的介绍
    </h2>
    <p>
     list在底层是双向链表，能够进行动态内存分配，与其他容器相比，list的插入删除要更高效。
    </p>
    <p>
     <strong>
      list的特性
     </strong>
    </p>
    <blockquote>
     <p>
      1、list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。
     </p>
     <p>
      2、list的底层是带头双向循环链表结构，在节点中通过指针指向其前一个元素和后一个元素。
     </p>
     <p>
      3、与其他的序列式容器相比(array，vector，deque等)，list通常在任意位置进行插入、移除元素的效率更高。
     </p>
    </blockquote>
    <p>
     <strong>
      list的缺陷
     </strong>
    </p>
    <blockquote>
     <p>
      list最大的缺陷是不支持任意位置的随机访问
     </p>
    </blockquote>
    <p>
     list和vector一样也是类模板。
    </p>
    <p>
     <img alt="" height="120" src="https://i-blog.csdnimg.cn/direct/0d5deb6ffc604243b6bd0df80d8e003e.png" width="1271"/>
    </p>
    <hr/>
    <h2 id="2%E3%80%81list%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" name="2%E3%80%81list%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0">
     2、list常用接口函数
    </h2>
    <h3 id="2.1%20%E5%87%A0%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" name="2.1%20%E5%87%A0%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">
     2.1 几个构造函数
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:680px">
     <thead>
      <tr>
       <th style="text-align:center">
        函数声明
       </th>
       <th style="text-align:center">
        函数说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="text-align:center">
        list (size_type n, const value_type&amp; val = value_type())
       </td>
       <td style="text-align:center">
        构造的list中包含n个值为val的元素
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        list()
       </td>
       <td style="text-align:center">
        构造空的list
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        list (const list&amp; x)
       </td>
       <td style="text-align:center">
        拷贝构造函数
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        list (InputIterator first, InputIterator last)
       </td>
       <td style="text-align:center">
        <p>
         用[first, last)区间中的元素构造list
        </p>
        <p>
         注意：这里的区间是左闭右开
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-cpp">//无参构造
list&lt;int&gt; l1;
//用10个6初始化链表
list&lt;int&gt; l2(10, 6);
//拷贝构造
list&lt;int&gt; ll2(l2);

vector&lt;int&gt; v{ 1,2,3,4 };
//用迭代器区间初始化链表
list&lt;int&gt; l3(v.begin(), v.end());</code></pre>
    <h4 id="2.1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="2.1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     2.1.1 构造函数的模拟实现
    </h4>
    <p>
     <strong>
      无参构造
     </strong>
    </p>
    <pre><code class="language-cpp">void empty_init()
{
	_head = new Node;
	_head-&gt;_next = _head;
	_head-&gt;_prev = _head;
}

list()
{
	empty_init();
}</code></pre>
    <p>
     <strong>
      拷贝构造
     </strong>
    </p>
    <pre><code class="language-cpp">list(const list&lt;T&gt;&amp; lt)
{
	empty_init();

	for (const auto&amp; e : lt)
	{
		push_back(e);
	}
}</code></pre>
    <p>
     <strong>
      赋值构造
     </strong>
    </p>
    <pre><code class="language-cpp">void swap(const list&lt;T&gt;&amp; tmp)
{
	std::swap(_head, tmp._head);
}

list&lt;T&gt;&amp; operator=(const list&lt;T&gt; lt)
{
	swap(lt);
	return *this;
}</code></pre>
    <p>
     <strong>
      析构
     </strong>
    </p>
    <pre><code class="language-cpp">void clear()
{
	iterator it = begin();
	while (it != end())
	{
		it = erase(it);
	}
}

~list()
{
	clear();

	delete _head;
	_head = nullptr;
}</code></pre>
    <hr/>
    <h3 id="2.2%20%E8%BF%AD%E4%BB%A3%E5%99%A8" name="2.2%20%E8%BF%AD%E4%BB%A3%E5%99%A8">
     2.2 迭代器
    </h3>
    <p>
     可以暂时将迭代器理解成指针，这个指针指向list中的某个节点。
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:680px">
     <thead>
      <tr>
       <th style="text-align:center">
        函数声明
       </th>
       <th style="text-align:center">
        接口说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="text-align:center">
        begin + end
       </td>
       <td style="text-align:center">
        返回第一个元素的迭代器+返回最后一个元素下一个位置的迭代器
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        rbegin + rend
       </td>
       <td style="text-align:center">
        返回第一个元素的reverse_iterator,即end位置，返回最后一个元素下一个位置的reverse_iterator,即begin位置
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-cpp">vector&lt;int&gt; v1{ 5,3,10,26,9,22,12,24 };
list&lt;int&gt; l(v1.begin(), v1.end());

auto it = l.begin();
while (it != l.end())
{
	cout &lt;&lt; *it &lt;&lt; " ";
	it++;
}</code></pre>
    <p>
     <img alt="" height="383" src="https://i-blog.csdnimg.cn/direct/7d39dac922674288a503b1f211195aa1.png" width="1015"/>
    </p>
    <p>
     反向迭代
    </p>
    <p>
     <img alt="" height="397" src="https://i-blog.csdnimg.cn/direct/3d8ce25ef6f9451885982539a51943c9.png" width="1009"/>
    </p>
    <h4 id="2.2.1%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="2.2.1%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     2.2.1 迭代器的模拟实现
    </h4>
    <p>
     与vector不同，list的迭代器不是一个原生指针，而是封装节点指针的类，因为用户只需要得到节点中的数据而不是整个节点。
    </p>
    <p>
     vector随机访问可以支持像it+5，it[6]这样的形式，而list不能随机访问也就不能使用operator []来访问节点，仅支持++和--操作，这个++和--也不是指针的++和--，所以要把迭代器也封装成一个类，通过重载++、--和解引用等运算符来满足需求。
    </p>
    <pre><code class="language-cpp">//先要封装一个结点类
template&lt;class T&gt;
struct ListNode
{
	ListNode&lt;T&gt;* _next;
	ListNode&lt;T&gt;* _prev;
	T _data;

	ListNode(const T&amp; x = T())
		:_next(nullptr)
		, _prev(nullptr)
		, _data(x)
	{}
};
//封装一个迭代器类
template&lt;class T&gt;
struct __list_iterator
{
	typedef ListNode&lt;T&gt; Node;
	typedef __list_iterator&lt;T&gt; self;
	Node* _node;

	__list_iterator(Node* x)
		:_node(x)
	{}

	self&amp; operator++()
	{
		_node = _node-&gt;_next;
		return *this;
	}

	self operator++(int)
	{
		//相当于__list_iterator&lt;T&gt; tmp(*this);
		self tmp(*this);

		_node = _node-&gt;_next;

		return tmp;
	}

	self&amp; operator--()
	{
		_node = _node-&gt;_prev;
		return *this;
	}

	self operator--(int);

    //解引用重载
	T&amp; operator*()
	{
		return _node-&gt;_data;
	}

    //
    T operator-&gt;()
    {
        return &amp;_node-&gt;_data;
    }

	bool operator!=(const self&amp; s)
	{
		return _node != s._node;
	}

	bool operator==(const self&amp; s);
};</code></pre>
    <p>
     迭代器的实现
    </p>
    <pre><code class="language-cpp">const_iterator begin()const
{
    //这里是单参数类型支持隐式类型转换
	//return const_iterator(_head-&gt;_next);
	return _head-&gt;_next;
}

const_iterator end()const
{
	return _head;
}

iterator begin()
{
	return _head-&gt;_next;
}

iterator end()
{
	return _head;
}
</code></pre>
    <hr/>
    <h3 id="2.3%20%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0" name="2.3%20%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0">
     2.3 容量相关的函数
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:680px">
     <thead>
      <tr>
       <th style="text-align:center">
        函数
       </th>
       <th style="text-align:center">
        接口说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="text-align:center">
        empty
       </td>
       <td style="text-align:center">
        检测list是否为空，是返回true，否则返回false
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        size
       </td>
       <td style="text-align:center">
        返回list中有效节点的个数
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     这里个函数我们学会使用即可。
    </p>
    <h2 id="3%E3%80%81list%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9" name="3%E3%80%81list%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">
     3、list的增删查改
    </h2>
    <p>
     <strong>
      访问头部和尾部数据
     </strong>
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:680px">
     <thead>
      <tr>
       <th style="text-align:center">
        函数
       </th>
       <th style="text-align:center">
        功能
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="text-align:center">
        front()
       </td>
       <td style="text-align:center">
        取到头节点数据的引用
       </td>
      </tr>
      <tr>
       <td style="text-align:center">
        back()
       </td>
       <td style="text-align:center">
        返回尾节点数据的引用
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="3.1%20%E6%8F%92%E5%85%A5insert" name="3.1%20%E6%8F%92%E5%85%A5insert">
     3.1 插入insert
    </h3>
    <pre><code class="language-cpp">iterator insert(iterator pos, const T&amp; x)
{
	Node* cur = pos._node;
	Node* prev = cur-&gt;_prev;
	Node* newnode = new Node(x);

	prev-&gt;_next = newnode;
	newnode-&gt;_prev = prev;
	newnode-&gt;_next = cur;
	cur-&gt;_prev = newnode;

	++_size;//这里是为了管理_size
	return newnode;
}</code></pre>
    <h3 id="3.2%20%E5%88%A0%E9%99%A4erase" name="3.2%20%E5%88%A0%E9%99%A4erase">
     3.2 删除erase
    </h3>
    <p>
     将待删除的节点的前后节点先保存起来，再删除pos出节点，将前后节点连接起来。
    </p>
    <pre><code class="language-cpp">iterator erase(iterator pos)
{
	assert(pos != end());

	Node* cur = pos._node;
	Node* prev = cur-&gt;_prev;
	Node* next = cur-&gt;_next;
	prev-&gt;_next = next;
	next-&gt;_prev = prev;

	delete cur;
	--_size;
	return next;
}</code></pre>
    <h3 id="3.3%20%E5%A4%B4%E6%8F%92%E3%80%81%E5%A4%B4%E5%88%A0%E3%80%81%E5%B0%BE%E6%8F%92%E3%80%81%E5%B0%BE%E5%88%A0" name="3.3%20%E5%A4%B4%E6%8F%92%E3%80%81%E5%A4%B4%E5%88%A0%E3%80%81%E5%B0%BE%E6%8F%92%E3%80%81%E5%B0%BE%E5%88%A0">
     3.3 头插、头删、尾插、尾删
    </h3>
    <pre><code class="language-cpp">//尾插
void push_back(const T&amp; x)
{
	insert(end(), x);
}
//头插
void push_front(const T&amp; x)
{
	insert(begin(), x);
}

//尾删
void pop_back()
{
	erase(--end());
}

//头删
void pop_front()
{
	erase(begin());
}
</code></pre>
    <h2 id="4%E3%80%81list%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84" name="4%E3%80%81list%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84">
     4、list需要注意的点及功能完善
    </h2>
    <h3 id="4.1%20list%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98" name="4.1%20list%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98">
     4.1 list迭代器失效问题
    </h3>
    <p>
     list的底层结构为带头结点的双向循环链表，因此在list中进行插入时是不会导致list的迭代器失效的，pos指向的节点的，改变的只是连接关系，位置始终都是一个位置。
    </p>
    <p>
     只有在删除时才会失效，这个位置的数据被删除后，连接关系被改变，此位置就不在原链表中了，此时失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响。
    </p>
    <h2 id="4.2%20list%E7%9A%84sort%E6%8E%92%E5%BA%8F" name="4.2%20list%E7%9A%84sort%E6%8E%92%E5%BA%8F">
     4.2 list的sort排序
    </h2>
    <p>
     由于list是带头结点的双向循环链表，而算法库中的sort底层是快排，需要传入随机访问迭代器，所以list并不能使用算法库的sort。那么list的sort是怎么一回事呢？
    </p>
    <p>
     list中给了一个适合自己的sort，这个sort实质上是归并排序，但是
     <span style="background-color:#fbd4d0">
      直接使用这个sort
     </span>
     比list的数据先push_back到vector中，再使用算法库的sort，排完序后再导入list中的三步
     <span style="background-color:#fbd4d0">
      还要慢。
     </span>
    </p>
    <p>
     <span style="background-color:null">
      所以我们通常不使用list自己的sort。
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f41313030373535313436302f:61727469636c652f64657461696c732f313436313332353835" class_="artid" style="display:none">
 </p>
</div>


