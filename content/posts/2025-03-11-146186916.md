---
layout: post
title: "javascript-es6-六"
date: 2025-03-11 21:53:58 +0800
description: "就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次 调用就可以了就是按照我们分析好了的步骤，按照步骤解决问题。"
keywords: "javascript-es6 （六）"
categories: ['Javascript']
tags: ['笔记', '开发语言', '原型模式', '前端', 'Javascript', 'Es', 'Ecmascript']
artid: "146186916"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146186916
    alt: "javascript-es6-六"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146186916
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146186916
cover: https://bing.ee123.net/img/rand?artid=146186916
image: https://bing.ee123.net/img/rand?artid=146186916
img: https://bing.ee123.net/img/rand?artid=146186916
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     javascript-es6 （六）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     编程思想
    </h2>
    <h3 style="background-color:transparent">
     面向过程
    </h3>
    <p>
     <strong>
      面向过程
     </strong>
     就是分析出解决问题所需要的
     <span style="background-color:#ffd900">
      步骤
     </span>
     ，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次 调用就可以了
    </p>
    <p>
     <span style="color:#fe2c24">
      就是按照我们分析好了的步骤，按照步骤解决问题
     </span>
    </p>
    <h3>
     面向对象
    </h3>
    <p>
     <strong>
      面向对象
     </strong>
     是把事务分解成为一个个对象，然后由对象之间分工与合作
    </p>
    <p>
     是以对象功能来划分问题，而不是步骤，在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工
    </p>
    <p>
     面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目
    </p>
    <p>
     面向对象的特性：
    </p>
    <ul>
     <li>
      封装性
     </li>
     <li>
      继承性
     </li>
     <li>
      多态性
     </li>
    </ul>
    <h2>
     构造函数
    </h2>
    <p>
     回顾一下
    </p>
    <pre><code class="language-javascript">//构造函数 公共的属性和方法 封装到 Pig 构造函数里面了
function Pig(uname,age) {   //Pig 一定要大写开头
    this.uname = uname    //this 表示 创建的空对象
    this.age = age
    //方法
    this.sing = function (){
    console.log('我是可爱的小猪~')
}
}
//创建实例对象
const peiqi = new Pig('佩奇',18)
const qiaozhi = new Pig('乔治',6)
console.log(peiqi === qiaozhi)  //false  表明创建的对象彼此独立，互不影响
</code></pre>
    <div>
     <span style="color:#262626">
      总结：
     </span>
    </div>
    <div>
     <span style="color:#262626">
      1. 构造函数体现了面向对象的封装特性，一定要使用this
     </span>
    </div>
    <div>
     <span style="color:#262626">
      2. 构造函数实例创建的对象彼此独立、互不影响
     </span>
    </div>
    <div>
     <span style="color:#262626">
      但是
     </span>
     <span style="color:#c00000">
      存在浪费内存的问题
     </span>
    </div>
    <h2>
     原型
    </h2>
    <div>
     <ol>
      <li>
       <span style="color:#262626">
        构造函数通过
        <strong>
         原型
        </strong>
        分配的函数是所有对象所
       </span>
       <span style="color:#c00000">
        <strong>
         共享的
        </strong>
       </span>
       <span style="color:#c00000">
        。
       </span>
      </li>
      <li>
       <span style="color:#404040">
       </span>
       <span style="color:#262626">
        JavaScript 规定，
       </span>
       <span style="color:#c00000">
        每一个构造函数都有一个 prototype 属性
       </span>
       <span style="color:#262626">
        ，指向另一个对象，所以我们也称为原型对象
       </span>
      </li>
      <li>
       <span style="color:#404040">
       </span>
       <span style="color:#262626">
        这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
       </span>
      </li>
      <li>
       <span style="color:#404040">
       </span>
       <span style="color:#c00000">
        我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。
       </span>
      </li>
      <li>
       <span style="color:#404040">
       </span>
       <span style="color:#c00000">
        构造函数和原型对象中的this 都指向 实例化的对象
       </span>
      </li>
     </ol>
     <p style="text-align:center">
      <img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/fb112af11636490cb163f10ce55f06c0.png" width="431"/>
     </p>
    </div>
    <p>
     总结：
    </p>
    <p>
     <span style="color:#000000">
      1.原型：一个对象，我们也称为 prototype 为
     </span>
     <span style="color:#c00000">
      原型对象
     </span>
    </p>
    <div>
     <span style="color:#000000">
      2. 原型的作用：
     </span>
    </div>
    <div>
     <span style="color:#000000">
     </span>
     <span style="color:#000000">
      共享方法
     </span>
    </div>
    <div>
     <span style="color:#000000">
     </span>
     <span style="color:#000000">
      可以把那些不变的方法，直接定义在 prototype 对象上
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#000000">
      3. 构造函数和原型里面的this指向谁 ？
     </span>
    </div>
    <div>
     <span style="color:#000000">
     </span>
     <strong>
      <span style="color:#fe2c24">
       实例化的对象
      </span>
     </strong>
    </div>
    <div>
    </div>
    <div>
     <strong>
      <span style="color:#0d0016">
       下面简单证明一下
      </span>
     </strong>
    </div>
    <div>
     <pre><code class="language-javascript">let that
function Pig(uname) {
    that = this
    this.uname = uname
}
const peiqi = new Pig('佩奇')
console.log(that === peiqi)  //true 表明在构造函数中 this 指向的还是实例对象 peiqi

Pig.prototype.sing = function (){
    that = this
    console.log('唱歌')
}
peiqi.sing()  //唱歌   能被调用，表明this 指向peiqi
console.log(that === peiqi)  //true 表明在原型中 this 指向的还是实例对象 peiqi</code></pre>
    </div>
    <p>
     <strong>
      练习：给数组拓展 最大值方法
     </strong>
    </p>
    <pre><code class="language-javascript">//1.我们定义数组求最大值方法，使任意一个数组实例对象都可使用
//2.自定义的方法写到 数组.prototype 身上
const arr = [1,2,3]
Array.prototype.max = function (){
    return Math.max(...this)  //运用展开运算符 ...  原型里面的this 指向实例对象 arr
}
console.log(arr.max()) //3</code></pre>
    <h3 style="background-color:transparent">
     <span style="color:#000000">
      constructor 属性
     </span>
    </h3>
    <div>
     <span style="color:#000000">
      每个原型对象里面都有个constructor 属性,
     </span>
     <span style="color:#262626">
      该属性
     </span>
     <span style="color:#c00000">
      指向
     </span>
     <span style="color:#262626">
      该原型对象的
     </span>
     <span style="color:#c00000">
      构造函数
     </span>
    </div>
    <div style="text-align:center">
     <span style="color:#c00000">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/ab0df418f14a4bab8ee3ff8858ee4e50.png"/>
     </span>
    </div>
    <div>
     <span style="color:#000000">
      <strong>
       使用场景：
      </strong>
     </span>
    </div>
    <div>
     <span style="color:#262626">
      如果有多个对象的方法，我们可以给原型对象采取
     </span>
     <span style="color:#fe2c24">
      对象形式赋值
     </span>
     <span style="color:#262626">
      .
     </span>
    </div>
    <div>
     <span style="color:#262626">
      但是这样就会
      <strong>
       覆盖
      </strong>
      构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了
     </span>
    </div>
    <div>
     <span style="color:#262626">
      此时，我们可以在修改后的原型对象中，
     </span>
     <span style="color:#fe2c24">
      <strong>
       添加一个 constructor 指向原来的构造函数
      </strong>
     </span>
    </div>
    <pre><code class="language-javascript">function Star(name) {
    this.name = name
}
//如果有多个对象的方法，我们可以给原型对象采取对象形式赋值
Star.prototype = {
    sing:function(){
    console.log('唱歌')
},
    dance:function(){
    console.log('跳舞')
},
}
console.log(Star.prototype.constructor)  //指向 Object 而不是 指向Star了
//我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数
Star.prototype = {

//手动添加constructor 指向 Star 构造函数
    constructor: Star,

    sing:function(){
    console.log('唱歌')
},
    dance:function(){
    console.log('跳舞')
},
}
console.log(Star.prototype.constructor)  //指向 Star</code></pre>
    <p>
    </p>
    <h3 style="background-color:transparent">
     <span style="color:#000000">
      对象原型（__proto__）
     </span>
    </h3>
    <div>
     <div>
      <span style="color:#c00000">
       对象都会有一个属性 __proto__（双下划线）
      </span>
      <span style="color:#262626">
       指向构造函数的
      </span>
      <span style="color:#fe2c24">
       <strong>
        prototype 原型对象
       </strong>
      </span>
     </div>
     <div>
      <span style="color:#262626">
       <img alt="" src="https://i-blog.csdnimg.cn/direct/ae1527de26c744f98716b3814d46c889.png"/>
      </span>
     </div>
    </div>
    <p>
    </p>
    <div>
     <span style="color:#000000">
      注意：
     </span>
    </div>
    <ol>
     <li>
      <span style="color:#404040">
      </span>
      <span style="color:#000000">
       __proto__ 是JS非标准属性
      </span>
     </li>
     <li>
      <span style="color:#000000">
       [[prototype]]和__proto__意义相同（只读的，只能获取不能赋值）
      </span>
     </li>
     <li>
      <span style="color:#404040">
      </span>
      <span style="color:#000000">
       用来表明当前实例对象指向哪个原型对象prototype
      </span>
     </li>
     <li>
      <span style="color:#404040">
      </span>
      <span style="color:#000000">
       __proto__对象原型里面也有一个
      </span>
      <span style="color:#262626">
       constructor属性，
      </span>
      <span style="color:#c00000">
       指向创建该实例对象的构造函数
      </span>
     </li>
    </ol>
    <h3>
     <span style="color:#000000">
      原型继承
     </span>
    </h3>
    <div>
     <div>
      <span style="color:#262626">
       继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承 的特性
      </span>
     </div>
     <div>
     </div>
     <div>
      <div>
       <strong>
        <span style="color:#c00000">
         1、
        </span>
       </strong>
       <strong>
        <span style="color:#c00000">
         封装
        </span>
       </strong>
       <strong>
        <span style="color:#c00000">
         -
        </span>
       </strong>
       <strong>
        <span style="color:#262626">
         抽取公共部分
        </span>
       </strong>
      </div>
      <div>
       <span style="color:#000000">
        把男人和女人公共的部分抽取出来放到人类里面
       </span>
      </div>
     </div>
    </div>
    <h3>
     <span style="color:#000000">
      原型链
     </span>
    </h3>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303131353234312f:61727469636c652f64657461696c732f313436313836393136" class_="artid" style="display:none">
 </p>
</div>


