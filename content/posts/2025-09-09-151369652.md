---
layout: post
title: "opencv-银行卡号识别案例"
date: 2025-09-09T22:44:25+0800
description: "具体的判定条件，选择合适的区域，根据实际任务。"
keywords: "opencv 银行卡号识别案例"
categories: ['未分类']
tags: ['银行卡号识别', '计算机视觉', '人工智能', 'Opencv']
artid: "151369652"
arturl: "https://blog.csdn.net/weixin_72931638/article/details/151369652"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151369652
    alt: "opencv-银行卡号识别案例"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151369652
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151369652
cover: https://bing.ee123.net/img/rand?artid=151369652
image: https://bing.ee123.net/img/rand?artid=151369652
img: https://bing.ee123.net/img/rand?artid=151369652
---



# opencv 银行卡号识别案例



**目录**

[一.参数设置](#%E4%B8%80.%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE)

[二.指定信用卡的类型](#%E4%BA%8C.%E6%8C%87%E5%AE%9A%E4%BF%A1%E7%94%A8%E5%8D%A1%E7%9A%84%E7%B1%BB%E5%9E%8B)

[三.模板图像中的数字定位处理](#%E4%B8%89.%E6%A8%A1%E6%9D%BF%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86)

[1.读取数字模板照片做灰度图处理并进行二值化处理成黑底白字](#1.%E8%AF%BB%E5%8F%96%E6%95%B0%E5%AD%97%E6%A8%A1%E6%9D%BF%E7%85%A7%E7%89%87%E5%81%9A%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%A4%84%E7%90%86%E5%B9%B6%E8%BF%9B%E8%A1%8C%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86%E6%88%90%E9%BB%91%E5%BA%95%E7%99%BD%E5%AD%97)

[2.得到所有数字轮廓](#2.%E5%BE%97%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E8%BD%AE%E5%BB%93)

[3.给所有数字轮廓排序](#3.%E7%BB%99%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E8%BD%AE%E5%BB%93%E6%8E%92%E5%BA%8F)

[4.将数字和对应的外接矩形图片即数字图片保存在字典中](#4.%E5%B0%86%E6%95%B0%E5%AD%97%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2%E5%9B%BE%E7%89%87%E5%8D%B3%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD)

[四.信用卡的图像处理](#%E5%9B%9B.%E4%BF%A1%E7%94%A8%E5%8D%A1%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86)

[1.银行卡图片的基本处理](#1.%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%9B%BE%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86)

[①读取图片](#%E2%91%A0%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87)

[②通过自定义的方法将图像等比缩放到宽度为300后提取灰度图](#%E2%91%A1%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95%E5%B0%86%E5%9B%BE%E5%83%8F%E7%AD%89%E6%AF%94%E7%BC%A9%E6%94%BE%E5%88%B0%E5%AE%BD%E5%BA%A6%E4%B8%BA300%E5%90%8E%E6%8F%90%E5%8F%96%E7%81%B0%E5%BA%A6%E5%9B%BE)

[③顶帽操作（顶帽=原始图像-开运算结果（先腐蚀后膨胀））](#%E2%91%A2%E9%A1%B6%E5%B8%BD%E6%93%8D%E4%BD%9C%EF%BC%88%E9%A1%B6%E5%B8%BD%3D%E5%8E%9F%E5%A7%8B%E5%9B%BE%E5%83%8F-%E5%BC%80%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%EF%BC%88%E5%85%88%E8%85%90%E8%9A%80%E5%90%8E%E8%86%A8%E8%83%80%EF%BC%89%EF%BC%89)

[2.找到银行卡图片中的数字边框](#2.%E6%89%BE%E5%88%B0%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%BE%B9%E6%A1%86)

[①通过闭操作（先膨胀后腐蚀），将数字连在一起](#%E2%91%A0%E9%80%9A%E8%BF%87%E9%97%AD%E6%93%8D%E4%BD%9C%EF%BC%88%E5%85%88%E8%86%A8%E8%83%80%E5%90%8E%E8%85%90%E8%9A%80%EF%BC%89%EF%BC%8C%E5%B0%86%E6%95%B0%E5%AD%97%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7)

[​编辑](#%E2%80%8B%E7%BC%96%E8%BE%91)

[②对闭操作后的图进行二值化处理](#%E2%91%A1%E5%AF%B9%E9%97%AD%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%9B%BE%E8%BF%9B%E8%A1%8C%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86)

[③对二值化后的黑白图载进行一次闭操作](#%E2%91%A2%E5%AF%B9%E4%BA%8C%E5%80%BC%E5%8C%96%E5%90%8E%E7%9A%84%E9%BB%91%E7%99%BD%E5%9B%BE%E8%BD%BD%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E9%97%AD%E6%93%8D%E4%BD%9C)

[④找出最后闭操作的图中所有的轮廓](#%E2%91%A3%E6%89%BE%E5%87%BA%E6%9C%80%E5%90%8E%E9%97%AD%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9B%BE%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E8%BD%AE%E5%BB%93)

[⑤遍历找出的轮廓，找到数字部分像素区域轮廓的最小外接矩形并保存](#%E2%91%A4%E9%81%8D%E5%8E%86%E6%89%BE%E5%87%BA%E7%9A%84%E8%BD%AE%E5%BB%93%EF%BC%8C%E6%89%BE%E5%88%B0%E6%95%B0%E5%AD%97%E9%83%A8%E5%88%86%E5%83%8F%E7%B4%A0%E5%8C%BA%E5%9F%9F%E8%BD%AE%E5%BB%93%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2%E5%B9%B6%E4%BF%9D%E5%AD%98)

[3.遍历上面得到的每一个轮廓矩形中的数字，再匹配每一个值](#3.%E9%81%8D%E5%8E%86%E4%B8%8A%E9%9D%A2%E5%BE%97%E5%88%B0%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%BD%AE%E5%BB%93%E7%9F%A9%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E5%86%8D%E5%8C%B9%E9%85%8D%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%80%BC)

[①切片获取数字区域](#%E2%91%A0%E5%88%87%E7%89%87%E8%8E%B7%E5%8F%96%E6%95%B0%E5%AD%97%E5%8C%BA%E5%9F%9F)

[②对数字区域group图片进行二值化处理得到黑底白字](#%E2%91%A1%E5%AF%B9%E6%95%B0%E5%AD%97%E5%8C%BA%E5%9F%9Fgroup%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86%E5%BE%97%E5%88%B0%E9%BB%91%E5%BA%95%E7%99%BD%E5%AD%97)

[③找出group的中的所有数字外轮廓，再排序](#%E2%91%A2%E6%89%BE%E5%87%BAgroup%E7%9A%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E5%A4%96%E8%BD%AE%E5%BB%93%EF%BC%8C%E5%86%8D%E6%8E%92%E5%BA%8F)

[④匹配group中的每一个数值](#%E2%91%A3%E5%8C%B9%E9%85%8Dgroup%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E5%80%BC)

[⑤使用模板匹配，计算匹配得分](#%E2%91%A4%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%8C%B9%E9%85%8D%E5%BE%97%E5%88%86)

[⑥在遍历完一个group里的所有数值后直接在银行卡原图片画出该group外界矩阵并在上面写出对应数字](#%E2%91%A5%E5%9C%A8%E9%81%8D%E5%8E%86%E5%AE%8C%E4%B8%80%E4%B8%AAgroup%E9%87%8C%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E5%80%BC%E5%90%8E%E7%9B%B4%E6%8E%A5%E5%9C%A8%E9%93%B6%E8%A1%8C%E5%8D%A1%E5%8E%9F%E5%9B%BE%E7%89%87%E7%94%BB%E5%87%BA%E8%AF%A5group%E5%A4%96%E7%95%8C%E7%9F%A9%E9%98%B5%E5%B9%B6%E5%9C%A8%E4%B8%8A%E9%9D%A2%E5%86%99%E5%87%BA%E5%AF%B9%E5%BA%94%E6%95%B0%E5%AD%97)

[4.遍历所有的数字轮廓矩形后打印结果](#4.%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E5%AD%97%E8%BD%AE%E5%BB%93%E7%9F%A9%E5%BD%A2%E5%90%8E%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C)

---

![](https://i-blog.csdnimg.cn/direct/d1ec82602651410b8b6305148a91eefb.png)

![](https://i-blog.csdnimg.cn/direct/83111a9d698e460daa9f8d9435c13c4a.png)

本案例根据银行卡的图片识别出银行卡号，效果如下 :

![](https://i-blog.csdnimg.cn/direct/a3245778357f4441ba4b56df36b908ee.png)

第一个数字用来代表银行卡的类型，在代码中我们可以使用字典来保存

### 一.参数设置

导入相关库和文件，其中myutils是一个自己创建的工具包，后面会介绍

```
import numpy as np
import argparse  # python内置库
import cv2
import myutils
```

我们使用argparse类来设置参数，只需在运行配置中填入参数即可

```
# 设置参数
ap = argparse.ArgumentParser()  #创建 ArgumentParser 对象，这个对象将用于定义和解析命令行参数
ap.add_argument("-i", "--image", required=True,
                help="path to input image")
ap.add_argument("-t", "--template", required=True,
                help="path to template OCR-A image")
args = vars(ap.parse_args())  # vars()是Python中的一个内置函数，用于返回对象的属性和值的字典。
```

在运行配置中填入-i card1.png -t kahao.pn，args=vars()是Python中的一个内置函数，用于返回对象的属性和值的字典，则**args['image']='card1.png',args['template']='kakao.png'**

![](https://i-blog.csdnimg.cn/direct/7e9ff8f801824a398128fcbf5b31a00c.png)

![](https://i-blog.csdnimg.cn/direct/e844828619044c86b92636d5cfaabc7f.png)

### 二.指定信用卡的类型

我们直接用字典来保存不同数字对应的银行卡类型

```
# 指定信用卡类型
FIRST_NUMBER = {"3": "American Express",
                "4": "Visa",
                "5": "MasterCard",
                "6": "Discover Card"}
```

自定义一个展示图片的函数减小代码量

```
def cv_show(name, img):  # 绘图展示
    cv2.imshow(name, img)
    cv2.waitKey(0)
```

### 三.模板图像中的数字定位处理

#### 1.读取数字模板照片做灰度图处理并进行二值化处理成黑底白字

```
img=cv2.imread(args['template'])
cv_show('img',img)

```

![](https://i-blog.csdnimg.cn/direct/e97e3b2f5d2a4927a74e692e59eca192.png)

```
ref=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
cv_show('ref',ref)

```

![](https://i-blog.csdnimg.cn/direct/07aad2ec70644bada80eff21ac837afc.png)

```
ref=cv2.threshold(ref,10,255,cv2.THRESH_BINARY_INV)[1]#二值图像黑底白字，方便找到轮廓
cv_show('ref',ref)
```

**cv2.THRESH_BINARY_INV模式像素值大于thresh(10)的变为0，小于thresh的变成255,取索引[1]是因为函数有两个返回结果第二个才是需要的二值图**

![](https://i-blog.csdnimg.cn/direct/60283f508cd54c31b859b8309a253c83.png)

#### 2.得到所有数字轮廓

**cv2.RETR_EXTERNAL模式代表只检测图像的外轮廓，**

**cv2.CHAIN_APPROX_SIMPLE表示只简单保留轮廓的终点坐标即只保留完整轮廓的其中一部分**

```
_,refCnts,hierarchy=cv2.findContours(ref,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)#RETR_EXTERNAL只检测外轮廓，CHAIN_APPROX_SIMPLE只保留终点坐标
cv2.drawContours(img,refCnts,-1,(0,0,255),3)
cv_show('img',img)
```

**drawContours()方法表示在直接img上画出轮廓，-1表示绘制所有轮廓**

![](https://i-blog.csdnimg.cn/direct/e3a1e454742d478683b5cd8ecfead27a.png)

#### 3.给所有数字轮廓排序

由于我们前面提取到的所有轮廓refCnts中的轮廓列表并不是和我们图片中的数字一个是按顺序拍好的，所有我们在myutils.py中自定义了一个排序方法sort_contours（）来将refCnts列表中的轮廓按对应的数字0,1,2,3,4,5,6,7,8,9排好

```
def sort_contours(cnts,method='left-to-right'):
    reverse=False
    i=0
    if method=='right-to-left'or method=='bottom-to-top':
        reverse=True
    if method=='bottom-to-top'or method=='bottom-to-top':
        i=1

    boundingBoxes=[cv2.boundingRect(c) for c in cnts]
    (cnts,boundingBoxes)=zip(*sorted(zip(cnts,boundingBoxes),key=lambda a:a[1][i],reverse=reverse))
    return cnts,boundingBoxes
```

  boundingBoxes=[cv2.boundingRect(c) for c in cnts]是**遍历轮廓列表中的所有轮廓，分别得到他们的最小外接矩形**后，以列表的形式存储在boundingsBoxes中

sorted(zip(cnts,boundingBoxes),key=lambda a:a[1][i],reverse=reverse)是先将轮廓列表和对应的外接矩阵列表用zip()组和在一组里，然后**根据外接****矩阵列表中的第一个元素即外界矩行的x坐标的大小来排序，从小到大排序**，对应的轮廓就是从0到9，排序完成之后在用zip()压缩成组返回，最后return轮廓列表和对应的最小外接矩行列表

```
refCnts,boundingBoxes= myutils.sort_contours(refCnts, method='left-to-right')
```

调用方法得到排序后的轮廓列表和对应的最小外接矩形列表

#### 4.将数字和对应的外接矩形图片即数字图片保存在字典中

利用上面返回的**最小外接矩形列表通过索引得到对应数字外接矩形的x,y,w和h**，直接**在黑底白字的二值图ref上进行切片操作来截取对应的数字图片**，最后一遍遍的保存在字典中（键：数字，值：对应的图片）

```
digits={}
for i in range(10):
    (x,y,w,h)=boundingBoxes[i]
    roi=ref[y:y+h,x:x+w]
    roi=cv2.resize(roi,(57,88))
    cv_show('roi',roi)
    digits[i]=roi
print(digits)
```

可以来显示对应的数字图片

![](https://i-blog.csdnimg.cn/direct/5a188c948e884abc9aff00d306115a83.png)![](https://i-blog.csdnimg.cn/direct/099a38d461fe481fa7c1ed190083288b.png)![](https://i-blog.csdnimg.cn/direct/6e9514d21dd0480796890401ad49b75b.png)![](https://i-blog.csdnimg.cn/direct/ee7d180e19b34915998e8f033577e12e.png)![](https://i-blog.csdnimg.cn/direct/b59dc21802c645509bd07ec3cdea1f35.png)![](https://i-blog.csdnimg.cn/direct/a9376da188a544c2bdfc0430388c76d5.png)![](https://i-blog.csdnimg.cn/direct/e6ecc99d716749dd9accc35a382e4746.png)![](https://i-blog.csdnimg.cn/direct/3d647079c28f413990503a22af2b5060.png)![](https://i-blog.csdnimg.cn/direct/4b09880d30394b809154652a7e6d4b90.png)![](https://i-blog.csdnimg.cn/direct/b013fd163cde440d9c25a0ee81f231a5.png)

### 四.信用卡的图像处理

#### 1.银行卡图片的基本处理

①读取图片

```
image=cv2.imread(args['image'])
cv_show('image',image)
```

![](https://i-blog.csdnimg.cn/direct/a4b0d78374324a23917ec92a99c19ade.png)

②通过自定义的方法将图像等比缩放到宽度为300后提取灰度图

```
def resize(image,width=None,height=None,inter=cv2.INTER_AREA):
    dim=None
    (h,w)=image.shape[:2]
    if width is None and height is None:
        return image
    if width is None:
        r=height/float(h)
        dim=(int(w*r),height)
    else:
        r=width/float(w)
        dim=(width,int(h*r))
    resized=cv2.resize(image,dim,interpolation=inter)#默认为cv2.INTER_AREA，即面积插值适用于缩放图像
    return resized
```

```
image= myutils.resize(image, width=300)
gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
cv_show('gray',gray)
```

![](https://i-blog.csdnimg.cn/direct/cec8e96c3f474344bf9fce1fd01ff128.png)

③顶帽操作（顶帽=原始图像-开运算结果（先腐蚀后膨胀））

**突出图像中的亮细节，清楚背景图，原因是背景颜色变化小不被腐蚀掉**

**直接使用**cv2.getStructuringElement()方法生成卷积核(**全是1的矩阵)**一个9*3的一个5*5的

![](https://i-blog.csdnimg.cn/direct/7570a4d283e24d58bde62dddc8fa3264.png)

在cv2.morphologyEx()方法中cv2.MORPH_TOPHAT表示顶帽模式卷积核我们选择使用9*3的卷积核对银行卡的灰度图进行顶帽处理

```
rectKernel=cv2.getStructuringElement(cv2.MORPH_RECT,(9,3))#初始化卷积核
sqKernel=cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))
tophat=cv2.morphologyEx(gray,cv2.MORPH_TOPHAT,rectKernel)#顶帽=原始图像-开运算结果（先腐蚀后膨胀）
cv_show('tophat',tophat)
```

![](https://i-blog.csdnimg.cn/direct/e157b0dd7d6a4b7ebc467e6a8bccbe83.png)

#### 2.找到银行卡图片中的数字边框

①通过闭操作（先膨胀后腐蚀），将数字连在一起

将之前得到的顶帽后的图片进行闭操作，卷积核选择9*3的

```
closeX=cv2.morphologyEx(tophat,cv2.MORPH_CLOSE,rectKernel)
cv_show('closeX',closeX)
```

### 

②对闭操作后的图进行二值化处理

cv2.THRESH_OTSU会自动寻找适合的阈值，适合双峰，需要把阈值参数设置为0

```
#cv2.THRESH_OTSU会自动寻找适合的阈值，适合双峰，需要把阈值参数设置为0
thresh=cv2.threshold(closeX,0,255,cv2.THRESH_BINARY|cv2.THRESH_OTSU)[1]
cv_show('thresh_1',thresh)
```

![](https://i-blog.csdnimg.cn/direct/3af4648f3f4c447b94d4772890ba8773.png)

③对二值化后的黑白图载进行一次闭操作

这一次卷积核使用5*5的

```
#再来一次闭操作
thresh=cv2.morphologyEx(thresh,cv2.MORPH_CLOSE,sqKernel)
cv_show('thresh_2',thresh)
```

![](https://i-blog.csdnimg.cn/direct/a182b8038f2b498885613b196864c29a.png)

④找出最后闭操作的图中所有的轮廓

```
_,threshCnts,h=cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
cnts=threshCnts
```

在初始银行卡图片的副本上画出所有轮廓

```
cur_img=image.copy()
cv2.drawContours(cur_img,cnts,-1,(0,0,255),3)
cv_show('cur_img',cur_img)
```

![](https://i-blog.csdnimg.cn/direct/12c4ffab83a74508b1783d1f1b6cdee9.png)

⑤遍历找出的轮廓，找到数字部分像素区域轮廓的最小外接矩形并保存

**locs集和用来存放最后符合条件的四块数字区域轮廓的最小外界矩形的x,y,w和h的元组**

具体的判定条件，选择合适的区域，根据实际任务

```
locs=[]
for (i,c) in enumerate(cnts):
    (x,y,w,h)=cv2.boundingRect(c)
    ar=w/float(h)
    #选择合适的区域，根据实际任务
    if 2.5<ar<4.0:
        if 40<w<55 and 10<h<20:
            locs.append((x,y,w,h))
```

**将符合的轮廓外界矩形从左到右排序，根据x坐标**

```
locs=sorted(locs,key=lambda x:x[0])
```

#### 3.遍历上面得到的每一个轮廓矩形中的数字，再匹配每一个值

**output列表用来存放最后匹配得到的所有数字**

①切片获取数字区域

可以利用上面存储外界矩形信息的列表locs直接在银行卡的灰度图中切片出一块数字区域的外界矩形可以适当增加一些边界

**group_output列表存放每一个group中的所有数字**

```
output=[]
#遍历每一个轮廓中的数字
for (i,(gX,gY,gW,gH)) in enumerate(locs):
    group_output=[]
    group=gray[gY-5:gY+gH+5,gX-5:gX+gW+5]#适当加一点边界
    cv_show('group',group)
```

**这里我们直接将四次遍历后的图片都放出来但实际上是一次循环后才会出来后面的group图片**

![](https://i-blog.csdnimg.cn/direct/2f71569375a0496f9b8af0565031cd3f.png)![](https://i-blog.csdnimg.cn/direct/a959aa26194b491d95c1bb0acd945cbe.png)![](https://i-blog.csdnimg.cn/direct/fabbf8cb835046bc9a3e35b157339c92.png)![](https://i-blog.csdnimg.cn/direct/8be0f072aba0480b8fdb55b85dd5284d.png)

**注意：后续代码的缩进是表示还在此for循环中**

②对数字区域group图片进行二值化处理得到黑底白字

```
    group=cv2.threshold(group,0,255,cv2.THRESH_BINARY|cv2.THRESH_OTSU)[1]
    cv_show('group', group)
```

![](https://i-blog.csdnimg.cn/direct/9ace7480732e4245b8876687bb5a1861.png)

③找出group的中的所有数字外轮廓，再排序

```
                      
    group_,digitCnts,hierarchy=cv2.findContours(group.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
    digitCnts= myutils.sort_contours(digitCnts, method='left-to-right')[0]
```

④匹配group中的每一个数值

**对上面得到的group中的所有数字轮廓进行遍历，得到对应的外接矩形的信息后直接对group进行切片操作获取该数字的图片**

```
#计算每一组中的每一个数值
    for c in digitCnts:
        #找到当前数值的轮廓，resize成合适的大小
        (x,y,w,h)=cv2.boundingRect(c)
        roi=group[y:y+h,x:x+w]
        roi=cv2.resize(roi,(57,88))
        cv_show('roi',roi)
```

![](https://i-blog.csdnimg.cn/direct/d42751fba073411497e8d192fa0d6a1b.png)

⑤使用模板匹配，计算匹配得分

遍历前面存储数字和对应图片的字典

cv2.matchTemplate(roi,digitROI,cv2.TM_CCOEFF)在字典中的数字图片匹配当前roi返回结果

scores列表用来存放当前roi对每个字典中的数字图片的得分

```
  scores=[]
        #在模板中计算每一个得分
        for (digit,digitROI) in digits.items():
            #模板匹配
            result=cv2.matchTemplate(roi,digitROI,cv2.TM_CCOEFF)
            (_,score,_,_)=cv2.minMaxLoc(result)
            scores.append(score)
```

**往group_output中添加遍历字典后最大得分的索引直接对应相应的数字**

```
#得到合适的数字
        group_output.append(str(np.argmax(scores)))
```

⑥在遍历完一个group里的所有数值后直接在银行卡原图片画出该group外界矩阵并在上面写出对应数字

```
    cv2.rectangle(image,(gX-5,gY-5),(gX+gW+5,gY+gH+5),(0,0,255),3)
    cv2.putText(image,''.join(group_output),(gX,gY-15),cv2.FONT_HERSHEY_SIMPLEX,0.65,(0,0,255),2)
    output.extend(group_output)
```

#### 4.遍历所有的数字轮廓矩形后打印结果

Credit Card Type可以用最开始的银行类型字典来获取，output[0]就是第一位银行卡号

Credit Card就是将output列表的内容用‘’.join()直接连接起来返回字符串

最后显示识别后的银行卡号图

```
print('Credit Card Type:{}'.format(FIRST_NUMBER[output[0]]))
print('Credit Card #:{}'.format(''.join(output)))
cv2.imshow('Image',image)
cv2.waitKey(0)
```

![](https://i-blog.csdnimg.cn/direct/140458fd0f704da5ba99a456e61055a4.png)

![](https://i-blog.csdnimg.cn/direct/45baead87a1146f68e61cf51cd002375.png)



