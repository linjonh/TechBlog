---
layout: post
title: "Redis-底层数据结构源码剖析"
date: 2025-03-16 19:51:24 +0800
description: "Redis底层数据结构源码分析"
keywords: "Redis 底层数据结构源码剖析"
categories: ['Redis']
tags: ['数据结构', '数据库', 'Redis']
artid: "146240348"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146240348
    alt: "Redis-底层数据结构源码剖析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146240348
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146240348
cover: https://bing.ee123.net/img/rand?artid=146240348
image: https://bing.ee123.net/img/rand?artid=146240348
img: https://bing.ee123.net/img/rand?artid=146240348
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis 底层数据结构源码剖析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     一直好奇为什么 Redis 处理速度这么快，很大部分是因为数据结构设计的好，所以学习一下 Redis 数据结构的底层实现。
    </p>
    <p>
     Redis 发展到现在已经有 9 种数据类型了，其中最基础、最常用的数据类型有 5 种，它们分别是：字符串类型（String）、列表类型（List）、哈希表类型（Hash）、集合类型（Set）、有序集合类型（SortedSet/Zset）
    </p>
    <h3>
     <a id="redisObject_3">
     </a>
     redisObject
    </h3>
    <p>
     在 Redis 中，所有的对象都会包含 redisObject 对象头，
    </p>
    <pre><code class="prism language-c"><span class="token comment">//在 server.h 头文件中</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">/* 4 bit */</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">/* 4 bit */</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* 3 个字节 */</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>   <span class="token comment">/* 4 个字节 */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>  <span class="token comment">/* 8 个字节 */</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre>
    <p>
     它的参数说明如下：
    </p>
    <ul>
     <li>
      type：对象的数据类型，例如：string、list、hash 等，占用 4 bits 也就是半个字符的大小；
     </li>
     <li>
      encoding：对象数据编码，占用 4 bits；
     </li>
     <li>
      lru：记录对象的 LRU(Least Recently Used 的缩写，即最近最少使用)信息，内存回收时会用到此属性，占用 24 bits(3 字节)；
     </li>
     <li>
      refcount：引用计数器，占用 32 bits(4 字节)；
     </li>
     <li>
      *ptr：对象指针用于指向具体的内容，占用 64 bits(8 字节)。
     </li>
    </ul>
    <p>
     在我们使用
     <code>
      object encoding key
     </code>
     查看键值对的数据类型时，发现有不同的情况，
    </p>
    <ol>
     <li>
      <strong>
       int 类型
      </strong>
     </li>
    </ol>
    <pre><code class="prism language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key <span class="token number">666</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key
<span class="token string">"int"</span>
</code></pre>
    <ol start="2">
     <li>
      <strong>
       embstr 类型
      </strong>
     </li>
    </ol>
    <pre><code class="prism language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key abc
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key
<span class="token string">"embstr"</span>
</code></pre>
    <ol start="3">
     <li>
      <strong>
       raw 类型
      </strong>
     </li>
    </ol>
    <pre><code class="prism language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key abcdefghigklmnopqrstyvwxyzabcdefghigklmnopqrs
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key
<span class="token string">"raw"</span>
</code></pre>
    <p>
     存储整数时是 int 类型，存储字符串时是 embstr 类型，存储的字符串长度
     <strong>
      超过 44 个字节
     </strong>
     (Redis 5.0后)时数据类型是 raw 类型。
     <br/>
     在 Redis中，SDS 存储的值为 64字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储。64个字节包括了 Redis 对象头字节长度+ SDS 结构头字节长度+结束标识\0。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3d91705c1b8541f18d0e4316dee1051a.png"/>
    </p>
    <h3>
     <a id="_48">
     </a>
     字符串
    </h3>
    <p>
     Redis 中的字符串类型本质是 sds，sds 定义的结构体有五种 sdshdr5,sdshdr8,sdshdr16,sdshdr32,sdshdr64。
     <strong>
      sdshdr5已经不再使用
     </strong>
     ，如果字符串长度小于2的5次方，会把字符串长度设为2的8次方，即
     <code>
      sdshdr8
     </code>
     。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e0990c012d544a5389d0e3fbac065968.png"/>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>sds<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 字符串现有长度，8位无符号整型,小于 256 字节*/</span>  <span class="token comment">/*1字节*/</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 已分配的空间 */</span>	<span class="token comment">/*1字节*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* SDS 类型 */</span>	<span class="token comment">/*1字节*/</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 字符数组 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     SDS 定义多种结构体是为了灵活应对不同的数据长度，因为不同类型的结构体结构头占有字节大小也不同，可以更好地节省内存空间。
     <br/>
     除了结构头的优化外，Redis 还在编译器处理方面做了优化，比如
     <code>
      __attribute__ ((__packed__))
     </code>
     告诉编译器不采用字节对齐的方式分配内存，而是采用
     <strong>
      紧凑
     </strong>
     的方式分配内存，这是因为在默认情况下，编译器会按照 8 字节对齐的方式，给变量分配内存。也就是说，即使一个变量的大小不到 8 个字节，编译器也会给它分配 8 个字节。
    </p>
    <h3>
     <a id="_66">
     </a>
     字典
    </h3>
    <p>
     字典类型(hash)本质上是通过数组加链表结构组成的，添加时，如果哈希冲突就添加到链表的尾部（尾插法）。
    </p>
    <pre><code class="prism language-c"><span class="token comment">// dict.h</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{<!-- --></span>	
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>	<span class="token comment">// 下一个 dictEntry</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{<!-- --></span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{<!-- --></span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/*两个dictht，另一个用来 rehash*/</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment">/* 判断是否进行 rehash 的标识 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment">/* number of iterators currently running */</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/54b62612201248bcadecf5ebe3492b0f.png">
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/98c114b36fa94c158826eee3fd785e7f.png"/>
     </img>
    </p>
    <p>
     每次向字典中添加或删除时，需要判断是否进行 rehash，进行扩容或缩容
    </p>
    <ul>
     <li>
      扩容
      <br/>
      在
      <code>
       _dictExpandIfNeeded
      </code>
      方法中判断是否进行扩容或rehash
     </li>
    </ul>
    <pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">_dictExpandIfNeeded</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* 1. 已经扩容后 rehashidx = 0，直接开始 rehash  */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictIsRehashing</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>

    <span class="token comment">/* 2. 第一次初始化时，分配内存空间，不进行 rehash */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">dictExpand</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> DICT_HT_INITIAL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 3. ht[0]的已使用的长度大于ht[0]长度 或 ht[0]已使用的长度大于ht[0]长度的5倍时扩容 */</span>
    <span class="token comment">/* dict_can_resize 是为了确保在 fork 时不进行 rehash =》 bgsave 或 bgrewriteaof*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dict_can_resize <span class="token operator">==</span> DICT_RESIZE_ENABLE <span class="token operator">&amp;&amp;</span>
         d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">&gt;=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>dict_can_resize <span class="token operator">!=</span> DICT_RESIZE_FORBID <span class="token operator">&amp;&amp;</span>
         d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size <span class="token operator">&gt;</span> dict_force_resize_ratio<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">/*扩容为原来已用空间的两倍*/</span>
        <span class="token keyword">return</span> <span class="token function">dictExpand</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// DICT_OK = 0, rehashidx != -1, 开始进行 rehash</span>
    <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">dictExpand</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* 需要容量的小于当前容量，不需要扩容 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictIsRehashing</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">||</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>
        <span class="token keyword">return</span> DICT_ERR<span class="token punctuation">;</span>
    dictht n<span class="token punctuation">;</span> <span class="token comment">/* the new hash table */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> realsize <span class="token operator">=</span> <span class="token function">_dictNextPower</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 计算后的 realsize 等于当前容量大小，不需要扩容 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>realsize <span class="token operator">==</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> 
    	<span class="token keyword">return</span> DICT_ERR<span class="token punctuation">;</span>
    <span class="token comment">/* 分配一个新的哈希表，并初始化所有的指针指向 NULL，==》开始扩容 */</span>
    n<span class="token punctuation">.</span>size <span class="token operator">=</span> realsize<span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>sizemask <span class="token operator">=</span> realsize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token function">zcalloc</span><span class="token punctuation">(</span>realsize<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dictEntry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* 如果是第一次初始化，为 ht[0] 分配空间，直接返回 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 为 ht[1] 分配空间，rehashidx=0，准备 rehash */</span>
    d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
    d<span class="token operator">-&gt;</span>rehashidx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     从以上源码可以看出，如果需要扩容则会申请一个新的内存地址赋值给 ht[1]，并把字典的 rehashindex 设置为 0，表示之后需要进行 rehash 操作。
    </p>
    <ul>
     <li>
      缩容
      <br/>
      当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。
     </li>
    </ul>
    <p>
     扩容或缩容后，开始
     <strong>
      rehash
     </strong>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">_dictRehashStep</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>iterators <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">dictRehash</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">dictRehash</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// rehash 时, 遍历的 bucket 为空的次数是 n*10</span>
    <span class="token keyword">int</span> empty_visits <span class="token operator">=</span> n<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
	<span class="token comment">// 开始拷贝n个哈希桶, 直到原ht[0]个数等于0或哈希桶个数为0</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">&amp;&amp;</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">,</span> <span class="token operator">*</span>nextde<span class="token punctuation">;</span>

        <span class="token comment">// 从 empty_visit 个哈希桶中遍历 dictEntry!=null, 并开始 rehash</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            d<span class="token operator">-&gt;</span>rehashidx<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// empty_visits 为有限个 n*10, 如果多个 bucket 都为null, 直接返回, 防止一直阻塞主线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>empty_visits <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        de <span class="token operator">=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">/* 开始将 ht[0] 迁移到 ht[1] 中 */</span>
        <span class="token comment">/* 反转链表 */</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">uint64_t</span> h<span class="token punctuation">;</span>
            
            nextde <span class="token operator">=</span> de<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            h <span class="token operator">=</span> <span class="token function">dictHashKey</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> de<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span>
            de<span class="token operator">-&gt;</span>next <span class="token operator">=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span><span class="token punctuation">;</span>
            d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> de<span class="token punctuation">;</span>
            d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">--</span><span class="token punctuation">;</span>
            d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used<span class="token operator">++</span><span class="token punctuation">;</span>
            de <span class="token operator">=</span> nextde<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>d<span class="token operator">-&gt;</span>rehashidx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        d<span class="token operator">-&gt;</span>rehashidx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/* 已经迁移完成，释放原 ht[0] */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">zfree</span><span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">_dictReset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        d<span class="token operator">-&gt;</span>rehashidx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      rehashidx
     </code>
     变量表示的是当前 rehash 在对哪个 bucket 做数据迁移。比如，当 rehashidx 等于 0 时，表示对 ht[0]中的第一个 bucket 进行数据迁移；当 rehashidx 等于 1 时，表示对 ht[0]中的第二个 bucket 进行数据迁移，以此类推。
     <br/>
     当ht[0]容量已满，已扩容且将要 rehash 时，因为整个 hash 结构容量过大，如果直接把所有 bucket 进行 rehash 可能会阻塞主线程，会产生较大的
     <strong>
      rehash开销
     </strong>
     ， Redis 为了减少 rehash产生的开销（长时间阻塞主线程），采用了
     <strong>
      渐进式rehash
     </strong>
     的方式。在 rehash 时，如果遍历 bucket 次数为空的个数超过了 n*10（
     <code>
      empty_visit
     </code>
     ），则不再继续 rehash。
    </p>
    <h3>
     <a id="_208">
     </a>
     压缩链表
    </h3>
    <p>
     压缩链表在内存中是一块连续的内存空间，在
     <code>
      ziplist.h
     </code>
     中没有定义压缩链表的结构体
    </p>
    <pre><code class="prism language-c"><span class="token comment">/* Create a new empty ziplist. */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//初始分配的大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bytes <span class="token operator">=</span> ZIPLIST_HEADER_SIZE<span class="token operator">+</span>ZIPLIST_END_SIZE<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ZIPLIST_BYTES</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ZIPLIST_TAIL_OFFSET</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>ZIPLIST_HEADER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ZIPLIST_LENGTH</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//将列表尾设置为ZIP_END</span>
    zl<span class="token punctuation">[</span>bytes<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ZIP_END<span class="token punctuation">;</span>
    <span class="token keyword">return</span> zl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     创建一个新的 ziplist 后，ziplist的结构
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4d4329728667454ebb386bd1a8bf5566.png">
      <br/>
      当我们向 ziplist 中新增数据时，ziplist 会根据添加的是字符串还是数字，以及数据的大小进行不同的编码处理，这种根据数据大小进行相应编码的设计思想，正是 Redis 为了节省内存而采用的。
     </img>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span> <span class="token comment">// 前一个项使用的字节大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>	 <span class="token comment">// 前一个项的长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>		 <span class="token comment">// 当前项使用字节大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>			 <span class="token comment">// 当前项的长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">// headersize = prevrawlensize + lensize</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>      <span class="token comment">// 编码方式，比如 ZIP_STR_* 或 ZIP_INT_*</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>			 <span class="token comment">// 指向每一个当前项的起始位置, 也可以通过前一项的长度prev-entry-len确定 </span>
<span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/784df83130c64386b660931bbba39a8f.png"/>
    </p>
    <pre><code class="prism language-c"><span class="token comment">// ziplist.c</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">__ziplistInsert</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> slen<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 设置 prevlen 前一项的长度 1 或 5字节</span>
	reqlen <span class="token operator">+=</span> <span class="token function">zipStorePrevEntryLength</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 针对字符串或整数设置不同的编码大小</span>
    reqlen <span class="token operator">+=</span> <span class="token function">zipStoreEntryEncoding</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>encoding<span class="token punctuation">,</span>slen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">zipStorePrevEntryLength</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ZIP_BIG_PREVLEN=254</span>
	<span class="token comment">// len 前一项的字节大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> ZIP_BIG_PREVLEN<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// 判断prevlen的长度是否小于ZIP_BIG_PREVLEN</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> ZIP_BIG_PREVLEN<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 如果前一项的长度小于254字节，那么返回prevlen为1字节</span>
            p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 否则将 p[0] 设为 254, 且拷贝前一项长度从第二字节到第五字节</span>
	        <span class="token comment">// 返回prevlen大小为5字节</span>
            <span class="token keyword">return</span> <span class="token function">zipStorePrevEntryLengthLarge</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      前一项长度
      <strong>
       小于 254 字节
      </strong>
      ，prevlen 使用
      <strong>
       1字节
      </strong>
      空间保存这个长度值
     </li>
     <li>
      前一项长度
      <strong>
       大于等于 254 字节
      </strong>
      ，prevlen 使用
      <strong>
       5字节
      </strong>
      空间保存这个长度值
     </li>
    </ul>
    <h3>
     <a id="_271">
     </a>
     压缩链表的问题及改进
    </h3>
    <ul>
     <li>
      查找效率低
      <br/>
      压缩链表查找头节点尾节点效率很高，但是随机查找中间节点的效率较低
     </li>
     <li>
      连锁更新风险
      <br/>
      压缩链表可能存在
      <strong>
       连锁更新或内存的重分配
      </strong>
      问题，当前项的 prevlen 会根据前一个节点长度分配不同的空间，这可能会引发连锁更新的问题。
     </li>
    </ul>
    <p>
     假如有多个 zlentry，每个 zlentry 大小都在 250~253字节，现在新增了一个前置项，且大小超过了 254字节，后一项的 prevlen 无法用 1字节来保存新添加前一项的长度，需要扩容为 5字节，扩容后的当前项总大小超过了 254字节，同样导致后一项 prevlen 的扩容更新。
     <br/>
     所以压缩链表通常用来保存数量不多的情况，避免大量的连锁更新。Redis 后续版本对压缩链表发生的连锁更新等问题做了优化，比如quicklist 或 listpack。
    </p>
    <h4>
     <a id="quicklist_279">
     </a>
     quicklist
    </h4>
    <p>
     quicklist底层实际上使用了双向链表和压缩列表，
     <strong>
      一个quicklist就是一个双向链表，链表内的元素(quicklistNode)是一个 ziplist
     </strong>
     。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0462a96052dd442abba3a70c488a8b5f.png"/>
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>			 <span class="token comment">// 指向 ---- ziplist 的指针</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>             <span class="token comment">/* ziplist size in bytes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment">/* count of items in ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">/* RAW==1 or LZF==2 */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{<!-- --></span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">/* total count of all entries in all ziplists */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">/* number of quicklistNodes */</span>
    <span class="token keyword">int</span> fill <span class="token operator">:</span> QL_FILL_BITS<span class="token punctuation">;</span>              <span class="token comment">/* fill factor for individual nodes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> QL_COMP_BITS<span class="token punctuation">;</span> <span class="token comment">/* depth of end nodes not to compress;0=off */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bookmark_count<span class="token operator">:</span> QL_BM_BITS<span class="token punctuation">;</span>
    quicklistBookmark bookmarks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>
</code></pre>
    <p>
     quicklist 通过控制每个 quicklistNode 中，ziplist 的大小或是元素个数，就有效减少了在 ziplist 中新增或修改元素后，发生连锁更新的情况，从而提供了更好的访问性能。
     <br/>
     Redis 列表，底层就是 quicklist 实现的，虽然随机查询效率较低，但是 quicklist 的头尾节点查询效率很高，非常适合作为列表的数据结构，比如 lpush，rpush等从两端操作的命令。
    </p>
    <h4>
     <a id="listpack_306">
     </a>
     listpack
    </h4>
    <p>
     listpack 和 ziplist 结构类似也是连续紧凑的内存空间，区别在于 listpack 每一项存储的不再是前一项的字节长度，而是当前项的字节大小 ===》
     <strong>
      解决了连锁更新的问题
     </strong>
     。
     <br/>
     当我们在 listpack 中新增或修改元素时，实际上只会涉及每个列表项自己的操作，而不会影响后续列表项的长度变化，这就避免了连锁更新。
    </p>
    <p>
     listpack 是对压缩列表的改善，适合存储元素个数较少的情况，所以当 有序集合 和 字典 中当元素个数较少时，用 listpack 存储。
    </p>
    <h3>
     <a id="_312">
     </a>
     集合
    </h3>
    <p>
     集合（Set）底层是通过整数集合（intSet）或哈希表（hashtable）的形式存储的。
    </p>
    <ul>
     <li>
      当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null。
     </li>
     <li>
      当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储。
     </li>
    </ul>
    <p>
     当所有元素都为整数时，集合会以 intset 结构进行存储。
     <br/>
     当发生以下两种情况时，会导致集合类型使用 hashtable 存储：
     <br/>
     1）当元素的个数超过一定数量时，默认是 512 个，该值可通过命令
     <code>
      set-max-intset-entries xxx
     </code>
     来配置
     <br/>
     2）当元素为非整数时，集合将会使用 hashtable 来存储
    </p>
    <pre><code class="prism language-c"><span class="token comment">// 传入的 value 是 sds 类型，需要判断编码方式是整数还是字符串</span>
<span class="token keyword">int</span> <span class="token function">setTypeAdd</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>subject<span class="token punctuation">,</span> sds value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> llval<span class="token punctuation">;</span>
    <span class="token comment">// 编码方式是 hashtable</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_HT<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        dict <span class="token operator">*</span>ht <span class="token operator">=</span> subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">;</span>
        <span class="token comment">// hashkey = value, hashvalue = NULL</span>
        dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictAddRaw</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">dictSetKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>de<span class="token punctuation">,</span><span class="token function">sdsdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">dictSetVal</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>de<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_INTSET<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 编码方式是 intset</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSdsRepresentableAsLongLong</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>llval<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">uint8_t</span> success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            subject<span class="token operator">-&gt;</span>ptr <span class="token operator">=</span> <span class="token function">intsetAdd</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span>llval<span class="token punctuation">,</span><span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">size_t</span> max_entries <span class="token operator">=</span> server<span class="token punctuation">.</span>set_max_intset_entries<span class="token punctuation">;</span>
                <span class="token comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>max_entries <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">)</span> max_entries <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intsetLen</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span> <span class="token operator">&gt;</span> max_entries<span class="token punctuation">)</span>
                    <span class="token function">setTypeConvert</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span>OBJ_ENCODING_HT<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 转化为整数类型失败，使用字典类型存储</span>
            <span class="token function">setTypeConvert</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span>OBJ_ENCODING_HT<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">dictAdd</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span><span class="token function">sdsdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown set encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_362">
     </a>
     有序集合
    </h3>
    <p>
     在使用 Redis 的 zset 查询存储的数据时，无论是范围查询还是等值查询效率都非常高，底层使用了字典和跳表存储
    </p>
    <pre><code class="prism language-c"><span class="token comment">// server.h</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{<!-- --></span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>		<span class="token comment">// 字典</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span> <span class="token comment">// 跳表</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// zset 中的元素</span>
    sds ele<span class="token punctuation">;</span>
    <span class="token comment">// 元素的权重值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment">// </span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre>
    <p>
     当查询一个节点时，跳表会先从头节点的最高层开始，查找下一个节点。
     <br/>
     在查找时，先根据节点的权重值查找当前层，如果权重值小于目标权重值，则继续访问当前层的下一个节点，如果权重值相等，则比较 SDS 值是否和目标 SDS 值相等，如果小于 目标 SDS 值，则继续访问当前层的下一个节点。当这两个条件都不满足时，则使用当前 level 数组里的指针，跳转到下一层，接着查找。
    </p>
    <p>
     当跳表从最高层开始进行查找时，由于每一层结点数都约是下一层结点数的一半，这种查找过程就
     <strong>
      类似于二分查找
     </strong>
     ，查找复杂度可以降低到 O(logN)。但这种设计方法也会带来负面影响，那就是为了维持相邻两层上结点数的比例为 2:1，一旦有新的结点插入或是有结点被删除，那么插入或删除处的结点，及其后续结点的层数都需要进行调整，而这样就带来了额外的开销。
    </p>
    <p>
     跳表在创建结点时，采用的是另一种设计方法，即
     <strong>
      随机生成每个结点的层数
     </strong>
     。此时，相邻两层链表上的结点数并不需要维持在严格的 2:1 关系。这样一来，当新插入一个结点时，只需要修改前后结点的指针，而其他结点的层数就不需要随之改变了，这就降低了插入操作的复杂度。
    </p>
    <pre><code class="prism language-c"><span class="token comment">// t_zset.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZSKIPLIST_MAXLEVEL</span> <span class="token expression"><span class="token number">64</span>  </span><span class="token comment">//最大层数为64</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZSKIPLIST_P</span> <span class="token expression"><span class="token number">0.25</span>       </span><span class="token comment">//随机数的值为0.25</span></span>
<span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 初始化层数为 1</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>ZSKIPLIST_P <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        level <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>level<span class="token operator">&lt;</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token operator">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">zsetAdd</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>zobj<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>flags<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>newscore<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>zobj<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_ZIPLIST<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 编码方式是 skiplist</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>zobj<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_SKIPLIST<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        zset <span class="token operator">*</span>zs <span class="token operator">=</span> zobj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">;</span>
        zskiplistNode <span class="token operator">*</span>znode<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>

        <span class="token comment">// 从哈希表中查询新增的元素 ele</span>
        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果新元素存在</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>de <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* NX? Return, same element already exists. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nx<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token operator">*</span>flags <span class="token operator">|=</span> ZADD_NOP<span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 从 dict 中获取之前 key=ele 的 value:score</span>
            curscore <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* Prepare the score for the increment if needed. */</span>
            <span class="token comment">// 如果要更新元素的权重值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>incr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                score <span class="token operator">+=</span> curscore<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isnan</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token operator">*</span>flags <span class="token operator">|=</span> ZADD_NAN<span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>newscore<span class="token punctuation">)</span> <span class="token operator">*</span>newscore <span class="token operator">=</span> score<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">/* Remove and re-insert when score changes. */</span>
            <span class="token comment">//如果权重发生变化了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">!=</span> curscore<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//更新跳表结点</span>
                znode <span class="token operator">=</span> <span class="token function">zslUpdateScore</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>zsl<span class="token punctuation">,</span>curscore<span class="token punctuation">,</span>ele<span class="token punctuation">,</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//让哈希表元素的值指向跳表结点的权重</span>
                <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>znode<span class="token operator">-&gt;</span>score<span class="token punctuation">;</span>
                <span class="token operator">*</span>flags <span class="token operator">|=</span> ZADD_UPDATED<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment">// 如果新元素不存在</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>xx<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            ele <span class="token operator">=</span> <span class="token function">sdsdup</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 新插入跳表结点</span>
            znode <span class="token operator">=</span> <span class="token function">zslInsert</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>zsl<span class="token punctuation">,</span>score<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 新插入哈希表元素</span>
            <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">dictAdd</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>ele<span class="token punctuation">,</span><span class="token operator">&amp;</span>znode<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span> <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">*</span>flags <span class="token operator">|=</span> ZADD_ADDED<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newscore<span class="token punctuation">)</span> <span class="token operator">*</span>newscore <span class="token operator">=</span> score<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     Sorted Set 先是通过在它的数据结构中同时定义了跳表和哈希表，来实现同时使用这两种索引结构。然后，Sorted Set 在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。
    </p>
    <p>
     Sorted Set 既可以使用跳表支持数据的范围查询，还能使用哈希表支持根据元素直接查询它的权重。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37323430363132372f:61727469636c652f64657461696c732f313436323430333438" class_="artid" style="display:none">
 </p>
</div>


