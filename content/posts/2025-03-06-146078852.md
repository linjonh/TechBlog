---
layout: post
title: "TDengine-SQL查询语法"
date: 2025-03-06 20:27:01 +0800
description: "TDengine 中的查询 SQL 基本遵循 MYSQL 的查询语法，大部分查询都是通过超级表按时间维度进行的各种查询。TDengine 时序数据库以时间为主索引列进行数据组织排序及存储，同时按存储块做了预计算，所以在无普通列过滤的 SQL 查询语句中聚合函数查询会使用到预计算，如 sum count min max 等函数，查询速度会非常快。关于 TDengine 中的索引，不支持普通列创建索引，支持标签列创建索引，第一个标签列默认带索引，无需创建。"
keywords: "查询数据库字段名 tdegine"
categories: ['未分类']
tags: ['时序数据库', '数据库', '数据分析', '大数据', 'Tdengine', 'Sql', 'Iot']
artid: "146078852"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146078852
    alt: "TDengine-SQL查询语法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146078852
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146078852
cover: https://bing.ee123.net/img/rand?artid=146078852
image: https://bing.ee123.net/img/rand?artid=146078852
img: https://bing.ee123.net/img/rand?artid=146078852
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     TDengine SQL查询语法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     简介
    </h2>
    <p>
     TDengine 中的查询 SQL 基本遵循 MYSQL 的查询语法，大部分查询都是通过超级表按时间维度进行的各种查询。
    </p>
    <p>
     TDengine 时序数据库以时间为主索引列进行数据组织排序及存储，同时按存储块做了预计算，所以在无普通列过滤的 SQL 查询语句中聚合函数查询会使用到预计算，如 sum count min max 等函数，查询速度会非常快。
    </p>
    <p>
     关于 TDengine 中的索引，不支持普通列创建索引，支持标签列创建索引，第一个标签列默认带索引，无需创建。
    </p>
    <h3>
     <a id="_7">
     </a>
     查询语法
    </h3>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> {<!-- --><span class="token keyword">DATABASE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> CLIENT_VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> SERVER_VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> SERVER_STATUS<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> TODAY<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> TIMEZONE<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">CURRENT_USER</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">USER</span><span class="token punctuation">(</span><span class="token punctuation">)</span> }

<span class="token keyword">SELECT</span> <span class="token punctuation">[</span>hints<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>TAGS<span class="token punctuation">]</span> select_list
    from_clause
    <span class="token punctuation">[</span><span class="token keyword">WHERE</span> condition<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>partition_by_clause<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>interp_clause<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>window_clause<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>group_by_clause<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>order_by_clasue<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>SLIMIT limit_val <span class="token punctuation">[</span>SOFFSET offset_val<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token keyword">LIMIT</span> limit_val <span class="token punctuation">[</span><span class="token keyword">OFFSET</span> offset_val<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token operator">&gt;&gt;</span> export_file<span class="token punctuation">]</span>

hints: <span class="token comment">/*+ [hint([hint_param_list])] [hint([hint_param_list])] */</span>

hint:
    BATCH_SCAN <span class="token operator">|</span> NO_BATCH_SCAN <span class="token operator">|</span> SORT_FOR_GROUP <span class="token operator">|</span> PARTITION_FIRST <span class="token operator">|</span> PARA_TABLES_SORT <span class="token operator">|</span> SMALLDATA_TS_SORT

select_list:
    select_expr <span class="token punctuation">[</span><span class="token punctuation">,</span> select_expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

select_expr: {
    <span class="token operator">*</span>
  <span class="token operator">|</span> query_name<span class="token punctuation">.</span><span class="token operator">*</span>
  <span class="token operator">|</span> <span class="token punctuation">[</span>schema_name<span class="token punctuation">.</span><span class="token punctuation">]</span> {table_name <span class="token operator">|</span> view_name} <span class="token punctuation">.</span><span class="token operator">*</span>
  <span class="token operator">|</span> t_alias<span class="token punctuation">.</span><span class="token operator">*</span>
  <span class="token operator">|</span> expr <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">AS</span><span class="token punctuation">]</span> c_alias<span class="token punctuation">]</span>
}

from_clause: {
    table_reference <span class="token punctuation">[</span><span class="token punctuation">,</span> table_reference<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token operator">|</span> table_reference join_clause <span class="token punctuation">[</span><span class="token punctuation">,</span> join_clause<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
}

table_reference:
    table_expr t_alias

table_expr: {
    table_name
  <span class="token operator">|</span> view_name
  <span class="token operator">|</span> <span class="token punctuation">(</span> subquery <span class="token punctuation">)</span>
}

join_clause:
    <span class="token punctuation">[</span><span class="token keyword">INNER</span><span class="token operator">|</span><span class="token keyword">LEFT</span><span class="token operator">|</span><span class="token keyword">RIGHT</span><span class="token operator">|</span><span class="token keyword">FULL</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">OUTER</span><span class="token operator">|</span>SEMI<span class="token operator">|</span>ANTI<span class="token operator">|</span>ASOF<span class="token operator">|</span>WINDOW<span class="token punctuation">]</span> <span class="token keyword">JOIN</span> table_reference <span class="token punctuation">[</span><span class="token keyword">ON</span> condition<span class="token punctuation">]</span> <span class="token punctuation">[</span>WINDOW_OFFSET<span class="token punctuation">(</span>start_offset<span class="token punctuation">,</span> end_offset<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>JLIMIT jlimit_num<span class="token punctuation">]</span>

window_clause: {
    <span class="token keyword">SESSION</span><span class="token punctuation">(</span>ts_col<span class="token punctuation">,</span> tol_val<span class="token punctuation">)</span>
  <span class="token operator">|</span> STATE_WINDOW<span class="token punctuation">(</span>col<span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token keyword">INTERVAL</span><span class="token punctuation">(</span>interval_val <span class="token punctuation">[</span><span class="token punctuation">,</span> interval_offset<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>SLIDING <span class="token punctuation">(</span>sliding_val<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>WATERMARK<span class="token punctuation">(</span>watermark_val<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>FILL<span class="token punctuation">(</span>fill_mod_and_val<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token operator">|</span> EVENT_WINDOW <span class="token keyword">START</span> <span class="token keyword">WITH</span> start_trigger_condition <span class="token keyword">END</span> <span class="token keyword">WITH</span> end_trigger_condition
  <span class="token operator">|</span> COUNT_WINDOW<span class="token punctuation">(</span>count_val<span class="token punctuation">[</span><span class="token punctuation">,</span> sliding_val<span class="token punctuation">]</span><span class="token punctuation">)</span>

interp_clause:
      RANGE<span class="token punctuation">(</span>ts_val <span class="token punctuation">[</span><span class="token punctuation">,</span> ts_val<span class="token punctuation">]</span><span class="token punctuation">)</span> EVERY<span class="token punctuation">(</span>every_val<span class="token punctuation">)</span> FILL<span class="token punctuation">(</span>fill_mod_and_val<span class="token punctuation">)</span>
    <span class="token operator">|</span> RANGE<span class="token punctuation">(</span>ts_val<span class="token punctuation">,</span> surrounding_time_val<span class="token punctuation">)</span> FILL<span class="token punctuation">(</span>fill_mod_and_val<span class="token punctuation">)</span>

partition_by_clause:
    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> partition_by_expr <span class="token punctuation">[</span><span class="token punctuation">,</span> partition_by_expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

partition_by_expr:
    {expr <span class="token operator">|</span> position <span class="token operator">|</span> c_alias}

group_by_clause:
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> group_by_expr <span class="token punctuation">[</span><span class="token punctuation">,</span> group_by_expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">HAVING</span> condition
                                                    
group_by_expr:
    {expr <span class="token operator">|</span> position <span class="token operator">|</span> c_alias}

order_by_clasue:
    <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> order_expr <span class="token punctuation">[</span><span class="token punctuation">,</span> order_expr<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

order_expr:
    {expr <span class="token operator">|</span> position <span class="token operator">|</span> c_alias} <span class="token punctuation">[</span><span class="token keyword">DESC</span> <span class="token operator">|</span> <span class="token keyword">ASC</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>NULLS <span class="token keyword">FIRST</span> <span class="token operator">|</span> NULLS <span class="token keyword">LAST</span><span class="token punctuation">]</span>
</code></pre>
    <h3>
     <a id="Hints_87">
     </a>
     Hints
    </h3>
    <p>
     Hints 是用户控制单个语句查询优化的一种手段，当 Hint 不适用于当前的查询语句时会被自动忽略，具体说明如下：
    </p>
    <ul>
     <li>
      Hints 语法以
      <code>
       /*+
      </code>
      开始，终于
      <code>
       */
      </code>
      ，前后可有空格。
     </li>
     <li>
      Hints 语法只能跟随在 SELECT 关键字后。
     </li>
     <li>
      每个 Hints 可以包含多个 Hint，Hint 间以空格分开，当多个 Hint 冲突或相同时以先出现的为准。
     </li>
     <li>
      当 Hints 中某个 Hint 出现错误时，错误出现之前的有效 Hint 仍然有效，当前及之后的 Hint 被忽略。
     </li>
     <li>
      hint_param_list 是每个 Hint 的参数，根据每个 Hint 的不同而不同。
     </li>
    </ul>
    <p>
     目前支持的 Hints 列表如下：
    </p>
    <table>
     <thead>
      <tr>
       <th align="center">
        <strong>
         Hint
        </strong>
       </th>
       <th>
        <strong>
         参数
        </strong>
       </th>
       <th>
        <strong>
         说明
        </strong>
       </th>
       <th>
        <strong>
         适用范围
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="center">
        BATCH_SCAN
       </td>
       <td>
        无
       </td>
       <td>
        采用批量读表的方式
       </td>
       <td>
        超级表 JOIN 语句
       </td>
      </tr>
      <tr>
       <td align="center">
        NO_BATCH_SCAN
       </td>
       <td>
        无
       </td>
       <td>
        采用顺序读表的方式
       </td>
       <td>
        超级表 JOIN 语句
       </td>
      </tr>
      <tr>
       <td align="center">
        SORT_FOR_GROUP
       </td>
       <td>
        无
       </td>
       <td>
        采用 sort 方式进行分组，与 PARTITION_FIRST 冲突
       </td>
       <td>
        partition by 列表有普通列时
       </td>
      </tr>
      <tr>
       <td align="center">
        PARTITION_FIRST
       </td>
       <td>
        无
       </td>
       <td>
        在聚合之前使用 PARTITION 计算分组，与 SORT_FOR_GROUP 冲突
       </td>
       <td>
        partition by 列表有普通列时
       </td>
      </tr>
      <tr>
       <td align="center">
        PARA_TABLES_SORT
       </td>
       <td>
        无
       </td>
       <td>
        超级表的数据按时间戳排序时，不使用临时磁盘空间，只使用内存。当子表数量多，行长比较大时候，会使用大量内存，可能发生 OOM
       </td>
       <td>
        超级表的数据按时间戳排序时
       </td>
      </tr>
      <tr>
       <td align="center">
        SMALLDATA_TS_SORT
       </td>
       <td>
        无
       </td>
       <td>
        超级表的数据按时间戳排序时，查询列长度大于等于 256，但是行数不多，使用这个提示，可以提高性能
       </td>
       <td>
        超级表的数据按时间戳排序时
       </td>
      </tr>
      <tr>
       <td align="center">
        SKIP_TSMA
       </td>
       <td>
        无
       </td>
       <td>
        用于显示的禁用 TSMA 查询优化
       </td>
       <td>
        带 Agg 函数的查询语句
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     举例：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token comment">/*+ BATCH_SCAN() */</span> a<span class="token punctuation">.</span>ts <span class="token keyword">FROM</span> stable1 a<span class="token punctuation">,</span> stable2 b <span class="token keyword">where</span> a<span class="token punctuation">.</span>tag0 <span class="token operator">=</span> b<span class="token punctuation">.</span>tag0 <span class="token operator">and</span> a<span class="token punctuation">.</span>ts <span class="token operator">=</span> b<span class="token punctuation">.</span>ts<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token comment">/*+ SORT_FOR_GROUP() */</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1 <span class="token keyword">FROM</span> stable1 <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> c1<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token comment">/*+ PARTITION_FIRST() */</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1 <span class="token keyword">FROM</span> stable1 <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> c1<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token comment">/*+ PARA_TABLES_SORT() */</span> <span class="token operator">*</span> <span class="token keyword">from</span> stable1 <span class="token keyword">order</span> <span class="token keyword">by</span> ts<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token comment">/*+ SMALLDATA_TS_SORT() */</span> <span class="token operator">*</span> <span class="token keyword">from</span> stable1 <span class="token keyword">order</span> <span class="token keyword">by</span> ts<span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="_119">
     </a>
     列表
    </h3>
    <p>
     查询语句可以指定部分或全部列作为返回结果。数据列和标签列都可以出现在列表中。
    </p>
    <h4>
     <a id="_123">
     </a>
     通配符
    </h4>
    <p>
     通配符 * 可以用于代指全部列。对于普通表和子表，结果中只有普通列。对于超级表，还包含了 TAG 列。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> d1001<span class="token punctuation">;</span>
</code></pre>
    <p>
     通配符支持表名前缀，以下两个 SQL 语句均为返回全部的列：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> d1001<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> d1001<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> d1001<span class="token punctuation">;</span>
</code></pre>
    <p>
     在 JOIN 查询中，带表名前缀的*和不带前缀*返回的结果有差别， *返回全部表的所有列数据（不包含标签），而带表名前缀的通配符，则只返回该表的列数据。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> d1001<span class="token punctuation">,</span> d1003 <span class="token keyword">WHERE</span> d1001<span class="token punctuation">.</span>ts<span class="token operator">=</span>d1003<span class="token punctuation">.</span>ts<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> d1001<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> d1001<span class="token punctuation">,</span>d1003 <span class="token keyword">WHERE</span> d1001<span class="token punctuation">.</span>ts <span class="token operator">=</span> d1003<span class="token punctuation">.</span>ts<span class="token punctuation">;</span>
</code></pre>
    <p>
     上面的查询语句中，前者返回 d1001 和 d1003 的全部列，而后者仅返回 d1001 的全部列。
    </p>
    <p>
     在使用 SQL 函数来进行查询的过程中，部分 SQL 函数支持通配符操作。其中的区别在于：
     <br/>
     <code>
      count(*)
     </code>
     函数只返回一列。
     <code>
      first
     </code>
     、
     <code>
      last
     </code>
     、
     <code>
      last_row
     </code>
     函数则是返回全部列。
    </p>
    <h4>
     <a id="_150">
     </a>
     标签列
    </h4>
    <p>
     在超级表和子表的查询中可以指定
     <em>
      标签列
     </em>
     ，且标签列的值会与普通列的数据一起返回。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> location<span class="token punctuation">,</span> groupid<span class="token punctuation">,</span> <span class="token keyword">current</span> <span class="token keyword">FROM</span> d1001 <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_158">
     </a>
     别名
    </h4>
    <p>
     别名的命名规则与列相同，支持直接指定 UTF-8 编码格式的中文别名。
    </p>
    <h4>
     <a id="_161">
     </a>
     结果去重
    </h4>
    <p>
     <code>
      DISTINCT
     </code>
     关键字可以对结果集中的一列或多列进行去重，去除的列既可以是标签列也可以是数据列。
    </p>
    <p>
     对标签列去重：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> tag_name <span class="token punctuation">[</span><span class="token punctuation">,</span> tag_name <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">FROM</span> stb_name<span class="token punctuation">;</span>
</code></pre>
    <p>
     对数据列去重：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> col_name <span class="token punctuation">[</span><span class="token punctuation">,</span> col_name <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">FROM</span> tb_name<span class="token punctuation">;</span>
</code></pre>
    <p>
     :::info
    </p>
    <ol>
     <li>
      cfg 文件中的配置参数 maxNumOfDistinctRes 将对 DISTINCT 能够输出的数据行数进行限制。其最小值是 100000，最大值是 100000000，默认值是 10000000。如果实际计算结果超出了这个限制，那么会仅输出这个数量范围内的部分。
     </li>
     <li>
      由于浮点数天然的精度机制原因，在特定情况下，对 FLOAT 和 DOUBLE 列使用 DISTINCT 并不能保证输出值的完全唯一性。
     </li>
    </ol>
    <p>
     :::
    </p>
    <h4>
     <a id="_184">
     </a>
     标签查询
    </h4>
    <p>
     当查询的列只有标签列时，
     <code>
      TAGS
     </code>
     关键字可以指定返回所有子表的标签列。每个子表只返回一行标签列。
    </p>
    <p>
     返回所有子表的标签列：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> TAGS tag_name <span class="token punctuation">[</span><span class="token punctuation">,</span> tag_name <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">FROM</span> stb_name
</code></pre>
    <h4>
     <a id="_194">
     </a>
     结果集列名
    </h4>
    <p>
     <code>
      SELECT
     </code>
     子句中，如果不指定返回结果集合的列名，结果集列名称默认使用
     <code>
      SELECT
     </code>
     子句中的表达式名称作为列名称。此外，用户可使用
     <code>
      AS
     </code>
     来重命名返回结果集合中列的名称。例如：
    </p>
    <pre><code class="prism language-sql">taos<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> ts<span class="token punctuation">,</span> ts <span class="token keyword">AS</span> primary_key_ts <span class="token keyword">FROM</span> d1001<span class="token punctuation">;</span>
</code></pre>
    <p>
     但是针对
     <code>
      first(*)
     </code>
     、
     <code>
      last(*)
     </code>
     、
     <code>
      last_row(*)
     </code>
     不支持针对单列的重命名。
    </p>
    <h4>
     <a id="_204">
     </a>
     伪列
    </h4>
    <p>
     <strong>
      伪列
     </strong>
     : 伪列的行为表现与普通数据列相似但其并不实际存储在表中。可以查询伪列，但不能对其做插入、更新和删除的操作。伪列有点像没有参数的函数。下面介绍是可用的伪列：
    </p>
    <p>
     <strong>
      TBNAME
     </strong>
     <br/>
     <code>
      TBNAME
     </code>
     可以视为超级表中一个特殊的标签，代表子表的表名。
    </p>
    <p>
     获取一个超级表所有的子表名及相关的标签信息：
    </p>
    <pre><code class="prism language-mysql">SELECT TAGS TBNAME, location FROM meters;
</code></pre>
    <p>
     建议用户使用 INFORMATION_SCHEMA 下的 INS_TAGS 系统表来查询超级表的子表标签信息，例如获取超级表 meters 所有的子表名和标签值：
    </p>
    <pre><code class="prism language-mysql">SELECT table_name, tag_name, tag_type, tag_value FROM information_schema.ins_tags WHERE stable_name='meters';
</code></pre>
    <p>
     统计超级表下辖子表数量：
    </p>
    <pre><code class="prism language-mysql">SELECT COUNT(*) FROM (SELECT DISTINCT TBNAME FROM meters);
</code></pre>
    <p>
     以上两个查询均只支持在 WHERE 条件子句中添加针对标签（TAGS）的过滤条件。
    </p>
    <p>
     <strong>
      _QSTART/_QEND
     </strong>
    </p>
    <p>
     _qstart 和_qend 表示用户输入的查询时间范围，即 WHERE 子句中主键时间戳条件所限定的时间范围。如果 WHERE 子句中没有有效的主键时间戳条件，则时间范围为[-2^63, 2^63-1]。
    </p>
    <p>
     _qstart 和_qend 不能用于 WHERE 子句中。
    </p>
    <p>
     <strong>
      _WSTART/_WEND/_WDURATION
     </strong>
     <br/>
     _wstart 伪列、_wend 伪列和_wduration 伪列
     <br/>
     _wstart 表示窗口起始时间戳，_wend 表示窗口结束时间戳，_wduration 表示窗口持续时长。
    </p>
    <p>
     这三个伪列只能用于时间窗口的窗口切分查询之中，且要在窗口切分子句之后出现。
    </p>
    <p>
     <strong>
      _c0/_ROWTS
     </strong>
    </p>
    <p>
     TDengine 中，所有表的第一列都必须是时间戳类型，且为其主键，_rowts 伪列和_c0 伪列均代表了此列的值。相比实际的主键时间戳列，使用伪列更加灵活，语义也更加标准。例如，可以和 max\min 等函数一起使用。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">select</span> _rowts<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">current</span><span class="token punctuation">)</span> <span class="token keyword">from</span> meters<span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      _IROWTS
     </strong>
    </p>
    <p>
     _irowts 伪列只能与 interp 函数一起使用，用于返回 interp 函数插值结果对应的时间戳列。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">select</span> _irowts<span class="token punctuation">,</span> interp<span class="token punctuation">(</span><span class="token keyword">current</span><span class="token punctuation">)</span> <span class="token keyword">from</span> meters range<span class="token punctuation">(</span><span class="token string">'2020-01-01 10:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-01 10:30:00'</span><span class="token punctuation">)</span> every<span class="token punctuation">(</span><span class="token number">1</span>s<span class="token punctuation">)</span> fill<span class="token punctuation">(</span>linear<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      _IROWTS_ORIGIN
     </strong>
     <br/>
     <code>
      _irowts_origin
     </code>
     伪列只能与 interp 函数一起使用，不支持在流计算中使用, 仅适用于FILL类型为PREV/NEXT/NEAR, 用于返回 interp 函数所使用的原始数据的时间戳列。若范围内无值, 则返回 NULL。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">select</span> _iorwts_origin<span class="token punctuation">,</span> interp<span class="token punctuation">(</span><span class="token keyword">current</span><span class="token punctuation">)</span> <span class="token keyword">from</span> meters range<span class="token punctuation">(</span><span class="token string">'2020-01-01 10:00:00'</span><span class="token punctuation">,</span> <span class="token string">'2020-01-01 10:30:00'</span><span class="token punctuation">)</span> every<span class="token punctuation">(</span><span class="token number">1</span>s<span class="token punctuation">)</span> fill<span class="token punctuation">(</span><span class="token keyword">NEXT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="_266">
     </a>
     查询对象
    </h3>
    <p>
     FROM 关键字后面可以是若干个表（超级表）列表，也可以是子查询的结果。
     <br/>
     如果没有指定用户的当前数据库，可以在表名称之前使用数据库的名称来指定表所属的数据库。例如：
     <code>
      power.d1001
     </code>
     方式来跨库使用表。
    </p>
    <p>
     TDengine 支持基于时间戳主键的 INNER JOIN，规则如下：
    </p>
    <ol>
     <li>
      支持 FROM 表列表和显式的 JOIN 子句两种语法。
     </li>
     <li>
      对于普通表和子表，ON 条件必须有且只有时间戳主键的等值条件。
     </li>
     <li>
      对于超级表，ON 条件在时间戳主键的等值条件之外，还要求有可以一一对应的标签列等值条件，不支持 OR 条件。
     </li>
     <li>
      参与 JOIN 计算的表只能是同一种类型，即只能都是超级表，或都是子表，或都是普通表。
     </li>
     <li>
      JOIN 两侧均支持子查询。
     </li>
     <li>
      不支持与 FILL 子句混合使用。
     </li>
    </ol>
    <h3>
     <a id="GROUP_BY_280">
     </a>
     GROUP BY
    </h3>
    <p>
     如果在语句中同时指定了 GROUP BY 子句，那么 SELECT 列表只能包含如下表达式：
    </p>
    <ol>
     <li>
      常量
     </li>
     <li>
      聚集函数
     </li>
     <li>
      与 GROUP BY 后表达式相同的表达式。
     </li>
     <li>
      包含前面表达式的表达式
     </li>
    </ol>
    <p>
     GROUP BY 子句对每行数据按 GROUP BY 后的表达式的值进行分组，并为每个组返回一行汇总信息。
    </p>
    <p>
     GROUP BY 子句中可以通过指定表或视图的列名来按照表或视图中的任何列分组，这些列不需要出现在 SELECT 列表中。
    </p>
    <p>
     GROUP BY 子句中可以使用位置语法，位置标识为正整数，从 1 开始，表示使用 SELECT 列表的第几个表达式进行分组。
    </p>
    <p>
     GROUP BY 子句中可以使用结果集列名，表示使用 SELECT 列表的指定表达式进行分组。
    </p>
    <p>
     GROUP BY 子句中在使用位置语法和结果集列名进行分组时，其对应的 SELECT 列表中的表达式不能是聚集函数。
    </p>
    <p>
     该子句对行进行分组，但不保证结果集的顺序。若要对分组进行排序，请使用 ORDER BY 子句
    </p>
    <h3>
     <a id="PARTITION_BY_302">
     </a>
     PARTITION BY
    </h3>
    <p>
     PARTITION BY 子句是 TDengine 3.0版本引入的特色语法，用于根据 part_list 对数据进行切分，在每个切分的分片中可以进行各种计算。
    </p>
    <p>
     PARTITION BY 与 GROUP BY 基本含义相似，都是按照指定列表进行数据分组然后进行计算，不同点在于 PARTITION BY 没有 GROUP BY 子句的 SELECT 列表的各种限制，组内可以进行任意运算（常量、聚合、标量、表达式等），因此在使用上 PARTITION BY 完全兼容 GROUP BY，所有使用 GROUP BY 子句的地方都可以替换为 PARTITION BY, 需要注意的是在没有聚合查询时两者的查询结果可能存在差异。
    </p>
    <p>
     因为 PARTITION BY 没有返回一行聚合数据的要求，因此还可以支持在分组切片后的各种窗口运算，所有需要分组进行的窗口运算都只能使用 PARTITION BY 子句。
    </p>
    <p>
     详见 TDengine 特色查询
    </p>
    <h3>
     <a id="ORDER_BY_313">
     </a>
     ORDER BY
    </h3>
    <p>
     ORDER BY 子句对结果集排序。如果没有指定 ORDER BY，无法保证同一语句多次查询的结果集返回顺序一致。
    </p>
    <p>
     ORDER BY 后可以使用位置语法，位置标识为正整数，从 1 开始，表示使用 SELECT 列表的第几个表达式进行排序。
    </p>
    <p>
     ASC 表示升序，DESC 表示降序。
    </p>
    <p>
     NULLS 语法用来指定 NULL 值在排序中输出的位置。NULLS LAST 是升序的默认值，NULLS FIRST 是降序的默认值。
    </p>
    <h3>
     <a id="LIMIT_323">
     </a>
     LIMIT
    </h3>
    <p>
     LIMIT 控制输出条数，OFFSET 指定从第几条之后开始输出。LIMIT/OFFSET 对结果集的执行顺序在 ORDER BY 之后。
     <code>
      LIMIT 5 OFFSET 2
     </code>
     可以简写为
     <code>
      LIMIT 2, 5
     </code>
     ，都输出第 3 行到第 7 行数据。
    </p>
    <p>
     在有 PARTITION BY/GROUP BY 子句时，LIMIT 控制的是每个切分的分片中的输出，而不是总的结果集输出。
    </p>
    <h3>
     <a id="SLIMIT_329">
     </a>
     SLIMIT
    </h3>
    <p>
     SLIMIT 和 PARTITION BY/GROUP BY 子句一起使用，用来控制输出的分片的数量。
     <code>
      SLIMIT 5 SOFFSET 2
     </code>
     可以简写为 SLIMIT
     <code>
      2, 5
     </code>
     ，都表示输出第 3 个到第 7 个分片。
    </p>
    <p>
     需要注意，如果有 ORDER BY 子句，则输出只有一个分片。
    </p>
    <h3>
     <a id="_335">
     </a>
     特殊功能
    </h3>
    <p>
     部分特殊的查询功能可以不使用 FROM 子句执行。
    </p>
    <h4>
     <a id="_339">
     </a>
     获取当前数据库
    </h4>
    <p>
     下面的命令可以获取当前所在的数据库 database()，如果登录的时候没有指定默认数据库，且没有使用
     <code>
      USE
     </code>
     命令切换数据，则返回 NULL。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DATABASE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_347">
     </a>
     获取服务器和客户端版本号
    </h4>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> CLIENT_VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> SERVER_VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_354">
     </a>
     获取服务器状态
    </h4>
    <p>
     服务器状态检测语句。如果服务器正常，返回一个数字（例如 1）。如果服务器异常，返回 error code。该 SQL 语法能兼容连接池对于 TDengine 状态的检查及第三方工具对于数据库服务器状态的检查。并可以避免出现使用了错误的心跳检测 SQL 语句导致的连接池连接丢失的问题。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> SERVER_STATUS<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_362">
     </a>
     获取当前时间
    </h4>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_368">
     </a>
     获取当前日期
    </h4>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> TODAY<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_374">
     </a>
     获取当前时区
    </h4>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> TIMEZONE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="_380">
     </a>
     获取当前用户
    </h4>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CURRENT_USER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="_386">
     </a>
     正则表达式过滤
    </h3>
    <h4>
     <a id="_388">
     </a>
     语法
    </h4>
    <pre><code class="prism language-txt">WHERE (column|tbname) match/MATCH/nmatch/NMATCH _regex_
</code></pre>
    <h4>
     <a id="_394">
     </a>
     正则表达式规范
    </h4>
    <p>
     确保使用的正则表达式符合 POSIX 的规范，具体规范内容可参见
     <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html" rel="nofollow">
      Regular Expressions
     </a>
    </p>
    <h4>
     <a id="_398">
     </a>
     使用限制
    </h4>
    <p>
     只能针对表名（即 tbname 筛选）、binary/nchar 类型值进行正则表达式过滤。
    </p>
    <p>
     正则匹配字符串长度不能超过 128 字节。可以通过参数
     <em>
      maxRegexStringLen
     </em>
     设置和调整最大允许的正则匹配字符串，该参数是客户端配置参数，需要重启才能生效。
    </p>
    <h3>
     <a id="CASE__404">
     </a>
     CASE 表达式
    </h3>
    <h4>
     <a id="_406">
     </a>
     语法
    </h4>
    <pre><code class="prism language-txt">CASE value WHEN compare_value THEN result [WHEN compare_value THEN result ...] [ELSE result] END
CASE WHEN condition THEN result [WHEN condition THEN result ...] [ELSE result] END
</code></pre>
    <h4>
     <a id="_413">
     </a>
     说明
    </h4>
    <p>
     TDengine 通过 CASE 表达式让用户可以在 SQL 语句中使用 IF … THEN … ELSE 逻辑。
    </p>
    <p>
     第一种 CASE 语法返回第一个 value 等于 compare_value 的 result，如果没有 compare_value 符合，则返回 ELSE 之后的 result，如果没有 ELSE 部分，则返回 NULL。
    </p>
    <p>
     第二种语法返回第一个 condition 为真的 result。 如果没有 condition 符合，则返回 ELSE 之后的 result，如果没有 ELSE 部分，则返回 NULL。
    </p>
    <p>
     CASE 表达式的返回类型为第一个 WHEN THEN 部分的 result 类型，其余 WHEN THEN 部分和 ELSE 部分，result 类型都需要可以向其转换，否则 TDengine 会报错。
    </p>
    <h4>
     <a id="_423">
     </a>
     示例
    </h4>
    <p>
     某设备有三个状态码，显示其状态，语句如下：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CASE</span> dev_status <span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'Running'</span> <span class="token keyword">WHEN</span> <span class="token number">2</span> <span class="token keyword">THEN</span> <span class="token string">'Warning'</span> <span class="token keyword">WHEN</span> <span class="token number">3</span> <span class="token keyword">THEN</span> <span class="token string">'Downtime'</span> <span class="token keyword">ELSE</span> <span class="token string">'Unknown'</span> <span class="token keyword">END</span> <span class="token keyword">FROM</span> dev_table<span class="token punctuation">;</span>
</code></pre>
    <p>
     统计智能电表的电压平均值，当电压小于 200 或大于 250 时认为是统计有误，修正其值为 220，语句如下：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> voltage <span class="token operator">&lt;</span> <span class="token number">200</span> <span class="token operator">or</span> voltage <span class="token operator">&gt;</span> <span class="token number">250</span> <span class="token keyword">THEN</span> <span class="token number">220</span> <span class="token keyword">ELSE</span> voltage <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> meters<span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="JOIN__437">
     </a>
     JOIN 子句
    </h3>
    <p>
     在 3.3.0.0 版本之前 TDengine 只支持内连接，自 3.3.0.0 版本起 TDengine 支持了更为广泛的 JOIN 类型，这其中既包括传统数据库中的 LEFT JOIN、RIGHT JOIN、FULL JOIN、SEMI JOIN、ANTI-SEMI JOIN，也包括时序库中特色的 ASOF JOIN、WINDOW JOIN。JOIN 操作支持在子表、普通表、超级表以及子查询间进行。
    </p>
    <h4>
     <a id="_441">
     </a>
     示例
    </h4>
    <p>
     普通表与普通表之间的 JOIN 操作：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> temp_tb_1 t1<span class="token punctuation">,</span> pressure_tb_1 t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>ts <span class="token operator">=</span> t2<span class="token punctuation">.</span>ts
</code></pre>
    <p>
     超级表与超级表之间的 LEFT JOIN 操作：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> temp_stable t1 <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> temp_stable t2
<span class="token keyword">ON</span> t1<span class="token punctuation">.</span>ts <span class="token operator">=</span> t2<span class="token punctuation">.</span>ts <span class="token operator">AND</span> t1<span class="token punctuation">.</span>deviceid <span class="token operator">=</span> t2<span class="token punctuation">.</span>deviceid <span class="token operator">AND</span> t1<span class="token punctuation">.</span><span class="token keyword">status</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     子表与超级表之间的 LEFT ASOF JOIN 操作：
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> temp_ctable t1 <span class="token keyword">LEFT</span> ASOF <span class="token keyword">JOIN</span> temp_stable t2
<span class="token keyword">ON</span> t1<span class="token punctuation">.</span>ts <span class="token operator">=</span> t2<span class="token punctuation">.</span>ts <span class="token operator">AND</span> t1<span class="token punctuation">.</span>deviceid <span class="token operator">=</span> t2<span class="token punctuation">.</span>deviceid<span class="token punctuation">;</span>
</code></pre>
    <p>
     更多 JOIN 操作相关介绍参见页面 TDengine 关联查询
    </p>
    <h3>
     <a id="_469">
     </a>
     嵌套查询
    </h3>
    <p>
     “嵌套查询”又称为“子查询”，也即在一条 SQL 语句中，“内层查询”的计算结果可以作为“外层查询”的计算对象来使用。
    </p>
    <p>
     从 2.2.0.0 版本开始，TDengine 的查询引擎开始支持在 FROM 子句中使用非关联子查询（“非关联”的意思是，子查询不会用到父查询中的参数）。也即在普通 SELECT 语句的 tb_name_list 位置，用一个独立的 SELECT 语句来代替（这一 SELECT 语句被包含在英文圆括号内），于是完整的嵌套查询 SQL 语句形如：
    </p>
    <pre><code>SELECT ... FROM (SELECT ... FROM ...) ...;
</code></pre>
    <p>
     :::info
    </p>
    <ul>
     <li>
      内层查询的返回结果将作为“虚拟表”供外层查询使用，此虚拟表建议起别名，以便于外层查询中方便引用。
     </li>
     <li>
      外层查询支持直接通过列名或`列名`的形式引用内层查询的列或伪列。
     </li>
     <li>
      在内层和外层查询中，都支持普通的表间/超级表间 JOIN。内层查询的计算结果也可以再参与数据子表的 JOIN 操作。
     </li>
     <li>
      内层查询支持的功能特性与非嵌套的查询语句能力是一致的。
      <ul>
       <li>
        内层查询的 ORDER BY 子句一般没有意义，建议避免这样的写法以免无谓的资源消耗。
       </li>
      </ul>
     </li>
     <li>
      与非嵌套的查询语句相比，外层查询所能支持的功能特性存在如下限制：
      <ul>
       <li>
        计算函数部分：
        <ul>
         <li>
          如果内层查询的结果数据未提供时间戳，那么计算过程隐式依赖时间戳的函数在外层会无法正常工作。例如：INTERP、DERIVATIVE、IRATE、LAST_ROW、FIRST、LAST、TWA、STATEDURATION、TAIL、UNIQUE。
         </li>
         <li>
          如果内层查询的结果数据不是按时间戳有序，那么计算过程依赖数据按时间有序的函数在外层会无法正常工作。例如：LEASTSQUARES、ELAPSED、INTERP、DERIVATIVE、IRATE、TWA、DIFF、STATECOUNT、STATEDURATION、CSUM、MAVG、TAIL、UNIQUE。
         </li>
         <li>
          计算过程需要两遍扫描的函数，在外层查询中无法正常工作。例如：此类函数包括：PERCENTILE。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     :::
    </p>
    <h3>
     <a id="UNION__494">
     </a>
     UNION 子句
    </h3>
    <pre><code class="prism language-txt">SELECT ...
UNION [ALL] SELECT ...
[UNION [ALL] SELECT ...]
</code></pre>
    <p>
     TDengine 支持 UNION [ALL] 操作符。也就是说，如果多个 SELECT 子句返回结果集的结构完全相同（列名、列类型、列数、顺序），那么可以通过 UNION [ALL] 把这些结果集合并到一起。
    </p>
    <h3>
     <a id="SQL__504">
     </a>
     SQL 示例
    </h3>
    <p>
     对于下面的例子，表 tb1 用以下语句创建：
    </p>
    <pre><code>CREATE TABLE tb1 (ts TIMESTAMP, col1 INT, col2 FLOAT, col3 BINARY(50));
</code></pre>
    <p>
     查询 tb1 刚过去的一个小时的所有记录：
    </p>
    <pre><code>SELECT * FROM tb1 WHERE ts &gt;= NOW - 1h;
</code></pre>
    <p>
     查询表 tb1 从 2018-06-01 08:00:00.000 到 2018-06-02 08:00:00.000 时间范围，并且 col3 的字符串是’nny’结尾的记录，结果按照时间戳降序：
    </p>
    <pre><code>SELECT * FROM tb1 WHERE ts &gt; '2018-06-01 08:00:00.000' AND ts &lt;= '2018-06-02 08:00:00.000' AND col3 LIKE '%nny' ORDER BY ts DESC;
</code></pre>
    <p>
     查询 col1 与 col2 的和，并取名 complex，时间大于 2018-06-01 08:00:00.000，col2 大于 1.2，结果输出仅仅 10 条记录，从第 5 条开始：
    </p>
    <pre><code>SELECT (col1 + col2) AS 'complex' FROM tb1 WHERE ts &gt; '2018-06-01 08:00:00.000' AND col2 &gt; 1.2 LIMIT 10 OFFSET 5;
</code></pre>
    <p>
     查询过去 10 分钟的记录，col2 的值大于 3.14，并且将结果输出到文件
     <code>
      /home/testoutput.csv
     </code>
     ：
    </p>
    <pre><code>SELECT COUNT(*) FROM tb1 WHERE ts &gt;= NOW - 10m AND col2 &gt; 3.14 &gt;&gt; /home/testoutput.csv;
</code></pre>
    <h3>
     <a id="_539">
     </a>
     访问官网
    </h3>
    <p>
     更多内容欢迎访问
     <a href="https://www.taosdata.com/?utm_source=web&amp;utm_medium=all-staff&amp;utm_campaign=2025-01-12" rel="nofollow">
      TDengine 官网
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f7469636b7469636b3939392f:61727469636c652f64657461696c732f313436303738383532" class_="artid" style="display:none">
 </p>
</div>


