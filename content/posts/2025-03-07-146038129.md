---
layout: post
title: "Spring-Boot-项目中慢SQL优化方案"
date: 2025-03-07 09:34:50 +0800
description: "Spring Boot 项目中慢 SQL 优化是一个重要的性能优化环节。(MySQL 8.0 已移除)"
keywords: "Spring Boot 项目中慢SQL优化方案"
categories: ['Spring', 'Java', 'Boot', '2025']
tags: ['后端', 'Sql', 'Spring', 'Boot']
artid: "146038129"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146038129
    alt: "Spring-Boot-项目中慢SQL优化方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146038129
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146038129
cover: https://bing.ee123.net/img/rand?artid=146038129
image: https://bing.ee123.net/img/rand?artid=146038129
img: https://bing.ee123.net/img/rand?artid=146038129
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring Boot 项目中慢SQL优化方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     Spring Boot 项目中慢 SQL 优化是一个重要的性能优化环节。以下是一些常用的慢 SQL 优化方案，涵盖了从 SQL 语句本身到数据库配置、应用层优化的多个方面：
    </p>
    <p>
     <strong>
      1. 识别慢 SQL：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        慢查询日志 (Slow Query Log):
       </strong>
      </p>
      <ul>
       <li>
        MySQL、PostgreSQL 等数据库都提供了慢查询日志功能。
       </li>
       <li>
        开启慢查询日志，设置阈值（例如，超过 1 秒的查询被认为是慢查询）。
       </li>
       <li>
        分析慢查询日志，找出执行时间较长的 SQL 语句。
       </li>
       <li>
        <strong>
         MySQL 示例：
        </strong>
        <pre><code class="prism language-sql"><span class="token comment">-- 开启慢查询日志</span>
<span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> slow_query_log <span class="token operator">=</span> <span class="token string">'ON'</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置慢查询阈值 (单位：秒)</span>
<span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> long_query_time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">-- 查看慢查询日志文件路径</span>
<span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'slow_query_log_file'</span><span class="token punctuation">;</span>
</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        数据库监控工具：
       </strong>
      </p>
      <ul>
       <li>
        使用数据库自带的监控工具（例如，MySQL Workbench、pgAdmin）或第三方监控工具（例如，Prometheus + Grafana、DataDog、New Relic）监控数据库性能指标，包括慢查询数量、执行时间等。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        应用性能监控 (APM) 工具：
       </strong>
      </p>
      <ul>
       <li>
        使用 APM 工具（例如，SkyWalking、Pinpoint、Jaeger、Zipkin、New Relic、AppDynamics）监控应用程序的性能，包括数据库查询的执行时间。这些工具通常可以自动识别慢 SQL，并提供详细的性能分析报告。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Spring Boot Actuator (Metrics):
       </strong>
      </p>
      <ul>
       <li>
        Spring Boot Actuator 提供了
        <code>
         /actuator/metrics
        </code>
        端点，可以暴露应用程序的各种指标，包括数据库连接池的使用情况、SQL 执行时间等（需要集成 Micrometer 和相应的数据库驱动）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Druid (或其他数据库连接池) 监控：
       </strong>
      </p>
      <ul>
       <li>
        Druid 连接池提供了强大的监控功能，可以监控 SQL 执行时间、连接池状态等。
       </li>
       <li>
        开启 Druid 的 StatFilter，配置
        <code>
         wall
        </code>
        防火墙 (可选).
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        自定义拦截器/AOP:
       </strong>
      </p>
      <ul>
       <li>
        可以自定义 MyBatis 拦截器或 Spring AOP 切面，拦截 SQL 执行，记录执行时间，并进行分析。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      2. SQL 语句优化：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        使用
        <code>
         EXPLAIN
        </code>
        分析查询计划：
       </strong>
      </p>
      <ul>
       <li>
        在 SQL 语句前加上
        <code>
         EXPLAIN
        </code>
        关键字，可以查看 MySQL 如何执行该查询。
       </li>
       <li>
        分析
        <code>
         EXPLAIN
        </code>
        的输出，关注以下几点：
        <ul>
         <li>
          <code>
           type
          </code>
          : 连接类型，从好到差依次为：
          <code>
           system
          </code>
          、
          <code>
           const
          </code>
          、
          <code>
           eq_ref
          </code>
          、
          <code>
           ref
          </code>
          、
          <code>
           range
          </code>
          、
          <code>
           index
          </code>
          、
          <code>
           ALL
          </code>
          。尽量避免
          <code>
           ALL
          </code>
          (全表扫描)。
         </li>
         <li>
          <code>
           possible_keys
          </code>
          : 可能使用的索引。
         </li>
         <li>
          <code>
           key
          </code>
          : 实际使用的索引。
         </li>
         <li>
          <code>
           rows
          </code>
          : 预计扫描的行数。
         </li>
         <li>
          <code>
           Extra
          </code>
          : 额外信息，例如
          <code>
           Using filesort
          </code>
          (需要排序)、
          <code>
           Using temporary
          </code>
          (需要使用临时表) 等。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        优化索引：
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         创建合适的索引：
        </strong>
        为经常用于查询条件的列、连接列、排序/分组列创建索引。
        <ul>
         <li>
          <code>
           WHERE
          </code>
          子句中的列
         </li>
         <li>
          <code>
           JOIN
          </code>
          子句中的连接列
         </li>
         <li>
          <code>
           ORDER BY
          </code>
          子句中的列
         </li>
         <li>
          <code>
           GROUP BY
          </code>
          子句中的列
         </li>
        </ul>
       </li>
       <li>
        <strong>
         使用组合索引：
        </strong>
        对于多列查询条件，可以使用组合索引。注意组合索引的列顺序。
       </li>
       <li>
        <strong>
         避免在索引列上使用函数或表达式：
        </strong>
        这会导致索引失效。
       </li>
       <li>
        <strong>
         使用前缀索引：
        </strong>
        对于较长的字符串列，可以使用前缀索引，减少索引大小。
       </li>
       <li>
        <strong>
         避免过多索引：
        </strong>
        过多的索引会增加写操作的开销，并占用存储空间。
       </li>
       <li>
        <strong>
         定期维护索引:
        </strong>
        定期检查和优化索引，删除不必要的索引。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        优化查询语句：
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         避免使用
         <code>
          SELECT *
         </code>
         ：
        </strong>
        只查询需要的列，减少数据传输量。
       </li>
       <li>
        <strong>
         避免在
         <code>
          WHERE
         </code>
         子句中使用
         <code>
          !=
         </code>
         或
         <code>
          &lt;&gt;
         </code>
         ：
        </strong>
        这会导致索引失效。
       </li>
       <li>
        <strong>
         避免在
         <code>
          WHERE
         </code>
         子句中对列进行
         <code>
          NULL
         </code>
         值判断：
        </strong>
        应该使用
        <code>
         IS NULL
        </code>
        或
        <code>
         IS NOT NULL
        </code>
        。
       </li>
       <li>
        <strong>
         避免在
         <code>
          WHERE
         </code>
         子句中使用
         <code>
          OR
         </code>
         连接非索引列：
        </strong>
        可以考虑使用
        <code>
         UNION
        </code>
        或
        <code>
         UNION ALL
        </code>
        。
       </li>
       <li>
        <strong>
         尽量使用
         <code>
          JOIN
         </code>
         代替子查询：
        </strong>
        子查询可能会导致性能问题。
       </li>
       <li>
        <strong>
         优化
         <code>
          JOIN
         </code>
         操作：
        </strong>
        <ul>
         <li>
          确保连接列上有索引。
         </li>
         <li>
          尽量使用小表驱动大表。
         </li>
         <li>
          减少
          <code>
           JOIN
          </code>
          的数量。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         优化
         <code>
          ORDER BY
         </code>
         和
         <code>
          GROUP BY
         </code>
         操作：
        </strong>
        <ul>
         <li>
          确保排序/分组的列上有索引。
         </li>
         <li>
          尽量减少排序的数据量。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         使用
         <code>
          LIMIT
         </code>
         分页：
        </strong>
        避免一次性查询大量数据。
       </li>
       <li>
        <strong>
         避免使用
         <code>
          LIKE '%keyword%'
         </code>
         ：
        </strong>
        这会导致索引失效。如果需要模糊查询，可以考虑使用全文索引。
       </li>
       <li>
        <strong>
         使用批量操作：
        </strong>
        批量插入、批量更新等操作可以减少与数据库的交互次数。
       </li>
       <li>
        <strong>
         使用预编译语句 (Prepared Statements):
        </strong>
        可以减少 SQL 解析和编译的开销，并防止 SQL 注入。
       </li>
       <li>
        <strong>
         避免使用游标:
        </strong>
        游标会逐行处理数据, 效率较低.
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        其他优化：
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         分解复杂查询：
        </strong>
        将复杂的查询分解为多个简单的查询。
       </li>
       <li>
        <strong>
         使用临时表：
        </strong>
        对于复杂的查询，可以考虑使用临时表存储中间结果。
       </li>
       <li>
        <strong>
         使用存储过程：
        </strong>
        对于复杂的业务逻辑，可以考虑使用存储过程。
       </li>
       <li>
        <strong>
         避免在循环中执行 SQL 查询：
        </strong>
        尽量将数据一次性查询出来，然后在应用层进行处理。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      3. 数据库配置优化：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        调整缓冲区大小：
       </strong>
      </p>
      <ul>
       <li>
        <code>
         innodb_buffer_pool_size
        </code>
        (InnoDB 存储引擎): 缓存表数据和索引数据。
       </li>
       <li>
        <code>
         key_buffer_size
        </code>
        (MyISAM 存储引擎): 缓存索引数据。
       </li>
       <li>
        <code>
         sort_buffer_size
        </code>
        : 排序缓冲区大小。
       </li>
       <li>
        <code>
         join_buffer_size
        </code>
        : 连接缓冲区大小。
       </li>
       <li>
        <code>
         read_buffer_size
        </code>
        : 读缓冲区大小。
       </li>
       <li>
        <code>
         read_rnd_buffer_size
        </code>
        : 随机读缓冲区大小。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        调整连接数：
       </strong>
      </p>
      <ul>
       <li>
        <code>
         max_connections
        </code>
        : 最大连接数。
       </li>
       <li>
        <code>
         max_user_connections
        </code>
        : 每个用户的最大连接数。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        开启查询缓存 (Query Cache):
       </strong>
       (MySQL 8.0 已移除)
      </p>
      <ul>
       <li>
        如果查询缓存命中率较高，可以开启查询缓存。
       </li>
       <li>
        注意：查询缓存可能会导致性能问题，特别是对于写操作频繁的场景。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        其他参数：
       </strong>
      </p>
      <ul>
       <li>
        <code>
         innodb_log_file_size
        </code>
        : InnoDB 日志文件大小。
       </li>
       <li>
        <code>
         innodb_flush_log_at_trx_commit
        </code>
        : InnoDB 日志刷新策略。
       </li>
       <li>
        <code>
         sync_binlog
        </code>
        : 二进制日志刷新策略。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        硬件优化：
       </strong>
      </p>
      <ul>
       <li>
        使用 SSD 硬盘。
       </li>
       <li>
        增加内存。
       </li>
       <li>
        使用更快的 CPU。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      4. 应用层优化：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       使用连接池：
      </strong>
      使用数据库连接池（例如，Druid、HikariCP、Tomcat JDBC Connection Pool）管理数据库连接，减少连接创建和销毁的开销。
     </li>
     <li>
      <strong>
       缓存：
      </strong>
      <ul>
       <li>
        <strong>
         应用内缓存：
        </strong>
        使用
        <code>
         ConcurrentHashMap
        </code>
        、Guava Cache、Ehcache 等在应用内缓存数据。
       </li>
       <li>
        <strong>
         分布式缓存：
        </strong>
        使用 Redis、Memcached 等分布式缓存系统缓存数据。
       </li>
       <li>
        <strong>
         HTTP 缓存：
        </strong>
        使用 HTTP 缓存头（例如，
        <code>
         Cache-Control
        </code>
        、
        <code>
         ETag
        </code>
        、
        <code>
         Last-Modified
        </code>
        ）缓存静态资源。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       异步处理：
      </strong>
      使用异步任务（例如，
      <code>
       @Async
      </code>
      、
      <code>
       CompletableFuture
      </code>
      、消息队列）处理耗时的操作，避免阻塞主线程。
     </li>
     <li>
      <strong>
       批量操作：
      </strong>
      使用批量插入、批量更新等操作，减少与数据库的交互次数。
     </li>
     <li>
      <strong>
       读写分离：
      </strong>
      将读操作和写操作分离到不同的数据库实例，提高数据库的并发性能。
     </li>
     <li>
      <strong>
       分库分表：
      </strong>
      将数据拆分到多个数据库或表中，提高数据库的扩展性。
     </li>
     <li>
      <strong>
       代码优化：
      </strong>
      优化 Java 代码，减少对象创建、循环次数、字符串拼接等操作的开销。
     </li>
     <li>
      <strong>
       使用更快的序列化方式:
      </strong>
      例如使用 Protobuf, Kryo 等代替 Java 原生序列化.
     </li>
    </ul>
    <p>
     <strong>
      5. 其他：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       使用更快的 ORM 框架:
      </strong>
      例如, 使用 MyBatis 代替 JPA.
     </li>
     <li>
      <strong>
       选择合适的数据库：
      </strong>
      根据业务需求选择合适的数据库类型（关系型数据库、NoSQL 数据库）。
     </li>
     <li>
      <strong>
       定期分析慢 SQL：
      </strong>
      定期分析慢查询日志，找出需要优化的 SQL 语句。
     </li>
     <li>
      <strong>
       压力测试：
      </strong>
      使用压力测试工具（例如，JMeter、Gatling）模拟高并发场景，测试系统的性能瓶颈。
     </li>
    </ul>
    <p>
     <strong>
      总结：
     </strong>
    </p>
    <p>
     慢 SQL 优化是一个综合性的工作，需要从多个方面入手，包括：
    </p>
    <ol>
     <li>
      <strong>
       识别慢 SQL：
      </strong>
      使用慢查询日志、数据库监控工具、APM 工具等。
     </li>
     <li>
      <strong>
       SQL 语句优化：
      </strong>
      使用
      <code>
       EXPLAIN
      </code>
      分析查询计划，优化索引，优化查询语句。
     </li>
     <li>
      <strong>
       数据库配置优化：
      </strong>
      调整缓冲区大小、连接数、查询缓存等参数。
     </li>
     <li>
      <strong>
       应用层优化：
      </strong>
      使用连接池、缓存、异步处理、批量操作、读写分离、分库分表、代码优化等。
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6e6d736f66746b6c622f:61727469636c652f64657461696c732f313436303338313239" class_="artid" style="display:none">
 </p>
</div>


