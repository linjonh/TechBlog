---
layout: post
title: "CFC.-Tokitsukaze-and-Two-Colorful-TapesC.-Where-is-the-Pizza"
date: 2025-03-06 21:30:01 +0800
description: "进一步观察发现（其实是打表），我们可以知道，对于任意一个长度大于一的环，无论如何都只能有两种选法，同时如果这个环只要有一个被锁定了，那么就只能有一种选法所以这道题我们只需要寻找环，如果这个环没有被锁定，且长度大于1，那么就将结果乘2。"
keywords: "【CF】C. Tokitsukaze and Two Colorful Tapes+C. Where is the Pizza?"
categories: ['未分类']
tags: ['算法']
artid: "146079633"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146079633
    alt: "CFC.-Tokitsukaze-and-Two-Colorful-TapesC.-Where-is-the-Pizza"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146079633
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146079633
cover: https://bing.ee123.net/img/rand?artid=146079633
image: https://bing.ee123.net/img/rand?artid=146079633
img: https://bing.ee123.net/img/rand?artid=146079633
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【CF】C. Tokitsukaze and Two Colorful Tapes+C. Where is the Pizza?
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <a href="https://codeforces.com/contest/1677/problem/C" rel="nofollow" title="https://codeforces.com/contest/1677/problem/C">
      https://codeforces.com/contest/1677/problem/C
     </a>
    </p>
    <p>
     <a href="https://codeforces.com/contest/1670/problem/C" rel="nofollow" title="https://codeforces.com/contest/1670/problem/C">
      https://codeforces.com/contest/1670/problem/C
     </a>
    </p>
    <p>
     两道很像的的题目，都和环有关
    </p>
    <hr/>
    <h2>
     C. Tokitsukaze and Two Colorful Tapes
    </h2>
    <h3>
     题目：
    </h3>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6bb020cf814d451c9f97f645a403010d.png">
      <img alt="" src="https://i-blog.csdnimg.cn/direct/f95c81dcbac649d39bc8ad141b686801.png"/>
     </img>
    </p>
    <h3>
     思路：
    </h3>
    <p>
     题意就是给定你两排颜色，要求在相同的颜色填相同的数字，最后让
     <img alt="\sum abs(a[i] - b[i])" class="mathcode" src="https://latex.csdn.net/eq?%5Csum%20abs%28a%5Bi%5D%20-%20b%5Bi%5D%29">
      最大
     </img>
    </p>
    <p>
     对于此类两排排列的问题，我们可以想到是否和环有关，观察发现，这两排数字其实可以构成k个环，对于例一有：
    </p>
    <p>
     1 5 4 3 2 6
    </p>
    <p>
     5 3 1 4 6 2
    </p>
    <p>
     环①：1-&gt;5-&gt;3-&gt;4-&gt;1 长度为4
    </p>
    <p>
     环②：2-&gt;6-&gt;2 长度为2
    </p>
    <p>
     那么对于环上任意一个数，假设为h[i]，那么它的奉献就为 abs(h[i+1] - h[i]) + abs(h[i] - h[i-1])
    </p>
    <p>
     可以发现，对于任意一个数，它只有以下几种情况
    </p>
    <p>
     ①.奉献为2*x
    </p>
    <p>
     ②.奉献为-2*x
    </p>
    <p>
     ③.奉献为0
    </p>
    <p>
     用图表示就是
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/2dc20afd4d2847b2aee8c8477ed32eec.png"/>
    </p>
    <p>
     ①②如右图所示
    </p>
    <p>
     对于2点，有奉献p = 2 - 1 + 2 - 3 = 2*2 - 1 - 3
    </p>
    <p>
     对于4点，有奉献p = 4 - 3 + 4 - 1 = 2*4 - 1 - 3
    </p>
    <p>
     于是总奉献为 2*2 + 2*4 - 1*2 - 3*2
    </p>
    <p>
     同理左图也是，而左图中的3点可计算得到奉献为0
    </p>
    <p>
     因为我们可以这样构造：
    </p>
    <p>
     对于偶数环，我们考虑用最大值，最小值，次大值，次小值....
    </p>
    <p>
     对于奇数环，我们和偶数环一样，但是我们最后要空一个不选，因为这个点的奉献为0，我们可以先给考虑其他环用，最后再来考虑（这里有贪心的想法）
    </p>
    <p>
     那么到最后肯定是这样的形式 n*2 + n-1*2 + n-3*2 ... 0+0-0-0 ... -3*2 - 2*2 - 1*2
    </p>
    <p>
     我们可以发现对于任意一个环，其正奉献的个数和负奉献的元素一样，即都为[c/2]
    </p>
    <p>
     其中c为
     <img alt="\sum [C.Length/2]" class="mathcode" src="https://latex.csdn.net/eq?%5Csum%20%5BC.Length/2%5D">
      ，C.Length为环的长度
     </img>
    </p>
    <p>
     那么根据我们的等差数列求和我们最后来化简一下答案
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/3689c63abb7749fb91db9dcdacc522ec.jpeg"/>
    </p>
    <p>
     最后可以得到答案是 2*(n*len - len*len)，即
     <strong>
      2*len*(n-len)
     </strong>
    </p>
    <h3>
     代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;stack&gt;
#include &lt;memory&gt;
using namespace std;
#define ll long long
#define yes cout &lt;&lt; "YES" &lt;&lt; endl
#define no cout &lt;&lt; "NO" &lt;&lt; endl

int vis[100005];
int a[100005];
int b[100005];
int posina[100005];

ll getLen(int x)
{
    if (vis[x])
    {
        return 0;
    }
    vis[x] = 1;
    return 1LL + getLen(posina[b[x]]);
}

void solve()
{
    memset(vis, 0, sizeof vis);
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
        posina[a[i]] = i;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; b[i];
    }
    ll len = 0;
    for (int i = 1; i &lt;= n; i++)
    {
        if (!vis[i])
        {
            len += getLen(i) / 2LL;
        }
    }
    cout &lt;&lt; 2L * len * (n - len) &lt;&lt; endl;
}

int main()
{
    cin.tie(0)-&gt;sync_with_stdio(false);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}</code></pre>
    <hr/>
    <h2>
     C. Where is the Pizza?
    </h2>
    <h3>
     题目：
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/796e52ae657046b4a21aad283a27f79a.png"/>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/b0f5f0d926944155a5aa3c685ddd2288.png"/>
    </p>
    <h3>
     思路：
    </h3>
    <p>
     我们观察发现，其实又是两个排列，而且也是可以构成环的，在这道题中我们只是多了一个约束条件，即d[i]，其作用是锁定了环的某个元素
    </p>
    <p>
     <strong>
      为什么可以看出构成环呢？可以看到，对于任意一个数，它的位置只有两种选择，如果对于一个位置确定好了一个数，那么这个位置的另一个数的位置肯定也确定好了，以此类推，到最后肯定会形成一个环
     </strong>
    </p>
    <p>
     进一步观察发现（其实是打表），我们可以知道，对于任意一个长度大于一的环，无论如何都只能有两种选法，同时如果这个环只要有一个被锁定了，那么就只能有一种选法
    </p>
    <p>
     所以这道题我们只需要寻找环，如果这个环没有被锁定，且长度大于1，那么就将结果乘2
    </p>
    <h3>
     代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;stack&gt;
#include &lt;memory&gt;
using namespace std;
#define ll long long
#define yes cout &lt;&lt; "YES" &lt;&lt; endl
#define no cout &lt;&lt; "NO" &lt;&lt; endl

const int MOD = 1e9 + 7;
int a[100005];
int b[100005];
int d[100005];
int posina[100005];
int flag = 0;
ll getlen(int x)
{
    if (!a[x])
    {
        return 0;
    }
    a[x] = 0;
    if (d[x] != 0)
    {
        flag = 1;
    }
    return 1 + getlen(posina[b[x]]);
}

void solve()
{
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
        posina[a[i]] = i;
    }    
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; b[i];
    }
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; d[i];
    }
    ll ans = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        if (a[i])
        {
            flag = 0;
            if (getlen(i) &gt; 1 &amp;&amp; !flag)
            {
                ans = ans * 2 % MOD;
            }
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
    cin.tie(0)-&gt;sync_with_stdio(false);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36313432323636342f:61727469636c652f64657461696c732f313436303739363333" class_="artid" style="display:none">
 </p>
</div>


