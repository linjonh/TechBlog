---
layout: post
title: "JavaEE进阶Transactional-详解"
date: 2025-03-16 22:12:39 +0800
description: "本篇博客的将讲述 @注解的使用细节rollbackFor:异常回滚属性.指定能够触发事务回滚的异常类型.可以指定多个异常类型Isolation:事务的隔离级别.默认值为 Isolation.DEFAULTpropagation:事务的传播机制.默认为Propagation.REQUIRED事务传播机制就是: 多个事务⽅法存在调⽤关系时,事务是如何在这些⽅法间进⾏传播的.比如有两个⽅法A,B都被 @Transactional 修饰,A⽅法调⽤B⽅法。"
keywords: "【JavaEE进阶】@Transactional 详解"
categories: ['未分类']
tags: ['开发语言', 'Java']
artid: "146028321"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146028321
    alt: "JavaEE进阶Transactional-详解"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146028321
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146028321
cover: https://bing.ee123.net/img/rand?artid=146028321
image: https://bing.ee123.net/img/rand?artid=146028321
img: https://bing.ee123.net/img/rand?artid=146028321
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【JavaEE进阶】@Transactional 详解
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <h2>
     🍃前言
    </h2>
    <p>
     本篇博客的将讲述 @
     <a href="https://so.csdn.net/so/search?q=Transactional&amp;spm=1001.2101.3001.7020" title="Transactional">
      Transactional
     </a>
     注解的使用细节
    </p>
    <p>
     主要学习 @Transactional 注解当中的三个常见属性:
    </p>
    <ol>
     <li>
      rollbackFor:异常回滚属性.指定能够触发事务回滚的异常类型.可以指定多个异常类型
     </li>
     <li>
      Isolation:事务的隔离级别.默认值为 Isolation.DEFAULT
     </li>
     <li>
      propagation:事务的传播机制.默认为Propagation.REQUIRED
     </li>
    </ol>
    <h2 id="%F0%9F%8C%B2rollbackFor(%E5%BC%82%E5%B8%B8%E5%9B%9E%E6%BB%9A%E5%B1%9E%E6%80%A7)" name="%F0%9F%8C%B2rollbackFor(%E5%BC%82%E5%B8%B8%E5%9B%9E%E6%BB%9A%E5%B1%9E%E6%80%A7)">
     🌲rollbackFor(异常回滚属性)
    </h2>
    <h3 id="%F0%9F%9A%A9rollbackFor%E5%B1%9E%E6%80%A7" name="%F0%9F%9A%A9rollbackFor%E5%B1%9E%E6%80%A7">
     🚩rollbackFor属性
    </h3>
    <p>
     源码：
    </p>
    <p>
     <img alt="" height="66" src="https://i-blog.csdnimg.cn/direct/4bef4df6a8cf48c3b699f94129178a94.png" width="782"/>
    </p>
    <p>
     @Transactional 默认只在遇到运行时异常和Error时才会回滚,非运行时异常不回滚.
    </p>
    <p>
     即Exception的⼦类中,除了RuntimeException及其⼦类.
    </p>
    <p>
     <img alt="" height="1011" src="https://i-blog.csdnimg.cn/direct/ad11bf102671424a8ac1f0ffd27ac9cd.png" width="2154"/>
    </p>
    <p>
     如果我们需要所有异常都回滚,需要来配置 @Transactional 注解当中的 rollbackFor 属性,通过 rollbackFor 这个属性指定出现何种异常类型时事务进行回滚
    </p>
    <p>
     代码：
     <img alt="" height="690" src="https://i-blog.csdnimg.cn/direct/98423a6f8f804452ae00d8eaf3dbf132.png" width="1039"/>
    </p>
    <p>
     在上篇文章中，演示了该代码会出现运行时异常，它是继承的RuntimeEcxeption，所以会进行回滚
     <img alt="" height="207" src="https://i-blog.csdnimg.cn/direct/840d729b0cf5421ba670c50493fd0a2a.png" width="1236"/>
    </p>
    <p>
     接下来我们把异常改为如下代码
     <img alt="" height="697" src="https://i-blog.csdnimg.cn/direct/612efcb86e8a4d039d59e29d094b7399.png" width="1146"/>
    </p>
    <p>
     发送请求：
     <img alt="" height="750" src="https://i-blog.csdnimg.cn/direct/904a961d042b4dbe800e6ad992a66282.png" width="1378"/>
    </p>
    <p>
     观察日志：发现事务是进行提交了，并没有回滚
     <img alt="" height="229" src="https://i-blog.csdnimg.cn/direct/804dc192aca14c8b8a34e8cee8f70425.png" width="1458"/>
    </p>
    <p>
     如果我们需要所有异常都回滚,需要来配置 过 @Transactional 注解当中的 rollbackFor 这个属性，通过rollbackFor 这个属性指定出现何种异常类型时事务进⾏回滚
    </p>
    <p>
     指定所有异常回滚：
     <img alt="" height="405" src="https://i-blog.csdnimg.cn/direct/77683f2e31484fbfaf47084ba87faf23.png" width="1085"/>
    </p>
    <p>
     运行观察日志：发现事务没有提交，进行了回滚
     <img alt="" height="200" src="https://i-blog.csdnimg.cn/direct/ed1e56917bbf4f938f15af880f364215.png" width="1257"/>
    </p>
    <h3 id="%F0%9F%9A%A9noRollbackFor%E5%B1%9E%E6%80%A7" name="%F0%9F%9A%A9noRollbackFor%E5%B1%9E%E6%80%A7">
     🚩noRollbackFor属性
    </h3>
    <p>
     源码：
    </p>
    <p>
     <img alt="" height="64" src="https://i-blog.csdnimg.cn/direct/94686f3614874a3d8bc2a7f32ea0edbc.png" width="774"/>
    </p>
    <p>
     我们知道了rollbackFor属性是指定异常进行回滚；那么noRollbackFor指定异常不进行回滚
    </p>
    <h2 id="%F0%9F%8E%84Isolation(%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)" name="%F0%9F%8E%84Isolation(%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)">
     🎄Isolation(事务隔离级别)
    </h2>
    <p>
     我们先来看一下MySQL事务隔离级别都有那些
    </p>
    <h3 id="%F0%9F%9A%A9MySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" name="%F0%9F%9A%A9MySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">
     🚩MySQL事务的隔离级别
    </h3>
    <p>
     SQL标准定义了四种隔离级别,MySQL全都⽀持.这四种隔离级别分别是:
     <img alt="" height="473" src="https://i-blog.csdnimg.cn/direct/24f9cf90df854fb1a344ae604ad13d95.png" width="1170"/>
    </p>
    <ul>
     <li>
      1. 读未提交(READUNCOMMITTED): 读未提交,也叫未提交读.该隔离级别的事务可以看到其他事务中未提交的数据.
     </li>
    </ul>
    <blockquote>
     <p>
      因为其他事务未提交的数据可能会发⽣回滚,但是该隔离级别却可以读到,我们把该级别读到的数 据称之为脏数据,这个问题称之为
      <span style="color:#fe2c24">
       脏读
      </span>
      .
     </p>
    </blockquote>
    <ul>
     <li>
      2. 读提交(READ COMMITTED): 读已提交,也叫提交读.该隔离级别的事务能读取到已经提交事务的数据
     </li>
    </ul>
    <blockquote>
     <p>
      该隔离级别不会有脏读的问题.但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL
      <br/>
      查询可能会得到不同的结果,这种现象叫做
      <span style="color:#fe2c24">
       不可重复读
      </span>
     </p>
    </blockquote>
    <ul>
     <li>
      3. 可重复读(REPEATABLE READ): 事务不会读到其他事务对已有数据的修改,即使其他事务已提交.也就可以确保同⼀事务多次查询的结果⼀致,但是其他事务新插⼊的数据,是可以感知到的.这也就引发了幻读问题.可重复读,是MySQL的默认事务隔离级别.
     </li>
    </ul>
    <blockquote>
     <p>
      ⽐如此级别的事务正在执⾏时,另⼀个事务成功的插⼊了某条数据,但因为它每次查询的结果都是⼀样的,所以会导致查询不到这条数据,自己重复插⼊时⼜失败(因为唯⼀约束的原因).明明在事务
      <br/>
      中查询不到这条信息，但⾃⼰就是插⼊不进去,这个现象叫
      <span style="color:#fe2c24">
       幻读
      </span>
      .
     </p>
    </blockquote>
    <ul>
     <li>
      4. 串⾏化(SERIALIZABLE): 序列化,事务最⾼隔离级别.它会强制事务排序,使之不会发⽣冲突,从⽽解决了脏读,不可重复读和幻读问题,但因为执⾏效率低,所以真正使⽤的场景并不多
     </li>
    </ul>
    <p>
     MySQL可重复读演示：
    </p>
    <p>
     1. 查看user_info表
     <img alt="" height="177" src="https://i-blog.csdnimg.cn/direct/d7f7ebec8f16488f93973ff6e2cb06c4.png" width="978"/>
    </p>
    <p>
     2. 开启两个事务
     <img alt="" height="453" src="https://i-blog.csdnimg.cn/direct/7047b088414e4c939a5947357df443c7.png" width="2054"/>
    </p>
    <p>
     3. 事务B进行插入数据，在进行提交
     <img alt="" height="487" src="https://i-blog.csdnimg.cn/direct/dd8642c257eb4890892cbd5f386ba6f0.png" width="981"/>
    </p>
    <p>
     4. 查询数据库(可以看到事务B成功的提交了数据)
     <img alt="" height="164" src="https://i-blog.csdnimg.cn/direct/fd54f59e77a44e138fae1d9d854fe4d1.png" width="741"/>
    </p>
    <p>
     5. 事务A进行查询数据库(可以看到查不到上述id为12的记录，事务A是查询不到的)
     <img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/8d9cf2f711984dec9b4378525c86ed8f.png" width="972"/>
    </p>
    <p>
     6. 在事务A中插入上述id为12的记录(发现也插入不了，说主键冲突了，这就叫幻读)
     <img alt="" height="70" src="https://i-blog.csdnimg.cn/direct/2e5194e11f46430b83dae217f6596e13.png" width="1028"/>
    </p>
    <p>
     7. 当事务A进行提交之后，在此查询就可以查询到了
     <img alt="" height="274" src="https://i-blog.csdnimg.cn/direct/1828199344934d1f9a25cbd88aac8370.png" width="1027"/>
    </p>
    <h3 id="%F0%9F%9A%A9Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" name="%F0%9F%9A%A9Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">
     🚩Spring事务隔离级别
    </h3>
    <p>
     Spring 中事务隔离级别有5 种:
    </p>
    <p>
     源码：
     <img alt="" height="1326" src="https://i-blog.csdnimg.cn/direct/09a71cd2558444c1adac19fa6020251c.png" width="1235"/>
    </p>
    <ul>
     <li>
      Isolation.DEFAULT :以连接的数据库的事务隔离级别为主(连接MySQL默认就是可重复读).
     </li>
     <li>
      Isolation.READ_UNCOMMITTED :读未提交,对应SQL标准中READ UNCOMMITTED
     </li>
     <li>
      Isolation.READ_COMMITTED :读已提交,对应SQL标准中READ COMMITTED
     </li>
     <li>
      Isolation.REPEATABLE_READ :可重复读,对应SQL标准中 REPEATABLE READ
     </li>
     <li>
      Isolation.SERIALIZABLE :串行化,对应SQL标准中SERIALIZABLE
     </li>
    </ul>
    <p>
     Spring中事务隔离级别可以通过 @Transactional 中的 isolation 属性进行设置
    </p>
    <p>
     <img alt="" height="52" src="https://i-blog.csdnimg.cn/direct/c6f4ab49220d44748b766525f39e2940.png" width="1009"/>
    </p>
    <h2 id="%F0%9F%8E%8BSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6" name="%F0%9F%8E%8BSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6">
     🎋Spring事务传播机制
    </h2>
    <h3 id="%F0%9F%9A%A9%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6" name="%F0%9F%9A%A9%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6">
     <a name="t7">
     </a>
     <a id="_66">
     </a>
     🚩什么是事务传播机制
    </h3>
    <p>
     事务传播机制就是: 多个事务⽅法存在调⽤关系时,事务是如何在这些⽅法间进⾏传播的.
    </p>
    <p>
     比如有两个⽅法A,B都被 @Transactional 修饰,A⽅法调⽤B⽅法
    </p>
    <p>
     A⽅法运⾏时,会开启⼀个事务.当A调⽤B时,B⽅法本⾝也有事务,此时B⽅法运⾏时,是加⼊A的事务,还是创建⼀个新的事务呢?
    </p>
    <p>
     这个就涉及到了事务的传播机制.
    </p>
    <blockquote>
     <p>
      ⽐如公司流程管理
     </p>
     <p>
      执⾏任务之前,需要先写执⾏⽂档,任务执⾏结束,再写总结汇报
      <img alt="" height="330" src="https://i-blog.csdnimg.cn/direct/ba81ac15cb624870853715f2aee366ee.png" width="984"/>
     </p>
     <p>
      此时A部⻔有⼀项⼯作,需要B部⻔的⽀援,此时B部⻔是直接使⽤A部⻔的⽂档,还是新建⼀个⽂档呢?
     </p>
    </blockquote>
    <p>
     事务隔离级别解决的是多个事务同时调⽤⼀个数据库的问题
    </p>
    <p>
     <img alt="" height="711" src="https://i-blog.csdnimg.cn/direct/d38d40ca5aab4f25a2d1d40664df37a4.png" width="1159"/>
    </p>
    <p>
     而事务传播机制解决的是⼀个事务在多个节点(方法)中传递的问题
    </p>
    <p>
     <img alt="" height="204" src="https://i-blog.csdnimg.cn/direct/df2dfc840d79486187c423aa4ac1f472.png" width="1154"/>
    </p>
    <h3 id="%F0%9F%9A%A9%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6" name="%F0%9F%9A%A9%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6">
     🚩事务有哪些传播机制
    </h3>
    <p>
     @Transactional 注解⽀持事务传播机制的设置,通过propagation 属性来指定传播⾏为.
    </p>
    <p>
     Spring 事务传播机制有以下 7 种：
     <img alt="" height="1092" src="https://i-blog.csdnimg.cn/direct/4057eaf6341d4f4f822c6c4f7bf87b63.png" width="1184"/>
     <img alt="" height="765" src="https://i-blog.csdnimg.cn/direct/0e70aa4863ec462c8954c863a152f665.png" width="1181"/>
    </p>
    <ol>
     <li>
      Propagation.REQUIRED :默认的事务传播级别.如果当前存在事务,则加⼊该事务.如果当前没有事务,则创建⼀个新的事务.
     </li>
     <li>
      Propagation.SUPPORTS : 如果当前存在事务,则加⼊该事务.如果当前没有事务,则以⾮事务的⽅式继续运⾏.
     </li>
     <li>
      Propagation.MANDATORY :强制性.如果当前存在事务,则加⼊该事务.如果当前没有事务,则抛出异常.
     </li>
     <li>
      Propagation.REQUIRES_NEW :创建⼀个新的事务.如果当前存在事务,则把当前事务挂起.也就是说不管外部方法是否开启事务, Propagation.REQUIRES_NEW 修饰的内部⽅法都会新开启自己的事务,且开启的事务相互独⽴,互不⼲扰.
     </li>
     <li>
      Propagation.NOT_SUPPORTED : 以⾮事务⽅式运⾏,如果当前存在事务,则把当前事务挂起(不⽤).
     </li>
     <li>
      Propagation.NEVER : 以⾮事务⽅式运⾏,如果当前存在事务,则抛出异常.
     </li>
     <li>
      Propagation.NESTED : 如果当前存在事务,则创建⼀个事务作为当前事务的嵌套事务来运⾏.如果当前没有事务,则该取值等价于PROPAGATION_REQUIRED .
     </li>
    </ol>
    <p>
     可能上述理解起来有点儿抽象，这儿举个例子
    </p>
    <blockquote>
     <p>
      ⽐如⼀对新⼈要结婚了,关于是否需要房⼦
     </p>
     <ol>
      <li>
       Propagation.REQUIRED :需要有房⼦.如果你有房,我们就⼀起住,如果你没房,我们就⼀起买房.(如果当前存在事务,则加⼊该事务.如果当前没有事务,则创建⼀个新的事务)
      </li>
      <li>
       Propagation.SUPPORTS : 可以有房⼦. 如果你有房,那就⼀起住.如果没房,那就租房.(如果当前存在事务,则加⼊该事务.如果当前没有事务,则以⾮事务的⽅式继续运⾏)
      </li>
      <li>
       Propagation.MANDATORY :必须有房⼦.要求必须有房,如果没房就不结婚.(如果当前存在事务,则加⼊该事务.如果当前没有事务,则抛出异常)
      </li>
      <li>
       Propagation.REQUIRES_NEW :必须买新房.不管你有没有房,必须要两个⼈⼀起买房.即使有房也不住.(创建⼀个新的事务.如果当前存在事务,则把当前事务挂起)
      </li>
      <li>
       Propagation.NOT_SUPPORTED :不需要房.不管你有没有房,我都不住,必须租房.(以非事务⽅式运⾏,如果当前存在事务,则把当前事务挂起)
      </li>
      <li>
       Propagation.NEVER :不能有房⼦.(以⾮事务⽅式运⾏,如果当前存在事务,则抛出异常)
      </li>
      <li>
       Propagation.NESTED :如果你没房,就⼀起买房.如果你有房,我们就以房⼦为根据地,做点小⽣意.(如果如果当前存在事务,则创建⼀个事务作为当前事务的嵌套事务来运⾏.如果当前没有事务,则该取值等价于PROPAGATION_REQUIRED )
      </li>
     </ol>
    </blockquote>
    <p>
     这里我们需要注意一下NESTED和REQUIRED区别
    </p>
    <ul>
     <li>
      整个事务如果全部执⾏成功,⼆者的结果是⼀样的.
     </li>
     <li>
      如果事务⼀部分执⾏成功,REQUIRED加⼊事务会导致整个事务全部回滚.NESTED嵌套事务可以实现局部回滚,不会影响上⼀个方法中执⾏的结果.
     </li>
    </ul>
    <p>
     嵌套事务之所以能够实现部分事务的回滚,是因为事务中有⼀个保存点(savepoint)的概念,嵌套事务进⼊之后相当于新建了⼀个保存点,而滚回时只回滚到当前保存点
    </p>
    <p>
     使用方法与上述两个属性使用方法是一样的，进行相应属性值设置即可
    </p>
    <p>
     <img alt="" height="49" src="https://i-blog.csdnimg.cn/direct/37db2130018d4b8bb72d240ff49275fd.png" width="935"/>
    </p>
    <h3 id="%F0%9F%9A%A9Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E5%90%84%E7%A7%8D%E5%9C%BA%E6%99%AF%E6%BC%94%E7%A4%BA" name="%F0%9F%9A%A9Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E5%90%84%E7%A7%8D%E5%9C%BA%E6%99%AF%E6%BC%94%E7%A4%BA">
     🚩Spring事务传播机制使用和各种场景演示
    </h3>
    <p>
     对于以上事务传播机制，我们重点关注以下两个就可以了：
    </p>
    <ol>
     <li>
      REQUIRED（默认值）
     </li>
     <li>
      REQUIRES_NEW
     </li>
    </ol>
    <p>
     数据准备：
    </p>
    <p>
     user_info表和相关代码在上篇文章以准备
    </p>
    <ul>
     <li>
      1. log_info表：
      <img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/08cbad769c9546218a8e55fea074ad30.png" width="1125"/>
     </li>
     <li>
      2. controller
      <img alt="" height="792" src="https://i-blog.csdnimg.cn/direct/58fd71b2442f415b89ee5add39e056de.png" width="1146"/>
     </li>
     <li>
      3. service​​​​​​​
      <img alt="" height="331" src="https://i-blog.csdnimg.cn/direct/e75b4674648a4dbb99bc6d9de9665f5e.png" width="942"/>
     </li>
     <li>
      4. mapper
      <img alt="" height="166" src="https://i-blog.csdnimg.cn/direct/b0ffaac464cb4e2c991715e626a1e245.png" width="968"/>
     </li>
    </ul>
    <p>
     测试：​​​​​​​
    </p>
    <p>
     发送请求前数据表：
     <img alt="" height="120" src="https://i-blog.csdnimg.cn/direct/ecfcd87d00bc491e83a34b12ec6f98d1.png" width="670"/>
     <img alt="" height="73" src="https://i-blog.csdnimg.cn/direct/6cffb4d22a4942a88fa23c69bad8676b.png" width="802"/>
    </p>
    <p>
     发送请求：​​​​​​​​​​​​​​​​​​​​​
     <img alt="" height="642" src="https://i-blog.csdnimg.cn/direct/4c02e8523f394955a6a6e1102aa3ac38.png" width="1340"/>
    </p>
    <p>
     发送请求后数据表：
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/7dffc12d7e914aa59facb28eaab9fb32.png" width="709"/>
     <img alt="" height="194" src="https://i-blog.csdnimg.cn/direct/6093f264bc474ef9b40d51f803fac3a5.png" width="942"/>
    </p>
    <h4 id="%F0%9F%8F%80REQUIRED(%E5%8A%A0%E5%85%A5%E4%BA%8B%E5%8A%A1)" name="%F0%9F%8F%80REQUIRED(%E5%8A%A0%E5%85%A5%E4%BA%8B%E5%8A%A1)">
     🏀REQUIRED(加入事务)
    </h4>
    <p>
     方法调用方的代码：
     <img alt="" height="789" src="https://i-blog.csdnimg.cn/direct/40ecf3d20ffe405e87e397ec03d9c9c2.png" width="1042"/>
    </p>
    <p>
     被调用方的代码：
     <img alt="" height="367" src="https://i-blog.csdnimg.cn/direct/04eeb4849f484d5388277712f71e1bd2.png" width="1017"/>
     <img alt="" height="333" src="https://i-blog.csdnimg.cn/direct/a6eae4006cba4ca9aead35b69738119a.png" width="985"/>
    </p>
    <p>
     required理解：如果当前存在事务,则加⼊该事务.如果当前没有事务,则创建⼀个新的事务.
    </p>
    <p>
     当前调用方registry是存在事务的，那么insertUser和InsertLog都会使用registry的事务，他们三个共用这一个事务。
    </p>
    <p>
     如果当前我让insertLog报错，insertUser执行成功
    </p>
    <p>
     insertLog代码修改：​​​​​​​
     <img alt="" height="381" src="https://i-blog.csdnimg.cn/direct/1d2f2f64ae5b4087870b2bc2bc68e145.png" width="1098"/>
    </p>
    <p>
     他们三个使用的是同一个事务，那么当前insertLog会报错，进行回滚，他们三个都会进行回滚。
    </p>
    <p>
     测试：
    </p>
    <p>
     发送请求前数据表：
     <img alt="" height="417" src="https://i-blog.csdnimg.cn/direct/2ab7ebe9743a41b79faf6775ed2ca8de.png" width="1029"/>
    </p>
    <p>
     发送请求：
     <img alt="" height="768" src="https://i-blog.csdnimg.cn/direct/66174c3cc4b945de832ec97c1f2a919c.png" width="1389"/>
    </p>
    <p>
     查看日志：全部进行了回滚，没有提交​​​​​​​
     <img alt="" height="501" src="https://i-blog.csdnimg.cn/direct/3c89b3db3fdb47599c76515fbba02816.png" width="1548"/>
    </p>
    <p>
     发送请求后数据表：发现也没有插入进来
     <img alt="" height="424" src="https://i-blog.csdnimg.cn/direct/63b74c12291f4523aeaab92972d04dd6.png" width="1094"/>
    </p>
    <h4 id="%F0%9F%8F%80REQUIRES_NEW(%E6%96%B0%E5%BB%BA%E4%BA%8B%E5%8A%A1)" name="%F0%9F%8F%80REQUIRES_NEW(%E6%96%B0%E5%BB%BA%E4%BA%8B%E5%8A%A1)">
     🏀REQUIRES_NEW(新建事务)
    </h4>
    <p>
     调用方代码：
     <img alt="" height="789" src="https://i-blog.csdnimg.cn/direct/43f5d3218c124b878bc562cf5af74583.png" width="1059"/>
    </p>
    <p>
     被调用方代码：
     <img alt="" height="362" src="https://i-blog.csdnimg.cn/direct/205bf476fcc741eb8190bab2b50bfb41.png" width="1027"/>
     <img alt="" height="395" src="https://i-blog.csdnimg.cn/direct/345f8678e2a347f980d4dc4f29c1eb19.png" width="1077"/>
    </p>
    <p>
     requires_new理解：创建⼀个新的事务.如果当前存在事务,则把当前事务挂起.也就是说不管外部方法是否开启事务, Propagation.REQUIRES_NEW 修饰的内部⽅法都会新开启自己的事务,且开启的事务相互独⽴,互不⼲扰.
    </p>
    <p>
     意思就是当前代码，insertLog会有异常，进行回滚；insertUser没有异常，正确提交
    </p>
    <p>
     测试：
    </p>
    <p>
     发送请求前数据表：
     <img alt="" height="425" src="https://i-blog.csdnimg.cn/direct/3bf8c4c8a1b44321b1487e879674c15b.png" width="1071"/>
    </p>
    <p>
     发请求请：
     <img alt="" height="755" src="https://i-blog.csdnimg.cn/direct/e29b0cd0f3ed4dfdae2014b9962f95e5.png" width="1371"/>
    </p>
    <p>
     查看日志：​​​​​​​
     <img alt="" height="731" src="https://i-blog.csdnimg.cn/direct/a52f7c8a9dfe4d429e53d6fb5e74482b.png" width="1551"/>
    </p>
    <p>
     发送请求后数据表：
     <img alt="" height="444" src="https://i-blog.csdnimg.cn/direct/cd7a1c2f51e748b9875a26156b95a003.png" width="1073"/>
    </p>
    <p>
     注意：若只是调用方发生异常(controller)，被调用方没有异常(insertLog, insertUser)，则被调用方开启新的事务，会正确的进行提交，不会回滚。
    </p>
    <h4 id="%F0%9F%8F%80NEVER(%E4%B8%8D%E6%94%AF%E6%8C%81%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%2C%E6%8A%9B%E5%BC%82%E5%B8%B8)" name="%F0%9F%8F%80NEVER(%E4%B8%8D%E6%94%AF%E6%8C%81%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%2C%E6%8A%9B%E5%BC%82%E5%B8%B8)">
     🏀NEVER(不支持当前事务,抛异常)
    </h4>
    <p>
     调用方代码：
     <img alt="" height="938" src="https://i-blog.csdnimg.cn/direct/dcd474ed1377414eafcc24c6c1a50e5c.png" width="1033"/>
    </p>
    <p>
     被调用方代码：​​​​​​​
     <img alt="" height="394" src="https://i-blog.csdnimg.cn/direct/22ffddd4d5404d88af0a50f40002c3fa.png" width="1044"/>
     ​​​​​​
     <img alt="" height="369" src="https://i-blog.csdnimg.cn/direct/42098567c7d64dbe846e86a0aff99a6f.png" width="1026"/>
    </p>
    <p>
     never理解：以⾮事务⽅式运⾏,如果当前存在事务,则抛出异常.
    </p>
    <p>
     意思就是insertLog必须以非事务的方式运行，若有事务过来了，就会报错；那么当前registry是有事务的，所以insertLog就会报错，insertUser则正确提交。
    </p>
    <p>
     测试：
    </p>
    <p>
     发送请求前数据表：
     <img alt="" height="447" src="https://i-blog.csdnimg.cn/direct/2e07d1678a784a878e3f27c4ed73d902.png" width="1070"/>
    </p>
    <p>
     发送求情：​​​​​​​
     <img alt="" height="764" src="https://i-blog.csdnimg.cn/direct/c86804638f1242d8ace58c580cf48afd.png" width="1376"/>
    </p>
    <p>
     查看日志：
     <img alt="" height="509" src="https://i-blog.csdnimg.cn/direct/7709af4c530b46dbae1908cddefcbaf3.png" width="1887"/>
    </p>
    <p>
     发送请求后数据表：
     <img alt="" height="468" src="https://i-blog.csdnimg.cn/direct/1c5d4ec78c95455ba7270f18e621338b.png" width="1121"/>
    </p>
    <h4 id="%F0%9F%8F%80%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BNESTED(%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1)" name="%F0%9F%8F%80%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BNESTED(%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1)">
     🏀​​​​​​​NESTED(嵌套事务)
    </h4>
    <p>
     <strong>
      与required比较：
     </strong>
    </p>
    <p>
     调用方代码：​​​​​​​​​​​​​​
     <img alt="" height="787" src="https://i-blog.csdnimg.cn/direct/84465175f7754a87911f1a4d9f903dc0.png" width="1150"/>
    </p>
    <p>
     被调用方代码：
    </p>
    <p>
     <img alt="" height="369" src="https://i-blog.csdnimg.cn/direct/02cbfca44d534bd397ee752bcfe72370.png" width="1003"/>
     <img alt="" height="398" src="https://i-blog.csdnimg.cn/direct/ebb4222d651e4cd6b2440d24072c7f17.png" width="984"/>
    </p>
    <p>
     上述我们演示了required，若调用方有事务，则被调用方使用调用方的事务，当发生异常时，会进行回滚。那么方法成功时事务全部提交。
    </p>
    <ul>
     <li>
      方法出现异常：事务全部回滚
     </li>
     <li>
      方法都执行成功：事务全部提交
     </li>
    </ul>
    <p>
     <strong>
      改成NESTED：
     </strong>
    </p>
    <p>
     方法成功的情况：
    </p>
    <p>
     调用方代码：​​​​​​​​​​​​​​​​​​​​​
     <img alt="" height="791" src="https://i-blog.csdnimg.cn/direct/2acee18e484c443ca3820608820dd323.png" width="993"/>
    </p>
    <p>
     被调用方代码：
     <img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/d153e57bf70945e6bef6090ae5be2c03.png" width="1021"/>
     <img alt="" height="392" src="https://i-blog.csdnimg.cn/direct/90df30fb46224d5fa1c7392381d87f3f.png" width="1041"/>
    </p>
    <p>
     发送请求前数据表：
     <img alt="" height="459" src="https://i-blog.csdnimg.cn/direct/6382a39c00c64c0198d65882d56aee26.png" width="1056"/>
    </p>
    <p>
     发送请求：
     <img alt="" height="622" src="https://i-blog.csdnimg.cn/direct/60c915aa7c164cf1ad2aa6e08a2065c1.png" width="1361"/>
    </p>
    <p>
     查看日志：
     <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/1957e641513340f7a16660f4436fccc9.png" width="1560"/>
    </p>
    <p>
     发送请求后数据表：
     <img alt="" height="513" src="https://i-blog.csdnimg.cn/direct/75b02e46a197489388fa0cd2a498207d.png" width="1068"/>
    </p>
    <p>
     发现上述事务全部提交
    </p>
    <p>
     事务异常的情况：
    </p>
    <p>
     修改insertLog代码：
     <img alt="" height="395" src="https://i-blog.csdnimg.cn/direct/3ad407b639f34b11b13d0999471a52d7.png" width="994"/>
    </p>
    <p>
     发送请求前数据表：
     <img alt="" height="515" src="https://i-blog.csdnimg.cn/direct/8c6e732c9d7e425bbced0143aac70a52.png" width="1092"/>
    </p>
    <p>
     发送请求：​​​​​​​
     <img alt="" height="755" src="https://i-blog.csdnimg.cn/direct/71733e104f8e495cadb68207238cfa23.png" width="1382"/>
    </p>
    <p>
     查看日志：发现日志没有提交操作​​​​​​​
     <img alt="" height="577" src="https://i-blog.csdnimg.cn/direct/2d81b0c393784de7a91cdc3346942d93.png" width="1467"/>
    </p>
    <p>
     发送请求后数据表：发现两个都没有进行插入，事务全部回滚
     <img alt="" height="513" src="https://i-blog.csdnimg.cn/direct/7027c81f2d8d49fe936fcf3094e493c5.png" width="1026"/>
    </p>
    <p>
     结论：
    </p>
    <ul>
     <li>
      方法全部执行成功：事务全部提交
     </li>
     <li>
      方式出现异常：事务全部回滚
     </li>
    </ul>
    <h4 id="%F0%9F%8F%80NESTED%E5%92%8CREQUIRED%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" name="%F0%9F%8F%80NESTED%E5%92%8CREQUIRED%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">
     🏀NESTED和REQUIRED有什么区别？
    </h4>
    <p>
     经过上述发现，NESTED和REQUIRED的结论好像都是一样的，那他们有什么区别？
    </p>
    <p>
     我们可以简单的理解为
    </p>
    <p>
     REQUIRED他们使用的是同一事务，要么都提交，要么都回滚
    </p>
    <p>
     NESTED理解为父子事务，子事务处理成功了，父事务不受影响；子事务处理不好，父事务受牵连
    </p>
    <p>
     我们就需要对子事务进行处理：
    </p>
    <p>
     代码：
     <img alt="" height="558" src="https://i-blog.csdnimg.cn/direct/93385e3d7a5e42ceba85932a29a75cc8.png" width="1157"/>
    </p>
    <p>
     我们知道，NESTED属于嵌套事务，那么insertLog和insertUser都属于嵌套事务，由于呢insertLog中发生了异常，导致影响到了父事务(registry)，那么也就影响到了insertUser，全部回滚了；此时呢当insertLog出现异常了自己进行了回滚，那么回滚的是自己的事务(自己是否有事务？)，如果自己有事务，那么父事务(registry)就不会受到影响，insertUser肯定也不会受到影响。
    </p>
    <p>
     测试：
    </p>
    <p>
     发送请求：
     <img alt="" height="629" src="https://i-blog.csdnimg.cn/direct/f3c27c658aef42eab25fa888101bda81.png" width="1339"/>
    </p>
    <p>
     查看日志：​​​​​​​​​​​​​​
     <img alt="" height="573" src="https://i-blog.csdnimg.cn/direct/fdd32f31dd434240832a60edaeb71e5a.png" width="1664"/>
    </p>
    <p>
     查看数据库：
     <img alt="" height="540" src="https://i-blog.csdnimg.cn/direct/695112ad34494f8f8fc4756128a733e6.png" width="1100"/>
    </p>
    <p>
     我们可以看到，insertLog进行了回滚，而insertUser插入成功了
    </p>
    <p>
     结论：insertLog在进行事务回滚的时候，把自己的事务进行了回滚，则父事务(registry)和insertUser就不受影响，若insertLog不回滚自己的事务，当自己发生异常，一定会影响到父事务(registry)，insertUser它也是依靠于父事务的，所以也会受到影响。
    </p>
    <p>
     我们知道使用required，若出现异常则全部回滚，那么把异常按照上述的一个处理方式是否会全部回滚？
    </p>
    <p>
     调用方代码：
     <img alt="" height="775" src="https://i-blog.csdnimg.cn/direct/5070fc28ac434a6a9f151d10938571b1.png" width="1083"/>
    </p>
    <p>
     被调用方代码：
     <img alt="" height="557" src="https://i-blog.csdnimg.cn/direct/fa93cd62c8c44aebb4be84c8d9613db9.png" width="1129"/>
     <img alt="" height="369" src="https://i-blog.csdnimg.cn/direct/021d76ebb413483f9b6e8849c523f949.png" width="971"/>
    </p>
    <p>
     发送请求：
     <img alt="" height="753" src="https://i-blog.csdnimg.cn/direct/9396f4dfd87342fd95b48cf0c1e9f9cc.png" width="1377"/>
    </p>
    <p>
     查看日志：
     <img alt="" height="630" src="https://i-blog.csdnimg.cn/direct/7b8c40c9d3da45b2bdfcc0d4597a4ddc.png" width="1685"/>
    </p>
    <p>
     发现没有任何提交，全部回滚！
    </p>
    <p>
     NESTED和REQUIRED区别：
    </p>
    <ul>
     <li>
      整个事务如果全部执⾏成功,⼆者的结果是⼀样的
     </li>
     <li>
      如果事务⼀部分执⾏成功,REQUIRED加⼊事务会导致整个事务全部回滚.NESTED嵌套事务可以实 现局部回滚,不会影响上⼀个⽅法中执⾏的结果
     </li>
    </ul>
    <blockquote>
     <p>
      嵌套事务之所以能够实现部分事务的回滚,是因为事务中有⼀个保存点(savepoint)的概念,嵌套事务 进⼊之后相当于新建了⼀个保存点,⽽滚回时只回滚到当前保存点
     </p>
     <p>
      REQUIRED是加⼊到当前事务中,并没有创建事务的保存点,因此出现了回滚就是整个事务回滚,这就 是嵌套事务和加⼊事务的区别
     </p>
    </blockquote>
    <p>
     总结：
    </p>
    <ul>
     <li>
      1. Spring中使⽤事务,有两种⽅式:编程式事务(⼿动操作)和声明式事务.其中声明式事务使⽤较多,在⽅法上添加 @Transactional 就可以实现了
     </li>
     <li>
      2. 通过@Transactional(isolation = Isolation.SERIALIZABLE)设置事务的隔离级 别.Spring中的事务隔离级别有5种
     </li>
     <li>
      3. 通过@Transactional(propagation =Propagation.REQUIRED)设置事务的传播机制,Spring中的事务传播级别有7种,重点关注REQUIRED(默认值)和REQUIRES_NEW
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313531303337342f:61727469636c652f64657461696c732f313436303238333231" class_="artid" style="display:none">
 </p>
</div>


