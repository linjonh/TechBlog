---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33393230393131372f:61727469636c652f64657461696c732f313231393434393931"
layout: post
title: "区块链知识整理之系统架构及各层功能"
date: 2025-01-02 14:21:51 +08:00
description: "文章目录前言一、区块链技术基础模型和关键技术1.1系统架构1.1.1数据层二、使用步骤1.引入库2."
keywords: "3、描述区块链的架构,并简单解释每一层的功能"
categories: ['区块链技术知识']
tags: ['系统架构', '区块链']
artid: "121944991"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=121944991
    alt: "区块链知识整理之系统架构及各层功能"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=121944991
featuredImagePreview: https://bing.ee123.net/img/rand?artid=121944991
---

# 区块链知识整理之系统架构及各层功能

#### 文章目录

* [前言](#_5)
* [一、区块链技术基础模型和关键技术](#_17)
* + [1.1系统架构](#11_19)
  + - [1.1.1数据层](#111_24)
    - [1.1.2 网络层](#112__84)
    - [1.1.3 共识层](#113__113)
    - [1.1.4 合约层](#114__144)
* [参考文献资料汇总](#_161)

---

## 前言

本篇笔记是阅读区块链综述论文
  
[1] 代闯闯,栾海晶,杨雪莹,等. 区块链技术研究综述[J]. 计算机科学, 2021(S2).
  
[2] 刘敖迪,杜学绘,王娜,等. 区块链技术及其在信息安全领域的研究进展_刘敖迪[J]. 软件学报, 2018, 29(7): 2092-2115.
  
[3] 袁勇,王飞跃. 区块链技术发展现状与展望_袁勇[J]. 自动化学报, 2016, 42(4): 481-494.
  
和查阅一些网络资料所作整理。

---

## 一、区块链技术基础模型和关键技术

比特币是由
**交易、共识协议和通信网络**
等技术组件所构成的一种去中心化的电子交易系统，其涵盖的技术组件形成了整个比特币系统的3个渐进的层次：
**交易、区块和区块链**
。

### 1.1系统架构

区块链技术的基础架构模型如图 2 所示. 一般说来, 区块链系统由
**数据层、网络层、共识层、激励层、合约层和应用层**
组成。
  
![区块链基础架构模型](https://i-blog.csdnimg.cn/blog_migrate/6a3f5c9c2f44ebd9969cbf6792182498.png#pic_center)

#### 1.1.1数据层

比特币系统中的交易记录类似于物理系统中的交易记录，每一条交易记录中均包括
**交易信息的输入、输出地址以及转让的数目**
等信息。
  
数据层封装了底层数据区块以及相关的数据加密和时间戳等技术。每个分布式节点都可以通过特定的
**哈希算法**
和
**Merkle 树数据结构**
, 将一段时间内接收到的交易数据和代码封装到一个带有
**时间戳**
的数据区块中, 并链接到
**当前最长的主区块链上**
, 形成最新的区块. 该过程涉及
**区块、链式结构、哈希算法、Merkle树和时间戳**
等技术要素。

1. 哈希函数
     
   区块链通常并不直接保存原始数据或交易记录, 而是保存其哈希函数值, 即将原始数据编码为
   **特定长度**
   的由数字和字母组成的字符串后记入区块链。

   特点：通过哈希输出几乎不能反推输入值 (
   **单向性**
   ), 不同长度输入的哈希过程消耗大约相同的时间 (
   **定时性**
   ) 且产生固定长度的输出 (
   **定长性**
   ), 即使输入仅相差一个字节也会产生显著不同的输出值 (
   **随机性**
   ) 。

   比特币区块链通常采用双 SHA256 哈希函数, 即
   **将任意长度的原始数据经过两次 SHA256 哈希运算后转换为长度为 256 位 (32 字节) 的二进制数字来统一存储和识别**
   . 除上述特点外, SHA256 算法还具有
   **巨大的散列空间**
   (2的256次方大的散列空间 ) 和
   **抗碰撞**
   (避免不同输入值产生相同哈希值) 等特性, 可满足比特币的任何相关标记需要而不会出现冲突。
2. 数据区块
     
   如图 3 所示, 每个数据区块一般包含
   **区块头 (Header)**
   和
   **区块体 (Body)**
   两部分。
     
   区块头封装了
   **当前版本号 (Version)、前一区块地址(Prev-block)、当前区块的目标哈希值 (Bits)、当前区块 PoW 共识过程的解随机数 (Nonce)、Merkle根 (Merkle-root) 以及时间戳 (Timestamp)**
   等信息。
     
   区块体则包括
   **当前区块的交易数量**
   以及
   **经过验证的、区块创建过程中生成的所有交易记录**
   。 这些记录通过
   **Merkle 树的哈希过程**
   生成唯一的
   **Merkle 根**
   并记入区块头。

![区块结构](https://i-blog.csdnimg.cn/blog_migrate/aeea4c25da79bcf1e76633c7933dbe72.png#pic_center)

1. Merkle树
     
   结构： 如图 3 所示, Merkle 树通常包含
   **区块体的底层 (交易)数据库**
   ,
   **区块头的根哈希值 (即Merkle 根)**
   以及
   **所有沿底层区块数据到根哈希的分支**
   。

   作用：快速归纳和校验区块数据的存在性和完整性，即进行
   **SPV（简单支付验证）**
   。

   优点：①是极大地提高了区块链的
   **运行效率和可扩展性**
   ,使得区块头只需包含根哈希值而不必封装所有底层数据, 这使得哈希运算可以高效地运行在智能手机甚至物联网设备上;②可持 “简化支付验证”协议, 即
   **在不运行完整区块链网络节点的情况下, 也能够对 (交易) 数据进行检验。**
     
   ![支付验证过程](https://i-blog.csdnimg.cn/blog_migrate/cc4d73a03f06ab7658438f9f51b03208.png#pic_center)

   支付验证过程：假设我们要验证区块中存在Hash值为9Dog:64（绿色框）的交易，我们仅需要知道1FXq:18、ec20、8f74（黄色框）即可计算出781a、5c71与Root节点（藕粉色框）的哈希，如果最终计算得到的Root节点哈希与区块头中记录的哈希（6c0a）一致，即代表该交易在区块中存在。（依据：①默克尔树是
   **从下往上**
   逐层计算的，所以只要知道相邻的另一个节点的hash值就可以一直往上计算直到根节点，②
   **根节点的hash值**
   可以准确的作为一组交易的
   **唯一摘要**
   ，依据这两点就可以来验证一笔交易是否存在。）

   算法复杂度：O(log2N)。 这将极宽和验证时间, 并使得仅保存部分相关区块链数据的轻量级客户端成为可能。

   简单支付验证(Simplified Payment Verification, SPV)和交易验证：
   *简单支付验证*
   是一种无须维护完整的区块链信息，只需要保存所有的
   **区块头部**
   信息即可进行支付验证的技术，简单的说就是支付验证只需验证该笔交易是否被确认过了；
   **交易验证**
   的过程较为复杂，包括
   **余额验证、双重支付**
   判断等，通常由
   **保存区块链完整信息的区块链验证节点**
   来完成。验证节点虽然可以精准无误地验证任何一笔交易，但需要拥有巨大的数据量。（更详细见：
   [区块链交易验证和支付验证](https://blog.csdn.net/qq_44587855/article/details/103225530?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163957129616780271911939%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163957129616780271911939&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-103225530.first_rank_v2_pc_rank_v29&utm_term=%E6%94%AF%E4%BB%98%E9%AA%8C%E8%AF%81%E5%92%8C%E4%BA%A4%E6%98%93%E9%AA%8C%E8%AF%81&spm=1018.2226.3001.4187)
   ）
2. 时间戳
     
   区块链技术要求
   **获得记账权的节点必须在当前数据区块头中加盖时间戳**
   , 表明区块数据的写入时间。

   主链上各区块是按照
   **时间顺序**
   依次排列的。

   意义：①可以作为区块数据的
   **存在性证明 (Proof of existence)**
   ,有助于形成不可篡改和不可伪造的区块链数据库,从而为区块链应用于公证、知识产权注册等时间敏感的领域奠定了基础。②更为重要的是, 时间戳为未来基于区块链的互联网和大数据增加了时间维度, 使得通过区块数据和时间戳来重现历史成为可能。
3. 链式结构
     
   取得记账权的矿工将当前区块链接到前一区块, 形成最新的区块主链。 各个区块依次环环相接, 形成从创世区块到当前区块的一条
   **最长主链**
   , 从而记录了区块链数据的完整历史, 能够提供
   **区块链数据的溯源和定位功能**
   , 任意数据都可以通过此链式结构顺藤摸瓜、追本溯源。

   分叉及解决方式：两个矿工
   **同时**
   “挖出” 两个新的区块加以链接的话, 区块主链可能会出现暂时的 “分叉”现象。其解决方法是约定矿工总是选择
   **延长累计工作量证明最大的区块链**
   . 因此, 当主链分叉后, 后续区块的矿工将通过计算和比较, 将其区块链接到当前累计工作量证明最大化的备选链上, 形成更长的新主链。
4. 非对称加密
     
   非对称加密通常在加密和解密过程中使用两个
   **非对称的密码**
   , 分别称为公钥和私钥。

   特点：①用其中一个密钥 (公钥或私钥) 加密信息后, 只有另一个对应的密钥才能解开; ②是公钥可向其他人公开、私钥则保密, 其他人无法通过该公钥推算出相应的私钥。

   应用场景：①
   **信息加密**
   场景主要是由信息发送者 (记为 A)
   **使用接受者 (记为 B) 的公钥**
   对信息加密后再发送给 B,
   **B 利用自己的私钥**
   对信息解密. 比特币交易的加密即属于此场景; ②
   **数字签名**
   场景则是由
   **发送者 A 采用自己的私钥**
   加密信息后发送给 B, B 使用 A 的公钥对信息解密、从而可确保信息是由 A 发送的; ③
   **登录认证**
   场景则是由
   **客户端使用私钥**
   加密登录信息后发送给服务器, 后者接收后采用该客户端的公钥解密并认证登录信息。

   比特币中非对称加密机制：
   ![比特币中非对称加密机制](https://i-blog.csdnimg.cn/blog_migrate/06c4693d8e86111d909a998aa279ea39.png#pic_center)
     
   比特币系统一般通过调用操作系统底层的随机数生成器来生成
   **256 位随机数作为私钥**
   。比特币
   **私钥的总量可达2的256次方**
   , 极难通过遍历全部私钥空间来获得存有比特币的私钥, 因而是密码学安全的。为便于识别, 256 位二进制形式的
   **比特币私钥**
   将通过 SHA256 哈希算法和 Base58 转换, 形成 50 个字符长度的易识别和书写的私钥提供给用户;
   **比特币的公钥**
   是由私钥首先经过 Secp256k1 椭圆曲线算法生成 65 字节长度的随机数。该公钥可用于产生比特币交易时使用的地址, 其生成过程为首先将公钥进行 SHA256 和 RIPEMD160 双哈希运算并生成20 字节长度的摘要结果 (即 hash160 结果), 再经过SHA256 哈希算法和 Base58 转换形成 33 字符长度的比特币地址。
   **公钥生成过程是不可逆的, 即不能通过公钥反推出私钥。**
     
   比特币的公钥和私钥通常保存于比特币钱包文件。
     
   **私钥最为重要，丢失私钥就意味着丢失了对应地址的全部比特币资产。**

#### 1.1.2 网络层

网络层封装了区块链系统的
**组网方式、消息传播协议和数据验证机制**
等要素. 结合实际应用需求,通过设计特定的传播协议和数据验证机制, 可使得区块链系统中每一个节点都能参与区块数据的校验和记账过程, 仅当区块数据通过
**全网大部分节点**
验证后, 才能记入区块链。

1. 组网方式
     
   区块链系统的节点一般具有
   **分布式、自治性、开放可自由进出**
   等特性, 因而一般采用
   **对等式网络 (Peer-to-peer network, P2P 网络)**
   来组织散布全球的参与数据验证和记账的节点.。

   P2P：P2P网络中的每个节点均
   **地位对等**
   且以
   **扁平式拓扑结构**
   相互连通和交互,
   **不存在任何中心化的特殊节点和层级结构**
   。

   ![节点结构及作用](https://i-blog.csdnimg.cn/blog_migrate/ed9dea6cbc570834355bbc0bbadc2aed.png#pic_center)
   如图 4 所示,每个节点
   **均会承担网络路由任务**
   ,把其他节点传递来的交易信息转发给更多的相邻节点,网络中有些节点还具有
   **钱包和挖矿功能**
   。同时，节点具有
   **验证区块数据**
   的能力,但
   **不必所有节点**
   都存储完整的区块链数据， 按照节点
   **存储数据量**
   的不同, 可以分为
   **全节点**
   和
   **轻量级节点**
   。
     
   全节点保存有
   **从创世区块到当前最新区块为止的完整区块链数据**
   , 并通过
   **实时参与区块数据的校验和记账来动态更新主链**
   。其优势在于不依赖任何其他节点而能够
   **独立**
   地实现任意区块数据的校验、查询和更新, 劣势则是
   **维护全节点的空间成本较高**
   ; 轻量级节点则仅保存一
   **部分区块链数据**
   , 节点具有验证区块数据的能力,节点间可以通过基于 Merkle 树的SPV
   **向相邻节点请求所需数据**
   以验证交易的合法性,并对交易数据进行更新。
2. 数据传播协议
     
   任一区块数据生成后, 将由生成该数据的节点广播到全网其他所有的节点来加以验证。根据中本聪的设计, 比特币系统的交易数据传播协议包括如下步骤:
     
   ① 比特币交易节点将新生成的
   **交易数据向全网所有节点**
   进行广播;
     
   ② 每个节点都将收集到的交易数据存储到一个区块中;
     
   ③ 每个节点基于自身算力在区块中找到一个具有足够难度的
   **工作量证明**
   ;
     
   ④ 当节点找到区块的工作量证明后, 就向全网所有节点广播此区块;
     
   ⑤ 仅当包含在区块中的
   **所有交易都是有效的且之前未存在过的**
   , 其他节点才认同该区块的有效性;
     
   ⑥ 其他节点接受该数据区块,
   **并在该区块的末尾制造新的区块以延长该链条**
   , 而将被接受区块的随机哈希值视为先于新区块的随机哈希值。

   需要说明的是, ① 如果交易节点是与其他节点无连接的新节点, 比特币系统通常会将一组长期稳定运行的 “
   **种子节点**
   ” 推荐给新节点建立连接, 或者推荐至少一个节点连接到新节点.。② 交易数据广播时, 并不需要全部节点均接收到, 而是只要
   **足够多的节点**
   做出响应即可整合进入区块账本中. 未接收到特定交易数据的节点则
   **可向邻近节点请求下载**
   该缺失的交易数据。
3. 数据验证机制
     
   节点接收到邻近节点发来的数据后, 将
   **首先验证该数据的有效性**
   。如果数据有效, 则按照接收顺序为新数据建立存储池以暂存尚未记入区块的有效数据, 同时继续向邻近节点转发; 如果数据无效, 则立即废弃该数据, 从而保证无效数据不会在区块链网络继续传播。

   在比特币中, 比特币的
   **矿工节点**
   会收集和验证P2P 网络中广播的尚未确认的交易数据, 并对照预定义的标准清单, 从数据结构、语法规范性、输入输出和数字签名等各方面校验交易数据的有效性, 并将有效交易数据整合到当前区块中;同理，当矿工节点“挖” 到新区块后, 其他矿工节点也会按照预定义标准来校验该区块是否包含足够工作量证明, 时间戳是否有效等; 如确认有效, 其他矿工节点会将该区块链接到主区块链上, 并开始竞争下一个新区块。

区块链全网数据
**同时存储于去中心化系统的所有节点**
上, 即使部分节点失效, 只要
**仍存在一个正常运行的节点**
, 区块链主链数据就可完全恢复而不会影响后续区块数据的记录与更新。这种完全的“去中心化”模式，具有更高的安全性。

#### 1.1.3 共识层

区块链技术的核心优势之一就是能够在决策权高度分散的去中心化系统中使得各节点高效地针对区块数据的有效性达成共识。
  
共识机制是
**分布式节点间**
根据某一事先协商好的
**规则**
来确定分布式账本(即区块)的
**记账权归属**
的方法,以此
**使不同节点对交易数据达成共识**
,保障分布式账本数据的
**一致性**
和
**真实性**
。.共识机制主要用来解决
**拜占庭将军**
问题，常见的共识机制按照数据一致性可进行如下划分.
  
![共识机制分类](https://i-blog.csdnimg.cn/blog_migrate/0ac0681993c8f3498c88b52897bda1ec.png#pic_center)

1. PoW共识：其核心思想是通过引入
   **分布式节点的算力竞争**
   来保证数据一致性和共识的安全性.比特币系统中, 各节点 (即
   **矿工**
   )
     
   基于各自的计算机算力相互竞争来共同解决一个求解复杂但验证容易的 SHA256 数学难题 (即
   **挖矿**
   ),
     
   最快解决该难题的节点将获得区块记账权和系统自动生成的比特币奖励.

   符合要求的区块头哈希值通常由
   **多个前导零**
   构成, 目标哈希值越小, 区块头哈希值的前导零越多,成功找到合适的随机数并 “挖”
     
   出新区块的难度越大.
   **比特币区块链系统的安全性和不可篡改性是由PoW 共识机制的强大算力所保证的**
   ,
     
   任何对于区块数据的攻击或篡改都必须重新计算该区块以及其后所有区块的 SHA256 难题, 并且计算速度必须使得伪造链长度超过主链,
     
   这种攻击难度导致的成本将远超其收益.

   优点：PoW 共识机制是具有重要意义的创新, 其近乎完美地
   **整合了比特币系统的货币发行、交易支付和验证等功能**
   ,
     
   并通过
   **算力竞争**
   保障系统的安全性和去中心性; 缺陷：其强大算力造成的
   **资源浪费 (如电力)**
   历来为研究者所诟病, 而且长达
     
   10 分钟的
   **交易确认时间**
   使其相对不适合小额交易的商业应用.
2. PoS共识：本质上是采用
   **权益证明**
   来代替 PoW中的基于哈希算力的工作量证明, 是由系统中具有
   **最高权益**
   而非最高算力的节点获得区块记账权.
   **权益体现为节点对特定数量货币的所有权, 称为币龄或币天数 (Coin days)**
   .

   PoS 共识过程中的难度与交易输入的币龄成反比,
   **消耗币龄越多则挖矿难度越低**
   .

   优点：PoS将算力竞争转化为权益竞争,不仅
   **节约算力**
   ,权益的引入也能够
   **防止节点发动恶意攻击**
   ;同时
   **促使所有节点有责任维护区块链的安全稳定运行以保障自身权益**
   .PoS中需要拥有超全网一半的权益发动51%攻击,但其成本
   **高于**
   拥有超全网一半的算力,另外创建区块需要
   **消耗权益**
   ,使得PoS持续进行51%攻击的难度增加,
   **一定程度上降低了安全风险.**
     
   缺点：
   **没有解决中心化程度增强的问题**
   ,新区块的生成趋向于权益高的节点.
3. DPoS 共识机制：授权股份证明（Delegated Proof of Stake, DPo S）共识算法尝试解决Po W和Po S存在的问题，通过实施
   **去中心化的民主方式**
   ，每个币相当于一张选票，持有币的人可以根据自己持有币的数量来将自己的若干选票投给
   **自己信任的受托人**
   。系统会选出获得投票数量最多的N个人作为
   **系统受托人**
   ，他们的工作是签署（生产）区块，且在每个区块被签署之前，必须先验证前一个区块已经被受信任节点签署。

   优点：通过基于权益的民主投票产生信任节点集合,每个节点都可以参与到信任节点的选择上，避免了
   **主节点的产生趋向于高权益节点的问题**
   .区块的产生
   **不需要消耗算力**
   ,相对于PoS更加节省能耗.
     
   缺点：但选举的信任节点全权负责创建区块,这在一定程度上
   **降低了去中心化程度**
   .
     
   ![共识算法性能指标对比](https://i-blog.csdnimg.cn/blog_migrate/f90a02e26daa86e29e89e1395c847d7c.png#pic_center)

#### 1.1.4 合约层

合约层封装区块链系统的
**各类脚本代码、算法以及由此生成的更为复杂的智能合约**
. 如果说数据、网络和共识三个层次作为区块链底层 “虚拟机” 分别承担数据表示、数据传播和数据验证功能的话,
**合约层则是建立在区块链虚拟机之上的商业逻辑和算法, 是实现区块链系统灵活编程和操作数据的基础**
.

* 智能合约
    
  区块链技术的出现重新定义了智能合约. 智能合约是区块链的核心构成要素 (合约层),
  **是由事件驱动的、具有状态的、运行在可复制的共享区块链数据账本上的计算机程序, 能够实现主动或被动的处理数据, 接受、储存和发送价值, 以及控制和管理各类链上智能资产等功能**
  .

  智能合约同样具有区块链数据的一般特征, 如分布式记录、存储和验证, 不可篡改和伪造等.
    
  ![智能合约的运作机理](https://i-blog.csdnimg.cn/blog_migrate/70a2bd24ac7dc4c8744bc484a54dc5fc.png#pic_center)
  智能合约的运作机理如图 5 所示: 通常情况下,智能合约经各方签署后, 以程序代码的形式附着在区块链数据 (例如一笔比特币交易) 上, 经 P2P 网络传播和节点验证后记入区块链的特定区块中. 智能合约封装了预定义的若干状态及转换规则、触发合约执行的情景 (如到达特定时间或发生特定事件等)、特定情景下的应对行动等. 区块链可实时监控智能合约的状态, 并通过核查外部数据源、确认满足特定触发条件后激活并执行合约.

---

## 参考文献资料汇总

[1] 代闯闯,栾海晶,杨雪莹,等. 区块链技术研究综述[J]. 计算机科学, 2021(S2).
  
[2] 刘敖迪,杜学绘,王娜,等. 区块链技术及其在信息安全领域的研究进展_刘敖迪[J]. 软件学报, 2018, 29(7): 2092-2115.
  
[3] 袁勇,王飞跃. 区块链技术发展现状与展望_袁勇[J]. 自动化学报, 2016, 42(4): 481-494.
  
[4] 郑敏,王虹,刘洪,等. 区块链共识算法研究综述[J]. 信息网络安全, 2019(7): 8-24.
  
[5] 靳世雄,张潇丹,葛敬国,等. 区块链共识算法研究综述[J]. 信息安全学报, 2021, 6(2): 85-100.
  
[4]
[简单支付验证-SPV](https://blog.csdn.net/xq723310/article/details/80156169?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163956624516780366559305%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163956624516780366559305&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80156169.first_rank_v2_pc_rank_v29&utm_term=%E7%AE%80%E5%8D%95%E6%94%AF%E4%BB%98%E9%AA%8C%E8%AF%81&spm=1018.2226.3001.4187)
  
[5]
[区块链100篇之第九篇–默克尔树（Merkle Tree）](https://blog.csdn.net/weixin_37504041/article/details/80474636)