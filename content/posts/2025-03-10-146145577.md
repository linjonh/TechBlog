---
layout: post
title: "Rust-模式匹配中的可反驳性与不可反驳性"
date: 2025-03-10 10:06:22 +0800
description: "模式匹配（Pattern Matching）是 Rust 语言的核心特性之一，在 `match`、`if let`、`while let`、`for` 以及 `let` 语句中都可以使用模式。然而，Rust 还区分 **可反驳（refutable）** 和 **不可反驳（irrefutable）** 模式。在不同的场景下，Rust 对这两种模式的要求不同。如果你不理解这一点，可能会遇到编译错误或警告。本文将详细讲解 **可反驳模式** 和 **不可反驳模式** 的概念、使用场景以及如何正确地应用它们。"
keywords: "Rust 模式匹配中的可反驳性与不可反驳性"
categories: ['Rust']
tags: ['开发语言', '后端', 'Rust']
artid: "146145577"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146145577
    alt: "Rust-模式匹配中的可反驳性与不可反驳性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146145577
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146145577
cover: https://bing.ee123.net/img/rand?artid=146145577
image: https://bing.ee123.net/img/rand?artid=146145577
img: https://bing.ee123.net/img/rand?artid=146145577
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Rust 模式匹配中的可反驳性与不可反驳性
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="1__0">
     </a>
     1. 什么是可反驳模式和不可反驳模式？
    </h3>
    <h4>
     <a id="11Irrefutable_Patterns_2">
     </a>
     1.1.
     <strong>
      不可反驳模式（Irrefutable Patterns）
     </strong>
    </h4>
    <p>
     不可反驳模式是
     <strong>
      总能匹配任何可能值
     </strong>
     的模式。例如，下面的
     <code>
      let
     </code>
     语句：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <code>
      x
     </code>
     是一个不可反驳模式，它匹配
     <strong>
      任何值
     </strong>
     ，不会失败。因此，它适用于
     <code>
      let
     </code>
     语句、函数参数和
     <code>
      for
     </code>
     循环等必须始终成功的情况。
    </p>
    <h4>
     <a id="12Refutable_Patterns_12">
     </a>
     1.2.
     <strong>
      可反驳模式（Refutable Patterns）
     </strong>
    </h4>
    <p>
     可反驳模式是
     <strong>
      可能匹配失败
     </strong>
     的模式。例如：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> some_value <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这里的
     <code>
      Some(x)
     </code>
     就是一个可反驳模式，因为如果
     <code>
      some_value
     </code>
     是
     <code>
      None
     </code>
     ，那么它将无法匹配
     <code>
      Some(x)
     </code>
     ，这就是
     <strong>
      匹配失败
     </strong>
     的情况。
    </p>
    <p>
     Rust 要求
     <strong>
      某些语法结构只能接受不可反驳模式，而另一些可以接受可反驳模式
     </strong>
     。接下来，我们看看具体的规则。
    </p>
    <h3>
     <a id="2__26">
     </a>
     2. 哪些地方必须使用不可反驳模式？
    </h3>
    <p>
     Rust
     <strong>
      不允许在必须匹配的地方使用可反驳模式
     </strong>
     ，否则编译器会报错。例如：
    </p>
    <h4>
     <a id="21_let__30">
     </a>
     2.1.
     <strong>
      <code>
       let
      </code>
      语句
     </strong>
    </h4>
    <p>
     <code>
      let
     </code>
     语句要求
     <strong>
      始终能匹配
     </strong>
     ，所以它只能接受
     <strong>
      不可反驳模式
     </strong>
     。如果我们尝试在
     <code>
      let
     </code>
     语句中使用可反驳模式，例如：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ❌ 编译错误</span>
</code></pre>
    <p>
     这段代码的
     <code>
      Some(x)
     </code>
     是一个可反驳模式，但
     <code>
      let
     </code>
     语句无法处理
     <strong>
      匹配失败
     </strong>
     的情况。如果
     <code>
      Some(5)
     </code>
     变成
     <code>
      None
     </code>
     ，
     <code>
      let
     </code>
     语句就不知道该怎么做。因此，Rust
     <strong>
      禁止
     </strong>
     这种写法，编译器会报错：
    </p>
    <pre><code class="prism language-console">error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:2:5
  |
2 | let Some(x) = Some(5);
  |     ^^^^^^^ pattern `None` not covered
  |
  = help: consider using `if let` to handle the variant that does not match
</code></pre>
    <h4>
     <a id="22__49">
     </a>
     2.2.
     <strong>
      函数参数
     </strong>
    </h4>
    <p>
     函数参数也是
     <strong>
      必须匹配的
     </strong>
     ，所以它们只能使用
     <strong>
      不可反驳模式
     </strong>
     。例如：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">print_value</span><span class="token punctuation">(</span><span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// ❌ 编译错误</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这里
     <code>
      Some(x)
     </code>
     是
     <strong>
      可反驳模式
     </strong>
     ，但函数参数必须始终能匹配所有传入值。如果
     <code>
      Option&lt;i32&gt;
     </code>
     传入
     <code>
      None
     </code>
     ，
     <code>
      Some(x)
     </code>
     就无法匹配，因此编译器报错。
    </p>
    <p>
     如果需要处理
     <code>
      None
     </code>
     ，可以改为：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">print_value</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> value <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"No value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="23_for__72">
     </a>
     2.3.
     <strong>
      <code>
       for
      </code>
      循环
     </strong>
    </h4>
    <p>
     <code>
      for
     </code>
     也要求模式
     <strong>
      始终匹配
     </strong>
     ，因为循环的每次迭代都会提供一个值。如果模式匹配失败，循环应该做什么呢？Rust 无法处理这种情况，所以它要求
     <code>
      for
     </code>
     循环的模式必须是
     <strong>
      不可反驳的
     </strong>
     。
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">None</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">in</span> values <span class="token punctuation">{<!-- --></span>  <span class="token comment">// ❌ 编译错误</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这里
     <code>
      Some(x)
     </code>
     是
     <strong>
      可反驳模式
     </strong>
     ，但
     <code>
      for
     </code>
     可能会遇到
     <code>
      None
     </code>
     ，导致匹配失败。因此，Rust 禁止这种写法。我们可以改用
     <code>
      if let
     </code>
     ：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">for</span> value <span class="token keyword">in</span> values <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> value <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="3__94">
     </a>
     3. 哪些地方可以使用可反驳模式？
    </h3>
    <p>
     Rust 允许在
     <strong>
      可以处理匹配失败的地方
     </strong>
     使用可反驳模式，包括：
    </p>
    <h4>
     <a id="31_if_let__98">
     </a>
     3.1.
     <strong>
      <code>
       if let
      </code>
      语句
     </strong>
    </h4>
    <p>
     <code>
      if let
     </code>
     是
     <code>
      match
     </code>
     的简化版，它允许匹配失败并进入
     <code>
      else
     </code>
     分支。例如：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"No value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      if let
     </code>
     <strong>
      专门用于处理可反驳模式
     </strong>
     ，如果模式匹配失败，代码就会跳过
     <code>
      if let
     </code>
     块，进入
     <code>
      else
     </code>
     。
    </p>
    <p>
     如果
     <code>
      if let
     </code>
     使用的是不可反驳模式，Rust 会给出
     <strong>
      警告
     </strong>
     ，因为这样
     <code>
      if let
     </code>
     就失去了意义。例如：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">// ⚠️ 编译器警告</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     编译器会提示：
    </p>
    <pre><code class="prism language-console">warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 | if let x = 5 {
  |        ^ pattern `x` always matches
  |
  = note: this pattern will always match, so the `if let` is useless
</code></pre>
    <h4>
     <a id="32_while_let__132">
     </a>
     3.2.
     <strong>
      <code>
       while let
      </code>
      语句
     </strong>
    </h4>
    <p>
     类似
     <code>
      if let
     </code>
     ，
     <code>
      while let
     </code>
     允许循环
     <strong>
      直到模式匹配失败
     </strong>
     ，适用于迭代可变数据结构：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> stack <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>top<span class="token punctuation">)</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Popped: {}"</span><span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这里
     <code>
      stack.pop()
     </code>
     可能返回
     <code>
      None
     </code>
     ，所以
     <code>
      Some(top)
     </code>
     是
     <strong>
      可反驳模式
     </strong>
     ，但
     <code>
      while let
     </code>
     可以处理匹配失败的情况，所以它是合法的。
    </p>
    <h3>
     <a id="4__147">
     </a>
     4. 总结
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        语法结构
       </th>
       <th>
        需要的模式
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         let
        </code>
        语句
       </td>
       <td>
        不可反驳
       </td>
       <td>
        不能使用可反驳模式，否则匹配失败后代码无法执行
       </td>
      </tr>
      <tr>
       <td>
        函数参数
       </td>
       <td>
        不可反驳
       </td>
       <td>
        函数参数必须匹配所有传入值
       </td>
      </tr>
      <tr>
       <td>
        <code>
         for
        </code>
        循环
       </td>
       <td>
        不可反驳
       </td>
       <td>
        <code>
         for
        </code>
        不能跳过某些值，因此不能使用可反驳模式
       </td>
      </tr>
      <tr>
       <td>
        <code>
         if let
        </code>
       </td>
       <td>
        可反驳
       </td>
       <td>
        专门用于处理可能匹配失败的情况
       </td>
      </tr>
      <tr>
       <td>
        <code>
         while let
        </code>
       </td>
       <td>
        可反驳
       </td>
       <td>
        允许循环，直到匹配失败
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     Rust 通过
     <strong>
      类型系统和编译检查
     </strong>
     确保模式匹配的正确性。理解
     <strong>
      可反驳模式
     </strong>
     和
     <strong>
      不可反驳模式
     </strong>
     的区别，有助于编写更安全、更高效的 Rust 代码。
    </p>
    <p>
     希望这篇文章能帮助你更好地理解 Rust 的模式匹配机制，欢迎交流讨论！🚀
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333131343230392f:61727469636c652f64657461696c732f313436313435353737" class_="artid" style="display:none">
 </p>
</div>


