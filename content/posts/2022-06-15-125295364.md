---
layout: post
title: "哈希hash从原理到应用"
date: 2022-06-15 16:55:18 +0800
description: "在百度上搜索哈希（hash），你将会知道：将任意长度的输入（关键字），通过Hash算法变成固定长度的"
keywords: "哈希算法原理"
categories: ['未分类']
tags: ['算法', '散列表', '哈希算法']
artid: "125295364"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=125295364
  alt: "哈希hash从原理到应用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=125295364
featuredImagePreview: https://bing.ee123.net/img/rand?artid=125295364
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     哈希（hash）：从原理到应用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一、什么是哈希
    </h3>
    <p style="text-align:center;">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/01e1f19b007b5c890fb0464bdee63fcf.png"/>
    </p>
    <p>
    </p>
    <p>
     在百度上搜索哈希（hash），你将会知道：
     <strong>
      将任意长度的输入（关键字），通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值，通常哈希值代表了关键字的存储位置。
     </strong>
    </p>
    <p>
     但是为什么要这样做呢？或者说，哈希是怎样来的呢？
    </p>
    <p>
     <strong>
      个人觉得哈希的出现解决了两个问题：存储和搜索。
     </strong>
    </p>
    <p>
     <strong>
      1.存储（数据结构）
     </strong>
     ：如果在容器中保存对象及其关联的键，并且不用键来决定 （键/对象） 对的顺序，那就必须对键值釆用其他方式来确定元素在内存中的位置。
    </p>
    <p>
     如果使用像 string 这样的对象作为键，就会遇到一些问题，可能的变量的数目是巨大的。具有 10 个字符的字母字符串可能的个数是 26^10。这个索引范围没有多大用处。我们需要一种机制来将它变为可接受的范围；而且理想情况下，这个机制可以为每个键生成唯一的值，根据这个值所在的位置来找到对应的字符串。这正是哈希需要做的事情之一。
    </p>
    <p>
     <strong>
      2.搜索（算法/思想）
     </strong>
     ：当我们处理数据的时候，不外乎使用顺序结构、链表和树结构。但是使用这些结构时，元素的关键字与其存储位置之间通常没有对应的逻辑关系，这时候想要查找一个元素，我们根本不知道它在结构中的存储位置，甚至不知道它在不在结构中，这要求我们必须要不断地比较关键字进行查找，如顺序结构查找的时间是O(N)，树结构是O(logN)，通常这带来的结果是不断for循环遍历，极大地增加了代码时间复杂度。
    </p>
    <p>
     那么可不可以有更好的搜索方法呢？哈希函数应运而生：由上面的定义可知，hash完美解决了这一问题，可以不经过任何比较，直接从哈希表/集中得到要搜索的元素或判断是否存在。
    </p>
    <h3>
     二、哈希会出现的问题
    </h3>
    <p>
     <strong>
      哈希有两种缺点：实际缺点和根本缺点。
     </strong>
    </p>
    <p>
     <strong>
      1.根本缺点：
     </strong>
    </p>
    <p>
     哈希表的缺点它是基于数组的，数组创建后难于扩展某些哈希表被基本填满时，性能下降得非常严重，所以程序虽必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。
    </p>
    <p>
     而且，也没有一种简便的方法可以以任何一种顺序〔例如从小到大〕遍历表中数据项。如果需要这种能力，就只能选择其他数据结构。
    </p>
    <p>
     然而如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。
    </p>
    <p>
     <strong>
      2.实际缺点：
     </strong>
    </p>
    <p>
     <strong>
      哈希冲突：
     </strong>
     由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突，即不同的关键字得到的值相同。
    </p>
    <p>
     这样的话我们前面所有的理想情况就成了笑谈，所以处理问题时要解决哈希冲突。
    </p>
    <h3>
     三、构造哈希算法
    </h3>
    <p>
     <strong>
      基本原则
     </strong>
     ：
     <strong>
      便于计算
     </strong>
     （函数计算时间&lt;=查找时间）；（散列地址）
     <strong>
      分布均匀
     </strong>
    </p>
    <h4>
     3.1 直接定址法
    </h4>
    <p>
     直接定值法是取关键字的某个线性函数值为散列地址，即 f(key) = a*key + b。其优点是简单、均匀，不会产生冲突；但缺点是需要知道关键字的分布情况，希望数值是连续的。
    </p>
    <h4>
     3.2 数字分析法
    </h4>
    <p>
     数字分析法通常适合处理关键字位数比较大的情况，例如我们现在要存储外卖信息登记表，如果用手机号作为关键字，那么抽取后面的四位数字作为散列地址是不错的选择。
    </p>
    <h4>
     3.3 平方取中法
    </h4>
    <p>
     平方取中法是将关键字平方之后取中间若干位数字作为散列地址。这种方法适用于不知道关键字的分布，且数值的位数又不是很大的情况。
    </p>
    <h4>
     3.4 折叠法
    </h4>
    <p>
     折叠法是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长取后几位作为散列地址。
    </p>
    <h4>
     3.5 除留余数法
    </h4>
    <p>
     <strong>
      此方法最常用：
     </strong>
    </p>
    <p>
     f(key) = key mod p(p &lt;= n)  n：散列表的长度。
    </p>
    <p>
     p的选择非常非常非常重要。
    </p>
    <h4>
     3.6 随机数法
    </h4>
    <p>
     f(key) = random(key)
    </p>
    <p>
     当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。
    </p>
    <h3>
     四、处理哈希冲突
    </h3>
    <h4>
     4.1 开放定址法
    </h4>
    <p>
     当发生哈希冲突时，寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，处理冲突的过程结束，记录填入的位置：
     <br/>
     fi(key) = (f(key)+di) MOD n
    </p>
    <p>
     di为增量序列，可以有下列三种取法：
    </p>
    <p>
     1.di = 1,2,...,n-1：线性探测再散列；
    </p>
    <p>
     2.di = 1^2,-1^2,...,k^2,-k^2(k&lt;=n/2) 二次探测再散列
    </p>
    <p>
     3.di = 伪随机数序列：伪随机探测再散列
    </p>
    <h4>
     4.2 链地址法
    </h4>
    <p style="text-align:center;">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/78dee7dbe50e7cb28234c05af2854839.png"/>
    </p>
    <p>
    </p>
    <h4>
     4.3 公共溢出区法
    </h4>
    <p>
     没有冲突的元素放在基本表，有冲突的元素，将多余的元素放在冲突表。
    </p>
    <h3>
     五、C++ STL 容器：哈希表和哈希集
    </h3>
    <p>
     <a href="http://c.biancheng.net/view/vip_7723.html" rel="nofollow" title="深度剖析C++无序容器的底层实现机制 (biancheng.net)">
      深度剖析C++无序容器的底层实现机制 (biancheng.net)
     </a>
    </p>
    <h4>
     5.1 无序哈希表unordered_map
    </h4>
    <p>
     1.以键值对（pair类型）的形式存储数据
    </p>
    <p>
     2.存储的各个键值对的键互不相同且不允许被修改
    </p>
    <p>
     3.不会自行对存储的键值对进行排序
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt; //哈希表头文件
using namespace std;

int main(){
//建立哈希表
unordered_map&lt;Type,Type&gt; hashsmap
//第一个 Type 是键的变量类型，第二个是值得变量类型，hashmap 是该哈希表的名称

    //插入键值对的两种方法
    hashmap.insert(make_pair(key，value));
    hashmap[key] = value;

    //删除键值对
    hashset.erase(key)

    //查询键值
    cout&lt;&lt;hashmap[key]&lt;&lt;endl;

    //搜索键值对
    if(hashmap.count(key)&gt;0) cout&lt;&lt;"exist"&lt;&lt;endl;

    //遍历哈希表
    for (auto i = hashmap.begin(); i != hashmap.end(); i++)
    {
        cout &lt;&lt; "(" &lt;&lt; i-&gt;first &lt;&lt; "," &lt;&lt; i-&gt;second &lt;&lt; ") "&lt;&lt;endl;
    }

    /* 其他常用方法
     * empty() 若容器为空，返回true；
     * size() 返回当前容器存有键值对的个数
     * at(key) 返回容器中存储的键key对应的值，如果key不存在，则会抛出out_of_range异常
     * clear() 清空容器
     * find(key) 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，
     * 则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器)
     */

}</code></pre>
<h4>
5.2  无序哈希集 unordered_set
</h4>
<p>
无序哈希集是一种功能简单的哈希结构：
</p>
<p> 1.不再以键值对的形式存储数据，而是直接存储数据的值(存储的键值对 键和值相同 所以只存 value 即可)；
</p>
<p> 2.容器内部存储的各个元素的值都互不相等，且不能被修改；
</p>
<p> 3.不会自行对内部存储的数据进行排序。
</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt; //哈希集头文件
using namespace std;

int main(){
//建立哈希集
unordered_set&lt;Type&gt; hashset
//Type 是哈希集中键的变量类型，hashset 是该哈希集的名称

    //插入键
    hashset.insert(key)

    //删除键
    hashset.erase(key)

    //搜索键
    if(hashset.count(key) &gt; 0) cout&lt;&lt;"exist"&lt;&lt;endl;

    //遍历哈希集
    for (auto i = hashset.begin(); i != hashset.end(); i++)
    {
        cout &lt;&lt; (*i) &lt;&lt; endl;
    }

    /* 其他常用方法
     * empty() 若容器为空，返回true；
     * size() 返回当前容器存有元素的个数
     * clear() 清空容器
     * find(key)查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一
     * 个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）
     */

}</code></pre>

   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36313637373430362f:61727469636c652f64657461696c732f313235323935333634" class_="artid" style="display:none">
 </p>
</div>
