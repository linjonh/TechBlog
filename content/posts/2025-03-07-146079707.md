---
layout: post
title: "蓝桥备赛12-顺序表和-vector上"
date: 2025-03-07 18:41:33 +0800
description: "线性表是 n 个具有 相同特性 的数据元素的有序序列 。"
keywords: "蓝桥备赛（12）- 顺序表和 vector（上）"
categories: ['未分类']
tags: ['算法', '数据结构', '开发语言', 'C']
artid: "146079707"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146079707
    alt: "蓝桥备赛12-顺序表和-vector上"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146079707
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146079707
cover: https://bing.ee123.net/img/rand?artid=146079707
image: https://bing.ee123.net/img/rand?artid=146079707
img: https://bing.ee123.net/img/rand?artid=146079707
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥备赛（12）- 顺序表和 vector（上）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     一、顺序表的概念
    </h2>
    <h3>
     1.1 线性表的定义
    </h3>
    <blockquote>
     <p>
      线性表是 n 个具有
      <span style="color:#fe2c24">
       <strong>
        相同特性
       </strong>
      </span>
      的数据元素的
      <span style="color:#fe2c24">
       <strong>
        有序序列
       </strong>
      </span>
      。
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="360" src="https://i-blog.csdnimg.cn/direct/363c35d5e34343fcaf000e6669be4586.png" width="898"/>
    </p>
    <p>
     线性表在
     <strong>
      <span style="background-color:#ffd900">
       逻辑上可以想象成是连续的一条线段
      </span>
     </strong>
     ， 线段上有很多点 ， 比如下图：
    </p>
    <p class="img-center">
     <img alt="" height="187" src="https://i-blog.csdnimg.cn/direct/d4965bfb0f6540a49bee69cd09e351ed.png" width="1752"/>
    </p>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       相关术语
      </span>
     </strong>
     <span style="background-color:#ffd900">
      ：
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="446" src="https://i-blog.csdnimg.cn/direct/14ab57d85e304a3284ddbab9765d66d2.png" width="971"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       线性表是一个比较简单 和 基础的数据结构 。
      </strong>
     </span>
    </p>
    <p>
    </p>
    <h3>
     1.2 线性表的顺序存储 - 顺序表
    </h3>
    <p class="img-center">
     <img alt="" height="194" src="https://i-blog.csdnimg.cn/direct/1321138b00984d63b428d5cf01f4c578.png" width="955"/>
    </p>
    <blockquote>
     <p>
      1）顺序存储：逻辑上相邻的元素 ， 在内存中也存在相邻的位置。
     </p>
     <p>
      2）
      <strong>
       <span style="color:#fe2c24">
        顺序表就是通过数组来实现的 。
       </span>
      </strong>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="188" src="https://i-blog.csdnimg.cn/direct/a74e50a0cf7940a386a2f0e837f858d5.png" width="1363"/>
    </p>
    <h2>
     二、顺序表的模拟实现
    </h2>
    <h3>
     2.1 顺序表的表示方法
    </h3>
    <p class="img-center">
     <img alt="" height="344" src="https://i-blog.csdnimg.cn/direct/c8bf0155590b4b69bc5d8e1b8aac0990.png" width="1368"/>
    </p>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       按照数组的申请方式，有两种实现方式：
      </span>
     </strong>
    </p>
    <p>
     1）数组采用
     <span style="color:#fe2c24">
      <strong>
       静态分配
      </strong>
     </span>
     ，此时的顺序表称为静态顺序表
    </p>
    <p>
     2）数组采用
     <span style="color:#fe2c24">
      <strong>
       动态分配
      </strong>
     </span>
     ，此时的顺序表称为动态顺序表
    </p>
    <blockquote>
     <p>
      ---&gt;
      <span style="color:#fe2c24">
       <strong>
        静态分配就是直接向内存申请一大块连续的区域
       </strong>
      </span>
      ， 然后将需要存放的数组放在一大块连续的区域 。
     </p>
     <p>
      ---&gt;
      <strong>
       <span style="background-color:#ffd900">
        动态分配就是按需所取
       </span>
      </strong>
      ， 按照需要存放的数据的数量 ，
      <strong>
       合理的申请大小合适的空间来存放数据 。
      </strong>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="793" src="https://i-blog.csdnimg.cn/direct/d875e5d271d0417c8a726efccf80da86.png" width="1865"/>
    </p>
    <div>
     <span style="color:#1f2329">
      <strong>
       <span style="background-color:#ffd900">
        通过两者对比会发现，并没有⼀种实现方式就是绝对完美的。
       </span>
      </strong>
      想要书写方便以及运行更快，
     </span>
     <span style="color:#fe2c24">
      <strong>
       就要承担空间不够或者空间浪费的情况；
      </strong>
     </span>
     <span style="color:#1f2329">
      想要空间上合理分配
     </span>
     <span style="color:#fe2c24">
      <strong>
       ，就要承担时间以及代码书写上的消耗。
      </strong>
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      在后续的学习中，会经常看到各种情况的对比。这就要求我们掌握各种数据结构的特点，从而在解决实际问题的时候，选择⼀个合适的数据结构。
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      在算法竞赛中，我们主要关心的其实是时间开销，空间上是基本够用的。因此，定义⼀个超大的静态数组来解决问题是完全可以接受的。
     </span>
    </div>
    <h4>
    </h4>
    <h3>
     2.2 创建
    </h3>
    <p class="img-center">
     <img alt="" height="448" src="https://i-blog.csdnimg.cn/direct/c151f23eafa04f05ab673012c406d1d3.png" width="1174"/>
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 1e6 + 10;//根据实际情况而定

//创建顺序表
int arr[N];//用足够大的数组来模拟顺序表
int n;//标记顺序表里面有多少个元素
 
int main()
{
	
	return 0;
 } </code></pre>
    <h3 style="background-color:transparent">
    </h3>
    <h3 style="background-color:transparent">
     2.3 添加一个元素
    </h3>
    <p class="img-center">
     <img alt="" height="256" src="https://i-blog.csdnimg.cn/direct/768cc07e72e340f49f9d7fccf1511dee.png" width="574"/>
    </p>
    <h4>
     2.3.1 尾插
    </h4>
    <p class="img-center">
     <img alt="" height="763" src="https://i-blog.csdnimg.cn/direct/b4b1ddbbfb2f46e8b4ee629cc115e657.png" width="1126"/>
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 1e6 + 10;//根据实际情况而定

//创建顺序表
int arr[N];//用足够大的数组来模拟顺序表
int n;//标记顺序表里面有多少个元素
 
 //打印数组
 void print_Arr()
 {
	for(int i = 0;i&lt;n ; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";	
	} 	
	cout &lt;&lt; endl;
} 
 //尾插
 void push_back(int x)
 {
 	arr[n++] = x;
  } 
 
int main()
{
	push_back(1);
	push_back(2);
	push_back(3);
	push_back(4);
	//1 2 3 4
	print_Arr();
	return 0;
 } </code></pre>
    <p class="img-center">
     <img alt="" height="365" src="https://i-blog.csdnimg.cn/direct/f936d5bfdb604a4390e14f9dec7f4f51.png" width="806"/>
    </p>
    <blockquote>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        时间复杂度：O(1)
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     2.3.2 头插
    </h4>
    <blockquote>
     <p>
      方法：
     </p>
     <p>
      1）从最
      <span style="color:#fe2c24">
       <strong>
        右边的元素
       </strong>
      </span>
      开始 ， 依次往后移动一位
     </p>
     <p>
      2）然后把 新的数据  放入到a[0] 上
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        3） 不要忘记n++
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        <span style="background-color:#ffd900">
         4) 注意不要从前往后依次移动 ， 因为会导致后一个值  被  前一个值覆盖  ！！！
        </span>
       </span>
      </strong>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="245" src="https://i-blog.csdnimg.cn/direct/c34c4487dd8b4eff80811be616e29d8a.png" width="589"/>
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 1e6 + 10;//根据实际情况而定

//创建顺序表
int arr[N];//用足够大的数组来模拟顺序表
int n;//标记顺序表里面有多少个元素
 
 //打印数组
 void print_Arr()
 {
	for(int i = 0;i&lt;n ; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";	
	} 	
	cout &lt;&lt; endl;
} 
 //尾插
 void push_back(int x)
 {
 	arr[n++] = x;
  } 
  
//头插
void push_front(int x)
{
	for(int i = n;i&gt;=0;i--)
	{
		arr[i+1] = arr[i];
	}
	arr[0] = x;
	n++;
 } 
 
int main()
{
	push_back(1);
	push_back(2);
	push_back(3);
	push_back(4);
	//1 2 3 4
	
	push_front(3);
	push_front(2);
	push_front(1);
	//1 2 3 1 2 3 4
	print_Arr();
	return 0;
 } </code></pre>
    <p class="img-center">
     <img alt="" height="74" src="https://i-blog.csdnimg.cn/direct/5cc46500346b43aaa08c4f6a1830765f.png" width="408"/>
    </p>
    <blockquote>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        时间复杂度：由于需要将所有元素右移一位 ， 所以时间复杂度为 O(N）
       </span>
      </strong>
     </p>
    </blockquote>
    <h4>
    </h4>
    <h4>
     2.3.3 任意位置插入
    </h4>
    <blockquote>
     <p>
      1）指定插入位置
      <span style="color:#fe2c24">
       <strong>
        之后的所有数据
       </strong>
      </span>
      ，
      <span style="color:#fe2c24">
       <strong>
        从右往左
       </strong>
      </span>
      依次向后移动一位 。
     </p>
     <p>
      2）指定位置插入新的元素
     </p>
     <p>
      3）
      <strong>
       <span style="color:#fe2c24">
        不要忘记了 n++;(因为插入了一个新的元素）
       </span>
      </strong>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="562" src="https://i-blog.csdnimg.cn/direct/f6214ca8fdf14a05a18ce922d2901ee6.png" width="889"/>
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 1e6 + 10;//根据实际情况而定

//创建顺序表
int arr[N];//用足够大的数组来模拟顺序表
int n;//标记顺序表里面有多少个元素
 
 //打印数组
 void print_Arr()
 {
	for(int i = 0;i&lt;n ; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";	
	} 	
	cout &lt;&lt; endl;
} 
 //尾插
 void push_back(int x)
 {
 	arr[n++] = x;
  } 
  
//头插
void push_front(int x)
{
	for(int i = n;i&gt;=0;i--)
	{
		arr[i+1] = arr[i];
	}
	arr[0] = x;
	n++;
 } 
 
 //任意插入数据
 void Insert(int p,int x)
 {
 	for(int i = n;i&gt;=p;i--)
 	{
 		arr[ i + 1] = arr[i];	
	}
	arr[p] = x;
	n++; 
  } 
int main()
{
	push_back(1);
	push_back(2);
	push_back(3);
	push_back(4);
	//1 2 3 4
	
	push_front(3);
	push_front(2);
	push_front(1);
	//1 2 3 1 2 3 4
	
	Insert(1,99);
	print_Arr();
	return 0;
 } </code></pre>
    <blockquote>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        时间复杂度：O(N) ,   最坏的情况下 ， 数组中的所有元素需要往后移动 (任意插入的位置指定为数组第一个元素的位置)
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      其实上面的三个函数 ， 都存在一个BUG ， 因为需要判断数组是否存满 ， 如果数组存满了，就不能在继续存数据了；这里我们通过自己来判断数组是否存满，如果不合法，一般我们并不会调用。其次，任意位置插入的p位置也需要合法；
     </strong>
    </p>
    <h4>
    </h4>
    <h3>
     2.4 删除一个元素
    </h3>
    <p class="img-center">
     <img alt="" height="248" src="https://i-blog.csdnimg.cn/direct/6fce6db41a204242815c351a8066ea2d.png" width="623"/>
    </p>
    <h4>
     2.4.1 尾删
    </h4>
    <blockquote>
     <p>
      <span style="color:#fe2c24">
       <strong>
        直接 n--   , 不识别n 之后的数据 ， 就会达到我们想尾删的目的
       </strong>
      </span>
     </p>
    </blockquote>
    <pre><code class="hljs">  //尾删
  void Pop_back()
  {
  	n--;
   } </code></pre>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        1）时间复杂度：O(1)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2 ) 这里也有一个小BUG
       </strong>
      </span>
      ， 因为删除数据的时候需要判断数组是否存在元素，如果数组没元素 ，还删除，编译器会报错
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     2.4.2 头删
    </h4>
    <p class="img-center">
     <img alt="" height="837" src="https://i-blog.csdnimg.cn/direct/ab98512eace14d259007d0bf401ac690.png" width="1125"/>
    </p>
    <pre><code class="hljs">   //头删
void Pop_front()
{
	for(int i = 0;i&lt;n;i++)
	{
		arr[i] = arr[i+1];	
	}
	n--;
} </code></pre>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        1）时间复杂度：O(n)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2 ) 这里也有一个小BUG
       </strong>
      </span>
      ， 因为删除数据的时候需要判断数组是否存在元素，如果数组没元素 ，还删除，编译器会报错
     </p>
    </blockquote>
    <h4>
    </h4>
    <h4>
     2.4.3 任意位置删除
    </h4>
    <p class="img-center">
     <img alt="" height="283" src="https://i-blog.csdnimg.cn/direct/6718891feb9a44e88bbea467fc141af2.png" width="450"/>
    </p>
    <pre><code class="hljs">//任意位置删除
void erase(int p)
{
	for(int i = p;i&lt;=n;i++)
	{
		arr[i] = arr[i+1];
	}
	n--;
}</code></pre>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        1）时间复杂度：O(n)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2 ) 这里也有一个小BUG
       </strong>
      </span>
      ， 因为删除数据的时候需要判断数组是否存在元素，如果数组没元素 ，还删除，编译器会报错 ； 同时 p 位置不能非法 ；
     </p>
    </blockquote>
    <h4>
    </h4>
    <h3>
     2.5 查找元素
    </h3>
    <h4>
     2.5.1 按值查找
    </h4>
    <p class="img-center">
     <img alt="" height="564" src="https://i-blog.csdnimg.cn/direct/e35fc475ba044d5591984a16575ffeb5.png" width="550"/>
    </p>
    <pre><code class="hljs">//查找元素
int find(int x)
{
	for(int i = 0;i&lt;n ; i++)
	{
		if(arr[i] == x)
			return i;		
	}
	return 0;
 } </code></pre>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        1）时间复杂度：O(1)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2 ) 顺序表能直接通过下标 ， 快速访问到元素
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     2.5.2 按位查找
    </h4>
    <p>
     想找第几位，就返回第几位的元素：
    </p>
    <pre><code class="hljs">// 返回 p 位置的数
int at(int p)
{
    return a[p];
}</code></pre>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        1）时间复杂度：O(1)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2 ) 顺序表能直接通过下标 ， 快速访问到元素
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        <em>
         // p 的位置应该是合法的 [1,n]
        </em>
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
    </p>
    <h3>
     2.6 修改元素
    </h3>
    <pre><code class="hljs">// 把 p 位置的数修改成 x
void change(int p, int x)
{
    a[p] = x;
}

// 思考，这个函数有 bug 么？
// 位置 p 要是合法的才⾏</code></pre>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        1）时间复杂度：O(1)
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        2 ) 顺序表能直接通过下标 ， 快速访问到元素 ， 然后直接修改值就好了
       </strong>
      </span>
     </p>
    </blockquote>
    <p>
    </p>
    <h3>
     2.7 清空顺序表
    </h3>
    <pre><code class="hljs">// 清空顺序表
void clear()
{
    n = 0;
}</code></pre>
    <blockquote>
     <div>
      <span style="color:#0d0016">
       <strong>
        时间复杂度：
       </strong>
      </span>
     </div>
     <div>
      <span style="color:#fe2c24">
       <strong>
        1 . 要注意，我们自己实现的简单形式是
        <em>
         O
        </em>
        (1) 。
       </strong>
      </span>
     </div>
     <div>
      <span style="color:#fe2c24">
       <strong>
        2 . 但是，严谨的方式应该是
        <em>
         O
        </em>
        (
        <em>
         N
        </em>
        )  （如果数组元素存储的不是int 类型，而是我们new出来的空间，如果不一个一个的释放，会导致内存泄漏）。
       </strong>
      </span>
     </div>
    </blockquote>
    <p style="background-color:transparent">
     <strong>
      <span style="background-color:#ffd900">
       总代码：
      </span>
     </strong>
     <br/>
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 1e6 + 10;//根据实际情况而定

//创建顺序表
int arr[N];//用足够大的数组来模拟顺序表
int n;//标记顺序表里面有多少个元素
 
 //打印数组
 void print_Arr()
 {
	for(int i = 0;i&lt;n ; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";	
	} 	
	cout &lt;&lt; endl;
} 
 //尾插
 void push_back(int x)
 {
 	arr[n++] = x;
  } 
  
//头插
void push_front(int x)
{
	for(int i = n;i&gt;=0;i--)
	{
		arr[i+1] = arr[i];
	}
	arr[0] = x;
	n++;
 } 
 
 //任意插入数据
 void Insert(int p,int x)
 {
 	for(int i = n;i&gt;=p;i--)
 	{
 		arr[ i + 1] = arr[i];	
	}
	arr[p] = x;
	n++; 
  } 
  
  //尾删
  void Pop_back()
  {
  	n--;
   }
   
   //头删
void Pop_front()
{
	for(int i = 0;i&lt;n;i++)
	{
		arr[i] = arr[i+1];	
	}
	n--;
} 
//任意位置删除
void erase(int p)
{
	for(int i = p;i&lt;=n;i++)
	{
		arr[i] = arr[i+1];
	}
	n--;
}
//按值查找
int find(int x)
{
	for(int i = 0;i&lt;n ; i++)
	{
		if(arr[i] == x)
			return i;		
	}
	return 0;
 } 
 
 // 按位查找
int at(int p)
{
	return a[p];
}

// 按位修改
int change(int p, int x)
{
	a[p] = x;
} 

//清空操作
void clear()
{
	n = 0;
 } 
 
int main()
{
	push_back(1);
	push_back(2);
	push_back(3);
	push_back(4);
	//1 2 3 4
	
	push_front(3);
	push_front(2);
	push_front(1);
	//1 2 3 1 2 3 4
	
	Pop_back();
	Pop_back();
	//1 2 3 1 2
	
	erase(1);
	erase(2);
	print_Arr();
	return 0;
 } </code></pre>
    <h2 style="background-color:transparent">
    </h2>
    <h2 style="background-color:transparent">
     三、封装静态顺序表
    </h2>
    <blockquote>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        思考：
       </span>
       <span style="color:#1f2329">
        <span style="background-color:#ffd900">
         如果实际情况需要特别多的顺序表来解决问题，上述的写法有什么问题么？
        </span>
       </span>
      </strong>
     </p>
     <div>
      <span style="color:#0d0016">
       <strong>
        如果需要两个及以上的顺序表：
       </strong>
      </span>
     </div>
     <div>
      <p class="img-center">
       <img alt="" height="420" src="https://i-blog.csdnimg.cn/direct/8fb9a267545b43048cf496af390d89f6.png" width="1355"/>
      </p>
     </div>
    </blockquote>
    <p>
     利用C++结构体和类
     <strong>
      把我们实现的顺序表封装起来
     </strong>
     ， 就能简化操作。
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 1e5 + 10;//根据实际情况而定

//将顺序表的创建以及增删查改封装在一个类中
class SqList
{
	int a[N];
	int n;
	
public:
	//构造函数，初始化
	SqList()
	{
		n = 0;	
	}	
	
	//尾插 
	void push_back(int x)
	{
		a[n++] = x;
	}
	
	//打印
	void print_Arr()
	{
		for(int i = 1;i&lt;=n;i++)
		{
			cout &lt;&lt; a[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	 } 
};
 
int main()
{
	SqList s1,s2;
	for(int i = 1;i &lt;= 5 ; i++)
	{
		s1.push_back(i);
		s2.push_back(i + 2);  
	}
	s1.print_Arr() ;
	s2.print_Arr() ;
	return 0;
}</code></pre>
    <div>
     <span style="color:#1f2329">
      用类和结构体将代码进行封装
      <strong>
       <span style="background-color:#ffd900">
        ，能够很大程度上减少重复的操作，使代码的复用率大幅度提升。
       </span>
      </strong>
     </span>
    </div>
    <div>
     <p class="img-center">
      <img alt="" height="675" src="https://i-blog.csdnimg.cn/direct/1fe2babe337a45b189b26e7e47dc5ce3.png" width="1775"/>
     </p>
    </div>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6b686a6a6a67642f:61727469636c652f64657461696c732f313436303739373037" class_="artid" style="display:none">
 </p>
</div>


