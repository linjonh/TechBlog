---
layout: post
title: "c介绍锁二"
date: 2025-03-10 20:43:11 +0800
description: "由于上述加锁，代码的健壮性不是很好，如果遇到异常抛出情况，可能存在互斥量未释放问题。锁主要在两个以上的线程中使用，当多个线程访问共享资源时，我们需要使用锁，开保证共享资源的唯一性。unique_lock更加灵活，可以创建后不锁定，在使用过程中进行锁定。这样只要不在作用域范围内，锁就会释放，可以避免上述问题。当两个线程访问不带锁的共享资源时，如下代码。还有一种计时锁，设定在多少时间内进行锁定。这时我们需要加锁来限制。显然结果是不正确的。"
keywords: "c++介绍锁二"
categories: ['C']
tags: ['C']
artid: "146163276"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146163276
    alt: "c介绍锁二"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146163276
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146163276
cover: https://bing.ee123.net/img/rand?artid=146163276
image: https://bing.ee123.net/img/rand?artid=146163276
img: https://bing.ee123.net/img/rand?artid=146163276
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     c++介绍锁二
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     锁主要在两个以上的线程中使用，当多个线程访问共享资源时，我们需要使用锁，开保证共享资源的唯一性。
    </p>
    <p>
     当两个线程访问不带锁的共享资源时，如下代码
    </p>
    <pre><code class="hljs">#include&lt;array&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;
using namespace std;

void inc(int&amp; res)
{
	for (int i = 0; i &lt; 1000000; i++)
		res++;
}
int main1()
{
	int counter = 0;
	thread th1(inc,ref(counter));
	thread th2(inc, ref(counter));
	th1.join();
	th2.join();
	cout &lt;&lt; "counter =" &lt;&lt; counter &lt;&lt; "\n";
	return 0;
}
</code></pre>
    <p>
     得到结果
     <img alt="" height="168" src="https://i-blog.csdnimg.cn/direct/1e6034a1cf7f4978a1a5655ef403dd80.png" width="904"/>
    </p>
    <p>
     显然结果是不正确的。
    </p>
    <p>
     这时我们需要加锁来限制
    </p>
    <pre><code class="hljs">#include&lt;array&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;
#include&lt;mutex&gt;
using namespace std;


class Counter {
public:
	void inc()
	{
		counter_mutex.lock();
		m_count++;
		counter_mutex.unlock();
	}
	int getCounter()    //如果在多线程调用也需要加锁  这里没在多线程调用也加了锁
	{
		int temp;
		counter_mutex.lock();
		temp = m_count;
		counter_mutex.unlock();
		return temp;
	}
private:
	mutex counter_mutex;
	int m_count = 0;
};
int main2()
{
	Counter counter;
	auto increase = [](Counter&amp; counter)
	{
		for (int i = 0; i &lt; 1000000; i++)
			counter.inc();
	};
	thread th1(increase, ref(counter));
	thread th2(increase,ref(counter));
	th1.join();
	th2.join();
cout &lt;&lt; "counter=" &lt;&lt; counter.getCounter()&lt;&lt;"\n";
return 0;
}</code></pre>
    <p>
     由于上述加锁，代码的健壮性不是很好，如果遇到异常抛出情况，可能存在互斥量未释放问题。所以进一步改进
    </p>
    <p>
     如下代码
    </p>
    <pre><code class="hljs">#include&lt;array&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;
#include&lt;mutex&gt;
using namespace std;


class Counter {
public:
	void inc()
	{
		lock_guard&lt;mutex&gt; lock(counter_mutex);
		m_count++;
	}
	int getCounter()
	{
		int temp;
		lock_guard&lt;mutex&gt; lock(counter_mutex);
		temp = m_count;
		return temp;
	}
private:
	mutex counter_mutex;
	int m_count = 0;
};
int main2()
{
	Counter counter;
	auto increase = [](Counter&amp; counter)
	{
		for (int i = 0; i &lt; 1000000; i++)
			counter.inc();
	};
	thread th1(increase, ref(counter));
	thread th2(increase,ref(counter));
	th1.join();
	th2.join();
cout &lt;&lt; "counter=" &lt;&lt; counter.getCounter()&lt;&lt;"\n";
return 0;
}</code></pre>
    <p>
     这样只要不在作用域范围内，锁就会释放，可以避免上述问题。
    </p>
    <p>
     unique_lock更加灵活，可以创建后不锁定，在使用过程中进行锁定。
    </p>
    <pre><code class="hljs">#include&lt;array&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;
#include&lt;mutex&gt;
using namespace std;

class Counter
{
public:

	void increase(int n)
	{
		unique_lock&lt;mutex&gt;lock(counter_mutex,defer_lock);//延迟获取锁
		while (n--)
		{
			lock.lock();
			m_count++;
			lock.unlock();
		}
	}
	int getCount()
	{
		unique_lock&lt;mutex&gt; lock(counter_mutex);
		return m_count;
	}
private:
	mutex counter_mutex;
	int m_count = 0;
};
void main3()
{
	Counter counter;
	auto increase = [](Counter&amp; counter) {
		counter.increase(1000000);
	};
	thread th1(increase, ref(counter));
	thread th2(increase, ref(counter));

	th1.join();
	th2.join();
	cout &lt;&lt; "counter=" &lt;&lt; counter.getCount() &lt;&lt; "\n";

}</code></pre>
    <p>
     还有一种计时锁，设定在多少时间内进行锁定
    </p>
    <pre><code class="hljs">#include&lt;array&gt;
#include&lt;thread&gt;
#include&lt;iostream&gt;
#include&lt;mutex&gt;
using namespace std;
//time_mutex

using namespace std::chrono_literals;
class TryDemo
{
public:
	void print()
	{
		for (int i =0; i &lt; 10; i++)
		{
			unique_lock&lt;timed_mutex&gt;lock(m_mutex,defer_lock);

			if (lock.try_lock_for(100ms))//100ms是否获得该锁
			{
				{
					lock_guard&lt;mutex&gt; guard(count_mutex);
					cout &lt;&lt; "[" &lt;&lt; this_thread::get_id &lt;&lt; "]" &lt;&lt; "成功；\n";
				}
				this_thread::sleep_for(100ms);
			}
			else
			{
				lock_guard&lt;mutex&gt; lock_guard(count_mutex);
				cout &lt;&lt; "[" &lt;&lt; this_thread::get_id() &lt;&lt; "]" &lt;&lt; "失败;\n";
				this_thread::sleep_for(100ms);
			}
		}
	}
private:
	timed_mutex m_mutex;
	mutex count_mutex;
	int m_count = 0;
};
void main5()
{
	TryDemo demo;
	auto print = [](TryDemo&amp; demo)
	{
		demo.print();
	};
		thread th1(print,ref(demo));
		thread th2(print, ref(demo));
		th1.join();
		th2.join();
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f73756e74696e677368656e673132332f:61727469636c652f64657461696c732f313436313633323736" class_="artid" style="display:none">
 </p>
</div>


