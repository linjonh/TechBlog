---
layout: post
title: "java本地调用-JNA技术"
date: 2024-12-28 14:43:45 +0800
description: "#JAVA 本地调用 - JNA技术##JNI回顾JNI是Java Native Interface"
keywords: "java本地调用"
categories: ['J']
tags: ['无标签']
artid: "33728113"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=33728113
    alt: "java本地调用-JNA技术"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=33728113
featuredImagePreview: https://bing.ee123.net/img/rand?artid=33728113
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     java本地调用 - JNA技术
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="java-本地调用-jna技术">
     JAVA 本地调用 - JNA技术
    </h2>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-3">
     <h3 id="jni回顾">
      JNI回顾
     </h3>
     <p>
      JNI是Java Native Interface的缩写，中文为JAVA本地调用。从Java1.1开始，Java Native Interface(JNI)标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。
     </p>
     <p>
      我们知道，使用JNI调用.dll/.so共享类库是非常非常麻烦和痛苦的。
      <br/>
      如果有一个现有的.dll/.so文件，要使用JNI技术调用之，我们首先需要使用C语言（或其它语言）另外写一个适配器.dll/.so（使用SUN规定的数据结构替代C语言的数据结构）调用已有的.dll/.so中公布的函数，然后在Java中载入这个适配器.dll/.so并编写Java native函数调用这个适配器.dll/.so，进而达到调用原生函数的目的。
     </p>
     <p>
      经过以上2个繁琐的步骤（编写适配器.dll/.so文件、编写jni代码调用适配器文件）才能在Java中调用本地代码。因此，很少有Java程序员愿意编写调用.dll/.so库中的原生函数的java程序。
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-4">
     <h3 id="jna技术介绍">
      JNA技术介绍
     </h3>
     <p>
      JNA（Java Native Access）提供一组Java工具类用于在运行期动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native/JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。
     </p>
     <p>
      JNA可以让你像调用一般java方法一样直接调用本地方法。就和直接执行本地方法差不多，而且调用本地方法还不用额外的其他处理或者配置什么的，也不需要多余的引用或者编码，使用很方便。
     </p>
     <p>
      项目主页：
      <a href="https://github.com/twall/jna" rel="noopener noreferrer" target="_blank">
       https://github.com/twall/jna
      </a>
      <br/>
      主页上有很多的介绍和示例。
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-5">
     <h4 id="jna示例1">
      JNA示例1
     </h4>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-6">
     <pre class="prettyprint prettyprinted" style=""><code class="language-java"><span class="kwd">import</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">sun</span><span class="pun">.</span><span class="pln">jna</span><span class="pun">.</span><span class="typ">Library</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">sun</span><span class="pun">.</span><span class="pln">jna</span><span class="pun">.</span><span class="typ">Native</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">sun</span><span class="pun">.</span><span class="pln">jna</span><span class="pun">.</span><span class="typ">Platform</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">HelloWorld</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">CLibrary</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Library</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="typ">CLibrary</span><span class="pln"> INSTANCE </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">CLibrary</span><span class="pun">)</span><span class="pln">
                </span><span class="typ">Native</span><span class="pun">.</span><span class="pln">loadLibrary</span><span class="pun">((</span><span class="typ">Platform</span><span class="pun">.</span><span class="pln">isWindows</span><span class="pun">()</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="str">"msvcrt"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">"c"</span><span class="pun">),</span><span class="pln">
                        </span><span class="typ">CLibrary</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">void</span><span class="pln"> printf</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> format</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">...</span><span class="pln"> args</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="typ">CLibrary</span><span class="pun">.</span><span class="pln">INSTANCE</span><span class="pun">.</span><span class="pln">printf</span><span class="pun">(</span><span class="str">"Hello, World\n"</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
     <p>
      可以看到控制台中打印出了：Hello, World
      <br/>
      请注意，这个程序实际上是使用msvcrt.dll这个C运行时库中的printf函数打印出上面这些字符的。
      <br/>
      看，多简单，不需要写一行C代码，就可以直接在Java中调用外部动态链接库中的函数！
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-7">
     <h4 id="jna示例2">
      JNA示例2
     </h4>
     <p>
      上面那个例子使用了操作系统自带的动态链接库，现在我们再自己写一个动态链接库试试。
      <br/>
      1，在VS中选择C++语言，然后选择创建一个Win32程序。 选择dll类型。
      <br/>
      2，发布的C函数是：
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-8">
     <pre class="prettyprint prettyprinted" style=""><code class="language-c"><span class="com">#define</span><span class="pln"> MYLIBAPI  </span><span class="kwd">extern</span><span class="pln">   </span><span class="str">"C"</span><span class="pln">     __declspec</span><span class="pun">(</span><span class="pln"> dllexport </span><span class="pun">)</span><span class="pln"> 
MYLIBAPI </span><span class="kwd">void</span><span class="pln"> say</span><span class="pun">(</span><span class="typ">wchar_t</span><span class="pun">*</span><span class="pln"> pValue</span><span class="pun">);</span><span class="pln">
</span><span class="pun">这个函数的实现是：</span><span class="pln">
</span><span class="kwd">void</span><span class="pln">  say</span><span class="pun">(</span><span class="typ">wchar_t</span><span class="pun">*</span><span class="pln"> pValue</span><span class="pun">){<!-- --></span><span class="pln">
     std</span><span class="pun">::</span><span class="pln">wcout</span><span class="pun">.</span><span class="pln">imbue</span><span class="pun">(</span><span class="pln">std</span><span class="pun">::</span><span class="pln">locale</span><span class="pun">(</span><span class="str">"chs"</span><span class="pun">));</span><span class="pln">
     std</span><span class="pun">::</span><span class="pln">wcout</span><span class="pun">&lt;&lt;</span><span class="pln">L</span><span class="str">"上帝说："</span><span class="pun">&lt;&lt;</span><span class="pln">pValue</span><span class="pun">&lt;&lt;</span><span class="pln">std</span><span class="pun">::</span><span class="pln">endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>
     <p>
      它需要传入一个Unicode编码的字符数组。然后在控制台上打印出一段中文字符。
      <br/>
      3，生成dll。然后把生成的dll文件复制到Eclipse项目中，放在
      <strong>
       项目根目录
      </strong>
      下面。
      <br/>
      4，在Eclipse中编写以下代码：
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-9">
     <pre class="prettyprint prettyprinted" style=""><code class="language-java"><span class="kwd">import</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">sun</span><span class="pun">.</span><span class="pln">jna</span><span class="pun">.</span><span class="typ">Library</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">sun</span><span class="pun">.</span><span class="pln">jna</span><span class="pun">.</span><span class="typ">Native</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">sun</span><span class="pun">.</span><span class="pln">jna</span><span class="pun">.</span><span class="typ">WString</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">TestDll1Service</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
         </span><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">TestDll1</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Library</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
                   </span><span class="com">/**
                    * 当前路径是在项目根目录下，而不是bin输出目录下。
                    */</span><span class="pln">
                   </span><span class="typ">TestDll1</span><span class="pln"> INSTANCE </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">TestDll1</span><span class="pun">)</span><span class="typ">Native</span><span class="pun">.</span><span class="pln">loadLibrary</span><span class="pun">(</span><span class="str">"TestDll1"</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TestDll1</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">);</span><span class="pln">
                   </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> say</span><span class="pun">(</span><span class="typ">WString</span><span class="pln"> value</span><span class="pun">);</span><span class="pln">
         </span><span class="pun">}</span><span class="pln">
         </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">TestDll1Service</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
                   </span><span class="com">// TODO Auto-generated constructor stub</span><span class="pln">
         </span><span class="pun">}</span><span class="pln">
         </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
                   </span><span class="typ">TestDll1</span><span class="pun">.</span><span class="pln">INSTANCE</span><span class="pun">.</span><span class="pln">say</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">WString</span><span class="pun">(</span><span class="str">"Hello World!"</span><span class="pun">));</span><span class="pln">
                   </span><span class="typ">System</span><span class="pun">.</span><span class="pln">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"aaaaa"</span><span class="pun">);</span><span class="pln">
         </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
     <p>
      5，执行这个Java类。可以看到控制台下如下输出：
      <br/>
      上帝说：Hello World!
      <br/>
      aaaaa
      <br/>
      6，上面一行是C语言使用C++的std::wcout输出的。
      <br/>
      下面一行是Java语言输出的。
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-10">
     <h3 id="jna技术解密">
      JNA技术解密
     </h3>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-11">
     <h4 id="jna工作原理">
      JNA工作原理
     </h4>
     <p>
      JNA是建立在JNI技术基础之上的一个Java类库，它使您可以方便地使用java直接访问动态链接库中的函数。原来使用JNI，你必须手工用C写一个
      <strong>
       动态链接库
      </strong>
      ，在C语言中映射Java的数据类型。JNA中，它提供了一个动态的转发器，可以自动实现Java和C的数据类型映射。你不再需要编写C动态链接库。
      <br/>
      当然，这也意味着，使用JNA技术比使用JNI技术调用动态链接库会有些微的性能损失。可能速度会降低几倍。但影响不大。
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-12">
     <h4 id="数据结构的对应关系">
      数据结构的对应关系
     </h4>
     <p>
      Java—C和操作系统数据类型的对应表
      <br/>
      略，请看：
      <a href="http://blog.csdn.net/shendl/article/details/3589676" rel="noopener noreferrer" target="_blank">
       JNA相关博客
      </a>
      <br/>
      除了上面的类型，JNA还支持常见的数据类型的映射。
      <br/>
      略，情况：
      <a href="http://blog.csdn.net/shendl/article/details/3589676" rel="noopener noreferrer" target="_blank">
       JNA相关博客
      </a>
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-13">
     <h4 id="jna编程过程">
      JNA编程过程
     </h4>
     <p>
      .dll/.so是C函数的集合、容器，这正和java的接口的概念吻合。
      <br/>
      JNA把一个.dll/.so文件看做是一个Java接口。
      <br/>
      我们定义这样一个接口:
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-14">
     <pre class="prettyprint prettyprinted" style=""><code class="language-java"><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">TestDll1</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Library</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
   </span><span class="typ">TestDll1</span><span class="pln"> INSTANCE </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">TestDll1</span><span class="pun">)</span><span class="typ">Native</span><span class="pun">.</span><span class="pln">loadLibrary</span><span class="pun">(</span><span class="str">"TestDll1"</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TestDll1</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">);</span><span class="pln">
   </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> say</span><span class="pun">(</span><span class="typ">WString</span><span class="pln"> value</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
     <p>
      如果dll是以stdcall方式输出函数，那么就继承
      <strong>
       StdCallLibrary
      </strong>
      。否则就继承默认的Library接口。
      <br/>
      接口内部需要一个公共静态常量：instance。
      <br/>
      TestDll1 INSTANCE = (TestDll1)Native.loadLibrary(“TestDll1”, TestDll1.class);
      <br/>
      通过这个常量，就可以获得这个接口的实例，从而使用接口的方法。也就是调用外部dll的函数！
      <br/>
      注意：Native.loadLibrary()函数有2个参数：
     </p>
     <p>
      1，第一个参数是.dll或者.so文件的名字，但不带后缀名。这符合JNI的规范，因为带了后缀名就不可以跨操作系统平台了。
      <br/>
      JNI搜索dll的路径是：
      <br/>
      1）项目的根路径
      <br/>
      2）操作系统的全局路径、
      <br/>
      3）path指定的路径。
      <br/>
      这个路径可以通过java系统属性”java.library.path”查看，但要注意这个属性是只读的，即不可以运行时修改，即便属性值可以修改成功也不会生效！只有在启动脚本中添加 -D 参数予以修改方可生效（但这样会修改原有值，不推荐），不同的操作系统脚本指定不同的路径，比较好的方式是将.dll/.so放到项目根目录或bin目录，这些目录一般也会包含在”java.library.path”属性内。
      <br/>
      JNA在JNI的基础上又增加了
      <strong>
       “jna.library.path”
      </strong>
      熟悉，这也是官方比较推荐的方式。
     </p>
     <p>
      2，第二个参数是本接口的Class类型。
     </p>
     <p>
      JNA通过这个Class类型，根据指定的.dll/.so文件，使用java 动态代理技术创建接口的实例。
     </p>
     <p>
      接口中你只需要定义你需要的函数或者公共变量，不需要的可以不定义
      <br/>
      public void say(WString value);
      <br/>
      参数和返回值的类型，应该和dll中的C函数的类型一致。这是JNA，甚至所有跨平台调用的难点。
      <br/>
      这里，C语言的函数参数是：wchar_t*，JNA中对应的Java类型是WStirng。
     </p>
    </div>
    <div class="wmd-preview-section preview-content" id="wmd-preview-section-15">
     <h4 id="jna不足">
      JNA不足
     </h4>
     <p>
      1.性能比JNI差距较大，实际项目必需中要实际测试是否满足需求。
      <br/>
      2.使用JNI技术，不仅可以实现Java访问C函数，也可以实现C语言调用Java代码。
      <br/>
      而JNA只能实现Java访问C函数，作为一个Java框架，自然不能实现C语言调用Java代码。此时，你还是需要使用JNI技术。
     </p>
     <p>
      <strong>
       JNI是JNA的基础。是Java和C互操作的技术基础。
      </strong>
     </p>
     <p>
      参考：
      <br/>
      <a href="https://github.com/twall/jna" rel="noopener noreferrer" target="_blank">
       JNA项目主页
      </a>
      <br/>
      <a href="https://github.com/twall/jna/blob/master/www/GettingStarted.md" rel="noopener noreferrer" target="_blank">
       JNA GettingStarted
      </a>
      <br/>
      <a href="http://blog.csdn.net/shendl/article/details/3589676" rel="noopener noreferrer" target="_blank">
       JNA相关博客
      </a>
     </p>
    </div>
    <br/>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f636f6e7175657230373135:2f61727469636c652f64657461696c732f3333373238313133" class_="artid" style="display:none">
 </p>
</div>


