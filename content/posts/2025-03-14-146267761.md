---
layout: post
title: "OTSU算法大津算法"
date: 2025-03-14 21:37:04 +0800
description: "Otsu 算法通过最大化类间方差自动确定全局阈值，是图像二值化的经典方法。其核心优势在于无需人工干预，但需图像直方图呈现双峰特性。实际应用中需结合预处理或其他方法以应对复杂场景。Otsu 算法（大津算法）是一种经典的图像二值化方法，其核心是通过最大化类间方差自动确定全局阈值。假设图像由前景（目标）和背景两部分组成，且两者的灰度分布存在明显差异（直方图呈现双峰）。Otsu 算法通过寻找一个阈值，使得。，从而将图像分割为二值图。，即为 Otsu 阈值。"
keywords: "OTSU算法（大津算法）"
categories: ['未分类']
tags: ['算法', '人工智能', '二值化', 'Opencv']
artid: "146267761"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146267761
    alt: "OTSU算法大津算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146267761
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146267761
cover: https://bing.ee123.net/img/rand?artid=146267761
image: https://bing.ee123.net/img/rand?artid=146267761
img: https://bing.ee123.net/img/rand?artid=146267761
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     OTSU算法（大津算法）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Otsu 算法（大津算法）是一种经典的图像二值化方法，其核心是通过最大化类间方差自动确定全局阈值。以下是其具体工作原理和步骤：
    </p>
    <h4>
     <strong>
      1. 基本思想
     </strong>
    </h4>
    <p>
     假设图像由前景（目标）和背景两部分组成，且两者的灰度分布存在明显差异（直方图呈现双峰）。Otsu 算法通过寻找一个阈值，使得
     <strong>
      前景与背景之间的类间方差最大
     </strong>
     ，从而将图像分割为二值图。
    </p>
    <h4>
     <strong>
      2. 数学推导
     </strong>
    </h4>
    <h5>
     <strong>
      （1）计算灰度直方图
     </strong>
    </h5>
    <ul>
     <li>
      统计图像中每个灰度值的像素个数，得到直方图
      <code>
       h[i]
      </code>
      （
      <code>
       i
      </code>
      为灰度级，范围 0~L-1）。
     </li>
     <li>
      总像素数
      <code>
       N = sum(h[i])
      </code>
      。
     </li>
    </ul>
    <h5>
     <strong>
      （2）遍历所有可能的阈值
     </strong>
    </h5>
    <p>
     假设阈值为
     <code>
      t
     </code>
     ，将图像分为两类：
    </p>
    <ul>
     <li>
      <strong>
       背景类 C0
      </strong>
      ：灰度值 &lt;
      <code>
       t
      </code>
     </li>
     <li>
      <strong>
       前景类 C1
      </strong>
      ：灰度值 ≥
      <code>
       t
      </code>
     </li>
    </ul>
    <h5>
     <strong>
      （3）计算类概率和均值
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       背景类概率
      </strong>
      ：
      <code>
       w0 = sum(h[0..t]) / N
      </code>
     </li>
     <li>
      <strong>
       前景类概率
      </strong>
      ：
      <code>
       w1 = sum(h[t+1..L-1]) / N = 1 - w0
      </code>
     </li>
     <li>
      <strong>
       背景类均值
      </strong>
      ：
      <code>
       μ0 = sum(i*h[i] for i=0..t) / (w0*N)
      </code>
     </li>
     <li>
      <strong>
       前景类均值
      </strong>
      ：
      <code>
       μ1 = sum(i*h[i] for i=t+1..L-1) / (w1*N)
      </code>
     </li>
    </ul>
    <h5>
     <strong>
      （4）计算类间方差
     </strong>
    </h5>
    <p>
     总均值
     <code>
      μ = w0*μ0 + w1*μ1
     </code>
     <br/>
     类间方差
     <code>
      σ_b² = w0*(μ0 - μ)² + w1*(μ1 - μ)²
     </code>
    </p>
    <h5>
     <strong>
      （5）寻找最优阈值
     </strong>
    </h5>
    <p>
     遍历所有可能的阈值
     <code>
      t
     </code>
     ，找到使
     <code>
      σ_b²
     </code>
     最大的
     <code>
      t
     </code>
     ，即为 Otsu 阈值。
    </p>
    <h4>
     <strong>
      3. 算法步骤
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       计算灰度直方图
      </strong>
      。
     </li>
     <li>
      <strong>
       遍历所有可能的阈值
      </strong>
      （通常从 1 到 L-2，避免极端值）。
     </li>
     <li>
      <strong>
       计算每个阈值对应的类间方差
      </strong>
      。
     </li>
     <li>
      <strong>
       选择最大类间方差对应的阈值
      </strong>
      作为二值化阈值。
     </li>
    </ol>
    <h4>
     <strong>
      4. 关键特性
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       自动性
      </strong>
      ：无需手动设置阈值，适用于双峰直方图图像。
     </li>
     <li>
      <strong>
       鲁棒性
      </strong>
      ：对光照变化和噪声有一定容忍度。
     </li>
     <li>
      <strong>
       局限性
      </strong>
      ：
      <ul>
       <li>
        仅适用于双峰直方图图像，单峰或多峰场景效果差。
       </li>
       <li>
        全局阈值，无法处理光照不均匀的图像（需结合自适应阈值）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      5. 示例代码（OpenCV 实现）
     </strong>
    </h4>
    <pre><code class="language-python">import cv2
import numpy as np

# 读取灰度图
img = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)

# Otsu阈值法
_, otsu_mask = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# 显示结果
cv2.imshow('Original', img)
cv2.imshow('Otsu Binary', otsu_mask)
cv2.waitKey(0)
cv2.destroyAllWindows()
</code></pre>
    <h4>
     <strong>
      6. 应用场景
     </strong>
    </h4>
    <ul>
     <li>
      文档扫描（如身份证、票据）。
     </li>
     <li>
      简单物体分割（如硬币、印章）。
     </li>
     <li>
      图像预处理（如 OCR 前的二值化）。
     </li>
    </ul>
    <h4>
     <strong>
      7. 改进与扩展
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       自适应 Otsu
      </strong>
      ：分块计算局部 Otsu 阈值，处理非均匀光照。
     </li>
     <li>
      <strong>
       结合预处理
      </strong>
      ：先通过高斯模糊降噪，再应用 Otsu。
     </li>
     <li>
      <strong>
       多阈值 Otsu
      </strong>
      ：扩展到多类分割（需计算多峰直方图的类间方差）。
     </li>
    </ul>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     Otsu 算法通过最大化类间方差自动确定全局阈值，是图像二值化的经典方法。其核心优势在于无需人工干预，但需图像直方图呈现双峰特性。实际应用中需结合预处理或其他方法以应对复杂场景。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6d7173646667686a6b2f:61727469636c652f64657461696c732f313436323637373631" class_="artid" style="display:none">
 </p>
</div>


