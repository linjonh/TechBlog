---
layout: post
title: "Golang-每日一练-5"
date: 2025-03-13 03:01:08 +0800
description: "简述 golang 中的 GMP 模型。"
keywords: "Golang | 每日一练 (5)"
categories: ['每日一练', 'Golang']
tags: ['面试', '开发语言', 'Golang']
artid: "146220274"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146220274
    alt: "Golang-每日一练-5"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146220274
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146220274
cover: https://bing.ee123.net/img/rand?artid=146220274
image: https://bing.ee123.net/img/rand?artid=146220274
img: https://bing.ee123.net/img/rand?artid=146220274
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Golang | 每日一练 (5)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      💢欢迎来到张胤尘的技术站
      <br/>
      💥技术如江河，汇聚众志成。代码似星辰，照亮行征程。开源精神长，传承永不忘。携手共前行，未来更辉煌💥
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="Golang___5_5">
     </a>
     Golang | 每日一练 (5)
    </h2>
    <h3>
     <a id="_7">
     </a>
     题目
    </h3>
    <p>
     简述
     <code>
      golang
     </code>
     中的
     <code>
      GMP
     </code>
     模型。
    </p>
    <h3>
     <a id="_11">
     </a>
     参考答案
    </h3>
    <p>
     为了可以更加深入的了解
     <code>
      golang
     </code>
     中的
     <code>
      GMP
     </code>
     模型，下面我们先从操作系统的线程开始，一步一步的深入探索。
    </p>
    <h4>
     <a id="_15">
     </a>
     线程与协程
    </h4>
    <p>
     线程是操作系统能够进行调度的最小单位，是进程中的一个执行流。
     <strong>
      有了线程为什么会另外引入协程？
     </strong>
     下面主要从如下三个方面进行说明：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        重量级
       </strong>
       ：创建和销毁线程需要操作系统级别的资源分配和回收，开销较大。
      </p>
     </li>
     <li>
      <p>
       <strong>
        调度
       </strong>
       ：线程的调度是由操作系统内核完成，线程切换涉及上下文切换，性能开销较大。
      </p>
     </li>
     <li>
      <p>
       <strong>
        数量限制
       </strong>
       ：由于资源开销大（一个系统线程的内存占用在几MB），一个进程能够创建的线程数量有限（通常在几百到数千级别），一般都会受到操作系统的硬件资源限制。
      </p>
     </li>
    </ul>
    <h5>
     <a id="_24">
     </a>
     线程切换
    </h5>
    <p>
     从以上列出的这三点来看，其中我认为最主要的还是线程切换的开销，另外线程切换又离不开线程上下文的切换，那么下面解释一下什么是上下文切换？
    </p>
    <p>
     <strong>
      上下文切换是指操作系统在切换线程或进程时，保存当前线程或进程的执行状态（上下文），并加载下一个线程或进程的执行状态的过程。上下文切换的目的是让操作系统能够在多个线程或进程之间公平地分配
      <code>
       CPU
      </code>
      时间，从而实现多任务并发执行的效果
     </strong>
     。
    </p>
    <blockquote>
     <p>
      这里需要强调一点的是：上面这句话所描述的 “线程或进程” 中的进程，指的是可能会出现切换的两个线程是跨进程的情况。
     </p>
    </blockquote>
    <p>
     上下文切换流程主要包括以下几个步骤：
    </p>
    <ul>
     <li>
      <strong>
       中断触发
      </strong>
      ：上下文切换通常由时钟中断、I/O 中断或系统调用触发。当前线程的时间片用完或有其他原因需要调度器介入时，硬件会发出中断信号。
      <code>
       CPU
      </code>
      收到中断信号后，会从用户态切换到内核态，执行内核的中断处理程序。
     </li>
     <li>
      <strong>
       保存当前线程的上下文
      </strong>
      ：操作系统内核的调度器会保存当前正在运行的线程的上下文信息（包括程序计数器、寄存器、栈指针等）。这些信息通常会保存在当前线程的
      <code>
       TCB
      </code>
      中，供以后线程恢复执行时使用。
     </li>
     <li>
      <strong>
       选择新的线程
      </strong>
      ：内核的调度器根据调度算法从就绪队列中选择一个新的线程。选择新的线程时，调度器会考虑线程的优先级、剩余时间片等因素。
     </li>
     <li>
      <strong>
       加载新线程的上下文
      </strong>
      ：内核从新选中的线程的
      <code>
       TCB
      </code>
      中加载它的上下文信息，将新线程的寄存器、程序计数器、栈指针等恢复到
      <code>
       CPU
      </code>
      寄存器中。如果是从阻塞态恢复的线程，可能需要加载额外的资源（如文件描述符、内存页表等）。
     </li>
     <li>
      <strong>
       切换到新线程
      </strong>
      ：内核完成上下文恢复后，
      <code>
       CPU
      </code>
      将切换到新线程的程序计数器所指向的代码继续执行。如果新线程正在等待系统调用完成，它可能会切换回用户态执行用户代码。
     </li>
    </ul>
    <p>
     线程切换时，上下文切换的性能开销主要体现在以下几个方面：
    </p>
    <ul>
     <li>
      <strong>
       寄存器保存与恢复
      </strong>
      ：需要保存当前线程的寄存器状态，并恢复新线程的寄存器状态。
     </li>
     <li>
      <strong>
       内存管理单元状态切换
      </strong>
      ：如果线程切换涉及不同进程（进程切换），还需要切换页表等内存管理信息。
     </li>
     <li>
      <strong>
       调度器开销
      </strong>
      ：操作系统调度器需要选择下一个线程或进程，这本身也有一定的计算开销。
     </li>
    </ul>
    <h5>
     <a id="_46">
     </a>
     协程的引入
    </h5>
    <p>
     与线程切换不同，协程的切换是在用户态完成的轻量级执行单元切换。其核心是
     <strong>
      协作式调度
     </strong>
     ，具体过程如下所示：
    </p>
    <ul>
     <li>
      <strong>
       主动让出控制权
      </strong>
      ：当前协程在合适的位置（例如：I/O操作等）主动调用
      <code>
       yield
      </code>
      或类似机制，将控制权交还给调度器。
     </li>
     <li>
      <strong>
       选择下一个协程
      </strong>
      ：调度器根据协程的状态（如就绪、阻塞）选择下一个可运行的协程。
     </li>
     <li>
      <strong>
       恢复协程状态
      </strong>
      ：调度器切换到新协程的栈指针和寄存器状态，新协程从上次暂停的位置继续执行。
     </li>
    </ul>
    <p>
     另外，相比较于线程切换来说，协程切换的开销极小，主要体现在以下几个方面：
    </p>
    <ul>
     <li>
      <strong>
       用户态切换
      </strong>
      ：协程切换在用户态完成，无需进入内核态，避免了内核态切换的开销。
     </li>
     <li>
      <strong>
       轻量级上下文切换
      </strong>
      ：协程的上下文通常只包括栈指针和少量寄存器状态，切换开销远小于线程切换。
     </li>
     <li>
      <strong>
       无内核调度器开销
      </strong>
      ：协程调度由程序自身完成，无需依赖操作系统调度器。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/be75cbd34ea4404a8e68781224774bf6.png"/>
    </p>
    <h4>
     <a id="Goroutine_63">
     </a>
     <code>
      Goroutine
     </code>
    </h4>
    <p>
     <code>
      Goroutine
     </code>
     是
     <code>
      golang
     </code>
     中对于协程的一种实现，
     <code>
      Goroutine
     </code>
     相比较于传统的多线程模型的优势主要体现在以下几个方面：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        轻量级
       </strong>
       ：
       <code>
        Goroutine
       </code>
       的创建和销毁开销极低，每个
       <code>
        Goroutine
       </code>
       的初始栈大小仅为 2 KB，且栈大小会根据需要动态调整。
      </p>
     </li>
     <li>
      <p>
       <strong>
        高并发能力
       </strong>
       ：由于资源占用少，
       <code>
        golang
       </code>
       程序可以轻松创建数百万甚至上千万个
       <code>
        Goroutine
       </code>
       ，而不会对系统性能产生显著影响。
      </p>
     </li>
     <li>
      <p>
       <strong>
        高效的调度机制
       </strong>
       ：
       <code>
        Goroutine
       </code>
       的调度由
       <code>
        golang
       </code>
       运行时完成。运行时采用协作式和抢占式相结合的调度方式，能够高效地在多个
       <code>
        Goroutine
       </code>
       之间切换。
      </p>
     </li>
     <li>
      <p>
       <strong>
        语法简单
       </strong>
       ：通过
       <code>
        go
       </code>
       关键字即可启动一个
       <code>
        Goroutine
       </code>
       ，代码简洁易读。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自动内存管理
       </strong>
       ：
       <code>
        golang
       </code>
       语言内置了垃圾回收机制，能够自动管理
       <code>
        Goroutine
       </code>
       的内存分配和回收，减少了内存泄漏的风险。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多核支持
       </strong>
       ：
       <code>
        golang
       </code>
       运行时通过
       <code>
        GMP
       </code>
       模型，能够充分利用多核
       <code>
        CPU
       </code>
       的计算能力，将
       <code>
        Goroutine
       </code>
       分配到不同的
       <code>
        CPU
       </code>
       核心上并行执行。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自动负载均衡
       </strong>
       ：运行时会根据
       <code>
        Goroutine
       </code>
       的运行状态和
       <code>
        CPU
       </code>
       负载情况，动态调整
       <code>
        Goroutine
       </code>
       的分配，确保多核
       <code>
        CPU
       </code>
       的高效利用。
      </p>
     </li>
    </ul>
    <p>
     下面先给出一个简单示例，展示如何使用
     <code>
      Goroutine
     </code>
     进行并发编程，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"sync"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Worker %d received: %d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// 模拟工作负载</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> numWorkers <span class="token operator">=</span> <span class="token number">3</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

	<span class="token comment">// 创建通道</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>

	<span class="token comment">// 启动多个Goroutine</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numWorkers<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wg<span class="token punctuation">,</span> ch<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 向通道发送数据</span>
	<span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		ch <span class="token operator">&lt;-</span> j
	<span class="token punctuation">}</span>

	<span class="token comment">// 关闭通道</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>

	<span class="token comment">// 等待所有Goroutine完成</span>
	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="GMP__121">
     </a>
     <code>
      GMP
     </code>
     模型
    </h5>
    <p>
     <code>
      golang
     </code>
     的
     <code>
      Goroutine
     </code>
     的调度基于
     <code>
      GMP
     </code>
     模型，即
     <code>
      Goroutine
     </code>
     （
     <code>
      G
     </code>
     ）、
     <code>
      Machine
     </code>
     （
     <code>
      M
     </code>
     ）和
     <code>
      Processor
     </code>
     （
     <code>
      P
     </code>
     ）的组合。
    </p>
    <p>
     下面先给出
     <code>
      GMP
     </code>
     模型全景图，如下图所示：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7efc7ef108844244b024b30f0592935a.png"/>
    </p>
    <blockquote>
     <p>
      以上图片只是示例，并非实际运行图，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="G_132">
     </a>
     <code>
      G
     </code>
    </h6>
    <p>
     <code>
      Goroutine
     </code>
     （以下全部简称
     <code>
      G
     </code>
     ），
     <code>
      golang
     </code>
     语言中的轻量级协程，代表一个独立的执行单元。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//  栈相关字段</span>
	stack       stack 	<span class="token comment">// stack.lo 栈底；stack.hi 栈顶</span>
	stackguard0 <span class="token builtin">uintptr</span>
	stackguard1 <span class="token builtin">uintptr</span>
	
    <span class="token comment">// 内层的 panic 信息，如果 G 正在执行 panic 处理，则此字段有效</span>
	_panic    <span class="token operator">*</span>_panic
    <span class="token comment">// 内层的 defer 信息，当发生 panic 或函数返回时，会依次执行 defer</span>
	_defer    <span class="token operator">*</span>_defer
	m         <span class="token operator">*</span>m	<span class="token comment">// 当前绑定的 M</span>
	sched     gobuf	<span class="token comment">// 保存 G 的调度信息，包括栈指针、程序计数器等</span>
    <span class="token comment">// 用于记录系统调用时的状态，以便在 G 恢复时正确恢复上下文</span>
	syscallsp <span class="token builtin">uintptr</span>
	syscallpc <span class="token builtin">uintptr</span>
	syscallbp <span class="token builtin">uintptr</span>
	stktopsp  <span class="token builtin">uintptr</span>
	param        unsafe<span class="token punctuation">.</span>Pointer	<span class="token comment">// 通用指针字段，用于传递参数</span>
	atomicstatus atomic<span class="token punctuation">.</span>Uint32	<span class="token comment">// G 的状态</span>
	stackLock    <span class="token builtin">uint32</span>
	goid         <span class="token builtin">uint64</span>	<span class="token comment">// G 的ID</span>
	schedlink    guintptr	<span class="token comment">// 调度链表链接</span>
	waitsince    <span class="token builtin">int64</span>	<span class="token comment">// 阻塞的时间戳 </span>
	waitreason   waitReason	<span class="token comment">// 阻塞原因</span>
	preempt       <span class="token builtin">bool</span>	<span class="token comment">// 关于抢占的信息</span>
	preemptStop   <span class="token builtin">bool</span> 
	preemptShrink <span class="token builtin">bool</span> 
	<span class="token comment">// ...</span>
	parkingOnChan atomic<span class="token punctuation">.</span>Bool	<span class="token comment">// 是否正在等待通道操作</span>
	<span class="token comment">// ...</span>
	parentGoid    <span class="token builtin">uint64</span>	<span class="token comment">// 创建当前 G 的父 GID</span>
	gopc          <span class="token builtin">uintptr</span>   <span class="token comment">// 创建当前 G 的调用点    </span>
	ancestors     <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span>ancestorInfo 
	startpc       <span class="token builtin">uintptr</span>   <span class="token comment">// G 的起始函数     </span>
	racectx       <span class="token builtin">uintptr</span>
	waiting       <span class="token operator">*</span>sudog    <span class="token comment">// G 正在等待的通道操作 </span>
	<span class="token comment">// ...</span>
	selectDone    atomic<span class="token punctuation">.</span>Uint32  <span class="token comment">// 是否参与了 select 操作</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上源代码只是核心字段截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="G__183">
     </a>
     <code>
      G
     </code>
     的状态
    </h6>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// defined constants</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
	<span class="token comment">// G status</span>
	_Gidle <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// 0	空闲状态，尚未被调度</span>
	_Grunnable <span class="token comment">// 1	可运行状态，等待被调度到某个M上执行</span>
	_Grunning <span class="token comment">// 2	正在运行中</span>
	_Gsyscall <span class="token comment">// 3	系统调用中，当前被阻塞在某个系统调用操作上</span>
	_Gwaiting <span class="token comment">// 4	等待状态，例如等待通道操作完成</span>
	_Gmoribund_unused <span class="token comment">// 5	未使用的状态，保留</span>
	_Gdead <span class="token comment">// 6	结束运行，处于死亡状态</span>
	_Genqueue_unused <span class="token comment">// 7	未使用的状态，保留</span>
	_Gcopystack <span class="token comment">// 8	执行栈复制操作（例如栈增长时）</span>
	_Gpreempted <span class="token comment">// 9	被抢占，需要暂停执行</span>
	
    <span class="token comment">// 扫描状态是垃圾回收期间使用的状态</span>
    <span class="token comment">// 这些状态在基础状态的基础上加上了 _Gscan 标志，用于标记 G 在垃圾回收阶段的行为</span>
    _Gscan          <span class="token operator">=</span> <span class="token number">0x1000</span>	<span class="token comment">// 基础扫描状态标志，用于垃圾回收阶段</span>
	_Gscanrunnable  <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Grunnable  <span class="token comment">// 0x1001	可运行状态，且正在被扫描</span>
	_Gscanrunning   <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Grunning   <span class="token comment">// 0x1002	运行中，且正在被扫描</span>
	_Gscansyscall   <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Gsyscall   <span class="token comment">// 0x1003	系统调用中，且正在被扫描</span>
	_Gscanwaiting   <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Gwaiting   <span class="token comment">// 0x1004	等待状态，且正在被扫描</span>
	_Gscanpreempted <span class="token operator">=</span> _Gscan <span class="token operator">+</span> _Gpreempted <span class="token comment">// 0x1009	被抢占，且正在被扫描</span>
<span class="token punctuation">)</span>
</code></pre>
    <p>
     <code>
      G
     </code>
     状态变化流程图，如下所示：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6971b4d8be964290a76bd95431964792.png"/>
    </p>
    <h6>
     <a id="M_218">
     </a>
     <code>
      M
     </code>
    </h6>
    <p>
     代表操作系统线程，是实际执行
     <code>
      G
     </code>
     的实体。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> m <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	g0      <span class="token operator">*</span>g	<span class="token comment">// 每个 M 的初始 G0，用于执行系统调用和调度器逻辑</span>
	morebuf gobuf  <span class="token comment">// 用于保存 G 的调度信息</span>
	divmod  <span class="token builtin">uint32</span> 
	<span class="token boolean">_</span>       <span class="token builtin">uint32</span> 
	procid          <span class="token builtin">uint64</span>      <span class="token comment">// 操作系统线程ID      </span>
	gsignal         <span class="token operator">*</span>g          <span class="token comment">// 用于信号处理的 G</span>
	goSigStack      gsignalStack      <span class="token comment">// golang 的信号处理栈</span>
	sigmask         sigset            <span class="token comment">// 当前线程的信号掩码</span>
	tls             <span class="token punctuation">[</span>tlsSlots<span class="token punctuation">]</span><span class="token builtin">uintptr</span> <span class="token comment">// 线程局部存储（TLS）的指针</span>
	mstartfn        <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	curg            <span class="token operator">*</span>g	<span class="token comment">// 当前正在执行的 G</span>
	caughtsig       guintptr 	<span class="token comment">// 捕获的信号</span>
	p               puintptr	<span class="token comment">// 当前绑定的 P</span>
	nextp           puintptr	<span class="token comment">// 下一次要执行的 P</span>
	oldp            puintptr 
	id              <span class="token builtin">int64</span>	<span class="token comment">// M 的唯一标识符</span>
	mallocing       <span class="token builtin">int32</span>	<span class="token comment">// 是否正在执行内存分配</span>
	throwing        throwType	<span class="token comment">// 是否正在抛出异常</span>
	preemptoff      <span class="token builtin">string</span> 
	locks           <span class="token builtin">int32</span>	<span class="token comment">// 当前 M 持有的锁数量</span>
	dying           <span class="token builtin">int32</span>	<span class="token comment">// M 是否正在退出</span>
	profilehz       <span class="token builtin">int32</span>
	spinning        <span class="token builtin">bool</span> 	<span class="token comment">// M 是否处于自旋状态</span>
	blocked         <span class="token builtin">bool</span> 	<span class="token comment">// M 是否被阻塞</span>
	newSigstack     <span class="token builtin">bool</span> 
	printlock       <span class="token builtin">int8</span>	<span class="token comment">// 打印锁，防止并发打印</span>
	<span class="token comment">// ...     </span>
	freeWait        atomic<span class="token punctuation">.</span>Uint32	<span class="token comment">// 是否在等待释放</span>
	needextram      <span class="token builtin">bool</span>	<span class="token comment">// 是否需要额外的 M</span>
	g0StackAccurate <span class="token builtin">bool</span> 
	traceback       <span class="token builtin">uint8</span>	<span class="token comment">// 回溯信息</span>
	ncgocall        <span class="token builtin">uint64</span>	<span class="token comment">// Cgo 调用次数   </span>
	ncgo            <span class="token builtin">int32</span>	<span class="token comment">// Cgo 活跃调用数量   </span>
	cgoCallersUse   atomic<span class="token punctuation">.</span>Uint32 
	cgoCallers      <span class="token operator">*</span>cgoCallers   
	park            note	<span class="token comment">// 用于阻塞和唤醒 M 的同步原语</span>
	alllink         <span class="token operator">*</span>m	<span class="token comment">// M 的全局链表</span>
	schedlink       muintptr	<span class="token comment">// 调度链表</span>
	lockedg         guintptr	<span class="token comment">// 当前锁定的 G</span>
	<span class="token comment">// ...     </span>
	syscalltick <span class="token builtin">uint32</span>	<span class="token comment">// 系统调用的计数器</span>
	freelink    <span class="token operator">*</span>m	<span class="token comment">// 释放链表</span>
	<span class="token comment">// ...     </span>
	signalPending atomic<span class="token punctuation">.</span>Uint32	<span class="token comment">// 是否有挂起的信号</span>
	<span class="token comment">// ...     </span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上源代码只是核心字段截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="P_276">
     </a>
     <code>
      P
     </code>
    </h6>
    <p>
     <code>
      golang
     </code>
     运行时中的调度上下文，负责管理
     <code>
      G
     </code>
     的调度，
     <code>
      P
     </code>
     的数量由
     <code>
      GOMAXPROCS
     </code>
     设置，默认等于
     <code>
      CPU
     </code>
     核心数。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	id          <span class="token builtin">int32</span>	<span class="token comment">// P 的唯一标识符</span>
	status      <span class="token builtin">uint32</span>	<span class="token comment">// P 的状态</span>
	link        puintptr	<span class="token comment">// P 的链表链接</span>
	schedtick   <span class="token builtin">uint32</span>     <span class="token comment">// 调度器的 tick 计数器</span>
	syscalltick <span class="token builtin">uint32</span>     <span class="token comment">// 系统调用的 tick 计数器</span>
	sysmontick  sysmontick <span class="token comment">// 系统监控的 tick 计数器</span>
	m           muintptr	<span class="token comment">// 当前绑定的 M</span>
	mcache      <span class="token operator">*</span>mcache	<span class="token comment">// 当前 P 的内存分配缓存</span>
	pcache      pageCache	<span class="token comment">// 页面缓存</span>
	raceprocctx <span class="token builtin">uintptr</span>	<span class="token comment">// 用于竞态检测的上下文</span>
	deferpool    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>_defer 	<span class="token comment">// defer 池</span>
	deferpoolbuf <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">*</span>_defer	<span class="token comment">// defer 池缓冲区</span>
	goidcache    <span class="token builtin">uint64</span>	<span class="token comment">// GID 缓存</span>
	goidcacheend <span class="token builtin">uint64</span>	<span class="token comment">// GID 缓存结束位置</span>
	runqhead <span class="token builtin">uint32</span>	<span class="token comment">// 运行队列头指针</span>
	runqtail <span class="token builtin">uint32</span> <span class="token comment">// 运行队列尾指针</span>
	runq     <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span>guintptr	<span class="token comment">// P 的本地运行队列</span>
	runnext guintptr	<span class="token comment">// 下一个要运行的 G</span>
	gFree <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
		gList
		n <span class="token builtin">int32</span>
	<span class="token punctuation">}</span>
	sudogcache <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>sudog	<span class="token comment">// sudog 缓存</span>
	sudogbuf   <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">*</span>sudog	<span class="token comment">// sudog 缓冲区</span>
	mspancache <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">// mspan 缓存</span>
		<span class="token builtin">len</span> <span class="token builtin">int</span>
		buf <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">*</span>mspan
	<span class="token punctuation">}</span>
	pinnerCache <span class="token operator">*</span>pinner	<span class="token comment">// 内存页缓存</span>
	trace pTraceState
	palloc persistentAlloc 
    <span class="token comment">// 垃圾回收相关字段</span>
	gcAssistTime         <span class="token builtin">int64</span> 
	gcFractionalMarkTime <span class="token builtin">int64</span> 
	limiterEvent limiterEvent
	gcMarkWorkerMode gcMarkWorkerMode
	gcMarkWorkerStartTime <span class="token builtin">int64</span>
	gcw gcWork
    
	<span class="token comment">// ...     </span>
	preempt <span class="token builtin">bool</span>	<span class="token comment">// 是否允许抢占</span>
	gcStopTime <span class="token builtin">int64</span>	<span class="token comment">// GC 停止时间</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上源代码只是核心字段截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="P__331">
     </a>
     <code>
      P
     </code>
     的状态
    </h6>
    <blockquote>
     <p>
      源码位置：src/runtime/runtime2.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
	<span class="token comment">// P status</span>
	_Pidle <span class="token operator">=</span> <span class="token boolean">iota</span>	<span class="token comment">// P 处于空闲状态，没有 G 正在执行，也没有 G 等待执行</span>
	_Prunning	<span class="token comment">// P 正在运行中，即至少有一个 G 正在该 P 上执行</span>
	_Psyscall	<span class="token comment">// P 处于系统调用状态，即当前 P 上的 G 正在执行系统调用并被阻塞</span>
	_Pgcstop	<span class="token comment">// P 处于垃圾回收停止状态，即 P 上的 G 被暂停执行以进行垃圾回收</span>
	_Pdead	<span class="token comment">// P 已经死亡，不再参与调度，也不会再执行任何 G</span>
<span class="token punctuation">)</span>
</code></pre>
    <p>
     <code>
      P
     </code>
     状态变化流程图，如下所示：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d61d7c2e2ee84c9d871eeaaa70ac542a.png"/>
    </p>
    <h5>
     <a id="_351">
     </a>
     程序启动流程
    </h5>
    <h6>
     <a id="_353">
     </a>
     程序入口
    </h6>
    <p>
     首先给出一段测试代码，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test start main~"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将以上代码生成可执行文件后，查看该文件的文件头信息：
    </p>
    <pre><code class="prism language-bash">$ objdump <span class="token parameter variable">-f</span> <span class="token builtin class-name">test</span>

test：     文件格式 elf64-x86-64
体系结构：i386:x86-64， 标志 0x00000112：
EXEC_P, HAS_SYMS, D_PAGED
起始地址 0x000000000046ce80
</code></pre>
    <p>
     文件头中记录该程序的起始地址是：
     <code>
      0x000000000046ce80
     </code>
     ，根据该地址找到对应标号表中的内容：
    </p>
    <pre><code class="prism language-bash">$ objdump <span class="token parameter variable">-t</span> <span class="token builtin class-name">test</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'46ce80'</span>
000000000046ce80 g     F .text  0000000000000005 _rt0_amd64_linux
</code></pre>
    <p>
     然后找到该汇编代码文件，核心的函数调用内容如下所示：
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/asm_amd64.s
     </p>
    </blockquote>
    <pre><code class="prism language-assembly">TEXT runtime·rt0_go(SB),NOSPLIT|NOFRAME|TOPFRAME,$0
# ...
    CALL	runtime·check(SB)

# ...
    CALL	runtime·args(SB)
    CALL	runtime·osinit(SB)
    CALL	runtime·schedinit(SB)

    // create a new goroutine to start program
    MOVQ	$runtime·mainPC(SB), AX		# 获取 runtime.main 的地址
    PUSHQ	AX
    CALL	runtime·newproc(SB)
    POPQ	AX

    // start this M
    CALL	runtime·mstart(SB)

    CALL	runtime·abort(SB)	// mstart should never return
# ...
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <ul>
     <li>
      <code>
       runtime·check(SB)
      </code>
      ：用于运行时的初始化检查，确保运行时环境是安全的。
     </li>
     <li>
      <code>
       runtime·args(SB)
      </code>
      ：用于处理命令行参数，并将它们存储到运行时变量中。
     </li>
     <li>
      <code>
       runtime·osinit(SB)
      </code>
      ：进行操作系统相关的初始化。
     </li>
     <li>
      <code>
       runtime·schedinit(SB)
      </code>
      ：初始化
      <code>
       golang
      </code>
      的调度器。
     </li>
     <li>
      <code>
       runtime·newproc(SB)
      </code>
      ：创建一个新的
      <code>
       G
      </code>
      来运行主程序逻辑。
     </li>
     <li>
      <code>
       runtime·mstart(SB)
      </code>
      ：启动当前的
      <code>
       M
      </code>
      ，开始执行
      <code>
       G
      </code>
      调度。
     </li>
     <li>
      <code>
       runtime·abort(SB)
      </code>
      ：如果
      <code>
       runtime.mstart
      </code>
      返回，说明程序出现了异常，则调用
      <code>
       runtime.abort
      </code>
      函数终止程序。
     </li>
    </ul>
    <h6>
     <a id="_422">
     </a>
     初始化
    </h6>
    <p>
     当
     <code>
      golang
     </code>
     程序启动时，首先获取当前系统的 CPU 核心数、获取系统支持的大页内存大小、完成其他底层的初始化动作。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/os_linux.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">osinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前系统的 CPU 核心数</span>
	ncpu <span class="token operator">=</span> <span class="token function">getproccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 获取系统支持的大页内存大小</span>
	physHugePageSize <span class="token operator">=</span> <span class="token function">getHugePageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 完成操作系统的底层初始化</span>
	<span class="token function">osArchInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     操作系统底层初始化完成后，执行
     <code>
      runtime·schedinit
     </code>
     函数初始化
     <code>
      golang
     </code>
     的调度器，其中对于调度流程来说比较重要的是：
    </p>
    <ul>
     <li>
      <code>
       mcommoninit
      </code>
      函数会初始化
      <code>
       M0
      </code>
      的一些属性，并将
      <code>
       M0
      </code>
      放入全局链表
      <code>
       allm
      </code>
      中；
     </li>
     <li>
      根据
      <code>
       GOMAXPROCS
      </code>
      创建和初始化
      <code>
       P
      </code>
      列表。
      <code>
       GOMAXPROCS
      </code>
      决定了
      <code>
       P
      </code>
      的数量，通常等于系统的
      <code>
       CPU
      </code>
      核心数。
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">schedinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 初始化一系列锁</span>
	<span class="token comment">// ...</span>

    <span class="token comment">// 获取当前的 G</span>
    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// ...</span>
	
    <span class="token comment">// 设置 M 数量的上限</span>
	sched<span class="token punctuation">.</span>maxmcount <span class="token operator">=</span> <span class="token number">10000</span>

	<span class="token comment">// ...</span>
	<span class="token function">mcommoninit</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>	<span class="token comment">// M 初始化函数</span>
	<span class="token comment">// ...</span>
	
    <span class="token comment">// 设置调度器的处理器数量</span>
    <span class="token comment">// 加锁</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	procs <span class="token operator">:=</span> ncpu
	<span class="token keyword">if</span> n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">atoi32</span><span class="token punctuation">(</span><span class="token function">gogetenv</span><span class="token punctuation">(</span><span class="token string">"GOMAXPROCS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		procs <span class="token operator">=</span> n
	<span class="token punctuation">}</span>
    <span class="token comment">// 调用 procresize 设置调度器的处理器数量</span>
	<span class="token keyword">if</span> <span class="token function">procresize</span><span class="token punctuation">(</span>procs<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"unknown runnable goroutine during bootstrap"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    
     <span class="token comment">// 解锁</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     另外，在
     <code>
      schedinit
     </code>
     函数中的
     <code>
      procresize
     </code>
     函数主要用于动态调整运行时的
     <code>
      P
     </code>
     数量。它会根据需要创建新的
     <code>
      P
     </code>
     或销毁多余的
     <code>
      P
     </code>
     ，并确保调度器的运行状态与新的
     <code>
      P
     </code>
     数量一致。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// nprocs 是处理器数量</span>
<span class="token keyword">func</span> <span class="token function">procresize</span><span class="token punctuation">(</span>nprocs <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token operator">*</span>p <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>

	<span class="token comment">// 初始化新的 P</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> old<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nprocs<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		pp <span class="token operator">:=</span> allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> pp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			pp <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 初始化每个新的 P</span>
		pp<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token function">atomicstorep</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 构建空闲 P 链表，将可运行的 P 加入队列</span>
    <span class="token comment">// 遍历所有处理器，将有本地工作（run queue 不为空）的 P 加入可运行队列</span>
	<span class="token keyword">var</span> runnablePs <span class="token operator">*</span>p
	<span class="token keyword">for</span> i <span class="token operator">:=</span> nprocs <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{<!-- --></span>
		pp <span class="token operator">:=</span> allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pp <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
		pp<span class="token punctuation">.</span>status <span class="token operator">=</span> _Pidle
		<span class="token keyword">if</span> <span class="token function">runqempty</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 加入空闲链表</span>
			<span class="token function">pidleput</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 将有任务的 P 链接起来</span>
			pp<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">mget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			pp<span class="token punctuation">.</span>link<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>runnablePs<span class="token punctuation">)</span>
			runnablePs <span class="token operator">=</span> pp
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	stealOrder<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>nprocs<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> int32p <span class="token operator">*</span><span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>gomaxprocs
    <span class="token comment">// 使用原子操作更新全局变量 gomaxprocs，确保线程安全</span>
	atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uint32</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>int32p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uint32</span><span class="token punctuation">(</span>nprocs<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> old <span class="token operator">!=</span> nprocs <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果实际改变了处理器数量，通知垃圾回收器的 CPU 限制器，更新其容量</span>
		gcCPULimiter<span class="token punctuation">.</span><span class="token function">resetCapacity</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> nprocs<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> runnablePs
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="_G_540">
     </a>
     创建
     <code>
      G
     </code>
    </h6>
    <p>
     <code>
      newproc
     </code>
     函数专门用于创建一个新的
     <code>
      G
     </code>
     并将其放入运行队列中。此时会将
     <code>
      runtime.main
     </code>
     函数的
     <code>
      G
     </code>
     加入到
     <code>
      P
     </code>
     的本地运行队列中。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// fn 是一个指向函数值的指针，表示 G 将要运行的函数</span>
<span class="token keyword">func</span> <span class="token function">newproc</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment">// 获取当前 G 的指针</span>
	pc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment">// 调用者的程序计数器</span>
	<span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">// 切换到系统栈（G0 的栈）上执行闭包中的代码</span>
        <span class="token comment">// 调用 newproc1 函数，创建一个新的 G</span>
        <span class="token comment">// 但是需要注意，这个并不是一个系统调用</span>
		newg <span class="token operator">:=</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> pc<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> waitReasonZero<span class="token punctuation">)</span>
		
        <span class="token comment">// 获取当前 M 绑定的 P 的指针</span>
		pp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment">// 将新创建的 G 放入 P 的本地运行队列，并需要立即调度</span>
		<span class="token function">runqput</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> newg<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	
       	<span class="token comment">// 如果主函数已经启动（mainStarted 为 true），唤醒一个空闲的 P</span>
		<span class="token keyword">if</span> mainStarted <span class="token punctuation">{<!-- --></span>
			<span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     其中，
     <code>
      newproc1
     </code>
     是
     <code>
      golang
     </code>
     运行时中用于创建新
     <code>
      G
     </code>
     的核心函数。它负责初始化
     <code>
      G
     </code>
     的状态，并将其放入调度队列中。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">,</span> parked <span class="token builtin">bool</span><span class="token punctuation">,</span> waitreason waitReason<span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 检查传入的函数指针是否为 nil。如果是 nil，则触发运行时错误</span>
    <span class="token keyword">if</span> fn <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">"go of nil func value"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 调用 acquirem 获取当前的 M</span>
	mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 获取当前 M 绑定的 P 的指针</span>
	pp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	newg <span class="token operator">:=</span> <span class="token function">gfget</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>	<span class="token comment">// 尝试从 P 的空闲 G 队列中获取一个 G</span>
    <span class="token comment">// 如果队列为空，则调用 malg 分配一个新的 G</span>
	<span class="token keyword">if</span> newg <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果没有可用的 G，调度器会分配一个新的 G，并为其分配初始栈空间</span>
		newg <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">)</span>	
		<span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gidle<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span>
		<span class="token function">allgadd</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span> 
	<span class="token punctuation">}</span>
    <span class="token comment">// 检查新 G 是否分配了栈空间。如果没有分配，则抛出错误</span>
	<span class="token keyword">if</span> newg<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"newproc1: newg missing stack"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 检查新 G 的状态是否为 _Gdead。如果不是，则抛出错误</span>
	<span class="token keyword">if</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span> <span class="token operator">!=</span> _Gdead <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"newproc1: new g is not Gdead"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 计算 G 的栈空间大小</span>
	totalSize <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize <span class="token operator">+</span> sys<span class="token punctuation">.</span>MinFrameSize<span class="token punctuation">)</span>
    <span class="token comment">// 对齐栈空间</span>
	totalSize <span class="token operator">=</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>totalSize<span class="token punctuation">,</span> sys<span class="token punctuation">.</span>StackAlign<span class="token punctuation">)</span>
	sp <span class="token operator">:=</span> newg<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">-</span> totalSize
    <span class="token comment">// 根据架构，初始化 G 的栈帧</span>
	<span class="token keyword">if</span> usesLR <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// caller's LR</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token function">prepGoExitFrame</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> GOARCH <span class="token operator">==</span> <span class="token string">"arm64"</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// caller's FP</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>sp <span class="token operator">-</span> goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
    
    <span class="token comment">// 释放当前的 M</span>
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>

    <span class="token comment">// 返回新创建的 G</span>
	<span class="token keyword">return</span> newg
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="_632">
     </a>
     启动调度
    </h6>
    <p>
     当
     <code>
      newproc
     </code>
     执行完毕后，执行
     <code>
      mstart
     </code>
     启动
     <code>
      M
     </code>
     ，开始执行
     <code>
      G
     </code>
     调度。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/asm_amd64.s
     </p>
    </blockquote>
    <pre><code class="prism language-assembly">TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME|NOFRAME,$0
	CALL	runtime·mstart0(SB)
	RET // not reached
</code></pre>
    <p>
     在
     <code>
      mstart
     </code>
     汇编代码中调用了
     <code>
      mstart0
     </code>
     函数。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">mstart0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前 G</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
    
    <span class="token comment">// 调用 mstart1，执行 M 的初始化逻辑</span>
	<span class="token function">mstart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     <code>
      mstart1
     </code>
     在
     <code>
      mstart0
     </code>
     调用后执行，启动调度器。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">mstart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前 M 正在执行的 G</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> gp <span class="token operator">!=</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0 <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 确保当前 G 是 M 的初始 G0，如果不是则会抛出异常</span>
        <span class="token comment">// mstart1 只能由 G0 调用</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"bad runtime·mstart"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 这些设置使得 goexit0 或 mcall 可以通过 gogo 恢复到 mstart0 的调用点，并正确退出线程</span>
	gp<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">)</span>	<span class="token comment">// 设置为当前 G</span>
	gp<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment">// 获取调用者的程序计数器</span>
	gp<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>sp <span class="token operator">=</span> <span class="token function">getcallersp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment">// 获取调用者的栈指针</span>
	
    <span class="token comment">// 初始化与架构相关的运行时状态</span>
	<span class="token function">asminit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 初始化 M 的状态</span>
	<span class="token function">minit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
    <span class="token comment">// 如果当前 M 是 M0，调用 mstartm0 安装信号处理器</span>
	<span class="token keyword">if</span> gp<span class="token punctuation">.</span>m <span class="token operator">==</span> <span class="token operator">&amp;</span>m0 <span class="token punctuation">{<!-- --></span>
		<span class="token function">mstartm0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
		
    <span class="token comment">// 允许用户在主线程启动时执行自定义逻辑（例如，初始化 C 代码）</span>
	<span class="token keyword">if</span> fn <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>mstartfn<span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 线程有一个用户定义的启动函数</span>
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果当前 M 不是 M0，尝试获取一个 P</span>
	<span class="token keyword">if</span> gp<span class="token punctuation">.</span>m <span class="token operator">!=</span> <span class="token operator">&amp;</span>m0 <span class="token punctuation">{<!-- --></span>
		<span class="token function">acquirep</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>nextp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>nextp <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 调用 schedule 启动调度器，开始执行 G</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     <code>
      schedule
     </code>
     负责执行一个调度周期：找到一个可运行的
     <code>
      G
     </code>
     并执行它。这个函数是调度器的主循环，它会不断运行，直到程序退出。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前 G 的 M</span>
	mp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m
	
    <span class="token comment">// 如果当前 M 持有锁，抛出异常</span>
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>locks <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"schedule: holding locks"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果 M 绑定到一个特定的 G</span>
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>lockedg <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 调用 stoplockedm 停止当前 M ，并执行绑定的 G</span>
		<span class="token function">stoplockedm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 执行</span>
		<span class="token function">execute</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span>lockedg<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果当前 M 正在执行 cgo 调用，抛出异常</span>
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>incgo <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"schedule: in cgo"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

top<span class="token punctuation">:</span>
    <span class="token comment">// 获取当前 M 的 P</span>
	pp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>
	
    <span class="token comment">// 如果正在自旋，但本地队列中有可运行的 G，抛出异常</span>
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>spinning <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runnext <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> pp<span class="token punctuation">.</span>runqhead <span class="token operator">!=</span> pp<span class="token punctuation">.</span>runqtail<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"schedule: spinning with local work"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 查找可运行的 G</span>
	gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">,</span> tryWakeP <span class="token operator">:=</span> <span class="token function">findRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 如果 M 正在自旋，调用 resetspinning 重置自旋状态</span>
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>spinning <span class="token punctuation">{<!-- --></span>
		<span class="token function">resetspinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 如果需要唤醒一个 P</span>
	<span class="token keyword">if</span> tryWakeP <span class="token punctuation">{<!-- --></span>
		<span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 如果 G 绑定到一个特定线程，重新查找</span>
	<span class="token keyword">if</span> gp<span class="token punctuation">.</span>lockedm <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">startlockedm</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> top
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 调用 execute 执行找到的 G</span>
	<span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     <code>
      execute
     </code>
     用于启动一个
     <code>
      G
     </code>
     的执行。它的作用是将一个可运行的
     <code>
      G
     </code>
     设置为运行状态，并开始执行其代码。
    </p>
    <p>
     <strong>
      注意，当首次程序执行到这里时，取出
      <code>
       G
      </code>
      就是
      <code>
       runtime.main
      </code>
      ，也就是说接下来执行的是
      <code>
       runtime.main
      </code>
      函数。
     </strong>
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">execute</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前 G 的 M</span>
	mp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 将当前 M 的当前 G 设置为 gp</span>
	mp<span class="token punctuation">.</span>curg <span class="token operator">=</span> gp
    <span class="token comment">// 将 G 的 M 指针 gp.m 设置为当前线程 mp</span>
	gp<span class="token punctuation">.</span>m <span class="token operator">=</span> mp
    <span class="token comment">// 使用原子操作将 G 的状态从 _Grunnable 更新为 _Grunning</span>
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>
    <span class="token comment">// 表示 G 不再等待</span>
	gp<span class="token punctuation">.</span>waitsince <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 避免在刚启动时被抢占</span>
	gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>
	gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> stackGuard
    <span class="token comment">// 如果不继承时间片，增加当前 P 的时间片计数器</span>
    <span class="token comment">// 从其他 P 的本地队列中获取到的 G，需要继承时间片计数器</span>
    <span class="token comment">// 用于调度器的公平性调度，确保 G 能够获得足够的时间片</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>inheritTime <span class="token punctuation">{<!-- --></span>
		mp<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schedtick<span class="token operator">++</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 切换到 G 的上下文并执行</span>
    <span class="token comment">// gogo 是一个底层函数，用于在 G 之间切换栈和程序计数器</span>
	<span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>sched<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     运行到这里时
     <code>
      execute
     </code>
     会调用
     <code>
      gogo
     </code>
     ，它的作用是从
     <code>
      gobuf
     </code>
     结构中恢复
     <code>
      G
     </code>
     的状态，并跳转到目标
     <code>
      G
     </code>
     的执行点。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/asm_amd64.s
     </p>
    </blockquote>
    <pre><code class="prism language-assembly"># func gogo(buf *gobuf)
# restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $0-8
	# 从函数参数中获取 gobuf 的地址，并保存到寄存器 BX 中
	MOVQ	buf+0(FP), BX		# gobuf
	# 从 gobuf 中获取 G 的指针（gobuf_g），并保存到寄存器 DX 中
	MOVQ	gobuf_g(BX), DX
	# 检查 G 是否为 nil，确保安全性
	MOVQ	0(DX), CX		# make sure g != nil
	# 跳转到 gogo&lt;&gt;，执行实际的上下文切换逻辑
	JMP	gogo&lt;&gt;(SB)

TEXT gogo&lt;&gt;(SB), NOSPLIT, $0
	get_tls(CX)	# 获取当前线程的线程局部存储
	MOVQ	DX, g(CX) # 将目标 G 的指针保存到 TLS 中的 g 指针
	MOVQ	DX, R14		# 将目标 G 的指针保存到寄存器 R14 中，用于后续操作
	
	# 恢复寄存器状态
	MOVQ	gobuf_sp(BX), SP	# 栈指针
	MOVQ	gobuf_ret(BX), AX	# 返回地址
	MOVQ	gobuf_ctxt(BX), DX	# 上下文指针
	MOVQ	gobuf_bp(BX), BP	# 基指针
	
	# 清理 gobuf
	# 将 gobuf 中的寄存器状态清零
	MOVQ	$0, gobuf_sp(BX)	# clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	
	# 跳转到目标 G
	MOVQ	gobuf_pc(BX), BX	# 从 gobuf 中恢复目标 G 的程序计数器
	JMP	BX	# 跳转到目标地址，开始执行目标 G
</code></pre>
    <h6>
     <a id="runtimemain_861">
     </a>
     <code>
      runtime.main
     </code>
    </h6>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  	<span class="token comment">// ...</span>
   
	<span class="token keyword">if</span> goarch<span class="token punctuation">.</span>PtrSize <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">{<!-- --></span>	
		maxstacksize <span class="token operator">=</span> <span class="token number">1000000000</span>	<span class="token comment">// 64位系统：1GB</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		maxstacksize <span class="token operator">=</span> <span class="token number">250000000</span>	<span class="token comment">// 32位系统：256MB</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 设置栈大小的上限，避免分配过大的栈导致崩溃</span>
	maxstackceiling <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> maxstacksize
    
    <span class="token comment">// 可以启动 M 来运行 G</span>
	mainStarted <span class="token operator">=</span> <span class="token boolean">true</span>

    <span class="token comment">// ...</span>
    
	<span class="token comment">// 启动系统监控线程 sysmon</span>
	<span class="token keyword">if</span> haveSysmon <span class="token punctuation">{<!-- --></span>
		<span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">newm</span><span class="token punctuation">(</span>sysmon<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 将当前 G 锁定到内核线程 M0，确保某些需要在主线程执行的调用能够正常工作</span>
	<span class="token function">lockOSThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
    <span class="token comment">// 确保 runtime.main 是在 M0 上执行</span>
	<span class="token keyword">if</span> mp <span class="token operator">!=</span> <span class="token operator">&amp;</span>m0 <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"runtime.main not on m0"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 调用用户定义的 main.main 函数，开始执行用户代码</span>
	fn <span class="token operator">:=</span> main_main
	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
    <span class="token comment">// ...</span>

	<span class="token comment">// 如果程序在退出时有正在运行的 panic 或 defer 函数，等待它们完成</span>
	<span class="token keyword">if</span> runningPanicDefers<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Running deferred functions should not take long.</span>
		<span class="token keyword">for</span> c <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> c<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> runningPanicDefers<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span>
			<span class="token punctuation">}</span>
			<span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> panicking<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">gopark</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> waitReasonPanicWait<span class="token punctuation">,</span> traceBlockForever<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 运行退出钩子</span>
	<span class="token function">runExitHooks</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	
    <span class="token comment">// 如果程序正常结束，调用 exit(0) 退出程序</span>
	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">var</span> x <span class="token operator">*</span><span class="token builtin">int32</span>
		<span class="token operator">*</span>x <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     到这里时，就已经开始执行业务代码了，那么接下来就是从业务执行的角度来分析
     <code>
      G
     </code>
     的调度流程。
    </p>
    <hr/>
    <h5>
     <a id="_938">
     </a>
     业务执行流程
    </h5>
    <h6>
     <a id="_G_940">
     </a>
     创建
     <code>
      G
     </code>
    </h6>
    <p>
     给出一个创建
     <code>
      G
     </code>
     的代码，如下所示：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">printVal</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">10</span> <span class="token operator">+</span> val
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">go</span> <span class="token function">printVal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将以上代码编译成汇编代码，如下所示：
    </p>
    <pre><code class="prism language-assembly"># ...
0x000e 00014       LEAQ    main.main.gowrap1·f(SB), AX
0x0015 00021       PCDATA  $1, $0
0x0015 00021       CALL    runtime.newproc(SB)
0x001a 00026       ADDQ    $8, SP
0x001e 00030       POPQ    BP
0x001f 00031       NOP
0x0020 00032       RET
# ...
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <p>
     上述代码中使用
     <code>
      runtime.newproc
     </code>
     来创建一个
     <code>
      G
     </code>
     ，那么接下来根据之前分析结果，在
     <code>
      newproc
     </code>
     函数中会创建，并且将该
     <code>
      G
     </code>
     放入
     <code>
      P
     </code>
     的本地运行队列，需要立即调度。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">runqput</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> gp <span class="token operator">*</span>g<span class="token punctuation">,</span> next <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 优先将 G 放入 runnext 插槽</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>haveSysmon <span class="token operator">&amp;&amp;</span> next <span class="token punctuation">{<!-- --></span>
		next <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> randomizeScheduler <span class="token operator">&amp;&amp;</span> next <span class="token operator">&amp;&amp;</span> <span class="token function">randn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		next <span class="token operator">=</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> next <span class="token punctuation">{<!-- --></span>
	retryNext<span class="token punctuation">:</span>
        <span class="token comment">// 如果 runnext 插槽已经被占用，则将旧的 runnext G 放入普通队列</span>
		oldnext <span class="token operator">:=</span> pp<span class="token punctuation">.</span>runnext
		<span class="token keyword">if</span> <span class="token operator">!</span>pp<span class="token punctuation">.</span>runnext<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>oldnext<span class="token punctuation">,</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">goto</span> retryNext
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> oldnext <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Kick the old runnext out to the regular run queue.</span>
		gp <span class="token operator">=</span> oldnext<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

retry<span class="token punctuation">:</span>
    <span class="token comment">// 队列头</span>
	h <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadAcq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>runqhead<span class="token punctuation">)</span>
    <span class="token comment">// 队列尾</span>
	t <span class="token operator">:=</span> pp<span class="token punctuation">.</span>runqtail
    <span class="token comment">// 检查本地队列是否已满，大小是256个</span>
	<span class="token keyword">if</span> t<span class="token operator">-</span>h <span class="token operator">&lt;</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果队列未满，将 G 放入队列尾部</span>
		pp<span class="token punctuation">.</span>runq<span class="token punctuation">[</span>t<span class="token operator">%</span><span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
		atomic<span class="token punctuation">.</span><span class="token function">StoreRel</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>runqtail<span class="token punctuation">,</span> t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 如果队列已满，调用 runqputslow 将 G 放入全局队列</span>
	<span class="token keyword">if</span> <span class="token function">runqputslow</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> h<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 如果放入操作失败，则重新尝试</span>
	<span class="token keyword">goto</span> retry
<span class="token punctuation">}</span>
</code></pre>
    <p>
     如果当前
     <code>
      P
     </code>
     的本地队列已满会调用
     <code>
      runqputslow
     </code>
     函数，将
     <code>
      G
     </code>
     放入全局队列。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">runqputslow</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> gp <span class="token operator">*</span>g<span class="token punctuation">,</span> h<span class="token punctuation">,</span> t <span class="token builtin">uint32</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 定义一个临时数组 batch，大小是本地队列长度的一半加一</span>
	<span class="token keyword">var</span> batch <span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>g

	<span class="token comment">// First, grab a batch from local queue.</span>
    <span class="token comment">// 计算本地队列中可用的 G 数量</span>
	n <span class="token operator">:=</span> t <span class="token operator">-</span> h
	n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span>
	<span class="token keyword">if</span> n <span class="token operator">!=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果本地队列未满（即实际数量不等于队列长度的一半），抛出异常</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"runqputslow: queue is not full"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 从本地队列中取出一半的 G，放入 batch 数组</span>
		batch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pp<span class="token punctuation">.</span>runq<span class="token punctuation">[</span><span class="token punctuation">(</span>h<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">%</span><span class="token function">uint32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 使用原子操作，更新本地队列的头指针，表示这些 G 已被取出</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">CasRel</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>runqhead<span class="token punctuation">,</span> h<span class="token punctuation">,</span> h<span class="token operator">+</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// cas-release, commits consume</span>
        <span class="token comment">// 如果操作失败，返回 false</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 将传入的 G 添加到批量的末尾</span>
	batch<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> gp
	
    <span class="token comment">// 如果启用了调度器随机化，对批量中的 G 进行随机打乱</span>
	<span class="token keyword">if</span> randomizeScheduler <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 使用 cheaprandn 生成随机索引并交换元素，避免调度的可预测性</span>
			j <span class="token operator">:=</span> <span class="token function">cheaprandn</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
			batch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> batch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> batch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> batch<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Link the goroutines.</span>
   	<span class="token comment">// 将批量中的 G 链接起来，形成一个双向链表</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		batch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>schedlink<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>batch<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 创建一个 gQueue 对象，表示要放入全局队列的 G 批量</span>
	<span class="token keyword">var</span> q gQueue
    <span class="token comment">// 设置队列的头指针和尾指针</span>
	q<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>batch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	q<span class="token punctuation">.</span>tail<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>batch<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>

	<span class="token comment">// Now put the batch on global queue.</span>
    <span class="token comment">// 获取全局调度器锁 sched.lock，确保对全局队列的操作是线程安全的</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
    <span class="token comment">// 调用 globrunqputbatch 将批量 G 放入全局队列</span>
	<span class="token function">globrunqputbatch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
    
    <span class="token comment">// 如果批量成功放入全局队列，返回 true</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     当创建好
     <code>
      G
     </code>
     之后，会调用
     <code>
      wakep
     </code>
     函数唤醒空闲的
     <code>
      P
     </code>
     。该函数的主要目的是确保有足够的
     <code>
      M
     </code>
     在运行，以处理当前的
     <code>
      G
     </code>
     负载。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果当前存在有自旋 M 或者其他 M 已经尝试过唤醒，直接返回</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">.</span><span class="token function">CompareAndSwap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 获取当前 M</span>
	mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">var</span> pp <span class="token operator">*</span>p
    <span class="token comment">// 加锁</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
    <span class="token comment">// 尝试获取一个空闲的 P</span>
	pp<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">pidlegetSpinning</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> pp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果没有找到空闲的处理器</span>
		<span class="token keyword">if</span> sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"wakep: negative nmspinning"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 解锁并释放当前 M ，直接返回</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 解锁</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	
    <span class="token comment">// 获取到了空闲 P，则调用 startm 启动一个 M，并将其绑定到获取到的处理器</span>
	<span class="token function">startm</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	
    <span class="token comment">// 释放当前 M</span>
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在
     <code>
      wakep
     </code>
     函数中执行了
     <code>
      startm
     </code>
     函数，该函数主要对找到的空闲
     <code>
      P
     </code>
     ，获取一个
     <code>
      M
     </code>
     并进行绑定。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">startm</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> spinning<span class="token punctuation">,</span> lockheld <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>
    
    <span class="token comment">// 从 M 的空闲列表中获取</span>
	nmp <span class="token operator">:=</span> <span class="token function">mget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> nmp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// ...</span>
        
        <span class="token comment">// 创建一个新的 M</span>
		<span class="token function">newm</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> id<span class="token punctuation">)</span>

		<span class="token comment">// ...</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// ...</span>
	nmp<span class="token punctuation">.</span>spinning <span class="token operator">=</span> spinning
	nmp<span class="token punctuation">.</span>nextp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
    <span class="token comment">// 唤醒空闲的 M</span>
	<span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmp<span class="token punctuation">.</span>park<span class="token punctuation">)</span>
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="_G_1155">
     </a>
     执行
     <code>
      G
     </code>
    </h6>
    <p>
     在
     <code>
      schedule
     </code>
     调度函数中有一个
     <code>
      findRunnable
     </code>
     函数，这个函数专门用于获取待执行的
     <code>
      G
     </code>
     。
    </p>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">findRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime<span class="token punctuation">,</span> tryWakeP <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前 G 的 M</span>
	mp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m

top<span class="token punctuation">:</span>
    <span class="token comment">// 获取 M 绑定的 P</span>
	pp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 如果调度器正在等待垃圾回收，调用 gcstopm 停止当前 M ，并重新开始查找</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">gcstopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> top
	<span class="token punctuation">}</span>
	
    <span class="token comment">// ...</span>
	
    <span class="token comment">// 从全局队列中获取 G</span>
    <span class="token comment">// 每间隔 61 次调度，尝试从全局队列中获取一个 G</span>
	<span class="token keyword">if</span> pp<span class="token punctuation">.</span>schedtick<span class="token operator">%</span><span class="token number">61</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加锁</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
        <span class="token comment">// 从全局队列中获取</span>
		gp <span class="token operator">:=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment">// 解锁</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
        <span class="token comment">// 获取 G，直接返回</span>
		<span class="token keyword">if</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// ...</span>

    <span class="token comment">//  从本地队列中取到，直接返回</span>
	<span class="token keyword">if</span> gp<span class="token punctuation">,</span> inheritTime <span class="token operator">:=</span> <span class="token function">runqget</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">,</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 本地队列中未取到，从全局队列中取</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 加锁</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
         <span class="token comment">// 从全局队列中获取</span>
		gp <span class="token operator">:=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment">// 解锁</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
         <span class="token comment">// 获取 G，直接返回</span>
		<span class="token keyword">if</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 处理网络轮询</span>
	<span class="token keyword">if</span> <span class="token function">netpollinited</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">netpollAnyWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果网络轮询初始化完成且有等待的 G</span>
		<span class="token keyword">if</span> list<span class="token punctuation">,</span> delta <span class="token operator">:=</span> <span class="token function">netpoll</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// non-blocking</span>
            <span class="token comment">// 获取 G</span>
			gp <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token function">injectglist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>
			<span class="token function">netpollAdjustWaiters</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span>
			trace <span class="token operator">:=</span> <span class="token function">traceAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
			<span class="token keyword">if</span> trace<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				trace<span class="token punctuation">.</span><span class="token function">GoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token function">traceRelease</span><span class="token punctuation">(</span>trace<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
            <span class="token comment">// 如果找到 G，返回</span>
			<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

    <span class="token comment">// 如果当前 M 正在自旋或者系统中自旋 M 的数量少于 GOMAXPROCS/2，则当前 M 可以进入自旋状态</span>
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>spinning <span class="token operator">||</span> <span class="token number">2</span><span class="token operator">*</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> gomaxprocs<span class="token operator">-</span>sched<span class="token punctuation">.</span>npidle<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token operator">!</span>mp<span class="token punctuation">.</span>spinning <span class="token punctuation">{<!-- --></span>
     		<span class="token comment">// 当前 M 成为自旋状态</span>
			mp<span class="token punctuation">.</span><span class="token function">becomeSpinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 尝试从其他 P 中“偷取” G</span>
		gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">,</span> tnow<span class="token punctuation">,</span> w<span class="token punctuation">,</span> newWork <span class="token operator">:=</span> <span class="token function">stealWork</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span>
        <span class="token comment">// 获取 G，直接返回</span>
		<span class="token keyword">if</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
		
        <span class="token comment">// ...</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 处理 GC 标记任务</span>
    <span class="token comment">// ...</span>

	<span class="token comment">// 处理空闲状态</span>
    <span class="token comment">// ...</span>
	
    <span class="token comment">// 释放处理器</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> pp<span class="token punctuation">.</span>runSafePointFn <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> top
	<span class="token punctuation">}</span>
    <span class="token comment">// 如果全局队列中有任务，尝试从中获取一个 G</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		gp <span class="token operator">:=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 如果当前 M 不是自旋状态，但调度器需要自旋 M，尝试将当前 M 标记为“自旋”</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>mp<span class="token punctuation">.</span>spinning <span class="token operator">&amp;&amp;</span> sched<span class="token punctuation">.</span>needspinning<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
		mp<span class="token punctuation">.</span><span class="token function">becomeSpinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> top
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token function">releasep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pp <span class="token punctuation">{<!-- --></span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"findrunnable: wrong p"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 释放当前 P，并将其放入空闲队列</span>
	now <span class="token operator">=</span> <span class="token function">pidleput</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
    
	wasSpinning <span class="token operator">:=</span> mp<span class="token punctuation">.</span>spinning
	<span class="token keyword">if</span> mp<span class="token punctuation">.</span>spinning <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果当前 M 处于自旋状态，则将其标记为非自旋</span>
		mp<span class="token punctuation">.</span>spinning <span class="token operator">=</span> <span class="token boolean">false</span>
		<span class="token keyword">if</span> sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"findrunnable: negative nmspinning"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		
        <span class="token comment">// 加锁</span>
        <span class="token comment">// 重新检查全局队列和本地队列</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
        <span class="token comment">// 如果全局队列中有 G,尝试获取一个空闲的 P，并从中获取一个 G</span>
		<span class="token keyword">if</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 获取 P</span>
			pp<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">pidlegetSpinning</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> pp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 获取 G</span>
				gp <span class="token operator">:=</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"global runq empty with non-zero runqsize"</span><span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
                <span class="token comment">// 解锁</span>
				<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
				<span class="token function">acquirep</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
				mp<span class="token punctuation">.</span><span class="token function">becomeSpinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// 返回</span>
				<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果全局队列中还是没有G，解锁</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
        
        <span class="token comment">// 这里起始有个疑问：为什么这里就先检查的是全局队列？不是先检查所有 P 的本地队列？</span>
        <span class="token comment">// 比如先遍历所有 P，找到有 G 的 P，然后直接返回 top，开始获取</span>
        <span class="token comment">// 如果所有的 P 都没有，再从全局队列中再获取 G</span>
		
        <span class="token comment">// 检查所有 P 的本地队列</span>
        <span class="token comment">// 如果找到 G，获取对应的处理器</span>
		pp <span class="token operator">:=</span> <span class="token function">checkRunqsNoP</span><span class="token punctuation">(</span>allpSnapshot<span class="token punctuation">,</span> idlepMaskSnapshot<span class="token punctuation">)</span>
		<span class="token keyword">if</span> pp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">acquirep</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
            <span class="token comment">// 当前 M 成为自旋状态</span>
			mp<span class="token punctuation">.</span><span class="token function">becomeSpinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// 从顶部开始，重新检查</span>
			<span class="token keyword">goto</span> top
		<span class="token punctuation">}</span>
		
        <span class="token comment">// 检查是否有空闲优先级的 GC G</span>
        
        <span class="token comment">// 如果找到 G，获取对应的 P</span>
		pp<span class="token punctuation">,</span> gp <span class="token operator">:=</span> <span class="token function">checkIdleGCNoP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> pp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">acquirep</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
            <span class="token comment">// 恢复 M 的自旋状态</span>
			mp<span class="token punctuation">.</span><span class="token function">becomeSpinning</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

			pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerIdleMode
			trace <span class="token operator">:=</span> <span class="token function">traceAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
			<span class="token keyword">if</span> trace<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				trace<span class="token punctuation">.</span><span class="token function">GoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token function">traceRelease</span><span class="token punctuation">(</span>trace<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
             <span class="token comment">// 并返回找到的 G</span>
			<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">// ...</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
	
    <span class="token comment">// 如果没有找到可运行的 G，停止当前 M，进入休眠状态</span>
    <span class="token comment">// 1. 调用 mput 将当前 M 放入空闲队列</span>
    <span class="token comment">// 2. 调用 mPark 将当前 M 放入休眠状态，直到被唤醒</span>
    <span class="token comment">// 3. 清空 gp.m.nextp，当前 M 不再持有下一个处理器</span>
	<span class="token function">stopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 重新开始查找</span>
	<span class="token keyword">goto</span> top
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       每间隔 61 次调度，尝试从全局队列中获取一个
       <code>
        G
       </code>
       ；其余时候
       <code>
        M
       </code>
       会从绑定的
       <code>
        P
       </code>
       的本地队列中获取
       <code>
        G
       </code>
       并执行。
      </p>
     </li>
     <li>
      <p>
       当
       <code>
        P
       </code>
       的本地队列为空时，会执行
       <code>
        globrunqget
       </code>
       函数，该函数专门用于从全局队列中获取
       <code>
        G
       </code>
       。
      </p>
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">globrunqget</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> max <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{<!-- --></span>
	<span class="token function">assertLockHeld</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token comment">// 如果全局队列为空，直接返回 nil</span>
	<span class="token keyword">if</span> sched<span class="token punctuation">.</span>runqsize <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 计算要从全局队列中获取的 G 数量</span>
    <span class="token comment">// 默认情况下，每个 P 可以从全局队列中获取 sched.runqsize / gomaxprocs + 1 个 G，以确保负载均衡</span>
	n <span class="token operator">:=</span> sched<span class="token punctuation">.</span>runqsize<span class="token operator">/</span>gomaxprocs <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token comment">// 如果计算的 n 超过了全局队列的大小，则取全局队列的大小</span>
	<span class="token keyword">if</span> n <span class="token operator">&gt;</span> sched<span class="token punctuation">.</span>runqsize <span class="token punctuation">{<!-- --></span>
		n <span class="token operator">=</span> sched<span class="token punctuation">.</span>runqsize
	<span class="token punctuation">}</span>
    <span class="token comment">// 如果设置了 max，则 n 不能超过 max</span>
	<span class="token keyword">if</span> max <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">&gt;</span> max <span class="token punctuation">{<!-- --></span>
		n <span class="token operator">=</span> max
	<span class="token punctuation">}</span>
    <span class="token comment">// 如果 n 超过了本地队列大小的一半，则取本地队列大小的一半</span>
	<span class="token keyword">if</span> n <span class="token operator">&gt;</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">{<!-- --></span>
		n <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>runq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 从全局队列大小中减去即将获取的 G 数量</span>
	sched<span class="token punctuation">.</span>runqsize <span class="token operator">-=</span> n
	
    <span class="token comment">// 从全局队列中弹出一个 G，并将其保存到 gp 中</span>
	gp <span class="token operator">:=</span> sched<span class="token punctuation">.</span>runq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	n<span class="token operator">--</span>
    <span class="token comment">// 如果还需要获取更多 G，则继续从全局队列中弹出，并将它们放入目标 P 的本地队列中</span>
	<span class="token keyword">for</span> <span class="token punctuation">;</span> n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">--</span> <span class="token punctuation">{<!-- --></span>
		gp1 <span class="token operator">:=</span> sched<span class="token punctuation">.</span>runq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token function">runqput</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> gp1<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// 返回从全局队列中获取的第一个 G</span>
	<span class="token keyword">return</span> gp
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      如果全局队列不空时，则根据以下公式取出
      <code>
       n
      </code>
      个
      <code>
       G
      </code>
      加入到
      <code>
       P
      </code>
      的本地队列中。
     </li>
    </ul>
    <p>
     <span class="katex--display">
      <span class="katex-display">
       <span class="katex">
        <span class="katex-mathml">
         n 
         
        
          = 
         
        
          m 
         
        
          i 
         
        
          n 
         
        
          ( 
         
        
          l 
         
        
          e 
         
        
          n 
         
        
          ( 
         
        
          全局队列 
         
        
          ) 
         
        
          / 
         
        
          G 
         
        
          O 
         
        
          M 
         
        
          A 
         
        
          X 
         
        
          P 
         
        
          R 
         
        
          O 
         
        
          C 
         
        
          S 
         
        
          + 
         
        
          1 
         
        
          , 
         
        
          c 
         
        
          a 
         
        
          p 
         
        
          ( 
         
        
          本地队列 
         
        
          ) 
         
        
          / 
         
        
          2 
         
        
          ) 
         
        
       
         n = min(len(全局队列) / GOMAXPROCS + 1, cap(本地队列) / 2 )
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 0.4306em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mspace" style="margin-right: 0.2778em;">
          </span>
          <span class="mrel">
           =
          </span>
          <span class="mspace" style="margin-right: 0.2778em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal">
           min
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0197em;">
           l
          </span>
          <span class="mord mathnormal">
           e
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord cjk_fallback">
           全局队列
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mord">
           /
          </span>
          <span class="mord mathnormal" style="margin-right: 0.109em;">
           GOM
          </span>
          <span class="mord mathnormal">
           A
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0576em;">
           XPROCS
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
          <span class="mbin">
           +
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord">
           1
          </span>
          <span class="mpunct">
           ,
          </span>
          <span class="mspace" style="margin-right: 0.1667em;">
          </span>
          <span class="mord mathnormal">
           c
          </span>
          <span class="mord mathnormal">
           a
          </span>
          <span class="mord mathnormal">
           p
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord cjk_fallback">
           本地队列
          </span>
          <span class="mclose">
           )
          </span>
          <span class="mord">
           /2
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
     </span>
    </p>
    <ul>
     <li>
      <p>
       如果全局队列也为空，则从网络轮询事件中取
       <code>
        G
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       如果获取到
       <code>
        G
       </code>
       则直接进入调度阶段。
      </p>
     </li>
     <li>
      <p>
       如果还是未获取到
       <code>
        G
       </code>
       并且当前系统中自旋
       <code>
        M
       </code>
       的数量小于
       <code>
        GOMAXPROCS/2
       </code>
       ，则
       <code>
        M
       </code>
       会进入自旋状态。自旋状态的目的是让
       <code>
        M
       </code>
       快速尝试获取任务，而不是直接进入休眠，从而减少上下文切换的开销。
      </p>
     </li>
     <li>
      <p>
       在自旋状态下，通过
       <code>
        stealWork
       </code>
       调用函数尝试从其他
       <code>
        P
       </code>
       的本地队列中窃取
       <code>
        G
       </code>
       执行。
      </p>
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">stealWork</span><span class="token punctuation">(</span>now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">,</span> rnow<span class="token punctuation">,</span> pollUntil <span class="token builtin">int64</span><span class="token punctuation">,</span> newWork <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取当前 M 绑定的 P</span>
	pp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>

   	<span class="token comment">// 尝试最多4次</span>
	<span class="token keyword">const</span> stealTries <span class="token operator">=</span> <span class="token number">4</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stealTries<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		stealTimersOrRunNextG <span class="token operator">:=</span> i <span class="token operator">==</span> stealTries<span class="token operator">-</span><span class="token number">1</span>
		
        <span class="token comment">// 使用 stealOrder 随机遍历所有 P，以避免总是从相同的处理器中偷取 G</span>
		<span class="token keyword">for</span> enum <span class="token operator">:=</span> stealOrder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">cheaprand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>enum<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> enum<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果调度器正在等待垃圾回收，表示可能有新的 G</span>
			<span class="token keyword">if</span> sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// GC work may be available.</span>
				<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> now<span class="token punctuation">,</span> pollUntil<span class="token punctuation">,</span> <span class="token boolean">true</span>
			<span class="token punctuation">}</span>
	
			<span class="token comment">// ... </span>
			
            <span class="token comment">// 如果目标 P 不是空闲的，尝试从其本地队列中偷取 G</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>idlepMask<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>enum<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> gp <span class="token operator">:=</span> <span class="token function">runqsteal</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> stealTimersOrRunNextG<span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> now<span class="token punctuation">,</span> pollUntil<span class="token punctuation">,</span> ranTimer
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
    <span class="token comment">// 如果没有找到可运行的 G，返回 nil 和其他相关信息</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> now<span class="token punctuation">,</span> pollUntil<span class="token punctuation">,</span> ranTimer
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <ul>
     <li>
      如果从其他
      <code>
       P
      </code>
      的本地队列中窃取到
      <code>
       G
      </code>
      ，则直接进入调度阶段。
     </li>
     <li>
      如果还是没有从其他
      <code>
       P
      </code>
      的本地队列中窃取到
      <code>
       G
      </code>
      ，则首先会将当前
      <code>
       M
      </code>
      重新标记为非自旋
      <code>
       M
      </code>
      ，减少全局自旋
      <code>
       M
      </code>
      的数量，然后再一次检查全局队列和本地队列是否可以获取到
      <code>
       G
      </code>
      。
     </li>
     <li>
      当此时从全局队列、本地队列、空闲优先级的
      <code>
       GCG
      </code>
      、网络轮询获取到了
      <code>
       G
      </code>
      ，则恢复
      <code>
       M
      </code>
      的自旋状态，进入调度阶段。
     </li>
     <li>
      如果没有找到可运行的
      <code>
       G
      </code>
      ，调用
      <code>
       stopm
      </code>
      函数将当前
      <code>
       M
      </code>
      放入空闲队列，并进入休眠状态。
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">stopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>

	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token function">mput</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">)</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token function">mPark</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">acquirep</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>nextp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>nextp <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <h6>
     <a id="_1486">
     </a>
     调度执行
    </h6>
    <ul>
     <li>
      <p>
       当获取到
       <code>
        G
       </code>
       后，在
       <code>
        execute
       </code>
       函数中执行
       <code>
        gogo
       </code>
       函数切换到该
       <code>
        G
       </code>
       的栈，此时，
       <code>
        M
       </code>
       会保存当前
       <code>
        G0
       </code>
       的上下文，并恢复目标
       <code>
        G
       </code>
       的上下文，然后开始执行
       <code>
        G
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       在
       <code>
        golang
       </code>
       中
       <code>
        sysmon
       </code>
       是一个独立的后台监控线程，它负责监控和管理
       <code>
        G
       </code>
       的执行情况，确保调度的公平性和系统的高效运行。如果某个
       <code>
        G
       </code>
       运行时间超过 10 ms，
       <code>
        sysmon
       </code>
       会触发抢占，将
       <code>
        G
       </code>
       重新放入全局队列中。
      </p>
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">sysmon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>

	lasttrace <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	idle <span class="token operator">:=</span> <span class="token number">0</span> <span class="token comment">// how many cycles in succession we had not wokeup somebody</span>
	delay <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> idle <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// start with 20us sleep...</span>
			delay <span class="token operator">=</span> <span class="token number">20</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> idle <span class="token operator">&gt;</span> <span class="token number">50</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// start doubling the sleep after 1ms...</span>
			delay <span class="token operator">*=</span> <span class="token number">2</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> delay <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// up to 10ms</span>
			delay <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span>
		<span class="token punctuation">}</span>
		<span class="token function">usleep</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span>
        
		<span class="token comment">// ...</span>

		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>sysmonlock<span class="token punctuation">)</span>
        
		<span class="token comment">// ...</span>
        
		<span class="token comment">// </span>
		<span class="token keyword">if</span> <span class="token function">retake</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			idle <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			idle<span class="token operator">++</span>
		<span class="token punctuation">}</span>
		
        <span class="token comment">// ...</span>
        
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>sysmonlock<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <ul>
     <li>
      <code>
       sysmon
      </code>
      函数通过定时调用
      <code>
       retake
      </code>
      函数强制停止长时间运行的
      <code>
       G
      </code>
      ，以避免某些
      <code>
       G
      </code>
      占用过多的
      <code>
       CPU
      </code>
      时间，影响其他
      <code>
       G
      </code>
      的执行。
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// 定义了 G 在没有被抢占的情况下可以运行的最大时间</span>
<span class="token keyword">const</span> forcePreemptNS <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token comment">// 10ms</span>

<span class="token keyword">func</span> <span class="token function">retake</span><span class="token punctuation">(</span>now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">uint32</span> <span class="token punctuation">{<!-- --></span>
	n <span class="token operator">:=</span> <span class="token number">0</span>
	<span class="token comment">// 加锁</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>
	
    <span class="token comment">// 遍历所有处理器</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>allp<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取当前处理器</span>
		pp <span class="token operator">:=</span> allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> pp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
		pd <span class="token operator">:=</span> <span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>sysmontick
        <span class="token comment">// 获取处理器的状态</span>
		s <span class="token operator">:=</span> pp<span class="token punctuation">.</span>status
		sysretake <span class="token operator">:=</span> <span class="token boolean">false</span>
        <span class="token comment">// 如果处理器正在运行或在系统调用中</span>
		<span class="token keyword">if</span> s <span class="token operator">==</span> _Prunning <span class="token operator">||</span> s <span class="token operator">==</span> _Psyscall <span class="token punctuation">{<!-- --></span>
			t <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>schedtick<span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token function">int64</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>schedtick<span class="token punctuation">)</span> <span class="token operator">!=</span> t <span class="token punctuation">{<!-- --></span>
				pd<span class="token punctuation">.</span>schedtick <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
				pd<span class="token punctuation">.</span>schedwhen <span class="token operator">=</span> now
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> pd<span class="token punctuation">.</span>schedwhen<span class="token operator">+</span>forcePreemptNS <span class="token operator">&lt;=</span> now <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果 G 运行时间超过 10 毫秒，调用 preemptone 强制抢占</span>
				<span class="token function">preemptone</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
				sysretake <span class="token operator">=</span> <span class="token boolean">true</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// 如果处理器阻塞在系统调用中</span>
		<span class="token keyword">if</span> s <span class="token operator">==</span> _Psyscall <span class="token punctuation">{<!-- --></span>
			t <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>syscalltick<span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>sysretake <span class="token operator">&amp;&amp;</span> <span class="token function">int64</span><span class="token punctuation">(</span>pd<span class="token punctuation">.</span>syscalltick<span class="token punctuation">)</span> <span class="token operator">!=</span> t <span class="token punctuation">{<!-- --></span>
				pd<span class="token punctuation">.</span>syscalltick <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
				pd<span class="token punctuation">.</span>syscallwhen <span class="token operator">=</span> now
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
            
			<span class="token keyword">if</span> <span class="token function">runqempty</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span> 
            	<span class="token operator">&amp;&amp;</span> sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>sched<span class="token punctuation">.</span>npidle<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> 
            	<span class="token operator">&amp;&amp;</span> pd<span class="token punctuation">.</span>syscallwhen<span class="token operator">+</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1000</span> <span class="token operator">&gt;</span> now <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>
			<span class="token function">incidlelocked</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
			trace <span class="token operator">:=</span> <span class="token function">traceAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// 将处理器的状态从 _Psyscall 改为 _Pidle</span>
			<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> _Pidle<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> trace<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					trace<span class="token punctuation">.</span><span class="token function">ProcSteal</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
					<span class="token function">traceRelease</span><span class="token punctuation">(</span>trace<span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
                <span class="token comment">// 回收 P 的数量加1</span>
				n<span class="token operator">++</span>
				pp<span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>
                <span class="token comment">// 将一个 P 从当前 M 释放出来，并将其放入空闲队列中</span>
				<span class="token function">handoffp</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> trace<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">traceRelease</span><span class="token punctuation">(</span>trace<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token function">incidlelocked</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">// 释放锁</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allpLock<span class="token punctuation">)</span>
 
    <span class="token comment">// 返回回收的处理器数量</span>
	<span class="token keyword">return</span> <span class="token function">uint32</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上汇编代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <ul>
     <li>
      如果
      <code>
       G
      </code>
      遇到阻塞操作（如：I/O操作、系统调用等），则对应的
      <code>
       M
      </code>
      内核线程也会陷入阻塞状态。
     </li>
     <li>
      如果此时队列中存在未执行的
      <code>
       G
      </code>
      ，则调度器会将这个阻塞的内核线程
      <code>
       M
      </code>
      从
      <code>
       P
      </code>
      中剔除。
     </li>
     <li>
      然后从空闲
      <code>
       M
      </code>
      队列中取一个
      <code>
       M
      </code>
      ，重新绑定
      <code>
       P
      </code>
      ；如果不存在空闲的
      <code>
       M
      </code>
      ，则会创建一个新的
      <code>
       M
      </code>
      ，再重新绑定
      <code>
       P
      </code>
      。
     </li>
     <li>
      接着从本地队列中或者全局队列中取未执行的
      <code>
       G
      </code>
      运行。
     </li>
     <li>
      当陷入阻塞的内核线程
      <code>
       M
      </code>
      恢复后，会尝试恢复执行。此时，
      <code>
       M
      </code>
      需要重新获取一个
      <code>
       P
      </code>
      来继续执行
      <code>
       G
      </code>
      。
     </li>
     <li>
      <code>
       M
      </code>
      会尝试从空闲
      <code>
       P
      </code>
      队列中获取一个空闲的
      <code>
       P
      </code>
      。如果成功获取到
      <code>
       P
      </code>
      ，
      <code>
       M
      </code>
      会将该
      <code>
       P
      </code>
      绑定到自己，并继续执行
      <code>
       G
      </code>
      ；如果当前没有空闲的
      <code>
       P
      </code>
      ，
      <code>
       M
      </code>
      会进入休眠状态。
     </li>
     <li>
      此时，原本在
      <code>
       M
      </code>
      上执行的
      <code>
       G
      </code>
      会被放入全局队列中，等待其他
      <code>
       M
      </code>
      获取空闲的
      <code>
       P
      </code>
      后重新调度。
     </li>
    </ul>
    <h6>
     <a id="_1625">
     </a>
     执行结束
    </h6>
    <ul>
     <li>
      当某一个
      <code>
       G
      </code>
      执行完成时，它会调用
      <code>
       goexit
      </code>
      函数。
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/asm_amd64.s
     </p>
    </blockquote>
    <pre><code class="prism language-assembly">TEXT runtime·goexit(SB),NOSPLIT|TOPFRAME|NOFRAME,$0-0
	BYTE	$0x90	# NOP
	CALL	runtime·goexit1(SB)	# does not return
	BYTE	$0x90	# NOP
</code></pre>
    <ul>
     <li>
      在
      <code>
       goexit
      </code>
      调用
      <code>
       runtime.goexit1
      </code>
      ，该函数负责清理当前
      <code>
       G
      </code>
      的资源，
      <code>
       M
      </code>
      会切换回
      <code>
       G0
      </code>
      。
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ...</span>
    <span class="token comment">// 调用 mcall，将控制权切换到 goexit0 函数</span>
    <span class="token comment">// </span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      以上代码只是部分截取，请注意甄别。
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       <code>
        goexit0
       </code>
       是
       <code>
        goexit1
       </code>
       的延续，运行在
       <code>
        g0
       </code>
       上，该函数主要做两件事：
      </p>
      <ul>
       <li>
        <p>
         调用
         <code>
          gdestroy
         </code>
         函数，销毁当前
         <code>
          G
         </code>
         的资源，包括释放栈空间。
        </p>
       </li>
       <li>
        <p>
         调用
         <code>
          schedule
         </code>
         函数，将控制权交还给调度器，让调度器选择下一个可运行的
         <code>
          G
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      源码位置：src/runtime/proc.go
     </p>
    </blockquote>
    <pre><code class="prism language-go"><span class="token comment">// goexit continuation on g0.</span>
<span class="token keyword">func</span> <span class="token function">goexit0</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">gdestroy</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
    <ul>
     <li>
      如果程序中没有可运行的
      <code>
       G
      </code>
      ，且主
      <code>
       G
      </code>
      执行完毕，程序会退出。
     </li>
    </ul>
    <p>
     🌺🌺🌺撒花！
    </p>
    <p>
     如果本文对你有帮助，就点关注或者留个👍
     <br/>
     如果您有任何技术问题或者需要更多其他的内容，请随时向我提问。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3734a0d4d24847a6ad83ea7ad3b1a2c6.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34363238373931382f:61727469636c652f64657461696c732f313436323230323734" class_="artid" style="display:none">
 </p>
</div>


