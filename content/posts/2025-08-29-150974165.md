---
layout: post
title: "Java学习笔记-泛型"
date: 2025-08-29T09:30:32+0800
description: "Java泛型是JDK5引入的重要特性，本质是参数化类型，允许在定义类、接口或方法时使用类型参数，使用时再指定具体类型。泛型的主要优势包括：提高代码复用性、增强类型安全（编译时检查）、减少类型转换。泛型语法包括声明（如class Person&amp;lt;E&amp;gt;）和实例化（如Person&amp;lt;String&amp;gt;）。使用注意事项：泛型只支持引用类型，静态方法不能用类的泛型参数，数组初始化受限制。自定义泛型类和接口可以定义多个类型参数，接口实现时可指定具体类型或保留泛型。泛型在编译时约束类型，但运行时可通过反射"
keywords: "Java学习笔记-泛型"
categories: ['未分类']
tags: ['笔记', '学习', 'Java']
artid: "150974165"
arturl: "https://blog.csdn.net/m0_62107756/article/details/150974165"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150974165
    alt: "Java学习笔记-泛型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150974165
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150974165
cover: https://bing.ee123.net/img/rand?artid=150974165
image: https://bing.ee123.net/img/rand?artid=150974165
img: https://bing.ee123.net/img/rand?artid=150974165
---



# Java学习笔记-泛型

## 13.Java 泛型

### 13.1 泛型介绍

1. **基本介绍**

   1. Java泛型（generics）是JDK 5中引入的一个新特性，在很大的程度上方便在集合上的使用。
   2. 泛型的本质是 **参数化类型**，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了
2. **泛型的好处**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/722beb29530a4b1fb022fcb6b242d349.png#pic_center)

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bbd9737ed4714a2596826c257c794146.png#pic_center)

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/830f7a7ff0454a31af907462a44afc3b.png#pic_center)

   **注意**：泛型只是编译时约束，运行时可以通过反射添加其他类型元素

### 13.2 泛型语法

1. **泛型的声明**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/347b399c5b1a46e3a04276f606d04994.png#pic_center)

   ```java
   class Person<E> {
       //E表示 s的数据类型, 该数据类型在定义Person对象的时候指定,即在编译期间，就确定E是什么类型
       E s ;
       public Person(E s) {//E也可以是参数类型
           this.s = s;
       }
       public E f() {//返回类型使用E
           return s;
       }
       public void show() {
           System.out.println(s.getClass());//显示s的运行类型
       }
   }

   ```
2. **泛型的实例化**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c3d8bf0977a442a7a8d05a381b65c593.png#pic_center)
3. **泛型使用的注意事项和细节**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bac4f9f1cb45464fa01f4a2e41742471.png#pic_center)

   ```java
   public class GenericDetail {
       public static void main(String[] args) {
           //1.给泛型指向数据类型是，要求是引用类型，不能是基本数据类型
           List<Integer> list = new ArrayList<Integer>(); //OK
           //List<int> list2 = new ArrayList<int>();//错误

           //2. 说明
           //因为 E 指定了 A 类型, 构造器传入了 new A()
           //在给泛型指定具体类型后，可以传入该类型或者其子类类型
           Pig<A> aPig = new Pig<A>(new A());
           aPig.f();
           Pig<A> aPig2 = new Pig<A>(new B());
           aPig2.f();

           //3. 泛型的使用形式
           ArrayList<Integer> list1 = new ArrayList<Integer>();
           List<Integer> list2 = new ArrayList<Integer>();
           //在实际开发中，我们往往简写
           //编译器会进行类型推断, 老师推荐使用下面写法
           ArrayList<Integer> list3 = new ArrayList<>();
           List<Integer> list4 = new ArrayList<>();
           ArrayList<Pig> pigs = new ArrayList<>();

           //4. 如果是这样写 泛型默认是 Object
           ArrayList arrayList = new ArrayList();//等价 ArrayList<Object> arrayList = new ArrayList<Object>();
           /*
               public boolean add(Object e) {
                   ensureCapacityInternal(size + 1);  // Increments modCount!!
                   elementData[size++] = e;
                   return true;
               }
            */
           Tiger tiger = new Tiger();
           /*
               class Tiger {//类
                   Object e;

                   public Tiger() {}

                   public Tiger(Object e) {
                       this.e = e;
                   }
               }
            */

       }
   }
   class Tiger<E> {//类
       E e;

       public Tiger() {}

       public Tiger(E e) {
           this.e = e;
       }
   }

   class A {}
   class B extends A {}

   class Pig<E> {//
       E e;
       public Pig(E e) { this.e = e; }
       public void f() {
           System.out.println(e.getClass()); //运行类型
       }
   }

   ```

### 13.3 自定义泛型

#### 13.3.1 自定义泛型类

1. **自定义泛型类**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a431299de7a8433c8f7939c5ee6fe830.png#pic_center)

   ```java
   //解读
   //1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类
   //2, T, R, M 泛型的标识符, 一般是单个大写字母
   //3. 泛型标识符可以有多个.
   //4. 普通成员可以使用泛型 (属性、方法)
   //5. 使用泛型的数组，不能初始化
   //6. 静态方法中不能使用类的泛型
   class Tiger<T, R, M> {
       String name;
       R r; //属性使用到泛型
       M m;
       T t;
       //因为数组在new 不能确定T的类型，就无法在内存开空间
       T[] ts;

       public Tiger(String name) {
           this.name = name;
       }
       public Tiger(R r, M m, T t,T[] ts) {//构造器使用泛型
           //不能直接ts = new T[10];这样写
           this.ts=ts;
           this.r = r;
           this.m = m;
           this.t = t;
       }
       //因为静态是和类相关的，在类加载时，对象还没有创建
       //所以，如果静态方法和静态属性使用了泛型，JVM就无法完成初始化
   //    static R r2;
   //    public static void m1(M m) {
   //
   //    }  
       //方法使用泛型
       public void setR(R r) {//方法使用到泛型
           this.r = r;
       }
       public M getM() {//返回类型可以使用泛型.
           return m;
       }

   }

   ```

#### 13.3.2 自定义泛型接口

1. **自定义泛型接口**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d43607f6442848989f947970a6b029e7.png#pic_center)

   ```java
   //在继承接口 指定泛型接口的类型
   interface IA extends IUsb<String, Double> {
       
   }
   //当我们去实现IA接口时，因为IA在继承IUsu 接口时，指定了U 为String R为Double
   //，在实现IUsu接口的方法时，使用String替换U, 是Double替换R
   class AA implements IA {

       @Override
       public Double get(String s) { return null; }
       
       @Override
       public void hi(Double aDouble) {}
       
       @Override
       public void run(Double r1, Double r2, String u1, String u2) {}
       
   }

   //实现接口时，直接指定泛型接口的类型
   //给U 指定Integer 给 R 指定了 Float
   //所以，当我们实现IUsb方法时，会使用Integer替换U, 使用Float替换R
   class BB implements IUsb<Integer, Float> {
       
       @Override
       public Float get(Integer integer) { return null; }
       
       @Override
       public void hi(Float aFloat) {}
       
       @Override
       public void run(Float r1, Float r2, Integer u1, Integer u2) {}
   }
   //没有指定类型，默认为Object
   //建议直接写成 IUsb<Object,Object>
   class CC implements IUsb { //等价 class CC implements IUsb<Object,Object> {
       
       @Override
       public Object get(Object o) { return null; }
       
       @Override
       public void hi(Object o) {}
       
       @Override
       public void run(Object r1, Object r2, Object u1, Object u2) {}

   }

   interface IUsb<U, R> {

       int n = 10;
       //U name; 不能这样使用，neme一看就应该是String类型

       //普通方法中，可以使用接口泛型
       R get(U u);

       void hi(R r);

       void run(R r1, R r2, U u1, U u2);

       //在jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型
       default R method(U u) {
           return null;
       }
   }

   ```

#### 13.3.3 自定义泛型方法

1. **自定义泛型方法**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/781298d571ac45ffa7eff98a0d747fb9.png#pic_center)

   ```java
   public class CustomMethodGeneric {
       public static void main(String[] args) {
           Car car = new Car();
           car.fly("宝马", 100);//当调用方法时，传入参数，编译器，就会确定类型
           System.out.println("=======");
           car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型

           //测试
           //T->String, R-> ArrayList
           Fish<String, ArrayList> fish = new Fish<>();
           fish.hello(new ArrayList(), 11.3f);
       }
   }

   //泛型方法，可以定义在普通类中, 也可以定义在泛型类中
   class Car {//普通类

       public void run() {//普通方法
       }
       //说明 泛型方法
       //1. <T,R> 就是泛型
       //2. 是提供给 fly使用的
       public <T, R> void fly(T t, R r) {//泛型方法
           System.out.println(t.getClass());//String
           System.out.println(r.getClass());//Integer
       }
   }

   class Fish<T, R> {//泛型类
       public void run() {//普通方法
       }
       public<U,M> void eat(U u, M m) {//泛型方法

       }
       //说明
       //1. 下面hi方法不是泛型方法
       //2. 是hi方法使用了类声明的 泛型
       public void hi(T t) {
       }
       //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型
       public<K> void hello(R r, K k) {
           System.out.println(r.getClass());//ArrayList
           System.out.println(k.getClass());//Float
       }
   }

   ```
2. **练习**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/030a1f321b184522893982bfa6ef3936.png#pic_center)

### 13.4 泛型的继承和通配符

1. **基本介绍**

   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38b568f67ad144c38fbaa8aaef4412f5.png#pic_center)
2. **举例**

   ```java
   public class GenericExtends {
       public static void main(String[] args) {

           Object o = new String("xx");

           //泛型没有继承性
   //        List<Object> list = new ArrayList<String>(); //报错

           //举例说明下面三个方法的使用
           List<Object> list1 = new ArrayList<>();
           List<String> list2 = new ArrayList<>();
           List<AA> list3 = new ArrayList<>();
           List<BB> list4 = new ArrayList<>();
           List<CC> list5 = new ArrayList<>();

           //如果是 List<?> c ，可以接受任意的泛型类型
           printCollection1(list1);
           printCollection1(list2);
           printCollection1(list3);
           printCollection1(list4);
           printCollection1(list5);

           //List<? extends AA> c： 表示 上限，可以接受 AA或者AA子类
   //        printCollection2(list1);//×
   //        printCollection2(list2);//×
           printCollection2(list3);//√
           printCollection2(list4);//√
           printCollection2(list5);//√

           //List<? super AA> c: 支持AA类以及AA类的父类，不限于直接父类
           printCollection3(list1);//√
           //printCollection3(list2);//×
           printCollection3(list3);//√
           //printCollection3(list4);//×
           //printCollection3(list5);//×
           
       }
       // ? extends AA 表示 上限，可以接受 AA或者AA子类
       public static void printCollection2(List<? extends AA> c) {
           for (Object object : c) {
               System.out.println(object);
           }
       }

       //说明: List<?> 表示 任意的泛型类型都可以接受
       public static void printCollection1(List<?> c) {
           for (Object object : c) { // 通配符，取出时，就是Object
               System.out.println(object);
           }
       }
       
       // ? super 子类类名AA:支持AA类以及AA类的父类，不限于直接父类，
       //规定了泛型的下限
       public static void printCollection3(List<? super AA> c) {
           for (Object object : c) {
               System.out.println(object);
           }
       }

   }

   class AA {
   }

   class BB extends AA {
   }

   class CC extends BB {
   }


   ```

### 13.5 JUnit 单元测试

1. **为什么要**`Junit`

   目前测试方法是怎么进行的，存在什么问题

   * 只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。
   * 无法得到测试的结果报告，需要程序员自己去观察测试是否成功。
   * 无法实现自动化测试。

   比如要测试一个方法或一段代码，这个时候就要去`main`方法里面去调用，测试了这个之后要测试别的，此时还要将原来的代码注释掉，这个时候就可以用`JUnit`，即单独运行一个函数，相当于main方法来运行
2. `JUnit`**基本介绍**

   1. `JUnit`是一个 Java 语言的单元测试框架
   2. 多数Java开发环境都已经集成了JUnit作为单元测试工具
   3. **JUnit优点**

      * JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。
      * Junit可以生成全部方法的测试报告。
      * 单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。

        ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ceb430d72be8443eb8646f2b19984f8c.png#pic_center)
3. `JUnit`**导入及使用方法**

   1. 方法一：`手动导入jar包`

      1. 将JUnit的jar包导入到项目中

         * IDEA通常整合好了Junit框架，一般不需要导入。
         * 如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块

           ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8b8cc0fd4f7140ada1098baf82ba0d44.png#pic_center)
      2. 编写测试方法：该测试方法通常是`公共的无参数无返回值的非静态方法`。
      3. 在测试方法上使用@Test注解：标注该方法是一个测试方法
      4. 在测试方法中完成被测试方法的预期正确性测试。
      5. 选中测试方法，选择“JUnit运行” ，如果测试良好则是绿色；如果测试失败，则是红色

         * 点类中的空白处（非方法体内）或者绿色箭头，可以运行类中的所有测试方法

           ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d7ba2b70a8cc42538dc5b653e126cee5.png#pic_center)
   2. 方法二：`自动导入jar包`

      1. 首先在要测试的方法前面加上`@Test`，刚开始的时候是红的
      2. 之后`Alt + 回车`，便会自动弄啥maven之类的东西，等test不是红色后，左边就会出现运行按钮了

         ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e9201ef0a837468d995a793cd60b7e3f.png#pic_center)

         ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5196cf1dd90c45579168a75f2ce565ba.png#pic_center)
      3. 一般是加`JUnit5.4`或`JUnit5.8.1（因为没有JUnit5.4）`，即`Alt + 回车`后会有选择，选择加哪个
4. **Junit常用注解**

   1. **Junit 4.xxxx版本**

      | 注解 | 说明 |
      | --- | --- |
      | @Test | 测试方法 |
      | @Before | 用来`修饰实例方法`，该方法会在`每一个测试方法执行之前执行一次` |
      | @After | 用来`修饰实例方法`，该方法会在`每一个测试方法执行之后执行一次` |
      | @BeforeClass | 用来`静态修饰方法`，该方法会在`所有测试方法之前只执行一次` |
      | @AfterClass | 用来`静态修饰方法`，该方法会在`所有测试方法之后只执行一次` |

      * 开始执行的方法：初始化资源。
      * 执行完之后的方法：释放资源。
   2. **Junit 5.xxxx版本**

      | 注解 | 说明 |
      | --- | --- |
      | @Test | 测试方法 |
      | @BeforeEach | 用来`修饰实例方法`，该方法会在`每一个测试方法执行之前执行一次` |
      | @AfterEach | 用来`修饰实例方法`，该方法会在`每一个测试方法执行之后执行一次` |
      | @BeforeAll | 用来`静态修饰方法`，该方法会在`所有测试方法之前只执行一次` |
      | @AfterAll | 用来`静态修饰方法`，该方法会在`所有测试方法之后只执行一次` |

      * 开始执行的方法：初始化资源。
      * 执行完之后的方法：释放资源。
   3. **举例说明**

      ```java
      public class TestUserService {

          // 修饰实例方法的
          @Before
          public void before(){
              System.out.println("===before方法执行一次===");
          }

          @After
          public void after(){
              System.out.println("===after方法执行一次===");
          }

          // 修饰静态方法
          @BeforeClass
          public static void beforeClass(){
              System.out.println("===beforeClass方法执行一次===");
          }

          @AfterClass
          public static void afterClass(){
              System.out.println("===afterClass方法执行一次===");
          }


          /**
             测试方法
             注意点：
                  1、必须是公开的。通常是无参数 无返回值的方法
                  2、测试方法必须使用@Test注解标记。
           */
          @Test
          public void testSelectNames(){
          }

      }

      ```



