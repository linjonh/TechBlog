---
layout: post
title: "sylar-webserver4-协程模块"
date: 2025-03-11 11:26:08 +0800
description: "协程模块"
keywords: "【sylar-webserver】4 协程模块"
categories: ['Webserver', 'C']
tags: ['Linux', 'C']
artid: "146171710"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146171710
    alt: "sylar-webserver4-协程模块"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146171710
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146171710
cover: https://bing.ee123.net/img/rand?artid=146171710
image: https://bing.ee123.net/img/rand?artid=146171710
img: https://bing.ee123.net/img/rand?artid=146171710
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【sylar-webserver】4 协程模块
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     知识点
    </h2>
    <h3>
     <a id="1_Fiber_2">
     </a>
     1 Fiber
    </h3>
    <p>
     有栈协程
    </p>
    <pre><code class="prism language-cpp">  <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ucontext_t</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">__ctx</span><span class="token punctuation">(</span>uc_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ucontext_t</span> <span class="token operator">*</span>uc_link<span class="token punctuation">;</span>					<span class="token comment">// uc_link 指向后继上下文</span>
    stack_t uc_stack<span class="token punctuation">;</span>							<span class="token comment">// uc_stack 为该上下文中使用的栈；</span>
    mcontext_t uc_mcontext<span class="token punctuation">;</span>						<span class="token comment">// uc_mcontext 这个结构体依赖于机器且不透明，作用是保存硬件上下文，包括硬件寄存器的值 。</span>
    sigset_t uc_sigmask<span class="token punctuation">;</span>						<span class="token comment">// uc_sigmask 为该上下文中的阻塞信号集合</span>
    <span class="token keyword">struct</span> <span class="token class-name">_libc_fpstate</span> __fpregs_mem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> ucontext_t<span class="token punctuation">;</span>

 <span class="token keyword">typedef</span> <span class="token keyword">struct</span> 
 <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">void</span>  <span class="token operator">*</span>ss_sp<span class="token punctuation">;</span>     <span class="token comment">/* Base address of stack */</span>		<span class="token comment">// 协程的栈空间的起始地址，可以是用户级的栈变量指针，也可以是堆变量指针。</span>
     <span class="token keyword">int</span>    ss_flags<span class="token punctuation">;</span>  <span class="token comment">/* Flags */</span>						<span class="token comment">// flag，在协程使用中设置该值为0。</span>
     size_t ss_size<span class="token punctuation">;</span>   <span class="token comment">/* Number of bytes in stack */</span>	<span class="token comment">// 表示栈空间的大小。</span>
 <span class="token punctuation">}</span> stack_t<span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">// 创建Fiber</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ucontext.h&gt;</span></span>

ucontext_t m_ctx<span class="token punctuation">;</span>

<span class="token comment">// 获取当前上下文，初始化上下文 ucontext_t。</span>
<span class="token comment">// 当 getcontext 之后，如果不指定 uc_link, uc_stack, makecontext。 那么相当于初始化了 一个 主协程 m_ctx</span>
<span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>

m_ctx<span class="token punctuation">.</span>uc_link <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>				<span class="token comment">// 下一个指向的上下文 任务</span>
m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_sp <span class="token operator">=</span> m_stack<span class="token punctuation">;</span>			<span class="token comment">// 指定分配的 堆空间，用于协程函数堆栈</span>
m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_size <span class="token operator">=</span> m_stacksize<span class="token punctuation">;</span>

<span class="token comment">// void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</span>
<span class="token comment">// 函数将ucp 对应的上下文中的指令地址指向 func函数(协程)地址，argc表示func的入参个数，如果入参为空，该值设置为0。如果argc有值，入参为一系列 (int)整型的数据。</span>
<span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Fiber<span class="token double-colon punctuation">::</span>MainFunc<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	

<span class="token comment">// int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);</span>
<span class="token comment">// 保存当前协程的上下文到oucp，然后激活(切换到) ucp所指向的上下文对应的协程。返回值：当调用成功后，swapcontext()不会返回；当调用失败后，返回-1并设置合适的errno。</span>


<span class="token comment">// 当前正在运行的协程，会不停修改的~</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber<span class="token operator">*</span> t_fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">// 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber<span class="token double-colon punctuation">::</span>ptr t_thread_fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>c

<span class="token comment">// 从主协程切换到 m_ctx目标任务协程</span>
<span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>t_thread_fiber<span class="token operator">-&gt;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// m_ctx任务协程 切换回 主协程</span>
<span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>t_thread_fiber<span class="token operator">-&gt;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h2>
     <a id="_57">
     </a>
     设计思路
    </h2>
    <p>
     类的设计，当前还不涉及 调度，所以只是 主协程和任务协程 的相互切换
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 全局静态变量，用于生成协程id</span>
<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">&gt;</span> s_fiber_id<span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 全局静态变量，用于统计当前的协程数</span>
<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">&gt;</span> s_fiber_count<span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 当前正在运行的协程，会不停修改的~</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber<span class="token operator">*</span> t_fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">// 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber<span class="token double-colon punctuation">::</span>ptr t_thread_fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">/**
 * @brief 协程类
 * 
 * 主协程：GetThis() -&gt; Fiber()
 * 
 * 任务协程：
 * Fiber(std::function&lt;void()&gt; cb, size_t stacksize = 0, bool run_in_scheduler = true);
 *  
 * task_fiber-&gt;resume();
 *  
 * task_fiber-&gt;yield();
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Fiber</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Fiber<span class="token operator">&gt;</span> ptr<span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 协程状态
     * @details 在sylar基础上进行了状态简化，只定义三态转换关系，也就是协程要么正在运行(RUNNING)，
     * 要么准备运行(READY)，要么运行结束(TERM)。不区分协程的初始状态，初始即READY。不区分协程是异常结束还是正常结束，
     * 只要结束就是TERM状态。也不区别HOLD状态，协程只要未结束也非运行态，那就是READY状态。
     */</span>
    <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/// 就绪态，刚创建或者yield之后的状态</span>
        READY<span class="token punctuation">,</span>
        <span class="token comment">/// 运行态，resume之后的状态</span>
        RUNNING<span class="token punctuation">,</span>
        <span class="token comment">/// 结束态，协程的回调函数执行完之后为TERM状态</span>
        TERM
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">/**
     * @brief 构造函数
     * @attention 无参构造函数只用于创建线程的第一个协程，也就是线程主函数对应的协程，
     * 这个协程只能由GetThis()方法调用，所以定义成私有方法
     */</span>
    <span class="token function">Fiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">/**
     * @brief 构造函数，用于创建用户协程
     * @param[in] cb 协程入口函数
     * @param[in] stacksize 栈大小
     * @param[in] run_in_scheduler 本协程是否参与调度器调度，默认为true
     */</span>
    <span class="token function">Fiber</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> cb<span class="token punctuation">,</span> size_t stacksize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> run_in_scheduler <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * @brief 析构函数
     */</span>
    <span class="token operator">~</span><span class="token function">Fiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 重置协程状态和入口函数，复用栈空间，不重新创建栈
     * @param[] cb 
     */</span>
    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 将当前协程切到到执行状态
     * @details 当前协程和正在运行的协程进行交换，前者状态变为RUNNING，后者状态变为READY
     * 在这里设置SetThis(this); 交换前确定好 t_fiber 当前执行的协程Fiber*
     */</span>
    <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 当前协程让出执行权
     * @details 当前协程与上次resume时退到后台的协程进行交换，前者状态变为READY，后者状态变为RUNNING
     * 在这里设置SetThis(t_thread_fiber.get()); 交换前确定好 t_fiber 当前执行的协程Fiber*
     */</span>
    <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 获取协程ID
     */</span>
    <span class="token keyword">uint64_t</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_id<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">/**
     * @brief 获取协程状态
     */</span>
    State <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_state<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">/**
     * @brief 设置当前正在运行的协程，即设置线程局部变量t_fiber的值
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SetThis</span><span class="token punctuation">(</span>Fiber <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 返回当前线程正在执行的协程
     * @details 如果当前线程还未创建协程，则创建线程的第一个协程，
     * 且该协程为当前线程的主协程，其他协程都通过这个协程来调度，也就是说，其他协程
     * 结束时,都要切回到主协程，由主协程重新选择新的协程进行resume
     * @attention 线程如果要创建协程，那么应该首先执行一下Fiber::GetThis()操作，以初始化主函数协程
     */</span>
    <span class="token keyword">static</span> Fiber<span class="token double-colon punctuation">::</span>ptr <span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 获取总协程数
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">uint64_t</span> <span class="token function">TotalFibers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 协程入口函数
     * 所有的任务协程 指向这个这里，在这里面执行对应的 m_cb
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MainFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @brief 获取当前协程id
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">uint64_t</span> <span class="token function">GetFiberId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">/// 协程id</span>
    <span class="token keyword">uint64_t</span> m_id        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/// 协程栈大小</span>
    <span class="token keyword">uint32_t</span> m_stacksize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/// 协程状态</span>
    State m_state        <span class="token operator">=</span> READY<span class="token punctuation">;</span>
    <span class="token comment">/// 协程上下文</span>
    ucontext_t m_ctx<span class="token punctuation">;</span>
    <span class="token comment">/// 协程栈地址</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>m_stack <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token comment">/// 协程入口函数</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> m_cb<span class="token punctuation">;</span>
    <span class="token comment">/// 本协程是否参与调度器调度，相当于当前协程，是任务协程。</span>
    <span class="token keyword">bool</span> m_runInScheduler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35323335353732372f:61727469636c652f64657461696c732f313436313731373130" class_="artid" style="display:none">
 </p>
</div>


