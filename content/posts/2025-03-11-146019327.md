---
layout: post
title: "Redis设计与实现-服务器中的数据库"
date: 2025-03-11 11:36:02 +0800
description: "如有侵权，请联系～如有错误，也欢迎批评指正～本篇文章大部分是来自学习《Redis设计与实现》的笔记。"
keywords: "Redis设计与实现-服务器中的数据库"
categories: ['未分类']
tags: ['运维', '缓存', '笔记', '服务器', '数据库', '性能优化', 'Redis']
artid: "146019327"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146019327
    alt: "Redis设计与实现-服务器中的数据库"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146019327
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146019327
cover: https://bing.ee123.net/img/rand?artid=146019327
image: https://bing.ee123.net/img/rand?artid=146019327
img: https://bing.ee123.net/img/rand?artid=146019327
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Redis设计与实现-服务器中的数据库
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <blockquote>
     <p>
      如有侵权，请联系～
      <br/>
      如有错误，也欢迎批评指正～
      <br/>
      本篇文章大部分是来自学习《Redis设计与实现》的笔记
     </p>
    </blockquote>
    <h2>
     <a id="1_redis_7">
     </a>
     1、 redis数据库
    </h2>
    <p>
     Redis默认有16个数据库，可以根据配置设置数据库的数量。数据库存储在数据库数组中，如下redisServer定义中的*db字段。
    </p>
    <p>
     redisServer 是 Redis 服务器的核心数据结构，它包含了 Redis 运行时的所有状态和配置信息。redisServer 是一个全局变量（通常命名为 server），在 Redis 源码中定义为 struct redisServer 类型。它是 Redis 内部管理数据库、客户端连接、命令执行等核心功能的基础。
    </p>
    <pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 配置相关</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>configfile<span class="token punctuation">;</span>          <span class="token comment">// 配置文件路径</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>                  <span class="token comment">// 监听端口</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>bindaddr<span class="token punctuation">;</span>           <span class="token comment">// 绑定地址</span>
    <span class="token keyword">int</span> databases<span class="token punctuation">;</span>             <span class="token comment">// 数据库数量</span>

    <span class="token comment">// 数据库相关</span>
    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>               <span class="token comment">// 数据库数组</span>
    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span>                 <span class="token comment">// 当前数据库索引</span>

    <span class="token comment">// 客户端连接相关</span>
    list <span class="token operator">*</span>clients<span class="token punctuation">;</span>             <span class="token comment">// 客户端列表</span>
    list <span class="token operator">*</span>clients_pending_write<span class="token punctuation">;</span> <span class="token comment">// 等待写入的客户端</span>

    <span class="token comment">// 命令相关</span>
    dict <span class="token operator">*</span>commands<span class="token punctuation">;</span>            <span class="token comment">// 命令字典</span>

    <span class="token comment">// 持久化相关</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>rdb_filename<span class="token punctuation">;</span>        <span class="token comment">// RDB 文件路径</span>
    <span class="token keyword">int</span> aof_state<span class="token punctuation">;</span>             <span class="token comment">// AOF 状态</span>
    sds aof_buf<span class="token punctuation">;</span>               <span class="token comment">// AOF 缓冲区</span>

    <span class="token comment">// 事件循环</span>
    aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">;</span>           <span class="token comment">// 事件循环</span>
    <span class="token keyword">int</span> hz<span class="token punctuation">;</span>                    <span class="token comment">// 定时任务频率</span>

    <span class="token comment">// 复制与集群</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>masterhost<span class="token punctuation">;</span>          <span class="token comment">// 主服务器地址</span>
    <span class="token keyword">int</span> repl_state<span class="token punctuation">;</span>            <span class="token comment">// 复制状态</span>
    <span class="token keyword">int</span> cluster_enabled<span class="token punctuation">;</span>       <span class="token comment">// 是否启用集群</span>

    <span class="token comment">// 统计与监控</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_numcommands<span class="token punctuation">;</span> <span class="token comment">// 命令总数</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> stat_numconnections<span class="token punctuation">;</span> <span class="token comment">// 连接总数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     可以通过select命令进行切换数据库。例如select 2表示切换到2号数据库中。
    </p>
    <p>
     Redis服务端利用client用来管理每个连接到服务器的客户端的状态和行为的核心数据结构。当一个客户端（如 Redis CLI、应用程序或其他 Redis 客户端）通过网络连接到 Redis 服务端时，Redis 服务端会为该连接创建一个 redisClient 实例。这个实例用于跟踪客户端的状态（如连接信息、执行的命令、数据库选择等），并负责处理客户端发送的请求以及向客户端返回响应。
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">client</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 客户端基本信息</span>
    <span class="token class-name">uint64_t</span> id<span class="token punctuation">;</span>               <span class="token comment">// 客户端 ID</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>                    <span class="token comment">// 文件描述符</span>
    sds name<span class="token punctuation">;</span>                  <span class="token comment">// 客户端名称</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>                 <span class="token comment">// 客户端状态标志</span>

    <span class="token comment">// 输入缓冲区</span>
    sds querybuf<span class="token punctuation">;</span>              <span class="token comment">// 输入缓冲区</span>
    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>                  <span class="token comment">// 参数个数</span>
    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>               <span class="token comment">// 参数数组</span>
    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span>  <span class="token comment">// 当前命令</span>

    <span class="token comment">// 输出缓冲区</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>PROTO_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 固定大小的输出缓冲区</span>
    list <span class="token operator">*</span>reply<span class="token punctuation">;</span>               <span class="token comment">// 动态分配的输出缓冲区</span>

    <span class="token comment">// 数据库相关</span>
    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>               <span class="token comment">// 当前数据库</span>
    <span class="token keyword">int</span> dictid<span class="token punctuation">;</span>                <span class="token comment">// 数据库索引</span>

    <span class="token comment">// 复制相关</span>
    <span class="token keyword">int</span> replstate<span class="token punctuation">;</span>             <span class="token comment">// 复制状态</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> reploff<span class="token punctuation">;</span>         <span class="token comment">// 复制偏移量</span>

    <span class="token comment">// 阻塞与超时</span>
    <span class="token class-name">mstime_t</span> bpop_timeout<span class="token punctuation">;</span>     <span class="token comment">// 阻塞超时时间</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> lastinteraction<span class="token punctuation">;</span> <span class="token comment">// 上次交互时间</span>

    <span class="token comment">// 统计信息</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> query_start_time<span class="token punctuation">;</span> <span class="token comment">// 命令开始执行时间</span>
    <span class="token class-name">size_t</span> obuf_mem<span class="token punctuation">;</span>           <span class="token comment">// 输出缓冲区内存占用</span>

    <span class="token comment">// 其他</span>
    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>         <span class="token comment">// 是否已认证</span>
    connection <span class="token operator">*</span>conn<span class="token punctuation">;</span>          <span class="token comment">// 连接对象</span>
    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>     <span class="token comment">// 订阅的频道</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>     <span class="token comment">// 订阅的模式</span>
<span class="token punctuation">}</span> client<span class="token punctuation">;</span>

</code></pre>
    <p>
     client中的db字段就表示当前使用的数据库。select命令其实底层实现就是修改client的db这个字段，这个字段就会指向redisServer db数组的具体某个数据库。
    </p>
    <h2>
     <a id="2__96">
     </a>
     2、 数据库键空间
    </h2>
    <p>
     redis默认有16个数据库，每个数据库都是键值对数据库，每个数据库都是有redisServer中提到的redisDB数据结构存储。
    </p>
    <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 键空间，保存所有的键值对</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>               <span class="token comment">// 主字典，存储键值对</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>            <span class="token comment">// 过期字典，存储键的过期时间。过期key的删除策略：定期删除和惰性删除</span>

    <span class="token comment">// 阻塞操作</span>
    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>      <span class="token comment">// 阻塞键的集合</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>         <span class="token comment">// 已经准备好的阻塞键</span>

    <span class="token comment">// 订阅发布</span>
    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>    <span class="token comment">// 频道订阅关系</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>    <span class="token comment">// 模式订阅关系</span>

    <span class="token comment">// 持久化相关</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                   <span class="token comment">// 数据库 ID</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>        <span class="token comment">// 平均 TTL</span>

    <span class="token comment">// 事务相关</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>       <span class="token comment">// 被监视的键</span>

    <span class="token comment">// Redis Cluster 相关</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span>CLUSTER_SLOTS <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 哈希槽位图</span>
    dict <span class="token operator">*</span>slots_to_keys<span class="token punctuation">;</span>      <span class="token comment">// 哈希槽到键的映射</span>
<span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span>
</code></pre>
    <p>
     这里的键空间就是和我们所见的数据库直接对应。存储的键就是dict中的键，存储的值【字符串、列表、哈希…】就是dict中的值。
    </p>
    <h2>
     <a id="3__127">
     </a>
     3、 过期时间和删除策略
    </h2>
    <p>
     和键过期相关的命令：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        命令
       </th>
       <th>
        描述
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        EXPIRE
       </td>
       <td>
        设置键的过期时间（秒）
       </td>
       <td>
        EXPIRE key seconds
       </td>
      </tr>
      <tr>
       <td>
        PEXPIRE
       </td>
       <td>
        设置键的过期时间（毫秒）
       </td>
       <td>
        PEXPIRE key milliseconds
       </td>
      </tr>
      <tr>
       <td>
        EXPIREAT
       </td>
       <td>
        设置键在指定时间戳（秒）后过期
       </td>
       <td>
        EXPIREAT key timestamp
       </td>
      </tr>
      <tr>
       <td>
        PEXPIREAT
       </td>
       <td>
        设置键在指定时间戳（毫秒）后过期
       </td>
       <td>
        PEXPIREAT key milliseconds-timestamp
       </td>
      </tr>
      <tr>
       <td>
        TTL
       </td>
       <td>
        查看键剩余的过期时间（秒）
       </td>
       <td>
        TTL key
       </td>
      </tr>
      <tr>
       <td>
        PTTL
       </td>
       <td>
        查看键剩余的过期时间（毫秒）
       </td>
       <td>
        PTTL key
       </td>
      </tr>
      <tr>
       <td>
        PERSIST
       </td>
       <td>
        移除键的过期时间，使其永不过期
       </td>
       <td>
        PERSIST key
       </td>
      </tr>
      <tr>
       <td>
        SET … EX
       </td>
       <td>
        设置键值对并指定过期时间（秒）
       </td>
       <td>
        SET key value EX seconds
       </td>
      </tr>
      <tr>
       <td>
        SET … PX
       </td>
       <td>
        设置键值对并指定过期时间（毫秒）
       </td>
       <td>
        SET key value PX milliseconds
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     无论是EXPIRE、PEXPIRE还是EXPIREAT底层都是使用PEXPIREAT命令进行实现的。
    </p>
    <p>
     <strong>
      底层实现：
     </strong>
     <br/>
     通过上面redisDB数据结构就可以看到有个字典属性expires过期字典，所有的键值对都存储到键空间dict上，而所有键的过期时间都存储到过期字典expires中。expires中的key就是指向键空间中的键对象key，而value就是一个long long类型的整数。
    </p>
    <p>
     <strong>
      如何判断一个键是不是过期了呢？
     </strong>
     <br/>
     通过过期字典中某个键的过期时间【键的value值】，如果当前时间大于过期时间证明这个键已经过期。
    </p>
    <p>
     <strong>
      键过期了，怎么删除呢？
     </strong>
     <br/>
     删除策略主要有三种：
    </p>
    <ul>
     <li>
      定时删除：每当给某个键设置过期时间的时候，都会为其创建一个定时器。当到过期时间之后，就会立刻删除。所以这种方式对于内存是友好的，一旦过期就会删除不会占用多余的内存；缺点：浪费CPU资源，尤其是存在大量的过期键，定时器，CPU的浪费更明显。
     </li>
     <li>
      惰性删除：只有用到这个键的时候才会校验这个键值对是不是已经过期了，如果过期则进行删除。这种方式不会浪费占用多余CPU资源，但是会占用大量内存。例如某些键已经过期，但是长期又不访问就导致一直占用内存，可以看成内存泄漏。Redis底层通过expireIfNeed方法进行实现。
     </li>
     <li>
      定期删除：这种策略是定期的去清理一定数量的过期键。综合衡量CPU和内存资源，但是这种方式的难点是执行的频率和时间。Redis底层通过activeExpireCycle方法进行实现。
     </li>
    </ul>
    <p>
     Redis使用惰性删除和定期删除相结合的方式进行过期键的删除。
    </p>
    <h2>
     <a id="4_AOFRDB_158">
     </a>
     4、 AOF、RDB和复制功能对过期键的处理
    </h2>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        生成RDB文件
       </td>
       <td>
        无论是执行save命令、bgsave命令，还是配置项中的save周期，在进行生成RDB文件的时候，过期键都不会保存，会对数据库中的键进行检查
       </td>
      </tr>
      <tr>
       <td>
        加载RDB文件
       </td>
       <td>
        针对于主服务器：在加载RDB文件的时候，会主动过滤掉过期的键值对；从服务器则会将所有的键都加载到数据库内存中，不过等主从同步的时候，从服务器就会删除自身所有数据，加载主服务器的RDB数据
       </td>
      </tr>
      <tr>
       <td>
        AOF文件写入
       </td>
       <td>
        如果数据库中的键过期，不会对AOF文件有任何影响。除非触发定期删除或者惰性删除，在定期删除或者惰性删除的时候，会往AOF文件中写一条del命令
       </td>
      </tr>
      <tr>
       <td>
        AOF重写
       </td>
       <td>
        AOF重写和生成RDB文件一样，不会对过期键进行保存
       </td>
      </tr>
      <tr>
       <td>
        复制
       </td>
       <td>
        主服务器删除一个过期键之后，会显式地向所有的从服务器发送一个DEL命令；从服务器并不会主动的删除过期键，只有收到主服务器的DEL命令才会删除，这么做为了主从一致性。如果一个键过期了，从服务器没有收到主服务器的DEL命令，那么从服务器仍然存在这个键值对，这个时候当从服务收到客户端读get命令，从服务器会将这个键对应的值返回出去。【
        <strong>
         如果Redis集群配置读写分离，需要注意这点
        </strong>
        】
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="5__168">
     </a>
     5、 通知
    </h2>
    <p>
     这里的通知与发布订阅【客户端发布到频道一个值，服务端就会向订阅这个频道的客户端发送这个值，即订阅者就会收到这个值（客户端和服务端长连接）】不同。
     <br/>
     通知分为键空间通知【某个键执行了哪些命令】和键事件通知【某个命令被哪些键执行了】。用于控制通知的参数：notify-keyspace-events
     <br/>
     notify-keyspace-events的所有字符取值：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        字符
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         K
        </code>
       </td>
       <td>
        启用键空间通知（Keyspace notifications）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         E
        </code>
       </td>
       <td>
        启用键事件通知（Keyevent notifications）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         g
        </code>
       </td>
       <td>
        通用命令（如
        <code>
         DEL
        </code>
        、
        <code>
         EXPIRE
        </code>
        、
        <code>
         RENAME
        </code>
        等）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         s
        </code>
       </td>
       <td>
        字符串命令（如
        <code>
         SET
        </code>
        、
        <code>
         GET
        </code>
        、
        <code>
         INCR
        </code>
        等）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         l
        </code>
       </td>
       <td>
        列表命令（如
        <code>
         LPUSH
        </code>
        、
        <code>
         LPOP
        </code>
        等）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         h
        </code>
       </td>
       <td>
        哈希命令（如
        <code>
         HSET
        </code>
        、
        <code>
         HGET
        </code>
        等）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         z
        </code>
       </td>
       <td>
        有序集合命令（如
        <code>
         ZADD
        </code>
        、
        <code>
         ZREM
        </code>
        等）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         x
        </code>
       </td>
       <td>
        过期事件（当键因过期而被删除时触发）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         e
        </code>
       </td>
       <td>
        驱逐事件（当键因内存不足而被驱逐时触发）。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         A
        </code>
       </td>
       <td>
        启用所有事件（相当于
        <code>
         g$lshzxe
        </code>
        的组合）。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     常见组合：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        组合
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         KEA
        </code>
       </td>
       <td>
        启用所有键空间和键事件通知。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Ex
        </code>
       </td>
       <td>
        仅启用键事件通知中的过期事件。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Kg
        </code>
       </td>
       <td>
        仅启用键空间通知中的通用命令事件。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         Ksx
        </code>
       </td>
       <td>
        启用键空间通知中的字符串命令和过期事件。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     通知功能是通过 notifyKeySpaceEvent函数实现的，每个命令执行成功都会执行这个方法。这个方法的底层其实是使用的发布订阅功能。
     <br/>
     <strong>
      键空间通知：
     </strong>
     <br/>
     频道格式：_
     <em>
      keyspace@&lt;db&gt;_
     </em>
     :&lt;key&gt;
     <br/>
     消息内容：操作类型（如 set、del、expire 等）。
     <br/>
     <strong>
      键事件通知：
     </strong>
     <br/>
     频道格式：_
     <em>
      keyevent@&lt;db&gt;_
     </em>
     :&lt;event&gt;
     <br/>
     消息内容：键名。
    </p>
    <p>
     键空间和键事件通知流程图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/416b51854ebb411a948e4723914ffde2.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35303134393834372f:61727469636c652f64657461696c732f313436303139333237" class_="artid" style="display:none">
 </p>
</div>


