---
layout: post
title: "python-pickle库"
date: 2025-03-11 20:07:53 +0800
description: "`pickle` 是 Python 标准库中的一个模块，它可以将 Python 对象（如列表、字典、类实例等）转换为字节流，这个过程称为“序列化”；反之，也可以将字节流转换回 Python 对象，这个过程称为“反序列化”。"
keywords: "python---pickle库"
categories: ['Python']
tags: ['网络', 'Python', 'Linux']
artid: "146187898"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146187898
    alt: "python-pickle库"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146187898
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146187898
cover: https://bing.ee123.net/img/rand?artid=146187898
image: https://bing.ee123.net/img/rand?artid=146187898
img: https://bing.ee123.net/img/rand?artid=146187898
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     python---pickle库
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="pickle_0">
     </a>
     pickle库
    </h2>
    <p>
     <code>
      pickle
     </code>
     是 Python 标准库中的一个模块，它可以将 Python 对象（如列表、字典、类实例等）转换为字节流，这个过程称为“序列化”；反之，也可以将字节流转换回 Python 对象，这个过程称为“反序列化”。：
    </p>
    <h4>
     <a id="1__pickle__3">
     </a>
     1. 导入
     <code>
      pickle
     </code>
     模块
    </h4>
    <p>
     在使用
     <code>
      pickle
     </code>
     模块之前，需要先导入它：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle
</code></pre>
    <h4>
     <a id="2_pickledump__pickledumps_9">
     </a>
     2. 序列化（
     <code>
      pickle.dump()
     </code>
     和
     <code>
      pickle.dumps()
     </code>
     ）
    </h4>
    <h5>
     <a id="21_pickledumps_11">
     </a>
     2.1
     <code>
      pickle.dumps()
     </code>
    </h5>
    <p>
     <code>
      pickle.dumps()
     </code>
     函数用于将 Python 对象序列化为字节流，返回一个字节对象。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token number">25</span><span class="token punctuation">}</span>
<span class="token comment"># 序列化对象</span>
serialized_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>serialized_data<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># &lt;class 'bytes'&gt;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>serialized_data<span class="token punctuation">)</span>
</code></pre>
    <h5>
     <a id="22_pickledump_23">
     </a>
     2.2
     <code>
      pickle.dump()
     </code>
    </h5>
    <p>
     <code>
      pickle.dump()
     </code>
     函数用于将 Python 对象序列化并直接写入文件对象。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment"># 打开一个文件以二进制写入模式</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.pickle'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    <span class="token comment"># 将对象序列化并写入文件</span>
    pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="3_pickleload__pickleloads_35">
     </a>
     3. 反序列化（
     <code>
      pickle.load()
     </code>
     和
     <code>
      pickle.loads()
     </code>
     ）
    </h4>
    <h5>
     <a id="31_pickleloads_37">
     </a>
     3.1
     <code>
      pickle.loads()
     </code>
    </h5>
    <p>
     <code>
      pickle.loads()
     </code>
     函数用于将字节流反序列化为 Python 对象。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">}</span>
serialized_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token comment"># 反序列化字节流</span>
deserialized_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>serialized_data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>deserialized_data<span class="token punctuation">)</span>  <span class="token comment"># {'name': 'Bob', 'age': 30}</span>
</code></pre>
    <h5>
     <a id="32_pickleload_49">
     </a>
     3.2
     <code>
      pickle.load()
     </code>
    </h5>
    <p>
     <code>
      pickle.load()
     </code>
     函数用于从文件对象中读取字节流并反序列化为 Python 对象。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

<span class="token comment"># 打开一个文件以二进制读取模式</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.pickle'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    <span class="token comment"># 从文件中读取并反序列化对象</span>
    loaded_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>loaded_data<span class="token punctuation">)</span>  <span class="token comment"># [1, 2, 3, 4, 5]</span>
</code></pre>
    <h4>
     <a id="4__61">
     </a>
     4. 支持的对象类型
    </h4>
    <p>
     <code>
      pickle
     </code>
     可以处理大多数 Python 内置对象类型，包括：
    </p>
    <ul>
     <li>
      布尔值、整数、浮点数、复数等基本数据类型。
     </li>
     <li>
      字符串、字节、字节数组。
     </li>
     <li>
      列表、元组、集合、字典等容器类型。
     </li>
     <li>
      函数（仅限于全局作用域内定义的函数）。
     </li>
     <li>
      类（仅限于全局作用域内定义的类）和类实例。
     </li>
    </ul>
    <h4>
     <a id="5__69">
     </a>
     5. 不支持的对象类型
    </h4>
    <ul>
     <li>
      生成器、迭代器、文件对象等。
     </li>
     <li>
      部分内置对象（如
      <code>
       open()
      </code>
      返回的文件对象、
      <code>
       sockets
      </code>
      对象等）。
     </li>
    </ul>
    <h4>
     <a id="6__73">
     </a>
     6. 协议版本
    </h4>
    <p>
     <code>
      pickle
     </code>
     支持多个协议版本，不同的协议版本在性能和兼容性上有所不同。可以通过
     <code>
      pickle.HIGHEST_PROTOCOL
     </code>
     获取当前 Python 版本支持的最高协议版本，也可以在
     <code>
      dump()
     </code>
     和
     <code>
      dumps()
     </code>
     函数中指定协议版本。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'key'</span><span class="token punctuation">:</span> <span class="token string">'value'</span><span class="token punctuation">}</span>
<span class="token comment"># 使用最高协议版本进行序列化</span>
serialized_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">,</span> protocol<span class="token operator">=</span>pickle<span class="token punctuation">.</span>HIGHEST_PROTOCOL<span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="7__83">
     </a>
     7. 安全性问题
    </h4>
    <p>
     <code>
      pickle
     </code>
     反序列化操作存在安全风险，因为它可以执行任意代码。如果从不可信的源接收
     <code>
      pickle
     </code>
     数据，可能会导致代码注入攻击。因此，在反序列化数据时，要确保数据来源是可信的。
    </p>
    <h4>
     <a id="8__json__86">
     </a>
     8. 与
     <code>
      json
     </code>
     模块的比较
    </h4>
    <ul>
     <li>
      <strong>
       数据格式
      </strong>
      ：
      <code>
       pickle
      </code>
      序列化后的数据是二进制格式，而
      <code>
       json
      </code>
      序列化后的数据是文本格式。
     </li>
     <li>
      <strong>
       支持的对象类型
      </strong>
      ：
      <code>
       pickle
      </code>
      可以处理更广泛的 Python 对象类型，而
      <code>
       json
      </code>
      只能处理基本数据类型和部分容器类型。
     </li>
     <li>
      <strong>
       安全性
      </strong>
      ：
      <code>
       json
      </code>
      反序列化相对安全，因为它只能处理纯数据，而
      <code>
       pickle
      </code>
      反序列化存在安全风险。
     </li>
    </ul>
    <h4>
     <a id="9__91">
     </a>
     9. 示例：序列化和反序列化自定义类实例
    </h4>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age

    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"Person(name=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">, age=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>age<span class="token punctuation">}</span></span><span class="token string">)"</span></span>

<span class="token comment"># 创建一个 Person 类的实例</span>
person <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token string">'Charlie'</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">)</span>

<span class="token comment"># 序列化实例</span>
serialized_person <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>person<span class="token punctuation">)</span>

<span class="token comment"># 反序列化实例</span>
deserialized_person <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>serialized_person<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>deserialized_person<span class="token punctuation">)</span>  <span class="token comment"># Person(name=Charlie, age=35)</span>
</code></pre>
    <h2>
     <a id="_116">
     </a>
     序列化
    </h2>
    <p>
     序列化是将对象的状态信息转换为可以存储或传输的形式（如字节序列、文本等）的过程。在不同的应用场景中，序列化发挥着重要的作用，以下从几个方面详细介绍序列化的作用：
    </p>
    <h4>
     <a id="1__119">
     </a>
     1. 数据持久化
    </h4>
    <ul>
     <li>
      <strong>
       存储对象到磁盘
      </strong>
      ：在许多应用程序中，需要将程序运行过程中的对象保存到磁盘上，以便在程序下次启动时能够恢复这些对象的状态。例如，一个游戏程序可能需要保存玩家的游戏进度，包括玩家的角色信息、关卡进度、道具列表等。通过序列化，可以将这些对象转换为字节流，然后存储到文件中。下次游戏启动时，再从文件中读取字节流并反序列化，恢复玩家的游戏进度。
     </li>
    </ul>
    <pre><code class="prism language-python"><span class="token keyword">import</span> pickle

<span class="token keyword">class</span> <span class="token class-name">Player</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>level <span class="token operator">=</span> level

<span class="token comment"># 创建一个玩家对象</span>
player <span class="token operator">=</span> Player<span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>

<span class="token comment"># 将玩家对象序列化并保存到文件</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'player_data.pickle'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>player<span class="token punctuation">,</span> <span class="token builtin">file</span><span class="token punctuation">)</span>

<span class="token comment"># 下次启动程序时，从文件中读取并反序列化对象</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'player_data.pickle'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
    loaded_player <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Player name: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>loaded_player<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">, Level: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>loaded_player<span class="token punctuation">.</span>level<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre>
    <ul>
     <li>
      <strong>
       数据库存储
      </strong>
      ：在数据库中存储复杂的对象时，序列化也非常有用。有些数据库（如 NoSQL 数据库）可以直接存储二进制数据，通过将对象序列化后存储到数据库中，可以方便地保存和检索对象信息。
     </li>
    </ul>
    <h4>
     <a id="2__143">
     </a>
     2. 数据传输
    </h4>
    <ul>
     <li>
      <strong>
       网络通信
      </strong>
      ：在网络编程中，不同的计算机或进程之间需要进行数据交换。由于网络传输的数据必须是二进制形式，因此需要将对象序列化为字节流后才能在网络上传输。例如，在客户端 - 服务器架构中，客户端可能需要将用户的请求对象（如登录请求、查询请求等）序列化后发送给服务器，服务器接收到字节流后再进行反序列化，解析出请求信息并进行相应的处理。常见的网络协议如 HTTP、TCP 等都可以传输序列化后的数据。
     </li>
    </ul>
    <pre><code class="prism language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> pickle

<span class="token comment"># 服务器端</span>
server_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Waiting for a connection..."</span><span class="token punctuation">)</span>
conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Connected by </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>addr<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

<span class="token comment"># 接收序列化的数据</span>
data <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token comment"># 反序列化数据</span>
received_object <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Received object: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>received_object<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 客户端</span>
client_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 要发送的对象</span>
data_to_send <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'message'</span><span class="token punctuation">:</span> <span class="token string">'Hello, server!'</span><span class="token punctuation">}</span>
<span class="token comment"># 序列化对象</span>
serialized_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data_to_send<span class="token punctuation">)</span>
<span class="token comment"># 发送序列化的数据</span>
client_socket<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>serialized_data<span class="token punctuation">)</span>

client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <ul>
     <li>
      <strong>
       进程间通信（IPC）
      </strong>
      ：在多进程编程中，不同的进程之间需要进行数据交换。序列化可以将对象转换为可以在进程间传输的格式，从而实现进程间的通信。例如，在 Python 的
      <code>
       multiprocessing
      </code>
      模块中，进程之间可以通过管道（
      <code>
       Pipe
      </code>
      ）、队列（
      <code>
       Queue
      </code>
      ）等方式进行通信，这些通信机制内部会使用序列化和反序列化来处理对象的传输。
     </li>
    </ul>
    <h4>
     <a id="3__181">
     </a>
     3. 数据共享与协作
    </h4>
    <ul>
     <li>
      <strong>
       分布式系统
      </strong>
      ：在分布式系统中，不同的节点（计算机或服务器）之间需要共享数据和协同工作。序列化可以将对象在不同节点之间进行传输和共享，使得各个节点能够处理和操作相同的数据。例如，在一个分布式计算系统中，主节点可以将任务对象序列化后分发给各个工作节点，工作节点接收到任务对象后进行反序列化，然后执行相应的任务。
     </li>
     <li>
      <strong>
       跨语言交互
      </strong>
      ：在一些跨语言的应用场景中，不同的编程语言可能需要共享数据。通过选择一种通用的序列化格式（如 JSON、XML 等），可以实现不同语言之间的数据交互。例如，一个 Python 程序可以将数据序列化为 JSON 格式，然后将 JSON 数据发送给一个 Java 程序，Java 程序再将 JSON 数据反序列化后进行处理。
     </li>
    </ul>
    <h4>
     <a id="4__185">
     </a>
     4. 缓存和优化
    </h4>
    <ul>
     <li>
      <strong>
       缓存机制
      </strong>
      ：在一些应用程序中，为了提高性能，会使用缓存来存储经常使用的数据。通过将对象序列化后存储在缓存中，可以减少对象的创建和初始化时间。当需要使用这些数据时，直接从缓存中读取并反序列化，避免了重复计算和数据库查询。例如，在 Web 应用程序中，可以使用缓存（如 Redis）来存储用户的会话信息，将用户会话对象序列化后存储在 Redis 中，下次用户访问时直接从 Redis 中读取并反序列化，提高响应速度。
     </li>
     <li>
      <strong>
       数据压缩
      </strong>
      ：序列化过程中可以对数据进行压缩，减少数据的存储空间和传输带宽。例如，一些序列化库（如 Protocol Buffers）支持数据压缩功能，通过将对象序列化并压缩后存储或传输，可以节省大量的资源。
     </li>
    </ul>
    <p>
     综上所述，序列化在数据持久化、传输、共享和缓存等方面都有着重要的作用，是现代软件开发中不可或缺的技术之一。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303037393634322f:61727469636c652f64657461696c732f313436313837383938" class_="artid" style="display:none">
 </p>
</div>


