---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f78755f77656e6d696e672f:61727469636c652f64657461696c732f313436313739313035"
layout: post
title: "apollo3录音到wav播放解决方法"
date: 2025-03-11 15:06:02 +08:00
description: "ePDMClkSpeed = AM_HAL_PDM_CLK_1_5MHZ,    //PDM采样频率，1.5M转换后是16K音频频率。.eClkDivider = AM_HAL_PDM_MCLKDIV_1,    //主时钟分频设置为1，不分频。.ePDMClkSource = AM_HAL_PDM_INTERNAL_CLK,    //使用内部时钟源。.ePCMChannels = AM_HAL_PDM_CHANNEL_LEFT,    //录音声道选择。在PCM音频（BIN）文件加上WAV文件头，"
keywords: "apollo3录音到wav播放解决方法"
categories: ['未分类']
tags: ['驱动开发', '音视频', '物联网', '嵌入式硬件', '单片机']
artid: "146179105"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146179105
    alt: "apollo3录音到wav播放解决方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146179105
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146179105
cover: https://bing.ee123.net/img/rand?artid=146179105
image: https://bing.ee123.net/img/rand?artid=146179105
img: https://bing.ee123.net/img/rand?artid=146179105
---

# apollo3录音到wav播放解决方法

SDK DEMO项目:ap3bp\_evb\_vos\_pcm\_recorder\_20210901

pcm\_recorder.c

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// Options
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
#define PRINT\_UART          0
  
#define USE\_OPUS            1

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// Cache configuration
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
const am\_hal\_cachectrl\_config\_t am\_hal\_cachectrl\_benchmark =
  
{
  
.bLRU                       = 0,
  
.eDescript                  = AM\_HAL\_CACHECTRL\_DESCR\_1WAY\_128B\_512E,
  
.eMode                      = AM\_HAL\_CACHECTRL\_CONFIG\_MODE\_INSTR,
  
};

#define RTT\_LOGGER\_BUFFER\_LENGTH\_BYTE   (128\*1024)
  
uint8\_t ui8RttLoggerBuffer[RTT\_LOGGER\_BUFFER\_LENGTH\_BYTE];

#define AUDIO\_FRAME\_MS                  20

#define AUDIO\_FRAME\_SIZE\_SAMPLES        ((16000)/(1000/AUDIO\_FRAME\_MS))
  
#define AUDIO\_FRAME\_SIZE\_MONO\_BYTES     (AUDIO\_FRAME\_SIZE\_SAMPLES\*2)
  
#define AUDIO\_FRAME\_SIZE\_STEREO\_BYTES   (AUDIO\_FRAME\_SIZE\_SAMPLES\*4)

#define ENCODED\_HEADER\_SIZE\_BYITES      8
  
#define ENCODED\_COMPRESS\_RATE           8
  
#define ENCODED\_FRAME\_SIZE\_BYTES        ((AUDIO\_FRAME\_SIZE\_SAMPLES\*2/ENCODED\_COMPRESS\_RATE) + ENCODED\_HEADER\_SIZE\_BYITES)

uint8\_t g\_opusAudioInputBuffer[AUDIO\_FRAME\_SIZE\_MONO\_BYTES]; // 20ms mono raw audio frame
  
bool g\_opusInputReadyFlag = false;

#if USE\_OPUS
  
uint8\_t g\_opusAudioOutputBuffer[ENCODED\_FRAME\_SIZE\_BYTES]; // encoded audio frame, with header
  
uint16\_t g\_opusInputIndex = 0;
  
#endif // #if USE\_OPUS

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// PDM configuration information.
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
void \*PDMHandle = NULL;

#define PDM\_CLK                     12
  
#define PDM\_CLK\_PIN\_CFG             AM\_HAL\_PIN\_12\_PDMCLK
  
#define PDM\_DATA                    11
  
#define PDM\_DATA\_PIN\_CFG            AM\_HAL\_PIN\_11\_PDMDATA

am\_hal\_pdm\_config\_t g\_sPdmConfig =
  
{
  
.eClkDivider = AM\_HAL\_PDM\_MCLKDIV\_1,    //主时钟分频设置为1，不分频
  
.eLeftGain = AM\_HAL\_PDM\_GAIN\_P105DB,    //左声道增益延迟设置为105dB
  
.eRightGain = AM\_HAL\_PDM\_GAIN\_P105DB,
  
.ui32DecimationRate = 48,     // CLK 1.5 Mhz  //降频采样倍数
  
.bHighPassEnable = 0, //禁用高通滤波器
  
.ui32HighPassCutoff = 0xB,
  
.ePDMClkSpeed = AM\_HAL\_PDM\_CLK\_1\_5MHZ,    //PDM采样频率，1.5M转换后是16K音频频率
  
.bInvertI2SBCLK = 0,
  
.ePDMClkSource = AM\_HAL\_PDM\_INTERNAL\_CLK,    //使用内部时钟源
  
.bPDMSampleDelay = 0,    //PDM采样延迟
  
.bDataPacking = 1,    //启用数据换包
  
.ePCMChannels = AM\_HAL\_PDM\_CHANNEL\_LEFT,    //录音声道选择
  
.bLRSwap = 0,    //不交换左右声道
  
.bSoftMute = 0,    //禁用软静音
  
};

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// Start a transaction to get some number of bytes from the PDM interface.
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
uint32\_t g\_ui32PDMDataBuffer[AUDIO\_FRAME\_SIZE\_MONO\_BYTES/4];
  
void
  
pdm\_trigger\_dma(void)
  
{
  
//
  
// Configure DMA and target address.
  
//
  
am\_hal\_pdm\_transfer\_t sTransfer;
  
sTransfer.ui32TargetAddr = (uint32\_t ) g\_ui32PDMDataBuffer;
  
sTransfer.ui32TotalCount = (AUDIO\_FRAME\_SIZE\_MONO\_BYTES);

//
  
// Start the data transfer.
  
//
  
am\_hal\_pdm\_dma\_start(PDMHandle, &sTransfer);
  
}

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// Structure for handling PDM register state information for power up/down
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
typedef struct
  
{
  
bool bValid;
  
}
  
am\_hal\_pdm\_register\_state\_t;

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// Structure for handling PDM HAL state information.
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
typedef struct
  
{
  
am\_hal\_handle\_prefix\_t prefix;
  
am\_hal\_pdm\_register\_state\_t sRegState;
  
uint32\_t ui32Module;
  
}
  
am\_hal\_pdm\_state\_t;

void am\_app\_KWD\_pdm\_dma\_disable(void \*pHandle)
  
{
  
am\_hal\_pdm\_state\_t \*pState = (am\_hal\_pdm\_state\_t \*) pHandle;
  
uint32\_t ui32Module = pState->ui32Module;

//
  
// Disable DMA
  
//
  
PDMn(ui32Module)->DMACFG\_b.DMAEN = PDM\_DMACFG\_DMAEN\_DIS;

}

//-----------------------------------------------------------------------------
  
// METHOD:  PDM\_Init
  
// PURPOSE: PDM module configuration
  
//-----------------------------------------------------------------------------
  
void PDMInit(void)
  
{

if (PDMHandle != NULL)
  
return;
  
//
  
// Initialize, power-up, and configure the PDM.
  
//
  
am\_hal\_pdm\_initialize(0, &PDMHandle);
  
//
  
// Configure the necessary pins.
  
//
  
am\_hal\_gpio\_pincfg\_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

sPinCfg.uFuncSel = PDM\_CLK\_PIN\_CFG;
  
am\_hal\_gpio\_pinconfig(PDM\_CLK, sPinCfg);

sPinCfg.uFuncSel = PDM\_DATA\_PIN\_CFG;
  
am\_hal\_gpio\_pinconfig(PDM\_DATA, sPinCfg);

am\_hal\_pdm\_power\_control(PDMHandle, AM\_HAL\_PDM\_POWER\_ON, false);
  
am\_hal\_pdm\_configure(PDMHandle, &g\_sPdmConfig);
  
am\_hal\_pdm\_fifo\_flush(PDMHandle);

//
  
// Configure and enable PDM interrupts (set up to trigger on DMA
  
// completion).
  
//
  
am\_hal\_pdm\_interrupt\_enable(PDMHandle, (AM\_HAL\_PDM\_INT\_DERR
  
| AM\_HAL\_PDM\_INT\_DCMP
  
| AM\_HAL\_PDM\_INT\_UNDFL
  
| AM\_HAL\_PDM\_INT\_OVF));
  
NVIC\_EnableIRQ(PDM\_IRQn);
  
}

void PDMDeInit()
  
{
  
if(PDMHandle == NULL)
  
return;

am\_hal\_pdm\_interrupt\_clear(PDMHandle, (AM\_HAL\_PDM\_INT\_DERR
  
| AM\_HAL\_PDM\_INT\_DCMP
  
| AM\_HAL\_PDM\_INT\_UNDFL
  
| AM\_HAL\_PDM\_INT\_OVF));

am\_hal\_pdm\_interrupt\_disable(PDMHandle, (AM\_HAL\_PDM\_INT\_DERR
  
| AM\_HAL\_PDM\_INT\_DCMP
  
| AM\_HAL\_PDM\_INT\_UNDFL
  
| AM\_HAL\_PDM\_INT\_OVF));

NVIC\_DisableIRQ(PDM\_IRQn);

am\_hal\_gpio\_pinconfig(PDM\_CLK, g\_AM\_HAL\_GPIO\_DISABLE);
  
am\_hal\_gpio\_pinconfig(PDM\_DATA, g\_AM\_HAL\_GPIO\_DISABLE);

// This was a workaround code to measure power consumption. Need to review!!
  
am\_app\_KWD\_pdm\_dma\_disable(PDMHandle);

am\_hal\_pdm\_disable(PDMHandle);
  
am\_hal\_pdm\_power\_control(PDMHandle, AM\_HAL\_PDM\_POWER\_OFF, false);

am\_hal\_pdm\_deinitialize(PDMHandle);
  
PDMHandle = NULL;

}

void am\_pdm0\_isr(void)
  
{
  
uint32\_t ui32Status;

//
  
// Read the interrupt status.
  
//
  
am\_hal\_pdm\_interrupt\_status\_get(PDMHandle, &ui32Status, true);
  
am\_hal\_pdm\_interrupt\_clear(PDMHandle, ui32Status);

//
  
// Once our DMA transaction completes, we will disable the PDM and send a
  
// flag back down to the main routine. Disabling the PDM is only necessary
  
// because this example only implemented a single buffer for storing FFT
  
// data. More complex programs could use a system of multiple buffers to
  
// allow the CPU to run the FFT in one buffer while the DMA pulls PCM data
  
// into another buffer.
  
//
  
if (ui32Status & AM\_HAL\_PDM\_INT\_DCMP)
  
{
  
// trigger next traction
  
PDMn(0)->DMATOTCOUNT = AUDIO\_FRAME\_SIZE\_MONO\_BYTES;  // FIFO unit in bytes

amu2s\_send(Amu2s\_pcm, g\_ui32PDMDataBuffer, AMU2S\_PCM\_BYTES);

#if USE\_OPUS
  
//
  
// move data to opus buffer
  
//
  
memmove(g\_opusAudioInputBuffer, g\_ui32PDMDataBuffer,AUDIO\_FRAME\_SIZE\_MONO\_BYTES);
  
g\_opusInputReadyFlag = true;
  
#endif // #if USE\_OPUS
  
}
  
else if(ui32Status & (AM\_HAL\_PDM\_INT\_UNDFL | AM\_HAL\_PDM\_INT\_OVF))
  
{
  
am\_hal\_pdm\_fifo\_flush(PDMHandle);
  
}

}

#define AM\_CRITICAL\_BEGIN\_VOS                                               \
  
if ( 1 )                                                                \
  
{                                                                       \
  
volatile uint32\_t ui32Primask\_04172010;                             \
  
ui32Primask\_04172010 = am\_hal\_interrupt\_master\_disable();

#define AM\_CRITICAL\_END\_VOS                                                 \
  
am\_hal\_interrupt\_master\_set(ui32Primask\_04172010);                  \
  
}

//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
//
  
// Main Function.
  
//
  
//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
  
int
  
main(void)
  
{
  
//
  
// Set the clock frequency.
  
//
  
am\_hal\_clkgen\_control(AM\_HAL\_CLKGEN\_CONTROL\_SYSCLK\_MAX, 0);

//
  
// Set the default cache configuration
  
//
  
am\_hal\_cachectrl\_config(&am\_hal\_cachectrl\_benchmark);
  
am\_hal\_cachectrl\_enable();

//
  
// Configure the board for low power operation.
  
//
  
am\_bsp\_low\_power\_init();

#if (PRINT\_UART == 1)
  
am\_bsp\_uart\_printf\_enable();

//
  
// Clear the terminal and print the banner.
  
//
  
am\_util\_stdio\_terminal\_clear();
  
am\_util\_stdio\_printf("Ambiq Micro 'while' example.\n\n");

//
  
// Brief description
  
//
  
am\_util\_stdio\_printf("Used for measuring power in an infinite while loop.\n");

//
  
// Print the compiler version.
  
//
  
am\_util\_stdio\_printf("App Compiler:    %s\n", COMPILER\_VERSION);
  
am\_util\_stdio\_printf("HAL Compiler:    %s\n", g\_ui8HALcompiler);
  
am\_util\_stdio\_printf("HAL SDK version: %d.%d.%d\n",
  
g\_ui32HALversion.s.Major,
  
g\_ui32HALversion.s.Minor,
  
g\_ui32HALversion.s.Revision);
  
am\_util\_stdio\_printf("HAL compiled with %s-style registers\n",
  
g\_ui32HALversion.s.bAMREGS ? "AM\_REG" : "CMSIS");

#endif // PRINT\_UART

amu2s\_init();
  
PDMInit();
  
am\_hal\_pdm\_enable(PDMHandle);
  
pdm\_trigger\_dma();

SEGGER\_RTT\_ConfigUpBuffer(1, "TestDataLogger", ui8RttLoggerBuffer, RTT\_LOGGER\_BUFFER\_LENGTH\_BYTE, SEGGER\_RTT\_MODE\_NO\_BLOCK\_SKIP);

#if USE\_OPUS
  
/\* initialize the audio encoder \*/
  
audio\_enc\_init(true);       // true for with header
  
#endif // #if USE\_OPUS

// master interrupt enable
  
am\_hal\_interrupt\_master\_enable();

while(1)
  
{

#if USE\_OPUS
  
if(g\_opusInputReadyFlag == true)
  
{
  
g\_opusInputReadyFlag = false;
  
// data ready to encode, run encoder

uint32\_t encoded\_bytes = audio\_enc\_encode\_frame((short\*)g\_opusAudioInputBuffer, AUDIO\_FRAME\_SIZE\_SAMPLES, (unsigned char\*)g\_opusAudioOutputBuffer);

// send to RTT
  
SEGGER\_RTT\_Write(1, (uint8\_t\*)g\_opusAudioOutputBuffer, encoded\_bytes);

// send to AmU2S
  
amu2s\_send(Amu2s\_opus, g\_opusAudioOutputBuffer, AMU2S\_OPUS\_BYTES);

#endif // #if USE\_OPUS
  
}
  
}

项目编译，在开发板上运行，打开官方配备的工具，抓取录音数据，如下图：
![](https://i-blog.csdnimg.cn/direct/baf0a89eaa514aaab3b0355713a8ccf1.png)

按任意键停止抓取，即可抓取到非标准的PCM音频，如下图：

![](https://i-blog.csdnimg.cn/direct/744357fcae334bb99984b2f11ffcf813.png)

##### **使用提供的 Python 脚本**

运行以下命令解码为 PCM 文件：

python ftdi\_bin\_decoder.py decoder input.bin --output=audio --format=raw

生成文件：
`audio_pcm`
（原始 PCM 数据）

执行成功，同时生成标准的PCM数据BIN文件和OPUS压缩的BIN文件，如下图：

![](https://i-blog.csdnimg.cn/direct/9f906bacbfd64c3f8046090d737a73ac.png)

如果出现以下错误提示
  
import pandas as pd
  
ModuleNotFoundError: No module named 'pandas'
  
遇到 ModuleNotFoundError: No module named 'pandas' 错误，说明你的 Python 环境中缺少 pandas 库

通过 pip 直接安装：pip install pandas

转换为 WAV 播放命令 ：
  
python bin\_to\_wav.py mono -i audio\_pcm
  
在PCM音频（BIN）文件加上WAV文件头，

执行成功后，生成可播放音频文件，如下图：

![](https://i-blog.csdnimg.cn/direct/fbe9dd1f1a1a4feab061ef7a14c5d7ca.png)

如果出现以下错误提示：
  
import soundfile as sf
  
ModuleNotFoundError: No module named 'soundfile'

错误 ModuleNotFoundError: No module named 'soundfile' 表明 Python 环境中缺少 soundfile 库。该库用于读写音频文件（如 WAV 格式），是 bin\_to\_wav.py 脚本的依赖项。
  
解决方法
  
安装 soundfile 库
  
通过 pip 直接安装：pip install soundfile

bin\_to\_wav.py这个python脚本重要补充说明

1. **硬件适配特性**
   ：

   * **声道交换**
     ：通过
     `--swap 1`
     参数修正 Apollo PDM 模块的左右声道反接问题
   * **位深度处理**
     ：假设输入为 16-bit PCM，通过
     `/32768`
     实现标准化
2. **音频处理流程**
   ： 原始PCM --> 解析为整数 --> 声道分离 --> 浮点归一化 --> 峰值归一化 --> 输出WAV