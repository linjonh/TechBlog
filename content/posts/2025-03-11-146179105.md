---
layout: post
title: "apollo3录音到wav播放解决方法"
date: 2025-03-11 15:06:02 +0800
description: "ePDMClkSpeed = AM_HAL_PDM_CLK_1_5MHZ,    //PDM采样频率，1.5M转换后是16K音频频率。.eClkDivider = AM_HAL_PDM_MCLKDIV_1,    //主时钟分频设置为1，不分频。.ePDMClkSource = AM_HAL_PDM_INTERNAL_CLK,    //使用内部时钟源。.ePCMChannels = AM_HAL_PDM_CHANNEL_LEFT,    //录音声道选择。在PCM音频（BIN）文件加上WAV文件头，"
keywords: "apollo3录音到wav播放解决方法"
categories: ['未分类']
tags: ['驱动开发', '音视频', '物联网', '嵌入式硬件', '单片机']
artid: "146179105"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146179105
    alt: "apollo3录音到wav播放解决方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146179105
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146179105
cover: https://bing.ee123.net/img/rand?artid=146179105
image: https://bing.ee123.net/img/rand?artid=146179105
img: https://bing.ee123.net/img/rand?artid=146179105
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     apollo3录音到wav播放解决方法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     SDK DEMO项目:ap3bp_evb_vos_pcm_recorder_20210901
    </p>
    <p>
     pcm_recorder.c
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // Options
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     #define PRINT_UART          0
     <br/>
     #define USE_OPUS            1
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // Cache configuration
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     const am_hal_cachectrl_config_t am_hal_cachectrl_benchmark =
     <br/>
     {
     <!-- -->
     <br/>
     .bLRU                       = 0,
     <br/>
     .eDescript                  = AM_HAL_CACHECTRL_DESCR_1WAY_128B_512E,
     <br/>
     .eMode                      = AM_HAL_CACHECTRL_CONFIG_MODE_INSTR,
     <br/>
     };
    </p>
    <p>
     #define RTT_LOGGER_BUFFER_LENGTH_BYTE   (128*1024)
     <br/>
     uint8_t ui8RttLoggerBuffer[RTT_LOGGER_BUFFER_LENGTH_BYTE];
    </p>
    <p>
     #define AUDIO_FRAME_MS                  20
    </p>
    <p>
     #define AUDIO_FRAME_SIZE_SAMPLES        ((16000)/(1000/AUDIO_FRAME_MS))
     <br/>
     #define AUDIO_FRAME_SIZE_MONO_BYTES     (AUDIO_FRAME_SIZE_SAMPLES*2)
     <br/>
     #define AUDIO_FRAME_SIZE_STEREO_BYTES   (AUDIO_FRAME_SIZE_SAMPLES*4)
    </p>
    <p>
     #define ENCODED_HEADER_SIZE_BYITES      8
     <br/>
     #define ENCODED_COMPRESS_RATE           8
     <br/>
     #define ENCODED_FRAME_SIZE_BYTES        ((AUDIO_FRAME_SIZE_SAMPLES*2/ENCODED_COMPRESS_RATE) + ENCODED_HEADER_SIZE_BYITES)
    </p>
    <p>
     <br/>
     uint8_t g_opusAudioInputBuffer[AUDIO_FRAME_SIZE_MONO_BYTES]; // 20ms mono raw audio frame
     <br/>
     bool g_opusInputReadyFlag = false;
    </p>
    <p>
     #if USE_OPUS
     <br/>
     uint8_t g_opusAudioOutputBuffer[ENCODED_FRAME_SIZE_BYTES]; // encoded audio frame, with header
     <br/>
     uint16_t g_opusInputIndex = 0;
     <br/>
     #endif // #if USE_OPUS
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // PDM configuration information.
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     void *PDMHandle = NULL;
    </p>
    <p>
     #define PDM_CLK                     12
     <br/>
     #define PDM_CLK_PIN_CFG             AM_HAL_PIN_12_PDMCLK
     <br/>
     #define PDM_DATA                    11
     <br/>
     #define PDM_DATA_PIN_CFG            AM_HAL_PIN_11_PDMDATA
    </p>
    <p>
     am_hal_pdm_config_t g_sPdmConfig =
     <br/>
     {
     <!-- -->
     <br/>
     .eClkDivider = AM_HAL_PDM_MCLKDIV_1,    //主时钟分频设置为1，不分频
     <br/>
     .eLeftGain = AM_HAL_PDM_GAIN_P105DB,    //左声道增益延迟设置为105dB
     <br/>
     .eRightGain = AM_HAL_PDM_GAIN_P105DB,
     <br/>
     .ui32DecimationRate = 48,     // CLK 1.5 Mhz  //降频采样倍数
     <br/>
     .bHighPassEnable = 0, //禁用高通滤波器
     <br/>
     .ui32HighPassCutoff = 0xB,
     <br/>
     .ePDMClkSpeed = AM_HAL_PDM_CLK_1_5MHZ,    //PDM采样频率，1.5M转换后是16K音频频率
     <br/>
     .bInvertI2SBCLK = 0,
     <br/>
     .ePDMClkSource = AM_HAL_PDM_INTERNAL_CLK,    //使用内部时钟源
     <br/>
     .bPDMSampleDelay = 0,    //PDM采样延迟
     <br/>
     .bDataPacking = 1,    //启用数据换包
     <br/>
     .ePCMChannels = AM_HAL_PDM_CHANNEL_LEFT,    //录音声道选择
     <br/>
     .bLRSwap = 0,    //不交换左右声道
     <br/>
     .bSoftMute = 0,    //禁用软静音
     <br/>
     };
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // Start a transaction to get some number of bytes from the PDM interface.
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     uint32_t g_ui32PDMDataBuffer[AUDIO_FRAME_SIZE_MONO_BYTES/4];
     <br/>
     void
     <br/>
     pdm_trigger_dma(void)
     <br/>
     {
     <!-- -->
     <br/>
     //
     <br/>
     // Configure DMA and target address.
     <br/>
     //
     <br/>
     am_hal_pdm_transfer_t sTransfer;
     <br/>
     sTransfer.ui32TargetAddr = (uint32_t ) g_ui32PDMDataBuffer;
     <br/>
     sTransfer.ui32TotalCount = (AUDIO_FRAME_SIZE_MONO_BYTES);
    </p>
    <p>
     //
     <br/>
     // Start the data transfer.
     <br/>
     //
     <br/>
     am_hal_pdm_dma_start(PDMHandle, &amp;sTransfer);
     <br/>
     }
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // Structure for handling PDM register state information for power up/down
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     typedef struct
     <br/>
     {
     <!-- -->
     <br/>
     bool bValid;
     <br/>
     }
     <br/>
     am_hal_pdm_register_state_t;
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // Structure for handling PDM HAL state information.
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     typedef struct
     <br/>
     {
     <!-- -->
     <br/>
     am_hal_handle_prefix_t prefix;
     <br/>
     am_hal_pdm_register_state_t sRegState;
     <br/>
     uint32_t ui32Module;
     <br/>
     }
     <br/>
     am_hal_pdm_state_t;
    </p>
    <p>
     void am_app_KWD_pdm_dma_disable(void *pHandle)
     <br/>
     {
     <!-- -->
     <br/>
     am_hal_pdm_state_t *pState = (am_hal_pdm_state_t *) pHandle;
     <br/>
     uint32_t ui32Module = pState-&gt;ui32Module;
    </p>
    <p>
     //
     <br/>
     // Disable DMA
     <br/>
     //
     <br/>
     PDMn(ui32Module)-&gt;DMACFG_b.DMAEN = PDM_DMACFG_DMAEN_DIS;
    </p>
    <p>
     }
    </p>
    <p>
     //-----------------------------------------------------------------------------
     <br/>
     // METHOD:  PDM_Init
     <br/>
     // PURPOSE: PDM module configuration
     <br/>
     //-----------------------------------------------------------------------------
     <br/>
     void PDMInit(void)
     <br/>
     {
     <!-- -->
    </p>
    <p>
     if (PDMHandle != NULL)
     <br/>
     return;
     <br/>
     //
     <br/>
     // Initialize, power-up, and configure the PDM.
     <br/>
     //
     <br/>
     am_hal_pdm_initialize(0, &amp;PDMHandle);
     <br/>
     //
     <br/>
     // Configure the necessary pins.
     <br/>
     //
     <br/>
     am_hal_gpio_pincfg_t sPinCfg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    </p>
    <p>
     sPinCfg.uFuncSel = PDM_CLK_PIN_CFG;
     <br/>
     am_hal_gpio_pinconfig(PDM_CLK, sPinCfg);
    </p>
    <p>
     sPinCfg.uFuncSel = PDM_DATA_PIN_CFG;
     <br/>
     am_hal_gpio_pinconfig(PDM_DATA, sPinCfg);
    </p>
    <p>
     am_hal_pdm_power_control(PDMHandle, AM_HAL_PDM_POWER_ON, false);
     <br/>
     am_hal_pdm_configure(PDMHandle, &amp;g_sPdmConfig);
     <br/>
     am_hal_pdm_fifo_flush(PDMHandle);
    </p>
    <p>
     //
     <br/>
     // Configure and enable PDM interrupts (set up to trigger on DMA
     <br/>
     // completion).
     <br/>
     //
     <br/>
     am_hal_pdm_interrupt_enable(PDMHandle, (AM_HAL_PDM_INT_DERR
     <br/>
     | AM_HAL_PDM_INT_DCMP
     <br/>
     | AM_HAL_PDM_INT_UNDFL
     <br/>
     | AM_HAL_PDM_INT_OVF));
     <br/>
     NVIC_EnableIRQ(PDM_IRQn);
     <br/>
     }
    </p>
    <p>
     void PDMDeInit()
     <br/>
     {
     <!-- -->
     <br/>
     if(PDMHandle == NULL)
     <br/>
     return;
    </p>
    <p>
     am_hal_pdm_interrupt_clear(PDMHandle, (AM_HAL_PDM_INT_DERR
     <br/>
     | AM_HAL_PDM_INT_DCMP
     <br/>
     | AM_HAL_PDM_INT_UNDFL
     <br/>
     | AM_HAL_PDM_INT_OVF));
    </p>
    <p>
     am_hal_pdm_interrupt_disable(PDMHandle, (AM_HAL_PDM_INT_DERR
     <br/>
     | AM_HAL_PDM_INT_DCMP
     <br/>
     | AM_HAL_PDM_INT_UNDFL
     <br/>
     | AM_HAL_PDM_INT_OVF));
    </p>
    <p>
     NVIC_DisableIRQ(PDM_IRQn);
    </p>
    <p>
     am_hal_gpio_pinconfig(PDM_CLK, g_AM_HAL_GPIO_DISABLE);
     <br/>
     am_hal_gpio_pinconfig(PDM_DATA, g_AM_HAL_GPIO_DISABLE);
    </p>
    <p>
     // This was a workaround code to measure power consumption. Need to review!!
     <br/>
     am_app_KWD_pdm_dma_disable(PDMHandle);
    </p>
    <p>
     am_hal_pdm_disable(PDMHandle);
     <br/>
     am_hal_pdm_power_control(PDMHandle, AM_HAL_PDM_POWER_OFF, false);
    </p>
    <p>
     am_hal_pdm_deinitialize(PDMHandle);
     <br/>
     PDMHandle = NULL;
    </p>
    <p>
     }
    </p>
    <p>
     void am_pdm0_isr(void)
     <br/>
     {
     <!-- -->
     <br/>
     uint32_t ui32Status;
    </p>
    <p>
     //
     <br/>
     // Read the interrupt status.
     <br/>
     //
     <br/>
     am_hal_pdm_interrupt_status_get(PDMHandle, &amp;ui32Status, true);
     <br/>
     am_hal_pdm_interrupt_clear(PDMHandle, ui32Status);
    </p>
    <p>
     //
     <br/>
     // Once our DMA transaction completes, we will disable the PDM and send a
     <br/>
     // flag back down to the main routine. Disabling the PDM is only necessary
     <br/>
     // because this example only implemented a single buffer for storing FFT
     <br/>
     // data. More complex programs could use a system of multiple buffers to
     <br/>
     // allow the CPU to run the FFT in one buffer while the DMA pulls PCM data
     <br/>
     // into another buffer.
     <br/>
     //
     <br/>
     if (ui32Status &amp; AM_HAL_PDM_INT_DCMP)
     <br/>
     {
     <!-- -->
     <br/>
     // trigger next traction
     <br/>
     PDMn(0)-&gt;DMATOTCOUNT = AUDIO_FRAME_SIZE_MONO_BYTES;  // FIFO unit in bytes
    </p>
    <p>
     amu2s_send(Amu2s_pcm, g_ui32PDMDataBuffer, AMU2S_PCM_BYTES);
    </p>
    <p>
     #if USE_OPUS
     <br/>
     //
     <br/>
     // move data to opus buffer
     <br/>
     //
     <br/>
     memmove(g_opusAudioInputBuffer, g_ui32PDMDataBuffer,AUDIO_FRAME_SIZE_MONO_BYTES);
     <br/>
     g_opusInputReadyFlag = true;
     <br/>
     #endif // #if USE_OPUS
     <br/>
     }
     <br/>
     else if(ui32Status &amp; (AM_HAL_PDM_INT_UNDFL | AM_HAL_PDM_INT_OVF))
     <br/>
     {
     <!-- -->
     <br/>
     am_hal_pdm_fifo_flush(PDMHandle);
     <br/>
     }
    </p>
    <p>
     }
    </p>
    <p>
     #define AM_CRITICAL_BEGIN_VOS                                               \
     <br/>
     if ( 1 )                                                                \
     <br/>
     {                                                                       \
     <br/>
     volatile uint32_t ui32Primask_04172010;                             \
     <br/>
     ui32Primask_04172010 = am_hal_interrupt_master_disable();
    </p>
    <p>
     #define AM_CRITICAL_END_VOS                                                 \
     <br/>
     am_hal_interrupt_master_set(ui32Primask_04172010);                  \
     <br/>
     }
    </p>
    <p>
     //*****************************************************************************
     <br/>
     //
     <br/>
     // Main Function.
     <br/>
     //
     <br/>
     //*****************************************************************************
     <br/>
     int
     <br/>
     main(void)
     <br/>
     {
     <!-- -->
     <br/>
     //
     <br/>
     // Set the clock frequency.
     <br/>
     //
     <br/>
     am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    </p>
    <p>
     //
     <br/>
     // Set the default cache configuration
     <br/>
     //
     <br/>
     am_hal_cachectrl_config(&amp;am_hal_cachectrl_benchmark);
     <br/>
     am_hal_cachectrl_enable();
    </p>
    <p>
     //
     <br/>
     // Configure the board for low power operation.
     <br/>
     //
     <br/>
     am_bsp_low_power_init();
    </p>
    <p>
     #if (PRINT_UART == 1)
     <br/>
     am_bsp_uart_printf_enable();
    </p>
    <p>
     //
     <br/>
     // Clear the terminal and print the banner.
     <br/>
     //
     <br/>
     am_util_stdio_terminal_clear();
     <br/>
     am_util_stdio_printf("Ambiq Micro 'while' example.\n\n");
    </p>
    <p>
     //
     <br/>
     // Brief description
     <br/>
     //
     <br/>
     am_util_stdio_printf("Used for measuring power in an infinite while loop.\n");
    </p>
    <p>
     //
     <br/>
     // Print the compiler version.
     <br/>
     //
     <br/>
     am_util_stdio_printf("App Compiler:    %s\n", COMPILER_VERSION);
     <br/>
     am_util_stdio_printf("HAL Compiler:    %s\n", g_ui8HALcompiler);
     <br/>
     am_util_stdio_printf("HAL SDK version: %d.%d.%d\n",
     <br/>
     g_ui32HALversion.s.Major,
     <br/>
     g_ui32HALversion.s.Minor,
     <br/>
     g_ui32HALversion.s.Revision);
     <br/>
     am_util_stdio_printf("HAL compiled with %s-style registers\n",
     <br/>
     g_ui32HALversion.s.bAMREGS ? "AM_REG" : "CMSIS");
    </p>
    <p>
     <br/>
     #endif // PRINT_UART
    </p>
    <p>
     amu2s_init();
     <br/>
     PDMInit();
     <br/>
     am_hal_pdm_enable(PDMHandle);
     <br/>
     pdm_trigger_dma();
    </p>
    <p>
     SEGGER_RTT_ConfigUpBuffer(1, "TestDataLogger", ui8RttLoggerBuffer, RTT_LOGGER_BUFFER_LENGTH_BYTE, SEGGER_RTT_MODE_NO_BLOCK_SKIP);
    </p>
    <p>
     #if USE_OPUS
     <br/>
     /* initialize the audio encoder */
     <br/>
     audio_enc_init(true);       // true for with header
     <br/>
     #endif // #if USE_OPUS
    </p>
    <p>
     // master interrupt enable
     <br/>
     am_hal_interrupt_master_enable();
    </p>
    <p>
     while(1)
     <br/>
     {
     <!-- -->
    </p>
    <p>
     #if USE_OPUS
     <br/>
     if(g_opusInputReadyFlag == true)
     <br/>
     {
     <!-- -->
     <br/>
     g_opusInputReadyFlag = false;
     <br/>
     // data ready to encode, run encoder
    </p>
    <p>
     uint32_t encoded_bytes = audio_enc_encode_frame((short*)g_opusAudioInputBuffer, AUDIO_FRAME_SIZE_SAMPLES, (unsigned char*)g_opusAudioOutputBuffer);
    </p>
    <p>
     // send to RTT
     <br/>
     SEGGER_RTT_Write(1, (uint8_t*)g_opusAudioOutputBuffer, encoded_bytes);
    </p>
    <p>
     // send to AmU2S
     <br/>
     amu2s_send(Amu2s_opus, g_opusAudioOutputBuffer, AMU2S_OPUS_BYTES);
    </p>
    <p>
     #endif // #if USE_OPUS
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     项目编译，在开发板上运行，打开官方配备的工具，抓取录音数据，如下图：
     <img alt="" height="509" src="https://i-blog.csdnimg.cn/direct/baf0a89eaa514aaab3b0355713a8ccf1.png" width="1331"/>
    </p>
    <p>
     按任意键停止抓取，即可抓取到非标准的PCM音频，如下图：
    </p>
    <p>
     <img alt="" height="99" src="https://i-blog.csdnimg.cn/direct/744357fcae334bb99984b2f11ffcf813.png" width="950"/>
    </p>
    <h5>
     <strong>
      使用提供的 Python 脚本
     </strong>
    </h5>
    <p>
     运行以下命令解码为 PCM 文件：
    </p>
    <p>
     python ftdi_bin_decoder.py decoder input.bin --output=audio --format=raw
    </p>
    <p>
     生成文件：
     <code>
      audio_pcm
     </code>
     （原始 PCM 数据）
    </p>
    <p>
     执行成功，同时生成标准的PCM数据BIN文件和OPUS压缩的BIN文件，如下图：
    </p>
    <p>
     <img alt="" height="336" src="https://i-blog.csdnimg.cn/direct/9f906bacbfd64c3f8046090d737a73ac.png" width="1245"/>
    </p>
    <p>
     如果出现以下错误提示
     <br/>
     import pandas as pd
     <br/>
     ModuleNotFoundError: No module named 'pandas'
     <br/>
     遇到 ModuleNotFoundError: No module named 'pandas' 错误，说明你的 Python 环境中缺少 pandas 库
    </p>
    <p>
     通过 pip 直接安装：pip install pandas
    </p>
    <p>
     转换为 WAV 播放命令 ：
     <br/>
     python bin_to_wav.py mono -i audio_pcm
     <br/>
     在PCM音频（BIN）文件加上WAV文件头，
    </p>
    <p>
     执行成功后，生成可播放音频文件，如下图：
    </p>
    <p>
     <img alt="" height="347" src="https://i-blog.csdnimg.cn/direct/fbe9dd1f1a1a4feab061ef7a14c5d7ca.png" width="1228"/>
    </p>
    <p>
     如果出现以下错误提示：
     <br/>
     import soundfile as sf
     <br/>
     ModuleNotFoundError: No module named 'soundfile'
    </p>
    <p>
     错误 ModuleNotFoundError: No module named 'soundfile' 表明 Python 环境中缺少 soundfile 库。该库用于读写音频文件（如 WAV 格式），是 bin_to_wav.py 脚本的依赖项。
     <br/>
     解决方法
     <br/>
     安装 soundfile 库
     <br/>
     通过 pip 直接安装：pip install soundfile
    </p>
    <p>
     bin_to_wav.py这个python脚本重要补充说明
    </p>
    <ol>
     <li>
      <p>
       <strong>
        硬件适配特性
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          声道交换
         </strong>
         ：通过
         <code>
          --swap 1
         </code>
         参数修正 Apollo PDM 模块的左右声道反接问题
        </p>
       </li>
       <li>
        <p>
         <strong>
          位深度处理
         </strong>
         ：假设输入为 16-bit PCM，通过
         <code>
          /32768
         </code>
         实现标准化
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        音频处理流程
       </strong>
       ： 原始PCM --&gt; 解析为整数 --&gt; 声道分离 --&gt; 浮点归一化 --&gt; 峰值归一化 --&gt; 输出WAV
      </p>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f78755f77656e6d696e672f:61727469636c652f64657461696c732f313436313739313035" class_="artid" style="display:none">
 </p>
</div>


