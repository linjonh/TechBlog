---
layout: post
title: "大数据之Zookeeper"
date: 2022-04-30 13:34:18 +0800
description: "大数据之Zookeeper"
keywords: "大数据之Zookeeper"
categories: ['中间件']
tags: ['分布式', 'Zookeeper', 'Data', 'Big']
artid: "124511742"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=124511742
    alt: "大数据之Zookeeper"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=124511742
featuredImagePreview: https://bing.ee123.net/img/rand?artid=124511742
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     大数据之Zookeeper
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#1_Zookeeper__1" rel="nofollow">
        1. Zookeeper 入门
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#11__2" rel="nofollow">
          1.1 概述
         </a>
        </li>
        <li>
         <a href="#12__7" rel="nofollow">
          1.2 特点
         </a>
        </li>
        <li>
         <a href="#13__16" rel="nofollow">
          1.3 数据结构
         </a>
        </li>
        <li>
         <a href="#14__20" rel="nofollow">
          1.4 应用场景
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#2_Zookeeper__47" rel="nofollow">
        2. Zookeeper 安装
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#21__48" rel="nofollow">
          2.1 下载地址
         </a>
        </li>
        <li>
         <a href="#22__51" rel="nofollow">
          2.2 本地模式安装部署
         </a>
        </li>
        <li>
         <a href="#23__80" rel="nofollow">
          2.3 分布式安装部署
         </a>
        </li>
        <li>
         <a href="#24__159" rel="nofollow">
          2.4 配置参数解读
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#3_Zookeeper__183" rel="nofollow">
        3. Zookeeper 内部原理
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#31__184" rel="nofollow">
          3.1 选举机制
         </a>
        </li>
        <li>
         <a href="#32__206" rel="nofollow">
          3.2 节点类型
         </a>
        </li>
        <li>
         <a href="#33_Stat__236" rel="nofollow">
          3.3 Stat 结构体
         </a>
        </li>
        <li>
         <a href="#34__263" rel="nofollow">
          3.4 监听器原理
         </a>
        </li>
        <li>
         <a href="#35__280" rel="nofollow">
          3.5 写数据流程
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#4_Zookeeper__283" rel="nofollow">
        4. Zookeeper 实战
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#41__284" rel="nofollow">
          4.1 客户端命令行操作
         </a>
        </li>
        <li>
         <a href="#42_API__332" rel="nofollow">
          4.2 API 操作
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#431_IDEA__333" rel="nofollow">
            4.3.1 IDEA 环境搭建
           </a>
          </li>
          <li>
           <a href="#432__ZooKeeper__371" rel="nofollow">
            4.3.2 创建 ZooKeeper 客户端
           </a>
          </li>
          <li>
           <a href="#434__418" rel="nofollow">
            4.3.4 获取子节点并监听节点变化
           </a>
          </li>
          <li>
           <a href="#435__Znode__461" rel="nofollow">
            4.3.5 判断 Znode 是否存在
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#43__469" rel="nofollow">
          4.3 监听服务器节点动态上下线案例
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#5_zookeeper_583" rel="nofollow">
        5 zookeeper框架
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#51_orgapachezookeeper_584" rel="nofollow">
          5.1 org.apache.zookeeper
         </a>
        </li>
        <li>
         <a href="#52_zkclient_585" rel="nofollow">
          5.2 zkclient
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#521__588" rel="nofollow">
            5.2.1 简介
           </a>
          </li>
          <li>
           <a href="#522_Maven_602" rel="nofollow">
            5.2.2 Maven依赖
           </a>
          </li>
          <li>
           <a href="#523_ZkClient__610" rel="nofollow">
            5.2.3 ZkClient 的设计
           </a>
          </li>
          <li>
           <a href="#524__616" rel="nofollow">
            5.2.4 重要处理流程说明
           </a>
          </li>
          <li>
           <a href="#525_Watcher_638" rel="nofollow">
            5.2.5 客户端处理变更（Watcher通知）
           </a>
          </li>
          <li>
           <a href="#526__669" rel="nofollow">
            5.2.6 序列化处理
           </a>
          </li>
          <li>
           <a href="#527_ZkClientZooKeeper_675" rel="nofollow">
            5.2.7 ZkClient如何解决使用ZooKeeper客户端遇到的问题的呢?
           </a>
          </li>
          <li>
           <a href="#528_API_681" rel="nofollow">
            5.2.8 API介绍
           </a>
          </li>
          <li>
           <a href="#529_demo_697" rel="nofollow">
            5.2.9 demo
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#53_Curator_939" rel="nofollow">
          5.3 Curator
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#531__940" rel="nofollow">
            5.3.1 简介
           </a>
          </li>
          <li>
           <a href="#532__958" rel="nofollow">
            5.3.2 版本问题
           </a>
          </li>
          <li>
           <a href="#533_CuratorFramework_962" rel="nofollow">
            5.3.3 CuratorFramework
           </a>
          </li>
          <li>
           <a href="#534_curatorrecipes_970" rel="nofollow">
            5.3.4 curator-recipes
           </a>
          </li>
          <li>
           <a href="#535__972" rel="nofollow">
            5.3.5 知识点
           </a>
          </li>
          <li>
           <a href="#536_Maven_980" rel="nofollow">
            5.3.6 Maven依赖
           </a>
          </li>
          <li>
           <a href="#537_api_999" rel="nofollow">
            5.3.7 api
           </a>
          </li>
          <li>
           <a href="#538_CuratorAPICache_1119" rel="nofollow">
            5.3.8 使用Curator高级API特性之Cache缓存监控节点变化
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#54_CuratorACL_1639" rel="nofollow">
        5.4 使用Curator创建/验证ACL(访问权限列表)
       </a>
      </li>
      <li>
       <ul>
        <li>
         <ul>
          <li>
           <a href="#541_Zk_1640" rel="nofollow">
            5.4.1 连通Zk时，就指定登录权限
           </a>
          </li>
          <li>
           <a href="#542_1665" rel="nofollow">
            5.4.2写一个把明文的账号密码转换为加密后的密文的工具类
           </a>
          </li>
          <li>
           <a href="#543AclUtilsAcl_1688" rel="nofollow">
            5.4.3使用自定义工具类AclUtils，一次性给多个用户赋Acl权限
           </a>
          </li>
          <li>
           <a href="#544_1700" rel="nofollow">
            5.4.4级联创建节点，并赋予节点操作权限
           </a>
          </li>
          <li>
           <a href="#545_1711" rel="nofollow">
            5.4.5读取节点数据
           </a>
          </li>
          <li>
           <a href="#546ACLdata_1723" rel="nofollow">
            5.4.6修改具有ACL权限节点的data数据
           </a>
          </li>
          <li>
           <a href="#547node_1732" rel="nofollow">
            5.4.7两种方法判断node节点是否存（优先使用第一种）
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#7__1771" rel="nofollow">
        7 分布式锁
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#71InterProcessMutex_1788" rel="nofollow">
          7.1.重入式排它锁InterProcessMutex
         </a>
        </li>
        <li>
         <a href="#72InterProcessSemaphoreMutex_1803" rel="nofollow">
          7.2.不可重入排它锁InterProcessSemaphoreMutex
         </a>
        </li>
        <li>
         <a href="#73InterProcessReadWriteLock_InterProcessLock_1807" rel="nofollow">
          7.3.可重入读写锁InterProcessReadWriteLock 、InterProcessLock
         </a>
        </li>
        <li>
         <a href="#74_InterProcessMultiLockInterProcessLock_1810" rel="nofollow">
          7.4.多锁对象容器(多共享锁) ，将多个锁作为单个实体管理，InterProcessMultiLock、InterProcessLock
         </a>
        </li>
        <li>
         <a href="#75_1817" rel="nofollow">
          7.5.代码
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#8_1876" rel="nofollow">
        8.分布式计数器
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="1_Zookeeper__1">
     </a>
     1. Zookeeper 入门
    </h2>
    <h3>
     <a id="11__2">
     </a>
     1.1 概述
    </h3>
    <p>
     Zookeeper 是一个开源的分布式的，为分布式应用提供协调服务的 Apache 项目。
     <br/>
     Zookeeper 从设计模式角度来理解：是一个基于观案者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/42ff9072a85a37ddfe9ca52b0e18de8c.png"/>
    </p>
    <h3>
     <a id="12__7">
     </a>
     1.2 特点
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/42b9ec4a284bfa870d18efb3968fc017.png"/>
    </p>
    <p>
     1)Zookeeper：一个领导者（Leader） ，多个跟随者（Follower）组成的集群。
     <br/>
     2)集群中只要有半数以上节点存活，Zookeeper 集群就能正常服务。
     <br/>
     3)全局数据一致：每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致的。
     <br/>
     4)更新请求顺序进行，来自同一个 Client 的更新请求按其发送顺序依次执行。
     <br/>
     5)数据更新原子性，一次数据更新要么成功，要么失败。
     <br/>
     6)实时性，在一定时间范围内，Client 能读到最新数据。
    </p>
    <h3>
     <a id="13__16">
     </a>
     1.3 数据结构
    </h3>
    <p>
     ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1 MB 的数据，每个 ZNode 都可以通过其路径唯一标识。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/12938d7df7a78a9597ccafd086e4cbdb.png"/>
    </p>
    <h3>
     <a id="14__20">
     </a>
     1.4 应用场景
    </h3>
    <p>
     提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。
     <br/>
     统一命名服务
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6860121ddf11ab1f41e92b0682fe1b9c.png">
      <br/>
      在分布式环境下，经常需要对应用/服务进行统一命名 ，便于识别。例如：IP 不容易记住，而域名容易记住。
      <br/>
      统一配置管理
      <br/>
      （1）分布式环境下，配置文件同步非常常见。
      <br/>
      ① 一般要求一个集群中，所有节点的配置信息是一致的，比如 Kafka 集群。
      <br/>
      ② 对配置文件修改后，希望能够快速同步到各个节点上。
      <br/>
      （2）配置管理可交由 ZooKeeper 实现。
      <br/>
      ① 可将配置信息写入 ZooKeeper 上的一个 Znode 。
      <br/>
      ② 各个客户端服务器监听这个 Znode。
      <br/>
      ③ 一旦 Znode 中的数据被修改，ZooKeeper 将通知各个客户端服务器。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/bb3dc27950e58ed6685259aac58763ee.png"/>
     </img>
    </p>
    <p>
     统一集群管理
     <br/>
     （1）分布式环境中，实时掌握每个节点的状态是必要的。
     <br/>
     可根据节点实时状态做出一些调整。
     <br/>
     （2）ZooKeeper 可以实现实时监控节点状态变化
     <br/>
     ① 可将节点信息写入Z ooKeeper 上的一个 ZNode。
     <br/>
     ② 监听这个 ZNode 可获取它的实时状态变化。
     <br/>
     服务器动态上下线
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4b83a6958fd3a2349bc260f0a39ed0b3.png">
      <br/>
      软负载均衡
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/db67d515f0b31e2098c4525b6659e5af.png">
       <br/>
       在 Zookeeper 中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6bac2e6bad0abf6911c9f70d947fb7f6.png"/>
      </img>
     </img>
    </p>
    <h2>
     <a id="2_Zookeeper__47">
     </a>
     2. Zookeeper 安装
    </h2>
    <h3>
     <a id="21__48">
     </a>
     2.1 下载地址
    </h3>
    <p>
     zookeeper 官网
    </p>
    <h3>
     <a id="22__51">
     </a>
     2.2 本地模式安装部署
    </h3>
    <p>
     准备工作
    </p>
    <pre><code>tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz -C /usr/local/
mv apache-zookeeper-3.5.6-bin/ zookeeper
mv zoo_sample.cfg zoo.cfg
mkdir -p /usr/local/zookeeper/data

vim zoo.cfg
dataDir=/usr/local/zookeeper/data
</code></pre>
    <p>
     vim /etc/profile
     <br/>
     在配置文件中添加以下内容
     <br/>
     #ZOOKEEPER
     <br/>
     export ZOOKEEPER_HOME=/hadoop/zookeeper-3.5.6
     <br/>
     export PATH=
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        P 
        
       
         A 
        
       
         T 
        
       
         H 
        
       
         : 
        
       
      
        PATH:
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.13889em;">
          P
         </span>
         <span class="mord mathdefault">
          A
         </span>
         <span class="mord mathdefault" style="margin-right: 0.13889em;">
          T
         </span>
         <span class="mord mathdefault" style="margin-right: 0.08125em;">
          H
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          :
         </span>
        </span>
       </span>
      </span>
     </span>
     ZOOKEEPER_HOME/bin
     <br/>
     source /etc/profile
    </p>
    <p>
     启动 Zookeeper
     <br/>
     zkServer.sh start
    </p>
    <p>
     启动客户端
     <br/>
     zkCli.sh
     <br/>
     退出客户端
     <br/>
     quit
     <br/>
     停止 Zookeeper
     <br/>
     zkServer.sh stop
    </p>
    <h3>
     <a id="23__80">
     </a>
     2.3 分布式安装部署
    </h3>
    <p>
     集群规划
     <br/>
     在 master、slave1 和 slave2 三个节点上部署 Zookeeper。
     <br/>
     tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz -C /usr/local
     <br/>
     mv apache-zookeeper-3.5.6-bin/ zookeeper
     <br/>
     同步 /usr/local/zookeeper 目录内容到 slave1、slave2
    </p>
    <p>
     xsync zookeeper/
     <br/>
     配置服务器编号
     <br/>
     ① 在 /usr/local/zookeeper/ 这个目录下创建 zkData
     <br/>
     mkdir data
     <br/>
     ② /usr/local/zookeeper/data 目录下创建一个 myid 的文件
     <br/>
     touch myid
     <br/>
     ③ 编辑 myid 文件
     <br/>
     vim myid
     <br/>
     在文件中添加与 server 对应的编号：
     <br/>
     0
     <br/>
     ④ 分发到其他机器上
     <br/>
     xsync myid
     <br/>
     并分别在 slave1、slave2 上修改 myid 文件中内容为 1、2
    </p>
    <p>
     配置 zoo.cfg 文件
     <br/>
     ① 将 /usr/local/zookeeper/conf 这个路径下的 zoo_sample.cfg 修改为 zoo.cfg
     <br/>
     mv zoo_sample.cfg zoo.cfg
     <br/>
     ② 打开 zoo.cfg 文件，修改 dataDir 路径
     <br/>
     dataDir=/usr/local/zookeeper/data
    </p>
    <p>
     增加如下配置
     <br/>
     server.0=master:2888:3888
     <br/>
     server.1=slave1:2888:3888
     <br/>
     server.2=slave2:2888:3888
     <br/>
     同步 zoo.cfg 配置文件
     <br/>
     xsync zoo.cfg
    </p>
    <p>
     修改环境变量
     <br/>
     ① 打开配置文件
     <br/>
     vim /etc/profile
     <br/>
     ② 在配置文件中添加以下内容
     <br/>
     #ZOOKEEPER
     <br/>
     export ZOOKEEPER_HOME=/usr/local/zookeeper
     <br/>
     export PATH=
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        P 
        
       
         A 
        
       
         T 
        
       
         H 
        
       
         : 
        
       
      
        PATH:
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.68333em; vertical-align: 0em;">
         </span>
         <span class="mord mathdefault" style="margin-right: 0.13889em;">
          P
         </span>
         <span class="mord mathdefault">
          A
         </span>
         <span class="mord mathdefault" style="margin-right: 0.13889em;">
          T
         </span>
         <span class="mord mathdefault" style="margin-right: 0.08125em;">
          H
         </span>
         <span class="mspace" style="margin-right: 0.277778em;">
         </span>
         <span class="mrel">
          :
         </span>
        </span>
       </span>
      </span>
     </span>
     ZOOKEEPER_HOME/bin
     <br/>
     ③ 同步配置文件
     <br/>
     xsync /etc/profile
     <br/>
     ④ 使配置文件生效（三台机器）
     <br/>
     source /etc/profile
    </p>
    <p>
     集群操作
     <br/>
     ① 三台机器分别启动 Zookeeper
     <br/>
     zkServer.sh start
     <br/>
     ② 三台机器分别关闭 Zookeeper
     <br/>
     zkServer.sh stop
     <br/>
     编写 Zookeeper 的群起群关脚本
    </p>
    <p>
     ① 在 /usr/local/bin 目录下创建 zk 文件
     <br/>
     vim zk.sh
    </p>
    <pre><code>#!/bin/bash
case $1 in
"start"){
  for i in master slave1 slave2
    do
      echo "****************** $i *********************"
      ssh $i "source /etc/profile &amp;&amp; zkServer.sh start"
    done
};;

"stop"){
  for i in master slave1 slave2
    do
      echo "****************** $i *********************"
      ssh $i "source /etc/profile &amp;&amp; zkServer.sh stop"
    done
};;

esac
</code></pre>
    <p>
     修改脚本 zk 具有执行权限
     <br/>
     chmod 777 zk.sh
     <br/>
     调用脚本形式：zk start 或 zk stop
    </p>
    <h3>
     <a id="24__159">
     </a>
     2.4 配置参数解读
    </h3>
    <p>
     Zookeeper 中的配置文件 zoo.cfg 中参数含义解读如下：
     <br/>
     tickTime =2000：通信心跳数，Zookeeper 服务器与客户端心跳时间，单位毫秒
     <br/>
     Zookeeper 使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime 时间就会发送一个心跳，时间单位为毫秒。它用于心跳机制，并且设置最小的 session 超时时间为两倍心跳时间。(session 的最小超时时间是 2*tickTime）
    </p>
    <p>
     initLimit =10：LF 初始通信时限
     <br/>
     集群中的 Follower 跟随者服务器与 Leader 领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的 Zookeeper 服务器连接到 Leader 的时限。
    </p>
    <p>
     syncLimit =5：LF 同步通信时限
     <br/>
     集群中 Leader 与 Follower 之间的最大响应时间单位，假如响应超过 syncLimit * tickTime，Leader 认为 Follwer 死掉，从服务器列表中删除 Follwer。
    </p>
    <p>
     dataDir：数据文件目录+数据持久化路径
     <br/>
     主要用于保存 Zookeeper 中的数据。
    </p>
    <p>
     clientPort =2181：客户端连接端口
     <br/>
     监听客户端连接的端口。
    </p>
    <p>
     server.A=B:C:D
     <br/>
     A 是一个数字，表示这个是第几号服务器；集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个server。
     <br/>
     B 是这个服务器的 ip 地址；
     <br/>
     C 是这个服务器与集群中的 Leader 服务器交换信息的端口；
     <br/>
     D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。
    </p>
    <h2>
     <a id="3_Zookeeper__183">
     </a>
     3. Zookeeper 内部原理
    </h2>
    <h3>
     <a id="31__184">
     </a>
     3.1 选举机制
    </h3>
    <p>
     半数机制
    </p>
    <p>
     集群中半数以上机器存活，集群可用。所以 Zookeeper 适合安装奇数台服务器。
    </p>
    <p>
     Zookeeper 虽然在配置文件中并没有指定 Master 和 Slave。但是，Zookeeper 工作时，是有一个节点为 Leader，其他则为 Follower，Leader 是通过内部的选举机制临时产生的。
    </p>
    <p>
     选举过程例子
    </p>
    <p>
     假设有五台服务器组成的 Zookeeper 集群，它们的 id 从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动。
    </p>
    <p>
     ① 服务器 1 启动，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是 LOOKING 状态。
    </p>
    <p>
     ② 服务器 2 启动，它与最开始启动的服务器 1 进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以 id 值较大的服务器 2 胜出，但是由于没有达到超过半数以上的服务器都同意选举它（这个例子中的半数以上是 3），所以服务器 1、2 还是继续保持 LOOKING 状态。
    </p>
    <p>
     ③ 服务器 3 启动，根据前面的理论分析，服务器 3 成为服务器 1、2、3 中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的 Leader。
    </p>
    <p>
     ④ 服务器 4 启动，根据前面的分析，理论上服务器4应该是服务器 1、2、3、4 中最大的，但是由于前面已经有半数以上的服务器选举了服务器 3，所以它只能接收当小弟的命了。
    </p>
    <p>
     ⑤ 服务器 5 启动，同 4 一样当小弟。
    </p>
    <h3>
     <a id="32__206">
     </a>
     3.2 节点类型
    </h3>
    <p>
     持久（Persistent）
    </p>
    <p>
     客户端和服务器端断开连接后，创建的节点不删除
    </p>
    <p>
     短暂（Ephemeral）
    </p>
    <p>
     客户端和服务器端断开连接后，创建的节点自己删除
    </p>
    <p>
     节点类型
    </p>
    <p>
     ① 持久化目录节点
    </p>
    <p>
     客户端与 Zookeeper 断开连接后，该节点依旧存在。
    </p>
    <p>
     ② 持久化顺序编号目录节点
    </p>
    <p>
     客户端与 Zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号
    </p>
    <p>
     ③ 临时目录节点
    </p>
    <p>
     客户端与 Zookeeper 断开连接后，该节点被删除
    </p>
    <p>
     ④ 临时顺序编号目录节点
    </p>
    <p>
     客户端与 Zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号。
    </p>
    <p>
     说明： 创建 znode 时设置顺序标识，znode 名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。
     <br/>
     注意： 在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a7bb676db70518a1c5cce4075fe5ad27.png"/>
    </p>
    <h3>
     <a id="33_Stat__236">
     </a>
     3.3 Stat 结构体
    </h3>
    <p>
     czxid： 创建节点的事务 zxid
    </p>
    <p>
     每次修改 ZooKeeper 状态都会收到一个 zxid 形式的时间戳，也就是 ZooKeepe r事务 ID。
     <br/>
     事务 ID 是 ZooKeeper 中所有修改总的次序。每个修改都有唯一的 zxid，若 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。
    </p>
    <p>
     ctime： znode 被创建的毫秒数（从 1970 年开始）
    </p>
    <p>
     mzxid： znode 最后更新的事务 zxid
    </p>
    <p>
     mtime： znode 最后修改的毫秒数（从 1970 年开始）
    </p>
    <p>
     pZxid： znode 最后更新的子节点 zxid
    </p>
    <p>
     cversion ： znode 子节点变化号，znode 子节点修改次数
    </p>
    <p>
     dataversion： znode 数据变化号
    </p>
    <p>
     aclVersion： znode 访问控制列表的变化号
    </p>
    <p>
     ephemeralOwner： 如果是临时节点，这个是 znode 拥有者的 session id。如果不是临时节点则是 0。
    </p>
    <p>
     dataLength： znode 的数据长度
    </p>
    <p>
     numChildren： znode 子节点数量
    </p>
    <h3>
     <a id="34__263">
     </a>
     3.4 监听器原理
    </h3>
    <p>
     监听原理详解:
    </p>
    <p>
     ① 首先要有一个 main() 线程
     <br/>
     ② 在 main 线程中创建 Zokeeper 客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener） 。
     <br/>
     ③ 通过 connect 线程将注册的监听事件发送给 Zookeeper。
     <br/>
     ④ 在 Zookeeper 的注册监听器列表中将注册的监听事件添加到列表中。
     <br/>
     ⑤ Zookeeper 监听到有数据或路径变化，就会将这个消息发送给 listener 线程。
     <br/>
     ⑥ listener 线程内部调用了 process() 方法。
    </p>
    <p>
     常见的监听
     <br/>
     ① 监听节点数据的变化
     <br/>
     get -w path
     <br/>
     ② 监听子节点增减的变化
     <br/>
     ls -w path
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/1fe8ef4d75c6ab72536f42b097c7b2e4.png"/>
    </p>
    <h3>
     <a id="35__280">
     </a>
     3.5 写数据流程
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/57ac07316fd98ff4f81dc3e73aa07dfe.png"/>
    </p>
    <h2>
     <a id="4_Zookeeper__283">
     </a>
     4. Zookeeper 实战
    </h2>
    <h3>
     <a id="41__284">
     </a>
     4.1 客户端命令行操作
    </h3>
    <p>
     启动客户端
     <br/>
     zkCli.sh
     <br/>
     显示所有操作命令
     <br/>
     help
     <br/>
     查看当前 znode 中所包含的内容
     <br/>
     ls /
     <br/>
     ls2 /
     <br/>
     查看当前节点详细数据
     <br/>
     ls -s /
    </p>
    <p>
     分别创建 2 个普通节点
     <br/>
     create /animals “dog”
     <br/>
     create /animals/small “ant”
     <br/>
     获得节点的值
     <br/>
     get /animals
     <br/>
     get /animals/small
    </p>
    <p>
     创建短暂节点
     <br/>
     create -e /animals/big “elephant”
     <br/>
     创建带序号的节点
     <br/>
     create -s /animals/middle “hourse”
    </p>
    <p>
     修改节点数据值
     <br/>
     set /animals/small “bug”
     <br/>
     节点的值变化监听
     <br/>
     ① 在 slave1 主机上注册监听 /animals 节点数据变化
     <br/>
     get -w /animals
     <br/>
     ② 在 slave2 主机上修改 /animals 节点的数据
     <br/>
     set /animals “cat”
     <br/>
     ③ 观察 slave1 主机收到子节点变化的监听
    </p>
    <p>
     节点的子节点变化监听（路径变化）
     <br/>
     ① 在 slave1 主机上注册监听 /animals 节点的子节点变化
     <br/>
     ls -w /animals
     <br/>
     ② 在 slave2 主机 /animals 节点上创建子节点
     <br/>
     create /animals/mini “fly”
     <br/>
     ③ 观察 slave1 主机收到子节点变化的监听
    </p>
    <p>
     删除节点
     <br/>
     delete /animals/big
     <br/>
     递归删除节点
     <br/>
     deleteall /animals/mini
     <br/>
     查看节点状态
     <br/>
     stat /animals
    </p>
    <h3>
     <a id="42_API__332">
     </a>
     4.2 API 操作
    </h3>
    <h4>
     <a id="431_IDEA__333">
     </a>
     4.3.1 IDEA 环境搭建
    </h4>
    <p>
     创建一个 Maven 工程
     <br/>
     在 pom 文件中添加依赖
    </p>
    <pre><code>    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.5.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
    <p>
     在项目的 src/main/resources 目录下，新建一个文件，命名为 “log4j.properties”，在文件中填入:
     <br/>
     log4j.rootLogger=INFO, stdout
     <br/>
     log4j.appender.stdout=org.apache.log4j.ConsoleAppender
     <br/>
     log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
     <br/>
     log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n
     <br/>
     log4j.appender.logfile=org.apache.log4j.FileAppender
     <br/>
     log4j.appender.logfile.File=target/spring.log
     <br/>
     log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
     <br/>
     log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n
    </p>
    <h4>
     <a id="432__ZooKeeper__371">
     </a>
     4.3.2 创建 ZooKeeper 客户端
    </h4>
    <p>
     @SpringBootTest
     <br/>
     public class ZookeeperTest {
     <!-- -->
    </p>
    <pre><code>private static String connectString = "localhost:2181";
private static int sessionTimeout = 2000;
private static ZooKeeper zkClient;


@Test
public static void init() throws IOException {
    zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
        public void process(WatchedEvent watchedEvent) {
        }
    });
}
</code></pre>
    <p>
     }
    </p>
    <p>
     4.3.3 创建子节点
     <br/>
     先将上面的 init() 方法前面的注解 @Test 改为 @BeforeAll
    </p>
    <p>
     // 创建子节点
    </p>
    <pre><code>@SpringBootTest
public class ZookeeperTest {

    private static String connectString = "localhost:2181";
    private static int sessionTimeout = 2000;
    private static ZooKeeper zkClient;

    @BeforeAll
    public static void init() throws IOException {
        zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            public void process(WatchedEvent watchedEvent) {
            }
        });
    }

    @Test
    public void createNode() throws Exception {
// 参数1：要创建的节点的路径； 参数2：节点数据 ； 参数3：节点权限 ；参数4：节点的类型
        String path = zkClient.create("/demo1", "hello".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        System.out.println(path);
    }
}
</code></pre>
    <h4>
     <a id="434__418">
     </a>
     4.3.4 获取子节点并监听节点变化
    </h4>
    <pre><code>// 获取子节点并监听节点变化
@SpringBootTest
public class WatchTest {

    private static String connectString = "localhost:2181";
    private static int sessionTimeout = 2000;
    private static ZooKeeper zkClient;

    @Test
    public void getChildrenAndWatch() throws Exception {

        List&lt;String&gt; children = zkClient.getChildren("/", true);
        for (String child : children) {
            System.out.println(child);
        }
        // 延时阻塞
        Thread.sleep(Long.MAX_VALUE);
    }

    @BeforeAll
    public static void init() throws IOException {
        zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
            public void process(WatchedEvent watchedEvent) {
                List&lt;String&gt; children = null;
                try {
                    children = zkClient.getChildren("/", true);
                } catch (KeeperException e) {
                    e.printStackTrace();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                for (String child : children) {
                    System.out.println(child);
                }
            }
        });
    }
}
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/764f0fae19d935611709b6c389988e0c.png"/>
    </p>
    <h4>
     <a id="435__Znode__461">
     </a>
     4.3.5 判断 Znode 是否存在
    </h4>
    <p>
     // 判断znode是否存在
     <br/>
     @Test
     <br/>
     public void exist() throws Exception {
     <!-- -->
     <br/>
     Stat stat = zkClient.exists(“/animals”, false);
     <br/>
     System.out.println(stat == null ? “not exist” : “exist”);
     <br/>
     }
    </p>
    <h3>
     <a id="43__469">
     </a>
     4.3 监听服务器节点动态上下线案例
    </h3>
    <p>
     需求
    </p>
    <p>
     某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线。
    </p>
    <p>
     需求分析
    </p>
    <p>
     代码实现
    </p>
    <p>
     ① 先在集群上创建 /servers 节点
     <br/>
     create /servers “servers”
     <br/>
     ② 服务器端向 Zookeeper 注册代码
    </p>
    <p>
     package zookeeper;
    </p>
    <p>
     import org.apache.zookeeper.*;
    </p>
    <p>
     import java.io.IOException;
    </p>
    <p>
     public class DistributeServer {
     <!-- -->
    </p>
    <pre><code>private String connectString = "master:2181,slave1:2181,slave2:2181";
private int sessionTimeout = 2000;
private ZooKeeper zkClient;

public static void main(String[] args) throws Exception {
    args = new String[]{"slave1"};
    DistributeServer server = new DistributeServer();
    // 1.连接zookeeper集群
    server.getConnect();
    // 2.注册节点
    server.register(args[0]);
    // 3.业务逻辑处理
    server.business();
}

private void getConnect() throws IOException {
    zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
        public void process(WatchedEvent event) {

        }
    });
}

private void register(String hostname) throws KeeperException, InterruptedException {
    String path = zkClient.create("/servers/server", hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
    System.out.println(hostname + " is online");
}

private void business() throws InterruptedException {
    Thread.sleep(Long.MAX_VALUE);
}
</code></pre>
    <p>
     }
    </p>
    <p>
     ③ 客户端代码
    </p>
    <p>
     package zookeeper;
    </p>
    <p>
     import org.apache.zookeeper.KeeperException;
     <br/>
     import org.apache.zookeeper.WatchedEvent;
     <br/>
     import org.apache.zookeeper.Watcher;
     <br/>
     import org.apache.zookeeper.ZooKeeper;
    </p>
    <p>
     import java.io.IOException;
     <br/>
     import java.util.ArrayList;
     <br/>
     import java.util.List;
    </p>
    <p>
     public class DistributeClient {
     <!-- -->
    </p>
    <pre><code>private String connectString = "master:2181,slave1:2181,slave2:2181";
private int sessionTimeout = 2000;
private ZooKeeper zkClient;


public static void main(String[] args) throws Exception {
    DistributeClient client = new DistributeClient();
    // 1.连接zookeeper集群
    client.getConnect();
    // 2.注册监听
    client.getChildren();
    // 3.业务逻辑处理
    client.business();
}

private void getConnect() throws IOException {
    zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() {
        public void process(WatchedEvent event) {
            try {
                getChildren();
            } catch (KeeperException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
}

private void getChildren() throws KeeperException, InterruptedException {
    List&lt;String&gt; children = zkClient.getChildren("/servers", true);
    // 存储服务器节点主机名称集合
    ArrayList&lt;String&gt; hosts = new ArrayList&lt;String&gt;();
    for (String child : children) {
        byte[] data = zkClient.getData("/servers/" + child, false, null);
        hosts.add(new String(data));
    }
    System.out.println(hosts);
}

private void business() throws InterruptedException {
    Thread.sleep(Long.MAX_VALUE);
}
</code></pre>
    <p>
     }
    </p>
    <h2>
     <a id="5_zookeeper_583">
     </a>
     5 zookeeper框架
    </h2>
    <h3>
     <a id="51_orgapachezookeeper_584">
     </a>
     5.1 org.apache.zookeeper
    </h3>
    <h3>
     <a id="52_zkclient_585">
     </a>
     5.2 zkclient
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/56e651ad7e9513a8bfe1faca514d3663.png"/>
    </p>
    <h4>
     <a id="521__588">
     </a>
     5.2.1 简介
    </h4>
    <p>
     ZkClient 是由 Datameer 的工程师开发的开源客户端，对 Zookeeper 的原生 API 进行了包装，实现了超时重连、Watcher 反复注册等功能。
     <br/>
     在使用 ZooKeeper 的 Java 客户端时，经常需要处理几个问题：重复注册 watcher、session失效重连、异常处理。
     <br/>
     IZKConnection：是一个ZkClient与Zookeeper之间的一个适配器；在代码里直接使用的是ZKClient，实质上还是委托了zookeeper来处理了。
    </p>
    <p>
     在ZKClient中，根据事件类型，分为
    </p>
    <p>
     节点事件（数据事件），对应的事件处理器是IZKDataListener；
     <br/>
     子节点事件，对应的事件处理器是IZKChildListener；
     <br/>
     Session事件，对应的事件处理器是IZKStatusListener；
     <br/>
     ZkEventThread：是专门用来处理事件的线程
    </p>
    <p>
     目前已经运用到了很多项目中，知名的有 Dubbo、Kafka、Helix。
    </p>
    <h4>
     <a id="522_Maven_602">
     </a>
     5.2.2 Maven依赖
    </h4>
    <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.101tec&lt;/groupId&gt;
    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
    &lt;version&gt;0.11&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    <h4>
     <a id="523_ZkClient__610">
     </a>
     5.2.3 ZkClient 的设计
    </h4>
    <p>
     从上述结构上看，IZKConnection 是一个 ZkClient 与 ZooKeeper 之间的一个适配器。在代码里直接使用的是 ZKClient，其实质还是委托了 zookeeper 来处理了。
    </p>
    <p>
     使用 ZooKeeper 客户端来注册 watcher 有几种方法: 1、创建 ZooKeeper 对象时指定默认的 Watcher，2、getData()，3、exists()，4、 getchildren。其中 getdata,exists 注册的是某个节点的事件处理器(watcher)，getchildren 注册的是子节点的事件处理器(watcher)。而在 ZKClient 中，根据事件类型，分为了节点事件(数据事件)、子节点事件。对应的事件处理器则是 IZKDataListener 和 IZKChildListener。另外加入了 Session 相关的事件和事件处理器。
    </p>
    <p>
     ZkEventThread 是专门用来处理事件的线程。
    </p>
    <h4>
     <a id="524__616">
     </a>
     5.2.4 重要处理流程说明
    </h4>
    <p>
     启动 ZKClient
    </p>
    <p>
     在创建 ZKClient 对象时，就完成了到 ZooKeeper 服务器连接的建立。具体过程是这样的：
    </p>
    <p>
     启动时，指定好 connection string，连接超时时间，序列化工具等。
     <br/>
     创建并启动 eventThread，用于接收事件，并调度事件监听器 Listener 的执行。
     <br/>
     连接到 zookeeper 服务器，同时将 ZKClient 自身作为默认的 Watcher。
     <br/>
     为节点注册Watcher：
    </p>
    <p>
     ZooKeeper 的三个方法:getData、getChildren、exists.
    </p>
    <p>
     ZKClient 都提供了相应的代理方法。就拿 exists 来看:
    </p>
    <p>
     可以看到，是否注册 watcher，由 hasListeners(path)来决定的。
    </p>
    <p>
     hasListeners 就是看有没有与该数据节点绑定的 listener。
    </p>
    <p>
     所以，默认情况下，都会自动的为指定的 path 注册 watcher，并且是默认的 watcher (ZKClient)。怎么才能让 hasListeners 判定值为 true 呢，也就是怎么才能为 path 绑定 Listener 呢?
     <br/>
     ZKClient提供了订阅功能:
    </p>
    <p>
     一个新建的会话，只需要在取得响应的数据节点后，调用 subscribteXxx 就可以订阅上相应的事件了。
    </p>
    <h4>
     <a id="525_Watcher_638">
     </a>
     5.2.5 客户端处理变更（Watcher通知）
    </h4>
    <p>
     前面已经知道，ZKClient 是默认的 Watcher，并且在为各个数据节点注册的 Watcher 都是这个默认的 Watcher。那么该是如何将各种事件通知给相应的 Listener 呢?
    </p>
    <p>
     处理过程大致可以概括为下面的步骤:
    </p>
    <p>
     判断变更类型:变更类型分为 State 变更、ChildNode 变更(创建子节点、删除子节点、修改子节点数据)、NodeData 变更(创建指定 node，删除节点，节点数据变更)。
     <br/>
     取出与 path 关联的 Listeners，并为每一个 Listener 创建一个 ZKEvent，将 ZkEvent 交给 ZkEventThread 处理。
     <br/>
     ZkEventThread 线程，拿到 ZkEvent 后，只需要调用 ZkEvent 的 run 方法进行处理。 从这里也可以知道，具体的怎么如何调用 Listener，还要依赖于 ZkEvent 的 run()实现了。
     <br/>
     注册监听 watcher：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        接口类
       </th>
       <th>
        注册监听方法
       </th>
       <th>
        解除监听方法
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        IZkChildListener(子节点)
       </td>
       <td>
        ZkClient的subscribeChildChanges方法
       </td>
       <td>
        ZkClient 的unsubscribeChildChanges 方法
       </td>
      </tr>
      <tr>
       <td>
        IZkDataListener(数据)
       </td>
       <td>
        ZkClient 的subscribeDataChanges 方法
       </td>
       <td>
        ZkClient 的 unsubscribeDataChanges 方法
       </td>
      </tr>
      <tr>
       <td>
        IZkStateListener(客户端状 态)
       </td>
       <td>
        ZkClient 的 subscribeStateChanges 方 法
       </td>
       <td>
        ZkClient 的 unsubscribeStateChanges 方法
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     在 ZkClient 中客户端可以通过注册相关的事件监听来实现对 Zookeeper 服务端时间的订阅。
    </p>
    <p>
     其中 ZkClient 提供的监听事件接口有以下几种:
    </p>
    <p>
     其中 ZkClient 还提供了一个 unsubscribeAll 方法，来解除所有监听。
    </p>
    <p>
     Zookeeper 中提供的变更操作有:节点的创建、删除，节点数据的修改：
    </p>
    <p>
     创建操作，数据节点分为四种，ZKClient 分别为他们提供了相应的代理:
    </p>
    <p>
     删除节点的操作:
    </p>
    <p>
     修改节点数据的操作:
    </p>
    <p>
     writeDataReturnStat():写数据并返回数据的状态。
     <br/>
     updateDataSerialized():修改已序列化的数据。执行过程是:先读取数据，然后使用DataUpdater 对数据修改，最后调用 writeData 将修改后的数据发送给服务端。
    </p>
    <h4>
     <a id="526__669">
     </a>
     5.2.6 序列化处理
    </h4>
    <p>
     ZooKeeper 中，会涉及到序列化、反序列化的操作有两种:getData、setData。在 ZKClient 中，分别用 readData、writeData 来替代了。
    </p>
    <p>
     对于 readData:先调用 zookeeper 的 getData，然后进行使用 ZKSerializer 进行反序列化工 作。
    </p>
    <p>
     对于 writeData:先使用 ZKSerializer 将对象序列化后，再调用 zookeeper 的 setData。
    </p>
    <h4>
     <a id="527_ZkClientZooKeeper_675">
     </a>
     5.2.7 ZkClient如何解决使用ZooKeeper客户端遇到的问题的呢?
    </h4>
    <p>
     Watcher 自动重注册:这个要是依赖于 hasListeners()的判断，来决定是否再次注册。如果对此有不清晰的，可以看上面的流程处理的说明。
     <br/>
     Session 失效重连:如果发现会话过期，就先关闭已有连接，再重新建立连接。
     <br/>
     异常处理:对比 ZooKeeper 和 ZKClient，就可以发现 ZooKeeper 的所有操作都是抛异常 的，而 ZKClient 的所有操作，都不会抛异常的。在发生异常时，它或做日志，或返回空， 或做相应的 Listener 调用。
     <br/>
     相比于 ZooKeeper 官方客户端，使用 ZKClient 时，只需要关注实际的 Listener 实现即可。所 以这个客户端，还是推荐大家使用的。
     <br/>
     <a href="https://www.cnblogs.com/jinchengll/p/12333213.html" rel="nofollow">
      https://www.cnblogs.com/jinchengll/p/12333213.html
     </a>
    </p>
    <h4>
     <a id="528_API_681">
     </a>
     5.2.8 API介绍
    </h4>
    <p>
     启动ZKClient：在创建ZKClient对象时，就完成了到ZooKeeper服务器连接的建立
     <br/>
     1、启动时，制定好connection string，连接超时时间，序列化工具等
     <br/>
     2、创建并启动eventThread，用于接收事件，并调度事件监听器Listener的执行
     <br/>
     3、连接到Zookeeper服务器，同时将ZKClient自身作为默认的Watcher
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/249f770da5aa6424101c29c390eebc6d.png"/>
     <br/>
     为节点注册Watcher
     <br/>
     Zookeeper 原始API的三个方法：getData，getChildren、exists，ZKClient都提供了相应的代理方法，比如exists，
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/e36e1ccb6b11319aa7f91d3b2ea28827.png"/>
     <br/>
     hasListeners是看有没有与该数据节点绑定的listener
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/83c720303560a68238f23376571ffc68.png"/>
     <br/>
     所以，默认情况下，都会自动的为指定的path注册watcher，并且是默认的watcher（ZKClient），那么怎样才能让hasListeners值为true呢，也就是怎么才能为path绑定Listener呢？
     <br/>
     ZKClient提供了订阅功能，一个新建的会话，只需要在取得响应的数据节点后，调用subscribeXXX就可以订阅上相应的事件了。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d0656f2f5d158933bedeb926d3bd1855.png"/>
    </p>
    <h4>
     <a id="529_demo_697">
     </a>
     5.2.9 demo
    </h4>
    <ol>
     <li>
      createParents可以递归创建节点（public void createPersistent(String path, boolean createParents)）
     </li>
     <li>
      无需注册watcher（前面也说了，ZKClient帮我们做好了）
     </li>
     <li>
      节点内容可以传任意类型数据
     </li>
     <li>
      可以自定义内容的序列化和反序列化
     </li>
     <li>
      在没指定zkSerializer时，默认使用java自动的序列化和反序列化
     </li>
    </ol>
    <pre><code>public class ZkClientCrud&lt;T&gt; {

    ZkClient zkClient ;
    final static Logger logger = LoggerFactory.getLogger(ZkClientCrud.class);

    public ZkClientCrud(ZkSerializer zkSerializer) {
        logger.info("链接zk开始");
        // zkClient=new ZkClient(ZookeeperUtil.connectString,ZookeeperUtil.sessionTimeout);
        zkClient=new ZkClient(ZookeeperUtil.connectString,ZookeeperUtil.sessionTimeout,ZookeeperUtil.sessionTimeout,zkSerializer);
    }


    public void createEphemeral(String path,Object data){

        zkClient.createEphemeral(path,data);
    }

    /***
     * 支持创建递归方式
     * @param path
     * @param createParents
     */
    public void createPersistent(String path,boolean createParents){

        zkClient.createPersistent(path,createParents);
    }

    /***
     * 创建节点 跟上data数据
     * @param path
     * @param data
     */
    public void createPersistent(String path,Object data){

        zkClient.createPersistent(path,data);
    }

    /***
     * 子节点
     * @param path
     * @return
     */
    public  List&lt;String&gt; getChildren(String path){
        return zkClient.getChildren(path);

    }

    public  T readData(String path){
        return zkClient.readData(path);
    }

    public  void  writeData(String path,Object data){
        zkClient.writeData(path,data);
    }

    //递归删除
    public  void deleteRecursive(String path){
        zkClient.deleteRecursive(path);

    }
}
</code></pre>
    <pre><code>public class ZkClientCrudTest {
    final static Logger logger = LoggerFactory.getLogger(ZkClientCrudTest.class);
    public static void main(String[] args) {
        ZkClientCrud&lt;User&gt; zkClientCrud=new ZkClientCrud&lt;User&gt;(new SerializableSerializer());
        String path="/root";
        zkClientCrud.deleteRecursive(path);
        zkClientCrud.createPersistent(path,"hi");
     /*  zkClientCrud.createPersistent(path+"/a/b/c",true);//递归创建 但是不能设在value
       //zkClientCrud.createPersistent(path,"hi");
        logger.info(zkClientCrud.readData(path));
        //更新
        zkClientCrud.writeData(path,"hello");
        logger.info(zkClientCrud.readData(path));
        logger.info(String.valueOf(zkClientCrud.getChildren(path)));
        //子节点
        List&lt;String&gt; list=zkClientCrud.getChildren(path);
        for(String child:list){
            logger.info("子节点:"+child);
        }*/

        User user=new User();
        user.setId(1);
        user.setName("张三");
        zkClientCrud.writeData(path,user);
        System.out.println(zkClientCrud.readData(path).getName());;
    }
}
</code></pre>
    <pre><code>@Data
@NoArgsConstructor
@AllArgsConstructor
public class User implements Serializable {

    private Integer id;
    private String name;
}
</code></pre>
    <p>
     Watcher
    </p>
    <pre><code>public class ZkClientWatcher {
    ZkClient zkClient;

    public ZkClientWatcher() {
        zkClient = new ZkClient(new ZkConnection(ZookeeperUtil.connectString), ZookeeperUtil.sessionTimeout);
    }
    
    public void createPersistent(String path, Object data) {
        zkClient.createPersistent(path, data);
    }


    public void writeData(String path, Object object) {
        zkClient.writeData(path, object);

    }

    public void delete(String path) {
        zkClient.delete(path);

    }

    public boolean exists(String path) {
        return zkClient.exists(path);

    }

    public void deleteRecursive(String path) {
        zkClient.deleteRecursive(path);

    }

    //对父节点添加监听数据变化。
    public void subscribe(String path) {


        zkClient.subscribeDataChanges(path, new IZkDataListener() {
            @Override
            public void handleDataChange(String dataPath, Object data) throws Exception {
                System.out.printf("变更的节点为:%s,数据：%s\r\n", dataPath, data);
            }

            @Override
            public void handleDataDeleted(String dataPath) throws Exception {
                System.out.printf("删除的节点为:%s\r\n", dataPath);
            }
        });
    }

    //对父节点添加监听子节点变化。
    public void subscribe2(String path) {
        zkClient.subscribeChildChanges(path, new IZkChildListener() {
            @Override
            public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception {
                System.out.println("父节点: " + parentPath + ",子节点:" + currentChilds + "\r\n");
            }
        });
    }
    
    //客户端状态
    public void subscribe3(String path) {
        zkClient.subscribeStateChanges(new IZkStateListener() {
            @Override
            public void handleStateChanged(Watcher.Event.KeeperState state) throws Exception {
                if (state == Watcher.Event.KeeperState.SyncConnected) {
                    //当我重新启动后start，监听触发
                    System.out.println("连接成功");
                } else if (state == Watcher.Event.KeeperState.Disconnected) {
                    System.out.println("连接断开");//当我在服务端将zk服务stop时，监听触发
                } else
                    System.out.println("其他状态" + state);
            }

            @Override
            public void handleNewSession() throws Exception {
                System.out.println("重建session");

            }

            @Override
            public void handleSessionEstablishmentError(Throwable error) throws Exception {

            }
        });

    }

  /*  @Override
    public void handleDataChange(String dataPath, Object data) throws Exception {
    }

    @Override
    public void handleDataDeleted(String dataPath) throws Exception {

    }*/
}

</code></pre>
    <pre><code>public class ZkClientWatcherTest {
    public static void main(String[] args) throws InterruptedException {
        ZkClientWatcher zkClientWatche=new ZkClientWatcher();
        String path="/root";
        zkClientWatche.deleteRecursive(path);
        zkClientWatche.createPersistent(path,"hello");
        zkClientWatche.subscribe(path);
        zkClientWatche.subscribe2(path);
        // zkClientWatche.subscribe3(path);//需要启服务
        // Thread.sleep(Integer.MAX_VALUE);
        zkClientWatche.createPersistent(path+"/root2","word");
        TimeUnit.SECONDS.sleep(1);
        zkClientWatche.writeData(path,"hi");
        TimeUnit.SECONDS.sleep(1);
        //zkClientWatche.delete(path);//如果目录下有内容 不能删除 会报 Directory not empty for /root的异常
        zkClientWatche.deleteRecursive(path);
        TimeUnit.SECONDS.sleep(1); //这个main线程就结束

    }
}
</code></pre>
    <pre><code>public class ZookeeperUtil {

    /** zookeeper服务器地址 */
//    public static final String connectString = "192.168.0.101:2181,192.168.0.102:2181,192.168.0.104:2181";
    public static final String connectString = "localhost:2181";
    /** 定义session失效时间 */
    public static final int sessionTimeout = 5000;
    public static final String path = "/root";
}
</code></pre>
    <h3>
     <a id="53_Curator_939">
     </a>
     5.3 Curator
    </h3>
    <h4>
     <a id="531__940">
     </a>
     5.3.1 简介
    </h4>
    <p>
     zookeeper不是为高可用性设计的，但它使用ZAB协议达到了极高的一致性。所以它经常被选作注册中心、配置中心、分布式锁等场景。
     <br/>
     它的性能是非常有限的，而且API并不是那么好用。xjjdog倾向于使用基于Raft协议的Etcd或者Consul，它们更加轻量级一些。
     <br/>
     Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator解决了很多zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册wathcer和NodeExistsException 异常等。
    </p>
    <p>
     Zookeeper 原生API问题：
     <br/>
     1.超时重连，不支持自动，需要手动操作
     <br/>
     2.Watch注册一次后会失效
     <br/>
     3.不支持递归创建节点
    </p>
    <p>
     Zookeeper API 升级版 Curator：
     <br/>
     1.解决watcher的注册一次就失效
     <br/>
     2.提供更多解决方案并且实现简单
     <br/>
     3.提供常用的ZooKeeper工具类
     <br/>
     4.编程风格更爽，点点点就可以了
     <br/>
     5.可以递归创建节点等
    </p>
    <p>
     Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes。
    </p>
    <h4>
     <a id="532__958">
     </a>
     5.3.2 版本问题
    </h4>
    <p>
     Curator2.x.x版本兼容Zookeeper的3.4.x和3.5.x。
     <br/>
     Curator3.x.x只兼容Zookeeper 3.5.x，并且提供了一些诸如动态重新配置、watch删除等新特性。
     <br/>
     Curator4 统一对 ZooKeeper 3.4.x 和 3.5.x 的支持
    </p>
    <h4>
     <a id="533_CuratorFramework_962">
     </a>
     5.3.3 CuratorFramework
    </h4>
    <p>
     Curator-Framework是ZooKeeper Client更高的抽象API，最佳核心的功能就是自动连接管理:
     <br/>
     当ZooKeeper客户端内部出现异常, 将自动进行重连或重试, 该过程对外几乎完全透明
     <br/>
     监控节点数据变化事件NodeDataChanged，需要时调用updateServerList()方法
     <br/>
     Curator recipes自动移除监控
    </p>
    <p>
     更加清晰的API
     <br/>
     简化了ZooKeeper原生的方法, 事件等, 提供流式fluent的接口，提供Recipes实现 : 选举，共享锁， 路径cache， 分布式队列，分布式优先队列等。
    </p>
    <h4>
     <a id="534_curatorrecipes_970">
     </a>
     5.3.4 curator-recipes
    </h4>
    <p>
     curator-recipes：封装了一些高级特性，如：Cache事件监听、 Elections选举、分布式锁、分布式计数器、分布式Barrier、Queues队列等
    </p>
    <h4>
     <a id="535__972">
     </a>
     5.3.5 知识点
    </h4>
    <p>
     1.使用curator建立与zk的连接
     <br/>
     2.使用curator添加/递归添加节点
     <br/>
     3.使用curator删除/递归删除节点
     <br/>
     4.使用curator创建/验证 ACL(访问权限列表)
     <br/>
     5.使用curator监听 单个/父 节点的变化(watch事件)
     <br/>
     6.基于curator实现Zookeeper分布式锁(需要掌握基本的多线程知识)
     <br/>
     7.基于curator实现分布式计数器
    </p>
    <h4>
     <a id="536_Maven_980">
     </a>
     5.3.6 Maven依赖
    </h4>
    <pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
	&lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
	&lt;!--建议和本地安装版本保持一致--&gt;
	&lt;version&gt;3.7.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
	&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
	&lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
	&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
	&lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
    <h4>
     <a id="537_api_999">
     </a>
     5.3.7 api
    </h4>
    <pre><code>import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.RetryNTimes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ZkConnectCuratorUtil {
    final static Logger log = LoggerFactory.getLogger(ZkConnectCuratorUtil.class);
    public CuratorFramework zkClient = null; //zk的客户端工具Curator（在本类通过new实例化的是，自动start）
    private static final int MAX_RETRY_TIMES = 3; //定义失败重试次数
    private static final int BASE_SLEEP_TIME_MS = 5000; //连接失败后，再次重试的间隔时间 单位:毫秒
    private static final int SESSION_TIME_OUT = 1000000; //会话存活时间,根据业务灵活指定 单位:毫秒
    private static final String ZK_SERVER_IP_PORT = "localhost:2181";//Zookeeper服务所在的IP和客户端端口
    private static final String NAMESPACE = "workspace";//指定后，默认操作的所有的节点都会在该工作空间下进行

    //本类通过new ZkCuratorUtil()时，自动连通zkClient
    public ZkConnectCuratorUtil() {
        RetryPolicy retryPolicy = new RetryNTimes(MAX_RETRY_TIMES, BASE_SLEEP_TIME_MS);//首次连接失败后，重试策略
        zkClient = CuratorFrameworkFactory.builder()
                //.authorization("digest", "root:root".getBytes())//登录超级管理(需单独配)
                .connectString(ZK_SERVER_IP_PORT)
                .sessionTimeoutMs(SESSION_TIME_OUT)
                .retryPolicy(retryPolicy)
                .namespace(NAMESPACE).build();
        zkClient.start();
    }
    public void closeZKClient() {
        if (zkClient != null) {
            this.zkClient.close();
        }
    }

    public static void main(String[] args) {
        ZkConnectCuratorUtil zkUtil=new ZkConnectCuratorUtil();
        boolean ifStarted=zkUtil.zkClient.isStarted();
        System.out.println("当前客户的状态：" + (ifStarted ? "连接中" : "已关闭"));
        zkUtil.closeZKClient();
        boolean ifClose = zkUtil.zkClient.isStarted();
        System.out.println("当前客户的状态：" + (ifClose ? "连接成功" : "已关闭"));
    }
}
</code></pre>
    <pre><code>public class CuratorDao {

    //使用curator(递归)添加节点
    //级联创建节点（原生API不支持/后台客户端也不支持，但是Curator支持）
    public static void createNodes(CuratorFramework zkClient, String nodePath, String nodeData) throws Exception {
        zkClient.create()
                .creatingParentContainersIfNeeded()//创建父节点,如果需要的话
                .withMode(CreateMode.PERSISTENT) //指定节点是临时的，还是永久的
                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE) //指定节点的操作权限
                .forPath(nodePath, nodeData.getBytes());
        System.out.println(nodePath + "节点已成功创建…");
    }

    //使用curator(递归)删除节点
    //删除node节点及其子节点
    public static void deleteNodeWithChild(CuratorFramework zkClient, String nodePath) throws Exception {
        zkClient.delete()
                .guaranteed()                //保证删除：如果删除失败，那么在后端还是继续会删除，直到成功
                .deletingChildrenIfNeeded()  //级联删除子节点
                //.withVersion(1)//版本号可以据需使用
                .forPath(nodePath);
        System.out.println(nodePath + "节点已删除成功…");
    }

    //使用curator更新节点数据
    //更新节点data数据
    public static void updateNodeData(CuratorFramework zkClient, String nodePath, String nodeNewData) throws Exception {
        zkClient.setData().withVersion(0).forPath(nodePath, nodeNewData.getBytes());//版本号据需使用，默认可以不带
        System.out.println(nodePath + "节点数据已修改成功…");
    }

    //使用curator查询节点数据
    //查询node节点数据
    public static void getNodeData(CuratorFramework zkClient, String nodePath) throws Exception {
        Stat stat = new Stat();
        byte[] data = zkClient.getData().storingStatIn(stat).forPath(nodePath);
        System.out.println("节点" + nodePath + "的数据为" + new String(data));
        System.out.println("节点的版本号为：" + stat.getVersion());
    }

    //使用curator查询节点的子节点
    //打印node子节点
    public static void printChildNodes(CuratorFramework zkClient, String parentNodePath) throws Exception {
        List&lt;String&gt; childNodes = zkClient.getChildren().forPath(parentNodePath);
        System.out.println("开始打印子节点");
        for (String str : childNodes) {
            System.out.println(str);
        }
    }

    //使用curator判断节点是否存在
    //判断node节点是否存在
    public static void checkNodeExists(CuratorFramework zkClient, String nodePath) throws Exception {
        Stat stat = zkClient.checkExists().forPath(nodePath);
        System.out.println(null == stat ? "节点不存在" : "节点存在");
    }

    /**************使用Curator高级API特性之Cache缓存监控节点变化*************/


    @Test
    public void test() throws Exception {
        ZkConnectCuratorUtil zkUtil = new ZkConnectCuratorUtil();
        CuratorFramework zkClient = zkUtil.zkClient;
//        CuratorDao.createNodes(zkClient,"/xiaosi/test","siguogui");
//        CuratorDao.deleteNodeWithChild(zkClient,"/xiaosi/test");
//        CuratorDao.updateNodeData(zkClient,"/xiaosi/test","xiaosi");
//        CuratorDao.getNodeData(zkClient,"/xiaosi/test");
//        CuratorDao.printChildNodes(zkClient, "/xiaosi");
        CuratorDao.checkNodeExists(zkClient, "/xiaosi");
    }

}
</code></pre>
    <h4>
     <a id="538_CuratorAPICache_1119">
     </a>
     5.3.8 使用Curator高级API特性之Cache缓存监控节点变化
    </h4>
    <p>
     cache是一种缓存机制，可以借助cache实现监听。
     <br/>
     简单来说，cache在客户端缓存了znode的各种状态，当感知到zk集群的znode状态变化，会触发event事件，注册的监听器会处理这些事件。
     <br/>
     curator支持的cache种类有4种Path Cache，Node Cache，Tree Cache，Curator Cache
     <br/>
     1）Path Cache
     <br/>
     Path Cache用来观察ZNode的子节点并缓存状态，如果ZNode的子节点被创建，更新或者删除，那么Path Cache会更新缓存，并且触发事件给注册的监听器。
     <br/>
     它是通过PathChildrenCache类来实现的，监听器注册是通过PathChildrenCacheListener。
     <br/>
     2）Node Cache
     <br/>
     Node Cache用来观察ZNode自身，如果ZNode节点本身被创建，更新或者删除，那么Node Cache会更新缓存，并触发事件给注册的监听器。
     <br/>
     它是通过NodeCache类来实现的，监听器对应的接口为NodeCacheListener。
     <br/>
     3）Tree Cache
     <br/>
     Tree Cache是上两种的合体，Tree Cache观察的是自身+所有子节点的所有数据，并缓存所有节点数据。
     <br/>
     它是通过TreeCache类来实现的，监听器对应的接口为TreeCacheListener。
     <br/>
     4）Curator Cache （ requires ZooKeeper 3.6+）
     <br/>
     Curator Cache，是在zk3.6新版本添加的特性，该版本的出现是为了逐步淘汰上面3监听。
     <br/>
     它是通过CuratorCache类来实现的，监听器对应的接口为CuratorCacheListener。
    </p>
    <p>
     Curator一次性的watch
    </p>
    <pre><code>import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.zookeeper.WatchedEvent;
 
public class MyCuratorWatcher implements CuratorWatcher {
	@Override
	public void process(WatchedEvent event) throws Exception {
		System.out.println("触发watcher，节点路径为：" + event.getPath());
		switch (event.getType()) {
		case NodeCreated:
			break;
		default:
			break;
		}
	}
}

 //一次性的watch
    public static void watchOnce(CuratorFramework zkClient,String nodePath) throws Exception {
        zkClient.getData().usingWatcher(new MyCuratorWatcher()).forPath(nodePath);
    }
</code></pre>
    <p>
     NodeCache监听当前节点变化,通过NodeCacheListener接口持续监听节点的变化来实现
    </p>
    <pre><code>//持续监听的watch
	public static void watchForeverByNodeCache(CuratorFramework zkClient,String nodePath) throws Exception {
		final NodeCache nodeCache=new NodeCache(zkClient, nodePath);//把监听节点，转换为nodeCache
		nodeCache.start(false);//默认为false  设置为true时，会自动把节点数据存放到nodeCache中；设置为false时，初始化数据为空
		ChildData cacheData=nodeCache.getCurrentData();	
		if(null==cacheData) {
			System.out.println("NodeCache节点的初始化数据为空……");
		}else {
			System.out.println("NodeCache节点的初始化数据为"+new String(cacheData.getData()));
		}
		
		//设置循环监听
		nodeCache.getListenable().addListener(new NodeCacheListener() {
			@Override
			public void nodeChanged() throws Exception {
				ChildData cdata=nodeCache.getCurrentData();
				if(null==cdata) {
					System.out.println("节点发生了变化，可能刚刚被删除！");
					nodeCache.close();//关闭监听
				}else {
					String data=new String(cdata.getData());
					String path=nodeCache.getCurrentData().getPath();
					System.out.println("节点路径"+path+"数据发生了变化，最新数据为："+data);
				}
			}
		});
	}
</code></pre>
    <p>
     PathChildrenCache只监听子节点变化
     <br/>
     通过PathChildrenCacheListener接口持续监听子节点来实现
    </p>
    <pre><code>//持续监听watch子节点的任何变化
	public static void watchForeverByPathChildrenCache(CuratorFramework zkClient,String nodePath) throws Exception {
		final PathChildrenCache childrenCache=new PathChildrenCache(zkClient, nodePath,true);//把监听节点，转换为childrenCache
		/**
		 * StartMode:初始化方式
		 *	POST_INITIALIZED_EVENT: 异步初始化，初始化之后会触发事件(会进入下面的第一个case)
		 *	NORMAL:异步初始化 (不会进入下面的第一个case)
		 *	BUILD_INITIAL_CACHE: 同步初始化(把节点数据同步缓存到Cache中)
		 */
		childrenCache.start(StartMode.NORMAL);
		List&lt;ChildData&gt; childDataList=childrenCache.getCurrentData();
		System.out.println("当前节点所有子节点的数据列表如下：");
		for (ChildData childData : childDataList) {
			System.out.println(new String(childData.getData()));
		}
		
		childrenCache.getListenable().addListener(new PathChildrenCacheListener() {
			
			@Override
			public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
				switch (event.getType()) {
				case INITIALIZED:
					System.out.println("子节点初始化OK…");
					break;
				case CHILD_ADDED:
					System.out.println("子节点"+event.getData().getPath()+"已被成功添加，数据data="+new String(event.getData().getData()));
					break;
				case CHILD_UPDATED:
					System.out.println("子节点"+event.getData().getPath()+"数据发生变化，新数据data="+new String(event.getData().getData()));
					break;
				case CHILD_REMOVED:
					System.out.println("子节点"+event.getData().getPath()+"已被移除~");
					break;
				case CONNECTION_RECONNECTED:
					System.out.println("正在尝试重新建立连接…");
					break;
				case CONNECTION_SUSPENDED:
					System.out.println("连接状态被暂时停止…");
					break;
				default:
					break;
				}
			}
		});
	}
</code></pre>
    <p>
     TreeCache是上两者的合体，既监听自身，也监听所有子节点变化
     <br/>
     通过TreeCacheListener接口来实现
    </p>
    <pre><code>public static void treeCache(CuratorFramework zkClient) throws Exception {
	    final String path = "/treeChildrenCache";
	    final TreeCache treeCache = new TreeCache(zkClient, path);
	 
	    treeCache.getListenable().addListener(new TreeCacheListener() {
			@Override
			public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {
				 switch (event.getType()){
		            case NODE_ADDED:
		                System.out.println("节点变动触发：NODE_ADDED:" + event.getData().getPath());
		                break;
		            case NODE_REMOVED:
		                System.out.println("节点变动触发：NODE_REMOVED:" + event.getData().getPath());
		                break;
		            case NODE_UPDATED:
		                System.out.println("节点变动触发：NODE_UPDATED:" + event.getData().getPath());
		                break;
		            case CONNECTION_LOST:
		                System.out.println("节点变动触发：CONNECTION_LOST:" + event.getData().getPath());
		                break;
		            case CONNECTION_RECONNECTED:
		                System.out.println("节点变动触发：CONNECTION_RECONNECTED:" + event.getData().getPath());
		                break;
		            case CONNECTION_SUSPENDED:
		                System.out.println("节点变动触发：CONNECTION_SUSPENDED:" + event.getData().getPath());
		                break;
		            case INITIALIZED:
		                System.out.println("节点变动触发：INITIALIZED:" + event.getData().getPath());
		                break;
		            default:
		                break;
		        }
			}
		});
        //据需可以继续做一些其他的增删改操作
	    zkClient.create().withMode(CreateMode.PERSISTENT).forPath(path);
	    Thread.sleep(1000);
	    
	    zkClient.create().withMode(CreateMode.PERSISTENT).forPath(path + "/c1");
	    Thread.sleep(1000);
	    
	    zkClient.delete().forPath(path + "/c1");
	    Thread.sleep(1000);
	    
	    zkClient.delete().forPath(path);
	    Thread.sleep(1000);
	    zkClient.close();
	}
</code></pre>
    <p>
     Curator Cache，是在zk3.6新版本添加的特性，Curator需5.
     <em>
      +
      <br/>
      它的出现是为了替换以上3个监听（NodeCache、PathCache、TreeCache），它通过CuratorCacheListener.builder().for
     </em>
     **来选择对应的监听。最后再通过curatorCache.listenable().addListener(listener);注册监听。
    </p>
    <pre><code>public static void curatorCache1(CuratorFramework zkClient) {
		final String path = "/curatorCache";
		CuratorCache curatorCache = CuratorCache.build(zkClient, path);
		curatorCache.listenable().addListener(new CuratorCacheListener() {
			@Override
			public void event(Type type, ChildData oldData, ChildData newdata) {
				 switch (type) {
				case NODE_CREATED:
					//各种判断
					break;
 
				default:
					break;
				}
		    }
		});
	}
 
 
public static void curatorCache2(CuratorFramework zkClient) throws InterruptedException {
		final String path = "/curatorCache";
		CuratorCache curatorCache = CuratorCache.builder(zkClient,path).build();
		 
		//构建监听器
		//新旧对照：
		//1.node cache--&gt; CuratorCacheListener.builder().forNodeCache(new NodeCacheListener(){} );
		//2.path cache--&gt; CuratorCacheListener.builder().forPathChildrenCache();
		//3.tree cache--&gt; CuratorCacheListener.builder().forTreeCache.forTreeCache();
		CuratorCacheListener listener = CuratorCacheListener.builder()
		        .forNodeCache(new NodeCacheListener() {
		            @Override
		            public void nodeChanged() throws Exception {
		                System.out.println("节点改变了...");
		            }
		        })
		        .build();
 
		//添加监听
		curatorCache.listenable().addListener(listener);
		//开启监听
		curatorCache.start();
		//让线程休眠30s(为了方便测试)
		Thread.sleep(1000 * 30);
	}
</code></pre>
    <pre><code>package org.example.zookeeper.curator;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.*;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.data.Stat;
import org.testng.annotations.Test;

import java.util.List;

/**
 * @ClassName: CuratorDao
 * @Description:
 * @Author: 88578
 * @Date: 2022/5/1 14:17
 */
public class CuratorDao {

    //使用curator(递归)添加节点
    //级联创建节点（原生API不支持/后台客户端也不支持，但是Curator支持）
    public static void createNodes(CuratorFramework zkClient, String nodePath, String nodeData) throws Exception {
        zkClient.create()
                .creatingParentContainersIfNeeded()//创建父节点,如果需要的话
                .withMode(CreateMode.PERSISTENT) //指定节点是临时的，还是永久的
                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE) //指定节点的操作权限
                .forPath(nodePath, nodeData.getBytes());
        System.out.println(nodePath + "节点已成功创建…");
    }

    //使用curator(递归)删除节点
    //删除node节点及其子节点
    public static void deleteNodeWithChild(CuratorFramework zkClient, String nodePath) throws Exception {
        zkClient.delete()
                .guaranteed()                //保证删除：如果删除失败，那么在后端还是继续会删除，直到成功
                .deletingChildrenIfNeeded()  //级联删除子节点
                //.withVersion(1)//版本号可以据需使用
                .forPath(nodePath);
        System.out.println(nodePath + "节点已删除成功…");
    }

    //使用curator更新节点数据
    //更新节点data数据
    public static void updateNodeData(CuratorFramework zkClient, String nodePath, String nodeNewData) throws Exception {
        zkClient.setData().withVersion(0).forPath(nodePath, nodeNewData.getBytes());//版本号据需使用，默认可以不带
        System.out.println(nodePath + "节点数据已修改成功…");
    }

    //使用curator查询节点数据
    //查询node节点数据
    public static void getNodeData(CuratorFramework zkClient, String nodePath) throws Exception {
        Stat stat = new Stat();
        byte[] data = zkClient.getData().storingStatIn(stat).forPath(nodePath);
        System.out.println("节点" + nodePath + "的数据为" + new String(data));
        System.out.println("节点的版本号为：" + stat.getVersion());
    }

    //使用curator查询节点的子节点
    //打印node子节点
    public static void printChildNodes(CuratorFramework zkClient, String parentNodePath) throws Exception {
        List&lt;String&gt; childNodes = zkClient.getChildren().forPath(parentNodePath);
        System.out.println("开始打印子节点");
        for (String str : childNodes) {
            System.out.println(str);
        }
    }

    //使用curator判断节点是否存在
    //判断node节点是否存在
    public static void checkNodeExists(CuratorFramework zkClient, String nodePath) throws Exception {
        Stat stat = zkClient.checkExists().forPath(nodePath);
        System.out.println(null == stat ? "节点不存在" : "节点存在");
    }

    /**************使用Curator高级API特性之Cache缓存监控节点变化*************/

    //一次性的watch
    public static void watchOnce(CuratorFramework zkClient, String nodePath) throws Exception {
        zkClient.getData().usingWatcher(new MyCuratorWatcher()).forPath(nodePath);
    }

    //NodeCache监听当前节点变化
    //通过NodeCacheListener接口持续监听节点的变化来实现
    //持续监听的watch
    public static void watchForeverByNodeCache(CuratorFramework zkClient, String nodePath) throws Exception {
        final NodeCache nodeCache = new NodeCache(zkClient, nodePath);//把监听节点，转换为nodeCache
        nodeCache.start(false);//默认为false  设置为true时，会自动把节点数据存放到nodeCache中；设置为false时，初始化数据为空
        ChildData cacheData = nodeCache.getCurrentData();
        if (null == cacheData) {
            System.out.println("NodeCache节点的初始化数据为空……");
        } else {
            System.out.println("NodeCache节点的初始化数据为" + new String(cacheData.getData()));
        }

        //设置循环监听
        nodeCache.getListenable().addListener(new NodeCacheListener() {
            @Override
            public void nodeChanged() throws Exception {
                ChildData cdata = nodeCache.getCurrentData();
                if (null == cdata) {
                    System.out.println("节点发生了变化，可能刚刚被删除！");
                    nodeCache.close();//关闭监听
                } else {
                    String data = new String(cdata.getData());
                    String path = nodeCache.getCurrentData().getPath();
                    System.out.println("节点路径" + path + "数据发生了变化，最新数据为：" + data);
                }
            }
        });
    }

    //PathChildrenCache只监听子节点变化
    //通过PathChildrenCacheListener接口持续监听子节点来实现
    //持续监听watch子节点的任何变化
    public static void watchForeverByPathChildrenCache(CuratorFramework zkClient, String nodePath) throws Exception {
        final PathChildrenCache childrenCache = new PathChildrenCache(zkClient, nodePath, true);//把监听节点，转换为childrenCache
        /**
         * StartMode:初始化方式
         *	POST_INITIALIZED_EVENT: 异步初始化，初始化之后会触发事件(会进入下面的第一个case)
         *	NORMAL:异步初始化 (不会进入下面的第一个case)
         *	BUILD_INITIAL_CACHE: 同步初始化(把节点数据同步缓存到Cache中)
         */
        childrenCache.start(PathChildrenCache.StartMode.NORMAL);
        List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();
        System.out.println("当前节点所有子节点的数据列表如下：");
        for (ChildData childData : childDataList) {
            System.out.println(new String(childData.getData()));
        }

        childrenCache.getListenable().addListener(new PathChildrenCacheListener() {

            @Override
            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
                switch (event.getType()) {
                    case INITIALIZED:
                        System.out.println("子节点初始化OK…");
                        break;
                    case CHILD_ADDED:
                        System.out.println("子节点" + event.getData().getPath() + "已被成功添加，数据data=" + new String(event.getData().getData()));
                        break;
                    case CHILD_UPDATED:
                        System.out.println("子节点" + event.getData().getPath() + "数据发生变化，新数据data=" + new String(event.getData().getData()));
                        break;
                    case CHILD_REMOVED:
                        System.out.println("子节点" + event.getData().getPath() + "已被移除~");
                        break;
                    case CONNECTION_RECONNECTED:
                        System.out.println("正在尝试重新建立连接…");
                        break;
                    case CONNECTION_SUSPENDED:
                        System.out.println("连接状态被暂时停止…");
                        break;
                    default:
                        break;
                }
            }
        });
    }

    //TreeCache是上两者的合体，既监听自身，也监听所有子节点变化
    //通过TreeCacheListener接口来实现
    public static void treeCache(CuratorFramework zkClient, String nodePath) throws Exception {
//        final String path = "/treeChildrenCache";
        final TreeCache treeCache = new TreeCache(zkClient, nodePath);

        treeCache.getListenable().addListener(new TreeCacheListener() {
            @Override
            public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {
                switch (event.getType()) {
                    case NODE_ADDED:
                        System.out.println("节点变动触发：NODE_ADDED:" + event.getData().getPath());
                        break;
                    case NODE_REMOVED:
                        System.out.println("节点变动触发：NODE_REMOVED:" + event.getData().getPath());
                        break;
                    case NODE_UPDATED:
                        System.out.println("节点变动触发：NODE_UPDATED:" + event.getData().getPath());
                        break;
                    case CONNECTION_LOST:
                        System.out.println("节点变动触发：CONNECTION_LOST:" + event.getData().getPath());
                        break;
                    case CONNECTION_RECONNECTED:
                        System.out.println("节点变动触发：CONNECTION_RECONNECTED:" + event.getData().getPath());
                        break;
                    case CONNECTION_SUSPENDED:
                        System.out.println("节点变动触发：CONNECTION_SUSPENDED:" + event.getData().getPath());
                        break;
                    case INITIALIZED:
                        System.out.println("节点变动触发：INITIALIZED:" + event.getData().getPath());
                        break;
                    default:
                        break;
                }
            }
        });
        //据需可以继续做一些其他的增删改操作
        zkClient.create().withMode(CreateMode.PERSISTENT).forPath(nodePath);
        Thread.sleep(1000);

        zkClient.create().withMode(CreateMode.PERSISTENT).forPath(nodePath + "/c1");
        Thread.sleep(1000);

        zkClient.delete().forPath(nodePath + "/c1");
        Thread.sleep(1000);

        zkClient.delete().forPath(nodePath);
        Thread.sleep(1000);
        zkClient.close();
    }

    /*Curator Cache，是在zk3.6新版本添加的特性，Curator需5.*+
    它的出现是为了替换以上3个监听（NodeCache、PathCache、TreeCache），
            它通过CuratorCacheListener.builder().for***来选择对应的监听。
            最后再通过curatorCache.listenable().addListener(listener);注册监听。*/
    public static void curatorCache1(CuratorFramework zkClient) {
        final String path = "/curatorCache";
        CuratorCache curatorCache = CuratorCache.build(zkClient, path);
        curatorCache.listenable().addListener(new CuratorCacheListener() {
            @Override
            public void event(Type type, ChildData oldData, ChildData newdata) {
                switch (type) {
                    case NODE_CREATED:
                        //各种判断
                        break;

                    default:
                        break;
                }
            }
        });
    }

    public static void curatorCache2(CuratorFramework zkClient) throws InterruptedException {
        final String path = "/curatorCache";
        CuratorCache curatorCache = CuratorCache.builder(zkClient, path).build();

        //构建监听器
        //新旧对照：
        //1.node cache--&gt; CuratorCacheListener.builder().forNodeCache(new NodeCacheListener(){} );
        //2.path cache--&gt; CuratorCacheListener.builder().forPathChildrenCache();
        //3.tree cache--&gt; CuratorCacheListener.builder().forTreeCache.forTreeCache();
        CuratorCacheListener listener = CuratorCacheListener.builder()
                .forNodeCache(new NodeCacheListener() {
                    @Override
                    public void nodeChanged() throws Exception {
                        System.out.println("节点改变了...");
                    }
                })
                .build();

        //添加监听
        curatorCache.listenable().addListener(listener);
        //开启监听
        curatorCache.start();
        //让线程休眠30s(为了方便测试)
        Thread.sleep(1000 * 30);
    }


    @Test
    public void test() throws Exception {
        ZkConnectCuratorUtil zkUtil = new ZkConnectCuratorUtil();//new的同时，zk也被启动
        CuratorFramework zkClient = zkUtil.zkClient;
//        CuratorDao.createNodes(zkClient,"/xiaosi/test","siguogui");
//        CuratorDao.deleteNodeWithChild(zkClient,"/xiaosi/test");
//        CuratorDao.updateNodeData(zkClient,"/xiaosi/test","xiaosi");
//        CuratorDao.getNodeData(zkClient,"/xiaosi/test");
//        CuratorDao.printChildNodes(zkClient, "/xiaosi");
        CuratorDao.checkNodeExists(zkClient, "/xiaosi");
    }


    public static void main(String[] args) throws Exception {
        ZkConnectCuratorUtil zkUtil = new ZkConnectCuratorUtil();//new的同时，zk也被启动
        CuratorFramework zkClient = zkUtil.zkClient;
//        CuratorDao.watchOnce(zkClient, "/xiaosi/test");
//        CuratorDao.watchForeverByNodeCache(zkClient, "/xiaosi/test");
//        CuratorDao.watchForeverByPathChildrenCache(zkClient, "/xiaosi/test");
        CuratorDao.treeCache(zkClient, "/xiaosi/test4");

        CuratorDao dao = new CuratorDao();

        String nodePath = "/super/succ";
        dao.createNodes(zkClient, nodePath, "super");//创建节点
//		dao.updateNodeData(zkClient, nodePath, "hello");//更新节点数据
//		dao.deleteNodeWithChild(zkClient, nodePath);
//		dao.getNodeData(zkClient, nodePath);
//		dao.printChildNodes(zkClient, nodePath);
//		dao.checkNodeExists(zkClient, nodePath);
//		dao.watchOnce(zkClient, nodePath);
//		dao.watchForeverByNodeCache(zkClient, nodePath);
//		dao.watchForeverByPathChildrenCache(zkClient, nodePath);

        Thread.sleep(300000); //延迟sleep时间，便于后才修改节点，看前台是否会继续触发watch
        cto.closeZKClient();
    }
}
</code></pre>
    <h2>
     <a id="54_CuratorACL_1639">
     </a>
     5.4 使用Curator创建/验证ACL(访问权限列表)
    </h2>
    <h4>
     <a id="541_Zk_1640">
     </a>
     5.4.1 连通Zk时，就指定登录权限
    </h4>
    <pre><code>//本类代码，只涉及ACL操作 
public class CuratorAcl {
 
	public CuratorFramework client = null;
	public static final String workspace="workspace";
	public static final String zkServerPath = "192.168.31.216:2181";
 
	public CuratorAcl() {
		RetryPolicy retryPolicy = new RetryNTimes(3, 5000);
		client = CuratorFrameworkFactory.builder().authorization("digest", "mayun:mayun".getBytes())//通常情况下，登录账号、密码可以通过构造参数传入，暂时固定，据需修改
				.connectString(zkServerPath)
				.sessionTimeoutMs(20000).retryPolicy(retryPolicy)
				.namespace(workspace).build();
		client.start();
	}
	
	public void closeZKClient() {
		if (client != null) {
			this.client.close();
		}
	}
}
</code></pre>
    <h4>
     <a id="542_1665">
     </a>
     5.4.2写一个把明文的账号密码转换为加密后的密文的工具类
    </h4>
    <pre><code>//把明文的账号密码转换为加密后的密文
public class AclUtils {
 
	public static String getDigestUserPwd(String loginId_Username_Passwd) {
		String digest = "";
		try {
			digest = DigestAuthenticationProvider.generateDigest(loginId_Username_Passwd);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
		return digest;
	}
 
	public static void main(String[] args) throws IOException, InterruptedException, KeeperException, Exception {
		String id = "mayun:mayun";
		String idDigested = getDigestUserPwd(id);
		System.out.println(idDigested); // mayun:KThXmEntEPZyHsQk7tbP5ZzEevk=
	}
}
</code></pre>
    <h4>
     <a id="543AclUtilsAcl_1688">
     </a>
     5.4.3使用自定义工具类AclUtils，一次性给多个用户赋Acl权限
    </h4>
    <pre><code>    public static List&lt;ACL&gt; getAcls() throws NoSuchAlgorithmException{
		List&lt;ACL&gt; acls=new ArrayList&lt;ACL&gt;();
		Id mayun =new Id("digest", AclUtils.getDigestUserPwd("mayun:mayun"));
		Id lilei =new Id("digest", AclUtils.getDigestUserPwd("lilei:lilei"));
		acls.add(new ACL(Perms.ALL, mayun));//给mayun一次性赋值所有权限
		acls.add(new ACL(Perms.READ, lilei));
		acls.add(new ACL(Perms.DELETE | Perms.CREATE, lilei));//给lilei分两次赋权限（目的：看不同的赋权方式）
		return acls;
	}
</code></pre>
    <h4>
     <a id="544_1700">
     </a>
     5.4.4级联创建节点，并赋予节点操作权限
    </h4>
    <pre><code>	public static void createNodesCascade(CuratorAcl cto,String nodePath,String nodeData,List&lt;ACL&gt; acls) throws Exception {
		String result=cto.client.create().creatingParentsIfNeeded()
				.withMode(CreateMode.PERSISTENT)
				.withACL(acls, true)//给节点赋权限
				.forPath(nodePath, nodeData.getBytes());
		
		System.out.println("创建成功,result="+result);		
	}
</code></pre>
    <h4>
     <a id="545_1711">
     </a>
     5.4.5读取节点数据
    </h4>
    <pre><code>   public  void getNodeData(CuratorAcl cto,String nodePath) throws Exception {
   	Stat stat = new Stat();
    
   	byte[] data = cto.client.getData().storingStatIn(stat).forPath(nodePath);
   	if(null!=stat) {
   		System.out.println("节点" + nodePath + "的数据为: " + new String(data));
   		System.out.println("该节点的版本号为: " + stat.getVersion());
   	}
   }
</code></pre>
    <h4>
     <a id="546ACLdata_1723">
     </a>
     5.4.6修改具有ACL权限节点的data数据
    </h4>
    <pre><code>	public void modNodeDataWhichWithAcl(CuratorAcl cto,String nodePath,String nodeNewData) throws Exception {
		cto.getNodeData(cto, nodePath);
		System.out.println("节点修改后的数据为："+nodeNewData);
		cto.client.setData().forPath(nodePath, nodeNewData.getBytes());
		System.out.println("修改成功");
	}
</code></pre>
    <h4>
     <a id="547node_1732">
     </a>
     5.4.7两种方法判断node节点是否存（优先使用第一种）
    </h4>
    <pre><code>	public void checkNodeExists(CuratorAcl cto,String nodePath) throws Exception {
		cto.getNodeData(cto, nodePath);
		System.out.println("-----------=================-------------");
		
		//判断节点是否存在，方法一（路径前面会自动添加workspace）
		Stat stat=cto.client.checkExists().forPath(nodePath);
		System.out.println("======="+stat==null?"不存在":"存在");
		
		//判断节点是否存在，方法二（路径前面需手动添加workspace）
		Stat stat2 = cto.client.getZookeeperClient().getZooKeeper().exists("/"+workspace+nodePath, false);
		System.out.println("======="+stat2==null?"不存在":"存在");
	}
</code></pre>
    <p>
     ACL权限的main方法测试
     <br/>
     通过java代码给某个节点添加ACL权限后，后台登陆zk客户端时，是无法直接操作该节点被ACL控制的权限的操作的，要想操作具有ACL权限的节点，方法只有两个。
     <br/>
     1、知道该节点输入用户都有哪些，用这些用户的账号密码登录
     <br/>
     2、使用超级用户登录
     <br/>
     #getAcl /succ/testDigest 查看都有哪些用户对该节点有操作权限
     <br/>
     #addauth digest succ:succ 登录
    </p>
    <pre><code>	public static void main(String[] args) throws Exception {
		CuratorAcl cto = new CuratorAcl();
		boolean isZkCuratorStarted = cto.client.isStarted();
		System.out.println("当前客户的状态：" + (isZkCuratorStarted ? "连接成功" : "已关闭"));
		
		String nodePath1 = "/acl/tom/bin";
		String nodePath2 = "/acl/father/child/sub";
//		cto.createNodesCascade(cto, nodePath1, "aclTest", getAcls());//首次创建，报错，只能创建父节点，子节点无法创建
//		cto.client.setACL().withACL(getAcls()).forPath("/curatorNode");//给节点创建权限		
//		cto.getNodeData(cto, "/super");
//		cto.getNodeData(cto, "/acl");
		cto.checkNodeExists(cto, nodePath2);
		cto.closeZKClient();
		boolean isZkCuratorStarted2 = cto.client.isStarted();
		System.out.println("当前客户的状态：" + (isZkCuratorStarted2 ? "连接成功" : "已关闭"));
	}
</code></pre>
    <h2>
     <a id="7__1771">
     </a>
     7 分布式锁
    </h2>
    <p>
     Curator的5种分布式锁及其对应的核心类：
    </p>
    <p>
     1.重入式排它锁 Shared Reentrant Lock，实现类：InterProcessMutex
    </p>
    <p>
     2.不可重入排它锁 Shared Lock ，实现类：InterProcessSemaphoreMutex
    </p>
    <p>
     3.可重入读写锁 Shared Reentrant Read Write Lock，实现类： InterProcessReadWriteLock 、InterProcessLock
    </p>
    <p>
     4.多锁对象容器（多共享锁） Multi Shared Lock，将多个锁作为单个实体管理的容器，实现类：InterProcessMultiLock、InterProcessLock
    </p>
    <p>
     5.共享信号锁Shared Semaphore ，实现类：InterProcessSemaphoreV2
    </p>
    <p>
     跨 JVM 工作的计数信号量。使用相同锁路径的所有 JVM 中的所有进程将实现进程间有限的租用集。此外，这个信号量大多是“公平的”——每个用户将按照请求的顺序获得租用（从 ZK 的角度来看）。
    </p>
    <p>
     有两种模式可用于确定信号量的最大租用。在第一种模式中，最大租用是由给定路径的用户维护的约定。在第二种模式中，SharedCountReader 用作给定路径的信号量的方法，以确定最大租用。
    </p>
    <h3>
     <a id="71InterProcessMutex_1788">
     </a>
     7.1.重入式排它锁InterProcessMutex
    </h3>
    <p>
     public InterProcessMutex(CuratorFramework client, String path)
     <br/>
     获取/释放锁的API
    </p>
    <p>
     public void acquire() throws Exception;//获取锁，获取不到锁一直阻塞，zk连接中断则抛异常
     <br/>
     public boolean acquire(long time, TimeUnit unit) throws Exception;//获取锁，超过该时间后，直接返回false，zk连接中断则抛异常
     <br/>
     public void release() throws Exception;//释放锁
     <br/>
     通过release()方法释放锁。InterProcessMutex 实例可以重用。Revoking ZooKeeper recipes wiki定义了可协商的撤销机制。为了撤销mutex, 调用下面的方法
    </p>
    <p>
     /**
    </p>
    <ul>
     <li>
      将锁设为可撤销的. 当别的进程或线程想让你释放锁时Listener会被调用。
     </li>
     <li>
      Parameters:
     </li>
     <li>
      listener - the listener
      <br/>
      */
      <br/>
      public void makeRevocable(RevocationListener listener)
     </li>
    </ul>
    <h3>
     <a id="72InterProcessSemaphoreMutex_1803">
     </a>
     7.2.不可重入排它锁InterProcessSemaphoreMutex
    </h3>
    <p>
     public InterProcessSemaphoreMutex(CuratorFramework client, String path)
     <br/>
     使用InterProcessSemaphoreMutex，调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入
    </p>
    <h3>
     <a id="73InterProcessReadWriteLock_InterProcessLock_1807">
     </a>
     7.3.可重入读写锁InterProcessReadWriteLock 、InterProcessLock
    </h3>
    <p>
     一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁使用时不允许读 (阻塞)。此锁是可重入的。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁， 比如请求写锁 —&gt;读锁 —-&gt;释放写锁。从读锁升级成写锁是不成的。
    </p>
    <h3>
     <a id="74_InterProcessMultiLockInterProcessLock_1810">
     </a>
     7.4.多锁对象容器(多共享锁) ，将多个锁作为单个实体管理，InterProcessMultiLock、InterProcessLock
    </h3>
    <p>
     Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire（上锁），如果请求失败，所有的锁都会被release （释放锁）。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。主要涉及两个类：InterProcessMultiLock、InterProcessLock
    </p>
    <p>
     它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。
    </p>
    <p>
     public InterProcessMultiLock(List locks)
     <br/>
     public InterProcessMultiLock(CuratorFramework client, List paths)
    </p>
    <h3>
     <a id="75_1817">
     </a>
     7.5.代码
    </h3>
    <pre><code>public class ZkLock {
    final static Logger log = LoggerFactory.getLogger(ZkLock.class);
    public CuratorFramework zkClient = null; // zk的客户端工具Curator（在本类通过new实例化的是，自动start）
    private static final int BASE_SLEEP_TIME_MS = 1000; // 连接失败后，再次重试的间隔时间 单位:毫秒
    private static final int MAX_RETRY_TIMES = 10; // 定义失败重试次数
    private static final int SESSION_TIME_OUT = 1000000; // 会话存活时间,根据业务灵活指定 单位:毫秒
    private static final String ZK_SERVER_IP_PORT = "localhost:2181";// Zookeeper服务所在的IP和客户端端口
    private static final String NAMESPACE = "workspace";// 指定后，默认操作的所有的节点都会在该工作空间下进行
    static int j = 10;

    //初始化zk客户端
    public ZkLock() {
        // 重试策略：初试时间为1s 重试10次
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(BASE_SLEEP_TIME_MS, MAX_RETRY_TIMES);
        // 通过工厂建立连接
        zkClient = CuratorFrameworkFactory.builder().connectString(ZK_SERVER_IP_PORT) // 连接地址
                .sessionTimeoutMs(SESSION_TIME_OUT).retryPolicy(retryPolicy)// 重试策略
                .build();
        zkClient.start();
    }

    public static void lockTest(CuratorFramework zkClient) throws InterruptedException {
        // 使用分布式锁,所有系统同时监听同一个节点,达到分布式锁的目的
        final InterProcessMutex lock = new InterProcessMutex(zkClient, "/test");
        final CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i &lt; 10; i++) {//启动10个线程
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        countDownLatch.await();// 线程等待一起执行
                        lock.acquire();// 分布式锁,数据同步
                        // 处理业务
                        j--;
                        System.out.println(j);
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        try {// 释放锁
                            lock.release();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }, "t" + i).start();
        }
        Thread.sleep(1000);
        countDownLatch.countDown();// 模拟十个线程一起并发.指定一起执行
    }

    public static void main(String[] args) throws InterruptedException {
        ZkLock zkl = new ZkLock();
        ZkLock.lockTest(zkl.zkClient);
    }
}
</code></pre>
    <h2>
     <a id="8_1876">
     </a>
     8.分布式计数器
    </h2>
    <p>
     利用Zookeeper可以实现一个集群共享的计数器。只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器：DistributedAtomicInteger，DistributedAtomicLong。这个两个除了计数范围(int、long)不同外，没有任何不同。操作也非常简单，跟AtomicInteger大同小异。
    </p>
    <p>
     increment() //加1
     <br/>
     decrement() //减1
     <br/>
     compareAndSet(Integer expectedValue, Integer newValue) //cas操作
     <br/>
     get() //获取当前值
     <br/>
     add()：增加特定的值
     <br/>
     subtract(): 减去特定的值
     <br/>
     trySet(): 尝试设置计数值
     <br/>
     使用的时候，必须检查返回结果的succeeded()， 它代表此操作是否成功。如果操作成功， preValue()代表操作前的值， postValue()代表操作后的值。
    </p>
    <pre><code>public static void count(CuratorFramework zkClient) throws Exception {
		//分布式计数器
        DistributedAtomicInteger counter=new DistributedAtomicInteger(zkClient,"/super",new RetryNTimes(3,100));
        //初始化
        counter.forceSet(0);
        AtomicValue&lt;Integer&gt; value = counter.increment();//原子自增
        System.out.println("原值为"+value.preValue());
        System.out.println("更改后的值为"+value.postValue());
        System.out.println("状态"+value.succeeded());
	}
 
	public static void main(String[] args) throws Exception {
		ZkLock zkl=new ZkLock();
		//ZkLock.lockTest(zkl.zkClient);
		ZkLock.count(zkl.zkClient);
	}
</code></pre>
    <p>
     另外Curator还有一些高端的用法：分布式屏障—Barrier、Double-barrier，分布式队列DistributedQueueDistributed Queue
     <br/>
     <a href="https://blog.csdn.net/succing/article/details/121779721">
      https://blog.csdn.net/succing/article/details/121779721
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/succing/article/details/121793494">
      https://blog.csdn.net/succing/article/details/121793494
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/succing/article/details/121844550">
      https://blog.csdn.net/succing/article/details/121844550
     </a>
     <br/>
     <a href="https://blog.csdn.net/succing/article/details/121802687">
      https://blog.csdn.net/succing/article/details/121802687
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33373730353532352f:61727469636c652f64657461696c732f313234353131373432" class_="artid" style="display:none">
 </p>
</div>


