---
layout: post
title: "深度优先搜索DFS与方格图的连通性判断"
date: 2025-03-16 22:27:22 +0800
description: "深度优先搜索（DFS）与方格图的连通性判断"
keywords: "深度优先搜索（DFS）与方格图的连通性判断"
categories: ['蓝桥杯', '算法Oj', '算法']
tags: ['算法', '深度优先', 'C']
artid: "146298712"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146298712
    alt: "深度优先搜索DFS与方格图的连通性判断"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146298712
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146298712
cover: https://bing.ee123.net/img/rand?artid=146298712
image: https://bing.ee123.net/img/rand?artid=146298712
img: https://bing.ee123.net/img/rand?artid=146298712
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深度优先搜索（DFS）与方格图的连通性判断
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p style="background-color:transparent">
      在算法竞赛中，
      <strong>
       方格图（Grid）
      </strong>
      是常见的问题场景（如迷宫、岛屿问题等）。
      <strong>
       DFS常用于遍历方格中的连通区域，判断连通性。
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h2 style="background-color:transparent">
     一、方格图的DFS核心思想
    </h2>
    <ol>
     <li>
      <p>
       <strong>
        图的表示
       </strong>
       <br/>
       方格图通常用二维数组表示，每个格子可能有不同的状态（例如可通行或不可通行）。例如：
      </p>
      <ul>
       <li>
        <p>
         <code>
          grid[i][j] = 0
         </code>
         表示水域（不可通行）
        </p>
       </li>
       <li>
        <p>
         <code>
          grid[i][j] = 1
         </code>
         表示陆地（可通行）
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        移动方向
       </strong>
       <br/>
       根据题目要求，每个格子可以向
       <strong>
        4方向
       </strong>
       （上下左右）或
       <strong>
        8方向
       </strong>
       （包括对角线）移动。需要定义方向数组：
      </p>
      <pre><code class="language-cpp">// 4方向：上、右、下、左
int dx4[] = {-1, 0, 1, 0};
int dy4[] = {0, 1, 0, -1};

// 8方向：包括对角线
int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};
int dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};</code></pre>
     </li>
     <li>
      <p>
       <strong>
        DFS遍历步骤
       </strong>
      </p>
      <ul>
       <li>
        <p>
         从起点出发，标记当前格子为已访问。
        </p>
       </li>
       <li>
        <p>
         遍历所有允许的方向，检查下一个格子是否在边界内、未被访问且可通行。
        </p>
       </li>
       <li>
        <p>
         递归访问所有连通区域。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h2>
     二、C++代码实现
    </h2>
    <h3>
     场景示例：统计方格图中的连通区域数量（如岛屿数量）
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 4方向移动数组
const int dx4[] = {-1, 0, 1, 0};
const int dy4[] = {0, 1, 0, -1};

// 8方向移动数组
const int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};
const int dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};

// DFS遍历函数（4方向）
void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
    int rows = grid.size();
    int cols = grid[0].size();
    
    visited[x][y] = true; // 标记当前格子已访问
    
    // 遍历4个方向
    for (int i = 0; i &lt; 4; i++) {
        int nx = x + dx4[i];
        int ny = y + dy4[i];
        // 检查边界、是否可访问、是否已访问
        if (nx &gt;= 0 &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; cols 
            &amp;&amp; grid[nx][ny] == 1 &amp;&amp; !visited[nx][ny]) {
            dfs(grid, visited, nx, ny);
        }
    }
}

// 统计连通区域数量
int countConnectedRegions(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    if (grid.empty()) return 0;
    
    int rows = grid.size();
    int cols = grid[0].size();
    vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(cols, false));
    int count = 0;
    
    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            // 发现未访问的陆地，启动DFS并计数
            if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {
                dfs(grid, visited, i, j);
                count++;
            }
        }
    }
    return count;
}

int main() {
    // 示例输入：5x5的方格图
    vector&lt;vector&lt;int&gt;&gt; grid = {
        {1, 1, 0, 0, 0},
        {1, 1, 0, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 0, 1, 1}
    };
    
    cout &lt;&lt; "连通区域数量（4方向）: " &lt;&lt; countConnectedRegions(grid) &lt;&lt; endl;
    return 0;
}</code></pre>
    <hr/>
    <h2>
     三、代码解析
    </h2>
    <ol>
     <li>
      <h3>
       <strong>
        方向数组
       </strong>
      </h3>
      <ul>
       <li>
        <p>
         <code>
          dx4
         </code>
         和
         <code>
          dy4
         </code>
         表示4个方向的坐标变化。
        </p>
       </li>
       <li>
        <p>
         <code>
          dx8
         </code>
         和
         <code>
          dy8
         </code>
         表示8个方向的坐标变化（可用于更复杂的连通性判断）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h3>
       <strong>
        DFS函数
       </strong>
      </h3>
      <ul>
       <li>
        <p>
         递归访问当前格子的所有相邻可行走格子。
        </p>
       </li>
       <li>
        <p>
         通过
         <code>
          visited
         </code>
         数组避免重复访问。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h3>
       <strong>
        统计连通区域
       </strong>
      </h3>
      <ul>
       <li>
        <p>
         遍历所有格子，对每个未访问的陆地启动一次DFS，统计启动次数即为连通区域数量。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h2>
     四、扩展：8方向连通性
    </h2>
    <p>
     若允许8方向移动，只需修改方向数组和遍历循环：
    </p>
    <pre><code class="language-cpp">// 修改DFS中的方向遍历
for (int i = 0; i &lt; 8; i++) {
    int nx = x + dx8[i];
    int ny = y + dy8[i];
    // ... 其他逻辑不变
}</code></pre>
    <hr/>
    <h2>
     五、复杂度分析
    </h2>
    <ul>
     <li>
      <p>
       <strong>
        时间复杂度
       </strong>
       ：
       <code>
        O(rows × cols)
       </code>
       ，每个格子被访问一次。
      </p>
     </li>
     <li>
      <p>
       <strong>
        空间复杂度
       </strong>
       ：
       <code>
        O(rows × cols)
       </code>
       ，用于存储
       <code>
        visited
       </code>
       数组。
      </p>
     </li>
    </ul>
    <hr/>
    <h2 style="background-color:transparent">
     六、应用场景
    </h2>
    <ol>
     <li>
      <p>
       岛屿问题（LeetCode 200）
      </p>
     </li>
     <li>
      <p>
       迷宫寻路
      </p>
     </li>
     <li>
      <p>
       图像中的连通区域分析
      </p>
     </li>
    </ol>
    <p>
     通过调整方向数组和状态判断逻辑，DFS可灵活应对各类方格图连通性问题。
    </p>
    <hr/>
    <h2>
     七、 例题解析
    </h2>
    <h3 style="background-color:transparent">
     <a href="https://www.lanqiao.cn/problems/2410/learning/?page=1&amp;first_category_id=1&amp;problem_id=2410" rel="nofollow" title="1、最大连通 - 蓝桥云课">
      1、最大连通 - 蓝桥云课
     </a>
    </h3>
    <h4 id="问题描述">
     问题描述
    </h4>
    <p>
     小蓝有一个 30 行 60 列的数字矩阵，矩阵中的每个数都是 0 或 1 。
    </p>
    <pre><code class="language-cpp">
110010000011111110101001001001101010111011011011101001111110

010000000001010001101100000010010110001111100010101100011110 

001011101000100011111111111010000010010101010111001000010100 

101100001101011101101011011001000110111111010000000110110000 

010101100100010000111000100111100110001110111101010011001011 

010011011010011110111101111001001001010111110001101000100011 

101001011000110100001101011000000110110110100100110111101011 

101111000000101000111001100010110000100110001001000101011001 

001110111010001011110000001111100001010101001110011010101110 

001010101000110001011111001010111111100110000011011111101010 

011111100011001110100101001011110011000101011000100111001011 

011010001101011110011011111010111110010100101000110111010110 

001110000111100100101110001011101010001100010111110111011011 

111100001000001100010110101100111001001111100100110000001101 

001110010000000111011110000011000010101000111000000110101101 

100100011101011111001101001010011111110010111101000010000111 

110010100110101100001101111101010011000110101100000110001010 

110101101100001110000100010001001010100010110100100001000011 

100100000100001101010101001101000101101000000101111110001010 

101101011010101000111110110000110100000010011111111100110010 

101111000100000100011000010001011111001010010001010110001010 

001010001110101010000100010011101001010101101101010111100101 

001111110000101100010111111100000100101010000001011101100001 

101011110010000010010110000100001010011111100011011000110010 

011110010100011101100101111101000001011100001011010001110011 

000101000101000010010010110111000010101111001101100110011100 

100011100110011111000110011001111100001110110111001001000111 

111011000110001000110111011001011110010010010110101000011111 

011110011110110110011011001011010000100100101010110000010011 

010011110011100101010101111010001001001111101111101110011101</code></pre>
    <p>
     如果从一个标为 1 的位置可以通过上下左右走到另一个标为 1 的位置，则称两个位置连通。与某一个标为 1 的位置连通的所有位置（包括自己）组成一个连通分块。
    </p>
    <p>
     请问矩阵中最大的连通分块有多大？
    </p>
    <h4 id="答案提交" style="background-color:transparent">
     答案提交
    </h4>
    <p>
     这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
    </p>
    <h4 id="运行限制">
     运行限制
    </h4>
    <ul>
     <li>
      最大运行时间：1s
     </li>
     <li>
      最大运行内存: 256M
     </li>
    </ul>
    <h4>
     算法代码：
    </h4>
    <pre><code class="language-cpp"># include &lt;bits/stdc++.h&gt;  // 包含标准库的所有头文件
using namespace std;  // 使用标准命名空间

// int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; // 定义四个方向的移动：上、右、下、左
// char g[100][100];  // 定义一个100x100的字符数组，用于存储矩阵
// int n = 30, m = 60;  // 定义矩阵的行数n为30，列数m为60

// int dfs(int x, int y) {  // 定义深度优先搜索函数，参数为当前坐标[x, y]
//     if (g[x][y] == '0') return 0;  // 如果当前点是'0'，返回0，表示不连通
//     g[x][y] = '0';  // 将当前点从'1'改为'0'，标记为已访问
//     int ans = 1;  // 初始化连通块的大小为1
//     for (int i = 0; i &lt; 4; i++) {  // 遍历当前点的四个邻居
//         int nx = x + dx[i], ny = y + dy[i];  // 计算邻居的坐标
//         if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m)  // 如果邻居坐标超出边界
//             continue;  // 跳过该邻居
//         ans += dfs(nx, ny);  // 递归调用dfs，累加连通块的大小
//     }
//     return ans;  // 返回当前连通块的大小
// }

// int main() {
//     for (int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];  // 输入矩阵的每一行
//     int ans = 0;  // 初始化最大连通块的大小为0
//     for (int i = 0; i &lt; n; i++)  // 遍历矩阵的每一行
//         for (int j = 0; j &lt; m; j++)  // 遍历矩阵的每一列
//             if (g[i][j] == '1')  // 如果当前点是'1'
//                 ans = max(ans, dfs(i, j));  // 更新最大连通块的大小
//     cout &lt;&lt; ans;  // 输出最大连通块的大小
//     return 0;  // 程序正常结束
// }

int main()
{
    cout&lt;&lt;"148";
    return 0;
}</code></pre>
    <h4>
     <strong>
      先执行上面注释中的代码，输入测试数据（注意删除测试数据中间的空行），得到的答案后直接提交答案。因为测试数据挺多挺大的，使用DFS会超时是正常的，因为DFS使用到了递归（会占用到很大的栈空间，超过系统栈空间，会导致栈溢出），但是这是个填空题，直接搞出答案就可以了。
     </strong>
    </h4>
    <p class="img-center">
     <img alt="" height="315" src="https://i-blog.csdnimg.cn/direct/20790ec15ba04e8a9ce1f14c53470bc4.png" width="711"/>
    </p>
    <p>
    </p>
    <h3 style="background-color:transparent">
     2、
     <a href="http://oj.ecustacm.cn/problem.php?id=1868" rel="nofollow" title="P1868 - 连接草坪(II) - New Online Judge">
      P1868 - 连接草坪(II) - New Online Judge
     </a>
    </h3>
    <p class="img-center">
     <img alt="" height="947" src="https://i-blog.csdnimg.cn/direct/1bf3b58714b24945863d0b8719ad509b.png" width="925"/>
    </p>
    <p class="img-center">
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/6106244b1f894bbd8a88691251c62c72.png" width="931"/>
    </p>
    <h4 style="background-color:transparent">
     算法代码：
    </h4>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;  // 包含标准库的所有头文件
using namespace std;  // 使用标准命名空间

int n, m;  // 定义矩阵的行数n和列数m
char Map[55][55];  // 定义一个55x55的字符数组，用于存储地图
int id[55][55], id_cnt = 0;  // id[x][y]表示点(x,y)属于第id_cnt个草地，id_cnt从1开始计数
vector&lt;pair&lt;int, int&gt;&gt; A[4];  // A[i]存储第i个草地中的所有点

int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};  // 定义四个方向的移动：下、右、上、左

void dfs(int x, int y, int c) {  // 深度优先搜索函数，参数为当前坐标[x, y]和草地编号c
    id[x][y] = c;  // 标记点(x,y)属于第c个草地
    A[c].push_back(make_pair(x, y));  // 将点(x,y)加入第c个草地的点集中
    for (int i = 0; i &lt; 4; i++) {  // 遍历当前点的四个邻居
        int nx = x + dir[i][0], ny = y + dir[i][1];  // 计算邻居的坐标
        if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue;  // 如果邻居坐标超出边界，跳过
        if (Map[nx][ny] == '.') continue;  // 如果邻居是土地，跳过
        if (id[nx][ny]) continue;  // 如果邻居已经遍历过，跳过
        dfs(nx, ny, c);  // 递归调用dfs，继续搜索
    }
}

int Count(int x, int y, int i) {  // 计算点(x,y)到第i个草地的最短距离
    int ans = 100;  // 初始化最短距离为一个较大的值
    for (auto a : A[i])  // 遍历第i个草地的所有点
        ans = min(ans, abs(a.first - x) + abs(a.second - y));  // 计算曼哈顿距离并更新最小值
    return ans;  // 返回最短距离
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;  // 输入矩阵的行数n和列数m
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; Map[i];  // 输入地图的每一行

    // 第1步：标记每个点属于哪个连通块
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
            if (Map[i][j] == 'X' &amp;&amp; !id[i][j])  // 如果当前点是草地且未被标记
                dfs(i, j, ++id_cnt);  // 进行DFS，标记连通块

    int ans = 100;  // 初始化答案为较大的值

    // 第2步：枚举每块土地，计算它到3个草地的最短距离
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
            if (Map[i][j] == '.')  // 如果当前点是土地
                ans = min(ans, Count(i, j, 1) + Count(i, j, 2) + Count(i, j, 3) - 2);  // 计算到三个草地的最短距离并更新答案

    // 第3步：计算3个草地之间的最短距离
    int Min[4] = {0, 100, 100, 100};  // 初始化草地之间的最短距离
    for (int i = 1; i &lt;= 3; i++) {  // 遍历每个草地
        int j = i + 1 &lt;= 3 ? i + 1 : 1;  // 计算下一个草地的编号
        for (auto a : A[i])  // 遍历第i个草地的所有点
            Min[j] = min(Min[j], Count(a.first, a.second, j));  // 计算到下一个草地的最短距离并更新
    }

    // 第4步：计算连通3个草地的最短距离，并与情况(1)的结果比较
    for (int i = 1; i &lt;= 3; i++)
        ans = min(ans, Min[i] + Min[i + 1 &lt;= 3 ? i + 1 : 1] - 2);  // 计算连通三个草地的最短距离并更新答案

    cout &lt;&lt; ans &lt;&lt; endl;  // 输出最终答案
    return 0;  // 程序正常结束
}</code></pre>
    <p class="img-center">
     <img alt="" height="374" src="https://i-blog.csdnimg.cn/direct/fe2d399b5a91475993fc3c21df14f70c.png" width="729"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436323938373132" class_="artid" style="display:none">
 </p>
</div>


