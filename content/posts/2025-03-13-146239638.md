---
layout: post
title: "MySQL与Redis的缓存一致性问题"
date: 2025-03-13 18:52:50 +0800
description: "本文探讨了MySQL与Redis缓存一致性问题，分析了先操作MySQL或Redis时的时序问题及潜在风险，提出了Cache-Aside模式作为解决方案，并介绍了直读、直写等缓存操作模式。此外，还提到通过Canal和消息队列提升系统一致性的方法，为高并发场景下的数据一致性提供了实践指导。"
keywords: "MySQL与Redis的缓存一致性问题"
categories: ['未分类']
tags: ['缓存', 'Redis', 'Mysql']
artid: "146239638"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146239638
    alt: "MySQL与Redis的缓存一致性问题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146239638
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146239638
cover: https://bing.ee123.net/img/rand?artid=146239638
image: https://bing.ee123.net/img/rand?artid=146239638
img: https://bing.ee123.net/img/rand?artid=146239638
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL与Redis的缓存一致性问题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="MySQLRedis_0">
     </a>
     MySQL与Redis的缓存一致性问题
    </h2>
    <h3>
     <a id="_2">
     </a>
     前言
    </h3>
    <p>
     在学习中，为了提高数据的读取效率，我们往往会使用Redis来作为MySQL数据的缓存，那么，自然就产生了二者间数据的一致性问题。
    </p>
    <p>
     想要对MySQL和Redis进行数据处理，自然会产生以下问题：
    </p>
    <ul>
     <li>
      MySQL与Redis操作的时序问题
      <ul>
       <li>
        更新与删除的选择及时序问题
       </li>
      </ul>
     </li>
    </ul>
    <p>
     下面我们来一一分析：
    </p>
    <h3>
     <a id="MySQL_13">
     </a>
     先操作MySQL
    </h3>
    <h4>
     <a id="MySQL_15">
     </a>
     先删除MySQL中数据
    </h4>
    <p>
     这种情况下，当我们选择先将MySQL中的数据删除时，如果后续写入新数据失败，新数据就很有可能会丢失，我们就完全失去了这条数据，这是难以接受的。所以我们还是来看看先更新MySQL的情况吧：
    </p>
    <h4>
     <a id="MySQL_19">
     </a>
     先更新MySQL中数据
    </h4>
    <p>
     这种情况下，当客户端修改一个数据时，我们先将MySQL中数据更新为最新状态，然后再操作Redis（如果第一步更新MySQL数据失败，就不会继续操作Redis了，此时MySQL和Redis中的数据都还是老数据，也是处于一致状态，可以接受）：
    </p>
    <h5>
     <a id="Redis_23">
     </a>
     再更新Redis中数据
    </h5>
    <p>
     试想这样一种情况：
    </p>
    <p>
     线程A和线程B按以下顺序执行：
    </p>
    <ol>
     <li>
      线程A缓存未命中，然后从MySQL中读到数据c=1
     </li>
     <li>
      线程B想将数据c=1修改为c=2
     </li>
     <li>
      线程B先更新MySQL成功，再更新Redis数据c=2（不论更新Redis成功与否）
     </li>
     <li>
      线程A写回Redis数据c=1
     </li>
    </ol>
    <p>
     可以看到，此时MySQL中是新数据c=2，Redis中却是老数据c=1，处于不一致状态。在Redis中该数据自动过期，或者再次更新该数据之前，客户端都会读到Redis中的老数据（脏数据）。
    </p>
    <p>
     不过读操作，往往比写操作更快速，也就是说大多数情况下，线程A等线程B操作完了再写回Redis的情况不会出现。
    </p>
    <p>
     但是，对于并发更新的情况，可能会出现多个线程并发更新Redis数据，导致老数据覆盖新数据的情况，也会造成不一致状态。
    </p>
    <h5>
     <a id="Redis_40">
     </a>
     再删除Redis中数据
    </h5>
    <p>
     与上面“再更新Redis中数据”的情况类似，可能会出现线程B删除完Redis数据后，线程A又写回老数据的情况。
    </p>
    <p>
     但是，对于并发更新的情况，就算多个线程并发删除Redis数据，也能够保证删除老数据，不会造成不一致状态。
    </p>
    <p>
     当然，如果删除Redis失败了，Redis中还是会留下老数据，造成不一致状态。
    </p>
    <h3>
     <a id="Redis_48">
     </a>
     先操作Redis
    </h3>
    <h4>
     <a id="Redis_50">
     </a>
     先删除Redis中数据
    </h4>
    <h5>
     <a id="MySQL_52">
     </a>
     再更新MySQL中数据
    </h5>
    <p>
     试想这样一种情况：
    </p>
    <p>
     线程A和线程B按以下顺序执行：
    </p>
    <ol>
     <li>
      线程B想将数据c=1修改为c=2
     </li>
     <li>
      线程B先删除Redis中数据成功
     </li>
     <li>
      线程A缓存未命中，然后从MySQL中读到数据c=1
     </li>
     <li>
      线程B更新MySQL中数据c=2
     </li>
     <li>
      线程A写回Redis数据c=1
     </li>
    </ol>
    <p>
     可以看到，此时MySQL中是新数据c=2，Redis中却是老数据c=1，处于不一致状态。在Redis中该数据自动过期，或者再次更新该数据之前，客户端都会读到Redis中的老数据（脏数据）。
    </p>
    <p>
     此外，对于并发更新的情况，可能会出现多个线程并发更新MySQL数据，导致老数据覆盖新数据的情况，也会造成不一致状态。
    </p>
    <h5>
     <a id="MySQL_68">
     </a>
     再删除MySQL中数据
    </h5>
    <p>
     这种情况下，当我们选择将MySQL中的数据删除时，如果后续Redis中的新数据丢失（磁盘存储相对内存存储的可靠性更高），我们就完全失去了这条数据，这是难以接受的。
    </p>
    <h3>
     <a id="_72">
     </a>
     总结
    </h3>
    <h4>
     <a id="CacheAside__74">
     </a>
     Cache-Aside (旁路缓存)
    </h4>
    <p>
     综上所述，我们往往会选择
     <strong>
      先更新MySQL中数据-再删除Redis中数据
     </strong>
     的方案。
    </p>
    <p>
     以上所述所有的方案，有一个统称：
     <strong>
      Cache-Aside (旁路缓存)
     </strong>
     。
    </p>
    <h4>
     <a id="___80">
     </a>
     直读 与 同步/异步直写
    </h4>
    <p>
     此外，如果我们将缓存的业务直接从其它业务代码中抽取出来，给其它业务提供一个缓存抽象层，将缓存的操作全部放在这个缓存抽象层中独立存在，也就是缓存的解耦。
    </p>
    <p>
     这样，主体业务就只需要与抽出来的缓存层进行交互，无需再关心数据的一致性，直接读/写缓存层，也就是
     <strong>
      直读
     </strong>
     与
     <strong>
      直写
     </strong>
     。
    </p>
    <h5>
     <a id="WriteThrough_86">
     </a>
     直读（Write-Through）
    </h5>
    <p>
     客户端（也可以是其他业务层）直接读取Redis缓存，如果缓存未命中，从MySQL中读取数据后，再写回Redis，然后再返回给客户端。
    </p>
    <h5>
     <a id="WriteThrough_90">
     </a>
     直写（Write-Through）
    </h5>
    <p>
     客户端（也可以是其他业务层）直接先更新Redis缓存，然后再更新MySQL，然后再返回数据给客户端。
    </p>
    <p>
     上面的是
     <strong>
      同步直写
     </strong>
     ，如果在更新MySQL的同时，异步将数据返回给客户端，那么就叫
     <strong>
      异步直写（Write-Behind）
     </strong>
     。
    </p>
    <h5>
     <a id="canal_96">
     </a>
     canal
    </h5>
    <p>
     此外，为了提高系统的可用性，我们可以配合一些成熟的中间件，例如：
    </p>
    <p>
     使用Canal监控MySQL的binlog日志，自动通知缓存业务MySQL中的数据进行了什么修改，可以让我们的系统迅速知道MySQL的数据改动，延迟极低。
    </p>
    <p>
     在缓存业务中，我们往往还可以引入
     <strong>
      消息队列
     </strong>
     ，提高数据传输的可靠性，例如：
    </p>
    <p>
     当Canal监控到MysQL数据改动后，将监控数据发送到RabbitMQ，由订阅了相关Topic的缓存业务消费监控数据并进行处理，可以有效避免数据传输中失败、丢失等问题。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f556e636f6d6d656e2f:61727469636c652f64657461696c732f313436323339363338" class_="artid" style="display:none">
 </p>
</div>


