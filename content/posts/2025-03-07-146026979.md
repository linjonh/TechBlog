---
layout: post
title: "CC蓝桥杯算法真题打卡Day1"
date: 2025-03-07 00:00:00 +0800
description: "C/C++蓝桥杯算法真题打卡（Day1）"
keywords: "蓝桥杯c 历年真题"
categories: ['蓝桥杯']
tags: ['蓝桥杯', '算法', '数据结构', '动态规划', 'C']
artid: "146026979"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146026979
    alt: "CC蓝桥杯算法真题打卡Day1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146026979
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146026979
cover: https://bing.ee123.net/img/rand?artid=146026979
image: https://bing.ee123.net/img/rand?artid=146026979
img: https://bing.ee123.net/img/rand?artid=146026979
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C/C++蓝桥杯算法真题打卡（Day1）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     一、
     <a href="https://leetcode.cn/problems/XltzEq/description/" rel="nofollow" title="LCR 018. 验证回文串 - 力扣（LeetCode）">
      LCR 018. 验证回文串 - 力扣（LeetCode）
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="807" src="https://i-blog.csdnimg.cn/direct/c0c65f25b7344d5b9e4fb510a8ee9027.png" width="799"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">class Solution {
public:
    bool isPalindrome(string s) {
        int n = s.size();
        // 处理一下s为空字符的情况
        if (n == 0) {
            return true; // 修正拼写错误
        }

        // 定义左右指针遍历字符串
        int left = 0;
        int right = n - 1; // 修正右指针初始化
        while (left &lt; right) {
            // 左右对非字母数字字符的处理是直接跳过
            while (left &lt; right &amp;&amp; !isalnum(s[left])) {
                left++;
            }
            while (left &lt; right &amp;&amp; !isalnum(s[right])) {
                right--;
            }

            // 处理大小写的情况，统一转换为小写
            if (s[left] &gt;= 'A' &amp;&amp; s[left] &lt;= 'Z') {
                s[left] += 32;
            }
            if (s[right] &gt;= 'A' &amp;&amp; s[right] &lt;= 'Z') {
                s[right] += 32;
            }

            // 然后判断是不是相同的字符，若是则直接跳过
            if (s[left] == s[right]) {
                left++;
                right--;
            } else {
                return false;
            }
        }
        return true;
    }
};</code></pre>
    <h3 style="background-color:transparent">
     <strong>
      代码思路
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        处理空字符串
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         如果字符串
         <code>
          s
         </code>
         为空（
         <code>
          n == 0
         </code>
         ），直接返回
         <code>
          true
         </code>
         ，因为题目定义空字符串为有效回文串。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        初始化左右指针
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         定义左指针
         <code>
          left
         </code>
         ，初始化为
         <code>
          0
         </code>
         ，指向字符串的开头。
        </p>
       </li>
       <li>
        <p>
         定义右指针
         <code>
          right
         </code>
         ，初始化为
         <code>
          n - 1
         </code>
         ，指向字符串的末尾。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        主循环：左右指针向中间移动
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         使用
         <code>
          while (left &lt; right)
         </code>
         循环，确保左右指针没有相遇或交叉。
        </p>
       </li>
       <li>
        <p>
         在循环中，分别处理左指针和右指针指向的字符。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        跳过非字母数字字符
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         使用
         <code>
          isalnum
         </code>
         函数检查当前字符是否为字母或数字。
        </p>
       </li>
       <li>
        <p>
         如果不是字母或数字，则移动指针（左指针向右移动，右指针向左移动），直到找到字母或数字字符。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        统一字符大小写
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         如果字符是大写字母（
         <code>
          A-Z
         </code>
         ），将其转换为小写字母（
         <code>
          a-z
         </code>
         ），以便在比较时忽略大小写。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        比较字符
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         如果左右指针指向的字符相等，则继续向中间移动指针（
         <code>
          left++
         </code>
         和
         <code>
          right--
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         如果字符不相等，则直接返回
         <code>
          false
         </code>
         ，说明字符串不是回文串。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        循环结束
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         如果循环正常结束（即左右指针相遇或交叉），说明所有字符都匹配，返回
         <code>
          true
         </code>
         ，表示字符串是回文串。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      代码优化建议
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        避免修改原始字符串
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         你的代码中直接修改了字符串
         <code>
          s
         </code>
         中的字符（如
         <code>
          s[left] += 32
         </code>
         ）。虽然这不会影响结果，但为了代码的健壮性，建议避免修改输入数据。
        </p>
       </li>
       <li>
        <p>
         可以使用
         <code>
          tolower
         </code>
         函数直接在比较时转换字符大小写，而不修改原始字符串。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        使用
        <code>
         tolower
        </code>
        函数
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         <code>
          tolower
         </code>
         是 C++ 标准库函数，可以直接将字符转换为小写，避免手动计算 ASCII 值。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <strong>
      优化后的代码如下：
     </strong>
    </h3>
    <pre><code class="language-cpp">class Solution {
public:
    bool isPalindrome(string s) {
        int n = s.size();
        // 处理空字符串
        if (n == 0) {
            return true;
        }

        int left = 0;
        int right = n - 1;
        while (left &lt; right) {
            // 跳过非字母数字字符
            while (left &lt; right &amp;&amp; !isalnum(s[left])) {
                left++;
            }
            while (left &lt; right &amp;&amp; !isalnum(s[right])) {
                right--;
            }

            // 统一转换为小写并比较
            if (tolower(s[left]) != tolower(s[right])) {
                return false;
            }

            // 移动指针
            left++;
            right--;
        }
        return true;
    }
};</code></pre>
    <hr/>
    <h3>
     <strong>
      代码思路总结
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        步骤
       </th>
       <th>
        操作
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1
       </td>
       <td>
        处理空字符串
       </td>
       <td>
        如果字符串为空，直接返回
        <code>
         true
        </code>
        。
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        初始化左右指针
       </td>
       <td>
        <code>
         left
        </code>
        指向开头，
        <code>
         right
        </code>
        指向末尾。
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        主循环
       </td>
       <td>
        当
        <code>
         left &lt; right
        </code>
        时，继续循环。
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        跳过非字母数字字符
       </td>
       <td>
        使用
        <code>
         isalnum
        </code>
        检查并跳过非字母数字字符。
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        统一字符大小写
       </td>
       <td>
        使用
        <code>
         tolower
        </code>
        将字符转换为小写。
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        比较字符
       </td>
       <td>
        如果字符不相等，返回
        <code>
         false
        </code>
        ；否则移动指针。
       </td>
      </tr>
      <tr>
       <td>
        7
       </td>
       <td>
        循环结束
       </td>
       <td>
        如果所有字符都匹配，返回
        <code>
         true
        </code>
        。
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3 style="background-color:transparent">
     <strong>
      时间复杂度分析
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        时间复杂度
       </strong>
       ：
       <code>
        O(n)
       </code>
       ，其中
       <code>
        n
       </code>
       是字符串的长度。每个字符最多被访问一次。
      </p>
     </li>
     <li>
      <p>
       <strong>
        空间复杂度
       </strong>
       ：
       <code>
        O(1)
       </code>
       ，只使用了常数级别的额外空间。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     二、
     <a href="https://leetcode.cn/problems/pascals-triangle/description/" rel="nofollow" title="118. 杨辉三角 - 力扣（LeetCode）">
      118. 杨辉三角 - 力扣（LeetCode）
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="851" src="https://i-blog.csdnimg.cn/direct/a88d7c979014422c935dcb84eeb1e000.png" width="792"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        // 初始化 DP 表
        vector&lt;vector&lt;int&gt;&gt; dp(numRows);

        // 生成每一行
        for (int i = 0; i &lt; numRows; i++) {
            // 调整当前行的大小为 i+1
            dp[i].resize(i + 1);

            // 设置边界值：第一个和最后一个元素为 1
            dp[i][0] = dp[i][i] = 1;

            // 计算中间元素
            for (int j = 1; j &lt; i; j++) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            }
        }

        // 返回生成的杨辉三角
        return dp;
    }
};</code></pre>
    <h3>
     <strong>
      代码思路
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        初始化 DP 表
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         创建一个二维向量
         <code>
          dp
         </code>
         ，用于存储杨辉三角的每一行。
        </p>
       </li>
       <li>
        <p>
         <code>
          dp
         </code>
         的大小为
         <code>
          numRows
         </code>
         ，表示杨辉三角的行数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        生成每一行
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         使用一个外层循环遍历每一行（从
         <code>
          0
         </code>
         到
         <code>
          numRows - 1
         </code>
         ）。
        </p>
       </li>
       <li>
        <p>
         对于每一行
         <code>
          i
         </code>
         ，调整其大小为
         <code>
          i + 1
         </code>
         （因为第
         <code>
          i
         </code>
         行有
         <code>
          i + 1
         </code>
         个元素）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        设置边界值
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         每一行的第一个元素和最后一个元素总是
         <code>
          1
         </code>
         ，即：
        </p>
        <pre><code class="language-cpp">dp[i][0] = dp[i][i] = 1;</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        计算中间元素
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         使用一个内层循环计算每一行的中间元素（从第
         <code>
          2
         </code>
         个元素到倒数第
         <code>
          2
         </code>
         个元素）。
        </p>
       </li>
       <li>
        <p>
         每个中间元素等于它左上方和右上方元素的和，即：
        </p>
        <pre><code class="language-cpp">dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        返回结果
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         最终返回
         <code>
          dp
         </code>
         表，即生成的杨辉三角。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      代码执行流程
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        初始化
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         <code>
          dp
         </code>
         表被创建，大小为
         <code>
          numRows
         </code>
         ，每一行是一个空的
         <code>
          vector&lt;int&gt;
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        生成每一行
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         对于第
         <code>
          i
         </code>
         行：
        </p>
        <ul>
         <li>
          <p>
           调整大小为
           <code>
            i + 1
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           设置第一个和最后一个元素为
           <code>
            1
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           计算中间元素（如果存在）。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        返回结果
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         返回完整的
         <code>
          dp
         </code>
         表。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      示例
     </strong>
    </h3>
    <p>
     假设
     <code>
      numRows = 5
     </code>
     ，代码的执行过程如下：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        第 0 行
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调整大小为
         <code>
          1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         设置
         <code>
          dp[0][0] = 1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         行内容：
         <code>
          [1]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        第 1 行
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调整大小为
         <code>
          2
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         设置
         <code>
          dp[1][0] = 1
         </code>
         和
         <code>
          dp[1][1] = 1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         行内容：
         <code>
          [1, 1]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        第 2 行
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调整大小为
         <code>
          3
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         设置
         <code>
          dp[2][0] = 1
         </code>
         和
         <code>
          dp[2][2] = 1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         计算中间元素：
         <code>
          dp[2][1] = dp[1][0] + dp[1][1] = 1 + 1 = 2
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         行内容：
         <code>
          [1, 2, 1]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        第 3 行
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调整大小为
         <code>
          4
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         设置
         <code>
          dp[3][0] = 1
         </code>
         和
         <code>
          dp[3][3] = 1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         计算中间元素：
        </p>
        <ul>
         <li>
          <p>
           <code>
            dp[3][1] = dp[2][0] + dp[2][1] = 1 + 2 = 3
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           <code>
            dp[3][2] = dp[2][1] + dp[2][2] = 2 + 1 = 3
           </code>
           。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         行内容：
         <code>
          [1, 3, 3, 1]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        第 4 行
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         调整大小为
         <code>
          5
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         设置
         <code>
          dp[4][0] = 1
         </code>
         和
         <code>
          dp[4][4] = 1
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         计算中间元素：
        </p>
        <ul>
         <li>
          <p>
           <code>
            dp[4][1] = dp[3][0] + dp[3][1] = 1 + 3 = 4
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           <code>
            dp[4][2] = dp[3][1] + dp[3][2] = 3 + 3 = 6
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           <code>
            dp[4][3] = dp[3][2] + dp[3][3] = 3 + 1 = 4
           </code>
           。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         行内容：
         <code>
          [1, 4, 6, 4, 1]
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      最终结果
     </strong>
    </h3>
    <pre>[
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1]
]</pre>
    <hr/>
    <h3>
     <strong>
      复杂度分析
     </strong>
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        时间复杂度
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         生成每一行需要 O(i) 的时间，其中 i 是行号。
        </p>
       </li>
       <li>
        <p>
         总时间复杂度为：
        </p>
        <p class="img-center">
         <img alt="" height="90" src="https://i-blog.csdnimg.cn/direct/dcda5a4473204558bf44ae0b3bf39d84.png" width="579"/>
        </p>
       </li>
       <li>
        <p>
         其中 n=numRows。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        空间复杂度
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         需要存储整个杨辉三角，空间复杂度为 O(n2)。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3 style="background-color:transparent">
     <strong>
      总结
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       代码通过动态规划（DP）表的方式生成杨辉三角，思路清晰且高效。
      </p>
     </li>
     <li>
      <p>
       使用
       <code>
        resize
       </code>
       为每一行分配空间，并通过状态转移方程计算中间元素。
      </p>
     </li>
     <li>
      <p>
       代码的时间复杂度和空间复杂度均为 O(n2)，是生成杨辉三角的经典实现。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436303236393739" class_="artid" style="display:none">
 </p>
</div>


