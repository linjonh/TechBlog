---
layout: post
title: "项目负载均衡式在线OJ"
date: 2025-03-08 20:05:25 +0800
description: "该项目完成了类似力扣，牛客网等网站的在线OJ功能， 通过平衡负载函数，将所有用户发出的请求平均分配给每一台主机，做到负载均衡实现高并发、高可用性和高性能。"
keywords: "【项目】负载均衡式在线OJ"
categories: ['未分类']
tags: ['负载均衡', 'Linux', 'C']
artid: "146092660"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146092660
    alt: "项目负载均衡式在线OJ"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146092660
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146092660
cover: https://bing.ee123.net/img/rand?artid=146092660
image: https://bing.ee123.net/img/rand?artid=146092660
img: https://bing.ee123.net/img/rand?artid=146092660
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【项目】负载均衡式在线OJ
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%BC%8F%E5%9C%A8%E7%BA%BFOJ" name="%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%BC%8F%E5%9C%A8%E7%BA%BFOJ">
     负载均衡式在线OJ
    </h2>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%EF%BC%9A" name="1.%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%EF%BC%9A">
     1.项目介绍：
    </h2>
    <p>
     该项目完成了类似力扣，牛客网等网站的在线OJ功能， 通过平衡负载函数，将所有用户发出的请求平均分配给每一台主机，做到负载均衡
     <span style="color:#000000">
      实现高并发、高可用性和高性能。
     </span>
    </p>
    <p>
     <span style="color:#000000">
      <strong>
       三个板块
      </strong>
      ：
     </span>
    </p>
    <blockquote>
     <div>
      <span style="color:#000000">
       comm : 时间戳生成、文件路径处理、文件读写操作以及字符串分割功能。
      </span>
     </div>
     <div>
      <span style="color:#000000">
       compile_server : 编译与运⾏模块
      </span>
     </div>
     <div>
      <span style="color:#000000">
       oj_server : 获取题目列表，查看题目编写题目界面，负载均衡等功能
      </span>
     </div>
    </blockquote>
    <p>
     <strong>
      开发环境 :
     </strong>
     C++、Ubuntu、vim、g++、gdb、git、Makefile
    </p>
    <p>
     <strong>
      所用技术栈 :
     </strong>
     HTML、Json、STL标准库、Boost准标准库、cpp-httplib、ctemplate、MySQL
    </p>
    <p>
     <strong>
      项目源码 :
     </strong>
    </p>
    <h2 id="2.comm" name="2.comm">
     2.comm
    </h2>
    <h3 id="2.1%20log.hpp" name="2.1%20log.hpp">
     2.1 log.hpp
    </h3>
    <p>
     log.hpp定义了一个日志系统，可以进行日志等级，日志格式化，日志输出等功能，命名空间为ns_log。
    </p>
    <h4 id="%E6%97%A5%E5%BF%97%E7%AD%89%E7%BA%A7" name="%E6%97%A5%E5%BF%97%E7%AD%89%E7%BA%A7">
     日志等级
    </h4>
    <pre><code class="language-cpp">enum
{
    INFO,    // 信息级别日志
    DEBUG,   // 调试级别日志
    WARNING, // 警告级别日志
    ERROR,   // 错误级别日志
    FATAL    // 致命错误级别日志
};</code></pre>
    <h4 id="%E5%BC%80%E6%94%BE%E5%BC%8F%E6%97%A5%E5%BF%97" name="%E5%BC%80%E6%94%BE%E5%BC%8F%E6%97%A5%E5%BF%97">
     开放式日志
    </h4>
    <p>
     使用方法 :   LOG(INFO) &lt;&lt; "This is an info message" &lt;&lt; "\n";
    </p>
    <pre><code class="language-cpp">inline std::ostream &amp;Log(const std::string &amp;level, const std::string &amp;file_name, int line)

#define LOG(level) Log(#level, __FILE__, __LINE__)</code></pre>
    <h4 id="%C2%A0%E6%97%B6%E9%97%B4%E6%88%B3%E5%B7%A5%E5%85%B7" name="%C2%A0%E6%97%B6%E9%97%B4%E6%88%B3%E5%B7%A5%E5%85%B7">
     时间戳工具
    </h4>
    <pre><code class="language-cpp">TimeUtil::GetTimeStamp()</code></pre>
    <h3 id="2.2%20util.hpp" name="2.2%20util.hpp">
     2.2 util.hpp
    </h3>
    <h4 id="TimeUtil%E7%B1%BB" name="TimeUtil%E7%B1%BB">
     TimeUtil类
    </h4>
    <p>
     此类中共有两个接口，分别为GetTimeStamp()，用于获取当前时间的秒级时间戳，目的是为了给文件形成唯一的文件名，另外一个是GetTimeMs()获取当前时间的毫秒级时间戳。
    </p>
    <pre><code class="language-cpp">static std::string GetTimeStamp()

static std::string GetTimeMs()</code></pre>
    <h4 id="PathUtil%E7%B1%BB" name="PathUtil%E7%B1%BB">
     PathUtil类
    </h4>
    <p>
     该类共有7个接口
    </p>
    <blockquote>
     <p>
      AddSuffix：将文件名与后缀拼接，生成完整的文件路径 ；
     </p>
     <p>
      Src: 构建源文件的完整路径,返回.cpp后缀的文件；
     </p>
     <p>
      Exe:构建可执行文件的完整路径,添加.exe后缀
     </p>
     <p>
      CompileError:构建编译错误文件的完整路径,添加.compile_error后缀
     </p>
     <p>
      Stdin:构建标准输入文件的完整路径,添加.stdin后缀
      <br/>
      Stdout:构建标准输出文件的完整路径,添加.stdout后缀
     </p>
     <p>
      Stderr:构建标准错误文件的完整路径,添加.stderr后缀
     </p>
    </blockquote>
    <pre><code class="language-cpp">static std::string AddSuffix(const std::string &amp;file_name, const std::string &amp;suffix)
static std::string Src(const std::string &amp;file_name)
static std::string Exe(const std::string &amp;file_name)
static std::string CompilerError(const std::string &amp;file_name)
static std::string Stdin(const std::string &amp;file_name)
static std::string Stdout(const std::string &amp;file_name)
static std::string Stderr(const std::string &amp;file_name)</code></pre>
    <h4 id="FileUtil%E7%B1%BB" name="FileUtil%E7%B1%BB">
     FileUtil类
    </h4>
    <p>
     IsFileExists：检查文件是否存在，存在返回true，不存在返回false
    </p>
    <pre><code class="language-cpp">static bool IsFileExists(const std::string &amp;path_name)</code></pre>
    <p>
     UniqFileName：使用上述GetTimeMs函数获得唯一文件名
    </p>
    <pre><code class="language-cpp">static std::string UniqFileName()</code></pre>
    <p>
     WriteFile：将内容写入指定文件，target为目标文件路径，content为要写入的内容,写入成功为true
    </p>
    <pre><code class="language-cpp">static bool WriteFile(const std::string &amp;target, const std::string &amp;content)</code></pre>
    <p>
     ReadFile： 读取文件的内容，target:目标文件路径,content:用于存储读取内容的字符串指针
    </p>
    <pre><code class="language-cpp">static bool ReadFile(const std::string &amp;target, std::string *content, bool keep = false)</code></pre>
    <h4 id="StringUtil%E7%B1%BB" name="StringUtil%E7%B1%BB">
     StringUtil类
    </h4>
    <p>
     SplitString：将字符串按指定分隔符切分，并存储到target中，str：要切分的字符串，target：存储切结果的字符串向量，sep：切割符，该方法是基于Boost库实现的
     <br/>
    </p>
    <pre><code class="language-cpp">static void SplitString(const std::string &amp;str, std::vector&lt;std::string&gt; *target, const std::string &amp;sep)</code></pre>
    <h2 id="3.Compile_server" name="3.Compile_server">
     3.Compile_server
    </h2>
    <h3 id="3.1compile_run.hpp" name="3.1compile_run.hpp">
     3.1compile_run.hpp
    </h3>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         编译用户代码
        </strong>
        : 将用户提交的代码编译为可执行文件。
       </p>
      </li>
      <li>
       <p>
        <strong>
         运行用户程序
        </strong>
        : 在限制的 CPU 时间和内存内运行用户程序。
       </p>
      </li>
      <li>
       <p>
        <strong>
         处理运行结果
        </strong>
        : 根据运行结果生成状态码和描述信息。
       </p>
      </li>
      <li>
       <p>
        <strong>
         清理临时文件
        </strong>
        : 在运行结束后清理生成的临时文件
       </p>
      </li>
     </ul>
    </blockquote>
    <h4 id="RemoveTempFile" name="RemoveTempFile">
     RemoveTempFile
    </h4>
    <pre><code class="language-cpp">static void RemoveTempFile(const std::string &amp;file_name)
</code></pre>
    <p>
     该方法用于清理有指定文件名相关的临时文件。可用于清理以下文件：
    </p>
    <blockquote>
     <p>
      源文件 (file_name.cpp)
      <br/>
      编译错误文件 (file_name.compile_error)
      <br/>
      可执行文件 (file_name.exe)
      <br/>
      标准输入文件 (file_name.stdin)
      <br/>
      标准输出文件 (file_name.stdout)
      <br/>
      标准错误文件 (file_name.stderr)
     </p>
    </blockquote>
    <h4 id="%C2%A0CodeToDesc" name="%C2%A0CodeToDesc">
     CodeToDesc
    </h4>
    <pre><code class="language-cpp">static std::string CodeToDesc(int code, const std::string &amp;file_name)</code></pre>
    <p>
     该方法的作用是将状态码转换为描述信息
    </p>
    <p>
     code：状态码，file_name：文件名  以下为状态码处理：
    </p>
    <blockquote>
     <p>
      0: 编译运行成功。
      <br/>
      -1: 提交的代码为空。
      <br/>
      -2: 未知错误。
      <br/>
      -3: 编译错误（从 file_name.compile_error 文件中读取错误信息）。
      <br/>
      SIGABRT (6): 内存超过范围。
      <br/>
      SIGXCPU (24): CPU 使用超时。
      <br/>
      SIGFPE (8): 浮点数溢出。
     </p>
    </blockquote>
    <h4 id="%C2%A0Start" name="%C2%A0Start">
     Start
    </h4>
    <pre><code class="language-cpp">static void Start(const std::string &amp;in_json, std::string *out_json)</code></pre>
    <p>
     该方法：编译并运行用户提交的代码，返回运行结果
     <br/>
     参数：in_json:输入的 JSON 字符串，包含用户代码、输入、CPU 时间限制和内存限制
     <br/>
     out_json:输出的 JSON 字符串，包含状态码、描述信息、标准输出和标准错误
    </p>
    <pre><code class="language-cpp">输入JSON格式：
{
  "code": "用户提交的代码",
  "input": "用户输入",
  "cpu_limit": "CPU 时间限制",
  "mem_limit": "内存限制"
}

输出JSON格式：
{
  "status": "状态码",
  "reason": "描述信息",
  "stdout": "标准输出",
  "stderr": "标准错误"
}</code></pre>
    <blockquote>
     <p>
      解析输入 JSON，获取代码、输入、CPU 限制和内存限制。
      <br/>
      检查代码是否为空，如果为空，设置状态码为 -1。
      <br/>
      生成唯一的文件名，并将代码写入临时源文件。
      <br/>
      调用 Compiler::Compile 编译代码：
      <br/>
      如果编译失败，设置状态码为 -3。
      <br/>
      调用 Runner::Run 运行编译后的程序：
      <br/>
      如果运行失败，设置状态码为运行结果。
      <br/>
      根据状态码生成描述信息。
      <br/>
      如果运行成功，读取标准输出和标准错误文件的内容。
      <br/>
      将结果写入输出 JSON。
      <br/>
      （可选）清理临时文件
     </p>
    </blockquote>
    <p>
     所依赖的外部模块：
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          Compiler
         </code>
        </strong>
        : 编译模块，负责将用户代码编译为可执行文件。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          Runner
         </code>
        </strong>
        : 运行模块，负责运行编译后的程序，并限制其 CPU 和内存使用。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_log
         </code>
        </strong>
        : 日志模块，用于记录日志信息。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_util
         </code>
        </strong>
        : 工具模块，提供文件、路径、时间等工具函数。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          JsonCpp
         </code>
        </strong>
        : 用于解析和生成 JSON 数据。
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="%C2%A03.2compile.hpp" name="%C2%A03.2compile.hpp">
     3.2compile.hpp
    </h3>
    <h4 id="Compiler%E7%B1%BB" name="Compiler%E7%B1%BB">
     Compiler类
    </h4>
    <p>
     Compile
    </p>
    <pre><code class="language-cpp">static bool Compile(const std::string &amp;file_name)</code></pre>
    <blockquote>
     <p>
      使用 fork 创建子进程。
      <br/>
      在子进程中：
      <br/>
      打开编译错误文件（file_name.compile_error），用于存储编译错误信息。
      <br/>
      使用 dup2 将标准错误输出重定向到编译错误文件。
      <br/>
      使用 execlp 调用 g++ 编译器，将源文件（file_name.cpp）编译为可执行文件（file_name.exe）。
      <br/>
      如果 execlp 失败，记录错误日志并退出。
      <br/>
      在父进程中：
      <br/>
      使用 waitpid 等待子进程结束。
      <br/>
      检查是否生成了可执行文件（file_name.exe）。
      <br/>
      如果生成成功，记录日志并返回 true；否则返回 false。
     </p>
    </blockquote>
    <blockquote>
     <p>
      所依赖的外部模块：
     </p>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          ns_util
         </code>
        </strong>
        : 工具模块，提供路径拼接和文件操作功能。
       </p>
       <ul>
        <li>
         <p>
          <code>
           PathUtil::Src(file_name)
          </code>
          : 获取源文件路径（
          <code>
           ./temp/file_name.cpp
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          <code>
           PathUtil::Exe(file_name)
          </code>
          : 获取可执行文件路径（
          <code>
           ./temp/file_name.exe
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          <code>
           PathUtil::CompilerError(file_name)
          </code>
          : 获取编译错误文件路径（
          <code>
           ./temp/file_name.compile_error
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          <code>
           FileUtil::IsFileExists(path)
          </code>
          : 检查文件是否存在。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_log
         </code>
        </strong>
        : 日志模块，用于记录日志信息。
       </p>
       <ul>
        <li>
         <p>
          <code>
           LOG(INFO)
          </code>
          : 记录信息日志。
         </p>
        </li>
        <li>
         <p>
          <code>
           LOG(WARNING)
          </code>
          : 记录警告日志。
         </p>
        </li>
        <li>
         <p>
          <code>
           LOG(ERROR)
          </code>
          : 记录错误日志
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h3 id="%C2%A03.3runner.hpp" name="%C2%A03.3runner.hpp">
     3.3runner.hpp
    </h3>
    <h4 id="Runner%E7%B1%BB" name="Runner%E7%B1%BB">
     Runner类
    </h4>
    <p>
     SetProcLimit接口
    </p>
    <pre><code class="language-cpp">static void SetProcLimit(int _cpu_limit, int _mem_limit)</code></pre>
    <p>
     参数：_cpu_limit:CPU时间限制，_mem_limit:内存资源限制，设置进程的 CPU 和内存资源限制。
    </p>
    <p>
     <code>
      setrlimit
     </code>
     系统调用设置资源限制。
     <code>
      RLIMIT_CPU
     </code>
     : 限制 CPU 时间。
     <code>
      RLIMIT_AS
     </code>
     : 限制虚拟内存大小。
    </p>
    <p>
     Run接口
    </p>
    <p>
     运行编译后的程序，并限制其 CPU 和内存资源使用
    </p>
    <pre><code class="language-cpp">static int Run(const std::string &amp;file_name, int cpu_limit, int mem_limit)</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        <code>
         &gt; 0
        </code>
        : 程序异常退出，返回值为收到的信号编号。
       </p>
      </li>
      <li>
       <p>
        <code>
         == 0
        </code>
        : 程序正常运行完毕。
       </p>
      </li>
      <li>
       <p>
        <code>
         &lt; 0
        </code>
        : 内部错误（如文件打开失败或子进程创建失败）
       </p>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
     </p>
     <ol>
      <li>
       <p>
        获取可执行文件、标准输入、标准输出和标准错误的路径。
       </p>
      </li>
      <li>
       <p>
        打开标准输入、标准输出和标准错误文件。
       </p>
      </li>
      <li>
       <p>
        使用
        <code>
         fork
        </code>
        创建子进程。
       </p>
      </li>
      <li>
       <p>
        在子进程中：
       </p>
       <ul>
        <li>
         <p>
          使用
          <code>
           dup2
          </code>
          重定向标准输入、标准输出和标准错误。
         </p>
        </li>
        <li>
         <p>
          调用
          <code>
           SetProcLimit
          </code>
          设置资源限制。
         </p>
        </li>
        <li>
         <p>
          使用
          <code>
           execl
          </code>
          运行可执行程序。
         </p>
        </li>
        <li>
         <p>
          如果
          <code>
           execl
          </code>
          失败，记录错误日志并退出。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        在父进程中：
       </p>
       <ul>
        <li>
         <p>
          关闭文件描述符。
         </p>
        </li>
        <li>
         <p>
          使用
          <code>
           waitpid
          </code>
          等待子进程结束。
         </p>
        </li>
        <li>
         <p>
          获取子进程的退出状态，并返回状态码的低 7 位（信号编号）。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <p>
      依赖的外部模块
     </p>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          ns_util
         </code>
        </strong>
        : 工具模块，提供路径拼接功能。
       </p>
       <ul>
        <li>
         <p>
          <code>
           PathUtil::Exe(file_name)
          </code>
          : 获取可执行文件路径（
          <code>
           ./temp/file_name.exe
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          <code>
           PathUtil::Stdin(file_name)
          </code>
          : 获取标准输入文件路径（
          <code>
           ./temp/file_name.stdin
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          <code>
           PathUtil::Stdout(file_name)
          </code>
          : 获取标准输出文件路径（
          <code>
           ./temp/file_name.stdout
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          <code>
           PathUtil::Stderr(file_name)
          </code>
          : 获取标准错误文件路径（
          <code>
           ./temp/file_name.stderr
          </code>
          ）。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_log
         </code>
        </strong>
        : 日志模块，用于记录日志信息。
       </p>
       <ul>
        <li>
         <p>
          <code>
           LOG(INFO)
          </code>
          : 记录信息日志。
         </p>
        </li>
        <li>
         <p>
          <code>
           LOG(ERROR)
          </code>
          : 记录错误日志。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <h2 id="%C2%A04.oj_server" name="%C2%A04.oj_server" style="background-color:transparent">
     4.oj_server
    </h2>
    <h3 id="4.1%20oj_control.hpp" name="4.1%20oj_control.hpp">
     4.1 oj_control.hpp
    </h3>
    <p>
     主要的功能:管理题目数据，渲染网面，负载均衡，调用编译和运行服务。
    </p>
    <p>
     核心类
    </p>
    <blockquote>
     <p>
      Machine：表示提供编译和运行服务的主机
     </p>
     <p>
      LoadBlance：实现负载均衡
     </p>
     <p>
      Control：核心业务逻辑处理器
     </p>
    </blockquote>
    <p>
     依赖模块
    </p>
    <blockquote>
     <p>
      <code>
       ns_model
      </code>
      : 题目数据管理。
     </p>
     <p>
      <code>
       ns_view
      </code>
      : HTML 渲染。
     </p>
     <p>
      <code>
       ns_log
      </code>
      : 日志记录。
     </p>
     <p>
      <code>
       ns_util
      </code>
      : 工具函数。
     </p>
     <p>
      <code>
       httplib
      </code>
      : HTTP 客户端。
     </p>
    </blockquote>
    <h4 id="Machine%E7%B1%BB" name="Machine%E7%B1%BB">
     Machine类
    </h4>
    <h4 id="IncLoad" name="IncLoad">
     IncLoad
    </h4>
    <pre><code class="language-cpp">void IncLoad()//增加主机负载，使用互斥锁保护负载变量，确保线程安全。</code></pre>
    <h4 id="DecLoad" name="DecLoad">
     DecLoad
    </h4>
    <pre><code class="language-cpp">void DecLoad()//减少主机负载，使用互斥锁保护负载变量，确保线程安全。</code></pre>
    <h4 id="ResetLoad" name="ResetLoad">
     ResetLoad
    </h4>
    <pre><code class="language-cpp">void ResetLoad()//重置主机的负载为0，使用互斥锁保护负载变量，确保线程安全</code></pre>
    <h4 id="Load" name="Load">
     Load
    </h4>
    <pre><code class="language-cpp">uint64_t Load() //获取主机的当前负载,使用互斥锁保护负载变量，确保线程安全</code></pre>
    <h4 id="LoadBlance%E7%B1%BB" name="LoadBlance%E7%B1%BB" style="background-color:transparent">
     LoadBlance类
    </h4>
    <h4 id="LoadConf" name="LoadConf">
     LoadConf
    </h4>
    <pre><code class="language-cpp">bool LoadConf(const std::string &amp;machine_conf)</code></pre>
    <p>
     从配置文件中加载主机信息，参数：machine_conf：配置文件路径
    </p>
    <p>
     读取配置文件，解析每台主机的 IP 和端口。初始化主机对象，并将其加入在线主机列表。
    </p>
    <h4 id="SmartChoice" name="SmartChoice">
     SmartChoice
    </h4>
    <pre><code class="language-cpp">bool SmartChoice(int *id, Machine **m)</code></pre>
    <p>
     参数:id 输出型参数返回选择的主机ID， m:输出参数，返回选择的主机的对象指针。
     <br/>
     遍历在线主机列表，选择负载最低的主机
    </p>
    <h4 id="OfflineMachine" name="OfflineMachine">
     OfflineMachine
    </h4>
    <pre><code class="language-cpp">void OfflineMachine(int which)//将指定主机离线</code></pre>
    <p>
     which为要离线的主机ID
    </p>
    <h4 id="OnlineMachine" name="OnlineMachine">
     OnlineMachine
    </h4>
    <pre><code class="language-cpp">void OnlineMachine()//将所有离线主机全部上线</code></pre>
    <p>
     ShowMachine
    </p>
    <pre><code class="language-cpp">void ShowMachines()//打印当前在线和离线主机列表（用于调试）。</code></pre>
    <h4 id="Control%E7%B1%BB" name="Control%E7%B1%BB" style="background-color:transparent">
     Control类
    </h4>
    <p>
     核心业务逻辑控制器，负责管理题目数据、渲染网页、负载均衡以及调用编译和运行服务。
    </p>
    <h4 id="RecoveryMachine" name="RecoveryMachine">
     RecoveryMachine
    </h4>
    <pre><code class="language-cpp">void RecoveryMachine()//恢复离线主机为在线状态</code></pre>
    <h4 id="AllQuestions" name="AllQuestions">
     AllQuestions
    </h4>
    <pre><code class="language-cpp">bool AllQuestions(string *html) //获取所有题目数据并渲染为网页。</code></pre>
    <p>
     html:输出参数，返回渲染后的HTML内容
    </p>
    <p>
     从Model获取所有题目数据，使用View渲染题目列表为HTML
    </p>
    <h4 id="Question" name="Question">
     Question
    </h4>
    <pre><code class="language-cpp">bool Question(const string &amp;number, string *html)//获取指定题目数据并渲染为网页</code></pre>
    <p>
     number: 题目编号。html: 输出参数，返回渲染后的 HTML 内容。
    </p>
    <h4 id="Judge" name="Judge">
     Judge
    </h4>
    <pre><code class="language-cpp">void Judge(const std::string &amp;number, const std::string in_json, std::string *out_json)</code></pre>
    <p>
     参数：number：题目编号，in_json:输入的JSON数据，out_json:输出的JSON数据，包含评测数据
    </p>
    <blockquote>
     <p>
      从 Model 获取指定题目的详细信息。
      <br/>
      解析输入 JSON，拼接用户代码和测试用例代码。
      <br/>
      使用负载均衡选择主机，发起 HTTP 请求调用编译和运行服务。
      <br/>
      将评测结果写入输出 JSON。
     </p>
    </blockquote>
    <blockquote>
     <p>
      所依赖的外部模块
     </p>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          ns_model
         </code>
        </strong>
        : 提供题目数据管理功能。
       </p>
       <ul>
        <li>
         <p>
          <code>
           GetAllQuestions
          </code>
          : 获取所有题目数据。
         </p>
        </li>
        <li>
         <p>
          <code>
           GetOneQuestion
          </code>
          : 获取指定题目数据。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_view
         </code>
        </strong>
        : 提供 HTML 渲染功能。
       </p>
       <ul>
        <li>
         <p>
          <code>
           AllExpandHtml
          </code>
          : 渲染题目列表为 HTML。
         </p>
        </li>
        <li>
         <p>
          <code>
           OneExpandHtml
          </code>
          : 渲染题目详情为 HTML。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_log
         </code>
        </strong>
        : 提供日志记录功能。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_util
         </code>
        </strong>
        : 提供工具函数（如字符串分割）。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          httplib
         </code>
        </strong>
        : 提供 HTTP 客户端功能，用于调用编译和运行服务。
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="%C2%A04.2%20oj_model" name="%C2%A04.2%20oj_model">
     4.2 oj_model
    </h3>
    <h4 id="Question%E7%BB%93%E6%9E%84%E4%BD%93" name="Question%E7%BB%93%E6%9E%84%E4%BD%93">
     Question结构体
    </h4>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        变量名
       </td>
       <td>
        类型
       </td>
       <td>
        描述
       </td>
      </tr>
      <tr>
       <td>
        number
       </td>
       <td>
        std::string
       </td>
       <td>
        题目编号，唯一标识
       </td>
      </tr>
      <tr>
       <td>
        title
       </td>
       <td>
        std::string
       </td>
       <td>
        题目标题
       </td>
      </tr>
      <tr>
       <td>
        star
       </td>
       <td>
        std::string
       </td>
       <td>
        题目难度（简单、中等、困难）
       </td>
      </tr>
      <tr>
       <td>
        desc
       </td>
       <td>
        std::string
       </td>
       <td>
        题目描述
       </td>
      </tr>
      <tr>
       <td>
        header
       </td>
       <td>
        std::string
       </td>
       <td>
        题目预设代码（用户编辑器的初始代码）
       </td>
      </tr>
      <tr>
       <td>
        tail
       </td>
       <td>
        std::string
       </td>
       <td>
        题目测试用例（与
        <code>
         header
        </code>
        拼接形成完整代码）
       </td>
      </tr>
      <tr>
       <td>
        cpu_limit
       </td>
       <td>
        int
       </td>
       <td>
        题目时间限制（单位：秒）
       </td>
      </tr>
      <tr>
       <td>
        mem_limit
       </td>
       <td>
        int
       </td>
       <td>
        题目空间限制（单位：KB)
       </td>
      </tr>
     </tbody>
    </table>
    <h4 id="Model%E7%B1%BB" name="Model%E7%B1%BB">
     Model类
    </h4>
    <h4 id="QueryMysql" name="QueryMysql">
     QueryMysql
    </h4>
    <pre><code class="language-cpp">bool QueryMySql(const std::string &amp;sql, vector&lt;Question&gt; *out)//执行 SQL 查询，并将结果存储到 out 中。</code></pre>
    <p>
     sql:要执行的SQL查询语句，out:输出参数，存储查询结果的Question向量
    </p>
    <h4 id="GetAllQuestions" name="GetAllQuestions">
     GetAllQuestions
    </h4>
    <pre><code class="language-cpp">bool GetAllQuestions(vector&lt;Question&gt; *out)</code></pre>
    <blockquote>
     <p>
      构造 SQL 查询语句：
      <code>
       SELECT * FROM oj_questions
      </code>
     </p>
     <p>
      调用
      <code>
       QueryMySql
      </code>
      执行查询
     </p>
    </blockquote>
    <h4 id="GetOneQuestion" name="GetOneQuestion">
     GetOneQuestion
    </h4>
    <pre><code class="language-cpp">bool GetOneQuestion(const std::string &amp;number, Question *q)</code></pre>
    <blockquote>
     <p>
      构造 SQL 查询语句：SELECT * FROM oj_questions WHERE number=&lt;number&gt;。
      <br/>
      调用 QueryMySql 执行查询。
      <br/>
      如果查询结果中有且仅有一条记录，将其赋值给 q。
     </p>
    </blockquote>
    <blockquote>
     <h4 id="%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97" name="%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97">
      <strong>
       依赖的外部模块
      </strong>
     </h4>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          ns_log
         </code>
        </strong>
        : 提供日志记录功能。
       </p>
       <ul>
        <li>
         <p>
          <code>
           LOG(INFO)
          </code>
          : 记录信息日志。
         </p>
        </li>
        <li>
         <p>
          <code>
           LOG(WARNING)
          </code>
          : 记录警告日志。
         </p>
        </li>
        <li>
         <p>
          <code>
           LOG(FATAL)
          </code>
          : 记录致命错误日志。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         <code>
          ns_util
         </code>
        </strong>
        : 提供工具函数。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          mysql.h
         </code>
        </strong>
        : MySQL C API 头文件，用于连接和操作 MySQL 数据库。
       </p>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <pre>// 以下是硬编码的常量
    const std::string oj_questions = "oj_questions"; // 数据库表名
    const std::string host = "127.0.0.1";           // MySQL 服务器地址
    const std::string user = "oj_client";           // MySQL 用户名
    const std::string passwd = "123456";            // MySQL 密码
    const std::string db = "oj";                    // 数据库名称
    const int port = 3306;                          // MySQL 服务器端口号</pre>
    </blockquote>
    <h3 id="%C2%A04.3%20oj_view" name="%C2%A04.3%20oj_view">
     4.3 oj_view
    </h3>
    <h4 id="AllExpandHtml" name="AllExpandHtml">
     AllExpandHtml
    </h4>
    <pre><code class="language-cpp">void AllExpandHtml(const vector&lt;struct Question&gt; &amp;questions, std::string *html)</code></pre>
    <p>
     question:题目列表，包含所有题目的详细信息，html：输出参数，存储渲染后的html内容。
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        构造模板文件路径：
        <code>
         ./template_html/all_questions.html
        </code>
        。
       </p>
      </li>
      <li>
       <p>
        创建
        <code>
         ctemplate::TemplateDictionary
        </code>
        对象
        <code>
         root
        </code>
        ，用于存储模板数据。
       </p>
      </li>
      <li>
       <p>
        遍历题目列表，将每个题目的编号、标题和难度添加到模板数据中。
       </p>
      </li>
      <li>
       <p>
        加载模板文件。
       </p>
      </li>
      <li>
       <p>
        使用模板数据渲染 HTML 页面，并将结果存储到
        <code>
         html
        </code>
        中。
       </p>
      </li>
     </ol>
    </blockquote>
    <h4 id="%C2%A0OneExpandHtml" name="%C2%A0OneExpandHtml">
     OneExpandHtml
    </h4>
    <p>
     q：单个题目的详细信息，html：输出参数存储渲染后的html内容
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        构造模板文件路径：
        <code>
         ./template_html/one_question.html
        </code>
        。
       </p>
      </li>
      <li>
       <p>
        创建
        <code>
         ctemplate::TemplateDictionary
        </code>
        对象
        <code>
         root
        </code>
        ，用于存储模板数据。
       </p>
      </li>
      <li>
       <p>
        将题目的编号、标题、难度、描述和预设代码添加到模板数据中。
       </p>
      </li>
      <li>
       <p>
        加载模板文件。
       </p>
      </li>
      <li>
       <p>
        使用模板数据渲染 HTML 页面，并将结果存储到
        <code>
         html
        </code>
        中。
       </p>
      </li>
     </ol>
    </blockquote>
    <p>
     所依赖的外部模块
    </p>
    <blockquote>
     <p>
      ctemplate: 用于 HTML 模板渲染。
     </p>
     <p>
      ctemplate::TemplateDictionary: 存储模板数据。
      <br/>
      ctemplate::Template: 加载和渲染模板文件。
      <br/>
      ns_model: 提供题目数据管理功能。
      <br/>
      Question: 题目数据结构，包含编号、标题、难度、描述、预设代码等信息。
     </p>
    </blockquote>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37343733323632382f:61727469636c652f64657461696c732f313436303932363630" class_="artid" style="display:none">
 </p>
</div>


