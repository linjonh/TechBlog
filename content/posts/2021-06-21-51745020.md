---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f426c61636b4d75645f37:2f61727469636c652f64657461696c732f3531373435303230"
layout: post
title: "使用DirectX打造游戏GUI界面一"
date: 2021-06-21 11:47:52 +0800
description: "本系列文章由zhmxy555（毛星云）编写，转载请注明"
keywords: "directx写gui"
categories: ['Gui']
tags: ['Gui', 'Direct', 'C']
artid: "51745020"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=51745020
    alt: "使用DirectX打造游戏GUI界面一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=51745020
featuredImagePreview: https://bing.ee123.net/img/rand?artid=51745020
---

# 使用DirectX打造游戏GUI界面（一）

> 本系列文章由zhmxy555（毛星云）编写，转载请注明出处。
>
> 文章链接：
> <http://blog.csdn.net/poem_qianmo/article/details/16384009>
>
> 作者：毛星云（浅墨）    邮箱：
>
> [happylifemxy@163.com](mailto:happylifemxy@163.com)

> 众所周知，GUI是游戏中不可缺少的元素，这篇文章中，我们首先了解了游戏GUI界面的知识与相关概念，然后一起设计了一个封装好GUI图形界面的C++类。这个类有着非常强的扩展性，使用也是极其方便，很适合二次开发。

> 先看一张实现的效果图吧：
>
> ![](https://img-blog.csdn.net/20131117191916093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 其中的背景音乐，游戏图标和背景图片都出自育碧公司的招牌式大作《刺客信条》。
>
> 程序的窗口大小已经被浅墨调成了1366 x768，现阶段比较流行的笔记本分辨率尺寸（其实真的想吐槽这个奇葩万年不变的电脑屏幕分辨率，在如今的后PC时代。手机屏幕都开始对1920 x1080的分辨率不满足了。。。。）
>
> 嗯，开始正文吧。

> ## 一、UI和GUI的概述
>
> 首先我们看一下UI的比较正统的定义：
>
> 用户界面（
>
> User Interface
>
> ，简称
>
> UI
>
> ，亦称使用者界面）是系统和用户之间进行交互和信息交换的媒介，它实现信息的内部形式与人类可以接受形式之间的转换。
>
> 用户界面是介于用户与硬件之间，为彼此之间交互沟通而设计的相关软件，使得用户能够方便有效地去操作硬件以达成双向之交互，完成所希望的工作，用户界面定义广泛，包含了人机交互与图形用户界面，凡参与人类与机械的信息交流的领域都存在着用户界面。
>
> 而GUI
>
> 的正统定义是：
>
> 图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受。
>
> 我们知道，在游戏中，能够和游戏玩家进行交互是至关重要的。这样的交流可以是文本形式的，视觉显示，声音信号等等。而对于视觉显示而言，绝大多数游戏毋庸置疑就是用图形用户界面(GUI)来和游戏玩家进行交互的。而在游戏过程中，依旧少不了GUI界面的出场，比如说状态显示界面（Head-up Display,HUD），HUD，这个界面提供一切和游戏有关的信息。用于提供玩家剩余任务时间，生命值，坐标位置，以及更多信息。
>
> 让我们欣赏一部分近期的3A游戏大作的UI界面美图吧：

> 《鬼泣5》：
>
> ![](https://img-blog.csdn.net/20131117193108390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 《英雄无敌6》：
>
> ![](https://img-blog.csdn.net/20131117193051453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 欣赏完了，我们继续开讲吧。
>
> ## 二、关于状态显示界面(HUD)
>
> 这一节里让我们一起科普HUD的概念。
>
> 我们知道，通常情况下在游戏中屏幕上会有很多的小的界面模块配上文字，为玩家提供了一些有用的信息，比如玩家剩余任务时间，生命值，魔法值，坐标位置等等更多的信息。而因为在玩家和游戏交互的过程中，这些界面是透过摄像机视角显示出来的，它们被称为HUD(heads-up-display)。在视频游戏中，HUD就是一类可以实时向玩家显示有用信息和符号的GUI，并且它和诸如游戏菜单这样的其他界面不同.HUD中通常没有按钮、编辑框或者适合玩家交互的内容，因为玩家往往都是被游戏本身的画面和内容所吸引，而不是去关注HUD。所以呢，HUD通常并不去使用可以交互的元素，而倾向于使用文本和图像来表示某些信息。所以，游戏选项和偏好设置这样的内容不是HUD的菜，它们直接交由系统菜单来完成。
>
> 下面我们看一看更加规范化的
>
> HUD
>
> 的介绍。
>
> HUD
>
> ，
> heads-up-display，硬着过来翻译就是“
> 抬头显视设备
>
> ”- -
>
> 。这是一个从军事领域起源的技术，可以把一些重要的战术信息显示在正常观察方向的视野范围内，而同时又不会影响对于环境的注意，也不用总是转移视线去专门观察仪表板上的那些指针和数据。游戏借鉴了这个概念，把游戏相关的信息以类似
>
> HUD
>
> 的方式显示在游戏画面上，让玩家可以随时了解那些最重要最直接相关的内容。当然玩家要获得游戏信息可以有别的方式，比如菜单。菜单有着专门的界面，可以容纳更大的信息量，但却不能和游戏画面同时出现。调出菜单意味着中断游戏流程，
>
> HUD
>
> 则在提供必要的信息的同时完全避免了这个问题。
>
> 虽然菜单提供了大量的信息，然而对于处在自由行动状态下的玩家而言，这些信息都不是立刻需要获取的。
>
> HUD
>
> 只提供了最重要最基本的内容：当前场景的地图。切换到战斗状态下之后，
>
> HUD
>
> 所提供的信息便会转变为那些只和战斗相关的部分。
>
> 记得最早的游戏
>
> pong
>
> 在设计的时候就没有
>
> HUD
>
> 的。对于这样一个简单的游戏而言，唯一对玩家有意义需要及时掌握的就是双方的比分，而最早版本的
>
> pong
>
> 没有这个功能，玩家需要自己去记录比分。游戏设计者很快意识到了这个问题，
>
> HUD
>
> 很快就被整合到了后来的游戏之中，并随着游戏的进化一起演变，完善。
>
> 如果被上面的这些书面语绕晕了没关系，说了这么多，一言以蔽之：
> 菜单的目的是大而全，
>
> HUD
>
> 的目的则是少而精。
> HUD主要注重的是实时向玩家显示有用信息和符号的GUI，和而系统菜单GUI可以给玩家提供
> 更多更全的信息。
>
> 不同类型的游戏玩起来的重点不一样，
>
> HUD
>
> 在提供的信息方面也有很大的差别。我们不妨按照游戏的类别，来看看各种游戏的
>
> HUD
>
> 设计的模式和重点。
>
> ### 1.角色扮演类游戏
>
> 取决于游戏是否会在行动场景和战斗场景之间切换，角色扮演游戏的
>
> HUD
>
> 设计会有所不同，关于行动的那一部分内容，比如地图和方向指示之类的信息可能会被单独分列出来。但总体上角色扮演游戏的
>
> HUD
>
> 信息量基本是一致的：玩家的生命，魔法，行动力，状态（或者其它因游戏而异的内容）等等的数值，玩家可以
>
> “
>
> 一键
>
> ”
>
> 接触到的物品魔法等等东西，如果物品和魔法的内容很复杂，那么一般都会把全面调节的功能交给菜单来完成。比如预设快捷键和菜单光标位置记忆功能就是这样的目的，把菜单中全面而细微的调节能力中，挑选出一些最重要的，放到
>
> HUD
>
> 上来，共玩家选择使用。
>
> ### 2.格斗游戏
>
> 无论格斗游戏系统本身怎么进化，从
>
> 2D
>
> 变到
>
> 3D
>
> ，格斗游戏的
>
> HUD
>
> 总是保持着自己一贯的特色。格斗游戏的
>
> HUD
>
> 大多分成两个部分：第一，对战斗数据的统计，第二，对战斗中精彩场面的描述。前者就是那些显眼的血槽，还包括时间，局数计分。后者则是对于连击之类的精彩动作的积分等等信息。其中血槽这个东西是游戏
>
> HUD
>
> 设计上一个非常典型的东西。
>
> ##### 3.体育游戏
>
> 体育类游戏在设计
>
> HUD
>
> 的问题上有着天然的两个参考坐标系：电视转播画面和球队的战术分析图。游戏的
>
> HUD
>
> 结合了这两者，即体现出了电视转播画面的现场感，也做出了战术分析图那样的清晰感，让玩家尽可能的在有身临其境的感觉的同时也对比赛局面有着清晰的了解。实际上体育类游戏的
>
> HUD
>
> 设计作的是如此的好，以至于最近以来，很多体育项目
>
>
>
>
> 的电视转播画面开始学习这类游戏的
>
> HUD
>
> 设计，往画面上添加一些即时的比赛信息和战术分析。
>
> ##### 4.驾驶模拟类游戏
>
> 这类游戏所要模仿的对象就是
>
> HUD
>
> 这个概念的来源的地方，所以驾驶模拟类游戏
>
> HUD
>
> 设计的原则也就变得非常简单而直接：尽可能的去重现模拟对象的原始
>
> HUD
>
> 就可以了。当然根据游戏模拟真实的程度不同，再现真实
>
> HUD
>
> 设计的程度也有所区别。
>
> HUD
>
> 的设计始终存在一个如何抽取最重要的信息提示玩家的问题，过于仿真的游戏
>
> HUD
>
> 设计将大量的信息不加选择的堆在玩家面前。对于游戏本身
>
> “
>
> 模拟
>
> ”
>
> 这个概念而言，是好事，但对于像通过这些游戏来体验现实生活中不可能接触到的东西这个目的而言，高度的仿真模拟往往会成为上手的障碍。游戏毕竟是游戏，游戏的
>
> HUD
>
> 如何在仿真模拟和抽象表现上把握平衡，是这类游戏的一个突出问题。
>
> ##### 5.动作射击类游戏
>
> 射击类游戏的
>
> HUD
>
> 通常都包括了玩家的状态，玩家的武器状态，地图，以及目标指示这四个方面。第三人称的射击游戏或者团队策略类射击游戏在
>
> HUD
>
> 设计上和传统的第一人称射击游戏区别也不是很大，重点同样在这些要素上。
>
> HUD
>
> 的引入给所有的射击类游戏，无论游戏本身的背景设定是在什么样的时代，都带来了一定的科幻未来的要素。真实的战斗中，对于战场情况的把握从来都是很大的挑战，不断进步的单兵信息化装备正是力求解决这些问题。射击类游戏通过
>
> HUD
>
> 的引入超前的解决了这个问题。就目前而言，感觉做的最好的射击类游戏
>
> HUD
>
> 恰恰就是一些未来题材的射击游戏，等下在
>
> HUD
>
> 进化中我们会看到例子。
>
> ##### 6.策略类游戏
>
> 最为复杂的一类游戏
>
> HUD
>
> ，事实上在这类游戏里面
>
> HUD
>
> 和菜单往往难以截然区分。因为玩家几乎每时每刻都需要确实的掌握整个游戏空间里大量单位的行动。
>
> HUD
>
> 是简化了的菜单，但在很多的策略类游戏上，简化只是一个美好的愿望，游戏本身的复杂程度和玩家的
>
> “
>
> 上帝
>
> ”
>
> 视角导致了这类游戏必然随时都有大量的信息反馈和大量的命令等待输入。策略类游戏的
>
> HUD
>
> 如此的复杂，以至于在控制器键位相对较少的游戏主机上，这类游戏的流行程度始终达不到
>
> PC
>
> 上同类游戏的流行度。游戏本身机制导致的复杂
>
> HUD
>
> 设计应该是这类游戏受众群体局限性产生的原因之一。
>
> 其它类型的游戏，比如平台游戏，益智游戏等等在
>
> HUD
>
> 设计上感觉并没有什么特别的地方。它们的
>
> HUD
>
> 只要能清晰的交代出游戏人物（如果有的话）的状态和游戏的进展程度（得分之类的信息）就可以了。
>
> 如果看到这里觉得累了，依旧是欣赏一部分近期的3A游戏大作的UI界面美图吧：
>
> 《孤岛危机3》：
>
> ![](https://img-blog.csdn.net/20131117193150953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 《仙剑奇侠传五 前传》：
>
> ![](https://img-blog.csdn.net/20131117193203375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 《刺客信条4黑旗》：
>
> ![](https://img-blog.csdn.net/20131117193229062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> ## 三、开始GUI系统的设计
>
> 在这篇文章里面，我们将一起去实现一个简单而健全的GUI系统。这个系统既有HUD的功能，也可以创建GUI菜单。依旧是和之前的其他系统一样，封装在一个类中，这次的类是D3DGUIClass。
>
> 下面又到了天马行空的设计时刻了——在实现GUI系统之前，让我们设计出心目中的GUI系统该有的功能。
>
> ### 1.大体说明
>
> 首先需要说明的是，我们这次设计的GUI系统主要用于演示之用，扩展性很强，需要的更多功能完全可以在这个GUI的系统上进行二次开发，来增强它的特性和功能。
>
> GUI系统主要由按钮和静态文本控件对象组成，当然，还少不了背景图的显示。由于GUI系统是2D的，这意味着指定对象位置时，是用不到Z轴的。另外，我们决定使用正交投影的方式来渲染GUI，这样可以根据像素的位置来指定屏幕的位置。
>
> 让我们来回忆一下，（0,0）对应的是屏幕的左上角。在windows系统中，左上角就是（0,0）。有了这个信息，就可以轻松地确定玩家的鼠标指针是否悬停在GUI系统的控件之上，或者说正在点击这个控件。
>
> ### 2.关于布局规划和背景图
>
> 在设计和规划按钮和文本位置时，我们只要牢记窗口左上角的坐标是（0,0），就能随心所欲的创建各式各样的限制的系统范围内的心仪的GUI布局出来。对于背景图的话，其实没必要考虑它的位置，因为这个图像就是一个由两个三角形构成的全屏图像。只要系统知道当前程序的宽度和高度，就可以显示一个全屏纹理图。
>
> ### 3.关于按钮控件的实现
>
> 必不可少的特性就是可以点击的按钮控件，其实按钮控件的实现比点击图像更容易实现。由于按钮控件的位置是以像素来指定的，因此为了确定鼠标指针是否在按钮上或者按下了按钮，其实就是检查当前鼠标指针的位置是否落在按钮区域内。因为Windows
> [操作系统](http://lib.csdn.net/base/operatingsystem "操作系统知识库")
> 用像素指定鼠标位置且屏幕的左上角为（0,0），所以检查鼠标的坐标是否处于按钮四个角的坐标范围内就可以了，即检查如下四个方面：
>
> 按钮的左侧坐标位置是否小于鼠标指针的X坐标，按钮右侧坐标位置是否大于鼠标指针的X坐标，按钮的上侧坐标是否小于鼠标指针的Y坐标，下侧坐标是否大于鼠标的Y坐标。如果四个都为真的话，那么就可以认定鼠标指针就在按钮控件之上了，然后便通过消息过程来检测是否按下的鼠标左键这个状态，如果按下了鼠标左键，那么就可以确定玩家不仅仅是把鼠标放在了按钮之上，而是同时点击了按钮。我们还在这个GUI系统中实现了通过鼠标的悬停和点击动作，来改变按钮的外观，在按下按钮后有一定的动画效果。
>
> 根据上面的描述，我们可以写出的实现代码如下：
>
> 其中pControl是一个自定义的GUICONTROL结构体的指针对象
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //检查鼠标是否悬停或者点击了按钮
> 2. if
>
>    (mouseX> pControl->m\_xPos && mouseX < pControl->m\_xPos +pControl->m\_width &&
> 3. mouseY> pControl->m\_yPos && mouseY < pControl->m\_yPos + pControl->m\_height)
> 4. {
> 5. if
>
>    (LMBDown)status = UGP\_BUTTON\_DOWN;
> 6. elsestatus = UGP\_BUTTON\_OVER;
> 7. }
>
>   
>
> ### 4.类的框架设计
>
> 因为这个GUI系统的实现还有一定的细节需要详细说明，所以决定分两次更新来讲解。这次我们先把功能完整的类的实现结果给大家，并告诉大家如何使用，说明一下main函数相对于之前有哪些细节需要改变，然后GUI系统类的实现细节留待下篇讲解（如果需要额外用一次更新来讲解的话）。
>
> 还是把详细注释的头文件贴一下吧：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //====================================================
> 2. // Name: D3DGUIClass.h
> 3. //      Des:一个游戏GUI界面系统类的头文件
> 4. // 2013年 11月17日  Create by 浅墨
> 5. //====================================================
> 7. #pragma once
>
> 10. // 所支持的控件类型宏
> 11. #define UGP\_GUI\_STATICTEXT                 1
> 12. #define UGP\_GUI\_BUTTON                     2
> 13. #define UGP\_GUI\_Background                 3
> 15. // 鼠标按键状态宏
> 16. #define UGP\_BUTTON\_UP                      1
> 17. #define UGP\_BUTTON\_OVER                2
> 18. #define UGP\_BUTTON\_DOWN                    3
> 20. // 设置一些GUI中用到的控件ID
> 21. #define STATIC\_ID\_1  1
> 22. #define STATIC\_ID\_2  2
> 23. #define BUTTON\_ID\_1  3
> 24. #define BUTTON\_ID\_2  4
> 25. #define BUTTON\_ID\_3  5
> 26. #define BUTTON\_ID\_4  6
>
>
> 30. // FVF灵活顶点类型的结构体
> 31. struct
>
>     GUIVERTEX
> 32. {
> 33. floatx, y, z, rhw;
> 34. unsignedlong color;
> 35. floattu, tv;
> 36. };
> 37. #define D3DFVF\_GUI (D3DFVF\_XYZRHW |D3DFVF\_DIFFUSE | D3DFVF\_TEX1)
>
> 40. //控件属性结构体
> 41. struct
>
>     GUICONTROL
> 42. {
> 43. //操作类型，ID和颜色
> 44. intm\_type;
>     //控件类型
> 45. intm\_id;
>     //控件ID
> 46. unsignedlong m\_color;
>     //控件颜色
> 47. intm\_listID;
>     //如果是文字的话，这个变量就表示它使用的字体，否则就表示顶点缓存
> 48. floatm\_xPos, m\_yPos;
>     //控件的起始位置
> 49. floatm\_width, m\_height;
>     // 控件的宽度和高度
> 50. wchar\_t
>
>     \*m\_text;
>
>     // 文字内容
> 51. LPDIRECT3DTEXTURE9m\_Background;
>     // 控件背景的填充图像
> 52. LPDIRECT3DTEXTURE9m\_upTex, m\_downTex, m\_overTex;
>     // 存放按钮弹起，按下和鼠标经过时的3张纹理图
> 53. };
>
>
> 57. class
>
>     D3DGUIClass
> 58. {
> 60. private
>
>     :
> 61. LPDIRECT3DDEVICE9m\_pd3dDevice;
>     //D3D设备对象
> 62. LPD3DXFONT\*m\_pFonts;
>     //D3D字体对象
> 63. GUICONTROL\*m\_pControls;
>     //控件对象
> 64. LPDIRECT3DVERTEXBUFFER9\*m\_pVertexBuffer;
>     //顶点缓存对象指针
> 65. GUICONTROLm\_Background;
>     //背景图对象
> 66. LPDIRECT3DVERTEXBUFFER9m\_BackgroundBuffer;
>     //背景图缓冲区对象
> 68. boolm\_bIsBackgroundUsed;
>     //一个标识，用于标识是否已经用了背景
> 69. intm\_nTotalFontNum;
>     //字体数目计数器
> 70. intm\_nTotalControlNum;
>     //控件数目计数器
> 71. intm\_nTotalBufferNum;
>     //缓冲区数目计数器
> 73. intm\_nWindowWidth;
>     //窗口宽度
> 74. intm\_nWindowHeight;
>     //窗口高度
>
>
> 78. public
>
>     :
> 79. D3DGUIClass(LPDIRECT3DDEVICE9device,
>     int
>
>     w,
>
>     int
>
>     h);
> 80. ~D3DGUIClass(){ ClearUp(); }
> 82. LPDIRECT3DDEVICE9GetD3dDevice() {
>     return
>
>     m\_pd3dDevice; }
>
>     //返回D3D设备对象的函数
> 83. GUICONTROL\*GetBackground() {
>     return
>
>     &m\_Background; }
>
>     //返回背景的函数
> 84. LPDIRECT3DVERTEXBUFFER9GetBackgroundBuffer() {
>     return
>
>     m\_BackgroundBuffer; }
>
>     //返回背景缓冲区对象的函数
>
> 87. intGetTotalFontNum() {
>     return
>
>     m\_nTotalFontNum; }
>
>     //返回所有字体数目的函数
> 88. intGetTotalControlNum() {
>     return
>
>     m\_nTotalControlNum; }
>
>     //返回所有控件数目的函数
> 89. intGetTotalBufferNum() {
>     return
>
>     m\_nTotalBufferNum; }
>
>     //返回总的缓冲区数目的函数
> 90. intGetWindowWidth() {
>     return
>
>     m\_nWindowWidth; }
>
>     //返回窗口宽度的函数
> 91. intGetWindowHeight() {
>     return
>
>     m\_nWindowHeight; }
>
>     //返回窗口高度的函数
> 92. boolIsBackgroundUsed() {
>     return
>
>     m\_bIsBackgroundUsed; }
>
>     //返回背景是否在使用的bool值的函数
> 93. voidSetWindowSize(
>     int
>
>     w,
>
>     int
>
>     h) { m\_nWindowWidth = w; m\_nWindowHeight = h; }
>
>     //设置窗口宽度和高度的函数
> 95. LPD3DXFONTGetFont(
>     int
>
>     id)
>
>     //返回字体ID函数
> 96. {
> 97. if
>
>     (id< 0 || id >= m\_nTotalFontNum)
>
>     return
>
>     NULL;
> 98. returnm\_pFonts[id];
> 99. }
> 101. GUICONTROL\*GetGUIControl(
>      int
>
>      id)
>
>      //返回GUI控件ID函数
> 102. {
> 103. if
>
>      (id< 0 || id >= m\_nTotalControlNum)
>
>      return
>
>      NULL;
> 104. return
>
>      &m\_pControls[id];
> 105. }
> 107. LPDIRECT3DVERTEXBUFFER9GetVertexBuffer(
>      int
>
>      id)
>
>      //返回顶点缓存ID函数
> 108. {
> 109. if
>
>      (id< 0 || id >= m\_nTotalBufferNum)
>
>      return
>
>      NULL;
> 110. returnm\_pVertexBuffer[id];
> 111. }
>
> 114. boolCreateTextFont(
>      wchar\_t
>
>      \*fontName,
>
>      int
>
>      size,
>
>      int
>
>      \*fontID);
>
>      //字体创建函数
> 115. boolAddBackground(
>      wchar\_t
>
>      \*fileName);
>
>      //GUI背景添加函数
> 116. boolAddStaticText(
>      int
>
>      id,
>
>      wchar\_t
>
>      \*text,
>
>      float
>
>      x,
>
>      float
>
>      y, unsigned
>
>      long
>
>      color, intfontID);
>
>      //添加静态文本函数
> 117. boolAddButton(
>      int
>
>      id,
>
>      float
>
>      x,
>
>      float
>
>      y,
>
>      wchar\_t
>
>      \*up,
>
>      wchar\_t
>
>      \*over,
>
>      wchar\_t
>
>      \*down);
>
>      //添加按钮函数
> 118. voidClearUp( );
>      //资源清理函数
>
> 121. };
> 123. void
>
>      ProcessGUI(D3DGUIClass \*gui, boolLMBDown,
>
>      int
>
>      mouseX,
>
>      int
>
>      mouseY,
> 124. void
>
>      (\*funcPtr)(intid,
>
>      int
>
>      state));
>
>      //回调函数
>
>   
>   
>   
>
> 具体的实现细节如果现在讲会有一定的篇幅，我们留待下次讲解吧。
>
> ## 四、GUI系统类的使用
>
> 接下来，一起来研究研究如果要在我们之前的demo框架里使用GUI系统的话，需要添加哪些代码。
>
> 第一步
>
> ，依旧是添加一些必要的全局变量：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. D3DGUIClass      g\_gui= NULL;
>
>    //创建GUI类对象
> 2. int
>
>    g\_FontID = -1;
>
>    //  GUI中字体对象的ID
> 3. bool
>
>    g\_LMBDown=
>
>    false
>
>    ;
>
>    // GUI中的鼠标状态信息，鼠标左键是否按下的标识
> 4. int
>
>    g\_MouseX= 0, g\_MouseY = 0;
>
>    //存储鼠标坐标的两个变量
>
>   
>
> 可以看到，在这里我们定义了自己写的GUI系统类D3DGUIClass的类对象，然后是鼠标状态信息相关的变量和一个字体对象。
>
> 第二步
>
> ，在消息处理函数的switch中添加一些新的case：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //-----------------------------------【WndProc( )函数】--------------------------------------
> 2. //      描述：窗口过程函数WndProc,对窗口消息进行处理
> 3. //------------------------------------------------------------------------------------------------
> 4. LRESULT
>
>    CALLBACK WndProc(
>
>    HWND
>
>    hwnd, UINTmessage,
>
>    WPARAM
>
>    wParam,
>
>    LPARAM
>
>    lParam )
>
>    //窗口过程函数WndProc
> 5. {
> 6. switch
>
>    (message )
>
>    //switch语句开始
> 7. {
> 8. caseWM\_PAINT:
>    // 客户区重绘消息
> 9. Direct3D\_Render(hwnd,0.0f);
>    //调用Direct3D\_Render函数，进行画面的绘制
> 10. ValidateRect(hwnd,NULL);
>     // 更新客户区的显示
> 11. break
>
>     ;
>
>     //跳出该switch语句
> 13. caseWM\_KEYDOWN:
>     // 键盘按下消息
> 14. if
>
>     (wParam == VK\_ESCAPE)
>
>     // ESC键
> 15. DestroyWindow(hwnd);
>     // 销毁窗口, 并发送一条WM\_DESTROY消息
> 16. break
>
>     ;
> 17. caseWM\_DESTROY:
>     //窗口销毁消息
> 18. Direct3D\_CleanUp();
>     //调用Direct3D\_CleanUp函数，清理COM接口对象
> 19. PostQuitMessage(0 );
>     //向系统表明有个线程有终止请求。用来响应WM\_DESTROY消息
> 20. break
>
>     ;
>
>     //跳出该switch语句
> 22. caseWM\_KEYUP:
> 23. if
>
>     (wParam== VK\_ESCAPE) PostQuitMessage(0);
> 24. break
>
>     ;
> 26. caseWM\_LBUTTONDOWN:
> 27. g\_LMBDown=
>     true
>
>     ;
> 28. break
>
>     ;
> 30. caseWM\_LBUTTONUP:
> 31. g\_LMBDown=
>     false
>
>     ;
> 32. break
>
>     ;
> 34. caseWM\_MOUSEMOVE:
> 35. g\_MouseX= LOWORD (lParam);
> 36. g\_MouseY= HIWORD (lParam);
> 37. break
>
>     ;
>
> 40. default
>
>     :
>
>     //若上述case条件都不符合，则执行该default语句
> 41. returnDefWindowProc( hwnd, message, wParam, lParam );
>     //调用缺省的窗口过程来为应用程序没有处理的窗口消息提供缺省的处理。
> 42. }
> 44. return0;
>     //正常退出
> 45. }
>
> 其实这一步就是在之前消息的基础上，添加了左键按下，左键弹起，和鼠标移动的消息响应。
>
> 第三步
> ，在进行渲染资源准备的Object\_Init( )函数中，添加载入GUI系统中的资源到内存中的相关代码：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //-----------------------------------【Object\_Init()函数】--------------------------------------
> 2. //      描述：渲染资源初始化函数，在此函数中进行要被渲染的物体的资源的初始化
> 3. //--------------------------------------------------------------------------------------------------
> 4. HRESULT
>
>    Objects\_Init()
> 5. {
> 6. //创建字体
> 7. D3DXCreateFont(g\_pd3dDevice,36, 0, 0, 1000,
>    false
>
>    , DEFAULT\_CHARSET,
> 8. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, \_T(
>    "Calibri"
>
>    ), &g\_pTextFPS);
> 9. D3DXCreateFont(g\_pd3dDevice,20, 0, 1000, 0,
>    false
>
>    , DEFAULT\_CHARSET,
> 10. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, L
>     "华文中宋"
>
>     , &g\_pTextAdaperName);
> 11. D3DXCreateFont(g\_pd3dDevice,23, 0, 1000, 0,
>     false
>
>     , DEFAULT\_CHARSET,
> 12. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, L
>     "微软雅黑"
>
>     , &g\_pTextHelper);
> 13. D3DXCreateFont(g\_pd3dDevice,26, 0, 1000, 0,
>     false
>
>     , DEFAULT\_CHARSET,
> 14. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, L
>     "黑体"
>
>     , &g\_pTextInfor);
>
> 17. //设置纹理采样参数
> 18. g\_pd3dDevice->SetSamplerState(0,D3DSAMP\_MINFILTER, D3DTEXF\_NONE);
> 19. g\_pd3dDevice->SetSamplerState(0,D3DSAMP\_MAGFILTER, D3DTEXF\_NONE);
> 20. g\_pd3dDevice->SetSamplerState(0,D3DSAMP\_MIPFILTER, D3DTEXF\_NONE);
>
> 23. //-----------------------------------【GUI系统相关代码】-------------------------------
> 24. //创建GUI系统
> 25. g\_gui=
>     new
>
>     D3DGUIClass(g\_pd3dDevice, WINDOW\_WIDTH, WINDOW\_HEIGHT);
> 26. if
>
>     (!g\_gui)
>
>     return
>
>
>
>     false
>
>     ;
> 28. //添加背景图片
> 29. if
>
>     (!g\_gui->AddBackground(L
>
>     "GameMedia\\Assassinscreed.jpg"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 31. //添加字体
> 32. if
>
>     (!g\_gui->CreateTextFont(L
>
>     "微软雅黑"
>
>     ,28, &g\_FontID))
>
>     return
>
>
>
>     false
>
>     ;
>
> 35. //添加静态文本到GUI中
> 36. if
>
>     (!g\_gui->AddStaticText(STATIC\_ID\_1,L
>
>     "Version 浅墨1.0版"
>
>     ,
> 37. 1170,735, D3DCOLOR\_XRGB(55,155,255), g\_FontID))
>     return
>
>
>
>     false
>
>     ;
> 39. if
>
>     (!g\_gui->AddStaticText(STATIC\_ID\_2,L
>
>     "浅墨DirectX教程第三季之 打造游戏GUI界面"
>
>     ,
> 40. 500,10, D3DCOLOR\_XRGB(255,255,255), g\_FontID))
>     return
>
>
>
>     false
>
>     ;
>
> 43. //添加4个按钮，分别是开始游戏，载入进度，选项和退出游戏，每个按钮对应3幅图
> 44. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_1,650, 340, L
>
>     "GameMedia\\startUp.png"
>
>     ,
> 45. L
>     "GameMedia\\StartOver.png"
>
>     ,L
>
>     "GameMedia\\startDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 47. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_2,650, 385, L
>
>     "GameMedia\\loadUp.png"
>
>     ,
> 48. L
>     "GameMedia\\loadOver.png"
>
>     ,L
>
>     "GameMedia\\loadDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 50. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_3,650, 430, L
>
>     "GameMedia\\optionsUp.png"
>
>     ,
> 51. L
>     "GameMedia\\optionsOver.png"
>
>     ,L
>
>     "GameMedia\\optionsDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 53. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_4,650, 475, L
>
>     "GameMedia\\quitUp.png"
>
>     ,
> 54. L
>     "GameMedia\\quitOver.png"
>
>     ,L
>
>     "GameMedia\\quitDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 56. returnS\_OK;
> 57. }
>
> 代码中都注释的比较详细，就不多说明了哈。
>
> 第四步
>
> ，添加一个GUI系统的回调函数：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. void
>
>    GUICallback(
>
>    int
>
>    id,
>
>    int
>
>    state)
> 2. {
> 3. switch
>
>    (id)
> 4. {
> 5. caseBUTTON\_ID\_1:
> 6. //“开始游戏”按钮的相关代码实现
> 7. break
>
>    ;
> 8. caseBUTTON\_ID\_2:
> 9. //“载入游戏”按钮的相关代码实现
> 10. break
>
>     ;
> 11. caseBUTTON\_ID\_3:
> 12. //“选项”按钮的相关代码实现
> 13. break
>
>     ;
> 14. caseBUTTON\_ID\_4:
> 15. //如果点击了退出按钮，就退出程序
> 16. if
>
>     (state== UGP\_BUTTON\_DOWN) PostQuitMessage(0);
> 17. break
>
>     ;
> 18. }
> 19. }
>
> 这里是一个switch—case语句总领的回调函数。
>
> 大家也许暂时会对这个函数的使用不太理解，其实它和我们自定义的ProcessGUI有着千丝万缕的联系，具体内容我们在出GUI的第二篇文章的时候再详细讲解。这里我们只要知道它是和ProcessGUI搞基的就可以了。
>
> 举个例子吧，对其中的BUTTON\_ID\_1按钮，就是指的GUI界面中的“Start Game”按钮，而点击之后的余下响应代码（也就是消息响应代码）就写在这个case之后，比如说点击了新游戏的开始后需要渲染游戏画面等等一系列代码。
>
> 第五步
>
> ，在渲染五步曲的第三步中调用一个封装好功能的ProcessGUI函数就可以了。这个函数的具体实现我们在稍后退出的文章中会讲到。
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //--------------------------------------------------------------------------------------
> 2. //【Direct3D渲染五步曲之二】：开始绘制
> 3. //--------------------------------------------------------------------------------------
> 4. g\_pd3dDevice->BeginScene();
>    // 开始绘制
> 6. //--------------------------------------------------------------------------------------
> 7. //【Direct3D渲染五步曲之三】：正式绘制
> 8. //--------------------------------------------------------------------------------------
>
> 11. //处理和渲染GUI系统
> 12. ProcessGUI(g\_gui,g\_LMBDown, g\_MouseX, g\_MouseY, GUICallback);
> 14. //-----------------------------【绘制文字信息】-----------------------------
> 15. HelpText\_Render(hwnd);
>
> 18. //--------------------------------------------------------------------------------------
> 19. //【Direct3D渲染五步曲之四】：结束绘制
> 20. //--------------------------------------------------------------------------------------
> 21. g\_pd3dDevice->EndScene();
>     // 结束绘制
>
>   
>
> ## 五、详细注释的源代码欣赏
>
> 这次的工程因为是作为GUI的初步演示，自然就有了孑然一身的感觉，除了main.cpp和D3DUtil.h就是D3DGUIClass类的源文件和头文件了。如下图：
>
> ![](https://img-blog.csdn.net/20131117203956390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 程序主要是实现了简单的GUI系统，通过GUI系统的功能在屏幕上添加了游戏菜单的四个按钮，并且在屏幕上输出了“浅墨DirectX教程第三季 之 打造游戏GUI界面”，"Version 浅墨1.0版"这两段文字。
>
> 而且目前对“quit”退出按钮的功能进行了实行实现，其实就简单一句if(state == UGP\_BUTTON\_DOWN) PostQuitMessage(0);。。。。。
>
> 那么，老规矩，上程序的核心部分，main函数的代码吧：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //-----------------------------------【程序说明】----------------------------------------------
> 2. // 【Visual C++】游戏开发系列配套源码五十六 浅墨DirectX教程二十三 打造游戏GUI界面（一）
> 3. // VS2010版
> 4. // 2013年11月 Create by 浅墨
> 5. // 背景音乐素材出处： 刺客信条
> 6. //------------------------------------------------------------------------------------------------
>
> 9. //-----------------------------------【宏定义部分】--------------------------------------------
> 10. // 描述：定义一些辅助宏
> 11. //------------------------------------------------------------------------------------------------
> 12. #define WINDOW\_WIDTH    1366                        //为窗口宽度定义的宏，以方便在此处修改窗口宽度
> 13. #define WINDOW\_HEIGHT   768                         //为窗口高度定义的宏，以方便在此处修改窗口高度
> 14. #define WINDOW\_TITLE     \_T("【致我们永不熄灭的游戏开发梦想】 浅墨DirectX教程二十三 打造游戏GUI界面（一）博文配套示例程序 by浅墨") //为窗口标题定义的宏
>
>
> 18. //-----------------------------------【头文件包含部分】---------------------------------------
> 19. //  描述：包含程序所依赖的头文件
> 20. //------------------------------------------------------------------------------------------------
> 21. #include <d3d9.h>
> 22. #include <d3dx9.h>
> 23. #include <tchar.h>
> 24. #include <time.h>
> 25. #include "D3DUtil.h"
> 26. #include "D3DGUIClass.h"
>
>
> 30. //-----------------------------------【库文件包含部分】---------------------------------------
> 31. //  描述：包含程序所依赖的库文件
> 32. //------------------------------------------------------------------------------------------------
> 33. #pragma comment(lib,"d3d9.lib")
> 34. #pragma comment(lib,"d3dx9.lib")
> 35. #pragma comment(lib, "dinput8.lib")     // 使用DirectInput必须包含的库文件，注意这里有8
> 36. #pragma comment(lib,"dxguid.lib")
> 37. #pragma comment(lib, "winmm.lib")
>
>
> 41. // 地板的顶点结构
> 42. struct
>
>     CUSTOMVERTEX
> 43. {
> 44. FLOAT
>
>     \_x, \_y, \_z;
> 45. FLOAT
>
>     \_u, \_v ;
> 46. CUSTOMVERTEX(
>     FLOAT
>
>     x,
>
>     FLOAT
>
>     y,
>
>     FLOAT
>
>     z,
>
>     FLOAT
>
>     u,
>
>     FLOAT
>
>     v)
> 47. : \_x(x), \_y(y), \_z(z), \_u(u), \_v(v) {}
> 48. };
> 49. #define D3DFVF\_CUSTOMVERTEX  (D3DFVF\_XYZ | D3DFVF\_TEX1)
>
> 52. //-----------------------------------【全局变量声明部分】-------------------------------------
> 53. //  描述：全局变量的声明
> 54. //------------------------------------------------------------------------------------------------
> 55. LPDIRECT3DDEVICE9                   g\_pd3dDevice = NULL;
>     //Direct3D设备对象
> 56. LPD3DXFONT                              g\_pTextFPS =NULL;
>     //字体COM接口
> 57. LPD3DXFONT                              g\_pTextAdaperName = NULL;
>     // 显卡信息的2D文本
> 58. LPD3DXFONT                              g\_pTextHelper = NULL;
>     // 帮助信息的2D文本
> 59. LPD3DXFONT                              g\_pTextInfor= NULL;
>     // 绘制信息的2D文本
> 60. float
>
>     g\_FPS= 0.0f;
>
>     //一个浮点型的变量，代表帧速率
> 61. wchar\_t
>
>     g\_strFPS[50] ={0};
>
>     //包含帧速率的字符数组
> 62. wchar\_t
>
>     g\_strAdapterName[60] ={0};
>
>     //包含显卡名称的字符数组
> 64. D3DGUIClass                             \*g\_gui = NULL;
>     //创建GUI类对象
> 65. bool
>
>     g\_LMBDown =
>
>     false
>
>     ;
>
>     // GUI中的鼠标状态信息，鼠标左键是否按下的标识
> 66. int
>
>     g\_MouseX = 0, g\_MouseY = 0;
>
>     //存储鼠标坐标的两个变量
> 67. int
>
>     g\_FontID = -1;
>
>     //  GUI中字体对象的ID
>
> 70. //-----------------------------------【全局函数声明部分】-------------------------------------
> 71. //  描述：全局函数声明，防止“未声明的标识”系列错误
> 72. //------------------------------------------------------------------------------------------------
> 73. LRESULT
>
>     CALLBACK        WndProc(
>
>     HWND
>
>     hwnd,
>
>     UINT
>
>     message,
>
>     WPARAM
>
>     wParam,
>
>     LPARAM
>
>     lParam );
> 74. HRESULT
>
>     Direct3D\_Init(
>
>     HWND
>
>     hwnd,
>
>     HINSTANCE
>
>     hInstance);
> 75. HRESULT
>
>     Objects\_Init();
> 76. void
>
>     Direct3D\_Render(
>
>     HWND
>
>     hwnd,
>
>     FLOAT
>
>     fTimeDelta);
> 77. void
>
>     Direct3D\_Update(
>
>     HWND
>
>     hwnd,
>
>     FLOAT
>
>     fTimeDelta);
> 78. void
>
>     Direct3D\_CleanUp( );
> 79. float
>
>     Get\_FPS();
> 80. void
>
>     HelpText\_Render(
>
>     HWND
>
>     hwnd);
> 81. void
>
>     GUICallback(
>
>     int
>
>     id,
>
>     int
>
>     state);
> 83. //-----------------------------------【WinMain( )函数】--------------------------------------
> 84. //  描述：Windows应用程序的入口函数，我们的程序从这里开始
> 85. //------------------------------------------------------------------------------------------------
> 86. int
>
>     WINAPI WinMain(
>
>     HINSTANCE
>
>     hInstance,
>
>     HINSTANCE
>
>     hPrevInstance,
>
>     LPSTR
>
>     lpCmdLine,
>
>     int
>
>     nShowCmd)
> 87. {
> 89. //开始设计一个完整的窗口类
> 90. WNDCLASSEX wndClass={0} ;
>     //用WINDCLASSEX定义了一个窗口类，即用wndClass实例化了WINDCLASSEX，用于之后窗口的各项初始化
> 91. wndClass.cbSize =
>     sizeof
>
>     ( WNDCLASSEX ) ;
>
>     //设置结构体的字节数大小
> 92. wndClass.style = CS\_HREDRAW | CS\_VREDRAW;
>     //设置窗口的样式
> 93. wndClass.lpfnWndProc = WndProc;
>     //设置指向窗口过程函数的指针
> 94. wndClass.cbClsExtra     = 0;
> 95. wndClass.cbWndExtra     = 0;
> 96. wndClass.hInstance = hInstance;
>     //指定包含窗口过程的程序的实例句柄。
> 97. wndClass.hIcon=(
>     HICON
>
>     )::LoadImage(NULL,\_T(
>
>     "GameMedia\\icon.ico"
>
>     ),IMAGE\_ICON,0,0,LR\_DEFAULTSIZE|LR\_LOADFROMFILE);
>
>     //从全局的::LoadImage函数从本地加载自定义ico图标
> 98. wndClass.hCursor = LoadCursor( NULL, IDC\_ARROW );
>     //指定窗口类的光标句柄。
> 99. wndClass.hbrBackground=(
>     HBRUSH
>
>     )GetStockObject(GRAY\_BRUSH);
>
>     //为hbrBackground成员指定一个灰色画刷句柄
> 100. wndClass.lpszMenuName = NULL;
>      //用一个以空终止的字符串，指定菜单资源的名字。
> 101. wndClass.lpszClassName = \_T(
>      "ForTheDreamOfGameDevelop"
>
>      );
>
>      //用一个以空终止的字符串，指定窗口类的名字。
> 103. if
>
>      ( !RegisterClassEx( &wndClass ) )
>
>      //设计完窗口后，需要对窗口类进行注册，这样才能创建该类型的窗口
> 104. return
>
>      -1;
> 106. HWND
>
>      hwnd = CreateWindow( \_T(
>
>      "ForTheDreamOfGameDevelop"
>
>      ),WINDOW\_TITLE,
>
>      //喜闻乐见的创建窗口函数CreateWindow
> 107. WS\_OVERLAPPEDWINDOW, CW\_USEDEFAULT, CW\_USEDEFAULT, WINDOW\_WIDTH,
> 108. WINDOW\_HEIGHT, NULL, NULL, hInstance, NULL );
>
> 111. //Direct3D资源的初始化，调用失败用messagebox予以显示
> 112. if
>
>      (!(S\_OK==Direct3D\_Init (hwnd,hInstance)))
> 113. {
> 114. MessageBox(hwnd, \_T(
>      "Direct3D初始化失败~！"
>
>      ), \_T(
>
>      "浅墨的消息窗口"
>
>      ), 0);
>
>      //使用MessageBox函数，创建一个消息窗口
> 115. }
> 116. PlaySound(L
>      "GameMedia\\Heart - 刺客信条.wav"
>
>      , NULL, SND\_FILENAME | SND\_ASYNC|SND\_LOOP);
>
>      //循环播放背景音乐
> 118. MoveWindow(hwnd,0,0,WINDOW\_WIDTH,WINDOW\_HEIGHT,
>      true
>
>      );
>
>      //调整窗口显示时的位置，窗口左上角位于屏幕坐标（200，10）处
> 119. ShowWindow( hwnd, nShowCmd );
>      //调用Win32函数ShowWindow来显示窗口
> 120. UpdateWindow(hwnd);
>      //对窗口进行更新，就像我们买了新房子要装修一样
>
> 123. //消息循环过程
> 124. MSG msg = { 0 };
>      //初始化msg
> 125. while
>
>      ( msg.message != WM\_QUIT )
>
>      //使用while循环
> 126. {
> 127. static
>
>
>
>      FLOAT
>
>      fLastTime  = (
>
>      float
>
>      )::timeGetTime();
> 128. static
>
>
>
>      FLOAT
>
>      fCurrTime  = (
>
>      float
>
>      )::timeGetTime();
> 129. static
>
>
>
>      FLOAT
>
>      fTimeDelta = 0.0f;
> 130. fCurrTime  = (
>      float
>
>      )::timeGetTime();
> 131. fTimeDelta = (fCurrTime - fLastTime) / 1000.0f;
> 132. fLastTime  = fCurrTime;
> 134. if
>
>      ( PeekMessage( &msg, 0, 0, 0, PM\_REMOVE ) )
>
>      //查看应用程序消息队列，有消息时将队列中的消息派发出去。
> 135. {
> 136. TranslateMessage( &msg );
>      //将虚拟键消息转换为字符消息
> 137. DispatchMessage( &msg );
>      //该函数分发一个消息给窗口程序。
> 138. }
> 139. else
> 140. {
> 141. Direct3D\_Update(hwnd,fTimeDelta);
>      //调用更新函数，进行画面的更新
> 142. Direct3D\_Render(hwnd,fTimeDelta);
>      //调用渲染函数，进行画面的渲染
> 143. }
> 144. }
> 146. UnregisterClass(\_T(
>      "ForTheDreamOfGameDevelop"
>
>      ), wndClass.hInstance);
> 147. return
>
>      0;
> 148. }
>
> 151. //-----------------------------------【WndProc( )函数】--------------------------------------
> 152. //  描述：窗口过程函数WndProc,对窗口消息进行处理
> 153. //------------------------------------------------------------------------------------------------
> 154. LRESULT
>
>      CALLBACK WndProc(
>
>      HWND
>
>      hwnd,
>
>      UINT
>
>      message,
>
>      WPARAM
>
>      wParam,
>
>      LPARAM
>
>      lParam )
>
>      //窗口过程函数WndProc
> 155. {
> 156. switch
>
>      ( message )
>
>      //switch语句开始
> 157. {
> 158. case
>
>      WM\_PAINT:
>
>      // 客户区重绘消息
> 159. Direct3D\_Render(hwnd,0.0f);
>      //调用Direct3D\_Render函数，进行画面的绘制
> 160. ValidateRect(hwnd, NULL);
>      // 更新客户区的显示
> 161. break
>
>      ;
>
>      //跳出该switch语句
> 163. case
>
>      WM\_KEYDOWN:
>
>      // 键盘按下消息
> 164. if
>
>      (wParam == VK\_ESCAPE)
>
>      // ESC键
> 165. DestroyWindow(hwnd);
>      // 销毁窗口, 并发送一条WM\_DESTROY消息
> 166. break
>
>      ;
> 167. case
>
>      WM\_DESTROY:
>
>      //窗口销毁消息
> 168. Direct3D\_CleanUp();
>      //调用Direct3D\_CleanUp函数，清理COM接口对象
> 169. PostQuitMessage( 0 );
>      //向系统表明有个线程有终止请求。用来响应WM\_DESTROY消息
> 170. break
>
>      ;
>
>      //跳出该switch语句
> 172. case
>
>      WM\_KEYUP:
> 173. if
>
>      (wParam == VK\_ESCAPE) PostQuitMessage(0);
> 174. break
>
>      ;
> 176. case
>
>      WM\_LBUTTONDOWN:
> 177. g\_LMBDown =
>      true
>
>      ;
> 178. break
>
>      ;
> 180. case
>
>      WM\_LBUTTONUP:
> 181. g\_LMBDown =
>      false
>
>      ;
> 182. break
>
>      ;
> 184. case
>
>      WM\_MOUSEMOVE:
> 185. g\_MouseX = LOWORD (lParam);
> 186. g\_MouseY = HIWORD (lParam);
> 187. break
>
>      ;
>
> 190. default
>
>      :
>
>      //若上述case条件都不符合，则执行该default语句
> 191. return
>
>      DefWindowProc( hwnd, message, wParam, lParam );
>
>      //调用缺省的窗口过程来为应用程序没有处理的窗口消息提供缺省的处理。
> 192. }
> 194. return
>
>      0;
>
>      //正常退出
> 195. }
>
> 198. //-----------------------------------【Direct3D\_Init( )函数】----------------------------------
> 199. //  描述：Direct3D初始化函数，进行Direct3D的初始化
> 200. //------------------------------------------------------------------------------------------------
> 201. HRESULT
>
>      Direct3D\_Init(
>
>      HWND
>
>      hwnd,
>
>      HINSTANCE
>
>      hInstance)
> 202. {
> 204. //--------------------------------------------------------------------------------------
> 205. // 【Direct3D初始化四步曲之一，创接口】：创建Direct3D接口对象, 以便用该Direct3D对象创建Direct3D设备对象
> 206. //--------------------------------------------------------------------------------------
> 207. LPDIRECT3D9  pD3D = NULL;
>      //Direct3D接口对象的创建
> 208. if
>
>      ( NULL == ( pD3D = Direct3DCreate9( D3D\_SDK\_VERSION ) ) )
>
>      //初始化Direct3D接口对象，并进行DirectX版本协商
> 209. return
>
>      E\_FAIL;
> 211. //--------------------------------------------------------------------------------------
> 212. // 【Direct3D初始化四步曲之二,取信息】：获取硬件设备信息
> 213. //--------------------------------------------------------------------------------------
> 214. D3DCAPS9 caps;
>      int
>
>      vp = 0;
> 215. if
>
>      ( FAILED( pD3D->GetDeviceCaps( D3DADAPTER\_DEFAULT, D3DDEVTYPE\_HAL, &caps ) ) )
> 216. {
> 217. return
>
>      E\_FAIL;
> 218. }
> 219. if
>
>      ( caps.DevCaps & D3DDEVCAPS\_HWTRANSFORMANDLIGHT )
> 220. vp = D3DCREATE\_HARDWARE\_VERTEXPROCESSING;
>      //支持硬件顶点运算，我们就采用硬件顶点运算，妥妥的
> 221. else
> 222. vp = D3DCREATE\_SOFTWARE\_VERTEXPROCESSING;
>      //不支持硬件顶点运算，无奈只好采用软件顶点运算
> 224. //--------------------------------------------------------------------------------------
> 225. // 【Direct3D初始化四步曲之三，填内容】：填充D3DPRESENT\_PARAMETERS结构体
> 226. //--------------------------------------------------------------------------------------
> 227. D3DPRESENT\_PARAMETERS d3dpp;
> 228. ZeroMemory(&d3dpp,
>      sizeof
>
>      (d3dpp));
> 229. d3dpp.BackBufferWidth            = WINDOW\_WIDTH;
> 230. d3dpp.BackBufferHeight           = WINDOW\_HEIGHT;
> 231. d3dpp.BackBufferFormat           = D3DFMT\_A8R8G8B8;
> 232. d3dpp.BackBufferCount            = 2;
> 233. d3dpp.MultiSampleType            = D3DMULTISAMPLE\_NONE;
> 234. d3dpp.MultiSampleQuality         = 0;
> 235. d3dpp.SwapEffect                 = D3DSWAPEFFECT\_DISCARD;
> 236. d3dpp.hDeviceWindow              = hwnd;
> 237. d3dpp.Windowed                   =
>      true
>
>      ;
> 238. d3dpp.EnableAutoDepthStencil     =
>      true
>
>      ;
> 239. d3dpp.AutoDepthStencilFormat     = D3DFMT\_D24S8;
> 240. d3dpp.Flags                      = 0;
> 241. d3dpp.FullScreen\_RefreshRateInHz = 0;
> 242. d3dpp.PresentationInterval       = D3DPRESENT\_INTERVAL\_IMMEDIATE;
> 244. //--------------------------------------------------------------------------------------
> 245. // 【Direct3D初始化四步曲之四，创设备】：创建Direct3D设备接口
> 246. //--------------------------------------------------------------------------------------
> 247. if
>
>      (FAILED(pD3D->CreateDevice(D3DADAPTER\_DEFAULT, D3DDEVTYPE\_HAL,
> 248. hwnd, vp, &d3dpp, &g\_pd3dDevice)))
> 249. return
>
>      E\_FAIL;
>
> 252. //获取显卡信息到g\_strAdapterName中，并在显卡名称之前加上“当前显卡型号：”字符串
> 253. wchar\_t
>
>      TempName[60]=L
>
>      "当前显卡型号："
>
>      ;
>
>      //定义一个临时字符串，且方便了把"当前显卡型号："字符串引入我们的目的字符串中
> 254. D3DADAPTER\_IDENTIFIER9 Adapter;
>      //定义一个D3DADAPTER\_IDENTIFIER9结构体，用于存储显卡信息
> 255. pD3D->GetAdapterIdentifier(0,0,&Adapter);
>      //调用GetAdapterIdentifier，获取显卡信息
> 256. int
>
>      len = MultiByteToWideChar(CP\_ACP,0, Adapter.Description, -1, NULL, 0);
>
>      //显卡名称现在已经在Adapter.Description中了，但是其为char类型，我们要将其转为wchar\_t类型
> 257. MultiByteToWideChar(CP\_ACP, 0, Adapter.Description, -1, g\_strAdapterName, len);
>      //这步操作完成后，g\_strAdapterName中就为当前我们的显卡类型名的wchar\_t型字符串了
> 258. wcscat\_s(TempName,g\_strAdapterName);
>      //把当前我们的显卡名加到“当前显卡型号：”字符串后面，结果存在TempName中
> 259. wcscpy\_s(g\_strAdapterName,TempName);
>      //把TempName中的结果拷贝到全局变量g\_strAdapterName中，大功告成~
> 261. if
>
>      (!(S\_OK==Objects\_Init()))
>
>      return
>
>      E\_FAIL;
> 263. SAFE\_RELEASE(pD3D)
>      //LPDIRECT3D9接口对象的使命完成，我们将其释放掉
> 265. return
>
>      S\_OK;
> 266. }
>
> 269. //-----------------------------------【Object\_Init( )函数】--------------------------------------
> 270. //  描述：渲染资源初始化函数，在此函数中进行要被渲染的物体的资源的初始化
> 271. //--------------------------------------------------------------------------------------------------
> 272. HRESULT
>
>      Objects\_Init()
> 273. {
> 274. //创建字体
> 275. D3DXCreateFont(g\_pd3dDevice, 36, 0, 0, 1000,
>      false
>
>      , DEFAULT\_CHARSET,
> 276. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, \_T(
>      "Calibri"
>
>      ), &g\_pTextFPS);
> 277. D3DXCreateFont(g\_pd3dDevice, 20, 0, 1000, 0,
>      false
>
>      , DEFAULT\_CHARSET,
> 278. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, L
>      "华文中宋"
>
>      , &g\_pTextAdaperName);
> 279. D3DXCreateFont(g\_pd3dDevice, 23, 0, 1000, 0,
>      false
>
>      , DEFAULT\_CHARSET,
> 280. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, L
>      "微软雅黑"
>
>      , &g\_pTextHelper);
> 281. D3DXCreateFont(g\_pd3dDevice, 26, 0, 1000, 0,
>      false
>
>      , DEFAULT\_CHARSET,
> 282. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, L
>      "黑体"
>
>      , &g\_pTextInfor);
>
> 285. //设置纹理采样参数
> 286. g\_pd3dDevice->SetSamplerState(0, D3DSAMP\_MINFILTER, D3DTEXF\_NONE);
> 287. g\_pd3dDevice->SetSamplerState(0, D3DSAMP\_MAGFILTER, D3DTEXF\_NONE);
> 288. g\_pd3dDevice->SetSamplerState(0, D3DSAMP\_MIPFILTER, D3DTEXF\_NONE);
>
> 291. //-----------------------------------【GUI系统相关代码】-------------------------------
> 292. // 创建GUI系统
> 293. g\_gui =
>      new
>
>      D3DGUIClass(g\_pd3dDevice, WINDOW\_WIDTH, WINDOW\_HEIGHT);
> 294. if
>
>      (!g\_gui)
>
>      return
>
>
>
>      false
>
>      ;
> 296. // 添加背景图片
> 297. if
>
>      (!g\_gui->AddBackground(L
>
>      "GameMedia\\Assassins creed.jpg"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 299. // 添加字体
> 300. if
>
>      (!g\_gui->CreateTextFont(L
>
>      "微软雅黑"
>
>      , 28, &g\_FontID))
>
>      return
>
>
>
>      false
>
>      ;
>
> 303. // 添加静态文本到GUI中
> 304. if
>
>      (!g\_gui->AddStaticText(STATIC\_ID\_1, L
>
>      "Version 浅墨1.0版"
>
>      ,
> 305. 1170, 735, D3DCOLOR\_XRGB(55,155,255), g\_FontID))
>      return
>
>
>
>      false
>
>      ;
> 307. if
>
>      (!g\_gui->AddStaticText(STATIC\_ID\_2, L
>
>      "浅墨DirectX教程第三季 之 打造游戏GUI界面"
>
>      ,
> 308. 500, 10, D3DCOLOR\_XRGB(255,255,255), g\_FontID))
>      return
>
>
>
>      false
>
>      ;
>
> 311. // 添加4个按钮，分别是开始游戏，载入进度，选项和退出游戏，每个按钮对应3幅图
> 312. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_1, 650, 340, L
>
>      "GameMedia\\startUp.png"
>
>      ,
> 313. L
>      "GameMedia\\StartOver.png"
>
>      , L
>
>      "GameMedia\\startDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 315. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_2, 650, 385, L
>
>      "GameMedia\\loadUp.png"
>
>      ,
> 316. L
>      "GameMedia\\loadOver.png"
>
>      , L
>
>      "GameMedia\\loadDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 318. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_3, 650, 430, L
>
>      "GameMedia\\optionsUp.png"
>
>      ,
> 319. L
>      "GameMedia\\optionsOver.png"
>
>      , L
>
>      "GameMedia\\optionsDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 321. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_4, 650, 475, L
>
>      "GameMedia\\quitUp.png"
>
>      ,
> 322. L
>      "GameMedia\\quitOver.png"
>
>      , L
>
>      "GameMedia\\quitDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 324. return
>
>      S\_OK;
> 325. }
>
> 328. void
>
>      GUICallback(
>
>      int
>
>      id,
>
>      int
>
>      state)
> 329. {
> 330. switch
>
>      (id)
> 331. {
> 332. case
>
>      BUTTON\_ID\_1:
> 333. //“开始游戏”按钮的相关代码实现
> 334. break
>
>      ;
> 335. case
>
>      BUTTON\_ID\_2:
> 336. //“载入游戏”按钮的相关代码实现
> 337. break
>
>      ;
> 338. case
>
>      BUTTON\_ID\_3:
> 339. //“选项”按钮的相关代码实现
> 340. break
>
>      ;
> 341. case
>
>      BUTTON\_ID\_4:
> 342. //如果点击了退出按钮，就退出程序
> 343. if
>
>      (state == UGP\_BUTTON\_DOWN) PostQuitMessage(0);
> 344. break
>
>      ;
> 345. }
> 346. }
>
> 349. //-----------------------------------【Direct3D\_Update( )函数】--------------------------------
> 350. //  描述：不是即时渲染代码但是需要即时调用的，如按键后的坐标的更改，都放在这里
> 351. //--------------------------------------------------------------------------------------------------
> 352. void
>
>      Direct3D\_Update(
>
>      HWND
>
>      hwnd,
>
>      FLOAT
>
>      fTimeDelta)
> 353. {
> 354. //GUI的实现暂时不需要在这里写代码
> 355. }
>
>
> 359. //-----------------------------------【Direct3D\_Render( )函数】-------------------------------
> 360. //  描述：使用Direct3D进行渲染
> 361. //--------------------------------------------------------------------------------------------------
> 362. void
>
>      Direct3D\_Render(
>
>      HWND
>
>      hwnd,
>
>      FLOAT
>
>      fTimeDelta)
> 363. {
> 364. //--------------------------------------------------------------------------------------
> 365. // 【Direct3D渲染五步曲之一】：清屏操作
> 366. //--------------------------------------------------------------------------------------
> 367. g\_pd3dDevice->Clear(0, NULL, D3DCLEAR\_TARGET|D3DCLEAR\_ZBUFFER|D3DCLEAR\_STENCIL, D3DCOLOR\_XRGB(100, 255, 255), 1.0f, 0);
> 369. //--------------------------------------------------------------------------------------
> 370. // 【Direct3D渲染五步曲之二】：开始绘制
> 371. //--------------------------------------------------------------------------------------
> 372. g\_pd3dDevice->BeginScene();
>      // 开始绘制
> 374. //--------------------------------------------------------------------------------------
> 375. // 【Direct3D渲染五步曲之三】：正式绘制
> 376. //--------------------------------------------------------------------------------------
>
> 379. // 处理和渲染GUI系统
> 380. ProcessGUI(g\_gui, g\_LMBDown, g\_MouseX, g\_MouseY, GUICallback);
> 382. //-----------------------------【绘制文字信息】-----------------------------
> 383. HelpText\_Render(hwnd);
>
> 386. //--------------------------------------------------------------------------------------
> 387. // 【Direct3D渲染五步曲之四】：结束绘制
> 388. //--------------------------------------------------------------------------------------
> 389. g\_pd3dDevice->EndScene();
>      // 结束绘制
> 390. //--------------------------------------------------------------------------------------
> 391. // 【Direct3D渲染五步曲之五】：显示翻转
> 392. //--------------------------------------------------------------------------------------
> 393. g\_pd3dDevice->Present(NULL, NULL, NULL, NULL);
>      // 翻转与显示
> 395. }
>
> 398. //-----------------------------------【HelpText\_Render( )函数】-------------------------------
> 399. //  描述：封装了帮助信息的函数
> 400. //--------------------------------------------------------------------------------------------------
> 401. void
>
>      HelpText\_Render(
>
>      HWND
>
>      hwnd)
> 402. {
> 403. //定义一个矩形，用于获取主窗口矩形
> 404. RECT formatRect;
> 405. GetClientRect(hwnd, &formatRect);
> 407. //在窗口右上角处，显示每秒帧数
> 408. formatRect.top = 5;
> 409. int
>
>      charCount = swprintf\_s(g\_strFPS, 20, \_T(
>
>      "FPS:%0.3f"
>
>      ), Get\_FPS() );
> 410. g\_pTextFPS->DrawText(NULL, g\_strFPS, charCount , &formatRect, DT\_TOP | DT\_RIGHT, D3DCOLOR\_RGBA(0,239,136,255));
> 412. //显示显卡类型名
> 413. g\_pTextAdaperName->DrawText(NULL,g\_strAdapterName, -1, &formatRect,
> 414. DT\_TOP | DT\_LEFT, D3DXCOLOR(1.0f, 0.5f, 0.0f, 1.0f));
> 415. }
>
> 418. //-----------------------------------【Get\_FPS( )函数】------------------------------------------
> 419. //  描述：用于计算每秒帧速率的一个函数
> 420. //--------------------------------------------------------------------------------------------------
> 421. float
>
>      Get\_FPS()
> 422. {
> 424. //定义四个静态变量
> 425. static
>
>
>
>      float
>
>      fps = 0;
>
>      //我们需要计算的FPS值
> 426. static
>
>
>
>      int
>
>      frameCount = 0;
>
>      //帧数
> 427. static
>
>
>
>      float
>
>      currentTime =0.0f;
>
>      //当前时间
> 428. static
>
>
>
>      float
>
>      lastTime = 0.0f;
>
>      //持续时间
> 430. frameCount++;
>      //每调用一次Get\_FPS()函数，帧数自增1
> 431. currentTime = timeGetTime()\*0.001f;
>      //获取系统时间，其中timeGetTime函数返回的是以毫秒为单位的系统时间，所以需要乘以0.001，得到单位为秒的时间
> 433. //如果当前时间减去持续时间大于了1秒钟，就进行一次FPS的计算和持续时间的更新，并将帧数值清零
> 434. if
>
>      (currentTime - lastTime > 1.0f)
>
>      //将时间控制在1秒钟
> 435. {
> 436. fps = (
>      float
>
>      )frameCount /(currentTime - lastTime);
>
>      //计算这1秒钟的FPS值
> 437. lastTime = currentTime;
>      //将当前时间currentTime赋给持续时间lastTime，作为下一秒的基准时间
> 438. frameCount    = 0;
>      //将本次帧数frameCount值清零
> 439. }
> 441. return
>
>      fps;
> 442. }
>
>
> 446. //-----------------------------------【Direct3D\_CleanUp( )函数】--------------------------------
> 447. //  描述：对Direct3D的资源进行清理，释放COM接口对象
> 448. //---------------------------------------------------------------------------------------------------
> 449. void
>
>      Direct3D\_CleanUp()
> 450. {
> 451. //释放COM接口对象
> 452. SAFE\_RELEASE(g\_pd3dDevice);
> 453. SAFE\_RELEASE(g\_pTextFPS)
> 454. SAFE\_RELEASE(g\_pd3dDevice)
> 455. SAFE\_DELETE(g\_gui)
> 456. }
>
> 那么，最后一起看看运行截图吧：
>
> ![](https://img-blog.csdn.net/20131117204150921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 鼠标悬停在options按钮之上，可以发现按钮“下陷”了
>
> ![](https://img-blog.csdn.net/20131117204220218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 点击quit按钮，游戏程序便会退出：
>
> ![](https://img-blog.csdn.net/20131117204755921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

> 本系列文章由zhmxy555（毛星云）编写，转载请注明出处。
>
> 文章链接：
> <http://blog.csdn.net/poem_qianmo/article/details/16384009>
>
> 作者：毛星云（浅墨）    邮箱：
>
> [happylifemxy@163.com](mailto:happylifemxy@163.com)

> 众所周知，GUI是游戏中不可缺少的元素，这篇文章中，我们首先了解了游戏GUI界面的知识与相关概念，然后一起设计了一个封装好GUI图形界面的C++类。这个类有着非常强的扩展性，使用也是极其方便，很适合二次开发。

> 先看一张实现的效果图吧：
>
> ![](https://img-blog.csdn.net/20131117191916093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 其中的背景音乐，游戏图标和背景图片都出自育碧公司的招牌式大作《刺客信条》。
>
> 程序的窗口大小已经被浅墨调成了1366 x768，现阶段比较流行的笔记本分辨率尺寸（其实真的想吐槽这个奇葩万年不变的电脑屏幕分辨率，在如今的后PC时代。手机屏幕都开始对1920 x1080的分辨率不满足了。。。。）
>
> 嗯，开始正文吧。

> ## 一、UI和GUI的概述
>
> 首先我们看一下UI的比较正统的定义：
>
> 用户界面（
>
> User Interface
>
> ，简称
>
> UI
>
> ，亦称使用者界面）是系统和用户之间进行交互和信息交换的媒介，它实现信息的内部形式与人类可以接受形式之间的转换。
>
> 用户界面是介于用户与硬件之间，为彼此之间交互沟通而设计的相关软件，使得用户能够方便有效地去操作硬件以达成双向之交互，完成所希望的工作，用户界面定义广泛，包含了人机交互与图形用户界面，凡参与人类与机械的信息交流的领域都存在着用户界面。
>
> 而GUI
>
> 的正统定义是：
>
> 图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受。
>
> 我们知道，在游戏中，能够和游戏玩家进行交互是至关重要的。这样的交流可以是文本形式的，视觉显示，声音信号等等。而对于视觉显示而言，绝大多数游戏毋庸置疑就是用图形用户界面(GUI)来和游戏玩家进行交互的。而在游戏过程中，依旧少不了GUI界面的出场，比如说状态显示界面（Head-up Display,HUD），HUD，这个界面提供一切和游戏有关的信息。用于提供玩家剩余任务时间，生命值，坐标位置，以及更多信息。
>
> 让我们欣赏一部分近期的3A游戏大作的UI界面美图吧：

> 《鬼泣5》：
>
> ![](https://img-blog.csdn.net/20131117193108390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 《英雄无敌6》：
>
> ![](https://img-blog.csdn.net/20131117193051453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 欣赏完了，我们继续开讲吧。
>
> ## 二、关于状态显示界面(HUD)
>
> 这一节里让我们一起科普HUD的概念。
>
> 我们知道，通常情况下在游戏中屏幕上会有很多的小的界面模块配上文字，为玩家提供了一些有用的信息，比如玩家剩余任务时间，生命值，魔法值，坐标位置等等更多的信息。而因为在玩家和游戏交互的过程中，这些界面是透过摄像机视角显示出来的，它们被称为HUD(heads-up-display)。在视频游戏中，HUD就是一类可以实时向玩家显示有用信息和符号的GUI，并且它和诸如游戏菜单这样的其他界面不同.HUD中通常没有按钮、编辑框或者适合玩家交互的内容，因为玩家往往都是被游戏本身的画面和内容所吸引，而不是去关注HUD。所以呢，HUD通常并不去使用可以交互的元素，而倾向于使用文本和图像来表示某些信息。所以，游戏选项和偏好设置这样的内容不是HUD的菜，它们直接交由系统菜单来完成。
>
> 下面我们看一看更加规范化的
>
> HUD
>
> 的介绍。
>
> HUD
>
> ，
> heads-up-display，硬着过来翻译就是“
> 抬头显视设备
>
> ”- -
>
> 。这是一个从军事领域起源的技术，可以把一些重要的战术信息显示在正常观察方向的视野范围内，而同时又不会影响对于环境的注意，也不用总是转移视线去专门观察仪表板上的那些指针和数据。游戏借鉴了这个概念，把游戏相关的信息以类似
>
> HUD
>
> 的方式显示在游戏画面上，让玩家可以随时了解那些最重要最直接相关的内容。当然玩家要获得游戏信息可以有别的方式，比如菜单。菜单有着专门的界面，可以容纳更大的信息量，但却不能和游戏画面同时出现。调出菜单意味着中断游戏流程，
>
> HUD
>
> 则在提供必要的信息的同时完全避免了这个问题。
>
> 虽然菜单提供了大量的信息，然而对于处在自由行动状态下的玩家而言，这些信息都不是立刻需要获取的。
>
> HUD
>
> 只提供了最重要最基本的内容：当前场景的地图。切换到战斗状态下之后，
>
> HUD
>
> 所提供的信息便会转变为那些只和战斗相关的部分。
>
> 记得最早的游戏
>
> pong
>
> 在设计的时候就没有
>
> HUD
>
> 的。对于这样一个简单的游戏而言，唯一对玩家有意义需要及时掌握的就是双方的比分，而最早版本的
>
> pong
>
> 没有这个功能，玩家需要自己去记录比分。游戏设计者很快意识到了这个问题，
>
> HUD
>
> 很快就被整合到了后来的游戏之中，并随着游戏的进化一起演变，完善。
>
> 如果被上面的这些书面语绕晕了没关系，说了这么多，一言以蔽之：
> 菜单的目的是大而全，
>
> HUD
>
> 的目的则是少而精。
> HUD主要注重的是实时向玩家显示有用信息和符号的GUI，和而系统菜单GUI可以给玩家提供
> 更多更全的信息。
>
> 不同类型的游戏玩起来的重点不一样，
>
> HUD
>
> 在提供的信息方面也有很大的差别。我们不妨按照游戏的类别，来看看各种游戏的
>
> HUD
>
> 设计的模式和重点。
>
> ### 1.角色扮演类游戏
>
> 取决于游戏是否会在行动场景和战斗场景之间切换，角色扮演游戏的
>
> HUD
>
> 设计会有所不同，关于行动的那一部分内容，比如地图和方向指示之类的信息可能会被单独分列出来。但总体上角色扮演游戏的
>
> HUD
>
> 信息量基本是一致的：玩家的生命，魔法，行动力，状态（或者其它因游戏而异的内容）等等的数值，玩家可以
>
> “
>
> 一键
>
> ”
>
> 接触到的物品魔法等等东西，如果物品和魔法的内容很复杂，那么一般都会把全面调节的功能交给菜单来完成。比如预设快捷键和菜单光标位置记忆功能就是这样的目的，把菜单中全面而细微的调节能力中，挑选出一些最重要的，放到
>
> HUD
>
> 上来，共玩家选择使用。
>
> ### 2.格斗游戏
>
> 无论格斗游戏系统本身怎么进化，从
>
> 2D
>
> 变到
>
> 3D
>
> ，格斗游戏的
>
> HUD
>
> 总是保持着自己一贯的特色。格斗游戏的
>
> HUD
>
> 大多分成两个部分：第一，对战斗数据的统计，第二，对战斗中精彩场面的描述。前者就是那些显眼的血槽，还包括时间，局数计分。后者则是对于连击之类的精彩动作的积分等等信息。其中血槽这个东西是游戏
>
> HUD
>
> 设计上一个非常典型的东西。
>
> ##### 3.体育游戏
>
> 体育类游戏在设计
>
> HUD
>
> 的问题上有着天然的两个参考坐标系：电视转播画面和球队的战术分析图。游戏的
>
> HUD
>
> 结合了这两者，即体现出了电视转播画面的现场感，也做出了战术分析图那样的清晰感，让玩家尽可能的在有身临其境的感觉的同时也对比赛局面有着清晰的了解。实际上体育类游戏的
>
> HUD
>
> 设计作的是如此的好，以至于最近以来，很多体育项目
>
>
>
>
> 的电视转播画面开始学习这类游戏的
>
> HUD
>
> 设计，往画面上添加一些即时的比赛信息和战术分析。
>
> ##### 4.驾驶模拟类游戏
>
> 这类游戏所要模仿的对象就是
>
> HUD
>
> 这个概念的来源的地方，所以驾驶模拟类游戏
>
> HUD
>
> 设计的原则也就变得非常简单而直接：尽可能的去重现模拟对象的原始
>
> HUD
>
> 就可以了。当然根据游戏模拟真实的程度不同，再现真实
>
> HUD
>
> 设计的程度也有所区别。
>
> HUD
>
> 的设计始终存在一个如何抽取最重要的信息提示玩家的问题，过于仿真的游戏
>
> HUD
>
> 设计将大量的信息不加选择的堆在玩家面前。对于游戏本身
>
> “
>
> 模拟
>
> ”
>
> 这个概念而言，是好事，但对于像通过这些游戏来体验现实生活中不可能接触到的东西这个目的而言，高度的仿真模拟往往会成为上手的障碍。游戏毕竟是游戏，游戏的
>
> HUD
>
> 如何在仿真模拟和抽象表现上把握平衡，是这类游戏的一个突出问题。
>
> ##### 5.动作射击类游戏
>
> 射击类游戏的
>
> HUD
>
> 通常都包括了玩家的状态，玩家的武器状态，地图，以及目标指示这四个方面。第三人称的射击游戏或者团队策略类射击游戏在
>
> HUD
>
> 设计上和传统的第一人称射击游戏区别也不是很大，重点同样在这些要素上。
>
> HUD
>
> 的引入给所有的射击类游戏，无论游戏本身的背景设定是在什么样的时代，都带来了一定的科幻未来的要素。真实的战斗中，对于战场情况的把握从来都是很大的挑战，不断进步的单兵信息化装备正是力求解决这些问题。射击类游戏通过
>
> HUD
>
> 的引入超前的解决了这个问题。就目前而言，感觉做的最好的射击类游戏
>
> HUD
>
> 恰恰就是一些未来题材的射击游戏，等下在
>
> HUD
>
> 进化中我们会看到例子。
>
> ##### 6.策略类游戏
>
> 最为复杂的一类游戏
>
> HUD
>
> ，事实上在这类游戏里面
>
> HUD
>
> 和菜单往往难以截然区分。因为玩家几乎每时每刻都需要确实的掌握整个游戏空间里大量单位的行动。
>
> HUD
>
> 是简化了的菜单，但在很多的策略类游戏上，简化只是一个美好的愿望，游戏本身的复杂程度和玩家的
>
> “
>
> 上帝
>
> ”
>
> 视角导致了这类游戏必然随时都有大量的信息反馈和大量的命令等待输入。策略类游戏的
>
> HUD
>
> 如此的复杂，以至于在控制器键位相对较少的游戏主机上，这类游戏的流行程度始终达不到
>
> PC
>
> 上同类游戏的流行度。游戏本身机制导致的复杂
>
> HUD
>
> 设计应该是这类游戏受众群体局限性产生的原因之一。
>
> 其它类型的游戏，比如平台游戏，益智游戏等等在
>
> HUD
>
> 设计上感觉并没有什么特别的地方。它们的
>
> HUD
>
> 只要能清晰的交代出游戏人物（如果有的话）的状态和游戏的进展程度（得分之类的信息）就可以了。
>
> 如果看到这里觉得累了，依旧是欣赏一部分近期的3A游戏大作的UI界面美图吧：
>
> 《孤岛危机3》：
>
> ![](https://img-blog.csdn.net/20131117193150953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 《仙剑奇侠传五 前传》：
>
> ![](https://img-blog.csdn.net/20131117193203375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 《刺客信条4黑旗》：
>
> ![](https://img-blog.csdn.net/20131117193229062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> ## 三、开始GUI系统的设计
>
> 在这篇文章里面，我们将一起去实现一个简单而健全的GUI系统。这个系统既有HUD的功能，也可以创建GUI菜单。依旧是和之前的其他系统一样，封装在一个类中，这次的类是D3DGUIClass。
>
> 下面又到了天马行空的设计时刻了——在实现GUI系统之前，让我们设计出心目中的GUI系统该有的功能。
>
> ### 1.大体说明
>
> 首先需要说明的是，我们这次设计的GUI系统主要用于演示之用，扩展性很强，需要的更多功能完全可以在这个GUI的系统上进行二次开发，来增强它的特性和功能。
>
> GUI系统主要由按钮和静态文本控件对象组成，当然，还少不了背景图的显示。由于GUI系统是2D的，这意味着指定对象位置时，是用不到Z轴的。另外，我们决定使用正交投影的方式来渲染GUI，这样可以根据像素的位置来指定屏幕的位置。
>
> 让我们来回忆一下，（0,0）对应的是屏幕的左上角。在windows系统中，左上角就是（0,0）。有了这个信息，就可以轻松地确定玩家的鼠标指针是否悬停在GUI系统的控件之上，或者说正在点击这个控件。
>
> ### 2.关于布局规划和背景图
>
> 在设计和规划按钮和文本位置时，我们只要牢记窗口左上角的坐标是（0,0），就能随心所欲的创建各式各样的限制的系统范围内的心仪的GUI布局出来。对于背景图的话，其实没必要考虑它的位置，因为这个图像就是一个由两个三角形构成的全屏图像。只要系统知道当前程序的宽度和高度，就可以显示一个全屏纹理图。
>
> ### 3.关于按钮控件的实现
>
> 必不可少的特性就是可以点击的按钮控件，其实按钮控件的实现比点击图像更容易实现。由于按钮控件的位置是以像素来指定的，因此为了确定鼠标指针是否在按钮上或者按下了按钮，其实就是检查当前鼠标指针的位置是否落在按钮区域内。因为Windows
> [操作系统](http://lib.csdn.net/base/operatingsystem "操作系统知识库")
> 用像素指定鼠标位置且屏幕的左上角为（0,0），所以检查鼠标的坐标是否处于按钮四个角的坐标范围内就可以了，即检查如下四个方面：
>
> 按钮的左侧坐标位置是否小于鼠标指针的X坐标，按钮右侧坐标位置是否大于鼠标指针的X坐标，按钮的上侧坐标是否小于鼠标指针的Y坐标，下侧坐标是否大于鼠标的Y坐标。如果四个都为真的话，那么就可以认定鼠标指针就在按钮控件之上了，然后便通过消息过程来检测是否按下的鼠标左键这个状态，如果按下了鼠标左键，那么就可以确定玩家不仅仅是把鼠标放在了按钮之上，而是同时点击了按钮。我们还在这个GUI系统中实现了通过鼠标的悬停和点击动作，来改变按钮的外观，在按下按钮后有一定的动画效果。
>
> 根据上面的描述，我们可以写出的实现代码如下：
>
> 其中pControl是一个自定义的GUICONTROL结构体的指针对象
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //检查鼠标是否悬停或者点击了按钮
> 2. if
>
>    (mouseX> pControl->m\_xPos && mouseX < pControl->m\_xPos +pControl->m\_width &&
> 3. mouseY> pControl->m\_yPos && mouseY < pControl->m\_yPos + pControl->m\_height)
> 4. {
> 5. if
>
>    (LMBDown)status = UGP\_BUTTON\_DOWN;
> 6. elsestatus = UGP\_BUTTON\_OVER;
> 7. }
>
>   
>
> ### 4.类的框架设计
>
> 因为这个GUI系统的实现还有一定的细节需要详细说明，所以决定分两次更新来讲解。这次我们先把功能完整的类的实现结果给大家，并告诉大家如何使用，说明一下main函数相对于之前有哪些细节需要改变，然后GUI系统类的实现细节留待下篇讲解（如果需要额外用一次更新来讲解的话）。
>
> 还是把详细注释的头文件贴一下吧：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //====================================================
> 2. // Name: D3DGUIClass.h
> 3. //      Des:一个游戏GUI界面系统类的头文件
> 4. // 2013年 11月17日  Create by 浅墨
> 5. //====================================================
> 7. #pragma once
>
> 10. // 所支持的控件类型宏
> 11. #define UGP\_GUI\_STATICTEXT                 1
> 12. #define UGP\_GUI\_BUTTON                     2
> 13. #define UGP\_GUI\_Background                 3
> 15. // 鼠标按键状态宏
> 16. #define UGP\_BUTTON\_UP                      1
> 17. #define UGP\_BUTTON\_OVER                2
> 18. #define UGP\_BUTTON\_DOWN                    3
> 20. // 设置一些GUI中用到的控件ID
> 21. #define STATIC\_ID\_1  1
> 22. #define STATIC\_ID\_2  2
> 23. #define BUTTON\_ID\_1  3
> 24. #define BUTTON\_ID\_2  4
> 25. #define BUTTON\_ID\_3  5
> 26. #define BUTTON\_ID\_4  6
>
>
> 30. // FVF灵活顶点类型的结构体
> 31. struct
>
>     GUIVERTEX
> 32. {
> 33. floatx, y, z, rhw;
> 34. unsignedlong color;
> 35. floattu, tv;
> 36. };
> 37. #define D3DFVF\_GUI (D3DFVF\_XYZRHW |D3DFVF\_DIFFUSE | D3DFVF\_TEX1)
>
> 40. //控件属性结构体
> 41. struct
>
>     GUICONTROL
> 42. {
> 43. //操作类型，ID和颜色
> 44. intm\_type;
>     //控件类型
> 45. intm\_id;
>     //控件ID
> 46. unsignedlong m\_color;
>     //控件颜色
> 47. intm\_listID;
>     //如果是文字的话，这个变量就表示它使用的字体，否则就表示顶点缓存
> 48. floatm\_xPos, m\_yPos;
>     //控件的起始位置
> 49. floatm\_width, m\_height;
>     // 控件的宽度和高度
> 50. wchar\_t
>
>     \*m\_text;
>
>     // 文字内容
> 51. LPDIRECT3DTEXTURE9m\_Background;
>     // 控件背景的填充图像
> 52. LPDIRECT3DTEXTURE9m\_upTex, m\_downTex, m\_overTex;
>     // 存放按钮弹起，按下和鼠标经过时的3张纹理图
> 53. };
>
>
> 57. class
>
>     D3DGUIClass
> 58. {
> 60. private
>
>     :
> 61. LPDIRECT3DDEVICE9m\_pd3dDevice;
>     //D3D设备对象
> 62. LPD3DXFONT\*m\_pFonts;
>     //D3D字体对象
> 63. GUICONTROL\*m\_pControls;
>     //控件对象
> 64. LPDIRECT3DVERTEXBUFFER9\*m\_pVertexBuffer;
>     //顶点缓存对象指针
> 65. GUICONTROLm\_Background;
>     //背景图对象
> 66. LPDIRECT3DVERTEXBUFFER9m\_BackgroundBuffer;
>     //背景图缓冲区对象
> 68. boolm\_bIsBackgroundUsed;
>     //一个标识，用于标识是否已经用了背景
> 69. intm\_nTotalFontNum;
>     //字体数目计数器
> 70. intm\_nTotalControlNum;
>     //控件数目计数器
> 71. intm\_nTotalBufferNum;
>     //缓冲区数目计数器
> 73. intm\_nWindowWidth;
>     //窗口宽度
> 74. intm\_nWindowHeight;
>     //窗口高度
>
>
> 78. public
>
>     :
> 79. D3DGUIClass(LPDIRECT3DDEVICE9device,
>     int
>
>     w,
>
>     int
>
>     h);
> 80. ~D3DGUIClass(){ ClearUp(); }
> 82. LPDIRECT3DDEVICE9GetD3dDevice() {
>     return
>
>     m\_pd3dDevice; }
>
>     //返回D3D设备对象的函数
> 83. GUICONTROL\*GetBackground() {
>     return
>
>     &m\_Background; }
>
>     //返回背景的函数
> 84. LPDIRECT3DVERTEXBUFFER9GetBackgroundBuffer() {
>     return
>
>     m\_BackgroundBuffer; }
>
>     //返回背景缓冲区对象的函数
>
> 87. intGetTotalFontNum() {
>     return
>
>     m\_nTotalFontNum; }
>
>     //返回所有字体数目的函数
> 88. intGetTotalControlNum() {
>     return
>
>     m\_nTotalControlNum; }
>
>     //返回所有控件数目的函数
> 89. intGetTotalBufferNum() {
>     return
>
>     m\_nTotalBufferNum; }
>
>     //返回总的缓冲区数目的函数
> 90. intGetWindowWidth() {
>     return
>
>     m\_nWindowWidth; }
>
>     //返回窗口宽度的函数
> 91. intGetWindowHeight() {
>     return
>
>     m\_nWindowHeight; }
>
>     //返回窗口高度的函数
> 92. boolIsBackgroundUsed() {
>     return
>
>     m\_bIsBackgroundUsed; }
>
>     //返回背景是否在使用的bool值的函数
> 93. voidSetWindowSize(
>     int
>
>     w,
>
>     int
>
>     h) { m\_nWindowWidth = w; m\_nWindowHeight = h; }
>
>     //设置窗口宽度和高度的函数
> 95. LPD3DXFONTGetFont(
>     int
>
>     id)
>
>     //返回字体ID函数
> 96. {
> 97. if
>
>     (id< 0 || id >= m\_nTotalFontNum)
>
>     return
>
>     NULL;
> 98. returnm\_pFonts[id];
> 99. }
> 101. GUICONTROL\*GetGUIControl(
>      int
>
>      id)
>
>      //返回GUI控件ID函数
> 102. {
> 103. if
>
>      (id< 0 || id >= m\_nTotalControlNum)
>
>      return
>
>      NULL;
> 104. return
>
>      &m\_pControls[id];
> 105. }
> 107. LPDIRECT3DVERTEXBUFFER9GetVertexBuffer(
>      int
>
>      id)
>
>      //返回顶点缓存ID函数
> 108. {
> 109. if
>
>      (id< 0 || id >= m\_nTotalBufferNum)
>
>      return
>
>      NULL;
> 110. returnm\_pVertexBuffer[id];
> 111. }
>
> 114. boolCreateTextFont(
>      wchar\_t
>
>      \*fontName,
>
>      int
>
>      size,
>
>      int
>
>      \*fontID);
>
>      //字体创建函数
> 115. boolAddBackground(
>      wchar\_t
>
>      \*fileName);
>
>      //GUI背景添加函数
> 116. boolAddStaticText(
>      int
>
>      id,
>
>      wchar\_t
>
>      \*text,
>
>      float
>
>      x,
>
>      float
>
>      y, unsigned
>
>      long
>
>      color, intfontID);
>
>      //添加静态文本函数
> 117. boolAddButton(
>      int
>
>      id,
>
>      float
>
>      x,
>
>      float
>
>      y,
>
>      wchar\_t
>
>      \*up,
>
>      wchar\_t
>
>      \*over,
>
>      wchar\_t
>
>      \*down);
>
>      //添加按钮函数
> 118. voidClearUp( );
>      //资源清理函数
>
> 121. };
> 123. void
>
>      ProcessGUI(D3DGUIClass \*gui, boolLMBDown,
>
>      int
>
>      mouseX,
>
>      int
>
>      mouseY,
> 124. void
>
>      (\*funcPtr)(intid,
>
>      int
>
>      state));
>
>      //回调函数
>
>   
>   
>   
>
> 具体的实现细节如果现在讲会有一定的篇幅，我们留待下次讲解吧。
>
> ## 四、GUI系统类的使用
>
> 接下来，一起来研究研究如果要在我们之前的demo框架里使用GUI系统的话，需要添加哪些代码。
>
> 第一步
>
> ，依旧是添加一些必要的全局变量：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. D3DGUIClass      g\_gui= NULL;
>
>    //创建GUI类对象
> 2. int
>
>    g\_FontID = -1;
>
>    //  GUI中字体对象的ID
> 3. bool
>
>    g\_LMBDown=
>
>    false
>
>    ;
>
>    // GUI中的鼠标状态信息，鼠标左键是否按下的标识
> 4. int
>
>    g\_MouseX= 0, g\_MouseY = 0;
>
>    //存储鼠标坐标的两个变量
>
>   
>
> 可以看到，在这里我们定义了自己写的GUI系统类D3DGUIClass的类对象，然后是鼠标状态信息相关的变量和一个字体对象。
>
> 第二步
>
> ，在消息处理函数的switch中添加一些新的case：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //-----------------------------------【WndProc( )函数】--------------------------------------
> 2. //      描述：窗口过程函数WndProc,对窗口消息进行处理
> 3. //------------------------------------------------------------------------------------------------
> 4. LRESULT
>
>    CALLBACK WndProc(
>
>    HWND
>
>    hwnd, UINTmessage,
>
>    WPARAM
>
>    wParam,
>
>    LPARAM
>
>    lParam )
>
>    //窗口过程函数WndProc
> 5. {
> 6. switch
>
>    (message )
>
>    //switch语句开始
> 7. {
> 8. caseWM\_PAINT:
>    // 客户区重绘消息
> 9. Direct3D\_Render(hwnd,0.0f);
>    //调用Direct3D\_Render函数，进行画面的绘制
> 10. ValidateRect(hwnd,NULL);
>     // 更新客户区的显示
> 11. break
>
>     ;
>
>     //跳出该switch语句
> 13. caseWM\_KEYDOWN:
>     // 键盘按下消息
> 14. if
>
>     (wParam == VK\_ESCAPE)
>
>     // ESC键
> 15. DestroyWindow(hwnd);
>     // 销毁窗口, 并发送一条WM\_DESTROY消息
> 16. break
>
>     ;
> 17. caseWM\_DESTROY:
>     //窗口销毁消息
> 18. Direct3D\_CleanUp();
>     //调用Direct3D\_CleanUp函数，清理COM接口对象
> 19. PostQuitMessage(0 );
>     //向系统表明有个线程有终止请求。用来响应WM\_DESTROY消息
> 20. break
>
>     ;
>
>     //跳出该switch语句
> 22. caseWM\_KEYUP:
> 23. if
>
>     (wParam== VK\_ESCAPE) PostQuitMessage(0);
> 24. break
>
>     ;
> 26. caseWM\_LBUTTONDOWN:
> 27. g\_LMBDown=
>     true
>
>     ;
> 28. break
>
>     ;
> 30. caseWM\_LBUTTONUP:
> 31. g\_LMBDown=
>     false
>
>     ;
> 32. break
>
>     ;
> 34. caseWM\_MOUSEMOVE:
> 35. g\_MouseX= LOWORD (lParam);
> 36. g\_MouseY= HIWORD (lParam);
> 37. break
>
>     ;
>
> 40. default
>
>     :
>
>     //若上述case条件都不符合，则执行该default语句
> 41. returnDefWindowProc( hwnd, message, wParam, lParam );
>     //调用缺省的窗口过程来为应用程序没有处理的窗口消息提供缺省的处理。
> 42. }
> 44. return0;
>     //正常退出
> 45. }
>
> 其实这一步就是在之前消息的基础上，添加了左键按下，左键弹起，和鼠标移动的消息响应。
>
> 第三步
> ，在进行渲染资源准备的Object\_Init( )函数中，添加载入GUI系统中的资源到内存中的相关代码：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //-----------------------------------【Object\_Init()函数】--------------------------------------
> 2. //      描述：渲染资源初始化函数，在此函数中进行要被渲染的物体的资源的初始化
> 3. //--------------------------------------------------------------------------------------------------
> 4. HRESULT
>
>    Objects\_Init()
> 5. {
> 6. //创建字体
> 7. D3DXCreateFont(g\_pd3dDevice,36, 0, 0, 1000,
>    false
>
>    , DEFAULT\_CHARSET,
> 8. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, \_T(
>    "Calibri"
>
>    ), &g\_pTextFPS);
> 9. D3DXCreateFont(g\_pd3dDevice,20, 0, 1000, 0,
>    false
>
>    , DEFAULT\_CHARSET,
> 10. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, L
>     "华文中宋"
>
>     , &g\_pTextAdaperName);
> 11. D3DXCreateFont(g\_pd3dDevice,23, 0, 1000, 0,
>     false
>
>     , DEFAULT\_CHARSET,
> 12. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, L
>     "微软雅黑"
>
>     , &g\_pTextHelper);
> 13. D3DXCreateFont(g\_pd3dDevice,26, 0, 1000, 0,
>     false
>
>     , DEFAULT\_CHARSET,
> 14. OUT\_DEFAULT\_PRECIS,DEFAULT\_QUALITY, 0, L
>     "黑体"
>
>     , &g\_pTextInfor);
>
> 17. //设置纹理采样参数
> 18. g\_pd3dDevice->SetSamplerState(0,D3DSAMP\_MINFILTER, D3DTEXF\_NONE);
> 19. g\_pd3dDevice->SetSamplerState(0,D3DSAMP\_MAGFILTER, D3DTEXF\_NONE);
> 20. g\_pd3dDevice->SetSamplerState(0,D3DSAMP\_MIPFILTER, D3DTEXF\_NONE);
>
> 23. //-----------------------------------【GUI系统相关代码】-------------------------------
> 24. //创建GUI系统
> 25. g\_gui=
>     new
>
>     D3DGUIClass(g\_pd3dDevice, WINDOW\_WIDTH, WINDOW\_HEIGHT);
> 26. if
>
>     (!g\_gui)
>
>     return
>
>
>
>     false
>
>     ;
> 28. //添加背景图片
> 29. if
>
>     (!g\_gui->AddBackground(L
>
>     "GameMedia\\Assassinscreed.jpg"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 31. //添加字体
> 32. if
>
>     (!g\_gui->CreateTextFont(L
>
>     "微软雅黑"
>
>     ,28, &g\_FontID))
>
>     return
>
>
>
>     false
>
>     ;
>
> 35. //添加静态文本到GUI中
> 36. if
>
>     (!g\_gui->AddStaticText(STATIC\_ID\_1,L
>
>     "Version 浅墨1.0版"
>
>     ,
> 37. 1170,735, D3DCOLOR\_XRGB(55,155,255), g\_FontID))
>     return
>
>
>
>     false
>
>     ;
> 39. if
>
>     (!g\_gui->AddStaticText(STATIC\_ID\_2,L
>
>     "浅墨DirectX教程第三季之 打造游戏GUI界面"
>
>     ,
> 40. 500,10, D3DCOLOR\_XRGB(255,255,255), g\_FontID))
>     return
>
>
>
>     false
>
>     ;
>
> 43. //添加4个按钮，分别是开始游戏，载入进度，选项和退出游戏，每个按钮对应3幅图
> 44. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_1,650, 340, L
>
>     "GameMedia\\startUp.png"
>
>     ,
> 45. L
>     "GameMedia\\StartOver.png"
>
>     ,L
>
>     "GameMedia\\startDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 47. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_2,650, 385, L
>
>     "GameMedia\\loadUp.png"
>
>     ,
> 48. L
>     "GameMedia\\loadOver.png"
>
>     ,L
>
>     "GameMedia\\loadDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 50. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_3,650, 430, L
>
>     "GameMedia\\optionsUp.png"
>
>     ,
> 51. L
>     "GameMedia\\optionsOver.png"
>
>     ,L
>
>     "GameMedia\\optionsDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 53. if
>
>     (!g\_gui->AddButton(BUTTON\_ID\_4,650, 475, L
>
>     "GameMedia\\quitUp.png"
>
>     ,
> 54. L
>     "GameMedia\\quitOver.png"
>
>     ,L
>
>     "GameMedia\\quitDown.png"
>
>     ))
>
>     return
>
>
>
>     false
>
>     ;
> 56. returnS\_OK;
> 57. }
>
> 代码中都注释的比较详细，就不多说明了哈。
>
> 第四步
>
> ，添加一个GUI系统的回调函数：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. void
>
>    GUICallback(
>
>    int
>
>    id,
>
>    int
>
>    state)
> 2. {
> 3. switch
>
>    (id)
> 4. {
> 5. caseBUTTON\_ID\_1:
> 6. //“开始游戏”按钮的相关代码实现
> 7. break
>
>    ;
> 8. caseBUTTON\_ID\_2:
> 9. //“载入游戏”按钮的相关代码实现
> 10. break
>
>     ;
> 11. caseBUTTON\_ID\_3:
> 12. //“选项”按钮的相关代码实现
> 13. break
>
>     ;
> 14. caseBUTTON\_ID\_4:
> 15. //如果点击了退出按钮，就退出程序
> 16. if
>
>     (state== UGP\_BUTTON\_DOWN) PostQuitMessage(0);
> 17. break
>
>     ;
> 18. }
> 19. }
>
> 这里是一个switch—case语句总领的回调函数。
>
> 大家也许暂时会对这个函数的使用不太理解，其实它和我们自定义的ProcessGUI有着千丝万缕的联系，具体内容我们在出GUI的第二篇文章的时候再详细讲解。这里我们只要知道它是和ProcessGUI搞基的就可以了。
>
> 举个例子吧，对其中的BUTTON\_ID\_1按钮，就是指的GUI界面中的“Start Game”按钮，而点击之后的余下响应代码（也就是消息响应代码）就写在这个case之后，比如说点击了新游戏的开始后需要渲染游戏画面等等一系列代码。
>
> 第五步
>
> ，在渲染五步曲的第三步中调用一个封装好功能的ProcessGUI函数就可以了。这个函数的具体实现我们在稍后退出的文章中会讲到。
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //--------------------------------------------------------------------------------------
> 2. //【Direct3D渲染五步曲之二】：开始绘制
> 3. //--------------------------------------------------------------------------------------
> 4. g\_pd3dDevice->BeginScene();
>    // 开始绘制
> 6. //--------------------------------------------------------------------------------------
> 7. //【Direct3D渲染五步曲之三】：正式绘制
> 8. //--------------------------------------------------------------------------------------
>
> 11. //处理和渲染GUI系统
> 12. ProcessGUI(g\_gui,g\_LMBDown, g\_MouseX, g\_MouseY, GUICallback);
> 14. //-----------------------------【绘制文字信息】-----------------------------
> 15. HelpText\_Render(hwnd);
>
> 18. //--------------------------------------------------------------------------------------
> 19. //【Direct3D渲染五步曲之四】：结束绘制
> 20. //--------------------------------------------------------------------------------------
> 21. g\_pd3dDevice->EndScene();
>     // 结束绘制
>
>   
>
> ## 五、详细注释的源代码欣赏
>
> 这次的工程因为是作为GUI的初步演示，自然就有了孑然一身的感觉，除了main.cpp和D3DUtil.h就是D3DGUIClass类的源文件和头文件了。如下图：
>
> ![](https://img-blog.csdn.net/20131117203956390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 程序主要是实现了简单的GUI系统，通过GUI系统的功能在屏幕上添加了游戏菜单的四个按钮，并且在屏幕上输出了“浅墨DirectX教程第三季 之 打造游戏GUI界面”，"Version 浅墨1.0版"这两段文字。
>
> 而且目前对“quit”退出按钮的功能进行了实行实现，其实就简单一句if(state == UGP\_BUTTON\_DOWN) PostQuitMessage(0);。。。。。
>
> 那么，老规矩，上程序的核心部分，main函数的代码吧：
>
> **[cpp]**
> [view plain](http://blog.csdn.net/poem_qianmo/article/details/16384009# "view plain")
> [copy](http://blog.csdn.net/poem_qianmo/article/details/16384009# "copy")[print](http://blog.csdn.net/poem_qianmo/article/details/16384009# "print")
> [?](http://blog.csdn.net/poem_qianmo/article/details/16384009# "?")
>
> 1. //-----------------------------------【程序说明】----------------------------------------------
> 2. // 【Visual C++】游戏开发系列配套源码五十六 浅墨DirectX教程二十三 打造游戏GUI界面（一）
> 3. // VS2010版
> 4. // 2013年11月 Create by 浅墨
> 5. // 背景音乐素材出处： 刺客信条
> 6. //------------------------------------------------------------------------------------------------
>
> 9. //-----------------------------------【宏定义部分】--------------------------------------------
> 10. // 描述：定义一些辅助宏
> 11. //------------------------------------------------------------------------------------------------
> 12. #define WINDOW\_WIDTH    1366                        //为窗口宽度定义的宏，以方便在此处修改窗口宽度
> 13. #define WINDOW\_HEIGHT   768                         //为窗口高度定义的宏，以方便在此处修改窗口高度
> 14. #define WINDOW\_TITLE     \_T("【致我们永不熄灭的游戏开发梦想】 浅墨DirectX教程二十三 打造游戏GUI界面（一）博文配套示例程序 by浅墨") //为窗口标题定义的宏
>
>
> 18. //-----------------------------------【头文件包含部分】---------------------------------------
> 19. //  描述：包含程序所依赖的头文件
> 20. //------------------------------------------------------------------------------------------------
> 21. #include <d3d9.h>
> 22. #include <d3dx9.h>
> 23. #include <tchar.h>
> 24. #include <time.h>
> 25. #include "D3DUtil.h"
> 26. #include "D3DGUIClass.h"
>
>
> 30. //-----------------------------------【库文件包含部分】---------------------------------------
> 31. //  描述：包含程序所依赖的库文件
> 32. //------------------------------------------------------------------------------------------------
> 33. #pragma comment(lib,"d3d9.lib")
> 34. #pragma comment(lib,"d3dx9.lib")
> 35. #pragma comment(lib, "dinput8.lib")     // 使用DirectInput必须包含的库文件，注意这里有8
> 36. #pragma comment(lib,"dxguid.lib")
> 37. #pragma comment(lib, "winmm.lib")
>
>
> 41. // 地板的顶点结构
> 42. struct
>
>     CUSTOMVERTEX
> 43. {
> 44. FLOAT
>
>     \_x, \_y, \_z;
> 45. FLOAT
>
>     \_u, \_v ;
> 46. CUSTOMVERTEX(
>     FLOAT
>
>     x,
>
>     FLOAT
>
>     y,
>
>     FLOAT
>
>     z,
>
>     FLOAT
>
>     u,
>
>     FLOAT
>
>     v)
> 47. : \_x(x), \_y(y), \_z(z), \_u(u), \_v(v) {}
> 48. };
> 49. #define D3DFVF\_CUSTOMVERTEX  (D3DFVF\_XYZ | D3DFVF\_TEX1)
>
> 52. //-----------------------------------【全局变量声明部分】-------------------------------------
> 53. //  描述：全局变量的声明
> 54. //------------------------------------------------------------------------------------------------
> 55. LPDIRECT3DDEVICE9                   g\_pd3dDevice = NULL;
>     //Direct3D设备对象
> 56. LPD3DXFONT                              g\_pTextFPS =NULL;
>     //字体COM接口
> 57. LPD3DXFONT                              g\_pTextAdaperName = NULL;
>     // 显卡信息的2D文本
> 58. LPD3DXFONT                              g\_pTextHelper = NULL;
>     // 帮助信息的2D文本
> 59. LPD3DXFONT                              g\_pTextInfor= NULL;
>     // 绘制信息的2D文本
> 60. float
>
>     g\_FPS= 0.0f;
>
>     //一个浮点型的变量，代表帧速率
> 61. wchar\_t
>
>     g\_strFPS[50] ={0};
>
>     //包含帧速率的字符数组
> 62. wchar\_t
>
>     g\_strAdapterName[60] ={0};
>
>     //包含显卡名称的字符数组
> 64. D3DGUIClass                             \*g\_gui = NULL;
>     //创建GUI类对象
> 65. bool
>
>     g\_LMBDown =
>
>     false
>
>     ;
>
>     // GUI中的鼠标状态信息，鼠标左键是否按下的标识
> 66. int
>
>     g\_MouseX = 0, g\_MouseY = 0;
>
>     //存储鼠标坐标的两个变量
> 67. int
>
>     g\_FontID = -1;
>
>     //  GUI中字体对象的ID
>
> 70. //-----------------------------------【全局函数声明部分】-------------------------------------
> 71. //  描述：全局函数声明，防止“未声明的标识”系列错误
> 72. //------------------------------------------------------------------------------------------------
> 73. LRESULT
>
>     CALLBACK        WndProc(
>
>     HWND
>
>     hwnd,
>
>     UINT
>
>     message,
>
>     WPARAM
>
>     wParam,
>
>     LPARAM
>
>     lParam );
> 74. HRESULT
>
>     Direct3D\_Init(
>
>     HWND
>
>     hwnd,
>
>     HINSTANCE
>
>     hInstance);
> 75. HRESULT
>
>     Objects\_Init();
> 76. void
>
>     Direct3D\_Render(
>
>     HWND
>
>     hwnd,
>
>     FLOAT
>
>     fTimeDelta);
> 77. void
>
>     Direct3D\_Update(
>
>     HWND
>
>     hwnd,
>
>     FLOAT
>
>     fTimeDelta);
> 78. void
>
>     Direct3D\_CleanUp( );
> 79. float
>
>     Get\_FPS();
> 80. void
>
>     HelpText\_Render(
>
>     HWND
>
>     hwnd);
> 81. void
>
>     GUICallback(
>
>     int
>
>     id,
>
>     int
>
>     state);
> 83. //-----------------------------------【WinMain( )函数】--------------------------------------
> 84. //  描述：Windows应用程序的入口函数，我们的程序从这里开始
> 85. //------------------------------------------------------------------------------------------------
> 86. int
>
>     WINAPI WinMain(
>
>     HINSTANCE
>
>     hInstance,
>
>     HINSTANCE
>
>     hPrevInstance,
>
>     LPSTR
>
>     lpCmdLine,
>
>     int
>
>     nShowCmd)
> 87. {
> 89. //开始设计一个完整的窗口类
> 90. WNDCLASSEX wndClass={0} ;
>     //用WINDCLASSEX定义了一个窗口类，即用wndClass实例化了WINDCLASSEX，用于之后窗口的各项初始化
> 91. wndClass.cbSize =
>     sizeof
>
>     ( WNDCLASSEX ) ;
>
>     //设置结构体的字节数大小
> 92. wndClass.style = CS\_HREDRAW | CS\_VREDRAW;
>     //设置窗口的样式
> 93. wndClass.lpfnWndProc = WndProc;
>     //设置指向窗口过程函数的指针
> 94. wndClass.cbClsExtra     = 0;
> 95. wndClass.cbWndExtra     = 0;
> 96. wndClass.hInstance = hInstance;
>     //指定包含窗口过程的程序的实例句柄。
> 97. wndClass.hIcon=(
>     HICON
>
>     )::LoadImage(NULL,\_T(
>
>     "GameMedia\\icon.ico"
>
>     ),IMAGE\_ICON,0,0,LR\_DEFAULTSIZE|LR\_LOADFROMFILE);
>
>     //从全局的::LoadImage函数从本地加载自定义ico图标
> 98. wndClass.hCursor = LoadCursor( NULL, IDC\_ARROW );
>     //指定窗口类的光标句柄。
> 99. wndClass.hbrBackground=(
>     HBRUSH
>
>     )GetStockObject(GRAY\_BRUSH);
>
>     //为hbrBackground成员指定一个灰色画刷句柄
> 100. wndClass.lpszMenuName = NULL;
>      //用一个以空终止的字符串，指定菜单资源的名字。
> 101. wndClass.lpszClassName = \_T(
>      "ForTheDreamOfGameDevelop"
>
>      );
>
>      //用一个以空终止的字符串，指定窗口类的名字。
> 103. if
>
>      ( !RegisterClassEx( &wndClass ) )
>
>      //设计完窗口后，需要对窗口类进行注册，这样才能创建该类型的窗口
> 104. return
>
>      -1;
> 106. HWND
>
>      hwnd = CreateWindow( \_T(
>
>      "ForTheDreamOfGameDevelop"
>
>      ),WINDOW\_TITLE,
>
>      //喜闻乐见的创建窗口函数CreateWindow
> 107. WS\_OVERLAPPEDWINDOW, CW\_USEDEFAULT, CW\_USEDEFAULT, WINDOW\_WIDTH,
> 108. WINDOW\_HEIGHT, NULL, NULL, hInstance, NULL );
>
> 111. //Direct3D资源的初始化，调用失败用messagebox予以显示
> 112. if
>
>      (!(S\_OK==Direct3D\_Init (hwnd,hInstance)))
> 113. {
> 114. MessageBox(hwnd, \_T(
>      "Direct3D初始化失败~！"
>
>      ), \_T(
>
>      "浅墨的消息窗口"
>
>      ), 0);
>
>      //使用MessageBox函数，创建一个消息窗口
> 115. }
> 116. PlaySound(L
>      "GameMedia\\Heart - 刺客信条.wav"
>
>      , NULL, SND\_FILENAME | SND\_ASYNC|SND\_LOOP);
>
>      //循环播放背景音乐
> 118. MoveWindow(hwnd,0,0,WINDOW\_WIDTH,WINDOW\_HEIGHT,
>      true
>
>      );
>
>      //调整窗口显示时的位置，窗口左上角位于屏幕坐标（200，10）处
> 119. ShowWindow( hwnd, nShowCmd );
>      //调用Win32函数ShowWindow来显示窗口
> 120. UpdateWindow(hwnd);
>      //对窗口进行更新，就像我们买了新房子要装修一样
>
> 123. //消息循环过程
> 124. MSG msg = { 0 };
>      //初始化msg
> 125. while
>
>      ( msg.message != WM\_QUIT )
>
>      //使用while循环
> 126. {
> 127. static
>
>
>
>      FLOAT
>
>      fLastTime  = (
>
>      float
>
>      )::timeGetTime();
> 128. static
>
>
>
>      FLOAT
>
>      fCurrTime  = (
>
>      float
>
>      )::timeGetTime();
> 129. static
>
>
>
>      FLOAT
>
>      fTimeDelta = 0.0f;
> 130. fCurrTime  = (
>      float
>
>      )::timeGetTime();
> 131. fTimeDelta = (fCurrTime - fLastTime) / 1000.0f;
> 132. fLastTime  = fCurrTime;
> 134. if
>
>      ( PeekMessage( &msg, 0, 0, 0, PM\_REMOVE ) )
>
>      //查看应用程序消息队列，有消息时将队列中的消息派发出去。
> 135. {
> 136. TranslateMessage( &msg );
>      //将虚拟键消息转换为字符消息
> 137. DispatchMessage( &msg );
>      //该函数分发一个消息给窗口程序。
> 138. }
> 139. else
> 140. {
> 141. Direct3D\_Update(hwnd,fTimeDelta);
>      //调用更新函数，进行画面的更新
> 142. Direct3D\_Render(hwnd,fTimeDelta);
>      //调用渲染函数，进行画面的渲染
> 143. }
> 144. }
> 146. UnregisterClass(\_T(
>      "ForTheDreamOfGameDevelop"
>
>      ), wndClass.hInstance);
> 147. return
>
>      0;
> 148. }
>
> 151. //-----------------------------------【WndProc( )函数】--------------------------------------
> 152. //  描述：窗口过程函数WndProc,对窗口消息进行处理
> 153. //------------------------------------------------------------------------------------------------
> 154. LRESULT
>
>      CALLBACK WndProc(
>
>      HWND
>
>      hwnd,
>
>      UINT
>
>      message,
>
>      WPARAM
>
>      wParam,
>
>      LPARAM
>
>      lParam )
>
>      //窗口过程函数WndProc
> 155. {
> 156. switch
>
>      ( message )
>
>      //switch语句开始
> 157. {
> 158. case
>
>      WM\_PAINT:
>
>      // 客户区重绘消息
> 159. Direct3D\_Render(hwnd,0.0f);
>      //调用Direct3D\_Render函数，进行画面的绘制
> 160. ValidateRect(hwnd, NULL);
>      // 更新客户区的显示
> 161. break
>
>      ;
>
>      //跳出该switch语句
> 163. case
>
>      WM\_KEYDOWN:
>
>      // 键盘按下消息
> 164. if
>
>      (wParam == VK\_ESCAPE)
>
>      // ESC键
> 165. DestroyWindow(hwnd);
>      // 销毁窗口, 并发送一条WM\_DESTROY消息
> 166. break
>
>      ;
> 167. case
>
>      WM\_DESTROY:
>
>      //窗口销毁消息
> 168. Direct3D\_CleanUp();
>      //调用Direct3D\_CleanUp函数，清理COM接口对象
> 169. PostQuitMessage( 0 );
>      //向系统表明有个线程有终止请求。用来响应WM\_DESTROY消息
> 170. break
>
>      ;
>
>      //跳出该switch语句
> 172. case
>
>      WM\_KEYUP:
> 173. if
>
>      (wParam == VK\_ESCAPE) PostQuitMessage(0);
> 174. break
>
>      ;
> 176. case
>
>      WM\_LBUTTONDOWN:
> 177. g\_LMBDown =
>      true
>
>      ;
> 178. break
>
>      ;
> 180. case
>
>      WM\_LBUTTONUP:
> 181. g\_LMBDown =
>      false
>
>      ;
> 182. break
>
>      ;
> 184. case
>
>      WM\_MOUSEMOVE:
> 185. g\_MouseX = LOWORD (lParam);
> 186. g\_MouseY = HIWORD (lParam);
> 187. break
>
>      ;
>
> 190. default
>
>      :
>
>      //若上述case条件都不符合，则执行该default语句
> 191. return
>
>      DefWindowProc( hwnd, message, wParam, lParam );
>
>      //调用缺省的窗口过程来为应用程序没有处理的窗口消息提供缺省的处理。
> 192. }
> 194. return
>
>      0;
>
>      //正常退出
> 195. }
>
> 198. //-----------------------------------【Direct3D\_Init( )函数】----------------------------------
> 199. //  描述：Direct3D初始化函数，进行Direct3D的初始化
> 200. //------------------------------------------------------------------------------------------------
> 201. HRESULT
>
>      Direct3D\_Init(
>
>      HWND
>
>      hwnd,
>
>      HINSTANCE
>
>      hInstance)
> 202. {
> 204. //--------------------------------------------------------------------------------------
> 205. // 【Direct3D初始化四步曲之一，创接口】：创建Direct3D接口对象, 以便用该Direct3D对象创建Direct3D设备对象
> 206. //--------------------------------------------------------------------------------------
> 207. LPDIRECT3D9  pD3D = NULL;
>      //Direct3D接口对象的创建
> 208. if
>
>      ( NULL == ( pD3D = Direct3DCreate9( D3D\_SDK\_VERSION ) ) )
>
>      //初始化Direct3D接口对象，并进行DirectX版本协商
> 209. return
>
>      E\_FAIL;
> 211. //--------------------------------------------------------------------------------------
> 212. // 【Direct3D初始化四步曲之二,取信息】：获取硬件设备信息
> 213. //--------------------------------------------------------------------------------------
> 214. D3DCAPS9 caps;
>      int
>
>      vp = 0;
> 215. if
>
>      ( FAILED( pD3D->GetDeviceCaps( D3DADAPTER\_DEFAULT, D3DDEVTYPE\_HAL, &caps ) ) )
> 216. {
> 217. return
>
>      E\_FAIL;
> 218. }
> 219. if
>
>      ( caps.DevCaps & D3DDEVCAPS\_HWTRANSFORMANDLIGHT )
> 220. vp = D3DCREATE\_HARDWARE\_VERTEXPROCESSING;
>      //支持硬件顶点运算，我们就采用硬件顶点运算，妥妥的
> 221. else
> 222. vp = D3DCREATE\_SOFTWARE\_VERTEXPROCESSING;
>      //不支持硬件顶点运算，无奈只好采用软件顶点运算
> 224. //--------------------------------------------------------------------------------------
> 225. // 【Direct3D初始化四步曲之三，填内容】：填充D3DPRESENT\_PARAMETERS结构体
> 226. //--------------------------------------------------------------------------------------
> 227. D3DPRESENT\_PARAMETERS d3dpp;
> 228. ZeroMemory(&d3dpp,
>      sizeof
>
>      (d3dpp));
> 229. d3dpp.BackBufferWidth            = WINDOW\_WIDTH;
> 230. d3dpp.BackBufferHeight           = WINDOW\_HEIGHT;
> 231. d3dpp.BackBufferFormat           = D3DFMT\_A8R8G8B8;
> 232. d3dpp.BackBufferCount            = 2;
> 233. d3dpp.MultiSampleType            = D3DMULTISAMPLE\_NONE;
> 234. d3dpp.MultiSampleQuality         = 0;
> 235. d3dpp.SwapEffect                 = D3DSWAPEFFECT\_DISCARD;
> 236. d3dpp.hDeviceWindow              = hwnd;
> 237. d3dpp.Windowed                   =
>      true
>
>      ;
> 238. d3dpp.EnableAutoDepthStencil     =
>      true
>
>      ;
> 239. d3dpp.AutoDepthStencilFormat     = D3DFMT\_D24S8;
> 240. d3dpp.Flags                      = 0;
> 241. d3dpp.FullScreen\_RefreshRateInHz = 0;
> 242. d3dpp.PresentationInterval       = D3DPRESENT\_INTERVAL\_IMMEDIATE;
> 244. //--------------------------------------------------------------------------------------
> 245. // 【Direct3D初始化四步曲之四，创设备】：创建Direct3D设备接口
> 246. //--------------------------------------------------------------------------------------
> 247. if
>
>      (FAILED(pD3D->CreateDevice(D3DADAPTER\_DEFAULT, D3DDEVTYPE\_HAL,
> 248. hwnd, vp, &d3dpp, &g\_pd3dDevice)))
> 249. return
>
>      E\_FAIL;
>
> 252. //获取显卡信息到g\_strAdapterName中，并在显卡名称之前加上“当前显卡型号：”字符串
> 253. wchar\_t
>
>      TempName[60]=L
>
>      "当前显卡型号："
>
>      ;
>
>      //定义一个临时字符串，且方便了把"当前显卡型号："字符串引入我们的目的字符串中
> 254. D3DADAPTER\_IDENTIFIER9 Adapter;
>      //定义一个D3DADAPTER\_IDENTIFIER9结构体，用于存储显卡信息
> 255. pD3D->GetAdapterIdentifier(0,0,&Adapter);
>      //调用GetAdapterIdentifier，获取显卡信息
> 256. int
>
>      len = MultiByteToWideChar(CP\_ACP,0, Adapter.Description, -1, NULL, 0);
>
>      //显卡名称现在已经在Adapter.Description中了，但是其为char类型，我们要将其转为wchar\_t类型
> 257. MultiByteToWideChar(CP\_ACP, 0, Adapter.Description, -1, g\_strAdapterName, len);
>      //这步操作完成后，g\_strAdapterName中就为当前我们的显卡类型名的wchar\_t型字符串了
> 258. wcscat\_s(TempName,g\_strAdapterName);
>      //把当前我们的显卡名加到“当前显卡型号：”字符串后面，结果存在TempName中
> 259. wcscpy\_s(g\_strAdapterName,TempName);
>      //把TempName中的结果拷贝到全局变量g\_strAdapterName中，大功告成~
> 261. if
>
>      (!(S\_OK==Objects\_Init()))
>
>      return
>
>      E\_FAIL;
> 263. SAFE\_RELEASE(pD3D)
>      //LPDIRECT3D9接口对象的使命完成，我们将其释放掉
> 265. return
>
>      S\_OK;
> 266. }
>
> 269. //-----------------------------------【Object\_Init( )函数】--------------------------------------
> 270. //  描述：渲染资源初始化函数，在此函数中进行要被渲染的物体的资源的初始化
> 271. //--------------------------------------------------------------------------------------------------
> 272. HRESULT
>
>      Objects\_Init()
> 273. {
> 274. //创建字体
> 275. D3DXCreateFont(g\_pd3dDevice, 36, 0, 0, 1000,
>      false
>
>      , DEFAULT\_CHARSET,
> 276. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, \_T(
>      "Calibri"
>
>      ), &g\_pTextFPS);
> 277. D3DXCreateFont(g\_pd3dDevice, 20, 0, 1000, 0,
>      false
>
>      , DEFAULT\_CHARSET,
> 278. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, L
>      "华文中宋"
>
>      , &g\_pTextAdaperName);
> 279. D3DXCreateFont(g\_pd3dDevice, 23, 0, 1000, 0,
>      false
>
>      , DEFAULT\_CHARSET,
> 280. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, L
>      "微软雅黑"
>
>      , &g\_pTextHelper);
> 281. D3DXCreateFont(g\_pd3dDevice, 26, 0, 1000, 0,
>      false
>
>      , DEFAULT\_CHARSET,
> 282. OUT\_DEFAULT\_PRECIS, DEFAULT\_QUALITY, 0, L
>      "黑体"
>
>      , &g\_pTextInfor);
>
> 285. //设置纹理采样参数
> 286. g\_pd3dDevice->SetSamplerState(0, D3DSAMP\_MINFILTER, D3DTEXF\_NONE);
> 287. g\_pd3dDevice->SetSamplerState(0, D3DSAMP\_MAGFILTER, D3DTEXF\_NONE);
> 288. g\_pd3dDevice->SetSamplerState(0, D3DSAMP\_MIPFILTER, D3DTEXF\_NONE);
>
> 291. //-----------------------------------【GUI系统相关代码】-------------------------------
> 292. // 创建GUI系统
> 293. g\_gui =
>      new
>
>      D3DGUIClass(g\_pd3dDevice, WINDOW\_WIDTH, WINDOW\_HEIGHT);
> 294. if
>
>      (!g\_gui)
>
>      return
>
>
>
>      false
>
>      ;
> 296. // 添加背景图片
> 297. if
>
>      (!g\_gui->AddBackground(L
>
>      "GameMedia\\Assassins creed.jpg"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 299. // 添加字体
> 300. if
>
>      (!g\_gui->CreateTextFont(L
>
>      "微软雅黑"
>
>      , 28, &g\_FontID))
>
>      return
>
>
>
>      false
>
>      ;
>
> 303. // 添加静态文本到GUI中
> 304. if
>
>      (!g\_gui->AddStaticText(STATIC\_ID\_1, L
>
>      "Version 浅墨1.0版"
>
>      ,
> 305. 1170, 735, D3DCOLOR\_XRGB(55,155,255), g\_FontID))
>      return
>
>
>
>      false
>
>      ;
> 307. if
>
>      (!g\_gui->AddStaticText(STATIC\_ID\_2, L
>
>      "浅墨DirectX教程第三季 之 打造游戏GUI界面"
>
>      ,
> 308. 500, 10, D3DCOLOR\_XRGB(255,255,255), g\_FontID))
>      return
>
>
>
>      false
>
>      ;
>
> 311. // 添加4个按钮，分别是开始游戏，载入进度，选项和退出游戏，每个按钮对应3幅图
> 312. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_1, 650, 340, L
>
>      "GameMedia\\startUp.png"
>
>      ,
> 313. L
>      "GameMedia\\StartOver.png"
>
>      , L
>
>      "GameMedia\\startDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 315. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_2, 650, 385, L
>
>      "GameMedia\\loadUp.png"
>
>      ,
> 316. L
>      "GameMedia\\loadOver.png"
>
>      , L
>
>      "GameMedia\\loadDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 318. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_3, 650, 430, L
>
>      "GameMedia\\optionsUp.png"
>
>      ,
> 319. L
>      "GameMedia\\optionsOver.png"
>
>      , L
>
>      "GameMedia\\optionsDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 321. if
>
>      (!g\_gui->AddButton(BUTTON\_ID\_4, 650, 475, L
>
>      "GameMedia\\quitUp.png"
>
>      ,
> 322. L
>      "GameMedia\\quitOver.png"
>
>      , L
>
>      "GameMedia\\quitDown.png"
>
>      ))
>
>      return
>
>
>
>      false
>
>      ;
> 324. return
>
>      S\_OK;
> 325. }
>
> 328. void
>
>      GUICallback(
>
>      int
>
>      id,
>
>      int
>
>      state)
> 329. {
> 330. switch
>
>      (id)
> 331. {
> 332. case
>
>      BUTTON\_ID\_1:
> 333. //“开始游戏”按钮的相关代码实现
> 334. break
>
>      ;
> 335. case
>
>      BUTTON\_ID\_2:
> 336. //“载入游戏”按钮的相关代码实现
> 337. break
>
>      ;
> 338. case
>
>      BUTTON\_ID\_3:
> 339. //“选项”按钮的相关代码实现
> 340. break
>
>      ;
> 341. case
>
>      BUTTON\_ID\_4:
> 342. //如果点击了退出按钮，就退出程序
> 343. if
>
>      (state == UGP\_BUTTON\_DOWN) PostQuitMessage(0);
> 344. break
>
>      ;
> 345. }
> 346. }
>
> 349. //-----------------------------------【Direct3D\_Update( )函数】--------------------------------
> 350. //  描述：不是即时渲染代码但是需要即时调用的，如按键后的坐标的更改，都放在这里
> 351. //--------------------------------------------------------------------------------------------------
> 352. void
>
>      Direct3D\_Update(
>
>      HWND
>
>      hwnd,
>
>      FLOAT
>
>      fTimeDelta)
> 353. {
> 354. //GUI的实现暂时不需要在这里写代码
> 355. }
>
>
> 359. //-----------------------------------【Direct3D\_Render( )函数】-------------------------------
> 360. //  描述：使用Direct3D进行渲染
> 361. //--------------------------------------------------------------------------------------------------
> 362. void
>
>      Direct3D\_Render(
>
>      HWND
>
>      hwnd,
>
>      FLOAT
>
>      fTimeDelta)
> 363. {
> 364. //--------------------------------------------------------------------------------------
> 365. // 【Direct3D渲染五步曲之一】：清屏操作
> 366. //--------------------------------------------------------------------------------------
> 367. g\_pd3dDevice->Clear(0, NULL, D3DCLEAR\_TARGET|D3DCLEAR\_ZBUFFER|D3DCLEAR\_STENCIL, D3DCOLOR\_XRGB(100, 255, 255), 1.0f, 0);
> 369. //--------------------------------------------------------------------------------------
> 370. // 【Direct3D渲染五步曲之二】：开始绘制
> 371. //--------------------------------------------------------------------------------------
> 372. g\_pd3dDevice->BeginScene();
>      // 开始绘制
> 374. //--------------------------------------------------------------------------------------
> 375. // 【Direct3D渲染五步曲之三】：正式绘制
> 376. //--------------------------------------------------------------------------------------
>
> 379. // 处理和渲染GUI系统
> 380. ProcessGUI(g\_gui, g\_LMBDown, g\_MouseX, g\_MouseY, GUICallback);
> 382. //-----------------------------【绘制文字信息】-----------------------------
> 383. HelpText\_Render(hwnd);
>
> 386. //--------------------------------------------------------------------------------------
> 387. // 【Direct3D渲染五步曲之四】：结束绘制
> 388. //--------------------------------------------------------------------------------------
> 389. g\_pd3dDevice->EndScene();
>      // 结束绘制
> 390. //--------------------------------------------------------------------------------------
> 391. // 【Direct3D渲染五步曲之五】：显示翻转
> 392. //--------------------------------------------------------------------------------------
> 393. g\_pd3dDevice->Present(NULL, NULL, NULL, NULL);
>      // 翻转与显示
> 395. }
>
> 398. //-----------------------------------【HelpText\_Render( )函数】-------------------------------
> 399. //  描述：封装了帮助信息的函数
> 400. //--------------------------------------------------------------------------------------------------
> 401. void
>
>      HelpText\_Render(
>
>      HWND
>
>      hwnd)
> 402. {
> 403. //定义一个矩形，用于获取主窗口矩形
> 404. RECT formatRect;
> 405. GetClientRect(hwnd, &formatRect);
> 407. //在窗口右上角处，显示每秒帧数
> 408. formatRect.top = 5;
> 409. int
>
>      charCount = swprintf\_s(g\_strFPS, 20, \_T(
>
>      "FPS:%0.3f"
>
>      ), Get\_FPS() );
> 410. g\_pTextFPS->DrawText(NULL, g\_strFPS, charCount , &formatRect, DT\_TOP | DT\_RIGHT, D3DCOLOR\_RGBA(0,239,136,255));
> 412. //显示显卡类型名
> 413. g\_pTextAdaperName->DrawText(NULL,g\_strAdapterName, -1, &formatRect,
> 414. DT\_TOP | DT\_LEFT, D3DXCOLOR(1.0f, 0.5f, 0.0f, 1.0f));
> 415. }
>
> 418. //-----------------------------------【Get\_FPS( )函数】------------------------------------------
> 419. //  描述：用于计算每秒帧速率的一个函数
> 420. //--------------------------------------------------------------------------------------------------
> 421. float
>
>      Get\_FPS()
> 422. {
> 424. //定义四个静态变量
> 425. static
>
>
>
>      float
>
>      fps = 0;
>
>      //我们需要计算的FPS值
> 426. static
>
>
>
>      int
>
>      frameCount = 0;
>
>      //帧数
> 427. static
>
>
>
>      float
>
>      currentTime =0.0f;
>
>      //当前时间
> 428. static
>
>
>
>      float
>
>      lastTime = 0.0f;
>
>      //持续时间
> 430. frameCount++;
>      //每调用一次Get\_FPS()函数，帧数自增1
> 431. currentTime = timeGetTime()\*0.001f;
>      //获取系统时间，其中timeGetTime函数返回的是以毫秒为单位的系统时间，所以需要乘以0.001，得到单位为秒的时间
> 433. //如果当前时间减去持续时间大于了1秒钟，就进行一次FPS的计算和持续时间的更新，并将帧数值清零
> 434. if
>
>      (currentTime - lastTime > 1.0f)
>
>      //将时间控制在1秒钟
> 435. {
> 436. fps = (
>      float
>
>      )frameCount /(currentTime - lastTime);
>
>      //计算这1秒钟的FPS值
> 437. lastTime = currentTime;
>      //将当前时间currentTime赋给持续时间lastTime，作为下一秒的基准时间
> 438. frameCount    = 0;
>      //将本次帧数frameCount值清零
> 439. }
> 441. return
>
>      fps;
> 442. }
>
>
> 446. //-----------------------------------【Direct3D\_CleanUp( )函数】--------------------------------
> 447. //  描述：对Direct3D的资源进行清理，释放COM接口对象
> 448. //---------------------------------------------------------------------------------------------------
> 449. void
>
>      Direct3D\_CleanUp()
> 450. {
> 451. //释放COM接口对象
> 452. SAFE\_RELEASE(g\_pd3dDevice);
> 453. SAFE\_RELEASE(g\_pTextFPS)
> 454. SAFE\_RELEASE(g\_pd3dDevice)
> 455. SAFE\_DELETE(g\_gui)
> 456. }
>
> 那么，最后一起看看运行截图吧：
>
> ![](https://img-blog.csdn.net/20131117204150921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 鼠标悬停在options按钮之上，可以发现按钮“下陷”了
>
> ![](https://img-blog.csdn.net/20131117204220218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> 点击quit按钮，游戏程序便会退出：
>
> ![](https://img-blog.csdn.net/20131117204755921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)