---
layout: post
title: "MySQL索引作用底层数据结构常见问题"
date: 2025-03-05 13:56:53 +0800
description: "类似于目录，能够提高查询的速度，会占用更多的空间，也可能会拖慢增删改的速度默认情况下，进行条件查询，就是遍历表，一条一条都带入条件引入索引，引入额外的数据结构，加快查询的速度，减少遍历表的可能性（2）创建索引（危险操作）（3）删除索引（危险操作）Q1：为啥创建和删除索引都是危险操作？A：因为这里的操作都会涉及大量的IO，就可能把MySQL主机搞挂了Q2:那怎么给以及包含大量数据的表添加索引？A：部署新的服务器，用新的代替旧的数据库MySQL有类似弱类型语言的特性Q1：什么是强类型和"
keywords: "【MySQL】索引|作用|底层数据结构|常见问题"
categories: ['Mysql']
tags: ['数据库', 'Mysql']
artid: "146036644"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146036644
    alt: "MySQL索引作用底层数据结构常见问题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146036644
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146036644
cover: https://bing.ee123.net/img/rand?artid=146036644
image: https://bing.ee123.net/img/rand?artid=146036644
img: https://bing.ee123.net/img/rand?artid=146036644
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【MySQL】索引|作用|底层数据结构|常见问题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <h3>
     1.概念
    </h3>
    <p>
     类似于目录，能够提高查询的速度，会占用更多的空间，也可能会拖慢增删改的速度
    </p>
    <hr/>
    <h3 id="2.%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5" name="2.%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5">
     2.为何引入
    </h3>
    <p>
     默认情况下，进行条件查询，就是遍历表，一条一条都带入条件
    </p>
    <p>
     引入索引，引入额外的数据结构，加快查询的速度，减少遍历表的可能性
    </p>
    <hr/>
    <h3 id="3.%E4%BD%BF%E7%94%A8" name="3.%E4%BD%BF%E7%94%A8">
     3.使用
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95" name="%EF%BC%881%EF%BC%89%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95">
     （1）查看索引
    </h4>
    <pre><code class="hljs">show index from 表名;</code></pre>
    <h4 id="%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8D%B1%E9%99%A9%E6%93%8D%E4%BD%9C%EF%BC%89" name="%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8D%B1%E9%99%A9%E6%93%8D%E4%BD%9C%EF%BC%89">
     （2）创建索引（危险操作）
    </h4>
    <pre><code class="hljs">create index 索引名 on 表名（列名）;</code></pre>
    <h4 id="%EF%BC%883%EF%BC%89%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8D%B1%E9%99%A9%E6%93%8D%E4%BD%9C%EF%BC%89" name="%EF%BC%883%EF%BC%89%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%EF%BC%88%E5%8D%B1%E9%99%A9%E6%93%8D%E4%BD%9C%EF%BC%89">
     （3）删除索引（危险操作）
    </h4>
    <pre><code class="hljs">drop index 索引名 on 表名;</code></pre>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q1
      </span>
     </span>
     ：为啥创建和删除索引都是危险操作？
    </p>
    <p>
     A：因为这里的操作都会涉及大量的IO，就可能把MySQL主机搞挂了
    </p>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q2
      </span>
     </span>
     :那怎么给以及包含大量数据的表添加索引？
    </p>
    <p>
     A：部署新的服务器，用新的代替旧的数据库
    </p>
    <p>
    </p>
    <p>
     MySQL有类似弱类型语言的特性
    </p>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q1
      </span>
     </span>
     ：什么是强类型和弱类型语言？
    </p>
    <p>
     A：弱类型：数据类型转换不那么严格（自动转换类型）
    </p>
    <p>
     强类型：不能自动转换类型
    </p>
    <p>
     eg：
    </p>
    <pre><code class="hljs"> 2 + "3" 如果可以直接相加，那么就是弱类型，否则为强类型</code></pre>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q2
      </span>
     </span>
     ：什么是动态语言和静态语言？
    </p>
    <p>
     A：动态语言：变量的数据类型在运行时才能确定，即变量在声明时不需要指定数据类型，程序在运行过程中会根据变量被赋予的值来确定其类型
    </p>
    <p>
     静态语言：编译时就必须确定
    </p>
    <p>
     eg：int 类型程序运行过程中，变量的类型通常不能改变，那么就是静态语言，否则就是动态语言
    </p>
    <hr/>
    <h3 id="4.%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" name="4.%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">
     4.使用场景
    </h3>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q1
      </span>
     </span>
     ：如果考虑对数据库的某列/某几列创建索引，需要考虑哪些？
    </p>
    <p>
     A：
    </p>
    <p>
     （1）数据量大否？经常对这些列进行条件查询否？
    </p>
    <p>
     （2）数据库是否经常进行插入，修改操作？
    </p>
    <p>
     （3）索引可能会占用磁盘空间哦~
    </p>
    <p>
     （4）查询条件是否经常涉及排序？
    </p>
    <p>
     如果是非条件查询，或者经常做插入，修改操作，或者磁盘空间不足，就不考虑创建索引了
    </p>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q2
      </span>
     </span>
     ：什么样的查询，能够命中索引？
    </p>
    <p>
     大前提：查询的条件和创建的索引的列是匹配的
    </p>
    <hr/>
    <h3 id="%F0%9F%94%A55.%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89" name="%F0%9F%94%A55.%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89" style="background-color:transparent">
     <a href="https://blog.csdn.net/qq_73017178/article/details/145962267?spm=1001.2014.3001.5501#t3" title="🔥">
      🔥
     </a>
     5.底层数据结构（核心）
    </h3>
    <p>
     查询优化，首先想到
     <strong>
      树
     </strong>
     和
     <strong>
      哈希表
     </strong>
    </p>
    <p>
     （1）树
    </p>
    <p>
     <strong>
      Q1：二叉树 / 二叉搜索树？
     </strong>
    </p>
    <p>
     A1：
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       二叉树
      </span>
     </span>
     ：
    </p>
    <p>
     &lt;1&gt;
     <strong>
      无序
     </strong>
     ：查找特定节点时，需要遍历所有节点
    </p>
    <p>
     &lt;2&gt;随机排布：最坏情况直接
     <strong>
      退化成链表
     </strong>
     ，查找效率低O(N)
    </p>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       二叉搜索树
      </span>
     </span>
     ：虽然二叉搜索树对节点的排列有一定规则，即左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值，但是
    </p>
    <p>
     &lt;1&gt;如果元素有序：直接
     <strong>
      退化成链表
     </strong>
     ，查找效率低O(N)
    </p>
    <p>
     &lt;2&gt;树高度越高，I
     <strong>
      O操作越多
     </strong>
     （数据库的数据通常存储在磁盘上，而磁盘 I/O 操作的速度相对较慢）
    </p>
    <p>
     <strong>
      Q2：那 AVL树  /  红黑树呢？
     </strong>
    </p>
    <p>
     首先我们考虑一下
    </p>
    <p>
     <strong>
      Q3：为啥TreeMap / TreeSet不用AVL树，而用红黑树呢？
     </strong>
    </p>
    <p>
     A3：
    </p>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       AVL树
      </span>
     </span>
     ：是一个非常严格的平衡二叉搜索树（要求任意节点，左右子树高度差不能超过1）
    </p>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       红黑树
      </span>
     </span>
     ：本质是一个没有那么严格的平衡二叉搜索树（要求更宽松）
    </p>
    <p>
     那么显而易见，当你要求非常严格的时候，随便进行一些增删改操作，都可能会破坏平衡，从而触发旋转（每次旋转，都是有开销的）
    </p>
    <p>
     <strong>
      总结
     </strong>
     一下就是：
     <strong>
      红黑树要求更宽松，触发旋转概率低，虽然没有AVL树那么平衡，但是查找速度并没有差多少
     </strong>
    </p>
    <p>
     A2：那么对于Q2问题，我们out AVL树，再来看红黑树，
     <strong>
      红黑树相较于哈希表可以进行范围查询
     </strong>
     ，但是还是不太行
    </p>
    <p>
     &lt;1&gt; 红黑树还是二叉搜索树，那么
     <strong>
      树的高度越高，查询效率就越低
     </strong>
     （数的高度每增加一层，比较次数就增加1，数据库的数据/索引都是保存在硬盘上的，上述每一次比较，就需要一次硬盘IO操作）
    </p>
    <p>
     &lt;2&gt; 在红黑树中，找到中序遍历的下一个
     <strong>
      后续元素
     </strong>
     ，不高效，很有可能需要往父节点上一系列回溯，才能找到后继（不过这个好解决，可以通过“
     <strong>
      线索化
     </strong>
     ”的方式解决，简单理解就是每个节点加上后续节点的指针，但是需要付出更多的存储空间）
    </p>
    <p>
     （2）再来看查询O(1)的
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       哈希表
      </span>
     </span>
    </p>
    <p>
     虽然哈希表最坏时间复杂度为O（M）（M为链表最大长度，即哈希冲突时，把哈希值相同的元素存储在同一个链表中），但是哈希表有个致命的弱点
    </p>
    <p>
     只能查询相等情况，
     <strong>
      无法进行范围查询
     </strong>
     ，这样不适合数据库&lt; &gt;这样的范围查询
    </p>
    <hr/>
    <p>
     上面的结构都不是，那么还有什么呢？
     <br/>
     还有
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       B树
      </span>
     </span>
     （N叉搜索树）：
     <strong>
      每个节点上可存储多个元素
     </strong>
     ，延伸出多个子数（非常好的解决了红黑树数据多，数的高度变高的问题）
    </p>
    <p>
     <img alt="" height="306" src="https://i-blog.csdnimg.cn/direct/4eba3b2a3e104302a5d8187aef80ea73.png" width="694"/>
    </p>
    <p>
     每个方框是一个节点，每个数字代表一个key（或者是数据库中的一行记录），n个key，n+1个子树
    </p>
    <p>
     <strong>
      Q1：有人就说他每个节点（方框）中还需要拿着key进行比较，不应该效率很低吗？
     </strong>
    </p>
    <p>
     <strong>
      A1
     </strong>
     ：其实还是很高效的
    </p>
    <p>
     1）每个节点上的这些key也是有序排列的，比较的时候可以直接
     <strong>
      二分查找
     </strong>
     .
    </p>
    <p>
     2）B树也会控制，某个节点上保存的key不会太多，如果插入更多的元素，使key变多了，就会是节点
     <strong>
      分裂出更多树
     </strong>
     出来.
    </p>
    <p>
     3）多个数据，都是放在一块
     <strong>
      连续的存储空间
     </strong>
     上，进行比较的时候，一次硬盘IO就能读出整个节点，就可以直接完成上述比较.（进行多次比较，实际上只有一次硬盘IO）【硬盘IO操作较内存/CPU操作很慢】
    </p>
    <hr/>
    <p>
     但是最终MySQL索引底层还是没有采用B树，而是
     <span style="color:#be191c">
      <span style="background-color:#fff5e6">
       B+树
      </span>
     </span>
    </p>
    <p>
     <img alt="" height="471" src="https://i-blog.csdnimg.cn/direct/e88686d093b34c0096a5b8b03267ab42.png" width="827"/>
    </p>
    <p>
     <strong>
      特点：
     </strong>
    </p>
    <p>
     （1）N叉搜索树
    </p>
    <p>
     （2）每个父节点中的元素都会在子节点中以最大值的方式存在
    </p>
    <p>
     （3）叶子节点这一层通过链表连上
    </p>
    <p>
     <strong>
      Q：为什么不用B树（B+树好处）?
     </strong>
    </p>
    <p>
     <strong>
      A：
     </strong>
    </p>
    <p>
     （1）
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       方便遍历和范围查询
      </span>
     </span>
    </p>
    <p>
     好遍历整个表中的所有数据，也方便进行范围查询，叶子节点 即整个数据的全集+链表的链式结构（B树叶子节点没有这种链式节点）
    </p>
    <p>
    </p>
    <p>
     （2）
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       每一次操作都比较稳定
      </span>
     </span>
    </p>
    <p>
     任何一层操作，最终都是要落到叶子节点来完成的，那么查询任何数据，经历的硬盘IO次数都是一样的，查询操作消耗的时间都是一样的（但是
     <strong>
      B树可能在非叶子节点就查到
     </strong>
     了，虽然效率更高，但是有点时候查的快，有的时候慢，IO次数很大影响，不稳定）
    </p>
    <p>
     （3）
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       叶子节点保存全集，非叶子节点能够在内存中进行缓存（主键索引）
      </span>
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="543" src="https://i-blog.csdnimg.cn/img_convert/cbb3da11d2ff65af875f07c41f7ab276.png" width="1149"/>
    </p>
    <p>
     由于叶子节点，是数据的全集，对应的，非叶子节点中，都是重复出现的数据.
    </p>
    <p>
     就可以把表每一行的数据，最终都关联到叶子节点这一层.非叶子节点中只保存一个单纯的key值即可（id）
    </p>
    <blockquote>
     <p>
      数据库每一行有很多列：student(id, name, classld, gender, score.......)
     </p>
     <p>
      此时，比如使用id这一列来做索引.这里B+树的非叶子节点，都只需要保存一个id这样的值就行了
     </p>
     <p>
      到了叶子节点这里，每个叶子节点不光要保存id，还要把后续的name，classld 等信息也保存起来.
     </p>
     <p>
      咱们看到的“表格”只是一个逻辑上的结构
     </p>
     <p>
      实际上底层的结构，就是这个B+树的结构.
     </p>
     <p>
      就会按照主键的索引的这个B+树的叶子节点来保存每一行的数据～～
     </p>
    </blockquote>
    <p>
     如果你的表，创建主键了，自然是通过你创建的主键的索引的B+树来组织所有行.
    </p>
    <p>
     如果你没创建主键，mysql其实生成了一个
     <strong>
      隐藏的主键
     </strong>
     ，按照隐藏主键构造的树来组织.这样组织之后，非叶子节点占用的空间就比较小
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       （非叶子节点只存id）
      </span>
     </span>
     此时，
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       非叶子节点就可以缓存到内存
      </span>
     </span>
     中，这样查询速度又大大提高（当然，这份数据必然要在硬盘上也保存一份，为了提高查询速度，就可以把这部分结构放到内存中
    </p>
    <p>
     总结就是说
     <strong>
      B+树的非叶子节点只存储主键，可以缓存到内存，查询速度又大大提高，
     </strong>
     <strong>
      而B树存储就得把非主键信息也保存起来，占据的空间大
     </strong>
    </p>
    <hr/>
    <p>
     针对哪个列创建索引，就是针对哪个列构建B+树(前提是Innodb存储引擎，不同存储引擎，存储的数据结构不同）
    </p>
    <p>
     （1）主键索引：叶子节点是带有数据行
    </p>
    <p>
     如果查主键值，就从树根节点往下层一层一层擦查询
    </p>
    <p>
     如果查非主键值，遍历链表即可
    </p>
    <p>
     （2）非主键索引：叶子节点，只有主键Id，如果查到了主键id，那么就要回到主键索引再去查询一次（也就是回标）
    </p>
    <hr/>
    <h3 id="%F0%9F%94%A56.%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98" name="%F0%9F%94%A56.%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98">
     🔥6.经典问题
    </h3>
    <p>
     （1）为什么使用索引会加快查询？
    </p>
    <p>
     （2）能简单说一下索引的分类吗？
    </p>
    <p>
     （3）创建索引有哪些注意点？
    </p>
    <p>
     （4）索引哪些情况下会失效呢？
    </p>
    <p>
     （5）索引不适合哪些场景呢？
    </p>
    <p>
     （6）索引是不是建的越多越好？
    </p>
    <p>
     （7）为什么InnoDB要使用B+树作为索引？
    </p>
    <p>
     （8）为什么不用普通二叉树？
    </p>
    <p>
     （9）为什么用B+树而不用B树呢
    </p>
    <p>
     （10）Hash 索引和B+树索引区别
    </p>
    <p>
     （11）聚簇索引与非聚簇索引的区别
    </p>
    <p>
     （12）回表了解吗？
    </p>
    <p>
    </p>
    <p>
     <strong>
      回答思路：
     </strong>
    </p>
    <p>
     （1）全表扫描 与 磁盘IO
    </p>
    <p>
     （2）功能分 ，底层分 ，存储位置分
    </p>
    <p>
     （3）合适的列 + 不要太多 + 利用前缀索引和索引列的顺序
    </p>
    <p>
     （4）
    </p>
    <p>
     <img alt="" height="227" src="https://i-blog.csdnimg.cn/direct/d3032989c63645cebf77f64f4e735836.png" width="818"/>
    </p>
    <p>
     （5）数据少 、频繁更新的列
    </p>
    <p>
     （6）磁盘空间 + 索引可以提高效率，但是更新不方便了
    </p>
    <p>
     （7）二叉平衡树，红黑树，B树比较
    </p>
    <p>
     （8）退化为链表，无序遍历全表
    </p>
    <p>
     （9）结构（链表+子节点最大值）方便遍历和范围查询 + 非叶子节点缓存 + 稳定
    </p>
    <p>
     （10）
     <img alt="" height="210" src="https://i-blog.csdnimg.cn/direct/60cdf2ef324d4485b9031d3ce8517893.png" width="841"/>
    </p>
    <p>
     （11) 主键索引 VS 非主键索引
    </p>
    <p>
     （12）同（11）
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37333031373137382f:61727469636c652f64657461696c732f313436303336363434" class_="artid" style="display:none">
 </p>
</div>


