---
layout: post
title: "计算机视觉进阶教学之图像投影透视变换"
date: 2025-09-11T20:35:27+0800
description: "本文系统介绍了图像透视变换技术的原理与应用。透视变换通过3x3变换矩阵实现二维图像的视角转换，广泛应用于图像校正、虚拟现实等领域。文章以票据图像矫正为例，详细演示了OpenCV实现流程：包括轮廓检测、最大轮廓提取、四点透视变换等关键步骤。通过定义辅助函数实现坐标排序、宽高计算和图像缩放，最终将倾斜票据转换为正视图。该技术可有效解决图像视角变形问题，是计算机视觉领域的重要基础技术。"
keywords: "计算机视觉进阶教学之图像投影(透视)变换"
categories: ['未分类']
tags: ['计算机视觉', '人工智能']
artid: "151587573"
arturl: "https://blog.csdn.net/m0_74977182/article/details/151587573"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151587573
    alt: "计算机视觉进阶教学之图像投影透视变换"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151587573
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151587573
cover: https://bing.ee123.net/img/rand?artid=151587573
image: https://bing.ee123.net/img/rand?artid=151587573
img: https://bing.ee123.net/img/rand?artid=151587573
---



# 计算机视觉进阶教学之图像投影(透视)变换

---

## 简介

        在计算机视觉的进阶学习旅程中，图像投影（透视）变换是一座连接理论与实战的关键桥梁。无论是实现证件照的智能矫正、自动驾驶中道路场景的视角转*换，还是无人机航拍图*像的地理坐标映射，这一技术都扮演着不可或缺的核心角色。如果你曾困惑于 “为何倾斜拍摄的文档会出现边缘变形”“如何让二维图像呈现出三维空间的立体感”，或是在项目开发中急需解决图像视角转换的技术难题，那么本系列博客将为你提供系统性的解决方案。

## 一、了解图像投影(透视)变换

        图像的透视变换（Perspective Transformation）是一种在图像处理中广泛使用的技术，它通过模拟人眼或相机镜头观看三维空间物体时的透视效果，来改变图像的视角和形状。以下是对图像透视变换的详细解释：

### 一、定义与原理

        透视变换是一种非线性变换，它可以将一个二维坐标系中的点映射到三维坐标系中的点，然后再将其投影到另一个二维坐标系中的点。这种变换基于几何学中的透视原理，通过一个3x3的变换矩阵来实现，该矩阵作用于图像的每个像素坐标，从而进行坐标的映射转换。透视变换能够模拟真实世界中的透视效果，使物体看起来更接近、更远或者从不同角度观看。

### 二、应用场景

透视变换在图像处理和计算机视觉领域有着广泛的应用，包括但不限于以下几个方面：

        图像校正：通过透视变换可以修正由于视角引起的图像扭曲，如将拍摄的倾斜书本或建筑物照片校正为正视图。  
         图像合成：将两个图像中的物体或场景合成在一起，仿佛它们是从同一视角拍摄的。  
 虚拟现实（VR）和增强现实（AR）：在VR和AR应用中，透视变换用于模拟真实世界的视角和深度感，提升用户体验。  
         目标检测与跟踪：在目标检测和跟踪任务中，透视变换可以用于调整图像视角，以便更准确地识别和跟踪目标。  
         三维重建：在三维重建过程中，透视变换是连接二维图像与三维空间的关键技术之一。

### 三、实现方法

在OpenCV等图像处理库中，透视变换通常通过以下步骤实现：

        选择对应点：在原始图像和目标图像上分别选择四个非共线的对应点。这些点通常是图像中的显著特征点，如纸上的角落、建筑物的边缘等。  
         计算变换矩阵：使用OpenCV中的cv2.getPerspectiveTransform函数根据这些对应点计算透视变换矩阵。  
         应用变换矩阵：使用cv2.warpPerspective函数将计算得到的透视变换矩阵应用于原始图像，从而得到变换后的图像。

## 二、案例分析

**了解了枯燥的理论我们用下面这个案例来分析**

**实现对一个小票进行图像投影变换**

![](https://i-blog.csdnimg.cn/direct/aaa473560257492aa8ff7ecd4e66e2f7.png)

![](https://i-blog.csdnimg.cn/direct/0f561d5a89bc4dadaf26542a90c63cc1.png)

![](https://i-blog.csdnimg.cn/direct/32aa9e1d957b4b6380a2ee72d158c718.png)

#### 1. 辅助函数定义

##### 1.1.cv_show 函数

```
def cv_show(name, img):
    cv2.imshow(name, img)  # 显示图像，name是窗口名称，img是要显示的图像
    cv2.waitKey(0)  # 等待用户按键，0表示无限等待
```

这是一个简化图像显示操作的函数，封装了 OpenCV 的`imshow`和`waitKey`方法，方便在多个地方调用。

##### 1.2.order_points 函数

```
def order_points(pts):
    # 初始化一个4x2的矩阵存储排序后的坐标
    rect = np.zeros(shape=(4, 2), dtype="float32")
    
    # 按顺序找到对应坐标：左上，右上，右下，左下
    s = pts.sum(axis=1)  # 对每个点的x和y坐标求和
    rect[0] = pts[np.argmin(s)]  # 最小的和对应左上角(x+y最小)
    rect[2] = pts[np.argmax(s)]  # 最大的和对应右下角(x+y最大)
    
    diff = np.diff(pts, axis=1)  # 计算每个点的y-x差值
    rect[1] = pts[np.argmin(diff)]  # 最小的差值对应右上角(y-x最小)
    rect[3] = pts[np.argmax(diff)]  # 最大的差值对应左下角(y-x最大)
    
    return rect
```

这个函数用于对四边形的四个顶点进行排序，确保它们按 "左上→右上→右下→左下" 的顺序排列，为后续的透视变换做准备。

##### 1.3.four_point_transform 函数

```
def four_point_transform(image, pts):
    # 获取排序后的坐标点
    rect = order_points(pts)
    (tl, tr, br, bl) = rect  # 分别赋值给左上、右上、右下、左下
    
    # 计算宽度：取底部和顶部宽度的最大值
    widthA = np.sqrt(((br[0] - bl[0]) **2) + ((br[1] - bl[1])** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) **2) + ((tr[1] - tl[1])** 2))
    maxWidth = max(int(widthA), int(widthB))
    
    # 计算高度：取右侧和左侧高度的最大值
    heightA = np.sqrt(((tr[0] - br[0]) **2) + ((tr[1] - br[1])** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) **2) + ((tl[1] - bl[1])** 2))
    maxHeight = max(int(heightA), int(heightB))
    
    # 定义变换后的目标坐标
    dst = np.array([
        [0, 0],                  # 左上
        [maxWidth - 1, 0],       # 右上
        [maxWidth - 1, maxHeight - 1],  # 右下
        [0, maxHeight - 1]       # 左下
    ], dtype="float32")
    
    # 计算透视变换矩阵
    M = cv2.getPerspectiveTransform(rect, dst)
    # 应用透视变换
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))
    
    return warped
```

这是核心函数，实现了图像的透视变换，将倾斜的四边形区域转换为正面矩形视图，模拟了从不同角度拍摄的文档转换为正视图的效果。

##### 1.4.resize 函数

```
def resize(image, width=None, height=None, inter=cv2.INTER_AREA):
    dim = None  # 存储调整后的尺寸
    (h, w) = image.shape[:2]  # 获取原始图像的高度和宽度
    
    # 如果宽高都未指定，直接返回原图
    if width is None and height is None:
        return image
    
    # 如果宽度未指定，按高度比例缩放
    if width is None:
        r = height / float(h)  # 计算缩放比例
        dim = (int(w * r), height)  # 计算新的宽度
    # 否则按宽度比例缩放
    else:
        r = width / float(w)  # 计算缩放比例
        dim = (width, int(h * r))  # 计算新的高度
    
    # 执行缩放操作
    resized = cv2.resize(image, dim, interpolation=inter)
    return resized
```

这个函数用于按比例调整图像大小，避免图像过大处理困难或过小影响精度。

#### 2. 主程序执行流程

```
import cv2
import numpy as np

# 读取输入图像
image = cv2.imread('fapiao.jpg')
cv_show('image', image)  # 显示原始图像
```

##### 2.1.图像缩放处理

```
# 计算缩小比率（以高度为基准缩放到500像素）
ratio = image.shape[0] / 500.0
orig = image.copy()  # 保存原始图像副本
image = resize(orig, height=500)  # 按比例缩小图像
cv_show('1', image)  # 显示缩小后的图像
```

将图像按比例缩小到高度为 500 像素，便于后续处理，同时记录缩放比例，以便后期恢复原始尺寸。

##### 2.2.轮廓检测

```
print("STEP 1: 轮廓检测")
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # 转换为灰度图
# 自动阈值二值化处理（OTSU算法）
edged = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]
# 查找轮廓
cnts = cv2.findContours(edged.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)[-2]
# 绘制所有轮廓并显示
image_contours = cv2.drawContours(image.copy(), cnts, -1, color=(0, 0, 255), thickness=1)
cv_show('image_contours', image_contours)
```

这一步将图像转为灰度图，再通过二值化处理突出边缘，最后检测出图像中的所有轮廓。

##### 2.3.获取最大轮廓（文档边缘）

```
print("STEP 2: 获取最大轮廓")
# 按轮廓面积排序，取最大的那个（通常是文档的边缘）
screenCnt = sorted(cnts, key=cv2.contourArea, reverse=True)[0]
print(screenCnt.shape)  # 输出轮廓形状

# 轮廓近似（将不规则轮廓近似为多边形）
peri = cv2.arcLength(screenCnt, closed=True)  # 计算轮廓周长
# 用Douglas-Peucker算法近似轮廓，0.05*peri是近似精度
screenCnt = cv2.approxPolyDP(screenCnt, 0.05 * peri, closed=True)
print(screenCnt.shape)  # 输出近似后的轮廓形状

# 绘制最大轮廓并显示
image_contour = cv2.drawContours(image.copy(), [screenCnt], -1, color=(0, 255, 0), thickness=2)
cv2.imshow("image_contour", image_contour)
cv2.waitKey(0)
```

文档通常是图像中面积最大的矩形物体，所以这里通过面积排序找到最大轮廓，并通过轮廓近似算法将其转换为四边形。

##### 2.4.透视变换并保存结果

```
# 应用四点透视变换，注意要将坐标还原到原始图像尺寸
warped = four_point_transform(orig, screenCnt.reshape(4, 2) * ratio)
# 保存变换后的图像
cv2.imwrite(filename='invoice_new.jpg', img=warped)
# 显示变换后的图像
cv2.namedWindow('xx', cv2.WINDOW_NORMAL)  # 创建可调整大小的窗口
cv2.imshow("xx", mat=warped)
cv2.waitKey(0)
```

#### 3.总结

整个程序的核心思想是：

1. 读取图像并适当缩放
2. 通过图像处理技术找到文档的边缘轮廓
3. 利用透视变换将倾斜的文档转换为正视图
4. 保存和显示处理结果

最后我们还可以通过之前学习的旋转、阈值处理和图像形态学等让图片中的文字更加突出

```
import cv2
import numpy as np


img=cv2.imread('invoice_new.jpg')
img=cv2.resize(img,dsize=None,fx=0.4,fy=0.4)
rotated_image1 = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
cv2.imshow('ni90',rotated_image1)
cv2.waitKey(0)

ret, binary = cv2.threshold(rotated_image1,  125,   255, cv2.THRESH_BINARY)
cv2.imshow(  'binary', binary) # 偏白的变纯白，偏黑的变纯黑
cv2.waitKey(0)

kernel = np.ones((2,2),np.uint8)  # 这里kernel大小，修改为5*5试试
erosion_1 = cv2.erode(binary,kernel,iterations=1)  #iterations改为5试试
cv2.imshow('erosion_1',erosion_1)
cv2.waitKey(0)
```



