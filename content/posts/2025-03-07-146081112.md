---
layout: post
title: "Linux-进程间通信"
date: 2025-03-07 18:36:39 +0800
description: "本文主要对进程间通信的目的和本质做了简单介绍，而后针对 管道和System V IPC 两种方式做了较为详尽的介绍，并提供了部分代码做特性测试，帮助您更好的理解本部分知识"
keywords: "Linux 进程间通信"
categories: ['Linux']
tags: ['Linux']
artid: "146081112"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146081112
    alt: "Linux-进程间通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146081112
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146081112
cover: https://bing.ee123.net/img/rand?artid=146081112
image: https://bing.ee123.net/img/rand?artid=146081112
img: https://bing.ee123.net/img/rand?artid=146081112
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux 进程间通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%20%E7%9B%AE%E7%9A%84" name="1.%20%E7%9B%AE%E7%9A%84">
     1. 目的
    </h2>
    <p>
     ·
     <strong>
      数据传输
     </strong>
     ：一个进程需要将它的数据发送给另一个进程
    </p>
    <p>
     <strong>
      ·
     </strong>
     <strong>
      资源共享
     </strong>
     ：多个进程之间共享同样的资源
    </p>
    <p>
     <strong>
      · 事件通知
     </strong>
     ：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时通知父进程）
    </p>
    <p>
     <strong>
      · 进程控制：
     </strong>
     有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       本质：让不同的进程，看到同一份资源！
      </strong>
     </span>
    </p>
    <h2 id="2.%20%E7%AE%A1%E9%81%93%C2%A0" name="2.%20%E7%AE%A1%E9%81%93%C2%A0">
     2. 管道
    </h2>
    <h3 id="2.1%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%C2%A0" name="2.1%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%C2%A0">
     2.1 核心原理
    </h3>
    <p>
     <img alt="" height="780" src="https://i-blog.csdnimg.cn/direct/40b6dc2787db44d584aeadd9250b7520.png" width="2217">
      <span style="color:#1c7331">
       <strong>
        所以，内核文件系统的设计管理本身就可以做到：让不同的进程，看到同一份资源。
       </strong>
      </span>
     </img>
    </p>
    <p>
     <span style="color:#ff9900">
      <strong>
       我们把从一个进程连接到另一个进程的一个 数据流 称为一个 “管道”。
      </strong>
     </span>
    </p>
    <h3 id="2.2%C2%A0%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93" name="2.2%C2%A0%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93">
     2.2 匿名管道
    </h3>
    <p>
     使用系统接口，基于内核创建管理的一种
     <span style="color:#1c7331">
      “
      <strong>
       内核级文件
      </strong>
      ”
     </span>
     ，本质是一个
     <span style="color:#1c7331">
      <strong>
       内核缓冲区
      </strong>
     </span>
     ，进程通过读写这个缓冲区实现通信。
    </p>
    <pre><code class="language-cpp">#include &lt;unistd.h&gt;

       int pipe(int pipefd[2]);</code></pre>
    <p>
     输出型参数：pipefd文件描述符数组：
     <span style="color:#1c7331">
      <strong>
       pipefd[0]读端
      </strong>
     </span>
     ，
     <strong>
      <span style="color:#1c7331">
       pipefd[1]写端
      </span>
     </strong>
    </p>
    <p>
     成功返回0； 失败返回-1， 错误码被设置
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       只能
      </strong>
     </span>
     用于具有
     <span style="color:#fe2c24">
      <strong>
       “亲缘关系”
      </strong>
     </span>
     的进程之间，
     <strong>
      通常用于父子进程
     </strong>
     ，因为子进程继承拷贝了父进程的大部分内核数据结构信息，这其中就 包括所打开的文件信息（fd_arry）。
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       四种情况：（命名管道也一样）
      </strong>
     </span>
    </p>
    <p>
     <strong>
      1.
     </strong>
     管道内没有数据 &amp;&amp; 写端不关闭：读端阻塞等待
    </p>
    <p>
     <strong>
      2.
     </strong>
     管道内被写满 &amp;&amp; 读端不关闭 ： 写端阻塞等待
    </p>
    <p>
     <strong>
      3.
     </strong>
     写端关闭，读端可以继续读取管道内的数据，直到读完
    </p>
    <p>
     <strong>
      4.
     </strong>
     读端关闭 &amp;&amp; 写端尝试写入，OS发送异常信号（13）直接终止写端进程
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       五种特性：
      </strong>
     </span>
    </p>
    <p>
     <strong>
      1.
     </strong>
     用于具有亲缘关系的进程间
    </p>
    <p>
     <strong>
      2.
     </strong>
     单向性 （命名管道同）
    </p>
    <p>
     <strong>
      3.
     </strong>
     面向字节流（命名管道同）
    </p>
    <p>
     <strong>
      4. 自带同步机制（即上述的 “四种情况”）（命名管道同）
     </strong>
    </p>
    <p>
     <strong>
      5.
     </strong>
     生命周期随进程，临时性
    </p>
    <p>
     <strong>
      补充：
     </strong>
     默认管道大小通常是64KB，系统全局最大管道大小可以通过 /proc/sys/pipe-max-size 进行调整；也可以在创建管道后，使用 fcntl 系统调用动态调整管道的大小。
    </p>
    <p>
     <strong>
      为什么要有大小限制？
     </strong>
    </p>
    <p>
     首先是 为了
     <strong>
      避免资源耗尽
     </strong>
     ，若不限制管道的大小，多个进程可能消耗大量内存，导致系统不稳定 。
    </p>
    <p>
     其次是 为了
     <strong>
      平衡速度与内存
     </strong>
     ：适当的管道大小可以在速度和内存占用之间找到平衡。
    </p>
    <p>
     <strong>
      所以，设置合适的管道大小，有助于提高进程间的通信效率，避免不必要的阻塞。
     </strong>
    </p>
    <p>
     <a class="link-info" href="https://gitee.com/a-clear-meaning/linux/blob/master/proc-commun/pipeline/unnamed/pipe.hpp" rel="nofollow" title="相关的测试代码获取可点击：前往我的代码仓库！ ">
      相关的测试代码获取可点击：前往我的代码仓库！
     </a>
    </p>
    <h3 id="2.3%C2%A0%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%C2%A0" name="2.3%C2%A0%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%C2%A0">
     2.3 命名管道
    </h3>
    <p>
     <span style="color:#1c7331">
      <strong>
       磁盘级文件，但是不能持久化存储数据。
      </strong>
     </span>
    </p>
    <p>
     它可以
     <span style="color:#fe2c24">
      <strong>
       让没有 “亲缘关系” 的进程间也能通信
      </strong>
     </span>
     。
    </p>
    <p>
     <strong>
      创建：
     </strong>
    </p>
    <p>
     1. 系统的指令工具：mkfifo
    </p>
    <p>
     2. C 库函数：
    </p>
    <pre><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

       int mkfifo(const char *pathname, mode_t mode);
</code></pre>
    <p>
     成功返回0； 失败返回-1， 错误码被设置。
    </p>
    <p>
     在操作上，和 匿名管道不同的是：
     <strong>
      命名管道的打开规则（open）
     </strong>
    </p>
    <p>
     通常，如果不设置 O_NONBLOCK 参数：
    </p>
    <p>
     <strong>
      写端先启动，阻塞等待 直到有写端打开时才同步打开此管道
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#ffd900">
       读端先启动
      </span>
      ，
     </strong>
     读端进程阻塞，等待写端进程打开管道；此时启动写端进程，由于读端已经阻塞，导致写端进程也卡住，等待读端准备好读取数据 —— 这是典型的
     <span style="color:#fe2c24">
      死锁
     </span>
     情况：读写端互相等待，导致两个进程都
     <strong>
      无法继续执行
     </strong>
     。
    </p>
    <p>
     解决方式：1. 写端先open
    </p>
    <p>
     2. 设置非阻塞参数： O_NONBLOCK
    </p>
    <p>
     3. 设置管道超时机制
    </p>
    <p>
     ......
    </p>
    <p>
     <a class="link-info" href="https://gitee.com/a-clear-meaning/linux/tree/master/proc-commun/pipeline/named" rel="nofollow" title="   相关代码测试获取可点击：前往我的仓库！">
      相关代码测试获取可点击：前往我的仓库！
     </a>
    </p>
    <h2 id="3.%20System%20V%20IPC" name="3.%20System%20V%20IPC">
     3. System V IPC
    </h2>
    <h3 id="3.1%20%E7%AE%80%E4%BB%8B" name="3.1%20%E7%AE%80%E4%BB%8B">
     3.1 简介
    </h3>
    <p>
     <span style="color:#fe2c24">
      <strong>
       用于在不同进程之间交换数据 或 同步 的机制！
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       同步
      </strong>
     </span>
     和
     <span style="color:#fe2c24">
      <strong>
       异步
      </strong>
     </span>
     是计算机科学和编程中的常见概念，主要用于描述
     <span style="color:#1c7331">
      <strong>
       任务执行的方式
      </strong>
     </span>
     以及
     <span style="color:#1c7331">
      <strong>
       程序流控制
      </strong>
     </span>
    </p>
    <p>
     <strong>
      同步（Synchronous）
     </strong>
     :
     <strong>
      【阻塞式执行】
     </strong>
     任务按照顺序执行，一个任务必须等待前一个任务完成后才能继续，确保多个进程访问共享资源 的
     <span style="color:#956fe7">
      原子性操作【某个操作，只有两种状态，要么还没开始，要么已经结束】
     </span>
     ，
     <strong>
      防止资源竞争和数据冲突
     </strong>
     。
    </p>
    <p>
     <strong>
      异步（Asynchronous）:
     </strong>
     任务可以
     <strong>
      并行或非阻塞执行
     </strong>
     ，不需要等待前一个任务完成；
     <strong>
      提高效率，减少等待时间
     </strong>
     ，但是代码
     <strong>
      复杂度增加，难以调试和控制程序流 。
     </strong>
    </p>
    <p>
     <strong>
      场景：
     </strong>
    </p>
    <p>
     <strong>
     </strong>
     同步：文件读写，小型脚本，CLI命令，...
    </p>
    <p>
     异步：网络请求，GUI事件处理，服务器处理多用户请求，...
    </p>
    <p>
     在实际开发中，同步和异步通常结合使用，根据具体的场景才能选择合适的方案。
    </p>
    <p>
     <strong>
      回到正题：
     </strong>
    </p>
    <p>
     <strong>
      System V IPC
     </strong>
     是一套独立于文件系统的通信机制，通过
     <strong>
      内核维护IPC对象资源
     </strong>
     在进程间进行通信，所以，
     <strong>
      即使进程终止，IPC对象仍然可以保留在内核中，直到显示删除
     </strong>
     ；它在一定程度上，避免了传统文件系统操作带来的性能开销，适合高效的进程间数据交换和同步。
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       它包括：共享内存，消息队列，信号量
      </strong>
     </span>
    </p>
    <p>
     接下来，以共享内存为重点讲解，其它次之来分别介绍
    </p>
    <h3 id="3.2%20%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88Shared%C2%A0%20Memory%EF%BC%89" name="3.2%20%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88Shared%C2%A0%20Memory%EF%BC%89">
     3.2 共享内存（Shared  Memory）
    </h3>
    <p>
     <span style="color:#956fe7">
      <strong>
       基于内存段，直接映射到进程的地址空间，数据在内存中传递（双向，可读可写），减少了内核态与用户态切换以及数据拷贝，速度快，传输量大
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       操作：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       1. 创建/获取
      </strong>
     </span>
     <img alt="" height="1137" src="https://i-blog.csdnimg.cn/direct/378d766b17454761a24719be1f91ff0b.png" width="2337"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       2. 映射到进程的地址空间/解除映射
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="756" src="https://i-blog.csdnimg.cn/direct/375cf7af3d0b4470889a39da9e63c49c.png" width="2115"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       3. 控制
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="933" src="https://i-blog.csdnimg.cn/direct/6c8423636eee498782283c4bbd33e9fd.png" width="2994"/>
    </p>
    <p>
     <a class="link-info" href="https://gitee.com/a-clear-meaning/linux/tree/master/proc-commun/shm" rel="nofollow" title="相关代码测试获取可点击：前往我的仓库！ ">
      相关代码测试获取可点击：前往我的仓库！
     </a>
    </p>
    <h3 id="3.3%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20(Message%20Queues)" name="3.3%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20(Message%20Queues)">
     3.3 消息队列 (Message Queues)
    </h3>
    <p>
     允许一个进程以
     <span style="color:#956fe7">
      <strong>
       结构化
      </strong>
     </span>
     消息的形式向队列发送消息，另一个进程向队列中读取消息；消息有优先级，可以按照特定顺序读取
    </p>
    <p>
     操作是类似的（
     <strong>
      注意对比
     </strong>
     ）：
    </p>
    <p>
     <img alt="" height="480" src="https://i-blog.csdnimg.cn/direct/8f15083939e04cdd845ad527efc88fa6.png" width="2388">
      <img alt="" height="648" src="https://i-blog.csdnimg.cn/direct/ad913e6a488248df8bddd2b73becd2a2.png" width="2520"/>
     </img>
    </p>
    <h3 id="3.4%20%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphores%EF%BC%89" name="3.4%20%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphores%EF%BC%89" style="background-color:transparent">
     3.4 信号量（Semaphores）
    </h3>
    <p>
     主要用于进程间的
     <span style="color:#fe2c24">
      <strong>
       同步【具有一定的顺序性】
      </strong>
     </span>
     和 互斥
     <span style="color:#fe2c24">
      <strong>
       【对共享资源的独占访问】
      </strong>
     </span>
     ，确保进程在访问共享资源时的协调和安全性；并不作为一种朴素的数据通信。
    </p>
    <p>
     我们把
     <strong>
      共享资源
     </strong>
     就称为 ：
     <strong>
      临界资源 或 互斥资源
     </strong>
    </p>
    <p>
     涉及到访问临界资源的程序代码就叫：
     <strong>
      临界区
     </strong>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       信号量的本质就是：一个描述管理互斥资源的 “计数器”
      </strong>
     </span>
    </p>
    <p>
     下面引入一个具体的场景进行类比理解：
     <img alt="" height="1299" src="https://i-blog.csdnimg.cn/direct/f68e4acc18ba44eaa5a22b3009c36540.png" width="2499"/>
    </p>
    <p>
     用户态接口：
     <img alt="" height="1071" src="https://i-blog.csdnimg.cn/direct/100315838b7e40798a21b9913679004f.png" width="2367"/>
    </p>
    <p>
     <strong>
      （注意对比）
     </strong>
    </p>
    <p>
     <img alt="" height="558" src="https://i-blog.csdnimg.cn/direct/f5e4dd5c16ab4b9494f5304a401330b5.png" width="2406"/>
    </p>
    <h3 id="3.5%20%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89" name="3.5%20%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E5%9B%BE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89">
     3.5 内核结构图（部分）
    </h3>
    <p>
     <img alt="" height="1212" src="https://i-blog.csdnimg.cn/direct/4ff6f975796d42359e1201881da85996.png" width="2658"/>
    </p>
    <p>
     本篇分享到此结束，如果对你有所帮助，就是对小编最大的鼓励，可以的话，点赞，收藏并分享给您的小伙伴一起学习吧！
    </p>
    <p>
     关注小编，持续更新中......
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343137313035342f:61727469636c652f64657461696c732f313436303831313132" class_="artid" style="display:none">
 </p>
</div>


