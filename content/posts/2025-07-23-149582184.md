---
layout: post
title: "opencv学习图像处理"
date: 2025-07-23T22:03:10+0800
description: "方法有：均值滤波（做简单的平均卷积操作，进行归一化），方框滤波（基本和均值一样，可以选择归一化（所有在卷积核中的数值相加求平均值），也可以不归一化），高斯滤波（高斯模糊的卷积核里的数值的满足高斯分布(正态分布)的，相当于更重视中间的数值），中值滤波（对卷积核中的像素数值从小到大排序，用中间值代替）等。BORDER_REFLECT 101:反射法，也就是以最边缘像素为轴，对称，gfedcb | abcdefgh | gfedcba。CV2.THRESH_TRUNC 大于阈值部分设为阈值，否则不变。"
keywords: "opencv 学习"
categories: ['未分类']
tags: ['学习', '图像处理', 'Opencv']
artid: "149582184"
arturl: "https://blog.csdn.net/weixin_63566653/article/details/149582184"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=149582184
    alt: "opencv学习图像处理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=149582184
featuredImagePreview: https://bing.ee123.net/img/rand?artid=149582184
cover: https://bing.ee123.net/img/rand?artid=149582184
image: https://bing.ee123.net/img/rand?artid=149582184
img: https://bing.ee123.net/img/rand?artid=149582184
---



# opencv学习（图像处理）

![](https://i-operation.csdnimg.cn/images/cf31225e169b4512917b2e77694eb0a2.png)OpenCV图像处理学习要点

---

#### 1.图像的截取

用数组的形式呈现进行截取，如

```
img = cv2.imread("sea.jpeg")
sea = img[100:1000, 100:1000]
cv2.imshow('sea', sea)#或者直接调用函数cv__show('sea',sea)
cv2.waitKey(0)
```

#### 2.颜色通道的提取

opencv的颜色通道为BGR，在数组中索引为[0,1,2]

如，只提取B：

```
cur_img=img.copy()
cur_img[:,:,1]=0
cur_img[:,:,2]=0
cv2.imshow("R",cur_img)
cv2.waitKey(0)
```

#### 3.图像边界填充

BORDER_REPLICATE:复制法，也就是复制最边缘像素。  
 BORDER_REFLECT:反射法，对感兴趣的图像中的像素在两边进行复制例如:fedcba | abcdefgh | hgfedcb  
 BORDER_REFLECT 101:反射法，也就是以最边缘像素为轴，对称，gfedcb | abcdefgh | gfedcba  
 BORDER_WRAP:外包装法cdefgh | abcdefgh | abcdefg  
 BORDER_CONSTANT:常量法，常数值填充。

如：

```
top_size,bottom_size,left_size,right_size=(200,200,200,200)
replicate=cv2.copyMakeBorder(img,top_size,bottom_size,left_size,right_size,borderType=cv2.BORDER_REPLICATE)
reflect=cv2.copyMakeBorder(img,top_size,bottom_size,left_size,right_size,cv2.BORDER_REFLECT)
reflect1=cv2.copyMakeBorder(img,top_size,bottom_size,left_size,right_size,cv2.BORDER_REFLECT101)
wrap=cv2.copyMakeBorder(img,top_size,bottom_size,left_size,right_size,cv2.BORDER_WRAP)
constant=cv2.copyMakeBorder(img,top_size,bottom_size,left_size,right_size,cv2.BORDER_CONSTANT,value=2)

plt.subplot(231),plt.imshow(img,'gray'),plt.title('O')

.......
plt.show()


```

plt.subplot(231) 的意思是：将画布划分为 2行3列 的网格（共6个子图位置），当前要绘制的子图放在第 1 个位置。

#### 4.数值计算（OpenCV 图像数组的算术运算与 OpenCV 内置加法函数）

如：

```
img_sea=cv2.imread('sea.jpeg')
img_sea2=img_sea+10   #对图像中每个像素的每个通道值都加 10
#打印前5行、所有列、第0个通道（B通道）的像素值
print(img_sea[:5,:,0])
print(img_sea2[:5,:,0])

print((img_sea+img_sea2)[:5,:,0])   #当相加后的数值大于255时，进行%运算，如(195+205)-256
add=cv2.add(img_sea,img_sea2)[:5,:,0]  #当相加后的数值大于255时，其值取255。当小于255时，保留数值
print(add)

```

#### 5.图像融合（两个图像只有shape值相同才能融合）

如：

```
img_ajiao=cv2.imread("ajiao.jpg")
img_aiye=cv2.imread("aiye.jpg")
print(img_ajiao.shape,img_aiye.shape)   #若两个shape不同，则用cv2.resize()函数进行参数转换，使之二者相同
res1=cv2.addWeighted(img_ajiao,0.5,img_aiye,0.6,2)  #res1=0.5*x__ajiao+0.6*x__aiye+2，其中0.5，0.6分别是两张图片的融合倍数
plt.imshow(res1)
plt.show()
```

#### 6.图像阈值（**通过设定一个或多个阈值，将图像中的像素值划分为不同的类别（通常是黑白两个类别），从而简化图像信息，突出感兴趣的区域**。）

ret, dst =cv2.threshold(src, thresh, maxval, type)  
 src: 输入图，只能输入单通道图像，通常来说为灰度；dst:输出图；thresh:阈值；maxval:当像素值超过了阈值(或者小于阈值，根据type来决定)，所赋予的值·；type:二值化操作的类型，包含以下5种类型：

CV2.THRESH_BINARY 超过阈值部分取maxval(最大值)，否则取0  ;最大值的部分呈现白色，0的部分呈现黑色  
 CV2.THRESH_BINARY INV ，是THRESH BINARY的反转  
 CV2.THRESH_TRUNC 大于阈值部分设为阈值，否则不变  
 CV2.THRESH_TOZERO 大于阈值部分不改变，否则设为0  
 CV2.THRESH_TOZERO INV THRESH TOZERO的反转

如：

```
img=cv2.imread('aiye.jpg')
ret,thresh1=cv2.threshold(img,127,255,cv2.THRESH_BINARY)
ret,thresh2=cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV)
ret,thresh3=cv2.threshold(img,127,255,cv2.THRESH_TRUNC)
ret,thresh4=cv2.threshold(img,127,255,cv2.THRESH_TOZERO)
ret,thresh5=cv2.threshold(img,127,255,cv2.THRESH_TOZERO_INV)
titles=['原始图像','BINARY','BINARY_INV','THRESH_TRUNC','THRESH_TOZERO','THRESH_TOZERO_INV']
images=[img,thresh1,thresh2,thresh3,thresh4,thresh5]
for i in range(6):
    plt.subplot(2,3,i+1)
    plt.imshow(images[i],'gray')
    plt.xticks([])
    plt.yticks([])
plt.show()
```

#### 7.图像平滑（模糊，主动降低图像清晰度，目的是去除噪声、弱化细节）

方法有：均值滤波（做简单的平均卷积操作，进行归一化），方框滤波（基本和均值一样，可以选择归一化（所有在卷积核中的数值相加求平均值），也可以不归一化），高斯滤波（高斯模糊的卷积核里的数值的满足高斯分布(正态分布)的，相当于更重视中间的数值），中值滤波（对卷积核中的像素数值从小到大排序，用中间值代替）等

如：

```
imag=cv2.imread('girl.png')
cv2.imshow('imag',imag)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

##### （1）均值滤波

```
blur=cv2.blur(imag,(7,7))  #(7,7)是卷积核的大小,   并非卷积核越大越好，容易边缘失真
'''
核越小（如 3×3）：仅对局部少量像素进行平均，模糊程度轻，能保留较多细节，但可能无法完全去除噪声。
核越大（如 9×9、15×15）：对更大范围的像素取平均，图像整体更模糊，边缘和细节损失更多，噪声去除更彻底。
'''
cv2.imshow('blur',blur)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

##### （2）方框滤波

```
box=cv2.boxFilter(imag,-1,(9,9),normalize=True)#True表示选择归一化
'''
-1 对应 ddepth 参数（输出图像的深度）：
深度指的是图像中每个像素值的位数（如 8 位、16 位、32 位等）
-1 是一个特殊值，表示输出图像的深度与输入图像 imag 的深度相同
这样可以避免因深度不匹配导致的像素值范围异常或数据丢失
'''
cv2.imshow('box',box)
cv2.waitKey(0)
cv2.destroyAllWindows()
#不归一化，所有在卷积核中的数值相加，大于255时都取255，则图像显示为白色
box=cv2.boxFilter(imag,-1,(7,7),normalize=False)#Flase表示选择不归一化
cv2.imshow('box',box)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

##### （3）高斯滤波

```
aussian=cv2.GaussianBlur(imag,(7,7),1)
cv2.imshow('aussian',aussian)
cv2.waitKey(0)
cv2.destroyAllWindows()
'''
在 cv2.GaussianBlur(imag, (7,7), 1) 中，最后的参数 1 表示高斯核的标准差（sigma），具体来说是 X 方向的标准差（sigmaX）。
高斯模糊的原理是使用一个符合高斯分布的卷积核对图像进行卷积操作，标准差（sigma）是高斯分布的重要参数，它决定了高斯函数的 "宽窄" 程度：
sigma 值越小，高斯核越 "窄"，图像模糊程度越轻
sigma 值越大，高斯核越 "宽"，图像模糊程度越重
在 OpenCV 的 GaussianBlur 函数中：
第三个参数 sigmaX 是必须指定的 X 方向标准差
第四个可选参数 sigmaY 是 Y 方向标准差，如果不指定则默认与 sigmaX 相同
当你传入 1 时，表示使用标准差为 1 的高斯核进行模糊处理，这会产生轻微的模糊效果。
如果将这个值增大（比如 5），图像会变得更模糊；如果减小（比如 0.5），模糊效果会更轻微。
'''
```

##### （4）中值滤波

```
median=cv2.medianBlur(imag,7)
cv2.imshow('median',median)
cv2.waitKey(0)
cv2.destroyAllWindows()
```



