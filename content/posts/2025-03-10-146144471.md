---
layout: post
title: "从0开始的操作系统手搓教程43实现一个简单的shell"
date: 2025-03-10 09:31:08 +0800
description: "我们下面来实现一个简单的shell。"
keywords: "从0开始的操作系统手搓教程43——实现一个简单的shell"
categories: ['从0开始的操作系统教程']
tags: ['教程', '操作系统', '手搓教程', '学习', 'Shell']
artid: "146144471"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146144471
    alt: "从0开始的操作系统手搓教程43实现一个简单的shell"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146144471
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146144471
cover: https://bing.ee123.net/img/rand?artid=146144471
image: https://bing.ee123.net/img/rand?artid=146144471
img: https://bing.ee123.net/img/rand?artid=146144471
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     从0开始的操作系统手搓教程43——实现一个简单的shell
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     我们下面来实现一个简单的shell
    </p>
    <h3 id="%E6%B7%BB%E5%8A%A0%20read%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%20%3Asys_read" name="%E6%B7%BB%E5%8A%A0%20read%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%20%3Asys_read">
     添加 read 系统调用，获取键盘输入 :sys_read
    </h3>
    <pre><code class="language-cpp">/* Read count bytes from the file pointed to by file descriptor fd into buf,
 * return the number of bytes read on success, return -1 if end of file is
 * reached
 */
int32_t sys_read(int32_t fd, void *buf, uint32_t count)
{
    KERNEL_ASSERT(buf);
    int32_t ret = -1;
    uint32_t global_fd = 0;
    if (fd &lt; 0 || fd == stdout_no || fd == stderr_no)
    {
        ccos_printk("sys_read: fd error\n");
    }
    else if (fd == stdin_no)
    {
        char *buffer = buf;
        uint32_t bytes_read = 0;
        while (bytes_read &lt; count)
        {
            *buffer = ioq_getchar(&amp;keyboard_ringbuffer);
            bytes_read++;
            buffer++;
        }
        ret = (bytes_read == 0 ? -1 : (int32_t)bytes_read);
    }
    else
    {
        global_fd = fd_local2global(fd);
        ret = file_read(&amp;file_table[global_fd], buf, count);
    }
    return ret;
}</code></pre>
    <p>
     我们终于跟老朋友见面了。我们修订一下:sys_read，现在实现了读取文件的功能。它首先检查传入的
     <code>
      buf
     </code>
     指针是否有效。如果文件描述符
     <code>
      fd
     </code>
     无效（例如小于0或者是标准输出、标准错误），则会打印错误信息。如果文件描述符是标准输入（
     <code>
      stdin_no
     </code>
     ），函数会从键盘输入的缓冲区
     <code>
      keyboard_ringbuffer
     </code>
     中读取字符，将其存入
     <code>
      buf
     </code>
     中，直到读取指定的字节数或达到文件末尾。函数会返回成功读取的字节数，如果没有读取到任何数据，返回
     <code>
      -1
     </code>
     。如果文件描述符不是标准输入，函数会根据
     <code>
      fd
     </code>
     获取对应的文件，并调用
     <code>
      file_read
     </code>
     函数来执行实际的读取操作，并返回成功读取的字节数。如果文件读取失败，返回
     <code>
      -1
     </code>
     。
    </p>
    <pre><code class="language-cpp">int32_t read(int32_t fd, void *buf, uint32_t count)
{
    return _syscall3(SYS_READ, fd, buf, count);
}</code></pre>
    <h3 id="putchar%E5%92%8Cclear" name="putchar%E5%92%8Cclear">
     putchar和clear
    </h3>
    <p>
     这个把我们之前做的工作编程系统调用即可
    </p>
    <pre><code class="language-cpp">/* Outputs a character */
void putchar(char char_asci) {
    _syscall1(SYS_PUTCHAR, char_asci);
}
/* Clears the screen */
void clear(void) {
    _syscall0(SYS_CLEAR);
}
​
void sys_putchar(char char_asci)
{
    console__ccos_putchar(char_asci);
}
​
​
/* Initialize the system call table */
void syscall_init(void) {
    verbose_ccputs(
        "syscall_init start\n"); // Logging the start of syscall initialization
    /* Set the system call table entries for various system call numbers */
    syscall_table[SYS_GETPID] = sys_getpid; // Get process ID
    syscall_table[SYS_WRITE] = sys_write;   // Write to console
    syscall_table[SYS_MALLOC] = sys_malloc; // Memory allocation
    syscall_table[SYS_FREE] = sys_free;     // Free allocated memory
    syscall_table[SYS_FORK] = sys_fork;     // Fork a new process
    syscall_table[SYS_READ] = sys_read;
    syscall_table[SYS_PUTCHAR] = sys_putchar;
    syscall_table[SYS_CLEAR] = clean_screen;
    verbose_ccputs("syscall_init done\n"); // Logging the completion of syscall
                                          // initialization
}</code></pre>
    <h3 id="%E4%B8%8A%E7%8F%AD%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shell" name="%E4%B8%8A%E7%8F%AD%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shell">
     上班：实现一个简单的shell
    </h3>
    <pre><code class="language-cpp">#include "include/user/ccshell/ccshell.h"
#include "include/defines.h"
#include "include/filesystem/file.h"
#include "include/library/string.h"
#include "include/library/types.h"
#include "include/syscall/syscall.h"
#include "include/user/stdio/stdio.h"
#include "include/filesystem/filesystem_settings.h"
#include "include/user/library/user_assertion.h"
#define CMD_LEN MAX_PATH_LEN
#define MAX_ARG_NR (16)
​
/* Stores the input command */
static char cmd_line[CMD_LEN] = {0};
​
/* Used to record the current directory; it is updated every time the cd command
 * is executed */
char cwd_cache[MAX_PATH_LEN] = {0};
​
/* Outputs the shell prompt */
void print_prompt(void)
{
    printf("[" HOST_NAME "@localhost %s]$ ", cwd_cache);
}
​
/* Reads up to 'count' bytes from the keyboard buffer into 'buf' */
static void readline(char *buf, int32_t count)
{
    user_assert(buf &amp;&amp; count &gt; 0);
    char *pos = buf;
​
    while (read(stdin_no, pos, 1) != -1 &amp;&amp;
           (pos - buf) &lt; count)
    { // Read until enter key is found
        switch (*pos)
        {
            /* If enter or newline is found, treat it as the end of the command
             */
        case '\n':
        case '\r':
            *pos = 0; // Add null terminator to cmd_line
            putchar('\n');
            return;
​
        case '\b':
            if (cmd_line[0] != '\b')
            {          // Prevent deleting non-inputted data
                --pos; // Move back to the previous character in the buffer
                putchar('\b');
            }
            break;
​
        /* For other characters, output normally */
        default:
            putchar(*pos);
            pos++;
        }
    }
    printf("readline: can't find enter_key in the cmd_line, max num of char is "
           "128\n");
}</code></pre>
    <p>
     先说说readline:这段代码实现了一个从键盘缓冲区读取用户输入的功能。函数
     <code>
      readline
     </code>
     的作用是从输入流中读取字符，直到遇到回车键（
     <code>
      \n
     </code>
     或
     <code>
      \r
     </code>
     ）为止，或者读取达到指定的字节数限制。读取的内容会存储到
     <code>
      buf
     </code>
     中。具体步骤如下：
    </p>
    <ol>
     <li>
      <p>
       函数首先检查传入的缓冲区指针
       <code>
        buf
       </code>
       是否有效，并确认
       <code>
        count
       </code>
       大于0。
      </p>
     </li>
     <li>
      <p>
       <code>
        while
       </code>
       循环会持续读取一个字符（通过
       <code>
        read(stdin_no, pos, 1)
       </code>
       ），直到读取到回车键或达到指定的字符数量（
       <code>
        count
       </code>
       ）。读取的字符会存储在
       <code>
        buf
       </code>
       中。
      </p>
     </li>
     <li>
      <p>
       当遇到回车符（
       <code>
        \n
       </code>
       或
       <code>
        \r
       </code>
       ）时，表示用户输入完成，此时将当前位置字符设置为
       <code>
        '\0'
       </code>
       ，并输出换行符，表示命令输入结束。
      </p>
     </li>
     <li>
      <p>
       如果遇到退格符（
       <code>
        \b
       </code>
       ），程序会检查输入内容是否为空。如果不为空，指针会退回一个字符，删除命令行中的最后一个字符，并输出退格符。此功能允许用户删除输入的字符。
      </p>
     </li>
     <li>
      <p>
       其他字符直接输出并追加到
       <code>
        pos
       </code>
       指向的位置，继续读取下一个字符。
      </p>
     </li>
     <li>
      <p>
       如果没有在指定字符数内读取到回车键，则会输出错误提示，表明命令行输入超出了最大字符限制。
      </p>
     </li>
    </ol>
    <p>
     这个函数的设计使得用户可以在命令行中输入命令，且支持基本的退格功能，直到按下回车键为止。
    </p>
    <p>
     ccshell是我们的核心：
    </p>
    <pre><code class="language-cpp">void ccshell(void)
{
    cwd_cache[0] = '/';
    while (1)
    {
        print_prompt();
        k_memset(cmd_line, 0, CMD_LEN);
        readline(cmd_line, CMD_LEN);
        if (cmd_line[0] == 0)
        {
            continue;
        }
    }
    user_panic("Man!: you should not be here!!!");
}</code></pre>
    <p>
     这段代码实现了一个简单的命令行shell功能。函数
     <code>
      ccshell
     </code>
     定义了一个无限循环，其中每次循环都会显示提示符，等待用户输入命令。命令输入通过
     <code>
      readline
     </code>
     函数完成，读取用户输入并存储到
     <code>
      cmd_line
     </code>
     中。每次读取命令之前，
     <code>
      cmd_line
     </code>
     会被清空，确保新命令不会受到旧命令的影响。如果用户没有输入命令，程序会跳过本次循环。当用户输入命令时，如果命令不为空，程序会继续执行。虽然代码没有明确的退出机制，但如果程序异常执行到
     <code>
      user_panic("Man!: you should not be here!!!")
     </code>
     ，说明发生了错误。
    </p>
    <h3 id="%E6%B5%8B%E8%AF%95%E4%B8%8A%E7%94%B5" name="%E6%B5%8B%E8%AF%95%E4%B8%8A%E7%94%B5">
     测试上电
    </h3>
    <pre><code class="language-cpp">#include "include/device/console_tty.h"
#include "include/kernel/init.h"
#include "include/library/kernel_assert.h"
#include "include/thread/thread.h"
#include "include/user/stdio/stdio.h"
#include "include/memory/memory.h"
#include "include/library/ccos_print.h"
#include "include/filesystem/filesystem.h"
#include "include/library/string.h"
#include "include/filesystem/dir.h"
#include "include/syscall/syscall.h"
#include "include/user/ccshell/ccshell.h"
void init(void);
​
int main(void)
{
    init_all();
    while(1);
}
​
// init process here
void init(void)
{
    uint32_t ret_pid = fork();
    if (ret_pid)
    {
        while(1);
    }
    else
    {
        ccshell();
    }
    while (1)
        ;
}
​</code></pre>
    <p>
     <img alt="" height="507" src="https://i-blog.csdnimg.cn/direct/83853afac40f44999c09270043236afb.png" width="1089"/>
    </p>
    <p>
     注意多敲几下键盘，因为输出非常多。
    </p>
    <h3>
     下一篇
    </h3>
    <p>
     <a class="has-card" href="https://blog.csdn.net/charlie114514191/article/details/146144528" title="从0开始的操作系统手搓教程44——实现更好的shell-CSDN博客">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        从0开始的操作系统手搓教程44——实现更好的shell-CSDN博客
       </span>
       <span class="link-desc">
        文章浏览阅读766次，点赞14次，收藏9次。在 Linux 系统中，快捷键如“Ctrl+u”和“Ctrl+l”是由操作系统提供的标准功能，但它们的实现方式并不是直接由键盘驱动程序（keyboard.c）来处理的。如果在键盘驱动程序中加入过多的逻辑处理，会导致系统的中断处理变得非常复杂，效率降低，进而影响整个系统的响应速度。的数据类型（从16位改为32位），因为一旦改动数据类型，后续代码可能会受到影响，造成所谓的“雪崩效应”，即需要改动很多地方的代码和解释。时，输入缓冲区中的字符会被清除，屏幕会被清空，然后打印命令提示符，再显示用户已输入的命令。
       </span>
       <span class="link-link">
        <img alt=" " class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico">
         https://blog.csdn.net/charlie114514191/article/details/146144528
        </img>
       </span>
      </span>
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e63:73646e2e6e65742f636861726c69653131343531343139312f:61727469636c652f64657461696c732f313436313434343731" class_="artid" style="display:none">
 </p>
</div>


