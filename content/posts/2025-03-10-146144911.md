---
layout: post
title: "鸿蒙NEXT开发-自定义相机拍照-"
date: 2025-03-10 09:50:33 +0800
description: "鸿蒙NEXT开发实现自定义相机拍照"
keywords: "鸿蒙NEXT开发-自定义相机拍照 "
categories: ['鸿蒙学习']
tags: ['华为', 'Harmonyos']
artid: "146144911"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146144911
    alt: "鸿蒙NEXT开发-自定义相机拍照-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146144911
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146144911
cover: https://bing.ee123.net/img/rand?artid=146144911
image: https://bing.ee123.net/img/rand?artid=146144911
img: https://bing.ee123.net/img/rand?artid=146144911
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     鸿蒙NEXT开发-自定义相机拍照
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h4 id="h0" name="h0" style="background-color:transparent">
     <span style="font-size:22px">
      大致流程
     </span>
    </h4>
    <p>
     相机开发需要使用真机，模拟器目前还是不支持的。这就劝退了一部分开发者。
     <br/>
     所需要的调用的接口大部分集中在
     <code>
      @kit.CameraKit
     </code>
     、
     <code>
      @kit.AbilityKit
     </code>
     中。保存图片时需要用到
     <code>
      @kit.ImageKit
     </code>
     、
     <code>
      @kit.CoreFileKit
     </code>
     、
     <code>
      @kit.MediaLibraryKit
     </code>
     等
     <br/>
     接下来看下需要做哪些工作：
    </p>
    <ol>
     <li>
      获取相机权限
     </li>
     <li>
      获取可用相机列表
      <ol>
       <li>
        可以在这里监听相机状态(USB相机连接、断开连接、关闭、被占用等)
       </li>
       <li>
        选择当前使用的相机
       </li>
      </ol>
     </li>
     <li>
      创建相机输入流并打开相机
      <ol>
       <li>
        可以创建相机输入流
       </li>
       <li>
        可以监听预览输出流状态，包括预览流启动、预览流结束、预览流输出错误
       </li>
       <li>
        可以获取相机支持的模式列表(NORMAL_PHOTO,NORMAL_VIDEO,SECURE_PHOTO)
       </li>
       <li>
        可以获取当前相机设备支持的所有输出流，如预览流、拍照流、录像流等
       </li>
      </ol>
     </li>
     <li>
      会话(Session)管理
      <ol>
       <li>
        配置相机的输入流和输出流(分辨路等配置)
       </li>
       <li>
        添加闪光灯、调整焦距等配置
       </li>
       <li>
        会话切换控制:切换拍照或者录像
       </li>
       <li>
        交和开启会话，可以开始调用相机相关功能
       </li>
      </ol>
     </li>
     <li>
      预览
      <ol>
       <li>
        创建Surface用于预览
       </li>
       <li>
        将预览输出流通过SurfaceID与Surface关联
       </li>
       <li>
        调用Session.start方法开始预览
       </li>
      </ol>
     </li>
     <li>
      拍照
      <ol>
       <li>
        创建拍照输出流
       </li>
       <li>
        设置拍照photoAvailable的回调，并将拍照的buffer保存为图片。
       </li>
       <li>
        参数配置(闪光灯、变焦、焦距等)
       </li>
       <li>
        触发拍照
       </li>
      </ol>
     </li>
    </ol>
    <h3 id="h3" name="h3">
     <a id="_33">
     </a>
     开发
    </h3>
    <h4 id="h4" name="h4">
     <a id="_35">
     </a>
     权限处理
    </h4>
    <p>
     在进入拍照页面之前先申请权限，具体的流程看这里
     <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/request-app-permissions-V5" rel="nofollow" title="申请应用权限">
      申请应用权限
     </a>
     ，本文不再赘述。
    </p>
    <h4 id="h5" name="h5">
     <a id="_38">
     </a>
     获取可用相机列表
    </h4>
    <p>
     首先要获取相机管理实例，这里为了代码看起来清晰，将各个步骤写到了单独的方法中。
     <br/>
     另外多出使用
     <code>
      camera.CameraManager
     </code>
     实例，因此定义为了全局变量
    </p>
    <pre><code>
@Entry
@Component
struct TakePhotoPage {


  //相机管理
  getCameraManager(context: common.BaseContext): camera.CameraManager {
    let cameraManager: camera.CameraManager = camera.getCameraManager(context);
    return cameraManager;
  }

  //获取可用相机列表
  getCameraDevices(cameraManager: camera.CameraManager): Array&lt;camera.CameraDevice&gt; {
    let cameraArray: Array&lt;camera.CameraDevice&gt; = cameraManager.getSupportedCameras();
    
    if (cameraArray != undefined &amp;&amp; cameraArray.length &gt; 0) {
      //在这里可以输出一些相机参数，比如相机位置(前置、后置)、相机类型(广角相机、长焦相机)等信息
      return cameraArray;
    } else {
      hilog.error(0x01,TAG,"cameraManager.getSupportedCameras error");
      return [];
    }
  }

  // 监听相机状态
  onCameraStatusChange(cameraManager: camera.CameraManager): void {
    cameraManager.on('cameraStatus', (err: BusinessError, cameraStatusInfo: camera.CameraStatusInfo) =&gt; {
      if (err !== undefined &amp;&amp; err.code !== 0) {
        hilog.error(0x01,TAG,`Callback Error, errorCode: ${err.code}`);
        return;
      }
      // 如果当通过USB连接相机设备时，回调函数会返回新的相机出现状态
      if (cameraStatusInfo.status == camera.CameraStatus.CAMERA_STATUS_APPEAR) {
        hilog.info(0x01,TAG,`New Camera device appear.`);
      }
      // 如果当断开相机设备USB连接时，回调函数会返回相机被移除状态
      if (cameraStatusInfo.status == camera.CameraStatus.CAMERA_STATUS_DISAPPEAR) {
        hilog.info(0x01,TAG,`Camera device has been removed.`);
      }
      // 相机被关闭时，回调函数会返回相机可用状态
      if (cameraStatusInfo.status == camera.CameraStatus.CAMERA_STATUS_AVAILABLE) {
        hilog.info(0x01,TAG,`Current Camera is available.`);
      }
      // 相机被打开/占用时，回调函数会返回相机不可用状态
      if (cameraStatusInfo.status == camera.CameraStatus.CAMERA_STATUS_UNAVAILABLE) {
        hilog.info(0x01,TAG,`Current Camera has been occupied.`);
      }
      hilog.info(0x01,TAG,`camera: ${cameraStatusInfo.camera.cameraId}`);
      hilog.info(0x01,TAG,`status: ${cameraStatusInfo.status}`);
    });
  }
}
</code></pre>
    <ul>
    </ul>
    <p>
     这样我们可以获取到所有可用的相机列表，并且可以根据相机类型、连接类型等过滤掉不适用的相机。
     <br/>
     在获取到相机列表后，我们默认使用返回列表的第一个相机。
    </p>
    <h4 id="h6" name="h6">
     <a id="_101">
     </a>
     创建相机输入流并打开相机
    </h4>
    <p>
     在这一步我们主要是创建相机的输入流，为后面在
     <code>
      XComponent
     </code>
     中预览做准备。
    </p>
    <pre><code>createInput(): camera.CameraInput | undefined {
// 创建相机输入流
let cameraInput: camera.CameraInput | undefined = undefined;
try {
    cameraInput = this.cameraManager.createCameraInput(this.currentCamera);
} catch (error) {
    let err = error as BusinessError;
    console.error('Failed to createCameraInput errorCode = ' + err.code);
}
if (cameraInput === undefined) {
    return undefined;
}
// 监听cameraInput错误信息
cameraInput.on('error', this.currentCamera, (error: BusinessError) =&gt; {
    console.error(`Camera input error code: ${error.code}`);
});

return cameraInput;
}
</code></pre>
    <ul>
    </ul>
    <p>
     最重要的就一行代码：调用
     <code>
      cameraManager.createCameraInput(camera: CameraDevice)
     </code>
     创建一个输入流并返回，之后调用返回的输入流的
     <code>
      open()
     </code>
     方法打开相机，注意该方法是异步的。
     <br/>
     同样的，我们可以调用
     <code>
      cameraManager.getSupportedSceneModes(camera: CameraDevice)
     </code>
     来获取相机支持的模式，一般情况下都会支持拍照和录像。
     <br/>
     之后我们获取设备支持的输出流能力
    </p>
    <pre><code>getSupportedOutputCapability(): camera.CameraOutputCapability | undefined {
// 获取相机设备支持的输出流能力
let cameraOutputCapability: camera.CameraOutputCapability =
    this.cameraManager.getSupportedOutputCapability(this.currentCamera, camera.SceneMode.NORMAL_PHOTO)

if (!cameraOutputCapability) {
    console.error("cameraManager.getSupportedOutputCapability error");
    return undefined;
}
return cameraOutputCapability;
}
</code></pre>
    <p>
     我们拿到
     <code>
      cameraOutputCapability
     </code>
     之后，可以从该对象的
     <code>
      previewProfiles
     </code>
     、
     <code>
      photoProfiles
     </code>
     属性中获取到设备支持的分辨率大小。这里我们直接使用
     <code>
      1920*1080
     </code>
     的分辨率。
     <br/>
     需要注意的是
     <code>
      previewProfiles
     </code>
     和
     <code>
      photoProfiles
     </code>
     所支持的分辨率不一定是一致的。预览的话只要宽高比一致，分辨率别差的太离谱就可以。
    </p>
    <p>
     之后我们使用选择好的
     <code>
      Profile
     </code>
     对象来创建拍照输出流和预览输出流
    </p>
    <pre><code>    try {
      this.photoOutput = this.cameraManager.createPhotoOutput(this.currentPhotoProfile);
      this.previewOutput = this.cameraManager.createPreviewOutput(previewProfile, this.surfaceId);
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to createPhotoOutput errorCode = ' + err.code);
    }
    if (this.photoOutput === undefined) {
      return;
    }
</code></pre>
    <ul>
    </ul>
    <p>
     这里需要注意的是，创建预览输出流的时候需要传入 surfaceID，该值来源于组件
     <code>
      XComponent
     </code>
    </p>
    <pre><code>private mXComponentController: XComponentController = new XComponentController;
XComponent({
id: 'componentId',
type: XComponentType.SURFACE,
controller: this.mXComponentController,
})
.onLoad(async () =&gt; {
    this.surfaceId = this.mXComponentController.getXComponentSurfaceId();
})
</code></pre>
    <ul>
    </ul>
    <p>
     所以这里我们需要注意一下创建预览输出流的时机
    </p>
    <h4 id="h7" name="h7">
     <a id="_170">
     </a>
     创建并配置会话
    </h4>
    <p>
     创建会话也只是一行的就可以搞定，但可能会有异常出现
    </p>
    <pre><code>  createSession() {
    //创建会话

    try {
      this.photoSession = this.cameraManager.createSession(camera.SceneMode.NORMAL_PHOTO) as camera.PhotoSession;
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to create the session instance. errorCode = ' + err.code);
    }
    if (this.photoSession === undefined) {
      return;
    }
    // 监听session错误信息
    this.photoSession.on('error', (error: BusinessError) =&gt; {
      console.error(`Capture session error code: ${error.code}`);
    });
  }
</code></pre>
    <ul>
    </ul>
    <p>
     配置会话主要是添加相机输入流、预览输出流和拍照输出流，最后提交配置
    </p>
    <pre><code>
  async configSession(cameraInput: camera.CameraInput, previewOutput: camera.PreviewOutput) {
    if (!this.photoSession) {
      return
    }

    // 开始配置会话
    try {
      this.photoSession.beginConfig();
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to beginConfig. errorCode = ' + err.code);
    }

    // 向会话中添加相机输入流
    try {
      this.photoSession.addInput(cameraInput);
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to addInput. errorCode = ' + err.code);
    }

    // 向会话中添加预览输出流
    try {
      this.photoSession.addOutput(previewOutput);
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to addOutput(previewOutput). errorCode = ' + err.code);
    }

    // 向会话中添加拍照输出流
    try {
      this.photoSession.addOutput(this.photoOutput);
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to addOutput(photoOutput). errorCode = ' + err.code);
    }

    // 提交会话配置
    await this.photoSession.commitConfig();
  }
</code></pre>
    <ul>
    </ul>
    <h4 id="h8" name="h8">
     <a id="_237">
     </a>
     拍照回调和启动会话
    </h4>
    <p>
     我们先启动会话
    </p>
    <pre><code>await this.photoSession.start().then(() =&gt; {
        console.info('Promise returned to indicate the session start success.');
      });
</code></pre>
    <ul>
    </ul>
    <p>
     会话启动之后我们就可以进行拍照了。拍照的话需要调用拍照输出流的
     <code>
      capture
     </code>
     方法
    </p>
    <pre><code>takePhoto() {
if (!this.photoOutput) {
    return
}
let photoCaptureSetting: camera.PhotoCaptureSetting = {
    quality: camera.QualityLevel.QUALITY_LEVEL_HIGH, // 设置图片质量高
    rotation: camera.ImageRotation.ROTATION_0 // 设置图片旋转角度0
}
// 使用当前拍照设置进行拍照
this.photoOutput.capture(photoCaptureSetting, (err: BusinessError) =&gt; {
    if (err) {
    console.error(`Failed to capture the photo ${err.message}`);
    return;
    }
    console.info('Callback invoked to indicate the photo capture request success.');
});
}
</code></pre>
    <ul>
    </ul>
    <p>
     但照片内容确不是在该方法中返回，而是需要我们在拍照输出流中添加
     <code>
      photoAvailable
     </code>
     事件监听，该监听可以在创建拍照输出流之后就添加
    </p>
    <pre><code>setPhotoOutputCb(): void {
    if (!this.photoOutput) {
      return
    }
    //设置回调之后，调用photoOutput的capture方法，就会将拍照的buffer回传到回调中
    this.photoOutput.on('photoAvailable', (errCode: BusinessError, photo: camera.Photo): void =&gt; {
      console.info('getPhoto start');
      console.info(`err: ${JSON.stringify(errCode)}`);
      if (errCode || photo === undefined) {
        console.error('getPhoto failed');
        return;
      }
      let imageObj = photo.main;
      imageObj.getComponent(image.ComponentType.JPEG, (errCode: BusinessError, component: image.Component): void =&gt; {
        console.info('getComponent start');
        if (errCode || component === undefined) {
          console.error('getComponent failed');
          return;
        }
        let buffer: ArrayBuffer;
        if (component.byteBuffer) {
          buffer = component.byteBuffer;
          let filePath = getContext().cacheDir + '/' + systemDateTime.getTime() + '.jpg'
          let file = fileIo.openSync(filePath, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE)
          fileIo.writeSync(file.fd, buffer)
          fileIo.closeSync(file)

          let fileUrl = fileUri.getUriFromPath(filePath)
          promptAction.showToast({message:fileUrl})


          let id: number = 0
          promptAction.openCustomDialog({
            builder: () =&gt; {
              this.saveImageToAlbumDialog(fileUrl, () =&gt; {
                promptAction.closeCustomDialog(id)
              })
            }
          }).then((dialogID) =&gt; {
            id = dialogID
          })

        } else {
          console.error('byteBuffer is null');
          return;
        }
        imageObj.release();
      });
    });
  }
</code></pre>
    <ul>
    </ul>
    <p>
     这里就简单写了一下处理：拿到 ArrayBuffer 之后写入沙箱文件，然后在弹窗中展示
    </p>
    <h4 id="h9" name="h9">
     <a id="_320">
     </a>
     其他配置
    </h4>
    <p>
     我们创建会话(camera.PhotoSession)之后，可以通过该对象配置闪光灯模式、对焦模式、缩放等
    </p>
    <h5 id="h10" name="h10">
     <a id="_323">
     </a>
     闪光灯
    </h5>
    <p>
     首先判断设备是否支持闪光灯，然后再判断支持的闪光灯模式。
    </p>
    <pre><code> getSupportFlashMode() {
    this.supportFlashMode = []
    if (!this.photoSession) {
      return
    }
    // 判断设备是否支持闪光灯
    let flashStatus: boolean = false;
    try {
      flashStatus = this.photoSession.hasFlash();
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to hasFlash. errorCode = ' + err.code);
    }
    console.info('Returned with the flash light support status:' + flashStatus);

    if (flashStatus) {
      // 判断支持的闪光灯模式
      try {
        let status: boolean = this.photoSession.isFlashModeSupported(camera.FlashMode.FLASH_MODE_CLOSE);
        if (status) {
          this.supportFlashMode.push(camera.FlashMode.FLASH_MODE_CLOSE)
        }
      } catch (error) {
        let err = error as BusinessError;
        console.error('Failed to check whether the flash mode is supported. errorCode = ' + err.code);
      }

      try {
        let status: boolean = this.photoSession.isFlashModeSupported(camera.FlashMode.FLASH_MODE_OPEN);
        if (status) {
          this.supportFlashMode.push(camera.FlashMode.FLASH_MODE_OPEN)
        }
      } catch (error) {
        let err = error as BusinessError;
        console.error('Failed to check whether the flash mode is supported. errorCode = ' + err.code);
      }

      try {
        let status: boolean = this.photoSession.isFlashModeSupported(camera.FlashMode.FLASH_MODE_AUTO);
        if (status) {
          this.supportFlashMode.push(camera.FlashMode.FLASH_MODE_AUTO)
        }
      } catch (error) {
        let err = error as BusinessError;
        console.error('Failed to check whether the flash mode is supported. errorCode = ' + err.code);
      }

      try {
        let status: boolean = this.photoSession.isFlashModeSupported(camera.FlashMode.FLASH_MODE_ALWAYS_OPEN);
        if (status) {
          this.supportFlashMode.push(camera.FlashMode.FLASH_MODE_ALWAYS_OPEN)
        }
      } catch (error) {
        let err = error as BusinessError;
        console.error('Failed to check whether the flash mode is supported. errorCode = ' + err.code);
      }
    }
  }
</code></pre>
    <ul>
    </ul>
    <h5 id="h11" name="h11">
     <a id="_386">
     </a>
     连续自动对焦
    </h5>
    <p>
     也是需要先判断是否支持自动连续对焦，不支持的话只能手动对焦
    </p>
    <pre><code>  setAutoContinuousFocus() {
    if (!this.photoSession) {
      return
    }
    // 判断是否支持连续自动变焦模式
    let focusModeStatus: boolean = false;
    try {
      let status: boolean = this.photoSession.isFocusModeSupported(camera.FocusMode.FOCUS_MODE_CONTINUOUS_AUTO);
      focusModeStatus = status;
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to check whether the focus mode is supported. errorCode = ' + err.code);
    }

    if (focusModeStatus) {
      // 设置连续自动变焦模式
      try {
        this.photoSession.setFocusMode(camera.FocusMode.FOCUS_MODE_CONTINUOUS_AUTO);
      } catch (error) {
        let err = error as BusinessError;
        console.error('Failed to set the focus mode. errorCode = ' + err.code);
      }
    }

  }
</code></pre>
    <ul>
    </ul>
    <p>
     手动对焦则是获取到用户点击的位置，然后调用
     <code>
      this.photoSession.setFocusPoint(point: camera.Point)
     </code>
     方法进行对焦
    </p>
    <h5 id="h12" name="h12">
     <a id="_416">
     </a>
     缩放
    </h5>
    <p>
     同样的，需要先获取到支持的缩放范围
    </p>
    <pre><code>  getZoomRatioRange() {
    if (!this.photoSession) {
      return
    }
    // 获取相机支持的可变焦距比范围
    let zoomRatioRange: Array&lt;number&gt; = [];
    try {
      zoomRatioRange = this.photoSession.getZoomRatioRange();
    } catch (error) {
      let err = error as BusinessError;
      console.error('Failed to get the zoom ratio range. errorCode = ' + err.code);
    }
    if (zoomRatioRange.length &lt;= 0) {
      return;
    }
    this.zoomRatioRangeStart = zoomRatioRange[0]
    this.zoomRatioRangeEnd = zoomRatioRange[1]

  }
</code></pre>
    <ul>
    </ul>
    <p>
     然后调用
     <code>
      this.photoSession.setZoomRatio(zoom);
     </code>
     设置缩放比
    </p>
    <h4 id="h13" name="h13">
     <a id="_441">
     </a>
     释放资源
    </h4>
    <p>
     在拍照结束后需要释放相应的资源
    </p>
    <pre><code>await photoSession.stop();

// 释放相机输入流
await cameraInput.close();

// 释放预览输出流
await previewOutput.release();

// 释放拍照输出流
await photoOutput.release();

// 释放会话
await photoSession.release();

// 会话置空
photoSession = undefined;
</code></pre>
    <ul>
    </ul>
    <h4 id="h14" name="h14">
     <a id="_462">
     </a>
     优化
    </h4>
    <h5 id="h15" name="h15">
     <a id="_464">
     </a>
     设备旋转
    </h5>
    <p>
     上面的代码中我们并没有考虑设备旋转问题
    </p>
    <pre><code>import { display } from '@kit.ArkUI';   

let initDisplayRotation = display.getDefaultDisplaySync().rotation;
let initPreviewRotation = previewOutput.getPreviewRotation(initDisplayRotation * camera.ImageRotation.ROTATION_90);
previewOutput.setPreviewRotation(initPreviewRotation, false);
display.off('change');
display.on('change', () =&gt; {
  initDisplayRotation = display.getDefaultDisplaySync().rotation;
  let imageRotation = initDisplayRotation * camera.ImageRotation.ROTATION_90;
  let previewRotation = previewOutput.getPreviewRotation(imageRotation);
  previewOutput.setPreviewRotation(previewRotation, false);
});
</code></pre>
    <ul>
    </ul>
    <h5 id="h16" name="h16">
     <a id="_Worker__481">
     </a>
     在 Worker 线程中使用相机
    </h5>
    <p>
     一般情况下，设备的性能足以支持我们直接使用相机，但如果要追求极致性能，可以将拍照的一系列流程都放在 Worker 线程中完成，通过宿主线程的即时消息通信完成线程间交互
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313136363738362f:61727469636c652f64657461696c732f313436313434393131" class_="artid" style="display:none">
 </p>
</div>


