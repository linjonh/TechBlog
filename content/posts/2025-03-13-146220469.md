---
layout: post
title: "基于FPGA的16PSK帧同步系统verilog开发,包含testbench,高斯信道,误码统计,可设置SNR"
date: 2025-03-13 04:21:02 +0800
description: "vivado2019.2仿真结果如下（完整代码运行后无水印）：SNR=30db对应星座图：SNR=20db对应星座图：仿真操作步骤可参考程序配套的操作视频。随着通信技术的不断发展，相位调制技术因其高频谱效率和抗干扰能力而广泛应用于无线通信系统中。其中，16PSK（16相位相移键控）作为一种高阶调制方式，具有更高的频谱效率和更强的抗干扰能力，因此备受关注。然而，16PSK调制解调的实现复杂度较高，需要高效的数字信号处理技术。"
keywords: "md5sum verilog"
categories: ['Fpga']
tags: ['误码', '帧同步', '信道', 'Fpga', 'Fpga', 'Awgn', '16Psk']
artid: "146220469"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146220469
    alt: "基于FPGA的16PSK帧同步系统verilog开发,包含testbench,高斯信道,误码统计,可设置SNR"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146220469
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146220469
cover: https://bing.ee123.net/img/rand?artid=146220469
image: https://bing.ee123.net/img/rand?artid=146220469
img: https://bing.ee123.net/img/rand?artid=146220469
---

# 基于FPGA的16PSK+帧同步系统verilog开发,包含testbench,高斯信道,误码统计,可设置SNR
\* \* \*
## 1.算法仿真效果
vivado2019.2仿真结果如下（完整代码运行后无水印）：
SNR=30db
![](https://i-blog.csdnimg.cn/direct/c87b57e2021f4951964b2f14f6c8cb17.jpeg)
对应星座图：
![](https://i-blog.csdnimg.cn/direct/0e3622f7e6714b23ad7755d05f8ed85e.jpeg)
SNR=20db
![](https://i-blog.csdnimg.cn/direct/e1b80bf4042a4be49c970149133c74ab.jpeg)
对应星座图：
![](https://i-blog.csdnimg.cn/direct/4c08a8b5ad594826894b50c1efc4efd7.jpeg)
仿真操作步骤可参考程序配套的操作视频。
## \*\*2.算法涉及理论知识概要\*\*
随着通信技术的不断发展，相位调制技术因其高频谱效率和抗干扰能力而广泛应用于无线通信系统中。其中，16PSK（16相位相移键控）作为一种高阶调制方式，具有更高的频谱效率和更强的抗干扰能力，因此备受关注。然而，16PSK调制解调的实现复杂度较高，需要高效的数字信号处理技术。现场可编程门阵列（FPGA）作为一种可编程逻辑器件，具有高度的灵活性和并行处理能力，非常适合实现复杂的数字信号处理算法。
### 2.1 16PSK原理
十六进制相位移键控（16PSK, 16-Phase Shift
Keying）是一种数字调制技术，它通过改变载波相位来传输信息。16PSK能够在一个符号时间内传输4比特的信息，因此在高速数据传输中得到了广泛应用。
16PSK是一种相位调制技术，其中载波信号的相位根据要传输的信息发生改变。在16PSK中，一个符号可以表示4比特的信息，即每个符号有16种不同的相位状态。在16PSK中，每个符号可以表示16种不同的相位状态，这16个状态均匀分布在单位圆上，形成一个16点的星座图。每个符号对应于4比特的信息，即：
![](https://i-blog.csdnimg.cn/direct/22f73a4982544a4eb5f08318055847d7.png)
首先，需要将要传输的比特流转换成16个相位状态之一。假设信息比特序列为{bi​}，则将每4比特映射到一个相位状态上。映射规则如下：
![](https://i-blog.csdnimg.cn/direct/3108bf92007f4a0c9b2cb8742c52695d.png)
16PSK的解调过程主要包括匹配滤波和决策两个步骤。
### \*\*2.2 帧同步\*\*
在数字通信中，信息通常是以帧为单位进行组织和传输的。帧同步的目的是确定每一帧的起始位置，以便接收端能够正确地解调出每帧中的数据。
设发送的帧结构为：帧同步码 + 信息码元序列 。帧同步码是具有特定规律的码序列，用于接收端识别帧的起始。
帧同步的过程就是在接收序列中寻找与帧同步码匹配的位置，一旦找到匹配位置，就确定了帧的起始位置，后续的码元就可以按照帧结构进行正确的划分和处理。
## 3.Verilog核心程序
`timescale 1ns / 1ps
//
// Company:
// Engineer:
//
// Create Date: 2024/08/05 03:30:02
// Design Name:
// Module Name: TOPS\_8PSK
// Project Name:
// Target Devices:
// Tool Versions:
// Description:
//
// Dependencies:
//
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//
module TOPS\_16PSK(
input i\_clk,
input i\_rst,
input signed[7:0]i\_SNR,
input[1:0]i\_en,
input i\_dat,
output [3:0]o\_ISET,
output signed[15:0]o\_I16psk,
output signed[15:0]o\_Q16psk,
output signed[15:0]o\_Ifir\_T,
output signed[15:0]o\_Qfir\_T,
output signed[31:0]o\_mod\_T,
output signed[15:0]o\_Nmod\_T,
output signed[31:0]o\_modc\_R,
output signed[31:0]o\_mods\_R,
output signed[31:0]o\_Ifir\_R,
output signed[31:0]o\_Qfir\_R,
output [3:0]o\_wbits,
output o\_bits,
output [1:0]o\_bits\_head,
output [7:0]o\_peak,
output o\_en\_data,
output o\_en\_pn,
output o\_frame\_start,
output signed[31:0]o\_error\_num,
output signed[31:0]o\_total\_num
);
reg[9:0]cnt;
always @(posedge i\_clk or posedge i\_rst)
begin
if(i\_rst)
begin
cnt <= 10'd0;
end
else begin
if(cnt == 79)
cnt <= 10'd0;
else
cnt <= cnt+10'd1;
end
end
reg dat\_clk;
always @(posedge i\_clk or posedge i\_rst)
begin
if(i\_rst)
begin
dat\_clk <= 1'd0;
end
else begin
if(cnt == 39)
dat\_clk <= 1'd1;
else
dat\_clk <= 1'd0;
end
end
T16PSK T16PSKU(
.i\_clk (dat\_clk),
.i\_clksample(i\_clk),
.i\_rst (i\_rst),
.i\_en (i\_en),
.i\_dat (i\_dat),
.o\_ISET (o\_ISET),
.o\_clk\_3div(),
.o\_I16psk(o\_I16psk),
.o\_Q16psk(o\_Q16psk),
.o\_Ifir (o\_Ifir\_T),
.o\_Qfir (o\_Qfir\_T),
.o\_cos (),
.o\_sin (),
.o\_modc (),
.o\_mods (),
.o\_mod (o\_mod\_T)
);
//加入信道
awgns awgns\_u(
.i\_clk(i\_clk),
.i\_rst(i\_rst),
.i\_SNR(i\_SNR), //这个地方可以设置信噪比，数值大小从-10~50，
.i\_din(o\_mod\_T[28:13]),
.o\_noise(),
.o\_dout(o\_Nmod\_T)
);
16PSK解调
R16PSK R16SKU(
.i\_clk (dat\_clk),
.i\_clksample(i\_clk),
.i\_rst (i\_rst),
.o\_clk\_3div(),
.i\_med (o\_Nmod\_T),
.o\_cos (),
.o\_sin (),
.o\_modc (o\_modc\_R),
.o\_mods (o\_mods\_R),
.o\_Ifir (o\_Ifir\_R),
.o\_Qfir (o\_Qfir\_R),
.o\_wbits(o\_wbits),
.o\_bits (o\_bits),
.o\_bits\_head(o\_bits\_head),
.o\_peak(o\_peak),
.o\_en\_data(o\_en\_data),
.o\_en\_pn(o\_en\_pn),
.o\_frame\_start(o\_frame\_start)
);
Error\_Chech Error\_Chech\_u1(
.i\_clk(dat\_clk),
.i\_rst(i\_rst),
.i\_trans({~i\_dat,1'b1}),
.i\_en\_data(o\_en\_data),
.i\_rec({~o\_bits,1'b1}),
.o\_error\_num(o\_error\_num),
.o\_total\_num(o\_total\_num)
);
endmodule
0sj2\_066m
## 4.完整算法代码文件获得
\*\*V\*\*