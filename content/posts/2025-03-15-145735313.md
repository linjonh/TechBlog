---
layout: post
title: "背诵-2"
date: 2025-03-15 21:46:55 +0800
description: "如果运算中，数据的范围超过了long类型后，可以使用BigInteger类实现，该类的计算整数是不限制长度的。4.数组即可以存储基本数据类型的数据,又可以存储引用数据类型的数据 int[] double[] String[] Student[]注意:局部内部类生产的class含有$(1,2,3指的是外部类中第1个,第2个…调用的是其他语言编写的代码或者操作系统底层的代码,看不到具体的方法。native修饰的方法:说明这个方法不是java语言编写的。3.集合的长度是可以变化的(添加元素,删除集合中的元素)"
keywords: "背诵--2"
categories: ['Javase']
tags: ['Java']
artid: "145735313"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145735313
    alt: "背诵-2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145735313
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145735313
cover: https://bing.ee123.net/img/rand?artid=145735313
image: https://bing.ee123.net/img/rand?artid=145735313
img: https://bing.ee123.net/img/rand?artid=145735313
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     背诵--2
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="DAY01__0">
     </a>
     DAY01 面向对象回顾、继承、抽象类
    </h2>
    <h3>
     <a id="_1">
     </a>
     学习目标
    </h3>
    <pre><code>能够写出类的继承格式
	public class 子类 extends 父类{}
	public class Cat extends Animal{}
能够说出继承的特点
	子类继承父类,就会自动拥有父类非私有的成员
能够说出子类调用父类的成员特点
	1.子类有使用子类自己的
	2.子类没有使用,继承自父类的
	3.子类父类都没有编译报错
能够说出方法重写的概念
	发生在两个类之间
	子类出现了和父类一模一样(返回值类型,方法名,参数列表,修饰符子类大于等于父类)的方法,叫方法重写(Override)
能够说出this可以解决的问题
	1.this.变量名:代表本类的成员变量
	2.this.方法名称():代表本类的成员方法
	3.this(),this(参数):代表调用本类其他的构造方法
能够说出super可以解决的问题
	1.super.变量名:代表父类的成员变量
	2.super.方法名称():代表父类的成员方法
	3.super(),super(参数):代表调用父类的构造方法
描述抽象方法的概念
	没有方法体,被abstract修饰的方法
写出抽象类的格式
	public abstract class 类名{};
写出抽象方法的格式
	权限修饰符 abstract 返回值类型 方法名(参数);
	public abstract void aaa();
	public abstract int bbb();
	public abstract int ccc(String s);
能够说出父类抽象方法的存在意义
	在抽象类中定义类抽象方法,那么子类就必须重写这个抽象方法
	公司中所有的员工都必须工作
	作为模版:让子类强制重写抽象方法,不同的子类添加不同的方法体
</code></pre>
    <h3>
     <a id="this_38">
     </a>
     this关键字
    </h3>
    <pre><code class="prism language-java">
<span class="token comment">/*
    this关键字:
        代表本类对象的引用==&gt;根据类创建的对象
        哪个对象调用的方法,方法中的this就是哪个对象

    this关键字作用:当局部变量和成员变量重名时,使用this关键字可以区分局部变量和成员变量
        this.变量名==&gt;成员变量
 */</span>
</code></pre>
    <h3>
     <a id="_51">
     </a>
     对象的内存图
    </h3>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/db8194f6b6d249bbacafa897796c8d6e.png"/>
    </p>
    <h3>
     <a id="_53">
     </a>
     匿名对象
    </h3>
    <pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>demo03Object</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>

<span class="token comment">/*
    匿名对象:
        创建对象时,只有创建对象的语句,没有把对象赋值给某个变量,这个对象叫匿名对象
        没有名字的对象
    特点:
        只能使用一次,使用完毕会被JVM在空闲的时候进行垃圾回收
    好处:
        可以节约内存,可以提高程序的效率
    作用:
        一般可以作为方法的参数和返回值使用
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01Animal</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建一个有名字的对象:可以重复使用</span>
        <span class="token class-name">Animal</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a1<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a1<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//创建一个匿名对象:只能使用一次</span>
        <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果想要在使用匿名对象,需要重新创建</span>
        <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">"熊大"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用show方法,创建Animal对象为变量a2赋值</span>
        <span class="token function">show</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果方法的参数传递的对象只使用一次,就可以使用匿名对象</span>
        <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">"熊二"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用getAnimal方法</span>
        <span class="token comment">//Animal a4 = getAnimal();==&gt; new Animal("光头强");</span>
        <span class="token class-name">Animal</span> a4 <span class="token operator">=</span> <span class="token function">getAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a4<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//对象只使用一次,就可以使用匿名对象</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">"加菲猫"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*
        定义一个方法,方法的参数使用Animal类型
        Animal a2 = a1 = new Animal("Tom");
        Animal a2 = new Animal("熊二")
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Animal</span> a2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        a2<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*
        定义一个方法,方法的返回值类型使用Animal
            方法的返回值类型是Animal,就必须在方法中创建一个Animal对象返回
            方法的返回值类型是int,就必须在方法中返回一个整数
            ...
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Animal</span> <span class="token function">getAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//Animal a3 = new Animal("光头强");</span>
        <span class="token comment">//return a3;</span>
        <span class="token comment">//对象只使用一次,就可以使用匿名对象</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">"光头强"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_122">
     </a>
     继承
    </h3>
    <pre><code class="prism language-java">继承的概念：子类继承父类，子类就会自动拥有父类非私有的成员变量和成员方法。
继承的特点：
	子类继承父类，子类就会自动拥有父类非私有的成员变量和成员方法
	在子类中可以定义子类特有的成员
继承的注意事项：
	<span class="token number">1.</span>构造方法是不能继承的，构造方法是本类创建对象使用的
	<span class="token number">2.</span>父类私有成员子类是不能继承的
继承后的特点—成员变量：
	<span class="token number">1.</span>子类有使用子类自己的成员变量
	<span class="token number">2.</span>子类没有使用子类继承自父类的成员变量
	<span class="token number">3.</span>子类和父类都没有<span class="token punctuation">,</span>编译报错
继承后的特点—成员方法：
	<span class="token number">1.</span>子类有使用子类自己的成员方法
	<span class="token number">2.</span>子类没有使用子类继承自父类的成员方法
	<span class="token number">3.</span>子类和父类都没有<span class="token punctuation">,</span>编译报错
</code></pre>
    <h3>
     <a id="_142">
     </a>
     方法重写
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    方法重写:发生在两个类之间,在子类中出现了和父类一模一样的方法,叫方法重写(Override)
        一模一样:
            方法名一样
            参数列表一样
            返回值类型一样
            修饰符一样(子类的修饰符权限大于等于父类的修饰符)
        注解:
            @Override:检查方法是否为重写的方法
   ------------------------------------------------------------
   方法重载:发生在一个类中,在一个类中出现了方法名相同,但是参数列表不同的方法,叫方法重载(Overload)
 */</span>
</code></pre>
    <h3>
     <a id="thissuper_158">
     </a>
     this和super
    </h3>
    <pre><code class="prism language-java">    <span class="token comment">/*
        继承后的特点—构造方法
        在子类构造方法的第一行,有一个默认的super();
        super();作用就是调用父类的空参数构造方法
        子类继承父类,子类想要使用继承自父类的成员,就必须把父类加载到内存中,调用父类的构造方法创建父类对象
        父类进入到内存中,子类才可以使用父类的成员
     */</span>
</code></pre>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/6c7ffe6e37814bff9b7b85291a25a899.png">
      <br/>
      <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/39bf5a86d18b4c44bdaef3a103f2e8fc.png"/>
     </img>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    this关键字:本类对象的引用(根据Cat创建的对象)
        this.成员变量:本类的成员变量
        this.成员方法(参数):本类的成员方法
    super关键字:父类对象的引用(根据Animal创建的对象)
        super.成员变量:父类的成员变量
        super.成员方法(参数):父类的成员方法
 */</span>
 <span class="token comment">/*
    this关键字:可以调用本类其他的构造方法
    格式:
        this();调用空参数构造方法
        this(参数);调用带参数构造方法
    注意:
        1.this();|this(参数);调用构造方法必须写在构造方法中的第一行,创建对象必须优先执行
        2.构造方法不能相互调用(不能你调用我,我在调用你--&gt;死循环)
 */</span>
 <span class="token comment">/*
    super关键字:调用父类的构造方法
    格式:
        super();调用父类的空参数构造方法
        super(参数);调用父类带参数构造方法
    注意:
        1.在子类的构造方法中没有写super();有一个默认的super();用于调用父类的空参数构造方法
        2.super();|super(参数);必须写在子类构造方法有效代码的第一行,构造方法必须优先执行
        3.在子类的构造方法中this和super不能同时出现,都必须写在有效代码第一行
 */</span>
</code></pre>
    <h2>
     <a id="DAY02_finalstatic_201">
     </a>
     DAY02 final关键字、static关键字、接口
    </h2>
    <h3>
     <a id="_202">
     </a>
     学习目标
    </h3>
    <pre><code>描述final修饰的类的特点
	//是一个最终类不能被继承,是一个太监类
描述final修饰的方法的特点
	//是一个最终方法,可以被继承使用,但是不能被重写
描述final修饰的变量的特点
	//是一个常量,值不能改变
	局部变量:定义在方法中的变量
		基本数据类型:值不能改变
		引用数据类型(数组,对象,集合...):地址值不能改变
	成员变量:定义在成员位置,类中方法外
		保证在创建对象前赋值
			1.可以定义变量的时候直接赋值
			2.可以使用构造方法给变量赋值
能够掌握static关键字修饰的变量调用方式
	类名.静态成员变量
	public class Person{
		static int a = 10;
	}
	Person.a;
能够掌握static关键字修饰的方法调用方式
	类名.静态成员方法(参数);
	public class Person{
		public static void show(int a){}
	}
	Person.show(10);
能够写出接口的定义格式
	public interface 接口名{
		抽象方法 public abstract 返回值类型 方法名(参数);
		默认方法 public default 返回值类型 方法名(参数){方法体}
		静态方法 public static 返回值类型 方法名(参数){方法体}
	}
能够写出接口的实现格式
	public class 实现类 implements 接口{}
能够说出接口中的成员特点
	变量:接口中的变量都是常量,有固定的修饰符 public static final int AAA = 10;
	方法:抽象方法(需实现类重写) 默认方法(实现类可以选择性重写) 静态方法(不能重写,使用接口名直接调用)
	接口中没有构造方法,不能创建对象
</code></pre>
    <h3>
     <a id="final_243">
     </a>
     final关键字
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    final修饰的类:是一个最终类,不能被继承;其他的使用方式不变(继承其他的类,创建对象使用...)
    简单记:太监类
*/</span>
<span class="token comment">/*
    final修饰的方法:是一个最终方法,可以被继承使用,但是不能被重写
 */</span>
 <span class="token comment">/*
    final修饰的变量:是一个常量,值不能改变
    局部变量:定义在方法中的变量(语句中for)
    final修饰符是局部变量唯一的修饰符
    引用数据类型(数组,类,集合...):地址值不能改变
    对象中的内容是可以改变的(成员变量的值,数组中的元素,集合中的元素...)
 */</span>
 <span class="token comment">/*
    final修饰的成员变量:是一个常量,值不能改变
    特点:特殊记忆
        final修饰的成员变量必须在创建对象前赋值(规定)
    注意:
        1.成员变量的默认值(String=&gt;null,int==&gt;0,doble=&gt;0.0,boolean==&gt;false),不是final修饰的成员变量的值,必须赋一个具体值
        2.赋值的方式:
            a.直接赋值:定义变量,直接给变量赋值
            b.使用构造方法赋值,构造方法是创建对象前执行
            无论哪种赋值方式,只能赋值一次
        3.常量的命名规则:一般都使用大写字母
            final int  AAA_BBB_CCC = 10;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//final int a;//Variable 'a' might not have been initialized</span>

    <span class="token comment">//a.直接赋值:定义变量,直接给变量赋值</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token class-name">String</span> d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">//b.使用构造方法赋值,构造方法是创建对象前执行</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token comment">//b = 100;//Cannot assign a value to final variable 'b' 无论哪种赋值方式,只能赋值一次</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        c<span class="token operator">=</span>e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="static_295">
     </a>
     static关键字
    </h3>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/cae2f615efe94f6b92cd1142e3f79cd5.png">
      <br/>
      <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/951c27d119204949af04d1e0f25369e5.png"/>
     </img>
    </p>
    <h3>
     <a id="_298">
     </a>
     接口
    </h3>
    <pre><code class="prism language-java">接口<span class="token operator">:</span>是引用数据类型的一种<span class="token punctuation">,</span>是功能的集合<span class="token punctuation">(</span>接口中定义的都是方法<span class="token punctuation">)</span>
    接口中不能定义变量<span class="token punctuation">,</span>可以定义常量<span class="token punctuation">(</span>很少使用<span class="token punctuation">)</span>
定义接口使用的也是<span class="token punctuation">.</span>java文件<span class="token punctuation">;</span>编译生成的也是<span class="token punctuation">.</span><span class="token keyword">class</span>文件
定义接口使用关键字<span class="token keyword">interface</span>
定义格式<span class="token operator">:</span>
	修饰符 <span class="token keyword">interface</span> 接口名<span class="token punctuation">{<!-- --></span>
        抽象方法<span class="token punctuation">;</span><span class="token punctuation">(</span>jdk7<span class="token punctuation">)</span>重点
        默认方法<span class="token punctuation">;</span><span class="token punctuation">(</span>jdk8<span class="token punctuation">)</span>
        静态方法<span class="token punctuation">;</span><span class="token punctuation">(</span>jdk8<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token comment">/*
    接口的多实现:类可以同时实现多个接口
    格式:
        public class 实现类 implements 接口1,接口2,接口3....接口n{
            重写所有接口中的抽象方法
        }
     注意:
        接口中含有抽象方法,实现类需要重写所有接口的抽象方法
        如果接口中有同名的抽象方法,实现类只重写一个就可以了
        不会产生不确定性,抽象方法没有方法体
 */</span>
 
<span class="token comment">/*
    接口的多实现:类实现含有默认方法的多个接口
    格式:
        public class 实现类 implements 接口1,接口2,接口3....接口n{
        }
    注意:
        1.如果接口中的默认方法不重复,实现类可以选择重写或者不重写默认方法
            重写:使用实现类重写的
            不重写:使用继承自接口的
        2.如果多个接口中默认方法有重复的,实现类必须重写这个重复的默认方法
            有不确定性,实现类不知道使用继承自哪个接口的默认方法,重写之后使用自己的
 */</span>
<span class="token comment">/*
    接口的多实现:实现类实现含有静态方法的多个接口
    格式:
        public class 实现类 implements 接口1,接口2,接口3....接口n{
        }
    注意:
        1.实现类实现含有静态方法的接口,没有意义;静态方法实现类不能继承,也不能重写
        2.接口中静态方法有重复的,不会冲突,静态方法属于每个接口本身
 */</span>
<span class="token comment">/*
    接口中其他成员的特点(使用)
        1.接口中是无法定义成员变量的,但是可以定义常量,常量的值不能改变
            默认使用的修饰符public static final,接口中的常量修饰符可以省略不写,默认默认也是public static final
            常量的命名规则:所有的单词都要大写,多个单词之间使用下划线连接
                AAA_BBB_CCC
                定义一些常用的常量:
                    公司的名称:"江苏省传智播客股份有限公司北京分公司"
                    公司的网址: www.itcast.cn    www.itheima.com
                    公司地址: 昌平区建材城西路金燕龙办公楼一层
       2.接口中,没有构造方法,不能创建对象
       3.接口中,没有静态代码块(讲代码块的时候在说)
 */</span> 
</code></pre>
    <h2>
     <a id="DAY03__358">
     </a>
     DAY03 多态、内部类、权限修饰符、代码块
    </h2>
    <h3>
     <a id="_359">
     </a>
     学习目标
    </h3>
    <pre><code>能够说出多态的前提
	//有子父类继承关系|有类和接口的实现关系
能够写出多态的格式
	//父类的类型 变量名 = new 子类对象();
	Animal a = new Cat();
	Animal a = new Dog();
	//接口的类型 变量名 = new 实现类对象();
	Fly f = new MaQue();
能够理解多态向上转型和向下转型
	//向上转型:多态本身就是向上转型
		格式:
			父类的类型 变量名 = new 子类对象();
			接口的类型 变量名 = new 实现类对象();
			Animal a = new Cat();
			a = new Dog();
		好处:
			扩展性强,可以赋值不同的子类对象,调用不同子类重写的方法
		弊端:
			无法使用子类特有的成员变量和成员方法
	//向下转型:前提必须是多态,可以把父类的类型强制转换为子类类型
		格式:
			子类类型 变量名 = (子类类型)父类变量名;
			Cat c = (Cat)a;
			c.catchMouse();
		好处:
			可以使用子类特有的内容
能够说出内部类概念
	//把类定义在其他类的内部
		成员内部类:类定义在其他类的成员位置
		局部内部类:类定义在其他类的方法中
		注意:局部位置唯一可以使用的修饰符就是final
能够理解匿名内部类的编写格式(new 爹(亲爹父类,干爹接口))
	作用:简化代码
		把子类继承父类,重写父类的方法,创建子类对象合成一步完成;
		把实现类实现接口,重写接口中的方法,创建实现类对象合成一步完成;
	格式:
		new 父类|接口(){
			重写父类|接口中方法;
		};
		new Animal(){
			public void eat(){}
			public void sleep(){}
		}.eat();
		new Fly(){
			public void fly(){}
		}.fly();
能够说出每种权限修饰符的作用
	private:只能在本类中使用
	默认(不写):既能在本类中使用,又能在本包的其他类中使用
	protected:既能在本类中使用,又能在本包的其他类中使用,还能在不同包的子类中使用
	public:本项目中的任意包,任意的类中都可以使用
	需要记住(重点):
		1.privare使用:定义成员变量,需要私有(封装)
		2.public使用:定义成员方法,定义构造方法,定义类
代码块:
	静态代码块:只执行一次,优先执行
</code></pre>
    <h3>
     <a id="_419">
     </a>
     多态
    </h3>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/79f38cfe093643e59513aff312aa67df.png">
      <br/>
      <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/44d16673efd048ba8f8d45825c159520.png"/>
     </img>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    多态的转型:
        1.向上转型:多态本身就是向上转型,把子类对象赋值给父类的变量
            格式:
                父类类型 变量名 = new 子类对象():
            好处:
                扩展性强,可以赋值不同的子类对象,而调用不同子类重写后的方法
            --------------------------------------------------------------
            int a = 10;
            double d = a;
        2.向下转型:把父类类型的变量强制转换为子类类型(强转)
            格式:
                子类类型 变量名 = (子类类型)父类变量名;
            好处:
                强制之后,多态变量变成了子类类型,就可以使用子类特有的功能
            注意:
                a.向下转型前提,必须是多态
                b.直接创建父类对象,不能向下转型
            -----------------------------------------------------------------
            double d = 5.5;
            int a = (int)d;
 */</span>
 <span class="token comment">/*
    向下转型:有可能发生类型转换异常
    ClassCastException: com.itheima.demo02duotai.Cat cannot be cast to com.itheima.demo02duotai.Dog
    猫不能转换为狗

    instanceof关键字:判断某个对象是否属于某种数据类型
    格式:
        boolean b = 对象 instanceof 数据类型;
        对象属于对应的数据类型,返回true
        对象不属于对应的数据类型,返回false
    使用前提:
        对象根据类创建的(对象所属的类和判断的数据类型之间必须有继承或者实现关系)
 */</span>
</code></pre>
    <h3>
     <a id="_460">
     </a>
     内部类
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    内部类:定义在其他类内部的类
    分类:
        成员内部类:内部类定义在其他类的成员位置(类中方法外)
        局部内部类:内部类定义在其他类的方法中
    重点:记住固定格式
    ---------------------------------------------------------------
    成员内部类:
        定义格式:
            修饰符 class 外部类{
                修饰符 class 成员内部类名{
                    内部类的成员变量
                    内部类的成员方法
                }
            }
        使用格式:通过外部类来找到内部类
            外部类名.内部类名 变量名 = new 外部类().new 内部类();
            变量名.内部类的成员变量
            变量名,内部类的成员方法();
   注意:
       1.在内部类中可以直接使用外部类的成员变量和成员方法
       2.内部类只是定义在其他类的内部,其他的使用方式不变,也可以继承其他的类,也可以实现接口
 */</span>
</code></pre>
    <p>
     <strong>
      注意:内部类生成的class文件含有$
     </strong>
     <br/>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/0f9110375860471688ffffcbd3e25c1c.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    局部内部类:定义在其他类的方法中
    定义格式:
        修饰符 class 外部类名{
            修饰符 返回值类型 外部类方法名(参数){
                (final)class 局部内部类名{
                    内部类的成员变量,
                    内部类的成员方法();
                }
            }
        }
    使用格式:局部内部类的使用范围就是在方法中有效
        使用方式就是在方法中定义完局部内部类之后,直接创建局部内部类对象使用
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//定义一个外部类的成员方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//定义局部内部类(局部变量唯一可以使用的修饰符final 面试)</span>
        <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//定义局部内部类的成员变量</span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">//定义局部内部类的成员方法</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"局部内部类Inner的成员方法inner!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//定义完局部内部类之后,直接创建局部内部类对象使用</span>
        <span class="token class-name">Inner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//final int aa = 10;</span>
        <span class="token comment">//System.out.println(aa);</span>

    <span class="token punctuation">}</span>

    <span class="token comment">//定义一个外部类的成员方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//定义局部内部类(局部变量唯一可以使用的修饰符final 面试)</span>
        <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//定义局部内部类的成员变量</span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">//定义局部内部类的成员方法</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"局部内部类Inner的成员方法inner!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//定义完局部内部类之后,直接创建局部内部类对象使用</span>
        <span class="token class-name">Inner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//final int aa = 10;</span>
        <span class="token comment">//System.out.println(aa);</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     注意:局部内部类生产的class含有$(1,2,3指的是外部类中第1个,第2个…方法)
     <br/>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/2b135bc41e254439bdac1ee5a2b63790.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    匿名内部类(重点):
        匿名:创建内部类,不像Cat.Dog有类名,没有具体的类名
        内部类:是一个局部内部类(写在方法中)
    作用:简化代码
        把子类继承父类,重写父类的方法,创建子类对象合成一步完成
        把实现类实现接口,重写接口中的方法,创建实现类对象合成一步完成
    格式:
        new 父类|接口(){
            重写父类|接口中的方法;
        };
     ------------------------------------------------
     new Animal(){
        @Override
        public void eat() {
            System.out.println("动物在吃饭");
        }
        @Override
        public void sleep() {
            System.out.println("动物在睡觉!");
        }
    };
    以上一堆代码就是一个创建子类对象的过程,相当于new Cat();
 */</span>
</code></pre>
    <h3>
     <a id="_580">
     </a>
     权限修饰符
    </h3>
    <table>
     <thead>
      <tr>
       <th>
       </th>
       <th>
        public
       </th>
       <th>
        protected
       </th>
       <th>
        default（空的）
       </th>
       <th>
        private
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        同一类中
       </td>
       <td>
        √
       </td>
       <td>
        √
       </td>
       <td>
        √
       </td>
       <td>
        √
       </td>
      </tr>
      <tr>
       <td>
        同一包中(子类与无关类)
       </td>
       <td>
        √
       </td>
       <td>
        √
       </td>
       <td>
        √
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        不同包的子类
       </td>
       <td>
        √
       </td>
       <td>
        √
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        不同包中的无关类
       </td>
       <td>
        √
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="_588">
     </a>
     代码块
    </h3>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> sex<span class="token punctuation">;</span>

    <span class="token comment">/*
        2.构造代码块:写在成员位置(类中方法外)的代码块
        特点:
            优先于构造方法执行,每创建一次对象,都会执行一次
        作用:
            1.可以给成员变量赋初始化值
            2.可以把每个构造方法中的共性内容提取出来,写在构造代码块中,可以提高代码复用性
                需求:无论使用空参数|带参数构造方法创建对象,都先打印10次HelloWorld
     */</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//1.可以给成员变量赋初始化值</span>
        name <span class="token operator">=</span> <span class="token string">"张三"</span><span class="token punctuation">;</span>
        age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造代码块!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2.可以把每个构造方法中的共性内容提取出来,写在构造代码块中</span>
        <span class="token comment">/*for (int i = 1; i &lt;=10 ; i++) {
            System.out.println("HelloWorld"+i);
        }*/</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*
        3.静态代码块:写在成员位置(类中方法外)被static修饰的代码块
        特点:
            static修饰的成员属于类,不属于某一个对象,被所有的对象所共享
            所以我们无论创建多少次对象,静态代码块只执行一次
            静态优先于非静态加载到内存中,优先于构造代码块和构造方法执行
        作用:
            1.可以给静态的成员变量赋初始化值
            2.在项目启动的时候,可以做一些初始化的设计(只执行一次 数据库)
     */</span>
    <span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span>
        sex <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/*for (int i = 1; i &lt;=10 ; i++) {
            System.out.println("HelloWorld"+i);
        }*/</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Student类的空参数构造方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/*for (int i = 1; i &lt;=10 ; i++) {
            System.out.println("HelloWorld"+i);
        }*/</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Student类的带参数构造方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> sex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setSex</span><span class="token punctuation">(</span><span class="token class-name">String</span> sex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Student</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>     
</code></pre>
    <pre><code class="prism language-java"><span class="token comment">/*
    代码块:被{ }包裹起来的代码叫代码块
        1.局部代码块:写在方法中的代码块
        2.构造代码块:写在成员位置(类中方法外)的代码块
        3.静态代码块:写在成员位置(类中方法外)被static修饰的代码块
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/*
            1.局部代码块:写在方法中的代码块
            作用:修改变量的作用域,提高程序的效率
            变量的作用域:在变量所在的{ }的范围内有效,出了作用域,就会被垃圾回收
         */</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">//System.out.println(a);</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//System.out.println(a);//Cannot resolve symbol 'a'</span>

        <span class="token comment">//for (int i = 0; i &lt; 10; i++) {<!-- --></span>
        <span class="token comment">//    System.out.println(i);</span>
        <span class="token comment">//}</span>
        <span class="token comment">//System.out.println(i);//Cannot resolve symbol 'i'</span>

        <span class="token class-name">Student</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Student</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"柳岩"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>s1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="DAY04_ObjectDateDateFormatCalendarMathSystem_706">
     </a>
     DAY04 Object、Date类、DateFormat类、Calendar类、Math类、System类
    </h2>
    <h3>
     <a id="_707">
     </a>
     学习目标
    </h3>
    <pre><code class="prism language-java">能够说出<span class="token class-name">Object</span>类的特点
	是所有类的祖宗类<span class="token punctuation">,</span>任意的一个类都直接或者间接的继承了<span class="token class-name">Object</span>类<span class="token punctuation">,</span>都可以使用<span class="token class-name">Object</span>类中的方法
	<span class="token class-name">Animal</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token operator">:</span>直接继承
	<span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token operator">:</span>间接继承
能够重写<span class="token class-name">Object</span>类的toString方法
	alt<span class="token operator">+</span>insert<span class="token punctuation">,</span>选择toString
能够重写<span class="token class-name">Object</span>类的equals方法
	alt<span class="token operator">+</span>insert<span class="token punctuation">,</span>选择equals and hashCode
能够使用日期类输出当前日期
	<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span>
	<span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sout</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Mon Apr 27 15:55:03 CST 2020</span>
能够使用将日期格式化为字符串的方法
	<span class="token comment">//1.创建SimpleDateFormat对象,构造方法中传递指定的模式   </span>
    <span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy年MM月dd日 HH时mm分ss秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//2.调用SimpleDateFormat对象中的方法format根据构造方法中传递的模式,把日期格式化为符合模式的字符串</span>
    <span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Wed Mar 18 11:50:38 CST 2020</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2020年03月18日 11时51分32秒</span>
能够使用将字符串转换成日期的方法
	<span class="token comment">//1.创建SimpleDateFormat对象,构造方法中传递指定的模式</span>
    <span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//2.调用SimpleDateFormat对象中的方法format根据构造方法中传递的模式,把日期格式化为符合模式的字符串</span>
	<span class="token class-name">Date</span> date <span class="token operator">=</span>  sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2000-12-12"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Tue Dec 12 00:00:00 CST 2000</span>
能够使用<span class="token class-name">Calendar</span>类的get、set、add方法计算日期
	<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">)</span> 获取给定日历字段的值。
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> 将给定的日历字段设置为给定值。
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span>  把日历字段增加<span class="token operator">|</span>减少指定的值
能够使用<span class="token class-name">Math</span>类对某个浮点数进行四舍五入取整
	<span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">ceil</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span>  向上取整
    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span>  向下取整
	<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span> 四合五入 <span class="token keyword">long</span>。
能够使用<span class="token class-name">System</span>类获取当前系统毫秒值
	<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回以毫秒为单位的当前时间。
</code></pre>
    <h3>
     <a id="Object_746">
     </a>
     Object类
    </h3>
    <ul>
     <li>
      java.
      <strong>
       lang
      </strong>
      .Object 注意:lang包中的类无需导包可以直接使用
     </li>
     <li>
      类
      <code>
       Object
      </code>
      是类层次结构的根类(最顶层的类 祖宗类)。
     </li>
     <li>
      每个类都使用
      <code>
       Object
      </code>
      作为超类。任何一个类都直接或者间接的继承了Object类
     </li>
     <li>
      所有对象（包括数组）都实现这个Object类的方法。
      <strong>
       任何一个类都可以使用Object类中的方法
      </strong>
     </li>
    </ul>
    <pre><code class="prism language-java"><span class="token comment">/*
    Object类中的常用方法:
        String toString() 返回该对象的字符串表示。
    Object类toString方法的底层源码:
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
        getClass().getName():使用反射技术获取类的全类名(包名+类名)
            com.itheima.demo01toString.Person
        "@" :字符串原样输出,分割的作用
        hashCode():Object类中的方法,可以获取对象的哈希值,哈希值是一个系统随机给出的十进制的整数 123123123
        Integer.toHexString(hashCode());把十进制的整数转换为十六进制 0-9 a-f
   组合在一起: com.itheima.demo01toString.Person@AC123(对象在堆内存中的地址值)
 */</span>
<span class="token comment">/*
    Object类中的方法equals:
        boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。
    Object类中的equals方法的源码:
        public boolean equals(Object obj) {
            return (this == obj);
        }
        ==:比较运算符
            基本数据类型:比较的是值是否相等  10==20
            引用数据类型(数组,集合,类Person):比较的是地址值是否相等  @1ac1==@223
 */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/*
            如果obj就是this本身,那么就没有比较在强转进行属性的比较,直接返回true,可以提高效率
         */</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/*
            如果obj的值是null,那么直接返回false,可以提高程序的效率
         */</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/*
            ClassCastException: java.util.Random cannot be cast to com.itheima.demo02equals.Student
            为了防止类在转换异常,强转之前使用instanceof关键字进行判断
         */</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">/*
                问题:多态==&gt;无法使用子类特有的成员==&gt;需要向下转型
                Object obj = s2 = new Student("韦德",38);
             */</span>
            <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
            <span class="token comment">//比较this(s1)和s(obj=s2)两个对象的属性name和age</span>
            <span class="token comment">//             詹姆斯          韦德         35           38</span>
            <span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">==</span> s<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
            <span class="token keyword">return</span> b<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//obj不是Student,直接返回false</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <p>
     native修饰的方法:说明这个方法不是java语言编写的
    </p>
    <p>
     调用的是其他语言编写的代码或者操作系统底层的代码,看不到具体的方法
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Object</span><span class="token operator">:</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="Objects_824">
     </a>
     Objects对象的工具类(了解)
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    java.util.Objects类:操作对象的工具类,里边的方法都是静态的
    Objects中的方法都是防止空指针异常的
    注意:
        工具类中的方法一般都是静态的,可以通过类名直接使用
    Obejcts工具类中的equals方法
        static boolean equals​(Object a, Object b) :判断两个对象是否相等,相等返回true,不相等返回false
    底层源码:
        public static boolean equals(Object a, Object b) {
            return (a == b) || (a != null &amp;&amp; a.equals(b));
        }
 */</span>
</code></pre>
    <h3>
     <a id="Date_840">
     </a>
     Date类
    </h3>
    <pre><code class="prism language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span>类<span class="token operator">:</span>用于描述日期和时间的类
	类 <span class="token class-name">Date</span> 表示特定的瞬间，精确到毫秒。
	<span class="token number">1</span>秒<span class="token operator">=</span><span class="token number">1000</span>毫秒
	<span class="token number">1</span> 天 <span class="token operator">=</span> <span class="token number">24</span> × <span class="token number">60</span> × <span class="token number">60</span> <span class="token operator">=</span> <span class="token number">86400</span> 秒 <span class="token operator">=</span> <span class="token number">86400</span><span class="token operator">*</span><span class="token number">1000</span> <span class="token operator">=</span> <span class="token number">86400000</span>毫秒
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
时间原点<span class="token operator">:</span><span class="token number">0</span>毫秒的时间点
	<span class="token number">1970</span> 年 <span class="token number">1</span> 月 <span class="token number">1</span> 日 <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>  英国格林威治时间<span class="token punctuation">(</span>世界标准时间<span class="token punctuation">)</span>
中国<span class="token operator">:</span>东八区 时间<span class="token operator">+</span><span class="token number">8</span>个小时的时差
	<span class="token number">1970</span> 年 <span class="token number">1</span> 月 <span class="token number">1</span> 日 <span class="token number">08</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>
把日期和时间转换为毫秒值<span class="token operator">:</span>就是时间原点和当前时间的一个差值
	当前时间<span class="token punctuation">(</span><span class="token number">2020</span>年<span class="token number">4</span>月<span class="token number">27</span>日<span class="token number">11</span><span class="token operator">:</span><span class="token number">26</span><span class="token operator">:</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token operator">-</span>时间原点<span class="token punctuation">(</span><span class="token number">1970</span>年<span class="token number">1</span>月<span class="token number">1</span>日 <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token punctuation">)</span><span class="token operator">=</span>把当前时间转换为毫秒值<span class="token punctuation">(</span><span class="token number">12312412514312</span><span class="token punctuation">)</span>
毫秒值的作用<span class="token operator">:</span>用于对时间进行计算
工作<span class="token operator">:</span>计算两个时间的差值<span class="token punctuation">,</span>把时间转换为毫秒值计算
	<span class="token string">"2020年4月27日11:26:33"</span> <span class="token operator">-</span> <span class="token string">"2019年3月5日12:26:33"</span> <span class="token operator">=</span> 没法计算
	把时间转换为毫秒值<span class="token punctuation">,</span>使用毫秒值相减
	<span class="token number">15888123123123</span> <span class="token operator">-</span> <span class="token number">15734324324233</span> <span class="token operator">=</span> <span class="token number">324324</span>毫秒<span class="token operator">==</span><span class="token operator">&gt;</span>转换为时间<span class="token punctuation">(</span><span class="token number">324324</span>毫秒<span class="token operator">/</span><span class="token number">1000</span><span class="token operator">/</span><span class="token number">60</span><span class="token operator">/</span><span class="token number">60</span><span class="token operator">/</span><span class="token number">24</span><span class="token punctuation">)</span>天
</code></pre>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/84620de69e7a49b0b079837b8803fb25.png"/>
    </p>
    <h3>
     <a id="DateFormat_861">
     </a>
     DateFormat类
    </h3>
    <pre><code class="prism language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span>DateFormat</span>类
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">DateFormat</span> <span class="token keyword">extends</span> <span class="token class-name">Format</span>
<span class="token class-name">DateFormat</span> 是日期<span class="token operator">/</span>时间格式化子类的抽象类<span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token class-name">DateFormat</span>是<span class="token class-name">Format</span>类的子类<span class="token punctuation">,</span><span class="token class-name">DateFormat</span>本身还是一个抽象类
无法直接创建对象使用
作用<span class="token operator">:</span>
	它以与语言无关的方式格式化并解析日期或时间。
	格式化（也就是日期 <span class="token operator">-&gt;</span> 文本）
	解析（文本<span class="token operator">-&gt;</span> 日期）
<span class="token class-name">DateFormat</span>类的成员方法<span class="token operator">:</span>
	<span class="token class-name">String</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">Date</span> date<span class="token punctuation">)</span> 传递指定的日期<span class="token punctuation">,</span>把日期格式化为符合模式的字符串 
	<span class="token class-name">Date</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> source<span class="token punctuation">)</span> 把符合模式的字符串解析为<span class="token class-name">Date</span>日期
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token class-name">DateFormat</span>本身还是一个抽象类<span class="token punctuation">,</span>无法直接创建对象使用<span class="token punctuation">,</span>需要使用<span class="token class-name">DateFormat</span>类的子类创建对象使用
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span>SimpleDateFormat</span>类 <span class="token keyword">extends</span> <span class="token class-name">DateFormat</span>类
<span class="token class-name">SimpleDateFormat</span>类构造方法
	<span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token class-name">String</span> pattern<span class="token punctuation">)</span> 
          用给定的模式和默认语言环境的日期格式符号构造 <span class="token class-name">SimpleDateFormat</span>。
   参数<span class="token operator">:</span>
	 <span class="token class-name">String</span> pattern<span class="token operator">:</span>传递日期和时间的模式
	 	在模式中写y代表年
        在模式中写<span class="token class-name">M</span>代表月
        在模式中写d代表日
        在模式中写<span class="token class-name">H</span>代表时
        在模式中写m代表分
        在模式中写s代表秒
        在模式中写<span class="token class-name">S</span>代表毫秒
        <span class="token string">"yyyy-MM-dd HH:mm:ss"</span>  <span class="token string">"2020-04-27 11:57:03"</span>
        <span class="token string">"yyyy/MM/dd HH:mm:ss"</span> 
        <span class="token string">"yyyy年MM月dd日 HH时mm分ss"</span>
  注意<span class="token operator">:</span>
	<span class="token number">1.</span>表示模式的字母不能改变<span class="token punctuation">(</span>y<span class="token punctuation">,</span><span class="token class-name">M</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>字母的连接符号可以改变<span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">,</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token number">2.</span>表示模式的字母严格区分大小写    

</code></pre>
    <h3>
     <a id="Calendar_897">
     </a>
     Calendar类
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    java.util.Calendar类:日历类
        我们可以使用Calendar类中的方法获取日历上的字段(年,月,日,时,分,秒...)
        我们可以使用Calendar类中的方法修改日历上的字段的值  2020--&gt;2030  4月--&gt;6月
        我们可以使用Calendar类中的方法把日历上字段的值增加|减少  2020-5=2015  4月+3月=7月
        我们可以使用Calendar类中的方法把日历对象转换为Date日期对象
    Calendar 类是一个抽象类,无法直接创建对象使用,在Calendar类中有一个静态方法叫getInstance
        获取Calendar类的子类对象
        static Calendar getInstance() 使用默认时区和语言环境获得一个日历。
    注意:
        西方的月份:0-11月
        东方的月份:1-12月
        西方的星期:星期日-星期六
        东方的星期:星期一-星期日
 */</span>
</code></pre>
    <h3>
     <a id="Math_916">
     </a>
     Math类(重点)
    </h3>
    <pre><code class="prism language-java">
<span class="token comment">/*
    java.lang.Math类:数学工具类
        Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。
        Math类中的方法都是静态方法,通过类名.方法名(参数)可以直接使用
        Math类中私有了构造方法,不让我们直接创建对象使用  private Math() {}
    成员方法:
        public static int abs(int a) 获取参数a的绝对值：
        public static double ceil(double a) 向上取整  1.1 2.0  1.9  2.0
        public static double floor(double a) 向下取整 1.1 1.0  1.99999 1.0
        public static long round(double a) 四舍五入取整  5.5 6   5.49999 5
        public static double pow(double a, double b) 获取a的b次幂  2^3  2^4
 */</span>
</code></pre>
    <h3>
     <a id="System_933">
     </a>
     System类(重点)
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    java.lang.System类
        System 类包含一些有用的类字段和方法。它不能被实例化(私有了构造方法)。
        里边的方法都是静态的,通过类名.方法名(参数)可以直接使用
    成员方法:
        public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止
        public static native long currentTimeMillis() 返回当前时间(以毫秒为单位)
        public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)  数组复制
 */</span>
</code></pre>
    <h2>
     <a id="DAY05_BigIntegerBigDecimalArraysString_946">
     </a>
     DAY05 BigInteger类、BigDecimal类、Arrays类、包装类、String类、引用类型
    </h2>
    <h3>
     <a id="_947">
     </a>
     学习目标
    </h3>
    <pre><code class="prism language-java">能够说出<span class="token class-name">BigInteger</span>可以解决的问题
	<span class="token comment">//可以操作范围超过long类型的整数</span>
	<span class="token comment">//"11111111232131231233333333333333333333333333333"</span>
能够说出<span class="token class-name">BigDecimal</span>可以解决的问题
	<span class="token comment">//用于小数(浮点数)的精确计算</span>
能够使用<span class="token class-name">Arrays</span>类的sort方法
	<span class="token comment">//static void sort(Object[] a) 根据元素的自然顺序对指定对象数组按升序进行排序。</span>
	<span class="token comment">//int[] arr1 = {1,2,3,7,6,4,9,8,10};</span>
	<span class="token comment">//Arrays.sort(arr1);</span>
	<span class="token comment">//[1, 2, 3, 4, 6, 7, 8, 9, 10]</span>
能够使用<span class="token class-name">Arrays</span>类的toString方法
	<span class="token comment">//static String toString(Object[] a) 对数组进行遍历,把数组中的元素组合成一个字符串返回</span>
	<span class="token comment">//String s = Arrays.toString(arr);</span>
能够说出自动装箱、自动拆箱的概念
	<span class="token comment">//在JDK1.5之后,装箱(int--&gt;Integer)与拆箱(Integer--&gt;int)可以自动转换,无需我们调用方法</span>
能够将基本类型转换为对应的字符串
	<span class="token comment">//1+""  任意的数据类型的值+空字符串,结果都是一个字符串</span>
能够将字符串转换为对应的基本类型
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
能够说出<span class="token class-name">String</span>类常用方法的功能及使用
	<span class="token comment">//String concat(String str) 将指定字符串连接到此字符串的结尾。 把两个字符串连接到一起  "a"+"b"</span>
    <span class="token comment">//boolean contains(String s)  判断字符串中是否包含指定的字符串;包含返回true,不包含返回false    </span>
    <span class="token comment">//boolean endsWith(String suffix)  判断字符串是否以指定的字符串结尾;是返回true,不是返回false</span>
    <span class="token comment">//boolean startsWith(String prefix) 判断字符串是否以指定的字符串开头;是返回true,不是返回false</span>
    <span class="token comment">//int indexOf(String str) 从前往后在字符串中查找另外一个字符串,找到了返回字符串对应的索引,</span>
    <span class="token comment">//int lastIndexOf(int ch)  从后往前在字符串中查找另外一个字符串,找到了返回字符串对应的索引,</span>
    <span class="token comment">//String replace(String target, String replacement)  把大的字符串中所有的目标字符串,替换为新的字符串</span>
    <span class="token comment">//String substring(int beginIndex) 从开始索引beginIndex截取字符串到字符串的末尾</span>
    <span class="token comment">//String substring(int beginIndex, int endIndex)  从开始索引beginIndex到结束索引endIndex截取字符串;包含头,不包含尾</span>
    <span class="token comment">//char[] toCharArray() 将此字符串转换为一个新的字符数组。</span>
    <span class="token comment">//byte[] getBytes()  查询系统默认的编码把字符串转换为字节数组</span>
    <span class="token comment">//String toLowerCase()  把字符串中所有的英文字符转换为小写 "abc123你好"==&gt;"ABC123你好"</span>
    <span class="token comment">//String toUpperCase()  把字符串中所有的英文字符转换为大写 "ABC123你好"==&gt;"abc123你好"</span>
    <span class="token comment">//String trim() 去掉字符串两端的空格 "       abc   def   www    "==&gt;"abc   def   www"</span>
    <span class="token comment">//String[] split(String regex)  根据自定的字符串对字符串进行切割</span>
能够在不同的位置使用引用类型
	<span class="token comment">//引用数据类型和基本数据类型的使用方式是一样的,只是引用数据类型传递都是地址</span>
	<span class="token comment">//可以作为方法的参数  public static void show(Person p){}</span>
	<span class="token comment">//可以作为方法的返回值类型 public static Person getPerson{return new Person()}</span>
	<span class="token comment">//可以作为成员变量 private Person person;</span>
</code></pre>
    <h3>
     <a id="BigInteger_990">
     </a>
     BigInteger类(重点)
    </h3>
    <p>
     java.math.BigInteger 类，不可变的任意精度的整数。如果运算中，数据的范围超过了long类型后，可以使用BigInteger类实现，该类的计算整数是不限制长度的。
    </p>
    <p>
     BigInteger(String value) 将 BigInteger 的十进制字符串表示形式转换为 BigInteger。超过long类型的范围，已经不能称为数字了，因此构造方法中采用字符串的形式来表示超大整数，将超大整数封装成BigInteger对象。
    </p>
    <p>
     BigInteger类提供了对很大的整数进行加、减、乘、除的方法，注意：都是与另一个BigInteger对象进行运算。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        方法声明
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        add(BigInteger value)
       </td>
       <td>
        返回其值为 (this + val) 的 BigInteger，超大整数加法运算
       </td>
      </tr>
      <tr>
       <td>
        subtract(BigInteger value)
       </td>
       <td>
        返回其值为 (this - val) 的 BigInteger，超大整数减法运算
       </td>
      </tr>
      <tr>
       <td>
        multiply(BigInteger value)
       </td>
       <td>
        返回其值为 (this * val) 的 BigInteger，超大整数乘法运算
       </td>
      </tr>
      <tr>
       <td>
        divide(BigInteger value)
       </td>
       <td>
        返回其值为 (this / val) 的 BigInteger，超大整数除法运算，除不尽取整数部分
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="BigDecimal_1004">
     </a>
     BigDecimal类(重点)
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    java.math.BigDecimal类
        用于浮点数(小数)的精确计算
        以后想进行小数的精确计算,不要使用float和double,使用BigDecimal类
    构造方法:
        BigDecimal(String val) 将 BigDecimal 的字符串表示形式转换为 BigDecimal。
        参数:
            String val:传递一个字符类型的小数  "1.1"
    成员方法:
        加法:BigDecimal add(BigDecimal augend) 返回一个 BigDecimal，其值为 (this + augend)
        减法:BigDecimal subtract(BigDecimal subtrahend) 返回一个 BigDecimal，其值为 (this - subtrahend)，
        乘法:BigDecimal multiply(BigDecimal multiplicand) 返回一个 BigDecimal，其值为 (this × multiplicand)，
        除法:BigDecimal divide(BigDecimal divisor) 返回一个 BigDecimal，其值为 (this / divisor)
                如果无法表示准确的商值（除法除不尽 10/3=3.3333333333333），则抛出 ArithmeticException。
            BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)
                返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。
                参数:
                    参数：
                        divisor - 此 BigDecimal 要除以的值。
                        scale - 保留的小数位数(2,3,4...)  3.33  3.333
                        roundingMode - 要应用的舍入模式。
                            BigDecimal.ROUND_HALF_UP:四舍五入模式  3.66666666==&gt;3.67  3.333333==&gt;3.3
 */</span>
</code></pre>
    <h3>
     <a id="Arrays_1031">
     </a>
     Arrays类(重点)
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    java.util.Arrays:操作数组的工具类
        此类包含用来操作数组（比如排序和搜索）的各种方法。
        Arrays类中的方法都是静态的,可以通过类名.方法名(参数)直接使用
    Arrays类中的成员方法:
         static String toString(Object[] a) 返回指定数组内容的字符串表示形式。
            对数组进行遍历,把数组中的元素组合成一个字符串返回
         static void sort(Object[] a)
            根据元素的自然顺序对指定对象数组按升序进行排序。
 */</span>
</code></pre>
    <h3>
     <a id="_1044">
     </a>
     包装类
    </h3>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/45e74ac465bd4a12ade268a371c1d42f.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    包装类:
        基本数据类型的值(int,double,char,boolean...),使用起来很方便,可以直接使用 10 1.1
        但是没有相关的方法,可以操作这些基本数据类型的值
        所以我们可以使用一个类,把这些基本数据类型的值包裹起来
        在类中定义一些方法,用于操作这些基本数据类型的值
        这个类叫包装类
    基本数据类型:4类8种
        byte    short   int     long    float   double  char        boolean
    基本数据类型对应的包装类: java.lang包
        Byte    Short   Integer Long    Float   Double  Character   Boolean
    java.lang.Integer类:
        Integer 类在对象中包装了一个基本类型 int 的值。
 */</span>
        <span class="token comment">/*
            装箱:把基本类型的值装到包装类中 int--&gt;Integer
            1.包装类中的构造方法:
                Integer(int value) 传递一个整数
                Integer(String s)  传递字符串类型的整数
            2.包装类中的静态方法:
                static Integer valueOf(int i)  传递一个整数
                static Integer valueOf(String s)  传递字符串类型的整数
            注意:
                两个传递字符串的方法,必须传递整数类型的字符串,否则会抛出异常 "123"  "aaa"
         */</span>
        <span class="token comment">/*
            拆箱:在包装类对象中取出基本类型的值  Integer==&gt;int
            Integer类中的方法
                int intValue()以 int 类型返回该 Integer 的值。
                long longValue() 以 long 类型返回该 Integer 的值。
         */</span>
<span class="token comment">/*
    装箱:基本类型--&gt;包装类
    拆箱:包装类--&gt;基本类型
    自动装箱和自动拆箱:在JDK1.5以后,装箱和拆箱可以自动进行,不用我们手动转换
 */</span>
 <span class="token comment">//自动装箱:基本数据类型自动转换为Integer类型使用 list.add(1); 相当于 list.add(new Integer(1));</span>
        <span class="token comment">/*
            自动拆箱:Integer类型的数据直接可以变成int类型使用
            int i = list.get(0); 就相当于 int i = list.get(0).intValue();
         */</span> 
<span class="token comment">/*
    基本类型与字符串之间的转换(重点,经常使用)
    1.基本数据类型==&gt;字符串
        a.基本数据类型的值+"":工作中最常用  1+""---&gt;"1"
        b.使用包装类Integer中的静态方法toString
            static String toString(int i) 返回一个表示指定整数的 String 对象。
        c.使用String类中的静态方法valueOf
            static String valueOf(int i) 返回 int 参数的字符串表示形式。
    2.字符串类型==&gt;基本数据类型(非常重要)
         在每个包装类中都有一个parseXXX方法,可以把字符串格式的基本类型数据的值,转换为基本数据类型
            Integer类:  static int parseInt(String s)
            Double类:   static double parseDouble(String s)
            ...
         注意:
            1.除了Character类之外，其他所有包装类都具有parseXxx静态方法
            2.字符串必须传递基本数据类型的字符串,否则会抛出数字格式化异常  "100"  "aaa":异常
 */</span>
</code></pre>
    <h2>
     <a id="DAY06__1107">
     </a>
     DAY06 综合案例
    </h2>
    <h2>
     <a id="DAY07_CollectionIterator_1108">
     </a>
     DAY07 Collection、Iterator、泛型、数据结构
    </h2>
    <h3>
     <a id="_1109">
     </a>
     学习目标
    </h3>
    <pre><code class="prism language-java">能够说出集合与数组的区别
	数组<span class="token operator">:</span>
		<span class="token number">1.</span>是引用数据类型的一种
		<span class="token number">2.</span>可以存储多个元素
		<span class="token number">3.</span>数组的长度是固定的 <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token number">4.</span>数组即可以存储基本类型的数据<span class="token punctuation">,</span>又可以存储引用数据类型的数据
			<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
	集合<span class="token operator">:</span>
		<span class="token number">1.</span>是引用数据类型的一种
		<span class="token number">2.</span>可以存储多个元素
		<span class="token number">3.</span>集合的长度是可以变化的<span class="token punctuation">(</span>可以往集合中添加元素<span class="token punctuation">,</span>删除集合中的元素<span class="token punctuation">)</span>
		<span class="token number">4.</span>只能存储引用数据类型的数据
			<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> 错误	<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span>	<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span>
能够使用<span class="token class-name">Collection</span>集合的常用功能<span class="token punctuation">(</span>重点<span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> ： 把给定的对象添加到当前集合中 。
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token operator">:</span> 把给定的对象在当前集合中删除。
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token operator">:</span> 判断当前集合中是否包含给定的对象。
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> 判断当前集合是否为空。
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> 返回集合中元素的个数。
	<span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> 把集合中的元素，存储到数组中
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>清空集合中所有的元素。
能够使用迭代器对集合进行取元素<span class="token punctuation">(</span>重点<span class="token punctuation">)</span>
	<span class="token comment">//1.创建集合对象,往集合中添加元素</span>
	<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> coll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//Collection&lt;String&gt; coll = new HashSet&lt;&gt;();</span>
	coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"詹姆斯"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"姚明"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"科比"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"乔丹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"艾弗森"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//2.使用Collection接口中的方法iterator,获取迭代器的实现类对象</span>
	<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> coll<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//3.使用迭代器对象Iterator中的方法hasNext和next遍历集合</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">String</span> s <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
能够使用增强<span class="token keyword">for</span>循环遍历集合和数组<span class="token punctuation">(</span>重点<span class="token punctuation">)</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>集合<span class="token operator">|</span>数组中元素的数据类型 变量名<span class="token operator">:</span> 集合<span class="token operator">|</span>数组<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">sout</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">sout</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">sout</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
能够理解泛型上下限
    泛型的上限限定<span class="token operator">:</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span> <span class="token operator">==</span><span class="token operator">&gt;</span>传递的未知类型<span class="token operator">?</span>只能是<span class="token class-name">E</span>的子类或者本身
    泛型的下限限定<span class="token operator">:</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span>   <span class="token operator">==</span><span class="token operator">&gt;</span>传递的未知类型<span class="token operator">?</span>只能是<span class="token class-name">E</span>的父类或者本身
能够阐述泛型通配符的作用
	泛型的通配符<span class="token operator">:</span> <span class="token operator">?</span>  可以接收任意的数据类型
能够说出常见的数据结构
	栈<span class="token punctuation">,</span>队列<span class="token punctuation">,</span>数组<span class="token punctuation">,</span>链表<span class="token punctuation">,</span>红黑树
能够说出数组结构特点
	查询快<span class="token punctuation">,</span>增删慢
能够说出栈结构特点
	先进后出
能够说出队列结构特点
	先进先出
能够说出单向链表结构特点
	查询慢<span class="token punctuation">,</span>增删快
</code></pre>
    <h3>
     <a id="Collection_1178">
     </a>
     Collection集合
    </h3>
    <p>
     数组:
    </p>
    <p>
     1.是引用数据类型的一种
    </p>
    <p>
     2.可以存储多个元素
    </p>
    <p>
     3.数组的长度是固定的 int[] arr1 = new int[10]; int[] arr2 = {1,2,3};
    </p>
    <p>
     4.数组即可以存储基本数据类型的数据,又可以存储引用数据类型的数据 int[] double[] String[] Student[]
    </p>
    <p>
     集合:
    </p>
    <p>
     1.是引用数据类型的一种
    </p>
    <p>
     2.可以存储多个元素
    </p>
    <p>
     3.集合的长度是可以变化的(添加元素,删除集合中的元素)
    </p>
    <p>
     4.集合只能存储引用数据类型的数据
    </p>
    <p>
     <code>
      ArrayList&lt;int&gt; 错误 ArrayList&lt;Integer&gt; ArrayList&lt;Student&gt; ArrayList&lt;String&gt;正确
     </code>
    </p>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/0d9a235ca56544bda556392199a939b0.png"/>
    </p>
    <h3>
     <a id="Iterator_1203">
     </a>
     Iterator迭代器
    </h3>
    <pre><code class="prism language-java"><span class="token comment">/*
    迭代器:是一种通用取出集合中元素的方式
    迭代器的由来:
        集合有很多种,每种集合的数据结构不同(数组,链表,哈希表...),集合取出元素的方式也不同
        我们不可能为每种集合都定义一种取出元素的方式,浪费
        所以我们可以使用迭代器,是集合通用的取出元素的方式
    迭代器的原理:
        判断集合中还有没有元素,有就取出来;
        再判断集合中还有没有元素,有再取出来;
        一直判断到集合中没有元素为止,这种取出元素的方式叫迭代
    ------------------------------------------------------------------------------------
    java.util.Iterator&lt;E&gt;接口:对 collection 进行迭代的迭代器。
    Iterator接口的常用方法:
        boolean hasNext() 如果仍有元素可以迭代，则返回 true。
            判断集合中还没有没有元素;有返回true,没有返回false
        E next() 返回迭代的下一个元素。 取出集合中的元素
    ------------------------------------------------------------------------------------
    Iterator是一个接口无法创建对象使用,使用Iterator接口的实现类对象,Iterator接口的实现类对象是每个集合的内部类(了解)
    我们可以使用Collection接口中的方法iterator获取迭代器Iterator接口的实现类对象
        Iterator&lt;E&gt; iterator() 返回在此 collection 的元素上进行迭代的迭代器。
    注意:
        我们无需关注iterator方法返回的是接口的哪个实现类对象,我们只需要会使用Iterator接口来接收这个实现类对象即可(多态)
 */</span>
 <span class="token comment">//注意:迭代器只能使用一次,想要在遍历元素,必须重新获取一个新的迭代器</span>
</code></pre>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/aec5d0f776bf4888a2f9516831a746fd.png"/>
     <br/>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/da9b50b5b11e45acbfecdb66cb147482.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    迭代器的并发修改异常:在使用迭代器遍历集合的过程中,对集合长度进行了修改,迭代器就会抛出并发修改异常
    ConcurrentModificationException
    注意:
        1.并发:遍历和修改同时进行
        2.修改:修改集合的长度(添加元素,删除元素)
    解决方案:
        1.遍历集合的同时,不修改集合的长度
        2.Iterator接口有一个子接口叫ListIterator
            在ListIterator接口定义了往集合中添加元素的方法
                public interface ListIterator&lt;E&gt;extends Iterator&lt;E&gt;
                void add(E e)  迭代器中往集合添加元素的方法
                void remove() 删除的是next方法取出的元素
       注意:
        1.如果使用迭代器中的add|remove方法,往集合中添加|删除元素
            就相当于集合和迭代器商量好了,可以往集合中添加|删除元素,迭代器就不会抛出并发修改异常了
        2.ListIterator迭代器只能遍历List接口下的集合(ArrayList,LinkedList),不能遍历Set接口下的集合(HashSet,LinkedHashSet)
 */</span>
</code></pre>
    <p>
     <strong>
      迭代器的实现类是每个集合的内部类(了解)
     </strong>
     <br/>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/a9108fe17c424e089342e46d68f8c578.png"/>
     <br/>
     <strong>
      注意:
     </strong>
    </p>
    <p>
     ​
     <strong>
      增强for循环底层是一个迭代器,所以在使用增强for循环遍历的时候,不能对集合的长度进行修改,否则会抛出并发修改异常
     </strong>
     <br/>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/d7d5fdfe79834e83a74fe0dcb11939cb.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    增强for循环(重点)
        是JDK1.5之后出现的新特性
        使用for循环的方式,对迭代器进行了简化
        增强for循环内部就是一个迭代器,对迭代器进行了封装
   Collection接口有一个父接口叫Iterable
        public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;
        java.lang.Iterable&lt;T&gt;接口
            实现这个接口允许对象成为 "foreach" 语句的目标。
            Collection接口继承了Iterable接口,所以可以使用增强for循环
            Collection接口所有的实现类,都可以使用增强for循环(ArrayList,LinkedList,HashSet...)
   ------------------------------------------------------------
   增强for循环的格式:重点
        for(集合|数组中元素的类型 变量名 : 集合名|数组名){
               sout(变量名);
        }
 */</span>
</code></pre>
    <h3>
     <a id="_1279">
     </a>
     泛型
    </h3>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/dc6f10e31df64e3e8ad21084df5a5606.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    java中的泛型:是一个伪泛型,在.java文件中有,但是.class文件中没有
 */</span>
    <span class="token comment">/*
        使用泛型创建ArrayList集合对象
        好处:
            1.使用什么泛型就只能存储什么类型的数据;避免向下转型抛出类型转换异常
            2.写上泛型存储的是什么类型,取出的就是什么类型,不用向下转型,就可以使用特有的方法
        弊端:
            1.不能什么类型的数据都存储
     */</span>

    <span class="token comment">/*
        不使用泛型创建ArrayList集合对象
        好处:
            不使用泛型,集合默认的数据类型就是Object类型,可以存储任意数据类型的元素
        弊端:
            1.不能使用元素特有的方法(多态)
            2.在进行向下转型的时候,容易引发类型转换异常
     */</span>
</code></pre>
    <p>
     通过反编译软件,查看的class文件中,没有泛型
     <br/>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/ea00e05d5b164acb96a4ce6387a2c6e0.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    定义和使用含有泛型的类:模拟ArrayList集合
        当我们不知道使用什么类型的时候,就可以使用泛型,是一个未知的数据类型
        可以给泛型赋值任意的数据类型:Integer,Student,Person,String...
    定义格式:
        public class 类名&lt;泛型&gt;{
            类中使用数据类型的地方,都可以使用类上定义好的泛型
        }
    什么时候确定类上泛型的数据类型
        创建对象的时候,确定类上泛型的数据类型;对象使用什么类型,类的泛型就是什么类型
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">C</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">C</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">C</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">C</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/66ba95e0e0ab4361aabb65fd4f9cba26.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    定义和使用含有泛型的方法(重点)
        泛型需要定义在方法的修饰符和返回值类型之间
    定义格式:
        修饰符 &lt;泛型&gt; 返回值类型 方法名(参数类型--&gt;使用泛型){
            方法体;
        }
    什么时候确定泛型的数据类型:
        调用方法,传递的参数是什么类型,方法的泛型就是什么类型
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericMethod</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//定义含有泛型的方法(重点)</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">M</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token class-name">M</span> m<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//定义含有泛型的静态方法(了解)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token class-name">S</span> s<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//定义含有泛型的方法,返回值类型使用泛型(了解==&gt;看源码)</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span>AAA<span class="token punctuation">&gt;</span></span> <span class="token class-name">AAA</span> <span class="token function">method03</span><span class="token punctuation">(</span><span class="token class-name">AAA</span> aaa<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aaa<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> aaa<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/6c449d63c287439c891993d5d8abb47c.png"/>
    </p>
    <pre><code class="prism language-java"><span class="token comment">/*
    定义含有泛型的接口
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GenericInterface</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//定义抽象方法,使用接口上的泛型,作为参数的类型</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">I</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
    含有泛型的接口:第一种使用方式
    定义一个类,实现含有泛型的接口,在实现接口的同时,指定接口泛型的数据类型
    格式:
        public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;{
            重写接口中的方法,使用指定的类型String
            public void show(String s) { }
        }

        public class GenericInterfaceImpl1 implements GenericInterface&lt;Integer&gt;{
            重写接口中的方法,使用指定的类型Integer
            public void show(Integer integer) { }
        }
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericInterfaceImpl1</span> <span class="token keyword">implements</span> <span class="token class-name">GenericInterface</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> in<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
    含有泛型的接口:第二种使用方式
        定义类实现含有泛型的接口,接口使用什么泛型,实现类就使用什么泛型
        实现类跟着接口走,就和定义一个含有泛型的类是一样的
    格式:
        public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt;{
            重写的方法使用接口上的泛型
            public void show(I i) { }
        }
    注意:
        创建对象的时候,确定泛型的数据类型;创建对象是什么数据类型,泛型就是什么数据类型
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericInterfaceImpl2</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">GenericInterface</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">I</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">I</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-java"><span class="token comment">/*
    泛型的通配符
        ?:代表可以接收任意的数据类型
        ?已经由java定义好了,我们可以直接使用
 */</span>
        <span class="token comment">/*
            泛型的通配符只能作为方法参数的数据类型使用,不能创建对象作为数据类型使用
         */</span>
        <span class="token comment">//ArrayList&lt;?&gt; list = new ArrayList&lt;&gt;();</span>
        <span class="token comment">//list.add(1);</span>
        <span class="token comment">//list.add("a");</span>
<span class="token comment">/*
    泛型通配符的高级使用
    泛型的通配符: ? 代表可以接收任意数据类型的数据
    泛型的上限限定: ? extends E==&gt;传递的未知类型?只能使用E的子类或者是E本身
    泛型的下限限定: ? super E==&gt;传递的未知类型?只能使用E的父类或者是E本身
 */</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34303239303834352f:61727469636c652f64657461696c732f313435373335333133" class_="artid" style="display:none">
 </p>
</div>


