---
layout: post
title: "RGV调度算法三-遗传算法"
date: 2025-03-14 00:04:07 +0800
description: "2.2019年MathorCup高校数学建模挑战赛B题。"
keywords: "RGV调度算法（三）--遗传算法"
categories: ['Rgv']
tags: ['Rgv']
artid: "146245258"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146245258
    alt: "RGV调度算法三-遗传算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146245258
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146245258
cover: https://bing.ee123.net/img/rand?artid=146245258
image: https://bing.ee123.net/img/rand?artid=146245258
img: https://bing.ee123.net/img/rand?artid=146245258
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RGV调度算法（三）--遗传算法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     1、基于时间窗
    </p>
    <p>
     <a href="https://wenku.baidu.com/view/470e9fd8b4360b4c2e3f5727a5e9856a57122693.html?_wkts_=1741880736197&amp;bdQuery=%E7%8E%AF%E7%A9%BF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" rel="nofollow" title="https://wenku.baidu.com/view/470e9fd8b4360b4c2e3f5727a5e9856a57122693.html?_wkts_=1741880736197&amp;bdQuery=%E7%8E%AF%E7%A9%BF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">
      https://wenku.baidu.com/view/470e9fd8b4360b4c2e3f5727a5e9856a57122693.html?_wkts_=1741880736197&amp;bdQuery=%E7%8E%AF%E7%A9%BF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95
     </a>
    </p>
    <p>
     2.2019年MathorCup高校数学建模挑战赛B题
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_39529891/article/details/89414856" title="2019-mathorcupB题-环形穿梭机调度模型（思路篇）_环形调度算法-CSDN博客">
      2019-mathorcupB题-环形穿梭机调度模型（思路篇）_环形调度算法-CSDN博客
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_43292788/article/details/129406488" title="2019年MathorCup数学建模B题环形穿梭车系统的设计与调度解题全过程文档及程序_2019-mathorcupb题-环形穿梭机调度模型-CSDN博客">
      2019年MathorCup数学建模B题环形穿梭车系统的设计与调度解题全过程文档及程序_2019-mathorcupb题-环形穿梭机调度模型-CSDN博客
     </a>
    </p>
    <p>
     <img alt="" height="653" src="https://i-blog.csdnimg.cn/direct/d23f86ea041e47ec920edc8c098c9d58.png" width="988">
     </img>
    </p>
    <p>
     <img alt="" height="427" src="https://i-blog.csdnimg.cn/direct/8a08d0f1d26a46bda9bb2c393888e98b.png" width="990"/>
    </p>
    <h3>
     基于遗传算法的穿梭车调度主函数
    </h3>
    <pre><code>function [time]=GA()
N=3;num=10;%每次迭代一个口货物的数量，染色体携带的基因个数
popsize=20; %初始种群大小
Generationnmax=20; %最大代数
pcrossover=0.8; %交配概率
pmutation=0.1;%变异概率
fitness=zeros(1,popsize);%%产生初始种群，两个矩阵
A_2=xlsread('A.xlsx');A_2(:,1)=A_2(:,1)+A_2(:,2);A_2(:,2)=A_2(:,1)-A_2(:,2);
A_2(:,1)=A_2(:,1)-A_2(:,2);A_2_ini=A_2;
population=[ceil(4+3*rand(100,4,popsize)),ceil(N*rand(100,6,popsize))];
for i=1:popsize
 population(52:100,2,i)=0;
 population(72:100,3,i)=0;
 population(52:100,8,i)=0;
 population(72:100,9,i)=0;
end%%迭代的时候用到的 population 信息，ini 为所有信息，raise 随着迭代不断上升，
best 为最优种群
population_ini=population;population_raise=[];scnew=zeros(num,10,popsize);
smnew=zeros(num,10,popsize);handle_waitbar=waitbar(0,'Please wait...');%%每次迭代10个
货物
for s=1:10
 start=10*s-9;
 the_end=10*s;%%每次迭代取 ini 对应的 10 行，population_part 的值每次都在变
 population_part_s=population_ini(start:the_end,:,:);
 A_2_part=A_2_ini(1:the_end,:);Generation=0;
while Generation&lt;Generationnmax
 Generation=Generation+1;%%算 raise 后的适应度 
for i=1:popsize 
 fitness(i)=simulation([population_raise;population_part_s(:,:,i)],A_2_part,N);
end%给适应度函数加上一个大小合理的数以便保证种群适应值为正数
fitness=fitness';
valuemax=max(fitness);
fitness=(valuemax-fitness);
fsum=sum(fitness);
Pperpopulation=fitness/fsum;
cumsump=cumsum(Pperpopulation);
cumsump=cumsump';%%只对 part 进行交叉等操作
for j=1:2:popsize %选择操作
 seln=selection(cumsump); %交叉操作
 scro=crossover(population_part_s,seln,pcrossover);
 scnew(:,:,j)=scro(:,:,1);scnew(:,:,j+1)=scro(:,:,2); 
 smnew(:,:,j)=mutation(scnew(:,:,j),pmutation,N);
 smnew(:,:,j+1)=mutation(scnew(:,:,j+1),pmutation,N);
end%产生了新的种群，part
population_part_s=smnew;
end%%计算 raise 后的适应度
for i=1:popsize
 fitness(i)=simulation([population_raise();population_part_s(:,:,i)],A_2_part,N);
end
 [~,index]=min(fitness); population_raise(start:the_end,:)=population_part_s(:,:,index);
 waitbar(s/20,handle_waitbar)
end
close(handle_waitbar);time=simulation(population_raise,A_2_ini,N);
xlswrite('task.xlsx',population_raise);
end
</code></pre>
    <p>
     环形穿梭车调度过程
    </p>
    <pre><code>function 
[port_state,vehicle_state]=Fnc_update_state(task_assignment,task_information,port_state,veh
icle_state,vehicle_coordinate,in_coordinate,out_coordinate,N)
% vehicle_state 第一行代表 N 个运输车的状态，
%0 表示空闲%1 代表正在装货%2 代表正在运货%3 代表正在卸货
% 第二行代表货物来源于哪个进货口（编号 1-6），从开始装货到开始卸货此数值不为
0
% 第三行代表需要将货物送到哪个出货口（编号 1-7），从开始装货到开始卸货此数值
不为 0
% 第四行在运输车不处于 flag=1 或 3 时为 0，当 flag==1 或 3 时其数字代表装卸货剩余
的时间，本程序中由于取了 h=0.01
% 因为浮点数的判定条件问题所以取这个数字的范围为 0-100，每当进行一个 whlie 循
环 t 增加 0.1， 10s 对应 100 次循环
%%port_state 口的状态，列数为 6，6 个进货口
%%第一行代表每一个口下一个有待装箱的货物编号%%第二行代表这个货物由哪个运
输车负责%%第三行代表这个货物要送到哪个口
for i=1:N%%如果空闲则满足一定条件变成装货
 if(vehicle_state(1,i)==0) 
 %%检测第 i 个车是否到达对应进货口,如果已经到达进货口则进行装箱,
 %%并将小车状态改为正在装货，记录起始地和目的地，并将等待时间置 100.
 %%0.15=0.1*1.5，代表进货出货区间
 delta=vehicle_coordinate(i)-in_coordinate;%index 代表哪个进货口
 index=find((0&lt;delta)&amp;(delta&lt;=0.15));%有空闲的运输车到达进货口
 if(~isempty(index))
 if port_state(2,index)==i
 vehicle_state(1,i)=1; vehicle_state(2,i)=index;
 vehicle_state(3,i)=port_state(3,index); vehicle_state(4,i)=100; 
 end
 end
%%如果在装货，则时间减一，如果减一后为 0，变为运货状态,此时进货口的状态进行
更新，
 %%货物信息进行移位
 elseif(vehicle_state(1,i)==1)
 vehicle_state(4,i)=vehicle_state(4,i)-1;
 if(vehicle_state(4,i)==0)
 vehicle_state(1,i)=2;index=vehicle_state(2,i); %%当有一个货物完成装货后，对应 port 货物编号+1，并更新对应 port 信息
 port_state(1,index)=port_state(1,index)+1;
 port_state(2,index)=task_assignment(port_state(1,index),index);
 port_state(3,index)=task_information(port_state(1,index),index);
 end
%%处于运货状态时，检测第 i 个车是否到达对应出货口，如果已经到达出货口进行卸货
%%小车状态改为卸货，并将时间置 1000
 elseif(vehicle_state(1,i)==2)
 delta=vehicle_coordinate(i)-out_coordinate;
 index=find((0&lt;delta)&amp;(delta&lt;=0.15));
 if(~isempty(index))
 if vehicle_state(3,i)==index
 vehicle_state(1,i)=3; vehicle_state(4,i)=100; 
 end
end%%如果在卸货，则时间减一，如果减一后为 0，变为空闲状态，并清空该
车的进货口和出货口信息
 elseif(vehicle_state(1,i)==3)
 vehicle_state(4,i)=vehicle_state(4,i)-1;
 if(vehicle_state(4,i)==0)
 vehicle_state(1,i)=0; vehicle_state(2,i)=0; vehicle_state(3,i)=0; 
 end 
 end
end
end
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32353139343638312f:61727469636c652f64657461696c732f313436323435323538" class_="artid" style="display:none">
 </p>
</div>


