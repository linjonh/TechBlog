---
layout: post
title: "hadoop框架与核心组件刨析五ZOOKEEPER及选举深度刨析"
date: 2025-03-09 18:06:48 +0800
description: "Zookeeper的目标是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。myid用于区分集群中不同的服务器，在选举过程中，如果两个服务器的zxid相同，则会比较myid，myid更大的服务器优先级更高。当某个服务器收到超过半数的相同投票（即Quorum），它会确定投票中的服务器为Leader，并将自己的状态改为。它由Leader产生，是集群中唯一的标识事务的量。myid是在zookeeper在初始化集群时写在配置文件中的，是每个服务器的唯一标识，是一个整数。"
keywords: "hadoop框架与核心组件刨析（五）ZOOKEEPER及选举深度刨析"
categories: ['Hadoop']
tags: ['云原生', 'Zookeeper', 'Hadoop']
artid: "146135417"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146135417
    alt: "hadoop框架与核心组件刨析五ZOOKEEPER及选举深度刨析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146135417
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146135417
cover: https://bing.ee123.net/img/rand?artid=146135417
image: https://bing.ee123.net/img/rand?artid=146135417
img: https://bing.ee123.net/img/rand?artid=146135417
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     hadoop框架与核心组件刨析（五）ZOOKEEPER及选举深度刨析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A%EF%BC%9A" name="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A%EF%BC%9A">
     基本概念解释：
    </h2>
    <p>
     在介绍选举leader之前，先来介绍一下什么是zookeeper：
    </p>
    <p>
     ZooKeeper是一个开源的分布式应用程序协调服务，来自于Google的Chubby一个开源的实现。是Hadoop和Hbase的重要组件。Zookeeper可以为分布式应用提供一致性的服务，功能包括：配置维护、名字服务、分布式系统、组服务等等。Zookeeper的目标是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。ZooKeeper包含一个简单的原语集，提供Java和C的接口。
    </p>
    <p>
     <img alt="" height="451" src="https://i-blog.csdnimg.cn/direct/9e2143f6dd0e4b5686f14a7838672e08.png" width="911"/>
    </p>
    <p>
     ZOOKEEPER的角色：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        角色
       </th>
       <th>
        描述
       </th>
       <th>
        职责
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         Leader
        </strong>
       </td>
       <td>
        集群中的主节点，负责处理写请求和事务协调。
       </td>
       <td>
        - 处理客户端的写请求。
        <br/>
        - 广播事务（PROPOSAL）给Follower。
        <br/>
        - 提交事务（COMMIT）。
        <br/>
        - 维护集群的事务顺序（zxid）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Follower
        </strong>
       </td>
       <td>
        集群中的从节点，负责处理读请求和同步Leader的数据。
       </td>
       <td>
        - 处理客户端的读请求。
        <br/>
        - 参与事务投票（ACK）。
        <br/>
        - 同步Leader的数据。
        <br/>
        - 参与Leader选举。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Observer
        </strong>
       </td>
       <td>
        类似于Follower，但不参与事务投票，用于扩展读性能。
       </td>
       <td>
        - 处理客户端的读请求。
        <br/>
        - 同步Leader的数据。
        <br/>
        - 不参与事务投票和Leader选举。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Learner
        </strong>
       </td>
       <td>
        泛指Follower和Observer，表示从Leader学习数据的节点。
       </td>
       <td>
        - 从Leader同步数据。
        <br/>
        - 根据角色（Follower/Observer）决定是否参与投票。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Client
        </strong>
       </td>
       <td>
        客户端，与ZooKeeper集群交互，发送读/写请求。
       </td>
       <td>
        - 发送读请求（任意节点）。
        <br/>
        - 发送写请求（必须由Leader处理）。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h5 id="1.%20Leader" name="1.%20Leader">
     <strong>
      1. Leader
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Leader是集群的核心节点，负责处理所有写请求和事务协调。
      </p>
     </li>
     <li>
      <p>
       <strong>
        职责
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         接收客户端的写请求，并将其转换为事务。
        </p>
       </li>
       <li>
        <p>
         广播事务（PROPOSAL）给所有Follower。
        </p>
       </li>
       <li>
        <p>
         收集Follower的确认（ACK），并在达到Quorum后提交事务（COMMIT）。
        </p>
       </li>
       <li>
        <p>
         维护全局的事务顺序（通过zxid）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         集群中只有一个Leader。
        </p>
       </li>
       <li>
        <p>
         如果Leader崩溃，会触发新的Leader选举。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="2.%20Follower" name="2.%20Follower">
     <strong>
      2. Follower
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Follower是集群中的从节点，负责处理读请求和同步Leader的数据。
      </p>
     </li>
     <li>
      <p>
       <strong>
        职责
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         处理客户端的读请求。
        </p>
       </li>
       <li>
        <p>
         参与事务投票（ACK），确认是否接受Leader广播的事务。
        </p>
       </li>
       <li>
        <p>
         同步Leader的数据，保持与Leader的一致性。
        </p>
       </li>
       <li>
        <p>
         参与Leader选举，投票选出新的Leader。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         可以处理读请求，减轻Leader的负载。
        </p>
       </li>
       <li>
        <p>
         参与事务投票和Leader选举，是集群的重要组成部分。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="3.%20Observer" name="3.%20Observer">
     <strong>
      3. Observer
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Observer类似于Follower，但不参与事务投票，用于扩展集群的读性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        职责
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         处理客户端的读请求。
        </p>
       </li>
       <li>
        <p>
         同步Leader的数据，保持与Leader的一致性。
        </p>
       </li>
       <li>
        <p>
         不参与事务投票和Leader选举。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         不参与投票，因此不会影响写性能。
        </p>
       </li>
       <li>
        <p>
         主要用于扩展读性能，适合读多写少的场景。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="4.%20Learner" name="4.%20Learner">
     <strong>
      4. Learner
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：Learner是Follower和Observer的统称，表示从Leader学习数据的节点。
      </p>
     </li>
     <li>
      <p>
       <strong>
        职责
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         从Leader同步数据。
        </p>
       </li>
       <li>
        <p>
         根据角色（Follower/Observer）决定是否参与投票。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Learner是一个抽象概念，用于描述Follower和Observer的共同行为。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5 id="5.%20Client" name="5.%20Client">
     <strong>
      5. Client
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：客户端是与ZooKeeper集群交互的应用程序。
      </p>
     </li>
     <li>
      <p>
       <strong>
        职责
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         发送读请求（可以直接发送给任意节点）。
        </p>
       </li>
       <li>
        <p>
         发送写请求（必须发送给Leader，或由Follower转发给Leader）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        特点
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         客户端通过ZooKeeper提供的API与集群交互。
        </p>
       </li>
       <li>
        <p>
         客户端可以连接到任意节点（Leader/Follower/Observer）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4 id="%E8%A7%92%E8%89%B2%E5%AF%B9%E6%AF%94" name="%E8%A7%92%E8%89%B2%E5%AF%B9%E6%AF%94" style="background-color:transparent">
     <strong>
      角色对比
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        Leader
       </th>
       <th>
        Follower
       </th>
       <th>
        Observer
       </th>
       <th>
        Client
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         处理读请求
        </strong>
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
       <td>
        是
       </td>
       <td>
        发送读请求
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         处理写请求
        </strong>
       </td>
       <td>
        是
       </td>
       <td>
        转发给Leader
       </td>
       <td>
        转发给Leader
       </td>
       <td>
        发送写请求
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         参与事务投票
        </strong>
       </td>
       <td>
        是（发起投票）
       </td>
       <td>
        是（ACK确认）
       </td>
       <td>
        否
       </td>
       <td>
        否
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         参与Leader选举
        </strong>
       </td>
       <td>
        是（被选举）
       </td>
       <td>
        是（投票）
       </td>
       <td>
        否
       </td>
       <td>
        否
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据同步
        </strong>
       </td>
       <td>
        是（广播数据）
       </td>
       <td>
        是（同步数据）
       </td>
       <td>
        是（同步数据）
       </td>
       <td>
        否
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数量
        </strong>
       </td>
       <td>
        1（集群中只有一个Leader）
       </td>
       <td>
        多个
       </td>
       <td>
        多个
       </td>
       <td>
        多个
       </td>
      </tr>
     </tbody>
    </table>
    <h3 id="ZOOKEEPER%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%EF%BC%9A" name="ZOOKEEPER%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%EF%BC%9A">
     ZOOKEEPER选举过程：
    </h3>
    <h4 id="1.%20%E5%BF%AB%E9%80%9FLeader%E9%80%89%E4%B8%BE%EF%BC%88Fast%20Leader%20Election%EF%BC%89" name="1.%20%E5%BF%AB%E9%80%9FLeader%E9%80%89%E4%B8%BE%EF%BC%88Fast%20Leader%20Election%EF%BC%89" style="background-color:transparent">
     1.
     <strong>
      快速Leader选举（Fast Leader Election）
     </strong>
    </h4>
    <p>
     快速Leader选举是ZooKeeper默认的选举算法，基于**Zab协议（ZooKeeper Atomic Broadcast）**实现。它的核心思想是通过投票机制快速选出一个Leader，确保集群的高效性和一致性。
    </p>
    <h5 id="%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%EF%BC%9A" name="%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%EF%BC%9A">
     选举过程：
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        初始状态
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每个ZooKeeper服务器启动时处于
         <strong>
          LOOKING
         </strong>
         状态，表示正在寻找Leader。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        投票
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每个服务器会投票给自己，投票信息包括：
        </p>
        <ul>
         <li>
          <p>
           <strong>
            myid
           </strong>
           ：服务器的唯一标识。
          </p>
         </li>
         <li>
          <p>
           <strong>
            zxid
           </strong>
           ：服务器上最新的事务ID（越大表示数据越新）。
          </p>
         </li>
         <li>
          <p>
           <strong>
            epoch
           </strong>
           ：选举轮次。
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         服务器将投票信息广播给集群中的其他服务器。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        比较投票
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每个服务器收到其他服务器的投票后，会比较投票信息：
        </p>
        <ul>
         <li>
          <p>
           优先比较
           <strong>
            zxid
           </strong>
           ，zxid越大，优先级越高。
          </p>
         </li>
         <li>
          <p>
           如果zxid相同，则比较
           <strong>
            myid
           </strong>
           ，myid越大，优先级越高。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        更新投票
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果收到的投票比自己当前的投票更优，服务器会更新自己的投票，并重新广播。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        确定Leader
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当某个服务器收到超过半数的相同投票（即Quorum），它会确定投票中的服务器为Leader，并将自己的状态改为
         <strong>
          FOLLOWING
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         被选中的服务器将自己的状态改为
         <strong>
          LEADING
         </strong>
         ，成为Leader。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h5 id="%E7%89%B9%E7%82%B9%EF%BC%9A" name="%E7%89%B9%E7%82%B9%EF%BC%9A">
     特点：
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        快速
       </strong>
       ：通过优先比较zxid和myid，快速选出Leader。
      </p>
     </li>
     <li>
      <p>
       <strong>
        高效
       </strong>
       ：避免了复杂的协商过程，适合大规模集群。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="2.%20%E5%9F%BA%E4%BA%8ETCP%E7%9A%84Leader%E9%80%89%E4%B8%BE" name="2.%20%E5%9F%BA%E4%BA%8ETCP%E7%9A%84Leader%E9%80%89%E4%B8%BE">
     2.
     <strong>
      基于TCP的Leader选举
     </strong>
    </h4>
    <p>
     基于TCP的Leader选举是ZooKeeper早期版本中使用的一种选举方式，现在已经较少使用。它的核心思想是通过TCP连接和简单的投票机制选出Leader。
    </p>
    <h5 id="%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%EF%BC%9A" name="%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%EF%BC%9A" style="background-color:transparent">
     选举过程：
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        初始状态
       </strong>
       ：
      </p>
      每个服务器启动时处于
      <strong>
       LOOKING
      </strong>
      状态。
     </li>
     <li>
      <p>
       <strong>
        建立连接
       </strong>
       ：
      </p>
      每个服务器尝试与其他服务器建立TCP连接。
     </li>
     <li>
      <p>
       <strong>
        投票
       </strong>
       ：
      </p>
      每个服务器投票给自己，并将投票信息发送给其他服务器。
     </li>
     <li>
      <p>
       <strong>
        比较投票
       </strong>
       ：
      </p>
      服务器收到其他服务器的投票后，会比较投票信息（基于myid和zxid）。
     </li>
     <li>
      <p>
       <strong>
        确定Leader
       </strong>
       ：
      </p>
      当某个服务器收到超过半数的相同投票时，它会确定投票中的服务器为Leader。
     </li>
    </ol>
    <h5 id="%E7%89%B9%E7%82%B9%EF%BC%9A" name="%E7%89%B9%E7%82%B9%EF%BC%9A">
     特点：
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        简单
       </strong>
       ：实现较为简单，适合小规模集群。
      </p>
     </li>
     <li>
      <p>
       <strong>
        效率较低
       </strong>
       ：依赖TCP连接的建立和维护，选举速度较慢。
      </p>
     </li>
    </ul>
    <h2 id="zxid%E5%92%8Cmyid" name="zxid%E5%92%8Cmyid">
     zxid和myid
    </h2>
    <h5 id="myid" name="myid" style="background-color:transparent">
     myid
    </h5>
    <p>
     myid是在zookeeper在初始化集群时写在配置文件中的，是每个服务器的唯一标识，是一个整数。
    </p>
    <p>
     如在zoo.cfg中配置：
    </p>
    <p>
     server.1=192.168.1.1:2888:3888
     <br/>
     server.2=192.168.1.2:2888:3888
     <br/>
     server.3=192.168.1.3:2888:3888
    </p>
    <p>
     对应的myid分别是1 2 3
    </p>
    <p>
     myid用于区分集群中不同的服务器，在选举过程中，如果两个服务器的zxid相同，则会比较myid，myid更大的服务器优先级更高。
    </p>
    <h5 id="zxid" name="zxid" style="background-color:transparent">
     zxid
    </h5>
    <p>
     zxid是zookeeper的事务id，用于标识事务的顺序。它由Leader产生，是集群中唯一的标识事务的量。
    </p>
    <p>
     如何产生：zxid由两部分组成：epoch和counter
    </p>
    <p>
     epoch：表示Leader的任期。每次选举新的Leader时，epoch会递增。
    </p>
    <p>
     counter：表示事务的序号，每次新的事务发生时，counter会递增。
    </p>
    <p>
     在每个服务器启动时，会从本地磁盘加载最新的zxid（既最后一次提交的事务）
    </p>
    <p>
     如果服务器是第一次启动，或者没有历史数据，则zxid为0
    </p>
    <p>
     这里就会说，欸，比较时每个服务器发送zxid，但是这个参数又是集群共有的，那如何比较呢？
    </p>
    <p>
     这其实是一种误解，具体解释如下：
    </p>
    <h4 id="" name="" style="background-color:transparent">
    </h4>
    <h4 id="1.%20zxid%20%E7%9A%84%E9%9B%86%E7%BE%A4%E5%85%B1%E6%9C%89%E6%80%A7" name="1.%20zxid%20%E7%9A%84%E9%9B%86%E7%BE%A4%E5%85%B1%E6%9C%89%E6%80%A7" style="background-color:transparent">
     1.
     <strong>
      zxid 的集群共有性
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        zxid 是集群共有的
       </strong>
       ：在ZooKeeper集群中，所有服务器最终会达成一致，拥有相同的
       <strong>
        zxid
       </strong>
       。这是因为ZooKeeper通过
       <strong>
        Zab协议（ZooKeeper Atomic Broadcast）
       </strong>
       保证所有服务器按相同的顺序执行事务。
      </p>
     </li>
     <li>
      <p>
       <strong>
        zxid 的一致性
       </strong>
       ：一旦一个事务被提交（即被大多数服务器确认），所有服务器都会看到相同的
       <strong>
        zxid
       </strong>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%20zxid%EF%BC%9F" name="2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%20zxid%EF%BC%9F" style="background-color:transparent">
     2.
     <strong>
      为什么每个服务器有自己的 zxid？
     </strong>
    </h4>
    <p>
     尽管
     <strong>
      zxid
     </strong>
     是集群共有的，但在选举过程中，每个服务器会携带自己本地的
     <strong>
      zxid
     </strong>
     ，这是因为：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        <span style="background-color:#fbd4d0">
         数据同步的延迟
        </span>
       </strong>
       ：在分布式系统中，不同服务器之间的数据同步可能存在延迟。某些服务器可能已经收到了最新的事务，而其他服务器还没有。
      </p>
     </li>
     <li>
      <p>
       <strong>
        本地 zxid 的作用
       </strong>
       ：每个服务器的本地
       <strong>
        zxid
       </strong>
       表示它当前已经提交的最新事务。在选举过程中，这个值用于
       <span style="background-color:#fef2f0">
        比较服务器的数据新旧程度
       </span>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="3.%20zxid%20%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E5%90%8C%E6%AD%A5" name="3.%20zxid%20%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E5%90%8C%E6%AD%A5" style="background-color:transparent">
     3.
     <strong>
      zxid 的生成和同步
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Leader 生成 zxid
       </strong>
       ：只有Leader可以生成新的
       <strong>
        zxid
       </strong>
       。当Leader接收到一个新的事务请求时，它会递增
       <strong>
        zxid
       </strong>
       的低32位（counter），并将事务广播给所有Follower。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Follower 同步 zxid
       </strong>
       ：Follower接收到Leader广播的事务后，会按照
       <strong>
        zxid
       </strong>
       的顺序执行事务，并更新自己的本地
       <strong>
        zxid
       </strong>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4 id="4.%20%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%E4%B8%AD%20zxid%20%E7%9A%84%E4%BD%9C%E7%94%A8" name="4.%20%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%E4%B8%AD%20zxid%20%E7%9A%84%E4%BD%9C%E7%94%A8">
     4.
     <strong>
      选举过程中 zxid 的作用
     </strong>
    </h4>
    <p>
     在选举过程中，每个服务器会携带自己本地的
     <strong>
      zxid
     </strong>
     ，用于比较数据的新旧程度。具体过程如下：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        初始状态
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每个服务器启动时，会从本地磁盘加载最新的
         <strong>
          zxid
         </strong>
         。
        </p>
       </li>
       <li>
        <p>
         如果服务器是第一次启动，或者没有历史数据，则
         <strong>
          zxid
         </strong>
         为
         <code>
          0
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        投票
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每个服务器投票给自己，并携带自己的
         <strong>
          myid
         </strong>
         和
         <strong>
          zxid
         </strong>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        比较投票
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         服务器收到其他服务器的投票后，会比较
         <strong>
          zxid
         </strong>
         ：
        </p>
        <ul>
         <li>
          <p>
           <strong>
            zxid
           </strong>
           越大的服务器，数据越新，优先级越高。
          </p>
         </li>
         <li>
          <p>
           如果
           <strong>
            zxid
           </strong>
           相同，则比较
           <strong>
            myid
           </strong>
           ，
           <strong>
            myid
           </strong>
           越大的服务器优先级越高。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        确定Leader
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当某个服务器收到超过半数的相同投票（即Quorum），它会确定投票中的服务器为Leader。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4 id="5.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%AF%94%E8%BE%83%E6%9C%AC%E5%9C%B0%20zxid%EF%BC%9F" name="5.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%AF%94%E8%BE%83%E6%9C%AC%E5%9C%B0%20zxid%EF%BC%9F">
     5.
     <strong>
      为什么需要比较本地 zxid？
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        确保数据一致性
       </strong>
       ：通过比较
       <strong>
        zxid
       </strong>
       ，可以确保选举出的Leader拥有最新的数据，从而避免数据丢失或不一致。
      </p>
     </li>
     <li>
      <p>
       <strong>
        处理网络分区
       </strong>
       ：在网络分区的情况下，某些服务器可能无法与Leader通信，导致它们的
       <strong>
        zxid
       </strong>
       落后于其他服务器。通过比较
       <strong>
        zxid
       </strong>
       ，可以确保选举出的Leader是最新的。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
     如此在回头看选举过程，就会明朗的多。如果文章帮到了你，请帮主播点个小关小猪哦~~
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393839333837382f:61727469636c652f64657461696c732f313436313335343137" class_="artid" style="display:none">
 </p>
</div>


