---
layout: post
title: "Django-ORM-select_related"
date: 2025-03-11 22:15:52 +0800
description: "如何实现“只发起一次查询，包含所有相关作者信息”对于掌握Django的查询优化至关重要。它通过SQL的JOIN操作，在单个查询中获取相关对象的数据，从而减少数据库查询次数。时，Django会在后台构造一个包含JOIN的SQL语句，一次性从数据库中获取所有需要的数据。操作将主查询和相关模型的查询合并为一个单一的数据库查询。将查询结果分批加载，每次只处理一部分数据，避免一次性加载所有记录。：将读操作和写操作分离到不同的数据库实例，提升查询性能。：只需要执行一次SQL查询，就可以获取所有相关的数据。"
keywords: "Django-ORM-select_related"
categories: ['Python', 'Django']
tags: ['数据库', 'Sqlite', 'Python', 'Django']
artid: "146189949"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146189949
    alt: "Django-ORM-select_related"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146189949
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146189949
cover: https://bing.ee123.net/img/rand?artid=146189949
image: https://bing.ee123.net/img/rand?artid=146189949
img: https://bing.ee123.net/img/rand?artid=146189949
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Django-ORM-select_related
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-kimbie-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     作用
    </h2>
    <p>
     <code>
      select_related
     </code>
     主要用于优化
     <strong>
      一对一(OneToOneField)
     </strong>
     和
     <strong>
      外键(ForeignKey)
     </strong>
     关系中的查询。
     <br/>
     它通过SQL的JOIN操作，在单个查询中获取相关对象的数据，从而减少数据库查询次数。
    </p>
    <h2>
     <a id="_5">
     </a>
     使用场景
    </h2>
    <p>
     • 当你需要访问外键或一对一关系的相关对象时。
     <br/>
     • 适用于深度较浅的关系（通常一层或两层）。
    </p>
    <h2>
     <a id="_9">
     </a>
     示例
    </h2>
    <p>
     假设有以下模型：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models

<span class="token keyword">class</span> <span class="token class-name">Author</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    title <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    author <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>Author<span class="token punctuation">,</span> on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span>
</code></pre>
    <h3>
     <a id="_select_related__24">
     </a>
     无 select_related 的查询
    </h3>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment"># 每次循环都会发起一次数据库查询</span>
</code></pre>
    <p>
     上述代码会对每个
     <code>
      book
     </code>
     对象的
     <code>
      author
     </code>
     执行一次额外的查询，导致“N+1查询问题”。
    </p>
    <h3>
     <a id="_select_related__34">
     </a>
     有 select_related 的查询
    </h3>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment"># 只发起一次查询，包含所有相关作者信息</span>
</code></pre>
    <p>
     通过
     <code>
      select_related
     </code>
     ，Django 在单个查询中使用JOIN语句同时获取
     <code>
      Book
     </code>
     和对应的
     <code>
      Author
     </code>
     数据，避免了多次查询。
    </p>
    <p>
     当然，理解
     <code>
      select_related
     </code>
     如何实现“只发起一次查询，包含所有相关作者信息”对于掌握Django的查询优化至关重要。让我们深入探讨这一过程，包括Django如何构建SQL查询、执行查询以及处理结果。
    </p>
    <hr/>
    <h2>
     <a id="__48">
     </a>
     如何理解 “只发起一次查询，包含所有相关作者信息”
    </h2>
    <h3>
     <a id="1_select_related__49">
     </a>
     1. select_related 的工作原理
    </h3>
    <p>
     <code>
      select_related
     </code>
     通过
     <strong>
      SQL JOIN
     </strong>
     操作将主查询和相关模型的查询合并为一个单一的数据库查询。这意味着，当你调用
     <code>
      select_related
     </code>
     时，Django会在后台构造一个包含JOIN的SQL语句，一次性从数据库中获取所有需要的数据。
    </p>
    <h3>
     <a id="2__51">
     </a>
     2. 具体示例解析
    </h3>
    <p>
     当你执行
     <code>
      Book.objects.select_related('author').all()
     </code>
     时，Django会生成一个包含JOIN的SQL查询。
    </p>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> book<span class="token punctuation">.</span>id<span class="token punctuation">,</span> book<span class="token punctuation">.</span>title<span class="token punctuation">,</span> book<span class="token punctuation">.</span>author_id<span class="token punctuation">,</span> author<span class="token punctuation">.</span>id<span class="token punctuation">,</span> author<span class="token punctuation">.</span>name
<span class="token keyword">FROM</span> book
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> author <span class="token keyword">ON</span> book<span class="token punctuation">.</span>author_id <span class="token operator">=</span> author<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre>
    <p>
     这个查询通过
     <code>
      INNER JOIN
     </code>
     将
     <code>
      book
     </code>
     表和
     <code>
      author
     </code>
     表连接起来，一次性获取所有书籍及其对应的作者信息。
     <br/>
     Django将上述SQL语句发送到数据库执行。数据库处理JOIN操作并返回一个包含所有书籍和作者信息的结果集。
    </p>
    <p>
     Django的ORM会将查询结果映射到相应的Python对象中。具体来说：
    </p>
    <p>
     • 每个
     <code>
      Book
     </code>
     实例都会包含其相关联的
     <code>
      Author
     </code>
     实例。
     <br/>
     • 这些
     <code>
      Author
     </code>
     实例已经被预先加载，不需要额外的数据库查询。
    </p>
    <p>
     因此，当你迭代
     <code>
      books
     </code>
     并访问
     <code>
      book.author.name
     </code>
     时，Django已经拥有了所有必要的数据，直接从内存中获取
     <code>
      author.name
     </code>
     ，而不会发起新的数据库查询。
    </p>
    <h3>
     <a id="3__68">
     </a>
     3. 为什么只发起一次查询
    </h3>
    <p>
     关键在于
     <code>
      select_related
     </code>
     使用了JOIN操作，将多个表的数据合并到一个结果集中。这意味着：
    </p>
    <p>
     •
     <strong>
      单一查询
     </strong>
     ：只需要执行一次SQL查询，就可以获取所有相关的数据。
     <br/>
     •
     <strong>
      减少开销
     </strong>
     ：避免了“N+1查询问题”，即避免了对每个
     <code>
      Book
     </code>
     对象都执行一次额外的查询来获取其
     <code>
      Author
     </code>
     。
    </p>
    <hr/>
    <h2>
     <a id="booksselect_related_76">
     </a>
     数据库中的books量巨大，使用
     <code>
      select_related
     </code>
     导致服务崩掉，如何解决
    </h2>
    <h3>
     <a id="_77">
     </a>
     程序层面优化
    </h3>
    <p>
     拿时间换空间：
    </p>
    <ul>
     <li>
      通过加一些条件只在必要的时候使用 select_related
     </li>
     <li>
      只查询必要字段
     </li>
     <li>
      分页
     </li>
     <li>
      分批
     </li>
     <li>
      迭代器
     </li>
     <li>
      缓存
     </li>
     <li>
      异步
     </li>
    </ul>
    <h4>
     <a id="1___select_related__87">
     </a>
     1. 优化 select_related 的使用
    </h4>
    <p>
     如果某些关联数据不需要，可以避免使用
     <code>
      select_related
     </code>
     ，或者在必要时才使用。
    </p>
    <pre><code class="prism language-python"><span class="token comment"># 只在需要时使用 select_related</span>
books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">if</span> some_condition<span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">:</span>
        author <span class="token operator">=</span> book<span class="token punctuation">.</span>author  <span class="token comment"># 触发单独的查询</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <p>
     或者分情况使用
     <code>
      select_related
     </code>
     ：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>some_field<span class="token operator">=</span>some_value<span class="token punctuation">)</span><span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="2__105">
     </a>
     2. 限制查询字段
    </h4>
    <p>
     只选择需要的字段，减少每次查询的数据量。
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>only<span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'author__name'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <p>
     或者使用
     <code>
      values
     </code>
     或
     <code>
      values_list
     </code>
     ：
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'author__name'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">[</span><span class="token string">'author__name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="3_Pagination_121">
     </a>
     3. 分页（Pagination）
    </h4>
    <p>
     将查询结果分批加载，每次只处理一部分数据，避免一次性加载所有记录。
    </p>
    <h5>
     <a id="_Django__124">
     </a>
     使用 Django 内置的分页器
    </h5>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>core<span class="token punctuation">.</span>paginator <span class="token keyword">import</span> Paginator

books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

paginator <span class="token operator">=</span> Paginator<span class="token punctuation">(</span>books<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment"># 每页100条记录</span>

page_number <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    page <span class="token operator">=</span> paginator<span class="token punctuation">.</span>get_page<span class="token punctuation">(</span>page_number<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> page<span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> page<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    page_number <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre>
    <h5>
     <a id="Cursorbased_Pagination_143">
     </a>
     使用基于游标的分页（Cursor-based Pagination）
    </h5>
    <p>
     对于大数据量且需要高效分页的场景，基于游标的分页更为适用。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> connection

books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span>  <span class="token comment"># 确保有排序字段</span>

batch_size <span class="token operator">=</span> <span class="token number">1000</span>
offset <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    batch <span class="token operator">=</span> books<span class="token punctuation">[</span>offset<span class="token punctuation">:</span>offset <span class="token operator">+</span> batch_size<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> batch<span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> batch<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    offset <span class="token operator">+=</span> batch_size
</code></pre>
    <p>
     <strong>
      注意
     </strong>
     ：对于非常大的数据集，建议使用基于游标的分页库，如
     <a href="https://django-elasticsearch-dsl.readthedocs.io/" rel="nofollow">
      django-elasticsearch-dsl
     </a>
     或其他支持高效分页的工具。
    </p>
    <h4>
     <a id="4__Batch_Processing_165">
     </a>
     4. 批量处理（Batch Processing）
    </h4>
    <p>
     将数据分成较小的批次进行处理，避免一次性加载所有数据。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> transaction

batch_size <span class="token operator">=</span> <span class="token number">1000</span>
books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> books<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    batch <span class="token operator">=</span> books<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> batch_size<span class="token punctuation">]</span>
    <span class="token keyword">with</span> transaction<span class="token punctuation">.</span>atomic<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 根据需要使用事务</span>
        <span class="token keyword">for</span> book <span class="token keyword">in</span> batch<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <h4>
     <a id="5__iterator_182">
     </a>
     5. 使用 iterator
    </h4>
    <p>
     <code>
      iterator
     </code>
     方法可以逐批从数据库中获取数据，减少内存消耗。
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      注意
     </strong>
     ：使用
     <code>
      iterator
     </code>
     后，无法再次遍历查询集，且缓存机制会有所不同。
    </p>
    <h4>
     <a id="6__prefetch_related__select_related_193">
     </a>
     6. 使用 prefetch_related 结合 select_related
    </h4>
    <p>
     在某些复杂查询中，可以结合使用
     <code>
      select_related
     </code>
     和
     <code>
      prefetch_related
     </code>
     来优化性能。
    </p>
    <pre><code class="prism language-python">books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prefetch_related<span class="token punctuation">(</span><span class="token string">'other_related_field'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <p>
     但对于大数据量，通常建议优先考虑分页或批量处理。
    </p>
    <h4>
     <a id="7__204">
     </a>
     7. 数据库索引优化
    </h4>
    <p>
     确保在
     <code>
      Book
     </code>
     表的
     <code>
      author_id
     </code>
     字段上有索引，以加快 JOIN 操作的速度。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    title <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    author <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>Author<span class="token punctuation">,</span> on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">,</span> db_index<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment"># 确保有索引</span>
</code></pre>
    <h4>
     <a id="8__214">
     </a>
     8. 缓存机制
    </h4>
    <p>
     对于不经常变化的数据，可以使用缓存来减少数据库查询次数。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>core<span class="token punctuation">.</span>cache <span class="token keyword">import</span> cache

<span class="token keyword">def</span> <span class="token function">get_books</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    books <span class="token operator">=</span> cache<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'all_books'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> books<span class="token punctuation">:</span>
        books <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cache<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">'all_books'</span><span class="token punctuation">,</span> books<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">15</span><span class="token punctuation">)</span>  <span class="token comment"># 缓存15分钟</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      注意
     </strong>
     ：缓存大数据量可能会占用大量内存，需谨慎使用。
    </p>
    <h4>
     <a id="9__232">
     </a>
     9. 异步处理
    </h4>
    <p>
     将耗时的处理任务放到异步队列中执行，如 Celery，避免阻塞主线程。
    </p>
    <pre><code class="prism language-python"><span class="token comment"># tasks.py</span>
<span class="token keyword">from</span> celery <span class="token keyword">import</span> shared_task
<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Book

<span class="token decorator annotation punctuation">@shared_task</span>
<span class="token keyword">def</span> <span class="token function">process_books</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    books <span class="token operator">=</span> Book<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>select_related<span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> book <span class="token keyword">in</span> books<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>author<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment"># 在视图中调用</span>
process_books<span class="token punctuation">.</span>delay<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     ，
    </p>
    <h3>
     <a id="_251">
     </a>
     数据库层面优化
    </h3>
    <h4>
     <a id="10__252">
     </a>
     10. 数据库层面的优化
    </h4>
    <blockquote>
     <p>
      https://blog.csdn.net/2303_78378466/article/details/145123310
     </p>
    </blockquote>
    <p>
     •
     <strong>
      分表分库
     </strong>
     ：将
     <code>
      books
     </code>
     表拆分成多个子表或数据库，减少单个查询的压力。
     <br/>
     •
     <strong>
      读写分离
     </strong>
     ：将读操作和写操作分离到不同的数据库实例，提升查询性能。
     <br/>
     •
     <strong>
      使用更高效的数据库
     </strong>
     ：如 PostgreSQL 在处理复杂查询时性能更优，可以考虑切换数据库。
    </p>
    <p>
    </p>
    <div class="toc">
     <h4>
      Django-ORM-select_related
     </h4>
     <ul>
      <li>
       <a href="#_1" rel="nofollow">
        作用
       </a>
      </li>
      <li>
       <a href="#_5" rel="nofollow">
        使用场景
       </a>
      </li>
      <li>
       <a href="#_9" rel="nofollow">
        示例
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_select_related__24" rel="nofollow">
          无 select_related 的查询
         </a>
        </li>
        <li>
         <a href="#_select_related__34" rel="nofollow">
          有 select_related 的查询
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#__48" rel="nofollow">
        如何理解 "只发起一次查询，包含所有相关作者信息"
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#1_select_related__49" rel="nofollow">
          1. select_related 的工作原理
         </a>
        </li>
        <li>
         <a href="#2__51" rel="nofollow">
          2. 具体示例解析
         </a>
        </li>
        <li>
         <a href="#3__68" rel="nofollow">
          3. 为什么只发起一次查询
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#booksselect_related_76" rel="nofollow">
        数据库中的books量巨大，使用`select_related`导致服务崩掉，如何解决
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#_77" rel="nofollow">
          程序层面优化
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1___select_related__87" rel="nofollow">
            1. 优化 select_related 的使用
           </a>
          </li>
          <li>
           <a href="#2__105" rel="nofollow">
            2. 限制查询字段
           </a>
          </li>
          <li>
           <a href="#3_Pagination_121" rel="nofollow">
            3. 分页（Pagination）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#_Django__124" rel="nofollow">
              使用 Django 内置的分页器
             </a>
            </li>
            <li>
             <a href="#Cursorbased_Pagination_143" rel="nofollow">
              使用基于游标的分页（Cursor-based Pagination）
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#4__Batch_Processing_165" rel="nofollow">
            4. 批量处理（Batch Processing）
           </a>
          </li>
          <li>
           <a href="#5__iterator_182" rel="nofollow">
            5. 使用 iterator
           </a>
          </li>
          <li>
           <a href="#6__prefetch_related__select_related_193" rel="nofollow">
            6. 使用 prefetch_related 结合 select_related
           </a>
          </li>
          <li>
           <a href="#7__204" rel="nofollow">
            7. 数据库索引优化
           </a>
          </li>
          <li>
           <a href="#8__214" rel="nofollow">
            8. 缓存机制
           </a>
          </li>
          <li>
           <a href="#9__232" rel="nofollow">
            9. 异步处理
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#_251" rel="nofollow">
          数据库层面优化
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#10__252" rel="nofollow">
            10. 数据库层面的优化
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32323033383332372f:61727469636c652f64657461696c732f313436313839393439" class_="artid" style="display:none">
 </p>
</div>


