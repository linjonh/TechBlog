---
layout: post
title: "数据结构-线性表"
date: 2025-03-16 21:44:03 +0800
description: "【代码】数据结构------线性表。"
keywords: "数据结构------线性表"
categories: ['未分类']
tags: ['数据结构', 'Windows']
artid: "146302087"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146302087
    alt: "数据结构-线性表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146302087
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146302087
cover: https://bing.ee123.net/img/rand?artid=146302087
image: https://bing.ee123.net/img/rand?artid=146302087
img: https://bing.ee123.net/img/rand?artid=146302087
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构------线性表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、线性表顺序存储详解
    </h2>
    <hr/>
    <h4>
     （一）线性表核心概念
    </h4>
    <h5>
     1. 结构定义
    </h5>
    <pre><code>// 数据元素类型
typedef struct person {
    char name[32];
    char sex;
    int age;
    int score;
} DATATYPE;

// 顺序表结构
typedef struct list {
    DATATYPE *head;  // 存储空间基地址
    int tlen;        // 表总长度
    int clen;        // 当前元素个数
} SeqList;
</code></pre>
    <h5>
     2. 核心特性
    </h5>
    <ul>
     <li>
      <strong>
       有限性
      </strong>
      ：元素个数n ≥ 0
     </li>
     <li>
      <strong>
       有序性
      </strong>
      ：元素位置由序号确定（a₁~aₙ）
     </li>
     <li>
      <strong>
       同类型
      </strong>
      ：所有元素属于同一数据类
     </li>
    </ul>
    <hr/>
    <h4>
     （二）基本操作接口
    </h4>
    <h5>
     1. 创建/销毁
    </h5>
    <pre><code>// 创建顺序表
SeqList *CreateSeqList(int len) {
    SeqList *list = (SeqList *)malloc(sizeof(SeqList));
    list-&gt;head = (DATATYPE *)malloc(len * sizeof(DATATYPE));
    list-&gt;tlen = len;
    list-&gt;clen = 0;
    return list;
}

// 销毁顺序表
int DestroySeqList(SeqList *list) {
    free(list-&gt;head);
    free(list);
    return 0;
}
</code></pre>
    <h5>
     2. 状态判断
    </h5>
    <pre><code>// 判断表满
int IsFullSeqList(SeqList *list) {
    return list-&gt;clen &gt;= list-&gt;tlen;
}

// 判断表空
int IsEmptySeqList(SeqList *list) {
    return list-&gt;clen == 0;
}
</code></pre>
    <hr/>
    <h4>
     （三）核心操作实现
    </h4>
    <h5>
     1. 插入操作
    </h5>
    <pre><code>// 尾部插入
int InsertTailSeqList(SeqList *list, DATATYPE data) {
    if (IsFullSeqList(list)) return -1;
    list-&gt;head[list-&gt;clen++] = data;
    return 0;
}

// 指定位置插入
int InsertPosSeqList(SeqList *list, DATATYPE data, int pos) {
    if (pos &lt; 0 || pos &gt; list-&gt;clen) return -1;
    if (IsFullSeqList(list)) return -1;
    
    // 移动后续元素
    for(int i = list-&gt;clen; i &gt; pos; i--) {
        list-&gt;head[i] = list-&gt;head[i-1];
    }
    
    list-&gt;head[pos] = data;
    list-&gt;clen++;
    return 0;
}
</code></pre>
    <h5>
     2. 删除操作
    </h5>
    <pre><code>// 按姓名删除
int DeleteSeqList(SeqList *list, char *name) {
    for(int i = 0; i &lt; list-&gt;clen; i++) {
        if(strcmp(list-&gt;head[i].name, name) == 0) {
            // 前移后续元素
            for(int j = i; j &lt; list-&gt;clen-1; j++) {
                list-&gt;head[j] = list-&gt;head[j+1];
            }
            list-&gt;clen--;
            return 0;
        }
    }
    return -1;
}
</code></pre>
    <hr/>
    <h4>
     （四）性能分析
    </h4>
    <h5>
     1. 时间复杂度对比
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        操作
       </th>
       <th>
        最好情况
       </th>
       <th>
        最坏情况
       </th>
       <th>
        平均情况
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        随机访问
       </td>
       <td>
        O(1)
       </td>
       <td>
        O(1)
       </td>
       <td>
        O(1)
       </td>
      </tr>
      <tr>
       <td>
        插入/删除
       </td>
       <td>
        O(1)
       </td>
       <td>
        O(n)
       </td>
       <td>
        O(n)
       </td>
      </tr>
      <tr>
       <td>
        查找
       </td>
       <td>
        O(1)
       </td>
       <td>
        O(n)
       </td>
       <td>
        O(n)
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     2. 空间复杂度
    </h5>
    <ul>
     <li>
      存储空间：O(n)
     </li>
     <li>
      额外空间：O(1)
     </li>
    </ul>
    <hr/>
    <h4>
     （五）内存管理实践
    </h4>
    <h5>
     1. 内存管理要点
    </h5>
    <ol>
     <li>
      <strong>
       malloc/free配对
      </strong>
      ：确保每个分配都有释放
     </li>
     <li>
      <strong>
       越界访问检查
      </strong>
      ：严格验证索引范围
     </li>
     <li>
      <strong>
       野指针处理
      </strong>
      ：释放后置空指针
      <pre><code>free(list-&gt;head);
list-&gt;head = NULL;  // 重要！
</code></pre>
     </li>
    </ol>
    <hr/>
    <h4>
     （六）顺序存储优劣分析
    </h4>
    <h5>
     1. 优势场景
    </h5>
    <ul>
     <li>
      <strong>
       高频随机访问
      </strong>
      ：学生成绩快速查询
     </li>
     <li>
      <strong>
       数据规模稳定
      </strong>
      ：固定长度的传感器数据缓存
     </li>
     <li>
      <strong>
       内存敏感场景
      </strong>
      ：无额外指针开销
     </li>
    </ul>
    <h5>
     2. 局限场景
    </h5>
    <ul>
     <li>
      <strong>
       动态数据管理
      </strong>
      ：实时消息队列
     </li>
     <li>
      <strong>
       高频插入删除
      </strong>
      ：聊天记录管理
     </li>
     <li>
      <strong>
       超大稀疏数据
      </strong>
      ：地图坐标存储
     </li>
    </ul>
    <h4>
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343338323937302f:61727469636c652f64657461696c732f313436333032303837" class_="artid" style="display:none">
 </p>
</div>


