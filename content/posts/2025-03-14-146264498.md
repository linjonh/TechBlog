---
layout: post
title: "Java高级-04.反射-获取成员变量和方法对象并使用"
date: 2025-03-14 20:21:47 +0800
description: "【代码】Java高级-04.反射-获取成员变量和方法对象并使用。"
keywords: "Java高级-04.反射-获取成员变量和方法对象并使用"
categories: ['Javase']
tags: ['开发语言', '反射', 'Javase', 'Java']
artid: "146264498"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146264498
    alt: "Java高级-04.反射-获取成员变量和方法对象并使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146264498
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146264498
cover: https://bing.ee123.net/img/rand?artid=146264498
image: https://bing.ee123.net/img/rand?artid=146264498
img: https://bing.ee123.net/img/rand?artid=146264498
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java高级-04.反射-获取成员变量和方法对象并使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一.获取类的成员变量
    </h2>
    <pre><code class="language-java">package com.njau.d2_reflect;



public class Cat {
    public static int a;
    public static final String COUNTRY = "中国";
    private String name;
    private int age;

    public Cat(String name, int age) {
        System.out.println("有参数构造器执行了！");
        this.name = name;
        this.age = age;
    }

    public Cat() {
        System.out.println("无参构造器执行了！");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
</code></pre>
    <p>
     <img alt="" height="601" src="https://i-blog.csdnimg.cn/direct/d1980ca462f148f68d5e89632eb783d6.png" width="1405"/>
    </p>
    <h4>
     * public Field[] getFields()   获取类的全部成员变量（只能获取public修饰的）
     <br/>
     * public Field[] getDeclaredFields()  获取类的全部成员变量（只要存在就能拿到）
     <br/>
     * public Field getField()   获取类的某个成员变量（只能获取public修饰的）
     <br/>
     * public Field getDeclaredField()  获取类的全部成员变量（只要存在就能拿到）
    </h4>
    <h4>
     返回回来的是一个Filed类型的对象。可以使用数组接收多个。
    </h4>
    <pre><code class="language-java">package com.njau.d2_reflect;

import org.junit.Test;

import java.lang.reflect.Field;

/**
 * 目标：掌握获取类的成员变量
 * Class提供了从类中获取成员变量的方法
 * public Field[] getFields()   获取类的全部成员变量（只能获取public修饰的）
 * public Field[] getDeclaredFields()  获取类的全部成员变量（只要存在就能拿到）
 * public Field getField(String name)   获取类的某个成员变量（只能获取public修饰的）
 * public Field getDeclaredField(String name)  获取类的全部成员变量（只要存在就能拿到）
 * 获取到成员变量的作用：依然是赋值，取值
 * void set(Object obj,Object value)   赋值
 * Object get(Object obj)   取值
 * public void setAccessible(boolean flag)   设置为true，表示禁止检查访问控制（暴力反射）
 */

public class Test3Field {
    @Test
    public void testGetFields() throws Exception {
        // 1、反射第一步：首先获取到类Class对象
        Class c = Cat.class;

        // 2、public Field[] getFields()   获取类的全部成员变量（只能获取public修饰的）
//        Field[] fields = c.getFields();
        Field[] fields = c.getDeclaredFields();    // 获取类的全部成员变量（只要存在就能拿到）

        for (Field field : fields) {
            System.out.println(field.getName() + "---&gt;" + field.getType());
        }

        // 3、public Field getField(String name)   获取类的某个成员变量（只能获取public修饰的）
        Field fName = c.getDeclaredField("name");
        System.out.println(fName.getName() + "---&gt;" + fName.getType());    // name---&gt;class java.lang.String

        // 4、public Field getDeclaredField(String name)  获取类的某个成员变量（只要存在就能拿到）
        Field fAge = c.getDeclaredField("age");
        System.out.println(fAge.getName() + "---&gt;" + fAge.getType());   // age---&gt;int
    }
}
</code></pre>
    <p>
     <img alt="" height="345" src="https://i-blog.csdnimg.cn/direct/0d560780edd14716bc5f9cb73c8c0260.png" width="1104"/>
    </p>
    <h4>
     获取成员变量的作用：依然是赋值、取值
     <img alt="" height="416" src="https://i-blog.csdnimg.cn/direct/35f4e8ac1d5f4c0b81b23c4a3a0bd93d.png" width="1405"/>
    </h4>
    <h4>
     使用set进行赋值，但是赋值时必须要创建出该类的实例化对象，否则这个值又赋给谁呢？同样的，使用get方法时也要传入该类的实例化对象，否则不知道获取哪个对象的成员变量值。
    </h4>
    <h4>
     注意：我们在获得构造器和成员变量的时候均不用setAccessible方法，而是在
     <span style="color:#fe2c24">
      使用
     </span>
     构造器实例化对象和使用成员变量赋值的时候，对于私有的构造器和成员变量才要使用setAccessible方法。成员方法也和上述一样。
    </h4>
    <pre><code class="language-java">package com.njau.d2_reflect;

import org.junit.Test;

import java.lang.reflect.Field;

/**
 * 目标：掌握获取类的成员变量
 * Class提供了从类中获取成员变量的方法
 * public Field[] getFields()   获取类的全部成员变量（只能获取public修饰的）
 * public Field[] getDeclaredFields()  获取类的全部成员变量（只要存在就能拿到）
 * public Field getField()   获取类的某个成员变量（只能获取public修饰的）
 * public Field getDeclaredField()  获取类的全部成员变量（只要存在就能拿到）
 * 获取到成员变量的作用：依然是赋值，取值
 * void set(Object obj,Object value)   赋值
 * Object get(Object obj)   取值
 * public void setAccessible(boolean flag)   设置为true，表示禁止检查访问控制（暴力反射）
 */

public class Test3Field {
    @Test
    public void testGetFields() throws Exception {
        // 1、反射第一步：首先获取到类Class对象
        Class c = Cat.class;

        // 2、public Field[] getFields()   获取类的全部成员变量（只能获取public修饰的）
//        Field[] fields = c.getFields();
        Field[] fields = c.getDeclaredFields();    // 获取类的全部成员变量（只要存在就能拿到）

        for (Field field : fields) {
            System.out.println(field.getName() + "---&gt;" + field.getType());
        }

        // 3、public Field getField(String name)   获取类的某个成员变量（只能获取public修饰的）
        Field fName = c.getDeclaredField("name");
        System.out.println(fName.getName() + "---&gt;" + fName.getType());    // name---&gt;class java.lang.String

        // 4、public Field getDeclaredField(String name)  获取类的某个成员变量（只要存在就能拿到）
        Field fAge = c.getDeclaredField("age");
        System.out.println(fAge.getName() + "---&gt;" + fAge.getType());   // age---&gt;int
    }

    @Test
    public void testSetAndGet() throws Exception {
        Class c = Cat.class;
        Cat cat = new Cat();
//        获取某个类的成员变量
        Field fName = c.getDeclaredField("name");
//        public void setAccessible(boolean flag)   设置为true，表示禁止检查访问控制（暴力反射）
        fName.setAccessible(true);   // 禁止访问控制权限
//        void set(Object obj,Object value)   赋值
        fName.set(cat, "招财猫");
//        Object get(Object obj)   取值
        String name = (String) fName.get(cat);
        System.out.println(name);
        System.out.println(cat);

        Field fAge = c.getDeclaredField("age");
//        public void setAccessible(boolean flag)   设置为true，表示禁止检查访问控制（暴力反射）
        fAge.setAccessible(true);
//        void set(Object obj,Object value)   赋值
        fAge.set(cat,3);
//        Object get(Object obj)   取值
        int age = (int) fAge.get(cat);
        System.out.println(age);
        System.out.println(cat);
    }
}
</code></pre>
    <h4>
     调用get方法时并不知道返回的成员变量类型，因此java官方为我们设定了Object类型。但是我们要将其进行强制转换。
     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/19c93dd4cd0a49b6a0fdb5d8eb6c877c.png" width="410"/>
    </h4>
    <h2>
     二.获取类的成员方法
    </h2>
    <pre><code class="language-java">package com.njau.d2_reflect;



public class Cat {
    public static int a;
    public static final String COUNTRY = "中国";
    private String name;
    private int age;

    public Cat(String name, int age) {
        System.out.println("有参数构造器执行了！");
        this.name = name;
        this.age = age;
    }

    public Cat() {
        System.out.println("无参构造器执行了！");
    }

    public String getName() {
        return name;
    }

    private void run() {
        System.out.println("🐱跑的贼快~~");
    }

    public void eat() {
        System.out.println("🐱爱吃猫粮~~");
    }

    // 方法的重载
    private String eat(String name) {
        return "🐱爱吃" + name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
</code></pre>
    <p>
     <img alt="" height="616" src="https://i-blog.csdnimg.cn/direct/57a10ed3f549486ba28e6a8e477d150d.png" width="1776"/>
    </p>
    <h4>
     * Method[] getMethods()   获取类的全部成员方法（只能获取public修饰的）
     <br/>
     * Method[] getDeclaredMethods()   获取类的全部成员方法（只要存在就能获取）
     <br/>
     * Method[] getMethod(String name,Class&lt;?&gt; ... parameterTypes)   获取类的某个成员方法（只能获取public修饰的）
     <br/>
     * Method[] getDeclaredMethod(String name,Class&lt;?&gt; ... parameterTypes)   获取类的某个成员方法（只要存在就能获取）
    </h4>
    <h4>
     首先我们要获取类的成员方法，就要先获取类对象。因此反射的第一步永远都是获取类对象。
    </h4>
    <pre><code class="language-java">package com.njau.d2_reflect;

import org.junit.Test;

import java.lang.reflect.Method;

/**
 * 目标：获取类的成员方法
 * Method[] getMethods()   获取类的全部成员方法（只能获取public修饰的）
 * Method[] getDeclaredMethods()   获取类的全部成员方法（只要存在就能获取）
 * Method[] getMethod(String name,Class&lt;?&gt; ... parameterTypes)   获取类的某个成员方法（只能获取public修饰的）
 * Method[] getDeclaredMethod(String name,Class&lt;?&gt; ... parameterTypes)   获取类的某个成员方法（只要存在就能获取）
 * 成员方法的作用：依然是执行
 * public Object invoke(Object obj, Object ... args)   出发某个对象的该方法执行  Object obj代表类的某个实例对象
 * public void setAccessible(boolean flag)  设置为true，表示禁止检查访问控制（暴力反射）
 */
public class Test4Method {
    @Test
    public void testGetDeclaredMethods() throws Exception {
        // 1、反射第一步：首先获取Class对象
        Class c = Cat.class;

        // 2、获取类的全部成员方法
        Method[] methods = c.getDeclaredMethods();
        // 3、对所有成员方法进行遍历
        for (Method method : methods) {
            System.out.println(method.getName() + "---&gt;" + method.getParameterCount()
                    + "---&gt;" + method.getReturnType());
        }

        // 4、获得某个成员方法
        Method run = c.getDeclaredMethod("run");
        System.out.println(run.getName() + "---&gt;" + run.getParameterCount()
                + "---&gt;" + run.getReturnType());  // run---&gt;0---&gt;void

        Method eat = c.getDeclaredMethod("eat",String.class);
        System.out.println(eat.getName() + "---&gt;" + eat.getParameterCount()
                + "---&gt;" + eat.getReturnType());  // eat---&gt;1---&gt;class java.lang.String
    }
}
</code></pre>
    <h4>
     我们使用getDeclaredMethods()方法来获取类中的全部实例对象。然后用Method类型的数据对其进行封装。封装后我们进行遍历，在遍历时我们可以使用：
    </h4>
    <h4>
     1.getName()方法获得该方法的方法名
    </h4>
    <h4>
     2.getParameterCount()方法获得该方法的参数个数
    </h4>
    <h4>
     3.getReturnType()方法获得该方法的返回值类型
    </h4>
    <h4>
     我们使用getDeclaredMethod(String name,Class&lt;?&gt; ... parameterTypes)方法来获取类中的指定的实例对象。其中要获得指定的方法吗，就要在name字段指定方法名，在Class&lt;?&gt; ... parameterTypes字段指定参数类型。
     <img alt="" height="268" src="https://i-blog.csdnimg.cn/direct/c6d7b2e552ab4802b434887e71d68793.png" width="972"/>
    </h4>
    <h4>
     通过反射获得成员方法的作用依然是执行
    </h4>
    <h4>
     <img alt="" height="373" src="https://i-blog.csdnimg.cn/direct/ab4ee46c35eb4a6db66cce61316b81f9.png" width="1772">
      * public Object invoke(Object obj, Object ... args)   出发某个对象的该方法执行  Object obj代表类的某个实例对象
      <br/>
      * public void setAccessible(boolean flag)  设置为true，表示禁止检查访问控制（暴力反射）
     </img>
    </h4>
    <h4>
     我们可以在获得成员方法对象后通过invoke方法执行该成员方法。但是在使用invoke方法之前，我们首先要new一个该方法所在类的实例化对象，因为这个成员方法是该类的成员方法，是通过该类的实例化对象进行调用的。因此要先将该类实例化对象出来，再将该对象传入invoke方法里才能够进行调用。
    </h4>
    <pre><code class="language-java">package com.njau.d2_reflect;

import org.junit.Test;

import java.lang.reflect.Method;

/**
 * 目标：获取类的成员方法
 * Method[] getMethods()   获取类的全部成员方法（只能获取public修饰的）
 * Method[] getDeclaredMethods()   获取类的全部成员方法（只要存在就能获取）
 * Method[] getMethod(String name,Class&lt;?&gt; ... parameterTypes)   获取类的某个成员方法（只能获取public修饰的）
 * Method[] getDeclaredMethod(String name,Class&lt;?&gt; ... parameterTypes)   获取类的某个成员方法（只要存在就能获取）
 * 成员方法的作用：依然是执行
 * public Object invoke(Object obj, Object ... args)   出发某个对象的该方法执行  Object obj代表类的某个实例对象
 * public void setAccessible(boolean flag)  设置为true，表示禁止检查访问控制（暴力反射）
 */
public class Test4Method {
    @Test
    public void testGetDeclaredMethods() throws Exception {
        // 1、反射第一步：首先获取Class对象
        Class c = Cat.class;

        // 2、获取类的全部成员方法
        Method[] methods = c.getDeclaredMethods();
        // 3、对所有成员方法进行遍历
        for (Method method : methods) {
            System.out.println(method.getName() + "---&gt;" + method.getParameterCount()
                    + "---&gt;" + method.getReturnType());
        }

        // 4、获得某个成员方法
        Method run = c.getDeclaredMethod("run");
        System.out.println(run.getName() + "---&gt;" + run.getParameterCount()
                + "---&gt;" + run.getReturnType());  // run---&gt;0---&gt;void

        Method eat = c.getDeclaredMethod("eat",String.class);
        System.out.println(eat.getName() + "---&gt;" + eat.getParameterCount()
                + "---&gt;" + eat.getReturnType());  // eat---&gt;1---&gt;class java.lang.String

        Cat cat = new Cat();  // 创建一个猫对象
        run.setAccessible(true);   // 表示禁止检查访问控制（暴力反射）
        Object object = run.invoke(cat);  // 🐱跑的贼快~~
        System.out.println(object);  // null  没有返回值，就是null

        eat.setAccessible(true);
        String food = (String) eat.invoke(cat, "鱼儿");
        System.out.println(food);
    }
}
</code></pre>
    <h4>
     我们使用获取到的成员方法对象run调用invoke方法执行run方法，在调用invoke方法前我们实例化一个Cat类对象cat，并将该对象传入invoke方法中，又因为run方法没有参数，因此不需要传递参数。也没有返回值，因此返回值为null。java官方并不知道我们的方法返回值类型是什么，因此统一使用Object进行接收。
    </h4>
    <h4>
     同样的，在调用eat的重载方法时，有一个参数String类型的，因此要传入一个字符串。且返回值是一个字符串，因此要使用String类型的变量接收并打印出来。
    </h4>
    <h4>
     当我们在调用invoke进行方法的执行时，由于我们的方法在定义时都是用private修饰的，因此再调用invoke执行该方法时会出现权限不够，因此要使用setAccessible()方法将其设置为true。才能保证正常执行。
     <img alt="" height="315" src="https://i-blog.csdnimg.cn/direct/76e27f70c31e414ca2ea196b47f621a6.png" width="1221"/>
    </h4>
    <h4>
     执行结果：
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/aff11f1c74d5419881b48b4d67b51079.png" width="1171"/>
    </h4>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353035353835362f:61727469636c652f64657461696c732f313436323634343938" class_="artid" style="display:none">
 </p>
</div>


