---
layout: post
title: "Python代码加密方案"
date: 2022-07-20 15:04:30 +0800
description: "Python代码加密方案_python加密代码"
keywords: "python加密代码"
categories: ['Python']
tags: ['开发语言', 'Python']
artid: "125892531"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=125892531
    alt: "Python代码加密方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=125892531
featuredImagePreview: https://bing.ee123.net/img/rand?artid=125892531
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python代码加密方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="Python_0">
     </a>
     Python代码加密方案
    </h4>
    <h6>
     <a id="1Pyarmor_2">
     </a>
     方案1：使用Pyarmor工具进行加密
    </h6>
    <p>
     PyArmor 是一个用于加密和保护 Python 脚本的工具。它能够在运行时刻保护 Python脚本的二进制代码不被泄露，设置加密后 Python 源代码的有效期限，绑定加密后的Python源代码到硬盘、网卡等硬件设备。
    </p>
    <h6>
     <a id="1_6">
     </a>
     1、安装
    </h6>
    <pre><code class="prism language-python">pip install pyarmor

<span class="token comment"># 验证是否安装成功, 7.0 以下版本为稳定版</span>
pyarmor <span class="token operator">-</span><span class="token operator">-</span>version
</code></pre>
    <h6>
     <a id="2_15">
     </a>
     2、加密过程
    </h6>
    <ul>
     <li>
      <p>
       首先把源代码编译成代码块
      </p>
      <blockquote>
       <pre><code class="prism language-python">char <span class="token operator">*</span>filename <span class="token operator">=</span> <span class="token string">"foo.py"</span><span class="token punctuation">;</span>
char <span class="token operator">*</span>source <span class="token operator">=</span> read_file<span class="token punctuation">(</span> filename <span class="token punctuation">)</span><span class="token punctuation">;</span>
PyCodeObject <span class="token operator">*</span>co <span class="token operator">=</span> Py_CompileString<span class="token punctuation">(</span> source<span class="token punctuation">,</span> <span class="token string">"&lt;frozen foo&gt;"</span><span class="token punctuation">,</span> Py_file_input <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </blockquote>
     </li>
     <li>
      <p>
       接着进行如下处理
      </p>
      <ol>
       <li>
        <p>
         使用 try…finally 语句把代码块的代码段 co_code 包裹起来
        </p>
        <blockquote>
         <pre><code class="prism language-python">新添加一个头部，对应于 <span class="token keyword">try</span> 语句<span class="token punctuation">:</span>

        LOAD_GLOBALS    N <span class="token punctuation">(</span>__armor_enter__<span class="token punctuation">)</span>     N <span class="token operator">=</span> length of co_consts
        CALL_FUNCTION   <span class="token number">0</span>
        POP_TOP
        SETUP_FINALLY   X <span class="token punctuation">(</span>jump to wrap footer<span class="token punctuation">)</span> X <span class="token operator">=</span> size of original byte code

接着是处理过的原始代码段<span class="token punctuation">:</span>

        对于所有的绝对跳转指令，操作数增加头部字节数

        加密修改过的所有指令代码

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

追加一个尾部，对应于 <span class="token keyword">finally</span> 块<span class="token punctuation">:</span>

        LOAD_GLOBALS    N <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">(</span>__armor_exit__<span class="token punctuation">)</span>
        CALL_FUNCTION   <span class="token number">0</span>
        POP_TOP
        END_FINALLY
</code></pre>
        </blockquote>
       </li>
       <li>
        <p>
         添加字符串名称 __armor_enter, __armor_exit__ 到 co_consts
        </p>
       </li>
       <li>
        <p>
         如果 co_stacksize 小于 4，那么设置为 4
        </p>
       </li>
       <li>
        <p>
         在 co_flags 设置自定义的标志位 CO_OBFUSCAED (0x80000000)
        </p>
       </li>
       <li>
        <p>
         按照上面的方式递归修改 co_consts 中的所有类型为代码块的常量
        </p>
       </li>
      </ol>
     </li>
     <li>
      <p>
       然后把改装后的代码块转换成为字符串，把字符串进行加密，保护其中的常量和字符串
      </p>
      <blockquote>
       <pre><code class="prism language-python">char <span class="token operator">*</span>string_code <span class="token operator">=</span> marshal<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span> co <span class="token punctuation">)</span><span class="token punctuation">;</span>
char <span class="token operator">*</span>obfuscated_code <span class="token operator">=</span> obfuscate_algorithm<span class="token punctuation">(</span> string_code  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </blockquote>
     </li>
     <li>
      <p>
       最后生成加密后的脚本，写入到磁盘文件
      </p>
      <blockquote>
       <pre><code class="prism language-python">sprintf<span class="token punctuation">(</span> buf<span class="token punctuation">,</span> <span class="token string">"__pyarmor__(__name__, __file__, b'%s')"</span><span class="token punctuation">,</span> obfuscated_code <span class="token punctuation">)</span><span class="token punctuation">;</span>
save_file<span class="token punctuation">(</span> <span class="token string">"dist/foo.py"</span><span class="token punctuation">,</span> buf <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </blockquote>
     </li>
    </ul>
    <h6>
     <a id="3_75">
     </a>
     3、加密模式
    </h6>
    <p>
     PyArmor 提供多种加密模式，以满足安全和性能方面的平衡。通常情况下，默认 的加密模式能够满足绝大多数的需要，一般情况下也不需要对加密模式有详细 的了解。仅当对性能有特别的要求或者默认加密模式无法满足需求的时候，才需 要改变加密模式，这就需要理解 PyArmor 的不同加密模式。
    </p>
    <ul>
     <li>
      <p>
       默认加密模式
      </p>
      <blockquote>
       <p>
        加密脚本命令
       </p>
       <p>
        pyarmor obfuscate xx.py
       </p>
      </blockquote>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       超级模式
      </p>
      <blockquote>
       <p>
        目前支持版本
       </p>
       <ol>
        <li>
         <p>
          python 2.7
         </p>
        </li>
        <li>
         <p>
          python 3.7
         </p>
        </li>
       </ol>
       <p>
        加密脚本命令
       </p>
       <p>
        pyarmor obfuscate --advanced 2 xx.py
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       高级模式
      </p>
      <blockquote>
       <p>
        加密脚本命令
       </p>
       <p>
        pyarmor obfuscate --advanced 1 xx.py
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       其他加密模式(不常用)
      </p>
      <blockquote>
       <ol>
        <li>
         <p>
          代码加密模式
         </p>
        </li>
        <li>
         <p>
          代码包裹模式
         </p>
        </li>
        <li>
         <p>
          模块加密模式
         </p>
        </li>
        <li>
         <p>
          约束模式
         </p>
        </li>
       </ol>
      </blockquote>
     </li>
    </ul>
    <h6>
     <a id="4pyarmor_115">
     </a>
     4、使用pyarmor
    </h6>
    <ol>
     <li>
      <p>
       加密脚本
      </p>
      <blockquote>
       <p>
        pyarmor [command] [options]
       </p>
       <p>
        常用命令：pyarmor obfuscate main.py
       </p>
       <p>
        pyarmor会加密main.py文件和相同目录下的所有*.py文件，并创建输出子目录dist, 生成加密的主脚本main,py、相同目录下的**.py、生成的运行加密脚本所需的全部辅助文件保存到dis输出目录
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       发布加密脚本
      </p>
      <blockquote>
       <p>
        发布加密脚本给客户只需要把输出路径dist的所有文件拷贝过去即可
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       生成新的许可文件（可选）
      </p>
      <blockquote>
       <p>
        使用命令 licenses为加密脚本生成新的许可文件license.lic，加密脚本的同时会在输出目录下面生成一个默认许可文件，dist/licnese.lic，需要生成新的许可文件，并覆盖默认许可文件
       </p>
       <p>
        例如：
       </p>
       <p>
        pyarmor licneses --expired 2019 -01-01 code-001
       </p>
       <p>
        执行该命令会生成一个带有效期的认证文件，这样超过指定日期后加密脚本就无法正常运行了
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       绑定加密脚本到固定机器上（可选）
      </p>
      <blockquote>
       <p>
        如果想绑定加密脚本到固定机器上，首先在该机器上面运行下面的命令获取硬件信息
       </p>
       <p>
        pyarmor hdinfo
       </p>
       <p>
        然后生成绑定到固定机器的许可文件
       </p>
       <p>
        pyarmor licenses --bind-disk “100304PBN2081SF3NJ5T” --bind-mac “20:c1:d2:2f:a0:96” code-002，
       </p>
      </blockquote>
      <p>
       同样，覆盖默认的许可证，这样加密脚本就只能在指定机器上运行
      </p>
     </li>
    </ol>
    <h6>
     <a id="6_151">
     </a>
     6、命令手册
    </h6>
    <p>
     <a href="https://pyarmor.readthedocs.io/zh/stable/man.html" rel="nofollow">
      点击查看
     </a>
    </p>
    <h6>
     <a id="7_155">
     </a>
     7、优缺点
    </h6>
    <ol>
     <li>
      <p>
       优点
      </p>
      <ul>
       <li>
        <p>
         使用方便，加密脚本较快且能一键加密，操作较简单
        </p>
       </li>
       <li>
        <p>
         多种加密模式，满足常规绝大多数的加密要求
        </p>
       </li>
       <li>
        <p>
         有文档支持，对于常见的错误异常可以通过查阅官方文档解决
        </p>
       </li>
       <li>
        <p>
         支持其他功能，例如，检查加密脚本的性能、交叉保护机制
        </p>
       </li>
       <li>
        <p>
         可以设置加密文件有效期及绑定在固定机器上
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       缺点
      </p>
      <ul>
       <li>
        <p>
         每个大的版本的改动比较大，安装时需要查看官方文档选用合适的版本进行安装
        </p>
       </li>
       <li>
        <p>
         个别版本交叉发布时脚本无法运行，具体查看官方文档
        </p>
       </li>
       <li>
        <p>
         安装python版本时需要开启静态库的共享进行安装，否则会无法加密文件
        </p>
       </li>
       <li>
        <p>
         运行加密文件时的python版需要和加密时的python版本一致
        </p>
       </li>
       <li>
        <p>
         pyarmor安装的默认是试用版，对加密文件的大小、模块的函数个数等都有限制，用于商业时需要单独购买
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h6>
     <a id="2cython_181">
     </a>
     方案2：使用cython进行加密
    </h6>
    <h6>
     <a id="1_183">
     </a>
     1、安装
    </h6>
    <pre><code class="prism language-python">pip install cython
</code></pre>
    <h6>
     <a id="2_189">
     </a>
     2、加密过程
    </h6>
    <ul>
     <li>
      <p>
       利用Cython将.py文件编译为.c文件
      </p>
     </li>
     <li>
      <p>
       将.c文件编译为为.so或.pyd文件，linux系统为.so文件，Windows系统为.pyd文件
      </p>
     </li>
    </ul>
    <h6>
     <a id="3Cython_195">
     </a>
     3、使用Cython
    </h6>
    <ul>
     <li>
      <p>
       创建setup.py加密指定的python文件
      </p>
      <blockquote>
       <pre><code class="prism language-python"><span class="token keyword">from</span> distutils<span class="token punctuation">.</span>core <span class="token keyword">import</span> setup
<span class="token keyword">from</span> Cython<span class="token punctuation">.</span>Build <span class="token keyword">import</span> cythonize
setup<span class="token punctuation">(</span>ext_modules <span class="token operator">=</span> cythonize<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"main.py"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> language_level<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre>
      </blockquote>
     </li>
    </ul>
    <h6>
     <a id="4Cython_205">
     </a>
     4、简化Cython加密过程
    </h6>
    <p>
     jmpy3为python的一个第三方库，能够将python代码一键加密为.so或者.pyd文件，支持单个文件加密，整个项目加密，加密后会在项目目录中增加一个dist的文件夹，把源文件替换为加密后的文件即可正常运行
    </p>
    <ol>
     <li>
      <p>
       安装
      </p>
      <blockquote>
       <p>
        pip install jmpy3
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       切换到项目所在目录，执行以下命令
      </p>
      <blockquote>
       <p>
        jmpy -i 项目名称
       </p>
      </blockquote>
     </li>
     <li>
      <p>
       发布加密脚本
      </p>
      <blockquote>
       <p>
        同样加密后会在项目目录中增加一个dist的文件夹，把源文件替换为加密后的文件即可正常运行
       </p>
      </blockquote>
     </li>
    </ol>
    <h6>
     <a id="5_221">
     </a>
     5、优缺点
    </h6>
    <ol>
     <li>
      <p>
       优点
      </p>
      <ul>
       <li>
        <p>
         通过jmpy3可以实现一键加密，加密较为方便
        </p>
       </li>
       <li>
        <p>
         加密后代码运行效率有所提升
        </p>
       </li>
       <li>
        <p>
         生成.so或.pyd文件难以破解
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       缺点
      </p>
      <ul>
       <li>
        <p>
         兼容性稍差，对于不同的版本的操作系统，需要重新编译
        </p>
       </li>
       <li>
        <p>
         运行加密文件时的python版需要和加密时的python版本一致
        </p>
       </li>
       <li>
        <p>
         没有官方文档，使用加密后的代码出错后，需要自己排查解决错误
        </p>
       </li>
      </ul>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34313634393638392f:61727469636c652f64657461696c732f313235383932353331" class_="artid" style="display:none">
 </p>
</div>


