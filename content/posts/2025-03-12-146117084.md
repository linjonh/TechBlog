---
layout: post
title: "MySQL进阶-优化查询"
date: 2025-03-12 12:19:39 +0800
description: "简单说就是，索引列+主键包含SELECT 到 FROM之间查询的列。理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。理解方式二：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。"
keywords: "MySQL进阶-优化查询"
categories: ['未分类']
tags: ['数据库', 'Mysql']
artid: "146117084"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146117084
    alt: "MySQL进阶-优化查询"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146117084
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146117084
cover: https://bing.ee123.net/img/rand?artid=146117084
image: https://bing.ee123.net/img/rand?artid=146117084
img: https://bing.ee123.net/img/rand?artid=146117084
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL进阶-优化查询
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     优化分页查询
    </h2>
    <p>
     <img alt="" height="262" src="https://i-blog.csdnimg.cn/direct/4746c21001b94054ae111d996816267a.png" width="871"/>
    </p>
    <h3>
     <strong>
      优化思路一
     </strong>
    </h3>
    <p>
     在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。
    </p>
    <p>
     <img alt="" height="301" src="https://i-blog.csdnimg.cn/direct/89dc0c965d8844ceb551edaff3525110.png" width="1477"/>
    </p>
    <h3>
     <strong>
      优化思路二
     </strong>
    </h3>
    <p>
     该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。
    </p>
    <p>
     <img alt="" height="248" src="https://i-blog.csdnimg.cn/direct/90c8325243c84ee8ab1190058760ee1d.png" width="1443"/>
    </p>
    <h2>
     优先考虑覆盖索引
    </h2>
    <h3>
     什么是覆盖索引？
    </h3>
    <p>
     简单说就是，
     <code>
      索引列+主键
     </code>
     包含
     <code>
      SELECT 到 FROM之间查询的列
     </code>
     。
    </p>
    <blockquote>
     <p>
      <strong>
       理解方式一
      </strong>
      ：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。
      <strong>
       一个索引包含了满足查询结果的数据就叫做覆盖索引
      </strong>
      。
     </p>
     <p>
      <strong>
       理解方式二
      </strong>
      ：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。
     </p>
    </blockquote>
    <h3>
     <strong>
      举例一：
     </strong>
    </h3>
    <blockquote>
     <p>
      <strong>
       当条件是不等于的时候，查询优化器不一定会使用索引。此时要是只查索引包含的两个字段就会走这个覆盖索引，查询优化器选择索引用不用都是基于查询成本的考虑。
      </strong>
     </p>
    </blockquote>
    <p>
     <img alt="" height="392" src="https://i-blog.csdnimg.cn/direct/59cd82fd249e4240a6a8abdc23fc96dd.png" width="1446"/>
    </p>
    <h3>
     举例二：
    </h3>
    <blockquote>
     <p>
      此时模糊查询百分号在前，索引失效
     </p>
    </blockquote>
    <p>
     <img alt="" height="296" src="https://i-blog.csdnimg.cn/direct/58dd4b84b8a04e4582c9b51b75df2b3f.png" width="1452"/>
    </p>
    <blockquote>
     <p>
      此时走了覆盖索引，经过查询优化器的考量，发现走覆盖索引成本较低。
     </p>
    </blockquote>
    <p>
     <img alt="" height="284" src="https://i-blog.csdnimg.cn/direct/675e52932ec243f38440218af7cffa90.png" width="1445"/>
    </p>
    <blockquote>
     <p>
      上述都使用到了声明的索引，下面的情况则不然，查询列依然多了classId,结果是未使用到索引，因为此时多了这一列，需要进行回表操作，查询成本较高，查询优化器会认为不如直接全表扫描。
     </p>
    </blockquote>
    <p>
     <img alt="" height="286" src="https://i-blog.csdnimg.cn/direct/80d7002b352d4c76919c674ad667924c.png" width="1445"/>
    </p>
    <h3>
     覆盖索引的利弊
    </h3>
    <blockquote>
     <p>
      首先就是
      <strong>
       避免了回表操作
      </strong>
      ，要查询的字段索引节点都有可以直接返回，不需要回表到叶子节点查询其它字段信息，
      <strong>
       由于索引是按照键值顺序存储的
      </strong>
      ，可以把随机读取的IO转化索引查找的顺序IO，加快查询效率。
     </p>
    </blockquote>
    <p>
     <img alt="" height="647" src="https://i-blog.csdnimg.cn/direct/75fda46c4b2f433e90511687878bf5c8.png" width="1172"/>
    </p>
    <h2>
     如何给字符串添加索引
    </h2>
    <h3>
     前缀索引
    </h3>
    <p>
     MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。
    </p>
    <p>
     <img alt="" height="143" src="https://i-blog.csdnimg.cn/direct/3a0f136a4f77471a999d4f32cbed92d5.png" width="1453"/>
    </p>
    <p>
     这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。
    </p>
    <p>
     <img alt="" height="380" src="https://i-blog.csdnimg.cn/direct/1a5362a2930d41a28734364738e17267.png" width="1152"/>
    </p>
    <p>
     <img alt="" height="709" src="https://i-blog.csdnimg.cn/direct/adfaa6611845414a8180a153c7ce9b9a.png" width="988"/>
    </p>
    <p>
     <strong>
      如果使用的是index1
     </strong>
     （即email整个字符串的索引结构），执行顺序是这样的：
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        从index1索引树找到满足索引值是’
        <a href="mailto:zhangssxyz@xxx.com" rel="nofollow">
         zhangssxyz@xxx.com
        </a>
        ’的这条记录，取得ID2的值；
       </p>
      </li>
      <li>
       <p>
        到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；
       </p>
      </li>
      <li>
       <p>
        取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='
        <a href="mailto:zhangssxyz@xxx.com" rel="nofollow">
         zhangssxyz@xxx.com
        </a>
        ’的 条件了，循环结束。
       </p>
      </li>
     </ol>
    </blockquote>
    <p>
     这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。
    </p>
    <p>
     <strong>
      如果使用的是index2
     </strong>
     （即email(6)索引结构），执行顺序是这样的：
    </p>
    <blockquote>
     <ol>
      <li>
       <p>
        从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；
       </p>
      </li>
      <li>
       <p>
        到主键上查到主键值是ID1的行，判断出email的值不是’
        <a href="mailto:zhangssxyz@xxx.com" rel="nofollow">
         zhangssxyz@xxx.com
        </a>
        ’，这行记录丢弃；
       </p>
      </li>
      <li>
       <p>
        取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然 后判断，这次值对了，将这行记录加入结果集；
       </p>
      </li>
      <li>
       <p>
        重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。
       </p>
      </li>
     </ol>
    </blockquote>
    <p>
     结论：
    </p>
    <blockquote>
     <p>
      <strong>
       使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本，但使用了前缀索引就不能使用覆盖索引了，因为前缀索引必须回表查询，才能精确比对。
      </strong>
     </p>
    </blockquote>
    <h2>
     索引下推
    </h2>
    <p>
     Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。即先在索引层面筛选，再利用筛选完的索引
    </p>
    <p>
     <img alt="" height="308" src="https://i-blog.csdnimg.cn/direct/297b61adce90477eaee08892eb35a263.png" width="1173"/>
    </p>
    <h4>
     使用案例
    </h4>
    <p>
     <img alt="" height="823" src="https://i-blog.csdnimg.cn/direct/813753f9aeec4d3884680e3b6adb5594.png" width="1190"/>
    </p>
    <p>
     <img alt="" height="119" src="https://i-blog.csdnimg.cn/direct/94c7e3c814a24660959b77ffbd72f44e.png" width="1147"/>
     <img alt="" height="124" src="https://i-blog.csdnimg.cn/direct/fb254537b3fb4898bcaa6da997e6e9e6.png" width="1147"/>
    </p>
    <h4>
     ICP的使用条件
    </h4>
    <blockquote>
     <ol>
      <li>
       <p>
        如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP。
       </p>
      </li>
      <li>
       <p>
        ICP可以使用
        <code>
         InnDB
        </code>
        和
        <code>
         MyISAM
        </code>
        表，包括分区表
        <code>
         InnoDB
        </code>
        和
        <code>
         MyISAM
        </code>
        表
       </p>
      </li>
      <li>
       <p>
        对于
        <code>
         InnoDB
        </code>
        表，ICP仅用于
        <code>
         二级索引
        </code>
        。ICP的目标是减少全行读取次数，从而减少I/O操作。
       </p>
      </li>
      <li>
       <p>
        当SQL使用覆盖索引时，
        <strong>
         不支持ICP优化方法。因为这种情况下使用ICP不会减少I/O
        </strong>
        。
       </p>
      </li>
      <li>
       <p>
        相关子查询的条件不能使用ICP
       </p>
      </li>
     </ol>
    </blockquote>
    <h2>
     普通索引 vs 唯一索引
    </h2>
    <h3>
     查询过程
    </h3>
    <p>
     假设，执行查询的语句是根据索引字段进行等值匹配。
    </p>
    <blockquote>
     <ul>
      <li>
       <p>
        对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一 个不满足k=5条件的记录。
       </p>
      </li>
      <li>
       <p>
        对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
       </p>
      </li>
     </ul>
    </blockquote>
    <h3>
     更新过程
    </h3>
    <p>
     为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。
    </p>
    <blockquote>
     <ul>
      <li>
       当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下，
       <code>
        InooDB会将这些更新操作缓存在change buffer中
       </code>
       ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
      </li>
      <li>
       将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了
       <code>
        访问这个数据页
       </code>
       会触 发merge外，系统有
       <code>
        后台线程会定期
       </code>
       merge。在
       <code>
        数据库正常关闭（shutdown）
       </code>
       的过程中，也会执行merge 操作。
      </li>
      <li>
       如果能够将更新操作先记录在change buffer，
       <code>
        减少读磁盘
       </code>
       ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够
       <code>
        避免占用内存
       </code>
       ，提高内存利用率。
      </li>
     </ul>
    </blockquote>
    <h3 style="background-color:transparent">
     change buffer的使用场景
    </h3>
    <blockquote>
     <ol>
      <li>
       <p>
        普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，
        <strong>
         建议你 尽量选择普通索引
        </strong>
        。
       </p>
      </li>
      <li>
       <p>
        在实际使用中会发现，
        <strong>
         普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的。
        </strong>
       </p>
      </li>
      <li>
       <p>
        如果所有的更新后面，
        <strong>
         都马上伴随着对这个记录的查询 ，那么你应该关闭change buffer
        </strong>
        。而在其他情况下，change buffer都能提升更新性能。
       </p>
      </li>
      <li>
       <p>
        由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优 先考虑非唯一索引。但是如果"业务可能无法确保"的情况下，怎么处理呢？
       </p>
       <ul>
        <li>
         <p>
          首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。
         </p>
        </li>
        <li>
         <p>
          然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36343133333133302f:61727469636c652f64657461696c732f313436313137303834" class_="artid" style="display:none">
 </p>
</div>


