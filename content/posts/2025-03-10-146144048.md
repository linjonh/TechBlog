---
layout: post
title: "数据结构有序表的合并"
date: 2025-03-10 09:16:58 +0800
description: "合并有序表的方法"
keywords: "数据结构：有序表的合并"
categories: ['考研复习408']
tags: ['有序表合并', '数据结构', '408考研']
artid: "146144048"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146144048
    alt: "数据结构有序表的合并"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146144048
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146144048
cover: https://bing.ee123.net/img/rand?artid=146144048
image: https://bing.ee123.net/img/rand?artid=146144048
img: https://bing.ee123.net/img/rand?artid=146144048
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构：有序表的合并
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <a href="https://blog.csdn.net/qiwsir/article/details/146143841">
      前文介绍了《有序表的插入》
     </a>
     ，本文介绍有序表的合并。这两种对有序表的操作，是数据结构中常考的内容，特别是在 408 考卷中，在算法设计的题目中，有可能会考查对有序表的操作。那么，这两篇文章中的方法就是能够拿到基本分数的方法。
    </p>
    <p>
     <strong>
      例题 3.10.3
     </strong>
     假设有两个非递减有序表 LA 和 LB，设计一个算法，将它们合并成一个非递减有序表 LC（假设每个有序表中和两个有序表间均不存在重复元素）。
    </p>
    <p>
     【解】
    </p>
    <p>
     采用二路归并算法将两个有序表合并成一个有序表，其过程是：创建空表 LC，且长度是 LA 和 LB 长度之和。分别扫描 LA 和 LB 两个有序表：
    </p>
    <ul>
     <li>
      当两个有序表都没有扫描完成时，循环执行：比较 LA 和 LB 的当前元素，将其中较小的元素插入到 LC 中，再从较小元素所在的有序表中取下一个元素。
     </li>
     <li>
      重复此过程，直到 LA 或 LB 比较完毕，最后将未比较的有序表中余下的元素插入到 LC 中。
     </li>
    </ul>
    <p>
     举例：
     <code>
      LA = (1, 3, 5), LB = (2, 4, 8, 10)
     </code>
     ，按照上述算法，过程如图 3.10.1 所示。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2f3c5871d9504ddd83badca2ea438af6.png#pic_center"/>
    </p>
    <center>
     图 3.10.1 合并有序表
    </center>
    <p>
     （1）采用顺序表存放有序表
    </p>
    <p>
     【算法描述】
    </p>
    <pre><code class="prism language-c"><span class="token comment">//顺序表存储结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
    ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span>    <span class="token comment">//存储空间的基地址</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>        <span class="token comment">//当前长度</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>               <span class="token comment">//顺序表的结构类型为 SqList</span>

<span class="token keyword">void</span> <span class="token function">MergeList</span><span class="token punctuation">(</span>SqList LA<span class="token punctuation">,</span> SqList LB<span class="token punctuation">,</span> SqList <span class="token operator">&amp;</span>LC<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//i,j 是 LA,LB 的下标，k 是 LC 中的元素个数 </span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    LC <span class="token operator">=</span> （SqList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SqList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//LA 和 LB 均未到达表尾</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> LA<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> LB<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>LA<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> LB<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            LC<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LA<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            LC<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LB<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//LA尚未扫描完毕，将其余元素插入 LC 中</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> LA<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        LC<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LA<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//LB尚未扫描完毕，将其余元素插入 LC 中</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> LB<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        LC<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> LB<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    LC<span class="token punctuation">.</span>length <span class="token operator">=</span> k<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
    <p>
     上述写法比较容易理解，但写法不紧凑，可以对上述写法进行改进。
    </p>
    <pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">MergeList</span><span class="token punctuation">(</span>SqList LA<span class="token punctuation">,</span> SqList LB<span class="token punctuation">,</span> SqList <span class="token operator">&amp;</span>LC<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LC<span class="token punctuation">.</span>length <span class="token operator">=</span> LA<span class="token punctuation">.</span>length <span class="token operator">+</span> LB<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//新表的长度</span>
    LC<span class="token punctuation">.</span>elem <span class="token operator">=</span> new ElemType<span class="token punctuation">[</span>LC<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//为新表分配数组空间</span>
    
    pc <span class="token operator">=</span> LC<span class="token punctuation">.</span>elem<span class="token punctuation">;</span> <span class="token comment">//指针 pc 指向新表的第一个元素</span>
    pa <span class="token operator">=</span> LA<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>
    pb <span class="token operator">=</span> LB<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>
    
    <span class="token comment">//指针 pa_last 指向 LA 的最后一个元素</span>
    pa_last <span class="token operator">=</span> LA<span class="token punctuation">.</span>elem <span class="token operator">+</span> LA<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    pb_last <span class="token operator">=</span> LB<span class="token punctuation">.</span>elem <span class="token operator">+</span> LB<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token comment">//LA, LB 均未达到表尾</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pa <span class="token operator">&lt;=</span> pa_last<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pb <span class="token operator">&lt;=</span> pb_last<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>pa <span class="token operator">&lt;=</span> <span class="token operator">*</span>pb<span class="token punctuation">)</span>
            <span class="token operator">*</span>pc<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>pa<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token operator">*</span>pc<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//LB已到表尾，依次将 LA 剩余元素插入 LC 的最后</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pa <span class="token operator">&lt;=</span> pa_last<span class="token punctuation">)</span> <span class="token operator">*</span>pc<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>pa<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">//LA已到表尾，依次将 LB 剩余元素插入 LC 的最后</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pb <span class="token operator">&lt;=</span> pb_last<span class="token punctuation">)</span> <span class="token operator">*</span>pc<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     【算法分析】
    </p>
    <p>
     假设 LA 和 LB 的长度分别为
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        m 
        
       
      
        m
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.4306em;">
         </span>
         <span class="mord mathnormal">
          m
         </span>
        </span>
       </span>
      </span>
     </span>
     和
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        n 
        
       
      
        n
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 0.4306em;">
         </span>
         <span class="mord mathnormal">
          n
         </span>
        </span>
       </span>
      </span>
     </span>
     ，元素比较次数：
    </p>
    <ul>
     <li>
      最好情况下的比较次数是
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         min 
         
        
          ⁡ 
         
        
          ( 
         
        
          m 
         
        
          , 
         
        
          n 
         
        
          ) 
         
        
       
         \min(m,n)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mop">
           min
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathnormal">
           m
          </span>
          <span class="mpunct">
           ,
          </span>
          <span class="mspace" style="margin-right: 0.1667em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
      。时间复杂度是
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         O 
         
        
          ( 
         
        
          min 
         
        
          ⁡ 
         
        
          ( 
         
        
          m 
         
        
          , 
         
        
          n 
         
        
          ) 
         
        
          ) 
         
        
       
         O(\min(m,n))
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0278em;">
           O
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mop">
           min
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathnormal">
           m
          </span>
          <span class="mpunct">
           ,
          </span>
          <span class="mspace" style="margin-right: 0.1667em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mclose">
           ))
          </span>
         </span>
        </span>
       </span>
      </span>
     </li>
     <li>
      最坏情况下的比较次数是
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         m 
         
        
          + 
         
        
          n 
         
        
          − 
         
        
          1 
         
        
       
         m+n-1
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;">
          </span>
          <span class="mord mathnormal">
           m
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
          <span class="mbin">
           +
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
          <span class="mbin">
           −
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 0.6444em;">
          </span>
          <span class="mord">
           1
          </span>
         </span>
        </span>
       </span>
      </span>
      。时间复杂度是
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         O 
         
        
          ( 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          ) 
         
        
       
         O(m+n)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0278em;">
           O
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathnormal">
           m
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
          <span class="mbin">
           +
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
     </li>
    </ul>
    <p>
     空间复杂度为
     <span class="katex--inline">
      <span class="katex">
       <span class="katex-mathml">
        O 
        
       
         ( 
        
       
         m 
        
       
         + 
        
       
         n 
        
       
         ) 
        
       
      
        O(m+n)
       </span>
       <span class="katex-html">
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathnormal" style="margin-right: 0.0278em;">
          O
         </span>
         <span class="mopen">
          (
         </span>
         <span class="mord mathnormal">
          m
         </span>
         <span class="mspace" style="margin-right: 0.2222em;">
         </span>
         <span class="mbin">
          +
         </span>
         <span class="mspace" style="margin-right: 0.2222em;">
         </span>
        </span>
        <span class="base">
         <span class="strut" style="height: 1em; vertical-align: -0.25em;">
         </span>
         <span class="mord mathnormal">
          n
         </span>
         <span class="mclose">
          )
         </span>
        </span>
       </span>
      </span>
     </span>
     。
    </p>
    <p>
     （2）采用单链表存放有序表
    </p>
    <p>
     假设头指针为
     <code>
      LA
     </code>
     和
     <code>
      LB
     </code>
     的单链表分别为线性表 LA 和 LB 的存储结构，现要归并 LA 和 LB 得到单链表 LC。因为链表结点之间的关系是通过指针指向建立起来的，所以用链表进行合并不需要另外开辟存储空间，可以直接利用原来两个表的存储空间，合并过程中只需把 LA 和 LB 两个表中的结点重新进行链接即可。
    </p>
    <p>
     按照二路归并的思想，需设立 3 个指针
     <code>
      pa
     </code>
     、
     <code>
      pb
     </code>
     和
     <code>
      pc
     </code>
     ：
    </p>
    <ul>
     <li>
      <code>
       pa
      </code>
      和
      <code>
       pb
      </code>
      分别指向 LA 和LB 中当前待比较插入的结点，
      <code>
       pc
      </code>
      指向 LC 中当前最后一个结点（LC 的表头结点设为 LA 的表头结点）。
     </li>
     <li>
      指针的初值：
      <code>
       pa
      </code>
      和
      <code>
       pb
      </code>
      分别指向 LA 和 LB 表中的第一个结点，pc 指向空表 LC 中的头结点。通过比较指针
      <code>
       pa
      </code>
      和
      <code>
       pb
      </code>
      所指向的元素的值，依次从 LA 或 LB 中“摘取”元素值较小的结点插入到 LC 的最后，当其中一个表变空时，只要将另一个表的剩余段链接在
      <code>
       pc
      </code>
      所指结点之后即可。
     </li>
    </ul>
    <p>
     【算法描述】
    </p>
    <pre><code class="prism language-c"><span class="token comment">//单链表存储结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{<!-- --></span>
    ElemType data<span class="token punctuation">;</span>  <span class="token comment">//结点的数据域</span>
    <span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//结点的指针域</span>
<span class="token punctuation">}</span>LNode<span class="token punctuation">,</span> <span class="token operator">*</span>LinkList<span class="token punctuation">;</span>  <span class="token comment">//LinkList 为指向结构体 LNode 的指针类型</span>

<span class="token keyword">void</span> <span class="token function">MergeList</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>LA<span class="token punctuation">,</span> LinkList <span class="token operator">&amp;</span>LB<span class="token punctuation">,</span> LinkList <span class="token operator">&amp;</span>LC<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//LA, LB 是带头结点的单链表</span>
    pa <span class="token operator">=</span> LA<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    pb <span class="token operator">=</span> LA<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    LC <span class="token operator">=</span> LA<span class="token punctuation">;</span> <span class="token comment">//用 LA 的头结点作为 LC 的头结点</span>
    pc <span class="token operator">=</span> LC<span class="token punctuation">;</span> <span class="token comment">//pc 的初始值指向 LC 的头结点</span>
    
    <span class="token comment">// LA, LB 均未到达表尾，依次“摘取”其中较小的结点插入到 LC 最后</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> pb<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pa<span class="token operator">-&gt;</span>data <span class="token operator">&lt;</span> pb<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            pc<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pa<span class="token punctuation">;</span> <span class="token comment">//将 pa 所指结点作为到 pc 所指结点的后继</span>
            pc <span class="token operator">=</span> pa<span class="token punctuation">;</span> <span class="token comment">//pc 指向 pa，即为 LC 的尾结点指针</span>
            pa <span class="token operator">=</span> pa<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//pa 指向下一个结点</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            pc<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pb<span class="token punctuation">;</span>
            pc <span class="token operator">=</span> pb<span class="token punctuation">;</span>
            pb <span class="token operator">=</span> pb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    pc<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pa <span class="token operator">?</span> pa<span class="token operator">:</span> pb<span class="token punctuation">;</span> <span class="token comment">//将非空表的剩余段插入到 pc 所指结点之后</span>
    delete LB<span class="token punctuation">;</span>  <span class="token comment">//释放 LB 的头结点</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     【算法分析】
    </p>
    <ul>
     <li>
      时间复杂度
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         O 
         
        
          ( 
         
        
          m 
         
        
          + 
         
        
          n 
         
        
          ) 
         
        
       
         O(m+n)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0278em;">
           O
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord mathnormal">
           m
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
          <span class="mbin">
           +
          </span>
          <span class="mspace" style="margin-right: 0.2222em;">
          </span>
         </span>
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal">
           n
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
     </li>
     <li>
      空间复杂度
      <span class="katex--inline">
       <span class="katex">
        <span class="katex-mathml">
         O 
         
        
          ( 
         
        
          1 
         
        
          ) 
         
        
       
         O(1)
        </span>
        <span class="katex-html">
         <span class="base">
          <span class="strut" style="height: 1em; vertical-align: -0.25em;">
          </span>
          <span class="mord mathnormal" style="margin-right: 0.0278em;">
           O
          </span>
          <span class="mopen">
           (
          </span>
          <span class="mord">
           1
          </span>
          <span class="mclose">
           )
          </span>
         </span>
        </span>
       </span>
      </span>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f7169777369722f:61727469636c652f64657461696c732f313436313434303438" class_="artid" style="display:none">
 </p>
</div>


