---
layout: post
title: "深度优先搜索DFS-总结算法剪枝优化总结"
date: 2025-01-18 22:47:43 +0800
description: "深度优先搜索(DFS) 总结(算法+剪枝+优化总结)本文中会引"
keywords: "dfs"
categories: ['算法学习', 'Road', 'Ac']
tags: ['算法', '剪枝', 'Dfs', 'C', 'Acm']
artid: "109603384"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=109603384
    alt: "深度优先搜索DFS-总结算法剪枝优化总结"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=109603384
featuredImagePreview: https://bing.ee123.net/img/rand?artid=109603384
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深度优先搜索(DFS) 总结(算法+剪枝+优化总结)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="DFS__0">
     </a>
     深度优先搜索(DFS) 总结(算法+剪枝+优化总结)
    </h2>
    <blockquote>
     <p>
      本文中会引用部分实例、文献资料来自不同的作者之手，由于资料整理比较困难，转载地址不在文中列举。如有侵权请联系我更换或删除！对于提供题解思路的各位大佬和作者：非常感谢！
     </p>
    </blockquote>
    <h3>
     <a id="_4">
     </a>
     一、前导
    </h3>
    <p>
     定义上的深度优先搜索的思路与树的先序遍历非常相似，是针对图的搜索而提出的一种算法，下面是算法导论上的解释：
    </p>
    <blockquote>
     <p>
      在深度优先搜索中，对于最新发现的顶点，如果它还有以此为顶点而未探测到的边，就沿此边继续探测下去，当顶点v的所有边都已被探寻过后，搜索将回溯到发现顶点v有起始点的那些边。这一过程一直进行到已发现从源顶点可达的所有顶点为止。如果还存在未被发现的顶点，则选择其中一个作为源顶点，并重复上述过程。整个过程反复进行，直到所有的顶点都被发现时为止。
     </p>
    </blockquote>
    <blockquote>
     <p>
      在深度优先搜索中，每当扫描到已发现的顶点u的邻接表，从而发现新顶点v时，就将置v的先辈域Π[v]为u。与广度优先搜索不同的是，其先辈子图形成一棵树，深度优先搜索产生的先辈子图可以有几棵树所构成，因为搜索可能由多个源顶点开始重复进行。因此，在深度优先搜索中，先辈子图的定义也和广度优先搜索中稍有所不同：GΠ = (V, EΠ)，其中EΠ = {(Π[v], v) : v ∈V 且 Π[v] ≠ NIL}
     </p>
    </blockquote>
    <p>
     在实际的操作中，我们一般对深度优先搜索问题进行分类：
    </p>
    <ol>
     <li>
      定义的DFS：对图的连通性进行测试，典型的问题：迷宫连通性测试、图的条件搜索等
     </li>
     <li>
      广义的DFS–DFS思路的应用：DFS搜索顺序+规则问题、穷举结果寻求最优解/符合条件解等等，由于其穷举答案的本质，又被称为爆搜
     </li>
    </ol>
    <p>
     深度优先搜索(下文统称DFS)的精髓在于递归求解问题的思路以及回溯的处理。而针对搜索的过程，又有更为重要的剪枝、优化，必要的剪枝优化(通过对穷举答案方式进行改进)对DFS的顺利执行有着不可或缺的作用。本文章将针对DFS的原理、常见的题型、剪枝优化的思路进行分析。当然，爆搜的题型千千万，不可能一概而论，我会通过具体的题目对几类问题的求解思路进行总结分析，构建基本的思维模型。
    </p>
    <h3>
     <a id="_19">
     </a>
     二、原理分类与分析
    </h3>
    <h4>
     <a id="1_DFS_21">
     </a>
     1. DFS连通性模型
    </h4>
    <blockquote>
     <p>
      在测试图的连通性时，DFS与实际人们的思想一致，相对于起点选择一条路走到底，发现不行就返回选择的节点换一条路试，直到试出一条能到达终点的路。当然，一直试不出来就表示该起点与某点(终点)不连通。其他DFS连通性模型的思想与之类似。
     </p>
    </blockquote>
    <p>
     针对实际问题，我又将连通性模型按照是否需要回溯继续细分：
    </p>
    <h5>
     <a id="1__27">
     </a>
     1. 无需回溯：统计某点能到达的点的个数问题
    </h5>
    <p>
     在这类问题中，我们一般从某点出发进行搜索，对于已经被搜索过的点可以直接抛弃(标记不可访问)，对于当前被搜索的点递归搜索周围邻接的点并进行计数，直到无法搜索到合法的点返回。最终计数变量将记录所有能到达的点。
    </p>
    <blockquote>
     <p>
      典型模板题：ACWing.1113 红与黑
     </p>
     <p>
      解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109243556X
     </p>
    </blockquote>
    <h5>
     <a id="2_35">
     </a>
     2.需要回溯：迷宫类问题，测试两点间连通性
    </h5>
    <p>
     在这类问题中，由于当前选择的路径未必能够到达目标点，因此需要设置回溯，当搜索到非法路径返回时需要“恢复现场”，即：对于该路径下各点的访问状态重置。具体的搜索过程如下图所演示：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/c79bcfdc003d1114c686bd4b5d5bfa8a.gif#pic_center"/>
    </p>
    <blockquote>
     <p>
      典型模板题：ACWing.1112 迷宫
     </p>
     <p>
      解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109239579
     </p>
     <p>
      二维矩阵里走迷宫，非常简单
     </p>
    </blockquote>
    <blockquote>
     <p>
      典型模板题：ACWing.1116 马走日
     </p>
     <p>
      解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109247649
     </p>
     <p>
      这题堪称经典，与迷宫模板不同的是移动路径的选择和点合法性的判断，属于简单的搜索题
     </p>
    </blockquote>
    <p>
     根据数据结构，又可以将两个模型分别继续细分，DFS可以基于邻接矩阵、邻接表、边集数组实现，思路相同，只是路径的遍历方式、点的访问有所改变。
    </p>
    <blockquote>
     <p>
      这里留个坑，以后会选择不同数据结构类型的题目补充在这里
     </p>
    </blockquote>
    <p>
     ⭐总结一下DFS的模板框架(简单描述)
    </p>
    <pre><code class="prism language-c++">function dfs(当前状态){
	if(当前状态 == 目的状态){
        ···
    }
    for(···寻找新状态){
        if(状态合法){
            vis[访问该点]；
            dfs(新状态);
            ?是否需要恢复现场-&gt;vis[恢复访问]
        } 
    }
    if(找不到新状态){
        ···
    }
}
</code></pre>
    <h4>
     <a id="2_DFS_78">
     </a>
     2. DFS思路应用-穷举求解问题
    </h4>
    <blockquote>
     <p>
      在无路可走时，我们往往会选择搜索算法，因为我们期望利用计算机的高性能来有目的的穷举一个问题的部分甚至所有可能情况，从而在这些情况中寻找符合题目要求的答案。这也是“爆搜”之名的由来
     </p>
    </blockquote>
    <p>
     我们约定，对于问题的介入状态，叫
     <strong>
      初始状态
     </strong>
     ，要求的状态叫
     <strong>
      目标状态
     </strong>
     。
     <br/>
     这里的搜索就是对
     <strong>
      实时产生的状态
     </strong>
     进行分析检测，直到得到一个
     <strong>
      目标状态或符合要求的最佳状态
     </strong>
     为止。对于实时产生新的状态的过程叫
     <strong>
      扩展
     </strong>
     （由一个状态，应用规则，产生新状态的过程）
    </p>
    <h5>
     <a id="_85">
     </a>
     搜索的要点：
    </h5>
    <ol>
     <li>
      <p>
       选定初始状态，在某些问题中可能是从多个合法状态分别入手搜索；
      </p>
     </li>
     <li>
      <p>
       遍历自初始状态或当前状态所产生的合法状态，产生新的状态并进入递归；
      </p>
     </li>
     <li>
      <p>
       检查新状态是否为目标状态，是则返回，否则继续遍历，重复2-3步骤
      </p>
     </li>
    </ol>
    <h5>
     <a id="DFS_94">
     </a>
     对状态的处理：DFS时，用一个数组存放产生的所有状态。
    </h5>
    <ol>
     <li>
      把初始状态放入数组中，设为当前状态；
     </li>
     <li>
      扩展当前的状态，从合法状态中旬寻找一个新的状态放入数组中，同时把新产生的状态设为当前状态；
     </li>
     <li>
      判断当前状态是否和前面的状态重复，如果重复则回到上一个状态，产生它的另一状态；
     </li>
     <li>
      判断当前状态是否为目标状态，如果是目标目标状态，则找到一个解答，根据实际问题需求，选择继续寻找答案或是直接返回。
     </li>
     <li>
      如果数组为空，说明对于该问题无解。
     </li>
    </ol>
    <p>
     ⭐与图的搜索类似，算法的框架基本不变，不同的是对于新状态的寻找、控制递归终止的条件更为复杂。在实际的题目中，会有一些题目需要对合法的新状态进行干预：可能在首轮搜索无法应用规则或所有条件均不满足且需要人为创建新的规则以继续搜索答案。这里也会设计到一系列剪枝与优化的问题。
    </p>
    <pre><code class="prism language-c++">function dfs(当前状态, 一系列其他的状态量){
	if(当前状态 == 目的状态){
        ···
    }
    for(···寻找新状态){
        if(状态合法){
            vis[访问该点]；
            dfs(新状态);
            ?是否需要恢复现场-&gt;vis[恢复访问]
        } 
    }
    if(找不到新状态){
        是否需要创建新规则？{
            创建并对当前状态进行访问vis;
            继续搜索;
            恢复现场/恢复访问vis;
        }
    }
}
</code></pre>
    <blockquote>
     <p>
      这里举一道具体的题目案例来演示：ACWing分成互质组
     </p>
    </blockquote>
    <h6>
     <a id="_127">
     </a>
     题目描述：
    </h6>
    <p>
     给定 n 个正整数，将它们分组，使得每组中任意两个数互质。至少要分成多少个组？
    </p>
    <h6>
     <a id="_131">
     </a>
     输入格式
    </h6>
    <p>
     第一行是一个正整数 n。
    </p>
    <p>
     第二行是 n 个不大于10000的正整数。
    </p>
    <h6>
     <a id="_137">
     </a>
     输出格式
    </h6>
    <p>
     一个正整数，即最少需要的组数。
    </p>
    <h6>
     <a id="_141">
     </a>
     数据范围
    </h6>
    <p>
     1≤n≤10
    </p>
    <h6>
     <a id="_145">
     </a>
     输入样例：
    </h6>
    <pre><code>6
14 20 33 117 143 175
</code></pre>
    <h6>
     <a id="_152">
     </a>
     输出样例：
    </h6>
    <pre><code>3
</code></pre>
    <h6>
     <a id="_158">
     </a>
     题目分析与算法设计：
    </h6>
    <p>
     给定n个数字分成互质组，那么考虑最坏的情况，要分成n组(n个数均不互质)。因为题目的数据量并不大，可以采用DFS解决，具体思路如下：
    </p>
    <p>
     预备工作：准备一个数组存输入数据，准备一个容器，用于存不同的组，准备一个检索函数，可以检索指定分组内是否存在与目的数字重合的
    </p>
    <ol>
     <li>
      **开始DFS：**首先是递归终止条件，判断是否搜到末尾，搜到末尾则更新组数计数的值，返回；
     </li>
     <li>
      **继续：**每次在已有分组中从头开始搜索，用检索函数判断当前数字是否可以加入分组，若可以，加入后递归向下一个数字搜索
     </li>
     <li>
      **新建分组：**考虑组数为0的情况、找不到可以加入组的情况，应该设置创建新分组的情况，加入新分组后，同样递归向后搜索。
     </li>
    </ol>
    <pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 11;
int n, p[N], cnt, ans = N;
vector&lt;int&gt; num[N];	//这里使用STL中的Vector，其长度可变，更方便模拟分组的状态

int gcd(int x, int y){
    return y ? gcd(y, x % y) : x;	//辗转相除求最大公约数
}

//判断两数是否互质
bool check(int x, int t){
    for (int i = 0; i &lt; num[t].size(); i++){
        if (gcd(x, num[t][i]) &gt; 1) return false;
    }
    return true;


void dfs(int now)
{
    if (now == n){
        ans = min(ans,  cnt);	//每次搜完取最小组数
        return;
    }
    for (int i = 0; i &lt;  cnt; i++){
        if (check(p[now], i)){
            num[now].push_back(p[now]);
            dfs(now + 1);
            num[i].pop_back();
        }
    }
    //需要考虑首次搜索无组可加、当前状态无组可加
    num[cnt++].push_back(p[u]);
    dfs(now + 1);
    num[--cnt].pop_back(); 
}

int main(){
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; p[i];
    dfs(0);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
    <h3>
     <a id="_217">
     </a>
     三、剪枝优化、题型归纳总结(未完待续)
    </h3>
    <blockquote>
     <p>
      在通过搜索解决实际问题的过程中，我们是通过穷举每种情况来寻找合法解，然而在一些情况比较复杂的题目、数据量较强的题目中，由于算法的时间复杂度较高、数据规模过大，从而会导致运行超时甚至程序卡死，因此在对复杂问题的答案进行搜索时，我们应该灵活的针对每种题型设计对应的搜索规则并进行优化，通常通过设置剪枝、排除无效情况、对问题进行适当的转化等手法对搜索算法进行优化，使算法高效的执行并得出我们想要的结果。
     </p>
     <p>
      对算法的剪枝与优化堪称是爆搜算法的精髓，如何合理的设置剪枝优化直接关系能否得到结果，这对我们的解题思维是一个很大的挑战，本板块将对常见的剪枝优化思路、对细节的处理进行归纳总结。
     </p>
    </blockquote>
    <h4>
     <a id="_223">
     </a>
     概述：剪枝与优化
    </h4>
    <h5>
     <a id="_225">
     </a>
     ①.剪枝与优化的原则
    </h5>
    <blockquote>
     <p>
      <strong>
       1.正确性
      </strong>
     </p>
     <p>
      剪枝优化的过程是使算法逼近最优解的过程，而不是使算法远离最优解甚至跳过最优解的过程。剪枝的前提是保证对最优解不丢不漏。
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       2.准确性
      </strong>
     </p>
     <p>
      在保证正确性的前提下，我们采取必要的手段使算法跳过一定不含有目标状态/最优解的分支，从而保证算法高效地进行并更迅速的找出
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       3.高效性
      </strong>
     </p>
     <p>
      设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的。
     </p>
    </blockquote>
    <h5>
     <a id="_239">
     </a>
     ②剪枝与优化的一般入手点
    </h5>
    <blockquote>
     <p>
      1.优化搜索顺序：
     </p>
     <p>
      在一些题目中，可以通过对子问题分支进行分析，先解决相对简单的子问题从而使尚未解决的子问题得到简化，通过对搜索顺序的优化可以实现这一点。
     </p>
    </blockquote>
    <blockquote>
     <p>
      2.排除冗余信息：
     </p>
     <p>
      对限制条件进行分析，不要额外添加没有意义的搜索规则
     </p>
    </blockquote>
    <blockquote>
     <p>
      3.可行性剪枝：
     </p>
     <p>
      对于显然不包含目标状态的搜索方向及时停止搜索，转而向可能包含目标状态的分支进行搜索
     </p>
    </blockquote>
    <blockquote>
     <p>
      4.最优性剪枝：
     </p>
     <p>
      每次搜索完成后更新当前得到的最优状态/最优解，在每次搜索开始前判断当前解是否已经比上次得出的状态/解更劣？如果是则停止本次搜索，转向其他搜索分支
     </p>
    </blockquote>
    <blockquote>
     <p>
      5.记忆化搜索：
     </p>
     <p>
      这是技术活~这里不展开赘述
     </p>
    </blockquote>
    <h4>
     <a id="1_261">
     </a>
     1.问题的转化、数据的预处理与压缩
    </h4>
    <blockquote>
     <p>
      在解决实际问题时，我们可以巧妙地对题目给出的数据进行适当的转化，从而构造出DFS的模型进行求解。
     </p>
    </blockquote>
    <p>
     这与数学上的构造函数思想类似，在掌握题目数据的基础上对数据进行预处理从而构造可以按照某规则进行检索的新数据，通过对新数据进行搜索从而得出原数据符合要求的解。
    </p>
    <p>
     对于问题的转化：这里举一个有趣的题目作为例子：ACWing.1117 单词接龙，本题有一种解法便是在读入单词数目后初始化一张邻接表，用于表示对应序号的两个单词重叠部分的长度，同时再设置一个访问状态数组，这样就可以在表中进行搜索，每搜索完一轮更新最长长度，最终得到的便是最长“龙”的长度。
    </p>
    <blockquote>
     <h5>
      <a id="_269">
      </a>
      题目描述
     </h5>
     <p>
      单词接龙是一个与我们经常玩的成语接龙相类似的游戏。
     </p>
     <p>
      现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。
     </p>
     <p>
      在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。
     </p>
     <p>
      我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。
     </p>
     <h5>
      <a id="_278">
      </a>
      输入格式
     </h5>
     <p>
      输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。
     </p>
     <p>
      你可以假定以此字母开头的“龙”一定存在。
     </p>
     <h5>
      <a id="_283">
      </a>
      输出格式
     </h5>
     <p>
      只需输出以此字母开头的最长的“龙”的长度。
     </p>
     <h5>
      <a id="_287">
      </a>
      输入样例：
     </h5>
     <pre><code>5
at
touch
cheat
choose
tact
a
</code></pre>
     <h5>
      <a id="_299">
      </a>
      输出样例：
     </h5>
     <pre><code>23
</code></pre>
     <h5>
      <a id="_atoucheatactactouchoose_305">
      </a>
      提示：连成的“龙”为 “atoucheatactactouchoose”。
     </h5>
    </blockquote>
    <pre><code class="prism language-c++">#include &lt;bits/stdc++.h&gt;
#define N 26
using namespace std;

vector&lt;int&gt; ver[N],edge[N];//匹配的单词编号和匹配长度
string word[N];
int n, res;
int st[N];

void dfs(string u, int k)
{
    st[k] ++;
    res = max(res, (int)u.size());

    for(int i = 0;i &lt; ver[k].size(); i++)
    {
        int point = ver[k][i],d = edge[k][i];
        if(st[point]&lt;2)
            dfs(u + word[point].substr(d), point);
    }
    st[k]--;
}

int main(){
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++) cin &gt;&gt; word[i];

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
        {
            string a = word[i] , b = word[j];
            int len = min(a.size(),b.size());
            for(int k=1;k&lt;len;k++)
            {
                if(a.substr(a.size()-k)==b.substr(0,k))
                {
                    ver[i].push_back(j);
                    edge[i].push_back(k);
                    break;
                }
            }
        }

    string head;
    cin &gt;&gt; head;
    for(int i = 1; i &lt;= n; i++)
        if(head[0] == word[i][0]) dfs(word[i], i);
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
    <p>
     对于数据的预处理和规模压缩，这里同样举一个非常巧妙地例子：数独
    </p>
    <blockquote>
     <h5>
      <a id="_362">
      </a>
      题目描述
     </h5>
     <p>
      数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。
     </p>
     <p>
      请编写一个程序填写数独。
     </p>
     <h5>
      <a id="_368">
      </a>
      输入格式
     </h5>
     <p>
      输入包含多组测试用例。
     </p>
     <p>
      每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。
     </p>
     <p>
      每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。
     </p>
     <p>
      您可以假设输入中的每个谜题都只有一个解决方案。
     </p>
     <p>
      文件结尾处为包含单词“end”的单行，表示输入结束。
     </p>
     <h5>
      <a id="_380">
      </a>
      输出格式
     </h5>
     <p>
      每个测试用例，输出一行数据，代表填充完全后的数独。
     </p>
     <h5>
      <a id="_384">
      </a>
      输入样例：
     </h5>
     <pre><code>4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......
......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.
end
</code></pre>
     <h5>
      <a id="_392">
      </a>
      输出样例：
     </h5>
     <pre><code>417369825632158947958724316825437169791586432346912758289643571573291684164875293
416837529982465371735129468571298643293746185864351297647913852359682714128574936
</code></pre>
    </blockquote>
    <h5>
     <a id="_399">
     </a>
     题目分析：
    </h5>
    <p>
     本题目数据量较大，用爆搜解决超时是个问题，因此如何优化剪枝便成了重点，下面是需要进行的准备工作，这些预处理极其关键！：
    </p>
    <p>
     借鉴自yxc大佬的思路，本题可以用二进制位表示的方法巧妙地解决，因此需要提前准备一些数位转换的表以便使用
    </p>
    <ol>
     <li>
      数组map：在进行lowbit运算时，将返回值转换成对应的含义(数字)
     </li>
     <li>
      数组ones：每个数的二进制表示中有几个1
     </li>
     <li>
      数组sudoku：存放原始数据和解
     </li>
     <li>
      数组row、col，cell，表示每行可供选择的数、每列可供选择的数，每个3*3方格可供选择的数
     </li>
     <li>
      函数lowbit：返回一个数字的二进制表达式中最低位的1所对应的值
     </li>
     <li>
      函数makeg：制作两张查询表：ones、map，以便搜索时查询
     </li>
     <li>
      函数init：初始化数组row、col，cell，从输入的数据中检索每行每列的合法数字
     </li>
     <li>
      函数get：找到数组row、col，cell的交集，即满足条件的合法数字
     </li>
     <li>
      函数dfs：深搜解题
     </li>
    </ol>
    <h5>
     <a id="dfsyxc_415">
     </a>
     dfs的思路(借鉴自yxc大佬)：
    </h5>
    <ol>
     <li>
      开始时判断是否搜索成功，若成功则返回
     </li>
     <li>
      ！优化：找出备选方案数最少的空格，先填它，从而实现整体的优化
     </li>
     <li>
      找出能填的数字怼上去试试，能行继续搜，搜到底return上来true，搜不到返回false，那么恢复现场，继续找数搜
     </li>
    </ol>
    <pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;

const int N = 9;
int map[1 &lt;&lt; N], ones[1 &lt;&lt; N];
int row[N], col[N], cell[3][3];
char sudoku[100];

inline int lowbit(int x){
    return x &amp; (-x);
}

inline int get(int x, int y){
    return row[x] &amp; col[y] &amp; cell[x / 3][y / 3];
}

void makeg(){
    for(int i = 0; i &lt; N; i++) map[1 &lt;&lt; i] = i;
    for(int i = 0, k = 0; i &lt; (1 &lt;&lt; N); i++, k = 0){
        for(int j = i; j; j -= lowbit(j)) k++;
        ones[i] = k;
    }
}

void init(){
    for (int i = 0; i &lt; N; i++) row[i] = col[i] = (1 &lt;&lt; N) - 1;
    for(int i = 0; i &lt; 3 ; i++)
        for(int j = 0; j &lt; 3; j++) cell[i][j] = (1 &lt;&lt; N) - 1;
}

bool dfs(int cnt){
    //搜索成功结束
    if(!cnt) return true;
    //找出备选数字数目最少的空格
    int minn = 10;
    int x, y;
    for(int i = 0; i &lt; N; i++){
        for(int j = 0; j &lt; N; j++){
            if(sudoku[i * 9 + j] == '.'){
                int tmp = ones[get(x, y)];
                if(tmp &lt; minn) minn = tmp, x = i, y = j;
            }
        }
    }
    for(int i = get(x, y); i; i -= lowbit(i)){
        int tmp = map[lowbit(i)];
        row[x] -= 1 &lt;&lt; tmp;
        col[y] -= 1 &lt;&lt; tmp;
        cell[x / 3][y  /3] -= 1 &lt;&lt; tmp;
        sudoku[x * 9 + y] = '1' + tmp;
        if(dfs(cnt - 1)) return true;
        row[x] += 1 &lt;&lt; tmp;
        col[y] += 1 &lt;&lt; tmp;
        cell[x / 3][y / 3] += 1 &lt;&lt; tmp;
        sudoku[x * 9 + y] = '.';
    }
    return false;
}

int main(){
    makeg();
    while(cin &gt;&gt; sudoku,  sudoku[0] != 'e'){
        init();
        int cnt = 0;
        for(int i = 0, k = 0; i &lt; N; i++){
            for(int j = 0; j &lt; N; j++, k++){
                if(sudoku[k] != '.'){
                    int tmp = sudoku[k] - '1';
                    row[i] -= 1 &lt;&lt; tmp;
                    col[j] -= 1 &lt;&lt; tmp;
                    cell[i / 3][j / 3] -= 1 &lt;&lt; tmp;
                }
                else cnt++;
            }
        }
        dfs(cnt);
        cout &lt;&lt; sudoku &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
    <blockquote>
     <p>
      从本题中可以看出，通过合理利用位运算使运算和数据的规模极大的得到了缩小，因此，合理利用巧解法可以优化搜索算法。但这类思路通常难以想到，需要大量的刷题经验积累。
     </p>
    </blockquote>
    <h4>
     <a id="2_510">
     </a>
     2.分组问题
    </h4>
    <p>
     典型的例题：分成互质组： 给定 n 个正整数，将它们分组，使得每组中任意两个数互质。至少要分成多少个组？
    </p>
    <blockquote>
     <p>
      给定n个数字分成互质组，那么考虑最坏的情况，要分成n组(n个数均不互质)。因为题目的数据量并不大，可以采用DFS解决，具体思路如下：
     </p>
     <p>
      预备工作：准备一个数组存输入数据，准备一个容器，用于存不同的组，准备一个检索函数，可以检索指定分组内是否存在与目的数字重合的
     </p>
     <ol>
      <li>
       开始DFS：首先是递归终止条件，判断是否搜到末尾，搜到末尾则更新组数计数的值，返回；
      </li>
      <li>
       继续：每次在已有分组中从头开始搜索，用检索函数判断当前数字是否可以加入分组，若可以，加入后递归向下一个数字搜索
      </li>
      <li>
       新建分组：考虑组数为0的情况、找不到可以加入组的情况，应该设置创建新分组的情况，加入新分组后，同样递归向后搜索。
      </li>
     </ol>
    </blockquote>
    <pre><code class="prism language-c++">//dfs搜索函数的框架：
void dfs(int now)
{
    if (now == n){
        ans = min(ans,  cnt);	//每次搜完取最小组数
        return;
    }
    for (int i = 0; i &lt;  cnt; i++){
        if (check(p[now], i)){	//check函数为检查两数是否互质的函数
            num[now].push_back(p[now]);
            dfs(now + 1);
            num[i].pop_back();
        }
    }
    //需要考虑首次搜索无组可加、当前状态无组可加
    num[cnt++].push_back(p[u]);
    dfs(now + 1);
    num[--cnt].pop_back(); 
}
</code></pre>
    <h4>
     <a id="3_544">
     </a>
     3.求最小分组数问题
    </h4>
    <blockquote>
     <p>
      请区分2！这里使求最小分组数，即存在多组可能的分组方案，
     </p>
    </blockquote>
    <h5>
     <a id="vector_548">
     </a>
     剪枝的基本思路：对于每组数据定长或有最大长度，用vector储存每组长度，如果存不下则新建分组。每轮搜索完毕更新最小组数，每次搜索开始判断当前分组数量是否已经超过历史最优解数量，如果是，放弃该搜索分支。
    </h5>
    <p>
     典型的例题：小猫爬山
    </p>
    <blockquote>
     <p>
      太简单，上文章链接(原创)：
     </p>
     <p>
      https://blog.csdn.net/yanweiqi1754989931/article/details/109603191
     </p>
     <p>
      https://heartfirey.github.io/2020/11/08/ACWing-165-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1-DFS%E5%89%AA%E6%9E%9D/
     </p>
    </blockquote>
    <h4>
     <a id="4_558">
     </a>
     4.求最大分组长度
    </h4>
    <p>
     预处理的时候要求出合法的分组长度，对于合法长度存在的区间也要进行分析，例如：
    </p>
    <blockquote>
     <p>
      ACWing.167 木棒 DFS+剪枝(可直接参考博文内容)
     </p>
     <p>
      https://blog.csdn.net/yanweiqi1754989931/article/details/109603322
     </p>
     <p>
      https://heartfirey.github.io/2020/11/08/ACWing-167-%E6%9C%A8%E6%A3%92-DFS-%E5%89%AA%E6%9E%9D/
     </p>
    </blockquote>
    <blockquote>
     <h5>
      <a id="_568">
      </a>
      题目描述
     </h5>
     <p>
      乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。
     </p>
     <p>
      然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。
     </p>
     <p>
      请你设计一个程序，帮助乔治计算木棒的可能最小长度。
     </p>
     <p>
      每一节木棍的长度都用大于零的整数表示。
     </p>
     <h5>
      <a id="_578">
      </a>
      输入格式
     </h5>
     <p>
      输入包含多组数据，每组数据包括两行。
     </p>
     <p>
      第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。
     </p>
     <p>
      第二行是截断以后，所得到的各节木棍的长度。
     </p>
     <p>
      在最后一组数据之后，是一个零。
     </p>
     <h5>
      <a id="_588">
      </a>
      输出格式
     </h5>
     <p>
      为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。
     </p>
     <h5>
      <a id="_592">
      </a>
      数据范围
     </h5>
     <p>
      数据保证每一节木棍的长度均不大于50。
     </p>
     <h5>
      <a id="_596">
      </a>
      输入样例：
     </h5>
     <pre><code>9
5 2 1 5 2 1 5 2 1
4
1 2 3 4
0
</code></pre>
     <h5>
      <a id="_606">
      </a>
      输出样例：
     </h5>
     <pre><code>6
5
</code></pre>
    </blockquote>
    <h4>
     <a id="_613">
     </a>
     解题思路分析
    </h4>
    <p>
     需要的准备工作如下：
    </p>
    <ol>
     <li>
      一个数组stick：用于存放题目的输入
     </li>
     <li>
      一个数组vis：记录对每根木棒的访问
     </li>
     <li>
      变量cnt：用于记录总的木棍数
     </li>
     <li>
      变量len：用于dfs前找到合法的长度并记录
     </li>
     <li>
      变量group：分组数
     </li>
     <li>
      变量total：记录总长度
     </li>
    </ol>
    <p>
     下面分析解题思路：
    </p>
    <ol>
     <li>
      木棒的原始长度未知，但是所有木棒的总长度已知，因此我们可以通过枚举每个”假设“合法的长度（可以被总长度整除），并通过搜索判断该长度是否真正合法。这里有一点要注意，合法的长度一定比最长的木棒大，比所有的木棒短，因此变得到了合法长度存在的区间；
     </li>
     <li>
      在假设合法长度确定的同时也就确定了小木棒的数量cnt=sum/len，那么这个就可以作为合法标志的判断条件：在所有的小木棍都用完的情况下拼成了cnt个长度相等的小木棒。
     </li>
     <li>
      dfs的搜索思路：
      <ol>
       <li>
        枚举长度len；
       </li>
       <li>
        用之前还没有使用过的小木棍拼凑小木棒；
       </li>
       <li>
        判断该长度方案是否可行。
       </li>
      </ol>
     </li>
    </ol>
    <p>
     剪枝与优化：
    </p>
    <ol>
     <li>
      在搜索时设置一个fail变量，标记拼接失败的木棍的长度, 避免同样长度的木棒重复搜索
     </li>
     <li>
      不容易考虑到的是：当该木棍在开头和结尾都不可以使用的时候, 那么该方案就失败了。因此在搜索失败时要进行及时判断处理
     </li>
     <li>
      可以在一开始时对所有的木棒排序，从大到小，若填上最长的之后没有可以匹配的话，那么这个长度绝对是不合法的。（大块一定比小块需要搜索的次数少）
     </li>
     <li>
      限制小木棍加入到木棒中的编号，保证加入进来的木棍的长度是递减的（必须先排序）
     </li>
    </ol>
    <p>
     <strong>
      具体的实现不在这里展示，请参考博文
     </strong>
    </p>
    <h4>
     <a id="5_643">
     </a>
     5.未完待续
    </h4>
    <p>
     …时间暂时不允许，先写到这，留个坑
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f79616e7765697169313735343938393933312f:61727469636c652f64657461696c732f313039363033333834" class_="artid" style="display:none">
 </p>
</div>


