---
layout: post
title: "学习笔记10并发编程2线程安全问题与同步机制"
date: 2025-03-07 07:22:37 +0800
description: "线程修改共享变量后，其他线程无法立即看到最新值（CPU缓存与主存不一致）。：编译器或处理器优化可能导致代码执行顺序与源码不一致，破坏预期逻辑。：多个线程对同一资源进行非原子操作，导致结果依赖线程执行顺序。：代码简洁，JVM 自动优化锁升级，适合大多数低竞争场景。可见性：一个线程修改共享变量后，其他线程能立即感知变化。使用读写锁：读操作频率远高于写操作（如热点数据缓存）。原子性：确保操作不可分割，要么全部执行，要么不执行。使用原子类：单一变量的原子操作（如计数器、标志位）。，导致程序行为不符合预期。"
keywords: "学习笔记10——并发编程2线程安全问题与同步机制"
categories: ['高级开发必备技能', 'Java']
tags: ['笔记', '学习']
artid: "146084960"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146084960
    alt: "学习笔记10并发编程2线程安全问题与同步机制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146084960
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146084960
cover: https://bing.ee123.net/img/rand?artid=146084960
image: https://bing.ee123.net/img/rand?artid=146084960
img: https://bing.ee123.net/img/rand?artid=146084960
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     学习笔记10——并发编程2线程安全问题与同步机制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     线程安全问题与同步机制
    </h3>
    <h4>
     线程安全的本质问题
    </h4>
    <p>
     线程安全问题源于多线程环境下对
     <strong>
      共享资源（数据或状态）的非原子性、非可见性、非有序性访问
     </strong>
     ，导致程序行为不符合预期。
    </p>
    <p>
     主要表现如下：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        竞态条件（Race Condition）
       </strong>
       ：多个线程对同一资源进行非原子操作，导致结果依赖线程执行顺序。
      </p>
      <ul>
       <li>
        <p>
         <strong>
          示例
         </strong>
         ：两个线程同时执行
         <code>
          count++
         </code>
         （非原子操作，实际包含读-改-写三步）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        内存可见性问题
       </strong>
       ：线程修改共享变量后，其他线程无法立即看到最新值（CPU缓存与主存不一致）。
      </p>
      <ul>
       <li>
        <p>
         <strong>
          示例
         </strong>
         ：线程A修改
         <code>
          flag=true
         </code>
         ，线程B可能仍读取到旧值
         <code>
          flag=false
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        指令重排序
       </strong>
       ：编译器或处理器优化可能导致代码执行顺序与源码不一致，破坏预期逻辑。
      </p>
      <ul>
       <li>
        <p>
         <strong>
          示例
         </strong>
         ：单例模式的双重检查锁定中，未使用
         <code>
          volatile
         </code>
         可能导致对象未初始化完成就被使用。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     同步机制的核心目标
    </h4>
    <ul>
     <li>
      <p>
       原子性：确保操作不可分割，要么全部执行，要么不执行。
      </p>
     </li>
     <li>
      <p>
       可见性：一个线程修改共享变量后，其他线程能立即感知变化。
      </p>
     </li>
     <li>
      <p>
       有序性：禁止编译器和处理器对代码顺序进行破坏逻辑的优化。
      </p>
     </li>
    </ul>
    <h4>
     线程的互斥同步方式有哪些? 如何比较和选择?
    </h4>
    <p>
     <strong>
      互斥同步的主要方式
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         机制
        </strong>
       </th>
       <th>
        <strong>
         实现原理
        </strong>
       </th>
       <th>
        <strong>
         特点
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         1.
         <code>
          synchronized
         </code>
        </strong>
       </td>
       <td>
        基于 JVM 的 Monitor 锁，通过对象头实现锁状态管理
       </td>
       <td>
        - 自动加锁/解锁 - 支持锁升级（偏向锁→轻量级锁→重量级锁） - 非公平锁
       </td>
       <td>
        简单的代码块或方法同步，低竞争场景
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         2.
         <code>
          ReentrantLock
         </code>
        </strong>
       </td>
       <td>
        基于 AQS（AbstractQueuedSynchronizer）实现
       </td>
       <td>
        - 支持公平锁与非公平锁 - 可中断、可超时 - 支持多条件变量（
        <code>
         Condition
        </code>
        ）
       </td>
       <td>
        需要灵活控制的复杂同步场景
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         3. 原子类
        </strong>
       </td>
       <td>
        基于 CAS（Compare-And-Swap）无锁算法
       </td>
       <td>
        - 无阻塞、高并发性能 - 仅适用于单一变量操作
       </td>
       <td>
        高并发计数、状态标记等简单原子操作
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         4. 读写锁（
         <code>
          ReentrantReadWriteLock
         </code>
         ）
        </strong>
       </td>
       <td>
        分离读锁（共享）和写锁（独占）
       </td>
       <td>
        - 读操作并发度高 - 写操作互斥
       </td>
       <td>
        读多写少场景（如缓存）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     synchronized
     <code>
      vs
     </code>
     ReentrantLock
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         维度
        </strong>
       </th>
       <th>
        <strong>
         <code>
          synchronized
         </code>
        </strong>
       </th>
       <th>
        <strong>
         <code>
          ReentrantLock
         </code>
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         锁获取方式
        </strong>
       </td>
       <td>
        自动获取/释放，无需手动管理
       </td>
       <td>
        需手动
        <code>
         lock()
        </code>
        和
        <code>
         unlock()
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         公平性
        </strong>
       </td>
       <td>
        仅支持非公平锁
       </td>
       <td>
        支持公平锁与非公平锁
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         功能扩展
        </strong>
       </td>
       <td>
        不支持超时、中断
       </td>
       <td>
        支持
        <code>
         tryLock(timeout)
        </code>
        、
        <code>
         lockInterruptibly()
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         性能
        </strong>
       </td>
       <td>
        JVM 优化成熟，低竞争下性能优
       </td>
       <td>
        高竞争下更灵活，但代码复杂度高
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        简单同步需求（如方法同步）
       </td>
       <td>
        需要精细控制的场景（如死锁恢复、条件等待）
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      选择建议
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       优先使用
       <code>
        synchronized
       </code>
       ：代码简洁，JVM 自动优化锁升级，适合大多数低竞争场景。
      </p>
     </li>
     <li>
      <p>
       选择
       <code>
        ReentrantLock
       </code>
       ：需要公平锁、可中断锁或复杂条件等待时（如生产者-消费者模型）。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      原子类 vs 锁机制
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         维度
        </strong>
       </th>
       <th>
        <strong>
         原子类（CAS）
        </strong>
       </th>
       <th>
        <strong>
         锁机制（synchronized/ReentrantLock）
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         并发性能
        </strong>
       </td>
       <td>
        无锁，高吞吐量（适合高频短操作）
       </td>
       <td>
        有锁，线程阻塞可能引发上下文切换开销
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用操作
        </strong>
       </td>
       <td>
        单一变量的原子操作（如
        <code>
         i++
        </code>
        ）
       </td>
       <td>
        复杂逻辑或跨多个变量的操作
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         竞争处理
        </strong>
       </td>
       <td>
        自旋重试（可能浪费 CPU）
       </td>
       <td>
        线程阻塞（节省 CPU，但增加延迟）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         内存语义
        </strong>
       </td>
       <td>
        仅保证变量操作的原子性和可见性
       </td>
       <td>
        保证临界区内的原子性、可见性和有序性
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      选择建议
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       使用原子类：单一变量的原子操作（如计数器、标志位）。
      </p>
     </li>
     <li>
      <p>
       使用锁机制：涉及多个共享变量或复杂逻辑的同步。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      读写锁 vs 普通互斥锁
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         维度
        </strong>
       </th>
       <th>
        <strong>
         读写锁（
         <code>
          ReentrantReadWriteLock
         </code>
         ）
        </strong>
       </th>
       <th>
        <strong>
         普通互斥锁（synchronized/ReentrantLock）
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         并发度
        </strong>
       </td>
       <td>
        读操作可并发，写操作互斥
       </td>
       <td>
        所有操作互斥
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        读多写少（如缓存、配置管理）
       </td>
       <td>
        读写均衡或写多读少
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         实现复杂度
        </strong>
       </td>
       <td>
        需区分读/写锁
       </td>
       <td>
        简单，统一加锁
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      选择建议
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       使用读写锁：读操作频率远高于写操作（如热点数据缓存）。
      </p>
     </li>
     <li>
      <p>
       使用普通锁：读写频率接近或写操作较多。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33363137343038312f:61727469636c652f64657461696c732f313436303834393630" class_="artid" style="display:none">
 </p>
</div>


