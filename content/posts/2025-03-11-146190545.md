---
layout: post
title: "23种设计模式"
date: 2025-03-11 22:12:47 +0800
description: "设计模式的选择需结合具体场景，其核心目标是提高代码的。"
keywords: "设计模式csdn"
categories: ['杂谈']
tags: ['设计模式']
artid: "146190545"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146190545
    alt: "23种设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146190545
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146190545
cover: https://bing.ee123.net/img/rand?artid=146190545
image: https://bing.ee123.net/img/rand?artid=146190545
img: https://bing.ee123.net/img/rand?artid=146190545
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     23种设计模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     <strong>
      一、创建型模式（Creational Patterns）
     </strong>
    </h4>
    <p>
     <strong>
      聚焦对象创建过程，简化复杂对象的实例化。
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        单例模式（Singleton）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：确保一个类仅有一个实例，并提供全局访问点。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：日志管理器、配置中心。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        工厂模式（Factory Method）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：定义创建对象的接口，由子类决定实例化哪个类。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：根据用户类型创建不同的用户对象。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        抽象工厂模式（Abstract Factory）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：提供一个创建一系列相关或依赖对象的接口，无需指定具体类。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：跨平台 UI 组件库（如鸿蒙、Android、iOS 的按钮工厂）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        建造者模式（Builder）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：分步构建复杂对象，分离构造与表示。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：配置一个包含多个参数的网络请求对象。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        原型模式（Prototype）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：通过克隆现有对象创建新对象，避免重复初始化。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：游戏中快速复制角色对象。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      二、结构型模式（Structural Patterns）
     </strong>
    </h4>
    <p>
     <strong>
      关注类和对象的组合，优化系统结构。
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        适配器模式（Adapter）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：将一个类的接口转换为另一个接口，使不兼容的类可以协同工作。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：将旧版本的 API 适配到新系统中。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        桥接模式（Bridge）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：分离抽象与实现，使两者可以独立变化。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：将 UI 组件的抽象类与具体渲染实现分离。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        装饰器模式（Decorator）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：动态添加功能到对象，避免继承的局限性。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：给图片加载组件添加缓存、压缩等功能。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        组合模式（Composite）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：将对象组合成树形结构，统一处理单个对象和组合对象。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：文件系统中的目录和文件管理。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        外观模式（Facade）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：为子系统提供统一接口，简化复杂子系统的使用。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：支付系统的统一接口封装（支付宝、微信支付等）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        享元模式（Flyweight）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：共享细粒度对象，减少内存消耗。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：游戏中大量重复的子弹、粒子效果对象。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        代理模式（Proxy）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：为其他对象提供代理以控制访问。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：网络请求的代理缓存、权限控制。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      三、行为型模式（Behavioral Patterns）
     </strong>
    </h4>
    <p>
     <strong>
      处理对象间的交互和职责分配。
     </strong>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        策略模式（Strategy）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：定义算法族，使它们可互换，策略的变化独立于使用它的客户。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：电商平台的促销策略（满减、折扣、赠品）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        责任链模式（Chain of Responsibility）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：将请求传递给处理者链，直到有一个处理者响应。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：请假审批流程（员工→主管→经理）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        命令模式（Command）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：将请求封装为对象，支持撤销、重做等操作。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：文本编辑器的撤销 / 重做功能。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        迭代器模式（Iterator）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：提供遍历集合元素的统一接口，隐藏集合内部结构。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：遍历列表、树结构等数据集合。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        中介者模式（Mediator）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：用中介对象封装对象间的交互，减少对象间的直接依赖。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：聊天系统中用户间的消息传递。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        备忘录模式（Memento）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：捕获对象状态并保存，以便恢复。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：游戏进度保存与恢复。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        观察者模式（Observer）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：对象间的一对多依赖，当对象状态变化时通知所有依赖者。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：股票价格实时更新通知。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        状态模式（State）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：对象行为随状态改变而变化，状态作为独立类。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：订单状态机（待支付→已支付→已发货）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        模板方法模式（Template Method）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：定义算法骨架，子类实现具体步骤。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：HTTP 请求的模板（预处理→发送→后处理）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        访问者模式（Visitor）
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         定义
        </strong>
        ：将数据结构与操作分离，允许在不修改数据结构的前提下添加新操作。
       </li>
       <li>
        <strong>
         示例
        </strong>
        ：文档解析器支持多种格式（HTML、Markdown）的访问。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      四、总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       创建型
      </strong>
      ：解决对象创建的复杂性，如单例、工厂。
     </li>
     <li>
      <strong>
       结构型
      </strong>
      ：优化类 / 对象的组合，如适配器、装饰器。
     </li>
     <li>
      <strong>
       行为型
      </strong>
      ：规范对象间的交互逻辑，如策略、观察者。
     </li>
    </ul>
    <p>
     设计模式的选择需结合具体场景，其核心目标是提高代码的
     <strong>
      可维护性
     </strong>
     、
     <strong>
      可扩展性
     </strong>
     和
     <strong>
      复用性
     </strong>
     。
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f687179313938392f:61727469636c652f64657461696c732f313436313930353435" class_="artid" style="display:none">
 </p>
</div>


