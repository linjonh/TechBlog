---
layout: post
title: "redis删除与先判断再删除的区别"
date: 2025-03-15 16:54:51 +0800
description: "redis直接删除与先判断存在后再删除的区别"
keywords: "redis删除与先判断再删除的区别"
categories: ['未分类']
tags: ['缓存', '数据库', 'Redis']
artid: "146281863"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146281863
    alt: "redis删除与先判断再删除的区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146281863
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146281863
cover: https://bing.ee123.net/img/rand?artid=146281863
image: https://bing.ee123.net/img/rand?artid=146281863
img: https://bing.ee123.net/img/rand?artid=146281863
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     redis删除与先判断再删除的区别
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在Redis中，“先判断存在再删除”与“直接删除”的区别主要体现在‌
     <strong>
      操作效率、原子性保障、并发安全性
     </strong>
     ‌三个方面，具体对比如下：
    </p>
    <hr/>
    <h4>
     <a id="1__4">
     </a>
     ‌
     <strong>
      1. 操作效率
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      ‌
      <strong>
       直接删除
      </strong>
      ‌：仅需执行
      <code>
       DEL
      </code>
      命令一次，无论键是否存在均直接操作，无额外判断步骤。时间复杂度为
      <code>
       O(1)
      </code>
      ，适合高频操作场景‌。
     </li>
     <li>
      ‌
      <strong>
       先判断存在再删除
      </strong>
      ‌：需先执行
      <code>
       EXISTS
      </code>
      命令判断键是否存在，再根据结果执行
      <code>
       DEL
      </code>
      。若键不存在，
      <code>
       DEL
      </code>
      命令仍会执行但实际无操作，导致‌
      <strong>
       两次网络请求和两次命令执行
      </strong>
      ‌，增加耗时和资源消耗‌。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="2__11">
     </a>
     ‌
     <strong>
      2. 原子性保障
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      ‌
      <strong>
       直接删除
      </strong>
      ‌：
      <code>
       DEL
      </code>
      命令本身是原子操作，执行过程不会被其他客户端命令打断，保证操作的完整性‌。
     </li>
     <li>
      ‌
      <strong>
       先判断存在再删除
      </strong>
      ‌：
      <code>
       EXISTS
      </code>
      与
      <code>
       DEL
      </code>
      为两个独立操作，在两者间隔期间可能因其他客户端修改键状态（如删除或更新），导致判断结果与实际删除操作不一致（‌
      <strong>
       竞态条件
      </strong>
      ‌）‌。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="3__18">
     </a>
     ‌
     <strong>
      3. 并发安全性
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      ‌
      <strong>
       直接删除
      </strong>
      ‌：在高并发场景下，仅需关注
      <code>
       DEL
      </code>
      的返回结果（返回
      <code>
       1
      </code>
      表示删除成功，
      <code>
       0
      </code>
      表示键不存在），无需额外逻辑即可处理并发冲突‌。
     </li>
     <li>
      ‌
      <strong>
       先判断存在再删除
      </strong>
      ‌：若多个客户端同时判断键存在并尝试删除，可能导致重复删除或误删问题（如键已被其他客户端删除）‌。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_25">
     </a>
     ‌
     <strong>
      总结对比
     </strong>
     ‌
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        ‌
        <strong>
         场景
        </strong>
        ‌
       </th>
       <th>
        ‌
        <strong>
         直接删除
        </strong>
        ‌
       </th>
       <th>
        ‌
        <strong>
         先判断存在再删除
        </strong>
        ‌
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ‌
        <strong>
         执行次数
        </strong>
        ‌
       </td>
       <td>
        1次命令
       </td>
       <td>
        2次命令（
        <code>
         EXISTS
        </code>
        +
        <code>
         DEL
        </code>
        ）
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         网络开销
        </strong>
        ‌
       </td>
       <td>
        低（单次请求）
       </td>
       <td>
        高（两次请求）
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         原子性
        </strong>
        ‌
       </td>
       <td>
        强（单命令原子性）
       </td>
       <td>
        弱（命令组合非原子）
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         适用场景
        </strong>
        ‌
       </td>
       <td>
        无需关心键是否存在的场景
       </td>
       <td>
        需记录键状态或统计删除次数的场景
       </td>
      </tr>
      <tr>
       <td>
        ‌
        <strong>
         性能影响
        </strong>
        ‌
       </td>
       <td>
        更高效
       </td>
       <td>
        效率较低，存在竞态风险
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_37">
     </a>
     ‌
     <strong>
      推荐方案
     </strong>
     ‌
    </h4>
    <ul>
     <li>
      <p>
       ‌
       <strong>
        优先选择直接删除
       </strong>
       ‌：通过
       <code>
        DEL
       </code>
       命令的返回值（
       <code>
        0
       </code>
       或
       <code>
        1
       </code>
       ）即可判断是否删除成功，无需额外操作‌。
      </p>
     </li>
     <li>
      <p>
       ‌特殊场景处理
      </p>
      <p>
       若需记录键的删除状态，可结合事务（MULTI/EXEC）或Lua脚本保证操作的原子性‌。例如：
      </p>
      <pre><code class="prism language-lua"><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'EXISTS'</span><span class="token punctuation">,</span> KEYS‌<span class="token punctuation">:</span>ml<span class="token operator">-</span><span class="token function">citation</span><span class="token punctuation">{<!-- --></span>ref<span class="token operator">=</span><span class="token string">"5"</span> data<span class="token operator">=</span><span class="token string">"citationList"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">then</span>
  <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'DEL'</span><span class="token punctuation">,</span> KEYS‌<span class="token punctuation">:</span>ml<span class="token operator">-</span><span class="token function">citation</span><span class="token punctuation">{<!-- --></span>ref<span class="token operator">=</span><span class="token string">"5"</span> data<span class="token operator">=</span><span class="token string">"citationList"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
  <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f7a7a775f31373630303639313335372f:61727469636c652f64657461696c732f313436323831383633" class_="artid" style="display:none">
 </p>
</div>


