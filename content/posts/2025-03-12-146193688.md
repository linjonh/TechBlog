---
layout: post
title: "LuaJIT-学习1-LuaJIT介绍"
date: 2025-03-12 01:43:06 +0800
description: "LuaJit 介绍"
keywords: "LuaJIT 学习（1）—— LuaJIT介绍"
categories: ['Lua']
tags: ['Luajit', 'Lua']
artid: "146193688"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146193688
    alt: "LuaJIT-学习1-LuaJIT介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146193688
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146193688
cover: https://bing.ee123.net/img/rand?artid=146193688
image: https://bing.ee123.net/img/rand?artid=146193688
img: https://bing.ee123.net/img/rand?artid=146193688
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     LuaJIT 学习（1）—— LuaJIT介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="_1">
     </a>
     介绍
    </h3>
    <p>
     LuaJIT is a
     <strong>
      Just-In-Time Compiler
     </strong>
     (JIT) for the
     <a href="https://www.lua.org/" rel="nofollow">
      Lua
     </a>
     programming language. Lua is a powerful, dynamic and light-weight programming language. It may be embedded or used as a general-purpose, stand-alone language.
    </p>
    <p>
     <strong>
      LuaJIT is fully upwards-compatible with Lua 5.1. It supports all
      <a href="https://www.lua.org/manual/5.1/manual.html#5" rel="nofollow">
       standard Lua library functions
      </a>
      and the full set of
      <a href="https://www.lua.org/manual/5.1/manual.html#3" rel="nofollow">
       Lua/C API functions
      </a>
      .
     </strong>
    </p>
    <p>
     <strong>
      LuaJIT is also fully ABI-compatible to Lua 5.1 at the linker/dynamic loader level.
     </strong>
     This means you can compile a C module against the standard Lua headers and load the same shared library from either Lua or LuaJIT.
    </p>
    <p>
     <strong>
      LuaJIT extends the standard Lua VM with new functionality and adds several extension modules.
     </strong>
     Please note, this page is only about
     <em>
      functional
     </em>
     enhancements and not about performance enhancements, such as the optimized VM, the faster interpreter or the JIT compiler.
    </p>
    <h3>
     <a id="Extensions_Modules_10">
     </a>
     Extensions Modules
    </h3>
    <p>
     LuaJIT comes with several built-in extension modules:
    </p>
    <h4>
     <a id="bit__Bitwise_operations_14">
     </a>
     <code>
      bit.*
     </code>
     — Bitwise operations
    </h4>
    <p>
     LuaJIT supports all bitwise operations as defined by
     <a href="https://bitop.luajit.org" rel="nofollow">
      Lua BitOp
     </a>
     :
    </p>
    <pre><code>bit.tobit  bit.tohex  bit.bnot    bit.band bit.bor  bit.bxor
bit.lshift bit.rshift bit.arshift bit.rol  bit.ror  bit.bswap
</code></pre>
    <p>
     This module is a LuaJIT built-in — you don’t need to download or install Lua BitOp. The Lua BitOp site has full documentation for all
     <a href="https://bitop.luajit.org/api.html" rel="nofollow">
      Lua BitOp API functions
     </a>
     . The FFI adds support for
     <a href="https://luajit.org/ext_ffi_semantics.html#cdata_arith" rel="nofollow">
      64 bit bitwise operations
     </a>
     , using the same API functions.
    </p>
    <p>
     Please make sure to
     <code>
      require
     </code>
     the module before using any of its functions:
    </p>
    <pre><code>local bit = require("bit")
</code></pre>
    <p>
     An already installed Lua BitOp module is ignored by LuaJIT. This way you can use bit operations from both Lua and LuaJIT on a shared installation.
    </p>
    <h4>
     <a id="ffi__FFI_library_33">
     </a>
     <code>
      ffi.*
     </code>
     — FFI library
    </h4>
    <p>
     The
     <a href="https://luajit.org/ext_ffi.html" rel="nofollow">
      FFI library
     </a>
     <strong>
      allows calling external C functions and the use of C data structures from pure Lua code【重点】
     </strong>
     .
    </p>
    <h4>
     <a id="jit__JIT_compiler_control_37">
     </a>
     <code>
      jit.*
     </code>
     — JIT compiler control
    </h4>
    <p>
     The functions in this module
     <a href="https://luajit.org/ext_jit.html" rel="nofollow">
      control the behavior of the JIT compiler engine
     </a>
     .
    </p>
    <h4>
     <a id="C_API_extensions_41">
     </a>
     C API extensions
    </h4>
    <p>
     LuaJIT adds some
     <a href="https://luajit.org/ext_c_api.html" rel="nofollow">
      extra functions to the Lua/C API
     </a>
     .
    </p>
    <h4>
     <a id="Profiler_45">
     </a>
     Profiler
    </h4>
    <p>
     LuaJIT has an
     <a href="https://luajit.org/ext_profiler.html" rel="nofollow">
      integrated profiler
     </a>
     .
    </p>
    <h3>
     <a id="Enhanced_Standard_Library_Functions_49">
     </a>
     Enhanced Standard Library Functions
    </h3>
    <h4>
     <a id="xpcallf_err_args_passes_arguments_51">
     </a>
     <code>
      xpcall(f, err [,args...])
     </code>
     passes arguments
    </h4>
    <p>
     Unlike the standard implementation in Lua 5.1,
     <code>
      xpcall()
     </code>
     passes any arguments after the error function to the function which is called in a protected context.
    </p>
    <h5>
     <a id="_xpcall__55">
     </a>
     例子： xpcall 的使用
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">divide</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Division by zero"</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span>
    <span class="token keyword">return</span> a <span class="token operator">/</span> b
<span class="token keyword">end</span>

<span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">error_handler</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">"Handled error: "</span> <span class="token operator">..</span> err
<span class="token keyword">end</span>

<span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">safe_divide</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token keyword">local</span> status<span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token function">xpcall</span><span class="token punctuation">(</span>divide<span class="token punctuation">,</span> error_handler<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token keyword">if</span> status <span class="token keyword">then</span>
        <span class="token keyword">return</span> result
    <span class="token keyword">else</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Custom Error Handler: "</span> <span class="token operator">..</span> result<span class="token punctuation">)</span>  <span class="token comment">-- 自定义错误处理</span>
        <span class="token keyword">return</span> <span class="token keyword">nil</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">safe_divide</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- 输出：5</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">safe_divide</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- 输出：Custom Error Handler: Handled error: Division by zero</span>


</code></pre>
    <h4>
     <a id="load_handle_UTF8_source_code_85">
     </a>
     <code>
      load*()
     </code>
     handle UTF-8 source code
    </h4>
    <p>
     Non-ASCII characters are handled transparently by the Lua source code parser. This allows the use of UTF-8 characters in identifiers and strings. A UTF-8 BOM is skipped at the start of the source code.
    </p>
    <h5>
     <a id="_89">
     </a>
     例子：变量名是中文
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> 姓名 <span class="token operator">=</span> <span class="token string">"张三"</span>
<span class="token keyword">local</span> 年龄 <span class="token operator">=</span> <span class="token number">25</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"姓名："</span> <span class="token operator">..</span> 姓名<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"年龄："</span> <span class="token operator">..</span> 年龄<span class="token punctuation">)</span>
</code></pre>
    <p>
     使用标准的lua5.1会语法报错
    </p>
    <h4>
     <a id="load_add_a_mode_parameter_101">
     </a>
     <code>
      load*()
     </code>
     add a mode parameter
    </h4>
    <p>
     As an extension from Lua 5.2, the functions
     <code>
      loadstring()
     </code>
     ,
     <code>
      loadfile()
     </code>
     and (new)
     <code>
      load()
     </code>
     add an optional
     <code>
      mode
     </code>
     parameter.
    </p>
    <p>
     The default mode string is
     <code>
      "bt"
     </code>
     , which allows loading of both source code and bytecode. Use
     <code>
      "t"
     </code>
     to allow only source code or
     <code>
      "b"
     </code>
     to allow only bytecode to be loaded.
    </p>
    <p>
     By default, the
     <code>
      load*
     </code>
     functions generate the native bytecode format. For cross-compilation purposes, add
     <code>
      W
     </code>
     to the mode string to force the 32 bit format and
     <code>
      X
     </code>
     to force the 64 bit format. Add both to force the opposite format. 【同时使用
     <code>
      W
     </code>
     和
     <code>
      X
     </code>
     来强制使用与本机平台相反的字节码格式】Note that non-native bytecode generated by
     <code>
      load*
     </code>
     cannot be run, but can still be passed to
     <code>
      string.dump
     </code>
     .
    </p>
    <h4>
     <a id="stringdumpf_mode_generates_portable_bytecode_109">
     </a>
     <code>
      string.dump(f [,mode])
     </code>
     generates portable bytecode
    </h4>
    <p>
     An extra argument has been added to
     <code>
      string.dump()
     </code>
     . If set to
     <code>
      true
     </code>
     or to a string which contains the character
     <code>
      s
     </code>
     , ‘stripped’ bytecode without debug information is generated. This speeds up later bytecode loading and reduces memory usage. See also the
     <a href="https://luajit.org/running.html#opt_b" rel="nofollow">
      <code>
       -b
      </code>
      command line option
     </a>
     .
    </p>
    <p>
     The generated bytecode is portable and can be loaded on any architecture that LuaJIT supports. However, the bytecode compatibility versions must match. Bytecode only stays compatible within a major+minor version (x.y.aaa → x.y.bbb), except for development branches. Foreign bytecode (e.g. from Lua 5.1) is incompatible and cannot be loaded.
    </p>
    <p>
     Note:
     <code>
      LJ_GC64
     </code>
     mode requires a different frame layout, which implies a different, incompatible bytecode format between 32 bit and 64 bit ports. This may be rectified in the future. In the meantime, use the
     <code>
      W
     </code>
     and X
     <a href="https://luajit.org/extensions.html#load_mode" rel="nofollow">
      modes of the
      <code>
       load*
      </code>
      functions
     </a>
     for cross-compilation purposes.
    </p>
    <p>
     Due to VM hardening, bytecode is not deterministic. Add
     <code>
      d
     </code>
     to the mode string to dump it in a deterministic manner: identical source code always gives a byte-for-byte identical bytecode dump. This feature is mainly useful for reproducible builds.
    </p>
    <h4>
     <a id="tablenewnarray_nhash_allocates_a_presized_table_119">
     </a>
     <code>
      table.new(narray, nhash)
     </code>
     allocates a pre-sized table
    </h4>
    <p>
     An extra library function
     <code>
      table.new()
     </code>
     can be made available via
     <code>
      require("table.new")
     </code>
     . This creates a pre-sized table, just like the C API equivalent
     <code>
      lua_createtable()
     </code>
     . This is useful for big tables if the final table size is known and automatic table resizing is too expensive.
    </p>
    <h5>
     <a id="tablenew__123">
     </a>
     例子：table.new 的使用
    </h5>
    <pre><code class="prism language-lua"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"table.new"</span><span class="token punctuation">)</span>

t <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
t<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- table</span>
</code></pre>
    <h4>
     <a id="tablecleartab_clears_a_table_134">
     </a>
     <code>
      table.clear(tab)
     </code>
     clears a table
    </h4>
    <p>
     An extra library function
     <code>
      table.clear()
     </code>
     can be made available via
     <code>
      require("table.clear")
     </code>
     . This clears all keys and values from a table, but preserves the allocated array/hash sizes. This is useful when a table, which is linked from multiple places, needs to be cleared and/or when recycling a table for use by the same context. This avoids managing backlinks, saves an allocation and the overhead of incremental array/hash part growth.
    </p>
    <p>
     Please note, this function is meant for very specific situations. In most cases it’s better to replace the (usually single) link with a new table and let the GC do its wo
    </p>
    <h5>
     <a id="tableclear__140">
     </a>
     例子：table.clear 的使用
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> tab <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">}</span>

<span class="token comment">-- 清空表，但保留表的内存分配</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"table.clear"</span><span class="token punctuation">)</span>  <span class="token comment">-- 确保你加载了这个扩展函数</span>
table<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>

<span class="token comment">-- 现在 tab 变成了空表，但它的内存结构（数组和哈希大小）没有改变</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- 输出 nil，因为表已经没有内容了</span>

</code></pre>
    <h4>
     <a id="Enhanced_PRNG_for_mathrandom_154">
     </a>
     Enhanced PRNG for
     <code>
      math.random()
     </code>
    </h4>
    <p>
     LuaJIT uses a Tausworthe PRNG with period 2^223 to implement
     <code>
      math.random()
     </code>
     and
     <code>
      math.randomseed()
     </code>
     . The quality of the PRNG results is much superior compared to the standard Lua implementation, which uses the platform-specific ANSI
     <code>
      rand()
     </code>
     .
    </p>
    <p>
     The PRNG generates the same sequences from the same seeds on all platforms and makes use of all bits in the seed argument.
     <code>
      math.random()
     </code>
     without arguments generates 52 pseudo-random bits for every call. The result is uniformly distributed between 0.0 and 1.0. It’s correctly scaled up and rounded for
     <code>
      math.random(n [,m])
     </code>
     to preserve uniformity.
    </p>
    <p>
     Call
     <code>
      math.randomseed()
     </code>
     without any arguments to seed it from system entropy.
    </p>
    <p>
     Important: Neither this nor any other PRNG based on the simplistic
     <code>
      math.random()
     </code>
     API is suitable for cryptographic use.
    </p>
    <h4>
     <a id="io_functions_handle_64_bit_file_offsets_164">
     </a>
     <code>
      io.*
     </code>
     functions handle 64 bit file offsets
    </h4>
    <p>
     The file I/O functions in the standard
     <code>
      io.*
     </code>
     library handle 64 bit file offsets. In particular, this means it’s possible to open files larger than 2 Gigabytes and to reposition or obtain the current file position for offsets beyond 2 GB (
     <code>
      fp:seek()
     </code>
     method).
    </p>
    <h4>
     <a id="debug_functions_identify_metamethods_168">
     </a>
     <code>
      debug.*
     </code>
     functions identify metamethods
    </h4>
    <p>
     <code>
      debug.getinfo()
     </code>
     and
     <code>
      lua_getinfo()
     </code>
     also return information about invoked metamethods. The
     <code>
      namewhat
     </code>
     field is set to
     <code>
      "metamethod"
     </code>
     and the
     <code>
      name
     </code>
     field has the name of the corresponding metamethod (e.g.
     <code>
      "__index"
     </code>
     ).
    </p>
    <h3>
     <a id="Fully_Resumable_VM_172">
     </a>
     Fully Resumable VM
    </h3>
    <p>
     The LuaJIT VM is fully resumable. This means you can yield from a coroutine even across contexts, where this would not possible with the standard Lua 5.1 VM: e.g. you can yield across
     <code>
      pcall()
     </code>
     and
     <code>
      xpcall()
     </code>
     , across iterators and across metamethods.
    </p>
    <h5>
     <a id="_pcall__yield_176">
     </a>
     例子：协程在 pcall 中 yield
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">testCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">pcall</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Start coroutine"</span><span class="token punctuation">)</span>
        coroutine<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- 在这里挂起协程</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Resumed coroutine"</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">local</span> co <span class="token operator">=</span> coroutine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>testCoroutine<span class="token punctuation">)</span>


coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>co<span class="token punctuation">)</span> <span class="token comment">-- 启动协程</span>
coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>co<span class="token punctuation">)</span> <span class="token comment">-- 恢复协程</span>

</code></pre>
    <p>
     输出
    </p>
    <pre><code>Start coroutine
Resumed coroutine
</code></pre>
    <p>
     而在标准的lua5.1中只输出
    </p>
    <pre><code>Start coroutine
</code></pre>
    <h5>
     <a id="_yield_208">
     </a>
     例子：协程在迭代器中 yield
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> coroutine <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"coroutine"</span><span class="token punctuation">)</span>

<span class="token comment">-- 一个自定义的迭代器，它会在每次返回一个元素时进行yield</span>
<span class="token keyword">function</span> <span class="token function">my_iterator</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> _end<span class="token punctuation">)</span>
  <span class="token keyword">local</span> i <span class="token operator">=</span> start
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> _end <span class="token keyword">then</span>
      coroutine<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">-- 在返回每个元素时进行yield</span>
      i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token keyword">return</span> i <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token comment">-- 创建一个协程来使用迭代器</span>
<span class="token keyword">local</span> co <span class="token operator">=</span> coroutine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token function">my_iterator</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"迭代值: "</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token comment">-- 在这里可以插入一些逻辑，例如，暂停协程，模拟某些异步操作</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span><span class="token punctuation">)</span>

<span class="token comment">-- 在主线程中控制协程的恢复</span>
<span class="token keyword">while</span> coroutine<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span>co<span class="token punctuation">)</span> <span class="token operator">~=</span> <span class="token string">"dead"</span> <span class="token keyword">do</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"恢复协程"</span><span class="token punctuation">)</span>
  coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>co<span class="token punctuation">)</span>
  <span class="token comment">-- 每次恢复时迭代器会继续从`yield`的位置往下执行</span>
<span class="token keyword">end</span>

</code></pre>
    <p>
     输出
    </p>
    <pre><code>恢复协程
恢复协程
迭代值:         1
恢复协程
迭代值:         2
恢复协程
迭代值:         3
恢复协程
迭代值:         4
恢复协程
迭代值:         5
</code></pre>
    <p>
     而标准的lua5.1输出
    </p>
    <pre><code>恢复协程
</code></pre>
    <h3>
     <a id="Extensions_from_Lua_52_264">
     </a>
     Extensions from Lua 5.2
    </h3>
    <p>
     LuaJIT supports some language and library extensions from Lua 5.2. Features that are unlikely to break existing code are unconditionally enabled:
    </p>
    <ul>
     <li>
      <code>
       goto
      </code>
      and
      <code>
       ::labels::
      </code>
      .
     </li>
    </ul>
    <h5>
     <a id="goto__270">
     </a>
     例子：goto 的使用
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> i <span class="token operator">=</span> <span class="token number">0</span>

<span class="token punctuation">::</span>start<span class="token punctuation">::</span>  <span class="token comment">-- 标签定义</span>

<span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token keyword">then</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"i is "</span> <span class="token operator">..</span> i<span class="token punctuation">)</span>
    i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">goto</span> start  <span class="token comment">-- 跳回到 start 标签</span>
<span class="token keyword">end</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Finished"</span><span class="token punctuation">)</span>

</code></pre>
    <ul>
     <li>
      Hex escapes
      <code>
       '\x3F'
      </code>
      and
      <code>
       '\z'
      </code>
      escape in strings.
     </li>
    </ul>
    <p>
     The escape sequence ‘
     <code>
      \z
     </code>
     ’ skips the following span of white-space characters, including line breaks; it is particularly useful to break and indent a long literal string into multiple lines without adding the newlines and spaces into the string contents.
    </p>
    <h5>
     <a id="z_291">
     </a>
     例子：'\z’转义字符的使用
    </h5>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> long_str <span class="token operator">=</span><span class="token string">"This is a very long string that we\z
    want to break into multiple lines,\z
    but without including the newlines\z
    or spaces in the actual string content."</span>

<span class="token function">print</span><span class="token punctuation">(</span>long_str<span class="token punctuation">)</span>

</code></pre>
    <p>
     A byte in a literal string can also be specified by its numerical value. This can be done with the escape sequence
     <code>
      \xXX
     </code>
     , where
     <em>
      XX
     </em>
     is a sequence of exactly two hexadecimal digits, or with the escape sequence
     <code>
      \ddd
     </code>
     , where
     <em>
      ddd
     </em>
     is a sequence of up to three decimal digits. (Note that if a decimal escape is to be followed by a digit, it must be expressed using exactly three digits.) Strings in Lua can contain any 8-bit value, including embedded zeros, which can be specified as ‘
     <code>
      \0
     </code>
     ’.
    </p>
    <ul>
     <li>
      <code>
       load(string|reader [, chunkname [,mode [,env]]])
      </code>
      .
     </li>
     <li>
      <code>
       loadstring()
      </code>
      is an alias for
      <code>
       load()
      </code>
      .
     </li>
     <li>
      <code>
       loadfile(filename [,mode [,env]])
      </code>
      .
     </li>
     <li>
      <code>
       math.log(x [,base])
      </code>
      .
     </li>
     <li>
      <code>
       string.rep(s, n [,sep])
      </code>
      .
     </li>
     <li>
      <code>
       string.format()
      </code>
      :
      <code>
       %q
      </code>
      reversible.
      <code>
       %s
      </code>
      checks
      <code>
       __tostring
      </code>
      .
      <code>
       %a
      </code>
      and
      <code>
       "%A
      </code>
      added.
     </li>
     <li>
      String matching pattern
      <code>
       %g
      </code>
      added.【
      <strong>
       <code>
        %g
       </code>
       :
      </strong>
      represents all printable characters except space.】
     </li>
     <li>
      <code>
       io.read("*L")
      </code>
      .【
      <strong>
       “
       <code>
        \*L
       </code>
       ”:
      </strong>
      reads the next line keeping the end of line (if present), returning
      <strong>
       nil
      </strong>
      on end of file.】
     </li>
     <li>
      <code>
       io.lines()
      </code>
      and
      <code>
       file:lines()
      </code>
      process
      <code>
       io.read()
      </code>
      options.【和 io.read() 函数一样的参数】
     </li>
     <li>
      <code>
       os.exit(status|true|false [,close])
      </code>
      .
     </li>
     <li>
      <code>
       package.searchpath(name, path [, sep [, rep]])
      </code>
      .
     </li>
     <li>
      <code>
       package.loadlib(name, "*")
      </code>
      .
     </li>
    </ul>
    <h5>
     <a id="packageloadlib__317">
     </a>
     例子：package.loadlib 的使用
    </h5>
    <p>
     假设你有两个 C 库：libcore.so 和 libext.so。libext.so 依赖于 libcore.so，但是你不想让 libcore.so 的函数直接暴露到 Lua 环境中，而是只需要确保它的符号可以在 libext.so 中使用。
    </p>
    <pre><code class="prism language-lua"><span class="token comment">-- 仅仅加载 libcore.so，并确保符号链接到 Lua 环境中</span>
package<span class="token punctuation">.</span><span class="token function">loadlib</span><span class="token punctuation">(</span><span class="token string">"libcore.so"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span>

<span class="token comment">-- 加载并使用 libext.so（它依赖于 libcore.so 的符号）</span>
package<span class="token punctuation">.</span><span class="token function">loadlib</span><span class="token punctuation">(</span><span class="token string">"libext.so"</span><span class="token punctuation">,</span> <span class="token string">"luaopen_libext"</span><span class="token punctuation">)</span>

</code></pre>
    <ul>
     <li>
      <code>
       debug.getinfo()
      </code>
      returns
      <code>
       nparams
      </code>
      and
      <code>
       isvararg
      </code>
      for option
      <code>
       "u"
      </code>
      .
     </li>
     <li>
      <code>
       debug.getlocal()
      </code>
      accepts function instead of level.
     </li>
     <li>
      <code>
       debug.getlocal()
      </code>
      and
      <code>
       debug.setlocal()
      </code>
      accept negative indexes for varargs.
     </li>
     <li>
      <code>
       debug.getupvalue()
      </code>
      and
      <code>
       debug.setupvalue()
      </code>
      handle C functions.
     </li>
     <li>
      <code>
       debug.upvalueid()
      </code>
      and
      <code>
       debug.upvaluejoin()
      </code>
      .
     </li>
     <li>
      Lua/C API extensions:
      <code>
       lua_version()
      </code>
      <code>
       lua_upvalueid()
      </code>
      <code>
       lua_upvaluejoin()
      </code>
      <code>
       lua_loadx()
      </code>
      <code>
       lua_copy()
      </code>
      <code>
       lua_tonumberx()
      </code>
      <code>
       lua_tointegerx()
      </code>
      <code>
       luaL_fileresult()
      </code>
      <code>
       luaL_execresult()
      </code>
      <code>
       luaL_loadfilex()
      </code>
      <code>
       luaL_loadbufferx()
      </code>
      <code>
       luaL_traceback()
      </code>
      <code>
       luaL_setfuncs()
      </code>
      <code>
       luaL_pushmodule()
      </code>
      <code>
       luaL_newlibtable()
      </code>
      <code>
       luaL_newlib()
      </code>
      <code>
       luaL_testudata()
      </code>
      <code>
       luaL_setmetatable()
      </code>
     </li>
     <li>
      Command line option
      <code>
       -E
      </code>
      .
     </li>
     <li>
      Command line checks
      <code>
       __tostring
      </code>
      for errors.
     </li>
    </ul>
    <h3>
     <a id="Extensions_from_Lua_53_336">
     </a>
     Extensions from Lua 5.3
    </h3>
    <p>
     LuaJIT supports some extensions from Lua 5.3:
    </p>
    <ul>
     <li>
      Unicode escape
      <code>
       '\u{XX...}'
      </code>
      embeds the UTF-8 encoding in string literals.【支持 Unicode 转义！】
     </li>
     <li>
      The argument table
      <code>
       arg
      </code>
      can be read (and modified) by
      <code>
       LUA_INIT
      </code>
      and
      <code>
       -e
      </code>
      chunks.
     </li>
     <li>
      <code>
       io.read()
      </code>
      and
      <code>
       file:read()
      </code>
      accept formats with or without a leading
      <code>
       *
      </code>
      .
     </li>
     <li>
      <code>
       assert()
      </code>
      accepts any type of error object.
     </li>
     <li>
      <code>
       table.move(a1, f, e, t [,a2])
      </code>
      .
     </li>
    </ul>
    <p>
     Moves elements from table a1 to table a2, performing the equivalent to the following multiple assignment: a2[t],··· = a1[f],···,a1[e]. The default for a2 is a1. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.
    </p>
    <p>
     Returns the destination table a2.
    </p>
    <ul>
     <li>
      <code>
       coroutine.isyieldable()
      </code>
      .
     </li>
    </ul>
    <p>
     Returns 1 if the given coroutine can yield, and 0 otherwise.
    </p>
    <ul>
     <li>
      Lua/C API extensions:
      <code>
       lua_isyieldable()
      </code>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f776f6179323030382f:61727469636c652f64657461696c732f313436313933363838" class_="artid" style="display:none">
 </p>
</div>


