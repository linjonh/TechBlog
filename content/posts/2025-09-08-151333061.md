---
layout: post
title: "Django中的软删除"
date: 2025-09-08T21:34:36+0800
description: "软删除是一种数据库策略，通过标记字段（如is_deleted）而非实际删除数据。Django中实现步骤：1）创建含is_delete字段的基类；2）自定义Manager过滤已删除数据；3）重写delete()方法将删除操作转为标记更新；4）可选扩展QuerySet支持批量软删除。优点包括数据可恢复、支持审计，同时保持正常查询只返回有效数据。"
keywords: "Django中的软删除"
categories: ['Python']
tags: ['数据库', 'Sqlite', 'Django']
artid: "151333061"
arturl: "https://blog.csdn.net/qq_44810930/article/details/151333061"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151333061
    alt: "Django中的软删除"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151333061
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151333061
cover: https://bing.ee123.net/img/rand?artid=151333061
image: https://bing.ee123.net/img/rand?artid=151333061
img: https://bing.ee123.net/img/rand?artid=151333061
---



# Django中的软删除



软删除（Soft Delete）是一种数据删除策略，它并不真正从数据库中删除记录，而是通过标记（如 is_deleted 字段）来表示记录已被删除。

这样做的好处是可以保留数据历史，支持数据恢复和审计。

在 Django 里可以通过 **自定义 Manager + 重写 delete 方法** 来实现。

---

### 1. 在模型里增加 `is_delete` 字段

```python
from django.db import models

class BaseModel(models.Model):
    is_delete = models.BooleanField(default=False, verbose_name="是否删除")

    class Meta:
        abstract = True  # 抽象基类，不会建表

```

这样所有继承 `BaseModel` 的表都有 `is_delete` 字段。

---

### 2. 自定义 Manager（默认过滤掉删除的记录）

```python
class ActiveManager(models.Manager):
    def get_queryset(self):
        # 默认只返回 is_delete=False 的数据
        return super().get_queryset().filter(is_delete=False)

```

---

### 3. 在模型里应用 Manager

```python
class User(BaseModel):
    name = models.CharField(max_length=100)

    # managers
    objects = ActiveManager()   # 默认只取未删除的
    all_objects = models.Manager()  # 需要时可以取所有（包括已删除的）

```

这样：

```python
User.objects.all()        # 只会查 is_delete=False
User.all_objects.all()    # 不加过滤，所有数据都能查

```

---

### 4. 重写 `delete()` 方法（软删除）

```python
class User(BaseModel):
    name = models.CharField(max_length=100)

    objects = ActiveManager()
    all_objects = models.Manager()

    def delete(self, using=None, keep_parents=False):
        self.is_delete = True
        self.save(update_fields=['is_delete'])  # 只更新 is_delete 字段

```

这样：

```python
u = User.objects.get(id=1)
u.delete()  # 不会真正删除，只会把 is_delete 置为 True

```

---

### 5. 如果要做批量删除

Django 的 `QuerySet.delete()` 默认会直接删掉数据，所以我们也可以自定义一个 `QuerySet` 来支持批量软删除：

```python
class SoftDeleteQuerySet(models.QuerySet):
    def delete(self):
        return super().update(is_delete=True)

```

结合 Manager 使用：

```python
class ActiveManager(models.Manager):
    def get_queryset(self):
        return SoftDeleteQuerySet(self.model, using=self._db).filter(is_delete=False)

```

这样就支持：

```python
User.objects.filter(name="Tom").delete()  # 也会变成软删除

```

---

✅ **总结**：

1. `is_delete` 字段标记是否删除。
2. 自定义 Manager 过滤掉已删除的数据。
3. 重写 `delete()` 实现软删除逻辑。
4. 如有需要，配合自定义 `QuerySet` 处理批量软删除。



