---
layout: post
title: "设计模式-观察者模式状态模式"
date: 2025-03-12 18:02:47 +0800
description: "本文总结了23种设计模式中的观察者模式和状态模式，小伙伴可以自行学习"
keywords: "设计模式-观察者模式、状态模式"
categories: ['设计模式']
tags: ['设计模式', '观察者模式', '状态模式']
artid: "146211207"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146211207
    alt: "设计模式-观察者模式状态模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146211207
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146211207
cover: https://bing.ee123.net/img/rand?artid=146211207
image: https://bing.ee123.net/img/rand?artid=146211207
img: https://bing.ee123.net/img/rand?artid=146211207
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     设计模式-观察者模式、状态模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" name="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">
     观察者模式
    </h2>
    <h3 id="vXpfl" name="vXpfl">
     定义
    </h3>
    <ul>
     <li id="u57da99b4">
      <p>
       定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
      </p>
     </li>
     <li id="u7c30262e">
      <p>
       又被称为发布-订阅（Publish/Subscribe)模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己；
      </p>
     </li>
    </ul>
    <h3 id="XwjoL" name="XwjoL">
     类图
    </h3>
    <p id="ua8ccdbd0">
    </p>
    <p class="img-center">
     <img alt="" height="631" id="uc2fd4265" src="https://i-blog.csdnimg.cn/img_convert/2a89c37e59f497c68decc351124e2213.png" width="847"/>
    </p>
    <h3 id="qZNFw" name="qZNFw">
     角色
    </h3>
    <ul>
     <li id="u9f9beabf">
      <p>
       Subject ：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象
      </p>
     </li>
     <li id="u2cae9e24">
      <p>
       ConcreteSubject ： 具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知
      </p>
     </li>
     <li id="uae3bd359">
      <p>
       Observer： 抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己
      </p>
     </li>
     <li id="udae35cfb">
      <p>
       ConcrereObserver： 具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态
      </p>
     </li>
    </ul>
    <h3 id="pSrua" name="pSrua">
     优缺点
    </h3>
    <ul>
     <li>
      <p>
       优点：
      </p>
      <ul>
       <li>
        <p>
         实现了观察者和被观察者之间的抽象耦合
        </p>
       </li>
       <li>
        <p>
         动态联动
        </p>
       </li>
       <li>
        <p>
         广播通信。被观察者会向所有的登记的观察者发出通知
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       缺点
      </p>
      <ul>
       <li>
        <p>
         在应用观察者模式时需要考虑开发效率和运行效率的问题，程序中包括一个被观察者，多个观察者，开发，调式等内容会比较复杂。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="fcROX" name="fcROX">
     使用场景
    </h3>
    <ul>
     <li id="u04ee92e2">
      <p>
       关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系
      </p>
     </li>
     <li id="ue0868a98">
      <p>
       事件多级触发场景
      </p>
     </li>
     <li id="uaf51f17f">
      <p>
       跨系统的消息交换场景，如消息队列，事件总线的处理机制
      </p>
     </li>
    </ul>
    <h2 id="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F" name="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">
     状态模式
    </h2>
    <h3 id="s8p2b" name="s8p2b">
     定义
    </h3>
    <ul>
     <li id="uc9884333">
      <p>
       允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类
      </p>
     </li>
     <li id="u92dd9329">
      <p>
       与策略模式是亲兄弟，策略模式会控制对象使用什么策略，而状态模式会自动改变状态
      </p>
     </li>
    </ul>
    <h3 id="wJeCM" name="wJeCM">
     类图
    </h3>
    <p id="uf303a515">
    </p>
    <p class="img-center">
     <img alt="" height="681" id="uc3f7fe3e" src="https://i-blog.csdnimg.cn/img_convert/ef5cee05f3e4db5d6d4382bce148c2a6.png" width="1334"/>
    </p>
    <h3 id="y5rUI" name="y5rUI">
     角色
    </h3>
    <ul>
     <li id="u56c4db8c">
      <p>
       state： 抽象状态对象，负责对象状态定义，并且封装环境角色来实现状态转换。一般为抽象类或者接口
      </p>
     </li>
     <li id="ub77b32ce">
      <p>
       ConcreteState： 具体状态角色，需要完成两个职责，本状态的行为管理和趋向状态管理，就是本状态下该干的事情，与本状态该如何过渡到其他状态
      </p>
     </li>
     <li id="u23ef3fa6">
      <p>
       Context: 环境角色，定义客户端所需要的接口，并且负责具体状态的切换
      </p>
     </li>
    </ul>
    <h3 id="Fll34" name="Fll34">
     优缺点
    </h3>
    <ul>
     <li>
      <p>
       优点
      </p>
      <ul>
       <li>
        <p>
         封装了转换规则
        </p>
       </li>
       <li>
        <p>
         枚举可能的状态，在枚举状态之前需要确定状态种类
        </p>
       </li>
       <li>
        <p>
         将所有与某个状态有关的行为放到一个类中，并且可以以方便的增加新的状态，只需要改变对象状态即可改变对象的行为
        </p>
       </li>
       <li>
        <p>
         允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
        </p>
       </li>
       <li>
        <p>
         可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       缺点
      </p>
      <ul>
       <li>
        <p>
         状态模式的使用必然会增加系统类和对象的个数
        </p>
       </li>
       <li>
        <p>
         状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱
        </p>
       </li>
       <li>
        <p>
         状态模式对”开闭原则“的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源代码
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="fPux6" name="fPux6">
     使用场景
    </h3>
    <ul>
     <li id="uaa4f616e">
      <p>
       行为随状态改变而改变的场景
      </p>
     </li>
     <li id="ue5f8d77f">
      <p>
       条件，分支语句的代替者
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34313634353831372f:61727469636c652f64657461696c732f313436323131323037" class_="artid" style="display:none">
 </p>
</div>


