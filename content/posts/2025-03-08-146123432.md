---
layout: post
title: "VUE2第三期样式冲突组件通信异步更新自定义指令插槽"
date: 2025-03-08 21:53:50 +0800
description: "scoped解决样式冲突、data写法、组件通信（props获取数据、$emit发送事件；eventbus（$on、$emit和 $off）；provide（提供数据）、inject（获取数据）；v-model简化（固定属性名）；sync简化（自定义属性名））、ref与$refs（获取dom元素与组件）、$nextTick（解决vue异步更新的缺点）、自定义指令、插槽"
keywords: "【VUE2】第三期——样式冲突、组件通信、异步更新、自定义指令、插槽"
categories: ['Vue']
tags: ['前端框架', 'Vue', 'Vue']
artid: "146123432"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146123432
    alt: "VUE2第三期样式冲突组件通信异步更新自定义指令插槽"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146123432
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146123432
cover: https://bing.ee123.net/img/rand?artid=146123432
image: https://bing.ee123.net/img/rand?artid=146123432
img: https://bing.ee123.net/img/rand?artid=146123432
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【VUE2】第三期——样式冲突、组件通信、异步更新、自定义指令、插槽
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="main-toc" name="tableOfContents">
     <strong>
      目录
     </strong>
    </h2>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1%20scoped%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81" name="1%20scoped%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E5%86%B2%E7%AA%81">
     1 scoped解决样式冲突
    </h2>
    <p id="1.1%20%E9%97%AE%E9%A2%98" name="1.1%20%E9%97%AE%E9%A2%98">
     问题：
    </p>
    <p>
     写在组件中的样式会
     <strong>
      全局生效
     </strong>
     → 因此很容易造成多个组件之间的样式冲突问题。
    </p>
    <p id="1.2%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" name="1.2%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">
     解决方法：
    </p>
    <p>
     可以给组件加上
     <strong>
      scoped
     </strong>
     属性,可以
     <strong>
      让样式只作用于当前组件
     </strong>
    </p>
    <p>
     如：
    </p>
    <pre><code class="language-html">&lt;style scoped&gt;

&lt;/style&gt;</code></pre>
    <p id="1.3%20scoped%E5%8E%9F%E7%90%86" name="1.3%20scoped%E5%8E%9F%E7%90%86">
     scoped原理：
    </p>
    <blockquote>
     <p>
      自动执行：
     </p>
     <ol>
      <li>
       <p>
        当前组件内标签都被添加
        <strong>
         data-v-hash值
        </strong>
        的属性
       </p>
      </li>
      <li>
       <p>
        css选择器都被添加 [
        <strong>
         data-v-hash值
        </strong>
        ] 的属性选择器
       </p>
      </li>
     </ol>
     <p>
      最终效果:
     </p>
     <p>
      <strong>
       必须是当前组件的元素
      </strong>
      , 才会有这个自定义属性, 才会被这个样式作用到
     </p>
    </blockquote>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/66b66a4370a446d280880e6cf09fbc3c.png"/>
    </p>
    <hr/>
    <h2 id="2%20data%E5%86%99%E6%B3%95" name="2%20data%E5%86%99%E6%B3%95">
     2 data写法
    </h2>
    <blockquote>
     <p>
      一个组件的 data 选项必须是一个函数
     </p>
     <p>
      目的是为了：保证每个组件实例，维护独立的一份数据对象
     </p>
     <p>
      每次创建新的组件实例，都会新执行一次data 函数，得到一个新对象
     </p>
    </blockquote>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/550950cfa65a4d8d8ab35765a3e5b827.png"/>
    </p>
    <p>
     如：
    </p>
    <pre><code class="language-html">&lt;script&gt;
export default {
  data: function () {
    return {
      count: 100,
    }
  },
}
&lt;/script&gt;</code></pre>
    <hr/>
    <h2 id="3%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1" name="3%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">
     3 组件通信
    </h2>
    <blockquote>
     <p>
      总结：
     </p>
     <p>
     </p>
     <p>
      父子通信：
     </p>
     <p>
      1.props &amp; $emit 父向子传值，子通知父改值        3.1
     </p>
     <p>
      1.1 v-model简写（不可自定义属性值）        5.1.2
     </p>
     <p>
      1.2 sync简写（可自定义属性值）                 5.1.3
     </p>
     <p>
      2.ref &amp; $refs 父主动拿子的方法与属性                  6.2
     </p>
     <p>
     </p>
     <p>
      非父子通信：
     </p>
     <p>
      1.event bus 事件总线（任意组件）                       3.2.1
     </p>
     <p>
      2.跨层级通信（同一家族组件）                             3.2.2
     </p>
    </blockquote>
    <hr/>
    <h3 id="3.1%20%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB" name="3.1%20%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB">
     3.1 父子关系
    </h3>
    <blockquote>
     <p>
      父组件通过 props 将数据传递给子组件
      <br/>
      子组件利用 $emit 通知父组件修改更新
     </p>
    </blockquote>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/4dca1b37953d41a29cc8dcca41b1de7d.png"/>
    </p>
    <hr/>
    <h4 id="3.1.1%C2%A0%E7%88%B6%E5%90%91%E5%AD%90%E4%BC%A0%E5%80%BC%20props" name="3.1.1%C2%A0%E7%88%B6%E5%90%91%E5%AD%90%E4%BC%A0%E5%80%BC%20props">
     3.1.1 父向子传值 props
    </h4>
    <blockquote>
     <p>
      步骤：
     </p>
     <ol>
      <li>
       给子组件以添加属性的方式传值
      </li>
      <li>
       子组件内部通过props接收
      </li>
      <li>
       模板中直接使用 props接收的值
      </li>
     </ol>
    </blockquote>
    <p>
     App.vue（父组件）：
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;!-- 主体区域 --&gt;
  &lt;section id="app"&gt;
    &lt;!--第一步：给子组件挂上list属性，并将值赋值给list属性--&gt;
    &lt;TodoMain :list="list" @del="del"&gt;&lt;/TodoMain&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
//...
  data() {
    return {
      list: [
        {id: 1, content: "吃饭"},
        {id: 2, content: "睡觉"},
        {id: 3, content: "打豆豆"}
      ],
    }
  },
 
 
}
&lt;/script&gt;

</code></pre>
    <p>
     TodoMain.vue（子组件）：
    </p>
    <p>
     注意：此处props为简略用法，完整写法见下文4.2 props校验完整写法
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;!-- 列表区域 --&gt;
  &lt;section class="main"&gt;
    &lt;ul class="todo-list"&gt;
      &lt;!--第三步：直接使用list变量--&gt;
      &lt;li class="todo" v-for="(item, index) in list" :key="item.id"&gt;
        &lt;!--...--&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  //第二步：props接收数据（简略写法）
  props: ["list"],
}
&lt;/script&gt;
</code></pre>
    <hr/>
    <h4 id="3.1.2%20%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC%20%24emit" name="3.1.2%20%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC%20%24emit">
     3.1.2 子向父传值 $emit
    </h4>
    <p>
     （此处为子通知父，父为被动，下文中的$refs为父主动拿子）
    </p>
    <blockquote>
     <p>
      步骤
     </p>
     <ol>
      <li>
       <p>
        $emit触发事件，给父组件发送消息通知
       </p>
      </li>
      <li>
       <p>
        父组件监听$emit触发的事件
       </p>
      </li>
      <li>
       <p>
        提供处理函数，在函数的性参中获取传过来的参数
       </p>
      </li>
     </ol>
    </blockquote>
    <p>
     TodoMain.vue（子组件）：
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;!-- 列表区域 --&gt;
  &lt;section class="main"&gt;
    &lt;button @click="del(item.id)" &gt;&lt;/button&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
//...
  methods: {
    dela(id) {
      //第一步：触发delb事件
      this.$emit("delb", id1)
    }
  }
}
&lt;/script&gt;</code></pre>
    <p>
     App.vue（父组件）：
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;!-- 主体区域 --&gt;
  &lt;section id="app"&gt;
    &lt;!--监听子组件触发的delb事件，监听到后执行delc函数，并将子组件传过来的id1值用id2接收--&gt;
    &lt;TodoMain @delb="delc"&gt;&lt;/TodoMain&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
//...
export default {
  //...
  methods: {
    delc(id2) {
      console.log(id2)
    },
  },

}
&lt;/script&gt;</code></pre>
    <p>
     此为最基本写法，可以进一步化简：使用v-model或sync修饰符，具体见 5 v-model原理
    </p>
    <hr/>
    <h3 id="3.2%20%E9%9D%9E%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB" name="3.2%20%E9%9D%9E%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB">
     3.2 非父子关系
    </h3>
    <h4 id="3.2.1%20event%20bus%20%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF" name="3.2.1%20event%20bus%20%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF">
     3.2.1 event bus 事件总线
    </h4>
    <p>
     （任意两个组件之间的通信）
    </p>
    <p>
     非父子组件之间，进行简易消息传递。(复杂场景→ Vuex)
    </p>
    <p>
     Event Bus（事件总线）可以有多个发送方与多个接收方
    </p>
    <p>
     <strong>
      第一步：创建事件总线实例
     </strong>
     ：
    </p>
    <p>
     首先创建一个新的 Vue 实例作为事件总线，通常命名为
     <code>
      eventBus
     </code>
    </p>
    <p>
     这个实例就像一个中央枢纽，负责管理所有的事件
    </p>
    <p>
     因为 Vue 实例本身具有
     <code>
      $on
     </code>
     （监听事件）、
     <code>
      $emit
     </code>
     （触发事件）和
     <code>
      $off
     </code>
     （移除事件监听器）方法，所以可以利用这些方法来实现事件的发布和订阅
    </p>
    <pre><code class="language-javascript">// EventBus.js
import Vue from 'vue'

const Bus = new Vue()

export default Bus</code></pre>
    <p>
     在使用Bus事件总线时，需要先导入Bus这个实例对象
    </p>
    <pre><code class="language-javascript">import Bus from '../utils/EventBus'</code></pre>
    <hr/>
    <p>
     <strong>
      第二步：订阅事件（监听事件）：
     </strong>
    </p>
    <p>
     在需要接收数据或响应某个事件的组件中，使用
     <code>
      Bus.$on
     </code>
     方法来监听特定的事件
    </p>
    <blockquote>
     <p>
      <code>
       $on
      </code>
      方法接受两个参数：
     </p>
     <p>
      第一个参数是事件名称（字符串）
     </p>
     <p>
      第二个参数是当事件触发时要执行的回调函数
     </p>
    </blockquote>
    <pre><code class="language-javascript">// 组件 A 中监听事件
Bus.$on('sendMsg', (msg) =&gt; {
  this.msg = msg
})</code></pre>
    <hr/>
    <p>
     <strong>
      第三步：发布事件（触发事件）：
     </strong>
    </p>
    <p>
     在需要发送数据或通知其他组件的组件中，使用
     <code>
      eventBus.$emit
     </code>
     方法来触发特定的事件
    </p>
    <blockquote>
     <p>
      <code>
       $emit
      </code>
      方法的参数：
     </p>
     <p>
      第一个参数是事件名称（必须与要监听的事件名称一致）
     </p>
     <p>
      后面参数不限制个数及数据类型，这些参数会传递给监听该事件的回调函数
     </p>
    </blockquote>
    <pre><code class="language-javascript">Bus.$emit('sendMsg', '这是一个消息')</code></pre>
    <hr/>
    <p>
     <strong>
      第四步：取消事件监听（移除事件监听器）
     </strong>
     ：
    </p>
    <p>
     （选学）
    </p>
    <p>
     在组件销毁或不再需要监听事件时，可以使用
     <code>
      Bus.$off
     </code>
     方法来移除事件监听器，防止内存泄漏
    </p>
    <pre><code class="language-javascript">Bus.$off([event, callback])</code></pre>
    <blockquote>
     <p>
      参数说明：
     </p>
     <p>
      event（可选）：要移除的事件名，可以是一个字符串或一个包含多个事件名的数组。如果省略该参数，则会移除所有事件监听器
     </p>
     <p>
      callback（可选）：要移除的特定回调函数。如果省略该参数，则会移除该事件名下的所有回调函数
     </p>
    </blockquote>
    <hr/>
    <h4 id="3.2.2%C2%A0%E8%B7%A8%E5%B1%82%E7%BA%A7%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%C2%A0provide%26inject" name="3.2.2%C2%A0%E8%B7%A8%E5%B1%82%E7%BA%A7%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%C2%A0provide%26inject">
     3.2.2 跨层级共享数据 provide&amp;inject
    </h4>
    <p>
     （父子、爷孙等之间的通信）
    </p>
    <p>
     父组件 provide提供数据：
    </p>
    <pre><code class="language-javascript">export default {
  provide () {
    return {
       // 普通类型【非响应式】
       color: this.color, 
       // 复杂类型【响应式】
       userInfo: this.userInfo, 
    }
  }
}</code></pre>
    <p>
     子/孙组件 inject获取数据：
    </p>
    <pre><code class="language-javascript">export default {
  inject: ['color','userInfo'],
  created () {
    console.log(this.color, this.userInfo)
  }
}</code></pre>
    <p>
     注意：
    </p>
    <p>
     provide提供的简单类型的数据不是响应式的，复杂类型数据是响应式（推荐提供复杂类型数据）
    </p>
    <p>
     子/孙组件通过inject获取的数据，不能在自身组件内修改
    </p>
    <p>
     inject中的属性值值也可以写成对象形式，可以设置的值：
    </p>
    <blockquote>
     <p>
      <code>
       from
      </code>
      用于指定从祖先组件注入的属性名。如果不使用
      <code>
       from
      </code>
      ，则默认使用当前定义的属性名作为注入的属性名
     </p>
     <p>
      <code>
       default
      </code>
      用于指定注入属性的默认值，当祖先组件没有提供对应的属性时，会使用这个默认值
     </p>
    </blockquote>
    <pre><code class="language-javascript">      inject: {
        // 使用 from 指定注入属性的来源名称
        myUserInfo: {
          from: 'userInfo',
          // 设置默认值
          default: {
            name: '默认姓名',
            age: 0
          }
        },
        // 没有使用 from，默认使用当前属性名注入
        someValue: {
          default: '默认值'
        }
      },</code></pre>
    <hr/>
    <h2 id="4%20props" name="4%20props">
     4 props
    </h2>
    <h3 id="4.1%20%E4%BB%8B%E7%BB%8D%C2%A0" name="4.1%20%E4%BB%8B%E7%BB%8D%C2%A0">
     4.1 介绍
    </h3>
    <p>
     定义：
    </p>
    <p>
     组件上 注册的一些 自定义属性
    </p>
    <p>
     作用：
    </p>
    <p>
     向子组件传递数据
    </p>
    <p>
     特点：
    </p>
    <ol>
     <li>
      <p>
       可以 传递
       <strong>
        任意数量
       </strong>
       的prop
      </p>
     </li>
     <li>
      <p>
       可以 传递
       <strong>
        任意类型
       </strong>
       的prop
      </p>
     </li>
    </ol>
    <hr/>
    <h3 id="4.2%20props%E6%A0%A1%E9%AA%8C%E5%AE%8C%E6%95%B4%E5%86%99%E6%B3%95" name="4.2%20props%E6%A0%A1%E9%AA%8C%E5%AE%8C%E6%95%B4%E5%86%99%E6%B3%95">
     4.2 props校验完整写法
    </h3>
    <p>
     语法：
    </p>
    <pre><code class="language-javascript">props: {
  校验的属性名: {
    type: 类型,  // Number String Boolean ...
    required: true, // 是否必填
    default: 默认值, // 默认值
    validator (value) {
      // 自定义校验逻辑
      return 是否通过校验
    }
  }
},</code></pre>
    <p>
     示例：
    </p>
    <pre><code class="language-javascript">&lt;script&gt;
export default {
  // 完整写法（类型、默认值、非空、自定义校验）
  props: {
    w: {
      type: Number,
      //required: true,
      default: 0,
      validator(val) {
        // console.log(val)
        if (val &gt;= 100 || val &lt;= 0) {
          console.error('传入的范围必须是0-100之间')
          return false
        } else {
          return true
        }
      },
    },
  },
}
&lt;/script&gt;</code></pre>
    <p>
     注意：
    </p>
    <blockquote>
     <p>
      1.default和required一般不同时写（因为当时必填项时，肯定是有值的）
     </p>
     <p>
     </p>
     <p>
      2.default后面如果是简单类型的值，可以直接写。如果是复杂类型的值，则需要以函数的形式return一个默认
     </p>
    </blockquote>
    <hr/>
    <h2 id="5%20v-model%E5%8E%9F%E7%90%86%C2%A0" name="5%20v-model%E5%8E%9F%E7%90%86%C2%A0">
     5 v-model原理
    </h2>
    <p>
     v-model本质上是一个语法糖。例如应用在输入框上，就是value属性 和 input事件 的合写
    </p>
    <pre><code class="language-javascript">&lt;template&gt;
  &lt;div id="app" &gt;
    &lt;input v-model="msg" type="text"&gt;

    &lt;input :value="msg" @input="msg = $event.target.value" type="text"&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
    <p>
     注意：
    </p>
    <blockquote>
     <p>
      1.
      <strong>
       $event
      </strong>
      用于在模板中，获取事件的形参
     </p>
     <p>
      2.不同的表单元素， v-model在底层的处理机制是不一样的，比如给checkbox使用v-model
     </p>
     <p>
      底层处理的是 checked属性和change事件
     </p>
    </blockquote>
    <hr/>
    <h3 id="5.1%20%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A1%A8%E5%8D%95%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%C2%A0" name="5.1%20%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A1%A8%E5%8D%95%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%C2%A0">
     5.1 应用：表单类组件封装
    </h3>
    <h4 id="5.1.1%20%E4%B8%8D%E7%94%A8v-model%E7%9A%84%E5%86%99%E6%B3%95%C2%A0" name="5.1.1%20%E4%B8%8D%E7%94%A8v-model%E7%9A%84%E5%86%99%E6%B3%95%C2%A0">
     5.1.1 不用v-model的写法
    </h4>
    <p>
     （此处就是父子组件通讯的方法 3.1）
    </p>
    <p>
     App.vue
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;BaseSelect :selectId="selectId" @changeCity="selectId = $event"&gt;&lt;/BaseSelect&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import BaseSelect from './components/BaseSelect.vue'
export default {
  data() {
    return {
      selectId: '102',
    }
  },
  components: {
    BaseSelect,
  },
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre>
    <p>
     BaseSelect.vue
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;select :value="selectId" @change="selectCity"&gt;
      &lt;option value="101"&gt;北京&lt;/option&gt;
      &lt;option value="102"&gt;上海&lt;/option&gt;
      &lt;option value="103"&gt;武汉&lt;/option&gt;
      &lt;option value="104"&gt;广州&lt;/option&gt;
      &lt;option value="105"&gt;深圳&lt;/option&gt;
    &lt;/select&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    selectId: String,
  },
  methods: {
    selectCity(e) {
      this.$emit('changeCity', e.target.value)
    },
  },
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre>
    <hr/>
    <h4 id="5.1.2%20%E7%94%A8v-model%E7%9A%84%E5%86%99%E6%B3%95" name="5.1.2%20%E7%94%A8v-model%E7%9A%84%E5%86%99%E6%B3%95">
     5.1.2 用v-model的写法
    </h4>
    <p>
     注意：使用前需要先基于5.1.1的代码稍作修改
    </p>
    <p>
     App.vue
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;!--1.给子组件挂在的属性名为：value 2.监听input事件--&gt;
    &lt;BaseSelect :value="selectId" @input="selectId = $event"&gt;&lt;/BaseSelect&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import BaseSelect from './components/BaseSelect.vue'
export default {
  data() {
    return {
      selectId: '102',
    }
  },
  components: {
    BaseSelect,
  },
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre>
    <p>
     BaseSelect.vue
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;!--绑定value值--&gt;
    &lt;select :value="value" @change="selectCity"&gt;
      &lt;option value="101"&gt;北京&lt;/option&gt;
      &lt;option value="102"&gt;上海&lt;/option&gt;
      &lt;option value="103"&gt;武汉&lt;/option&gt;
      &lt;option value="104"&gt;广州&lt;/option&gt;
      &lt;option value="105"&gt;深圳&lt;/option&gt;
    &lt;/select&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    //接收value值
    value: String,
  },
  methods: {
    selectCity(e) {
      //更改所触发的事件为input
      this.$emit('input', e.target.value)
    },
  },
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre>
    <p>
     完成上述修改后，可以对父组件（App.vue）中的代码进行简化：
    </p>
    <p>
     原：
    </p>
    <pre><code class="language-html">&lt;BaseSelect :value="selectId" @input="selectId = $event"&gt;&lt;/BaseSelect&gt;</code></pre>
    <p>
     改：
    </p>
    <pre><code class="language-html">&lt;BaseSelect v-model="selectId" &gt;&lt;/BaseSelect&gt;</code></pre>
    <p>
     此种方法缺点也显而易见，固定死了属性名必须传value ，
    </p>
    <p>
     以下方法可以自定义属性名
    </p>
    <hr/>
    <h4 id="5.1.3%20sync%20%E4%BF%AE%E9%A5%B0%E7%AC%A6" name="5.1.3%20sync%20%E4%BF%AE%E9%A5%B0%E7%AC%A6">
     5.1.3 sync 修饰符
    </h4>
    <p>
     .sync修饰符 就是
     <strong>
      :属性名
     </strong>
     和
     <strong>
      @update:属性名
     </strong>
     合写
    </p>
    <pre><code class="language-html">&lt;!--父组件--&gt;
&lt;!-- .sync写法 --&gt;
&lt;BaseDialog :visible.sync="isShow" /&gt;
--------------------------------------
&lt;!-- 完整写法 --&gt;
&lt;BaseDialog :visible="isShow" @update:visible="isShow = $event" /&gt;</code></pre>
    <p>
     对比一下上面的v-model
    </p>
    <blockquote>
     <p>
      <strong>
       :value
      </strong>
      =""               变成了
      <strong>
       :属性名
      </strong>
      =""
     </p>
     <p>
      <strong>
       @事件类型
      </strong>
      =""       变成了
      <strong>
       @update:属性名
      </strong>
      =""
     </p>
    </blockquote>
    <p>
     因此在组件中可以使用自定义属性名了，
    </p>
    <p>
     但是在子组件触发的事件变成了
     <strong>
      update:属性名
     </strong>
    </p>
    <pre><code class="language-javascript">//子组件
props: {
  visible: Boolean
},

this.$emit('update:visible', false)</code></pre>
    <p>
     除此之外其他与上述一样，本质上还是最基本的props、$emit通信
    </p>
    <hr/>
    <h2 id="6%20ref%20%E4%B8%8E%20%24refs" name="6%20ref%20%E4%B8%8E%20%24refs">
     6 ref 与 $refs
    </h2>
    <blockquote>
     <p>
      利用ref 和 $refs 可以用于 获取 dom 元素 或 组件实例
     </p>
     <p>
      查找范围 → 当前组件内(更精确稳定)，
     </p>
     <p>
      而之前用document.querySelect('.box') 获取的是整个页面中的盒子
     </p>
    </blockquote>
    <h3 id="6.1%20%E8%8E%B7%E5%8F%96dom%E5%85%83%E7%B4%A0" name="6.1%20%E8%8E%B7%E5%8F%96dom%E5%85%83%E7%B4%A0">
     6.1 获取dom元素
    </h3>
    <p>
     1.给要获取的盒子添加ref属性
    </p>
    <pre><code class="language-html">&lt;div ref="chartRef"&gt;我是渲染图表的容器&lt;/div&gt;</code></pre>
    <p>
     2.恰当时机，通过 $refs获取 this.$refs.xxx 获取
    </p>
    <pre><code class="language-javascript">console.log(this.$refs.chartRef)</code></pre>
    <p>
     恰当时机：指的是页面渲染完（mouted时期及以后）
    </p>
    <hr/>
    <h3 id="6.2%20%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6" name="6.2%20%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6">
     6.2 获取组件
    </h3>
    <p>
     1.给目标组件添加ref属性
    </p>
    <pre><code class="language-html">&lt;BaseForm ref="baseForm"&gt;&lt;/BaseForm&gt;</code></pre>
    <p>
     2.恰当时机，通过 this.$refs.xxx 获取目标组件
    </p>
    <pre><code class="language-javascript">this.$refs.baseForm.组件方法()

this.$refs.baseForm.属性名</code></pre>
    <hr/>
    <h2 id="7%20Vue%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%8E%24nextTick" name="7%20Vue%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%8E%24nextTick">
     7 Vue异步更新与$nextTick
    </h2>
    <p>
     需求：
    </p>
    <p>
     编辑标题, 编辑框自动聚焦
    </p>
    <ol>
     <li>
      <p>
       点击编辑，显示编辑框
      </p>
     </li>
     <li>
      <p>
       让编辑框，立刻获取焦点
      </p>
     </li>
    </ol>
    <p>
     代码：
    </p>
    <pre><code class="language-html">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;div v-if="isShowEdit"&gt;
      &lt;input type="text" v-model="editValue" ref="inp" /&gt;
      &lt;button&gt;确认&lt;/button&gt;
    &lt;/div&gt;
    &lt;div v-else&gt;
      &lt;span&gt;{<!-- -->{ title }}&lt;/span&gt;
      &lt;button @click="editFn"&gt;编辑&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      title: '大标题',
      isShowEdit: false,
      editValue: '',
    }
  },
  methods: {
    editFn() {
        // 显示输入框
        this.isShowEdit = true  
        // 获取焦点
        this.$refs.inp.focus() 
    }  },
}
&lt;/script&gt; </code></pre>
    <p>
     问题：
    </p>
    <p>
     "显示之后"，立刻获取焦点是不能成功的！
    </p>
    <p>
     原因：Vue 是异步更新DOM (提升性能)
    </p>
    <p>
     解决方案：
    </p>
    <p>
     $nextTick：
     <strong>
      等 DOM更新后
     </strong>
     ,才会触发执行此方法里的函数体
    </p>
    <p>
     <strong>
      语法:
     </strong>
     this.$nextTick(函数体)
    </p>
    <pre><code class="language-javascript">this.$nextTick(() =&gt; {
  this.$refs.inp.focus()
})</code></pre>
    <p>
     <strong>
      注意：
     </strong>
     $nextTick 内的函数体 一定是
     <strong>
      箭头函数
     </strong>
     ，这样才能让函数内部的this指向Vue实例
    </p>
    <hr/>
    <h2 id="8%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4" name="8%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">
     8 自定义指令
    </h2>
    <h3 id="8.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" name="8.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">
     8.1 基本用法
    </h3>
    <p>
     全局注册：
    </p>
    <pre><code class="language-javascript">//在main.js中
Vue.directive('指令名', {
    inserted(el) {
    // 可以对 el 标签，扩展额外功能
    el.focus()
  }
})</code></pre>
    <p>
     局部注册：
    </p>
    <pre><code class="language-javascript">//在Vue组件的配置项中
directives: {
  "指令名": {
    inserted () {
      // 可以对 el 标签，扩展额外功能
      el.focus()
    }
  }
}</code></pre>
    <p>
     参数介绍：
    </p>
    <blockquote>
     <p>
      inserted:被绑定元素插入父节点时调用的钩子函数
     </p>
     <p>
      el：使用指令的那个DOM元素
     </p>
    </blockquote>
    <p>
     注意：
    </p>
    <blockquote>
     <p>
      在使用指令的时候，一定要
      <strong>
       先注册
      </strong>
      ，
      <strong>
       再使用
      </strong>
      ，否则会报错使用指令语法： v-指令名
     </p>
     <p>
      如：&lt;input type="text" v-focus/&gt;
     </p>
     <p>
      <strong>
       注册
      </strong>
      指令时
      <strong>
       不用
      </strong>
      加
      <strong>
       v-前缀
      </strong>
      ，但
      <strong>
       使用时
      </strong>
      一定要
      <strong>
       加v-前缀
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h3 id="8.2%20%E4%BC%A0%E5%80%BC" name="8.2%20%E4%BC%A0%E5%80%BC">
     8.2 传值
    </h3>
    <p>
     1.在绑定指令时，可以通过“等号”的形式为指令 绑定 具体的参数值
    </p>
    <pre><code class="language-html">&lt;div v-color="color"&gt;我是内容&lt;/div&gt;</code></pre>
    <p>
     2.通过 binding.value 可以拿到指令值，
     <strong>
      指令值修改会 触发 update 函数
     </strong>
    </p>
    <pre><code class="language-javascript">directives: {
  color: {
    inserted (el, binding) {
      el.style.color = binding.value
    },
    update (el, binding) {
      el.style.color = binding.value
    }
  }
}</code></pre>
    <hr/>
    <h2 id="9%20%E6%8F%92%E6%A7%BD" name="9%20%E6%8F%92%E6%A7%BD">
     9 插槽
    </h2>
    <h3 id="9.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" name="9.1%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">
     9.1 基本用法
    </h3>
    <ol>
     <li>
      <p>
       组件内需要定制的结构部分，改用
       <strong>
        &lt;slot&gt;&lt;/slot&gt;
       </strong>
       占位
      </p>
     </li>
     <li>
      <p>
       使用组件时, 如
       <strong>
        &lt;MyDialog&gt;&lt;/MyDialog&gt;
       </strong>
       标签，内部传入结构替换slot
      </p>
     </li>
     <li>
      <p>
       给插槽传入内容时，可以传入
       <strong>
        纯文本、html标签、组件
       </strong>
      </p>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/f99d22e1eb4e44e586831e47c04e11b7.png"/>
    </p>
    <hr/>
    <h3 id="9.2%20%E9%BB%98%E8%AE%A4%E5%80%BC" name="9.2%20%E9%BB%98%E8%AE%A4%E5%80%BC">
     9.2 默认值
    </h3>
    <p>
     在 &lt;slot&gt; 标签内，放置内容, 作为默认显示内容
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/62bd267fef384566964686f4e2a76f20.png"/>
    </p>
    <p>
     效果：
    </p>
    <ul>
     <li>
      <p>
       外部使用组件时，不传东西，则slot会显示后备内容
      </p>
     </li>
     <li>
      <p>
       外部使用组件时，传东西了，则slot整体会被换掉
      </p>
     </li>
    </ul>
    <hr/>
    <h3 id="9.3%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD" name="9.3%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">
     9.3 具名插槽
    </h3>
    <p>
     多个slot使用name属性区分名字
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/4620684d85b34510ababa76232e4cddf.png"/>
    </p>
    <p>
     template配合v-slot:名字来分发对应标签
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6fd74430d067497392c936af0f7ca57a.png"/>
    </p>
    <p>
     v-slot写起来太长，vue给我们提供一个简单写法
     <strong>
      v-slot —&gt; #
     </strong>
    </p>
    <hr/>
    <h3 id="9.4%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD" name="9.4%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">
     9.4 作用域插槽
    </h3>
    <p>
     作用域插槽不是插槽的一种，插槽只有两种：默认插槽与具名插槽
    </p>
    <p>
     定义slot 插槽的同时, 是可以传值的。给 插槽 上可以 绑定数据，将来 使用组件时可以用
    </p>
    <p>
     使用步骤：
    </p>
    <p>
     1.给 slot 标签, 以 添加属性的方式传值
    </p>
    <pre><code class="language-html">&lt;slot :id="item.id" msg="测试文本"&gt;&lt;/slot&gt;</code></pre>
    <p>
     注意：所有添加的属性, 都会被收集到一个对象中
    </p>
    <p>
     2.在template中, 通过
     <code>
      #插槽名= "obj"
     </code>
     接收，默认插槽名为 default
    </p>
    <pre><code class="language-html">&lt;MyTable :list="list"&gt;
  &lt;template #default="obj"&gt;
    &lt;button @click="del(obj.id)"&gt;删除&lt;/button&gt;
  &lt;/template&gt;
&lt;/MyTable&gt;</code></pre>
    <p>
     注意：传给组件数据，只能写在组价标签身上，不能写在template上，
    </p>
    <p>
     但是接收组件的数据（#default）可以写在组件标签上（仅限默认插槽）
    </p>
    <p>
     插槽与组件的选择：
    </p>
    <p>
     具有逻辑操作的选组件，修改组件部分标签结构选插槽
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35383837303433342f:61727469636c652f64657461696c732f313436313233343332" class_="artid" style="display:none">
 </p>
</div>


