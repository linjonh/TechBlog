---
layout: post
title: "Leetcode_hot100_day1"
date: 2025-03-09 12:07:48 +0800
description: "先排序，固定最小的加数，然后用双指针去夹住后面的序列，去查看三数之和是大了还是小了，决定指针往左还是往右移动。这里要注意的是记得去重，这里调了好久。很合理的思路，但是最后一个样例不能通过。暴力，但是我并不觉得很暴力，感觉还是很优美哈哈，986 / 987 个通过的测试用例。然后我让gpt优化了一下，以为能通过，其实还是没有，但是优化一下的代码更优美，尤其是去重那部分。**注意：**答案中不可以包含重复的三元组。然后屈服了，去学习一下，是怎么个事儿。，请你找出其中不含有重复字符的。，判断是否存在三元组。"
keywords: "Leetcode_hot100_day1"
categories: ['未分类']
tags: ['Leetcode']
artid: "146130146"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146130146
    alt: "Leetcode_hot100_day1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146130146
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146130146
cover: https://bing.ee123.net/img/rand?artid=146130146
image: https://bing.ee123.net/img/rand?artid=146130146
img: https://bing.ee123.net/img/rand?artid=146130146
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Leetcode_hot100_day1
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="15__1">
     </a>
     [15. 三数之和]
    </h3>
    <p>
     (https://leetcode.cn/problems/3sum/)
    </p>
    <p>
     已解答
    </p>
    <p>
     中等
    </p>
    <p>
     相关标签
    </p>
    <p>
     相关企业
    </p>
    <p>
     提示
    </p>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，判断是否存在三元组
     <code>
      [nums[i], nums[j], nums[k]]
     </code>
     满足
     <code>
      i != j
     </code>
     、
     <code>
      i != k
     </code>
     且
     <code>
      j != k
     </code>
     ，同时还满足
     <code>
      nums[i] + nums[j] + nums[k] == 0
     </code>
     。请你返回所有和为
     <code>
      0
     </code>
     且不重复的三元组。
    </p>
    <p>
     **注意：**答案中不可以包含重复的三元组。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <pre><code>输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
</code></pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><code>输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
</code></pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       3 &lt;= nums.length &lt;= 3000
      </code>
     </li>
     <li>
      <code>
       -105 &lt;= nums[i] &lt;= 105
      </code>
     </li>
    </ul>
    <h4>
     <a id="_64">
     </a>
     分析：
    </h4>
    <p>
     先排序，固定最小的加数，然后用双指针去夹住后面的序列，去查看三数之和是大了还是小了，决定指针往左还是往右移动。这里要注意的是记得去重，这里调了好久。
    </p>
    <pre><code class="prism language-C++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; res;
        for (int k = 0; k &lt; nums.size(); k++) {
            if (nums[k] &gt; 0)
                break;
            if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1])
                continue;
            int i = k + 1, j = nums.size() - 1;
            while (i &lt; j) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    res.push_back({nums[i], nums[j], nums[k]});
                    while(i&lt;j&amp;&amp;nums[i]==nums[i+1])///答案去重这里，有点难
                        i++;
                    while(i&lt;j&amp;&amp;nums[j]==nums[j-1])
                        j--;
                    i++;//注意
                    j--;
                } else if (nums[i] + nums[j] + nums[k] &gt; 0)
                    j--;
                else
                    i++;
            }
        }
        return res;
    }
};
</code></pre>
    <h3>
     <a id="3__100">
     </a>
     [3. 无重复字符的最长子串]
    </h3>
    <p>
     (https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
    </p>
    <p>
     已解答
    </p>
    <p>
     中等
    </p>
    <p>
     相关标签
    </p>
    <p>
     相关企业
    </p>
    <p>
     提示
    </p>
    <p>
     给定一个字符串
     <code>
      s
     </code>
     ，请你找出其中不含有重复字符的
     <strong>
      最长 子串
     </strong>
     的长度。
    </p>
    <p>
     <strong>
      示例 1:
     </strong>
    </p>
    <pre><code>输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</code></pre>
    <p>
     <strong>
      示例 2:
     </strong>
    </p>
    <pre><code>输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
</code></pre>
    <p>
     <strong>
      示例 3:
     </strong>
    </p>
    <pre><code>输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
</code></pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <code>
       0 &lt;= s.length &lt;= 5 * 104
      </code>
     </li>
     <li>
      <code>
       s
      </code>
      由英文字母、数字、符号和空格组成
     </li>
    </ul>
    <h4>
     <a id="_155">
     </a>
     分析：
    </h4>
    <p>
     很合理的思路，但是最后一个样例不能通过。暴力，但是我并不觉得很暴力，感觉还是很优美哈哈，986 / 987 个通过的测试用例。
    </p>
    <pre><code class="prism language-C++">class Solution {
public:
     bool checkNor(string s){
       unordered_map&lt;char,int&gt; h;
        for(int i=0;i&lt;s.length();i++){
            h[s[i]]++;
            if(h[s[i]]&gt;1)
                return false;
        }
        return true;
    }
    int lengthOfLongestSubstring(string s) {
        int ans=0;
        for(int i=0; i &lt; s.length(); ){
            int j=i+1;
            string tmp=s.substr(i,j-i);
            while(checkNor(tmp)){
                ans=ans&gt;tmp.length()?ans:tmp.length();
                j++;
                if(j&gt; s.length())
                    break;
                tmp=s.substr(i,j-i);
            }
          i++;
        }
        return ans;
    }
};
</code></pre>
    <p>
     然后我让gpt优化了一下，以为能通过，其实还是没有，但是优化一下的代码更优美，尤其是去重那部分。
    </p>
    <pre><code class="prism language-C++">class Solution {
public:
    // 优化 checkNor，不再创建新的字符串，而是直接在 s 上检查
    bool checkNor(const string &amp;s, int start, int end) {
        unordered_set&lt;char&gt; h;
        for (int i = start; i &lt; end; i++) {
            if (h.count(s[i])) return false; // 如果已有字符，返回 false
            h.insert(s[i]);
        }
        return true;
    }

    int lengthOfLongestSubstring(string s) {
        int ans = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            int j = i + 1;
            while (j &lt;= s.length() &amp;&amp; checkNor(s, i, j)) { // 直接在 s 上检查，避免 substr
                ans = max(ans, j - i);
                j++;
            }
        }
        return ans;
    }
};
</code></pre>
    <p>
     然后屈服了，去学习一下，是怎么个事儿。
    </p>
    <pre><code class="prism language-C++">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       unordered_set&lt;char&gt; lookup;
       int ans=0;
       int left=0;
       for(int i=0;i&lt;s.length();i++){
           while(lookup.find(s[i])!=lookup.end()){//找到了
               //窗口向右滑动，直到s[i]在窗口内不重复
               lookup.erase(s[left]);
               left++;
           }
           //没找到右边界的，可以插入
           lookup.insert(s[i]);
           ans=max(ans,i-left+1);
       }
       return ans;
    }
};
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f53637265616d696e675f517565656e2f:61727469636c652f64657461696c732f313436313330313436" class_="artid" style="display:none">
 </p>
</div>


