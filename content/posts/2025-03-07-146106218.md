---
layout: post
title: "深入理解C语言链表数据结构的基石"
date: 2025-03-07 22:10:43 +0800
description: "在C语言中，借助结构体（struct）c// 定义链表节点结构int data;// 数据域，这里存储整数// 指针域，指向下一个节点在这个定义中，struct Node 代表链表节点的类型。data 成员用于存放具体的数据（这里设定为 int 类型）；next 是一个指针，指向 struct Node 类型的对象，即下一个链表节点，如此构建起链表的链式结构。"
keywords: "c链表的详细讲解"
categories: ['数据结构', 'C']
tags: ['算法', '数据结构', 'C']
artid: "146106218"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146106218
    alt: "深入理解C语言链表数据结构的基石"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146106218
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146106218
cover: https://bing.ee123.net/img/rand?artid=146106218
image: https://bing.ee123.net/img/rand?artid=146106218
img: https://bing.ee123.net/img/rand?artid=146106218
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深入理解C语言链表：数据结构的基石
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      在C语言的编程宇宙中，
      <span style="color:#fe2c24">
       链表
      </span>
      就像是一座稳固的基石，支撑着众多复杂程序的构建。它以独特的魅力和强大的功能，在解决各类编程难题时发挥着至关重要的作用。今天，就让我们一同深入探索链表的奥秘。
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p style="text-align:center">
     <br/>
     <img alt="" height="493" src="https://i-blog.csdnimg.cn/direct/4465171330fa4243ac055994f0e55b89.jpeg" width="655"/>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%88%9D%E7%9B%B8%E8%AF%86" name="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%88%9D%E7%9B%B8%E8%AF%86">
     一、链表初相识
    </h2>
    <p>
    </p>
    <p>
     链表是一种线性数据结构，与内存中连续存储数据的数组截然不同，链表的元素在内存中的存储位置是离散的。它由一系列节点（Node）串连而成，每个节点都包含两个关键部分：
    </p>
    <p>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       数据域：
      </strong>
     </span>
     <u>
      用于存储实际的数据，可以是整数、字符，甚至是复杂的结构体等各种数据类型。
     </u>
    </p>
    <p>
    </p>
    <p>
     <strong>
      指针域：
     </strong>
     存储着下一个节点在内存中的
     <span style="color:#fe2c24">
      地址
     </span>
     ，
     <u>
      <em>
       <strong>
        通过指针将各个节点按顺序连接起来，形成一条“链”。链表的最后一个节点的指针通常指向NULL，作为链表结束的标志。
       </strong>
      </em>
     </u>
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89" name="%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89">
     二、链表的结构定义
    </h2>
    <p>
    </p>
    <p>
     在C语言中，借助
     <strong>
      <span style="color:#fe2c24">
       结构体（struct）
      </span>
     </strong>
     来定义链表节点，示例如下：
    </p>
    <pre><code class="language-cpp">c

// 定义链表节点结构

struct Node {

    int data; // 数据域，这里存储整数

    struct Node* next; // 指针域，指向下一个节点

};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     在这个定义中，
     <span style="color:#fe2c24">
      struct Node 代表链表节点的类型。 data 成员用于存放具体的数据（这里设定为 int 类型）； next 是一个指针，指向 struct Node 类型的对象，即下一个链表节点，如此构建起链表的链式结构。
     </span>
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%A4%A7%E6%8F%AD%E7%A7%98" name="%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%A4%A7%E6%8F%AD%E7%A7%98">
     三、链表的基本操作大揭秘
    </h2>
    <p>
    </p>
    <h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%B0%E8%8A%82%E7%82%B9" name="%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%B0%E8%8A%82%E7%82%B9">
     <span style="color:#956fe7">
      （一）创建新节点
     </span>
    </h3>
    <p>
    </p>
    <p>
     创建新节点是链表操作的基础，
     <u>
      每当要向链表添加新元素时，都需先创建一个新节点。
     </u>
    </p>
    <p>
     <br/>
    </p>
    <pre><code class="language-cpp">c

// 创建新节点的函数

struct Node* createNode(int value) {

    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

    if (newNode == NULL) {

        // 内存分配失败，通常是系统内存不足的情况

        fprintf(stderr, "内存分配失败\n");

        return NULL;

    }

    newNode-&gt;data = value;

    newNode-&gt;next = NULL;

    return newNode;

}



</code></pre>
    <p>
     此函数中，首先使用 malloc 函数为新节点分配内存空间。若内存分配成功，将传入的值赋给新节点的数据域 data ，并将指针域 next 初始化为 NULL ，表示该新节点暂时是链表的最后一个节点。若内存分配失败，打印错误信息并返回 NULL 。
    </p>
    <p>
    </p>
    <h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9" name="%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9">
     <span style="color:#956fe7">
      （二）插入节点
     </span>
    </h3>
    <p>
    </p>
    <p>
     插入节点是常用操作，可在链表不同位置插入，常见的有
     <span style="color:#fe2c24">
      头部插入
     </span>
     和
     <span style="color:#fe2c24">
      尾部插入
     </span>
     。
    </p>
    <p>
    </p>
    <h4 id="%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5" name="%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5">
     头部插入
    </h4>
    <pre><code class="language-cpp">c

// 在链表头部插入节点的函数

struct Node* insertAtHead(struct Node* head, int value) {

    struct Node* newNode = createNode(value);

    if (newNode != NULL) {

        newNode-&gt;next = head;

        head = newNode;

    }

    return head;

}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     头部插入时，先创建新节点 newNode 。然后让新节点的 next 指针指向当前头节点 head ，将新节点连接到原链表头部。最后，更新 head 为新节点，使其成为链表的头节点。
    </p>
    <p>
    </p>
    <h4 id="%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5" name="%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5">
     尾部插入
    </h4>
    <p>
     <br/>
    </p>
    <pre><code class="language-cpp">c

// 在链表尾部插入节点的函数

struct Node* insertAtTail(struct Node* head, int value) {

    struct Node* newNode = createNode(value);

    if (newNode == NULL) {

        return head;

    }

    if (head == NULL) {

        head = newNode;

    } else {

        struct Node* current = head;

        while (current-&gt;next != NULL) {

            current = current-&gt;next;

        }

        current-&gt;next = newNode;

    }

    return head;

}



</code></pre>
    <p>
     尾部插入时，若链表为空（ head 为 NULL ），直接将新节点赋值给 head ，新节点成为链表唯一节点。若链表不为空，通过循环遍历找到链表最后一个节点（即 current-&gt;next 为 NULL 的节点），然后将最后一个节点的 next 指针指向新节点，完成添加。
    </p>
    <p>
    </p>
    <h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9" name="%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">
     <span style="color:#956fe7">
      （三）删除节点
     </span>
    </h3>
    <p>
    </p>
    <p>
     删除节点操作相对复杂，需先找到要删除节点的前一个节点，再修改其指针，绕过要删除的节点。
    </p>
    <p>
     <br/>
    </p>
    <pre><code class="language-cpp">c

// 删除指定值节点的函数

struct Node* deleteNode(struct Node* head, int value) {

    if (head == NULL) {

        return head;

    }

    if (head-&gt;data == value) {

        struct Node* temp = head;

        head = head-&gt;next;

        free(temp);

        return head;

    }

    struct Node* current = head;

    while (current-&gt;next != NULL &amp;&amp; current-&gt;next-&gt;data != value) {

        current = current-&gt;next;

    }

    if (current-&gt;next != NULL) {

        struct Node* temp = current-&gt;next;

        current-&gt;next = current-&gt;next-&gt;next;

        free(temp);

    }

    return head;

}



</code></pre>
    <p>
     首先判断链表是否为空，若为空则直接返回 head 。若头节点数据是要删除的值，用临时指针 temp 保存头节点，更新 head 为头节点的下一个节点，释放 temp 指向的头节点内存，返回新的 head 。若要删除的节点不是头节点，通过循环找到其前一个节点 current 。若找到要删除的节点，用临时指针 temp 保存，将 current 的 next 指针指向要删除节点的下一个节点，绕过该节点，最后释放 temp 指向节点的内存。
    </p>
    <p>
    </p>
    <h3 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8" name="%EF%BC%88%E5%9B%9B%EF%BC%89%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8">
     <span style="color:#956fe7">
      （四）遍历链表
     </span>
    </h3>
    <p>
    </p>
    <p>
     遍历链表是访问每个节点数据的过程，通常用循环结构实现。
    </p>
    <pre><code class="language-cpp">c

// 遍历链表并打印节点数据的函数

void traverseList(struct Node* head) {

    struct Node* current = head;

    while (current != NULL) {

        printf("%d -&gt; ", current-&gt;data);

        current = current-&gt;next;

    }

    printf("NULL\n");

}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <blockquote>
     <p>
      此函数中，定义指针 current 并初始化为 head ，通过 while 循环，只要 current 不为 NULL ，就打印当前节点数据，并将 current 移到下一个节点。当 current 为 NULL 时，说明遍历到链表末尾，打印“NULL”表示结束。
     </p>
    </blockquote>
    <p>
    </p>
    <h2 id="%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" name="%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">
     四、链表的优势与应用场景
    </h2>
    <p>
    </p>
    <h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E5%8A%BF" name="%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E5%8A%BF">
     （一）优势
    </h3>
    <p>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       动态内存分配：
      </span>
     </strong>
     链表无需预先知晓数据数量，可根据实际需求随时动态分配和释放内存。而数组声明时就需确定大小，灵活性不足。
    </p>
    <p>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       高效的插入和删除：
      </span>
     </strong>
     在已知插入或删除位置的情况下，链表插入和删除节点的时间复杂度为O(1)，数组进行相同操作可能需移动大量元素，时间复杂度较高。
    </p>
    <p>
    </p>
    <h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" name="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">
     （二）应用场景
    </h3>
    <p>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       操作系统进程调度：
      </strong>
     </span>
     操作系统管理多个进程时，链表可维护进程的就绪队列、阻塞队列等，便于进程的插入、删除和调度。
    </p>
    <p>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       哈希表冲突解决：
      </strong>
     </span>
     哈希表发生冲突时，常使用链表解决，将哈希值相同的元素存储在链表中。
    </p>
    <p>
    </p>
    <p>
     <span style="color:#956fe7">
      <strong>
       图的邻接表存储：
      </strong>
     </span>
     在图的存储结构中，邻接表常用链表表示每个顶点的邻接顶点，方便呈现图的复杂结构。
    </p>
    <p>
    </p>
    <p>
     <em>
      链表作为C语言编程中不可或缺的数据结构，熟练掌握其操作，对提升编程能力和解决实际问题意义重大。希望通过本文，大家能对链表有更深刻的理解与掌握，在编程之路上更进一步。
     </em>
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6e706c706c75732f:61727469636c652f64657461696c732f313436313036323138" class_="artid" style="display:none">
 </p>
</div>


