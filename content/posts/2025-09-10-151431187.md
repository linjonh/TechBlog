---
layout: post
title: "华清远见25072班网络编程学习day3"
date: 2025-09-10T21:35:59+0800
description: "程序源码：#define SER_IP &quot;192.168.109.15&quot;    //服务器ｉｐ地址#define SER_PORT 8888               //服务器端口号#define CLI_IP &quot;192.168.153.128&quot;     //客户端ｉｐ地址#define CLI_PORT 7777               //客户端端口号//1.创建用于通信的套接字文件描述符return -1;"
keywords: "华清远见25072班网络编程学习day3"
categories: ['未分类']
tags: ['基于Udp的Tftp文件传输', 'Tcp']
artid: "151431187"
arturl: "https://blog.csdn.net/Nuyoah11klay/article/details/151431187"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151431187
    alt: "华清远见25072班网络编程学习day3"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151431187
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151431187
cover: https://bing.ee123.net/img/rand?artid=151431187
image: https://bing.ee123.net/img/rand?artid=151431187
img: https://bing.ee123.net/img/rand?artid=151431187
---



# 华清远见25072班网络编程学习day3

## 作业：

### 项目1-->机械臂：

![](https://i-blog.csdnimg.cn/direct/b30c98e510024a2d9b21dee5be0b0988.png)

程序源码：

> #include<25072head.h>  
> #define SER_IP "192.168.109.15"    //服务器ｉｐ地址  
> #define SER_PORT 8888               //服务器端口号  
> #define CLI_IP "192.168.153.128"     //客户端ｉｐ地址  
> #define CLI_PORT 7777               //客户端端口号
>
> int main(int argc, const char *argv[])  
> {  
>     //1.创建用于通信的套接字文件描述符  
>     int cfd = socket(AF_INET, SOCK_STREAM, 0);  
>     if(cfd == -1)  
>     {  
>         perror("socket error");  
>         return -1;  
>     }
>
>     //将套接字重新设置属性，让端口号快速重用  
>     int reuse = 1;  
>     if(setsockopt(cfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse))==-1)  
>     {  
>         perror("setsockopt error");  
>         return -1;  
>     }  
>     printf("端口号已经快速重用\n");  
>     //延迟关闭从而能重新运行  
>     struct linger reuse1 = {1,0};  
>     if(setsockopt(cfd, SOL_SOCKET, SO_LINGER, &reuse1, sizeof(reuse1))==-1)  
>     {  
>         perror("setsockopt error");  
>         return -1;  
>     }  
>     printf("延迟关闭已经使用\n");
>
>     //2.给客户端套接字绑定ip地址和端口号（可选）  
>     //2.1 填充地址信息结构体  
>     struct sockaddr_in cin;  
>     cin.sin_family = AF_INET;   
>     cin.sin_addr.s_addr = inet_addr(CLI_IP);  
>     cin.sin_port = htons(CLI_PORT);  
>     //2.2 绑定  
>     if(bind(cfd, (struct sockaddr*)&cin, sizeof(cin))==-1)  
>     {  
>         perror("bind error");  
>         return -1;  
>     }  
>     //3.连接服务器  
>     //3.1 组装对端地址信息结构体  
>     struct sockaddr_in sin;  
>     sin.sin_family = AF_INET;    //通信域  
>     sin.sin_addr.s_addr = inet_addr(SER_IP);   //要连接的服务器ip  
>     sin.sin_port = htons(SER_PORT);     //服务器的端口号  
>     //3.2 连接操作  
>     if(connect(cfd, (struct sockaddr*)&sin, sizeof(sin))==-1)  
>     {  
>         perror("connect error");  
>         close(cfd);  
>         return -1;  
>     }
>
>     char rbuf[5] = {0xff, 0x02, 0x00, 0x10, 0xff};             //红色臂初始角度  
>     unsigned char bbuf[5] = {0xff, 0x02, 0x01, 0x10, 0xff};     //蓝色臂初始角度
>
>     //将上面的数据分别发送给服务器  
>     send(cfd, rbuf, sizeof(rbuf), 0);  
>     send(cfd, bbuf, sizeof(bbuf), 0);
>
>     //4.数据通信  
>     char buf[128] = "";  
>     while(1)  
>     {  
>         //从终端输入要发送的消息  
>         fgets(buf,sizeof(buf),stdin);  
>         buf[strlen(buf)-1]=0;  
>         //判断输入内容  
>         if(strcmp(buf,"w")==0)  
>         {  
>             rbuf[3]+=10;  
>             send(cfd, rbuf, sizeof(rbuf), 0);  
>         }  
>         if(strcmp(buf,"s")==0)  
>         {  
>             rbuf[3]-=10;  
>             send(cfd, rbuf, sizeof(rbuf), 0);  
>         }  
>         if(strcmp(buf,"a")==0)  
>         {  
>             bbuf[3]-=10;  
>             send(cfd, bbuf, sizeof(bbuf), 0);  
>         }  
>         if(strcmp(buf,"d")==0)  
>         {  
>             bbuf[3]+=10;  
>             send(cfd, bbuf, sizeof(bbuf), 0);  
>         }  
>         if(strcmp(buf,"quit")==0)  
>         {  
>             break;  
>         }
>
>     }  
>     //5.关闭套接字  
>     close(cfd);  
>       
>     return 0;  
> }

### 项目2-->基于UDP的TFTP文件传输：

![](https://i-blog.csdnimg.cn/direct/18619665c4564bb495d56cb97f668c60.png)

![](https://i-blog.csdnimg.cn/direct/d6e751c261f74e988d53bcd01dbf7fe8.png)

程序源码：

> #include<25072head.h>
>
> #define SER_IP "192.168.109.15"    //服务器ｉｐ  
> #define SER_PORT 69          //服务器端口号  
> #define CLI_IP "192.168.153.128"     //客户端ｉｐ  
> #define CLI_PORT 6666 //客户端端口号
>
> int main(int argc, const char *argv[])  
> {  
>     //1、创建一个用于通信的套接字文件描述符  
>     int cfd = socket(AF_INET, SOCK_DGRAM, 0);  
>     if(cfd == -1)  
>     {  
>         perror("socket error");  
>         return -1;  
>     }
>
>     /*２、绑定ｉｐ和端口号（可选）  
>     struct sockaddr_in cin;  
>     cin.sin_family = AF_INET;  
>     cin.sin_addr.s_addr = inet_addr(CLI_IP);  
>     cin.sin_port = htons(CLI_PORT);  
>     if(bind(cfd, (struct sockaddr*)&cin, sizeof(cin))==-1)  
>     {  
>         perror("bind error");  
>         return -1;  
>     }*/
>
>     //３、数据收发  
>     struct sockaddr_in sin;     //目标地址  
>     sin.sin_family = AF_INET;  
>     sin.sin_port = htons(SER_PORT);  
>     sin.sin_addr.s_addr = inet_addr(SER_IP);  
>     socklen_t addrlen = sizeof(sin);
>
>     //向服务器发送一个下载请求  
>     char msgbuf[516] = "";
>
>     //组装协议  
>     //１、组装操作码，下载请求的操作码为１  
>     short *p1 = (short *)msgbuf;  
>     *p1 = htons(1);           //网络字节序，因为是２字节无符号整数
>
>     //2、将要下载的文件名放入  
>     char filename[20] = "";  
>     printf("请输入要下载的文件名：");  
>     fgets(filename, sizeof(filename), stdin);  
>     filename[strlen(filename)-1] = 0;
>
>     //封装到协议中  
>     char *p2 = msgbuf+2;         //跳过前两个字节  
>     strcpy(p2, filename);
>
>     //3、将传输模式放入协议中  
>     char *p4 = p2+strlen(p2)+1;  
>     strcpy(p4, "octet");
>
>     int size = 2+strlen(p2)+strlen(p4)+2;
>
>     //将请求数据包发送给服务器  
>     sendto(cfd, msgbuf, size, 0, (struct sockaddr*)&sin, sizeof(sin));
>
>     //以只写的形式打开一个名为filename的文件  
>     int fd=-1;  
>     if((fd=open(filename,O_CREAT|O_WRONLY,0664))==-1)  
>     {  
>         perror("open error");  
>         return -1;  
>     }
>
>     while(1)  
>     {  
>         //通过recvfrom接受服务器传来的消息包  
>         int len;  
>         if((len=recvfrom(cfd,msgbuf,sizeof(msgbuf),0,(struct sockaddr*)&sin,&addrlen))==-1)  
>         {  
>             perror("recvfrom error");  
>             return -1;  
>         }  
>         //解析传来的消息报中的前两字节  
>         short x=ntohs(*(short*)msgbuf);  
>         //判断如果前两字节的值为５，说明传过来的是错误消息包  
>         if(x==5)  
>         {  
>             printf("[error-%d]:%s\n",ntohs(*(msgbuf+2)),msgbuf+4);  
>         }
>
>         //如果前两字节的值为３，则说明传来的是数据信息  
>         else if(x==3)  
>         {  
>             //判断消息包的四个字节后的数据长度是否为512  
>             //如果是将消息包的4个字节后的数据，写入到文件中  
>             if(len==516)  
>             {  
>                 write(fd,msgbuf+4,512);  
>                 //并回复一个:确认包
>
>                 //判断消息包的４字节后的数据长度是否为５１２，如果是  
>                 //将消息包的４字节后的数据，写入到文件中  
>                 //并且回复一个４字节确认包  
>                 short *p = (short *)msgbuf;  
>                 *p = htons(4);  
>                 sendto(cfd, msgbuf, 4, 0, (struct sockaddr*)&sin, sizeof(sin));      
>             }
>
>             //如果消息包的４字节后的长度为小于５１２  
>             if(len<516)  
>             {  
>                 //将最后的数据写入到文件中，回复一个确认包，结束循环  
>                 write(fd,msgbuf+4,len-4);  
>                 short *p=(short *)msgbuf;  
>                 *p=htons(4);  
>                 sendto(cfd,msgbuf,4,0,(struct sockaddr*)&sin,sizeof(sin));  
>                 printf("文件下载完成\n");  
>                 break;  
>             }  
>         }  
>     }  
>     //４、关闭套接字  
>     close(cfd);  
>     close(fd);  
>     return 0;  
> }



