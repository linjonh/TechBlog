---
layout: post
title: "Unity自定义渲染管线Scriptable-Render-Pipeline架构设计与实现指南"
date: 2025-03-06 14:16:26 +0800
description: "全托管渲染控制：通过C#脚本完全掌控渲染流程模块化架构：将渲染流程拆分为可组合的RenderPassGPU友好设计：支持CommandBuffer与Compute Shader混合编程对惹，这里有一个游戏开发交流小组，希望大家可以点击进来一起交流一下开发经验呀。"
keywords: "Unity自定义渲染管线（Scriptable Render Pipeline）架构设计与实现指南"
categories: ['未分类']
tags: ['游戏引擎', 'Unity']
artid: "146069573"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146069573
    alt: "Unity自定义渲染管线Scriptable-Render-Pipeline架构设计与实现指南"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146069573
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146069573
cover: https://bing.ee123.net/img/rand?artid=146069573
image: https://bing.ee123.net/img/rand?artid=146069573
img: https://bing.ee123.net/img/rand?artid=146069573
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity自定义渲染管线（Scriptable Render Pipeline）架构设计与实现指南
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一、SRP技术体系概述
    </h3>
    <h4>
     1. 核心设计理念
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        全托管渲染控制
       </strong>
       ：通过C#脚本完全掌控渲染流程
      </p>
     </li>
     <li>
      <p>
       <strong>
        模块化架构
       </strong>
       ：将渲染流程拆分为可组合的RenderPass
      </p>
     </li>
     <li>
      <p>
       <strong>
        GPU友好设计
       </strong>
       ：支持CommandBuffer与Compute Shader混合编程
      </p>
     </li>
     <li>
      <strong>
       对惹，这里有一
      </strong>
      <a href="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=IqUxZnxrxs99GLIgMaDDkrLQZj-lDkzo&amp;authKey=QkRlObO4dPdZs8r2UVfgwE%2FjwrqE8AHKau8C1cH7RnbSGjhFMwuPPj0cjuEgg4nn&amp;noverify=0&amp;group_code=411232577" rel="nofollow" title="个游戏开发交流小组">
       个游戏开发交流小组
      </a>
      <strong>
       ，希望大家可以点击进来一起交流一下开发经验呀
      </strong>
     </li>
    </ul>
    <h4>
     2. 与传统管线对比
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        内置管线
       </th>
       <th>
        SRP
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        流程控制
       </td>
       <td>
        黑盒模式
       </td>
       <td>
        全脚本可编程
       </td>
      </tr>
      <tr>
       <td>
        渲染策略
       </td>
       <td>
        固定前向/延迟
       </td>
       <td>
        自由组合多Pass
       </td>
      </tr>
      <tr>
       <td>
        性能优化
       </td>
       <td>
        有限批处理
       </td>
       <td>
        深度控制资源生命周期
       </td>
      </tr>
      <tr>
       <td>
        跨平台支持
       </td>
       <td>
        自动适配
       </td>
       <td>
        需手动实现变体
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     二、核心架构设计
    </h3>
    <h4>
     1. 分层架构图
    </h4>
    <pre>graph TB
    A[SRP Asset] --&gt;|配置参数| B[RenderPipeline]
    B --&gt;|调度| C[CameraRenderer]
    C --&gt;|组织| D[RenderPass]
    D --&gt;|执行| E[CommandBuffer]
    E --&gt;|提交| F[GPU]</pre>
    <h4>
     2. 核心组件职责
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        SRP Asset
       </strong>
       ：管线全局配置（质量等级、Shader变体等）
      </p>
     </li>
     <li>
      <p>
       <strong>
        RenderPipeline
       </strong>
       ：主入口类，负责每帧调度
      </p>
     </li>
     <li>
      <p>
       <strong>
        CameraRenderer
       </strong>
       ：单相机渲染流程控制器
      </p>
     </li>
     <li>
      <p>
       <strong>
        RenderPass
       </strong>
       ：最小渲染单元（如阴影Pass、光照Pass）
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     三、基础管线实现
    </h3>
    <h4>
     1. SRP Asset创建
    </h4>
    <pre>[CreateAssetMenu(menuName = "Rendering/Custom RP")]
public class CustomRenderPipelineAsset : RenderPipelineAsset {
    public bool useDynamicBatching = true;
    public bool useGPUInstancing = true;
    
    protected override RenderPipeline CreatePipeline() {
        return new CustomRenderPipeline(this);
    }
}</pre>
    <h4>
     2. 主渲染管线类
    </h4>
    <pre>public class CustomRenderPipeline : RenderPipeline {
    private CameraRenderer renderer = new CameraRenderer();
    private bool useDynamicBatching;
    private bool useGPUInstancing;

    public CustomRenderPipeline(CustomRenderPipelineAsset asset) {
        useDynamicBatching = asset.useDynamicBatching;
        useGPUInstancing = asset.useGPUInstancing;
    }

    protected override void Render(
        ScriptableRenderContext context, 
        Camera[] cameras
    ) {
        foreach (var camera in cameras) {
            renderer.Render(context, camera, useDynamicBatching, useGPUInstancing);
        }
    }
}</pre>
    <h4>
     3. 相机渲染器
    </h4>
    <pre>public class CameraRenderer {
    static ShaderTagId unlitShaderTagId = new ShaderTagId("SRPDefaultUnlit");
    
    public void Render(
        ScriptableRenderContext context, 
        Camera camera,
        bool useDynamicBatching,
        bool useGPUInstancing
    ) {
        // 设置相机矩阵
        context.SetupCameraProperties(camera);
        
        // 清除渲染目标
        var cmd = new CommandBuffer { name = camera.name };
        cmd.ClearRenderTarget(true, true, Color.clear);
        context.ExecuteCommandBuffer(cmd);
        cmd.Clear();
        
        // 物体排序与绘制
        var sortingSettings = new SortingSettings(camera) {
            criteria = SortingCriteria.CommonOpaque
        };
        var drawingSettings = new DrawingSettings(
            unlitShaderTagId, 
            sortingSettings
        ) {
            enableDynamicBatching = useDynamicBatching,
            enableInstancing = useGPUInstancing
        };
        
        // 执行绘制
        var filterSettings = new FilteringSettings(RenderQueueRange.opaque);
        context.DrawRenderers(
            cullingResults, ref drawingSettings, ref filterSettings
        );
        
        context.Submit();
    }
}</pre>
    <hr/>
    <h3>
     四、高级渲染功能实现
    </h3>
    <h4>
     1. 多Pass渲染架构
    </h4>
    <pre>public class LightingPass : ScriptableRenderPass {
    public override void Configure(
        CommandBuffer cmd, 
        RenderTextureDescriptor cameraTextureDescriptor
    ) {
        // 创建临时RT
        cmd.GetTemporaryRT(
            Shader.PropertyToID("_LightBuffer"),
            1024, 1024, 24, FilterMode.Bilinear
        );
    }

    public override void Execute(
        ScriptableRenderContext context, 
        ref RenderingData renderingData
    ) {
        // 绘制光照几何体
        cmd.DrawMesh(lightMesh, matrix, lightMaterial);
        context.ExecuteCommandBuffer(cmd);
    }

    public override void FrameCleanup(CommandBuffer cmd) {
        // 释放临时RT
        cmd.ReleaseTemporaryRT(Shader.PropertyToID("_LightBuffer"));
    }
}</pre>
    <h4>
     2. 延迟渲染路径实现
    </h4>
    <h5>
     G-Buffer生成Shader
    </h5>
    <pre>struct GBufferOutput {
    float4 albedo   : SV_Target0; // RGB:BaseColor, A:Smoothness
    float4 normal   : SV_Target1; // RGB:WorldNormal, A:Metallic
    float4 emission : SV_Target2; // RGB:Emission, A:Occlusion
};

GBufferOutput FragGBuffer(Varyings input) {
    GBufferOutput output;
    // 采样材质属性...
    output.albedo = float4(baseColor, smoothness);
    output.normal = float4(normalWS * 0.5 + 0.5, metallic);
    output.emission = float4(emission, occlusion);
    return output;
}</pre>
    <h5>
     光照计算Pass
    </h5>
    <pre>public class DeferredLightingPass : ScriptableRenderPass {
    private Material lightingMat;
    
    public override void Execute(...) {
        // 设置G-Buffer纹理
        cmd.SetGlobalTexture("_AlbedoBuffer", albedoRT);
        cmd.SetGlobalTexture("_NormalBuffer", normalRT);
        
        // 全屏四边形绘制光照
        cmd.DrawProcedural(
            Matrix4x4.identity, lightingMat, 0,
            MeshTopology.Triangles, 3, 1
        );
    }
}</pre>
    <hr/>
    <h3>
     五、性能优化技术
    </h3>
    <h4>
     1. SRP Batcher优化
    </h4>
    <pre>// Shader中声明PerObject数据
CBUFFER_START(UnityPerMaterial)
float4 _BaseColor;
float _Metallic;
CBUFFER_END

// C#端启用SRP Batcher
GraphicsSettings.useScriptableRenderPipelineBatching = true;</pre>
    <h4>
     2. GPU Driven Rendering
    </h4>
    <pre>ComputeBuffer argsBuffer = new ComputeBuffer(
    5, sizeof(uint), ComputeBufferType.IndirectArguments
);

// 通过Compute Shader生成绘制参数
computeShader.Dispatch(kernel, groupCount, 1, 1);

// 间接绘制
cmd.DrawMeshInstancedIndirect(
    mesh, 0, material, bounds, argsBuffer
);</pre>
    <h4>
     3. 多线程渲染支持
    </h4>
    <pre>// 创建并行上下文
var renderThread = new RenderThread();
renderThread.Start();

// 提交渲染任务
renderThread.Schedule(() =&gt; {
    context.SetupCameraProperties(camera);
    context.DrawRenderers(...);
    context.Submit();
});</pre>
    <hr/>
    <h3>
     六、实战案例：卡通渲染管线
    </h3>
    <h4>
     1. 架构设计
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        功能模块
       </th>
       <th>
        技术方案
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        轮廓描边
       </td>
       <td>
        法线扩展+深度检测
       </td>
      </tr>
      <tr>
       <td>
        色阶着色
       </td>
       <td>
        颜色量化+LUT映射
       </td>
      </tr>
      <tr>
       <td>
        高光处理
       </td>
       <td>
        各向异性高光模型
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     2. 关键Shader代码
    </h4>
    <pre>// 轮廓Pass
Pass {
    Cull Front
    HLSLPROGRAM
    float _OutlineWidth;
    
    Varyings VertOutline(Varyings input) {
        float3 normal = input.normal * _OutlineWidth;
        input.positionOS += normal;
        return input;
    }
    ENDHLSL
}

// 色阶处理
float3 QuantizeColor(float3 color) {
    float levels = 3.0;
    return floor(color * levels) / levels;
}</pre>
    <hr/>
    <h3>
     七、调试与优化工具
    </h3>
    <h4>
     1. 帧调试器扩展
    </h4>
    <pre>[MenuItem("Custom RP/Debug/Show Light Count")]
static void ToggleLightCountDebug() {
    Shader.EnableKeyword("_DEBUG_LIGHT_COUNT");
}</pre>
    <h4>
     2. 性能分析标记
    </h4>
    <pre>using (new ProfilingScope(cmd, 
    new ProfilingSampler("Lighting Pass"))) 
{
    // 光照计算代码...
}</pre>
    <hr/>
    <h3>
     八、完整项目参考
    </h3>
    <p>
     <a href="https://www.bycwedu.com/promotion_channels/1421254306" rel="nofollow" title="Unlit渲染管线全流程详解">
      Unlit渲染管线全流程详解
     </a>
    </p>
    <hr/>
    <p>
     通过自定义渲染管线，开发者可突破Unity默认渲染的限制，实现从移动端到主机的全平台优化方案。核心在于：1) 合理设计RenderPass执行顺序；2) 利用CommandBuffer精细控制GPU资源；3) 结合Compute Shader实现GPU Driven架构。建议将常用渲染功能（如阴影、后处理）模块化封装，便于不同项目间复用。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f766f6964696e69742f:61727469636c652f64657461696c732f313436303639353733" class_="artid" style="display:none">
 </p>
</div>


