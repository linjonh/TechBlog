---
layout: post
title: "蓝桥杯备考图论之Prim算法"
date: 2025-03-16 19:18:54 +0800
description: "Prim算法，我们从任意一个结点开始构造最小生成树，先把离生成树最近的点拉进来，然后更新所有结点距离生成树的距离，然后再拉进来最近的点，然后再更新所有结点到这颗生成树的距离，一直到所有结点全部拉进来的时候，我们的算法就结束了。比如这张图，当我们用prim算法把2，1，5，4都加到生成树里的时候，3这个结点距离生成树的值还是无穷，就说明他不连通，没法找最小生成树。通过我们前面的学习，我们知道了，一个具有n个顶点的连通图，它的生成树包括n-1个边，如果边多一条就会变成图，少一条就不连通了。"
keywords: "蓝桥杯备考：图论之Prim算法"
categories: ['未分类']
tags: ['算法', '图论']
artid: "146298438"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146298438
    alt: "蓝桥杯备考图论之Prim算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146298438
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146298438
cover: https://bing.ee123.net/img/rand?artid=146298438
image: https://bing.ee123.net/img/rand?artid=146298438
img: https://bing.ee123.net/img/rand?artid=146298438
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥杯备考：图论之Prim算法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     嗯。通过我们前面的学习，我们知道了，一个具有n个顶点的连通图，它的生成树包括n-1个边，如果边多一条就会变成图，少一条就不连通了
    </p>
    <p>
     接下来我们来学一下把图变成生成树的一个算法
    </p>
    <p>
     Prim算法，我们从任意一个结点开始构造最小生成树，先把离生成树最近的点拉进来，然后更新所有结点距离生成树的距离，然后再拉进来最近的点，然后再更新所有结点到这颗生成树的距离，一直到所有结点全部拉进来的时候，我们的算法就结束了
    </p>
    <p>
     这里我们需要开两个数组，一个是dist数组来判断某个点距离生成树的距离，另一个是st数组，来判断某个点在不在生成树里
    </p>
    <p>
     <img alt="" height="226" src="https://i-blog.csdnimg.cn/direct/8458bde9a6d04871a9f99ff61e89a812.png" width="620"/>
    </p>
    <p>
     如图，我们把起始点加入进去了，接下来我们更新一下所有点离最小生成树的距离
     <img alt="" height="233" src="https://i-blog.csdnimg.cn/direct/8acbaa20063f405cbbd532d17bb5cf05.png" width="617"/>
    </p>
    <p>
     我们还是找距离生成树最近的结点，如图，是5，我们把5拉进去
     <img alt="" height="588" src="https://i-blog.csdnimg.cn/direct/73e6799cbe6542798b02d0638a4cedde.png" width="1408"/>
    </p>
    <p>
     接下来把5标记上，然后更新所有点距离最小生成树的距离
     <img alt="" height="275" src="https://i-blog.csdnimg.cn/direct/0b4ffa6f03264e0fb219fe1b22c32c37.png" width="642"/>
    </p>
    <p>
     然后继续找最小的，应该是2结点了
     <img alt="" height="273" src="https://i-blog.csdnimg.cn/direct/b29895490a6c44bc91f99a92ca61460e.png" width="659"/>
    </p>
    <p>
     把2结点拉进去之后，我们再次更新dist数组，....如此往复，直到所有点都遍历完之后，我们的最小生成树也就构建完了；
    </p>
    <p>
     话不多说我们来实现一下代码
    </p>
    <p>
     我们先来实现一下邻接矩阵的代码；
    </p>
    <p>
     <img alt="" height="1077" src="https://i-blog.csdnimg.cn/direct/6fccb2cad1f942cab3eb15d9ca76563a.png" width="1178"/>
    </p>
    <p>
     这道题我们还要考虑一下连通不连通的情况
    </p>
    <p>
     <img alt="" height="457" src="https://i-blog.csdnimg.cn/direct/7106aa9737b94013889ccf1980997f39.png" width="664"/>
    </p>
    <p>
     比如这张图，当我们用prim算法把2，1，5，4都加到生成树里的时候，3这个结点距离生成树的值还是无穷，就说明他不连通，没法找最小生成树
    </p>
    <p>
     下面就是我们的代码
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 5010;
const int INF = 0x3f3f3f3f;
int dist[N];
bool st[N];
int edges[N][N];
int n, m;
int ret = 0;
int prim()
{
	dist[1] = 0;
	for (int i = 1; i &lt;= n; i++)//循环把n个结点加入到生成树里面 
	{
		//1.找最近点
		int t = 0;
		for (int j = 1; j &lt;= n; j++)
		{
			if (dist[j] &lt; dist[t] &amp;&amp; !st[j])
			{
				t = j;
			}
		}
		if (dist[t] == INF) return INF;//不连通
		//把最小结点加入到生成树里
		st[t] = true;
		ret += dist[t];
		//更新所有结点离最小生成树的距离
		for (int i = 1; i &lt;= n; i++)
		{
			dist[i] = min(dist[i], edges[t][i]);
		}
	}
	return ret;
}
int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	memset(dist, 0x3f, sizeof(dist));
	memset(edges, 0x3f, sizeof(edges));
	for (int i = 1; i &lt;= m; i++)
	{
		int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
		edges[a][b] = edges[b][a] = min(edges[a][b],c);
	}
	ret = prim();
	if (ret == INF) cout &lt;&lt; "orz" &lt;&lt; endl;
	else cout &lt;&lt; ret &lt;&lt; endl;





	return 0;
}</code></pre>
    <p>
     接下来，我们用邻接表实现一下这道题
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 5010, INF = 0x3f3f3f3f;
vector &lt;PII&gt; path[N];
int dist[N];
bool st[N];
int ret = 0;
int n, m;
int prim()
{
	dist[1] = 0;
	for (int i = 1; i &lt;= n; i++)
	{
		int t = 0;
		for (int j = 1; j &lt;= n; j++)
		{
			if (dist[t] &gt; dist[j] &amp;&amp; !st[j])
			{
				t = j;
			}
		}
		if (dist[t] == INF) return INF;
		st[t] = true;
		ret += dist[t];
		for (auto &amp;e : path[t])
		{
			int x = e.first, y = e.second;
			dist[x] = min(dist[x], y);
		}
	}
	return ret;
}
int main()
{
	memset(dist, 0x3f, sizeof(dist));
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= m; i++)
	{
		int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
		path[x].push_back({ y,z });
		path[y].push_back({ x,z });
	}
	int r = prim();
	if (r == INF) cout &lt;&lt; "orz" &lt;&lt; endl;
	else cout &lt;&lt; r &lt;&lt; endl;






	return 0;
}</code></pre>
    <p>
     根据我们的代码可以看到，我们的prim算法时间复杂度是N²，如果结点很少边很多的话，我们用prim算法最合适
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313737323234392f:61727469636c652f64657461696c732f313436323938343338" class_="artid" style="display:none">
 </p>
</div>


