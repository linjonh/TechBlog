---
layout: post
title: "C-WPF-基础知识学习三"
date: 2025-03-13 11:10:29 +0800
description: "Windows Presentation Foundation（WPF）是微软为开发 Windows 桌面应用程序而推出的一个 UI 框架。它引入了许多先进的技术和概念，如基于矢量图形的渲染、数据绑定、样式和模板等，使得开发者能够创建出具有丰富视觉效果和交互性的应用程序。与传统的 Windows Forms 相比，WPF 更加注重用户体验和界面设计的灵活性。XAML 是一种基于 XML 的标记语言，用于描述 WPF 应用程序的用户界面。"
keywords: "xceed.wpf.toolkit propertygrid wpf"
categories: ['未分类']
tags: ['计算机视觉', '神经网络', '学习', '人工智能', 'Wpf', 'C']
artid: "146225633"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146225633
    alt: "C-WPF-基础知识学习三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146225633
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146225633
cover: https://bing.ee123.net/img/rand?artid=146225633
image: https://bing.ee123.net/img/rand?artid=146225633
img: https://bing.ee123.net/img/rand?artid=146225633
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C# WPF 基础知识学习(三)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一、WPF 概述
    </h3>
    <p>
     <img alt="" height="600" src="https://i-blog.csdnimg.cn/direct/2d5bb260b23345aca1221e45131e57c2.png" width="1000"/>
    </p>
    <h4>
     1.1 什么是 WPF
    </h4>
    <p>
    </p>
    <p>
     Windows Presentation Foundation（WPF）是微软为开发 Windows 桌面应用程序而推出的一个 UI 框架。它引入了许多先进的技术和概念，如基于矢量图形的渲染、数据绑定、样式和模板等，使得开发者能够创建出具有丰富视觉效果和交互性的应用程序。与传统的 Windows Forms 相比，WPF 更加注重用户体验和界面设计的灵活性。
    </p>
    <h4>
     1.2 WPF 的优势
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       声明式编程
      </strong>
      ：通过 XAML（可扩展应用程序标记语言），开发者可以以声明的方式定义界面，将界面设计与业务逻辑分离，提高开发效率和可维护性。
     </li>
     <li>
      <strong>
       强大的图形渲染
      </strong>
      ：基于 DirectX 技术，WPF 能够实现高质量的 2D 和 3D 图形渲染，支持硬件加速，确保复杂图形和动画的流畅显示。
     </li>
     <li>
      <strong>
       数据绑定
      </strong>
      ：提供了强大的数据绑定机制，使得 UI 元素能够自动反映数据源的变化，并且可以双向绑定，方便数据的交互和更新。
     </li>
     <li>
      <strong>
       样式和模板
      </strong>
      ：允许开发者定义统一的样式和模板，实现界面的一致性和复用性，同时可以轻松地定制控件的外观和行为。
     </li>
     <li>
      <strong>
       动画支持
      </strong>
      ：内置了丰富的动画系统，包括线性动画、关键帧动画等，能够创建出生动的用户界面。
     </li>
    </ul>
    <h4>
     1.3 WPF 的应用场景
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       企业级应用
      </strong>
      ：如办公软件、数据分析工具等，需要提供复杂的界面和交互功能，WPF 可以满足这些需求。
     </li>
     <li>
      <strong>
       多媒体应用
      </strong>
      ：视频播放器、音频编辑软件等，利用 WPF 的图形和多媒体处理能力，实现高质量的媒体播放和编辑功能。
     </li>
     <li>
      <strong>
       游戏开发
      </strong>
      ：虽然不是主流的游戏开发平台，但 WPF 可以用于开发一些小型的 2D 游戏，尤其是需要精美的界面和动画效果的游戏。
     </li>
    </ul>
    <h3>
     二、创建 WPF 项目
    </h3>
    <h4>
     2.1 安装开发环境
    </h4>
    <p>
    </p>
    <p>
     要开始开发 WPF 应用程序，需要安装 Visual Studio。可以从微软官方网站下载并安装最新版本的 Visual Studio，在安装过程中选择 “.NET 桌面开发” 工作负载，其中包含了开发 WPF 应用所需的工具和框架。
    </p>
    <h4>
     2.2 创建新的 WPF 项目
    </h4>
    <p>
    </p>
    <ol>
     <li>
      打开 Visual Studio，选择 “创建新项目”。
     </li>
     <li>
      在搜索框中输入 “WPF 应用”，选择适合的项目模板，如 “WPF 应用（.NET Framework）” 或 “WPF 应用（.NET Core）”，根据自己的需求选择。
     </li>
     <li>
      输入项目名称和存储位置，然后点击 “创建” 按钮。
     </li>
    </ol>
    <h4>
     2.3 项目结构
    </h4>
    <p>
    </p>
    <p>
     创建好的 WPF 项目包含以下主要文件和文件夹：
    </p>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       App.xaml 和 App.xaml.cs
      </strong>
      ：App.xaml 是应用程序的入口文件，定义了应用程序的资源和启动设置；App.xaml.cs 是对应的代码文件，包含应用程序的启动逻辑。
     </li>
     <li>
      <strong>
       MainWindow.xaml 和 MainWindow.xaml.cs
      </strong>
      ：MainWindow.xaml 是主窗口的 XAML 文件，用于定义窗口的界面布局和元素；MainWindow.xaml.cs 是对应的代码文件，包含窗口的事件处理和业务逻辑。
     </li>
     <li>
      <strong>
       Properties 文件夹
      </strong>
      ：包含项目的属性设置，如应用程序图标、版本信息等。
     </li>
     <li>
      <strong>
       References 文件夹
      </strong>
      ：列出了项目所引用的程序集，开发者可以根据需要添加或删除引用。
     </li>
    </ul>
    <h3>
     三、XAML 基础
    </h3>
    <h4>
     3.1 XAML 简介
    </h4>
    <p>
    </p>
    <p>
     XAML 是一种基于 XML 的标记语言，用于描述 WPF 应用程序的用户界面。它通过标签和属性的方式来定义界面元素的结构和外观，使得界面设计更加直观和易于理解。
    </p>
    <h4>
     3.2 XAML 语法
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       元素和属性
      </strong>
      ：XAML 中的元素对应于.NET 类型，元素名称通常与类型名称相同。属性用于设置元素的特性，例如：
     </li>
    </ul>
    <pre><code class="language-XML">&lt;Button Content="Click Me" Width="100" Height="30" /&gt;
</code></pre>
    <p>
    </p>
    <p>
     这里的
     <code>
      &lt;Button&gt;
     </code>
     是元素，
     <code>
      Content
     </code>
     、
     <code>
      Width
     </code>
     和
     <code>
      Height
     </code>
     是属性。
    </p>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       嵌套元素
      </strong>
      ：元素可以嵌套在其他元素内部，形成层次结构。例如：
     </li>
    </ul>
    <pre><code class="language-XML">&lt;StackPanel&gt;
    &lt;TextBlock Text="Hello, World!" /&gt;
    &lt;Button Content="OK" /&gt;
&lt;/StackPanel&gt;
</code></pre>
    <p>
    </p>
    <p>
     <code>
      &lt;StackPanel&gt;
     </code>
     是一个容器元素，包含了一个
     <code>
      &lt;TextBlock&gt;
     </code>
     和一个
     <code>
      &lt;Button&gt;
     </code>
     。
    </p>
    <ul>
     <li>
      <strong>
       命名空间
      </strong>
      ：XAML 使用命名空间来引用不同的类型。在每个 XAML 文件的根元素中，通常会定义默认命名空间和其他需要的命名空间。例如：
     </li>
    </ul>
    <pre><code class="language-XML">&lt;Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"&gt;
    &lt;!-- 窗口内容 --&gt;
&lt;/Window&gt;
</code></pre>
    <p>
    </p>
    <p>
     默认命名空间
     <code>
      http://schemas.microsoft.com/winfx/2006/xaml/presentation
     </code>
     包含了 WPF 的核心 UI 元素类型，
     <code>
      xmlns:x
     </code>
     引用的命名空间用于 XAML 语言本身的特性，如
     <code>
      x:Class
     </code>
     用于指定代码隐藏文件中对应的类。
    </p>
    <h4>
     3.3 常用 XAML 元素
    </h4>
    <ul>
     <li>
      <strong>
       布局容器
      </strong>
      <ul>
       <li>
        <strong>
         Grid
        </strong>
        ：将界面划分为行和列的网格，子元素可以通过
        <code>
         Grid.Row
        </code>
        和
        <code>
         Grid.Column
        </code>
        附加属性指定在网格中的位置。例如：
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="language-XML">&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto" /&gt;
        &lt;RowDefinition Height="*" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="*" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;Button Content="Top - Left" Grid.Row="0" Grid.Column="0" /&gt;
    &lt;Button Content="Top - Right" Grid.Row="0" Grid.Column="1" /&gt;
    &lt;Button Content="Bottom - Left" Grid.Row="1" Grid.Column="0" /&gt;
    &lt;Button Content="Bottom - Right" Grid.Row="1" Grid.Column="1" /&gt;
&lt;/Grid&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       StackPanel
      </strong>
      ：按照水平或垂直方向排列子元素，通过
      <code>
       Orientation
      </code>
      属性可以设置排列方向，默认是垂直方向。例如：
     </li>
    </ul>
    <pre><code class="language-XML">&lt;StackPanel Orientation="Horizontal"&gt;
    &lt;Button Content="Button 1" /&gt;
    &lt;Button Content="Button 2" /&gt;
    &lt;Button Content="Button 3" /&gt;
&lt;/StackPanel&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       WrapPanel
      </strong>
      ：子元素会按照指定的方向依次排列，当一行或一列排满时，会自动换行或换列。例如：
     </li>
    </ul>
    <pre><code class="language-XML">&lt;WrapPanel&gt;
    &lt;Button Content="Short Button" /&gt;
    &lt;Button Content="A Longer Button" /&gt;
    &lt;Button Content="Another Button" /&gt;
&lt;/WrapPanel&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       DockPanel
      </strong>
      ：子元素可以停靠在面板的边缘，通过
      <code>
       DockPanel.Dock
      </code>
      附加属性设置停靠位置。例如：
     </li>
    </ul>
    <pre><code class="language-XML">&lt;DockPanel&gt;
    &lt;Button Content="Top" DockPanel.Dock="Top" /&gt;
    &lt;Button Content="Bottom" DockPanel.Dock="Bottom" /&gt;
    &lt;Button Content="Left" DockPanel.Dock="Left" /&gt;
    &lt;Button Content="Right" DockPanel.Dock="Right" /&gt;
    &lt;Button Content="Center" /&gt;
&lt;/DockPanel&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       控件元素
      </strong>
      <ul>
       <li>
        <strong>
         Button
        </strong>
        ：用于触发操作，通过
        <code>
         Content
        </code>
        属性设置按钮显示的文本或其他内容，通过
        <code>
         Click
        </code>
        事件处理按钮的点击操作。
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="language-XML">&lt;Button Content="Submit" Click="Button_Click" /&gt;
</code></pre>
    <p>
    </p>
    <p>
     在后台代码中：
    </p>
    <pre><code>private void Button_Click(object sender, RoutedEventArgs e)
{
    MessageBox.Show("Button clicked!");
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       TextBox
      </strong>
      ：用于输入文本，通过
      <code>
       Text
      </code>
      属性获取或设置文本内容，通过
      <code>
       TextChanged
      </code>
      事件响应文本的变化。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBox TextChanged="TextBox_TextChanged" /&gt;
</code></pre>
    <p>
    </p>
    <p>
     后台代码：
    </p>
    <pre><code>private void TextBox_TextChanged(object sender, TextChangedEventArgs e)
{
    TextBox textBox = (TextBox)sender;
    string text = textBox.Text;
    // 处理文本变化逻辑
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       ComboBox
      </strong>
      ：下拉列表框，用户可以从预定义的选项中选择一个值。通过
      <code>
       ItemsSource
      </code>
      属性绑定数据源，通过
      <code>
       SelectedItem
      </code>
      或
      <code>
       SelectedValue
      </code>
      属性获取当前选中的项。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;ComboBox ItemsSource="{Binding MyItems}" SelectedValue="{Binding SelectedItem}" /&gt;
</code></pre>
    <p>
    </p>
    <p>
     假设在 ViewModel 中定义了
     <code>
      MyItems
     </code>
     集合和
     <code>
      SelectedItem
     </code>
     属性：
    </p>
    <pre><code>public class ViewModel
{
    public ObservableCollection&lt;string&gt; MyItems { get; set; }
    public string SelectedItem { get; set; }

    public ViewModel()
    {
        MyItems = new ObservableCollection&lt;string&gt;() { "Option 1", "Option 2", "Option 3" };
    }
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       CheckBox
      </strong>
      ：复选框控件，用于表示布尔值的选择状态。通过
      <code>
       IsChecked
      </code>
      属性获取或设置复选框的选中状态，通过
      <code>
       Checked
      </code>
      和
      <code>
       Unchecked
      </code>
      事件响应状态变化。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;CheckBox Content="Remember Me" IsChecked="{Binding IsRememberMe}" /&gt;
</code></pre>
    <p>
    </p>
    <p>
     在 ViewModel 中定义
     <code>
      IsRememberMe
     </code>
     属性：
    </p>
    <pre><code>private bool _isRememberMe;
public bool IsRememberMe
{
    get { return _isRememberMe; }
    set
    {
        _isRememberMe = value;
        OnPropertyChanged(nameof(IsRememberMe));
    }
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       RadioButton
      </strong>
      ：单选按钮，一组单选按钮中只能有一个被选中。通过
      <code>
       GroupName
      </code>
      属性将多个单选按钮分组，通过
      <code>
       IsChecked
      </code>
      属性判断是否被选中。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;StackPanel&gt;
    &lt;RadioButton Content="Male" GroupName="Gender" IsChecked="{Binding Gender, Converter={StaticResource GenderConverter}, ConverterParameter=Male}" /&gt;
    &lt;RadioButton Content="Female" GroupName="Gender" IsChecked="{Binding Gender, Converter={StaticResource GenderConverter}, ConverterParameter=Female}" /&gt;
&lt;/StackPanel&gt;
</code></pre>
    <p>
    </p>
    <p>
     这里使用了一个转换器
     <code>
      GenderConverter
     </code>
     来将 ViewModel 中的
     <code>
      Gender
     </code>
     属性值与单选按钮的选中状态进行转换。
    </p>
    <h3>
     四、数据绑定
    </h3>
    <h4>
     4.1 数据绑定的概念
    </h4>
    <p>
     数据绑定是 WPF 的核心特性之一，它建立了 UI 元素（绑定目标）和数据源（绑定源）之间的连接，使得 UI 元素能够自动反映数据源的变化，并且可以将用户在 UI 上的操作反馈到数据源。
    </p>
    <h4>
     4.2 绑定模式
    </h4>
    <ul>
     <li>
      <strong>
       OneWay
      </strong>
      ：数据从绑定源流向绑定目标，当绑定源属性值发生变化时，绑定目标属性会自动更新，但绑定目标的变化不会影响绑定源。常用于显示只读数据的场景，如显示数据库中的记录。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBlock Text="{Binding ReadOnlyProperty, Mode=OneWay}" /&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       TwoWay
      </strong>
      ：数据在绑定源和绑定目标之间双向流动，当绑定源属性值变化时，绑定目标更新；当绑定目标属性值变化时，绑定源也会相应更新。常用于需要用户输入并更新数据的场景，如编辑表单。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBox Text="{Binding EditableProperty, Mode=TwoWay}" /&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       OneTime
      </strong>
      ：数据在初始化时从绑定源流向绑定目标，之后绑定源的变化不会再影响绑定目标。适用于数据在应用程序运行过程中不会改变的情况，如显示应用程序的版本号。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBlock Text="{Binding AppVersion, Mode=OneTime}" /&gt;
</code></pre>
    <h4>
     4.3 实现数据绑定
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       创建数据源
      </strong>
      ：通常会创建一个 ViewModel 类来作为数据源。ViewModel 类应该实现
      <code>
       INotifyPropertyChanged
      </code>
      接口，以便在属性值发生变化时通知绑定目标更新。例如：
     </li>
    </ul>
    <pre><code class="language-cs">public class UserViewModel : INotifyPropertyChanged
{
    private string _name;
    public string Name
    {
        get { return _name; }
        set
        {
            _name = value;
            OnPropertyChanged(nameof(Name));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       设置 DataContext
      </strong>
      ：在窗口或控件的代码隐藏文件中，将 ViewModel 的实例设置为
      <code>
       DataContext
      </code>
      ，这样 XAML 中的绑定就可以找到对应的数据源。
     </li>
    </ul>
    <pre><code class="language-cs">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        UserViewModel viewModel = new UserViewModel();
        DataContext = viewModel;
    }
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       在 XAML 中进行绑定
      </strong>
      ：使用
      <code>
       Binding
      </code>
      标记扩展将 UI 元素的属性绑定到 ViewModel 的属性上。
     </li>
    </ul>
    <pre><code class="language-XML">&lt;TextBox Text="{Binding Name}" /&gt;
</code></pre>
    <h4>
     4.4 绑定到集合
    </h4>
    <p>
     在实际应用中，经常需要将 UI 元素绑定到集合数据上，例如将
     <code>
      ListView
     </code>
     或
     <code>
      ComboBox
     </code>
     绑定到一个
     <code>
      ObservableCollection
     </code>
     。
     <code>
      ObservableCollection
     </code>
     是一个动态集合，当集合中的元素发生添加、删除或修改操作时，会自动通知绑定的 UI 元素进行更新。
    </p>
    <p>
     以下是一个将
     <code>
      ListView
     </code>
     绑定到
     <code>
      ObservableCollection
     </code>
     的示例：
    </p>
    <pre><code class="language-cs">public class EmployeeViewModel
{
    public ObservableCollection&lt;Employee&gt; Employees { get; set; }

    public EmployeeViewModel()
    {
        Employees = new ObservableCollection&lt;Employee&gt;
        {
            new Employee { Name = "John Doe", Age = 30 },
            new Employee { Name = "Jane Smith", Age = 25 },
            new Employee { Name = "Bob Johnson", Age = 35 }
        };
    }
}

public class Employee
{
    public string Name { get; set; }
    public int Age { get; set; }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;DataTemplate x:Key="EmployeeTemplate"&gt;
        &lt;StackPanel Orientation="Horizontal"&gt;
            &lt;TextBlock Text="{Binding Name}" Margin="5" /&gt;
            &lt;TextBlock Text="{Binding Age}" Margin="5" /&gt;
        &lt;/StackPanel&gt;
    &lt;/DataTemplate&gt;
&lt;/Window.Resources&gt;
&lt;ListView ItemsSource="{Binding Employees}" ItemTemplate="{StaticResource EmployeeTemplate}" /&gt;
</code></pre>
    <p>
    </p>
    <p>
     在窗口的代码隐藏文件中设置
     <code>
      DataContext
     </code>
     ：
    </p>
    <pre><code class="language-cs">public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        EmployeeViewModel viewModel = new EmployeeViewModel();
        DataContext = viewModel;
    }
}
</code></pre>
    <h4>
     4.5 数据绑定的其他特性
    </h4>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       绑定转换器
      </strong>
      ：当绑定源和绑定目标的类型不匹配时，或者需要对绑定值进行一些转换时，可以使用绑定转换器。绑定转换器是实现了
      <code>
       IValueConverter
      </code>
      接口的类。例如，将一个布尔值转换为字符串显示：
     </li>
    </ul>
    <pre><code class="language-cs">public class BooleanToStringConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool boolValue)
        {
            return boolValue ? "Yes" : "No";
        }
        return null;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string stringValue)
        {
            return stringValue == "Yes";
        }
        return false;
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中使用转换器：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;local:BooleanToStringConverter x:Key="BooleanToStringConverter" /&gt;
&lt;/Window.Resources&gt;
&lt;TextBlock Text="{Binding IsActive, Converter={StaticResource BooleanToStringConverter}}" /&gt;
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       绑定验证
      </strong>
      ：在用户输入数据时，需要对输入的数据进行验证，确保数据的有效性。WPF 提供了绑定验证机制，可以通过实现
      <code>
       IDataErrorInfo
      </code>
      接口或使用
      <code>
       ValidationRule
      </code>
      类来实现验证。例如，验证一个文本框输入的是否为有效的整数：
     </li>
    </ul>
    <pre><code class="language-cs">public class IntegerValidationRule : ValidationRule
{
    public override ValidationResult Validate(object value, CultureInfo cultureInfo)
    {
        if (int.TryParse(value as string, out _))
        {
            return ValidationResult.ValidResult;
        }
        return new ValidationResult(false, "请输入有效的整数。");
    }
}
</code></pre>
    <p>
    </p>
    <p>
     在 XAML 中应用验证规则：
    </p>
    <pre><code class="language-XML">&lt;Window.Resources&gt;
    &lt;local:IntegerValidationRule x:Key="IntegerValidationRule" /&gt;
&lt;/Window.Resources&gt;
&lt;TextBox&gt;
    &lt;TextBox.Text&gt;
        &lt;Binding Path="Age" UpdateSourceTrigger="PropertyChanged"&gt;
            &lt;Binding.ValidationRules&gt;
                &lt;local:IntegerValidationRule /&gt;
            &lt;/Binding.ValidationRules&gt;
        &lt;/Binding&gt;
    &lt;/TextBox.Text&gt;
&lt;/TextBox&gt;
</code></pre>
    <p>
     当用户输入的不是有效的整数时，文本框会显示验证错误信息。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f34343937353831342f:61727469636c652f64657461696c732f313436323235363333" class_="artid" style="display:none">
 </p>
</div>


