---
layout: post
title: "JVM内存结构笔记01-运行时数据区域"
date: 2025-03-11 22:18:14 +0800
description: "对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++那样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。"
keywords: "JVM内存结构笔记01-运行时数据区域"
categories: ['Jvm']
tags: ['笔记', 'Jvm']
artid: "145683037"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145683037
    alt: "JVM内存结构笔记01-运行时数据区域"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145683037
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145683037
cover: https://bing.ee123.net/img/rand?artid=145683037
image: https://bing.ee123.net/img/rand?artid=145683037
img: https://bing.ee123.net/img/rand?artid=145683037
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM内存结构笔记01-运行时数据区域
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0c18f87fbed543acaab34900fbf522dd.jpeg"/>
    </p>
    <h2>
     <a id="_6">
     </a>
     前言
    </h2>
    <p>
     对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++那样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。
    </p>
    <h2>
     <a id="_9">
     </a>
     运行时数据区域
    </h2>
    <p>
     Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，用于存储程序执行期间所需的各种信息。这些区域可以分为
     <strong>
      线程共享和线程私有
     </strong>
     两种类型。主要有程序计数器、虚拟机栈、本地方法栈、堆、方法区等区域，每个部分承担着不同的功能和角色。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0155059860af4bc79965c7d358641f4c.png"/>
    </p>
    <p>
     JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。
     <br/>
     JDK 1.7
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ef7fb4be3dc046f380af4139a1a0fd88.png"/>
    </p>
    <p>
     JDK1.8
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/51175122afe04739854bdd411b6983af.png">
      <br/>
      线程私有的：
     </img>
    </p>
    <ul>
     <li>
      程序计数器
     </li>
     <li>
      虚拟机栈
     </li>
     <li>
      本地方法栈
     </li>
    </ul>
    <p>
     线程共享的：
    </p>
    <ul>
     <li>
      堆
     </li>
     <li>
      方法区
     </li>
     <li>
      直接内存 (非运行时数据区的一部分)
     </li>
    </ul>
    <p>
     Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。
    </p>
    <h2>
     <a id="1_31">
     </a>
     1.程序计数器
    </h2>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/df98e03f2aff4f01a6b05bb9b31f6448.png"/>
    </p>
    <h3>
     <a id="_33">
     </a>
     定义
    </h3>
    <p>
     Program Counter Register 程序计数器（物理上通过寄存器实现计数功能）
     <br/>
     作用：是记住下一条jvm指令的执行地址
    </p>
    <h3>
     <a id="_37">
     </a>
     特点
    </h3>
    <ul>
     <li>
      是线程私有的(当线程1时间片内没有执行完，下一条指令会保存到程序计数器，切换执行其他线程)
     </li>
     <li>
      程序计数器不会存在内存溢出
      <ul>
       <li>
        程序计数器是唯一不会抛出OutOfMemoryError的内存区域。
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_42">
     </a>
     总结
    </h3>
    <p>
     程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
     <br/>
     另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
    </p>
    <p>
     从上面的介绍中我们知道了程序计数器主要有两个作用：
    </p>
    <ul>
     <li>
      字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
     </li>
     <li>
      在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
     </li>
    </ul>
    <p>
     ⚠️ 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
    </p>
    <h2>
     <a id="2_52">
     </a>
     2.虚拟机栈
    </h2>
    <h3>
     <a id="21__53">
     </a>
     2.1 定义
    </h3>
    <p>
     Java Virtual Machine Stacks （Java 虚拟机栈）
    </p>
    <ul>
     <li>
      JVM 中每个线程运行时需要的内存包括虚拟机栈、程序计数器、本地方法栈等，其中虚拟机栈用于存储方法调用的栈帧。
     </li>
     <li>
      每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
     </li>
     <li>
      每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法
     </li>
    </ul>
    <p>
     与程序计数器一样，Java 虚拟机栈（简称栈）也是
     <strong>
      线程私有
     </strong>
     的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。
    </p>
    <p>
     栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。
    </p>
    <p>
     方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。可以说每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
    </p>
    <p>
     栈由一个个栈帧组成，而每个栈帧中都拥有：
     <strong>
      局部变量表、操作数栈、动态链接、方法返回地址
     </strong>
     。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8bc326afe1b142b981192b5bad32db72.png"/>
    </p>
    <h4>
     <a id="__68">
     </a>
     局部变量表 ★
    </h4>
    <p>
     局部变量表 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4de1b2d364a644059987647ea995857f.png"/>
    </p>
    <ul>
     <li>
      这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。
     </li>
     <li>
      局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
     </li>
     <li>
      注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。
     </li>
    </ul>
    <h4>
     <a id="_75">
     </a>
     操作数栈
    </h4>
    <p>
     操作数栈 是一个后进先出（LIFO）的栈，用于在方法执行过程中进行数据的计算和操作。例如，在执行算术运算时，操作数(临时变量)会被压入操作数栈，计算结果也会从操作数栈中弹出。
    </p>
    <h4>
     <a id="_78">
     </a>
     动态链接
    </h4>
    <p>
     动态链接 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。
     <br/>
     动态链接的作用就是在方法调用时，通过动态链接可以将符号引用转换为调用方法的直接引用，这个过程也被称为 动态连接 。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4410d1a55bc74061abc1291ca471e629.png"/>
    </p>
    <h4>
     <a id="_83">
     </a>
     方法返回地址(方法出口)
    </h4>
    <p>
     记录了方法执行完毕后返回的地址，以便线程能够返回到调用该方法的位置继续执行。
    </p>
    <p>
     栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
    </p>
    <p>
     Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说，
     <strong>
      栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束
     </strong>
     。
    </p>
    <p>
     除了 StackOverFlowError 错误之外，栈还可能会出现OutOfMemoryError错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
    </p>
    <p>
     简单总结一下程序运行中栈可能会出现两种错误：
    </p>
    <ul>
     <li>
      <strong>
       StackOverFlowError
      </strong>
      ： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
     </li>
     <li>
      <strong>
       OutOfMemoryError
      </strong>
      ： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛OutOfMemoryError异常。
     </li>
    </ul>
    <p>
     在《深入理解 Java 虚拟机》第三版中解释到：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d8c2a46643774255859bd51adddb9e48.png"/>
    </p>
    <h3>
     <a id="22__98">
     </a>
     2.2 栈内存溢出
    </h3>
    <ol>
     <li>
      栈帧过多导致栈内存溢出(递归)
      <br/>
      java.lang.stackOverflowError
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a2daf7ee99904b17b1b0b87f92ef46a6.png"/>
     </li>
     <li>
      栈帧过大导致栈内存溢出
     </li>
    </ol>
    <h4>
     <a id="_javalangStackOverflowError_104">
     </a>
     演示栈内存溢出 java.lang.StackOverflowError
    </h4>
    <p>
     通过 -Xss256k 可以设置栈内存大小
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     点击Edit
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e78c479749064fe1b96039dbbda4d5a6.png"/>
     <br/>
     点击Modify options
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/970a2ce0b1fe46249e3b91af7e77a2ae.png"/>
     <br/>
     点击Add VM options
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f4cfc6aa8d234eec92051fc213bdc0c2.png"/>
     <br/>
     输入-Xss256k
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c0c7a37e99f841178c07f942b6e072db.png"/>
     <br/>
     配置后运行发现3816次就会报错java.lang.StackOverflowError
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d45af61d01844a10812911eda5d16d0e.png"/>
    </p>
    <h3>
     <a id="23_137">
     </a>
     2.3问题辨析
    </h3>
    <h4>
     <a id="1__138">
     </a>
     1. 垃圾回收是否涉及栈内存？
    </h4>
    <p>
     不涉及，栈帧内存在调用完后会自动回收掉。
    </p>
    <p>
     详细说明：
    </p>
    <ul>
     <li>
      栈内存：栈内存是线程私有的，用于存储方法调用的栈帧（包括局部变量、操作数栈、动态链接、方法出口等）。栈内存的生命周期与线程绑定，线程结束时栈内存会自动释放。
     </li>
     <li>
      垃圾回收（GC）：垃圾回收主要针对堆内存（Heap）和方法区（Metaspace），用于回收不再使用的对象和类信息。
     </li>
     <li>
      栈内存的管理：栈内存的分配和释放是自动的，由 JVM 负责。当一个方法调用结束时，其对应的栈帧会被弹出并销毁，局部变量也会随之消失。因此，栈内存不需要垃圾回收。
     </li>
    </ul>
    <h4>
     <a id="2__146">
     </a>
     2. 栈内存分配越大越好吗？
    </h4>
    <p>
     不是，栈内存的分配需要根据实际应用场景进行调整，既不能过小（避免栈溢出），也不能过大（避免内存浪费和线程数限制）。
    </p>
    <p>
     详细说明：
    </p>
    <ul>
     <li>
      栈内存过大的问题：
      <ul>
       <li>
        内存浪费：如果栈内存分配过大，但实际使用较少，会导致内存浪费。
       </li>
       <li>
        线程数限制：栈内存是线程私有的，每个线程都会占用独立的栈内存。如果栈内存过大，会导致可创建的线程数减少（因为总内存有限）。
       </li>
       <li>
        栈溢出风险：虽然栈内存过小可能导致栈溢出（StackOverflowError），但栈内存过大并不能解决深层递归或方法调用过多的问题，反而会浪费资源。
       </li>
      </ul>
     </li>
     <li>
      栈内存过小的问题：
      <ul>
       <li>
        栈溢出：如果栈内存过小，可能会导致栈溢出错误（StackOverflowError），尤其是在递归调用或方法调用链过长时。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="3__157">
     </a>
     3. 方法内的局部变量是否线程安全？
    </h4>
    <p>
     如果方法内局部变量没有逃离方法的作用访问(如对象引用为参数值、返回值)，它是线程安全的
     <br/>
     如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全
    </p>
    <h2>
     <a id="3_161">
     </a>
     3.本地方法栈
    </h2>
    <p>
     因为java代码有一定限制，不能直接跟操作系统底层联系，所以需要C或C++来和操作系统底层联系，这些本地方法运行时使用的内存为本地方法栈。
    </p>
    <p>
     和虚拟机栈所发挥的作用非常相似，区别是：
     <strong>
      虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
     </strong>
     在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
    </p>
    <p>
     本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
    </p>
    <p>
     方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。
    </p>
    <hr/>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34363432353636312f:61727469636c652f64657461696c732f313435363833303337" class_="artid" style="display:none">
 </p>
</div>


