---
layout: post
title: "学习笔记12并发编程之线程之间协作方式"
date: 2025-03-10 22:15:12 +0800
description: "它通过内置的阻塞机制，让生产者线程和消费者线程自动协调工作，无需开发者手动管理。是一个同步辅助工具，允许一组线程相互等待，直到所有线程到达屏障点后才能继续执行。实现：初始化时指定许可数，线程调用acquire()获取许可，调用release()释放许可。通过阻塞队列，生产者和消费者线程无需直接交互，只需要操作队列即可自动协调；：消费者线程尝试从空队列取数据时，会被阻塞直到队列非空。若队列已满，生产者线程阻塞，等待消费者取走数据后唤醒。若队列为空，消费者线程阻塞，等待生产者放入数据后唤醒。"
keywords: "学习笔记12——并发编程之线程之间协作方式"
categories: ['高级开发必备技能']
tags: ['开发语言', 'Jvm', 'Java']
artid: "146165444"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146165444
    alt: "学习笔记12并发编程之线程之间协作方式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146165444
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146165444
cover: https://bing.ee123.net/img/rand?artid=146165444
image: https://bing.ee123.net/img/rand?artid=146165444
img: https://bing.ee123.net/img/rand?artid=146165444
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     学习笔记12——并发编程之线程之间协作方式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     线程之间协作有哪些方式
    </h3>
    <p>
     当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其他部分之前完成，那么就需要对线程进行协调。
    </p>
    <h4>
     共享变量和轮询方式
    </h4>
    <p>
     实现：定义一个共享变量（如
     <code>
      volatile
     </code>
     修饰的布尔标志）。线程通过检查共享变量的状态来决定是否继续执行。
    </p>
    <pre><code class="language-java">public class Test {
​
    private static volatile boolean flag = false;
​
    public static void main(String[] args) throws InterruptedException {
​
        new Thread(new Runnable() {
            public void run() {
                System.out.println("flag" + flag);
                while (!flag){
                    System.out.println( "waiting"); //轮询等待
                }
                System.out.println("Flag is now " + flag);
            }
        }).start();
​
        Thread.sleep(1000);
        flag = true; // 修改共享变量
    }
}</code></pre>
    <h4 style="background-color:transparent">
     使用
     <strong>
      wait() 与 notify()/notifyAll()
     </strong>
    </h4>
    <p>
     通过object类中的wait()、notify()和notifyAll来实现。
    </p>
    <p>
     实现：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        wait()
       </strong>
       ：当前线程释放锁并进入等待状态（
       <code>
        WAITING
       </code>
       ）。需在同步块中调用（持有锁）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        notify()
       </strong>
       ：随机唤醒一个等待线程（
       <code>
        WAITING
       </code>
       →
       <code>
        BLOCKED
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        notifyAll()
       </strong>
       ：唤醒所有等待线程。
      </p>
     </li>
    </ul>
    <pre><code class="language-java">public class ProducerConsumer {
    private final Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    private final int capacity = 10;
    public void produce(int value) throws InterruptedException {
        synchronized (queue) {
            while (queue.size() == capacity) {
                queue.wait(); // 队列满，等待
            }
            queue.add(value);
            queue.notifyAll(); // 唤醒消费者
        }
    }
    public int consume() throws InterruptedException {
        synchronized (queue) {
            while (queue.isEmpty()) {
                queue.wait(); // 队列空，等待
            }
            int value = queue.poll();
            queue.notifyAll(); // 唤醒生产者
            return value;
        }
    }
    public static void main(String[] args) throws InterruptedException {
        ProducerConsumer pc = new ProducerConsumer();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                try {
                    pc.produce(i);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }).start();
​
        new Thread(() -&gt; {
            while (true){
                try {
                    System.out.println(pc.consume());
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }).start();
    }
}
​</code></pre>
    <h4>
     <strong>
      Condition 条件变量
     </strong>
    </h4>
    <p>
     通过
     <code>
      ReentrantLock
     </code>
     的
     <code>
      Condition
     </code>
     实现更灵活的线程协作。
    </p>
    <p>
     实现：Condition类似于
     <code>
      wait()
     </code>
     /
     <code>
      notify()
     </code>
     ，但支持多个条件队列，使用它需要和ReentrantLock配合使用。
    </p>
    <pre><code class="language-java">import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
​
public class ProducerConsumerWithCondition {
    private final Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    private final int capacity = 10;
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
​
    public void produce(int value) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                notFull.await(); // 等待队列不满
            }
            queue.add(value);
            notEmpty.signalAll(); // 唤醒消费者
        } finally {
            lock.unlock();
        }
    }
​
    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await(); //等待队列不空
            }
            int value = queue.poll();
            notFull.signalAll(); // 唤醒生产者
            return value;
        } finally {
            lock.unlock();
        }
    }
}</code></pre>
    <h4>
     <strong>
      CountDownLatch
     </strong>
    </h4>
    <p>
     通过CountDownLatch实现线程的等待与唤醒。
    </p>
    <p>
     实现：初始化时指定计数值，线程调用await()等待计数器归零；其他线程调用countDown()减少计数器。
    </p>
    <pre><code class="language-java">import java.util.concurrent.CountDownLatch;
​
public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int threadCount = 3;
        CountDownLatch latch = new CountDownLatch(threadCount);
​
        for (int i = 0; i &lt; threadCount; i++) {
            new Thread(() -&gt; {
                System.out.println("Thread finished");
                latch.countDown(); // 计数器减1
            }).start();
        }
​
        latch.await(); // 等待所有线程完成
        System.out.println("All threads finished");
    }
}</code></pre>
    <h4 style="background-color:transparent">
     <strong>
      CyclicBarrier
     </strong>
    </h4>
    <p>
     是一个同步辅助工具，允许一组线程相互等待，直到所有线程到达屏障点后才能继续执行。可以重复使用。
    </p>
    <p>
     实现：初始化时指定参与线程数；线程调用await()等待其他线程到达屏障点；所有线程到达后，屏障重置，可重复使用。
    </p>
    <pre><code class="language-java">import java.util.concurrent.CyclicBarrier;
​
public class CyclicBarrierExample {
    public static void main(String[] args) {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -&gt; {
            System.out.println("All threads reached the barrier");
        });
​
        for (int i = 0; i &lt; threadCount; i++) {
            new Thread(() -&gt; {
                System.out.println("Thread waiting at barrier");
                try {
                    barrier.await(); // 等待其他线程
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}</code></pre>
    <h4 style="background-color:transparent">
     <strong>
      Semaphore
     </strong>
     信号量
    </h4>
    <p>
     通过Semaphore控制资源的并发访问。
    </p>
    <p>
     实现：初始化时指定许可数，线程调用acquire()获取许可，调用release()释放许可。
    </p>
    <pre><code class="language-java">import java.util.concurrent.Semaphore;
​
public class SemaphoreExample {
    public static void main(String[] args) {
        int permits = 2;
        Semaphore semaphore = new Semaphore(permits);
​
        for (int i = 0; i &lt; 5; i++) {
            new Thread(() -&gt; {
                try {
                    semaphore.acquire(); // 获取许可
                    System.out.println("Thread acquired permit");
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // 释放许可
                    System.out.println("Thread released permit");
                }
            }).start();
        }
    }
}</code></pre>
    <h4 style="background-color:transparent">
     阻塞队列
    </h4>
    <p>
     <strong>
      阻塞队列（Blocking Queue）
     </strong>
     是 Java 多线程中实现线程协作的核心工具之一。它通过内置的阻塞机制，让生产者线程和消费者线程自动协调工作，无需开发者手动管理
     <code>
      wait()
     </code>
     、
     <code>
      notify()
     </code>
     或锁的细节。
    </p>
    <p>
     阻塞队列是一种特殊的队列，提供以下功能：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        队列空时的阻塞
       </strong>
       ：消费者线程尝试从空队列取数据时，会被阻塞直到队列非空。
      </p>
     </li>
     <li>
      <p>
       <strong>
        队列满时的阻塞
       </strong>
       ：生产者线程尝试向满队列放数据时，会被阻塞直到队列有空位。
      </p>
     </li>
     <li>
      <p>
       <strong>
        支持超时机制
       </strong>
       ：部分阻塞队列允许在指定时间内尝试操作，超时后返回失败
      </p>
     </li>
    </ol>
    <p>
     Java 并发包
     <code>
      java.util.concurrent
     </code>
     提供了多种阻塞队列实现：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         实现类
        </strong>
       </th>
       <th>
        <strong>
         特点
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         ArrayBlockingQueue
        </code>
       </td>
       <td>
        基于数组的有界队列，固定容量，公平性可选。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         LinkedBlockingQueue
        </code>
       </td>
       <td>
        基于链表的队列，默认无界（可指定容量），吞吐量高。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         PriorityBlockingQueue
        </code>
       </td>
       <td>
        支持优先级排序的无界队列。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         SynchronousQueue
        </code>
       </td>
       <td>
        不存储元素的队列，生产者插入操作必须等待消费者移除。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         DelayQueue
        </code>
       </td>
       <td>
        元素按延迟时间排序，只有到期后才能被取出。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     示例：生产者——消费者模型
    </p>
    <p>
     通过阻塞队列，生产者和消费者线程无需直接交互，只需要操作队列即可自动协调；
    </p>
    <ul>
     <li>
      <p>
       <strong>
        生产者线程
       </strong>
       ：调用
       <code>
        put()
       </code>
       方法放入数据，若队列满则阻塞。
      </p>
     </li>
     <li>
      <p>
       <strong>
        消费者线程
       </strong>
       ：调用
       <code>
        take()
       </code>
       方法取出数据，若队列空则阻塞。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      协作流程
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        生产者放数据
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         若队列未满，直接插入数据并唤醒消费者线程。
        </p>
       </li>
       <li>
        <p>
         若队列已满，生产者线程阻塞，等待消费者取走数据后唤醒。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        消费者取数据
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         若队列非空，直接取出数据并唤醒生产者线程。
        </p>
       </li>
       <li>
        <p>
         若队列为空，消费者线程阻塞，等待生产者放入数据后唤醒。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="language-java">import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
​
public class ProducerConsumerExample {
    public static void main(String[] args) {
        BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); // 容量为10的阻塞队列
​
        // 生产者线程
        Thread producer = new Thread(() -&gt; {
            try {
                for (int i = 0; i &lt; 100; i++) {
                    queue.put(i); // 队列满时自动阻塞
                    System.out.println("Produced: " + i);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
​
        // 消费者线程
        Thread consumer = new Thread(() -&gt; {
            try {
                while (true) {
                    Integer value = queue.take(); // 队列空时自动阻塞
                    System.out.println("Consumed: " + value);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
​
        producer.start();
        consumer.start();
    }
}</code></pre>
    <p>
    </p>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         协作方式
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
       <th>
        <strong>
         优点
        </strong>
       </th>
       <th>
        <strong>
         缺点
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         共享变量与轮询
        </strong>
       </td>
       <td>
        简单状态检查
       </td>
       <td>
        简单易用
       </td>
       <td>
        浪费 CPU，无法精确唤醒
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         wait/notify
        </strong>
       </td>
       <td>
        生产者-消费者模型
       </td>
       <td>
        精确控制线程唤醒
       </td>
       <td>
        需手动管理锁和条件
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Condition
        </strong>
       </td>
       <td>
        复杂条件等待
       </td>
       <td>
        支持多条件队列，灵活性高
       </td>
       <td>
        代码复杂度高
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         CountDownLatch
        </strong>
       </td>
       <td>
        一次性等待场景（如任务完成）
       </td>
       <td>
        简单易用
       </td>
       <td>
        不可重置
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         CyclicBarrier
        </strong>
       </td>
       <td>
        分阶段任务同步
       </td>
       <td>
        可重复使用
       </td>
       <td>
        需预先知道线程数
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Semaphore
        </strong>
       </td>
       <td>
        控制资源并发访问
       </td>
       <td>
        灵活控制并发数
       </td>
       <td>
        需手动管理许可
       </td>
      </tr>
      <tr>
       <td>
        阻塞队列
       </td>
       <td>
        <strong>
         生产者-消费者模型
        </strong>
        、
        <strong>
         线程池任务队列
        </strong>
        ：如
        <code>
         ThreadPoolExecutor
        </code>
        使用阻塞队列管理待执行任务。
        <strong>
         流量控制
        </strong>
        ：通过有界队列限制系统资源使用，防止内存溢出。
        <strong>
         延迟任务调度
        </strong>
        ：如
        <code>
         DelayQueue
        </code>
        实现定时任务执行。
       </td>
       <td>
        <strong>
         简化代码
        </strong>
        ，
        <strong>
         避免竞态条件
        </strong>
        ，自动阻塞与唤醒，支持多种策略
       </td>
       <td>
        无界队列可能导致内存溢出。
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33363137343038312f:61727469636c652f64657461696c732f313436313635343434" class_="artid" style="display:none">
 </p>
</div>


