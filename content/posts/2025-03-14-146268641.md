---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f4368656e374368616e2f:61727469636c652f64657461696c732f313436323638363431"
layout: post
title: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—32-å‰ç«¯æµ‹è¯•å®è·µæŒ‡å—"
date: 2025-03-14 22:31:59 +0800
description: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ä¹‹æ—…ç¬¬ä¸‰åäºŒç«™"
keywords: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ32ï¼‰--å‰ç«¯æµ‹è¯•å®è·µæŒ‡å—"
categories: ['å‰ç«¯å·¥ç¨‹åŒ–ä¸æ¡†æ¶']
tags: ['å‰ç«¯']
artid: "146268641"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268641
    alt: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—32-å‰ç«¯æµ‹è¯•å®è·µæŒ‡å—"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268641
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268641
cover: https://bing.ee123.net/img/rand?artid=146268641
image: https://bing.ee123.net/img/rand?artid=146268641
img: https://bing.ee123.net/img/rand?artid=146268641
---

# å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ32ï¼‰--å‰ç«¯æµ‹è¯•å®è·µæŒ‡å—

## å‰ç«¯æµ‹è¯•å®è·µæŒ‡å— ğŸ§ª

### å¼•è¨€

å‰ç«¯æµ‹è¯•æ˜¯ä¿è¯åº”ç”¨è´¨é‡çš„é‡è¦ç¯èŠ‚ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å‰ç«¯æµ‹è¯•çš„å„ä¸ªæ–¹é¢ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•ç­‰ï¼Œå¹¶æä¾›å®ç”¨çš„æµ‹è¯•å·¥å…·å’Œæœ€ä½³å®è·µã€‚

### æµ‹è¯•æ¦‚è¿°

å‰ç«¯æµ‹è¯•ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹ç±»å‹ï¼š

* **å•å…ƒæµ‹è¯•**
  ï¼šæµ‹è¯•ç‹¬ç«‹ç»„ä»¶å’Œå‡½æ•°
* **é›†æˆæµ‹è¯•**
  ï¼šæµ‹è¯•å¤šä¸ªç»„ä»¶çš„äº¤äº’
* **ç«¯åˆ°ç«¯æµ‹è¯•**
  ï¼šæ¨¡æ‹Ÿç”¨æˆ·è¡Œä¸ºçš„å®Œæ•´æµ‹è¯•
* **æ€§èƒ½æµ‹è¯•**
  ï¼šæµ‹è¯•åº”ç”¨æ€§èƒ½æŒ‡æ ‡
* **å¿«ç…§æµ‹è¯•**
  ï¼šUIç»„ä»¶çš„è§†è§‰å›å½’æµ‹è¯•

### æµ‹è¯•å·¥å…·å®ç°

#### æµ‹è¯•è¿è¡Œå™¨

```typescript
// æµ‹è¯•è¿è¡Œå™¨ç±»
class TestRunner {
    private tests: TestCase[] = [];
    private beforeEachHooks: Hook[] = [];
    private afterEachHooks: Hook[] = [];
    private beforeAllHooks: Hook[] = [];
    private afterAllHooks: Hook[] = [];
    
    constructor(private config: TestConfig = {}) {
        this.initialize();
    }
    
    // åˆå§‹åŒ–è¿è¡Œå™¨
    private initialize(): void {
        // è®¾ç½®é»˜è®¤é…ç½®
        this.config = {
            timeout: 5000,
            bail: false,
            verbose: true,
            ...this.config
        };
    }
    
    // æ·»åŠ æµ‹è¯•ç”¨ä¾‹
    addTest(test: TestCase): void {
        this.tests.push(test);
    }
    
    // æ·»åŠ beforeEaché’©å­
    beforeEach(hook: Hook): void {
        this.beforeEachHooks.push(hook);
    }
    
    // æ·»åŠ afterEaché’©å­
    afterEach(hook: Hook): void {
        this.afterEachHooks.push(hook);
    }
    
    // æ·»åŠ beforeAllé’©å­
    beforeAll(hook: Hook): void {
        this.beforeAllHooks.push(hook);
    }
    
    // æ·»åŠ afterAllé’©å­
    afterAll(hook: Hook): void {
        this.afterAllHooks.push(hook);
    }
    
    // è¿è¡Œæ‰€æœ‰æµ‹è¯•
    async runTests(): Promise<TestResult[]> {
        const results: TestResult[] = [];
        let failedTests = 0;
        
        console.log('\nStarting test run...\n');
        
        // è¿è¡ŒbeforeAllé’©å­
        for (const hook of this.beforeAllHooks) {
            await this.runHook(hook);
        }
        
        // è¿è¡Œæµ‹è¯•ç”¨ä¾‹
        for (const test of this.tests) {
            const result = await this.runTest(test);
            results.push(result);
            
            if (!result.passed) {
                failedTests++;
                if (this.config.bail) {
                    break;
                }
            }
        }
        
        // è¿è¡ŒafterAllé’©å­
        for (const hook of this.afterAllHooks) {
            await this.runHook(hook);
        }
        
        // è¾“å‡ºæµ‹è¯•æŠ¥å‘Š
        this.printReport(results);
        
        return results;
    }
    
    // è¿è¡Œå•ä¸ªæµ‹è¯•
    private async runTest(test: TestCase): Promise<TestResult> {
        const startTime = Date.now();
        let error: Error | null = null;
        
        try {
            // è¿è¡ŒbeforeEaché’©å­
            for (const hook of this.beforeEachHooks) {
                await this.runHook(hook);
            }
            
            // è¿è¡Œæµ‹è¯•
            await Promise.race([
                test.fn(),
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Test timed out'));
                    }, this.config.timeout);
                })
            ]);
            
            // è¿è¡ŒafterEaché’©å­
            for (const hook of this.afterEachHooks) {
                await this.runHook(hook);
            }
        } catch (e) {
            error = e as Error;
        }
        
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        return {
            name: test.name,
            passed: !error,
            duration,
            error: error?.message
        };
    }
    
    // è¿è¡Œé’©å­å‡½æ•°
    private async runHook(hook: Hook): Promise<void> {
        try {
            await hook();
        } catch (error) {
            console.error('Hook failed:', error);
        }
    }
    
    // æ‰“å°æµ‹è¯•æŠ¥å‘Š
    private printReport(results: TestResult[]): void {
        console.log('\nTest Results:\n');
        
        results.forEach(result => {
            const status = result.passed ? 'âœ… PASS' : 'âŒ FAIL';
            console.log(`${status} ${result.name} (${result.duration}ms)`);
            
            if (!result.passed && result.error) {
                console.log(`  Error: ${result.error}\n`);
            }
        });
        
        const totalTests = results.length;
        const passedTests = results.filter(r => r.passed).length;
        const failedTests = totalTests - passedTests;
        
        console.log('\nSummary:');
        console.log(`Total: ${totalTests}`);
        console.log(`Passed: ${passedTests}`);
        console.log(`Failed: ${failedTests}`);
        
        const duration = results.reduce((sum, r) => sum + r.duration, 0);
        console.log(`Duration: ${duration}ms\n`);
    }
}

// æ–­è¨€å·¥å…·ç±»
class Assertions {
    static assertEquals<T>(actual: T, expected: T, message?: string): void {
        if (actual !== expected) {
            throw new Error(
                message || 
                `Expected ${expected} but got ${actual}`
            );
        }
    }
    
    static assertNotEquals<T>(actual: T, expected: T, message?: string): void {
        if (actual === expected) {
            throw new Error(
                message || 
                `Expected ${actual} to be different from ${expected}`
            );
        }
    }
    
    static assertTrue(value: boolean, message?: string): void {
        if (!value) {
            throw new Error(
                message || 
                'Expected value to be true'
            );
        }
    }
    
    static assertFalse(value: boolean, message?: string): void {
        if (value) {
            throw new Error(
                message || 
                'Expected value to be false'
            );
        }
    }
    
    static assertDefined<T>(value: T, message?: string): void {
        if (value === undefined) {
            throw new Error(
                message || 
                'Expected value to be defined'
            );
        }
    }
    
    static assertUndefined<T>(value: T, message?: string): void {
        if (value !== undefined) {
            throw new Error(
                message || 
                'Expected value to be undefined'
            );
        }
    }
    
    static assertNull<T>(value: T, message?: string): void {
        if (value !== null) {
            throw new Error(
                message || 
                'Expected value to be null'
            );
        }
    }
    
    static assertNotNull<T>(value: T, message?: string): void {
        if (value === null) {
            throw new Error(
                message || 
                'Expected value to be not null'
            );
        }
    }
    
    static assertThrows(fn: () => void, message?: string): void {
        try {
            fn();
            throw new Error(
                message || 
                'Expected function to throw'
            );
        } catch (error) {
            // æœŸæœ›æŠ›å‡ºé”™è¯¯
        }
    }
    
    static async assertRejects(
        fn: () => Promise<any>,
        message?: string
    ): Promise<void> {
        try {
            await fn();
            throw new Error(
                message || 
                'Expected promise to reject'
            );
        } catch (error) {
            // æœŸæœ›æŠ›å‡ºé”™è¯¯
        }
    }
    
    static assertMatch(
        actual: string,
        pattern: RegExp,
        message?: string
    ): void {
        if (!pattern.test(actual)) {
            throw new Error(
                message || 
                `Expected ${actual} to match ${pattern}`
            );
        }
    }
    
    static assertNotMatch(
        actual: string,
        pattern: RegExp,
        message?: string
    ): void {
        if (pattern.test(actual)) {
            throw new Error(
                message || 
                `Expected ${actual} not to match ${pattern}`
            );
        }
    }
}

// æ¨¡æ‹Ÿå·¥å…·ç±»
class Mock {
    private calls: any[][] = [];
    private implementation?: (...args: any[]) => any;
    
    constructor(implementation?: (...args: any[]) => any) {
        this.implementation = implementation;
    }
    
    // åˆ›å»ºæ¨¡æ‹Ÿå‡½æ•°
    fn = (...args: any[]): any => {
        this.calls.push(args);
        return this.implementation?.(...args);
    }
    
    // è·å–è°ƒç”¨æ¬¡æ•°
    callCount(): number {
        return this.calls.length;
    }
    
    // è·å–è°ƒç”¨å‚æ•°
    getCall(index: number): any[] {
        return this.calls[index];
    }
    
    // è·å–æ‰€æœ‰è°ƒç”¨
    getCalls(): any[][] {
        return this.calls;
    }
    
    // æ¸…é™¤è°ƒç”¨è®°å½•
    clear(): void {
        this.calls = [];
    }
    
    // è®¾ç½®å®ç°
    setImplementation(implementation: (...args: any[]) => any): void {
        this.implementation = implementation;
    }
}

// æ¥å£å®šä¹‰
interface TestCase {
    name: string;
    fn: () => Promise<void> | void;
}

interface TestResult {
    name: string;
    passed: boolean;
    duration: number;
    error?: string;
}

interface TestConfig {
    timeout?: number;
    bail?: boolean;
    verbose?: boolean;
}

type Hook = () => Promise<void> | void;

// ä½¿ç”¨ç¤ºä¾‹
const runner = new TestRunner({
    timeout: 2000,
    bail: true
});

// æ·»åŠ é’©å­
runner.beforeAll(async () => {
    console.log('Setting up test environment...');
});

runner.afterAll(async () => {
    console.log('Cleaning up test environment...');
});

runner.beforeEach(async () => {
    console.log('Setting up test case...');
});

runner.afterEach(async () => {
    console.log('Cleaning up test case...');
});

// æ·»åŠ æµ‹è¯•ç”¨ä¾‹
runner.addTest({
    name: 'should add numbers correctly',
    fn: () => {
        const result = 1 + 1;
        Assertions.assertEquals(result, 2);
    }
});

runner.addTest({
    name: 'should handle async operations',
    fn: async () => {
        const result = await Promise.resolve(42);
        Assertions.assertEquals(result, 42);
    }
});

// è¿è¡Œæµ‹è¯•
runner.runTests().then(results => {
    process.exit(results.every(r => r.passed) ? 0 : 1);
});

```

#### ç»„ä»¶æµ‹è¯•å·¥å…·

```typescript
// ç»„ä»¶æµ‹è¯•å·¥å…·ç±»
class ComponentTester {
    private element: HTMLElement;
    private eventListeners: Map<string, Function[]> = new Map();
    
    constructor(private component: any) {
        this.element = this.mount();
    }
    
    // æŒ‚è½½ç»„ä»¶
    private mount(): HTMLElement {
        const container = document.createElement('div');
        document.body.appendChild(container);
        
        if (typeof this.component === 'string') {
            container.innerHTML = this.component;
        } else {
            // å‡è®¾ç»„ä»¶æ˜¯ä¸€ä¸ªç±»
            const instance = new this.component();
            container.appendChild(instance.render());
        }
        
        return container;
    }
    
    // æŸ¥æ‰¾å…ƒç´ 
    find(selector: string): HTMLElement | null {
        return this.element.querySelector(selector);
    }
    
    // æŸ¥æ‰¾æ‰€æœ‰å…ƒç´ 
    findAll(selector: string): NodeListOf<HTMLElement> {
        return this.element.querySelectorAll(selector);
    }
    
    // è§¦å‘äº‹ä»¶
    trigger(
        selector: string,
        eventName: string,
        eventData: any = {}
    ): void {
        const element = this.find(selector);
        if (!element) {
            throw new Error(`Element not found: ${selector}`);
        }
        
        const event = new CustomEvent(eventName, {
            detail: eventData,
            bubbles: true,
            cancelable: true
        });
        
        element.dispatchEvent(event);
    }
    
    // ç­‰å¾…å…ƒç´ å‡ºç°
    async waitForElement(
        selector: string,
        timeout: number = 1000
    ): Promise<HTMLElement> {
        const startTime = Date.now();
        
        while (Date.now() - startTime < timeout) {
            const element = this.find(selector);
            if (element) {
                return element;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        throw new Error(`Timeout waiting for element: ${selector}`);
    }
    
    // ç­‰å¾…å…ƒç´ æ¶ˆå¤±
    async waitForElementToDisappear(
        selector: string,
        timeout: number = 1000
    ): Promise<void> {
        const startTime = Date.now();
        
        while (Date.now() - startTime < timeout) {
            const element = this.find(selector);
            if (!element) {
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        throw new Error(
            `Timeout waiting for element to disappear: ${selector}`
        );
    }
    
    // è·å–å…ƒç´ æ–‡æœ¬
    getText(selector: string): string {
        const element = this.find(selector);
        if (!element) {
            throw new Error(`Element not found: ${selector}`);
        }
        return element.textContent || '';
    }
    
    // è·å–å…ƒç´ å±æ€§
    getAttribute(
        selector: string,
        attributeName: string
    ): string | null {
        const element = this.find(selector);
        if (!element) {
            throw new Error(`Element not found: ${selector}`);
        }
        return element.getAttribute(attributeName);
    }
    
    // è®¾ç½®è¾“å…¥å€¼
    setInputValue(selector: string, value: string): void {
        const element = this.find(selector) as HTMLInputElement;
        if (!element) {
            throw new Error(`Input element not found: ${selector}`);
        }
        
        element.value = value;
        this.trigger(selector, 'input');
        this.trigger(selector, 'change');
    }
    
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
    isVisible(selector: string): boolean {
        const element = this.find(selector);
        if (!element) {
            return false;
        }
        
        const style = window.getComputedStyle(element);
        return style.display !== 'none' && 
               style.visibility !== 'hidden' && 
               style.opacity !== '0';
    }
    
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
    exists(selector: string): boolean {
        return !!this.find(selector);
    }
    
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦åŒ…å«ç±»å
    hasClass(selector: string, className: string): boolean {
        const element = this.find(selector);
        return element ? element.classList.contains(className) : false;
    }
    
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦ç¦ç”¨
    isDisabled(selector: string): boolean {
        const element = this.find(selector) as HTMLInputElement;
        return element ? element.disabled : false;
    }
    
    // æ¸…ç†
    cleanup(): void {
        document.body.removeChild(this.element);
        this.eventListeners.clear();
    }
}

// ä½¿ç”¨ç¤ºä¾‹
class Counter {
    private count = 0;
    private element: HTMLElement;
    
    constructor() {
        this.element = document.createElement('div');
        this.render();
    }
    
    increment(): void {
        this.count++;
        this.render();
    }
    
    render(): HTMLElement {
        this.element.innerHTML = `
            <div class="counter">
                <span class="count">${this.count}</span>
                <button class="increment">+</button>
            </div>
        `;
        
        const button = this.element.querySelector('.increment');
        button?.addEventListener('click', () => this.increment());
        
        return this.element;
    }
}

// æµ‹è¯•è®¡æ•°å™¨ç»„ä»¶
const runner = new TestRunner();

runner.addTest({
    name: 'Counter component should render correctly',
    fn: () => {
        const tester = new ComponentTester(Counter);
        
        // æ£€æŸ¥åˆå§‹çŠ¶æ€
        Assertions.assertEquals(
            tester.getText('.count'),
            '0'
        );
        
        // è§¦å‘ç‚¹å‡»äº‹ä»¶
        tester.trigger('.increment', 'click');
        
        // æ£€æŸ¥æ›´æ–°åçš„çŠ¶æ€
        Assertions.assertEquals(
            tester.getText('.count'),
            '1'
        );
        
        tester.cleanup();
    }
});

runner.runTests();

```

### æœ€ä½³å®è·µä¸å»ºè®®

1. **æµ‹è¯•ç­–ç•¥**

   * éµå¾ªæµ‹è¯•é‡‘å­—å¡”
   * åˆç†åˆ†é…æµ‹è¯•ç±»å‹
   * å…³æ³¨æ ¸å¿ƒåŠŸèƒ½
   * ç»´æŠ¤æµ‹è¯•è´¨é‡
2. **æµ‹è¯•è®¾è®¡**

   * å•ä¸€èŒè´£
   * ç‹¬ç«‹æ€§
   * å¯é‡å¤æ€§
   * å¯ç»´æŠ¤æ€§
3. **æµ‹è¯•è¦†ç›–ç‡**

   * è®¾ç½®åˆç†ç›®æ ‡
   * å…³æ³¨é‡è¦ä»£ç 
   * é¿å…è¿‡åº¦æµ‹è¯•
   * æŒç»­ç›‘æ§
4. **æµ‹è¯•æ•ˆç‡**

   * å¹¶è¡Œæ‰§è¡Œ
   * ä¼˜åŒ–é€Ÿåº¦
   * è‡ªåŠ¨åŒ–é›†æˆ
   * æŒç»­é›†æˆ

### æ€»ç»“

å‰ç«¯æµ‹è¯•éœ€è¦è€ƒè™‘ä»¥ä¸‹æ–¹é¢ï¼š

1. æµ‹è¯•ç±»å‹é€‰æ‹©
2. æµ‹è¯•å·¥å…·ä½¿ç”¨
3. æµ‹è¯•ç­–ç•¥åˆ¶å®š
4. æµ‹è¯•æ•ˆç‡ä¼˜åŒ–
5. æµ‹è¯•ç»´æŠ¤ç®¡ç†

é€šè¿‡åˆç†çš„æµ‹è¯•å®è·µï¼Œå¯ä»¥æé«˜ä»£ç è´¨é‡å’Œé¡¹ç›®å¯ç»´æŠ¤æ€§ã€‚

### å­¦ä¹ èµ„æº

1. Jestå®˜æ–¹æ–‡æ¡£
2. Testing LibraryæŒ‡å—
3. Cypressæ–‡æ¡£
4. æµ‹è¯•æœ€ä½³å®è·µ
5. è‡ªåŠ¨åŒ–æµ‹è¯•æ•™ç¨‹

---

å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è—ï¼Œä¹ŸæœŸå¾…åœ¨è¯„è®ºåŒºçœ‹åˆ°ä½ çš„æƒ³æ³•å’Œå»ºè®®ï¼ğŸ‘‡

***ç»ˆèº«å­¦ä¹ ï¼Œå…±åŒæˆé•¿ã€‚***

å’±ä»¬ä¸‹ä¸€æœŸè§

ğŸ’»