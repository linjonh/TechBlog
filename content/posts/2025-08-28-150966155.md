---
layout: post
title: "数据结构与算法LeetCode141.环形链表-142.环形链表"
date: 2025-08-28T23:57:28+0800
description: "由于快指针每次比慢指针多走一步，它们之间的距离会逐次减少：N, N-1, N-2, …这意味着：从头节点到环入口的距离L，等于从相遇点走(x-1)圈再加(C-N)步。进一步分析表明，当快指针走三步时，追不上的条件是：N为奇数且C为偶数。2.当N为奇数时，会错过，这时他们的距离会变为C-1    (假设C为环的长度)fast走的距离就是L+x*C+N     (x为fast走的圈数)。所以这么一看，追不上的条件是:N为奇数并且C为偶数。当C为偶数N为奇数时，x*C为偶数。所以不存在N为奇数，C为偶数的情况。"
keywords: "【数据结构与算法】（LeetCode）141.环形链表 142.环形链表Ⅱ"
categories: ['未分类']
tags: ['链表', '算法', '数据结构', 'Leetcode']
artid: "150966155"
arturl: "https://blog.csdn.net/czx_163/article/details/150966155"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=150966155
    alt: "数据结构与算法LeetCode141.环形链表-142.环形链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=150966155
featuredImagePreview: https://bing.ee123.net/img/rand?artid=150966155
cover: https://bing.ee123.net/img/rand?artid=150966155
image: https://bing.ee123.net/img/rand?artid=150966155
img: https://bing.ee123.net/img/rand?artid=150966155
---



# 【数据结构与算法】（LeetCode）141.环形链表 142.环形链表Ⅱ



### 引言

环形链表问题是数据结构与算法中的经典问题，在面试中出现频率极高。这类问题不仅考察对链表结构的理解，更考验解决问题的思维能力和数学分析能力。本文将详细分析环形链表的判断方法以及环入口节点的定位算法，帮助读者深入理解这一重要问题。

### 环形链表判断

#### 问题描述

给定一个链表的头节点 `head`，判断链表中是否存在环。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/43795d41d3574b71904d658008b15436.png#pic_center)

#### 解决方案：快慢指针法

快慢指针法是解决环形链表问题的经典方法，其核心思想是使用两个指针以不同速度遍历链表。

```c
bool hasCycle(struct ListNode *head) {
    
    struct ListNode* slow=head,*fast=head;
    while(fast&&fast->next)
    {
        slow=slow->next;
        fast=fast->next->next;
        //一定要先让快慢指针走，再判断 因为一开始快慢指针都是head

        if(slow==fast)
        return true;
       
    }
    return false;
    
}

```

#### 原理分析

##### 为什么快慢指针一定能相遇？

假设慢指针进入环时，快指针与慢指针之间的距离为N。由于快指针每次比慢指针多走一步，它们之间的距离会逐次减少：N, N-1, N-2, …, 2, 1, 0。因此最终一定会相遇。

##### 步长选择的数学分析

**为什么选择一步和两步？**

当快指针每次走三步、四步或更多时，情况会变得更加复杂。以三步为例：

* 每次移动后，快慢指针之间的距离减少2
* 当N为偶数时，可以追上
* 当N为奇数时，会错过，距离变为C-1（C为环长）

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ed27c1de79a480da0fe3e93e2bf0785.png#pic_center)

假设slow进环时，fast跟slow的距离是N

fast追击slow时 距离变化为N N-1 N-2 ……2 1 0

所以能追上

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0986209d44834bbb890c2a4cf9b92b43.png#pic_center)

当fast等于3时，每次fast与slow距离就减2

1.当N为偶数时，可以追上

2.当N为奇数时，会错过，这时他们的距离会变为C-1 (假设C为环的长度)

a.如果C-1为偶数(C为奇数)，下一轮就追上了

b.如果C-1为奇数(C为偶数)，就永远追不上

所以这么一看，追不上的条件是:N为奇数并且C为偶数

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7f113d070ddc4cd29eb276284f02e772.png#pic_center)

**但是这种情况存在吗？**

进一步分析表明，当快指针走三步时，追不上的条件是：N为奇数且C为偶数。但通过数学推导可以证明这种情况实际上不可能发生：

假设slow走的距离是L

fast走的距离就是L+x*C+N (x为fast走的圈数)

fast走的距离是slow的3倍

3L=L+x*C+N

化简可得

2L=x*C+N

当C为偶数N为奇数时，x*C为偶数

等号左边是偶数，右边是偶数加奇数（也就是奇数），显然不成立

所以不存在N为奇数，C为偶数的情况

所以fast一定能追上slow

### 环形链表Ⅱ

题目如下

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1acacb65ebca4c3498c1488e4651c3d1.png#pic_center)

#### 方法一

找到fast与slow相遇的位置meet，head与meet同时走，他们相遇位置就是环的入口

证明如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d7960e4496a240d99a6d61461cac7d15.png#pic_center)

相遇时:

slow走的路程为：L+N

fast走的路程为: L+x*C+N

fast走的是slow的2倍

2(L+N)=L+x*C+N

化简可得

L=(x-1)*C+C-N

所以L的长度就是相遇点转了x-1圈 再走了C-N距离的点

这意味着：从头节点到环入口的距离L，等于从相遇点走(x-1)圈再加(C-N)步。因此，两个指针分别从头节点和相遇点出发，一定会在环入口相遇。

代码如下

```c
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode* slow=head,*fast=head;

    while(fast&&fast->next)
    {
        slow=slow->next;
        fast=fast->next->next;

        if(slow==fast)
        {
            struct ListNode * meet=slow;
            while(meet!=head)
            {
                head=head->next;
                meet=meet->next;
                
            }
            return meet;
        }
    }
    return NULL;
}

```

#### 方法二：转换为相交链表问题

##### 算法思路

1. 找到快慢指针的相遇点
2. 将环从相遇点处断开
3. 问题转换为求两个链表的交点问题

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/de543c974d274dbbb66d4d6e16e83685.png#pic_center)

将环形链表断开

newhead=meet->next

meet->next=NULL

这样就转换成了链表相交的问题

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode* curA=headA,*curB=headB;
    int lenA=1,lenB=1;
    while(curA->next)
    {
        curA=curA->next;
        lenA++;
    }

    while(curB->next)
    {
        curB=curB->next;
        lenB++;
    }

   

    int gap=abs(lenA-lenB);

    //假设法 先假设A长
    struct ListNode* longList=headA;
    struct ListNode* shortList=headB;
    if(lenA<lenB)
    {
        longList=headB;
        shortList=headA;
    }

    while(gap--)
    {
        longList=longList->next;
    }

    while(longList)
    {
        if(longList==shortList)
        return longList;
        longList=longList->next;
        shortList=shortList->next;
    }
    return NULL;
}

struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode* slow=head,*fast=head;
    
    while(fast&&fast->next)
    {
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast)
        {
            struct ListNode* meet=slow;
            struct ListNode* newhead=meet->next;
            meet->next=NULL;
            return getIntersectionNode(head,newhead);
        }
       
    }
   
 return NULL;
    
}

```

### 实际应用与扩展

#### 应用场景

1. **内存管理**：检测内存泄漏或循环引用
2. **状态机检测**：验证有限状态机是否会进入循环状态
3. **递归检测**：判断递归函数是否会无限递归  
    meet->next=NULL;  
    return getIntersectionNode(head,newhead);  
    }

   }

return NULL;

}

```

## 实际应用与扩展

### 应用场景

1. **内存管理**：检测内存泄漏或循环引用
2. **状态机检测**：验证有限状态机是否会进入循环状态
3. **递归检测**：判断递归函数是否会无限递归
4. **哈希冲突解决**：在开放定址法中检测哈希表是否已满

```



