---
layout: post
title: "数据结构顺序表seqlist"
date: 2025-03-13 10:41:36 +0800
description: "线性表是具有相同数据类型的n个数据元素的有限序列，n为表长，当n=0时线性表时一个空表。用l命名线性表，表示为l=（a1，a2，  ，an）。线性表除第一个元素之外，每个元素都有直接前驱，除最后一个元素之外每个元素都有直接后继。顺序表是一种线性表的存储实现方式。线性表是具有相同数据类型的元素构成的有限序列，顺序表通过数组的形式将这些元素存储在内存中，并通过下标索引来访问和操作元素。"
keywords: "数据结构——顺序表seqlist"
categories: ['数据结构']
tags: ['数据结构']
artid: "146039209"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146039209
    alt: "数据结构顺序表seqlist"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146039209
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146039209
cover: https://bing.ee123.net/img/rand?artid=146039209
image: https://bing.ee123.net/img/rand?artid=146039209
img: https://bing.ee123.net/img/rand?artid=146039209
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——顺序表seqlist
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      前言：大家好😍，本文主要介绍了数据结构——顺序表部分的内容
     </p>
    </blockquote>
    <div>
    </div>
    <hr/>
    <h2 id="%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" name="%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">
     一、线性表的定义
    </h2>
    <p>
     线性表是具有
     <span style="color:#fe2c24">
      相同数据类型
     </span>
     的
     <span style="color:#fe2c24">
      n个数据元素
     </span>
     的
     <span style="color:#fe2c24">
      有限序列
     </span>
     ，n为表长，当n=0时线性表时一个空表。用l命名线性表，表示为l=（a1，a2，  ，an）。
    </p>
    <p>
     <span style="color:#fe2c24">
      线性表
     </span>
     除第一个元素之外，每个元素都有
     <span style="color:#fe2c24">
      直接前驱
     </span>
     ，除最后一个元素之外每个元素都有
     <span style="color:#fe2c24">
      直接后继
     </span>
     。
    </p>
    <p>
     <img alt="" height="43" src="https://i-blog.csdnimg.cn/direct/9dc4ba48bfec409ea7736a4e1743812e.png" width="262"/>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" name="%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">
     <a id="_19">
     </a>
     二、线性表的基本操作
    </h2>
    <blockquote>
     <p>
      <a id="1_20">
      </a>
      Initlist（&amp;L）：
      <span style="background-color:#ffd900">
       初始化
      </span>
      表，
      <span style="color:#fe2c24">
       构造一个空的线性表L
      </span>
      ，构造一个空的线性表，分配内存空间
     </p>
     <p>
      Destroylist（&amp;L）：
      <span style="background-color:#ffd900">
       销毁
      </span>
      。销毁线性表并释放线性表L所占用的内存空间
     </p>
     <p>
     </p>
     <p>
      Insertlist（&amp;L，i，e）：
      <span style="background-color:#ffd900">
       插入
      </span>
      ，在表
      <span style="color:#fe2c24">
       L
      </span>
      中第
      <span style="color:#fe2c24">
       i
      </span>
      个位置上插入指定元素
      <span style="color:#fe2c24">
       e
      </span>
     </p>
     <p>
      <span style="color:#494949">
       Deletelist（&amp;L，i，&amp;e）：
       <span style="background-color:#ffd900">
        删除
       </span>
       ，删除表
      </span>
      <span style="color:#fe2c24">
       L
      </span>
      <span style="color:#494949">
       中第
      </span>
      <span style="color:#fe2c24">
       i
      </span>
      <span style="color:#494949">
       个位置上的元素，并用
      </span>
      <span style="color:#fe2c24">
       e
      </span>
      <span style="color:#494949">
       返回删除元素的值
      </span>
     </p>
     <p>
     </p>
     <p>
      LocateElem（L，e）：
      <span style="background-color:#ffd900">
       按值查找
      </span>
      ，在表
      <span style="color:#fe2c24">
       L
      </span>
      中查找具有给定关键字
      <span style="color:#fe2c24">
       e
      </span>
      值的元素
     </p>
     <p>
      GetElem（L，i）：
      <span style="background-color:#ffd900">
       按位查找
      </span>
      ，获取表
      <span style="color:#fe2c24">
       L
      </span>
      中第
      <span style="color:#fe2c24">
       i
      </span>
      个位置的元素的值
     </p>
     <p>
     </p>
     <p>
      Length（L)：求
      <span style="background-color:#ffd900">
       表长
      </span>
      ，返回线性表L的长度，即L中数据元素的个数
     </p>
     <p>
      Printlist（L）：
      <span style="background-color:#ffd900">
       输出
      </span>
      ，输出线性表所有元素值
     </p>
     <p>
      Empty（L）：
      <span style="background-color:#ffd900">
       判空
      </span>
      ，若L为空，返回true，否则返回false
     </p>
    </blockquote>
    <p>
     对参数的修改结果需要引用&amp;
    </p>
    <h2 id="%E4%B8%89.%E9%A1%BA%E5%BA%8F%E8%A1%A8" name="%E4%B8%89.%E9%A1%BA%E5%BA%8F%E8%A1%A8">
     三.顺序表
    </h2>
    <h3 id="1.%E5%AE%9A%E4%B9%89" name="1.%E5%AE%9A%E4%B9%89">
     1.定义
    </h3>
    <p>
     顺序表是一种
     <strong>
      线性表
     </strong>
     的存储实现方式。线性表是具有相同数据类型的元素构成的有限序列，顺序表通过
     <strong>
      <span style="background-color:#ffd900">
       数组
      </span>
     </strong>
     的形式将这些元素存储在内存中，并通过
     <strong>
      <span style="background-color:#ffd900">
       下标索引
      </span>
     </strong>
     来访问和操作元素。
    </p>
    <h3 id="2.%C2%A0%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" name="2.%C2%A0%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">
     2.
     <strong>
      存储结构
     </strong>
    </h3>
    <p>
     顺序表通常使用数组来实现，数组的每个位置存储一个元素。例如，一个顺序表可以表示为：
    </p>
    <p>
     数组：[a0, a1, a2, ..., an-1]
     <br/>
     其中，a0 是表头元素，an-1 是表尾元素。
    </p>
    <p>
     <img alt="" height="527" src="https://i-blog.csdnimg.cn/direct/d5bbf7adddbd49c983ddfe21cc9133e2.png" width="516"/>
    </p>
    <h3 id="3.%C2%A0%E7%89%B9%E7%82%B9" name="3.%C2%A0%E7%89%B9%E7%82%B9">
     3. 特点
    </h3>
    <p>
     <br/>
     <span style="background-color:#ffd900">
      优点：
     </span>
     <br/>
     随机访问：可以通过下标索引快速访问任意位置的元素，时间复杂度为 O(1)。
     <br/>
     存储密度高：由于没有额外的指针存储空间，顺序表的存储利用率较高。
     <br/>
     操作简单：基于数组的实现使得顺序表的操作逻辑相对简单。
     <br/>
     <span style="background-color:#ffd900">
      缺点：
     </span>
     <br/>
     插入和删除效率低：插入或删除元素时，需要移动大量元素以保持顺序表的连续性，时间复杂度为 O(n)。
     <br/>
     存储空间固定：顺序表的存储空间在初始化时需要预先分配，难以动态扩展。如果分配的空间不足，需要重新分配更大的空间并复制数据；如果分配过多，则会浪费空间。
     <br/>
     内存碎片问题：频繁的动态扩展和收缩可能导致内存碎片化。
    </p>
    <h2 id="%E5%9B%9B%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C" name="%E5%9B%9B%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C">
     四 顺序表操作
    </h2>
    <p>
     点h文件中
     <span style="color:#fe2c24">
      定义
     </span>
     了一个顺序表（
     <code>
      SeqList
     </code>
     ）的结构体
    </p>
    <pre><code>#define INIT_SIZE 10 //初始化时malloc购买的格子数量
//可库容的顺序表的结构体设计
typedef int ELEM_TYPE;
typedef struct SeqList
{
	ELEM_TYPE* elem;//用来接收malloc返回的数组首地址
	int length;//存放有效值个数
	int listsize;//存放数组的总的格子数
}SeqList, * PSeqList;</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         作用
        </strong>
        ：定义了一个宏
        <code>
         INIT_SIZE
        </code>
        ，表示顺序表初始化时分配的内存大小（即初始容量）。
       </p>
      </li>
      <li>
       <p>
        <strong>
         值
        </strong>
        ：
        <code>
         INIT_SIZE
        </code>
        被设置为 10，表示初始化时会分配 10 个元素的空间。
       </p>
      </li>
      <li>
       <p>
        <strong>
         结构体名称
        </strong>
        ：
        <code>
         SeqList
        </code>
        ，表示顺序表的结构体。
       </p>
      </li>
      <li>
       <p>
        <strong>
         指针类型别名
        </strong>
        ：
        <code>
         PSeqList
        </code>
        ，表示指向
        <code>
         SeqList
        </code>
        的指针。
       </p>
      </li>
      <li>
       <p>
        <code>
         <span style="background-color:#ffd900">
          ELEM_TYPE*
         </span>
        </code>
        <span style="background-color:#ffd900">
         表示
        </span>
        <code>
         <span style="background-color:#ffd900">
          elem
         </span>
        </code>
        <span style="background-color:#ffd900">
         是一个指针，指向
        </span>
        <code>
         <span style="background-color:#ffd900">
          ELEM_TYPE
         </span>
        </code>
        <span style="background-color:#ffd900">
         类型的数据。
        </span>
        <code>
         <span style="background-color:#ffd900">
          ELEM_TYPE
         </span>
        </code>
        <span style="background-color:#ffd900">
         是一个类型别名
        </span>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="4.1%E5%88%9D%E5%A7%8B%E5%8C%96" name="4.1%E5%88%9D%E5%A7%8B%E5%8C%96">
     4.1初始化
    </h3>
    <p>
     <img alt="" height="148" src="https://i-blog.csdnimg.cn/direct/9b5525d616d144f3a8d15c50be7d3db8.png" width="558"/>
    </p>
    <pre><code>void Init_SeqList(struct SeqList* psl)
{
	//0.安全处理   每一个函数都要写的
	assert(nullptr != psl);
	if (nullptr == psl)
	{
		exit(EXIT_FAILURE);
	}

	//1.对我们的 elem 用来去malloc 在堆区购买一块连续的空间
	psl-&gt;elem = (ELEM_TYPE*)malloc(INIT_SIZE * sizeof(ELEM_TYPE));
	if (NULL == psl-&gt;elem)
	{
		exit(EXIT_FAILURE);
	}

	//2.对我们的 length 初始化为0
	psl-&gt;length = 0;

	//3.对我们的 listsize 初始化为 INITSIZE
	psl-&gt;listsize = INIT_SIZE;

}</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         类型转换
        </strong>
        ：
        <code>
         malloc
        </code>
        返回的是
        <code>
         void*
        </code>
        类型的指针，需要强制转换为
        <code>
         ELEM_TYPE*
        </code>
        。
       </p>
      </li>
      <li>
       <p>
        <strong>
         安全检查
        </strong>
        ：如果
        <code>
         malloc
        </code>
        分配失败（返回
        <code>
         NULL
        </code>
        ），程序会退出。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          length
         </code>
        </strong>
        ：表示顺序表中当前存储的元素个数，初始值为 0。
       </p>
      </li>
      <li>
       <p>
        <strong>
         <code>
          listsize
         </code>
        </strong>
        ：表示顺序表当前分配的总容量，初始值为
        <code>
         INIT_SIZE
        </code>
        。
       </p>
      </li>
      <li>
       <p>
        <code>
         <span style="background-color:#ffd900">
          psl-&gt;elem
         </span>
        </code>
        <span style="background-color:#ffd900">
         存储了这块内存的首地址。
        </span>
       </p>
      </li>
      <li>
       <p>
        <span style="background-color:#ffd900">
         通过
        </span>
        <code>
         <span style="background-color:#ffd900">
          psl-&gt;elem[i]
         </span>
        </code>
        <span style="background-color:#ffd900">
         可以访问顺序表中的第
        </span>
        <code>
         <span style="background-color:#ffd900">
          i
         </span>
        </code>
        <span style="background-color:#ffd900">
         个元素。
        </span>
       </p>
      </li>
      <li>
       <p>
        <strong>
         存储元素
        </strong>
        <span style="color:#fe2c24">
         ：
         <code>
          elem
         </code>
         指向的内存空间被用来存储顺序表中的所有元素。例如，如果
         <code>
          elem
         </code>
         指向的内存空间大小为
         <code>
          INIT_SIZE
         </code>
         ，则可以存储
         <code>
          INIT_SIZE
         </code>
         个
         <code>
          ELEM_TYPE
         </code>
         类型的元素。
        </span>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="4.2%20%E6%8F%92%E5%85%A5" name="4.2%20%E6%8F%92%E5%85%A5">
     4.2 插入
    </h3>
    <h4 id="4.2.1%E5%A4%B4%E6%8F%92" name="4.2.1%E5%A4%B4%E6%8F%92">
     4.2.1头插
    </h4>
    <p>
     <img alt="" height="560" src="https://i-blog.csdnimg.cn/direct/e47b0c09f8164d6bae3c1cdf68eb3e01.png" width="533"/>
    </p>
    <pre><code>bool Insert_Seqlist_head(PSeqList psl, ELEM_TYPE val)
{
	//0.assert
	//0.5 判满
	if (Is_Full(psl))
	{
		Increase(psl);
	}

	//此时，肯定有空闲格子

	//1.集体向后挪(尾巴先动)
	for (int i = psl-&gt;length - 1; i &gt;= 0; i--)
	{
		psl-&gt;elem[i + 1] = psl-&gt;elem[i];
	}

	//2.将val放入0号下标
	psl-&gt;elem[0] = val;

	//3.有效值个数+1
	psl-&gt;length++;
	return true;
}</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         逻辑
        </strong>
        ：从顺序表的尾部开始，逐个将元素向后移动一个位置。
       </p>
       <code>
        <span style="background-color:#ffd900">
         psl-&gt;elem[i + 1] = psl-&gt;elem[i]
        </span>
       </code>
       <span style="background-color:#ffd900">
        ：将第
       </span>
       <code>
        <span style="background-color:#ffd900">
         i
        </span>
       </code>
       <span style="background-color:#ffd900">
        个元素移动到第
       </span>
       <code>
        <span style="background-color:#ffd900">
         i + 1
        </span>
       </code>
       <span style="background-color:#ffd900">
        个位置。
       </span>
      </li>
      <li>
       <p>
        <strong>
         循环条件
        </strong>
        ：从
        <code>
         psl-&gt;length - 1
        </code>
        开始，直到
        <code>
         i = 0
        </code>
        ，确保所有元素都向后移动。
       </p>
      </li>
      <li>
       <p>
        更新顺序表的长度，反映新插入的元素。
       </p>
      </li>
      <li>
       <p>
        函数返回
        <code>
         true
        </code>
        ，表示插入操作成功
       </p>
      </li>
     </ul>
     <p>
      <code>
       <span style="background-color:#ffd900">
        psl-&gt;length
       </span>
      </code>
      <span style="background-color:#ffd900">
      </span>
      表示顺序表中当前存储的有效元素的个数。例如：如果
      <code>
       psl-&gt;length
      </code>
      的值为 5，说明顺序表中有
      <span style="background-color:#ff9900">
       5
      </span>
      个有效元素。
     </p>
     <p>
      <code>
       <span style="background-color:#ffd900">
        psl-&gt;length - 1
       </span>
      </code>
      <span style="background-color:#ffd900">
      </span>
      是对
      <code>
       psl-&gt;length
      </code>
      的值减去 1，如果
      <code>
       psl-&gt;length
      </code>
      为 5，那么最后一个有效元素的索引为
      <code>
       5 - 1 =
       <span style="background-color:#ff9900">
        4
       </span>
      </code>
      。常用于从顺序表的最后一个有效元素开始，逐个向前遍历所有元素
     </p>
    </blockquote>
    <h4 id="4.2.2%20%E5%B0%BE%E6%8F%92" name="4.2.2%20%E5%B0%BE%E6%8F%92">
     4.2.2 尾插
    </h4>
    <p>
     <img alt="" height="178" src="https://i-blog.csdnimg.cn/direct/ed4c0b23c6b249fea9c7d7c396f978e4.png" width="465"/>
    </p>
    <pre><code>bool Insert_Seqlist_tail(PSeqList psl, ELEM_TYPE val)
{
	//0.assert

	//0.5 判满
	if (Is_Full(psl))
	{
		Increase(psl);
	}

	//此时，肯定有空闲格子
	psl-&gt;elem[psl-&gt;length] = val;

	psl-&gt;length++;

	return true;
}</code></pre>
    <h4 id="4.2.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92" name="4.2.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92">
     4.2.3 按位置插
    </h4>
    <p>
     <img alt="" height="413" src="https://i-blog.csdnimg.cn/direct/fd0c8de7d54a40418c11bdceb6d4906e.png" width="433"/>
    </p>
    <pre><code>bool Insert_Seqlist_pos(PSeqList psl, ELEM_TYPE val, int pos)
{
	//默认pos==0 则认为是头插

	//0.安全性处理   psl    pos合法性判断
	assert(nullptr != psl);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= psl-&gt;length);

	//0.5 判满
	if (Is_Full(psl))
	{
		Increase(psl);
	}

	//此时，肯定有空闲格子
	//1.将插入位置之后的元素，统一向后挪动，把插入位置给空出来
	for (int i = psl-&gt;length - 1; i &gt;= pos; i--)
	{
		psl-&gt;elem[i + 1] = psl-&gt;elem[i];
	}

	//2.插入

	psl-&gt;elem[pos] = val;

	//3.length++
	psl-&gt;length++;

	return true;
}</code></pre>
    <blockquote>
     <p>
      <span style="background-color:#ffd900">
       通过
      </span>
      <code>
       <span style="background-color:#ffd900">
        psl-&gt;elem[i]
       </span>
      </code>
      <span style="background-color:#ffd900">
       可以访问顺序表中的第
      </span>
      <code>
       <span style="background-color:#ffd900">
        i
       </span>
      </code>
      <span style="background-color:#ffd900">
       个元素。
      </span>
     </p>
    </blockquote>
    <h3 id="4.3%20%E5%88%A0%E9%99%A4" name="4.3%20%E5%88%A0%E9%99%A4">
     4.3 删除
    </h3>
    <h4 id="4.3.1%20%E5%A4%B4%E5%88%A0" name="4.3.1%20%E5%A4%B4%E5%88%A0">
     4.3.1 头删
    </h4>
    <p>
     <img alt="" height="383" src="https://i-blog.csdnimg.cn/direct/c88670e903424bb49d85e39441430851.png" width="563"/>
    </p>
    <pre><code>bool Del_Seqlist_head(SeqList* psl)
{
	//0.assert

	//0.5 判空
	if (Is_Empty(psl))
		return false;

	//1.除了第一个元素之外，统一向前挪动
	for (int i = 1; i &lt;= psl-&gt;length - 1; i++)
	{
		psl-&gt;elem[i - 1] = psl-&gt;elem[i];
	}

	//2.有效值个数-1
	psl-&gt;length--;

	return true;
}</code></pre>
    <blockquote>
     <p>
      //1.除了第一个元素之外，
      <span style="background-color:#ffd900">
       统一向前挪动
      </span>
      <br/>
      for (int i = 1; i &lt;= psl-&gt;length - 1; i++)
      <br/>
      {
      <!-- -->
      <br/>
      psl-&gt;elem[i - 1] = psl-&gt;elem[i];
      <br/>
      }
     </p>
     <p>
     </p>
     <p>
      //1.
      <span style="background-color:#ffd900">
       集体向后挪(
      </span>
      尾巴先动)
      <br/>
      for (int i = psl-&gt;length - 1; i &gt;= 0; i--)
      <br/>
      {
      <!-- -->
      <br/>
      psl-&gt;elem[i + 1] = psl-&gt;elem[i];
      <br/>
      }
     </p>
    </blockquote>
    <h4 id="4.3.2%20%E5%B0%BE%E5%88%A0" name="4.3.2%20%E5%B0%BE%E5%88%A0">
     4.3.2 尾删
    </h4>
    <p>
     <img alt="" height="178" src="https://i-blog.csdnimg.cn/direct/41c14fef484748e4836c9b3d93e1898c.png" width="524"/>
    </p>
    <pre><code>//尾删
bool Del_Seqlist_tail(SeqList* psl)
{
	//0.assert

	//0.5 判空
	if (Is_Empty(psl))
		return false;

	psl-&gt;length--;

	return true;
}</code></pre>
    <h4 id="%C2%A04.3.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0" name="%C2%A04.3.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0">
     4.3.3 按位置删
    </h4>
    <p>
     <img alt="" height="453" src="https://i-blog.csdnimg.cn/direct/c2411d4383694f2692166fd089c33078.png" width="461"/>
    </p>
    <pre><code>bool Del_Seqlist_pos(SeqList* psl, int pos)
{
	//0.assert psl pos
	assert(psl != NULL);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;length);

	//0.5 判空isempty
	if (Is_Empty(psl))
		return false;

	//1.将pos位置之后的有效值，统一向前覆盖(头先动)
	for (int i = pos + 1; i &lt;= psl-&gt;length - 1; i++)
	{
		psl-&gt;elem[i - 1] = psl-&gt;elem[i];
	}


	//2.有效值个数-1
	psl-&gt;length--;

	return true;
}</code></pre>
    <h4 id="4.3.4%20%E6%8C%89%E5%80%BC%E5%88%A0" name="4.3.4%20%E6%8C%89%E5%80%BC%E5%88%A0">
     4.3.4 按值删
    </h4>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/direct/6e79982461304647b692763ad749bd05.png" width="468"/>
    </p>
    <pre><code>
//按值删(只删除这个val值出现的第一次的位置)
bool Del_Seqlist_val(SeqList* psl, ELEM_TYPE val)
{
	//0.assert
	//0.5 isempty

	//1.通过调用查找函数，查找val值在顺序表中的位置
	int index = Search_SeqList(psl, val);

	//2.若返回的位置下标为-1 返回假  若不等于-1，则此时怎么删
	if (index == -1)
		return false;

	return Del_Seqlist_pos(psl, index);
}</code></pre>
    <h3 id="4.4%20%E6%9F%A5%E6%89%BE%C2%A0" name="4.4%20%E6%9F%A5%E6%89%BE%C2%A0">
     4.4 查找
    </h3>
    <pre><code>
//4.查找数据是否已经存在(若存在，则只需要返回下标即可  找不到返回-1)
int Search_SeqList(PSeqList psl, ELEM_TYPE val)
{
	//0.assert

	for (int i = 0; i &lt; psl-&gt;length; i++)
	{
		if (psl-&gt;elem[i] == val)
			return i;
	}

	return -1;
}</code></pre>
    <h3 id="4.5%20%E5%88%A0%E9%99%A4%E5%80%BCval%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE" name="4.5%20%E5%88%A0%E9%99%A4%E5%80%BCval%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE">
     4.5 删除值val出现的位置
    </h3>
    <p>
     <img alt="" height="308" src="https://i-blog.csdnimg.cn/direct/c4a9748d778a4c43837b977019332436.png" width="587"/>
    </p>
    <pre><code>//删除当前val值出现的所有位置(1)
bool Del_SeqList_All_Val1(struct SeqList* psl, ELEM_TYPE val)
{
	int count = 0;
	for (int i = 0; i &lt; psl-&gt;length; i++)
	{
		if (psl-&gt;elem[i] == val)
		{
			count++;
		}
	}

	for (int i = 0; i &lt; count; i++)
	{
		int index = Search_SeqList(psl, val);
		Del_Seqlist_pos(psl, index);
	}

	return true;

}</code></pre>
    <p>
     <img alt="" height="203" src="https://i-blog.csdnimg.cn/direct/26155a4bfe4b4bcc9e27d00287f4ae25.png" width="651"/>
    </p>
    <pre><code>//删除当前val值出现的所有位置(2)
bool Del_SeqList_All_Val2(struct SeqList* psl, ELEM_TYPE val)
{
	int qianfangkongxiangezishu = 0;
	for (int i = 0; i &lt; psl-&gt;length; i++)
	{
		if (psl-&gt;elem[i] == val)
			qianfangkongxiangezishu++;
		else
			psl-&gt;elem[i - qianfangkongxiangezishu] = psl-&gt;elem[i];
	}
	psl-&gt;length = psl-&gt;length - qianfangkongxiangezishu;
	return true;
}</code></pre>
    <h3 id="4.6%20%E5%85%B6%E4%BD%99%E6%93%8D%E4%BD%9C" name="4.6%20%E5%85%B6%E4%BD%99%E6%93%8D%E4%BD%9C">
     4.6 其余操作
    </h3>
    <pre><code>//5.判空
bool Is_Empty(PSeqList psl)
{
	return psl-&gt;length == 0;
}

//6.判满
bool Is_Full(PSeqList psl)
{
	return psl-&gt;length == psl-&gt;listsize;
}

//7.扩容函数(1.5 2)   默认用2倍扩容
void Increase(PSeqList psl)
{
	ELEM_TYPE* tmp = (ELEM_TYPE*)realloc(psl-&gt;elem, psl-&gt;listsize * sizeof(ELEM_TYPE) * 2);
	if (tmp != nullptr)
	{
		psl-&gt;elem = tmp;
	}

}

//8.清空  (不释放已购买的内存)
void Clear(PSeqList psl)
{
	//malloc申请空间先不释放，而是认为所有格子里都是无效值
	psl-&gt;length = 0;
}

//9.销毁  (需要释放malloc购买的内存的)
void Destroy(PSeqList psl)
{
	free(psl-&gt;elem);
	psl-&gt;length = psl-&gt;listsize = 0;
}


//打印
void Show(PSeqList psl)
{
	//assert

	for (int i = 0; i &lt; psl-&gt;length; i++)
	{
		printf("%d ", psl-&gt;elem[i]);
	}

	printf("\n");

}</code></pre>
    <h3 id="4.7%20%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95" name="4.7%20%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95">
     4.7 主函数测试
    </h3>
    <pre><code>int main()
{
	struct SeqList sq;

	Init_SeqList(&amp;sq);

	Insert_Seqlist_head(&amp;sq, 100);
	Insert_Seqlist_head(&amp;sq, 101);
	Insert_Seqlist_head(&amp;sq, 102);
	Insert_Seqlist_tail(&amp;sq, 200);
	Insert_Seqlist_tail(&amp;sq, 201);
	Insert_Seqlist_tail(&amp;sq, 202);
	Insert_Seqlist_tail(&amp;sq, 2000);
	Insert_Seqlist_tail(&amp;sq, 2010);
	Insert_Seqlist_tail(&amp;sq, 2020);
	Insert_Seqlist_pos(&amp;sq, 10000, 3);
	Show(&amp;sq);

	Insert_Seqlist_head(&amp;sq, 111);
	Insert_Seqlist_tail(&amp;sq, 222);
	Show(&amp;sq);

	//删除
	Del_Seqlist_head(&amp;sq);
	Del_Seqlist_tail(&amp;sq);
	Show(&amp;sq);

	Del_Seqlist_pos(&amp;sq, 4);
	Show(&amp;sq);
	Del_Seqlist_pos(&amp;sq, 8);
	Show(&amp;sq);
	Del_Seqlist_pos(&amp;sq, 0);
	Show(&amp;sq);

	Del_Seqlist_val(&amp;sq, 201);
	Show(&amp;sq);

	//Clear(&amp;sq);
	//Show(&amp;sq);

	//Destroy(&amp;sq);
	//Show(&amp;sq);

	//------------------------------------------------
	Insert_Seqlist_pos(&amp;sq, 3, 2);
	Insert_Seqlist_pos(&amp;sq, 3, 4);
	Insert_Seqlist_pos(&amp;sq, 3, 6);
	Show(&amp;sq);

	Del_SeqList_All_Val2(&amp;sq, 3);
	Show(&amp;sq);

	return 0;
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37353139373930362f:61727469636c652f64657461696c732f313436303339323039" class_="artid" style="display:none">
 </p>
</div>


