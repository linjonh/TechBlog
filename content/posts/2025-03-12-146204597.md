---
layout: post
title: "JVM的垃圾回收器都有哪些"
date: 2025-03-12 14:49:27 +0800
description: "在 Java 虚拟机（JVM）中，不同的垃圾回收器采用不同的算法和策略，以满足不同应用场景的性能需求。"
keywords: "JVM的垃圾回收器都有哪些？"
categories: ['未分类']
tags: ['测试工具', 'Jvm']
artid: "146204597"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146204597
    alt: "JVM的垃圾回收器都有哪些"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146204597
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146204597
cover: https://bing.ee123.net/img/rand?artid=146204597
image: https://bing.ee123.net/img/rand?artid=146204597
img: https://bing.ee123.net/img/rand?artid=146204597
---

# JVM的垃圾回收器都有哪些？

在 Java 虚拟机（JVM）中，不同的垃圾回收器采用不同的算法和策略，以满足不同应用场景的性能需求。以下为你详细介绍常见的 JVM 垃圾回收器：

#### 新生代垃圾回收器

##### 1\. Serial 收集器

  * **特点** ：单线程的垃圾回收器，在进行垃圾回收时，必须暂停其他所有的工作线程（Stop The World，简称 STW），直到垃圾回收完成。
  * **适用场景** ：适用于客户端模式下的小型应用程序，因为它的实现简单，没有线程交互的开销，在单 CPU 环境下有较好的性能。
  * **启用参数** ：`-XX:+UseSerialGC`

##### 2\. ParNew 收集器

  * **特点** ：Serial 收集器的多线程版本，同样会产生 STW 现象，但它可以利用多个 CPU 核心并行进行垃圾回收，从而提高垃圾回收的效率。
  * **适用场景** ：常与老年代的 CMS 收集器配合使用，在注重响应时间的服务器应用中较为常见。
  * **启用参数** ：`-XX:+UseParNewGC`

##### 3\. Parallel Scavenge 收集器

  * **特点** ：也是一款多线程的新生代收集器，它的目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间））。它可以自动调节新生代的大小、Eden 区和 Survivor 区的比例等参数，以达到预设的吞吐量目标。
  * **适用场景** ：适用于那些对吞吐量要求较高、对停顿时间要求不是特别苛刻的应用，如后台运算等。
  * **启用参数** ：`-XX:+UseParallelGC`

#### 老年代垃圾回收器

##### 1\. Serial Old 收集器

  * **特点** ：Serial 收集器的老年代版本，同样是单线程收集器，使用标记 - 整理算法。
  * **适用场景** ：主要用于客户端模式，或者在 Server 模式下作为 CMS 收集器发生失败时的后备预案。
  * **启用参数** ：`-XX:+UseSerialGC`（同时会启用 Serial 作为新生代收集器）

##### 2\. Parallel Old 收集器

  * **特点** ：Parallel Scavenge 收集器的老年代版本，多线程收集器，使用标记 - 整理算法。它的出现是为了在注重吞吐量的场景下，与 Parallel Scavenge 收集器配合使用，进一步提高系统的整体吞吐量。
  * **适用场景** ：与 Parallel Scavenge 收集器搭配，适用于对吞吐量要求较高的服务器应用。
  * **启用参数** ：`-XX:+UseParallelOldGC`

##### 3\. CMS（Concurrent Mark Sweep）收集器

  * **特点** ：以获取最短回收停顿时间为目标的收集器，采用标记 - 清除算法。它的整个过程分为初始标记、并发标记、重新标记和并发清除四个阶段，其中初始标记和重新标记阶段会产生 STW，但停顿时间相对较短，而并发标记和并发清除阶段可以与用户线程并发执行。
  * **适用场景** ：适用于对响应时间要求较高的应用，如 Web 应用等。
  * **启用参数** ：`-XX:+UseConcMarkSweepGC`

#### 全堆垃圾回收器

##### 1\. G1（Garbage - First）收集器

  * **特点** ：面向服务端应用的垃圾回收器，将堆内存划分为多个大小相等的 Region，它可以预测垃圾回收的停顿时间，并根据用户指定的停顿时间目标，优先回收价值最大的 Region。G1 收集器采用标记 - 整理和复制算法，整体上看是标记 - 整理算法，局部（Region 之间）是复制算法，不会产生内存碎片。
  * **适用场景** ：适用于大内存、多 CPU 的服务器应用，能较好地满足对响应时间和吞吐量的综合要求。
  * **启用参数** ：`-XX:+UseG1GC`

##### 2\. ZGC（Z Garbage Collector）

  * **特点** ：可伸缩的低延迟垃圾回收器，它的停顿时间几乎可以忽略不计，最大停顿时间不超过 10 毫秒。ZGC 采用染色指针和读屏障技术，能够在并发的情况下完成对象的标记、移动等操作。
  * **适用场景** ：适用于对低延迟要求极高的应用，如大型在线游戏、金融交易系统等。
  * **启用参数** ：`-XX:+UseZGC`

##### 3\. Shenandoah 收集器

  * **特点** ：与 ZGC 类似，也是一款追求极低延迟的垃圾回收器，它通过与用户线程并发执行大部分的垃圾回收工作，减少了 STW 时间。
  * **适用场景** ：适用于对延迟非常敏感的应用场景。
  * **启用参数** ：`-XX:+UseShenandoahGC`

新生代往往和老年代回收器是配合使用一般搭配如下：

  * Serial 和 Serial Old
  * ParNew 和CMS
  * Parallel Scavenge 和 Parallel Old

G1、ZGC和Shenandoah则都是不区分

不同的垃圾回收器有不同的特点和适用场景，在实际应用中，需要根据应用的内存使用情况、性能要求等因素选择合适的垃圾回收器。



