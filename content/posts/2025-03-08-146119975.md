---
layout: post
title: "RabbitMQ之旅1"
date: 2025-03-08 19:07:25 +0800
description: "通道的设计是为了复用连接，避免频繁创建和销毁连接的开销。创建通道后，通常会用它来声明队列、发送消息或消费消息。你可以通过这个工厂对象预先设置连接参数（如服务器地址、端口、用户名、密码等），然后通过它来生成具体的连接对象。假如有十条队列消息,C1和C2是共同消费这10条消息,消息不会重复消费。：当队列中有消息时，RabbitMQ 会调用此方法将消息传递给消费者。消费者接收到消息后，RabbitMQ 会自动将消息标记为已处理。是一个设计模式中的“工厂类”，它的目的是。：RabbitMQ 提供的默认消费者类。"
keywords: "channel.queuebind如何不声明交换机"
categories: ['未分类']
tags: ['分布式', 'Rabbitmq']
artid: "146119975"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146119975
    alt: "RabbitMQ之旅1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146119975
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146119975
cover: https://bing.ee123.net/img/rand?artid=146119975
image: https://bing.ee123.net/img/rand?artid=146119975
img: https://bing.ee123.net/img/rand?artid=146119975
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ之旅(1)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p style="text-align:center">
    </p>
    <blockquote>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        相信自
       </strong>
       <strong>
        己,终会成功
       </strong>
      </span>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/c089ed3a0b0a4cc5a7e42e9f401a7235.jpeg" width="287"/>
      </span>
     </p>
    </blockquote>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="%E4%B8%BB%E6%B5%81MQ%E4%BA%A7%E5%93%81" name="%E4%B8%BB%E6%B5%81MQ%E4%BA%A7%E5%93%81">
     主流MQ产品
    </h3>
    <h4 id="1.kafaka%C2%A0" name="1.kafaka%C2%A0">
     1.kafaka
    </h4>
    <ol>
     <li>
      <strong>
       特点
      </strong>
      ：高吞吐量、分布式、持久化、支持分区和副本。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：日志收集、流处理、实时数据分析等大数据场景。
     </li>
     <li>
      <strong>
       优势
      </strong>
      ：高吞吐量和低延迟，适合处理大量数据。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：配置复杂，对小型项目可能过于重量级。
     </li>
    </ol>
    <h4 id="2.RocketMQ" name="2.RocketMQ">
     2.RocketMQ
    </h4>
    <ol>
     <li>
      <strong>
       特点
      </strong>
      ：分布式、高吞吐量、低延迟、支持事务消息。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：电商、金融等需要高可靠性和事务支持的场景。
     </li>
     <li>
      <strong>
       优势
      </strong>
      ：支持事务消息，适合金融等高可靠性要求的场景。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：社区相对较小，文档和资源不如Kafka丰富。
     </li>
    </ol>
    <h4 id="3.RabbitMQ" name="3.RabbitMQ">
     3.RabbitMQ
    </h4>
    <ol>
     <li>
      <strong>
       特点
      </strong>
      ：轻量级、支持多种消息协议、易于使用和部署。
     </li>
     <li>
      <strong>
       适用场景
      </strong>
      ：中小型项目、需要快速上手的场景。
     </li>
     <li>
      <strong>
       优势
      </strong>
      ：易于使用，支持多种消息协议，社区活跃。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：在大规模高并发场景下性能不如Kafka和RocketMQ。
     </li>
    </ol>
    <hr/>
    <h3 id="%E5%9C%A8xshell%E4%B8%8A%E5%AE%89%E8%A3%85RabbitMQ" name="%E5%9C%A8xshell%E4%B8%8A%E5%AE%89%E8%A3%85RabbitMQ">
     在xshell上安装RabbitMQ
    </h3>
    <p>
     1.更新xshell中最新的软件包列表
    </p>
    <pre><code>sudo apt-get update
</code></pre>
    <p>
     2.安装erlang
    </p>
    <pre><code>sudo apt-get install erlang</code></pre>
    <p>
     输入erl,出现下图内容表示安装成功  输入halt().退出即可
    </p>
    <p>
     <img alt="" height="41" src="https://i-blog.csdnimg.cn/direct/c52e09c2a8ba47c4b739d81806f0c662.png" width="598"/>
    </p>
    <p>
     3.安装rabbitmq
    </p>
    <pre><code>sudo apt-get install rabbitmq-server</code></pre>
    <p>
     4.确认安装结果
    </p>
    <pre><code>systemctl status rabbitmq-server</code></pre>
    <p>
     显示running即可
    </p>
    <p>
     <img alt="" height="61" src="https://i-blog.csdnimg.cn/direct/9b6fafa95dfc4e22ab51a4577a96e313.png" width="606"/>
    </p>
    <p>
     5.安装RabbitMQ管理界面
    </p>
    <pre><code>rabbitmq-plugins enable rabbiting_management</code></pre>
    <p>
     6.启动服务
    </p>
    <pre><code>sudo service rabbitmq-server start
</code></pre>
    <p>
     在浏览器中输入自己云服务器的端口号+15672即可访问页面
    </p>
    <p>
     <img alt="" height="279" src="https://i-blog.csdnimg.cn/direct/9c382bfb836140229cc11a72197b21e9.png" width="492"/>
    </p>
    <p>
     添加用户名和密码
    </p>
    <pre><code>rabbitmqctl add_user 用户名 密码</code></pre>
    <p>
     给用户权限
    </p>
    <pre><code>rabbitmqctl set_user_tags 用户名 权限等级</code></pre>
    <hr/>
    <h3 id="%C2%A0RabbitMQ%E4%B8%83%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" name="%C2%A0RabbitMQ%E4%B8%83%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">
     RabbitMQ七种工作模式
    </h3>
    <blockquote>
     <p>
      <span style="color:null">
       <strong>
        P:生产者        C:消费者
       </strong>
      </span>
     </p>
     <p>
      <span style="color:null">
       <strong>
        queue:队列   X:交换机
       </strong>
      </span>
     </p>
     <p>
      <span style="color:null">
       <strong>
        在使用绑定的时候为 BindingKey
       </strong>
      </span>
     </p>
     <p>
      <span style="color:null">
       <strong>
        在发送消息的时候为RoutingKey
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        官方网站:
       </strong>
      </span>
      <a href="https://www.rabbitmq.com/tutorials#1-hello-world" rel="nofollow" title="RabbitMQ Tutorials | RabbitMQ">
       RabbitMQ Tutorials | RabbitMQ
      </a>
     </p>
    </blockquote>
    <p>
     建立连接需要的信息:
    </p>
    <p>
     1.IP   2.端口号   3.账号   4.密码   5. 虚拟主机
    </p>
    <p>
     消费者代码:
    </p>
    <p>
     1.创建连接  2.创建Channel  3.声明一个队列Queue  4.消费信息  5.释放资源
    </p>
    <p>
    </p>
    <h4 id="1.%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F" name="1.%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F">
     1.简单模式
    </h4>
    <p>
     一个生产者,一个消费者,点到点模式
    </p>
    <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="100" src="https://i-blog.csdnimg.cn/direct/c7c2a132dff7488a80b1e04dcb885f20.png" width="399"/>
    </h4>
    <p>
    </p>
    <p>
    </p>
    <h4 id="2.%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F" name="2.%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F">
     2.工作队列模式
    </h4>
    <p>
     一个生产者,多个消费者
    </p>
    <p>
     假如有十条队列消息,C1和C2是共同消费这10条消息,消息不会重复消费
    </p>
    <p>
     <img alt="" height="210" src="https://i-blog.csdnimg.cn/direct/cbe7e05e170c4e79b3f32beb0e433c5e.png" width="373"/>
    </p>
    <h4 id="3.%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F" name="3.%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F">
     3.发布/订阅模式
    </h4>
    <p>
     <img alt="" height="199" src="https://i-blog.csdnimg.cn/direct/36f05727bd564190923ea7f1e498539c.png" width="376"/>
    </p>
    <p>
     <img alt="" height="199" src="https://i-blog.csdnimg.cn/direct/9f803155505a4a2d9dedbfd1389484b3.png" width="327"/>
    </p>
    <h4 id="4.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F" name="4.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F">
     4.路由模式
    </h4>
    <p>
     订阅模式的变化形式
    </p>
    <p>
     <img alt="" height="202" src="https://i-blog.csdnimg.cn/direct/43592cee467d4df39bc093cc1b8489b8.png" width="373"/>
    </p>
    <p>
    </p>
    <h4 id="5.%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F" name="5.%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F">
     5.通配符模式
    </h4>
    <p>
    </p>
    <p>
     <img alt="" height="184" src="https://i-blog.csdnimg.cn/direct/69c6eaec470a4e83a61d1d7db548c2ed.png" width="364"/>
    </p>
    <p>
     <img alt="" height="205" src="https://i-blog.csdnimg.cn/direct/8c5fe7a86b86446383cb4f26810a0a47.png" width="387"/>
    </p>
    <h4 id="6.RPC%E6%A8%A1%E5%BC%8F" name="6.RPC%E6%A8%A1%E5%BC%8F" style="background-color:transparent">
     6.RPC模式
    </h4>
    <p>
     <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/8e5698b751994020b9116aca157fd730.png" width="399"/>
    </p>
    <p>
     <img alt="" height="435" src="https://i-blog.csdnimg.cn/direct/c27e37624c254478ad34bac788dab93c.png" width="650"/>
    </p>
    <h5 id="AMQP.BasicProperties%20%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB" name="AMQP.BasicProperties%20%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB">
     AMQP.BasicProperties 设置消息属性的类
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        属性名
       </th>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         <code>
          contentType
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        消息内容的 MIME 类型（如
        <code>
         text/plain
        </code>
        、
        <code>
         application/json
        </code>
        ）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          contentEncoding
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        消息内容的编码方式（如
        <code>
         UTF-8
        </code>
        ）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          headers
         </code>
        </strong>
       </td>
       <td>
        <code>
         Map&lt;String, Object&gt;
        </code>
       </td>
       <td>
        自定义消息头，用于传递额外信息。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          deliveryMode
         </code>
        </strong>
       </td>
       <td>
        <code>
         Integer
        </code>
       </td>
       <td>
        消息的持久化模式：
        <code>
         1
        </code>
        （非持久化）或
        <code>
         2
        </code>
        （持久化）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          priority
         </code>
        </strong>
       </td>
       <td>
        <code>
         Integer
        </code>
       </td>
       <td>
        消息的优先级（0 到 9，数值越大优先级越高）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          correlationId
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        关联 ID，通常用于 RPC 模式，匹配请求和响应。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          replyTo
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        响应队列的名称，通常用于 RPC 模式。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          expiration
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        消息的过期时间（以毫秒为单位的字符串）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          messageId
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        消息的唯一标识符。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          timestamp
         </code>
        </strong>
       </td>
       <td>
        <code>
         Date
        </code>
       </td>
       <td>
        消息的时间戳。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          type
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        消息的类型标识符。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          userId
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        用户 ID，用于验证消息的发送者。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          appId
         </code>
        </strong>
       </td>
       <td>
        <code>
         String
        </code>
       </td>
       <td>
        应用程序 ID，用于标识发送消息的应用程序。
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code>//        AMQP.BasicProperties 是一个不可变类，因此需要通过其内部类 Builder 来创建对象。
        AMQP.BasicProperties props = new AMQP.BasicProperties().builder()
                .correlationId(correlationID)
                .replyTo(Constants.RPC_RESPONSE_QUEUE)
                .build();</code></pre>
    <blockquote>
     <ol>
      <li>
       <p>
        <strong>
         客户端
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          生成唯一的
          <code>
           correlationId
          </code>
          。
         </p>
        </li>
        <li>
         <p>
          设置
          <code>
           replyTo
          </code>
          为响应队列的名称。
         </p>
        </li>
        <li>
         <p>
          发送消息到请求队列（
          <code>
           Constants.RPC_REQUEST_QUEUE
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          监听响应队列（
          <code>
           Constants.RPC_RESPONSE_QUEUE
          </code>
          ），等待服务器返回结果。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         服务器
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          监听请求队列（
          <code>
           Constants.RPC_REQUEST_QUEUE
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          处理请求后，将结果发送到客户端指定的响应队列（
          <code>
           replyTo
          </code>
          ）。
         </p>
        </li>
        <li>
         <p>
          在响应消息中设置与请求相同的
          <code>
           correlationId
          </code>
          。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         客户端匹配响应
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          收到响应后，根据
          <code>
           correlationId
          </code>
          匹配对应的请求。
         </p>
        </li>
       </ul>
      </li>
     </ol>
    </blockquote>
    <h4 id="7.%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E6%A8%A1%E5%BC%8F" name="7.%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E6%A8%A1%E5%BC%8F">
     7.发布确认模式
    </h4>
    <p>
     是RabbitMQ消息可靠性保证的关键
    </p>
    <hr/>
    <h3 id="%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA(%E7%94%9F%E4%BA%A7%E8%80%85)" name="%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA(%E7%94%9F%E4%BA%A7%E8%80%85)">
     代码展示(生产者)
    </h3>
    <p>
     下图的代码Constants是自己写的
     <strong>
      Java 常量
     </strong>
    </p>
    <blockquote>
     <h4 id="%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" name="%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">
      <strong>
       常量命名规范
      </strong>
     </h4>
     <p>
      1.常量名使用
      <strong>
       全大写字母
      </strong>
      ，并用下划线
      <code>
       _
      </code>
      分隔单词（如
      <code>
       VIRTUALHOST
      </code>
      和
      <code>
       WORK_QUEUE
      </code>
      ）。
     </p>
     <p>
      2.这是 Java 中的命名约定，便于区分常量和变量。
     </p>
    </blockquote>
    <pre><code>//1. 建立连接
        ConnectionFactory connectionFactory = new ConnectionFactory();

        connectionFactory.setHost(Constants.HOST); //云服务器的IP地址
        connectionFactory.setPort(Constants.PORT); //需要提前开放端口号
        connectionFactory.setUsername(Constants.USER_NAME);//账号
        connectionFactory.setPassword(Constants.PASSWORD);  //密码
        connectionFactory.setVirtualHost(Constants.VIRTUALHOST); //虚拟主机


        //2. 开启信道
        Channel channel = connection.createChannel();
        //3. 声明交换机   使用内置的交换机</code></pre>
    <h4 id="%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%20(ConnectionFactory)%C2%A0" name="%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%20(ConnectionFactory)%C2%A0">
     <strong>
      连接工厂 (
      <code>
       ConnectionFactory
      </code>
      )
     </strong>
    </h4>
    <p>
     是一个设计模式中的“工厂类”，它的目的是
     <strong>
      隐藏创建连接的复杂细节
     </strong>
     （比如网络配置、认证信息等）。你可以通过这个工厂对象预先设置连接参数（如服务器地址、端口、用户名、密码等），然后通过它来生成具体的连接对象
    </p>
    <h4 id="Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89" name="Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89">
     <strong>
      Channel（通道）
     </strong>
    </h4>
    <div>
    </div>
    <p>
     <strong>
      通道
     </strong>
     是建立在连接（
     <code>
      Connection
     </code>
     ）之上的一个轻量级逻辑连接。一个连接（
     <code>
      Connection
     </code>
     ）可以创建多个通道，每个通道可以独立地发送和接收消息。通道的设计是为了复用连接，避免频繁创建和销毁连接的开销。创建通道后，通常会用它来声明队列、发送消息或消费消息
    </p>
    <h5 id="channel.queueDeclare%C2%A0" name="channel.queueDeclare%C2%A0">
     channel.queueDeclare 声明队列
    </h5>
    <pre><code>//4.声明队列
        
channel.queueDeclare(Constants.WORK_QUEUE,true,false,false,null);

         /**
         * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
         *                                  Map&lt;String, Object&gt; arguments)
         *  参数说明:
         *  queue: 队列名称
         *  durable: 可持久化
         *  exclusive: 是否独占
         *  autoDelete: 是否自动删除
         *  arguments: 参数
         */</code></pre>
    <p>
     <img alt="" height="551" src="https://i-blog.csdnimg.cn/direct/e5cafa42fcaf495da1e2e386ff06ca80.png" width="573"/>
    </p>
    <h5 id="channel.basicPublish%C2%A0" name="channel.basicPublish%C2%A0">
     channel.basicPublish 发送消息
    </h5>
    <pre><code>        //5. 发送消息
        /**
         * basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)
         * 参数说明:
         * exchange: 交换机名称
         * routingKey: 内置交换机, routingkey和队列名称保持一致
         * props: 属性配置
         * body: 消息
         */
        for (int i = 0; i &lt; 10; i++) {
            String msg = "hello rabbitmq~"+i;
            channel.basicPublish("","hello", null, msg.getBytes());
        }
</code></pre>
    <p>
     <img alt="" height="447" src="https://i-blog.csdnimg.cn/direct/ad4ccfd89df64d319ce718b15f03f82c.png" width="617"/>
    </p>
    <p>
     <img alt="" height="148" src="https://i-blog.csdnimg.cn/direct/e1cf205e6c4745a9b27112e02656e6fd.png" width="619"/>
    </p>
    <pre><code> //6. 资源释放
        channel.close();
        connection.close();</code></pre>
    <h5 id="channel.exchangeDeclare%C2%A0" name="channel.exchangeDeclare%C2%A0">
     channel.exchangeDeclare 声明创建交换机
    </h5>
    <pre><code>Exchange.DeclareOk exchangeDeclare(
    String exchange,              // 交换机名称
    String type,                  // 交换机类型（direct、fanout、topic、headers）
    boolean durable,              // 是否持久化
    boolean autoDelete,           // 是否自动删除
    boolean internal,            // 是否内部交换机
    Map&lt;String, Object&gt; arguments // 额外参数
) throws IOException;</code></pre>
    <p>
     <img alt="" height="379" src="https://i-blog.csdnimg.cn/direct/842e122c288946be9978c4acb2064194.png" width="634"/>
    </p>
    <p>
     <img alt="" height="287" src="https://i-blog.csdnimg.cn/direct/5f9c8ff715324a7fa462fa48a284c9ac.png" width="663"/>
    </p>
    <h5 id="channel.queueBind()%C2%A0" name="channel.queueBind()%C2%A0">
     <code>
      channel.queueBind()
     </code>
     将队列绑定到交换机
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         queue
        </code>
       </strong>
       ：队列名称（如
       <code>
        Constants.PUBLISH_QUEUE1
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         exchange
        </code>
       </strong>
       ：交换机名称（如
       <code>
        Constants.PUBLISH_EXCHANGE
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         routingKey
        </code>
       </strong>
       ：路由键（如
       <code>
        ""
       </code>
       或
       <code>
        "key1"
       </code>
       ）
      </p>
     </li>
    </ul>
    <pre><code>channel.queueBind(Constants.PUBLISH_QUEUE1, Constants.PUBLISH_EXCHANGE, "");
channel.queueBind(Constants.PUBLISH_QUEUE2, Constants.PUBLISH_EXCHANGE, "");
//作用：将 Constants.PUBLISH_QUEUE1 和 Constants.PUBLISH_QUEUE2 绑定到 //Constants.PUBLISH_EXCHANGE。
//路由键为空字符串（""），表示所有消息都会被路由到这两个队列（前提是交换机类型支持）。</code></pre>
    <h5 id="channel.basicQos%E8%AE%BE%E7%BD%AE%E6%B6%88%E8%B4%B9%E8%80%85%E9%A2%84%E5%8F%96%E9%99%90%E5%88%B6" name="channel.basicQos%E8%AE%BE%E7%BD%AE%E6%B6%88%E8%B4%B9%E8%80%85%E9%A2%84%E5%8F%96%E9%99%90%E5%88%B6">
     channel.basicQos设置消费者预取限制
    </h5>
    <table>
     <thead>
      <tr>
       <th style="width:129px">
        参数名
       </th>
       <th style="width:78px">
        类型
       </th>
       <th style="width:481px">
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="width:129px">
        <strong>
         <code>
          prefetchSize
         </code>
        </strong>
       </td>
       <td style="width:78px">
        <code>
         int
        </code>
       </td>
       <td style="width:481px">
        预取消息的总大小（以字节为单位），通常设置为
        <code>
         0
        </code>
        表示不限制大小。
       </td>
      </tr>
      <tr>
       <td style="width:129px">
        <strong>
         <code>
          prefetchCount
         </code>
        </strong>
       </td>
       <td style="width:78px">
        <code>
         int
        </code>
       </td>
       <td style="width:481px">
        预取消息的数量限制（即未确认消息的最大数量）。
       </td>
      </tr>
      <tr>
       <td style="width:129px">
        <strong>
         <code>
          global
         </code>
        </strong>
       </td>
       <td style="width:78px">
        <code>
         boolean
        </code>
       </td>
       <td style="width:481px">
        是否全局生效：
        <code>
         true
        </code>
        表示对整个 Channel 生效，
        <code>
         false
        </code>
        表示对每个消费者生效。
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code>// 设置每个消费者最多预取 10 条未确认消息
channel.basicQos(10);

// 设置整个 Channel 最多预取 100 条未确认消息
channel.basicQos(100, true);

// 设置预取消息的总大小不超过 1MB，数量不超过 10 条
channel.basicQos(1024 * 1024, 10, false);</code></pre>
    <h5 id="channel.basicAck%20%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF" name="channel.basicAck%20%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF">
     channel.basicAck 手动确认消息
    </h5>
    <table>
     <thead>
      <tr>
       <th style="width:139px">
        参数名
       </th>
       <th style="width:111px">
        类型
       </th>
       <th style="width:439px">
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="width:139px">
        <strong>
         <code>
          deliveryTag
         </code>
        </strong>
       </td>
       <td style="width:111px">
        <code>
         long
        </code>
       </td>
       <td style="width:439px">
        消息的唯一标识符，由 RabbitMQ 分配。
       </td>
      </tr>
      <tr>
       <td style="width:139px">
        <strong>
         <code>
          multiple
         </code>
        </strong>
       </td>
       <td style="width:111px">
        <code>
         boolean
        </code>
       </td>
       <td style="width:439px">
        是否批量确认：
        <code>
         true
        </code>
        表示确认所有比
        <code>
         deliveryTag
        </code>
        小的消息；
        <code>
         false
        </code>
        表示仅确认当前消息。
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      <strong>
       使用场景
      </strong>
     </p>
     <ul>
      <li>
       <p>
        <strong>
         手动确认模式
        </strong>
        ：当消费者从队列中拉取消息时，如果启用了手动确认模式（
        <code>
         autoAck=false
        </code>
        ），则必须调用
        <code>
         basicAck
        </code>
        来确认消息。
       </p>
      </li>
      <li>
       <p>
        <strong>
         确保消息可靠性
        </strong>
        ：通过手动确认，可以确保消息在处理成功后才会从队列中删除，避免消息丢失。
       </p>
      </li>
      <li>
       <p>
        <strong>
         批量确认
        </strong>
        ：通过设置
        <code>
         multiple=true
        </code>
        ，可以一次性确认多条消息，提高效率。
       </p>
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h3 id="%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA(%E6%B6%88%E8%B4%B9%E8%80%85)" name="%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA(%E6%B6%88%E8%B4%B9%E8%80%85)">
     代码展示(消费者)
    </h3>
    <pre><code>public static void main(String[] args) throws IOException, TimeoutException {
        //1. 建立连接
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(Constants.HOST);
        connectionFactory.setPort(Constants.PORT); //需要提前开放端口号
        connectionFactory.setUsername(Constants.USER_NAME);//账号
        connectionFactory.setPassword(Constants.PASSWORD);  //密码
        connectionFactory.setVirtualHost(Constants.VIRTUAL_HOST); //虚拟主机
        Connection connection = connectionFactory.newConnection();
        //2. 开启信道
        Channel channel = connection.createChannel();
        //3. 声明队列   使用内置的交换机
        //如果队列不存在, 则创建, 如果队列存在, 则不创建
        channel.queueDeclare(Constants.WORK_QUEUE, true, false, false, null);
        //4. 消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel){
            //从队列中收到消息, 就会执行的方法
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息:"+ new String(body));
            }
        };
        channel.basicConsume(Constants.WORK_QUEUE, true, consumer);

        6. 资源释放
        channel.close();
        connection.close();
    }</code></pre>
    <p>
    </p>
    <h4 id="DefaultConsumer%EF%BC%9A" name="DefaultConsumer%EF%BC%9A">
     <strong>
      <code>
       DefaultConsumer
      </code>
     </strong>
     ：
    </h4>
    <p>
     RabbitMQ 提供的默认消费者类。
    </p>
    <p>
     <strong>
      <code>
       channel
      </code>
     </strong>
     ：消费者绑定的通道（Channel）。
    </p>
    <p>
     <strong>
      匿名内部类
     </strong>
     ：通过
     <code>
      new DefaultConsumer(channel) { ... }
     </code>
     创建一个匿名内部类，并写
     <code>
      handleDelivery
     </code>
     方法。
    </p>
    <h4 id="handleDelivery%C2%A0%E6%96%B9%E6%B3%95%EF%BC%9A" name="handleDelivery%C2%A0%E6%96%B9%E6%B3%95%EF%BC%9A">
     <strong>
      <code>
       handleDelivery
      </code>
      方法
     </strong>
     ：
    </h4>
    <p>
     当队列中有消息时，RabbitMQ 会调用此方法将消息传递给消费者
    </p>
    <p>
     <img alt="" height="219" src="https://i-blog.csdnimg.cn/direct/c5c396233bcb4fdba7129981340b7685.png" width="650"/>
    </p>
    <p>
     RabbitMQ 支持两种消息确认模式：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        自动确认
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在
         <code>
          basicConsume
         </code>
         方法中将第二个参数设置为
         <code>
          true
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         消费者接收到消息后，RabbitMQ 会自动将消息标记为已处理。
        </p>
       </li>
       <li>
        <p>
         示例：
        </p>
        <pre><code>channel.basicConsume(QUEUE_NAME, true, consumer);</code></pre>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        手动确认
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在
         <code>
          basicConsume
         </code>
         方法中将第二个参数设置为
         <code>
          false
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         需要在
         <code>
          handleDelivery
         </code>
         方法中手动调用
         <code>
          channel.basicAck()
         </code>
         确认消息。
        </p>
       </li>
       <li>
        <p>
         示例：
        </p>
        <pre><code>channel.basicAck(envelope.getDeliveryTag(), false);</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <h4 id="" name="">
    </h4>
    <hr/>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323230315f37353838363735372f:61727469636c652f64657461696c732f313436313139393735" class_="artid" style="display:none">
 </p>
</div>


