---
layout: post
title: "prototype和proto的区别"
date: 2025-03-14 10:11:18 +0800
description: "都与原型链和继承机制有关，但它们的含义和作用是不同的。下面来详细讲解它们的区别。在 JavaScript 中，prototype。希望这些讲解能帮你彻底搞清楚 prototype。和 __proto__和 __proto__在 ES6 中，使用。"
keywords: "prototype和proto的区别"
categories: ['未分类']
tags: ['开发语言', '原型模式', 'Javascript']
artid: "146250507"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146250507
    alt: "prototype和proto的区别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146250507
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146250507
cover: https://bing.ee123.net/img/rand?artid=146250507
image: https://bing.ee123.net/img/rand?artid=146250507
img: https://bing.ee123.net/img/rand?artid=146250507
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     prototype和proto的区别
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 JavaScript 中，
     <strong>
      <code>
       prototype
      </code>
     </strong>
     和
     <strong>
      <code>
       __proto__
      </code>
     </strong>
     都与原型链和继承机制有关，但它们的含义和作用是不同的。下面来详细讲解它们的区别。
    </p>
    <hr/>
    <h3>
     <strong>
      一、prototype 和
      <strong>
       proto
      </strong>
      的区别
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        <code>
         prototype
        </code>
       </th>
       <th>
        <code>
         __proto__
        </code>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        作用
       </td>
       <td>
        构造函数的原型对象
       </td>
       <td>
        实例对象的隐式原型
       </td>
      </tr>
      <tr>
       <td>
        类型
       </td>
       <td>
        <strong>
         对象
        </strong>
       </td>
       <td>
        <strong>
         对象
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        访问方式
       </td>
       <td>
        <strong>
         构造函数.prototype
        </strong>
       </td>
       <td>
        <strong>
         实例对象.
         <strong>
          proto
         </strong>
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        作用场景
       </td>
       <td>
        为构造函数定义
        <strong>
         方法和属性
        </strong>
       </td>
       <td>
        用于实例对象访问
        <strong>
         原型链
        </strong>
       </td>
      </tr>
      <tr>
       <td>
        修改影响
       </td>
       <td>
        修改后影响所有实例
       </td>
       <td>
        修改后仅影响该实例及其后代
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <strong>
      二、prototype 和
      <strong>
       proto
      </strong>
      的详细解析
     </strong>
    </h3>
    <h4>
     <strong>
      1. prototype 的作用
     </strong>
    </h4>
    <ul>
     <li>
      每个
      <strong>
       构造函数
      </strong>
      都有一个名为
      <code>
       prototype
      </code>
      的属性，它指向一个
      <strong>
       对象
      </strong>
      。
     </li>
     <li>
      这个对象是用来
      <strong>
       共享方法和属性
      </strong>
      的。
     </li>
     <li>
      当通过构造函数创建对象时，
      <strong>
       实例会继承 prototype 上的方法和属性
      </strong>
      。
     </li>
    </ul>
    <p>
     <strong>
      示例：
     </strong>
    </p>
    <pre><code>// 构造函数
function Person(name) {
    this.name = name;
}

// 给构造函数的 prototype 添加方法
Person.prototype.sayHello = function() {
    console.log("Hello, my name is " + this.name);
};

// 创建实例
const person1 = new Person("Alice");
const person2 = new Person("Bob");

person1.sayHello(); // 输出：Hello, my name is Alice
person2.sayHello(); // 输出：Hello, my name is Bob
</code></pre>
    <h5>
     <strong>
      注意：
     </strong>
    </h5>
    <ul>
     <li>
      通过修改
      <code>
       Person.prototype
      </code>
      ，
      <strong>
       所有实例
      </strong>
      都能访问到新的方法或属性。
     </li>
     <li>
      <code>
       prototype
      </code>
      只有在构造函数上存在，
      <strong>
       实例本身没有
       <code>
        prototype
       </code>
       属性
      </strong>
      。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      2.
      <strong>
       proto
      </strong>
      的作用
     </strong>
    </h4>
    <ul>
     <li>
      每个
      <strong>
       对象实例
      </strong>
      都有一个
      <strong>
       <code>
        __proto__
       </code>
      </strong>
      属性，指向
      <strong>
       创建该实例的构造函数的原型对象
      </strong>
      。
     </li>
     <li>
      这个属性是
      <strong>
       隐式原型
      </strong>
      ，用于
      <strong>
       查找属性和方法
      </strong>
      。
     </li>
    </ul>
    <p>
     <strong>
      示例：
     </strong>
    </p>
    <pre><code>console.log(person1.__proto__ === Person.prototype); // true
console.log(person2.__proto__ === Person.prototype); // true
</code></pre>
    <h5>
     <strong>
      作用：
     </strong>
    </h5>
    <ul>
     <li>
      当我们访问对象的属性或方法时，JavaScript 会
      <strong>
       先查找对象本身
      </strong>
      ，如果没有，则沿着**
      <code>
       __proto__
      </code>
      ** 继续查找，直到
      <code>
       null
      </code>
      。
     </li>
     <li>
      这种
      <strong>
       链式查找机制
      </strong>
      称为
      <strong>
       原型链
      </strong>
      。
     </li>
    </ul>
    <hr/>
    <h3>
     <strong>
      三、构造函数、实例、原型三者关系
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        构造函数：
       </strong>
      </p>
      <ul>
       <li>
        <code>
         Person.prototype
        </code>
        ：原型对象。
       </li>
       <li>
        <code>
         Person.prototype.constructor
        </code>
        ：指向构造函数本身。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        实例对象：
       </strong>
      </p>
      <ul>
       <li>
        <code>
         person1.__proto__
        </code>
        ：指向构造函数的原型对象，即
        <code>
         Person.prototype
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      关系图：
     </strong>
    </p>
    <pre><code>Person --&gt; prototype --&gt; { sayHello, constructor }
                   ↑
                 __proto__
                   ↑
              person1 / person2
</code></pre>
    <hr/>
    <h3>
     <strong>
      四、示例验证原型链
     </strong>
    </h3>
    <pre><code>console.log(person1.__proto__ === Person.prototype);  // true
console.log(Person.prototype.constructor === Person); // true
console.log(Object.getPrototypeOf(person1) === Person.prototype); // true
</code></pre>
    <hr/>
    <h3>
     <strong>
      五、修改 prototype 和
      <strong>
       proto
      </strong>
      的区别
     </strong>
    </h3>
    <h4>
     <strong>
      修改 prototype：影响所有实例
     </strong>
    </h4>
    <pre><code>Person.prototype.greet = function() {
    console.log("Greetings from " + this.name);
};

person1.greet(); // Greetings from Alice
person2.greet(); // Greetings from Bob
</code></pre>
    <h4>
     <strong>
      修改
      <strong>
       proto
      </strong>
      ：仅影响当前对象
     </strong>
    </h4>
    <pre><code>const obj = {};
obj.__proto__ = {
    customMethod: function() {
        console.log("I am custom!");
    }
};

obj.customMethod(); // I am custom!
</code></pre>
    <hr/>
    <h3>
     <strong>
      六、在类中的表现（ES6+）
     </strong>
    </h3>
    <p>
     在 ES6 中，使用
     <code>
      class
     </code>
     语法定义类，原型机制依然有效：
    </p>
    <pre><code>class Animal {
    speak() {
        console.log("Animal speaks");
    }
}

const dog = new Animal();

console.log(dog.__proto__ === Animal.prototype);  // true
console.log(Animal.prototype.constructor === Animal); // true
</code></pre>
    <hr/>
    <h3>
     <strong>
      七、为什么
      <strong>
       proto
      </strong>
      不推荐使用？
     </strong>
    </h3>
    <ol>
     <li>
      <strong>
       性能问题：
      </strong>
      <code>
       __proto__
      </code>
      是非标准特性，访问速度较慢。
     </li>
     <li>
      <strong>
       兼容性问题：
      </strong>
      早期版本的 IE 不支持。
     </li>
     <li>
      <strong>
       规范性：
      </strong>
      建议使用
      <code>
       Object.getPrototypeOf()
      </code>
      代替：
      <pre><code>console.log(Object.getPrototypeOf(person1) === Person.prototype); // true
</code></pre>
     </li>
    </ol>
    <hr/>
    <h3>
     <strong>
      八、总结
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        比较项
       </th>
       <th>
        prototype
       </th>
       <th>
        <strong>
         proto
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        作用
       </td>
       <td>
        构造函数的原型对象
       </td>
       <td>
        实例对象的隐式原型
       </td>
      </tr>
      <tr>
       <td>
        类型
       </td>
       <td>
        对象
       </td>
       <td>
        对象
       </td>
      </tr>
      <tr>
       <td>
        修改效果
       </td>
       <td>
        修改后影响所有实例
       </td>
       <td>
        修改后仅影响该实例及其后代
       </td>
      </tr>
      <tr>
       <td>
        使用场景
       </td>
       <td>
        批量定义共享方法和属性
       </td>
       <td>
        查找实例对象原型链中的属性和方法
       </td>
      </tr>
      <tr>
       <td>
        推荐使用
       </td>
       <td>
        是
       </td>
       <td>
        否，建议使用
        <code>
         Object.getPrototypeOf()
        </code>
        代替
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <strong>
      面试高频问题
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        prototype 和
        <strong>
         proto
        </strong>
        有什么区别？
       </strong>
      </p>
      <ul>
       <li>
        <code>
         prototype
        </code>
        是构造函数的属性，
        <code>
         __proto__
        </code>
        是实例对象的属性。
       </li>
       <li>
        <code>
         prototype
        </code>
        用于定义
        <strong>
         共享方法和属性
        </strong>
        ，
        <code>
         __proto__
        </code>
        用于访问
        <strong>
         原型链
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        如何修改实例的原型？
       </strong>
      </p>
      <ul>
       <li>
        可以直接使用
        <code>
         Object.setPrototypeOf(obj, newProto);
        </code>
        或
        <code>
         obj.__proto__ = newProto;
        </code>
        ，但前者性能更优。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        为什么不推荐使用
        <strong>
         proto
        </strong>
        ？
       </strong>
      </p>
      <ul>
       <li>
        性能差且非标准化，推荐使用
        <code>
         Object.getPrototypeOf()
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <p>
     希望这些讲解能帮你彻底搞清楚
     <strong>
      <code>
       prototype
      </code>
     </strong>
     和
     <strong>
      <code>
       __proto__
      </code>
     </strong>
     的区别！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f33383338323338302f:61727469636c652f64657461696c732f313436323530353037" class_="artid" style="display:none">
 </p>
</div>


