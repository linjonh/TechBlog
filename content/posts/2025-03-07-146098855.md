---
layout: post
title: "驱动字符设备开发之Linux2.6开发"
date: 2025-03-07 16:37:59 +0800
description: "字符设备驱动开发三大方法之一Linux2.6开发"
keywords: "驱动字符设备开发之Linux2.6开发"
categories: ['未分类']
tags: ['驱动开发', 'Linux']
artid: "146098855"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146098855
    alt: "驱动字符设备开发之Linux2.6开发"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146098855
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146098855
cover: https://bing.ee123.net/img/rand?artid=146098855
image: https://bing.ee123.net/img/rand?artid=146098855
img: https://bing.ee123.net/img/rand?artid=146098855
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     驱动字符设备开发之Linux2.6开发
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <h3>
     1.Linux2.6开发特点：
    </h3>
    <ol>
     <li style="text-align:justify">
      标准化。可以清晰明了地了解开发代码的操作。
     </li>
     <li style="text-align:justify">
      设备范围广泛。不限制设备号，开发时需要自己申请设备号。
     </li>
     <li style="text-align:justify">
      注册完毕后不会生成设备文件。需要用指令生成或内核其他接口生成。
     </li>
    </ol>
    <h3 id="2.Linux2.6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B" name="2.Linux2.6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B" style="text-align:justify">
     2.Linux2.6开发流程
    </h3>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     驱动注册-&gt;分配cdev设备号（静态分配register_chrdev_region/动态分配alloc_chrdev_region）-&gt;初始化cdev（cdev_init）-&gt;注册cdev（cdev_add）-&gt;初始化硬件-&gt;设备操作函数的实现（open/read/write/close）-&gt;驱动注销（cdev_del/unregister_chrdev_region）
    </p>
    <h3 id="3.Linux2.6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" name="3.Linux2.6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0" style="text-align:justify">
     3.Linux2.6开发的相关接口函数
    </h3>
    <h4 id="%C2%B7alloc_chrdev_region()%E7%94%B3%E8%AF%B7%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%87%BD%E6%95%B0" name="%C2%B7alloc_chrdev_region()%E7%94%B3%E8%AF%B7%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%87%BD%E6%95%B0" style="text-align:justify">
     ·alloc_chrdev_region()申请设备号函数
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数功能：向内核申请一个可以使用的设备号（连续申请）
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数头文件：&lt;linux/fs.h&gt;
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数原型：
    </p>
    <pre><code class="language-cpp">int alloc_chrdev_region(
    dev_t * devnum, 
    unsigned base_minor, 
    unsigned count, 
    const char * labelname
);</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数参数：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     devnum：设备号。需要提供一个这样类型的空间。函数申请设备号成功，就会把申请得到的首设备号存入该空间。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     base_minor：起始次设备号。跟系统指定准备从哪个次设备号开始使用。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     count：要申请的设备号数量。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     label_name：给它们的名字
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数返回值：成功返回0
    </p>
    <h4 id="%C2%B7unregister_chrdev_region()%E9%87%8A%E6%94%BE%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%87%BD%E6%95%B0" name="%C2%B7unregister_chrdev_region()%E9%87%8A%E6%94%BE%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%87%BD%E6%95%B0">
     ·unregister_chrdev_region()释放设备号函数
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数功能：释放申请得到的设备号
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数头文件：&lt;linux/fs.h&gt;
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数原型：
    </p>
    <pre><code class="language-cpp">void unregister_chrdev_region(
    dev_t devnum, 
    unsigned count
);</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数参数：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     devnum：申请得到的首设备号
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     count：连续释放的数量
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数返回值：无
    </p>
    <h4 id="%C2%B7%E5%88%9D%E5%A7%8B%E5%8C%96cdev%E7%BB%93%E6%9E%84%E4%BD%93" name="%C2%B7%E5%88%9D%E5%A7%8B%E5%8C%96cdev%E7%BB%93%E6%9E%84%E4%BD%93">
     ·初始化cdev结构体
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数功能：初始化一个cdev结构体
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数头文件：&lt;linux/cdev.h&gt;
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数原型：
    </p>
    <pre><code class="language-cpp">void cdev_init(
    struct cdev * cdevp, 
    const struct file_operations * fops
);</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数参数：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     cdevp：给函数一个cdev结构体空间。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     fops：提供一个ops结构体，并至少填入其中的owner、open、release。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数返回值：无
    </p>
    <h4 id="%C2%B7%E6%B3%A8%E5%86%8Ccdev%E8%AE%BE%E5%A4%87" name="%C2%B7%E6%B3%A8%E5%86%8Ccdev%E8%AE%BE%E5%A4%87">
     ·注册cdev设备
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数功能：向内核注册一个cdev结构体。可以一次注册多个设备。
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数原型：
    </p>
    <pre><code class="language-cpp">int cdev_add(
    struct cdev * cdevp, 
    dev_t dev_num, 
    unsigned count
);</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数参数：
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     cdevp：填入经cdev_init初始化完毕的结构体
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     dev_num：经过alloc_chrdev_region申请的设备号
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     count：要注册的设备数量
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数返回值：成功返回0
    </p>
    <h4 id="%C2%B7%E5%88%A0%E9%99%A4%E6%B3%A8%E5%86%8C%E7%9A%84cdev%E7%BB%93%E6%9E%84%E4%BD%93" name="%C2%B7%E5%88%A0%E9%99%A4%E6%B3%A8%E5%86%8C%E7%9A%84cdev%E7%BB%93%E6%9E%84%E4%BD%93">
     ·删除注册的cdev结构体
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数功能：从内核取消一个cdev的结构体的注册
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数原型：
    </p>
    <pre><code class="language-cpp">void cdev_del(struct cdev * cdevp);</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数参数：cdevp：传入cdev结构体，即可自动取消全部设备的注册
    </p>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     函数返回值：无
    </p>
    <h3 id="4.%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8E%A5%E5%8F%A3" name="4.%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8E%A5%E5%8F%A3" style="text-align:justify">
     4.生成设备文件的指令和接口
    </h3>
    <h4 id="1.%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%EF%BC%9A" name="1.%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%EF%BC%9A" style="text-align:justify">
     1.手动创建设备文件：
    </h4>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     mknod  /dev/xxx c 主设备号 次设备号
    </p>
    <h4 id="2.%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%EF%BC%9A%E7%94%9F%E6%88%90%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93-%3E%E5%88%A9%E7%94%A8%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6" name="2.%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%EF%BC%9A%E7%94%9F%E6%88%90%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93-%3E%E5%88%A9%E7%94%A8%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6">
     2.利用函数生成：生成类结构体-&gt;利用类结构体生成设备文件
    </h4>
    <h5 id="%C2%B7%E7%94%9F%E6%88%90%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E5%87%BD%E6%95%B0" name="%C2%B7%E7%94%9F%E6%88%90%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E5%87%BD%E6%95%B0" style="text-align:justify">
     ·生成类结构体函数
    </h5>
    <pre><code class="language-cpp">struct class * class_create(owner , name);</code></pre>
    <p style="margin-left:.0001pt; margin-right:0; text-align:justify">
     其中，owner固定填写，name可任意命名。
    </p>
    <h5 id="%C2%B7%E6%91%A7%E6%AF%81%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E5%87%BD%E6%95%B0" name="%C2%B7%E6%91%A7%E6%AF%81%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E5%87%BD%E6%95%B0" style="text-align:justify">
     ·摧毁类结构体函数
    </h5>
    <pre><code class="language-cpp">void class_destroy(struct class *cls);</code></pre>
    <h5 id="%C2%B7%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0" name="%C2%B7%E7%94%9F%E6%88%90%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0" style="text-align:justify">
     ·生成设备文件的函数
    </h5>
    <pre><code class="language-cpp">struct device *device_create(
    struct class *cls, //类结构体
    struct device *parent,//父设备
    dev_t devt, //设备号
    void *drvdata, //设备的私有数据
    const char *fmt, ...//格式化设备名
); </code></pre>
    <h5 id="%C2%B7%E9%94%80%E6%AF%81%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0" name="%C2%B7%E9%94%80%E6%AF%81%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0" style="text-align:justify">
     ·销毁设备文件的函数
    </h5>
    <pre><code class="language-cpp">void device_destroy(
    struct class *cls, 
    dev_t devt
);</code></pre>
    <h3 id="5.%E5%9F%BA%E4%BA%8ELinux2.6%E5%BC%80%E5%8F%91%E9%A9%B1%E5%8A%A8led%E7%81%AF%E9%97%AA%E7%83%81" name="5.%E5%9F%BA%E4%BA%8ELinux2.6%E5%BC%80%E5%8F%91%E9%A9%B1%E5%8A%A8led%E7%81%AF%E9%97%AA%E7%83%81" style="text-align:justify">
     5.基于Linux2.6开发驱动led灯闪烁
    </h3>
    <p>
     驱动开发程序
    </p>
    <p>
     此处led1的引脚为gpio的第24个引脚，低电平亮
    </p>
    <pre><code class="language-cpp">#include "linux/module.h"
#include "linux/kernel.h"
#include "linux/miscdevice.h"
#include "linux/gpio.h"
#include "linux/cdev.h"
#include "linux/fs.h"
#include "linux/device.h" 
dev_t devnum;
struct cdev cdevp;
struct file_operations ops;
struct class * cls;
int led1_open (struct inode * a, struct file * b){
    gpio_set_value(24,0);
    return 0;
}
int led1_close (struct inode * c, struct file * d){
    gpio_set_value(24,1);
    return 0;
}
	
//加载函数-&gt;驱动入口
static int __init test_init(void)
{
    gpio_request(24,"myled1");
    gpio_direction_output(24,1);
    //1.先申请一个设备号
    alloc_chrdev_region(&amp;devnum,78,1,"led1_dev");
    printk("主设备号 == %d\r\n",devnum &gt;&gt; 20);
	printk("次设备号 == %d\r\n",devnum &amp;0xFFFFF);

    //2.初始化cdev结构体
    ops.owner = THIS_MODULE;
    ops.open = led1_open;
    ops.release = led1_close;
    cdev_init(&amp;cdevp,&amp;ops);
    //3.注册cdev到内核
    cdev_add(&amp;cdevp,devnum,1);
    cls = class_create(THIS_MODULE,"led1_devclass");
    device_create(cls,NULL,devnum,NULL,"LED1_test07");
    return 0;
}         
//卸载函数-&gt;驱动的出口
static  void __exit test_exit(void)
{
    printk("hello  出口函数！\r\n");
    device_destroy(cls, devnum);
    class_destroy(cls);
    //注销cdev设备
    cdev_del(&amp;cdevp);
    //释放申请的设备号
    unregister_chrdev_region(devnum,1);
    //释放gpio引脚
    gpio_free(24);
}
//内核层的声明
module_init(test_init);
module_exit(test_exit);
MODULE_LICENSE("GPL");//必须遵循开源协议</code></pre>
    <p>
     应用层程序--控制led1闪烁
    </p>
    <pre><code class="language-cpp">#include "stdio.h"
#include "unistd.h"
#include "fcntl.h"
#include "sys/types.h"
#include "sys/stat.h"
int main(){
    int fd1 = 0;
    while(1){ 
        fd1 = open("/dev/LED1_test07",O_RDONLY);
        sleep(1);
        close(fd1);
        sleep(1);
    }
}</code></pre>
    <p>
     开发板下执行注册、注销和执行程序操作
    </p>
    <p>
     <img alt="" height="114" src="https://i-blog.csdnimg.cn/direct/2219696a0c87461ba0de2c65ff0e6085.png" width="218"/>
    </p>
    <p>
     其中打印了字符设备的主设备号和次设备号，可以通过查看日志信息指令获取。
    </p>
    <p>
     <img alt="" height="56" src="https://i-blog.csdnimg.cn/direct/74cdc752db864eceaca882bc148194d2.png" width="319"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f436861726172792f:61727469636c652f64657461696c732f313436303938383535" class_="artid" style="display:none">
 </p>
</div>


