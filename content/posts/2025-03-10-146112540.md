---
layout: post
title: "贪心算法三"
date: 2025-03-10 19:08:21 +0800
description: "贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。"
keywords: "贪心算法三"
categories: ['贪心算法']
tags: ['贪心算法', '算法', '推荐算法', '动态规划', 'Leetcode']
artid: "146112540"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146112540
    alt: "贪心算法三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146112540
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146112540
cover: https://bing.ee123.net/img/rand?artid=146112540
image: https://bing.ee123.net/img/rand?artid=146112540
img: https://bing.ee123.net/img/rand?artid=146112540
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     贪心算法三
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      &gt; 作者：დ旧言~
      <br/>
      &gt; 座右铭：松树千年终是朽，槿花一日自为荣。
     </p>
     <p>
      &gt; 目标：了解什么是贪心算法，并且掌握贪心算法。
     </p>
     <p>
      &gt; 毒鸡汤：有些事情，总是不明白，所以我不会坚持。早安!
     </p>
     <p>
      &gt; 专栏选自：
      <a href="https://blog.csdn.net/aalykk/category_12867594.html?spm=1001.2014.3001.5482" title="贪心算法_დ旧言~的博客-CSDN博客">
       贪心算法_დ旧言~的博客-CSDN博客
      </a>
     </p>
     <p>
      &gt; 望小伙伴们点赞👍收藏✨加关注哟💕💕
     </p>
    </blockquote>
    <h2>
     一、算法讲解
    </h2>
    <p>
     <span style="color:#4da8ee">
      <strong>
       贪心算法的定义：
      </strong>
     </span>
    </p>
    <p>
     贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       解题的一般步骤是：
      </strong>
     </span>
    </p>
    <ol>
     <li>
      建立数学模型来描述问题；
     </li>
     <li>
      把求解的问题分成若干个子问题；
     </li>
     <li>
      对每一子问题求解，得到子问题的局部最优解；
     </li>
     <li>
      把子问题的局部最优解合成原来问题的一个解。
     </li>
    </ol>
    <p>
     如果大家比较了解动态规划，就会发现它们之间的相似之处。最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，大部分情况下这是不可行的。贪心算法和动态规划本质上是对子问题树的一种修剪，两种算法要求问题都具有的一个性质就是子问题最优性(组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的)。
    </p>
    <p>
     动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。而贪心算法是动态规划方法的一个特例，可以证明每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。
    </p>
    <h2>
     二、算法习题
    </h2>
    <hr/>
    <h3>
     2.1、第一题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/" rel="nofollow" title="674. 最长连续递增序列 - 力扣（LeetCode）">
       674. 最长连续递增序列 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="980" src="https://i-blog.csdnimg.cn/direct/37bbd9e9589e46dba31a10940f648ba9.png" width="1596"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#333333">
      找到以某个位置为起点的最⻓连续递增序列之后（设这个序列的末尾为 j 位置），接下来直接
      <br/>
      以 j + 1 的位置为起点寻找下⼀个最⻓连续递增序列。
     </span>
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) 
    {
        int ret = 0, n = nums.size();
        for (int i = 0; i &lt; n;) 
        {
            int j = i + 1;
            // 找到递增区间的末端
            while (j &lt; n &amp;&amp; nums[j] &gt; nums[j - 1])
                j++;
            ret = max(ret, j - i);
            i = j; // 直接在循环中更新下⼀个位置的起点
        }
        return ret;
    }
};</code></pre>
    <h3>
     2.2、第二题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" rel="nofollow" title="121. 买卖股票的最佳时机 - 力扣（LeetCode）">
       121. 买卖股票的最佳时机 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="862" src="https://i-blog.csdnimg.cn/direct/80188e5438754cf7bd6c446808e277c4.png" width="1532"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     由于只能交易⼀次，所以对于某⼀个位置 i ，要想获得最⼤利润，仅需知道前⾯所有元素的最⼩
     <br/>
     值。然后在最⼩值的位置「买⼊」股票，在当前位置「卖出」股票即可。
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) 
    {
        int ret = 0; // 记录最终结果
        for (int i = 0, prevMin = INT_MAX; i &lt; prices.size(); i++) 
        {
            ret = max(ret, prices[i] - prevMin); // 先更新结果
            prevMin = min(prevMin, prices[i]);   // 再更新最⼩值
        }
        return ret;
    }
};</code></pre>
    <h3>
     2.3、第三题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" rel="nofollow" title="122. 买卖股票的最佳时机 II - 力扣（LeetCode）">
       122. 买卖股票的最佳时机 II - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="939" src="https://i-blog.csdnimg.cn/direct/dd4f0ba59f3e422ca40df0e133a53abe.png" width="1554"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     由于可以进⾏⽆限次交易，所以只要是⼀个「上升区域」，我们就把利润拿到⼿就好了。
    </p>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) 
    {
        // 实现⽅式⼆：拆分成⼀天⼀天
        int ret = 0;
        for (int i = 1; i &lt; prices.size(); i++) 
        {
            if (prices[i] &gt; prices[i - 1])
                ret += prices[i] - prices[i - 1];
        }
        return ret;
    }
};</code></pre>
    <h3>
     2.4、第四题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/" rel="nofollow" title="1005. K 次取反后最大化的数组和 - 力扣（LeetCode）">
       1005. K 次取反后最大化的数组和 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="975" src="https://i-blog.csdnimg.cn/direct/bd3121f9bd824257b550e80b863cf7f6.png" width="1731"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
     分情况讨论，设整个数组中负数的个数为 m 个
    </p>
    <p>
     a. m &gt; k ：把前 k ⼩负数，全部变成正数；
    </p>
    <p>
     b. m == k ：把所有的负数全部转化成正数；
    </p>
    <p>
     c. m &lt; k ：
    </p>
    <ul>
     <li>
      先把所有的负数变成正数；
     </li>
     <li>
      然后根据 k - m 的奇偶分情况讨论：
     </li>
     <li>
      1. 如果是偶数，直接忽略；
      <br/>
      2. 如果是奇数，挑选当前数组中最⼩的数，变成负数
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) 
    {
        int m = 0, minElem = INT_MAX, n = nums.size();
        for (auto x : nums) 
        {
            if (x &lt; 0)
                m++;
            minElem = min(minElem, abs(x)); // 求绝对值最⼩的那个数
        }
        // 分类讨论
        int ret = 0;
        if (m &gt; k) 
        {
            sort(nums.begin(), nums.end());
            for (int i = 0; i &lt; k; i++) // 前 k ⼩个负数，变成正数
            {
                ret += -nums[i];
            }
            for (int i = k; i &lt; n; i++) // 后⾯的数不变
            {
                ret += nums[i];
            }
        } else {
            // 把所有的负数变成正数
            for (auto x : nums)
                ret += abs(x);
            if ((k - m) % 2) // 判断是否处理最⼩的正数
            {
                ret -= minElem * 2;
            }
        }
        return ret;
    }
};</code></pre>
    <h3>
     2.5、第五题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/sort-the-people/description/" rel="nofollow" title="2418. 按身高排序 - 力扣（LeetCode）">
       2418. 按身高排序 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="839" src="https://i-blog.csdnimg.cn/direct/27570c3f5aca4c66a51e0b74485c8e1c.png" width="1859"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <ul>
     <li>
      我们不能直接按照 i 位置对应的 heights 来排序，因为排序过程是会移动元素的，但是names 内的元素是不会移动的。
     </li>
     <li>
      由题意可知， names 数组和 heights 数组的下标是⼀⼀对应的，因此我们可以重新创建出来⼀个下标数组，将这个下标数组按照 heights[i] 的⼤⼩排序。
     </li>
     <li>
      那么，当下标数组排完序之后，⾥⾯的顺序就相当于 heights 这个数组排完序之后的下标。之后通过排序后的下标，依次找到原来的 name ，完成对名字的排序。
     </li>
    </ul>
    <p>
     <span style="color:#4da8ee">
      <strong>
       代码呈现：
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) 
    {
        // 1. 创建⼀个下标数组
        int n = names.size();
        vector&lt;int&gt; index(n);
        for (int i = 0; i &lt; n; i++)
            index[i] = i;
        // 2. 对下标进⾏排序
        sort(index.begin(), index.end(),
             [&amp;](int i, int j) { return heights[i] &gt; heights[j]; });
        // 3. 提取结果
        vector&lt;string&gt; ret;
        for (int i : index) {
            ret.push_back(names[i]);
        }
        return ret;
    }
};</code></pre>
    <h3>
     2.6、第六题
    </h3>
    <blockquote>
     <p>
      <strong>
       题目链接：
      </strong>
      <a href="https://leetcode.cn/problems/advantage-shuffle/description/" rel="nofollow" title="870. 优势洗牌 - 力扣（LeetCode）">
       870. 优势洗牌 - 力扣（LeetCode）
      </a>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       题目描述：
      </strong>
     </span>
    </p>
    <blockquote>
     <p>
      <img alt="" height="924" src="https://i-blog.csdnimg.cn/direct/641d533ca04248c6a84ae166f2122889.png" width="1792"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#4da8ee">
      <strong>
       算法思路：
      </strong>
     </span>
    </p>
    <p>
     讲⼀下⽥忌赛⻢背后包含的博弈论和贪⼼策略：
     <br/>
     ⽥忌：下等⻢ 中等⻢ 上等⻢
     <br/>
     ⻬王：下等⻢ 中等⻢ 上等⻢
    </p>
    <ul>
     <li>
      a. ⽥忌的下等⻢ pk 不过⻬王的下等⻢，因此把这匹⻢丢去消耗⼀个⻬王的最强战⻢！
     </li>
     <li>
      b. 接下来选择中等⻢ pk ⻬王的下等⻢，勉强获胜；
     </li>
     <li>
      c. 最后⽤上等⻢ pk ⻬王的中等⻢，勉强获胜。
     </li>
    </ul>
    <p>
     <strong>
      由此，我们可以得出⼀个最优的决策⽅式：
     </strong>
    </p>
    <ul>
     <li>
      a. 当⼰⽅此时最差的⽐不过对⾯最差的时候，让我⽅最差的去处理掉对⾯最好的（反正要输，不如去拖掉对⾯⼀个最强的）；
     </li>
     <li>
      b. 当⼰⽅此时
     </li>
     <li>
      c. 最差的能⽐得上对⾯最差的时候，就让两者⽐对下去（最差的都能获胜，为什么要输呢）。每次决策，都会使我⽅处于优势。
     </li>
    </ul>
    <p>
     <strong>
      代码呈现：
     </strong>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) 
    {
        int n = nums1.size();
        // 1. 排序
        sort(nums1.begin(), nums1.end());
        vector&lt;int&gt; index2(n);
        for (int i = 0; i &lt; n; i++)
            index2[i] = i;
        sort(index2.begin(), index2.end(),
             [&amp;](int i, int j) { return nums2[i] &lt; nums2[j]; });
        // 2. ⽥忌赛⻢
        vector&lt;int&gt; ret(n);
        int left = 0, right = n - 1;
        for (auto x : nums1) {
            if (x &gt; nums2[index2[left]])
                ret[index2[left++]] = x;
            else
                ret[index2[right--]] = x;
        }
        return ret;
    }
};</code></pre>
    <h2 style="background-color:transparent">
     三、结束语
     <strong>
     </strong>
    </h2>
    <p>
     今天内容就到这里啦，时间过得很快，大家沉下心来好好学习，会有一定的收获的，大家多多坚持，嘻嘻，成功路上注定孤独，因为坚持的人不多。那请大家举起自己的小手给博主一键三连，有你们的支持是我最大的动力💞💞💞，回见。
    </p>
    <p>
     <img alt="" height="190" src="https://i-blog.csdnimg.cn/blog_migrate/15e0d701305bac519d5e1792f515a055.jpeg" width="200"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f41416c796b6b2f:61727469636c652f64657461696c732f313436313132353430" class_="artid" style="display:none">
 </p>
</div>


