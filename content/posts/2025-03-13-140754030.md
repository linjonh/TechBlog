---
layout: post
title: "Unix-域套接字本地套接字"
date: 2025-03-13 08:44:44 +0800
description: "Unix 域套接字是一种只在 Unix 和类 Unix 操作系统（包括 Linux）中可用的套接字类型。它允许在同一主机上的进程之间通过文件系统进行通信，而不必通过网络层。流式套接字 (SOCK_STREAM)：提供面向连接的服务，类似于 TCP。数据报套接字 (SOCK_DGRAM)：提供无连接的服务，类似于 UDP。"
keywords: "Unix 域套接字（本地套接字）"
categories: ['玩转C语言', 'Linux']
tags: ['本地套接字', '开发语言', 'Unix', 'Unix', 'Socket', 'Linux', 'C']
artid: "140754030"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=140754030
    alt: "Unix-域套接字本地套接字"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=140754030
featuredImagePreview: https://bing.ee123.net/img/rand?artid=140754030
cover: https://bing.ee123.net/img/rand?artid=140754030
image: https://bing.ee123.net/img/rand?artid=140754030
img: https://bing.ee123.net/img/rand?artid=140754030
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unix 域套接字（本地套接字）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Unix 域套接字（Unix Domain Sockets），也称为本地套接字（Local Sockets），是一种用于同一主机上进程间通信（IPC）的机制。Unix 域套接字提供了一种高效的进程间通信方式，它利用文件系统作为传输媒介，而不是网络栈，因此可以避免网络层的开销。下面详细介绍 Unix 域套接字的概念、用途、API 以及示例代码。
    </p>
    <p>
     <img src="https://i-blog.csdnimg.cn/direct/f932aaee23e449bc866fb6319e8dca9c.png"/>
    </p>
    <h4>
     概述
    </h4>
    <p>
     Unix 域套接字是一种只在 Unix 和类 Unix 操作系统（包括 Linux）中可用的套接字类型。它允许在同一主机上的进程之间通过文件系统进行通信，而不必通过网络层。Unix 域套接字可以分为两种类型：
    </p>
    <ol>
     <li>
      <strong>
       流式套接字 (SOCK_STREAM)
      </strong>
      ：提供面向连接的服务，类似于 TCP。
     </li>
     <li>
      <strong>
       数据报套接字 (SOCK_DGRAM)
      </strong>
      ：提供无连接的服务，类似于 UDP。
     </li>
    </ol>
    <h4>
     特点
    </h4>
    <ul>
     <li>
      <strong>
       高效性
      </strong>
      ：由于通信发生在同一主机上，不需要经过网络层，因此效率更高。
     </li>
     <li>
      <strong>
       安全性
      </strong>
      ：通信数据不离开本机，减少了外部攻击的风险。
     </li>
     <li>
      <strong>
       简单性
      </strong>
      ：API 与传统的网络套接字相似，但无需处理 IP 地址和端口。
     </li>
    </ul>
    <h4>
     API
    </h4>
    <p>
     Unix 域套接字主要使用的函数包括：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        socket()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         int socket(int domain, int type, int protocol)
        </code>
        : 创建一个套接字。
       </li>
       <li>
        参数
        <code>
         domain
        </code>
        指定域，对于 Unix 域套接字为
        <code>
         AF_UNIX
        </code>
        ，
        <code>
         type
        </code>
        指定套接字类型，如
        <code>
         SOCK_STREAM
        </code>
        或
        <code>
         SOCK_DGRAM
        </code>
        ，
        <code>
         protocol
        </code>
        通常设为0。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        bind()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
        </code>
        : 绑定套接字到一个地址。
       </li>
       <li>
        参数
        <code>
         sockfd
        </code>
        是套接字描述符，
        <code>
         addr
        </code>
        是地址结构的指针，
        <code>
         addrlen
        </code>
        是地址结构的大小。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        listen()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         int listen(int sockfd, int backlog)
        </code>
        : 将套接字标记为监听状态。
       </li>
       <li>
        参数
        <code>
         sockfd
        </code>
        是套接字描述符，
        <code>
         backlog
        </code>
        是连接队列的最大长度。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        accept()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
        </code>
        : 接受传入的连接。
       </li>
       <li>
        参数
        <code>
         sockfd
        </code>
        是监听套接字描述符，
        <code>
         addr
        </code>
        和
        <code>
         addrlen
        </code>
        用于返回客户端的地址信息。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        connect()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
        </code>
        : 连接到一个服务器。
       </li>
       <li>
        参数
        <code>
         sockfd
        </code>
        是套接字描述符，
        <code>
         addr
        </code>
        是服务器地址结构的指针，
        <code>
         addrlen
        </code>
        是地址结构的大小。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        send()
       </strong>
       和
       <strong>
        recv()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         ssize_t send(int sockfd, const void *buf, size_t len, int flags)
        </code>
        : 发送数据。
       </li>
       <li>
        <code>
         ssize_t recv(int sockfd, void *buf, size_t len, int flags)
        </code>
        : 接收数据。
       </li>
       <li>
        参数
        <code>
         sockfd
        </code>
        是套接字描述符，
        <code>
         buf
        </code>
        是缓冲区指针，
        <code>
         len
        </code>
        是数据长度，
        <code>
         flags
        </code>
        用于指定发送或接收的选项。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        close()
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         int close(int sockfd)
        </code>
        : 关闭套接字。
       </li>
       <li>
        参数
        <code>
         sockfd
        </code>
        是套接字描述符。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     示例代码
    </h4>
    <p>
     下面是一个简单的 Unix 域套接字示例，演示了如何在服务器和客户端之间进行通信。
    </p>
    <p>
     服务器端 (server.c)
    </p>
    <pre><code>1#include &lt;sys/socket.h&gt;
2#include &lt;sys/un.h&gt;
3#include &lt;stdio.h&gt;
4#include &lt;stdlib.h&gt;
5#include &lt;unistd.h&gt;
6#include &lt;string.h&gt;
7
8#define SOCK_PATH "/tmp/unix_socket_example.sock"
9
10int main() {
11    int server_sock, client_sock;
12    struct sockaddr_un addr;
13    char buf[1024];
14
15    // 创建 Unix 域套接字
16    server_sock = socket(AF_UNIX, SOCK_STREAM, 0);
17    if (server_sock == -1) {
18        perror("socket");
19        exit(EXIT_FAILURE);
20    }
21
22    // 清空地址结构
23    memset(&amp;addr, 0, sizeof(addr));
24    addr.sun_family = AF_UNIX;
25    strncpy(addr.sun_path, SOCK_PATH, sizeof(addr.sun_path) - 1);
26
27    // 绑定套接字
28    if (bind(server_sock, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1) {
29        perror("bind");
30        exit(EXIT_FAILURE);
31    }
32
33    // 监听连接
34    if (listen(server_sock, 5) == -1) {
35        perror("listen");
36        exit(EXIT_FAILURE);
37    }
38
39    // 接受连接
40    socklen_t len = sizeof(addr);
41    client_sock = accept(server_sock, (struct sockaddr *)&amp;addr, &amp;len);
42    if (client_sock == -1) {
43        perror("accept");
44        exit(EXIT_FAILURE);
45    }
46
47    // 接收数据
48    ssize_t bytes_received = recv(client_sock, buf, sizeof(buf), 0);
49    if (bytes_received == -1) {
50        perror("recv");
51        exit(EXIT_FAILURE);
52    }
53    buf[bytes_received] = '\0';
54
55    // 输出收到的数据
56    printf("Received: %s\n", buf);
57
58    // 关闭连接
59    close(client_sock);
60    close(server_sock);
61
62    // 删除套接字文件
63    unlink(SOCK_PATH);
64
65    return 0;
66}</code></pre>
    <p>
     客户端 (client.c)
    </p>
    <pre><code>1#include &lt;sys/socket.h&gt;
2#include &lt;sys/un.h&gt;
3#include &lt;stdio.h&gt;
4#include &lt;stdlib.h&gt;
5#include &lt;unistd.h&gt;
6#include &lt;string.h&gt;
7
8#define SOCK_PATH "/tmp/unix_socket_example.sock"
9
10int main() {
11    int sock;
12    struct sockaddr_un addr;
13    char buf[] = "Hello, Unix Domain Socket!";
14
15    // 创建 Unix 域套接字
16    sock = socket(AF_UNIX, SOCK_STREAM, 0);
17    if (sock == -1) {
18        perror("socket");
19        exit(EXIT_FAILURE);
20    }
21
22    // 清空地址结构
23    memset(&amp;addr, 0, sizeof(addr));
24    addr.sun_family = AF_UNIX;
25    strncpy(addr.sun_path, SOCK_PATH, sizeof(addr.sun_path) - 1);
26
27    // 连接到服务器
28    if (connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1) {
29        perror("connect");
30        exit(EXIT_FAILURE);
31    }
32
33    // 发送数据
34    if (send(sock, buf, strlen(buf), 0) == -1) {
35        perror("send");
36        exit(EXIT_FAILURE);
37    }
38
39    // 关闭连接
40    close(sock);
41
42    return 0;
43}</code></pre>
    <h4>
     编译和运行
    </h4>
    <p>
     为了编译上述代码，你可以使用以下命令：
    </p>
    <pre><code>1gcc -o server server.c
2gcc -o client client.c</code></pre>
    <p>
     然后运行这两个程序：
    </p>
    <pre><code>1./server &amp;
2./client</code></pre>
    <h4>
     注意事项
    </h4>
    <ul>
     <li>
      在使用 Unix 域套接字之前，确保检查所有 API 调用的返回值，以确保操作成功。
     </li>
     <li>
      在关闭套接字之后，记得删除套接字文件，以避免占用不必要的系统资源。
     </li>
     <li>
      如果套接字文件不再需要，应使用
      <code>
       unlink()
      </code>
      删除它，以避免占用不必要的系统资源。
     </li>
     <li>
      在实际应用中，可能需要处理更复杂的错误情况，比如处理连接失败的情况。
     </li>
    </ul>
    <p>
     Unix 域套接字提供了一种简单而强大的机制来进行进程间的通信，非常适合那些需要快速访问共享数据的应用场景。理解和熟练掌握这些 API 对于开发可靠的多进程应用程序非常重要。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f73756966656e676d652f:61727469636c652f64657461696c732f313430373534303330" class_="artid" style="display:none">
 </p>
</div>


