---
layout: post
title: "数据库与存储优化"
date: 2025-03-06 19:18:42 +0800
description: "通过结合业务场景选择合适的存储方案，并持续监控关键指标（如MySQL的QPS、Elasticsearch的段合并频率），可显著提升系统性能和稳定性。"
keywords: "数据库与存储优化"
categories: ['未分类']
tags: ['数据库', 'Mybatis', 'Java']
artid: "146078062"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146078062
    alt: "数据库与存储优化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146078062
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146078062
cover: https://bing.ee123.net/img/rand?artid=146078062
image: https://bing.ee123.net/img/rand?artid=146078062
img: https://bing.ee123.net/img/rand?artid=146078062
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据库与存储优化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     <strong>
      一、MySQL深度优化
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        索引优化
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          B+树索引结构
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           结构特点
          </strong>
          ：
          <ul>
           <li>
            平衡多路搜索树，所有数据存储在叶子节点，非叶子节点仅存键值和指针。
           </li>
           <li>
            叶子节点通过双向链表连接，支持范围查询高效遍历。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           优势
          </strong>
          ：
          <ul>
           <li>
            减少磁盘IO（高扇出，3~4层可存储千万级数据）。
           </li>
           <li>
            适合范围查询（如
            <code>
             WHERE id BETWEEN 100 AND 200
            </code>
            ）。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          覆盖索引
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           定义
          </strong>
          ：索引包含查询所需的所有字段，无需回表。
         </li>
         <li>
          <strong>
           示例
          </strong>
          ：
          <pre><code class="language-sql">-- 创建覆盖索引 
CREATE INDEX idx_cover ON user(name, age); 
-- 查询命中覆盖索引 
SELECT name, age FROM user WHERE name = 'Alice';</code></pre>
          <p>
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          索引下推（ICP）
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           原理
          </strong>
          ：在存储引擎层过滤数据，减少回表次数。
         </li>
         <li>
          <strong>
           触发条件
          </strong>
          ：
          <ul>
           <li>
            查询条件包含索引列和非索引列。
           </li>
           <li>
            需在
            <code>
             WHERE
            </code>
            子句中使用索引前缀。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           查看ICP优化
          </strong>
          ：
          <pre><code class="language-sql">EXPLAIN SELECT * FROM user WHERE name = 'Alice' AND age &gt; 20; 

-- Extra列显示"Using index condition"</code></pre>
          <p>
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        锁机制
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          意向锁（Intention Locks）
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           作用
          </strong>
          ：快速判断表中是否存在行级锁，避免全表扫描。
         </li>
         <li>
          <strong>
           类型
          </strong>
          ：
          <ul>
           <li>
            意向共享锁（IS）：事务准备加行级共享锁。
           </li>
           <li>
            意向排他锁（IX）：事务准备加行级排他锁。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          间隙锁（Gap Locks）
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           功能
          </strong>
          ：锁定索引记录间的间隙，防止幻读（Phantom Read）。
         </li>
         <li>
          <strong>
           示例
          </strong>
          ：
          <pre><code class="language-sql">-- 对id范围(5,10)加间隙锁 
SELECT * FROM user WHERE id &gt; 5 AND id &lt; 10 FOR UPDATE;</code></pre>
          <p>
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          死锁排查
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           步骤
          </strong>
          ：
          <ol>
           <li>
            执行
            <code>
             SHOW ENGINE INNODB STATUS
            </code>
            ，查看
            <code>
             LATEST DETECTED DEADLOCK
            </code>
            。
           </li>
           <li>
            分析
            <code>
             WAITING FOR THIS LOCK
            </code>
            和
            <code>
             HOLDS THE LOCK
            </code>
            信息。
           </li>
          </ol>
         </li>
         <li>
          <strong>
           解决
          </strong>
          ：
          <ul>
           <li>
            调整事务顺序，缩短事务时间。
           </li>
           <li>
            使用
            <code>
             innodb_deadlock_detect = ON
            </code>
            （默认开启）自动检测。
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        分库分表
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         ShardingSphere分片策略
        </strong>
        <ul>
         <li>
          <strong>
           取模分片
          </strong>
          ：
          <code>
           user_id % 4
          </code>
          ，数据均匀分布，但扩容需迁移数据。
         </li>
         <li>
          <strong>
           范围分片
          </strong>
          ：按时间或ID范围分片，易导致数据倾斜。
         </li>
         <li>
          <strong>
           基因法路由
          </strong>
          ：
          <ul>
           <li>
            <strong>
             原理
            </strong>
            ：将关联数据（如订单和订单明细）的基因值（如用户ID哈希）嵌入分片键，确保关联查询在同一分片。
           </li>
           <li>
            <strong>
             示例
            </strong>
            ：
            <pre><code class="language-sql">-- 订单表分片键 = user_id % 8 
-- 订单明细表分片键 = (order_id的基因部分) % 8</code></pre>
            <p>
            </p>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      二、大数据存储优化
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        HBase
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          LSM树结构
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           写入流程
          </strong>
          ：
          <ol>
           <li>
            数据先写入内存（MemStore）。
           </li>
           <li>
            MemStore满后刷写到磁盘（HFile）。
           </li>
           <li>
            后台合并（Compaction）HFile，减少文件数。
           </li>
          </ol>
         </li>
         <li>
          <strong>
           优势
          </strong>
          ：高吞吐写入，适合时序数据。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          Region分裂机制
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           触发条件
          </strong>
          ：Region大小超过阈值（默认10GB）。
         </li>
         <li>
          <strong>
           分裂策略
          </strong>
          ：
          <ul>
           <li>
            <code>
             IncreasingToUpperBound
            </code>
            ：动态调整分裂阈值。
           </li>
           <li>
            <code>
             Disabled
            </code>
            ：手动控制分裂。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          RowKey设计
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           原则
          </strong>
          ：
          <ul>
           <li>
            <strong>
             散列化
            </strong>
            ：避免热点（如
            <code>
             MD5(user_id).substr(0,4) + user_id
            </code>
            ）。
           </li>
           <li>
            <strong>
             有序性
            </strong>
            ：时间戳反转（
            <code>
             Long.MAX_VALUE - timestamp
            </code>
            ）。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           示例
          </strong>
          ：
          <pre><code class="language-sql">RowKey = 盐值（4位） + 用户ID + 时间戳反转</code></pre>
          <p>
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Elasticsearch
       </strong>
      </p>
      <ul>
       <li>
        <p>
         <strong>
          倒排索引
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           结构
          </strong>
          ：词项（Term） → 文档ID列表。
         </li>
         <li>
          <strong>
           优化
          </strong>
          ：
          <ul>
           <li>
            使用
            <code>
             keyword
            </code>
            类型避免分词开销。
           </li>
           <li>
            合并段（Force Merge）减少查询时的段数量。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          分词器原理
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           标准分词器
          </strong>
          ：按空格和标点切分，过滤停用词。
         </li>
         <li>
          <strong>
           IK分词器
          </strong>
          ：
          <ul>
           <li>
            <code>
             ik_smart
            </code>
            ：粗粒度切分（如“清华大学” → “清华大学”）。
           </li>
           <li>
            <code>
             ik_max_word
            </code>
            ：细粒度切分（如“清华大学” → “清华”,“大学”）。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           自定义词典
          </strong>
          ：
          <pre><code class="language-java">PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_ik": {
          "type": "custom",
          "tokenizer": "ik_max_word",
          "filter": ["my_stopwords"]
        }
      },
      "filter": {
        "my_stopwords": {
          "type": "stop",
          "stopwords": ["的", "是"]
        }
      }
    }
  }
}
</code></pre>
          <p>
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          DSL优化技巧
         </strong>
        </p>
        <ul>
         <li>
          <strong>
           避免深分页
          </strong>
          ：使用
          <code>
           search_after
          </code>
          代替
          <code>
           from/size
          </code>
          。
         </li>
         <li>
          <strong>
           过滤器上下文
          </strong>
          ：将
          <code>
           term
          </code>
          查询放入
          <code>
           filter
          </code>
          ，利用缓存。
         </li>
         <li>
          <strong>
           冷热数据分离
          </strong>
          ：按时间范围分索引，热数据使用SSD存储。
         </li>
        </ul>
        <pre><code class="language-java">GET /logs-2023/_search
{
  "query": {
    "bool": {
      "filter": [
        { "range": { "@timestamp": { "gte": "now-1d/d" }}}
      ]
    }
  },
  "sort": [{"@timestamp": "desc"}],
  "size": 10,
  "search_after": [1698765432000]
}
</code></pre>
        <p>
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h5>
     <strong>
      三、总结与实战建议
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        MySQL优化重点
       </strong>
       ：
      </p>
      <ul>
       <li>
        索引设计遵循最左前缀原则，避免冗余索引。
       </li>
       <li>
        分库分表优先考虑基因法路由，减少跨分片查询。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        HBase核心实践
       </strong>
       ：
      </p>
      <ul>
       <li>
        RowKey设计需平衡散列与查询需求。
       </li>
       <li>
        预分区（Pre-split）避免自动分裂带来的性能波动。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Elasticsearch调优
       </strong>
       ：
      </p>
      <ul>
       <li>
        使用
        <code>
         _bulk
        </code>
        接口批量写入，提升吞吐量。
       </li>
       <li>
        定期清理旧索引，结合ILM（索引生命周期管理）自动化。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     通过结合业务场景选择合适的存储方案，并持续监控关键指标（如MySQL的QPS、Elasticsearch的段合并频率），可显著提升系统性能和稳定性。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f7171313334343639313732372f:61727469636c652f64657461696c732f313436303738303632" class_="artid" style="display:none">
 </p>
</div>


