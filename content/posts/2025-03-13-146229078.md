---
layout: post
title: "Linux浅谈冯诺依曼和进程"
date: 2025-03-13 19:35:06 +0800
description: "它提供用户接口和资源分配，是计算机系统中最基本的系统软件，任何计算机系统都包含一个基本的程序集合，统称为。9. I / O状态信息：包含显示的 I / O 请求，分配给进程的 I / O 设备和被进程使用的文件链表。5. 优先级：用来描述进程被调度的先后的数字，数字小的优先级高，数字大的优先级低，和成绩排名有异曲同工之妙。X死亡状态：这是一个返回状态，你不会在任务列表中看到这个状态，因为这是一个瞬时状态，一下就消失了。因为进程这里大部分时间都在做IO交互，IO的时间是很慢的，所有看不到R状态。"
keywords: "【Linux】浅谈冯诺依曼和进程"
categories: ['未分类']
tags: ['运维', '服务器', 'Linux']
artid: "146229078"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146229078
    alt: "Linux浅谈冯诺依曼和进程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146229078
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146229078
cover: https://bing.ee123.net/img/rand?artid=146229078
image: https://bing.ee123.net/img/rand?artid=146229078
img: https://bing.ee123.net/img/rand?artid=146229078
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Linux】浅谈冯诺依曼和进程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     一、冯诺依曼体系结构
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9af26e5d7c6049c9b0b43b676aa3fc04.png">
      <br/>
      冯诺依曼由
      <strong>
       输入设备、输出设备、运算器、控制器、存储器
      </strong>
      五部分组成。
     </img>
    </p>
    <h4>
     <a id="_3">
     </a>
     冯诺依曼的设计特点
    </h4>
    <ol>
     <li>
      <p>
       二进制表示
       <br/>
       所有数据（包括程序指令）均以二进制形式存储和运算，简化了硬件逻辑设计，提高了可靠性。
      </p>
     </li>
     <li>
      <p>
       存储程序原理 程序与数据共同存储于同一存储器中，且程序可像数据一样被修改。
      </p>
     </li>
     <li>
      <p>
       顺序执行机制 指令按线性顺序逐条执行，由程序计数器（PC）控制执行流程。
      </p>
     </li>
     <li>
      <p>
       ​指令结构 每条指令由操作码​（定义操作类型）和地址码​（指定操作数位置）组成。
      </p>
     </li>
    </ol>
    <h4>
     <a id="_11">
     </a>
     冯诺依曼体系结构的作用
    </h4>
    <p>
     <strong>
      引言：
     </strong>
     <strong>
      外设
     </strong>
     和
     <strong>
      CPU
     </strong>
     读取速度完全不一样，如果
     <strong>
      外设
     </strong>
     和
     <strong>
      CPU
     </strong>
     直接进行数据交互，就会导致
     <strong>
      CPU
     </strong>
     读取速度非常缓慢。但
     <strong>
      冯诺依曼体系结构
     </strong>
     就解决了这种问题，那它是怎么解决的呢？
    </p>
    <ol>
     <li>
      内存作为缓冲区
      <br/>
      冯·诺依曼体系结构将内存作为CPU和外设之间的缓冲区。外设将数据写入内存，CPU再从内存读取数据进行处理。这种设计解决了CPU与外设之间速度不匹配的问题。例如，外设（如硬盘）的读写速度远低于CPU，通过内存作为中间存储，可以避免CPU长时间等待外设完成操作。
     </li>
     <li>
      中断机制
      <br/>
      冯·诺依曼体系结构引入了中断机制，以优化CPU与外设之间的交互。外设在完成数据写入内存后，会发送中断信号通知CPU。CPU在收到中断信号后，再读取内存中的数据进行处理。这种方式避免了CPU轮询外设状态的低效操作，使得CPU可以将更多时间用于执行其他任务。
     </li>
     <li>
      数据传输的统一性
      <br/>
      在冯·诺依曼体系结构中，所有数据（包括程序指令和外设数据）都通过内存进行交互。这种统一的数据流动模式简化了硬件设计，使得CPU只需要支持对内存的读写操作，而无需直接处理多种外设协议。
     </li>
     <li>
      存储分级
      <br/>
      冯·诺依曼体系结构通过存储分级（如寄存器、缓存、内存、外存）来优化数据访问速度。内存作为中间层，其访问速度远高于外设，但低于CPU缓存和寄存器。通过这种分级设计，数据可以按需在不同存储层级之间流动，从而提高整体效率。
     </li>
     <li>
      操作系统与驱动程序的支持
      <br/>
      操作系统通过驱动程序将外设的复杂操作抽象成统一的接口，进一步优化了CPU与外设之间的数据交互。驱动程序可以动态更新，以支持新功能，而无需修改硬件。
     </li>
    </ol>
    <h3>
     <a id="Operator_System_24">
     </a>
     二、操作系统（Operator System）
    </h3>
    <h4>
     <a id="_25">
     </a>
     概念
    </h4>
    <p>
     <strong>
      操作系统（Operating System，简称OS）
     </strong>
     是管理计算机硬件与软件资源的系统软件。它提供用户接口和资源分配，是计算机系统中最基本的系统软件，任何计算机系统都包含一个基本的程序集合，统称为
     <strong>
      操作系统（OS）
     </strong>
     。
     <br/>
     简单来讲，
     <strong>
      操作系统
     </strong>
     包含 ：
    </p>
    <ol>
     <li>
      <strong>
       内核
      </strong>
      （进程管理、内存管理、文件管理、驱动管理）
     </li>
     <li>
      其他程序 （函数库、shell程序等）
     </li>
    </ol>
    <h4>
     <a id="OS_32">
     </a>
     设计OS的目的
    </h4>
    <ol>
     <li>
      对下，与硬件交互，管理所有软硬件资源
     </li>
     <li>
      对上，为用户程序提供一个良好的运行环境
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/eb39f0c40d4b46d8bc562b973b61dc79.png"/>
     </li>
    </ol>
    <h4>
     <a id="OS_37">
     </a>
     OS如何管理软、硬件
    </h4>
    <p>
     <strong>
      OS
     </strong>
     是怎么管理软、硬件的呢？，简单6个字就可以总结：
     <strong>
      先描述，再组织
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       先描述
      </strong>
      ：描述起来，用
      <strong>
       struct
      </strong>
      结构体来描述
     </li>
     <li>
      <strong>
       再组织
      </strong>
      ：通过数据结构报
      <strong>
       struct
      </strong>
      结构体组织起来，用链表或其他数据结构（队列、哈希等）组织起来
     </li>
    </ol>
    <h3>
     <a id="_42">
     </a>
     进程
    </h3>
    <p>
     上面讲了
     <strong>
      OS
     </strong>
     是怎么将软硬件资源管理起来的，那么对于进程也是再这样吗？答案是肯定的
    </p>
    <h4>
     <a id="_44">
     </a>
     概念
    </h4>
    <ol>
     <li>
      进程信息被放在一个叫做
      <strong>
       进程控制块
      </strong>
      的数据结构中，可以理解为描述进程属性的结构体
     </li>
     <li>
      课本上称之为
      <strong>
       PCB
      </strong>
      （
      <strong>
       process control block
      </strong>
      ）,
      <strong>
       Linux
      </strong>
      操作系统下的PCB叫做
      <strong>
       task_struct
      </strong>
      ,是一种结构体
     </li>
    </ol>
    <h4>
     <a id="task_struct__48">
     </a>
     task_struct （描述进程）
    </h4>
    <p>
     <strong>
      task_struct
     </strong>
     中的进程属性很多，我在这里描述其中的一部分：
     <br/>
     3. 标识符：描述本进程的唯一标识符，用来区别其他进程
     <br/>
     4. 状态：任务状态，退出代码，退出信号等
     <br/>
     5. 优先级：用来描述进程被调度的先后的数字，数字小的优先级高，数字大的优先级低，和成绩排名有异曲同工之妙
     <br/>
     6. 程序技术器（PC）：表示程序中即将执行的下一条指令的地址
     <br/>
     7. 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享内存块的指针
     <br/>
     8. 上下文数据：进程执行时处理器的寄存器中的数据，
     <strong>
      主要包括：
     </strong>
     <br/>
     CPU寄存器的值：包括程序计数器（PC）、指令寄存器、堆栈指针等。
     <br/>
     内存映射信息：进程的虚拟内存空间布局。
     <br/>
     进程状态：如运行状态、阻塞状态、就绪状态等。
     <br/>
     I/O状态：与进程相关的输入输出设备的状态。
     <br/>
     其他系统资源的状态：如文件描述符、信号状态等。
     <br/>
     9. I / O状态信息：包含显示的 I / O 请求，分配给进程的 I / O 设备和被进程使用的文件链表
     <br/>
     10. 记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号的等。
    </p>
    <h4>
     <a id="_64">
     </a>
     组织进程
    </h4>
    <p>
     <strong>
      PCB
     </strong>
     在内核中使用双链表进程链接起来的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5a6299fca6244add9b42a197f99a6039.png"/>
    </p>
    <h4>
     <a id="_67">
     </a>
     查看进程
    </h4>
    <ol>
     <li>
      <p>
       通过
       <strong>
        /proc
       </strong>
       系统文件夹来查看
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0bcb0fddc8a24a3294c3c9b41ce74083.png"/>
      </p>
     </li>
     <li>
      <p>
       通过
       <strong>
        top
       </strong>
       和
       <strong>
        ps
       </strong>
       这些用户工具来获取进程信息
       <br/>
       <strong>
        top:
       </strong>
       <code>
        top -p [pid]
       </code>
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/879c3d759cf64f72a545eeaf4f8b6530.png">
        <br/>
        <strong>
         ps:
        </strong>
        <code>
         ps axj
        </code>
       </img>
      </p>
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ee4eabf6411a4bf292274988f2f56b53.png"/>
    </p>
    <h4>
     <a id="_77">
     </a>
     通过系统调用获取进程标识符
    </h4>
    <ul>
     <li>
      获取进程id （PID）：
      <code>
       getpid()
      </code>
     </li>
     <li>
      父进程id （PID）:
      <code>
       getppid()
      </code>
     </li>
     <li>
      通过手册来查看相关系统调用：
      <code>
       man 2 getpid
      </code>
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1eb85601e94e4fb58c257f374687a07f.png"/>
     </li>
    </ul>
    <h4>
     <a id="fork_83">
     </a>
     通过系统调用fork创建子进程
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7fdaf4b2ab1f4a829e53b9e1267fe487.png"/>
     <br/>
     通过
     <strong>
      fork
     </strong>
     创建的子进程和父进程共享同一份代码，但数据是各自私有的（
     <strong>
      写时拷贝
     </strong>
     ）（其中
     <strong>
      pid_t
     </strong>
     的类型其实是一个有符号整数类型，取了个别名而已，当
     <strong>
      fork()
     </strong>
     返回值为 0 时就表示子进程，当
     <strong>
      fork()
     </strong>
     返回值大于0时，表示的就为父进程。）
     <br/>
     至于为什么数据各自私一份，有我们通过一个程序就可以看出来
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pid_t id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//表示子进程</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是子进程，pid: %d ,ppid: %d, val = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>val<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token comment">//父进程</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是父进程，pid: %d ,ppid: %d, val = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     程序运行结果：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/127a1f737a714b318b6226c8dca5c5d5.png"/>
     <br/>
     可以看到父进程和子进程的
     <strong>
      val
     </strong>
     的值并不是一样的，我们就可以得出父子进程并不共享同一份数据的结论
    </p>
    <h3>
     <a id="_123">
     </a>
     进程状态
    </h3>
    <p>
     进程状态有很多种：
    </p>
    <ul>
     <li>
      R运行状态：并不意味着进程一定在运行中，它表明进程要么在运行中，要么在运行队列中（
      <strong>
       运行队列用于管理处于“就绪状态”（Ready State）的进程。这些进程已经准备好运行，但正在等待 CPU 时间片分配。当调度器选择一个进程运行时，它会从运行队列中选取一个进程，并将其状态从“就绪”变为“运行”。
      </strong>
      ）
     </li>
     <li>
      S睡眠状态：以为着进程在等待事件完成（也叫做可中断睡眠）
      <br/>
      <strong>
       注意：
      </strong>
      以下有个场景可能让人误会为是
      <strong>
       R
      </strong>
      状态 ，但其实是
      <strong>
       S
      </strong>
      状态
     </li>
    </ul>
    <pre><code class="prism language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid: %d,cnt = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cnt<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">~</span>  
</code></pre>
    <p>
     这里可能很多认为进程的状态是R状态，其实不然，这里的进程状态其实大部分都是S+（
     <strong>
      +表示是前台进程
     </strong>
     ）状态，为什么呢？因为进程这里大部分时间都在做IO交互，IO的时间是很慢的，所有看不到R状态
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1c7842e5caa241e88cf33fb3e5e51062.png"/>
     <br/>
     表示每隔1秒查看对应名为code进程的信息：
     <code>
      while :;do ps axj | head -1 &amp;&amp; ps axj | grep code | grep -v grep;sleep 1 ; done
     </code>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/26bbbfcb75f1409a85067250ef9e426a.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/59a9790e1b2e4cc8bbe862f1983cdc0b.png"/>
    </p>
    <ul>
     <li>
      <p>
       D磁盘休眠状态：有时候叫做不可中断状态（不会响应信号），在这个状态等待IO的结束
      </p>
     </li>
     <li>
      <p>
       T停止状态：可以通过发送
       <strong>
        SIGSTOP
       </strong>
       信号来给进程停止 （T）进程。这个被暂停的进程可以通过发送
       <strong>
        SIGCOUT
       </strong>
       信号让进程继续执行
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/93dece103e424dddb16118a32cc7884a.png"/>
      </p>
     </li>
     <li>
      <p>
       X死亡状态：这是一个返回状态，你不会在任务列表中看到这个状态，因为这是一个瞬时状态，一下就消失了
      </p>
     </li>
     <li>
      <p>
       Z僵死状态：是一个比较特殊的状态。当进程退出并且父进程没有读到子进程返回的退出码时，子进程就会除以一个僵死状态。僵死状态会以终止状态保持在进程表中，并且会一直等待父进程读取退出状态代码（通过
       <strong>
        kill -9 pid
       </strong>
       杀死子进程就可以看到子进程处于僵死状态）
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bd043b59e61249a89c516ff81bce7384.png"/>
      </p>
     </li>
    </ul>
    <h4>
     <a id="_162">
     </a>
     僵死状态危害
    </h4>
    <p>
     没创建一个子进程就需要一个
     <strong>
      PCB
     </strong>
     ，如果父进程创建了很多子进程，而没有去回收就会造成内存资源的浪费
    </p>
    <h3>
     <a id="_165">
     </a>
     孤儿进程
    </h3>
    <p>
     父进程如果提前退出，子进程就会变成孤儿进程，孤儿进程就会被1号
     <strong>
      init
     </strong>
     也就是操作系统启动后第一个运行的用户空间程序
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8fb36ff98aed4b658b1f5b3205ffa9f0.png"/>
    </p>
    <h3>
     <a id="_168">
     </a>
     进程优先级
    </h3>
    <h4>
     <a id="_169">
     </a>
     基本概念
    </h4>
    <ul>
     <li>
      <p>
       cpu资源分配的先后顺序，就是进程的优先权。
      </p>
     </li>
     <li>
      <p>
       优先级高的进程有优先执行权利。
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d71dd2fc6caf47c18f04804b156c8a2c.png"/>
      </p>
     </li>
     <li>
      <p>
       UID : 代表执⾏者的⾝份
      </p>
     </li>
     <li>
      <p>
       PID : 代表这个进程的代号
      </p>
     </li>
     <li>
      <p>
       PPID ：代表这个进程是由哪个进程发展衍⽣⽽来的，亦即⽗进程的代号
      </p>
     </li>
     <li>
      <p>
       PRI ：代表这个进程可被执⾏的优先级，其值越⼩越早被执⾏
      </p>
     </li>
     <li>
      <p>
       NI ：代表这个进程的nice值（
       <strong>
        修正优先级数值的
       </strong>
       ）
      </p>
     </li>
    </ul>
    <p>
     其中
     <strong>
      PRI（new） = PRI（采用默认值80） + nice
     </strong>
    </p>
    <h4>
     <a id="nice_186">
     </a>
     更改进程nice值
    </h4>
    <p>
     通过更改进程
     <strong>
      nice
     </strong>
     来改变进程优先级
     <br/>
     用
     <strong>
      top
     </strong>
     命令来改变进程
     <strong>
      nice
     </strong>
     值：
    </p>
    <ol>
     <li>
      进入top后按 “r” -&gt; 输入进程PID -&gt; 输入nice值
     </li>
    </ol>
    <h3>
     <a id="_190">
     </a>
     进程竞争、独立、并行、并发
    </h3>
    <ol start="2">
     <li>
      竞争：本质是僧多粥少，系统进程数目众多，而CPU资源只有少量，所以进程之间具有竞争属性，为了更高效的完成任务，更合理竞争相关资源，于是就有了优先级
     </li>
     <li>
      独立：多进程在运行时，需要独享各种资源，进程之间互不干扰，就算一个进程挂掉了，也不影响另一个进程，而如果线程挂掉了，不仅会影响其他进程，可能还会导致进程挂掉。
     </li>
     <li>
      并行：多个进程在多个CPU下同时进行运行
     </li>
     <li>
      并发：多个进程在同一个CPU资源下采用进程切换的方式，在同一段时间之内，让多个进程都得以推进
     </li>
    </ol>
    <h3>
     <a id="_195">
     </a>
     进程切换
    </h3>
    <p>
     在多任务操作系统中，多个进程会共享有限的 CPU 资源。为了实现高效的资源利用和良好的用户体验，操作系统需要在这些进程之间切换 CPU 的控制权。这种切换通常发生在以下几种情况：
    </p>
    <ol>
     <li>
      时间片用完：在时间片轮转（Round Robin）调度算法中，当一个进程的时间片用完时，操作系统会将 CPU 切换到另一个进程。
      <br/>
      进程阻塞：当一个进程因为等待 I/O 操作（如磁盘读写、网络通信）而阻塞时，操作系统会将 CPU 切换到另一个就绪的进程。
      <br/>
      更高优先级的进程就绪：当一个更高优先级的进程进入就绪队列时，操作系统可能会抢占当前运行的进程，将 CPU 切换到优先级更高的进程。
      <br/>
      系统调用或中断：当进程执行系统调用或发生中断时，操作系统可能会触发进程切换。
     </li>
     <li>
      进程切换的过程
      <br/>
      进程切换是一个复杂的过程，涉及到多个步骤，主要包括以下内容：
      <br/>
      2.1 保存当前进程的上下文
      <br/>
      当操作系统决定切换进程时，首先需要保存当前运行进程的上下文信息。上下文信息包括：
      <br/>
      CPU 寄存器的值：如程序计数器（PC）、指令寄存器（IR）、堆栈指针（SP）等。
      <br/>
      进程状态：如运行状态、就绪状态或阻塞状态。
      <br/>
      内存映射信息：如页表或段表。
      <br/>
      I/O 状态：如打开的文件描述符、设备状态等。
      <br/>
      这些上下文信息通常被保存在进程控制块（PCB，Process Control Block）中，或者在内核栈中。
      <br/>
      2.2 更新进程状态
      <br/>
      操作系统会更新当前进程的状态，将其从“运行状态”（Running State）改为“就绪状态”（Ready State）或“阻塞状态”（Blocked State），具体取决于进程为何被切换出去。
      <br/>
      2.3 选择下一个要运行的进程
      <br/>
      操作系统通过调度器（Scheduler）选择下一个要运行的进程。调度器会根据调度算法（如先来先服务、时间片轮转、优先级调度等）从就绪队列中选择一个进程。
      <br/>
      2.4 恢复新进程的上下文
      <br/>
      操作系统从新进程的 PCB 或内核栈中恢复其上下文信息，包括：
      <br/>
      将寄存器的值恢复到 CPU 寄存器中。
      <br/>
      更新内存映射信息。
      <br/>
      恢复 I/O 状态。
      <br/>
      2.5 将 CPU 控制权交给新进程
      <br/>
      操作系统将 CPU 的控制权交给新进程，新进程从上次被中断的地方继续执行。
     </li>
     <li>
      进程切换的开销
      <br/>
      进程切换是一个相对昂贵的操作，因为它涉及到大量的上下文保存和恢复工作。每次切换都会消耗一定的 CPU 时间，具体开销包括：
      <br/>
      寄存器保存和恢复：保存和恢复 CPU 寄存器的值。
      <br/>
      内存映射切换：更新页表或段表。
      <br/>
      调度器开销：选择下一个进程的开销。
      <br/>
      缓存失效：切换进程可能导致 CPU 缓存失效，新进程需要重新加载数据到缓存中。
      <br/>
      因此，操作系统会尽量减少不必要的进程切换，以提高系统性能。
     </li>
     <li>
      示例：进程切换的场景
      <br/>
      假设系统中有两个进程 A 和 B，它们共享 CPU 资源。以下是进程切换的一个简单示例：
      <br/>
      进程 A 运行：
      <br/>
      进程 A 正在 CPU 上运行，执行某些任务。
      <br/>
      时间片用完，操作系统决定切换进程。
      <br/>
      保存进程 A 的上下文：
      <br/>
      操作系统保存进程 A 的寄存器值、内存映射信息等，并将其状态从“运行状态”改为“就绪状态”。
      <br/>
      选择进程 B：
      <br/>
      调度器从就绪队列中选择进程 B。
      <br/>
      恢复进程 B 的上下文：
      <br/>
      操作系统恢复进程 B 的寄存器值、内存映射信息等。
      <br/>
      进程 B 运行：
      <br/>
      进程 B 从上次被中断的地方继续执行。
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0a17eb1634294151be5c034fe0ebf04d.png"/>
    </p>
    <h3>
     <a id="Linux26O1_244">
     </a>
     Linux2.6内核进程O(1)调度队列
    </h3>
    <p>
     <a href="https://elixir.bootlin.com/linux/v6.13.6/source" rel="nofollow">
      LInux源码查看网站
     </a>
     <br/>
     <a href="https://www.kernel.org/" rel="nofollow">
      Linux源码官方网站
     </a>
    </p>
    <h4>
     <a id="Linux26_247">
     </a>
     Linux2.6内核调度队列
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/66b4e228e86d48e58ee1cd3326e41059.png"/>
    </p>
    <h5>
     <a id="array0_249">
     </a>
     活动队列（array[0]）
    </h5>
    <ul>
     <li>
      时间片还没有结束的所有的进程都会按照优先级放在该队列
     </li>
     <li>
      nr_active：总共有多少个运行的进程
     </li>
     <li>
      queue[140]：一个元素就是一个进程队列，相同优先级的进程按照 FIFO（先进先出）的规则排队调度，所以数组下标就是优先级
     </li>
     <li>
      bitmap[5]：一共140个优先级，用位图就可以提高非空队列的效率，一个整形占32个比特位，数组大小为5，就有5 * 32 = 160 个bit位来表示队列是否为空，大大提高了查找效率
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e4ecea3dde4240169751b018c738c0cd.png"/>
     </li>
    </ul>
    <h5>
     <a id="_256">
     </a>
     过期队列
    </h5>
    <ul>
     <li>
      过期队列上的进程都是时间片耗尽之后的进程
     </li>
     <li>
      活动队列上的进程都被处理完毕以后，就会对过期队列的进程进行时间片重新计算
     </li>
    </ul>
    <h5>
     <a id="active__expired__259">
     </a>
     active 和 expired 指针
    </h5>
    <ul>
     <li>
      active指针永远指向活动队列
     </li>
     <li>
      expired指针永远指向过期队列
     </li>
     <li>
      活动队列中的进程进程会越来越少，过期队列上的进程会越来越多，因为进程时间片到期就会进入过期队列，但在合适的时间交换
      <strong>
       active
      </strong>
      指针和
      <strong>
       expired
      </strong>
      指针的内容，即 swap(&amp;active,&amp;expired) ,活动队列就又有了一批新的活动进程
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f38303138373437362f:61727469636c652f64657461696c732f313436323239303738" class_="artid" style="display:none">
 </p>
</div>


