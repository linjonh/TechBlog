---
arturl_encode: "6874747073:3a2f2f626c6f672e6373646e2e6e65742f776a63726f6f6d2f:61727469636c652f64657461696c732f313436313634363634"
layout: post
title: "æ–‡æœ¬è½¬è¯­éŸ³-éŸ³ç”»é€‚æ—¶æ¨é€rtspå¹¶æ’­æ”¾"
date: 2025-03-10 22:08:17 +0800
description: "è€Œä»Šå¤©çš„è¿™ä¸ªç›¸ä¼¼åŠŸèƒ½çš„ä»£ç æ˜¯mac osï¼Œç†è®ºæ”¯æŒwindowsï¼Œå’Œlinuxï¼Œä¾èµ–ffmpegå’Œxiuï¼ˆä¸€ä¸ªrustæµæœåŠ¡å™¨ï¼‰çš„rtspæœåŠ¡ã€‚éŸ³ç”»åŒæ­¥åº”è¯¥æ˜¯å¦ä¸ªé—®é¢˜äº†ï¼Œå‡ å¤©å‰ï¼Œé¼“æ£äº†ä¸€ä¸‹å›¾ç‰‡ã€‚è®©ç¼–è¾‘åçš„ï¼Œé©¬ä¸Š åœ¨è§†é¢‘ä¸­æ˜¾ç¤ºã€‚åšçš„è¿™äº›å°±ä¸ºäº†ï¼Œè®©æŠ¥å·å’Œç‚¹å•ï¼Œæœ‰ä¸ªç•Œé¢ã€‚è¿™ä¸¤å¤©åœ¨å¼„è¿™ä¸ªï¼Œå‰2ç¯‡æ˜¯é€šè¿‡è™šæ‹Ÿå£°å¡ï¼Œè¾¾åˆ°äº†æœ€ç®€å•çš„ä¸€ä¸ªé€»è¾‘ï¼Œæ’­æ”¾æ–‡æœ¬å°±ä»å£°å¡å‘å£°ï¼Œä¸æ’­æ— æ‰€è°“ï¼Œè‡ªåŠ¨å¿™éŸ³ã€‚é‚£ä¸ªå·¥ä½œåœ¨windowså¹³å°ï¼Œå¯¹äºåˆšæ¥è§¦çš„ï¼Œæœ€å¥½æ˜¯æ…¢æ…¢å’ŒAIè°ƒè¯•ç€æ¥ï¼Œä¸€äº›åŠŸèƒ½å°±åšå‡ºæ¥ã€‚åˆå¹¶çš„ä»£ç ï¼Œå°±å½“æˆå‰©ä¸‹çš„ä½œä¸šï¼Œæœ‰ç©ºå†æ¥åšã€‚"
keywords: "logazspeech: display: task: utexttoaudiodataasync::texttoaudiodata (112178);"
categories: ['æ—¥å¸¸å°æ“ä½œ', 'Python', 'Mac']
tags: ['Python']
artid: "146164664"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146164664
    alt: "æ–‡æœ¬è½¬è¯­éŸ³-éŸ³ç”»é€‚æ—¶æ¨é€rtspå¹¶æ’­æ”¾"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146164664
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146164664
cover: https://bing.ee123.net/img/rand?artid=146164664
image: https://bing.ee123.net/img/rand?artid=146164664
img: https://bing.ee123.net/img/rand?artid=146164664
---

# æ–‡æœ¬è½¬è¯­éŸ³-éŸ³ç”»é€‚æ—¶æ¨é€rtspå¹¶æ’­æ”¾

æ–‡æœ¬è¯­éŸ³ rtspé€‚æ—¶æ’­æ”¾å«å·ç³»ç»Ÿçš„åº•å±‚é€»è¾‘

  
å‘å¸ƒLinux, unix socket å’Œwindow win32åšä¸ºéŸ³é¢‘æºçš„ python10ä¸‹çš„(ffmpeg version 7.1) å¯è¿è¡Œç‰ˆæœ¬.

è¿™ä¸¤å¤©åœ¨å¼„è¿™ä¸ªï¼Œå‰2ç¯‡æ˜¯é€šè¿‡è™šæ‹Ÿå£°å¡ï¼Œè¾¾åˆ°äº†æœ€ç®€å•çš„ä¸€ä¸ªé€»è¾‘ï¼Œæ’­æ”¾æ–‡æœ¬å°±ä»å£°å¡å‘å£°ï¼Œä¸æ’­æ— æ‰€è°“ï¼Œè‡ªåŠ¨å¿™éŸ³ã€‚ é‚£ä¸ªå·¥ä½œåœ¨windowså¹³å°ï¼Œ
  
è€Œä»Šå¤©çš„è¿™ä¸ªç›¸ä¼¼åŠŸèƒ½çš„ä»£ç æ˜¯mac osï¼Œç†è®ºæ”¯æŒwindowsï¼Œå’Œlinuxï¼Œä¾èµ–ffmpegå’Œxiuï¼ˆä¸€ä¸ªrustæµæœåŠ¡å™¨ï¼‰çš„rtspæœåŠ¡ã€‚
  
ä»Šå¤©çš„éš¾ç‚¹æœ‰ç‚¹å¤š

1. asyncioçš„ä»»åŠ¡ async def \_tts\_worker(self, text: str) è¿è¡Œä¸­æœ‰å„ç§é”™è¯¯ï¼Œ engine runAndWaitæ˜¯ä¸è¡Œçš„ã€‚ å†…éƒ¨æœ‰å®ƒçš„event loopã€‚æ‰€ä»¥initå’ŒendLoopï¼Œæ˜¯æš‚æ—¶æ‰¾åˆ°çš„è§£å†³åŠæ³•ã€‚åŒæ—¶ç»å†äº†ï¼Œè¿™ä¸ªï¼Œå’Œè°ƒç”¨ ffmpeg å¤–éƒ¨æŒ‡ä»¤ï¼Œå¹¶ç›´æ¥è·å–- ä»£è¡¨çš„stdoutã€‚ ä¼šé‡åˆ°å„ç§é—®é¢˜ã€‚åšäº†æ•è·å’Œå¤„ç†ã€‚ä½†æ˜¯æŸ¥æ‰¾çš„æ—¶å€™ï¼Œä¸æ˜¯å¤ªå®¹æ˜“ã€‚
2. self.\_start\_ffmpeg() ä»–éœ€è¦ï¼Œ create socket æˆ–pipeå®Œæˆä»¥åï¼Œæ‰èƒ½è¿è¡Œã€‚ è°ƒè¯•æˆ‘éƒ½æ‰‹å·¥åœ¨å¤–éƒ¨å¯åŠ¨ã€‚ ä½œç”¨å°±æ˜¯ï¼Œè¾“å‡ºåˆ°rtspæœåŠ¡å™¨ï¼Œä»¥å¤‡æ’­æ”¾ã€‚
3. input handleï¼Œç­‰éƒ½æ˜¯aiç”Ÿæˆçš„ï¼Œå› ä¸ºæœ‰å¥½å¤šç§å¾ªç¯ï¼Œè¿™æ˜¯æ¯”è¾ƒçœå¿ƒåœ¨ã€‚
4. æœ€ç´§æ€¥éšè”½åœ¨æ˜¯ï¼Œ async def \_heartbeat(self) ä»–éœ€è¦è®¡ç®—æ’­æ”¾é™éŸ³çš„æ—¶é—´ï¼Œé•¿äº†ä¸è¡Œï¼ŒçŸ­äº†ä¸è¡Œã€‚ è¿™ä¸ªæœ€åˆåœ¨æµ‹è¯•ä»£ç ï¼Œå°±å‡ ä¸ªå‡½æ•°ã€‚ç„¶åAIï¼Œç”Ÿæˆäº†ä¸‰ä¸ªtheadingçš„ç‰ˆæœ¬ï¼Œä¸¤ä¸ªQueueã€‚ ç„¶åè½¬åˆ°äº†å¼‚æ­¥ç‰ˆæœ¬ï¼Œæ˜æ˜¾å¿«äº†å¾ˆå¤šã€‚
5. åœ¨windowsä¸Šä½¿ç”¨win32pipenå¯ä»¥è¾¾åˆ°unix socketçš„æ•ˆæœå¾ˆç›¸ä¼¼ï¼Œ è®°å¾—è¿˜æœ‰FIFOæ˜¯linuxä¸“ç”¨çš„ï¼Œå½“ç„¶è¿˜æœ‰stdinï¼Œå’Œstdoutã€‚å¯¹äºffmpegï¼Œè¿™æ˜¯ä¸€äº›ç¨‹åºå†…éƒ¨çš„ä¼ é€æœºåˆ¶
6. rtspæ˜¯éœ€è¦ä¸€ä¸ªåå°çš„æœåŠ¡çš„ï¼Œxiuæ˜¯å¼€æºçš„rusté¡¹ç›®ï¼Œå¯ä»¥ä½¿ã€‚å¦å¤–windowæ¨èmetamtxï¼ŒåŒå‡»è¿è¡Œï¼Œä»€ä¹ˆä¹Ÿä¸ç®¡ã€‚
     
   ![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/c2d51fe12f9b4bc69dcc0720b56d8a26.png#pic_center)

éŸ³ç”»åŒæ­¥åº”è¯¥æ˜¯å¦ä¸ªé—®é¢˜äº†ï¼Œå‡ å¤©å‰ï¼Œé¼“æ£äº†ä¸€ä¸‹å›¾ç‰‡ã€‚è®©ç¼–è¾‘åçš„ï¼Œé©¬ä¸Š åœ¨è§†é¢‘ä¸­æ˜¾ç¤ºã€‚ è¿™ä¸ªå¦å¤–ä¸€ä¸ªè¯é¢˜äº†ã€‚åšçš„è¿™äº›å°±ä¸ºäº†ï¼Œè®©æŠ¥å·å’Œç‚¹å•ï¼Œæœ‰ä¸ªç•Œé¢ã€‚

```bash
ffmpeg -re -framerate 30 -f image2 -loop 1 -i "image1.jpg" -c:v libx264 -preset ultrafast -tune zerolatency -pix_fmt rgba  -f rtsp -rtsp_transport tcp rtsp://localhost:8554/live

```

åˆå¹¶çš„ä»£ç ï¼Œå°±å½“æˆå‰©ä¸‹çš„ä½œä¸šï¼Œæœ‰ç©ºå†æ¥åšã€‚

å¯¹äºåˆšæ¥è§¦çš„ï¼Œæœ€å¥½æ˜¯æ…¢æ…¢å’ŒAIè°ƒè¯•ç€æ¥ï¼Œä¸€äº›åŠŸèƒ½å°±åšå‡ºæ¥ã€‚

å¯åŠ¨







æ¥æ”¶text














FIFOunix..









åŒæ­¥è¯­éŸ³ä¼ è¾“








è¯­éŸ³ æ¨é€








æ–‡æœ¬è½¬è¯­éŸ³








rtspæµæœåŠ¡å™¨

è¯­éŸ³æ¨é€ä½¿ç”¨ffmpegç‹¬ç«‹è¿›ç¨‹ï¼Œå®ç°äº†å‰åä¸­æ–­åè‡ªåŠ¨é‡å¯ã€‚

### ç¨‹åºä¸»ä½“

å¯ç‹¬ç«‹è¿è¡Œï¼Œä¹Ÿå¯ä»¥ç»“åˆffmgç®¡ç†æ¨é€è¿›ç¨‹

1. macos ,ç†è®ºLinuxé€‚ç”¨,å•æ–‡ä»¶å¯æ‰§è¡Œ
     
   main.py

```bash
import asyncio
import struct
import pyttsx3
import tempfile
import os
import socket
from aioconsole import ainput
from contextlib import suppress
from typing import Optional

class AsyncTTSController:
    def __init__(self):
        # ä½¿ç”¨UnixåŸŸå¥—æ¥å­—
        self.socket_path = "/tmp/tts_audio.sock"
        self.server_socket: Optional[socket.socket] = None
        self.client_socket: Optional[socket.socket] = None
        
        # è¿›ç¨‹æ§åˆ¶
        self.ffmpeg_process: Optional[asyncio.subprocess.Process] = None
        self.running = False
        
        # TTSå¼•æ“
        self.engine = pyttsx3.init()
        self.engine.setProperty('rate', 180)
        self.engine.setProperty('volume', 1.0)
        
        # éŸ³é¢‘å‚æ•°
        self.sample_rate = 24000
        self.channels = 1
        self.bits_per_sample = 16
        self.silence = self._generate_silence(0.2)
        self.wav_header = self._generate_wav_header()
        
        # çŠ¶æ€ç®¡ç†
        self.connection_active = False
        self.last_heartbeat = 0.0
        self.heartbeat_interval = 2.0
        self.sending_audio = 0
    def _generate_wav_header(self) -> bytes:
        """ç”ŸæˆWAVæ–‡ä»¶å¤´"""
        byte_rate = self.sample_rate * self.channels * self.bits_per_sample // 8
        block_align = self.channels * self.bits_per_sample // 8
        return struct.pack(
            '<4sI4s4sIHHIIHH4sI',
            b'RIFF', 36, b'WAVE', b'fmt ', 16, 1, self.channels,
            self.sample_rate, byte_rate, block_align, self.bits_per_sample,
            b'data', 0
        )

    def _generate_silence(self, duration: float) -> bytes:
        """ç”Ÿæˆé™éŸ³æ•°æ®"""
        samples = int(self.sample_rate * duration)
        return bytes(samples * self.channels * (self.bits_per_sample // 8))

    async def _async_create_socket(self) -> None:
        """åˆ›å»ºUnixåŸŸå¥—æ¥å­—"""
        with suppress(Exception):
            if os.path.exists(self.socket_path):
                os.unlink(self.socket_path)
                
            self.server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.server_socket.setblocking(False)
            self.server_socket.bind(self.socket_path)
            self.server_socket.listen(1)
            
            loop = asyncio.get_running_loop()
            while self.running and not self.connection_active:
                try:
                    self.client_socket, _ = await loop.sock_accept(self.server_socket)
                    self.connection_active = True
                    print("å®¢æˆ·ç«¯å·²è¿æ¥")
                    await loop.sock_sendall(self.client_socket, self.wav_header)
                except (BlockingIOError, InterruptedError):
                    await asyncio.sleep(0.1)
                except Exception as e:
                    print(f"è¿æ¥é”™è¯¯: {str(e)}")
                    self.connection_active = False
                    await asyncio.sleep(1)

    async def _start_ffmpeg(self) -> None:
        """å¯åŠ¨FFmpegè¿›ç¨‹"""
        with suppress(Exception):
            if self.ffmpeg_process:
                self.ffmpeg_process.terminate()
                await self.ffmpeg_process.wait()
            socketid='unix:'+self.socket_path

            self.ffmpeg_process = await asyncio.create_subprocess_exec(
                'ffmpeg',
                '-f', 's16le',
                '-ar', str(self.sample_rate),
                '-ac', str(self.channels),
                '-i', socketid,  # ä¿®æ”¹è¾“å…¥æºä¸ºå¥—æ¥å­—è·¯å¾„
                '-c:a', 'aac',
                '-f', 'rtsp',
                '-rtsp_transport', 'tcp',
                'rtsp://localhost:8554/mystream',
                stdout=asyncio.subprocess.DEVNULL,
                stdin=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.PIPE
            )
            asyncio.create_task(self._monitor_ffmpeg_errors())

    async def _monitor_ffmpeg_errors(self) -> None:
        """ç›‘æ§FFmpegé”™è¯¯è¾“å‡º"""
        while self.running and self.ffmpeg_process:
            line = await self.ffmpeg_process.stderr.readline()
            if not line:
                break
         #   print(f"[FFmpeg Error] {line.decode().strip()}")

    async def _async_write_socket(self, data: bytes) -> None:
        """å®‰å…¨å†™å…¥å¥—æ¥å­—"""
        try:
            if self.client_socket and self.connection_active:
                loop = asyncio.get_running_loop()
                await loop.sock_sendall(self.client_socket, data)
        except (BrokenPipeError, ConnectionResetError):
            print("è¿æ¥å·²æ–­å¼€ï¼Œå°è¯•é‡è¿...")
            await self._reconnect_pipeline()
        except Exception as e:
            print(f"å†™å…¥é”™è¯¯: {str(e)}")
            self.connection_active = False

    async def _reconnect_pipeline(self) -> None:
        """å®Œæ•´é‡è¿æµç¨‹"""
        print("å¯åŠ¨é‡è¿æµç¨‹...")
        self.connection_active = False
        if self.client_socket:
            self.client_socket.close()
        task1=asyncio.create_task(self._async_create_socket()),
        task2=asyncio.create_task( self._start_ffmpeg()),    
        await task2
        await task1
       # await asyncio.gather(task1, task2)
        #await self._async_create_socket()
        #await self._start_ffmpeg()

    # å‰©ä½™çš„heartbeatã€tts_workerã€input_handlerç­‰æ–¹æ³•ä¿æŒç›¸åŒ...

    async def stop(self) -> None:
        """å®‰å…¨å…³é—­"""
        self.running = False
        with suppress(Exception):
            if self.ffmpeg_process:
                self.ffmpeg_process.terminate()
                await self.ffmpeg_process.wait()
            if self.client_socket:
                self.client_socket.close()
            if self.server_socket:
                self.server_socket.close()
            if os.path.exists(self.socket_path):
                os.unlink(self.socket_path)
            print("æ‰€æœ‰èµ„æºå·²é‡Šæ”¾")
    async def _heartbeat(self) -> None:
        """å¿ƒè·³ç»´æŒæœºåˆ¶"""
        while self.running:
            if self.connection_active :
                for i in range(10):
                    if   self.sending_audio<0:
                       await self._async_write_socket(self.silence)
                    else :
                        self.sending_audio-= 2
                    await asyncio.sleep(0.2)   
                    
           #     print(self.sending_audio,"slend")
              #  await asyncio.sleep(self.heartbeat_interval)
            else:
                await asyncio.sleep(0.5)
    def _sync_tts(self,text,tmp_filename):
        eng=pyttsx3.init()
      #  eng.say(text)
        eng.save_to_file(text, 'temp3.wav')
        eng.runAndWait()
        eng.endLoop()
            
    async def _tts_worker(self, text: str) -> None:
        """å¼‚æ­¥TTSå¤„ç†æ ¸å¿ƒ"""
        tmp_filename = None
        #with open('audio1.raw','rb') as chunkf:
                # data=chunkf.read()
                # secdd=len(data)/48000
                # self.sending_audio=int(secdd*10) 
                # await self._async_write_socket(data)
               
              
                # #await asyncio.sleep(secdd)
                
 
                # print (secdd,len(data) )   
        
            # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
        with tempfile.NamedTemporaryFile(delete=False) as tmp:
                tmp_filename = tmp.name

            # # åŒæ­¥TTSæ“ä½œè½¬å¼‚æ­¥æ‰§è¡Œ
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, self._sync_tts, *(text, 'temp3.wav',))
            # è½¬æ¢éŸ³é¢‘æ ¼å¼
           # await asyncio.sleep(1.3)
           # self._sync_tts(text,tmp_filename)
        try: 
            proc = await asyncio.create_subprocess_exec(
    'ffmpeg',
    '-hide_banner',
    '-loglevel', 'error',
    '-y',
    '-i', 'temp3.wav',       # è¾“å…¥æ–‡ä»¶è·¯å¾„
    '-f', 's16le',            # å¼ºåˆ¶è¾“å‡ºæ ¼å¼ä¸ºPCM s16le
    '-acodec', 'pcm_s16le',   # æ˜ç¡®æŒ‡å®šéŸ³é¢‘ç¼–è§£ç å™¨ ğŸ‘ˆ å…³é”®ä¿®å¤
    '-ar', str(self.sample_rate),
    '-ac', str(self.channels),
    '-',                     # è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡º
    stdout=asyncio.subprocess.PIPE
)

           # æµå¼å‘é€éŸ³é¢‘æ•°æ®
            sum=0
            while chunk := await proc.stdout.read(4096):
              
               sum+=len(chunk)
               await self._async_write_socket(chunk)
            self.sending_audio=int(sum*10/48000) 
            print("write data x0.1s:",self.sending_audio)


        finally:
            if tmp_filename and os.path.exists(tmp_filename):
              1
              #  os.unlink(tmp_filename)

    async def _input_handler(self) -> None:
        """å¼‚æ­¥è¾“å…¥å¤„ç†"""
        while self.running:
            try:
                text = await ainput("è¯·è¾“å…¥æ–‡æœ¬ï¼ˆè¾“å…¥qé€€å‡ºï¼‰: ")
                if text.lower() == 'q':
                    self.running = False
                    break
                if text.strip():
                  await self._tts_worker(text)
            except Exception as e:
                print(f"è¾“å…¥é”™è¯¯: {str(e)}")

    async def run(self) -> None:
        """ä¸»è¿è¡Œå¾ªç¯"""
        self.running = True
       # 
        #await  self._start_ffmpeg()

        tasks = [
            asyncio.create_task(self._async_create_socket()),
            asyncio.create_task( self._start_ffmpeg()),
            asyncio.create_task(self._input_handler()),
            asyncio.create_task(self._heartbeat()),


        ]
       
        await asyncio.gather(*tasks)
       
    

# ä»¥ä¸‹ä¿æŒä¸å˜...
if __name__ == "__main__":
    controller = AsyncTTSController()
    try:
        asyncio.run(controller.run())
    except KeyboardInterrupt:
        asyncio.run(controller.stop())
"""
ffmpeg -y -i temp.wav -f s16le -acodec pcm_s16le  -ar 24000  -ac 1   audio.raw
ffmpeg  -ar 24000 -ac 1 -f s16le  -i unix:/tmp/tts_audio.sock -f rtsp  rtsp://localhost:8554/mystream
"""

```

2. window10ç³»ç»Ÿpython10 å¯è¿è¡Œç‰ˆæœ¬
     
   ä¸»è¦è®©deepseek,æ‰§è¡Œäº†,socket åˆ° win32pipençš„æ›¿æ¢.å› ä¸ºæœ¬æ¥å°±æ˜¯æ¢è¿‡å»çš„.è¿™ä¸€å—çš„ä»£ç å®Œå…¨æ²¡æœ‰æ‰‹å·¥ä»‹å…¥. å”¯ä¸€æ”¹çš„æ˜¯æ³¨é‡Šeng.endLoop(),å¹¶ä¸ç”¨æ¯æ¬¡init() ,åº”æ”¹æ˜¯pyttsx3çš„ä¸€ä¸ªè·¨å¹³å°ç‰¹æ€§. ,å¼‚æ­¥çš„win32ä¸‹æ”¯æŒç¨³å®š.

```bash
    def _sync_tts(self, text, tmp_filename):
         eng = self.engine  #pyttsx3.init()
        eng.save_to_file(text, 'temp3.wav')
        eng.runAndWait()
      #  eng.endLoop()

```

main-win.py

```bash
import asyncio
import struct
import pyttsx3
import tempfile
import os
from aioconsole import ainput
from contextlib import suppress
from typing import Optional
import win32pipe
import win32file
import pywintypes

class AsyncTTSController:
    def __init__(self):
        # ä½¿ç”¨Windowså‘½åç®¡é“
        self.pipe_name = r'\\.\pipe\tts_audio_pipe'
        self.pipe_handle = None
        
        # è¿›ç¨‹æ§åˆ¶
        self.ffmpeg_process: Optional[asyncio.subprocess.Process] = None
        self.running = False
        
        # TTSå¼•æ“
        self.engine = pyttsx3.init()
        self.engine.setProperty('rate', 180)
        self.engine.setProperty('volume', 1.0)
        
        # éŸ³é¢‘å‚æ•°
        self.sample_rate = 24000
        self.channels = 1
        self.bits_per_sample = 16
        self.silence = self._generate_silence(0.2)
        self.wav_header = self._generate_wav_header()
        
        # çŠ¶æ€ç®¡ç†
        self.connection_active = False
        self.last_heartbeat = 0.0
        self.heartbeat_interval = 2.0
        self.sending_audio = 0

    def _generate_wav_header(self) -> bytes:
        """ç”ŸæˆWAVæ–‡ä»¶å¤´"""
        byte_rate = self.sample_rate * self.channels * self.bits_per_sample // 8
        block_align = self.channels * self.bits_per_sample // 8
        return struct.pack(
            '<4sI4s4sIHHIIHH4sI',
            b'RIFF', 36, b'WAVE', b'fmt ', 16, 1, self.channels,
            self.sample_rate, byte_rate, block_align, self.bits_per_sample,
            b'data', 0
        )

    def _generate_silence(self, duration: float) -> bytes:
        """ç”Ÿæˆé™éŸ³æ•°æ®"""
        samples = int(self.sample_rate * duration)
        return bytes(samples * self.channels * (self.bits_per_sample // 8))

    async def _async_create_pipe(self) -> None:
        """åˆ›å»ºå‘½åç®¡é“"""
        while self.running and not self.connection_active:
            try:
                # åˆ›å»ºå‘½åç®¡é“
                self.pipe_handle = win32pipe.CreateNamedPipe(
                    self.pipe_name,
                    win32pipe.PIPE_ACCESS_DUPLEX,
                    win32pipe.PIPE_TYPE_BYTE | win32pipe.PIPE_READMODE_BYTE | win32pipe.PIPE_WAIT,
                    1,  # æœ€å¤§å®ä¾‹æ•°
                    65536, 65536,  # è¾“å…¥è¾“å‡ºç¼“å†²åŒºå¤§å°
                    0,  # é»˜è®¤è¶…æ—¶
                    None  # å®‰å…¨å±æ€§
                )
                
                # å¼‚æ­¥ç­‰å¾…è¿æ¥
                loop = asyncio.get_running_loop()
                await loop.run_in_executor(None, win32pipe.ConnectNamedPipe, self.pipe_handle, None)
                self.connection_active = True
                print("å®¢æˆ·ç«¯å·²è¿æ¥")
                await self._async_write_socket(self.wav_header)
            except pywintypes.error as e:
                if e.winerror == 536:  # ERROR_PIPE_CONNECTED
                    self.connection_active = True
                    print("å®¢æˆ·ç«¯å·²è¿æ¥")
                elif e.winerror == 232:  # å®¢æˆ·ç«¯æ–­å¼€
                    print("å®¢æˆ·ç«¯æ–­å¼€è¿æ¥")
                    self.connection_active = False
                    if self.pipe_handle:
                        win32file.CloseHandle(self.pipe_handle)
                        self.pipe_handle = None
                    await asyncio.sleep(1)
                else:
                    print(f"ç®¡é“é”™è¯¯: {e}")
                    await asyncio.sleep(1)
            except Exception as e:
                print(f"å…¶ä»–é”™è¯¯: {e}")
                await asyncio.sleep(1)

    async def _start_ffmpeg(self) -> None:
        """å¯åŠ¨FFmpegè¿›ç¨‹"""
        with suppress(Exception):
            if self.ffmpeg_process:
                self.ffmpeg_process.terminate()
                await self.ffmpeg_process.wait()

            self.ffmpeg_process = await asyncio.create_subprocess_exec(
                'ffmpeg',
                '-f', 's16le',
                '-ar', str(self.sample_rate),
                '-ac', str(self.channels),
                '-i', self.pipe_name,
                '-c:a', 'aac',
                '-f', 'rtsp',
                '-rtsp_transport', 'tcp',
                'rtsp://localhost:8554/mystream',
                stdout=asyncio.subprocess.DEVNULL,
                stdin=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.PIPE
            )
            asyncio.create_task(self._monitor_ffmpeg_errors())

    async def _monitor_ffmpeg_errors(self) -> None:
        """ç›‘æ§FFmpegé”™è¯¯è¾“å‡º"""
        while self.running and self.ffmpeg_process:
            line = await self.ffmpeg_process.stderr.readline()
            if not line:
                break
            # print(f"[FFmpeg Error] {line.decode().strip()}")

    async def _async_write_socket(self, data: bytes) -> None:
        """å®‰å…¨å†™å…¥ç®¡é“"""
        try:
            if self.connection_active and self.pipe_handle:
                loop = asyncio.get_running_loop()
                await loop.run_in_executor(None, win32file.WriteFile, self.pipe_handle, data)
        except pywintypes.error as e:
            print(f"å†™å…¥é”™è¯¯: {e}")
            self.connection_active = False
            await self._reconnect_pipeline()
        except Exception as e:
            print(f"å…¶ä»–å†™å…¥é”™è¯¯: {e}")
            self.connection_active = False

    async def _reconnect_pipeline(self) -> None:
        """å®Œæ•´é‡è¿æµç¨‹"""
        print("å¯åŠ¨é‡è¿æµç¨‹...")
        self.connection_active = False
        if self.pipe_handle:
            win32file.CloseHandle(self.pipe_handle)
            self.pipe_handle = None
        await asyncio.gather(
            self._async_create_pipe(),
            self._start_ffmpeg()
        )

    async def _heartbeat(self) -> None:
        """å¿ƒè·³ç»´æŒæœºåˆ¶"""
        while self.running:
            if self.connection_active:
                for i in range(10):
                    if self.sending_audio < 0:
                        await self._async_write_socket(self.silence)
                    else:
                        self.sending_audio -= 2
                    await asyncio.sleep(0.2)
            else:
                await asyncio.sleep(0.5)

    def _sync_tts(self, text, tmp_filename):
        eng = pyttsx3.init()
        eng.save_to_file(text, 'temp3.wav')
        eng.runAndWait()
      #  eng.endLoop()

    async def _tts_worker(self, text: str) -> None:
        """å¼‚æ­¥TTSå¤„ç†æ ¸å¿ƒ"""
        await asyncio.get_event_loop().run_in_executor(None, self._sync_tts, text, 'temp3.wav')

        try:
            proc = await asyncio.create_subprocess_exec(
                'ffmpeg',
                '-hide_banner',
                '-loglevel', 'error',
                '-y',
                '-i', 'temp3.wav',
                '-f', 's16le',
                '-acodec', 'pcm_s16le',
                '-ar', str(self.sample_rate),
                '-ac', str(self.channels),
                '-',
                stdout=asyncio.subprocess.PIPE
            )

            sum_bytes = 0
            while chunk := await proc.stdout.read(4096):
                sum_bytes += len(chunk)
                await self._async_write_socket(chunk)
            self.sending_audio = int(sum_bytes * 10 / 48000)
            print(f"å†™å…¥æ•°æ® x0.1s: {self.sending_audio}")

        finally:
            if os.path.exists('temp3.wav'):
                os.remove('temp3.wav')

    async def _input_handler(self) -> None:
        """å¼‚æ­¥è¾“å…¥å¤„ç†"""
        while self.running:
            try:
                text = await ainput("è¯·è¾“å…¥æ–‡æœ¬ï¼ˆè¾“å…¥qé€€å‡ºï¼‰: ")
                if text.lower() == 'q':
                    self.running = False
                    break
                if text.strip():
                    await self._tts_worker(text)
            except Exception as e:
                print(f"è¾“å…¥é”™è¯¯: {str(e)}")

    async def run(self) -> None:
        """ä¸»è¿è¡Œå¾ªç¯"""
        self.running = True
        tasks = [
            asyncio.create_task(self._async_create_pipe()),
            asyncio.create_task(self._start_ffmpeg()),
            asyncio.create_task(self._input_handler()),
            asyncio.create_task(self._heartbeat()),
        ]
        await asyncio.gather(*tasks)

    async def stop(self) -> None:
        """å®‰å…¨å…³é—­"""
        self.running = False
        with suppress(Exception):
            if self.ffmpeg_process:
                self.ffmpeg_process.terminate()
                await self.ffmpeg_process.wait()
            if self.pipe_handle:
                win32pipe.DisconnectNamedPipe(self.pipe_handle)
                win32file.CloseHandle(self.pipe_handle)
            print("æ‰€æœ‰èµ„æºå·²é‡Šæ”¾")

if __name__ == "__main__":
    controller = AsyncTTSController()
    try:
        asyncio.run(controller.run())
    except KeyboardInterrupt:
        asyncio.run(controller.stop())


```

### ç‹¬ç«‹çš„ffmpegå¯åŠ¨å’Œç›‘æ§çš„ç‹¬ç«‹ä»£ç 

éªŒè¯äº†ä¸€ä¸‹rtspæ–­çº¿é‡å»ºè¿ç»“ï¼Œä¹ŸéªŒè¯äº† ä¸Šé¢ çš„main.pyçš„socket serveré€€å‡ºåï¼Œffmpegè‡ªåŠ¨é‡å¯è¿æ¥ã€‚ è¦ä½¿ç”¨è¿™ä¸ªæ›´ç¨³å¥çƒçš„ç¨‹åºï¼Œéœ€è¦

> æ³¨é‡Šmain.py runä¸­çš„asyncio.create\_task( self.\_start\_ffmpeg()),

ä»£ç ä¸ç”¨ä¿®æ”¹,æŠŠç®¡é“åè¿™ä¸ªå¿«, å½»åº•ä¿®æ”¹ä¸º,ffmpegè®¤è¯†çš„windowæ ·å¼,å°±å¯è¿è¡Œ.

> râ€™\.\pipe\tts\_audio\_pipeâ€™

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/b9afd098601a49a0ac40d4169e35355c.png)
  
ffmg,py

```bash
import asyncio
from contextlib import suppress
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class FFmpegManager:
    def __init__(self):
        self.ffmpeg_process = None
        self._retry_count = 0
        self._max_retries = 5
        self._retry_lock = asyncio.Lock()
        self._is_running = False
        self.sample_rate=24000
        self.channels=1
        self.socket_path = "/tmp/tts_audio.sock"

    async def _start_ffmpeg(self) -> None:
        """å¸¦è‡ªåŠ¨é‡è¯•çš„FFmpegå¯åŠ¨å‡½æ•°"""
        async with self._retry_lock:
            await self._safe_terminate()
            
            try:
                socketid = 'unix:' + self.socket_path
                self.ffmpeg_process =await asyncio.create_subprocess_exec(
                'ffmpeg',
                '-f', 's16le',
                '-ar', str(self.sample_rate),
                '-ac', str(self.channels),
                '-i', socketid,  # ä¿®æ”¹è¾“å…¥æºä¸ºå¥—æ¥å­—è·¯å¾„
                '-c:a', 'aac',
                '-f', 'rtsp',
                '-rtsp_transport', 'tcp',
                'rtsp://localhost:8554/mystream',
                stdout=asyncio.subprocess.DEVNULL,
                stdin=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.PIPE
            )
                self._retry_count = 0  # é‡ç½®é‡è¯•è®¡æ•°å™¨
                asyncio.create_task(self._monitor_ffmpeg_errors())
                self._is_running = True
            except Exception as e:
                logging.error(f"FFmpegå¯åŠ¨å¤±è´¥: {str(e)}")
                await self._handle_retry()

    async def _monitor_ffmpeg_errors(self):
        """å¢å¼ºå‹è¿›ç¨‹ç›‘æ§"""
        while self._is_running:
            logging.info("loop  error cathch")
            stderr = await self.ffmpeg_process.stderr.readline()
            if stderr:
                logging.error(f"FFmpegé”™è¯¯è¾“å‡º: {stderr.decode().strip()}")
            
            # æ£€æµ‹è¿›ç¨‹çŠ¶æ€
            return_code = self.ffmpeg_process.returncode
            if return_code is not None:
                logging.warning(f"FFmpegå¼‚å¸¸é€€å‡ºï¼Œè¿”å›ç : {return_code}")
                self._is_running = False
                await self._handle_retry()
                break

    async def _handle_retry(self):
        """æ™ºèƒ½é‡è¯•ç­–ç•¥"""
        if self._retry_count >= self._max_retries:
            logging.critical("è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒé‡å¯")
            return

        # æŒ‡æ•°é€€é¿ç®—æ³•
        delay = min(2 ** self._retry_count, 30)  # æœ€å¤§é—´éš”30ç§’
        self._retry_count += 1
        logging.info(f"å°†åœ¨ {delay} ç§’åå°è¯•ç¬¬ {self._retry_count} æ¬¡é‡å¯")

        await asyncio.sleep(delay)
        await self._start_ffmpeg()

    async def _safe_terminate(self):
        """å®‰å…¨ç»ˆæ­¢ç°æœ‰è¿›ç¨‹"""
        if self.ffmpeg_process:
            with suppress(Exception):
                self.ffmpeg_process.terminate()
                await self.ffmpeg_process.wait()
                self.ffmpeg_process = None
# ä»¥ä¸‹ä¿æŒä¸å˜...
async def main():
    controller=FFmpegManager()
    try:
        await controller._start_ffmpeg()
        logging.info('rung')
        await asyncio.sleep(1160)
    except KeyboardInterrupt:
        logging.info(3)
        asyncio.run(controller._safe_terminate())
if __name__ == "__main__":
     
     asyncio.run(main())

```