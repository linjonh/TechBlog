---
layout: post
title: "Pytorch-张量的scatter_add_方法介绍"
date: 2025-03-10 18:49:37 +0800
description: "torch.Tensor.scatter_add_ 是 PyTorch 中的一个原地操作（in-place operation），用于将一个源张量（src）中的值根据指定的索引（index）累加到目标张量（self）中。它常用于分布式计算、加权聚合以及自定义深度学习层等场景。"
keywords: "Pytorch 张量的scatter_add_方法介绍"
categories: ['未分类']
tags: ['人工智能', 'Pytorch', 'Python']
artid: "146161256"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146161256
    alt: "Pytorch-张量的scatter_add_方法介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146161256
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146161256
cover: https://bing.ee123.net/img/rand?artid=146161256
image: https://bing.ee123.net/img/rand?artid=146161256
img: https://bing.ee123.net/img/rand?artid=146161256
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Pytorch 张量的scatter_add_方法介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <code>
      torch.Tensor.scatter_add_
     </code>
     是 PyTorch 中的一个原地操作（in-place operation），用于将一个源张量（
     <code>
      src
     </code>
     ）中的值根据指定的索引（
     <code>
      index
     </code>
     ）累加到目标张量（
     <code>
      self
     </code>
     ）中。它常用于分布式计算、加权聚合以及自定义深度学习层等场景。
    </p>
    <h4>
     <strong>
      函数签名
     </strong>
    </h4>
    <pre><code class="hljs">Tensor.scatter_add_(dim, index, src) → Tensor</code></pre>
    <h5>
     <strong>
      参数说明
     </strong>
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         dim
        </code>
        (int)
       </strong>
       ：指定沿着哪个维度进行索引和累加。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         index
        </code>
        (LongTensor)
       </strong>
       ：一个整数类型的张量，包含要累加的索引位置。
       <code>
        index
       </code>
       的形状应与
       <code>
        src
       </code>
       相同，除了指定的维度
       <code>
        dim
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         src
        </code>
        (Tensor)
       </strong>
       ：源张量，包含要累加到目标张量的值。
      </p>
     </li>
    </ol>
    <h4>
     <strong>
      功能
     </strong>
    </h4>
    <p>
     <code>
      scatter_add_
     </code>
     会根据
     <code>
      index
     </code>
     中的索引，将
     <code>
      src
     </code>
     中的值累加到目标张量
     <code>
      self
     </code>
     的指定位置。对于每个值，其目标位置由
     <code>
      index
     </code>
     指定，而其他维度的位置由其在
     <code>
      src
     </code>
     中的位置决定。
    </p>
    <h4>
     <strong>
      操作逻辑
     </strong>
    </h4>
    <p>
     对于一个三维张量，
     <code>
      scatter_add_
     </code>
     的更新规则如下：
    </p>
    <pre><code>self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0
self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1
self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2</code></pre>
    <h4>
     <strong>
      示例
     </strong>
    </h4>
    <p>
     以下是一个简单的二维张量示例：
    </p>
    <p>
     Python复制
    </p>
    <pre><code>import torch

# 初始化目标张量
input_tensor = torch.zeros(3, 5)

# 源张量
src = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], dtype=torch.float32)

# 索引张量
index = torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]], dtype=torch.long)

# 沿着维度 0 进行累加
input_tensor.scatter_add_(0, index, src)

print(input_tensor)</code></pre>
    <p>
     输出：
    </p>
    <pre><code>tensor([[ 1.,  2.,  3.,  4.,  5.],
        [ 0.,  7.,  0.,  9.,  0.],
        [ 6.,  0.,  8.,  0., 10.]])</code></pre>
    <h4>
     <strong>
      详细解析
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        目标张量
       </strong>
       ：
       <code>
        input_tensor
       </code>
       是一个形状为
       <code>
        (3, 5)
       </code>
       的零张量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        源张量
       </strong>
       ：
       <code>
        src
       </code>
       是一个形状为
       <code>
        (2, 5)
       </code>
       的张量，包含要累加的值。
      </p>
     </li>
     <li>
      <p>
       <strong>
        索引张量
       </strong>
       ：
       <code>
        index
       </code>
       是一个形状为
       <code>
        (2, 5)
       </code>
       的整数张量，指定
       <code>
        src
       </code>
       中的值应该累加到
       <code>
        input_tensor
       </code>
       的哪些位置。
      </p>
     </li>
     <li>
      <p>
       <strong>
        累加操作
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          scatter_add_
         </code>
         沿着维度
         <code>
          0
         </code>
         进行操作。
        </p>
       </li>
       <li>
        <p>
         <code>
          index
         </code>
         中的每个值指定了
         <code>
          src
         </code>
         中对应值的目标位置。
        </p>
       </li>
       <li>
        <p>
         例如：
        </p>
        <ul>
         <li>
          <p>
           <code>
            index[0, 0] = 0
           </code>
           ，表示
           <code>
            src[0, 0] = 1
           </code>
           应该累加到
           <code>
            input_tensor[0, 0]
           </code>
           。
          </p>
         </li>
         <li>
          <p>
           <code>
            index[1, 1] = 0
           </code>
           ，表示
           <code>
            src[1, 1] = 7
           </code>
           应该累加到
           <code>
            input_tensor[0, 1]
           </code>
           。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <strong>
      注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        形状要求
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          index
         </code>
         和
         <code>
          src
         </code>
         的形状必须与目标张量
         <code>
          self
         </code>
         的形状兼容。
        </p>
       </li>
       <li>
        <p>
         <code>
          index.size(d) &lt;= src.size(d)
         </code>
         对所有维度
         <code>
          d
         </code>
         成立。
        </p>
       </li>
       <li>
        <p>
         <code>
          index.size(d) &lt;= self.size(d)
         </code>
         对所有维度
         <code>
          d != dim
         </code>
         成立。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        非确定性行为
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         在 CUDA 设备上，
         <code>
          scatter_add_
         </code>
         的行为可能是非确定性的。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        反向传播
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         反向传播仅在
         <code>
          src.shape == index.shape
         </code>
         时实现。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        原地操作
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          scatter_add_
         </code>
         是一个原地操作，会直接修改目标张量
         <code>
          self
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     <code>
      torch.Tensor.scatter_add_
     </code>
     是一个强大的工具，用于将源张量中的值根据索引累加到目标张量中。它在处理稀疏更新和聚合操作时非常有用，尤其适合需要在特定位置累加值的场景。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32373339303032332f:61727469636c652f64657461696c732f313436313631323536" class_="artid" style="display:none">
 </p>
</div>


