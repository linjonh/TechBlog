---
layout: post
title: "C蓝桥杯基础篇十一"
date: 2025-03-11 23:53:08 +0800
description: "嗨~小伙伴们，大家好！今天我们来学习C++蓝桥杯基础篇（十一），学习类，结构体，指针相关知识，准备好了吗？咱们开始咯~"
keywords: "c++初级蓝桥杯"
categories: ['C']
tags: ['蓝桥杯', '开发语言', 'C']
artid: "146169038"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146169038
    alt: "C蓝桥杯基础篇十一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146169038
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146169038
cover: https://bing.ee123.net/img/rand?artid=146169038
image: https://bing.ee123.net/img/rand?artid=146169038
img: https://bing.ee123.net/img/rand?artid=146169038
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++蓝桥杯基础篇（十一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     片头
    </h5>
    <p>
     嗨~小伙伴们，大家好！今天我们来学习C++蓝桥杯基础篇（十一），学习类，结构体，指针相关知识，准备好了吗？咱们开始咯~
    </p>
    <p>
     <img alt="" height="643" src="https://i-blog.csdnimg.cn/direct/f90441181761434280ba7e84357571c2.png" width="656"/>
    </p>
    <hr/>
    <h5>
     一、类与结构体
    </h5>
    <p>
     类的定义：在C++中，类的定义是通过关键字"class"来完成的。一个类定义一舿数据的结构和方法。
    </p>
    <pre><code>class Person {

private:				//私有的成员变量
	int age, height;
	double money;
	string books[100];

public:					//公有的成员变量,成员函数
	string name;

	void say() {
		cout &lt;&lt; "I'm " &lt;&lt; name &lt;&lt; endl;
	}

	void set_age(int a) {
		age = a;
	}

	int get_age() {
		return age;
	}

	void set_height(int h) {
		height = h;

	}

	int get_height() {
		return height;
	}

	void add_money(double x) {
		money += x;
	}
};</code></pre>
    <p>
     上面的例子定义了一个名为Person的类，包含了5个数据成员name，age，height，money，books，以及3个成员函数say()用来打招呼，set_age()用来设置年龄，get_age()用来获取年龄，add_money()用来增加零钱的数量。可以通过实例化这个类来创建具体的对象并访问其成员和方法。
    </p>
    <p>
     类中的变量和函数被统一称为类的成员变量。
    </p>
    <p>
     private后面的内容是私有成员变量，在类的外部不能访问；public后面的内容是公有成员变量，在类的外部可以访问。
    </p>
    <p>
     类的使用：
    </p>
    <p>
     <img alt="" height="598" src="https://i-blog.csdnimg.cn/direct/7990d8a149e34503bd6c7c42af900036.png" width="1187"/>
    </p>
    <p>
     正确示例代码如下：
    </p>
    <pre><code>int main() {
	Person c;
	c.name = "小明";    //正确!访问公有变量
	//c.age = 18;		//错误!访问私有变量
	c.set_age(18);		//正确!set_age()是公有成员变量
	c.set_height(185);  //正确!set_height()是公有成员变量

	c.add_money(100);	//设置零钱为100块

	c.say();
	cout &lt;&lt; c.get_age() &lt;&lt; endl;
	cout &lt;&lt; c.get_height() &lt;&lt; endl;

	return 0;
}</code></pre>
    <p>
     <img alt="" height="845" src="https://i-blog.csdnimg.cn/direct/16cca110718e43a1927e2968fa14790d.png" width="1223"/>
    </p>
    <p>
     结构体和类的作用是一样的。不同点在于，类默认是private，结构体默认是public。
    </p>
    <hr/>
    <h5>
     二、构造函数
    </h5>
    <p>
     结构体构造函数是一种特殊的函数，用于创建结构体并对其进行初始化。在C++中，结构体构造函数与类构造函数类似，用于初始化结构体的成员变量，可以通过传入参数来指定初始值。结构体构造函数的名称与结构体本身相同，不需要指定返回类型。
    </p>
    <pre><code>struct Person1 {
	int age, height;
	double money;

	Person1 () {};
	
	Person1(int _age, int _height, double _money) {
		age = _age;
		height = _height;
		money = _money;
	}
};

int main() {
	Person1 p(18,185,100);    //调用有参构造
	cout &lt;&lt; p.age &lt;&lt; " " &lt;&lt; p.height &lt;&lt; " " &lt;&lt; p.money &lt;&lt; endl;

	Person1 a;                //调用无参构造
	cout &lt;&lt; a.age &lt;&lt; " " &lt;&lt; a.height &lt;&lt; " " &lt;&lt; a.money &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     <img alt="" height="943" src="https://i-blog.csdnimg.cn/direct/dccdef7781eb46c294ce6e749a6dcdca.png" width="1277"/>
    </p>
    <p>
     此外，我们还可以使用初始化列表来初始化成员变量
    </p>
    <pre><code>struct Person2 {
	int age, height;
	double money;

	Person2() {};  //无参构造

	Person2(int _age, int _height) :age(_age), height(_height) {}; //使用初始化列表构造

	Person2(int _age, int _height, double _money) :age(_age),height(_height),money(_money) {}
};


int main() {
	Person2 p(18, 185, 100);
	cout &lt;&lt; p.age &lt;&lt; " " &lt;&lt; p.height &lt;&lt; " " &lt;&lt; p.money &lt;&lt; endl;

	Person2 a;
	cout &lt;&lt; a.age &lt;&lt; " " &lt;&lt; a.height &lt;&lt; " " &lt;&lt; a.money &lt;&lt; endl;

	return 0;
}</code></pre>
    <hr/>
    <h5>
     三、指针和引用
    </h5>
    <p>
     指针指向存放变量的值的地址。因此，我们可以通过指针来修改变量的值。
    </p>
    <pre><code>int main() {
	int a = 10;
	int* p = &amp;a;
	*p += 5;
	cout &lt;&lt; *p &lt;&lt; endl;		//15
	cout &lt;&lt; a &lt;&lt; endl;		//15

	return 0;
}</code></pre>
    <p>
     上面代码中，指针p存放的是a的地址，修改*p的值，a的值也会被修改。
    </p>
    <p>
     数组名是一种特殊的指针。指针可以做运算。
    </p>
    <pre><code>int main() {
	char c;
	int a[5] = { 1,2,3,4,5 };

	printf("%p\n", &amp;c);
	printf("%p\n", &amp;a);

	return 0;
}</code></pre>
    <p>
     <img alt="" height="537" src="https://i-blog.csdnimg.cn/direct/bbdc427d091a466b9ba53854c1b88d6d.png" width="864"/>
    </p>
    <p>
     我们将数组a中每个元素的地址都打印一遍：
    </p>
    <pre><code>int main() {
	char c;
	int a[5] = { 1,2,3,4,5 };

	printf("字符c的地址为: %p\n", &amp;c);
	printf("数组名a的地址为: %p\n", &amp;a);

	for (int i = 0; i &lt; 5; i++) {
		printf("a[%d] = %p\n",i, &amp;a[i]);
	}
	cout &lt;&lt; endl;

	return 0;
}</code></pre>
    <p>
     <img alt="" height="749" src="https://i-blog.csdnimg.cn/direct/46cbbff99f9c4affa89b3d2c5f3c7375.png" width="915"/>
    </p>
    <p>
     由此，我们发现，数组名和首元素的地址相同。数组名 = 首元素地址。每个地址之间相差4个字节，因为是int类型的数组，每个int类型的整数占4个字节。
    </p>
    <p>
     我们还可以通过
     <span style="background-color:#fef2f0">
      指针+1来访问下一个元素
     </span>
     ：
    </p>
    <pre><code>int main() {
	char c;
	int a[5] = { 1,2,3,4,5 };

	int* p = a;		//p代表首元素a[0]的地址

	cout &lt;&lt; p &lt;&lt; endl;
	cout &lt;&lt; p + 1 &lt;&lt; endl;

	return 0;
}</code></pre>
    <p>
     <img alt="" height="525" src="https://i-blog.csdnimg.cn/direct/0c0ae9486a5e49868b6283e66cc85037.png" width="1062"/>
    </p>
    <p>
     因此，如果我们想直接访问a[2]的话，也可以写成 *(p+2)
    </p>
    <pre><code>int main() {
	int a[5] = { 1,2,3,4,5 };
	int* p = a;					//p代表首元素a[0]的地址

	cout &lt;&lt; p &lt;&lt; endl;			//a[0]的地址
	cout &lt;&lt; *p &lt;&lt; endl;			//a[0]的值

	cout &lt;&lt; p + 1 &lt;&lt; endl;		//a[1]的地址
	cout &lt;&lt; *(p + 1) &lt;&lt; endl;	//a[1]的值

	cout &lt;&lt; p + 2 &lt;&lt; endl;		//a[2]的地址
	cout &lt;&lt; *(p + 2) &lt;&lt; endl;	//a[2]的值

	return 0;
}</code></pre>
    <p>
     <img alt="" height="729" src="https://i-blog.csdnimg.cn/direct/456ba016ffc8451d9624784e10e8dd08.png" width="1134"/>
    </p>
    <p>
     因此，遍历整个数组的代码如下：
    </p>
    <pre><code>int main() {
	int a[5] = { 1,2,3,4,5 };
	int* p = a;

	//之前的
	for (int i = 0; i &lt; 5; i++) {
		cout &lt;&lt; a[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	//现在的
	for (int i = 0; i &lt; 5; i++) {
		cout &lt;&lt; *(p + i) &lt;&lt; " ";
	}

	return 0;
}</code></pre>
    <p>
     <img alt="" height="818" src="https://i-blog.csdnimg.cn/direct/87c96f743ef64c7f8a884916f427bdf9.png" width="1113"/>
    </p>
    <p>
     同理，输出可以用指针实现，那么输入也可以：
    </p>
    <pre><code>int main() {
	char c;
	int a[5] = { 1,2,3,4,5 };

	scanf("%d", a + 1);		//输入a[1]的值
							//相当于 scanf("%d",&amp;a[1]);
							//因为数组名 = 首元素的地址
							//数组名+1 = 下一个元素的地址

	for (auto e : a) {
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	return 0;
}</code></pre>
    <p>
     <img alt="" height="768" src="https://i-blog.csdnimg.cn/direct/6db16303e9594fa1a08a5889f28b939c.png" width="1171"/>
    </p>
    <p>
     那么，难道指针只能进行加法运算码？不是的~ 可以进行减法运算
    </p>
    <pre><code>int main() {
	int a[5] = { 1,2,3,4,5 };

	int* p = &amp;a[0];
	int* q = &amp;a[2];

	cout &lt;&lt; q - p &lt;&lt; endl; //2

	return 0;
}</code></pre>
    <p>
     <img alt="" height="489" src="https://i-blog.csdnimg.cn/direct/d1dcebdd7d38423eb38a6a171dfce9ad.png" width="938"/>
    </p>
    <p>
     引用和指针类似，相当于给变量起个别名。
    </p>
    <pre><code>int main() {
	int a = 10;
	int&amp; p = a;			 //p是a的别名

	p += 5;

	cout &lt;&lt; p &lt;&lt; endl;   //p的值被修改为15
	cout &lt;&lt; a &lt;&lt; endl;	 //a的值被修改为15

	return 0;
}</code></pre>
    <p>
     <img alt="" height="625" src="https://i-blog.csdnimg.cn/direct/f06283f846284500ae1b00e80cea19cb.png" width="893"/>
    </p>
    <hr/>
    <h5>
     四、链表
    </h5>
    <p>
     单链表在C语言中可以定义为一个结构体，其中包含一个指向下一个节点的指针。
    </p>
    <pre><code>// 定义单链表节点
struct Node {
    int data; // 节点数据
    struct Node *next; // 指向下一个节点的指针
};

// 定义单链表
struct LinkedList {
    struct Node *head; // 头节点指针
};
</code></pre>
    <p>
     在这个定义中，struct Node 代表单链表的节点，包含节点的数据和指向下一节点的指针。struct LinkedList 代表整个单链表，其中包含一个头节点指针 head，指向链表的第一个节点。
    </p>
    <pre><code>struct Node {
	int val;		//节点里面的值
	Node* next;		//指向下一节点的next指针

	Node(int _val):val(_val),next(NULL){}
};


int main() {
	Node* p = new Node(1);   //创建p节点
	Node* q = new Node(2);   //创建q节点
	Node* o = new Node(3);	 //创建o节点

	p-&gt;next = q;			 //p节点的next指针指向q节点
	q-&gt;next = o;			 //q节点的next指针指向o节点

	Node* pcur = p;			 //pcur节点从第1个节点p开始

	//链表的遍历方式
	for (Node* i = pcur; i != NULL; i = i-&gt;next) {
		cout &lt;&lt; i-&gt;val &lt;&lt; " --&gt;" &lt;&lt; " ";
	}
	cout &lt;&lt; "NULL" &lt;&lt; endl;

	return 0;
}</code></pre>
    <p>
     <img alt="" height="860" src="https://i-blog.csdnimg.cn/direct/33c3e22b9dc74a27b50d8606f12db94f.png" width="1113"/>
    </p>
    <p>
     如何在链表中添加节点呢？并且添加在第一个位置，也就是头插
    </p>
    <pre><code>	Node* p = new Node(1);   //创建p节点
	Node* q = new Node(2);   //创建q节点
	Node* o = new Node(3);	 //创建o节点

	p-&gt;next = q;			 //p节点的next指针指向q节点
	q-&gt;next = o;			 //q节点的next指针指向o节点

	Node* head = p;			 //pcur节点从第1个节点p开始

	//添加节点
	Node* u = new Node(4);
	u-&gt;next = head;
	head = u;</code></pre>
    <p>
     <img alt="" height="666" src="https://i-blog.csdnimg.cn/direct/6268387163b049ca8c96b1877169a470.png" width="1110"/>
    </p>
    <p>
     那么如何删除节点呢？删除链表中第2个节点
    </p>
    <pre><code>	Node* p = new Node(1);   //创建p节点
	Node* q = new Node(2);   //创建q节点
	Node* o = new Node(3);	 //创建o节点

	p-&gt;next = q;			 //p节点的next指针指向q节点
	q-&gt;next = o;			 //q节点的next指针指向o节点

	Node* head = p;			 //pcur节点从第1个节点p开始

	//删除节点
	head-&gt;next = head-&gt;next-&gt;next;</code></pre>
    <p>
     <img alt="" height="805" src="https://i-blog.csdnimg.cn/direct/a26e1d7918674dfda6e61dc25bc5f9a0.png" width="1121"/>
    </p>
    <hr/>
    <h5>
     五、习题
    </h5>
    <h6>
     第1题  斐波那契数列
    </h6>
    <p>
     <img alt="" height="753" src="https://i-blog.csdnimg.cn/direct/c0de705e32c24db4ae61185ed3ceacf8.png" width="1646"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       错误代码
      </strong>
     </span>
     如下：
    </p>
    <pre><code>class Solution {
public:
	int Fibonacci(int n) {
		if (n &lt;= 2) return 1;		//错误,这是第0项为1
		return Fibonacci(n - 1) + Fibonacci(n - 2);
	}
};</code></pre>
    <p>
     为啥错了呢？因为，
     <span style="background-color:#fff5e6">
      题目告诉我们从0开始，第0项为0
     </span>
    </p>
    <p>
     因此，
     <span style="color:#fe2c24">
      <strong>
       正确代码
      </strong>
     </span>
     如下：
    </p>
    <pre><code>//f(0)=0,f(1)=1
//f(2)=f(0)+f(1)=1
//f(3)=f(1)+f(2)=2

class Solution {
public:
	int Fibonacci(int n) {
		if (n &lt;= 1) return n;	//当n==0,返回0	
								//当n==1,返回1

		return Fibonacci(n - 1) + Fibonacci(n - 2); //从n==2开始,都满足这个规律
	}
};</code></pre>
    <hr/>
    <h6>
     第2题  替换空格
    </h6>
    <p>
     <img alt="" height="745" src="https://i-blog.csdnimg.cn/direct/00f4a2d030fe4adebc540e337ac7e2a9.png" width="1601"/>
    </p>
    <p>
     代码如下：
    </p>
    <pre><code>class Solution {
public:
	string replaceSpaces(string&amp; str) {
		string res;			  //定义res字符串,用来保存最后结果
		for (auto c : str) {
			if (c == ' ') res += "%20";
			else res += c;
		}
		return res;
	}
};</code></pre>
    <hr/>
    <h6>
     第3题  求1+2+3+...+n
    </h6>
    <p>
     <img alt="" height="653" src="https://i-blog.csdnimg.cn/direct/7dd771389e284f19bf159e5d082e4e63.png" width="1614"/>
    </p>
    <p>
     题目要求我们不能使用乘除法、for、while、if、else、switch、case以及条件判断语句(A?B:C) ，那么我们可以使用
     <span style="background-color:#fef2f0">
      短路与&amp;&amp;和递归
     </span>
     来解决此类问题。
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       <span style="background-color:#fef2f0">
        sum(n) = n+sum(n-1)
       </span>
      </span>
     </strong>
     ，但是要注意终止条件，由于求的是 1+2+3+....+n 的和，
     <span style="background-color:#fef2f0">
      所以需要在n=0的时候跳出递归
     </span>
     。但是题目要求不能使用if，while等分支判断，可以考虑利用&amp;&amp;短路运算来终止判断。
    </p>
    <p>
     代码如下：
    </p>
    <p>
     方法一：
    </p>
    <pre><code>class Solution {
public:
	int getSum(int n) {
		int res = n;
		n &gt; 0 &amp;&amp; (res += getSum(n - 1) + n);  //短路与&amp;&amp;
											  //只要左边的表达式错误,那么右边也不会再执行
											  //利用短路与&amp;&amp;终止递归
		return 0;
	}
};</code></pre>
    <p>
     方法二：我们还可以采用函数递归来解决。在外部定义递归函数，内部调用即可。
    </p>
    <pre><code>//调用函数
class Solution {
public:
	int getSum(int n) {
		return f(n);
	}
	int f(int n) {
		if (n == 0) return 0;
		return f(n - 1) + n;
	}
};</code></pre>
    <hr/>
    <h6 style="background-color:transparent">
     第4题  在O(1)时间删除链表结点
    </h6>
    <p>
     <img alt="" height="774" src="https://i-blog.csdnimg.cn/direct/1220bb3593754056aa696b4b785ebcd7.png" width="1620"/>
    </p>
    <p>
     代码如下:
    </p>
    <pre><code>struct ListNode {
	int val;
	ListNode* next;
	ListNode(int x):val(x),next(NULL){}
};

class Solution {
public:
	void deleteNode(ListNode* node) {
		node-&gt;val = node-&gt;next-&gt;val;	//伪装成下一个点
		node-&gt;next = node-&gt;next-&gt;next;	//将下一个点删掉
	}
};</code></pre>
    <p>
     还有一种更简便的方法：
    </p>
    <pre><code>struct ListNode {
	int val;
	ListNode* next;
	ListNode(int x):val(x),next(NULL){}
};

class Solution {
public:
	void deleteNode(ListNode* node) {
		*(node) = *(node-&gt;next);
	}
};</code></pre>
    <h6>
     第5题  合并两个排序的链表
    </h6>
    <p>
     <img alt="" height="692" src="https://i-blog.csdnimg.cn/direct/8776b087d1c942b0ad18766e264735f1.png" width="1656"/>
    </p>
    <p>
     这道题，我们先来一种易理解的方法：
    </p>
    <pre><code>typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
	if (list1 == NULL)
		//如果list1为空，则返回list2
		return list2;

	if (list2 == NULL)
		//如果list2为空，则返回list1
		return list1;

	ListNode* l1 = list1;	//定义l1变量,指向list1
	ListNode* l2 = list2;	//定义l2变量,指向list2

	ListNode* newHead = NULL;  //定义新链表的头节点
	ListNode* newTail = NULL;  //定义新链表的尾节点

	while (l1 &amp;&amp; l2) {
		if (l1-&gt;val &lt; l2-&gt;val) {
			//l1比l2小
			if (newHead == NULL) {
				//如果链表为空
				newHead = newTail = l1;
			}
			else {
				//链表不为空
				newTail-&gt;next = l1;
				newTail = l1;
			}
			l1 = l1-&gt;next;	//l1指向下一个节点
		}
		else {
			//l2比l1小
			if (newHead == NULL) {
				//如果链表为空
				newHead = newTail = NULL;
			}
			else {
				//链表不为空
				newTail-&gt;next = l2;
				newTail = l2;
			}
			l2 = l2-&gt;next;	//l2指向下一个节点
		}
	}

	if (l1) {
		//l1没有遍历完链表
		newTail-&gt;next = l1;
	}

	if (l2) {
		//l2没有遍历完链表
		newTail-&gt;next = l2;
	}
	return newHead;//返回头节点
}</code></pre>
    <p>
     好啦，这道题我们基本上做完了。但是，看看这代码，有重复冗余的部分，我们如何优化代码呢？
    </p>
    <p>
     <img alt="" height="834" src="https://i-blog.csdnimg.cn/direct/20c9aa74f31f4adfa52bc4d2f88a13ec.png" width="690"/>
    </p>
    <p>
     有啦！我们可以定义一个哨兵节点，这个节点可以不存放数据，让它指向新链表的头节点
    </p>
    <pre><code>	ListNode* node = (ListNode*)malloc(sizeof(ListNode));		//创建一个哨兵节点
	ListNode* newHead = node;									//头节点指向哨兵节点
	ListNode* newTail = node;									//尾节点指向哨兵节点</code></pre>
    <p>
     中间的循环也要进行更改，不用判断链表是否为空了
    </p>
    <pre><code>	while (l1 &amp;&amp; l2) {
		if (l1-&gt;val &lt; l2-&gt;val) {
			//l1比l2小
			newTail-&gt;next = l1;
			newTail = l1;
			l1 = l1-&gt;next;	//l1指向下一个节点
		}
		else {
			//l2比l1小
			newTail-&gt;next = l2;
			newTail = l2;
			l2 = l2-&gt;next;	//l2指向下一个节点
		}
	}</code></pre>
    <p>
     malloc了空间，但这块空间实际上用不了，最后我们需要将哨兵节点释放
    </p>
    <pre><code>	//malloc了空间，但这块空间实际上用不了，最后我们需要将哨兵节点释放
	ListNode* ret = newHead-&gt;next;
	free(newHead);
	return ret;		 //返回头节点的下一个节点</code></pre>
    <p>
     欧克，优化过的代码如下：
    </p>
    <pre><code>typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
	if (list1 == NULL)
		//如果list1为空，则返回list2
		return list2;

	if (list2 == NULL)
		//如果list2为空，则返回list1
		return list1;

	ListNode* l1 = list1;	//定义l1变量,指向list1
	ListNode* l2 = list2;	//定义l2变量,指向list2

	ListNode* node = (ListNode*)malloc(sizeof(ListNode));		//创建一个哨兵节点
	ListNode* newHead = node;									//头节点指向哨兵节点
	ListNode* newTail = node;									//尾节点指向哨兵节点

	while (l1 &amp;&amp; l2) {
		if (l1-&gt;val &lt; l2-&gt;val) {
			//l1比l2小
			newTail-&gt;next = l1;
			newTail = l1;
			l1 = l1-&gt;next;	//l1指向下一个节点
		}
		else {
			//l2比l1小
			newTail-&gt;next = l2;
			newTail = l2;
			l2 = l2-&gt;next;	//l2指向下一个节点
		}
	}

	if (l1) {
		//l1没有遍历完链表
		newTail-&gt;next = l1;
	}

	if (l2) {
		//l2没有遍历完链表
		newTail-&gt;next = l2;
	}

	//malloc了空间，但这块空间实际上用不了，最后我们需要将哨兵节点释放
	ListNode* ret = newHead-&gt;next;
	free(newHead);
	return ret;		 //返回头节点的下一个节点
}</code></pre>
    <hr/>
    <h5>
     片尾
    </h5>
    <p>
     今天我们学习了相关类、结构体、指针相关知识，希望看完这篇文章能对友友们有所帮助！！！
    </p>
    <p>
     求
     <strong>
      点赞收藏加关注！！！
     </strong>
    </p>
    <p>
     <strong>
      谢谢大家！！！
     </strong>
    </p>
    <p>
     <img alt="" height="639" src="https://i-blog.csdnimg.cn/direct/455fd44453c2400a96854b78ebd825b0.png" width="648"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37343333363139312f:61727469636c652f64657461696c732f313436313639303338" class_="artid" style="display:none">
 </p>
</div>


