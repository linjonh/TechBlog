---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35393334343132372f:61727469636c652f64657461696c732f313436323637373831"
layout: post
title: "后端django抛弃-Django-自带用户管理后,能否使用-simple-jwt"
date: 2025-03-14 21:32:44 +0800
description: "如果完全抛弃 Django 用户管理，你可以。Django 的用户管理（如不继承。）来进行 JWT 认证。如果你不使用 Django 默认的。能识别和处理你的自定义用户模型。默认使用 Django 自带的。由于 Django 默认的。"
keywords: "【后端】【django】抛弃 Django 自带用户管理后，能否使用 `simple-jwt`？"
categories: ['Django']
tags: ['数据库', 'Sqlite', 'Django']
artid: "146267781"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146267781
    alt: "后端django抛弃-Django-自带用户管理后,能否使用-simple-jwt"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146267781
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146267781
cover: https://bing.ee123.net/img/rand?artid=146267781
image: https://bing.ee123.net/img/rand?artid=146267781
img: https://bing.ee123.net/img/rand?artid=146267781
---

# 【后端】【django】抛弃 Django 自带用户管理后，能否使用 `simple-jwt`？

### **抛弃 Django 自带用户管理后，能否使用 `simple-jwt` ？**

#### **一、结论**

是的，
**即使抛弃了 Django 自带的用户管理**
（
`AbstractUser`
或
`AbstractBaseUser`
），仍然可以使用
`django-rest-framework-simplejwt`
（简称
`simple-jwt`
）来进行 JWT 认证。但需要进行
**额外配置**
，确保
`simple-jwt`
能识别和处理你的自定义用户模型。

---

#### **二、Django 用户管理的作用**

Django 自带的用户管理提供：

1. **`AbstractUser`
   /
   `AbstractBaseUser`**
   作为默认用户模型。
2. **`django.contrib.auth`
   认证系统**
   ，如
   `authenticate()`
   、
   `login()`
   、
   `logout()`
   。
3. **默认的
   `User`
   模型**
   ，用于管理权限、组等。

如果你
**完全抛弃**
Django 的用户管理（如不继承
`AbstractUser`
），你需要：

* **自定义用户模型**
* **自定义
  `simple-jwt`
  的用户解析逻辑**
* **手动实现
  `authenticate()`
  逻辑**

---

#### **三、如何自定义 JWT 认证**

##### **1. 安装 `djangorestframework-simplejwt`**

```bash
pip install djangorestframework-simplejwt

```

##### **2. 在 `settings.py` 进行基础配置**

```python
INSTALLED_APPS += ["rest_framework_simplejwt"]

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    )
}

```

##### **3. 自定义用户模型**

如果你不使用 Django 默认的
`User`
，可以创建自己的
`CustomUser`
模型：

```python
from django.db import models

class CustomUser(models.Model):
    id = models.AutoField(primary_key=True)
    username = models.CharField(max_length=255, unique=True)
    email = models.EmailField(unique=True)
    password = models.CharField(max_length=255)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return self.username

```

##### **4. 自定义 `get_user_model()`**

由于 Django 默认的
`get_user_model()`
依赖
`AbstractUser`
，如果完全抛弃 Django 用户管理，你可以
**手动指定用户模型**
：

```python
from myapp.models import CustomUser

def get_custom_user(identifier):
    """支持使用用户名或邮箱获取用户"""
    try:
        return CustomUser.objects.get(username=identifier)
    except CustomUser.DoesNotExist:
        try:
            return CustomUser.objects.get(email=identifier)
        except CustomUser.DoesNotExist:
            return None

```

##### **5. 自定义 `JWTAuthentication`**

因为
`simple-jwt`
默认使用 Django 自带的
`User`
，你需要自定义
`JWTAuthentication`
来适配
`CustomUser`
：

```python
from rest_framework_simplejwt.authentication import JWTAuthentication

class CustomJWTAuthentication(JWTAuthentication):
    def get_user(self, validated_token):
        try:
            user_id = validated_token.get("user_id")
            return CustomUser.objects.get(id=user_id)
        except CustomUser.DoesNotExist:
            return None

```

然后在
`settings.py`
替换
`DEFAULT_AUTHENTICATION_CLASSES`
：

```python
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "path.to.CustomJWTAuthentication",
    )
}

```

##### **6. 自定义 Token 生成视图**

由于
`simple-jwt`
默认使用
`User`
进行认证，你需要
**自定义 Token 生成逻辑**
：

```python
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from django.contrib.auth.hashers import check_password

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    def validate(self, attrs):
        username = attrs.get("username")
        password = attrs.get("password")

        user = get_custom_user(username)
        if not user or not check_password(password, user.password):
            raise serializers.ValidationError("用户名或密码错误")

        data = super().validate(attrs)
        return data

class CustomTokenObtainPairView(TokenObtainPairView):
    serializer_class = CustomTokenObtainPairSerializer

```

然后在
`urls.py`
里注册：

```python
from django.urls import path
from path.to.views import CustomTokenObtainPairView
from rest_framework_simplejwt.views import TokenRefreshView

urlpatterns = [
    path("api/token/", CustomTokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("api/token/refresh/", TokenRefreshView.as_view(), name="token_refresh"),
]

```

---

#### **四、总结**

| 方案 | 需要修改 |
| --- | --- |
| 直接使用 Django `User` | **无需修改，默认支持 `simple-jwt`** |
| 继承 `AbstractUser` | **支持 `simple-jwt` ，只需 `settings.AUTH_USER_MODEL`** |
| **完全自定义用户模型** | **需要手动适配 `JWTAuthentication` ，重写 `TokenObtainPairSerializer`** |

##### **推荐方案**

* **如果只是调整
  `User`
  字段，建议继承
  `AbstractUser`
  ，这样
  `simple-jwt`
  仍然可用**
* **如果完全自定义用户模型，必须手动适配
  `simple-jwt`**

总之，
**抛弃 Django 的
`User`
仍然可以使用
`simple-jwt`
，但需要额外开发
`JWTAuthentication`
逻辑**
。🚀