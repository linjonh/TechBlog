---
layout: post
title: "Kubernetes11-Java访问apiserver"
date: 2024-12-17 19:45:00 +0800
description: "想实现Java访问k8s  apiserver接口服务，目前主要Java client 有基于Jer"
keywords: "apiserver burst jdk"
categories: ['云计算', 'Kubernetes']
tags: ['无标签']
artid: "84788467"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=84788467
    alt: "Kubernetes11-Java访问apiserver"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=84788467
featuredImagePreview: https://bing.ee123.net/img/rand?artid=84788467
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Kubernetes11--Java访问apiserver
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     想实现Java访问k8s  apiserver接口服务，目前主要Java client 有基于Jersey以及基于Fabric8
    </p>
    <p>
     <a href="https://jersey.github.io/" rel="nofollow">
      https://jersey.github.io/
     </a>
    </p>
    <p>
     <a href="https://github.com/fabric8io/kubernetes-client">
      https://github.com/fabric8io/kubernetes-client
     </a>
    </p>
    <p>
     Jersey需要自己实现各种接口调用，Fabric8已经实现主要的api调用，研究了一下Fabric8，决定还是自己模拟https请求来调用k8s服务接口，现成的框架尽管便于使用，但是有时候不便于扩展，还有k8s更新太快，现有框架对于功能可能不支持，因此这里使用org.apache.http包来模拟https请求，访问k8s服务。
    </p>
    <p>
     k8s  apiserver服务端口
     <a href="https://10.3.10.144:6443" rel="nofollow">
      https://10.3.10.144:6443
     </a>
     内网IP  这里验证方式使用Bootstrap Token请求响应头方式，已经在上一篇给出Service Account的配置以及访问方式。
    </p>
    <p>
     由于使用https通信，首先下载apiserver的证书到jdk中证书信息中。
    </p>
    <h4>
     1.apiserver证书下载
    </h4>
    <p>
     点击证书信息  复制到文件，下载到本地   命名为k8s.cer
    </p>
    <p>
     <img alt="" class="has" height="30" src="https://i-blog.csdnimg.cn/blog_migrate/b73615e0cb4123161a7583a36274808c.png" width="283"/>
    </p>
    <p>
     <img alt="" class="has" height="448" src="https://i-blog.csdnimg.cn/blog_migrate/545ccbc3ae4df4f010d7a4d5a5739eb5.png" width="322"/>
    </p>
    <h4>
     2.将k8s证书导入到jdk中
    </h4>
    <p>
     cd $JAVA_HOME/jre/lib/security
    </p>
    <p>
     keytool -import -file C:\Users\chen\Desktop\k8s.cer -keystore cacerts -alias k8s -trustcacerts
    </p>
    <p>
     输入口令   changeit
    </p>
    <p>
     <img alt="" class="has" height="103" src="https://i-blog.csdnimg.cn/blog_migrate/b49e86acef6674d7ab219fa764f1d215.png" width="1172"/>
    </p>
    <p>
     查看口令：
    </p>
    <p>
     <img alt="" class="has" height="68" src="https://i-blog.csdnimg.cn/blog_migrate/93713c6ee4bff2d2b5da6114d047ed8a.png" width="889"/>
    </p>
    <p>
     具体密钥库的管理命令可以查看keytool指令
    </p>
    <p>
     首先保证当前操作者用户对于jdk所在的文件有读写权限，win10权限验证很严格
    </p>
    <p>
     <img alt="" class="has" height="431" src="https://i-blog.csdnimg.cn/blog_migrate/81eb430f47df82a91861d2d36e252537.png" width="293"/>
    </p>
    <p>
     <img alt="" class="has" height="22" src="https://i-blog.csdnimg.cn/blog_migrate/23b3a5ad594fe83b0abb1f8a5284c4ad.png" width="942"/>
    </p>
    <p>
     尽量到jdk中secure目录下进行操作，keystore路径中不能有空格，否则：
    </p>
    <p>
     <img alt="" class="has" height="28" src="https://i-blog.csdnimg.cn/blog_migrate/06009380444338020fa9267181fb73d2.png" width="973"/>
    </p>
    <h4>
     3.使用httpclient访问
    </h4>
    <p>
     之前访问利用curl来完成：
    </p>
    <p>
     <span style="color:#000000;">
      curl -k https://192.168.1.15:6443/api/v1/services --header "Authorization: Bearer $token”
     </span>
    </p>
    <p>
     <span style="color:#000000;">
      现在使用httpclient来模拟上述请求
     </span>
    </p>
    <p>
     构建sslclient,信任所有证书：
    </p>
    <pre class="has"><code>private static CloseableHttpClient createSSLClientDefault() {
        SSLContext sslContext;
        try {
            sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {
                //信任所有
                @Override
                public boolean isTrusted(X509Certificate[] xcs, String string){
                    return true;
                }
            }).build();
            SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext, SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);            
            return HttpClients.custom().setSSLSocketFactory(sslsf).build();
        } catch (KeyStoreException ex) {
            Logger.getLogger(HttpUtils.class.getName()).log(Level.SEVERE, null, ex);
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(HttpUtils.class.getName()).log(Level.SEVERE, null, ex);
        } catch (KeyManagementException ex) {
            Logger.getLogger(HttpUtils.class.getName()).log(Level.SEVERE, null, ex);
        }
        return HttpClients.createDefault();
    }</code></pre>
    <p>
     构建http  get请求方法，来执行get请求：
    </p>
    <pre class="has"><code>public static String get(String url, Map&lt;String, String&gt; param,
            Map&lt;String, String&gt; headers) {
        HttpClient httpClient = getClient();
        // HttpClient httpClient = new DefaultHttpClient();
        HttpGet get = null;
        get = new HttpGet(url);
        appendHeaders(get, headers);
        appendParams(get, param);     
        try {
            HttpResponse httpResponse = httpClient.execute(get);
            if (httpResponse.getStatusLine().getStatusCode() == 200) {
                HttpEntity entity = httpResponse.getEntity();
                return EntityUtils.toString(entity);
            } else {
                httpResponse.getEntity().getContent().close();
                //System.out.println("return status code:" + httpResponse.getStatusLine().getStatusCode());
            }
        } catch (ClientProtocolException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        long e = System.currentTimeMillis();
        return null;
    }

    private static HttpClient getClient() {
//        HttpClient hc = clients.get();
//        if (hc == null) {
//            hc = ThreadSafeHttpclientGetter.getNewInstance(1000, 5000, 40000);
//            clients.set(hc);
//        }
//        return hc;
    	return createSSLClientDefault();
    }</code></pre>
    <p>
     构建main方法进行初步测试，
    </p>
    <pre class="has"><code>public static void main( String[] args ){
    	String url = "https://10.3.10.144:6443/api/v1/services";
    	Map&lt;String, String&gt; param = new HashMap&lt;&gt;();
    	Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
    	headers.put("Authorization", ConfigUtils.getBootstrapTokenSecret());
        String result = HttpUtils.get(url, param, headers);
    	System.out.println(result);
    }</code></pre>
    <p>
     在请求头中添加Authorization中这一项，内容是Bootstrap_Token_Secret,之前生成的Service Account  Secret
    </p>
    <p>
     执行结果：返回所有的Services的列表
    </p>
    <p>
     <img alt="" class="has" height="463" src="https://i-blog.csdnimg.cn/blog_migrate/0de6019ed2258288cef6ab685d2d3eb4.png" width="482"/>
    </p>
    <p>
     参考地址：
    </p>
    <p>
     请求头地址：
     <a href="http://tools.jb51.net/table/http_header" rel="nofollow">
      http://tools.jb51.net/table/http_header
     </a>
    </p>
    <p>
     github:
     <a href="https://github.com/chen1234567/k8s-java">
      https://github.com/chen1234567/k8s-java
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f75303134313036363434:2f61727469636c652f64657461696c732f3834373838343637" class_="artid" style="display:none">
 </p>
</div>


