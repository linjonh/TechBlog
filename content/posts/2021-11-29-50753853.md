---
layout: post
title: "iOS9-by-Tutorials-学习笔记二App-Search"
date: 2021-11-29 09:28:52 +0800
description: "iOS9-by-Tutorials-学习笔记二：App-Search  本文版权归作者所有，如需转载"
keywords: "app-search"
categories: ['Swift']
tags: ['Ios']
artid: "50753853"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=50753853
    alt: "iOS9-by-Tutorials-学习笔记二App-Search"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=50753853
featuredImagePreview: https://bing.ee123.net/img/rand?artid=50753853
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     iOS9-by-Tutorials-学习笔记二：App-Search
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3 id="ios9-by-tutorials-学习笔记二app-search">
     iOS9-by-Tutorials-学习笔记二：App-Search
    </h3>
    <blockquote>
     <p>
      本文版权归作者所有，如需转载请联系孟祥月
      <br/>
      CSDN博客：
      <a href="http://blog.csdn.net/mengxiangyue">
       http://blog.csdn.net/mengxiangyue
      </a>
      <br/>
      独立博客：
      <a href="http://mengxiangyue.com" rel="nofollow">
       http://mengxiangyue.com
      </a>
     </p>
     <p>
      本文为自己读书的一个总结，可能与原书有一定出入
     </p>
    </blockquote>
    <p>
     iOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：
     <br/>
     * NSUserActivity
     <br/>
     * Core Spotlight
     <br/>
     * Web markup
    </p>
    <p>
     下面简单的说一下我对于这三个API的理解：
     <br/>
     1. NSUserActivity:
     <br/>
     NSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。
     <br/>
     2. Core Spotlight:
     <br/>
     这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。
     <br/>
     3. Web markup:
     <br/>
     Web Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。
    </p>
    <h4 id="getting-started">
     Getting started
    </h4>
    <p>
     下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/f53bb063d4844389f8dfef1fbbd71b3d.png" title="">
     </img>
    </p>
    <p>
     下面是这个工程的截图：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/03892eb7d052223171323346ac9dbec8.png" title="">
     </img>
    </p>
    <p>
     下面是图中标注的几个关键类的解释：
     <br/>
     1. AppDelegate
     <br/>
     点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理
     <br/>
     2. EmployeeViewController
     <br/>
     人员的详细界面，这个里面主要设置NSUserActivity
     <br/>
     3. EmployeeService
     <br/>
     这个主要是写CoreSpotlight中index相关的东西
     <br/>
     4. EmployeeSearch
     <br/>
     主要是扩展了Employee类，添加了与搜索相关的属性
     <br/>
     另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。
    </p>
    <p>
     在Iphone的Setting/Colleagues/Indexing中有如下三个选项：
     <br/>
     * Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容
     <br/>
     * ViewedRecords 只有打开过的才能够被搜索到
     <br/>
     * AllRecords 所有的员工信息都能够被搜索到
    </p>
    <h5 id="搜索我们已经打开过的内容">
     搜索我们已经打开过的内容
    </h5>
    <p>
     使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：
     <br/>
     1. 创建NSUserActivity的一个实例，设置相关的属性
     <br/>
     2. 赋值给UIViewController的userActivity属性
    </p>
    <p>
     下面我们在EmployeeSearch中添加如下代码：
    </p>
    <blockquote>
     <p>
      如果没有该文件，需要手动创建一个，然后target选择EmployeeKit
     </p>
    </blockquote>
    <pre class="prettyprint"><code class="language-swift hljs cs">import Foundation
import CoreSpotlight

extension Employee {
  <span class="hljs-comment">// 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> domainIdentifier = <span class="hljs-string">"com.mengxiangyue.colleagues.employee"</span>
  <span class="hljs-comment">// 字典 在处理点击的时候，可以根据该字典获取我们想要的数据</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> userActivityUserInfo: [NSObject: AnyObject] {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">"id"</span>: objectId]
  }

  <span class="hljs-comment">// 给Employee添加userActivity属性，主要是方便我们获取userActivity</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> userActivity: NSUserActivity {
    <span class="hljs-keyword">let</span> activity = NSUserActivity(activityType: Employee.domainIdentifier)
    activity.title = name  <span class="hljs-comment">// 显示的名字</span>
    activity.userInfo = userActivityUserInfo  <span class="hljs-comment">// 与该Activity相关的数据</span>
    activity.keywords = [email, department]  <span class="hljs-comment">// 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索</span>
    <span class="hljs-keyword">return</span> activity
  }
}  </code></pre>
    <p>
     这里扩展了Employee，然后添加了几个属性，属性的意义见注释。
     <br/>
     这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。
    </p>
    <p>
     下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs avrasm">let activity = employee<span class="hljs-preprocessor">.userActivity</span>
switch Setting<span class="hljs-preprocessor">.searchIndexingPreference</span> {
case <span class="hljs-preprocessor">.Disabled</span>:
  activity<span class="hljs-preprocessor">.eligibleForSearch</span> = false
case <span class="hljs-preprocessor">.ViewedRecords</span>:
  activity<span class="hljs-preprocessor">.eligibleForSearch</span> = true
  // relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复
  activity<span class="hljs-preprocessor">.contentAttributeSet</span>?<span class="hljs-preprocessor">.relatedUniqueIdentifier</span> = nil
case <span class="hljs-preprocessor">.AllRecords</span>:
  activity<span class="hljs-preprocessor">.eligibleForSearch</span> = true
}

userActivity = activity</code></pre>
    <p>
     下面在该类中添加如下的方法，用于在合适的时机更新Activity：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs cs"><span class="hljs-comment">// 更新NSUserActivity关联的信息</span>
  <span class="hljs-keyword">override</span> func updateUserActivityState(activity: NSUserActivity) {
    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)
  }</code></pre>
    <p>
     下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/683b170dd0252672f8ee544d988b357e.png" title="">
     </img>
    </p>
    <p>
     看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b1a23bcf8c596a6dea518c6e9cfc6d55.png" title="">
     </img>
    </p>
    <p>
     下面我们在EmployeeSearch.swift添加如下属性：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> attributeSet: CSSearchableItemAttributeSet {
  <span class="hljs-keyword">let</span> attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeContact <span class="hljs-keyword">as</span> String)
  attributeSet.title = name  <span class="hljs-comment">// 不太清楚是干啥的</span>
  attributeSet.contentDescription = <span class="hljs-string">"\(department), \(title)\n\(phone)"</span>
  attributeSet.thumbnailData = UIImageJPEGRepresentation(loadPicture(), <span class="hljs-number">0.9</span>)
  attributeSet.supportsPhoneCall = <span class="hljs-keyword">true</span>
  attributeSet.phoneNumbers = [phone]
  attributeSet.emailAddresses = [email]
  attributeSet.keywords = skills
  attributeSet.relatedUniqueIdentifier = objectId  

  <span class="hljs-keyword">return</span> attributeSet
}</code></pre>
    <p>
     然后将给userActivity添加如下属性：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> userActivity: NSUserActivity {
  <span class="hljs-keyword">let</span> activity = NSUserActivity(activityType: Employee.domainIdentifier)
  activity.title = name
  activity.userInfo = userActivityUserInfo
  activity.keywords = [email, department]
  activity.contentAttributeSet = attributeSet   <span class="hljs-comment">// 新添加的这一行</span>
  <span class="hljs-keyword">return</span> activity
}</code></pre>
    <p>
     然后运行程序，搜索结果如下：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/9769f3a7f654cf7551e28d1ab096a659.png" title="">
     </img>
    </p>
    <p>
     但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs cs">func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -&gt; Void) -&gt; Bool {
  <span class="hljs-keyword">let</span> objectId: String
  <span class="hljs-comment">// 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId</span>
  <span class="hljs-keyword">if</span> userActivity.activityType == Employee.domainIdentifier, <span class="hljs-keyword">let</span> activityObjectId = userActivity.userInfo?[<span class="hljs-string">"id"</span>] <span class="hljs-keyword">as</span>? String {
    objectId = activityObjectId
  }
  <span class="hljs-comment">// 获取对应Employee实例 然后跳转到对应的界面</span>
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> nav = window?.rootViewController <span class="hljs-keyword">as</span>? UINavigationController, listVC = nav.viewControllers.first <span class="hljs-keyword">as</span>? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {
    nav.popToRootViewControllerAnimated(<span class="hljs-keyword">false</span>)
    <span class="hljs-keyword">let</span> employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(<span class="hljs-string">"EmployeeView"</span>) <span class="hljs-keyword">as</span>! EmployeeViewController
    employeeViewController.employee = employee
    nav.pushViewController(employeeViewController, animated: <span class="hljs-keyword">false</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
}   </code></pre>
    <p>
     这时候我们再点击搜索结果就能够跳转到对应的详细界面了。
    </p>
    <h4 id="corespotlight">
     CoreSpotlight
    </h4>
    <p>
     下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs fix"><span class="hljs-attribute">// 在前面的代码中已经设置过了
attributeSet.relatedUniqueIdentifier </span>=<span class="hljs-string"> objectId</span></code></pre>
    <p>
     这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）
    </p>
    <p>
     然后在EmployeeSearch.swift添加如下的代码：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs cs"><span class="hljs-comment">// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用</span>
<span class="hljs-keyword">var</span> searchableItem: CSSearchableItem {
  <span class="hljs-keyword">let</span> item = CSSearchableItem(uniqueIdentifier: objectId, domainIdentifier: Employee.domainIdentifier, attributeSet: attributeSet)
  <span class="hljs-keyword">return</span> item
}</code></pre>
    <p>
     然后在EmployeeService.swift添加如下代码：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs coffeescript"><span class="hljs-reserved">import</span> CoreSpotlight

..............&lt;省略一部分代码&gt;

public func indexAllEmployees() {
  <span class="hljs-reserved">let</span> employees = fetchEmployees()
  <span class="hljs-reserved">let</span> searchableItems = employees.map{ $<span class="hljs-number">0.</span>searchableItem }
  <span class="hljs-regexp">//</span> 将我们需要被索引的item放入到defaultSearchableIndex中
  CSSearchableIndex.defaultSearchableIndex<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">indexSearchableItems</span><span class="hljs-params">(searchableItems)</span> { <span class="hljs-params">(error)</span> -&gt;</span> Void <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">if</span> <span class="hljs-reserved">let</span> error = error {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"Error indexing employees: \(error)"</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"Employees indexed."</span>)
    }
  }
}</code></pre>
    <p>
     然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：
     <br/>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b7f1c043c4e2f1bc089eee669d6f3edf.png" title=""/>
    </p>
    <p>
     但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs cs">func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -&gt; Void) -&gt; Bool {
    <span class="hljs-keyword">let</span> objectId: String
    <span class="hljs-keyword">if</span> userActivity.activityType == Employee.domainIdentifier, <span class="hljs-keyword">let</span> activityObjectId = userActivity.userInfo?[<span class="hljs-string">"id"</span>] <span class="hljs-keyword">as</span>? String {
      objectId = activityObjectId
    }
    <span class="hljs-comment">// 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   </span>
    <span class="hljs-comment">// CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> userActivity.activityType == CSSearchableItemActionType, <span class="hljs-keyword">let</span> activityObjectId = userActivity.userInfo?[CSSearchableItemActivityIdentifier] <span class="hljs-keyword">as</span>? String {
      objectId = activityObjectId
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> nav = window?.rootViewController <span class="hljs-keyword">as</span>? UINavigationController, listVC = nav.viewControllers.first <span class="hljs-keyword">as</span>? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {
      nav.popToRootViewControllerAnimated(<span class="hljs-keyword">false</span>)
      <span class="hljs-keyword">let</span> employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(<span class="hljs-string">"EmployeeView"</span>) <span class="hljs-keyword">as</span>! EmployeeViewController
      employeeViewController.employee = employee
      nav.pushViewController(employeeViewController, animated: <span class="hljs-keyword">false</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
  }</code></pre>
    <p>
     这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。
    </p>
    <h4 id="删除item">
     删除Item
    </h4>
    <p>
     最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：
    </p>
    <pre class="prettyprint"><code class="language-swift hljs coffeescript">public func destroyEmployeeIndexing() {
  CSSearchableIndex.defaultSearchableIndex<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">deleteAllSearchableItemsWithCompletionHandler</span> { <span class="hljs-params">(error)</span> -&gt;</span> Void <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">if</span> <span class="hljs-reserved">let</span> error = error {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"Error deleting searching employee items: \(error)"</span>)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"Employees indexing deleted."</span>)
    }
  }
}</code></pre>
    <p>
     这个方法会在APP启动并且Indxing设置为Disabled的时候调用。
    </p>
    <p>
     另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:
     <a href="http://blog.csdn.net/mengxiangyue/article/details/46575977">
      CoreSpotlight.framework注释翻译
     </a>
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d656e677869616e67797565:2f61727469636c652f64657461696c732f3530373533383533" class_="artid" style="display:none">
 </p>
</div>


