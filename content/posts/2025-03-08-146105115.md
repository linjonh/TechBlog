---
layout: post
title: "linux-ptrace-图文详解一基础介绍"
date: 2025-03-08 14:09:02 +0800
description: "ptrace 是 linux内核 提供的一个系统调用，并非一个标准的posix接口，ptrace 主要用于进程跟踪和调试。它运行一个用户态进程（通常称为跟踪器, Tracer）控制和监视另一个进程（称为被调试进程, Tracee）的执行。ptrace是许多调试跟踪工具（如：GDB、strace 等）的 “基座”，其函数原型如下：用于标识一个需要执行的操作；标识目标线程ID一个内存地址和附加信息，其语义因选择的操作而不同；"
keywords: "linux ptrace 图文详解（一）基础介绍"
categories: ['未分类']
tags: ['服务器', 'Linux', 'Arm']
artid: "146105115"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146105115
    alt: "linux-ptrace-图文详解一基础介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146105115
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146105115
cover: https://bing.ee123.net/img/rand?artid=146105115
image: https://bing.ee123.net/img/rand?artid=146105115
img: https://bing.ee123.net/img/rand?artid=146105115
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     linux ptrace 图文详解（一）基础介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
     <span style="background-color:#fefcd8">
      （代码：
      <a href="https://so.csdn.net/so/search?q=linux&amp;spm=1001.2101.3001.7020" title="linux">
       linux
      </a>
      6.3.1，架构：arm64）
     </span>
    </p>
    <p>
     <strong>
      One look is worth a thousand words.  —— Tess Flanders
     </strong>
    </p>
    <p>
    </p>
    <h2 id="%E5%BC%95%E8%A8%80" name="%E5%BC%95%E8%A8%80">
     引言
    </h2>
    <p>
     在现代操作系统中，对于开发者来说，能够深入理解和控制进程的行为是解决复杂问题的关键。Linux提供了多种机制来实现这一目标，而 ptrace 系统调用无疑是其中最为强大和灵活的工具之一。尽管 ptrace 的功能强大，它的使用和实现原理却相对复杂，需要对操作系统内核机制有深入的理解。许多开发者在使用 ptrace 时，往往只停留在表面，而对于其底层实现知之甚少。
    </p>
    <p>
     为了帮助开发者更好理解和应用ptrace，笔者将推出一系列文章，深入探讨 ptrace 的各个功能及其详细实现原理。本系列文章将从基础概念入手，逐步深入到每个功能的具体实现，包括：
     <span style="background-color:#fefcd8">
      进程控制、寄存器操作、内存读写、系统调用跟踪、断点设置、单步调试等
     </span>
     。
    </p>
    <p>
     在本系列的第一篇文章中，笔者将对 ptrace 进行基本介绍，包括其定义、功能、应用场景等。通过这篇文章，读者将对 ptrace 有一个全面的了解，为后续深入学习ptrace实现原理打下坚实的基础。
    </p>
    <p>
     让我们一起踏上探索 ptrace 的旅程，解锁其强大功能。
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81ptrace%20%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D" name="%E4%B8%80%E3%80%81ptrace%20%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D">
     一、ptrace 基础介绍
    </h2>
    <p>
     ptrace 是 linux内核 提供的一个系统调用，并非一个标准的posix接口，ptrace 主要用于进程跟踪和调试。它运行一个用户态进程（通常称为跟踪器, Tracer）控制和监视另一个进程（称为被调试进程, Tracee）的执行。ptrace是许多调试跟踪工具（如：GDB、strace 等）的 “基座”，其函数原型如下：
    </p>
    <p class="img-center">
     <img alt="" height="35" src="https://i-blog.csdnimg.cn/direct/824c3e1f9b604569ba5f323a0c955ac5.png" width="632"/>
    </p>
    <p>
     <strong>
      参数：
     </strong>
    </p>
    <p>
     <strong>
      request：
     </strong>
     用于标识一个需要执行的操作；
    </p>
    <p>
     <strong>
      pid：
     </strong>
     标识目标线程ID
    </p>
    <p>
     <strong>
      addr、data：
     </strong>
     一个内存地址和附加信息，其语义因选择的操作而不同；
    </p>
    <p>
     这里详细介绍下ptrace系统调用中的参数request，通过该参数，ptrace为用户态提供了丰富的进程调试跟踪功能。
    </p>
    <p>
     <strong>
      1）PTRACE_TRACEME
     </strong>
    </p>
    <p>
     允许当前进程被其父进程跟踪，通常用于GDB加载运行一个被调试程序；
    </p>
    <p>
     <strong>
      2）PTRACE_PEEKTEXT
     </strong>
    </p>
    <p>
     读取目标进程的代码段内容，通常用于GDB查看目标进程的指令代码；
    </p>
    <p>
     <strong>
      3）PTRACE_PEEKDATA
     </strong>
    </p>
    <p>
     读取目标进程的数据段内容，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB查看目标进程的全局变量、堆栈内容等
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      4）PTRACE_PEEKUSER
     </strong>
    </p>
    <p>
     读取目标进程的用户态寄存器和状态信息，通常用于GDB查看目标进程的PC、SP等；
    </p>
    <p>
     <strong>
      5）PTRACE_POKETEXT
     </strong>
    </p>
    <p>
     修改目标进程的代码段内容，用于GDB修改目标进程的指令代码，例如
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       设置
       <strong>
        软断点
       </strong>
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      6）PTRACE_POKEDATA
     </strong>
    </p>
    <p>
     修改目标进程的数据段内容，用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB修改目标进程的全局变量、堆栈内容等数据
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      7）PTRACE_POKEUSER
     </strong>
    </p>
    <p>
     修改目标进程的用户态寄存器和状态信息；
    </p>
    <p>
     <strong>
      8）PTRACE_CONT
     </strong>
    </p>
    <p>
     唤醒目标进程继续执行，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB的continue功能
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      9）PTRACE_KILL
     </strong>
    </p>
    <p>
     终止目标进程，用于GDB杀死被调试进程；
    </p>
    <p>
     <strong>
      10）PTRACE_SINGLESTEP
     </strong>
    </p>
    <p>
     单步执行目标进程，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB的
       <strong>
        step单步调试
       </strong>
       目标进程的功能
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      11）PTRACE_GETREGS
     </strong>
    </p>
    <p>
     获取目标进程的寄存器状态，如当前的程序计数器（PC）、栈指针（SP）等；
    </p>
    <p>
     <strong>
      12）PTRACE_SETREGS
     </strong>
    </p>
    <p>
     设置目标进程的寄存器状态；
    </p>
    <p>
     <strong>
      13）PTRACE_ATTACH
     </strong>
    </p>
    <p>
     用于attach到一个正在运行的目标进程，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB attach调试功能
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      14）PTRACE_DETACH
     </strong>
    </p>
    <p>
     从一个目标进程上detach，通常用于GDB解除对目标进程的调试功能；
    </p>
    <p>
     <strong>
      15）PTRACE_SYSCALL
     </strong>
    </p>
    <p>
     在目标进程的系统调用入口处、返回处暂停，通常
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       用于strace工具捕获目标进程的系统调用
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      16）PTRACE_SETOPTIONS
     </strong>
    </p>
    <p>
     设置目标进程的跟踪选项，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB设置是否对目标进程的一些操作（如：fork、pthread_create、exec、所有系统调用等）进行跟踪
      </span>
     </span>
     ；
    </p>
    <p>
     <strong>
      17）PTRACE_GETSIGINFO
     </strong>
    </p>
    <p>
     获取目标进程的信号信息，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB获取目标进程的异常地址、exit_code、pending信号
      </span>
     </span>
     等信息；
    </p>
    <p>
     <strong>
      18）PTRACE_GETEVENTMSG
     </strong>
    </p>
    <p>
     获取目标进程与特定 ptrace事件 相关联的消息，例如
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB获取目标进程fork创建的子进程/子线程pid信息
      </span>
     </span>
     、位于系统调用入口处/出口处 等信息；
    </p>
    <p>
     <strong>
      19）PTRACE_GETREGSET
     </strong>
    </p>
    <p>
     获取目标进程的寄存器集合；
    </p>
    <p>
     <strong>
      20）PTRACE_SETREGSET
     </strong>
    </p>
    <p>
     设置目标进程的寄存器集合，通常用于
     <span style="color:#fe2c24">
      <span style="background-color:#fefcd8">
       GDB设置目标进程的
       <strong>
        硬断点、观察点
       </strong>
      </span>
     </span>
     ；
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81ptrace%20%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" name="%E4%BA%8C%E3%80%81ptrace%20%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">
     二、ptrace 常见应用场景
    </h2>
    <h4 id="1%E3%80%81gdb%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95" name="1%E3%80%81gdb%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95">
     1、gdb进程调试
    </h4>
    <p>
     gdb对目标进程进行跟踪调试，其底下依赖的主要是linux内核中的 ptrace功能、以及 signal + wait 这两个用于同步的系统调用。通过ptrace接口，gdb可以对被调试进程进行一系列的调试跟踪操作。
    </p>
    <p>
    </p>
    <h4 id="2%E3%80%81strace%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%B7%9F%E8%B8%AA" name="2%E3%80%81strace%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%B7%9F%E8%B8%AA">
     2、strace 系统调用跟踪
    </h4>
    <p>
     strace是一个用户态的工具，其主要用途是跟踪目标进程执行期间的所有系统调用操作，获取对应系统调用的参数、返回值等信息。strace底层依赖的就是ptrace(PTRACE_SYSCALL)这一功能，做到对目标进程的所有系统调用操作进行监控。
    </p>
    <p>
    </p>
    <h4 id="3%E3%80%81%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5" name="3%E3%80%81%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5">
     3、动态注入
    </h4>
    <p>
     通过ptrace系统调用，可以用于向目标进程注入代码或数据，在某些情况下用于功能扩展或漏洞利用。
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%89%E3%80%81gdb%20%E4%B8%8E%20ptrace" name="%E4%B8%89%E3%80%81gdb%20%E4%B8%8E%20ptrace">
     三、gdb 与 ptrace
    </h2>
    <p>
     这里简单介绍下GDB调试，GDB调试主要分为以下两种方法：
    </p>
    <p>
     <strong>
      1）本地调试
     </strong>
    </p>
    <p>
     该方式下，调试程序（GDB） 和 被调试程序（Tracee）运行在同一台电脑中。可以使用 “gdb加载运行被调试程序” 或 “gdb attach到正在运行的被调试程序” 这两个模式进行调试。
    </p>
    <p class="img-center">
     <img alt="" height="229" src="https://i-blog.csdnimg.cn/direct/517f31c501c34838a6b7386f925ef1a0.png" width="227"/>
    </p>
    <p>
     <strong>
      2）远程调试
     </strong>
    </p>
    <p>
     GDB远程调试的方式，主要用于嵌入式的场景，由于GDB这个程序本身体积比较大，在某些容量比较下的嵌入式目标机中，没有充足的资源用于运行庞大的GDB。因此，GDB也提供远程调试的方式：gdb server程序 运行在目标机上，gdb client运行在调试机上。由于gdb server程序的体积比较小，所以可以在大部分嵌入式目标机上运行，gdb client运行在调试机上，通过网络/串口与目标机上运行的gdb server进行通知，并通过gdb server调试控制目标程序。
    </p>
    <p class="img-center">
     <img alt="" height="242" src="https://i-blog.csdnimg.cn/direct/20dd06dea0af44c88c6d1cc0f6f6b710.png" width="278"/>
    </p>
    <p>
     以下总结了gdb中常用的一些操作，以及其底层对应的ptrace操作。本系列后续文章将围绕以下功能进行深入探讨。
    </p>
    <p class="img-center">
     <img alt="" height="2120" src="https://i-blog.csdnimg.cn/direct/7486982d509d4fa5814a8cf2a3b30068.png" width="2732"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f685f625f5f6b2f:61727469636c652f64657461696c732f313436313035313135" class_="artid" style="display:none">
 </p>
</div>


