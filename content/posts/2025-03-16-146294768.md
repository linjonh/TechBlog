---
layout: post
title: "二vtkCommand的使用"
date: 2025-03-16 14:20:14 +0800
description: "vtkCommand是VTK中的一个重要的类，用于处理事件和回调机制。它允许用户在特定事件发生时执行自定义的操作，例如在交互操作、数据更新或渲染过程中触发某些功能。"
keywords: "二、vtkCommand的使用"
categories: ['Vtk']
tags: ['Vtk']
artid: "146294768"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146294768
    alt: "二vtkCommand的使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146294768
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146294768
cover: https://bing.ee123.net/img/rand?artid=146294768
image: https://bing.ee123.net/img/rand?artid=146294768
img: https://bing.ee123.net/img/rand?artid=146294768
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     二、vtkCommand的使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、概述
    </h2>
    <p>
     vtkCommand是VTK中的一个重要的类，用于处理事件和回调机制。它允许用户在特定事件发生时执行自定义的操作，例如在交互操作、数据更新或渲染过程中触发某些功能。
    </p>
    <h2>
     二、主要功能
    </h2>
    <p>
     1、事件处理：vtkCommand用于监听和处理VTK管线中的各种事件
    </p>
    <p>
     2、回调机制：通过回调函数，用户可以在事件发生时执行自定义代码
    </p>
    <p>
     3、事件类型：VTK定义了多种事件类型，如StartEvent、EndEvent、ProgressEvent等。
    </p>
    <h2>
     三、常用事件类型
    </h2>
    <table align="left" border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        StartEvent
       </td>
       <td>
        某个过程开始时触发
       </td>
      </tr>
      <tr>
       <td>
        EndEvent
       </td>
       <td>
        某个过程结束时触发
       </td>
      </tr>
      <tr>
       <td>
        ProgressEvent
       </td>
       <td>
        过程进行中触发，常用于更新进度条
       </td>
      </tr>
      <tr>
       <td>
        ModifiedEvent
       </td>
       <td>
        对象被修改时触发
       </td>
      </tr>
      <tr>
       <td>
        PickEvent
       </td>
       <td>
        用户进行拾起操作时触发
       </td>
      </tr>
      <tr>
       <td>
        InteractionEvent
       </td>
       <td>
        用户进行交互操作时触发
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
    </h2>
    <h2>
    </h2>
    <h2>
    </h2>
    <h2>
    </h2>
    <h2>
    </h2>
    <h2>
    </h2>
    <h2>
     四、使用步骤
    </h2>
    <h3>
     1、创建一个类继承于vtkCommand，并重写Execute方法
    </h3>
    <pre><code>class vtkMyCallback : public vtkCommand
{
public:
    static vtkMyCallback* New()
    {
        return new vtkMyCallback;
    }
    void Execute(vtkObject* caller, unsigned long, void*) override
    {
        auto renderer = reinterpret_cast&lt;vtkRenderer*&gt;(caller);
        std::cout &lt;&lt; renderer-&gt;GetActiveCamera()-&gt;GetPosition()[0] &lt;&lt; " "
                  &lt;&lt; renderer-&gt;GetActiveCamera()-&gt;GetPosition()[1] &lt;&lt; " "
                  &lt;&lt; renderer-&gt;GetActiveCamera()-&gt;GetPosition()[2] &lt;&lt; std::endl;
    }
    vtkMyCallback() = default;
};</code></pre>
    <h3>
     2、创建vtkCommand对象 ，经对象添加到需要监听的对象中
    </h3>
    <pre><code>//渲染器对象
vtkNew&lt;vtkRenderer&gt; ren1;

vtkNew&lt;vtkMyCallback&gt; mo1;
ren1-&gt;AddObserver(vtkCommand::StartEvent, mo1);</code></pre>
    <h2>
     五、完整示例
    </h2>
    <pre><code>namespace {
class vtkMyCallback : public vtkCommand
{
public:
    static vtkMyCallback* New()
    {
        return new vtkMyCallback;
    }
    void Execute(vtkObject* caller, unsigned long, void*) override
    {
        // Note the use of reinterpret_cast to cast the caller to the expected type.
        auto renderer = reinterpret_cast&lt;vtkRenderer*&gt;(caller);
        std::cout &lt;&lt; renderer-&gt;GetActiveCamera()-&gt;GetPosition()[0] &lt;&lt; " "
                  &lt;&lt; renderer-&gt;GetActiveCamera()-&gt;GetPosition()[1] &lt;&lt; " "
                  &lt;&lt; renderer-&gt;GetActiveCamera()-&gt;GetPosition()[2] &lt;&lt; std::endl;
    }
    vtkMyCallback() = default;
};
}

int main(int, char*[])
{
  //创建VTK命名颜色
  vtkNew&lt;vtkNamedColors&gt; colors;

  //创建多边形圆锥体
  vtkNew&lt;vtkConeSource&gt; cone;
  cone-&gt;SetHeight(3.0);
  cone-&gt;SetRadius(1.0);
  cone-&gt;SetResolution(10);

  //将多边形数据映射到圆形基于映射器
  vtkNew&lt;vtkPolyDataMapper&gt; coneMapper;
  coneMapper-&gt;SetInputConnection(cone-&gt;GetOutputPort());

  //创建渲染创建中的实体（几何体和属性）
  vtkNew&lt;vtkActor&gt; coneActor;
  coneActor-&gt;SetMapper(coneMapper);
  coneActor-&gt;GetProperty()-&gt;SetColor(colors-&gt;GetColor3d("MistyRose").GetData());

  //创建渲染器
  vtkNew&lt;vtkRenderer&gt; ren1;
  ren1-&gt;AddActor(coneActor);
  ren1-&gt;SetBackground(colors-&gt;GetColor3d("MidnightBlue").GetData());
  ren1-&gt;ResetCamera();

  //为渲染器创建绘制窗口
  vtkNew&lt;vtkRenderWindow&gt; renWin;
  renWin-&gt;AddRenderer(ren1);
  renWin-&gt;SetSize(300, 300);
  renWin-&gt;SetWindowName("Tutorial_Step2");

  //注册监听的事件及回调
  vtkNew&lt;vtkMyCallback&gt; mo1;
  ren1-&gt;AddObserver(vtkCommand::StartEvent, mo1);

  for (int i = 0; i &lt; 360; ++i)
  {
    renWin-&gt;Render();
    ren1-&gt;GetActiveCamera()-&gt;Azimuth(1);
  }

  return EXIT_SUCCESS;
}</code></pre>
    <p>
     运行结果，物体旋转的同时，打印数据：
    </p>
    <pre><code>15.2107 1 0
15.2084 1 -0.265464
15.2014 1 -0.530846
15.1899 1 -0.796067
15.1737 1 -1.06105
15.1528 1 -1.3257
15.1274 1 -1.58995
15.0973 1 -1.85372
15.0627 1 -2.11692
15.0234 1 -2.37948
14.9796 1 -2.64131
14.9312 1 -2.90234
14.8783 1 -3.16248
14.8209 1 -3.42167
14.7589 1 -3.6798
14.6924 1 -3.93682
14.6215 1 -4.19264
14.5461 1 -4.44718
14.4662 1 -4.70037
14.382 1 -4.95212
14.2934 1 -5.20237
14.2004 1 -5.45103</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313739353539372f:61727469636c652f64657461696c732f313436323934373638" class_="artid" style="display:none">
 </p>
</div>


