---
layout: post
title: "spring配置类和整合Junit"
date: 2025-03-09 16:46:28 +0800
description: "在spring中，虽然可以用@Component把我们想要放入的bean所属的类放入ioc容器中，但是这个类局限于自己自定义的类，但是如果时其他已经被封装好的实现的类，我们就不能这么干了，就只能老老实实用xml文件来。其实还是有其他方法的，它就是java的配置类。那至于什么是配置类呢，它的作用其实和xml文件的作用是差不多的，都是用来管理bean的。首先来介绍它的作用就是用来指定当前的类是一个配置类。其实讲到这就够了，至于怎么获取bean后面再来讲。接着我们来讲一下。"
keywords: "【spring】配置类和整合Junit"
categories: ['未分类']
tags: ['后端', 'Spring', 'Java']
artid: "146131341"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146131341
    alt: "spring配置类和整合Junit"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146131341
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146131341
cover: https://bing.ee123.net/img/rand?artid=146131341
image: https://bing.ee123.net/img/rand?artid=146131341
img: https://bing.ee123.net/img/rand?artid=146131341
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【spring】配置类和整合Junit
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.配置类
    </h2>
    <p>
     在spring中，虽然可以用@Component把我们想要放入的bean所属的类放入ioc容器中，但是这个类局限于自己自定义的类，但是如果时其他已经被封装好的实现的类，我们就不能这么干了，就只能老老实实用xml文件来。其实还是有其他方法的，它就是java的配置类。
    </p>
    <p>
     那至于什么是配置类呢，它的作用其实和xml文件的作用是差不多的，都是用来管理bean的。
    </p>
    <p>
     首先来介绍
     <span style="color:#fe2c24">
      @Configuration
     </span>
    </p>
    <p>
     它的作用就是用来指定当前的类是一个配置类。
    </p>
    <p>
     其实讲到这就够了，至于怎么获取bean后面再来讲。
    </p>
    <p>
     接着我们来讲一下
     <span style="color:#fe2c24">
      @ComponentScan
     </span>
    </p>
    <p>
     <span style="color:null">
      它就是通过注解的方式指定spring在创建容器时要扫描的包（带有@Conponent，@Service），使用它就等同于在xml文件中配置了.它一般和@Configuration配合使用。
     </span>
    </p>
    <p>
     <span style="color:null">
      &lt;context:component-scan base-package="包路径"&gt;&lt;/context:component-scan&gt;
     </span>
    </p>
    <p>
     该注解有4个属性，分别是basePackages，basePackageClasses，includeFilters，excludeFilters，下面来分别讲解吧。
    </p>
    <p>
     <strong>
      basePackages：
     </strong>
     用与指定要扫描的包的路径，可以同时指定多个包，例如@ComponentScan(basePackages={" 包1","包2"})
    </p>
    <p>
     <strong>
      basePackageClasses：
     </strong>
     这个就更加准确，用来指定具体要扫描的类，它也可以同时指定多个类，例如：@ComponentScan(basePackageClasses={"类a.class,类b.class"})
    </p>
    <p>
     <strong>
      includeFilters:
     </strong>
     指定要筛选的类，它一般配合basePackages来使用，通常先是basePackages来指定要扫描的包，然后includeFilters来从这些包中指定要筛选的类型。例如@ComponentScan（basePackages={“包1，包2”}
    </p>
    <p>
     includeFilters=@ComponentScan.Filter(type=FilterType.ASSIGNABLE_TYPE,classes="类a"）
    </p>
    <p>
     这里还要补充一点就是关于这里的type，常用的分两种，FilterType.ASSIGNABLE_TYPE和FilterType.ANNOTATION，第一个就是表明该过滤器会筛选指定的类及其子类，第二个就不会连带着筛选指定的类的子类，而是你标明是什么类就筛选什么类。
    </p>
    <p>
     <strong>
      excludeFilters：
     </strong>
     它与includeFilters就相反了，它是用来指定要排除的类，当然它也需要与basePackages配合使用，流程也是一样的，先是basePackages来指定要扫描的包，然后excludeFilters来排除相应的类其他就可以注册为bean。
    </p>
    <p>
     同样需要补充的是，它也有不同的类型，常用的分别是 FilterType.ASSIGNABLE_TYPE和 FilterType.ANNOTATION，也是一样的一个就是排除类及其子类，另一个就是排除类但不排除它的子类。
    </p>
    <p>
     例如  @ComponentScan(
     <br/>
     basePackages = "包",
     <br/>
     excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = 类)
     <br/>
     )
    </p>
    <p>
     然后呢来讲一下
     <span style="color:#fe2c24">
      @Bean
     </span>
    </p>
    <p>
     <span style="color:null">
      他是用于把当前的方法的返回值作为bean对象作为返回值放入IOC容器中
     </span>
    </p>
    <p>
     <span style="color:null">
      它有一个属性name，用于指定当前bean的id，如果不写，id默认为方法名。
     </span>
    </p>
    <p>
     <span style="color:null">
      这里还有一点要提醒，它默认还是单例bean，如果我们想要创建多例bean，就再加一个注解，就是@Scope(value="prototype"),这样就行了
     </span>
    </p>
    <p>
     <span style="color:null">
      然后就是
     </span>
     <span style="color:#fe2c24">
      @Import
     </span>
     <span style="color:null">
      了
     </span>
    </p>
    <p>
     它用于引入其他的配置类，用于实现配置的模块化(通俗点讲就是解决了整个项目所有的bean都交由一个配置类，这样显然不符合java中分层的思想，所以可以将这些bean拆分为其他模块，最后在通过引入的方式合并)
    </p>
    <p>
     例如@Configuration
     <br/>
     @Import({类a.class, 类b.class})
    </p>
    <p>
    </p>
    <p>
     最后呢就是
     <span style="color:#fe2c24">
      @PropertySource
     </span>
    </p>
    <p>
     它是用于指定一个或多个属性配置文件的位置，以便在应用程序中加载和使用这些配置文件中的属性值。它可以将外部的属性文件加载到 Spring 的环境中，从而在应用程序中方便地访问这些属性值。
    </p>
    <p>
     它可以通过value属性指定属性文件的位置，可以使用类路径(classpath:)或文件系统路径(file:)
    </p>
    <p>
     例如
    </p>
    <pre><code class="hljs">@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig {
    // 配置类内容
}</code></pre>
    <p>
     它支持同时加载多个文件，文件间用逗号隔开即可
    </p>
    <p>
     下面用一个properties文件为例
    </p>
    <p>
     文件内容如下
    </p>
    <pre><code class="hljs">jdbc.username=root
jdbc.password=Admin123!
jdbc.url=jdbc:mysql://192.168.10.137:3306/user
jdbc.driverClass=com.mysql.jdbc.Driver</code></pre>
    <p>
     代码
    </p>
    <pre><code class="hljs">​
​
​
@PropertySource("classpath:jdbcConfig.properties")
public class JdbcConfig {
@Value("${jdbc.driver}")
private String driver;
@Value("${jdbc.url}")
private String url;
@Value("${jdbc.username}")
private String username;
@Value("${jdbc.password}")
private String password;
@Bean(name = "dataSource")
public DataSource dataSource(){
ComboPooledDataSource dataSource = new ComboPooledDataSource();
try {
dataSource.setDriverClass(driver);
dataSource.setJdbcUrl(url);
dataSource.setUser(username);
dataSource.setPassword(password);
return dataSource;
} catch (PropertyVetoException e) {
throw new RuntimeException();
}
}
}

​

​

​</code></pre>
    <p>
     接下来就讲一下啊这个配置类到底怎么用
    </p>
    <p>
     直接上代码
    </p>
    <pre><code class="hljs">import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 定义一个服务类
class MyService {
    public void doSomething() {
        System.out.println("Doing something...");
    }
}

// 配置类
@Configuration
class AppConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建 Spring 应用上下文
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        // 从上下文中获取 Bean
        MyService service = context.getBean(MyService.class);

        // 调用 Bean 的方法
        service.doSomething();

        // 关闭上下文
        context.close();
    }
}</code></pre>
    <p>
     其实跟之前xml的方式差不多，只不过这个类吧变成了AnnotationConfigApplicationContext，然后把相应的类放进去。
    </p>
    <h2>
     2.整合Junit
    </h2>
    <p>
     Junit就是用来测试片段代码的，下面直接上代码
    </p>
    <pre><code class="hljs">import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfiguration.class)
public class TestAccount {

    @Autowired
    AccountService accountService;

    @Test
    public void test() {
        // 3. 执行方法
        List&lt;Account&gt; accounts = accountService.findAllAccount();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }
}</code></pre>
    <p>
     <strong>
      <code>
       @RunWith(SpringJUnit4ClassRunner.class)
      </code>
      ：
     </strong>
     让 JUnit 使用 Spring 测试运行器，激活 Spring 容器的依赖注入等功能。
    </p>
    <p>
     <strong>
      <code>
       @ContextConfiguration(classes = SpringConfiguration.class)
      </code>
      ：
     </strong>
     指定 Spring 容器的配置来源（配置类或 XML 文件），告诉测试环境如何加载 Bean。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f4c333532363538313430322f:61727469636c652f64657461696c732f313436313331333431" class_="artid" style="display:none">
 </p>
</div>


