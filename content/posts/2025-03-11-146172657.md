---
layout: post
title: "面试题系列Redis-常见面试题答案"
date: 2025-03-11 11:06:14 +0800
description: "Redis 是 Java 高级工程师必须掌握的核心技术，需深入理解其数据结构、持久化、集群、锁机制等。面试中常考察问题的实际应用和原理结合"
keywords: "【面试题系列】Redis 常见面试题&答案"
categories: ['面试题系列']
tags: ['缓存', '数据库', 'Redis']
artid: "146172657"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146172657
    alt: "面试题系列Redis-常见面试题答案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146172657
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146172657
cover: https://bing.ee123.net/img/rand?artid=146172657
image: https://bing.ee123.net/img/rand?artid=146172657
img: https://bing.ee123.net/img/rand?artid=146172657
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【面试题系列】Redis 常见面试题&amp;答案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d0a8356fe2414bf28a016856f2b56ede.png#pic_center"/>
    </p>
    <h3>
     <a id="_2">
     </a>
     <strong>
      一、基础概念
     </strong>
    </h3>
    <h4>
     <a id="1_Redis__3">
     </a>
     1. Redis 有哪些数据结构？各自的应用场景是什么？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis 支持以下数据结构：
    </p>
    <ul>
     <li>
      <strong>
       String
      </strong>
      ：最基础类型，存储字符串、数字、二进制数据。
      <br/>
      <em>
       场景：缓存用户信息、计数器、分布式锁。
      </em>
     </li>
     <li>
      <strong>
       Hash
      </strong>
      ：键值对集合，类似 Java 的 HashMap。
      <br/>
      <em>
       场景：存储对象（如用户属性）。
      </em>
     </li>
     <li>
      <strong>
       List
      </strong>
      ：双向链表，支持左右插入和弹出。
      <br/>
      <em>
       场景：消息队列（LPUSH + RPOP）、微博时间线。
      </em>
     </li>
     <li>
      <strong>
       Set
      </strong>
      ：无序唯一集合，支持交集、并集、差集操作。
      <br/>
      <em>
       场景：好友关系、标签系统。
      </em>
     </li>
     <li>
      <strong>
       Sorted Set
      </strong>
      ：有序唯一集合，基于跳表实现。
      <br/>
      <em>
       场景：排行榜、带权重的任务队列。
      </em>
     </li>
     <li>
      <strong>
       BitMap
      </strong>
      ：位操作，存储空间极小。
      <br/>
      <em>
       场景：用户签到、统计活跃用户。
      </em>
     </li>
     <li>
      <strong>
       HyperLogLog
      </strong>
      ：基数统计，误差率约 0.81%。
      <br/>
      <em>
       场景：统计 UV。
      </em>
     </li>
     <li>
      <strong>
       Geospatial
      </strong>
      ：地理空间索引。
      <br/>
      <em>
       场景：附近的人、路线规划。
      </em>
     </li>
    </ul>
    <p>
     <strong>
      Java 示例（Jedis）：
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user:10086"</span><span class="token punctuation">,</span> <span class="token string">"{\"name\":\"Alice\",\"age\":25}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="2_Redis__30">
     </a>
     2. Redis 持久化机制有哪些？区别是什么？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis 提供两种持久化方式：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        RDB（快照）
       </strong>
      </p>
      <ul>
       <li>
        定期将内存数据快照写入磁盘。
       </li>
       <li>
        优点：恢复速度快，适合全量备份。
       </li>
       <li>
        缺点：可能丢失最后一次快照后的所有数据。
       </li>
       <li>
        配置：
        <code>
         save 900 1
        </code>
        （900 秒内至少 1 次修改触发快照）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        AOF（Append-Only File）
       </strong>
      </p>
      <ul>
       <li>
        记录所有写操作命令，追加到日志文件。
       </li>
       <li>
        优点：数据更完整（可配置每秒刷盘）。
       </li>
       <li>
        缺点：文件体积大，恢复速度较慢。
       </li>
       <li>
        配置：
        <code>
         appendonly yes
        </code>
        ，
        <code>
         appendfsync everysec
        </code>
        。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      最佳实践：
     </strong>
     <br/>
     同时开启 RDB 和 AOF，AOF 用于保证数据完整性，RDB 用于快速恢复。
    </p>
    <h3>
     <a id="_49">
     </a>
     <strong>
      二、核心原理
     </strong>
    </h3>
    <h4>
     <a id="3_Redis__50">
     </a>
     3. Redis 为什么单线程还能高性能？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       纯内存操作
      </strong>
      ：数据存储在内存中，读写速度极快。
     </li>
     <li>
      <strong>
       非阻塞 I/O
      </strong>
      ：使用多路复用（epoll）处理大量连接。
     </li>
     <li>
      <strong>
       单线程避免上下文切换
      </strong>
      ：减少线程间竞争和锁开销。
     </li>
     <li>
      <strong>
       优化数据结构
      </strong>
      ：例如跳表、哈希表的高效实现。
     </li>
    </ul>
    <p>
     <strong>
      扩展：
     </strong>
     <br/>
     Redis 6.0 引入多线程处理网络请求，但核心逻辑仍为单线程。
    </p>
    <h4>
     <a id="4_Redis__61">
     </a>
     4. Redis 如何实现分布式锁？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis 分布式锁的实现方案：
    </p>
    <ol>
     <li>
      <strong>
       SETNX + EXPIRE
      </strong>
      （存在原子性问题）：
      <pre><code class="prism language-java"><span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"lock_key"</span><span class="token punctuation">,</span> <span class="token string">"unique_value"</span><span class="token punctuation">,</span> <span class="token string">"NX"</span><span class="token punctuation">,</span> <span class="token string">"EX"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获得锁，执行业务逻辑</span>
    jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token string">"lock_key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <strong>
       RedLock 算法
      </strong>
      （Redis 官方推荐）：
      <ul>
       <li>
        基于多个独立 Redis 节点，避免单点故障。
       </li>
       <li>
        步骤：
        <br/>
        ① 向半数以上节点获取锁；
        <br/>
        ② 计算总耗时，若超过锁有效期则释放所有锁。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      注意事项：
     </strong>
    </p>
    <ul>
     <li>
      锁的有效期需合理设置，防止业务未完成锁已过期。
     </li>
     <li>
      使用 UUID 保证解锁时的幂等性，避免误删他人锁。
     </li>
    </ul>
    <h3>
     <a id="_83">
     </a>
     <strong>
      三、集群与高可用
     </strong>
    </h3>
    <h4>
     <a id="5_Redis_Cluster__84">
     </a>
     5. Redis Cluster 的分片机制是什么？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis Cluster 使用**哈希槽（Hash Slot）**分配数据：
    </p>
    <ul>
     <li>
      总共有 16384 个槽，每个键通过 CRC16 算法计算哈希值，对 16384 取模得到槽位。
     </li>
     <li>
      每个节点负责一部分槽，槽位可动态迁移。
     </li>
     <li>
      客户端通过询问节点或缓存槽位信息，直接定位数据所在节点。
     </li>
    </ul>
    <p>
     <strong>
      Java 示例（JedisCluster）：
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"node1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">JedisCluster</span> jedisCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h4>
     <a id="6_Redis__100">
     </a>
     6. Redis 主从复制的原理是什么？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     主从复制流程：
    </p>
    <ol>
     <li>
      <strong>
       全量复制
      </strong>
      ：
      <ul>
       <li>
        从节点发送
        <code>
         SYNC
        </code>
        命令，主节点生成 RDB 文件并发送给从节点。
       </li>
       <li>
        主节点将后续写命令缓存，待 RDB 同步完成后发送给从节点。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       增量复制
      </strong>
      ：
      <ul>
       <li>
        全量复制完成后，主节点将写命令以
        <code>
         PSYNC
        </code>
        方式同步给从节点。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      配置：
     </strong>
     <br/>
     <code>
      slaveof &lt;master_ip&gt; &lt;master_port&gt;
     </code>
     。
    </p>
    <h3>
     <a id="_113">
     </a>
     <strong>
      四、性能与优化
     </strong>
    </h3>
    <h4>
     <a id="7__Redis__114">
     </a>
     7. 如何避免 Redis 缓存雪崩？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     缓存雪崩指大量缓存同时失效，导致数据库压力激增。解决方案：
    </p>
    <ol>
     <li>
      <strong>
       设置随机过期时间
      </strong>
      ：避免所有键集中过期。
     </li>
     <li>
      <strong>
       加锁限流
      </strong>
      ：使用分布式锁（如 RedLock）保证同一时间只有少量请求访问数据库。
     </li>
     <li>
      <strong>
       二级缓存
      </strong>
      ：本地缓存（如 Caffeine）作为 Redis 的降级方案。
     </li>
     <li>
      <strong>
       服务熔断
      </strong>
      ：通过 Hystrix 等框架暂时拒绝部分请求。
     </li>
    </ol>
    <h4>
     <a id="8_Redis__123">
     </a>
     8. Redis 内存淘汰策略有哪些？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis 内存不足时的淘汰策略（
     <code>
      maxmemory-policy
     </code>
     ）：
    </p>
    <ul>
     <li>
      <code>
       noeviction
      </code>
      ：默认策略，内存不足时拒绝写操作。
     </li>
     <li>
      <code>
       allkeys-lru
      </code>
      ：淘汰所有键中最久未使用的键。
     </li>
     <li>
      <code>
       volatile-lru
      </code>
      ：仅淘汰设置了过期时间的键中最久未使用的键。
     </li>
     <li>
      <code>
       allkeys-random
      </code>
      ：随机淘汰键。
     </li>
     <li>
      <code>
       volatile-ttl
      </code>
      ：优先淘汰剩余存活时间最短的键。
     </li>
    </ul>
    <p>
     <strong>
      最佳实践：
     </strong>
     <br/>
     通常使用
     <code>
      allkeys-lru
     </code>
     ，并结合监控调整内存大小。
    </p>
    <h3>
     <a id="_136">
     </a>
     <strong>
      五、实战问题
     </strong>
    </h3>
    <h4>
     <a id="9__Redis__137">
     </a>
     9. 如何监控 Redis 的慢查询？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       配置慢查询日志
      </strong>
      ：
      <pre><code class="prism language-conf">slowlog-log-slower-than 10000  # 超过 10ms 的查询记录日志
slowlog-max-len 128           # 最多保存 128 条慢查询
</code></pre>
     </li>
     <li>
      <strong>
       Java 监控工具
      </strong>
      ：
      <br/>
      使用
      <code>
       Redis Sentinel
      </code>
      或
      <code>
       Redis Insight
      </code>
      分析慢查询。
      <br/>
      通过 Jedis 执行
      <code>
       SLOWLOG GET
      </code>
      命令获取慢查询列表。
     </li>
    </ul>
    <h4>
     <a id="10_Redis__149">
     </a>
     10. Redis 事务支持回滚吗？
    </h4>
    <p>
     <strong>
      答案：
     </strong>
     <br/>
     Redis 事务
     <strong>
      不支持回滚
     </strong>
     ，因为设计哲学是“快速失败”：
    </p>
    <ul>
     <li>
      若事务中的命令在入队阶段出现语法错误，整个事务会被取消。
     </li>
     <li>
      若命令在执行阶段失败（如操作类型错误），其他命令仍会执行。
     </li>
     <li>
      需通过应用层逻辑保证数据一致性。
     </li>
    </ul>
    <p>
     <strong>
      示例：
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token class-name">Transaction</span> transaction <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
transaction<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
transaction<span class="token punctuation">.</span><span class="token function">incr</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 类型错误，执行时失败</span>
transaction<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 返回 [OK, (error) ERR value is not an integer or out of range]</span>
</code></pre>
    <h2>
     <a id="_165">
     </a>
     总结
    </h2>
    <p>
     Redis 是 Java 高级工程师必须掌握的核心技术，需深入理解其数据结构、持久化、集群、锁机制等。面试中常考察问题的实际应用和原理结合，建议结合源码和生产实践进一步巩固。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33363735353533352f:61727469636c652f64657461696c732f313436313732363537" class_="artid" style="display:none">
 </p>
</div>


