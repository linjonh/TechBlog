---
layout: post
title: "C语言_数据结构总结7顺序队列循环队列"
date: 2025-03-09 09:07:22 +0800
description: "简称队，也是一种操作受限的线性表。只允许表的一端进行插入，表的另一端进行删除针对顺序队列存在的“假溢出”问题，引出的循环队列概念。将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环。当队首指针Q->front=MaxSize-1 后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。显然，队空的条件是Q.front == Q.rear。但若入队元素的速度快于出队元素，则队尾指针很快就会追赶上队首指针。"
keywords: "C语言_数据结构总结7:顺序队列（循环队列）"
categories: ['C']
tags: ['算法', '数据结构', '开发语言', 'Visualstudio', 'Visual', 'Studio', 'C']
artid: "146127318"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146127318
    alt: "C语言_数据结构总结7顺序队列循环队列"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146127318
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146127318
cover: https://bing.ee123.net/img/rand?artid=146127318
image: https://bing.ee123.net/img/rand?artid=146127318
img: https://bing.ee123.net/img/rand?artid=146127318
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言_数据结构总结7:顺序队列（循环队列）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="color:#f3f3f4">
      <strong>
       <span style="background-color:#fe2c24">
        纯C语言实现，不涉及C++
       </span>
      </strong>
     </span>
    </p>
    <h3>
     <strong>
      队列
     </strong>
    </h3>
    <p>
     简称队，也是一种操作受限的线性表。只允许表的一端进行插入，表的另一端进行删除
     <br/>
     特性：
     <span style="color:#4da8ee">
      <strong>
       先进先出
      </strong>
     </span>
    </p>
    <p>
     针对顺序队列存在的“
     <span style="color:#fe2c24">
      假溢出
     </span>
     ”问题，引出的循环队列概念。
    </p>
    <p>
     <br/>
     <strong>
      循环队列
     </strong>
     <br/>
     将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环。
     <br/>
     当队首指针Q-&gt;front=MaxSize-1 后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。
    </p>
    <p>
     <strong>
      循环队列中的判空和判满条件分析：
     </strong>
     <br/>
     显然，队空的条件是Q.front == Q.rear。但若入队元素的速度快于出队元素，则队尾指针很快就会追赶上队首指针。
     <br/>
     此时可以看出队满时也有：Q.front == Q.rear.
     <br/>
     为此，有3中处理方法：
     <br/>
     1.
     <span style="color:#f3f3f4">
      <strong>
       <span style="background-color:#fe2c24">
        （推荐）
       </span>
      </strong>
     </span>
     牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定“队头指针在队尾指针的下一个位置作为队满标志”
     <br/>
     队满条件：
     <span style="background-color:#f9eda6">
      (Q.rear + 1) % MaxSize == Q.front;
     </span>
     <br/>
     队空条件：
     <span style="background-color:#f9eda6">
      Q.front == Q.rear;
     </span>
     <br/>
     队列中元素的个数：
     <span style="background-color:#f9eda6">
      (Q.rear - Q.front + MaxSize) % MaxSize;
     </span>
    </p>
    <p>
     2. 在定义存储类型中，增设size数据成员，表示元素个数。
     <br/>
     删除元素成功size减1；插入元素成功size加1.
     <br/>
     队满时：Q.size == MaxSize;
     <br/>
     队空时：Q.size == 0;
     <br/>
     队空和队满时都有：Q.front == Q.rear;
    </p>
    <p>
     3. 在定义存储类型中，增设tag数据成员,以区分是队满还是队空。
     <br/>
     删除元素成功置tag=0,若导致Q.front == Q.rear;则为队空
     <br/>
     插入元素成功置tag=1，若导致Q.front == Q.rear;则为队空
    </p>
    <p>
     <strong>
      顺序队列（循环队列）的基本操作：
     </strong>
    </p>
    <p>
     <em>
      <span style="color:#ed7976">
       以下使用的方法是第一种处理方法，即牺牲一个单元来区分队空和队满。
      </span>
     </em>
    </p>
    <h4>
     0.  存储结构
    </h4>
    <pre><code class="language-cs">
#include&lt;stdio.h&gt;
#define MaxSize 50
typedef int ElemType;

typedef struct SqQueue {
	ElemType data[MaxSize];  // 用数组存放队列元素
	int front;  // 队头指针.负责出队
	int rear;   //队尾指针，负责进队
}SqQueue;</code></pre>
    <h4>
     1. 初始化
    </h4>
    <pre><code class="language-cs">void InitQueue(SqQueue* Q) {
	Q-&gt;front = 0;
	Q-&gt;rear = 0;
}</code></pre>
    <h4>
     2. 判空
    </h4>
    <pre><code class="language-cs">int QueueEmpty(SqQueue* Q) {
	return Q-&gt;front == Q-&gt;rear;
}</code></pre>
    <h4>
     3. 判满
    </h4>
    <pre><code class="language-cs">int QueueFull(SqQueue* Q) {
	return (Q-&gt;rear + 1) % MaxSize == Q-&gt;front;
}</code></pre>
    <h4>
     4. 入队
    </h4>
    <pre><code class="language-cs">int EntreQueue(SqQueue* Q,ElemType value) {
	if (QueueFull(Q))
	{
		printf("队列已满，无法入队!\n");
		return -2;
	}
	Q-&gt;data[Q-&gt;rear] = value;
	Q-&gt;rear = (Q-&gt;rear + 1) % MaxSize;
	return 0;  //入队成功
}</code></pre>
    <h4>
     5. 出队
    </h4>
    <pre><code class="language-cs">int LeaveQueue(SqQueue* Q,ElemType* value) {
	if (QueueEmpty(Q))
	{
		printf("队列为空，无法有元素出队!\n");
		return -2;
	}
	*value = Q-&gt;data[Q-&gt;front];
	Q-&gt;front = (Q-&gt;front + 1) % MaxSize;
	return 0;  //出队成功
}</code></pre>
    <h4>
     6. 打印
    </h4>
    <pre><code class="language-cs">void printQueue(SqQueue* Q) {
	if (QueueEmpty(Q))
	{
		printf("队列为空，没有元素打印!\n");
		return;
	}
	int i = Q-&gt;front;
	printf("队列中的元素为：");
	while (i != Q-&gt;rear) {
		printf("%d ", Q-&gt;data[i]);
		i = (i + 1) % MaxSize;
	}
	printf("\n");
}</code></pre>
    <h4>
     7. 注销
    </h4>
    <p>
     这里其实循环队列不需要特别的注销操作，只是为了保持接口统一
    </p>
    <pre><code class="language-cs">void destroyQueue(SqQueue* Q) {
	Q-&gt;front = 0;
	Q-&gt;rear = 0;
}</code></pre>
    <h4>
     8. 测试
    </h4>
    <pre><code class="language-cs">int main() {
	SqQueue Q;
	InitQueue(&amp;Q);

	// 入队操作测试
	EntreQueue(&amp;Q, 11);
	EntreQueue(&amp;Q, 22);
	EntreQueue(&amp;Q, 33);
	printQueue(&amp;Q);  //队列中的元素为：11 22 33

	// 出队操作测试
	ElemType value;
	if (LeaveQueue(&amp;Q,&amp;value) == 0)
	{
		printf("出队的元素是:%d\n", value);  // 出队的元素是:11
	}
	printQueue(&amp;Q);  //队列中的元素为：22 33

	// 判空操作测试
	if (QueueEmpty(&amp;Q))
	{
		printf("队列为空!\n");
	}
	else {
		printf("队列不为空!\n");  //队列不为空!
	}
	
	// 判满操作测试
	if (QueueFull(&amp;Q))
	{
		printf("队列满了\n");
	}
	else {
		printf("队列还没满\n");  //队列还没满
	}

	// 注销队列
	destroyQueue(&amp;Q);
	printQueue(&amp;Q);  // 队列为空，没有元素打印!

	return 0;
}</code></pre>
    <h4>
     9. 完整代码
    </h4>
    <pre><code class="language-cs">#include&lt;stdio.h&gt;
#define MaxSize 50
typedef int ElemType;

typedef struct SqQueue {
	ElemType data[MaxSize];  // 用数组存放队列元素
	int front;  // 队头指针.负责出队
	int rear;   //队尾指针，负责进队
}SqQueue;

//操作1——初始化
void InitQueue(SqQueue* Q) {
	Q-&gt;front = 0;
	Q-&gt;rear = 0;
}

//操作2——判空
int QueueEmpty(SqQueue* Q) {
	return Q-&gt;front == Q-&gt;rear;
}

//操作3——判满
int QueueFull(SqQueue* Q) {
	return (Q-&gt;rear + 1) % MaxSize == Q-&gt;front;
}

//操作4——入队
int EntreQueue(SqQueue* Q,ElemType value) {
	if (QueueFull(Q))
	{
		printf("队列已满，无法入队!\n");
		return -2;
	}
	Q-&gt;data[Q-&gt;rear] = value;
	Q-&gt;rear = (Q-&gt;rear + 1) % MaxSize;
	return 0;  //入队成功
}

//操作5——出队
int LeaveQueue(SqQueue* Q,ElemType* value) {
	if (QueueEmpty(Q))
	{
		printf("队列为空，无法有元素出队!\n");
		return -2;
	}
	*value = Q-&gt;data[Q-&gt;front];
	Q-&gt;front = (Q-&gt;front + 1) % MaxSize;
	return 0;  //出队成功
}
//操作6——打印
void printQueue(SqQueue* Q) {
	if (QueueEmpty(Q))
	{
		printf("队列为空，没有元素打印!\n");
		return;
	}
	int i = Q-&gt;front;
	printf("队列中的元素为：");
	while (i != Q-&gt;rear) {
		printf("%d ", Q-&gt;data[i]);
		i = (i + 1) % MaxSize;
	}
	printf("\n");
}
//操作7——注销
// 这里其实循环队列不需要特别的注销操作，只是为了保持接口统一
void destroyQueue(SqQueue* Q) {
	Q-&gt;front = 0;
	Q-&gt;rear = 0;
}

int main() {
	SqQueue Q;
	InitQueue(&amp;Q);

	// 入队操作测试
	EntreQueue(&amp;Q, 11);
	EntreQueue(&amp;Q, 22);
	EntreQueue(&amp;Q, 33);
	printQueue(&amp;Q);  //队列中的元素为：11 22 33

	// 出队操作测试
	ElemType value;
	if (LeaveQueue(&amp;Q,&amp;value) == 0)
	{
		printf("出队的元素是:%d\n", value);  // 出队的元素是:11
	}
	printQueue(&amp;Q);  //队列中的元素为：22 33

	// 判空操作测试
	if (QueueEmpty(&amp;Q))
	{
		printf("队列为空!\n");
	}
	else {
		printf("队列不为空!\n");  //队列不为空!
	}
	
	// 判满操作测试
	if (QueueFull(&amp;Q))
	{
		printf("队列满了\n");
	}
	else {
		printf("队列还没满\n");  //队列还没满
	}

	// 注销队列
	destroyQueue(&amp;Q);
	printQueue(&amp;Q);  // 队列为空，没有元素打印!

	return 0;
}</code></pre>
    <h4>
     10. 运行截图
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/fbdb4c5a08df4b80b3ceb8a72682855c.png"/>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#f3f3f4">
      <strong>
       <span style="background-color:#ed7976">
        分享小妙招
       </span>
      </strong>
     </span>
     ：如果对哪个操作不是很明白，就询问AI:
     <strong>
      请结合以下代码详细描述XXX操作的过程 + 粘贴的代码
     </strong>
    </p>
    <p>
    </p>
    <p>
     <strong>
      <span style="color:#be191c">
       本人菜鸟一只，如果文章有出错处，欢迎评论区指正！
      </span>
     </strong>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363738313035392f:61727469636c652f64657461696c732f313436313237333138" class_="artid" style="display:none">
 </p>
</div>


