---
layout: post
title: "C28-特殊类设计"
date: 2025-03-13 18:06:25 +0800
description: "为什么会产生设计模式这样的东西呢？就像人类历史发展会产生兵法。最开始部落之间打仗时都是人拼人的对砍。后来春秋战国时期，七国之间经常打仗，就发现打仗也是有套路的，后来孙武就总结出了《孙子兵法》。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。"
keywords: "C++28--特殊类设计"
categories: ['未分类']
tags: ['C']
artid: "146155866"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146155866
    alt: "C28-特殊类设计"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146155866
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146155866
cover: https://bing.ee123.net/img/rand?artid=146155866
image: https://bing.ee123.net/img/rand?artid=146155866
img: https://bing.ee123.net/img/rand?artid=146155866
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++28--特殊类设计
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB" name="1.%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB">
     1.一个不能被拷贝的类
    </h2>
    <blockquote>
     <p>
      拷贝只会放生在两个场景中：拷贝构造函数以及赋值运算符重载，因此
      <strong>
       想要让一个类禁止拷贝，只需让该类不能调用拷贝构造以及赋值运算符重载即可。
      </strong>
     </p>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       C++98
      </li>
     </ul>
     <p>
      将拷贝构造函数与赋值运算符重载只声明不定义，并且将其访问权限设置为私有即可。
     </p>
    </blockquote>
    <pre><code class="language-cpp">class CopyBan
{
	//···

private:
	CopyBan(const CopyBan&amp;);
	CopyBan&amp; operator=(const CopyBan&amp;);
	//···
};</code></pre>
    <blockquote>
     <p>
      原因：
     </p>
     <ol>
      <li>
       设置成私有：如果只声明没有设置成private，用户自己如果在类外定义了，就可以不能禁止拷贝了
      </li>
      <li>
       只剩名不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不屑反而还简单，而且如果定义了就不会防止成员函数内部拷贝了。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       C++11
      </li>
     </ul>
     <p>
      C++扩展delete的用法，delete除了释放new申请的资源外，如果在默认成员函数后跟上=delete，表示让编译器删除掉该默认成员函数
     </p>
    </blockquote>
    <pre><code class="language-cpp">class CopyBan
{
	//···
	CopyBan(const CopyBan&amp;) = delete;
	CopyBan&amp; operator=(const CopyBan&amp;) = delete;
	//···
};</code></pre>
    <h2 id="2.%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" name="2.%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB">
     2.一个只能在堆上创建对象的类
    </h2>
    <pre><code class="language-cpp">class HeapOnly
{
public:
	static HeapOnly* CreatObject()
	{
		return new HeapOnly;
	}
private:
	HeapOnly(){}

	//C++98
	//1.只声明，不实现。因为实现可能会很麻烦，而你本身不需要
	//2.声明成私有
	HeapOnly(const HeapOnly&amp;);

	//or

	//C++11
	HeapOnly(const HeapOnly&amp;) = delete;
};</code></pre>
    <h2 id="3.%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" name="3.%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">
     3.一个只能在栈上创建对象
    </h2>
    <blockquote>
     <p>
      方法一：同上将构造函数私有化，然后设计静态方法创建对象返回即可。
     </p>
    </blockquote>
    <pre><code class="language-cpp">class StackOnly 
{
public:
	static StackOnly CreateObj()
	{
		return StackOnly();
	}

	//禁掉operator new可以把下面用new 调用拷贝构造申请对象给禁掉
	// StackOnly obj = StackOnly::CreatorObj();
	//StackOnly* ptr3 = new StackOnly(obj);
	void* operator new(size_t size) = delete;
	void operator delete(void* p) = delete;

private:
	StackOnly()
		:_a(0)
	{}
private:
	int _a;
}</code></pre>
    <h2 id="4.%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB" name="4.%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB">
     4.一个不能被继承的类
    </h2>
    <pre><code class="language-cpp">//C++98中构造函数私有化，派生类中调不到基类的构造函数，则无法继承
class NonInherit
{
public:
	static NonInherit GetInstance()
	{
		return NonInherit();
	}

private:
	NonInherit()
	{}
};</code></pre>
    <blockquote>
     <ul>
      <li>
       C++11方法
      </li>
     </ul>
     <p>
      final关键字，
      <strong>
       final修饰类，表示该类不能被继承。
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-cpp">class A final
{
	//···
};</code></pre>
    <h2 id="5.%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)" name="5.%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)" style="background-color:transparent">
     5.一个只能创建一个对象的类(单例模式)
    </h2>
    <blockquote>
     <p>
      <strong>
       设计模式：
      </strong>
     </p>
     <p>
      设计模式是一套
      <strong>
       被反复使用、多数人知晓、经过分类的、代码设计经验的总结。
      </strong>
      为什么会产生设计模式这样的东西呢？就像人类历史发展会产生兵法。最开始部落之间打仗时都是人拼人的对砍。后来春秋战国时期，七国之间经常打仗，就发现打仗也是有套路的，后来孙武就总结出了《孙子兵法》。
     </p>
     <p>
     </p>
     <p>
      使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。
     </p>
    </blockquote>
    <blockquote>
     <p>
      <strong>
       单例模式：
       <br/>
       一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全部访问点，该实例被所有程序模块共享。
      </strong>
      比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。
     </p>
    </blockquote>
    <blockquote>
     <p>
      单例模式有两种实现模式：
     </p>
     <ul>
      <li>
       饿汉模式
      </li>
     </ul>
     <p>
      就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象
     </p>
    </blockquote>
    <pre><code class="language-cpp">//饿汉模式
//优点：简单
//缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。
class Singleton
{
public:
	static Singleton* GetInstance()
	{
		return &amp;m_instance;
	}

private:
	//构造函数私有
	Singleton() {};

	//C++98防拷贝
	//Singleton(Singleton const&amp;);
	//Singleton&amp; operator = (Singleton const&amp;);

	//or

	//C++11
	Singleton(Singleton const&amp;) = delete;
	Singleton&amp; operator=(Singleton const&amp;) = delete;

	static Singleton m_instance;
};

Singleton Singleton::m_instance;//在程序入口之前就完成单例对象的初始化</code></pre>
    <blockquote>
     <p>
      如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避免资源竞争，提高响应速度更好。
     </p>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       懒汉模式
      </li>
     </ul>
     <p>
      如果单例对象构造十分耗时或者占用很多资源，比如加载插件，初始化网络链接，读取文件等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。所以这种情况使用懒汉模式(
      <strong>
       延迟加载
      </strong>
      )更好。(这个后续再讲，等我学完多线程)
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37383730323434302f:61727469636c652f64657461696c732f313436313535383636" class_="artid" style="display:none">
 </p>
</div>


