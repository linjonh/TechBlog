---
layout: post
title: "关于Playwright和Selenium-的区别和选择"
date: 2025-03-13 07:53:23 +0800
description: "2个实际的示例，展示如何使用 Playwright 进行网页自动化操作，包括导航、鼠标操作、输入框操作、键盘操作以及如何在 iframe 中操作元素。关于网页操作针对网页的常用操作方法page.reload()#刷新当前页面page.go_to(url)  #导航到新的URL地址page.go_back()#回到历史记录中的上一个界面page.go__forward()  #前进到历史记录中的下一个界面print(page.url)#打印当前网址。"
keywords: "关于Playwright和Selenium 的区别和选择"
categories: ['Playwright']
tags: ['自动化', '经验分享', '百度']
artid: "146189469"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146189469
    alt: "关于Playwright和Selenium-的区别和选择"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146189469
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146189469
cover: https://bing.ee123.net/img/rand?artid=146189469
image: https://bing.ee123.net/img/rand?artid=146189469
img: https://bing.ee123.net/img/rand?artid=146189469
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     关于Playwright和Selenium 的区别和选择
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
    </h2>
    <p>
     在自动化测试领域，Selenium 和 Playwright 是两个非常受欢迎的工具。了解它们各自的优缺点对于选择合适的测试工具至关重要。本文将详细比较这两个工具。
    </p>
    <p>
     <strong>
      Selenium 的优势
     </strong>
    </p>
    <p>
     <strong>
      历史悠久
     </strong>
    </p>
    <ul>
     <li>
      <p>
       由于 Selenium 存在时间长，拥有一个庞大的用户社区和大量的学习资源，这意味着我们在使用过程中遇到的一些疑难杂症有着更方便的解决方案。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      多语言支持
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Selenium 支持多种编程语言，如 Java、C#、Python、Ruby 等，这使得不同背景的开发者都能使用它。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      成熟的生态系统
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Selenium 与许多现有的 CI/CD 工具和测试框架集成良好。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      Selenium 的局限性
     </strong>
    </p>
    <h4>
     <strong>
      性能问题
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Selenium WebDriver 启动浏览器实例的速度通常比 Playwright 慢。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      浏览器支持
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       在某些情况下，Selenium 对浏览器的控制不如 Playwright 精细。如：并行运行测试、浏览器会话隔离等。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      复杂性
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Selenium 的测试脚本比 Playwright 更复杂，尤其是当涉及到多窗口或多标签页时。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      Playwright 的优势
     </strong>
    </p>
    <p>
     <strong>
      全面支持现代 Web 技术
     </strong>
    </p>
    <ul>
     <li>
      <p>
       Playwright 支持现代 Web 特性，如 Shadow DOM、现代 JavaScript 功能等。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      快速启动和执行
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       快速启动和执行：Playwright 通常比 Selenium 启动更快，执行测试也更迅速。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      易于编写及维护
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Playwright 提供了简洁的 API，使得编写和维护测试脚本变得更加容易。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      跨平台支持
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Playwright 原生支持 Windows、Linux 和 macOS，无需额外配置即可在不同操作系统上运行。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      自动录制测试过程
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       Playwright 可以自动录制测试过程，生成视频，便于分析和调试。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      Playwright 的局限性
     </strong>
    </p>
    <p>
     <strong>
      社区和资源
     </strong>
    </p>
    <ul>
     <li>
      <p>
       虽然 Playwright 的社区正在迅速增长，但与 Selenium 相比，可用的资源和社区支持可能较少。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      学习曲线
     </strong>
    </p>
    <ul>
     <li>
      <p>
       学习曲线对初学者可能稍陡：对于习惯于 Selenium 的开发者来说，适应 Playwright 的 API 和概念可能需要一些时间。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      针对以上的补充
     </strong>
    </p>
    <p>
     在自动化测试工具的选择上，Selenium 和 Playwright 各有千秋，而决定使用哪一个往往取决于项目需求、团队技能、未来发展趋势以及测试复杂度，可以参考以下。
    </p>
    <h3>
     <strong>
      项目需求
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       如果项目需要高度定制化的测试，或者已经围绕 Selenium 建立了成熟的测试框架，继续使用 Selenium 可能是更稳定的选择。
      </p>
     </li>
     <li>
      <p>
       对于重视跨浏览器一致性、测试效率和易用性的项目，Playwright 提供了更现代的解决方案。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      团队技能
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       如果团队成员对 JavaScript 生态系统更熟悉，Playwright 可能是一个更受欢迎的选择，因为它提供了更丰富的 JavaScript/TypeScript API。
      </p>
     </li>
     <li>
      <p>
       如果团队具有多种编程语言的背景，Selenium 的多语言支持（包括 Java、C#、Python、Ruby 等）可能更有优势。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      未来发展趋势
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       考虑技术栈的长期发展和维护成本至关重要。Playwright 作为后起之秀，其设计理念更贴近现代 Web 开发，对于追求技术前沿和效率的团队，可能更具吸引力。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      测试复杂度
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       对于需要大量模拟用户交互、网络条件变化等复杂场景的测试，Playwright 提供的高级 API 和内置功能可能更能满足需求。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
     <strong>
      小结啦~
     </strong>
    </p>
    <p>
     选择 Selenium 还是 Playwright 取决于多种因素。Selenium 拥有成熟的社区和广泛的语言支持，适合已经建立在该工具上的项目和多语言团队。而 Playwright 以其现代化的 API、高性能和易用性，适合追求最新技术和简化测试流程的团队。
    </p>
    <h2>
     安装指南及常见问题解决
    </h2>
    <p>
     Playwright 是一个用于自动化跨浏览器测试的 Node.js 库，支持 Chromium、Firefox 和 WebKit，我们可以通过编写测试脚本，模拟用户在浏览器中的操作。
    </p>
    <p>
     以下是Playwright的
    </p>
    <p>
     <strong>
      一、安装步骤
     </strong>
    </p>
    <p>
     1. 安装 Playwright 库
    </p>
    <p>
     在终端或命令提示符中输入以下命令来安装 Playwright：
    </p>
    <pre><code>pip install playwright</code></pre>
    <p>
     如果安装速度比较慢，可以使用国内镜像源来加速安装过程。以下是一些国内常用的 Python 镜像源：
    </p>
    <ul>
     <li>
      <p>
       豆瓣：https://pypi.douban.com/simple/
      </p>
     </li>
     <li>
      <p>
       阿里云：https://mirrors.aliyun.com/pypi/simple/
      </p>
     </li>
     <li>
      <p>
       华中理工大学：https://pypi.hustunique.com/simple/
      </p>
     </li>
     <li>
      <p>
       山东理工大学：https://pypi.sdutlinux.org/simple/
      </p>
     </li>
     <li>
      <p>
       中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple/
      </p>
     </li>
     <li>
      <p>
       清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/
      </p>
     </li>
    </ul>
    <h4>
     例如，使用阿里云镜像源安装 Playwright 的命令如下：
    </h4>
    <pre><code>pip install playwright -i https://mirrors.aliyun.com/pypi/simple</code></pre>
    <p>
     <strong>
      二、启动Playwright
     </strong>
    </p>
    <p>
     安装完成后，可以使用以下命令来启动 Playwright：
    </p>
    <pre><code>npx playwright install</code></pre>
    <ol>
     <li>
      <p>
       下载浏览器：该命令会检查你的系统中是否已经安装了 Playwright 支持的浏览器版本，如果没有，它会自动下载所需的浏览器。
      </p>
     </li>
     <li>
      <p>
       安装浏览器驱动：浏览器驱动程序（如 ChromeDriver 对于 Chromium、GeckoDriver 对于 Firefox）是允许 Playwright 与浏览器通信的程序。
       <code>
        npx playwright install
       </code>
       命令也会确保这些驱动程序是最新的，并且与 Playwright 的版本兼容。
      </p>
     </li>
     <li>
      <p>
       设置环境：安装过程中，Playwright 会设置必要的环境变量，确保测试脚本能够找到浏览器的可执行文件和驱动程序。
      </p>
     </li>
     <li>
      <p>
       无需手动操作：使用这个命令可以简化安装过程，你不需要手动下载和设置浏览器及其驱动程序。
      </p>
     </li>
    </ol>
    <p>
     如果只想安装指定的浏览器，可以使用以下命令。
    </p>
    <p>
     以下命令将只安装 Chromium 浏览器及其驱动程序。
    </p>
    <pre><code>npx playwright install chromium</code></pre>
    <p>
     <strong>
      三、创建第一个Playwright脚本
     </strong>
    </p>
    <p>
     在保证前面步骤均已成功后，创建一个名为
     <code>
      test.py
     </code>
     的文件，并添加以下代码：
    </p>
    <pre><code>from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch()  # 启动浏览器
    page = browser.new_page()      # 打开新页面
    page.goto('https://www.baidu.com')  # 导航到网页
    page.screenshot(path='example.png')  # 截图，默认保存在当前文件目录
    browser.close()  # 关闭浏览器</code></pre>
    <p>
     默认情况下，
     <code>
      headless
     </code>
     参数是
     <code>
      True
     </code>
     ，这意味着浏览器将在无头模式下运行。如果希望启动一个可视化界面的浏览器窗口，可将其设置为
     <code>
      False
     </code>
     。，如下所示：
    </p>
    <pre><code>from playwright.sync_api import sync_playwright</code>
<code>with sync_playwright() as p:</code><code>    browser = p.chromium.launch(headless=False)  # 启动浏览器，非无头模式</code><code>    page = browser.new_page()  # 打开新页面</code><code>    page.goto('https://www.baidu.com')  # 导航到网页</code><code>    page.screenshot(path='example.png')  # 截图，默认保存在当前文件目录</code><code>    browser.close()  # 关闭浏览器</code></pre>
    <p>
     <strong>
      四、安装过程中的常见问题及解决方法
     </strong>
    </p>
    <p>
     <strong>
      1、pip 安装错误
     </strong>
    </p>
    <p>
     如果“pip install playwright”指令报错，常见的执行失败原因是下载依赖中断，此时需重新执行。
    </p>
    <p>
     若 pip 版本过低导致获取相关依赖失败，可根据提示的指引执行以下命令自动升级 pip 到最新版本：
    </p>
    <pre><code>python.exe -m pip install --upgrade pip</code></pre>
    <p>
     <strong>
      2、playwright install 错误
     </strong>
    </p>
    <p>
     “python -m playwright install”报错常见的执行失败原因包括安装中断，最常见的是网络问题，可能是当前网络状态不佳，可以尝试切换镜像源或网络环境好的时候重新反复执行。
    </p>
    <p>
     <strong>
      3、Windows7 系统错误
     </strong>
    </p>
    <p>
     在 Windows 7 系统中，执行“playwright install”可能会出现“无法找到入口 无法定位程序输入点 GetHostNameW 于动态链接库 WS2_32.dll 上”的错误。
    </p>
    <p>
     解决方法是替换 Playwright 驱动下的 node.exe 版本，选择 win7 支持的版本，如 v12-13 版本，并将 node.exe 所在目录设置为环境变量 Path 中的变量。
    </p>
    <p>
     <strong>
      4、.Node.js版本问题
     </strong>
    </p>
    <p>
     当系统为 win7 时，执行“playwright install”可能会提示错误，原因是 win7 支持 node 的最高版本为 13.14.0，而 Playwright 要求 node 的版本必须高于 14，且 Playwright 下载的 node 版本为 16
    </p>
    <h2>
     locator 与 get_by_xxx 方法的应用
    </h2>
    <p>
     locator是 Playwright API 的核心组成部分，它在 Playwright 的所有语言绑定中都支持。是Playwright中最常用的方法。
    </p>
    <p>
     <strong>
      一、通过案例了解locator 与 get_by_xxx
     </strong>
    </p>
    <p>
     下面以百度搜索页为例，通过 Playwright 模拟打开百度，搜索“Playwright”操作的流程。
    </p>
    <pre><code>from playwright.sync_api import sync_playwright</code>
<code>with sync_playwright() as p:</code><code>    browser = p.chromium.launch()  # 启动浏览器</code><code>    page = browser.new_page()</code><code>    page.goto("https://www.baidu.com/")  # 打开百度界面</code><code>    input_box = page.locator("#kw")  # 通过id为“kw”的元素定位输入框</code><code>    input_box.click()  # 点击输入框</code><code>    page.locator("#kw").fill("Playwright")  # 输入“Playwright”</code><code>    page.get_by_role("button", name="百度一下").click()  # 点击查询按钮</code><code>    browser.close()  # 关闭浏览器</code></pre>
    <p>
     在以上案例中，我们使用了两种不同的方法来定义和操作页面元素：
     <code>
      locator
     </code>
     方法和
     <code>
      get_by_xxx
     </code>
     快捷方法。这两种方法在内部都是用来创建定位器，然后用于元素的操作。它们在本质上没有太大的不同，只是在使用方式上有所区别。
    </p>
    <p>
     <strong>
      1、locator方法
     </strong>
    </p>
    <p>
     先让我们一起了解下关于元素操作部分的代码：
    </p>
    <pre><code>input_box = page.locator("#kw")  # 通过id为“kw”的元素定位输入框</code><code>input_box.click()  # 点击输入框</code><code>page.locator("#kw").fill("Playwright")  # 输入“Playwright”</code></pre>
    <p>
     其中前两行代码都是通过 id 为“kw”进行元素定位。
    </p>
    <p>
     在第2行代码
     <code>
      input_box.click()
     </code>
     中，使用的是直接获取赋值后的
     <code>
      input_box
     </code>
     变量进行操作。
    </p>
    <p>
     在第3行代码中，直接通过 id="kw" 属性定位到元素后再进行操作。
    </p>
    <p>
     由此可见，如果我们针对一个元素只需要进行单次操作，可以直接定位并赋予相关操作；但如果我们需要针对一个元素进行多次操作，通过
     <code>
      locator
     </code>
     方法创建一个定位器对象，用于后续的操作更为方便。
    </p>
    <p>
     <strong>
      2、get_by_xxx 快捷方法
     </strong>
    </p>
    <p>
     <code>
      get_by_xxx
     </code>
     方法是 Playwright Python 语言特有的快捷方法。如案例中第10行代码所示：
    </p>
    <pre><code>page.get_by_role("button", name="百度一下").click()#点击查询按钮</code></pre>
    <p>
     这些快捷方法在内部使用
     <code>
      locator
     </code>
     创建定位器，然后执行相应的操作。它们提供了一种更简洁的方式来直接执行操作，而不需要事先创建一个定位器。
    </p>
    <p>
     除了以上案例代码外，常用的
     <code>
      get_by_xxx
     </code>
     方法还包括：
    </p>
    <ul>
     <li>
      <p>
       <code>
        get_by_xpath
       </code>
       ：通过 XPath 定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_css_selector
       </code>
       ：通过 CSS 选择器定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_text
       </code>
       ：通过元素文本内容定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_title
       </code>
       ：通过元素的 title 属性定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_placeholder
       </code>
       ：通过元素的 placeholder 属性定位输入框。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_label
       </code>
       ：通过元素的 label 属性定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_alt_text
       </code>
       ：通过元素的 alt 属性定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_display_value
       </code>
       ：通过元素的 displayValue 属性定位元素。
      </p>
     </li>
     <li>
      <p>
       <code>
        get_by_role
       </code>
       ：通过元素的角色（role)定位元素，例如按钮、链接等。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      二、注意事项
     </strong>
    </p>
    <p>
    </p>
    <ul>
     <li>
      <p>
       确保 URL 正确无误，例如
       <code>
        "https://www.baidu.com/"
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       如果在访问网页时遇到问题，请检查网络连接是否稳定，并确保 URL 的合法性。
      </p>
     </li>
     <li>
      <p>
       在自动化测试中，考虑添加错误处理和日志记录，以便在测试失败时能够追踪问题。
      </p>
     </li>
    </ul>
    <p>
     嗯~
    </p>
    <p>
     <strong>
      你看完啦，这是结束语啦~
     </strong>
    </p>
    <p>
     通过以上介绍，我们可以看到 Playwright 提供了灵活且强大的工具来执行自动化测试。无论是使用
     <code>
      locator
     </code>
     方法还是
     <code>
      get_by_xxx
     </code>
     快捷方法，都可以有效地定位和操作页面元素。
    </p>
    <h2>
     Playwright常用方法介绍
    </h2>
    <p>
     2个实际的示例，展示如何使用 Playwright 进行网页自动化操作，包括导航、鼠标操作、输入框操作、键盘操作以及如何在 iframe 中操作元素。
    </p>
    <p>
     <strong>
      关于网页操作
     </strong>
    </p>
    <p>
     <strong>
      针对网页的常用操作方法
     </strong>
    </p>
    <p>
     page.reload()#刷新当前页面
    </p>
    <p>
     page.go_to(url)  #导航到新的URL地址
    </p>
    <p>
     page.go_back()#回到历史记录中的上一个界面
    </p>
    <p>
     page.go__forward()  #前进到历史记录中的下一个界面
    </p>
    <p>
     print(page.url)#打印当前网址
    </p>
    <p>
     print(page.title())#打印网页标题
    </p>
    <p>
     print(page.context)#刷新
    </p>
    <p>
     <strong>
      实操一下，以下为案例部分
     </strong>
    </p>
    <pre><code>with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)  # 启动浏览器
    page = browser.new_page()
    page.goto('https://www.baidu.com')  # 打开百度
    page.reload()  # 刷新百度页面
    page.goto('https://mail.163.com/')  # 再进入163邮箱地址
    page.go_back()  # 通过回退，回到百度界面
    print(page.url)  # 打印百度网址
    page.go_forward()  # 通过前进，进入到163邮箱界面
    print(page.title())  # 打印163邮箱网页标题
    print(page.context)  # 刷新163邮箱网页</code></pre>
    <p>
     <strong>
      常用的元素方法
     </strong>
    </p>
    <p>
     <strong>
      常用的鼠标操作
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        page.click(selector, options)
       </strong>
       : 点击指定选择器的元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.dblclick(selector, options)
       </strong>
       : 双击指定选择器的元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.right_click(selector, options)
       </strong>
       : 右键点击指定选择器的元素。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.hover(selector, options)
       </strong>
       : 将鼠标悬停在指定选择器的元素上。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.focus(selector, options)
       </strong>
       : 将焦点设置到指定选择器的元素上。这在填写表单或与页面上的可聚焦元素交互时非常有用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.selectOption(selector, values, options)
       </strong>
       : 在
       <code>
        &lt;select&gt;
       </code>
       元素上选择一个或多个选项。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的输入框操作
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        page.fill(selector, text, options)
       </strong>
       : 在指定选择器的输入框中填写文本。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.locator(selector).clear(options)
       </strong>
       : 清除一个输入框或文本区域的当前内容。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.type(selector, text, options)
       </strong>
       : 向指定选择器的元素发送文本输入，这包括处理键盘事件。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的鼠标操作
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        page.press(selector, key, options)
       </strong>
       : 向指定选择器的元素发送一个键盘按键。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.keyboard.type(text, options)
       </strong>
       : 向页面发送一系列键盘按键。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.keyboard.press(key, options)
       </strong>
       : 模拟按下一个特定的键。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.keyboard.down(key, options)
       </strong>
       : 长按键盘上的一个键。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.keyboard.up(key, options)
       </strong>
       : 释放长按的键盘上的一个键。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的打印操作
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        print(page.locator(selector).get_attribute(name))
       </strong>
       : 打印指定选择器的元素的属性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        print(page.locator(selector).get_properties()[name])
       </strong>
       : 打印指定选择器的元素的多个属性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        print(page.locator(selector).text_content())
       </strong>
       : 打印指定选择器的元素的文本内容。
      </p>
     </li>
     <li>
      <p>
       <strong>
        print(page.locator(selector).inner_html())
       </strong>
       : 打印指定选择器的元素的内部 HTML。
      </p>
     </li>
     <li>
      <p>
       <strong>
        print(page.locator(selector).outer_html())
       </strong>
       : 打印指定选择器的元素的外部 HTML。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的frame操作方法
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        frame = page.frame_locator(selector)
       </strong>
       : 获取一个
       <code>
        FrameLocator
       </code>
       对象，用于在 iframe 或 frame 中执行操作。
      </p>
     </li>
     <li>
      <p>
       <strong>
        frame = page.frame_evaluate(expression)
       </strong>
       : 在指定的 frame 中执行 JavaScript 表达式并返回结果。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的截图和PDF操作方法
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        page.screenshot(options)
       </strong>
       : 对当前页面进行屏幕截图。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.pdf(options)
       </strong>
       : 将当前页面保存为 PDF 文件。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的网络操作方法
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        page.wait_for_response(url_or_predicate, options)
       </strong>
       : 等待一个网络响应。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.wait_for_request(url_or_predicate, options)
       </strong>
       : 等待一个网络请求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        page.route(url, handler)
       </strong>
       : 对网络请求进行拦截和修改。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      常用的对话框操作方法
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        page.wait_for_dialog(options)
       </strong>
       : 等待对话框出现。
      </p>
     </li>
     <li>
      <p>
       <strong>
        dialog.accept(options)
       </strong>
       : 接受对话框。
      </p>
     </li>
     <li>
      <p>
       <strong>
        dialog.dismiss(options)
       </strong>
       : 取消对话框。
      </p>
     </li>
     <li>
      <p>
       <strong>
        dialog.value()
       </strong>
       : 获取对话框的值。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      一个常用元素方法示例及代码解释
     </strong>
    </p>
    <pre><code>from playwright.sync_api import sync_playwright
import time

with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)  # 启动浏览器，非无头模式
    page = browser.new_page()
    page.goto('https://mail.163.com/')  # 进入163邮箱登录界面

    page.hover("#lbApp")# 鼠标悬浮至二维码的位置
    frame = page.frame_locator('//html//body//div[3]//div[3]//div[1]//div//div[3]//div[1]//div[2]//iframe')#切换至输入框所在的frame内
    email_box=frame.get_by_placeholder('邮箱账号或手机号码')
    email_box.fill('1111')#点击并输入邮箱地址
    email_box.dblclick()# 双击邮箱账号输入框
    email_box.focus()#焦点转移至邮箱账号输入框

    #模拟剪切操作 Ctrl + X
    page.keyboard.down('Control')  # 按下 Control 键
    email_box.press('x')  # 按下 'x' 键
    page.keyboard.up('Control')  # 释放 Control 键

    # 模拟剪切操作 Ctrl + V
    page.keyboard.down('Control')  # 按下 Control 键
    email_box.press('V')  # 按下 'x' 键
    page.keyboard.up('Control')  # 释放 Control 键

    #输入密码
    frame.get_by_placeholder('输入密码').first.fill('2222')

    # 打印登录元素的class属性
    print(frame.locator("#dologin").get_attribute('class'))

    #等待3秒
    time.sleep(3)
    browser.close()  # 关闭浏览器</code></pre>
    <p>
     <strong>
      代码解释
     </strong>
    </p>
    <ol>
     <li>
      <p>
       启动浏览器：
       <code>
        p.chromium.launch(headless=False)
       </code>
       启动一个 Chromium 浏览器实例，
       <code>
        headless=False
       </code>
       表示以有头模式运行，这样可以直观地看到操作过程。
      </p>
     </li>
     <li>
      <p>
       打开网页：
       <code>
        page.goto('https://www.baidu.com')
       </code>
       打开百度的首页。
      </p>
     </li>
     <li>
      <p>
       刷新页面：
       <code>
        page.reload()
       </code>
       刷新当前页面。
      </p>
     </li>
     <li>
      <p>
       导航操作：
      </p>
      <ul>
       <li>
        <p>
         <code>
          page.goto('https://mail.163.com')
         </code>
         跳转到 163 邮箱登录页面。
        </p>
       </li>
       <li>
        <p>
         <code>
          page.go_back()
         </code>
         回退到历史记录中的上一个页面（百度首页）。
        </p>
       </li>
       <li>
        <p>
         <code>
          page.go_forward()
         </code>
         前进到历史记录中的下一个页面（163 邮箱登录页面）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       打印信息：
      </p>
      <ul>
       <li>
        <p>
         <code>
          print(page.url)
         </code>
         打印当前页面的 URL。
        </p>
       </li>
       <li>
        <p>
         <code>
          print(page.title())
         </code>
         打印当前页面的标题。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       鼠标操作：
      </p>
      <ul>
       <li>
        <p>
         <code>
          page.hover("#lbApp")
         </code>
         将鼠标悬停在指定元素上。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       切换 iframe：
       <code>
        frame = page.frame_locator('xpath=//iframe[@id="login-frame"]')
       </code>
       切换到包含登录表单的 iframe。
      </p>
     </li>
     <li>
      <p>
       输入框操作：
      </p>
      <ul>
       <li>
        <p>
         <code>
          email_box.fill('1111')
         </code>
         在邮箱输入框中填入账号。
        </p>
       </li>
       <li>
        <p>
         <code>
          email_box.dblclick()
         </code>
         双击邮箱账号输入框。
        </p>
       </li>
       <li>
        <p>
         <code>
          email_box.focus()
         </code>
         将焦点设置到邮箱账号输入框。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       键盘操作：
      </p>
      <ul>
       <li>
        <p>
         模拟 Ctrl + X 剪切操作。
        </p>
       </li>
       <li>
        <p>
         模拟 Ctrl + V 粘贴操作。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       输入密码：
       <code>
        frame.get_by_placeholder('输入密码').first.fill('2222')
       </code>
       在密码输入框中填入密码。
      </p>
     </li>
     <li>
      <p>
       打印属性：
       <code>
        print(frame.locator("#dologin").get_attribute('class'))
       </code>
       打印登录按钮的 class 属性。
      </p>
     </li>
     <li>
      <p>
       点击登录：
       <code>
        frame.locator("#dologin").click()
       </code>
       点击登录按钮。
      </p>
     </li>
     <li>
      <p>
       等待页面加载：
       <code>
        time.sleep(3)
       </code>
       等待 3 秒，确保页面加载完成。
      </p>
     </li>
     <li>
      <p>
       关闭浏览器：
       <code>
        browser.close()
       </code>
       关闭浏览器实例。
      </p>
     </li>
    </ol>
    <p>
     <strong>
      最后
     </strong>
    </p>
    <p>
     通过这个示例，我们可以看到 Playwright 提供了灵活且强大的工具来执行自动化测试。无论是模拟键盘操作还是处理 iframe，Playwright 都能轻松应对。希望这个示例能帮助你更好地理解和使用 Playwright 进行自动化测试。
    </p>
    <h2>
     Playwright常用的上下文管理器介绍
    </h2>
    <p>
     介绍 Playwright 中的常用上下文管理器及其应用场景，包括浏览器实例的创建与销毁、新页面的创建、新标签页的获取、对话框的处理、页面导航的等待、文件下载的监控、截图和视频操作等。
    </p>
    <p>
     <strong>
      常用的上下文管理器介绍
     </strong>
    </p>
    <p>
     <strong>
      创建和销毁浏览器实例：sync_playwright()
     </strong>
    </p>
    <p>
     sync_playwright()作为最顶层的上下文管理器，用于创建和销毁Playwright的浏览器实例，它管理脚本的整个生命周期，是最常用的上下文管理器，一般和browser.new_context()搭配使用。
    </p>
    <p>
     <strong>
      创建新的浏览器上下文：browser.new_context()
     </strong>
    </p>
    <p>
     浏览器上下文是浏览器会话隔离环境，可以包含多个页面，确保页面之间的隔离。
    </p>
    <h4>
     <strong>
      以上两者的使用场景
     </strong>
    </h4>
    <p>
     在 Playwright 中，
     <code>
      sync_playwright()
     </code>
     和
     <code>
      browser.new_context()
     </code>
     是基础的上下文管理器，它们提供了测试环境的初始化和浏览器上下文的创建。其他的上下文管理器，如
     <code>
      expect_page()
     </code>
     、
     <code>
      expect_popup()
     </code>
     、
     <code>
      expect_navigation()
     </code>
     等，都是在这两个基础上使用的。
    </p>
    <p>
     <strong>
      举例：
     </strong>
     启动浏览器并创建页面
    </p>
    <pre><code>with sync_playwright() as p:#最顶层的上下文管理器</code><code>  browser = p.chromium.launch(headless=False)  # 启动浏览器，非无头模式</code><code>  context = browser.new_context()  # 在新的浏览器上下文创建页面</code>
</pre>
    <p>
     <strong>
      创建新界面：browser.new_page()
     </strong>
    </p>
    <p>
     browser.new_page()可以在指定的浏览器上下文中创建一个新的页面。
    </p>
    <p>
     <strong>
      使用场景
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       当需要打开一个新的标签页进行操作时。
      </p>
     </li>
     <li>
      <p>
       在需要并行处理多个页面或测试多个独立页面的场景中。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      举例：
     </strong>
     打开百度​​​​​​​
    </p>
    <pre><code>with sync_playwright() as p:#最顶层的上下文管理器</code><code>  browser = p.chromium.launch(headless=False)  # 启动浏览器，非无头模式</code><code>  context = browser.new_context()  # 在新的浏览器上下文管理器中创建页面</code><code>  </code><code>  #--------------------以下是新增代码-----------------------------------------------</code><code>  page = browser.new_page()#在新的页面执行操作  page.goto('https://www.zhibo8.com/')#在新的界面打开网页</code>
</pre>
    <p>
     <strong>
      获取新界面：context.expect_page()
     </strong>
    </p>
    <p>
     context.expect_page()可以等待和获取当前页面操作触发的新页面。
    </p>
    <p>
     <strong>
      使用场景
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       当点击链接或按钮后需要处理新打开的标签页时。
      </p>
     </li>
     <li>
      <p>
       在测试需要打开多个标签页并与之交互的功能时。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      举例：
     </strong>
     获取通过点击界面元素产生的新界面并执行操作​​​​​​​
    </p>
    <pre><code>with sync_playwright() as p:#最顶层的上下文管理器</code><code>  browser = p.chromium.launch(headless=False)  # 启动浏览器，非无头模式</code><code>  context = browser.new_context()  # 在新的浏览器上下文管理器中创建页面</code><code>  page = browser.new_page()#在新的页面执行操作</code><code>  page.goto('https://www.zhibo8.com/')#在新的界面打开网页</code><code>  </code><code>  #--------------------以下是新增代码-----------------------------------------------</code><code>  with context.expect_page() as new_page_info:</code><code>    page.get_by_role('link', name='个人').first.click() #使用 first 方法选择第一个匹配的元素。</code><code>    </code><code>    new_page=new_page_info.value#给新的界面赋到new_page</code><code>    new_page.get_by_role('link',name='已购方案').click()#针对新界面进行操作</code>
</pre>
    <p>
     <strong>
      弹出框：expect_popup()
     </strong>
    </p>
    <p>
     expect_popup()上下文管理器用于处理页面上的弹出窗口（如新标签页或新窗口）。当你准备打开一个新窗口或者标签页时，这个上下文管理器可以捕获这个新打开的页面
    </p>
    <h4>
     <strong>
      使用场景
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        打开新窗口或标签页
       </strong>
       ：当网页上打开新的浏览器窗口或标签页时， expect_popup()可用于等待和获取这个新打开的窗口。
      </p>
     </li>
     <li>
      <p>
       <strong>
        表单提交
       </strong>
       ：在表单提交后，如果网页是通过
       <code>
        target="_blank"
       </code>
       打开新页面来显示结果，expect_popup()可用于等待新页面的出现。
      </p>
     </li>
     <li>
      <p>
       <strong>
        广告或宣传窗口
       </strong>
       ：当网页打开广告或宣传的新窗口时，expect_popup()可用于测试这些窗口是否按预期出现。
      </p>
     </li>
     <li>
      <p>
       <strong>
        打印或下载页面
       </strong>
       ：点击打印或下载链接时，
       <code>
        expect_popup()
       </code>
       可用于验证新窗口的行为。
      </p>
     </li>
     <li>
      <p>
       <strong>
        测试弹窗应用
       </strong>
       ：测试弹窗的显示和功能。
      </p>
      <p>
      </p>
     </li>
    </ol>
    <p>
     <strong>
      举例：
     </strong>
     在弹窗中输入文本操作
    </p>
    <pre><code>with page.expect_popup() as popup_info:</code><code>    page.click('a#open-popup-link')  # 点击一个打开新标签页的链接，预计会触发弹窗</code><code>popup = popup_info.value</code><code>if popup:</code><code>    popup.fill('input[name="name"]', 'Playwright')#在弹窗中输入Playwright</code><code>    popup.click('button#submit')#关闭弹窗</code>
</pre>
    <p>
     <strong>
      对话框：expect_dialog()
     </strong>
    </p>
    <p>
     用于处理 JavaScript 产生的对话框，如
     <code>
      alert
     </code>
     、
     <code>
      confirm
     </code>
     和
     <code>
      prompt
     </code>
     。
    </p>
    <p>
     当你点击一个链接或提交表单后，需要通过浏览器加载新页面来完成操作的情况下，expect_navigation() 上下文管理器可以确保新的页面已经加载完成，再继续执行后面的代码，这样可以避免脚本和加载状态不同步的问题。
    </p>
    <p>
     <strong>
      使用场景
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        验证警告
       </strong>
       ：验证测试网页上的警告消息是否正确显示。
      </p>
     </li>
     <li>
      <p>
       <strong>
        确认操作
       </strong>
       ：测试用户确认操作（如删除操作）是否按预期工作。
      </p>
     </li>
     <li>
      <p>
       <strong>
        输入信息
       </strong>
       ：在需要用户输入的对话框中自动填写信息。
      </p>
     </li>
    </ol>
    <p>
     <strong>
      举例：
     </strong>
     在对话框中输入文本​​​​​​​
    </p>
    <pre><code>with page.expect_dialog() as dialog_info:</code><code>    page.click('button#open-alert')  # 点击一个打开 alert 对话框的按钮</code><code>dialog = dialog_info.value</code><code>if dialog:</code><code>    dialog.accept("晚上好!有点困！")  # 在对话框中输入文本</code>
</pre>
    <p>
     <strong>
      下载：expect_download()
     </strong>
    </p>
    <p>
     <code>
      expect_download()
     </code>
     上下文管理器用于处理通过模拟用户操作（如点击链接）触发的文件下载。
    </p>
    <p>
     <strong>
      使用场景
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       需要测试网站的下载功能时，如下载文件或文档。
      </p>
     </li>
     <li>
      <p>
       在自动化测试中验证下载链接是否正确工作。
      </p>
     </li>
     <li>
      <p>
       需要捕获和验证下载的文件名、大小、类型等属性。
      </p>
     </li>
    </ul>
    <p>
     <strong>
      举例：
     </strong>
     下载文件
    </p>
    <pre><code>with sync_playwright()as p:
    browser = p.chromium.launch(headless=False)
    page = browser.new_page()
    page.goto("https://baidu.com")
   
with page.expect_download()as download_info: 
        page.click("a#download-link")# 假装这是下载链接
    download = download_info.value
if download:</code>
<code>print(f"下载文件：{download.url}")
print(f"保存路径：{download.path}")
print(f"文件名：{download.suggested_filename}")
# 后续可以添加断言或其他验证逻辑
    browser.close()</code>
</pre>
    <p>
     <strong>
      截图：expect_screenshot()
     </strong>
    </p>
    <p>
     expect_screenshot（）上下文管理器可用于执行截图操作前后的一些额外的逻辑，比如验证截图是否成功。
    </p>
    <p>
     <strong>
      使用场景：
     </strong>
     一般用于获取截图的结果或进行断言。
    </p>
    <p>
     <strong>
      举例：
     </strong>
     截图操作​​​​​​​
    </p>
    <pre><code>with page.expect_screenshot()as screenshot_info:</code><code>    #调用page.expect_screenshot触发截图操作</code><code>    page.screenshot()</code>
</pre>
    <p>
     <strong>
      截图：expect_video()
     </strong>
    </p>
    <p>
     expect_video()用于页面上的视频元素进行操作，确保视频元素已经存在于页面上，并且可以进行相关操作，如播放、暂停或检查视频属性。
    </p>
    <h3>
     <strong>
      使用场景
     </strong>
    </h3>
    <p>
     <strong>
      视频播放：
     </strong>
     测试网页上的视频是否能够正确加载和播放。
    </p>
    <p>
     <strong>
      媒体内容测试：
     </strong>
     验证视频媒体内容是否按预期工作，例如自动播放、静音等。
    </p>
    <p>
     <strong>
      视频控件测试：
     </strong>
     测试视频播放控件（如播放/暂停按钮、进度条）是否正常工作。
    </p>
    <p>
     <strong>
      广告验证：
     </strong>
     验证视频广告是否按预期显示和行为。
    </p>
    <p>
     <strong>
      举例：
     </strong>
     针对网页视频进行播放操作
    </p>
    <pre><code>with page.expect_video() as video_info:</code><code>        page.click('#id4')#触发视频播放按钮</code>
<code>        #获取视频元素信息</code><code>        video=video_info.value</code><code>        if video:</code><code>            print('视频已经准备就绪，可以播放')</code><code>            #下面可以进一步检查视频操作，比如视频时长、状态等。</code><code>            duration = video.duration()</code><code>            print(f'视频时长：{duration}秒')</code><code>        browser.close()</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34363238313531382f:61727469636c652f64657461696c732f313436313839343639" class_="artid" style="display:none">
 </p>
</div>


