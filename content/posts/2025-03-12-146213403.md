---
layout: post
title: "缓存的双写一致性实现方案"
date: 2025-03-12 19:53:02 +0800
description: "的数据，在 Redis 作为缓存的情况下，保证 Redis 和数据库数据的一致性，可以选择。：数据读取多、实时性要求不高的场景（比如商品详情、用户信息等）。❌ 如果 Redis 更新失败，可能导致缓存和数据库数据不一致。✅ 避免缓存和数据库数据不一致的问题（先删缓存）。✅ 读性能高，数据实时同步，减少不一致问题。，减少数据库压力（因为数据库只需批量写入）。的业务场景，能有效减少数据库压力。的场景，如日志收集、订单队列等。，不适用于实时性要求高的业务。，对一致性要求高的场景。，增加了写操作的延迟。"
keywords: "缓存的双写一致性实现方案"
categories: ['未分类']
tags: ['Java']
artid: "146213403"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146213403
    alt: "缓存的双写一致性实现方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146213403
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146213403
cover: https://bing.ee123.net/img/rand?artid=146213403
image: https://bing.ee123.net/img/rand?artid=146213403
img: https://bing.ee123.net/img/rand?artid=146213403
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     缓存的双写一致性实现方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     对于
     <strong>
      实时性要求不高
     </strong>
     的数据，在 Redis 作为缓存的情况下，保证 Redis 和数据库数据的一致性，可以选择
     <strong>
      缓存更新策略
     </strong>
     ，常见的方案包括：
    </p>
    <h3>
     <strong>
      1. Cache Aside（旁路缓存，推荐）
     </strong>
    </h3>
    <p>
     <strong>
      适用场景
     </strong>
     ：数据读取多、实时性要求不高的场景（比如商品详情、用户信息等）。
    </p>
    <h4>
     <strong>
      工作流程
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       查询数据
      </strong>
      ：
      <ul>
       <li>
        先查 Redis，如果缓存命中，直接返回。
       </li>
       <li>
        如果缓存未命中（Cache Miss），则查询数据库。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       更新缓存
      </strong>
      ：
      <ul>
       <li>
        将数据库查询结果写入 Redis，并设置过期时间（TTL）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       修改数据
      </strong>
      ：
      <ul>
       <li>
        先更新数据库，再
        <strong>
         删除 Redis 缓存
        </strong>
        （而不是直接更新 Redis）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       下次查询
      </strong>
      ：
      <ul>
       <li>
        由于缓存被删除，下一次请求会触发数据库查询，并重新写入缓存。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <strong>
      为什么删除缓存而不是更新缓存？
     </strong>
    </h4>
    <ul>
     <li>
      数据库和 Redis
      <strong>
       更新非原子
      </strong>
      ，可能导致
      <strong>
       缓存和数据库数据不一致
      </strong>
      。
     </li>
     <li>
      <strong>
       延迟双删策略
      </strong>
      ：
      <ul>
       <li>
        <strong>
         第一次删除缓存
        </strong>
        （更新数据库后）。
       </li>
       <li>
        <strong>
         短暂延迟（如 500ms）后，再次删除缓存
        </strong>
        ，确保高并发场景下缓存不会被旧值回写。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      示例代码
     </strong>
    </h4>
    <pre><code>// 读取数据
public String getDataFromCache(Long id) {
    String key = "data:" + id;
    String value = redisTemplate.opsForValue().get(key);
    
    if (value != null) {
        return value; // 直接返回缓存数据
    }
    
    // 缓存未命中，查询数据库
    value = database.queryById(id);
    
    // 写入 Redis，并设置过期时间
    redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(10));
    
    return value;
}

// 更新数据
public void updateData(Long id, String newValue) {
    // 先更新数据库
    database.updateById(id, newValue);
    
    // 删除 Redis 缓存
    redisTemplate.delete("data:" + id);

    // 延迟 500ms 再次删除，防止并发问题
    new Timer().schedule(new TimerTask() {
        @Override
        public void run() {
            redisTemplate.delete("data:" + id);
        }
    }, 500);
}
</code></pre>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <p>
     ✅ 适用于
     <strong>
      读多写少
     </strong>
     的业务场景，能有效减少数据库压力。
     <br/>
     ✅ 避免缓存和数据库数据不一致的问题（先删缓存）。
     <br/>
     ✅ 结合
     <strong>
      延迟双删
     </strong>
     策略，在高并发情况下也能减少不一致。
    </p>
    <hr/>
    <h3>
     <strong>
      2. Write Through（写穿透）
     </strong>
    </h3>
    <p>
     <strong>
      适用场景
     </strong>
     ：
     <strong>
      读写比例均衡
     </strong>
     ，对一致性要求高的场景。
    </p>
    <h4>
     <strong>
      工作流程
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       写入数据时
      </strong>
      ：
      <ul>
       <li>
        先写入数据库，然后
        <strong>
         同步更新 Redis
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       读取数据时
      </strong>
      ：
      <ul>
       <li>
        直接从 Redis 读取数据，不需要查询数据库。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <strong>
      示例代码
     </strong>
    </h4>
    <pre><code>public void updateData(Long id, String newValue) {
    // 先更新数据库
    database.updateById(id, newValue);
    
    // 同步更新 Redis
    redisTemplate.opsForValue().set("data:" + id, newValue, Duration.ofMinutes(10));
}
</code></pre>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <p>
     ✅ 读性能高，数据实时同步，减少不一致问题。
     <br/>
     ✅ 适用于
     <strong>
      读写并发均衡的业务
     </strong>
     （如用户状态、账户余额）。
    </p>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <p>
     ❌ 写入数据时，
     <strong>
      Redis 也要同步更新
     </strong>
     ，增加了写操作的延迟。
     <br/>
     ❌ 如果 Redis 更新失败，可能导致缓存和数据库数据不一致。
    </p>
    <hr/>
    <h3>
     <strong>
      3. Write Behind（异步写回，适用于高吞吐写入场景）
     </strong>
    </h3>
    <p>
     <strong>
      适用场景
     </strong>
     ：
     <strong>
      写入频繁、对数据实时性要求不高
     </strong>
     的场景，如日志收集、订单队列等。
    </p>
    <h4>
     <strong>
      工作流程
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       数据先写入 Redis
      </strong>
      （不会立刻写数据库）。
     </li>
     <li>
      <strong>
       后台异步任务
      </strong>
      （定时任务、MQ 消费者等）
      <strong>
       批量更新数据库
      </strong>
      。
     </li>
     <li>
      <strong>
       当 Redis 数据过期或容量不足时
      </strong>
      ，需要持久化到数据库。
     </li>
    </ol>
    <h4>
     <strong>
      示例代码
     </strong>
    </h4>
    <pre><code>public void writeData(Long id, String newValue) {
    // 先写入 Redis
    redisTemplate.opsForValue().set("data:" + id, newValue);
    
    // 记录变更到队列
    messageQueue.send("update-db", id);
}

// 定时任务（或 MQ 消费者）批量更新数据库
@Scheduled(fixedRate = 5000)
public void batchUpdateDatabase() {
    List&lt;Long&gt; ids = messageQueue.receive("update-db");
    if (!ids.isEmpty()) {
        database.batchUpdate(ids);
    }
}
</code></pre>
    <h4>
     <strong>
      优点
     </strong>
    </h4>
    <p>
     ✅
     <strong>
      高吞吐写入
     </strong>
     ，减少数据库压力（因为数据库只需批量写入）。
     <br/>
     ✅ 适用于
     <strong>
      日志、订单、点击数据等高并发写入的业务
     </strong>
     。
    </p>
    <h4>
     <strong>
      缺点
     </strong>
    </h4>
    <p>
     ❌ 数据持久化到数据库有
     <strong>
      延迟
     </strong>
     ，不适用于实时性要求高的业务。
     <br/>
     ❌ 断电或 Redis 故障可能导致数据丢失，需要配合
     <strong>
      持久化方案
     </strong>
     （AOF、RDB、MQ）。
    </p>
    <hr/>
    <h3>
     <strong>
      4. 总结
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        方案
       </th>
       <th>
        适用场景
       </th>
       <th>
        一致性
       </th>
       <th>
        读性能
       </th>
       <th>
        写性能
       </th>
       <th>
        复杂度
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         Cache Aside（推荐）
        </strong>
       </td>
       <td>
        读多写少，数据实时性要求不高（如商品详情）
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        ⭐⭐
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Write Through
        </strong>
       </td>
       <td>
        读写比例均衡，数据一致性要求高（如用户状态）
       </td>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        ⭐⭐
       </td>
       <td>
        ⭐⭐
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Write Behind
        </strong>
       </td>
       <td>
        写多读少，允许短时间数据延迟（如日志、订单）
       </td>
       <td>
        ⭐⭐
       </td>
       <td>
        ⭐⭐⭐
       </td>
       <td>
        ⭐⭐⭐⭐
       </td>
       <td>
        ⭐⭐⭐
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     🚀
     <strong>
      推荐方案
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       绝大多数场景
      </strong>
      ：使用
      <strong>
       Cache Aside（旁路缓存）
      </strong>
      ，加上
      <strong>
       延迟双删
      </strong>
      策略。
     </li>
     <li>
      <strong>
       一致性要求高的业务
      </strong>
      （如账户余额、权限管理）：使用
      <strong>
       Write Through
      </strong>
      。
     </li>
     <li>
      <strong>
       高写入吞吐场景
      </strong>
      （日志、订单流式数据）：使用
      <strong>
       Write Behind
      </strong>
      +
      <strong>
       消息队列
      </strong>
      。
     </li>
    </ul>
    <p>
     这样可以在
     <strong>
      性能和一致性之间找到平衡！
     </strong>
     🎯
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393635323439302f:61727469636c652f64657461696c732f313436323133343033" class_="artid" style="display:none">
 </p>
</div>


