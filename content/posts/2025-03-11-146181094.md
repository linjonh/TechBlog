---
layout: post
title: "JAVA字符串与正则表达式"
date: 2025-03-11 16:50:00 +0800
description: "1、String在java源码中是怎么实现的？2、什么是正则表达式的DFA自动机和NFA自动机？"
keywords: "JAVA字符串与正则表达式"
categories: ['未分类']
tags: ['正则表达式', 'Java']
artid: "146181094"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146181094
    alt: "JAVA字符串与正则表达式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146181094
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146181094
cover: https://bing.ee123.net/img/rand?artid=146181094
image: https://bing.ee123.net/img/rand?artid=146181094
img: https://bing.ee123.net/img/rand?artid=146181094
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JAVA字符串与正则表达式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     写在前面
    </h2>
    <p>
     1、String在java源码中是怎么实现的？
     <br/>
     2、什么是正则表达式的DFA自动机和NFA自动机？
    </p>
    <h3>
     <a id="1String_5">
     </a>
     1、String
    </h3>
    <h4>
     <a id="11String_6">
     </a>
     1.1、String底层实现
    </h4>
    <p>
     Java 6及以前版本，通过char数组，每个char占用两个字节，使得String能够很好地处理Unicode。
    </p>
    <pre><code class="prism language-bash">public final class String implements java.io.Serializable, Comparable<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span>, CharSequence <span class="token punctuation">{<!-- --></span>  
    private final char<span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>  
    private int offset<span class="token punctuation">;</span>  
    private int count<span class="token punctuation">;</span>  
    // <span class="token punctuation">..</span>.其他成员和方法  
<span class="token punctuation">}</span>  
</code></pre>
    <p>
     Java 7至Java 8版本，offset和count两个变量被移除，String.substring不再共享char[]，解决内存可能泄漏问题。
    </p>
    <pre><code class="prism language-bash">public final class String implements java.io.Serializable, Comparable<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span>, CharSequence <span class="token punctuation">{<!-- --></span>  
    private final char<span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>  
    // <span class="token punctuation">..</span>.其他成员和方法  
<span class="token punctuation">}</span>  
</code></pre>
    <p>
     Java9开始，把char[]改成了byte[] + coder(编码标识)
    </p>
    <h4>
     <a id="12strabcnew_Stringabc_27">
     </a>
     1.2、str="abc"和new String(“abc”)的区别
    </h4>
    <ul>
     <li>
      str=“abc”
      <br/>
      会先检查"abc"在不在常量池，在就不创建了，直接拿引用
     </li>
     <li>
      new String(“abc”)
      <br/>
      先将”abc“放入常量池，再将其引用传给new的String
     </li>
    </ul>
    <h4>
     <a id="13_33">
     </a>
     1.3、使用+拼接字符串
    </h4>
    <p>
     使用+拼接字符串，代码编译后，会被替换成StringBuilder。并且每+的一个字符串都可能被new一个新的StringBuilder，所以建议少用+，直接用StringBuilder
    </p>
    <h4>
     <a id="14Stringintern_36">
     </a>
     1.4、如何使用String.intern节约内存
    </h4>
    <p>
     String a = new String(“a123”).intern();
     <br/>
     当调用intern()时，会先查看常量池中是否已有字符串”a123“, 所以当多次用到”a123“时，使用String.intern不会再创建新的字符串，从而节约内存。
    </p>
    <h4>
     <a id="15splitindexOf_40">
     </a>
     1.5、分割字符，split()和indexOf()用哪个
    </h4>
    <p>
     split()使用正则表达式实现，正则表达式性能是比较不稳定的。
     <br/>
     indexOf()能分割时尽量用indexOf()
    </p>
    <h3>
     <a id="2_44">
     </a>
     2、正则表达式
    </h3>
    <h4>
     <a id="21DFANFA_45">
     </a>
     2.1、DFA和NFA
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        正则表达式引擎
       </th>
       <th>
        构造代价
       </th>
       <th>
        执行效率
       </th>
       <th>
        优势
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        NFA
       </td>
       <td>
        小
       </td>
       <td>
        低
       </td>
       <td>
        支持更多，如group、环视、占有有限量词
       </td>
      </tr>
      <tr>
       <td>
        DFA
       </td>
       <td>
        大
       </td>
       <td>
        高
       </td>
       <td>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     NFA 自动机回溯
    </p>
    <pre><code class="prism language-bash">str <span class="token operator">=</span> <span class="token string">"arrrc"</span>
reg <span class="token operator">=</span> <span class="token string">"ar{1,3}c"</span>

自动回溯会先匹配arrr,匹配到c,发现不是r,就回溯到最后一个r,用reg的c去继续匹配
</code></pre>
    <h4>
     <a id="22_61">
     </a>
     2.2、怎么减少回溯?
    </h4>
    <p>
     1、贪婪模式
     <br/>
     如上述例子就是贪婪模式
     <br/>
     2、懒惰模式
    </p>
    <pre><code class="prism language-bash">str <span class="token operator">=</span> <span class="token string">"arrrc"</span>
reg <span class="token operator">=</span> <span class="token string">"ar{1,3}?c"</span>

懒惰模式会先匹配ar,发现已经有一个r了,就开始用c接着匹配
</code></pre>
    <p>
     3、独占模式
    </p>
    <pre><code class="prism language-bash">str <span class="token operator">=</span> <span class="token string">"arrc"</span>
reg <span class="token operator">=</span> <span class="token string">"ar{1,3}+rc"</span>

独占模式会先匹配ar,发现已经有一个r了,就开始用rc接着匹配,不会回溯
</code></pre>
    <p>
     下面这种独占模式会回溯
    </p>
    <pre><code class="prism language-bash">str <span class="token operator">=</span> <span class="token string">"arrc"</span>
reg <span class="token operator">=</span> <span class="token string">"ar{1,3}+c"</span>

独占模式会先匹配ar,发现已经有一个r了,就开始用c接着匹配,匹配失败回溯
</code></pre>
    <p>
     总结：
     <br/>
     1、少用贪婪模式，多用独占模式
     <br/>
     2、减少分支选择，如将”(abcd|abef)“替换为”ab(cd|ef)“
     <br/>
     3、减少捕获嵌套。
     <br/>
     捕获组： 一个 （）里面的就是一个不获取
     <br/>
     非捕获组：一个（?:EXP）就是一个非捕获组
    </p>
    <pre><code class="prism language-bash">str <span class="token operator">=</span> <span class="token string">"&lt;input id=1&gt;文本&lt;/input&gt;"</span>
reg <span class="token operator">=</span> <span class="token string">"(&lt;input.*?)(.*?)(&lt;/input)"</span>
<span class="token comment"># 上面reg包含了3个捕获组，所以如果输出捕获结果会有整个匹配到的内容+括号里面的，4组字符串</span>

str <span class="token operator">=</span> <span class="token string">"&lt;input id=1&gt;文本&lt;/input&gt;"</span>
reg <span class="token operator">=</span> <span class="token string">"(?:&lt;input.*?)(.*?)(?:&lt;/input)"</span>
<span class="token comment"># 上面reg包含了1个捕获组，所以如果输出捕获结果会有整个匹配到的内容+捕获组括号里面的，2组字符串</span>
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f615f5f696e745f5f2f:61727469636c652f64657461696c732f313436313831303934" class_="artid" style="display:none">
 </p>
</div>


