---
arturl_encode: "6874747073:3a2f2f626c6f672e6373646e2e6e65742f7879683031323135:2f61727469636c652f64657461696c732f3136383432333335"
layout: post
title: "Gstreamer的音视频同步-."
date: 2025-01-02 13:47:11 +0800
description: "一 概述    Gstreamer的音频视频同步，概括起来是一个比较大的问题，因为在网上可以看到很多"
keywords: "gstreamer音视频同步"
categories: ['Linux', 'Gstreamer']
tags: ['无标签']
artid: "16842335"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=16842335
    alt: "Gstreamer的音视频同步-."
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=16842335
featuredImagePreview: https://bing.ee123.net/img/rand?artid=16842335
---

# Gstreamer的音视频同步 .

一 概述

Gstreamer的音频视频同步，概括起来是一个比较大的问题，因为在网上可以看到很多音视频同步的办法。这里我们只看最普通的一种。以音频时钟做为参考时钟(要求参考时钟上的时间是线性递增的)；生成数据流时依据参考时钟上的时间给每个数据块都打上时间戳(一般包括开始时间和结束时间)；在播放时，读取数据上的时间戳，同时参考当前参考时钟上的时间来安排播放(如果数据块上的时间大于参考时钟的时间，则不急于播放，直到参考时钟达到数据块的开始时间；如果数据块上的时间小于参考时钟的时间，则应"尽快"播放或者干脆"丢弃"该数据块，以使得播放赶上播放进度。)

Gstreamer的音视频分离器如下图：

demux element将音频，视频分离后，给各自的解码器进行解码播放。

**[cpp]**
[view plain](http://blog.csdn.net/maeom/article/details/7729840# "view plain")
[copy](http://blog.csdn.net/maeom/article/details/7729840# "copy")
[print](http://blog.csdn.net/maeom/article/details/7729840# "print")
[?](http://blog.csdn.net/maeom/article/details/7729840# "?")

1. +-----------+
2. |   Audio   |
3. +--|           |
4. /   +-----------+
5. +----------+ /
6. |  demux   |/
7. |          |\
8. +----------+ \
9. \   +-----------+
10. +--|   Video   |
11. |           |
12. +-----------+

二  提供时钟

默认情况下，是有AudioSink来提供参考时钟的。下面开始代码之旅。

**[cpp]**
[view plain](http://blog.csdn.net/maeom/article/details/7729840# "view plain")
[copy](http://blog.csdn.net/maeom/article/details/7729840# "copy")
[print](http://blog.csdn.net/maeom/article/details/7729840# "print")
[?](http://blog.csdn.net/maeom/article/details/7729840# "?")

1. /\* gst-plugins-base-0.10.32/gst-libs/gst/audio/gstbaseaudiosink.c \*/
2. /\*默认的情况下是由这个element来提供clock的。\*/
3. #define DEFAULT\_PROVIDE\_CLOCK   TRUE
5. static

   void
6. gst\_base\_audio\_sink\_init (GstBaseAudioSink \* baseaudiosink,
7. GstBaseAudioSinkClass \* g\_class)
8. {
9. baseaudiosink->provide\_clock = DEFAULT\_PROVIDE\_CLOCK
10. /\* 这里在clock类里面新建了一个时钟 \*/
11. baseaudiosink->provided\_clock = gst\_audio\_clock\_new (
    "GstAudioSinkClock"
    ,
12. (GstAudioClockGetTimeFunc) gst\_base\_audio\_sink\_get\_time, baseaudiosink);
13. }
15. /\*
16. \* 查询是否 @sink 将提供 clock
17. \*/
18. gboolean
19. gst\_base\_audio\_sink\_get\_provide\_clock (GstBaseAudioSink \* sink)
20. {
21. gboolean result;
22. result = sink->provide\_clock;
23. return
    result;
24. }
26. /\* 查询clock的时间
27. \* 如果将这里的返回结果变慢，那么视频播放就会变慢。当然视频很音频就不同步了。
28. \*/
29. static
    GstClockTime
30. gst\_base\_audio\_sink\_get\_time (GstClock \* clock, GstBaseAudioSink \* sink)
31. {
32. result = gst\_util\_uint64\_scale\_int (samples, GST\_SECOND,
33. sink->ringbuffer->spec.rate);
34. return
    result;
35. }

三 视频如何同步？

以我实验的视频为例，视频使用的是xvimagesink element它的继承关系如下

**[cpp]**
[view plain](http://blog.csdn.net/maeom/article/details/7729840# "view plain")
[copy](http://blog.csdn.net/maeom/article/details/7729840# "copy")
[print](http://blog.csdn.net/maeom/article/details/7729840# "print")
[?](http://blog.csdn.net/maeom/article/details/7729840# "?")

1. GObject
2. +----GstObject
3. +----GstElement
4. +----GstBaseSink
5. +----GstVideoSink
6. +----GstXvImageSink

从element的chain func开始(PS: 为什么从chain开始，参考[Gstreamer初见]).
  

**[cpp]**
[view plain](http://blog.csdn.net/maeom/article/details/7729840# "view plain")
[copy](http://blog.csdn.net/maeom/article/details/7729840# "copy")
[print](http://blog.csdn.net/maeom/article/details/7729840# "print")
[?](http://blog.csdn.net/maeom/article/details/7729840# "?")

1. /\*
2. \* gst-plugins-base/sys/xvimage/xvimagesink.c
3. \* gst-plugins-base/gst-libs/gst/video/gstvideosink.c
4. \* 这两个文件里都没有chain函数.
5. \* 在gstreamer-0.10.32/libs/gst/base/gstbasesink.c中 chain函数为
6. \*/
7. static
   GstFlowReturn
8. gst\_base\_sink\_chain (GstPad \* pad, GstBuffer \* buf)
9. {
10. basesink = GST\_BASE\_SINK (GST\_OBJECT\_PARENT (pad));
12. return
    gst\_base\_sink\_chain\_main (basesink, pad, \_PR\_IS\_BUFFER, buf);
13. }
15. static
    GstFlowReturn
16. gst\_base\_sink\_chain\_main (GstBaseSink \* basesink, GstPad \* pad,
17. guint8 obj\_type, gpointer obj)
18. {
19. result = gst\_base\_sink\_chain\_unlocked (basesink, pad, obj\_type, obj);
20. }
22. static
    GstFlowReturn
23. gst\_base\_sink\_chain\_unlocked (GstBaseSink \* basesink, GstPad \* pad,
24. guint8 obj\_type, gpointer obj)
25. {
26. result = gst\_base\_sink\_queue\_object\_unlocked (basesink, pad,
27. obj\_type, obj, TRUE);
28. }
30. static
    GstFlowReturn
31. gst\_base\_sink\_queue\_object\_unlocked (GstBaseSink \* basesink, GstPad \* pad,
32. guint8 obj\_type, gpointer obj, gboolean prerollable)
33. {
34. while
    (G\_UNLIKELY (!g\_queue\_is\_empty (q))) {
35. ret = gst\_base\_sink\_render\_object (basesink, pad, ot, o);
36. }
37. }
39. /\* gstreamer-0.10.32/libs/gst/base/gstbasesink.c \*/
40. static
    GstFlowReturn
41. gst\_base\_sink\_render\_object (GstBaseSink \* basesink, GstPad \* pad,
42. guint8 obj\_type, gpointer obj)
43. {
44. /\* 这里开始做同步，同步成功后，才开始播放 \*/
45. ret =
46. gst\_base\_sink\_do\_sync (basesink, pad, sync\_obj, &late, &step\_end,
47. obj\_type);
48. if
    (G\_UNLIKELY (ret != GST\_FLOW\_OK))
49. goto
    sync\_failed;
51. if
    (!OBJ\_IS\_BUFFERLIST (obj\_type)) {
52. ret = bclass->render (basesink, buf);
53. }
    else
    {
54. ret = bclass->render\_list (basesink, buflist);
55. }
56. }
58. static
    GstFlowReturn
59. gst\_base\_sink\_do\_sync (GstBaseSink \* basesink, GstPad \* pad,
60. GstMiniObject \* obj, gboolean \* late, gboolean \* step\_end, guint8 obj\_type)
61. {
62. status = gst\_base\_sink\_wait\_clock (basesink, stime, &jitter);
63. return
    GST\_FLOW\_OK;
64. }

67. /\*
68. \* @time: the running\_time to be reached
69. \* @jitter: (out) (allow-none): the jitter to be filled with time diff, or NULL
70. \*
71. \* This function will block until @time is reached. It is usually called by
72. \* subclasses that use their own internal synchronisation.
73. \*/
74. GstClockReturn
75. gst\_base\_sink\_wait\_clock (GstBaseSink \* sink, GstClockTime time,
76. GstClockTimeDiff \* jitter)
77. {
78. if
    (G\_UNLIKELY ((clock = GST\_ELEMENT\_CLOCK (sink)) == NULL))
79. goto
    no\_clock;
81. base\_time = GST\_ELEMENT\_CAST (sink)->base\_time;
83. sink->priv->cached\_clock\_id = gst\_clock\_new\_single\_shot\_id (clock, time);
85. /\* 这里一直等待到时间 \*/
86. ret = gst\_clock\_id\_wait (sink->priv->cached\_clock\_id, jitter);
88. return
    ret;
89. }

这里同步完成，其实这里还有最后一个小问题，那么就是AudioClock是以什么为时钟的呢。其实就是以声卡的时钟为时钟的。因为声卡有时钟同步功能。所以我们计算一同播放了多少个sample，就可以计算出当前播放了多长的时间。 So.

END