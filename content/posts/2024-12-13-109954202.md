---
layout: post
title: "现代操作系统-原理与实现上银杏书-读书笔记"
date: 2024-12-13 21:15:25 +0800
description: "看看多久才会读完---买于20年双十一目录第1章-操作系统概述第2章-硬件结构第3章-操作系统结构第"
keywords: "现代操作系统:原理与实现"
categories: ['笔记']
tags: ['无标签']
artid: "109954202"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=109954202
    alt: "现代操作系统-原理与实现上银杏书-读书笔记"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=109954202
featuredImagePreview: https://bing.ee123.net/img/rand?artid=109954202
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     现代操作系统-原理与实现(上)【银杏书-读书笔记】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      <strong>
       看看多久才会读完---买于20年双十一
      </strong>
     </p>
     <p>
      <strong>
       【来自未来的​更新】​​​​​​已于2021年5月16日看完！！！！
      </strong>
     </p>
    </blockquote>
    <p>
     本篇为上集，戳这里
     <a href="https://blog.csdn.net/tpoem/article/details/114744720">
      直接看下集
     </a>
     ~~~~
    </p>
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="%E7%AC%AC1%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;">
     <a href="#%E7%AC%AC1%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0" rel="nofollow">
      第1章-操作系统概述
     </a>
    </p>
    <p id="%E7%AC%AC2%E7%AB%A0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;">
     <a href="#%E7%AC%AC2%E7%AB%A0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84" rel="nofollow">
      第2章-硬件结构
     </a>
    </p>
    <p id="%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;">
     <a href="#%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84" rel="nofollow">
      第3章-操作系统结构
     </a>
    </p>
    <p id="%E7%AC%AC4%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;">
     <a href="#%E7%AC%AC4%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" rel="nofollow">
      第4章-内存管理
     </a>
    </p>
    <p id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-toc" style="margin-left:0px;">
     <a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B" rel="nofollow">
      第5章-进程与线程
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81" rel="nofollow">
      进程的状态
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80-toc" style="margin-left:40px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80" rel="nofollow">
      进程的内存空间布局
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-toc" style="margin-left:40px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2" rel="nofollow">
      进程控制块和内存上下文切换
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;">
     <a href="#%E7%BA%BF%E7%A8%8B" rel="nofollow">
      线程
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%B1%E6%9D%A5-toc" style="margin-left:40px;">
     <a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%B1%E6%9D%A5" rel="nofollow">
      线程的由来
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;">
     <a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">
      线程的定义
     </a>
    </p>
    <p id="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80-toc" style="margin-left:40px;">
     <a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80" rel="nofollow">
      多线程的地址空间布局
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;">
     <a href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8" rel="nofollow">
      线程控制块和线程本地存储
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3-POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93-toc" style="margin-left:40px;">
     <a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3-POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93" rel="nofollow">
      线程的基本接口-POSIX线程库
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;">
     <a href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA" rel="nofollow">
      线程创建
     </a>
    </p>
    <p id="%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA-toc" style="margin-left:80px;">
     <a href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA" rel="nofollow">
      线程退出
     </a>
    </p>
    <p id="%E5%87%BA%E8%AE%A9%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;">
     <a href="#%E5%87%BA%E8%AE%A9%E8%B5%84%E6%BA%90" rel="nofollow">
      出让资源
     </a>
    </p>
    <p id="%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;">
     <a href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C" rel="nofollow">
      合并操作
     </a>
    </p>
    <p id="%E6%8C%82%E8%B5%B7%E4%B8%8E%E5%94%A4%E9%86%92-toc" style="margin-left:80px;">
     <a href="#%E6%8C%82%E8%B5%B7%E4%B8%8E%E5%94%A4%E9%86%92" rel="nofollow">
      挂起与唤醒
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C-toc" style="margin-left:40px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C" rel="nofollow">
      进程的执行
     </a>
    </p>
    <p id="%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B-toc" style="margin-left:80px;">
     <a href="#%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B" rel="nofollow">
      执行进程
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86" rel="nofollow">
      进程管理
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9B%91%E6%8E%A7-toc" style="margin-left:80px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9B%91%E6%8E%A7" rel="nofollow">
      进程间监控
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D%E7%BB%84-toc" style="margin-left:80px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D%E7%BB%84" rel="nofollow">
      进程组和会话组
     </a>
    </p>
    <p id="Fork%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;">
     <a href="#Fork%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">
      Fork的优点
     </a>
    </p>
    <p id="Fork%E7%9A%84%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;">
     <a href="#Fork%E7%9A%84%E7%BC%BA%E7%82%B9" rel="nofollow">
      Fork的缺点
     </a>
    </p>
    <p id="Fork%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85%E4%BB%AC-toc" style="margin-left:40px;">
     <a href="#Fork%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85%E4%BB%AC" rel="nofollow">
      Fork的继任者们
     </a>
    </p>
    <p id="%E7%AC%AC6%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6-toc" style="margin-left:0px;">
     <a href="#%E7%AC%AC6%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6" rel="nofollow">
      第6章-操作系统调度
     </a>
    </p>
    <p id="%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;">
     <a href="#%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6" rel="nofollow">
      调度机制
     </a>
    </p>
    <p id="%E9%95%BF%E6%9C%9F%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;">
     <a href="#%E9%95%BF%E6%9C%9F%E8%B0%83%E5%BA%A6" rel="nofollow">
      长期调度
     </a>
    </p>
    <p id="%E4%B8%AD%E6%9C%9F%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;">
     <a href="#%E4%B8%AD%E6%9C%9F%E8%B0%83%E5%BA%A6" rel="nofollow">
      中期调度
     </a>
    </p>
    <p id="%E7%9F%AD%E6%9C%9F%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;">
     <a href="#%E7%9F%AD%E6%9C%9F%E8%B0%83%E5%BA%A6" rel="nofollow">
      短期调度
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">
      进程的分类
     </a>
    </p>
    <p id="%E7%BB%8F%E5%85%B8%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;">
     <a href="#%E7%BB%8F%E5%85%B8%E8%B0%83%E5%BA%A6" rel="nofollow">
      经典调度
     </a>
    </p>
    <p id="%E5%85%88%E5%88%B0%E5%85%88%E5%BE%97FIFO-toc" style="margin-left:80px;">
     <a href="#%E5%85%88%E5%88%B0%E5%85%88%E5%BE%97FIFO" rel="nofollow">
      先到先得FIFO
     </a>
    </p>
    <p id="%E6%9C%80%E7%9F%AD%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88-toc" style="margin-left:80px;">
     <a href="#%E6%9C%80%E7%9F%AD%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88" rel="nofollow">
      最短任务优先
     </a>
    </p>
    <p id="%E6%9C%80%E7%9F%AD%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88-toc" style="margin-left:80px;">
     <a href="#%E6%9C%80%E7%9F%AD%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88" rel="nofollow">
      最短完成时间任务优先
     </a>
    </p>
    <p id="%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-toc" style="margin-left:80px;">
     <a href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC" rel="nofollow">
      时间片轮转
     </a>
    </p>
    <p id="%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;">
     <a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6" rel="nofollow">
      优先级调度
     </a>
    </p>
    <p id="%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:80px;">
     <a href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">
      多级队列
     </a>
    </p>
    <p id="%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-toc" style="margin-left:80px;">
     <a href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97" rel="nofollow">
      多级反馈队列
     </a>
    </p>
    <p id="%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6-toc" style="margin-left:80px;">
     <a href="#%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6" rel="nofollow">
      公平共享调度
     </a>
    </p>
    <hr id="hr-toc"/>
    <h2 id="%E7%AC%AC1%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">
     第1章-操作系统概述
    </h2>
    <p style="text-indent:33px;">
     <strong>
      从硬件角度
     </strong>
    </p>
    <p style="text-indent:33px;">
     对硬件进行管理，处理各种错误
    </p>
    <p style="text-indent:33px;">
     对硬件进行抽象，形成不依赖硬件的资源
    </p>
    <p style="text-indent:33px;">
     <strong>
      从应用角度
     </strong>
    </p>
    <p style="text-indent:33px;">
     提供不同的接口，满足不同类型的访问控制，应用间交互等服务
    </p>
    <p style="text-indent:33px;">
     进行资源分配与管理
    </p>
    <p style="text-indent:33px;">
    </p>
    <p style="text-indent:33px;">
     操作系统提供不同层次的接口
    </p>
    <ol>
     <li>
      系统调用接口，例如printf【printf 从应用程序-》libc-》下陷处理-》系统调用处理】[从应用程序-》libc-》是在用户态] [从下陷处理-》系统调用处理 是在内核态]
     </li>
     <li>
      POSIX接口【可移植操作系统接口】，例如glibc
     </li>
     <li>
      领域应用接口，例如AUTOSAR，这种算框架了
     </li>
    </ol>
    <h2 id="%E7%AC%AC2%E7%AB%A0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84">
     第2章-硬件结构
    </h2>
    <p>
     冯诺依曼-机，包含
    </p>
    <ol>
     <li>
      中央处理器
     </li>
     <li>
      存储器
     </li>
     <li>
      输入输出
     </li>
    </ol>
    <p>
     <img alt="" height="316" src="https://i-blog.csdnimg.cn/blog_migrate/51493c63cfd7834cad63851e932f3d7e.png" width="509"/>
    </p>
    <p style="text-indent:0;">
     <strong>
      指令集
     </strong>
     是ISA【指令集架构】的重要组成部分，AArch64属于RISC【精简指令集计算机】
    </p>
    <p style="text-indent:0;">
     <strong>
      特权级
     </strong>
     在AArch64中叫做异常级别，包括
    </p>
    <ol>
     <li>
      EL0   应用层跑在这【用户态】
     </li>
     <li>
      EL1   操作系统跑在这【内核态】
     </li>
     <li>
      EL2   虚拟化在这里【虚拟机场景用】
     </li>
     <li>
      EL3   TrustZone相关【负责切换安全世界和普通世界】
     </li>
    </ol>
    <p style="text-indent:33px;">
    </p>
    <p style="text-indent:0;">
     <strong>
      何时从EL0切换到EL1
     </strong>
    </p>
    <ol>
     <li>
      应用层程序用系统调用
     </li>
     <li>
      CPU收到中断
     </li>
     <li>
      应用层触发了异常
     </li>
    </ol>
    <p style="text-indent:33px;">
     其中1和2为同步的CPU特权级切换
    </p>
    <p style="text-indent:33px;">
     3为异步的CPU特权级切换
    </p>
    <p style="text-indent:33px;">
    </p>
    <p style="text-indent:0;">
     <strong>
      从EL0切换到EL1
     </strong>
    </p>
    <ol>
     <li>
      触发异常的指令地址【PC】保存到ELR_EL1
     </li>
     <li>
      异常原因保存到ESR_EL1
     </li>
     <li>
      CPU将栈指针从SP_EL0切换到SP_EL1，在异常向量表中选择对应的异常处理函数
     </li>
     <li>
      CPU还要保存一些状态
     </li>
    </ol>
    <p style="text-indent:0px;">
    </p>
    <p style="text-indent:0px;">
     寄存器是ISA的重要组成，包括
    </p>
    <ol>
     <li>
      <strong>
       通用寄存器
      </strong>
     </li>
     <li>
      <strong>
       栈指针寄存器
      </strong>
     </li>
     <li>
      <strong>
       链接指针
      </strong>
     </li>
    </ol>
    <p style="text-indent:0px;">
     EL1下有两个
     <strong>
      页表基地址寄存器
     </strong>
     ，这个和虚拟内存有关系
    </p>
    <p style="text-indent:0px;">
    </p>
    <p style="text-indent:0px;">
     <strong>
      Cache
     </strong>
    </p>
    <p style="text-indent:0px;">
     这个是为了加快CPU访问数据的速度，包括：
    </p>
    <p style="text-indent:0px;">
     若干个缓冲行，每一个行包括
    </p>
    <p style="text-indent:0px;">
     <strong>
      一个有效位
     </strong>
    </p>
    <p style="text-indent:0px;">
     <strong>
      一个标记地址
     </strong>
    </p>
    <p style="text-indent:0px;">
    </p>
    <p style="text-indent:0px;">
     为了通过物理地址找到对应的缓存，物理地址在逻辑上分为Tag，Set以及Offset三段
    </p>
    <p style="text-indent:0px;">
     物理地址中Set段能够表示的最大数目叫做
     <strong>
      组
     </strong>
    </p>
    <p style="text-indent:0px;">
     支持的最大Tag数叫做
     <strong>
      路
     </strong>
    </p>
    <p style="text-indent:0px;">
     <strong>
      缓存结构和缓存寻址的图请看书
     </strong>
    </p>
    <p style="text-indent:0px;">
    </p>
    <h2 id="%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">
     <strong>
      第3章-操作系统结构
     </strong>
    </h2>
    <p style="text-indent:0px;">
     设计操作系统的原则【机制与策略分离】
    </p>
    <blockquote>
     <p style="text-indent:0px;">
      策略：做什么【输入处理，启动加载....】
     </p>
     <p style="text-indent:0px;">
      机制：如何做【调度方法...】
     </p>
    </blockquote>
    <p style="text-indent:0px;">
     管理复杂系统的方法
    </p>
    <ol>
     <li>
      <strong>
       模块化
      </strong>
     </li>
     <li>
      <strong>
       抽象
      </strong>
     </li>
     <li>
      <strong>
       分层
      </strong>
     </li>
     <li>
      <strong>
       层级
      </strong>
     </li>
    </ol>
    <blockquote>
     <p style="text-indent:0px;">
      模块化：分而治之，将复杂系统分解成一系列的模块，保证模块之间的界限，高耦合低内聚，使之有独立性
     </p>
     <p style="text-indent:0px;">
      抽象：接口与实现分离，无需关心各个模块之间的内部实现
     </p>
     <p style="text-indent:0px;">
      分层：将模块按一定的层次划分，约束内部模块之间的交互方式
     </p>
     <p style="text-indent:0px;">
      层级：将功能相近的模块划分在一个子系统
     </p>
    </blockquote>
    <p style="text-indent:0;">
     操作系统的内核架构
    </p>
    <ol>
     <li>
      <strong>
       简要结构
      </strong>
     </li>
     <li>
      <strong>
       宏内核
      </strong>
     </li>
     <li>
      <strong>
       微内核
      </strong>
     </li>
     <li>
      <strong>
       外核
      </strong>
     </li>
     <li>
      <strong>
       多内核
      </strong>
     </li>
    </ol>
    <blockquote>
     <p style="text-indent:0px;">
      简要结构：应用程序和操作系统在同一个地址空间，没有虚拟内存管理，特权级隔离等功能，任何一个模块出问题，系统就崩溃了
     </p>
     <p style="text-indent:0px;">
      宏内核：所有的操作系统模块运行在内核态
     </p>
     <p style="text-indent:0px;">
      微内核：将单个的内核功能拆分，作为服务部署在用户态，仅有很小部分的内核运行在内核态，服务提供进程间通信的功能使之互相协作
     </p>
     <p style="text-indent:0px;">
      外核：操作系统与应用程序挂钩，应用程序要啥就装对应的功能，内核只负责对操作系统在多个操作系统之间的多路复用
     </p>
     <p style="text-indent:0px;">
      多内核：通过多内核管理异构多核设备
     </p>
    </blockquote>
    <h2 id="%E7%AC%AC4%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">
     第4章-内存管理
    </h2>
    <p style="text-indent:0px;">
     应用程序是面向虚拟内存编写的，CPU会翻译地址到物理地址，操作系统来管理虚拟地址和物理地址的映射
    </p>
    <p style="text-indent:0px;">
     设计时的三个目标
    </p>
    <ol>
     <li>
      高效性【不应占用过多的物理内存资源】
     </li>
     <li>
      安全性【使不同应用程序互相隔离】
     </li>
     <li>
      透明性【应用层编程时感觉不到内存的抽象】
     </li>
    </ol>
    <p style="text-indent:0px;">
     CPU通过MMU进行地址翻译，为了加速翻译，现代CPU都有
     <strong>
      TLB
     </strong>
     【转址旁路缓存】
    </p>
    <p style="text-indent:0px;">
     有两种机制
    </p>
    <ol>
     <li>
      分段机制
     </li>
     <li>
      分页机制
     </li>
    </ol>
    <p style="text-indent:0px;">
     分段机制不多写了，目前用的多的是分页机制的
    </p>
    <p style="text-indent:0px;">
     <strong>
      分页机制
     </strong>
    </p>
    <p>
     一个虚拟地址将被划分成两部分
    </p>
    <ol>
     <li>
      虚拟页号
     </li>
     <li>
      页内偏移量
     </li>
    </ol>
    <p>
     多级页表也是一样的结构，多级页表允许部分空洞，单级页表则需要每一项都真实存在
    </p>
    <p>
     <strong>
      AArch64 下的多级页表
     </strong>
    </p>
    <p>
     虚拟地址低48位参与地址翻译，页表级数为4，虚拟页大小4KB
    </p>
    <p>
     物理地址划分为连续的4KB大小物理页，一个虚拟页映射为一个物理页，低12位对应页内偏移量
    </p>
    <p>
     整个页表的起始地址放在
     <strong>
      页表基地址寄存器
     </strong>
     中，对应的就是第0级的页表页
    </p>
    <p>
     每一个页表页占用物理内存的一个物理页[4KB]
    </p>
    <p>
     每一个页表项占用8字节，存访问权限。
    </p>
    <p>
     因此，一个页表页包含512个页表项[4K/8],虚拟地址中对应于每一级页表的索引都是9位【2^9】
    </p>
    <blockquote>
     <p>
      63-48位： 全0或者全1
     </p>
     <p>
      47-39位：0级页表索引值
     </p>
     <p>
      38-30位：1级页表索引值
     </p>
     <p>
      29-21位：2级页表索引值
     </p>
     <p>
      20-12位：3级页表索引值
     </p>
     <p>
      11-0位：  页内偏移量
     </p>
    </blockquote>
    <p>
     <strong>
      如何翻译呢？
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       先根据页表基地址寄存器找到第0级页表页
      </strong>
     </li>
     <li>
      <strong>
       用0级页表索引值作为页表项索引，读取第0级页表页中对应的页表项，这个页表项又对应下一级的页表页物理地址
      </strong>
     </li>
     <li>
      <strong>
       以此类推，最后结合页内偏移量就可以得到最终的物理地址
      </strong>
     </li>
    </ol>
    <p>
    </p>
    <p>
     <strong>
      TLB【
     </strong>
     转址旁路缓存
     <strong>
      】
     </strong>
    </p>
    <p>
     <strong>
      多级页表的出现使得MMU翻译地址的过程要查找多个页表页中的页表项
     </strong>
    </p>
    <p>
     <strong>
      为了减少次数，加入TLB加速翻译
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       TLB缓存了虚拟页号到物理页号的映射关系
      </strong>
     </p>
     <p>
      <strong>
       MMU先把虚拟页号作为键值去查询TLB的缓存项
      </strong>
     </p>
     <p>
      <strong>
       找到【TLB命中】就直接得到物理页号，否则【TLB未命中】就要查页表
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     由于这个TLB是CPU的一部分，所以它的大小是有限的，它是由硬件直接进行管理的，这样才能高效利用
    </p>
    <p>
     TLB未命中，就去查页表，然后填进TLB
    </p>
    <p>
     如果已满，按照预定的方式替换掉某一项
    </p>
    <p>
     如果再次翻译一样的页号，那么就可以马上得到页表了。
    </p>
    <p>
     TLB与当前页表不一致是需要刷新的，如何最小化刷新对应用程序带来的影响，则是操作系统与CPU一起需要处理的。
    </p>
    <p>
    </p>
    <p>
     <strong>
      换页和缺页
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       换页：当物理内存不足时，操作系统把物理页的数据写到磁盘等容量更大的设备中，然后就可以回收物理页回来了，此时的物理页处于【已分配但未映射到物理内存】的状态
      </strong>
     </p>
     <p>
      <strong>
       缺页：当应用程序访问了处于【已分配但未映射到物理内存】的状态的物理页，那么就会触发缺页异常，操作系统会调用预先设置的处理函数，然后找到一个空虚的物理页，将之前的数据重新写回到该物理页上，并且在页表上填写该虚拟地址到这一个物理页的映射。
      </strong>
     </p>
    </blockquote>
    <p>
     由于换页涉及到磁盘操作，所以操作系统会引入预取机制优化。
    </p>
    <p>
     当应用层申请虚拟内存的时候，操作系统可以把新分配的虚拟页标记为已分配但未映射至物理内存的状态，不需要为这个虚拟页分配对应的物理页。只有要访问时才会触发缺页异常，真正为虚拟页分配物理页，并在页表里填写映射。
    </p>
    <p>
     初次访问时产生的缺页异常会导致访问延迟的增加，可以利用应用程序访问时的时空局限性改善。
    </p>
    <p>
    </p>
    <p>
     虚拟页处于
     <strong>
      未分配
     </strong>
     或者
     <strong>
      已分配但未映射至物理内存状态
     </strong>
     时，应用程序访问该虚拟页会触发缺页异常。
    </p>
    <p>
     Linux中应用程序的虚拟地址空间被实现由多个虚拟内存区域VMA组成
    </p>
    <blockquote>
     <p>
      当应用程序发生缺页异常时，操作系统通过判断虚拟页是否属于该应用程序的某个虚拟内存区域区分该页所处的分配状态
     </p>
     <p>
      <strong>
       若属于，则该页处于已分配但未映射至物理内存的状态
      </strong>
     </p>
     <p>
      <strong>
       否则，该页处于未分配状态。
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     <strong>
      页替换策略
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       如果空闲的物理页已经用完或者小于某个阈值，策略便会选择某些物理页换出到磁盘，让出空间,最小化缺页异常发生的次数进而提升性能
      </strong>
     </p>
    </blockquote>
    <p>
     常见的页替换策略有:
    </p>
    <ol>
     <li>
      MIN策略【优先选择未来不会再用的页】
     </li>
     <li>
      FIFO策略【优先选择最先换入的页】
     </li>
     <li>
      SECOND CHANCE策略【每一个物理页号维护一个访问标志位，如果没有置位，则换出该页，反之对应页挪动到队尾，从新的队头重新开始找换出的内存页】
     </li>
     <li>
      LRU策略【优先选择最久未被访问的页】
     </li>
     <li>
      MRU策略【优先选择最近访问的页】
     </li>
     <li>
      时钟算法策略【换入物理内存的页号排列成一个时钟的形状，该时钟有一个针臂，指向新换入内存的页号的后一个。每次需要选择换出页号时，从针臂所指的页号开始检查】
     </li>
    </ol>
    <p>
     <strong>
      共享内存
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       允许同一个物理页再不同的应用程序间共享
      </strong>
     </p>
     <p>
      <strong>
       基本用途是可以让不同应用程序之间互相通信
      </strong>
     </p>
     <p>
      <strong>
       基于此，操作系统又衍生出写时拷贝和内存去重
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     <strong>
      写时拷贝
     </strong>
    </p>
    <p>
     <strong>
      页表项中有部分位用来标识属性，包括标识虚拟页的权限
     </strong>
    </p>
    <p>
     <strong>
      写时拷贝技术允许应用程序A和B以只读方式共享同一段物理内存
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       当应用程序对该内存区域进行修改时，便会触发缺页异常，在异常处理函数之中系统会发现由于应用程序写了只读内存，对应区域被标记为写时拷贝。于是操作系统会把这种异常的物理页重新拷贝一份，并将新拷贝的物理页以可读可写的方式重新映射给应用程序。
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      内存去重
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       操作系统定时在内存中扫描相同的物理页，找到映射这些物理页的虚拟页，只保留其中一个物理页，并将具有相同内容的其他虚拟页都用写时拷贝方式映射到这个物理页上，然后释放掉给其他的物理页用。
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      内存压缩
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       操作系统还会引入压缩算法对内存数据进行压缩，特别是资源不足时，把不太会使用的一部分数据压缩，节约出更多的内存空间
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      大页
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       解决TLB缓存项不够的问题，大页的大小可以到2M甚至1G，相比原来4K的大小，大幅度减小TLB的占用量
      </strong>
     </p>
     <p>
      <strong>
       Linux还提供透明大页的机制，能够自动地降连续的4K页合并成2M的内存页.
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      物理内存分配机制
     </strong>
    </p>
    <p>
     <strong>
      内存碎片
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       无法被利用的内存，直接导致内存的利用率下降
      </strong>
     </p>
     <p>
      <strong>
       分为内部碎片和外部碎片
      </strong>
     </p>
     <p>
      <strong>
       外部碎片：经过多次回收和分配之后，物理内存高度分散，导致空闲内存足够但是无法满足申请需求
      </strong>
     </p>
     <p>
      <strong>
       内部碎片：当分配内存空间大于实际分配请求所需要的空间时，就会造成部分的内存浪费
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">
     第5章-进程与线程
    </h2>
    <blockquote>
     <p>
      <strong>
       上下文切换：通过保存和恢复进程在运行过程中的状态【上下文】，使进程可以暂停，切换和护肤，从而实现了CPU的资源调度。
      </strong>
     </p>
    </blockquote>
    <h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">
     进程的状态
    </h3>
    <ol>
     <li>
      新生状态
     </li>
     <li>
      预备状态
     </li>
     <li>
      运行状态
     </li>
     <li>
      阻塞状态
     </li>
     <li>
      终止状态
     </li>
    </ol>
    <h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80">
     进程的内存空间布局
    </h3>
    <p>
     用户栈： 栈保存了进程需要使用的各种临时数据，一般是自顶而下的，栈底在高地址，栈顶在低地址
    </p>
    <p>
     代码库：进程运行依赖的共享代码库，标记为只读
    </p>
    <p>
     用户堆：管理的是进程动态分配的内存，堆的扩展方向是自底向上。
    </p>
    <p>
     数据与代码段：数据段主要保存全局变量的值，代码段保存的是进程执行所需的代码
    </p>
    <p>
     内核部分：当进程在用户态运行时，内核内存对其不可见。只有进程进入内核态时，才能访问内存。
    </p>
    <p>
    </p>
    <h3 id="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">
     进程控制块和内存上下文切换
    </h3>
    <p>
     在内核中，每一个进程都通过一个数据结构来存它的相关状态，譬如进程标识符【PID】，进程状态，虚拟内存状态等，这种数据结构叫做进程控制块【PCB】
    </p>
    <p>
     进程的上下文包括运行时的寄存器状态，它可以用于保存和恢复上一个进程在处理器运行的状态。使用上下文切换机制，就可以把前一个进程的寄存器保存到PCB，然后将下一个进程保存的状态写入寄存器，切换到它运行。
    </p>
    <p>
     上下文切换一般是在内核态中运行的。
    </p>
    <p>
    </p>
    <h3 id="%E7%BA%BF%E7%A8%8B">
     线程
    </h3>
    <p>
     一个进程至少有一个线程，多个线程可以共享进程的资源。进程是在内存中运行的一段程序，而线程是这一段程序中的其中一个执行单元。
    </p>
    <p>
     在linux中，进程一般是调用fork从进程中分裂出来的
    </p>
    <p>
     一个进程调用fork后，会为该进程创建一个子进程。而调用fork的进程称作父进程。
    </p>
    <p>
     之后便会形成两个完全独立的两个进程，将拥有不同的PID与虚拟内存空间。
    </p>
    <p>
     对于父进程，返回值是子进程的PID，对子进程来说，返回值是0
    </p>
    <blockquote>
     <p>
      注意调度器眼中，子进程和父进程是两个独立的个体，执行顺序不定，完全取决于调度器的决策
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     对每一个进程来说，运行过程中都会维护一个已打开文件的文件描述符【fd表】文件描述符会使用偏移量记录当前进程读取到某一个文件的位置，因为文件结构可能根据不同文件系统而变化，这样做有利于操作系统进行管理。
    </p>
    <p>
     子进程和父进程拥有一样的fd表，因此在read操作的时候会对文件加锁，父子进程不可能读到完全一样的字符串。
    </p>
    <p>
     操作系统的第一个进程是由操作系统创建的，特定而唯一，其他进程就像树一样派生出来。
    </p>
    <p>
    </p>
    <h3 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%B1%E6%9D%A5">
     线程的由来
    </h3>
    <ol>
     <li>
      创建进程的开销比较大，需要独立的地址空间
     </li>
     <li>
      进程之间的通信和同步比较麻烦
     </li>
    </ol>
    <h3 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89">
     线程的定义
    </h3>
    <blockquote>
     <p>
      线程之间共享地址空间，但又各自保存运行时所需要的状态【上下文】
     </p>
     <p>
      它是操作系统种调度管理的最小单位
     </p>
    </blockquote>
    <h3 id="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80">
     多线程的地址空间布局
    </h3>
    <table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;">
     <caption>
      地址空间布局
     </caption>
     <tbody>
      <tr>
       <td>
        <p style="text-indent:0;">
         内核代码与数据
        </p>
       </td>
      </tr>
      <tr>
       <td>
        内核栈1
       </td>
      </tr>
      <tr>
       <td>
        内核栈2
       </td>
      </tr>
      <tr>
       <td>
        内核栈3
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         线程栈1
        </span>
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         线程栈2
        </span>
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         线程栈3
        </span>
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         代码库
        </span>
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         用户堆
        </span>
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         数据
        </span>
       </td>
      </tr>
      <tr>
       <td>
        <span style="color:#f33b45;">
         代码
        </span>
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      两个重要特征
     </p>
     <p>
      1. 分离的内核栈和用户栈
     </p>
     <p>
      2. 共享的其他区域
     </p>
    </blockquote>
    <p>
     内核栈由系统内核创建，用户栈不可见，直接受操作系统调度器管理。
    </p>
    <p>
     为了实现内核栈和用户栈协作，操作系统会在两者之间维护一个关系，叫做
     <strong>
      多线程模型
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       多对一模型【每次只有一个用户态线程进入内核】
      </strong>
     </li>
     <li>
      <strong>
       一对一模型【每一个线程对应一个内核态线程，但是这种需要限制线程总数，太多了处理不了】【Linux和Windows采用】
      </strong>
     </li>
     <li>
      <strong>
       多对多模型【既解决了内核态线程少而阻塞的问题，也解决了一对一模型线程有限制的问题】【Mac OS采用】
      </strong>
     </li>
    </ol>
    <h3 id="%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8">
     线程控制块和线程本地存储
    </h3>
    <p>
     类似于进程，线程也有自己的控制块，存储一些信息
    </p>
    <p>
     对linux来说，用户态的
     <strong>
      线程控制块TCB
     </strong>
     可以认为是内核态的扩展，用来存储更多与用户态相关的信息，其中最重要的就是
     <strong>
      线程本地存储TLS
     </strong>
    </p>
    <p>
     <strong>
      在多线程编程中，不同线程使用全局变量的时候，实际上访问的是该变量的不同拷贝，不会对其他线程产生影响。
     </strong>
    </p>
    <p>
     <strong>
      线程库位每一个线程创建完全相同的TLS，保存在内存的不同地址之上，每一个全局变量的拷贝相对于TLS起始位置的偏移量都是一样的
     </strong>
    </p>
    <p>
     <strong>
      由于TLS的结构相似性，对于TLS的寻址也比较特殊
     </strong>
    </p>
    <p>
     <strong>
      不同线程的段寄存器FS保存着不同的TLS起始地址，当不同的线程访问同名的TLS时，最终访问了不同的地址
     </strong>
    </p>
    <p>
    </p>
    <h3 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3-POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93">
     线程的基本接口-POSIX线程库
    </h3>
    <h4 id="%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA">
     线程创建
    </h4>
    <p>
     pthread_create
    </p>
    <h4 id="%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA">
     线程退出
    </h4>
    <p>
     pthread_exit
    </p>
    <h4 id="%E5%87%BA%E8%AE%A9%E8%B5%84%E6%BA%90">
     出让资源
    </h4>
    <p>
     pthread_yield
    </p>
    <h4 id="%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C">
     合并操作
    </h4>
    <p>
     pthread_join
    </p>
    <h4 id="%E6%8C%82%E8%B5%B7%E4%B8%8E%E5%94%A4%E9%86%92">
     挂起与唤醒
    </h4>
    <p>
     sleep
    </p>
    <p>
     pthread_cond_wait
    </p>
    <p>
    </p>
    <h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C">
     进程的执行
    </h3>
    <h4 id="%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B">
     执行进程
    </h4>
    <p>
     通过调用execve函数执行进程
    </p>
    <blockquote>
     <ul>
      <li>
       将可执行文件的数据段和代码段载入当前进程的地址空间
      </li>
      <li>
       重新初始化堆和栈
      </li>
      <li>
       将PC寄存器设置到可执行文件代码段定义的入口点，该入口点最终会调用main函数
      </li>
      <li>
       在需要设定环境变量时，main函数也可以扩展写成int main(int argc,char * argv[],char *envp[]),使得程序能够直接访问envp来获取到环境变量
      </li>
     </ul>
    </blockquote>
    <h4 id="%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">
     进程管理
    </h4>
    <p>
     Linux中，进程都是通过fork生成出来的
    </p>
    <p>
     每一个进程都会记录自己的父进程和子进程，这样进程之间就构成了树关系
    </p>
    <p>
     <strong>
      处于树根部的是init进程
     </strong>
    </p>
    <h4 id="%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9B%91%E6%8E%A7">
     进程间监控
    </h4>
    <p>
     在linux中，进程可以使用wait来对其子进程进行监控。
    </p>
    <blockquote>
     <p>
      父进程调用waitpid堆子进程进行监控，如果子进程已经退出，那么waitpid就会立即返回，并设置状态值，否则会阻塞等待子进程退出，当waitpid退出后，父进程可以访问状态值变量来获取子进程的状态
     </p>
    </blockquote>
    <p>
    </p>
    <blockquote>
     <p>
      僵尸进程： 终止了却没有释放对应资源的子进程
     </p>
    </blockquote>
    <h4 id="%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D%E7%BB%84">
     进程组和会话组
    </h4>
    <blockquote>
     <p>
      <strong>
       进程组
      </strong>
      是进程的集合，父进程和子进程属于同一个进程组
     </p>
     <p>
      <strong>
       会话
      </strong>
      是
      <strong>
       进程组
      </strong>
      的集合，可以分为前台进程组和后台进程组，控制终端进程组等
     </p>
     <p>
      每一个进程都有自己的进程id【PID】，进程组id【GID】和会话id【SID】
     </p>
     <p>
      <strong>
       对于init进程来说，这三个值都是1
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <h3 id="Fork%E7%9A%84%E4%BC%98%E7%82%B9">
     Fork的优点
    </h3>
    <blockquote>
     <p>
      fork和exec的组合可以认为是将进程的创建的进一步解耦
     </p>
     <p>
      fork强调进程之间的联系，如果父子进程之间有较强的联系的话就适合用fork
     </p>
    </blockquote>
    <h3 id="Fork%E7%9A%84%E7%BC%BA%E7%82%B9">
     Fork的缺点
    </h3>
    <blockquote>
     <p>
      过于复杂，接口简洁，但是内部已经随着时代的变迁变得异常复杂
     </p>
     <p>
      性能不佳，写时拷贝技术对于今天的应用来说需要耗费太多的时间
     </p>
     <p>
      有安全漏洞
     </p>
    </blockquote>
    <h3 id="Fork%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85%E4%BB%AC">
     Fork的继任者们
    </h3>
    <ol>
     <li>
      posix_spawn【将fork和exec合二为一】
     </li>
     <li>
      vfork【限定场景，只适合进程创建后立即使用exec】
     </li>
     <li>
      rfork/clone【精密控制，提供更多的控制选项】
     </li>
    </ol>
    <h2 id="%E7%AC%AC6%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6">
     第6章-操作系统调度
    </h2>
    <h3 id="%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6">
     调度机制
    </h3>
    <p>
     把调度分成
    </p>
    <ol>
     <li>
      长期调度
     </li>
     <li>
      中期调度
     </li>
     <li>
      短期调度
     </li>
    </ol>
    <h3 id="%E9%95%BF%E6%9C%9F%E8%B0%83%E5%BA%A6">
     长期调度
    </h3>
    <p>
     用于限制系统中真正被短期调度管理的进程数量，避免短期调度开销过大。
    </p>
    <p>
     它的触发时间长，粗粒度的决定是不是要将一个新进程纳入调度管理，负责增加系统中可被调度的进程的数量
    </p>
    <h3 id="%E4%B8%AD%E6%9C%9F%E8%B0%83%E5%BA%A6">
     中期调度
    </h3>
    <p>
     将内存使用的情况也考虑进来，避免内存使用过多，实际上算作换页机制的一部分，它会挂起系统中被短期调度管理的进程。
    </p>
    <p>
     触发相对频繁，辅助换页机制，负责限制系统中可被调度的进程数量
    </p>
    <h3 id="%E7%9F%AD%E6%9C%9F%E8%B0%83%E5%BA%A6">
     短期调度
    </h3>
    <p>
     是实际来做出调度决策的，负责进程状态的转换。
    </p>
    <p>
     触发最为频繁，细粒度的负责进程的执行，做出对应的调度决策。
    </p>
    <p>
     <img alt="" height="358" src="https://i-blog.csdnimg.cn/blog_migrate/0ccc80e1bd7412731932456ec2084119.png" width="586"/>
    </p>
    <h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB">
     进程的分类
    </h3>
    <ol>
     <li>
      计算密集型【使用CPU进行长时间运算】
     </li>
     <li>
      IO密集型【等待IO请求会占用大量的时间】
     </li>
    </ol>
    <h3 id="%E7%BB%8F%E5%85%B8%E8%B0%83%E5%BA%A6">
     经典调度
    </h3>
    <h4 id="%E5%85%88%E5%88%B0%E5%85%88%E5%BE%97FIFO">
     先到先得FIFO
    </h4>
    <p>
     【优点】：简单直观，不需要预知任务的信息
    </p>
    <p>
     【缺点】：
    </p>
    <ol>
     <li>
      在长短任务混合的场景下，对短任务不友好，短任务要等很久。
     </li>
     <li>
      对IO密集型进程不友好，用IO很久，占CPU很短，但是计算密集型一直占着CPU，CPU处理不了IO请求，就对IO密集型进程很不公平。
     </li>
    </ol>
    <h4 id="%E6%9C%80%E7%9F%AD%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88">
     最短任务优先
    </h4>
    <p>
     【优点】：选择运行时间最短的任务执行，短任务就可以不用等很久了
    </p>
    <p>
     【缺点】：
    </p>
    <ol>
     <li>
      必须预知任务的运行时间，某些场景很难预知任务的时长
     </li>
     <li>
      严重依赖任务到达的时间点，一旦调度器没有发现短任务到达，错过了就会做出错误的决策了
     </li>
    </ol>
    <h4 id="%E6%9C%80%E7%9F%AD%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88">
     最短完成时间任务优先
    </h4>
    <p>
     调度器必须等一个任务执行完或者主动退出执行才能开始下一个调度，这种就是
     <strong>
      非抢占式调度
     </strong>
     。
    </p>
    <p>
     对于最短完成时间任务优先来说，在任务达到的时候也会调度，还有可能打断目前正在执行的任务，这种就是
     <strong>
      抢占式调度。
     </strong>
    </p>
    <p>
     【缺点】：
    </p>
    <ol>
     <li>
      需要预知任务运行的时间
     </li>
     <li>
      长任务会饥饿，短任务多，长任务少，因为短任务执行完的快，所以长任务就很吃亏
     </li>
    </ol>
    <h4 id="%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC">
     时间片轮转
    </h4>
    <p>
     限定每一个任务的运行时间，完成以后就执行运行队列中的下一个任务
    </p>
    <p>
     【优点】：不需要预知任务运行的时间，也不会出现长任务很吃亏的问题。
    </p>
    <p>
     【缺点】：
    </p>
    <ol>
     <li>
      过小的时间片就会造成调度开销很大
     </li>
     <li>
      虽然保证了每个任务之间的公平性，良好的响应时间，但是在任务运行时间相似的场景下平均周转时间高。
     </li>
    </ol>
    <h3 id="%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6">
     优先级调度
    </h3>
    <h4 id="%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97">
     多级队列
    </h4>
    <p>
     每一个任务都会被分配预先设置好的优先级
    </p>
    <p>
     每一个优先级对应一个队列，任务就被存放在这些队列里。
    </p>
    <p>
     多个任务同时预备，那么调度器就会选择优先级高的队列中的任务执行，在同一优先级下，策略又不一样，可以采取不同的策略，譬如FIFO或者时间片。
    </p>
    <p>
     在这种调度策略下
    </p>
    <p>
     <strong>
      需要预知任务的运行时间
     </strong>
    </p>
    <p>
     <strong>
      设置优先级需要提高IO密集型任务的优先级，因为IO密集型并不占用CPU太久。
     </strong>
    </p>
    <p>
     【缺点】：
    </p>
    <ol>
     <li>
      低优先级任务饥饿，高优先级的任务特别多，低优先级的任务根本轮不上，需要另外加机制【监测等待时间】，等待太久直接上了。
     </li>
     <li>
      优先级反转，这个弄过操作系统的都知道，解决的方法就是优先级继承【互斥信号量】
     </li>
    </ol>
    <h4 id="%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97">
     多级反馈队列
    </h4>
    <p>
     类似多级队列，但是它实现了优先级的动态设置。
    </p>
    <p>
     【优点】：
    </p>
    <ol>
     <li>
      短任务的优先级更高，对IO密集型任务就很有利了，降低交互式任务的响应时间。
     </li>
     <li>
      统计运行任务的时间长度，判断是长任务还是短任务，定义最大运行时间，超过了的任务优先级自动降低，实现动态评估任务优先级。
     </li>
     <li>
      低优先级的任务采用更长的时间片，但是有优先级抢占所以不怕占时间长
     </li>
     <li>
      定时将所有任务优先级改到最高，保证不会有任务饥饿
     </li>
    </ol>
    <h4 id="%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6">
     公平共享调度
    </h4>
    <p>
     会量化任务对系统资源的占用比例，从而实现资源公平调度，以份额量化每一个任务对CPU的使用。
    </p>
    <p>
     实际中将任务分组，以组为单位分配份额，任务在组内继续分配份额。
    </p>
    <p>
     优先级调度为了优化任务的周转时间，响应时间，而份额式的公平共享调度式为了让每个任务都可以得到对应的资源。
    </p>
    <h2>
    </h2>
    <p>
     <a href="https://blog.csdn.net/tpoem/article/details/114744720">
      下篇链接戳这里
     </a>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f74706f656d2f:61727469636c652f64657461696c732f313039393534323032" class_="artid" style="display:none">
 </p>
</div>


