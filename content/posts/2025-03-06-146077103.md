---
layout: post
title: "Linux网络编程TCP并行服务器"
date: 2025-03-06 18:35:49 +0800
description: "多线程实现：每当有客户端连接时，服务器创建一个线程来处理该连接。适合连接数适中的情况，但线程数过多时可能会带来性能问题多进程实现：通过fork()创建子进程来处理每个客户端。I/O 多路复用（select）实现：服务器通过select等待多个客户端的事件，适用于大量客户端连接，且无需为每个连接创建线程或进程。select使用位图管理文件描述符，最多允许同时监测1024个文件描述符（有上限）；文件描述符集合在应用层创建，需要实现应用层和内核层的反复拷贝；需要应用层对集合表进行遍历，寻找到达的事件；"
keywords: "Linux网络编程——TCP并行服务器"
categories: ['未分类']
tags: ['运维', '服务器', 'Tcp', 'Linux']
artid: "146077103"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077103
    alt: "Linux网络编程TCP并行服务器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077103
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077103
cover: https://bing.ee123.net/img/rand?artid=146077103
image: https://bing.ee123.net/img/rand?artid=146077103
img: https://bing.ee123.net/img/rand?artid=146077103
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux网络编程——TCP并行服务器
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 Linux 网络编程中，通过不同的技术来实现一个
     <strong>
      TCP 并行服务器
     </strong>
     ，能够有效地处理多个客户端连接。我们可以使用
     <strong>
      多线程
     </strong>
     、
     <strong>
      多进程进程池
     </strong>
     和
     <strong>
      I/O 多路复用
     </strong>
     （如
     <code>
      select
     </code>
     、
     <code>
      poll
     </code>
     或
     <code>
      epoll
     </code>
     ）来提高服务器的性能。以下是分步实现的代码示例：
    </p>
    <h4>
     1. 使用多线程实现 TCP 并行服务器
    </h4>
    <h5>
     多线程服务器：
    </h5>
    <p>
     多线程服务器会为每个客户端请求创建一个新线程来处理它们。这样可以让服务器同时处理多个客户端，但线程过多会增加上下文切换的开销。
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;pthread.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;sys/socket.h&gt; 
#include &lt;arpa/inet.h&gt; 
#include &lt;netinet/in.h&gt;

#define LISMAXNUM    1024

int init_udp_ser(const char *ip, unsigned short port)
{
	struct sockaddr_in seraddr;
	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(port);
	seraddr.sin_addr.s_addr = inet_addr(ip);

	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd &lt; 0)
	{
		perror("fail socket");
		return -1;
	}
	
	int ret = bind(sockfd, (struct sockaddr *)&amp;seraddr, sizeof(seraddr));
	if (ret &lt; 0)
	{
		perror("fail bind");
		return -1;
	}

	ret = listen(sockfd, LISMAXNUM);
	if (ret &lt; 0)
	{
		perror("fail listen");
		return -1;
	}

	return sockfd;
}

void handler(int signo)
{
	wait(NULL);
}

void *thread(void *arg)
{
	int connfd = *(int *)arg;
	char buff[512] = {0};

	while (1)
	{
		memset(buff, 0, sizeof(buff));
		ssize_t size = recv(connfd, buff, sizeof(buff), 0);
		if (size &lt; 0)
		{
			close(connfd);
			return NULL;
		}
		
		if (size == 0)
		{
			close(connfd);
			return NULL;
		}
		printf("%s\n", buff);

		size = send(connfd, buff, strlen(buff), 0);
		if (size &lt; 0)
		{
			close(connfd);
			return NULL;
		}
	}
}

int main(int argc, const char *argv[])
{
	struct sockaddr_in cli;

	socklen_t clilen = sizeof(cli); 

	signal(SIGCHLD, handler);

	int sockfd = init_udp_ser("192.168.1.178", 50000);
	if (sockfd &lt; 0)
	{
		return -1;
	}

	while (1)
	{
		int connfd = accept(sockfd, (struct sockaddr *)&amp;cli, &amp;clilen);
		if (connfd &lt; 0)
		{
			perror("fail accept");
			return -1;
		}

		pthread_t tid;
		pthread_create(&amp;tid, NULL, thread, &amp;connfd);

		pthread_detach(tid);

	}

	close(sockfd);

	return 0;
}</code></pre>
    <h5>
     主要流程：
    </h5>
    <ol>
     <li>
      <strong>
       创建套接字
      </strong>
      ：服务器通过
      <code>
       socket()
      </code>
      创建 TCP 套接字。
     </li>
     <li>
      <strong>
       绑定与监听
      </strong>
      ：通过
      <code>
       bind()
      </code>
      和
      <code>
       listen()
      </code>
      绑定端口并等待客户端连接。
     </li>
     <li>
      <strong>
       创建线程
      </strong>
      ：每当有一个客户端连接时，通过
      <code>
       pthread_create()
      </code>
      创建一个新线程来处理客户端请求。
     </li>
     <li>
      <strong>
       回显客户端消息
      </strong>
      ：线程处理客户端的消息接收与发送。
     </li>
    </ol>
    <h4>
     2. 使用多进程进程池实现 TCP 并行服务器
    </h4>
    <h5>
     多进程服务器：
    </h5>
    <p>
     多进程服务器通过
     <code>
      fork()
     </code>
     创建多个子进程，每个子进程处理一个客户端连接。
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;sys/socket.h&gt; 
#include &lt;arpa/inet.h&gt; 
#include &lt;netinet/in.h&gt; 
#include &lt;sys/wait.h&gt;

#define LISMAXNUM    1024

int init_udp_ser(const char *ip, unsigned short port)
{
	struct sockaddr_in seraddr;
	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(port);
	seraddr.sin_addr.s_addr = inet_addr(ip);

	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd &lt; 0)
	{
		perror("fail socket");
		return -1;
	}
	
	int ret = bind(sockfd, (struct sockaddr *)&amp;seraddr, sizeof(seraddr));
	if (ret &lt; 0)
	{
		perror("fail bind");
		return -1;
	}

	ret = listen(sockfd, LISMAXNUM);
	if (ret &lt; 0)
	{
		perror("fail listen");
		return -1;
	}

	return sockfd;
}

void handler(int signo)
{
	wait(NULL);
}


int main(int argc, const char *argv[])
{
	struct sockaddr_in cli;

	socklen_t clilen = sizeof(cli); 

	signal(SIGCHLD, handler);

	int sockfd = init_udp_ser("192.168.1.178", 50000);
	if (sockfd &lt; 0)
	{
		return -1;
	}

	while (1)
	{
		int connfd = accept(sockfd, (struct sockaddr *)&amp;cli, &amp;clilen);
		if (connfd &lt; 0)
		{
			perror("fail accept");
			return -1;
		}

		pid_t pid = fork();
		if (pid &lt; 0)
		{
			perror("fail fork");
			return -1;
		}

		if (0 == pid)
		{
			char buff[512] = {0};

			while (1)
			{
				memset(buff, 0, sizeof(buff));
				ssize_t size = recv(connfd, buff, sizeof(buff), 0);
				if (size &lt; 0)
				{
					close(connfd);
					exit(1);
				}
				
				if (size == 0)
				{
					close(connfd);
					exit(1);
				}
				printf("%s\n", buff);

				size = send(connfd, buff, strlen(buff), 0);
				if (size &lt; 0)
				{
					close(connfd);
					exit(1);
				}
			}
		}
		else if (pid &gt; 0)
		{
			
		}
	}

	close(sockfd);

	return 0;
}</code></pre>
    <h5>
     主要流程：
    </h5>
    <ol>
     <li>
      <strong>
       创建套接字
      </strong>
      ：通过
      <code>
       socket()
      </code>
      创建 TCP 套接字。
     </li>
     <li>
      <strong>
       绑定与监听
      </strong>
      ：使用
      <code>
       bind()
      </code>
      和
      <code>
       listen()
      </code>
      绑定地址并开始监听。
     </li>
     <li>
      <strong>
       <code>
        fork()
       </code>
       创建子进程
      </strong>
      ：每当有客户端连接时，父进程通过
      <code>
       fork()
      </code>
      创建一个新的子进程来处理该客户端。
     </li>
     <li>
      <strong>
       处理客户端
      </strong>
      ：子进程使用
      <code>
       recv()
      </code>
      和
      <code>
       send()
      </code>
      与客户端进行交互，并回显客户端的消息。
     </li>
    </ol>
    <h4>
     3. 线程池
    </h4>
    <p>
     提前预创建大量线程，避免任务执行过程中创建线程的耗时。
    </p>
    <h4>
     3. 使用 I/O 多路复用（
     <code>
      select
     </code>
     ）实现 TCP 并行服务器
    </h4>
    <p>
     <code>
      select
     </code>
     是一种 I/O 多路复用技术，允许一个进程或线程监视多个文件描述符的状态变化。使用
     <code>
      select
     </code>
     使得服务器能够同时处理多个客户端的请求。
    </p>
    <h5>
     <code>
      select
     </code>
     实现服务器代码：
    </h5>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;sys/socket.h&gt; 
#include &lt;arpa/inet.h&gt; 
#include &lt;netinet/in.h&gt; 
#include &lt;sys/select.h&gt;


#define LISMAXNUM    1024

int init_udp_ser(const char *ip, unsigned short port)
{
	struct sockaddr_in seraddr;
	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(port);
	seraddr.sin_addr.s_addr = inet_addr(ip);

	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd &lt; 0)
	{
		perror("fail socket");
		return -1;
	}
	
	int ret = bind(sockfd, (struct sockaddr *)&amp;seraddr, sizeof(seraddr));
	if (ret &lt; 0)
	{
		perror("fail bind");
		return -1;
	}

	ret = listen(sockfd, LISMAXNUM);
	if (ret &lt; 0)
	{
		perror("fail listen");
		return -1;
	}

	return sockfd;
}


int main(int argc, const char *argv[])
{
	char buff[512] = {0};
	struct sockaddr_in cli;

	socklen_t clilen = sizeof(cli); 

	int sockfd = init_udp_ser("192.168.1.164", 50000);
	if (sockfd &lt; 0)
	{
		return -1;
	}

	int maxfd = -1;
	fd_set rdfds;
	fd_set tmpfds;
	FD_ZERO(&amp;rdfds);

	FD_SET(sockfd, &amp;rdfds);
	maxfd = maxfd &gt; sockfd ? maxfd : sockfd;

	while (1)
	{
		tmpfds = rdfds;
		int cnt = select(maxfd+1, &amp;tmpfds, NULL, NULL, NULL);
		if (cnt &lt; 0)
		{
			perror("fail select");
			return -1;
		}

		for (int i = 0; i &lt; maxfd+1; i++)
		{
			if (FD_ISSET(i, &amp;tmpfds))
			{
				if (i == sockfd)
				{
					int connfd = accept(sockfd, (struct sockaddr *)&amp;cli, &amp;clilen);
					if (connfd &lt; 0)
					{
						perror("fail accept");
						continue;
					}

					FD_SET(connfd, &amp;rdfds);
					maxfd = maxfd &gt; connfd ? maxfd : connfd;
				}
				else
				{
					memset(buff, 0, sizeof(buff));
					ssize_t size = recv(i, buff, sizeof(buff), 0);
					if (size &lt; 0)
					{
						perror("fail recv");
						FD_CLR(i, &amp;rdfds);
						close(i);
						continue;
					}
					
					if (size == 0)
					{
						FD_CLR(i, &amp;rdfds);
						close(i);
						continue;
					}
					printf("%s\n", buff);

					strcat(buff, "------&gt;OK");
					size = send(i, buff, strlen(buff), 0);
					if (size &lt; 0)
					{
						perror("fail send");
						FD_CLR(i, &amp;rdfds);
						close(i);
						continue;
					}
				}
			}
		}
	}

	close(sockfd);

	return 0;
}</code></pre>
    <h5>
     主要流程：
    </h5>
    <ol>
     <li>
      <strong>
       创建套接字
      </strong>
      ：通过
      <code>
       socket()
      </code>
      创建 TCP 套接字。
     </li>
     <li>
      <strong>
       绑定与监听
      </strong>
      ：使用
      <code>
       bind()
      </code>
      和
      <code>
       listen()
      </code>
      绑定地址并开始监听。
     </li>
     <li>
      <strong>
       select
      </strong>
      ：监听多个套接字的状态变化，通过非阻塞方式检测哪些客户端有数据可以处理
      <ol>
       <li>
        创建文件描述符集合
       </li>
       <li>
        将关注的文件描述符加入到集合
       </li>
       <li>
        等待IO事件到达
       </li>
       <li>
        根据不同的IO事件处理不同的任务
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     总结
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        多线程实现
       </strong>
       ：每当有客户端连接时，服务器创建一个线程来处理该连接。适合连接数适中的情况，但线程数过多时可能会带来性能问题
      </p>
     </li>
     <li>
      <p>
       <strong>
        多进程实现
       </strong>
       ：通过
       <code>
        fork()
       </code>
       创建子进程来处理每个客户端。
      </p>
     </li>
     <li>
      <p>
       <strong>
        I/O 多路复用（
        <code>
         select
        </code>
        ）实现
       </strong>
       ：服务器通过
       <code>
        select
       </code>
       等待多个客户端的事件，适用于大量客户端连接，且无需为每个连接创建线程或进程。
      </p>
      <ul>
       <li>
        <p>
         select使用位图管理文件描述符，最多允许同时监测1024个文件描述符（有上限）；
        </p>
       </li>
       <li>
        <p>
         文件描述符集合在应用层创建，需要实现应用层和内核层的反复拷贝；
        </p>
       </li>
       <li>
        <p>
         需要应用层对集合表进行遍历，寻找到达的事件；
        </p>
       </li>
       <li>
        <p>
         只能工作在水平触发模式（低速模式），不能工作在边沿触发模式（高速模式） 。
        </p>
       </li>
      </ul>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f57575757777777424a2f:61727469636c652f64657461696c732f313436303737313033" class_="artid" style="display:none">
 </p>
</div>


