---
layout: post
title: "linux-基础IO之操作与文件描述符全解析从C语言到系统调用底层实现"
date: 2025-03-15 21:34:00 +0800
description: "本文剖析Linux文件操作与系统调用原理，从C语言文件打开模式（如w清空、a追加）及重定向机制切入，详解open()的标志位（O_CREAT/O_EXCL等）、权限设置与原子性操作。核心揭示文件描述符（fd）本质：内核文件指针数组下标，通过struct file管理文件属性及缓冲区。结合“一切皆文件”设计，阐明设备通过函数指针表抽象为文件接口，并验证C语言FILE对fd的封装，最终呈现用户态到内核态的文件操作链路。"
keywords: "linux - 基础IO之操作与文件描述符全解析：从C语言到系统调用底层实现"
categories: ['Linux']
tags: ['运维', '服务器', 'Linux']
artid: "146277868"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146277868
    alt: "linux-基础IO之操作与文件描述符全解析从C语言到系统调用底层实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146277868
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146277868
cover: https://bing.ee123.net/img/rand?artid=146277868
image: https://bing.ee123.net/img/rand?artid=146277868
img: https://bing.ee123.net/img/rand?artid=146277868
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     linux - 基础IO之操作与文件描述符全解析：从C语言到系统调用底层实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="1.%E5%9B%9E%E9%A1%BEc%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%89%80%E5%AD%A6%E7%9A%84%E6%96%87%E4%BB%B6" name="1.%E5%9B%9E%E9%A1%BEc%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%89%80%E5%AD%A6%E7%9A%84%E6%96%87%E4%BB%B6">
     <span style="color:#0d0016">
      1.回顾c语言中所学的文件
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="324" src="https://i-blog.csdnimg.cn/direct/15e69ca7532945b3841694d929d1e95a.png" width="560"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       进行文件操作，前提是我们的程序在执行了，所谓的文件的打开和关闭，是cpu在执行代码，比如执行fopen(),才将文件打开的。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       当一个代码执行的时候已经变成了一个
       <strong>
        进程
       </strong>
       ，所以在
       <strong>
        建立文件时
       </strong>
       ，他就会默认的接在当前
       <strong>
        进程所处路径
       </strong>
       后，拼上所创建的文件名，创建的这个文件。
      </span>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        （进程启动时所处的路径：当前进程的当前工作路径。）
       </strong>
      </span>
     </p>
    </blockquote>
    <h2 id="2.%E6%8F%90%E7%82%BC%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88linux%E5%9F%BA%E7%A1%80io%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89" name="2.%E6%8F%90%E7%82%BC%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88linux%E5%9F%BA%E7%A1%80io%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89">
     <span style="color:#0d0016">
      2.提炼对文件的理解（linux基础io第一阶段的学习）
     </span>
    </h2>
    <h3 id="a.%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%88%B0%E5%90%8E%E9%9D%A2%E4%BC%9A%E5%8F%98%E6%88%90%E4%B8%A4%E7%A7%8D%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E3%80%82" name="a.%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%88%B0%E5%90%8E%E9%9D%A2%E4%BC%9A%E5%8F%98%E6%88%90%E4%B8%A4%E7%A7%8D%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8C%87%E9%92%88%E5%85%B3%E7%B3%BB%E3%80%82">
     <strong>
      <span style="color:#0d0016">
       a.在操作系统内部，一个进程和一个被打开的文件，他们到后面会变成两种对象之间的指针关系。
      </span>
     </strong>
    </h3>
    <blockquote>
     <ul>
      <li>
       <span style="color:#0d0016">
        打开文件，本质是进程打开文件。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        当文件本就存在时，文件没有被打开的时候，存在磁盘上
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        一个进程可以打开多个文件。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        系统当中可以存在多个进程，大多数情况下，OS内部，一定存在大量被打开的文件，每个进程可能都打开很多文件。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        文件未被打开时处于磁盘上，处于一个硬件上，因此只能被操作系统（操作系统是硬件的管理者）打开（用的是c语言接口），因此操作系统会对这些被打开的文件进行管理（先描述，再组织）。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        每一个被打开的文件，在os内部，一定会存在对应的描述文件属性的结构体，类似于PCB。
       </span>
      </li>
     </ul>
    </blockquote>
    <h3 id="b.%E6%96%87%E4%BB%B6%20%3D%20%E5%B1%9E%E6%80%A7%20%2B%20%E5%86%85%E5%AE%B9" name="b.%E6%96%87%E4%BB%B6%20%3D%20%E5%B1%9E%E6%80%A7%20%2B%20%E5%86%85%E5%AE%B9">
     <span style="color:#0d0016">
      <strong>
       b.文件 = 属性 + 内容
      </strong>
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       当我在磁盘上新建一个文本文件，但并不打开，并不往其中填写任何数据，他在磁盘上所占据的大小是0KB,此时他是否会占据磁盘空间？会占据，文件的名字、文件建立的时间、文件的大小等等文件的属性就已经占据了磁盘空间了。0kb指的是内容为0。结构体放的就是文件的属性。
      </span>
     </p>
    </blockquote>
    <p>
     <span style="color:#0d0016">
      1.打开文件 2.并向文件 写入3.再关闭。
     </span>
    </p>
    <p>
     <img alt="" height="379" src="https://i-blog.csdnimg.cn/direct/166de9e755fa4737a22e8292899eed3a.png" width="664"/>
    </p>
    <p>
     <span style="color:#0d0016">
      1.打开文件  --- w ,不存在就在当前路径下创建指定文件。 2.并向文件 写入3.再关闭。都是进程让cpu在执行自己的代码。通过这样的方式发开文件，访问文件。
     </span>
    </p>
    <h3 id="c.%E5%9C%A8c%E8%AF%AD%E8%A8%80%E4%B8%AD%2C%E4%BB%A5w%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%85%88%E6%8A%8A%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%BB%99%E6%B8%85%E7%A9%BA%E3%80%82a%E5%88%99%E6%98%AF%E8%BF%BD%E5%8A%A0" name="c.%E5%9C%A8c%E8%AF%AD%E8%A8%80%E4%B8%AD%2C%E4%BB%A5w%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%85%88%E6%8A%8A%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%BB%99%E6%B8%85%E7%A9%BA%E3%80%82a%E5%88%99%E6%98%AF%E8%BF%BD%E5%8A%A0">
     <span style="color:#0d0016">
      <strong>
       c.在c语言中,以w的方式打开文件，默认打开文件的时候，就会先把目标文件给清空。a则是追加
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#0d0016">
      只以写的方式打开文件：
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <img alt="" height="371" src="https://i-blog.csdnimg.cn/direct/ced0cefcdd8644a7b3b537e78b2410ff.png" width="725"/>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      延续上面的操作本来log.txt中是有内容的，现在被清空了
     </span>
    </p>
    <p class="img-center">
     <img alt="" height="294" src="https://i-blog.csdnimg.cn/direct/601cd5c1b8214ff88d3a27950d5a54ac.png" width="447"/>
    </p>
    <h3 id="d.%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%C2%A0%20%E2%80%98%C2%A0%20%3E%20%E2%80%99---%3E%E5%85%88%E6%B8%85%E7%A9%BA%E5%86%8D%E5%86%99%E5%85%A5%EF%BC%88%E4%BB%A5w%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91%20'%3E%3E'%E5%85%B7%E4%BD%93%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%8D%9A%E5%AE%A2linux-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%94%A8%E6%B3%9502%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81%EF%BC%81%EF%BC%89_linux%E7%9A%8402-CSDN%E5%8D%9A%E5%AE%A2" name="d.%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%C2%A0%20%E2%80%98%C2%A0%20%3E%20%E2%80%99---%3E%E5%85%88%E6%B8%85%E7%A9%BA%E5%86%8D%E5%86%99%E5%85%A5%EF%BC%88%E4%BB%A5w%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91%20'%3E%3E'%E5%85%B7%E4%BD%93%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%8D%9A%E5%AE%A2linux-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%94%A8%E6%B3%9502%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81%EF%BC%81%EF%BC%89_linux%E7%9A%8402-CSDN%E5%8D%9A%E5%AE%A2">
     <span style="color:#0d0016">
      <strong>
       d.输出重定向  ‘  &gt; ’---&gt;先清空再写入（以w方式打开文件），追加重定向 '&gt;&gt;'具体可以看博客
      </strong>
     </span>
     <a href="https://blog.csdn.net/2303_77756141/article/details/140713813?spm=1011.2415.3001.5331" title="linux-基本指令与用法02（超详细！！）_linux的02-CSDN博客">
      linux-基本指令与用法02（超详细！！）_linux的02-CSDN博客
     </a>
    </h3>
    <h2 id="3.%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6" name="3.%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6" style="background-color:transparent">
     <span style="color:#0d0016">
      3.理解文件
     </span>
    </h2>
    <p>
     <span style="color:#0d0016">
      a,操作文件、本质：进程在操作文件。进程和文件的关系
     </span>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       b.文件 --&gt; 磁盘（外设）---&gt; 硬件  ----&gt; 向文件中写入，本质是向硬件中写入。 ----&gt;  用户没有权利直接向硬件写入  ----&gt;  硬件的管理者是操作系统 ------&gt;  用户无法绕过操作系统去处理硬件（嵌入式除外）----&gt; 用户必须通过OS来写入 ----&gt;  操作系统给用户提供系统调用 ----&gt; c语言 / c++ ...都是对系统调用接口的封装   ----&gt;
      </span>
      <span style="color:#fe2c24">
       <strong>
        访问文件，就可以用系统调用
       </strong>
      </span>
     </p>
     <p>
      <img alt="" height="756" src="https://i-blog.csdnimg.cn/direct/b4664036f64c4ee6b9b08bf4542852c9.png" width="875"/>
     </p>
    </blockquote>
    <p>
     <span style="color:#0d0016">
      c++写入文件：
     </span>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;

#define FILENAME "log.txt"

using namespace std;

int main()
{
  std::ofstream out(FILENAME, std::ios::binary);
  if(!out.is_open()) return 1;
  string message("hello c++\n");
  out.write(message.c_str(), message.size());

  out.close();
  return 0;
}
</code></pre>
    <h3 id="open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0" name="open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0" style="background-color:transparent">
     <span style="color:#0d0016">
      open()系统调用函数
     </span>
    </h3>
    <pre><code class="language-cpp">       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;fcntl.h&gt;

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);
</code></pre>
    <h4 id="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" name="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" style="background-color:transparent">
     <span style="color:#0d0016">
      参数说明
     </span>
    </h4>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        pathname
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       类型：
       <code>
        const char*
       </code>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       作用：要打开或创建的文件路径（绝对或相对路径）。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        flags
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       类型：
       <code>
        int
       </code>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       作用：指定文件的打开方式，多个标志可通过按位或（
       <code>
        |
       </code>
       ）组合。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       常用标志：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        必选标志
       </strong>
       （三选一）：
      </span>
     </p>
     <p>
      <span style="color:#ed7976">
       <strong>
        <code>
         O_RDONLY
        </code>
        :
       </strong>
      </span>
      <span style="color:#0d0016">
       只读模式、
      </span>
      <span style="color:#ed7976">
       <strong>
        <code>
         O_WRONLY
        </code>
        :
       </strong>
      </span>
      <span style="color:#0d0016">
       只写模式、
      </span>
      <span style="color:#ed7976">
       <strong>
        <code>
         O_RDWR
        </code>
        :
       </strong>
      </span>
      <span style="color:#0d0016">
       读写模式。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        可选标志
       </strong>
       ：（O代表open的意思）
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        <code>
         O_CREAT
        </code>
        :
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
       </strong>
      </span>
      <span style="color:#ed7976">
       <strong>
       </strong>
       文件不存在时创建新文件，需配合
       <code>
        mode
       </code>
       参数设置权限。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        <code>
         O_TRUNC
        </code>
        :
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
      </span>
      <span style="color:#ed7976">
       若文件存在且为普通文件，将其长度截断为0。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        <code>
         O_APPEND
        </code>
        :
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
       </strong>
      </span>
      <span style="color:#ed7976">
       <strong>
       </strong>
       追加写入（每次写操作前移动到文件末尾）。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        <code>
         O_EXCL
        </code>
        :
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
       </strong>
       与
       <code>
        O_CREAT
       </code>
       联用时，若文件已存在则返回错误（用于原子性创建文件）。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        <code>
         O_NONBLOCK
        </code>
        :
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
       </strong>
       非阻塞模式（对设备文件或管道有效）。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        mode
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       类型：
       <code>
        mode_t
       </code>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       作用：创建文件时的权限（仅当使用
       <code>
        O_CREAT
       </code>
       时需指定）。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       常见值（八进制表示）：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <code>
        0644
       </code>
       : 用户可读写，组和其他用户只读。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <code>
        0755
       </code>
       : 用户可读写执行，组和其他用户可读执行。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       注意：实际权限为
       <code>
        mode &amp; ~umask
       </code>
       （
       <code>
        umask
       </code>
       用于过滤权限位）。
      </span>
     </p>
     <h4 id="%E8%BF%94%E5%9B%9E%E5%80%BC" name="%E8%BF%94%E5%9B%9E%E5%80%BC">
      <span style="color:#0d0016">
       返回值
      </span>
     </h4>
     <ul>
      <li>
       <p>
        <span style="color:#0d0016">
         <strong>
          成功
         </strong>
         ：返回文件描述符（非负整数），用于后续操作（如
         <code>
          read
         </code>
         ,
         <code>
          write
         </code>
         ）。
        </span>
       </p>
      </li>
      <li>
       <p>
        <span style="color:#0d0016">
         <strong>
          失败
         </strong>
         ：返回
         <code>
          -1
         </code>
         ，并设置
         <code>
          errno
         </code>
         指示错误类型（如
         <code>
          ENOENT
         </code>
         文件不存在、
         <code>
          EACCES
         </code>
         权限不足）
        </span>
       </p>
      </li>
     </ul>
    </blockquote>
    <h4 id="%E6%89%93%E5%BC%80%E7%8E%B0%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%88%E5%8F%AA%E8%AF%BB%EF%BC%89" name="%E6%89%93%E5%BC%80%E7%8E%B0%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%88%E5%8F%AA%E8%AF%BB%EF%BC%89">
     <span style="color:#0d0016">
      打开现有文件（只读）
     </span>
    </h4>
    <p>
     <span style="color:#0d0016">
      当已经存在文件时，可以不传权限的参数
     </span>
    </p>
    <pre><code class="language-cpp">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("open failed");
        return 1;
    }
    close(fd);
    return 0;
}</code></pre>
    <p>
    </p>
    <h4 id="%C2%A0%C2%A0%E7%8B%AC%E5%8D%A0%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%88%E9%81%BF%E5%85%8D%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%89" name="%C2%A0%C2%A0%E7%8B%AC%E5%8D%A0%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%88%E9%81%BF%E5%85%8D%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%89">
     <span style="color:#0d0016">
      独占创建文件（避免竞态条件）
     </span>
    </h4>
    <pre><code class="language-cpp">int fd = open("unique.txt", O_WRONLY | O_CREAT | O_EXCL, 0644);
if (fd == -1) {
    perror("file already exists");
    return 1;
}</code></pre>
    <h4 id="%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%EF%BC%88%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90%EF%BC%8C%E8%8B%A5%E5%AD%98%E5%9C%A8%E5%88%99%E6%B8%85%E7%A9%BA%EF%BC%89" name="%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%EF%BC%88%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90%EF%BC%8C%E8%8B%A5%E5%AD%98%E5%9C%A8%E5%88%99%E6%B8%85%E7%A9%BA%EF%BC%89">
     <span style="color:#0d0016">
      创建新文件（读写权限，若存在则清空）
     </span>
    </h4>
    <p>
     <span style="color:#0d0016">
      创建新文件时，一定要传权限码，例如：0666：用户、组、其他，默认都是可读可写的权限
     </span>
    </p>
    <pre><code class="language-bash">-rwxr-xr--  1 user  group  4096 Jun 1 10:00 file.txt
▲ ▲▲▲ ▲▲▲ ▲▲▲ 
│ │││ │││ │││ 
│ └──────┬─────── 权限（用户u、组g、其他o）
└───────── 文件类型（`-`普通文件，`d`目录）</code></pre>
    <blockquote>
     <p>
      八进制：
     </p>
     <p>
      数字表示（八进制）：
     </p>
     <ul>
      <li>
       <p>
        r=4, w=2, x=1，三者相加：
       </p>
       <ul>
        <li>
         <p>
          <code>
           rwxr-xr--
          </code>
          →
          <code>
           7(4+2+1) 5(4+0+1) 4(4+0+0)
          </code>
          → 权限数字
          <strong>
           754
          </strong>
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <pre><code class="language-cpp">int fd = open("log.txt", O_WRONLY | O_CREAT, 0666);
if (fd == -1) {
    perror("open");
    return 1;
}</code></pre>
     <p>
      <span style="color:#0d0016">
       没有传
       <strong>
        权限码
       </strong>
       就会出现权限处乱码：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="128" src="https://i-blog.csdnimg.cn/direct/807493632a1d471fb88f65883d804c6f.png" width="839"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       传了0666：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="274" src="https://i-blog.csdnimg.cn/direct/58a2776aca4548138dc583e59dad9317.png" width="928"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       这是因为：最终权限 =
       <strong>
        默认最大权限
       </strong>
       -
       <strong>
        umask 值
       </strong>
       （实际是位运算
       <code>
        默认权限 &amp; ~umask
       </code>
       ）
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="120" src="https://i-blog.csdnimg.cn/direct/eb6de28262314bfd9467d284752d2bea.png" width="775"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       如何一次性创建好需求权限的文件：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       umask()系统调用
      </span>
     </p>
     <pre><code class="language-cpp"> #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       mode_t umask(mode_t mask);
</code></pre>
     <p>
      <span style="color:#0d0016">
       修改原代码：将系统掩码设置为0，没设置的时候就用系统默认的
      </span>
     </p>
     <pre><code class="language-cpp">  umask(0);
  int fd = open("log.txt", O_WRONLY | O_CREAT, 0666);
  if(fd &lt; 0)
  {
    perror("open");
    return 1;
  }

</code></pre>
     <p>
      <span style="color:#0d0016">
       输出：
      </span>
     </p>
     <p>
      <img alt="" height="217" src="https://i-blog.csdnimg.cn/direct/4f689398a390464c9c7246a5a4da8fb9.png" width="877"/>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        补充：文件权限计算
       </strong>
       ：
      </span>
     </p>
     <ul>
      <li>
       <p>
        <span style="color:#0d0016">
         默认最大权限：
         <code>
          666
         </code>
         （二进制
         <code>
          110 110 110
         </code>
         ）
        </span>
       </p>
      </li>
      <li>
       <p>
        <span style="color:#0d0016">
         umask 值：
         <code>
          002
         </code>
         （二进制
         <code>
          000 000 010
         </code>
         ）
        </span>
       </p>
      </li>
      <li>
       <p>
        <span style="color:#0d0016">
         实际权限：
         <code>
          666 - 002 = 664
         </code>
        </span>
       </p>
       <p>
        <span style="color:#0d0016">
         （即
         <code>
          rw-rw-r--
         </code>
         ，用户和组可读写，其他只读）
        </span>
       </p>
      </li>
     </ul>
     <p>
      <span style="color:#0d0016">
       将这个整数参数看作是一张位图
      </span>
     </p>
     <p>
      <img alt="" height="167" src="https://i-blog.csdnimg.cn/direct/d3bc6254a04d4627b200671d776f200b.png" width="1116"/>
     </p>
    </blockquote>
    <blockquote>
     <h4 id="%E8%AE%BE%E8%AE%A1%E4%BC%A0%E9%80%92%E4%BD%8D%E5%9B%BE%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%87%BD%E6%95%B0" name="%E8%AE%BE%E8%AE%A1%E4%BC%A0%E9%80%92%E4%BD%8D%E5%9B%BE%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%87%BD%E6%95%B0" style="background-color:transparent">
      <span style="color:#333333">
       设计传递位图标记位的函数
      </span>
     </h4>
     <p>
      <span style="color:#333333">
       通过设计一个传递位图标记位的函数来理解os 设计很多系统调用接口的方法：
      </span>
     </p>
     <pre><code class="language-cpp">#include &lt;stdio.h&gt; 
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#define ONE    1     // 1 0000 0001
#define TWO   (1&lt;&lt;1) // 2 0000 0010
#define THREE (1&lt;&lt;2) // 4 0000 0100
#define FOUR  (1&lt;&lt;3) // 8 0000 1000

void print(int flag)
{
    if(flag &amp; ONE)
        printf("one\n");
    if(flag &amp; TWO)
        printf("two\n");
    if(flag &amp; THREE)
        printf("three\n");
    if(flag &amp; FOUR)
        printf("four\n");
}

int main()
{
    print(ONE);
    printf("\n");

    print(TWO);
    printf("\n");

    print(ONE | TWO);
    printf("\n");

    print(ONE | TWO | THREE);
    printf("\n");

    print(ONE | FOUR);
    printf("\n");

    print(ONE | TWO | THREE | FOUR);
    printf("\n");
    return 0;
}</code></pre>
     <p>
      <span style="color:#333333">
       通过标志位来让我们实现对应的功能，向指定的函数传递多种标记位的方法，标记位传参
      </span>
     </p>
     <p>
      <span style="color:#333333">
       <img alt="" height="203" src="https://i-blog.csdnimg.cn/direct/65f5f877abf04c91a90e336411dd0064.png" width="271"/>
       <img alt="" height="205" src="https://i-blog.csdnimg.cn/direct/bd9a83601c5149218d17be772b5e7153.png" width="301"/>
      </span>
     </p>
    </blockquote>
    <h3 id="close()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0" name="close()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">
     <span style="color:#0d0016">
      close()系统调用函数
     </span>
    </h3>
    <blockquote>
     <h4 id="close()%C2%A0%E7%9A%84%E4%BD%9C%E7%94%A8" name="close()%C2%A0%E7%9A%84%E4%BD%9C%E7%94%A8">
      <span style="color:#0d0016">
       <code>
        close()
       </code>
       的作用
      </span>
     </h4>
     <p>
      <span style="color:#0d0016">
       <strong>
        释放资源
       </strong>
       ：
      </span>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        每个打开的文件描述符都会占用系统资源（如内核中的文件表项、缓冲区等）。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        调用
        <code>
         close()
        </code>
        后，系统会释放这些资源。
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#0d0016">
       <strong>
        刷新缓冲区
       </strong>
       ：
      </span>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        如果文件是以写入模式打开的，
        <code>
         close()
        </code>
        会确保所有缓冲区的数据写入磁盘（类似于
        <code>
         fflush()
        </code>
        ）。
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#0d0016">
       <strong>
        解除文件描述符的绑定
       </strong>
       ：
      </span>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        关闭后，文件描述符不再与任何文件或资源关联，可以被重新用于其他文件。
       </span>
      </li>
     </ul>
     <p>
      <span style="color:#0d0016">
       <strong>
        避免资源泄漏
       </strong>
       ：
      </span>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        如果不关闭文件描述符，可能会导致文件描述符耗尽（每个进程有文件描述符数量限制）。
       </span>
      </li>
     </ul>
     <p>
     </p>
     <h4 id="close()%E5%8F%82%E6%95%B0%EF%BC%9A" name="close()%E5%8F%82%E6%95%B0%EF%BC%9A">
      <strong>
       <span style="color:#0d0016">
        close()参数：
       </span>
      </strong>
     </h4>
     <pre><code class="language-cpp">#include &lt;unistd.h&gt;

int close(int fd);</code></pre>
     <ul>
      <li>
       <p>
        <span style="color:#0d0016">
         <code>
          fd
         </code>
         ：要关闭的文件描述符（通常由
         <code>
          open()
         </code>
         、
         <code>
          socket()
         </code>
         等函数返回）。
        </span>
       </p>
      </li>
     </ul>
     <p>
      <span style="color:#0d0016">
       返回值：
      </span>
     </p>
     <ul>
      <li>
       <p>
        <span style="color:#0d0016">
         成功时返回
         <code>
          0
         </code>
         。
        </span>
       </p>
      </li>
      <li>
       <p>
        <span style="color:#0d0016">
         失败时返回
         <code>
          -1
         </code>
         ，并设置
         <code>
          errno
         </code>
         表示错误原因。
        </span>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="write()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0" name="write()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">
     <span style="color:#0d0016">
      write()系统调用函数
     </span>
    </h3>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       一、函数原型与头文件
      </span>
     </p>
     <pre><code class="language-cpp">#include &lt;unistd.h&gt;

ssize_t write(int fd, const void *buf, size_t count);</code></pre>
     <h4 id="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%9A" name="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%9A" style="background-color:transparent">
      <strong>
       <span style="color:#0d0016">
        参数说明：
       </span>
      </strong>
     </h4>
     <p>
      <strong>
       <span style="color:#0d0016">
        <code>
         fd
        </code>
        （文件描述符）
       </span>
      </strong>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        已打开文件的描述符（由
        <code>
         open()
        </code>
        、
        <code>
         socket()
        </code>
        等函数返回）。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        必须具有
        <strong>
         可写权限
        </strong>
        （例如以
        <code>
         O_WRONLY
        </code>
        或
        <code>
         O_RDWR
        </code>
        模式打开）。
       </span>
      </li>
     </ul>
     <p>
      <strong>
       <span style="color:#0d0016">
        <code>
         buf
        </code>
        （数据缓冲区）
       </span>
      </strong>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        指向用户空间缓冲区的指针，包含待写入的数据。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        可以是任意类型的数据（如字符串、二进制数据）。
       </span>
      </li>
     </ul>
     <p>
      <strong>
       <span style="color:#0d0016">
        <code>
         count
        </code>
        （写入字节数）
       </span>
      </strong>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        指定从
        <code>
         buf
        </code>
        中写入的字节数。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        实际写入的字节数可能小于
        <code>
         count
        </code>
        （需检查返回值）。
       </span>
      </li>
     </ul>
     <p>
     </p>
     <h4 id="%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A" name="%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A">
      <strong>
       <span style="color:#0d0016">
        返回值：
       </span>
      </strong>
     </h4>
     <p>
      <span style="color:#0d0016">
       <strong>
        成功时：
       </strong>
       返回实际写入的字节数（
       <code>
        0 ≤ 返回值 ≤ count
       </code>
       ）。
      </span>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        返回值为
        <code>
         0
        </code>
        表示未写入数据（例如写入到已满的管道）。
       </span>
      </li>
      <li>
       <span style="color:#0d0016">
        返回值小于
        <code>
         count
        </code>
        表示部分写入（需处理剩余数据）。
       </span>
      </li>
     </ul>
     <p>
      <strong>
       <span style="color:#0d0016">
        失败时：
       </span>
      </strong>
     </p>
     <ul>
      <li>
       <span style="color:#0d0016">
        返回
        <code>
         -1
        </code>
        ，并设置全局变量
        <code>
         errno
        </code>
        表示错误类型
       </span>
      </li>
     </ul>
     <h4 id="write()%C2%A0%E4%B8%8E%C2%A0fwrite()%C2%A0%E5%AF%B9%E6%AF%94" name="write()%C2%A0%E4%B8%8E%C2%A0fwrite()%C2%A0%E5%AF%B9%E6%AF%94" style="background-color:transparent">
      <code>
       write()
      </code>
      与
      <code>
       fwrite()
      </code>
      对比
     </h4>
     <table>
      <thead>
       <tr>
        <th>
         特性
        </th>
        <th>
         <code>
          write()
         </code>
        </th>
        <th>
         <code>
          fwrite()
         </code>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         接口层级
        </td>
        <td>
         系统调用（底层）
        </td>
        <td>
         标准库函数（高层）
        </td>
       </tr>
       <tr>
        <td>
         缓冲
        </td>
        <td>
         无缓冲（直接写入内核）
        </td>
        <td>
         带用户空间缓冲区
        </td>
       </tr>
       <tr>
        <td>
         错误处理
        </td>
        <td>
         通过
         <code>
          errno
         </code>
         和返回值
        </td>
        <td>
         通过返回值与
         <code>
          ferror()
         </code>
        </td>
       </tr>
       <tr>
        <td>
         适用场景
        </td>
        <td>
         需要精细控制的场景（如非阻塞）
        </td>
        <td>
         常规文件操作（更便捷）
        </td>
       </tr>
      </tbody>
     </table>
    </blockquote>
    <h2 id="%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9Afd%EF%BC%88%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89%EF%BC%9A" name="%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9Afd%EF%BC%88%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89%EF%BC%9A" style="background-color:transparent">
     <span style="color:#0d0016">
      什么叫做fd（文件描述符）：
     </span>
    </h2>
    <blockquote>
     <p>
      strlen 函数：只用写入有效字符串
     </p>
     <p>
      <img alt="" height="160" src="https://i-blog.csdnimg.cn/direct/d0f4ff3b6fb9475086218b8668725c61.png" width="813"/>
     </p>
     <p>
      输出：
     </p>
     <p>
      <img alt="" height="339" src="https://i-blog.csdnimg.cn/direct/aa0d6a259c8a4d2e955efed77b6d35d5.png" width="1249"/>
     </p>
     <p>
      <span style="color:#0d0016">
       很显然第二次的写入是在上一次的基础上从头开始写的。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        以写的方式打开，不存在就创建，并且先清空文件内容
       </strong>
      </span>
     </p>
     <pre><code class="language-cpp">int fd = open("log.txt", O_WRONLY | O_CREAT | O_TRUNC, 0666);</code></pre>
     <p>
      open()的返回值fd是什么？这里我创建了四个文件并记录他们的返回值
     </p>
     <p>
      <img alt="" height="224" src="https://i-blog.csdnimg.cn/direct/96c755799cb44639aef12658227dc94c.png" width="650"/>
     </p>
     <p>
      <span style="color:#0d0016">
       输出结果：
      </span>
      <img alt="" height="78" src="https://i-blog.csdnimg.cn/direct/e239a5a7261147ecafbbad02b9c23add.png" width="280"/>
     </p>
    </blockquote>
    <h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%BF%94%E5%9B%9E%200%E3%80%811%E3%80%812%EF%BC%9F" name="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%BF%94%E5%9B%9E%200%E3%80%811%E3%80%812%EF%BC%9F">
     <span style="color:#0d0016">
      为什么不返回 0、1、2？
     </span>
    </h3>
    <p>
     <span style="color:#0d0016">
      <strong>
       因为：
      </strong>
     </span>
    </p>
    <p>
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        <span style="color:#0d0016">
         1：标准输入 - 键盘
        </span>
       </strong>
      </li>
      <li>
       <strong>
        <span style="color:#0d0016">
         2：标准输出 - 显示器
        </span>
       </strong>
      </li>
      <li>
       <strong>
        <span style="color:#0d0016">
         3：标准错误 - 显示器
        </span>
       </strong>
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       这里和c语言的进行对比
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="268" src="https://i-blog.csdnimg.cn/direct/ea7b404219924226b15a76fafc174848.png" width="1003"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       stdin、stdout、stderr对应的类型都是文件指针，与c语言的fopen、fdopen、freopen的返回值是一样的
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="212" src="https://i-blog.csdnimg.cn/direct/edf6a96b4af24f0cb7c766e106a8b0e5.png" width="1140"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        这些说明，在c语言中我们把键盘显示器也是当做文件来看的
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       也就是说，由于write()是根据open返回的fd，来查找文件并写入的，那我直接往1中写入不就是往显示器文件中写吗：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="61" src="https://i-blog.csdnimg.cn/direct/6d77e46b398d45f18f38ddfeb0df9b2a.png" width="573"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       编译运行：
      </span>
     </p>
     <p>
      <img alt="" height="67" src="https://i-blog.csdnimg.cn/direct/bc69e8debfa545888b3c83e5ce0ee191.png" width="455"/>
     </p>
     <p>
      <span style="color:#0d0016">
       fd  ---&gt;   文件描述符   ---&gt;  文件描述符的本质是什么？
      </span>
     </p>
    </blockquote>
    <h2 id="fd%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" name="fd%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="background-color:transparent">
     <span style="color:#0d0016">
      <strong>
       fd的本质是什么？
      </strong>
     </span>
    </h2>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       1.在打开文件的时候，会在操作系统中创建一个
       <strong>
        struct file
       </strong>
       ，文件的内核数据结构所包含的是文件的属性（权限，什么方式被打开，标记位），所有被打开的文件，他们的内核数据结构以双链表的形式被链接起来，操作系统对文件的管理转变成对链表的增删查改，每一个struct file内部都有一个指向与 该文件所对应的文件内核级的缓存的 指针，操作系统给文件申请的内存。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       一个磁盘上的文件，会经过属性struct file内核数据结构 初始化，内容直接存到这个文件的缓存当中。未来直接从缓存当中读写修改。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="488" src="https://i-blog.csdnimg.cn/direct/d2a28bd1fb2e49559ef5c57bf07c93b4.png" width="1492"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       os中有多个进程，每个进程都有可能打开多个文件，进程和文件的关系是1：n，进程的内核数据结构中存在一个struct files_struct *file属性。os中还会存在一个struct file_struct内核数据结构，整个结构中会包含一个指针数组struct file* fd_array[N]。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       想让进程和对应的文件产生关系：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       将描述文件的结构体变量的地址（文件属性的地址），依次填入到 fd_array[],特定的数组中，因此一个进程想要找到对应的文件，只需要把对应文件数组的下标返回给上层比如说 int fd，就可以访问文件了。
       <strong>
        每个进程都有一个指针*files, 指向一张表files_struct,该表最重要的部分就是包涵一个指针数组，每个元素都是一个指向打开文件的指针！所以，本质上，文件描述符就是该数组的下标。所以，只要拿着文件描述符，就可以找到对应的文件
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="623" src="https://i-blog.csdnimg.cn/direct/ba999dcf58434450b6e7e99fdd80cde9.png" width="1555"/>
      </span>
     </p>
     <h3 id="fd%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%EF%BC%9A%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87" name="fd%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%EF%BC%9A%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87">
      <span style="color:#0d0016">
       <strong>
        fd的本质是：内核的进程：文件映射关系的数组的下标
       </strong>
      </span>
     </h3>
     <p>
      <span style="color:#0d0016">
       读的本质是：将文件缓冲区的内容拷贝到需要的文件当中去，如果对应的内容不在缓冲区里，os就会把这个打开文件的进程阻塞住，挂起，os再将磁盘中的数据搬到缓存当中，再唤醒进程。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       写和修改内容：没有内容的时候上层就直接将内容拷贝到缓冲区，当文件中本来就有内容的时候，现将内容拷贝到缓冲区，再在内存当中修改，定期由os再刷新
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        1.无论读写，都必须让os把内容读到对应的文件缓冲区内，在内存中修改，再刷新到磁盘
       </strong>
       。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        2.open()在：
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        a.创建file
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        b.开辟文件缓冲区的空间，加载文件数据（延后）
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        c.查进程的文件描述符表
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        d.将file地址，填入对应的表中
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        e.返回下标
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        3.write()、read()函数的本质是拷贝函数
       </strong>
      </span>
     </p>
    </blockquote>
    <blockquote>
     <h3 id="%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6%C2%A0" name="%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6%C2%A0" style="background-color:transparent">
      <span style="color:#0d0016">
       一切皆文件
      </span>
     </h3>
     <p>
      <span style="color:#0d0016">
       像是键盘、鼠标、显示器、网卡、磁盘这些外设，他们可以由一个设备结构体来记录他们的属性，但是，他们每一个的操作方法都不同，这是通过驱动来控制的。对每一个设备os都会构建一个struct file,里面就会包含他们的读写的函数指针,再指向驱动层的方法。使用同一个类，其中包含的读写函数指针指向不同的设备，因此我们就不用再管底层的差异了，因为底层外设的方法---&gt;归于函数指针  ---》
       <strong>
        一切皆文件
       </strong>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <strong>
        这就像c++中的多态
       </strong>
      </span>
     </p>
     <p>
      <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/38b38f1448b842bd9f6b06a64afd36cb.png" width="1583"/>
     </p>
     <p>
      <img alt="" height="521" src="https://i-blog.csdnimg.cn/direct/8f1f5a3714e24769a12c4d70e35ace97.png" width="1575"/>
     </p>
    </blockquote>
    <blockquote>
     <p>
      <img alt="" height="109" src="https://i-blog.csdnimg.cn/direct/9fb0eee2573b4f409f40284dac848ac6.png" width="463"/>
     </p>
     <p>
      这是一个指针指向一张操作表：
     </p>
     <p>
      <img alt="" height="593" src="https://i-blog.csdnimg.cn/direct/64e966478a1b425ebd65c70394116a8a.png" width="1062"/>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        每一个被打开的文件还会有一张，操作底层方法的指针表
       </strong>
      </span>
     </p>
     <p style="text-align:center">
      <img alt="" height="230" src="https://i-blog.csdnimg.cn/direct/f47703f91dbd4a4dba7053820a002a3f.png" width="1639"/>
     </p>
     <p>
      在操作系统中，这就叫做虚拟文件系统：virtual file system
     </p>
    </blockquote>
    <p>
    </p>
    <blockquote>
     <p>
      在操作系统中，系统访问文件时只认文件描述符fd
     </p>
     <p>
     </p>
     <p>
      如何理解
      <strong>
       c语言
      </strong>
      通过FILE* 访问文件？ 这个FILE是一个结构体
     </p>
     <p>
      <img alt="" height="313" src="https://i-blog.csdnimg.cn/direct/7c9678a9d60f47108fc83c68b0d25929.png" width="1689"/>
     </p>
     <p>
      <img alt="" height="206" src="https://i-blog.csdnimg.cn/direct/47ad1faf171946939856f6558c891c41.png" width="789"/>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        因此这个FILE里面一定封装了fd文件描述符
       </strong>
      </span>
     </p>
    </blockquote>
    <h2 id="c%E8%AF%AD%E8%A8%80%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E5%AF%B9%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%B0%81%E8%A3%85" name="c%E8%AF%AD%E8%A8%80%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E5%AF%B9%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%B0%81%E8%A3%85" style="background-color:transparent">
     c语言上的文件操作函数，本质底层都是对系统调用的封装
    </h2>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       写如下代码：
      </span>
     </p>
     <pre><code class="language-cpp">  FILE* fp = fopen("log.txt", "w");
  
  if(fp == NULL)
  {
    perror("fopen");
    return 1;
  }
  printf("fd: %d\n",fp-&gt;_fileno);

  fwrite("hello\n", 5, 1, fp);

  fclose(fp);
</code></pre>
     <p>
      <span style="color:#0d0016">
       运行结果：这就证明了我们的FILE结构体中封装了fd文件描述符，
       <img alt="" height="187" src="https://i-blog.csdnimg.cn/direct/558c9c2ef38d4e068d11c0eb8c6663e2.png" width="945"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       更进一步：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       代码：
      </span>
     </p>
     <pre><code class="language-cpp">  FILE* fp1 = fopen("log1.txt", "w");
  
  if(fp1 == NULL)
  {
    perror("fopen");
    return 1;
  }
  printf("fd1: %d\n",fp1-&gt;_fileno);


  FILE* fp2 = fopen("log2.txt", "w");
  
  if(fp2 == NULL)
  {
    perror("fopen");
    return 1;
  }
  printf("fd2: %d\n",fp2-&gt;_fileno);

  FILE* fp3 = fopen("log3.txt", "w");
  
  if(fp3 == NULL)
  {
    perror("fopen");
    return 1;
  }
  printf("fd3: %d\n",fp3-&gt;_fileno);

  fclose(fp1);
  fclose(fp2);
  fclose(fp3);</code></pre>
     <p>
      <span style="color:#0d0016">
       输出结果：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/6ff4df5e28b54dc48bdb0ed14f244bbe.png" width="828"/>
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       c语言的stdout:stdin:stderr:
      </span>
     </p>
     <pre><code class="language-cpp">
  printf("stdin -&gt;fd: %d\n", stdin-&gt;_fileno);
  printf("stdout-&gt;fd: %d\n", stdout-&gt;_fileno);
  printf("stderr-&gt;fd: %d\n", stderr-&gt;_fileno);

</code></pre>
     <p>
      <span style="color:#0d0016">
       最后输出
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       <img alt="" height="374" src="https://i-blog.csdnimg.cn/direct/7219c4f128f345eba563bbff54dba732.png" width="883"/>
      </span>
     </p>
    </blockquote>
    <h2 id="c%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%3A" name="c%E8%AF%AD%E8%A8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%3A" style="background-color:transparent">
     <span style="color:#0d0016">
      c语言为什么要这么做:
     </span>
    </h2>
    <p>
     <span style="color:#0d0016">
      本来可以使用系统调用，也可以使用语言提供的文件方法
     </span>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       系统不一样，系统调用接口就不一样，代码不具有跨平台性，而为什么c语言、c++....等所有的语言都具有跨平台性的原因和作用我们现在就知道了。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       如图：
      </span>
     </p>
     <p>
      <img alt="" height="479" src="https://i-blog.csdnimg.cn/direct/4aaff288a9964cdcb70e4b7009f2031d.png" width="856"/>
     </p>
     <p style="text-align:center">
      <strong>
       <span style="color:#fe2c24">
        所有的语言要对不同的平台的系统调用进行封装，不同语言封装时，文件接口就有差别了
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
     <span style="color:#0d0016">
      在c++中的cin、cout、cerr可以向文件，显示器都写，我们称他们为流，但cin、cout、cerr在c++中都叫做类，他们内部一定包含了文件描述符。
     </span>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       通过进程pid找到fd
      </span>
     </p>
     <p>
      <img alt="" height="899" src="https://i-blog.csdnimg.cn/direct/d05315dae1184f7eb05bf2b6fd37a3f7.png" width="1709"/>
      终端文件：
     </p>
     <p>
      <img alt="" height="671" src="https://i-blog.csdnimg.cn/direct/589bb79191ac48d1bf9bc1722d63ebb4.png" width="1889"/>
     </p>
     <p>
      这个终端也是属于一个文件，因此实际上我也可以向这个终端直接写东西：
     </p>
     <p>
      <img alt="" height="587" src="https://i-blog.csdnimg.cn/direct/eaaa59435dcd4d5bbd0223ffcff29a86.png" width="633"/>
     </p>
     <p>
      运行结果：
      <img alt="" height="574" src="https://i-blog.csdnimg.cn/direct/fb43d24d7a3e48bfbd3b91f6e40acb58.png" width="1672"/>
     </p>
    </blockquote>
    <p>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       结语：
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       随着这篇关于题目解析的博客接近尾声，我衷心希望我所分享的内容能为你带来一些启发和帮助。学习和理解的过程往往充满挑战，但正是这些挑战让我们不断成长和进步。我在准备这篇文章时，也深刻体会到了学习与分享的乐趣。
      </span>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#0d0016">
       在此，我要特别感谢每一位阅读到这里的你。是你的关注和支持，给予了我持续写作和分享的动力。我深知，无论我在某个领域有多少见解，都离不开大家的鼓励与指正。因此，如果你在阅读过程中有任何疑问、建议或是发现了文章中的不足之处，都欢迎你慷慨赐教。
      </span>
     </p>
     <p>
      <span style="color:#0d0016">
       你的每一条反馈都是我前进路上的宝贵财富。同时，我也非常期待能够得到你的点赞、收藏，关注这将是对我莫大的支持和鼓励。当然，我更期待的是能够持续为你带来有价值的内容，让我们在知识的道路上共同前行。
      </span>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f37373735363134312f:61727469636c652f64657461696c732f313436323737383638" class_="artid" style="display:none">
 </p>
</div>


