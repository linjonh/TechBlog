---
layout: post
title: "Redis如何保证Redis缓存与数据库的一致性"
date: 2024-11-06 20:32:22 +0800
description: "但是这个方案会有⼀个缺点就是会对业务代码造成大量的侵入，深深的耦合在⼀起，所以这时会有⼀个优化的方法"
keywords: "redis缓存如何与数据库保持一致"
categories: ['Redis']
tags: ['缓存', '数据库', 'Redis']
artid: "132752377"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=132752377
    alt: "Redis如何保证Redis缓存与数据库的一致性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=132752377
featuredImagePreview: https://bing.ee123.net/img/rand?artid=132752377
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Redis】如何保证Redis缓存与数据库的一致性？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <a href="#1_1" rel="nofollow">
        1、四种同步策略
       </a>
      </li>
      <li>
       <a href="#2_13" rel="nofollow">
        2、更新缓存还是删除缓存
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#21__16" rel="nofollow">
          2.1 更新缓存
         </a>
        </li>
        <li>
         <a href="#22__21" rel="nofollow">
          2.2 删除缓存
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#3_26" rel="nofollow">
        3、先操作数据库还是缓存
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#31__30" rel="nofollow">
          3.1 先删除缓存再更新数据库
         </a>
        </li>
        <li>
         <a href="#32__38" rel="nofollow">
          3.2 先更新数据库再删除缓存
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#4_79" rel="nofollow">
        4、延时双删
       </a>
      </li>
      <li>
       <ul>
        <li>
         <a href="#41__98" rel="nofollow">
          4.1 采用读写分离的架构怎么办？
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#5_116" rel="nofollow">
        5、利用消息队列进行删除的补偿
       </a>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h2>
     <a id="1_1">
     </a>
     1、四种同步策略
    </h2>
    <p>
     想要保证缓存与数据库的双写一致，一共有4种方式，即4种同步策略：
    </p>
    <ul>
     <li>
      先更新缓存，再更新数据库；
     </li>
     <li>
      先更新数据库，再更新缓存；
     </li>
     <li>
      先删除缓存，再更新数据库；
     </li>
     <li>
      先更新数据库，再删除缓存。
     </li>
    </ul>
    <p>
     从这4种同步策略中，我们需要作出比较的是：
    </p>
    <blockquote>
     <p>
      更新缓存与删除缓存哪种方式更合适？应该先操作数据库还是先操作缓存？
     </p>
    </blockquote>
    <h2>
     <a id="2_13">
     </a>
     2、更新缓存还是删除缓存
    </h2>
    <p>
     下面，我们来分析一下，应该采用更新缓存还是删除缓存的方式。
    </p>
    <h3>
     <a id="21__16">
     </a>
     2.1 更新缓存
    </h3>
    <ul>
     <li>
      <p>
       优点：每次数据变化都及时更新缓存，所以查询时不容易出现未命中的情况。
      </p>
     </li>
     <li>
      <p>
       缺点：更新缓存的消耗比较大。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。
      </p>
     </li>
    </ul>
    <h3>
     <a id="22__21">
     </a>
     2.2 删除缓存
    </h3>
    <ul>
     <li>
      <p>
       优点：操作简单，无论更新操作是否复杂，都是将缓存中的数据直接删除。
      </p>
     </li>
     <li>
      <p>
       缺点：删除缓存后，下一次查询缓存会出现未命中，这时需要重新读取一次数据库。从上面的比较来看，一般情况下，删除缓存是更优的方案。
      </p>
     </li>
    </ul>
    <h2>
     <a id="3_26">
     </a>
     3、先操作数据库还是缓存
    </h2>
    <p>
     下面，我们再来分析一下，应该先操作数据库还是先操作缓存。
     <br/>
     首先，我们将先删除缓存与先更新数据库，在出现失败时进行一个对比：
    </p>
    <h3>
     <a id="31__30">
     </a>
     3.1 先删除缓存再更新数据库
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0383e2e5e4740becdc537c8fedbbd2bb.png"/>
    </p>
    <p>
     如上图，是先删除缓存再更新数据库，在出现失败时可能出现的问题：
    </p>
    <ul>
     <li>
      线程A删除缓存成功，线程A更新数据库失败；
     </li>
     <li>
      线程B从缓存中读取数据；由于缓存被删，进程B无法从缓存中得到数据，进而从数据库读取数据；此时数据库中的数据更新失败，线程B从数据库成功获取旧的数据，然后将数据更新到了缓存。
     </li>
     <li>
      最终，缓存和数据库的数据是一致的，但仍然是旧的数据
     </li>
    </ul>
    <h3>
     <a id="32__38">
     </a>
     3.2 先更新数据库再删除缓存
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/0304945ae1aa29405f34a8ca8065c378.png"/>
    </p>
    <p>
     如上图，是先更新数据库再删除缓存，在出现失败时可能出现的问题：
    </p>
    <ul>
     <li>
      线程A更新数据库成功，线程A删除缓存失败；
     </li>
     <li>
      线程B读取缓存成功，由于缓存删除失败，所以线程B读取到的是缓存中旧的数据。
     </li>
     <li>
      最后线程A删除缓存成功，有别的线程访问缓存同样的数据，与数据库中的数据是一样。
     </li>
     <li>
      最终，缓存和数据库的数据是一致的，但是会有一些线程读到旧的数据。
     </li>
    </ul>
    <p>
     经过上面的比较，我们发现在出现失败的时候，是无法明确分辨出先删缓存和先更新数据库哪个方式更好，以为它们都存在问题。后面我们会进一步对这两种方式进行比较，但是在这里我们先探讨一下，上述场景出现的问题，应该如何解决呢？
    </p>
    <p>
     实际上，无论上面我们采用哪种方式去同步缓存与数据库，在第二步出现失败的时候，都建议采用重试机制解决，上面两幅图中已经画了。
    </p>
    <p>
     下面我们再将先删缓存与先更新数据库，在没有出现失败时进行对比：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/6f92354b10acf7f476678527d935db36.png"/>
    </p>
    <p>
     如上图，是先删除缓存再更新数据库，在没有出现失败时可能出现的问题：
    </p>
    <ul>
     <li>
      线程A删除缓存成功；
     </li>
     <li>
      线程B读取缓存失败；
     </li>
     <li>
      线程B读取数据库成功，得到旧的数据；
     </li>
     <li>
      线程B将旧的数据成功地更新到了缓存；
     </li>
     <li>
      线程A将新的数据成功地更新到数据库。
     </li>
    </ul>
    <p>
     可见，进程A的两步操作均成功，但由于存在并发，在这两步之间，进程B访问了缓存。最终结果是，缓存中存储了旧的数据，而数据库中存储了新的数据，二者数据不一致。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a540fbbdc6d7f7a8ac8ed81f7952345e.png"/>
    </p>
    <p>
     如上图，是先更新数据库再删除缓存，在没有出现失败时可能出现的问题：
    </p>
    <ul>
     <li>
      线程A更新数据库成功；
     </li>
     <li>
      线程B读取缓存成功；
     </li>
     <li>
      线程A删除缓存成功。
     </li>
    </ul>
    <p>
     可见，最终缓存与数据库的数据是一致的，并且都是最新的数据。但线程B在这个过程里读到了旧的数据，可能还有其他线程也像线程B一样，在这两步之间读到了缓存中旧的数据，但因为这两步的执行速度会比较快，所以影响不大。对于这两步之后，其他进程再读取缓存数据的时候，就不会出现类似于进程B的问题了。
    </p>
    <blockquote>
     <p>
      最终结论：
     </p>
     <p>
      经过对比你会发现，先更新数据库、再删除缓存是影响更小的方案。如果第二步出现失败的情况，则可以采用重试机制解决问题。
     </p>
    </blockquote>
    <h2>
     <a id="4_79">
     </a>
     4、延时双删
    </h2>
    <p>
     上面我们提到，如果是先删缓存、再更新数据库，在没有出现失败时可能会导致数据的不一致。如果在实际的应用中，出于某些考虑我们需要选择这种方式，那有办法解决这个问题吗？答案是有的，那就是采用延时双删的策略，延时双删的基本思路如下：
    </p>
    <ul>
     <li>
      删除缓存；
     </li>
     <li>
      更新数据库；
     </li>
     <li>
      sleep N毫秒；
     </li>
     <li>
      再次删除缓存。
     </li>
    </ul>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Redis</span><span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Redis</span><span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     阻塞一段时间之后，再次删除缓存，就可以把这个过程中缓存中不一致的数据删除掉。而具体的时间，要评估你这项业务的大致时间，按照这个时间来设定即可。
    </p>
    <h3>
     <a id="41__98">
     </a>
     4.1 采用读写分离的架构怎么办？
    </h3>
    <p>
     如果数据库采用的是读写分离的架构，那么又会出现新的问题，如下图：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/73f013d06c4cc8d92b0371a68ce04e7d.png"/>
    </p>
    <p>
     此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）
    </p>
    <ul>
     <li>
      请求 A 更新操作，删除了 Redis；
     </li>
     <li>
      请求主库进⾏更新操作，主库与从库进行同步数据的操作；
     </li>
     <li>
      请 B 查询操作，发现 Redis 中没有数据；
     </li>
     <li>
      去从库中拿去数据；
     </li>
     <li>
      此时同步数据还未完成，拿到的数据是旧数据；
     </li>
    </ul>
    <p>
     此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进⾏查询。
    </p>
    <p>
     删除失败了怎么办？
    </p>
    <p>
     如果删除依然失败，则可以增加重试的次数，但是这个次数要有限制，当超出一定的次数时，要采取报错、记日志、发邮件提醒等措施。
    </p>
    <h2>
     <a id="5_116">
     </a>
     5、利用消息队列进行删除的补偿
    </h2>
    <p>
     先更新数据库，后删除缓存这⼀种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d75d6e3609d03d1e90d54b70307e03c2.png"/>
    </p>
    <p>
     此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑⽤语⾔描述如下：
    </p>
    <ul>
     <li>
      请求 线程A 先对数据库进行更新操作；
     </li>
     <li>
      在对 Redis 进行删除操作的时候发现报错，删除失败；
     </li>
     <li>
      此时将Redis 的 key 作为消息体发送到消息队列中；
     </li>
     <li>
      系统接收到消息队列发送的消息后再次对 Redis 进行删除操作；
     </li>
    </ul>
    <p>
     但是这个方案会有⼀个缺点就是会对业务代码造成大量的侵入，深深的耦合在⼀起，所以这时会有⼀个优化的方法，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/49da9a7b1c0abf15026cf727533f0a7c.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f753031313339373938312f:61727469636c652f64657461696c732f313332373532333737" class_="artid" style="display:none">
 </p>
</div>


