---
layout: post
title: "HarmonyOS-Next-状态管理ObserverV2和Trace-装饰器实践"
date: 2025-03-14 11:02:40 +0800
description: "在组件化开发中，我们常常需要对类对象的属性进行观测，以便在属性变化时自动更新 UI。和@Trace正是为此设计的修饰器。：用于装饰类，表明该类是可被观察的。单独使用无效，必须与@Trace配合使用。@Trace：用于装饰类的属性，表示该属性可以被精确跟踪和观察。@Trace只能在被装饰的类中使用。通过和@Trace修饰器，我们可以实现对类属性的精确观测，并在属性变化时自动更新 UI。搭配使用必须与@Trace搭配使用。属性观测：只有被@Trace装饰的属性在变化时才会触发 UI 刷新。嵌套与继承。"
keywords: "HarmonyOS Next 状态管理：ObserverV2和Trace 装饰器实践"
categories: ['鸿蒙原生开发']
tags: ['华为', 'Harmonyos']
artid: "146252268"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146252268
    alt: "HarmonyOS-Next-状态管理ObserverV2和Trace-装饰器实践"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146252268
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146252268
cover: https://bing.ee123.net/img/rand?artid=146252268
image: https://bing.ee123.net/img/rand?artid=146252268
img: https://bing.ee123.net/img/rand?artid=146252268
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     HarmonyOS Next 状态管理：ObserverV2和Trace 装饰器实践
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="_0">
     </a>
     目录
    </h4>
    <ul>
     <li>
      <a href="https://juejin.cn/post/7474067702320676890" rel="nofollow">
       HarmonyOS Next 状态管理：Local 装饰器实践
      </a>
     </li>
     <li>
      <a href="https://juejin.cn/post/7474450687356026917" rel="nofollow">
       HarmonyOS Next 状态管理：Param 装饰器实践
      </a>
     </li>
     <li>
      <a href="https://juejin.cn/spost/7476717539549839411" rel="nofollow">
       HarmonyOS Next 状态管理：Once 装饰器实践
      </a>
     </li>
     <li>
      <a href="https://juejin.cn/post/7476717539550969907" rel="nofollow">
       HarmonyOS Next 状态管理：Event 装饰器实践
      </a>
     </li>
     <li>
      <a href="https://juejin.cn/spost/7477188513415577611" rel="nofollow">
       HarmonyOS Next 状态管理：!! 状态装饰器实践
      </a>
     </li>
     <li>
      <a href="https://juejin.cn/spost/7477541534607917097" rel="nofollow">
       HarmonyOS Next 状态管理：@ObserverV2和@Trace 装饰器实践
      </a>
     </li>
     <li>
      <a href="https://juejin.cn/post/7479368570759446538" rel="nofollow">
       HarmonyOS Next 状态管理：Provider和Consumer 装饰器实践
      </a>
     </li>
    </ul>
    <h4>
     <a id="_ObserverV2Trace__10">
     </a>
     一、 @ObserverV2和@Trace 修饰器概述
    </h4>
    <p>
     在组件化开发中，我们常常需要对类对象的属性进行观测，以便在属性变化时自动更新 UI。
     <code>
      @ObservedV2
     </code>
     和
     <code>
      @Trace
     </code>
     正是为此设计的修饰器。
    </p>
    <ul>
     <li>
      <strong>
       <code>
        @ObservedV2
       </code>
      </strong>
      ：用于装饰类，表明该类是可被观察的。单独使用
      <code>
       @ObservedV2
      </code>
      无效，必须与
      <code>
       @Trace
      </code>
      配合使用。
     </li>
     <li>
      <strong>
       <code>
        @Trace
       </code>
      </strong>
      ：用于装饰类的属性，表示该属性可以被精确跟踪和观察。
      <code>
       @Trace
      </code>
      只能在被
      <code>
       @ObservedV2
      </code>
      装饰的类中使用。
     </li>
    </ul>
    <h4>
     <a id="ObserverV2Trace__17">
     </a>
     二、@ObserverV2和@Trace 修饰器的限制
    </h4>
    <p>
     <strong>
      使用范围
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       @ObservedV2
      </code>
      和
      <code>
       @Trace
      </code>
      只能在
      <code>
       ComponentV2
      </code>
      中使用。
     </li>
    </ul>
    <p>
     <strong>
      搭配使用
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       @ObservedV2
      </code>
      必须与
      <code>
       @Trace
      </code>
      搭配使用，单独使用任意一个修饰器都不会生效。
     </li>
    </ul>
    <p>
     <strong>
      属性观测
     </strong>
     ：
    </p>
    <ul>
     <li>
      只有被
      <code>
       @Trace
      </code>
      装饰的属性在变化时，才会通知关联的组件进行 UI 刷新。
     </li>
     <li>
      未被
      <code>
       @Trace
      </code>
      装饰的属性无法触发 UI 刷新，即使其值发生变化。
     </li>
    </ul>
    <p>
     <strong>
      嵌套类
     </strong>
     ：
    </p>
    <ul>
     <li>
      在嵌套类中，只有嵌套类的属性被
      <code>
       @Trace
      </code>
      装饰，且嵌套类本身被
      <code>
       @ObservedV2
      </code>
      装饰时，才能触发 UI 刷新。
     </li>
    </ul>
    <p>
     <strong>
      继承类
     </strong>
     ：
    </p>
    <ul>
     <li>
      在继承类中，父类或子类的属性被
      <code>
       @Trace
      </code>
      装饰，且该属性所在的类被
      <code>
       @ObservedV2
      </code>
      装饰时，才能触发 UI 刷新。
     </li>
    </ul>
    <h4>
     <a id="_40">
     </a>
     三、实践探索
    </h4>
    <h5>
     <a id="31_ObserverV2Trace__42">
     </a>
     3.1 @ObserverV2和@Trace 的简单使用
    </h5>
    <p>
     @ObservedV2
     <br/>
     class UserInfo {
     <!-- -->
     <br/>
     @Trace name: string
     <br/>
     age: number
    </p>
    <p>
     constructor(name: string, age: number) {
     <!-- -->
     <br/>
     this.name = name
     <br/>
     this.age = age
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     @Entry
     <br/>
     @ComponentV2
     <br/>
     struct Index {
     <!-- -->
     <br/>
     userInfo1: UserInfo = new UserInfo(“孙膑”, 29)
     <br/>
     @Local userInfo2: UserInfo = new UserInfo(“张仪”, 26)
     <br/>
     build() {
     <!-- -->
     <br/>
     Column({space: 20}) {
     <!-- -->
     <br/>
     Row({space: 8}) {
     <!-- -->
     <br/>
     Text(
     <code>
      User-1,name:${this.userInfo1.name}
     </code>
     )
     <br/>
     Text(
     <code>
      age:${this.userInfo1.age}
     </code>
     )
     <br/>
     }
     <br/>
     Row({space: 8}) {
     <!-- -->
     <br/>
     Text(
     <code>
      User-2,name:${this.userInfo2.name}
     </code>
     )
     <br/>
     Text(
     <code>
      age:${this.userInfo2.age}
     </code>
     )
     <br/>
     }
     <br/>
     Button(‘update name’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfo1.name += “-user1”
     <br/>
     this.userInfo2.name += “-user2”
     <br/>
     })
     <br/>
     Button(‘update age’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfo1.age++
     <br/>
     this.userInfo2.age++
     <br/>
     })
     <br/>
     }
     <br/>
     .width(‘100%’)
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     <img alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2F053af14e2dff4f9da00c2e27c6347c50~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyI5pyq5aSu%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTY3OTcwOTQ5NDg0OTYyMyJ9%26rk3s%3Df64ab15b%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1742524674%26x-orig-sign%3De51MyMmJsTs1Zddf65db9ZAI3Is%253D&amp;pos_id=img-tQeOSDGM-1741921346893"/>
    </p>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       @ObserverV2
      </code>
      和
      <code>
       @Trace
      </code>
      装饰的类在组件中创建的时候，是否加其他装饰器修饰不影响属性的观测。
     </li>
     <li>
      只有
      <code>
       @Trace
      </code>
      装饰的属性在变化的时候才会刷新UI（例如：name），非
      <code>
       @Trace
      </code>
      装饰的属性在变化时不会刷新UI（例如：age）
     </li>
    </ul>
    <h5>
     <a id="32_ObserverV2Trace_92">
     </a>
     3.2 在类的嵌套中使用@ObserverV2和@Trace
    </h5>
    <p>
     @ObservedV2
     <br/>
     class Address {
     <!-- -->
     <br/>
     @Trace country: string
    </p>
    <p>
     constructor(country: string) {
     <!-- -->
     <br/>
     this.country = country
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     class Person {
     <!-- -->
     <br/>
     name: string
     <br/>
     address: Address
    </p>
    <p>
     constructor(name: string, country: string) {
     <!-- -->
     <br/>
     this.name = name
     <br/>
     this.address = new Address(country)
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     @Entry
     <br/>
     @ComponentV2
     <br/>
     struct Index {
     <!-- -->
     <br/>
     userInfo: UserInfo = new UserInfo(“孙膑”, “齐国”)
     <br/>
     person: Person = new Person(“庞涓”, “魏国”)
    </p>
    <p>
     build() {
     <!-- -->
     <br/>
     Column({space: 20}) {
     <!-- -->
     <br/>
     Row({space: 8}) {
     <!-- -->
     <br/>
     Text(
     <code>
      name:${this.userInfo.name}
     </code>
     )
     <br/>
     Text(
     <code>
      country:${this.userInfo.address.country}
     </code>
     )
     <br/>
     }
     <br/>
     Line().width(‘100%’).height(1).backgroundColor(Color.Gray)
     <br/>
     Row({space: 8}) {
     <!-- -->
     <br/>
     Text(
     <code>
      person_name:${this.person.name}
     </code>
     )
     <br/>
     Text(
     <code>
      person_country:${this.person.address.country}
     </code>
     )
     <br/>
     }
     <br/>
     Button(‘update update’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfo.address.country = (this.userInfo.address.country == “齐国” ? “中国” : “齐国”)
     <br/>
     this.person.address.country = (this.person.address.country == “魏国” ? “中国” : “魏国”)
     <br/>
     })
     <br/>
     }
     <br/>
     .width(‘100%’)
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     <img alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2F4de0665062a14002b768d4cf8e39a663~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyI5pyq5aSu%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTY3OTcwOTQ5NDg0OTYyMyJ9%26rk3s%3Df64ab15b%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1742524674%26x-orig-sign%3Dz59tpE4ixpgddEJ5XmD5TuytFKs%253D&amp;pos_id=img-hpchW5r6-1741921346895"/>
    </p>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       嵌套类观测
      </strong>
      ：嵌套类中的属性必须被
      <code>
       @Trace
      </code>
      装饰，且嵌套类本身必须被
      <code>
       @ObservedV2
      </code>
      装饰，才能触发 UI 刷新。
     </li>
     <li>
      <strong>
       非观测属性
      </strong>
      ：未被
      <code>
       @Trace
      </code>
      装饰的属性（如
      <code>
       Person
      </code>
      类中的
      <code>
       name
      </code>
      ）在变化时不会触发 UI 刷新
     </li>
    </ul>
    <h5>
     <a id="33_ObserverV2Trace_147">
     </a>
     3.3 在继承类中使用@ObserverV2和@Trace
    </h5>
    <h6>
     <a id="331__ObserverV2TraceObserverV2Trace_149">
     </a>
     3.3.1 实践一, 父类不使用@ObserverV2和@Trace来装饰，子类使用@ObserverV2和@Trace来装饰
    </h6>
    <p>
     class Person {
     <!-- -->
     <br/>
     name: string
    </p>
    <p>
     constructor(name: string) {
     <!-- -->
     <br/>
     this.name = name
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     @ObservedV2
     <br/>
     class UserInfo extends Person {
     <!-- -->
     <br/>
     @Trace age: number
    </p>
    <p>
     constructor(name: string, age: number) {
     <!-- -->
     <br/>
     super(name)
     <br/>
     this.age = age
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     @Entry
     <br/>
     @ComponentV2
     <br/>
     struct Index {
     <!-- -->
     <br/>
     userInfo: UserInfo = new UserInfo(“孙膑”, 29)
    </p>
    <p>
     build() {
     <!-- -->
     <br/>
     Column({space: 20}) {
     <!-- -->
     <br/>
     Text(
     <code>
      name:${this.userInfo.name}
     </code>
     )
     <br/>
     Text(
     <code>
      age:${this.userInfo.age}
     </code>
     )
     <br/>
     Button(‘change value’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfo.name = (this.userInfo.name === “孙膑” ? “庞涓” : “孙膑”)
     <br/>
     this.userInfo.age++
     <br/>
     })
     <br/>
     }
     <br/>
     .width(‘100%’)
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     <img alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2F8d64ece007f54b798b8bb76780de6fd9~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyI5pyq5aSu%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTY3OTcwOTQ5NDg0OTYyMyJ9%26rk3s%3Df64ab15b%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1742524674%26x-orig-sign%3DzEj8P1U4MpVWvCuGV9weDMc93xw%253D&amp;pos_id=img-OPT6puK1-1741921346895"/>
    </p>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       子类属性观测
      </strong>
      ：子类中被
      <code>
       @Trace
      </code>
      装饰的属性（如
      <code>
       age
      </code>
      ）在变化时会触发 UI 刷新。
     </li>
     <li>
      <strong>
       父类属性
      </strong>
      ：父类中未被
      <code>
       @Trace
      </code>
      装饰的属性（如
      <code>
       name
      </code>
      ）在变化时不会触发 UI 刷新。
     </li>
    </ul>
    <h6>
     <a id="332__ObserverV2TraceObserverV2Trace_195">
     </a>
     3.3.2 实践二, 父类使用@ObserverV2和@Trace来装饰，子类不使用@ObserverV2和@Trace来装饰
    </h6>
    <p>
     @ObservedV2
     <br/>
     class Person {
     <!-- -->
     <br/>
     @Trace name: string
    </p>
    <p>
     constructor(name: string) {
     <!-- -->
     <br/>
     this.name = name
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     class UserInfo extends Person {
     <!-- -->
     <br/>
     age: number
    </p>
    <p>
     constructor(name: string, age: number) {
     <!-- -->
     <br/>
     super(name)
     <br/>
     this.age = age
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     @Entry
     <br/>
     @ComponentV2
     <br/>
     struct Index {
     <!-- -->
     <br/>
     userInfo: UserInfo = new UserInfo(“孙膑”, 29)
    </p>
    <p>
     build() {
     <!-- -->
     <br/>
     Column({space: 20}) {
     <!-- -->
     <br/>
     Text(
     <code>
      name:${this.userInfo.name}
     </code>
     )
     <br/>
     Text(
     <code>
      age:${this.userInfo.age}
     </code>
     )
     <br/>
     Button(‘change value’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfo.name = (this.userInfo.name === “孙膑” ? “庞涓” : “孙膑”)
     <br/>
     this.userInfo.age++
     <br/>
     })
     <br/>
     }
     <br/>
     .width(‘100%’)
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     <img alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2F34a3ac08f81a4feeb3543b868bcb12f5~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyI5pyq5aSu%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTY3OTcwOTQ5NDg0OTYyMyJ9%26rk3s%3Df64ab15b%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1742524674%26x-orig-sign%3DYBnJXEZZZiERHtqBc5s3nT2337E%253D&amp;pos_id=img-0LdTvusN-1741921346895"/>
    </p>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       继承属性观测
      </strong>
      ：子类会继承父类中被
      <code>
       @Trace
      </code>
      装饰的属性的观测能力。
     </li>
     <li>
      <strong>
       非观测属性
      </strong>
      ：子类中未被
      <code>
       @Trace
      </code>
      装饰的属性（如
      <code>
       age
      </code>
      ）在变化时不会触发 UI 刷新。
     </li>
    </ul>
    <h5>
     <a id="34_ObserverV2Trace_242">
     </a>
     3.4 容器中的类使用@ObserverV2和@Trace
    </h5>
    <p>
     @ObservedV2
     <br/>
     class UserInfo {
     <!-- -->
     <br/>
     @Trace name: string
     <br/>
     @Trace age: number
    </p>
    <p>
     constructor(name: string, age: number) {
     <!-- -->
     <br/>
     this.name = name
     <br/>
     this.age = age
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     @Entry
     <br/>
     @ComponentV2
     <br/>
     struct Index {
     <!-- -->
     <br/>
     @Local userInfos: UserInfo[] = [new UserInfo(“孙膑”, 29)]
    </p>
    <p>
     build() {
     <!-- -->
     <br/>
     Column({space: 20}) {
     <!-- -->
     <br/>
     ForEach(this.userInfos, (userInfo: UserInfo) =&gt; {
     <!-- -->
     <br/>
     Text(
     <code>
      name:${userInfo.name}
     </code>
     )
     <br/>
     Text(
     <code>
      age:${userInfo.age}
     </code>
     )
    </p>
    <p>
     Line().width(‘100%’).height(1).backgroundColor(Color.Gray)
     <br/>
     })
     <br/>
     Button(‘add item’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfos.push(new UserInfo(“庞涓”, 31))
     <br/>
     })
     <br/>
     Button(‘change property’)
     <br/>
     .onClick(() =&gt; {
     <!-- -->
     <br/>
     this.userInfos[0].name =
     <code>
      ${Math.round(Math.random() * 100)}
     </code>
     <br/>
     this.userInfos[0].age++
     <br/>
     })
     <br/>
     }
     <br/>
     .width(‘100%’)
     <br/>
     }
     <br/>
     }
    </p>
    <p>
     <img alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2F5ecec8aa8158411b99d08aa26d7d8ef7~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pyI5pyq5aSu%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTY3OTcwOTQ5NDg0OTYyMyJ9%26rk3s%3Df64ab15b%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1742524674%26x-orig-sign%3DuEA7P6uymkHF2rOGkZjHB3fTpgQ%253D&amp;pos_id=img-9hjPQvnf-1741921346895"/>
    </p>
    <p>
     <strong>
      关键点
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       容器中的对象观测
      </strong>
      ：容器中的对象如果被
      <code>
       @ObservedV2
      </code>
      和
      <code>
       @Trace
      </code>
      装饰，其属性变化时会触发 UI 刷新。
     </li>
     <li>
      <strong>
       动态更新
      </strong>
      ：通过操作容器（如添加或修改对象），可以动态更新 UI。
     </li>
    </ul>
    <h4>
     <a id="_289">
     </a>
     四、总结
    </h4>
    <p>
     通过
     <code>
      @ObservedV2
     </code>
     和
     <code>
      @Trace
     </code>
     修饰器，我们可以实现对类属性的精确观测，并在属性变化时自动更新 UI。关键点包括：
    </p>
    <ol>
     <li>
      <strong>
       搭配使用
      </strong>
      ：
      <code>
       @ObservedV2
      </code>
      必须与
      <code>
       @Trace
      </code>
      搭配使用。
     </li>
     <li>
      <strong>
       属性观测
      </strong>
      ：只有被
      <code>
       @Trace
      </code>
      装饰的属性在变化时才会触发 UI 刷新。
     </li>
     <li>
      <strong>
       嵌套与继承
      </strong>
      ：在嵌套类和继承类中，需要确保属性和类被正确装饰，才能实现属性观测。
     </li>
     <li>
      <strong>
       容器中的对象
      </strong>
      ：容器中的对象如果被正确装饰，其属性变化也会触发 UI 刷新。
     </li>
    </ol>
    <p>
     通过合理使用
     <code>
      @ObservedV2
     </code>
     和
     <code>
      @Trace
     </code>
     ，可以显著提升组件化开发的效率和代码的可维护性。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6b69645f646576696c2f:61727469636c652f64657461696c732f313436323532323638" class_="artid" style="display:none">
 </p>
</div>


