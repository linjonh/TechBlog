---
arturl_encode: "6874747073:3a2f2f626c6f672e6373646e2e6e65742f626967636172702f:61727469636c652f64657461696c732f313436323439383637"
layout: post
title: "理解langchain-langgraph-官方文档示例代码中的MemorySaver"
date: 2025-03-14 10:41:27 +0800
description: "中间件有什么特征：它在程序执行过程中某些数据流的环节介入，并根据设定的逻辑对部分数据进行加工或调整数据的流向，而这一切对用户来说是透明的，看不见的，像一只看不见的手在那里做了些什么。在这里中的作用类似于一个“中间件”，workflow编译的时候提供了一个“检查点（Checkpointing）”让这个中间件介入进去，让这个看不见的手去捕获并加工里面数据。节点 (Nodes): 节点是工作流中的执行单元，每个节点都关联一个函数，该函数定义了节点的执行逻辑。：标记节点及节点的状态，定义节点之间的连接和流向。"
keywords: "langgraph state如何保存到memoru"
categories: ['未分类']
tags: ['前端', 'Langchain', 'Java']
artid: "146249867"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146249867
    alt: "理解langchain-langgraph-官方文档示例代码中的MemorySaver"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146249867
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146249867
cover: https://bing.ee123.net/img/rand?artid=146249867
image: https://bing.ee123.net/img/rand?artid=146249867
img: https://bing.ee123.net/img/rand?artid=146249867
---

# 理解langchain langgraph 官方文档示例代码中的MemorySaver

以下是langchain v0.3官方示例代码

```python
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import START, MessagesState, StateGraph

# 可以理解为：定义一个流程，这个流程中用到的数据类型是Messages。 <---定义一个有向图，指定状态模式/格式/规范为 MessagesState这种规范
workflow = StateGraph(state_schema=MessagesState)


# 定义调用模型的函数
def call_model(state: MessagesState):
    response = model.invoke(state["messages"])
    return {"messages": response}


# 整个流程只有一个节点，可谓是最简单的任务流了
workflow.add_edge(START, "model")
workflow.add_node("model", call_model)

# 把“记忆保存器”这个中间件注入到流程中
memory = MemorySaver()
app = workflow.compile(checkpointer=memory)

config = {"configurable": {"thread_id": "abc123"}}

query = "Hi! I'm Bob."

input_messages = [HumanMessage(query)]
output = app.invoke({"messages": input_messages}, config)
output["messages"][-1].pretty_print()  # output contains all messages in state

query = "What's my name?"

input_messages = [HumanMessage(query)]
output = app.invoke({"messages": input_messages}, config)
output["messages"][-1].pretty_print()
```

输出

```python
==================================[1m Ai Message [0m==================================

Hi Bob! How can I assist you today?


==================================[1m Ai Message [0m==================================

Your name is Bob! How can I help you today, Bob?
```

这里涉及到图论的基础知识，要快速了最基础概念，推荐这个视频：
[【硬核干货】图论到底是个什么玩意儿？图论入门：树与生成树 (Graph Theory: Tree and Spanning Tree)\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1dz411e7WG/ "【硬核干货】图论到底是个什么玩意儿？图论入门：树与生成树 (Graph Theory: Tree and Spanning Tree)_哔哩哔哩_bilibili")

**图 (Graph)**
：基于图论的概念，它由节点 (nodes) 和边 (edges) 组成。

节点 (Nodes): 节点是工作流中的执行单元，每个节点都关联一个函数，该函数定义了节点的执行逻辑。

边 (Edges): 边定义了节点之间的连接关系，以及工作流的执行路径。

**状态 (State)**
：标记节点及节点的状态，定义节点之间的连接和流向。--> 简单直观地理解的话，可以把State理解为我们常规编程中常用的Data

StateGraph=  State + Graph --> 依据【状态】来运作的【有向图】--->可近似理解为工作流

```python
workflow = StateGraph(state_schema=MessagesState)
```

当中，state\_schema 参数定义了这个“状态驱动的有向图” 的
状态描述格式/标准/规范
采用 MessagesState 这种数据结构的规范。

--> 更通俗理解的话，可以把它想象成是以下语句在LangGraph场景下的固有写法：

```
# 以下这是一段伪代码
workflow = LangChainWorkFlow(data_type=Messages) 
```

------ MemorySaver ------

```python
memory = MemorySaver()
app = workflow.compile(checkpointer=memory)
```

这里的MemorySaver有点像一个中间件，你可以把它当作中间件来理解。

中间件有什么特征：它在程序执行过程中某些数据流的环节介入，并根据设定的逻辑对部分数据进行加工或调整数据的流向，而这一切对用户来说是透明的，看不见的，像一只看不见的手在那里做了些什么。

* **它不是核心逻辑**
  ，但能在数据流经过时
  **插入**
  自己的逻辑。
* **它不改变程序的主要流程**
  ，但能
  **修改、过滤、检查**
  数据。
* **它对用户是透明的**
  ，但对系统来说是
  **必不可少的**
  。

#### **中间件在程序中的作用**

| **作用** | **示例** |
| --- | --- |
| **数据过滤** | 日志记录、请求验证、权限检查 |
| **数据转换** | 格式转换、加密/解密、压缩 |
| **流向控制** | 负载均衡、路由选择、错误处理 |

`MemorySaver`
在这里中的作用类似于一个“中间件”，workflow编译的时候提供了一个“检查点（checkpointer）”让这个中间件介入进去，让这个看不见的手去捕获并加工里面数据。

这个参数名叫checkpointer我觉得名字起得非常好。