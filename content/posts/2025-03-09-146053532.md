---
layout: post
title: "Unity-通用UI界面逻辑总结"
date: 2025-03-09 13:55:18 +0800
description: "介绍一些游戏开发中常会遇到的通用界面的实现逻辑，以免重复开发"
keywords: "Unity 通用UI界面逻辑总结"
categories: ['未分类']
tags: ['Unity', 'Ui']
artid: "146053532"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053532
    alt: "Unity-通用UI界面逻辑总结"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053532
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053532
cover: https://bing.ee123.net/img/rand?artid=146053532
image: https://bing.ee123.net/img/rand?artid=146053532
img: https://bing.ee123.net/img/rand?artid=146053532
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity 通用UI界面逻辑总结
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     概述
    </h2>
    <p>
     在游戏开发中，常常会遇到一些通用的界面逻辑，它不论在什么类型的游戏中都会出现。为了避免重复造轮子，本文总结并提供了一些常用UI界面的实现逻辑。希望可以帮助大家快速开发通用界面模块，也可以在次基础上进行扩展修改，以适应你项目的需求。
    </p>
    <p>
     <span style="color:#1c7331">
      <strong>
       工程链接
      </strong>
     </span>
     ：
     <a href="https://gitcode.com/qq_44809934/CommonLogic/tree/company/CommonLogic" title="GitCode - 全球开发者的开源社区,开源代码托管平台">
      GitCode - 全球开发者的开源社区,开源代码托管平台
     </a>
    </p>
    <p>
    </p>
    <h2>
     二次确认界面
    </h2>
    <p>
     <img alt="" height="323" src="https://i-blog.csdnimg.cn/direct/73827173ec91492db7101206078c48a3.png" width="483"/>
    </p>
    <pre><code class="language-cs">using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ConfirmDialog : MonoBehaviour
{
    private Text txt_title;
    private Text txt_content;
    private Button btn_Yes;
    private Button btn_No;

    void Start()
    {
        var root = gameObject.transform;
        txt_title = root.Find("txt_Title").GetComponent&lt;Text&gt;();
        txt_content = root.Find("txt_Content").GetComponent&lt;Text&gt;();
        btn_Yes = root.Find("btn/btn_Yes").GetComponent&lt;Button&gt;();
        btn_No = root.Find("btn/btn_No").GetComponent&lt;Button&gt;();
        txt_title.text = "提示";
        
        //测试代码
        InitDialog("好好学习，天天向上！", 
            () =&gt; {Debug.Log("Yes"); },
            () =&gt; {Debug.Log("No"); });
    }

    /// &lt;summary&gt;
    /// 重载一：使用默认标题 “提示”
    /// &lt;/summary&gt;
    /// &lt;param name="content"&gt;需要确认的内容&lt;/param&gt;
    /// &lt;param name="yesAction"&gt;确认按钮回调&lt;/param&gt;
    /// &lt;param name="noAction"&gt;取消按钮回调&lt;/param&gt;
    public void InitDialog(string content, UnityAction yesAction = null, UnityAction noAction = null)
    {
        txt_title.text = "提示";
        CoreLogic(content, yesAction, noAction);
    }

    /// &lt;summary&gt;
    /// 重载一：使用自定义标题
    /// &lt;/summary&gt;
    /// &lt;param name="title"&gt;自定义标题&lt;/param&gt;
    /// &lt;param name="content"&gt;需要确认的内容&lt;/param&gt;
    /// &lt;param name="yesAction"&gt;确认按钮回调&lt;/param&gt;
    /// &lt;param name="noAction"&gt;取消按钮回调&lt;/param&gt;
    public void InitDialog(string title, string content, UnityAction yesAction = null, UnityAction noAction = null)
    {
        txt_title.text = title;
        CoreLogic(content, yesAction, noAction);
    }

    //公共逻辑提取
    private void CoreLogic(string content, UnityAction yesAction = null, UnityAction noAction = null)
    {
        txt_content.text = content;
        BindBtnLogic(btn_Yes, yesAction);
        BindBtnLogic(btn_No, noAction);
        btn_Yes.gameObject.SetActive(yesAction != null);
        btn_No.gameObject.SetActive(noAction != null);
    }

    //绑定按钮点击回调
    private void BindBtnLogic(Button btn, UnityAction action)
    {
        btn.onClick.RemoveAllListeners();
        if (action != null)
        {
            btn.onClick.AddListener(action);
        }
    }
}</code></pre>
    <h2>
     切页标签
    </h2>
    <p>
     <img alt="" height="113" src="https://i-blog.csdnimg.cn/direct/ab0b45957ff44670abb84f97d1b95a9a.png" width="513"/>
    </p>
    <p>
     通过按钮来实现。虽然使用Toggle也可以实现，但是在实际开发中会发现使用toggle不好控制选中事件的触发和选中状态表现。通过按钮来自定义组件可以更好地控制逻辑的调用和标签的显示。
    </p>
    <pre><code class="language-cs">using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

class TabNode
{ 
    public int index;
    public GameObject offBg;
    public GameObject onBg;
    public Text offTxt;
    public Text onTxt;
    public Button btn;
    public UnityAction callback;
}

public class SwitchPageTab : MonoBehaviour
{
    public Transform tabRoot;//标签组的父节点
    public GameObject tabObj;//标签页预制体模板
    private int _selectIndex;//选中的标签页索引

    private List&lt;TabNode&gt; _objList = new List&lt;TabNode&gt;();
    private Dictionary&lt;int, UnityAction&gt; _callbackDic = new Dictionary&lt;int, UnityAction&gt;();
    
    private void Start()
    {
        _selectIndex = -1;
        
        InitCount(4);
        BindSelectCallback(0, "背包", (() =&gt;
        {
            Debug.Log("查看背包");
        }));
        BindSelectCallback(1, "英雄", (() =&gt;
        {
            Debug.Log("查看英雄");
        }));
        BindSelectCallback(2, "商店", (() =&gt;
        {
            Debug.Log("查看商店");
        }));
        BindSelectCallback(3, "活动", (() =&gt;
        {
            Debug.Log("查看活动");
        }));
        
        
        OnSelectLogic(0);
    }

    /// &lt;summary&gt;
    /// 初始化调用
    /// &lt;/summary&gt;
    /// &lt;param name="count"&gt;标签的数量&lt;/param&gt;
    public void InitCount(int count)
    {
        _objList.Clear();
        ClearAllChild(tabRoot);
        for (var i = 0; i &lt; count; i++)
        {
            var obj = Instantiate(tabObj, tabRoot);
            obj.SetActive(true);
            var trans = obj.transform;
            var node = new TabNode
            {
                offTxt = trans.Find("btn/offBg/offTxt").GetComponent&lt;Text&gt;(),
                onTxt = trans.Find("btn/onBg/onTxt").GetComponent&lt;Text&gt;(),
                onBg = trans.Find("btn/onBg").gameObject,
                offBg = trans.Find("btn/offBg").gameObject,
                btn = trans.Find("btn").GetComponent&lt;Button&gt;(),
            };
            var index = i;
            BindBtnLogic(node.btn, () =&gt;
            {
                OnSelectLogic(index);
            });
            _objList.Add(node);
        }
    }
    
    /// &lt;summary&gt;
    /// 绑定指定页签索引的回调函数
    /// &lt;/summary&gt;
    /// &lt;param name="index"&gt;页签索引&lt;/param&gt;
    /// &lt;param name="txt"&gt;页签问本&lt;/param&gt;
    /// &lt;param name="callback"&gt;选中回调&lt;/param&gt;
    public void BindSelectCallback(int index,string txt,UnityAction callback)
    {
        if (_callbackDic.ContainsKey(index))
        {
            Debug.LogError("已经注册过了！");
            return;
        }

        if (callback == null)
        {
            Debug.LogError("回调为空！");
            return;
        }

        if (index &lt; 0 || index &gt; _objList.Count)
        {
            Debug.LogError("索引越界！");
            return;
        }

        var node = _objList[index];
        node.onTxt.text = txt;
        node.offTxt.text = txt;
        _callbackDic.Add(index,callback);
    }
    
    /// &lt;summary&gt;
    /// 调用指定索引对应的回调函数
    /// &lt;/summary&gt;
    /// &lt;param name="index"&gt;&lt;/param&gt;
    private void OnSelectLogic(int index)
    {
        if (index == _selectIndex)
        {
            return;
        }
        _selectIndex = index;
        
        var isExist = _callbackDic.TryGetValue(_selectIndex, out UnityAction callback);
        if (isExist)
        {
            callback?.Invoke();
            SetSelectStatus(index);
        }
    }
    
    /// &lt;summary&gt;
    /// 控制指定页签的UI表现
    /// &lt;/summary&gt;
    /// &lt;param name="index"&gt;&lt;/param&gt;
    private void SetSelectStatus(int index)
    {
        var count = _objList.Count;
        for (var i = 0; i &lt; count; i++)
        {
            var isActive = index == i;
            var node = _objList[i];
            node.onBg.SetActive(isActive);
            node.offBg.SetActive(!isActive);
        }
    }
    
    //清除指定父节点下的所有子物体
    private void ClearAllChild(Transform parentRoot)
    {
        var childCount = parentRoot.childCount;
        for (var i = childCount - 1; i &gt;= 0; i--)
        {
            var child = parentRoot.GetChild(i);
            DestroyImmediate(child.gameObject);
        }
    }

    //绑定按钮点击回调
    private void BindBtnLogic(Button btn, UnityAction action)
    {
        btn.onClick.RemoveAllListeners();
        if (action != null)
        {
            btn.onClick.AddListener(action);
        }
    }
}
</code></pre>
    <p>
    </p>
    <h2>
     飘字提示
    </h2>
    <h3>
     简易版本
    </h3>
    <p>
     <img alt="" height="720" src="https://i-blog.csdnimg.cn/direct/ff995c525f5a4b2c8c96435f829ad6f5.gif" width="496"/>
    </p>
    <pre><code class="language-cs">using UnityEngine;
using UnityEngine.Pool;
using DG.Tweening;
using UnityEngine.UI;

public class SimpleTip : MonoBehaviour
{
    //提示栏预制体
    public GameObject tipObj;
    //提示栏显示的父节点
    public Transform tipRoot;
    //对象池
    private ObjectPool&lt;GameObject&gt; tipPool;
    //飞行高度
    private float flyHeight = 500;
    
    void Start()
    {
        InitTipPool();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            ShowTip("货币不足！");
        }
    }

    void ShowTip(string tipStr)
    {
        var obj = tipPool.Get();
        var rectValue = obj.GetComponent&lt;RectTransform&gt;();
        var group = obj.GetComponent&lt;CanvasGroup&gt;();
        var txt = obj.transform.Find("txt").GetComponent&lt;Text&gt;();
        txt.text = tipStr;
        obj.SetActive(true);
        group.alpha = 1;
        ResetLocal(obj.transform);
        rectValue.DOAnchorPosY(flyHeight, 1f).OnComplete(() =&gt;
        {
            group.DOFade(0, 0.1f).OnComplete(() =&gt;
            {
                tipPool.Release(obj);
            });
        });
    }
    
    //初始化对象池
    void InitTipPool()
    {
        tipPool = new ObjectPool&lt;GameObject&gt;(() =&gt;
        {
            //创建新对象调用
            var obj = Instantiate(tipObj, tipRoot);
            obj.SetActive(false);
            return obj;
        },
        (go) =&gt;
        {
            //获取对象调用
            go.SetActive(true);
            ResetLocal(go.transform);
        },
        (go) =&gt;
        {
            // 在对象放回池子时调用
            go.SetActive(false);
            ResetLocal(go.transform);
            go.transform.SetParent(tipRoot);
        },
        (go) =&gt;
        {
            Destroy(go); 
        });
    }
    
    //重置本地信息
    void ResetLocal(Transform trans)
    {
        trans.localPosition = Vector3.zero;
        trans.localEulerAngles = Vector3.zero;
        trans.localScale = Vector3.one;
    }
}
</code></pre>
    <h3>
     升级版本
    </h3>
    <p>
     <img alt="" height="720" src="https://i-blog.csdnimg.cn/direct/18fee40ac18744d980778cbbc6596a7a.gif" width="496"/>
    </p>
    <pre><code class="language-cs">using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Pool;

public class GoodTip : MonoBehaviour
{
    //提示栏显示的父节点
    public Transform root;
    //提示栏模板预制体
    public GameObject tipObj;
    //对象池节点
    public Transform objectPool;
    
    //最多显示的提示栏数量，超过就隐藏
    private int limitCount = 5;
    //提示栏之间的偏移
    private float offset = 20;
    //提示飞行高度
    private float flyHeight = 100;
    //提示栏生成数量，只用于逻辑运算
    private int tipCount = 0;
    //提示栏高度
    private float tipHeight;
    private Queue&lt;GameObject&gt; visualTipQueue = new Queue&lt;GameObject&gt;();
    //是否可继续生成提示栏，防止频繁点击造成异常
    private bool isOk = true;
    private float timer = 0f;
    private bool startTimer = false;
    private float displayTime = 0.65f;//提示停留展示时间
    private ObjectPool&lt;GameObject&gt; tipPool;
    
    void Start()
    {
        var rect = tipObj.GetComponent&lt;RectTransform&gt;();
        tipHeight = rect.rect.height;
        
        InitTipPool();
    }

    private void Update()
    {
        if (startTimer)
        {
            //定时统一清理提示消息
            timer += Time.deltaTime;
            if (timer &gt; displayTime)
            {
                ClearAllMsg();
                timer = 0f;
                startTimer = false;
            }
        }

        if (Input.GetKeyDown(KeyCode.Space))
        {
            ShowTip("货币不足！");
        }
    }
    
    public void ShowTip(string tip)
    {
        if (!isOk)
        {
            return;
        }
        startTimer = false;
        isOk = false;
        var obj = tipPool.Get();
        var rect1 = obj.GetComponent&lt;RectTransform&gt;();
        var group = obj.GetComponent&lt;CanvasGroup&gt;();
        
        var sequence = DOTween.Sequence();
        if (visualTipQueue.Count &gt; 0)
        {
            sequence.AppendCallback(() =&gt;
            {
                foreach (var item in visualTipQueue)
                {
                    var rectValue = item.GetComponent&lt;RectTransform&gt;();
                    rectValue.DOAnchorPosY(rectValue.anchoredPosition.y+tipHeight+offset, 0.2f);
                }
            });
            sequence.AppendInterval(0.2f);
        }
        sequence.AppendCallback(() =&gt;
        {
            group.alpha = 1;
            obj.transform.SetParent(root);
            obj.transform.localScale = new Vector3(0, 0, 1);
            obj.SetActive(true);
            rect1.anchoredPosition = Vector2.zero;
            visualTipQueue.Enqueue(obj);
            
            tipCount++;
            var txt  = obj.transform.Find("txt").GetComponent&lt;Text&gt;();
            txt.text = tip;
            
            if (tipCount &gt; limitCount)
            {
                var result = visualTipQueue.Dequeue();
                tipPool.Release(result);
                tipCount--;
            }
        });
        sequence.Append(obj.transform.DOScale(Vector3.one, 0.1f));
        sequence.AppendInterval(0.1f);
        sequence.OnComplete(() =&gt;
        {
            timer = 0f;
            isOk = true;
            startTimer = true;
        });
    }
    
    //初始化对象池
    void InitTipPool()
    {
        tipPool = new ObjectPool&lt;GameObject&gt;(() =&gt;
        {
            //创建新对象调用
            var obj = Instantiate(tipObj, objectPool);
            obj.SetActive(false);
            return obj;
        },
        (go) =&gt;
        {
            //获取对象调用
            go.SetActive(true);
            ResetLocal(go.transform);
        },
        (go) =&gt;
        {
            // 在对象放回池子时调用
            go.SetActive(false);
            ResetLocal(go.transform);
            go.transform.SetParent(objectPool);
        },
        (go) =&gt;
        {
            Destroy(go); 
        });
    }
    
    //重置本地信息
    void ResetLocal(Transform trans)
    {
        trans.localPosition = Vector3.zero;
        trans.localEulerAngles = Vector3.zero;
        trans.localScale = Vector3.one;
    }
    
    //清空消息
    public void ClearAllMsg()
    {
        var childCount = root.childCount;
        for (var i = 0; i &lt; childCount; i++)
        {
            var child = root.GetChild(i);
            var group = child.GetComponent&lt;CanvasGroup&gt;();
            var rectValue = child.GetComponent&lt;RectTransform&gt;();
            var sequence = DOTween.Sequence();
            sequence.AppendInterval(0.1f * i);
            sequence.Append(rectValue.DOAnchorPosY(rectValue.anchoredPosition.y + tipHeight+flyHeight, 0.2f));
            sequence.Append(group.DOFade(0, 0.1f).OnComplete(() =&gt;
            {
                visualTipQueue.Dequeue();
                tipPool.Release(child.gameObject);
                tipCount--;
            }));
        }
    }
}
</code></pre>
    <p>
    </p>
    <h2>
     左右切换按钮组
    </h2>
    <p>
     本组件一般出现在查看英雄界面，点击左右两个按钮切换查看按钮的详细信息。在英雄列表中，第一个英雄的左按钮不显示，最后一个英雄的右按钮不显示。
    </p>
    <p>
     <img alt="" height="380" src="https://i-blog.csdnimg.cn/direct/737155cb3946479f9976a8b1a497078e.png" width="501"/>
    </p>
    <pre><code class="language-cs">using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class SwitchCheck : MonoBehaviour
{
    public Button btn_Left;
    public Button btn_Right;
    public Text txt_Check;

    private int sumCount;
    private int curIndex;
    private UnityAction&lt;int&gt; callback;//外部逻辑回调
    
    void Start()
    {
        curIndex = 0;
        InitGroup(10, (index) =&gt;
        {
            txt_Check.text = $"{index}/{sumCount}";
        });
        CheckBtnActive();
        BindBtnLogic(btn_Left, () =&gt;
        {
            var nextIndex = curIndex - 1;
            if (nextIndex &lt; 0)
            {
                return;
            }
            curIndex = nextIndex;
            CheckBtnActive();
        });
        
        BindBtnLogic(btn_Right, () =&gt;
        {
            var nextIndex = curIndex + 1;
            if (nextIndex &gt;= sumCount)
            {
                return;
            }
            curIndex = nextIndex;
            CheckBtnActive();
        });
    }
    
    public void InitGroup(int _sumCount,UnityAction&lt;int&gt; _callback)
    {
        sumCount = _sumCount;
        callback = _callback;
    }
    
    //按钮显隐逻辑
    private void CheckBtnActive()
    {
        if (sumCount &lt;= 1)
        {
            btn_Left.gameObject.SetActive(false);
            btn_Right.gameObject.SetActive(false);
        }
        else
        {
            btn_Left.gameObject.SetActive(curIndex &gt;= 1);
            btn_Right.gameObject.SetActive(curIndex &lt;= sumCount-2);
        }

        var showIndex = curIndex + 1;
        callback?.Invoke(showIndex);
    }
    
    //绑定按钮点击回调
    private void BindBtnLogic(Button btn, UnityAction action)
    {
        btn.onClick.RemoveAllListeners();
        if (action != null)
        {
            btn.onClick.AddListener(action);
        }
    }
}
</code></pre>
    <h2>
     帮助说明界面
    </h2>
    <p>
     <img alt="" height="532" src="https://i-blog.csdnimg.cn/direct/b5c6d521f0f8405bb3207eb25c1d4166.png" width="488"/>
    </p>
    <pre><code class="language-cs">using System.Text;
using UnityEngine;
using UnityEngine.UI;

public class ComDesc : MonoBehaviour
{
    public Text txt_Title;
    public Text txt_Desc;
    public RectTransform content;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            SetDesc("帮助", "好好学习,天天向上");
        }
            
        if (Input.GetKeyDown(KeyCode.A))
        {
            var str = "好好学习,天天向上";
            StringBuilder sb = new StringBuilder();
            for (var i = 1; i &lt; 100; i++)
            {
                sb.Append(str);
            }
            SetDesc("帮助", sb.ToString());
        }
    }

    /// &lt;summary&gt;
    /// 设置说明描述
    /// &lt;/summary&gt;
    /// &lt;param name="title"&gt;界面标题&lt;/param&gt;
    /// &lt;param name="desc"&gt;说明文本&lt;/param&gt;
    public void SetDesc(string title,string desc)
    {
        txt_Title.text = title;
        txt_Desc.text = desc;
        LayoutRebuilder.ForceRebuildLayoutImmediate(content);
    }
}
</code></pre>
    <h2>
     跑马灯消息提示
    </h2>
    <p>
     <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/0a29bd7b7b524762b923250cf769144c.gif" width="512"/>
    </p>
    <p>
     有消息队列缓存，等待队列中所有消息播放完后，提示才消失。
    </p>
    <pre><code class="language-cs">using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using TMPro;
using UnityEngine.Events;
using UnityEngine.UI;

public class Marquee : MonoBehaviour
{
    public TMP_Text tmpTxt;
    public RectTransform maskNode;
    public CanvasGroup canvasGroup;
    private float maskWidth;
    private float unitTime = 0.2f;//计算动画时间自定义标准
    private Queue&lt;MsgNode&gt; marqueeMsg = new Queue&lt;MsgNode&gt;();
    private List&lt;int&gt; idList = new List&lt;int&gt;();
    private bool isPlay;//是否正在播放消息
    
    private class MsgNode
    {
        public int id;
        public string msg;
        public int loopCount;
    }
    
    void Start()
    {
        maskWidth = maskNode.rect.width;
    }

    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            var id = Random.Range(1,100);
            var str = $"id:{id}好好学习，天天向上&gt;&gt;";
            AddMarqueeMsg(id,str,1);
        }
        
        if(marqueeMsg.Count &gt; 0) {
            if (!isPlay)
            {
                isPlay = true;
                tmpTxt.rectTransform.anchoredPosition = Vector2.zero;
                var data = marqueeMsg.Peek();
                idList.Remove(data.id);
                DisplayMarqueeMsg(data.msg,data.loopCount, () =&gt;
                {
                    marqueeMsg.Dequeue();
                    if (marqueeMsg.Count == 0)
                    {
                        canvasGroup.alpha = 0;
                    }
                    isPlay = false;
                });
            }
        }
    }

    /// &lt;summary&gt;
    /// 在跑马灯消息队列中添加消息
    /// &lt;/summary&gt;
    /// &lt;param name="msgId"&gt;消息记录的唯一id&lt;/param&gt;
    /// &lt;param name="msg"&gt;消息内容&lt;/param&gt;
    /// &lt;param name="loopCount"&gt;循环播放时间&lt;/param&gt;
    public void AddMarqueeMsg(int msgId, string msg, int loopCount)
    {
        if (idList.Contains(msgId))
        {
            Debug.LogError("消息已在预播队列");
            return;
        }
        
        if (canvasGroup.alpha &lt; 0.95f)
        {
            canvasGroup.alpha = 1;
        }
        
        idList.Add(msgId);
        marqueeMsg.Enqueue(new MsgNode
        {
            id = msgId,
            msg = msg,
            loopCount = loopCount
        });
    }
    
    /// &lt;summary&gt;
    /// 跑马灯消息播放
    /// &lt;/summary&gt;
    /// &lt;param name="msgId"&gt;消息记录的唯一id&lt;/param&gt;
    /// &lt;param name="msg"&gt;消息内容&lt;/param&gt;
    /// &lt;param name="loopCount"&gt;循环播放时间&lt;/param&gt;
    public void DisplayMarqueeMsg(string msg,int loopCount,UnityAction callback)
    {
        tmpTxt.text = msg;
        LayoutRebuilder.ForceRebuildLayoutImmediate(tmpTxt.rectTransform);
        var width = tmpTxt.rectTransform.rect.width+maskWidth;
        var duration = GetDuration(width);
        tmpTxt.rectTransform.DOAnchorPosX(-width, duration)
            .SetEase(Ease.Linear)
            .SetLoops(loopCount, LoopType.Restart)
            .OnComplete(() =&gt;
            {
                callback?.Invoke();
            });
    }

    //根据消息长度计算动画匀速运行时间
    private float GetDuration(float width)
    {
        var offset1 = (int)width / 100;
        var offset2 = width % 100 == 0 ?0:1;
        var offset = offset1 + offset2;
        return offset * unitTime;
    }
}
</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34343830393933342f:61727469636c652f64657461696c732f313436303533353332" class_="artid" style="display:none">
 </p>
</div>


