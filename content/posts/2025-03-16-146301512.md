---
layout: post
title: "Go语言圣经2.6"
date: 2025-03-16 21:08:48 +0800
description: "popcount算法解读想象一下你有一本“数字图鉴”，里面记着0到255这256个数字，每个数字旁边都写着它的“1的个数”。这个图鉴就是那个预先计算好的表格(pc数组)。预先计算图鉴（init函数）对于0到255中的每个数字，我们算一算它的二进制写法里有几个1，然后把这个数字和它的1的个数存进图鉴里。计算一个二进制数字的1的个数时，我们可以把它分解为“除以2后的数字”里的1的个数，再加上“最后一位是否为1”。"
keywords: "【Go语言圣经2.6】"
categories: ['未分类']
tags: ['数据库', 'Golang']
artid: "146301512"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146301512
    alt: "Go语言圣经2.6"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146301512
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146301512
cover: https://bing.ee123.net/img/rand?artid=146301512
image: https://bing.ee123.net/img/rand?artid=146301512
img: https://bing.ee123.net/img/rand?artid=146301512
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Go语言圣经2.6】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     目标
    </h3>
    <h3>
     <a id="_2">
     </a>
     概念
    </h3>
    <ol>
     <li>
      <p>
       GOPATH模型
      </p>
      <ul>
       <li>
        GOPATH：GOPATH 是一个环境变量，指明 Go 代码的工作区路径。
       </li>
       <li>
        工作区通常包含三个目录：
        <ul>
         <li>
          <strong>
           src
          </strong>
          ：存放源代码，按照导入路径组织。例如，包
          <code>
           gopl.io/ch2/tempconv
          </code>
          应存放在
          <code>
           $GOPATH/src/gopl.io/ch2/tempconv
          </code>
          中。
         </li>
         <li>
          <strong>
           pkg
          </strong>
          ：编译后生成的包文件（中间产物）。
         </li>
         <li>
          <strong>
           bin
          </strong>
          ：可执行文件。
         </li>
        </ul>
       </li>
       <li>
        在 GOPATH 模型中，包的导入路径直接对应于
        <code>
         src
        </code>
        目录下的子目录结构
        <ul>
         <li>
          例如，
          <code>
           import "gopl.io/ch2/tempconv"
          </code>
          表示编译器将在
          <code>
           $GOPATH/src/gopl.io/ch2/tempconv
          </code>
          下寻找该包的源代码。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       Go module 模型（现代依赖管理方式）
      </p>
      <ul>
       <li>
        Go module
        <ul>
         <li>
          Go module 是从 Go 1.11 开始引入的，不再强制要求代码必须放在 GOPATH 内。
         </li>
         <li>
          每个模块有一个
          <code>
           go.mod
          </code>
          文件，其中定义了模块路径（作为导入路径的前缀）和依赖项及其版本。
         </li>
        </ul>
       </li>
       <li>
        模块根目录可以放在任意位置，
        <code>
         go.mod
        </code>
        中指定的模块路径决定了包的导入路径前缀。
        <ul>
         <li>
          例如，如果
          <code>
           go.mod
          </code>
          声明模块为
          <code>
           gopl.io/ch2/tempconv
          </code>
          ，则该模块中的包可以直接用该路径导入，无需放在 GOPATH 内。
         </li>
        </ul>
       </li>
       <li>
        优势：
        <ul>
         <li>
          自动管理依赖版本，支持版本控制；
         </li>
         <li>
          使得项目结构更灵活，不受 GOPATH 限制；
         </li>
         <li>
          编译工具会根据
          <code>
           go.mod
          </code>
          自动解析和下载依赖。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       构建工具如何根据不同模型处理依赖和编译项目
      </p>
      <ul>
       <li>
        <strong>
         go build 命令
        </strong>
        <ul>
         <li>
          在 GOPATH 模型下，
          <code>
           go build
          </code>
          根据 GOPATH/src 中的目录结构找到并编译包；
         </li>
         <li>
          在 module 模型下，
          <code>
           go build
          </code>
          会读取当前目录或上级目录中的
          <code>
           go.mod
          </code>
          文件来确定模块范围，并自动处理依赖。
         </li>
        </ul>
       </li>
       <li>
        <strong>
         导入包时的区别
        </strong>
        <ul>
         <li>
          在 GOPATH 模型下，你的代码必须位于 GOPATH/src 中；
         </li>
         <li>
          在 module 模型下，你可以在任何地方创建项目，依赖管理由
          <code>
           go.mod
          </code>
          文件控制。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       包的作用和意义
      </p>
      <ul>
       <li>
        <p>
         <strong>
          模块化与封装
         </strong>
        </p>
        <p>
         Go 语言中的包类似于其他语言中的库或模块，其目的是将相关代码组织在一起，实现模块化编程。
        </p>
        <ul>
         <li>
          <strong>
           封装
          </strong>
          ：包内部的实现细节可以隐藏，仅公开需要被外部使用的部分。
         </li>
         <li>
          <strong>
           单独编译和重用
          </strong>
          ：每个包可以单独编译，也能在不同程序中复用，提高代码可维护性和协作效率。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        命名空间
       </strong>
      </p>
      <p>
       每个包都有自己独立的命名空间。当不同包中存在同名的函数或类型，外部引用时加上包前缀，这避免了名称冲突
      </p>
     </li>
     <li>
      <p>
       导出规则
      </p>
      <ul>
       <li>
        包中的标识符（如变量、常量、函数、类型等）只有首字母大写时才是导出的，也就是对外可见的；否则只在包内部可见。这为包内部实现细节的隐藏提供了简单而有效的机制。
       </li>
      </ul>
     </li>
     <li>
      <p>
       文件组织与包结构
      </p>
      <ul>
       <li>
        一个包通常由一个或多个以
        <code>
         .go
        </code>
        为后缀的源文件组成。这些文件必须以相同的包声明开始。例如，一个包可能存放在
        <code>
         $GOPATH/src/gopl.io/ch2/tempconv
        </code>
        目录中，其导入路径就是
        <code>
         gopl.io/ch2/tempconv
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       多个源文件协同工作
      </p>
      <ul>
       <li>
        包级别的声明（类型、变量、常量、函数）在同一包内的所有源文件中都是共享的，就像所有代码都写在一个文件中一样。
       </li>
       <li>
        可以将不同功能或逻辑拆分到多个文件中，提高代码组织和可维护性。例如：
        <ul>
         <li>
          <strong>
           tempconv.go
          </strong>
          ：放置包级的常量、类型、以及为这些类型定义的方法（如
          <code>
           String()
          </code>
          ）。
         </li>
         <li>
          <strong>
           conv.go
          </strong>
          ：专门放置温度转换函数，如
          <code>
           CToF
          </code>
          和
          <code>
           FToC
          </code>
          。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       导入包
      </p>
      <ul>
       <li>
        导入路径与包名
        <ul>
         <li>
          每个包都有一个全局唯一的导入路径，如
          <code>
           "gopl.io/ch2/tempconv"
          </code>
          。这个路径由构建工具解析，通常对应一个目录。
         </li>
         <li>
          包的名字通常在包声明处指定，惯例上包名和导入路径的最后一个字段相同（例如
          <code>
           tempconv
          </code>
          ）
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       包注释
      </p>
      <ul>
       <li>
        在每个包的源文件开头紧跟着的注释称为包注释，它应该简明扼要地说明包的功能。
        <ul>
         <li>
          通常只需在一个文件中包含完整的包注释，如果包比较复杂，也可以单独放在 doc.go 文件中。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       开发工具支持
      </p>
      <p>
       <strong>
        goimports 和 gofmt
       </strong>
      </p>
      <ul>
       <li>
        这些工具可以自动添加或删除导入语句，并格式化代码，保持代码风格一致，有助于日常开发。
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_62">
     </a>
     要点
    </h3>
    <h4>
     <a id="_64">
     </a>
     导入语句的写法与使用
    </h4>
    <ol>
     <li>
      <p>
       在源文件中通过
       <code>
        import
       </code>
       语句导入包
      </p>
      <pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"gopl.io/ch2/tempconv"</span>
<span class="token punctuation">)</span>

</code></pre>
     </li>
     <li>
      <p>
       导入后，包内导出的标识符（首字母大写的）可以通过“包名.标识符”访问，例如：
      </p>
      <pre><code class="prism language-go">tempconv<span class="token punctuation">.</span><span class="token function">CToF</span><span class="token punctuation">(</span>tempconv<span class="token punctuation">.</span>BoilingC<span class="token punctuation">)</span>
</code></pre>
      <ul>
       <li>
        如果导入后不使用该包，编译器会报错。这鼓励程序员只导入真正需要的包，保持依赖清晰。
       </li>
      </ul>
     </li>
     <li>
      <p>
       如果有命名冲突或为了简洁，可以将导入的包绑定到另一个名字**（重命名导入）**
      </p>
      <pre><code class="prism language-go"><span class="token keyword">import</span> tconv <span class="token string">"gopl.io/ch2/tempconv"</span>
</code></pre>
      <p>
       然后用
       <code>
        tconv.CToF
       </code>
       访问包中的内容。
      </p>
     </li>
    </ol>
    <h4>
     <a id="_92">
     </a>
     包的初始化
    </h4>
    <ol>
     <li>
      初始化顺序规则
      <ul>
       <li>
        <p>
         包中的全局变量（包级变量）的初始化遵循先依赖后顺序：
        </p>
        <ul>
         <li>
          变量的初始化顺序是按照它们在源代码中出现的顺序进行。
         </li>
         <li>
          当一个包被导入时，所有包级变量会在
          <code>
           main()
          </code>
          函数执行前完成初始化。
         </li>
        </ul>
        <pre><code class="prism language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> b <span class="token operator">+</span> c <span class="token comment">// a 是第三个初始化的变量</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// b 是第二个初始化的变量（依赖 c）</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span>     <span class="token comment">// c 是第一个初始化的变量</span>
<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> c <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre>
        <ul>
         <li>
          在这个例子中，初始化时会确保
          <code>
           c
          </code>
          已经赋值，这样
          <code>
           b
          </code>
          才能正确调用
          <code>
           f()
          </code>
          。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          包初始化顺序与依赖
         </strong>
        </p>
        <ul>
         <li>
          当一个包 A 导入包 B 时，B 包会先于 A 包初始化。
         </li>
         <li>
          这种自下而上的初始化方式确保 main 包执行前，所有依赖包都已完成初始化。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      init函数
      <ul>
       <li>
        <strong>
         init 函数的作用
        </strong>
        <ul>
         <li>
          init 函数用于在包初始化时执行额外的初始化逻辑。
         </li>
         <li>
          每个源文件可以包含多个 init 函数，且它们会在包初始化时按照声明顺序自动调用。
         </li>
         <li>
          init 函数不能被显式调用或引用，仅用于初始化工作。
         </li>
        </ul>
       </li>
       <li>
        示例
        <ul>
         <li>
          <p>
           构建辅助数据表或进行复杂的初始化运算。例如在 popcount 包中，用 init 函数预生成一个查表数组：
          </p>
          <pre><code class="prism language-go"><span class="token keyword">var</span> pc <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> pc <span class="token punctuation">{<!-- --></span>
        pc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pc<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">byte</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
         </li>
         <li>
          <p>
           如果初始化过程较复杂，可以采用匿名函数直接在变量声明中完成初始化
          </p>
          <pre><code class="prism language-go"><span class="token keyword">var</span> pc <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pc <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> pc<span class="token punctuation">{<!-- --></span>
		pc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pc<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">byte</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> 
<span class="token punctuation">}</span>
</code></pre>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     <a id="_140">
     </a>
     语言特性
    </h3>
    <h3>
     <a id="_142">
     </a>
     习题
    </h3>
    <ol>
     <li>
      <p>
       重写PopCount函数，用一个循环代替单一的表达式。
      </p>
      <pre><code class="prism language-go"><span class="token comment">// 假设已经定义查数数组pc[256]</span>
<span class="token keyword">func</span> <span class="token function">PopCountLoop</span><span class="token punctuation">(</span>x <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> sum <span class="token builtin">int</span>
	<span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">{<!-- --></span>
		sum <span class="token operator">+=</span> <span class="token function">int</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 取最低8位</span>
		x <span class="token operator">&gt;&gt;</span> <span class="token number">8</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。
      </p>
      <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">PopCountShift</span><span class="token punctuation">(</span>x <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> sum <span class="token builtin">int</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        sum <span class="token operator">+=</span> <span class="token function">int</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        x <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       表达式x&amp;(x-1)用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数
      </p>
      <ul>
       <li>
        二进制，x-1 会把 x 中最右边的那个“1”变成“0”，并把后面所有的 0 变成 1。（当你给 x 减 1 时，从最右边开始，所有连续的 0 都借1减1，直到碰到第一个 1，这个 1 就变成 0。）
       </li>
       <li>
        当你把 x 和 x-1 做与操作时，只有当两个对应位置都是 1 时，结果才为 1。由于 x-1 在原来最低1的位置已经变成了 0，所以 x&amp;(x-1) 在那个位置肯定是 0，并且之前为0的低位不会改变——这就把x的最低的一个非零的bit位清零
       </li>
      </ul>
      <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">PopCountClear</span><span class="token punctuation">(</span>x <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> count <span class="token builtin">int</span>
    <span class="token keyword">for</span> x <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">&amp;=</span> x <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment">// 清除最低位的1</span>
        count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> count
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ol>
    <h3>
     <a id="_186">
     </a>
     总结与补充
    </h3>
    <ol>
     <li>
      <p>
       popcount算法解读
      </p>
      <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">PopCount</span><span class="token punctuation">(</span>x <span class="token builtin">uint64</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span>
        pc<span class="token punctuation">[</span><span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       想象一下你有一本“数字图鉴”，里面记着0到255这256个数字，每个数字旁边都写着它的“1的个数”。这个图鉴就是那个预先计算好的表格(pc数组)。
      </p>
      <ul>
       <li>
        预先计算图鉴（init函数）
        <ul>
         <li>
          <strong>
           做法：
          </strong>
          对于0到255中的每个数字，我们算一算它的二进制写法里有几个1，然后把这个数字和它的1的个数存进图鉴里。
         </li>
         <li>
          <strong>
           秘诀：
          </strong>
          计算一个二进制数字的1的个数时，我们可以把它分解为“除以2后的数字”里的1的个数，再加上“最后一位是否为1”。比如说，如果数字6（二进制110），我们先看6/2等于3（二进制11），再加上6最后一位（0），结果就是2个1。
          <ul>
           <li>
            你把一个数字除以2（也就是右移一位），其实就是把最右边那一位扔掉了。那么，这个数字中1的总数就等于“扔掉最后一位后剩下的数字中的1的个数”加上“刚刚扔掉的那一位是否是1”。
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        用图鉴快速数1的个数（PopCount函数）
        <ul>
         <li>
          <strong>
           大数字切小块：
          </strong>
          当我们有一个很大的64位数字时，不用检查64个数字，而是把它分成8个8位的小数字。
          <ul>
           <li>
            表达式
            <code>
             x &gt;&gt; (k*8)
            </code>
            的意思是把数字 x 向右移动 k*8 位，这样原本在第 k 个8位区域的数字就会移动到最右边。
           </li>
           <li>
            使用
            <code>
             byte()
            </code>
            把移动后的结果截取成一个8位的数字（一个字节）。
           </li>
          </ul>
         </li>
         <li>
          <strong>
           查表加和：
          </strong>
          对每个8位的小数字，直接在图鉴里查出它有几个1，然后把8个结果加起来，就知道整个64位数字里有多少个1。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f5079726f79737465722f:61727469636c652f64657461696c732f313436333031353132" class_="artid" style="display:none">
 </p>
</div>


