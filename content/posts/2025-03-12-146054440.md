---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303737343837352f:61727469636c652f64657461696c732f313436303534343430"
layout: post
title: "Linux系统进程优先级进程间的权力游戏"
date: 2025-03-12 12:07:43 +08:00
description: "进程优先级调度是是指操作系统，根据进程的优先级来分配CPU资源的一种调度算法。系统会为每个进程分配一个优先级，优先级高的进程会优先获取CPU资源，从而更好地决定进程执行顺序。这种机制极大程度上提高了，系统的运行效率。"
keywords: "【Linux系统】进程优先级：进程间的权力游戏"
categories: ['未分类']
tags: ['运维', '游戏', 'Linux']
artid: "146054440"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146054440
    alt: "Linux系统进程优先级进程间的权力游戏"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146054440
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146054440
cover: https://bing.ee123.net/img/rand?artid=146054440
image: https://bing.ee123.net/img/rand?artid=146054440
img: https://bing.ee123.net/img/rand?artid=146054440
---

# 【Linux系统】进程优先级：进程间的权力游戏

## Linux系列

---

---

## 前言

进程优先级调度是是指操作系统，根据进程的优先级来分配
`CPU`
资源的一种调度算法。系统会为每个进程分配一个优先级，优先级高的进程会优先获取
`CPU`
资源，从而更好地决定进程执行顺序。这种机制极大程度上提高了，系统的运行效率。

## 一、优先级的概念

首先，要知道这几个概念：
  
1、什么是优先级？
  
优先级就是对于系统资源，谁先访问，谁后访问的问题。
  
2、为什么要有优先级？
  
因为对于一个多任务的操作系统来说，
`CPU`
资源有限，进程是多个的，注定了进程之间是竞争关系，而如果一个进程长时间得不到
`CPU`
资源，该进程就一直得不到推进（就相当于某个程一直无法启动），我们称这个为
**进程饥饿**
问题，而操作系统为了规避这种情况，保证进程间的良性竞争，就给每个进程分配了对应的优先级（号码牌），进程就拿着自己的优先级去排队了。
  
总结一下：

* 优先级：对
  `CPU`
  资源访问优先的问题
* 存在原因：
  `CPU`
  的资源不足
* 优先级高的比优先级低的更早被调度，能够确保关键任务及时完成，同时提高系统的运行效率

## 二、查看、修改优先级

### 2.1、查看优先级

`随便写的程序，用来演示`

```c
  1 #include<stdio.h>  
  2 #include<unistd.h>  
  3 int main()  
  4 {
  5   while(1)
  6   {
  7                                                               
  8   }
  9   return 0;
 10 }        

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5feeef5f233e4378b04c5c9b88c784ac.png)

在Linux系统中，
`PRI（Priority）`
和
`NI（Nice）`
两个参数共同决定了进程的优先级，影响进程的调度顺序。
  
可以通过
`ps指令`
来查看具体信息。
  
**PRI（Priority）**
  
`PRI`
是进程的最终优先级，由内核通过计算得到，直接影响调度器为进程分配
`CPU`
资源的顺序。
  
`优先级数值越小，优先级月高！！`
  
**PRI的范围**

* 实时任务：范围为0到99
* 普通任务：范围为100到139

> **实时任务：是指必须在规定时间内完成处理，并对响应时间和处理结果的准确性有严格要求的。
>   
> 普通任务：是指对时间要求宽松没有严格时间限制的任务。**

**PRI的计算公式**
  
`PRI(new)=PRI(old)+NI（nice）`
  
其中：

* `PRI(old)`
  :是进程原来优先级（其实对我们写的程序来说固定为80）
* `NI`
  ：是进程的
  `nice`
  值，我们可以通过设置不同的
  `nice`
  达到改变进程优先级的目的，但是操作系统规定
  `nice`
  值的范围必须在【-20，19】

对于我们执行的程序，优先级一般初始为80。

### 2.2、修改指令

**NI(Nice)**
  
`NI`
值是用户空间设置的静态优先级，默认值为0，用户可以通过对
`NI`
赋予不同的值，来达到修改优先级的目的，帮助我们对一些比较重要的程序，优先分配
`CPU`
资源。如果修改
`NI`
的值超过规定空间，如：设为30，则
`NI`
会取其范围内最靠进的值19.
  
**修改NI的值**
  
启动
`top`
命令，进入下面页面：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/45598c215fcc41dab63332e3c9edc252.png)
  
找到要修改进程的
`PID`
,可使用
`/`
搜索，按下
`r`
键，输入要修改进程的
`PID`
，输入后直接回车，系统会提示你输入要修改的值，下面为我输入
`19`
后的值，其进程优先级修改结果为：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/900c8dc4201044d3b4d0537bab4f3ebb.png)
  
注意，我们平时不建议修改进程优先级，内核调度器分配的优先级是比较合理的，如果改动可能会导致进程响应变慢。

## 三、Linux o(1)调度算法

### 3.1、内核调度器算法的工作方式

一个
`CPU`
绑定一个运行队列，和两个优先级队列，在这两个优先级队列中，一个是活跃的一个是过期的，每个优先级队列包含
`140`
个优先级：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dcc7077fb0554c95ad7b823dd38dbbca.png)

在这个优先级队列中，按优先级顺序存储着PCB结构体对象的指针，如果有两相同优先级的进程，那么他们的PCB结构体通过指针链接起来进行排队，另外操作系统还会为他创建一个对应的位图，同过遍历位图的方式判断，对应位置是否为空，若不为空则对该位图映射对应的优先级队列位置的进程，进行调度，被调度的进程时间片消耗完后，就会去另一个不活跃的优先级队列中，重新进程排对，当
`CPU`
将活跃优先级队列遍历完后，此时只要将活跃优先级的队列同不活跃优先级的队列的指针交换，就可以再次遍历队列，调度进程了，而这个交换的时间复杂度为o（1）,因此被称为，o（1）的调度算法。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0f19fdb6f8844705a97a668d1b9aeae3.png)