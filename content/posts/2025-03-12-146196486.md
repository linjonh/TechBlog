---
layout: post
title: "Unity3D-着色器优化Shader-Optimization"
date: 2025-03-12 09:33:40 +0800
description: "Unity3D 着色器（Shader）优化是提升渲染性能的关键环节，尤其是在移动设备或复杂场景中。对惹，这里有一个游戏开发交流小组，希望大家可以点击进来一起交流一下开发经验呀！1. 减少计算复杂度简化数学运算优先使用mad（乘加）指令代替单独的乘法和加法。避免复杂函数（如sinpowexp），改用近似计算或查值纹理（Lookup Texture）。利用向量化操作（如float3代替逐分量计算）。移动计算到更早的阶段。"
keywords: "Unity3D 着色器优化（Shader Optimization）"
categories: ['未分类']
tags: ['着色器', '游戏开发', 'Unity', 'Shader']
artid: "146196486"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146196486
    alt: "Unity3D-着色器优化Shader-Optimization"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146196486
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146196486
cover: https://bing.ee123.net/img/rand?artid=146196486
image: https://bing.ee123.net/img/rand?artid=146196486
img: https://bing.ee123.net/img/rand?artid=146196486
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Unity3D 着色器优化（Shader Optimization）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     前言
    </h3>
    <p>
     Unity3D 着色器（Shader）优化是提升渲染性能的关键环节，尤其是在移动设备或复杂场景中。以下是系统的优化策略和实践建议：
    </p>
    <p>
     <strong>
      对惹，这里有一
     </strong>
     <a href="https://link.zhihu.com/?target=http%3A//qm.qq.com/cgi-bin/qm/qr%3F_wv%3D1027%26k%3DdMAq1DlcS381YbFZmdb7BtZY0P6oUBtl%26authKey%3DhZcaQ9EFvMcDLf%252FPsKrFKENOeVlSVBMgFEsh1P43L2ZfSUQZjAndaA5MFK5IsGBM%26noverify%3D0%26group_code%3D682143601" rel="nofollow" title="个游戏开发交流小组">
      个游戏开发交流小组
     </a>
     <strong>
      ，希望大家可以点击进来一起交流一下开发经验呀！
     </strong>
    </p>
    <h4>
     <strong>
      1. 减少计算复杂度
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       简化数学运算
      </strong>
      ：
      <ul>
       <li>
        优先使用
        <code>
         mad
        </code>
        （乘加）指令代替单独的乘法和加法。
       </li>
       <li>
        避免复杂函数（如
        <code>
         sin
        </code>
        ,
        <code>
         pow
        </code>
        ,
        <code>
         exp
        </code>
        ），改用近似计算或查值纹理（Lookup Texture）。
       </li>
       <li>
        利用向量化操作（如
        <code>
         float3
        </code>
        代替逐分量计算）。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       移动计算到更早的阶段
      </strong>
      ：
      <ul>
       <li>
        在顶点着色器中计算非高精度需求的值（如法线、光照方向），通过插值传递给片元着色器。
       </li>
       <li>
        避免在片元着色器中重复计算相同值，使用
        <code>
         v2f
        </code>
        结构传递预计算数据。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       分支语句优化
      </strong>
      ：
      <ul>
       <li>
        尽量避免
        <code>
         if/else
        </code>
        分支（尤其在移动端），使用
        <code>
         step()
        </code>
        或
        <code>
         lerp()
        </code>
        函数代替。
       </li>
       <li>
        若必须分支，尽量保证同一像素块内的线程执行相同路径（避免发散）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      2. 纹理与采样优化
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       减少纹理采样次数
      </strong>
      ：
      <ul>
       <li>
        合并纹理通道（如将金属度、光滑度打包到单张纹理的RGBA通道）。
       </li>
       <li>
        使用纹理图集（Texture Atlas）减少切换纹理的开销。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       优化纹理格式
      </strong>
      ：
      <ul>
       <li>
        使用压缩格式（如ASTC、ETC2）减少内存带宽占用。
       </li>
       <li>
        避免过大的纹理尺寸，合理使用 Mipmap 减少远处像素的采样开销。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       采样器优化
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         linear
        </code>
        或
        <code>
         point
        </code>
        滤波代替高开销的
        <code>
         trilinear
        </code>
        。
       </li>
       <li>
        关闭不必要的纹理属性（如
        <code>
         Generate Mipmaps
        </code>
        若不需要）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      3. 光照与阴影优化
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       简化光照模型
      </strong>
      ：
      <ul>
       <li>
        移动端使用 Lambert 或 Blinn-Phong 代替 PBR（若视觉可接受）。
       </li>
       <li>
        预烘焙静态光照（Baked Lightmaps）减少实时计算。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       阴影优化
      </strong>
      ：
      <ul>
       <li>
        降低阴影分辨率（
        <code>
         Shadow Resolution
        </code>
        ）或使用级联阴影（Cascaded Shadows）的优化配置。
       </li>
       <li>
        使用
        <code>
         Soft Shadows
        </code>
        仅在必要时启用。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      4. Shader变体管理
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       减少变体数量
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         shader_feature
        </code>
        替代
        <code>
         multi_compile
        </code>
        避免生成未使用的变体。
       </li>
       <li>
        合并功能相近的关键字，如通过
        <code>
         #pragma multi_compile_fog
        </code>
        统一管理雾效。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       剔除无用变体
      </strong>
      ：
      <ul>
       <li>
        在
        <code>
         Shader
        </code>
        代码中使用
        <code>
         #ifdef
        </code>
        条件编译剔除不需要的功能模块。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      5. 平台针对性优化
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       移动端（GLES/Vulkan）
      </strong>
      ：
      <ul>
       <li>
        使用
        <code>
         half
        </code>
        或
        <code>
         fixed
        </code>
        代替
        <code>
         float
        </code>
        精度（避免高精度计算）。
       </li>
       <li>
        禁用
        <code>
         Alpha Test
        </code>
        减少 Overdraw，或改用
        <code>
         Alpha Blend
        </code>
        但要排序渲染顺序。
       </li>
       <li>
        避免使用
        <code>
         discard
        </code>
        操作（可能打断 GPU 的 Tile-Based Rendering）。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       PC/主机端
      </strong>
      ：
      <ul>
       <li>
        利用 Compute Shader 或 Geometry Shader 处理复杂计算（需硬件支持）。
       </li>
       <li>
        启用 GPU Instancing 减少 Draw Call（尤其适用于大量重复物体）。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      6. 工具与调试
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       性能分析工具
      </strong>
      ：
      <ul>
       <li>
        <strong>
         Unity Profiler
        </strong>
        ：检查
        <code>
         GPU Usage
        </code>
        和
        <code>
         SetPass Calls
        </code>
        。
       </li>
       <li>
        <strong>
         Frame Debugger
        </strong>
        ：逐帧分析渲染流程和 Shader 开销。
       </li>
       <li>
        <strong>
         RenderDoc
        </strong>
        ：深入分析 GPU 指令和纹理/缓冲区使用。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       Shader LOD
      </strong>
      ：
      <ul>
       <li>
        为不同距离的物体设置不同复杂度的 Shader（通过
        <code>
         LOD
        </code>
        指令）。
       </li>
      </ul>
     </li>
    </ul>
    <pre><code>SubShader {
    LOD 200 // 高复杂度
    // ...
}
SubShader {
    LOD 100 // 低复杂度
    // ...
}</code></pre>
    <h4>
     <strong>
      7. 其他高级技巧
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       预计算与缓存
      </strong>
      ：
      <ul>
       <li>
        使用 Light Probes 或 Reflection Probes 缓存环境光照。
       </li>
       <li>
        预计算复杂数学运算（如将菲涅尔项存储到纹理）。
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       GPU Instancing
      </strong>
      ：
      <ul>
       <li>
        对相同材质的物体启用 Instancing，减少 CPU 到 GPU 的数据传输。
       </li>
      </ul>
     </li>
    </ul>
    <pre><code>#pragma multi_compile_instancing
UNITY_INSTANCING_BUFFER_START(Props)
    // 声明实例化属性
UNITY_INSTANCING_BUFFER_END(Props)</code></pre>
    <ul>
     <li>
      <strong>
       SRP Batcher
      </strong>
      ：
      <ul>
       <li>
        在 URP/HDRP 中启用 SRP Batcher，减少材质切换开销。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <strong>
      总结检查表
     </strong>
    </h4>
    <ol>
     <li>
      是否移除了冗余计算和纹理采样？
     </li>
     <li>
      是否合理降低了数学运算精度？
     </li>
     <li>
      是否启用了 Instancing 或 SRP Batcher？
     </li>
     <li>
      是否管理了 Shader 变体数量？
     </li>
     <li>
      是否针对目标平台（如移动端）做了特殊优化？
     </li>
     <li>
      是否通过工具验证了优化效果？
     </li>
    </ol>
    <p>
     通过逐步应用上述策略，并结合实际性能分析，可显著降低 Shader 的开销，同时保持视觉质量。
    </p>
    <p>
     <strong>
      更多教学视频
     </strong>
    </p>
    <p>
     <a href="https://link.zhihu.com/?target=https%3A//www.bycwedu.com/promotion_channels/2146264125" rel="nofollow" title="Unity3D​www.bycwedu.com/promotion_channels/2146264125">
      Unity3D​www.bycwedu.com/promotion_channels/2146264125
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f54686f6d61735f5958512f:61727469636c652f64657461696c732f313436313936343836" class_="artid" style="display:none">
 </p>
</div>


