---
layout: post
title: "设计模式-单例模式SingletonC"
date: 2025-03-07 20:01:12 +0800
description: "设计模式--单例模式"
keywords: "设计模式--单例模式(Singleton)【C++】"
categories: ['设计模式']
tags: ['设计模式', '单例模式']
artid: "146103516"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146103516
    alt: "设计模式-单例模式SingletonC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146103516
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146103516
cover: https://bing.ee123.net/img/rand?artid=146103516
image: https://bing.ee123.net/img/rand?artid=146103516
img: https://bing.ee123.net/img/rand?artid=146103516
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     设计模式--单例模式(Singleton)【C++】
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     引言
    </h3>
    <p>
     在设计模式中，单例模式（Singleton Pattern）是一种非常常见且实用的模式。它的核心思想是确保一个类只有一个实例，并提供一个全局访问点。这种模式在需要全局唯一对象的场景中非常有用，比如配置管理、日志记录、数据库连接池等。
    </p>
    <p>
     本文将通过一个简单的 C++ 示例，带你理解单例模式的基本概念和实现方法。即使你是设计模式的新手，也能轻松掌握！
    </p>
    <hr/>
    <h3>
     什么是单例模式？
    </h3>
    <p>
     单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。它的主要特点包括：
    </p>
    <ol>
     <li>
      <strong>
       唯一性
      </strong>
      ：整个程序中只有一个实例存在。
     </li>
     <li>
      <strong>
       全局访问
      </strong>
      ：通过一个静态方法或变量来访问该实例。
     </li>
    </ol>
    <p>
     单例模式的核心思想是通过控制类的实例化过程，避免外部代码随意创建多个实例。
    </p>
    <hr/>
    <h3>
     为什么需要单例模式？
    </h3>
    <p>
     在某些场景中，我们需要确保一个类只有一个实例。例如：
    </p>
    <ul>
     <li>
      <strong>
       配置管理
      </strong>
      ：程序的配置信息只需要加载一次，全局共享。
     </li>
     <li>
      <strong>
       日志记录
      </strong>
      ：日志系统只需要一个实例来记录所有日志。
     </li>
     <li>
      <strong>
       数据库连接池
      </strong>
      ：数据库连接池只需要一个实例来管理所有连接。
     </li>
    </ul>
    <p>
     如果这些场景中允许多个实例存在，可能会导致资源浪费或数据不一致的问题。
    </p>
    <h3>
     C++实现单例模式
    </h3>
    <blockquote>
     <p>
      <strong>
       先从简单的单例模式入手，通过简单的锁机制实现单例
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;

class Singleton {
protected:
    Singleton() = default;//禁止外部构造
    Singleton(const Singleton&amp;) = delete;//禁止外部拷贝构造
    ~Singleton() { std::cout &lt;&lt; "~Singleton" &lt;&lt; std::endl; }//禁止外部析构
    Singleton&amp; operator=(const Singleton&amp;) = delete;//禁止外部赋值
    static Singleton* _instance;//单例对象指针
    static std::mutex s_mutex; //互斥锁

public:
    //获取单例实例
    static Singleton* GetInstance() {//通过双重检查实现单例
        if (_instance == nullptr) {
            std::lock_guard&lt;std::mutex&gt; lock(s_mutex);//加锁
            if (_instance == nullptr) {
                _instance = new Singleton();//初始化单例对象
            }
        }
        return _instance;
    }
    //打印单例实例地址
    void PrintAddress() { std::cout &lt;&lt; _instance &lt;&lt; std::endl; }
};
//初始化静态成员变量
Singleton* Singleton::_instance = nullptr;
std::mutex Singleton::s_mutex;

int main() {
    Singleton* singleton1 = Singleton::GetInstance();
    singleton1-&gt;PrintAddress();
    Singleton* singleton2 = Singleton::GetInstance();
    singleton2-&gt;PrintAddress();
    std::cout &lt;&lt; "Address: " &lt;&lt; singleton1 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Address: " &lt;&lt; singleton2 &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <blockquote>
     <p>
      <strong>
       通过这个例子，你会发现singleton1和singleton2的地址相同
      </strong>
      。
     </p>
     <p>
      <strong>
       如果我们想通过单例模式来创建其他类实例，需要引入模板，参考下列代码。
      </strong>
     </p>
     <p>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        假设我们需要创建一个Redis连接池，通过单例模式实现可以确保一个实例管理所有链接
       </strong>
      </span>
     </p>
    </blockquote>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
class RedisConPool : public Singleton&lt;RedisConPool&gt;{
    friend class Singleton&lt;RedisConPool&gt;;//允许Singleton访问Redis的私有成员
private:
    Redis(){std::cout &lt;&lt; "RedisConPool instance created!" &lt;&lt; std::endl;}
    ~Redis(){std::cout &lt;&lt; "RedisConPool instance destroyed!" &lt;&lt; std::endl;}
};
template&lt;typename T&gt;
class Singleton {
protected:
    Singleton() = default;//禁止外部构造
    Singleton(const Singleton&lt;T&gt;&amp;) = delete;//禁止外部拷贝构造
    ~Singleton() { std::cout &lt;&lt; "~Singleton" &lt;&lt; std::endl; }//禁止外部析构
    Singleton&lt;T&gt;&amp; operator=(const Singleton&lt;T&gt;&amp;) = delete;//禁止外部赋值
    static std::shared_ptr&lt;T&gt; _instance;//单例对象智能指针
    static std::once_flag s_flag;//保证单例对象只被初始化一次
public:
    //获取单例实例
    static std::shared_ptr&lt;T&gt; GetInstance() {
        std::claa_once(s_flag,[&amp;]() {
            _instance = std::shared_ptr&lt;T&gt;(new T);//初始化单例对象
        });
        return _instance;
    }
    //打印单例实例地址
    void PrintAddress() { std::cout &lt;&lt; _instance.get() &lt;&lt; std::endl; }

};
//初始化静态成员变量
template&lt;typename T&gt;
std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = nullptr;
template&lt;typename T&gt;
std::once_flag Singleton&lt;T&gt;::s_flag;

int main() {
    //获取单例实例
    std::shared_ptr&lt;RedisConPool&gt; redis1 = Singleton&lt;RedisConPool&gt;::GetInstance();
    std::shared_ptr&lt;RedisConPool&gt; redis2 = Singleton&lt;RedisConPool&gt;::GetInstance();
    redis1-&gt;PrintAddress();
    redis2-&gt;PrintAddress();
    //比较两个单例实例的地址
    std::cout &lt;&lt; "redis1 == redis2 ? " &lt;&lt; (redis1 == redis2) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <blockquote>
     <p>
      <strong>
       通过引入模板和智能指针单例类可以更方便的
       <span style="color:#fe2c24">
        管理仅需一个实例的类
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f416d617a696e675f736e61636b2f:61727469636c652f64657461696c732f313436313033353136" class_="artid" style="display:none">
 </p>
</div>


