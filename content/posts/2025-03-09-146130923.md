---
layout: post
title: "JavaWeb后端基础7AOP"
date: 2025-03-09 13:47:03 +0800
description: "AOP是Spring框架的核心之一，那什么是AOP？AOP：Aspect Oriented Programming（面向切面编程、面向方面编程），其实说白了，面向切面编程就是面向特定方法编程。AOP是一种思想，而在Spring框架中，对这种思想进行了实现，那我们要学习的就是Spring AOP。"
keywords: "JavaWeb后端基础（7）AOP"
categories: ['Javaweb']
tags: ['开发语言', 'Web', 'Java']
artid: "146130923"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146130923
    alt: "JavaWeb后端基础7AOP"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146130923
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146130923
cover: https://bing.ee123.net/img/rand?artid=146130923
image: https://bing.ee123.net/img/rand?artid=146130923
img: https://bing.ee123.net/img/rand?artid=146130923
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JavaWeb后端基础（7）AOP
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     AOP是Spring框架的核心之一，那什么是AOP？AOP：Aspect Oriented Programming（面向切面编程、面向方面编程），其实说白了，面向切面编程就是面向特定方法编程。AOP是一种思想，而在Spring框架中，对这种思想进行了实现，那我们要学习的就是Spring AOP。
    </p>
    <h2>
     如何实现AOP开发
    </h2>
    <h3>
     案例：
    </h3>
    <p>
     统计部门管理各个业务层方法执行耗时。在原始的实现方式中，我们需要在业务层的也一个方法执行执行，获取方法运行的开始时间； 然后运行原始的方法逻辑； 最后在每一个方法运行结束时，获取方法运行结束时间，计算执行耗时。
    </p>
    <h3>
     AOP实现步骤：
    </h3>
    <p>
     1、导入依赖
    </p>
    <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
    <p>
     2、编写AOP程序：针对于特定方法根据业务需要进行编程
    </p>
    <pre><code class="language-java">@Component
@Aspect //当前类为切面类
@Slf4j
public class RecordTimeAspect {

    @Around("execution(* com.itheima.service.impl.DeptServiceImpl.*(..))")
    public Object recordTime(ProceedingJoinPoint pjp) throws Throwable {
        //记录方法执行开始时间
        long begin = System.currentTimeMillis();

        //执行原始方法
        Object result = pjp.proceed();

        //记录方法执行结束时间
        long end = System.currentTimeMillis();

        //计算方法执行耗时
        log.info("方法执行耗时: {}毫秒",end-begin);
        return result;
    }
}</code></pre>
    <h3>
     应用场景：
    </h3>
    <p>
     AOP的应用场景有很多：
    </p>
    <ul>
     <li>
      <p>
       记录系统的操作日志
      </p>
     </li>
     <li>
      <p>
       权限控制
      </p>
     </li>
     <li>
      <p>
       事务管理：Spring事务管理，底层其实也是通过AOP来实现的，只要添加@Transactional注解之后，AOP程序自动会在原始方法运行前先来开启事务，在原始方法运行完毕之后提交或回滚事务
      </p>
     </li>
    </ul>
    <h3>
     优势：
    </h3>
    <ul>
     <li>
      <p>
       代码无侵入：没有修改原始的业务方法，就已经对原始的业务方法进行了功能的增强或者是功能的改变
      </p>
     </li>
     <li>
      <p>
       减少了重复代码
      </p>
     </li>
     <li>
      <p>
       提高开发效率
      </p>
     </li>
     <li>
      <p>
       维护方便
      </p>
     </li>
    </ul>
    <h2>
     AOP中的核心概念
    </h2>
    <ul>
     <li>
      <p>
       <strong>
        连接点：JoinPoint
       </strong>
       ，可以被AOP控制的方法（暗含方法执行时的相关信息）。连接点指的是可以被aop控制的方法。SpringAOP提供的JoinPoint当中，封装了连接点方法在执行时的相关信息。
      </p>
     </li>
     <li>
      <p>
       <strong>
        通知：Advice
       </strong>
       ，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）。在AOP面向切面编程当中，我们只需要将这部分重复的代码逻辑抽取出来单独定义。抽取出来的这一部分重复的逻辑，也就是共性的功能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        切入点：PointCut
       </strong>
       ，匹配连接点的条件，通知仅会在切入点方法执行时被应用。切入点指的是匹配连接点的条件。通知仅会在切入点方法运行时才会被应用。在aop的开发当中，我们通常会通过一个切入点表达式来描述切入点
      </p>
     </li>
     <li>
      <p>
       <strong>
        切面：Aspect
       </strong>
       ，描述通知与切入点的对应关系（通知+切入点）当通知和切入点结合在一起，就形成了一个切面。通过切面就能够描述当前aop程序需要针对于哪个原始方法，在什么时候执行什么样的操作。
      </p>
      <ul>
      </ul>
      <ul>
      </ul>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       <strong>
        目标对象：Target
       </strong>
       ，通知所应用的对象。目标对象指的就是通知所应用的对象，我们就称之为目标对象。
      </p>
     </li>
    </ul>
    <p>
     SpringAOP 旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程 。
    </p>
    <h2>
     AOP进阶
    </h2>
    <p>
     AOP的基础知识学习完之后，下面我们对AOP当中的各个细节进行详细的学习。主要分为3个部分：
    </p>
    <ol>
     <li>
      <p>
       通知类型
      </p>
     </li>
     <li>
      <p>
       通知顺序
      </p>
     </li>
     <li>
      <p>
       切入点表达式
      </p>
     </li>
    </ol>
    <h3>
     通知类型
    </h3>
    <table>
     <tbody>
      <tr>
       <td colspan="2" rowspan="1">
        <p>
         <strong>
          Spring AOP 通知类型
         </strong>
        </p>
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        <p>
         @Around
        </p>
       </td>
       <td colspan="1" rowspan="1">
        <p>
         环绕通知，此注解标注的通知方法在目标方法前、后都被执行
        </p>
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        <p>
         @Before
        </p>
       </td>
       <td colspan="1" rowspan="1">
        <p>
         前置通知，此注解标注的通知方法在目标方法前被执行
        </p>
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        <p>
         @After
        </p>
       </td>
       <td colspan="1" rowspan="1">
        <p>
         后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
        </p>
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        <p>
         @AfterReturning
        </p>
       </td>
       <td colspan="1" rowspan="1">
        <p>
         返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行
        </p>
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        <p>
         @AfterThrowing
        </p>
       </td>
       <td colspan="1" rowspan="1">
        <p>
         异常后通知，此注解标注的通知方法发生异常后执行
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-java">//前置通知
@Before("execution(* com.itheima.service.*.*(..))")

//环绕通知
@Around("execution(* com.itheima.service.*.*(..))")
  
//后置通知
@After("execution(* com.itheima.service.*.*(..))")

//返回后通知（程序在正常执行的情况下，会执行的后置通知）
@AfterReturning("execution(* com.itheima.service.*.*(..))")

//异常通知（程序在出现异常的情况下，执行的后置通知）
@AfterThrowing("execution(* com.itheima.service.*.*(..))")</code></pre>
    <p>
    </p>
    <p>
     在使用通知时的注意事项：
    </p>
    <ul>
     <li>
      <p>
       @Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行
      </p>
     </li>
     <li>
      <p>
       @Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。
      </p>
     </li>
    </ul>
    <p>
     Spring提供了
     <code>
      @PointCut
     </code>
     注解，该注解的作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可
    </p>
    <p>
     举例：
    </p>
    <pre><code class="language-java">@Slf4j
@Component
@Aspect
public class MyAspect1 {

    //切入点方法（公共的切入点表达式）
    @Pointcut("execution(* com.itheima.service.*.*(..))")
    private void pt(){}

    //前置通知（引用切入点）
    @Before("pt()")
    public void before(JoinPoint joinPoint){
        log.info("before ...");

    }

    //环绕通知
    @Around("pt()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info("around before ...");

        //调用目标对象的原始方法执行
        Object result = proceedingJoinPoint.proceed();
        //原始方法在执行时：发生异常
        //后续代码不在执行

        log.info("around after ...");
        return result;
    }

    //后置通知
    @After("pt()")
    public void after(JoinPoint joinPoint){
        log.info("after ...");
    }

    //返回后通知（程序在正常执行的情况下，会执行的后置通知）
    @AfterReturning("pt()")
    public void afterReturning(JoinPoint joinPoint){
        log.info("afterReturning ...");
    }

    //异常通知（程序在出现异常的情况下，执行的后置通知）
    @AfterThrowing("pt()")
    public void afterThrowing(JoinPoint joinPoint){
        log.info("afterThrowing ...");
    }
}</code></pre>
    <h3>
     通知顺序
    </h3>
    <ul>
     <li>
      <p>
       默认按照切面类的类名字母排序：
      </p>
      <ul>
       <li>
        <p>
         目标方法前的通知方法：字母排名靠前的先执行
        </p>
       </li>
       <li>
        <p>
         目标方法后的通知方法：字母排名靠前的后执行
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     如果我们想控制通知的执行顺序有两种方式：
    </p>
    <ol>
     <li>
      <p>
       修改切面类的类名（这种方式非常繁琐、而且不便管理）
      </p>
     </li>
     <li>
      <p>
       使用Spring提供的
       <code>
        @Order
       </code>
       注解
      </p>
     </li>
    </ol>
    <p>
     切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行）
    </p>
    <h3>
     切入点表达式
    </h3>
    <p>
     切入点表达式：描述切入点方法的一种表达式，主要用来决定项目中的哪些方法需要加入通知
    </p>
    <p>
     常见形式：
    </p>
    <ul>
     <li>
      <p>
       execution(……)：根据方法的签名来匹配
      </p>
     </li>
     <li>
      <p>
       @annotation(……) ：根据注解匹配
      </p>
     </li>
    </ul>
    <h4>
     execution
    </h4>
    <p>
     execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为下。其中带
     <code>
      ?
     </code>
     的表示可以省略的部分
    </p>
    <pre><code class="language-java">execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)</code></pre>
    <p>
     可以使用通配符描述切入点
    </p>
    <ul>
     <li>
      <p>
       <code>
        *
       </code>
       ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分
      </p>
     </li>
     <li>
      <p>
       <code>
        ..
       </code>
       ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数
      </p>
     </li>
    </ul>
    <h4>
     切入点表达式的语法规则
    </h4>
    <ol>
     <li>
      <p>
       方法的访问修饰符可以省略
      </p>
     </li>
     <li>
      <p>
       返回值可以使用
       <code>
        *
       </code>
       号代替（任意返回值类型）
      </p>
     </li>
     <li>
      <p>
       包名可以使用
       <code>
        *
       </code>
       号代替，代表任意包（一层包使用一个
       <code>
        *
       </code>
       ）
      </p>
     </li>
     <li>
      <p>
       使用
       <code>
        ..
       </code>
       配置包名，标识此包以及此包下的所有子包
      </p>
     </li>
     <li>
      <p>
       类名可以使用
       <code>
        *
       </code>
       号代替，标识任意类
      </p>
     </li>
     <li>
      <p>
       方法名可以使用
       <code>
        *
       </code>
       号代替，表示任意方法
      </p>
     </li>
     <li>
      <p>
       可以使用
       <code>
        *
       </code>
       配置参数，一个任意类型的参数
      </p>
     </li>
     <li>
      <p>
       可以使用
       <code>
        ..
       </code>
       配置参数，任意个任意类型的参数
      </p>
     </li>
    </ol>
    <h4>
     @annotation
    </h4>
    <p>
     如果我们要匹配多个无规则的方法，比如：list()和 delete()这两个方法。这个时候我们基于execution这种切入点表达式来描述就不是很方便了。而在之前我们是将两个切入点表达式组合在了一起完成的需求，这个是比较繁琐的。
    </p>
    <p>
     我们可以借助于另一种切入点表达式
     <code>
      @annotation
     </code>
     来描述这一类的切入点，从而来简化切入点表达式的书写。
    </p>
    <p>
     实现步骤：
    </p>
    <ol>
     <li>
      <p>
       编写自定义注解
      </p>
     </li>
     <li>
      <p>
       在业务类要做为连接点的方法上添加自定义注解
      </p>
     </li>
    </ol>
    <p>
     举例：
    </p>
    <pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogOperation{
}</code></pre>
    <p>
    </p>
    <pre><code class="language-java">@Slf4j
@Component
@Aspect
public class MyAspect6 {
    //针对list方法、delete方法进行前置通知和后置通知

    //前置通知
    @Before("@annotation(com.itheima.anno.LogOperation)")
    public void before(){
        log.info("MyAspect6 -&gt; before ...");
    }
    
    //后置通知
    @After("@annotation(com.itheima.anno.LogOperation)")
    public void after(){
        log.info("MyAspect6 -&gt; after ...");
    }
}</code></pre>
    <ul>
     <li>
      <p>
       execution切入点表达式
      </p>
      <ul>
       <li>
        <p>
         根据我们所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式
        </p>
       </li>
       <li>
        <p>
         如果我们要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       annotation 切入点表达式
      </p>
      <ul>
       <li>
        <p>
         基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，我们需要自定义一个注解，但是相对来比较灵活。我们需要匹配哪个方法，就在方法上加上对应的注解就可以了
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     根据业务需要，可以使用 &amp;&amp; ，||，！ 来组合比较复杂的切入点表达式。
    </p>
    <h2>
     连接点补充
    </h2>
    <p>
     在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。
    </p>
    <ul>
     <li>
      <p>
       对于
       <code>
        @Around
       </code>
       通知，获取连接点信息只能使用
       <code>
        ProceedingJoinPoint
       </code>
       类型
      </p>
     </li>
     <li>
      <p>
       对于其他四种通知，获取连接点信息只能使用
       <code>
        JoinPoint
       </code>
       ，它是
       <code>
        ProceedingJoinPoint
       </code>
       的父类型
      </p>
     </li>
    </ul>
    <p>
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/7b4304b9eee94edbaed82c0311f06216.png" width="760">
      <img alt="" height="261" src="https://i-blog.csdnimg.cn/direct/0dc535887f8b4e0d92b0a802fc43b0fa.png" width="770"/>
     </img>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f36303437303436302f:61727469636c652f64657461696c732f313436313330393233" class_="artid" style="display:none">
 </p>
</div>


