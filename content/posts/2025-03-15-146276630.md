---
layout: post
title: "qt-stm32-发送接受浮点数以及两字节数"
date: 2025-03-15 11:32:38 +0800
description: "bool ok;// 输入验证if (!ok) {ui->status->setText(\"电流输入无效，请重新输入\");return;// 设置CAN消息参数// 1字节信号 + 4字节浮点数// 固定信号字节// 将浮点数转换为4字节（考虑字节序）// 假设接收端使用小端模式（默认与x86兼容）// 如果接收端是大端模式，需要反转字节顺序// 调试输出字节内容。"
keywords: "qt stm32 发送接受浮点数以及两字节数"
categories: ['未分类']
tags: ['开发语言', 'Stm', 'Qt']
artid: "146276630"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146276630
    alt: "qt-stm32-发送接受浮点数以及两字节数"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146276630
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146276630
cover: https://bing.ee123.net/img/rand?artid=146276630
image: https://bing.ee123.net/img/rand?artid=146276630
img: https://bing.ee123.net/img/rand?artid=146276630
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     qt stm32 发送接受浮点数以及两字节数
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     void MainWindow::on_pushButton_4_clicked()
     <br/>
     {
     <!-- -->
     <br/>
     TPCANMsg msg;
     <br/>
     bool ok;
     <br/>
     float dianliu = ui-&gt;lineEditdianliu-&gt;text().toFloat(&amp;ok);
     <br/>
     <br/>
     // 输入验证
     <br/>
     if (!ok) {
     <!-- -->
     <br/>
     ui-&gt;status-&gt;setText("电流输入无效，请重新输入");
     <br/>
     return;
     <br/>
     }
    </p>
    <p>
     // 设置CAN消息参数
     <br/>
     msg.MSGTYPE = static_cast&lt;BYTE&gt;(ui-&gt;framegeshi-&gt;currentIndex());
     <br/>
     msg.ID = (ui-&gt;frameid-&gt;text().toUInt(&amp;ok, 16)) &amp; 0x7FF;
     <br/>
     msg.LEN = 5;  // 1字节信号 + 4字节浮点数
     <br/>
     <br/>
     // 固定信号字节
     <br/>
     msg.DATA[0] = 0xDD;
    </p>
    <p>
     // 将浮点数转换为4字节（考虑字节序）
     <br/>
     unsigned char* ptr = reinterpret_cast&lt;unsigned char*&gt;(&amp;dianliu);
     <br/>
     <br/>
     // 假设接收端使用小端模式（默认与x86兼容）
     <br/>
     // 如果接收端是大端模式，需要反转字节顺序
     <br/>
     msg.DATA[1] = ptr[0];
     <br/>
     msg.DATA[2] = ptr[1];
     <br/>
     msg.DATA[3] = ptr[2];
     <br/>
     msg.DATA[4] = ptr[3];
    </p>
    <p>
     // 调试输出字节内容
     <br/>
     qDebug() &lt;&lt; "发送电流数据 (HEX):"
     <br/>
     &lt;&lt; QString::number(msg.DATA[0], 16)
     <br/>
     &lt;&lt; QString::number(msg.DATA[1], 16)
     <br/>
     &lt;&lt; QString::number(msg.DATA[2], 16)
     <br/>
     &lt;&lt; QString::number(msg.DATA[3], 16)
     <br/>
     &lt;&lt; QString::number(msg.DATA[4], 16);
    </p>
    <p>
     // 发送CAN消息
     <br/>
     TPCANStatus status = CAN_Write(PCAN_USBBUS1, &amp;msg);
    </p>
    <p>
     if (status != PCAN_ERROR_OK) {
     <!-- -->
     <br/>
     QString error = QString("电流发送失败，错误代码: 0x%1").arg(status, 0, 16);
     <br/>
     ui-&gt;status-&gt;setText(error);
     <br/>
     return;
     <br/>
     }
    </p>
    <p>
     ui-&gt;status-&gt;setText(QString("电流设置成功: %1 A").arg(dianliu));
     <br/>
     }
    </p>
    <p>
     下位机接受;
    </p>
    <p>
     // 假设接收数据存储在 rxData[5]
     <br/>
     if (rxData[0] == 0xDD) {
     <!-- -->
     <br/>
     // 提取浮点数字节
     <br/>
     unsigned char bytes[4] = {rxData[1], rxData[2], rxData[3], rxData[4]};
     <br/>
     float current;
     <br/>
     memcpy(&amp;current, bytes, 4);
     <br/>
     printf("接收电流值: %f A\n", current);
     <br/>
     }
    </p>
    <p>
     TPCANMsg msg;
     <br/>
     bool ok;
     <br/>
     int time=ui-&gt;lineEdittime-&gt;text().toInt(&amp;ok,10);
     <br/>
     if (!ok || time&lt; 0 || time &gt; 9999) {
     <!-- -->
     <br/>
     ui-&gt;status-&gt;setText("占空比输入无效，请输入0~9999的整数");
     <br/>
     return;
     <br/>
     }
     <br/>
     msg.DATA[0] = 0xCC;
     <br/>
     msg.MSGTYPE = static_cast&lt;BYTE&gt;(ui-&gt;framegeshi-&gt;currentIndex());
     <br/>
     msg.ID = (ui-&gt;frameid-&gt;text().toUInt(&amp;ok, 16)) &amp; 0x7FF;
     <br/>
     msg.LEN = 3;
     <br/>
     msg.DATA[1]=(time&gt;&gt;8)&amp;0xff;
     <br/>
     msg.DATA[2] = time&amp; 0xFF;
     <br/>
     TPCANStatus status = CAN_Write(PCAN_USBBUS1, &amp;msg);
     <br/>
     <br/>
     if (status != PCAN_ERROR_OK) {
     <!-- -->
     <br/>
     QString error = QString("发送失败，错误代码: 0x%1").arg(status, 0, 16);
     <br/>
     ui-&gt;status-&gt;setText(error);
     <br/>
     return;
     <br/>
     }
     <br/>
     <br/>
     qDebug() &lt;&lt; "占空比设置成功: 信号=0xcc 数值=" &lt;&lt; time&lt;&lt; "%";
     <br/>
     ui-&gt;status-&gt;setText(QString("占空比设置成功: 数值=%1%").arg(time));
    </p>
    <h4>
     <strong>
      上位机（Qt）接收代码
     </strong>
    </h4>
    <pre></pre>
    <p>
     cpp
    </p>
    <pre><code>// 在MainWindow类中定义CAN接收线程或槽函数
void MainWindow::initCANReceiver() {
    // 启动定时器或线程持续读取CAN消息
    QTimer *timer = new QTimer(this);
    connect(timer, &amp;QTimer::timeout, this, &amp;MainWindow::readCANData);
    timer-&gt;start(10); // 每10ms读取一次
}

void MainWindow::readCANData() {
    TPCANMsg msg;
    TPCANStatus status;
    DWORD timestamp;

    // 读取CAN消息
    while (CAN_Read(PCAN_USBBUS1, &amp;msg, &amp;timestamp) == PCAN_ERROR_OK) {
        // 过滤特定ID的消息（假设目标ID为用户输入的ID）
        bool ok;
        uint targetID = ui-&gt;frameid-&gt;text().toUInt(&amp;ok, 16) &amp; 0x7FF;
        if (msg.ID != targetID) continue;

        // 解析数据（假设数据格式为3字节：[信号][高字节][低字节]）
        if (msg.LEN &gt;= 3 &amp;&amp; msg.DATA[0] == 0xA1) {
            uint16_t dutyCycle = (msg.DATA[1] &lt;&lt; 8) | msg.DATA[2];
            ui-&gt;status-&gt;setText(QString("接收占空比: %1%").arg(dutyCycle));
            qDebug() &lt;&lt; "Received duty cycle:" &lt;&lt; dutyCycle &lt;&lt; "%";
        }
    }
}</code></pre>
    <hr/>
    <h4>
     ​
     <strong>
      下位机（STM32 HAL库）接收代码
     </strong>
    </h4>
    <pre></pre>
    <p>
     c
    </p>
    <pre><code>// 在main.c中定义CAN接收回调函数
#include "stm32f1xx_hal.h"

CAN_HandleTypeDef hcan;
CAN_RxHeaderTypeDef rxHeader;
uint8_t rxData[8];

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
    // 读取CAN消息
    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &amp;rxHeader, rxData) == HAL_OK) {
        // 过滤特定ID的消息（假设目标ID为0x123）
        if (rxHeader.StdId == 0x123) {
            // 解析数据（假设数据格式为3字节：[信号][高字节][低字节]）
            if (rxData[0] == 0xA1 &amp;&amp; rxHeader.DLC &gt;= 3) {
                uint16_t dutyCycle = (rxData[1] &lt;&lt; 8) | rxData[2];
                // 应用占空比到PWM（示例代码）
                TIM1-&gt;CCR1 = dutyCycle; // 假设使用TIM1通道1输出PWM
            }
        }
    }
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36323338333436372f:61727469636c652f64657461696c732f313436323736363330" class_="artid" style="display:none">
 </p>
</div>


