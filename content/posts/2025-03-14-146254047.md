---
layout: post
title: "C-中的-RTTIRun-Time-Type-Information,运行时类型识别"
date: 2025-03-14 11:55:15 +0800
description: "RTTI 是 C++ 提供的一种机制，允许程序在运行时识别对象的类型信息。typeid运算符：返回对象的类型信息（以对象表示）。运算符：用于在继承体系中安全地将基类指针或引用转换为派生类类型。RTTI 依赖于多态性（即虚函数），只有在类中至少有一个虚函数时，编译器才会为该类生成运行时类型信息。描述：RTTI 允许程序员在运行时识别 C++ 类对象的类型。解释：RTTI 的核心功能是动态检查对象的实际类型，尤其在基类指针或引用指向派生类对象时。通过typeid或，程序可以在运行时做出类型相关的决策。"
keywords: "C++ 中的 RTTI（Run-Time Type Information，运行时类型识别）"
categories: ['未分类']
tags: ['开发语言', 'C']
artid: "146254047"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146254047
    alt: "C-中的-RTTIRun-Time-Type-Information,运行时类型识别"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146254047
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146254047
cover: https://bing.ee123.net/img/rand?artid=146254047
image: https://bing.ee123.net/img/rand?artid=146254047
img: https://bing.ee123.net/img/rand?artid=146254047
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ 中的 RTTI（Run-Time Type Information，运行时类型识别）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     我来为你详细讲解 C++ 中的
     <strong>
      RTTI（Run-Time Type Information，运行时类型识别）
     </strong>
     ，并结合你提供的参考内容进行分析和说明。
    </p>
    <hr/>
    <h4>
     <a id="_RTTI_4">
     </a>
     什么是 RTTI？
    </h4>
    <p>
     RTTI 是 C++ 提供的一种机制，允许程序在运行时识别对象的类型信息。它主要���过以下两个工具实现：
    </p>
    <ol>
     <li>
      <strong>
       <code>
        typeid
       </code>
       运算符
      </strong>
      ：返回对象的类型信息（以
      <code>
       std::type_info
      </code>
      对象表示）。
     </li>
     <li>
      <strong>
       <code>
        dynamic_cast
       </code>
       运算符
      </strong>
      ：用于在继承体系中安全地将基类指针或引用转换为派生类类型。
     </li>
    </ol>
    <p>
     RTTI 依赖于多态性（即虚函数），只有在类中至少有一个虚函数时，编译器才会为该类生成运行时类型信息。
    </p>
    <h5>
     <a id="_RTTI_12">
     </a>
     示例：使用 RTTI
    </h5>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 虚函数确保多态性</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Base<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 使用 typeid 获取类型信息</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出类似 "Derived"</span>

    <span class="token comment">// 使用 dynamic_cast 进行类型转换</span>
    Derived<span class="token operator">*</span> d <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Successfully cast to Derived"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <hr/>
    <h4>
     <a id="_43">
     </a>
     参考内容的讲解
    </h4>
    <p>
     参考内容明确提出“禁止使用 RTTI”，并从定义、优点、缺点和结论四个方面阐述了理由。以下是对其内容的逐条分析。
    </p>
    <h5>
     <a id="_47">
     </a>
     定义
    </h5>
    <ul>
     <li>
      <strong>
       描述
      </strong>
      ：RTTI 允许程序员在运行时识别 C++ 类对象的类型。
     </li>
     <li>
      <strong>
       解释
      </strong>
      ：RTTI 的核心功能是动态检查对象的实际类型，尤其在基类指针或引用指向派生类对象时。通过
      <code>
       typeid
      </code>
      或
      <code>
       dynamic_cast
      </code>
      ，程序可以在运行时做出类型相关的决策。
     </li>
    </ul>
    <h5>
     <a id="_51">
     </a>
     优点
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        单元测试中的用处
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         描述
        </strong>
        ：RTTI 在某些单元测试中非常有用，例如验证工厂类是否创建了预期的动态类型对象。
       </li>
       <li>
        <strong>
         解释
        </strong>
        ：在测试场景中，开发者可能需要确保某个函数返回的对象是指定的派生类类型。例如：
        <pre><code class="prism language-cpp">Base<span class="token operator">*</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">testFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Base<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 验证类型</span>
    <span class="token keyword">delete</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
        RTTI 提供了一种便捷的方式来检查动态类型是否正确。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        非测试场景的稀少使用
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         描述
        </strong>
        ：除测试外，RTTI 极少用到。
       </li>
       <li>
        <strong>
         解释
        </strong>
        ：在常规代码中，RTTI 的使用往往是特殊情况，大多数设计可以通过其他方式避免对运行时类型检查的依赖。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="_69">
     </a>
     缺点
    </h5>
    <ol>
     <li>
      <strong>
       设计问题的信号
      </strong>
      <ul>
       <li>
        <strong>
         描述
        </strong>
        ：运行时识别类型意味着设计本身有问题。如果需要在运行时确定对象的类型，通常需要重新考虑类的设计。
       </li>
       <li>
        <strong>
         解释
        </strong>
        ：RTTI 的使用往往暗示代码没有充分利用面向对象编程的多态性。例如：
        <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Base<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理 Derived</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理其他类型</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
        这种基于类型检查的逻辑通常可以通过虚函数或设计模式替代，减少运行时开销并提高代码可维护性。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="_84">
     </a>
     结论
    </h5>
    <ul>
     <li>
      <strong>
       禁用建议
      </strong>
      ：除单元测试外，不要使用 RTTI。
     </li>
     <li>
      <strong>
       原因
      </strong>
      ：RTTI 的使用可能表明设计缺陷，且有更好的替代方案。
     </li>
     <li>
      <strong>
       替代方案
      </strong>
      ：
      <ol>
       <li>
        <p>
         <strong>
          虚函数
         </strong>
        </p>
        <ul>
         <li>
          通过多态性，让对象自己处理类型相关的行为。
         </li>
         <li>
          示例：
          <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Base<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> obj<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 无需 RTTI</span>
</code></pre>
          这里，
          <code>
           process()
          </code>
          根据对象的实际类型自动调用正确的实现。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          双重分发（如 Visitor 模式）
         </strong>
        </p>
        <ul>
         <li>
          当需要在对象外部根据类型执行不同��作时，可以使用 Visitor 模式。
         </li>
         <li>
          示例：
          <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Visitor</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Derived<span class="token operator">&amp;</span> d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Visiting Derived"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token class-name">Derived</span><span class="token double-colon punctuation">::</span><span class="token function">accept</span><span class="token punctuation">(</span>Visitor<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> v<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
          Visitor 模式通过双重分发（
          <code>
           accept
          </code>
          和
          <code>
           visit
          </code>
          的协作）在对象外部实现类型特定逻辑，避免 RTTI。
         </li>
        </ul>
       </li>
       <li>
        <p>
         <strong>
          谨慎使用 RTTI
         </strong>
        </p>
        <ul>
         <li>
          如果虚函数或 Visitor 模式难以实现，且确实需要 RTTI，应三思而后行。
         </li>
         <li>
          <strong>
           反对手动 RTTI 替代方案
          </strong>
          ：不要通过类型标签（如枚举或字符串）手动实现类似 RTTI 的功能，这不仅复杂，还失去了 RTTI 的标准支持。
         </li>
        </ul>
       </li>
      </ol>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="RTTI__133">
     </a>
     RTTI 的优缺点（扩展分析）
    </h4>
    <h5>
     <a id="_135">
     </a>
     优点（补充）
    </h5>
    <ul>
     <li>
      <strong>
       动态性
      </strong>
      ：RTTI 提供运行时灵活性，适用于类型信息在编译时未知的场景。
     </li>
     <li>
      <strong>
       调试支持
      </strong>
      ：通过
      <code>
       typeid().name()
      </code>
      可以打印类型信息，便于调试。
     </li>
    </ul>
    <h5>
     <a id="_139">
     </a>
     缺点（补充）
    </h5>
    <ul>
     <li>
      <strong>
       性能开销
      </strong>
      ：RTTI 需要额外的运行时支持（如虚表扩展），增加二进制大小和执行开销。
     </li>
     <li>
      <strong>
       可维护性差
      </strong>
      ：依赖 RTTI 的代码往往难以理解和扩展，因为类型检查分散在条件语句中。
     </li>
     <li>
      <strong>
       编译器依赖
      </strong>
      ：某些编译器可能禁用 RTTI（如通过
      <code>
       -fno-rtti
      </code>
      ），导致代码不可移植。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="RTTI__146">
     </a>
     RTTI 的实际使用场景与禁忌
    </h4>
    <h5>
     <a id="_148">
     </a>
     允许场景
    </h5>
    <ul>
     <li>
      <strong>
       单元测试
      </strong>
      ：验证对象的动态类型，确保工厂函数或依赖注入的正确性。
     </li>
     <li>
      <strong>
       调试工具
      </strong>
      ：在日志或诊断代码中临时使用
      <code>
       typeid
      </code>
      。
     </li>
    </ul>
    <h5>
     <a id="_152">
     </a>
     禁用场景
    </h5>
    <ul>
     <li>
      <strong>
       常规业务逻辑
      </strong>
      ：不应在核心代码中依赖 RTTI 判断类型。
     </li>
     <li>
      <strong>
       性能敏感代码
      </strong>
      ：RTTI 的开销在高性能场景（如游戏引擎）中不可接受。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_RTTI_158">
     </a>
     如何避免 RTTI？
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        利用多态性
       </strong>
      </p>
      <ul>
       <li>
        通过虚函数将类型相关的行为封装在类内部，避免外部检查。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        设计模式
       </strong>
      </p>
      <ul>
       <li>
        使用 Visitor、Strategy 或其他模式，将类型特定逻辑从调用者中解耦。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        静态类型检查
       </strong>
      </p>
      <ul>
       <li>
        在编译时通过模板或类型 traits 解决问题。例如：
        <pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_base_of_v<span class="token operator">&lt;</span>Base<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token string">"T must derive from Base"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_178">
     </a>
     总结
    </h4>
    <ul>
     <li>
      <strong>
       定义
      </strong>
      ：RTTI 是 C++ 中用于运行时识别对象类型的机制，主要通过
      <code>
       typeid
      </code>
      和
      <code>
       dynamic_cast
      </code>
      实现。
     </li>
     <li>
      <strong>
       优点
      </strong>
      ：在单元测试中非常有用，但在其他场景中用途有限。
     </li>
     <li>
      <strong>
       缺点
      </strong>
      ：依赖 RTTI 通常是设计缺陷的信号，增加性能开销和维护难度。
     </li>
     <li>
      <strong>
       参考建议
      </strong>
      ：除测试外禁止使用 RTTI，推荐使用虚函数或 Visitor 模式替代。如果必须使用，应谨慎，避免手动实现类似功能。
     </li>
     <li>
      <strong>
       实践建议
      </strong>
      ：优先通过面向对象设计解决问题，只有在无其他选择时才考虑 RTTI。
     </li>
    </ul>
    <p>
     如果你有具体代码或场景需要进一步探讨，欢迎告诉我！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f637879686a6c2f:61727469636c652f64657461696c732f313436323534303437" class_="artid" style="display:none">
 </p>
</div>


