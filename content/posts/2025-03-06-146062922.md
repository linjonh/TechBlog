---
layout: post
title: "CC蓝桥杯算法真题打卡Day3"
date: 2025-03-06 12:13:20 +0800
description: "C/C++蓝桥杯算法真题打卡（Day3）"
keywords: "C/C++蓝桥杯算法真题打卡（Day3）"
categories: ['蓝桥杯']
tags: ['蓝桥杯', '算法', 'C', 'C']
artid: "146062922"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146062922
    alt: "CC蓝桥杯算法真题打卡Day3"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146062922
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146062922
cover: https://bing.ee123.net/img/rand?artid=146062922
image: https://bing.ee123.net/img/rand?artid=146062922
img: https://bing.ee123.net/img/rand?artid=146062922
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C/C++蓝桥杯算法真题打卡（Day3）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、
     <a href="https://www.luogu.com.cn/problem/P8598" rel="nofollow" title="P8598 [蓝桥杯 2013 省 AB] 错误票据 - 洛谷">
      P8598 [蓝桥杯 2013 省 AB] 错误票据 - 洛谷
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="971" src="https://i-blog.csdnimg.cn/direct/2671f8eb3f1442a7a4a5cdfbb6f37408.png" width="742"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int N;
    cin &gt;&gt; N;  // 读取数据行数
    unordered_map&lt;int, int&gt; idCount;  // 用于统计每个ID出现的次数
    vector&lt;int&gt; ids;                  // 用于存储所有ID（方便排序）
    int num;

    // 读取所有ID
    for (int i = 0; i &lt; N; i++) {
        while (cin &gt;&gt; num) {
            ids.push_back(num);  // 将ID存入vector
            idCount[num]++;      // 统计ID出现的次数
            if (cin.get() == '\n') break;  // 换行时结束当前行的读取
        }
    }

    // 对ID进行排序
    sort(ids.begin(), ids.end());

    int missing = -1, duplicate = -1;  // 断号ID和重号ID

    // 查找重号
    for (auto&amp; pair : idCount) {
        if (pair.second == 2) {
            duplicate = pair.first;  // 找到重号
            break;
        }
    }

    // 查找断号
    for (int i = ids[0]; i &lt;= ids.back(); i++) {
        if (idCount.find(i) == idCount.end()) {
            missing = i;  // 找到断号
            break;
        }
    }

    // 输出结果
    cout &lt;&lt; missing &lt;&lt; " " &lt;&lt; duplicate &lt;&lt; endl;

    return 0;
}</code></pre>
    <h3>
     <strong>
      代码思路
     </strong>
    </h3>
    <h4>
     ​
     <strong>
      1. 输入处理
     </strong>
    </h4>
    <ul>
     <li>
      读取数据行数
      <code>
       N
      </code>
      。
     </li>
     <li>
      使用
      <code>
       unordered_map&lt;int, int&gt;
      </code>
      统计每个ID出现的次数。
     </li>
     <li>
      使用
      <code>
       vector&lt;int&gt;
      </code>
      存储所有ID，方便后续排序。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      2. 读取所有ID
     </strong>
    </h4>
    <ul>
     <li>
      使用
      <code>
       while (cin &gt;&gt; num)
      </code>
      逐行读取ID，直到遇到换行符
      <code>
       \n
      </code>
      结束当前行的读取。
     </li>
     <li>
      将每个ID存入
      <code>
       vector&lt;int&gt; ids
      </code>
      中，并在
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      中统计其出现次数。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      3. 排序
     </strong>
    </h4>
    <ul>
     <li>
      对
      <code>
       vector&lt;int&gt; ids
      </code>
      进行排序，方便后续查找断号和重号。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      4. 查找重号
     </strong>
    </h4>
    <ul>
     <li>
      遍历
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      ，找到出现次数为2的ID，即为重号。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      5. 查找断号
     </strong>
    </h4>
    <ul>
     <li>
      从最小ID（
      <code>
       ids[0]
      </code>
      ）到最大ID（
      <code>
       ids.back()
      </code>
      ）遍历，检查每个ID是否在
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      中。
     </li>
     <li>
      如果某个ID不在
      <code>
       unordered_map
      </code>
      中，则说明它是断号。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      6. 输出结果
     </strong>
    </h4>
    <ul>
     <li>
      输出断号ID
      <code>
       missing
      </code>
      和重号ID
      <code>
       duplicate
      </code>
      。
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      代码实现细节
     </strong>
    </h3>
    <h4>
     ​
     <strong>
      1. 头文件
     </strong>
    </h4>
    <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;</code></pre>
    <ul>
     <li>
      使用万能头文件
      <code>
       bits/stdc++.h
      </code>
      ，包含所有标准库。
     </li>
     <li>
      使用
      <code>
       using namespace std
      </code>
      ，避免每次调用标准库时需要写
      <code>
       std::
      </code>
      。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      2. 主函数
     </strong>
    </h4>
    <pre><code>int main() {
    int N;
    cin &gt;&gt; N;</code></pre>
    <ul>
     <li>
      读取数据行数
      <code>
       N
      </code>
      。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      3. 数据存储
     </strong>
    </h4>
    <pre><code>unordered_map&lt;int, int&gt; idCount;
vector&lt;int&gt; ids;
int num;</code></pre>
    <ul>
     <li>
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      ：用于统计每个ID出现的次数。
     </li>
     <li>
      <code>
       vector&lt;int&gt; ids
      </code>
      ：用于存储所有ID，方便后续排序。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      4. 读取所有ID
     </strong>
    </h4>
    <pre><code>for (int i = 0; i &lt; N; i++) {
    while (cin &gt;&gt; num) {
        ids.push_back(num);
        idCount[num]++;
        if (cin.get() == '\n') break;
    }
}</code></pre>
    <ul>
     <li>
      逐行读取ID，存入
      <code>
       vector&lt;int&gt; ids
      </code>
      中。
     </li>
     <li>
      使用
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      统计每个ID出现的次数。
     </li>
     <li>
      当遇到换行符
      <code>
       \n
      </code>
      时，结束当前行的读取。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      5. 排序
     </strong>
    </h4>
    <pre><code>sort(ids.begin(), ids.end());</code></pre>
    <ul>
     <li>
      对
      <code>
       vector&lt;int&gt; ids
      </code>
      进行排序，方便后续查找断号和重号。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      6. 查找重号
     </strong>
    </h4>
    <pre><code>int missing = -1, duplicate = -1;
for (auto&amp; pair : idCount) {
    if (pair.second == 2) {
        duplicate = pair.first;
        break;
    }
}</code></pre>
    <ul>
     <li>
      遍历
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      ，找到出现次数为2的ID，即为重号。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      7. 查找断号
     </strong>
    </h4>
    <pre><code>for (int i = ids[0]; i &lt;= ids.back(); i++) {
    if (idCount.find(i) == idCount.end()) {
        missing = i;
        break;
    }
}</code></pre>
    <ul>
     <li>
      从最小ID（
      <code>
       ids[0]
      </code>
      ）到最大ID（
      <code>
       ids.back()
      </code>
      ）遍历，检查每个ID是否在
      <code>
       unordered_map&lt;int, int&gt; idCount
      </code>
      中。
     </li>
     <li>
      如果某个ID不在
      <code>
       unordered_map
      </code>
      中，则说明它是断号。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      8. 输出结果
     </strong>
    </h4>
    <pre><code>cout &lt;&lt; missing &lt;&lt; " " &lt;&lt; duplicate &lt;&lt; endl;</code></pre>
    <ul>
     <li>
      输出断号ID
      <code>
       missing
      </code>
      和重号ID
      <code>
       duplicate
      </code>
      。
     </li>
    </ul>
    <h4>
     ​
     <strong>
      9. 返回
     </strong>
    </h4>
    <pre><code>return 0;</code></pre>
    <ul>
     <li>
      程序正常结束。
     </li>
    </ul>
    <hr/>
    <h3>
     ​
     <strong>
      示例运行
     </strong>
    </h3>
    <h4>
     ​
     <strong>
      输入
     </strong>
    </h4>
    <pre><code>2
7 9
5 6 8 11 9</code></pre>
    <h4>
     ​
     <strong>
      输出
     </strong>
    </h4>
    <pre><code>10 9</code></pre>
    <hr/>
    <h3>
     ​
     <strong>
      总结
     </strong>
    </h3>
    <ul>
     <li>
      代码通过
      <code>
       unordered_map
      </code>
      统计ID出现次数，结合排序和遍历，高效地找到断号和重号。
     </li>
     <li>
      时间复杂度为
      <code>
       O(n)
      </code>
      ，其中
      <code>
       n
      </code>
      是ID的总数。
     </li>
     <li>
      代码逻辑清晰，适合处理题目描述中的场景。
     </li>
    </ul>
    <h3>
     还有另一种形式（
     <strong>
      不排序，直接使用哈希表
     </strong>
     ）：
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
using namespace std;

int main() {
    int N;
    cin &gt;&gt; N;  // 读取数据行数
    unordered_set&lt;int&gt; idSet;  // 用于存储所有ID
    int minID = INT_MAX, maxID = INT_MIN;  // 记录最小ID和最大ID
    int num;

    // 读取所有ID
    for (int i = 0; i &lt; N; i++) {
        while (cin &gt;&gt; num) {
            idSet.insert(num);  // 将ID存入哈希表
            minID = min(minID, num);  // 更新最小ID
            maxID = max(maxID, num);  // 更新最大ID
            if (cin.get() == '\n') break;  // 换行时结束当前行的读取
        }
    }

    int missing = -1, duplicate = -1;  // 断号ID和重号ID

    // 查找重号
    unordered_set&lt;int&gt; seen;
    for (int id : idSet) {
        if (seen.count(id)) {
            duplicate = id;  // 找到重号
            break;
        }
        seen.insert(id);
    }

    // 查找断号
    for (int i = minID; i &lt;= maxID; i++) {
        if (idSet.find(i) == idSet.end()) {
            missing = i;  // 找到断号
            break;
        }
    }

    // 输出结果
    cout &lt;&lt; missing &lt;&lt; " " &lt;&lt; duplicate &lt;&lt; endl;

    return 0;
}</code></pre>
    <p>
    </p>
    <h2>
     二、
     <a href="https://www.luogu.com.cn/problem/P8775" rel="nofollow" title="P8775 [蓝桥杯 2022 省 A] 青蛙过河 - 洛谷">
      P8775 [蓝桥杯 2022 省 A] 青蛙过河 - 洛谷
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="987" src="https://i-blog.csdnimg.cn/direct/e38375766ad84b7fb1578166faee4176.png" width="652"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define N 100005
using namespace std;

int n, T, h[N], ans;

int main() {
    // 读取河的宽度 n 和需要去学校的天数 T
    scanf("%d%d", &amp;n, &amp;T);
    // 将 T 乘以 2 得到实际过河的次数
    T &lt;&lt;= 1;
    
    // 读取每块石头的高度
    for (int i = 1; i &lt; n; ++i) scanf("%d", &amp;h[i]);
    
    // 使用滑动窗口的方法来找到满足条件的最小跳跃能力
    for (int i = 1, j = 0, sum = 0; i &lt; n; i++) {
        // 扩展窗口的右边界，直到累加的高度大于等于 T
        while (j &lt; n &amp;&amp; sum &lt; T) sum += h[++j];
        
        // 记录当前窗口的长度，即跳跃能力
        ans = max(ans, j - i + 1);
        
        // 缩小窗口的左边界，减去左边石头的高度
        sum -= h[i];
    }
    
    // 输出满足条件的最小跳跃能力
    printf("%d\n", ans);
    
    return 0;
}</code></pre>
    <h3>
     <span style="color:#fe2c24">
      <strong>
       规律：
      </strong>
     </span>
    </h3>
    <p>
     <span style="color:#0d0016">
      <strong>
       对于一个跳跃能力 y，青蛙能跳过河 2x 次，当且仅当对于每个长度为 y 的区间，这个区间内 h 的和都大于等于 2x
      </strong>
     </span>
    </p>
    <p>
     这个问题涉及到对青蛙跳跃能力和石头高度分布的分析。我们需要理解为什么对于一个跳跃能力 y，青蛙能够跳过河 2x次，当且仅当对于每个长度为 y 的区间，这个区间内石头高度 h 的和都大于等于 2x。
    </p>
    <hr/>
    <h3>
     1.
     <strong>
      问题背景
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       青蛙需要往返 2x 次，每次跳跃必须落在石头或岸上。
      </p>
     </li>
     <li>
      <p>
       每块石头的高度 h[i]表示这块石头可以被踩的次数。
      </p>
     </li>
     <li>
      <p>
       跳跃能力 y 表示青蛙一次跳跃的最大距离。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     2.
     <strong>
      跳跃能力 y 的含义
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       如果青蛙的跳跃能力是 y，那么它每次跳跃的距离不能超过 y。
      </p>
     </li>
     <li>
      <p>
       这意味着青蛙在跳跃时，只能选择距离当前位置不超过 y 的石头。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     3.
     <strong>
      为什么需要每个长度为 y 的区间和 ≥2x
     </strong>
    </h3>
    <ul>
     <li>
      <h4>
       <strong>
        必要性
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         如果存在一个长度为 y的区间，其石头高度和 &lt;2x，那么青蛙在这个区间内无法完成 2x 次跳跃。
        </p>
       </li>
       <li>
        <p>
         因为青蛙每次跳跃必须落在石头上，而石头的高度限制了可以被踩的次数。
        </p>
       </li>
       <li>
        <p>
         如果某个区间的石头高度和不足 2x，青蛙在这个区间内无法完成足够的跳跃次数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        充分性
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         如果每个长度为 y 的区间的石头高度和 ≥2x，那么青蛙可以在每个区间内完成足够的跳跃次数。
        </p>
       </li>
       <li>
        <p>
         因为青蛙的跳跃能力是 y，它可以在每个区间内自由选择石头进行跳跃，而不会受到石头高度不足的限制。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     4.
     <strong>
      具体分析
     </strong>
    </h3>
    <ul>
     <li>
      <h4>
       <strong>
        青蛙的跳跃路径
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         青蛙需要从起点跳到终点，再跳回起点，重复 x 次。
        </p>
       </li>
       <li>
        <p>
         每次跳跃的距离不能超过 y。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        区间的划分
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         将河分成若干个长度为 y 的区间。
        </p>
       </li>
       <li>
        <p>
         每个区间内的石头高度和必须≥2x，因为青蛙需要在这些区间内完成 2x2x 次跳跃。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        石头高度的作用
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         每块石头的高度 h[i] 表示这块石头可以被踩的次数。
        </p>
       </li>
       <li>
        <p>
         如果某个区间的石头高度和&lt;2x，那么青蛙在这个区间内无法完成 2x 次跳跃。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     5.
     <strong>
      举例说明
     </strong>
    </h3>
    <p>
     假设：
    </p>
    <ul>
     <li>
      <p>
       河的宽度 n=5。
      </p>
     </li>
     <li>
      <p>
       需要去学校的天数 x=1，实际过河次数 2x=2。
      </p>
     </li>
     <li>
      <p>
       石头高度 h=[3,1,2,1]。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      跳跃能力 y=2
     </strong>
     ：
    </h4>
    <ul>
     <li>
      <p>
       区间划分：
      </p>
      <ul>
       <li>
        <p>
         区间 1: 位置 1 和 2，高度和 3+1=4≥2。
        </p>
       </li>
       <li>
        <p>
         区间 2: 位置 2 和 3，高度和 1+2=3≥2。
        </p>
       </li>
       <li>
        <p>
         区间 3: 位置 3 和 4，高度和 2+1=3≥2。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       每个区间的石头高度和都 ≥2，因此青蛙可以完成 2 次跳跃。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      跳跃能力 y=1
     </strong>
     ：
    </h4>
    <ul>
     <li>
      <p>
       区间划分：
      </p>
      <ul>
       <li>
        <p>
         区间 1: 位置 1，高度和 3≥2。
        </p>
       </li>
       <li>
        <p>
         区间 2: 位置 2，高度和 1&lt;2。
        </p>
       </li>
       <li>
        <p>
         区间 3: 位置 3，高度和 2≥2。
        </p>
       </li>
       <li>
        <p>
         区间 4: 位置 4，高度和 1&lt;2。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       存在区间的石头高度和 &lt;2，因此青蛙无法完成 2 次跳跃。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     6.
     <strong>
      总结
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       对于一个跳跃能力 y，青蛙能够跳过河 2x 次，当且仅当对于每个长度为 y 的区间，这个区间内石头高度 h 的和都大于等于 2x。
      </p>
     </li>
     <li>
      <p>
       这是因为青蛙的跳跃能力限制了它每次跳跃的距离，而石头的高度限制了它可以在每块石头上踩的次数。
      </p>
     </li>
     <li>
      <p>
       如果某个区间的石头高度和不足2x，青蛙在这个区间内无法完成足够的跳跃次数。
      </p>
     </li>
     <li>
      <p>
       如果每个区间的石头高度和都 ≥2x，青蛙可以在每个区间内自由选择石头进行跳跃，完成 2x次跳跃。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     代码思路：
    </h3>
    <p>
     这段代码的目的是通过滑动窗口的方法，找到小青蛙的最小跳跃能力 y，使得它能够完成 2x 次往返跳跃。以下是代码的详细思路：
    </p>
    <hr/>
    <h4>
     1.
     <strong>
      输入处理
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        读取河的宽度 n 和需要去学校的天数 T
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          scanf("%d%d", &amp;n, &amp;T);
         </code>
         读取输入。
        </p>
       </li>
       <li>
        <p>
         河的宽度 n 表示从起点到终点共有 n 个位置（包括起点和终点）。
        </p>
       </li>
       <li>
        <p>
         T 是小青蛙需要去学校的天数，实际过河次数是 2T（往返各一次）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        将 T乘以 2
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          T &lt;&lt;= 1;
         </code>
         将 T左移一位，相当于 T=2T，表示实际过河次数。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     2.
     <strong>
      读取石头高度
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        读取每块石头的高度
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          for (int i = 1; i &lt; n; i++) scanf("%d", &amp;h[i]);
         </code>
         读取每块石头的高度。
        </p>
       </li>
       <li>
        <p>
         数组 h 的下标从 1 开始，表示从起点到终点之间的 n−1块石头的高度。
        </p>
       </li>
       <li>
        <p>
         h[i]表示距离起点 i的位置的石头高度。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     3.
     <strong>
      滑动窗口寻找最小跳跃能力
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        初始化滑动窗口
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          for (int i = 1, j = 0, sum = 0; i &lt; n; ++i)
         </code>
         初始化滑动窗口。
        </p>
       </li>
       <li>
        <p>
         i是窗口的左边界，表示当前跳跃的起点。
        </p>
       </li>
       <li>
        <p>
         j是窗口的右边界，表示当前跳跃的终点。
        </p>
       </li>
       <li>
        <p>
         sum 是窗口内石头高度的累加和。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        扩展窗口的右边界
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          while (j &lt; n &amp;&amp; sum &lt; T) sum += h[++j];
         </code>
         扩展窗口的右边界。
        </p>
       </li>
       <li>
        <p>
         不断将右边界 j向右移动，累加石头的高度，直到累加的高度 sum大于等于 T。
        </p>
       </li>
       <li>
        <p>
         这一步的目的是找到一个窗口，使得窗口内的石头高度总和足够支持 2T 次跳跃。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        记录窗口的长度
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          ans = max(ans, j - i + 1);
         </code>
         记录当前窗口的长度。
        </p>
       </li>
       <li>
        <p>
         窗口的长度 j−i+1表示当前跳跃能力 y。
        </p>
       </li>
       <li>
        <p>
         通过取最大值，确保找到最小的跳跃能力。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        缩小窗口的左边界
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          sum -= h[i];
         </code>
         缩小窗口的左边界。
        </p>
       </li>
       <li>
        <p>
         将左边界 i 向右移动，减去左边石头的高度，继续寻找更小的跳跃能力。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     4.
     <strong>
      输出结果
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        输出满足条件的最小跳跃能力
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用
         <code>
          printf("%d\n", ans);
         </code>
         输出结果。
        </p>
       </li>
       <li>
        <p>
         ans 是满足条件的最小跳跃能力 yy。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     代码的核心思想：
    </h3>
    <ul>
     <li>
      <h4>
       <strong>
        滑动窗口
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         通过滑动窗口的方法，动态调整窗口的左右边界，找到一个最小的窗口长度 y，使得窗口内的石头高度总和至少为 T。
        </p>
       </li>
       <li>
        <p>
         窗口的长度 y 表示小青蛙的跳跃能力。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        跳跃能力的定义
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         跳跃能力 y 表示小青蛙一次跳跃的最大距离。
        </p>
       </li>
       <li>
        <p>
         通过滑动窗口找到的 y是最小的跳跃能力，使得小青蛙能够完成 2T 次跳跃。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     代码的优化点：
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        滑动窗口的边界处理
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         窗口的右边界 j 不能超过 n，否则会越界。
        </p>
       </li>
       <li>
        <p>
         窗口的左边界 i 逐步向右移动，确保窗口长度最小。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        时间复杂度
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         滑动窗口的时间复杂度是 O(n)，因为每个石头最多被访问两次（一次扩展右边界，一次缩小左边界）。
        </p>
       </li>
       <li>
        <p>
         这种方法在 n≤10**5 的规模下非常高效。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     总结：
    </h3>
    <p>
     这段代码通过滑动窗口的方法，高效地找到了小青蛙的最小跳跃能力 y，使得它能够完成 2T 次往返跳跃。滑动窗口的核心思想是动态调整窗口的左右边界，确保窗口内的石头高度总和满足条件，同时找到最小的窗口长度 y。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436303632393232" class_="artid" style="display:none">
 </p>
</div>


