---
layout: post
title: "设计模式,持续更新"
date: 2025-03-16 16:46:09 +0800
description: "设计模式，持续更新"
keywords: "设计模式，持续更新"
categories: ['设计模式']
tags: ['设计模式', 'Java']
artid: "146297364"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146297364
    alt: "设计模式,持续更新"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146297364
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146297364
cover: https://bing.ee123.net/img/rand?artid=146297364
image: https://bing.ee123.net/img/rand?artid=146297364
img: https://bing.ee123.net/img/rand?artid=146297364
---

# 设计模式，持续更新

## 创建型

### 简单工厂

    
    
    public interface Product{}
    
    public class ConcreteProduct implements Product {
    }
    public class ConcreteProduct1 implements Product {
    }
    public class ConcreteProduct2 implements Product {
    }
    public class SimpleFactory{
        public Product createProduct(int type) {
            int type = 1;
            if (type == 1) {
                return new ConcreteProduct();
            } else if (type == 2) {
                return new ConcreteProduct1();
            } else if (type == 3) {
                return new ConcreteProduct2();
            }
        }
    }
    
    
    
    使用的场景?
    创建逻辑比较简单，不关心对象的创建逻辑，对象种类较少
    
    本质是什么?
    创建对象的封装，多态
    
    它解决了什么问题?
    解耦，调用方不需要知道有哪些子类以及应当实例化哪个子类，避免 new 直接依赖具体类。
    把对象创建逻辑集中到工厂里，复用创建逻辑，减少重复代码。
    
    它体现了设计模式中什么原则?
    单一职责原则（SRP）：工厂类只负责创建对象，客户端不需要关心具体创建过程
    依赖倒置原则（DIP）：调用方依赖抽象（接口），而不是依赖具体实现
    
    存在的缺陷?
    如果对象种类多，工厂类会有很多 if-else，变得难以维护。
    新增产品时，需要修改工厂类
    
    你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?
    工厂方法模式	每个产品都有自己的工厂	解决简单工厂扩展性差的问题，每个子类工厂独立
    抽象工厂模式	生产多个相关产品族	适用于一组相关对象的创建
    策略模式	通过不同策略处理逻辑	可结合工厂模式，避免 if-else
    
    
    *开源架构中哪些使用了这一模式?
    MyBatis：SqlSessionFactory 生产 SqlSession
    Spring BeanFactory：底层用简单工厂管理 Bean
    

### 工厂方法

    
    
    pubblic interface Product{
        void method();
    }
    public class P1 implements Product {
         @Override
        public void method() {
            System.out.println("p1");
        }
    }
    public class P2 implements Product {
         @Override
        public void method() {
            System.out.println("p2");
        }
    }
    
    public interface Factory {
        Product create();
    }
    public class P1Factory implements Factory {
        @Override
        public Product create() {
            return new P1Factory();
        }
    }
    
    public class P2Factory implements Factory {
        @Override
        public Product create() {
            return new P2Factory();
        }
    }
    
    public class FactoryMethodDemo {
        public static void main(String[] args) {
           
            Product factory = new P1Factory();
            Coffee coffee = factory.create();
            coffee.method();
    
            
            factory = new P2Factory();
            coffee = factory.createCoffee();
            coffee.method();
        }
    }
    
    
    
    
    使用的场景?
    产品种类较多，并且可能扩展（如数据库驱动、日志系统）。
    客户端不想直接依赖具体类，而是通过抽象接口操作对象。
    对象创建逻辑复杂，需要封装在工厂中，避免影响客户端代码。
    需要遵循“开闭原则”，允许扩展新产品而不修改现有工厂代码。
    
    本质是什么?
    本质： 将对象的创建延迟到子类，避免直接在客户端代码中使用 new 关键字。
    简单来说，它是 简单工厂模式的升级版，让每种产品都有独立的工厂，避免了 if-else 代码膨胀的问题。
    
    它解决了什么问题?
    避免代码重复：每次创建新对象时，不需要重复写实例化代码，工厂类可以复用。
    降低耦合：客户端代码依赖于抽象工厂接口，而不依赖具体实现，增强了灵活性。
    符合开闭原则：新增产品时只需新增具体工厂类，而不需要修改现有工厂代码。
    
    它体现了设计模式中什么原则?
    开闭原则（OCP，Open-Closed Principle）
    扩展新产品时，只需新增工厂，而不影响已有代码。
    单一职责原则（SRP，Single Responsibility Principle）
    工厂类的唯一职责是创建对象，而非控制对象的业务逻辑。
    依赖倒置原则（DIP，Dependency Inversion Principle）
    代码依赖于抽象（接口），而不是具体类，增强可扩展性。
    
    存在的缺陷?
    增加代码复杂度：每个产品都需要一个工厂类，导致代码量变多。
    新增工厂类较多：如果产品种类过多，会导致工厂类数量膨胀，管理较为复杂。
    类爆炸问题：当产品数量大时，可能会有大量工厂类，使代码结构复杂。
    
    你认为与它相关的设计模式有哪些? 它们之间的区别有哪些?
    简单工厂模式	一个工厂类创建所有对象	适用于产品种类较少、对象创建逻辑简单	不符合开闭原则，新增产品需要修改工厂
    工厂方法模式	每种产品都有独立的工厂	适用于产品较多、未来可能扩展的情况	符合开闭原则，但类数量较多
    抽象工厂模式	提供一组相关产品的工厂	适用于多个产品族的情况（如 Windows/Mac UI 组件）	创建的是一组相关产品，而非单一产品
    建造者模式	复杂对象的逐步构建	对象创建步骤较多，属性较复杂	用于一步步构造复杂对象，而不是简单实例化
    
    *开源架构中哪些使用了这一模式?
    Spring Framework（Spring IOC 容器）
    
    BeanFactory 使用工厂方法模式创建和管理 Bean。
    ApplicationContext.getBean() 方法背后使用了工厂模式。
    JDBC（Java Database Connectivity）
    
    DriverManager.getConnection(url, user, password) 背后就是工厂模式。
    JDBC 连接工厂负责创建数据库连接，而不是客户端直接实例化 Connection。
    Log4j / SLF4J
    
    LoggerFactory.getLogger(Class clazz) 通过工厂方法创建 Logger 实例，而不是 new Logger()。
    Apache Commons DBCP（数据库连接池）
    
    BasicDataSource 通过工厂模式管理数据库连接池，确保连接复用，提升性能。
    JDK 并发库
    
    Executors.newFixedThreadPool() 返回 ThreadPoolExecutor，封装线程池创建逻辑，避免直接 new Thread()。
    
    
    



