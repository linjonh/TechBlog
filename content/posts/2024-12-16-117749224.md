---
layout: post
title: "Java实习生常规技术面试题每日十题Java基础五"
date: 2024-12-16 08:37:38 +0800
description: "启动一个线程是用run()还是start()? 线程的基本状态以及状态之间的关系。Set和List的"
keywords: "19.java 集合类框架的最佳实践有哪些?"
categories: ['面试']
tags: ['面试', '编程语言', '多线程', 'Jdk', 'Java']
artid: "117749224"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=117749224
    alt: "Java实习生常规技术面试题每日十题Java基础五"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=117749224
featuredImagePreview: https://bing.ee123.net/img/rand?artid=117749224
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java实习生常规技术面试题每日十题Java基础（五）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      目录
     </strong>
    </p>
    <p id="1.%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%94%A8run()%E8%BF%98%E6%98%AFstart()%3F%20.%C2%A0-toc" style="margin-left:80px;">
     <a href="#1.%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%94%A8run%28%29%E8%BF%98%E6%98%AFstart%28%29%3F%20.%C2%A0" rel="nofollow">
      1.启动一个线程是用run()还是start()? .
     </a>
    </p>
    <p id="2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82-toc" style="margin-left:80px;">
     <a href="#2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82" rel="nofollow">
      2.线程的基本状态以及状态之间的关系。
     </a>
    </p>
    <p id="3.Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CList%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;">
     <a href="#3.Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CList%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">
      3.Set和List的区别，List和Map的区别？
     </a>
    </p>
    <p id="4.%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;">
     <a href="#4.%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">
      4.同步方法、同步代码块区别？
     </a>
    </p>
    <p id="5.%E6%8F%8F%E8%BF%B0Java%20%E9%94%81%E6%9C%BA%E5%88%B6%E3%80%82-toc" style="margin-left:80px;">
     <a href="#5.%E6%8F%8F%E8%BF%B0Java%20%E9%94%81%E6%9C%BA%E5%88%B6%E3%80%82" rel="nofollow">
      5.描述Java 锁机制。
     </a>
    </p>
    <p id="6.Comparable%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E5%88%97%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;">
     <a href="#6.Comparable%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E5%88%97%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">
      6.Comparable和Comparator接口是干什么的？列出它们的区别
     </a>
    </p>
    <p id="7.Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:80px;">
     <a href="#7.Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">
      7.Java集合类框架的最佳实践有哪些？
     </a>
    </p>
    <p id="8.HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82-toc" style="margin-left:80px;">
     <a href="#8.HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82" rel="nofollow">
      8.HashMap和Hashtable的区别。
     </a>
    </p>
    <p id="9.HashSet%E5%92%8CTreeSet%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;">
     <a href="#9.HashSet%E5%92%8CTreeSet%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">
      9.HashSet和TreeSet有什么区别？
     </a>
    </p>
    <p id="10.%E8%AF%B4%E5%87%BAArrayList%2CVector%2C%20LinkedList%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7%E3%80%82-toc" style="margin-left:80px;">
     <a href="#10.%E8%AF%B4%E5%87%BAArrayList%2CVector%2C%20LinkedList%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7%E3%80%82" rel="nofollow">
      10.说出ArrayList,Vector, LinkedList的存储性能和特性。
     </a>
    </p>
    <hr id="hr-toc"/>
    <h4>
     1.启动一个线程是用run()还是start()? .
    </h4>
    <blockquote>
     <p>
      启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。
     </p>
    </blockquote>
    <h4 id="2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82">
     2.线程的基本状态以及状态之间的关系。
    </h4>
    <blockquote>
     <p>
      <strong>
       1、新建状态（New）
      </strong>
      ：新创建了一个线程对象。
     </p>
     <p>
      <strong>
       2、就绪状态（Runnable）
      </strong>
      ：也叫可运行状态。线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
     </p>
     <p>
      <strong>
       3、运行状态（Running）
      </strong>
      ：就绪状态的线程获取了CPU，执行程序代码。
     </p>
     <p>
      <strong>
       4、阻塞状态（Blocked）
      </strong>
      ：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
     </p>
     <p>
      <strong>
       ①等待阻塞：
      </strong>
      运行的线程执行wait()方法，JVM会把该线程放入等待池中。
     </p>
     <p>
      <strong>
       ②同步阻塞：
      </strong>
      运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
     </p>
     <p>
      <strong>
       ③其他阻塞：
      </strong>
      运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
     </p>
     <p>
      <strong>
       5、死亡状态（Dead）
      </strong>
      ：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
     </p>
     <p style="margin-left:.0001pt;">
     </p>
     <p style="margin-left:.0001pt;">
      <img alt="" height="371" src="https://i-blog.csdnimg.cn/blog_migrate/25ff9bff441b66f3860b08212fd0c42d.png" width="510"/>
     </p>
    </blockquote>
    <h4 id="3.Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CList%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">
     3.Set和List的区别，List和Map的区别？
    </h4>
    <blockquote>
     <p>
      1、Set是无序的，元素不可重复；List是有序的，元素可以重复；
     </p>
     <p>
      2、List存储的是单个对象的集合（有序的），Map存储的是键值对为对象的集合（无序的）；
     </p>
    </blockquote>
    <h4 id="4.%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%8C%BA%E5%88%AB%EF%BC%9F">
     4.同步方法、同步代码块区别？
    </h4>
    <p>
     <strong>
      1.同步方法
     </strong>
    </p>
    <blockquote>
     <p>
      即有synchronized关键字修饰的方法。
     </p>
     <p>
      由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，
     </p>
     <p>
      内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
     </p>
    </blockquote>
    <p>
     <strong>
      2.同步代码块
     </strong>
    </p>
    <blockquote>
     <p>
      即有synchronized关键字修饰的语句块。
     </p>
     <p>
      被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
     </p>
    </blockquote>
    <h4 id="5.%E6%8F%8F%E8%BF%B0Java%20%E9%94%81%E6%9C%BA%E5%88%B6%E3%80%82">
     5.描述Java 锁机制。
    </h4>
    <blockquote>
     <p>
      java中所说的锁就是指的内置锁，每个java对象都可以作为一个实现同步的锁，虽然说在java中一切皆对象， 但是锁必须是引用类型的，基本数据类型则不可以 。每一个引用类型的对象都可以隐式的扮演一个用于同步的锁的角色，执行线程进入synchronized块之前会自动获得锁，无论是通过正常语句退出还是执行过程中抛出了异常，线程都会在放弃对synchronized块的控制时自动释放锁。 获得锁的唯一途径就是进入这个内部锁保护的同步块或方法 。
     </p>
    </blockquote>
    <h4 id="6.Comparable%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E5%88%97%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB">
     6.Comparable和Comparator接口是干什么的？列出它们的区别
    </h4>
    <blockquote>
     <p>
      它们都是用于对类的对象进行比较和排序使用的接口。
     </p>
     <p>
      Comparable是排序接口，位于java.lang包下，若一个类实现了Comparable接口，且重写了compareTo方法，就意味着该类支持排序，常结合Collections.sort或Arrays.sort对集合或数组内的元素进行排序。
     </p>
     <p>
      Comparator是比较接口，位于java.util包下，我们如果需要控制某个类对象的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。
     </p>
     <p>
      Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。
     </p>
    </blockquote>
    <h4 id="7.Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">
     7.Java集合类框架的最佳实践有哪些？
    </h4>
    <blockquote>
     <p>
      首先Java中的集合框架体系非常强大和完善，主要用于程序中的数据存储，从最顶层主要分为了Collection和Map接口，我们平时使用的集合类都是从这两个类别中扩展开来，正确选择要使用的集合的类型对性能非常重要。
     </p>
     <p>
      比如：
     </p>
     <p>
      1）元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。
     </p>
     <p>
      2）如果我们大概知道存储的数量，可以在使用集合时先给予一个初始容量大小，从而有效避免集合自动增长的算法而造成的空间浪费，如new ArrayList(30)。
     </p>
     <p>
      3）为了类型安全，提高存取效率和可读性，我们优先使用泛型，并且还能有效避免ClassCastException类型转换异常。
     </p>
     <p>
      4）有时为了提高数据的快速定位查找，可优先使用Map键值对集合，因为Map集合在数据的查找上效率非常高，但是如果要保证数据的顺序，最好使用List
     </p>
     <p>
      5）使用JDK提供的不变类作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。
     </p>
     <p>
      6）底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。
     </p>
    </blockquote>
    <h4 id="8.HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82">
     8.HashMap和Hashtable的区别。
    </h4>
    <blockquote>
     <p>
      1、HashMap和HashTable都是键值对数据结构，且都实现了Map接口，存储的元素无序；
     </p>
     <p>
      2、HashMap非线程安全的，而HashTable是线程安全的（HashTable里面的方法使用Synchronize关键字修饰），所以HashMap的效率高于HashTable。
     </p>
     <p>
      3、HashMap允许空键空值，HashTable则不允许
     </p>
    </blockquote>
    <h4 id="9.HashSet%E5%92%8CTreeSet%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">
     9.HashSet和TreeSet有什么区别？
    </h4>
    <blockquote>
     <p>
      相同点：1、单列存储   2、元素不可重复
     </p>
     <p>
      不同点：1、底层数据结构不同（HashSet===哈希表结构   TreeSet===二叉树结构）
     </p>
     <p>
      2、数据唯一性依据不同（HashSet通过重写hashcode和equals     TreeSet通过compareable接口）
     </p>
     <p>
      3、有序性不同，HashSet无序，TreeSet有序
     </p>
    </blockquote>
    <h4 id="10.%E8%AF%B4%E5%87%BAArrayList%2CVector%2C%20LinkedList%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7%E3%80%82">
     10.说出ArrayList,Vector, LinkedList的存储性能和特性。
    </h4>
    <blockquote>
     <p>
      1、ArrayList和LinkedList、Vector都实现了List接口；
     </p>
     <p>
      2、ArrayList和Vector底层是用数组实现的，而LinkedList使用双向链表实现的，在集合插入、删除元素时，ArrayList需要移动数组元素性能较差；但是在查询时，因为是连续的数组，所以查询速度快；LinkedList正好相反。
     </p>
     <p>
      3、在容量增长上，ArrayList增长原来50%，Vector集合增加容量原来的一倍。
     </p>
     <p>
      4、安全性方面Vector能够保证线程安全，但是效率比ArrayList要低。
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     其他面试题：
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117818994">
      Java实习生常规技术面试题每日十题Java基础（八）
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117818447">
      Java实习生常规技术面试题每日十题Java基础（七）
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117769949">
      Java实习生常规技术面试题每日十题Java基础（六）
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117749224">
      <span style="color:#f33b45;">
       Java实习生常规技术面试题每日十题Java基础（五）
      </span>
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117715273">
      Java实习生常规技术面试题每日十题Java基础（四）
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117653658">
      Java实习生常规技术面试题每日十题Java基础（三）
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117607763">
      Java实习生常规技术面试题每日十题Java基础（二）
     </a>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_44893902/article/details/117592354">
      Java实习生常规技术面试题每日十题Java基础（一）
     </a>
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343839333930322f:61727469636c652f64657461696c732f313137373439323234" class_="artid" style="display:none">
 </p>
</div>


