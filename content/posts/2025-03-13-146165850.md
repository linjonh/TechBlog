---
layout: post
title: "二叉树中堆的实现"
date: 2025-03-13 23:23:44 +0800
description: "int size;}HP;与顺序表相似，我们需要一个数组，有效空间大小，有效元素个数。"
keywords: "二叉树中堆的实现"
categories: ['未分类']
tags: ['算法', '数据结构']
artid: "146165850"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146165850
    alt: "二叉树中堆的实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146165850
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146165850
cover: https://bing.ee123.net/img/rand?artid=146165850
image: https://bing.ee123.net/img/rand?artid=146165850
img: https://bing.ee123.net/img/rand?artid=146165850
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     二叉树中堆的实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     1 堆的声明和定义
    </h3>
    <pre><code class="language-cpp">typedef int HPDateType;
typedef struct Heap {
	HPDateType* arr;
	int size;
	int capcity;
}HP;</code></pre>
    <p>
     与顺序表相似，我们需要一个数组，有效空间大小，有效元素个数
    </p>
    <h3>
     2 堆的初始化
    </h3>
    <pre><code class="language-cpp">void HPInit(HP*php)
{
	assert(php);
	php-&gt;arr = NULL;
	php-&gt;size = php-&gt;capcity = 0;
}</code></pre>
    <p>
     把数组置空，有效元素个数和有效空间大小置为0
    </p>
    <h3>
     3 堆的销毁
    </h3>
    <pre><code class="language-cpp">void HPDestroy(HP* php)
{
	assert(php);
	if (php-&gt;arr)
		free(php-&gt;arr);
	php-&gt;arr = NULL;
	php-&gt;capcity = php-&gt;size = 0;
}</code></pre>
    <p>
     传递的参数当然不能为空，用assert断言，接着把arr的空间释放掉，让size,capcity为0
    </p>
    <h3>
     4 入堆
    </h3>
    <p>
     <strong>
      这里我们需要先讲解思路
     </strong>
    </p>
    <p>
     首先，堆是用数组储存起来的，如果直接插到数组最后一位是不合理的
    </p>
    <p>
     <img alt="" height="451" src="https://i-blog.csdnimg.cn/direct/f4d4800ddbc64f77942f2d754d5c1b89.jpeg" width="505"/>
    </p>
    <p>
    </p>
    <p>
     如图所示，可能空间是满的，这里就需要们
     <strong>
      重新开辟空间
     </strong>
    </p>
    <p>
     同时，为了保证堆为一个
     <strong>
      有效堆（保证为大堆或者小堆）
     </strong>
     ，我们需要重新调整堆的排序
    </p>
    <p>
     <span style="color:#6eaad7">
      <strong>
       空间开辟
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">if (php-&gt;size == php-&gt;capcity)
{
	int newcapcity = php-&gt;capcity == 0 ? 4 : 2 * php-&gt;capcity;
	HPDateType* tmp = (HPDateType*)realloc(php-&gt;arr, newcapcity * sizeof(HPDateType));
	if (tmp == NULL)
	{
		perror("realloc fail");
		exit(1);
	}
	php-&gt;capcity = newcapcity;
	php-&gt;arr = tmp;
}</code></pre>
    <p>
     利用realloc开辟，最后给capcity和arr赋值
    </p>
    <p>
     <span style="color:#6eaad7">
      <strong>
       堆调整--向上调整--小堆
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">void AdjustUp(HPDateType* arr, int child)//向上调整
{
	while (child &gt; 0)
	{
		int parent = (child - 1) / 2;
		// &lt;: 小堆
		// &gt;: 大堆
		if (arr[child] &lt; arr[parent])
		{
			swap(&amp;arr[child], &amp;arr[parent]);//swap函数的形参是两个指针，需要传地址
			child = parent;
			parent = (child - 1) / 2;
		}
		else {
			break;
		}
	}
}</code></pre>
    <p style="text-align:center">
     <img alt="" height="424" src="https://i-blog.csdnimg.cn/direct/f6892b3a27204e1f9376051a12a85cb1.png" width="495"/>
    </p>
    <blockquote>
     <p>
      <strong>
       <span style="color:#6eaad7">
        调整原理
       </span>
       ：将该入堆元素（child）插到末尾，顺着其父母结点(parent)往上调整，在堆为小堆的条件下，如果该元素比他的父母结点小就交换二者，再让其父母结点成为新的孩子结点，循环往复，直到新的孩子结点跳出，或者直白点说就是下标&lt;0就跳出循环
      </strong>
     </p>
     <p>
     </p>
     <p>
      <strong>
       <em>
        注意，因为当child走到根结点时也需要比较之后判断是否要交换，所以不能只是parent走到空，必须要child走到空
       </em>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
     <span style="color:#6eaad7">
      <strong>
       完整入堆操作的实现
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">void HPPush(HP* php, HPDateType x)
{
	assert(php);
	//判断空间是否足够	
	if (php-&gt;size == php-&gt;capcity)
	{
		int newcapcity = php-&gt;capcity == 0 ? 4 : 2 * php-&gt;capcity;
		HPDateType* tmp = (HPDateType*)realloc(php-&gt;arr, newcapcity * sizeof(HPDateType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			exit(1);
		}
		php-&gt;capcity = newcapcity;
		php-&gt;arr = tmp;
	}
	php-&gt;arr[php-&gt;size] = x;
	AdjustUp(php-&gt;arr, php-&gt;size);//向上调整
	++php-&gt;size;
}</code></pre>
    <p>
     如果是大堆的调整就把向上调整的" &lt; "改为" &gt; "
    </p>
    <p>
     最后还需要让最大元素个数+1
    </p>
    <h3>
     5 出堆
    </h3>
    <blockquote>
     <p>
      <strong>
       <span style="color:#6eaad7">
        思路讲解
       </span>
       ：
      </strong>
      这里出堆出的通常是
      <strong>
       堆顶元素
      </strong>
      ，如果要出堆尾元素只需要让size--即可，意义不大，如果是出堆顶元素，那么这里我们一定不能用顺序表的向前覆盖来写，这样会让整个堆的结构混乱，我们不妨另辟蹊径，继续沿用交换操作，让根结点和最后一个结点交换，再出堆尾让size--，这时候我们关注交换到堆顶的元素，利用向下调整算法，让其成为
      <strong>
       有效堆
      </strong>
     </p>
    </blockquote>
    <p style="text-align:center">
     <strong>
      <img alt="" height="337" src="https://i-blog.csdnimg.cn/direct/21f10424dbfb45e6ab180d45b8419706.png" width="428"/>
     </strong>
    </p>
    <p>
     <strong>
      堆调整--向下调整--大堆
     </strong>
    </p>
    <pre><code class="language-cpp">void AdjustDown(HPDateType*arr,int parent,int n)
{
	int child = parent * 2 + 1;
	while (child&lt;n)
	{
		// 大堆:&lt;
		// 小堆:&gt;
		if (child+1&lt;n&amp;&amp;arr[child] &lt; arr[child + 1])
		{
			child++;
		}
		if (arr[child] &gt; arr[parent])
		{
			swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child=parent * 2 + 1;
		}
		else {
			break;
		}
		
	}

}</code></pre>
    <blockquote>
     <p>
      <strong>
       <span style="color:#6eaad7">
        调整原理
       </span>
       ：
      </strong>
      从堆顶开始，此时的堆顶设为初始parent，我们取child结点中较大的一个作为比较对象，如过child&gt;parent就交换，
      <strong>
       再让child成为新的parent
      </strong>
      ，直到调整完成跳出循环，或者child走到最后一个结点
     </p>
     <p>
      这里我们还需要注意child+1在调整的时候是否
      <strong>
       越界
      </strong>
      ，以防出现
      <strong>
       非法访问
      </strong>
     </p>
    </blockquote>
    <p>
     <strong>
      完整出堆操作的实现
     </strong>
    </p>
    <pre><code class="language-cpp">void HPPop(HP* php) 
{
	assert(!HPEmpty(php));
	swap(&amp;php-&gt;arr[0], &amp;php-&gt;arr[php-&gt;size - 1]);
	--php-&gt;size;
	AdjustDown(php-&gt;arr, 0, php-&gt;size);
}
</code></pre>
    <p>
     其中判空函数
    </p>
    <pre><code class="language-cpp">bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size == 0;
}

</code></pre>
    <h3>
     6 借助数据结构堆来实现的堆排序
    </h3>
    <p>
     先来写
     <strong>
      取堆顶元素
     </strong>
     的实现
    </p>
    <pre><code class="language-cpp">HPDateType HPTop(HP* php)
{
	assert(!HPEmpty(php));
	return php-&gt;arr[0];
}</code></pre>
    <pre><code class="language-cpp">void HeapSort01(int* arr, int n)
{
	HP hp;
	HPInit(&amp;hp);
	for (int i = 0; i &lt; n; i++)
	{
		HPPush(&amp;hp,arr[i]);
	}
	int i = 0;
	while (!HPEmpty(&amp;hp))
	{
		int top = HPTop(&amp;hp);
		arr[i++] = top;
		HPPop(&amp;hp);//删除之后会重新排列
	}
	HPDestroy(&amp;hp);
}</code></pre>
    <p>
     这种堆排序借助了入堆和出堆时的堆调整，因为
     <strong>
      每次出堆我们都获取了堆中最小或者最大的元素
     </strong>
     ，所以最终得到了一个有序序列
    </p>
    <h3>
     7 常规堆排序
    </h3>
    <p>
     <strong>
      <span style="color:#6eaad7">
       思路讲解：
      </span>
     </strong>
     <span style="color:null">
      首先利用向下堆调整让待排序的数组建堆，接着将堆顶元素和最后一个元素交换，接着再进行堆调整直到end&lt;0，
      <strong>
       实质上还是堆顶元素一定为最大（小）的出堆操作的运用
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      有如下示例帮助理解
     </span>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/231db72beb6749348d938cad0d77ed81.jpeg"/>
    </p>
    <p>
     这里我们实现了把最大元素一个个放到末尾 ，最终实现堆排序
    </p>
    <pre><code class="language-cpp">void HeapSort(int* arr,int n)
{
	//向下调整建堆
	for (int i = (n - 2) / 2; i&gt;=0;i--)
	{
		AdjustDown(arr, i, n);//i是最后一个节点的parent节点
	}
	int end = n - 1;
	while (end&gt;0)
	{
		swap(&amp;arr[0], &amp;arr[end]);
		AdjustDown(arr, 0, end);
		end--;
	}
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     完
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38383034333131332f:61727469636c652f64657461696c732f313436313635383530" class_="artid" style="display:none">
 </p>
</div>


