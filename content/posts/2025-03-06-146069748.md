---
layout: post
title: "SpringMvc的设计模式"
date: 2025-03-06 14:21:10 +0800
description: "不同处理器（如 Controller 接口、HttpRequestHandler）通过对应的适配器（如 RequestMappingHandlerAdapter）转换为统一的处理接口，使框架能够灵活支持多种处理器类型。用于统一不同处理器的调用方式，例如将基于注解的 @Controller 类、传统 Servlet 或其他框架（如 Struts）的处理器适配到 Spring MVC 的流程中。通过工厂模式管理控制器、服务层等 Bean 的生命周期，依赖注入（DI）进一步解耦组件间依赖。"
keywords: "SpringMvc的设计模式"
categories: ['未分类']
tags: ['设计模式']
artid: "146069748"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146069748
    alt: "SpringMvc的设计模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146069748
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146069748
cover: https://bing.ee123.net/img/rand?artid=146069748
image: https://bing.ee123.net/img/rand?artid=146069748
img: https://bing.ee123.net/img/rand?artid=146069748
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringMvc的设计模式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="1_Front_Controller_Pattern_0">
     </a>
     1. 前端控制器模式（Front Controller Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     Spring MVC 的 DispatcherServlet 是该模式的核心实现，作为统一请求入口，负责接收所有 HTTP 请求并协调后续处理流程。它通过集中控制请求分发、视图解析和异常处理，简化了 Web 层的复杂性。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     流程控制：DispatcherServlet 根据请求 URL 调用 HandlerMapping 定位处理器，再通过 HandlerAdapter 执行具体业务逻辑，最后通过 ViewResolver 渲染视图。
    </p>
    <h3>
     <a id="2_Adapter_Pattern_7">
     </a>
     2. 适配器模式（Adapter Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     用于统一不同处理器的调用方式，例如将基于注解的 @Controller 类、传统 Servlet 或其他框架（如 Struts）的处理器适配到 Spring MVC 的流程中。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     HandlerAdapter：
     <br/>
     不同处理器（如 Controller 接口、HttpRequestHandler）通过对应的适配器（如 RequestMappingHandlerAdapter）转换为统一的处理接口，使框架能够灵活支持多种处理器类型。
    </p>
    <h3>
     <a id="3_Template_Method_Pattern_15">
     </a>
     3. 模板方法模式（Template Method Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     定义处理流程的骨架，允许子类在不改变整体结构的情况下重写特定步骤。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     FrameworkServlet：
     <br/>
     DispatcherServlet 继承自 FrameworkServlet，其 processRequest() 方法定义了请求处理的整体流程（如初始化上下文、调用 doService()），而子类只需实现 doService() 完成具体逻辑。
    </p>
    <h3>
     <a id="4_Strategy_Pattern_23">
     </a>
     4. 策略模式（Strategy Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     动态选择算法或策略以满足不同需求，例如视图解析、处理器映射等。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     HandlerMapping：
     <br/>
     支持多种策略（如基于注解的 RequestMappingHandlerMapping、基于 XML 配置的 BeanNameUrlHandlerMapping），根据配置动态选择最佳实现。
     <br/>
     ViewResolver：
     <br/>
     支持多种视图技术（如 JSP、Thymeleaf、JSON），通过不同解析策略生成最终响应。
    </p>
    <h3>
     <a id="5_Composite_Pattern_33">
     </a>
     5. 组合模式（Composite Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     将多个对象组合成树形结构以表示“整体-部分”关系，常用于拦截器链的处理。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     HandlerExecutionChain：
     <br/>
     包含一个处理器（Handler）和多个拦截器（Interceptor），通过链式调用实现请求的前置处理、后置处理和最终响应。
    </p>
    <h3>
     <a id="6_Observer_Pattern_41">
     </a>
     6. 观察者模式（Observer Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     处理事件驱动的逻辑，如请求生命周期中的事件通知。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     ApplicationContext 事件机制：
     <br/>
     Spring MVC 通过 ApplicationEvent 和 ApplicationListener 实现事件发布与监听，例如请求处理完成时发布事件以触发日志记录或资源清理。
    </p>
    <h3>
     <a id="7_Factory_Pattern_49">
     </a>
     7. 工厂模式（Factory Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     对象的创建与管理解耦，例如 Bean 的实例化。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     BeanFactory 与 ApplicationContext：
     <br/>
     通过工厂模式管理控制器、服务层等 Bean 的生命周期，依赖注入（DI）进一步解耦组件间依赖。
    </p>
    <h3>
     <a id="8_Singleton_Pattern_57">
     </a>
     8. 单例模式（Singleton Pattern）
    </h3>
    <p>
     应用场景：
     <br/>
     确保核心组件（如 DispatcherServlet、HandlerMapping）全局唯一，减少资源消耗。
    </p>
    <p>
     具体体现：
    </p>
    <p>
     Bean 的单例作用域：
     <br/>
     Spring 默认以单例模式管理 Bean，例如控制器、适配器等核心组件仅实例化一次。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353533303139322f:61727469636c652f64657461696c732f313436303639373438" class_="artid" style="display:none">
 </p>
</div>


