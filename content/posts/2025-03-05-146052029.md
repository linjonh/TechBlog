---
layout: post
title: "常用的分布式-ID-设计方案"
date: 2025-03-05 20:34:44 +0800
description: "它将 64 位划分为不同部分，包含 1 位符号位（固定为 0）、41 位时间戳（毫秒级）、10 位工作机器 ID（可支持 1024 个节点）和 12 位序列号（同一毫秒内生成不同 ID）。二是 “segment（号段）” 模式，服务端一次性分配一个号段给客户端，客户端在号段内自行生成 ID，用完后再向服务端申请新号段。：利用关系型数据库（如 MySQL）的自增字段特性，每插入一条数据，ID 自动递增。：利用 Redis 的INCR或INCRBY命令，以原子操作的方式递增一个键的值，以此作为 ID。"
keywords: "常用的分布式 ID 设计方案"
categories: ['未分类']
tags: ['分布式']
artid: "146052029"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146052029
    alt: "常用的分布式-ID-设计方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146052029
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146052029
cover: https://bing.ee123.net/img/rand?artid=146052029
image: https://bing.ee123.net/img/rand?artid=146052029
img: https://bing.ee123.net/img/rand?artid=146052029
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     常用的分布式 ID 设计方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="1UUID_3">
     </a>
     1.UUID
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：UUID 是由数字和字母组成的 128 位标识符，通过特定算法随机生成，包括时间戳、计算机网卡地址等信息。常见的版本有版本 1（基于时间戳和 MAC 地址）、版本 4（纯随机数）等。
    </p>
    <p>
     优点：
    </p>
    <ul>
     <li>
      生成简单，本地生成，不需要依赖额外的组件或服务，能有效减少网络开销。
     </li>
     <li>
      全球唯一，基本能保证在任何场景下不会重复。
     </li>
    </ul>
    <p>
     缺点：
    </p>
    <ul>
     <li>
      长度较长，通常为 36 个字符（如550e8400-e29b-41d4-a716-446655440000），占用存储空间大，在数据库存储和传输时会增加开销。
     </li>
     <li>
      无序性，导致在数据库索引中效率较低，不利于排序和分页操作。
     </li>
    </ul>
    <h2>
     <a id="2_ID_13">
     </a>
     2.数据库自增 ID
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：利用关系型数据库（如 MySQL）的自增字段特性，每插入一条数据，ID 自动递增。可以单库单表生成，也可以分库分表生成（如设置不同的初始值和步长） 。
    </p>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      简单直观，符合人们对 ID 的认知习惯，容易理解和使用。
     </li>
     <li>
      有序性，方便进行排序、分页和统计等操作。
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      性能瓶颈，在高并发场景下，数据库的写操作会成为性能瓶颈，因为自增 ID 的生成依赖数据库的锁机制。
     </li>
     <li>
      扩展性差，分库分表时，ID 的生成和管理会变得复杂，需要额外的逻辑来保证唯一性。
     </li>
    </ul>
    <h2>
     <a id="3_24">
     </a>
     3.雪花算法
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：由 Twitter 开源，是一种生成 64 位整数 ID 的算法。它将 64 位划分为不同部分，包含 1 位符号位（固定为 0）、41 位时间戳（毫秒级）、10 位工作机器 ID（可支持 1024 个节点）和 12 位序列号（同一毫秒内生成不同 ID）。
    </p>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      高性能，在内存中生成，不依赖数据库等外部组件，生成速度快，能满足高并发场景。
     </li>
     <li>
      有序性，根据时间戳生成，基本保证 ID 是有序的，有利于数据库索引和排序。
     </li>
     <li>
      可扩展性，通过调整工作机器 ID 位数，可以适应不同规模的分布式系统。
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      强依赖时钟，若服务器时钟回拨，可能会生成重复 ID，需要额外的处理逻辑。
     </li>
     <li>
      实现相对复杂，需要对算法原理有一定了解才能正确实现和维护。
     </li>
    </ul>
    <h2>
     <a id="4Redis__ID_36">
     </a>
     4.Redis 生成 ID
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：利用 Redis 的INCR或INCRBY命令，以原子操作的方式递增一个键的值，以此作为 ID。也可以结合时间戳等信息生成更有意义的 ID。
    </p>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      性能高，Redis 基于内存操作，处理速度快，能应对高并发的 ID 生成需求。
     </li>
     <li>
      可扩展性好，Redis 本身支持集群部署，可以方便地扩展以满足更大规模的系统需求。
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      依赖外部组件，若 Redis 出现故障，会影响 ID 的生成。
     </li>
     <li>
      没有内置的时间顺序性，如果需要有序 ID，需要额外处理。
     </li>
    </ul>
    <h2>
     <a id="5_Leaf_47">
     </a>
     5.美团 Leaf
    </h2>
    <p>
     <strong>
      原理
     </strong>
     ：美团开源的分布式 ID 生成系统，支持两种模式。一是 “雪花算法” 模式，适用于强依赖 ID 有序性的场景；二是 “segment（号段）” 模式，服务端一次性分配一个号段给客户端，客户端在号段内自行生成 ID，用完后再向服务端申请新号段。
    </p>
    <p>
     <strong>
      优点
     </strong>
     ：
    </p>
    <ul>
     <li>
      灵活性高，可根据不同业务场景选择不同模式，满足多样化的需求。
     </li>
     <li>
      高性能，“segment” 模式下，客户端在本地生成 ID，减少了与服务端的交互，提高了性能。
     </li>
    </ul>
    <p>
     <strong>
      缺点
     </strong>
     ：
    </p>
    <ul>
     <li>
      实现相对复杂，需要搭建和维护 Leaf 服务。
     </li>
     <li>
      在 “segment” 模式下，如果号段设置不合理，可能会导致号段浪费或不足的情况。
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f686867685f2f:61727469636c652f64657461696c732f313436303532303239" class_="artid" style="display:none">
 </p>
</div>


