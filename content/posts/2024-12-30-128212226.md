---
layout: post
title: "Java函数式接口之Comparable"
date: 2024-12-30 09:04:23 +0800
description: "Java函数式接口之Comparable_java comparable"
keywords: "java comparable"
categories: ['Java']
tags: ['Java']
artid: "128212226"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=128212226
    alt: "Java函数式接口之Comparable"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=128212226
featuredImagePreview: https://bing.ee123.net/img/rand?artid=128212226
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java函数式接口之Comparable
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="JavaComparable_0">
     </a>
     Java函数式接口之Comparable
    </h3>
    <p>
     <strong>
      -able接口 在Java中一般表示能力，例如Comparable 比较能力，Iterable迭代能力等等
     </strong>
    </p>
    <h4>
     <a id="1_Comparable_4">
     </a>
     1. Comparable接口
    </h4>
    <p>
     <strong>
      Comparable接口，如其名，实现它后，实现类具有比较比较能力。在Java中是一个FunctionalInterface接口，里面包含一个compareTo方法
     </strong>
    </p>
    <p>
     这里引入源代码来分析, 具体如下：
    </p>
    <ol>
     <li>
      实现该接口的每个类对象会被强加一个总排序，被称之为自然排序，compareTo方法被称之为自然排序法
     </li>
     <li>
      List、Array等对象实现了该接口，可以自动排序。
     </li>
     <li>
      compareTo禁止接收null值 会抛出空指针异常，null不是任何类的实例
     </li>
     <li>
      强烈推荐自然排序和equal结果是一致的，例如 compareTo一致相当于equal方法返回true，
      <strong>
       但未要求
      </strong>
     </li>
     <li>
      compareTo 使用特定对象来比较顺序 返回 一个负数 或者 0 或者正数 来表示 小于 等于 大于
     </li>
     <li>
      compareTo必须满足交换性、传递性等特性
     </li>
     <li>
      <strong>
       排序输出默认是升序
      </strong>
     </li>
    </ol>
    <pre><code class="prism language-java">
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token comment">/**
     * 使用特定对象来比较顺序 返回 一个负数 或者 0 或者正数 来表示 小于 等于 大于
     * Compares this object with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     * 必须确保交换性 x.compareTo(y)的结果和y.compareTo(x)结果一致
     * &lt;p&gt;The implementor must ensure &lt;tt&gt;sgn(x.compareTo(y)) ==
     * -sgn(y.compareTo(x))&lt;/tt&gt; for all &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;.  (This
     * implies that &lt;tt&gt;x.compareTo(y)&lt;/tt&gt; must throw an exception iff
     * &lt;tt&gt;y.compareTo(x)&lt;/tt&gt; throws an exception.)
     * 传递性
     * &lt;p&gt;The implementor must also ensure that the relation is transitive:
     * &lt;tt&gt;(x.compareTo(y)&amp;gt;0 &amp;amp;&amp;amp; y.compareTo(z)&amp;gt;0)&lt;/tt&gt; implies
     * &lt;tt&gt;x.compareTo(z)&amp;gt;0&lt;/tt&gt;.
     * 
     * &lt;p&gt;Finally, the implementor must ensure that &lt;tt&gt;x.compareTo(y)==0&lt;/tt&gt;
     * implies that &lt;tt&gt;sgn(x.compareTo(z)) == sgn(y.compareTo(z))&lt;/tt&gt;, for
     * all &lt;tt&gt;z&lt;/tt&gt;.
     * 强烈推荐 x.compareTo比较相同的话 equals值也相等
     * &lt;p&gt;It is strongly recommended, but &lt;i&gt;not&lt;/i&gt; strictly required that
     * &lt;tt&gt;(x.compareTo(y)==0) == (x.equals(y))&lt;/tt&gt;.  Generally speaking, any
     * class that implements the &lt;tt&gt;Comparable&lt;/tt&gt; interface and violates
     * this condition should clearly indicate this fact.  The recommended
     * language is "Note: this class has a natural ordering that is
     * inconsistent with equals."
     * 一般来说 返回值 通常定义三种 -1、0或者 1 这类似一种约定 当然你负数 正数其他值也可以
     * &lt;p&gt;In the foregoing description, the notation
     * &lt;tt&gt;sgn(&lt;/tt&gt;&lt;i&gt;expression&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; designates the mathematical
     * &lt;i&gt;signum&lt;/i&gt; function, which is defined to return one of &lt;tt&gt;-1&lt;/tt&gt;,
     * &lt;tt&gt;0&lt;/tt&gt;, or &lt;tt&gt;1&lt;/tt&gt; according to whether the value of
     * &lt;i&gt;expression&lt;/i&gt; is negative, zero or positive.
     *
     * @param   o the object to be compared.
     * @return  a negative integer, zero, or a positive integer as this object
     *          is less than, equal to, or greater than the specified object.
     *
     * @throws NullPointerException if the specified object is null
     * @throws ClassCastException if the specified object's type prevents it
     *         from being compared to this object.
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="1_Comparable_66">
     </a>
     1. 已实现Comparable接口
    </h5>
    <ol>
     <li>
      List集合，一般排序借助于Collections工具类
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">//第一种排序方法</span>
       	list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">//第二种排序方法 底层使用第一种方法</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <ol start="2">
     <li>
      Array排序 一般排序借助于Arrays工具类
     </li>
    </ol>
    <pre><code class="prism language-java">  <span class="token comment">//在原有基础上排序</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arraySort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    	<span class="token comment">//第一种排序</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">//第二种排序</span>
    	<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArr <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="2_Comparator_98">
     </a>
     2. Comparator类
    </h4>
    <p>
     Comparator,一个比较的功能类，也是一个FunctionalInterface.提供了compare方法，接受两个参数，并返回比较值，比较值的规则和Comparable一致，
    </p>
    <p>
     也可以实现Comparable相同的比较效果
    </p>
    <pre><code class="prism language-java"><span class="token comment">//其他方法省略</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**比较两个参数顺序 返回 负数 0 或 正数 分别表示 小于 等于 大于
     * Compares its two arguments for order.  Returns a negative integer,
     * zero, or a positive integer as the first argument is less than, equal
     * to, or greater than the second.&lt;p&gt;
     * 一般用 -1 0 1表示返回结果
     * In the foregoing description, the notation
     * &lt;tt&gt;sgn(&lt;/tt&gt;&lt;i&gt;expression&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; designates the mathematical
     * &lt;i&gt;signum&lt;/i&gt; function, which is defined to return one of &lt;tt&gt;-1&lt;/tt&gt;,
     * &lt;tt&gt;0&lt;/tt&gt;, or &lt;tt&gt;1&lt;/tt&gt; according to whether the value of
     * &lt;i&gt;expression&lt;/i&gt; is negative, zero or positive.&lt;p&gt;
     *
     * The implementor must ensure that &lt;tt&gt;sgn(compare(x, y)) ==
     * -sgn(compare(y, x))&lt;/tt&gt; for all &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;y&lt;/tt&gt;.  (This
     * implies that &lt;tt&gt;compare(x, y)&lt;/tt&gt; must throw an exception if and only
     * if &lt;tt&gt;compare(y, x)&lt;/tt&gt; throws an exception.)&lt;p&gt;
     *
     * The implementor must also ensure that the relation is transitive:
     * &lt;tt&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0))&lt;/tt&gt; implies
     * &lt;tt&gt;compare(x, z)&amp;gt;0&lt;/tt&gt;.&lt;p&gt;
     *
     * Finally, the implementor must ensure that &lt;tt&gt;compare(x, y)==0&lt;/tt&gt;
     * implies that &lt;tt&gt;sgn(compare(x, z))==sgn(compare(y, z))&lt;/tt&gt; for all
     * &lt;tt&gt;z&lt;/tt&gt;.&lt;p&gt;
     *
     * It is generally the case, but &lt;i&gt;not&lt;/i&gt; strictly required that
     * &lt;tt&gt;(compare(x, y)==0) == (x.equals(y))&lt;/tt&gt;.  Generally speaking,
     * any comparator that violates this condition should clearly indicate
     * this fact.  The recommended language is "Note: this comparator
     * imposes orderings that are inconsistent with equals."
     *
     * @param o1 the first object to be compared.
     * @param o2 the second object to be compared.
     * @return a negative integer, zero, or a positive integer as the
     *         first argument is less than, equal to, or greater than the
     *         second.
     * @throws NullPointerException if an argument is null and this
     *         comparator does not permit null arguments
     * @throws ClassCastException if the arguments' types prevent them from
     *         being compared by this comparator.
     */</span>
    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">T</span> o1<span class="token punctuation">,</span> <span class="token class-name">T</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h4>
     <a id="3_ComparableComparator_152">
     </a>
     3. Comparable和Comparator区别
    </h4>
    <p>
     Java设计了Comparable接口，那么为什么还需要设计Comparator接口呢，两者区别是什么呢。
    </p>
    <p>
     <strong>
      首先Comparable接口和Comparator接口 都能提供比较能力并返回结果。这是他们的相同点，这是设计的初衷
     </strong>
    </p>
    <p>
     不同点：
    </p>
    <ol>
     <li>
      Comparable 表示一种能力，一般需要对象实现其接口，使其获取比较的能力。实现后 相当于本身具有比较能力。直接调用compareTo方法
     </li>
     <li>
      Comparator 是一种工具，通过这种工具，可以将两种不具备比较的对象，区分出顺序。是借助外部工具
     </li>
    </ol>
    <h4>
     <a id="4_Java_163">
     </a>
     4. Java设计方式思考
    </h4>
    <p>
     <strong>
      Java中有其实还有其他类似的设计。例如Iterable和iterator.都是这样。针对相同的能力尽可能的提供更多的渠道，可以实现它，或者使用工具，最终的目的都是达到需要实现的目的。根据这种类似案例，是否以后在开发业务或工具时，也提供更多的渠道供其他调用者使用
     </strong>
    </p>
    <h4>
     <a id="5__167">
     </a>
     5. 其他类似案例
    </h4>
    <p>
     Iterable和Iterator
    </p>
    <h4>
     <a id="6__171">
     </a>
     6. 总结
    </h4>
    <p>
     本篇文章其实是FunctionalInterface函数式接口的扩展。在常用的Supplier、Consumer、Function、Predicate的FunctionalInterface以及各种类型扩展后。介绍了Comparable接口。并扩展介绍Comparable的功能含义以及Comparable和Comparator比较。
    </p>
    <p>
     其实本篇在介绍Comparable接口功能时，列举的案例，输出结果都是都是升序的，那么你有没有想过，如果列举出倒序的结果呢，又有哪几种方式呢?
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f666f72323031382f:61727469636c652f64657461696c732f313238323132323236" class_="artid" style="display:none">
 </p>
</div>


