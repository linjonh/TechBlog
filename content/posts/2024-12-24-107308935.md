---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34323637323737302f:61727469636c652f64657461696c732f313037333038393335"
layout: post
title: "单元测试用例编写总结-白盒测试"
date: 2024-12-24 14:58:52 +08:00
description: "1 背景测试是开发的一个非常重要的方面，可以在很大程度上决定一个应用程序的命运。良好的测试可以在早期"
keywords: "单元测试用例编写"
categories: ['生产工具与工作流', 'C']
tags: ['无标签']
artid: "107308935"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=107308935
    alt: "单元测试用例编写总结-白盒测试"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=107308935
featuredImagePreview: https://bing.ee123.net/img/rand?artid=107308935
---

# 单元测试用例编写总结 （白盒测试）

1 背景
  
测试是开发的一个非常重要的方面，可以在很大程度上决定一个应用程序的命运。良好的测试可以在早期捕获导致应用程序崩溃的问题，但较差的测试往往总是导致故障和停机。

单元测试用于测试各个代码组件，并确保代码按照预期的方式工作。单元测试由开发人员编写和执行。大多数情况下，使用JUnit或TestNG之类的测试框架。测试用例通常是在方法级别写入并通过自动化执行。

单元测试不仅仅用来保证当前代码的正确性，更重要的是用来保证代码修复、改进或重构之后的正确性。

2 单元测试用例相关概念
  
2.1正面测试（Positive Testing）
  
测试被测对象的正确功能实现无误，即正常流程功能。往往需要根据设计说明进行用例导出，严格按照设计说明编写即可，用例划分注意等价类区分等方法。

2.2负面测试（Negative Testing）
  
测试被测对象的异常功能实现无误，多在异常流程，异常数据中体现。该部分测试需要对被测对象进行错误发散，常依赖于边界值区分等方法。

2.3分支测试
  
使用流程图，明确可能出现的每条分支，制造响应的数据进行覆盖，实现对被测对象的测试。这个过程对于分支可以进行响应的简化，可以穿插等价类等方法去除同类分支。

2.4 边界值分析法
  
这种方法更偏向于黑盒测试用例设计中使用，对被测输入进行边界分析，从各个角度都会有边界值，例如程序内部依赖之间，已经有一些边界存在，在程序集成展示后，也会有新的边界出现，在设计的时候，需要注意这些细节。例如我们可输入范围是3-6，和输入类型为浮点数。那么边界值为7-8之间

7 8

| |

3 单元测试设计原则和任务
  
3.1 三原则
  
为了提高开发人员的代码质量，编写高质量的单元测试，要遵守3R（Responsible, Reliable, Repeative）原则，具体含义如下：

Responsible: 谁开发谁负责测试，在哪里开发就在哪里测试。

Reliable: 测试case要可靠，并且是值得信赖的，对于底层的任何改动都要能够及时感知。

Repeative: 所有单元测试用例都要能够重复运行。能够重复运行就能够进行回归测试、覆盖率统计等等。

3.2 单元测试任务
  
一般来说，单元测试任务包括：

1、接口功能测试：用来保证接口功能的正确性。

2、局部数据结构测试（不常用）：用来保证接口中的数据结构是正确的

（1）比如变量有无初始值

（2）变量是否溢出

3、边界条件测试

（1）变量没有赋值（即为NULL）

（2）变量是数值（或字符)

a.主要边界：最小值，最大值，无穷大（对于DOUBLE等）

b.溢出边界（期望异常或拒绝服务）：最小值-1，最大值+1

c.临近边界：最小值+1，最大值-1

（3）变量是字符串

a.引用"字符变量"的边界

b.空字符串

c.对字符串长度应用"数值变量"的边界

（4）变量是集合

a.空集合

b.对集合的大小应用"数值变量"的边界

c.调整次序：升序、降序

（5）变量有规律

a.比如对于Math.sqrt，给出n^2-1，和n^2+1的边界

4、所有独立执行通路测试：保证每一条代码，每个分支都经过测试

（1）代码覆盖率

a.语句覆盖：保证每一个语句都执行到了

b.判定覆盖（分支覆盖）：保证每一个分支都执行到

c.条件覆盖：保证每一个条件都覆盖到true和false（即if、while中的条件语句）

d.路径覆盖：保证每一个路径都覆盖到

（2）相关软件

a.Cobertura：语句覆盖

b.Emma: Eclipse插件Eclemma

5、各条错误处理通路测试：保证每一个异常都经过测试

4 注意事项
  
4.1独立性
  
单元测试用例在设计和数据准备的过程中，需要保持良好的独立性，确保本测试的数据是不需要依赖其他输出的，这样减少相互影响。

4.2尽量脱离被测代码的束缚
  
在测试用例设计的过程中，尤其是测试用例编写在代码编写完成后进行的，一定小心被代码实现功能所影响，多考虑异常分支和异常数据。

4.3面向对象的语言单元测试特点
  
面向对象的语言进行单元测试还有一定的特点，对于每一个类，可能他出现在程序中的情况各不相同，在进行测试的时候，可以结合上面介绍的方法，根据内部方法相互调用逻辑，完成测试设计。

大体划分两个方向，一个是功能性的，就是类似黑盒的方法，仅仅关注实现的功能点是否正确；另一个就是结构性测试，需要分析类中的方法相互实现逻辑，进行类似白盒测试，确保每个分支覆盖。

5 单元测试用例编写技巧
  
5.1使用断言
  
使用断言而不是Print语句许多新手开发人员习惯于在每行代码之后编写System.out.println语句来验证代码是否正确执行。这种做法常常扩展到单元测试，从而导致测试代码变得杂乱。除了混乱，这需要开发人员手动干预去验证控制台上打印的输出，以检查测试是否成功运行。更好的方法是使用自动指示测试结果的断言。

5.2 考虑负面场景
  
除了正面情景，还要测试负面情景和边缘情况通常，开发人员会花费大量的时间和精力编写测试用例，以确保应用程序按预期工作。然而，测试负面测试用例也很重要。负面测试用例指的是测试系统是否可以处理无效数据的测试用例。

5.3 测试结果的预知性
  
构建具有确定性结果的测试，一些方法不具有确定性结果，即该方法的输出不是预先知道的，并且每一次都可以改变，为该方法编写测试用例不会有任何用处。

#### 

一、
**单元测试**
的概念

单元通俗的说就是指一个实现简单功能的函数。单元测试就是只用一组特定的输入(
**测试用例**
)测试函数是否功能正常，并且返回了正确的输出。

测试的覆盖种类

1.语句覆盖：语句覆盖就是设计若干个测试用例，运行被测试程序，使得每一条可执行语句至少执行一次。

2.判定覆盖（也叫分支覆盖）：设计若干个测试用例，运行所测程序，使程序中每个判断的取真分支和取假分支至少执行一次。

3.条件覆盖：设计足够的测试用例，运行所测程序，使程序中每个判断的每个条件的每个可能取值至少执行一次。

4.判定——条件覆盖：设计足够的测试用例，运行所测程序，使程序中每个判断的每个条件的每个可能取值至少执行一次，并且每个可能的判断结果也至少执行一次。

5.条件组合测试：设计足够的测试用例，运行所测程序，使程序中每个判断的所有条件取值组合至少执行一次。

6.路径测试：设计足够的测试用例，运行所测程序，要覆盖程序中所有可能的路径。

用例的设计方案主要的有下面几种：条件测试，基本路径测试，循环测试。通过上面的方法可以实现测试用例对程序的逻辑覆盖，和路径覆盖。

二、开始测试前的准备

在开始测试时，要先声明一下，无论你设计多少测试用例，无论你的测试方案多么完美，都不可能完全100%的发现所有BUG，我们所需要做的是用最少的资源，做最多测试检查，寻找一个平衡点保证程序的正确性。穷举测试是不可能的。   所以现在进行单元测试我选用的是现在一般用的比较多的基本路径测试法。

三、开始测试

基本路径测试法：设计出的测试用例要保证每一个基本独立路径至少要执行一次。

函数说明 ：当i\_flag=0；返回     i\_count+100
  
当i\_flag=1；返回   i\_count  \*10
  
否则  返回   i\_count  \*20

输入参数：int i\_count ，
  
int i\_flag
  
输出参数： int  i\_return;
  
  
  
代码：

1  int Test(int i\_count, int i\_flag)
  
2         {
  
3             int i\_temp = 0;
  
4             while (i\_count>0)
  
5             {
  
6                 if (0 == i\_flag)
  
7                 {
  
8                     i\_temp = i\_count + 100;
  
9                     break;
  
10                 }
  
11                 else
  
12                 {
  
13                     if (1 == i\_flag)
  
14                     {
  
15                         i\_temp = i\_temp + 10;
  
16                     }
  
17                     else
  
18                     {
  
19                         i\_temp = i\_temp + 20;
  
20                     }
  
21                 }
  
22                 i\_count--;
  
23             }
  
24             return i\_temp;
  
25         }

引用：https://blog.csdn.net/moshenglv/article/details/79610986