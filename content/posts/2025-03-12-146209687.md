---
layout: post
title: "力扣练习之确定两个字符串是否接近"
date: 2025-03-12 17:20:25 +0800
description: "通过该判断之后，我们要判断的是是否有相同频次出现，那这个时候，我们就可以进行排序，排序完看看这两个count数组是否一样即可，如果不一样，比如说count1里有5，但是count2里并没有，那么说明字符串1里有一个字符出现了5次，二字符串2里并没有出现5次的字符，这也会不符合接近的定义，所以返回false，如果完全一样，那么就返回true。2. 字符的出现频次是要一样的（这里的意思不是说相同字符出现的频次必须要一样，而是说只要有跟它一样的频次的字符出现在另一个字符串里就可以）执行操作 1：\"ca。"
keywords: "力扣练习之确定两个字符串是否接近"
categories: ['力扣练习题']
tags: ['算法', '前端', 'Leetcode']
artid: "146209687"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146209687
    alt: "力扣练习之确定两个字符串是否接近"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146209687
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146209687
cover: https://bing.ee123.net/img/rand?artid=146209687
image: https://bing.ee123.net/img/rand?artid=146209687
img: https://bing.ee123.net/img/rand?artid=146209687
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     力扣练习之确定两个字符串是否接近
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E9%A2%98%E7%9B%AE%EF%BC%9A" name="%E9%A2%98%E7%9B%AE%EF%BC%9A">
     题目：
    </h2>
    <blockquote>
     <p>
      如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串
      <strong>
       接近
      </strong>
      ：
     </p>
     <ul>
      <li>
       操作 1：交换任意两个
       <strong>
        现有
       </strong>
       字符。
       <ul>
        <li>
         例如，
         <code>
          a
          <u>
           b
          </u>
          cd
          <u>
           e
          </u>
          -&gt; a
          <u>
           e
          </u>
          cd
          <u>
           b
          </u>
         </code>
        </li>
       </ul>
      </li>
      <li>
       操作 2：将一个
       <strong>
        现有
       </strong>
       字符的每次出现转换为另一个
       <strong>
        现有
       </strong>
       字符，并对另一个字符执行相同的操作。
       <ul>
        <li>
         例如，
         <code>
          <u>
           aa
          </u>
          c
          <u>
           abb
          </u>
          -&gt;
          <u>
           bb
          </u>
          c
          <u>
           baa
          </u>
         </code>
         （所有
         <code>
          a
         </code>
         转化为
         <code>
          b
         </code>
         ，而所有的
         <code>
          b
         </code>
         转换为
         <code>
          a
         </code>
         ）
        </li>
       </ul>
      </li>
     </ul>
     <p>
      你可以根据需要对任意一个字符串多次使用这两种操作。
     </p>
     <p>
      给你两个字符串，
      <code>
       word1
      </code>
      和
      <code>
       word2
      </code>
      。如果
      <em>
      </em>
      <code>
       word1
      </code>
      <em>
      </em>
      和
      <em>
      </em>
      <code>
       word2
      </code>
      <em>
      </em>
      <strong>
       接近
      </strong>
      ，就返回
      <code>
       true
      </code>
      ；否则，返回
      <em>
      </em>
      <code>
       false
      </code>
      <em>
      </em>
      。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <pre><strong>输入：</strong>word1 = "abc", word2 = "bca"
<strong>输出：</strong>true
<strong>解释：</strong>2 次操作从 word1 获得 word2 。
执行操作 1："a<u>bc</u>" -&gt; "a<u>cb</u>"
执行操作 1："<u>a</u>c<u>b</u>" -&gt; "<u>b</u>c<u>a</u>"
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>word1 = "a", word2 = "aa"
<strong>输出：</strong>false
<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>word1 = "cabbba", word2 = "abbccc"
<strong>输出：</strong>true
<strong>解释：</strong>3 次操作从 word1 获得 word2 。
执行操作 1："ca<u>b</u>bb<u>a</u>" -&gt; "ca<u>a</u>bb<u>b</u>"
执行操作 2：<code>"</code><u>c</u>aa<u>bbb</u>" -&gt; "<u>b</u>aa<u>ccc</u>"
执行操作 2："<u>baa</u>ccc" -&gt; "<u>abb</u>ccc"
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       <code>
        1 &lt;= word1.length, word2.length &lt;= 105
       </code>
      </li>
      <li>
       <code>
        word1
       </code>
       和
       <code>
        word2
       </code>
       仅包含小写英文字母
      </li>
     </ul>
    </blockquote>
    <h2 id="%E9%A2%98%E8%A7%A3%EF%BC%9A" name="%E9%A2%98%E8%A7%A3%EF%BC%9A">
     题解：
    </h2>
    <pre><code class="language-cpp">class Solution {
public:
    bool closeStrings(string word1, string word2) {
        //存储各个字符出现的频率
        vector&lt;int&gt; count1(26),count2(26);//因为一共就26个字母，所以长度26即可
        for(char c: word1){
            count1[c-'a']++;
        }
        for(char c: word2){
            count2[c-'a']++;
        }
        //验证是否字符一样
        for(int i=0;i&lt;26;i++){
            if(count2[i]&gt;0&amp;&amp;count1[i]==0 ||count2[i]==0&amp;&amp;count1[i]&gt;0){
                return false;
            }
        }
        //字符一样之后，验证是否有相同的次数出现
        sort(count1.begin(),count1.end());
        sort(count2.begin(),count2.end());
        return count1==count2;
    }
};</code></pre>
    <h2 id="%E8%AF%A6%E7%BB%86%E9%A2%98%E8%A7%A3" name="%E8%AF%A6%E7%BB%86%E9%A2%98%E8%A7%A3">
     详细题解
    </h2>
    <p>
     刚开始其实我看到这个题目是懵的，因为我忘了c++关于字符串的遍历还有统计啥的方法咋做了哈哈哈，所以就看了官方题解。其实我觉得官方题解非常的妙。
    </p>
    <p>
     对于这个题我觉得理解到底什么叫两个字符串接近是关键，对于题目的两个操作其实说人话就是
    </p>
    <p>
     1.这两个字符串出现的字符必须得一样
    </p>
    <p>
     2. 字符的出现频次是要一样的（这里的意思不是说相同字符出现的频次必须要一样，而是说只要有跟它一样的频次的字符出现在另一个字符串里就可以）
    </p>
    <p>
     所以在解答这个题的时候同样可以分成两部分
    </p>
    <p>
     首先我们使用两个数组来分别存储不同字符出现的频率，其中下标来表示字符的ASCII码，元素来表示频率
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">//存储各个字符出现的频率
        vector&lt;int&gt; count1(26),count2(26);//因为一共就26个字母，所以长度26即可
        for(char c: word1){
            count1[c-'a']++;
        }
        for(char c: word2){
            count2[c-'a']++;
        }</code></pre>
    <p>
     然后可以来判断两个字符串出现的字符是否一样了 ,因为我们用下标来表示字符，元素来表示出现的次数，那么对于同样下标的如果有一个数组元素为0，那说明他对应的字符串是没有该元素的，所以也就是两个字符串中字符不一样，也就是不接近，所以也就可以直接返回false了
    </p>
    <pre><code class="language-cpp">//验证是否字符一样
        for(int i=0;i&lt;26;i++){
            if(count2[i]&gt;0&amp;&amp;count1[i]==0 ||count2[i]==0&amp;&amp;count1[i]&gt;0){
                return false;
            }
        }</code></pre>
    <p>
     通过该判断之后，我们要判断的是是否有相同频次出现，那这个时候，我们就可以进行排序，排序完看看这两个count数组是否一样即可，如果不一样，比如说count1里有5，但是count2里并没有，那么说明字符串1里有一个字符出现了5次，二字符串2里并没有出现5次的字符，这也会不符合接近的定义，所以返回false，如果完全一样，那么就返回true
    </p>
    <pre><code class="language-cpp"> //字符一样之后，验证是否有相同的次数出现
        sort(count1.begin(),count1.end());
        sort(count2.begin(),count2.end());
        return count1==count2;</code></pre>
    <p>
     后话：希望我下次再次做这个题的时候，还能像现在这样思路清晰~
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343637323733342f:61727469636c652f64657461696c732f313436323039363837" class_="artid" style="display:none">
 </p>
</div>


