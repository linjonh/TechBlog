---
layout: post
title: "jmockit教程_原创如何使用Jmockit进行单元测试"
date: 2021-02-26 06:36:20 +0800
description: "如何使用jmockit进行单元测试1. Jmockit简介JMockit 是用以帮助开发人员编写测试"
keywords: "jmockit"
categories: ['未分类']
tags: ['Jmockit']
artid: "114720445"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=114720445
  alt: "jmockit教程_原创如何使用Jmockit进行单元测试"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=114720445
featuredImagePreview: https://bing.ee123.net/img/rand?artid=114720445
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     jmockit教程_【原创】如何使用Jmockit进行单元测试
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div style="font-size:16px;">
     <p>
      如何使用jmockit进行单元测试
     </p>
     <p>
      1. Jmockit简介
     </p>
     <p>
      JMockit 是用以帮助开发人员编写测试程序的一组工具和API，它完全基于 Java 5 SE 的 java.lang.instrument 包开发，内部使用 ASM 库来修改Java的Bytecode。正是由于基于instrument，可以修改字节码。所以这也是它强大的原因。
     </p>
     <p>
      Jmockit可以mock的种类包含了：
     </p>
     <p>
      1. class(abstract, final, static)
     </p>
     <p>
      2. interface
     </p>
     <p>
      3. enum
     </p>
     <p>
      4. annotation
     </p>
     <p>
      5. native
     </p>
     <p>
      Jmockit 有两种mock的方式：
     </p>
     <p>
      1. Behavior-oriented(Expectations &amp; Verifications)
     </p>
     <p>
      2. State-oriented(MockUp)
     </p>
     <p>
      通俗点讲，Behavior-oriented是基于行为的mock，对mock目标代码的行为进行模仿，更像黑盒测试。State-oriented 是基于状态的mock，是站在目标测试代码内部的。可以对传入的参数进行检查、匹配，才返回某些结果，类似白盒。而State-oriented的 new MockUp基本上可以mock任何代码或逻辑。非常强大。
     </p>
     <p>
      (这段介绍来自网络转载)
     </p>
     <p>
      2. Jmockit实践
     </p>
     <p>
      使用jMockit首先要引用相关的jar包，pom文件引用如下.
     </p>
     <p>
      org.jmockit
     </p>
     <p>
      jmockit
     </p>
     <p>
      1.20
     </p>
     <p>
      test
     </p>
     <p>
      org.jmockit
     </p>
     <p>
      jmockit-coverage
     </p>
     <p>
      1.20
     </p>
     <p>
      test
     </p>
     <p>
      junit
     </p>
     <p>
      junit
     </p>
     <p>
      4.11
     </p>
     <p>
      test
     </p>
     <p>
      2.1 示例1：模拟类
     </p>
     <p>
      被测试方法如下：
     </p>
     <p align="center">
      <img alt="1dbfa8c06be034982dc6912687c72ac7.png" src="https://i-blog.csdnimg.cn/blog_migrate/01f283361929bd890dfd8b9ad97a0bc6.png"/>
     </p>
     <p>
      其中NegativeTransDos的insert方法是插入数据库。
     </p>
     <p>
      为了测试process()方法的逻辑，希望能够模拟dao.insert方法的返回结果，参考测试代码如下：
     </p>
     <p align="center">
      <img alt="826d5730d55f14cf3abfc42f1cdd3d23.png" src="https://i-blog.csdnimg.cn/blog_migrate/4343974a568f088b52fe57ccd20e776f.png"/>
     </p>
     <p>
      可以看到使用jmockit基本有三个步骤：
     </p>
     <p>
      (1)打桩。指定要打桩类和函数，模拟返回结果。这里是new Mockup(NegativeTransDos)。
     </p>
     <p>
      (2)调用被测方法。被测逻辑执行过程中，之前的打桩数据生效。
     </p>
     <p>
      (3)判断测试结果是否符合预期。
     </p>
     <p>
      通过以下方法来模拟类和方法。
     </p>
     <p>
      new Mockup(类) {
      <!-- -->
     </p>
     <p>
      模拟方法{
      <!-- -->
     </p>
     <p>
      控制该方法返回结果
     </p>
     <p>
      }
     </p>
     <p>
      }
     </p>
     <p>
      2.2 示例2：模拟静态方法
     </p>
     <p>
      被测试方法如下。其中红框是需要Mock的两个静态方法。通过Jmockit模拟这两个静态方法的返回，只关注EdaStartup方法的自身逻辑。
     </p>
     <p align="center">
      <img alt="c74b1e8fc78b0a05b554bb3caed32bab.png" src="https://i-blog.csdnimg.cn/blog_migrate/cf2b6064594c8392b6e2af1b16bc7eb0.png"/>
     </p>
     <p>
      参考测试代码如下：
     </p>
     <p align="center">
      <img alt="8d38e8e4630d0c08d6ffe544d13fc785.png" src="https://i-blog.csdnimg.cn/blog_migrate/07e82965c181a420621c74bc46aa9f0e.png"/>
     </p>
     <p>
      2.3 示例3：模拟非静态方法
     </p>
     <p>
      被测试方法：
     </p>
     <p align="center">
      <img alt="7283a21a654acd0f98f2e97f3554ab95.png" src="https://i-blog.csdnimg.cn/blog_migrate/c6afd86975370130c8ca0731b9b31600.png"/>
     </p>
     <p>
      这里包括两种方法的模拟：
     </p>
     <p>
      McEventManager.getReceiver()，这个是静态方法调用的模拟，参考2.1章节。
     </p>
     <p>
      receiver.getEvent()，这个是普通对象方法调用。本节关注这种方法的模拟。
     </p>
     <p>
      参考测试代码如下：
     </p>
     <p align="center">
      <img alt="0a63c322650867969f66c8f7a4aa4bdc.png" src="https://i-blog.csdnimg.cn/blog_migrate/3ec0872850290bb5dff28e2eb1d37279.png"/>
     </p>
     <p>
      首先需要通过 @Injectable 声明要插桩的对象：
     </p>
     <p>
      private McEventReceiver receiver;
     </p>
     <p>
      之后使用以下方式来插桩：
     </p>
     <p>
      new NonStrictExpectations() {
      <!-- -->
     </p>
     <p>
      要模拟的方法(参数1，参数2，…)
     </p>
     <p>
      result = 返回结果
     </p>
     <p>
      }
     </p>
     <p>
      Jmockit提供了很彪悍的万能入参，这一点非常方便。包括：
     </p>
     <p align="center">
      <img alt="9e1a09f07165a534144e7ca0e1df9d11.png" src="https://i-blog.csdnimg.cn/blog_migrate/624762db9bfe2cf81357a9fde73ada93.png"/>
     </p>
     <p>
      2.4 示例4：模拟private静态方法
     </p>
     <p>
      被测代码如下：
     </p>
     <p align="center">
      <img alt="cc210411d4fa150eacc0485049d95992.png" src="https://i-blog.csdnimg.cn/blog_migrate/bb42efda4d9dc63000275fc4c690317b.png"/>
     </p>
     <p>
      publicMethod()是被测试方法，其中调用了静态成员方法privateMethod。为了摒除privateMethod的影响，需要模拟它的返回结果。
     </p>
     <p>
      参考测试代码如下：
     </p>
     <p align="center">
      <img alt="7377e08a87d337f21dcdb7557ec1774c.png" src="https://i-blog.csdnimg.cn/blog_migrate/73a8b6700fb7b61dd4742da086ed6655.png"/>
     </p>
     <p>
      test1和test2的输出结果分别是：
     </p>
     <p align="center">
      <img alt="fecb49769c0a29727e68f5ab76f1ef8e.png" src="https://i-blog.csdnimg.cn/blog_migrate/5166e0a484eea2c6750442cac5d38929.png"/>
     </p>
     <p>
      2.5 示例5：模拟private非静态方法
     </p>
     <p>
      被测代码如下：
     </p>
     <p align="center">
      <img alt="433b3faf92225193d84662c68eef34b2.png" src="https://i-blog.csdnimg.cn/blog_migrate/859d4c7c662661a1fe2a910e416264fa.png"/>
     </p>
     <p>
      publicMethod()是被测试方法，其中调用了私有非静态成员方法privateMethod。为了摒除privateMethod的影响，需要模拟它的返回结果。
     </p>
     <p>
      参考测试代码如下：
     </p>
     <p align="center">
      <img alt="839f08951047b1f4782608b2efaad453.png" src="https://i-blog.csdnimg.cn/blog_migrate/618961ed1d18d248817c4aeffaa0e048.png"/>
     </p>
     <p>
      对比2.5私有静态方法的模拟可以看到略有区别。
     </p>
     <p>
      new Expectations(XXX) 中，之前指定的是MockClass.class，这里指定的是被测试的MockClass对象。
     </p>
     <p>
      test1和test2的输出结果分别是：
     </p>
     <p align="center">
      <img alt="0dd7a479a9c7b04907fa52af57db8480.png" src="https://i-blog.csdnimg.cn/blog_migrate/806f83feff671db57b6e263f8232edff.png"/>
     </p>
     <p>
      2.6 示例6：模拟private非静态成员变量
     </p>
     <p>
      被测方法如下：
     </p>
     <p align="center">
      <img alt="8c3d2853bc2621c87ae1011dea0ada11.png" src="https://i-blog.csdnimg.cn/blog_migrate/9f81a359f424c45f5702d852a9c573d3.png"/>
     </p>
     <p>
      其中field是MockField的私有变量。我们目的是能够模拟该私有变量的值，来关注publicMethod方法的测试。
     </p>
     <p>
      参考测试代码如下：
     </p>
     <p align="center">
      <img alt="0e9a7f747b435ec4a9c125e9b8db10c4.png" src="https://i-blog.csdnimg.cn/blog_migrate/a4b8dce5c1173fc52fbe2c8c4c10d1e9.png"/>
     </p>
     <p>
      test1和test2的输出结果分别是：
     </p>
     <p align="center">
      <img alt="61473b88a061f2bb2b66fff4d8db68ca.png" src="https://i-blog.csdnimg.cn/blog_migrate/ed8c99d6466c83ef239dae717e81fce0.png"/>
     </p>
     <p>
      2.7 示例7：模拟private静态成员变量
     </p>
     <p>
      类似2.6节非静态成员变量的模拟，参考2.4和2.5的区别。示例略。
     </p>
    </div>
   </div>
  </div>
  <div id="recommendDown">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f33393832383835392f:61727469636c652f64657461696c732f313134373230343435" class_="artid" style="display:none">
 </p>
</div>
