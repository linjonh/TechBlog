---
layout: post
title: "数据结构单调队列"
date: 2025-03-14 22:13:38 +0800
description: "单调队列是一种维护滑动窗口内极值的高效数据结构，通过保持队列元素单调性，可在O(n)时间内解决最大值/最小值问题，常用于优化动态规划及算法时间复杂度"
keywords: "数据结构——单调队列"
categories: ['C']
tags: ['算法', '数据结构', '开发语言', 'C']
artid: "146268142"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268142
    alt: "数据结构单调队列"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268142
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268142
cover: https://bing.ee123.net/img/rand?artid=146268142
image: https://bing.ee123.net/img/rand?artid=146268142
img: https://bing.ee123.net/img/rand?artid=146268142
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——单调队列
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     一.单调队列简介
    </h3>
    <h4>
     1.1单调队列定义与特性本质：
    </h4>
    <blockquote>
     <p>
      单调队列是一种特殊的队列结构，其内部元素始终保持单调递增或单调递减的顺序。
      <br/>
      核心规则：当新元素入队列时，会通过弹出破坏单调性的队首元素来维持有序性。
      <br/>
      单调方向：
      <br/>
      单调递增栈：从队列首到队列尾，元素逐渐变大（例如 [1,3,5,7][1,3,5,7]）。
      <br/>
      单调递减栈：从队列首到队列尾，元素逐渐变小（例如 [9,6,2,1][9,6,2,1]）。
     </p>
    </blockquote>
    <h4>
     1.2应用场景
    </h4>
    <h5>
     1.
     <strong>
      滑动窗口最大值/最小值
     </strong>
    </h5>
    <p>
     单调队列最典型的应用是
     <strong>
      动态维护滑动窗口内的极值
     </strong>
     。例如，给定数组和窗口大小 kk，要求实时输出窗口滑动时的最大值或最小值。
    </p>
    <h5>
     2.
     <strong>
      子数组最小值之和
     </strong>
    </h5>
    <p>
     题目要求计算所有连续子数组的最小值之和（如引用[1]的问题）。虽然通常用
     <strong>
      单调栈
     </strong>
     解决，但
     <strong>
      单调队列
     </strong>
     可优化特定条件下的动态范围操作。
    </p>
    <h5>
     3.
     <strong>
      动态规划优化
     </strong>
    </h5>
    <p>
     在动态规划问题中，若状态转移方程涉及某区间内的极值，可用单调队列减少时间复杂度。
    </p>
    <h3>
     二.模板代码
    </h3>
    <h4>
     2.1代码
    </h4>
    <pre><code class="language-cpp">for (int i = 0; i &lt; n; i++) {
    // 维护单调性：移除比当前元素大的队尾元素
    while (!q.empty() &amp;&amp; a[i] &lt;= a[q.back()]) {
        q.pop_back();
    }
    q.push_back(i);
    // 移除超出窗口范围的队首元素
    while (q.front() &lt;= i - k) {
        q.pop_front();
    }
    // 当窗口形成后记录结果
    if (i &gt;= k - 1) {
        res.push_back(a[q.front()]);
    }
}</code></pre>
    <h4>
     2.2实现解析
    </h4>
    <ol>
     <li>
      <strong>
       双端队列选择
      </strong>
      ：使用
      <code>
       deque
      </code>
      容器支持O(1)时间的头尾操作
     </li>
     <li>
      <strong>
       单调性维护
      </strong>
      ：通过
      <code>
       while
      </code>
      循环确保队列元素单调递增（nums[i]&lt;=nums[q.back()]nums[i]&lt;=nums[q.back()]），若需要最大值队列则改为
      <code>
       &gt;=
      </code>
      比较
     </li>
     <li>
      <strong>
       窗口范围检查
      </strong>
      ：
      <code>
       q.front() &lt;= i - k
      </code>
      判断队首是否超出当前窗口左边界
     </li>
     <li>
      <strong>
       时间复杂度
      </strong>
      ：每个元素最多入队出队各一次，整体O(n)时间复杂度
     </li>
    </ol>
    <h3>
     三.例题《切蛋糕》
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

deque&lt;int&gt; q; // 单调队列，存储可能的左端点索引j，保持sum[j-1]递增
int n, k, a[500005], sum[500005], maxx = -0x3f3f3f3f; // sum为前缀和数组，maxx记录最大值

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); // 加速输入输出
    cin &gt;&gt; n &gt;&gt; k; // 输入n和k（k对应题目中的m）
    for(int i = 1; i &lt;= n; i++){
        cin &gt;&gt; a[i];
        sum[i] = sum[i-1] + a[i]; // 计算前缀和
    }
    
    for(int i = 1; i &lt;= n; i++){
        // 维护队列的单调性：保证队列中的sum[j-1]递增
        // 当当前sum[i-1]比队尾的sum[j-1]更小，队尾的元素不可能成为最优解，弹出
        while(!q.empty() &amp;&amp; sum[q.back()-1] &gt; sum[i-1]){
            q.pop_back();
        }
        q.push_back(i); // 将当前索引i加入队列，作为可能的左端点
        
        // 维护窗口大小：确保子数组长度不超过k
        // 若当前i与队首的距离超过k，弹出队首
        if(i - q.front() + 1 &gt; k){
            q.pop_front();
        }
        
        // 计算以i为右端点的最大子段和，并更新最大值
        maxx = max(maxx, sum[i] - sum[q.front()-1]);
    }
    
    cout &lt;&lt; maxx;
    return 0;
}</code></pre>
    <h2>
     加纳！！！！！
    </h2>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37373537323335332f:61727469636c652f64657461696c732f313436323638313432" class_="artid" style="display:none">
 </p>
</div>


