---
layout: post
title: "list及其模拟实现"
date: 2025-03-16 17:06:09 +0800
description: "list其实就是一个带头双向链表。"
keywords: "list及其模拟实现"
categories: ['C']
tags: ['数据结构', 'List']
artid: "146162705"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146162705
    alt: "list及其模拟实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146162705
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146162705
cover: https://bing.ee123.net/img/rand?artid=146162705
image: https://bing.ee123.net/img/rand?artid=146162705
img: https://bing.ee123.net/img/rand?artid=146162705
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     list及其模拟实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     list其实就是一个带头双向链表
    </p>
    <p>
     <img alt="" height="862" src="https://i-blog.csdnimg.cn/direct/e59ea2851fdc4faaa5288cafd1d0ab2e.png" width="1264"/>
    </p>
    <h2>
     1 迭代器
    </h2>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        按功能分
       </td>
      </tr>
      <tr>
       <td>
        iterator
       </td>
      </tr>
      <tr>
       <td>
        reverse_iterator
       </td>
      </tr>
      <tr>
       <td>
        const_iterator
       </td>
      </tr>
      <tr>
       <td>
        const_reverse_iterator
       </td>
      </tr>
     </tbody>
    </table>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        按性质分
       </td>
       <td>
        支持结构
       </td>
       <td>
        支持操作
       </td>
      </tr>
      <tr>
       <td>
        单向
       </td>
       <td>
        forward_list/unordered_map
       </td>
       <td>
        ++
       </td>
      </tr>
      <tr>
       <td>
        双向
       </td>
       <td>
        list/map/set
       </td>
       <td>
        ++/--
       </td>
      </tr>
      <tr>
       <td>
        随机
       </td>
       <td>
        vector/string/deque
       </td>
       <td>
        ++ / -- / + / -
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     按性质分，决定可以使用那些算法。支持单向的算法，也支持双向和随机，反之不然。
    </p>
    <h2>
     2 list的使用
    </h2>
    <h3>
     2.1 list的构造
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        构造函数（
        <a href="https://legacy.cplusplus.com/reference/list/list/list/" rel="nofollow" title="(constructor)">
         (constructor)
        </a>
        ）
       </td>
       <td>
        接口说明
       </td>
      </tr>
      <tr>
       <td>
        <p>
         list(size_type n,
        </p>
        <p>
         const value_type&amp; val = value_type())
        </p>
       </td>
       <td>
        构造的list包含n个值为val的元素
       </td>
      </tr>
      <tr>
       <td>
        list()
       </td>
       <td>
        构造空的list
       </td>
      </tr>
      <tr>
       <td>
        list(const list&amp; x)
       </td>
       <td>
        拷贝构造函数
       </td>
      </tr>
      <tr>
       <td>
        list(InputIterator frist,InputIterator last)
       </td>
       <td>
        用[frist,last)区间中的元素构造list
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-cpp">void test_list1()
{
	list&lt;int&gt; l1;
	list&lt;int&gt; l2(4, 10);
	list&lt;int&gt; l3(l2);
	list&lt;int&gt; l4(++l2.begin(), --l2.end());
	for (auto e : l1)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	for (auto e : l2)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	for (auto e : l3)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	for (auto e : l4)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

int main()
{
	test_list1();
}</code></pre>
    <p>
     <img alt="" height="832" src="https://i-blog.csdnimg.cn/direct/860641fed902493095aaf10df3fc4a56.png" width="621"/>
    </p>
    <h3>
     2.2 list的迭代器
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        函数声明
       </td>
       <td>
        接口说明
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/begin/" rel="nofollow" title="begin">
          begin
         </a>
        </p>
       </td>
       <td>
        返回第一个元素的迭代器（头节点的下一个）
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/end/" rel="nofollow" title="end">
          end
         </a>
        </p>
       </td>
       <td>
        返回最后一个元素下一个的位置（头结点）
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/rbegin/" rel="nofollow" title="rbegin">
          rbegin
         </a>
        </p>
       </td>
       <td>
        返回第一个元素的reverse_iterator，及end的位置
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/rend/" rel="nofollow" title="rend">
          rend
         </a>
        </p>
       </td>
       <td>
        返回最后一个元素下一个位置的reverse_iterator，及begin的位置
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-cpp">void PrintList(const list&lt;int&gt;&amp; l)
{
	list&lt;int&gt;::const_iterator it = l.begin();
	while (it != l.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;//迭代器支持++
	}
	cout &lt;&lt; endl;
}

void test_list2()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	list&lt;int&gt; lt(arr, arr + sizeof(arr) / sizeof(int));
	PrintList(lt);
	auto it = lt.rbegin();
	while (it != lt.rend())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;
}
</code></pre>
    <p>
     <img alt="" height="797" src="https://i-blog.csdnimg.cn/direct/974d5bdbe5fb4465bda825bd2ba6d9dd.png" width="949"/>
    </p>
    <h3>
     2.3 list的增删查改
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
        函数说明
       </td>
       <td>
        接口说明
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/empty/" rel="nofollow" title="empty">
          empty
         </a>
        </p>
       </td>
       <td>
        检测list是否为空，是返回ture，否则返回false
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/size/" rel="nofollow" title="size">
          size
         </a>
        </p>
       </td>
       <td>
        返回list中有效节点的个数
       </td>
      </tr>
      <tr>
       <td>
        <a href="https://legacy.cplusplus.com/reference/list/list/front/" rel="nofollow" title="front">
         front
        </a>
       </td>
       <td>
        返回list的第一个节点中值的引用
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/back/" rel="nofollow" title="back">
          back
         </a>
        </p>
       </td>
       <td>
        返回list的最后一个节点中值的引用
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/push_front/" rel="nofollow" title="push_front">
          push_front
         </a>
        </p>
       </td>
       <td>
        在list首元素前插入值为val的元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/pop_front/" rel="nofollow" title="pop_front">
          pop_front
         </a>
        </p>
       </td>
       <td>
        删除list中的第一个元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/emplace_front/" rel="nofollow" title="emplace_front ">
          emplace_front
         </a>
        </p>
       </td>
       <td>
        和push_front类似
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/push_back/" rel="nofollow" title="push_back">
          push_back
         </a>
        </p>
       </td>
       <td>
        在尾部插入值为val的元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/pop_back/" rel="nofollow" title="pop_back">
          pop_back
         </a>
        </p>
       </td>
       <td>
        删除list中最后一个元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/emplace_back/" rel="nofollow" title="emplace_back ">
          emplace_back
         </a>
        </p>
       </td>
       <td>
        和push_back类似（有些情况比push_back高效）
       </td>
      </tr>
      <tr>
       <td>
        <a href="https://legacy.cplusplus.com/reference/list/list/insert/" rel="nofollow" title="insert">
         insert
        </a>
       </td>
       <td>
        在list position 位置中插入值为val的元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/erase/" rel="nofollow" title="erase">
          erase
         </a>
        </p>
       </td>
       <td>
        删除list position 位置的元素（可以返回迭代器）
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/swap/" rel="nofollow" title="swap">
          swap
         </a>
        </p>
       </td>
       <td>
        交换两个list中的元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/resize/" rel="nofollow" title="resize">
          resize
         </a>
        </p>
       </td>
       <td>
        调整list的大小，包含n个元素
       </td>
      </tr>
      <tr>
       <td>
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/clear/" rel="nofollow" title="clear">
          clear
         </a>
        </p>
       </td>
       <td>
        清空list中的有效元素
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-cpp">void test_list3()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	PrintList(lt);

	lt.push_front(5);
	PrintList(lt);

	lt.pop_back();
	lt.pop_front();
	PrintList(lt);

	list&lt;int&gt; lt2;
	lt2.push_back(1);
	lt2.push_back(2);
	lt2.push_back(3);
	lt2.push_back(4);
	lt2.push_back(5);
	lt2.insert(lt2.begin(), 10);
	PrintList(lt2);

	lt2.erase(--lt2.end());
	PrintList(lt2);

}</code></pre>
    <p>
     <img alt="" height="856" src="https://i-blog.csdnimg.cn/direct/19bf8848923744909b48d3296b896f15.png" width="773"/>
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">struct A
{
	A(int a1 = 1,int a2 = 1)
		:_a1(a1)
		,_a2(a2)
	{
		cout &lt;&lt; "A(int a1 = 1,int a2 = 1)" &lt;&lt; endl;
	}

	A(const A&amp; aa)
	{
		_a1 = aa._a1;
		_a2 = aa._a2;
		cout &lt;&lt; "A(const A&amp; aa)" &lt;&lt; endl;
	}

	int _a1;
	int _a2;
};

void test_list4()
{
	list&lt;A&gt; lt;

	A aa(1, 1);
	lt.push_back(aa);
	lt.push_back(A(2, 2));//创建一个临时对象
	//lt.push_back(3, 3);

	lt.emplace_back(aa);
	lt.emplace_back(A(2, 2));
	lt.emplace_back(3, 3);//使用 3 和 3 作为参数调用 A 的构造函数,避免了拷贝构造
}
</code></pre>
    <p>
     <img alt="" height="785" src="https://i-blog.csdnimg.cn/direct/d47713e34c9b4964abdc1c48407ffbe1.png" width="1234"/>
    </p>
    <h3 style="background-color:transparent">
     2.4 list
     <strong>
      Operations
     </strong>
    </h3>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td style="width:73px">
        函数说明
       </td>
       <td style="width:425px">
        接口说明
       </td>
      </tr>
      <tr>
       <td style="width:73px">
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/splice/" rel="nofollow" title="splice">
          splice
         </a>
        </p>
       </td>
       <td style="width:425px">
        <p>
         能够把一个
         <code>
          std::list
         </code>
         中的元素（可以是单个元素、一段连续元素或者全部元素）移动到另一个
         <code>
          std::list
         </code>
         的指定位置。
        </p>
       </td>
      </tr>
      <tr>
       <td style="width:73px">
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/remove/" rel="nofollow" title="remove">
          remove
         </a>
        </p>
       </td>
       <td style="width:425px">
        删除给定值的元素
       </td>
      </tr>
      <tr>
       <td style="width:73px">
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/unique/" rel="nofollow" title="unique">
          unique
         </a>
        </p>
       </td>
       <td style="width:425px">
        删除重复值(前提是有序)
       </td>
      </tr>
      <tr>
       <td style="width:73px">
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/merge/" rel="nofollow" title="merge">
          merge
         </a>
        </p>
       </td>
       <td style="width:425px">
        合并有序列表
       </td>
      </tr>
      <tr>
       <td style="width:73px">
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/sort/" rel="nofollow" title="sort">
          sort
         </a>
        </p>
       </td>
       <td style="width:425px">
        对容器中的元素进行排序
       </td>
      </tr>
      <tr>
       <td style="width:73px">
        <p>
         <a href="https://legacy.cplusplus.com/reference/list/list/reverse/" rel="nofollow" title="reverse">
          reverse
         </a>
        </p>
       </td>
       <td style="width:425px">
        反转元素的顺序
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code class="language-cpp">void test_list5()
{
	std::list&lt;int&gt; mylist1, mylist2;
	std::list&lt;int&gt;::iterator it;

	for (int i = 1; i &lt;= 4; ++i)
		mylist1.push_back(i);      // mylist1: 1 2 3 4

	for (int i = 1; i &lt;= 3; ++i)
		mylist2.push_back(i * 10);   // mylist2: 10 20 30

	it = mylist1.begin();
	++it;                         // points to 2

	mylist1.splice(it, mylist2); // mylist1: 1 10 20 30 2 3 4
								  // mylist2 (empty)  mylist2为空
								  // "it" still points to 2 (the 5th element)

	PrintList(mylist1);

	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 6; ++i)
		lt.push_back(i);

	//把x之后的值翻转
	int x;
	cin &gt;&gt; x;
	it = find(lt.begin(), lt.end(), x);
	if (it != lt.end())
	{
		auto next_it = next(it);//当x是第一个元素时，移动范围从第二个元素开始，防止整个链表被移动，确保哨兵节点指针正确。
		lt.splice(lt.begin(), lt, next_it, lt.end());
	}
	PrintList(lt);

	//删除x
	lt.remove(x);
	PrintList(lt);

}</code></pre>
    <p>
     <img alt="" height="731" src="https://i-blog.csdnimg.cn/direct/9a2b56bd8432459d940084741f37e248.png" width="1827"/>
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">void test_list6()
{
	list&lt;int&gt; first, second;
	first.push_back(2);
	first.push_back(4);
	first.push_back(6);
	second.push_back(1);
	second.push_back(3);
	second.push_back(5);

	first.sort();
	second.sort();

	first.merge(second);
	PrintList(first);

	list&lt;int&gt; lt;
	lt.push_back(5);
	lt.push_back(10);
	lt.push_back(5);
	lt.push_back(4);
	lt.push_back(3);
	lt.push_back(5);
	lt.push_back(12);

	lt.sort();
	lt.unique();
	PrintList(lt);
}
</code></pre>
    <p>
     <img alt="" height="821" src="https://i-blog.csdnimg.cn/direct/686b17b6a42d4e5aa09e7f490b000b75.png" width="644"/>
    </p>
    <h2>
     3 list的模拟实现
    </h2>
    <h3>
     3.1 list的节点
    </h3>
    <pre><code class="language-cpp">template&lt;class T&gt;
	struct list_node
	{
		T _data;
		list_node&lt;T&gt;* _next;
		list_node&lt;T&gt;* _prev;

		list_node(const T&amp; data = T())//构造函数
			:_data(data)
			,_next(nullptr)
			,_prev(nullptr)
		{}
	};</code></pre>
    <p>
    </p>
    <h3>
     3.2 list的迭代器
    </h3>
    <p>
     iterator：
    </p>
    <pre><code class="language-cpp">template&lt;class T&gt;
	struct list_iterator
	{
		typedef list_node&lt;T&gt; Node;
		Node* _node;

		list_iterator(Node* node)
			:_node(node)
		{}

		T&amp; operator*()
		{
			return _node-&gt;_data;
		}

		T* operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}

		list_iterator operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}

		list_iterator operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}

		list_iterator operator++(int)//后置++：必须添加一个 无实际用途的 int 类型占位参数
		{
			list_iterator tmp(*this);
			_node = _node-&gt;_next;
			return tmp;
		}

		list_iterator operator--(int)//后置--
		{
			list_iterator tmp(*this);
			_node = _node-&gt;_prev;
			return tmp;
		}

		bool operator!=(const list_iterator&amp; lt) const
		{
			return _node != lt._node;
		}

		bool operator==(const list_iterator&amp; lt) const
		{
			return _node == lt._node;
		}
	};</code></pre>
    <p>
     const_iterator：
    </p>
    <pre><code class="language-cpp">template&lt;class T&gt;
	struct list_const_iterator
	{
		typedef list_node&lt;T&gt; Node;
		Node* _node;

		list_iterator(Node* node)
			:_node(node)
		{}

		const T&amp; operator*()
		{
			return _node-&gt;_data;
		}

		const T* operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}

		list_iterator operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}

		list_iterator operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}

		list_iterator operator++(int)//后置++：必须添加一个 无实际用途的 int 类型占位参数
		{
			list_iterator tmp(*this);
			_node = _node-&gt;_next;
			return tmp;
		}

		list_iterator operator--(int)//后置--
		{
			list_iterator tmp(*this);
			_node = _node-&gt;_prev;
			return tmp;
		}

		bool operator!=(const list_iterator&amp; lt) const
		{
			return _node != lt._node;
		}

		bool operator==(const list_iterator&amp; lt) const
		{
			return _node == lt._node;
		}
	};</code></pre>
    <p>
     这两个迭代器只有重载operator*和operator-&gt;时有差异所以可以写成一下写法
    </p>
    <pre><code class="language-cpp">template&lt;class T, class Ref, class Ptr&gt;
	struct list_iterator
	{
		typedef list_node&lt;T&gt; Node;
		typedef list_iterator&lt;T, Ref, Ptr&gt; Self;
		Node* _node;

		list_iterator(Node* node)
			:_node(node)
		{}

		Ref operator*()
		{
			return _node-&gt;_data;
		}

		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}

		Self operator++()//前置++
		{
			_node = _node-&gt;_next;
			return *this;
		}

		Self operator--()//前置--
		{
			_node = _node-&gt;_prev;
			return *this;
		}

		Self operator++(int)//后置++：必须添加一个 无实际用途的 int 类型占位参数
		{
			list_iterator tmp(*this);
			_node = _node-&gt;_next;
			return tmp;
		}

		Self operator--(int)//后置--
		{
			list_iterator tmp(*this);
			_node = _node-&gt;_prev;
			return tmp;
		}

		bool operator!=(const list_iterator&amp; lt) const
		{
			return _node != lt._node;
		}

		bool operator==(const list_iterator&amp; lt) const
		{
			return _node == lt._node;
		}
	};</code></pre>
    <p>
     const iterator 是迭代器本身不能改变
    </p>
    <p>
     const_iterator 是指向的内容不能改变
    </p>
    <pre><code class="language-cpp">    struct AA
	{
		int _a1 = 1;
		int _a2 = 1;
	};

    template&lt;class Container&gt;
	void PrintContainer(const Container&amp; con)
	{
		typename Container::const_iterator it = con.begin();
		//auto it = con.begin();
		for (auto&amp; e : con)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}

	void test_list1()
	{
		list&lt;int&gt; lt;
		lt.push_back(1);
		lt.push_back(2);
		lt.push_back(3);
		lt.push_back(4);

		list&lt;int&gt;::iterator it = lt.begin();
		while (it != lt.end())
		{
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		list&lt;AA&gt; la;
		la.push_back(AA());
		la.push_back(AA());
		la.push_back(AA());
		la.push_back(AA());

		list&lt;AA&gt;::iterator ait = la.begin();
		while (ait != la.end())
		{
			cout &lt;&lt; ait-&gt;_a1 &lt;&lt; ":" &lt;&lt; ait-&gt;_a2 &lt;&lt; endl;
			//特殊处理，本来是两个-&gt;才合理，为了可读性省略了一个
			//cout &lt;&lt; ait.operator-&gt;()-&gt;_a1 &lt;&lt; ait.operator-&gt;()-&gt;_a2 &lt;&lt; endl;
			++ait;
		}
		cout &lt;&lt; endl;
	}</code></pre>
    <h3>
     3.2 list
    </h3>
    <pre><code class="language-cpp">template&lt;class T&gt;
	class list
	{
		typedef list_node&lt;T&gt; Node;
	public:

		typedef list_iterator&lt;T, T&amp;, T*&gt; iterator;
		typedef list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;

		iterator begin()
		{
			/*iterator it(_head-&gt;_next);
			return it;*/

			//return iterator(_head-&gt;_next);//

			return _head-&gt;_next;//单参数构造函数支持隐式类型转换
		}

		iterator end()
		{
			return _head;
		}

		const_iterator begin() const
		{
			return _head-&gt;_next;
		}

		const_iterator end() const
		{
			return _head;
		}

		list()
		{
			empty_init();
		}

		void empty_init()
		{
			_head = new Node;
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			_size = 0;
		}

		list(initializer_list&lt;T&gt; lt)
		{
			empty_init();
			for (auto&amp; e : lt)
			{
				push_back(e);
			}
		}

		//l1(l2)
		list(const list&lt;T&gt;&amp; lt)
		{
			empty_init();
			for (auto&amp; e : lt)
			{
				push_back(e);
			}
		}

		list&lt;T&gt;&amp; operator=(list&lt;T&gt;&amp; lt)
		{
			swap(lt);
			return *this;
		}

		~list()
		{
			clear();
			delete _head;
			_head = nullptr;
			_size = 0;
		}

		void clear()
		{
			auto it = begin();
			while (it != end())
			{
				it = erase(it);
			}
		}

		void swap(list&lt;T&gt;&amp; lt)
		{
			std::swap(_head, lt._head);
			std::swap(_size, lt._size);
		}

		iterator insert(iterator pos, const T&amp; x)//在pos位置之前插入
		{
			Node* cur = pos._node;
			Node* newnode = new Node(x);
			Node* prev = cur-&gt;_prev;

			newnode-&gt;_next = cur;
			cur-&gt;_prev = newnode;
			prev-&gt;_next = newnode;
			newnode-&gt;_prev = prev;

			_size++;

			return newnode;
		}

		void push_back(const T&amp; x)
		{
			insert(end(), x);
		}

		void push_front(const T&amp; x)
		{
			insert(begin(), x);
		}

		iterator erase(iterator pos)
		{
			assert(pos != end());
			Node* next = pos._node-&gt;_next;
			Node* prev = pos._node-&gt;_prev;

			prev-&gt;_next = next;
			next-&gt;_prev = prev;
			delete pos._node;

			_size--;

			return next;
		}

		void pop_back()
		{
			erase(--end());
		}

		void pop_front()
		{
			erase(begin());
		}

		size_t size() const
		{
			return _size;
		}

		bool empty() const
		{
			return _size == 0;
		}
	private:
		Node* _head;
		size_t _size;
	};</code></pre>
    <p>
    </p>
    <pre><code class="language-cpp">void test_list2()
	{
		list&lt;int&gt; lt;
		lt.push_back(1);
		lt.push_back(2);
		lt.push_back(3);
		lt.push_back(4);

		list&lt;int&gt;::iterator it = lt.begin();
		lt.insert(it, 10);
		*it += 100;
		PrintContainer(lt);

		it = lt.begin();
		while (it != lt.end())
		{
			if (*it % 2 == 0)
			{
				it = lt.erase(it);
			}
			else
			{
				it++;
			}
		}
		PrintContainer(lt);
	}

	void test_list3()
	{
		list&lt;int&gt; lt;
		lt.push_back(1);
		lt.push_back(2);
		lt.push_back(3);
		lt.push_back(4);

		list&lt;int&gt; lt2(lt);
		PrintContainer(lt);
		PrintContainer(lt2);

		list&lt;int&gt; lt3;
		lt.push_back(10);
		lt.push_back(20);
		lt.push_back(30);
		lt.push_back(40);

		lt = lt3;
		PrintContainer(lt);

		PrintContainer(lt3);
	}

	void func(const list&lt;int&gt;&amp; lt)
	{
		PrintContainer(lt);
	}

	void test_list4()
	{
		//直接构造
		list&lt;int&gt; lt0({ 1,2,3,4,5,6 });
		
		//隐式类型转换
		list&lt;int&gt; lt1 = { 1,2,3,4,5,6,7,8 };
		const list&lt;int&gt;&amp; lt3 = { 1,2,3,4,5,6,7,8 };

		func(lt0);
		func({ 1,2,3,4,5,6 });
		PrintContainer(lt3);

	}</code></pre>
    <h2>
     4 list和vector的比较
    </h2>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
       </td>
       <td>
        vector
       </td>
       <td>
        list
       </td>
      </tr>
      <tr>
       <td>
        底层结构
       </td>
       <td>
        动态顺序表，一段连续的空间
       </td>
       <td>
        带头节点的双向链表
       </td>
      </tr>
      <tr>
       <td>
        随机访问
       </td>
       <td>
        支持随机访问，访问某个元素的效率O(1)
       </td>
       <td>
        不支持随机访问，访问某个元素效率O(N)
       </td>
      </tr>
      <tr>
       <td>
        <p>
         插入和删除
        </p>
       </td>
       <td>
        <div>
         <span style="color:#777777">
          任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)
         </span>
         <span style="color:#777777">
          ，插入时有可能需要增容。
         </span>
        </div>
        <div>
         <span style="color:#777777">
          增容：开辟新空间，拷贝元素，释放旧空间，导致效率更
         </span>
        </div>
        <div>
         <span style="color:#777777">
          低
         </span>
        </div>
       </td>
       <td>
        <div>
         <span style="color:#777777">
          任意位置插入和删除效率高，
         </span>
        </div>
        <div>
         <span style="color:#777777">
          不需要搬移元素，时间复杂度
         </span>
        </div>
        <div>
         <span style="color:#777777">
          为
         </span>
         <span style="color:#777777">
          O(1)
         </span>
        </div>
       </td>
      </tr>
      <tr>
       <td>
        空间利用率
       </td>
       <td>
        底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高
       </td>
       <td>
        底层节点动态开辟，小节点容易造成内存碎片，空间利用率低，缓存利用率低
       </td>
      </tr>
      <tr>
       <td>
        迭代器
       </td>
       <td>
        原生态指针
       </td>
       <td>
        对愿生态节点进行封装
       </td>
      </tr>
      <tr>
       <td>
        迭代器失效
       </td>
       <td>
        在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，导致原来的迭代器失效，删除时，当迭代器需要重新赋值否则会失效
       </td>
       <td>
        插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响
       </td>
      </tr>
      <tr>
       <td>
        使用场景
       </td>
       <td>
        需要高效存储，支持随机访问，不关心插入删除效率
       </td>
       <td>
        大量插入删除操作，不关心随机访问
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38323637363231362f:61727469636c652f64657461696c732f313436313632373035" class_="artid" style="display:none">
 </p>
</div>


