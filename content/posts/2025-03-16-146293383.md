---
layout: post
title: "vulkanscenegraph显示倾斜模型5.3-相机"
date: 2025-03-16 15:01:10 +0800
description: "在Vulkan中，相机的概念并非由API直接提供，而是由应用程序实现。相机的核心功能包括视图变换和投影变换：视图变换将世界坐标系中的物体转换到相机坐标系，投影变换则将相机坐标系中的物体转换到投影空间。在VSG（Vulkan Scene Graph）框架中，vsg::Camera类封装了视图矩阵和投影矩阵，并提供了便捷的接口来管理相机。本章将深入探讨Vulkan中的矩阵变换原理，以及VSG对相机功能的封装与实现。目录2 vsg中的视图变换3 vsg中的投影变换。"
keywords: "vulkanscenegraph显示倾斜模型(5.3)-相机"
categories: ['总结', 'Vulkan']
tags: ['Vulkan', 'Vsg', 'Osg', 'C']
artid: "146293383"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293383
    alt: "vulkanscenegraph显示倾斜模型5.3-相机"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293383
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293383
cover: https://bing.ee123.net/img/rand?artid=146293383
image: https://bing.ee123.net/img/rand?artid=146293383
img: https://bing.ee123.net/img/rand?artid=146293383
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     vulkanscenegraph显示倾斜模型(5.3)-相机
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3 id="osgEarth%20%E7%90%83%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%9C%B0%E5%BD%A2">
     前言
    </h3>
    <p style="text-align:justify">
     在Vulkan中，相机的概念并非由API直接提供，而是由应用程序实现。相机的核心功能包括视图变换和投影变换：视图变换将世界坐标系中的物体转换到相机坐标系，投影变换则将相机坐标系中的物体转换到投影空间。在VSG（Vulkan Scene Graph）框架中，vsg::Camera类封装了视图矩阵和投影矩阵，并提供了便捷的接口来管理相机。本章将深入探讨Vulkan中的矩阵变换原理，以及VSG对相机功能的封装与实现。
    </p>
    <hr/>
    <p>
     目录
    </p>
    <ul>
     <li>
      1 vsg::Camera
     </li>
     <li>
      2 vsg中的视图变换
     </li>
     <li>
      3 vsg中的投影变换
     </li>
    </ul>
    <hr/>
    <h3>
     1 vsg::Camera
    </h3>
    <p>
     本章将参照测试用例(
     <a href="https://mp.csdn.net/mp_blog/creation/editor/144853436" title="写文章-CSDN创作中心">
      写文章-CSDN创作中心
     </a>
     )中的如下代码进行深入探讨。
    </p>
    <pre><code class="language-cpp">	vsg::ComputeBounds computeBounds;
	vsg_scene-&gt;accept(computeBounds);
	vsg::dvec3 centre = (computeBounds.bounds.min + computeBounds.bounds.max)*0.5;
	double radius = vsg::length(computeBounds.bounds.max - computeBounds.bounds.min)*0.6;
	double nearFarRatio = 0.001;

	// set up the camera
	auto lookAt = vsg::LookAt::create(centre + vsg::dvec3(0.0, -radius * 3.5, 0.0), centre, vsg::dvec3(0.0, 0.0, 1.0));
	vsg::ref_ptr&lt;vsg::ProjectionMatrix&gt; perspective;
	if (vsg::ref_ptr&lt;vsg::EllipsoidModel&gt; ellipsoidModel(vsg_scene-&gt;getObject&lt;vsg::EllipsoidModel&gt;("EllipsoidModel")); ellipsoidModel)
	{
		perspective = vsg::EllipsoidPerspective::create(lookAt, ellipsoidModel, 30.0, static_cast&lt;double&gt;(vsg_window-&gt;extent2D().width) / static_cast&lt;double&gt;(vsg_window-&gt;extent2D().height), nearFarRatio, 0.0);
	}
	else
	{
		perspective = vsg::Perspective::create(30.0, static_cast&lt;double&gt;(vsg_window-&gt;extent2D().width) / static_cast&lt;double&gt;(vsg_window-&gt;extent2D().height), nearFarRatio*radius, radius * 4.5);
	}
	auto vsg_camera = vsg::Camera::create(perspective, lookAt, vsg::ViewportState::create(vsg_window-&gt;extent2D()));
</code></pre>
    <p style="text-align:justify">
     上述代码中1-5行，通过vsg::ComputeBounds计算得到场景的包围盒范围，进而计算得到场景中心点和半径，并设置远景裁剪面的比例。接着第7行，计算得到视图矩阵，第8-16行，计算得到投影矩阵。代码17行，由视图矩阵、投影矩阵、视口状态(Viewport)创建vsg::Camera。
    </p>
    <pre><code class="language-cpp">    class VSG_DECLSPEC Camera : public Inherit&lt;Node, Camera&gt;
    {
    public:
        Camera();

        Camera(ref_ptr&lt;ProjectionMatrix&gt; in_projectionMatrix, ref_ptr&lt;ViewMatrix&gt; in_viewMatrix, ref_ptr&lt;ViewportState&gt; in_viewportState = {});

        std::string name;
        ref_ptr&lt;ProjectionMatrix&gt; projectionMatrix;
        ref_ptr&lt;ViewMatrix&gt; viewMatrix;
        ref_ptr&lt;ViewportState&gt; viewportState;

        VkViewport getViewport() const { return viewportState ? viewportState-&gt;getViewport() : VkViewport{}; }
        VkRect2D getRenderArea() const { return viewportState ? viewportState-&gt;getScissor() : VkRect2D{}; }

        void read(Input&amp; input) override;
        void write(Output&amp; output) const override;
    };</code></pre>
    <p style="text-align:justify">
     vsg::Camera类提供了投影矩阵(ref_ptr&lt;ProjectionMatrix&gt;)、视图矩阵(ref_ptr&lt;ViewMatrix&gt;)以及视口设置(ref_otr&lt;ViewportState&gt;)，这些共同控制着View在场景中所观察到的内容。
    </p>
    <h3>
     2 vsg中的视图变换
    </h3>
    <p>
     <img alt="" height="268" src="https://i-blog.csdnimg.cn/direct/2780e2cbf4934652bd15eca88f9c692f.png" width="879"/>
    </p>
    <p style="text-align:justify">
     在vsg中视图相关的矩阵基类为vsg::ViewMatrix，子类有vsg::LookAt、vsg::LookDirection、vsg::RelativeViewMatrix、vsg::TrackingViewMatrix。
    </p>
    <pre><code class="language-cpp">auto lookAt = vsg::LookAt::create(centre + vsg::dvec3(0.0, -radius * 3.5, 0.0), centre, vsg::dvec3(0.0, 0.0, 1.0));</code></pre>
    <pre><code class="language-cpp">          Z (Up)
          |
          |
          |
          +--------&gt; Y
         /
        /
       X</code></pre>
    <p style="text-align:justify">
     其中vsg::LookAt，通过传入eyePosition、centerPositon、upDirection创建。上述代码，eyePosition位于负y轴上，centerPositon为上图的中心点、upDirection为Z轴。因此模型在视口中呈现的状态类似左视图的观察效果。
    </p>
    <p>
     <img alt="" height="287" src="https://i-blog.csdnimg.cn/direct/f8b5119708d64ea4bb361261c134c763.png" width="682"/>
    </p>
    <h3>
     3 vsg中的投影变换
    </h3>
    <p>
     <img alt="" height="283" src="https://i-blog.csdnimg.cn/direct/a294a67ef8df4d5fa68325a9a175ac22.png" width="943"/>
    </p>
    <p style="text-align:justify">
     在vsg中投影相关的矩阵基类为vsg::ProjectionMatrix，相应的子类有vsg::EllipsoidPerspective、vsg::Orthographic、vsg::Perspective、vsg::RelativeProjection。
    </p>
    <p>
     其中vsg::Perspective中的矩阵计算公式如下：
    </p>
    <p>
     <img alt="" height="218" src="https://i-blog.csdnimg.cn/direct/d4ba7d9169a249268bf4252726ecd9ce.png" width="763"/>
    </p>
    <p>
     相比 OpenGL，Vulkan 在投影空间中，x 轴从左到右、y 轴从上向下（与 OpenGL 相反），同时 z 的取值范围为 0 到 1（其中近平面为 0、远平面为 1，而在 OpenGL 中，z 的取值范围为 -1 到 1）。
    </p>
    <p>
     将(0,0,-zNear)、(0,0,-zFar)带入公式，分别计算得到的深度值为1和0，这与vulkan正好相反，这种深度值分布方式被称为 Reversed-Z，是一种常见的深度优化技术。 相应地，VKCompareOp默认取值为VK_COMPARE_OP_GREATER。
    </p>
    <p>
     <img alt="" height="462" src="https://i-blog.csdnimg.cn/direct/c9281fa5e8f246dfbea87eb50cadc39c.png" width="1117"/>
    </p>
    <p>
     在Vulkan中，相机的概念并非由API直接提供，而是由应用程序实现，应用程序中的矩阵可通过vkCmdPushConstants将矩阵直接推送到命令缓冲区，对应的代码如下。
    </p>
    <p>
     <img alt="" height="416" src="https://i-blog.csdnimg.cn/direct/339b6c6f8ace441d8990f3a4a5d2bd65.png" width="1123"/>
    </p>
    <p style="text-align:justify">
     <strong>
      文末
     </strong>
     ：本章在上一篇文章的基础上，进一步深入探讨 Vulkan 中的矩阵变换，重点分析了视图矩阵(View Matrix)和投影矩阵(Projection Matrix)的作用及其数学原理，并详细介绍了 VSG 框架对相机的封装实现——vsg::Camera 类。此外，本章还深入探讨了视图矩阵与投影矩阵的计算公式，对比了 Vulkan 与 OpenGL 在投影空间中的差异，并解释了 VSG 中投影矩阵计算公式的设计考量-ReverseZ。下一章将在本章的基础上，深入探讨 VSG 中的相机操纵器(Camera Manipulator)。相机操纵器的本质是通过用户交互动态修改视图矩阵，从而改变模型在视口中的显示效果。下章将详细分析相机操纵器的工作原理及其实现方式，以更好地理解如何通过交互控制相机状态。
    </p>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f435057574853552f:61727469636c652f64657461696c732f313436323933333833" class_="artid" style="display:none">
 </p>
</div>


