---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f4368656e374368616e2f:61727469636c652f64657461696c732f313436323638363830"
layout: post
title: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—33-å‰ç«¯å®‰å…¨å®è·µæŒ‡å—"
date: 2025-03-14 22:34:43 +08:00
description: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ä¹‹æ—…ç¬¬ä¸‰åä¸‰ç«™"
keywords: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ33ï¼‰--å‰ç«¯å®‰å…¨å®è·µæŒ‡å—"
categories: ['å‰ç«¯å·¥ç¨‹åŒ–ä¸æ¡†æ¶']
tags: ['å®‰å…¨', 'å‰ç«¯']
artid: "146268680"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268680
    alt: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—33-å‰ç«¯å®‰å…¨å®è·µæŒ‡å—"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268680
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268680
cover: https://bing.ee123.net/img/rand?artid=146268680
image: https://bing.ee123.net/img/rand?artid=146268680
img: https://bing.ee123.net/img/rand?artid=146268680
---

# å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ33ï¼‰--å‰ç«¯å®‰å…¨å®è·µæŒ‡å—

## å‰ç«¯å®‰å…¨å®è·µæŒ‡å— ğŸ”’

### å¼•è¨€

å‰ç«¯å®‰å…¨æ˜¯Webåº”ç”¨å¼€å‘ä¸­çš„å…³é”®ç¯èŠ‚ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å‰ç«¯å®‰å…¨å®è·µï¼ŒåŒ…æ‹¬XSSé˜²æŠ¤ã€CSRFé˜²å¾¡ã€å†…å®¹å®‰å…¨ç­–ç•¥ç­‰ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºæ›´å®‰å…¨çš„å‰ç«¯åº”ç”¨ã€‚

### å®‰å…¨æ¦‚è¿°

å‰ç«¯å®‰å…¨ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹æ–¹é¢ï¼š

* **XSSé˜²æŠ¤**
  ï¼šè·¨ç«™è„šæœ¬æ”»å‡»é˜²å¾¡
* **CSRFé˜²å¾¡**
  ï¼šè·¨ç«™è¯·æ±‚ä¼ªé€ é˜²æŠ¤
* **CSPé…ç½®**
  ï¼šå†…å®¹å®‰å…¨ç­–ç•¥
* **æ•°æ®åŠ å¯†**
  ï¼šæ•æ„Ÿä¿¡æ¯ä¿æŠ¤
* **è®¿é—®æ§åˆ¶**
  ï¼šæƒé™ç®¡ç†

### å®‰å…¨å·¥å…·å®ç°

#### å®‰å…¨ç®¡ç†å™¨

```typescript
// å®‰å…¨ç®¡ç†å™¨ç±»
class SecurityManager {
    private static instance: SecurityManager;
    private config: SecurityConfig;
    
    private constructor() {
        this.config = {
            xssFilter: true,
            csrfProtection: true,
            contentSecurityPolicy: true,
            httpsOnly: true,
            maxTokenAge: 3600
        };
        
        this.initialize();
    }
    
    // è·å–å•ä¾‹å®ä¾‹
    static getInstance(): SecurityManager {
        if (!SecurityManager.instance) {
            SecurityManager.instance = new SecurityManager();
        }
        return SecurityManager.instance;
    }
    
    // åˆå§‹åŒ–å®‰å…¨ç®¡ç†å™¨
    private initialize(): void {
        // é…ç½®CSP
        if (this.config.contentSecurityPolicy) {
            this.setupCSP();
        }
        
        // é…ç½®HTTPS
        if (this.config.httpsOnly) {
            this.enforceHTTPS();
        }
        
        // åˆå§‹åŒ–CSRFä¿æŠ¤
        if (this.config.csrfProtection) {
            this.initializeCsrfProtection();
        }
    }
    
    // è®¾ç½®CSP
    private setupCSP(): void {
        const csp = [
            "default-src 'self'",
            "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
            "style-src 'self' 'unsafe-inline'",
            "img-src 'self' data: https:",
            "font-src 'self'",
            "connect-src 'self'",
            "media-src 'self'",
            "object-src 'none'",
            "frame-src 'self'",
            "worker-src 'self' blob:"
        ].join('; ');
        
        const meta = document.createElement('meta');
        meta.httpEquiv = 'Content-Security-Policy';
        meta.content = csp;
        document.head.appendChild(meta);
    }
    
    // å¼ºåˆ¶HTTPS
    private enforceHTTPS(): void {
        if (window.location.protocol === 'http:' && 
            window.location.hostname !== 'localhost') {
            window.location.href = window.location.href.replace(
                'http:', 'https:'
            );
        }
    }
    
    // åˆå§‹åŒ–CSRFä¿æŠ¤
    private initializeCsrfProtection(): void {
        this.setupCsrfToken();
        this.interceptXHR();
        this.interceptFetch();
    }
    
    // è®¾ç½®CSRF Token
    private setupCsrfToken(): void {
        const token = this.generateToken();
        document.cookie = `XSRF-TOKEN=${token}; path=/; secure; samesite=strict`;
        
        const meta = document.createElement('meta');
        meta.name = 'csrf-token';
        meta.content = token;
        document.head.appendChild(meta);
    }
    
    // æ‹¦æˆªXHRè¯·æ±‚
    private interceptXHR(): void {
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;
        const manager = this;
        
        XMLHttpRequest.prototype.open = function(
            method: string,
            url: string,
            ...args: any[]
        ) {
            this._method = method;
            this._url = url;
            originalOpen.apply(this, [method, url, ...args]);
        };
        
        XMLHttpRequest.prototype.send = function(data?: any) {
            if (this._method?.toUpperCase() !== 'GET') {
                const token = manager.getCsrfToken();
                this.setRequestHeader('X-XSRF-TOKEN', token);
            }
            originalSend.call(this, data);
        };
    }
    
    // æ‹¦æˆªFetchè¯·æ±‚
    private interceptFetch(): void {
        const originalFetch = window.fetch;
        const manager = this;
        
        window.fetch = function(
            input: RequestInfo,
            init?: RequestInit
        ): Promise<Response> {
            if (init?.method && init.method.toUpperCase() !== 'GET') {
                const token = manager.getCsrfToken();
                init.headers = {
                    ...init.headers,
                    'X-XSRF-TOKEN': token
                };
            }
            return originalFetch.call(window, input, init);
        };
    }
    
    // ç”ŸæˆToken
    private generateToken(): string {
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        return Array.from(array, byte => 
            byte.toString(16).padStart(2, '0')
        ).join('');
    }
    
    // è·å–CSRF Token
    private getCsrfToken(): string {
        const meta = document.querySelector('meta[name="csrf-token"]');
        return meta?.getAttribute('content') || '';
    }
    
    // XSSè¿‡æ»¤
    sanitizeHTML(html: string): string {
        const div = document.createElement('div');
        div.textContent = html;
        return div.innerHTML;
    }
    
    // éªŒè¯è¾“å…¥
    validateInput(
        input: string,
        pattern: RegExp | string
    ): boolean {
        const regex = typeof pattern === 'string' 
            ? new RegExp(pattern) 
            : pattern;
        return regex.test(input);
    }
    
    // åŠ å¯†æ•°æ®
    async encryptData(
        data: string,
        password: string
    ): Promise<string> {
        const encoder = new TextEncoder();
        const salt = crypto.getRandomValues(new Uint8Array(16));
        
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveBits', 'deriveKey']
        );
        
        const key = await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt,
                iterations: 100000,
                hash: 'SHA-256'
            },
            keyMaterial,
            {
                name: 'AES-GCM',
                length: 256
            },
            false,
            ['encrypt']
        );
        
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encryptedContent = await crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv
            },
            key,
            encoder.encode(data)
        );
        
        const encryptedArray = new Uint8Array(encryptedContent);
        const resultArray = new Uint8Array(
            salt.length + iv.length + encryptedArray.length
        );
        
        resultArray.set(salt, 0);
        resultArray.set(iv, salt.length);
        resultArray.set(encryptedArray, salt.length + iv.length);
        
        return btoa(String.fromCharCode(...resultArray));
    }
    
    // è§£å¯†æ•°æ®
    async decryptData(
        encryptedData: string,
        password: string
    ): Promise<string> {
        const decoder = new TextDecoder();
        const encoder = new TextEncoder();
        const data = Uint8Array.from(
            atob(encryptedData),
            c => c.charCodeAt(0)
        );
        
        const salt = data.slice(0, 16);
        const iv = data.slice(16, 28);
        const content = data.slice(28);
        
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveBits', 'deriveKey']
        );
        
        const key = await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt,
                iterations: 100000,
                hash: 'SHA-256'
            },
            keyMaterial,
            {
                name: 'AES-GCM',
                length: 256
            },
            false,
            ['decrypt']
        );
        
        const decryptedContent = await crypto.subtle.decrypt(
            {
                name: 'AES-GCM',
                iv
            },
            key,
            content
        );
        
        return decoder.decode(decryptedContent);
    }
    
    // ç”Ÿæˆå®‰å…¨çš„éšæœºå€¼
    generateSecureRandom(length: number): string {
        const array = new Uint8Array(length);
        crypto.getRandomValues(array);
        return Array.from(array, byte => 
            byte.toString(16).padStart(2, '0')
        ).join('');
    }
    
    // å“ˆå¸Œå¯†ç 
    async hashPassword(
        password: string,
        salt?: string
    ): Promise<{ hash: string; salt: string }> {
        const encoder = new TextEncoder();
        salt = salt || this.generateSecureRandom(16);
        
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveBits']
        );
        
        const bits = await crypto.subtle.deriveBits(
            {
                name: 'PBKDF2',
                salt: encoder.encode(salt),
                iterations: 100000,
                hash: 'SHA-256'
            },
            keyMaterial,
            256
        );
        
        const hash = Array.from(new Uint8Array(bits), byte =>
            byte.toString(16).padStart(2, '0')
        ).join('');
        
        return { hash, salt };
    }
    
    // éªŒè¯å¯†ç 
    async verifyPassword(
        password: string,
        hash: string,
        salt: string
    ): Promise<boolean> {
        const result = await this.hashPassword(password, salt);
        return result.hash === hash;
    }
}

// æ¥å£å®šä¹‰
interface SecurityConfig {
    xssFilter: boolean;
    csrfProtection: boolean;
    contentSecurityPolicy: boolean;
    httpsOnly: boolean;
    maxTokenAge: number;
}

// ä½¿ç”¨ç¤ºä¾‹
const security = SecurityManager.getInstance();

// XSSé˜²æŠ¤
const userInput = '<script>alert("xss")</script>';
const safeHtml = security.sanitizeHTML(userInput);

// è¾“å…¥éªŒè¯
const email = 'user@example.com';
const isValidEmail = security.validateInput(
    email,
    /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+[a-zA-Z]{2,}$/
);

// æ•°æ®åŠ å¯†
const sensitiveData = 'secret information';
security.encryptData(sensitiveData, 'password123')
    .then(encrypted => {
        console.log('Encrypted:', encrypted);
        return security.decryptData(encrypted, 'password123');
    })
    .then(decrypted => {
        console.log('Decrypted:', decrypted);
    });

// å¯†ç å“ˆå¸Œ
security.hashPassword('myPassword123')
    .then(({ hash, salt }) => {
        console.log('Hash:', hash);
        console.log('Salt:', salt);
        
        return security.verifyPassword('myPassword123', hash, salt);
    })
    .then(isValid => {
        console.log('Password valid:', isValid);
    });

```

#### å®‰å…¨HTTPå®¢æˆ·ç«¯

```typescript
// å®‰å…¨HTTPå®¢æˆ·ç«¯ç±»
class SecureHttpClient {
    private baseUrl: string;
    private security: SecurityManager;
    
    constructor(config: SecureHttpConfig) {
        this.baseUrl = config.baseUrl || '';
        this.security = SecurityManager.getInstance();
    }
    
    // å‘é€GETè¯·æ±‚
    async get<T>(
        url: string,
        config?: RequestConfig
    ): Promise<T> {
        return this.request<T>({
            method: 'GET',
            url,
            ...config
        });
    }
    
    // å‘é€POSTè¯·æ±‚
    async post<T>(
        url: string,
        data?: any,
        config?: RequestConfig
    ): Promise<T> {
        return this.request<T>({
            method: 'POST',
            url,
            data,
            ...config
        });
    }
    
    // å‘é€PUTè¯·æ±‚
    async put<T>(
        url: string,
        data?: any,
        config?: RequestConfig
    ): Promise<T> {
        return this.request<T>({
            method: 'PUT',
            url,
            data,
            ...config
        });
    }
    
    // å‘é€DELETEè¯·æ±‚
    async delete<T>(
        url: string,
        config?: RequestConfig
    ): Promise<T> {
        return this.request<T>({
            method: 'DELETE',
            url,
            ...config
        });
    }
    
    // å‘é€è¯·æ±‚
    private async request<T>(config: RequestConfig): Promise<T> {
        const url = this.baseUrl + config.url;
        
        // æ·»åŠ CSRF Token
        const headers = {
            'Content-Type': 'application/json',
            ...config.headers
        };
        
        if (config.method !== 'GET') {
            const token = document.querySelector(
                'meta[name="csrf-token"]'
            )?.getAttribute('content');
            
            if (token) {
                headers['X-XSRF-TOKEN'] = token;
            }
        }
        
        // åŠ å¯†æ•æ„Ÿæ•°æ®
        let data = config.data;
        if (config.encrypt && data) {
            data = await this.security.encryptData(
                JSON.stringify(data),
                config.encryptKey || ''
            );
        }
        
        try {
            const response = await fetch(url, {
                method: config.method,
                headers,
                body: data ? JSON.stringify(data) : undefined,
                credentials: 'same-origin'
            });
            
            if (!response.ok) {
                throw new Error(response.statusText);
            }
            
            // è§£å¯†å“åº”æ•°æ®
            let result = await response.json();
            if (config.encrypt && result.encrypted) {
                result = JSON.parse(
                    await this.security.decryptData(
                        result.data,
                        config.encryptKey || ''
                    )
                );
            }
            
            return result;
            
        } catch (error) {
            console.error('Request failed:', error);
            throw error;
        }
    }
}

// æ¥å£å®šä¹‰
interface SecureHttpConfig {
    baseUrl?: string;
}

interface RequestConfig {
    method: string;
    url: string;
    data?: any;
    headers?: Record<string, string>;
    encrypt?: boolean;
    encryptKey?: string;
}

// ä½¿ç”¨ç¤ºä¾‹
const http = new SecureHttpClient({
    baseUrl: 'https://api.example.com'
});

// å‘é€æ™®é€šè¯·æ±‚
http.get('/users')
    .then(users => {
        console.log('Users:', users);
    });

// å‘é€åŠ å¯†è¯·æ±‚
http.post(
    '/sensitive-data',
    { secret: 'value' },
    {
        encrypt: true,
        encryptKey: 'secret-key-123'
    }
).then(response => {
    console.log('Response:', response);
});

```

### æœ€ä½³å®è·µä¸å»ºè®®

1. **è¾“å…¥éªŒè¯**

   * å®¢æˆ·ç«¯éªŒè¯
   * æœåŠ¡ç«¯éªŒè¯
   * ç‰¹æ®Šå­—ç¬¦è¿‡æ»¤
   * é•¿åº¦é™åˆ¶
2. **æ•°æ®åŠ å¯†**

   * ä½¿ç”¨HTTPS
   * æ•æ„Ÿæ•°æ®åŠ å¯†
   * å®‰å…¨å¯†é’¥ç®¡ç†
   * å“ˆå¸Œç®—æ³•é€‰æ‹©
3. **è®¿é—®æ§åˆ¶**

   * èº«ä»½è®¤è¯
   * æƒé™éªŒè¯
   * ä¼šè¯ç®¡ç†
   * ä»¤ç‰ŒéªŒè¯
4. **å®‰å…¨é…ç½®**

   * CSPç­–ç•¥
   * Cookieè®¾ç½®
   * é”™è¯¯å¤„ç†
   * æ—¥å¿—è®°å½•

### æ€»ç»“

å‰ç«¯å®‰å…¨éœ€è¦è€ƒè™‘ä»¥ä¸‹æ–¹é¢ï¼š

1. XSSå’ŒCSRFé˜²æŠ¤
2. æ•°æ®åŠ å¯†å’Œä¼ è¾“
3. è®¿é—®æ§åˆ¶å’Œè®¤è¯
4. å®‰å…¨é…ç½®å’Œç›‘æ§
5. æ¼æ´ä¿®å¤å’Œæ›´æ–°

é€šè¿‡å…¨é¢çš„å®‰å…¨å®è·µï¼Œå¯ä»¥æœ‰æ•ˆé™ä½å®‰å…¨é£é™©ã€‚

### å­¦ä¹ èµ„æº

1. OWASPå®‰å…¨æŒ‡å—
2. Webå®‰å…¨æœ€ä½³å®è·µ
3. åŠ å¯†ç®—æ³•æ•™ç¨‹
4. å®‰å…¨æµ‹è¯•å·¥å…·
5. æ¼æ´æ•°æ®åº“

---

å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è—ï¼Œä¹ŸæœŸå¾…åœ¨è¯„è®ºåŒºçœ‹åˆ°ä½ çš„æƒ³æ³•å’Œå»ºè®®ï¼ğŸ‘‡

***ç»ˆèº«å­¦ä¹ ï¼Œå…±åŒæˆé•¿ã€‚***

å’±ä»¬ä¸‹ä¸€æœŸè§

ğŸ’»