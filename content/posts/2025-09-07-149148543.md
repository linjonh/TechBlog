---
layout: post
title: "贪心算法day6"
date: 2025-09-07T14:45:14+0800
description: "【贪心算法】day6：45. 跳跃游戏 II、553. 最优除法、455. 分发饼干"
keywords: "【贪心算法】day6"
categories: ['未分类']
tags: ['贪心算法', '算法', 'Leetcode', 'C']
artid: "149148543"
arturl: "https://blog.csdn.net/tan_run/article/details/149148543"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=149148543
    alt: "贪心算法day6"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=149148543
featuredImagePreview: https://bing.ee123.net/img/rand?artid=149148543
cover: https://bing.ee123.net/img/rand?artid=149148543
image: https://bing.ee123.net/img/rand?artid=149148543
img: https://bing.ee123.net/img/rand?artid=149148543
---



# 【贪心算法】day6



📝前言说明：

* 本专栏主要记录本人的**贪心算法**学习以及LeetCode刷题记录，按专题划分
* 每题主要记录：（1）本人解法 + 本人屎山代码；（2）优质解法 + 优质代码；（3）精益求精，更好的解法和独特的思想（如果有的话）；（4）贪心策略正确性的 “证明”
* 文章中的理解仅为个人理解。如有错误，感谢纠错

> 🎬个人简介：努力学习ing  
>  📋本专栏：[C++刷题专栏](https://blog.csdn.net/tan_run/category_12917016.html)  
>  📋其他专栏：[C语言入门基础](https://blog.csdn.net/tan_run/category_12506809.html)，[python入门基础](https://blog.csdn.net/tan_run/category_12597882.html)，[C++学习笔记](https://blog.csdn.net/tan_run/category_12910423.html)，[Linux](https://blog.csdn.net/tan_run/category_12918758.html)  
>  🎀CSDN主页 [愚润泽](https://blog.csdn.net/tan_run?spm=1010.2135.3001.5421)

**你可以点击下方链接，进行其他贪心算法题目的学习**

| 点击链接 | 开始学习 |
| --- | --- |
| [贪心day1](https://blog.csdn.net/tan_run/article/details/149126061?spm=1011.2415.3001.5331) | [贪心day2](https://blog.csdn.net/tan_run/article/details/149148490?spm=1011.2415.3001.5331) |
| [贪心day3](https://blog.csdn.net/tan_run/article/details/149148503?spm=1011.2415.3001.5331) | [贪心day4](https://blog.csdn.net/tan_run/article/details/149148522?spm=1011.2415.3001.5331) |
| [贪心day5](https://blog.csdn.net/tan_run/article/details/149148529?spm=1011.2415.3001.5331) | [贪心day6](https://blog.csdn.net/tan_run/article/details/149148543?spm=1011.2415.3001.5331) |
| [贪心day7](https://blog.csdn.net/tan_run/article/details/149148551?spm=1011.2415.3001.5331) | [贪心day8](https://blog.csdn.net/tan_run/article/details/149148559?spm=1011.2415.3001.5331) |
| [贪心day9](https://blog.csdn.net/tan_run/article/details/149148568?spm=1011.2415.3001.5331) | [贪心day10](https://blog.csdn.net/tan_run/article/details/149148600?spm=1011.2415.3001.5331) |

**也可以点击下面连接，学习其他算法**

| 点击链接 | 开始学习 |
| --- | --- |
| [优选专题](https://blog.csdn.net/tan_run/category_12948755.html) | [动态规划](https://blog.csdn.net/tan_run/category_12960027.html) |
| [递归、搜索与回溯](https://blog.csdn.net/tan_run/category_12960031.html) | [贪心算法](https://blog.csdn.net/tan_run/category_12960040.html) |

---

## 455. 分发饼干

题目链接：<https://leetcode.cn/problems/assign-cookies/description/>  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f942e94adc7b42ffbf4b91d739337217.png)

### 个人解

思路：

* 从低到高满足

屎山代码：

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) 
    {
        ranges::sort(g); ranges::sort(s);
        int n = g.size(), m = s.size();
        int st = m > n ? m - n: 0;
        int ans = 0;
        for(int i = 0, j = st; j < m; j++) // 遍历每一块饼干
        {
            if(s[j] >= g[i])
            {
                ans++;
                i++; // 下一个孩子
            }
        }
        return ans;
    }
};

```

**时间复杂度：
O
(
n
l
o
g
n
+
m
l
o
g
m
)
O(nlogn + mlogm)
O(nlogn+mlogm)  
 空间复杂度：
O
(
l
o
g
n
+
l
o
g
m
)
O(logn + logm)
O(logn+logm)**

---

## 553. 最优除法

题目链接：<https://leetcode.cn/problems/optimal-division/description/>  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fb966ab88cd747ca9402526d122ccb62.png)

---

### 优质解

思路：

* 我们观察整个表达式，最后一定会化成：`x / y`的形式
* 易知：`第一个数`一定位于分子，`第二个数`一定位于分母
* 只要让分子最大，则得到的结果一定是最大的，即：把其他数都通过加`()`移动至分子（因为题目条件`nums[i] >= 2`）

代码：

```cpp
class Solution {
public:
    string optimalDivision(vector<int>& nums) 
    {
        int n = nums.size();
        if(n == 1) return to_string(nums[0]);
        else if(n == 2) return to_string(nums[0]) + "/" + to_string(nums[1]);
        string ans = to_string(nums[0]) + "/(";
        for(int i = 1; i < n - 1; i++)
            ans += to_string(nums[i]) + "/";
        ans += to_string(nums[n - 1]) + ")";
        return ans;
    }
};

```

---

## 45. 跳跃游戏 II

题目链接：<https://leetcode.cn/problems/jump-game-ii/description/>  
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/95b9c4bb2356400e90ebe6a669e65db7.png)

---

### 优质解

思路：

* 利用动态规划的思想 + 层序遍历
  + 动态规划：依次记录跳跃了多少步
  + 层序遍历：能跳跃到的地方作为下一次的起点，并且在跳跃过程中“剔除”次数多的

代码：

```cpp
class Solution {
public:
    int jump(vector<int>& nums) 
    {
        int n = nums.size();
        int left = 0, right = 0; // 标识该层的首尾位置
        int Maxpos = 0; // 记录下一次能跳跃到的最远位置
        int ans = 0;
        while(Maxpos < n - 1) // 如果已经跳跃到最后的位置了
        {
            for(int i = left; i <= right; i++)
                Maxpos = max(Maxpos, i + nums[i]);
            left = right + 1;
            right = Maxpos;
            ans++;
        }
        return ans;
    }
};

```

**时间复杂度：
O
(
n
)
O(n)
O(n)  
 空间复杂度：
O
(
1
)
O(1)
O(1)**

---

> 🌈我的分享也就到此结束啦🌈  
>  要是我的分享也能对你的学习起到帮助，那简直是太酷啦！  
>  若有不足，还请大家多多指正，我们一起学习交流！  
>  📢公主，王子：点赞👍→收藏⭐→关注🔍  
>  感谢大家的观看和支持！祝大家都能得偿所愿，天天开心！！！



