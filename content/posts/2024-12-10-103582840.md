---
layout: post
title: "Hutool生成的验证码展示在前端,点击刷新实例"
date: 2024-12-10 22:25:56 +0800
description: "这个实例还遇到个有意思的问题，废话不多说，先放前端代码<img src=\"/register/get"
keywords: "hutool返回验证码给前端,前端如何接收"
categories: ['工具']
tags: ['Hutool']
artid: "103582840"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=103582840
    alt: "Hutool生成的验证码展示在前端,点击刷新实例"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=103582840
featuredImagePreview: https://bing.ee123.net/img/rand?artid=103582840
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Hutool生成的验证码展示在前端，点击刷新实例
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     这个实例还遇到个有意思的问题，废话不多说，先放前端代码
    </p>
    <pre class="has"><code>&lt;img src="/register/getAuthCodeImg?count=0" id="authCodeImg" onclick="changeCodeImg(this)"&gt;</code></pre>
    <p>
     <span style="color:#f33b45;">
      <strong>
       src是我请求后台的路径
      </strong>
     </span>
    </p>
    <p>
     JS代码：
    </p>
    <pre class="has"><code> function changeCodeImg(codeImg){
				 codeImg.src = "/register/getAuthCodeImg?count=1&amp;timestamp="+new Date().getTime();
			 }</code></pre>
    <p>
     <span style="color:#f33b45;">
      这里就是那个有意思的问题了，刚开始我没加timestamp，点击验证码刷新的时候只能触发一次，后来了解到 在URL中加时间戳就会保证每一次发起的请求都是一个不同于之前的请求,这样就能避免浏览器对URL的缓存。
     </span>
    </p>
    <blockquote>
     <pre id="best-content-2689963740">URL后面添加随机数通常用于防止客户端（浏览器）缓存页面。 浏览器缓存是基于url进行缓存的，如果页面允许缓存，则在一定时间内（缓存时效时间前）再次访问相同的URL，浏览器就不会再次发送请求到服务器端，而是直接从缓存中获取指定资源。
</pre>
    </blockquote>
    <p>
     Controller
    </p>
    <pre class="has"><code class="language-java"> /**
     * 获取验证码图片
     * @return
     */
    @RequestMapping("/getAuthCodeImg")
    public void  getAuthCodeImg(HttpSession session, HttpServletResponse response, Integer count){

        //定义图形验证码的长和宽  码值个数  干扰圈数
        CircleCaptcha circleCaptcha = CaptchaUtil.createCircleCaptcha(90, 40, 4, 10);
        BufferedImage codeImg = circleCaptcha.getImage();

       if (null != count &amp;&amp; count &gt; 0){
            //重新生成验证码
            circleCaptcha.createCode();
        }
        //String codeImg = lineCaptcha.getImageBase64();
        String authCode = circleCaptcha.getCode();
        if(session.getAttribute("validateCode")!=null){
            session.removeAttribute("validateCode");
            session.setAttribute("validateCode", authCode);
        }else{
            session.setAttribute("validateCode", "请输入验证码");
        }
        ServletOutputStream sos;
        try {
            sos = response.getOutputStream();
            ImageIO.write(codeImg, "jpeg", sos);
            sos.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }</code></pre>
    <p>
     不要忘了在pom.xml中添加依赖
    </p>
    <pre class="has"><code>&lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;5.0.7&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f51696e675875313233342f:61727469636c652f64657461696c732f313033353832383430" class_="artid" style="display:none">
 </p>
</div>


