---
layout: post
title: "docker3-容器与镜像命令"
date: 2025-03-13 19:51:01 +0800
description: "这个就是为容器起一个名称以前是随机起的名称docker run -d --name mynginx1 nginx:1.24.0docker ps这样就可以看到我们起的名字了docker stop mynginx1这个就可以停掉指定名字的容器了，但不是删除这个容器，docker ps -a还是可以看到的这个就是指定容器的hostnamedocker run -it centos:7 bash这个就是交互式运行如果不指定-h就是随机生成的hostnamedocker run -it -h  "
keywords: "docker3-容器与镜像命令"
categories: ['未分类']
tags: ['镜像', '容器', 'Docker']
artid: "146185322"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146185322
    alt: "docker3-容器与镜像命令"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146185322
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146185322
cover: https://bing.ee123.net/img/rand?artid=146185322
image: https://bing.ee123.net/img/rand?artid=146185322
img: https://bing.ee123.net/img/rand?artid=146185322
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     docker3-容器与镜像命令
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_3">
     </a>
     前言
    </h2>
    <h2>
     <a id="_4">
     </a>
     容器命令[部分]
    </h2>
    <h3>
     <a id="docker_run_5">
     </a>
     docker run
    </h3>
    <h3>
     <a id="namenginxlb_7">
     </a>
     –name=“nginx-lb”
    </h3>
    <p>
     这个就是为容器起一个名称
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/af13cd89445a49be8dad5bc5ecb98435.png">
      <br/>
      以前是随机起的名称
      <br/>
      docker run -d --name mynginx1 nginx:1.24.0
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/290976c8aa244a1a9647e0e481886ee4.png">
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f8d72c27f4e4439495685ab8f6ba253f.png">
        <br/>
        docker ps
        <br/>
        这样就可以看到我们起的名字了
       </img>
      </img>
     </img>
    </p>
    <p>
     docker stop mynginx1
     <br/>
     这个就可以停掉指定名字的容器了，但不是删除这个容器，docker ps -a还是可以看到的
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7d7ba935a1784568ba848b790c792251.png"/>
    </p>
    <h3>
     <a id="h_mars_21">
     </a>
     -h “mars”
    </h3>
    <p>
     这个就是指定容器的hostname
     <br/>
     docker run -it centos:7 bash
    </p>
    <p>
     这个就是交互式运行
    </p>
    <p>
     如果不指定-h就是随机生成的hostname
     <br/>
     docker run -it -h mycentos7 centos:7 bash
     <br/>
     放在centos的参数是针对的centos的命令
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0c7a0e77db694880a92d1119002d51d2.png"/>
    </p>
    <p>
     这个就是指定的hostname了
    </p>
    <h3>
     <a id="e_usernameritchie_33">
     </a>
     -e username=“ritchie”
    </h3>
    <p>
     这个就是设置环境变量
    </p>
    <p>
     docker run -it -h mycentos7 -e myenv=test centos:7 bash
     <br/>
     这个表示我们的环境现在是测试环境
     <br/>
     我们用env这个命令检查环境变量
    </p>
    <p>
     env | grep myenv
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/72868485f0974b2cb2295a4e862a09c9.png">
      <br/>
      这个就成功了
      <br/>
      输入env就可以查看所有的环境变量
     </img>
    </p>
    <h3>
     <a id="cpusetcpus02_or_cpusetcpus012_45">
     </a>
     –cpuset-cpus=“0-2” or --cpuset-cpus=“0,1,2”
    </h3>
    <p>
     就是把这个容器绑定到具体的某个核某个cpu去跑
    </p>
    <p>
     docker run -d --name mynginx1 --cpuset-cpus=“0-1” nginx:1.24.0
     <br/>
     这个就是使用0或者1核
    </p>
    <p>
     我们先到另一个shell看看cpu信息
     <br/>
     cat /proc/cpuinfo
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4f27aa50d56543d3939d047e36854516.png">
      <br/>
      这个是运行前cpu的信息
      <br/>
      可以看出cpu单核的
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/603c85aaee994f18903a90e20db5f5e5.png"/>
      <br/>
      我们一运行就会报错
      <br/>
      因为只有一个核
      <br/>
      只能指定一个
      <br/>
      docker run -d --name mynginx1 --cpuset-cpus=“0” nginx:1.24.0
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ad768e33d9164762a0e85a09c3dee755.png"/>
      <br/>
      但是运行又出错了
      <br/>
      因为这个mynginx1的名字已经被其他容器使用了
      <br/>
      docker ps -a
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3ceb7d11a40e4570bbb04cedc2f92aba.png"/>
      <br/>
      所以换个名字
     </img>
    </p>
    <p>
     docker run -d --name mynginx2 --cpuset-cpus=“0” nginx:1.24.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fe6cf42ed6b3453097fd8daf3afd1c6c.png"/>
     <br/>
     这样就可以了
    </p>
    <h3>
     <a id="m_72">
     </a>
     -m
    </h3>
    <p>
     就是容器使用内存的最大值
    </p>
    <p>
     docker run -d --name mynginx3 nginx:1.24.0
     <br/>
     我们先不指定使用内存
     <br/>
     我们用
     <br/>
     docker stats mynginx3
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/33b4876325b64e00aa4accf3f081bfce.png"/>
     <br/>
     可以看出我们最大值为1.93G
     <br/>
     在另一个shell中
     <br/>
     输入
     <br/>
     free -m
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9635b1f96e314c968fb8c786c0e6dbe5.png"/>
     <br/>
     可以看出服务器最大只有1.9G
     <br/>
     所以默认最大的内存就是服务器的使用的内存
     <br/>
     docker run -d --name mynginx4 -m 500m nginx:1.24.0
     <br/>
     这个就是指定只能用500m
     <br/>
     docker stats mynginx4 mynginx3
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7f9c27df184a4204a3d7c38f94de3379.png"/>
     <br/>
     可以看出这个就有区别了
    </p>
    <h3>
     <a id="link_92">
     </a>
     –link=[]
    </h3>
    <p>
     这个就是把一个容器链接到另一个容器
     <br/>
     docker run -it --name mycentos1 centos:7 bash
    </p>
    <p>
     再打开另一个shell
     <br/>
     docker run -it --name mycentos2 --link mycentos1:mywebsite1 centos:7 bash
     <br/>
     这个就是把容器mycentos2 链接到mycentos1，然后取个别名mywebsite1
     <br/>
     这样的话我们就可以在mycentos2 中访问mycentos1的网络了
     <br/>
     我们直接ping mycentos1
     <br/>
     这个指令是测试网络的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7ddad14a38384a99ab6d5710c6f2b7d6.png"/>
     <br/>
     我们也可以ping mywebsite1
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b4c7e22566004a34849ddd654166d85a.png"/>
     <br/>
     mywebsite1 和mycentos1是一样的
     <br/>
     输入cat /etc/hosts
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8dfd0412b3ff4259add5b3bf799970c5.png"/>
     <br/>
     这里就有那个链接的信息
     <br/>
     但是这个链接是单向的
     <br/>
     意思就是
     <br/>
     mycentos1不能pingmycentos2
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fc73da42764f44dea8e76ab315834cf7.png"/>
     <br/>
     cat /etc/hosts输入这个也不会有链接的信息
     <br/>
     不会存储另一个容器的ip
     <br/>
     本质就是在/etc/hosts存储了另一个容器的ip所以才可以链接的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/955aa6e367f04c208ba29052807464e5.png"/>
    </p>
    <h3>
     <a id="rm_118">
     </a>
     –rm
    </h3>
    <p>
     这个就是容器暂停退出的时候自动删除容器
    </p>
    <p>
     docker run -it --name mycentos3 centos:7 bash
     <br/>
     docker ps -a是查看的运行中的容器
     <br/>
     exit只是暂停这个容器的运行
     <br/>
     docker run -it --name mycentos4 --rm centos:7 bash
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4edb5b7790aa469ab2522339c0319804.png"/>
     <br/>
     然后再在另一个容器中输入docker ps -a，能看到mycentos4
     <br/>
     但是我们在mycentos4 里面exit之后，
     <br/>
     再在另一个容器中docker ps -a，就看不到mycentos4 了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a40e3157286b4709930585d116882b10.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/eb7a074a9ddc43d1b3cb379d510818e2.png"/>
     <br/>
     这个就是自动清理容器删除容器了
    </p>
    <h3>
     <a id="docker_ps_135">
     </a>
     docker ps
    </h3>
    <ol start="2">
     <li>
      docker ps
      <br/>
      • 功能
      <br/>
      列出容器
     </li>
    </ol>
    <p>
     • 语法
     <br/>
     docker ps [OPTIONS]
    </p>
    <p>
     • 别名
     <br/>
     docker container ls, docker container list, docker container ps
    </p>
    <p>
     • 关键参数
     <br/>
     ￮ -a :显示所有的容器，包括未运行的。
     <br/>
     ￮ -f :根据条件过滤显示的内容。
     <br/>
     ￮ --format :指定返回值的模板文件。如json或者table
     <br/>
     ￮ -l :显示latest的容器。
     <br/>
     ￮ -n :列出最近创建的n个容器。
     <br/>
     ￮ --no-trunc :不截断输出。
     <br/>
     ￮ -q :静默模式，只显示容器编号。
     <br/>
     ￮ -s :显示总的文件大小。
    </p>
    <p>
     • 样例
     <br/>
     docker ps -a
    </p>
    <h3>
     <a id="f_158">
     </a>
     -f
    </h3>
    <p>
     就是根据docker ps里面的属性列进行过滤
    </p>
    <p>
     docker ps -f name=mynginx4
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e9fe955ab1d74d5d8a9d8ec8b2a330e0.png"/>
    </p>
    <h3>
     <a id="format_163">
     </a>
     –format
    </h3>
    <p>
     可以指定返回的模版
    </p>
    <p>
     docker ps --format json
     <br/>
     默认返回的是表格
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f1cbf9d5e2ac4448ace2c57fdbc1a2d1.png"/>
    </p>
    <h3>
     <a id="l_169">
     </a>
     -l
    </h3>
    <p>
     就是显示最近的那个容器
     <br/>
     docker ps -l
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/16d6b05abbe948a2a2b7a509e7e5634a.png"/>
    </p>
    <h3>
     <a id="n_173">
     </a>
     -n
    </h3>
    <p>
     docker ps -n 2
     <br/>
     就是显示最近的n个容器
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6259f8b69175450aa4cb395e17c3cd0c.png"/>
    </p>
    <h3>
     <a id="notrunc_177">
     </a>
     –no-trunc
    </h3>
    <p>
     就是不截断输出
     <br/>
     比如id不截断
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3d0c79113e274c9bac77d5a7e0517dcd.png"/>
    </p>
    <h3>
     <a id="q_181">
     </a>
     -q
    </h3>
    <p>
     docker ps -q
     <br/>
     就是只返回id
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e522416f6d5241b39a02ac9c22c8664b.png"/>
     <br/>
     还可以与-a配合，就是返回所有容器的id
    </p>
    <h3>
     <a id="s_187">
     </a>
     -s
    </h3>
    <p>
     就是顺便把容器的大小都返回了
    </p>
    <p>
     docker ps -s
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1ee00e023d19497cbe32b7870493322c.png"/>
     <br/>
     最后一列就是大小
    </p>
    <h2>
     <a id="_194">
     </a>
     实战
    </h2>
    <h2>
     <a id="nginx_196">
     </a>
     搭建一个nginx服务
    </h2>
    <h3>
     <a id="nginx_197">
     </a>
     查找nginx镜像
    </h3>
    <p>
     docker search nginx
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/968edecb85814c3183a00b85407b775d.png"/>
     <br/>
     但是一般还是在docker.hub官网上去找
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/767b57a7b3474049b1cc8d85dabbb590.png"/>
     <br/>
     选取镜像的时候还是要去选取上面的已认证的镜像
     <br/>
     然后看tags那边
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8042d359b2014ecbac8b77d4b5a7ff5d.png"/>
     <br/>
     选取镜像
     <br/>
     第二步就是拉取镜像了
     <br/>
     docker pull nginx:1.24.0
     <br/>
     我们如何验证拉取过来了没呢
     <br/>
     docker images nginx
     <br/>
     这个是把nginx过滤来查看
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/708fb0f797494406af3fc85eecdc10e6.png"/>
     <br/>
     我们如何看一个镜像的详细信息呢
     <br/>
     docker image inspect nginx:1.24.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1121d79d58e0441dbf725645184e7a65.png"/>
     <br/>
     我们看出ExposePorts暴露的是80的tcp端口
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/cd4b84924f934e13961fcf20b90011c2.png"/>
     <br/>
     我们还可以看出启动命令
    </p>
    <h3>
     <a id="_220">
     </a>
     启动镜像，修改首页
    </h3>
    <p>
     docker run -p 80:80 --name myweb2 -h myweb1.cm -e myenv=test nginx:1.24.0
     <br/>
     一运行
     <br/>
     但是Ubuntu上的服务器上已经布置了一个80端口了
     <br/>
     docker run -p 8099:80 --name myweb2 -h myweb1.cm -e myenv=test nginx:1.24.0
    </p>
    <p>
     但是这样又错了
     <br/>
     为什么呢，因为上一次已经创建了容器myweb2 ，只不过创建失败了，但是名字已经被占用了
    </p>
    <p>
     docker run -p 8099:80 --name myweb3 -h myweb1.cm -e myenv=test nginx:1.24.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c1b1fdd8e7384114af1691b726f64d23.png"/>
     <br/>
     这个就是nginx的启动信息
     <br/>
     打印出来了这个，就说明了我们是在前台运行的
     <br/>
     因为没有-d，这个就只能看看，什么都干不了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e8d23588e6604db0961b0abcc2b51915.png"/>
     <br/>
     这样就可以了
     <br/>
     如果我们ctrl+c或者关掉了shell
     <br/>
     就停止了这个容器了
     <br/>
     所以我们要后台运行
     <br/>
     docker run -p 8099:80 --name myweb4 -h myweb1.cm -e myenv=test -d nginx:1.24.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ec584f8371eb49dea4b7cc7368c413ae.png"/>
     <br/>
     这样就成功了
     <br/>
     ctrl+c也没用了
    </p>
    <p>
     现在开始改首页
     <br/>
     —》要交互运行才可以，因为要在里面搞事情，修改东西
    </p>
    <p>
     docker run -p 8100:80 --name myweb6 -h myweb1.cm -e myenv=test -it nginx:1.24.0 bash
     <br/>
     -it对应就有一个bash在后面，为什么要添加bash呢，添加bash的目的就是能够使用ll这种命令
     <br/>
     然后就是要改名字，改端口
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/073a5cbe264c42c98fc1d4b42b4aa76f.png"/>
     <br/>
     这样我们就进去了
    </p>
    <p>
     我们进入了nginx的交互，进入了这个nginx容器里面
     <br/>
     ，但是nginx并没有启动的，我们还要手动启动才可以，但是后台运行的话，就不用我们来手动启动了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8240b03e5d6c488c9476d2c23a044706.png"/>
     <br/>
     这样我们的nginx就启动起来了
     <br/>
     这样我们访问8100端口就可以访问里面的nginx的默认页面了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f32ef482af0d49e8bd8803bb0340ea2f.png"/>
     <br/>
     我们可以进入这个nginx的默认页面
     <br/>
     就在nginx容器里面进入nginx的默认页面
     <br/>
     cd /usr/share/nginx/html/
     <br/>
     这里面有一个index.html
     <br/>
     的页面
     <br/>
     修改它就可以修改默认显示的页面了
    </p>
    <p>
     直接输入echo “hello nginx docker” &gt; index.html
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/86ab94b0129048fbb7bb8cbe99cdc06a.png"/>
     <br/>
     这样的话，里面的内容就变成这一句话了，这个是因为echo是覆盖性的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/72c2a430c9e1421c9f60327f34a230d6.png"/>
     <br/>
     但是我们还没有学习怎么在后台运行，然后进入这个容器，修改这个容器的内容
    </p>
    <h2>
     <a id="Docker_hub_273">
     </a>
     Docker hub上创建自己私有仓库
    </h2>
    <h3>
     <a id="Busybox_275">
     </a>
     Busybox
    </h3>
    <p>
     BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件。BusyBox 包含了一
     <br/>
     些简单的工具，例如ls、cat和echo等等，还包含了一些更大、更复杂的工具，例
     <br/>
     grep、find、mount以及telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀。
     <br/>
     简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令，也
     <br/>
     包含了 Linux 系统的自带的shell。busybox是一个集成了一百多个最常用linux命令和
     <br/>
     工具的软件,他甚至还集成了一个http服务器和一个telnet服务器,而所有这一切功能却
     <br/>
     只有区区1M左右的大小.因海外带宽较小，我们拉取该镜像推送到自己的仓库。
    </p>
    <p>
     意思就是我们拿进去这个Busybox的命令，那么那些简简单单的rz命令我们都不用下载了，原生是没有的，需要下载，而且这个大小很小，推仓库很快
    </p>
    <h3>
     <a id="Busybox_287">
     </a>
     安装Busybox
    </h3>
    <p>
     我们直接敲busybox
     <br/>
     就知道我们有没有busybox了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/385a597f3eb44b10aa18fd461e6c9c9d.png"/>
     <br/>
     然后开始卸载
     <br/>
     apt --purge autoremove busybox
    </p>
    <p>
     然后就是安装
     <br/>
     apt install busybox -y
    </p>
    <p>
     安装和卸载都比较慢
     <br/>
     我们输入busybox检查一下
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3758e793aaf44e089bef38ce103949b8.png"/>
     <br/>
     可以正常运行就可以了
     <br/>
     这样我们就可以使用busybox来使用它里面的指令了
    </p>
    <p>
     比如
     <br/>
     busybox ls /
     <br/>
     查找根目录
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0489c15d7c274bed94d35f7b5eeaff02.png"/>
     <br/>
     busybox ping www.baidu.com
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/28aff52527fe4ee68536a859823eac1d.png"/>
     <br/>
     这些命令都是可以正常运行的
    </p>
    <p>
     输入which busybox
     <br/>
     就可以知道安装在哪里了
    </p>
    <p>
     ls -lh /usr/bin/busybox
     <br/>
     这样加了-h就知道大小了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d4e91c3868bf4508ab9f56883135bd49.png"/>
     <br/>
     发现才七百多k
    </p>
    <h3>
     <a id="_322">
     </a>
     创建仓库
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a109204acbd54c8997682844178a9653.png"/>
     <br/>
     要创建仓库的话，首先要在docker.hub上有一个账号才可以
     <br/>
     但是有两个问题
     <br/>
     第一这是海外的，我们要网络加速才可以
     <br/>
     第二就是，我们的QQ邮箱是国内的邮箱，国外无法发邮箱信息过来
     <br/>
     所以我们注册不了
     <br/>
     当然也创建不了账号
     <br/>
     所以得换国内的仓库了
     <br/>
     我们可以拉取一下busybox
     <br/>
     docker pull busybox:1.36.0
    </p>
    <h2>
     <a id="_336">
     </a>
     综合实战三、腾讯云创建自己的私有仓库
    </h2>
    <h3>
     <a id="_338">
     </a>
     创建腾讯云账号
    </h3>
    <p>
     <a href="https://cloud.tencent.com/" rel="nofollow">
      官网
     </a>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4537b0e4ee454403975bbe5b2929fd96.png"/>
     <br/>
     点击右上角的注册就可以了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2e8b8637e28b43acb00897f283f7fc00.png"/>
     <br/>
     然后我们搜索容器镜像服务
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1e7e15d4f84340cab7f82ab7a05f46fe.png"/>
     <br/>
     点击立即选购
    </p>
    <p>
     这个是要钱的
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/332175942ddd4b90876b8592eb349cc9.png"/>
    </p>
    <p>
     买了就会进去这个页面
     <br/>
     点击镜像仓库
     <br/>
     新建那里就可以建造仓库了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/496e0bcb1b0c4fee9843c4980409619b.png"/>
     <br/>
     创建的时候它要一个命令空间
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/da22b85433ce4742b6d23f57756150c9.png"/>
     <br/>
     点击命名空间这里进行命名
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/99dee3591cbf4ef5b026eb924716befc.png"/>
     <br/>
     现在就可以创建镜像仓库了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/34ddc73988ec44c580df41a5756d7815.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/eae6e9fc952c4f72b7e7fa2c2d2b4bc0.png"/>
    </p>
    <p>
     这样就创建好了
     <br/>
     点击快捷指令
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8a03c65c8fd04a168246710b288e8c07.png"/>
     <br/>
     这里就给出了命令
    </p>
    <p>
     我们推送镜像之前先登录
     <br/>
     直接复制上面图片的命令就可以了
    </p>
    <p>
     docker login ccr.ccs.tencentyun.com --username=100014125284
     <br/>
     然后输入密码
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f2928b2ea73546a4a3a5827c7002babe.png"/>
     <br/>
     然后就是打tag，打标签
     <br/>
     也是复制
     <br/>
     docker tag busybox:1.36.0 ccr.ccs.tencentyun.com/maxhou6/busyboxbymaxhou:v1.0
    </p>
    <p>
     或者用id来tag都是可以的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/19e64fb05e5e490f953cfedc97f334c6.png"/>
     <br/>
     我们在看一下效果
     <br/>
     dicker images | grep busybox
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/43700f6478c8436fa1fe63c458d885a1.png"/>
     <br/>
     这样就有1.0和2.0的tag了
     <br/>
     其实id都是一样的
    </p>
    <p>
     然后就是推送了
    </p>
    <p>
     docker push ccr.ccs.tencentyun.com/maxhou6/busyboxbymaxhou:v1.0
     <br/>
     这样就可以了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3cb311b599cb491c9f57baccf6e1858d.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e1009440d5dd4b59b74fc719453bffd5.png"/>
     <br/>
     还有就是tag重复的，只会push成功一个
     <br/>
     并不会全部一样的都push上去，
     <br/>
     docker push ccr.ccs.tencentyun.com/maxhou6/busyboxbymaxhou -a
     <br/>
     -a就是把 tag为ccr.ccs.tencentyun.com/maxhou6/busyboxbymaxhou全部push上去
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1815c842e7dd46fd91dddf7570f6ddaf.png"/>
     <br/>
     看前台我们就看到了，三个不同的tag都push上去了
     <br/>
     我们如何拉取呢
    </p>
    <p>
     docker pull ccr.ccs.tencentyun.com/maxhou6/busyboxbymaxhou:v1.0
     <br/>
     这样就可以拉取下来了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fcdda2fd3efc43e58060774504e94059.png"/>
     <br/>
     然后就是登出了
    </p>
    <p>
     docker logout ccr.ccs.tencentyun.com
     <br/>
     v1.0是tag
     <br/>
     busyboxbymaxhou是仓库名称
     <br/>
     maxhou6是命名空间的名称
     <br/>
     ccr.ccs.tencentyun.com是镜像仓库统一的对外的地址
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/be1a67ec5e3745f5888bc0fbca8836d1.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0dce24c5c222451b88a84dd92a4c0f26.png"/>
    </p>
    <p>
     登出之后就不能push和pull了
     <br/>
     不能pull是因为这个镜像是一个私有的镜像
    </p>
    <h2>
     <a id="_420">
     </a>
     阿里云创建自己的私有仓库
    </h2>
    <p>
     <a href="https://www.aliyun.com/" rel="nofollow">
      官网
     </a>
    </p>
    <p>
     还是搜索容器镜像服务
    </p>
    <p>
     这个比腾讯云的好，因为有个人版的，不要钱，腾讯云没有个人版，它的个人版用不了了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/40447d9b2a0549389bc121edc4fe000b.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e981d79a4aff4ea081caa1bb0b6caa94.png"/>
     <br/>
     这里可以设置docker登录的密码
     <br/>
     创建镜像仓库之前，先创建命名空间
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/cc851233fa964b89a1625036352a180d.png"/>
     <br/>
     然后就是创建镜像仓库
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8544332fc0054d32b34b4e35f0e8d446.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/84a836e99d7d4c19b5f5c7556e17414a.png"/>
     <br/>
     代码源我们选取本地仓库就可以了
    </p>
    <p>
     本地仓库就是通过docker push和docker pull来操作
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6166f2e16fd3483bbe55f4cbdc21ed03.png"/>
    </p>
    <p>
     而且命令阿里云都提供好了
     <br/>
     docker images busybox确保本地有镜像
    </p>
    <p>
     登录去复制然后输入密码
     <br/>
     然后就是打tag
     <br/>
     docker images | grep busybox过滤查看
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7adedf9f74aa4a8a86ff081ee6901316.png"/>
     <br/>
     然后push还是复制，但是tag不能复制
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/72f58a593994403093670821c11fe2c7.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/79f923d34a964708a0224e6696bcf52c.png"/>
     <br/>
     我们多打几个tag
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2816f52cbf3047048b219403fac43ed5.png"/>
     <br/>
     然后-a就是一起push
     <br/>
     就都进去了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/708b0973576a442d9683d4c13d6548db.png"/>
     <br/>
     退出来也是一样的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/79f82365037c4b89888d3cff577b0f6f.png"/>
     <br/>
     拉取的命令也是复制
     <br/>
     这个不需要登录，如果我们的镜像是公开的话
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/81cb8ee5e2e643b6a750233587cf9671.png"/>
     <br/>
     这样就完成了
     <br/>
     没有登录当然就不能push了
    </p>
    <h2>
     <a id="Docker_Image_466">
     </a>
     Docker Image（镜像）
    </h2>
    <h3>
     <a id="Docker__467">
     </a>
     Docker 镜像是什么
    </h3>
    <p>
     Docker image本质上是一个 read-only 只读文件， 这个文件包含了文件系统、
     <br/>
     源码、库文件、依赖、工具等一些运行application所必须的文件。
     <br/>
     • 我们可以把Docker image理解成一个模板或者类， 可以通过这个模板实例化出来很多
     <br/>
     容器。
     <br/>
     • image 里面是一层层文件系统Union FS。联合文件系统，可以将几层目录挂载到
     <br/>
     一起，形成一个虚拟文件系统。
     <br/>
     每一层文件系统我们叫做一层 layer，联合文件系统可以对每一层文件系统设置三
     <br/>
     种权限，只读（readonly）、读写（readwrite）和写出（whiteout-able），但是 docker
     <br/>
     镜像中每一层文件系统都是只读的。
     <br/>
     构建镜像的时候，从一个最基本的操作系统开始，每个构建的操作都相当于做一层
     <br/>
     的修改，增加了一层文件系统。一层层往上叠加，上层的修改会覆盖底层该位置的可
     <br/>
     见性，这也很容易理解，就像上层把底层遮住了一样。当你使用的时候，你只会看到
     <br/>
     一个完全的整体，你不知道里面有几层，也不清楚每一层所做的修改是什么。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ded581f37c17431a838952cf71b4617b.png"/>
     <br/>
     镜像可以弄java也可以是c++
    </p>
    <h3>
     <a id="_483">
     </a>
     为什么需要镜像
    </h3>
    <p>
     在部署应用时，通过手工或写一些脚本的方式进行部署。这样部署面临问题就是云端
     <br/>
     和本地环境一致问题。用户为每个应用打包过程比较繁琐，需要配置和给中修改等操
     <br/>
     作，非常费劲。
     <br/>
     然而，Docker 镜像就是为了解决这个小小的打包功能，突然一夜之间成名。那么，你
     <br/>
     可能说 Docker 镜像就是个压缩包，是的，你猜对了，它就像一个压缩包文件。它是如
     <br/>
     何解决 Paas 时代所面临的云端和本地一致性问题？很简单，它是把一个镜像制作成
     <br/>
     一个完整的操作系统所有文件和对应的目录结构，这样的压缩包是跟你本地和测试环
     <br/>
     境用的操作系统一摸一样。
     <br/>
     docker 最大的贡献就是定义了容器镜像的分层的存储格式，docker镜像技术的基础
     <br/>
     是联合文件系统(UnionFS)，其文件系统是分层的。这样既可以充分利用共享层，又可
     <br/>
     以减少存储空间占用。
     <br/>
     docker 镜像提供了一种打包应用程序和预配置服务器环境的便捷方式，可以很方便的
     <br/>
     将其用于个人用途或与其他 Docker 用户公开共享
     <br/>
     把jdk那些东西一起打包好的东西
     <br/>
     dockefile：docker镜像制作的标准
     <br/>
     而且镜像只需要存一份，就可以镜像出很多份
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a50e02aca66c4e73b7d3dbae4843462d.png"/>
     <br/>
     镜像存过来的时候，就不会把centos存两份，因为是分层的
    </p>
    <p>
     底层的东西已经有了的话，就只需要pull最上面的东西就可以了，这就是镜像分层的好处，节省了存储空间，直到找到不一样的层为止，就可以pull了
     <br/>
     所有镜像层数越深，浪费时间越多
    </p>
    <h3>
     <a id="_505">
     </a>
     镜像命令详解
    </h3>
    <p>
     这个是docker的命令，所以用ubuntu和centos是没有区别的
    </p>
    <ol>
     <li>
      镜像命令清单
      <br/>
      docker images
      <br/>
      docker image
      <br/>
      ls/docker
      <br/>
      image list
      <br/>
      列出本地镜像
     </li>
    </ol>
    <p>
     docker tag
     <br/>
     docker image tag
     <br/>
     给镜像打标签，
     <br/>
     可用于推送镜像
     <br/>
     仓库
    </p>
    <p>
     docker pull
     <br/>
     docker image pull
     <br/>
     从镜像仓库拉取
     <br/>
     镜像
     <br/>
     和镜像仓库命令相同，也可以
     <br/>
     归类为镜像操作命令,必须掌
     <br/>
     握，参考镜像命令此处不赘述
    </p>
    <p>
     docker push
     <br/>
     docker image push
     <br/>
     推送镜像到仓库 和镜像仓库命令相同，也可以
     <br/>
     归类为镜像操作命令必须掌
     <br/>
     握，参考镜像命令此处不赘述
    </p>
    <p>
     docker rmi
     <br/>
     docker image rm/ docker
     <br/>
     image remove
     <br/>
     删除本地镜像
    </p>
    <p>
     docker build
     <br/>
     docker image build
     <br/>
     通过dockerfile制作镜像
    </p>
    <p>
     docker save
     <br/>
     docker image save
     <br/>
     将指定镜像保存
     <br/>
     成 tar 归档文件
    </p>
    <p>
     docker load
     <br/>
     docker image load
     <br/>
     导入使用
     <br/>
     docker save 命
     <br/>
     令导出的镜像
    </p>
    <p>
     docker image inspect
     <br/>
     查看镜像详细信息
    </p>
    <p>
     docker history
     <br/>
     docker image history
     <br/>
     查看镜像历史
    </p>
    <p>
     docker import
     <br/>
     docker image import
     <br/>
     从归档文件
     <br/>
     docker export
     <br/>
     中创建镜像。
    </p>
    <p>
     docker image prune
     <br/>
     删除不使用的镜像
    </p>
    <h3>
     <a id="docker_rmi_572">
     </a>
     docker rmi
    </h3>
    <p>
     功能
     <br/>
     删除本地镜像。
    </p>
    <p>
     • 语法
     <br/>
     docker rmi [OPTIONS] IMAGE [IMAGE…]
     <br/>
     IMAGE [IMAGE…] 这个表示我们可以一次或者删除多个镜像
    </p>
    <p>
     • 别名
     <br/>
     docker image rm, docker image remove
    </p>
    <p>
     • 关键参数
     <br/>
     ￮ -f :强制删除；
     <br/>
     ￮ --no-prune :不移除该镜像的过程镜像，默认移除；
     <br/>
     这两个参数一般不用
    </p>
    <p>
     docker images busybox
     <br/>
     删除的话第一中可以通过id来删除
     <br/>
     docker rmi imageId
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/558e86e6cf2d43a18688b6e45c239e09.png"/>
     <br/>
     这个删除指令显示后面的意思就是，我们先删除了标签，然后就是删除
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/172237f2c17245589ff0c9616e981f19.png"/>
     <br/>
     这样就删除了
    </p>
    <p>
     我们还可以通过名字+tag删除
    </p>
    <p>
     docker rmi busybox:1.35.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/768b3c15e5474e4eb6031c74d6e21d86.png"/>
     <br/>
     但是如果这个镜像被引用了，也就是被run起来了，生成了·容器，这样的话是不能删除镜像的
    </p>
    <p>
     docker run -it --name mybusybox busybox:1.35.0 sh
     <br/>
     如果没有这个镜像会先pull，后面的sh的意思就是进入这个容器的shell
     <br/>
     和centos的后面的bash是一样的效果
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d326e3467a43448b9aab12e82eb2c847.png"/>
    </p>
    <p>
     docker ps -a | grep mybusybox
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b85f3002963d469d956d0e422081d471.png"/>
     <br/>
     也是可以正常退出的
     <br/>
     但是这个时候，这个容器对应的镜像就不能删除了
    </p>
    <p>
     docker rmi busybox:1.35.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d5fd3efd01c54b87838588b728cd7754.png"/>
     <br/>
     因为生成了一个容器，也就是对象，那你怎么能删除类呢
     <br/>
     接下来我们就只能强制删除了
     <br/>
     -f，
     <br/>
     就是不管有没有容器都删除镜像
     <br/>
     docker rmi -f busybox:1.35.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4341d5926fae4d59b79900d1a86c8a4b.png"/>
     <br/>
     正常的话不要这样删除
     <br/>
     我们要先删除容器
    </p>
    <p>
     rm就是删除容器的意思，i就是image的意思
     <br/>
     docker rm 容器id
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9c4da56003be47d1a76c6a23b53e4eb2.png"/>
     <br/>
     然后再删镜像
     <br/>
     正常删镜像时会报err，err里面有对应容器的id
    </p>
    <p>
     我们直接docker ps -a | grep busybox:1.35.0
     <br/>
     就可以看到所有使用这个镜像的容器了
     <br/>
     然后删除就可以了
     <br/>
     最后就是删除镜像了
     <br/>
     docker rmi busybox:1.35.0
    </p>
    <h3>
     <a id="docker_save_638">
     </a>
     docker save
    </h3>
    <p>
     功能
     <br/>
     将指定镜像保存成 tar 归档文件。
     <br/>
     因为镜像是一个文件系统，他就是把镜像打包成一个tar文件
    </p>
    <p>
     • 语法
     <br/>
     docker save [OPTIONS] IMAGE [IMAGE…]
     <br/>
     [IMAGE…]表示我们一次可以打包多个
    </p>
    <p>
     • 别名
     <br/>
     docker image save
     <br/>
     • 关键参数
     <br/>
     ￮ -o :输出到的文件。
    </p>
    <p>
     先创建一个个人的目录
     <br/>
     mkdir -p /data/maxhou
     <br/>
     然后进去
     <br/>
     docker images busybox
    </p>
    <p>
     docker save -o mybusybox1.tar busybox:1.36.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9a82d89daf8141a0961d43529d8115fc.png"/>
     <br/>
     然后我们还可以保存多个文件
     <br/>
     docker save -o mybusybox2.tar busybox:1.36.0 busybox:1.34.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/dde292a9dd5f49b4882ccc1d1cf1b4d1.png"/>
     <br/>
     ll -h就可以看大小了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8c0e7c62a21548a0901509865eafa1a1.png"/>
    </p>
    <p>
     而且镜像也不会消失的，就算打了包
    </p>
    <h3>
     <a id="docker_load_668">
     </a>
     docker load
    </h3>
    <p>
     功能
     <br/>
     导入使用 docker save 命令导出的镜像。
     <br/>
     • 语法
     <br/>
     docker load [OPTIONS]
     <br/>
     • 别名
     <br/>
     docker image load
     <br/>
     • 关键参数
     <br/>
     ￮ --input , -i : 指定导入的文件，代替 STDIN。
     <br/>
     ￮ --quiet , -q : 精简输出信息。
    </p>
    <p>
     我们导入这两个tar包的话
     <br/>
     要先删除原来的镜像，不然效果不明显
     <br/>
     dockerr rmi busybox:1.36.0 busybox:1.34.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/31eadca519964f1c85fe5a15f41523d2.png"/>
    </p>
    <p>
     然后就是加载了
     <br/>
     docker load -i mybusybox2.tar
     <br/>
     这样就会加载出两个镜像了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f4d55877907244dc90d254fe6e74b98e.png"/>
    </p>
    <p>
     然后又删除这两个镜像
     <br/>
     开始用-q
    </p>
    <p>
     docker load -i mybusybox2.tar -q
     <br/>
     这个就是安静模式加载，意思就是不会显示出额外没用的信息，没用进度条了
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/407805a43f6e469487e91c107a3f8e91.png"/>
    </p>
    <h3>
     <a id="docker_history_697">
     </a>
     docker history
    </h3>
    <p>
     功能
     <br/>
     显示镜像历史。 就是看镜像每层都是怎么盖上去的
     <br/>
     • 语法
     <br/>
     docker history [OPTIONS] IMAGE
     <br/>
     • 别名
     <br/>
     docker image history
     <br/>
     • 关键参数
     <br/>
     ￮ -H , --human :大小和日期采用人容易读的格式展现 ，这个是默认的开启
     <br/>
     ￮ --no-trunc :显示全部信息，不要隔断； --》不隔断的话会很难看，很乱
     <br/>
     ￮ -q, --quiet: 只显示镜像id信息；
    </p>
    <p>
     docker history busybox:1.36.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/06fb4511fe6d4019a6c6669ed2f50d7e.png"/>
     <br/>
     看的出来就盖了两层
     <br/>
     第一列id
     <br/>
     第二列创建时间
     <br/>
     第三列创建命令
     <br/>
     四列是大小
     <br/>
     最后一列是注释
    </p>
    <p>
     docker history nginx:1.24.0 -q
     <br/>
     只显示id
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/df97b57a4e2a4e45a0576430f26a790c.png"/>
    </p>
    <h3>
     <a id="docker_image_prune_722">
     </a>
     docker image prune
    </h3>
    <p>
     功能
     <br/>
     删除不使用的镜像。 —》第一容器没有使用的镜像，但是很危险，因为后面可能还会用，第二就是空悬镜像，就是这个镜像的某个层不被任何镜像使用
     <br/>
     • 语法
     <br/>
     docker image prune [OPTIONS]
     <br/>
     • 关键参数
     <br/>
     ￮ -a , --all : 删除全部不使用的镜像；
     <br/>
     ￮ --filter filter:指定过滤条件； —》时间过滤或者标签过滤
     <br/>
     ￮ -f, --force :不提示是否删除；
    </p>
    <p>
     docker image prune
     <br/>
     它会警告说这个会删除空悬镜像
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b1cf90ad22e742cb8c54cd6ea0623ec0.png"/>
     <br/>
     docker image prune -a
     <br/>
     会警告删除没有使用容器的镜像—》危险
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/39e085672acc4d048a5f8f175e74915d.png"/>
    </p>
    <h2>
     <a id="_741">
     </a>
     镜像操作案例
    </h2>
    <p>
     通过busybox查看一个容器和启动ip，然后就是删除镜像
    </p>
    <h3>
     <a id="__743">
     </a>
     查找镜像 下载镜像
    </h3>
    <p>
     docker search busybox
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/498907af240c4b6bbe202736917e279a.png"/>
     <br/>
     但是我们这个没有tag就是没有版本
     <br/>
     所有去网站上找
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b4323a055d68469bb31660870308c814.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a888587de10e465c9f63c721b16abd74.png"/>
     <br/>
     docker pull docker:1.36.0
     <br/>
     如何查看呢
     <br/>
     docker images
     <br/>
     或者docker images busybox
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/36fa02fa1a00432a88707b4b60267497.png"/>
    </p>
    <h3>
     <a id="_760">
     </a>
     查看镜像及列表存储位置
    </h3>
    <p>
     这些镜像的信息默认存在/var/lib/docker
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c15cd7784c344a8b8f9298c96ac0b449.png"/>
    </p>
    <p>
     这里是因为我改过了根目录
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d0ea52cc3946492eb06cf8cbf21869c8.png"/>
    </p>
    <p>
     然后进入image里面
     <br/>
     <img alt=" " src="https://i-blog.csdnimg.cn/direct/f606ef9b4b1647e2a68ace1a0b4be15a.png"/>
    </p>
    <p>
     里面有overlay2
     <br/>
     这个就是docker的存储驱动
    </p>
    <p>
     在进去
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e9352764083c4c89a515b91fc4fb7045.png"/>
     <br/>
     里面有一个json文件
     <br/>
     看一下
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/395bffe4213642038330c9f1b57361a2.png"/>
     <br/>
     我们再把这个json在线格式化一下
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c1d567a4593c43e999b738791fbecc46.png"/>
     <br/>
     这个就看出了我们下了busybox，centos
     <br/>
     说明docker把我们的镜像列表存到了一个docker里面
    </p>
    <h3>
     <a id="_786">
     </a>
     查看镜像详细信息
    </h3>
    <p>
     docker image inspect busybox:1.36.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7573814adcc0492f9f2f678c43e32038.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/04da57a044e04f898854fd405d1ab430.png"/>
     <br/>
     这个是启动命令，就是sh
     <br/>
     -it时候的启动命令就要在这里看
    </p>
    <p>
     docker history busybox:1.36.0
     <br/>
     这个是看楼
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7efd69dafc744b13892369dcec218663.png"/>
     <br/>
     或者在官网也是可以看的
    </p>
    <h3>
     <a id="__797">
     </a>
     打标签 推送镜像
    </h3>
    <p>
     然后就是又要建仓库了
     <br/>
     docker tag busybox:1.36.0 maxhou/mytest:v1.0
     <br/>
     docker tag busybox:1.36.0 maxhou/mytest:v2.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6ab520bbde434914933bd26f6fa49155.png"/>
     <br/>
     然后就是push上去—》官网下载
     <br/>
     docker push maxhou/mytest -a
    </p>
    <p>
     我们有没有登录怎么看呢
     <br/>
     cart /root/.docker/config.json
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ce1e0340b4984c6387de6a6b8992854c.png"/>
     <br/>
     当然也能拉取下来了
     <br/>
     docker pull maxhou/mytest:v2.0
    </p>
    <p>
     这里默认使用的是dockerhub上的
    </p>
    <h3>
     <a id="__813">
     </a>
     运行容器 删除镜像
    </h3>
    <p>
     这里我们运行的是自己从仓库远程拉取下来的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b99cd5b27c3544c382fd4ac0181851dd.png"/>
    </p>
    <p>
     docker run -it maxhou/mytest:v1.0 sh
    </p>
    <p>
     这样就运行起来了
     <br/>
     再打开一个shell
    </p>
    <p>
     docker ps
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/293efcb7d9414856b1c28398c34a2a32.png"/>
    </p>
    <p>
     看的出来我们的容器跑起来了
    </p>
    <p>
     我们要查看ip，直接输入ifconfig
     <br/>
     还可以ping www.baidu.com
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/976573d364564c70a8e5b03f19155ede.png"/>
     <br/>
     exit
     <br/>
     就可以退出了
     <br/>
     docker ps -a | grep maxhou/mytest就可以找到了
    </p>
    <p>
     docker rmi maxhou/mytest:v1.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/da3b2fc14d1e4722b647f3a85c121b50.png"/>
     <br/>
     但是这样并不是删除了镜像
     <br/>
     只是untag了
     <br/>
     并没有delete
     <br/>
     说明只是删除了tag，并没有删除空间
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5acfed5d341f474ca404cc8775787c96.png"/>
     <br/>
     docker run -it maxhou/mytest:v1.0 sh
     <br/>
     然后我们运行已经rmi的tag
     <br/>
     就会说本地没有这个镜像，会去远程拉取的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4db69b732f6d4798ad3fcd5b01a42a40.png"/>
     <br/>
     这样就又有了
     <br/>
     但是这个容器是另一个容器，不是原来的容器
     <br/>
     什么意思呢
     <br/>
     意思就是原来的docker run -it maxhou/mytest:v1.0 sh会生成一个容器
     <br/>
     rmi的时候只是删除了tag，没有删除空间，也没有删除对应容器
     <br/>
     docker ps -a | grep maxhou/mytest:v1.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/84f0f9df6bd24077ada4cca64d3defec.png"/>
     <br/>
     查看一下就知道有两个了
    </p>
    <p>
     然后我们再去删除这个镜像
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b5a2e36252a548338ade4b4248c307e3.png"/>
    </p>
    <p>
     还是只删除了标签
    </p>
    <p>
     docker ps -a | grep maxhou/mytest:v1.0
     <br/>
     我们再去过滤一下
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/389d8fd020314481962871a51be46d9f.png"/>
    </p>
    <p>
     结果什么都没有了
     <br/>
     docker ps -a
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/03a6fde78ddf4e5f9f5ff420c2e82cfa.png"/>
    </p>
    <p>
     我们发现了第二列本应该是tag的，但是变成了镜像id
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6d9cf331d0f5469da3209a449e4aed5d.png"/>
     <br/>
     而且这个镜像id就是busybox和maxhou/mytest的镜像id
    </p>
    <p>
     意思就是把已经停止了的镜像的容器的tag变成了镜像的id
     <br/>
     我们继续删除2.0
     <br/>
     docker rmi maxhou/mytest:v2.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8479fa9f07904464a5df14ef357c20d0.png"/>
     <br/>
     还是只删除了id
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/814f1e4da6e642f9937b2ab5d8839a5e.png"/>
     <br/>
     然后就是消失了
    </p>
    <p>
     再来删除
     <br/>
     docker rmi busybox:1.36.0
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f22956c617fc470a84956ed0948013da.png"/>
     <br/>
     这时候删除就报错了
     <br/>
     因为这已经是最后一个id了，最后一个镜像，还有对应的容器，所以就会出错
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fb7769eebe9d44f2b5f81b53bbe580ed.png"/>
    </p>
    <p>
     我们通过镜像的名称已经过滤不出来了容器，因为删除了它本来的镜像的tag，tag变成了镜像的id
     <br/>
     怎么过滤呢
     <br/>
     我们通过id过滤就可以了
    </p>
    <p>
     docker ps -a | grep 7cfbbec8963d
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1fbdfa21f1ac460e911de585dffeab19.png"/>
     <br/>
     这样就找到了容器了
     <br/>
     要删除镜像就要先删除容器了，，删除只能删除容器的id了，因为没有tag
    </p>
    <p>
     第一列就是容器的id
     <br/>
     第二列就是镜像的tag，现在变为id了
    </p>
    <p>
     docker rm 容器id 容器id
     <br/>
     直接删两个
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b3696c5b1d6a4763b3d77c7bb665fbd6.png"/>
     <br/>
     最后才是docker rmi busybox:1.36.0
     <br/>
     就可以了
     <br/>
     因为还显示了delete的
     <br/>
     所有成功了
     <br/>
     容器的id是唯一的
     <br/>
     tag1多样的
    </p>
    <h2>
     <a id="_910">
     </a>
     实战一、离线迁移镜像
    </h2>
    <p>
     就是断网的情况下
     <br/>
     在ubuntu的环境中保存一个镜像，然后拷贝到centos的服务器上，然后加载起来运行
     <br/>
     我们先来拉自己的镜像
     <br/>
     docker pull maxhou/mytest:v2.0
     <br/>
     然后保存为tar文件
     <br/>
     docker save -o mytestv2.0.tar maxhou/mytest:v2.0
    </p>
    <p>
     然后就是一个centos的环境
     <br/>
     注意这个迁移的环境一定要安装docker，不然是迁移不了的
    </p>
    <p>
     两个服务器之间的拷贝是scp
     <br/>
     在ubuntu中
     <br/>
     scp mytestv2.0.tar root@43.138.128.166:/data/maxhou
     <br/>
     43.138.128.166是centos的ip，然后就是root账户,/data/maxhou就是拷贝到的目录
     <br/>
     然后输入centos的密码
     <br/>
     就可以了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a5fd1ca4ccd947fe9eda2dbe0b4a8553.png"/>
     <br/>
     然后centos就有这个文件了
     <br/>
     docker load -i mytestv2.0.tar
     <br/>
     就可以了
     <br/>
     、
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2aef3f8266f64b9d874e2330a39b6f01.png"/>
     <br/>
     然后就是启动这个镜像成一个容器
     <br/>
     docker run -it maxhou/mytest:v2.0 sh
     <br/>
     这样就可以了
     <br/>
     研发的操作系统是ubuntu，生产的是centos，说明docker是跨平台运行的
    </p>
    <h2>
     <a id="_938">
     </a>
     实战二、镜像存储的压缩与共享
    </h2>
    <p>
     拉取nginx镜像，如果本地没有，镜像是从仓库拉取，如果有会提示镜像已经存
     <br/>
     在，并且是最新的。
     <br/>
     先看镜像在远端和本地是怎么存储对的
     <br/>
     然后就是看pull一千份镜像，会不会放一千份呢
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2c8114914e964f3eb27d3b7a2688f15e.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4600aa24caff4ed79faf22cd722249b9.png"/>
    </p>
    <p>
     远端存的是镜像是压缩过的
     <br/>
     pull到本地的是解压过的
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/995abb09ba0a47c1aa61864388c8e1ac.png"/>
     <br/>
     打了标签的镜像，只是tag不一样了，id还是一样的，而且打了tag也不会改变镜像的大小
     <br/>
     然后就是本端的push到远端，只会自动进行压缩的
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2a4358d67b5745c5b0a85e81e2df0d15.png"/>
     <br/>
     我们把同一个镜像打多个tag
     <br/>
     然后push到仓库去
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/7faebd486aa94824b6be5b37755f11e0.png"/>
     <br/>
     它发现nginx库里面有这个版本，所以直接就去nginx库里面导入到我们的仓库了
     <br/>
     我们再导入一个
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3a6b137a19f14c2abd8a995d5bdfaac6.png"/>
     <br/>
     这个直接就告诉你我们的仓库里面已经有这个镜像了
    </p>
    <p>
     <img alt=" " src="https://i-blog.csdnimg.cn/direct/d9c2a979924a45639ad8b71b15eb34ea.png"/>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3d20b9b8cde54f068e6563f8d3cb85e5.png"/>
    </p>
    <p>
     然后仓库里面就只是存了一个tag，不是存了很多个镜像，镜像只存了一种
    </p>
    <h2>
     <a id="_983">
     </a>
     总结
    </h2>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f37393938313838352f:61727469636c652f64657461696c732f313436313835333232" class_="artid" style="display:none">
 </p>
</div>


