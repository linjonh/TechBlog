---
layout: post
title: "08react基础-react原理"
date: 2025-03-06 19:05:10 +0800
description: "过程：父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件）虚拟 DOM：本质上就是一个 JS 对象，用来描述你希望在屏幕上看到的内容（UI）。React 元素： 是一个对象，用来描述你希望在屏幕上看到的内容。随机数案例 如果随机获取的数值和之上一次一样不更新组件否则就更新。最后编辑于：2025-02-24 21:39:42。著作权归作者所有,转载或内容合作请联系作者。更新根组件时..png。更新子组件时.png。setState() 的两个作用。虚拟DOM对象（树）"
keywords: "08react基础-react原理"
categories: ['面试题汇总与解析']
tags: ['课程设计', '大数据', 'Vue', 'Spring', 'Java', 'Boot']
artid: "146077904"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077904
    alt: "08react基础-react原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077904
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077904
cover: https://bing.ee123.net/img/rand?artid=146077904
image: https://bing.ee123.net/img/rand?artid=146077904
img: https://bing.ee123.net/img/rand?artid=146077904
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     08react基础-react原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <div>
     <div class="note-content">
      <h5>
       setState()更新数据
      </h5>
      <ul>
       <li>
        <code>
         setState()
        </code>
        更新数据是异步的
       </li>
       <li>
        注意：使用该语法，后面的
        <code>
         setState
        </code>
        不要依赖前面
        <code>
         setState
        </code>
        的值
       </li>
       <li>
        多次调用
        <code>
         setState
        </code>
        ，只会触发一次render
       </li>
      </ul>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'
class App extends React.Component {
  state = {
    count: 1
  }

  handleClick = () =&gt; {
    // 此处，更新state
    // 注意：异步更新数据的！！！
    this.setState({
      count: this.state.count + 1
    })
    console.log('count：', this.state.count) // 1
    this.setState({
      count: this.state.count + 1 // 1 + 1
    })
    console.log('count：', this.state.count) // 1
  }
  render() {
    console.log('render')
    return (
      &lt;div&gt;
        &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt;
        &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 384px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/29562dc15078a9c32b105f7dd4cfdf3d.webp?x-oss-process=image/format,png">
         </img>
        </div>
       </div>
       <div class="image-caption">
        执行结果.png
       </div>
      </div>
      <h5>
       setState()推荐语法
      </h5>
      <ul>
       <li>
        基础语法：
       </li>
      </ul>
      <pre><code>this.setState((state, props) =&gt; {
return {
count: state.count + 1
  }
})
console.log(this.state.count) // 1
</code></pre>
      <ul>
       <li>
        完整代码：
       </li>
      </ul>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  setState() 推荐语法
*/

class App extends React.Component {
  state = {
    count: 1
  }

  handleClick = () =&gt; {
  

    // 推荐语法：
    // 注意：这种语法也是异步更新state的！
    this.setState((state, props) =&gt; {
      return {
        count: state.count + 1 // 1 + 1
      }
    })
    this.setState((state, props) =&gt; {
      console.log('第二次调用：', state)
      return {
        count: state.count + 1
      }
    })
    console.log('count：', this.state.count) // 1
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;计数器：{this.state.count}&lt;/h1&gt;
        &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <div class="image-package">
       <div class="image-container" style="max-width: 490px; max-height: 398px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/54c0f452da03a74ee9b5356f851308da.webp?x-oss-process=image/format,png">
         </img>
        </div>
       </div>
       <div class="image-caption">
        执行结果.png
       </div>
      </div>
      <h5>
       setState()第二个参数
      </h5>
      <ul>
       <li>
        场景：在状态更新(页面完成重新渲染)后立即执行某个操作
       </li>
       <li>
        语法：
        <code>
         setState(update[,callback])
        </code>
       </li>
      </ul>
      <pre><code>this.setState(
(state, props) =&gt; {},
() =&gt; {console.log('这个回调函数会在状态更新后立即执行')}
)
</code></pre>
      <p>
       例子：
      </p>
      <pre><code>this.setState(
(state, props) =&gt; {},
() =&gt; {
document.title = '更新state后的标题：' + this.state.count
   }
)
</code></pre>
      <p>
       具体代码：
      </p>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  setState() callback
*/

class App extends React.Component {
  state = {
    count: 1
  }

  handleClick = () =&gt; {
    this.setState(
      (state, props) =&gt; {
        return {
          count: state.count + 1
        }
      },
      // 状态更新后并且重新渲染后，立即执行：
      () =&gt; {
        console.log('状态更新完成：', this.state.count) // 2
        console.log(document.getElementById('title').innerText)
        document.title = '更新后的count为：' + this.state.count
      }
    )
    console.log(this.state.count) // 1
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1 id="title"&gt;计数器：{this.state.count}&lt;/h1&gt;
        &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <h5>
       JSX语法的转化过程
      </h5>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 120px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/f82521fe1f70ce2b86d5e62e4a363b55.webp?x-oss-process=image/format,png">
         </img>
        </div>
       </div>
       <div class="image-caption">
        image.png
       </div>
      </div>
      <ul>
       <li>
        JSX仅仅是
        <code>
         createElement()
        </code>
        方法的语法糖(简化语法)
       </li>
       <li>
        JSX语法被 @babel/preset-react 插件编译为
        <code>
         createElement()
        </code>
        方法
       </li>
       <li>
        <p>
         React 元素： 是一个对象，用来描述你希望在屏幕上看到的内容
        </p>
        <br/>
        <div class="image-package">
         <div class="image-container" style="max-width: 700px; max-height: 280px;">
          <div class="image-container-fill">
          </div>
          <div class="image-view">
           <img src="https://i-blog.csdnimg.cn/img_convert/ec9471f7455d4fb52448be0092543cd4.webp?x-oss-process=image/format,png">
           </img>
          </div>
         </div>
         <div class="image-caption">
          image.png
         </div>
        </div>
       </li>
      </ul>
      <h5>
       组件更新机制
      </h5>
      <ul>
       <li>
        <p>
         setState() 的两个作用
        </p>
        <ul>
         <li>
          修改state
         </li>
         <li>
          更新组件
         </li>
        </ul>
       </li>
       <li>
        <p>
         过程：父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件）
        </p>
        <br/>
        <div class="image-package">
         <div class="image-container" style="max-width: 700px; max-height: 380px;">
          <div class="image-container-fill">
          </div>
          <div class="image-view">
           <img src="https://i-blog.csdnimg.cn/img_convert/0eda6327211cc15b6d3be8303ec5c739.webp?x-oss-process=image/format,png">
           </img>
          </div>
         </div>
         <div class="image-caption">
          image.png
         </div>
        </div>
       </li>
      </ul>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  组件更新机制
*/

import './index.css'

// 根组件
class App extends React.Component {
  state = {
    color: '#369'
  }

  getColor() {
    return Math.floor(Math.random() * 256)
  }

  changeBG = () =&gt; {
    this.setState(() =&gt; {
      return {
        color: `rgb(${this.getColor()}, ${this.getColor()}, ${this.getColor()})`
      }
    })
  }

  render() {
    console.log('根组件')
    return (
      &lt;div className="app" style={<!-- -->{ backgroundColor: this.state.color }}&gt;
        &lt;button onClick={this.changeBG}&gt;根组件 - 切换颜色状态&lt;/button&gt;
        &lt;div className="app-wrapper"&gt;
          &lt;Parent1 /&gt;
          &lt;Parent2 /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

// ------------------------左侧---------------------------

class Parent1 extends React.Component {
  state = {
    count: 0
  }

  handleClick = () =&gt; {
    this.setState(state =&gt; ({ count: state.count + 1 }))
  }
  render() {
    console.log('左侧父组件')
    return (
      &lt;div className="parent"&gt;
        &lt;h2&gt;
          左侧 - 父组件1
          &lt;button onClick={this.handleClick}&gt;点我（{this.state.count}）&lt;/button&gt;
        &lt;/h2&gt;
        &lt;div className="parent-wrapper"&gt;
          &lt;Child1 /&gt;
          &lt;Child2 /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

class Child1 extends React.Component {
  render() {
    console.log('左侧子组件 - 1')
    return &lt;div className="child"&gt;子组件1-1&lt;/div&gt;
  }
}
class Child2 extends React.Component {
  render() {
    console.log('左侧子组件 - 2')
    return &lt;div className="child"&gt;子组件1-2&lt;/div&gt;
  }
}

// ------------------------右侧---------------------------

class Parent2 extends React.Component {
  state = {
    count: 0
  }

  handleClick = () =&gt; {
    this.setState(state =&gt; ({ count: state.count + 1 }))
  }

  render() {
    console.log('右侧父组件')
    return (
      &lt;div className="parent"&gt;
        &lt;h2&gt;
          右侧 - 父组件2
          &lt;button onClick={this.handleClick}&gt;点我（{this.state.count}）&lt;/button&gt;
        &lt;/h2&gt;
        &lt;div className="parent-wrapper"&gt;
          &lt;Child3 /&gt;
          &lt;Child4 /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

class Child3 extends React.Component {
  render() {
    console.log('右侧子组件 - 1')
    return &lt;div className="child"&gt;子组件2-1&lt;/div&gt;
  }
}
class Child4 extends React.Component {
  render() {
    console.log('右侧子组件 - 2')
    return &lt;div className="child"&gt;子组件2-2 &lt;/div&gt;
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 337px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/3b2bfc3b8eee7b1fee591958ddcd629e.webp?x-oss-process=image/format,png">
         </img>
        </div>
       </div>
       <div class="image-caption">
        更新子组件时.png
       </div>
      </div>
      <br/>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 399px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/f339b50da7483dfe08e0cd48114f49c8.webp?x-oss-process=image/format,png">
         </img>
        </div>
       </div>
       <div class="image-caption">
        更新根组件时..png
       </div>
      </div>
      <h5>
       组件性能优化
      </h5>
      <ul>
       <li>
        1.减轻state
       </li>
       <li>
        减轻state：只存储跟组件渲染相关的数据（比如：count/ 列表数据 /loading等）
       </li>
       <li>
        注意：不用做渲染的数据不要放在state中
       </li>
       <li>
        对于这种需要在多个方法中用到的数据，应该放到this中
       </li>
      </ul>
      <pre><code>class Hello extends Component {
componentDidMount() {
// timerId存储到this中，而不是state中
this.timerId = setInterval(() =&gt; {}, 2000)
  }
componentWillUnmount() {
clearInterval(this.timerId)
   }
render() { … }
}
</code></pre>
      <ul>
       <li>
        2.避免不必要的重新渲染
       </li>
       <li>
        组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰
       </li>
       <li>
        问题：子组件没有任何变化时也会重新渲染
       </li>
       <li>
        如果避免不必要的重新渲染？
       </li>
       <li>
        解决方式：使用钩子函数
        <code>
         shouldComponentUpdate(nextProps, nextState)
        </code>
        <ul>
         <li>
          在这个函数中，
          <code>
           nextProps
          </code>
          和
          <code>
           nextState
          </code>
          是最新的状态以及属性
         </li>
        </ul>
       </li>
       <li>
        作用：这个函数有返回值，如果返回true，代表需要重新渲染，如果返回false，代表不需要重新渲染
       </li>
       <li>
        触发时机：更新阶段的钩子函数，组件重新渲染前执行
        <code>
         (shouldComponentUpdate =&gt; render)
        </code>
       </li>
      </ul>
      <pre><code>class Hello extends Component {
shouldComponentUpdate() {
// 根据条件，决定是否重新渲染组件
return false
}
render() {…}
}
</code></pre>
      <p>
       随机数案例 如果随机获取的数值和之上一次一样不更新组件否则就更新
      </p>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  组件性能优化：
*/

// 生成随机数
class App extends React.Component {
  state = {
    number: 0
  }

  handleClick = () =&gt; {
    this.setState(() =&gt; {
      return {
        number: 1
      }
    })
  }

  // 因为两次生成的随机数可能相同，如果相同，此时，不需要重新渲染
  shouldComponentUpdate(nextProps, nextState) {
    console.log('最新状态：', nextState, ', 当前状态：', this.state)

    return nextState.number !== this.state.number

    // if (nextState.number !== this.state.number) {
    //   return true
    // }
    // return false

    // if (nextState.number === this.state.number) {
    //   return false
    // }
    // return true
  }

  render() {
    console.log('render')
    return (
      &lt;div&gt;
        &lt;h1&gt;随机数：{this.state.number}&lt;/h1&gt;
        &lt;button onClick={this.handleClick}&gt;重新生成&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <ul>
       <li>
        nextprops:
       </li>
      </ul>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  组件性能优化：
*/

// 生成随机数
class App extends React.Component {
  state = {
    number: 0
  }

  handleClick = () =&gt; {
    this.setState(() =&gt; {
      return {
        number: Math.floor(Math.random() * 3)
      }
    })
  }

  // 因为两次生成的随机数可能相同，如果相同，此时，不需要重新渲染
  // shouldComponentUpdate(nextProps, nextState) {
  //   console.log('最新状态：', nextState, ', 当前状态：', this.state)
  //   return nextState.number !== this.state.number
  // }

  render() {
    // console.log('render')
    return (
      &lt;div&gt;
        &lt;NumberBox number={this.state.number} /&gt;
        &lt;button onClick={this.handleClick}&gt;重新生成&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

class NumberBox extends React.Component {
  shouldComponentUpdate(nextProps) {
    console.log('最新props：', nextProps, ', 当前props：', this.props)
    // 如果前后两次的number值相同，就返回false，不更新组件
    return nextProps.number !== this.props.number

    // if (nextProps.number === this.props.number) {
    //   return false
    // }
    // return true
  }
  render() {
    console.log('子组件中的render')
    return &lt;h1&gt;随机数：{this.props.number}&lt;/h1&gt;
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <h5>
       纯组件
      </h5>
      <h5>
       作用以及使用
      </h5>
      <ul>
       <li>
        纯组件：
        <code>
         PureComponent
        </code>
        与
        <code>
         React.Componen
        </code>
        t 功能相似
       </li>
       <li>
        区别：
        <code>
         PureComponent
        </code>
        内部自动实现了
        <code>
         shouldComponentUpdate
        </code>
        钩子，不需要手动比较
       </li>
       <li>
        原理：纯组件内部通过分别比对前后两次 props和state的值，来决定是否重新渲染组件
       </li>
      </ul>
      <pre><code>class Hello extends React.PureComponent {
render() {
return (
&lt;div&gt;纯组件&lt;/div&gt;
     )
  }
}
</code></pre>
      <ul>
       <li>
        实现原理
       </li>
       <li>
        说明：纯组件内部的对比是
        <code>
         shallow compare（浅层对比）
        </code>
       </li>
       <li>
        对于值类型来说：比较两个值是否相同
       </li>
      </ul>
      <pre><code>const obj = { number: 0 }
const newObj = obj
newObj.number = 2
console.log(newObj === obj) // true
</code></pre>
      <ul>
       <li>
        引用类型：只比对对象的引用地址是否相同
       </li>
      </ul>
      <pre><code>state = { obj: { number: 0 } }
// 错误做法
state.obj.number = 2
setState({ obj: state.obj })
// PureComponent内部比较：
最新的state.obj === 上一次的state.obj // true，不重新渲染组件
</code></pre>
      <ul>
       <li>
        注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据
       </li>
      </ul>
      <pre><code>// 正确！创建新数据
const newObj = {...state.obj, number: 2}
setState({ obj: newObj })
// 正确！创建新数据
// 不要用数组的push / unshift 等直接修改当前数组的的方法
// 而应该用 concat 或 slice 等这些返回新数组的方法
this.setState({
list: [...this.state.list, {新数据}]
})
</code></pre>
      <p>
       案例：
      </p>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  组件性能优化：
*/

// 引用类型：
const obj = { number: 0 }
const newObj = obj
newObj.number = 2
console.log(newObj === obj) // true

// 生成随机数
class App extends React.PureComponent {
  state = {
    obj: {
      number: 0
    }
  }

  handleClick = () =&gt; {
    // 正确做法：创建新对象
    const newObj = { ...this.state.obj, number: Math.floor(Math.random() * 3) }
    this.setState(() =&gt; {
      return {
        obj: newObj
      }
    })

    // 错误演示：直接修改原始对象中属性的值
    /* const newObj = this.state.obj
    newObj.number = Math.floor(Math.random() * 3)

    this.setState(() =&gt; {
      return {
        obj: newObj
      }
    }) */
  }

  render() {
    console.log('父组件重新render')
    return (
      &lt;div&gt;
        &lt;h1&gt;随机数：{this.state.obj.number}&lt;/h1&gt;
        &lt;button onClick={this.handleClick}&gt;重新生成&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <h5>
       虚拟 DOM 和 Diff 算法
      </h5>
      <ul>
       <li>
        React更新视图的思想是：只要state变化就重新渲染视图
       </li>
       <li>
        特点：思路非常清晰
       </li>
       <li>
        问题：组件中只有一个DOM元素需要更新时，也得把整个组件的内容重新渲染吗？ 不是这样的
       </li>
       <li>
        理想状态：部分更新，只更新变化的地方
       </li>
       <li>
        React运用的核心点就是 虚拟DOM 配合 Diff 算法
       </li>
      </ul>
      <h5>
       虚拟DOM
      </h5>
      <p>
       虚拟 DOM：本质上就是一个 JS 对象，用来描述你希望在屏幕上看到的内容（UI）。
      </p>
      <br/>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 305px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/7ac1e7ef35a7e63668d166fb65145a5b.webp?x-oss-process=image/format,png">
         </img>
        </div>
       </div>
       <div class="image-caption">
        image.png
       </div>
      </div>
      <h5>
       Diff算法
      </h5>
      <p>
       执行过程
      </p>
      <ul>
       <li>
        初次渲染时，React会根据初始化的state（model），创建一个
        <code>
         虚拟DOM对象（树）
        </code>
       </li>
       <li>
        根据虚拟DOM生成真正的DOM，渲染到页面
       </li>
       <li>
        当数据变化后(setState())，会重新根据新的数据，创建新的虚拟DOM对象（树）
       </li>
       <li>
        与上一次得到的虚拟DOM对象，使用
        <code>
         Diff算法
        </code>
        比对（找不同），得到需要更新的内容
       </li>
       <li>
        最终，React只将
        <code>
         变化的内容
        </code>
        更新（patch）到DOM中，重新渲染到页面
       </li>
      </ul>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 301px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/129c37a7b9094f0bb7f6ad963b0d1f6c.webp?x-oss-process=image/format,png"/>
        </div>
       </div>
       <div class="image-caption">
        image.png
       </div>
      </div>
      <br/>
      <p>
       代码演示：
      </p>
      <pre><code>import React from 'react'
import ReactDOM from 'react-dom'

/* 
  虚拟DOM 和 Diff算法
*/

// 生成随机数
class App extends React.PureComponent {
  state = {
    number: 0
  }

  handleClick = () =&gt; {
    this.setState(() =&gt; {
      return {
        number: Math.floor(Math.random() * 2)
      }
    })
  }

  // render方法调用并不意味着浏览器中的重新渲染！！！
  // render方法调用仅仅说明要进行diff
  render() {
    const el = (
      &lt;div&gt;
        &lt;h1&gt;随机数：&lt;/h1&gt;
        &lt;p&gt;{this.state.number}&lt;/p&gt;
        &lt;button onClick={this.handleClick}&gt;重新生成&lt;/button&gt;
      &lt;/div&gt;
    )
    console.log(el)

    return el
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
      <div class="image-package">
       <div class="image-container" style="max-width: 700px; max-height: 578px;">
        <div class="image-container-fill">
        </div>
        <div class="image-view">
         <img src="https://i-blog.csdnimg.cn/img_convert/7aaac0f6111d56bf24b164c36db708d3.webp?x-oss-process=image/format,png"/>
        </div>
       </div>
       <div class="image-caption">
        image.png
       </div>
      </div>
     </div>
     <div class="note-meta-time">
      最后编辑于：2025-02-24 21:39:42
     </div>
     <div class="copyright">
      © 
   著作权归作者所有,转载或内容合作请联系作者
     </div>
    </div>
    <br/>
    <img src="https://img-blog.csdnimg.cn/direct/67c64049147741939b85489caefbb597.png" width="800px"/>
    <br/>
    <p style="font-weight: 700;">
     喜欢的朋友记得点赞、收藏、关注哦！！！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6361696875617975616e352f:61727469636c652f64657461696c732f313436303737393034" class_="artid" style="display:none">
 </p>
</div>


