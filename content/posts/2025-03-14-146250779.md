---
layout: post
title: "UDP协议栈之整体架构处理"
date: 2025-03-14 15:39:30 +0800
description: "接下来查看单包信息的传递情况，需知道MAC层使用的目的AMC地址，是在ARP缓存表中进行读取的，在数据报文到达IP层时，向ARP缓存表进行读取，寻找目的IP的MAC地址是否存在于ARP缓存表中，将寻找到的MAC地址发送给MAC层，所以在仿真中进行检验，是否使用了正确的MAC地址。"
keywords: "UDP协议栈之整体架构处理"
categories: ['Fpga']
tags: ['架构', '单片机', 'Udp']
artid: "146250779"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146250779
    alt: "UDP协议栈之整体架构处理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146250779
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146250779
cover: https://bing.ee123.net/img/rand?artid=146250779
image: https://bing.ee123.net/img/rand?artid=146250779
img: https://bing.ee123.net/img/rand?artid=146250779
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     UDP协议栈之整体架构处理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在之前的章节中，笔者就UDP、ICMP、IP、ARP、MAC层的报文格式，以及组帧解帧、CRC校验、分片处理等操作进行了具体介绍以及详细代码实现，并且通过了仿真测试。但之前的仿真测试都是对单层报文的组帧解帧进行的，这些模块仍处于“孤立”状态，缺乏协同工作的能力。在本章节中，笔者将上述实现的各个模块，进行总线互联，实现一个UDP协议栈的整体架构，用户通过顶层接口，可以实现数据的发送、接收、ARP请求包、IP、MAC、PORT设置等关键操作。架构文字示意如下，其中PHY层物理接口，在之后的还章节会进行介绍
     <br/>
     ±--------------------+
     <br/>
     | 用户接口层 | ← 配置MAC/IP/端口，发送/接收数据
     <br/>
     ±--------------------+
     <br/>
     | UDP传输层 | ← 封装/解封装UDP头，端口校验
     <br/>
     ±--------------------+
     <br/>
     | IP网络层 | ← IP头处理、分片与重组、ICMP响应
     <br/>
     ±--------------------+
     <br/>
     | ARP &amp; MAC链路层 | ← ARP表维护、MAC帧组帧/解帧、CRC校验
     <br/>
     ±--------------------+
     <br/>
     | 物理接口（PHY） | ← RMII/GMII等硬件接口
     <br/>
     ±--------------------+
     <br/>
     流程示意框图如下所示
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d5a0ccf6a014458ba7ec1a7acda57bf4.png">
      <br/>
      接下来进行代码的整体组合，最终用户可操作的接口如下所示
     </img>
    </p>
    <pre><code class="prism language-c">	<span class="token comment">/*MAC IP PORTp配置*/</span>
    input   <span class="token punctuation">[</span><span class="token number">31</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_port_info     <span class="token punctuation">,</span>
    input               i_port_valid    <span class="token punctuation">,</span>
    input   <span class="token punctuation">[</span><span class="token number">63</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_ip_info       <span class="token punctuation">,</span>
    input               i_ip_valid      <span class="token punctuation">,</span>
    input   <span class="token punctuation">[</span><span class="token number">79</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_macip_info    <span class="token punctuation">,</span>
    input               i_info_valid    <span class="token punctuation">,</span>
    input   <span class="token punctuation">[</span><span class="token number">47</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_mac_sinfo     <span class="token punctuation">,</span>
    input               i_mac_svalid    <span class="token punctuation">,</span>
    <span class="token comment">/*ARP请求包配置*/</span>
    input   <span class="token punctuation">[</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_op_code       <span class="token punctuation">,</span>
    input               i_op_valid      <span class="token punctuation">,</span>
    input   <span class="token punctuation">[</span><span class="token number">31</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_request_ip    <span class="token punctuation">,</span>
    input               i_request_valid <span class="token punctuation">,</span>
    <span class="token comment">/*输入数据总线*/</span>
    input   <span class="token punctuation">[</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_user_len      <span class="token punctuation">,</span>
    input   <span class="token punctuation">[</span><span class="token number">7</span> <span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_user_data     <span class="token punctuation">,</span>
    input               i_user_valid    <span class="token punctuation">,</span>
    input               i_user_last     <span class="token punctuation">,</span>
    output              o_trans_ready   <span class="token punctuation">,</span>
    <span class="token comment">/*输出接收数据总线*/</span>
    output  <span class="token punctuation">[</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      o_user_len      <span class="token punctuation">,</span>
    output  <span class="token punctuation">[</span><span class="token number">7</span> <span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      o_user_data     <span class="token punctuation">,</span>
    output              o_user_valid    <span class="token punctuation">,</span>
    output              o_user_last     <span class="token punctuation">,</span>
</code></pre>
    <p>
     接下来进行代码仿真测试
     <br/>
     仿真测试条件如下，两个UDP相互发送指令
    </p>
    <ul>
     <li>
      首先，两台UDP协议栈向对方发送ARP请求包，请求MAC地址
     </li>
     <li>
      之后，两台UDP协议栈向对方发送数据，单包1024字节，发送三帧
     </li>
     <li>
      观察交互信息流
      <br/>
      标号为1的UDP协议栈，信息如下
      <br/>
      MAC地址：8’h11,8’h22,8’h33,8’h44,8’h55,8’h66
      <br/>
      IP地址：192.168.1.10
      <br/>
      PORT：16‘h8080
      <br/>
      标号为2的UDP协议栈，信息如下
      <br/>
      MAC地址：8’ha5,8’hd5,8’hff,8’hff,8’hff,8’he5
      <br/>
      IP地址：192.168.1.20
      <br/>
      PORT：16‘h8081
      <br/>
      首先观察ARP测试
      <br/>
      观察第一副图,ARP_T接收到用户的ARP请求操作码一级请求IP地址，并进行了ARP报文的输出。
      <br/>
      接口功能如下
     </li>
    </ul>
    <pre><code class="prism language-c">	<span class="token comment">/*ARP操作码及请求IP地址*/</span>
    input   <span class="token punctuation">[</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_op_code       <span class="token punctuation">,</span>
    input               i_op_valid      <span class="token punctuation">,</span>
    input   <span class="token punctuation">[</span><span class="token number">31</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      i_request_ip    <span class="token punctuation">,</span>
    input               i_request_valid <span class="token punctuation">,</span>
    <span class="token comment">/*输出给MAC层的报文端口*/</span>
    output  <span class="token punctuation">[</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      o_mac_len       <span class="token punctuation">,</span>
    output  <span class="token punctuation">[</span><span class="token number">7</span> <span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span>      o_mac_data      <span class="token punctuation">,</span>
    output              o_mac_valid     <span class="token punctuation">,</span>
    output              o_mac_last       
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d9491c1d1ed54bd199e100e880ed2d71.png">
      <br/>
      接下来观察ARP_RX模块仿真图，是否接收到UDP站点2的ARP响应。
     </img>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9847cb2caf0f43c4a068220c0b4133ec.png">
      <br/>
      观察红框中的有效数据，c0a80114其IP地址即为192.168.1.20，而mac地址为8’ha5,8’hd5,8’hff,8’hff,8’hff,8’he5，检验出，站点2接收到站点1的ARP请求，正确进行了ARP响应，站点1成功收到MAC地址。
     </img>
    </p>
    <p>
     接下来观察ARP_LIST模块仿真图，当输入进缓存的IP、MAC地址，是否进行了正确的地址查询，确定不存在后进行缓存
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4efa76a60bdd4d1c9608c8fc23998f46.png">
      <br/>
      可以观察图中红框处的RAM使能读写以及数据地址控制信号，由于协议栈运行初始，RAM中不会缓存MAC、IP信息，所以有效搜索范围只有地址0，当检测到当前MAC、IP在ARP缓存表中不存在后，将该MAC、IP信息进行缓存。
      <br/>
      可以看出ARP_LISRT模块正常进行了工作
     </img>
    </p>
    <p>
     接下来查看单包信息的传递情况，需知道MAC层使用的目的AMC地址，是在ARP缓存表中进行读取的，在数据报文到达IP层时，向ARP缓存表进行读取，寻找目的IP的MAC地址是否存在于ARP缓存表中，将寻找到的MAC地址发送给MAC层，所以在仿真中进行检验，是否使用了正确的MAC地址
    </p>
    <p>
     观察下图，为ARP_LIST接收到搜寻IP对应MAC地址命令，并进行响应的时序波形
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/41033011c6fe4d7bac5518932c08636b.png">
      <br/>
      观察红框处，可以看出ARP缓存表正确输出了MAC地址
     </img>
    </p>
    <p>
     观察下图，为MAC层的发送仿真图
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/46f2841b8af54ec3af3512190bc44bee.png">
      <br/>
      观察红框处，可以看出MAC_TX正确接收到MAC地址，并在发送报文时，进行了使用。
     </img>
    </p>
    <p>
     关于各层之间的处理，因为之前在各个章节已经仿真过，便不再赘述，直接观察UDP_RX的输出，是否正确接收到1024字节的数据包即可，UDP_RX的输出如下图所示
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a153388e33cb41d2b923d07a4505d320.png">
      <br/>
      可以看出，UDP_RX正确输出三帧1024的字节包。
     </img>
    </p>
    <p>
     至此,UDP协议栈的仿真告一段落，本章节中涉及到的许多知识，在之前的章节都有讲述，对哪部分有疑问的小伙伴可以查找对应章节，进行学习。接下来，笔者将其应用层协议进行讲解，初步打算是讲解IEEE1588V2协议，并在仿真中进行时间同步测验，觉得本文章写的不错，并且对之后的更新内容感兴趣的小伙伴，可以点个关注，不迷路，感谢你的阅读，谢谢！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f7a7931323032323030302f:61727469636c652f64657461696c732f313436323530373739" class_="artid" style="display:none">
 </p>
</div>


