---
layout: post
title: "C和标准库速成一HelloWorld和名称空间"
date: 2025-03-11 21:28:24 +0800
description: "HelloWorld和名称空间"
keywords: "C++和标准库速成(一)——HelloWorld和名称空间"
categories: ['C']
tags: ['开发语言', 'C']
artid: "146104364"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146104364
    alt: "C和标准库速成一HelloWorld和名称空间"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146104364
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146104364
cover: https://bing.ee123.net/img/rand?artid=146104364
image: https://bing.ee123.net/img/rand?artid=146104364
img: https://bing.ee123.net/img/rand?artid=146104364
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++和标准库速成(一)——HelloWorld和名称空间
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="1__1">
     </a>
     1. 引言
    </h2>
    <p>
     C++20的标准库模块目前还没有正式得到编译器的支持，而MSVC中已经存在了对标准库模块的实验性支持。需要安装适用于v143生成工具的C++模块，并且将普通控制台应用项目属性C/C++下的所有选项中的启用实验性的C++标准库模块改为是。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/45ab630617d24f459c19db85145abd63.png"/>
    </p>
    <h2>
     <a id="1_Hello_World_5">
     </a>
     1. 简单小程序"Hello World"
    </h2>
    <pre><code class="prism language-cpp"><span class="token keyword">import</span> <span class="token module">std<span class="token punctuation">.</span>core</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bc90758eb12044809b668179da30660c.png"/>
    </p>
    <h3>
     <a id="11__15">
     </a>
     1.1 模块导入
    </h3>
    <p>
     C++20中最重要的新特性之一就是对模块的支持，用来替代之前的头文件机制。如果你想要使用某个模块中的功能，则需要导入这个模块，可以通过一条import声明做到。如
     <code>
      import std.core;
     </code>
     <br/>
     如果你的编译器还不支持模块，只需要简单地将import声明替换为#include预处理指令。
    </p>
    <h3>
     <a id="12__18">
     </a>
     1.2 预处理指令
    </h3>
    <h4>
     <a id="121__19">
     </a>
     1.2.1 简介
    </h4>
    <p>
     如果你的编译器还不支持C++20的模块，需要编写如下的预处理指令：
     <code>
      #include &lt;iostream&gt;
     </code>
     。
     <br/>
     简单来说，生成一个C++程序共有3个步骤。首先，代码经过预处理器，预处理器会识别代码中的元信息。其次，代码被编译或转换为计算机可识别的目标文件。最后，独立的目标文件被连接在一起生成一个应用程序。
     <br/>
     预处理指令以#字符开始，前面实例中的
     <code>
      #include &lt;iostream&gt;
     </code>
     就是一条预处理指令。在此例中，include指令告诉预处理器：提取&lt;iostream&gt;头文件中的所有内容并提供给当前文件。
     <br/>
     头文件最常见的用途是声明在其他地方定义的函数，函数声明会通知编译器如何调用这个函数，并声明函数中参数的个数和类型，以及函数的返回类型；函数定义包含这个函数的实际代码。在C++20引入模块之前，声明通常放在扩展名为.h的文件中，称为头文件，其定义通常包含在扩展名为.cpp的文件中，称为源文件。有了模块，我们不再需要将声明与定义分离，但是之前的写法仍然可以使用。
     <br/>
     <font color="red">
      注意:
     </font>
     <br/>
     1. 在C中，标准库头文件的名称通常以.h结尾，不使用名称空间。
     <br/>
     2. 在C++中，标准库头文件的名称省略了.h后缀，所有文件都在std名称空间和std的子名称空间中定义。
     <br/>
     3. C中的标准库头文件在C++中依然存在，但使用以下两个版本：
     <br/>
     3.1 不使用.h后缀，改成前缀c，
     <font color="red">
      这是推荐使用的版本
     </font>
     ，这些头文件将内容放在std名称空间中。
     <br/>
     3.2 使用.h后缀，这是旧版本，这些版本不适用名称空间。
    </p>
    <h4>
     <a id="122__30">
     </a>
     1.2.2 常用的预处理指令
    </h4>
    <table>
     <thead>
      <tr>
       <th align="left">
        预处理指令
       </th>
       <th align="left">
        功能
       </th>
       <th align="left">
        常见用法
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="left">
        <font color="red">
         #include [file]
        </font>
       </td>
       <td align="left">
        将指定的文件插入代码中指令所在的位置
       </td>
       <td align="left">
        几乎总是用来包含头文件，使代码可使用在其他位置定义的功能
       </td>
      </tr>
      <tr>
       <td align="left">
        <font color="red">
         #define [id] [value]
        </font>
       </td>
       <td align="left">
        每个指定的标识符都被替换成指定的值
       </td>
       <td align="left">
        在C中，常用来定义常数值或宏。C++提供了常数和大多数宏类型的更好机制。
        <font color="red">
         在C++使用宏有风险
        </font>
        。
       </td>
      </tr>
      <tr>
       <td align="left">
        <div>
         <font color="red">
          #ifdef [id]
         </font>
         <br/>
         <font color="red">
          #endif
         </font>
         <br/>
         <font color="red">
          #ifndef [id]
         </font>
         <br/>
         <font color="red">
          #endif
         </font>
        </div>
       </td>
       <td align="left">
        ifdef(if defined)块和ifndef(if not defined)块中的代码被有条件地包含或舍弃，这取决于是否使用#define定义了特定的标识符
       </td>
       <td align="left">
        经常用来防止循环包含。每个头文件都以#ifndef开头，以保证某个标识符还未被定义，然后用一条#define指令定义该标识符。头文件以#endif结束，这样这个头文件不会被多次包含
       </td>
      </tr>
      <tr>
       <td align="left">
        <font color="red">
         #pragma [xyz]
        </font>
       </td>
       <td align="left">
        xyz因编译器而异。如果在预处理期间执行到这一指令，通常会显示一条警告或错误信息
       </td>
       <td align="left">
        参见该表之后的举例
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     下面是使用预处理指令避免重复包含的一个实例：
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">MYHEADER_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MYHEADER_H</span></span>
<span class="token comment">// ... the contents of this header file</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre>
    <p>
     如果编译器支持
     <code>
      #pragma once
     </code>
     指令，可采用以下方法重写上面的代码。
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token comment">// ... the contents of this header file</span>
</code></pre>
    <h3>
     <a id="13_main_76">
     </a>
     1.3 main()函数
    </h3>
    <p>
     main()函数是程序的入口。main函数返回一个int值以指示程序的最终执行状态。在main()函数中可以忽略显式的return语句，这种情况下会自动返回0.main()函数要么没有参数，要么具有两个参数，如下所示。
     <br/>
     <code>
      int main(int argc, char* argv[])
     </code>
     <br/>
     argc给出了传递给程序的实参数目，argv包含了这些实参。
     <font color="red">
      注意argv[0]可能是程序的名称，也可能是空字符串，所以不应使用它
     </font>
     。应当使用特定于平台的功能检索程序名。最重要的是，
     <font color="red">
      实际参数从索引1开始
     </font>
     。
    </p>
    <h3>
     <a id="14__80">
     </a>
     1.4 输入输出流
    </h3>
    <h4>
     <a id="141__81">
     </a>
     1.4.1 输出流
    </h4>
    <p>
     基本的输入输出非常简单，可将输出流想象为针对数据的洗衣滑槽，放入其中的任何内容都可以被正确地输出。
     <font color="red">
      std::cout就是对应于用户控制台或标准输出的滑槽
     </font>
     ，此外还有其他滑槽，包括
     <font color="blue">
      用于输出错误信息的std::cerr
     </font>
     。&lt;&lt;运算符将数据放入滑槽，在前面的示例中，引号中的文本字符串被送到标准输出。输出流可在一行代码中连续输出多个不同类型的数据，如下面的代码所示。
     <br/>
     <code>
      std::cout &lt;&lt; "There are " &lt;&lt; 219 &lt;&lt; " ways I love you." &lt;&lt; std::endl;
     </code>
     <br/>
     从C++20开始，
     <font color="red">
      推荐的写法是使用std::format()，定义在中，用来格式化字符串
     </font>
     。如
     <code>
      std::cout &lt;&lt; std::format("There are {} ways I love you.", 219) &lt;&lt; std::endl;
     </code>
     。std::endl代表序列的结尾。当输出流遇到std::endl时，就会将已送入滑槽的所有内容输出并转移到下一行。
    </p>
    <h4>
     <a id="142__85">
     </a>
     1.4.2 转义字符
    </h4>
    <p>
     表明一行结尾的另一种方法是使用\n字符，\n字符是一个转义字符，这是一个换行符。转义字符可以在任何被引用的文本字符串中使用。
    </p>
    <table>
     <thead>
      <tr>
       <th align="left">
        转义字符
       </th>
       <th align="left">
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="left">
        \n
       </td>
       <td align="left">
        换行：将光标移到下一行的开头
       </td>
      </tr>
      <tr>
       <td align="left">
        \r
       </td>
       <td align="left">
        回车：将光标移到本行的开头
       </td>
      </tr>
      <tr>
       <td align="left">
        \t
       </td>
       <td align="left">
        制表符
       </td>
      </tr>
      <tr>
       <td align="left">
        \
       </td>
       <td align="left">
        反斜杠字符
       </td>
      </tr>
      <tr>
       <td align="left">
        "
       </td>
       <td align="left">
        引号
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <font color="red">
      警告
     </font>
     ：请记住endl会在流中插入新的一行，并且将当前缓冲区中的所有内容刷出滑槽。
     <font color="blue">
      不建议过度地使用endl
     </font>
     ，例如在循环中使用，这会影响程序的性能。另一方面，在流中插入\n也会插入新的一行，但不会自动刷新缓冲区。
    </p>
    <h4>
     <a id="143__96">
     </a>
     1.4.3 输入流
    </h4>
    <p>
     流还可用于接收用户的输入，最简单的方式是在输入流中使用&gt;&gt;运算符。
     <font color="red">
      std::cin输入流接受用户的键盘输入
     </font>
     。示例如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> value<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> value<span class="token operator">:</span>
</code></pre>
    <p>
     需要慎重对待用户输入，因为永远都不会知道用户会输入什么类型的数据。
     <br/>
     如果你拥有C的背景知识但初次接触C++，你可能想了解过去使用的、可靠的printf()和scanf()现在究竟是什么情况。尽管C++中仍然可以使用这些函数，但
     <font color="red">
      强烈建议你改用format()和流库
     </font>
     ，主要原因是printf()和scanf()未提供类型安全。
    </p>
    <h2>
     <a id="2__104">
     </a>
     2. 名称空间
    </h2>
    <h3>
     <a id="21__105">
     </a>
     2.1 定义名称空间
    </h3>
    <p>
     名称空间用来处理不同代码段之间的名称冲突问题。例如，你某天编写了一段代码，其中有一个名为foo()的函数。某天，你决定用第三库，其中也有一个foo()函数。编译器无法判断你的代码要使用哪个版本的foo()函数。库函数的名称无法改变，而改变自己的函数名称又会感觉到痛苦。
     <br/>
     在此类情况下使用名称空间，从而指定定义名称的环境。为将某段代码加入名称空间，可用namespace块将其包含。示例如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">namespace</span> mycode <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo() called in the mycode namespace"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     将你编写的foo()版本放到名称空间mycode后，这个函数就与第三方库提供的foo()函数区分开来。为调用启用了名称空间的foo()版本，需要使用::在函数名称之前给出名称空间，
     <font color="red">
      ::称为作用域解析运算符
     </font>
     。
     <br/>
     <code>
      mycode::foo();
     </code>
    </p>
    <h3>
     <a id="22_using_117">
     </a>
     2.2 using指令
    </h3>
    <p>
     mycode名称空间中的任何代码都可调用该名称空间内的代码，而不需要显式说明该名称空间。隐式的名称空间可使代码清晰并易于阅读。
     <font color="red">
      可使用using指令避免预先指明名称空间
     </font>
     。这个指令通知编译器，后面的代码将使用指定名称空间中的名称。示例如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> mycode<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Implies mycode::foo();</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <font color="red">
      一个源文件中可包含多条using指令，这种方法虽然便捷，但注意不要过度使用
     </font>
     。极端情况下，如果你使用了已知的所有名称空间，实际上就是完全取消了名称空间。如果使用了两个同名的名称空间，将再次出现名称冲突问题。另外，应该知道代码在哪个名称空间内运行，这样就不会无意中调用错误版本的函数。
     <br/>
     <font color="blue">
      可以使用using指令引用名称空间内的特定项
     </font>
     。例如，想要只使用std名称空间中的cout，可以使用如下的using声明：
     <br/>
     <code>
      using std::cout;
     </code>
     <br/>
     后面的代码可以使用cout而不需要预先指明这个名称空间，但仍然需要显式说明std名称空间中的其他项。
     <br/>
     <font color="red">
      警告
     </font>
     ：切勿在全局作用域的头文件中使用using指令或using声明，否则添加你的头文件的每个人都必须使用它。
     <font color="blue">
      将其放在较小的作用域，例如名称空间或类作用域中，是可以的，甚至是在文件头部。将using指令或using声明放在模块接口文件中也是不错的选择，只要你不将它导出
     </font>
     。
    </p>
    <h3>
     <a id="23__131">
     </a>
     2.3 嵌套名称空间
    </h3>
    <p>
     嵌套的名称空间，即将一个名称空间放在另一个名称空间中。各个名称空间之间由双冒号隔开，示例如下：
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">namespace</span> MyLibraries<span class="token double-colon punctuation">::</span>Networking<span class="token double-colon punctuation">::</span>FTP <span class="token punctuation">{<!-- --></span>
	<span class="token comment">/*...*/</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这种紧凑写法是在C++17之后才得到支持的，在C++17之前，必须按如下方式使用嵌套的名称空间。
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">namespace</span> MyLibraries <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">namespace</span> Networking <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">namespace</span> FTP <span class="token punctuation">{<!-- --></span>
			<span class="token comment">/*...*/</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="24__148">
     </a>
     2.4 名称空间别名
    </h3>
    <p>
     可使用名称空间别名，为另一个名称空间指定一个更简短的新名称。示例如下
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">namespace</span> MyFTP <span class="token operator">=</span> MyLibraries<span class="token double-colon punctuation">::</span>Networking<span class="token double-colon punctuation">::</span>FTP<span class="token punctuation">;</span>
</code></pre>
    <h2>
     <a id="_153">
     </a>
     参考
    </h2>
    <p>
     [比] 马克·格雷戈勒著 程序喵大人 惠惠 墨梵 译 C++20高级编程(第五版)
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f35313138303932382f:61727469636c652f64657461696c732f313436313034333634" class_="artid" style="display:none">
 </p>
</div>


