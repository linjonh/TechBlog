---
layout: post
title: "FlutterStatelessWidget-vs-StatefulWidget-深度解析"
date: 2025-03-10 09:00:00 +0800
description: "在 Flutter 中，所有的 UI 组件都是由 Widget 组成，而 Widget 又分为两大类：StatelessWidget（无状态组件） 和 StatefulWidget（有状态组件）。StatelessWidget 适用于不会随时间变化的 UI，如文本、图标等静态内容；StatefulWidget 则适用于需要动态更新的 UI，如用户交互、动画、网络请求等。本文将深入解析这两种 Widget 的本质区别、适用场景以及生命周期，帮助开发者更好地理解 Flutter 组件的运行机制。"
keywords: "Flutter：StatelessWidget vs StatefulWidget 深度解析"
categories: ['Flutter']
tags: ['小程序', 'Webview', 'Swift', 'Studio', 'Ios', 'Flutter', 'Android']
artid: "146066840"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146066840
    alt: "FlutterStatelessWidget-vs-StatefulWidget-深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146066840
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146066840
cover: https://bing.ee123.net/img/rand?artid=146066840
image: https://bing.ee123.net/img/rand?artid=146066840
img: https://bing.ee123.net/img/rand?artid=146066840
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Flutter：StatelessWidget vs StatefulWidget 深度解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 id="1.%20%E5%BC%95%E8%A8%80" name="1.%20%E5%BC%95%E8%A8%80">
     <span style="color:#ed7976">
      1. 引言
     </span>
    </h3>
    <p>
     Flutter 是 Google 开发的跨平台 UI 框架，所有界面元素都是由
     <strong>
      Widget
     </strong>
     组成。Flutter 中的 Widget 分为
     <strong>
      StatelessWidget（无状态组件）
     </strong>
     和
     <strong>
      StatefulWidget（有状态组件）
     </strong>
     ，它们在开发过程中扮演着不同的角色。本文将深入解析这两类组件的特点、适用场景及生命周期，并通过示例代码帮助开发者理解如何正确选择和使用它们。
    </p>
    <h3 id="2.%20StatelessWidget%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%89" name="2.%20StatelessWidget%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%89">
     <span style="color:#ed7976">
      2. StatelessWidget（无状态组件）
     </span>
    </h3>
    <h4 id="2.1%20%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9" name="2.1%20%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9">
     <span style="color:#956fe7">
      2.1 定义与特点
     </span>
    </h4>
    <p>
     <strong>
      StatelessWidget
     </strong>
     是指
     <span style="color:#fe2c24">
      不可变的组件
     </span>
     ，它的 UI 由
     <code>
      build()
     </code>
     方法描述，并且不会因用户交互或数据变化而发生更新。
    </p>
    <p>
     <strong>
      主要特点：
     </strong>
    </p>
    <ul>
     <li>
      组件状态不可变（immutable）。
     </li>
     <li>
      仅依赖输入数据（
      <code>
       final
      </code>
      变量）。
     </li>
     <li>
      <code>
       build()
      </code>
      方法只会被调用一次，除非父组件触发更新。
     </li>
     <li>
      适用于静态 UI（如文本、按钮、图标）。
     </li>
    </ul>
    <h4 id="2.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" name="2.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
     <span style="color:#956fe7">
      2.2 代码示例
     </span>
    </h4>
    <pre><code class="language-Dart">import 'package:flutter/material.dart';

class MyStatelessWidget extends StatelessWidget {
  final String text;

  const MyStatelessWidget({super.key, required this.text});

  @override
  Widget build(BuildContext context) {
    return Text(text);
  }
}

void main() {
  runApp(MaterialApp(
    home: Scaffold(
      body: Center(
        child: MyStatelessWidget(text: 'Hello, Flutter!'),
      ),
    ),
  ));
}
</code></pre>
    <p>
     <strong>
      示例解析
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       MyStatelessWidget
      </code>
      组件接收
      <code>
       text
      </code>
      作为参数，无法在运行时改变。
     </li>
     <li>
      组件不会因外部状态变化而重新构建，适用于静态文本。
     </li>
    </ul>
    <p class="img-center">
     <img alt="" height="315" src="https://i-blog.csdnimg.cn/direct/092535e08c2c46c1a726c78a2b5b8242.png" width="300"/>
    </p>
    <h3 id="3.%20StatefulWidget%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%89" name="3.%20StatefulWidget%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%89">
     <span style="color:#ed7976">
      3. StatefulWidget（有状态组件）
     </span>
    </h3>
    <h4 id="3.1%20%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9" name="3.1%20%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9">
     <span style="color:#956fe7">
      3.1 定义与特点
     </span>
    </h4>
    <p>
     <strong>
      StatefulWidget
     </strong>
     适用于 UI
     <span style="color:#fe2c24">
      需要动态变化的场景
     </span>
     。它由
     <strong>
      两部分
     </strong>
     组成：
    </p>
    <ol>
     <li>
      <strong>
       StatefulWidget 类
      </strong>
      （负责创建 State）。
     </li>
     <li>
      <strong>
       <span style="color:#fe2c24">
        State
       </span>
       类
      </strong>
      （持有可变状态，并控制 UI 更新）。
     </li>
    </ol>
    <p>
     <strong>
      主要特点：
     </strong>
    </p>
    <ul>
     <li>
      UI 组件可变（mutable）。
     </li>
     <li>
      通过
      <code>
       setState()
      </code>
      触发 UI 更新。
     </li>
     <li>
      适用于用户交互、动画、异步数据加载等场景。
     </li>
    </ul>
    <h4 id="3.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" name="3.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">
     <span style="color:#956fe7">
      3.2 代码示例
     </span>
    </h4>
    <pre><code class="language-Dart">import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  final String title;
  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  int _counter = 0;
  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: Text(widget.title),
      ),
      body: Center(
        child:  Column(
          children: [
            Text('Count: $_counter'),
            ElevatedButton(
              onPressed: _incrementCounter,
              child: Text('Increment'),
            ),
          ],
        )
      ),
    );
  }
}
</code></pre>
    <p>
     <strong>
      示例解析
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       _incrementCounter
      </code>
      通过
      <code>
       setState()
      </code>
      更新
      <code>
       _counter
      </code>
      变量。
     </li>
     <li>
      每次按钮点击时，
      <code>
       setState()
      </code>
      触发
      <code>
       build()
      </code>
      方法重新执行，刷新 UI。
     </li>
    </ul>
    <h3 id="4.%20StatelessWidget%20vs%20StatefulWidget%20%E5%AF%B9%E6%AF%94" name="4.%20StatelessWidget%20vs%20StatefulWidget%20%E5%AF%B9%E6%AF%94" style="background-color:transparent">
     <span style="color:#ed7976">
      4. StatelessWidget vs StatefulWidget 对比
     </span>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        StatelessWidget
       </th>
       <th>
        StatefulWidget
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         是否可变
        </strong>
       </td>
       <td>
        不可变
       </td>
       <td>
        可变
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         状态管理
        </strong>
       </td>
       <td>
        依赖父组件传递数据
       </td>
       <td>
        组件内部维护状态
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        静态 UI（如文本、按钮、图标）
       </td>
       <td>
        交互组件（如计数器、表单）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         性能
        </strong>
       </td>
       <td>
        性能较优
       </td>
       <td>
        需要手动管理状态，可能影响性能
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         快捷创建
        </strong>
       </td>
       <td>
        <span style="color:#fe2c24">
         <strong>
          stless
         </strong>
        </span>
       </td>
       <td>
        <span style="color:#fe2c24">
         <strong>
          stful
         </strong>
        </span>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="img-center">
     <img alt="" height="159" src="https://i-blog.csdnimg.cn/direct/bf4659b5c4b049d7938a918a88cdfd98.png" width="500"/>
    </p>
    <p>
     例如创建 StatefulWidget，我们输入stful 回车，会自动出现下方代码，而不需要我们自己编写这种格式，自己仅需要修改 build 中的 UI 内容即可。
    </p>
    <p>
     <img alt="" height="840" src="https://i-blog.csdnimg.cn/direct/f8fc3d1ffbaf4b86b3f444d667b2bab4.png" width="1060">
     </img>
    </p>
    <h3 id="5.%20StatefulWidget%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" name="5.%20StatefulWidget%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">
     <span style="color:#ed7976">
      5. StatefulWidget 生命周期
     </span>
    </h3>
    <p>
     StatefulWidget 的生命周期由多个回调方法组成，理解这些方法有助于优化组件的性能。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        生命周期方法
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         <span style="color:#fe2c24">
          initState
         </span>
         ()
        </code>
       </td>
       <td>
        组件创建时调用，仅执行一次，适用于初始化数据。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         didChangeDependencies()
        </code>
       </td>
       <td>
        依赖发生变化时调用，如
        <code>
         InheritedWidget
        </code>
        更新。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         <span style="color:#fe2c24">
          build
         </span>
         ()
        </code>
       </td>
       <td>
        组件渲染 UI，可能多次调用。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         <span style="color:#fe2c24">
          setState
         </span>
         ()
        </code>
       </td>
       <td>
        触发状态更新并重新构建 UI。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         didUpdateWidget()
        </code>
       </td>
       <td>
        父组件更新时调用，可用于响应外部数据变化。
       </td>
      </tr>
      <tr>
       <td>
        <code>
         dispose()
        </code>
       </td>
       <td>
        组件销毁时调用，释放资源（如取消网络请求、关闭流）。
       </td>
      </tr>
     </tbody>
    </table>
    <h4 id="5.1%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A4%BA%E4%BE%8B" name="5.1%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A4%BA%E4%BE%8B">
     <span style="color:#956fe7">
      5.1 生命周期示例
     </span>
    </h4>
    <pre><code class="language-Dart">class LifecycleDemo extends StatefulWidget {
  @override
  _LifecycleDemoState createState() =&gt; _LifecycleDemoState();
}

class _LifecycleDemoState extends State&lt;LifecycleDemo&gt; {
  @override
  void initState() {
    super.initState();
    print('initState called');
  }

  @override
  Widget build(BuildContext context) {
    print('build called');
    return Text('Lifecycle Demo');
  }

  @override
  void dispose() {
    print('dispose called');
    super.dispose();
  }
}
</code></pre>
    <h3 id="6.%20%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9%20StatelessWidget%20%E6%88%96%20StatefulWidget%EF%BC%9F" name="6.%20%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9%20StatelessWidget%20%E6%88%96%20StatefulWidget%EF%BC%9F">
     <span style="color:#ed7976">
      6. 何时选择 StatelessWidget 或 StatefulWidget？
     </span>
    </h3>
    <h4 id="6.1%20%E9%80%89%E6%8B%A9%20StatelessWidget" name="6.1%20%E9%80%89%E6%8B%A9%20StatelessWidget">
     <span style="color:#956fe7">
      6.1 选择 StatelessWidget
     </span>
    </h4>
    <ul>
     <li>
      <strong>
       UI 仅依赖父组件的参数
      </strong>
      。
     </li>
     <li>
      <strong>
       组件不需要持有内部状态
      </strong>
      。
     </li>
     <li>
      <strong>
       适用于简单的文本、图标、按钮等静态内容
      </strong>
      。
     </li>
    </ul>
    <h4 id="6.2%20%E9%80%89%E6%8B%A9%20StatefulWidget" name="6.2%20%E9%80%89%E6%8B%A9%20StatefulWidget">
     <span style="color:#956fe7">
      6.2 选择 StatefulWidget
     </span>
    </h4>
    <ul>
     <li>
      <strong>
       组件的 UI 需要根据用户交互或数据变化而更新
      </strong>
      。
     </li>
     <li>
      <strong>
       组件需要维护内部状态，例如计数器、动画、表单输入等
      </strong>
      。
     </li>
     <li>
      <strong>
       涉及异步数据加载（如网络请求）
      </strong>
      。
     </li>
    </ul>
    <h3 id="7.%20%E6%80%BB%E7%BB%93" name="7.%20%E6%80%BB%E7%BB%93">
     <span style="color:#ed7976">
      7. 总结
     </span>
    </h3>
    <ul>
     <li>
      Flutter 中 Widget 分为
      <strong>
       StatelessWidget
      </strong>
      （无状态组件）和
      <strong>
       StatefulWidget
      </strong>
      （有状态组件）。
     </li>
     <li>
      StatelessWidget 适用于静态 UI，而 StatefulWidget 适用于需要动态更新的 UI。
     </li>
     <li>
      StatefulWidget 依赖
      <strong>
       setState()
      </strong>
      进行状态更新，并具有完整的生命周期管理。
     </li>
     <li>
      选择合适的 Widget 类型可以提高应用性能，并优化用户体验。
     </li>
    </ul>
    <h3 id="%E7%9B%B8%E5%85%B3%E6%8E%A8%E8%8D%90" name="%E7%9B%B8%E5%85%B3%E6%8E%A8%E8%8D%90">
     <span style="color:#ed7976">
      相关推荐
     </span>
    </h3>
    <p>
     <a class="has-card" href="https://shuaici.blog.csdn.net/article/details/145752085" rel="nofollow" title="Flutter 布局入门指南：掌握核心技巧，轻松构建精美界面_flutter 布局详解,必知必会-CSDN博客">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        Flutter 布局入门指南：掌握核心技巧，轻松构建精美界面_flutter 布局详解,必知必会-CSDN博客
       </span>
       <span class="link-desc">
        文章浏览阅读1.3k次，点赞56次，收藏53次。Flutter 的布局系统以其灵活性和高效性著称，但对于刚入门的开发者来说，面对琳琅满目的布局 Widget，可能会感到不知所措。本文将带你快速掌握 Flutter 布局的核心技巧，避开常见陷阱，并提供实用代码示例，助你轻松实现复杂界面设计。_flutter 布局详解,必知必会
       </span>
       <span class="link-link">
        <img alt=" " class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico">
         https://shuaici.blog.csdn.net/article/details/145752085
        </img>
       </span>
      </span>
     </a>
     <a class="has-card" href="https://shuaici.blog.csdn.net/article/details/145811726" rel="nofollow" title="Android内存优化指南：从数据结构到5R法则的全面策略_android 内存管理指南-CSDN博客">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        Android内存优化指南：从数据结构到5R法则的全面策略_android 内存管理指南-CSDN博客
       </span>
       <span class="link-desc">
        文章浏览阅读1.5k次，点赞67次，收藏62次。Android内存优化涉及多个方面，从选择合适的数据结构如ArrayMap和SparseArray以减少内存占用，到避免使用内存开销大的枚举类型。谨慎使用多进程和large heap选项，同时充分利用NDK进行内存管理。图片优化是关键，通过采样、缓存和格式转换等方式减少内存占用。此外，遵循5R法则——释放、回收、减少、重用和检查，确保资源得到有效管理。这些策略共同构成了一套全面的Android内存优化方案，有助于提升应用性能和用户体验。_android 内存管理指南
       </span>
       <span class="link-link">
        <img alt=" " class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico">
         https://shuaici.blog.csdn.net/article/details/145811726
        </img>
       </span>
      </span>
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f673938343136303534372f:61727469636c652f64657461696c732f313436303636383430" class_="artid" style="display:none">
 </p>
</div>


