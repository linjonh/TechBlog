---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37313936343738302f:61727469636c652f64657461696c732f313334343831343034"
layout: post
title: "Linux进程解析冯诺依曼体系结构,操作系统,进程初步解析"
date: 2025-02-22 17:58:56 +08:00
description: "Linux进程解析：冯诺依曼体系结构，操作系统，"
keywords: "Linux进程解析(冯诺依曼体系结构，操作系统，进程初步解析)"
categories: ['Linux']
tags: ['运维', '笔记', '深度学习', '服务器', 'Linux']
artid: "134481404"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=134481404
    alt: "Linux进程解析冯诺依曼体系结构,操作系统,进程初步解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=134481404
featuredImagePreview: https://bing.ee123.net/img/rand?artid=134481404
---

# Linux进程解析(冯诺依曼体系结构，操作系统，进程初步解析)

## 

## 冯诺依曼体系结构：

我们常见的计算机，如笔记本。
**我们常见的计算机，服务器，大部分都遵守冯诺依曼体系。**

![](https://i-blog.csdnimg.cn/blog_migrate/73ab51e70038f4e5e2540a8de2909f5e.jpeg)

> 截至目前，我们所认识的计算机，都是有一个个的
> **硬件组件组成：**
>   
> **中央处理器(CPU)：含有运算器和控制器等；**
>
> **输入单元：包括键盘, 鼠标，扫描仪, 写板、话筒、摄像头、磁盘、网卡等；
>   
> 输出单元：显示器，打印机、声卡、显卡、网卡、磁盘等；**
>
> **以上的设备有的只做输入，或者只做输出，有的即做输入又做输出。**

> **关于冯诺依曼，必须强调几点：
>   
>
> 1.这里的存储器指的是内存，特点是：断电后在内存的数据会丢失(掉电易失)！
>   
>
> 2.不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取。
>   
> 一句话，
> 所有设备都只能直接和内存打交道。**

> ![](https://i-blog.csdnimg.cn/blog_migrate/6c62a276579004bba9b0740be25b5e2f.png)
>
> **效率越高，造价贵单体容量越小距离CPU越近的存储单元，**
>
> **距离CPU越远的存储单元，效率越低，造价便宜，单体容量大**

> **各个设备之间是用总线连接在主板上的，目的：数据在设备之间流动(本质是设备之间会进行数据的来回拷贝，拷贝的整体速度，是决定计算机效率的重要指标！)**
>
> **为什么在体系结构中要存在内存？**
>
> **答：以一个文本文件为例：CPU的速度是非常快的，而键盘的输入和显示是我们写的速度决定的， 这样就导致CPU在效率上就过度的浪费，所以引入内存，可以理解为一个非常大的缓存，介于设备和CPU之间，这样计算机效率就变成了内存效率问题，并且由于内存的引入，让我们在计算机效率不错还比较便宜的情况下，让老百姓使用。**

> 对冯诺依曼的理解，不能停留在概念上，要深入到对软件数据流理解上，请解释，从你登录上qq开始和某位朋友聊天开始，数据的流动过程。从你打开窗口，开始给他发消息，到他的到消息之后的数据流动过程。
> **如果是在qq上发送文件呢？**
>
> **答：我们在键盘进行输入，然后将数据交给内存，由内存将数据给CPU处理打包，然后返回给内存，内存再将打包好的数据交给网卡，另一个人的网卡接受到数据，交给内存，内存再给CPU处理解包，然后输出到显示器上。**

![](https://i-blog.csdnimg.cn/blog_migrate/3af3a85b00ac91d259ca43706e9641ab.png)

## 操作系统

### 概念：

> **任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。**
>
> **笼统的理解，操作系统包括：
>   
> 内核（进程管理，内存管理，文件管理，驱动管理）
>   
> 其他程序（例如函数库，shell程序等等）**

### 设计OS的目的：

> **1.与硬件交互，管理所有的软硬件资源
>   
> 2.为用户程序（应用程序）提供一个良好的执行环境**
>
> **当我们
> 将电脑开机，第一个被加载的软件是操作系统，**
>
> **操作系统是一个进行软硬件资源管理的软件。**

![](https://i-blog.csdnimg.cn/blog_migrate/69ec741323ff926feb8f1c2126b5dcf8.png)

> **以操作系统、驱动程序、底层硬件讲解：**
>
> **每一个硬件都有对应的驱动！！！**
>
> **以校园生活为背景：**
>
> **校长(管理者)、辅导员(保证管理决策的落地)、学生(被管理者)**
>
> **首先我们应该知道管理者与被管理者，并不需要见面，
> 管理的本质不在于对人做管理，而在于对人的信息(数据)做管理，管理者核心工作是做决策，根据数据做决策。**
>
> **先描述，再组织：**
>
> **以面向对象语言为例：**
>
> **从历史的角度：**
>
> **我们要对一个事物进行管理，首先要知道他们的属性：如：名字，学号，年龄……信息，有了这些信息我们将他们写成一个结构体，这就是先描述！！！**
>
> **我们再用不同的STL容器(string、list、map……)将数据统一管理就是再组织！！**
>
> **最后按不同的需求来对数据的增删改查！**
>
> **预测未来：**
>
> **如果你要做一件事情第一步：先描述(struct/class);**
>
> **做一件事情的第二步：再组织——>容器(数据结构)**
>
> **最后把你对数据的管理场景转化成为对特点数据结构的增删改查！**
>
> **以上将具体问题，进行计算机级别的建模过程！转成计算机能够认识的问题！**

> **系统调用和库函数概念：**
>   
> **在开发角度**
> ，
> **操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。**
>   
> **系统调用在使用上**
> ，
> **功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。**

> **1.为什么要有操作系统？**
>
> **需要去管理软硬件；**
>
> **2.为什么要有操作系统的管理？**
>
> **对下：管理好软硬件资源——手段**
>
> **对上：提供一个良好(稳定、高效、安全)的环境——目的**
>
> **比如：一个用户去银行存钱，是自己拿到金库中，取钱也是自己去金库拿，这样必然会出现问题！！！**
>
> **所以在操作系统中，需要一个把用户和操作系统进行分隔的区间，所以就有了系统接口，它是由操作系统提供的系统调用函数。**
>
> **比如：用户在一个程序中用了printf这个函数，它会调用已经封装好系统调用的用户操作接口lib库，所有的操作都不能越级访问，必须按级调用**
>
> **比如一个printf可以实现在windows和Linux上使用，调用设计者提供的lib库来实现对系统调用接口向下实现**
> ​​​​​​​

## 进程：

> **描述进程-PCB**
>   
> **进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合。**
>   
> 课本上称之为PCB（process control block），
> **Linux操作系统下的PCB是: task_struct**
>
> **task_struct-PCB的一种**
>   
>
> **在Linux中描述进程的结构体叫做task_struct。**
>   
> **task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息**

> **task_ struct内容分类
>   
> 标示符: 描述本进程的唯一标示符，用来区别其他进程。（pid）
>   
> 状态: 任务状态，退出代码，退出信号等。
>   
> 优先级: 相对于其他进程的优先级。
>   
> 程序计数器: 程序中即将被执行的下一条指令的地址。
>   
> 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
>   
> 上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
>   
> I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
>   
> 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
>   
> 其他信息**

> **事实
>   
> 1.我们可以同时启动多个程序--- 我们一定要将多个.exe加载到内存**
>
> **2.操作系统要不要管理多个加载到内存的程序呢??要的**
>
> **2.操作系统如何管理加载到内存的程序呢? 先描述，在组织！！！**

> **进程=内核PCB对象(内核数据结构)+可执行程序**
>
> **所有对进程的控制和操作，都只和进程的PCB有关，与进程的可执行程序无关！！！**
>
> **如：需要启动多个程序，也是PCB去排队来等待调度！！！**
>
> **因此，对进程的管理，转化为对PCB对象的管理，就可以通过对数据结构的增删改查来实现对进程的管理！！！**

### 扩展：

> **程序计数器(pc指针 / eip寄存器):指向将被执行的下一条指令的地址。**
>
> **当程序运行到判断,循环,函数跳转这些语法时本质都是修改pc指针/eip寄存器，pc指针/eip寄存器指向哪一个进程的代码,就表示哪一个进程是下一个要被调度运行！！！**

### 在Linux关于进程的相关操作：

#### 查看进程信息：

> **进程的信息可以通过 /proc 系统文件夹查看。**

![](https://i-blog.csdnimg.cn/blog_migrate/1e6817155328c95ec11f31394cca111b.png)

**写一个死循环程序来，查看进程的执行：**

![](https://i-blog.csdnimg.cn/blog_migrate/b18e40c82a84d3eca57000f57e99d224.png)

**ps ajx | head -1 && ps -ajx | grep myprocess(编译结束后的文件名)**

![](https://i-blog.csdnimg.cn/blog_migrate/d624fe265fded1712af9e898c66e3d7a.png)

**查看进程里的信息：
ls /proc/进程pid**

![](https://i-blog.csdnimg.cn/blog_migrate/698be5742ff2ca7f2efc239f20c239c8.png)

**更改cwd(当前工作目录):更改为/home/LFH路径**

![](https://i-blog.csdnimg.cn/blog_migrate/4807f162d91590c026d8c6fc1484c7ac.png)

![](https://i-blog.csdnimg.cn/blog_migrate/2a721946d262362948f0bff38160bace.png)

![](https://i-blog.csdnimg.cn/blog_migrate/950445ae81a2ba35a16285f3261377d2.png)

> **我们创建一个文件会去找到对应的cwd，然后在这个路径下创建对应的文件。**
>
> **通过更改cwd，此时我们成功将110.txt创建到/home/LFH这个路径下。**

#### 通过系统调用获取进程标示符(pid)：

**1.getpid()和getppid()**

![](https://i-blog.csdnimg.cn/blog_migrate/98d46d434a596dcfcd9f010c76981a72.png)

**2.查看进程pid和父进程pid：**

![](https://i-blog.csdnimg.cn/blog_migrate/08172e3f54c05675c5cd8b1f83ed12b1.png)

![](https://i-blog.csdnimg.cn/blog_migrate/8fa78bdc5d78b451027e11ff5b99c618.png)

> **特别注意：**
>
> **1.每次执行这个编译好的程序，操作系统分配的pid会不相同，运行结束就进程就会销毁，再次运行又会重新分配！！！**
>
> **2.而每次运行的父进程相同都是bach(即：上面的14047)，每个进程都有它的父进程，而bash就是process的父进程，也是shell外壳的一种！**

**3.fork()函数**

![](https://i-blog.csdnimg.cn/blog_migrate/e44b0b795651cd3bfe418a7bf23da482.png)

![](https://i-blog.csdnimg.cn/blog_migrate/c7b0118a664ea668932f7427f7d3bcb1.png)

> **用fork()函数创建子进程，如果创建成功父进程的返回值是子进程的pid，子进程的返回值为0；如果创建失败父进程返回值为-1.**

4.创建子进程

![](https://i-blog.csdnimg.cn/blog_migrate/d5996740c97ece78897c927dcb0e669c.png)

![](https://i-blog.csdnimg.cn/blog_migrate/ad35ae1e5b4046abbf4116f6a0e6a599.png)

> **运行后发现父进程和子进程都在执行！！！**

**总结：**

> **用fork()函数创建子进程后：**
>
> **1.父子进程会共用代码块；**
>
> **2.在父子进程进行代码共享时，父进程会把PCB中的部分数据给子进程，但是比如pid就不会给，所以当创建子进程后，子进程也会执行后面的代码；**
>
> **3.因为代码共享，所以对应如果需要改变代码中的数据，各个进程会创建属于自己的数据区，用于存放自己改变的数据(写时拷贝)。**
>
> **4.创建子进程的目的：因为有些事情我们的父进程不想做，还有其他的事要做，所以创建一个子进程，然后通过if -else语句让它们去执行它们各个需要去做的事情！！！**

**5.进程之间具有相互独立性**

> **任意一个进程之间具有相对独立性，相互之间没有影响！！！**

> **即使父进程和子进程亲如父子,但是当我们的子进程和父进程都运行起来之后,子进程挂了,代码也仍会存在,对父进程无影响，父进程挂了,代码也仍会存在,对子进程无影响！！！**
>
> **因为程序被加载到内存，运行起来后，
> 进程里存放的是程序的拷贝数据。**

**以上就是个人学习的见解和学习过程的解析，欢迎各位大佬在评论区探讨，交流！**

**如果本篇对你有帮助的话，三连支持一下吧。**

**感谢大佬们的三连！ 感谢大佬们的三连！ 感谢大佬们的三连！**

**![](https://i-blog.csdnimg.cn/blog_migrate/23520666c57419622fc185943d97f065.png)**