---
layout: post
title: ".Net技术栈梳理01-核心框架与运行时CLR"
date: 2025-09-08T00:06:36+0800
description: ".NET的核心框架和运行时（CLR）是其跨平台、高性能特性的基础。CLR通过将源代码编译为中间语言（IL），再通过即时编译（JIT）转换为本地机器码执行，实现了跨平台能力。JIT编译器按需编译方法代码，并进行验证和优化，同时垃圾回收器（GC）自动管理内存，基于分代假说将对象分为0/1/2代进行高效回收。现代.NET还支持分层编译和AOT预编译，进一步优化性能。GC采用分代收集和标记压缩算法，针对不同应用场景提供工作站和服务器两种模式，确保内存管理的高效性。"
keywords: "【.Net技术栈梳理】01-核心框架与运行时（CLR）"
categories: ['.NET技术栈']
tags: ['开发语言', '.Net']
artid: "151176702"
arturl: "https://blog.csdn.net/Tiger_shl/article/details/151176702"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151176702
    alt: ".Net技术栈梳理01-核心框架与运行时CLR"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151176702
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151176702
cover: https://bing.ee123.net/img/rand?artid=151176702
image: https://bing.ee123.net/img/rand?artid=151176702
img: https://bing.ee123.net/img/rand?artid=151176702
---



# 【.Net技术栈梳理】01-核心框架与运行时（CLR）



核心框架与运行时是.NET的基石，决定了能开发什么类型的应用已经如何运行。

## 1 .NET Runtime（CLR-公共语言运行时）

负责执行编译后的代码（中间语言，IL）、内存管理（垃圾回收GC）、异常处理、线程管理等。是所有.Net应用的引擎

### 1.1 中间语言 IL

> .Net运行时(CLR)执行编译后的代码(中间语言,IL)是一个核心过程，理解这个过程就能明白跨平台、安全性、高性能等特性的基础。

整个过程可以概括为一下**关键阶段**

1. **编写源代码与编译为IL**
2. **分发与部署（包含IL的程序集）**
3. **运行时加载与即时编译（JIT Compilation）**
4. **执行本地代码**
5. **优化与高级特性（分层编译、AOT）**

#### 1.1.1 从源代码到通用中间语言（IL）

当使用 C#、F# 或 VB.NET 编写代码并执行 dotnet build 时，发生的事情与 C/C++ 这样的原生语言完全不同

> * C/C++ (原生编译)：编译器直接将源代码编译为针对特定 CPU 架构（如 x86, ARM）和操作系统的本地机器码。这个代码无法在其他平台上运行
> * .NET (托管编译)：编译器（如 Roslyn for C#）会将源代码编译为一种称为 中间语言 (IL) 或 通用中间语言 (CIL) 的字节码。同时，它还会生成丰富的元数据（描述代码中的类型、成员、引用等信息）

* **IL是什么**

> 可以把IL想象成一种高度抽象、与特定CPU无关的“汇编语言”。它比高级语言更底层，但是比真正的机器码更高级。它包含了ldloc（加载本地变量）、add（相加）、call（调用方法）这样的指令

* **为什么这样做？**

> **关键优势：跨平台和语言互操作性**。IL是一种统一的、标准的输出格式。无论使用的事C#还是F#，最终都变成了IL。这使得.NET运行时只需要理解IL这一种语言，就能运行所有.NET语言编写的程序。同时，因为IL不是特定于某个平台的，所以同一个IL程序集（.dll或.exe）可以分发到任何有相应.NET运行时（CLR）的平台上（Windows、Linux、macOS）

#### 1.1.2 运行时加载：CLR登场

> 当运行一个.NET程序时，操作系统会启动.NET运行时（CLR）。CLR的程序集加载器会负责找到并加载程序集（以及它所依赖的所有程序集）。加载后，CLR会读取其中的元数据和IL代码，为执行做准备。

#### 1.1.3 核心步骤：即时编译 (JIT Compilation)

这是最神奇、最核心的一步，CLR不会直接“解释”执行IL(像早期的Java或Python那样)。相反，它使用一个名为**JIT编译器**（Just-In-Time Compiler）的组件

JIT编译器的工作流程如下：

1. **按需编译**：当一个方法（函数）**第一次**被调用时，JIT编译器才会开始工作。CLR不会在程序启动时就把所有IL都编译成本地代码，这避免了不必要的启动延迟。
2. **读取IL**：JIT编译器从已加载的程序集中获取该方法的IL代码。
3. **验证**：在编译之前，JIT会执行一个重要的**验证**过程。它会检查IL代码是否是**类型安全**的（例如：不会错误地将一个整数当做对象引用来使用）。这个步骤是.NET内存安全和安全沙箱的基石，它能组织大量潜在的内存损坏漏洞。
4. **编译为本地代码**：验证通过后，JIT编译器将IL代码动态地编译成当前所在**平台**的**本地机器码**（x86、x64、ARM等）。这个过程考虑了当前的CPU和操作系统环境。
5. **存储和执行**：编译生成的本地机器码被存储在内存中的一块特定的区域（通常称为JIT代码堆）。然后CLR修改该方法的方法表，使其条目指向这块新生成的本地代码。最后，程序执行这个刚刚编译好的、极其高效的本地代码。

**JIT的优势**

* **跨平台**：  
   同一个IL包，在Windows上JIT编译为x86代码，在Linux上编译为x64代码，在Raspberry Pi上编译为ARM代码。
* **性能优化**：  
   JIT编译器可以进行**运行时优化**。它可以根据程序运行的**实际环境**进行优化。例如，如果它检测到运行程序的CPU支持特定的指令集（如AVX2），它就可以生成使用这些指令的更高效的代码。静态编译器（如C++）在编译时无法知道程序最终会运行在什么CPU上，因此无法做到这一点。
* **节省内存**：  
   只有真正被执行到的代码才会被编译和加载到内存中。

#### 1.1.4 执行与内存管理（GC）

代码已经是以本地机器码的形式在 CPU 上直接执行了，速度非常快。  
 在执行过程中，CLR 的另一个核心组件——垃圾回收器 (Garbage Collector, GC)——会持续工作。它负责自动分配和释放内存。当对象不再被引用时，GC 会自动回收它们占用的内存，开发者无需（也不能）手动释放。这消除了内存泄漏和悬空指针等常见问题。

#### 1.1.5 演进与高级模式：分层编译与 AOT

最初的 JIT 编译策略是“一次性编译”，但现代 .NET（.NET Core 3.0+）引入了更先进的策略：

1. **分层编译 (Tiered Compilation)**

* **第一层 (快速 JIT)**：当一个方法第一次被调用时，JIT会快速地进行编译，生成优化程度较低但编译速度极快的代码。目标是尽快让程序跑起来
* **第二层 (优化 JIT)**：如果发现某个方法被频繁调用（成为“热路径”），CLR会在后台异步地启动一个优化版本的JIT编译器，重新编译该方法，生成高度优化的、更快的本地代码。之后对该方法的调用就会切换到优化版本上。
* **好处：**完美平衡了启动速度和运行速度。

2. **预先编译 (AOT - Ahead of Time)**

* 虽然JIT很棒，但是它的编译过程仍然会在程序运行时产生一些开销（CPU和内存）。对于某些场景（如启动速度极致的App、命令工具），我们希望消除这个开销
* **Native AOT**：.NET提供了Native AOT编译模式。它**在发布时**就直接将IL代码编译为本地可执行文件，**完全不需要**在目标机器上安装.NET运行时，也**没有JIT编译阶段**
* **结果**：生成的文件更大，启动速度极快，但失去了JIT的运行时优化能力。.NET 8和更高版本对Native AOT的支持已经非常完善

**总结与类比**

| 步骤 | .Net（托管） | Java | 传统原生（C/C++） |
| --- | --- | --- | --- |
| **编译** | 源代码 -> **中间语言 (IL)**+ 元数据 | 源代码 -> **字节码 (.class)** | 源代码 -> **本地机器码 (.exe)** |
| **分发** | 包含 IL 的程序集（跨平台） | 包含字节码的 JAR 文件（跨平台） | 特定平台的二进制文件 |
| **执行** | **CLR + JIT** 编译为本地代码并执行 | **JVM + JIT** 编译为本地代码并执行 | 操作系统**直接加载执行** |

可以把一个 .NET 程序想象成：

* **IL** 是一份**标准化的、与烹饪设备无关的菜谱**。
* **CLR** 是一位**厨师（JIT 编译器）和一个厨房（运行时环境）**。
* 厨师**在接到订单（方法调用）时**，根据手头的厨具（CPU 架构）和食材（环境），**现场（Just-In-Time）** 将菜谱翻译成具体的烹饪步骤（本地机器码）并做菜（执行）。

这种方式既保证了菜谱（程序）的通用性，又能让每位厨师（不同平台上的 CLR）利用自己厨房的最优条件做出最好的菜。

### 1.2 CLR运行原理

CLR 是一个复杂的执行环境，它的核心任务是管理 **.NET 代码的执行**，提供内存管理、线程管理、类型安全、异常处理、安全性等一系列关键服务。我们可以将其运行原理分解为以下几个核心阶段和组件：

#### 1.2.1 从源代码到程序集：一切的开端

运行程序之前，旅程早已开始：

1. **编译（Compiler）**：用 C#、F# 或 VB.NET 等高级语言编写代码。编译器（如 C# 的 Roslyn）会将其编译为 **中间语言（IL / CIL**） 和**元数据（Metadata）**，并打包成一个 **程序集（Assembly）**（通常是 .dll 或 .exe 文件）。
   * **IL**：一种与特定 CPU 无关的、类似汇编的指令集。它比高级语言低级，但比原生机器码高级。它是 CLR 的“通用语言”。
   * **元数据**：一个详细的“清单”，描述了程序集中的所有类型、方法、属性、依赖关系等。这使得 CLR 和开发工具能够智能地理解代码结构。
2. **部署（Deployment）**：分发这个包含 IL 和元数据的程序集。它的一个关键优势是跨平台性——同一个 IL 包可以在任何有对应 .NET 运行时（Windows, Linux, macOS）的平台上运行。

#### 1.2.2 运行时加载与初始化

双击一个 .NET.exe 或在命令行中启动它时，操作系统的加载器会识别出这是一个 .NET 程序，并启动相应的**CLR**。

1. **启动 CLR**：操作系统加载 coreclr.dll（对于 .NET Core/.NET 5+）或 clr.dll（对于 .NET Framework），这是 CLR 本身的实现。
2. **创建应用程序域（AppDomain）**：CLR 会为应用程序创建一个逻辑隔离容器，称为应用程序域。它提供了代码加载、执行和卸载的隔离边界（虽然在 .NET Core 中 AppDomain 的隔离性被削弱，概念依然存在）。
3. **加载程序集**：CLR 的程序集加载器（Loader） 找到你的启动程序集（EXE）及其所有依赖项（DLLs），并将它们加载到应用程序域中。它使用元数据来解析所有依赖关系。

#### 1.2.3 JIT 编译：从通用 IL 到原生代码

这是 CLR 最核心、最精妙的部分。CLR 并不直接解释执行 IL，而是采用了一种称为 **即时编译（Just-In-Time Compilation, JIT）** 的技术。

1. **按需编译**：当一个方法（函数）**第一次**被调用时，CLR 才会介入。
2. **验证（Verification）**：在编译之前，**JIT 编译器**会执行一个至关重要的步骤——**验证**。它会分析该方法的 IL 代码，确保它是**类型安全**的（例如，不会将整数当作对象引用来错误使用、不会发生缓冲区溢出）。这是 .NET 内存安全和稳定性的基石，它阻止了绝大多数常见的安全漏洞和程序崩溃。
3. **编译为原生代码**：验证通过后，JIT 编译器将 IL 代码**动态地编译**成当前运行机器的**特定 CPU 架构**（x86, x64, ARM）的**生机器码**。
4. **存储与执行**：编译好的原生代码被存储在内存中的一块特定区域（JIT 代码堆）。CLR 然后会**修补该方法的方法表**，使其条目指向这块新生成的、高效的本地代码。最后，程序**执行这个刚刚编译好的本地代码**。

**JIT 的优势**：

* **跨平台**：一份 IL，处处编译运行。
* **性能优化**：JIT 可以进行**运行时优化**。它知道程序运行的具体硬件环境（CPU 型号、指令集支持），可以生成最适合当前机器的优化代码。这是静态编译器（如 C++）无法做到的。
* **分析引导的优化（PGO）**：现代 .NET 的 JIT 甚至可以观察程序的运行 profile（哪些分支最常走？哪些方法是热路径？），并进行更激进的优化。

#### 1.2.4 执行与管理：CLR 的持续服务

在代码执行过程中，CLR 持续提供关键服务，就像一个全能的管家：

1. **内存管理与垃圾回收（GC）**

   * **分配**：当使用 new 关键字创建对象时，CLR 在**托管堆**上为其分配内存。托管堆是一块由 CLR 连续管理的内存区域，分配速度极快（仅需移动一个指针）。
   * **回收**：**垃圾回收器（Garbage Collector）** 会自动追踪对象的引用。当堆内存不足时，GC 会启动，它从“根对象”开始遍历，标记所有仍在被引用的**存活对象**，然后回收**未被标记**的垃圾对象的内存。之后，它会**压缩**存活对象，消除内存碎片。这个过程完全是自动的，开发者无需关心。
2. **异常处理**

   * CLR 提供了一套结构化的、跨语言的异常处理机制。当异常被抛出时，CLR 会中断当前流程，遍历调用栈，寻找合适的 catch 块来处理异常。如果找不到，则终止进程。
3. **线程管理**

   * CLR 提供了线程池（ThreadPool），高效地管理线程的生命周期，避免频繁创建和销毁线程的巨大开销。它也是 async/await 异步编程模型的底层支撑。
4. **安全性**

   * .NET 提供了基于证据的安全性（如代码的来源、出版商），虽然现在较少使用，但其验证系统本身就是一道强大的安全防线，阻止不安全的代码执行。
5. **互操作性**

   * 通过 **P/Invoke**（平台调用），CLR 允许托管代码调用原生 C/C++ 编写的库（DLLs）。
   * 通过 **COM Interop**，允许 .NET 与传统的 COM 组件进行交互。

#### 1.2.5 演进与高级模式

CLR 也在不断进化，引入了新的编译模式以适应更多场景：

* **ReadyToRun (R2R)**：一种预先编译（Ahead-Of-Time, AOT） 的形式。程序集在发布时就被部分编译为本机代码，减少了应用程序启动时的 JIT 编译开销，从而改善启动性能。它更像是“JIT 预热”的产物。
* **Native AOT**：（.NET 7/8+ 的重点）程序在发布时被完全编译为一个独立的、不依赖 .NET 运行时的原生可执行文件。没有 JIT，没有 IL。代价是失去了 JIT 的运行时优化能力，并且文件更大，但换来了极致的启动速度和更小的部署体积（只包含真正用到的代码）。这是创建独立命令行工具和资源受限环境的理想选择。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bc276e48f1fe48b59ef33ae97c374a4e.png#pic_center)

CLR 的精妙之处在于，它通过 **JIT 编译**和**托管环境**，在**开发效率**（自动内存管理、跨平台、类型安全）、**执行性能**（JIT 优化、高效内存分配）和**安全性**之间取得了非凡的平衡。它让开发者能从繁琐的底层细节中解放出来，专注于实现业务逻辑。



