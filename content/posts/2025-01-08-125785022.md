---
layout: post
title: C语言数据结构知识点小结全
date: 2025-01-08 00:00:00 +08:00
categories: ['C']
tags: ['数据结构', 'C']
image:
    path: https://img-blog.csdnimg.cn/ff61345d6c3049beb4ddc45f6178d4b7.png?x-oss-process=image/resize,m_fixed,h_150
    alt: C语言数据结构知识点小结全
artid: 125785022
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=125785022
featuredImagePreview: https://bing.ee123.net/img/rand?artid=125785022
---

# C语言数据结构知识点小结(全）

#### Catologue

* [C语言数据结构](#C_4)
* + [一、基本概念和术语](#_10)
  + [二、时间、空间复杂度](#_73)
  + - [（1）时间复杂度](#1_75)
    - [（2）空间复杂度](#2_122)
  + [三、类C语言有关操作](#C_135)
  + - * [补充1：数组定义](#1_137)
      * [补充2：动态内存分配](#2_142)
      * [补充3：C++中的参数传递](#3C_150)
  + [四、线性表](#_162)
  + - [（1）定义](#1_164)
    - [（2）线性表的表示和实现](#2_178)
    - * [1、线性表的==顺序==表示和实现](#1_180)
      * [2、顺序表的优缺点](#2_419)
      * [3、线性表的==链式==表示和实现](#3_425)
      * + [a、单链表的实现](#a_460)
        + [b、单向循环链表的实现](#b_819)
        + [c、双向链表的实现](#c_844)
        + [d、双向循环链表的实现](#d_883)
      * [4、链表的优缺点](#4_888)
    - [（3）单链表、循环链表、双向链表的时间效率比较](#3_893)
    - [（4）顺序表和链表的比较](#4_898)
    - [（5）案例引入](#5_903)
    - * [1、线性表的应用](#1_905)
      * [2、一元多项式的运算](#2_936)
      * [3、图书管理系统](#3_961)
  + [五、栈和队列](#_971)
  + - [（1）栈（LIFO）](#1LIFO_975)
    - [（2）栈的表示和实现](#2_984)
    - * [1、栈的==顺序==表示和实现](#1_986)
      * [2、栈的==链式==表示和实现](#2_1177)
    - [（3）栈与==递归==](#3_1373)
    - [（4）队列（FIFO）](#4FIFO_1390)
    - [（5）队列的表示和实现](#5_1394)
    - * [1、队列的==顺序==表示和实现](#1_1396)
      * [2、队列的==链式==表示和实现](#2_1576)
  + [六、串、数组和广义表](#_1751)
  + - [（1）串](#1_1753)
    - [（2）串的表示和实现](#2_1766)
    - * [1、串的==顺序==表示](#1_1768)
      * [2、串的==链式==表示](#2_1784)
      * [3、串的模式匹配算法](#3_1808)
    - [（3）数组](#3_1858)
    - [（4）数组的表示](#4_1871)
    - [（5）广义表](#5_1890)
  + [七、树和二叉树](#_1915)
  + - [（1）树](#1_1917)
    - [（2）二叉树](#2_1931)
    - [（3）二叉树的表示](#3_1965)
    - * [1、二叉树的==顺序==存储结构](#1_1969)
      * [2、二叉树的==链式==存储结构](#2_1991)
    - [（4）二叉树的遍历](#4_2030)
    - * [1、==先序==遍历的实现](#1_2072)
      * [2、==中序==遍历的实现](#2_2087)
      * [3、==后序==遍历的实现](#3_2095)
      * [4、中序遍历的==非递归==算法](#4_2110)
      * [5、二叉树的==层次==遍历](#5_2117)
    - [（5）二叉树遍历算法的==应用==](#5_2129)
    - * [1、二叉树的建立](#1_2131)
      * [2、复制二叉树](#2_2138)
      * [3、计算二叉树的深度](#3_2145)
      * [4、计算二叉树结点的总个数](#4_2152)
      * [5、计算二叉树叶子结点的总个数](#5_2161)
    - [（6）==线索==二叉树](#6_2168)
    - [（7）树的存储结构](#7_2212)
    - * [1、双亲表示法](#1_2214)
      * [2、孩子链表](#2_2237)
      * [3、孩子兄弟表示法（二叉树表示法）](#3_2266)
      * [4、树和二叉树的转换](#4_2286)
      * [5、森林和二叉树的转换](#5_2305)
    - [（8）树与森林的遍历](#8_2317)
    - * [1、树的遍历](#1_2319)
      * [2、森林的遍历](#2_2323)
    - [（9）==哈夫曼树==](#9_2327)
    - [（10）哈夫曼树的表示](#10_2355)
    - * [1、哈夫曼树的==顺序==存储结构](#1_2359)
    - [（11）哈夫曼编码](#11_2395)
  + [八、图](#_2424)
  + - [（1）图的定义](#1_2426)
    - [（2）图的表示](#2_2459)
    - * [1、==数组==（邻接矩阵）表示法](#1_2463)
      * [2、==链表==（邻接表）表示法](#2_2516)
    - [（3）图的遍历](#3_2572)
    - * [1、==深度==优先搜索遍历（Depth First Search --- DFS）](#1Depth_First_Search__DFS_2581)
      * [2、==广度==优先搜索遍历（Breath First Search --- BFS）](#2Breath_First_Search__BFS_2591)
    - [（4）图的应用](#4_2601)
    - * [1、最小生成树](#1_2603)
      * [2、最短路径](#2_2632)
      * [3、拓扑排序](#3_2652)
      * [4、关键路径](#4_2666)
  + [九、查找](#_2685)
  + - [（1） 查找表](#1__2687)
    - [（2）线性表的查找](#2_2695)
    - * [1、顺序查找（线性查找）](#1_2697)
      * [2、二分查找](#2_2721)
      * [3、分块查找](#3_2746)
    - [（3）树表的查找](#3_2761)
    - [（4）==哈希表==的查找](#4_2800)
  + [十、排序](#_2855)
  + - [（1）插入排序](#1_2872)
    - * [1、直接插入排序](#1_2884)
      * [2、折半插入排序](#2_2902)
      * [3、==希尔==排序](#3_2915)
    - [（2）交换排序](#2_2935)
    - * [1、冒泡排序](#1_2937)
      * [2、==快速==排序](#2_2954)
    - [（3）选择排序](#3_2981)
    - * [1、直接选择排序](#1_2985)
      * [2、==堆==排序](#2_2990)
    - [（4）归并排序](#4_3048)
    - [（5）基数排序](#5_3060)
    - [（6）排序算法小结](#6_3064)
  + [附录A- ASCII](#A_ASCII_3075)

## C语言数据结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/350ba8ee717e308f4f713dc1cee01560.png)

---

### 一、基本概念和术语

> **数据（data）**是对客观事物的符号表示。
>
> **数据元素（data element）**是数据中的基本单位，在计算机程序中作为一个整体进行考虑和处理。
>
> **数据对象（data object）**是性质相同的数据元素的集合，是数据的一个子集。
>
> **数据结构（data structrue）
> **是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下4类基本**
> 逻辑结构**
> ：1、
> **集合**
> ，结构中的数据元素之间除了同属于一个集合的关系外，别无其他关系；2、
> **线性结构**
> ，结构中的数据元素之间存在一个对一个的关系；3、
> **树形结构**
> ，结构中的元素之间存在一个对多个的关系；4、
> **图状结构或网状结构**
> ，结构种的数据元素之间存在多个对多个的关系。
> **存储结构**
> 也有四种：1、顺序结构，2、链式结构，3、索引结构，4、散列结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/671d130919400cde0880e7199f4d552e.png)

C语言缺少类这一关键字，所以一般使用结构体和函数搭配起来构造数据类型，举个例子构造复数数据类型:

```c
//定义复数数据类型
#include <stdio.h>
typedef struct {
	float realpart;
	float imagpart;
} Complex;

void assign(Complex* A, float real, float image);
void add(Complex* C, const Complex A, const Complex B);
void minus(Complex* C, const Complex A, const Complex B);
void multiply(Complex* C, const Complex A, const Complex B);
void divide(Complex* C, const Complex A, const Complex B);

void assign(Complex* A, float real, float imag)
{
	A->realpart = real;
	A->imagpart = imag;
}
void add(Complex* C, const Complex A, const Complex B)
{
	C->realpart = A.realpart + B.realpart;
	C->imagpart = A.imagpart + B.imagpart;
}
void minus(Complex* C, const Complex A, const Complex B)
{
	C->realpart = A.realpart - B.realpart;
	C->imagpart = A.imagpart - B.imagpart;
}
void multiply(Complex* C, const Complex A, const Complex B)
{
	C->realpart = A.realpart * B.realpart - A.imagpart * B.imagpart;
	C->imagpart = A.realpart * B.imagpart + A.imagpart * B.realpart;
}
void divide(Complex* C, const Complex A, const Complex B)
{
	Complex temp;
	Complex B1;
	B1.realpart = B.realpart;
	B1.imagpart = -B.imagpart;
	multiply(&temp, A, B1);
	C->realpart = temp.realpart / (B.realpart * B.realpart + B.imagpart * B.imagpart);
	C->imagpart = temp.imagpart / (B.realpart * B.realpart + B.imagpart * B.imagpart);
}

```

---

### 二、时间、空间复杂度

#### （1）时间复杂度

算法的时间效率分析采用事前分析法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/90ea7b4ec1db61770f9d9dac14eb5c04.png)

​ 我们假设执行每条语句所需的时间均为单位时间。此时对算法的运行时间的讨论就可以转化为讨论该算法中所有语句的执行次数，即语句频度之和。举一个例子：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/195b1438bf24405c30a81e35dccfece5.png)

该算法的时间效率就为

T
(
n
)
=
2
n
3
+
3
n
2
+
2
n
+
1
T(n)=2n^3+3n^2+2n+1





T

(

n

)



=





2


n









3



+





3


n









2



+





2

n



+





1
，但是这样计算过于麻烦，于是，为了比较不同算法的时间效率，我们仅仅比较它们的
**数量级**
。该算法的时间效率即为

O
(
n
3
)
O(n^3)





O

(


n









3

)
。

​ 引入
时间复杂度
的概念：一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数

f
(
n
)
f(n)





f

(

n

)
算法的时间度量记作

T
(
n
)
=
O
(
f
(
n
)
)
T(n)=O(f(n))





T

(

n

)



=





O

(

f

(

n

)

)
  
它表示随问题规模n的增大，算法执行时间的增长和f(n)的增长率相同，称作算法的
渐进时间复杂度
，简称
时间复杂度
。其中

O
O





O
是数量级符号

O
r
d
e
r
Order





O

r

d

e

r
。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/103085d5034ab6a05122a256476fbf8b.png)

时间复杂度定义中所指的基本语句是在算法的执行过程中重复最多的语句，
时间复杂度实际上是由嵌套层次最深语句的频度决定的
。例如：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e400fdca4ba08e562f9d160db827c2f4.png)

对于较为复杂的时间复杂度计算问题，可以采用
**级数的方法来进行计算**
，例如：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b5069cd553622aa325de13987aeba83b.png)

> 在考虑算法的时间复杂度时，还需要考虑问题的规模和问题的形式，因此，出现了：
>
> **最坏时间复杂度**
> ：指在最坏的情况下，算法的时间复杂度。
>
> **最好时间复杂度**
> ：指在最优的情况下，算法的时间复杂度。
>
> **平均时间复杂度**
> ：指在所有可能输入实例等概率出现的情况下，算法的期望运行时间。
>
> 对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大
>
> O
> O
>
>
>
>
>
> O
> 的运算规则，计算算法的时间复杂度：
>
> **加法规则**
> ：
>
> T
> (
> n
> )
> =
> T
> 1
> (
> n
> )
> +
> T
> 2
> (
> n
> )
> =
> O
> (
> f
> (
> n
> )
> )
> +
> O
> (
> g
> (
> n
> )
> )
> =
> O
> (
> m
> a
> x
> (
> f
> (
> n
> )
> ,
> g
> (
> n
> )
> )
> )
> T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
>
>
>
>
>
> T
>
> (
>
> n
>
> )
>
>
>
> =
>
>
>
>
>
> T
>
> 1
>
> (
>
> n
>
> )
>
>
>
> +
>
>
>
>
>
> T
>
> 2
>
> (
>
> n
>
> )
>
>
>
> =
>
>
>
>
>
> O
>
> (
>
> f
>
> (
>
> n
>
> )
>
> )
>
>
>
> +
>
>
>
>
>
> O
>
> (
>
> g
>
> (
>
> n
>
> )
>
> )
>
>
>
> =
>
>
>
>
>
> O
>
> (
>
> m
>
> a
>
> x
>
> (
>
> f
>
> (
>
> n
>
> )
>
> ,
>
>
>
> g
>
> (
>
> n
>
> )
>
> )
>
> )
>
> **乘法规则**
> ：
>
> T
> (
> n
> )
> =
> T
> 1
> (
> n
> )
> ×
> T
> 2
> (
> n
> )
> =
> O
> (
> f
> (
> n
> )
> )
> ×
> O
> (
> g
> (
> n
> )
> )
> =
> O
> (
> f
> (
> n
> )
> ×
> g
> (
> n
> )
> )
> T(n)=T1(n) \times T2(n)=O(f(n)) \times O(g(n))=O(f(n) \times g(n))
>
>
>
>
>
> T
>
> (
>
> n
>
> )
>
>
>
> =
>
>
>
>
>
> T
>
> 1
>
> (
>
> n
>
> )
>
>
>
> ×
>
>
>
>
>
> T
>
> 2
>
> (
>
> n
>
> )
>
>
>
> =
>
>
>
>
>
> O
>
> (
>
> f
>
> (
>
> n
>
> )
>
> )
>
>
>
> ×
>
>
>
>
>
> O
>
> (
>
> g
>
> (
>
> n
>
> )
>
> )
>
>
>
> =
>
>
>
>
>
> O
>
> (
>
> f
>
> (
>
> n
>
> )
>
>
>
> ×
>
>
>
>
>
> g
>
> (
>
> n
>
> )
>
> )

#### （2）空间复杂度

​ 引入空间复杂度的概念：
空间复杂度
作为算法所需存储空间的度量，记作
  




S
(
n
)
=
O
(
f
(
n
)
)
S(n)=O(f(n))





S

(

n

)



=





O

(

f

(

n

)

)
  
其中

n
n





n
为问题大小的规模。算法要占据的空间包括，算法本身要占据的空间，输入/输出，指令，常数，变量等，算法在执行时所需的辅助空间。

例题：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/59f69cf4f639e7c1cf93a232b8624efd.png)

---

### 三、类C语言有关操作

##### 补充1：数组定义

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/af8e262e48c691ab2952c0cbe269c1e0.png)

##### 补充2：动态内存分配

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/57d43c776e85d36d055a4b2d1a144278.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/86ef7a588e1e41de045b7eaca790424f.png)

##### 补充3：C++中的参数传递

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/209df76e9101dc3bc2b489b372a63152.png)

C++特有的引用类型作为参数：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7b17dd0e7bbc1c415b41f59218da46f0.png)

---

### 四、线性表

#### （1）定义

​
线性表
是具有相同特性元素的一个有限序列，数据元素之间是线性关系，

(
a
1
,
a
2
,
…
,
a
i
−
1
,
a
i
,
a
i
+
1
,
…
,
a
n
)
⏟
数
据
元
素
\underbrace{(a\_1,a\_2, \dots,a\_{i-1},a\_i,a\_{i+1},\dots,a\_n)}\_{数据元素}














数

据

元

素




































(


a









1

​


,




a









2

​


,



…



,




a










i

−

1

​


,




a









i

​


,




a










i

+

1

​


,



…



,




a









n

​


)

​


​

，起始元素称为线性起点，终端元素称为线性终点。

> 线性表具有如下的特点：
>
> (1)存在唯一的一个被称为“第一个”的数据元素；
>
> (2)存在唯一的一个被称为“最后一个”的数据元素；
>
> (3)除第一个元素外，集合中的每个元素均只有一个前驱；
>
> (4)除最后一个元素外，集合中的每个元素均只有一个后继。

#### （2）线性表的表示和实现

##### 1、线性表的 顺序 表示和实现

​ 线性表的顺序表示又称为
**顺序存储结构**
或者
**顺序映像**
。顺序存储的
**定义**
：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。换句话说，以元素在计算机内存中**“物理位置相邻”**来表示线性表中数据元素之间的逻辑关系。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序结构是一种随机存取的存储结构。

​ 顺序表中元素存储位置的计算：假设线性表中的每个元素需要占据

l
l





l
个存储单元，则第

i
+
1
i+1





i



+





1
个数据元素的存储位置和第

i
i





i
个数据元素的存储位置之间的关系满足
  




L
O
C
(
a
i
+
1
)
=
L
O
C
(
a
i
)
+
l
LOC(a\_{i+1})=LOC(a\_i)+l





L

O

C

(


a










i

+

1

​


)



=





L

O

C

(


a









i

​


)



+





l
  
由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：
  




L
O
C
(
a
i
)
=
L
O
C
(
a
1
)
+
(
i
−
1
)
×
l
LOC(a\_i)=LOC(a\_1)+(i-1)\times{l}





L

O

C

(


a









i

​


)



=





L

O

C

(


a









1

​


)



+





(

i



−





1

)



×






l
  
由此可以看出顺序表的特点是：1、以物理位置表示相邻的逻辑关系；2、任意的元素均可以快速访问，故称为
随机存取
。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3c8fac05c74a9c7295b232400801fe3e.png)

顺序表（Sequence List）的类型定义模板：

```c
//顺序表定义模板
#define LIST_INIT_SIZE 100		//顺序表存储空间的初始分配
typedef struct {
    ElemType* elem;			//数据指针，动态分配存储空间
   int length;		//当前的长度
} SqList;

```

使用类型定义模板的案例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fb01a1e7866fb492edbed2fa1cea2fe5.png)

顺序表的示意图：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a26c3f7fa6594186d3b38cbd38c94986.png)

在一些较为复杂的时间复杂度计算的问题中，我们往往采用问题的
**时间复杂度期望**
来作为整体问题的复杂度，例如在顺序表中计算插入算法的时间复杂度或者是计算删除算法的时间复杂度：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d08a1e356517c6c5fbaf98c1a3c4dc70.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/90e591a3320f3f50c88440226cab40f4.png)

```c
//头文件包含
#include <stdio.h>
#include <stdlib.h>
//函数结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
//Status 是函数的类型，其值是函数结果状态代码
typedef int Status;
typedef char ElemType;
//顺序表的定义
#define MAXSIZE 100
typedef struct {
	ElemType* elem;
	int length;
} SqList;

//顺序表的初始化函数
Status InitList_Sq(SqList* L)
{
	L->elem = (ElemType*)malloc(MAXSIZE * sizeof(ElemType));
	if (!L->elem)
		exit(OVERFLOW);
	L->length = 0;
	return OK;
}
//销毁线性表
void DestroyList_Sq(SqList* L)
{
	if (L->elem)
		free(L->elem);
	L = NULL;
}
//清空线性表
void ClearList(SqList* L)
{
	L->length = 0;
}
//求线性表的长度
int GetLength(const SqList* L)
{
	return L->length;
}
//判断线性表是否为空
Status IsEmpty(const SqList* L)
{
	if (L->length == 0)
		return TRUE;
	else
		return FALSE;
}
//线性表取第i个值
Status GetElem(const SqList* L, int i, ElemType e)
{
	if (i<1 || i>L->length)
		return ERROR;
	else
	{
		e = L->elem[i - 1];
		return OK;
	}
}
//线性表按值顺序查找
Status LocateElem(const SqList* L, const ElemType e)
{
	int i;
	for (i = 0; i <= L->length - 1; i++)
	{
		if (L->elem[i] == e)
			return i + 1;		//查找成功返回元素位置
	}
	return 0;		//查找失败返回0
}
//顺序表的插入
Status InsertList_Sq(SqList* L, int n, const ElemType e)
{
	int i;
	if (n >= 1 && n <= L->length + 1)	//判断插入位置是否合法
	{
		if (L->length == MAXSIZE)		//判断存储空间是否已满
			return ERROR;
		for(i=L->length-1; i>=n-1; i--)		//插入位置及之后元素后移
		{
			L->elem[i+1] = L->elem[i];
		}
		L->elem[n - 1] = e;
		L->length += 1;
		return OK;
	}
	return ERROR;
}
//顺序表删除
Status DeleteElem(SqList* L, int n)
{
	int i;
	if (n >= 1 && n <= L->length)
	{
		L->elem[n - 1] = 0;		//删除指定元素
		for (i = n - 1; i <= L->length - 1; i++)		//剩余元素移位
		{
			L->elem[i] = L->elem[i + 1];
		}

		L->length--;		//顺序表长度-1
		return OK;
	}
	return ERROR;
}
//顺序表显示
void ShowList_Sq(const SqList* L)
{

	if (L->length == 0)
		puts("The SqList is empty!");
	
	else
	{
	int i;
	for (i = 0; i < L->length; i++)
	{
		printf("%d ", L->elem[i]);
	}
	putchar('\n');
	printf("The length of SqList is %d\n", L->length);

	}
}
//合并两个顺序表,将L2合并到L1中
Status MergeList_Sq(SqList* L1, const SqList* L2)
{
	if (L1->length == 0 || L2->length == 0)
	{
		puts("Length must be non-zero!");
		return ERROR;
	}
	else if (L1->length + L2->length > MAXSIZE)
	{
		puts("Overflow");
		return OVERFLOW;
	}
	else 
	{
		int i;
		for (i = 0; i <= L2->length - 1; i++)
		{
			L1->elem[i + L1->length] = L2->elem[i];
		}
		L1->length += L2->length;
		return OK;
	}
}

```

测试代码：

```c
int main(void)
{
	SqList my_list;
	ElemType a, b, c, d, e, f;
	a = 1;
	b = 2;
	c = 3;
	d = 4;
	e = 5;
	f = 6;
	SqList my_list2;
	InitList_Sq(&my_list);
	InsertList_Sq(&my_list, 1, a);
	InsertList_Sq(&my_list, 2, b);
	InsertList_Sq(&my_list, 3, c);
	InsertList_Sq(&my_list, 1, d);
	InsertList_Sq(&my_list, 2, e);
	InsertList_Sq(&my_list, 3, f);
	//printf("%d\n", LocateElem(&my_list, a));
	//ShowList_Sq(&my_list);
	//DeleteElem(&my_list, 2);
	ShowList_Sq(&my_list);
	InitList_Sq(&my_list2);
	InsertList_Sq(&my_list2, 1, a);
	InsertList_Sq(&my_list2, 2, b);
	InsertList_Sq(&my_list2, 3, c);
	ShowList_Sq(&my_list2);
	MergeList_Sq(&my_list, &my_list2);
	ShowList_Sq(&my_list);
	return 0;
}

```

##### 2、顺序表的优缺点

> 优点：1、存储密度大；2、可以随机存取表中任一元素。
>
> 缺点：1、在插入、删除某一元素时，需要移动大量其他元素；2、浪费大量存储空间；3、属于静态存储形式，数据元素的个数不能够自由扩充。

##### 3、线性表的 链式 表示和实现

​ 线性表的链式结构的特点是用一组任意的存储单元存储线性表的数据元素（这种存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素

a
i
a\_i






a









i

​

与其直接后继数据元素

a
i
+
1
a\_{i+1}






a










i

+

1

​

之间的逻辑关系，对数据元素

a
i
a\_i






a









i

​

来说，除了本身的存储信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素

a
i
a\_i






a









i

​

的存储映像，称为
**结点**
（node）。它包括两个域：其中存储信息数据元素信息的域被称为
**数据域**
；存储直接后继存储位置的域被称为
**指针域**
。指针域中存储的信息称为
**指针**
或
**链**
。

n
n





n
个结点

(
a
i
(
1
<
=
i
<
=
n
)
)
(a\_i(1<=i<=n))





(


a









i

​


(

1



<




=





i



<




=





n

)

)
的存储映像链结成一个
**链表**
，即为线性表
  




(
a
1
,
a
2
,
…
,
a
n
)
(a\_1,a\_2,\dots{,a\_n})





(


a









1

​


,




a









2

​


,



…




,




a









n

​


)
  
的
**链式**
存储结构。又由于此链表的每个结点中只包含一个指针域，故又称为
**线性链表**
或
**单链表**
。整个链表的存取必须从
**头指针**
开始，头指针指示链表中第一个结点（即第一个数据元素的存储映像）。

​ 链式存储结构的特点：1、结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。线性表的链式表示又称为
**非顺序映像**
或
**链式映像**
。2、访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等，这种存取元素的方式称为
顺序存取
。

链表（Link List）的分类：单链表、双链表、循环链表

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fb21c2762c982d7e0f396cf7c3250e55.png)

单链表还分为是否带头结点两种情况：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0d1c59a7d45374a7ad02bf50aa954a1a.png)

如何判断是否是空表：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/14218a5f0fb1a358275979ea3daa8456.png)

设置链表的头结点有什么好处：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/623cccc6893ae9b9809b0bf04e6dff91.png)

头结点的数据域能够存放什么内容：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4b4b8b67670d7638e792bc212e9f160c.png)

###### a、单链表的实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/20cc0f492b47b8811e3f98b9db9a4496.png)

单链表的每个结点都可以通过一个结构体来表示：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9a0f5fc6439e0d03f2ed180c0a9bd639.png)

```c
// 链表定义模板
typedef struct Lnode {
	ElemType data;
	struct Lnode* next;			//注意这里需要struct关键字
}Lnode, *LinkList;

```

![](https://i-blog.csdnimg.cn/blog_migrate/04572a3fd4a4f3689e5880e74968ab73.png)

举个例子，定义一个学生链表：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9e68c83b8c69be7c9acd04bef2260ace.png)

**单链表基本操作的实现**
：

1. 单链表的初始化

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9572de89bb4ba4a86b8769b97187d31b.png)

2. 判断单链表是否为空

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/04bab14234620e0ea9dff5bffe41f854.png)

3. 单链表的销毁

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0b446d3a57dc37bdbb1c7b6db64f5ee7.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e572cf63dd4ca2fcc655d2aa2d40c951.png)

4. 清空单链表
     
   ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b6810452df1bf2531ad34cc79786f6cf.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/320f714a17b1f7d0c501a20c65bc1a89.png)

5. 求单链表的表长

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a2dd6b19ed2b8933c3a23a096dd89064.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/516c74938718e5b4ad93aa7708df3c6c.png)

6. 取单链表中第i个元素内容

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9cd52385487b4395ccbeba55e9ef3f1d.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/eb4a790109910212d27c646382870d01.png)

7. 单链表按值查找

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/33d2a57c505f25bd5a6d8cb631ea15ef.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a26f17fb26c454405e187af3351c90ce.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f5b91ce220659e175d3f2f55c3466b51.png)

8. 单链表插入，在第

   i
   i





   i
   个结点的前面插入新结点

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0735fd7e3904efd53d57143dd93a455d.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fa286e161e1e3deab1f854fb540d4c4d.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9a431fb9585795d9a9d9d3f1ec2248f3.png)

9. 单链表删除，删除第

   i
   i





   i
   个结点

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f4daaae1115d236f92b0146c5d6165c2.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4d6ef955d66c474197d1c0822f5ebad6.png)

10. 单链表的建立–头插法
      
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4179bf8768af34c9d7ed55ffb754f61c.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/901ff1f5c68e03f758efd0168c47da70.png)

11. 单链表的建立–尾插法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c609415e31a41d9d4c48497cb4846665.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dc1636966c1d81546ac034e842c58848.png)

单链表实现完整算法
：

```c
//头文件导入
#include <stdio.h>
#include <stdlib.h>
//函数结果状态代码
#define OK 1
#define ERROR 0
//Status 是函数的类型，其值是函数结果状态代码
typedef int Status;
typedef int ElemType;
//单链表
typedef struct Signle_Link_List{
	ElemType data;
	struct LNode* next;
} LNode, *LinkList;

//创建空链表
Status InitLinkList(LinkList* L)
{
	*L = (LinkList)malloc(sizeof(LNode));
	if (*L == NULL)
		return ERROR;
	(*L)->next = NULL;
	return OK;
}
//判断链表是否为空
int IsEmptyLinkList(const LinkList* L)
{
	if ((*L)->next == NULL)
		return 1;
	else
		return 0;
}
//单链表的销毁
Status DestoryLinkList(LinkList* L)
{
	LNode* p;
	while (*L != NULL)
	{
		p = *L;
		*L = (*L)->next;
		free(p);
	}
	return OK;
}
//清空单链表
Status ClearLinkList(LinkList* L)
{
	LNode* p, * q;
	q = (*L)->next;
	while (q != NULL)
	{
		p = q;
		q = q->next;
		free(p);
	}
	(*L)->next = NULL;
	return OK;
}
//求单链表的表长
int LenLinkList(const LinkList* L)
{
	LNode* p;
	p = (*L)->next;
	int i = 0;
	while (p)
	{
		i++;
		p = p->next;
	}
	(*L)->data = i;			//将长度存储到L头结点的数据域中
	return i;
}
//取出单链表中第i个元素
Status LocateElem(const LinkList *L, int i, ElemType *e)
{
	int j = 1;
	LNode* p;
	p = (*L)->next;
	while (p && j < i)
	{
		j++;
		p = p->next;
	}
	if (!p || j > i)		//如果待查找的元素大于链表长度或者小于1，查找错误
		return ERROR;
	*e = p->data;
	return OK;
}
//单链表按值查找,返回LNode
LNode* LocateElem_V_LNode(const LinkList *L, ElemType value)
{
	LNode* p;
	p = (*L)->next;
	while (p && p->data != value)		//p不为空指针，并且没找到
	{
		p = p->next;
	}
	return p;			//找到返回结点的地址，没找到返回NULL
}
//单链表按值查找,返回元素位置
int LocateElem_V_Index(const LinkList *L, ElemType value)
{
	int j = 1;
	LNode* p;
	p = (*L)->next;
	while (p && p->data != value)
	{
		j++;
		p = p->next;
	}
	if (!p)
		return 0;		//没找到,返回0
	else
		return j;		//找到,返回第几个结点
}
//单链表插入,在第i个结点之前插入一个结点
Status InsertLinkList(LinkList *L, int i, ElemType value)
{
	LNode* p;
	p = (*L)->next;
	int j = 1;
	while (p && j < i - 1)		//找到第i-1个结点
	{
		j++;
		p = p->next;
	}
	if (!p || j > i - 1)		//i大于表长+1,或者小于1,插入位置非法
		return ERROR;

	LNode* newlnode;
	newlnode = (LNode*)malloc(sizeof(LNode));
	newlnode->data = value;
	newlnode->next = p->next;
	p->next = newlnode;
	return OK;
}
//单链表删除,删除第i个结点
Status DeleteLinkList(LinkList *L, int i)
{
	LNode* p, * q;
	int j = 1;
	p = (*L)->next;
	while (p && j < i - 1)
	{
		j++;
		p = p->next;
	}
	if (!p || j > i - 1)
		return ERROR;

	q = p->next;
	p->next = q->next;
	free(q);
	return OK;
}
//单链表建立-头插法
void CreateLinkList_H(LinkList* L, int n)
{
	*L = (LinkList)malloc(sizeof(LNode));
	(*L)->next = NULL;					//先建立一个头结点
	int i;
	for (i = n; i > 0; i--)
	{
		LNode* newlnode;
		newlnode = (LNode*)malloc(sizeof(LNode));
		printf("Enter the node data:_____\b");
		scanf("%d", &newlnode->data);
		newlnode->next = (*L)->next;
		(*L)->next = newlnode;
	}
}
//单链表建立-尾插法
void CreateLinkList_R(LinkList *L, int n)
{
	*L = (LinkList)malloc(sizeof(LNode));
	(*L)->next = NULL;					//先建立一个头结点
	LNode* p;
	p = *L;
	int i;
	for (i = n; i > 0; i--)
	{
		LNode* newlnode;
		newlnode = (LNode*)malloc(sizeof(LNode));
		printf("Enter the node data:___\b");
		scanf("%d", &newlnode->data);
		newlnode->next = NULL;
		p->next = newlnode;
		p = p->next;
	}
}
//显示单链表
void ShowLinkList(const LinkList* L)
{
	LNode* p;
	p = (*L)->next;
	if (!p)
	{
		puts("The LinkList is empty");
		return;
	}
	int i = 1;
	while (p)
	{
		printf("%d : %d\n", i, p->data);
		i++;
		p = p->next;
	}
	putchar('\n');
}

```

测试函数：

```c
//测试函数
int main(void)
{
	LinkList my_list;
	my_list = NULL;
	ElemType answer = 0;
	//InitLinkList(my_list);
	//CreateLinkList_H(&my_list, 3);		//测试头插法建立链表
	CreateLinkList_R(&my_list, 3);			//测试尾插法建立链表
	//ClearLinkList(&my_list);				//测试清空链表
	ShowLinkList(&my_list);
	//DestoryLinkList(&my_list);				//测试销毁链表
	printf("%s\n",IsEmptyLinkList(&my_list) >0?
		"LinkList is Empty":"LinkList isn't Empty");		//测试判断链表函数
	printf("The length of LinkList is %d\n", LenLinkList(&my_list));		//测试求长度函数
	LocateElem(&my_list, 3, &answer);
	printf("The %d elem is %d\n", 3, answer);		//测试取元素函数
	LNode *answer1;
	answer1 = LocateElem_V_LNode(&my_list, 2);
	printf("The answer is %d\n", answer1->data);		//测试取元素函数
	printf("The Index of 3 is %d\n", LocateElem_V_Index(&my_list, 3));			//测试取元素函数
	InsertLinkList(&my_list, 2, 10);		//测试增加结点函数
	ShowLinkList(&my_list);
	DeleteLinkList(&my_list, 3);			//测试删除结点函数
	ShowLinkList(&my_list);					
	return 0;
}

```

###### b、单向循环链表的实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ddf1280cba38532edcc5eccc369c829d.png)

判断循环链表结束的条件：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bd2cc24d88f3474bd45758698b45ba61.png)

当循环链表需要经常使用头结点和尾结点的时候，循环链表通常使用
尾指针
表示法更简单：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4259177d7b7a7ffe24c28a989500824c.png)

**循环链表的基本操作实现**

1. 循环链表的合并

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d1deafa810c96820d63148fde54c2a6b.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d25c7fd70b3431caf6a8125f5161dada.png)

###### c、双向链表的实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4b031f4ff53ab9c06841d86d1377ff4b.png)

双向链表的定义：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0da563c04585d755f287c01679ff02d9.png)

```c
//双向链表的定义
typedef struct DuLNode {
	ElemType data;
	struct DuLNode* prior, * next;
} DuLNode, *DuLinkList;

```

**双向链表的操作**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/899e52f9924d8a13b1355dfb260b9451.png)

1. 双向链表的插入

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/de4b11c39ecddf8974981fb4e8fa937b.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/535e891311c270e119fb2606c9e745be.png)

2. 双向链表的删除

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ef088df314c34c8f765e8ed33a842b1a.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e12cf3bd9114ab9c36bce9890cfedf26.png)

###### d、双向循环链表的实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/337add46b9b02b2caaa497a0d284f7e7.png)

##### 4、链表的优缺点

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a94612827071ef441cd2176fcdd633d3.png)

#### （3）单链表、循环链表、双向链表的时间效率比较

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b1025d3d3e7199e0553acd12634b800d.png)

#### （4）顺序表和链表的比较

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5212f0eb0839c1b8fbde3a1888d4e1e7.png)

#### （5）案例引入

##### 1、线性表的应用

线性表的合并

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c6fbebbbefa06513f03b9e5a37d88b8c.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ca84fe80cbfc00a4619e2f1d0d99093c.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a6e31a0d50f1233419022e3ea77a27f1.png)

有序表的合并

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d35f5608c5c1eb10b81a46b1c29b9763.png)

用顺序存储结构来实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ad7bb3ab76bc094cad3df5e91c05d7a0.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/af7e7363d9df3816faa1fcfbd294ad1b.png)

用链式存储结构来实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/08ec4b72dd1448c6e58e6c9558747760.png)

##### 2、一元多项式的运算

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/04284d558ef77a480c6f09ab4c26ec71.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e2e4066b89e1661abbeafa7e03cd434e.png)

采用链式结构会更简单。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d562e40122b24310dcdbdaf00e2bfa1d.png)

尾插法建立链表
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e631645cc66a05ff8a90d72f1523654b.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ab35b08e0d755d5127dc93f7f89439a7.png)

多项式相加

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b16b9292c041ba4379f4425af33569d1.png)

##### 3、图书管理系统

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5d2883c181fcb3542147de45687c6780.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/90fb5a0e2431b7a5397dacb125292fab.png)

---

### 五、栈和队列

​ 栈和队列是两种重要的线性结构，从数据结构的角度来看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可以称为限定数据类型。

#### （1）栈（LIFO）

​ **栈（stack）**是限定仅在表位进行插入或删除操作的线性表。对栈来说，表尾称为栈顶（Top），表头称为栈尾（Base）。换句话说，栈的修改是按后进先出的原则进行的。因此，栈又称为后进先出（last-in-first-out）的线性表（简称LIFO）。插入元素到栈顶称为入栈（压栈Push），从栈尾删除一个元素称为出栈（弹栈Pop）。

栈和线性表有什么不同：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/973b5219c254d2da3660bf986a85488a.png)

#### （2）栈的表示和实现

##### 1、栈的 顺序 表示和实现

栈的顺序表示又称为
**顺序栈**
，具体如下所示：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5680d5317b21a22ea39a1579a1bcfb7d.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0adfa35c535f37b861cc06e9d571618d.png)

​ 栈存在两种溢出的情况，当栈已经存放满元素时，若还将元素进行压栈此时会发生上溢（overflow）；当栈已经为空时，若还进行出栈此时会发生下溢（underflow）。上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题的处理结束。

顺序栈的表示：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e39c8ee2ada938dff85daed614365ba4.png)

```c
//栈的顺序表示
typedef struct {
	SElemType* top;		//栈顶指针
	SElemType* base;	//栈底指针，用于初始化动态存储空间
	int stacksize;		//栈的最大容量
} SqStack;

```

1. 顺序栈的初始化

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/981325b2dcb0e98efa6ca58d2ba700dc.png)

2. 判断顺序栈是否为空

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/92c4782ea15e939ee5fba3cc5b1d77b5.png)

3. 清空栈

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b3e00b8eda5bb9ac1bf133c342ecd1e2.png)

4. 销毁栈

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8b9563bf81c0a1271117672d48a87649.png)

5. 顺序栈的入栈

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/77d38da4f70559a9a16f6dad92369766.png)

6. 顺序栈的出栈

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5a393111e402e154046bbf5f5c7722eb.png)

这里一定是先进行指针下移，因为top指针指向的是栈顶空位置，用于存放下一个元素地址的地方，先进行下移则top指向栈中的栈顶第一个元素。

顺序栈的完整实现
：

```c
// 顺序栈的实现
//导入头文件
#include <stdio.h>	
#include <stdlib.h>
//函数结果状态代码
#define OK 1
#define ERROR 0
#define OVERFLOW -1
#define TRUE 1
#define FALSE 0
//宏定义
#define MAXSIZE 100
//Status 是函数的类型，其值是函数结果状态代码
typedef int Status;
typedef int SElemType;
//顺序栈的定义
typedef struct {
	SElemType* top;
	SElemType* base;
	int stacksize;
} SqStack;
//顺序栈的初始化
Status InitSqStack(SqStack* S)
{
	S->base = (SElemType*)malloc(MAXSIZE * sizeof(SElemType));
	if (!S->base)			//S->base为NULL，开辟空间失败
		exit(OVERFLOW);
	S->top = S->base;
	S->stacksize = MAXSIZE;
	return OK;
}
//判断顺序栈是否为空
Status IsEmptySqStack(const SqStack* S)
{
	if (S->base == S->top)
		return TRUE;
	else
		return FALSE;
}
//判断顺序栈是否已满
Status IsFullSqStack(const SqStack* S)
{
	if (!S->base)
		return ERROR;
	if (S->top - S->base == S->stacksize)
		return TRUE;
	else
		return FALSE;
}
//清空栈
Status ClearSqStack(SqStack* S)
{
	if(S->base)
		S->top = S->base;
	return OK;
}
//销毁栈
Status DestroySqStack(SqStack* S)
{
	if (!S->base)
		return ERROR;
	free(S->base);
	S->top = S->base = NULL;
	S->stacksize = 0;
	return OK;
}
//顺序栈的入栈
Status Push(SqStack* S, SElemType* e)
{
	if (!S->base || S->top - S->base == S->stacksize)		//栈为NULL,或者上溢
		return ERROR;
	*(S->top++) = *e;
	return OK;
}
//顺序栈的出栈
Status Pop(SqStack* S, SElemType* e)
{
	if (!S->base || S->top == S->base)						//栈为NULL,或者下溢
		return ERROR;
	*e = *--S->top;
	return OK;
}
//栈显示函数
void ShowSqStack(const SqStack* S)
{
	if (!S->base || S->top == S->base)
		printf("SqStack is Empty!\n");
	SElemType* p;
	p = S->top;
	while (p-- != S->base)
	{
		printf("%d ", *p);
	}
	putchar('\n');
}

```

测试函数：

```c
//测试函数
int main(void)
{
	SqStack my_stack;
	InitSqStack(&my_stack);							//测试栈初始化函数
	printf("%d\n", IsEmptySqStack(&my_stack));		//测试判断空函数
	printf("%d\n", IsFullSqStack(&my_stack));		//测试判断满函数
	SElemType a = 1;
	SElemType b = 2;
	SElemType c = 3;
	SElemType d = 10;
	SElemType answer;
	Push(&my_stack, &a);							//测试入栈函数
	Push(&my_stack, &b);
	Push(&my_stack, &c);
	Push(&my_stack, &d);						
	ShowSqStack(&my_stack);							//显示栈中元素
	Pop(&my_stack, &answer);						//测试出栈函数
	printf("The answer is %d\n", answer);			
	ShowSqStack(&my_stack);
	ClearSqStack(&my_stack);						//测试清空栈函数
	ShowSqStack(&my_stack);
	//DestroySqStack(&my_stack);						//测试销毁栈函数
	//ShowSqStack(&my_stack);
	return 0;
}

```

##### 2、栈的 链式 表示和实现

栈的链式表示又称为
**链栈**
，具体如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/158ccadad08eda53e2beb4f9098e3a10.png)

在这个表示方法中，**栈顶指针就用单链表的头结点指针来表示，栈底指针就用单链表的尾结点指针来表示。链栈需要一个指针就能进行操作，是因为栈只能在栈顶进行入栈和出栈，所以仅仅直到栈顶的指针就可以操作整个链栈。**链栈是没有头结点的单链表，但是链栈也可以添加头结点，具体操作方法，要看自己是如何进行定义的。链栈的使用和创建，类似于单链表建立的头插法，都是从头部开始进行插入。

```c
//链栈
typedef struct StackNode {
	SElemType data;
	struct StackNode* next;
} StackNode, *LinkStack;

```

1. 链栈的初始化

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b369a4e58aa9c15e7aadd54984cb9941.png)

2. 判断链栈是否为空

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ca51f81282d1cd83bc2e9e179997cbf8.png)

3. 链栈的入栈

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bc2b6630dc6a66418aa1cf7b2eb3cbe2.png)

4. 链栈的出栈

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/43c2f7d3f135b7824f92800f410a9bc1.png)

5. 取栈顶的元素

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e0a9cef98e390c3ff992609ebed0a35b.png)

链栈实现完整代码

```c
//链栈的实现 --该实现是保留了头结点，栈为空的条件为头结点的next为NULL
//导入头文件
#include <stdio.h>	
#include <stdlib.h>
//函数状态宏定义
#define TRUE 1
#define FALSE 0
#define ERROR 0
#define OK 1
#define OVERFLOW -1
//类型定义
typedef int Status;
typedef int SElemType;
//链栈定义
typedef struct StackNode {
	SElemType data;
	struct StackNode* next;
} StackNode, *LinkStack;
//链栈的初始化
Status InitLinkStack(LinkStack* S)
{
	*S = (LinkStack)malloc(sizeof(StackNode));
	if (!S)			//开辟空间失败
		return ERROR;
	(*S)->next = NULL;
	return OK;
}
//判断链栈是否为空
Status IsEmptyLinkStack(LinkStack* S)
{
	if ((*S)->next == NULL)	
		return TRUE;
	else
		return FALSE;
}
//链栈清空
Status ClearLinkStack(LinkStack* S)
{
	if (!(*S)->next)		//当链栈已经为空时报错
		return ERROR;
	StackNode* p, *q;
	p = (*S);
	while (p->next)
	{
		q = p;
		p = p->next;
		free(q);
	}
	(*S)->next = NULL;
	return OK;
}
//链表销毁
Status DestroyLinkStack(LinkStack* S)
{
	if (!(*S))			//当链栈不存在时报错
		return ERROR;
	StackNode* p, *q;
	p = *S;
	while (p->next)
	{
		q = p;
		p = p->next;
		free(q);
	}
	free(*S);
	*S = NULL;
	return OK;
}
//链栈入栈--链栈无上溢，所以不需要判断
Status Push(LinkStack* S, SElemType* e)
{
	StackNode* new;
	new = (StackNode*)malloc(sizeof(StackNode));
	new->data = *e;
	new->next = (*S);
	(*S) = new;
	return OK;
}
//链栈出栈--链栈有下溢，需要判断下溢
Status Pop(LinkStack* S, SElemType* e)
{
	if (!(*S)->next)			//判断链栈下溢
		return ERROR;
	StackNode* p;
	p = *S;
	*e = p->data;
	*S = p->next;
	free(p);					//释放栈顶空间
}
//获取链栈顶部元素，并不出栈
SElemType GetTop(LinkStack* S)
{
	if ((*S)->next)
		return (*S)->data;
}
//显示链栈
void ShowLinkStack(const LinkStack* S)
{
	if (!(*S)->next)
	{
		printf("The LinkStack is Empty\n");
		return;
	}
	else if (!(*S))
	{
		printf("The LinkStack dosen't  exsist\n");
	}
	StackNode* p;
	p = *S;
	while (p->next)
	{
		printf("%d ", p->data);
		p = p->next;
	}
	putchar('\n');
}

```

测试函数：

```c
//测试函数
int main(void)
{
	LinkStack my_stack;
	my_stack = NULL;
	SElemType a = 1;
	SElemType b = 2;
	SElemType c = 3;
	SElemType d = 10;
	SElemType answer;
	printf("%d\n", InitLinkStack(&my_stack));		//测试初始化函数
	ShowLinkStack(&my_stack);						//显示链栈
	printf("%d\n", IsEmptyLinkStack(&my_stack));	//测试判断为空函数
	Push(&my_stack, &a);							//测试入栈函数
	Push(&my_stack, &b);
	Push(&my_stack, &c);
	Push(&my_stack, &d);
	ShowLinkStack(&my_stack);
	Pop(&my_stack, &answer);						//测试出栈函数
	printf("%d\n", answer);
	ShowLinkStack(&my_stack);
	printf("%d\n", GetTop(&my_stack));				//测试获取首元素函数
	ClearLinkStack(&my_stack);						//测试清空函数
	ShowLinkStack(&my_stack);
	//DestroyLinkStack(&my_stack);					//测试销毁函数
	//ShowLinkStack(&my_stack);
	return 0;
}

```

#### （3）栈与 递归

递归的定义：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/716308cf2f04f2468f7553567077d401.png)

递归的问题往往采用
**分治法**
来解决，分治法是对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。分治法必备的三个条件：1、能够将一个问题转变成另一个新问题，而新问题的解法与原问题的解法相同或类似，不同仅是处理的对象，且这些处理这些问题是有变化规律的。2、可以通过上述转化来进行问题的简化。3、必须有一个明确的递归出口，或称为递归边界。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cd0fb078c5d25795139d5deca2195c7d.png)

递归的调用过程，举个例子：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2b9f6b13a33c8bd3ba0771cb22075fc7.png)

#### （4）队列（FIFO）

​ **队列（queue）**是一种先进后出（first-in-first-out，简称为FIFO）的线性表，它只允许在表的一端进行插入，另一端进行删除元素。在队列中，允许插入的一端叫做队尾（Rear），允许删除的一端叫做队头（Front）。插入操作称为入队，删除操作称为出队。

#### （5）队列的表示和实现

##### 1、队列的 顺序 表示和实现

队列的顺序表示又称为
**顺序队**
，具体表示如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9b27e0471cbb1d9d7cc2763f3dd3a55b.png)

```c
//顺序队的实现
#define MAXISIZE 100
typedef struct {
	QElemType* base;	//数据指针，初始化动态存储空间
	int front;			//头元素的索引，不是指针
	int rear;			//尾元素的索引，不是指针
} SqQueue;

```

顺序队入队时的假上溢问题：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b6fe9d15349161760e623e14f7c6c048.png)

顺序队存在
**假上溢**
的问题，即当队尾指针指向了最大元素个数MAXQSIZE，但是队头指针却不为0，这种情况称为假上溢，为了解决这个问题有以下两种做法：1、每次都将队列中剩余的元素向队头方向移动，这种方式时间效率低。2、把队列视为循环队列。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8ca530e5b33849917ee3be51030bf459.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/47e9fe325403554980ec1f31f60cead7.png)

如何判断队空队满：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2c4599bb4248eb35c8ae251322c3f092.png)

采用少用一个元素空间的方法比较简单。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6f70b2830d0ea37d31dd486b6e589e4c.png)

1. 循环队列的初始化

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/55f0e93bdfb6e05f52114d95b78a7f0a.png)

2. 求队列的长度

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2393fe75fee1005c3da545d1c4f5a636.png)

3. 循环队列入队

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cac035a5dcb9d1a561fbc17946e78211.png)

4. 循环队列出队

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cdc11e1e3f42680b5a2f4064f6ce9bc4.png)

5. 取队头元素

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bc759e738445a77b49bb566f87f32388.png)

顺序队列的完整实现
：

```c
//顺序队列的实现
//头文件包含
#include <stdio.h>
#include <stdlib.h>
//函数状态宏定义
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define OVERFLOW -1
//类型定义
typedef int Status;
typedef int QElemType;
//顺序队定义
#define MAXQSIZE 100
typedef struct SqQueue {
	QElemType* base;	//动态分配数据域，指针
	int front;			//队头索引
	int rear;			//队尾索引
} SqQueue;
//初始化
Status InitSqQueue(SqQueue* Q)
{
	Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
	if (!Q->base)
		return ERROR;
	Q->front = Q->rear = 0;
	return OK;
}
//求循环队列的长度
int GetLength(SqQueue* Q)
{
	return ((Q->rear - Q->front + MAXQSIZE) % MAXQSIZE);
}
//入队
Status EnQueue(SqQueue* Q, QElemType* e)
{
	if ((Q->rear + 1) % MAXQSIZE == Q->front)		//出现上溢
		return ERROR;
	Q->base[Q->rear] = *e;
	Q->rear = (Q->rear + 1) % MAXQSIZE;
	return OK;
}
//出队
Status DeQueue(SqQueue* Q, QElemType* e)
{
	if (Q->front == Q->rear)				//出现下溢
		return ERROR;
	*e = Q->base[Q->front];
	Q->front = (Q->front + 1) % MAXQSIZE;
	return OK;
}
//取队头元素
QElemType GetHead(SqQueue* Q)
{
	if (Q->rear != Q->front)
		return Q->base[Q->front];
}
//销毁队列
Status DestoryQueue(SqQueue* Q)
{
	if (!(Q->base))
		return ERROR;
	free(Q->base);
	Q->front = Q->rear = 0;
	return OK;
}
//显示队列
void ShowSqQueue(SqQueue Q)
{

	if (Q.front == Q.rear)
	{
		printf("The SqQueue is Empty\n");
		return;
	}
	while (Q.rear != Q.front)
	{
		printf("%d ", Q.base[Q.front]);
		Q.front = (Q.front + 1) % MAXQSIZE;
	}
	putchar('\n');
}

```

测试函数：

```c
//测试函数
int main(void)
{
	SqQueue my_queue;
	QElemType a = 1;
	QElemType b = 2;
	QElemType c = 3;
	QElemType d = 10;
	QElemType answer;
	InitSqQueue(&my_queue);				//测试初始化
	ShowSqQueue(my_queue);
	EnQueue(&my_queue, &a);				//测试入队函数
	EnQueue(&my_queue, &b);
	EnQueue(&my_queue, &c);
	EnQueue(&my_queue, &d);
	ShowSqQueue(my_queue);
	DeQueue(&my_queue, &answer);		//测试出队函数
	printf("The answer is %d\n", answer);
	DestoryQueue(&my_queue);			//测试销毁函数
	ShowSqQueue(my_queue);
	return 0;
}

```

##### 2、队列的 链式 表示和实现

队列的链式表示又称为
**链队**
，具体表示如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2c777b3dfa9462a7c536f8d16a7cd5af.png)

```c
//链队的实现
typedef struct Qnode {
	QElemType data;
	struct Qndoe* next;
} QNode, *QueuePtr;
typedef struct {
	QueuePtr front;		//队头指针
	QueuePtr rear;		//队尾指针
} LinkQueue;

```

在这种表示方法中，
**队头是单链表的头结点的指针，队尾是单链表尾结点的指针。与链栈不同，链队需要两个指针进行操作，是因为队列是在队头进行出队，队尾进行入队，需要两个指针分别来指示队列的队头和队尾。**

1. 链队的初始化

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/03834880242cd2c6abedf65bc59f0efb.png)

2. 链队列的销毁

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ca1035c470989eb43852f7f497f81482.png)

3. 链队列的入队

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3e8c3aa865acb6dd423dd183528a7a0a.png)

4. 链队的出队

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/92546849077efac78ffafc67e1fed515.png)

5. 链队列求队头元素

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a6d5eeaef0ca04878946770d6ee7888b.png)

链队的完整实现
：

```c
//链队的实现
//头文件包含
#include <stdio.h>
#include <stdlib.h>
//函数状态宏定义
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define OVERFLOW -1
//类型定义
typedef int Status;
typedef int QElemType;
//链队结点的定义
typedef struct Qnode {
	QElemType data;
	struct Qnode* next;
} QNode, *QueuePtr;
//链队的定义
typedef struct {
	QueuePtr front;		//队头指针
	QueuePtr rear;
} LinkQueue;
//链队的初始化
Status InitLinkQueue(LinkQueue* Q)
{
	Q->front = Q->rear = (QNode*)malloc(sizeof(QNode));
	if (!Q->rear)
		return ERROR;
	Q->rear->next = NULL;
	return OK;
}
//链队的销毁
Status DestoryLinkQueue(LinkQueue* Q)
{
	QNode* p;
	while (Q->front)
	{
		p = Q->front->next;
		free(Q->front);
		Q->front = p;
	}
	return OK;
}
//链队的入队
Status EnLinkQueue(LinkQueue* Q, QElemType* e)
{
	QNode* new;
	new = (QNode*)malloc(sizeof(QNode));
	new->data = *e;
	new->next = Q->rear->next;
	Q->rear->next = new;
	Q->rear = new;		//更新队列尾指针
	return OK;
}
//链队的出队
Status DeLinkQueue(LinkQueue* Q, QElemType* e)
{
	if (Q->front == Q->rear)
		return ERROR;
	QNode* p;
	p = Q->front->next;
	*e = p->data;
	Q->front->next = p->next;
	if (Q->rear == p)
		Q->front = Q->rear;
	free(p);
	return OK;
}
//获取链队头元素
QElemType GetHead(LinkQueue* Q)
{
	if(Q->front != Q->rear)
		return Q->front->next->data;
}
//显示链队
void ShowLinkQueue(LinkQueue Q)
{
	if (Q.front == Q.rear)
	{
		printf("The LinkQueue is Empty\n");
		return;
	}
	Q.front = Q.front->next;			//跳过头结点
	while (Q.front)
	{
		printf("%d ", Q.front->data);
		Q.front = Q.front->next;
	}
	putchar('\n');
	return OK;
}

```

测试函数：

```c
//测试函数
int main(void)
{
	LinkQueue my_queue;

	QElemType a = 1;
	QElemType b = 10;
	QElemType c = 100;
	QElemType d = 1000;
	QElemType answer;
	InitLinkQueue(&my_queue);			//测试初始化链队
	ShowLinkQueue(my_queue);
	EnLinkQueue(&my_queue, &a);			//测试链队入队
	EnLinkQueue(&my_queue, &b);
	EnLinkQueue(&my_queue, &c);
	EnLinkQueue(&my_queue, &d);
	ShowLinkQueue(my_queue);
	DeLinkQueue(&my_queue, &answer);		//测试链队出队
	printf("The answer is %d\n", answer);
	ShowLinkQueue(my_queue);
	printf("The head is %d\n", GetHead(&my_queue));	//测试获取头元素
	DestoryLinkQueue(&my_queue);			//测试销毁链队
	printf("%d\n", &my_queue==NULL);
	return 0;
}

```

---

### 六、串、数组和广义表

#### （1）串

​ 串（string）（或字符串）是由零个或多个字符组成的有限序列，一般记为
  




s
=
′
a
1
a
2
…
a
n
′
(
n
≥
0
)
s='a\_1a\_2\dots{a\_n}'(n\ge0)





s




=










′






a









1

​



a









2

​




…






a









n

​











′

(

n



≥





0

)
  
其中，

s
s





s
是串的名字，用单引号
`''`
括起来的字符序列是串的值；

a
i
(
1
≤
i
≤
n
)
a\_i(1\le{i}\le{n})






a









i

​


(

1



≤






i



≤






n

)
可以是字母、数字或其他字符；串中字符的数目

n
n





n
称为串的长度。零个字符的串称为空串（null string），它的长度为0。串中任意个连续的字符组成的子序列称为该串的子串。包含
**子串**
的串相应的称为
**主串**
。通常称字符在序列中的序号为该字符在串中的位置。
**子串的位置**
是子串的第一个字符在主串中的位置。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/302efd563eead3eb305cfad39f8fb3da.png)

​ 串也具有顺序存储结构和链式存储结构，分别称为顺序串和链串。

#### （2）串的表示和实现

##### 1、串的 顺序 表示

​ 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义大小，为每个定义的串变量分配一个固定长度的存储区。具体描述如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/61dab8fec9dbe4bf523e4c4283fa4087.png)

```c
//串的顺序存储结构
#define MAXLEN 255
typedef struct {
	char ch[MAXLEN + 1];	 //存储串的一维字符数组
	int length;				//串的当前长度
} SString;

```

##### 2、串的 链式 表示

​ 和线性表的链式存储结构类似，串也可以采用链式表示方法存储串值。由于串结构的特殊性——结构中的每个元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符，这种结构一般称为
**块链**
。由于串长不一定是结点大小的整数倍，所以链表的最后一个结点不一定全被串值占满，此时通常补上“#”或其他非串值字符。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/57e3eeb154c9d0093d2ff5a5c632345a.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/956854e1cb625e693439457279dc9a1e.png)

```c
//串的链式存储结构（块链）
#define CHUNKSIZE 80		//定义块的大小
typedef struct Chunk {
	char ch[CHUNKSIZE];
	struct Chunk* next;
} CHUNK;

typedef struct {
	CHUNK* head, * tail;		//串的头指针和尾指针
	int curlen;					//串的当前长度
} LString;						//字符串的块链结构

```

##### 3、串的模式匹配算法

​ 算法的目的是：确定主串中所含子串（模式串）第一次出现的位置（定位）。算法的种类：
**BE算法**
（Brute Force，暴力破解法）；
**KMP算法**
（特点：速度快）。

**BE算法**
：采用顺序串进行实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4f90e66e5d93b611d320aef693280a8b.png)

算法的步骤：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7411ee67050614a483b3cabe9f5f301d.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6e8131fc6771b2c258cef456f7043bd2.png)

新增了待查找的位置，从pos位置处开始进行查找。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/aaffb2392c3b9f69e98235017c746778.png)

BF
算法的时间复杂度：

​
**最好**
的情况是第一次匹配就成功，设子串的长度为m，主串的长度为n，那么最优的时间复杂度为

O
(
m
)
O(m)





O

(

m

)
；
**最坏**
的情况为前

n
−
m
n-m





n



−





m
次匹配均失败，最后一次匹配成功，时间复杂度为

O
(
(
n
−
m
+
1
)
×
m
)
O((n-m+1)\times{m})





O

(

(

n



−





m



+





1

)



×






m

)
，若

m
<
<
n
m<<n





m



<




<





n
，则时间复杂度为

O
(
n
∗
m
)
O(n*m)





O

(

n



∗





m

)
；
**平均**
时间复杂度为

O
(
n
2
∗
m
)
O(\frac{n}{2}*m)





O

(













2












n

​




∗





m

)
，数量级仍为

O
(
n
∗
m
)
O(n*m)





O

(

n



∗





m

)
。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/07c10c097a41cf92720276348df87846.png)

KMP算法
：采用顺序串进行实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/950416b6cc34029b9b9fee26706cd68f.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c2c592006c0f41a3c8e97184936291a8.png)

next函数使用示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1fe3bd4ec94571c620ef65dce98d7f35.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/65d0136c8a00de0f53f0783b3ae102a7.png)

对next函数的修正方法：（掌握到会计算即可）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2f005e75f4397f6e2ce46fdb669008f4.png)

#### （3）数组

​ 之前讨论的线性结构中的数据元素都是非结构的原子类型，元素的值是不再分解的。而数组和广义表可以看成线性表的一种扩展：表中的数据元素本身也是一个数据结构。

​ 数组：是按照一定格式排列起来的具有相同类型的数据元素的集合。一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。一维数组的逻辑结构：线性结构，定长的线性表。二维数组：若有一维数组中的数据元素又是一维数组结构，则称为二维数组。

数组的定义方法：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1e5105ead94026bc26824bbb153c0354.png)

由此可以看出，线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。

#### （4）数组的表示

​ 数组的特点是：结构固定，且一般不做插入和删除操作，所以一般都是采用顺序结构来表示数组。在C语言中一般采用内置的数组数据类型的定义。

数组的存储，以二维数组为例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d7f0bdf2430a898733ec273579ba0b73.png)

稀疏矩阵的十字链表存储方式：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d33048ba218f298e2ca7a65fc896dec4.png)

分别设置行的头指针，和列的头指针。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/023b1a79347d8557593e5a77f7b57d69.png)

#### （5）广义表

​
**广义表**
（又称为列表list）是

n
≥
0
n\ge{0}





n



≥






0
个元素

(
a
0
,
a
1
,
…
a
n
−
1
)
(a\_0,a\_1,\dots{a\_{n-1}})





(


a









0

​


,




a









1

​


,



…





a










n

−

1

​


)
的有限序列，其中每一个

a
i
a\_i






a









i

​

或者是
**原子**
，或者是一个
**广义表**
。广义表通常记作：

L
S
=
(
a
1
,
a
2
,
…
,
a
n
)
LS=(a\_1,a\_2,\dots{,a\_n})





L

S



=





(


a









1

​


,




a









2

​


,



…




,




a









n

​


)
，其中

L
S
LS





L

S
为表名，

n
n





n
为表的长度，每一个

a
i
a\_i






a









i

​

为表的元素，习惯上一般使用大写字母表示广义表，小写字母表示原子。
**表头**
：若

L
S
LS





L

S
非空

(
n
≥
1
)
(n\ge{1})





(

n



≥






1

)
，则其第一个元素

a
1
a\_1






a









1

​

就是表头，记作

h
e
a
d
(
L
S
)
=
a
1
head(LS)=a\_1





h

e

a

d

(

L

S

)



=






a









1

​

。
**表尾**
：除表头之外的其他元素组成表称为表尾。记作

t
a
i
l
(
L
S
)
=
(
a
2
,
…
,
a
n
)
tail(LS)=(a\_2,\dots{,a\_n})





t

a

i

l

(

L

S

)



=





(


a









2

​


,



…




,




a









n

​


)
。一定注意表尾不是最后一个元素，而是一个子表。

广义表的示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b7ff88d56a4b0444d8f8592264a526aa.png)

广义表的
**长度**
定义为最外层包含的元素个数；广义表的
**深度**
定义为该广义表展开后所含括号的重数，特殊的有，原子的深度为0，空表的深度为1。

广义表和线性表的区别：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/14543389d6a11dcb72b5730cdabbee36.png)

广义表的基本运算操作：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/56c307e47cacf1434fc2368502995aec.png)

广义表的存储：广义表通常采用链表来进行存储（暂不介绍）

---

### 七、树和二叉树

#### （1）树

​
**树（Tree）
**是

n
(
n
≥
0
)
n(n\ge{0})





n

(

n



≥






0

)
个结点的有限集。若

n
=
0
n=0





n



=





0
，则称为空树，若

n
>
0
n>0





n



>





0
，且满足如下两个条件：1、有且仅有一个特定的称为**
根**
（Root）的结点；2、其余结点可分为

m
(
m
≥
0
)
m(m\ge{0})





m

(

m



≥






0

)
个互不相交的有限集

T
1
,
T
2
,
T
3
,
…
,
T
m
T1,T2,T3,\dots,Tm





T

1

,



T

2

,



T

3

,



…



,



T

m
，其中每一个集合本身又是一棵树，并称为根的
**子树**
（SubTree）。树是典型的非线性结构。

​ 树的基本术语：1、
**根节点**
：非空树中无前驱结点的结点；2、结点的
**度**
：该结点拥有子树（分支）的个数；3、
**树的度**
：树内所有结点的度的最大值；4、
**叶子**
（终端）结点：度为零的结点称为叶子结点；5、
**分支（
**非终端）结点：度不为零的结点；6、
**兄弟**
结点：有共同双亲的结点称为兄弟结点；7、树的**
深度**
（高度）：树中结点的最大层次；8、
**有序树**
：树中结点的各子树从左到右有次序；9、
**无序树**
：树中结点的各子树无次序；10、
**森林**
：是

m
(
m
≥
0
)
m(m\ge{0})





m

(

m



≥






0

)
棵互不相交的树的集合。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bad96318d1f228e9364be1ebcc93bd46.png)

线性结构和树型结构的对比：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e69d07e2cf4746d6486838a1c4c98988.png)

#### （2）二叉树

​
**二叉树（Binary Tree）**
，是

n
(
n
≥
0
)
n(n\ge{0})





n

(

n



≥






0

)
个结点的有限集，或者它是空集

(
n
=
0
)
(n=0)





(

n



=





0

)
，或者有一个根节点及两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成。二叉树的特点：1、每个结点最多有两个子树；2、子树有左右之分，其次序不能颠倒；3、二叉树可以是空集合，根可以有空的左子树或空的右子树。

​
**二叉树和树的区别**
：二叉树的结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明该子树是左子树还是右子树。当树只有一个结点时，就无需区分它是左还是右的次序，因此二者是不同的。这就是二叉树和树的主要区别。

​ 二叉树的
**性质**
：1、在二叉树的第

i
i





i
层上至多有

2
i
−
1
2^{i-1}






2










i

−

1
个结点

(
i
≥
1
)
(i\ge{1})





(

i



≥






1

)
，那么有

n
n





n
个结点的二叉树，深度为

⌊
l
o
g
2
n
⌋
+
1
\lfloor{log\_2n}\rfloor+1





⌊


l

o


g









2

​


n

⌋



+





1
；2、第

i
i





i
层上最少有一个结点；3、深度为

k
k





k
的二叉树至多有

2
k
−
1
2^k-1






2









k



−





1
个结点

(
k
≥
1
)
(k\ge{1})





(

k



≥






1

)
；4、对于任何一棵二叉树

T
T





T
，如果其叶子树为

n
0
n\_0






n









0

​

，所有度为2的节点数为

n
2
n\_2






n









2

​

，则

n
2
=
n
2
+
1
n\_2=n\_2+1






n









2

​




=






n









2

​




+





1
。

性质4分析：

n
i
n\_i






n









i

​

是度为

i
i





i
的结点，

n
n





n
是所有结点的总数。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ee4975d2902f128161fc1963471adbab.png)

```
**满二叉树**，一棵深度为$k$且有$2^k-1$个结点的二叉树称为满二叉树。特点：1、每一层上的结点数都是最大结点数（即每层都是满的）；2、叶子结点全部在最底层。对满二叉树位置进行编号，编号规则：从根结点开始，**自上而下，自左而右**；每一结点位置都有元素。

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e10310b94dd081b222c6c4702b09a991.png)

​
**完全二叉树**
，深度为

k
k





k
的具有

n
n





n
个结点的二叉树，当且仅当其每一个结点都与深度为

k
k





k
的满二叉树中编号为

1
 
n
1~n





1



n
的结点一一对应时，称之为完全二叉树。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2b60a4916b46f4c213bd3cd636858211.png)

完全二叉树的
**简单判别方式**
：在满二叉树中，从最后一个结点开始，
**连续**
去掉
**任意**
个结点，即获得了一棵完全二叉树。

​ 完全二叉树的
**特点**
：1、叶子只可能分布在层次最大的两层上；2、对任一结点，如果其右子树的最大层次为

i
i





i
，则其左子树的最大层次必为

i
i





i
或

i
+
1
i+1





i



+





1
。

​ 完全二叉树的
**性质**
：1、具有

n
n





n
个结点的完全二叉树的深度为

⌊
l
o
g
2
n
⌋
+
1
\lfloor{log\_2{n}}\rfloor{+1}





⌊


l

o


g









2

​



n

⌋


+

1
，其中

⌊
x
⌋
\lfloor{x}\rfloor





⌊


x

⌋
称作

x
x





x
的底（向下取整），表示不大于

x
x





x
的最大整数。2、如果对一棵有

n
n





n
个结点的完全二叉树（深度为

⌊
l
o
g
2
n
⌋
+
1
\lfloor{log\_2{n}}\rfloor{+1}





⌊


l

o


g









2

​



n

⌋


+

1
的结点按层序编号（从第

1
1





1
层到第

⌊
l
o
g
2
n
⌋
+
1
\lfloor{log\_2{n}}\rfloor{+1}





⌊


l

o


g









2

​



n

⌋


+

1
层，每层从左往右），则对任一结点

i
(
1
≤
i
≤
n
)
i(1\le{i}\le{n})





i

(

1



≤






i



≤






n

)
有：a、如果

i
=
1
i=1





i



=





1
，则结点

i
i





i
是二叉树的根，无双亲；如果

i
>
1
i>1





i



>





1
，则其双亲结点

⌊
i
/
2
⌋
\lfloor{i/2}\rfloor





⌊


i

/

2

⌋
。b、如果

2
i
>
n
2i>n





2

i



>





n
，则结点

i
i





i
为叶子结点，无左孩子；否则，其左孩子结点是

2
i
2i





2

i
。c、如果

2
i
+
1
>
n
2i+1>n





2

i



+





1



>





n
，则结点

i
i





i
无右孩子；否则，其右孩子是结点

2
i
+
1
2i+1





2

i



+





1
。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b5f26b70c32df6dce64b3b0e0eb0f49c.png)

该性质2表明了完全二叉树中
**双亲结点**
编号和
**孩子结点**
编号之间的关系。

#### （3）二叉树的表示

​ 二叉树的存储结构，包括顺序存储结构和链式存储结构，链式存储结构又包括二叉链表和三叉链表。

##### 1、二叉树的 顺序 存储结构

​ 二叉树的顺序存储结构：实现，按照满二叉树的结点层次进行编号，依次存放二叉树中的数据元素。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f7a9c263b419f1952051cfe50d9e0838.png)

不完全二叉树如何进行存储：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/825af43a3ce9af3f98f479390054e8a2.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4b254e213c66da9977b359da31d0c496.png)

```c
//二叉树的顺序存储
#define MAXTSIZE 100
typedef TElemType SqBiTree[MAXTSIZE];
SqBiTree bt;			//创建一个二叉树

```

##### 2、二叉树的 链式 存储结构

​ 二叉树的链式存储结构中的
二叉链表
，需要包含指向左右子树的指针，还需包含本身结点的数据域。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4d4f77968fe57322a924bc78b5667837.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c8e216565e1ee430cfc42ad9f827d3fd.png)

```c
//二叉树的链式存储结构
typedef struct Binode {
	TElemType data;
	struct Binode* lchild, * rchild;	//左右孩子指针
}BiNode, *BiTree;

```

二叉树链式存储（二叉链表）示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6a98cae808f1026fec39ff6da14bfb50.png)

**结论**
：在

n
n





n
个结点的二叉链表中，一定有

n
+
1
n+1





n



+





1
个空指针域。分析：

n
n





n
个结点的二叉链表，一定有

2
n
2n





2

n
个链域，每个结点都会有一个双亲（除根节点），所以会存在

n
−
1
n-1





n



−





1
个结点的链域存放指针，那么空指针的个数为

2
n
−
(
n
−
1
)
=
n
+
1
2n-(n-1)=n+1





2

n



−





(

n



−





1

)



=





n



+





1
。

​
三叉链表
，除了需要包含指向左右子树的指针，还需要包含指向双亲结点的指针，同时还需要含本身结点的数据域。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/34b7cfecc0a09737f60a3068e986947e.png)

```c
//三叉链表
typedef struct Trinode {
	TElemType data;
	struct Trinode* lchild, * rchild;	//左右孩子指针
	struct Trinode* parent;  //双亲指针
} TriNode, *TriTree;

```

#### （4）二叉树的遍历

​ 二叉树遍历的
**定义**
：顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。遍历的目的是得到树种所有结点的一个线性排列。 如果规定左右子树的访问顺序为先左后右，那么有三种遍历方式：都是以
**递归**
的方式进行

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2826bb8bf0499b82ac6fdd39cf2f2ef4.png)

先序遍历（根左右）示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6dd383f016737199a2cf3725b9e9f425.png)

中序遍历（左根右）示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9022eb210e8f96be5ae32c29ca2360cd.png)

后序遍历（左右根）示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/98c63fb216c0a045764a88fe0b4b214f.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f68c893fb0feb732220220a80de9023b.png)

**已知先序和中序序列求二叉树**
的方法：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dfc07da2b49b8734db9eb08f9319a59c.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8c972df67c08bf0a165bc7d7aee890bf.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/552af553276d35654fd10edd75e2d820.png)

**已知中序和后序序列求二叉树**
的方法：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8aa20e88856b5d0a375e11d4af909a23.png)

如果只知道先序和后序序列是不能确定二叉树的形状的，因为只知道先序和后序不能唯一确定根结点的位置。

##### 1、 先序 遍历的实现

均在
**二叉链表**
的基础上进行实现：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7b350e57fcd0f6e6e22c5fda88f3a9b7.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c3ca6212712933eafa3b834adfc7ab12.png)

先序遍历递归调用的执行过程：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/888b73240b17d537a2c8824bcdb4ae4e.png)

##### 2、 中序 遍历的实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2a311206429637fd0bed0c874b8e8718.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/91e04d91714132adc080aa478e6713cd.png)

##### 3、 后序 遍历的实现

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/69a483c405ff4c857e42db5fb1147c5a.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/08b090211536f9d26554285df5582e79.png)

​ 三种遍历算法的对比，如果去掉输出语句，从递归的角度来看，三种算法是完全相同的，或者说这三种算法的访问路径是相同的，只是算法访问结点的时机不同。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/270df117cf78172144500a00f85218ba.png)

遍历算法分析，时间复杂度为：

O
(
n
)
O(n)





O

(

n

)
，因为每个结点都只访问一次；空间复杂度：

O
(
n
)
O(n)





O

(

n

)
，最坏情况下栈占用最大的辅助空间。

##### 4、中序遍历的 非递归 算法

​ 二叉树中序遍历的非递归算法的关键：在中序遍历过某个结点的整个左子树后，如何找到该结点的根以及右子树。基本思想如下：1、建立一个
**栈**
；2、根结点进栈，遍历左子树；3、根结点出栈，输出根结点，遍历右子树。（很巧妙）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ec72fed90eaf6dd0d16ec30dad27ccc6.png)

##### 5、二叉树的 层次 遍历

​ 二叉树的层次遍历：对于一棵二叉树，从根结点开始，按从上到下，从左到右的顺序逐层访问每一个结点，每个结点仅访问一次。

​ 算法设计
**思路**
：使用一个队列。1、将根结点入队；2、队列不为空时循环，从队列中出队一个结点
`*p`
，访问它；若它有左孩子结点，将左孩子结点入队；若它有右孩子结点，将右孩子结点入队。这里实现时，采用顺序循环队列。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3f0c0fa9ebf35448311835819e5efd51.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2f80a64ad8c2876dbf7b4390d50cf740.png)

#### （5）二叉树遍历算法的 应用

##### 1、二叉树的建立

应用先序遍历算法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/345998ca9ab2da1ce2812a399953cada.png)

##### 2、复制二叉树

应用先序遍历算法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/67a5d287e8ad556b17410e5edeb892c2.png)

##### 3、计算二叉树的深度

应用先序遍历算法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f00b91992c24377deb5f089e84f9dd4a.png)

##### 4、计算二叉树结点的总个数

应用先序遍历算法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4f9f83e2e1fa6aff8a39dad764c4d43d.png)

(
(
0
+
0
+
1
)
+
(
(
0
+
0
+
1
)
+
0
+
1
)
+
1
)
+
(
(
(
0
+
0
+
1
)
+
1
)
+
0
+
1
)
+
1
((0+0+1)+((0+0+1)+0+1)+1)+(((0+0+1)+1)+0+1)+1





(

(

0



+





0



+





1

)



+





(

(

0



+





0



+





1

)



+





0



+





1

)



+





1

)



+





(

(

(

0



+





0



+





1

)



+





1

)



+





0



+





1

)



+





1

##### 5、计算二叉树叶子结点的总个数

应用先序遍历算法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/91afbaeb0affe77ade3889706c42d5d6.png)

#### （6） 线索 二叉树

​ 二叉链表存储的特点：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/715d65b6672252d748d95a2b9aa4ce45.png)

​
**线索二叉树（Threaded Binary Tree）**
，线索二叉树的改进：利用二叉链表中的空指针域。如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某个结点的右孩子为空，则将空的右孩子指针域改为指向其后继。（
**注**
：这里说的前驱和后继指的是按照先序、中序或者后序遍历得到的结点顺序。）这种改变指向的指针称为“线索”。对二叉树按某种遍历次序使其变为线索二叉树的过程称为
**线索化**
。

线索二叉树示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a8fdac934173a58f836e3615432cc3a0.png)

线索二叉树的表示：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/53c1c6330be63c7cf3d697b64c7ec761.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8a8e630f1325284b87925ae3b85cf2d6.png)

```c
//线索二叉树
typedef struct BiThrnode {
	int data;
	int ltag, rtag;
	struct BiThrnode* lchild, * rchild;
} BiThrNode, *BiThrTree;

```

线索二叉树表示示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/045396f10d90d3449bfd35d0821eb403.png)

为了统一，给线索二叉树新增了头结点，如示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/496282acb6f3cc0cb8c904e799449a06.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3367715d49844b21e18e171de3876c68.png)

#### （7）树的存储结构

##### 1、双亲表示法

​ 树的
**双亲表示法**
：定义结构数组存放树的结点每个结点含有两个域，数据域：存放结点本身信息；双亲域：指示本届点的双亲结点在数组中的位置。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9a44956510a050208b68ae5f40da3a16.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ce0f4dab38d6d69951974d3d6de9fc5f.png)

```c
//树的双亲表示法
typedef struct PTnode {
	TElemType data;
	int parent;		//双亲位置域
} PTNode;
#define MAX_TREE_SIZE 100
typedef struct {
	PTNode nodes[MAX_TREE_SIZE];
	int r, n;		//指向根结点的位置和结点的个数的索引
} PTree;

```

##### 2、孩子链表

​ 树的
**孩子链表**
，是把每个结点的孩子结点排列起来，看成一个线性表，用单链表存储，则

n
n





n
个结点有

n
n





n
个孩子链表（叶子结点的孩子链表为空）。而

n
n





n
个头指针又组成了一个线性表，用顺序表（含

n
n





n
个元素的结构数组）存储。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3fd192d7f5749e51b78658296c5bb7b9.png)

将孩子链表和双亲表示法结合起来，获得了带双亲的孩子链表。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e30dfc338b42f5637504f0ae9a5ec976.png)

```c
//孩子链表
typedef struct CTnode {	//孩子结点 child + next
	int child;
	struct CTnode* next;
} *ChildPtr;
typedef struct {	//双亲结点 data + firstchild
	TElemType data;
	ChildPtr firstchild;	//孩子链表头指针
} CTBox;
#define MAX_TREE_SIZE 100
typedef struct {
	CTBox nodes[MAX_TREE_SIZE];
	int n, r;		//指向结点数和根结点位置的索引
} CTree;

```

##### 3、孩子兄弟表示法（二叉树表示法）

​ 二叉树表示法，实现：用二叉链表作为树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b6a4d8d9ba595a1b4f3b4bbdb7b928db.png)

```c
//孩子兄弟表示法（二叉树表示法）
typedef struct CSnode {
	ElemType data;
	struct CSnode* firstchild, *nextsiblingl;
}CSNode, *CSTree;

```

孩子兄弟表示法示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5d585570e7c76f59d76f683b1b576928.png)

##### 4、树和二叉树的转换

​ 由于树和二叉树都可以用二叉链表作为存储结构，则以
**二叉链表作为媒介**
可以导出数和二叉树之间的一个对应关系。

举个例子：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e1eb4f267efd29ac96260f136214fcc1.png)

​
**将树转化为二叉树**
：1、加线，在兄弟结点之间加一条线；2、抹线，对于每个结点，除了其左孩子外，去除与其他孩子之间的关系；3、旋转，以树的根结点为轴心，将整个树顺时针旋转
**45°**
。示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/55264b5bd728ebcf463a359c6d58631d.png)

​
**将二叉树转化为树**
：1、加线，若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子

…
\dots





…
沿分支找到所有的右孩子，都与p的双亲用线连起来；2、抹线，抹掉原二叉树中双亲与右孩子之间的连线；3、调整，将结点按层次排列，形成树结构。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f2b5481d5b8873f69779b36238bc8761.png)

##### 5、森林和二叉树的转换

​
**森林转换成二叉树**
：1、将各棵树分别转换成二叉树；2、将每棵树的根结点用线相连；3、以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树结构。示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/81af45ee53ed404b35d95093df28c2f2.png)

​
**二叉树转换成森林**
：1、抹线，将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；2、还原， 将孤立的二叉树还原成树。示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f4f22075aa7847a1fc01d9a0b3e45aeb.png)

#### （8）树与森林的遍历

##### 1、树的遍历

​ 树的遍历主要包括三种方式。1、
**先根**
次序遍历：若树不为空，则先访问根结点，然后依次先根遍历各子树；2、
**后根**
次序遍历：若树不为空，则先依次后根遍历各子树，然后访问根结点；3、按
**层次**
遍历：若树不为空，则自上而下自左而右访问树中每个结点。

##### 2、森林的遍历

​ 将森林看作由
**三部分**
构成：1、森林中第一棵树的根结点；2、森林中第一棵树的子树森林；3、森林中其它树构成的森林。森林的遍历方式有：1、
**先序遍历**
：访问森林中第一棵树的根结点，先序遍历森林中第一棵树的子树森林，先序遍历森林中其余树构成的森林。2、
**中序遍历**
：中序遍历森林中第一棵子树的子树森林，访问森森林中第一棵树的根结点，中序遍历森林中其余树构成的森林。

#### （9） 哈夫曼树

​ 哈夫曼树（最优二叉树）的
**基本概念**
，1、
**路径**
：从树中一个结点到另一个结点之间的
**分支**
构成这两个结点间的路径；2、
**结点**
的路径长度：两结点间路径上的分支数；3、
**树**
的路径长度：从树根结点到每个结点的路径长度之和，记作

T
L
TL





T

L
；4、
**权**
：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权；5、结点的
**带权路径长度**
（Weighted Path Length，WPL）：从根结点到该结点之间的路径长度

×
\times





×
该结点的权；6、
**树**
的带权路径长度：树中所有
**叶子**
结点的带权路径长度之和，记作
  




W
P
L
=
∑
k
=
1
n
w
k
l
k
WPL=\sum\_{k=1}^{n}{w\_kl\_k}





W

P

L



=














k

=

1





∑






n

​






w









k

​



l









k

​

  
7、哈夫曼树的
**定义**
：
**最优树**
，带权路径长度（WPL）最短的树；8、哈夫曼树的
**定义**
：
**最优二叉树**
，带权路径长度（WPL）最短的二叉树。

哈夫曼树的
**构造方法**
：

> 1、根据
>
> n
> n
>
>
>
>
>
> n
> 个给定的权值
>
> {
> W
> 1
> ,
> W
> 2
> ,
> …
> W
> n
> }
> \{
> {W\_1,W\_2,\dots{W\_n}}\}
>
>
>
>
>
> {
>
>
>
> W
>
>
>
>
>
>
>
>
>
> 1
>
> ​
>
>
> ,
>
>
>
>
> W
>
>
>
>
>
>
>
>
>
> 2
>
> ​
>
>
> ,
>
>
>
> …
>
>
>
>
>
> W
>
>
>
>
>
>
>
>
>
> n
>
> ​
>
>
> }
> 构成
>
> n
> n
>
>
>
>
>
> n
> 棵二叉树的森林
>
> F
> =
> {
> T
> 1
> ,
> T
> 2
> ,
> …
> ,
> T
> n
> }
> F=\{
> {T\_1,T\_2,\dots,{T\_n}}\}
>
>
>
>
>
> F
>
>
>
> =
>
>
>
>
>
> {
>
>
>
> T
>
>
>
>
>
>
>
>
>
> 1
>
> ​
>
>
> ,
>
>
>
>
> T
>
>
>
>
>
>
>
>
>
> 2
>
> ​
>
>
> ,
>
>
>
> …
>
>
>
> ,
>
>
>
>
>
> T
>
>
>
>
>
>
>
>
>
> n
>
> ​
>
>
> }
> ，其中
>
> T
> i
> T\_i
>
>
>
>
>
>
> T
>
>
>
>
>
>
>
>
>
> i
>
> ​
>
> 只有一个带权为
>
> W
> i
> W\_i
>
>
>
>
>
>
> W
>
>
>
>
>
>
>
>
>
> i
>
> ​
>
> 的根结点。（构造森林全是根）
>
> 2、在
>
> F
> F
>
>
>
>
>
> F
> 中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。（选用两小造新树）
>
> 3、在
>
> F
> F
>
>
>
>
>
> F
> 中删除这两棵树，同时将得到的二叉树加入森林中。（选用两小造新树）
>
> 4、重复2和3，直到森林中只有一棵树为止，这棵树即待构造的哈夫曼树。（删除两小添新人）

哈夫曼树构造示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c60715e4b22aa089a16ca92f2444a78a.png)

哈夫曼树小结：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/487406733d4626c76d100e58acf3e62b.png)

#### （10）哈夫曼树的表示

​ 哈夫曼树实际上就是一种特殊的二叉树，可以采用顺序存储结构，也可以采用链式存储结构。

##### 1、哈夫曼树的 顺序 存储结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ae204ddacf545c09a3aa8a534c664cdb.png)

```c
//哈夫曼树Huffman Tree
typedef struct {
	int weight;
	int parent, lch, rch;
} HTNode, *HuffmanTree;

```

哈夫曼构造算法的实现：

> 1、初始化
>
> H
> T
> [
> 1
> …
> 2
> n
> −
> 1
> ]
> HT[1\dots{2n-1}]
>
>
>
>
>
> H
>
> T
>
> [
>
> 1
>
>
>
> …
>
>
>
>
> 2
>
> n
>
>
>
> −
>
>
>
> 1
>
> ]
> ，lch=rch=parent=0。
>
> 2、输入初始
>
> n
> n
>
>
>
>
>
> n
> 个叶子结点，置
>
> H
> T
> [
> 1
> …
> n
> ]
> HT[1\dots{n}]
>
>
>
>
>
> H
>
> T
>
> [
>
> 1
>
>
>
> …
>
>
>
>
> n
>
> ]
> 的weight值。
>
> 3、进行以下
>
> n
> −
> 1
> n-1
>
>
>
>
>
> n
>
>
>
> −
>
>
>
>
>
> 1
> 次合并，依次产生
>
> n
> −
> 1
> n-1
>
>
>
>
>
> n
>
>
>
> −
>
>
>
>
>
> 1
> 个结点
>
> H
> T
> [
> i
> ]
> ,
> i
> =
> n
> +
> 1
> …
> 2
> n
> −
> 1
> HT[i],i=n+1\dots{2n-1}
>
>
>
>
>
> H
>
> T
>
> [
>
> i
>
> ]
>
> ,
>
>
>
> i
>
>
>
> =
>
>
>
>
>
> n
>
>
>
> +
>
>
>
>
>
> 1
>
>
>
> …
>
>
>
>
> 2
>
> n
>
>
>
> −
>
>
>
> 1
> ：
>
> > a）在
> >
> > H
> > T
> > [
> > 1
> > …
> > i
> > −
> > 1
> > ]
> > HT[1\dots{i-1}]
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > 1
> >
> >
> >
> > …
> >
> >
> >
> >
> > i
> >
> >
> >
> > −
> >
> >
> >
> > 1
> >
> > ]
> > 中选择两个未被选过（从parent==0的结点中选择）的weight最小的两个结点
> >
> > H
> > T
> > [
> > s
> > 1
> > ]
> > HT[s1]
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > s
> >
> > 1
> >
> > ]
> > 和
> >
> > H
> > T
> > [
> > s
> > 2
> > ]
> > HT[s2]
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > s
> >
> > 2
> >
> > ]
> > ，
> >
> > s
> > 1
> > ,
> > s
> > 2
> > s1,s2
> >
> >
> >
> >
> >
> > s
> >
> > 1
> >
> > ,
> >
> >
> >
> > s
> >
> > 2
> > 为两个最小结点的下标。
> >
> > b）修改
> >
> > H
> > T
> > [
> > s
> > 1
> > ]
> > HT[s1]
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > s
> >
> > 1
> >
> > ]
> > 和
> >
> > H
> > T
> > [
> > s
> > 2
> > ]
> > HT[s2]
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > s
> >
> > 2
> >
> > ]
> > 的parent值，
> >
> > H
> > T
> > [
> > s
> > 1
> > ]
> > .
> > p
> > a
> > r
> > e
> > n
> > t
> > =
> > i
> > HT[s1].parent=i
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > s
> >
> > 1
> >
> > ]
> >
> > .
> >
> > p
> >
> > a
> >
> > r
> >
> > e
> >
> > n
> >
> > t
> >
> >
> >
> > =
> >
> >
> >
> >
> >
> > i
> > ；
> >
> > H
> > T
> > [
> > s
> > 2
> > ]
> > .
> > p
> > a
> > r
> > e
> > n
> > t
> > =
> > i
> > HT[s2].parent=i
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > s
> >
> > 2
> >
> > ]
> >
> > .
> >
> > p
> >
> > a
> >
> > r
> >
> > e
> >
> > n
> >
> > t
> >
> >
> >
> > =
> >
> >
> >
> >
> >
> > i
> > ；
> >
> > c）修改新产生的
> >
> > H
> > T
> > [
> > i
> > ]
> > HT[i]
> >
> >
> >
> >
> >
> > H
> >
> > T
> >
> > [
> >
> > i
> >
> > ]
> > ：
> >
> > > * H
> > >   T
> > >   [
> > >   i
> > >   ]
> > >   .
> > >   w
> > >   e
> > >   i
> > >   g
> > >   h
> > >   t
> > >   =
> > >   H
> > >   T
> > >   [
> > >   s
> > >   1
> > >   ]
> > >   .
> > >   w
> > >   e
> > >   i
> > >   g
> > >   h
> > >   t
> > >   +
> > >   H
> > >   T
> > >   [
> > >   s
> > >   2
> > >   ]
> > >   .
> > >   w
> > >   e
> > >   i
> > >   g
> > >   h
> > >   t
> > >   HT[i].weight=HT[s1].weight+HT[s2].weight
> > >
> > >
> > >
> > >
> > >
> > >   H
> > >
> > >   T
> > >
> > >   [
> > >
> > >   i
> > >
> > >   ]
> > >
> > >   .
> > >
> > >   w
> > >
> > >   e
> > >
> > >   i
> > >
> > >   g
> > >
> > >   h
> > >
> > >   t
> > >
> > >
> > >
> > >   =
> > >
> > >
> > >
> > >
> > >
> > >   H
> > >
> > >   T
> > >
> > >   [
> > >
> > >   s
> > >
> > >   1
> > >
> > >   ]
> > >
> > >   .
> > >
> > >   w
> > >
> > >   e
> > >
> > >   i
> > >
> > >   g
> > >
> > >   h
> > >
> > >   t
> > >
> > >
> > >
> > >   +
> > >
> > >
> > >
> > >
> > >
> > >   H
> > >
> > >   T
> > >
> > >   [
> > >
> > >   s
> > >
> > >   2
> > >
> > >   ]
> > >
> > >   .
> > >
> > >   w
> > >
> > >   e
> > >
> > >   i
> > >
> > >   g
> > >
> > >   h
> > >
> > >   t
> > >   ；
> > > * H
> > >   T
> > >   [
> > >   i
> > >   ]
> > >   .
> > >   l
> > >   c
> > >   h
> > >   =
> > >   s
> > >   1
> > >   ;
> > >   H
> > >   T
> > >   [
> > >   i
> > >   ]
> > >   .
> > >   r
> > >   c
> > >   h
> > >   =
> > >   s
> > >   2
> > >   HT[i].lch=s1; HT[i].rch=s2
> > >
> > >
> > >
> > >
> > >
> > >   H
> > >
> > >   T
> > >
> > >   [
> > >
> > >   i
> > >
> > >   ]
> > >
> > >   .
> > >
> > >   l
> > >
> > >   c
> > >
> > >   h
> > >
> > >
> > >
> > >   =
> > >
> > >
> > >
> > >
> > >
> > >   s
> > >
> > >   1
> > >
> > >   ;
> > >
> > >
> > >
> > >   H
> > >
> > >   T
> > >
> > >   [
> > >
> > >   i
> > >
> > >   ]
> > >
> > >   .
> > >
> > >   r
> > >
> > >   c
> > >
> > >   h
> > >
> > >
> > >
> > >   =
> > >
> > >
> > >
> > >
> > >
> > >   s
> > >
> > >   2
> > >   ；

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/45cb0206fa55c407ce011fb09ba40282.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d55882c8d533a2a24fc01646481220dd.png)

#### （11）哈夫曼编码

​ 哈夫曼编码：1、统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。2、利用哈夫曼树的特点，权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树，则概率越大的结点路径越短。3、在哈夫曼树的每个分支上标0或1，结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b8afa862486295e7f45b5f828623827f.png)

哈夫曼编码不仅能够保证是前缀码，并且能保证字符编码总长最短。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1442ae442abec91b5631c0af67c735bb.png)

哈夫曼编码的实现：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/51a54d78613ae62088dfc04800bcd9d5.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bbc5be5813ddfb6f3084456bfc0060a8.png)

文件的编码和解码：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/94c03a3761f4f1d6d3c030b8a4c50602.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1870c8ded45cefa074d1bb3b7c4491d8.png)

---

### 八、图

#### （1）图的定义

​
**图**
是一种较为复杂的数据结构，在图中两个结点之间的关系可以是任意的，图中任意两个数据元素之间都有可能相关。在图中的数据元素通常称为顶点（Vertex），

V
V





V
是顶点的有穷非空集合，

E
E





E
是边有穷集合；

V
R
VR





V

R
是两个顶点之间的关系的集合。若

⟨
v
,
w
⟩
∈
V
R
\langle{v,w}\rangle{\in}VR





⟨


v

,



w

⟩


∈

V

R
，则

⟨
v
,
w
⟩
\langle{v,w}\rangle





⟨


v

,



w

⟩
表示从

v
v





v
到

w
w





w
的一条弧（Arc），且称

v
v





v
为弧尾（Tail），称

w
w





w
尾弧头（Head），此时的图称为
**有向图**
（Digraph）。若

⟨
v
,
w
⟩
∈
V
R
\langle{v,w}\rangle\in{VR}





⟨


v

,



w

⟩



∈






V

R
，则必有

⟨
w
,
v
⟩
∈
V
R
\langle{w,v}\rangle\in{VR}





⟨


w

,



v

⟩



∈






V

R
，即

V
R
VR





V

R
是对称的，则以无序对

(
v
,
w
)
(v,w)





(

v

,



w

)
代替这两个有序对，表示

v
v





v
和

w
w





w
之间的一条边（Edge），此时的图称为
**无向图**
（Undigraph）。当任意两个顶点之间都具有边的时候，此时的图称为
**完全图**
，完全图又分为有向完全图和无向完全图。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2ef52fc3d1aab466283ec0044e26d51a.png)

有很少的边或者弧

(
e
<
n
l
o
g
n
)
(e<nlogn)





(

e



<





n

l

o

g

n

)
的图称为
**稀疏图**
（Sparse graph），反之称为
**稠密图**
（Dense graph）。有些图的边或者弧具有与之相关的数，这种数称为
**权**
（Weight），这种带权的图称为
**网**
（Network)。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/221d618905fbe444c821590bbd8ffffd.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7c6ebde9a0bb64e4863eeabe7e04d4c7.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/33450e61d2a2159a4b160a1008064872.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1563c93d29a864f06c106023d551e8e4.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a1f2b2986977b9f61c28122e930c62cd.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f841e7fa035a3a8b7a71cd82c2b21062.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7e2e38e298ada7f9a76bddae368a56c7.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cdbc3ff49e80d529e45831fae258f4e3.png)

#### （2）图的表示

​ 图没有顺序结构，但是可以借助二维数组来描述元素之间的关系。数组表示法可以采用
**邻接矩阵**
（数组表示法）来表示。图具有链式结构，可以采用
**邻接表**
（链式表示法）来表示。

##### 1、 数组 （邻接矩阵）表示法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6201b9e52d515e9947869d3d21a81740.png)

邻接矩阵表示示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d340ff3bfd761bcc14eb4f07aab87e60.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cd8498a0d913ac40e6a8150ef9ea12de.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/55ce2777f4518bdba2cf859e19102a1d.png)

邻接矩阵表示图的类型定义：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ae616e8b3e7456ac26d3d4fd3403a162.png)

```c
//邻接矩阵表示图
#define MaxInt 32767			//表示极大值，即无穷大
#define MVNum 100				//最大顶点数
typedef char VerTexType;		//设顶点数的数据类型为字符型
typedef int ArcType;			//假设边的权值类型为整型
typedef struct {
	VerTexType vexs[MVNum];		//顶点表
	ArcType arcs[MVNum][MVNum]; //邻接矩阵
	int vexnum, arcnum;			//图的当前点数和边数
} AMGraph;						//Adjecency Matrix Graph

```

1、采用邻接矩阵创建无向网

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/422fdef6fa7b625f137ff9a6144d423e.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/584de5608ee6e149b606859f22970ede.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/39aafe4ac0dd847223076707561fb5bf.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/231eb316982bdc0caf804c1f48a1de1e.png)

2、采用邻接矩阵创建无向图、有向图（由算法1改进而来）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ab3a952f9b0603ad2ab271dbeb71e0ee.png)

##### 2、 链表 （邻接表）表示法

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e67d79aea8377cadb848cc45754ad3cc.png)

无向图的邻接表：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2731eb5aab02cac36e6914b6fd6e72f2.png)

有向图的邻接表：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6815fcf9351d0dd6acb1de34974aeb4b.png)

邻接表表示法的实现：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/217f9093ca7737672e6f3a16b2659f5f.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a2d3514b2ac33f01505b4171ea0d7bfd.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/98214612a0fbbb58309c9c054c96a92b.png)

```c
//邻接表表示法的实现
#define MVNum 100			//最大顶点数
typedef struct Arcnode {	//边结点
	int adjvex;				//该边所指向的顶点的位置
	struct Arcnode* nextarc;	//指向下一条边的指针
	OtherInfo info;				//和边相关的信息
}ArcNode;
typedef struct Vnode {
	VerTexType data;		//顶点信息
	ArcNode* firstarc;		//指向第一条衣服该顶点的指针
} VNode, AdjList[MVNum];	//AdjList表示邻接表类型
//图结构的定义
typedef struct {
	AdjList vertices;		//vertices-vertex的复数
	int vexnum; arcnum;		//图当前的顶点数和弧数
}ALGraph;

```

1、采用邻接表建立无向网

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/928aad798e5cc4d71fa4a8e9bf83b153.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8eb99de673be3387e8d4835ffea7fd00.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ba2472e25074d45f74c8c74a4a5c1716.png)

#### （3）图的遍历

​ 从已给的连通图中某一顶点出发，沿着一些边访问图中所有的顶点，且使每个顶点仅被访问一次，这就叫做图的遍历，它是图的基本运算。遍历的
**实质**
是找每个顶点的邻接点的过程。

如何避免重复访问：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f0f4df84ccdc159974adc754f3401f08.png)

##### 1、 深度 优先搜索遍历（Depth First Search — DFS）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c91089fa38d425564dfe5c62546e3a7a.png)

用邻接矩阵实现图的深度优先搜索遍历：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a00c83aae7a24d346e8ac26276e1b08b.png)

##### 2、 广度 优先搜索遍历（Breath First Search — BFS）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/aaeab34654bd2cec1ec38251140ba2d3.png)

用邻接表实现图的广度优先搜索遍历：广度优先搜索遍历和树的层次遍历的思想类似。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/33c57925a60bc6548bc4f9cc1e1e1bc1.png)

#### （4）图的应用

##### 1、最小生成树

​ 生成树是所有顶点都连在一起，但不存在回路的图。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/abb3fd260e16e2d58d77a81a70b08f62.png)

​ 最小生成树：给定一个无向网，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7d1cf0669c62b1646327b065cd097fee.png)

MST性质

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/75f927cad6be02bf2e095cc13d68c791.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b3fd2fa2200cd0b9ce56eae6ed629088.png)

构造最小生成树**普里姆（Prim）**算法：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/386428dda3064551f547f1278ec4eb5e.png)

构造最小生成树**克鲁斯卡尔（Kruskal）**算法：（贪心算法）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5c51294b387a83594cde1428c8ed7e26.png)

##### 2、最短路径

​ 最短路径问题：在有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。第一类问题（
**单源最短路径**
）采用**Dijkstra（迪杰斯特拉）
**算法，第二类问题（
**所有顶点间的最短路径**
），采用**
Floyd（佛洛依德）**算法。

**Dijkstra算法**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7809bcd145c74e991fc9b18fd76d5740.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/582c97db3959ceb6dbb2b15e72206956.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c4ede885d9807b90b13b6d60a418f1b0.png)

**Floyd算法**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f4fd8bb33c04bbae6f4f08e873bf9f2f.png)

##### 3、拓扑排序

有向无环图：是一种特殊的有向图，该有向图中没有环形结构。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/79474b9d3fd53bdf6e286211170b5f12.png)

​
**拓扑排序**
：在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧

<
i
,
j
>
<i,j>





<





i

,



j



>
存在，则在这个序列中，

i
i





i
一定排在

j
j





j
的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a854e02e22dff39edf4a175dfa0268cc.png)

拓扑排序的作用是，判断图中是否存在环，如果图中存在环，那么存在一些顶点不在图的拓扑序列中。

##### 4、关键路径

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/efd06e0ed84af27468815dd6c1da6917.png)

关键路径的描述量：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2067575ba1b1b18a3f49a0911114ffcc.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f8f2862a6de07d62407cef5ccb75f6c2.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/43c012071201fc0fbe07828f1792f639.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/14f3859cb11305c6dd3fab3c33b46f37.png)

### 九、查找

#### （1） 查找表

​ 查找表是由同一类型的数据元素构成的集合，由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。查找是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录，若查找表中存在这样一个记录，则称为“查找成功”，此时给出整个记录的信息，或者指示该记录在查找表中的位置；否则称为“查找失败”，查找结果给出空指针。查找算法的评价指标：
**关键字平均比较次数**
，也称为
**平均比较长度**
（
**ASL**
，Average Search Length）
  




A
S
L
=
∑
i
=
1
n
p
i
c
i
ASL=\sum\_{i=1}^{n}{p\_ic\_i}





A

S

L



=














i

=

1





∑






n

​






p









i

​



c









i

​

  
其中，

n
n





n
是记录个数，

p
i
p\_i






p









i

​

查找的第

i
i





i
个记录的概率（通常认为

p
i
=
1
/
n
p\_i=1/n






p









i

​




=





1

/

n
），

c
i
c\_i






c









i

​

是找到的第

i
i





i
个记录所需的比较次数。查找表分为静态查找表和动态查找表。

#### （2）线性表的查找

##### 1、顺序查找（线性查找）

​ 应用范围：1、顺序表或线性表表示的静态查找表；2、表内元素之间无序。
**思想**
：从线性表的某一端开始，遍历线性表进行查找。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/16cf6f4af59ef22e2d0a468025c24df7.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/976549daaf53e63f348e57bd842ac8c1.png)

为了避免每次查找都进行两次比较，可以作如下改进：
**带哨兵的顺序查找**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1453d4297dbd035c432ef5e327a7e8d9.png)

当待查找的长度过长时，这样改进之后能使所需的平均时间减少一半。

顺序查找的复杂度分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/48869174242189c6938bc53480eeeddc.png)

顺序查找的
**特点**
：1、算法简单，逻辑次序无要求，且不同存储结构均适用；2、缺点是时间复杂度高。

##### 2、二分查找

​ 应用范围：表内之间元素有序，且顺序可知。
**思想**
是：每次将待查找的记录所在的区间缩小一半。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8822c9da465b5a004e256e1dcfcb2da1.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fdd5d2d4b60f12bd1da4b20fe9fc9c07.png)

非递归的写法：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c23e95c893c8187906ad16fe8ad0ddb3.png)

递归的写法：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/522aceabf8c29df8955e4d587009b05b.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3d25a135a9144f288ad30711d34a3d6a.png)

​ 二分查找的特点：优点，查找效率比顺序查找高；缺点，只适用于有序表，且限于顺序存储结构（对线性表链表无效）。

##### 3、分块查找

分块查找法的思想：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c8091e0bc7741c091d64fd541c632298.png)

分块查找法的时间效率：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/642c848abb8cf163ac13c0f2ba91be8e.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/be17fb005a1f72c2ba976849d1c298d6.png)

#### （3）树表的查找

​ 当表插入、删除等操作频繁时，为了维护表的有序性，需要移动很多记录，此时就可以采用动态查找表。表的结构在查找的过程中动态生成。

​
**二叉排序树**
（Binary Sort Tree），又称为二叉搜索树，二叉查找树。二叉排序树的定义：1、若其左子树非空，则左子树上所有结点的值均
**小于**
根结点的值；2、若其右子树非空，则右子树上的所有节点的值均
**大于等于**
根结点的值；3、其左右子树本身又各是一棵二叉排序树。

二叉排序树的
**性质**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5fd792485a91cd0fe09fd4a0a79a6f5e.png)

二叉排序树的
**存储**
：采用二叉链表来进行存储

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1b2265edec0eb1866abbaef9a736e2bd.png)

二叉排序树的
**查找**
：（递归算法）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/90a85c88862c6f486ddae088f49abb1e.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1f02a12aa21adc4c61aa90ebaadbe0ef.png)

二叉排序树查找
**性能分析**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/941d6af3b39911ea7d9243aebea973c2.png)

二叉排序树的
**插入**
：
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1ec04946ddbb27253e288bc40fd96a1a.png)

二叉排序树的
**生成**
：从空树出发，经过一系列的查找、插入操作之后，可以生成一棵二叉排序树。

​
**平衡二叉树**
（Balanced Binary Tree）又称为（AVL树），一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：1、左子树与右子树的高度只差的绝对值小于等于1；2、左子树和右子树也是平衡二叉排序树。
**平衡因子**
就是左子树的高度减去右子树高度的绝对值。

平衡二叉树的调整有四种，分别是LL、RR、LR、RL调整。

#### （4） 哈希表 的查找

​
**哈希表**
又称为
**散列表**
，其基本思想：记录的存储位置与关键字之间存在对应关系——hash函数，通过hash函数就可以对元素进行查找，查找效率高，但是空间效率低。

​
**关键术语**
：1、
**散列方法**
，选取某个函数，依照该函数按照关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比对，确定查找是否成功。2、
**散列函数**
（hash），散列方法中运用的转换函数。3、
**散列表**
，按照上述思想构造的表。 4、
**冲突**
，不同关键码映射到同一个散列地址上。

​ 散列函数的
**构造方法**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0d518b4bdf328bd64882a0623cd78d4f.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4f422e5b03a490601887fa213d27652b.png)

**直接定址法**
：

H
a
s
h
(
k
e
y
)
=
a
×
k
e
y
+
b
Hash(key)=a\times{key}+b





H

a

s

h

(

k

e

y

)



=





a



×






k

e

y



+





b
（

a
、
b
a、b





a

、

b
为常数），优点是以关键字

k
e
y
key





k

e

y
的某个线性函数为散列地址，不会产生冲突。缺点是要占用连续的地址空间，空间效率较低。

**除留余数法**
：

H
a
s
h
(
k
e
y
)
=
k
e
y
m
o
d
p
Hash(key)=key\qquad{mod}\qquad{p}





H

a

s

h

(

k

e

y

)



=





k

e

y




m

o

d




p
（

p
p





p
是一个整数），设表长为

m
m





m
，取

p
≤
m
p\le{m}





p



≤






m
且

p
p





p
为质数。

​
**解决散列表中的冲突**
问题的方法：1、开放定址法（开地址法）；2、链地址法（拉链法）；3、再散列法（双散列函数法）；4、建立一个公共溢出区。

**1、开放定址法**
：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e833a2ca8ffb3b9bcf07ba02f5029ed8.png)

**线性探测法**
的示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3ab8e319d3fcbe842f27a0b4e69e7375.png)

**二次探测法**
的示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ff7055bf2cdc482ddd1f98fcd073e76d.png)

**2、链地址法**
：将具有相同散列地址的记录链成一单链表，

m
m





m
个散列地址就设

m
m





m
个单链表，然后用一个数组将

m
m





m
个单链表的表头指针存储起来，形成一个动态结构。（散列表的链式存储结构）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e71afc7ec5bb01dd0a4025e8b97567dc.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/663d533d37c285f23421347a5844895d.png)

散列表的
**查找**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2ad73ca8fd8f64b34a6333b7944dc440.png)

散列表的
**查找效率**
分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ee1ca4c1687fc2618b706fc634167361.png)

---

### 十、排序

​ 排序是将一组杂乱无章的数据按照一定规律顺次排列起来，即将无序序列排成一个有序序列的运算。排序的分类：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9e7fd913c36107597ae3df8ad33051d2.png)

排序算法是否稳定，看排序的过程中记录的相对次序是否发生改变，若发生改变那么是不稳定的，反之，是稳定的。自然排序，如果排序算法在序列基本有序的情况下，排序速率越快，那么排序算法是自然的，反之，是非自然的。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2ca1d350d78348dd84a80c7350f085ad.png)

待排序的数据存储结构定义：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/92a866019fe41fe062572da6439fd31f.png)

#### （1）插入排序

​ 基本
**思想**
：每步将一个待排序的对象，按其关键码的大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b20a1b48db603a49f765d3e6dd09d281.png)

插入排序的分类：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ad5c79f4a0717e3918c3b5b72d252c5a.png)

##### 1、直接插入排序

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9b8db8fa0e719dbbff46a3f9d3905bd8.png)

使用带
**哨兵**
的直接插入排序：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4e670f32cdaa140bf4515c3303870208.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c40636b99794c99557728d79788633ce.png)

直接插入排序的
**时间复杂度**
分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/24003a5ef3bb4d3bc0ad4b727585814f.png)

##### 2、折半插入排序

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d3f44dbe338f90f759ccbbf4bf79173c.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/563a924c6b012b21df8e7eed4ac42021.png)

折半插入排序时间复杂度分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/277a36a56b9fc5cbefd3926b4d53dfbd.png)

##### 3、 希尔 排序

​
**基本思想**
：先将整个待排序的记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。希尔排序的特点是：1、缩小增量，2、多遍插入排序。示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b43a83fcff0db3d06979b7a04286903d.png)

​ 希尔排序的
**基本思路**
：1、定义增量序列

D
K
:
D
M
>
D
M
−
1
>
…
>
D
1
=
1
D\_K:D\_M>D\_{M-1}>\dots{>D\_1}=1






D









K

​




:






D









M

​




>






D










M

−

1

​




>





…




>




D









1

​




=





1
；2、对每个

D
K
D\_K






D









K

​

进行"

D
K
−
间
隔
D\_K-间隔






D









K

​




−





间

隔
"插入排序（

K
=
M
,
M
−
1
,
…
,
1
K=M,M-1,\dots{,1}





K



=





M

,



M



−





1

,



…




,



1
）

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e200eec916622c73fc0b203ced9f83c5.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a69aede93b692cc5a56ad61a7812b059.png)

希尔排序的时间复杂度分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/02e903d5524924ee71a65e904df405c2.png)

#### （2）交换排序

##### 1、冒泡排序

​ 基本
**思想**
：每趟不断将记录两两进行比较，并按照前小后大规则进行交换。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b981922220243f7dfb40d47ab2f5d6ec.png)

当某一趟比较时不出想记录的交换，说明已经排好序了，可以结束算法了。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/678ac1cbea81da22c95b81007ad92c39.png)

冒泡排序的时间复杂分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cba34430da63c6f67d1b9244beb838f1.png)

##### 2、 快速 排序

​ 基本思想：任取一个元素作为中心，所有比它小的元素一律放在前面，比它大的元素一律后放，形成左右两个子表。对各子表重新选择中心元素并依次规则进行调整，直到每个子表的元素只有一个。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c021bd0bb952f03e9ebcac3b7e6e0e42.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7a50a68c034c694e2492facf6febb9dc.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0ba5c68bea6107dce4c39b5a4210fce5.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6864d4f6c9ec00bd9dff98de862475e9.png)

快速排序的时间复杂度分析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/20af548b723d358864caac203ffaef89.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0418aa78262877c95a61b08c8bd3e889.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/21a2306c395bb23857959f282a05b4b9.png)

#### （3）选择排序

​ 基本
**思想**
：在待排序的数据中选出最大（小）的元素放在最终的位置。基本
**操作**
：1、首先通过

n
−
1
n-1





n



−





1
次关键字比较，从

n
n





n
个记录中找出关键字最小的记录，将他与第一个记录交换；2、再通过

n
−
2
n-2





n



−





2
次比较，从剩余的

n
−
1
n-1





n



−





1
个记录中找出关键字次小的记录，将它与第二个记录交换；3、重复上述操作，共进行

n
−
1
n-1





n



−





1
趟排序后，排序结束。

##### 1、直接选择排序

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7b00895ef9967c5ad98c0cfb415c270f.png)

##### 2、 堆 排序

​ 堆的
**定义**
：若

n
n





n
个元素的序列

{
a
1
,
a
2
,
…
,
a
n
}
\{a\_1,a\_2,\dots ,a\_n\}





{


a









1

​


,




a









2

​


,



…



,




a









n

​


}
满足
  

KaTeX parse error: Unknown column alignment: * at position 39: … \begin{array}{*̲*lr**} a\_i\le…
  
则分别称该序列

{
a
1
,
a
2
,
…
,
a
n
}
\{a\_1,a\_2,\dots ,a\_n\}





{


a









1

​


,




a









2

​


,



…



,




a









n

​


}
为
**小根堆**
和
**大根堆**
。从
**堆**
的定义可以看出，堆实质是满足如下性质的
**完全二叉树**
：二叉树中任一非叶子结点均
**小于**
（
**大于**
）它的孩子结点。

堆判别的示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3eb2a0361bb6e3c880cb3bf19f52e687.png)

​ 堆排序的
**思想**
：若在输出堆顶的最小值（最大值）后，使得

n
−
1
n-1





n



−





1
个元素的序列又建成一个堆，则得到

n
n





n
个元素的次小值（次大值）…如此反复，便能得到一个有序序列，这个过程称为
**堆排序**
。

​ 堆的
**向下调整**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b7766c07c02a50ebc619fcfbb215a21f.png)

堆的实现采用
**顺序表**
的结构，具体的关系如下，父亲结点和孩子结点之间的
**编号关系**
：
**当列表从0开始编号时**
，1、父亲结点和左孩子结点之间的编号关系

i
→
2
i
+
1
i\to{2i+1}





i



→






2

i



+



1
；2、父亲结点和右孩子之间的编号关系

i
→
2
i
+
2
i\to{2i+2}





i



→






2

i



+



2
；3、从孩子结点找父亲结点

i
→
⌊
(
i
−
1
)
/
2
⌋
i\to{\lfloor{(i-1)/2\rfloor}}





i



→






⌊


(

i



−



1

)

/

2

⌋
。
**当列表从1开始编号时**
，1、父亲结点和左孩子结点之间的编号关系

i
→
2
i
i\to{2i}





i



→






2

i
；2、父亲结点和右孩子之间的编号关系

i
→
2
i
+
1
i\to{2i+1}





i



→






2

i



+



1
；3、从孩子结点找父亲结点

i
→
⌊
i
/
2
⌋
i\to{\lfloor{i/2\rfloor}}





i



→






⌊


i

/

2

⌋
。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/511a29ac2e8917c9b77261211e0195de.png)

​ 堆的
**建立**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6ced4b5c850d9ce0f2d7a2296340002f.png)

堆建立的示例：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a3f9da773ae89c33a73fb9ad59f1ee53.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0aeb07a064c2fcb0c7e6d31132f50e85.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dfa6de7408f753545aa792e9b2296f4e.png)

**堆排序算法**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/86c0bbdb5cf4401f2700912589f3b4f7.png)

#### （4）归并排序

​ 基本
**思想**
：将两个或两个以上的有序子序列“归并”为一个有序子序列。在内部排序中，通常采用的是2-路归并排序。即：将两个位置相邻的有序子序列

R
[
l
…
m
]
R[l\dots{m}]





R

[

l



…




m

]
和

R
[
m
+
1
…
n
]
R[m+1\dots{n}]





R

[

m



+





1



…




n

]
归并为一个有序子序列

R
[
l
…
n
]
R[l\dots{n}]





R

[

l



…




n

]
。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/26d4f8b0e01355be9682271c531cfa67.png)

归并排序
**算法**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/82d6799d0806bf198a0bc0892f074da1.png)

#### （5）基数排序

​ 基本
**思想**
：分配+收集，也叫桶排序或箱排序，设置若干个箱子，将关键字为

k
k





k
的记录放入第

k
k





k
个箱子，让后再按序号将非空的箱子连接。基数排序：数字是有范围的，均由

0
∼
9
0\sim9





0



∼





9
这十个数字组成，则只需设置十个箱子，相继按个、十、百…进行搜索。

#### （6）排序算法小结

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/26a1c5e6d1dd6e552605145980e41f7f.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b5361734351e4bf3220e911d9f1a5ad5.png)

---

### 附录A- ASCII

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fe8994f94b9460c07123c2087977f67e.png)