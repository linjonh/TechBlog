---
layout: post
title: "Spring-MVC源码分析init流程"
date: 2025-03-09 21:37:13 +0800
description: "本篇介绍Spring MVC 的初始化流程，源码的体现是HttpServletBean的init方法。通常Spring MVC的项目，需要打成war包，部署在Tomcat服务器上，也就是Spring MVC通常需要配合Tomcat使用，当然也可以使用Jetty、Undertow 等。Spring MVC的源码，主要是分为两部分，第一部分是Tomcat启动时，Spring MVC上下文和容器的初始化。第二部分则是请求到达Tomcat，进行路径映射，转发到然后进行处理并且返回的流程。"
keywords: "Spring MVC源码分析のinit流程"
categories: ['源码分析']
tags: ['后端', 'Springboot', 'Spring', 'Mvc', 'Java']
artid: "146133918"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146133918
    alt: "Spring-MVC源码分析init流程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146133918
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146133918
cover: https://bing.ee123.net/img/rand?artid=146133918
image: https://bing.ee123.net/img/rand?artid=146133918
img: https://bing.ee123.net/img/rand?artid=146133918
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring MVC源码分析のinit流程
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <hr/>
    <h2>
     <a id="_5">
     </a>
     前言
    </h2>
    <p>
     本篇介绍Spring MVC 的初始化流程，源码的体现是
     <strong>
      HttpServletBean的init方法
     </strong>
     。通常Spring MVC的项目，需要打成war包，部署在Tomcat服务器上，也就是Spring MVC通常需要配合Tomcat使用，当然也可以使用Jetty、Undertow 等。
     <br/>
     Spring MVC的源码，主要是分为两部分，第一部分是Tomcat启动时，Spring MVC上下文和容器的初始化。第二部分则是请求到达Tomcat，进行路径映射，转发到
     <code>
      DispatcherServlet
     </code>
     然后进行处理并且返回的流程。
    </p>
    <h2>
     <a id="_init_11">
     </a>
     一、 init
    </h2>
    <p>
     在Tomcat容器启动时，会进入到
     <code>
      HttpServletBean
     </code>
     的
     <code>
      init方法
     </code>
     ，在其中进行初始化的操作：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d694e5b3c40f430a9f55948f8c943a0b.png">
      <code>
       initServletBean
      </code>
      最终会跳转到
      <code>
       FrameworkServlet
      </code>
      的
      <code>
       initWebApplicationContext
      </code>
      方法，而在该方法中，最关键的代码是
      <code>
       createWebApplicationContext
      </code>
      。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/09c8d875524943d2a22d73549232d4be.png">
       在执行完
       <code>
        initWebApplicationContext
       </code>
       方法刷新容器之后，会将容器对象赋值给
       <code>
        webApplicationContext
       </code>
       属性，并且执行
       <code>
        initFrameworkServlet
       </code>
       方法（是一个空实现）。
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/17a59bf075ec4b38919a0bfe807d9b14.png"/>
      </img>
     </img>
    </p>
    <h3>
     <a id="11createWebApplicationContext_19">
     </a>
     1.1、createWebApplicationContext
    </h3>
    <pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token class-name">WebApplicationContext</span> <span class="token function">createWebApplicationContext</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ApplicationContext</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//首先获取上下文，这里获取到的是XmlWebApplicationContext类型，即解析xml文件的模式</span>
	<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> contextClass <span class="token operator">=</span> <span class="token function">getContextClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">ConfigurableWebApplicationContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>contextClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationContextException</span><span class="token punctuation">(</span>
				<span class="token string">"Fatal initialization error in servlet with name '"</span> <span class="token operator">+</span> <span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
				<span class="token string">"': custom WebApplicationContext class ["</span> <span class="token operator">+</span> contextClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
				<span class="token string">"] is not of type ConfigurableWebApplicationContext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//尝试通过类型去实例化	XmlWebApplicationContext 容器 </span>
	<span class="token comment">//实例化完成后的XmlWebApplicationContext是空的，属性都是默认值</span>
	<span class="token class-name">ConfigurableWebApplicationContext</span> wac <span class="token operator">=</span>
			<span class="token punctuation">(</span><span class="token class-name">ConfigurableWebApplicationContext</span><span class="token punctuation">)</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">instantiateClass</span><span class="token punctuation">(</span>contextClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//设置环境</span>
	wac<span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//设置父容器</span>
	wac<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//拿到WEB-INF下的spring.xml配置文件</span>
	<span class="token class-name">String</span> configLocation <span class="token operator">=</span> <span class="token function">getContextConfigLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>configLocation <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		wac<span class="token punctuation">.</span><span class="token function">setConfigLocation</span><span class="token punctuation">(</span>configLocation<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//完成后续容器初始化与刷新操作（配置、监听器、refresh 等）</span>
	<span class="token function">configureAndRefreshWebApplicationContext</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> wac<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      configureAndRefreshWebApplicationContext
     </code>
     方法：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configureAndRefreshWebApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableWebApplicationContext</span> wac<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 如果当前容器的 id 还只是默认值（即内存地址），我们给它设置一个更有意义的 id</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ObjectUtils</span><span class="token punctuation">.</span><span class="token function">identityToString</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>wac<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果用户自定义设置了 contextId，则使用用户提供的</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>contextId <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			wac<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>contextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 否则自动生成一个 id：一般是 application:/contextPath/servletName</span>
			wac<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableWebApplicationContext</span><span class="token punctuation">.</span><span class="token constant">APPLICATION_CONTEXT_ID_PREFIX</span> <span class="token operator">+</span>
					<span class="token class-name">ObjectUtils</span><span class="token punctuation">.</span><span class="token function">getDisplayString</span><span class="token punctuation">(</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token char">'/'</span> <span class="token operator">+</span> <span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 设置容器的 ServletContext，后续会用于获取资源、属性等</span>
	wac<span class="token punctuation">.</span><span class="token function">setServletContext</span><span class="token punctuation">(</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 设置 ServletConfig（包含 servlet 的 init 参数等信息）</span>
	wac<span class="token punctuation">.</span><span class="token function">setServletConfig</span><span class="token punctuation">(</span><span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 设置命名空间，一般用于区分不同的 DispatcherServlet 容器</span>
	wac<span class="token punctuation">.</span><span class="token function">setNamespace</span><span class="token punctuation">(</span><span class="token function">getNamespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 添加一个监听器，用于监听容器的 refresh 事件（刷新完成时触发）</span>
	wac<span class="token punctuation">.</span><span class="token function">addApplicationListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SourceFilteringListener</span><span class="token punctuation">(</span>wac<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ContextRefreshListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 获取当前环境对象，用于管理属性配置（如 application.properties）</span>
	<span class="token class-name">ConfigurableEnvironment</span> env <span class="token operator">=</span> wac<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>env <span class="token keyword">instanceof</span> <span class="token class-name">ConfigurableWebEnvironment</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 初始化 servletContext 和 servletConfig 中的属性源（property sources）</span>
		<span class="token comment">// 这样可以在后续的 Bean 初始化过程中使用 ${...} 占位符引用这些属性</span>
		<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableWebEnvironment</span><span class="token punctuation">)</span> env<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">initPropertySources</span><span class="token punctuation">(</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 钩子方法：可以在子类中覆写，对容器进一步自定义处理（例如注册额外 Bean 定义）</span>
	<span class="token function">postProcessWebApplicationContext</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 应用 SpringApplicationContextInitializer（初始化器扩展点）</span>
	<span class="token function">applyInitializers</span><span class="token punctuation">(</span>wac<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 最终刷新容器，触发 Bean 的加载、依赖注入、事件发布等流程</span>
	wac<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     最终调用的是
     <code>
      AbstractApplicationContext
     </code>
     的
     <code>
      refresh
     </code>
     方法，在
     <code>
      refresh
     </code>
     完成后，
     <code>
      XmlWebApplicationContext
     </code>
     的属性才有值：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8baaaf85cc9a449496da83760a1e8dd5.png"/>
    </p>
    <h3>
     <a id="12onRefresh_99">
     </a>
     1.2、onRefresh
    </h3>
    <p>
     在
     <code>
      configureAndRefreshWebApplicationContext
     </code>
     方法中，还有一行关键的代码：
    </p>
    <pre><code class="prism language-java">wac<span class="token punctuation">.</span><span class="token function">addApplicationListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SourceFilteringListener</span><span class="token punctuation">(</span>wac<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ContextRefreshListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     这行代码是添加了一个监听器，
     <strong>
      触发时机是Spring容器refresh完成后。
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d37215fa0b9042b0a5f41c6556305230.png">
      最终会跳转到
      <code>
       DispatcherServlet
      </code>
      的
      <code>
       initStrategies
      </code>
      方法。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/22decb7ce187440fa6d2061bbabaeb01.png">
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6d9c7d22215247689b308b7b3270bcfd.png">
        在该方法中，会进行一些初始化操作，其中最重要的是
        <code>
         initHandlerMappings
        </code>
        和
        <code>
         initHandlerAdapters
        </code>
        。在说明这两个方法的逻辑之前，有必要先说明下什么是Handler。
       </img>
      </img>
     </img>
    </p>
    <h2>
     <a id="_109">
     </a>
     二、请求处理器
    </h2>
    <p>
     Handler是Spring MVC中的请求处理器，有四种实现：
    </p>
    <h3>
     <a id="21RequestMapping_112">
     </a>
     2.1、@RequestMapping
    </h3>
    <p>
     <code>
      RequestMapping
     </code>
     是最常见的请求处理器实现，可以加在方法也可以加在类上，如果加在类上，需要配合
     <code>
      @Component
     </code>
     注解:
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">TestService</span> testService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token string">"/test"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <h3>
     <a id="22Controller_130">
     </a>
     2.2、Controller接口
    </h3>
    <p>
     后三种方式在项目开发中较为少见，第一种是自定义类，实现Controller接口，同时需要将自定义的类标记成bean，然后加上请求的路径（需要加/）
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"/test1"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
     * @param request  current HTTP request 
     * @param response current HTTP response
     * @return
     * @throws Exception
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyHandler implements Controller"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <h3>
     <a id="23HttpRequestHandler_150">
     </a>
     2.3、HttpRequestHandler接口
    </h3>
    <p>
     自定义一个类，实现HttpRequestHandler接口，和实现Controller接口的区别在于返回值为空。
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"/test2"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyHandler1</span> <span class="token keyword">implements</span> <span class="token class-name">HttpRequestHandler</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
     * @param request  current HTTP request 
     * @param response current HTTP response
     * @throws ServletException
     * @throws IOException
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyHandler1 implements HttpRequestHandler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="24HandlerFunction_170">
     </a>
     2.4、HandlerFunction
    </h3>
    <p>
     也可以在配置类中注册一个自定义的bean，返回值类型为
     <code>
      RouterFunction&lt;ServerResponse&gt;
     </code>
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.zhouyu"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{<!-- --></span>
		
		<span class="token annotation punctuation">@Bean</span>
		<span class="token keyword">public</span> <span class="token class-name">RouterFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServerResponse</span><span class="token punctuation">&gt;</span></span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token function">route</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/app/person"</span><span class="token punctuation">,</span> request <span class="token operator">-&gt;</span><span class="token class-name">ServerResponse</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">OK</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token string">"Hello GET"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
									<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/app/person"</span><span class="token punctuation">,</span> request <span class="token operator">-&gt;</span><span class="token class-name">ServerResponse</span><span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">OK</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token string">"Hello POST"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		 <span class="token punctuation">}</span>
		 
<span class="token punctuation">}</span>
</code></pre>
    <p>
     上述这四种Handler，分别对应Spring MVC源码中
     <code>
      DispatcherServlet.properties
     </code>
     ：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ff9cd3701ff84deba8cb99b15753ba33.png"/>
    </p>
    <ul>
     <li>
      @RequestMapping对应
      <code>
       BeanNameUrlHandlerMapping
      </code>
      。
     </li>
     <li>
      Controller接口和HttpRequestHandler接口对应
      <code>
       RequestMappingHandlerMapping
      </code>
      。
     </li>
     <li>
      HandlerFunction对应
      <code>
       RouterFunctionMapping
      </code>
      。
     </li>
    </ul>
    <h2>
     <a id="initHandlerMappings_196">
     </a>
     三、initHandlerMappings
    </h2>
    <p>
     <code>
      HandlerMapping
     </code>
     的作用，就是去记录
     <code>
      请求路径
     </code>
     和
     <code>
      上述Handler
     </code>
     的对应关系。可以理解底层有一个map，key是请求的路径，value是与之匹配的Handler对象，
     <strong>
      在容器启动时就将其维护好，避免在请求到达时再去寻找对应的Handler。
     </strong>
     <br/>
     在
     <code>
      initHandlerMappings
     </code>
     中，首先会去寻找有没有用户自定义的
     <code>
      HandlerMapping
     </code>
     类型的bean，如果有，就会直接给
     <code>
      DispatcherServlet
     </code>
     的
     <code>
      handlerMappings
     </code>
     属性赋值为自定义的那个处理器，不会再去用
     <code>
      DispatcherServlet.properties
     </code>
     中默认的那三个了。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c64591af651d4d629de4f0420d89a665.png"/>
     如果没有自定义的，才会去调用
     <code>
      getDefaultStrategies
     </code>
     找
     <code>
      DispatcherServlet.properties
     </code>
     中的：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/98a5b80f4b0142d29d74411956415df7.png"/>
    </p>
    <h3>
     <a id="31getDefaultStrategies_202">
     </a>
     3.1、getDefaultStrategies
    </h3>
    <p>
     在
     <code>
      getDefaultStrategies
     </code>
     中，首先会拿到
     <code>
      DispatcherServlet.properties
     </code>
     默认的三个处理器：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/15b7968f8079428f9b613cc66ac4a3a8.png"/>
     然后会按照顺序循环处理：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/390ef7280637457da7ab012b39690f72.png"/>
     这里要区分不同的情况。
    </p>
    <h4>
     <a id="311RequestMappingHandlerMapping_208">
     </a>
     3.1.1、RequestMappingHandlerMapping
    </h4>
    <p>
     <code>
      RequestMappingHandlerMapping
     </code>
     是针对
     <code>
      @RequestMapping
     </code>
     注解的情况，处理逻辑的代码在
     <code>
      afterPropertiesSet
     </code>
     中：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/aee95e81d19f4e67ae8c7e174bb47ac1.png"/>
     因为它间接实现了
     <code>
      InitializingBean
     </code>
     接口，所以处理时机是在bean生命周期中的
     <code>
      初始化阶段
     </code>
     。我们来看一下
     <code>
      RequestMappingHandlerMapping
     </code>
     重写的
     <code>
      afterPropertiesSet
     </code>
     的逻辑，最终调用的是父类
     <code>
      AbstractHandlerMethodMapping
     </code>
     的
     <code>
      afterPropertiesSet
     </code>
     方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b3c03fb7b99c44808412192379799411.png"/>
     首先会拿到Spring容器中所有bean的名称，然后过滤掉"scopedTarget." 开头的 Bean，最后用当前的候选bean调用
     <code>
      processCandidateBean
     </code>
     方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1ca9a2b97b464257ac11e5a596ea8748.png"/>
     在
     <code>
      processCandidateBean
     </code>
     方法中，会在
     <code>
      isHandler
     </code>
     中进行判断，当前的bean是否有
     <code>
      @Controller注解
     </code>
     或
     <code>
      @RequestMapping注解
     </code>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/933f26ba955b46218b4380d268bfd56a.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d83a6019b8794d13ab9efb77718a3519.png"/>
     <em>
      如果仅仅在类上加@RequestMapping注解也是不可以的，因为没有@Component，该类就不会被扫描并且注册成bean，也不会进入这一步的逻辑
     </em>
    </p>
    <p>
     对于符合要求的bean，则会进入
     <code>
      detectHandlerMethods
     </code>
     方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/732163d293584e47af06975ce3096b4a.png"/>
     其中的核心方法是
     <code>
      getMappingForMethod
     </code>
     :
    </p>
    <pre><code class="prism language-java"><span class="token comment">/**
 * 为指定的方法构建对应的 RequestMappingInfo（映射信息）。
 * 该方法会综合考虑方法级注解、类级注解，以及类路径前缀等信息。
 *
 * @param method       要处理的方法（如某个 @RequestMapping 方法）
 * @param handlerType  方法所属的处理器类
 * @return 方法对应的 RequestMappingInfo（包含路径、请求方式、参数条件等），如果该方法无映射，则返回 null
 */</span>
<span class="token annotation punctuation">@Override</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">protected</span> <span class="token class-name">RequestMappingInfo</span> <span class="token function">getMappingForMethod</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> handlerType<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 第一步：从方法上提取 @RequestMapping 注解信息（方法级映射）</span>
    <span class="token class-name">RequestMappingInfo</span> info <span class="token operator">=</span> <span class="token function">createRequestMappingInfo</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>info <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 第二步：从类上提取 @RequestMapping 注解信息（类级映射）</span>
        <span class="token class-name">RequestMappingInfo</span> typeInfo <span class="token operator">=</span> <span class="token function">createRequestMappingInfo</span><span class="token punctuation">(</span>handlerType<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果类级映射不为空，则与方法级映射合并，形成完整映射</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>typeInfo <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            info <span class="token operator">=</span> typeInfo<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 第三步：获取路径前缀（比如配置了统一前缀 "/api"），追加到映射路径中</span>
        <span class="token class-name">String</span> prefix <span class="token operator">=</span> <span class="token function">getPathPrefix</span><span class="token punctuation">(</span>handlerType<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 构造前缀映射信息，再与原映射 info 合并</span>
            info <span class="token operator">=</span> <span class="token class-name">RequestMappingInfo</span><span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">options</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">)</span>  <span class="token comment">// 使用当前的 config（包含匹配规则等）</span>
                    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 返回最终合并后的 RequestMappingInfo</span>
    <span class="token keyword">return</span> info<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
    <p>
     在该方法中会解析
     <code>
      @RequestMapping
     </code>
     注解信息:
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/45410a28439645bb921d0318c35d3b3d.png"/>
     最终返回到
     <code>
      detectHandlerMethods
     </code>
     方法的是一个
     <code>
      Map&lt;Method, T&gt; methods
     </code>
     ，
     <strong>
      key是当前的方法对象，value是注解的信息
     </strong>
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ee550d149fbb4d82bfa45a02884bfd75.png"/>
     然后会遍历这个map：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fe3f33dd9de5423f8454049d5f9155a3.png"/>
     从上图中的
     <code>
      registerHandlerMethod
     </code>
     进入
     <code>
      MappingRegistry
     </code>
     的
     <code>
      register
     </code>
     方法，在该方法中有两个重要的map:
    </p>
    <ul>
     <li>
      pathLookup：key存放了请求路径，value存放了注解的信息。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9783b593852f413f9980fea884b86b43.png"/>
    </p>
    <ul>
     <li>
      registry：key存放了注解的对象，value存放了方法的信息。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/02182c16977f4175b6b13daaffaacdda.png"/>
      <br/>
      <strong>
       到这一步为止就完成了路径与方法的映射关系
      </strong>
     </li>
    </ul>
    <h4>
     <a id="312BeanNameUrlHandlerMapping_271">
     </a>
     3.1.2、BeanNameUrlHandlerMapping
    </h4>
    <p>
     <code>
      BeanNameUrlHandlerMapping
     </code>
     处理的逻辑在
     <code>
      setApplicationContext
     </code>
     方法中。
     <br/>
     因为
     <code>
      BeanNameUrlHandlerMapping
     </code>
     间接实现了
     <code>
      ApplicationContextAware
     </code>
     接口，所以处理时机是在bean生命周期中的
     <code>
      初始化
     </code>
     前。
     <br/>
     会调用
     <code>
      initApplicationContext
     </code>
     方法：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/116d102e786e43e08b7373f185028318.png"/>
     其核心方法是
     <code>
      AbstractDetectingUrlHandlerMapping
     </code>
     的
     <code>
      detectHandlers
     </code>
     ，同样会先获取容器中所有的bean：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0b1ed7c953eb487684ba3886bae38dd0.png"/>
     然后遍历这些bean的名称，找到以"/“开头的（之前说明过，自定义bean实现HttpRequestHandler接口或Controller接口，需要指定bean的名称，并且在最前面加上”/"代表路径）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0959c5364e3740799071af57ab3c4e20.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f1bb3408fb124da2a62555f4eb2b61e2.png"/>
     <em>
      在这一步注册映射关系
     </em>
    </p>
    <p>
     调用到
     <code>
      registerHandler
     </code>
     方法，首先根据bean的名称获取到bean：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2a2f7bf73e3543dd9907814bf2a90e21.png"/>
    </p>
    <ul>
     <li>
      handlerMap：key存放访问路径，value存放类对象。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8be6b4a0ddd14180ad11c35b29f5d5b0.png"/>
     最终handlerMap存放了映射关系：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/469ad63b94194ffb8be285eb8f99b21f.png"/>
    </p>
    <h2>
     <a id="initHandlerAdapters_287">
     </a>
     四、initHandlerAdapters
    </h2>
    <p>
     <code>
      initHandlerAdapters
     </code>
     是用于初始化
     <code>
      DispatcherServlet
     </code>
     的
     <code>
      handlerAdapters
     </code>
     属性的方法。initHandlerAdapters() 的作用就是准备好一组 能够适配各种Controller类型的执行器，让DispatcherServlet能够在处理请求时找到并调用合适的控制器逻辑。
     <br/>
     <img alt="  " src="https://i-blog.csdnimg.cn/direct/8811ae4d58b546acab0fc206ef4950db.png"/>
     <em>
      和initHandlerMappings一样，首先会去找是否有自定义的HandlerAdapter，如果有，就用自定义的，并且不会用默认的了
     </em>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5a753ada62cc49cb93489af1cd7580e2.png"/>
     <em>
      getDefaultStrategies 同样是去DispatcherServlet.properties中找默认的策略
     </em>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/84503b224397400abe3c2808ff5d8016.png"/>
     <em>
      四种策略，分别对应&lt;二&gt;中的四种方式
     </em>
    </p>
    <p>
     和
     <code>
      initHandlerMappings
     </code>
     一样，最终同样会去遍历
     <code>
      DispatcherServlet.properties
     </code>
     中的策略，然后走创建各自bean的流程。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8e37b308bfea48b9b4764138aea93433.png"/>
     最终得到四个实例，因为在案例中四种请求方式都有。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/01761ee691a4462c80833517e8ce52fd.png"/>
     这里也是
     <strong>
      适配器模式
     </strong>
     的体现，四种
     <code>
      HandlerAdapter
     </code>
     都实现了
     <code>
      HandlerAdapter
     </code>
     适配器接口，真正如何适配的，会在
     <code>
      doDispatch
     </code>
     （处理请求）的源码中有所体现。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f12f96de549448ee85691d35b0af90e7.png"/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b10169b51b1c478699d546c6d71594ee.png"/>
    </p>
    <h2>
     <a id="_303">
     </a>
     总结
    </h2>
    <p>
     Spring MVC在解析web.xml，调用
     <code>
      DispatcherServlet
     </code>
     的
     <code>
      init
     </code>
     方法时，完成的主要工作可以分为两部分：
    </p>
    <ul>
     <li>
      添加一个监听器，用于监听容器的 refresh 事件（刷新完成时触发）。
     </li>
     <li>
      创建Spring容器，调用refresh方法。
     </li>
    </ul>
    <p>
     其中Spring容器refresh 完成后，最终会被监听到，并且调用
     <code>
      DispatcherServlet
     </code>
     的
     <code>
      initStrategies
     </code>
     方法，在该方法中会完成HandlerMappings和HandlerAdapters的初始化。HandlerMappings用于保存路径和方法的映射关系，而HandlerAdapters让DispatcherServlet能够在处理请求时找到并调用合适的控制器逻辑。
     <br/>
     HandlerMappings和HandlerAdapters的初始化，本质都是实例化
     <code>
      DispatcherServlet.properties
     </code>
     配置文件中定义的bean名称。在各自的生命周期中进行方法回调。
     <code>
      BeanNameUrlHandlerMapping
     </code>
     处理的逻辑在
     <code>
      setApplicationContext
     </code>
     方法中，
     <code>
      RequestMappingHandlerMapping
     </code>
     处理逻辑的代码在
     <code>
      afterPropertiesSet
     </code>
     中。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373539393037362f:61727469636c652f64657461696c732f313436313333393138" class_="artid" style="display:none">
 </p>
</div>


