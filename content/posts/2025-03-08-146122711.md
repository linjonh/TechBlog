---
layout: post
title: "RISC-V汇编学习三-RV指令集"
date: 2025-03-08 23:05:22 +0800
description: "RISC-V是一种开源的指令集架构（ISA），它遵循精简指令集计算（RISC）的原则，旨在为各种计算设备提供高效、灵活的基础。与传统的专有ISA不同，RISC-V的设计强调简洁性、模块化和可扩展性，使其成为从嵌入式系统到超级计算机广泛应用的理想选择。博客列举RISC-V指令集，包括基础整数指令集RV32I/RV64I以及一系列标准扩展，如乘法和除法（M）、原子操作（A）、浮点运算（F/D）等"
keywords: "RISC-V汇编学习（三）—— RV指令集"
categories: ['V']
tags: ['汇编', '指令集', 'V']
artid: "146122711"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146122711
    alt: "RISC-V汇编学习三-RV指令集"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146122711
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146122711
cover: https://bing.ee123.net/img/rand?artid=146122711
image: https://bing.ee123.net/img/rand?artid=146122711
img: https://bing.ee123.net/img/rand?artid=146122711
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RISC-V汇编学习（三）—— RV指令集
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-github-gist" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     有了前两节对于RISC-V汇编、寄存器、汇编语法等的认识，本节开始介绍RISC-V指令集和伪指令。
    </p>
    <p>
     前面说了RISC-V的模块化特点，是以RV32I为作为ISA的核心模块，其他都是要基于此为基础，可以这样认为：
     <code>
      RISC-V ISA = 基本整数指令集+多个可选扩展指令集
     </code>
     ；另外RISC-V的ISA spec上是从指令类型和指令格式开始介绍指令的；但从一个嵌入式软件开发人员的角度来说，不是特别适合学习和记忆，所以我这里简单罗列下，不多讲解，感兴趣可以参考spec。
    </p>
    <h2>
     <a id="1__3">
     </a>
     1 指令类型
    </h2>
    <h3>
     <a id="11__5">
     </a>
     1.1 组成格式
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c67a3cb46e2040e79f6c0763349de738.png">
      <br/>
      所有RISC-V指令都是固定长度的32位，这有助于简化指令解码过程。每个指令都由以下几个关键部分组成：
     </img>
    </p>
    <ul>
     <li>
      opcode：这是7位的操作码，用来标识指令的基本类型。
     </li>
     <li>
      funct3：这是一个3位的功能码，与opcode一起使用以进一步细化指令的类别。
     </li>
     <li>
      funct7：某些指令使用额外的7位功能码来更精确地定义指令的行为。
     </li>
     <li>
      rs1/rs2/rd：这些是5位的寄存器地址，分别代表源寄存器1、源寄存器2和目的寄存器。
     </li>
     <li>
      imm：立即数字段，其大小和位置根据指令类型的不同而变化。
     </li>
    </ul>
    <h3>
     <a id="12__13">
     </a>
     1.2 类型
    </h3>
    <p>
     RISC-V定义了几种基本的指令格式，每一种都针对特定类型的运算或操作。这些格式包括：R型、I型、S型、B型、U型、J型。
    </p>
    <ul>
     <li>
      <p>
       R型（Register）
       <br/>
       用于寄存器间的算术/逻辑运算（如ADD x1, x2, x3）
       <br/>
       字段：opcode确定操作类型，funct3和funct7进一步指定具体操作（如区分ADD与SUB）
      </p>
     </li>
     <li>
      <p>
       I型（Immediate）
       <br/>
       用于立即数操作（如ADDI x1, x2, 42）或加载指令（如LW x1, 100(x2)）
       <br/>
       立即数：12位符号扩展，直接嵌入指令中
      </p>
     </li>
     <li>
      <p>
       S型（Store）
       <br/>
       存储数据到内存（如SW x3, 200(x4)）
       <br/>
       立即数：12位拆分为imm[11:5]和imm[4:0]，组合后作为偏移地址。
      </p>
     </li>
     <li>
      <p>
       B型（Branch）
       <br/>
       条件分支（如BEQ x1, x2, label）
       <br/>
       立即数：13位（符号扩展后左移1位），拆分为imm[12|10:5|4:1|11]，支持更大跳转范围
      </p>
     </li>
     <li>
      <p>
       U型（Upper Immediate）
       <br/>
       加载高20位立即数（如LUI x1, 0x12345）或构造地址（如AUIPC）
       <br/>
       立即数：20位直接嵌入高位，低12位由后续指令补充
      </p>
     </li>
     <li>
      <p>
       J型（Jump）
       <br/>
       长距离无条件跳转（如JAL x1, label）
       <br/>
       立即数：20位符号扩展后左移1位，支持±1MB跳转范围
      </p>
     </li>
    </ul>
    <p>
     但在实际应用中，我们也很难记住这么汇编指令机器码，一般情况下也不会有错，具体可以参考spec。
    </p>
    <h2>
     <a id="2__39">
     </a>
     2 指令命名
    </h2>
    <p>
     下图是
     <strong>
      RV32I基础指令集
     </strong>
     的⼀⻚图形表示，将有下划线的字⺟从左到右连接起来，即可组成完整的RV32I指令集。集合标志{}内列举了指令的所有变体，变体⽤加下划线的字⺟或下划线字符_表示，特别的，下划线字符_表示对于此指令变体不需⽤字符表示
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/dae9394a4a1244c2bc92535338c7a00b.png"/>
    </p>
    <p>
     以slt指令为例，如下示意图：大括号{ }内列举了每组指令的所有变体，这些变体通过带下滑线的字母（单独的下划线_表示空字段），从左到右连接带下滑线的字母即可组成完整的指令集，比如slt意思是set less than，相当于是一种缩写，完整语句方便我们快速清晰的理解指令的作用。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/890b0f0483be4b76999c8ccd7f85e83d.png">
      <br/>
      上图可以表示：slt、slti、sltu、sltiu 这4条RVI指令。
     </img>
    </p>
    <p>
     下面将列举以下RISC-V指令集：
    </p>
    <ul>
     <li>
      RVI(包括RV32I与RV64I)
     </li>
     <li>
      RVM(包括RV32M与RV64M)
     </li>
     <li>
      RVFD(包括RV32FD与RV64FD)
     </li>
     <li>
      RVA(包括RV32A与RV64A)
     </li>
    </ul>
    <h2>
     <a id="3_RVI_53">
     </a>
     3 RVI指令集
    </h2>
    <p>
     RVI是 RISC-V 指令集架构的基础部分，它定义了32位整数运算的核心指令集。RVI 包括 RV32I（32位整数指令集）和 RV64I（64位整数指令集），它们为处理器提供了执行基本计算任务的能力；包括：内存操作指令、逻辑指令、分支和跳转指令、算术指令等等，下面就一一列举。
    </p>
    <h3>
     <a id="31__56">
     </a>
     3.1 内存操作指令
    </h3>
    <p>
     在RISC-V中，内存操作主要通过加载（Load）和存储（Store）两类指令来实现。这些指令允许程序从内存读取数据到寄存器（Load），或将寄存器中的数据写入内存（Store）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ba029268d8834efc8fc89221bb8a246b.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        LB
       </td>
       <td>
        <code>
         lb rd, offset(rs1)
        </code>
       </td>
       <td>
        加载字节（符号扩展）
       </td>
       <td>
        <code>
         rd = SignExt(Mem[rs1 + offset][7:0])
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        LBU
       </td>
       <td>
        <code>
         lbu rd, offset(rs1)
        </code>
       </td>
       <td>
        加载字节（无符号扩展）
       </td>
       <td>
        <code>
         rd = ZeroExt(Mem[rs1 + offset][7:0])
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        LH
       </td>
       <td>
        <code>
         lh rd, offset(rs1)
        </code>
       </td>
       <td>
        加载半字（符号扩展）
       </td>
       <td>
        <code>
         rd = SignExt(Mem[rs1 + offset][15:0])
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        LHU
       </td>
       <td>
        <code>
         lhu rd, offset(rs1)
        </code>
       </td>
       <td>
        加载半字（无符号扩展）
       </td>
       <td>
        <code>
         rd = ZeroExt(Mem[rs1 + offset][15:0])
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        LW
       </td>
       <td>
        <code>
         lw rd, offset(rs1)
        </code>
       </td>
       <td>
        加载字（RV32I：32位；RV64I：符号扩展至64位）
       </td>
       <td>
        RV32I:
        <code>
         rd = Mem[rs1 + offset][31:0]
        </code>
        <br/>
        RV64I:
        <code>
         rd = SignExt(Mem[rs1 + offset][31:0])
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        LWU
       </td>
       <td>
        <code>
         lwu rd, offset(rs1)
        </code>
       </td>
       <td>
        加载字（无符号扩展至64位）
       </td>
       <td>
        <code>
         rd = ZeroExt(Mem[rs1 + offset][31:0])
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        LD
       </td>
       <td>
        <code>
         ld rd, offset(rs1)
        </code>
       </td>
       <td>
        加载双字（64位）
       </td>
       <td>
        <code>
         rd = Mem[rs1 + offset][63:0]
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        SB
       </td>
       <td>
        <code>
         sb rs2, offset(rs1)
        </code>
       </td>
       <td>
        存储字节
       </td>
       <td>
        <code>
         Mem[rs1 + offset] = rs2[7:0]
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SH
       </td>
       <td>
        <code>
         sh rs2, offset(rs1)
        </code>
       </td>
       <td>
        存储半字
       </td>
       <td>
        <code>
         Mem[rs1 + offset] = rs2[15:0]
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SW
       </td>
       <td>
        <code>
         sw rs2, offset(rs1)
        </code>
       </td>
       <td>
        存储字
       </td>
       <td>
        <code>
         Mem[rs1 + offset] = rs2[31:0]
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SD
       </td>
       <td>
        <code>
         sd rs2, offset(rs1)
        </code>
       </td>
       <td>
        存储双字
       </td>
       <td>
        <code>
         Mem[rs1 + offset] = rs2[63:0]
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="32__74">
     </a>
     3.2 算术指令
    </h3>
    <p>
     算术指令狭义定义：仅包含加法、减法及其直接相关的操作，用于寄存器或寄存器与立即数之间的数值运算。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/819451c2b1f14786812a9189d8e1f712.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         基础加减指令
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        ADD
       </td>
       <td>
        <code>
         add rd, rs1, rs2
        </code>
       </td>
       <td>
        加法（忽略溢出）
       </td>
       <td>
        <code>
         rd = rs1 + rs2
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SUB
       </td>
       <td>
        <code>
         sub rd, rs1, rs2
        </code>
       </td>
       <td>
        减法（忽略溢出）
       </td>
       <td>
        <code>
         rd = rs1 - rs2
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        ADDI
       </td>
       <td>
        <code>
         addi rd, rs1, imm
        </code>
       </td>
       <td>
        立即数加法（符号扩展立即数）
       </td>
       <td>
        <code>
         rd = rs1 + SignExt(imm)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         RV64I 扩展加减指令
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        ADDIW
       </td>
       <td>
        <code>
         addiw rd, rs1, imm
        </code>
       </td>
       <td>
        立即数加法（32位，符号扩展至64位）
       </td>
       <td>
        <code>
         rd = SignExt((rs1 + SignExt(imm))[31:0])
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        ADDW
       </td>
       <td>
        <code>
         addw rd, rs1, rs2
        </code>
       </td>
       <td>
        加法（32位，符号扩展至64位）
       </td>
       <td>
        <code>
         rd = SignExt((rs1 + rs2)[31:0])
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        SUBW
       </td>
       <td>
        <code>
         subw rd, rs1, rs2
        </code>
       </td>
       <td>
        减法（32位，符号扩展至64位）
       </td>
       <td>
        <code>
         rd = SignExt((rs1 - rs2)[31:0])
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         高位立即数构建指令
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        LUI
       </td>
       <td>
        <code>
         lui rd, imm
        </code>
       </td>
       <td>
        加载高位立即数（imm[31:12]）
       </td>
       <td>
        <code>
         rd = imm &lt;&lt; 12
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        AUIPC
       </td>
       <td>
        <code>
         auipc rd, imm
        </code>
       </td>
       <td>
        将高位立即数与 PC 相加
       </td>
       <td>
        <code>
         rd = PC + (imm &lt;&lt; 12)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      伪指令表格
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         寄存器操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        MV
       </td>
       <td>
        <code>
         mv rd, rs
        </code>
       </td>
       <td>
        寄存器间移动值
       </td>
       <td>
        <code>
         addi rd, rs, 0
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        NEG
       </td>
       <td>
        <code>
         neg rd, rs
        </code>
       </td>
       <td>
        取负值（rd = -rs）
       </td>
       <td>
        <code>
         sub rd, x0, rs
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        NEGW
       </td>
       <td>
        <code>
         negw rd, rs
        </code>
       </td>
       <td>
        取负值（32位操作，符号扩展）
       </td>
       <td>
        <code>
         subw rd, x0, rs
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         立即数操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        LI
       </td>
       <td>
        <code>
         li rd, imm
        </code>
       </td>
       <td>
        加载任意立即数到寄存器
       </td>
       <td>
        若 imm 在 12 位有符号范围内：
        <code>
         addi rd, x0, imm
        </code>
        <br/>
        否则：
        <code>
         lui rd, imm[31:12]
        </code>
        +
        <code>
         addi rd, rd, imm[11:0]
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         地址加载
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        LA
       </td>
       <td>
        <code>
         la rd, symbol
        </code>
       </td>
       <td>
        加载绝对地址（链接时解析）
       </td>
       <td>
        <code>
         auipc rd, offset_hi
        </code>
        +
        <code>
         addi rd, rd, offset_lo
        </code>
        <br/>
        或
        <code>
         lui rd, offset_hi
        </code>
        +
        <code>
         addi rd, rd, offset_lo
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        LLA
       </td>
       <td>
        <code>
         lla rd, symbol
        </code>
       </td>
       <td>
        加载本地地址（PC相对，位置无关）
       </td>
       <td>
        <code>
         auipc rd, offset_hi
        </code>
        +
        <code>
         addi rd, rd, offset_lo
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         符号扩展
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SEXT.W
       </td>
       <td>
        <code>
         sext.w rd, rs
        </code>
       </td>
       <td>
        将低32位符号扩展至64位（RV64I）
       </td>
       <td>
        <code>
         addiw rd, rs, 0
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         空操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        NOP
       </td>
       <td>
        <code>
         nop
        </code>
       </td>
       <td>
        空操作（无实际效果）
       </td>
       <td>
        <code>
         addi x0, x0, 0
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="33__109">
     </a>
     3.3 移位指令
    </h3>
    <p>
     移位指令用于对寄存器中的数据进行位级左移或右移，分为以下两类：
    </p>
    <ul>
     <li>
      <ol>
       <li>
        寄存器移位：移位位数由另一个寄存器的低 5 位（RV32I）或低 6 位（RV64I）指定。
       </li>
      </ol>
     </li>
     <li>
      <ol start="2">
       <li>
        立即数移位：移位位数由指令中的立即数字段直接指定。
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5a69dd3ac3394bcc998feec16dbb2d96.png"/>
       </li>
      </ol>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         逻辑左移
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SLL
       </td>
       <td>
        <code>
         sll rd, rs1, rs2
        </code>
       </td>
       <td>
        逻辑左移（低位补零）
       </td>
       <td>
        <code>
         rd = rs1 &lt;&lt; (rs2[4:0])
        </code>
        （RV32I，取低5位）
        <br/>
        <code>
         rd = rs1 &lt;&lt; (rs2[5:0])
        </code>
        （RV64I，取低6位）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SLLI
       </td>
       <td>
        <code>
         slli rd, rs1, shamt
        </code>
       </td>
       <td>
        立即数逻辑左移
       </td>
       <td>
        <code>
         rd = rs1 &lt;&lt; shamt
        </code>
        （shamt范围：RV32I为 0–31，RV64I为 0–63）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SLLW
       </td>
       <td>
        <code>
         sllw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位逻辑左移（RV64I，低32位操作）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] &lt;&lt; rs2[4:0]))
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        SLLIW
       </td>
       <td>
        <code>
         slliw rd, rs1, shamt
        </code>
       </td>
       <td>
        32位立即数逻辑左移（RV64I）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] &lt;&lt; shamt)[31:0])
        </code>
        （shamt范围：0–31）
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         逻辑右移
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SRL
       </td>
       <td>
        <code>
         srl rd, rs1, rs2
        </code>
       </td>
       <td>
        逻辑右移（高位补零）
       </td>
       <td>
        <code>
         rd = rs1 &gt;&gt; (rs2[4:0])
        </code>
        （RV32I）
        <br/>
        <code>
         rd = rs1 &gt;&gt; (rs2[5:0])
        </code>
        （RV64I）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRLI
       </td>
       <td>
        <code>
         srli rd, rs1, shamt
        </code>
       </td>
       <td>
        立即数逻辑右移
       </td>
       <td>
        <code>
         rd = rs1 &gt;&gt; shamt
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRLW
       </td>
       <td>
        <code>
         srlw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位逻辑右移（RV64I，低32位操作）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] &gt;&gt; rs2[4:0]))
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRLIW
       </td>
       <td>
        <code>
         srliw rd, rs1, shamt
        </code>
       </td>
       <td>
        32位立即数逻辑右移（RV64I）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] &gt;&gt; shamt)[31:0])
        </code>
        （shamt范围：0–31）
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         算术右移
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SRA
       </td>
       <td>
        <code>
         sra rd, rs1, rs2
        </code>
       </td>
       <td>
        算术右移（高位补符号位）
       </td>
       <td>
        <code>
         rd = rs1 &gt;&gt;&gt; (rs2[4:0])
        </code>
        （RV32I）
        <br/>
        <code>
         rd = rs1 &gt;&gt;&gt; (rs2[5:0])
        </code>
        （RV64I）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRAI
       </td>
       <td>
        <code>
         srai rd, rs1, shamt
        </code>
       </td>
       <td>
        立即数算术右移
       </td>
       <td>
        <code>
         rd = rs1 &gt;&gt;&gt; shamt
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRAW
       </td>
       <td>
        <code>
         sraw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位算术右移（RV64I，低32位操作）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] &gt;&gt;&gt; rs2[4:0]))
        </code>
       </td>
       <td>
        RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRAIW
       </td>
       <td>
        <code>
         sraiw rd, rs1, shamt
        </code>
       </td>
       <td>
        32位立即数算术右移（RV64I）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] &gt;&gt;&gt; shamt)[31:0])
        </code>
        （shamt范围：0–31）
       </td>
       <td>
        RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="34__133">
     </a>
     3.4 逻辑指令
    </h3>
    <p>
     逻辑指令用于对寄存器中的数据进行按位操作，分为以下两类：
    </p>
    <ul>
     <li>
      1.寄存器-寄存器操作：两个寄存器之间的按位运算。
     </li>
     <li>
      2.寄存器-立即数操作：寄存器与符号扩展后的立即数进行按位运算。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0506c88743814bddab0fa73b26647d09.png"/>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         按位与操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        AND
       </td>
       <td>
        <code>
         and rd, rs1, rs2
        </code>
       </td>
       <td>
        按位与
       </td>
       <td>
        <code>
         rd = rs1 &amp; rs2
        </code>
       </td>
       <td>
        RV32I / RV64I
        <a href="18" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
      <tr>
       <td>
        ANDI
       </td>
       <td>
        <code>
         andi rd, rs1, imm
        </code>
       </td>
       <td>
        立即数按位与（符号扩展立即数）
       </td>
       <td>
        <code>
         rd = rs1 &amp; SignExt(imm)
        </code>
       </td>
       <td>
        RV32I / RV64I
        <a href="18" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         按位或操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        OR
       </td>
       <td>
        <code>
         or rd, rs1, rs2
        </code>
       </td>
       <td>
        按位或
       </td>
       <td>
        `rd = rs1
       </td>
       <td>
        rs2`
       </td>
      </tr>
      <tr>
       <td>
        ORI
       </td>
       <td>
        <code>
         ori rd, rs1, imm
        </code>
       </td>
       <td>
        立即数按位或（符号扩展立即数）
       </td>
       <td>
        `rd = rs1
       </td>
       <td>
        SignExt(imm)`
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         按位异或操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        XOR
       </td>
       <td>
        <code>
         xor rd, rs1, rs2
        </code>
       </td>
       <td>
        按位异或
       </td>
       <td>
        <code>
         rd = rs1 ^ rs2
        </code>
       </td>
       <td>
        RV32I / RV64I
        <a href="18" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
      <tr>
       <td>
        XORI
       </td>
       <td>
        <code>
         xori rd, rs1, imm
        </code>
       </td>
       <td>
        立即数按位异或（符号扩展立即数）
       </td>
       <td>
        <code>
         rd = rs1 ^ SignExt(imm)
        </code>
       </td>
       <td>
        RV32I / RV64I
        <a href="18" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      伪指令
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        NOT
       </td>
       <td>
        <code>
         not rd, rs
        </code>
       </td>
       <td>
        按位取反（rd = ~rs）
       </td>
       <td>
        <code>
         xori rd, rs, -1
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="35__157">
     </a>
     3.5 比较-置位指令
    </h3>
    <p>
     指令根据两个操作数的比较结果设置目标寄存器的值为 1 或 0，用于条件判断和逻辑控制，支持有符号和无符号比较。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/67be6be4016e4e72a2b1a5c46f10993c.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         有符号比较
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SLT
       </td>
       <td>
        <code>
         slt rd, rs1, rs2
        </code>
       </td>
       <td>
        有符号比较：若 rs1 &lt; rs2，则 rd = 1，否则 rd = 0
       </td>
       <td>
        <code>
         rd = (rs1 &lt; rs2) ? 1 : 0
        </code>
        （有符号比较）
       </td>
       <td>
        RV32I / RV64I
        <a href="20" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
      <tr>
       <td>
        SLTI
       </td>
       <td>
        <code>
         slti rd, rs1, imm
        </code>
       </td>
       <td>
        有符号立即数比较：若 rs1 &lt; SignExt(imm)，则 rd = 1
       </td>
       <td>
        <code>
         rd = (rs1 &lt; SignExt(imm)) ? 1 : 0
        </code>
       </td>
       <td>
        RV32I / RV64I
        <a href="20" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         无符号比较
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SLTU
       </td>
       <td>
        <code>
         sltu rd, rs1, rs2
        </code>
       </td>
       <td>
        无符号比较：若 rs1 &lt; rs2，则 rd = 1
       </td>
       <td>
        <code>
         rd = (rs1 &lt; rs2) ? 1 : 0
        </code>
        （无符号比较）
       </td>
       <td>
        RV32I / RV64I
        <a href="20" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
      <tr>
       <td>
        SLTIU
       </td>
       <td>
        <code>
         sltiu rd, rs1, imm
        </code>
       </td>
       <td>
        无符号立即数比较（立即数符号扩展后按无符号比较）：若 rs1 &lt; SignExt(imm)，则 rd = 1
       </td>
       <td>
        <code>
         rd = (rs1 &lt; SignExt(imm)) ? 1 : 0
        </code>
        （无符号比较）
       </td>
       <td>
        RV32I / RV64I
        <a href="20" rel="nofollow">
         ty-reference
        </a>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      伪指令
     </strong>
     ：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         零值判断
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SEQZ
       </td>
       <td>
        <code>
         seqz rd, rs
        </code>
       </td>
       <td>
        若 rs == 0，则 rd = 1，否则 0
       </td>
       <td>
        <code>
         sltiu rd, rs, 1
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SNEZ
       </td>
       <td>
        <code>
         snez rd, rs
        </code>
       </td>
       <td>
        若 rs ≠ 0，则 rd = 1，否则 0
       </td>
       <td>
        <code>
         sltu rd, x0, rs
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         符号判断
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SLTZ
       </td>
       <td>
        <code>
         sltz rd, rs
        </code>
       </td>
       <td>
        若 rs &lt; 0（有符号），则 rd = 1
       </td>
       <td>
        <code>
         slt rd, rs, x0
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SGTZ
       </td>
       <td>
        <code>
         sgtz rd, rs
        </code>
       </td>
       <td>
        若 rs &gt; 0（有符号），则 rd = 1
       </td>
       <td>
        <code>
         slt rd, x0, rs
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         非零符号判断
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        SLEZ
       </td>
       <td>
        <code>
         slez rd, rs
        </code>
       </td>
       <td>
        若 rs ≤ 0（有符号），则 rd = 1
       </td>
       <td>
        <code>
         slt rd, x0, rs → xori rd, rd, 1
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SGEZ
       </td>
       <td>
        <code>
         sgez rd, rs
        </code>
       </td>
       <td>
        若 rs ≥ 0（有符号），则 rd = 1
       </td>
       <td>
        <code>
         slt rd, rs, x0 → xori rd, rd, 1
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="36__183">
     </a>
     3.6 分支指令
    </h3>
    <p>
     分支指令用于控制程序流程，根据条件或地址跳转执行目标代码，均为 B-Type 或 J-Type 格式。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2fb55d9165d44f3892bdaa000ced1e76.png"/>
    </p>
    <h4>
     <a id="_186">
     </a>
     条件分支指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        BEQ
       </td>
       <td>
        <code>
         beq rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 == rs2，跳转到 PC + offset
       </td>
       <td>
        <code>
         if (rs1 == rs2) PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BNE
       </td>
       <td>
        <code>
         bne rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 ≠ rs2，跳转到 PC + offset
       </td>
       <td>
        <code>
         if (rs1 != rs2) PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BLT
       </td>
       <td>
        <code>
         blt rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 &lt; rs2（有符号），跳转
       </td>
       <td>
        <code>
         if (rs1 &lt; rs2) PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BGE
       </td>
       <td>
        <code>
         bge rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 ≥ rs2（有符号），跳转
       </td>
       <td>
        <code>
         if (rs1 &gt;= rs2) PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BLTU
       </td>
       <td>
        <code>
         bltu rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 &lt; rs2（无符号），跳转
       </td>
       <td>
        <code>
         if (rs1 &lt; rs2) PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BGEU
       </td>
       <td>
        <code>
         bgeu rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 ≥ rs2（无符号），跳转
       </td>
       <td>
        <code>
         if (rs1 &gt;= rs2) PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_197">
     </a>
     条件分支伪指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        BEQZ
       </td>
       <td>
        <code>
         beqz rs, offset
        </code>
       </td>
       <td>
        若 rs == 0，跳转到 offset
       </td>
       <td>
        <code>
         beq rs, x0, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BNEZ
       </td>
       <td>
        <code>
         bnez rs, offset
        </code>
       </td>
       <td>
        若 rs ≠ 0，跳转到 offset
       </td>
       <td>
        <code>
         bne rs, x0, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BGT
       </td>
       <td>
        <code>
         bgt rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 &gt; rs2（有符号），跳转
       </td>
       <td>
        <code>
         blt rs2, rs1, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BGTU
       </td>
       <td>
        <code>
         bgtu rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 &gt; rs2（无符号），跳转
       </td>
       <td>
        <code>
         bltu rs2, rs1, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BLE
       </td>
       <td>
        <code>
         ble rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 ≤ rs2（有符号），跳转
       </td>
       <td>
        <code>
         bge rs2, rs1, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        BLEU
       </td>
       <td>
        <code>
         bleu rs1, rs2, offset
        </code>
       </td>
       <td>
        若 rs1 ≤ rs2（无符号），跳转
       </td>
       <td>
        <code>
         bgeu rs2, rs1, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="37__208">
     </a>
     3.7 跳转指令
    </h3>
    <p>
     跳转指令用于改变程序的执行流程，使程序能够跳转到代码中的其他位置执行
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/a1c67ffc217a4438997b63ff08388768.png"/>
    </p>
    <h4>
     <a id="_211">
     </a>
     无条件跳转指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        JAL
       </td>
       <td>
        <code>
         jal rd, offset
        </code>
       </td>
       <td>
        跳转到 PC + offset，并将返回地址存入 rd
       </td>
       <td>
        <code>
         rd = PC + 4; PC += SignExt(offset &lt;&lt; 1)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        JALR
       </td>
       <td>
        <code>
         jalr rd, offset(rs1)
        </code>
       </td>
       <td>
        跳转到 rs1 + offset，存入返回地址
       </td>
       <td>
        <code>
         rd = PC + 4; PC = (rs1 + SignExt(offset)) &amp; ~1
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_218">
     </a>
     无条件跳转伪指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        J
       </td>
       <td>
        <code>
         j offset
        </code>
       </td>
       <td>
        无条件跳转到 offset
       </td>
       <td>
        <code>
         jal x0, offset
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        JR
       </td>
       <td>
        <code>
         jr rs
        </code>
       </td>
       <td>
        跳转到 rs 指向的地址
       </td>
       <td>
        <code>
         jalr x0, 0(rs)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        RET
       </td>
       <td>
        <code>
         ret
        </code>
       </td>
       <td>
        从函数返回（跳转到 ra 地址）
       </td>
       <td>
        <code>
         jalr x0, 0(ra)
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="38__227">
     </a>
     3.8 同步指令
    </h3>
    <p>
     同步指令用于处理内存访问顺序控制，确保数据一致性和并发安全。
    </p>
    <h4>
     <a id="_230">
     </a>
     内存屏障指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        FENCE
       </td>
       <td>
        <code>
         fence pred, succ
        </code>
       </td>
       <td>
        内存屏障（控制访存顺序）
       </td>
       <td>
        确保
        <code>
         pred
        </code>
        操作在
        <code>
         succ
        </code>
        操作前完成 (
        <code>
         pred/succ
        </code>
        可以为 r（读）、w（写）、i（指令流）)
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        FENCE.I
       </td>
       <td>
        <code>
         fence.i
        </code>
       </td>
       <td>
        指令流同步屏障
       </td>
       <td>
        确保后续指令看到此前所有指令的修改（用于自修改代码）
       </td>
       <td>
        RV32I / RV64I)
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="39__237">
     </a>
     3.9 环境指令
    </h3>
    <p>
     环境指令用于系统调用、调试、中断处理等特权级操作，通常需在特定权限模式下执行。
    </p>
    <h4>
     <a id="_240">
     </a>
     系统调用与异常处理指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ECALL
       </td>
       <td>
        <code>
         ecall
        </code>
       </td>
       <td>
        触发环境调用（系统调用/异常）
       </td>
       <td>
        根据当前模式跳转到异常处理程序
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        EBREAK
       </td>
       <td>
        <code>
         ebreak
        </code>
       </td>
       <td>
        触发断点异常（用于调试）
       </td>
       <td>
        进入调试模式或触发异常处理
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_247">
     </a>
     中断返回指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        MRET
       </td>
       <td>
        <code>
         mret
        </code>
       </td>
       <td>
        从机器模式异常返回
       </td>
       <td>
        <code>
         PC = MEPC; Privilege = MPP
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        SRET
       </td>
       <td>
        <code>
         sret
        </code>
       </td>
       <td>
        从监管者模式异常返回
       </td>
       <td>
        <code>
         PC = SEPC; Privilege = SPP
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        URET
       </td>
       <td>
        <code>
         uret
        </code>
       </td>
       <td>
        从用户模式异常返回
       </td>
       <td>
        <code>
         PC = UEPC
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_255">
     </a>
     等待与暂停指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        WFI
       </td>
       <td>
        <code>
         wfi
        </code>
       </td>
       <td>
        等待中断（暂停执行直至中断发生）
       </td>
       <td>
        暂停 CPU 直至中断或事件唤醒
       </td>
       <td>
        RV32I / RV64I )
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="310__260">
     </a>
     3.10 控制状态寄存器指令
    </h3>
    <p>
     指令用于读写处理器的控制状态寄存器（如中断配置、计数器、特权模式设置等），支持原子操作和位操作，适用于系统编程和特权级管理。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b4b90ee96a2d4f7c8be3e105f2b60521.png"/>
    </p>
    <h4>
     <a id="CSR__263">
     </a>
     CSR 读写指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        CSRRW
       </td>
       <td>
        <code>
         csrrw rd, csr, rs1
        </code>
       </td>
       <td>
        将
        <code>
         rs1
        </code>
        写入 CSR，原值存入
        <code>
         rd
        </code>
       </td>
       <td>
        <code>
         t = CSR[csr]; CSR[csr] = rs1; rd = t
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRRS
       </td>
       <td>
        <code>
         csrrs rd, csr, rs1
        </code>
       </td>
       <td>
        将
        <code>
         rs1
        </code>
        对应位设为 1，原值存入
        <code>
         rd
        </code>
       </td>
       <td>
        `t = CSR[csr]; CSR[csr]
       </td>
       <td>
        = rs1; rd = t`
       </td>
      </tr>
      <tr>
       <td>
        CSRRC
       </td>
       <td>
        <code>
         csrrc rd, csr, rs1
        </code>
       </td>
       <td>
        将
        <code>
         rs1
        </code>
        对应位清 0，原值存入
        <code>
         rd
        </code>
       </td>
       <td>
        <code>
         t = CSR[csr]; CSR[csr] &amp;= ~rs1; rd = t
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRRWI
       </td>
       <td>
        <code>
         csrrwi rd, csr, imm
        </code>
       </td>
       <td>
        将 5 位立即数写入 CSR
       </td>
       <td>
        <code>
         t = CSR[csr]; CSR[csr] = imm; rd = t
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRRSI
       </td>
       <td>
        <code>
         csrrsi rd, csr, imm
        </code>
       </td>
       <td>
        将立即数对应位置 1
       </td>
       <td>
        `t = CSR[csr]; CSR[csr]
       </td>
       <td>
        = imm; rd = t`
       </td>
      </tr>
      <tr>
       <td>
        CSRRCI
       </td>
       <td>
        <code>
         csrrci rd, csr, imm
        </code>
       </td>
       <td>
        将立即数对应位清 0
       </td>
       <td>
        <code>
         t = CSR[csr]; CSR[csr] &amp;= ~imm; rd = t
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="CSR__274">
     </a>
     CSR 伪指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        CSRR
       </td>
       <td>
        <code>
         csrr rd, csr
        </code>
       </td>
       <td>
        读取 CSR 的值到寄存器
       </td>
       <td>
        <code>
         csrrs rd, csr, x0
        </code>
        （读 CSR，不修改）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRW
       </td>
       <td>
        <code>
         csrw csr, rs
        </code>
       </td>
       <td>
        将寄存器的值写入 CSR
       </td>
       <td>
        <code>
         csrrw x0, csr, rs
        </code>
        （丢弃原值，仅写入）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRS
       </td>
       <td>
        <code>
         csrs csr, rs
        </code>
       </td>
       <td>
        设置 CSR 中由
        <code>
         rs
        </code>
        指定的位
       </td>
       <td>
        <code>
         csrrs x0, csr, rs
        </code>
        （按位或，不保存结果）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRC
       </td>
       <td>
        <code>
         csrc csr, rs
        </code>
       </td>
       <td>
        清除 CSR 中由
        <code>
         rs
        </code>
        指定的位
       </td>
       <td>
        <code>
         csrrc x0, csr, rs
        </code>
        （按位与取反，不保存结果）
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRWI
       </td>
       <td>
        <code>
         csrwi csr, imm
        </code>
       </td>
       <td>
        将 5 位立即数写入 CSR
       </td>
       <td>
        <code>
         csrrwi x0, csr, imm
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRSI
       </td>
       <td>
        <code>
         csrsi csr, imm
        </code>
       </td>
       <td>
        设置 CSR 中由立即数指定的位
       </td>
       <td>
        <code>
         csrrsi x0, csr, imm
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
      <tr>
       <td>
        CSRCI
       </td>
       <td>
        <code>
         csrci csr, imm
        </code>
       </td>
       <td>
        清除 CSR 中由立即数指定的位
       </td>
       <td>
        <code>
         csrrci x0, csr, imm
        </code>
       </td>
       <td>
        RV32I / RV64I
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="4_RVM_287">
     </a>
     4 RVM指令集
    </h2>
    <p>
     RVM 扩展指令分为 乘法指令 和 除法/取余指令，支持有符号和无符号操作，并区分 RV32 和 RV64 的差异。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/82d6f400832f4031a04e9d6c84a48dbc.png"/>
    </p>
    <h4>
     <a id="_290">
     </a>
     乘法指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        MUL
       </td>
       <td>
        <code>
         mul rd, rs1, rs2
        </code>
       </td>
       <td>
        乘法（低32/64位结果）
       </td>
       <td>
        <code>
         rd = (rs1 * rs2)[31:0]
        </code>
        （RV32）
        <br/>
        <code>
         rd = rs1 * rs2
        </code>
        （RV64）
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        MULH
       </td>
       <td>
        <code>
         mulh rd, rs1, rs2
        </code>
       </td>
       <td>
        有符号乘法（高32/64位结果）
       </td>
       <td>
        <code>
         rd = (rs1 * rs2)[63:32]
        </code>
        （RV32）
        <br/>
        <code>
         rd = (rs1 * rs2)[127:64]
        </code>
        （RV64）
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        MULHU
       </td>
       <td>
        <code>
         mulhu rd, rs1, rs2
        </code>
       </td>
       <td>
        无符号乘法（高32/64位结果）
       </td>
       <td>
        同上，操作数为无符号数
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        MULHSU
       </td>
       <td>
        <code>
         mulhsu rd, rs1, rs2
        </code>
       </td>
       <td>
        有符号-无符号乘法（高32/64位结果）
       </td>
       <td>
        <code>
         rs1
        </code>
        有符号，
        <code>
         rs2
        </code>
        无符号
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        MULW
       </td>
       <td>
        <code>
         mulw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位乘法（结果符号扩展至64位）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] * rs2[31:0]))
        </code>
       </td>
       <td>
        RV64M
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_300">
     </a>
     除法/取余指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        DIV
       </td>
       <td>
        <code>
         div rd, rs1, rs2
        </code>
       </td>
       <td>
        有符号除法（商）
       </td>
       <td>
        <code>
         rd = rs1 / rs2
        </code>
        （向零舍入）
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        DIVU
       </td>
       <td>
        <code>
         divu rd, rs1, rs2
        </code>
       </td>
       <td>
        无符号除法（商）
       </td>
       <td>
        <code>
         rd = rs1 / rs2
        </code>
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        REM
       </td>
       <td>
        <code>
         rem rd, rs1, rs2
        </code>
       </td>
       <td>
        有符号取余（余数）
       </td>
       <td>
        <code>
         rd = rs1 % rs2
        </code>
        （符号与
        <code>
         rs1
        </code>
        相同）
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        REMU
       </td>
       <td>
        <code>
         remu rd, rs1, rs2
        </code>
       </td>
       <td>
        无符号取余（余数）
       </td>
       <td>
        <code>
         rd = rs1 % rs2
        </code>
       </td>
       <td>
        RV32M / RV64M
       </td>
      </tr>
      <tr>
       <td>
        DIVW
       </td>
       <td>
        <code>
         divw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位有符号除法（符号扩展至64位）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] / rs2[31:0]))
        </code>
       </td>
       <td>
        RV64M
       </td>
      </tr>
      <tr>
       <td>
        DIVUW
       </td>
       <td>
        <code>
         divuw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位无符号除法（零扩展至64位）
       </td>
       <td>
        <code>
         rd = ZeroExt((rs1[31:0] / rs2[31:0]))
        </code>
       </td>
       <td>
        RV64M
       </td>
      </tr>
      <tr>
       <td>
        REMW
       </td>
       <td>
        <code>
         remw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位有符号取余（符号扩展至64位）
       </td>
       <td>
        <code>
         rd = SignExt((rs1[31:0] % rs2[31:0]))
        </code>
       </td>
       <td>
        RV64M
       </td>
      </tr>
      <tr>
       <td>
        REMUW
       </td>
       <td>
        <code>
         remuw rd, rs1, rs2
        </code>
       </td>
       <td>
        32位无符号取余（零扩展至64位）
       </td>
       <td>
        <code>
         rd = ZeroExt((rs1[31:0] % rs2[31:0]))
        </code>
       </td>
       <td>
        RV64M
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="5_RVFD_313">
     </a>
     5 RVFD指令集
    </h2>
    <h3>
     <a id="51__314">
     </a>
     5.1 访存指令
    </h3>
    <p>
     指令用于在内存和浮点寄存器（f0-f31）之间传输单精度（F 扩展）或双精度（D 扩展）浮点数据：
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1892a51020b6412d97c87924f9410e1b.png"/>
    </p>
    <h4>
     <a id="_317">
     </a>
     浮点加载和存储指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        FLW
       </td>
       <td>
        <code>
         flw fd, offset(rs1)
        </code>
       </td>
       <td>
        从内存加载单精度浮点数到浮点寄存器
       </td>
       <td>
        <code>
         fd = F32(Mem[rs1 + offset])
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        FSW
       </td>
       <td>
        <code>
         fsw fs, offset(rs1)
        </code>
       </td>
       <td>
        将单精度浮点数从浮点寄存器存入内存
       </td>
       <td>
        <code>
         Mem[rs1 + offset] = F32(fs)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        FLD
       </td>
       <td>
        <code>
         fld fd, offset(rs1)
        </code>
       </td>
       <td>
        从内存加载双精度浮点数到浮点寄存器
       </td>
       <td>
        <code>
         fd = F64(Mem[rs1 + offset])
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        FSD
       </td>
       <td>
        <code>
         fsd fs, offset(rs1)
        </code>
       </td>
       <td>
        将双精度浮点数从浮点寄存器存入内存
       </td>
       <td>
        <code>
         Mem[rs1 + offset] = F64(fs)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="52__326">
     </a>
     5.2 算术指令
    </h3>
    <p>
     算术指令用于执行各种数学运算，如加法、减法、乘法、除法等。当涉及到浮点数时，这些操作变得更为复杂，因为它们需要处理指数和尾数部分
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/d19accfb7c4045cc9aee4d97edd1a050.png"/>
    </p>
    <h4>
     <a id="_330">
     </a>
     基本算术指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        加法
       </td>
       <td>
        FADD.S
       </td>
       <td>
        <code>
         fadd.s fd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点加法
       </td>
       <td>
        <code>
         fd = fs1 + fs2
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FADD.D
       </td>
       <td>
        <code>
         fadd.d fd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点加法
       </td>
       <td>
        <code>
         fd = fs1 + fs2
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        减法
       </td>
       <td>
        FSUB.S
       </td>
       <td>
        <code>
         fsub.s fd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点减法
       </td>
       <td>
        <code>
         fd = fs1 - fs2
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FSUB.D
       </td>
       <td>
        <code>
         fsub.d fd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点减法
       </td>
       <td>
        <code>
         fd = fs1 - fs2
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        乘法
       </td>
       <td>
        FMUL.S
       </td>
       <td>
        <code>
         fmul.s fd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点乘法
       </td>
       <td>
        <code>
         fd = fs1 * fs2
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FMUL.D
       </td>
       <td>
        <code>
         fmul.d fd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点乘法
       </td>
       <td>
        <code>
         fd = fs1 * fs2
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        除法
       </td>
       <td>
        FDIV.S
       </td>
       <td>
        <code>
         fdiv.s fd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点除法
       </td>
       <td>
        <code>
         fd = fs1 / fs2
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FDIV.D
       </td>
       <td>
        <code>
         fdiv.d fd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点除法
       </td>
       <td>
        <code>
         fd = fs1 / fs2
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        平方根
       </td>
       <td>
        FSQRT.S
       </td>
       <td>
        <code>
         fsqrt.s fd, fs1
        </code>
       </td>
       <td>
        单精度浮点平方根
       </td>
       <td>
        <code>
         fd = sqrt(fs1)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FSQRT.D
       </td>
       <td>
        <code>
         fsqrt.d fd, fs1
        </code>
       </td>
       <td>
        双精度浮点平方根
       </td>
       <td>
        <code>
         fd = sqrt(fs1)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        最小值
       </td>
       <td>
        FMIN.S
       </td>
       <td>
        <code>
         fmin.s fd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点最小值
       </td>
       <td>
        <code>
         fd = min(fs1, fs2)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FMIN.D
       </td>
       <td>
        <code>
         fmin.d fd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点最小值
       </td>
       <td>
        <code>
         fd = min(fs1, fs2)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        最大值
       </td>
       <td>
        FMAX.S
       </td>
       <td>
        <code>
         fmax.s fd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点最大值
       </td>
       <td>
        <code>
         fd = max(fs1, fs2)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FMAX.D
       </td>
       <td>
        <code>
         fmax.d fd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点最大值
       </td>
       <td>
        <code>
         fd = max(fs1, fs2)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="53_RVFD__350">
     </a>
     5.3 RVFD 乘加指令
    </h3>
    <p>
     指令用于执行 乘加融合运算（Fused Multiply-Add, FMA），即在一个操作中完成乘法和加法，通常具有更高的精度和性能
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/676dc51f1b2a40dc9800611f98da9a97.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        单精度乘加
       </td>
       <td>
        FMADD.S
       </td>
       <td>
        <code>
         fmadd.s fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        单精度浮点乘加
       </td>
       <td>
        <code>
         fd = (fs1 * fs2) + fs3
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        单精度乘减
       </td>
       <td>
        FMSUB.S
       </td>
       <td>
        <code>
         fmsub.s fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        单精度浮点乘减
       </td>
       <td>
        <code>
         fd = (fs1 * fs2) - fs3
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        单精度负乘加
       </td>
       <td>
        FNMADD.S
       </td>
       <td>
        <code>
         fnmadd.s fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        单精度浮点负乘加
       </td>
       <td>
        <code>
         fd = -((fs1 * fs2) + fs3)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        单精度负乘减
       </td>
       <td>
        FNMSUB.S
       </td>
       <td>
        <code>
         fnmsub.s fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        单精度浮点负乘减
       </td>
       <td>
        <code>
         fd = -((fs1 * fs2) - fs3)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        双精度乘加
       </td>
       <td>
        FMADD.D
       </td>
       <td>
        <code>
         fmadd.d fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        双精度浮点乘加
       </td>
       <td>
        <code>
         fd = (fs1 * fs2) + fs3
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        双精度乘减
       </td>
       <td>
        FMSUB.D
       </td>
       <td>
        <code>
         fmsub.d fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        双精度浮点乘减
       </td>
       <td>
        <code>
         fd = (fs1 * fs2) - fs3
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        双精度负乘加
       </td>
       <td>
        FNMADD.D
       </td>
       <td>
        <code>
         fnmadd.d fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        双精度浮点负乘加
       </td>
       <td>
        <code>
         fd = -((fs1 * fs2) + fs3)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        双精度负乘减
       </td>
       <td>
        FNMSUB.D
       </td>
       <td>
        <code>
         fnmsub.d fd, fs1, fs2, fs3
        </code>
       </td>
       <td>
        双精度浮点负乘减
       </td>
       <td>
        <code>
         fd = -((fs1 * fs2) - fs3)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="54_RVFD_363">
     </a>
     5.4 RVFD传送指令
    </h3>
    <p>
     指令用于在 浮点寄存器 和 整数寄存器 之间传输数据，或在不同浮点寄存器之间复制数据
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b327bbda8e2a44fa80aaee3a0372857c.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        浮点到整数
       </td>
       <td>
        FMV.X.S
       </td>
       <td>
        <code>
         fmv.x.s rd, fs1
        </code>
       </td>
       <td>
        将单精度浮点数转为整数表示
       </td>
       <td>
        <code>
         rd = fs1
        </code>
        （按位复制）
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        浮点到整数
       </td>
       <td>
        FMV.X.D
       </td>
       <td>
        <code>
         fmv.x.d rd, fs1
        </code>
       </td>
       <td>
        将双精度浮点数转为整数表示
       </td>
       <td>
        <code>
         rd = fs1
        </code>
        （按位复制）
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        整数到浮点
       </td>
       <td>
        FMV.S.X
       </td>
       <td>
        <code>
         fmv.s.x fd, rs1
        </code>
       </td>
       <td>
        将整数表示转为单精度浮点数
       </td>
       <td>
        <code>
         fd = rs1
        </code>
        （按位复制）
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        整数到浮点
       </td>
       <td>
        FMV.D.X
       </td>
       <td>
        <code>
         fmv.d.x fd, rs1
        </code>
       </td>
       <td>
        将整数表示转为双精度浮点数
       </td>
       <td>
        <code>
         fd = rs1
        </code>
        （按位复制）
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="55_RVFD__374">
     </a>
     5.5 RVFD 转换指令
    </h3>
    <p>
     分两类归纳：浮点寄存器间传送 和 浮点与整数寄存器间传送，涵盖符号操作、位模式复制及特殊值处理
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5faa8652d539484ebcd7fb1dde216a6b.png"/>
    </p>
    <h4>
     <a id="_378">
     </a>
     浮点与整数之间的转换
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         浮点 → 整数
        </strong>
       </td>
       <td>
        FCVT.W.S
       </td>
       <td>
        <code>
         fcvt.w.s rd, fs1
        </code>
       </td>
       <td>
        单精度浮点转为 32 位有符号整数
       </td>
       <td>
        <code>
         rd = (int32_t)fs1
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.WU.S
       </td>
       <td>
        <code>
         fcvt.wu.s rd, fs1
        </code>
       </td>
       <td>
        单精度浮点转为 32 位无符号整数
       </td>
       <td>
        <code>
         rd = (uint32_t)fs1
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.L.S
       </td>
       <td>
        <code>
         fcvt.l.s rd, fs1
        </code>
       </td>
       <td>
        单精度浮点转为 64 位有符号整数
       </td>
       <td>
        <code>
         rd = (int64_t)fs1
        </code>
       </td>
       <td>
        RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.LU.S
       </td>
       <td>
        <code>
         fcvt.lu.s rd, fs1
        </code>
       </td>
       <td>
        单精度浮点转为 64 位无符号整数
       </td>
       <td>
        <code>
         rd = (uint64_t)fs1
        </code>
       </td>
       <td>
        RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.W.D
       </td>
       <td>
        <code>
         fcvt.w.d rd, fs1
        </code>
       </td>
       <td>
        双精度浮点转为 32 位有符号整数
       </td>
       <td>
        <code>
         rd = (int32_t)fs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.WU.D
       </td>
       <td>
        <code>
         fcvt.wu.d rd, fs1
        </code>
       </td>
       <td>
        双精度浮点转为 32 位无符号整数
       </td>
       <td>
        <code>
         rd = (uint32_t)fs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.L.D
       </td>
       <td>
        <code>
         fcvt.l.d rd, fs1
        </code>
       </td>
       <td>
        双精度浮点转为 64 位有符号整数
       </td>
       <td>
        <code>
         rd = (int64_t)fs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.LU.D
       </td>
       <td>
        <code>
         fcvt.lu.d rd, fs1
        </code>
       </td>
       <td>
        双精度浮点转为 64 位无符号整数
       </td>
       <td>
        <code>
         rd = (uint64_t)fs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         整数 → 浮点
        </strong>
       </td>
       <td>
        FCVT.S.W
       </td>
       <td>
        <code>
         fcvt.s.w fd, rs1
        </code>
       </td>
       <td>
        32 位有符号整数转为单精度浮点
       </td>
       <td>
        <code>
         fd = (float)rs1
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.S.WU
       </td>
       <td>
        <code>
         fcvt.s.wu fd, rs1
        </code>
       </td>
       <td>
        32 位无符号整数转为单精度浮点
       </td>
       <td>
        <code>
         fd = (float)rs1
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.S.L
       </td>
       <td>
        <code>
         fcvt.s.l fd, rs1
        </code>
       </td>
       <td>
        64 位有符号整数转为单精度浮点
       </td>
       <td>
        <code>
         fd = (float)rs1
        </code>
       </td>
       <td>
        RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.S.LU
       </td>
       <td>
        <code>
         fcvt.s.lu fd, rs1
        </code>
       </td>
       <td>
        64 位无符号整数转为单精度浮点
       </td>
       <td>
        <code>
         fd = (float)rs1
        </code>
       </td>
       <td>
        RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.D.W
       </td>
       <td>
        <code>
         fcvt.d.w fd, rs1
        </code>
       </td>
       <td>
        32 位有符号整数转为双精度浮点
       </td>
       <td>
        <code>
         fd = (double)rs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.D.WU
       </td>
       <td>
        <code>
         fcvt.d.wu fd, rs1
        </code>
       </td>
       <td>
        32 位无符号整数转为双精度浮点
       </td>
       <td>
        <code>
         fd = (double)rs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.D.L
       </td>
       <td>
        <code>
         fcvt.d.l fd, rs1
        </code>
       </td>
       <td>
        64 位有符号整数转为双精度浮点
       </td>
       <td>
        <code>
         fd = (double)rs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FCVT.D.LU
       </td>
       <td>
        <code>
         fcvt.d.lu fd, rs1
        </code>
       </td>
       <td>
        64 位无符号整数转为双精度浮点
       </td>
       <td>
        <code>
         fd = (double)rs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_398">
     </a>
     浮点精度之间的转换
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        单精度 ↔ 双精度
       </td>
       <td>
        FCVT.S.D
       </td>
       <td>
        <code>
         fcvt.s.d fd, fs1
        </code>
       </td>
       <td>
        双精度浮点转为单精度浮点
       </td>
       <td>
        <code>
         fd = (float)fs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        单精度 ↔ 双精度
       </td>
       <td>
        FCVT.D.S
       </td>
       <td>
        <code>
         fcvt.d.s fd, fs1
        </code>
       </td>
       <td>
        单精度浮点转为双精度浮点
       </td>
       <td>
        <code>
         fd = (double)fs1
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="56_RVFD__404">
     </a>
     5.6 RVFD 符号注入指令
    </h3>
    <p>
     指令用于将 整数立即数 或 整数寄存器值 注入到浮点寄存器中，通常用于快速构造浮点常数或特殊值（如 NaN、无穷大）
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/58fdcd9d5a6c4c548c39314cf8a3bb72.png"/>
    </p>
    <h4>
     <a id="_407">
     </a>
     单精度浮点注入指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        符号复制
       </td>
       <td>
        FSGNJ.S
       </td>
       <td>
        <code>
         fsgnj.s fd, fs1, fs2
        </code>
       </td>
       <td>
        复制数值，符号位取自 fs2
       </td>
       <td>
        <code>
         fd = {fs2[31], fs1[30:0]}
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        符号取反
       </td>
       <td>
        FSGNJN.S
       </td>
       <td>
        <code>
         fsgnjn.s fd, fs1, fs2
        </code>
       </td>
       <td>
        复制数值，符号位取反自 fs2
       </td>
       <td>
        <code>
         fd = {~fs2[31], fs1[30:0]}
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        符号取绝对值
       </td>
       <td>
        FSGNJX.S
       </td>
       <td>
        <code>
         fsgnjx.s fd, fs1, fs2
        </code>
       </td>
       <td>
        复制数值，符号位异或（取绝对值）
       </td>
       <td>
        <code>
         fd = {fs1[31] ^ fs2[31], fs1[30:0]}
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_414">
     </a>
     双精度浮点注入指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        符号复制
       </td>
       <td>
        FSGNJ.D
       </td>
       <td>
        <code>
         fsgnj.d fd, fs1, fs2
        </code>
       </td>
       <td>
        复制数值，符号位取自 fs2
       </td>
       <td>
        <code>
         fd = {fs2[63], fs1[62:0]}
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        符号取反
       </td>
       <td>
        FSGNJN.D
       </td>
       <td>
        <code>
         fsgnjn.d fd, fs1, fs2
        </code>
       </td>
       <td>
        复制数值，符号位取反自 fs2
       </td>
       <td>
        <code>
         fd = {~fs2[63], fs1[62:0]}
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        符号取绝对值
       </td>
       <td>
        FSGNJX.D
       </td>
       <td>
        <code>
         fsgnjx.d fd, fs1, fs2
        </code>
       </td>
       <td>
        复制数值，符号位异或（取绝对值）
       </td>
       <td>
        <code>
         fd = {fs1[63] ^ fs2[63], fs1[62:0]}
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_421">
     </a>
     伪指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         单精度浮点注入
        </strong>
       </td>
       <td>
        FABS.S
       </td>
       <td>
        <code>
         fabs.s fd, fs
        </code>
       </td>
       <td>
        单精度浮点取绝对值
       </td>
       <td>
        <code>
         fsgnjx.s fd, fs, fs
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FMV.S
       </td>
       <td>
        <code>
         fmv.s fd, fs
        </code>
       </td>
       <td>
        单精度浮点复制
       </td>
       <td>
        <code>
         fsgnj.s fd, fs, fs
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FNEG.S
       </td>
       <td>
        <code>
         fneg.s fd, fs
        </code>
       </td>
       <td>
        单精度浮点取反
       </td>
       <td>
        <code>
         fsgnjn.s fd, fs, fs
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        伪指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        实际转换（基础指令）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        双精度浮点注入
       </td>
       <td>
        FABS.D
       </td>
       <td>
        <code>
         fabs.d fd, fs
        </code>
       </td>
       <td>
        双精度浮点取绝对值
       </td>
       <td>
        <code>
         fsgnjx.d fd, fs, fs
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FMV.D
       </td>
       <td>
        <code>
         fmv.d fd, fs
        </code>
       </td>
       <td>
        双精度浮点复制
       </td>
       <td>
        <code>
         fsgnj.d fd, fs, fs
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FNEG.D
       </td>
       <td>
        <code>
         fneg.d fd, fs
        </code>
       </td>
       <td>
        双精度浮点取反
       </td>
       <td>
        <code>
         fsgnjn.d fd, fs, fs
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="57_RVFD__433">
     </a>
     5.7 RVFD 比较指令
    </h3>
    <p>
     指令用于比较两个浮点数的值，并将比较结果写入整数寄存器，支持 相等、小于 和 小于等于 三种比较操作
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c9925ee3417646768ead560e1414a0fc.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         相等比较
        </strong>
       </td>
       <td>
        FEQ.S
       </td>
       <td>
        <code>
         feq.s rd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点相等比较
       </td>
       <td>
        <code>
         rd = (fs1 == fs2) ? 1 : 0
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FEQ.D
       </td>
       <td>
        <code>
         feq.d rd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点相等比较
       </td>
       <td>
        <code>
         rd = (fs1 == fs2) ? 1 : 0
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         小于比较
        </strong>
       </td>
       <td>
        FLT.S
       </td>
       <td>
        <code>
         flt.s rd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点小于比较
       </td>
       <td>
        <code>
         rd = (fs1 &lt; fs2) ? 1 : 0
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FLT.D
       </td>
       <td>
        <code>
         flt.d rd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点小于比较
       </td>
       <td>
        <code>
         rd = (fs1 &lt; fs2) ? 1 : 0
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         小于等于比较
        </strong>
       </td>
       <td>
        FLE.S
       </td>
       <td>
        <code>
         fle.s rd, fs1, fs2
        </code>
       </td>
       <td>
        单精度浮点小于等于比较
       </td>
       <td>
        <code>
         rd = (fs1 &lt;= fs2) ? 1 : 0
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        FLE.D
       </td>
       <td>
        <code>
         fle.d rd, fs1, fs2
        </code>
       </td>
       <td>
        双精度浮点小于等于比较
       </td>
       <td>
        <code>
         rd = (fs1 &lt;= fs2) ? 1 : 0
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="58_RVFD__444">
     </a>
     5.8 RVFD 分类指令
    </h3>
    <p>
     指令用于检查浮点数的类别（如正无穷、负零、NaN 等），并将结果写入整数寄存器，适用于浮点数的异常处理和特殊值检测
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8d187bed2561437a999e96082ea6660b.png"/>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        浮点分类
       </td>
       <td>
        单精度分类
       </td>
       <td>
        <code>
         fclass.s rd, fs1
        </code>
       </td>
       <td>
        单精度浮点分类
       </td>
       <td>
        <code>
         rd = classify(fs1)
        </code>
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        浮点分类
       </td>
       <td>
        双精度分类
       </td>
       <td>
        <code>
         fclass.d rd, fs1
        </code>
       </td>
       <td>
        双精度浮点分类
       </td>
       <td>
        <code>
         rd = classify(fs1)
        </code>
       </td>
       <td>
        RV64D
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <a id="59_RVFD__451">
     </a>
     5.9 RVFD 配置指令
    </h3>
    <p>
     指令用于配置和管理浮点单元的状态，包括 舍入模式、异常标志 和 浮点控制状态寄存器（fcsr） 的操作
    </p>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         浮点控制状态寄存器（fcsr）操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        读取 fcsr
       </td>
       <td>
        FRCSR
       </td>
       <td>
        frcsr rd
       </td>
       <td>
        读取 fcsr 的值到整数寄存器
       </td>
       <td>
        rd = fcsr
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        写入 fcsr
       </td>
       <td>
        FSCSR
       </td>
       <td>
        fscsr rd, rs
       </td>
       <td>
        将整数寄存器的值写入 fcsr
       </td>
       <td>
        fcsr = rs
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        交换 fcsr
       </td>
       <td>
        FSRCS
       </td>
       <td>
        fscsr rd, rs
       </td>
       <td>
        交换 fcsr 和整数寄存器的值
       </td>
       <td>
        t = fcsr; fcsr = rs; rd = t
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         舍入模式配置
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        读取舍入模式
       </td>
       <td>
        FRRM
       </td>
       <td>
        frrm rd
       </td>
       <td>
        读取舍入模式到整数寄存器
       </td>
       <td>
        rd = fcsr[7:5]
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        写入舍入模式
       </td>
       <td>
        FSRM
       </td>
       <td>
        fsrm rd, rs
       </td>
       <td>
        将整数寄存器的值写入舍入模式
       </td>
       <td>
        fcsr[7:5] = rs[2:0]
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        交换舍入模式
       </td>
       <td>
        FSRRM
       </td>
       <td>
        fsrrm rd, rs
       </td>
       <td>
        交换舍入模式和整数寄存器的值
       </td>
       <td>
        t = fcsr[7:5]; fcsr[7:5] = rs[2:0]; rd = t
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         异常标志操作
        </strong>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        读取异常标志
       </td>
       <td>
        FFLAGS
       </td>
       <td>
        fflags rd
       </td>
       <td>
        读取异常标志到整数寄存器
       </td>
       <td>
        rd = fcsr[4:0]
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        写入异常标志
       </td>
       <td>
        FSFLAGS
       </td>
       <td>
        fsflags rd, rs
       </td>
       <td>
        将整数寄存器的值写入异常标志
       </td>
       <td>
        fcsr[4:0] = rs[4:0]
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
      <tr>
       <td>
        交换异常标志
       </td>
       <td>
        FSRFLAGS
       </td>
       <td>
        fsrflags rd, rs
       </td>
       <td>
        交换异常标志和整数寄存器的值
       </td>
       <td>
        t = fcsr[4:0]; fcsr[4:0] = rs[4:0]; rd = t
       </td>
       <td>
        RV32F / RV64F
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     <a id="6_RVA_469">
     </a>
     6 RVA指令集
    </h2>
    <p>
     RVA（Atomic Operations）扩展为 RISC-V 提供了硬件支持的原子操作指令，用于在多线程或多核环境中实现 原子内存访问 和 同步操作，确保数据一致性和并发安全。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/77da756e668b41a096eaa360944b6484.png"/>
    </p>
    <h4>
     <a id="_472">
     </a>
     加载保留与条件存储指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        加载保留
       </td>
       <td>
        LR.W
       </td>
       <td>
        <code>
         lr.w rd, (rs1)
        </code>
       </td>
       <td>
        加载保留（原子加载字，标记内存地址）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Reserve rs1
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        LR.D
       </td>
       <td>
        <code>
         lr.d rd, (rs1)
        </code>
       </td>
       <td>
        加载保留（原子加载双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Reserve rs1
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        条件存储
       </td>
       <td>
        SC.W
       </td>
       <td>
        <code>
         sc.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        条件存储（若地址未被修改，存储字）
       </td>
       <td>
        <code>
         if (Reserve rs1 still valid) { Mem[rs1] = rs2; rd = 0 } else { rd = 1 }
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        SC.D
       </td>
       <td>
        <code>
         sc.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        条件存储（若地址未被修改，存储双字）
       </td>
       <td>
        <code>
         if (Reserve rs1 still valid) { Mem[rs1] = rs2; rd = 0 } else { rd = 1 }
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="_481">
     </a>
     原子内存操作指令
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        指令类型
       </th>
       <th>
        指令
       </th>
       <th>
        格式
       </th>
       <th>
        功能描述
       </th>
       <th>
        操作（伪代码）
       </th>
       <th>
        适用指令集
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        原子加
       </td>
       <td>
        AMOADD.W
       </td>
       <td>
        <code>
         amoadd.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子加并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] += rs2
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOADD.D
       </td>
       <td>
        <code>
         amoadd.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子加并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] += rs2
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子交换
       </td>
       <td>
        AMOSWAP.W
       </td>
       <td>
        <code>
         amoswap.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子交换并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = rs2
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOSWAP.D
       </td>
       <td>
        <code>
         amoswap.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子交换并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = rs2
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子按位与
       </td>
       <td>
        AMOAND.W
       </td>
       <td>
        <code>
         amoand.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子按位与并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] &amp;= rs2
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOAND.D
       </td>
       <td>
        <code>
         amoand.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子按位与并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] &amp;= rs2
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子按位或
       </td>
       <td>
        AMOOR.W
       </td>
       <td>
        <code>
         amoor.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子按位或并返回原值
       </td>
       <td>
        `rd = Mem[rs1]; Mem[rs1]
       </td>
       <td>
        = rs2`
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOOR.D
       </td>
       <td>
        <code>
         amoor.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子按位或并返回原值（双字）
       </td>
       <td>
        `rd = Mem[rs1]; Mem[rs1]
       </td>
       <td>
        = rs2`
       </td>
      </tr>
      <tr>
       <td>
        原子按位异或
       </td>
       <td>
        AMOXOR.W
       </td>
       <td>
        <code>
         amoxor.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子按位异或并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] ^= rs2
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOXOR.D
       </td>
       <td>
        <code>
         amoxor.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子按位异或并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] ^= rs2
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子最大值
       </td>
       <td>
        AMOMAX.W
       </td>
       <td>
        <code>
         amomax.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子有符号最大值并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = max(rd, rs2)
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOMAX.D
       </td>
       <td>
        <code>
         amomax.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子有符号最大值并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = max(rd, rs2)
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子无符号最大值
       </td>
       <td>
        AMOMAXU.W
       </td>
       <td>
        <code>
         amomaxu.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子无符号最大值并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = maxu(rd, rs2)
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOMAXU.D
       </td>
       <td>
        <code>
         amomaxu.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子无符号最大值并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = maxu(rd, rs2)
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子最小值
       </td>
       <td>
        AMOMIN.W
       </td>
       <td>
        <code>
         amomin.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子有符号最小值并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = min(rd, rs2)
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOMIN.D
       </td>
       <td>
        <code>
         amomin.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子有符号最小值并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = min(rd, rs2)
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
      <tr>
       <td>
        原子无符号最小值
       </td>
       <td>
        AMOMINU.W
       </td>
       <td>
        <code>
         amominu.w rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子无符号最小值并返回原值
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = minu(rd, rs2)
        </code>
       </td>
       <td>
        RV32A / RV64A
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        AMOMINU.D
       </td>
       <td>
        <code>
         amominu.d rd, rs2, (rs1)
        </code>
       </td>
       <td>
        原子无符号最小值并返回原值（双字）
       </td>
       <td>
        <code>
         rd = Mem[rs1]; Mem[rs1] = minu(rd, rs2)
        </code>
       </td>
       <td>
        RV64A
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     上面列举了RISC-V指令集，但实际上上面列举的指令集我很多也没用过，是按照spec总结了下，如有错误或者遗漏，还请各位大佬评论区指出。
    </p>
    <p>
     <strong>
      参考
     </strong>
     <br/>
     riscv-spec-20240411.pdf
     <br/>
     <a href="https://www.cnblogs.com/sureZ-learning/p/18402849#3-rvm%E6%8C%87%E4%BB%A4%E9%9B%86" rel="nofollow">
      一起学RISC-V汇编第5讲之常用指令及伪指令列表
     </a>
     <br/>
     <a href="https://blog.csdn.net/m0_52132972/article/details/126574474">
      RISC-V 常用汇编指令
     </a>
    </p>
   </div>
   <link href="./../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="./../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333038333439312f:61727469636c652f64657461696c732f313436313232373131" class_="artid" style="display:none">
 </p>
</div>


