---
layout: post
title: "Java中的try-catch在jvm层面是怎么做的"
date: 2025-03-13 13:34:42 +0800
description: "java中的try-catch通过异常表和栈展开来实现"
keywords: "Java中的try-catch在jvm层面是怎么做的？"
categories: ['未分类']
tags: ['操作系统', 'Springboot', 'Spring', 'Jvm', 'Java']
artid: "146225243"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146225243
    alt: "Java中的try-catch在jvm层面是怎么做的"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146225243
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146225243
cover: https://bing.ee123.net/img/rand?artid=146225243
image: https://bing.ee123.net/img/rand?artid=146225243
img: https://bing.ee123.net/img/rand?artid=146225243
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java中的try-catch在jvm层面是怎么做的？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     简单描述
    </h4>
    <p>
     java中的try-catch通过
     <strong>
      异常表
     </strong>
     和
     <strong>
      栈展开
     </strong>
     来实现
    </p>
    <h4>
     异常表（exception-table）
    </h4>
    <p>
     <strong>
      每个方法的字节码中都有一个异常表，用于记录try-catch块的
     </strong>
     <strong>
      作用范围
     </strong>
     <strong>
      和
     </strong>
     <strong>
      对应的异常处理逻辑
     </strong>
    </p>
    <p>
    </p>
    <p>
     异常表的每个条目包含以下信息：
    </p>
    <p>
     <strong>
      起点，终点，处理代码的位置，捕获异常的类型
     </strong>
    </p>
    <p>
     起点（start_pc）：try块的
     <strong>
      起始指令偏移量
     </strong>
    </p>
    <p>
     终点（end_pc）：try块的
     <strong>
      结束指令偏移量
     </strong>
     （不包含该指令）
    </p>
    <p>
     处理代码位置（handler_pc）：catch块的
     <strong>
      第一条指令偏移量
     </strong>
    </p>
    <p>
     捕获的异常类型（catch_type）：要捕获的异常类（如java/lang/Exception），若为0表示捕获所有异常（finally块）
    </p>
    <p>
    </p>
    <p>
     字节码结构
    </p>
    <pre><code>Exception table:
   start  end  handler  type
   0      10   13       java/io/IOException
   0      10   20       java/lang/Exception</code></pre>
    <hr/>
    <h4>
     异常处理流程
    </h4>
    <p>
     抛出异常，从异常表判断异常是否在处理逻辑内（也就是是否被try-catch{}包围），
    </p>
    <p>
     代码中抛出异常时，JVM会执行以下步骤：
    </p>
    <p>
     <strong>
      创建异常对象
     </strong>
     ：实例化抛出的异常（如
     <code>
      new IOException()
     </code>
     ）
    </p>
    <p>
    </p>
    <p>
     <strong>
      查找异常表
     </strong>
     ：从当前方法的异常表中，按顺序匹配以下条件：
    </p>
    <p>
     异常抛出的位置是否在某个条目的
     <code>
      [start_pc, end_pc)
     </code>
     范围内。
    </p>
    <p>
     抛出的异常是否是
     <code>
      catch_type
     </code>
     的子类（或自身）
    </p>
    <p>
    </p>
    <p>
     <strong>
      跳转到处理代码
     </strong>
     ：
    </p>
    <p>
     若找到匹配条目，跳转到
     <code>
      handler_pc
     </code>
     执行
     <code>
      catch
     </code>
     块
    </p>
    <p>
    </p>
    <p>
     若未找到，触发
     <strong>
      栈展开
     </strong>
     ：弹出当前栈帧，回到调用者方法重复上述过程。
     <strong>
      栈展开
     </strong>
     确保异常沿调用链向上传播，直到被处理或终止线程
    </p>
    <p>
    </p>
    <p>
     <strong>
      未捕获异常
     </strong>
     ：若所有栈帧均未处理异常，线程
     <strong>
      终止并打印堆栈跟踪
     </strong>
    </p>
    <hr/>
    <h4>
     finally块的实现
    </h4>
    <p>
     finally 块的核心是：无论 try 或 catch 块中是否抛出异常或提前返回，
     <strong>
      finally 中的代码必须执行
     </strong>
    </p>
    <p>
     为了实现这一点，JVM 的编译器（如 javac）在生成字节码时，会通过两种机制来确保 finally 的执行
    </p>
    <p>
    </p>
    <p>
     finally块通过两种方式实现：
    </p>
    <p>
     <strong>
      代码复制
     </strong>
     ：编译器将
     <code>
      finally
     </code>
     代码复制到
     <code>
      try
     </code>
     和
     <code>
      catch
     </code>
     块的所有退出路径（包括
     <code>
      return
     </code>
     或异常抛出之后）。
    </p>
    <p>
     <strong>
      异常表条目兜底
     </strong>
     ：若
     <code>
      finally
     </code>
     需要处理异常退出，会生成一个
     <code>
      catch_type=0
     </code>
     的条目，捕获所有异常并执行
     <code>
      finally
     </code>
     代码，之后重新抛出异常
    </p>
    <hr/>
    <p>
     代码复制
    </p>
    <p>
    </p>
    <p>
     编译器会将 finally 块中的代码复制到所有可能的退出路径，包括：
    </p>
    <p>
     try 块正常结束后的退出路径。
    </p>
    <p>
     catch 块处理完异常后的退出路径。
    </p>
    <p>
     try 或 catch 块中的 return、break、continue 语句之前
    </p>
    <p>
    </p>
    <p>
     java代码
    </p>
    <pre><code>public void example() {
    try {
        System.out.println("try");
    } catch (Exception e) {
        System.out.println("catch");
    } finally {
        System.out.println("finally");
    }
}</code></pre>
    <p>
    </p>
    <p>
     编译后的字节码逻辑
    </p>
    <pre><code>// try 块
L0:
    System.out.println("try");
    // 复制 finally 代码到 try 块末尾
    System.out.println("finally");
    return;

// catch 块
L1:
    System.out.println("catch");
    // 复制 finally 代码到 catch 块末尾
    System.out.println("finally");
    return;

// 异常表条目（自动处理异常后的 finally）
Exception table:
    start=L0, end=L0, handler=L1, type=Exception</code></pre>
    <p>
     关键点：
    </p>
    <p>
     <strong>
      finally 的代码会被复制到 try 和 catch 的末尾
     </strong>
     ，确保正常流程下一定会执行
    </p>
    <p>
     如果 try 或 catch 中有 return，编译器会先执行 finally 代码，再执行 return
    </p>
    <hr/>
    <p>
     异常表兜底（处理未捕获的异常）
    </p>
    <p>
     如果 try 或 catch 块中抛出了未被捕获的异常，或者有 throw 语句，JVM 会通过异常表跳转到 finally 代码，执行后再重新抛出异常。
    </p>
    <p>
    </p>
    <p>
     异常表条目
    </p>
    <p>
     编译器会生成一个
     <strong>
      特殊的异常表条目
     </strong>
     ，
     <strong>
      用于捕获所有类型的异常（catch_type=0）
     </strong>
    </p>
    <p>
     确保任何未处理的异常都会先执行 finally，再继续传播异常
    </p>
    <p>
    </p>
    <p>
     java代码
    </p>
    <pre><code>public void example() {
    try {
        throw new IOException();
    } finally {
        System.out.println("finally");
    }
}</code></pre>
    <p>
    </p>
    <p>
     字节码的异常表会生成如下头目
    </p>
    <pre><code>Exception table:
    start=L0, end=L1, handler=L2, type=0  // type=0 表示捕获所有异常</code></pre>
    <p>
     对应的执行流程：
    </p>
    <ol>
     <li>
      <code>
       try
      </code>
      块抛出
      <code>
       IOException
      </code>
      。
     </li>
     <li>
      JVM 查找异常表，发现
      <code>
       type=0
      </code>
      的条目（匹配所有异常）。
     </li>
     <li>
      跳转到
      <code>
       handler=L2
      </code>
      （
      <code>
       finally
      </code>
      代码的位置）执行
      <code>
       System.out.println("finally")
      </code>
      。
     </li>
     <li>
      <strong>
       重新抛出异常
      </strong>
      ，继续栈展开
     </li>
    </ol>
    <p>
    </p>
    <p>
     假设代码中有 try 和 finally，但没有 catch：
    </p>
    <pre><code>try {
    throw new Exception();
} finally {
    System.out.println("finally");
}</code></pre>
    <p>
     执行步骤：
    </p>
    <ol>
     <li>
      <code>
       try
      </code>
      块抛出异常，JVM 创建异常对象。
     </li>
     <li>
      <strong>
       直接查找当前方法的异常表
      </strong>
      ，找到
      <code>
       catch_type=0
      </code>
      的条目，跳转到
      <code>
       finally
      </code>
      代码。
     </li>
     <li>
      执行
      <code>
       finally
      </code>
      块中的代码。
     </li>
     <li>
      <strong>
       重新抛出异常
      </strong>
      ，由外层调用者处理
     </li>
    </ol>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f4c554349415a5a5a2f:61727469636c652f64657461696c732f313436323235323433" class_="artid" style="display:none">
 </p>
</div>


