---
layout: post
title: "leetcode844.比较含退格的字符串"
date: 2025-03-14 14:47:37 +0800
description: "通过设置俩个栈来进行解决，对于碰到#号且栈不为空时，将上一个元素弹出，还有需要注意输入的是字符串，我们把它放置到字符数组内，方便后续操作。在最后俩个for循环时，如果将size直接写入判断语句，随着元素的弹出，size会发生改变，因此需要在外面定义好。两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回。s 会变成 \"c\"，但 t 仍然是 \"b\"。如果对空文本输入退格字符，文本继续为空。s 和 t 都会变成 \"ac\"。s 和 t 都会变成 \"\"。只含有小写字母以及字符。"
keywords: "leetcode844.比较含退格的字符串"
categories: ['Leetcode']
tags: ['算法', '数据结构', '开发语言', 'Leetcode', 'Java']
artid: "146257319"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257319
    alt: "leetcode844.比较含退格的字符串"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257319
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257319
cover: https://bing.ee123.net/img/rand?artid=146257319
image: https://bing.ee123.net/img/rand?artid=146257319
img: https://bing.ee123.net/img/rand?artid=146257319
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     leetcode844.比较含退格的字符串
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     题目：
    </h4>
    <blockquote>
     <p>
      给定
      <code>
       s
      </code>
      和
      <code>
       t
      </code>
      两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回
      <code>
       true
      </code>
      。
      <code>
       #
      </code>
      代表退格字符。
     </p>
     <p>
      <strong>
       注意：
      </strong>
      如果对空文本输入退格字符，文本继续为空。
     </p>
    </blockquote>
    <h4>
     <strong>
      示例 1：
     </strong>
    </h4>
    <blockquote>
     <p>
      <strong>
       输入：
      </strong>
      s = "ab#c", t = "ad#c"
      <br/>
      <strong>
       输出：
      </strong>
      true
      <br/>
      <strong>
       解释：
      </strong>
      s 和 t 都会变成 "ac"。
     </p>
    </blockquote>
    <h4>
     <strong>
      示例 2：
     </strong>
    </h4>
    <blockquote>
     <p>
      <strong>
       输入：
      </strong>
      s = "ab##", t = "c#d#"
      <br/>
      <strong>
       输出：
      </strong>
      true
      <br/>
      <strong>
       解释：
      </strong>
      s 和 t 都会变成 ""。
     </p>
    </blockquote>
    <h4>
     <strong>
      示例 3：
     </strong>
    </h4>
    <blockquote>
     <p>
      <strong>
       输入：
      </strong>
      s = "a#c", t = "b"
      <br/>
      <strong>
       输出：
      </strong>
      false
      <br/>
      <strong>
       解释：
      </strong>
      s 会变成 "c"，但 t 仍然是 "b"。
     </p>
    </blockquote>
    <h4>
     <strong>
      提示：
     </strong>
    </h4>
    <blockquote>
     <ul>
      <li>
       <p>
        <code>
         1 &lt;= s.length, t.length &lt;= 200
        </code>
       </p>
      </li>
      <li>
       <p>
        <code>
         s
        </code>
        和
        <code>
         t
        </code>
        只含有小写字母以及字符
        <code>
         '#'
        </code>
       </p>
      </li>
     </ul>
    </blockquote>
    <h4>
     代码：
    </h4>
    <pre><code class="language-java">class Solution {
    public boolean backspaceCompare(String s, String t) {
        Stack&lt;Character&gt; stack1 = new Stack&lt;&gt;();
        Stack&lt;Character&gt; stack2 = new Stack&lt;&gt;();
        char c1[] = s.toCharArray();
        char c2[] = t.toCharArray();
        for (int i = 0; i &lt; c1.length; i++) {
            if (c1[i] == '#' &amp;&amp; !stack1.isEmpty()) {
                stack1.pop();
            } else if(c1[i]!='#'){
                stack1.push(c1[i]);
            }
        }

        for (int i = 0; i &lt; c2.length; i++) {
            if (c2[i] == '#' &amp;&amp; !stack2.isEmpty()) {
                stack2.pop();
            } else if(c2[i]!='#'){
                stack2.push(c2[i]);
            }
        }

        String res1 = "";
        String res2 = "";

        int s1 = stack1.size();
        int s2 = stack2.size();

        for (int i = 0; i &lt; s1; i++) {
            res1 += stack1.pop();
        }
        for (int i = 0; i &lt; s2; i++) {
            res2 += stack2.pop();
        }
        System.out.println(res1);
        System.out.println(res2);
        return res1.equals(res2);
    }
}</code></pre>
    <h4>
     解释：
    </h4>
    <blockquote>
     <p>
      通过设置俩个栈来进行解决，对于碰到#号且栈不为空时，将上一个元素弹出，还有需要注意输入的是字符串，我们把它放置到字符数组内，方便后续操作。
     </p>
    </blockquote>
    <h4>
     注意：
    </h4>
    <blockquote>
     <p>
      在最后俩个for循环时，如果将size直接写入判断语句，随着元素的弹出，size会发生改变，因此需要在外面定义好。
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f35313636343038342f:61727469636c652f64657461696c732f313436323537333139" class_="artid" style="display:none">
 </p>
</div>


