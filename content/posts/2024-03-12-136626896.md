---
layout: post
title: "elasticsearch篇DSL查询语法"
date: 2024-03-12 14:26:44 +0800
description: "match和multi_match的区别是什么？match：根据一个字段查询multi_match："
keywords: "dsl语法"
categories: ['微服务']
tags: ['搜索引擎', '大数据', 'Elasticsearch']
artid: "136626896"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=136626896
    alt: "elasticsearch篇DSL查询语法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=136626896
featuredImagePreview: https://bing.ee123.net/img/rand?artid=136626896
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     elasticsearch篇：DSL查询语法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1.DSL查询文档
    </h2>
    <p>
     众所周知，elasticsearch的查询依然是基于JSON风格的DSL来实现的。
    </p>
    <h3>
     1.1. DSL查询分类
    </h3>
    <p>
     Elasticsearch提供了基于JSON的DSL（
     <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="nofollow" title="Domain Specific Language">
      Domain Specific Language
     </a>
     ）来定义查询。常见的查询类型包括：
    </p>
    <ul>
     <li>
      查询所有：查询出所有数据，一般测试用，例如： match_all
     </li>
     <li>
      全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：
     </li>
    </ul>
    <p>
     match_query
    </p>
    <p>
     multi_match_query
    </p>
    <ul>
     <li>
      精确查询：根据精确词条值查找数据，一般是查找keyword，数值，日期，boolean等类型字段，例如：
     </li>
    </ul>
    <p>
     ids
    </p>
    <p>
     range
    </p>
    <p>
     term
    </p>
    <ul>
     <li>
      地理（geo）查询：根据经纬度查询，例如
     </li>
    </ul>
    <p>
     geo_distance
    </p>
    <p>
     geo_bounding_box
    </p>
    <ul>
     <li>
      复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件，例如:
     </li>
    </ul>
    <p>
     bool
    </p>
    <p>
     function_score
    </p>
    <p>
     查询的语法基本一致：
    </p>
    <pre><code>GET /indexName/_search
{
    "query": {
        "查询类型": {
          "查询条件": "条件值"
        }
    }
}</code></pre>
    <p>
     我们以查询所有为例，其中：
    </p>
    <ul>
     <li>
      <p>
       查询类型为match_all
      </p>
     </li>
     <li>
      <p>
       没有查询条件
      </p>
     </li>
    </ul>
    <pre><code>GET /indexName/_search
{
    "query" :{
      "match_all":{
        }
    }
}</code></pre>
    <p>
     其它查询无非就是
     <strong>
      查询类型
     </strong>
     、
     <strong>
      查询条件
     </strong>
     的变化。
    </p>
    <h3>
     1.2.全文检索查询
    </h3>
    <h4>
     1.2.1.使用场景
    </h4>
    <p>
     全文检索查询的基本流程如下：
    </p>
    <ul>
     <li>
      <p>
       对用户搜索的内容做分词，得到词条
      </p>
     </li>
     <li>
      <p>
       根据词条去倒排索引库中匹配，得到文档id
      </p>
     </li>
     <li>
      <p>
       根据文档id找到文档，返回给用户
      </p>
     </li>
    </ul>
    <p>
     比较常用的场景包括：
    </p>
    <ul>
     <li>
      <p>
       商城的输入框搜索
      </p>
     </li>
     <li>
      <p>
       百度输入框搜索
      </p>
     </li>
    </ul>
    <p>
     例如京东：
    </p>
    <p>
     ​​
     <img alt="" height="112" src="https://i-blog.csdnimg.cn/blog_migrate/27116985e2e48e17b19e610c31eb0848.png" width="634"/>
    </p>
    <p>
     因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。
    </p>
    <h4>
     1.2.2.基本语法
    </h4>
    <p>
     常见的全文检索查询包括：
    </p>
    <ul>
     <li>
      <p>
       match查询：单字段查询
      </p>
     </li>
     <li>
      <p>
       multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件
      </p>
     </li>
    </ul>
    <p>
     match查询语法如下：
    </p>
    <pre><code>GET /indexName/_search
{
  "query": {
    "match": {
      "FIELD": "TEXT"
    }
  }
}

#举例：
# match查询
GET /hotel/_search
{
  "query": {
    "match": {
      "all": "外滩如家"
    }
  }
}</code></pre>
    <p>
     <img alt="" height="221" src="https://i-blog.csdnimg.cn/blog_migrate/5dc484bf36622a734013487288f71684.png" width="646"/>
    </p>
    <p>
     mulit_match语法如下：
    </p>
    <pre><code>GET /indexName/_search
{
  "query": {
    "multi_match": {
      "query": "TEXT",
      "fields": ["FIELD1", " FIELD12"]
    }
  }
}


#举例
# multi_match查询
GET /hotel/_search
{
  "query": {
    "multi_match": {
      "query": "外滩如家",
      "fields": ["brand","name","business"]
    }
  }
}</code></pre>
    <p>
     <img alt="" height="219" src="https://i-blog.csdnimg.cn/blog_migrate/0a481e093045550108b442757548537a.png" width="350"/>
    </p>
    <p>
     可以看到，两种查询结果是一样的，为什么？
    </p>
    <p>
     因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。
    </p>
    <p>
     但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。
    </p>
    <h4>
     1.2.4.总结
    </h4>
    <p>
     match和multi_match的区别是什么？
    </p>
    <ul>
     <li>
      <p>
       match：根据一个字段查询
      </p>
     </li>
     <li>
      <p>
       multi_match：根据多个字段查询，参与查询字段越多，查询性能越差
      </p>
     </li>
    </ul>
    <h3>
     1.3. 精准查询
    </h3>
    <h4>
     1.3.1.term查询
    </h4>
    <p>
     因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是
     <strong>
      不分词
     </strong>
     的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。
    </p>
    <p>
     语法说明：
    </p>
    <pre><code>// term查询
GET /indexName/_search
{
  "query": {
    "term": {
      "FIELD": {
        "value": "VALUE"
      }
    }
  }
}</code></pre>
    <p>
    </p>
    <p>
     示例：
    </p>
    <p>
     当我搜索的是精确词条时，能正确查询出结果：
    </p>
    <p>
     <img alt="" height="240" src="https://i-blog.csdnimg.cn/blog_migrate/fbafbb8c97fc4adcb49c646578d84003.png" width="656"/>
    </p>
    <p>
     但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：
    </p>
    <p>
     <img alt="" height="231" src="https://i-blog.csdnimg.cn/blog_migrate/007f56bdae88aa2538d7b091958fa02e.png" width="657"/>
    </p>
    <h4>
     1.3.2.range查询
    </h4>
    <p>
     范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。
    </p>
    <p>
     基本语法：
    </p>
    <pre><code>// range查询
GET /indexName/_search
{
  "query": {
    "range": {
      "FIELD": {
        "gte": 10, // 这里的gte代表大于等于，gt则代表大于
        "lte": 20 // lte代表小于等于，lt则代表小于
      }
    }
  }
}</code></pre>
    <p>
     示例：
    </p>
    <p>
     <img alt="" height="193" src="https://i-blog.csdnimg.cn/blog_migrate/81853c5af8cacdb8998025cdb709f6f4.png" width="659"/>
    </p>
    <h4>
     1.3.3.总结
    </h4>
    <p>
     精确查询常见的有哪些？
    </p>
    <ul>
     <li>
      <p>
       term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段
      </p>
     </li>
     <li>
      <p>
       range查询：根据数值范围查询，可以是数值、日期的范围
      </p>
     </li>
    </ul>
    <h3>
     1.4.地理坐标查询
    </h3>
    <p>
     所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：
     <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html" rel="nofollow" title="Geo queries | Elasticsearch Guide [8.12] | Elastic">
      Geo queries | Elasticsearch Guide [8.12] | Elastic
     </a>
    </p>
    <p>
     常见的使用场景包括：
    </p>
    <ul>
     <li>
      <p>
       携程：搜索我附近的酒店
      </p>
     </li>
     <li>
      <p>
       滴滴：搜索我附近的出租车
      </p>
     </li>
     <li>
      <p>
       微信：搜索我附近的人
      </p>
     </li>
    </ul>
    <p>
     附近的酒店：
    </p>
    <p>
     <img alt="" height="382" src="https://i-blog.csdnimg.cn/blog_migrate/828938edf4ca9e1a44fac43efde38378.png" width="363"/>
    </p>
    <h4>
     1.4.1.矩形范围查询
    </h4>
    <p>
     矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：
    </p>
    <p>
     <img alt="" height="176" src="https://i-blog.csdnimg.cn/blog_migrate/027c8778922267a341e8cc093e56f0f5.png" width="331"/>
    </p>
    <p>
     查询时，需要指定矩形的
     <strong>
      左上
     </strong>
     、
     <strong>
      右下
     </strong>
     两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。
    </p>
    <p>
     语法如下：
    </p>
    <pre><code>// geo_bounding_box查询
GET /indexName/_search
{
  "query": {
    "geo_bounding_box": {
      "FIELD": {
        "top_left": { // 左上点
          "lat": 31.1,
          "lon": 121.5
        },
        "bottom_right": { // 右下点
          "lat": 30.9,
          "lon": 121.7
        }
      }
    }
  }
}</code></pre>
    <p>
     这种并不符合“附近的人”这样的需求，所以我们就不做了。
    </p>
    <h4>
     1.4.2.附近查询
    </h4>
    <p>
     附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。
    </p>
    <p>
     换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：
    </p>
    <p>
     <img alt="" height="328" src="https://i-blog.csdnimg.cn/blog_migrate/b0d420c8d1ad10d68d78ed1cd559ab94.png" width="552"/>
    </p>
    <p>
     语法说明：
    </p>
    <pre><code>// geo_distance 查询
GET /indexName/_search
{
  "query": {
    "geo_distance": {
      "distance": "15km", // 半径
      "FIELD": "31.21,121.5" // 圆心
    }
  }
}</code></pre>
    <p>
     示例：
    </p>
    <p>
     我们先搜索陆家嘴附近15km的酒店：
    </p>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/blog_migrate/387891d7c914a22f6377ef262e7ca680.png" width="636"/>
    </p>
    <p>
     发现共有47家酒店。
    </p>
    <p>
    </p>
    <p>
     然后把半径缩短到3公里：
    </p>
    <p>
     <img alt="" height="241" src="https://i-blog.csdnimg.cn/blog_migrate/0d11dd767d51b65294e2fef99249a50e.png" width="663"/>
    </p>
    <p>
     可以发现，搜索到的酒店数量减少到了5家。
    </p>
    <h3>
     1.5.复合查询
    </h3>
    <p>
     复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：
    </p>
    <ul>
     <li>
      <p>
       fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名
      </p>
     </li>
     <li>
      <p>
       bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索
      </p>
     </li>
    </ul>
    <h4>
     1.5.1.相关性算分
    </h4>
    <p>
     当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。
    </p>
    <p>
     例如，我们搜索 "虹桥如家"，结果如下：
    </p>
    <pre><code>[
  {
    "_score" : 17.850193,
    "_source" : {
      "name" : "虹桥如家酒店真不错",
    }
  },
  {
    "_score" : 12.259849,
    "_source" : {
      "name" : "外滩如家酒店真不错",
    }
  },
  {
    "_score" : 11.91091,
    "_source" : {
      "name" : "迪士尼如家酒店真不错",
    }
  }
]</code></pre>
    <p>
     在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：
    </p>
    <p>
     <img alt="" height="236" src="https://i-blog.csdnimg.cn/blog_migrate/893997e210237f0869fad626aae91e7d.png" width="523"/>
    </p>
    <p>
     在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：
    </p>
    <p>
     <img alt="" height="114" src="https://i-blog.csdnimg.cn/blog_migrate/cba7f39a0233f2651744991ae77da709.png" width="488"/>
    </p>
    <p>
     TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：
    </p>
    <p>
     <img alt="" height="403" src="https://i-blog.csdnimg.cn/blog_migrate/0beccd9b6016e090a6ec41defcc4d1f5.png" width="578"/>
    </p>
    <p>
     小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：
    </p>
    <ul>
     <li>
      <p>
       TF-IDF算法
      </p>
     </li>
     <li>
      <p>
       BM25算法，elasticsearch5.1版本后采用的算法
      </p>
     </li>
    </ul>
    <h4>
     1.5.2.算分函数查询
    </h4>
    <p>
     根据相关度打分是比较合理的需求，但
     <strong>
      合理的不一定是产品经理需要
     </strong>
     的。
    </p>
    <p>
     以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：
    </p>
    <p>
     <img alt="" height="274" src="https://i-blog.csdnimg.cn/blog_migrate/65c8a623c63e2834976f6e8e106b9b23.png" width="636"/>
    </p>
    <p>
     要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。
    </p>
    <h5>
     1）语法说明
    </h5>
    <p>
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/blog_migrate/0bb5eb37a5f8e27456df847cc0011005.png" width="622"/>
    </p>
    <p>
     function score 查询中包含四部分内容：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        原始查询
       </strong>
       条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，
       <strong>
        原始算分
       </strong>
       （query score)
      </p>
     </li>
     <li>
      <p>
       <strong>
        过滤条件
       </strong>
       ：filter部分，符合该条件的文档才会重新算分
      </p>
     </li>
     <li>
      <p>
       <strong>
        算分函数
       </strong>
       ：符合filter条件的文档要根据这个函数做运算，得到的
       <strong>
        函数算分
       </strong>
       （function score），有四种函数
      </p>
      <ul>
       <li>
        <p>
         weight：函数结果是常量
        </p>
       </li>
       <li>
        <p>
         field_value_factor：以文档中的某个字段值作为函数结果
        </p>
       </li>
       <li>
        <p>
         random_score：以随机数作为函数结果
        </p>
       </li>
       <li>
        <p>
         script_score：自定义算分函数算法
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        运算模式
       </strong>
       ：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：
      </p>
      <ul>
       <li>
        <p>
         multiply：相乘
        </p>
       </li>
       <li>
        <p>
         replace：用function score替换query score
        </p>
       </li>
       <li>
        <p>
         其它，例如：sum、avg、max、min
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     function score的运行流程如下：
    </p>
    <ul>
     <li>
      <p>
       1）根据
       <strong>
        原始条件
       </strong>
       查询搜索文档，并且计算相关性算分，称为
       <strong>
        原始算分
       </strong>
       （query score）
      </p>
     </li>
     <li>
      <p>
       2）根据
       <strong>
        过滤条件
       </strong>
       ，过滤文档
      </p>
     </li>
     <li>
      <p>
       3）符合
       <strong>
        过滤条件
       </strong>
       的文档，基于
       <strong>
        算分函数
       </strong>
       运算，得到
       <strong>
        函数算分
       </strong>
       （function score）
      </p>
     </li>
     <li>
      <p>
       4）将
       <strong>
        原始算分
       </strong>
       （query score）和
       <strong>
        函数算分
       </strong>
       （function score）基于
       <strong>
        运算模式
       </strong>
       做运算，得到最终结果，作为相关性算分。
      </p>
     </li>
    </ul>
    <p>
     因此，其中的关键点是：
    </p>
    <ul>
     <li>
      <p>
       过滤条件：决定哪些文档的算分被修改
      </p>
     </li>
     <li>
      <p>
       算分函数：决定函数算分的算法
      </p>
     </li>
     <li>
      <p>
       运算模式：决定最终算分结果
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h5>
     2）示例
    </h5>
    <p>
     需求：给“如家”这个品牌的酒店排名靠前一些
    </p>
    <p>
     翻译一下这个需求，转换为之前说的四个要点：
    </p>
    <ul>
     <li>
      <p>
       原始条件：不确定，可以任意变化
      </p>
     </li>
     <li>
      <p>
       过滤条件：brand = "如家"
      </p>
     </li>
     <li>
      <p>
       算分函数：可以简单粗暴，直接给固定的算分结果，weight
      </p>
     </li>
     <li>
      <p>
       运算模式：比如求和
      </p>
     </li>
    </ul>
    <p>
     因此最终的DSL语句如下：
    </p>
    <pre><code>GET /hotel/_search
{
  "query": {
    "function_score": {
      "query": {  .... }, // 原始查询，可以是任意条件
      "functions": [ // 算分函数
        {
          "filter": { // 满足的条件，品牌必须是如家
            "term": {
              "brand": "如家"
            }
          },
          "weight": 2 // 算分权重为2
        }
      ],
      "boost_mode": "sum" // 加权模式，求和
    }
  }
}</code></pre>
    <p>
     测试，在未添加算分函数时，如家得分如下：
    </p>
    <p>
     <img alt="" height="220" src="https://i-blog.csdnimg.cn/blog_migrate/333a9610e17233509f1bf0bdb2431f91.png" width="650"/>
    </p>
    <p>
     添加了算分函数后，如家得分就提升了：
    </p>
    <p>
     <img alt="" height="263" src="https://i-blog.csdnimg.cn/blog_migrate/964357e73da3284f446d30888bf9a8cf.png" width="646"/>
    </p>
    <h5>
     3）小结
    </h5>
    <p>
     function score query定义的三要素是什么？
    </p>
    <ul>
     <li>
      <p>
       过滤条件：哪些文档要加分
      </p>
     </li>
     <li>
      <p>
       算分函数：如何计算function score
      </p>
     </li>
     <li>
      <p>
       加权方式：function score 与 query score如何运算
      </p>
     </li>
    </ul>
    <h4>
     1.5.3.布尔查询
    </h4>
    <p>
     布尔查询是一个或多个查询子句的组合，每一个子句就是一个
     <strong>
      子查询
     </strong>
     。子查询的组合方式有：
    </p>
    <ul>
     <li>
      <p>
       must：必须匹配每个子查询，类似“与”
      </p>
     </li>
     <li>
      <p>
       should：选择性匹配子查询，类似“或”
      </p>
     </li>
     <li>
      <p>
       must_not：必须不匹配，
       <strong>
        不参与算分
       </strong>
       ，类似“非”
      </p>
     </li>
     <li>
      <p>
       filter：必须匹配，
       <strong>
        不参与算分
       </strong>
      </p>
     </li>
    </ul>
    <p>
     比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：
    </p>
    <p>
     <img alt="" height="163" src="https://i-blog.csdnimg.cn/blog_migrate/1b65f51acaa480eed049dd5dd37a84b1.png" width="636"/>
    </p>
    <p>
     每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。
    </p>
    <p>
     需要注意的是，搜索时，参与
     <strong>
      打分的字段越多，查询的性能也越差
     </strong>
     。因此这种多条件查询时，建议这样做：
    </p>
    <ul>
     <li>
      <p>
       搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分
      </p>
     </li>
     <li>
      <p>
       其它过滤条件，采用filter查询。不参与算分
      </p>
     </li>
    </ul>
    <h5>
     1）语法示例：
    </h5>
    <pre><code># Boolean Query查询
GET /hotel/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "city": "上海"
          }
        }
      ],
      "should": [
        {
          "term": {
            "brand": "皇冠假日"
          }
        },
        {
          "term": {
            "brand": "华美达"
          }
        }
      ],
      "must_not": [
        {
          "range": {
            "price": {
              "lte": 500
            }
          }
        }
      ],
      "filter": [
        {
          "range": {
            "score": {
              "gte": 45 
            }
          }
        }
      ]
    }
  }
}</code></pre>
    <h5>
     2）示例
    </h5>
    <p>
     需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。
    </p>
    <p>
     分析：
    </p>
    <ul>
     <li>
      <p>
       名称搜索，属于全文检索查询，应该参与算分。放到must中
      </p>
     </li>
     <li>
      <p>
       价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中
      </p>
     </li>
     <li>
      <p>
       周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中
      </p>
     </li>
    </ul>
    <pre><code>GET /hotel/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match":{
            "name": "如家"
          }
        }
      ],
      "must_not": [
        {
          "range": {
            "price": {
              "gte": 400
            }
          }
        }
      ],
      "filter": [
        {
          "geo_distance": {
            "distance": "10km",
            "location": {
              "lat": 31.21,
              "lon": 121.5
            }
          }
        }
      ]
    }
  }
}
</code></pre>
    <p>
     <img alt="" height="772" src="https://i-blog.csdnimg.cn/blog_migrate/29d77fa1105f3fa0d80d899358c0d55e.png" width="669"/>
    </p>
    <h5>
     3）小结
    </h5>
    <p>
     bool查询有几种逻辑关系？
    </p>
    <ul>
     <li>
      <p>
       must：必须匹配的条件，可以理解为“与”
      </p>
     </li>
     <li>
      <p>
       should：选择性匹配的条件，可以理解为“或”
      </p>
     </li>
     <li>
      <p>
       must_not：必须不匹配的条件，不参与打分
      </p>
     </li>
     <li>
      <p>
       filter：必须匹配的条件，不参与打分
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2>
     2.搜索结果处理
    </h2>
    <p>
     搜索的结果可以按照用户指定的方式去处理或展示。
    </p>
    <h3>
     2.1.排序
    </h3>
    <p>
     elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索
     <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html" rel="nofollow" title="结果排序">
      结果排序
     </a>
     。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。
    </p>
    <h4>
     2.1.1.普通字段排序
    </h4>
    <p>
     keyword、数值、日期类型排序的语法基本一致。
    </p>
    <p>
     <strong>
      语法
     </strong>
     ：
    </p>
    <pre><code>GET /indexName/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "FIELD": "desc"  // 排序字段、排序方式ASC、DESC
    }
  ]
}</code></pre>
    <p>
     排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推
    </p>
    <p>
     <strong>
      示例
     </strong>
     ：
    </p>
    <p>
     需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序
    </p>
    <p>
     <img alt="" height="329" src="https://i-blog.csdnimg.cn/blog_migrate/38e1611f6371d3f2b28c9860d05d8b0c.png" width="641"/>
    </p>
    <h4>
     2.1.2.地理坐标排序
    </h4>
    <p>
     地理坐标排序略有不同。
    </p>
    <p>
     <strong>
      语法说明
     </strong>
     ：
    </p>
    <pre><code>GET /indexName/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "_geo_distance" : {
          "FIELD" : "纬度，经度", // 文档中geo_point类型的字段名、目标坐标点
          "order" : "asc", // 排序方式
          "unit" : "km" // 排序的距离单位
      }
    }
  ]
}</code></pre>
    <p>
     这个查询的含义是：
    </p>
    <ul>
     <li>
      <p>
       指定一个坐标，作为目标点
      </p>
     </li>
     <li>
      <p>
       计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少
      </p>
     </li>
     <li>
      <p>
       根据距离排序
      </p>
     </li>
    </ul>
    <p>
     <strong>
      示例：
     </strong>
    </p>
    <p>
     需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序
    </p>
    <p>
     提示：获取你的位置的经纬度的方式：
     <a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/" rel="nofollow" title="获取鼠标点击经纬度-地图属性-示例中心-JS API 2.0 示例 | 高德地图API">
      获取鼠标点击经纬度-地图属性-示例中心-JS API 2.0 示例 | 高德地图API
     </a>
    </p>
    <p>
     假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店
    </p>
    <p>
     <img alt="" height="223" src="https://i-blog.csdnimg.cn/blog_migrate/08812c9290a0616795bb7d7817ee723c.png" width="647"/>
    </p>
    <h3>
     2.2.分页
    </h3>
    <p>
     elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：
    </p>
    <ul>
     <li>
      <p>
       from：从第几个文档开始
      </p>
     </li>
     <li>
      <p>
       size：总共查询几个文档
      </p>
     </li>
    </ul>
    <p>
     类似于mysql中的
     <code>
      limit ?, ?
     </code>
    </p>
    <h4>
     2.2.1.基本的分页
    </h4>
    <p>
     分页的基本语法如下：
    </p>
    <pre><code>GET /hotel/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0, // 分页开始的位置，默认为0
  "size": 10, // 期望获取的文档总数
  "sort": [
    {"price": "asc"}
  ]
}</code></pre>
    <h4>
     2.2.2.深度分页问题
    </h4>
    <p>
     现在，我要查询990~1000的数据，查询逻辑要这么写：
    </p>
    <pre><code>GET /hotel/_search
{
  "query": {
    "match_all": {}
  },
  "from": 990, // 分页开始的位置，默认为0
  "size": 10, // 期望获取的文档总数
  "sort": [
    {"price": "asc"}
  ]
}</code></pre>
    <p>
     这里是查询990开始的数据，也就是 第990~第1000条 数据。
    </p>
    <p>
     不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="206" src="https://i-blog.csdnimg.cn/blog_migrate/efd624c8d779d5e3b4e0dfd0f364b507.png" width="541"/>
    </p>
    <p>
     查询TOP1000，如果es是单点模式，这并无太大影响。
    </p>
    <p>
     但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。
    </p>
    <p>
     因为节点A的TOP200，在另一个节点可能排到10000名以外了。
    </p>
    <p>
     因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="405" src="https://i-blog.csdnimg.cn/blog_migrate/19fc2318469002c477a104654dff84ce.png" width="625"/>
    </p>
    <p>
     那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？
    </p>
    <p>
     当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。
    </p>
    <p>
     针对深度分页，ES提供了两种解决方案，
     <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html" rel="nofollow" title="官方文档">
      官方文档
     </a>
     ：
    </p>
    <ul>
     <li>
      <p>
       search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。
      </p>
     </li>
     <li>
      <p>
       scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。
      </p>
     </li>
    </ul>
    <h4>
     2.2.3.小结
    </h4>
    <p>
     分页查询的常见实现方案以及优缺点：
    </p>
    <ul>
     <li>
      <p>
       <code>
        from + size
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         优点：支持随机翻页
        </p>
       </li>
       <li>
        <p>
         缺点：深度分页问题，默认查询上限（from + size）是10000
        </p>
       </li>
       <li>
        <p>
         场景：百度、京东、谷歌、淘宝这样的随机翻页搜索
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        after search
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         优点：没有查询上限（单次查询的size不超过10000）
        </p>
       </li>
       <li>
        <p>
         缺点：只能向后逐页查询，不支持随机翻页
        </p>
       </li>
       <li>
        <p>
         场景：没有随机翻页需求的搜索，例如手机向下滚动翻页
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        scroll
       </code>
       ：
      </p>
      <ul>
       <li>
        <p>
         优点：没有查询上限（单次查询的size不超过10000）
        </p>
       </li>
       <li>
        <p>
         缺点：会有额外内存消耗，并且搜索结果是非实时的
        </p>
       </li>
       <li>
        <p>
         场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     2.3.高亮
    </h3>
    <h4>
     2.3.1.高亮原理
    </h4>
    <p>
     什么是高亮显示呢？
    </p>
    <p>
     我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：
    </p>
    <p>
     <img alt="" height="456" src="https://i-blog.csdnimg.cn/blog_migrate/067255613e6be9343965e984f57cce2d.png" width="558"/>
    </p>
    <p>
     高亮显示的实现分为两步：
    </p>
    <ul>
     <li>
      <p>
       1）给文档中的所有关键字都添加一个标签，例如
       <code>
        &lt;em&gt;
       </code>
       标签
      </p>
     </li>
     <li>
      <p>
       2）页面给
       <code>
        &lt;em&gt;
       </code>
       标签编写CSS样式
      </p>
     </li>
    </ul>
    <h4>
     2.3.2.实现高亮
    </h4>
    <p>
     <strong>
      高亮的语法
     </strong>
     ：
    </p>
    <pre><code>GET /hotel/_search
{
  "query": {
    "match": {
      "FIELD": "TEXT" // 查询条件，高亮一定要使用全文检索查询
    }
  },
  "highlight": {
    "fields": { // 指定要高亮的字段
      "FIELD": {
        "pre_tags": "&lt;em&gt;",  // 用来标记高亮字段的前置标签
        "post_tags": "&lt;/em&gt;" // 用来标记高亮字段的后置标签
      }
    }
  }
}</code></pre>
    <p>
     <strong>
      注意：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       高亮是对关键字高亮，因此
       <strong>
        搜索条件必须带有关键字
       </strong>
       ，而不能是范围这样的查询。
      </p>
     </li>
     <li>
      <p>
       默认情况下，
       <strong>
        高亮的字段，必须与搜索指定的字段一致
       </strong>
       ，否则无法高亮
      </p>
     </li>
     <li>
      <p>
       如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false
      </p>
     </li>
    </ul>
    <p>
     <strong>
      示例
     </strong>
     ：
    </p>
    <p>
     <img alt="" height="252" src="https://i-blog.csdnimg.cn/blog_migrate/d833802b2ccb90a7c5971831558fe158.png" width="646"/>
    </p>
    <h3>
     2.4.总结
    </h3>
    <p>
     查询的DSL是一个大的JSON对象，包含下列属性：
    </p>
    <ul>
     <li>
      <p>
       query：查询条件
      </p>
     </li>
     <li>
      <p>
       from和size：分页条件
      </p>
     </li>
     <li>
      <p>
       sort：排序条件
      </p>
     </li>
     <li>
      <p>
       highlight：高亮条件
      </p>
     </li>
    </ul>
    <p>
     示例：
    </p>
    <p>
     <img alt="" height="550" src="https://i-blog.csdnimg.cn/blog_migrate/307ac84fc88e0ac3c8eca04d09c37e20.png" width="539"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f7669706572642f:61727469636c652f64657461696c732f313336363236383936" class_="artid" style="display:none">
 </p>
</div>


