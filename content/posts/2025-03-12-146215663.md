---
layout: post
title: "Android第二次面试总结项目拷打理论篇"
date: 2025-03-12 21:43:34 +0800
description: "LiveData是一种可观察的数据持有者类，它具有生命周期感知能力，这意味着它能遵循其他应用组件（如ActivityFragment）的生命周期。只有处于活跃状态（如STARTED或RESUMED）的观察者才能收到数据更新的通知。ViewModel旨在存储和管理与 UI 相关的数据，并且在配置更改（如屏幕旋转）时保持数据的一致性。它的生命周期比Activity或Fragment更长，直到关联的Activity或Fragment被销毁（对于Activity是调用且不是由于配置更改；对于Fragment是。"
keywords: "Android第二次面试总结（项目拷打理论篇）"
categories: ['未分类']
tags: ['Android']
artid: "146215663"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146215663
    alt: "Android第二次面试总结项目拷打理论篇"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146215663
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146215663
cover: https://bing.ee123.net/img/rand?artid=146215663
image: https://bing.ee123.net/img/rand?artid=146215663
img: https://bing.ee123.net/img/rand?artid=146215663
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android第二次面试总结（项目拷打理论篇）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     （一）理论基础
    </p>
    <p>
     <code>
      LiveData
     </code>
     和
     <code>
      ViewModel
     </code>
     是 Android 架构组件中的重要部分，它们在构建响应式、生命周期感知的 Android 应用程序中发挥着关键作用。下面分别介绍它们的原理。
    </p>
    <h4>
     LiveData 原理
    </h4>
    <h5>
     1. 概述
    </h5>
    <p>
     <code>
      LiveData
     </code>
     是一种可观察的数据持有者类，它具有生命周期感知能力，这意味着它能遵循其他应用组件（如
     <code>
      Activity
     </code>
     、
     <code>
      Fragment
     </code>
     ）的生命周期。只有处于活跃状态（如
     <code>
      STARTED
     </code>
     或
     <code>
      RESUMED
     </code>
     ）的观察者才能收到数据更新的通知。
    </p>
    <h5>
     2. 核心组成部分
    </h5>
    <ul>
     <li>
      <strong>
       <code>
        LiveData
       </code>
       类
      </strong>
      ：作为数据的持有者，它内部维护了一个数据对象和一个观察者列表。
     </li>
     <li>
      <strong>
       <code>
        Observer
       </code>
       接口
      </strong>
      ：定义了一个
      <code>
       onChanged(T t)
      </code>
      方法，当
      <code>
       LiveData
      </code>
      中的数据发生变化时，会调用该方法通知观察者。
     </li>
     <li>
      <strong>
       <code>
        LifecycleOwner
       </code>
       接口
      </strong>
      ：表示具有生命周期的对象，如
      <code>
       Activity
      </code>
      和
      <code>
       Fragment
      </code>
      都实现了该接口。
      <code>
       LiveData
      </code>
      通过
      <code>
       Lifecycle
      </code>
      来感知
      <code>
       LifecycleOwner
      </code>
      的生命周期状态。
     </li>
    </ul>
    <h5>
     3. 工作原理
    </h5>
    <ul>
     <li>
      <strong>
       注册观察者
      </strong>
      ：当调用
      <code>
       LiveData.observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer)
      </code>
      方法时，
      <code>
       LiveData
      </code>
      会将
      <code>
       LifecycleOwner
      </code>
      和
      <code>
       Observer
      </code>
      包装成一个
      <code>
       LifecycleBoundObserver
      </code>
      对象，并将其添加到观察者列表中。同时，
      <code>
       LifecycleBoundObserver
      </code>
      会监听
      <code>
       LifecycleOwner
      </code>
      的生命周期变化。
     </li>
    </ul>
    <pre><code class="language-java">// Java 示例
LiveData&lt;String&gt; liveData = new MutableLiveData&lt;&gt;();
observe(lifecycleOwner, new Observer&lt;String&gt;() {
    @Override
    public void onChanged(String s) {
        // 处理数据变化
    }
});</code></pre>
    <ul>
     <li>
      <strong>
       生命周期感知
      </strong>
      ：
      <code>
       LifecycleBoundObserver
      </code>
      实现了
      <code>
       LifecycleEventObserver
      </code>
      接口，当
      <code>
       LifecycleOwner
      </code>
      的生命周期状态发生变化时，
      <code>
       LifecycleBoundObserver
      </code>
      会收到相应的事件通知。如果
      <code>
       LifecycleOwner
      </code>
      进入活跃状态（
      <code>
       STARTED
      </code>
      或
      <code>
       RESUMED
      </code>
      ），
      <code>
       LiveData
      </code>
      会将最新的数据发送给该观察者；如果
      <code>
       LifecycleOwner
      </code>
      进入销毁状态（
      <code>
       DESTROYED
      </code>
      ），
      <code>
       LiveData
      </code>
      会自动移除该观察者，以避免内存泄漏。
     </li>
     <li>
      <strong>
       数据更新
      </strong>
      ：当调用
      <code>
       LiveData.setValue(T value)
      </code>
      或
      <code>
       LiveData.postValue(T value)
      </code>
      方法更新数据时，
      <code>
       LiveData
      </code>
      会检查所有观察者的生命周期状态，只有处于活跃状态的观察者才会收到
      <code>
       onChanged
      </code>
      方法的调用。
     </li>
    </ul>
    <h4>
     ViewModel 原理
    </h4>
    <h5>
     1. 概述
    </h5>
    <p>
     <code>
      ViewModel
     </code>
     旨在存储和管理与 UI 相关的数据，并且在配置更改（如屏幕旋转）时保持数据的一致性。它的生命周期比
     <code>
      Activity
     </code>
     或
     <code>
      Fragment
     </code>
     更长，直到关联的
     <code>
      Activity
     </code>
     或
     <code>
      Fragment
     </code>
     被销毁（对于
     <code>
      Activity
     </code>
     是
     <code>
      onDestroy()
     </code>
     调用且不是由于配置更改；对于
     <code>
      Fragment
     </code>
     是
     <code>
      onDestroy()
     </code>
     调用）。
    </p>
    <h5>
     2. 核心组成部分
    </h5>
    <ul>
     <li>
      <strong>
       <code>
        ViewModel
       </code>
       类
      </strong>
      ：开发者自定义的
      <code>
       ViewModel
      </code>
      类需要继承自
      <code>
       ViewModel
      </code>
      类，用于存储和管理与 UI 相关的数据。
     </li>
     <li>
      <strong>
       <code>
        ViewModelProvider
       </code>
       类
      </strong>
      ：负责创建和管理
      <code>
       ViewModel
      </code>
      实例。它使用
      <code>
       ViewModelStore
      </code>
      来存储
      <code>
       ViewModel
      </code>
      实例。
     </li>
     <li>
      <strong>
       <code>
        ViewModelStore
       </code>
       类
      </strong>
      ：是一个简单的键值对存储结构，用于存储
      <code>
       ViewModel
      </code>
      实例。每个
      <code>
       Activity
      </code>
      和
      <code>
       Fragment
      </code>
      都有一个对应的
      <code>
       ViewModelStore
      </code>
      。
     </li>
    </ul>
    <h5>
     3. 工作原理
    </h5>
    <ul>
     <li>
      <strong>
       创建
       <code>
        ViewModel
       </code>
       实例
      </strong>
      ：当调用
      <code>
       ViewModelProvider(owner).get(MyViewModel.class)
      </code>
      方法时，
      <code>
       ViewModelProvider
      </code>
      会首先检查
      <code>
       ViewModelStore
      </code>
      中是否已经存在指定类型的
      <code>
       ViewModel
      </code>
      实例。如果存在，则直接返回该实例；如果不存在，则使用
      <code>
       ViewModelProvider.Factory
      </code>
      创建一个新的
      <code>
       ViewModel
      </code>
      实例，并将其存储在
      <code>
       ViewModelStore
      </code>
      中。
     </li>
    </ul>
    <pre><code class="language-java">// Java 示例
ViewModelProvider viewModelProvider = new ViewModelProvider(this);
MyViewModel viewModel = viewModelProvider.get(MyViewModel.class);</code></pre>
    <ul>
     <li>
      <strong>
       配置更改时数据保留
      </strong>
      ：当发生配置更改（如屏幕旋转）时，
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      会被销毁并重新创建，但
      <code>
       ViewModelStore
      </code>
      会被保留。因此，重新创建的
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      可以从
      <code>
       ViewModelStore
      </code>
      中获取之前的
      <code>
       ViewModel
      </code>
      实例，从而保持数据的一致性。
     </li>
     <li>
      <strong>
       生命周期管理
      </strong>
      ：当
      <code>
       Activity
      </code>
      或
      <code>
       Fragment
      </code>
      被销毁（不是由于配置更改）时，
      <code>
       ViewModelStore
      </code>
      会调用
      <code>
       clear()
      </code>
      方法，该方法会遍历所有存储的
      <code>
       ViewModel
      </code>
      实例，并调用它们的
      <code>
       onCleared()
      </code>
      方法，以便进行资源释放。
     </li>
    </ul>
    <p>
     <code>
      LiveData
     </code>
     是具有生命周期感知能力的数据持有者，通过监听
     <code>
      LifecycleOwner
     </code>
     状态更新活跃观察者，
     <code>
      ViewModel
     </code>
     借助
     <code>
      ViewModelProvider
     </code>
     和
     <code>
      ViewModelStore
     </code>
     存储管理 UI 数据，在配置更改时保留数据并在关联组件非配置更改销毁时清理资源。
    </p>
    <p>
     下一阶段
    </p>
    <p>
     Room 是 Android 官方提供的一个 SQLite 对象映射库，用于在 Android 应用中简化数据库操作，WorkManager 是 Android 架构组件之一，用于在应用中调度和管理后台任务。
    </p>
    <p>
     Room 工作原理
    </p>
    <ul>
     <li>
      <strong>
       抽象层封装
      </strong>
      ：Room 提供了一个抽象层，将 SQLite 数据库的操作抽象成 Java 或 Kotlin 接口和注解。开发者可以通过定义实体类（
      <code>
       @Entity
      </code>
      ）、数据访问对象（
      <code>
       @Dao
      </code>
      ）和数据库类（
      <code>
       @Database
      </code>
      ）来描述数据库结构和操作。
     </li>
     <li>
      <strong>
       编译时处理
      </strong>
      ：在编译时，Room 会根据开发者定义的注解生成相应的 SQLite 语句和实现代码。这样可以在编译时发现数据库操作中的错误，提高开发效率和代码的健壮性。
     </li>
     <li>
      <strong>
       线程管理
      </strong>
      ：Room 默认不允许在主线程中执行数据库操作，因为数据库操作通常是耗时的，可能会导致 UI 卡顿。因此，Room 会将数据库操作放在后台线程中执行。
     </li>
    </ul>
    <p>
     <strong>
      定义实体类
     </strong>
     ：
    </p>
    <pre><code class="language-Kotlin">import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val age: Int
)</code></pre>
    <p>
     <strong>
      定义数据访问对象（DAO）
     </strong>
     ：
    </p>
    <pre><code class="language-Kotlin">import androidx.room.Dao
import androidx.room.Insert

@Dao
interface UserDao {
    @Insert
    suspend fun insertUser(user: User)
}</code></pre>
    <p>
     <strong>
      定义数据库类
     </strong>
     ：
    </p>
    <pre><code class="language-Kotlin">import androidx.room.Database
import androidx.room.RoomDatabase

@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}</code></pre>
    <h5>
     WorkManager 工作原理
    </h5>
    <ul>
     <li>
      <strong>
       任务调度
      </strong>
      ：WorkManager 会根据任务的约束条件（如网络连接、电池状态等）和设备的当前状态来决定何时执行任务。它会尽量在设备处于空闲状态时执行任务，以减少对用户体验的影响。
     </li>
     <li>
      <strong>
       任务持久化
      </strong>
      ：WorkManager 会将任务信息持久化到本地数据库中，即使应用被杀死或设备重启，任务信息也不会丢失。当设备满足任务的约束条件时，WorkManager 会重新调度任务执行。
     </li>
     <li>
      <strong>
       生命周期管理
      </strong>
      ：WorkManager 会自动处理任务的生命周期，包括任务的执行、重试和取消等操作。它会根据任务的状态（如运行中、已完成、失败等）更新任务信息。
     </li>
    </ul>
    <p>
     创建 WorkManager 任务
    </p>
    <pre><code class="language-Kotlin">import android.content.Context
import androidx.work.Worker
import androidx.work.WorkerParameters
import kotlinx.coroutines.runBlocking

class InsertUserWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result {
        val database = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java,
            "app-database"
        ).build()
        val userDao = database.userDao()

        val user = User(name = "John", age = 30)
        runBlocking {
            userDao.insertUser(user)
        }

        return Result.success()
    }
}</code></pre>
    <p>
     调度 WorkManager 任务
    </p>
    <pre><code class="language-Kotlin">import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.work.OneTimeWorkRequest
import androidx.work.WorkManager

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val workRequest = OneTimeWorkRequest.Builder(InsertUserWorker::class.java).build()
        WorkManager.getInstance(this).enqueue(workRequest)
    }
}</code></pre>
    <h5>
     Room + WorkManager 协同工作原理
    </h5>
    <ul>
     <li>
      <strong>
       数据交互
      </strong>
      ：WorkManager 可以在后台任务中执行 Room 数据库操作，如插入、查询、更新和删除数据。这样可以避免在主线程中执行耗时的数据库操作，提高应用的性能和响应速度。
     </li>
     <li>
      <strong>
       任务调度
      </strong>
      ：当应用需要在特定条件下执行数据库操作时，可以使用 WorkManager 来调度这些任务。例如，当设备连接到网络时，执行数据同步任务，将本地数据库中的数据上传到服务器。
     </li>
     <li>
      <strong>
       数据一致性
      </strong>
      ：由于 WorkManager 会保证任务的执行，即使应用在任务执行过程中被杀死或设备重启，任务也会在合适的时机继续执行。这样可以确保数据库操作的完整性和数据的一致性。
     </li>
    </ul>
    <p>
     总结：
    </p>
    <p>
     Room 作为 Android 的 SQLite 对象映射库，在编译时根据注解生成数据库操作代码并管理线程，WorkManager 依据任务约束和设备状态调度持久化的后台任务，二者结合时 WorkManager 可在后台任务里执行 Room 的数据库操作，保障数据一致性，实现时先添加依赖，再定义 Room 数据库，创建 WorkManager 任务，最后调度任务执行。
    </p>
    <p>
     下一篇我将讲述面试中我被项目拷打到的点！！！
    </p>
    <p>
     感谢观看！！！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303332393531372f:61727469636c652f64657461696c732f313436323135363633" class_="artid" style="display:none">
 </p>
</div>


