---
layout: post
title: "C的委托Action"
date: 2025-03-16 16:34:33 +0800
description: "C#的委托Action"
keywords: "C#的委托Action"
categories: ['未分类']
tags: ['服务器', 'Java', 'C']
artid: "146297146"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146297146
    alt: "C的委托Action"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146297146
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146297146
cover: https://bing.ee123.net/img/rand?artid=146297146
image: https://bing.ee123.net/img/rand?artid=146297146
img: https://bing.ee123.net/img/rand?artid=146297146
---

# C#的委托Action

在 C# 中，`Action` 是一个预定义的委托类型，它位于 `System` 命名空间下。下面详细介绍它的作用和使用方法。

#### 作用

`Action` 委托的主要作用是封装一个方法，这个方法没有返回值（即返回类型为
`void`）。它提供了一种简洁的方式来传递方法作为参数，从而实现代码的复用和增强代码的灵活性。使用 `Action`
可以让你将一段代码逻辑作为参数传递给其他方法，使得这些方法可以在合适的时机执行这段代码。

#### 不同重载形式

`Action` 有多种重载形式，主要区别在于参数的数量：

  * `Action`：封装一个不接受任何参数且不返回值的方法。
  * `Action<T>`：封装一个接受一个参数且不返回值的方法，其中 `T` 是参数的类型。
  * `Action<T1, T2>`：封装一个接受两个参数且不返回值的方法，`T1` 和 `T2` 分别是两个参数的类型。
  * 以此类推，最多可以有 16 个参数，即 `Action<T1, T2, ..., T16>`。

#### 使用方法

##### 1\. 使用 `Action`（无参数）

    
    
    using System;
    
    class Program
    {
        static void Main()
        {
            // 定义一个 Action 委托实例，指向一个无参数的方法
            Action printMessage = PrintHello;
    
            // 调用 Action 委托
            printMessage();
        }
    
        static void PrintHello()
        {
            Console.WriteLine("Hello, World!");
        }
    }
    

在上述代码中，我们定义了一个 `Action` 委托实例 `printMessage`，它指向了 `PrintHello` 方法。然后通过调用
`printMessage()` 来执行 `PrintHello` 方法。

##### 2\. 使用 `Action<T>`（一个参数）

    
    
    using System;
    
    class Program
    {
        static void Main()
        {
            // 定义一个 Action<int> 委托实例，指向一个接受一个 int 类型参数的方法
            Action<int> printNumber = PrintValue;
    
            // 调用 Action 委托并传递参数
            printNumber(42);
        }
    
        static void PrintValue(int number)
        {
            Console.WriteLine($"The number is: {number}");
        }
    }
    

这里我们使用了 `Action<int>` 委托，它接受一个 `int` 类型的参数。`printNumber` 委托指向了 `PrintValue`
方法，调用时传递了一个整数参数。

##### 3\. 使用匿名方法

    
    
    using System;
    
    class Program
    {
        static void Main()
        {
            // 使用匿名方法创建 Action 委托实例
            Action showMessage = delegate ()
            {
                Console.WriteLine("This is an anonymous method.");
            };
    
            // 调用 Action 委托
            showMessage();
        }
    }
    

在这个例子中，我们使用匿名方法创建了一个 `Action` 委托实例，匿名方法没有参数，并且直接在创建委托时定义了要执行的代码。

##### 4\. 使用 Lambda 表达式

    
    
    using System;
    
    class Program
    {
        static void Main()
        {
            // 使用 Lambda 表达式创建 Action<int> 委托实例
            Action<int> squareAndPrint = num =>
            {
                int result = num * num;
                Console.WriteLine($"The square of {num} is: {result}");
            };
    
            // 调用 Action 委托
            squareAndPrint(5);
        }
    }
    

这里我们使用 Lambda 表达式创建了一个 `Action<int>` 委托实例
`squareAndPrint`，它接受一个整数参数，计算该参数的平方并输出结果。

##### 5\. 将 `Action` 作为参数传递给其他方法

    
    
    using System;
    
    class Program
    {
        static void Main()
        {
            // 定义一个 Action 委托实例
            Action printInfo = () => Console.WriteLine("This is some information.");
    
            // 调用 ExecuteAction 方法并传递 Action 委托
            ExecuteAction(printInfo);
        }
    
        static void ExecuteAction(Action action)
        {
            // 在方法内部调用传递进来的 Action 委托
            action();
        }
    }
    

在这个例子中，我们定义了一个 `ExecuteAction` 方法，它接受一个 `Action` 委托作为参数，并在方法内部调用这个委托。这样可以让
`ExecuteAction` 方法在不同的场景下执行不同的代码逻辑。



