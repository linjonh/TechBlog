---
layout: post
title: "Python教程三类对象闭包装饰器类型注解MRO"
date: 2025-03-15 23:33:38 +0800
description: "本文是Python初学者必会的第三部分，详细介绍了类、对象、类型注解、闭包、装饰器、MRO等知识。"
keywords: "Python教程(三)：类&对象、闭包、装饰器、类型注解、MRO"
categories: ['Python']
tags: ['开发语言', 'Python']
artid: "146287567"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146287567
    alt: "Python教程三类对象闭包装饰器类型注解MRO"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146287567
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146287567
cover: https://bing.ee123.net/img/rand?artid=146287567
image: https://bing.ee123.net/img/rand?artid=146287567
img: https://bing.ee123.net/img/rand?artid=146287567
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Python教程(三)：类&amp;对象、闭包、装饰器、类型注解、MRO
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="Python_0">
     </a>
     Python总结（三）
    </h2>
    <p>
     <strong>
      <font color="red">
       本系列其他教程：
      </font>
     </strong>
    </p>
    <p>
     <a href="https://blog.csdn.net/weixin_49343190/article/details/146082392">
      Python教程(一)：基本语法、流程控制、数据容器
     </a>
     <br/>
     <a href="https://blog.csdn.net/weixin_49343190/article/details/146112661">
      Python教程(二)：函数、异常、模块&amp;包、文件读取、常用模块
     </a>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="_7">
     </a>
     一、类&amp;对象
    </h3>
    <p>
     使用
     <code>
      class
     </code>
     关键字来定义类，通过
     <code>
      对象=类名称()
     </code>
     来创建对象。
    </p>
    <ul>
     <li>
      对象也像变量一样，不用声明类型。
     </li>
     <li>
      创建对象的写法就像调用 “类函数” 一样。
     </li>
    </ul>
    <h4>
     <a id="11__14">
     </a>
     1.1 成员方法
    </h4>
    <ul>
     <li>
      类中定义的成员方法
      <font color="red">
       必须要有一个
      </font>
      形参
      <code>
       self
      </code>
      ，且必须放在所有参数的第一位。
      <ul>
       <li>
        self 表示类对象自身的意思，
        <font color="orange">
         在成员方法内想要访问成员变量必须使用 self 来访问。
        </font>
       </li>
       <li>
        <font color="cornflowerblue">
         使用类对象调用成员方法的时候，可以当 self 参数不存在。
        </font>
        <ul>
         <li>
          当使用类对象调用成员方法时，self 会自动被 Python 传入。
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-python"><span class="token comment"># 定义类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token comment"># 成员变量</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token comment"># 成员方法，必须要有self参数</span>
    <span class="token keyword">def</span> <span class="token function">myMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 通过self来访问成员变量</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"大家好，我叫</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">，我的地址是</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>address<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        
<span class="token comment"># 创建对象</span>
s1 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 定义成员变量值</span>
s1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jay'</span>
<span class="token comment"># 调用成员方法（当作self参数不存在）</span>
s1<span class="token punctuation">.</span>myMethod<span class="token punctuation">(</span><span class="token string">'Taiwan'</span><span class="token punctuation">)</span> <span class="token comment"># 大家好，我叫Jay，我的地址是Taiwan</span>
</code></pre>
    <h4>
     <a id="12__42">
     </a>
     1.2 构造方法
    </h4>
    <ul>
     <li>
      构造方法在创建类对象的时候会自动调用。
      <ul>
       <li>
        Python中构造方法的名称固定为
        <code>
         __init__()
        </code>
        ，前后各两个下划线。
       </li>
       <li>
        如果自己不定义构造方法，默认会有一个空参的构造方法；如果自己定义了构造方法，则默认的空参构造方法会失效。
       </li>
      </ul>
     </li>
     <li>
      构造方法也属于成员方法，也必须有 self 参数。
     </li>
     <li>
      经常用构造方法在创建对象的时候给成员变量赋值。
      <ul>
       <li>
        以下代码在类中并没有定义三个属性而构造方法直接使用了，下面会解释。
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>

    <span class="token comment"># 构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age
        self<span class="token punctuation">.</span>address <span class="token operator">=</span> address

    <span class="token keyword">def</span> <span class="token function">myInformation</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>age<span class="token punctuation">,</span> self<span class="token punctuation">.</span>address<span class="token punctuation">)</span>

<span class="token comment"># 创建对象自动调用构造方法，self当作不存在</span>
stu1 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Jay'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'Taiwan'</span><span class="token punctuation">)</span>
stu1<span class="token punctuation">.</span>myInformation<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># Jay 30 Taiwan</span>
</code></pre>
    <h4>
     <a id="13__71">
     </a>
     1.3 类属性&amp;类方法&amp;静态方法
    </h4>
    <ul>
     <li>
      <p>
       类属性：
      </p>
      <ul>
       <li>
        对象是从类创造的，它们的属性和方法是各个对象独有的，互相不能共享。
       </li>
       <li>
        而类也有属性和方法，且
        <font color="orange">
         它们可以和类创建的所有对象共享
        </font>
        ，并且类本身不用创建对象也能访问。
       </li>
       <li>
        以下代码定义了类属性，而不是对象属性：
        <ul>
         <li>
          访问类属性要使用类名，而不是self，self表示对象。
         </li>
        </ul>
       </li>
      </ul>
      <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token comment"># 以下都是类属性</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>
    age <span class="token operator">=</span> <span class="token boolean">None</span>
    count <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 访问类属性要使用类名，而不是self，self表示对象</span>
        Student<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment"># 0</span>
stu1 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment"># 1</span>
stu2 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu2<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment"># 2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment"># 2</span>
<span class="token comment"># 可以发现所有对象和类本身都共享类属性count</span>
</code></pre>
     </li>
     <li>
      <p>
       对象属性：
      </p>
      <ul>
       <li>
        使用 self 定义在
        <code>
         __init__
        </code>
        构造方法中，每个对象独有。
       </li>
       <li>
        以下代码定义了对象属性，而不是类属性：
        <ul>
         <li>
          访问对象属性要使用self，而不是类名。
         </li>
        </ul>
       </li>
      </ul>
      <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age
        self<span class="token punctuation">.</span>address <span class="token operator">=</span> address
</code></pre>
      <ul>
       <li>
        <font color="red">
         注意：
        </font>
        定义了对象属性后一般不会再定义同名的类属性，这也是为什么第1.2节代码中没有定义类属性的原因。
       </li>
      </ul>
     </li>
     <li>
      <p>
       类方法：
      </p>
      <ul>
       <li>
        类方法也不需要创建对象，通过类名就可以访问，通过对象也可以访问。
       </li>
       <li>
        使用
        <code>
         @classmethod
        </code>
        装饰器定义，第一个参数是
        <code>
         cls
        </code>
        ，而不是
        <code>
         self
        </code>
        ，
        <code>
         cls
        </code>
        表示类本身而不是对象本身，类方法中访问类中的其他
        <font color="red">
         类方法
        </font>
        和
        <font color="red">
         类属性
        </font>
        必须使用
        <code>
         cls
        </code>
        。
       </li>
      </ul>
      <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>
    <span class="token comment"># 类属性</span>
    class_attribute <span class="token operator">=</span> <span class="token number">2</span>

    <span class="token decorator annotation punctuation">@classmethod</span>
    <span class="token keyword">def</span> <span class="token function">class_method</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 类方法通过cls访问类属性</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>class_attribute

<span class="token comment"># 调用类方法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span>class_method<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 2</span>

<span class="token comment"># 也可以通过实例调用类方法，但效果相同</span>
obj <span class="token operator">=</span> MyClass<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>class_method<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 2</span>
</code></pre>
     </li>
     <li>
      <p>
       对象方法：
      </p>
      <ul>
       <li>
        定义在类中，第一个参数是
        <code>
         self
        </code>
        ，可以访问对象属性。
       </li>
      </ul>
     </li>
     <li>
      <p>
       静态方法：
      </p>
      <ul>
       <li>
        静态方法通过
        <code>
         @staticmethod
        </code>
        装饰器在类中定义。
       </li>
       <li>
        静态方法不使用
        <code>
         cls
        </code>
        或
        <code>
         self
        </code>
        作为第一个参数。
       </li>
       <li>
        静态方法类和对象都可以访问。
       </li>
       <li>
        静态方法用于实现一些与类相关的功能，但在实现过程中
        <font color="red">
         不需要访问或修改类或对象的成员
        </font>
        <font color="orange">
         （不使用cls、self参数也没法访问）
        </font>
        ，一般只是用来做与本类相关的一些逻辑运算。
       </li>
      </ul>
      <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">static_method</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2

<span class="token comment"># 调用静态方法</span>
result <span class="token operator">=</span> MyClass<span class="token punctuation">.</span>static_method<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment"># 输出: 15</span>

<span class="token comment"># 也可以通过实例调用静态方法，但效果相同</span>
obj <span class="token operator">=</span> MyClass<span class="token punctuation">(</span><span class="token punctuation">)</span>
result <span class="token operator">=</span> obj<span class="token punctuation">.</span>static_method<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment"># 输出: 15</span>
</code></pre>
     </li>
    </ul>
    <p>
     <strong>
      综合案例：
     </strong>
    </p>
    <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">:</span>
    <span class="token comment"># 类属性</span>
    wheels <span class="token operator">=</span> <span class="token number">4</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> brand<span class="token punctuation">,</span> model<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 对象属性</span>
        self<span class="token punctuation">.</span>brand <span class="token operator">=</span> brand
        self<span class="token punctuation">.</span>model <span class="token operator">=</span> model
        self<span class="token punctuation">.</span>year <span class="token operator">=</span> year

    <span class="token comment"># 类方法</span>
    <span class="token decorator annotation punctuation">@classmethod</span>
    <span class="token keyword">def</span> <span class="token function">is_motor_vehicle</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>wheels <span class="token operator">==</span> <span class="token number">4</span>

    <span class="token comment"># 对象方法</span>
    <span class="token keyword">def</span> <span class="token function">car_details</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>brand<span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>model<span class="token punctuation">}</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>year<span class="token punctuation">}</span></span><span class="token string">)"</span></span>

    <span class="token comment"># 静态方法</span>
    <span class="token comment"># 不访问类或对象中的任何成员</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">calculate_mileage</span><span class="token punctuation">(</span>distance<span class="token punctuation">,</span> fuel_used<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> distance <span class="token operator">/</span> fuel_used

<span class="token comment"># 创建实例</span>
car1 <span class="token operator">=</span> Car<span class="token punctuation">(</span><span class="token string">"Toyota"</span><span class="token punctuation">,</span> <span class="token string">"Camry"</span><span class="token punctuation">,</span> <span class="token number">2020</span><span class="token punctuation">)</span>
car2 <span class="token operator">=</span> Car<span class="token punctuation">(</span><span class="token string">"Honda"</span><span class="token punctuation">,</span> <span class="token string">"Accord"</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">)</span>

<span class="token comment"># 调用对象方法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>car1<span class="token punctuation">.</span>car_details<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: Toyota Camry (2020)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>car2<span class="token punctuation">.</span>car_details<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: Honda Accord (2019)</span>

<span class="token comment"># 调用类方法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span>is_motor_vehicle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: True</span>

<span class="token comment"># 调用静态方法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span>calculate_mileage<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 20.0</span>

<span class="token comment"># 访问类属性</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span>wheels<span class="token punctuation">)</span>  <span class="token comment"># 输出: 4</span>

<span class="token comment"># 访问对象属性</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>car1<span class="token punctuation">.</span>brand<span class="token punctuation">)</span>  <span class="token comment"># 输出: Toyota</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>car2<span class="token punctuation">.</span>model<span class="token punctuation">)</span>  <span class="token comment"># 输出: Accord</span>
</code></pre>
    <h4>
     <a id="14__220">
     </a>
     1.4 魔术方法
    </h4>
    <p>
     Python内置的
     <font color="orange">
      对象方法
     </font>
     称为魔术方法（第一个参数是self）：
    </p>
    <img src="https://i-blog.csdnimg.cn/direct/fc3efc5d9b2b48cdbcbc9744623c6976.png" width="60%">
     <p>
      <strong>
       <code>
        __str__
       </code>
      </strong>
     </p>
     <ul>
      <li>
       用于控制输出对象的时候输出的内容，而不是输出没什么用的内存地址。
      </li>
      <li>
       该方法
       <font color="orange">
        必须返回一个字符串
       </font>
       ，这个返回的字符串就是打印对象时输出的内容。
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token comment"># 没有定义__str__魔术方法</span>
<span class="token keyword">class</span> <span class="token class-name">Student1</span><span class="token punctuation">:</span>
     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
         self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
         self<span class="token punctuation">.</span>age <span class="token operator">=</span> age

stu1 <span class="token operator">=</span> Student1<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu1<span class="token punctuation">)</span> <span class="token comment"># &lt;__main__.Student object at 0x0000016A8BDE5810&gt;</span>

<span class="token comment"># 使用__str__魔术方法</span>
<span class="token keyword">class</span> <span class="token class-name">Student2</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age

    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>self<span class="token punctuation">.</span>age<span class="token punctuation">}</span></span><span class="token string">'</span></span>

stu2 <span class="token operator">=</span> Student2<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token comment"># 输出魔术方法返回的内容</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu2<span class="token punctuation">)</span> <span class="token comment"># Jack 12</span>
</code></pre>
     <p>
      <strong>
       <code>
        __lt__
       </code>
      </strong>
     </p>
     <ul>
      <li>
       直接进行对象的比较是会报错的，该方法用于支持对象之间的比较。
      </li>
      <li>
       该方法传入的第二个参数
       <code>
        other
       </code>
       指的是另一个参与比较的对象，而
       <code>
        self
       </code>
       参数指的是对象本身。
      </li>
      <li>
       该方法的返回值是 True 或 False。
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Student1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age

    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>age

stu1 <span class="token operator">=</span> Student1<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
stu2 <span class="token operator">=</span> Student1<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>
<span class="token comment"># stu2对应方法中的other参数</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu1 <span class="token operator">&lt;</span> stu2<span class="token punctuation">)</span> <span class="token comment"># True</span>
</code></pre>
     <p>
      <strong>
       其他魔术方法：
      </strong>
     </p>
     <ul>
      <li>
       <code>
        __le__
       </code>
       ：用于支持对象之间进行比较的
       <code>
        &lt;=
       </code>
       和
       <code>
        &gt;=
       </code>
       两种运算符。
       <ul>
        <li>
         用法和
         <code>
          __lt__
         </code>
         一模一样。
        </li>
       </ul>
      </li>
      <li>
       <code>
        __eq__
       </code>
       ：用于支持对象之间进行比较的
       <code>
        ==
       </code>
       运算符。
       <ul>
        <li>
         用法和
         <code>
          __lt__
         </code>
         一模一样。
        </li>
       </ul>
      </li>
     </ul>
     <h4>
      <a id="15__289">
      </a>
      1.5 私有成员
     </h4>
     <ul>
      <li>
       私有成员不能被类对象访问和使用。
      </li>
      <li>
       私有成员能被类中的其他成员访问和使用。
      </li>
      <li>
       私有成员的定义只需要在方法或变量名之前加
       <code>
        __
       </code>
       两个下划线即可。
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Student1</span><span class="token punctuation">:</span>
	<span class="token comment">#成员变量也可以有默认值</span>
    __address <span class="token operator">=</span> <span class="token string">'北京'</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age

    <span class="token keyword">def</span> <span class="token function">myAddress</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 访问私有成员</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__address

stu1 <span class="token operator">=</span> Student1<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>__address<span class="token punctuation">)</span> <span class="token comment"># 对象访问私有成员会报错</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>myAddress<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 北京</span>
</code></pre>
     <h4>
      <a id="16__315">
      </a>
      1.6 继承
     </h4>
     <h5>
      <a id="161__317">
      </a>
      1.6.1 单继承&amp;多继承
     </h5>
     <ul>
      <li>
       继承表示子类从父类继承成员变量和方法
       <font color="orange">
        （不含私有）
       </font>
       ，然后子类拥有了继承下来的成员，可以直接使用（就当成子类中也定义了相同的成员）。
      </li>
      <li>
       写法：
       <code>
        class 类名(父类名)
       </code>
       <ul>
        <li>
         可以多继承，多个父类名在括号中使用逗号隔开。
        </li>
        <li>
         如果继承下来的多个父类有同名的成员变量或方法，则以括号中
         <font color="red">
          从左到右
         </font>
         的顺序来排优先级。
        </li>
       </ul>
      </li>
     </ul>
     <p>
      <strong>
       单继承：
      </strong>
     </p>
     <pre><code class="prism language-python"><span class="token comment"># 定义父类</span>
<span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">:</span>
    IMEI <span class="token operator">=</span> <span class="token boolean">None</span>
    simCard <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">callBy4G</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父类Phone的成员方法被调用'</span><span class="token punctuation">)</span>

<span class="token comment"># 子类继承父类</span>
<span class="token keyword">class</span> <span class="token class-name">XIAOMI</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">:</span>
    color <span class="token operator">=</span> <span class="token string">'green'</span>

x1 <span class="token operator">=</span> XIAOMI<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x1<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token comment"># green</span>
<span class="token comment"># 子类对象可以直接调用继承下来的父类方法</span>
x1<span class="token punctuation">.</span>callBy4G<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 父类Phone的成员方法被调用</span>
</code></pre>
     <p>
      <strong>
       多继承：
      </strong>
     </p>
     <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">:</span>
    IMEI <span class="token operator">=</span> <span class="token boolean">None</span>
    simCard <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">callBy4G</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父类Phone的成员方法被调用'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">NFCReader</span><span class="token punctuation">:</span>
    producer <span class="token operator">=</span> <span class="token string">'NVINDA'</span>
    
    <span class="token keyword">def</span> <span class="token function">readNFC</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'读取了NFC'</span><span class="token punctuation">)</span>
        
<span class="token keyword">class</span> <span class="token class-name">HUAWEI</span><span class="token punctuation">(</span>Phone<span class="token punctuation">,</span> NFCReader<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 拥有了继承下来的两个父类的所有成员</span>
    <span class="token keyword">pass</span>
</code></pre>
     <h5>
      <a id="162__368">
      </a>
      1.6.2 复写
     </h5>
     <ul>
      <li>
       子类可以复写和父类同名的变量或方法，重写后子类再调用就会调用重写后的而不是父类的。
      </li>
      <li>
       重写的方式是直接定义一个和父类中同名的新方法或新变量。
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">:</span>
    IMEI <span class="token operator">=</span> <span class="token boolean">None</span>
    simCard <span class="token operator">=</span> <span class="token boolean">None</span>
    name <span class="token operator">=</span> <span class="token string">"手机大王"</span>

    <span class="token keyword">def</span> <span class="token function">callBy4G</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父类Phone的成员方法被调用'</span><span class="token punctuation">)</span>

<span class="token comment"># 子类继承父类</span>
<span class="token keyword">class</span> <span class="token class-name">XIAOMI</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">:</span>
    color <span class="token operator">=</span> <span class="token string">'green'</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 从父类继承下来的属性被修改</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token comment"># 进行了重写</span>
    <span class="token keyword">def</span> <span class="token function">callBy4G</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子类XIAOMI的成员方法被调用'</span><span class="token punctuation">)</span>

x1 <span class="token operator">=</span> XIAOMI<span class="token punctuation">(</span><span class="token string">"小米手机"</span><span class="token punctuation">)</span>
x1<span class="token punctuation">.</span>callBy4G<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 调用的是重写后的方法而不是父类的</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment"># 小米手机</span>
</code></pre>
     <h5>
      <a id="163__400">
      </a>
      1.6.3 调用父类同名属性
     </h5>
     <ul>
      <li>
       子类中调用父类属性有2种方式（仅针对属性，调用父类方法见下述）：
       <ul>
        <li>
         <code>
          父类名.属性名
         </code>
        </li>
        <li>
         <code>
          super().属性名
         </code>
        </li>
       </ul>
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">:</span>
    IMEI <span class="token operator">=</span> <span class="token boolean">None</span>
    simCard <span class="token operator">=</span> <span class="token string">'父类的sim卡'</span>

    <span class="token keyword">def</span> <span class="token function">callBy4G</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父类Phone的成员方法被调用'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">XIAOMI</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">:</span>
    color <span class="token operator">=</span> <span class="token string">'green'</span>
    simCard <span class="token operator">=</span> <span class="token string">'子类重写的sim卡'</span>

    <span class="token comment"># 进行了重写</span>
    <span class="token keyword">def</span> <span class="token function">callBy4G</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 调用父类成员</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>simCard<span class="token punctuation">)</span>

x1 <span class="token operator">=</span> XIAOMI<span class="token punctuation">(</span><span class="token punctuation">)</span>
x1<span class="token punctuation">.</span>callBy4G<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 父类的sim卡</span>
</code></pre>
     <h5>
      <a id="164__429">
      </a>
      1.6.4 多态和抽象
     </h5>
     <ul>
      <li>
       抽象指的是父类来确定有哪些方法和成员，但什么都不做（pass），具体的实现由子类重写决定。
      </li>
      <li>
       多态指的是参数接收父类，但其实传递的是子类对象，也就是父类抽象，子类实际工作。
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token comment"># 抽象类中定义抽象方法</span>
<span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">noise</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

<span class="token comment"># 定义子类</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">noise</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I am a dog"</span><span class="token punctuation">)</span>

<span class="token comment"># 参数接受一个父类对象</span>
<span class="token keyword">def</span> <span class="token function">makeNoise</span><span class="token punctuation">(</span>animal<span class="token punctuation">:</span> Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>
    animal<span class="token punctuation">.</span>noise<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 实际传递子类对象</span>
makeNoise<span class="token punctuation">(</span>Dog<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># I am a dog</span>
</code></pre>
     <h4>
      <a id="17__455">
      </a>
      1.7 自定义属性
     </h4>
     <ul>
      <li>
       对于一些不需要任何参数，然后返回一个值的成员函数，可以使用
       <code>
        @property
       </code>
       装饰器来将它们变成“属性”，以后这些方法就可以当作属性来使用，而不用调用函数。
      </li>
      <li>
       定义后函数名就是属性名。
      </li>
     </ul>
     <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>

    baseAge <span class="token operator">=</span> <span class="token number">12</span>

    <span class="token decorator annotation punctuation">@property</span>
    <span class="token keyword">def</span> <span class="token function">age</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>baseAge <span class="token operator">*</span> <span class="token number">2</span>
    
stu1 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 把age函数当成一个属性来使用了</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment"># 24</span>
</code></pre>
     <h3>
      <a id="_476">
      </a>
      二、类型注解
     </h3>
     <h4>
      <a id="21__478">
      </a>
      2.1 基本用法
     </h4>
     <ul>
      <li>
       <font color="red">
        对代码实际执行没有任何影响
       </font>
       ，只是帮助第三方IDE工具做类型提示，如自动补全和类型检查。
      </li>
      <li>
       支持的范围：
       <ul>
        <li>
         变量、对象的类型注解。
        </li>
        <li>
         函数的形参和返回值的类型注解。
        </li>
       </ul>
      </li>
      <li>
       写法：
       <ul>
        <li>
         变量、对象的注解直接在原本的代码基础上，变量或者对象之后加
         <code>
          : 类型
         </code>
         即可，其他赋值等代码都不动。
         <ul>
          <li>
           对象的类型注解就是所属的类。
          </li>
         </ul>
        </li>
        <li>
         方法的返回值注解：
         <code>
          def 函数名() -&gt; 返回值类型
         </code>
        </li>
       </ul>
      </li>
     </ul>
     <img src="https://i-blog.csdnimg.cn/direct/3ac1c0075fca4c138ebc8b97e580dea7.png" width="60%">
      <h4>
       <a id="22__493">
       </a>
       2.2 容器类型注解
      </h4>
      <ul>
       <li>
        元组类型设置类型详细注解，需要将每一个元素都标记出来。
       </li>
       <li>
        字典类型设置类型详细注解，需要2个类型，第一个是key第二个是value。
       </li>
      </ul>
      <img src="https://i-blog.csdnimg.cn/direct/1c9accab7f1241ff8a757340a27a64f4.png" width="30%">
       <img src="https://i-blog.csdnimg.cn/direct/16d6f26bb8884f48877245968d7c7108.png" width="50%">
        <h4>
         <a id="23_type_506">
         </a>
         2.3 type定义类型注解
        </h4>
        <ul>
         <li>
          除了使用
          <code>
           变量: 类型
          </code>
          这种语法做注解外，也可以在注释中进行类型注解。
          <ul>
           <li>
            语法：
            <code>
             # type: 类型
            </code>
            <br/>
            <img src="https://i-blog.csdnimg.cn/direct/ced69a9db31f492e8033fa0aebee0299.png" width="60%"/>
           </li>
          </ul>
         </li>
        </ul>
        <h4>
         <a id="24_Union_514">
         </a>
         2.4 Union联合类型
        </h4>
        <ul>
         <li>
          <p>
           对于可以存放各种类型的容器来说，如果一个一个的把所有元素的类型都按顺序写出来会比较麻烦，可以使用联合类型指出所有可能的类型即可。
          </p>
         </li>
         <li>
          <p>
           用法：先从typing导包，然后
           <code>
            Union[所有可能的类型逗号隔开]
           </code>
           ：
          </p>
         </li>
        </ul>
        <pre><code class="prism language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Union

<span class="token comment"># data可能是int, str种的一种</span>
<span class="token keyword">def</span> <span class="token function">process_data</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> Union<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Processing integer: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>data<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Processing string: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>data<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>

process_data<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
process_data<span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>
</code></pre>
        <img src="https://i-blog.csdnimg.cn/direct/7a45fd0f2c134595819b325d804dbf4b.png" width="70%">
         <ul>
          <li>
           <code>
            isinstance
           </code>
           用来判断对象和类的关系，返回 True 或 False：
           <ul>
            <li>
             第一个参数写对象，第二个参数写类。
            </li>
           </ul>
          </li>
         </ul>
         <h3>
          <a id="_540">
          </a>
          三、闭包
         </h3>
         <ul>
          <li>
           闭包指的是函数进行嵌套，内部函数使用外层函数的参数，并且外层函数返回值是
           <font color="red">
            内层函数本身
           </font>
           。
          </li>
          <li>
           如果一个变量只是用来传递给仅一个函数使用，可以使用闭包增加安全性。
          </li>
         </ul>
         <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">outer</span><span class="token punctuation">(</span>num1<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span>num2<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 内部函数可直接使用外层函数的参数</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'我是</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>num2<span class="token punctuation">}</span></span><span class="token string">，我引用了外层的参数</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>num1<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>
    <span class="token comment"># 外层函数直接返回内部函数本身</span>
    <span class="token keyword">return</span> inner

<span class="token comment"># 此时out1就相当于inner函数，当作函数来使用</span>
out1 <span class="token operator">=</span> outer<span class="token punctuation">(</span><span class="token string">'Jay'</span><span class="token punctuation">)</span>
out1<span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">)</span> <span class="token comment"># 我是Tom，我引用了外层的参数Jay</span>
</code></pre>
         <ul>
          <li>
           <p>
            如果不使用闭包，直接在inner之外定义num1变量，会存在被导包后被其他模块篡改num1变量的风险，而使用闭包避免这种风险，增加安全性。
           </p>
          </li>
          <li>
           <p>
            可以在内部函数中使用 nonlocal 关键字修饰外层函数的参数，从而使得内部函数可以修改这个参数的值。
           </p>
           <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">outer</span><span class="token punctuation">(</span>num1<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span>num2<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 使用nonlocal关键字修饰外层函数的参数，从而可以修改他</span>
        <span class="token keyword">nonlocal</span> num1
        num1 <span class="token operator">+=</span> num2
        <span class="token keyword">return</span> num1
    <span class="token keyword">return</span> inner

fn <span class="token operator">=</span> outer<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>fn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 30</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>fn<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 50</span>
</code></pre>
           <ul>
            <li>
             <font color="red">
              注意：
             </font>
             观察上方代码的最后两行，并不是两次输出都是30，那么得出结论：
             <font color="orange">
              外层函数的变量在内层函数是共用的
             </font>
             ，也就是一旦外层函数的参数被修改，那么对内层函数不论调用几次都整体生效，不会重置。
            </li>
           </ul>
          </li>
          <li>
           <p>
            闭包优缺点：
           </p>
           <ul>
            <li>
             优点：
             <ul>
              <li>
               无需定义全局变量即可通过内层函数持续访问、修改它的参数。
              </li>
              <li>
               增加代码安全性。
              </li>
             </ul>
            </li>
            <li>
             缺点：
             <ul>
              <li>
               内部函数持续引用外部函数的值，会导致这一部分内存空间不释放，占用内存（但是几个变量不释放的内存可以忽略不计）。
              </li>
             </ul>
            </li>
           </ul>
          </li>
         </ul>
         <h3>
          <a id="_588">
          </a>
          四、装饰器
         </h3>
         <ul>
          <li>
           装饰器也是闭包，其作用是在不改变原有函数功能的基础上，为函数增加新功能。
          </li>
          <li>
           装饰器本质上是一个接受函数作为参数并返回内层函数的函数。也就是上述闭包模块的外层函数的参数不再是一个变量，而是一个函数。
          </li>
         </ul>
         <p>
          <strong>
           举例：想要在调用sleep函数前后各执行一些代码：
          </strong>
         </p>
         <pre><code class="prism language-python"><span class="token comment"># 外层函数的参数接收一个函数</span>
<span class="token keyword">def</span> <span class="token function">outerFunc</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'睡觉前做的事情'</span><span class="token punctuation">)</span>
        func<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'睡觉后做的事情'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> inner

<span class="token keyword">def</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我要睡觉了啊'</span><span class="token punctuation">)</span>

inner <span class="token operator">=</span> outerFunc<span class="token punctuation">(</span>sleep<span class="token punctuation">)</span>
inner<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token triple-quoted-string string">"""
睡觉前做的事情
我要睡觉了啊
睡觉后做的事情
"""</span>
</code></pre>
         <p>
          <strong>
           代码可使用装饰器的语法糖来写：
          </strong>
         </p>
         <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">outerFunc</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'睡觉前做的事情'</span><span class="token punctuation">)</span>
        func<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'睡觉后做的事情'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> inner

<span class="token comment"># 使用@+外层函数名的方式</span>
<span class="token decorator annotation punctuation">@outerFunc</span>
<span class="token keyword">def</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我要睡觉了啊'</span><span class="token punctuation">)</span>

<span class="token comment"># 直接调用sleep函数即可实现上述功能</span>
sleep<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token triple-quoted-string string">"""
睡觉前做的事情
我要睡觉了啊
睡觉后做的事情
"""</span>
</code></pre>
         <ul>
          <li>
           在这个例子中，自定义的
           <code>
            @outerFunc
           </code>
           就是一个装饰器，
           <code>
            sleep()
           </code>
           是被装饰器修饰的函数。调用
           <code>
            sleep()
           </code>
           其实是在调用外层函数
           <code>
            outerFunc()
           </code>
           的内层方法
           <code>
            inner()
           </code>
           ，且外层方法的参数是被修饰的
           <code>
            sleep()
           </code>
           函数。
          </li>
          <li>
           <code>
            sleep()
           </code>
           函数被修饰，所以调用
           <code>
            sleep()
           </code>
           函数就是修饰后的内容，而不是函数原本的内容。
          </li>
         </ul>
         <p>
          <font color="red">
           总结一下具体写法：
          </font>
         </p>
         <ol>
          <li>
           想要修饰哪个函数就给哪个函数加装饰器。
          </li>
          <li>
           定义一个与装饰器同名的外层函数，并接收一个参数（这个参数实际就是被修饰的函数）。
          </li>
          <li>
           定义内层函数（这是将要被实际执行的函数），并在内层函数中使用外层函数的参数（被修饰的函数）。
          </li>
          <li>
           直接调用被修饰的函数，运行结果就是被修饰后的代码（内层函数）。
          </li>
         </ol>
         <p>
          <font color="orange">
           注意：
          </font>
          <font color="cornflowerblue">
           外层函数要在被修饰的函数之前定义
          </font>
          ，因为Python代码从上往下执行，否则Python识别不到当前行之后的内容。
         </p>
         <h3>
          <a id="_654">
          </a>
          五、构造方法重写补充
         </h3>
         <p>
          <font color="red">
           注意事项：
          </font>
         </p>
         <ul>
          <li>
           在Python中，如果子类没有显式定义构造函数（
           <code>
            __init__
           </code>
           方法），当实例化子类对象时，Python 会
           <font color="orange">
            自动调用父类的构造函数
           </font>
           。这是 Python 的默认行为，以使用父类的构造方法提供的功能。
          </li>
          <li>
           如果需要在子类中添加更多的初始化逻辑，可以定义子类自己的
           <code>
            __init__
           </code>
           方法，并且
           <font color="red">
            一定要在其中调用父类的
           </font>
           <code>
            __init__
           </code>
           方法，确保父类的初始化逻辑也能够执行。
          </li>
          <li>
           调用父类的属性（两种方式无差别）：
           <ul>
            <li>
             <code>
              父类名.属性名
             </code>
            </li>
            <li>
             <code>
              super().属性名
             </code>
            </li>
           </ul>
          </li>
          <li>
           调用父类的方法（无论构造方法还是普通方法都要遵守以下两个规则）：
           <ul>
            <li>
             <code>
              父类名.方法名
             </code>
             ：
             <font color="orange">
              一定需要
             </font>
             显式传递
             <code>
              self
             </code>
             作为第一个参数。
            </li>
            <li>
             <code>
              super().方法名
             </code>
             ：
             <font color="orange">
              一定不需要
             </font>
             显示传递
             <code>
              self
             </code>
             作为第一个参数。因为
             <code>
              super()
             </code>
             会自动处理这个参数。
             <font color="cornflowerblue">
              在多继承情况下更有用，所以推荐以后都使用这种方式。
             </font>
            </li>
           </ul>
          </li>
         </ul>
         <h4>
          <a id="51__667">
          </a>
          5.1 子类单继承没有定义构造方法
         </h4>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类1构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 没有显示调用父类的构造方法</span>
    <span class="token keyword">pass</span>

<span class="token comment"># 创建 Child 类的实例</span>
child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
         <p>
          输出：
         </p>
         <pre><code class="prism language-tex">父类1构造方法执行了！
</code></pre>
         <h4>
          <a id="52__690">
          </a>
          5.2 子类单继承重写构造方法
         </h4>
         <p>
          <strong>
           使用super()调用：
          </strong>
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类1构造方法执行了！"</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">normalMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用了父类的普通方法"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>normalMethod<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"子类构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token comment"># 创建 Child 类的实例</span>
child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
         <p>
          输出：
         </p>
         <pre><code class="prism language-tex">父类1构造方法执行了！
调用了父类的普通方法
子类构造方法执行了！
</code></pre>
         <p>
          <strong>
           使用父类名调用：
          </strong>
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类1构造方法执行了！"</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">normalMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用了父类的普通方法"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        Base1<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        Base1<span class="token punctuation">.</span>normalMethod<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"子类构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token comment"># 创建 Child 类的实例</span>
child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
         <h4>
          <a id="53_MRO_742">
          </a>
          5.3 MRO
         </h4>
         <ul>
          <li>
           在Python中，使用
           <code>
            super()
           </code>
           函数来调用父类的构造方法遵循了方法解析顺序（Method Resolution Order，MRO）。MRO是Python确定方法继承顺序的一种方式，它是基于C3线性化算法。
          </li>
          <li>
           <code>
            super()
           </code>
           的工作方式：在构造方法中使用
           <code>
            super().__init__()
           </code>
           时，Python会查找当前类的MRO来确定下一个类，
           <font color="orange">
            并调用下一个类的构造方法
           </font>
           。
          </li>
          <li>
           通过
           <code>
            类名.__mro__
           </code>
           可以得到一个类的MRO顺序。
          </li>
         </ul>
         <p>
          如何确定一个类的MRO呢？比如这段代码：
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类1构造方法执行了！"</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">normalMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用了父类1的普通方法"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类2构造方法执行了！"</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">normalMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用了父类2的普通方法"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>Child<span class="token punctuation">.</span>__mro__<span class="token punctuation">)</span>
<span class="token comment"># 输出：(&lt;class '__main__.Child'&gt;, &lt;class '__main__.Base1'&gt;, &lt;class '__main__.Base2'&gt;, &lt;class 'object'&gt;)</span>
</code></pre>
         <p>
          <strong>
           1. 首先确定大方向
          </strong>
         </p>
         <ul>
          <li>
           当前基类一定是排在第一位的，然后考虑当前类的父类，按照父类引用的顺序，从左到右给父类排序。
          </li>
          <li>
           如果一个基类有多个父类，那么这个父类的MRO也会按照和子类相同的算法（C3线性化算法）来计算。
          </li>
          <li>
           所有的Python类最终都继承自
           <code>
            object
           </code>
           类，所以
           <code>
            object
           </code>
           是MRO中的最后一个元素。
          </li>
          <li>
           最后，Python将当前类、父类的MRO、以及 object 合并起来，形成当前类的MRO。
          </li>
         </ul>
         <p>
          目前的MRO顺序：
          <code>
           Child、Base1的MRO、Base2的MRO、object
          </code>
          。
         </p>
         <p>
          <strong>
           2. 根据C3线性化算法，以下是确定两个父类MRO的详细步骤：
          </strong>
         </p>
         <ul>
          <li>
           <p>
            对每个父类，列出它的MRO（这俩父类都没继承其他类）：
           </p>
           <ul>
            <li>
             <code>
              Base1
             </code>
             的MRO是
             <code>
              [Base1, object]
             </code>
             。
            </li>
            <li>
             <code>
              Base2
             </code>
             的MRO是
             <code>
              [Base2, object]
             </code>
             。
            </li>
           </ul>
          </li>
          <li>
           <p>
            从两个父类列表的第一个元素开始，如果这个元素在其他列表中也是第一个元素，或者不在其他列表中，那么它就被添加到最终的MRO中。然后从所有包含这个元素的列表中移除这个元素。
            <font color="orange">
             （可以简单的认为是在剔除重复已有元素）
            </font>
           </p>
          </li>
          <li>
           <p>
            重复上述步骤，直到所有列表都为空。
           </p>
          </li>
         </ul>
         <p>
          <font color="green">
           故最终可以得到以下顺序：
          </font>
         </p>
         <ol>
          <li>
           选择
           <code>
            Base1
           </code>
           （因为它在第一个列表中，并且不在其他列表中），最终MRO得到
           <code>
            [Child, Base1]
           </code>
           。第一个列表的Object不做处理，因为它不满足条件。
          </li>
          <li>
           然后选择第二个列表的
           <code>
            Base2
           </code>
           （因为它不在其他列表中），最终MRO得到
           <code>
            [Child, Base1, Base2]
           </code>
           。
          </li>
          <li>
           最后选择
           <code>
            object
           </code>
           ，
           <strong>
            得到最终的MRO
           </strong>
           ：
           <code>
            [Child, Base1, Base2, object]
           </code>
           。
          </li>
         </ol>
         <p>
          <strong>
           如果父类也有继承的类：
          </strong>
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">BaseA</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"BaseA init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">BaseB</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"BaseB init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">(</span>BaseA<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Base1 init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span><span class="token punctuation">(</span>BaseB<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Base2 init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Child init"</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>Child<span class="token punctuation">.</span>__mro__<span class="token punctuation">)</span>
</code></pre>
         <p>
          输出：
         </p>
         <pre><code class="prism language-tex">(&lt;class '__main__.Child'&gt;, &lt;class '__main__.Base1'&gt;, &lt;class '__main__.BaseA'&gt;, &lt;class '__main__.Base2'&gt;, &lt;class '__main__.BaseB'&gt;, &lt;class 'object'&gt;)
</code></pre>
         <p>
          <font color="red">
           注意：
          </font>
          只有使用
          <code>
           super().__init__()
          </code>
          方式时才会使用到MRO的逻辑，如果通过父类名调用的话，和MRO无关。
         </p>
         <h5>
          <a id="531__838">
          </a>
          5.3.1 子类多继承没有定义构造方法
         </h5>
         <p>
          <font color="red">
           如果子类没有定义构造方法，则子类会根据MRO的顺序，只有第一个父类的构造方法会被自动调用
          </font>
          ，其他父类的构造方法不会被调用：
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类1构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类2构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#只会输出：父类1构造方法执行了！</span>
</code></pre>
         <h5>
          <a id="532__860">
          </a>
          5.3.2 子类多继承重写构造方法
         </h5>
         <p>
          <font color="red">
           注意：
          </font>
          子类中如果通过父类名显示调用了父类的构造方法，则没有调用所有父类的构造方法也不会报错，因为
          <font color="orange">
           Python支持选择性调用父类的构造方法。
          </font>
         </p>
         <p>
          多继承更推荐使用
          <code>
           super()
          </code>
          方式调用父类构造方法，因为只使用一个
          <code>
           super()
          </code>
          就可以自动加载所有的父类构造方法而不用一个个去调用：
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类1构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类2构造方法执行了！"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base2<span class="token punctuation">,</span> Base1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Child init"</span><span class="token punctuation">)</span>

child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
         <p>
          输出：
         </p>
         <pre><code class="prism language-tex">父类2构造方法执行了！
Child init
</code></pre>
         <p>
          为什么子类使用了
          <code>
           super()
          </code>
          方式，但是只调用了一个父类的构造方法解释：
         </p>
         <p>
          Child类的MRO顺序：
          <code>
           (&lt;class '__main__.Child'&gt;, &lt;class '__main__.Base2'&gt;, &lt;class '__main__.Base1'&gt;, &lt;class 'object'&gt;)
          </code>
         </p>
         <ol>
          <li>
           <code>
            super().__init__()
           </code>
           在
           <code>
            Child
           </code>
           的构造方法中被调用，它根据MRO调用
           <code>
            Base2
           </code>
           的构造方法。
          </li>
          <li>
           但是
           <code>
            Base2
           </code>
           中没有使用
           <code>
            super()
           </code>
           ，所以就不会再继续往上调用了
           <font color="red">
            （只有遇到了 super() 方法才会使用MRO逻辑）。
           </font>
          </li>
         </ol>
         <p>
          <strong>
           综合示例：
          </strong>
         </p>
         <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">BaseA</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"BaseA init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">BaseB</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"BaseB init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base1</span><span class="token punctuation">(</span>BaseA<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Base1 init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Base2</span><span class="token punctuation">(</span>BaseB<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Base2 init"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Child init"</span><span class="token punctuation">)</span>

<span class="token comment"># 创建 Child 类的实例</span>
child <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
         <p>
          <strong>
           Child的MRO：
          </strong>
         </p>
         <p>
          <code>
           (&lt;class '__main__.Child'&gt;, &lt;class '__main__.Base1'&gt;, &lt;class '__main__.BaseA'&gt;, &lt;class '__main__.Base2'&gt;, &lt;class '__main__.BaseB'&gt;, &lt;class 'object'&gt;)
          </code>
          。
         </p>
         <p>
          <strong>
           运行结果：
          </strong>
         </p>
         <pre><code class="prism language-tex">BaseB init
Base2 init
BaseA init
Base1 init
Child init
</code></pre>
         <p>
          <font color="red">
           注意：
          </font>
          调用完最上层的构造方法之后要开始回溯。
         </p>
        </img>
       </img>
      </img>
     </img>
    </img>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34393334333139302f:61727469636c652f64657461696c732f313436323837353637" class_="artid" style="display:none">
 </p>
</div>


