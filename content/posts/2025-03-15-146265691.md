---
layout: post
title: "进程间通信-匿名管道"
date: 2025-03-15 21:14:39 +0800
description: "管道是Unix中最古老的进程间通信的形式。"
keywords: "进程间通信--匿名管道"
categories: ['Linux']
tags: ['运维', '服务器']
artid: "146265691"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146265691
    alt: "进程间通信-匿名管道"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146265691
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146265691
cover: https://bing.ee123.net/img/rand?artid=146265691
image: https://bing.ee123.net/img/rand?artid=146265691
img: https://bing.ee123.net/img/rand?artid=146265691
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     进程间通信--匿名管道
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     进程间通信介绍
    </h2>
    <p>
     <strong>
      进程间通信目的
     </strong>
    </p>
    <ul>
     <li>
      数据传输：一个进程需要将它的数据发送给另一个进程
     </li>
     <li>
      资源共享：多个进程之间共享同样的资源。
     </li>
     <li>
      通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
     </li>
     <li>
      进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
     </li>
    </ul>
    <h3>
     管道
    </h3>
    <p>
     <br/>
     <strong>
      什么是管道
     </strong>
     <br/>
     管道是Unix中最古老的进程间通信的形式。我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”如：
    </p>
    <p>
     <img alt="" height="521" src="https://i-blog.csdnimg.cn/direct/0ea6ef17f48b46fba26b24307bf849e1.png" width="1057"/>
    </p>
    <p>
     <strong>
      用fork来共享管道原理
     </strong>
    </p>
    <p>
     <img alt="" height="411" src="https://i-blog.csdnimg.cn/direct/aeeae94e01a446a49a348e2bd9c7535d.png" width="1155"/>
    </p>
    <p>
     <strong>
      站在文件描述符角度-深度理解管道 （内存级）
     </strong>
    </p>
    <p>
     <img alt="" height="832" src="https://i-blog.csdnimg.cn/direct/38d37927e721402f9bc20ca7cddb54ea.jpeg" width="1828">
      左边是进程管理，右边是文件管理，进程通过全局变量能找到文件描述符标，也就找到了对应的file文件也能打开磁盘上的文件拷贝到缓冲区里进行读写，父进程创建子进程，发生写实拷贝，类似于浅拷贝，此时不做文件操作，文件描述符里面的对于关系和父进程一样，struc_file没有关闭，因为父进程还在， struc_file的对应的引用计数不为0就一定不会关闭，既然访问的同一个struc_file，也可以同时访问其中的file文件，通过缓冲区可以进行文件的读写
     </img>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="638" src="https://i-blog.csdnimg.cn/direct/c8bf8691e86e4756af596bd7bd01c5e9.png" width="531"/>
    </p>
    <ol>
     <li>
      父进程通过读写两种方式打开内存级的文件返回给上层完成管道的创建
     </li>
     <li>
      子进程继承父进程的文件描述符表，发生浅拷贝，也能拿到父进程以读写打开的管道文件
     </li>
     <li>
      父子都看得到，让父子单向通信，父进程写，子进程读，各自关闭掉自己不需要的文件描述符
     </li>
    </ol>
    <p>
     这个是管道是OS单独设计的，得配上单独的系统调用：pipe 内存级的，不需要文件路径，没有文件名，所以叫匿名管道，
     <u>
      那我们怎么保证，两个进程打开的是同一个管道的？
     </u>
    </p>
    <p>
     <u>
      子进程继承了父进程的文件描述符表
     </u>
    </p>
    <p>
     <strong>
      站在内核角度-管道本质
     </strong>
    </p>
    <p>
     <img alt="" height="374" src="https://i-blog.csdnimg.cn/direct/2c9b2ef052354ebdb7d4d90b115ef0a8.png" width="470"/>
    </p>
    <p>
    </p>
    <h4>
     匿名管道
    </h4>
    <p>
     <img alt="" height="413" src="https://i-blog.csdnimg.cn/direct/b0701fa02b1343e3959b0bced2c2c739.png" width="979"/>
    </p>
    <pre><code class="language-cpp">#include &lt;unistd.h&gt;
功能:创建⼀⽆名管道
原型
int pipe(int fd[2]);
参数
fd：⽂件描述符数组,其中fd[0]表⽰读端, fd[1]表⽰写端
返回值:成功返回0，失败返回错误代码</code></pre>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;unistd.h&gt;
using namespace std;
int main()
{
    int fds[2]={0};

    int n=pipe(fds);
    if(n&lt;0)
    {
        cerr&lt;&lt;"Pipe error"&lt;&lt;endl;
        return 1;
    }
    cout&lt;&lt;"fds[0]"&lt;&lt;fds[0]&lt;&lt;endl;
    cout&lt;&lt;"fds[1]"&lt;&lt;fds[1]&lt;&lt;endl;
   
    return 0;
}
</code></pre>
    <p>
     0，1，2被三个标准占用了，从3，4开始
    </p>
    <p>
     <img alt="" height="208" src="https://i-blog.csdnimg.cn/direct/8772875e18a34c40a44bee2af6d51caa.png" width="1362"/>
    </p>
    <p>
     父写子读，实现通信
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;cstring&gt;
using namespace std;

void ChildWrite(int fd)
{
char buffer[1024];
int cnt=0;
while(true)
{
snprintf(buffer,sizeof(buffer),"I am child,pid:%d cnt:%d\n",getpid(),cnt++); 
write(fd,buffer,strlen(buffer));
sleep(1);
}
}
void FatherRead(int fd)
{
    char buffer[1024];
 while(true)
 {
    buffer[0]=0;
    ssize_t n=read(fd,buffer,sizeof(buffer)-1);
    if(n&gt;0)
    {
        buffer[n]=0;
        cout&lt;&lt;"child says: "&lt;&lt;buffer&lt;&lt;endl;
    }
 }
}
int main()
{  //1.创建管道
    int fds[2]={0}; //fds[0]读端，fds[1]写端

    int n=pipe(fds);
    if(n&lt;0)
    {
        cerr&lt;&lt;"Pipe error"&lt;&lt;endl;
        return 1;
    }
    cout&lt;&lt;"fds[0]"&lt;&lt;fds[0]&lt;&lt;endl;
    cout&lt;&lt;"fds[1]"&lt;&lt;fds[1]&lt;&lt;endl;
   //3.创建子进程 f-&gt;r c-&gt;w
    pid_t id=fork();
  if(id==0)
  {
    //child
    close(fds[0]); //关闭读端
    ChildWrite(fds[1]);
    close(fds[1]);
    exit(0);
  }
close(fds[1]); //关闭写端
FatherRead(fds[0]);
waitpid(id,nullptr,0);
close(fds[0]);
    return 0;
}
</code></pre>
    <p>
     父进程写的cnt在不断变化，子进程能读到，说明实现了管道通信
    </p>
    <p>
     <img alt="" height="426" src="https://i-blog.csdnimg.cn/direct/7c2c2ac36eec46fc868bdde11c37d4fd.png" width="1678"/>
    </p>
    <p>
     <img alt="" height="358" src="https://i-blog.csdnimg.cn/direct/0a532f128d364d0082f6e6344da63b33.png" width="1820"/>
    </p>
    <p>
     <strong>
      五种特性
     </strong>
    </p>
    <p>
     1.匿名管道，只能用来进行具有血缘关系的进程进行进程间通信(常用父与子，如上述代码)
    </p>
    <p>
     2.管道文件，自带同步机制（父子进程进行IO同时进行，一个读一个写，不管是父快还是子快，父不断写，子read读不到会阻塞住直到读到为止）
    </p>
    <p>
     3.管道是面向字节流的
    </p>
    <p>
     <img alt="" height="616" src="https://i-blog.csdnimg.cn/direct/fd6b7114cbb84f36a5d12f83109f145e.jpeg" width="1740"/>
    </p>
    <p>
     4.管道是单向通信的（要么父写子读，要么子写父读）
    </p>
    <p>
     5. （管道）文件的生命周期随进程
    </p>
    <p>
     <strong>
      4种通信情况
     </strong>
    </p>
    <p>
     1.写慢，读快------&gt;读端阻塞等待写端(进程)
    </p>
    <p>
     2.写快，读慢------&gt;缓冲区写满了，写要阻塞等待读端
    </p>
    <p>
     3.写关，读开------&gt;read会读到返回值0，表示文件结尾
    </p>
    <pre><code class="language-cpp">//写一条就关
void ChildWrite(int fd)
{
char buffer[1024];
int cnt=0;
while(true)
{
snprintf(buffer,sizeof(buffer),"I am child,pid:%d cnt:%d\n",getpid(),cnt++); 
write(fd,buffer,strlen(buffer));
sleep(1);
break;
}
}
//观察n的返回值
void FatherRead(int fd)
{
    char buffer[1024];
 while(true)
 {
    buffer[0]=0;
    ssize_t n=read(fd,buffer,sizeof(buffer)-1);
    if(n&gt;0)
    {
        buffer[n]=0;
        cout&lt;&lt;"child says: "&lt;&lt;buffer&lt;&lt;endl;
    }
    else
    {
      cout&lt;&lt; "n:"&lt;&lt;n&lt;&lt;endl;
    }
 }
}</code></pre>
    <p>
     <img alt="" height="216" src="https://i-blog.csdnimg.cn/direct/ab45849464a04abb89daef5d4a819762.png" width="1380"/>
    </p>
    <p>
     4.读关，写开-------&gt;写端再写没有意义，OS会杀掉写端进程
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;cstring&gt;
using namespace std;

void ChildWrite(int fd)
{
char buffer[1024];
int cnt=0;
while(true)
{
snprintf(buffer,sizeof(buffer),"I am child,pid:%d cnt:%d\n",getpid(),cnt++); 
write(fd,buffer,strlen(buffer));
sleep(1);
}
}
void FatherRead(int fd)
{
    char buffer[1024];
 while(true)
 {
    buffer[0]=0;
    ssize_t n=read(fd,buffer,sizeof(buffer)-1);
    if(n&gt;0)
    {
        buffer[n]=0;
        cout&lt;&lt;"child says: "&lt;&lt;buffer&lt;&lt;endl;
    }
    else
    {
      cout&lt;&lt; "n:"&lt;&lt;n&lt;&lt;endl;
      sleep(4);
    }
    break;
 }
}
int main()
{  //1.创建管道
    int fds[2]={0}; //fds[0]读端，fds[1]写端

    int n=pipe(fds);
    if(n&lt;0)
    {
        cerr&lt;&lt;"Pipe error"&lt;&lt;endl;
        return 1;
    } 
    cout&lt;&lt;"fds[0]"&lt;&lt;fds[0]&lt;&lt;endl;
    cout&lt;&lt;"fds[1]"&lt;&lt;fds[1]&lt;&lt;endl;
   //3.创建子进程 f-&gt;r c-&gt;w
    pid_t id=fork();
  if(id==0)
  {
    //child
    close(fds[0]); //关闭读端
    ChildWrite(fds[1]);
    close(fds[1]);
    exit(0);
  }
close(fds[1]); //关闭写端
FatherRead(fds[0]);
close(fds[0]);
  int status;
int ret=waitpid(id,&amp;status,0);
//获取到子进程的退出状态
if(ret&gt;0)
{
  printf("child code: %d exited  status: %d\n",(status)&gt;&gt;8&amp;0xff,(status)&amp;0x7f);
}
return 0;
}
</code></pre>
    <p>
     发送异常信号13 SIGPIPE
    </p>
    <p>
     <img alt="" height="244" src="https://i-blog.csdnimg.cn/direct/908164245cf644fdbe2a15bf4a5d4700.png" width="1242"/>
    </p>
    <h2>
     基于匿名管道----进程池
    </h2>
    <p>
     父进程创建多个子进程，用匿名管道分派任务
    </p>
    <p>
     <img alt="" height="792" src="https://i-blog.csdnimg.cn/direct/87779e59d7cd458fbf79a3f56d49d409.jpeg" width="1488"/>
    </p>
    <p>
     1.构建进程链，为进程池做准备
    </p>
    <pre><code class="language-cpp">#ifndef __PROCESS__POOL_HPP__
#define __PROCESS__POOL_HPP__
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int gdefaultnum = 5; // 要创建几个进程
// 先描述 单个进程
class Channel
{
public:
    Channel() {}
    ~Channel() {}

private:
    int _wfd;
};

// 在组织  进程链
class ChannelManager
{
public:
    ChannelManager() {}
    ~ChannelManager() {}

private:
    vector&lt;Channel&gt; _channels;
};
</code></pre>
    <p>
     2.创建进程池，提供管道条件
    </p>
    <pre><code class="language-cpp">// 进程池
class ProcessPool
{
public:
    ProcessPool(int num) : _process_num(num) {}
    ~ProcessPool() {}
    bool Create()
    {
        int pipefd[2] = {0};
        for (int i = 0; i &lt; _process_num; i++)
        {
            // 1.创建管道

            int n = pipe(pipefd);
            if (n &lt; 0)
                return false;
        }
        // 2.创建子进程  各自关闭不需要的文件描述符
        pid_t id = fork();
        if (id &lt; 0)
            return false;
        else if (id == 0)
        {
            // 子进程 ---&gt;读
            // 3.关闭不需要的文件描述符
            close(pipefd[1]);
            exit(0);
        }
        else
        {
            // 父进程 ---&gt;写
            // 3.关闭不需要的文件描述符
            close(pipefd[0]);
        }
        return true;
    }

private:
    ChannelManager _cm; // 进程链
    int _process_num;   // 进程个数
};</code></pre>
    <p>
     3.父子各自打印验证是否通信
    </p>
    <pre><code class="language-cpp">void BuildChannel(int wfd, pid_t subid)
    {
        _channels.emplace_back(wfd, subid);
        // Channel c(wfd,subid);
        // _channels.push_back(c);
    }
  
void Print()
{
    for(auto  &amp;chnnel : _channels)
    {
cout&lt;&lt;chnnel.Name()&lt;&lt;endl;
    }
}

void Work(int rfd)
    {
        while (true)
        {
            cout &lt;&lt; "我是子进程，我的rfd是：" &lt;&lt; rfd &lt;&lt; endl;
            sleep(2);
        }
    }</code></pre>
    <pre><code class="language-cpp">//ProcessPool.hpp
#ifndef __PROCESS__POOL_HPP__
#define __PROCESS__POOL_HPP__
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt;
using namespace std;
const int gdefaultnum = 5; // 要创建几个进程
// 先描述 单个进程
class Channel
{
public:
    Channel(int fd, pid_t id) : _wfd(fd), _subid(id) { _name = "chnnel-" + std::to_string(_wfd) + "-" + std::to_string(_subid); }
    ~Channel() {}
    int Fd(){return  _wfd;}
    pid_t Subid(){return  _subid;}
    string Name(){return  _name;}
private:
    int _wfd;
    pid_t _subid;
    std::string _name;
};

// 在组织  进程链
class ChannelManager
{
public:
    ChannelManager() {}
    ~ChannelManager() {}
    void BuildChannel(int wfd, pid_t subid)
    {
        _channels.emplace_back(wfd, subid);
        // Channel c(wfd,subid);
        // _channels.push_back(c);
    }
  
void Print()
{
    for(auto  &amp;chnnel : _channels)
    {
cout&lt;&lt;chnnel.Name()&lt;&lt;endl;
    }
}
private:
    vector&lt;Channel&gt; _channels;
};

// 进程池
class ProcessPool
{
public:
    ProcessPool(int num) : _process_num(num) {}
    ~ProcessPool() {}

    void Work(int rfd)
    {
        while (true)
        {
            cout &lt;&lt; "我是子进程，我的rfd是：" &lt;&lt; rfd &lt;&lt; endl;
            sleep(2);
        }
    }
    bool Create()
    {

        for (int i = 0; i &lt; _process_num; i++)
        {
            int pipefd[2] = {0};
            // 1.创建管道

            int n = pipe(pipefd);
            if (n &lt; 0)
                return false;

            // 2.创建子进程  父子各自关闭不需要的文件描述符
            pid_t id = fork();
            if (id &lt; 0)
                return false;
            else if (id == 0)
            {
                // 子进程 ---&gt;读
                // 3.关闭不需要的文件描述符
                close(pipefd[1]);
                Work(pipefd[0]);
                exit(0);
            }
            else
            {
                // 父进程 ---&gt;写
                // 3.关闭不需要的文件描述符
                close(pipefd[0]);
                _cm.BuildChannel(pipefd[1], id);
                close(pipefd[1]);
            }
            
        }
        return true;
    }
  void Debug()
  {
    _cm.Print();
  }
private:
    ChannelManager _cm; // 进程链
    int _process_num;   // 进程个数
};

#endif</code></pre>
    <pre><code class="language-cpp">//Main.cc

#include"ProcessPool.hpp"

int main()
{
    ProcessPool pp(gdefaultnum);
    //创建进程池
    pp.Create();
    //打印进程池
    pp.Debug();
    sleep(1000);
    return 0;
}</code></pre>
    <p>
     实现通信
    </p>
    <p>
     <img alt="" height="526" src="https://i-blog.csdnimg.cn/direct/d6b515a356284bda8abefaac7cf1fb14.png" width="1954"/>
    </p>
    <p>
     4.分配任务，子写父读
    </p>
    <pre><code class="language-cpp"> void Work(int rfd)
    {
        while (true)
        {
            int code = 0;
            ssize_t n = read(rfd, &amp;code, sizeof(code));
            if (n &gt; 0)
            {
                if (n == sizeof(code))
                {
                    continue;
                }
                cout &lt;&lt; "子进程[]"&lt;&lt;getpid()&lt;&lt;"]收到一个任务码:" &lt;&lt; code &lt;&lt; endl;
            }
            else if (n == 0)
            {
                cout &lt;&lt; "子进程退出" &lt;&lt; endl;
                break;
            }
            else
            {
                // 读失败
                cout &lt;&lt; "读取错误" &lt;&lt; endl;
                break;
            }
        }
    }
 void PushTack(int taskcode)
    {
        // 1.选择一个子进程，采用轮询，防止负载均衡和负载不均衡
        auto &amp;c = _cm.Select();
        cout &lt;&lt; "选择一个子进程：" &lt;&lt; c.Name() &lt;&lt; endl;
        // 2.发送任务
        c.Send(taskcode);
        cout &lt;&lt; "发送了一个任务码：" &lt;&lt; taskcode &lt;&lt; endl;
    }

</code></pre>
    <p>
     完整代码
    </p>
    <pre><code class="language-cpp">//ProcessPool.hpp
#ifndef __PROCESS__POOL_HPP__
#define __PROCESS__POOL_HPP__
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt;
using namespace std;
const int gdefaultnum = 5; // 要创建几个进程
// 先描述 单个进程
class Channel
{
public:
    Channel(int fd, pid_t id) : _wfd(fd), _subid(id) { _name = "chnnel-" + std::to_string(_wfd) + "-" + std::to_string(_subid); }
    ~Channel() {}
    int Fd() { return _wfd; }
    pid_t Subid() { return _subid; }
    string Name() { return _name; }
    void Send(int code)
    {
        int n = write(_wfd, &amp;code, sizeof(code));
        (void)n;
    }

private:
    int _wfd;
    pid_t _subid;
    std::string _name;
};

// 在组织  进程链
class ChannelManager
{
public:
    ChannelManager() : _next(0) {}
    ~ChannelManager() {}
    void BuildChannel(int wfd, pid_t subid)
    {
        _channels.emplace_back(wfd, subid);
        // Channel c(wfd,subid);
        // _channels.push_back(c);
    }
    // 轮询
    Channel &amp;Select()
    {
        auto &amp;c = _channels[_next];
        _next++;
        _next %= _channels.size();
        return c;
    }
    void Print()
    {
        for (auto &amp;chnnel : _channels)
        {
            cout &lt;&lt; chnnel.Name() &lt;&lt; endl;
        }
    }

private:
    vector&lt;Channel&gt; _channels;
    int _next;
};

// 进程池
class ProcessPool
{
public:
    ProcessPool(int num) : _process_num(num) {}
    ~ProcessPool() {}

    void Work(int rfd)
    {
        while (true)
        {
            int code = 0;
            ssize_t n = read(rfd, &amp;code, sizeof(code));
            if (n &gt; 0)
            {
                if (n == sizeof(code))
                {
                    continue;
                }
                cout &lt;&lt; "子进程[]"&lt;&lt;getpid()&lt;&lt;"]收到一个任务码:" &lt;&lt; code &lt;&lt; endl;
            }
            else if (n == 0)
            {
                cout &lt;&lt; "子进程退出" &lt;&lt; endl;
                break;
            }
            else
            {
                // 读失败
                cout &lt;&lt; "读取错误" &lt;&lt; endl;
                break;
            }
        }
    }
    bool Create()
    {

        for (int i = 0; i &lt; _process_num; i++)
        {
            int pipefd[2] = {0};
            // 1.创建管道

            int n = pipe(pipefd);
            if (n &lt; 0)
                return false;

            // 2.创建子进程  父子各自关闭不需要的文件描述符
            pid_t id = fork();
            if (id &lt; 0)
                return false;
            else if (id == 0)
            {
                // 子进程 ---&gt;读
                // 3.关闭不需要的文件描述符
                close(pipefd[1]);
                Work(pipefd[0]);
                exit(0);
            }
            else
            {
                // 父进程 ---&gt;写
                // 3.关闭不需要的文件描述符
                close(pipefd[0]);
                _cm.BuildChannel(pipefd[1], id);
                close(pipefd[1]);
            }
        }
        return true;
    }

    void Debug()
    {
        _cm.Print();
    }
    void PushTack(int taskcode)
    {
        // 1.选择一个子进程，采用轮询，防止负载均衡和负载不均衡
        auto &amp;c = _cm.Select();
        cout &lt;&lt; "选择一个子进程：" &lt;&lt; c.Name() &lt;&lt; endl;
        // 2.发送任务
        c.Send(taskcode);
        cout &lt;&lt; "发送了一个任务码：" &lt;&lt; taskcode &lt;&lt; endl;
    }

private:
    ChannelManager _cm; // 进程链
    int _process_num;   // 进程个数
};

#endif</code></pre>
    <pre><code class="language-cpp">//Main.cc

#include"ProcessPool.hpp"

int main()
{
    ProcessPool pp(gdefaultnum);
    //创建进程池
    pp.Create();
    //打印进程池
    //pp.Debug();
    int task_code = 1;
   while(true)
   {
    pp.PushTack(task_code++);
    sleep(1);
   }
    return 0;
}</code></pre>
    <p>
     创建进程池后，OS关闭了没有意义的管道，每次选择一个管道接受消息
    </p>
    <p>
     <img alt="" height="754" src="https://i-blog.csdnimg.cn/direct/b1a6fce6021c421b904dcbae72e61e22.png" width="1946"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38313137313539312f:61727469636c652f64657461696c732f313436323635363931" class_="artid" style="display:none">
 </p>
</div>


