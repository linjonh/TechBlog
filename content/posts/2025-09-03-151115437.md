---
layout: post
title: "RabbitMQ高级可靠性"
date: 2025-09-03T17:02:53+0800
description: "其实就是写个配置，让发送者连接失败了就去尝试重新连接MQ。"
keywords: "RabbitMQ高级：可靠性"
categories: ['未分类']
tags: ['网络']
artid: "151115437"
arturl: "https://blog.csdn.net/2401_87663076/article/details/151115437"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151115437
    alt: "RabbitMQ高级可靠性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151115437
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151115437
cover: https://bing.ee123.net/img/rand?artid=151115437
image: https://bing.ee123.net/img/rand?artid=151115437
img: https://bing.ee123.net/img/rand?artid=151115437
---



# RabbitMQ高级：可靠性

## 发送者可靠性

#### 发送者重连

![](https://i-blog.csdnimg.cn/direct/e5d120c1c5eb433eb0ef757e6d0bf5e9.png)

        其实就是写个配置，让发送者连接失败了就去尝试重新连接MQ。

#### 发送者确认

![](https://i-blog.csdnimg.cn/direct/a3574d37be2145659c4d1f9593238b63.png)

        临时消息就是不需要写到磁盘的数据，也就是不需要持久化的数据。持久消息则反之。ACK是Publisher Confirm来返回的。

![](https://i-blog.csdnimg.cn/direct/3e07b4631c6e4aea9da94d33a367fa8e.png)

        correlated就是发送者发送消息后，直接往下走，MQ判断完是否发送成功后调用回调函数。

![](https://i-blog.csdnimg.cn/direct/08e5b8adb3914d6b90712098b69155b6.png)

```

@Test
public void testConfirmCallback() {
    //0.创建CorrelationData
    CorrelationData cd = new CorrelationData(UUID.randomUUID().toString());
    cd.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {
        @Override
        public void onFailure(Throwable ex) {
            log.error("spring amqp 处理确认结果异常", ex);
        }

        @Override
        public void onSuccess(CorrelationData.Confirm result) {
            //判断是否成功
            if (result.isAck()) {
                log.debug("收到ConfirmCallback ack，消息发送成功!");
            } else {
                log.error("收到ConfirmCallback nack，消息发送失败! reason: {}",result.getReason());
            }
        }
    });

    //1.交换机名
    String exchangeName = "hmall.fanout";
    //2.消息
    String message = "hello world";
    //3.发送消息
    rabbitTemplate.convertAndSend(exchangeName, null, message, cd);

}
```

        ConfirmCallback是针对消息的，所以每次发送都得写一个CorrelationData。这里在new CorrelationData的时候，同时也给消息指定了唯一id。这里的Future是多并发编程的知识。注意这里的onFailure不是返回nack，而是Spring处理Future异常了，nack在下面的onSuccess里。如果返回的是nack，还要重发消息，就是再用一次convertAndSend，但这里就只是记录了一下日志。不过这一块白雪呜呜呜，不用太在意。

## MQ可靠性

![](https://i-blog.csdnimg.cn/direct/a2e11a5a27e24080a3355902962d7761.png)

        当队列满了的时候，MQ会去给早发的那些消息做持久化，持久化到磁盘，给队列空出一点空间，持久化期间发送者是不能成功发送消息到队列里的。

#### 数据持久化

        其实就是把数据持久化到磁盘，但不是被动的等满了再去做，而是提前做，这样就不会导致消息堆积了。

![](https://i-blog.csdnimg.cn/direct/0875d5d99d9a4776ac969e02af3da99b.png)

        交换机和队列的持久化都是默认的，所以不用管，但是消息的持久化，你得在发消息时选择第二个Persistent。但其实Spring AMQP默认就是发持久化的消息，所以我们啥都不用管。

#### Lazy Queue

![](https://i-blog.csdnimg.cn/direct/426a19b001414cb8a944172a1467c9b8.png)

        消息队列会动态监测消费者处理消息的速度，如果速度慢，就直接从磁盘读取数据，如果发现速度很快，超过了我读取磁盘的速度，那就会提前缓存一批数据到内存。这个我们不用管，用高版本的RabbitMQ就行。

## 消费者可靠性

#### 消费者确认机制

![](https://i-blog.csdnimg.cn/direct/e3869f9b704a44a997d8edb3b53ee590.png)

        其实应该是MQ投递消息，如果返回ack或者reject，消息直接丢弃。如果返回nack，消息重新入队（requeue），然后再重新投递给消费者。

![](https://i-blog.csdnimg.cn/direct/291f275d73834f39803cb9746348b011.png)

        推荐使用auto。比如MessageConversionException，就属于消息处理异常，会返回reject。

#### 消费者失败重试

![](https://i-blog.csdnimg.cn/direct/637783ecba154d038bcc2e88c6420789.png)

        意思就是不会MQ和消费者不会来回踢皮球了。

![](https://i-blog.csdnimg.cn/direct/f8d04aee964f4f7ab340b16d14a2c4e4.png)

        第三种就是重试耗尽后，将失败消息（还包括报错信息）投递给指定的交换机(error.direct)，再给这个交换机绑定队列和消费者，就可以处理这种投递失败的消息，通知开发者介入。

![](https://i-blog.csdnimg.cn/direct/9681ba50a8194db29bdcb174d296e72b.png)

        也就是重试耗尽后，用你给的rabbitTemplate去重新投递，投递到error.direct交换机，routingKey为"error"。

```

@Configuration
public class ErrorMessageConfiguration {

    @Bean
    public DirectExchange errorExchange(){
        return new DirectExchange("error.direct");
    }

    @Bean
    public Queue errorQueue(){
        return new Queue("error.queue");
    }

    @Bean
    public Binding errorQueueBinding(Queue errorQueue,DirectExchange errorExchange){
        return BindingBuilder.bind(errorQueue).to(errorExchange).with("error");
    }

    @Bean
    public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){
        return new RepublishMessageRecoverer(rabbitTemplate,"error.direct","error");
    }
}
```

#### 业务幂等性

        为了避免消费者重复处理同一条消息影响业务的情况，需要保证业务幂等性。

![](https://i-blog.csdnimg.cn/direct/d4519769877947f49a5ef8c3ae9ebb83.png)

![](https://i-blog.csdnimg.cn/direct/1b9a26964f804dfd97b00090e23bab40.png)

        注意这里的id和之前发送者确认的那个id不一样。这个配置是在Publisher里的。

```

@RabbitListener(queues = "simple.queue")
public void listenSimpleQueue(Message message) {
    log.info("监听到simple.queue的消息:{}", new String(message.getBody()));
    log.info("监听到simple.queue的消息: ID: {}", message.getMessageProperties().getMessageId());
}
```

        然后用消费者用Message类来接受消息，因为消息转换器就是把Java对象转换为Message类的嘛。在message中就能拿到消息体和消息ID了。不过这种方法太影响性能了，不推荐......白雪。

![](https://i-blog.csdnimg.cn/direct/4b84c3e002b84af99d71afb2ce94f031.png)

        这一种就是添加业务逻辑了。比如这个支付业务，MQ发一个消息是修改订单为已支付，我去修改订单为已支付的时候，我先去查看当前订单状态，如果当前订单状态是未支付，那就说明这个消息不是重复消息；如果当前订单状态是已支付或者退款中，那就说明这个消息是重复消息，这样就保证了业务的幂等性。



