---
layout: post
title: "Leetcode32-最长有效括号深度解析"
date: 2025-03-16 12:14:07 +0800
description: "中最长的有效括号子串的长度。"
keywords: "Leetcode32 最长有效括号深度解析"
categories: ['未分类']
tags: ['数据库', 'Sql', 'Redis', 'Mysql', 'Java']
artid: "146293191"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293191
    alt: "Leetcode32-最长有效括号深度解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293191
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293191
cover: https://bing.ee123.net/img/rand?artid=146293191
image: https://bing.ee123.net/img/rand?artid=146293191
img: https://bing.ee123.net/img/rand?artid=146293191
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Leetcode32 最长有效括号深度解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     <strong>
      问题描述
     </strong>
    </h4>
    <p>
     找出字符串
     <code>
      s
     </code>
     中最长的有效括号子串的长度。
    </p>
    <h4>
     <strong>
      核心思路
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       动态规划
      </strong>
      ：定义
      <code>
       dp[i]
      </code>
      为以字符
      <code>
       s[i]
      </code>
      结尾的最长有效括号子串长度。
     </li>
     <li>
      <strong>
       分情况讨论
      </strong>
      ：根据当前字符是否为
      <code>
       )
      </code>
      以及前面的字符情况，推导状态转移方程。
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      状态转移方程详解
     </strong>
    </h4>
    <h5>
     <strong>
      Case 1：当前字符
      <code>
       )
      </code>
      与前一个字符
      <code>
       (
      </code>
      直接匹配
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：形如
       <code>
        ...()
       </code>
       的结构。
      </p>
     </li>
     <li>
      <p>
       <strong>
        转移方程
       </strong>
       ：
      </p>
      <pre><code>if (s.charAt(i-1) == '(') {
    dp[i] = dp[i-2] + 2;  // 前i-2个字符的有效长度 + 2
}
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <ul>
       <li>
        <code>
         s = "()"
        </code>
        ，当
        <code>
         i=1
        </code>
        时，
        <code>
         dp[1] = dp[-1] (视为0) + 2 = 2
        </code>
        。
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      Case 2：当前字符
      <code>
       )
      </code>
      与嵌套结构匹配
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        场景
       </strong>
       ：形如
       <code>
        ...((...))
       </code>
       的结构。
      </p>
     </li>
     <li>
      <p>
       <strong>
        转移方程
       </strong>
       ：
      </p>
      <pre><code>else if (i-dp[i-1]-1 &gt;=0 &amp;&amp; s.charAt(i-dp[i-1]-1) == '(') {
    dp[i] = dp[i-1] + 2;  // 内部有效长度 + 2
    if (i-dp[i-1]-2 &gt;=0) {
        dp[i] += dp[i-dp[i-1]-2];  // 前面独立结构的有效长度
    }
}
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        关键点
       </strong>
       ：
      </p>
      <ol>
       <li>
        <code>
         i-dp[i-1]-1
        </code>
        是当前
        <code>
         )
        </code>
        对应的
        <code>
         (
        </code>
        的位置。
       </li>
       <li>
        <code>
         dp[i-1]
        </code>
        是内部嵌套的有效长度（如
        <code>
         ()
        </code>
        的长度）。
       </li>
       <li>
        <code>
         dp[i-dp[i-1]-2]
        </code>
        是嵌套结构前面的独立有效长度（如
        <code>
         ()((...))
        </code>
        中前面的
        <code>
         ()
        </code>
        ）。
       </li>
      </ol>
     </li>
     <li>
      <p>
       <strong>
        示例
       </strong>
       ：
      </p>
      <ul>
       <li>
        <code>
         s = "(()())"
        </code>
        ，当
        <code>
         i=5
        </code>
        时：
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        dp[4] = 4
       </code>
       （对应内部
       <code>
        ()()
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <code>
        i-dp[i-1]-1 =5-4-1=0
       </code>
       ，检查
       <code>
        s[0]
       </code>
       为
       <code>
        (
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <code>
        dp[5] = 4 + 2 + dp[0] (视为0) = 6
       </code>
       。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      完整代码分析
     </strong>
    </h4>
    <pre><code>class Solution {
    public int longestValidParentheses(String s) {
        int maxLen = 0;
        int len = s.length();
        int[] dp = new int[len];
        
        for (int i = 1; i &lt; len; i++) {
            if (s.charAt(i) == ')') {
                // Case 1：直接匹配前一个'('
                if (s.charAt(i-1) == '(') {
                    dp[i] = (i &gt;= 2 ? dp[i-2] : 0) + 2;
                } 
                // Case 2：嵌套匹配前面的'('
                else if (i - dp[i-1] &gt; 0 &amp;&amp; s.charAt(i - dp[i-1] - 1) == '(') {
                    dp[i] = dp[i-1] + 2;
                    if (i - dp[i-1] - 2 &gt;= 0) {
                        dp[i] += dp[i - dp[i-1] - 2];
                    }
                }
                maxLen = Math.max(maxLen, dp[i]);
            }
        }
        return maxLen;
    }
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37333736323631322f:61727469636c652f64657461696c732f313436323933313931" class_="artid" style="display:none">
 </p>
</div>


