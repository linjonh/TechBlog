---
layout: post
title: ".NetCore-MVC"
date: 2025-09-02T01:31:03+0800
description: "/ 作用于所有包含 &quot;my-id&quot; 属性的 &lt;div&gt; 标签// 作用于所有以 &quot;my:&quot; 为前缀的标签（如 &lt;my:card&gt;）视图组件传参区域保持一致mvc的视图注入在 ASP.NET Core 中将依赖项注入到视图 | Microsoft Learn。"
keywords: ".NetCore MVC"
categories: ['未分类']
tags: ['Mvc', '.Netcore']
artid: "151078601"
arturl: "https://blog.csdn.net/m0_68206177/article/details/151078601"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151078601
    alt: ".NetCore-MVC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151078601
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151078601
cover: https://bing.ee123.net/img/rand?artid=151078601
image: https://bing.ee123.net/img/rand?artid=151078601
img: https://bing.ee123.net/img/rand?artid=151078601
---



# .NetCore MVC

这个是我自己记得笔记，最好有点基础看我的。

























---

## html 辅助标签

![](https://i-blog.csdnimg.cn/direct/a3dd5d7e47a945488c593effa9be5876.png)

![](https://i-blog.csdnimg.cn/direct/38b949a3dd7745afa9dcb2734ae592d6.png)

@html.Raw("<h1>标题</h1>")正常渲染html字符串

![](https://i-blog.csdnimg.cn/direct/4ee7a7c7c034478e924a180ae791b2b5.png)

@Html.DropList

![](https://i-blog.csdnimg.cn/direct/dc900ff7960c49ceb1ba262dcbcc0bcc.png)

![](https://i-blog.csdnimg.cn/direct/6777b7461991486c9c291d398dd29187.png)

![](https://i-blog.csdnimg.cn/direct/f81caf864c0a42799f5ad3ab5267d08f.png)

![](https://i-blog.csdnimg.cn/direct/17eb80595d134fdc890f8f552ce06491.png)

## 分布视图

使用 RenderPartialAsync 呈现分部视图。 此方法不返回 IHtmlContent。 它将呈现的输出直接流式传输到响应。 因为该方法不返回结果，所以必须在 Razor 代码块内调用它：微软推荐  
 @{  
     await Html.RenderPartialAsync("_AuthorPartial");  
 }  
 由于 RenderPartialAsync 流式传输呈现的内容，因此在某些情况下它可提供更好的性能。 在性能起关键作用的情况下，使用两种方法对页面进行基准测试，并使用生成更快响应的方法。

![](https://i-blog.csdnimg.cn/direct/3e34775358f441e383076b4fa54bdb74.png)

![](https://i-blog.csdnimg.cn/direct/cd1b338f5b654f89bc2848e1abb9f9b5.png)

分布视图通常放在当前需要用到分布视图的view文件夹下或者sharp文件夹下

![](https://i-blog.csdnimg.cn/direct/b5d5d58c792a48579c044840d58aaaae.png)

![](https://i-blog.csdnimg.cn/direct/46e38d41a3874154a860387cae776a69.png)

![](https://i-blog.csdnimg.cn/direct/74d1da570a79493e8a1f05f40dcfc0a9.png)

## JS,Css捆绑（.net5下）

.net6,7,8应该也可以用吧![](https://i-blog.csdnimg.cn/direct/609723997d974958a6d86880b68b6cab.png)

![](https://i-blog.csdnimg.cn/direct/48a08dbf22fe4aa59c54cc0a456c0bb9.png)

## 模型校验

模型上添加校验特性

![](https://i-blog.csdnimg.cn/direct/695e955f2ae246958244f9b6f71ee0df.png)

【RegularExpression("")】还可以添加 lamda表达式

@Html.ValidationMessageFor()可以显示校验错误

![](https://i-blog.csdnimg.cn/direct/ae5742620a0f404fb51cb80fc56c3ad1.png)

js引入也可以写分布视图，这样改的时候好改![](https://i-blog.csdnimg.cn/direct/c365118ecd4041679ed5edafc64de13c.png)

后端校验

![](https://i-blog.csdnimg.cn/direct/30006ab430db439d840f968f639c703b.png)

后端校验失败可以用ValidationSummary显示·传参true排除属性错误。

![](https://i-blog.csdnimg.cn/direct/a79d7d1a9fbc414abaf597d4e47c6dfd.png)

![](https://i-blog.csdnimg.cn/direct/d2e5b824dfc44da0950fca83cd5b91a0.png)

模型加上后，label不用写labeltext。

## 模型绑定

![](https://i-blog.csdnimg.cn/direct/7429ece9feae44c781da14cb1bbdcf96.png)

![](https://i-blog.csdnimg.cn/direct/2da19241f57b43efa8407638b0c49903.png)

一个对象中有另一个对象，前段想给内部对象ProductCategory的CategoryName属性赋值

![](https://i-blog.csdnimg.cn/direct/7824662f390f476ab16820329d2bda25.png)

![](https://i-blog.csdnimg.cn/direct/82e730a24f4f4e5294b8a566b0a607c9.png)

应该这样binding

![](https://i-blog.csdnimg.cn/direct/c0a4d1fd4efb4c5886f5bc80b6540aed.png)

![](https://i-blog.csdnimg.cn/direct/e8ca9cd6185a4527b0533c1d661e5f6d.png)

[Bind]可以省略，默认全部binding

![](https://i-blog.csdnimg.cn/direct/28ddf3105cc94f9b90c082526d5a0c1f.png)

## [formquery][formbody][formform]绑定

### [formquery]

![](https://i-blog.csdnimg.cn/direct/ef90859f206645f795c4c3278317aa33.png)

还可以这样

http:127.0.0.1/ControllerName/Search?startprice=1&name=互动&endprice=2

```
public ActionResult Search(int startprice, string name, int endprice)
{
    // 直接使用这三个参数进行业务处理
    // startprice 会被赋值为 1
    // name 会被赋值为 "互动"
    // endprice 会被赋值为 2
    
    return View();
}

--参数名称必须与 URL 中的查询参数名称完全一致（区分大小写）
--如果 URL 中缺少某个参数，且方法参数是值类型（如 int），会抛出异常
--若参数可能为空，建议使用可空类型，例如：

public ActionResult Search(int? startprice, string name, int? endprice)
```

不同标签可以结合，相同标签只能写一个，([formquery],[formquery])不行

下面这样query和heard可以

![](https://i-blog.csdnimg.cn/direct/852c5a0ffaf5448fb80cf3819eb472bf.png)

### [FromHeader]

header特殊可以重复

![](https://i-blog.csdnimg.cn/direct/4bd7fd73cb2b4c94989638616d0cd512.png)

![](https://i-blog.csdnimg.cn/direct/92b9dbfe9d57470296ee2f44019801b1.png)不能写中文

### [FromBody]

只能接受json，post请求

![](https://i-blog.csdnimg.cn/direct/20ae7a399428422a8aa030f46444fe15.png)

### [FromForm]

常用来表单提交

![](https://i-blog.csdnimg.cn/direct/56f0018b4eeb43cbb885e0fb3b3d3d12.png)

![](https://i-blog.csdnimg.cn/direct/5c1f48960fbb43f6aa7b953d7a30e17e.png)

### [FormRoute]

获取路由参数

```
[HttpGet("{id}/{name}")]
public IActionResult GetData(int id, string name)
{
    // 直接使用 id 和 name 参数
    return Ok($"ID: {id}, Name: {name}");
}
此时，访问 api/控制器名/123/测试 会自动将：

123 绑定到 id 参数
测试 绑定到 name 参数

```

```
2. 使用 [FromRoute] 特性（显式指定）
如果参数名与路由占位符不一致，或为了代码更清晰，可以使用 [FromRoute] 特性显式指定绑定来源：

csharp
[HttpGet("{id}/{name}")]
public IActionResult GetData(
    [FromRoute(Name = "id")] int dataId,  // 绑定路由中的 id 到 dataId 参数
    [FromRoute(Name = "name")] string userName)  // 绑定路由中的 name 到 userName 参数
{
    return Ok($"DataID: {dataId}, UserName: {userName}");
}

3. 使用复杂类型接收
如果参数较多，也可以定义一个类来接收所有路由参数：

csharp
public class MyRequest
{
    public int Id { get; set; }
    public string Name { get; set; }
}

[HttpGet("{id}/{name}")]
public IActionResult GetData([FromRoute] MyRequest request)
{
    return Ok($"ID: {request.Id}, Name: {request.Name}");
}


注意事项：
路由模板中的占位符名称（id、name）必须与参数名（或 [FromRoute(Name)] 指定的名称）完全匹配
参数类型会自动转换（如字符串 "123" 转换为 int 123），转换失败会返回 400 错误
若需要可选参数，可在路由模板中使用 ? 标记（如 {id?}），并将参数设为可空类型（如 int? id）
```

## layout布局

![](https://i-blog.csdnimg.cn/direct/c169d0fd169d41b8ba806214ed0330c3.png)

![](https://i-blog.csdnimg.cn/direct/0c08555b311c4232b6851356d6bec962.png)

## _ViewStatrt.cshtml

通常view.cshtml,如果你想对全部的cshtml起作用就放在Shared文件夹，对特定的，如HomeController对应的Home文件下的cshtml起作用，不想让其他文件用，就放在Views/Home文件夹下，就近原则。

![](https://i-blog.csdnimg.cn/direct/48651f8e47a9421a823f934dcff4fcfb.png)

例如

![](https://i-blog.csdnimg.cn/direct/5366118195be47238bfa32837fcbba44.png)

![](https://i-blog.csdnimg.cn/direct/22e48c9dc646419bb96f2dc7ab60545e.png)

## _ViewImport.cshtml

![](https://i-blog.csdnimg.cn/direct/74e8ef8e715d4a3498c98f583b7f5331.png)

## 标签助手

推荐使用标签助手代替html辅助标签

@addtaghelpers *，使Microsoft.AspNetCore.mvc.TagHelpers 类在我们所有 Razor 视图中可用

![](https://i-blog.csdnimg.cn/direct/64d7f6634b57424d9c684e4ac856611d.png)

可以用了

![](https://i-blog.csdnimg.cn/direct/38026ce126504289b3104721eeed16b9.png)

### 怎么用

这个图很好解释了

![](https://i-blog.csdnimg.cn/direct/d075094ba59f486187f2265ae8406c4b.png)![](https://i-blog.csdnimg.cn/direct/66683b7c47d44d0a8e4bd152f32f83dc.png)

![](https://i-blog.csdnimg.cn/direct/1907fc30454e4f5fb133c2c290348dba.png)

![](https://i-blog.csdnimg.cn/direct/25ae7a7b7a1d4ee6a8fcdd994095bda9.png)

![](https://i-blog.csdnimg.cn/direct/6a7f0df4d660404db6a0488f8e9ffef1.png)

![](https://i-blog.csdnimg.cn/direct/6a30272a58c6499f8efc2ad76055c366.png)

![](https://i-blog.csdnimg.cn/direct/dcfe3677fc694d2bb0cfb53fb2506548.png)

![](https://i-blog.csdnimg.cn/direct/0a2a7cbb082844b3999f52d2a5fa5ab3.png)

![](https://i-blog.csdnimg.cn/direct/2c74148dd3f8446eacd1252318a94494.png)

```
<partial name="Shared/_ProductPartial.cshtml" for="Product">

model 属性分配模型实例，以传递到分部视图。model 属性不能与 for 属性一起使用。

在以下标记中，实例化新的 Product 对象并将其传递给 model 属性进行绑定：

<partial name="_ProductPartial" model='new Product { Number = 1, Name = "Test product", Description = "This is a test" }'>
```



```
view-data 属性分配 ViewDataDictionary，以传递到分部视图。以下标记使整个 ViewData 集合可访问分部视图：

@{
    ViewData["IsNumberReadOnly"] = true;
}
<partial name="_ProductViewDataPartial" for="Product" view-data="ViewData">
在前面的代码中，IsNumberReadOnly 键值设置为 true 并添加到 ViewData 集合中。因此，在以下分部视图中可访问 ViewData["IsNumberReadOnly"]：

@model TagHelpersBuiltIn.Models.Product
<div class="form-group">
    <label asp-for="Number"></label>
    @if ((bool)ViewData["IsNumberReadOnly"])
    {
        <input asp-for="Number" type="number" class="form-control" readonly />
    }
    else
    {
        <input asp-for="Number" type="number" class="form-control" />
    }
</div>
<div class="form-group">
    <label asp-for="Name"></label>
    <input asp-for="Name" type="text" class="form-control" />
</div>
<div class="form-group">
    <label asp-for="Description"></label>
    <textarea asp-for="Description" rows="4" cols="50" class="form-control"></textarea>
</div>
```

### 自定义标签助手

#### 定义

推荐看例子

![](https://i-blog.csdnimg.cn/direct/5754334c3b2948728cda92198747ed64.png)

![](https://i-blog.csdnimg.cn/direct/417c3185785740f3a11cf94a299d55ac.png)

![](https://i-blog.csdnimg.cn/direct/65f3b225a434485ea18ebd8a04a472e5.png)

![](https://i-blog.csdnimg.cn/direct/7013896bd8354e5cb2e7600011cc99e6.png)

```
// 作用于所有包含 "my-id" 属性的 <div> 标签

[HtmlTargetElement("div", Attributes = "my-id")]

// 作用于所有以 "my:" 为前缀的标签（如 <my:card>）
[HtmlTargetElement("", TagStructure = TagStructure.NormalOrSelfClosing, Prefix = "my")]
```

![](https://i-blog.csdnimg.cn/direct/498e32264f4c4873821c25a5f509effa.png)

#### 例子

##### 创建新标签

```
using Microsoft.AspNetCore.Razor.TagHelpers;
using System;
using System.Threading.Tasks;

[HtmlTargetElement("current-time")]
public class TimeTagHelper : TagHelper
{
    [HtmlAttributeName("format")]
    public string Format { get; set; } = "yyyy-MM-dd HH:mm:ss";

    public override Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        // 显式指定输出为 <span> 标签（关键修正）
        output.TagName = "span";
        
        // 设置内容
        var currentTime = DateTime.Now.ToString(Format);
        output.Content.SetContent(currentTime);
        
        // 添加样式类
        output.Attributes.SetAttribute("class", "time-display");
        
        return Task.CompletedTask;
    }
}
```

2

```
在 _ViewImports.cshtml 中添加命名空间引用（确保与标签助手类的命名空间一致）
@addTagHelper *, 你的项目名称
```

3

```
<!-- 使用默认格式 -->
<current-time></current-time>

<!-- 自定义格式 -->
<current-time format="yyyy年MM月dd日"></current-time>

<span class="time-display">2025-09-05 14:30:00</span>
<span class="time-display">2025年09月05日</span>
```

```
关键知识点解析
标签命名：
通过 [HtmlTargetElement("标签名")] 定义标签名称
支持匹配现有标签（如 [HtmlTargetElement("a")] 可增强 <a> 标签）

属性绑定：
使用 [HtmlAttributeName("属性名")] 定义标签可接受的属性
属性值会自动绑定到类的对应属性

输出控制：
TagHelperOutput 对象用于控制最终输出的 HTML
可以修改标签名称（output.TagName = "div"）、添加属性、设置内容等

生命周期方法：
重写 Process() 或 ProcessAsync() 方法实现核心逻辑
异步操作优先使用 ProcessAsync()
```

##### 增强现有标签

```
[HtmlTargetElement("a", Attributes = "external")]
public class ExternalLinkTagHelper : TagHelper
{
    // 匹配标签中的 external 属性（无需值，存在即可）
    [HtmlAttributeName("external")]
    public bool IsExternal { get; set; }

    public override void Process(TagHelperContext context, TagHelperOutput output)
    {
        if (IsExternal)
        {
            output.Attributes.SetAttribute("target", "_blank");
            output.Attributes.SetAttribute("rel", "noopener noreferrer");
        }
    }
}
```

```
<!-- 浏览器会自动添加 target 和 rel 属性 -->
<a href="https://example.com" external>外部链接</a>
```

```
更多输出控制示例：
csharp
// 1. 输出为 div 标签
output.TagName = "div";

// 2. 移除标签，只输出内容（无外层标签）
output.TagName = null;

// 3. 添加自定义属性
output.Attributes.Add("data-time", DateTime.Now.Ticks);

// 4. 修改或移除原有属性
output.Attributes.RemoveAll("format"); // 移除传入的format属性，避免输出到HTML

// 5. 设置标签内部的HTML（注意XSS风险）
output.Content.SetHtmlContent($"<strong>{currentTime}</strong>");


通过这些控制，你可以完全自定义标签助手最终生成的 HTML 结构，让自定义标签既易用又符合标准 HTML 规范。
```

## 视图组件

![](https://i-blog.csdnimg.cn/direct/732a3196b362490a813b359920e21d9f.png)![](https://i-blog.csdnimg.cn/direct/ea8326d77f7849adae9324002baf64f3.png)

第二种我不行

![](https://i-blog.csdnimg.cn/direct/800d75c0d60444ed8a30258e4aeb8c66.png)

传参

![](https://i-blog.csdnimg.cn/direct/f3dcd45dba4741fab28616b07c7edddf.png)

![](https://i-blog.csdnimg.cn/direct/239e986b89164c328c5f675a8fad1ab5.png)

区域

建一个文件夹，鼠标添加区域，MVC里的

红框内保持一致

![](https://i-blog.csdnimg.cn/direct/7065c7aac70b446da4f96500c7a10c34.png)

mvc的视图注入[在 ASP.NET Core 中将依赖项注入到视图 | Microsoft Learn](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/dependency-injection?view=aspnetcore-9.0 "在 ASP.NET Core 中将依赖项注入到视图 | Microsoft Learn")



