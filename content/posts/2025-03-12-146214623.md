---
layout: post
title: "力扣hot100_二叉树"
date: 2025-03-12 20:48:45 +0800
description: "（2）当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root；中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（（3）当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right。**输入：**root = [1,2,3,4,null,null,null,5]"
keywords: "力扣hot100_二叉树"
categories: ['未分类']
tags: ['算法', '数据结构', 'Leetcode']
artid: "146214623"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146214623
    alt: "力扣hot100_二叉树"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146214623
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146214623
cover: https://bing.ee123.net/img/rand?artid=146214623
image: https://bing.ee123.net/img/rand?artid=146214623
img: https://bing.ee123.net/img/rand?artid=146214623
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     力扣hot100_二叉树
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     二叉树的建立与遍历
    </h3>
    <pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

// 定义二叉树节点
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 函数：根据层次遍历结果构建二叉树
TreeNode* buildTree(const vector&lt;int*&gt;&amp; nodes) {
    if (nodes.empty() || nodes[0] == nullptr) return nullptr;

    // 创建根节点
    TreeNode* root = new TreeNode(*nodes[0]);
    queue&lt;TreeNode*&gt; q;
    q.push(root);

    int i = 1; // 用于遍历输入数组
    while (!q.empty() &amp;&amp; i &lt; nodes.size()) {
        TreeNode* current = q.front();
        q.pop();

        // 创建左子节点
        if (i &lt; nodes.size() &amp;&amp; nodes[i] != nullptr) {
            current-&gt;left = new TreeNode(*nodes[i]);
            q.push(current-&gt;left);
        }
        i++;

        // 创建右子节点
        if (i &lt; nodes.size() &amp;&amp; nodes[i] != nullptr) {
            current-&gt;right = new TreeNode(*nodes[i]);
            q.push(current-&gt;right);
        }
        i++;
    }

    return root;
}

// 辅助函数：打印二叉树（层次遍历）
void printTree(TreeNode* root) {
    if (!root) return;

    queue&lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        if (node) {
            cout &lt;&lt; node-&gt;val &lt;&lt; " ";
            q.push(node-&gt;left);
            q.push(node-&gt;right);
        } else {
            cout &lt;&lt; "null ";
        }
    }
    cout &lt;&lt; endl;
}

int main() {
    // 输入层次遍历结果
    vector&lt;int&gt; input = {1, 2, 3, -1, 5, -1, 4}; // 使用 -1 表示 null
    vector&lt;int*&gt; nodes;
    for (int val : input) {
        nodes.push_back(val == -1 ? nullptr : new int(val));
    }

    // 构建二叉树
    TreeNode* root = buildTree(nodes);

    // 打印构建的二叉树
    cout &lt;&lt; "构建的二叉树层次遍历结果为：" &lt;&lt; endl;
    printTree(root);

    return 0;
}
</code></pre>
    <h3>
     <a id="hot100_94_89">
     </a>
     hot100_94.二叉树的中序遍历
    </h3>
    <pre><code class="prism language-c++">class Solution {
public:
    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res) {
        if (!root) {
            return;
        }
        inorder(root-&gt;left, res);
        res.push_back(root-&gt;val);
        inorder(root-&gt;right, res);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        inorder(root, res);
        return res;
    }
};
</code></pre>
    <h3>
     <a id="hot100_102_110">
     </a>
     hot100_102.二叉树的层序遍历
    </h3>
    <p>
     给你二叉树的根节点
     <code>
      root
     </code>
     ，返回其节点值的
     <strong>
      层序遍历
     </strong>
     。 （即逐层地，从左到右访问所有节点）。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/3c57654c17d08ae170315f444c8ba119.jpeg"/>
    </p>
    <pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：root = [1]
输出：[[1]]
</code></pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><code>输入：root = []
输出：[]
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res = {};
        if(root == nullptr)   return res;
        queue&lt;TreeNode*&gt; Q;
        Q.push(root);
        while(!Q.empty()){
            int k = Q.size();
            res.push_back(vector&lt;int&gt;{});
            for(int i = 0; i &lt; k ; i++){
                TreeNode *temp = Q.front();
                res.back().push_back(temp-&gt;val);
                if(temp-&gt;left!=nullptr) Q.push(temp-&gt;left);
                if(temp-&gt;right!=nullptr) Q.push(temp-&gt;right); 
                Q.pop();
            }
            
        }
        return res;
    }
};
</code></pre>
    <h3>
     <a id="hot100_199_164">
     </a>
     hot100_199.二叉树的右视图
    </h3>
    <p>
     给定一个二叉树的
     <strong>
      根节点
     </strong>
     <code>
      root
     </code>
     ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     **输入：**root = [1,2,3,null,5,null,4]
    </p>
    <p>
     <strong>
      输出：
     </strong>
     [1,3,4]
    </p>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/7154d53a19662a94f1069776ac1124cc.png"/>
    </p>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     **输入：**root = [1,2,3,4,null,null,null,5]
    </p>
    <p>
     <strong>
      输出：
     </strong>
     [1,3,4,5]
    </p>
    <p>
     <strong>
      解释：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/6b5c35f1a17e0ab03bdd6d14c4749d06.png"/>
    </p>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <p>
     **输入：**root = [1,null,3]
    </p>
    <p>
     <strong>
      输出：
     </strong>
     [1,3]
    </p>
    <p>
     <strong>
      示例 4：
     </strong>
    </p>
    <p>
     **输入：**root = []
    </p>
    <p>
     <strong>
      输出：
     </strong>
     []
    </p>
    <pre><code class="prism language-c++">class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res = levelOrder(root);
        vector&lt;int&gt; result;
        for(int i=0; i&lt;res.size(); i++){
            result.push_back(res[i].back());
        }
        return result;
    }
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res = {};
        if(root == nullptr)   return res;
        queue&lt;TreeNode*&gt; Q;
        Q.push(root);
        while(!Q.empty()){
            int k = Q.size();
            res.push_back(vector&lt;int&gt;{});
            for(int i = 0; i &lt; k ; i++){
                TreeNode *temp = Q.front();
                res.back().push_back(temp-&gt;val);
                if(temp-&gt;left!=nullptr) Q.push(temp-&gt;left);
                if(temp-&gt;right!=nullptr) Q.push(temp-&gt;right); 
                Q.pop();
            }
            
        }
        return res;
    }
};
</code></pre>
    <h3>
     <a id="hot100_114_233">
     </a>
     hot100_114.二叉树展开为链表
    </h3>
    <p>
     给你二叉树的根结点
     <code>
      root
     </code>
     ，请你将它展开为一个单链表：
    </p>
    <ul>
     <li>
      展开后的单链表应该同样使用TreeNode，其中right子指针指向链表中下一个结点，而左子指针始终null
     </li>
     <li>
      展开后的单链表应该与二叉树
      <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" rel="nofollow">
       <strong>
        先序遍历
       </strong>
      </a>
      顺序相同。
     </li>
    </ul>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/f395f889b2b21dc2bd265713d3228b87.jpeg"/>
    </p>
    <pre><code>输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：root = []
输出：[]
</code></pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><code>输入：root = [0]
输出：[0]
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    void flatten(TreeNode* root) {
        vector&lt;TreeNode*&gt; l;
        preorderTraversal(root, l);
        int n = l.size();
        for (int i = 1; i &lt; n; i++) {
            l[i-1]-&gt;left = nullptr;
            l[i-1]-&gt;right = l[i];
        }
    }

    void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) {
        if (root != NULL) {
            l.push_back(root);
            preorderTraversal(root-&gt;left, l);
            preorderTraversal(root-&gt;right, l);
        }
    }
};

</code></pre>
    <h3>
     <a id="hot100_105_287">
     </a>
     hot100_105.从前序和中序遍历序列构造二叉树
    </h3>
    <p>
     给定两个整数数组
     <code>
      preorder
     </code>
     和
     <code>
      inorder
     </code>
     ，其中
     <code>
      preorder
     </code>
     是二叉树的
     <strong>
      先序遍历
     </strong>
     ，
     <code>
      inorder
     </code>
     是同一棵树的
     <strong>
      中序遍历
     </strong>
     ，请构造二叉树并返回其根节点。
    </p>
    <p>
     <strong>
      示例 1:
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/2a5f00074985f29c8c690b5cd7a641f9.jpeg"/>
    </p>
    <pre><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
</code></pre>
    <p>
     <strong>
      示例 2:
     </strong>
    </p>
    <pre><code>输入: preorder = [-1], inorder = [-1]
输出: [-1]
</code></pre>
    <pre><code class="prism language-c++">class Solution{
	private:
		unordered_map&lt;int, int&gt; indexMap;
        int i;
	public:
		TreeNode* myBuildTree(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; in, int l, int r){         
			if(l &gt; r || i &gt;= pre.size()) return nullptr;
			TreeNode *root = new TreeNode;
            root-&gt;val = pre[i];
			int k = indexMap[pre[i]];//定位根节点在中序序列中的下标
            i++;
			root-&gt;left = myBuildTree(pre, in, l, k-1);//[l,k-1]为左子树的范围
			root-&gt;right = myBuildTree(pre, in, k+1, r);//[k+1,r]为右子树的范围
			return root;

		} 
		TreeNode* buildTree(vector&lt;int&gt;&amp; preOrder, vector&lt;int&gt;&amp; inOrder){
			for(int k = 0; k &lt; inOrder.size(); k++){
				indexMap[inOrder[k]] = k;
			}
            i = 0;
			return myBuildTree(preOrder, inOrder, 0, preOrder.size());
		} 
};
</code></pre>
    <h3>
     <a id="hot100_104_334">
     </a>
     hot100_104.二叉树的最大深度
    </h3>
    <p>
     给定一个二叉树
     <code>
      root
     </code>
     ，返回其最大深度。
    </p>
    <p>
     二叉树的
     <strong>
      最大深度
     </strong>
     是指从根节点到最远叶子节点的最长路径上的节点数。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/a5696169c9b95904c01e33c72c7e405c.jpeg"/>
    </p>
    <pre><code>输入：root = [3,9,20,null,null,15,7]
输出：3
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：root = [1,null,2]
输出：2
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;
    }
};

</code></pre>
    <h3>
     <a id="hot100_226_369">
     </a>
     hot100_226.翻转二叉树
    </h3>
    <p>
     给你一棵二叉树的根节点
     <code>
      root
     </code>
     ，翻转这棵二叉树，并返回其根节点。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/202c8e91cf008357f1b1ac160df6dc53.jpeg"/>
    </p>
    <pre><code>输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/a989f34c0c3e37714cdc2b192d0cd4a8.jpeg"/>
    </p>
    <pre><code>输入：root = [2,1,3]
输出：[2,3,1]
</code></pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><code>输入：root = []
输出：[]
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        TreeNode* left = invertTree(root-&gt;left);
        TreeNode* right = invertTree(root-&gt;right);
        root-&gt;left = right;
        root-&gt;right = left;
        return root;
    }
};
</code></pre>
    <h3>
     <a id="hot100_101_414">
     </a>
     hot100_101.对称二叉树
    </h3>
    <p>
     给你一个二叉树的根节点
     <code>
      root
     </code>
     ， 检查它是否轴对称。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/38f9e0f5c9117b9fbcf96e96a15b902e.png"/>
    </p>
    <pre><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/2866f60094ef71227d715b88845882aa.png"/>
    </p>
    <pre><code>输入：root = [1,2,2,null,3,null,3]
输出：false
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p &amp;&amp; !q) return true;
        if (!p || !q) return false;
        return p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root-&gt;left, root-&gt;right);
    }
};
</code></pre>
    <h3>
     <a id="hot100_543_451">
     </a>
     hot100_543.二叉树的直径
    </h3>
    <p>
     给你一棵二叉树的根节点，返回该树的
     <strong>
      直径
     </strong>
     。二叉树的
     <strong>
      直径
     </strong>
     是指树中任意两个节点之间最长路径的
     <strong>
      长度
     </strong>
     。这条路径可能经过也可能不经过根节点
     <code>
      root
     </code>
     。
    </p>
    <p>
     两节点之间路径的
     <strong>
      长度
     </strong>
     由它们之间边数表示。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/acf8a86e7661e9f19dfafcc2bd541bf5.jpeg"/>
    </p>
    <pre><code>输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：root = [1,2]
输出：1
</code></pre>
    <pre><code class="prism language-c++">class Solution {
    int ans;
    int depth(TreeNode* rt){
        if (rt == NULL) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(rt-&gt;left); // 左儿子为根的子树的深度
        int R = depth(rt-&gt;right); // 右儿子为根的子树的深度
        ans = max(ans, L + R + 1); // 计算d_node即L+R+1 并更新ans
        return max(L, R) + 1; // 返回该节点为根的子树的深度
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
};
</code></pre>
    <h3>
     <a id="hot100_108_495">
     </a>
     hot100_108.将有序数组转换为二叉搜索树
    </h3>
    <p>
     给你一个整数数组
     <code>
      nums
     </code>
     ，其中元素已经按
     <strong>
      升序
     </strong>
     排列，请你将其转换为一棵 平衡 二叉搜索树。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/696708407b717f48a02e82046b8b3e23.jpeg"/>
    </p>
    <pre><code>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/62403053594893e4140629d2a91943da.jpeg"/>
    </p>
    <pre><code>输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        return helper(nums, 0, nums.size()-1); 
    }

    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right) {
//       cout &lt;&lt; left &lt;&lt;" " &lt;&lt; right &lt;&lt;endl;
	   if(right &lt; left)	return nullptr;
       int mid = (right + left)/2;
       TreeNode *root = new TreeNode;
       root-&gt;val = nums[mid];
       root-&gt;left = helper(nums, left, mid - 1);
       root-&gt;right = helper(nums, mid + 1, right);
       return root;
    }
};
</code></pre>
    <h3>
     <a id="hot100_98_539">
     </a>
     hot100_98.验证二叉搜索树
    </h3>
    <p>
     给你一个二叉树的根节点
     <code>
      root
     </code>
     ，判断其是否是一个有效的二叉搜索树。
     <strong>
      有效
     </strong>
     二叉搜索树定义如下：
    </p>
    <ul>
     <li>
      节点的左子树只包含
      <strong>
       小于
      </strong>
      当前节点的数。
     </li>
     <li>
      节点的右子树只包含
      <strong>
       大于
      </strong>
      当前节点的数。
     </li>
     <li>
      所有左子树和右子树自身必须也是二叉搜索树。
     </li>
    </ul>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/4e5ffde1eb3a8712bf40f416151ebe5a.jpeg"/>
    </p>
    <pre><code>输入：root = [2,1,3]
输出：true
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/8f9bced1a198bb8c526eb72fb07e6e61.jpeg"/>
    </p>
    <pre><code>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) {
            return false;
        }
        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
</code></pre>
    <h3>
     <a id="hot100_230K_584">
     </a>
     hot100_230.二叉搜索树中第K小元素
    </h3>
    <p>
     给定一个二叉搜索树的根节点
     <code>
      root
     </code>
     ，和一个整数
     <code>
      k
     </code>
     ，请你设计一个算法查找其中第
     <code>
      k
     </code>
     小的元素（从 1 开始计数）。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/1947ca231492e9e9fed293a1c836c0e1.jpeg"/>
    </p>
    <pre><code>输入：root = [3,1,4,null,2], k = 1
输出：1
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/6c3584bb31fb40fed06fe3f69912070f.jpeg"/>
    </p>
    <pre><code>输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
</code></pre>
    <pre><code class="prism language-c++">class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack&lt;TreeNode *&gt; stack;
        while (root != nullptr || stack.size() &gt; 0) {
            while (root != nullptr) {
                stack.push(root);
                root = root-&gt;left;
            }
            root = stack.top();
            stack.pop();
            --k;
            if (k == 0) {
                break;
            }
            root = root-&gt;right;
        }
        return root-&gt;val;
    }
};
</code></pre>
    <h3>
     <a id="hot100_4373_631">
     </a>
     hot100_437.路径总和3
    </h3>
    <p>
     给定一个二叉树的根节点
     <code>
      root
     </code>
     ，和一个整数
     <code>
      targetSum
     </code>
     ，求该二叉树里节点值之和等于
     <code>
      targetSum
     </code>
     的
     <strong>
      路径
     </strong>
     的数目。
     <strong>
      路径
     </strong>
     不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/e3b3a1a38e4329b04d7c16bedfd54a48.jpeg"/>
    </p>
    <pre><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
</code></pre>
    <p>
     <strong>
      提示:
     </strong>
    </p>
    <ul>
     <li>
      <pre><code>二叉树的节点个数的范围是[0,1000]
</code></pre>
     </li>
     <li>
      <pre><code>-109 &lt;= Node.val &lt;= 109
</code></pre>
     </li>
     <li>
      <pre><code>-1000 &lt;= targetSum &lt;= 1000
</code></pre>
      <pre><code class="prism language-c++">class Solution {
private:
int count;
unordered_map&lt;long long, int&gt; hashMap;//&lt;前缀和,出现次数&gt;
int target;
public:
    void dfs(TreeNode* root, long long sum){
        if (root == nullptr)    return;
        sum += root-&gt;val; //计算当前前缀和
        if(hashMap.find(sum - target) != hashMap.end()){
            //如果hash表中存在当前前缀和a减去目标和的前缀和b，及存在目标路径
            //路径就是当前节点到前缀和为b之间
            count += hashMap[sum - target];
        }
        hashMap[sum] ++;//更新出现的前缀和以及次数
        dfs(root-&gt;left, sum);
        dfs(root-&gt;right, sum);
        //当遍历了一个节点的左右子树后，需要把当前节点的前缀和次数-1
        hashMap[sum]--;
    }
    int pathSum(TreeNode* root, int targetSum) {
        count = 0;
        target = targetSum;
        hashMap.clear();
        hashMap[0] = 1; //插入前缀和为0出现的次数为1
        dfs(root, 0);
        return count;
    }
    
};
</code></pre>
      <h4>
       <a id="hot100_560K_699">
       </a>
       <strong>
        hot100_560.和为K的子数组
       </strong>
       类似
      </h4>
      <p>
       给你一个整数数组
       <code>
        nums
       </code>
       和一个整数
       <code>
        k
       </code>
       ，请你统计并返回
       <em>
        该数组中和为
        <code>
         k
        </code>
        的子数组的个数
       </em>
       。子数组是数组中元素的连续非空序列。
      </p>
      <p>
       <strong>
        示例 1：
       </strong>
      </p>
      <pre><code>输入：nums = [1,1,1], k = 2
输出：2
</code></pre>
      <p>
       <strong>
        示例 2：
       </strong>
      </p>
      <pre><code>输入：nums = [1,2,3], k = 3
输出：2
</code></pre>
     </li>
    </ul>
    <pre><code class="prism language-c++">class Solution{
	public:
		int subarraySum(vector&lt;int&gt;&amp; nums, int k){
		unordered_map&lt;int, int&gt; hashMap;
        hashMap[0] = 1;
        int count = 0; // 记录满足条件的子数组个数
        int prefixSum = 0;  // 初始化前缀和
        for (int num : nums) {
            prefixSum += num; // 计算当前的前缀和
            // 检查是否存在 prefix_sum - k 的前缀和
            if (hashMap.find(prefixSum - k) != hashMap.end()) {
                count += hashMap[prefixSum - k]; // 加上满足条件的前缀和个数
            }
            hashMap[prefixSum]++; // 更新哈希表中的当前前缀和出现次数
        }
			return count;
		}
};
</code></pre>
    <h3>
     <a id="hot100_236_740">
     </a>
     hot100_236.二叉树的最近公共祖先
    </h3>
    <p>
     给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
    </p>
    <p>
     <a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" rel="nofollow">
      百度百科
     </a>
     中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（
     <strong>
      一个节点也可以是它自己的祖先
     </strong>
     ）。”
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/d65ea4ee175311b5c2449f8ea1d73c7c.png"/>
    </p>
    <pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/1c93536fbbed4b8ddbeea6145971698a.png"/>
    </p>
    <pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
</code></pre>
    <p>
     <strong>
      示例 3：
     </strong>
    </p>
    <pre><code>输入：root = [1,2], p = 1, q = 2
输出：1
</code></pre>
    <p>
     <strong>
      提示：
     </strong>
    </p>
    <ul>
     <li>
      <pre><code>树中节点数目在范围[2, 105]内。
</code></pre>
     </li>
     <li>
      <pre><code>-109 &lt;= Node.val &lt;= 109
</code></pre>
     </li>
     <li>
      <pre><code>所有Node.val互不相同。
</code></pre>
     </li>
     <li>
      <pre><code>p != q
</code></pre>
     </li>
     <li>
      <pre><code>`p` 和 `q` 均存在于给定的二叉树中。
</code></pre>
      <h4>
       <a id="_795">
       </a>
       思路：
      </h4>
      <ol>
       <li>
        <p>
         <strong>
          终止条件：
         </strong>
         <br/>
         当越过叶节点，则直接返回 null ；
         <br/>
         当 root 等于 p,q ，则直接返回 root ；
        </p>
       </li>
       <li>
        <p>
         <strong>
          递推：
         </strong>
        </p>
        <p>
         递归左子节点，返回值记为 left ；
         <br/>
         递归右子节点，返回值记为 right ；
        </p>
       </li>
       <li>
        <p>
         <strong>
          返回值
         </strong>
         ： 根据 left 和 right ，可展开为四种情况；
         <br/>
         （1）当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；
         <br/>
         （2）当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
         <br/>
         （3）当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：
         <br/>
         3.1 p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ；
         <br/>
         3.2 p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；
         <br/>
         （4）当 left 不为空 ， right 为空 ：与情况 3. 同理；
        </p>
       </li>
      </ol>
     </li>
    </ul>
    <pre><code class="prism language-c++">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);
        if(left == nullptr &amp;&amp; right == nullptr) return nullptr; // 1.
        if(left == nullptr) return right; // 3.
        if(right == nullptr) return left; // 4.
        return root; // 2. if(left != null and right != null)
    }
};
</code></pre>
    <h3>
     <a id="hot100_124_831">
     </a>
     hot100_124.二叉树中的最大路径和
    </h3>
    <p>
     二叉树中的
     <strong>
      路径
     </strong>
     被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中
     <strong>
      至多出现一次
     </strong>
     。该路径
     <strong>
      至少包含一个
     </strong>
     节点，且不一定经过根节点。
    </p>
    <p>
     <strong>
      路径和
     </strong>
     是路径中各节点值的总和。
    </p>
    <p>
     给你一个二叉树的根节点
     <code>
      root
     </code>
     ，返回其
     <strong>
      最大路径和
     </strong>
     。
    </p>
    <p>
     <strong>
      示例 1：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/76057f1f5df55bed3f7b13734c10f79e.jpeg"/>
    </p>
    <pre><code>输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6
</code></pre>
    <p>
     <strong>
      示例 2：
     </strong>
    </p>
    <p>
     <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/9f9698798722882372d0c3fde7ef44ce.jpeg"/>
    </p>
    <pre><code>输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
</code></pre>
    <pre><code class="prism language-c++">class Solution {
private:
    int maxSum = INT_MIN;

public:
    int maxGain(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = max(maxGain(node-&gt;left), 0);
        int rightGain = max(maxGain(node-&gt;right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node-&gt;val + leftGain + rightGain;

        // 更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node-&gt;val + max(leftGain, rightGain);
    }

    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return maxSum;
    }
};
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34373131333936302f:61727469636c652f64657461696c732f313436323134363233" class_="artid" style="display:none">
 </p>
</div>


