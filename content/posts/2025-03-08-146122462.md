---
layout: post
title: "手写一个Tomcat"
date: 2025-03-08 21:17:02 +0800
description: "Tomcat 是一个广泛使用的开源 Java Servlet 容器，用于运行 Java Web 应用程序。虽然 Tomcat 本身功能强大且复杂，但通过手写一个简易版的 Tomcat，我们可以更好地理解其核心工作原理。本文将带你一步步实现一个简易版的 Tomcat，并深入探讨其核心组件和运行机制。"
keywords: "手写一个Tomcat"
categories: ['未分类']
tags: ['Tomcat', 'Java']
artid: "146122462"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146122462
    alt: "手写一个Tomcat"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146122462
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146122462
cover: https://bing.ee123.net/img/rand?artid=146122462
image: https://bing.ee123.net/img/rand?artid=146122462
img: https://bing.ee123.net/img/rand?artid=146122462
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     手写一个Tomcat
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Tomcat 是一个广泛使用的开源 Java Servlet 容器，用于运行 Java Web 应用程序。虽然 Tomcat 本身功能强大且复杂，但通过手写一个简易版的 Tomcat，我们可以更好地理解其核心工作原理。本文将带你一步步实现一个简易版的 Tomcat，并深入探讨其核心组件和运行机制。
    </p>
    <h3>
     <img alt="" height="449" src="https://i-blog.csdnimg.cn/direct/5f715a42003f4efa82223f586dffe12b.png" width="1035"/>
    </h3>
    <h3>
     一、项目概述
    </h3>
    <p>
     Tomcat是一个简易的Java Web服务器，它能够处理HTTP请求并调用相应的Servlet进行处理。项目的
     <strong>
      核心功能
     </strong>
     包括：
    </p>
    <ul>
     <li>
      <p>
       监听HTTP请求并解析请求内容。
      </p>
     </li>
     <li>
      <p>
       根据请求路径调用相应的Servlet。
      </p>
     </li>
     <li>
      <p>
       支持GET和POST请求方法。
      </p>
     </li>
     <li>
      <p>
       使用注解配置Servlet的URL映射。
      </p>
     </li>
     <li>
      <p>
       通过反射机制动态加载Servlet类。
      </p>
     </li>
    </ul>
    <h3>
     <strong>
      二、项目结构
     </strong>
    </h3>
    <p>
     <strong>
      首先，我们来看一下项目的整体结构：
     </strong>
    </p>
    <p>
     <img alt="" height="400" src="https://i-blog.csdnimg.cn/direct/d601448d482e4ebe9cb704ed91fa8c1e.png" width="312"/>
    </p>
    <p>
     <strong>
      项目的主要类及其功能如下：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        ResponseUtil
       </strong>
       ：用于生成HTTP响应头。
      </p>
     </li>
     <li>
      <p>
       <strong>
        SearchClassUtil
       </strong>
       ：扫描指定包下的类文件，获取类的全限定名。
      </p>
     </li>
     <li>
      <p>
       <strong>
        WebServlet
       </strong>
       ：自定义注解，用于标记Servlet并指定URL映射。
      </p>
     </li>
     <li>
      <p>
       <strong>
        LoginServlet
       </strong>
       和
       <strong>
        ShowServlet
       </strong>
       ：具体的Servlet实现类，处理不同的HTTP请求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        HttpServletRequest
       </strong>
       和
       <strong>
        HttpServletResponse
       </strong>
       ：模拟HTTP请求和响应对象。
      </p>
     </li>
     <li>
      <p>
       <strong>
        GenericServlet
       </strong>
       和
       <strong>
        HttpServlet
       </strong>
       ：抽象类，提供Servlet的基本实现。
      </p>
     </li>
     <li>
      <p>
       <strong>
        Servlet
       </strong>
       ：Servlet接口，定义了Servlet的生命周期方法。
      </p>
     </li>
     <li>
      <p>
       <strong>
        MyTomcat
       </strong>
       ：主类，负责启动服务器并处理HTTP请求。
      </p>
     </li>
     <li>
      <p>
       <strong>
        ServletConfigMapping
       </strong>
       ：维护URL与Servlet的映射关系。
      </p>
     </li>
    </ul>
    <h3>
     三、核心组件解析
    </h3>
    <h4>
     1、 ResponseUtil 类
    </h4>
    <p>
     <strong>
      <code>
       ResponseUtil
      </code>
     </strong>
     类用于生成HTTP响应头。它提供了两个静态方法：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         getResponseHeader200(String context)
        </code>
       </strong>
       ：生成状态码为200的HTTP响应头，并将响应内容附加到响应头后。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         getResponseHeader404()
        </code>
       </strong>
       ：生成状态码为404的HTTP响应头。
      </p>
     </li>
    </ul>
    <pre><code class="language-java">public class ResponseUtil {
    public static final String responseHeader200 = "HTTP/1.1 200 \r\n" +
            "Content-Type:text/html; charset=utf-8 \r\n" + "\r\n";

    public static String getResponseHeader404() {
        return "HTTP/1.1 404 \r\n" +
                "Content-Type:text/html; charset=utf-8 \r\n" + "\r\n" + "404";
    }

    public static String getResponseHeader200(String context) {
        return "HTTP/1.1 200 \r\n" +
                "Content-Type:text/html; charset=utf-8 \r\n" + "\r\n" + context;
    }
}</code></pre>
    <h4>
     2、SearchClassUtil 类
    </h4>
    <p>
     <strong>
      <code>
       SearchClassUtil
      </code>
     </strong>
     类用于扫描指定包下的类文件，并获取这些类的全限定名。它通过递归遍历目录结构，找到所有以
     <code>
      .class
     </code>
     结尾的文件，并将其路径转换为类的全限定名。
    </p>
    <pre><code class="language-java">public class SearchClassUtil {
    public static List&lt;String&gt; classPaths = new ArrayList&lt;String&gt;();

    public static List&lt;String&gt; searchClass() {
        String basePack = "com.qcby.webapps.myweb";
        String classPath = SearchClassUtil.class.getResource("/").getPath();
        basePack = basePack.replace(".", File.separator);
        String searchPath = classPath + basePack;
        doPath(new File(searchPath), classPath);
        return classPaths;
    }

    private static void doPath(File file, String classpath) {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (File f1 : files) {
                doPath(f1, classpath);
            }
        } else {
            if (file.getName().endsWith(".class")) {
                String path = file.getPath().replace(classpath.replace("/", "\\")
                                .replaceFirst("\\\\", ""), "").replace("\\", ".")
                        .replace(".class", "");
                classPaths.add(path);
            }
        }
    }
}</code></pre>
    <h4>
     3.
     <strong>
      WebServlet 注解
     </strong>
    </h4>
    <p>
     <code>
      WebServlet
     </code>
     是一个自定义注解，用于标记Servlet类并指定URL映射。它包含一个
     <code>
      urlMapping
     </code>
     属性，用于指定Servlet处理的URL路径。
    </p>
    <pre><code class="language-java">package com.qcby.util;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface WebServlet {
    String urlMapping() default "";
}</code></pre>
    <h4>
     4、LoginServlet 和 ShowServlet 类
    </h4>
    <p>
     <code>
      LoginServlet
     </code>
     和
     <code>
      ShowServlet
     </code>
     是两个具体的Servlet实现类，分别处理
     <code>
      /login
     </code>
     和
     <code>
      /show
     </code>
     路径的请求。它们继承自
     <code>
      HttpServlet
     </code>
     ，并重写了
     <code>
      doGet
     </code>
     方法以处理GET请求。
    </p>
    <pre><code class="language-java">@WebServlet(urlMapping = "/login")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        System.out.println("我是login的doGet方法");
        response.writeServlet(ResponseUtil.getResponseHeader200("hello"));
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    }
}

@WebServlet(urlMapping = "/show")
public class ShowServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        System.out.println("我是show");
        response.writeServlet(ResponseUtil.getResponseHeader200("show"));
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
    }
}</code></pre>
    <h4>
     <strong>
      5、HttpServletRequest 和 HttpServletResponse
     </strong>
    </h4>
    <p>
     <code>
      HttpServletRequest
     </code>
     和
     <code>
      HttpServletResponse
     </code>
     类分别模拟了HTTP请求和响应对象。
     <code>
      HttpServletRequest
     </code>
     包含请求路径和请求方法，
     <code>
      HttpServletResponse
     </code>
     包含输出流，用于向客户端发送响应。
    </p>
    <pre><code class="language-java">package com.qcby.webapps.servlet.req;

public class HttpServletRequest {
    private String path;
    private String method;

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getMethod() {
        return method;
    }

    public void setMethod(String method) {
        this.method = method;
    }
}</code></pre>
    <p>
     <code>
      HttpServletRequest
     </code>
     类封装了 HTTP 请求的路径和方法（GET、POST 等）。
    </p>
    <pre><code class="language-java">package com.qcby.webapps.servlet.req;

import java.io.IOException;
import java.io.OutputStream;

public class HttpServletResponse {
    private OutputStream outputStream;

    public HttpServletResponse(OutputStream outputStream) {
        this.outputStream = outputStream;
    }

    public void writeServlet(String context) throws IOException {
        outputStream.write(context.getBytes());
    }
}</code></pre>
    <p>
     <code>
      HttpServletResponse
     </code>
     类封装了 HTTP 响应，提供了向客户端输出数据的方法。
    </p>
    <h4>
     <strong>
      6.
     </strong>
     GenericServlet 和
     <strong>
      HttpServlet 类
     </strong>
    </h4>
    <p>
     <code>
      GenericServlet
     </code>
     是一个抽象类，提供了Servlet的基本实现，包括
     <code>
      init
     </code>
     和
     <code>
      destroy
     </code>
     方法。
     <code>
      HttpServlet
     </code>
     继承自
     <code>
      GenericServlet
     </code>
     ，并实现了
     <code>
      service
     </code>
     方法，根据请求方法调用相应的
     <code>
      doGet
     </code>
     或
     <code>
      doPost
     </code>
     方法。
    </p>
    <pre><code class="language-java">public abstract class GenericServlet implements Servlet {
    public void init() {
        System.out.println("------初始化servlet------");
    }

    public void destroy() {
        System.out.println("------实现servlet对象的销毁------");
    }
}

public abstract class HttpServlet extends GenericServlet {
    public void service(HttpServletRequest request, HttpServletResponse response) throws IOException {
        if (request.getMethod().equals("GET")) {
            doGet(request, response);
        } else {
            doPost(request, response);
        }
    }

    protected abstract void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException;

    protected abstract void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException;
}</code></pre>
    <h4>
     <strong>
      7. Servlet 接口
     </strong>
    </h4>
    <p>
     <code>
      Servlet
     </code>
     接口定义了Servlet的生命周期方法，包括
     <code>
      init
     </code>
     、
     <code>
      service
     </code>
     和
     <code>
      destroy
     </code>
     。
    </p>
    <pre><code class="language-java">package com.qcby.webapps.servlet;

import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;

public interface Servlet {
    void init(); // Servlet 初始化
    void service(HttpServletRequest request, HttpServletResponse response) throws IOException; // 处理请求
    void destroy(); // 销毁
}</code></pre>
    <h4>
     8.
     <strong>
      MyTomcat 类
     </strong>
    </h4>
    <p>
     <code>
      MyTomcat
     </code>
     类是项目的核心，负责启动服务器并处理HTTP请求。它通过
     <code>
      ServerSocket
     </code>
     监听指定端口，接收客户端请求，解析请求内容，并根据请求路径调用相应的Servlet。
    </p>
    <pre><code class="language-java">package com.qcby;

import com.qcby.webapps.servlet.HttpServlet;
import com.qcby.webapps.servlet.req.HttpServletRequest;
import com.qcby.webapps.servlet.req.HttpServletResponse;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

import static com.qcby.ServletConfigMapping.servletMap;

public class MyTomcat {
    static HttpServletRequest request = new HttpServletRequest();

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8484);
        while (true) {
            Socket socket = serverSocket.accept();
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream = socket.getOutputStream();
            HttpServletResponse response = new HttpServletResponse(outputStream);

            int count = 0;
            while (count == 0) {
                count = inputStream.available();
            }

            byte[] bytes = new byte[count];
            inputStream.read(bytes);
            String context = new String(bytes);
            System.out.println(context);

            if (context.equals("")) {
                System.out.println("你输入了一个空请求");
            } else {
                String firstLine = context.split("\\n")[0];
                request.setPath(firstLine.split("\\s")[1]);
                request.setMethod(firstLine.split("\\s")[0]);
            }

            if (servletMap.containsKey(request.getPath())) {
                System.out.println("存在于HashMap中");
                HttpServlet servlet = servletMap.get(request.getPath());
                servlet.service(request, response);
            } else {
                System.out.println("不存在于HashMap中");
            }
        }
    }
}</code></pre>
    <h4>
     9.
     <strong>
      ServletConfigMapping 类
     </strong>
    </h4>
    <p>
     <code>
      ServletConfigMapping
     </code>
     类维护了URL与Servlet的映射关系。它通过
     <code>
      SearchClassUtil
     </code>
     扫描指定包下的类，利用反射机制获取带有
     <code>
      @WebServlet
     </code>
     注解的类，并将其实例化后存入
     <code>
      servletMap
     </code>
     中。
    </p>
    <pre><code class="language-java">package com.qcby;

import com.qcby.util.SearchClassUtil;
import com.qcby.util.WebServlet;
import com.qcby.webapps.servlet.HttpServlet;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ServletConfigMapping {
    public static Map&lt;String, HttpServlet&gt; servletMap = new HashMap&lt;&gt;();

    static {
        List&lt;String&gt; classNames = SearchClassUtil.searchClass();
        for (String path : classNames) {
            try {
                Class&lt;?&gt; clazz = Class.forName(path);
                WebServlet webServlet = clazz.getDeclaredAnnotation(WebServlet.class);
                HttpServlet servlet = (HttpServlet) clazz.newInstance();
                servletMap.put(webServlet.urlMapping(), servlet);
                System.out.println(servletMap);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
    <h3>
     <strong>
      四、运行流程
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        启动 Tomcat
       </strong>
       ：
       <code>
        MyTomcat
       </code>
       类的
       <code>
        main
       </code>
       方法启动，监听 8484 端口。
      </p>
     </li>
     <li>
      <p>
       <strong>
        接收请求
       </strong>
       ：当有客户端请求到来时，
       <code>
        MyTomcat
       </code>
       解析请求的路径和方法。
      </p>
     </li>
     <li>
      <p>
       <strong>
        分发请求
       </strong>
       ：根据请求路径从
       <code>
        ServletConfigMapping.servletMap
       </code>
       中获取对应的 Servlet 实例，并调用其
       <code>
        service
       </code>
       方法。
      </p>
     </li>
     <li>
      <p>
       <strong>
        处理请求
       </strong>
       ：Servlet 根据请求方法调用
       <code>
        doGet
       </code>
       或
       <code>
        doPost
       </code>
       方法，生成响应并返回给客户端。
      </p>
     </li>
    </ol>
    <p>
     通过手写一个简易版的 Tomcat，我们深入理解了 Servlet 容器的工作原理。虽然这个简易版 Tomcat 功能有限，但它涵盖了 Servlet 容器的核心组件和运行机制。希望本文能帮助你更好地理解 Tomcat 和 Servlet 技术，并为后续深入学习打下坚实的基础。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373037313937372f:61727469636c652f64657461696c732f313436313232343632" class_="artid" style="display:none">
 </p>
</div>


