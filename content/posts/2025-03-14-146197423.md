---
layout: post
title: "学习15天pytest"
date: 2025-03-14 11:02:31 +0800
description: "setup/teardown，setup_class/teardown class 它是作用于所有用例或者所有的类@pytest.fixtrue()它的作用是既可以部分也可以全部前后置。conftest.py和@pytest.fixtrue()结合使用，作用于全局的前后置,"
keywords: "学习15天：pytest"
categories: ['未分类']
tags: ['学习', 'Pytest']
artid: "146197423"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146197423
    alt: "学习15天pytest"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146197423
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146197423
cover: https://bing.ee123.net/img/rand?artid=146197423
image: https://bing.ee123.net/img/rand?artid=146197423
img: https://bing.ee123.net/img/rand?artid=146197423
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     学习15天：pytest
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     1、.pytest强大的插件
    </h3>
    <p>
     <br/>
     pytest-html(生成html格式的自动化测试报告)
    </p>
    <p>
     pytest-xdist测试用例分布式执行。多CPU分发。
    </p>
    <p>
     pytest-ordering 用于改变测试用例的执行顺序
    </p>
    <p>
     pytest-rerunfailures用例失败后重跑
    </p>
    <p>
     allure-pytest 用于生成美观的测试报告。
     <br/>
    </p>
    <h3>
     2、规则：
    </h3>
    <p>
     模块名必须以test_开头或者_test结尾
    </p>
    <p>
     测试类必须Test开头
    </p>
    <p>
     测试方法必须以test开头
    </p>
    <h3>
     3、运行
    </h3>
    <p>
     文件目录：
    </p>
    <p>
     （1）主函数运行
    </p>
    <ul>
     <li>
      运行所有的用例
     </li>
    </ul>
    <pre>if __name__ == '__main__':
    pytest.main()</pre>
    <ul>
     <li>
      指定模块运行
     </li>
    </ul>
    <pre>import pytest
if __name__ == '__main__':
    pytest.main(['-vs','test_login.py'])  #列表方式，注意大括号</pre>
    <p>
    </p>
    <ul>
     <li>
      <p>
       指定文件夹执行
       <br/>
      </p>
      <pre><code class="language-python">import pytest
if __name__ == '__main__':
    pytest.main(['-vs','./interface_testcases'])</code></pre>
      <p>
      </p>
     </li>
     <li>
      <p>
       通过nodeid指定用例运行，nodeid由模块名、类名、函数名组成
      </p>
     </li>
    </ul>
    <pre><code class="language-python">import pytest
if __name__ == '__main__':
    #文件里面的函数
    pytest.main(['-vs','./interface_testcases/test_interface.py::test_04_func'])
    
    #类下面的方法
    #pytest.main(['-vs', './interface_testcases/test_interface.py::TestInterface::test_Interface_01'])
</code></pre>
    <p>
    </p>
    <p>
     （2）命令行模式
    </p>
    <ul>
     <li>
      运行所有：pytest
     </li>
     <li>
      指定模块
      <img alt="" height="61" src="https://i-blog.csdnimg.cn/direct/ec2e88b546db40aca8a86d2bc829ba21.png" width="817"/>
     </li>
     <li>
      指定目录
     </li>
    </ul>
    <p>
     pytest -vs ./interface_testcases
    </p>
    <ul>
     <li>
      指定到方法
     </li>
    </ul>
    <pre>pytes-vs ./interface_testcases/test_interface.py::TestInterface::test_Interface_01</pre>
    <p>
     参数详情：
    </p>
    <p>
     -s：表示输出调试的信息，包括print打印信息
    </p>
    <p>
     -v:打印详细信息，模块名.类名.类方法
    </p>
    <pre>pytest.main(['-s'])       </pre>
    <p>
     两个参数可以合并使用
    </p>
    <pre>pytest.main(['-vs'])       
 #test_login.py::TestLogin::test_login_01 这是我打印的print内容
</pre>
    <p>
     -n :支持多线程或分布式运行测试用例，使用分布式需要先导入
    </p>
    <p>
    </p>
    <pre> pytest -vs ./testcases/test_login.py -n 2  #在命令行输入，2是代表线程数  </pre>
    <pre>pytest.main(['-vs','./testcases','-n=2'])        #在pycharm输入格式，要安装pytest-xdist</pre>
    <p>
     -k: 根据测试用例的部分字符指定测试用例
    </p>
    <p>
     pytest.main(['-v','-k test_1 or test_2','test_case3.py'])   #在pycharm输入格式
    </p>
    <p>
     pytest -vs .testcase -k "ao" #在命令行输入
    </p>
    <h3>
     4、改变测试用例的运行方式
    </h3>
    <p>
     安装pytest-ordering,在方法上面添加上装饰器
    </p>
    <pre><code class="language-python">#按照order顺序执行case
@pytest.mark.run(order =3)
def test_login_01(self):
    print("我说这是第二个文件")</code></pre>
    <p>
     5、通过读取pytest.ini配置文件yunx
    </p>
    <p>
     pytest.ini这个文件是pytest测试框架的核心配置文件，必须以这个命名
    </p>
    <p>
     位置：一般放在根目录下
    </p>
    <p>
     编码：必须是ANSI，可以使用notpad++修改编码格式,书写格式如下，举例说明
    </p>
    <pre>[pytest]
#命令行执行参数，用空格分开
addopts = -vs

#测试文件夹，可自己配置
testpaths = ./testcases</pre>
    <p>
     运行规则：不管是命令模式还是主函数模式运行，都会先去执行这个文件
    </p>
    <h3>
     5、初始化清除
    </h3>
    <p>
     模块、类、方法
    </p>
    <pre><code class="language-python">def setup_module():
    print('\n *** 初始化-模块 ***')

def teardown_module():
    print('\n ***   清除-模块 ***')

class Test_错误密码:

    @classmethod
    def setup_class(cls):
        print('\n === 初始化-类 ===')

    @classmethod
    def teardown_class(cls):
        print('\n === 清除 - 类 ===')

    def setup_method(self):
        print('\n --- 初始化-方法  ---')

    def teardown_method(self):
        print('\n --- 清除  -方法 ---')

    def test_C001001(self):
        print('\n用例C001001')
        assert 1 == 1

    def test_C001002(self):
        print('\n用例C001002')
        assert 2 == 2

    def test_C001003(self):
        print('\n用例C001003')
        assert 3 == 2

class Test_错误密码2:

    def test_C001021(self):
        print('\n用例C001021')
        assert 1 == 1

    def test_C001022(self):
        print('\n用例C001022')
        assert 2 == 2</code></pre>
    <p>
     目录级别
    </p>
    <p>
     目标级别的 初始化清除，就是针对整个目录执行的初始化、清除。
    </p>
    <p>
     我们在需要初始化的目录下面创建 一个名为
     <code>
      conftest.py
     </code>
     的文件，里面内容如下所示
    </p>
    <pre><code class="language-python">import pytest 

@pytest.fixture(scope='package',autouse=True)
def st_emptyEnv():
    print(f'\n#### 初始化-目录甲')
    yield

    print(f'\n#### 清除-目录甲')</code></pre>
    <h3>
     6、使用fixture装饰器实现部分用例的前后置
    </h3>
    <p>
     <img alt="" height="310" src="https://i-blog.csdnimg.cn/direct/addffeab00bb49ec8a6bf761ed10e2f8.png" width="865"/>
    </p>
    <p>
     一个方法使用
    </p>
    <p>
     <img alt="" height="555" src="https://i-blog.csdnimg.cn/direct/7d7714932c764f178ec84674767d2726.png" width="763"/>
    </p>
    <p>
     方法范围使用，等同等同setup_method,teardown_method，设置autouse是所有自动使用
    </p>
    <p>
     <img alt="" height="244" src="https://i-blog.csdnimg.cn/direct/a0134acba7c640c395fdbb0b6a457be2.png" width="786">
      修改这个参数，就是对类范围生效，等同setup_class,teardown_class
     </img>
    </p>
    <p>
     <img alt="" height="249" src="https://i-blog.csdnimg.cn/direct/ccc382ca5c1348fd86a61d29cbd36ea6.png" width="750"/>
    </p>
    <p>
     固定写法，注意：params和param，函数中使用这个方法，会调用执行3次，并且可以使用这个参数
    </p>
    <p>
     <img alt="" height="246" src="https://i-blog.csdnimg.cn/direct/d4c2db50593d4d00b9315ea6225fa96c.png" width="1330">
      <img alt="" height="372" src="https://i-blog.csdnimg.cn/direct/be02dd9aecf34fce891f8e96692b4203.png" width="828"/>
     </img>
    </p>
    <h3>
     7、通过conftest.py和@python.fixture()结合使用实现“全局”的前置
    </h3>
    <p>
     1.conftest.py文件是单独存放的一个夹具配置文件，名称是不能更改
    </p>
    <p>
     2.用处可以在不同的py文件中使用同一个fixture函数。
    </p>
    <p>
     3.原则上contest.py需要和运行的用例放到统一层。并且不需要做任何的imprt导入的操作。
    </p>
    <h3>
     总结:
    </h3>
    <p>
     <br/>
     setup/teardown，setup_class/teardown class 它是作用于所有用例或者所有的类
    </p>
    <p>
     @pytest.fixtrue()它的作用是既可以部分也可以全部前后置。
    </p>
    <p>
     conftest.py和@pytest.fixtrue()结合使用，作用于全局的前后置,
    </p>
    <h3>
     8、数据驱动@pytest.mark.parametrize
    </h3>
    <p>
     功能类似于unittest的ddt数据驱动
    </p>
    <pre><code class="language-python">class Test_错误登录:
    @pytest.mark.parametrize('username, password, expectedalert', [
        (None, '88888888', '请输入用户名'),
        ('byhy', None, '请输入密码'),
        ('byh', '88888888', '登录失败 : 用户名或者密码错误'),
        ('byhy', '8888888', '登录失败 : 用户名或者密码错误'),
        ('byhy', '888888888', '登录失败 : 用户名或者密码错误'),
    ]
                             )
    def test_UI_0001_0005(self, username, password, expectedalert):
        alertText = loginAndCheck(username, password)
        assert alertText == expectedalert</code></pre>
    <h3>
     9.YAML文件详情
    </h3>
    <p>
     <br/>
     1.用于全局的配置文件 ini或yaml
     <br/>
     2.用于写测试用例(接口测试用例)
     <br/>
     yaml简介:
     <br/>
     yaml是一种数据格式，支持注释，换行，多行字符串，裸字符串(整形，字符串)
     <br/>
     语法规则:
     <br/>
     1.区分大小写
     <br/>
     2.使用缩进表示层级，不能使用tab键缩进，只能用空格(和python一样)3.缩进没有数量的，只要前面是对其的就行。
     <br/>
     4.注释是#
     <br/>
     数据组成
     <br/>
     1.Map对象，键值对键:(空格)值
    </p>
    <p>
     多行形式：
     <br/>
     [msxy]
     <br/>
     name: 小名
     <br/>
     age：18
    </p>
    <p>
     <br/>
     一行的写法:
     <br/>
     msxy：{name: 小名，age：18}
    </p>
    <p>
     2、数组（list）
    </p>
    <p>
     msxy：
    </p>
    <p>
     -name：xiaoming
    </p>
    <p>
     -age：18
    </p>
    <p>
     <img alt="" height="424" src="https://i-blog.csdnimg.cn/direct/dd5058cc8055494b835949e40c5a0c55.png" width="856"/>
    </p>
    <p>
     一行的写法:
     <br/>
     msxy: [{name:百里},{age:18}]
    </p>
    <h3 style="background-color:transparent">
     10.Allure测试报告
    </h3>
    <p>
     第一步：先要下载，下载后放到D盘，然后解压
     <br/>
     第二步：配置Allure的环境变量，path增加
     <br/>
     D:\allure-2.21.0\bin
    </p>
    <p>
     <br/>
     验证环境：allure --version
    </p>
    <p>
     第三步：生成临时的json报告，配置添加第一句，在temp文件下，生成临时报告
    </p>
    <pre><code class="language-python">[pytest]
#配置常用运行参数
addopts = -vs --alluredir=./temps --clean-alluredir
#配置测试用例的位置
testpaths = ./testcases
#配置模块名的规则
python_files = test_*.py
#配置类的规则
python_classes = Test*
#配置测试用例(方法)的规则
python_functions = test_*</code></pre>
    <p>
     第四步：直接根据临时json报告生成Allure报告到reports文件下
    </p>
    <pre><code class="language-python">if __name__ == '__main__':
 pytest.main()
 time.sleep(1)
 os.system("allure generate ./temps -o ./reports --clean")</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343435323539322f:61727469636c652f64657461696c732f313436313937343233" class_="artid" style="display:none">
 </p>
</div>


