---
layout: post
title: "AgentOpenManus-Agent架构详细分析"
date: 2025-03-16 23:27:57 +0800
description: "openManus agent 组件的详细分析"
keywords: "【Agent】OpenManus-Agent架构详细分析"
categories: ['Ai']
tags: ['Openmanus', 'Manus', 'Ai', 'Agi', 'Agent']
artid: "146303801"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146303801
    alt: "AgentOpenManus-Agent架构详细分析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146303801
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146303801
cover: https://bing.ee123.net/img/rand?artid=146303801
image: https://bing.ee123.net/img/rand?artid=146303801
img: https://bing.ee123.net/img/rand?artid=146303801
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Agent】OpenManus-Agent架构详细分析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      各组件详细设计见：
     </strong>
    </p>
    <ul>
     <li>
      BaseAgent：
      <a href="https://blog.csdn.net/weixin_40242845/article/details/146303861?spm=1001.2014.3001.5502">
       BaseAgent
      </a>
     </li>
     <li>
      ReActAgent：
      <a href="https://blog.csdn.net/weixin_40242845/article/details/146303922">
       ReActAgent
      </a>
     </li>
     <li>
      ToolCallAgent：
      <a href="https://blog.csdn.net/weixin_40242845/article/details/146303987">
       ToolCallAgent
      </a>
     </li>
     <li>
      具体Agent实现：
      <a href="https://blog.csdn.net/weixin_40242845/article/details/146304008?spm=1001.2014.3001.5502">
       具体Agent
      </a>
     </li>
     <li>
      Memory数据结构：
      <a href="https://blog.csdn.net/weixin_40242845/article/details/146303891">
       Memory
      </a>
     </li>
    </ul>
    <h3>
     <a id="1__6">
     </a>
     1. 智能体层次结构
    </h3>
    <p>
     OpenManus 采用了一个多层次的智能体继承结构，形成了清晰的能力分层：
    </p>
    <pre><code>BaseAgent (抽象基类)
    ↓
ReActAgent (思考-行动循环)
    ↓
ToolCallAgent (工具调用能力)
    ↓
具体智能体实现:
    - Manus (通用智能体)
    - PlanningAgent (规划智能体)
    - SWEAgent (软件工程智能体)
</code></pre>
    <h3>
     <a id="2__23">
     </a>
     2. 核心组件设计
    </h3>
    <h4>
     <a id="21_BaseAgent__25">
     </a>
     2.1 BaseAgent (基础代理)
    </h4>
    <p>
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      使用 Pydantic 支持数据验证和序列化
     </li>
     <li>
      实现了状态管理、内存管理和执行循环的基础功能
     </li>
     <li>
      提供了上下文管理器
      <code>
       state_context
      </code>
      用于安全的状态转换
     </li>
     <li>
      实现了
      <code>
       run
      </code>
      方法作为主要执行入口
     </li>
     <li>
      定义了
      <code>
       step
      </code>
      抽象方法，要求子类实现
     </li>
     <li>
      包含循环检测和处理机制
     </li>
    </ul>
    <p>
     <strong>
      关键属性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       name
      </code>
      : 智能体名称
     </li>
     <li>
      <code>
       description
      </code>
      : 智能体描述
     </li>
     <li>
      <code>
       system_prompt
      </code>
      : 系统级指令提示
     </li>
     <li>
      <code>
       next_step_prompt
      </code>
      : 下一步行动提示
     </li>
     <li>
      <code>
       llm
      </code>
      : 语言模型实例
     </li>
     <li>
      <code>
       memory
      </code>
      : 内存存储
     </li>
     <li>
      <code>
       state
      </code>
      : 当前状态
     </li>
     <li>
      <code>
       max_steps
      </code>
      : 最大步骤数
     </li>
     <li>
      <code>
       current_step
      </code>
      : 当前步骤
     </li>
    </ul>
    <p>
     <strong>
      调用逻辑
     </strong>
     ：
    </p>
    <p>
     a. 通过
     <code>
      run
     </code>
     方法启动智能体
    </p>
    <p>
     b. 使用
     <code>
      state_context
     </code>
     管理状态转换
    </p>
    <p>
     c. 循环执行
     <code>
      step
     </code>
     方法直到达到终止条件
    </p>
    <p>
     d. 检测并处理循环状态
    </p>
    <p>
     e. 返回执行结果
    </p>
    <h4>
     <a id="22_ReActAgent__57">
     </a>
     2.2 ReActAgent (思考-行动代理)
    </h4>
    <p>
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      实现了
      <code>
       ReAct
      </code>
      (Reasoning and Acting) 模式
     </li>
     <li>
      将
      <code>
       step
      </code>
      方法分解为
      <code>
       think
      </code>
      和
      <code>
       act
      </code>
      两个抽象方法
     </li>
     <li>
      提供了思考-行动循环的基本框架
     </li>
    </ul>
    <p>
     <strong>
      关键方法
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       think
      </code>
      : 抽象方法，处理当前状态并决定下一步行动
     </li>
     <li>
      <code>
       act
      </code>
      : 抽象方法，执行决定的行动
     </li>
     <li>
      <code>
       step
      </code>
      : 实现了单个思考-行动周期
     </li>
    </ul>
    <p>
     <strong>
      调用逻辑
     </strong>
     ：
    </p>
    <p>
     a.
     <code>
      step
     </code>
     方法首先调用
     <code>
      think
     </code>
     方法
    </p>
    <p>
     b. 如果
     <code>
      think
     </code>
     返回
     <code>
      True
     </code>
     ，则调用
     <code>
      act
     </code>
     方法
    </p>
    <p>
     c. 返回执行结果
    </p>
    <h4>
     <a id="23_ToolCallAgent__77">
     </a>
     2.3 ToolCallAgent (工具调用代理)
    </h4>
    <p>
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      扩展了
      <code>
       ReActAgent
      </code>
      ，专注于工具调用能力
     </li>
     <li>
      实现了与
      <code>
       LLM
      </code>
      的工具调用接口集成
     </li>
     <li>
      支持多种工具选择模式：none、auto、required
     </li>
     <li>
      提供了工具执行和结果处理机制
     </li>
     <li>
      支持特殊工具处理（如终止工具）
     </li>
    </ul>
    <p>
     <strong>
      关键属性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       available_tools
      </code>
      : 可用工具集合
     </li>
     <li>
      <code>
       tool_choices
      </code>
      : 工具选择模式
     </li>
     <li>
      <code>
       special_tool_names
      </code>
      : 特殊工具名称列表
     </li>
     <li>
      <code>
       tool_calls
      </code>
      : 当前工具调用列表
     </li>
    </ul>
    <p>
     <strong>
      关键方法
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        think
       </code>
       : 这个方法的核心是与 LLM 交互，获取其决策，并根据不同的工具选择模式决定下一步操作
      </p>
     </li>
     <li>
      <p>
       <code>
        act
       </code>
       : 执行 LLM 决定使用的工具，并处理执行结果
      </p>
      <ul>
       <li>
        <p>
         如果没有工具调用且工具选择模式为 ToolChoice.REQUIRED，则抛出异常
        </p>
       </li>
       <li>
        <p>
         如果没有工具调用，返回最后一条消息的内容
        </p>
       </li>
       <li>
        <p>
         对每个工具调用，执行 execute_tool 方法并获取结果
        </p>
       </li>
       <li>
        <p>
         如果设置了 max_observe，限制结果的长度
        </p>
       </li>
       <li>
        <p>
         记录工具执行完成的日志
        </p>
       </li>
       <li>
        <p>
         将工具响应添加到内存中
        </p>
       </li>
       <li>
        <p>
         返回所有结果的组合字符串
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        execute_tool
       </code>
       : 执行单个工具调用
      </p>
     </li>
     <li>
      <p>
       <code>
        _handle_special_tool
       </code>
       : 处理特殊工具执行
      </p>
     </li>
    </ul>
    <p>
     <strong>
      调用逻辑
     </strong>
     ：
    </p>
    <p>
     a.
     <code>
      think
     </code>
     方法向 LLM 发送消息并获取响应
    </p>
    <p>
     b. 解析响应中的工具调用
    </p>
    <p>
     c. 将响应添加到内存中
    </p>
    <p>
     d.
     <code>
      act
     </code>
     方法执行工具调用
    </p>
    <p>
     e. 处理工具执行结果
    </p>
    <p>
     f. 检查特殊工具并更新状态
    </p>
    <h4>
     <a id="24_Manus__126">
     </a>
     2.4 Manus (通用智能体)
    </h4>
    <p>
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      继承自
      <code>
       ToolCallAgent
      </code>
      ，是项目的主要智能体
     </li>
     <li>
      配置了多种工具：PythonExecute、WebSearch、BrowserUseTool、FileSaver、Terminate
     </li>
     <li>
      使用特定的系统 prompt 和下一步 prompt
     </li>
     <li>
      重写了特殊工具处理方法，确保浏览器资源清理
     </li>
    </ul>
    <p>
     <strong>
      关键属性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       max_observe
      </code>
      : 限制 tool call的长度
     </li>
     <li>
      <code>
       max_steps
      </code>
      : 设置为 20 步
     </li>
    </ul>
    <p>
     <strong>
      复写_handle_special_tool()
     </strong>
     ：
    </p>
    <ul>
     <li>
      检查工具是否为特殊工具
     </li>
     <li>
      如果是特殊工具，清理浏览器资源
     </li>
     <li>
      调用父类的
      <code>
       _handle_special_tool()
      </code>
      方法
     </li>
    </ul>
    <h4>
     <a id="25_PlanningAgent__144">
     </a>
     2.5 PlanningAgent (规划智能体)
    </h4>
    <p>
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      继承自
      <code>
       ToolCallAgent
      </code>
      ，专注于任务规划
     </li>
     <li>
      使用
      <code>
       PlanningTool
      </code>
      创建和管理结构化计划
     </li>
     <li>
      跟踪计划步骤的执行状态
     </li>
     <li>
      支持计划创建、更新和执行
     </li>
    </ul>
    <p>
     <strong>
      额外属性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       active_plan_id
      </code>
      : 当前活动计划的 ID
     </li>
     <li>
      <code>
       step_execution_tracker
      </code>
      : 步骤执行跟踪器
     </li>
     <li>
      <code>
       current_step_index
      </code>
      : 当前步骤索引
     </li>
    </ul>
    <p>
     <strong>
      复写方法
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       <code>
        run
       </code>
      </p>
      <ul>
       <li>
        <p>
         如果提供了请求，创建初始计划
        </p>
       </li>
       <li>
        <p>
         调用父类的
         <code>
          run()
         </code>
         方法
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        think
       </code>
      </p>
      <ul>
       <li>
        获取当前计划状态并添加到提示中
       </li>
       <li>
        获取当前步骤索引
       </li>
       <li>
        调用父类的
        <code>
         think()
        </code>
        方法
       </li>
       <li>
        将工具调用与当前步骤关联以进行跟踪
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        act
       </code>
       :
      </p>
      <ul>
       <li>
        调用父类的
        <code>
         act()
        </code>
        方法执行工具
       </li>
       <li>
        更新工具执行状态为已完成
       </li>
       <li>
        如果是非规划、非特殊工具，更新计划状态
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      额外实现方法
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <code>
        get_plan
       </code>
       : 获取当前计划
      </p>
     </li>
     <li>
      <p>
       <code>
        update_plan_status
       </code>
       : 更新计划状态
      </p>
     </li>
     <li>
      <p>
       <code>
        _get_current_step_index()
       </code>
       : 解析当前计划以识别第一个未完成步骤的索引
      </p>
     </li>
     <li>
      <p>
       <code>
        create_initial_plan
       </code>
       : 创建初始计划
      </p>
     </li>
    </ul>
    <p>
     <strong>
      调用逻辑
     </strong>
     ：
    </p>
    <ol>
     <li>
      初始化时创建计划 ID 并验证工具
     </li>
     <li>
      首次运行时创建初始计划
     </li>
     <li>
      执行计划步骤并更新状态
     </li>
     <li>
      跟踪计划进度直到完成
     </li>
    </ol>
    <h4>
     <a id="26_SWEAgent__194">
     </a>
     2.6 SWEAgent (软件工程智能体)
    </h4>
    <p>
     <strong>
      设计特点
     </strong>
     ：
    </p>
    <ul>
     <li>
      继承自 ToolCallAgent，专注于软件工程任务
     </li>
     <li>
      配置了 Bash、StrReplaceEditor 和 Terminate 工具
     </li>
     <li>
      跟踪工作目录状态
     </li>
    </ul>
    <p>
     <strong>
      关键属性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       max_step
      </code>
      : 30
     </li>
    </ul>
    <p>
     <strong>
      额外属性
     </strong>
     ：
    </p>
    <ul>
     <li>
      <code>
       bash
      </code>
      : Bash 工具实例
     </li>
     <li>
      <code>
       working_dir
      </code>
      : 当前工作目录
     </li>
    </ul>
    <p>
     <strong>
      复写 think
     </strong>
     ：
    </p>
    <ul>
     <li>
      更新当前工作目录
     </li>
     <li>
      使用当前工作目录格式化
      <code>
       next_step_prompt
      </code>
     </li>
     <li>
      调用父类的
      <code>
       think()
      </code>
      方法
     </li>
    </ul>
    <h3>
     <a id="3__217">
     </a>
     3. 智能体调用流程
    </h3>
    <h4>
     <a id="31__219">
     </a>
     3.1 初始化流程
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        智能体创建
       </strong>
       ：
      </p>
      <pre><code class="prism language-python">agent <span class="token operator">=</span> Manus<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 或其他具体智能体</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        初始化验证
       </strong>
       ：
      </p>
      <ul>
       <li>
        通过 Pydantic 的
        <code>
         model_validator
        </code>
        进行初始化验证
       </li>
       <li>
        设置默认 LLM 和内存实例
       </li>
       <li>
        验证必要的工具和配置
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="32__231">
     </a>
     3.2 执行流程
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        启动执行
       </strong>
       ：
      </p>
      <pre><code class="prism language-python">result <span class="token operator">=</span> <span class="token keyword">await</span> agent<span class="token punctuation">.</span>run<span class="token punctuation">(</span>prompt<span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        状态管理
       </strong>
       ：
      </p>
      <ul>
       <li>
        使用
        <code>
         state_context
        </code>
        将状态设置为
        <code>
         RUNNING
        </code>
       </li>
       <li>
        执行完成后恢复状态或设置为
        <code>
         FINISHED
        </code>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        执行循环
       </strong>
       ：
      </p>
      <pre><code>while current_step &lt; max_steps and state != FINISHED:
    current_step += 1
    step_result = await step()
    check_for_stuck_state()
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        思考-行动循环
       </strong>
       ：
      </p>
      <pre><code>async def step():
    should_act = await think()
    if should_act:
        return await act()
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        工具调用流程
       </strong>
       ：
      </p>
      <pre><code>async def think():
    response = await llm.ask_tool(messages, tools, tool_choice)
    parse_tool_calls(response)
    add_to_memory(response)

async def act():
    for command in tool_calls:
        result = await execute_tool(command)
        add_to_memory(result)
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        特殊工具处理
       </strong>
       ：
      </p>
      <pre><code>if tool_name in special_tool_names:
    if should_finish_execution():
        state = FINISHED
</code></pre>
     </li>
    </ol>
    <h4>
     <a id="33__279">
     </a>
     3.3 内存管理
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        消息添加
       </strong>
       ：
      </p>
      <pre><code class="prism language-python">agent<span class="token punctuation">.</span>update_memory<span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"用户输入"</span><span class="token punctuation">)</span>
agent<span class="token punctuation">.</span>update_memory<span class="token punctuation">(</span><span class="token string">"assistant"</span><span class="token punctuation">,</span> <span class="token string">"助手响应"</span><span class="token punctuation">)</span>
agent<span class="token punctuation">.</span>update_memory<span class="token punctuation">(</span><span class="token string">"tool"</span><span class="token punctuation">,</span> <span class="token string">"工具结果"</span><span class="token punctuation">,</span> tool_call_id<span class="token operator">=</span><span class="token string">"工具ID"</span><span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        消息访问
       </strong>
       ：
      </p>
      <pre><code class="prism language-python">messages <span class="token operator">=</span> agent<span class="token punctuation">.</span>messages  <span class="token comment"># 获取所有消息</span>
</code></pre>
     </li>
    </ol>
    <h4>
     <a id="34__293">
     </a>
     3.4 工具集成
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        工具注册
       </strong>
       ：
      </p>
      <pre><code class="prism language-python">available_tools <span class="token operator">=</span> ToolCollection<span class="token punctuation">(</span>
    PythonExecute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> WebSearch<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> BrowserUseTool<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FileSaver<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Terminate<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        工具执行
       </strong>
       ：
      </p>
      <pre><code class="prism language-python">result <span class="token operator">=</span> <span class="token keyword">await</span> available_tools<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"tool_name"</span><span class="token punctuation">,</span> tool_input<span class="token operator">=</span>args<span class="token punctuation">)</span>
</code></pre>
     </li>
    </ol>
    <h3>
     <a id="4__307">
     </a>
     4. 设计模式应用
    </h3>
    <h4>
     <a id="41__309">
     </a>
     4.1 模板方法模式
    </h4>
    <ul>
     <li>
      BaseAgent 定义了算法骨架 (run)
     </li>
     <li>
      子类实现特定步骤 (step, think, act)
     </li>
    </ul>
    <h4>
     <a id="42__313">
     </a>
     4.2 策略模式
    </h4>
    <ul>
     <li>
      不同的智能体实现不同的策略
     </li>
     <li>
      通过继承和多态实现策略选择
     </li>
    </ul>
    <h4>
     <a id="43__317">
     </a>
     4.3 组合模式
    </h4>
    <ul>
     <li>
      ToolCollection 管理多个工具
     </li>
     <li>
      提供统一的接口执行工具
     </li>
    </ul>
    <h4>
     <a id="44__321">
     </a>
     4.4 观察者模式
    </h4>
    <ul>
     <li>
      状态变化和事件处理
     </li>
     <li>
      工具执行结果通知
     </li>
    </ul>
    <h4>
     <a id="45__325">
     </a>
     4.5 命令模式
    </h4>
    <ul>
     <li>
      工具调用封装为命令对象
     </li>
     <li>
      支持命令执行和结果处理
     </li>
    </ul>
    <h3>
     <a id="5__329">
     </a>
     5. 扩展性设计
    </h3>
    <h4>
     <a id="51__331">
     </a>
     5.1 智能体扩展
    </h4>
    <ul>
     <li>
      可以通过继承 BaseAgent 或其子类创建新的智能体
     </li>
     <li>
      只需实现必要的抽象方法
     </li>
    </ul>
    <h4>
     <a id="52__335">
     </a>
     5.2 工具扩展
    </h4>
    <ul>
     <li>
      通过 ToolCollection 可以灵活添加新工具
     </li>
     <li>
      智能体可以动态配置可用工具
     </li>
    </ul>
    <h4>
     <a id="53__339">
     </a>
     5.3 提示词扩展
    </h4>
    <ul>
     <li>
      系统提示和下一步提示可以自定义
     </li>
     <li>
      支持特定领域的提示词模板
     </li>
    </ul>
    <h3>
     <a id="6__343">
     </a>
     6. 错误处理机制
    </h3>
    <h4>
     <a id="61__345">
     </a>
     6.1 异常捕获
    </h4>
    <ul>
     <li>
      在
      <code>
       think
      </code>
      和
      <code>
       act
      </code>
      方法中捕获异常
     </li>
     <li>
      记录错误并添加到内存中
     </li>
    </ul>
    <h4>
     <a id="62__349">
     </a>
     6.2 状态恢复
    </h4>
    <ul>
     <li>
      使用
      <code>
       state_context
      </code>
      确保状态正确恢复
     </li>
     <li>
      异常时设置为 ERROR 状态
     </li>
    </ul>
    <h4>
     <a id="63__353">
     </a>
     6.3 循环检测
    </h4>
    <ul>
     <li>
      实现了
      <code>
       is_stuck
      </code>
      方法检测重复响应
     </li>
     <li>
      通过
      <code>
       handle_stuck_state
      </code>
      添加提示改变策略
     </li>
    </ul>
    <h3>
     <a id="7__357">
     </a>
     7. 性能考虑
    </h3>
    <h4>
     <a id="71__359">
     </a>
     7.1 异步设计
    </h4>
    <ul>
     <li>
      所有关键方法都使用
      <code>
       async/await
      </code>
      实现
     </li>
     <li>
      支持非阻塞 I/O 操作
     </li>
    </ul>
    <h4>
     <a id="72__363">
     </a>
     7.2 资源管理
    </h4>
    <ul>
     <li>
      特殊工具处理确保资源清理
     </li>
     <li>
      浏览器工具在终止时自动清理
     </li>
    </ul>
    <h4>
     <a id="73__367">
     </a>
     7.3 步骤限制
    </h4>
    <ul>
     <li>
      通过
      <code>
       max_steps
      </code>
      限制执行步骤
     </li>
     <li>
      防止无限循环和资源耗尽
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34303234323834352f:61727469636c652f64657461696c732f313436333033383031" class_="artid" style="display:none">
 </p>
</div>


