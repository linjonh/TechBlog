---
layout: post
title: "数据结构单链表list"
date: 2025-03-12 22:00:48 +0800
description: "单链表逻辑上相邻，物理上不一定相邻的链式存储结构。所以一个结点不仅仅要保存自身的数据，还要保存自己下一个连接结点的地址。所以每一个结点需要俩个域：一个数据域，一个指针域"
keywords: "数据结构——单链表list"
categories: ['数据结构']
tags: ['数据结构']
artid: "146069723"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146069723
    alt: "数据结构单链表list"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146069723
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146069723
cover: https://bing.ee123.net/img/rand?artid=146069723
image: https://bing.ee123.net/img/rand?artid=146069723
img: https://bing.ee123.net/img/rand?artid=146069723
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构——单链表list
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p>
      前言：大家好😍，本文主要介绍数据结构——单链表
     </p>
    </blockquote>
    <div>
    </div>
    <hr/>
    <h2 id="%E4%B8%80%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8" name="%E4%B8%80%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8">
     一、单链表
    </h2>
    <p>
     概念：单链表逻辑上相邻，物理上不一定相邻的链式存储结构
    </p>
    <p>
     所以一个结点不仅仅要保存自身的数据，还要保存自己下一个连接结点的地址
    </p>
    <p>
     所以每一个结点需要俩个域：
     <span style="background-color:#ffd900">
      一个数据域，一个指针域
     </span>
    </p>
    <p>
     <img alt="" height="203" src="https://i-blog.csdnimg.cn/direct/75a70a04f78c4ceebc4c8838155a55c9.png" width="392"/>
    </p>
    <p>
     <img alt="" height="282" src="https://i-blog.csdnimg.cn/direct/0d6be5549ba24f80a8c98d0c774fd454.png" width="545"/>
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4" name="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">
     <a id="_19">
     </a>
     二、使用步骤
    </h2>
    <h3 id="1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89" name="1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89">
     1.结构体定义
    </h3>
    <pre><code>typedef int Elem_Type;
struct Node
{
	Elem_Type data;//数据域 存储有效数据
	struct Node* next;//指针域  存下一个有效结点的地址
};

typedef struct Node Node;
typedef struct Node* pNode;</code></pre>
    <blockquote>
     struct Node：定义了一个
     <span style="background-color:#ffd900">
      结构体 Node
     </span>
     ，它包含两个成员：
     <br/>
     Elem_Type data;：
     <span style="background-color:#ffd900">
      数据域
     </span>
     ，用于存储节点中的数据。由于 Elem_Type 被定义为 int，所以这里的 data 可以存储一个整数。
     <br/>
     struct Node* next;：
     <span style="background-color:#ffd900">
      指针域
     </span>
     ，用于存储指向下一个节点的地址。这样，每个节点都可以通过 next 指针链接到下一个节点，形成链表。
     <br/>
     typedef struct Node Node;：为结构体 Node 创建了一个别名 Node，这样在代码中可以直接
     <span style="background-color:#ffd900">
      使用 Node 来声明这种类型的变量
     </span>
     。
     <br/>
     typedef struct Node* pNode;：定义了一个 pNode 类型，它实际上是
     <span style="background-color:#ffd900">
      指向 Node 结构体的指针类型。这通常用于表示链表的头指针或遍历链表时的指针变量。
     </span>
    </blockquote>
    <h3 id="2.%E5%88%9D%E5%A7%8B%E5%8C%96" name="2.%E5%88%9D%E5%A7%8B%E5%8C%96">
     <a id="1_20">
     </a>
     2.初始化
    </h3>
    <pre><code>//初始化
void Init_List(struct Node* head)
{
	assert(head != NULL);
	if (NULL == head)
	{
		exit(EXIT_FAILURE);
	}
	head-&gt;next = nullptr;
}</code></pre>
    <blockquote>
     <ul>
      <li>
       <p>
        参数
        <code>
         head
        </code>
        是指向
        <code>
         Node
        </code>
        结构体的指针。
       </p>
      </li>
      <li>
       <p>
        初始化链表：
        <code>
         head-&gt;next = nullptr;
        </code>
        将
        <code>
         head
        </code>
        节点的
        <code>
         next
        </code>
        指针设置为
        <code>
         nullptr
        </code>
        ，表示链表为空，即没有其他节点。
        <img alt="" height="173" src="https://i-blog.csdnimg.cn/direct/8ac4d18a44ad46cba115ba56784e2489.png" width="543"/>
       </p>
      </li>
     </ul>
    </blockquote>
    <h3 id="3.%E6%8F%92%E5%85%A5" name="3.%E6%8F%92%E5%85%A5">
     <a id="2_34">
     </a>
     3.插入
    </h3>
    <h4 id="3.1%20%E5%A4%B4%E6%8F%92" name="3.1%20%E5%A4%B4%E6%8F%92">
     3.1 头插
    </h4>
    <pre><code>bool Insert_head(struct Node* head, Elem_Type val)
{
	assert(head != NULL);
	if (NULL == head)
	{
		exit(EXIT_FAILURE);
	}

	Node* pnewnode=(Node*)malloc(sizeof(Node));
	if (NULL == pnewnode)
		exit(1);
	pnewnode-&gt;data = val;

	pnewnode-&gt;next = head-&gt;next;
	head-&gt;next = pnewnode;
}</code></pre>
    <blockquote>
     <p>
      <code>
       Node* pnewnode = (Node*)malloc(sizeof(Node));
      </code>
      ：使用
      <code>
       malloc
      </code>
      函数分配内存以创建一个新的
      <code>
       Node
      </code>
      结构体实例，并将其地址赋给指针
      <code>
       pnewnode
      </code>
     </p>
     <ol>
      <li>
       <p>
        <code>
         pnewnode-&gt;data = val;
        </code>
        ：将传入的数据
        <code>
         val
        </code>
        存储在新节点的
        <code>
         data
        </code>
        成员中。
       </p>
      </li>
      <li>
       <p>
        <code>
         pnewnode-&gt;next = head-&gt;next;
        </code>
        ：将新节点的
        <code>
         next
        </code>
        指针指向当前头节点的下一个节点，即链表的第二个节点。
       </p>
      </li>
      <li>
       <p>
        <code>
         head-&gt;next = pnewnode;
        </code>
        ：将头节点的
        <code>
         next
        </code>
        指针指向新节点，这样新节点就成为了链表的第一个节点。
        <img alt="" height="264" src="https://i-blog.csdnimg.cn/direct/5558c822af9c490ba3e124178621f888.png" width="569">
         <img alt="" height="216" src="https://i-blog.csdnimg.cn/direct/40d5d522ab3947c89d68640e5c1be977.png" width="575"/>
        </img>
       </p>
      </li>
     </ol>
    </blockquote>
    <h4 id="3.2%20%E5%B0%BE%E6%8F%92%C2%A0" name="3.2%20%E5%B0%BE%E6%8F%92%C2%A0">
     3.2 尾插
    </h4>
    <pre><code>bool Insert_tail(struct Node* head, Elem_Type val)
{
	assert(head != NULL);
	if (NULL == head)
	{
		exit(EXIT_FAILURE);
	}
	Node* pnewnode = (Node*)malloc(sizeof(Node));
	if (NULL == pnewnode)
		exit(1);
	pnewnode-&gt;data = val;

	Node* p = head;
	while (p-&gt;next != NULL)
	{
		p = p-&gt;next;
	}
	 
	//pnewnode-&gt;next = head-&gt;next;
	//head-&gt;next = pnewnode;
	pnewnode-&gt;next = p-&gt;next;
	p-&gt;next = pnewnode;

	return true;
} </code></pre>
    <p>
     <img alt="" height="323" src="https://i-blog.csdnimg.cn/direct/0c4bfbf3f1bd4141be40fc714bcfd3c4.png" width="663"/>
    </p>
    <h4 id="3.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92" name="3.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92">
     3.3 按位置插
    </h4>
    <pre><code>bool Insert_pos(struct Node* head, Elem_Type val, int pos)
{
	assert(head != NULL);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= Get_Length(head));

	Node* pnewnode = (Node*)malloc(sizeof(Node));
	if (NULL == head)
	{
		exit(1);
	}

	pnewnode-&gt;data = val;

	Node* p = head;
	for (int i = 0; i &lt; pos; i++)
		p = p-&gt;next;

	//pnewnode-&gt;next = head-&gt;next;
     //head-&gt;next = pnewnode;
	pnewnode-&gt;next = p-&gt;next;
	p-&gt;next = pnewnode;

	return true;
}</code></pre>
    <p>
     <img alt="" height="392" src="https://i-blog.csdnimg.cn/direct/ff8281b230d24a5d9df6d9333404ab13.png" width="563">
      <img alt="" height="227" src="https://i-blog.csdnimg.cn/direct/0e093479c9ce4725ae61481c31415270.png" width="646"/>
     </img>
    </p>
    <h3 id="%C2%A0%E5%9B%9B.%E5%88%A0%E9%99%A4" name="%C2%A0%E5%9B%9B.%E5%88%A0%E9%99%A4">
     四.删除
    </h3>
    <h4 id="4.1%E5%A4%B4%E5%88%A0" name="4.1%E5%A4%B4%E5%88%A0">
     4.1头删
    </h4>
    <pre><code>bool Del_head(struct Node* head)
{
	assert(head != NULL);

	 
	if (Is_Empty(head))
		return false;

	Node* p = head-&gt;next;
	head-&gt;next = p-&gt;next;

	free(p);
	p = NULL;
	return true;
}</code></pre>
    <p>
     <img alt="" height="231" src="https://i-blog.csdnimg.cn/direct/4777a568b4ac4a4aa77cf1e3b06b1e71.png" width="644"/>
    </p>
    <p>
     <img alt="" height="189" src="https://i-blog.csdnimg.cn/direct/6b02409eef804f28931939b14465cb59.png" width="458"/>
    </p>
    <h4 id="4.2%20%E5%B0%BE%E5%88%A0" name="4.2%20%E5%B0%BE%E5%88%A0">
     4.2 尾删
    </h4>
    <pre><code>bool Del_tail(struct Node* head)
{
	assert(head != NULL);


	if (Is_Empty(head))
		return false;

	Node* p = head;
	while (p-&gt;next-&gt;next != NULL)
		p = p-&gt;next;

	Node* q = p-&gt;next;
	p-&gt;next = q-&gt;next;

	free(p);
	p = NULL;
	return true;
}</code></pre>
    <p>
     <img alt="" height="168" src="https://i-blog.csdnimg.cn/direct/6b957425b9ab49ab9e7d5b0c96b98905.png" width="630"/>
    </p>
    <p>
     <img alt="" height="183" src="https://i-blog.csdnimg.cn/direct/23fda4b8e4094074901d6bbd4e086525.png" width="539"/>
    </p>
    <h4 id="4.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0" name="4.3%20%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0">
     4.3 按位置删
    </h4>
    <pre><code>//8.按值删(删除值val出现的第一次的地方)
bool Del_val(struct Node* head, Elem_Type val)
{
	//0.assert
	assert(head != NULL);

	//0.5 判断链表是否是空链表
	if (Is_Empty(head))
		return false;

	//1.调用Search函数，查找当前值val是否存在，用临时指针q接收
	Node* q = Search(head, val);
	if (q == NULL)
	{
		return false;
	}

	//2.申请临时指针p，让指针p停留在指针q指向节点的上一个节点
	Node* p = head;
	for ( ; p-&gt;next != q; p = p-&gt;next);

	//3.跨越指向
	p-&gt;next = q-&gt;next;

	//4.释放
	free(q);
	q = NULL;

	return true;
}</code></pre>
    <p>
     <img alt="" height="155" src="https://i-blog.csdnimg.cn/direct/16394872c7fa47e1ba850415bf157656.png" width="622"/>
    </p>
    <p>
     <img alt="" height="310" src="https://i-blog.csdnimg.cn/direct/1993e1f9322c43d7906440b2e598f53a.png" width="633"/>
    </p>
    <h4 id="4.4%E6%8C%89%E5%80%BC%E5%88%A0" name="4.4%E6%8C%89%E5%80%BC%E5%88%A0">
     4.4按值删
    </h4>
    <pre><code>bool Del_val(struct Node* head, Elem_Type val)
{
	//0.assert
	assert(head != NULL);

	//0.5 判断链表是否是空链表
	if (Is_Empty(head))
		return false;

	//1.调用Search函数，查找当前值val是否存在，用临时指针q接收
	Node* q = Search(head, val);
	if (q == NULL)
	{
		return false;
	}

	//2.申请临时指针p，让指针p停留在指针q指向节点的上一个节点
	Node* p = head;
	for ( ; p-&gt;next != q; p = p-&gt;next);

	//3.跨越指向
	p-&gt;next = q-&gt;next;

	//4.释放
	free(q);
	q = NULL;

	return true;
}</code></pre>
    <h3 id="%E4%BA%94%20%E7%BB%9F%E8%AE%A1%E6%9C%89%E6%95%88%E5%80%BC%E4%B8%AA%E6%95%B0%C2%A0" name="%E4%BA%94%20%E7%BB%9F%E8%AE%A1%E6%9C%89%E6%95%88%E5%80%BC%E4%B8%AA%E6%95%B0%C2%A0">
     五 统计有效值个数
    </h3>
    <pre><code>int Get_Length(struct Node* head)
{
	int count = 0;
	for (Node* p = head-&gt;next; p != NULL; p = p-&gt;next)
	{
		count++;
	}

	return count;
}</code></pre>
    <p>
     <img alt="" height="269" src="https://i-blog.csdnimg.cn/direct/823b5f9246d74e5ebf2f7553a53b5181.png" width="628"/>
    </p>
    <h3 id="%E5%85%AD%20%E9%94%80%E6%AF%811" name="%E5%85%AD%20%E9%94%80%E6%AF%811">
     六 销毁1
    </h3>
    <pre><code>//11.销毁1(需要辅助节点参与进来)
void Destroy1(struct Node* head)
{
	//只要不是空链表，则头删一次，直到链表为空
	/*while (!Is_Empty(head))
	{
		Del_head(head);
	}*/

	while (head-&gt;next != NULL)
	{
		Node* q = head-&gt;next;
		head-&gt;next = q-&gt;next;
		free(q);
		q = NULL;
	}
}</code></pre>
    <p>
     <img alt="" height="158" src="https://i-blog.csdnimg.cn/direct/1c790f18987446ed8c03baa89704523b.png" width="353"/>
    </p>
    <h4 id="%E9%94%80%E6%AF%812" name="%E9%94%80%E6%AF%812">
     销毁2
    </h4>
    <pre><code>//12.销毁2(不需要辅助节点参与进来)
void Destroy2(struct Node* head)
{
	//0.assert  head  

	//1.申请指针p，让其保存辅助节点的指针域
	Node* p = head-&gt;next;//p有可能为NULL， 有可能不空

	//2.申请指针q，先不给q赋值
	Node* q = NULL; //因为p有可能是NULL，所以不能现在直接把p-&gt;next给到q

	//3.反复通过p和q打配合，去销毁后续节点
	while (p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}

	//4.节点全部销毁完毕，别忘了把辅助节点的指针域置空
	head-&gt;next = NULL;//这一行代码可以帮助，下一次启用的时候，辅助节点不用初始化了

}
</code></pre>
    <p>
     <img alt="" height="307" src="https://i-blog.csdnimg.cn/direct/0ada41a0c7b04f008c0422664bb14094.png" width="523"/>
    </p>
    <h3 id="%E4%B8%83%20%E6%9F%A5%E6%89%BE" name="%E4%B8%83%20%E6%9F%A5%E6%89%BE">
     七 查找
    </h3>
    <pre><code>//9.查找(查找值val出现的第一次的地方)
struct Node* Search(struct Node* head, Elem_Type val)
{
	//0.assert

	for (Node* p = head-&gt;next; p != NULL; p = p-&gt;next)
	{
		if (p-&gt;data == val)
		{
			return p;
		}
	}

	return NULL;
}</code></pre>
    <h3 id="%E5%85%AB%20%E6%89%93%E5%8D%B0" name="%E5%85%AB%20%E6%89%93%E5%8D%B0">
     八 打印
    </h3>
    <pre><code>//15.打印
void Show(struct Node* head)
{
	//assert

	for (Node* p = head-&gt;next; p != NULL; p = p-&gt;next)
	{
		printf("%d ", p-&gt;data);
	}
	printf("\n");

}</code></pre>
    <h2 id="" name="">
     <a id="_45">
     </a>
    </h2>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37353139373930362f:61727469636c652f64657461696c732f313436303639373233" class_="artid" style="display:none">
 </p>
</div>


