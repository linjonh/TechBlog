---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35303737363432302f:61727469636c652f64657461696c732f313434363038303334"
layout: post
title: "Linux网络基础探索开启你的网络之旅"
date: 2024-12-21 12:27:29 +08:00
description: "详细讲解了网络基础概念，带领读者快速入门了解网络通信原理"
keywords: "【Linux】网络基础探索：开启你的网络之旅"
categories: ['Linux']
tags: ['网络', '服务器', 'Linux']
artid: "144608034"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144608034
    alt: "Linux网络基础探索开启你的网络之旅"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144608034
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144608034
---

# 【Linux】网络基础探索：开启你的网络之旅

![](https://i-blog.csdnimg.cn/direct/d2fb21b1ee6743fca931495a42612e07.png#pic_center)

🌈
**个人主页：
[Zfox\_](https://blog.csdn.net/weixin_50776420?type=blog)**
  
🔥
**系列专栏：
[Linux](https://blog.csdn.net/weixin_50776420/category_12753277.html?spm=1001.2014.3001.5482)**

![](https://i-blog.csdnimg.cn/direct/9f847edb50d9499e90b73ca82eff1413.gif)

#### 目录

* [一：🔥 计算机网络背景](#font_colorDarkOrchid__font_8)
* + [🦋 1-1 网络发展](#_11__10)
* [二：🔥 初识协议](#font_colorDarkOrchid___font_36)
* + [🦋 2-1 协议分层](#_21__64)
  + - [协议分层 vs. 软件分层](#_vs__87)
  + [🦋 2-2 OSI七层网络模型](#_22_OSI_100)
  + [🦋 2-3 TCP/IP 五层(或四层)模型](#_23_TCPIP__122)
* [三：🔥 再识协议](#font_colorDarkOrchid___font_145)
* + [🦋 3-1 为什么要有 TCP/IP 协议？](#_31__TCPIP__146)
  + [🦋 3-2 什么是 TCP/IP 协议？](#_32__TCPIP__156)
  + [🦋 3-3 TCP/IP 协议与操作系统的关系(宏观上， 怎么实现的)](#_33_TCPIP___159)
  + [🦋 3-4 所以究竟什么是协议？](#_34__162)
* [四：🔥 网络传输基本流程](#font_colorDarkOrchid___font_175)
* + [🦋 4-1 局域网(以太网为例)通信原理](#_41__177)
  + - [4-1-1 认识 MAC 地址](#411__MAC__181)
    - [4-1-2 数据包封装和分用](#412__224)
  + [🦋 4-2 跨网络传输流程图](#_42__237)
  + - [4-2-1 网络中的地址管理 - 认识 IP 地址](#421____IP__238)
* [五：🔥 Socket 编程预备](#font_colorDarkOrchid_Socket__font_267)
* + [🦋 5-1 理解源 IP 地址和目的 IP 地址](#_51__IP__IP__268)
  + [🦋 5-2 认识端口号](#_52__285)
  + - [5-2-1 端口号范围划分](#521__293)
    - [5-2-2 理解 "端口号" 和 "进程 ID"](#522_____ID_298)
    - [5-2-3 理解源端口号和目的端口号](#523__305)
  + [🦋 5-3 理解 socket](#_53__socket_308)
  + [🦋 5-4 传输层的典型代表](#_54__315)
  + - [5-4-1 认识 TCP 协议](#541__TCP__320)
    - [5-4-2 认识 UDP 协议](#542__UDP__326)
  + [🦋 5-5 网络字节序](#_55__335)
  + [🦋 5-6 socket 编程接口](#_56_socket__358)
  + - [5-6-1 socket 常见 API](#561_socket__API_359)
    - [5-6-2 sockaddr 结构](#562_sockaddr__378)
    - * [5-6-2-1 sockaddr 结构](#5621_sockaddr__388)
      * [5-6-2-2 sockaddr\_in 结构](#5622_sockaddr_in__391)
      * [5-6-2-3 in\_addr 结构](#5623_in_addr__399)
* [六：🔥 共勉](#font_colorDarkOrchid__font_406)

## 一：🔥 计算机网络背景

### 🦋 1-1 网络发展

![](https://i-blog.csdnimg.cn/direct/26b3e67962184983808e1f35bc136fb4.png#pic_center)
  

🛜
**网络互联: 多台计算机连接在一起, 完成数据共享;**

![](https://i-blog.csdnimg.cn/direct/9e0ee5f2c5314b61b5d3f92fdd0aea6d.png#pic_center)
  

**`局域网 （Local Area Network，LAN）`
: 计算机数量更多了, 通过交换机和路由器连接在一起；**
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b26748841eac45d3a05d7e3c8190f619.png)

📚
**`广域网 （Wide Area Network，WAN）`
: 将远隔千里的计算机都连在一起;**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0722dad221a4488ca92eeef1f2e63572.png)

**所谓 “局域网” 和 “广域网” 只是一个相对的概念. 比如, 我们有 “天朝特色” 的广域网, 也可以看做一个比较大的局域网.**

* **计算机是人的工具， 人要协同工作， 注定了网络的产生是必然的**

## 二：🔥 初识协议

* **"
  `协议`
  " 是一种约定.**
* **打电话约定电话铃响的次数的约定**
    
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2233f60c50604db28533286f3f17b146.png)
    
  **计算机之间的传输媒介是 光信号 和 电信号. 通过 “频率” 和 “强弱” 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式.**

> **🎯 思考: 只要通信的两台主机, 约定好协议就可以了么?**
>
> * **定好协议， 但是你用频率表示 01， 我用强弱表示 01， 就好比我用中国话， 你用葡萄牙语一样， 虽然大家可能遵守的一套通信规则， 但是语言不同，即是订好了基本的协议， 也是无法正常通信的。**
>     
>     
>   **所以， 完善的协议， 需要更多更细致的规定， 并让参与的人都要遵守。**
> * **计算机生产厂商有很多;**
> * **计算机操作系统, 也有很多;**
> * **计算机网络硬件设备, 还是有很多;**
> * **如何让这些不同厂商之间生产的计算机能够相互顺畅的通信? 就需要有人站出来, 约定一个共同的标准, 大家都来遵守, 这就是
>   `网络协议`
>   ;**

📚
**网络协议的核心作用包括：**

* **`标准化`
  ：使不同厂商的设备能够互联互通。**
* **`规范性`
  ：定义了数据在传输过程中的行为。**
* **`可靠性`
  ：通过校验和重传机制，确保数据正确传输。**

📚
**举例：**

* **`HTTP协议`
  ：定义了网页浏览器与服务器之间的通信规则。**
* **`TCP协议`
  ：确保数据在传输中无错误且按顺序到达。**

### 🦋 2-1 协议分层

**网络通信是一个复杂的过程，为了降低设计难度并提高效率，网络协议通常采用分层设计的理念。分层设计将复杂的通信任务划分为若干独立的功能模块，每个模块专注于特定任务。**

![](https://i-blog.csdnimg.cn/direct/046edab52e694c1eb07950feed334114.png#pic_center)

* **在这个例子中, 我们的"协议"只有两层:语言层、 通信设备层。**
* **但是实际的网络通信协议， 设计的会更加复杂, 需要分更多的层**
* **但是通过上面的简单例子， 我们是能理解， 分层可以实现解耦合， 让软件维护的成本更低**

**协议分层的特点：**

1. **`模块化设计`**
     
   **每一层完成特定功能，互不干扰。例如，传输层关注数据的可靠传输，而物理层则负责信号的传递。**
2. **`接口标准化`**
     
   **各层之间通过接口传递数据和信息，无需了解其他层的具体实现。例如，应用层无需关注底层硬件如何工作。**
3. **`便于开发与维护`**
     
   **协议的分层设计使得开发者可以专注于某一层的优化，而不影响其他层。**

#### 协议分层 vs. 软件分层

协议分层与操作系统的软件分层理念相似。例如，在Linux系统中：

* **操作系统的分层包括内核层、硬件抽象层和用户层。**
* **协议的分层则对应了从物理传输到应用服务的不同阶段。**

二者的共同点在于通过分层实现复杂任务的简化和模块化。例如：

* **协议分层：物理层负责电信号传输，传输层确保数据可靠到达。**
* **软件分层：驱动程序负责硬件控制，用户应用只需调用接口。**

通过分层设计，网络协议不仅实现了多厂商设备的互通，还为Linux等操作系统提供了结构化的网络通信支持。

### 🦋 2-2 OSI七层网络模型

**`OSI（Open Systems Interconnection）`**
模型是国际标准化组织（ISO）提出的网络通信框架，是一种理论上的参考模型，用于定义网络通信的结构和分层。

OSI 模型将网络通信划分为七个层次，从硬件传输到应用服务，层与层之间通过标准接口交互。其核心目的是规范和简化不同设备、协议之间的通信，促进互联互通。

它的最大优点是将服务、 接口和协议这三个概念明确地区分开来， 概念清楚，理论也比较完整. 通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯;

• 但是, 它既复杂又不实用; 所以我们按照 TCP/IP 四层模型来讲解

| 层次 | 主要功能 | 示例协议/设备 |
| --- | --- | --- |
| 应用层 | 面向用户，提供网络服务接口，如文件传输、邮件、远程登录等。 | HTTP、FTP、SMTP |
| 表示层 | 数据格式的转换、加密、解密和压缩，确保不同设备之间的数据表示一致。 | JPEG、GIF、TLS |
| 会话层 | 管理会话建立、维持和断开，如数据同步和传输控制。 | NetBIOS、RPC |
| 传输层 | 提供端到端的可靠数据传输和错误检测，确保数据完整到达目标端。 | TCP、UDP |
| 网络层 | 负责路由和逻辑地址（IP）的分配，确保数据能跨网络到达目标设备。 | IP、ICMP、IGRP |
| 数据链路层 | 负责数据帧的组装、传输与错误检测，在局域网中完成数据的正确传输。 | Ethernet、PPP、Wi-Fi |
| 物理层 | 负责比特流的传输，定义物理介质（如光纤、电缆）和信号规范（如电压、频率）。 | 光纤、网线、无线信号 |

其实在网络角度， OSI 定的协议 7 层模型其实非常完善， 但是在实际操作的过程中， 会话层、 表示层是不可能接入到操作系统中的， 所以在工程实践中， 最终落地的是 5 层协议。

* 但是要理解上面的话， 需要我们学习完网络才可以理解， 这里就知道就可以

### 🦋 2-3 TCP/IP 五层(或四层)模型

TCP/IP 是一组协议的代名词， 它还包括许多协议， 组成了 TCP/IP 协议簇.
  
TCP/IP 通讯协议采用了 5 层的层级结构， 每一层都呼叫它的下一层所提供的网络来完成自己的需求

> * **`物理层`
>   : 负责光 / 电信号的传递方式. 比如现在以太网通用的网线(双绞 线)、 早期以太网采用的的同轴电缆(现在主要用于有线电视)、 光纤, 现在的 wifi 无线网使用电磁波等都属于物理层的概念。 物理层的能力决定了最大传输速率、 传输距离、 抗干扰性等. 集线器 (Hub) 工作在物理层.**
> * **`数据链路层`
>   : 负责设备之间的数据帧的传送和识别. 例如网卡设备的驱动、 帧同步(就是说从网线上检测到什么信号算作新帧的开始)、 冲突检测(如果检测到冲突就自动重发)、 数据差错校验等工作. 有以太网、 令牌环网, 无线 LAN 等标准. 交换机 (Switch) 工作在数据链路层.**
> * **`网络层`
>   : 负责地址管理和路由选择. 例如在 IP 协议中, 通过 IP 地址来标识一台主机, 并通过路由表的方式规划出两台主机之间的数据传输的线路(路由). 路由器 (Router) 工作在网路层.**
> * **`传输层`
>   : 负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机.**
> * **`应用层`
>   : 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet） 等. 我们的网络编程主要就是针对应用层.**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6cb6a47514ea46f09070df49d4fd4659.png)

一般而言

* **对于一台主机, 它的操作系统内核实现了从传输层到物理层的内容;**
* **对于一台路由器, 它实现了从网络层到物理层;**
* **对于一台交换机, 它实现了从数据链路层到物理层;**
* **对于集线器, 它只实现了物理层;**
    
  但是并不绝对. 很多交换机也实现了网络层的转发; 很多路由器也实现了部分传输层的内容(比如端口转发);

## 三：🔥 再识协议

### 🦋 3-1 为什么要有 TCP/IP 协议？

* 首先， 即便是单机， 你的计算机内部， 其实都是存在协议的， 比如： 其他设备和内存通信， 会有内存协议。 其他设备和磁盘通信， 会有磁盘相关的协议， 比如：SATA， IDE， SCSI 等。 只不过我们感知不到罢了。 而且这些协议都在本地主机各自的硬件中， 通信的成本、 问题比较少。
* 其次， 网络通信最大的特点就是主机之间变远了。 任何通信特征的变化， 一定会带来新的问题， 有问题就得解决问题， 所以需要新的协议咯。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fa8a84ba896f429db9659cf8c8423e63.png)

* **所以， 为什么要有 TCP/IP 协议？ 本质就是通信主机距离变远了**

### 🦋 3-2 什么是 TCP/IP 协议？

* **`TCP/IP 协议的本质是一种解决方案`**
* **`TCP/IP 协议能分层， 前提是因为问题们本身能分层`**

### 🦋 3-3 TCP/IP 协议与操作系统的关系(宏观上， 怎么实现的)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/720117f4c8f64c8f9f8e3e6e45844827.png)

### 🦋 3-4 所以究竟什么是协议？

截止到目前， 我们还没接触过任何协议， 但是如何朴素的理解协议， 我们已经可以试试了。

* OS 源代码一般都是用 C/C++语言写的。
    
  下面， 仔细看看下面的图

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/586072b731344f27a05ef3a97d065761.png)

关于协议的朴素理解： 所谓协议， 就是通信双方都认识的结构化的数据类型

因为协议栈是分层的， 所以， 每层都有双方都有协议， 同层之间， 互相可以认识对方的协议。

## 四：🔥 网络传输基本流程

### 🦋 4-1 局域网(以太网为例)通信原理

* 首先回答， 两台主机在同一个局域网， 是否能够直接通信？ 是的
* 原理类似上课
* 每台主机在局域网上， 要有唯一的标识来保证主机的唯一性： mac 地址

#### 4-1-1 认识 MAC 地址

* **MAC 地址用来识别数据链路层中相连的节点;**
* **长度为 48 位, 及 6 个字节. 一般用 16 进制数字加上冒号的形式来表示(例如 : 08:00:27:03:fb:19)**
* **在网卡出厂时就确定了, 不能修改. mac 地址通常是唯一的(虚拟机中的 mac 地址不是真实的 mac 地址, 可能会冲突; 也有些网卡支持用户配置 mac 地址).**

后面我们详细谈论数据链路层的时候， 会谈 mac 帧协议， 此处我们做一个了解即可。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4a86e6f6119547d68ab051932cc76d6d.png)

* 以太网中， 任何时刻， 只允许一台机器向网络中发送数据
* **如果有多台同时发送， 会发生数据干扰， 我们称之为数据碰撞**
* **所有发送数据的主机要进行碰撞检测和碰撞避免**
* **没有交换机的情况下， 一个以太网就是一个碰撞域**
* 局域网通信的过程中， 主机对收到的报文确认是否是发给自己的， 是通过目标 mac 地址判定
* 这里可以试着从系统角度来理解局域网通信原理

初步明白了局域网通信原理， 再来看同一个网段内的两台主机进行发送消息的过程

![](https://i-blog.csdnimg.cn/direct/253fc1f2542c41f2b3628c8594e4a079.png#pic_center)
而其中每层都有协议， 所以当我进行进行上述传输流程的时候， 要进行封装和解包

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aefc41ab837347b79ee3bc1f5a2e3400.png)
  
下面我们明确一下概念

![](https://i-blog.csdnimg.cn/direct/8abba175db764002ba9d26f58e089771.png#pic_center)
- \*\*
报头部分， 就是对应协议层的结构体字段， 我们一般叫做 `报头`\*\* - \*\*除了报头， 剩下的叫做 `有效载荷`\*\* - \*\*故， `报文 = 报头 + 有效载荷`\*\*

然后， 我们在明确一下不同层的完整报文的叫法

> * **不同的协议层对数据包有不同的称谓, 在
>   `传输层叫做 段(segment)`
>   , 在
>   `网络层叫做 数据报 (datagram)`
>   , 在
>   `链路层叫做 帧(frame).`**
> * **应用层数据通过协议栈发到网络上时,每层协议都要加上一个 数据首部(header), 称为 封装(Encapsulation).**
> * **首部信息中包含了一些类似于首部有多长, 载荷(payload) 有多长, 上层协议是什么等信息.**
> * **`数据封装成帧后发到传输介质上,到达目的主机后每层协议再剥掉相应的首部,根据首部中的 "上层协议字段" 将数据交给对应的上层协议处理`**

最后， 在整体复盘一下：

![](https://i-blog.csdnimg.cn/direct/3878cb9c0c564b949d1a04a2052a7e9c.png#pic_center)

* **在网络传输的过程中， 数据不是直接发送给对方主机的， 而是先要自定向下将数据交付给下层协议， 最后由底层发送， 然后由对方主机的底层来进行接受， 在自底向上进行向上交付， 下面是一张示意图。**

#### 4-1-2 数据包封装和分用

下图为数据封装的过程

![](https://i-blog.csdnimg.cn/direct/8e8dbd06b73e4a7b8e251ae4edd6e903.png#pic_center)
下图为数据分用的过程
![](https://i-blog.csdnimg.cn/direct/615f8571570146faa7d8d2b111502c23.png#pic_center)
从今天开始， 我们学习任何协议， 都要先宏观上建立这样的认识： 1. 要学习的协议， 是如何做到解包的？ 只有明确了解包， 封包也就能理解 2. 要学习的协议， 是如何做到将自己的有效载荷， 交付给上层协议的？（分用）

### 🦋 4-2 跨网络传输流程图

#### 4-2-1 网络中的地址管理 - 认识 IP 地址

IP 协议有两个版本, IPv4 和 IPv6. 我们整个的博客, 凡是提到 IP 协议, 没有特殊说明的,默认都是指 IPv4

* IP 地址是在 IP 协议中, 用来标识网络中不同主机的地址;
* 对于 IPv4 来说, IP 地址是一个 4 字节, 32 位的整数;
* 我们通常也使用 “点分十进制” 的字符串表示 IP 地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个字节, 范围是 0 - 255;

📚
**跨网段的主机的数据传输. 数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器**

下面是一张示意图
  
![](https://i-blog.csdnimg.cn/direct/4c59757575974599add3eb70655244b6.png#pic_center)
  
首先理解一下 IP 地址的意义

* 为什么要去目标主机， 先要走路由器？
* 目的 IP 的意义

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/928262868d7b407c9c497dbb0956f72a.png)
  
📚
**然后结合封装与解包， 体现路由器解包和重新封装的特点**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7b70dac9d6964583a52f6c89f7c78f08.png)
  
对比 IP 地址和 Mac 地址的区别

* **IP 地址在整个路由过程中， 一直不变(目前， 我们只能这样说明， 后面在修正)**
* **Mac 地址一直在变**
* **目的 IP 是一种长远目标， Mac 是下一阶段目标， 目的 IP 是路径选择的重要依据， mac 地址是局域网转发的重要依据**

提炼 IP 网络的意义和网络通信的宏观流程
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/94640b67a3184b579bafc6ec6fbcb415.png)
  
**IP 网络层存在的意义： 提供网络虚拟层， 让世界的所有网络都是 IP 网络， 屏蔽最底层网络的差异**

## 五：🔥 Socket 编程预备

### 🦋 5-1 理解源 IP 地址和目的 IP 地址

* IP 在网络中， 用来标识主机的唯一性
* 注意： 后面我们会讲 IP 的分类， 后面会详细阐述 IP 的特点

但是这里要思考一个问题： 数据传输到主机是目的吗？ 不是的。 因为数据是给人用的。 比如： 聊天是人在聊天， 下载是人在下载， 浏览网页是人在浏览？

但是人是怎么看到聊天信息的呢？ 怎么执行下载任务呢？ 怎么浏览网页信息呢？ 通过启动的 qq， 迅雷， 浏览器。

而启动的 qq， 迅雷， 浏览器都是进程。 换句话说， 进程是人在系统中的代表， 只要把数据给进程， 人就相当于就拿到了数据。

**所以： 数据传输到主机不是目的， 而是手段。 到达主机内部， 在交给主机内的进程，才是目的。**

但是系统中， 同时会存在非常多的进程， 当数据到达目标主机之后， 怎么转发给目标进程？ 这就要在网络的背景下， 在系统中， 标识主机的唯一性。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8765e6cfe18a4bfbb3b6692cd74324c3.png)

### 🦋 5-2 认识端口号

端口号(port)是传输层协议的内容.

> * **端口号是一个 2 字节 16 位的整数;**
> * **端口号用来标识一个进程, 告诉操作系统, 当前的这个数据要交给哪一个进程来处理;**
> * **IP 地址 + 端口号能够标识网络上的某一台主机的某一个进程;**
> * **一个端口号只能被一个进程占用**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5b25ecc8e1e042658977e68ad00fe219.png)

#### 5-2-1 端口号范围划分

> * **`0 - 1023: 知名端口号`
>   , HTTP, FTP, SSH 等这些广为使用的应用层协议, 他们的端口号都是固定的.**
> * **`1024 - 65535`
>   : 操作系统动态分配的端口号. 客户端程序的端口号, 就是由操作系统从这个范围分配的.**

#### 5-2-2 理解 “端口号” 和 “进程 ID”

我们之前在学习系统编程的时候, 学习了 pid 表示唯一一个进程; 此处我们的端口号也是唯一表示一个进程. 那么这两者之间是怎样的关系?

10086 例子
  
**另外, 一个进程可以绑定多个端口号; 但是一个端口号不能被多个进程绑定;**

* **`进程 ID 属于系统概念， 技术上也具有唯一性， 确实可以用来标识唯一的一个进程， 但是这样做， 会让系统进程管理和网络强耦合， 实际设计的时候， 并没有选择这样做。`**

#### 5-2-3 理解源端口号和目的端口号

📚
**传输层协议(TCP 和 UDP)的数据段中有两个端口号, 分别叫做 源端口号 和 目的端口号. 就是在描述 “数据是谁发的, 要发给谁”;**

### 🦋 5-3 理解 socket

* **综上， IP 地址用来标识互联网中唯一的一台主机， port 用来标识该主机上唯一的一个网络进程**
* **IP+Port 就能表示互联网中唯一的一个进程**
* **所以， 通信的时候， 本质是两个互联网进程代表人来进行通信， {srcIp，srcPort， dstIp， dstPort}这样的 4 元组就能标识互联网中唯二的两个进程**
* **所以， 网络通信的本质， 也是进程间通信**
* **我们把 ip+port 叫做套接字 socket**

### 🦋 5-4 传输层的典型代表

如果我们了解了系统， 也了解了网络协议栈， 我们就会清楚， 传输层是属于内核的， 那么我们要通过网络协议栈进行通信， 必定调用的是传输层提供的系统调用， 来进行的网络通信。
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/027924800885468fb84a7f85ec4a0026.png)

#### 5-4-1 认识 TCP 协议

**此处我们先对
`TCP(Transmission Control Protocol 传输控制协议)`
有一个直观的认识; 后面我们再详细讨论 TCP 的一些细节问题.**

> * **传输层协议**
> * **有连接**
> * **可靠传输**
> * **面向字节流**

#### 5-4-2 认识 UDP 协议

**此处我们也是对
`UDP(User Datagram Protocol 用户数据报协议)`
有一个直观的认识; 后面再详细讨论.**

> * **传输层协议**
> * **无连接**
> * **不可靠传输**
> * **面向数据报**

因为我们暂时还没有深入了解 tcp、 udp 协议， 此处只做了解即可

### 🦋 5-5 网络字节序

我们已经知道,内存中的多字节数据相对于内存地址有大端和小端之分, 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分, 网络数据流同样有大端小端之分. 那么如何定义网络数据流的地址呢?

> * **发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;**
> * **接收主机把从网络上接到的字节依次保存在接收缓冲区中,也是按内存地址从低到高的顺序保存;**
> * **因此,网络数据流的地址应这样规定:先发出的数据是低地址,后发出的数据是高地址.**
> * **`TCP / IP 协议规定,网络数据流应采用大端字节序,即低地址高字节.`**
> * **不管这台主机是大端机还是小端机, 都会按照这个 TCP/IP 规定的网络字节序来发送/接收数据;**
> * **如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3ee259672269420a9c86914c2e86f50f.png)

**🎯 为使网络程序具有可移植性,使同样的 C 代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ebe6531deda44489b87efb59c713df3b.png)

> * **这些函数名很好记,
>   `h 表示 host`
>   ,
>   `n 表示 network`
>   ,
>   `l 表示 32 位长整数`
>   ,
>   `s 表示 16 位短整数`
>   。**
> * **例如
>   `htonl 表示将 32 位的长整数从主机字节序转换为网络字节序`
>   , 例如将 IP 地址转换后准备发送。**
> * **如果主机是小端字节序, 这些函数将参数做相应的大小端转换然后返回;**
> * **如果主机是大端字节序, 这些函数不做转换, 将参数原封不动地返回。**

### 🦋 5-6 socket 编程接口

#### 5-6-1 socket 常见 API

```cpp
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)
int socket(int domain, int type, int protocol);

// 绑定端口号 (TCP/UDP, 服务器)
int bind(int socket, const struct sockaddr *address, socklen_t address_len);

// 开始监听 socket (TCP, 服务器)
int listen(int socket, int backlog);

// 接收请求 (TCP, 服务器)
int accept(int socket, struct sockaddr* address, socklen_t* address_len);

// 建立连接 (TCP, 客户端)
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

```

#### 5-6-2 sockaddr 结构

**🦁 socket API 是一层抽象的网络编程接口,适用于各种底层网络协议,如 IPv4、 IPv6, 以及后面要讲的 UNIX Domain Socket. 然而, 各种网络协议的地址格式并不相同.**

![](https://i-blog.csdnimg.cn/direct/c4d250b398c44e34afa2b282cb3efae9.png#pic_center)
> * **Pv4 和 IPv6 的地址格式定义在 netinet / in.h 中,IPv4 地址用 sockaddr\_in 结构体表示,包括 16 位地址类型, 16 位端口号和 32 位 IP 地址.**
> * **IPv4、 IPv6 地址类型分别定义为常数
>   `AF_INET`
>   、
>   `AF_INET6`
>   . 这样,只要取得某种 sockaddr 结构体的首地址,不需要知道具体是哪种类型的 sockaddr 结构体,就可以根据地址类型字段确定结构体中的内容.**
> * **socket API 可以都用
>   `struct sockaddr \*`
>   类型表示, 在使用的时候需要强制转化成
>   `sockaddr_in`
>   ; 这样的好处是程序的通用性, 可以接收 IPv4, IPv6, 以及 UNIX Domain Socket 各种类型的 sockaddr 结构体指针做为参数;**

##### 5-6-2-1 sockaddr 结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e7fa608da5b24f00a1b917ddfb4317eb.png)

##### 5-6-2-2 sockaddr\_in 结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/66290a0ba7ae4bc8a72fa872c9e5e9af.png)
  
**虽然 socket api 的接口是 sockaddr, 但是我们真正在基于 IPv4 编程时, 使用的数据结构是 sockaddr\_in; 这个结构里主要有三部分信息: 地址类型, 端口号, IP 地址。**

📚
**其中，
`__SOCKADDR_DOMMON`
是一个宏 即
`sin_family`**
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9cdcd1dd80fe40ce9f42647338e0e99d.png)

##### 5-6-2-3 in\_addr 结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/450273a40a1641519d405bc6a4af1193.png)

* **in\_addr 用来表示一个 IPv4 的 IP 地址. 其实就是一个 32 位的整数;**

## 六：🔥 共勉

以上就是我对
**`【Linux】线程同步与互斥`**
的理解，觉得这篇博客对你有帮助的，可以点赞收藏关注支持一波~😉
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1c9d1ff0140a4e5685ff162c69851475.gif)