---
layout: post
title: "前端vue学习笔记CLASS-4组件组成部分与通信"
date: 2025-03-16 23:10:45 +0800
description: "作用：为组件的prop指定验证要求，不符合要求，控制台就会有错误提示，帮助开发者，快速发现错误。在子组件中利用props接收，并且用$emit通知，其中的事件名为update:属性名。恰当时机，通过this.$refs.xxx，获取目标组件，就可以调用组件对象里面的方法。默认情况下，写在组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。最终效果：必须是当前组件的元素，才会有这个自定义的属性，才会被这个样式作用到。2、局部样式：可以给组件加上scoped属性，可以让样式只作用于当前组件。"
keywords: "前端（vue)学习笔记（CLASS 4）：组件组成部分与通信"
categories: ['未分类']
tags: ['学习', '前端', 'Vue']
artid: "146191043"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146191043
    alt: "前端vue学习笔记CLASS-4组件组成部分与通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146191043
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146191043
cover: https://bing.ee123.net/img/rand?artid=146191043
image: https://bing.ee123.net/img/rand?artid=146191043
img: https://bing.ee123.net/img/rand?artid=146191043
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     前端（vue)学习笔记（CLASS 4）：组件组成部分与通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4>
     1、组件的三大组成部分（结构/样式/逻辑）
    </h4>
    <p>
     注意点：
    </p>
    <p>
     1、结构只能有一个根元素
    </p>
    <p>
     2、全局样式（默认），影响所有组件；局部样式，scoped下样式，只作用于当前组件
    </p>
    <p>
     3、el根实例独有，data是一个函数，其他配置项一致
    </p>
    <p>
     样式注意点：
    </p>
    <p>
     默认情况下，写在组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题
    </p>
    <p>
     1、全局样式：默认组件中的样式会作用到全局
    </p>
    <p>
     2、局部样式：可以给组件加上scoped属性，可以让样式只作用于当前组件
    </p>
    <p>
     scoped原理
    </p>
    <p>
     1、当前组件内标签都被添加上data-v-hash值的属性
    </p>
    <p>
     2、css选择器都被添加[data-v-hash]的属性选择器
    </p>
    <p>
     最终效果：必须是当前组件的元素，才会有这个自定义的属性，才会被这个样式作用到
    </p>
    <h4>
     2、data函数
    </h4>
    <p>
     一个组件的data选项必须是一个函数，保证每个组件实例维护独立的一份数据对象
    </p>
    <p>
     例如：
    </p>
    <pre><code class="language-javascript">data() {
    return {
        count: 100
    }
},</code></pre>
    <p>
     每次创建新的组件实例，都会新执行一次data函数，得到一个新对象
    </p>
    <h4>
     3、组件通信
    </h4>
    <p>
     组件通信，就是指组件与组件之间的数据传递
    </p>
    <p>
     组件的数据是独立的，无法直接访问其他组件的数据
    </p>
    <p>
     想用其他组件的数据-&gt;组件通信
    </p>
    <p>
     组件关系分类：
    </p>
    <p>
     1、父子关系
    </p>
    <p>
     2、非父子关系
    </p>
    <h5>
     1、父子关系通信
    </h5>
    <p>
     1、父组件通过props将数据传递给子组件
    </p>
    <p>
     具体流程，在父组件中，如果调用了子组件，需要给子组件添加一个自定义属性，在头标签：
    </p>
    <pre><code class="language-html">&lt;div :属性名="传递的参数名"&gt;&lt;/div&gt;</code></pre>
    <p>
     之后在子组件中添加配置项props
    </p>
    <pre><code class="language-javascript">props:['属性名']</code></pre>
    <p>
     即可在子组件中使用父组件的参数
    </p>
    <p>
     2、子组件利用$emit通知父组件修改更新
    </p>
    <p>
     具体流程，在子组件中使用$emit，可能会放在函数里
    </p>
    <pre><code class="language-javascript">handClick () {
    this.$emit('通知','修改后的数据')
}</code></pre>
    <p>
     然后在父组件中的子组件内加上@changTitle="函数名"，用于监听事件
    </p>
    <p>
     创建一个函数，函数的参数为新参数的名字，最后在函数内进行修改
    </p>
    <h5>
     2、prop详解
    </h5>
    <p>
     prop定义：组件上 注册的一些 自定义属性
    </p>
    <p>
     Prop作用：向子组件传递数据
    </p>
    <p>
     特点：可以传递任意数量和任意类型的prop
    </p>
    <p>
     校验：
    </p>
    <p>
     作用：为组件的prop指定验证要求，不符合要求，控制台就会有错误提示，帮助开发者，快速发现错误
    </p>
    <p>
     语法：
    </p>
    <p>
     1、类型校验
    </p>
    <pre><code class="language-javascript">props: {
    校验的属性名：类型
}</code></pre>
    <p>
     2、非空校验
    </p>
    <p>
     3、默认值
    </p>
    <p>
     4、自定义校验
    </p>
    <pre><code class="language-javascript">props:{
    校验的属性名：{
        type：类型，
        required：true，//是否必填
        default：默认值，//morz
        validator（value） {
            //自定义校验逻辑
            return 是否通过校验
        }
    }
}</code></pre>
    <p>
     prop&amp;data
    </p>
    <p>
     共同点：都可以给组件提供数据
    </p>
    <p>
     区别：
    </p>
    <p>
     data的数据是自己的，可以随意修改
    </p>
    <p>
     prop的数据是外部的，不能直接改，要遵循单向数据流
    </p>
    <h5>
     3、非父子关系通信
    </h5>
    <p>
     利用event bus事件总线
    </p>
    <p>
     作用：完成非父子组件之间，进行简易消息传递（复杂场景，vuex）
    </p>
    <p>
     1、创建一个都能访问到的事件总线（空Vue实例），utils/EventBus.js
    </p>
    <pre><code class="language-javascript">import Vue form 'vue'
const Bus = new Vue()
export default Bus</code></pre>
    <p>
     2、接收方，监听Bus实例的事件
    </p>
    <pre><code class="language-javascript">created() {
  Bus.$on('sendMsg',(msg) =&gt; {
    this.msg=msg
  })
}</code></pre>
    <p>
     3、发送方，触发Bus实例的事件
    </p>
    <pre><code class="language-javascript">Bus.$emit('sendMsg','这是一个消息')</code></pre>
    <h4>
     4、v-model原理
    </h4>
    <p>
     原理：v-model本质上是语法糖，例如在输入框上，就是value属性和input事件的合写
    </p>
    <p>
     作用：提供双向数据绑定
    </p>
    <p>
     1、数据变，视图跟着变:value
    </p>
    <p>
     2、视图变，数据跟着变@input
    </p>
    <p>
     注意：$event用于在模板中，获取事件的形参
    </p>
    <h4>
     5、表单类组件封装&amp;v-model简化代码
    </h4>
    <h5 style="background-color:transparent">
     1、表单类组件封装
    </h5>
    <p>
     1、父传子：数据应该是父组件props传递过来的，v-model拆解绑定数据
    </p>
    <pre><code class="language-javascript">&lt;BaseSelect :cityId="selectId" @事件名="selectedId=$event"&gt;&lt;/BaseSelect&gt;</code></pre>
    <p>
     2、子传父：监听输入，子传父传值给父组件修改
    </p>
    <pre><code class="language-html">  &lt;select :value="cityId" @change="handleChange"&gt;&lt;/select&gt;</code></pre>
    <pre><code class="language-javascript">props: {
  cityId: String
}</code></pre>
    <pre><code class="language-javascript">  methods: {
    handleChange(e) {
      this.$emit('事件名',e.target.value)
    }
}</code></pre>
    <h5>
     2、父组件v-model简化代码，实现父子双向绑定
    </h5>
    <p>
     1、子组件中：prop通过value接收，事件触发input
    </p>
    <p>
     2、父组件中：v-model给组件直接绑数据(:value+@input)
    </p>
    <pre><code class="language-html">  &lt;BaseSelect v-model="selectId"&gt;&lt;/BaseSelect&gt;</code></pre>
    <h4>
     6、.sync修饰符
    </h4>
    <p>
     作用：可以实现子组件与父组件数据的双向绑定，简化代码
    </p>
    <p>
     特点：prop属性名，可以自定义，非固定为value
    </p>
    <p>
     场景：封装弹框类的基础组件，visible属性 true显示false隐藏
    </p>
    <p>
     用法，直接在属性名后加上即可
    </p>
    <p>
     在子组件中利用props接收，并且用$emit通知，其中的事件名为update:属性名
    </p>
    <h4>
     7、ref和$refs
    </h4>
    <p>
     作用：利用这个可以用于获取dom元素，或组件实例
    </p>
    <p>
     特点：查找范围-&gt;当前组件内（更精确稳定）
    </p>
    <p>
     1、获取dom：
    </p>
    <p>
     目标标签-添加ref属性，属性值自拟
    </p>
    <p>
     恰当时机，通过this.$refs.ref属性值，获取目标标签
    </p>
    <p>
     要在mounted后才能进行获取
    </p>
    <p>
     2、获取组件实例
    </p>
    <p>
     目标组件，添加ref属性
    </p>
    <p>
     恰当时机，通过this.$refs.xxx，获取目标组件，就可以调用组件对象里面的方法
    </p>
    <h4>
     8、Vue异步更新
    </h4>
    <p>
     使用$nextTick:等dom更新完后，才会触发执行此方法里的函数
    </p>
    <pre><code class="language-javascript">this.$nextTick(() =&gt; {
    this.$refs.inp.focus()
})</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38313335313436382f:61727469636c652f64657461696c732f313436313931303433" class_="artid" style="display:none">
 </p>
</div>


