---
layout: post
title: "01.02判定是否互为字符重排"
date: 2025-03-11 19:22:28 +0800
description: "是否可以通过重新排列字符使得其中一个字符串变为另一个字符串。这意味着，我们需要检查这两个字符串是否包含完全相同的字符，并且每个字符的数量也必须相同。如果两个字符串是彼此的排列，那么对这两个字符串进行排序后，它们应该完全相同。，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。在这道题中，我们的任务是判断两个字符串。给定两个由小写字母组成的字符串。"
keywords: "java 怎样描述两个字符串是否互为字符重排"
categories: ['题解']
tags: ['算法', 'Leetcode']
artid: "141907661"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=141907661
    alt: "01.02判定是否互为字符重排"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=141907661
featuredImagePreview: https://bing.ee123.net/img/rand?artid=141907661
cover: https://bing.ee123.net/img/rand?artid=141907661
image: https://bing.ee123.net/img/rand?artid=141907661
img: https://bing.ee123.net/img/rand?artid=141907661
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     01.02、判定是否互为字符重排
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="0102_httpsleetcodecnproblemscheckpermutationlccidescription_0">
     </a>
     01.02、
     <a href="https://leetcode.cn/problems/check-permutation-lcci/description/" rel="nofollow">
      [简单] 判定是否互为字符重排
     </a>
    </h3>
    <h4>
     <a id="1_3">
     </a>
     1、题目描述
    </h4>
    <p>
     给定两个由小写字母组成的字符串
     <code>
      s1
     </code>
     和
     <code>
      s2
     </code>
     ，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
    </p>
    <p>
     在这道题中，我们的任务是判断两个字符串
     <code>
      s1
     </code>
     和
     <code>
      s2
     </code>
     是否可以通过重新排列字符使得其中一个字符串变为另一个字符串。这意味着，我们需要检查这两个字符串是否包含完全相同的字符，并且每个字符的数量也必须相同。
    </p>
    <h4>
     <a id="2_11">
     </a>
     2、方法一：排序比较法
    </h4>
    <h5>
     <a id="21_13">
     </a>
     2.1、思路解析
    </h5>
    <p>
     如果两个字符串是彼此的排列，那么对这两个字符串进行排序后，它们应该完全相同。因此，我们可以通过以下步骤来实现：
    </p>
    <ol>
     <li>
      <strong>
       长度判断
      </strong>
      ：首先，检查
      <code>
       s1
      </code>
      和
      <code>
       s2
      </code>
      的长度。如果长度不同，直接返回
      <code>
       false
      </code>
      。
     </li>
     <li>
      <strong>
       排序
      </strong>
      ：对
      <code>
       s1
      </code>
      和
      <code>
       s2
      </code>
      分别进行排序。
     </li>
     <li>
      <strong>
       比较
      </strong>
      ：比较排序后的两个字符串是否相等。如果相等，返回
      <code>
       true
      </code>
      ，否则返回
      <code>
       false
      </code>
      。
     </li>
    </ol>
    <h5>
     <a id="22_21">
     </a>
     2.2、代码实现
    </h5>
    <pre><code>class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        // 如果两个字符串长度不同，必然不能是彼此的排列
        if (s1.size() != s2.size()) {
            return false;
        }

        // 对两个字符串进行排序
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());

        // 比较排序后的字符串是否相等
        return s1 == s2;
    }
};
</code></pre>
    <h4>
     <a id="3_44">
     </a>
     3、方法二：哈希表计数法
    </h4>
    <h5>
     <a id="31_46">
     </a>
     3.1、思路解析
    </h5>
    <p>
     另一种方法是使用哈希表记录每个字符的出现次数。如果两个字符串是彼此的排列，那么每个字符在两个字符串中的出现次数必须相同。因此，我们可以通过以下步骤来实现：
    </p>
    <ol>
     <li>
      <strong>
       长度判断
      </strong>
      ：首先，检查
      <code>
       s1
      </code>
      和
      <code>
       s2
      </code>
      的长度。如果长度不同，直接返回
      <code>
       false
      </code>
      。
     </li>
     <li>
      <strong>
       字符计数
      </strong>
      ：使用一个长度为 26 的数组
      <code>
       hash
      </code>
      来记录
      <code>
       s1
      </code>
      中每个字符的出现次数，并在遍历
      <code>
       s2
      </code>
      的过程中减去相应字符的计数。
     </li>
     <li>
      <strong>
       判断字符计数
      </strong>
      ：如果在遍历
      <code>
       s2
      </code>
      的过程中发现某个字符的计数小于 0，说明
      <code>
       s2
      </code>
      中包含了
      <code>
       s1
      </code>
      没有的字符，返回
      <code>
       false
      </code>
      。
     </li>
     <li>
      <strong>
       返回结果
      </strong>
      ：遍历结束后，如果所有字符的计数都为 0，返回
      <code>
       true
      </code>
      。
     </li>
    </ol>
    <h5>
     <a id="32_55">
     </a>
     3.2、代码实现
    </h5>
    <pre><code>class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        // 如果两个字符串长度不同，必然不能是彼此的排列
        if (s1.size() != s2.size()) {
            return false;
        }

        // 使用哈希表记录每个字符的出现次数
        int hash[26] = {0};

        // 统计 s1 中每个字符的出现次数
        for (const auto&amp; ch : s1) {
            hash[ch - 'a']++;
        }

        // 遍历 s2，减去相应字符的计数
        for (const auto&amp; ch : s2) {
            hash[ch - 'a']--;
            // 如果发现某个字符的计数小于 0，返回 false
            if (hash[ch - 'a'] &lt; 0) {
                return false;
            }
        }

        // 如果遍历结束后没有发现问题，返回 true
        return true;
    }
};
</code></pre>
    <h4>
     <a id="4_91">
     </a>
     4、总结
    </h4>
    <p>
     这两种方法都可以有效地判断两个字符串是否为彼此的排列。方法一使用排序比较，简单直观；方法二使用哈希表计数，时间复杂度更低。具体选择哪种方法，可以根据具体情况和需求来决定。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6d6d6c68626a6b2f:61727469636c652f64657461696c732f313431393037363631" class_="artid" style="display:none">
 </p>
</div>


