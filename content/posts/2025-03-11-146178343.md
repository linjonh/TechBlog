---
layout: post
title: "MySQL的buffer-pool的缓存中,修改语句在执行时,是先更新buffer-pool,还是先更新数据库"
date: 2025-03-11 14:30:37 +0800
description: "直接写磁盘（随机 I/O）速度极慢，而修改内存（Buffer Pool）是纳秒级操作，通过异步刷盘将随机写转换为顺序写（Redo Log），极大提升吞吐量。：Redo Log 是顺序追加写入，即使脏页未刷盘，只要 Redo Log 落盘，事务的持久性（Durability）就能通过 Redo Log 恢复来保证。：解决“部分写失效”（Partial Page Write）问题，确保数据页写入磁盘的原子性。如果数据页不在 Buffer Pool 中，会先从磁盘加载到内存，再进行修改。"
keywords: "MySQL的buffer pool的缓存中，修改语句在执行时，是先更新buffer pool，还是先更新数据库"
categories: ['数据库']
tags: ['缓存', '数据库', 'Mysql']
artid: "146178343"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146178343
    alt: "MySQL的buffer-pool的缓存中,修改语句在执行时,是先更新buffer-pool,还是先更新数据库"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146178343
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146178343
cover: https://bing.ee123.net/img/rand?artid=146178343
image: https://bing.ee123.net/img/rand?artid=146178343
img: https://bing.ee123.net/img/rand?artid=146178343
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL的buffer pool的缓存中，修改语句在执行时，是先更新buffer pool，还是先更新数据库
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     在 MySQL 的 InnoDB 存储引擎中，修改语句（如
     <code>
      UPDATE
     </code>
     、
     <code>
      INSERT
     </code>
     、
     <code>
      DELETE
     </code>
     ）的执行流程遵循
     <strong>
      “先修改内存（Buffer Pool），再异步刷盘”
     </strong>
     的机制。具体流程如下：
    </p>
    <hr/>
    <h4>
     <strong>
      1. 修改操作的核心流程
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        Step 1：修改 Buffer Pool
       </strong>
      </p>
      <ul>
       <li>
        <p>
         当执行修改语句时，InnoDB 首先在内存的
         <strong>
          Buffer Pool
         </strong>
         中找到对应的数据页（Page）。
        </p>
       </li>
       <li>
        <p>
         如果数据页不在 Buffer Pool 中，会先从磁盘加载到内存，再进行修改。
        </p>
       </li>
       <li>
        <p>
         修改后的数据页会被标记为
         <strong>
          “脏页”（Dirty Page）
         </strong>
         ，表示内存与磁盘数据不一致。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Step 2：写入 Redo Log（保证持久性）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         在修改 Buffer Pool 的同时，InnoDB 会生成
         <strong>
          Redo Log
         </strong>
         （重做日志），记录数据的变更操作。
        </p>
       </li>
       <li>
        <p>
         Redo Log 会先写入
         <strong>
          Log Buffer
         </strong>
         （内存中的日志缓冲区），然后根据配置策略（
         <code>
          innodb_flush_log_at_trx_commit
         </code>
         ）刷到磁盘的 Redo Log 文件中。
        </p>
       </li>
       <li>
        <p>
         <strong>
          关键作用
         </strong>
         ：即使系统崩溃，也可以通过 Redo Log 恢复未刷盘的脏页数据。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Step 3：异步刷盘（延迟写磁盘）
       </strong>
      </p>
      <ul>
       <li>
        <p>
         脏页不会立即写入磁盘，而是由后台线程（
         <code>
          InnoDB Master Thread
         </code>
         ）通过
         <strong>
          Checkpoint 机制
         </strong>
         异步刷新到磁盘的数据文件中。
        </p>
       </li>
       <li>
        <p>
         刷盘时机由以下因素触发：
        </p>
        <ul>
         <li>
          <p>
           Buffer Pool 空间不足时（LRU 淘汰机制）。
          </p>
         </li>
         <li>
          <p>
           Redo Log 写满需要循环复用。
          </p>
         </li>
         <li>
          <p>
           系统空闲时主动刷脏页。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      2. 为什么先修改 Buffer Pool，而不是直接写磁盘？
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        性能优化
       </strong>
       ：直接写磁盘（随机 I/O）速度极慢，而修改内存（Buffer Pool）是纳秒级操作，通过异步刷盘将随机写转换为顺序写（Redo Log），极大提升吞吐量。
      </p>
     </li>
     <li>
      <p>
       <strong>
        事务持久性保障
       </strong>
       ：Redo Log 是顺序追加写入，即使脏页未刷盘，只要 Redo Log 落盘，事务的持久性（Durability）就能通过 Redo Log 恢复来保证。
      </p>
     </li>
     <li>
      <p>
       <strong>
        并发控制
       </strong>
       ：所有修改操作在内存中完成，避免频繁的磁盘 I/O 阻塞其他操作。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 关键机制与组件
     </strong>
    </h4>
    <h5>
     <strong>
      (1) Redo Log（重做日志）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：记录事务对数据页的物理修改，用于崩溃恢复。
      </p>
     </li>
     <li>
      <p>
       <strong>
        写入策略
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          innodb_flush_log_at_trx_commit=1
         </code>
         ：每次事务提交时刷盘（默认，严格保证持久性）。
        </p>
       </li>
       <li>
        <p>
         <code>
          innodb_flush_log_at_trx_commit=0/2
         </code>
         ：延迟刷盘（高性能但可能丢数据）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <strong>
      (2) Checkpoint 机制
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        触发条件
       </strong>
       ：定期将脏页刷新到磁盘，并更新 Redo Log 的检查点位置。
      </p>
     </li>
     <li>
      <p>
       <strong>
        目的
       </strong>
       ：缩短崩溃恢复时需要重放的 Redo Log 范围。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      (3) Double Write Buffer（双写缓冲区）
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：解决“部分写失效”（Partial Page Write）问题，确保数据页写入磁盘的原子性。
      </p>
     </li>
     <li>
      <p>
       <strong>
        流程
       </strong>
       ：脏页刷盘前，先写入 Double Write Buffer，再写入实际数据文件。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      4. 流程图解
     </strong>
    </h4>
    <pre><code class="language-bash">修改操作执行
    │
    ▼
1. 修改 Buffer Pool 中的数据页（标记为脏页）
    │
    ▼
2. 生成 Redo Log 并写入 Log Buffer
    │
    ▼
3. 事务提交时，根据策略将 Redo Log 刷盘
    │
    ▼
4. 后台线程异步将脏页刷到磁盘（Checkpoint 触发）
    │
    ▼
5. 刷盘完成后，脏页标记为干净页</code></pre>
    <hr/>
    <h4>
     <strong>
      5. 总结
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        核心逻辑
       </strong>
       ：
       <strong>
        先修改 Buffer Pool（内存），再异步刷盘（磁盘）
       </strong>
       。
      </p>
     </li>
     <li>
      <p>
       <strong>
        关键保障
       </strong>
       ：通过 Redo Log 保证事务持久性，通过异步刷盘提升性能。
      </p>
     </li>
     <li>
      <p>
       <strong>
        设计哲学
       </strong>
       ：用内存加速写操作，用日志保证可靠性，用异步机制平衡性能与安全。
      </p>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34323235313934342f:61727469636c652f64657461696c732f313436313738333433" class_="artid" style="display:none">
 </p>
</div>


