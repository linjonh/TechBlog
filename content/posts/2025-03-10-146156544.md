---
layout: post
title: "数据结构并查集-C版本的实现代码"
date: 2025-03-10 17:09:08 +0800
description: "并查集就可以很好的解决该问题，并查集是一个森林，他内部的每一棵多叉树，都是一个按照特定条件划分出来的相同属性的集合。并查集是使用数组的形式去表示森林的结构，森林中的每一颗树的每一个节点，采用的是双亲指针法，也就是说每一个节点，只能找到他的父节点，没法向下找子节点。每个存储的元素会被映射为一个下标序号，数组的值，存放的是他的父节点的下标。例如a[i] = n；那么就代表序号为i的元素的父节点是序号为n的元素。"
keywords: "[数据结构]并查集--C++版本的实现代码"
categories: ['未分类']
tags: ['算法', '笔记', '数据结构', '并查集', 'C']
artid: "146156544"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146156544
    alt: "数据结构并查集-C版本的实现代码"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146156544
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146156544
cover: https://bing.ee123.net/img/rand?artid=146156544
image: https://bing.ee123.net/img/rand?artid=146156544
img: https://bing.ee123.net/img/rand?artid=146156544
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     [数据结构]并查集--C++版本的实现代码
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     大学班级的同学会来自于五湖四海，每个人的家乡可能都不相同，那么如何将相同省份的同学连接到一块，也就是按省份进行分组呢？并查集就可以很好的解决该问题，并查集是一个森林，他内部的每一棵多叉树，都是一个按照特定条件划分出来的相同属性的集合。
    </p>
    <h4 id="%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6" name="%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6">
     并查集的基本框架
    </h4>
    <p>
     并查集是使用数组的形式去表示森林的结构，森林中的每一颗树的每一个节点，采用的是双亲指针法，也就是说每一个节点，只能找到他的父节点，没法向下找子节点。每个存储的元素会被映射为一个下标序号，数组的值，存放的是他的父节点的下标。例如a[i] = n；那么就代表序号为i的元素的父节点是序号为n的元素。
    </p>
    <p>
     所以说除了维护一个并查集数组之外，还要维护一个哈希map来进行字符串转下标的结构，和一个数组用来进行下标转字符串的操作。如果说数据本身就是数字的话，那就没必要了。
    </p>
    <p>
     初始化的时候，设置为-1，是因为首先让每一个元素都是一个特定的集合，然后根据情况，调用方法逐步的进行元素的合并操作，来完成并查集的构建操作。
    </p>
    <pre><code class="language-cpp">class UnionFind
{
private:
	std::vector&lt;int&gt; _uf;									//并查集数组
	std::unordered_map&lt;std::string, int&gt; _stringToMap;		//string类型转下标
	std::vector&lt;std::string&gt; _mapToString;					//下标转string类型

public:
	//初始化
	UnionFind(int n, std::vector&lt;std::string&gt;&amp; strs)
		: _uf(n, -1)
		, _mapToString(n)
	{
		for (int i = 0; i &lt; n; i++)
		{
			_stringToMap[strs[i]] = i;
			_mapToString[i] = strs[i];
		}
	}
};</code></pre>
    <h4 id="%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9C%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88" name="%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%9C%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88">
     <strong>
      查找一个元素在哪一个集合
     </strong>
    </h4>
    <p>
     采用循环的方式，一直追溯到根节点的为止，每一个数组元素都记录着父节点的下标为止，如果说该数组元素是一个负数的话，那么就代表这个数组元素是根节点。
    </p>
    <pre><code class="language-cpp">//查看元素在哪个集合中
int Find(int val)
{
	//如果查找的下标，超出了数组范围
	if (val &gt;= _uf.size())
	{
		return -1;
	}

	//一直查找到根节点
	while (_uf[val] &gt;= 0)
	{
		int parent = _uf[val];
		val = parent;
	}
	return val;
}
//按string类型进行查找 
const std::string&amp; Find(const std::string&amp; val)
{
	//查找映射关系
	auto it = _stringToMap.find(val);
	//没找到--返回空字符串
	if (it == _stringToMap.end())
	{
		return std::string("");
	}
	int index = Find((*it).second);
	return _mapToString[index];
}</code></pre>
    <h4 id="%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88" name="%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88">
     <strong>
      判断两个元素是否在同一个集合
     </strong>
    </h4>
    <p>
     <strong>
     </strong>
     判断两个元素是否在同一个集合，也就是判断两个元素的跟节点是不是一样的即可，所以复用Find函数代码。
    </p>
    <pre><code class="language-cpp">    //判断两个元素是否在同一个集合
	bool IsSame(int val1, int val2)
	{
		return Find(val1) == Find(val2);
	}
	//按string类型的判断
	bool IsSame(const std::string&amp; str1, const std::string&amp; str2)
	{
		return Find(str1) == Find(str2);
	}</code></pre>
    <h4 id="%E5%B0%86%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6" name="%E5%B0%86%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6">
     <strong>
      将两个集合进行合并
     </strong>
    </h4>
    <pre><code class="language-cpp">	//将两个集合进行合并
	void UnionSet(int val1, int val2)
	{
		//先查找两个元素的根节点
		int root1 = Find(val1);
		int root2 = Find(val2);

		//如果一样，就不用合并了
		if (root1 == root2)
			return;

		//将小的集合合并到大的集合当中
		if (std::abs(_uf[root1]) &lt; std::abs(_uf[root2]))
		{
			std::swap(root1, root2);
		}
		//更新数组值与下标
		_uf[root1] += _uf[root2];
		_uf[root2] = root1;
	}</code></pre>
    <h4 id="%E6%9F%A5%E8%AF%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E7%BB%84" name="%E6%9F%A5%E8%AF%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E7%BB%84">
     查询有多少组
    </h4>
    <pre><code class="language-cpp">	//查询有多少组
	int CountSet()
	{
		int count = 0;
		for (auto num : _uf)
		{
			if (num &lt; 0)
				count++;
		}
		return count;
	}</code></pre>
    <h4 id="%E6%B5%8B%E8%AF%95" name="%E6%B5%8B%E8%AF%95">
     测试
    </h4>
    <pre><code class="language-cpp">#include "UnionFind.hpp"

int main()
{
	std::vector&lt;std::string&gt; classmates = {
		"林晓", "陈悦", "刘阳", "张宇", "王婷",
		"李辉", "赵静", "孙峰", "周瑶", "吴俊"
	};
	//创建并查集
	UnionFind unionfind(10, classmates);

	//进行分组操作
	unionfind.UnionSet(0, 1);
	unionfind.UnionSet(0, 3);

	unionfind.UnionSet(2, 4);
	unionfind.UnionSet(2, 5);
	unionfind.UnionSet(2, 6);

	unionfind.UnionSet(7, 8);
	unionfind.UnionSet(7, 9);

	std::cout &lt;&lt; "有多少组：" &lt;&lt; unionfind.CountSet() &lt;&lt; std::endl;

	//查找陈悦在哪一组
	std::cout &lt;&lt; "陈悦的组长：" &lt;&lt; unionfind.Find("陈悦") &lt;&lt; std::endl;
	//查找是否在一组
	std::cout &lt;&lt; "陈悦和张宇：" &lt;&lt; unionfind.IsSame("陈悦", "张宇") &lt;&lt; std::endl;
	std::cout &lt;&lt; "陈悦和刘阳：" &lt;&lt; unionfind.IsSame("陈悦", "刘阳") &lt;&lt; std::endl;

	//合并
	unionfind.UnionSet(0, 2);
	std::cout &lt;&lt; "有多少组：" &lt;&lt; unionfind.CountSet() &lt;&lt; std::endl;

	//查找陈悦在哪一组
	std::cout &lt;&lt; "陈悦的组长：" &lt;&lt; unionfind.Find("陈悦") &lt;&lt; std::endl;
	//查找是否在一组
	std::cout &lt;&lt; "陈悦和张宇：" &lt;&lt; unionfind.IsSame("陈悦", "张宇") &lt;&lt; std::endl;
	std::cout &lt;&lt; "陈悦和刘阳：" &lt;&lt; unionfind.IsSame("陈悦", "刘阳") &lt;&lt; std::endl;


	return 0;
}</code></pre>
    <p>
     <img alt="" height="322" src="https://i-blog.csdnimg.cn/direct/87c5f5c553804ca0a2cfc305b71a529b.png" width="1439"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343230373936392f:61727469636c652f64657461696c732f313436313536353434" class_="artid" style="display:none">
 </p>
</div>


