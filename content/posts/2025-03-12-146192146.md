---
layout: post
title: "操作系统高频面试题"
date: 2025-03-12 16:58:36 +0800
description: "⭐️在反复复习面试题时，我发现不同资料的解释五花八门，容易造成概念混淆。尤其是很多总结性的文章和视频，要么冗长难记，要么过于简略，导致关键知识点含糊不清。⭐️为了系统梳理知识，我决定撰写一份面试指南，不只是简单汇总，而是融入个人理解，层层拆解复杂概念，构建完"
keywords: "操作系统高频面试题"
categories: ['Your', 'Java', 'Evaluation', 'Dominate']
tags: ['面试', '锁', '操作系统']
artid: "146192146"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146192146
    alt: "操作系统高频面试题"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146192146
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146192146
cover: https://bing.ee123.net/img/rand?artid=146192146
image: https://bing.ee123.net/img/rand?artid=146192146
img: https://bing.ee123.net/img/rand?artid=146192146
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     操作系统高频面试题
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     写在前面
    </h2>
    <p>
     🔥我把后端Java面试题做了一个汇总，有兴趣大家可以看看！
     <a href="https://blog.csdn.net/weixin_74199893/category_12788633.html?spm=1001.2014.3001.5482">
      这里👉
     </a>
    </p>
    <p>
     ⭐️在反复复习面试题时，我发现不同资料的解释五花八门，容易造成概念混淆。尤其是很多总结性的文章和视频，要么冗长难记，要么过于简略，导致关键知识点含糊不清。
    </p>
    <p>
     ⭐️为了系统梳理知识，我决定撰写一份面试指南，不只是简单汇总，而是融入个人理解，层层拆解复杂概念，构建完整的知识体系。我希望它不仅帮助自己更自信地应对面试，也能为同行提供清晰、实用的参考。
    </p>
    <hr/>
    <h2>
     <a id="_10">
     </a>
     操作系统相关面试题
    </h2>
    <h4>
     <a id="__12">
     </a>
     <strong>
      面试官：
     </strong>
     进程和线程的区别
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     线程和进程的区别主要体现在以下四个方面：
    </p>
    <p>
     1️⃣
     <strong>
      资源分配：
     </strong>
     进程是操作系统分配资源的基本单位，拥有独立的内存空间；线程共享进程资源，多个线程可访问相同的数据。
    </p>
    <blockquote>
     <p>
      <strong>
       你说到进程是分配资源的基本单位，那么这个资源指的是什么？
      </strong>
      虚拟内存、文件句柄、信号量等资源。
     </p>
    </blockquote>
    <p>
     2️⃣
     <strong>
      创建与切换开销：
     </strong>
     进程创建和切换成本较高，需要完整的资源分配和回收；线程切换更轻量，仅需保存和恢复私有数据。
    </p>
    <p>
     3️⃣
     <strong>
      通信与同步：
     </strong>
     进程间通信（IPC）依赖管道、消息队列等机制，效率较低；线程共享进程数据，通信更快，但需加锁避免竞争。
    </p>
    <p>
     4️⃣
     <strong>
      容错与并发：
     </strong>
     进程崩溃通常不影响其他进程，适用于高可靠性场景；线程共享进程资源，故单个线程异常可能导致整个进程崩溃。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6dd449114ab144b8a08d24bd0bc21eac.png"/>
    </p>
    <hr/>
    <h4>
     <a id="__30">
     </a>
     <strong>
      面试官：
     </strong>
     线程比进程高效的原因？
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     线程相较于进程的优势主要体现在
     <strong>
      资源共享、创建成本、切换开销和并发效率
     </strong>
     四个方面。
    </p>
    <ul>
     <li>
      <strong>
       资源共享
      </strong>
      ：进程间通信（IPC）成本较高，而线程共享进程资源，数据访问更快，通信更高效。
     </li>
     <li>
      <strong>
       创建成本
      </strong>
      ：进程创建需分配独立内存，开销大；线程仅需分配栈，创建速度更快。
     </li>
     <li>
      <strong>
       切换开销
      </strong>
      ：进程切换涉及完整上下文切换，线程切换仅涉及寄存器和栈指针，开销更小。
     </li>
     <li>
      <strong>
       并发执行
      </strong>
      ：线程能充分利用多核 CPU 并行执行，提高程序吞吐量，而进程的资源隔离限制了并发效率。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__42">
     </a>
     <strong>
      面试官：
     </strong>
     进程，线程，协程的区别是什么？
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <p>
     •首先,我们来谈谈
     <strong>
      进程
     </strong>
     。进程是操作系统分配资源的基本单位，它拥有自己的
     <strong>
      独立内存空间
     </strong>
     和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。进程间通信需要通过特定的机制，
     <strong>
      如管道、消息队列、信号量等
     </strong>
     。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高,但同时上下文切换的开销也较大,因为需要保存和恢复整个进程的状态。
    </p>
    <p>
     •接下来是
     <strong>
      线程
     </strong>
     。线程是进程内的一个执行单元,也是CPU调度的基本单位。与进程不同，线程共享进程的内存空间，包括堆和方法区。线程之间通信更加高效，因为它们可以直接读写
     <strong>
      共享内存
     </strong>
     。线程的上下文切换开销较小,因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在线程安全的问题，需要通过同步和互斥机制来解决。
    </p>
    <p>
     •最后是
     <strong>
      协程
     </strong>
     。协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。
     <strong>
      协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。
      <strong>
       协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理
      </strong>
      大量并发任务时
     </strong>
     具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说,其编程模型更为复杂。
    </p>
    <hr/>
    <h4>
     <a id="__54">
     </a>
     <strong>
      面试官：
     </strong>
     用户态和内核态是如何切换的？
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <p>
     在操作系统中，
     <strong>
      用户态
     </strong>
     用于运行普通应用程序，受限访问系统资源，而
     <strong>
      内核态
     </strong>
     具备最高权限，能够直接控制硬件。两者的切换主要通过以下三种方式：
    </p>
    <ul>
     <li>
      <strong>
       系统调用
      </strong>
      ：应用程序请求受限资源（如文件、网络）时，会触发系统调用，使 CPU 进入内核态，执行相应内核函数，完成后返回用户态。
     </li>
     <li>
      <strong>
       异常处理
      </strong>
      ：程序在用户态发生错误（如除零、非法内存访问）时，CPU 进入内核态执行异常处理程序，决定是否恢复或终止进程。
     </li>
     <li>
      <strong>
       硬件中断
      </strong>
      ：当外设完成任务（如磁盘 I/O、网络数据接收）时，触发中断，CPU 切换至内核态处理中断，随后恢复用户态继续执行程序。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__66">
     </a>
     <strong>
      面试官：
     </strong>
     什么是孤儿进程？什么是僵尸进程？
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <code>
        孤儿进程
       </code>
       是指父进程在子进程结束之前就已经退出，导致子进程失去了父进程的管理和控制，成为了 “孤儿”。此时，这些子进程会被系统的 init 进程（在 Linux 系统中，进程 ID 为 1）所收养，init 进程会负责回收它们的资源等工作。
      </p>
     </li>
     <li>
      <p>
       <code>
        僵尸进程
       </code>
       是指一个进程已经执行完了它的主要任务，进入了终止状态，但由于某些原因，它的父进程没有调用相应的系统函数（如 wait () 或 waitpid ()）来收集它的退出状态信息，导致该进程虽然已经停止运行，但在系统进程表中仍然保留着一个记录，占据着一定的系统资源。
      </p>
      <blockquote>
       <p>
        Linux 下可以使用 Top 命令查找，
        <code>
         zombie
        </code>
        值表示僵尸进程的数量，为 0 则代表没有僵尸进程。
       </p>
       <p>
        <img alt="僵尸进程查看" src="https://i-blog.csdnimg.cn/img_convert/8c00dfd5598a370113482710ca0cf853.jpeg"/>
       </p>
       <p>
        下面这个命令可以定位僵尸进程以及该僵尸进程的父进程：
       </p>
       <pre><code class="prism language-sh"><span class="token function">ps</span> <span class="token parameter variable">-A</span> -ostat,ppid,pid,cmd <span class="token operator">|</span><span class="token function">grep</span> <span class="token parameter variable">-e</span> <span class="token string">'^[Zz]'</span>
</code></pre>
      </blockquote>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__50__86">
     </a>
     <strong>
      面试官：
     </strong>
     假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，最终结果可能是 100，也可能小于 100，最坏的结果是 50，也就是最终的结果可能是在 [50, 100] 。
    </p>
    <p>
     小于 100 情况的分析，由于对整型变量的
     <code>
      num++
     </code>
     操作不是原子操作，它实际上包含了三个步骤：读取变量的值、将值加 1、将新值写回变量。在多线程环境下，可能会出现线程安全问题。例如，线程 1 和线程 2 同时读取了变量的当前值，然后各自将其加 1，最后都将相同的新值写回变量，这就导致了一次加 1 操作的丢失。这种情况会多次发生，最终结果就会小于 100。
    </p>
    <blockquote>
     <p>
      <strong>
       追问：
      </strong>
      如何保证2 个线程累加之后达到 100？
     </p>
     <p>
      第一种方式：原子变量的方法。使用
      <code>
       AtomicInteger
      </code>
      替代普通
      <code>
       int
      </code>
      ，其
      <code>
       incrementAndGet()
      </code>
      方法保证原子性，代码如下：
     </p>
     <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerAddition</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                num<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                num<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果: "</span> <span class="token operator">+</span> num<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
     <p>
      第二种方式：通过
      <code>
       synchronized
      </code>
      关键字或
      <code>
       ReentrantLock
      </code>
      确保操作的互斥性，代码如下：
     </p>
     <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedAddition</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    num<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    num<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终结果: "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    </blockquote>
    <hr/>
    <h4>
     <a id="__162">
     </a>
     <strong>
      面试官：
     </strong>
     操作系统中进程的调度算法有哪些?
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <ul>
     <li>
      <p>
       <strong>
        先到先服务(FCFS)调度算法
       </strong>
       : 按照进程到达的先后顺序进行调度，即最早到达的进程先执行，直到完成或阻塞
       <br/>
       <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/7054ce924985e20ba3983ad49db28e52.png"/>
      </p>
     </li>
     <li>
      <p>
       <strong>
        短作业优先(SJF)调度算法
       </strong>
       : 优先选择运行时间最短的进程来运行
       <br/>
       <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/fa5371327905b632c2964e86bf59cd5f.png"/>
      </p>
     </li>
     <li>
      <p>
       <strong>
        时间⽚轮转调度算法
       </strong>
       : 将
       <code>
        CPU
       </code>
       时间划分为时间片(时间量)，每个进程在一个时间片内运行，然后切换到下一个进程。
       <br/>
       <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/c4530d318cb16641565b695aea74964b.png"/>
      </p>
     </li>
     <li>
      <p>
       <strong>
        多级反馈队列调度算法
       </strong>
       ：将进程划分为多个队列，每个队列具有不同的优先级，进程在队列之间移动。具有更高优先级的队列的进程会更早执行，而长时间等待的进程会被提升到更高优先级队列。
       <br/>
       <img alt="img" src="https://i-blog.csdnimg.cn/img_convert/6670b945873bef28f2bc6aa460e83b53.png"/>
      </p>
     </li>
     <li>
      <p>
       <strong>
        最高优先级调度
       </strong>
       ： 为每个进程分配一个优先级，优先级较高的进程先执行。这可能导致低优先级进程长时间等待
       <strong>
        可能引发饥饿
       </strong>
       问题。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__182">
     </a>
     <strong>
      面试官：
     </strong>
     进程间的通信方式
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     ⼤概有 7 种常⻅的进程间的通信⽅式。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        管道/匿名管道(Pipes)
       </strong>
       ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。
      </p>
     </li>
     <li>
      <p>
       <strong>
        有名管道 (Names Pipes)
       </strong>
       : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)，可以实现本机任意两个进程通信。
      </p>
     </li>
     <li>
      <p>
       <strong>
        信号(Signal)
       </strong>
       ：信号是⼀种⽐复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；
      </p>
     </li>
     <li>
      <p>
       <strong>
        消息队列(Message Queuing)
       </strong>
       ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是
       <strong>
        消息队列存放在内核
       </strong>
       中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取，⽐ FIFO 更有优势。
      </p>
     </li>
     <li>
      <p>
       <strong>
        信号量(Semaphores)
       </strong>
       ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        共享内存(Shared memory)
       </strong>
       ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。
      </p>
     </li>
     <li>
      <p>
       <strong>
        套接字(Sockets)
       </strong>
       : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持 TCP/IP 的⽹络通信的基本操作单元，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="__200">
     </a>
     <strong>
      面试官：
     </strong>
     线程间的同步的⽅式有哪些呢？
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <p>
     线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。
    </p>
    <p>
     下面是几种常见的线程同步的方式：
    </p>
    <ol>
     <li>
      <strong>
       互斥锁(Mutex)
      </strong>
      ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的
      <code>
       synchronized
      </code>
      关键词和各种
      <code>
       Lock
      </code>
      都是这种机制。
     </li>
     <li>
      <strong>
       读写锁（Read-Write Lock）
      </strong>
      ：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。
     </li>
     <li>
      <strong>
       信号量(Semaphore)
      </strong>
      ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
     </li>
     <li>
      <strong>
       屏障（Barrier）
      </strong>
      ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的
      <code>
       CyclicBarrier
      </code>
      是这种机制。
     </li>
     <li>
      <strong>
       事件(Event)
      </strong>
      :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="__216">
     </a>
     <strong>
      面试官：
     </strong>
     操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式？
    </h4>
    <p>
     <strong>
      候选人：
      <strong>
       简单分为
      </strong>
      连续分配管理⽅式
     </strong>
     和
     <strong>
      ⾮连续分配管理⽅式
     </strong>
     这两种。连续分配管理⽅式是指为⼀个⽤户程序分配⼀个连续的内存空间，常⻅的如
     <strong>
      块式管理
     </strong>
     。同样地，⾮连续分配管理⽅式允许⼀个程序使⽤的内存分布在离散或者说不相邻的内存中，常⻅的如
     <strong>
      ⻚式管理
     </strong>
     和
     <strong>
      段式管理
     </strong>
     。
    </p>
    <ol>
     <li>
      <p>
       <strong>
        块式管理
       </strong>
       ： 远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了，产生一定的内存碎片。
      </p>
     </li>
     <li>
      <p>
       <strong>
        ⻚式管理
       </strong>
       ：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过
       <code>
        ⻚表
       </code>
       对应逻辑地址和物理地址。
      </p>
     </li>
     <li>
      <p>
       <strong>
        段式管理
       </strong>
       ： ⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意义。 段式管理把主存分为⼀段段的 。但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段X、数据段 D 及栈段 S 等。 段式管理通过
       <code>
        段表
       </code>
       对应逻辑地址和物理地址。
      </p>
     </li>
     <li>
      <p>
       <strong>
        段⻚式管理机制
       </strong>
       。结合了上述两者的优点，
       <strong>
        先将内存划分为若干个段
       </strong>
       ，每个段又被进一步划分为若干个页。段式管理解决了程序逻辑上不同部分的
       <strong>
        内存分配
       </strong>
       问题，而页式管理解决了物理内存的
       <strong>
        连续性
       </strong>
       问题。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="__230">
     </a>
     <strong>
      面试官：
     </strong>
     快表和多级⻚表
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <p>
     <strong>
      1）快表
     </strong>
    </p>
    <p>
     为了解决
     <code>
      虚拟地址到物理地址的转换速度
     </code>
     ，操作系统在
     <strong>
      ⻚表⽅案
     </strong>
     基础之上引⼊了
     <strong>
      快表
     </strong>
     来加速虚拟地址到物理地址的转换。我们可以把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。
    </p>
    <blockquote>
     <p>
      使⽤快表之后的地址转换流程是这样的：
     </p>
     <ol>
      <li>
       <p>
        根据虚拟地址中的⻚号查快表
       </p>
      </li>
      <li>
       <p>
        如果该⻚在快表中，直接从快表中读取相应的物理地址；
       </p>
      </li>
      <li>
       <p>
        如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；
       </p>
      </li>
      <li>
       <p>
        当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。
       </p>
      </li>
     </ol>
    </blockquote>
    <p>
     <strong>
      2）多级⻚表
     </strong>
    </p>
    <p>
     引⼊多级⻚表的主要⽬的是
     <code>
      为了避免把全部⻚表⼀直放在内存中占⽤过多空间
     </code>
     ，特别是那些根本就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景。
    </p>
    <hr/>
    <h4>
     <a id="__253">
     </a>
     <strong>
      面试官：
     </strong>
     分⻚机制和分段机制有哪些共同点和区别呢？
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <ol>
     <li>
      <strong>
       共同点
      </strong>
      ：
     </li>
    </ol>
    <ul>
     <li>
      <p>
       分⻚机制和分段机制都是为了提⾼内存利⽤率，少内存碎⽚。
      </p>
     </li>
     <li>
      <p>
       ⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内存是连续的。
      </p>
     </li>
    </ul>
    <ol start="2">
     <li>
      <strong>
       区别
      </strong>
      ：
     </li>
    </ol>
    <ul>
     <li>
      <p>
       ⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。
      </p>
     </li>
     <li>
      <p>
       分页对用户不可见，分段对用户可见
      </p>
     </li>
     <li>
      <p>
       分页的地址空间是一维的，分段的地址空间是二维的
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__273">
     </a>
     <strong>
      面试官：
     </strong>
     逻辑(虚拟)地址和物理地址
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥⾯存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。
    </p>
    <blockquote>
     <p>
      <strong>
       为什么要有虚拟地址空间呢？
      </strong>
     </p>
     <p>
      没有虚拟地址空间的时候，
      <strong>
       程序都是直接访问和操作的都是物理内存
      </strong>
      。但是这样有什么问题呢？
     </p>
     <ol>
      <li>
       <p>
        ⽤户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者⽆意）破坏操作系统，造成操作系统崩溃。
       </p>
      </li>
      <li>
       <p>
        想要同时运⾏多个程序特别困难，⽐如你想同时运⾏⼀个微信和⼀个 QQ ⾳乐都不⾏。为什么呢？举个简单的例⼦：微信在运⾏的时候给内存地址 1xxx 赋值后，QQ ⾳乐也同样给内存地址 1xxx 赋值，那么 QQ ⾳乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃
       </p>
      </li>
     </ol>
     <p>
      <strong>
       总结来说：如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="_Virtual_Memory_290">
     </a>
     <strong>
      面试官：
     </strong>
     什么是虚拟内存(Virtual Memory)?
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     虚拟内存(Virtual Memory) 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。
    </p>
    <p>
     总结来说，虚拟内存主要提供了下面这些能力：
    </p>
    <ul>
     <li>
      <strong>
       进程隔离
      </strong>
      ：每个进程拥有独立的虚拟地址空间，避免进程间干扰，提高系统稳定性。
     </li>
     <li>
      <strong>
       提升内存利用率
      </strong>
      ：仅加载当前需要的部分数据或代码，减少物理内存占用。
     </li>
     <li>
      <strong>
       简化内存管理
      </strong>
      ：程序员无需直接操作物理内存，而是通过虚拟地址空间访问，提高开发效率。
     </li>
     <li>
      <strong>
       共享物理内存
      </strong>
      ：多个进程可共享公共库，避免重复加载，节省内存资源。
     </li>
     <li>
      <strong>
       增强安全性
      </strong>
      ：控制进程对物理内存的访问权限，防止非法访问。
     </li>
     <li>
      <strong>
       扩展可用内存
      </strong>
      ：利用磁盘作为扩展，提供比物理内存更大的可用空间（但可能降低访问速度）。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__308">
     </a>
     <strong>
      面试官：
     </strong>
     说⼀下⻚⾯置换算法的作⽤?常⻅的⻚⾯置换算法有哪些?
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     地址映射过程中，若在⻚⾯中发现所要访问的⻚⾯不在内存中，则发⽣缺⻚中断 。
    </p>
    <blockquote>
     <p>
      <strong>
       缺⻚中断
      </strong>
      就是要访问的
      <strong>
       ⻚
      </strong>
      不在主存，需要操作系统将其调⼊主存后再进⾏访问。 在这个时候，被内存映射的⽂件实际上成了⼀个分⻚交换⽂件。
     </p>
    </blockquote>
    <p>
     当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。⽤来选择淘汰哪⼀⻚的规则叫做⻚⾯置换算法，我们可以把⻚⾯置换算法看成是淘汰⻚⾯的规则。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        OPT
       </strong>
       <strong>
        ⻚⾯置换算法（最佳⻚⾯置换算法）
       </strong>
       ：最佳(OPT)置换算法所选择的被淘汰⻚⾯将是以后永不使⽤的，或者是在最⻓时间内不再被访问的⻚⾯,这样可以保证获得最低的缺⻚率。但由于⼈们⽬前⽆法预知进程在内存下的若千⻚⾯中哪个是未来最⻓时间内不再被访问的，因⽽该算法⽆法实现。⼀般作为衡量其他置换算法的⽅法。
      </p>
     </li>
     <li>
      <p>
       <strong>
        FIFO（First In First Out）⻚⾯置换算法（先进先出⻚⾯置换算法）
       </strong>
       : 总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰。
      </p>
     </li>
     <li>
      <p>
       <strong>
        LRU（Least Currently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法）
       </strong>
       ：LRU算法赋予每个⻚⾯⼀个访问字段，⽤来记录⼀个⻚⾯⾃上次被访问以来所经历的时间 T，当须淘汰⼀个⻚⾯时，选择现有⻚⾯中其 T 值最⼤的，即最近最久未使⽤的⻚⾯予以淘汰。
      </p>
     </li>
     <li>
      <p>
       <strong>
        LFU（Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法）
       </strong>
       : 该置换算法选择在之前时期使⽤最少的⻚⾯作为淘汰⻚。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__328">
     </a>
     <strong>
      面试官：
     </strong>
     解释一下进程同步和互斥，以及解决这些问题的办法
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <p>
     <code>
      进程同步
     </code>
     是指多个并发执行的进程之间协调和管理它们的执行顺序，以确保它们
     <strong>
      按照一定的顺序或时间间隔执行
     </strong>
     。
    </p>
    <p>
     <code>
      进程互斥
     </code>
     指的是在
     <strong>
      某一时刻只允许一个进程访问某个共享资源
     </strong>
     。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。
    </p>
    <p>
     解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是使用
     <strong>
      信号量
     </strong>
     和
     <strong>
      PV 操作
     </strong>
     。信号量是一种特殊的变量，它表示系统中某种资源的数量或者状态。PV 操作是一种对信号量进行增加或者减少的操作，它们可以用来控制进程之间的同步或者互斥。
    </p>
    <p>
     除此之外，下面的方法也可以解决进程同步和互斥问题:
    </p>
    <ul>
     <li>
      <strong>
       临界区(Critical Section)
      </strong>
      : 将可能引发互斥问题的代码段称为临界区。为了实现互斥，每个进程在进入临界区前必须获取一个锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。
     </li>
     <li>
      <strong>
       互斥锁(Mutex)
      </strong>
      : 互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__345">
     </a>
     <strong>
      面试官：
     </strong>
     介绍一下几种典型的锁
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
    </p>
    <p>
     两个基础的锁：
    </p>
    <ul>
     <li>
      <strong>
       互斥锁
      </strong>
      :互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。
     </li>
     <li>
      <strong>
       自旋锁
      </strong>
      :自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。
     </li>
    </ul>
    <p>
     其他的锁都是基于这两个锁的：
    </p>
    <ul>
     <li>
      <strong>
       读写锁
      </strong>
      :允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读(共享)和写(排他)两种状态。
     </li>
     <li>
      <strong>
       悲观锁
      </strong>
      :认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁
     </li>
     <li>
      <strong>
       乐观锁
      </strong>
      :先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。.
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_362">
     </a>
     <strong>
      面试官
     </strong>
     ：死锁产生的条件是什么？
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人
     </strong>
     ：一个线程需要同时获取多把锁，这时就容易发生死锁。
    </p>
    <p>
     死锁必须具备以下四个条件：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        互斥条件：
       </strong>
       该资源任意⼀个时刻只由⼀个线程占⽤。
      </p>
     </li>
     <li>
      <p>
       <strong>
        请求与保持条件：
       </strong>
       ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。
      </p>
     </li>
     <li>
      <p>
       <strong>
        不剥夺条件:
       </strong>
       线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        循环等待条件:
       </strong>
       若⼲进程之间形成⼀种头尾相接的循环等待资源关系。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_376">
     </a>
     <strong>
      面试官
     </strong>
     ：如何避免线程死锁?
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人：
     </strong>
     我上⾯说了产⽣死锁的四个必要条件，为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。现在我们来挨个分析⼀下：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        破坏互斥条件
       </strong>
       ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        破坏请求与保持条件
       </strong>
       ：⼀次性申请所有的资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        破坏不剥夺条件
       </strong>
       ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        破坏循环等待条件
       </strong>
       ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。
      </p>
     </li>
    </ol>
    <blockquote>
     <p>
      <strong>
       那什么是资源有序分配法呢?
      </strong>
      线程A和线程 B获取资源的顺序要一样，当线程A是先尝试获取资源 A, 然后尝试获取资源 B 的时候，线程B同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A和线程B总是以相同的顺序申请自己想要的资源。
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="_392">
     </a>
     <strong>
      面试官
     </strong>
     ：如何进行死锁诊断？
     <code>
      （高频）
     </code>
    </h4>
    <p>
     <strong>
      候选人
     </strong>
     ：这个也很容易，我们只需要通过jdk自动的工具就能搞定。
    </p>
    <p>
     我们可以先通过
     <code>
      jps
     </code>
     来查看当前java程序运行的进程id，然后通过
     <code>
      jstack
     </code>
     来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。
    </p>
    <blockquote>
     <p>
      <strong>
       拓展：
      </strong>
     </p>
     <p>
      <code>
       jps
      </code>
      ：输出JVM中运行的进程状态信息。
     </p>
     <p>
      <code>
       jstack
      </code>
      ：查看java进程内线程的堆栈信息。
     </p>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37343139393839332f:61727469636c652f64657461696c732f313436313932313436" class_="artid" style="display:none">
 </p>
</div>


