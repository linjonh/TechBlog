---
layout: post
title: "CC-æ¯æ—¥ä¸€ç»ƒ-6"
date: 2025-03-16 19:38:56 +0800
description: "ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Ÿæ™ºèƒ½æŒ‡é’ˆå’Œæ™®é€šæŒ‡é’ˆçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›å¸¸ç”¨çš„æ™ºèƒ½æŒ‡é’ˆï¼Ÿè¯´ä¸€ä¸‹åº•å±‚å¦‚ä½•å®ç°çš„ï¼Ÿ"
keywords: "C/C++ | æ¯æ—¥ä¸€ç»ƒ (6)"
categories: ['æ¯æ—¥ä¸€ç»ƒ', 'C']
tags: ['é¢è¯•', 'C', 'C']
artid: "146300031"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146300031
    alt: "CC-æ¯æ—¥ä¸€ç»ƒ-6"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146300031
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146300031
cover: https://bing.ee123.net/img/rand?artid=146300031
image: https://bing.ee123.net/img/rand?artid=146300031
img: https://bing.ee123.net/img/rand?artid=146300031
---

# C/C++ | æ¯æ—¥ä¸€ç»ƒ (6)

> ğŸ’¢æ¬¢è¿æ¥åˆ°å¼ èƒ¤å°˜çš„æŠ€æœ¯ç«™  
>  ğŸ’¥æŠ€æœ¯å¦‚æ±Ÿæ²³ï¼Œæ±‡èšä¼—å¿—æˆã€‚ä»£ç ä¼¼æ˜Ÿè¾°ï¼Œç…§äº®è¡Œå¾ç¨‹ã€‚å¼€æºç²¾ç¥é•¿ï¼Œä¼ æ‰¿æ°¸ä¸å¿˜ã€‚æºæ‰‹å…±å‰è¡Œï¼Œæœªæ¥æ›´è¾‰ç…ŒğŸ’¥

## C/C++ | æ¯æ—¥ä¸€ç»ƒ (6)

### é¢˜ç›®

ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Ÿæ™ºèƒ½æŒ‡é’ˆå’Œæ™®é€šæŒ‡é’ˆçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›å¸¸ç”¨çš„æ™ºèƒ½æŒ‡é’ˆï¼Ÿè¯´ä¸€ä¸‹åº•å±‚å¦‚ä½•å®ç°çš„ï¼Ÿ

### å‚è€ƒç­”æ¡ˆ

#### æ™®é€šæŒ‡é’ˆå­˜åœ¨çš„é—®é¢˜ï¼Ÿ

æ™®é€šæŒ‡é’ˆï¼ˆå¦‚ `C/C++` ä¸­çš„ `int*`ã€`char*`
ç­‰ï¼‰æ˜¯ç¼–ç¨‹ä¸­éå¸¸çµæ´»çš„å·¥å…·ï¼Œä½†åŒæ—¶ä¹Ÿå¸¦æ¥äº†è®¸å¤šæ½œåœ¨é—®é¢˜ã€‚è¿™äº›é—®é¢˜ä¸»è¦æºäºæŒ‡é’ˆçš„ä½çº§ç‰¹æ€§å’Œå¯¹èµ„æºç®¡ç†çš„ç›´æ¥ä¾èµ–ã€‚

##### å†…å­˜æ³„æ¼

å†…å­˜æ³„æ¼æ˜¯æŒ‡åŠ¨æ€åˆ†é…çš„å†…å­˜æ²¡æœ‰è¢«æ­£ç¡®é‡Šæ”¾ï¼Œå¯¼è‡´ç¨‹åºå ç”¨çš„å†…å­˜ä¸æ–­å¢åŠ ï¼Œæœ€ç»ˆå¯èƒ½å¯¼è‡´ç¨‹åºæ€§èƒ½ä¸‹é™ç”šè‡³å´©æºƒã€‚æ¯”å¦‚ä½¿ç”¨ `malloc` æˆ–è€… `new`
åˆ†é…å†…å­˜åï¼Œå¿…é¡»åœ¨åˆé€‚çš„æ—¶å€™ä½¿ç”¨ `free` æˆ–è€… `delete` é‡Šæ”¾å†…å­˜ã€‚å¦‚æœå¿˜è®°é‡Šæ”¾å†…å­˜ï¼Œå°±ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ã€‚ä¾‹å¦‚ï¼š

    
    
    void leakMemory() {
        int* ptr = new int[1000]; // åˆ†é…å†…å­˜
        // å¿˜è®°é‡Šæ”¾å†…å­˜
    }
    
    int main() {
        leakMemory();	// å‡½æ•°è°ƒç”¨
        return 0;
    }
    

å½“ç¨‹åºæ¯æ¬¡è°ƒç”¨ `leakMemory` å‡½æ•°æ—¶ï¼Œéƒ½ä¼šåˆ†é…1000ä¸ª `int` çš„å†…å­˜ï¼Œä½†è¿™äº›å†…å­˜æ°¸è¿œä¸ä¼šè¢«é‡Šæ”¾ã€‚

å†…å­˜æ³„æ¼çš„å¯¹ç¨‹åºçš„å±å®³ï¼š

  * **æ€§èƒ½ä¸‹é™** ï¼šéšç€ç¨‹åºè¿è¡Œæ—¶é—´çš„å¢åŠ ï¼Œå†…å­˜æ³„æ¼ä¼šå¯¼è‡´å¯ç”¨å†…å­˜é€æ¸å‡å°‘ï¼Œç¨‹åºè¿è¡Œé€Ÿåº¦å˜æ…¢ã€‚
  * **ç³»ç»Ÿå´©æºƒ** ï¼šå¦‚æœå†…å­˜æ³„æ¼ä¸¥é‡ï¼Œå¯èƒ½ä¼šè€—å°½ç³»ç»Ÿèµ„æºï¼Œå¯¼è‡´ç¨‹åºå´©æºƒç”šè‡³æ•´ä¸ªç³»ç»Ÿå´©æºƒã€‚
  * **èµ„æºæµªè´¹** ï¼šæœªé‡Šæ”¾çš„å†…å­˜æ— æ³•è¢«ç³»ç»Ÿæˆ–å…¶ä»–ç¨‹åºä½¿ç”¨ï¼Œé€ æˆèµ„æºæµªè´¹ã€‚

##### æ‚¬ç©ºæŒ‡é’ˆ

å¦å¤–ï¼Œè¿˜æœ‰ä¸€ç§æ— æ•ˆçš„æŒ‡é’ˆâ€”â€”æ‚¬ç©ºæŒ‡é’ˆï¼Œåœ¨ä½¿ç”¨æ—¶å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºç”šè‡³ç¨‹åºå´©æºƒã€‚

æ‚¬ç©ºæŒ‡é’ˆæ˜¯æŒ‡æŒ‡é’ˆæ›¾ç»æŒ‡å‘ä¸€ä¸ªæœ‰æ•ˆçš„å†…å­˜ä½ç½®ï¼Œä½†è¯¥å†…å­˜å·²è¢«é‡Šæ”¾æˆ–å›æ”¶ï¼Œå¯¼è‡´æŒ‡é’ˆå˜å¾—æ— æ•ˆã€‚å°½ç®¡æŒ‡é’ˆä»ç„¶ä¿å­˜ç€åŸæ¥çš„åœ°å€ï¼Œä½†è®¿é—®è¯¥åœ°å€ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼Œå› ä¸ºè¯¥åœ°å€å¯èƒ½å·²ç»è¢«åˆ†é…ç»™å…¶ä»–å¯¹è±¡æˆ–æˆä¸ºä¸å¯è®¿é—®çš„åŒºåŸŸã€‚ä¾‹å¦‚ï¼š

    
    
    void danglingPointer()
    {
        int *ptr = new int(10);
        delete ptr; // é‡Šæ”¾å†…å­˜
        *ptr = 20;  // é€šè¿‡æ‚¬ç©ºæŒ‡é’ˆè®¿é—®å†…å­˜ï¼Œæœªå®šä¹‰è¡Œä¸º
    }
    int main()
    {
        danglingPointer();	// å‡½æ•°è°ƒç”¨
        return 0;
    }
    

##### æŒ‡é’ˆè¢«é‡å¤é‡Šæ”¾

é‡å¤é‡Šæ”¾æ˜¯æŒ‡å¯¹åŒä¸€å—å†…å­˜è°ƒç”¨å¤šæ¬¡ `delete` æˆ– `free`ã€‚è¿™å¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒæˆ–å†…å­˜æŸåã€‚ä¾‹å¦‚ï¼š

    
    
    int *doubleFree()
    {
        int *ptr = new int(10);
        delete ptr; // ç¬¬ä¸€æ¬¡é‡Šæ”¾
        return ptr;
    }
    
    int main()
    {
        int *p = doubleFree();
    
        // free(): double free detected in tcache 2
        // Aborted (core dumped)
        delete p; // ç¬¬äºŒæ¬¡é‡Šæ”¾ï¼Œæœªå®šä¹‰è¡Œä¸º
        return 0;
    }
    

* * *

å¦å¤–ï¼Œåœ¨ä½¿ç”¨æ™®é€šæŒ‡é’ˆæ—¶å¦‚æœä¸æ³¨æ„å¯èƒ½è¿˜ä¼šæœ‰ä¸€äº›å…¶ä»–æ›´ä¸ºä¸¥é‡çš„é—®é¢˜äº§ç”Ÿï¼Œè¿™é‡Œå°±ä¸å†ä¸€ä¸€åˆ—ä¸¾ã€‚

è¯´åˆ°è¿™é‡Œæœ‰äº›åŒå­¦å¯èƒ½ä¼šæœ‰ç–‘é—®ï¼šå½“ç¨‹åºå‘˜çš„èƒ½åŠ›è¶³å¤Ÿå¼ºã€è¶³å¤Ÿçš„ä»”ç»†æ˜¯ä¸æ˜¯å°±å¯ä»¥é¿å…è¿™äº›é—®é¢˜ï¼Ÿè¿™ä¹ˆè¯´ä¹Ÿå¾ˆæœ‰é“ç†ï¼Œç¡®å®å¯ä»¥é¿å…è®¸å¤šå¸¸è§çš„é—®é¢˜ï¼Œæ¯”å¦‚å†…å­˜æ³„æ¼ã€æ‚¬ç©ºæŒ‡é’ˆç­‰ã€‚ç„¶è€Œï¼Œæˆ‘è®¤ä¸º
â€œäººéåœ£è´¤ï¼Œå­°èƒ½æ— è¿‡â€ï¼Œå³ä½¿æ˜¯èƒ½åŠ›æœ€å¼ºã€æœ€è°¨æ…çš„ç¨‹åºå‘˜ä¹Ÿéš¾ä»¥å®Œå…¨é¿å…é”™è¯¯ï¼Œå°¤å…¶æ˜¯åœ¨ç‰¹åˆ«å¤æ‚çš„é¡¹ç›®æˆ–å›¢é˜Ÿåä½œç¯å¢ƒä¸­ã€‚ä½¿ç”¨æ™®é€šæŒ‡é’ˆä»ç„¶å­˜åœ¨ä¸€äº›éš¾ä»¥å…‹æœçš„å±€é™æ€§ï¼Œè¿™äº›å±€é™æ€§ä½¿å¾—æ™ºèƒ½æŒ‡é’ˆå’Œå…¶ä»–ç°ä»£`C++`
ç‰¹æ€§æˆä¸ºæ›´å¥½çš„é€‰æ‹©ã€‚

é‚£ä¹ˆï¼Œæ¥ä¸‹æ¥å°±é’ˆå¯¹ `C++` æ ‡å‡†åº“ä¸­çš„æ™ºèƒ½æŒ‡é’ˆè¿›è¡Œæ·±åº¦è®²è§£ã€‚

#### æ™ºèƒ½æŒ‡é’ˆ

æ™ºèƒ½æŒ‡é’ˆæ˜¯ `C++` æ ‡å‡†åº“ä¸­çš„ä¸€ç§ç±»æ¨¡æ¿ï¼Œç”¨äº**è‡ªåŠ¨ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜** ã€‚å®ƒä»¬å¯ä»¥é˜²æ­¢å†…å­˜æ³„æ¼å’Œæ‚¬æŒ‚æŒ‡é’ˆé—®é¢˜ï¼Œå¹¶ä¸”æä¾›äº†å¼‚å¸¸å®‰å…¨æ€§ã€‚

`C++11` æ ‡å‡†åº“å¼•å…¥äº†ä¸‰ç§æ™ºèƒ½æŒ‡é’ˆï¼š`std::unique_ptr`ã€`std::shared_ptr` å’Œ `std::weak_ptr`ã€‚

> æœ¬æ–‡ç« åªè®¨è®º `C++11` æ ‡å‡†åº“ä¸­çš„æ™ºèƒ½æŒ‡é’ˆï¼Œ`Boost` åº“ä¸­æä¾›çš„æ™ºèƒ½æŒ‡é’ˆæœ¬æ–‡ç« ä¸å†è®¨è®ºã€‚å¦å¤–`std::auto_ptr` åœ¨
> `C++11` ä¸­è¢«åºŸå¼ƒï¼Œåœ¨ `C++17` ä¸­è¢«ç§»é™¤ã€‚æœ¬æ–‡ç« ä¹Ÿä¸å†è®¨è®ºã€‚
>
> å¦å¤–ï¼Œæœ¬ç¯‡æ–‡ç« çš„æ‰€æœ‰åº•å±‚æºç å‡æ¥æºäº `libstdc++` ï¼Œå…¶ä»–å¹³å°çš„æºç å®ç°å¯èƒ½ä¼šæœ‰äº›å‡ºå…¥ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

##### `std::unique_ptr`

`std::unique_ptr` æ˜¯ `C++11`
å¼•å…¥çš„ä¸€ç§æ™ºèƒ½æŒ‡é’ˆï¼Œè¡¨ç¤ºå¯¹èµ„æºï¼ˆé€šå¸¸æ˜¯åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼‰çš„ç‹¬å æ‰€æœ‰æƒã€‚å®ƒé€šè¿‡ç§»åŠ¨è¯­ä¹‰ï¼ˆè€Œä¸æ˜¯æ‹·è´è¯­ä¹‰ï¼‰æ¥è½¬ç§»èµ„æºçš„æ‰€æœ‰æƒï¼Œç¡®ä¿åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ª
`unique_ptr` å¯ä»¥ç®¡ç†æŸä¸ªèµ„æºã€‚

    
    
    #include <memory>
    #include <iostream>
    
    int main()
    {
        std::unique_ptr<int> p(new int(10));
        std::cout << *p << std::endl;	// 10
    
        // cannot be referenced -- it is a deleted function
        // std::unique_ptr<int> p1 = p;
        // p = p1;
    }
    

åœ¨æºç ä¸­ï¼Œ`std::unique_ptr` å› ä¸ºç¦ç”¨äº†æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼è¿ç®—ç¬¦å‡½æ•°ï¼Œå¯¼è‡´ `std::unique_ptr` ä¸æ”¯æŒæ‹·è´è¯­ä¹‰ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
    

è™½ç„¶ `std::unique_ptr` ç¦ç”¨äº†æ‹·è´æ„é€ å’Œèµ‹å€¼æ“ä½œè¿ç®—ç¬¦ï¼Œä½†æ˜¯æä¾›äº†ç§»åŠ¨æ‹·è´æ„é€ å’Œç§»åŠ¨èµ‹å€¼æ“ä½œè¿ç®—ç¬¦ï¼Œä¹Ÿå°±æ˜¯è¯´
`std::unique_ptr` æ”¯æŒäº†ç§»åŠ¨è¯­ä¹‰ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    // Move constructor.
    unique_ptr(unique_ptr&&) = default;
    unique_ptr& operator=(unique_ptr&&) = default;
    

> æ³¨æ„ï¼š`std::unique_ptr` æ¨¡æ¿åŒ–çš„ç§»åŠ¨æ‹·è´æ„é€ å’Œç§»åŠ¨èµ‹å€¼æ“ä½œè¿ç®—ç¬¦æºç è¿™é‡Œä¸å†åˆ—ä¸¾ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦è‡ªè¡ŒæŸ¥çœ‹æºä»£ç ã€‚
    
    
    #include <memory>
    #include <iostream>
    
    int main()
    {
        std::unique_ptr<int> p(new int(10));
        std::unique_ptr<int> p1(new int(21));
        std::cout << *p << std::endl;  // 10
        std::cout << *p1 << std::endl; // 21
    
        std::unique_ptr<int> p3(std::move(p)); // ç§»åŠ¨æ„é€ 
    
        std::unique_ptr<int> p4;
        p4 = std::move(p1); // ç§»åŠ¨èµ‹å€¼æ“ä½œè¿ç®—ç¬¦
    
        std::cout << *p3 << std::endl; // 10
        std::cout << *p4 << std::endl; // 21
    
        return 0;
    }
    

###### åº•å±‚ç»“æ„

åœ¨ `std::unique_ptr` çš„å®ç°ä¸­ï¼Œ`__uniq_ptr_data` æ˜¯ä¸€ä¸ªåº•å±‚æ•°æ®ç»“æ„ï¼Œç”¨äºå°è£…å’Œç®¡ç† `std::unique_ptr`
çš„åº•å±‚æŒ‡é’ˆå’Œåˆ é™¤å™¨ã€‚

ä¸ºäº†å¯ä»¥æ›´å¥½çš„ç†è§£ä¸‹é¢çš„æºç ï¼Œè¿™é‡Œå…ˆè§£é‡Šä¸€ä¸‹åˆ é™¤å™¨ï¼šåˆ é™¤å™¨æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„ç»„ä»¶ï¼Œå®ƒå®šä¹‰äº†å¦‚ä½•é‡Šæ”¾ `std::unique_ptr`
æ‰€ç®¡ç†çš„èµ„æºã€‚å¦å¤–ï¼Œåˆ é™¤å™¨çš„ä½œç”¨ä¸ä»…ä»…æ˜¯ç®€å•åœ°é‡Šæ”¾å†…å­˜ï¼Œå®ƒè¿˜å¯ä»¥æ‰§è¡Œæ›´å¤æ‚çš„æ¸…ç†æ“ä½œï¼Œæ¯”å¦‚å…³é—­æ–‡ä»¶å¥æŸ„ã€é‡Šæ”¾ç½‘ç»œè¿æ¥ã€é”€æ¯è‡ªå®šä¹‰å¯¹è±¡ç­‰ã€‚å®é™…å¼€å‘è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡è‡ªå®šä¹‰åˆ é™¤å™¨ï¼Œ`std::unique_ptr`
èƒ½å¤Ÿçµæ´»åœ°ç®¡ç†å„ç§ç±»å‹çš„èµ„æºï¼Œè€Œä¸ä»…ä»…æ˜¯åŠ¨æ€åˆ†é…çš„å†…å­˜ã€‚

åœ¨ä¸‹é¢çš„ `std::unique_ptr` æ¨¡æ¿ç±»ä¸­ï¼Œç±»å‹ `_Tp` è¡¨ç¤ºåº•å±‚æŒ‡é’ˆçš„æ³›å‹å‚æ•°ï¼Œè€Œ `_Dp`
è¡¨ç¤ºæ‰€ä½¿ç”¨çš„åˆ é™¤å™¨ï¼Œå¦‚æœæœªæŒ‡å®šåˆ é™¤å™¨åˆ™ä½¿ç”¨é»˜è®¤åˆ é™¤å™¨ `default_delete<_Tp>`ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
        // ...
    	
        __uniq_ptr_data<_Tp, _Dp> _M_t;
        
        // ...
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

åœ¨ä¸Šè¿°ç»“æ„ä½“ä¸­ï¼Œ `_M_t` æ˜¯æœ€ä¸ºæ ¸å¿ƒçš„æˆå‘˜å±æ€§ï¼Œè¯¥å±æ€§æ˜¯ä¸€ä¸ªåŒ…å«äº†ä¸¤ä¸ªéƒ¨åˆ†çš„æ¨¡æ¿ç»“æ„ä½“ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template <typename _Tp, typename _Dp,
        bool = is_move_constructible<_Dp>::value,
        bool = is_move_assignable<_Dp>::value>
    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
    {
        using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
        __uniq_ptr_data(__uniq_ptr_data&&) = default;
        __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };
    

è€Œ `__uniq_ptr_data` åˆç»§æ‰¿è‡ª `__uniq_ptr_impl`ï¼Œ`__uniq_ptr_impl` ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œç”¨äºå°è£…å’Œç®¡ç†
`std::unique_ptr` çš„æŒ‡é’ˆå’Œåˆ é™¤å™¨ã€‚å®ƒæ˜¯ `std::unique_ptr` çš„åº•å±‚å®ç°ç»†èŠ‚ï¼Œéšè—äº†æŒ‡é’ˆå’Œåˆ é™¤å™¨çš„ç®¡ç†é€»è¾‘ï¼Œä½¿å¾—
`std::unique_ptr` çš„æ¥å£æ›´åŠ ç®€æ´å’Œå®‰å…¨ã€‚æºç å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
        template <typename _Up, typename _Ep, typename = void>
        struct _Ptr
        {
    		using type = _Up*;
        };
    
        template <typename _Up, typename _Ep>
        struct
        _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
        {
            using type = typename remove_reference<_Ep>::type::pointer;
        };
    
    public:
     	// ...
    
        pointer&   _M_ptr() { return std::get<0>(_M_t); }
        pointer    _M_ptr() const { return std::get<0>(_M_t); }
        _Dp&       _M_deleter() { return std::get<1>(_M_t); }
        const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
    
    	// ...
    
    private:
    	tuple<pointer, _Dp> _M_t;
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

ä»ä¸Šè¿°ä»£ç ä¸­å¯ä»¥çœ‹å‡ºï¼Œ`__uniq_ptr_impl` åˆä½¿ç”¨ `tuple` å­˜å‚¨åº•å±‚æŒ‡é’ˆå’Œåˆ é™¤å™¨ï¼ŒåŒæ—¶å¯¹å¤–ä¹Ÿæä¾›äº†åº•å±‚æŒ‡é’ˆ `pointer`
å’Œåˆ é™¤å™¨ `_Dp` çš„è®¿é—®å‡½æ•°ã€‚

###### å¸¸ç”¨æ“ä½œ

ä¸‹é¢é’ˆå¯¹ `std::unique_ptr` ä¸­å¸¸ç”¨å‡½æ•°çš„åº•å±‚æºç è¿›è¡Œåˆ†æã€‚

###### é‡Šæ”¾æ‰€æœ‰æƒ

`release` å‡½æ•°é‡Šæ”¾ `std::unique_ptr` å½“å‰ç®¡ç†çš„æŒ‡é’ˆã€‚

    
    
    pointer release() noexcept
    { 
        return _M_t.release(); 
    }
    

è°ƒç”¨ `_M_t` çš„ `release` å‡½æ•°ï¼Œå–åˆ°åº•å±‚æŒ‡é’ˆ `__p`ï¼Œç›´æ¥å°†åº•å±‚æŒ‡é’ˆç½®ä¸º `nullptr`ï¼Œæœ€ç»ˆè¿”å›å½“å‰ç®¡ç†çš„æŒ‡é’ˆã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    pointer release() noexcept
    {
        pointer __p = _M_ptr();
        _M_ptr() = nullptr;
        return __p;
    }
    

å¦‚æœå°† `std::unique_ptr` çš„åº•å±‚æŒ‡é’ˆç½®ä¸º `nullptr`ï¼Œè¡¨ç¤ºå®ƒä¸å†ç®¡ç†ä»»ä½•èµ„æºã€‚

###### é‡ç½®

`reset` å‡½æ•°ç”¨äºæ›¿æ¢ `std::unique_ptr` å½“å‰ç®¡ç†çš„åº•å±‚æŒ‡é’ˆã€‚

    
    
    void reset(pointer __p = pointer()) noexcept
    {
    	static_assert(__is_invocable<deleter_type&, pointer>::value,
          "unique_ptr's deleter must be invocable with a pointer");
    	_M_t.reset(std::move(__p));
    }
    

è°ƒç”¨ `_M_t` çš„ `reset` å‡½æ•°ï¼Œå–åˆ°åº•å±‚æŒ‡é’ˆ `__old_p`ï¼Œå°†æ–°çš„æŒ‡é’ˆ `__p` èµ‹å€¼åº•å±‚æŒ‡é’ˆã€‚ç»™å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void reset(pointer __p) noexcept
    {
        const pointer __old_p = _M_ptr();
        // æ–°çš„æŒ‡é’ˆèµ‹å€¼ç»™ unique_ptr
        _M_ptr() = __p;
        // å¦‚æœå½“å‰æŒ‡é’ˆä¸ä¸ºç©º
        if (__old_p)
            // è°ƒç”¨åˆ é™¤å™¨é‡Šæ”¾å½“å‰æŒ‡é’ˆ
        	_M_deleter()(__old_p);
    }
    

å¦‚æœå½“å‰åº•å±‚æŒ‡é’ˆ `__old_p` ä¸ä¸ºç©ºï¼Œåˆ™é¦–å…ˆè·å–åˆ°åˆ é™¤å™¨ã€‚ç»™å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    // è·å–å–åˆ°åˆ é™¤å™¨
    const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
    

ç„¶åï¼Œé€šè¿‡è°ƒç”¨åˆ é™¤å™¨é‡Šæ”¾å½“å‰æŒ‡é’ˆï¼ˆä¸‹é¢è¿™ä¸ªæ˜¯é»˜è®¤åˆ é™¤å™¨çš„é‡Šæ”¾æŒ‡é’ˆçš„ä»£ç ï¼‰ã€‚ç»™å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Tp>
    struct default_delete
    {
        // ...
        
        void operator()(_Tp* __ptr) const
        {
            static_assert(!is_void<_Tp>::value,
                  "can't delete pointer to incomplete type");
            static_assert(sizeof(_Tp)>0,
                  "can't delete pointer to incomplete type");
            delete __ptr;
        }
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

###### è·å–åŸå§‹æŒ‡é’ˆ

`get` å‡½æ•°è¿”å› `std::unique_ptr` å½“å‰ç®¡ç†çš„åº•å±‚æŒ‡é’ˆã€‚å®ƒä¸ä¼šè½¬ç§»æ‰€æœ‰æƒï¼Œåªæ˜¯æä¾›å¯¹åº•å±‚æŒ‡é’ˆçš„è®¿é—®ã€‚

    
    
    pointer get() const noexcept
    { 
        return _M_t._M_ptr();
    }
    

è°ƒç”¨ `_M_t` çš„ `_M_ptr` å‡½æ•°ï¼Œå–åˆ°åº•å±‚æŒ‡é’ˆ `pointer`ï¼Œç›´æ¥è¿”å›è¯¥æŒ‡é’ˆã€‚ç»™å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    pointer _M_ptr() const { return std::get<0>(_M_t); }
    

###### äº¤æ¢

`swap` å‡½æ•°ç”¨äºäº¤æ¢ä¸¤ä¸ª `std::unique_ptr` çš„åº•å±‚æŒ‡é’ˆå’Œåˆ é™¤å™¨ã€‚

    
    
    void swap(unique_ptr& __u) noexcept
    {
        static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
        _M_t.swap(__u._M_t);
    }
    

è°ƒç”¨ `_M_t` çš„ `swap` å‡½æ•°ï¼Œåº•å±‚ä½¿ç”¨çš„æ˜¯æ ‡å‡†åº“çš„ `std::swap` å‡½æ•°ï¼Œç„¶åäº¤æ¢åº•å±‚æŒ‡é’ˆå’Œåˆ é™¤å™¨ã€‚ç»™å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void swap(__uniq_ptr_impl& __rhs) noexcept
    {
        using std::swap;
        swap(this->_M_ptr(), __rhs._M_ptr());
        swap(this->_M_deleter(), __rhs._M_deleter());
    }
    

##### `std::shared_ptr`

`std::shared_ptr` ä¹Ÿæ˜¯ `C++11` å¼•å…¥çš„ä¸€ç§æ™ºèƒ½æŒ‡é’ˆï¼Œç”¨äºé€šè¿‡å¼•ç”¨è®¡æ•°æœºåˆ¶å…±äº«å¯¹è±¡çš„æ‰€æœ‰æƒã€‚å®ƒå…è®¸å¤šä¸ª
`std::shared_ptr` å®ä¾‹å…±äº«åŒä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶åœ¨æœ€åä¸€ä¸ª `std::shared_ptr` è¢«é”€æ¯æ—¶è‡ªåŠ¨é”€æ¯å¯¹è±¡ã€‚

    
    
    #include <memory>
    #include <iostream>
    
    int main()
    {
        std::shared_ptr<int> p(new int(10));
        std::cout << *p << std::endl; // 10
    
        std::shared_ptr<int> p1;
        std::shared_ptr<int> p2 = p;	// æ‹·è´æ„é€ 
    
        p1 = p2;	// èµ‹å€¼è¿ç®—ç¬¦æ„é€ 
    
        std::cout << *p << std::endl;  // 10
        std::cout << *p1 << std::endl; // 10
        std::cout << *p2 << std::endl; // 10
    }
    

`std::shared_ptr` å’Œ `std::unique_ptr` çš„å…¶ä¸­ä¹‹ä¸€çš„åŒºåˆ«å°±æ˜¯å…è®¸å…±äº«åŒä¸€ä¸ªå¯¹è±¡çš„æ‰€æœ‰æƒï¼Œåœ¨æºç ä¸­
`std::shared_ptr` å¼€æ”¾äº†æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼è¿ç®—ç¬¦å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ”¯æŒæ‹·è´è¯­ä¹‰ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    shared_ptr(const shared_ptr&) noexcept = default;
    shared_ptr& operator=(const shared_ptr&) noexcept = default;
    

> æ³¨æ„ï¼š`std::shared_ptr` æ¨¡æ¿åŒ–çš„æ‹·è´æ„é€ å’Œèµ‹å€¼æ“ä½œè¿ç®—ç¬¦æºç è¿™é‡Œä¸å†åˆ—ä¸¾ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦è‡ªè¡ŒæŸ¥çœ‹æºä»£ç ã€‚

åŒæ ·çš„ `std::shared_ptr` ä¹Ÿå¼€æ”¾äº†ç§»åŠ¨æ‹·è´æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦å‡½æ•°ï¼Œæ”¯æŒç§»åŠ¨è¯­ä¹‰ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    shared_ptr(shared_ptr&& __r) noexcept
    	: __shared_ptr<_Tp>(std::move(__r)) { }
    
    shared_ptr& operator=(shared_ptr&& __r) noexcept
    {
        this->__shared_ptr<_Tp>::operator=(std::move(__r));
        return *this;
    }
    

> æ³¨æ„ï¼š`std::shared_ptr` æ¨¡æ¿åŒ–çš„ç§»åŠ¨æ‹·è´æ„é€ å’Œç§»åŠ¨èµ‹å€¼æ“ä½œè¿ç®—ç¬¦æºç è¿™é‡Œä¸å†åˆ—ä¸¾ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦è‡ªè¡ŒæŸ¥çœ‹æºä»£ç ã€‚
    
    
    #include <memory>
    #include <iostream>
    
    int main()
    {
        std::shared_ptr<int> p(new int(10));
        std::cout << *p << std::endl; // 10
    
        std::shared_ptr<int> p1;
        std::shared_ptr<int> p2 = std::move(p);
    
        p1 = std::move(p2);
    
        std::cout << *p1 << std::endl; // 10
    }
    

###### åº•å±‚ç»“æ„

`std::shared_ptr` æ˜¯é€šè¿‡ç»§æ‰¿ä¸€ä¸ªå†…éƒ¨æ¨¡æ¿ç±» `__shared_ptr<_Tp>` æ¥å®ç°çš„ã€‚è¿™ç§è®¾è®¡å…è®¸
`std::shared_ptr` ç»§æ‰¿åº•å±‚çš„èµ„æºç®¡ç†å’Œå¼•ç”¨è®¡æ•°é€»è¾‘ï¼ŒåŒæ—¶æä¾›æ ‡å‡†åº“çš„æ¥å£ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
        // ...
    }
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

åœ¨ `__shared_ptr<_Tp>` ç±»ä¸­å°è£…äº†é‡è¦çš„ä¸¤ä¸ªæˆå‘˜å±æ€§ï¼š`_M_ptr` å’Œ `_M_refcount`ã€‚

  * `_M_ptr`ï¼šæŒ‡å‘è¢«ç®¡ç†åº•å±‚æŒ‡é’ˆçš„æŒ‡é’ˆã€‚
  * `_M_refcount`ï¼šå¼•ç”¨è®¡æ•°å™¨ï¼Œç”¨äºè·Ÿè¸ªèµ„æºçš„å¼•ç”¨è®¡æ•°ã€‚

    
    
    template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr 
        : public __shared_ptr_access<_Tp, _Lp>
    {
    	// ...
    private:
        element_type*     _M_ptr;         // Contained pointer.
        __shared_count<_Lp>  _M_refcount;    // Reference counter.
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

åœ¨å¼•ç”¨è®¡æ•°å™¨ `_M_refcount` ä¸­ï¼Œåˆå°è£…äº†å¼•ç”¨è®¡æ•°é€»è¾‘çš„ç±» `__shared_count`ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<_Lock_policy _Lp>
    class __shared_count
    {
        // ...
    private:
        _Sp_counted_base<_Lp>*  _M_pi;
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

`_Sp_counted_base` ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œå°è£…äº†å®é™…çš„å¼•ç”¨è®¡æ•°é€»è¾‘ã€‚å®ƒåŒ…å«ä¸¤ä¸ªåŸå­è®¡æ•°å™¨ï¼š

  * `_M_use_count`ï¼šè®°å½•å¼ºå¼•ç”¨è®¡æ•°ï¼ˆå³ `std::shared_ptr` çš„ä¸ªæ•°ï¼‰ã€‚
  * `_M_weak_count`ï¼šè®°å½•å¼±å¼•ç”¨è®¡æ•°ï¼ˆå³ `std::weak_ptr` çš„ä¸ªæ•°ï¼‰ã€‚

    
    
    template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
        : public _Mutex_base<_Lp>
    {
    	// ...
    private:
        _Atomic_word  _M_use_count;     // #shared
        _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

* * *

æ¥ä¸‹æ¥ï¼Œä»æ•´ä¸ª `std::shared_ptr` çš„ç”Ÿå‘½å‘¨æœŸï¼Œæ·±å…¥äº†è§£ `std::shared_ptr` æ˜¯å¦‚ä½•ç®¡ç†å¼•ç”¨è®¡æ•°å™¨çš„ã€‚

  * å½“ä¸€ä¸ªæ–°çš„ `std::shared_ptr` è¢«åˆ›å»ºæ—¶ï¼Œ`_M_use_count` å’Œ `_M_weak_count` é»˜è®¤éƒ½æ˜¯ 1ã€‚

    
    
    explicit shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
    

è°ƒç”¨ `__shared_ptr<_Tp>(__p)` æ„é€ å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Yp, typename = _SafeConv<_Yp>>
    explicit
    __shared_ptr(_Yp* __p)
    : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
    {
        static_assert( !is_void<_Yp>::value, "incomplete type" );
        static_assert( sizeof(_Yp) > 0, "incomplete type" );
        _M_enable_shared_from_this_with(__p);
    }
    

é¦–å…ˆ `_M_ptr(__p)` åˆå§‹åŒ–æ•°æ®æŒ‡é’ˆï¼Œç´§æ¥ç€ï¼Œè°ƒç”¨ `_M_refcount(__p, typename
is_array<_Tp>::type())` æ„é€ å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Ptr>
    explicit __shared_count(_Ptr __p) : _M_pi(0)
    {
        __try
        {
    		_M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
        }
        __catch(...)
        {
            delete __p;
            __throw_exception_again;
        }
    }
    

è°ƒç”¨ `_M_pi` çš„æ„é€ å‡½æ•°ï¼Œå…ˆåˆå§‹åŒ–çˆ¶ç±» `_Sp_counted_base`ï¼Œå½“çˆ¶ç±»åˆå§‹åŒ–å®Œæ¯•åå†åˆå§‹åŒ–
`_Sp_counted_ptr`ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    _Sp_counted_base() noexcept
          : _M_use_count(1), _M_weak_count(1) { }
    

  * æ¯å½“å…±äº«ä¸€ä¸ª `std::shared_ptr` æŒ‡é’ˆæ—¶ï¼Œ`_M_use_count` ä¼šå¢åŠ ã€‚

> ä¸‹é¢ä»¥èµ‹å€¼æ“ä½œè¿ç®—ç¬¦ä¸ºä¾‹ã€‚å…¶ä»–æƒ…å†µåŸºæœ¬ç±»ä¼¼ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚
    
    
    shared_ptr& operator=(const shared_ptr&) noexcept = default;
    

`std::shared_ptr` ä½¿ç”¨äº† `default` çš„æ–¹å¼è®©ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆä»£ç ï¼Œè¿™é‡Œå¯ä»¥æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£ï¼š

>
> [cppreference.com](https://en.cppreference.com/w/cpp/memory/shared_ptr/operator%3D)
>
> Shares ownership of the object managed by r. If r manages no object, *this
> manages no object too. Equivalent to shared_ptrÂ®.swap(*this).

æ ¹æ®æ ‡å‡†åº“çš„æ–‡æ¡£ï¼Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦çš„è¡Œä¸ºç­‰ä»·äºä»¥ä¸‹ä»£ç ï¼š

    
    
    shared_ptr(r).swap(*this);
    

é¦–å…ˆæ„é€ ä¸€ä¸ªä¸´æ—¶çš„ `std::shared_ptr` å¯¹è±¡ï¼Œå®ƒå…±äº« `r` çš„æ‰€æœ‰æƒã€‚ç„¶åï¼Œé€šè¿‡ `swap` æ–¹æ³•äº¤æ¢ä¸´æ—¶å¯¹è±¡å’Œå½“å‰å¯¹è±¡çš„å†…å®¹ã€‚

    
    
    template<typename _Yp,
    	       typename = _Constructible<const shared_ptr<_Yp>&>>
    shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }
    

è°ƒç”¨ `__shared_ptr` çš„å¸¦å‚æ„é€ å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Yp, typename = _Compatible<_Yp>>
    __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
    	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) { }
    

å…¶ä¸­ï¼Œ`_M_refcount` åˆè°ƒç”¨äº† `__shared_count` çš„æ‹·è´æ„é€ å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
     __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
    {
        if (_M_pi != nullptr)
        	_M_pi->_M_add_ref_copy();
    }
    

åœ¨è¯¥å‡½æ•°ä¸­å½“ `_M_pi != nullptr` æ—¶ï¼Œè°ƒç”¨ `_M_add_ref_copy`
å‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°å†…é‡‡ç”¨åŸå­æ“ä½œå¢åŠ å¼ºå¼•ç”¨è®¡æ•°å™¨çš„å€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void _M_add_ref_copy()
    { 
        __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1);
    }
    

æœ€åçš„äº¤æ¢é€»è¾‘å‚è€ƒ **å¸¸ç”¨æ“ä½œ** å°ç»“ä¸­çš„å†…å®¹ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚

  * å½“ä¸€ä¸ª `std::shared_ptr` è¢«é”€æ¯æ—¶ï¼Œ`_M_use_count` å¼•ç”¨è®¡æ•°ä¼šå‡å°‘ã€‚å¦‚æœå¼•ç”¨è®¡æ•°å˜ä¸ºé›¶ï¼Œè¯´æ˜æ²¡æœ‰ `std::shared_ptr` å†æŒæœ‰è¯¥å¯¹è±¡ï¼Œæ­¤æ—¶å¯¹è±¡ä¼šè¢«é”€æ¯ã€‚

`__shared_count` å¯¹è±¡å°è£…äº†å¼•ç”¨è®¡æ•°çš„é€»è¾‘ã€‚å½“ `std::shared_ptr` è¢«é”€æ¯æ—¶ï¼Œè§¦å‘ææ„é€»è¾‘ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
     ~__shared_count() noexcept
    {
        if (_M_pi != nullptr)
        	_M_pi->_M_release();
    }
    

è°ƒç”¨äº† `_M_release` å‡½æ•°ï¼Œè¯¥å‡½æ•°å†…å¯¹å¼•ç”¨è®¡æ•°å™¨è¿›è¡Œäº†å‡ä¸€çš„æ“ä½œï¼Œå½“å¼•ç”¨è®¡æ•°å™¨ä¸º0æ—¶ï¼Œè§¦å‘èµ„æºå›æ”¶çš„é€»è¾‘ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void _M_release() noexcept
    {
        // ...
        if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
        {
           // ...
            _M_dispose();
    
            // ...
            
            if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
              {
    			// ...
            	_M_destroy();
              }
        }
    }
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

`__exchange_and_add_dispatch` å‡½æ•°åˆ†åˆ«å¯¹ `_M_use_count` å’Œ `_M_weak_count` è¿›è¡Œäº†å‡ä¸€æ“ä½œï¼Œå½“
`_M_use_count` å€¼ä¸º 0 æ—¶è°ƒç”¨ `_M_dispose` å‡½æ•°ï¼›å½“ `_M_weak_count` å€¼ä¸º 0 æ—¶è°ƒç”¨
`_M_destroy` å‡½æ•°ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    virtual void _M_dispose() noexcept { delete _M_ptr; }
    
    
    
    virtual void _M_destroy() noexcept { delete this; }
    

* * *

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬è¿˜æœªå¯¹ **å¼±å¼•ç”¨è®¡æ•°å™¨** çš„ä½œç”¨è¿›è¡Œè¯´æ˜ã€‚å¦å¤–ï¼Œä»ä¸Šé¢çš„æè¿°ä¸­æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå¼ºå¼•ç”¨è®¡æ•°å™¨çš„ä½œç”¨æ˜¯ä¸ºäº†è·Ÿè¸ª
`std::shared_ptr` ç®¡ç†çš„åº•å±‚æŒ‡é’ˆè¢«å¤šå°‘ä¸ªå…¶ä»–çš„ `std::shared_ptr`
å…±äº«ã€‚é‚£ä¹ˆåœ¨è¿™é‡Œæˆ‘å…ˆæŠ›å‡ºä¸€ä¸ªé—®é¢˜ï¼š**åœ¨ä¸‹é¢çš„ä»£ç ç¤ºä¾‹ä¸­ï¼Œ`class A` å’Œ `class B` ä¸¤ä¸ªç±»çš„å¯¹è±¡é€šè¿‡ `std::shared_ptr`
æ™ºèƒ½æŒ‡é’ˆç›¸äº’å¼•ç”¨æ—¶ï¼Œåœ¨ç¨‹åºç»“æŸæ—¶æ˜¯å¦å¯ä»¥æ­£å¸¸çš„å°†å¼•ç”¨è®¡æ•°å‡å°‘åˆ°0ï¼Ÿ**

    
    
    #include <memory>
    
    class B;  // å‰ç½®å£°æ˜
    
    class A {
    public:
        std::shared_ptr<B> b_ptr;
    };
    
    class B {
    public:
        std::shared_ptr<A> a_ptr;
    };
    
    int main() {
        std::shared_ptr<A> aptr = std::make_shared<A>();
        std::shared_ptr<B> bptr = std::make_shared<B>();
    
        aptr->b_ptr = bptr;  // A æŒæœ‰ B çš„å…±äº«æŒ‡é’ˆ
        bptr->a_ptr = aptr;  // B æŒæœ‰ A çš„å…±äº«æŒ‡é’ˆ
    
        return 0;
    }
    

**ç­”æ¡ˆï¼šåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`A` å’Œ `B` é€šè¿‡ `std::shared_ptr` ç›¸äº’å¼•ç”¨ï¼Œå½¢æˆä¸€ä¸ªå¾ªç¯ä¾èµ–ã€‚å½“ç¨‹åºç»“æŸæ—¶ï¼Œ`A` å’Œ `B`
çš„å¼•ç”¨è®¡æ•°éƒ½ä¸º1ï¼Œæ— æ³•å‡å°‘åˆ°0ï¼Œå› æ­¤ä¸ä¼šè§¦å‘åˆ é™¤å™¨ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼**ã€‚

ä¸ºä»€ä¹ˆï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿè§£å†³åŠæ³•æ˜¯å¦å’Œå¼±å¼•ç”¨è®¡æ•°ç›¸å…³ï¼Ÿè¿™äº›æ‚¬å¿µä¼šåœ¨ `std::weak_ptr` ç« èŠ‚ä¸­ä¸€ä¸€è§£ç­”ã€‚

###### å¸¸ç”¨æ“ä½œ

###### è·å–å¼•ç”¨è®¡æ•°

`use_count` å‡½æ•°è¿”å›å½“å‰ `std::shared_ptr` ç®¡ç†çš„åº•å±‚æŒ‡é’ˆçš„å¼•ç”¨è®¡æ•°ï¼Œå³æœ‰å¤šå°‘ä¸ª `std::shared_ptr`
å®ä¾‹å…±äº«åŒä¸€ä¸ªåº•å±‚æŒ‡é’ˆã€‚

    
    
    long use_count() const noexcept
    { 
        return _M_refcount._M_get_use_count(); 
    }
    

è°ƒç”¨ `_M_refcount` çš„ `_M_get_use_count` å‡½æ•°ï¼Œå¦‚æœ `std::shared_ptr` æ²¡æœ‰å¼•ç”¨ä»»ä½•æŒ‡é’ˆï¼Œåˆ™
`_M_pi` å¯¹è±¡ä¸º `nullptr` åˆ™è¿”å› 0ï¼Œå¦åˆ™è°ƒç”¨ `_M_pi` å¯¹è±¡çš„ `_M_get_use_count` è·å–å¼ºå¼•ç”¨è®¡æ•°å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    long _M_get_use_count() const noexcept
    { 
        return _M_pi ? _M_pi->_M_get_use_count() : 0; 
    }
    

ç´§æ¥ç€ï¼Œåœ¨ `_M_get_use_count` ä¸­ä½¿ç”¨åŸå­æ“ä½œè¯»å– `_M_use_count` å¼ºå¼•ç”¨è®¡æ•°å™¨çš„å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    long _M_get_use_count() const noexcept
    {
        // No memory barrier is used here so there is no synchronization
        // with other threads.
        return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
    }
    

å…¶ä¸­ï¼Œ`__ATOMIC_RELAXED` æ˜¯æœ€å¼±çš„å†…å­˜é¡ºåºæ¨¡å‹ï¼Œä»…ä¿è¯æ“ä½œçš„åŸå­æ€§ï¼Œä¸æä¾›ä»»ä½•å†…å­˜é¡ºåºä¿è¯ã€‚

###### é‡ç½®

`reset` å‡½æ•°ç”¨äºé‡Šæ”¾å½“å‰ `std::shared_ptr` ç®¡ç†çš„æŒ‡é’ˆã€‚

    
    
    void reset() noexcept
    { 
        __shared_ptr().swap(*this); 
    }
    

åœ¨ `reset` å‡½æ•°ä¸­ä½¿ç”¨é»˜è®¤æ„é€ åˆ›å»ºäº† `__shared_ptr` ä¸´æ—¶å¯¹è±¡ï¼Œè¿™ä¸ªä¸´æ—¶å¯¹è±¡ä¸ç®¡ç†ä»»ä½•èµ„æºï¼ˆå³å®ƒçš„å¼•ç”¨è®¡æ•°ä¸º 0ï¼‰ã€‚ç„¶åè°ƒç”¨äº†
`swap` å‡½æ•°å°†å½“å‰ `std::shared_ptr` å¯¹è±¡çš„å†…å®¹ä¸ä¸´æ—¶å¯¹è±¡äº¤æ¢ã€‚äº¤æ¢åï¼Œå½“å‰ `std::shared_ptr`
çš„å†…å®¹è¢«æ¸…ç©ºã€‚åŒæ—¶ï¼Œä¸´æ—¶å¯¹è±¡æ¥ç®¡äº†å½“å‰ `std::shared_ptr` çš„èµ„æºï¼Œä½†ç”±äºä¸´æ—¶å¯¹è±¡å³å°†è¢«é”€æ¯ï¼Œå®ƒçš„ææ„å‡½æ•°å°±ä¼šè‡ªåŠ¨é‡Šæ”¾è¿™äº›èµ„æºã€‚

###### è·å–åŸå§‹æŒ‡é’ˆ

`get` å‡½æ•°è¿”å› `std::shared_ptr` ç®¡ç†çš„åº•å±‚æŒ‡é’ˆï¼Œä½†ä¸ä¼šè½¬ç§»æ‰€æœ‰æƒã€‚

    
    
    element_type* get() const noexcept
    { 
        return _M_ptr; 
    }
    

###### äº¤æ¢

`swap()` å‡½æ•°ç”¨äºäº¤æ¢ä¸¤ä¸ª `std::shared_ptr` çš„ç®¡ç†åº•å±‚æŒ‡é’ˆå’Œå¼•ç”¨å™¨ã€‚

    
    
    void swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
    {
        std::swap(_M_ptr, __other._M_ptr);
        _M_refcount._M_swap(__other._M_refcount);
    }
    

ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„ `swap` å‡½æ•°å¯¹åº•å±‚æŒ‡é’ˆè¿›è¡Œäº¤æ¢ï¼Œç„¶åè°ƒç”¨äº† `_M_swap` å‡½æ•°äº¤æ¢å¼•ç”¨è®¡æ•°å™¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
     void _M_swap(__shared_count& __r) noexcept
    {
        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
        __r._M_pi = _M_pi;
        _M_pi = __tmp;
    }
    

###### æ£€æµ‹æ˜¯å¦å”¯ä¸€

`unique()` å‡½æ•°ç”¨äºæ£€æŸ¥å½“å‰ `std::shared_ptr` æ˜¯å¦æ˜¯å…¶ç®¡ç†åº•å±‚æŒ‡é’ˆçš„å”¯ä¸€æ‰€æœ‰è€…ã€‚

    
    
    bool unique() const noexcept
    { 
        return _M_refcount._M_unique(); 
    }
    

è°ƒç”¨ `_M_unique` å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª `bool` å€¼ã€‚å¦‚æœ `_M_get_use_count` å‡½æ•°çš„è¿”å›å€¼ç­‰äº1è¿”å› `true` å¦åˆ™è¿”å›
`false`ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    bool _M_unique() const noexcept
    { 
        return this->_M_get_use_count() == 1; 
    }
    

åœ¨ `_M_get_use_count` å‡½æ•°ä¸­è°ƒç”¨äº† `_M_pi` çš„ `_M_get_use_count` æ–¹æ³•ï¼Œè¿”å›åº•å±‚æŒ‡é’ˆçš„å¼ºå¼•ç”¨è®¡æ•°å€¼ã€‚å…·ä½“
`_M_get_use_count` æ–¹æ³•å†…å®¹ï¼Œè¯·å‚è€ƒ **è·å–å¼•ç”¨è®¡æ•°** å‡½æ•°è§£æã€‚

###### åˆ¤æ–­ç›¸ç­‰æ€§

ä¸‹é¢ç»™å‡ºä¸€æ®µä»£ç ï¼Œè¯¥ä»£ç ä¸­åˆ¤æ–­äº†ä¸¤ä¸ª `std::shared_ptr` çš„ç›¸ç­‰æ€§ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    #include <memory>
    #include <iostream>
    
    int main()
    {
        std::shared_ptr<int> p(new int(10));
        std::shared_ptr<int> p1 = p;
    
        std::shared_ptr<int> p2(new int(10));
    
        std::cout << (p == p1) << std::endl; // 1
        std::cout << (p == p2) << std::endl; // 0
    }
    

å¯¹è±¡ç›¸ç­‰æ€§åˆ¤æ–­çš„ä¾æ®æ˜¯ `==` è¿ç®—ç¬¦é‡è½½å‡½æ•°çš„åˆ¤æ–­é€»è¾‘ï¼Œå‡½æ•°å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Tp, typename _Up>
    _GLIBCXX_NODISCARD inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }
    

åœ¨è¯¥å‡½æ•°ä¸­ï¼Œåˆ†åˆ«å¯¹ä¸¤ä¸ª `std::shared_ptr` è°ƒç”¨äº† `get`
å‡½æ•°ï¼Œåˆ¤æ–­ä¸¤ä¸ªåº•å±‚ç®¡ç†çš„æŒ‡é’ˆæ˜¯å¦ç›¸ç­‰ï¼Œåˆå› ä¸ºæŒ‡é’ˆçš„ç›¸ç­‰æ€§æ˜¯æ ¹æ®æŒ‡é’ˆçš„åœ°å€æ˜¯å¦ç›¸ç­‰æ¥ç¡®å®šçš„ï¼Œæ‰€ä»¥ä¸¤ä¸ª `std::shared_ptr`
æ˜¯å¦ç›¸ç­‰å°±æ˜¯åˆ¤æ–­åˆ†åˆ«å¼•ç”¨çš„åº•å±‚æŒ‡é’ˆåœ°å€æ˜¯å¦ç›¸ç­‰ã€‚

##### `std::weak_ptr`

`std::weak_ptr` æ˜¯ `C++11` æ ‡å‡†åº“ä¸­çš„ä¸€ç§æ™ºèƒ½æŒ‡é’ˆï¼Œç”¨äºè§£å†³ `std::shared_ptr`
åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°çš„å¾ªç¯å¼•ç”¨é—®é¢˜ï¼ŒåŒæ—¶å…è®¸å¯¹èµ„æºè¿›è¡Œâ€œå¼±å¼•ç”¨â€ã€‚ä¸ `std::shared_ptr` ä¸åŒï¼Œ`std::weak_ptr`
ä¸ä¼šå¢åŠ èµ„æºçš„å¼ºå¼•ç”¨è®¡æ•°ï¼Œå› æ­¤ä¸ä¼šé˜»æ­¢èµ„æºçš„é”€æ¯ã€‚

æˆ‘ä»¬é‡æ–°çœ‹ä¸€ä¸‹ `std::shared_ptr` ç« èŠ‚ä¸­ç»™å‡ºçš„å¼‚å¸¸ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    #include <memory>
    
    class B;  // å‰ç½®å£°æ˜
    
    class A {
    public:
        std::shared_ptr<B> b_ptr;
    };
    
    class B {
    public:
        std::shared_ptr<A> a_ptr;
    };
    
    int main() {
        std::shared_ptr<A> aptr = std::make_shared<A>();
        std::shared_ptr<B> bptr = std::make_shared<B>();
    
        aptr->b_ptr = bptr;  // A æŒæœ‰ B çš„å…±äº«æŒ‡é’ˆ
        bptr->a_ptr = aptr;  // B æŒæœ‰ A çš„å…±äº«æŒ‡é’ˆ
    
        return 0;
    }
    

æ¥ä¸‹æ¥ï¼Œæ ¹æ®æ¯è¡Œä»£ç åˆ†æä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆä¼šå‡ºç°åœ¨ç¨‹åºç»“æŸæ—¶ï¼Œå¼•ç”¨è®¡æ•°æ— æ³•åˆ° 0 çš„é—®é¢˜ã€‚

  * é¦–å…ˆåˆ›å»º `aptr`ï¼Œ`_M_use_count` å’Œ `_M_weak_count` éƒ½æ˜¯ 1ã€‚
  * ç´§æ¥ç€åˆ›å»º `bptr`ï¼Œ`_M_use_count` å’Œ `_M_weak_count` ä¹Ÿéƒ½æ˜¯ 1ã€‚
  * å½“æ‰§è¡Œåˆ° `aptr->b_ptr = bptr` æ—¶ï¼Œ`bptr` çš„ `_M_use_count` å¼•ç”¨è®¡æ•°å™¨å¢é•¿å˜æˆäº† 2ã€‚
  * åŒç†å½“æ‰§è¡Œåˆ° `bptr->a_ptr = aptr` æ—¶ï¼Œ`aptr` çš„ `_M_use_count` å¼•ç”¨è®¡æ•°å™¨ä¹Ÿå¢é•¿å˜æˆäº† 2ã€‚
  * å½“ç¨‹åº `main` å‡½æ•°ç»“æŸæ—¶ï¼Œå¯¹å‡½æ•°æ ˆä¸­çš„æ ˆå¯¹è±¡ä¾æ¬¡è¿›è¡Œææ„ï¼š 
    * é¦–å…ˆææ„ `bptr`ï¼Œå°† `bptr` çš„ `_M_use_count` å¼•ç”¨è®¡æ•°å™¨å‡å°‘å˜æˆäº† 1ï¼Œå› ä¸º `_M_use_count` ä¸æ˜¯ 0 æ— æ³•è§¦å‘ `_M_dispose` å‡½æ•°çš„æ‰§è¡Œã€‚
    * ç„¶åææ„ `aptr`ï¼Œå°† `aptr` çš„ `_M_use_count` å¼•ç”¨è®¡æ•°å™¨ä¹Ÿå‡å°‘å˜æˆäº† 1ï¼Œå› ä¸º `_M_use_count` åŒæ ·ä¸æ˜¯ 0 ä¹Ÿæ— æ³•è§¦å‘ `_M_dispose` å‡½æ•°çš„æ‰§è¡Œã€‚
  * æœ€ç»ˆï¼Œä¸¤ä¸ª `std::shared_ptr` æ‰€ç®¡ç†çš„åº•å±‚æŒ‡é’ˆéƒ½æ— æ³•å¾—åˆ°æ­£ç¡®çš„èµ„æºé‡Šæ”¾ï¼Œå½¢æˆå†…å­˜æ³„æ¼é—®é¢˜ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°±å¯ä»¥ä½¿ç”¨ `std::weak_ptr` æ¥æ‰“ç ´å¾ªç¯å¼•ç”¨ã€‚å› ä¸º `std::weak_ptr`
ä¸ä¼šå¢åŠ å¼ºå¼•ç”¨è®¡æ•°ï¼Œæ‰€ä»¥å¯ä»¥å®‰å…¨åœ°è®¿é—®èµ„æºã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    class B;  // å‰ç½®å£°æ˜
    
    class A {
    public:
        std::weak_ptr<B> b_ptr;  // ä½¿ç”¨ weak_ptr
    };
    
    class B {
    public:
        std::weak_ptr<A> a_ptr;
    };
    
    int main() {
        std::shared_ptr<A> aptr = std::make_shared<A>();
        std::shared_ptr<B> bptr = std::make_shared<B>();
    
        aptr->b_ptr = bptr;  // A æŒæœ‰ B çš„å¼±å¼•ç”¨
        bptr->a_ptr = aptr;  // B æŒæœ‰ A çš„å¼±å¼•ç”¨
    
        return 0;  // ç¨‹åºç»“æŸæ—¶ï¼Œèµ„æºå¯ä»¥æ­£ç¡®é‡Šæ”¾
    }
    

  * å½“æ‰§è¡Œåˆ° `aptr->b_ptr = bptr` æ—¶ï¼Œ`bptr` çš„ `_M_use_count` å¼•ç”¨è®¡æ•°å™¨ä¸ä¼šå¢é•¿ï¼Œä½†æ˜¯ä¼šå¯¹ `_M_weak_count` å¼•ç”¨è®¡æ•°å™¨å¢é•¿ï¼Œå˜æˆäº† 2ã€‚
  * åŒç†å½“æ‰§è¡Œåˆ° `bptr->a_ptr = aptr` æ—¶ï¼Œ`aptr` çš„ `_M_use_count` å¼•ç”¨è®¡æ•°å™¨ä¹Ÿä¸ä¼šå¢é•¿ï¼ŒåŒæ ·ä¼šå¯¹ `_M_weak_count` å¼•ç”¨è®¡æ•°å™¨å¢é•¿ï¼Œå˜æˆäº† 2ã€‚
  * å½“ `main` å‡½æ•°ç»“æŸæ—¶ï¼Œè§¦å‘ææ„é€»è¾‘ï¼š 
    * é¦–å…ˆææ„ `bptr`ï¼š 
      * `bptr` çš„ `_M_use_count` å‡å°‘1ï¼Œå˜ä¸º 0ï¼›å› ä¸º `_M_use_count` ä¸º 0ï¼Œè§¦å‘ `_M_dispose` å‡½æ•°ï¼Œé‡Šæ”¾ `B` çš„èµ„æºã€‚
      * `bptr` çš„ `_M_weak_count` å‡å°‘1ï¼Œå˜ä¸º1ã€‚
    * ç„¶åææ„ `aptr`ï¼š 
      * `aptr` çš„ `_M_use_count` å‡å°‘1ï¼Œå˜ä¸º 0ï¼›å› ä¸º `_M_use_count` ä¸º 0ï¼Œè§¦å‘ `_M_dispose` å‡½æ•°ï¼Œé‡Šæ”¾ `A` çš„èµ„æºã€‚
      * `aptr` çš„ `_M_weak_count` å‡å°‘1ï¼Œå˜ä¸º1ã€‚
  * å½“æœ€åä¸€ä¸ª `std::weak_ptr` è¢«ææ„æ—¶ï¼Œ`_M_weak_count` å‡å°‘åˆ° 0ï¼Œè§¦å‘ `_M_destroy` å‡½æ•°çš„æ‰§è¡Œã€‚è‡³æ­¤å†…å­˜éƒ½è¢«æ­£å¸¸é‡Šæ”¾ï¼Œæ— å†…å­˜æ³„æ¼é—®é¢˜ã€‚

* * *

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä¸€èµ·æ·±å…¥ `std::weak_ptr` ä¸­æ¢ç©¶å…¶èƒŒåçš„åŸç†ã€‚

`std::weak_ptr` æ”¯æŒæ‹·è´è¯­ä¹‰å’Œç§»åŠ¨è¯­ä¹‰ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    weak_ptr(const weak_ptr&) noexcept = default;
    weak_ptr& operator=(const weak_ptr& __r) noexcept = default;
    
    
    
    weak_ptr(weak_ptr&&) noexcept = default;
    weak_ptr& operator=(weak_ptr&& __r) noexcept = default;
    

> æ³¨æ„ï¼š`std::weak_ptr` æ¨¡æ¿åŒ–çš„æ‹·è´æ„é€ ã€ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨ã€èµ‹å€¼æ“ä½œè¿ç®—ç¬¦æºç è¿™é‡Œä¸å†åˆ—ä¸¾ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦è‡ªè¡ŒæŸ¥çœ‹ã€‚

###### åº•å±‚ç»“æ„

é¦–å…ˆ `std::weak_ptr` ç»§æ‰¿è‡ª `__weak_ptr<Tp>`ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
     template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
        // ...
    }
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

`__weak_ptr` æ˜¯ `std::weak_ptr` çš„åº•å±‚å®ç°ç±»ï¼Œç”¨äºç®¡ç†å¯¹èµ„æºçš„å¼±å¼•ç”¨ã€‚åœ¨ `__weak_ptr` ç±»ä¸­æœ‰ä¸¤ä¸ªæ ¸å¿ƒçš„æˆå‘˜å±æ€§
`_M_ptr` å’Œ `_M_refcount`ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
    	// ...
    private:
        element_type*	 _M_ptr;         // Contained pointer.
        __weak_count<_Lp>  _M_refcount;    // Reference counter.
    }
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

åœ¨ `__weak_count` ä¸­åˆå°è£…äº†å¯¹ `_Sp_counted_base` çš„å¼•ç”¨è®¡æ•°å™¨çš„ç®¡ç†ï¼Œç¡®ä¿å¼•ç”¨è®¡æ•°çš„ç”Ÿå‘½å‘¨æœŸè¢«æ­£ç¡®è·Ÿè¸ªã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    template<_Lock_policy _Lp>
    class __weak_count
    {
        // ...
    
    private:
        _Sp_counted_base<_Lp>*  _M_pi;
    };
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

* * *

  * å½“åˆ›å»ºä¸€ä¸ª `std::weak_ptr` æ—¶ï¼Œè°ƒç”¨å…¶æ„é€ å‡½æ•°ï¼ŒåŒæ—¶ä¹Ÿè°ƒç”¨ `__weak_ptr` çš„æ„é€ å‡½æ•°ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    weak_ptr(const shared_ptr<_Yp>& __r) noexcept
    	: __weak_ptr<_Tp>(__r) { }
    
    
    
    __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
    	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) { }
    

åˆå§‹åŒ–æ•°æ®æŒ‡é’ˆ `_M_ptr`ï¼Œå¦‚æœå½“å‰å¯¹è±¡ç¡®å®ç®¡ç†äº†ä¸€ä¸ªæœ‰æ•ˆçš„èµ„æºåˆ™å¢åŠ å¼±å¼•ç”¨è®¡æ•° `_M_weak_count`ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    __weak_count(const __shared_count<_Lp>& __r) noexcept
    	: _M_pi(__r._M_pi)
    {
        if (_M_pi != nullptr)
        	_M_pi->_M_weak_add_ref();
    }
    

è°ƒç”¨ `_M_weak_add_ref` å‡½æ•°å¢åŠ å¼±å¼•ç”¨è®¡æ•°
`_M_weak_count`ã€‚è¿™ä¸ªæ–¹æ³•æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­æ­£ç¡®åœ°æ›´æ–°å¼±å¼•ç”¨è®¡æ•°ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void _M_weak_add_ref() noexcept
    { 
         __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); 
    }
    

  * å½“é”€æ¯æˆ–è€…æˆ–é‡ç½® `std::weak_ptr` æ—¶ï¼Œ`__weak_count` çš„ææ„å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    ~__weak_count() noexcept
    {
        if (_M_pi != nullptr)
        	_M_pi->_M_weak_release();
    }
    

åœ¨ `_M_weak_release` å‡½æ•°ä¸­ä¼šè°ƒç”¨ `__exchange_and_add_dispatch` å‡½æ•°å°† `_M_weak_count`
å¼±å¼•ç”¨è®¡æ•°å™¨å‡ä¸€ï¼Œå¦‚æœå½“å¼±å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶ï¼Œåˆ™è°ƒç”¨ `_M_destroy` æ–¹æ³•ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void _M_weak_release() noexcept
    {
        // ...
        if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
        {
            // ...
            
            _M_destroy();
        }
    }
    

> ä»¥ä¸Šä»£ç åªæ˜¯éƒ¨åˆ†æˆªå–ï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚

`_M_destroy` æ˜¯ `_Sp_counted_base` ç±»ä¸­çš„ä¸€ä¸ªå…³é”®æ–¹æ³•ï¼Œå®ƒç¡®ä¿åœ¨å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶ï¼Œèµ„æºè¢«æ­£ç¡®é‡Šæ”¾ã€‚

    
    
    virtual void _M_destroy() noexcept
    { 
        delete this; 
    }
    

###### å¸¸ç”¨æ“ä½œ

###### æ£€æŸ¥å¼•ç”¨å¯¹è±¡æ˜¯å¦è¢«é”€æ¯

`expired` å‡½æ•°ç”¨äºæ£€æŸ¥ `std::weak_ptr` æ‰€å¼•ç”¨çš„å¯¹è±¡æ˜¯å¦å·²ç»è¢«é”€æ¯ã€‚å¦‚æœ `std::weak_ptr`
æ‰€å¼•ç”¨çš„å¯¹è±¡å·²ç»è¢«é”€æ¯ï¼Œåˆ™è¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

    
    
    bool expired() const noexcept
    { 
    	return _M_refcount._M_get_use_count() == 0; 
    }
    

å…·ä½“ `_M_get_use_count` æ–¹æ³•å†…å®¹ï¼Œ è¯·å‚è€ƒ **è·å–å¼•ç”¨è®¡æ•°** å‡½æ•°è§£æã€‚

###### è·å– `std::shared_ptr`

`lock` å‡½æ•°å°è¯•è·å–ä¸€ä¸ª `std::shared_ptr`ï¼ŒæŒ‡å‘ `std::weak_ptr` æ‰€å¼•ç”¨çš„å¯¹è±¡ã€‚å¦‚æœå¯¹è±¡ä»ç„¶å­˜åœ¨ï¼Œè¿”å›ä¸€ä¸ª
`std::shared_ptr`ï¼Œå…±äº«å¯¹è±¡çš„æ‰€æœ‰æƒï¼›å¦‚æœå¯¹è±¡å·²ç»è¢«é”€æ¯ï¼Œè¿”å›ä¸€ä¸ªç©ºçš„ `std::shared_ptr`ã€‚

    
    
    shared_ptr<_Tp> lock() const noexcept
    { 
    	return shared_ptr<_Tp>(*this, std::nothrow); 
    }
    

ç›´æ¥è°ƒç”¨äº† `std::shared_ptr` çš„æ„é€ å‡½æ•°ï¼Œç´§æ¥ç€åˆè°ƒç”¨äº† `__shared_ptr` çš„æ„é€ å‡½æ•°ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t) noexcept
        : __shared_ptr<_Tp>(__r, std::nothrow) { }
    

åœ¨è¯¥å‡½æ•°ä¸­ï¼Œé¦–å…ˆä» `__r` çš„å¼•ç”¨è®¡æ•°ä¸­åˆå§‹åŒ–å½“å‰ `std::shared_ptr`
çš„å¼•ç”¨è®¡æ•°ã€‚ç„¶åè®¾ç½®æ•°æ®æŒ‡é’ˆï¼Œå½“`_M_get_use_count` è¿”å›éé›¶å€¼ï¼ˆå³èµ„æºä»ç„¶å­˜åœ¨ï¼‰ï¼Œåˆ™ `_M_ptr` è¢«è®¾ç½®ä¸º
`__r._M_ptr`ï¼›å¦åˆ™å°±æ˜¯èµ„æºå·²ç»è¢«é”€æ¯ `_M_ptr` è¢«è®¾ç½®ä¸º `nullptr`ã€‚

    
    
    __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t) noexcept
    	: _M_refcount(__r._M_refcount, std::nothrow)
    {
    	_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
    }
    

###### é‡ç½®

`reset` å‡½æ•°å°† `std::weak_ptr` ç½®ä¸ºç©ºï¼Œè¡¨ç¤ºä¸å†å¼•ç”¨ä»»ä½•å¯¹è±¡ï¼Œå¹¶ä¸ä¼šå½±å“å¼•ç”¨è®¡æ•°ã€‚

    
    
    void reset() noexcept
    { 
    	__weak_ptr().swap(*this); 
    }
    

é¦–å…ˆè°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°åˆ›å»º `std::weak_ptr` å¯¹è±¡ï¼Œç„¶åè°ƒç”¨ `swap` å‡½æ•°è¿›è¡Œäº¤æ¢ã€‚

###### äº¤æ¢

`swap` å‡½æ•°ç”¨äºäº¤æ¢ä¸¤ä¸ª `std::weak_ptr` çš„å†…å®¹ï¼Œå¹¶ä¸ä¼šå½±å“å¼•ç”¨è®¡æ•°ã€‚

    
    
    void swap(__weak_ptr& __s) noexcept
    {
        std::swap(_M_ptr, __s._M_ptr);
        _M_refcount._M_swap(__s._M_refcount);
    }
    

è°ƒç”¨æ ‡å‡†åº“ä¸­çš„ `swap` å‡½æ•°äº¤æ¢åº•å±‚æ•°æ®æŒ‡é’ˆï¼Œç„¶åå†è°ƒç”¨ `_M_swap` å‡½æ•°äº¤æ¢å¼•ç”¨è®¡æ•°å™¨ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    void _M_swap(__weak_count& __r) noexcept
    {
        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
        __r._M_pi = _M_pi;
        _M_pi = __tmp;
    }
    

###### è·å–å¼•ç”¨è®¡æ•°

`use_count` å‡½æ•°è¿”å› `std::weak_ptr` æ‰€å¼•ç”¨çš„å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼Œè¡¨ç¤ºæœ‰å¤šå°‘ä¸ª `std::shared_ptr`
å…±äº«è¯¥å¯¹è±¡ï¼Œå¦‚æœå¯¹è±¡å·²ç»è¢«é”€æ¯ï¼Œè¿”å›0ã€‚

    
    
    long use_count() const noexcept
    { 
        return _M_refcount._M_get_use_count(); 
    }
    

åœ¨ `_M_get_use_count` å‡½æ•°ä¸­åˆ¤æ–­ `_M_pi` æ˜¯å¦ä¸º `nullptr` å¦‚æœä¸ºç©ºåˆ™è¡¨ç¤ºæ²¡æœ‰ç®¡ç†ä»»ä½•èµ„æºç›´æ¥è¿”å› 0ï¼›å¦åˆ™è°ƒç”¨
`_M_get_use_count` å‡½æ•°è·å–å¼•ç”¨è®¡æ•°å™¨çš„å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    long _M_get_use_count() const noexcept
    { 
        return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; 
    }
    

é€šè¿‡åŸå­æ“ä½œè·å–å…³è”çš„å¼ºå¼•ç”¨è®¡æ•°å™¨çš„å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

    
    
    long _M_get_use_count() const noexcept
    {
    	return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
    }
    

å…¶ä¸­ï¼Œ`__ATOMIC_RELAXED` æ˜¯æœ€å¼±çš„å†…å­˜é¡ºåºæ¨¡å‹ï¼Œä»…ä¿è¯æ“ä½œçš„åŸå­æ€§ï¼Œä¸æä¾›ä»»ä½•å†…å­˜é¡ºåºä¿è¯ã€‚

ğŸŒºğŸŒºğŸŒºæ’’èŠ±ï¼

å¦‚æœæœ¬æ–‡å¯¹ä½ æœ‰å¸®åŠ©ï¼Œå°±ç‚¹å…³æ³¨æˆ–è€…ç•™ä¸ªğŸ‘  
å¦‚æœæ‚¨æœ‰ä»»ä½•æŠ€æœ¯é—®é¢˜æˆ–è€…éœ€è¦æ›´å¤šå…¶ä»–çš„å†…å®¹ï¼Œè¯·éšæ—¶å‘æˆ‘æé—®ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/3734a0d4d24847a6ad83ea7ad3b1a2c6.png)



