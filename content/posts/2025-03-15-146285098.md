---
layout: post
title: "蓝桥杯刷题第十五届蓝桥杯大赛软件赛省赛CC-大学-B-组"
date: 2025-03-15 23:29:58 +0800
description: "蓝桥杯真题刷题——第十五届蓝桥杯大赛软件赛省赛C/C++ 大学 B 组"
keywords: "蓝桥杯刷题——第十五届蓝桥杯大赛软件赛省赛C/C++ 大学 B 组"
categories: ['蓝桥杯']
tags: ['蓝桥杯', 'C', 'C']
artid: "146285098"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146285098
    alt: "蓝桥杯刷题第十五届蓝桥杯大赛软件赛省赛CC-大学-B-组"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146285098
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146285098
cover: https://bing.ee123.net/img/rand?artid=146285098
image: https://bing.ee123.net/img/rand?artid=146285098
img: https://bing.ee123.net/img/rand?artid=146285098
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥杯刷题——第十五届蓝桥杯大赛软件赛省赛C/C++ 大学 B 组
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     一、
     <a href="https://www.lanqiao.cn/problems/19695/learning/" rel="nofollow" title="0握手问题 - 蓝桥云课">
      0握手问题 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="854" src="https://i-blog.csdnimg.cn/direct/c73eee3e056c497e926f21085a359157.png" width="567"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main()
{
    int sum=0;
    for(int i=49;i&gt;=7;i--)
        sum+=i;
    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
}</code></pre>
    <p>
     <strong>
      直接暴力，题意很清晰，累加即可。
     </strong>
    </p>
    <p>
    </p>
    <h2>
     二、
     <a href="https://www.lanqiao.cn/problems/19732/learning/" rel="nofollow" title="0小球反弹 - 蓝桥云课">
      0小球反弹 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="755" src="https://i-blog.csdnimg.cn/direct/fde92cd3cbe84b46a193d892c151bbbb.png" width="557"/>
    </p>
    <p class="img-center">
     <img alt="" height="417" src="https://i-blog.csdnimg.cn/direct/9f3c3798524e4b8cbac2c1b12bf83cc4.png" width="477"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include&lt;iostream&gt;  // 引入输入输出流库，用于标准输入输出操作
#include&lt;iomanip&gt;    // 引入输入输出操纵库，用于格式化输出（如设置小数点精度）
#include&lt;cmath&gt;      // 引入数学函数库，用于数学运算（如平方根）

using namespace std; // 使用标准命名空间，避免每次调用标准库函数时都要加std::

// 定义一个函数check，用于检查两个整数a和b是否满足特定条件
bool check(int a, int b) {
    // 如果a能被b整除，并且a除以b的结果是偶数，则返回true
    if (a % b == 0 &amp;&amp; (a / b) % 2 == 0) return true;
    return false;  // 否则返回false
}

// 主函数
int main() {
    long long x = 343720, y = 233333;  // 定义两个长整型变量x和y，并赋予初始值
    long long t = 1;  // 定义长整型变量t，并初始化为1
    long long lx, ly;  // 定义两个长整型变量lx和ly，用于存储计算过程中的临时值

    // 进入一个无限循环，直到满足特定条件时跳出循环
    while (1) {
        lx = 15 * t;  // 计算lx为15乘以t
        ly = 17 * t;  // 计算ly为17乘以t

        // 如果lx和x满足check函数的条件，且ly和y也满足check函数的条件，则跳出循环
        if (check(lx, x) &amp;&amp; check(ly, y)) break;

        t++;  // 否则，t自增1，继续循环
    }

    // 输出lx和ly的平方和的平方根，保留两位小数
    cout &lt;&lt; setprecision(2) &lt;&lt; fixed &lt;&lt; sqrt(lx * lx + ly * ly);

    return 0;  // 程序正常结束，返回0
}</code></pre>
    <h3>
     问题背景
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        小球运动
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         小球在长方形内以固定的速度比 dx:dy=15:17运动。
        </p>
       </li>
       <li>
        <p>
         当小球碰到长方形的边框时，会发生反弹（入射角等于反射角）。
        </p>
       </li>
       <li>
        <p>
         我们需要计算小球第一次回到起点时所经过的总路径长度。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        反弹的等效路径
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         反弹问题可以通过“镜像反射法”简化。将长方形无限复制，形成一个网格，小球的路径可以看作一条直线穿过这些镜像长方形。
        </p>
       </li>
       <li>
        <p>
         小球第一次回到起点，等价于这条直线第一次穿过一个镜像长方形的左上角顶点。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     数学分析
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        路径条件
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         小球在水平方向（长）移动的总距离必须是长方形长度 x=343720 的偶数倍。这是因为每次反弹都会改变方向，只有偶数倍才能让小球回到起点的水平位置。
        </p>
       </li>
       <li>
        <p>
         同理，小球在垂直方向（宽）移动的总距离必须是长方形宽度 y=233333 的偶数倍。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        公式推导
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         小球在水平方向的移动距离为 lx=15t。
        </p>
       </li>
       <li>
        <p>
         小球在垂直方向的移动距离为 ly=17t。
        </p>
       </li>
       <li>
        <p>
         为了满足回到起点的条件，必须同时满足：
        </p>
        lx=15t=2k⋅x（水平方向）ly=17t=2m⋅y（垂直方向）
        <p>
         其中 k 和 m 是正整数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        简化条件
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         我们需要找到最小的 t，使得 15t 是 x 的偶数倍，且 17t是 y的偶数倍。
        </p>
       </li>
       <li>
        <p>
         这等价于：
        </p>
        <p class="img-center">
         <img alt="" height="105" src="https://i-blog.csdnimg.cn/direct/73ba15546aba4d1ba29b837017660089.png" width="484"/>
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p class="img-center">
     <img alt="" height="146" src="https://i-blog.csdnimg.cn/direct/a01fe1bbfc11453db9a7def604739a6b.png" width="861"/>
    </p>
    <p>
     <code>
      setprecision(2)
     </code>
     是 C++ 标准库
     <code>
      &lt;iomanip&gt;
     </code>
     中的一个操纵符，用于设置浮点数输出的精度。具体来说，它控制输出流中浮点数的小数点后的位数。
    </p>
    <h3>
     详细解释
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         setprecision(n)
        </code>
       </strong>
       ：设置浮点数输出的小数点后的位数为
       <code>
        n
       </code>
       。例如，
       <code>
        setprecision(2)
       </code>
       表示输出浮点数时保留两位小数。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         fixed
        </code>
       </strong>
       ：与
       <code>
        setprecision
       </code>
       结合使用，表示使用固定小数格式输出。这意味着小数点后的位数是固定的，而不是科学计数法。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h2 style="background-color:transparent">
     三、
     <a href="https://www.lanqiao.cn/problems/19709/learning/" rel="nofollow" title="0好数 - 蓝桥云课">
      0好数 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="870" src="https://i-blog.csdnimg.cn/direct/b18817342d5144388968050518ee47f8.png" width="554"/>
    </p>
    <p class="img-center">
     <img alt="" height="681" src="https://i-blog.csdnimg.cn/direct/31e9bc08c1684f65af3d312c2107b190.png" width="554"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
    int n, i;
    scanf("%d", &amp;n);  // 输入一个整数 n
    for (; n &gt; 0; n--)  // 从 n 开始，递减到 1
    {
        for (int m = n; m &gt; 0;)  // 对每个数字 m = n，检查其每一位
        {
            if (m % 2 != 0) m /= 10;  // 如果最低位是奇数，去掉最低位
            else break;  // 如果最低位是偶数，退出循环
            if (m % 2 == 0) m /= 10;  // 如果新的最低位是偶数，去掉最低位
            else break;  // 如果新的最低位是奇数，退出循环
            if (m == 0) i++;  // 如果 m 变为 0，说明满足条件，计数器 i 增加
        }
    }
    printf("%d", i);  // 输出满足条件的数字的数量
    return 0;
}</code></pre>
    <p>
     <strong>
      题意清晰，直接一个一个数地循环递减，然后按规则，直接判断奇数位和偶数位是不是符合条件。
     </strong>
    </p>
    <p>
    </p>
    <h2>
     四、
     <a href="https://www.lanqiao.cn/problems/19710/learning/" rel="nofollow" title="0R 格式 - 蓝桥云课">
      0R 格式 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="806" src="https://i-blog.csdnimg.cn/direct/f1c9b4362dde438c81c19b33b2b7dfa8.png" width="570"/>
    </p>
    <p class="img-center">
     <img alt="" height="619" src="https://i-blog.csdnimg.cn/direct/33b916ef0880418c9139bbfb1f472397.png" width="557"/>
    </p>
    <h3>
     自己写的：算法代码（只能通过50%的测试用例）
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

// 快速幂函数，计算 2^n
ll fastPow(int n) {
    ll a = 2;  // 底数为 2
    ll sum = 1;  // 初始化 sum 为 1
    while (n) {
        if (n &amp; 1) {
            sum = sum * a;  // 如果当前位为 1，累乘到 sum
        }
        a = a * a;  // 底数平方
        n &gt;&gt;= 1;  // 右移一位
    }
    return sum;
}

int main() {
    int n;
    double d;
    cin &gt;&gt; n &gt;&gt; d;  // 输入 n 和 d
    ll ans = fastPow(n);  // 计算 2^n
    ll end_format = round(d * ans);  // 将 d 乘以 2^n 并四舍五入
    //round 函数用于对浮点数进行四舍五入操作
    printf("%lld\n", end_format);  // 输出结果
    return 0;
}</code></pre>
    <h3>
     罗勇军老师的几行代码（50%）（高下立判了属于是哈哈）算法代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{    
    long long n;    
    double s;    
    cin&gt;&gt;n&gt;&gt;s;    
    long long  a = 1&lt;&lt;n;    
    long long b= (long long)(a*s*1.0+0.5);//加0.5四舍五入    
    cout &lt;&lt; b;
}</code></pre>
    <h3 style="background-color:transparent">
     题解：
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;  // 包含所有标准库头文件
using namespace std;     // 使用标准命名空间

int main()
{
  int n;
  string d;    // 由于数字可能非常大，使用字符串来读取
  cin &gt;&gt; n &gt;&gt; d;  // 输入转换参数 n 和浮点数 d

  vector&lt;int&gt; b;  // 使用 vector 来存储数字的每一位，方便处理进位
  int sum = 0, k = 0;  // sum 用于记录总位数，k 用于记录小数点的位置

  // 从字符串末尾开始遍历，将字符转换为整数并存储到 vector 中
  for(int i = d.size() - 1; i &gt;= 0; i--)
  {
      if(d[i] != '.')
          b.push_back(d[i] - '0');  // 将字符转换为整数并存储
      else {
          k = sum;  // 记录小数点的位置
      }
      sum++;  // 记录总位数
  }

  int u = b.size();  // 记录当前数字的位数

  // 进行 n 次乘以 2 的操作
  while(n--)
  {
    int t = 0;  // t 用于记录进位
    for(int i = 0; i &lt; b.size(); i++)
    {
        b[i] = b[i] * 2 + t;  // 当前位乘以 2 并加上进位
        if(b[i] &gt;= 10)
        {
            t = b[i] / 10;  // 计算新的进位
            b[i] = b[i] % 10;  // 取余数作为当前位的值
        }
        else {
            t = 0;  // 如果没有进位，置为 0
        }
    }
    if(t)  // 如果最后还有进位，添加到 vector 中
        b.push_back(t);
  }

  u = b.size();  // 更新数字的位数

  int t = 1;  // 用于处理四舍五入的进位
  if(k &amp;&amp; b[k - 1] &gt;= 5)  // 如果需要四舍五入
  {
    for(int i = k; i &lt; u; i++)
    {
        b[i] = b[i] + 1;  // 当前位加 1
        if(b[i] &lt;= 9) {  // 如果不需要继续进位
            t = 0;
            break;
        }
        else {
            b[i] -= 10;  // 如果需要继续进位
        }
    }
    if(t)  // 如果最后还有进位，添加到 vector 中
        b.push_back(t);
  }

  // 从最高位开始输出结果，忽略小数部分
  for(int i = b.size() - 1; i &gt;= k; i--)
      cout &lt;&lt; b[i];

  return 0;  // 程序结束
}</code></pre>
    <h4>
     <strong>
      1. 输入处理
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        输入
       </strong>
       ：读取整数
       <code>
        n
       </code>
       和浮点数
       <code>
        d
       </code>
       。
      </p>
      <ul>
       <li>
        <p>
         <code>
          n
         </code>
         是转换参数，表示需要将浮点数乘以 2^n。
        </p>
       </li>
       <li>
        <p>
         <code>
          d
         </code>
         是待转换的浮点数，可能非常大，因此用字符串存储。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        目标
       </strong>
       ：将浮点数
       <code>
        d
       </code>
       转换为整数形式，方便后续计算。
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      2. 将浮点数转换为整数形式
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        遍历浮点数字符串
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         从字符串末尾开始遍历，将每个数字字符转换为整数，并存储到
         <code>
          vector&lt;int&gt; b
         </code>
         中。
        </p>
       </li>
       <li>
        <p>
         如果遇到小数点
         <code>
          .
         </code>
         ，记录小数点的位置
         <code>
          k
         </code>
         ，表示小数点后有
         <code>
          k
         </code>
         位。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          b
         </code>
         中存储的是浮点数
         <code>
          d
         </code>
         的整数形式（去掉小数点）。
        </p>
       </li>
       <li>
        <p>
         <code>
          k
         </code>
         记录了小数点的位置，用于后续四舍五入。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      3. 高精度乘以 2^n
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        循环乘以 2
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         进行
         <code>
          n
         </code>
         次乘以 2 的操作，每次操作都模拟高精度乘法。
        </p>
       </li>
       <li>
        <p>
         每次乘以 2 时，遍历
         <code>
          b
         </code>
         中的每一位，计算当前位乘以 2 并加上进位。
        </p>
       </li>
       <li>
        <p>
         如果当前位的结果大于等于 10，则计算进位，并将当前位的结果取余。
        </p>
       </li>
       <li>
        <p>
         如果最后还有进位，将其添加到
         <code>
          b
         </code>
         的末尾。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          b
         </code>
         中存储的是浮点数
         <code>
          d
         </code>
         乘以 2^n的结果，仍然是一个高精度整数。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      4. 四舍五入
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        判断是否需要四舍五入
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据小数点的位置
         <code>
          k
         </code>
         ，检查小数点后的第一位（即
         <code>
          b[k-1]
         </code>
         ）是否大于等于 5。
        </p>
       </li>
       <li>
        <p>
         如果大于等于 5，则需要进行四舍五入。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        四舍五入操作
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         从小数点位置开始，向高位逐位加 1，直到没有进位为止。
        </p>
       </li>
       <li>
        <p>
         如果最高位仍有进位，将其添加到
         <code>
          b
         </code>
         的末尾。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          b
         </code>
         中存储的是四舍五入后的最终结果。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      5. 输出结果
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        从最高位开始输出
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         从
         <code>
          b
         </code>
         的最高位开始，输出每一位数字。
        </p>
       </li>
       <li>
        <p>
         忽略小数部分（即小数点后的位数）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         输出的是浮点数
         <code>
          d
         </code>
         乘以 2^n 并四舍五入后的整数结果。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <strong>
      6. 代码的核心思想
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        高精度计算
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         由于浮点数和 2^n 可能非常大，普通数据类型无法存储，因此使用字符串和
         <code>
          vector&lt;int&gt;
         </code>
         来模拟高精度计算。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        逐位处理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         通过逐位遍历和进位处理，实现了高精度乘法和四舍五入。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        四舍五入
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         根据小数点后的第一位决定是否需要进位，模拟了四舍五入的过程。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <h2 style="background-color:transparent">
     五、
     <a href="https://www.lanqiao.cn/problems/19711/learning/" rel="nofollow" title="0宝石组合 - 蓝桥云课">
      0宝石组合 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="871" src="https://i-blog.csdnimg.cn/direct/8bc4316ae3ff44edae37e417829a9936.png" width="554"/>
    </p>
    <p class="img-center">
     <img alt="" height="721" src="https://i-blog.csdnimg.cn/direct/c67bee711e4a4d8781e8bbe69f529090.png" width="554"/>
    </p>
    <p style="background-color:transparent">
     <strong>
      （这道题我只会暴力，而且没拿到该拿的分，别提了，都是泪）
     </strong>
    </p>
    <h3 style="background-color:transparent">
     牛逼的题解：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;  // 包含所有标准库头文件

#define N 500010  // 定义常量 N，表示数组的最大大小

int gem[N], num[N];  // 定义两个数组：gem 用于存储输入的宝石编号，num 用于统计每种宝石的数量

int main() {
    int n;
    scanf("%d", &amp;n);  // 输入整数 n，表示宝石的数量

    int max = -0x3f3f3f3f;  // 初始化 max 为一个很小的值，用于记录宝石编号的最大值
    for (int i = 0; i &lt; n; i++) {
        scanf("%d", &amp;gem[i]);  // 输入每个宝石的编号
        num[gem[i]]++;  // 统计每种宝石的数量
        if (gem[i] &gt; max) max = gem[i];  // 更新宝石编号的最大值
    }

    // 从最大值开始，尝试找到满足条件的三个宝石
    for (int i = max; i &gt;= 1; i--) {  // i 是可能的公因数
        int tmp[3], pos = 0;  // tmp 用于存储符合条件的宝石编号，pos 用于记录 tmp 中的位置
        int cnt = 0;  // cnt 用于统计符合条件的宝石数量

        // 遍历所有 i 的倍数，检查是否存在对应的宝石
        for (int j = i; j &lt;= max; j += i) {  // j 是 i 的倍数
            if (num[j]) {  // 如果宝石 j 存在
                cnt += num[j];  // 统计宝石 j 的数量
                for (int k = 0; k &lt; num[j] &amp;&amp; pos &lt; 3; k++) {  // 将宝石 j 加入 tmp
                    tmp[pos++] = j;
                }
            }
            if (cnt == 3) break;  // 如果找到三个宝石，跳出循环
        }

        // 如果找到三个宝石，输出结果并结束程序
        if (cnt == 3) {
            for (int j = 0; j &lt; 3; j++) {
                printf("%d ", tmp[j]);  // 输出三个宝石的编号
            }
            break;  // 结束程序
        }
    }

    return 0;  // 程序结束
}</code></pre>
    <h3>
     代码思路：
    </h3>
    <p class="img-center">
     <img alt="" height="346" src="https://i-blog.csdnimg.cn/direct/c03e3220e1ea44209183d9576dba4581.png" width="886"/>
    </p>
    <p class="img-center">
     <img alt="" height="792" src="https://i-blog.csdnimg.cn/direct/92954f1097964e0987b034381f48f5e8.png" width="1020"/>
    </p>
    <p class="img-center">
     <img alt="" height="805" src="https://i-blog.csdnimg.cn/direct/299eea1f20554222bb9530ba9a01ef36.png" width="1044"/>
    </p>
    <p class="img-center">
     <img alt="" height="426" src="https://i-blog.csdnimg.cn/direct/53d2f98465c0464e8c3f61a18d5232a0.png" width="697"/>
    </p>
    <p>
    </p>
    <h2>
     六、
     <a href="https://www.lanqiao.cn/problems/19712/learning/" rel="nofollow" title="0数字接龙 - 蓝桥云课">
      0数字接龙 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="884" src="https://i-blog.csdnimg.cn/direct/e541937db79047b79cb9f207764d1ff9.png" width="554"/>
    </p>
    <p class="img-center">
     <img alt="" height="747" src="https://i-blog.csdnimg.cn/direct/95231bbe271a42ddb53311a39b00796f.png" width="555"/>
    </p>
    <p class="img-center">
     <img alt="" height="404" src="https://i-blog.csdnimg.cn/direct/20daf19011464b3d9ad406a486d50a6e.png" width="497"/>
    </p>
    <h3>
     题解代码：
    </h3>
    <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;  // 包含所有标准库头文件
using namespace std;

const int N = 11; // 定义棋盘的最大大小为11×11
int n, k; // n为棋盘大小，k为数字循环的范围
int g[N][N]; // 存储棋盘上的数字
int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1}; // 定义8个方向的x坐标偏移
int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1}; // 定义8个方向的y坐标偏移
string path; // 存储路径的方向编号
bool st[N][N]; // 标记棋盘上的格子是否被访问过
bool edge[N][N][N][N]; // 检查路径是否交叉

// 深度优先搜索函数，用于寻找路径
bool dfs(int a, int b) {
    // 如果到达右下角格子，检查路径长度是否为n*n-1（因为起点不计入路径）
    if (a == n - 1 &amp;&amp; b == n - 1)
        return path.size() == n * n - 1;

    st[a][b] = true; // 标记当前格子已访问
    for (int i = 0; i &lt; 8; i++) { // 遍历8个方向
        int x = a + dx[i], y = b + dy[i]; // 计算目标格子的坐标
        // 检查目标格子是否越界、是否访问过、数字是否满足循环序列要求
        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) continue;
        if (st[x][y]) continue;
        if (g[x][y] != (g[a][b] + 1) % k) continue;
        // 检查路径是否交叉（对于斜向移动，检查是否有反向的路径）
        if (i % 2 &amp;&amp; (edge[a][y][x][b] || edge[x][b][a][y])) continue;

        edge[a][b][x][y] = true; // 标记路径
        path += i + '0'; // 将方向编号加入路径
        if (dfs(x, y)) return true; // 递归搜索下一个格子
        path.pop_back(); // 回溯，移除路径中的最后一个方向
        edge[a][b][x][y] = false; // 回溯，取消路径标记
    }
    st[a][b] = false; // 回溯，取消当前格子的访问标记
    return false; // 如果所有方向都无法到达终点，返回false
}

int main() {
    cin &gt;&gt; n &gt;&gt; k; // 输入棋盘大小和数字循环范围
    for (int i = 0; i &lt; n; i++) // 读取棋盘上的数字
        for (int j = 0; j &lt; n; j++)
            cin &gt;&gt; g[i][j];

    // 从起点(0,0)开始搜索路径
    if (!dfs(0, 0))
        cout &lt;&lt; -1 &lt;&lt; endl; // 如果没有找到路径，输出-1
    else
        cout &lt;&lt; path &lt;&lt; endl; // 输出路径的方向编号序列

    return 0;
}</code></pre>
    <p class="img-center">
     <img alt="" height="567" src="https://i-blog.csdnimg.cn/direct/bec568edea234e56af7649971d701f08.png" width="755"/>
    </p>
    <p>
     <strong>
      罗勇军老师的分析：（有道理）
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="161" src="https://i-blog.csdnimg.cn/direct/e4cf46c38d954dc9aeb947fd64d63171.png" width="880"/>
    </p>
    <p>
    </p>
    <h2>
     七、
     <a href="https://www.lanqiao.cn/problems/19713/learning/" rel="nofollow" title="0拔河 - 蓝桥云课">
      0拔河 - 蓝桥云课
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="854" src="https://i-blog.csdnimg.cn/direct/cdd140649a134862a32bd6164fb44bb8.png" width="556"/>
    </p>
    <p class="img-center">
     <img alt="" height="731" src="https://i-blog.csdnimg.cn/direct/330ada349e174e4988771e0ff23ff730.png" width="555"/>
    </p>
    <p class="img-center">
     <img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/f94308e44e8e442eac08a941a6777f7f.png" width="877"/>
    </p>
    <h3>
     算法代码（20%暴力枚举）
    </h3>
    <pre><code class="language-cpp">//20%：暴力枚举
#include&lt;bits/stdc++.h&gt;  // 包含所有标准库头文件
using namespace std;     // 使用标准命名空间

const int N = 1e3 + 100;  // 定义常量 N，表示数组的最大大小
typedef long long ll;     // 定义 long long 类型的别名 ll
ll a[100];                // 定义数组 a，用于存储输入的数字

// 计算子数组和的函数
ll sum(int l, int r) {
    ll s = 0;             // 初始化子数组和为 0
    for (int i = l; i &lt;= r; i++)  // 遍历子数组的每个元素
        s += a[i];        // 累加子数组的元素
    return s;             // 返回子数组的和
}

int main() {
    int n;                // 定义整数 n，表示数组的大小
    cin &gt;&gt; n;             // 输入数组的大小 n

    for (int i = 1; i &lt;= n; i++)  // 遍历数组的每个位置
        cin &gt;&gt; a[i];       // 输入数组的每个元素

    ll ans = 1e12;         // 初始化答案为一个大值（1e12），用于存储最小绝对差

    // 暴力枚举所有可能的子数组对
    for (int l1 = 1; l1 &lt;= n; l1++) {        // 枚举第一个子数组的起始位置 l1
        for (int r1 = l1; r1 &lt;= n; r1++) {    // 枚举第一个子数组的结束位置 r1
            for (int l2 = r1 + 1; l2 &lt;= n; l2++) {  // 枚举第二个子数组的起始位置 l2
                for (int r2 = l2; r2 &lt;= n; r2++) {  // 枚举第二个子数组的结束位置 r2
                    // 计算两个子数组和的绝对差，并更新最小值
                    ans = min(ans, abs(sum(l2, r2) - sum(l1, r1)));
                }
            }
        }
    }

    cout &lt;&lt; ans;           // 输出最小绝对差
    return 0;              // 程序结束
}</code></pre>
    <h3>
     算法代码（40%暴力枚举+前缀和优化）
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;  // 包含所有标准库头文件
using namespace std;     // 使用标准命名空间

const int N = 1e3 + 100;  // 定义常量 N，表示数组的最大大小
typedef long long ll;     // 定义 long long 类型的别名 ll
ll a[N], prefix[N];       // 定义数组 a 和前缀和数组 prefix

// 计算子数组和的函数
ll sum(int l, int r) {
    return prefix[r] - prefix[l - 1];  // 返回子数组 [l, r] 的和
}

int main() {
    int n;                // 定义整数 n，表示数组的大小
    cin &gt;&gt; n;             // 输入数组的大小 n

    // 读取数组并计算前缀和
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];                // 输入数组的每个元素
        prefix[i] = prefix[i - 1] + a[i];  // 计算前缀和
    }

    ll ans = 1e12;         // 初始化答案为一个大值（1e12），用于存储最小绝对差

    // 枚举所有子数组对
    for (int l1 = 1; l1 &lt;= n; l1++) {        // 枚举第一个子数组的起始位置 l1
        for (int r1 = l1; r1 &lt;= n; r1++) {    // 枚举第一个子数组的结束位置 r1
            ll sum1 = sum(l1, r1);             // 计算第一个子数组的和
            for (int l2 = r1 + 1; l2 &lt;= n; l2++) {  // 枚举第二个子数组的起始位置 l2
                for (int r2 = l2; r2 &lt;= n; r2++) {  // 枚举第二个子数组的结束位置 r2
                    ll sum2 = sum(l2, r2);           // 计算第二个子数组的和
                    ans = min(ans, abs(sum2 - sum1));  // 更新最小绝对差
                }
            }
        }
    }

    cout &lt;&lt; ans;           // 输出最小绝对差
    return 0;              // 程序结束
}</code></pre>
    <p class="img-center">
     <img alt="" height="450" src="https://i-blog.csdnimg.cn/direct/d693429f5d114dcbbad1c7e5f417c9d0.png" width="706"/>
    </p>
    <h3>
     逆天题解：（真的想不出来，我是个只会暴力的fw）
    </h3>
    <p class="img-center">
     <img alt="" height="104" src="https://i-blog.csdnimg.cn/direct/4ebdefadec3840299f0588b68d3db91a.png" width="1175"/>
    </p>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;  // 包含所有标准库头文件
using namespace std;     // 使用标准命名空间

const int N = 1e3 + 10;  // 定义常量 N，表示数组的最大大小
long long a[N];          // 定义数组 a，用于存储前缀和
int n;                   // 定义整数 n，表示数组的大小
multiset&lt;long long&gt; s;   // 定义 multiset，用于存储所有可能的子数组和

// 自定义函数，返回两个数中的较小值
long long minn(long long a, long long b) {
    if (a &lt; b) return a;
    else return b;
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);  // 取消同步流，加速输入输出
    cin &gt;&gt; n;  // 输入数组的大小 n

    // 读取数组并构造前缀和
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
        a[i] += a[i - 1];  // 计算前缀和
    }

    // 枚举所有可能的子数组和，并将其插入 multiset
    for (int i = 1; i &lt;= n; i++) {
        for (int j = i; j &lt;= n; j++) {
            s.insert(a[j] - a[i - 1]);  // 计算子数组 [i, j] 的和，并插入 multiset
        }
    }

    long long res = 1e9;  // 初始化结果为一个大值（1e9），用于存储最小绝对差

    // 遍历所有可能的第一个区间的右端点 i
    for (int i = 1; i &lt; n; i++) {
        // 删除以 i 作为右端点的所有子数组和
        for (int j = i; j &lt;= n; j++) {
            auto k = a[j] - a[i - 1];  // 计算子数组 [i, j] 的和
            s.erase(s.find(k));        // 从 multiset 中删除该和
        }

        // 遍历所有可能的第一个区间的左端点 j
        for (int j = 1; j &lt;= i; j++) {
            auto k = a[i] - a[j - 1];  // 计算第一个子数组 [j, i] 的和

            // 在 multiset 中查找最接近 k 的值
            auto p = s.lower_bound(k);  // 找到第一个 &gt;= k 的值
            if (p != s.end()) {
                res = minn(res, abs(*p - k));  // 更新最小绝对差
            }
            if (p != s.begin()) {
                p--;  // 找到第一个 &lt; k 的值
                res = minn(res, abs(*p - k));  // 更新最小绝对差
            }
        }
    }

    cout &lt;&lt; res &lt;&lt; endl;  // 输出最小绝对差
    return 0;             // 程序结束
}</code></pre>
    <p class="img-center">
     <img alt="" height="714" src="https://i-blog.csdnimg.cn/direct/add4e9a63b084515a3cadcae099035b2.png" width="799"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436323835303938" class_="artid" style="display:none">
 </p>
</div>


