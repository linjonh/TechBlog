---
layout: post
title: "深入浅出-Elasticsearch-的-dense_vector-字段类型"
date: 2025-03-11 14:57:19 +0800
description: "在 Elasticsearch 中，dense_vector是一种专门用来存储和处理稠密向量（dense vectors）的字段类型。它特别适合需要进行k 近邻搜索（kNN）的场景，比如推荐系统、图像搜索或自然语言处理中的语义相似性计算。本文将带你从零开始了解dense_vector，包括它的定义、使用方式、索引选项以及一些实用技巧。让我们一步步拆解这块内容，用通俗的语言把复杂的概念讲明白..."
keywords: "深入浅出 Elasticsearch 的 dense_vector 字段类型"
categories: ['未分类']
tags: ['搜索引擎', '大数据', '全文检索', 'Jenkins', 'Elasticsearch']
artid: "146194328"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146194328
    alt: "深入浅出-Elasticsearch-的-dense_vector-字段类型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146194328
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146194328
cover: https://bing.ee123.net/img/rand?artid=146194328
image: https://bing.ee123.net/img/rand?artid=146194328
img: https://bing.ee123.net/img/rand?artid=146194328
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     深入浅出 Elasticsearch 的 dense_vector 字段类型
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div id="js_content">
     <p style="text-align:left;">
      在 Elasticsearch 中，
      <code>
       dense_vector
      </code>
      是一种专门用来存储和处理稠密向量（dense vectors）的字段类型。
     </p>
     <p style="text-align:left;">
      它特别适合需要进行
      <strong>
       k 近邻搜索（kNN）
      </strong>
      的场景，比如推荐系统、图像搜索或自然语言处理中的语义相似性计算。
     </p>
     <p style="text-align:center;">
      <img alt="aa2fc5efbfdf91952b381b9869ed6c87.jpeg" src="https://i-blog.csdnimg.cn/img_convert/aa2fc5efbfdf91952b381b9869ed6c87.jpeg"/>
     </p>
     <p style="text-align:left;">
      本文将带你从零开始了解
      <code>
       dense_vector
      </code>
      ，包括它的定义、使用方式、索引选项以及一些实用技巧。
     </p>
     <p style="text-align:left;">
      让我们一步步拆解这块内容，用通俗的语言把复杂的概念讲明白！
     </p>
     <hr/>
     <h3>
      1、什么是 dense_vector？
     </h3>
     <p style="text-align:left;">
      简单来说，
      <code>
       dense_vector
      </code>
      是一个字段类型，用来存储一组数字向量（比如
      <code>
       [0.5, 10, 6]
      </code>
      ），这些向量通常是机器学习模型生成的特征表示。它不像普通的字段类型（比如
      <code>
       keyword
      </code>
      或
      <code>
       text
      </code>
      ）那样支持聚合或排序，
     </p>
     <p style="text-align:left;">
      而是专为
      <strong>
       向量相似性搜索
      </strong>
      设计。
     </p>
     <p style="text-align:left;">
      在实际应用中，你可以用它来做 kNN 搜索，也就是找到与某个查询向量最相似的 k 个向量。
     </p>
     <p style="text-align:left;">
      这种搜索在推荐系统或语义匹配中非常常见。
     </p>
     <hr/>
     <h3>
      2、如何定义和使用 dense_vector？
     </h3>
     <h4>
      2.1 基本定义
     </h4>
     <p style="text-align:left;">
      在 Elasticsearch 中，添加一个
      <code>
       dense_vector
      </code>
      字段很简单。你需要指定它的维度（
      <code>
       dims
      </code>
      ），也就是向量中数字的个数。比如下面这个例子：
     </p>
     <pre class="has"><code class="language-go">PUT my-index
{
"mappings": {
    "properties": {
      "my_vector": {
        "type": "dense_vector",
        "dims": 3// 向量有 3 个维度
      },
      "my_text": {
        "type": "keyword"// 普通的文本字段
      }
    }
  }
}</code></pre>
     <p style="text-align:center;">
      <img alt="b75134dd4611432324423e6f3bb06bff.png" src="https://i-blog.csdnimg.cn/img_convert/b75134dd4611432324423e6f3bb06bff.png"/>
     </p>
     <p style="text-align:left;">
      这里我们定义了一个索引
      <code>
       my-index
      </code>
      ，
     </p>
     <ul>
      <li>
       <p style="text-align:left;">
        其中
        <code>
         my_vector
        </code>
        是
        <code>
         dense_vector
        </code>
        类型，维度是 3。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         dims
        </code>
        是必须指定的，最大不能超过 4096（注意：8.10 版本之前最大值 2048，8.10版本之后最大值 4096）。
       </p>
      </li>
     </ul>
     <h4>
      2.2 添加数据
     </h4>
     <p style="text-align:left;">
      定义好字段后，就可以往里面塞数据了。
     </p>
     <p style="text-align:left;">
      每个文档的
      <code>
       my_vector
      </code>
      字段只能存一个向量，不能存多个。比如：
     </p>
     <pre class="has"><code class="language-go">PUT my-index/_doc/1
{
  "my_text": "text1",
  "my_vector": [0.5, 10, 6]
}

PUT my-index/_doc/2
{
  "my_text": "text2",
  "my_vector": [-0.5, 10, 10]
}</code></pre>
     <p style="text-align:left;">
      注意，向量中的数字默认是浮点数（
      <code>
       float
      </code>
      ），而且长度必须和
      <code>
       dims
      </code>
      一致。
     </p>
     <p style="text-align:center;">
      <img alt="2d3ff62aa715baac803878538f74adb8.png" src="https://i-blog.csdnimg.cn/img_convert/2d3ff62aa715baac803878538f74adb8.png"/>
     </p>
     <p style="text-align:left;">
      这里我们用了 3 个数字，正好匹配定义的维度。
     </p>
     <hr/>
     <h3>
      3、kNN 搜索：让向量派上用场
     </h3>
     <p style="text-align:left;">
      <code>
       dense_vector
      </code>
      的核心用途是 kNN 搜索，也就是找到与查询向量最相似的 k 个文档。
     </p>
     <p style="text-align:left;">
      Elasticsearch 支持两种方式来实现：
     </p>
     <ol>
      <li>
       <p style="text-align:left;">
        <strong>
         暴力搜索（Brute-Force kNN）
        </strong>
        <br/>
        用
        <code>
         script_score
        </code>
        查询扫描所有文档，逐一计算相似度。这种方法简单，但数据量大时会很慢。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <strong>
         索引加速（Approximate kNN）
        </strong>
        <br/>
        通过给向量建立索引（默认启用），可以用专门的数据结构（比如 HNSW）加速搜索。索引后的向量可以通过
        <code>
         knn
        </code>
        选项在搜索 API 中快速检索。
       </p>
      </li>
     </ol>
     <h4>
      3.1 设置相似度
     </h4>
     <p style="text-align:left;">
      为了做 kNN 搜索，你需要告诉 Elasticsearch 如何衡量两个向量的相似度。
     </p>
     <p style="text-align:left;">
      可以用
      <code>
       similarity
      </code>
      参数指定，默认是
      <code>
       cosine
      </code>
      （余弦相似度）。
     </p>
     <p style="text-align:left;">
      比如：
     </p>
     <pre class="has"><code class="language-go">PUT my-index-2
{
  "mappings": {
    "properties": {
      "my_vector": {
        "type": "dense_vector",
        "dims": 3,
        "similarity": "dot_product"  // 用点积计算相似度
      }
    }
  }
}</code></pre>
     <p style="text-align:center;">
      <img alt="33510908f32efbfcc72a9e7486bec52e.png" src="https://i-blog.csdnimg.cn/img_convert/33510908f32efbfcc72a9e7486bec52e.png"/>
     </p>
     <p style="text-align:left;">
      支持的相似度选项包括：
     </p>
     <ul>
      <li>
       <p style="text-align:left;">
        <code>
         l2_norm
        </code>
        ：欧几里得距离
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         dot_product
        </code>
        ：点积
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         cosine
        </code>
        ：余弦相似度
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         max_inner_product
        </code>
        ：最大内积
       </p>
      </li>
     </ul>
     <p style="text-align:left;">
      每种方法适用于不同的场景，具体选哪个取决于你的数据和需求。
     </p>
     <h4>
      3.2 相似度选项的区别与适用场景
     </h4>
     <p style="text-align:left;">
      如前所述，Elasticsearch 的
      <code>
       dense_vector
      </code>
      字段支持四种相似度计算方式：
      <code>
       l2_norm
      </code>
      （欧几里得距离）、
      <code>
       dot_product
      </code>
      （点积）、
      <code>
       cosine
      </code>
      （余弦相似度）和
      <code>
       max_inner_product
      </code>
      （最大内积）。
     </p>
     <p style="text-align:center;">
      <img alt="6bdddb816d7885e4986aa5e989275c3e.png" src="https://i-blog.csdnimg.cn/img_convert/6bdddb816d7885e4986aa5e989275c3e.png"/>
     </p>
     <p style="text-align:left;">
      每种方法在向量比较时有不同的数学基础和适用场景，选择哪种主要取决于你的数据特性（如是否归一化）和应用需求（如是否重视向量长度）。
     </p>
     <p style="text-align:left;">
      下面通过一段话和一个表格来直观说明它们的区别与用途。
     </p>
     <p style="text-align:left;">
      简单来说：
     </p>
     <p style="text-align:left;">
      <code>
       l2_norm
      </code>
      适合需要精确衡量空间距离的场景，比如
      <strong>
       地理位置匹配
      </strong>
      ；
     </p>
     <p style="text-align:left;">
      <code>
       dot_product
      </code>
      适用于已归一化向量的高效余弦计算，或字节向量的高性能需求；
     </p>
     <p style="text-align:left;">
      <code>
       cosine
      </code>
      是语义相似性计算的首选，比如
      <strong>
       文本
      </strong>
      或
      <strong>
       图像特征匹配
      </strong>
      （所以，这个咱们用的多）；
     </p>
     <p style="text-align:left;">
      <code>
       max_inner_product
      </code>
      则在向量长度有意义时表现更好，比如
      <strong>
       某些推荐系统
      </strong>
      。
     </p>
     <h5>
      相似度选项对比表
     </h5>
     <table>
      <thead>
       <tr>
        <th>
         <p>
          相似度选项
         </p>
        </th>
        <th>
         <p>
          计算方式
         </p>
        </th>
        <th>
         <p>
          数据要求
         </p>
        </th>
        <th>
         <p>
          适用场景
         </p>
        </th>
        <th>
         <p>
          优点
         </p>
        </th>
        <th>
         <p>
          缺点
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <code>
          l2_norm
         </code>
        </td>
        <td>
         <p>
          欧几里得距离（L2 范数）
         </p>
        </td>
        <td>
         <p>
          无需归一化
         </p>
        </td>
        <td>
         <p>
          空间距离计算（如位置匹配）
         </p>
        </td>
        <td>
         <p>
          直观反映绝对距离
         </p>
        </td>
        <td>
         <p>
          对向量长度敏感
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <code>
          dot_product
         </code>
        </td>
        <td>
         <p>
          向量点积
         </p>
        </td>
        <td>
         <code>
          float
         </code>
         <p>
          需归一化，
          <code>
           byte
          </code>
          无要求
         </p>
        </td>
        <td>
         <p>
          高效余弦计算或字节向量相似性
         </p>
        </td>
        <td>
         <p>
          计算效率高
         </p>
        </td>
        <td>
         <p>
          对未归一化向量结果不稳定
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <code>
          cosine
         </code>
        </td>
        <td>
         <p>
          余弦相似度
         </p>
        </td>
        <td>
         <p>
          自动归一化（索引时处理）
         </p>
        </td>
        <td>
         <p>
          语义相似性（如文本、图像特征）
         </p>
        </td>
        <td>
         <p>
          只关注方向，忽略长度
         </p>
        </td>
        <td>
         <p>
          不适用零向量
         </p>
        </td>
       </tr>
       <tr>
        <td>
         <code>
          max_inner_product
         </code>
        </td>
        <td>
         <p>
          最大内积
         </p>
        </td>
        <td>
         <p>
          无需归一化
         </p>
        </td>
        <td>
         <p>
          推荐系统（长度有意义时）
         </p>
        </td>
        <td>
         <p>
          考虑方向和长度
         </p>
        </td>
        <td>
         <p>
          分数可能为负需调整
         </p>
        </td>
       </tr>
      </tbody>
     </table>
     <p style="text-align:left;">
      希望这能帮你快速选出合适的相似度方法！如果有具体案例，欢迎讨论。
     </p>
     <h4>
      3.3 关闭索引
     </h4>
     <p style="text-align:left;">
      如果不需要快速 kNN 搜索，可以关闭索引功能，节省资源：
     </p>
     <pre class="has"><code class="language-go">PUT my-index-2
{
  "mappings": {
    "properties": {
      "my_vector": {
        "type": "dense_vector",
        "dims": 3,
        "index": false  // 关闭索引
      }
    }
  }
}</code></pre>
     <p style="text-align:left;">
      关闭索引后，只能用暴力搜索方式查询。建议咱们慎用！！
     </p>
     <hr/>
     <h3>
      4、量化：内存和速度的平衡
     </h3>
     <p style="text-align:left;">
      索引向量虽然能加速搜索，但会占用不少内存。
     </p>
     <p style="text-align:left;">
      Elasticsearch 提供了
      <strong>
       量化（Quantization）
      </strong>
      来压缩向量，减少内存占用。
     </p>
     <p style="text-align:left;">
      支持三种量化策略：
     </p>
     <ol>
      <li>
       <p style="text-align:left;">
        <strong>
         int8
        </strong>
        <br/>
        每个维度用 1 字节整数表示，内存减少 75%（4 倍压缩），精度略有损失。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <strong>
         int4
        </strong>
        <br/>
        每个维度用半个字节（4 位），内存减少 87%（8 倍压缩），精度损失更大。要求维度是偶数。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <strong>
         bbq（实验功能）
        </strong>
        <br/>
        每个维度压缩到 1 位，内存减少 96%（32 倍压缩），精度损失最大，要求维度大于 64。可以用过采样和重排序来弥补。
       </p>
      </li>
     </ol>
     <p style="text-align:left;">
      设置量化很简单，比如用
      <code>
       int8_hnsw
      </code>
      ：
     </p>
     <pre class="has"><code class="language-go">PUT my-byte-quantized-index
{
"mappings": {
    "properties": {
      "my_vector": {
        "type": "dense_vector",
        "dims": 3,
        "index": true,
        "index_options": {
          "type": "int8_hnsw"// int8 量化 + HNSW 算法
        }
      }
    }
  }
}</code></pre>
     <p style="text-align:center;">
      <img alt="f0f9645e70002893d0fa76369609fd49.png" src="https://i-blog.csdnimg.cn/img_convert/f0f9645e70002893d0fa76369609fd49.png"/>
     </p>
     <p style="text-align:left;">
      量化后的向量会牺牲一些准确性，但可以通过调整查询时的参数（比如过采样）来提高结果质量。
     </p>
     <hr/>
     <h3>
      5、位向量（bit vectors）：超高维场景的利器
     </h3>
     <p style="text-align:left;">
      除了浮点数，
      <code>
       dense_vector
      </code>
      还支持
      <code>
       byte
      </code>
      和
      <code>
       bit
      </code>
      类型。
     </p>
     <p style="text-align:left;">
      其中
      <code>
       bit
      </code>
      类型特别适合
      <strong>
       超高维向量
      </strong>
      ，每个维度只用 1 位存储，极大节省空间。
     </p>
     <h4>
      5.1 定义位向量
     </h4>
     <pre class="has"><code class="language-go">PUT my-bit-vectors
{
  "mappings": {
    "properties": {
      "my_vector": {
        "type": "dense_vector",
        "dims": 40,  // 维度必须是 8 的倍数
        "element_type": "bit"
      }
    }
  }
}</code></pre>
     <p style="text-align:center;">
      <img alt="1faaa89f12b14d6b1f2127865df9d8a8.png" src="https://i-blog.csdnimg.cn/img_convert/1faaa89f12b14d6b1f2127865df9d8a8.png"/>
     </p>
     <h4>
      5.2 添加数据
     </h4>
     <p style="text-align:left;">
      可以用字节数组或十六进制字符串表示位向量：
     </p>
     <pre class="has"><code class="language-go">POST /my-bit-vectors/_bulk?refresh
{"index": {"_id": "1"}}
{"my_vector": [127, -127, 0, 1, 42]}
{"index": {"_id": "2"}}
{"my_vector": "8100012a7f"}</code></pre>
     <p style="text-align:center;">
      <img alt="9d2e38cee3ef841d2d1da16e48669133.png" src="https://i-blog.csdnimg.cn/img_convert/9d2e38cee3ef841d2d1da16e48669133.png"/>
     </p>
     <h4>
      5.3 搜索位向量
     </h4>
     <p style="text-align:left;">
      用
      <code>
       knn
      </code>
      查询搜索相似向量：
     </p>
     <pre class="has"><code class="language-go">POST /my-bit-vectors/_search?filter_path=hits.hits
{
  "query": {
    "knn": {
      "query_vector": [127, -127, 0, 1, 42],
      "field": "my_vector"
    }
  }
}</code></pre>
     <p style="text-align:center;">
      <img alt="e41d25e09eaa93d6378e56f5585dbd50.png" src="https://i-blog.csdnimg.cn/img_convert/e41d25e09eaa93d6378e56f5585dbd50.png"/>
     </p>
     <p style="text-align:left;">
      位向量的相似度用汉明距离（Hamming Distance）计算，分数越高表示越相似。
     </p>
     <hr/>
     <h3>
      6、参数详解
     </h3>
     <p style="text-align:left;">
      <code>
       dense_vector
      </code>
      支持以下几个关键参数：
     </p>
     <ul>
      <li>
       <p style="text-align:left;">
        <code>
         element_type
        </code>
        ：向量元素类型，默认
        <code>
         float
        </code>
        ，可选
        <code>
         byte
        </code>
        或
        <code>
         bit
        </code>
        。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         dims
        </code>
        ：维度数，最大 4096。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         index
        </code>
        ：是否启用索引，默认
        <code>
         true
        </code>
        。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         similarity
        </code>
        ：相似度计算方式，默认
        <code>
         cosine
        </code>
        。
       </p>
      </li>
      <li>
       <p style="text-align:left;">
        <code>
         index_options
        </code>
        ：索引算法配置，比如：
       </p>
       <ul>
        <li>
         <p style="text-align:left;">
          <code>
           type
          </code>
          ：算法类型（
          <code>
           hnsw
          </code>
          ,
          <code>
           int8_hnsw
          </code>
          ,
          <code>
           flat
          </code>
          等）。
         </p>
        </li>
        <li>
         <p style="text-align:left;">
          <code>
           m
          </code>
          ：HNSW 算法中每个节点的邻居数，默认 16。
         </p>
        </li>
        <li>
         <p style="text-align:left;">
          <code>
           ef_construction
          </code>
          ：构建时的候选数，默认 100。
         </p>
        </li>
       </ul>
      </li>
     </ul>
     <p style="text-align:left;">
      这些参数可以灵活调整，平衡准确性和性能。
     </p>
     <hr/>
     <h3>
      7、更新字段类型
     </h3>
     <p style="text-align:left;">
      Elasticsearch 支持通过
      <code>
       Update Mapping API
      </code>
      更新
      <code>
       index_options
      </code>
      的
      <code>
       type
      </code>
      ，比如从
      <code>
       flat
      </code>
      切换到
      <code>
       int4_hnsw
      </code>
      ：
     </p>
     <pre class="has"><code class="language-go">PUT my-index-000001/_mapping
{
  "properties": {
    "text_embedding": {
      "type": "dense_vector",
      "dims": 384,
      "index_options": {
        "type": "int4_hnsw"
      }
    }
  }
}</code></pre>
     <p style="text-align:left;">
      注意，更新不会影响已索引的数据，新数据才会用新类型。想让所有数据生效，可以重新索引或强制合并。
     </p>
     <hr/>
     <h3>
      8、总结
     </h3>
     <p style="text-align:left;">
      <code>
       dense_vector
      </code>
      是 Elasticsearch 中处理向量数据的强大工具。
     </p>
     <p style="text-align:left;">
      它支持灵活的定义、多种相似度计算方式，还能通过量化和索引优化性能。
     </p>
     <p style="text-align:left;">
      不管是简单的暴力搜索，还是复杂的近似 kNN 搜索，甚至超高维的位向量场景，
      <code>
       dense_vector
      </code>
      都能胜任。
     </p>
     <p style="text-align:left;">
      希望这篇博客能帮你快速上手
      <code>
       dense_vector
      </code>
      ！
     </p>
     <p style="text-align:left;">
      如果有疑问，欢迎留言讨论。
     </p>
     <h3>
      9、参考链接
     </h3>
     <ul>
      <li>
       <p style="text-align:left;">
        Elasticsearch 官方文档：Dense Vector Field Type
       </p>
       <ul>
        <li>
         <p style="text-align:left;">
          https://www.elastic.co/guide/en/elasticsearch/reference/current/dense-vector.html
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p style="text-align:left;">
        k-Nearest Neighbor (kNN) Search
       </p>
       <ul>
        <li>
         <p style="text-align:left;">
          https://www.elastic.co/guide/en/elasticsearch/reference/current/knn-search.html
         </p>
        </li>
       </ul>
      </li>
     </ul>
     <ol>
      <li>
       <p>
        <a href="" rel="nofollow">
         基于 Qwen2.5-14B + Elasticsearch RAG 的大数据知识库智能问答系统
        </a>
       </p>
       <p>
        <img alt="图片" src="https://i-blog.csdnimg.cn/img_convert/3d5516f393c566a10288b706eeb8d875.gif"/>
       </p>
      </li>
      <li>
       <p>
        <a href="" rel="nofollow">
         Elasticsearch 8.X “图搜图”实战
        </a>
       </p>
       <p>
        <img alt="图片" src="https://i-blog.csdnimg.cn/img_convert/0abd650916ee7aade2ce3d9a649f7c96.gif"/>
       </p>
      </li>
      <li>
       <p>
        <a href="" rel="nofollow">
         Elasticsearch 8.X 向量检索和普通检索能否实现组合检索？如何实现？
        </a>
       </p>
      </li>
      <li>
       <p>
        <a href="" rel="nofollow">
         Elasticsearch：普通检索和向量检索的异同？
        </a>
       </p>
      </li>
      <li>
       <p>
        <a href="" rel="nofollow">
         干货 | Elasticsearch 向量搜索的工程化实战
        </a>
       </p>
       <p style="text-align:center;">
        <img alt="图片" src="https://i-blog.csdnimg.cn/img_convert/f3ebe9c70359ae970b5d1b40ddb66b35.png"/>
       </p>
       <p style="text-align:center;">
        更短时间更快习得更多干货！
        <br/>
       </p>
       <p style="text-align:center;">
        和全球
        <strong>
         超
        </strong>
        2000+ Elastic 爱好者一起精进！
       </p>
       <p style="text-align:center;">
        <strong>
         elastic6.cn
        </strong>
        ——ElasticStack进阶助手
       </p>
       <p style="text-align:left;">
        <img alt="图片" src="https://i-blog.csdnimg.cn/img_convert/b55a8e5f113cda0cbcbfe0bcd7745ff6.gif"/>
       </p>
       <p style="text-align:left;">
        抢先一步学习进阶干货！
       </p>
      </li>
     </ol>
    </div>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f776f6a6975736869776f3938372f:61727469636c652f64657461696c732f313436313934333238" class_="artid" style="display:none">
 </p>
</div>


