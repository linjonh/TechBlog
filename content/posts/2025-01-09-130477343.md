---
layout: post
title: "Java中的互斥锁介绍"
date: 2025-01-09 16:30:00 +0800
description: "互斥锁是一种广泛应用于多线程编程中的并发控制机制。在Java中，互斥锁有很多不同的实现方式，在本文中"
keywords: "java互斥锁"
categories: ['并发编程']
tags: ['并发编程', '互斥锁', 'Java']
artid: "130477343"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=130477343
    alt: "Java中的互斥锁介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=130477343
featuredImagePreview: https://bing.ee123.net/img/rand?artid=130477343
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java中的互斥锁介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="_0">
     </a>
     前言
    </h3>
    <p>
     互斥锁是一种广泛应用于多线程编程中的并发控制机制。在Java中，互斥锁有很多不同的实现方式，在本文中我们将介绍Java中常见的几种互斥锁实现方式，并讲解它们的用法、原理和代码案例。
    </p>
    <h3>
     <a id="synchronized_4">
     </a>
     synchronized关键字
    </h3>
    <p>
     在Java中，采用
     <code>
      synchronized
     </code>
     关键字可以实现线程之间的互斥操作。具体来说，使用
     <code>
      synchronized
     </code>
     关键字可以保证同一时刻只有一个线程可以进入到临界区域（即加锁的代码块）执行。当一个线程访问某个对象的
     <code>
      synchronized
     </code>
     代码块或方法时，其他试图访问该对象的线程将会被阻塞，直到当前线程执行完这个代码块或方法并释放锁。
    </p>
    <p>
     <code>
      synchronized
     </code>
     关键字采用的是悲观锁机制，即在加锁的代码块或方法内部，系统默认认为其他线程会同时访问共享资源，因此需要加锁保护，以避免所谓的“脏数据”等情况。它的优点在于使用方便简单，缺点在于对于性能开销较大，而且只支持非公平锁。
    </p>
    <p>
     下面是
     <code>
      synchronized
     </code>
     关键字的一个示例代码：
    </p>
    <pre><code class="prism language-Java">public class SynchronizedDemo {
    public synchronized void synchronizedMethod() {
        // 临界区域
        // ...
    }
}
</code></pre>
    <h3>
     <a id="ReentrantLock_21">
     </a>
     ReentrantLock类
    </h3>
    <p>
     <code>
      ReentrantLock
     </code>
     类也是Java中的互斥锁实现方式之一，与
     <code>
      synchronized
     </code>
     不同的是，它提供了更加灵活的加锁和解锁机制。当一个线程获取了
     <code>
      ReentrantLock
     </code>
     实例的锁后，可以重复多次进入到临界区域执行，而不必像
     <code>
      synchronized
     </code>
     一样一次性获得或释放所有的锁。
    </p>
    <p>
     <code>
      ReentrantLock
     </code>
     提供了两种锁模式：公平锁和非公平锁。公平锁采用先进先出的机制，即等待时间最长的线程将获取到锁，这样可以保证所有线程在竞争资源时具有相同的机会。而非公平锁则允许线程由于优先级等因素插队获取锁，这样可能会导致某些线程长时间无法获取锁，从而造成饥饿现象。
    </p>
    <p>
     下面是
     <code>
      ReentrantLock
     </code>
     类的一个示例代码：
    </p>
    <pre><code class="prism language-Java">public class ReentrantLockDemo {
    private final ReentrantLock lock = new ReentrantLock();

    public void reentrantLockMethod() {
        lock.lock();
        try {
            // 临界区域
            // ...
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
    <h3>
     <a id="Semaphore_45">
     </a>
     Semaphore类
    </h3>
    <p>
     <code>
      Semaphore
     </code>
     是Java中另一种常见的互斥锁实现方式，它可以控制同时访问某个资源的线程数量，并允许多个线程同时访问同一个资源。
     <code>
      Semaphore
     </code>
     内部维护了一个计数器，用于记录当前可用的许可证数量，当线程需要获取许可证时，会调用
     <code>
      acquire()
     </code>
     方法进行等待，当许可证可用时，才能获取到许可证并执行相应的操作，执行完毕后需要调用
     <code>
      release()
     </code>
     方法释放许可证。
    </p>
    <p>
     <code>
      Semaphore
     </code>
     在一些场景下非常适用，例如必须限制某一资源的并发访问数量时。它也可以用来控制线程池中任务的数量，限制同时执行的任务数量。
    </p>
    <p>
     下面是
     <code>
      Semaphore
     </code>
     类的一个示例代码：
    </p>
    <pre><code class="prism language-Java">public class SemaphoreDemo {
    private final Semaphore semaphore = new Semaphore(1);

    public void semaphoreMethod() throws InterruptedException {
        try {
            semaphore.acquire();
            // 临界区域
            // ...
        } finally {
            semaphore.release();
        }
    }
}
</code></pre>
    <h3>
     <a id="ReadWriteLock_69">
     </a>
     ReadWriteLock接口
    </h3>
    <p>
     <code>
      ReadWriteLock
     </code>
     接口是Java中提供的读写锁机制，它允许多个线程同时读取共享资源，但只允许一个线程进行写操作。
     <code>
      ReadWriteLock
     </code>
     接口包含两个锁对象：读锁和写锁，读锁可以被多个线程同时获取，但写锁必须独占。当有线程持有写锁时，其他线程无法获得读锁或写锁，直到该线程释放写锁。
    </p>
    <p>
     <code>
      ReadWriteLock
     </code>
     适用于读操作频繁而写操作较少的场景，它可以提高系统的并发读取性能并保证数据一致性。例如，在某些场景下，我们需要将一些数据从数据库缓存到内存中，这些数据在内存中是只读的，可以使用
     <code>
      ReadWriteLock
     </code>
     来实现，以保证数据安全和性能。
    </p>
    <p>
     下面是
     <code>
      ReadWriteLock
     </code>
     接口的一个示例代码：
    </p>
    <pre><code class="prism language-Java">public class ReadWriteLockDemo {
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock readLock = readWriteLock.readLock();
    private final Lock writeLock = readWriteLock.writeLock();
    private String data;

    public String readData() {
        readLock.lock();
        try {
            return data;
        } finally {
            readLock.unlock();
        }
    }

    public void writeData(String newData) {
        writeLock.lock();
        try {
            data = newData;
        } finally {
            writeLock.unlock();
        }
    }
}
</code></pre>
    <p>
     以上就是Java中常见的互斥锁实现方式及其用法、原理和代码案例介绍。在实际应用中，选择合适的互斥锁实现方式可以提高程序的并发性能和稳定性，需要结合具体场景进行选择和使用。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f6a6176615f6370705f2f:61727469636c652f64657461696c732f313330343737333433" class_="artid" style="display:none">
 </p>
</div>


