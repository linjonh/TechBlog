---
layout: post
title: "RabbitMQ之旅2"
date: 2025-03-11 18:49:33 +0800
description: "在配置类中，可以使用。"
keywords: "RabbitMQ之旅(2)"
categories: ['未分类']
tags: ['Rabbitmq', 'Rabbitmq', 'Java']
artid: "146155281"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146155281
    alt: "RabbitMQ之旅2"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146155281
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146155281
cover: https://bing.ee123.net/img/rand?artid=146155281
image: https://bing.ee123.net/img/rand?artid=146155281
img: https://bing.ee123.net/img/rand?artid=146155281
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ之旅(2)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <strong>
        相信自
       </strong>
       <strong>
        己,终会成功
       </strong>
      </span>
     </p>
     <p style="text-align:center">
      <span style="color:#fe2c24">
       <img alt="" height="359" src="https://i-blog.csdnimg.cn/direct/c089ed3a0b0a4cc5a7e42e9f401a7235.jpeg" width="287"/>
      </span>
     </p>
    </blockquote>
    <hr/>
    <h3 id="Spring%E8%BF%9E%E6%8E%A5RabbitMQ" name="Spring%E8%BF%9E%E6%8E%A5RabbitMQ">
     Spring连接RabbitMQ
    </h3>
    <h4 id="1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" name="1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">
     1.引入依赖
    </h4>
    <pre><code class="language-java">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
    <h4 id="2.%E9%85%8D%E7%BD%AErabbitmq" name="2.%E9%85%8D%E7%BD%AErabbitmq">
     2.配置rabbitmq
    </h4>
    <p>
     在yml中配置
    </p>
    <pre><code class="language-java">spring:
#  application:
#    name=rabbit-extensions-demo
  rabbitmq:
    addresses: amqp://用户名:密码@云服务器IP地址:5672/虚拟主机
    listener:
      simple:
        #        acknowledge-mode: none  #消息接收确认
        #        acknowledge-mode: auto  #消息接收确认
        acknowledge-mode: manual  #消息接收确认
        prefetch: 1  #预取数量
        retry:
          enabled: true # 开启消费者失败重试
          initial-interval: 5000ms # 初始失败等待时长为5秒
          max-attempts: 5 # 最大重试次数
  #    publisher-confirm-type: correlated   #消息发送确认
</code></pre>
    <p>
     <strong>
      <code>
       properties
      </code>
     </strong>
     配置
    </p>
    <pre><code>spring.rabbitmq.host=云服务器IP地址
spring.rabbitmq.port=5672
spring.rabbitmq.username=用户名
spring.rabbitmq.password=密码</code></pre>
    <h4 id="3.%E7%94%9F%E4%BA%A7%E8%80%85(%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F)" name="3.%E7%94%9F%E4%BA%A7%E8%80%85(%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F)">
     3.生产者(简单模式)
    </h4>
    <p>
     声明队列和交换机(使用Spring AMQP中的
     <code>
      QueueBuilder
     </code>
     和
     <code>
      ExchangeBuilder
     </code>
     )
    </p>
    <pre><code class="language-java">
//声明常量
public class Constants {
    public static final String ACK_QUEUE = "ack.queue";

    public static final String ACK_EXCHANGE = "ack.exchange";

}
</code></pre>
    <pre><code class="language-java">    
@Configuration
public class RabbitMQConfig {

//声明队列
    @Bean("ackQueue")
    public Queue ackQueue(){
        return QueueBuilder.durable(Constants.ACK_QUEUE).build();
    }
//声明交换机
    @Bean("directExchange")
    public DirectExchange directExchange(){
        return ExchangeBuilder.directExchange(Constants.ACK_EXCHANGE).build();
    }


//    将队列绑定到交换机，并指定路由键（Routing Key）
//    @Bean("ackBinding")
//    public Binding ackBinding(Exchange directExchange, Queue queue){
//        return BindingBuilder.bind(queue).to(directExchange).with("ack").noargs();
//    }

//  将队列绑定到交换机，并指定路由键（Routing Key）
//  directExchange 的类型是 DirectExchange，这是一个具体的交换机类型。
    @Bean("ackBinding")
    public Binding ackBinding(@Qualifier("directExchange") DirectExchange directExchange, @Qualifier("ackQueue") Queue queue){
        return BindingBuilder.bind(queue).to(directExchange).with("ack");
    }
}

//   BindingBuilder.bind(queue).to(directExchange).with("ack");

//   这里没有调用 noargs()，因为 DirectExchange 的绑定不需要额外的参数。

//   由于 directExchange 是 DirectExchange 类型，这段代码明确指定了交换机的类型，适用于 Direct 类型的交换机。</code></pre>
    <blockquote>
     <ul>
      <li>
       BindingBuilder.bind(queue).to(directExchange).with("ack")
      </li>
      <li>
       <code>
        bind(queue)
       </code>
       ：指定要绑定的队列
      </li>
      <li>
       <code>
        t
       </code>
       <code>
        o(directExchange)
       </code>
       ：指定要绑定的交换机
      </li>
      <li>
       <code>
        with("ack")
       </code>
       ：指定路由键（Routing Key）
      </li>
      <li>
       <code>
        noargs()
       </code>
       ：表示不设置额外的绑定参数（可选）。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      <code>
       @Configuration在类方法上面的注解
      </code>
     </strong>
    </p>
    <p>
     <strong>
      作用定义 Bean
     </strong>
     ：在配置类中，可以使用
     <code>
      @Bean
     </code>
     注解来定义 Spring 容器管理的 Bean。
     <strong>
      替代 XML 配置
     </strong>
     ：
     <code>
      @Configuration
     </code>
     注解是 Java 配置的方式，可以完全替代传统的 XML 配置文件。
     <strong>
      模块化配置
     </strong>
     ：可以将不同的配置分散到多个配置类中，便于管理和维护。
    </p>
    <blockquote>
     <p>
      <strong>
       <code>
        @Configuration
       </code>
       与
       <code>
        @Bean
       </code>
       的关系
      </strong>
     </p>
     <p>
      <code>
       @Configuration
      </code>
      类中的
      <code>
       @Bean
      </code>
      方法会被 Spring 拦截，确保每次调用返回的是同一个 Bean 实例（单例模式）。如果去掉
      <code>
       @Configuration
      </code>
      注解，
      <code>
       @Bean
      </code>
      方法将不会被 Spring 代理，每次调用都会返回一个新的实例。
     </p>
     <p>
      <strong>
       <code>
        @Configuration
       </code>
       与
       <code>
        @Component
       </code>
       的区别
      </strong>
     </p>
     <p>
      <strong>
       <code>
        @Configuration
       </code>
      </strong>
      ：用于定义配置类，通常包含
      <code>
       @Bean
      </code>
      注解的方法，用于显式定义 Bean。
      <strong>
       <code>
        @Component
       </code>
      </strong>
      ：用于标记普通的组件类（如 Service、Repository 等），Spring 会自动扫描并注册为 Bean。
     </p>
    </blockquote>
    <p>
     <img alt="" height="127" src="https://i-blog.csdnimg.cn/direct/03d490110b5c4b46ae7f50c4f13dd2b1.png" width="427"/>
    </p>
    <p>
     <strong>
      指定一个接口,接口的 value 元素可用于在使用注释时传递特定值
     </strong>
    </p>
    <p>
     指定调用路径
    </p>
    <pre><code class="language-java">    @Resource(name="rabbitTemplate")
    private RabbitTemplate rabbitTemplate;

    @RequestMapping("/ack")
    public String ack() {
        rabbitTemplate.convertAndSend(Constants.ACK_EXCHANGE, "ack", "consumer ack mode test...");
        return "消息发送成功";
    }</code></pre>
    <p>
     <strong>
      <code>
       @Resource
      </code>
     </strong>
     是 Java 的注解，用于依赖注入 .
     <strong>
      <code>
       name="rabbitTemplate"
      </code>
     </strong>
     表示注入一个名为
     <code>
      rabbitTemplate
     </code>
     的 Bean。
     <strong>
      <code>
       RabbitTemplate
      </code>
      对象
     </strong>
     <span style="color:#fe2c24">
      ，它是 Spring AMQP 提供的一个工具类，用于与 RabbitMQ 进行交互（发送和接收消息）
     </span>
     。
     <strong>
      <code>
       convertAndSend
      </code>
      是
      <code>
       RabbitTemplate
      </code>
     </strong>
     的一个方法，用于将消息发送到指定的交换器
    </p>
    <pre><code class="language-java">   public void convertAndSend(String exchange, String routingKey, Object object) throws AmqpException {
        this.convertAndSend(exchange, routingKey, object, (CorrelationData)null);
    }
//String exchange交换机的名字
//String routingKey 指定的路由键,决定消息是如何从路由器到队列
//Object object 指定发送的内容</code></pre>
    <p>
     <strong>
      <code>
       QueueBuilder.durable(Constants.ACK_QUEUE).build()
      </code>
     </strong>
     ：
    </p>
    <p>
     使用
     <code>
      QueueBuilder
     </code>
     创建一个持久化的队列。
     <code>
      durable(true)
     </code>
     表示队列是持久化的，即使 RabbitMQ 服务器重启，队列也不会丢失。
     <code>
      Constants.ACK_QUEUE
     </code>
     是一个常量，表示队列的名称。
    </p>
    <p>
     <strong>
      <code>
       ExchangeBuilder.directExchange(Constants.ACK_EXCHANGE).build()
      </code>
     </strong>
     ：
    </p>
    <p>
     使用
     <code>
      ExchangeBuilder
     </code>
     创建一个直连交换机（Direct Exchange）。
     <code>
      Constants.ACK_EXCHANGE
     </code>
     是一个常量，表示交换机的名称。
    </p>
    <hr/>
    <h4 id="%40Bean%C2%A0%E5%B0%86%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%A4%E7%BB%99%20Spring%20%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86" name="%40Bean%C2%A0%E5%B0%86%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%A4%E7%BB%99%20Spring%20%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86">
     <strong>
      @Bean
     </strong>
     <strong>
      将方法的返回值交给 Spring 容器管理
     </strong>
    </h4>
    <h4 id="%E4%BD%9C%E7%94%A8" name="%E4%BD%9C%E7%94%A8">
     作用
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        将对象交给 Spring 管理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         被
         <code>
          @Bean
         </code>
         注解标记的方法，其返回值会被 Spring 容器注册为一个 Bean。
        </p>
       </li>
       <li>
        <p>
         这个 Bean 可以被其他组件（如
         <code>
          @Autowired
         </code>
         ）注入和使用。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        控制 Bean 的生命周期
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         Spring 容器会管理 Bean 的创建、初始化、销毁等生命周期。
        </p>
       </li>
       <li>
        <p>
         可以通过
         <code>
          @Bean
         </code>
         的
         <code>
          initMethod
         </code>
         和
         <code>
          destroyMethod
         </code>
         属性指定初始化和销毁方法。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        自定义 Bean 的名称
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         默认情况下，Bean 的名称是方法名。
        </p>
       </li>
       <li>
        <p>
         可以通过
         <code>
          @Bean("自定义名称")
         </code>
         指定 Bean 的名称。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4 id="4.%E6%B6%88%E8%B4%B9%E8%80%85" name="4.%E6%B6%88%E8%B4%B9%E8%80%85">
     4.消费者
    </h4>
    <pre><code class="language-java">@Configuration
public class AckListerner {
//@RabbitListener 表示是一个消息监听器,在这个代码中表示监听Constants.ACK_QUEUE
    @RabbitListener(queues = Constants.ACK_QUEUE)
    public void handMessage(Message message, Channel channel) throws IOException {
//每次从队列中消费一条消息时，RabbitMQ都会为该消息分配一个唯一的deliveryTag。
        long deliveryTag = message.getMessageProperties().getDeliveryTag();
        try {
            //消费者逻辑
            System.out.printf("接收到消息: %s, deliveryTag: %d \n", new String(message.getBody(),"UTF-8"), message.getMessageProperties().getDeliveryTag());

            //进行业务逻辑处理
            System.out.println("业务逻辑处理");
            System.out.println("业务处理完成");

//            这是对消息的肯定确认（acknowledgment），表示消息已经被成功处理。
//            deliveryTag指定要确认的消息。
//            false表示不进行批量确认，只确认当前消息。
            channel.basicAck(deliveryTag,false);
        } catch (Exception e) {
           
//            deliveryTag指定要否定的消息。
//            false表示不进行批量否定确认。
//            true表示将消息重新放回队列，以便稍后重新处理。
            channel.basicNack(deliveryTag, false, true);
        }
    }

}</code></pre>
    <h4 id="5.%E6%B5%8B%E8%AF%95" name="5.%E6%B5%8B%E8%AF%95">
     5.测试
    </h4>
    <p>
     <img alt="" height="164" src="https://i-blog.csdnimg.cn/direct/46706364883645af8f2224a54461524b.png" width="453"/>
    </p>
    <p>
    </p>
    <p>
     在RabbitMQ可视化界面中可以看到新建的交换机和队列
    </p>
    <p>
     <img alt="" height="43" src="https://i-blog.csdnimg.cn/direct/451a6bd66a484a5ba1bfc72d2dc0ab8e.png" width="507"/>
    </p>
    <p>
     <img alt="" height="35" src="https://i-blog.csdnimg.cn/direct/0acb6f927a014385b3919a115c52ff5d.png" width="632"/>
    </p>
    <p>
     <img alt="" height="303" src="https://i-blog.csdnimg.cn/direct/acba10d3297640af9d733c27c6970c07.png" width="329"/>
    </p>
    <p>
     <img alt="" height="32" src="https://i-blog.csdnimg.cn/direct/6c41df2b0d6748419e76239c8781a3c8.png" width="443"/>
    </p>
    <p>
     deliverytag正常从1开始,因为先演示的生产者,队列中存在一条数据,重新启动程序后,消费者自动消费了数据,但是因为我没截图,只好重新发送一条
    </p>
    <p>
     消费成功后的队列
    </p>
    <p>
     <img alt="" height="34" src="https://i-blog.csdnimg.cn/direct/74ef2056c45a48d8a35183fc83b7d956.png" width="569"/>
    </p>
    <hr/>
    <h3 id="%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6(%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E7%9A%84%E7%A1%AE%E8%AE%A4%E8%A1%8C%E4%B8%BA)" name="%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6(%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E7%9A%84%E7%A1%AE%E8%AE%A4%E8%A1%8C%E4%B8%BA)">
     消息确认机制(用于控制消息的确认行为)
    </h3>
    <p>
     Spring提供的AcknowledgeMode
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       AcknowledgeMode.NONE
      </strong>
     </span>
    </p>
    <p>
     <strong>
      这种
     </strong>
     <span style="color:null">
      <strong>
       模式下
      </strong>
     </span>
     <strong>
      ,消息一旦投递给消费者,不管消费者是否成功处理了消息,RabbitMQ就会自动确认消息,从Rabbit MQ队列中移除消息,如果消费者处理消息失效,消息可能会丢失
     </strong>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       AcknowledgeMode.AUTO(默认)
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
       这种模式下,消费者在消息处理成功时会自动确认消息,但如果处理过程中抛出了异常,则不会确认消息
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       AcknowledgeMode.MANUAL
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
       这种模式下,消费者必须在成功处理消息后显式调用basicAck方法来确认消息,如果消息未被确认,RabbitMQ会认为消息尚未被成功处理,并且会在消费者可用时重新投递该消息,这种模式提供了消息处理的可靠性,因为即使消费者处理消息后失败,消息也不会丢失,而是可以被重新处理
      </strong>
     </span>
    </p>
    <hr/>
    <h4 id="%E6%8C%81%E4%B9%85%E6%80%A7" name="%E6%8C%81%E4%B9%85%E6%80%A7">
     <span style="color:null">
      <strong>
       持久性
      </strong>
     </span>
    </h4>
    <p>
     <span style="color:null">
      <strong>
       交换机持久化
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="143" src="https://i-blog.csdnimg.cn/direct/3bb7ff643dde4c0b997f10d0ce37edd4.png" width="676"/>
    </p>
    <p>
     <span style="color:null">
      <strong>
       队列持久化
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="246" src="https://i-blog.csdnimg.cn/direct/344471ad30114afd990f5f42497bb573.png" width="493"/>
    </p>
    <p>
     <strong>
      消息的持久化
     </strong>
    </p>
    <p>
     <strong>
      消息是存储在队列中,所以消息的持久化,需要队列持久化+消息持久化
     </strong>
    </p>
    <p>
     <strong>
      如果只设置了队列持久化,MQ重启后,消息就会丢失
     </strong>
    </p>
    <p>
     <strong>
      如果只设置了消息的持久化,MQ重启后,队列会丢失,消息也会丢失
     </strong>
    </p>
    <pre><code class="language-java">//消息非持久化
        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);
//消息持久化
//        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
</code></pre>
    <ul>
     <li>
      <p>
       <code>
        getMessageProperties()
       </code>
       ：获取消息的属性对象（
       <code>
        MessageProperties
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         MessageDeliveryMode.PERSISTENT
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         消息会被持久化到磁盘。
        </p>
       </li>
       <li>
        <p>
         即使 RabbitMQ 服务器重启，消息也不会丢失。
        </p>
       </li>
       <li>
        <p>
         适用于需要确保消息不丢失的场景。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         MessageDeliveryMode.NON_PERSISTENT
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         消息不会被持久化到磁盘，仅存储在内存中。
        </p>
       </li>
       <li>
        <p>
         如果 RabbitMQ 服务器重启，消息会丢失。
        </p>
       </li>
       <li>
        <p>
         适用于对消息可靠性要求不高的场景，性能更高。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px">
     <tbody>
      <tr>
       <td>
       </td>
       <td>
        队列/交换机
       </td>
       <td>
        队列/消息(交换机默认持久化)
       </td>
      </tr>
      <tr>
       <td>
        持久化/持久化
       </td>
       <td>
        都不会消失
       </td>
       <td>
        都不会消失
       </td>
      </tr>
      <tr>
       <td>
        非持久化/非持久化
       </td>
       <td>
        都会消失
       </td>
       <td>
        都消失
       </td>
      </tr>
      <tr>
       <td>
        持久化/非持久化
       </td>
       <td>
        都不会消失
       </td>
       <td>
        队列不会消失,消息会消失
       </td>
      </tr>
      <tr>
       <td>
        非持久化/持久化
       </td>
       <td>
        都消失
       </td>
       <td>
        都消失
       </td>
      </tr>
     </tbody>
    </table>
    <h4 id="%E5%8F%91%E9%80%81%E6%96%B9%E7%A1%AE%E8%AE%A4" name="%E5%8F%91%E9%80%81%E6%96%B9%E7%A1%AE%E8%AE%A4">
     发送方确认
    </h4>
    <p>
     在 RabbitMQ 中，
     <strong>
      发送方确认（Publisher Confirms）
     </strong>
     是一种确保消息成功到达 RabbitMQ 服务器的机制。通过启用发送方确认，生产者可以知道消息是否被 RabbitMQ 成功接收。如果消息未被接收，生产者可以进行重试或其他处理。
    </p>
    <p>
     <strong>
      生产者发送消息到 RabbitMQ 服务器。RabbitMQ 服务器接收消息后，会向生产者发送一个确认（ack）或未确认（nack）的信号。生产者通过回调方法处理确认或未确认的信号。
     </strong>
    </p>
    <p>
     1.confirm模式
    </p>
    <p>
     通常在计算机编程、系统交互或业务流程等场景中，confirm 模式指的是一种确认机制。
    </p>
    <pre><code class="language-java">public String confirm() {
        CorrelationData correlationData = new CorrelationData("1");
        confirmRabbitTemplate.convertAndSend(Constants.CONFIRM_EXCHANGE, "confirm111", "confirm test...", correlationData);
        return "消息发送成功";
    }
</code></pre>
    <blockquote>
     <p>
      <strong>
       CorrelationData 的作用
      </strong>
     </p>
     <p>
      <code>
       CorrelationData("1")
      </code>
      ：初始化
      <code>
       CorrelationData
      </code>
      ，并为其设置一个唯一标识符（例如
      <code>
       "1"
      </code>
      ）
     </p>
     <ul>
      <li>
       <p>
        <strong>
         消息关联
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          <code>
           CorrelationData
          </code>
          用于将消息与其确认状态关联起来。
         </p>
        </li>
        <li>
         <p>
          每个消息可以有一个唯一的
          <code>
           CorrelationData
          </code>
          对象。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         确认回调
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          当 RabbitMQ 服务器确认收到消息时，会触发确认回调。
         </p>
        </li>
        <li>
         <p>
          在回调中，可以通过
          <code>
           CorrelationData
          </code>
          识别是哪条消息被确认。
         </p>
        </li>
       </ul>
      </li>
     </ul>
    </blockquote>
    <pre><code class="language-java"> @Bean
    public RabbitTemplate confirmRabbitTemplate(ConnectionFactory connectionFactory){
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        //设置回调方法
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println("执行了confirm方法");
                if (ack){
                    System.out.printf("接收到消息, 消息ID: %s \n", correlationData==null? null: correlationData.getId());
                }else {
                    System.out.printf("未接收到消息, 消息ID: %s, cause: %s \n", correlationData==null? null: correlationData.getId(), cause);
                    //相应的业务处理
                }
            }
        });
        //消息被退回时, 回调方法
        rabbitTemplate.setMandatory(true);
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            @Override
            public void returnedMessage(ReturnedMessage returned) {
                System.out.println("消息退回:"+returned);
            }
        });
        return rabbitTemplate;
    }</code></pre>
    <p>
     <strong>
      消息确认回调（Confirm Callback）
     </strong>
     ：
    </p>
    <pre><code class="language-java">    public interface ConfirmCallback {
        void confirm(@Nullable CorrelationData var1, boolean var2, @Nullable String var3);
    }
</code></pre>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         CorrelationData correlationData
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         关联数据，用于标识消息。
        </p>
       </li>
       <li>
        <p>
         可以是
         <code>
          null
         </code>
         ，表示没有关联数据。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         boolean ack
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         表示消息是否被成功确认。
        </p>
       </li>
       <li>
        <p>
         <code>
          true
         </code>
         ：消息被 RabbitMQ 服务器成功接收。
        </p>
       </li>
       <li>
        <p>
         <code>
          false
         </code>
         ：消息未被 RabbitMQ 服务器接收。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         String cause
        </code>
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果
         <code>
          ack
         </code>
         为
         <code>
          false
         </code>
         ，表示未确认的原因。
        </p>
       </li>
       <li>
        <p>
         如果
         <code>
          ack
         </code>
         为
         <code>
          true
         </code>
         ，通常为
         <code>
          null
         </code>
         。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <pre><code class="language-java">
    public void setReturnsCallback(ReturnsCallback returnCallback) {
        Assert.state(this.returnsCallback == null || this.returnsCallback.equals(returnCallback), "Only one ReturnCallback is supported by each RabbitTemplate");
        this.returnsCallback = returnCallback;
    }</code></pre>
    <p>
     <strong>
      消息退回回调（Returns Callback）
     </strong>
    </p>
    <p>
     通过
     <code>
      setMandatory(true)
     </code>
     设置强制消息退回
    </p>
    <p>
     如果消息无法路由到队列，RabbitMQ 会将消息退回给生产者。
    </p>
    <p>
     这么设置存在两个问题
    </p>
    <p>
     <strong>
      1.这种方式设置ConfirmCallback影响所有使用RabbitTemple的方法
     </strong>
    </p>
    <p>
     <strong>
      2.重复调用接口时会提示错误
     </strong>
    </p>
    <p>
     <img alt="" height="61" src="https://i-blog.csdnimg.cn/direct/82e5c84cc4dc4c8c99ec11994ab824d4.png" width="675"/>
    </p>
    <p>
     2.return退回模式
    </p>
    <p>
     return 退回模式主要用于将数据、控制权或流程返回到上一个状态、调用者或指定的位置。
    </p>
    <hr/>
    <h3 id="%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9C%A8%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E6%97%B6%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%EF%BC%89" name="%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9C%A8%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E6%97%B6%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%EF%BC%89">
     <strong>
      重试机制（
     </strong>
     在消息处理失败时，自动重试
     <strong>
      ）
     </strong>
    </h3>
    <pre><code class="language-java">        retry:
          enabled: true # 开启消费者失败重试
          initial-interval: 5000ms # 初始失败等待5S
          max-attempts: 5 #最大重试次数(包括自身消费的一次)</code></pre>
    <pre><code class="language-java">  @RabbitListener(queues = Constants.RETRY_QUEUE)
//    在 RabbitMQ 中，deliveryTag 是一个用于标识消息的唯一标识符，
//    通常用于确认（acknowledge）或拒绝（reject）消息。
//    当你从 RabbitMQ 队列中消费一条消息时，
//    RabbitMQ 会为该消息分配一个 deliveryTag。
//    这个标签是特定于消息所在的通道（channel）的。
    public void handlerMessage(Message message) throws UnsupportedEncodingException {
        long deliveryTag = message.getMessageProperties().getDeliveryTag();
        System.out.printf("["+Constants.RETRY_QUEUE+"]接收到消息: %s, deliveryTag: %s \n", new String(message.getBody(), "UTF-8"), deliveryTag);
//        int num = 3/0;
        
//        如果消息处理成功，调用 basicAck 确认消息。
//        如果消息处理失败，调用 basicReject 拒绝消息并重新放回队列。
        System.out.println("业务处理完成");
    }</code></pre>
    <p>
     消息处理成功
    </p>
    <p>
     <img alt="" height="102" src="https://i-blog.csdnimg.cn/direct/9b79e54162164289bdab44d0ceacad30.png" width="630"/>
    </p>
    <p>
     消息处理失败(因为设定间隔5s重试一次,所以比较慢,最多重试5次结束)
    </p>
    <p>
     <img alt="" height="156" src="https://i-blog.csdnimg.cn/direct/f08935b3de4b4975979be98bf12fcc32.png" width="608"/>
    </p>
    <hr/>
    <h3 id="%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97(DLQ%E5%A4%84%E7%90%86%E6%97%A0%E6%B3%95%E8%A2%AB%E6%AD%A3%E5%B8%B8%E6%B6%88%E8%B4%B9%E7%9A%84%E6%B6%88%E6%81%AF)" name="%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97(DLQ%E5%A4%84%E7%90%86%E6%97%A0%E6%B3%95%E8%A2%AB%E6%AD%A3%E5%B8%B8%E6%B6%88%E8%B4%B9%E7%9A%84%E6%B6%88%E6%81%AF)">
     <strong>
      死信队列(DLQ
     </strong>
     处理无法被正常消费的消息)
    </h3>
    <h4 id="%E8%AE%BE%E7%BD%AETTL" name="%E8%AE%BE%E7%BD%AETTL">
     设置TTL
    </h4>
    <pre><code class="language-java"> @Bean("ttlQueue2")
    public Queue ttlQueue2(){
        return QueueBuilder.durable(Constants.TTL_QUEUE2).ttl(20000).build();
    }
//还有ttlQueue1和ttlexchange就不网上写了

 @Bean("ttlBinding")
    public Binding ttlBinding(@Qualifier("ttlQueue1")Queue queue,@Qualifier("ttlExchange")Exchange exchange){
        return BindingBuilder.bind(queue).to(exchange).with("ttl").noargs();
    }
    @Bean("ttlBinding2")
    public Binding ttlBinding2(@Qualifier("ttlQueue2")Queue queue,@Qualifier("ttlExchange")Exchange exchange){
        return BindingBuilder.bind(queue).to(exchange).with("ttl").noargs();
    }
    @Bean("ttlQueue3")
    public Queue ttlQueue3(){
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
//向 Map 中添加一个参数 x-message-ttl，表示队列中消息的存活时间（TTL）
        map.put("x-message-ttl", 20000);

//withArguments(map):
//将之前定义的参数（x-message-ttl）应用到队列中。
        return QueueBuilder.durable(Constants.TTL_QUEUE2).withArguments(map).build();  //设置队列的ttl为20s
    }</code></pre>
    <pre><code class="language-java">//设置消息的TTL
@RequestMapping("ttl1")
    public String ttl1(){
        System.out.println("ttl1...");

        rabbitTemplate.convertAndSend(Constants.TTL_EXCHANGE, "ttl", "ttl1 test 30s...", message -&gt; {
            message.getMessageProperties().setExpiration("30000");  //单位: 毫秒, 过期时间为30s
            return message;
        });

        rabbitTemplate.convertAndSend(Constants.TTL_EXCHANGE, "ttl", "ttl1 test 10s...", message -&gt; {
            message.getMessageProperties().setExpiration("10000");  //单位: 毫秒, 过期时间为10s
            return message;
        });
        return "消息发送成功";
    }</code></pre>
    <p>
    </p>
    <p>
     <strong>
      这段代码(个人理解),设置一个队列中的过期时间,创建一个持久化队列 ,进入一个消息,消息存在时间为20s,如果消息不进行消费,则过期,进入到死信队列
     </strong>
    </p>
    <p>
     <img alt="" height="57" src="https://i-blog.csdnimg.cn/direct/311f76cb5e8a4f0eb5fb5e3a0a577be4.png" width="663"/>
    </p>
    <p>
     20S后
    </p>
    <p>
     <img alt="" height="37" src="https://i-blog.csdnimg.cn/direct/80b3cf3862bb4af3a40591ecd8479397.png" width="635"/>
    </p>
    <p>
     <strong>
      <code>
       ttlQueue2和ttlQueue3
      </code>
     </strong>
     二者的区别
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         特性
        </strong>
       </th>
       <th>
        <strong>
         <code>
          ttlQueue2
         </code>
        </strong>
       </th>
       <th>
        <strong>
         <code>
          ttlQueue3
         </code>
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         实现方式
        </strong>
       </td>
       <td>
        使用
        <code>
         QueueBuilder
        </code>
        的
        <code>
         ttl()
        </code>
        方法直接设置 TTL。
       </td>
       <td>
        手动创建
        <code>
         Map
        </code>
        对象，并通过
        <code>
         withArguments()
        </code>
        设置参数。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         代码简洁性
        </strong>
       </td>
       <td>
        更简洁，适合只设置 TTL 的场景。
       </td>
       <td>
        稍显冗长，但更灵活，适合需要设置多个参数的场景。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         灵活性
        </strong>
       </td>
       <td>
        只能设置 TTL，无法同时设置其他参数。
       </td>
       <td>
        可以同时设置多个队列参数（如 TTL、死信队列等）。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         底层实现
        </strong>
       </td>
       <td>
        内部会创建一个
        <code>
         Map
        </code>
        并设置
        <code>
         x-message-ttl
        </code>
        。
       </td>
       <td>
        显式创建
        <code>
         Map
        </code>
        并设置
        <code>
         x-message-ttl
        </code>
        。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <img alt="" height="184" src="https://i-blog.csdnimg.cn/direct/70d74029e69d44b0af83151f764002bd.png" width="641"/>
    </p>
    <blockquote>
     <p>
      注意:
     </p>
     <p>
      1.设置队列的TTL(存在该队列中所有消息的TTL)
     </p>
     <p>
      2.设置消息的TTL
     </p>
     <p>
      假如,队列TTL是20s,消息的TTL是10s,那么消息的TTL取小值,也就是10s
     </p>
     <p>
      如果消息的一个为30S和10s取大值
     </p>
    </blockquote>
    <hr/>
    <blockquote>
     <p>
      死信队列常见的3种情况
     </p>
     <p>
      1.消息被拒绝:消费者在处理消息时,可能因为消息内容错误,处理逻辑异常等原因拒绝处理该消息,可以理解为程序不能正常运行
     </p>
     <p>
      2.消息过期
     </p>
     <p>
      3.队列达到最大长度
     </p>
    </blockquote>
    <p>
     <img alt="" height="325" src="https://i-blog.csdnimg.cn/direct/06cce190907949fa999f4636db9d4a71.png" width="646"/>
    </p>
    <pre><code class="language-java">@Bean("normalQueue")
    public Queue normalQueue(){
        return QueueBuilder.durable(Constants.NORMAL_QUEUE)
                .deadLetterExchange(Constants.DL_EXCHANGE)
                .deadLetterRoutingKey("dlx")
                .build();
    }</code></pre>
    <p>
     <img alt="" height="103" src="https://i-blog.csdnimg.cn/direct/98cf9f771a3d4fd0b905a664c82771ad.png" width="667"/>
    </p>
    <h3 id="%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81(%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E6%89%A7%E8%A1%8C)" name="%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81(%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E6%89%A7%E8%A1%8C)">
     <strong>
      事务支持(
     </strong>
     确保消息的发送和确认在事务中执行
     <strong>
      )
     </strong>
    </h3>
    <p>
     <strong>
      开启事务
     </strong>
    </p>
    <pre><code class="language-java">  @Bean("transRabbitTemplate")
    public RabbitTemplate transRabbitTemplate(ConnectionFactory connectionFactory){
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setChannelTransacted(true);  //开启事务
        return rabbitTemplate;
    }

    @Bean
    public RabbitTransactionManager rabbitTransactionManager(ConnectionFactory connectionFactory){
        return new RabbitTransactionManager(connectionFactory);
    }</code></pre>
    <p>
    </p>
    <pre><code class="language-java">    @Transactional
    @RequestMapping("/trans")
    public String trans(){
        System.out.println("trans test...");
        transRabbitTemplate.convertAndSend("",Constants.TRANS_QUEUE, "trans test 1...");
//        int num = 5/0;
        transRabbitTemplate.convertAndSend("",Constants.TRANS_QUEUE, "trans test 2...");
        return "消息发送成功";
    }
</code></pre>
    <p>
     <span style="color:#fe2c24">
      <strong>
       不采用事务,第一条成功,第二条失败
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       采用事务,同时成功或同时失败
      </strong>
     </span>
    </p>
    <h3 id="%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%C2%A0%20%E5%86%B3%E5%AE%9A%E4%BA%86%E6%B6%88%E6%81%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%9F%E4%BA%A7%E8%80%85%E4%BC%A0%E9%80%92%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85" name="%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%C2%A0%20%E5%86%B3%E5%AE%9A%E4%BA%86%E6%B6%88%E6%81%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%9F%E4%BA%A7%E8%80%85%E4%BC%A0%E9%80%92%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85">
     消息分发  决定了消息如何从生产者传递到消费者
    </h3>
    <p>
     消息分发是指消息从生产者传递到消费者的过程。RabbitMQ 提供了多种分发模式，包括直接分发、广播分发、主题分发和头部分发（详见之前的回答）。除此之外，RabbitMQ 还支持以下分发策略：
    </p>
    <p>
     <strong>
      工作队列模式（Work Queue）
     </strong>
    </p>
    <p>
     在多个消费者之间分发消息，RabbitMQ 默认采用
     <strong>
      轮询（Round-Robin）
     </strong>
     的方式将消息均匀地分发给所有消费者。
    </p>
    <p>
     <strong>
      非公平分发（Non-Fair Dispatch）
     </strong>
    </p>
    <p>
     默认情况下，RabbitMQ 会将消息均匀地分发给所有消费者，即使某些消费者处理速度较慢。这可能导致某些消费者积压大量消息，而其他消费者空闲。
    </p>
    <p>
     <strong>
      限流（Quality of Service, QoS）
     </strong>
    </p>
    <p>
     限流是指控制消费者从队列中获取消息的速率，以避免消费者过载或消息积压。RabbitMQ 通过
     <strong>
      QoS 预取机制（Prefetch Count）
     </strong>
     实现限流。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323230315f37353838363735372f:61727469636c652f64657461696c732f313436313535323831" class_="artid" style="display:none">
 </p>
</div>


