---
layout: post
title: "C-返回值优化Return-Value-Optimization"
date: 2025-03-16 22:32:21 +0800
description: "本文深入探讨C++中的返回值优化(RVO), 包括命名返回值优化(NRVO)和无名返回值优化(URVO), 通过实例代码展示RVO如何提高程序性能, 避免不必要的临时对象创建. 同时, 讨论RVO的发展历程, 失效情况及与std::move的区别, 帮助开发者优化代码."
keywords: "C++ 返回值优化(Return Value Optimization)"
categories: ['Modern', 'C']
tags: ['开发语言', 'Rvo', 'Elision', 'Copy', 'C']
artid: "146302891"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146302891
    alt: "C-返回值优化Return-Value-Optimization"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146302891
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146302891
cover: https://bing.ee123.net/img/rand?artid=146302891
image: https://bing.ee123.net/img/rand?artid=146302891
img: https://bing.ee123.net/img/rand?artid=146302891
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ 返回值优化(Return Value Optimization)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-dracula" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="Intro_0">
     </a>
     Intro
    </h3>
    <p>
     返回值优化(Return Value Optimization, RVO)是 C++中的一种编译器优化技术, 它允许编译器在某些情况下省略临时对象的创建和复制/移动操作, 从而提高程序性能. RVO 主要应用于函数返回值的场景.
    </p>
    <h3>
     <a id="_RVO_4">
     </a>
     两种形式的 RVO
    </h3>
    <p>
     假定我们有这样一个类:
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>

 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">SetName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> name_ <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"默认构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">MyClass</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造函数: {}"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name_<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拷贝构造函数: {}"</span><span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>name_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">MyClass</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{<!-- --></span>
    name_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rhs<span class="token punctuation">.</span>name_ <span class="token operator">=</span> name_ <span class="token operator">+</span> <span class="token string">"[MOVED]"</span><span class="token punctuation">;</span>
    fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"移动构造函数: {}"</span><span class="token punctuation">,</span> name_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  MyClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拷贝赋值运算符"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  MyClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"移动赋值运算符"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"析构函数, name={}"</span><span class="token punctuation">,</span> name_<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <ol>
     <li>
      <p>
       <strong>
        命名返回值优化(Named Return Value Optimization, NRVO)
       </strong>
       : 当一个函数返回一个局部变量时, 如果这个变量的类型与函数返回类型相同或可转换, NRVO 允许编译器直接在调用者的作用域内构造该局部变量, 而不是先构造然后复制到返回值.
      </p>
      <pre><code class="prism language-cpp">MyClass <span class="token function">NamedRVO</span><span class="token punctuation">(</span><span class="token keyword">bool</span> useFirst<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  MyClass <span class="token function">result</span><span class="token punctuation">(</span><span class="token string">"named RVO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        无名返回值优化(Unamed Return Value Optimization)
       </strong>
       : 当返回一个临时对象时, 编译器可以在调用者的空间直接构造这个临时对象, 避免了临时对象的生成以及后续的复制/移动操作.
      </p>
      <pre><code class="prism language-cpp">MyClass <span class="token function">UnamedRVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token string">"unamed RVO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ol>
    <p>
     我们使用如下的测试代码, 有兴趣的读者可以打开运行(CSDN不适用, 可以访问
     <a href="https://www.arong-xu.com/blogs/modern-cpp/cpp-return-value-optimization/" rel="nofollow">
      个人网站版本
     </a>
     ):
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  MyClass unamed <span class="token operator">=</span> <span class="token function">UnamedRVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  MyClass named <span class="token operator">=</span> <span class="token function">NamedRVO</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     输出:
    </p>
    <pre><code class="prism language-txt">构造函数
=======
默认构造函数
析构函数, name=named RVO
析构函数, name=unamed RVO
</code></pre>
    <p>
     从析构函数的调用次数我们可以判断出使用了 RVO, 因为没有临时变量的产生. 直接在返回值所在的地方生成对象, 省略了返回值的拷贝或者移动.
    </p>
    <p>
     为了对比, 我们再看一下没有启用 RVO 的输出:
    </p>
    <pre><code class="prism language-txt">构造函数: unamed RVO
移动构造函数: unamed RVO
析构函数, name=unamed RVO[moved]
移动构造函数: unamed RVO
析构函数, name=unamed RVO[moved]
=======
构造函数: named RVO
移动构造函数: named RVO
析构函数, name=named RVO[moved]
移动构造函数: named RVO
析构函数, name=named RVO[moved]
析构函数, name=named RVO
析构函数, name=unamed RVO
</code></pre>
    <p>
     当启用了 RVO 后, 我们看到程序实际上是在返回值所在的地方构造了一个对象, 不需要借助拷贝或者移动.
    </p>
    <p>
     <img alt="RVO" src="https://i-blog.csdnimg.cn/direct/dec4887b6f3d4e0caa7fdf96012d7109.jpeg#pic_center"/>
    </p>
    <h3>
     <a id="RVO__101">
     </a>
     RVO 的发展历程
    </h3>
    <ol>
     <li>
      从 C++98 开始, 编译器被允许做 RVO 优化
     </li>
     <li>
      从 C++7 开始, 编译器被强制要求做 RVO 优化(Mandatory Copy Elision)
     </li>
    </ol>
    <p>
     RVO 可以被禁用, 在编译的时候指定
     <code>
      -fno-elide-constructors
     </code>
     (GCC/Clang) 来禁用 RVO.
    </p>
    <h4>
     <a id="C17__108">
     </a>
     C++17 中的改进
    </h4>
    <p>
     从 C++17 开始, 复制省略成为了标准的一部分, 这意味着即使类的复制/移动构造函数有副作用(如打印信息), 编译器也允许跳过这些步骤, 直接构造返回的对象. 这使得 RVO 不仅是一个优化选项, 而且是语言的一个特性, 进一步提高了代码的效率和简洁性.
    </p>
    <h3>
     <a id="RVO__112">
     </a>
     RVO 失效的情况
    </h3>
    <p>
     下面的情况下 RVO 不会被触发.
    </p>
    <ol>
     <li>
      <p>
       编译器选项设置了
       <code>
        -fno-elide-constructors
       </code>
      </p>
     </li>
     <li>
      <p>
       函数返回的是一个全局变量:
      </p>
      <pre><code class="prism language-cpp">MyClass <span class="token function">global</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
MyClass <span class="token function">NoRVO1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> global<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       当返回类型不匹配时:
      </p>
      <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MyClass</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> fmt<span class="token double-colon punctuation">::</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MyClass <span class="token function">NoRVO2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       如果返回的可能是不同的对象, 那么编译器将无法确定哪个对象应该被返回, 因此无法触发 RVO.
      </p>
      <p>
       多个
       <code>
        return
       </code>
       语句
      </p>
      <pre><code class="prism language-cpp">MyClass <span class="token function">NoRVO3</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  MyClass <span class="token function">r1</span><span class="token punctuation">(</span><span class="token string">"r1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  MyClass <span class="token function">r2</span><span class="token punctuation">(</span><span class="token string">"r2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> r2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> r1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       或者单个 return 语句里面有条件分支
      </p>
      <pre><code class="prism language-cpp">MyClass <span class="token function">NoRVO4</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  MyClass <span class="token function">r1</span><span class="token punctuation">(</span><span class="token string">"r1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  MyClass <span class="token function">r2</span><span class="token punctuation">(</span><span class="token string">"r2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> r2 <span class="token operator">:</span> r1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       加了一个不必要的
       <code>
        std::move
       </code>
       . 这属于画蛇添足了, RVO 比起 move 来更高效.
      </p>
      <pre><code class="prism language-cpp">MyClass <span class="token function">NoRVO5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  MyClass <span class="token function">r1</span><span class="token punctuation">(</span><span class="token string">"r1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
    </ol>
    <h3>
     <a id="RVO__stdmove_169">
     </a>
     RVO 与 std::move
    </h3>
    <p>
     上面讲到
     <code>
      std::move
     </code>
     会导致 RVO 失效, 那么或许有人会问: 已经存在 move 了那 RVO 还有必要吗?
    </p>
    <p>
     实际上是有必要的. 因为 RVO 是在返回位置处之间创建对象, 而 move 是先创建一个临时变量, 再进行 move. 明显多做了一步, 这一步无论再小也是代价. 另外对于 POD 类型来说, move 就是拷贝.
    </p>
    <p>
     下面做了一个测试对比, 我们看看 move 和 RVO 的性能差别:
    </p>
    <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;benchmark/benchmark.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fmt/core.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token comment">//{<!-- --></span>
<span class="token keyword">class</span> <span class="token class-name">SimpleClass</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>

 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SimpleClass</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

SimpleClass <span class="token function">UnamedRVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token string">"test string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

SimpleClass <span class="token function">Move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token function">SimpleClass</span><span class="token punctuation">(</span><span class="token string">"test string"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">BM_UnamedRVO</span><span class="token punctuation">(</span>benchmark<span class="token double-colon punctuation">::</span>State<span class="token operator">&amp;</span> state<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> _ <span class="token operator">:</span> state<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    SimpleClass unamed <span class="token operator">=</span> <span class="token function">UnamedRVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    benchmark<span class="token double-colon punctuation">::</span><span class="token function">DoNotOptimize</span><span class="token punctuation">(</span>unamed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">BM_Move</span><span class="token punctuation">(</span>benchmark<span class="token double-colon punctuation">::</span>State<span class="token operator">&amp;</span> state<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> _ <span class="token operator">:</span> state<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    SimpleClass moved <span class="token operator">=</span> <span class="token function">Move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    benchmark<span class="token double-colon punctuation">::</span><span class="token function">DoNotOptimize</span><span class="token punctuation">(</span>moved<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">BENCHMARK</span><span class="token punctuation">(</span>BM_UnamedRVO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">BENCHMARK</span><span class="token punctuation">(</span>BM_Move<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">BENCHMARK_MAIN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//}</span>
</code></pre>
    <p>
     测试结果(Release 版本):
    </p>
    <pre><code class="prism language-txt">-------------------------------------------------------
Benchmark             Time             CPU   Iterations
-------------------------------------------------------
BM_UnamedRVO       5.25 ns         5.24 ns    116932087
BM_Move            10.7 ns         10.6 ns     68695102
</code></pre>
    <p>
     请注意在使用 benchmark 库的时候, 需要使用
     <code>
      benchmark::DoNotOptimize
     </code>
     来避免编译器优化掉代码. 因为
     <code>
      unamed
     </code>
     和
     <code>
      moved
     </code>
     都是局部变量, 编译器可能会优化掉它们的创建和销毁. 就会出现运行开销为
     <code>
      0
     </code>
     的谬误.
    </p>
    <pre><code class="prism language-txt">-------------------------------------------------------
Benchmark             Time             CPU   Iterations
-------------------------------------------------------
BM_UnamedRVO      0.000 ns        0.000 ns   1000000000000
BM_Move            10.1 ns         10.1 ns     66627774
</code></pre>
    <h3>
     <a id="_236">
     </a>
     参考链接
    </h3>
    <ul>
     <li>
      <a href="https://gitcode.com/arong_xu/CSDNBlogSampleCode/tree/main/basics/return-value-optimization">
       演示示例源码
      </a>
     </li>
     <li>
      <a href="https://www.youtube.com/watch?v=WyxUilrR6fU" rel="nofollow">
       C++ RVO: Return Value Optimization for Performance in Bloomberg C++ Codebases - Michelle Fae D’Souza
      </a>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f61726f6e675f78752f:61727469636c652f64657461696c732f313436333032383931" class_="artid" style="display:none">
 </p>
</div>


