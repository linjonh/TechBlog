---
layout: post
title: "Android-FFMPEG-开发FFMPEG-直播功能完整流程-源码-源码交叉编译-AS工程配置-音视频打开读取解码格式转换-原生绘制播放-音视频同步-"
date: 2022-10-13 14:04:32 +0800
description: "FFMPEG 直播功能完整流程 + 源码 ( 源码交叉编译 -> AS工程配置 -> 音视频打开/读"
keywords: "android ffmpeg 直播"
categories: ['开发', 'Ffmpeg', 'Android']
tags: ['Opensles', 'Ffmpeg', 'Avpacket', 'Avframe', 'Android']
artid: "104900964"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=104900964
    alt: "Android-FFMPEG-开发FFMPEG-直播功能完整流程-源码-源码交叉编译-AS工程配置-音视频打开读取解码格式转换-原生绘制播放-音视频同步-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=104900964
featuredImagePreview: https://bing.ee123.net/img/rand?artid=104900964
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【Android FFMPEG 开发】FFMPEG 直播功能完整流程 + 源码 ( 源码交叉编译 -&gt; AS工程配置 -&gt; 音视频打开/读取/解码/格式转换  -&gt; 原生绘制播放 -&gt; 音视频同步 )
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-tomorrow-night-eighties" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <ul>
        <li>
         <ul>
          <li>
           <ul>
            <li>
             <a href="#I__FFMPEG__25" rel="nofollow">
              I . FFMPEG 播放视频流程总结
             </a>
            </li>
            <li>
             <a href="#II__FFMPEG__104" rel="nofollow">
              II . FFMPEG 下载及交叉编译
             </a>
            </li>
            <li>
             <a href="#III__Android_Studio__FFMPEG__193" rel="nofollow">
              III . Android Studio 配置 FFMPEG 函数库
             </a>
            </li>
            <li>
             <a href="#IV__FFMPEG__423" rel="nofollow">
              IV . FFMPEG 初始化
             </a>
            </li>
            <li>
             <a href="#V__FFMPEG__AVStream__522" rel="nofollow">
              V . FFMPEG 获取 AVStream 音视频流
             </a>
            </li>
            <li>
             <a href="#VI__FFMPEG__599" rel="nofollow">
              VI . FFMPEG 获取编解码器
             </a>
            </li>
            <li>
             <a href="#VII__FFMPEG__AVPacket____730" rel="nofollow">
              VII . FFMPEG 读取音视频流中的数据到 AVPacket ( 压缩编码后的数据包 )
             </a>
            </li>
            <li>
             <a href="#VIII__FFMPEG_AVFrame__YUV__RGBA_794" rel="nofollow">
              VIII . FFMPEG AVFrame 图像格式转换 YUV -&gt; RGBA
             </a>
            </li>
            <li>
             <a href="#IX__ANativeWindow__919" rel="nofollow">
              IX . ANativeWindow 原生绘制
             </a>
            </li>
            <li>
             <a href="#X__FFMPEG__1095" rel="nofollow">
              X . FFMPEG 音频重采样
             </a>
            </li>
            <li>
             <a href="#XI__OpenSLES__1295" rel="nofollow">
              XI . OpenSLES 播放音频
             </a>
            </li>
            <li>
             <a href="#XII__FFMPEG__1761" rel="nofollow">
              XII . FFMPEG 音视频同步
             </a>
            </li>
            <li>
             <a href="#XIII__GitHub__1869" rel="nofollow">
              XIII . GitHub 代码地址
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <br/>
    <br/>
    <br/>
    <blockquote>
     <p>
      本博客属于总结性质的博客 , 开发时可以参考该博客的代码示例 , 可以直接使用 ; 知识点比较概括 , 只描述操作流程及核心源码 , 没有具体原理说明 , 详细的原理知识去具体的单条知识点博客中查看 ;
     </p>
    </blockquote>
    <br/>
    <p>
     <strong>
      代码及播放效果 :
     </strong>
    </p>
    <p>
     <strong>
      1 . GitHub 代码地址 :
     </strong>
     <a href="https://github.com/han1202012/011_FFMPEG">
      FFMPEG 直播示例
     </a>
    </p>
    <p>
     <strong>
      2 . 效果展示 :
     </strong>
     <font color="blue">
      使用的是湖南卫视的直播源 rtmp://58.200.131.2:1935/livetv/hunantv
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/701b31bd4b8c46100f1adc14211de6f6.gif"/>
     </font>
    </p>
    <br/>
    <br/>
    <h5>
     <a id="I__FFMPEG__25">
     </a>
     I . FFMPEG 播放视频流程总结
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      FFMPEG 播放视频流程 :
     </strong>
     <font color="blue">
      视频中包含图像和音频 ;
     </font>
    </p>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 交叉编译配置 :
     </strong>
     <a href="https://blog.csdn.net/shulianghan/article/details/104351312">
      【Android FFMPEG 开发】FFMPEG 交叉编译配置 ( 下载 | 配置脚本 | 输出路径 | 函数库配置 | 程序配置 | 组件配置 | 编码解码配置 | 交叉编译配置 | 最终脚本 )
     </a>
    </p>
    <br/>
    <p>
     <strong>
      2 . Android Studio 工程配置 FFMPEG :
     </strong>
     <a href="https://blog.csdn.net/shulianghan/article/details/104367747">
      【Android FFMPEG 开发】Android Studio 工程配置 FFMPEG ( 动态库打包 | 头文件与函数库拷贝 | CMake 脚本配置 )
     </a>
    </p>
    <br/>
    <p>
     <strong>
      3 . FFMPEG 初始化 :
     </strong>
     <font color="orange">
      <a href="https://hanshuliang.blog.csdn.net/article/details/104636151" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 初始化 ( 网络初始化 | 打开音视频 | 查找音视频流 )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      4 . FFMPEG 获取 AVStream 音视频流 :
     </strong>
     <font color="orange">
      <a href="https://hanshuliang.blog.csdn.net/article/details/104652321" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 获取 AVStream 音视频流 ( AVFormatContext 结构体 | 获取音视频流信息 | 获取音视频流个数 | 获取音视频流 )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      5 . FFMPEG 获取 AVCodec 编解码器 :
     </strong>
     <font color="orange">
      <a href="https://hanshuliang.blog.csdn.net/article/details/104661085" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 获取编解码器 ( 获取编解码参数 | 查找编解码器 | 获取编解码器上下文 | 设置上下文参数 | 打开编解码器 )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      6 . FFMPEG 读取音视频流中的数据到 AVPacket :
     </strong>
     <font color="orange">
      <a href="https://blog.csdn.net/shulianghan/article/details/104746458">
       【Android FFMPEG 开发】FFMPEG 读取音视频流中的数据到 AVPacket ( 初始化 AVPacket 数据 | 读取 AVPacket )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      7 . FFMPEG 解码 AVPacket 数据到 AVFrame ( 音频 / 视频数据解码 ) :
     </strong>
     <font color="orange">
      <a href="https://blog.csdn.net/shulianghan/article/details/104768104">
       【Android FFMPEG 开发】FFMPEG 解码 AVPacket 数据到 AVFrame ( AVPacket-&gt;解码器 | 初始化 AVFrame | 解码为 AVFrame 数据 )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      8 . FFMPEG AVFrame 图像格式转换 YUV -&gt; RGBA :
     </strong>
     <font color="orange">
      <a href="https://hanshuliang.blog.csdn.net/article/details/104772549" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG AVFrame 图像格式转换 YUV -&gt; RGBA ( 获取 SwsContext | 初始化图像数据存储内存 | 图像格式转换 )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      9 . FFMPEG ANativeWindow 原生绘制 准备 :
     </strong>
     <font color="orange">
      <a href="https://hanshuliang.blog.csdn.net/article/details/104788783" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG ANativeWindow 原生绘制 ( Java 层获取 Surface | 传递画布到本地 | 创建 ANativeWindow )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      10 . FFMPEG ANativeWindow 原生绘制 :
     </strong>
     <a href="https://blog.csdn.net/shulianghan/article/details/104790084">
      【Android FFMPEG 开发】FFMPEG ANativeWindow 原生绘制 ( 设置 ANativeWindow 缓冲区属性 | 获取绘制缓冲区 | 填充数据到缓冲区 | 启动绘制 )
     </a>
    </p>
    <br/>
    <p>
     <strong>
      11 . FFMPEG 音频重采样 :
     </strong>
     <a href="https://blog.csdn.net/shulianghan/article/details/104871223">
      【Android FFMPEG 开发】FFMPEG 音频重采样 ( 初始化音频重采样上下文 SwrContext | 计算音频延迟 | 计算输出样本个数 | 音频重采样 swr_convert )
     </a>
    </p>
    <br/>
    <p>
     <strong>
      12 . FFMPEG 音频播放 :
     </strong>
     <a href="https://blog.csdn.net/shulianghan/article/details/104880199">
      【Android FFMPEG 开发】OpenSLES 播放音频 ( 创建引擎 | 输出混音设置 | 配置输入输出 | 创建播放器 | 获取播放/队列接口 | 回调函数 | 开始播放 | 激活回调 )
     </a>
    </p>
    <br/>
    <p>
     <strong>
      13 . FFMPEG 音视频同步 :
     </strong>
     <a href="https://blog.csdn.net/shulianghan/article/details/104891200">
      【Android FFMPEG 开发】FFMPEG 音视频同步 ( 音视频同步方案 | 视频帧 FPS 控制 | H.264 编码 I / P / B 帧 | PTS | 音视频同步 )
     </a>
    </p>
    <br/>
    <p>
     <strong>
      14 . FFMPEG 直播示例 :
     </strong>
     <a href="https://hanshuliang.blog.csdn.net/article/details/104900964" rel="nofollow">
      【Android FFMPEG 开发】FFMPEG 直播功能完整流程 + 源码 ( 源码交叉编译 -&gt; AS工程配置 -&gt; 音视频打开/读取/解码/格式转换 -&gt; 原生绘制播放 -&gt; 音视频同步 )
     </a>
    </p>
    <br/>
    <br/>
    <h5>
     <a id="II__FFMPEG__104">
     </a>
     II . FFMPEG 下载及交叉编译
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 下载 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      ① FFMPEG 源码下载地址 :
     </strong>
     <a href="http://ffmpeg.org/download.html#releases" rel="nofollow">
      http://ffmpeg.org/download.html#releases
     </a>
    </p>
    <p>
     <strong>
      ② 本博客使用的源码下载地址 :
     </strong>
     <a href="https://ffmpeg.org/releases/ffmpeg-4.0.2.tar.bz2" rel="nofollow">
      https://ffmpeg.org/releases/ffmpeg-4.0.2.tar.bz2
     </a>
     <br/>
     <font color="purple">
      ( 也可以直接从博客资源中下载 )
     </font>
    </p>
    <br/>
    <p>
     <strong>
      2 . FFMPEG 编译 :
     </strong>
     <font color="red">
      在 Ubuntu 18.04.4 中解压该源码 ;
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 配置编译脚本 :
     </strong>
     <font color="blue">
      在 FFMPEG 源码根目录下 , 创建 build_ffmpeg.sh 文件 , 内容如下 ;
     </font>
    </p>
    <pre><code class="prism language-shell"><span class="token shebang important">#!/bin/bash</span>

<span class="token comment"># NDK 根目录</span>
NDK_ROOT<span class="token operator">=</span>/root/NDK/android-ndk-r17c

<span class="token comment"># TOOLCHAIN 变量指向 gcc g++ 等交叉编译工具所在的目录</span>
TOOLCHAIN<span class="token operator">=</span><span class="token variable">$NDK_ROOT</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64

<span class="token comment"># gcc 编译器参数</span>
FLAGS<span class="token operator">=</span><span class="token string">"-isysroot <span class="token variable">$NDK_ROOT</span>/sysroot -isystem <span class="token variable">$NDK_ROOT</span>/sysroot/usr/include/arm-linux-androideabi -isystem <span class="token variable">$NDK_ROOT</span>/sources/android/support/include -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC"</span>

<span class="token comment"># 编译结果输出路径</span>
PREFIX<span class="token operator">=</span>./android/armeabi-v7a

<span class="token comment"># 执行 configure 脚本生成 Makefile 构建脚本</span>
./configure \
--prefix<span class="token operator">=</span><span class="token variable">$PREFIX</span> \
--enable-small \
--disable-programs \
--disable-avdevice \
--disable-encoders \
--disable-muxers \
--disable-filters \
--enable-cross-compile \
--cross-prefix<span class="token operator">=</span><span class="token variable">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \
--sysroot<span class="token operator">=</span><span class="token variable">$NDK_ROOT</span>/platforms/android-21/arch-arm \
--extra-cflags<span class="token operator">=</span><span class="token string">"<span class="token variable">$FLAGS</span>"</span> \
--arch<span class="token operator">=</span>arm \
--target-os<span class="token operator">=</span>android 

<span class="token comment"># 清除之前的编译内容</span>
<span class="token function">make</span> clean

<span class="token comment"># 开启新的 FFMPEG 编译</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre>
    <p>
     <strong>
      ② 修改 Shell 脚本权限 :
     </strong>
    </p>
    <pre><code class="prism language-shell"><span class="token function">chmod</span> +x build_ffmpeg.sh
</code></pre>
    <p>
     <strong>
      ③ 执行 Shell 脚本 :
     </strong>
    </p>
    <pre><code class="prism language-shell">./build_ffmpeg.sh
</code></pre>
    <p>
     <strong>
      ④ 编译结果 :
     </strong>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2f3fac6b4b33ff9c3299153e220d7983.png"/>
    </p>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/shulianghan/article/details/104351312">
       【Android FFMPEG 开发】FFMPEG 交叉编译配置 ( 下载 | 配置脚本 | 输出路径 | 函数库配置 | 程序配置 | 组件配置 | 编码解码配置 | 交叉编译配置 | 最终脚本 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="III__Android_Studio__FFMPEG__193">
     </a>
     III . Android Studio 配置 FFMPEG 函数库
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . 头文件与静态库文件拷贝 :
     </strong>
     <font color="blue">
      将上面编译生成的 include 和 lib 两个目录 , 拷贝到 app/src/main/cpp 目录下 ;
     </font>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2f4abc01f05850b7c45a705b0a39f4d0.png"/>
    </p>
    <blockquote>
     <p>
      <font color="purple">
       动态库拷贝到 jniLibs/armeabi-v7a 目录下 , 静态库可以拷贝到任意位置使用 ;
      </font>
     </p>
    </blockquote>
    <br/>
    <p>
     <strong>
      2 . 配置 Module 级别的 build.gradle 构建脚本 :
     </strong>
    </p>
    <pre><code class="prism language-java">apply plugin<span class="token operator">:</span> <span class="token string">'com.android.application'</span>

android <span class="token punctuation">{<!-- --></span>
    compileSdkVersion <span class="token number">28</span>
    defaultConfig <span class="token punctuation">{<!-- --></span>
        applicationId <span class="token string">"kim.hsl.ffmpeg"</span>
        minSdkVersion <span class="token number">21</span>
        targetSdkVersion <span class="token number">28</span>
        versionCode <span class="token number">1</span>
        versionName <span class="token string">"1.0"</span>
        testInstrumentationRunner <span class="token string">"androidx.test.runner.AndroidJUnitRunner"</span>


        <span class="token comment">// I . NDK 配置 1 : 配置 AS 工程中的 C/C++ 源文件的编译</span>

        <span class="token comment">//     defaultConfig 内部的 externalNativeBuild 配置的是配置 AS 工程的 C/C++ 源文件编译参数</span>
        <span class="token comment">//     defaultConfig 外部的 externalNativeBuild 配置的是 CMakeList.txt 或 Android1.mk 构建脚本的路径</span>
        externalNativeBuild <span class="token punctuation">{<!-- --></span>
            cmake <span class="token punctuation">{<!-- --></span>
                cppFlags <span class="token string">""</span>

                <span class="token comment">//配置编译 C/C++ 源文件为哪几个 CPU 指令集的函数库 (arm , x86 等)</span>
                abiFilters <span class="token string">"armeabi-v7a"</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>



        <span class="token comment">// II . NDK 配置 2 : 配置 AS 工程中的 C/C++ 源文件的编译</span>


        <span class="token comment">//配置 APK 打包 哪些动态库</span>
        <span class="token comment">//  示例 : 如在工程中集成了第三方库 , 其提供了 arm, x86, mips 等指令集的动态库</span>
        <span class="token comment">//        那么为了控制打包后的应用大小, 可以选择性打包一些库 , 此处就是进行该配置</span>
        ndk<span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 打包生成的 APK 文件指挥包含 ARM 指令集的动态库</span>
            abiFilters <span class="token string">"armeabi-v7a"</span> <span class="token comment">/*, "arm64-v8a", "x86", "x86_64"*/</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>


    <span class="token comment">// III . NDK 配置  : 配置 AS 工程中的 C/C++ 源文件的编译构建脚本</span>


    <span class="token comment">// 配置 NDK 的编译脚本路径</span>
    <span class="token comment">// 编译脚本有两种 ① CMakeList.txt ② Android.mk</span>
    <span class="token comment">//     defaultConfig 内部的 externalNativeBuild 配置的是配置 AS 工程的 C/C++ 源文件编译参数</span>
    <span class="token comment">//     defaultConfig 外部的 externalNativeBuild 配置的是 CMakeList.txt 或 Android1.mk 构建脚本的路径</span>
    externalNativeBuild <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 配置 CMake 构建脚本 CMakeLists.txt 脚本路径</span>
        cmake <span class="token punctuation">{<!-- --></span>
            path <span class="token string">"src/main/cpp/CMakeLists.txt"</span>
            version <span class="token string">"3.10.2"</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    buildTypes <span class="token punctuation">{<!-- --></span>
        release <span class="token punctuation">{<!-- --></span>
            minifyEnabled <span class="token boolean">false</span>
            proguardFiles <span class="token function">getDefaultProguardFile</span><span class="token punctuation">(</span><span class="token string">'proguard-android-optimize.txt'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'proguard-rules.pro'</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

dependencies <span class="token punctuation">{<!-- --></span>
    implementation <span class="token function">fileTree</span><span class="token punctuation">(</span>dir<span class="token operator">:</span> <span class="token string">'libs'</span><span class="token punctuation">,</span> include<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'*.jar'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    implementation <span class="token string">'androidx.appcompat:appcompat:1.1.0'</span>
    implementation <span class="token string">'androidx.constraintlayout:constraintlayout:1.1.3'</span>
    testImplementation <span class="token string">'junit:junit:4.12'</span>
    androidTestImplementation <span class="token string">'androidx.test:runner:1.2.0'</span>
    androidTestImplementation <span class="token string">'androidx.test.espresso:espresso-core:3.2.0'</span>
<span class="token punctuation">}</span>

</code></pre>
    <br/>
    <p>
     <strong>
      3 . 配置 CMakeList.txt 构建脚本 :
     </strong>
    </p>
    <pre><code class="prism language-shell"><span class="token comment"># I . 指定 CMake 最低版本</span>
cmake_minimum_required<span class="token punctuation">(</span>VERSION 3.4.1<span class="token punctuation">)</span>

<span class="token comment"># II . 设置函数库编译</span>
add_library<span class="token punctuation">(</span> <span class="token comment"># 参数 1 : 设置生成的动态库名称</span>
        native-lib

        <span class="token comment"># 参数 2 : 设置生成的函数库类型 : ① 静态库 STATIC ② 动态库 SHARED</span>
        SHARED

        <span class="token comment"># 参数 3 : 配置要编译的源文件</span>
        native-lib.cpp
        FFMPEG.cpp
        JavaPlayerCaller.cpp
        AudioChannel.cpp
        VideoChannel.cpp<span class="token punctuation">)</span>

<span class="token comment"># III . 到预设的目录查找 log 库 , 将找到的路径赋值给 log-lib</span>
<span class="token comment">#       这个路径是 NDK 的 ndk-bundle\platforms\android-29\arch-arm\usr\lib\liblog.so</span>
<span class="token comment">#       不同的 Android 版本号 和 CPU 架构 需要到对应的目录中查找 , 此处是 29 版本 32 位 ARM 架构的日志库</span>
<span class="token comment">#</span>
<span class="token comment"># 可以不配置 :</span>
<span class="token comment">#       可以不进行该配置, 直接在后面的 target_link_libraries 中链接 log 也不会出错</span>
find_library<span class="token punctuation">(</span>
        log-lib

        log<span class="token punctuation">)</span>


<span class="token comment"># IV . 指定 FFMPEG 头文件查找目录</span>
<span class="token comment">#           CMAKE_SOURCE_DIR 指的是当前的文件地址</span>
include_directories<span class="token punctuation">(</span><span class="token variable">${CMAKE_SOURCE_DIR}</span>/include<span class="token punctuation">)</span>

<span class="token comment"># V . 指定 FFMPEG 静态库</span>
<span class="token comment"># CMAKE_CXX_FLAGS 表示会将 C++ 的参数传给编译器</span>
<span class="token comment"># CMAKE_C_FLAGS 表示会将 C 参数传给编译器</span>

<span class="token comment"># 参数设置 : 传递 CMAKE_CXX_FLAGS C+= 参数给编译器时 , 在 该参数后面指定库的路径</span>
<span class="token comment">#   CMAKE_SOURCE_DIR 指的是当前的文件地址</span>
<span class="token comment">#   -L 参数指定动态库的查找路径</span>
set<span class="token punctuation">(</span>CMAKE_CXX_FLAGS <span class="token string">"<span class="token variable">${CMAKE_CXX_FLAGS}</span> -L<span class="token variable">${CMAKE_SOURCE_DIR}</span>/lib"</span><span class="token punctuation">)</span>


<span class="token comment"># V . 链接函数库</span>
<span class="token comment">#       参数 1 : 本构建脚本要生成的动态库目标</span>
<span class="token comment">#       参数 2 ~ ... : 后面是之前预编译的动态库或静态库 , 或引入的动态库</span>
target_link_libraries<span class="token punctuation">(</span>
        native-lib

        <span class="token comment"># FFMPEG 静态库</span>
        <span class="token comment"># 注意这些库的顺序必须按照如下进行 , 否则会报错</span>
        <span class="token comment">#   这些库之间有依赖的关系 , 必须按照顺序加载库 , 如 avcodec 内部依赖 avformat 库</span>
        avfilter
        avformat
        avcodec
        avutil
        swresample
        swscale

        <span class="token comment"># 日志库</span>
        <span class="token variable">${log-lib}</span>

        <span class="token comment">#FFMPEG 使用到了 libz 库 , 没有会报错</span>
        <span class="token comment">#   FFMPEG 对于 z 的依赖是以动态库的形式进行的</span>
        <span class="token comment">#   如果 FFMPEG 是动态库 , 那么可以不链接这个库 , 可以运行时链接这个库</span>
        <span class="token comment">#   当前 FFMPEG 是静态库 , 需要在编译时将这个库打包到静态库中</span>
        <span class="token comment">#   推荐使用静态库 , 静态库打包出来的库比动态库小很多 , 一倍左右</span>
        z

        <span class="token comment">#在 Native 层使用 ANativeWindow 进行原生绘制时 , 需要链接 libandroid.so 库</span>
        android

        <span class="token comment">#调用 OpenSLES 需要链接该库</span>
        OpenSLES
<span class="token punctuation">)</span>
</code></pre>
    <br/>
    <p>
     <strong>
      4 . 配置 AndroidManifest.xml :
     </strong>
     <font color="red">
      主要是配置网络和音频相关的权限 ;
     </font>
    </p>
    <pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span>
    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>
    <span class="token attr-name">package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kim.hsl.ffmpeg<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!-- RECORD_AUDIO is needed to create an audio recorder --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.permission.RECORD_AUDIO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>uses-permission</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- MODIFY_AUDIO_SETTINGS is needed to use audio effects such as environmental reverb --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.permission.MODIFY_AUDIO_SETTINGS<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>uses-permission</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- INTERNET is needed to use a URI-based audio player, depending on the URI --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.permission.INTERNET<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>uses-permission</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span>
        <span class="token attr-name"><span class="token namespace">android:</span>allowBackup</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@mipmap/ic_launcher<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">android:</span>label</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/app_name<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">android:</span>roundIcon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@mipmap/ic_launcher_round<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">android:</span>supportsRtl</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/AppTheme<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span>
            <span class="token attr-name"><span class="token namespace">android:</span>screenOrientation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>landscape<span class="token punctuation">"</span></span>
            <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/Theme.Black.NoTitleBar.Fullscreen<span class="token punctuation">"</span></span>
            <span class="token attr-name"><span class="token namespace">tools:</span>ignore</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LockedOrientationActivity<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>

                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.category.LAUNCHER<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">&gt;</span></span>
</code></pre>
    <br/>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/shulianghan/article/details/104367747">
       【Android FFMPEG 开发】Android Studio 工程配置 FFMPEG ( 动态库打包 | 头文件与函数库拷贝 | CMake 脚本配置 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="IV__FFMPEG__423">
     </a>
     IV . FFMPEG 初始化
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 初始化流程 :
     </strong>
     <font color="blue">
      FFMPEG 执行任何操作前 , 都需要初始化一些环境 , 及相关数据参数 ;
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 网络初始化 :
     </strong>
     <font color="red">
      <strong>
       avformat_network_init()
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">avformat_network_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 打开媒体 ( 音视频 ) 地址 :
     </strong>
     <font color="red">
      <strong>
       avformat_open_input()
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">avformat_open_input</span><span class="token punctuation">(</span>AVFormatContext <span class="token operator">*</span><span class="token operator">*</span>ps<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>url<span class="token punctuation">,</span> AVInputFormat <span class="token operator">*</span>fmt<span class="token punctuation">,</span> AVDictionary <span class="token operator">*</span><span class="token operator">*</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ③ 查找 ( 音 / 视频 ) 流 :
     </strong>
     <font color="red">
      <strong>
       avformat_find_stream_info()
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">avformat_find_stream_info</span><span class="token punctuation">(</span>AVFormatContext <span class="token operator">*</span>ic<span class="token punctuation">,</span> AVDictionary <span class="token operator">*</span><span class="token operator">*</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ④ 正式操作 :
     </strong>
     <font color="purple">
      对上述查找到的 音 / 视频 流进行操作 ;
     </font>
    </p>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp">    <span class="token comment">/*
     * 初始化网络 :
     *      默认状态下 , FFMPEG 是不允许联网的
     *      必须调用该函数 , 初始化网络后 FFMPEG 才能进行联网
     */</span>
    <span class="token function">avformat_network_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">//0 . 注册组件</span>
    <span class="token comment">//      如果是 4.x 之前的版本需要执行该步骤</span>
    <span class="token comment">//      4.x 及之后的版本 , 就没有该步骤了</span>
    <span class="token comment">//av_register_all();</span>

    <span class="token comment">//1 . 打开音视频地址 ( 播放文件前 , 需要先将文件打开 )</span>
    <span class="token comment">//      地址类型 : ① 文件类型 , ② 音视频流</span>
    <span class="token comment">//  参数解析 :</span>
    <span class="token comment">//      AVFormatContext **ps :  封装了文件格式相关信息的结构体 , 如视频宽高 , 音频采样率等信息 ;</span>
    <span class="token comment">//                              该参数是 二级指针 , 意味着在方法中会修改该指针的指向 ,</span>
    <span class="token comment">//                              该参数的实际作用是当做返回值用的</span>
    <span class="token comment">//      const char *url :   视频资源地址, 文件地址 / 网络链接</span>
    <span class="token comment">//  返回值说明 : 返回 0 , 代表打开成功 , 否则失败</span>
    <span class="token comment">//              失败的情况 : 文件路径错误 , 网络错误</span>
    <span class="token comment">//int avformat_open_input(AVFormatContext **ps, const char *url,</span>
    <span class="token comment">//                          AVInputFormat *fmt, AVDictionary **options);</span>
    formatContext <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> open_result <span class="token operator">=</span> <span class="token function">avformat_open_input</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>formatContext<span class="token punctuation">,</span> dataSource<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//如果返回值不是 0 , 说明打开视频文件失败 , 需要将错误信息在 Java 层进行提示</span>
    <span class="token comment">//  这里将错误码返回到 Java 层显示即可</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>open_result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"打开媒体失败 : %s"</span><span class="token punctuation">,</span> <span class="token function">av_err2str</span><span class="token punctuation">(</span>open_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>



    <span class="token comment">//2 . 查找媒体 地址 对应的音视频流 ( 给 AVFormatContext* 成员赋值 )</span>
    <span class="token comment">//      方法原型 : int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);</span>
    <span class="token comment">//      调用该方法后 , AVFormatContext 结构体的 nb_streams 元素就有值了 ,</span>
    <span class="token comment">//      该值代表了音视频流 AVStream 个数</span>
    <span class="token keyword">int</span> find_result <span class="token operator">=</span> <span class="token function">avformat_find_stream_info</span><span class="token punctuation">(</span>formatContext<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//如果返回值 &lt; 0 , 说明查找音视频流失败 , 需要将错误信息在 Java 层进行提示</span>
    <span class="token comment">//  这里将错误码返回到 Java 层显示即可</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>find_result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"查找媒体流失败 : %s"</span><span class="token punctuation">,</span> <span class="token function">av_err2str</span><span class="token punctuation">(</span>find_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      <a href="https://hanshuliang.blog.csdn.net/article/details/104636151" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 初始化 ( 网络初始化 | 打开音视频 | 查找音视频流 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="V__FFMPEG__AVStream__522">
     </a>
     V . FFMPEG 获取 AVStream 音视频流
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 音视频流 AVStream ( 结构体 ) 获取流程 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      ① 获取音视频流信息 :
     </strong>
     <font color="red">
      <strong>
       avformat_find_stream_info ( )
      </strong>
      ,
      <font color="blue">
       在
       <a href="https://hanshuliang.blog.csdn.net/article/details/104636151" rel="nofollow">
        【Android FFMPEG 开发】FFMPEG 初始化 ( 网络初始化 | 打开音视频 | 查找音视频流 )
       </a>
       博客中 , FFMPEG 初始化完毕后 , 获取了音视频流 , 本博客中讲解获取该音视频流对应的编解码器 , 从获取该音视频流开始 ;
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">avformat_find_stream_info</span><span class="token punctuation">(</span>AVFormatContext <span class="token operator">*</span>ic<span class="token punctuation">,</span> AVDictionary <span class="token operator">*</span><span class="token operator">*</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 音视频流数量 :
     </strong>
     <font color="purple">
      获取的音视频流信息存储在
      <font color="red">
       <strong>
        AVFormatContext *formatContext
       </strong>
       <font color="purple">
        结构体中 , nb_streams 元素的值就是音视频流的个数 ;
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//音视频流的个数</span>
formatContext<span class="token operator">-</span><span class="token operator">&gt;</span>nb_streams
</code></pre>
    <br/>
    <p>
     <strong>
      ③ 音视频流 :
     </strong>
     <font color="red">
      <strong>
       AVFormatContext *formatContext
      </strong>
      <font color="green">
       结构体中的 音视频流数组元素
       <font color="red">
        <strong>
         AVStream **streams
        </strong>
        <font color="green">
         元素 , 通过数组下标可以获取指定位置索引的音视频流 ;
        </font>
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//取出一个媒体流 ( 视频流 / 音频流 )</span>
AVStream <span class="token operator">*</span>stream <span class="token operator">=</span> formatContext<span class="token operator">-</span><span class="token operator">&gt;</span>streams<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp">    <span class="token comment">//2 . 查找媒体 地址 对应的音视频流 ( 给 AVFormatContext* 成员赋值 )</span>
    <span class="token comment">//      方法原型 : int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);</span>
    <span class="token comment">//      调用该方法后 , AVFormatContext 结构体的 nb_streams 元素就有值了 ,</span>
    <span class="token comment">//      该值代表了音视频流 AVStream 个数</span>
    <span class="token keyword">int</span> find_result <span class="token operator">=</span> <span class="token function">avformat_find_stream_info</span><span class="token punctuation">(</span>formatContext<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//如果返回值 &lt; 0 , 说明查找音视频流失败 , 需要将错误信息在 Java 层进行提示</span>
    <span class="token comment">//  这里将错误码返回到 Java 层显示即可</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>find_result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"查找媒体流失败 : %s"</span><span class="token punctuation">,</span> <span class="token function">av_err2str</span><span class="token punctuation">(</span>find_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">//3 . 处理视频流 , 解析其中的数据流 , 获取流的各种参数 , 编解码器 , 等信息</span>
    <span class="token comment">//      为视频 音频 解码播放准备数据</span>

    <span class="token comment">//formatContext-&gt;nb_streams 是 音频流 / 视频流 个数 ;</span>
    <span class="token comment">//  循环解析 视频流 / 音频流 , 一般是两个 , 一个视频流 , 一个音频流</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> formatContext<span class="token operator">-</span><span class="token operator">&gt;</span>nb_streams<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token comment">//取出一个媒体流 ( 视频流 / 音频流 )</span>
        AVStream <span class="token operator">*</span>stream <span class="token operator">=</span> formatContext<span class="token operator">-</span><span class="token operator">&gt;</span>streams<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      <a href="https://hanshuliang.blog.csdn.net/article/details/104652321" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 获取 AVStream 音视频流 ( AVFormatContext 结构体 | 获取音视频流信息 | 获取音视频流个数 | 获取音视频流 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="VI__FFMPEG__599">
     </a>
     VI . FFMPEG 获取编解码器
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 编解码器获取流程 :
     </strong>
     <font color="orange">
      在获取音视频流
      <font color="red">
       <strong>
        AVStream *stream
       </strong>
       <font color="orange">
        之后 , 执行以下流程 ;
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      〇 获取 AVStream * 音视频流 ( 获取编解码器前提 ) :
     </strong>
     <font color="purple">
      参考博客
      <a href="https://hanshuliang.blog.csdn.net/article/details/104652321" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 获取 AVStream 音视频流 ( AVFormatContext 结构体 | 获取音视频流信息 | 获取音视频流个数 | 获取音视频流 )
      </a>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 获取音视频流的编码参数 :
     </strong>
     <font color="red">
      <strong>
       AVStream *stream
      </strong>
      <font color="blue">
       结构体的
       <font color="red">
        <strong>
         AVCodecParameters *codecpar
        </strong>
        <font color="blue">
         元素是音视频流的编解码参数 ; 包含 码率 , 宽度 , 高度 , 采样率 等参数信息 ;
        </font>
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//解码这个媒体流的参数信息 , 包含 码率 , 宽度 , 高度 , 采样率 等参数信息</span>
AVCodecParameters <span class="token operator">*</span>codecParameters <span class="token operator">=</span> stream<span class="token operator">-</span><span class="token operator">&gt;</span>codecpar<span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 查找编解码器 :
     </strong>
     <font color="orange">
      调用
      <font color="red">
       <strong>
        avcodec_find_decoder ( )
       </strong>
       <font color="orange">
        获取当前音视频流使用的编解码器 ;
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//① 查找 当前流 使用的编码方式 , 进而查找编解码器 ( 可能失败 , 不支持的解码方式 )</span>
AVCodec <span class="token operator">*</span>avCodec <span class="token operator">=</span> <span class="token function">avcodec_find_decoder</span><span class="token punctuation">(</span>codecParameters<span class="token operator">-</span><span class="token operator">&gt;</span>codec_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ③ 获取编解码器上下文 :
     </strong>
     <font color="purple">
      调用
      <font color="red">
       <strong>
        avcodec_alloc_context3 ( )
       </strong>
       <font color="purple">
        方法 , 获取编解码器上下文 ;
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//② 获取编解码器上下文</span>
AVCodecContext <span class="token operator">*</span>avCodecContext <span class="token operator">=</span> <span class="token function">avcodec_alloc_context3</span><span class="token punctuation">(</span>avCodec<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ④ 设置编解码器上下文参数 :
     </strong>
     <font color="green">
      调用
      <font color="red">
       <strong>
        avcodec_parameters_to_context ( )
       </strong>
       <font color="green">
        方法 , 设置编解码器的上下文参数 ;
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//③ 设置 编解码器上下文 参数</span>
<span class="token comment">//      int avcodec_parameters_to_context(AVCodecContext *codec,</span>
<span class="token comment">//              const AVCodecParameters *par);</span>
<span class="token comment">//      返回值 &gt; 0 成功 , &lt; 0 失败</span>
<span class="token keyword">int</span> parameters_to_context_result <span class="token operator">=</span>
        <span class="token function">avcodec_parameters_to_context</span><span class="token punctuation">(</span>avCodecContext<span class="token punctuation">,</span> codecParameters<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑤ 打开编解码器 :
     </strong>
     <font color="blue">
      调用
      <font color="red">
       <strong>
        avcodec_open2 ( )
       </strong>
       <font color="blue">
        方法 , 打开编解码器 ;
       </font>
      </font>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//④ 打开编解码器</span>
<span class="token comment">//   int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, </span>
<span class="token comment">//   返回 0 成功 , 其它失败</span>
<span class="token keyword">int</span> open_codec_result <span class="token operator">=</span> <span class="token function">avcodec_open2</span><span class="token punctuation">(</span>avCodecContext<span class="token punctuation">,</span> avCodec<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp">        <span class="token comment">//视频 / 音频 处理需要的操作 ( 获取编解码器 )</span>

        <span class="token comment">//① 查找 当前流 使用的编码方式 , 进而查找编解码器 ( 可能失败 , 不支持的解码方式 )</span>
        AVCodec <span class="token operator">*</span>avCodec <span class="token operator">=</span> <span class="token function">avcodec_find_decoder</span><span class="token punctuation">(</span>codecParameters<span class="token operator">-</span><span class="token operator">&gt;</span>codec_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//查找失败处理</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>avCodec <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//如果没有找到编解码器 , 回调失败 , 方法直接返回 , 后续代码不执行</span>
            callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"查找 编解码器 失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>


        <span class="token comment">//② 获取编解码器上下文</span>
        AVCodecContext <span class="token operator">*</span>avCodecContext <span class="token operator">=</span> <span class="token function">avcodec_alloc_context3</span><span class="token punctuation">(</span>avCodec<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//获取编解码器失败处理</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>avCodecContext <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"创建编解码器上下文 失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//③ 设置 编解码器上下文 参数</span>
        <span class="token comment">//      int avcodec_parameters_to_context(AVCodecContext *codec,</span>
        <span class="token comment">//              const AVCodecParameters *par);</span>
        <span class="token comment">//      返回值 &gt; 0 成功 , &lt; 0 失败</span>
        <span class="token keyword">int</span> parameters_to_context_result <span class="token operator">=</span>
                <span class="token function">avcodec_parameters_to_context</span><span class="token punctuation">(</span>avCodecContext<span class="token punctuation">,</span> codecParameters<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//设置 编解码器上下文 参数 失败处理</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>parameters_to_context_result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"设置编解码器上下文参数 失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//④ 打开编解码器</span>
        <span class="token comment">//   int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);</span>
        <span class="token comment">//   返回 0 成功 , 其它失败</span>
        <span class="token keyword">int</span> open_codec_result <span class="token operator">=</span> <span class="token function">avcodec_open2</span><span class="token punctuation">(</span>avCodecContext<span class="token punctuation">,</span> avCodec<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//打开编解码器 失败处理</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>open_codec_result <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            callHelper<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">onError</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_ERROR <span class="token punctuation">,</span> <span class="token string">"FFMPEG"</span> <span class="token punctuation">,</span> <span class="token string">"打开 编解码器 失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      <a href="https://hanshuliang.blog.csdn.net/article/details/104661085" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG 获取编解码器 ( 获取编解码参数 | 查找编解码器 | 获取编解码器上下文 | 设置上下文参数 | 打开编解码器 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="VII__FFMPEG__AVPacket____730">
     </a>
     VII . FFMPEG 读取音视频流中的数据到 AVPacket ( 压缩编码后的数据包 )
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 获取 AVPacket 数据流程 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      〇 前置操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="red">
        获取 AVCodec 编解码器 ,
        <font color="purple">
         然后才能进行下面的操作 ;
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 初始化 AVPacket 空数据包 :
     </strong>
     <font color="red">
      <strong>
       av_packet_alloc ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp">AVPacket <span class="token operator">*</span>avPacket <span class="token operator">=</span> <span class="token function">av_packet_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 读取 AVPacket 数据 :
     </strong>
     <font color="red">
      <strong>
       av_read_frame ( AVFormatContext *s , AVPacket *pkt )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> read_frame_result <span class="token operator">=</span> <span class="token function">av_read_frame</span><span class="token punctuation">(</span>formatContext<span class="token punctuation">,</span> avPacket<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//读取数据包</span>
<span class="token comment">// AVPacket 存放编码后的音视频数据的 , 获取该数据包后 , 需要对该数据进行解码 , 解码后将数据存放在 AVFrame 中</span>
<span class="token comment">// AVPacket 是编码后的数据 , AVFrame 是编码前的数据</span>
<span class="token comment">//创建 AVPacket 空数据包</span>
AVPacket <span class="token operator">*</span>avPacket <span class="token operator">=</span> <span class="token function">av_packet_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
    读取数据包 , 并存储到 AVPacket 数据包中
    参数分析 : 一维指针 与 二维指针 参数分析
      ① 注意 : 第二个参数是 AVPacket * 类型的 , 那么传入 AVPacket *avPacket 变量
            不能修改 avPacket 指针的指向 , 即该指针指向的结构体不能改变
            只能修改 avPacket 指向的结构体中的元素的值
              因此 , 传入的 avPacket 结构体指针必须先进行初始化 , 然后再传入
                  av_read_frame 函数内 , 没有修改 AVPacket *avPacket 的值 , 但是修改了结构体中元素的值
      ② 与此相对应的是 avformat_open_input 方法 , 传入 AVFormatContext ** 二维指针
          传入的的 AVFormatContext ** 是没有经过初始化的 , 连内存都没有分配
          在 avformat_open_input 方法中创建并初始化 AVFormatContext * 结构体指针
          然后将该指针地址赋值给 AVFormatContext **
              avformat_open_input 函数内修改了 AVFormatContext ** 参数的值
    返回值 0 说明读取成功 , 小于 0 说明读取失败 , 或者 读取完毕
 */</span>
<span class="token keyword">int</span> read_frame_result <span class="token operator">=</span> <span class="token function">av_read_frame</span><span class="token punctuation">(</span>formatContext<span class="token punctuation">,</span> avPacket<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/shulianghan/article/details/104746458">
       【Android FFMPEG 开发】FFMPEG 读取音视频流中的数据到 AVPacket ( 初始化 AVPacket 数据 | 读取 AVPacket )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="VIII__FFMPEG_AVFrame__YUV__RGBA_794">
     </a>
     VIII . FFMPEG AVFrame 图像格式转换 YUV -&gt; RGBA
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 解码 AVPacket 数据到 AVFrame 流程 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      〇 前置操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="red">
        获取 AVCodec 编解码器 ,
        <font color="orange">
         读取音视频流中的数据到 AVPacket ,
         <font color="cyan">
          解码 AVPacket 数据到 AVFrame ,
          <font color="purple">
           然后才能进行下面的操作 ;
          </font>
         </font>
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 获取 SwsContext :
     </strong>
     <font color="red">
      <strong>
       sws_getContext ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp">SwsContext <span class="token operator">*</span>swsContext <span class="token operator">=</span> <span class="token function">sws_getContext</span><span class="token punctuation">(</span>
        <span class="token comment">//源图像的 宽 , 高 , 图像像素格式</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>pix_fmt<span class="token punctuation">,</span>
        <span class="token comment">//目标图像 大小不变 , 不进行缩放操作 , 只将像素格式设置成 RGBA 格式的</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> AV_PIX_FMT_RGBA<span class="token punctuation">,</span>
        <span class="token comment">//使用的转换算法 , FFMPEG 提供了许多转换算法 , 有快速的 , 有高质量的 , 需要自己测试</span>
        SWS_BILINEAR<span class="token punctuation">,</span>
        <span class="token comment">//源图像滤镜 , 这里传 NULL 即可</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token comment">//目标图像滤镜 , 这里传 NULL 即可</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token comment">//额外参数 , 这里传 NULL 即可</span>
        <span class="token number">0</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 初始化图像数据存储空间 :
     </strong>
     <font color="red">
      <strong>
       av_image_alloc ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token function">av_image_alloc</span><span class="token punctuation">(</span>dst_data<span class="token punctuation">,</span> dst_linesize<span class="token punctuation">,</span>
               avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> AV_PIX_FMT_RGBA<span class="token punctuation">,</span>
               <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ③ 转换图像格式 :
     </strong>
     <font color="red">
      <strong>
       sws_scale ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token function">sws_scale</span><span class="token punctuation">(</span>
        <span class="token comment">//SwsContext *swsContext 转换上下文</span>
        swsContext<span class="token punctuation">,</span>
        <span class="token comment">//要转换的数据内容</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span>
        <span class="token comment">//数据中每行的字节长度</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>linesize<span class="token punctuation">,</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span>
        <span class="token comment">//转换后目标图像数据存放在这里</span>
        dst_data<span class="token punctuation">,</span>
        <span class="token comment">//转换后的目标图像行数</span>
        dst_linesize
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//1 . 获取转换上下文</span>
SwsContext <span class="token operator">*</span>swsContext <span class="token operator">=</span> <span class="token function">sws_getContext</span><span class="token punctuation">(</span>
        <span class="token comment">//源图像的 宽 , 高 , 图像像素格式</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>pix_fmt<span class="token punctuation">,</span>
        <span class="token comment">//目标图像 大小不变 , 不进行缩放操作 , 只将像素格式设置成 RGBA 格式的</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> AV_PIX_FMT_RGBA<span class="token punctuation">,</span>
        <span class="token comment">//使用的转换算法 , FFMPEG 提供了许多转换算法 , 有快速的 , 有高质量的 , 需要自己测试</span>
        SWS_BILINEAR<span class="token punctuation">,</span>
        <span class="token comment">//源图像滤镜 , 这里传 NULL 即可</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token comment">//目标图像滤镜 , 这里传 NULL 即可</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token comment">//额外参数 , 这里传 NULL 即可</span>
        <span class="token number">0</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//2 . 初始化图像存储内存</span>

<span class="token comment">//指针数组 , 数组中存放的是指针</span>
<span class="token keyword">uint8_t</span> <span class="token operator">*</span>dst_data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//普通的 int 数组</span>
<span class="token keyword">int</span> dst_linesize<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//初始化 dst_data 和 dst_linesize , 为其申请内存 , 注意使用完毕后需要释放内存</span>
<span class="token function">av_image_alloc</span><span class="token punctuation">(</span>dst_data<span class="token punctuation">,</span> dst_linesize<span class="token punctuation">,</span>
               avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> AV_PIX_FMT_RGBA<span class="token punctuation">,</span>
               <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//3 . 格式转换</span>
<span class="token function">sws_scale</span><span class="token punctuation">(</span>
        <span class="token comment">//SwsContext *swsContext 转换上下文</span>
        swsContext<span class="token punctuation">,</span>
        <span class="token comment">//要转换的数据内容</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span>
        <span class="token comment">//数据中每行的字节长度</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>linesize<span class="token punctuation">,</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span>
        <span class="token comment">//转换后目标图像数据存放在这里</span>
        dst_data<span class="token punctuation">,</span>
        <span class="token comment">//转换后的目标图像行数</span>
        dst_linesize
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
    <blockquote>
     <p>
      <a href="https://hanshuliang.blog.csdn.net/article/details/104772549" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG AVFrame 图像格式转换 YUV -&gt; RGBA ( 获取 SwsContext | 初始化图像数据存储内存 | 图像格式转换 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="IX__ANativeWindow__919">
     </a>
     IX . ANativeWindow 原生绘制
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      FFMPEG 解码 AVPacket 数据到 AVFrame 流程 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      〇 前置操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="red">
        获取 AVCodec 编解码器 ,
        <font color="orange">
         读取音视频流中的数据到 AVPacket ,
         <font color="cyan">
          解码 AVPacket 数据到 AVFrame ,
          <font color="brown">
           AVFrame 图像格式转换 YUV -&gt; RGBA ,
           <font color="purple">
            然后才能进行下面的操作 ;
           </font>
          </font>
         </font>
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① Java 层获取 Surface 对象 :
     </strong>
     <font color="blue">
      Surface 画布可以在 SurfaceView 的 SurfaceHolder 中获取
     </font>
    </p>
    <pre><code class="prism language-java"><span class="token comment">//绘制图像的 SurfaceView</span>
SurfaceView surfaceView<span class="token punctuation">;</span>

<span class="token comment">//在 SurfaceView 回调函数中获取</span>
SurfaceHolder surfaceHolder <span class="token operator">=</span> surfaceView<span class="token punctuation">.</span><span class="token function">getHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 

<span class="token comment">//获取 Surface 画布</span>
Surface surface <span class="token operator">=</span> surfaceHolder<span class="token punctuation">.</span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 将 Surface 对象传递到 Native 层 :
     </strong>
     <font color="green">
      在 SurfaceHolder.Callback 接口的 surfaceChanged 实现方法中 , 将 Surface 画布传递给 Native 层 ;
     </font>
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">surfaceChanged</span><span class="token punctuation">(</span>SurfaceHolder holder<span class="token punctuation">,</span> <span class="token keyword">int</span> format<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//画布改变 , 横竖屏切换 , 按下 Home 键 , 按下菜单键</span>
    <span class="token comment">//将 Surface 传到 Native 层 , 在 Native 层绘制图像</span>
    <span class="token function">native_set_surface</span><span class="token punctuation">(</span>holder<span class="token punctuation">.</span><span class="token function">getSurface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//调用该方法将 Surface 传递到 Native 层</span>
<span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">native_set_surface</span><span class="token punctuation">(</span>Surface surface<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      ③ 设置 ANativeWindow 绘制缓冲区属性 :
     </strong>
     <font color="red">
      <strong>
       ANativeWindow_setBuffersGeometry ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//设置 ANativeWindow 绘制窗口属性</span>
<span class="token comment">//  传入的参数分别是 : ANativeWindow 结构体指针 , 图像的宽度 , 图像的高度 , 像素的内存格式</span>
<span class="token function">ANativeWindow_setBuffersGeometry</span><span class="token punctuation">(</span>aNativeWindow<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> WINDOW_FORMAT_RGBA_8888<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ④ 获取 ANativeWindow_Buffer 绘制缓冲区 :
     </strong>
     <font color="red">
      <strong>
       ANativeWindow_lock ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//获取 ANativeWindow_Buffer , 如果获取失败 , 直接释放相关资源退出</span>
ANativeWindow_Buffer aNativeWindow_Buffer<span class="token punctuation">;</span>

<span class="token comment">//如果获取成功 , 可以继续向后执行 , 获取失败 , 直接退出</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">ANativeWindow_lock</span><span class="token punctuation">(</span>aNativeWindow<span class="token punctuation">,</span> <span class="token operator">&amp;</span>aNativeWindow_Buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//退出操作 , 释放 aNativeWindow 结构体指针</span>
    <span class="token function">ANativeWindow_release</span><span class="token punctuation">(</span>aNativeWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    aNativeWindow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      ⑤ 填充图像数据到 ANativeWindow_Buffer 绘制缓冲区中 :
     </strong>
     <font color="blue">
      将图像字节数据使用内存拷贝到 ANativeWindow_Buffer 结构体的 bits 字段中 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//向 ANativeWindow_Buffer 填充 RGBA 像素格式的图像数据</span>
<span class="token keyword">uint8_t</span> <span class="token operator">*</span>dst_data <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>aNativeWindow_Buffer<span class="token punctuation">.</span>bits<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//参数中的 uint8_t *data 数据中 , 每一行有 linesize 个 , 拷贝的目标也要逐行拷贝</span>
<span class="token comment">//  aNativeWindow_Buffer.stride 是每行的数据个数 , 每个数据都包含一套 RGBA 像素数据 ,</span>
<span class="token comment">//      RGBA 数据每个占1字节 , 一个 RGBA 占 4 字节</span>
<span class="token comment">//  每行的数据个数 * 4 代表 RGBA 数据个数</span>
<span class="token keyword">int</span> dst_linesize <span class="token operator">=</span> aNativeWindow_Buffer<span class="token punctuation">.</span>stride <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment">//获取 ANativeWindow_Buffer 中数据的地址</span>
<span class="token comment">//      一次拷贝一行 , 有 像素高度 行数</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> aNativeWindow_Buffer<span class="token punctuation">.</span>height<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//计算拷贝的指针地址</span>
    <span class="token comment">//  每次拷贝的目的地址 : dst_data + ( i * dst_linesize )</span>
    <span class="token comment">//  每次拷贝的源地址 : data + ( i * linesize )</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>dst_data <span class="token operator">+</span> <span class="token punctuation">(</span> i <span class="token operator">*</span> dst_linesize <span class="token punctuation">)</span><span class="token punctuation">,</span> data <span class="token operator">+</span> <span class="token punctuation">(</span> i <span class="token operator">*</span> linesize <span class="token punctuation">)</span><span class="token punctuation">,</span> dst_linesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      ⑥ 启动绘制 :
     </strong>
     <font color="red">
      <strong>
       ANativeWindow_unlockAndPost ( )
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//启动绘制</span>
<span class="token function">ANativeWindow_unlockAndPost</span><span class="token punctuation">(</span>aNativeWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// I . 图像格式转换</span>


<span class="token comment">//指针数组 , 数组中存放的是指针</span>
<span class="token keyword">uint8_t</span> <span class="token operator">*</span>dst_data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//普通的 int 数组</span>
<span class="token keyword">int</span> dst_linesize<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//初始化 dst_data 和 dst_linesize , 为其申请内存 , 注意使用完毕后需要释放内存</span>
<span class="token function">av_image_alloc</span><span class="token punctuation">(</span>dst_data<span class="token punctuation">,</span> dst_linesize<span class="token punctuation">,</span>
               avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>width<span class="token punctuation">,</span> avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span> AV_PIX_FMT_RGBA<span class="token punctuation">,</span>
               <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//3 . 格式转换</span>
<span class="token function">sws_scale</span><span class="token punctuation">(</span>
        <span class="token comment">//SwsContext *swsContext 转换上下文</span>
        swsContext<span class="token punctuation">,</span>
        <span class="token comment">//要转换的数据内容</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span>
        <span class="token comment">//数据中每行的字节长度</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>linesize<span class="token punctuation">,</span>
        <span class="token number">0</span><span class="token punctuation">,</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>height<span class="token punctuation">,</span>
        <span class="token comment">//转换后目标图像数据存放在这里</span>
        dst_data<span class="token punctuation">,</span>
        <span class="token comment">//转换后的目标图像行数</span>
        dst_linesize
        <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// II . 拷贝图像数据</span>


<span class="token comment">//1 . 向 ANativeWindow_Buffer 填充 RGBA 像素格式的图像数据</span>
<span class="token keyword">uint8_t</span> <span class="token operator">*</span>dst_data <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>aNativeWindow_Buffer<span class="token punctuation">.</span>bits<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">//2 . 参数中的 uint8_t *data 数据中 , 每一行有 linesize 个 , 拷贝的目标也要逐行拷贝</span>
<span class="token comment">//  aNativeWindow_Buffer.stride 是每行的数据个数 , 每个数据都包含一套 RGBA 像素数据 ,</span>
<span class="token comment">//      RGBA 数据每个占1字节 , 一个 RGBA 占 4 字节</span>
<span class="token comment">//  每行的数据个数 * 4 代表 RGBA 数据个数</span>
<span class="token keyword">int</span> dst_linesize <span class="token operator">=</span> aNativeWindow_Buffer<span class="token punctuation">.</span>stride <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>


<span class="token comment">//3 . 获取 ANativeWindow_Buffer 中数据的地址</span>
<span class="token comment">//      一次拷贝一行 , 有 像素高度 行数</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> aNativeWindow_Buffer<span class="token punctuation">.</span>height<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token comment">//计算拷贝的指针地址</span>
    <span class="token comment">//  每次拷贝的目的地址 : dst_data + ( i * dst_linesize )</span>
    <span class="token comment">//  每次拷贝的源地址 : data + ( i * linesize )</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>dst_data <span class="token operator">+</span> <span class="token punctuation">(</span> i <span class="token operator">*</span> dst_linesize <span class="token punctuation">)</span><span class="token punctuation">,</span> data <span class="token operator">+</span> <span class="token punctuation">(</span> i <span class="token operator">*</span> linesize <span class="token punctuation">)</span><span class="token punctuation">,</span> dst_linesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>


<span class="token comment">// III . 启动绘制</span>
<span class="token comment">//启动绘制</span>
<span class="token function">ANativeWindow_unlockAndPost</span><span class="token punctuation">(</span>aNativeWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
    <blockquote>
     <p>
      <a href="https://hanshuliang.blog.csdn.net/article/details/104788783" rel="nofollow">
       【Android FFMPEG 开发】FFMPEG ANativeWindow 原生绘制 ( Java 层获取 Surface | 传递画布到本地 | 创建 ANativeWindow )
      </a>
      <br/>
      <a href="https://blog.csdn.net/shulianghan/article/details/104790084">
       【Android FFMPEG 开发】FFMPEG ANativeWindow 原生绘制 ( 设置 ANativeWindow 缓冲区属性 | 获取绘制缓冲区 | 填充数据到缓冲区 | 启动绘制 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="X__FFMPEG__1095">
     </a>
     X . FFMPEG 音频重采样
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . FFMPEG 音频重采样流程 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      〇 视频播放操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="red">
        获取 AVCodec 编解码器 ,
        <font color="orange">
         读取音视频流中的数据到 AVPacket ,
         <font color="cyan">
          解码 AVPacket 数据到 AVFrame ,
          <font color="brown">
           AVFrame 图像格式转换 YUV -&gt; RGBA ,
           <font color="magenta">
            ANativeWindow 原生绘制 ;
           </font>
          </font>
         </font>
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      〇 音频播放操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="red">
        获取 AVCodec 编解码器 ,
        <font color="orange">
         读取音视频流中的数据到 AVPacket ,
         <font color="cyan">
          解码 AVPacket 数据到 AVFrame ,
          <font color="purple">
           然后进行下面的操作 , 音频重采样 ;
          </font>
         </font>
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 初始化音频重采样上下文 :
      <font color="red">
       struct SwrContext *swr_alloc_set_opts( … )
       <font color="black">
        ,
        <font color="blue">
         int swr_init(struct SwrContext *s)
        </font>
       </font>
      </font>
     </strong>
    </p>
    <pre><code class="prism language-cpp">SwrContext <span class="token operator">*</span>swrContext <span class="token operator">=</span> <span class="token function">swr_alloc_set_opts</span><span class="token punctuation">(</span>
        <span class="token number">0</span> <span class="token punctuation">,</span>                     <span class="token comment">//现在还没有 SwrContext 上下文 , 先传入 0</span>
        <span class="token comment">//输出的音频参数</span>
        AV_CH_LAYOUT_STEREO <span class="token punctuation">,</span>   <span class="token comment">//双声道立体声</span>
        AV_SAMPLE_FMT_S16 <span class="token punctuation">,</span>     <span class="token comment">//采样位数 16 位</span>
        <span class="token number">44100</span> <span class="token punctuation">,</span>                 <span class="token comment">//输出的采样率</span>
        <span class="token comment">//从编码器中获取输入音频格式</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>channel_layout<span class="token punctuation">,</span> <span class="token comment">//输入的声道数</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>sample_fmt<span class="token punctuation">,</span>     <span class="token comment">//输入的采样位数</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>sample_rate<span class="token punctuation">,</span>    <span class="token comment">//输入的采样率</span>
        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token comment">//日志参数 设置 0 即可</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token function">swr_init</span><span class="token punctuation">(</span>swrContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 计算积压的延迟数据 :
     </strong>
     <font color="red">
      <strong>
       int64_t swr_get_delay(struct SwrContext *s, int64_t base)
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int64_t</span> delay <span class="token operator">=</span> <span class="token function">swr_get_delay</span><span class="token punctuation">(</span>swrContext <span class="token punctuation">,</span> avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>sample_rate<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ③ 计算本次重采样后的样本个数 :
     </strong>
     <font color="red">
      <strong>
       int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd) av_const
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int64_t</span> out_count <span class="token operator">=</span> <span class="token function">av_rescale_rnd</span><span class="token punctuation">(</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>nb_samples <span class="token operator">+</span> delay<span class="token punctuation">,</span> <span class="token comment">//本次要处理的数据个数</span>
        <span class="token number">44100</span><span class="token punctuation">,</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>sample_rate <span class="token punctuation">,</span>
        AV_ROUND_UP <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ④ 音频重采样 :
     </strong>
     <font color="red">
      <strong>
       int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count)
      </strong>
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">int</span> samples_per_channel_count <span class="token operator">=</span> <span class="token function">swr_convert</span><span class="token punctuation">(</span>
        swrContext <span class="token punctuation">,</span>
        <span class="token operator">&amp;</span>data<span class="token punctuation">,</span>
        out_count <span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span> <span class="token comment">//普通指针转为 const 指针需要使用 const_cast 转换</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>nb_samples
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑤ 计算音频重采样字节数 :
     </strong>
     <font color="blue">
      音频重采样 swr_convert ( ) 返回值 samples_per_channel_count 是 每个通道的样本数 ;
     </font>
    </p>
    <pre><code class="prism language-cpp">pcm_data_bit_size <span class="token operator">=</span> samples_per_channel_count <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// I . 音频重采样输出缓冲区准备</span>


<span class="token comment">/**
 * 存放重采样后的数据缓冲区 , 这个缓冲区存储 1 秒的数据 
 * 44100 Hz 采样率 , 16 位采样位数 , 双声道立体声 , 占用内存 44100 * 2 * 2 字节 
 */</span>
<span class="token keyword">uint8_t</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">44100</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">//初始化内存数据</span>
<span class="token function">memset</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">44100</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// II . 音频重采样上下文 初始化</span>


<span class="token comment">/*
 设置音频重采样的上下文参数
 struct SwrContext *swr_alloc_set_opts(struct SwrContext *s,
    int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
    int64_t  in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
    int log_offset, void *log_ctx);
 */</span>
swrContext <span class="token operator">=</span> <span class="token function">swr_alloc_set_opts</span><span class="token punctuation">(</span>
        <span class="token number">0</span> <span class="token punctuation">,</span>                     <span class="token comment">//现在还没有 SwrContext 上下文 , 先传入 0</span>
        <span class="token comment">//输出的音频参数</span>
        AV_CH_LAYOUT_STEREO <span class="token punctuation">,</span>   <span class="token comment">//双声道立体声</span>
        AV_SAMPLE_FMT_S16 <span class="token punctuation">,</span>     <span class="token comment">//采样位数 16 位</span>
        <span class="token number">44100</span> <span class="token punctuation">,</span>                 <span class="token comment">//输出的采样率</span>
        <span class="token comment">//从编码器中获取输入音频格式</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>channel_layout<span class="token punctuation">,</span> <span class="token comment">//输入的声道数</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>sample_fmt<span class="token punctuation">,</span>     <span class="token comment">//输入的采样位数</span>
        avCodecContext<span class="token operator">-</span><span class="token operator">&gt;</span>sample_rate<span class="token punctuation">,</span>    <span class="token comment">//输入的采样率</span>
        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token comment">//日志参数 设置 0 即可</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token comment">//注意创建完之后初始化</span>
<span class="token function">swr_init</span><span class="token punctuation">(</span>swrContext<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// III . 获取延迟数据</span>


<span class="token comment">//OpenSLES 播放器设定播放的音频格式是 立体声 , 44100 Hz 采样 , 16位采样位数</span>
<span class="token comment">//  解码出来的 AVFrame 中的数据格式不确定 , 需要进行重采样</span>
<span class="token comment">/*
    int64_t swr_get_delay(
    struct SwrContext *s,
    int64_t base
    );
    转码的过程中 , 输入 10 个数据 , 并不一定都能处理完毕并输出 10 个数据 , 可能处理输出了 8 个数据
    还剩余 2 个数据没有处理
    那么在下一次处理的时候 , 需要将上次没有处理完的两个数据处理了 ;
    如果不处理上次的2个数据 , 那么数据会一直积压 , 如果积压数据过多 , 最终造成很大的延迟 , 甚至崩溃
    因此每次处理的时候 , 都要尝试将上次剩余没有处理的数据加入到本次处理的数据中
    如果计算出的 delay 一直等于 0 , 说明没有积压数据
 */</span>
<span class="token keyword">int64_t</span> delay <span class="token operator">=</span> <span class="token function">swr_get_delay</span><span class="token punctuation">(</span>swrContext <span class="token punctuation">,</span> avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>sample_rate<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// IV . 计算输出样本个数</span>


<span class="token comment">/*
    将 a 个数据 , 由 c 采样率转换成 b 采样率后 , 返回多少数据
    int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd) av_const;
    下面的方法时将 avFrame-&gt;nb_samples 个数据 , 由 avFrame-&gt;sample_rate 采样率转为 44100 采样率
    返回的数据个数
    AV_ROUND_UP : 向上取整
 */</span>
<span class="token keyword">int64_t</span> out_count <span class="token operator">=</span> <span class="token function">av_rescale_rnd</span><span class="token punctuation">(</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>nb_samples <span class="token operator">+</span> delay<span class="token punctuation">,</span> <span class="token comment">//本次要处理的数据个数</span>
        <span class="token number">44100</span><span class="token punctuation">,</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>sample_rate <span class="token punctuation">,</span>
        AV_ROUND_UP <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// V . 音频重采样</span>


<span class="token comment">/*
 int swr_convert(
        struct SwrContext *s,   //上下文
        uint8_t **out,          //输出的缓冲区 ( 需要计算 )
        int out_count,          //输出的缓冲区最大可接受的样本个数 ( 需要计算 )
        const uint8_t **in ,    //输入的数据
        int in_count);          //输入的样本个数
返回值 : 转换后的采样个数 , 是样本个数 , 每个样本是 16 位 , 两个字节 ;
        samples_out_count 是每个通道的样本数 , samples_out_count * 2 是立体声双声道样本个数
        samples_out_count * 2 * 2 是字节个数
 */</span>
<span class="token keyword">int</span> samples_per_channel_count <span class="token operator">=</span> <span class="token function">swr_convert</span><span class="token punctuation">(</span>
        swrContext <span class="token punctuation">,</span>
        <span class="token operator">&amp;</span>data<span class="token punctuation">,</span>
        out_count <span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span> <span class="token comment">//普通指针转为 const 指针需要使用 const_cast 转换</span>
        avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>nb_samples
        <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// VI . 最终重采样后的数据字节大小</span>


<span class="token comment">//根据样本个数计算样本的字节数</span>
pcm_data_bit_size <span class="token operator">=</span> samples_per_channel_count <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/shulianghan/article/details/104871223">
       【Android FFMPEG 开发】FFMPEG 音频重采样 ( 初始化音频重采样上下文 SwrContext | 计算音频延迟 | 计算输出样本个数 | 音频重采样 swr_convert )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="XI__OpenSLES__1295">
     </a>
     XI . OpenSLES 播放音频
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . OpenSLES 播放音频流程 :
     </strong>
    </p>
    <br/>
    <p>
     <strong>
      〇 视频播放操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="brown">
        获取 AVCodec 编解码器 ,
        <font color="orange">
         读取音视频流中的数据到 AVPacket ,
         <font color="cyan">
          解码 AVPacket 数据到 AVFrame ,
          <font color="brown">
           AVFrame 图像格式转换 YUV -&gt; RGBA ,
           <font color="magenta">
            ANativeWindow 原生绘制 ;
           </font>
          </font>
         </font>
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      〇 音频播放操作 :
     </strong>
     <font color="blue">
      FFMPEG 环境初始化 ,
      <font color="green">
       获取 AVStream 音视频流 ,
       <font color="brown">
        获取 AVCodec 编解码器 ,
        <font color="orange">
         读取音视频流中的数据到 AVPacket ,
         <font color="cyan">
          解码 AVPacket 数据到 AVFrame ,
          <font color="purple">
           音频重采样 ,
           <font color="red">
            然后使用 OpenSLES 播放重采样后的音频 ;
           </font>
          </font>
         </font>
        </font>
       </font>
      </font>
     </font>
    </p>
    <br/>
    <p>
     <strong>
      ① 创建引擎 :
     </strong>
     <font color="red">
      先创建引擎对象 , 再实现引擎对象 , 最后从引擎对象中 , 获取引擎接口 ;
     </font>
    </p>
    <pre><code class="prism language-cpp">SLresult result<span class="token punctuation">;</span>

<span class="token comment">// 创建引擎</span>
result <span class="token operator">=</span> <span class="token function">slCreateEngine</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>engineObject<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 实现引擎</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Realize</span><span class="token punctuation">(</span>engineObject<span class="token punctuation">,</span> SL_BOOLEAN_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取引擎接口</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>engineObject<span class="token punctuation">,</span> SL_IID_ENGINE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>engineEngine<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ② 设置输出混音器 :
     </strong>
     <font color="blue">
      创建输出混音器对象 , 实现输出混音器 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 创建输出混音器对象 , 可以指定一个混响效果参数 ( 该混淆参数可选 )</span>
<span class="token keyword">const</span> SLInterfaceID ids_engine<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_IID_ENVIRONMENTALREVERB<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> SLboolean req_engine<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_BOOLEAN_FALSE<span class="token punctuation">}</span><span class="token punctuation">;</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineEngine<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">CreateOutputMix</span><span class="token punctuation">(</span>engineEngine<span class="token punctuation">,</span> <span class="token operator">&amp;</span>outputMixObject<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ids_engine<span class="token punctuation">,</span> req_engine<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 实现输出混音器</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outputMixObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Realize</span><span class="token punctuation">(</span>outputMixObject<span class="token punctuation">,</span> SL_BOOLEAN_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ③ 获取混响接口并设置混响 :
     </strong>
     <font color="cyan">
      该步骤不是必须操作 , 另外获取混响接口可能失败 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 获取混响接口</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outputMixObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>outputMixObject<span class="token punctuation">,</span> SL_IID_ENVIRONMENTALREVERB<span class="token punctuation">,</span>
                                           <span class="token operator">&amp;</span>outputMixEnvironmentalReverb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置混响</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outputMixEnvironmentalReverb<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">SetEnvironmentalReverbProperties</span><span class="token punctuation">(</span>
            outputMixEnvironmentalReverb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reverbSettings<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ④ 配置音源输入 :
     </strong>
     <font color="brown">
      配置音频数据源缓冲队列 , 和 音源格式 ( 采样率 , 样本位数 , 通道数 , 样本大小端格式 ) ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//1 . 配置音源输入</span>

<span class="token comment">// 配置要播放的音频输入缓冲队列属性参数 , 缓冲区大小 , 音频格式 , 采样率 , 样本位数 , 通道数 , 样本大小端格式</span>
SLDataLocator_AndroidSimpleBufferQueue loc_bufq <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// PCM 格式</span>
SLDataFormat_PCM format_pcm <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_DATAFORMAT_PCM<span class="token punctuation">,</span>           <span class="token comment">//PCM 格式</span>
                               <span class="token number">2</span><span class="token punctuation">,</span>                           <span class="token comment">//两个声道</span>
                               SL_SAMPLINGRATE_44_1<span class="token punctuation">,</span>        <span class="token comment">//采样率 44100 Hz</span>
                               SL_PCMSAMPLEFORMAT_FIXED_16<span class="token punctuation">,</span> <span class="token comment">//采样位数 16位</span>
                               SL_PCMSAMPLEFORMAT_FIXED_16<span class="token punctuation">,</span> <span class="token comment">//容器为 16 位</span>
                               SL_SPEAKER_FRONT_LEFT <span class="token operator">|</span> SL_SPEAKER_FRONT_RIGHT<span class="token punctuation">,</span>  <span class="token comment">//左右双声道</span>
                               SL_BYTEORDER_LITTLEENDIAN<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//小端格式</span>
                               
<span class="token comment">// 设置音频数据源 , 配置缓冲区 ( loc_bufq ) 与 音频格式 (format_pcm)</span>
SLDataSource audioSrc <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token operator">&amp;</span>loc_bufq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>format_pcm<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑤ 配置音频输出 :
     </strong>
     <font color="green">
      装载输出混音器对象 到 SLDataLocator_OutputMix , 在将 SLDataLocator_OutputMix 结构体装载到 SLDataSink 中 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 配置混音器 : 将 outputMixObject 混音器对象装载入 SLDataLocator_OutputMix 结构体中</span>
SLDataLocator_OutputMix loc_outmix <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_DATALOCATOR_OUTPUTMIX<span class="token punctuation">,</span> outputMixObject<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 将 SLDataLocator_OutputMix 结构体装载到 SLDataSink 中</span>
<span class="token comment">//  音频输出通过 loc_outmix 输出 , 实际上是通过 outputMixObject 混音器对象输出的</span>
SLDataSink audioSnk <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token operator">&amp;</span>loc_outmix<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑥ 创建并实现播放器 :
     </strong>
     <font color="blue">
      先使用 引擎 , 音源输入 , 音频输出 , 采样率 , 接口队列ID 等参数创建播放器 , 再实现播放器对象 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 操作队列接口 , 如果需要 特效接口 , 添加 SL_IID_EFFECTSEND</span>
<span class="token keyword">const</span> SLInterfaceID ids_player<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_IID_BUFFERQUEUE<span class="token punctuation">,</span> SL_IID_VOLUME<span class="token punctuation">,</span> SL_IID_EFFECTSEND<span class="token punctuation">,</span>
        <span class="token comment">/*SL_IID_MUTESOLO,*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> SLboolean req_player<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_BOOLEAN_TRUE<span class="token punctuation">,</span> SL_BOOLEAN_TRUE<span class="token punctuation">,</span> SL_BOOLEAN_TRUE<span class="token punctuation">,</span>
        <span class="token comment">/*SL_BOOLEAN_TRUE,*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        
<span class="token comment">// 创建播放器</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineEngine<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">CreateAudioPlayer</span><span class="token punctuation">(</span>
        engineEngine<span class="token punctuation">,</span>
        <span class="token operator">&amp;</span>bqPlayerObject<span class="token punctuation">,</span>
        <span class="token operator">&amp;</span>audioSrc<span class="token punctuation">,</span> <span class="token comment">//音频输入</span>
        <span class="token operator">&amp;</span>audioSnk<span class="token punctuation">,</span> <span class="token comment">//音频商户处</span>
        bqPlayerSampleRate<span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token comment">//</span>
        ids_player<span class="token punctuation">,</span>
        req_player<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token comment">// 创建播放器对象</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Realize</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_BOOLEAN_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑦ 获取播放器接口 和 缓冲队列接口 :
     </strong>
     <font color="magenta">
      获取的接口 对应 播放器创建时的接口 ID 数组参数 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 获取播放器 Player 接口 : 该接口用于设置播放器状态 , 开始 暂停 停止 播放 等操作</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_PLAY<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bqPlayerPlay<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 获取播放器 缓冲队列 接口 : 该接口用于控制 音频 缓冲区数据 播放</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_BUFFERQUEUE<span class="token punctuation">,</span>
                                         <span class="token operator">&amp;</span>bqPlayerBufferQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑧ 注册回调函数 :
     </strong>
     <font color="red">
      按照指定的回调函数类型 , 声明并实现该回调函数 , 并将该回调函数注册给播放器缓冲队列接口 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 注册缓冲区队列的回调函数 , 每次播放完数据后 , 会自动回调该函数</span>
<span class="token comment">//      传入参数 this , 就是 bqPlayerCallback 函数中的 context 参数</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerBufferQueue<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">RegisterCallback</span><span class="token punctuation">(</span>bqPlayerBufferQueue<span class="token punctuation">,</span> bqPlayerCallback<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      回调函数类型 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>SLAPIENTRY <span class="token operator">*</span>slAndroidSimpleBufferQueueCallback<span class="token punctuation">)</span><span class="token punctuation">(</span>
	SLAndroidSimpleBufferQueueItf caller<span class="token punctuation">,</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>pContext
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      回调函数实现 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//每当缓冲数据播放完毕后 , 会自动回调该回调函数</span>
<span class="token keyword">void</span> <span class="token function">bqPlayerCallback</span><span class="token punctuation">(</span>SLAndroidSimpleBufferQueueItf bq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>context<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
    <span class="token comment">//通过播放器队列接口 , 将 PCM 数据加入到该队列缓冲区后 , 就会自动播放这段音频</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>bq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Enqueue</span><span class="token punctuation">(</span>bq<span class="token punctuation">,</span> audioChannel<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span> data_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑨ 获取效果器接口 和 音量控制接口 :
     </strong>
     <font color="orange">
      这两个接口不是必须的 , 可选选项 ;
     </font>
    </p>
    <pre><code class="prism language-cpp">    <span class="token comment">// 获取效果器发送接口 ( get the effect send interface )</span>
    bqPlayerEffectSend <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">==</span> bqPlayerSampleRate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_EFFECTSEND<span class="token punctuation">,</span>
                                                 <span class="token operator">&amp;</span>bqPlayerEffectSend<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取音量控制接口 ( get the volume interface ) [ 如果需要调节音量可以获取该接口 ]</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_VOLUME<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bqPlayerVolume<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑩ 设置播放状态 :
     </strong>
     <font color="purple">
      设置播放状态为 SL_PLAYSTATE_PLAYING ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 设置播放器正在播放状态 ( set the player's state to playing )</span>
result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerPlay<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">SetPlayState</span><span class="token punctuation">(</span>bqPlayerPlay<span class="token punctuation">,</span> SL_PLAYSTATE_PLAYING<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <p>
     <strong>
      ⑪ 手动调用激活回调函数 :
     </strong>
     <font color="blue">
      第一次激活回调函数调用 , 需要手动激活 ;
     </font>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 手动激活 , 手动调用一次 bqPlayerCallback 回调函数</span>
<span class="token function">bqPlayerCallback</span><span class="token punctuation">(</span>bqPlayerBufferQueue<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp">    <span class="token comment">// I . 创建 OpenSLES 引擎并获取引擎的接口 ( 相关代码拷贝自 Google 官方示例 native-audio )</span>
    <span class="token comment">//      参考 : https://github.com/android/ndk-samples/blob/master/native-audio/app/src/main/cpp/native-audio-jni.c</span>

    <span class="token comment">//声明每个方法执行的返回结果 , 一般情况下返回 SL_RESULT_SUCCESS 即执行成功</span>
    <span class="token comment">//  该类型本质是 int 类型 , 定义的是各种类型的异常</span>
    SLresult result<span class="token punctuation">;</span>

    <span class="token comment">// 创建引擎</span>
    result <span class="token operator">=</span> <span class="token function">slCreateEngine</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>engineObject<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 返回 0 成功 , 否则失败 , 一旦失败就中断退出</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>

    <span class="token comment">// 实现引擎</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Realize</span><span class="token punctuation">(</span>engineObject<span class="token punctuation">,</span> SL_BOOLEAN_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>

    <span class="token comment">// 获取引擎接口 , 使用该接口创建输出混音器 , 音频播放器等其它对象</span>
    <span class="token comment">//      引擎对象不提供任何调用的方法 , 引擎调用的方法都定义在接口中</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>engineObject<span class="token punctuation">,</span> SL_IID_ENGINE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>engineEngine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>



    <span class="token comment">// II . 设置输出混音器</span>



    <span class="token comment">//  输出声音 , 添加各种音效 ( 混响 , 重低音 , 环绕音 , 均衡器 等 ) , 都要通过混音器实现 ;</span>

    <span class="token comment">// 创建输出混音器对象 , 可以指定一个混响效果参数 ( 该混淆参数可选 )</span>
    <span class="token keyword">const</span> SLInterfaceID ids_engine<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_IID_ENVIRONMENTALREVERB<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> SLboolean req_engine<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_BOOLEAN_FALSE<span class="token punctuation">}</span><span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineEngine<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">CreateOutputMix</span><span class="token punctuation">(</span>engineEngine<span class="token punctuation">,</span> <span class="token operator">&amp;</span>outputMixObject<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ids_engine<span class="token punctuation">,</span> req_engine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>

    <span class="token comment">// 实现输出混音器</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outputMixObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Realize</span><span class="token punctuation">(</span>outputMixObject<span class="token punctuation">,</span> SL_BOOLEAN_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>



    <span class="token comment">// III . 获取混响接口 并 设置混响 ( 可能会失败 )</span>


    <span class="token comment">// 获取环境混响接口</span>
    <span class="token comment">// 如果环境混响效果不可用 , 该操作可能失败</span>
    <span class="token comment">// either because the feature is not present, excessive CPU load, or</span>
    <span class="token comment">// the required MODIFY_AUDIO_SETTINGS permission was not requested and granted</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outputMixObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>outputMixObject<span class="token punctuation">,</span> SL_IID_ENVIRONMENTALREVERB<span class="token punctuation">,</span>
                                               <span class="token operator">&amp;</span>outputMixEnvironmentalReverb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>outputMixEnvironmentalReverb<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">SetEnvironmentalReverbProperties</span><span class="token punctuation">(</span>
                outputMixEnvironmentalReverb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reverbSettings<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>




    <span class="token comment">//IV . 配置音源输入</span>


    <span class="token comment">// 配置要播放的音频输入缓冲队列属性参数 , 缓冲区大小 , 音频格式 , 采样率 , 样本位数 , 通道数 , 样本大小端格式</span>
    SLDataLocator_AndroidSimpleBufferQueue loc_bufq <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">/*
        typedef struct SLDataFormat_PCM_ {
        SLuint32 		formatType;     //数据格式                 SL_DATAFORMAT_PCM
        SLuint32 		numChannels;    //通道数 , 左右声道 2个     2
        SLuint32 		samplesPerSec;  //采样率 44100Hz           SL_SAMPLINGRATE_44_1
        SLuint32 		bitsPerSample;  //采样位数 16位            SL_PCMSAMPLEFORMAT_FIXED_16
        SLuint32 		containerSize;  //容器大小                 SL_PCMSAMPLEFORMAT_FIXED_16
        SLuint32 		channelMask;    //通道        SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT
        SLuint32		endianness;     //小端格式                 SL_BYTEORDER_LITTLEENDIAN
    } SLDataFormat_PCM;
     */</span>
    SLDataFormat_PCM format_pcm <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_DATAFORMAT_PCM<span class="token punctuation">,</span>           <span class="token comment">//PCM 格式</span>
                                   <span class="token number">2</span><span class="token punctuation">,</span>                           <span class="token comment">//两个声道</span>
                                   SL_SAMPLINGRATE_44_1<span class="token punctuation">,</span>        <span class="token comment">//采样率 44100 Hz</span>
                                   SL_PCMSAMPLEFORMAT_FIXED_16<span class="token punctuation">,</span> <span class="token comment">//采样位数 16位</span>
                                   SL_PCMSAMPLEFORMAT_FIXED_16<span class="token punctuation">,</span> <span class="token comment">//容器为 16 位</span>
                                   SL_SPEAKER_FRONT_LEFT <span class="token operator">|</span> SL_SPEAKER_FRONT_RIGHT<span class="token punctuation">,</span>  <span class="token comment">//左右双声道</span>
                                   SL_BYTEORDER_LITTLEENDIAN<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//小端格式</span>

    <span class="token comment">// 设置音频数据源 , 配置缓冲区 ( loc_bufq ) 与 音频格式 (format_pcm)</span>
    SLDataSource audioSrc <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token operator">&amp;</span>loc_bufq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>format_pcm<span class="token punctuation">}</span><span class="token punctuation">;</span>



    <span class="token comment">// V . 配置音频输出</span>


    <span class="token comment">// 配置混音器 : 将 outputMixObject 混音器对象装载入 SLDataLocator_OutputMix 结构体中</span>
    SLDataLocator_OutputMix loc_outmix <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_DATALOCATOR_OUTPUTMIX<span class="token punctuation">,</span> outputMixObject<span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 将 SLDataLocator_OutputMix 结构体装载到 SLDataSink 中</span>
    <span class="token comment">//  音频输出通过 loc_outmix 输出 , 实际上是通过 outputMixObject 混音器对象输出的</span>
    SLDataSink audioSnk <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token operator">&amp;</span>loc_outmix<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>




    <span class="token comment">// VI . 创建并实现播放器</span>


    <span class="token comment">/*
     * 创建音频播放器:
     *      如果需要效果器时 , 不支持高性能音频
     *     ( fast audio does not support when SL_IID_EFFECTSEND is required, skip it
     *          for fast audio case )
     */</span>

    <span class="token comment">// 操作队列接口 , 如果需要 特效接口 , 添加 SL_IID_EFFECTSEND</span>
    <span class="token keyword">const</span> SLInterfaceID ids_player<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_IID_BUFFERQUEUE<span class="token punctuation">,</span> SL_IID_VOLUME<span class="token punctuation">,</span> SL_IID_EFFECTSEND<span class="token punctuation">,</span>
            <span class="token comment">/*SL_IID_MUTESOLO,*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> SLboolean req_player<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>SL_BOOLEAN_TRUE<span class="token punctuation">,</span> SL_BOOLEAN_TRUE<span class="token punctuation">,</span> SL_BOOLEAN_TRUE<span class="token punctuation">,</span>
            <span class="token comment">/*SL_BOOLEAN_TRUE,*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>


    <span class="token comment">// 创建播放器</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>engineEngine<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">CreateAudioPlayer</span><span class="token punctuation">(</span>
            engineEngine<span class="token punctuation">,</span>
            <span class="token operator">&amp;</span>bqPlayerObject<span class="token punctuation">,</span>
            <span class="token operator">&amp;</span>audioSrc<span class="token punctuation">,</span> <span class="token comment">//音频输入</span>
            <span class="token operator">&amp;</span>audioSnk<span class="token punctuation">,</span> <span class="token comment">//音频商户处</span>
            bqPlayerSampleRate<span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token comment">//</span>
            ids_player<span class="token punctuation">,</span>
            req_player<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>

    <span class="token comment">// 创建播放器对象</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Realize</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_BOOLEAN_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>



    <span class="token comment">// VII . 获取播放器接口 和 缓冲队列接口</span>


    <span class="token comment">// 获取播放器 Player 接口 : 该接口用于设置播放器状态 , 开始 暂停 停止 播放 等操作</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_PLAY<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bqPlayerPlay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>

    <span class="token comment">// 获取播放器 缓冲队列 接口 : 该接口用于控制 音频 缓冲区数据 播放</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_BUFFERQUEUE<span class="token punctuation">,</span>
                                             <span class="token operator">&amp;</span>bqPlayerBufferQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>




    <span class="token comment">// VIII . 注册回调函数</span>


    <span class="token comment">// 注册缓冲区队列的回调函数 , 每次播放完数据后 , 会自动回调该函数</span>
    <span class="token comment">//      传入参数 this , 就是 bqPlayerCallback 函数中的 context 参数</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerBufferQueue<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">RegisterCallback</span><span class="token punctuation">(</span>bqPlayerBufferQueue<span class="token punctuation">,</span> bqPlayerCallback<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>



    <span class="token comment">// IX . 获取效果器接口 和 音量控制接口 ( 不是必须的 )</span>


    <span class="token comment">// 获取效果器发送接口 ( get the effect send interface )</span>
    bqPlayerEffectSend <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">==</span> bqPlayerSampleRate<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_EFFECTSEND<span class="token punctuation">,</span>
                                                 <span class="token operator">&amp;</span>bqPlayerEffectSend<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token macro property">#<span class="token directive keyword">if</span> 0   </span><span class="token comment">// mute/solo is not supported for sources that are known to be mono, as this is</span>
    <span class="token comment">// get the mute/solo interface</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_MUTESOLO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bqPlayerMuteSolo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

    <span class="token comment">// 获取音量控制接口</span>

    <span class="token comment">// 获取音量控制接口 ( get the volume interface ) [ 如果需要调节音量可以获取该接口 ]</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerObject<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">GetInterface</span><span class="token punctuation">(</span>bqPlayerObject<span class="token punctuation">,</span> SL_IID_VOLUME<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bqPlayerVolume<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>



    <span class="token comment">// X . 设置播放状态</span>


    <span class="token comment">// 设置播放器正在播放状态 ( set the player's state to playing )</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bqPlayerPlay<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">SetPlayState</span><span class="token punctuation">(</span>bqPlayerPlay<span class="token punctuation">,</span> SL_PLAYSTATE_PLAYING<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>SL_RESULT_SUCCESS <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>result<span class="token punctuation">;</span>


    <span class="token comment">// XI. 手动调用激活回调函数</span>

    <span class="token comment">// 手动激活 , 手动调用一次 bqPlayerCallback 回调函数</span>
    <span class="token function">bqPlayerCallback</span><span class="token punctuation">(</span>bqPlayerBufferQueue<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     <strong>
      3 . bqPlayerCallback 回调函数 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//每当缓冲数据播放完毕后 , 会自动回调该回调函数</span>
<span class="token comment">// this callback handler is called every time a buffer finishes playing</span>
<span class="token keyword">void</span> <span class="token function">bqPlayerCallback</span><span class="token punctuation">(</span>SLAndroidSimpleBufferQueueItf bq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>context<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//获取 PCM 采样数据 , 将重采样的数据放到 data 中</span>
    <span class="token keyword">int</span> data_size <span class="token punctuation">;</span> 

	<span class="token comment">//进行 FFMPEG 音频重采样 ... 大块代码参考上一篇博客 </span>

    <span class="token comment">//开始播放</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> data_size <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token comment">//通过播放器队列接口 , 将 PCM 数据加入到该队列缓冲区后 , 就会自动播放这段音频</span>
        <span class="token comment">//  注意 , 最后一个参数是样本字节数</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>bq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">Enqueue</span><span class="token punctuation">(</span>bq<span class="token punctuation">,</span> audioChannel<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">,</span> data_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/shulianghan/article/details/104880199">
       【Android FFMPEG 开发】OpenSLES 播放音频 ( 创建引擎 | 输出混音设置 | 配置输入输出 | 创建播放器 | 获取播放/队列接口 | 回调函数 | 开始播放 | 激活回调 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="XII__FFMPEG__1761">
     </a>
     XII . FFMPEG 音视频同步
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . 音视频同步总结 :
     </strong>
    </p>
    <p>
     <font color="red">
      以音频播放的时间为基准 , 调整视频的播放速度 , 让视频与音频进行同步 ;
     </font>
    </p>
    <p>
     <font color="blue">
      先计算出音频的播放时间 ; 再计算视频的播放时间 ;
     </font>
    </p>
    <p>
     <font color="green">
      根据视频与音频之间的比较 , 如果视频比音频快 , 那么增大视频帧之间的间隔 , 降低视频帧绘制速度 ;
      <br/>
      如果视频比音频慢 , 那么需要丢弃部分视频帧 , 以追赶上音频的速度 ;
     </font>
    </p>
    <br/>
    <br/>
    <p>
     <strong>
      2 . 音视频同步代码示例 :
     </strong>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//根据帧率 ( fps ) 计算两次图像绘制之间的间隔</span>
<span class="token comment">//  注意单位换算 : 实际使用的是微秒单位 , 使用 av_usleep ( ) 方法时 , 需要传入微秒单位 , 后面需要乘以 10 万</span>
<span class="token keyword">double</span> frame_delay <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> fps<span class="token punctuation">;</span>


<span class="token keyword">while</span> <span class="token punctuation">(</span>isPlaying<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//从线程安全队列中获取 AVFrame * 图像</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
    <span class="token comment">//获取当前画面的相对播放时间 , 相对 : 即从播放开始到现在的时间</span>
    <span class="token comment">//  该值大多数情况下 , 与 pts 值是相同的</span>
    <span class="token comment">//  该值比 pts 更加精准 , 参考了更多的信息</span>
    <span class="token comment">//  转换成秒 : 这里要注意 pts 需要转成 秒 , 需要乘以 time_base 时间单位</span>
    <span class="token comment">//  其中 av_q2d 是将 AVRational 转为 double 类型</span>
    <span class="token keyword">double</span> vedio_best_effort_timestamp_second <span class="token operator">=</span> avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>best_effort_timestamp <span class="token operator">*</span> <span class="token function">av_q2d</span><span class="token punctuation">(</span>time_base<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//解码时 , 该值表示画面需要延迟多长时间在显示</span>
    <span class="token comment">//  extra_delay = repeat_pict / (2*fps)</span>
    <span class="token comment">//  需要使用该值 , 计算一个额外的延迟时间</span>
    <span class="token comment">//  这里按照文档中的注释 , 计算一个额外延迟时间</span>
    <span class="token keyword">double</span> extra_delay <span class="token operator">=</span> avFrame<span class="token operator">-</span><span class="token operator">&gt;</span>repeat_pict <span class="token operator">/</span> <span class="token punctuation">(</span> fps <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//计算总的帧间隔时间 , 这是真实的间隔时间</span>
    <span class="token keyword">double</span> total_frame_delay <span class="token operator">=</span> frame_delay <span class="token operator">+</span> extra_delay<span class="token punctuation">;</span>
    
    <span class="token comment">//将 total_frame_delay ( 单位 : 秒 ) , 转换成 微秒值 , 乘以 10 万</span>
    <span class="token keyword">unsigned</span> microseconds_total_frame_delay <span class="token operator">=</span> total_frame_delay <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>vedio_best_effort_timestamp_second <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
        <span class="token comment">//如果播放的是第一帧 , 或者当前音频没有播放 , 就要正常播放</span>
        <span class="token comment">//休眠 , 单位微秒 , 控制 FPS 帧率</span>
        <span class="token function">av_usleep</span><span class="token punctuation">(</span>microseconds_total_frame_delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
    
        <span class="token comment">//如果不是第一帧 , 要开始考虑音视频同步问题了</span>
        <span class="token comment">//获取音频的相对时间</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>audioChannel <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//音频的相对播放时间 , 这个是相对于播放开始的相对播放时间</span>
            <span class="token keyword">double</span> audio_pts_second <span class="token operator">=</span> audioChannel<span class="token operator">-</span><span class="token operator">&gt;</span>audio_pts_second<span class="token punctuation">;</span>
            
            <span class="token comment">//使用视频相对时间 - 音频相对时间</span>
            <span class="token keyword">double</span> second_delta <span class="token operator">=</span> vedio_best_effort_timestamp_second <span class="token operator">-</span> audio_pts_second<span class="token punctuation">;</span>
            
            <span class="token comment">//将相对时间转为 微秒单位</span>
            <span class="token keyword">unsigned</span> microseconds_delta <span class="token operator">=</span> second_delta <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>
            
            <span class="token comment">//如果 second_delta 大于 0 , 说明视频播放时间比较长 , 视频比音频快</span>
            <span class="token comment">//如果 second_delta 小于 0 , 说明视频播放时间比较短 , 视频比音频慢</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>second_delta <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            
                <span class="token comment">//视频快处理方案 : 增加休眠时间</span>
                <span class="token comment">//休眠 , 单位微秒 , 控制 FPS 帧率</span>
                <span class="token function">av_usleep</span><span class="token punctuation">(</span>microseconds_total_frame_delay <span class="token operator">+</span> microseconds_delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
                
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>second_delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            
                <span class="token comment">//视频慢处理方案 :</span>
                <span class="token comment">//  ① 方案 1 : 减小休眠时间 , 甚至不休眠</span>
                <span class="token comment">//  ② 方案 2 : 视频帧积压太多了 , 这里需要将视频帧丢弃 ( 比方案 1 极端 )</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>second_delta<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0.05</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                  
                    <span class="token comment">//丢弃解码后的视频帧</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                    
                    <span class="token comment">//终止本次循环 , 继续下一次视频帧绘制</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token keyword">if</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//如果音视频之间差距低于 0.05 秒 , 不操作 ( 50ms )</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


</code></pre>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/shulianghan/article/details/104891200">
       【Android FFMPEG 开发】FFMPEG 音视频同步 ( 音视频同步方案 | 视频帧 FPS 控制 | H.264 编码 I / P / B 帧 | PTS | 音视频同步 )
      </a>
     </p>
    </blockquote>
    <br/>
    <br/>
    <h5>
     <a id="XIII__GitHub__1869">
     </a>
     XIII . GitHub 代码地址
    </h5>
    <hr/>
    <br/>
    <p>
     <strong>
      1 . GitHub 代码地址 :
     </strong>
     <a href="https://github.com/han1202012/011_FFMPEG">
      FFMPEG 直播示例
     </a>
    </p>
    <p>
     <strong>
      2 . 效果展示 :
     </strong>
     <font color="blue">
      使用的是湖南卫视的直播源 rtmp://58.200.131.2:1935/livetv/hunantv
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/701b31bd4b8c46100f1adc14211de6f6.gif"/>
     </font>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f68616e313230323031322f:61727469636c652f64657461696c732f313034393030393634" class_="artid" style="display:none">
 </p>
</div>


