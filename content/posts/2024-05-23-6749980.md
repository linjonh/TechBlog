---
layout: post
title: "通信工具的音视频的网络传输实现"
date: 2024-05-23 16:14:01 +0800
description: "当下比较流行的即时通信工具，比如MSN，QQ等都实现了视音频的功能，通过视频，音频，我们可以更好的和"
keywords: "视频怎么在通信中传输"
categories: ['未分类']
tags: ['网络', '工具', '图形', 'Null', 'Graph', 'Filter']
artid: "6749980"
image:
  path: https://api.vvhan.com/api/bing?rand=sj&artid=6749980
  alt: "通信工具的音视频的网络传输实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=6749980
featuredImagePreview: https://bing.ee123.net/img/rand?artid=6749980
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     通信工具的音视频的网络传输实现
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <div>
     <p>
      当下比较流行的即时通信工具，比如MSN
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       QQ
      </span>
      <span style="font-family:宋体">
       等都实现了视音频的功能，通过视频，音频，我们可以更好的和朋友通过网络进行沟通，本文通过
      </span>
      <span style="font-family:Times New Roman">
       DirectShow
      </span>
      <span style="font-family:宋体">
       技术模拟
      </span>
      <span style="font-family:Times New Roman">
       QQ
      </span>
      <span style="font-family:宋体">
       实现了视频和音频的采集，传输，基本实现了
      </span>
      <span style="font-family:Times New Roman">
       QQ
      </span>
      <span style="font-family:宋体">
       的视音频聊天的功能。
      </span>
     </p>
     <p>
      网络音视频系统主要功能就在于视音频的采集，网络传输两个方面，通过Video Capture
      <span style="font-family:宋体">
       系列
      </span>
      <span style="font-family:Times New Roman">
       API
      </span>
      <span style="font-family:宋体">
       函数，你就可以轻松的搞定视频捕捉，但是对于视频的网络传输，则要费一番功夫了。
      </span>
      对于视音频数据的传输，只简单地使用数据报套接字传输音视频数据是不可行的，还必须在UDP
      <span style="font-family:宋体">
       层上采用
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       （实时传输协议）和
      </span>
      <span style="font-family:Times New Roman">
       RTCP
      </span>
      <span style="font-family:宋体">
       （实时传输控制协议）来改善服务质量。
      </span>
      实时传输协议提供具有实时特征的、端到端的数据传输服务。我们在音视频数据前插入包含有载荷标识、序号、时间戳和同步源标识符的
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       包头，然后利用数据报套接字在
      </span>
      <span style="font-family:Times New Roman">
       IP
      </span>
      <span style="font-family:宋体">
       网络上传输
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       包，以此改善连续重放效果和音视频同步。实时传输控制协议
      </span>
      <span style="font-family:Times New Roman">
       RTCP
      </span>
      <span style="font-family:宋体">
       用于
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       的控制，它最基本的功能是利用发送者报告和接收者报告来推断网络的服务质量，若拥塞状况严重，则改用低速率编码标准或降低数据传输比特率，以减少网络负荷，提供较好的
      </span>
      <span style="font-family:Times New Roman">
       Q.S
      </span>
      <span style="font-family:宋体">
       保证。
      </span>
     </p>
     <p>
      Directshow
      <span style="font-family:宋体">
       对于音视频的采集提供了很好的接口，利用
      </span>
      <span style="font-family:Times New Roman">
       ICaptureGraphBuilder2
      </span>
      <span style="font-family:宋体">
       接口可以很轻松的建立起视频捕捉的
      </span>
      <span style="font-family:Times New Roman">
       graph
      </span>
      <span style="font-family:宋体">
       图，通过枚举音频设备
      </span>
      <span style="font-family:Times New Roman">
       Filter
      </span>
      <span style="font-family:宋体">
       ，也可以很轻松的实现音频的捕捉
      </span>
      ，有点麻烦的是音视频数据的传输，我们可以自己封装
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       和
      </span>
      <span style="font-family:Times New Roman">
       RTCP
      </span>
      <span style="font-family:宋体">
       的协议，来自己实现一个
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       ，用来发送和接收音视频数据，当然了
      </span>
      <span style="font-family:Times New Roman">
       Directshow
      </span>
      <span style="font-family:宋体">
       也提供了一组支持使用
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       协议的网络传输多媒体流的
      </span>
      <span style="font-family:Times New Roman">
       Filters
      </span>
      <span style="font-family:宋体">
       。你也完全可以用
      </span>
      <span style="font-family:Times New Roman">
       Directshow
      </span>
      <span style="font-family:宋体">
       提供的
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       系列的
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       实现数据的传输。
      </span>
     </p>
     <p>
      下面分析一下这些RTP Filters
      <span style="font-family:宋体">
       。
      </span>
     </p>
     <p>
      新定义的Filter
      <span style="font-family:宋体">
       包括
      </span>
      <span style="font-family:Times New Roman">
       RTP Source Filter
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       RTP Render Filter
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       RTP Demux Filter
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       RTP Receive Playload Handler (RPH) filter
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       RTP Send Payload (SPH) filter
      </span>
      <span style="font-family:宋体">
       ，使用这
      </span>
      <span style="font-family:Times New Roman">
       5
      </span>
      <span style="font-family:宋体">
       个
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       构建一个通过
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       协议传输音视频数据的
      </span>
      <span style="font-family:Times New Roman">
       Graph
      </span>
      <span style="font-family:宋体">
       是没有问题的。
      </span>
     </p>
     <p>
      RTP Source filter
      <span style="font-family:宋体">
       被用来从一个单独的
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      会话中接收RTP
      <span style="font-family:宋体">
       和
      </span>
      <span style="font-family:Times New Roman">
       RTCP
      </span>
      <span style="font-family:宋体">
       包。这个
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       提供一个指定发送给其它主机
      </span>
      <span style="font-family:Times New Roman">
       RTCP
      </span>
      <span style="font-family:宋体">
       接收器报告和指定网络地址和端口接口来接收
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       会话的接口。
      </span>
     </p>
     <p>
      RTP Rend filter
      <span style="font-family:宋体">
       是用来将数据发到网络上的一个
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       ，这个
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       也提供了和
      </span>
      <span style="font-family:Times New Roman">
       RTP source Filter
      </span>
      类似的接口。
     </p>
     <p>
      RTP Demux filter
      <span style="font-family:宋体">
       用来多路分离来自
      </span>
      <span style="font-family:Times New Roman">
       RTP Source filter
      </span>
      <span style="font-family:宋体">
       的
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      包，这个filter
      <span style="font-family:宋体">
       有一个或者多个输出的
      </span>
      <span style="font-family:Times New Roman">
       pin
      </span>
      <span style="font-family:宋体">
       。这个
      </span>
      <span style="font-family:Times New Roman">
       Filter
      </span>
      <span style="font-family:宋体">
       提供了如何控制多路分离和如何分配到特定输出
      </span>
      <span style="font-family:Times New Roman">
       pin
      </span>
      <span style="font-family:宋体">
       的接口。
      </span>
     </p>
     <p>
      RTP RPH Filter 是用来网络过来的RTP
      <span style="font-family:宋体">
       包还原成原来的数据格式，主要支持
      </span>
      <span style="font-family:Times New Roman">
       H.261
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       H.263
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       Indeo
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       G.711
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       G.723
      </span>
      <span style="font-family:宋体">
       和
      </span>
      <span style="font-family:Times New Roman">
       G.729
      </span>
      <span style="font-family:宋体">
       和常见的多种音视频负载类型。
      </span>
     </p>
     <p>
      RTP SPH filter
      <span style="font-family:宋体">
       则和
      </span>
      <span style="font-family:Times New Roman">
       RPH filter
      </span>
      <span style="font-family:宋体">
       的功能相对，它的任务是将音视频 压缩
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       输出的
      </span>
      数据分解为RTP
      <span style="font-family:宋体">
       包，它提供的接口有指定最大生成包大小和
      </span>
      <span style="font-family:Times New Roman">
       pt
      </span>
      <span style="font-family:宋体">
       值。
      </span>
     </p>
     <p>
      下面我们看看如何用这些filter
      <span style="font-family:宋体">
       来搭建我们采集和传输的
      </span>
      <span style="font-family:Times New Roman">
       graph
      </span>
      <span style="font-family:宋体">
       图。
      </span>
     </p>
     <p>
      图1
      <span style="font-family:宋体">
       和图
      </span>
      <span style="font-family:Times New Roman">
       2
      </span>
      <span style="font-family:宋体">
       展示了
      </span>
      <span style="font-family:Times New Roman">
       DirectShow RTP
      </span>
      <span style="font-family:宋体">
       中定义的
      </span>
      <span style="font-family:Times New Roman">
       filters
      </span>
      <span style="font-family:宋体">
       如何运用。图
      </span>
      <span style="font-family:Times New Roman">
       1
      </span>
      <span style="font-family:宋体">
       是一个采集本地多媒体数据并使用
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       协议通过网络发送的
      </span>
      <span style="font-family:Times New Roman">
       filter graph
      </span>
      <span style="font-family:宋体">
       。它包含一个输出原始视频帧的视频采集
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       ，紧跟一个压缩帧的编码
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       。一旦压缩，这些帧就会被发送到
      </span>
      <span style="font-family:Times New Roman">
       RTP SPH filter
      </span>
      <span style="font-family:宋体">
       ，分片打包，生成
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       包，对应的发送到
      </span>
      <span style="font-family:Times New Roman">
       RTP Render filter
      </span>
      <span style="font-family:宋体">
       ，通过网络传输这些包。图
      </span>
      <span style="font-family:Times New Roman">
       2
      </span>
      <span style="font-family:宋体">
       展现了一个
      </span>
      <span style="font-family:Times New Roman">
       filter graph
      </span>
      <span style="font-family:宋体">
       ，用来接收包含视频流
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       包，播放视频。这个
      </span>
      <span style="font-family:Times New Roman">
       graph
      </span>
      <span style="font-family:宋体">
       由一个用来接收包的
      </span>
      <span style="font-family:Times New Roman">
       RTP Source filter
      </span>
      <span style="font-family:宋体">
       ，一个根据源和负载类型进行分类的
      </span>
      <span style="font-family:Times New Roman">
       RTP Demux filter
      </span>
      <span style="font-family:宋体">
       ，一个把
      </span>
      <span style="font-family:Times New Roman">
       RTP
      </span>
      <span style="font-family:宋体">
       包转为压缩视频帧的
      </span>
      <span style="font-family:Times New Roman">
       RTP RPH filter
      </span>
      <span style="font-family:宋体">
       组成。这些
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       随后的是用来解压帧的解码
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       ，一个显示未压缩帧的渲染
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       。
      </span>
     </p>
     <p>
      有了RTP filter
      <span style="font-family:宋体">
       的帮助我们就可以完成类似
      </span>
      <span style="font-family:Times New Roman">
       qq
      </span>
      <span style="font-family:宋体">
       的功能了，可以实现在网络上进行视频和音频的交互了，下面我给出在网络上两个客户端
      </span>
      <span style="font-family:Times New Roman">
       A
      </span>
      <span style="font-family:宋体">
       和
      </span>
      <span style="font-family:Times New Roman">
       B
      </span>
      <span style="font-family:宋体">
       进行音频和视频交互的
      </span>
      <span style="font-family:Times New Roman">
       Graph
      </span>
      <span style="font-family:宋体">
       图。这里我对图
      </span>
      <span style="font-family:Times New Roman">
       1
      </span>
      <span style="font-family:宋体">
       和图
      </span>
      <span style="font-family:Times New Roman">
       2
      </span>
      <span style="font-family:宋体">
       中的
      </span>
      <span style="font-family:Times New Roman">
       RTP filter
      </span>
      <span style="font-family:宋体">
       进行了自己封装，将编解码
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       直接封装到了
      </span>
      <span style="font-family:Times New Roman">
       RTP Source filter
      </span>
      <span style="font-family:宋体">
       和
      </span>
      <span style="font-family:Times New Roman">
       RTP Render filter
      </span>
      <span style="font-family:宋体">
       中，这样
      </span>
      <span style="font-family:Times New Roman">
       Graph
      </span>
      <span style="font-family:宋体">
       图就显得很简洁，
      </span>
      <span style="font-family:Times New Roman">
       RTP Source filter
      </span>
      <span style="font-family:宋体">
       只是用来接收网络过来的音视频数据，然后将数据传递给客户程序，
      </span>
      <span style="font-family:Times New Roman">
       RTP Render filter
      </span>
      <span style="font-family:宋体">
       则是将采集到的音视频数据发送到网络上的另一个客户端，编解码则的工作则封装到这两个
      </span>
      <span style="font-family:Times New Roman">
       filter
      </span>
      <span style="font-family:宋体">
       之中。
      </span>
     </p>
     <p>
      如果你也想自己封装自己的Source
      <span style="font-family:宋体">
       和
      </span>
      <span style="font-family:Times New Roman">
       Render filter
      </span>
      <span style="font-family:宋体">
       ，首先你要选择自己的编解码，视频编解码是选择
      </span>
      <span style="font-family:Times New Roman">
       H261
      </span>
      <span style="font-family:宋体">
       ，
      </span>
      <span style="font-family:Times New Roman">
       H263
      </span>
      <span style="font-family:宋体">
       ，还是
      </span>
      <span style="font-family:Times New Roman">
       MEPG4
      </span>
      <span style="font-family:宋体">
       ，音频是选择
      </span>
      <span style="font-family:Times New Roman">
       G729
      </span>
      <span style="font-family:宋体">
       还是
      </span>
      <span style="font-family:Times New Roman">
       G711
      </span>
      <span style="font-family:宋体">
       ，要首先确定好。选好编解码，封装的工作就简单了。
      </span>
     </p>
     <p>
      不多说了，下面看看我给出的代码吧。
     </p>
     <p>
      static const GUID CLSID_FG729Render = { 0x3556f7d8, 0x5b5, 0x4015, { 0xb9, 0x40, 0x65, 0xb8, 0x8, 0x94, 0xc8, 0xf9 } }; //音频发送
     </p>
     <p>
      static const GUID CLSID_FG729Source = { 0x290bf11a, 0x93b4, 0x4662, { 0xb1, 0xa3, 0xa, 0x53, 0x51, 0xeb, 0xe5, 0x8e } };//音频接收
     </p>
     <p>
      static const GUID CLSID_FH263Source = { 0xa0431ccf, 0x75db, 0x463e, { 0xb1, 0xcd, 0xe, 0x9d, 0xb6, 0x67, 0xba, 0x72 } };//视频接收
     </p>
     <p>
      static const GUID CLSID_FH263Render = { 0x787969cf, 0xc1b6, 0x41c5, { 0xba, 0xa8, 0x4e, 0xff, 0xa3, 0xdb, 0xe4, 0x1f } };//视频发送
     </p>
     <p>
      //发送和接收音视频数据的filter
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pAudioRtpRender ;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pAudioRtpSource ;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pVideoRtpRender ;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pVideoRtpSource ;
     </p>
     <p>
      char szClientA[100];
     </p>
     <p>
      int iVideoPort = 9937;
     </p>
     <p>
      int iAudioPort = 9938;
     </p>
     <p>
      //构建视频的graph图,并发送数据
     </p>
     <p>
      CComPtr&lt; IGraphBuilder &gt; m_pVideoGraphBuilder; //视频图形管理器
     </p>
     <p>
      CComPtr&lt; ICaptureGraphBuilder2 &gt; m_pVideoCapGraphBuilder;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pFilterVideoCap;
     </p>
     <p>
      CComPtr&lt; IVideoWindow &gt; m_pVideoWindow;
     </p>
     <p>
      CComPtr&lt; IMediaControl &gt; m_pVideoMediaCtrl ;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pVideoRenderFilter;
     </p>
     <p>
      HRESULT CMyDialog::VideoGraphInitAndSend(){
      <!-- -->
     </p>
     <p>
      HRESULT hr;
     </p>
     <p>
      hr =m_pVideoGraphBuilder.CoCreateInstance( CLSID_FilterGraph );
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      hr =m_pVideoCapGraphBuilder.CoCreateInstance( CLSID_CaptureGraphBuilder2);
     </p>
     <p>
      if(FAILED (hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pVideoCapGraphBuilder-&gt;SetFiltergraph(m_pVideoGraphBuilder);
     </p>
     <p>
      m_pVideoGraphBuilder-&gt;QueryInterface(IID_IMediaControl,(void**)&amp;m_pVideoMediaCtrl);
     </p>
     <p>
      m_pVideoGraphBuilder-&gt;QueryInterface(IID_IVideoWindow,(void**)&amp;m_pVideoWindow);
     </p>
     <p>
      FindDeviceFilter(&amp;m_pFilterVideoCap,CLSID_VideoInputDeviceCategory);
     </p>
     <p>
      if(m_pFilterVideoCap)
     </p>
     <p>
      m_pVideoGraphBuilder-&gt;AddFilter( m_pFilterVideoCap,T2W("VideoCap") ) ;
     </p>
     <p>
      //创建预览的filter
     </p>
     <p>
      hr = m_pRenderFilterVideo.CoCreateInstance(CLSID_VideoRenderer);
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pVideoGraphBuilder-&gt;AddFilter( m_pRenderFilterVideo, L"VideoRenderFilter" );
     </p>
     <p>
      Connect(m_pFilterVideoCap ,m_pRenderFilterVideo);
     </p>
     <p>
      //设置预览的窗口
     </p>
     <p>
      CRect rc ;
     </p>
     <p>
      GetClientRect(m_hOwnerWnd, &amp;rc );
     </p>
     <p>
      int iWidth = rc.right - rc.left ;
     </p>
     <p>
      int iHeight = rc.bottom - rc.top ;
     </p>
     <p>
      int iLeft, iTop;
     </p>
     <p>
      if((iHeight*1.0)/(iWidth*1.0) &gt;= 0.75){
      <!-- -->
     </p>
     <p>
      //按宽度算
     </p>
     <p>
      int tmpiHeight = iWidth*3/4;
     </p>
     <p>
      iTop = (iHeight - tmpiHeight)/2;
     </p>
     <p>
      int tmpiHeight = iWidth*3/4;
     </p>
     <p>
      iTop = (iHeight - tmpiHeight)/2;
     </p>
     <p>
      iHeight = tmpiHeight;
     </p>
     <p>
      iLeft = 0;
     </p>
     <p>
      }
     </p>
     <p>
      else
     </p>
     <p>
      {//按高度算
     </p>
     <p>
      int tmpiWidth = iHeight*4/3;
     </p>
     <p>
      iLeft = (iWidth - tmpiWidth)/2;
     </p>
     <p>
      iWidth = tmpiWidth;
     </p>
     <p>
      iTop = 0;
     </p>
     <p>
      }
     </p>
     <p>
      m_pVideoWindow-&gt;put_Owner( (OAHWND) m_hRenderWnd ) ;
     </p>
     <p>
      m_pVideoWindow-&gt;put_Visible( OATRUE );
     </p>
     <p>
      m_pVideoWindow-&gt;put_WindowStyle( WS_CHILD | WS_CLIPSIBLINGS ) ;
     </p>
     <p>
      m_pVideoMediaCtrl-&gt;Run();
     </p>
     <p>
      return S_OK;
     </p>
     <p>
      }
     </p>
     <p>
      //
     </p>
     <p>
      HRESULT FindDeviceFilter(IBaseFilter ** ppSrcFilter,GUID deviceGUID){
      <!-- -->
     </p>
     <p>
      HRESULT hr;
     </p>
     <p>
      IBaseFilter * pSrc = NULL;
     </p>
     <p>
      CComPtr &lt;IMoniker&gt; pMoniker =NULL;
     </p>
     <p>
      ULONG cFetched;
     </p>
     <p>
      if (!ppSrcFilter)
     </p>
     <p>
      return E_POINTER;
     </p>
     <p>
      // Create the system device enumerator
     </p>
     <p>
      CComPtr &lt;ICreateDevEnum&gt; pDevEnum =NULL;
     </p>
     <p>
      hr = CoCreateInstance (CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC,IID_ICreateDevEnum, (void **) &amp;pDevEnum);
     </p>
     <p>
      if (FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      // Create an enumerator for the video capture devices
     </p>
     <p>
      CComPtr &lt;IEnumMoniker&gt; pClassEnum = NULL;
     </p>
     <p>
      hr = pDevEnum-&gt;CreateClassEnumerator (deviceGUID, &amp;pClassEnum, 0);
     </p>
     <p>
      if (FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      if (pClassEnum == NULL)
     </p>
     <p>
      return E_FAIL;
     </p>
     <p>
      if (S_OK == (pClassEnum-&gt;Next (1, &amp;pMoniker, &amp;cFetched)))
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      hr = pMoniker-&gt;BindToObject(0,0,IID_IBaseFilter, (void**)&amp;pSrc);
     </p>
     <p>
      if (FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      }
     </p>
     <p>
      else
     </p>
     <p>
      return E_FAIL;
     </p>
     <p>
      *ppSrcFilter = pSrc;
     </p>
     <p>
      return S_OK;
     </p>
     <p>
      }
     </p>
     <p>
      //构建音频Graph图，并发送
     </p>
     <p>
      CComPtr&lt; IGraphBuilder &gt; m_pAudioGraphBuilder; //音频图形管理器
     </p>
     <p>
      CComPtr&lt; ICaptureGraphBuilder2 &gt; m_pCapAudioGraphBuilder;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pFilterAudioCap;
     </p>
     <p>
      CComPtr&lt; IMediaControl &gt; m_pAudioMediaCtrl ;
     </p>
     <p>
      HRESULT AudioGraphInit()
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      HRESULT hr;
     </p>
     <p>
      hr =m_pAudioGraphBuilder.CoCreateInstance( CLSID_FilterGraph );
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      hr =m_pCapAudioGraphBuilder.CoCreateInstance( CLSID_CaptureGraphBuilder2);
     </p>
     <p>
      if(FAILED (hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;SetFiltergraph(m_pCapAudioGraphBuilder);
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;m_pAudioMediaCtrl);
     </p>
     <p>
      FindDeviceFilter(&amp;m_pFilterVideoCap,CLSID_AudioInputDeviceCategory);
     </p>
     <p>
      if(m_pFilterAudioCap)
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;AddFilter( m_pFilterAudioCap,T2W("AudioCap") ) ;
     </p>
     <p>
      //发送到网络
     </p>
     <p>
      hr =::CoCreateInstance(CLSID_FG729Render,NULL,CLSCTX_INPROC,
     </p>
     <p>
      IID_IBaseFilter,(void**)&amp;m_pFilterRtpSendAudio)
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;AddFilter(m_pAudioRtpRender, L"FilterRtpSendAudio");
     </p>
     <p>
      Connect(m_pFilterAudioCap,m_pAudioRtpRender);
     </p>
     <p>
      CComPtr&lt; IRtpOption &gt; pOption ;
     </p>
     <p>
      m_pAudioRtpRender-&gt;QueryInterface(IID_IJRTPOption,(void**)&amp;pOption);
     </p>
     <p>
      hr =pOption-&gt;Connect(szClientA,iAudioPort,1024);
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pAudioMediaCtrl-&gt;Run();
     </p>
     <p>
      return S_OK;}
     </p>
     <p>
      //音频的接收
     </p>
     <p>
      CComPtr&lt; IGraphBuilder &gt; m_pAudioGraphBuilder; //音频图形管理器
     </p>
     <p>
      CComPtr&lt; ICaptureGraphBuilder2 &gt; m_pCapAudioGraphBuilder;
     </p>
     <p>
      CComPtr&lt; IBaseFilter &gt; m_pFilterAudioCap;
     </p>
     <p>
      CComPtr&lt; IMediaControl &gt; m_pAudioMediaCtrl ;
     </p>
     <p>
      CComPtr&lt;IBaseFilter&gt; m_pAudioRender;
     </p>
     <p>
      HRESULT AudioRecive()
     </p>
     <p>
      {
      <!-- -->
     </p>
     <p>
      HRESULT hr;
     </p>
     <p>
      hr =m_pAudioGraphBuilder.CoCreateInstance( CLSID_FilterGraph );
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;m_pAudioMediaCtrl);
     </p>
     <p>
      hr = m_pAudioRtpSource-&gt;CoCreateInstance(CLSID_FG729Source) ;
     </p>
     <p>
      if(FAILED(hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;AddFilter(m_pAudioRtpSource,L"AudioRtp");
     </p>
     <p>
      //创建声卡Renderfilter
     </p>
     <p>
      FindDeviceFilter(&amp;m_pAudioRender,CLSID_AudioRendererCategory);
     </p>
     <p>
      m_pAudioGraphBuilder-&gt;AddFilter(m_pAudioRender,L"AudioRender");
     </p>
     <p>
      CComPtr&lt; IRtpOption &gt; pRtpOption ;
     </p>
     <p>
      m_pAudioRtpSource-&gt;QueryInterface(IID_IJRTPOption,(void**)&amp;pRtpOption);
     </p>
     <p>
      hr= pRtpOption-&gt;Connect(szClientA,iAudioPort+2,1024);
     </p>
     <p>
      if(FAILED (hr))
     </p>
     <p>
      return hr;
     </p>
     <p>
      Connect(m_pAudioRtpSource,m_pAudioRender);
     </p>
     <p>
      m_pAudioMediaCtrl-&gt;Run();
     </p>
     <p>
      return S_OK;
     </p>
     <p>
      }
     </p>
    </div>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f666f726d6973:732f61727469636c652f64657461696c732f36373439393830" class_="artid" style="display:none">
 </p>
</div>
