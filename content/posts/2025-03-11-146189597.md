---
layout: post
title: "05.基于-TCP-的远程计算器从协议设计到高并发实现"
date: 2025-03-11 21:33:01 +0800
description: "计算机网络的核心就是通信。"
keywords: "05.基于 TCP 的远程计算器：从协议设计到高并发实现"
categories: ['计算机网络']
tags: ['网络协议', '网络', '算法', 'Vscode', 'Tcp', 'Linux', 'C']
artid: "146189597"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146189597
    alt: "05.基于-TCP-的远程计算器从协议设计到高并发实现"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146189597
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146189597
cover: https://bing.ee123.net/img/rand?artid=146189597
image: https://bing.ee123.net/img/rand?artid=146189597
img: https://bing.ee123.net/img/rand?artid=146189597
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     05.基于 TCP 的远程计算器：从协议设计到高并发实现
    </h1>
   </div>
   <div class="article-resource-info-box">
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="__1">
     </a>
     <strong>
      📖 目录
     </strong>
    </h2>
    <ol>
     <li>
      <strong>
       📌 前言
      </strong>
     </li>
     <li>
      <strong>
       🔍 需求分析
      </strong>
      <ul>
       <li>
        🤔 我们需要解决哪些问题？
       </li>
      </ul>
     </li>
     <li>
      <strong>
       🎯 方案设计
      </strong>
      <ul>
       <li>
        💡 服务器架构
       </li>
      </ul>
     </li>
     <li>
      <strong>
       🚀 什么是协议？为什么要设计协议？
      </strong>
      <ul>
       <li>
        📌 结构化数据的传输问题
       </li>
      </ul>
     </li>
     <li>
      <strong>
       📌 协议定制：如何让服务器正确解析数据？
      </strong>
      <ul>
       <li>
        ❌ TCP 直接传输的问题
       </li>
       <li>
        ✅ 解决方案：在数据前加上长度信息
       </li>
      </ul>
     </li>
     <li>
      <strong>
       📌 序列化与反序列化：如何让数据更容易解析？
      </strong>
      <ul>
       <li>
        📌 什么是序列化？
       </li>
       <li>
        📌 选择合适的序列化方式
       </li>
       <li>
        📜 通信协议设计
       </li>
      </ul>
     </li>
     <li>
      <strong>
       🔧 核心代码解析
      </strong>
      <ul>
       <li>
        🔹 协议封装
       </li>
       <li>
        🔹 解析数据
       </li>
       <li>
        🔹 服务器处理请求
       </li>
       <li>
        🔹 网络通信的实现
       </li>
       <li>
        🔹 服务器并发处理模型
       </li>
       <li>
        🔹 客户端请求的发送与接收
       </li>
      </ul>
     </li>
     <li>
      <strong>
       🚀 还有哪些可以改进的地方？
      </strong>
      <ul>
       <li>
        🛠 采用更高效的并发模型
       </li>
       <li>
        🔒 增加安全性
       </li>
       <li>
        📡 支持更丰富的计算功能
       </li>
       <li>
        📈 增强日志与监控
       </li>
       <li>
        🌍 让它支持更多设备（跨平台 &amp; Web 访问）
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h2>
     <a id="_1__33">
     </a>
     <strong>
      📌 1. 前言
     </strong>
    </h2>
    <p>
     计算机网络的核心就是通信。远程计算就是一个很好的例子：
    </p>
    <ul>
     <li>
      <strong>
       本地客户端
      </strong>
      负责发送计算请求（如
      <code>
       10 + 20
      </code>
      ）
     </li>
     <li>
      <strong>
       远程服务器
      </strong>
      负责解析、计算，并返回结果（如
      <code>
       30
      </code>
      ）
     </li>
    </ul>
    <p>
     这个项目的目标是：
     <strong>
      实现一个基于 TCP 的远程计算服务
     </strong>
     ，让多个客户端同时发送计算请求，服务器解析并返回结果。
    </p>
    <hr/>
    <h2>
     <a id="_2__44">
     </a>
     <strong>
      🔍 2. 需求分析
     </strong>
    </h2>
    <h4>
     <a id="__46">
     </a>
     <strong>
      🤔 我们需要解决哪些问题？
     </strong>
    </h4>
    <p>
     <strong>
      1. 计算器的核心功能
     </strong>
    </p>
    <ul>
     <li>
      支持基本的
      <code>
       + - * / %
      </code>
      运算
     </li>
     <li>
      远程计算，客户端发送计算请求，服务器计算并返回结果
     </li>
     <li>
      处理异常情况（如除零）
     </li>
    </ul>
    <p>
     <strong>
      2. 网络通信的挑战
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       如何保证数据完整性？
      </strong>
      （TCP 是
      <strong>
       流式传输
      </strong>
      ，可能会粘包）
     </li>
     <li>
      <strong>
       如何解析数据？
      </strong>
      （客户端发送的
      <code>
       10 + 20
      </code>
      ，服务器怎么拆解？）
     </li>
     <li>
      <strong>
       如何支持多个客户端？
      </strong>
      （服务器要能并发处理请求）
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="_3__62">
     </a>
     <strong>
      🎯 3. 方案设计
     </strong>
    </h2>
    <h4>
     <a id="__64">
     </a>
     <strong>
      💡 服务器架构
     </strong>
    </h4>
    <pre><code>[ 客户端 ]      &lt;--TCP--&gt;     [ 服务器 ]
     |                               |
     |-- 用户输入                   |-- 解析请求
     |-- 发送计算式                 |-- 计算结果
     |-- 显示运算结果               |-- 发送结果
</code></pre>
    <hr/>
    <h2>
     <a id="_4__76">
     </a>
     <strong>
      🚀 4. 什么是协议？为什么要设计协议？
     </strong>
    </h2>
    <p>
     在计算机网络中，不同的设备想要互相通信，就必须
     <strong>
      说同一种语言
     </strong>
     ，否则就会鸡同鸭讲，无法理解对方的信息。而这种“语言”，在网络编程中就被称为
     <strong>
      协议（Protocol）
     </strong>
     。
    </p>
    <p>
     这篇文章，我们就从
     <strong>
      协议的概念
     </strong>
     出发，一步步拆解如何基于
     <strong>
      TCP
     </strong>
     实现一个“远程计算器”服务，让客户端通过网络发送计算请求，服务器收到请求后计算结果并返回给客户端。
    </p>
    <hr/>
    <h2>
     <a id="_5__84">
     </a>
     <strong>
      📌 5. 协议定制：如何让服务器正确解析数据？
     </strong>
    </h2>
    <h4>
     <a id="_TCP__86">
     </a>
     <strong>
      ❌ TCP 直接传输的问题
     </strong>
    </h4>
    <p>
     TCP 是
     <strong>
      面向流的协议
     </strong>
     ，它不会帮我们划分数据边界，导致以下问题：
    </p>
    <ol>
     <li>
      <strong>
       粘包问题（多个小数据包合并）
      </strong>
     </li>
     <li>
      <strong>
       拆包问题（一个大数据包被拆成多部分）
      </strong>
     </li>
    </ol>
    <h4>
     <a id="__93">
     </a>
     <strong>
      ✅ 解决方案：在数据前加上长度信息
     </strong>
    </h4>
    <p>
     在数据包前加上
     <strong>
      固定长度的头部
     </strong>
     ，存储数据长度：
    </p>
    <pre><code>[数据长度][计算表达式]
</code></pre>
    <hr/>
    <h2>
     <a id="_6__103">
     </a>
     <strong>
      📌 6. 序列化与反序列化：如何让数据更容易解析？
     </strong>
    </h2>
    <h4>
     <a id="__105">
     </a>
     <strong>
      📌 什么是序列化？
     </strong>
    </h4>
    <p>
     序列化（Serialization）就是
     <strong>
      将数据转换为可传输的格式
     </strong>
     ，然后在接收端
     <strong>
      反序列化
     </strong>
     （Deserialization）回原始格式。
    </p>
    <h4>
     <a id="__109">
     </a>
     <strong>
      📌 选择合适的序列化方式
     </strong>
    </h4>
    <p>
     这里我们采用
     <strong>
      JSON
     </strong>
     ，因为它易读易解析。
    </p>
    <h4>
     <a id="__113">
     </a>
     <strong>
      📜 通信协议设计
     </strong>
    </h4>
    <p>
     客户端发送的 JSON 请求格式如下：
    </p>
    <pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"expr"</span><span class="token operator">:</span> <span class="token string">"10+20"</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     服务器返回的 JSON 结果格式如下：
    </p>
    <pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"result"</span><span class="token operator">:</span> <span class="token number">30</span>
<span class="token punctuation">}</span>
</code></pre>
    <hr/>
    <h2>
     <a id="_7__133">
     </a>
     <strong>
      🔧 7. 核心代码解析
     </strong>
    </h2>
    <h3>
     <a id="__135">
     </a>
     <strong>
      🔹 协议封装
     </strong>
    </h3>
    <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">encode_request</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> expr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    json j<span class="token punctuation">;</span>
    j<span class="token punctuation">[</span><span class="token string">"expr"</span><span class="token punctuation">]</span> <span class="token operator">=</span> expr<span class="token punctuation">;</span>
    <span class="token keyword">return</span> j<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="__146">
     </a>
     <strong>
      🔹 解析数据
     </strong>
    </h3>
    <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">decode_response</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> response<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    json j <span class="token operator">=</span> json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> j<span class="token punctuation">[</span><span class="token string">"result"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="__156">
     </a>
     <strong>
      🔹 服务器处理请求
     </strong>
    </h3>
    <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">process_request</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> request<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    json j <span class="token operator">=</span> json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string expr <span class="token operator">=</span> j<span class="token punctuation">[</span><span class="token string">"expr"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算表达式</span>
    json response<span class="token punctuation">;</span>
    response<span class="token punctuation">[</span><span class="token string">"result"</span><span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>
    <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="__170">
     </a>
     <strong>
      🔹 网络通信的实现
     </strong>
    </h3>
    <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">handle_client</span><span class="token punctuation">(</span><span class="token keyword">int</span> client_sock<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>client_sock<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    std<span class="token double-colon punctuation">::</span>string response <span class="token operator">=</span> <span class="token function">process_request</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">send</span><span class="token punctuation">(</span>client_sock<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>client_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="__185">
     </a>
     <strong>
      🔹 服务器并发处理模型
     </strong>
    </h3>
    <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">start_server</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> server_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
    
    <span class="token function">bind</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">listen</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> client_sock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>handle_client<span class="token punctuation">,</span> client_sock<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="__204">
     </a>
     <strong>
      🔹 客户端请求的发送与接收
     </strong>
    </h3>
    <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">send_request</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> expr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>
    
    <span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    std<span class="token double-colon punctuation">::</span>string request <span class="token operator">=</span> <span class="token function">encode_request</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Server response: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">decode_response</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    
    <span class="token function">close</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="_225">
     </a>
     最终效果
    </h3>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2717f4d656794145b64e3c8e7a3afa44.png"/>
    </p>
    <h2>
     <a id="_8__228">
     </a>
     <strong>
      🚀 8. 还有哪些可以改进的地方？
     </strong>
    </h2>
    <p>
     虽然我们的远程计算器已经可以正常工作，但仍然有许多优化空间。下面列出了一些可以改进的方向，并给出大致的思路：
    </p>
    <h4>
     <a id="_1__233">
     </a>
     <strong>
      🛠 1. 采用更高效的并发模型
     </strong>
    </h4>
    <p>
     目前服务器采用
     <strong>
      多进程
     </strong>
     方式处理多个客户端，但每次连接都会
     <code>
      fork()
     </code>
     一个子进程，进程创建和回收的开销较大。如果连接数增加，性能可能会下降。
    </p>
    <p>
     ✅
     <strong>
      改进方向
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       线程池
      </strong>
      ：可以使用
      <code>
       std::thread
      </code>
      + 线程池，避免频繁创建/销毁进程，提高并发能力。
     </li>
     <li>
      <strong>
       <code>
        epoll
       </code>
       /
       <code>
        select
       </code>
      </strong>
      ：基于 I/O 复用的方式，实现
      <strong>
       单进程管理多个连接
      </strong>
      ，减少资源占用。
     </li>
     <li>
      <strong>
       协程方案
      </strong>
      ：使用
      <code>
       libco
      </code>
      或
      <code>
       Boost.Asio
      </code>
      实现高并发的计算服务。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_2__245">
     </a>
     <strong>
      🔒 2. 增加安全性
     </strong>
    </h4>
    <p>
     目前客户端可以随意输入数据，如果用户输入了
     <code>
      "100 / 0"
     </code>
     ，就会导致
     <strong>
      除零异常
     </strong>
     。此外，服务器目前
     <strong>
      没有身份验证机制
     </strong>
     ，任何人都可以连接并发送计算请求。
    </p>
    <p>
     ✅
     <strong>
      改进方向
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       输入校验
      </p>
      <p>
       ：在解析
      </p>
      <pre><code>x op y
</code></pre>
      <p>
       之前，检查运算是否合法，比如：
      </p>
      <pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">"ERROR: Division by zero"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        身份验证
       </strong>
       ：可以添加
       <strong>
        用户名 + 密码
       </strong>
       认证，确保只有授权用户才能访问计算服务。
      </p>
     </li>
     <li>
      <p>
       <strong>
        SQL 注入防护
       </strong>
       （如果涉及数据库）
      </p>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_3__273">
     </a>
     <strong>
      📡 3. 支持更丰富的计算功能
     </strong>
    </h4>
    <p>
     目前计算器只支持
     <code>
      + - * / %
     </code>
     ，如果想让它更强大，可以扩展为
     <strong>
      数学计算引擎
     </strong>
     ，支持
     <strong>
      sin()、cos()、log()、pow()
     </strong>
     等函数。
    </p>
    <p>
     ✅
     <strong>
      改进方向
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       解析数学表达式
      </strong>
      ：可以用
      <code>
       Shunting Yard Algorithm
      </code>
      解析复杂表达式，如
      <code>
       3 + 5 * (2 - 8) / sin(30)
      </code>
      。
     </li>
     <li>
      <strong>
       结合开源数学库
      </strong>
      ：如
      <code>
       ExprTk
      </code>
      解析数学表达式，甚至支持微积分计算。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_4__284">
     </a>
     <strong>
      📈 4. 增强日志与监控
     </strong>
    </h4>
    <p>
     目前服务器
     <strong>
      没有日志系统
     </strong>
     ，如果某个请求失败，我们很难知道
     <strong>
      发生了什么问题
     </strong>
     。
    </p>
    <p>
     ✅
     <strong>
      改进方向
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       日志系统
      </strong>
      ：使用
      <code>
       log4cpp
      </code>
      或
      <code>
       spdlog
      </code>
      记录服务器运行状态，方便排查问题。
     </li>
     <li>
      <strong>
       监控系统
      </strong>
      ：可以结合
      <code>
       Prometheus + Grafana
      </code>
      监控请求数量、CPU 使用率等数据，确保服务器稳定运行。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_5___Web__295">
     </a>
     <strong>
      🌍 5. 让它支持更多设备（跨平台 &amp; Web 访问）
     </strong>
    </h4>
    <p>
     目前我们的计算器是
     <strong>
      C++ 客户端 + C++ 服务器
     </strong>
     ，但如果想要让
     <strong>
      网页、手机、Python 脚本
     </strong>
     也能调用计算服务，我们可以提供一个
     <strong>
      HTTP API
     </strong>
     或
     <strong>
      WebSocket
     </strong>
     版本。
    </p>
    <p>
     ✅
     <strong>
      改进方向
     </strong>
     ：
    </p>
    <ul>
     <li>
      <p>
       RESTful API
      </p>
      <p>
       ：让客户端用
      </p>
      <pre><code>curl
</code></pre>
      <p>
       或
      </p>
      <pre><code>Python
</code></pre>
      <p>
       直接调用：
      </p>
      <pre><code>GET /calculate?expr=10+2 HTTP/1.1
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        WebSocket 支持
       </strong>
       ：让前端网页也能实时计算。
      </p>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f796f7563686f75313237342f:61727469636c652f64657461696c732f313436313839353937" class_="artid" style="display:none">
 </p>
</div>


