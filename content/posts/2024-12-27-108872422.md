---
arturl_encode: "68747470733a2f2f626c6f67:2e6373646e2e6e65742f62616964755f33333537353733372f:61727469636c652f64657461696c732f313038383732343232"
layout: post
title: Java中的byte详解
date: 2024-12-27 21:36:12 +0800
description: "本文深入探讨Java中的byte类型，包括其取值范"
keywords: java byte
categories: ['Java']
tags: ['Java', 'Android']
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=108872422
    alt: Java中的byte详解
artid: 108872422
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=108872422
featuredImagePreview: https://bing.ee123.net/img/rand?artid=108872422
---

# Java中的byte详解

## Java中的byte详解

### 介绍

byte，即字节，由8位的二进制组成。在Java中，byte类型的数据是8位带符号的二进制数。

在计算机中，8位带符号二进制数的取值范围是[-128, 127]，所以在Java中，byte类型的取值范围也是[-128, 127]。

### byte取值范围分析

一直在想为什么不是 -128 到 128呢？今天分析了一下这个问题。

首先我们得明白一件事情，那就是运算规则(因为计算机中的数是以反码形式存储的，反码再求反码得到该数真值)：

> 正数的最高位都是 0 ，正数的值就是二进制表示的值。
>
> 负数的最高位都是 1 ，负数的值是 取反后加一 然后加个负号得到得值。

我们用8位的二进制来说明一下此规则：

比如：00000001。最高位是0 为正数 ，那么表示的就是 十进制的 1。

再比如：10000001.最高位是1 为负数，值是多少？取反得到 01111110 加1 得到 01111111 ，那么值为 -127 (可能你会有疑问了？why？-127不是应该是1111 1111，先不急，可以去看下面要说的 反码，你就懂了)

理解此运算规则我们正式开始说byte，byte正好是8位的二进制数。short是16位 int是32位 long是64位。

> 不难理解，byte的最大正数就是 01111111（最高位必须是0），也就是 127。

那么你可能会想 byte的最小负数就是 11111111 了，对不对? 这么想就

大错特错了。让我们看看11111111这个二进制数表示多少。

根据上面的提示 我们知道这是一个负数。它的值是先取反再加1 。

11111111取反得到：00000000，加1得到 00000001 。最后得到的值为-1.

这可是最大的负数啊。由此你是不是想到了最小的负数会不会是10000000呢？

> 让我们算一下 取反：01111111 加1得到 10000000 最后得到 -128.

127是01111111 然而 -128是10000000 ，看出来一个奇怪的事情。

仔细的看一下这两个二进制数 是不是前者加1就得到后者呢？对。

**可以编一个小程序实验一下：**

```java
byte a = 127; 
a+=1; 
System.out.println(a);

```

结果正好是-128

> 由此我们可以看出来二进制从 00000000 到01111111到10000000到 11111111
>
> 即 十进制从 0 到 127 到 -128 到 -1。

**接下来，我们用一段代码来更深刻地理解byte：**

```java
public class A {
 public static void main(String[] args) {
  int b = 456;
  byte test = (byte) b;
  System.out.println(test);
 }
}

```

上述代码，最后会输出-56。原因如下：

456的二进制表示是111001000，由于int是32位的二进制，所以在计算机中，实际上是00000000000……111001000，
**当int转成byte的时候，那么计算机会只保留最后8位，即11001000**
。

然后11001000的最高位是1，那么表示是一个负数，而负数在计算机中都是以补码的形式保存的，所以我们计算11001000的原码为00111000，即56，所以11001000表示的是-56，所以最后test的值为-56。

### byte\short\int\long

**java中存储的数据类型均带符号,即看最高位:为0表示正数,为1表示负数**

| 类型 | 字节数 | bit位数 | 取值范围 |
| --- | --- | --- | --- |
| byte | 1 | 8 | -128到127 |
| short | 2 | 16 | -2 15到2 15-1 |
| int | 4 | 32 | -2 31到2 31-1 |
| long | 8 | 64 | -2 63到2 63-1 |

### 原码\反码\补码

> 原码：就是二进制码，最高位为符号位，0表示正数，1表示负数，剩余部分表示真值。
>
> 反码：在原码的基础上，正数反码就是他本身，负数除符号位之外全部按位取 反。
>
> 补码：正数的补码就是自己本身， 负数的补码是在自身反码的基础上加1.

### 逻辑运算符

**包含: &（与）, | （或）, ^ （异或），~ （按位取反）**

> & :当2个都为1的时候为1， 其他都是0 。 1&1 = 1， 1&0 = 0， 0&0 = 0； 他的作用是清0
>
> | : 当2个只要有一个为1，就是1. 1|0 = 1; 0|0 = 0, 1|1 = 1;
>
> ^: 相同为0， 不相同为1， 1^0 = 1, 1^1 = 0, 0^0 = 0; 他的作用是定位翻转。
>
> ~: 按位取反，0变为1， 1变为0；

之所以要明确原码，反码，补码，
**是因为java中变量都是以补码的形式保存的。**

比如 整行30 他的原码是：0001 1110. 正数，所以反码，补码都是0001 1110.

对于负数：-7 ，他的原码是 1000 0111， 第一位1表示是此数是负数。他的反码是：1111 1000, 补码在反码的基础上加1， 所以它的补码是1111 1001， 所以他的二进制数就是1111 1001.

如“-16+11”的运算：

```java
11110000     + -16的补码
00001011       11的补码
————
11111011       - 5的补码

```

### 移位操作符

**包含:<<, >>, >>>**

> **<< 表示左移，不分正负数，丢去高位,低位补0,如果移动的位数大于32， 那么就需要取余**
> (例如下方<<10等价于<<2)

注：以下数据类型默认为byte-8位

左移时不管正负，低位补0

正数：
**r = 20 << 2**

20的二进制补码：
**0001 0100**

向左移动两位后：
**0101 0000**

结果：
**r = 80**

负数：
**r = -20 << 2**

-20 的二进制原码 ：
**1001 0100**

-20 的二进制反码 \*\*
*\*：\*
*1110 1011**

-20 的二进制补码 ：
**1110 1100**

左移两位后的补码：
**1011 0000**

反码：
**1010 1111**

原码：
**1101 0000**

结果：
**r = -80**

> **>>表示右移，如果该数为正，则高位补0，若为负数，则高位补1**

注：以下数据类型默认为byte-8位

正数：r = 20 >> 2

20的二进制补码：0001 0100

向右移动两位后：0000 0101

结果：r = 5

负数：r = -20 >> 2

-20 的二进制原码 ：1001 0100

-20 的二进制反码 ：1110 1011

-20 的二进制补码 ：1110 1100

右移两位后的补码：1111 1011

反码：1111 1010

原码：1000 0101

结果：r = -5

> **>>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0**

正数：　r = 20 >>> 2

的结果与 r = 20 >> 2 相同；

负数：　r = -20 >>> 2

注：以下数据类型默认为int 32位

-20:源码：10000000 00000000 00000000 00010100

反码：11111111 11111111 11111111 11101011

补码：11111111 11111111 11111111 11101100

右移：00111111 11111111 11111111 11111011

结果：r = 1073741819

### 大小端模式

> **大端模式**
> ，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
>
> **小端模式**
> ，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

下面以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value

**Big-Endian:**
低地址存放高位，如下：
  
高地址

​ buf[3] (0x78) – 低位
  
​ buf[2] (0x56)
  
​ buf[1] (0x34)
  
​ buf[0] (0x12) – 高位

​ 低地址
  
**Little-Endian**
: 低地址存放低位，如下：
  
​ 高地址

​ buf[3] (0x12) – 高位
  
buf[2] (0x34)
  
buf[1] (0x56)
  
buf[0] (0x78) – 低位

​ 低地址

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| --- | --- | --- |
| 0x4000 | 0x78 | 0x12 |
| 0x4001 | 0x56 | 0x34 |
| 0x4002 | 0x34 | 0x56 |
| 0x4003 | 0x12 | 0x78 |

### int与byte[]相互转换

```java
  /**
     * int到byte[] 由高位到低位
     * @param i 需要转换为byte数组的整行值。
     * @return byte数组
     */
    public static byte[] intToByteArray(int i) {
        byte[] result = new byte[4];
        result[0] = (byte)((i >> 24) & 0xFF);
        result[1] = (byte)((i >> 16) & 0xFF);
        result[2] = (byte)((i >> 8) & 0xFF);
        result[3] = (byte)(i & 0xFF);
        return result;
    }
 
    /**
     * byte[]转int
     * @param bytes 需要转换成int的数组
     * @return int值
     */
    public static int byteArrayToInt(byte[] bytes) {
        int value=0;
        for(int i = 0; i < 4; i++) {
            int shift= (3-i) * 8;
            value +=(bytes[i] & 0xFF) << shift;
        }
        return value;
    }

```

### 注意事项

c语言中数据类型分为有符号数和无符号数,但是在java中只有有符号数,不存在无符号数.所以当我们与硬件人员共同开发项目时,解析协议里面的byte[]要注意跟硬件人员
**确定是否带符号**
.带符号就跟java中一样处理即可.不带符号的话就要小心了,如果还按照java常规方法解析可能会越界.所以一般我们在
**byte[]转int值时,当作byte[]转long处理即可;在int转byte[]时,当作long转byte[],然后截取后4个字节(大端模式转换)**