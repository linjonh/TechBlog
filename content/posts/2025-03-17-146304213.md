---
layout: post
title: "BaseActivity-和-BaseFragment-的现代化架构ViewBinding-与-ViewModel-的深度整合"
date: 2025-03-17 00:04:40 +0800
description: "BaseActivity 和 BaseFragment 实现，集成了 View Binding，并增加了对 Lifecycle 和 ViewModel 的支持，同时进一步简化了代码结构，使其更易用、更灵活。在 onDestroy（Activity）和 onDestroyView（Fragment）中清理 binding 引用，避免内存泄漏。通过这种方式，可以轻松在项目中集成 View Binding 和 ViewModel，并享受其带来的便利和安全性！减少冗余代码，提高可读性和可维护性。"
keywords: "BaseActivity 和 BaseFragment 的现代化架构：ViewBinding 与 ViewModel 的深度整合"
categories: ['Android']
tags: ['架构', 'Android']
artid: "146304213"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146304213
    alt: "BaseActivity-和-BaseFragment-的现代化架构ViewBinding-与-ViewModel-的深度整合"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146304213
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146304213
cover: https://bing.ee123.net/img/rand?artid=146304213
image: https://bing.ee123.net/img/rand?artid=146304213
img: https://bing.ee123.net/img/rand?artid=146304213
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     BaseActivity 和 BaseFragment 的现代化架构：ViewBinding 与 ViewModel 的深度整合
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     BaseActivity 和 BaseFragment 实现，集成了 View Binding，并增加了对 Lifecycle 和 ViewModel 的支持，同时进一步简化了代码结构，使其更易用、更灵活。
    </p>
    <ol>
     <li>
      <strong>
       启用 View Binding
      </strong>
      <br/>
      确保在
      <strong>
       build.gradle
      </strong>
      中启用了
      <strong>
       View Binding
      </strong>
      ：
     </li>
    </ol>
    <pre><code>android {
    ...
    viewBinding {
        enabled = true
    }
}
</code></pre>
    <p>
     <strong>
      2. BaseActivity
     </strong>
    </p>
    <pre><code>import android.os.Bundle;
import androidx.annotation.CallSuper;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.lifecycle.ViewModel;
import androidx.lifecycle.ViewModelProvider;
import androidx.viewbinding.ViewBinding;

public abstract class BaseActivity&lt;VB extends ViewBinding, VM extends ViewModel&gt; extends AppCompatActivity {

    private VB _binding;
    private VM _viewModel;

    // 提供 binding 的 getter 方法
    protected VB getBinding() {
        return _binding;
    }

    // 提供 ViewModel 的 getter 方法
    protected VM getViewModel() {
        return _viewModel;
    }

    @Override
    @CallSuper
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        _binding = createViewBinding();
        setContentView(_binding.getRoot());

        // 初始化 ViewModel
        _viewModel = new ViewModelProvider(this).get(getViewModelClass());

        setupViews();
        observeData();
    }

    // 创建 ViewBinding 实例
    protected abstract VB createViewBinding();

    // 获取 ViewModel 的 Class 类型
    protected abstract Class&lt;VM&gt; getViewModelClass();

    // 初始化视图
    protected abstract void setupViews();

    // 观察数据（可选）
    protected void observeData() {
        // 默认空实现，子类可按需重写
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 清理 binding 引用，避免内存泄漏
        _binding = null;
    }
}
</code></pre>
    <p>
     <strong>
      3. BaseFragment
     </strong>
    </p>
    <pre><code>import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.CallSuper;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModel;
import androidx.lifecycle.ViewModelProvider;
import androidx.viewbinding.ViewBinding;

public abstract class BaseFragment&lt;VB extends ViewBinding, VM extends ViewModel&gt; extends Fragment {

    private VB _binding;
    private VM _viewModel;

    // 提供 binding 的 getter 方法
    protected VB getBinding() {
        return _binding;
    }

    // 提供 ViewModel 的 getter 方法
    protected VM getViewModel() {
        return _viewModel;
    }

    @Nullable
    @Override
    @CallSuper
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        _binding = createViewBinding(inflater, container);
        return _binding.getRoot();
    }

    @Override
    @CallSuper
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        // 初始化 ViewModel
        _viewModel = new ViewModelProvider(this).get(getViewModelClass());

        setupViews();
        observeData();
    }

    // 创建 ViewBinding 实例
    protected abstract VB createViewBinding(@NonNull LayoutInflater inflater, @Nullable ViewGroup container);

    // 获取 ViewModel 的 Class 类型
    protected abstract Class&lt;VM&gt; getViewModelClass();

    // 初始化视图
    protected abstract void setupViews();

    // 观察数据（可选）
    protected void observeData() {
        // 默认空实现，子类可按需重写
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        // 清理 binding 引用，避免内存泄漏
        _binding = null;
    }
}
</code></pre>
    <p>
     <strong>
      4. 使用示例
     </strong>
     <br/>
     <strong>
      MainActivity
     </strong>
    </p>
    <pre><code>public class MainActivity extends BaseActivity&lt;ActivityMainBinding, MainViewModel&gt; {

    @Override
    protected ActivityMainBinding createViewBinding() {
        return ActivityMainBinding.inflate(getLayoutInflater());
    }

    @Override
    protected Class&lt;MainViewModel&gt; getViewModelClass() {
        return MainViewModel.class;
    }

    @Override
    protected void setupViews() {
        // 使用 binding 访问视图
        getBinding().textView.setText("Hello, Optimized View Binding!");

        // 使用 ViewModel 数据
        getViewModel().getLiveData().observe(this, data -&gt; {
            // 更新 UI
        });
    }

    @Override
    protected void observeData() {
        // 观察数据变化（可选）
    }
}
</code></pre>
    <p>
     <strong>
      HomeFragment
     </strong>
    </p>
    <pre><code>public class HomeFragment extends BaseFragment&lt;FragmentHomeBinding, HomeViewModel&gt; {

    @Override
    protected FragmentHomeBinding createViewBinding(@NonNull LayoutInflater inflater, @Nullable ViewGroup container) {
        return FragmentHomeBinding.inflate(inflater, container, false);
    }

    @Override
    protected Class&lt;HomeViewModel&gt; getViewModelClass() {
        return HomeViewModel.class;
    }

    @Override
    protected void setupViews() {
        // 使用 binding 访问视图
        getBinding().button.setOnClickListener(v -&gt; {
            // 处理点击事件
        });

        // 使用 ViewModel 数据
        getViewModel().getLiveData().observe(getViewLifecycleOwner(), data -&gt; {
            // 更新 UI
        });
    }

    @Override
    protected void observeData() {
        // 观察数据变化（可选）
    }
}
</code></pre>
    <p>
     <strong>
      5. 优化点说明
     </strong>
     <br/>
     <strong>
      支持 ViewModel：
     </strong>
    </p>
    <p>
     通过泛型参数 ，基类可以动态绑定具体的 ViewModel 类。
    </p>
    <p>
     提供 getViewModelClass() 方法，子类只需返回 ViewModel 的 Class 类型即可。
    </p>
    <p>
     <strong>
      observeData 方法
     </strong>
     ：
    </p>
    <p>
     用于观察 ViewModel 中的数据变化（如 LiveData），子类可按需重写。
    </p>
    <p>
     <strong>
      内存泄漏防护：
     </strong>
    </p>
    <p>
     在 onDestroy（Activity）和 onDestroyView（Fragment）中清理 binding 引用，避免内存泄漏。
    </p>
    <p>
     <strong>
      简化代码结构：
     </strong>
    </p>
    <p>
     减少冗余代码，提高可读性和可维护性。
    </p>
    <p>
     <strong>
      @CallSuper 注解：
     </strong>
    </p>
    <p>
     确保子类在重写方法时调用 super，避免遗漏基类的关键逻辑。
    </p>
    <p>
     <strong>
      6. 注意事项
     </strong>
     <br/>
     确保布局文件的名称符合 View Binding 的命名规则（如
     <strong>
      activity_main.xml
     </strong>
     对应
     <strong>
      ActivityMainBinding
     </strong>
     ）。
    </p>
    <p>
     如果某个布局不需要 Binding，可以在布局文件的根标签中添加
     <strong>
      tools:viewBindingIgnore=“true”
     </strong>
     。
    </p>
    <p>
     通过这种方式，可以轻松在项目中集成 View Binding 和 ViewModel，并享受其带来的便利和安全性！
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f74616e6777656967756f30333035313938372f:61727469636c652f64657461696c732f313436333034323133" class_="artid" style="display:none">
 </p>
</div>


