---
arturl_encode: "68747470733a2f2f626c6f672e:6373646e2e6e65742f6162636432343638736664736673642f:61727469636c652f64657461696c732f313436313832303630"
layout: post
title: "å‰ç«¯æ‹“å±•Canvasæ€§èƒ½é©å‘½WebGPU-WebAssemblyæ··åˆæ¸²æŸ“æ–¹æ¡ˆæ·±åº¦è§£æ"
date: 2025-03-11 16:17:45 +08:00
description: "ä¸ºä»€ä¹ˆéœ€è¦æ··åˆæ–¹æ¡ˆï¼ŸçœŸå®åœºæ™¯ç—›ç‚¹åˆ†æï¼šä¼ ç»ŸWebGLåœ¨é«˜é¢‘æ•°æ®æ›´æ–°æ—¶å­˜åœ¨CPU-GPUé€šä¿¡ç“¶é¢ˆJavaScriptçš„åƒåœ¾å›æ”¶æœºåˆ¶å¯¼è‡´æ¸²æŸ“å¡é¡¿å¤æ‚ç‰©ç†æ¨¡æ‹Ÿï¼ˆå¦‚SPHæµä½“ï¼‰éš¾ä»¥åœ¨å•çº¿ç¨‹ä¸­å®ç°"
keywords: "ã€å‰ç«¯æ‹“å±•ã€‘Canvasæ€§èƒ½é©å‘½ï¼WebGPU + WebAssemblyæ··åˆæ¸²æŸ“æ–¹æ¡ˆæ·±åº¦è§£æ"
categories: ['æœªåˆ†ç±»']
tags: ['å‰ç«¯', 'Js']
artid: "146182060"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146182060
    alt: "å‰ç«¯æ‹“å±•Canvasæ€§èƒ½é©å‘½WebGPU-WebAssemblyæ··åˆæ¸²æŸ“æ–¹æ¡ˆæ·±åº¦è§£æ"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146182060
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146182060
cover: https://bing.ee123.net/img/rand?artid=146182060
image: https://bing.ee123.net/img/rand?artid=146182060
img: https://bing.ee123.net/img/rand?artid=146182060
---

# ã€å‰ç«¯æ‹“å±•ã€‘Canvasæ€§èƒ½é©å‘½ï¼WebGPU + WebAssemblyæ··åˆæ¸²æŸ“æ–¹æ¡ˆæ·±åº¦è§£æ

#### ä¸ºä»€ä¹ˆéœ€è¦æ··åˆæ–¹æ¡ˆï¼Ÿ

**çœŸå®åœºæ™¯ç—›ç‚¹åˆ†æ**
ï¼š

* ä¼ ç»ŸWebGLåœ¨é«˜é¢‘æ•°æ®æ›´æ–°æ—¶å­˜åœ¨CPU-GPUé€šä¿¡ç“¶é¢ˆ
* JavaScriptçš„åƒåœ¾å›æ”¶æœºåˆ¶å¯¼è‡´æ¸²æŸ“å¡é¡¿
* å¤æ‚ç‰©ç†æ¨¡æ‹Ÿï¼ˆå¦‚SPHæµä½“ï¼‰éš¾ä»¥åœ¨å•çº¿ç¨‹ä¸­å®ç°

**æŠ€æœ¯é€‰å‹å¯¹æ¯”**
ï¼š

```
graph LR
    A[è®¡ç®—å¯†é›†å‹ä»»åŠ¡] --> B[WebAssembly]
    C[å›¾å½¢æ¸²æŸ“ä»»åŠ¡] --> D[WebGPU]
    B --> E[å…±äº«å†…å­˜]
    D --> E

```

#### ğŸ› ï¸ ç¯å¢ƒæ­å»ºå…¨æµç¨‹

##### 1. WebGPUç¯å¢ƒé…ç½®

```
# å¯ç”¨Chromeå®éªŒç‰¹æ€§
chrome://flags/#enable-unsafe-webgpu

```

```
// æ£€æµ‹WebGPUæ”¯æŒ
if (!navigator.gpu) {
    throw new Error("WebGPU not supported!");
}
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();

```

##### 2. Rust WASMç¼–è¯‘ç¯å¢ƒ

```
# Cargo.toml
[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
rayon = "1.5" # å¹¶è¡Œè®¡ç®—åº“

```

##### 3. æ„å»ºæµæ°´çº¿

```
# å®‰è£…wasm-pack
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# ç¼–è¯‘å‘½ä»¤
wasm-pack build --target web --release

```

#### ğŸ”¥ æ ¸å¿ƒæ¶æ„æ·±åº¦è§£æ

##### å¤šçº¿ç¨‹é€šä¿¡æ¶æ„

```
sequenceDiagram
    Main Thread->>+Worker: åˆå§‹åŒ–å‘½ä»¤
    Worker->>+WASM: åˆ›å»ºç²’å­ç³»ç»Ÿ(1,000,000)
    WASM-->>-Worker: å†…å­˜æŒ‡é’ˆ
    loop æ¯å¸§å¾ªç¯
        Worker->>WASM: è°ƒç”¨update(dt)
        WASM->>GPU: é€šè¿‡å…±äº«å†…å­˜æ›´æ–°
        Worker->>GPU: æäº¤æ¸²æŸ“æŒ‡ä»¤
    end

```

##### å†…å­˜å…±äº«å…³é”®å®ç°

```
// Rustç«¯å¯¼å‡ºå†…å­˜
#[wasm_bindgen]
pub fn get_memory_buffer() -> JsValue {
    let memory = wasm_bindgen::memory();
    memory
}

```

```
// JavaScriptç«¯è®¿é—®
const wasmMemory = new WebAssembly.Memory({ initial: 256 });
const positions = new Float32Array(wasmMemory.buffer, 0, 1000000 * 3);
const velocities = new Float32Array(wasmMemory.buffer, 1000000 * 12, 1000000 * 3);

```

#### ğŸš€ æ€§èƒ½ä¼˜åŒ–å…¨æ”»ç•¥

##### 1. é›¶æ‹·è´æ•°æ®ä¼ è¾“

```
// åˆ›å»ºGPUç¼“å†²
const gpuBuffer = device.createBuffer({
    size: positions.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    mappedAtCreation: true
});

// ç›´æ¥å†…å­˜æ˜ å°„
const arrayBuffer = gpuBuffer.getMappedRange();
new Uint8Array(arrayBuffer).set(new Uint8Array(wasmMemory.buffer));
gpuBuffer.unmap();

```

##### 2. å¹¶è¡Œè®¡ç®—ä¼˜åŒ–ï¼ˆRustç¤ºä¾‹ï¼‰

```
use rayon::prelude::*;

fn update_particles(positions: &mut [f32], velocities: &mut [f32], dt: f32) {
    positions.par_chunks_mut(3)
        .zip(velocities.par_chunks_mut(3))
        .for_each(|(pos, vel)| {
            // SIMDåŠ é€Ÿè®¡ç®—
            vel[1] -= 9.8 * dt;
            pos[0] += vel[0] * dt;
            pos[1] += vel[1] * dt;
            pos[2] += vel[2] * dt;
        });
}

```

##### 3. GPU Instancingä¼˜åŒ–

```
// ç€è‰²å™¨ä»£ç 
struct VertexOutput {
    [[builtin(position)]] Position : vec4<f32>;
    [[location(0)]] color : vec4<f32>;
};

[[group(0), binding(0)] var<storage> particles : array<vec4<f32>>;

[[stage(vertex)]]
fn vs_main([[builtin(instance_index)]] instance : u32) -> VertexOutput {
    let position = particles[instance].xyz;
    return VertexOutput(
        vec4(position, 1.0),
        vec4(0.9, 0.2, 0.4, 1.0)
    );
}

```

#### ğŸ§ª æ€§èƒ½è°ƒè¯•æŠ€å·§

##### 1. Chromeæ€§èƒ½åˆ†æ

```
// æ ‡è®°æ€§èƒ½æ—¶é—´çº¿
performance.mark("simulation-start");
// ... è®¡ç®—ä»£ç  ...
performance.mark("simulation-end");
performance.measure("Simulation", "simulation-start", "simulation-end");

```

##### 2. GPUæŒ‡ä»¤ç»Ÿè®¡

```
const commandEncoder = device.createCommandEncoder();
// ... æ¸²æŸ“æŒ‡ä»¤ ...
const commands = commandEncoder.finish();

// æ³¨å…¥æŸ¥è¯¢
const querySet = device.createQuerySet({
    type: 'timestamp',
    count: 2
});
commandEncoder.writeTimestamp(querySet, 0);
// ... æ¸²æŸ“ä»£ç  ...
commandEncoder.writeTimestamp(querySet, 1);

```

##### 3. å†…å­˜ç›‘æ§æ–¹æ¡ˆ

```
const memory = window.performance.memory;
console.log(`JS heap: ${memory.usedJSHeapSize / 1024 / 1024}MB`);

```

#### ğŸ’¡ å®æˆ˜é¿å‘æŒ‡å—

**çº¿ç¨‹å®‰å…¨é™·é˜±**

```
// é”™è¯¯ç¤ºä¾‹ï¼šç›´æ¥ä¼ é€’TypedArray
worker.postMessage(positions); // å¯¼è‡´å†…å­˜å¤åˆ¶

// æ­£ç¡®æ–¹å¼ï¼šå…±äº«å†…å­˜
worker.postMessage({buffer: wasmMemory.buffer}, [wasmMemory.buffer]);

```

**ç²¾åº¦é—®é¢˜**

```
// ä½¿ç”¨å…¨ç²¾åº¦è®¡ç®—
[[stage(fragment)]]
fn fs_main() -> [[location(0)]] vec4<f32> {
    return vec4<f32>(0.9, 0.2, 0.4, 1.0);
}

```

**è®¾å¤‡å…¼å®¹æ–¹æ¡ˆ**

```
// è‡ªåŠ¨é™çº§é€»è¾‘
async function initRenderer() {
    try {
        return await initWebGPU();
    } catch {
        return await initWebGL();
    }
}

```

#### ğŸ® æ‰©å±•åº”ç”¨åœºæ™¯

##### 1. æµä½“æ¨¡æ‹Ÿï¼ˆSPHæ–¹æ³•ï¼‰

```
fn compute_density(particles: &mut [Particle]) {
    particles.par_iter_mut().for_each(|pi| {
        let mut density = 0.0;
        for pj in particles.iter() {
            let r = (pi.position - pj.position).norm();
            density += KERNEL(r, h);
        }
        pi.density = density;
    });
}

```

##### 2. å¸ƒæ–™æ¨¡æ‹Ÿï¼ˆVerletç§¯åˆ†ï¼‰

```
[[stage(vertex)]]
fn vs_main([[location(0)]] pos: vec3<f32>) -> [[builtin(position)]] vec4<f32> {
    let new_pos = 2.0 * pos - prev_pos + acceleration * dt * dt;
    return vec4(new_pos, 1.0);
}

```

##### 3. å¤§è§„æ¨¡åœ°å½¢ï¼ˆLODä¼˜åŒ–ï¼‰

```
const lodConfig = {
    0: { distance: 100, resolution: 1024 },
    1: { distance: 500, resolution: 512 },
    2: { distance: 1000, resolution: 256 }
};

```

#### ğŸ“ˆ æ€§èƒ½æµ‹è¯•æ•°æ®æ‰©å±•

| ç²’å­æ•°é‡ | WASMè®¡ç®—æ—¶é—´ | GPUæ¸²æŸ“æ—¶é—´ | æ€»å¸§æ—¶é—´ |
| --- | --- | --- | --- |
| 100,000 | 2.1ms | 4.3ms | 6.4ms |
| 500,000 | 8.7ms | 6.1ms | 14.8ms |
| 1,000,000 | 14.2ms | 8.9ms | 23.1ms |

*æµ‹è¯•è®¾å¤‡ï¼šM1 MacBook Pro / Chrome 105*

#### ğŸ› ï¸ å®Œæ•´é¡¹ç›®ç»“æ„

```
/webgpu-wasm-demo
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.rs          # WASMæ ¸å¿ƒé€»è¾‘
â”‚   â”œâ”€â”€ renderer.js     # WebGPUæ¸²æŸ“å™¨
â”‚   â””â”€â”€ worker.js       # å·¥ä½œçº¿ç¨‹æ§åˆ¶
â”œâ”€â”€ assets
â”‚   â””â”€â”€ shaders         # WGSLç€è‰²å™¨é›†åˆ
â””â”€â”€ benchmarks
    â””â”€â”€ stress-test     # å‹åŠ›æµ‹è¯•åœºæ™¯

```

#### ğŸŒ æµè§ˆå™¨å…¼å®¹æ€§å¯¹ç­–

| æµè§ˆå™¨ | WebGPUæ”¯æŒ | WASMçº¿ç¨‹æ”¯æŒ |
| --- | --- | --- |
| Chrome 105+ | âœ… | âœ… |
| Edge 105+ | âœ… | âœ… |
| Firefox | ğŸš§ Flagå¯ç”¨ | âœ… |
| Safari | ğŸš§ å¼€å‘ä¸­ | âœ… |

æŒæ¡è¿™å¥—æ··åˆæ–¹æ¡ˆï¼Œä½ ä¸ä»…å¯ä»¥å®ç°ï¼š

* ğŸ’¥ ç™¾ä¸‡çº§ç²’å­æµç•…äº¤äº’
* ğŸŒŒ å®æ—¶æµä½“æ¨¡æ‹Ÿ
* ğŸ”ï¸ æ— é™åœ°å½¢æ¸²æŸ“
* ğŸ¤– å¤æ‚ç‰©ç†å¼•æ“