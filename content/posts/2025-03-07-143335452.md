---
layout: post
title: "C语言_数据结构总结4不带头结点的单链表"
date: 2025-03-07 21:28:41 +0800
description: "纯c语言实现，不涉及C++每次插入新节点时，将新节点的 next 指针指向当前链表的头节点，然后更新链表的头指针，使其指向新节点。当链表不为空时，需要先遍历到链表的尾部，然后将新节点连接到尾部节点的后面。这样新节点就成为了链表的第一个节点，插入操作的时间复杂度为 O(1)。对于不带头结点的单链表，需要考虑链表为空的特殊情况。若删除的是其他节点，需要找到该节点的前一个节点。当链表为空时，新插入的节点就是链表的头节点；若要删除的是头节点，需要直接更新头指针；是每次都将新节点插入到链表的末尾。"
keywords: "不带头结点尾插法tn"
categories: ['C']
tags: ['链表', '算法', '数据结构', '开发语言', 'Visualstudio', 'Visual', 'Studio', 'C']
artid: "143335452"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=143335452
    alt: "C语言_数据结构总结4不带头结点的单链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=143335452
featuredImagePreview: https://bing.ee123.net/img/rand?artid=143335452
cover: https://bing.ee123.net/img/rand?artid=143335452
image: https://bing.ee123.net/img/rand?artid=143335452
img: https://bing.ee123.net/img/rand?artid=143335452
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言_数据结构总结4：不带头结点的单链表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="color:#f3f3f4">
      <strong>
       <span style="background-color:#ed7976">
        纯C语言代码，不涉及C++
       </span>
      </strong>
     </span>
    </p>
    <h3>
     0. 结点结构
    </h3>
    <p>
     typedef int ElemType;
     <br/>
     typedef struct LNode {
     <!-- -->
     <br/>
     ElemType data;  //数据域
     <br/>
     struct LNode* next;  //指针域
     <br/>
     }LNode, * LinkList;
    </p>
    <h3>
     1. 初始化
    </h3>
    <p>
     不带头结点的初始化，即只需将头指针初始化为NULL即可
    </p>
    <pre><code class="language-cs">void InitLink2(LinkList* L) {
	*L = NULL;
}</code></pre>
    <h3>
     2. 头插法
    </h3>
    <p>
     对于不带头结点的单链表，头插法的
     <span style="color:#4da8ee">
      核心思想
     </span>
     是：
     <br/>
     每次插入新节点时，将新节点的 next 指针指向当前链表的头节点，然后更新链表的头指针，使其指向新节点。
     <br/>
     这样新节点就成为了链表的第一个节点，插入操作的时间复杂度为 O(1)。
    </p>
    <pre><code class="language-cs">int headInsert(LinkList* L, ElemType value) {
	LinkList s = (LinkList)malloc(sizeof(LNode));
	if (s == NULL)
	{
		printf("内存分配失败!\n");
		return -2;
	}
	s-&gt;data = value;
	s-&gt;next = *L;
	*L = s;  //更新头结点指向新结点
	return 0;  //插入成功
}</code></pre>
    <h3>
     3. 尾插法
    </h3>
    <p>
     尾插法的
     <span style="color:#4da8ee">
      核心思路
     </span>
     是每次都将新节点插入到链表的末尾。
     <br/>
     对于不带头结点的单链表，需要考虑链表为空的特殊情况。
     <br/>
     当链表为空时，新插入的节点就是链表的头节点；
     <br/>
     当链表不为空时，需要先遍历到链表的尾部，然后将新节点连接到尾部节点的后面。
    </p>
    <pre><code class="language-cs">int tailInsert(LinkList* L, ElemType value) {
	LinkList s = (LinkList)malloc(sizeof(LNode));
	if (s == NULL)
	{
		printf("内存分配失败!\n");
		return -2;
	}
	s-&gt;data = value;
	s-&gt;next = NULL;  //因为新结点s要插入到链表尾部
	//若链表为空，新结点就是头结点
	if (*L == NULL)
	{
		*L = s;
	}
	else
	{
		//1.找到链表的尾结点
		LinkList p = *L;
		while (p-&gt;next != NULL) {
			p = p-&gt;next;
		}
		p-&gt;next = s;  //将新节点插入到尾结点后面
	}
	return 0; //插入成功
}</code></pre>
    <h3>
     4. 插入
    </h3>
    <pre><code class="language-cs">int insertLNode2(LinkList* L, int pos, ElemType value) {
	if (pos &lt; 1) {
		printf("插入位置不合法!\n");
		return -1;
	}
	LinkList s = (LinkList)malloc(sizeof(LNode));
	if (s == NULL) {
		printf("内存分配失败!\n");
		return -2;
	}
	s-&gt;data = value;

	if (pos == 1) {
		s-&gt;next = *L;
		*L = s;
	}
	else {
		LinkList p = *L;
		int i = 1;
		while (p != NULL &amp;&amp; i &lt; pos - 1) {
			p = p-&gt;next;
			i++;
		}
		if (p == NULL) {
			printf("插入位置不合法,已超出链表长度!\n");
			free(s);
			return -1;
		}
		s-&gt;next = p-&gt;next;
		p-&gt;next = s;
	}
	return 0;
}
</code></pre>
    <h3>
     5. 删除
    </h3>
    <p>
     <strong>
      <span style="color:#fe2c24">
       ！不带头结点的单链表进行删除结点操作需要分情况考虑：
      </span>
     </strong>
    </p>
    <p>
     若要删除的是头节点，需要直接更新头指针；
     <br/>
     若删除的是其他节点，需要找到该节点的前一个节点。
    </p>
    <p>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       ！在不带头结点的单链表删除操作中，当
       <code>
        pos == 1
       </code>
       时，不能直接使用
       <code>
        free(*L);
       </code>
       ，而要进行
       <code>
        *L = (*L)-&gt;next;
       </code>
      </strong>
     </span>
    </p>
    <p>
     <em>
      <span style="color:#0d0016">
       <strong>
        直接
        <code>
         free(*L);
        </code>
        存在的问题
       </strong>
      </span>
     </em>
    </p>
    <p>
     <code>
      free(*L);
     </code>
     这行代码的作用是释放
     <code>
      *L
     </code>
     所指向的内存空间。但执行完这一步后，链表的头指针
     <code>
      *L
     </code>
     仍然指向这块已经被释放的内存，形成了一个野指针。野指针是非常危险的，因为后续如果对这个野指针进行解引用操作（例如访问
     <code>
      (*L)-&gt;data
     </code>
     或
     <code>
      (*L)-&gt;next
     </code>
     ），会导致未定义行为，可能会使程序崩溃。而且，由于头指针没有更新，链表的后续节点就无法再被访问到，整个链表就丢失了。
    </p>
    <p>
     <em>
      <span style="color:#0d0016">
       <strong>
        <code>
         *L = (*L)-&gt;next;
        </code>
        操作的意义
       </strong>
      </span>
     </em>
    </p>
    <p>
     当
     <code>
      pos == 1
     </code>
     时，意味着要删除链表的第一个节点（即头节点）。
     <code>
      *L = (*L)-&gt;next;
     </code>
     这行代码的作用是更新头指针，让它指向原来头节点的下一个节点。具体步骤如下：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        保存原头节点指针
       </strong>
       ：
      </p>
     </li>
    </ol>
    <pre><code>LinkList temp = *L;
</code></pre>
    <p>
     》这行代码将原头节点的指针保存到临时变量
     <code>
      temp
     </code>
     中，方便后续释放该节点的内存。
     <br/>
     2.
     <strong>
      更新头指针
     </strong>
     ：
    </p>
    <pre><code>*L = (*L)-&gt;next;
</code></pre>
    <p>
     》》将头指针
     <code>
      *L
     </code>
     更新为原头节点的下一个节点。这样，新的头指针就指向了链表的第二个节点（如果存在的话），链表仍然可以正常访问。
     <br/>
     3.
     <strong>
      释放原头节点内存
     </strong>
     ：
    </p>
    <pre><code>free(temp);
</code></pre>
    <p>
     》》》释放临时变量
     <code>
      temp
     </code>
     所指向的内存，即原头节点的内存。
    </p>
    <p>
    </p>
    <p>
     <span style="color:#4da8ee">
      以下删除的操作完整代码：
     </span>
    </p>
    <pre><code class="language-cs">int deleteNode(LinkList* L, int pos) {
	if (pos &lt; 1)
	{
		printf("删除位置无效!\n");
		return -1;
	}
	if (*L == NULL)
	{
		printf("当前链表为空!\n");
		return -2;
	}
	if (pos == 1)  //即删除头结点，（更新头结点）
	{
		LinkList temp = *L;
		*L = (*L)-&gt;next;
		free(temp);
	}
	else
	{
		LinkList p = *L;
		int i = 1;
		//找到第pos-1个结点
		while (p != NULL &amp;&amp; i &lt; pos - 1) {
			p = p-&gt;next;
			i++;
		}
		if (p == NULL || p-&gt;next == NULL)
		{
			printf("删除位置不合法!\n");
			return -1;
		}
		LinkList temp = p-&gt;next;
		p-&gt;next = temp-&gt;next;
		free(temp);
	}
	return 0;  //删除成功
}</code></pre>
    <h3>
     6. 按位查找
    </h3>
    <p>
     即：查找第pos个位置上的value值
    </p>
    <pre><code class="language-cs">int findValueByPos(LinkList L, int pos, ElemType* value) {
	if (pos &lt; 1)
	{
		printf("查找位置不合法!\n");
		return -1;
	}
	LinkList p = L;
	int i = 1;
	while (p != NULL &amp;&amp; i &lt; pos) {
		p = p-&gt;next;
		i++;
	}
	if (p == NULL)
	{
		printf("查找位置超出链表长度!\n");
		return -1;
	}
	*value = p-&gt;data;
	return 0;
}</code></pre>
    <h3>
     7. 按值查找
    </h3>
    <p>
     即：查找value值在链表的第pos个位置
    </p>
    <pre><code class="language-cs">int findPosByvalue(LinkList L,ElemType value) {
	LinkList p = L;
	int pos = 1;
	while (p != NULL) {
		if (p-&gt;data == value)
		{
			return pos;
		}
		p = p-&gt;next;
		pos++;
	}
	return -1;  //查找失败，未在该链表中找到该value值
}</code></pre>
    <h3>
     8. 链表打印
    </h3>
    <pre><code class="language-cs">void printLink2(LinkList L) {
	if (L == NULL) {
		printf("链表为空!\n");
		return;
	}
	LinkList s = L;
	while (s != NULL) {
		printf("%d ", s-&gt;data);
		s = s-&gt;next;
	}
	printf("\n--------------------------------\n");
}</code></pre>
    <h3>
     9. 释放空间
    </h3>
    <pre><code class="language-cs">void freeList2(LinkList L) {
	LinkList p = L;
	while (p != NULL) {
		LinkList temp = p;
		p = p-&gt;next;
		free(temp);
	}
}
</code></pre>
    <h3>
     10. 测试代码
    </h3>
    <pre><code class="language-cs">int main() {
	//测试插入方法
	LinkList L1;
	InitLink2(&amp;L1);
	insertLNode2(&amp;L1, 1, 11);
	insertLNode2(&amp;L1, 2, 22);
	insertLNode2(&amp;L1, 3, 33);
	printLink2(L1);  // 11 22 33 
	freeList2(L1);

	// 测试头插法
	LinkList L2;
	InitLink2(&amp;L2);
	headInsert(&amp;L2, 1);
	headInsert(&amp;L2, 2);
	headInsert(&amp;L2, 3);
	printLink2(L2);  // 3 2 1
	freeList2(L2);

	// 测试尾插法
	LinkList L3;
	InitLink2(&amp;L3);
	tailInsert(&amp;L3, 1);
	tailInsert(&amp;L3, 2);
	tailInsert(&amp;L3, 3);
	printLink2(L3);  // 1 2 3
	

	// 测试删除
	deleteNode(&amp;L3, 3);
	printf("删除第三个结点后：");
	printLink2(L3);  //删除第三个结点后：1 2

	//测试按值查找
	printf("数值1在第%d个位置\n", findPosByvalue(L3, 1));  // 数值1在第1个位置

	//测试按位查找
	ElemType value;
	findValueByPos(L3, 1, &amp;value);
	printf("第1个位置的值为%d\n", value);  // 第1个位置的值为1

	freeList2(L3);

    return 0;
}</code></pre>
    <h3>
     11. 完整代码
    </h3>
    <pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
/*
    不带头结点的单链表
*/

typedef int ElemType;
typedef struct LNode {
	ElemType data;  //数据域
	struct LNode* next;  //指针域
}LNode, * LinkList;

// 操作1——不带头结点的初始化，即只需将头指针初始化为NULL即可
void InitLink2(LinkList* L) {
	*L = NULL;
}

// 操作2——不带头结点的插入操作
int insertLNode2(LinkList* L, int pos, ElemType value) {
	if (pos &lt; 1) {
		printf("插入位置不合法!\n");
		return -1;
	}
	LinkList s = (LinkList)malloc(sizeof(LNode));
	if (s == NULL) {
		printf("内存分配失败!\n");
		return -2;
	}
	s-&gt;data = value;

	if (pos == 1) {
		s-&gt;next = *L;
		*L = s;
	}
	else {
		LinkList p = *L;
		int i = 1;
		while (p != NULL &amp;&amp; i &lt; pos - 1) {
			p = p-&gt;next;
			i++;
		}
		if (p == NULL) {
			printf("插入位置不合法!\n");
			free(s);
			return -1;
		}
		s-&gt;next = p-&gt;next;
		p-&gt;next = s;
	}
	return 0;
}

//操作2.1——不带头结点的头插法建立单链表方法
int headInsert(LinkList* L, ElemType value) {
	LinkList s = (LinkList)malloc(sizeof(LNode));
	if (s == NULL)
	{
		printf("内存分配失败!\n");
		return -2;
	}
	s-&gt;data = value;
	s-&gt;next = *L;
	*L = s;  //更新头结点指向新结点
	return 0;  //插入成功
}

//操作2.3——不带头结点的尾插法建立单链表方法
/*
尾插法的核心思路是每次都将新节点插入到链表的末尾。
对于不带头结点的单链表，需要考虑链表为空的特殊情况。
当链表为空时，新插入的节点就是链表的头节点；
当链表不为空时，需要先遍历到链表的尾部，然后将新节点连接到尾部节点的后面。
*/
int tailInsert(LinkList* L, ElemType value) {
	LinkList s = (LinkList)malloc(sizeof(LNode));
	if (s == NULL)
	{
		printf("内存分配失败!\n");
		return -2;
	}
	s-&gt;data = value;
	s-&gt;next = NULL;  //因为新结点s要插入到链表尾部
	//若链表为空，新结点就是头结点
	if (*L == NULL)
	{
		*L = s;
	}
	else
	{
		//1.找到链表的尾结点
		LinkList p = *L;
		while (p-&gt;next != NULL) {
			p = p-&gt;next;
		}
		p-&gt;next = s;  //将新节点插入到尾结点后面
	}
	return 0; //插入成功
}

// 操作3——删除第pos个位置的值
/*
删除操作需要分情况考虑，若要删除的是头节点，需要直接更新头指针；
若删除的是其他节点，需要找到该节点的前一个节点。
*/
int deleteNode(LinkList* L, int pos) {
	if (pos &lt; 1)
	{
		printf("删除位置无效!\n");
		return -1;
	}
	if (*L == NULL)
	{
		printf("当前链表为空!\n");
		return -2;
	}
	if (pos == 1)  //即删除头结点，（更新头结点）
	{
		LinkList temp = *L;
		*L = (*L)-&gt;next;
		free(temp);
	}
	else
	{
		LinkList p = *L;
		int i = 1;
		//找到第pos-1个结点
		while (p != NULL &amp;&amp; i &lt; pos - 1) {
			p = p-&gt;next;
			i++;
		}
		if (p == NULL || p-&gt;next == NULL)
		{
			printf("删除位置不合法!\n");
			return -1;
		}
		LinkList temp = p-&gt;next;
		p-&gt;next = temp-&gt;next;
		free(temp);
	}
	return 0;  //删除成功
}

// 操作4——按位查找：查找第pos个位置上的value值
int findValueByPos(LinkList L, int pos, ElemType* value) {
	if (pos &lt; 1)
	{
		printf("查找位置不合法!\n");
		return -1;
	}
	LinkList p = L;
	int i = 1;
	while (p != NULL &amp;&amp; i &lt; pos) {
		p = p-&gt;next;
		i++;
	}
	if (p == NULL)
	{
		printf("查找位置超出链表长度!\n");
		return -1;
	}
	*value = p-&gt;data;
	return 0;
}

// 操作5——按值查找：查找value值在链表的第pos个位置
int findPosByvalue(LinkList L,ElemType value) {
	LinkList p = L;
	int pos = 1;
	while (p != NULL) {
		if (p-&gt;data == value)
		{
			return pos;
		}
		p = p-&gt;next;
		pos++;
	}
	return -1;  //查找失败，未在该链表中找到该value值
}

// 操作6——不带头结点的单链表打印操作
void printLink2(LinkList L) {
	if (L == NULL) {
		printf("链表为空!\n");
		return;
	}
	LinkList s = L;
	while (s != NULL) {
		printf("%d ", s-&gt;data);
		s = s-&gt;next;
	}
	printf("\n--------------------------------\n");
}

// 操作7——释放不带头结点链表内存
void freeList2(LinkList L) {
	LinkList p = L;
	while (p != NULL) {
		LinkList temp = p;
		p = p-&gt;next;
		free(temp);
	}
}

int main() {
	//测试插入方法
	LinkList L1;
	InitLink2(&amp;L1);
	insertLNode2(&amp;L1, 1, 11);
	insertLNode2(&amp;L1, 2, 22);
	insertLNode2(&amp;L1, 3, 33);
	printLink2(L1);  // 11 22 33 
	freeList2(L1);

	// 测试头插法
	LinkList L2;
	InitLink2(&amp;L2);
	headInsert(&amp;L2, 1);
	headInsert(&amp;L2, 2);
	headInsert(&amp;L2, 3);
	printLink2(L2);  // 3 2 1
	freeList2(L2);

	// 测试尾插法
	LinkList L3;
	InitLink2(&amp;L3);
	tailInsert(&amp;L3, 1);
	tailInsert(&amp;L3, 2);
	tailInsert(&amp;L3, 3);
	printLink2(L3);  // 1 2 3
	

	// 测试删除
	deleteNode(&amp;L3, 3);
	printf("删除第三个结点后：");
	printLink2(L3);  //删除第三个结点后：1 2

	//测试按值查找
	printf("数值1在第%d个位置\n", findPosByvalue(L3, 1));  // 数值1在第1个位置

	//测试按位查找
	ElemType value;
	findValueByPos(L3, 1, &amp;value);
	printf("第1个位置的值为%d\n", value);  // 第1个位置的值为1

	freeList2(L3);

    return 0;
}</code></pre>
    <h3>
     12. 运行截图
    </h3>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/5e4a43daae93452a9b520a7473df212a.png"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363738313035392f:61727469636c652f64657461696c732f313433333335343532" class_="artid" style="display:none">
 </p>
</div>


