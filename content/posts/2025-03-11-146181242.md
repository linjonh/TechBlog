---
layout: post
title: "nextjs15简要介绍以及配置eslint和prettier"
date: 2025-03-11 16:57:16 +0800
description: "Next.js 是一个基于的，用于构建。它由开发和维护，提供了等特性。自问世以来，一直受到众多前度开发者的青睐，其版本也在不断地更新当中，如已经更新到了nextjs15Next.js 提供了此外，还有作为 SSG 的增强版。revalidate如果你需要，但数据又，可以使用revalidaterevalidate。在nextjs15当中配置eslint和prettier。"
keywords: "nextjs15简要介绍以及配置eslint和prettier"
categories: ['React']
tags: ['Prettier', 'Nextjs', 'Nextjs', 'Eslint']
artid: "146181242"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146181242
    alt: "nextjs15简要介绍以及配置eslint和prettier"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146181242
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146181242
cover: https://bing.ee123.net/img/rand?artid=146181242
image: https://bing.ee123.net/img/rand?artid=146181242
img: https://bing.ee123.net/img/rand?artid=146181242
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     nextjs15简要介绍以及配置eslint和prettier
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <form>
     <p>
     </p>
     <hr id="hr-toc" name="tableOfContents"/>
     <p>
     </p>
    </form>
    <p>
     Next.js 是一个基于
     <strong>
      React
     </strong>
     的
     <strong>
      全栈框架
     </strong>
     ，用于构建
     <strong>
      高性能 Web 应用
     </strong>
     。它由
     <strong>
      Vercel
     </strong>
     开发和维护，提供了
     <strong>
      服务器渲染（SSR）
     </strong>
     、
     <strong>
      静态生成（SSG）
     </strong>
     、
     <strong>
      API 路由
     </strong>
     、
     <strong>
      自动路由
     </strong>
     、
     <strong>
      全栈功能
     </strong>
     等特性。
    </p>
    <p>
     自问世以来，一直受到众多前度开发者的青睐，其版本也在不断地更新当中，如已经更新到了nextjs15
    </p>
    <h3 id="%E4%B8%80%E3%80%81Next.js%20%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89%EF%BC%9F%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90%EF%BC%88SSG%EF%BC%89%EF%BC%9F" name="%E4%B8%80%E3%80%81Next.js%20%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89%EF%BC%9F%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90%EF%BC%88SSG%EF%BC%89%EF%BC%9F">
     <strong>
      一、Next.js 何时使用服务器端渲染（SSR）？何时使用静态生成（SSG）？
     </strong>
    </h3>
    <p>
     Next.js 提供了
     <strong>
      两种主要的页面渲染方式
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       服务器端渲染（SSR - Server-Side Rendering）
      </strong>
     </li>
     <li>
      <strong>
       静态生成（SSG - Static Site Generation）
      </strong>
     </li>
    </ol>
    <p>
     此外，还有
     <strong>
      增量静态生成（ISR - Incremental Static Regeneration）
     </strong>
     作为 SSG 的增强版。
    </p>
    <hr/>
    <h4 id="1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%20-%20getServerSideProps%EF%BC%89" name="1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%20-%20getServerSideProps%EF%BC%89">
     <strong>
      1、服务器端渲染（SSR -
      <code>
       getServerSideProps
      </code>
      ）
     </strong>
    </h4>
    <p>
     <strong>
      📌 什么时候用 SSR？
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       页面数据依赖于请求时的最新数据
      </strong>
     </li>
     <li>
      <strong>
       用户个性化内容
      </strong>
      （如用户登录状态、账户信息）
     </li>
     <li>
      <strong>
       SEO 友好，并且内容实时变化
      </strong>
     </li>
     <li>
      <strong>
       数据必须在请求时获取，不能提前生成
      </strong>
     </li>
    </ul>
    <p>
     <strong>
      ✅ 适用场景
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       动态新闻/社交媒体页面
      </strong>
     </li>
     <li>
      <strong>
       用户仪表盘（Dashboard）
      </strong>
     </li>
     <li>
      <strong>
       库存管理（需要最新库存数据）
      </strong>
     </li>
     <li>
      <strong>
       A/B 测试（不同用户看到不同的内容）
      </strong>
     </li>
    </ul>
    <p>
     <strong>
      📌 SSR 代码示例
     </strong>
    </p>
    <pre><code>export async function getServerSideProps(context) {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();

  return {
    props: { data }, // 这个 `data` 会被传递给组件
  };
}

export default function Page({ data }) {
  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;
}
</code></pre>
    <p>
     <strong>
      📌 SSR 发生的时间
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       每次请求
      </strong>
      时都会运行
      <code>
       getServerSideProps
      </code>
     </li>
     <li>
      页面不会被
      <strong>
       缓存
      </strong>
      ，每次访问都会请求 API
     </li>
    </ul>
    <h3 id="2%E3%80%81%20%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90%EF%BC%88SSG%20-%20getStaticProps%EF%BC%89" name="2%E3%80%81%20%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90%EF%BC%88SSG%20-%20getStaticProps%EF%BC%89">
     <strong>
      2、 静态生成（SSG -
      <code>
       getStaticProps
      </code>
      ）
     </strong>
    </h3>
    <p>
     <strong>
      📌 什么时候用 SSG？
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       数据在构建时就可以确定
      </strong>
     </li>
     <li>
      <strong>
       数据不会频繁变化
      </strong>
     </li>
     <li>
      <strong>
       SEO 友好，且性能要求高
      </strong>
     </li>
     <li>
      <strong>
       减少服务器负载，提升访问速度
      </strong>
     </li>
    </ul>
    <p>
     <strong>
      ✅ 适用场景
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       博客文章
      </strong>
     </li>
     <li>
      <strong>
       产品详情页
      </strong>
     </li>
     <li>
      <strong>
       文档、帮助中心
      </strong>
     </li>
     <li>
      <strong>
       营销页面（Landing Page）
      </strong>
     </li>
    </ul>
    <p>
     <strong>
      📌 SSG 代码示例
     </strong>
    </p>
    <pre><code>export async function getStaticProps() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();

  return {
    props: { data },
    revalidate: 60, // ISR: 60秒后重新生成页面
  };
}

export default function Page({ data }) {
  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;
}
</code></pre>
    <p>
     <strong>
      📌 SSG 发生的时间
     </strong>
    </p>
    <ul>
     <li>
      只在
      <strong>
       构建时
      </strong>
      运行
      <code>
       getStaticProps
      </code>
     </li>
     <li>
      生成的
      <strong>
       HTML 是静态的
      </strong>
      ，用户访问时不再请求 API
     </li>
     <li>
      可以配合
      <strong>
       ISR（增量静态生成）
      </strong>
      让部分数据自动更新（
      <code>
       revalidate
      </code>
      ）
     </li>
    </ul>
    <hr/>
    <h3 id="3%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%20ISR%EF%BC%88%E5%A2%9E%E9%87%8F%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90%EF%BC%89%EF%BC%9F" name="3%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%20ISR%EF%BC%88%E5%A2%9E%E9%87%8F%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90%EF%BC%89%EF%BC%9F">
     <strong>
      3、什么时候使用 ISR（增量静态生成）？
     </strong>
    </h3>
    <p>
     如果你需要
     <strong>
      SSG 的性能
     </strong>
     ，但数据又
     <strong>
      偶尔更新
     </strong>
     ，可以使用
     <strong>
      ISR
     </strong>
     （Incremental Static Regeneration）。
    </p>
    <p>
     <strong>
      ✅ 适用场景
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       产品价格、库存信息
      </strong>
     </li>
     <li>
      <strong>
       新闻列表（不是实时新闻，但会定期更新）
      </strong>
     </li>
     <li>
      <strong>
       带有 SEO 的动态内容
      </strong>
     </li>
    </ul>
    <p>
     <strong>
      📌 ISR 代码示例
     </strong>
    </p>
    <pre><code>export async function getStaticProps() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();

  return {
    props: { data },
    revalidate: 60, // 每 60 秒更新一次数据
  };
}
</code></pre>
    <ul>
     <li>
      页面会在
      <strong>
       首次构建时生成
      </strong>
     </li>
     <li>
      访问页面后，
      <strong>
       如果超过
       <code>
        revalidate
       </code>
       时间，Next.js 会后台重新生成
      </strong>
     </li>
     <li>
      用户访问不会等更新完成，
      <strong>
       只会在下次请求时看到新页面
      </strong>
     </li>
    </ul>
    <hr/>
    <h3 id="%F0%9F%8E%AF%20SSR%20vs%20SSG%20vs%20ISR%20%E5%AF%B9%E6%AF%94" name="%F0%9F%8E%AF%20SSR%20vs%20SSG%20vs%20ISR%20%E5%AF%B9%E6%AF%94">
     <strong>
      🎯 SSR vs SSG vs ISR 对比
     </strong>
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         渲染方式
        </strong>
       </th>
       <th>
        <strong>
         何时渲染？
        </strong>
       </th>
       <th>
        <strong>
         数据是否实时？
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         SSR
        </strong>
        （服务器端渲染）
       </td>
       <td>
        <strong>
         每次请求时
        </strong>
       </td>
       <td>
        ✅ 实时数据
       </td>
       <td>
        账户信息、仪表盘、个性化页面
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         SSG
        </strong>
        （静态生成）
       </td>
       <td>
        <strong>
         构建时
        </strong>
       </td>
       <td>
        ❌ 数据不会变
       </td>
       <td>
        博客、产品页、文档
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         ISR
        </strong>
        （增量静态生成）
       </td>
       <td>
        <strong>
         构建时生成，之后按
         <code>
          revalidate
         </code>
         更新
        </strong>
       </td>
       <td>
        ⏳ 定期更新
       </td>
       <td>
        新闻、商品库存、SEO 友好的动态页面
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3 id="4%E3%80%81%E6%80%BB%E7%BB%93" name="4%E3%80%81%E6%80%BB%E7%BB%93">
     <strong>
      4、总结
     </strong>
    </h3>
    <ul>
     <li>
      <strong>
       如果数据是动态的，并且需要最新的内容
      </strong>
      →
      <strong>
       SSR
      </strong>
     </li>
     <li>
      <strong>
       如果数据可以在构建时确定，且不会频繁变化
      </strong>
      →
      <strong>
       SSG
      </strong>
     </li>
     <li>
      <strong>
       如果数据不会实时更新，但仍然需要定期刷新
      </strong>
      →
      <strong>
       ISR
      </strong>
     </li>
    </ul>
    <h3 id="%E4%BA%8C%E3%80%81nextjs15%E7%9A%84%E4%BC%98%E5%8A%BF" name="%E4%BA%8C%E3%80%81nextjs15%E7%9A%84%E4%BC%98%E5%8A%BF">
     二、nextjs15的优势
    </h3>
    <p>
     Next.js 15 发布后，带来了多项重要更新，旨在提升开发者体验和应用性能。以下是主要改进：
    </p>
    <h4 id="1.%20Turbopack%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F" name="1.%20Turbopack%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F">
     1. Turbopack 开发模式
    </h4>
    <p>
     <code>
      next dev --turbo
     </code>
     现已稳定，可加速开发体验。在大型 Next.js 应用中，如 vercel.com，使用 Turbopack 开发模式可实现：
    </p>
    <ul>
     <li>
      <strong>
       本地服务器启动速度
      </strong>
      ：提升高达 76.7%
     </li>
     <li>
      <strong>
       Fast Refresh 代码更新速度
      </strong>
      ：提升高达 96.3%
     </li>
    </ul>
    <p>
     citeturn0search0
    </p>
    <h4 id="2.%20React%2019%20%E6%94%AF%E6%8C%81" name="2.%20React%2019%20%E6%94%AF%E6%8C%81">
     2. React 19 支持
    </h4>
    <p>
     Next.js 15 与即将发布的 React 19 保持一致：
    </p>
    <ul>
     <li>
      <strong>
       App Router
      </strong>
      ：使用 React 19 RC
     </li>
     <li>
      <strong>
       Pages Router
      </strong>
      ：保持对 React 18 的向后兼容性，允许在准备就绪时升级到 React 19
     </li>
    </ul>
    <h4 id="3.%20Hydration%20%E9%94%99%E8%AF%AF%E6%94%B9%E8%BF%9B" name="3.%20Hydration%20%E9%94%99%E8%AF%AF%E6%94%B9%E8%BF%9B">
     3. Hydration 错误改进
    </h4>
    <p>
     改进了 hydration 错误视图，错误信息更清晰，并提供解决建议，提升调试效率。
    </p>
    <h4 id="4.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%8C%87%E7%A4%BA%E5%99%A8" name="4.%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%8C%87%E7%A4%BA%E5%99%A8">
     4. 静态路由指示器
    </h4>
    <p>
     在开发过程中显示静态路由指示器，帮助识别哪些路由是静态的或动态的，便于优化性能。
    </p>
    <h4 id="5.%20%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%8A%9F%E8%83%BD" name="5.%20%E5%AE%9E%E9%AA%8C%E6%80%A7%E5%8A%9F%E8%83%BD">
     5. 实验性功能
    </h4>
    <ul>
     <li>
      <strong>
       <code>
        unstable_after
       </code>
       API
      </strong>
      ：允许在响应流式传输完成后处理任务，使次要任务在不阻塞主要响应的情况下运行。
     </li>
     <li>
      <strong>
       <code>
        instrumentation.js
       </code>
      </strong>
      ：提供
      <code>
       register()
      </code>
      API，允许接入 Next.js 服务器生命周期，以监控性能、追踪错误源头，并深度集成如 OpenTelemetry 等可观测性库。
     </li>
    </ul>
    <h4 id="6.%20%3CForm%3E%20%E7%BB%84%E4%BB%B6" name="6.%20%3CForm%3E%20%E7%BB%84%E4%BB%B6">
     6.
     <code>
      &lt;Form&gt;
     </code>
     组件
    </h4>
    <p>
     新的
     <code>
      &lt;Form&gt;
     </code>
     组件扩展了 HTML
     <code>
      &lt;form&gt;
     </code>
     元素，增加了预获取、客户端导航和渐进增强功能，适用于需要导航到新页面的表单。
    </p>
    <p>
     这些更新使 Next.js 15 成为一个更高效、更强大的框架，进一步提升了开发者的工作流程和应用性能。
    </p>
    <h3 id="%E4%B8%89%E3%80%81nextjs15%E9%85%8D%E7%BD%AEeslint%E5%92%8Cprettier" name="%E4%B8%89%E3%80%81nextjs15%E9%85%8D%E7%BD%AEeslint%E5%92%8Cprettier">
     三、nextjs15配置eslint和prettier
    </h3>
    <p>
     在前端开发项目当中使用eslint进行语法检查，prettier进行代码美化几乎已经成为一个标配。nextjs15默认支持eslint 9版本，跟之前8版本有很大的不同。
    </p>
    <ul>
     <li>
      <p>
       <strong>
        ESLint 8 及之前
       </strong>
       ：使用
       <code>
        .eslintrc
       </code>
       、
       <code>
        .eslintrc.js
       </code>
       、
       <code>
        .eslintrc.json
       </code>
       或在
       <code>
        package.json
       </code>
       中配置。
      </p>
     </li>
     <li>
      <p>
       <strong>
        ESLint 9
       </strong>
       ：引入了全新的扁平化配置文件
       <code>
        eslint.config.js
       </code>
       ，取代了之前的配置方式。这种新格式更灵活，支持模块化配置。
      </p>
     </li>
    </ul>
    <p>
     最近在github找了一个依赖插件
     <a href="https://github.com/danielalves96/eslint-prettier-next-15" title="eslint-prettier-next-15">
      eslint-prettier-next-15
     </a>
     ，执行一条命令，即可配置帮你的项目配置好eslint和prettier。
    </p>
    <p>
     首先，创建一个nextjs项目：
    </p>
    <pre><code class="language-javascript">pnpm dlx create-nextjs-app my-app
</code></pre>
    <p>
    </p>
    <p>
     创建完成后，再执行：
    </p>
    <pre><code class="language-javascript">pnpm dlx eslint-prettier-next-15</code></pre>
    <p>
     这条命令会帮助项目做两件事情：
    </p>
    <h4 id="1%E3%80%81%E5%AE%89%E8%A3%85eslint%E5%92%8Cprettier%E6%89%80%E9%9C%80%E4%BE%9D%E8%B5%96%EF%BC%9A" name="1%E3%80%81%E5%AE%89%E8%A3%85eslint%E5%92%8Cprettier%E6%89%80%E9%9C%80%E4%BE%9D%E8%B5%96%EF%BC%9A">
     1、安装eslint和prettier所需依赖：
    </h4>
    <ul>
     <li>
      <code>
       @eslint/eslintrc@3.2.0
      </code>
     </li>
     <li>
      <code>
       @eslint/js@9.18.0
      </code>
     </li>
     <li>
      <code>
       @ianvs/prettier-plugin-sort-imports@4.4.0
      </code>
     </li>
     <li>
      <code>
       @typescript-eslint/eslint-plugin@8.19.1
      </code>
     </li>
     <li>
      <code>
       @typescript-eslint/parser@8.19.1
      </code>
     </li>
     <li>
      <code>
       eslint@9.18.0
      </code>
     </li>
     <li>
      <code>
       eslint-config-next@15.1.4
      </code>
     </li>
     <li>
      <code>
       eslint-config-prettier@9.1.0
      </code>
     </li>
     <li>
      <code>
       eslint-plugin-prettier@5.2.1
      </code>
     </li>
     <li>
      <code>
       prettier@3.4.2
      </code>
     </li>
     <li>
      <code>
       prettier-plugin-sort-json@4.1.1
      </code>
     </li>
    </ul>
    <h4 id="2%E3%80%81%E7%94%9F%E6%88%90eslint%E5%92%8Cprettier%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" name="2%E3%80%81%E7%94%9F%E6%88%90eslint%E5%92%8Cprettier%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">
     2、生成eslint和prettier的配置文件
    </h4>
    <p id=".prettierrc.json" name=".prettierrc.json">
     <code>
      .prettierrc.json
     </code>
    </p>
    <pre><code class="language-javascript">{
  "printWidth": 120,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5",
  "plugins": [
    "@ianvs/prettier-plugin-sort-imports",
    "prettier-plugin-sort-json"
  ],
  "importOrder": [
    "^(react/(.*)$)|^(react$)",
    "^(next/(.*)$)|^(next$)",
    "&lt;THIRD_PARTY_MODULES&gt;",
    "",
    "^@/(.*)$",
    "^[./]"
  ],
  "importOrderParserPlugins": ["typescript", "jsx", "decorators-legacy"]
}</code></pre>
    <p id="eslint.config.mjs" name="eslint.config.mjs">
     <code>
      eslint.config.mjs
     </code>
    </p>
    <pre><code class="language-javascript">import path from "node:path";
import { fileURLToPath } from "node:url";
import { FlatCompat } from "@eslint/eslintrc";
import js from "@eslint/js";
import typescriptEslintEslintPlugin from "@typescript-eslint/eslint-plugin";
import tsParser from "@typescript-eslint/parser";
import prettier from "eslint-plugin-prettier";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
});

export default [
  ...compat.extends("next", "next/core-web-vitals", "prettier"),
  {
    plugins: {
      prettier,
    },
    rules: {
      "prettier/prettier": "error",
      camelcase: "off",
      "import/prefer-default-export": "off",
      "react/jsx-filename-extension": "off",
      "react/jsx-props-no-spreading": "off",
      "react/no-unused-prop-types": "off",
      "react/require-default-props": "off",
      "react/no-unescaped-entities": "off",
      "import/extensions": [
        "error",
        "ignorePackages",
        {
          ts: "never",
          tsx: "never",
          js: "never",
          jsx: "never",
        },
      ],
    },
  },
  ...compat
    .extends("plugin:@typescript-eslint/recommended", "prettier")
    .map((config) =&gt; ({
      ...config,
      files: ["**/*.+(ts|tsx)"],
    })),
  {
    files: ["**/*.+(ts|tsx)"],
    plugins: {
      "@typescript-eslint": typescriptEslintEslintPlugin,
    },
    languageOptions: {
      parser: tsParser,
    },
    rules: {
      "@typescript-eslint/explicit-function-return-type": "off",
      "@typescript-eslint/explicit-module-boundary-types": "off",
      "no-use-before-define": [0],
      "@typescript-eslint/no-use-before-define": [1],
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-var-requires": "off",
    },
  },
];</code></pre>
    <p>
     还有prettier美化忽略文件：
     <code>
      prettierignore
     </code>
    </p>
    <p>
     <code>
      完成以上配置后，重新启动vscode就可以正常使用；
     </code>
    </p>
    <h4 id="3%E3%80%81vscode%E7%BC%96%E8%BE%91%E5%99%A8eslint%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5" name="3%E3%80%81vscode%E7%BC%96%E8%BE%91%E5%99%A8eslint%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5">
     <code>
      3、vscode编辑器eslint配置检查
     </code>
    </h4>
    <p>
     <code>
      但是，我在完成这个以后，发现eslint不起作用，代码中出现错误，也不提示红色波浪线。检查发现vscode的eslint模块总是爆出一下错误：
     </code>
    </p>
    <p>
     eslint Config (unnamed): Key "env": This appears to be in eslintrc format rather than flat config format.
    </p>
    <p>
     <img alt="" height="82" src="https://i-blog.csdnimg.cn/direct/97d25b147eab4defbc2de26b60fab8e6.png" width="1660"/>
    </p>
    <p>
     这个错误提示是因为你的 ESLint 配置文件格式不符合 Flat Config（扁平配置）的要求。
    </p>
    <p>
     检查发现我的vscode的settings.json配置文件当中存在：
    </p>
    <p>
     settings.json
    </p>
    <pre><code class="language-javascript"> "eslint.options": {
    "overrideConfig": {
      "env": {
        "browser": true,
        "es6": true
      },
      "parserOptions": {
        "ecmaVersion": 2019,
        "sourceType": "module",
        "ecmaFeatures": {
          "jsx": true
        }
      },
      "rules": {
        "no-debugger": "off"
      }
    }
  },</code></pre>
    <p>
     以上是eslint 8版本的写法，在eslint 9版本当中env等属性都不存在了，因此与eslint9版本的写法发生了冲突。解决方法是将settings.json当中的eslint配置改用eslint9版本的写法，或者直接注释掉即可。
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f73696e61745f33363732383531382f:61727469636c652f64657461696c732f313436313831323432" class_="artid" style="display:none">
 </p>
</div>


