---
layout: post
title: "CC蓝桥杯算法真题打卡Day4"
date: 2025-03-09 00:00:00 +0800
description: "C/C++蓝桥杯算法真题打卡（Day4）"
keywords: "C/C++蓝桥杯算法真题打卡（Day4）"
categories: ['蓝桥杯']
tags: ['蓝桥杯', '算法', '数据结构', 'C']
artid: "146108321"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146108321
    alt: "CC蓝桥杯算法真题打卡Day4"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146108321
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146108321
cover: https://bing.ee123.net/img/rand?artid=146108321
image: https://bing.ee123.net/img/rand?artid=146108321
img: https://bing.ee123.net/img/rand?artid=146108321
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C/C++蓝桥杯算法真题打卡（Day4）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     一、
     <a href="https://www.luogu.com.cn/problem/P11041" rel="nofollow" title="P11041 [蓝桥杯 2024 省 Java B] 报数游戏 - 洛谷">
      P11041 [蓝桥杯 2024 省 Java B] 报数游戏 - 洛谷
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="761" src="https://i-blog.csdnimg.cn/direct/6f5df1dce11a46cdac98fe5c71a0a5dc.png" width="986"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

// 计算第 n 个满足条件的数
long long findNthNumber(long long n) {
    long long low = 1, high = 1e18; // 二分查找范围
    while (low &lt; high) {
        long long mid = (low + high) / 2;
        // 计算 mid 以内 20 或 24 的倍数的个数
        long long count = mid / 20 + mid / 24 - mid / 120;
        if (count &lt; n) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

int main() {
    long long n = 202420242024;
    long long result = findNthNumber(n);
    cout &lt;&lt; result &lt;&lt; endl;
    return 0;
}</code></pre>
    <h3>
     代码说明
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        二分查找
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         通过二分查找确定第 n 个满足条件的数。
        </p>
       </li>
       <li>
        <p>
         查找范围从 1 到 1e18（足够大的数）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        容斥原理
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         <code>
          mid / 20
         </code>
         ：计算 mid 以内 20 的倍数的个数。
        </p>
       </li>
       <li>
        <p>
         <code>
          mid / 24
         </code>
         ：计算 mid 以内 24 的倍数的个数。
        </p>
       </li>
       <li>
        <p>
         <code>
          mid / 120
         </code>
         ：减去 20 和 24 的最小公倍数的个数（避免重复计算）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        时间复杂度
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         二分查找的时间复杂度为 O(log N)，效率非常高。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p class="img-center">
     <img alt="" height="340" src="https://i-blog.csdnimg.cn/direct/717600228e104c4e8149c73bd10ddd22.png" width="926"/>
    </p>
    <p>
    </p>
    <h2>
     二、
     <a href="https://www.luogu.com.cn/problem/P8792" rel="nofollow" title="P8792 [蓝桥杯 2022 国 A] 最大公约数 - 洛谷">
      P8792 [蓝桥杯 2022 国 A] 最大公约数 - 洛谷
     </a>
    </h2>
    <p class="img-center">
     <img alt="" height="876" src="https://i-blog.csdnimg.cn/direct/9c86af93500f4e408bdbd6193800cc52.png" width="785"/>
    </p>
    <h3>
     算法代码：
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define lc 2*k
#define rc 2*k+1
using namespace std;
int n,a[1234567],cnt;
struct nord{
	int l,r,mx;
}t[1234567];
void build(int k,int l,int r){//建树
	t[k].l=l,t[k].r=r;
	if (l==r){
		t[k].mx=a[l];
		return ;
	}
	int mid=(l+r)/2;
	build(lc,l,mid);
	build(rc,mid+1,r);
	t[k].mx=__gcd(t[lc].mx,t[rc].mx);
}
int ask(int k,int l,int r){//求区间gcd
	if (l&lt;=t[k].l&amp;&amp;r&gt;=t[k].r) return t[k].mx;
	int ans=0;
	int mid=(t[k].l+t[k].r)/2;
	if (l&lt;=mid) ans=__gcd(ans,ask(lc,l,r));
	if (r&gt;mid) ans=__gcd(ans,ask(rc,l,r));
	return ans;
}
main(){
	cin&gt;&gt;n;
	for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],cnt+=(a[i]==1?1:0);
	build(1,1,n);
	if (cnt){//特殊情况
		cout &lt;&lt;n-cnt;
		return 0;
	}
	int ans=1e9;
	int i=1;
	for (int j=1;j&lt;=n;j++){//枚举
		while (i&lt;j&amp;&amp;ask(1,i+1,j)==1) i++;//一直往前走
		if (ask(1,i,j)==1) ans=min(ans,j-i);//成功了
	}
	if (ans==1e9) cout &lt;&lt;-1;//不合法
	else cout &lt;&lt;n+ans-1;
    return 0;
}</code></pre>
    <p>
     这段代码的主要功能是解决一个与区间 GCD（最大公约数）相关的问题。以下是代码的思路和逻辑分析：
    </p>
    <hr/>
    <h3>
     代码思路
    </h3>
    <h4>
     1.
     <strong>
      问题描述
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       给定一个长度为
       <code>
        n
       </code>
       的数组
       <code>
        a
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       目标是找到一个最短的区间
       <code>
        [i, j]
       </code>
       ，使得该区间内所有元素的 GCD 为 1。
      </p>
     </li>
     <li>
      <p>
       如果存在这样的区间，输出将整个数组变为全 1 的最小操作次数；否则输出 -1。
      </p>
     </li>
    </ul>
    <h4>
     2.
     <strong>
      核心逻辑
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        特殊情况处理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果数组中已经有
         <code>
          cnt
         </code>
         个 1，则直接输出
         <code>
          n - cnt
         </code>
         ，因为只需要将其他元素变为 1 即可。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        区间 GCD 计算
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用线段树维护区间 GCD，支持快速查询任意区间的 GCD。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        滑动窗口枚举
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用双指针
         <code>
          i
         </code>
         和
         <code>
          j
         </code>
         枚举区间
         <code>
          [i, j]
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         如果区间
         <code>
          [i, j]
         </code>
         的 GCD 为 1，则尝试缩小窗口（移动
         <code>
          i
         </code>
         ）以找到更短的区间。
        </p>
       </li>
       <li>
        <p>
         记录满足条件的最短区间长度。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        结果计算
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果找到满足条件的区间，输出
         <code>
          n + ans - 1
         </code>
         （将整个数组变为全 1 的最小操作次数）。
        </p>
       </li>
       <li>
        <p>
         否则输出 -1。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h3>
     代码逻辑分析
    </h3>
    <h4>
     1.
     <strong>
      线段树构建
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <code>
        build
       </code>
       函数用于构建线段树，每个节点存储区间的左右边界和区间 GCD。
      </p>
     </li>
     <li>
      <p>
       递归地将数组划分为左右子区间，直到区间长度为 1。
      </p>
     </li>
     <li>
      <p>
       区间 GCD 通过
       <code>
        __gcd
       </code>
       函数计算。
      </p>
     </li>
    </ul>
    <h4>
     2.
     <strong>
      区间 GCD 查询
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <code>
        ask
       </code>
       函数用于查询区间
       <code>
        [l, r]
       </code>
       的 GCD。
      </p>
     </li>
     <li>
      <p>
       如果当前节点区间完全包含在查询区间内，则直接返回节点值。
      </p>
     </li>
     <li>
      <p>
       否则递归查询左右子区间，并计算 GCD。
      </p>
     </li>
    </ul>
    <h4>
     3.
     <strong>
      滑动窗口枚举
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       使用双指针
       <code>
        i
       </code>
       和
       <code>
        j
       </code>
       枚举区间。
      </p>
     </li>
     <li>
      <p>
       如果区间
       <code>
        [i, j]
       </code>
       的 GCD 为 1，则尝试缩小窗口（移动
       <code>
        i
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       记录满足条件的最短区间长度
       <code>
        ans
       </code>
       。
      </p>
     </li>
    </ul>
    <h4>
     4.
     <strong>
      结果计算
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       如果找到满足条件的区间，输出
       <code>
        n + ans - 1
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       否则输出 -1。
      </p>
     </li>
    </ul>
    <hr/>
    <h3>
     代码优化建议
    </h3>
    <ol>
     <li>
      <h4>
       <strong>
        变量命名
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         变量名如
         <code>
          lc
         </code>
         、
         <code>
          rc
         </code>
         、
         <code>
          nord
         </code>
         等不够直观，建议改为更具描述性的名称，如
         <code>
          left_child
         </code>
         、
         <code>
          right_child
         </code>
         、
         <code>
          Node
         </code>
         等。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        代码可读性
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         添加注释，解释关键逻辑和变量的含义。
        </p>
       </li>
       <li>
        <p>
         使用空格和换行符提高代码的可读性。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        边界条件处理
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         确保数组下标从 1 开始，避免越界问题。
        </p>
       </li>
       <li>
        <p>
         在滑动窗口枚举时，注意
         <code>
          i
         </code>
         和
         <code>
          j
         </code>
         的移动条件。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <h4>
       <strong>
        时间复杂度
       </strong>
       ：
      </h4>
      <ul>
       <li>
        <p>
         线段树构建的时间复杂度为 O(n)。
        </p>
       </li>
       <li>
        <p>
         区间查询的时间复杂度为 O(log n)。
        </p>
       </li>
       <li>
        <p>
         滑动窗口枚举的时间复杂度为 O(n log n)。
        </p>
       </li>
       <li>
        <p>
         总体时间复杂度为 O(n log n)，效率较高。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h3>
     修正后的代码
    </h3>
    <pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

const int MAXN = 1234567;
int n, a[MAXN], cnt;

struct Node {
    int l, r, mx;
} t[MAXN * 4];

// 构建线段树
void build(int k, int l, int r) {
    t[k].l = l, t[k].r = r;
    if (l == r) {
        t[k].mx = a[l];
        return;
    }
    int mid = (l + r) / 2;
    build(2 * k, l, mid);
    build(2 * k + 1, mid + 1, r);
    t[k].mx = __gcd(t[2 * k].mx, t[2 * k + 1].mx);
}

// 查询区间 GCD
int ask(int k, int l, int r) {
    if (l &lt;= t[k].l &amp;&amp; r &gt;= t[k].r) return t[k].mx;
    int ans = 0;
    int mid = (t[k].l + t[k].r) / 2;
    if (l &lt;= mid) ans = __gcd(ans, ask(2 * k, l, r));
    if (r &gt; mid) ans = __gcd(ans, ask(2 * k + 1, l, r));
    return ans;
}

signed main() {
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
        cnt += (a[i] == 1 ? 1 : 0);
    }

    build(1, 1, n);

    // 特殊情况：数组中已经有 1
    if (cnt) {
        cout &lt;&lt; n - cnt &lt;&lt; endl;
        return 0;
    }

    int ans = 1e9;
    int i = 1;

    // 滑动窗口枚举
    for (int j = 1; j &lt;= n; j++) {
        while (i &lt; j &amp;&amp; ask(1, i + 1, j) == 1) i++;
        if (ask(1, i, j) == 1) ans = min(ans, j - i + 1);
    }

    // 输出结果
    if (ans == 1e9) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; n + ans - 1 &lt;&lt; endl;

    return 0;
}</code></pre>
    <hr/>
    <h3 style="background-color:transparent">
     总结
    </h3>
    <p>
     这段代码通过线段树和滑动窗口的结合，高效地解决了区间 GCD 问题。修正后的代码提高了可读性和健壮性，同时保留了原有的高效逻辑。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303837313739362f:61727469636c652f64657461696c732f313436313038333231" class_="artid" style="display:none">
 </p>
</div>


