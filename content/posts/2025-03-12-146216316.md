---
layout: post
title: "MQ消息发送不在MySQL事务中,该如何保证一致性"
date: 2025-03-12 22:08:45 +0800
description: "（RocketMQ 环境），结合幂等设计与重试机制，可有效解决 MQ 与数据库事务分离场景下的数据一致性问题。：任何 MQ（如 Kafka、RabbitMQ），需业务系统额外开发。：实时性略低（依赖 Binlog 解析延迟），需维护 CDC 服务。：强依赖 MQ 且支持事务消息的系统（如 RocketMQ）。：依赖特定 MQ（如 RocketMQ），技术栈受限。：高吞吐、解耦业务与消息发送的场景（如数据同步）。：需维护消息表，增加数据库压力。：与 MQ 无关，兼容性强。：原生支持，流程标准化。"
keywords: "MQ消息发送不在MySQL事务中，该如何保证一致性？"
categories: ['未分类']
tags: ['消息队列事务', '消息队列', '数据库', 'Mysql', 'Mq']
artid: "146216316"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216316
    alt: "MQ消息发送不在MySQL事务中,该如何保证一致性"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216316
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216316
cover: https://bing.ee123.net/img/rand?artid=146216316
image: https://bing.ee123.net/img/rand?artid=146216316
img: https://bing.ee123.net/img/rand?artid=146216316
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MQ消息发送不在MySQL事务中，该如何保证一致性？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     在 MQ 消息发送与 MySQL 事务分离的场景下，可通过以下方案保障数据一致性：
    </p>
    <hr/>
    <h4>
     <a id="_6">
     </a>
     <strong>
      一、核心原则
     </strong>
    </h4>
    <p>
     确保
     <strong>
      业务操作成功
     </strong>
     与
     <strong>
      消息发送成功
     </strong>
     的最终一致性，避免因网络抖动、服务宕机等异常导致以下问题：
    </p>
    <ul>
     <li>
      <strong>
       场景1
      </strong>
      ：业务操作成功但消息未发送（下游无感知）
     </li>
     <li>
      <strong>
       场景2
      </strong>
      ：业务操作失败但消息已发送（下游误处理）
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_13">
     </a>
     <strong>
      二、具体方案
     </strong>
    </h4>
    <h5>
     <a id="1_RocketMQ__15">
     </a>
     <strong>
      1. 事务消息（RocketMQ 专有）
     </strong>
    </h5>
    <p>
     <strong>
      适用场景
     </strong>
     ：强依赖 MQ 且支持事务消息的系统（如 RocketMQ）。
     <br/>
     <strong>
      核心流程
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       发送半消息
      </strong>
      ：业务操作前发送半消息（暂不可消费）。
     </li>
     <li>
      <strong>
       执行本地事务
      </strong>
      ：执行业务逻辑（如 MySQL 更新）。
     </li>
     <li>
      <strong>
       提交/回滚
      </strong>
      ：
      <ul>
       <li>
        若事务成功 → 提交半消息为可消费状态。
       </li>
       <li>
        若事务失败 → 回滚半消息（不投递）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       事务回查
      </strong>
      ：若未收到二次确认，MQ 主动询问事务状态（兜底机制）。
     </li>
    </ol>
    <p>
     <strong>
      代码示例
     </strong>
     （RocketMQ）：
    </p>
    <pre><code class="prism language-java"><span class="token comment">// 发送半消息</span>
<span class="token class-name">TransactionSendResult</span> result <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 实现 LocalTransactionChecker 处理回查</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">checkDBTransactionStatus</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getTransactionId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">COMMIT</span> <span class="token operator">:</span> <span class="token constant">ROLLBACK</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      优点
     </strong>
     ：原生支持，流程标准化。
     <br/>
     <strong>
      缺点
     </strong>
     ：依赖特定 MQ（如 RocketMQ），技术栈受限。
    </p>
    <hr/>
    <h5>
     <a id="2__41">
     </a>
     <strong>
      2. 本地消息表（通用方案）
     </strong>
    </h5>
    <p>
     <strong>
      适用场景
     </strong>
     ：任何 MQ（如 Kafka、RabbitMQ），需业务系统额外开发。
     <br/>
     <strong>
      实现步骤
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       同库事务
      </strong>
      ：业务操作与消息记录写入同一数据库事务。
      <pre><code class="prism language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> <span class="token keyword">order</span> <span class="token keyword">SET</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">'paid'</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 业务操作</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mq_message <span class="token punctuation">(</span>id<span class="token punctuation">,</span> content<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token string">'order_paid'</span><span class="token punctuation">,</span> <span class="token string">'pending'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 消息记录</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      <strong>
       异步发送
      </strong>
      ：定时任务轮询
      <code>
       mq_message
      </code>
      表，发送状态为
      <code>
       pending
      </code>
      的消息。
     </li>
     <li>
      <strong>
       确认与重试
      </strong>
      ：
      <ul>
       <li>
        发送成功 → 更新消息状态为
        <code>
         sent
        </code>
        。
       </li>
       <li>
        发送失败 → 记录重试次数，超过阈值则标记为
        <code>
         dead_letter
        </code>
        （人工介入）。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     <strong>
      优点
     </strong>
     ：与 MQ 无关，兼容性强。
     <br/>
     <strong>
      缺点
     </strong>
     ：需维护消息表，增加数据库压力。
    </p>
    <hr/>
    <h5>
     <a id="3_Spring__61">
     </a>
     <strong>
      3. 事务同步监听（Spring 生态）
     </strong>
    </h5>
    <p>
     <strong>
      适用场景
     </strong>
     ：基于 Spring 事务管理的系统。
     <br/>
     <strong>
      实现方式
     </strong>
     ：
    </p>
    <pre><code class="prism language-java"><span class="token annotation punctuation">@Transactional</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processOrder</span><span class="token punctuation">(</span><span class="token class-name">Order</span> order<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    orderDao<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 业务操作</span>
    <span class="token class-name">TransactionSynchronizationManager</span><span class="token punctuation">.</span><span class="token function">registerSynchronization</span><span class="token punctuation">(</span>
        <span class="token keyword">new</span> <span class="token class-name">TransactionSynchronization</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 事务提交后发送消息</span>
                mqService<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <strong>
      注意事项
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       发送失败处理
      </strong>
      ：需配合重试机制（如
      <code>
       @Retryable
      </code>
      ）或记录日志人工补偿。
     </li>
     <li>
      <strong>
       避免事务未提交提前发送
      </strong>
      ：确保消息发送在
      <code>
       afterCommit
      </code>
      回调中触发。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="4__Binlog_CDC__85">
     </a>
     <strong>
      4. 基于 Binlog 的变更捕获（CDC 方案）
     </strong>
    </h5>
    <p>
     <strong>
      适用场景
     </strong>
     ：高吞吐、解耦业务与消息发送的场景（如数据同步）。
     <br/>
     <strong>
      实现流程
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       监听数据库日志
      </strong>
      ：通过工具（如 Canal、Debezium）解析 MySQL Binlog。
     </li>
     <li>
      <strong>
       过滤变更事件
      </strong>
      ：捕获业务表变更（如订单状态更新）。
     </li>
     <li>
      <strong>
       发送 MQ 消息
      </strong>
      ：将变更事件投递到 MQ。
     </li>
    </ol>
    <p>
     <strong>
      优点
     </strong>
     ：完全解耦业务代码，适合大数据量场景。
     <br/>
     <strong>
      缺点
     </strong>
     ：实时性略低（依赖 Binlog 解析延迟），需维护 CDC 服务。
    </p>
    <hr/>
    <h4>
     <a id="_97">
     </a>
     <strong>
      三、最终一致性保障
     </strong>
    </h4>
    <p>
     无论采用何种方案，需补充以下措施：
    </p>
    <ol>
     <li>
      <strong>
       消费者幂等
      </strong>
      ：通过唯一 ID（如业务主键）去重，避免重复消费。
     </li>
     <li>
      <strong>
       死信队列（DLQ）
      </strong>
      ：处理多次重试失败的消息，人工介入修复。
     </li>
     <li>
      <strong>
       对账补偿
      </strong>
      ：定时比对业务数据与消息消费状态，修复不一致。
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_105">
     </a>
     <strong>
      四、方案对比
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        方案
       </th>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
       <th>
        适用场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         事务消息
        </strong>
       </td>
       <td>
        原生支持，流程标准化
       </td>
       <td>
        依赖 RocketMQ
       </td>
       <td>
        强事务需求且使用 RocketMQ
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         本地消息表
        </strong>
       </td>
       <td>
        通用性强，兼容所有 MQ
       </td>
       <td>
        需维护消息表
       </td>
       <td>
        技术栈受限或需高可靠性
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         事务同步监听
        </strong>
       </td>
       <td>
        代码侵入小，Spring 生态友好
       </td>
       <td>
        需处理发送失败补偿
       </td>
       <td>
        中小规模 Spring 项目
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Binlog 变更捕获
        </strong>
       </td>
       <td>
        完全解耦业务
       </td>
       <td>
        实时性低，维护成本高
       </td>
       <td>
        大数据量、异步数据同步场景
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <p>
     <strong>
      总结
     </strong>
     ：优先选择
     <strong>
      本地消息表
     </strong>
     （通用性强）或
     <strong>
      事务消息
     </strong>
     （RocketMQ 环境），结合幂等设计与重试机制，可有效解决 MQ 与数据库事务分离场景下的数据一致性问题。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c0aa5ca5532f47e0b5f3f9f513eb1572.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323530385f39303538303439322f:61727469636c652f64657461696c732f313436323136333136" class_="artid" style="display:none">
 </p>
</div>


