---
layout: post
title: "高并发内存池细节处理-性能优化-总结"
date: 2025-03-13 11:04:17 +0800
description: "STL容器是线程不安全的，多线程在并发用unordered_map的时候会有线程不安全的问题，在PageCache中对unordered_map写之前我们加锁了，但是在读unordered_map我们并没有加锁。这样我们就知道通过释放内存块的地址，转变成页号，在找到对应的Span，拿到_objsize就知道这个内存块大小了。写是在PageCache是加过锁的，读的时候就是在释放的时候去读，在读这个Span的时候，这个Span早在拿它的时候就写过了。，所有就减少了读写并发的问题，也就少了很多加锁解锁。"
keywords: "【高并发内存池】细节处理 + 性能优化 + 总结"
categories: ['高并发内存池']
tags: ['缓存', '性能优化', 'C']
artid: "145934809"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145934809
    alt: "高并发内存池细节处理-性能优化-总结"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145934809
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145934809
cover: https://bing.ee123.net/img/rand?artid=145934809
image: https://bing.ee123.net/img/rand?artid=145934809
img: https://bing.ee123.net/img/rand?artid=145934809
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【高并发内存池】细节处理 + 性能优化 + 总结
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/a7a0a92dc5bbb18299c7e7e9b2c1abe2.jpeg#pic_center"/>
    </p>
    <h2>
     <a id="1__4">
     </a>
     1. 细节处理
    </h2>
    <h3>
     <a id="11_1_5">
     </a>
     1.1 细节1
    </h3>
    <p>
     我们这个项目本来就是要代替系统的内存分配相关函数malloc和free，但是在我们的代码中还是在通过new申请，delete释放。new底层封装了malloc，delete底层封装了free。还是没和malloc和free脱离。
    </p>
    <p>
     这里我们就可以把项目最开始做的定长内存池拿过来用了。它是一个模板想要什么类型内存找它要就行了。下面就把用到new和delete的地方都换成去找定长内存池申请和释放。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//ObjectPool.h</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">ObjectPool</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">ObjectPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_memory</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_remainBytes</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_freelist</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	T<span class="token operator">*</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		T<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token comment">//如果链表中有空闲的内存块,就优先使用</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_freelist<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//头删</span>
			<span class="token keyword">void</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>_freelist<span class="token punctuation">;</span>
			obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_freelist<span class="token punctuation">;</span>
			_freelist <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//if (_memory == nullptr)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>_remainBytes <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果当前内存块不够一个T类型,就重新申请一大快内存快</span>
			<span class="token punctuation">{<!-- --></span>
				_remainBytes <span class="token operator">=</span> <span class="token number">128</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
				<span class="token comment">//_memory = (char*)malloc(_remain);</span>
				_memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>_remainBytes <span class="token operator">&gt;&gt;</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按页申请,想要每页8kb,申请多少页</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_memory <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			obj <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span>_memory<span class="token punctuation">;</span>
			<span class="token comment">//保证内存块至少能放下一个地址</span>
			size_t Size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_memory <span class="token operator">+=</span> Size<span class="token punctuation">;</span>
			_remainBytes <span class="token operator">-=</span> Size<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 定位new，显示调用T的构造函数初始化</span>
		<span class="token keyword">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>T<span class="token punctuation">;</span>

		<span class="token keyword">return</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span>T<span class="token operator">*</span> obj<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//对释放的内存块进行头插</span>

		<span class="token comment">// 显示调用析构函数清理对象</span>
		obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//直接头插</span>
		<span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> _freelist<span class="token punctuation">;</span>
		_freelist <span class="token operator">=</span> obj<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">char</span><span class="token operator">*</span> _memory<span class="token punctuation">;</span><span class="token comment">//指向申请的一大块内存</span>
	size_t _remainBytes<span class="token punctuation">;</span><span class="token comment">//记录申请一大块内存还剩下多少内存</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freelist<span class="token punctuation">;</span><span class="token comment">//指向释放后的内存,以链表形式管理起来</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">//PageCache.h</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Common.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"ObjectPool.h"</span></span>

<span class="token comment">//所有线程共享一个PageCache</span>
<span class="token keyword">class</span> <span class="token class-name">PageCache</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> PageCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInst<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//从PageCache第k号桶中获取一个span对象</span>
	Span<span class="token operator">*</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 获取从对象到span的映射</span>
	Span<span class="token operator">*</span> <span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 释放空闲span回到Pagecache，并合并相邻的span</span>
	<span class="token keyword">void</span> <span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
	PageCache<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

	<span class="token keyword">static</span> PageCache _sInst<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Spanlist _spanlists<span class="token punctuation">[</span>NPAGES<span class="token punctuation">]</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>PAGE_ID<span class="token punctuation">,</span> Span<span class="token operator">*</span><span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span><span class="token comment">//记录页号和span一一对应关系</span>
	ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span> <span class="token comment">//申请Span的地方都用定长内存池申请,不用new</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>mutex _pageMtx<span class="token punctuation">;</span> <span class="token comment">//整个锁</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">//PageCache.cpp</span>

<span class="token comment">//从PageCache第k号桶中获取一个span对象</span>
Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//assert(k &gt; 0 &amp;&amp; k &lt; NPAGES);</span>

	<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//大于 128page找堆要</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//申请一个span对象管理这块内存,释放内存的时候要对应的span</span>
		<span class="token comment">//Span* span = new Span;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>
		_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>
		<span class="token keyword">return</span> span<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//这里加锁递归会有死锁问题，除非用递归互斥锁，还有在外面调用这个函数之前加锁</span>

	<span class="token comment">// 先检查第k个桶里面有没有span</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_spanlists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Span<span class="token operator">*</span> Kspan <span class="token operator">=</span> _spanlists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


		<span class="token comment">//将Kspan给CentralCache之前,先将页号和span对应关系记录</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Kspan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_idSpanMap<span class="token punctuation">[</span>Kspan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> Kspan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//将管理k页的span给Central Cache</span>
		<span class="token keyword">return</span> Kspan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//走到这里第k个桶没有span，那就继续往下面的桶找</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_spanlists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//将一个管理更多页的span，变成两个span，一个管理k页，一个管理i-k页</span>
			Span<span class="token operator">*</span> Ispan <span class="token operator">=</span> _spanlists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//Span* Kspan = new Span;</span>
			Span<span class="token operator">*</span> Kspan <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			Kspan<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> Ispan<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">;</span>
			Kspan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>

			Ispan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+=</span> k<span class="token punctuation">;</span>
			Ispan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span>

			<span class="token comment">//将Ispan挂在对应大小的桶</span>
			_spanlists<span class="token punctuation">[</span>Ispan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>Ispan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//记录挂在PageCache中还未被使用的Ispan的页号和span对应关系</span>
			<span class="token comment">//这里仅需记录这个span的首页和尾页与Ispan的对应关系即可,</span>
			<span class="token comment">//不像返回给CentralCache的Kspan的需要把这个Kspan管理的每一页都和Kspan建立映射关系</span>
			<span class="token comment">//因为合并仅需知道每个Ispan的首页和尾页就可以找到Ispan,而返回给CentralCache的Kspan,</span>
			<span class="token comment">//首先需要将Kspan切成一块块小内存才行才能再给ThreadCache用,</span>
			<span class="token comment">//当小内存回来/8kb可能是Kspan管理的其中某一页,才能知道该页对应span</span>
			_idSpanMap<span class="token punctuation">[</span>Ispan<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">]</span> <span class="token operator">=</span> Ispan<span class="token punctuation">;</span>
			_idSpanMap<span class="token punctuation">[</span>Ispan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> Ispan<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Ispan<span class="token punctuation">;</span>


			<span class="token comment">//将Kspan给CentralCache之前,先将页号和span对应关系记录</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Kspan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				_idSpanMap<span class="token punctuation">[</span>Kspan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> Kspan<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">//将管理k页的span给Central Cache</span>
			<span class="token keyword">return</span> Kspan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//走到这里说明，后面的位置都没有大页的span</span>
	<span class="token comment">//那就去找堆申请一个128page的span</span>
	<span class="token comment">//Span* bigSpan = new Span;</span>
	Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bigSpan<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
	bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//span挂在对应桶下</span>
	_spanlists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//重复上述过程寻找k号桶的span，一定还回一个span</span>
	<span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>



<span class="token comment">// 释放空闲span回到Pagecache，并合并相邻的span</span>
<span class="token keyword">void</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//大于 128page直接还给堆</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">SystemFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete span;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token comment">// 如何知道相邻的span是否能合并?</span>
	<span class="token comment">// 通过自己的页号找到相邻的span看是否能合并,如果该页的span在PageCache说明该span还没有被使用,可以合并</span>
	<span class="token comment">// 如果在CentralCache说明该span正在被使用,不能合并</span>

	<span class="token comment">// 如何知道一个span是否被使用? 是用span中的usecount是否等于0吗? 不能!!</span>
	<span class="token comment">// 这里有一个空档时间,当thread1线程通过TLS找到自己threadcache申请内存块,但是没有,</span>
	<span class="token comment">// 就去找CentralCache,但是CentralCache对应桶下也没有,那就只能去找PageCache了</span>
	<span class="token comment">// PageCache返回给CentralCache一个span,这个span的usecount初始可是0,</span>
	<span class="token comment">// CentralCache拿到后对span这一大块内存切成一块块小内存</span>
	<span class="token comment">// 在挂到对应桶下,但是这时候thread2,要合并这个span,那就有问题了,thread1正准备从这span拿一批量</span>
	<span class="token comment">// 但是还没有拿到,这个span的usecount可还是0,只有拿走了usecount才会++</span>
	<span class="token comment">// thread2把这个span和自己span合并了,那就造成线程安全的问题!!</span>

	<span class="token comment">// 因此需要给span对象加一个isuse成员记录这个span是否被使用</span>


	<span class="token comment">// 如何通过页号找到相邻的页? 还是得用unordered_map记录页号合span对应关系</span>
	<span class="token comment">// 但是目前的unordered_map只记录了给CentralCache已经被使用的span的页号和span对应关系</span>
	<span class="token comment">// 并没有记录在PageCache的span的页号和span对应关系</span>
	<span class="token comment">// 因此需要把在PageCache的span的页号和span对应关系也要记录在unordered_map中</span>


	<span class="token comment">//先走前面相邻的span是否能合并,能合并就一直合</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		PAGE_ID prevId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>prevId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 前面的页号没有，不合并了(堆申请内存已经到了起始地址)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		
		<span class="token comment">// 前面相邻页的span在使用，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_isuse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 合并出超过128页的span没办法挂在桶下，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 用span合并prevSpan</span>
		span<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>

		<span class="token comment">// 将pevSpan从对应的桶中删除</span>
		_spanlists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete prevSpan;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 这里可能有疑问,那遗留unordered_map中被合并的对应页和prevSpan之间一对一的关系难道不删除吗?</span>
		<span class="token comment">// 因为prevSpan已经被删除了,在去通过已有页去找span那就是野指针了! 但其实并不用删除.</span>
		<span class="token comment">// 首先被合并的页已经被span管理起来了,合并结束之后会被挂在对应桶下,并且记录该span首页和尾页与span的对应关系.</span>
		<span class="token comment">// 当CentralCache要的时候,在把span切分成两个span,返回给CentralCache的Kspan每页都和Kspan重新进行映射</span>
		<span class="token comment">// 留在PageCache的Ispan的首页和尾页也会和Ispan重新映射</span>
		<span class="token comment">// 这样的话,以前被合并,遗留下来的页又和新得span建立了映射关系,就不会有通过页找span会有野指针的问题</span>

	<span class="token punctuation">}</span>

	<span class="token comment">//找后面相邻的span合并</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		PAGE_ID nextId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>nextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 后面的页号没有，不合并了(堆申请内存已经到了结尾地址)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		Span<span class="token operator">*</span> nextSpan <span class="token operator">=</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
		<span class="token comment">// 后面相邻页的span在使用，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_isuse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 合并出超过128页的span没办法挂在桶下，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>

		_spanlists<span class="token punctuation">[</span>nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete nextSpan;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//合并好的span挂在对应桶下</span>
	_spanlists<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	span<span class="token operator">-&gt;</span>_isuse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token comment">//重新映射在PageCace的Span的首页和尾页与Span映射关系</span>
	_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>
	_idSpanMap<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> span<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">//ConcurrentAlloc.h</span>

<span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token comment">//大于256KB/8KB=13page 小于等于128page 找PageCache要</span>
	<span class="token comment">//大于128page找堆要</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//找PageCache或者堆要都是以页为单位对齐</span>
		size_t alignnum <span class="token operator">=</span> <span class="token class-name">SizeClass</span><span class="token double-colon punctuation">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//在PageCache那个桶</span>
		size_t kpage <span class="token operator">=</span> alignnum <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>

		<span class="token comment">//在PageCache内部处理找是否找堆要</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>kpage<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//这里也不需要记录这个span已经被使用,因为还得时候合并的这个span相邻页的span看是否在使用</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//得到地址返回</span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token comment">//小于256KB通过三层缓存要</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//通过TLS 每个线程无锁的获取自己的专属的ThreadCache对象</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//pTLSThreadCache = new ThreadCache;</span>
			<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>ThreadCache<span class="token operator">&gt;</span> tcPool<span class="token punctuation">;</span><span class="token comment">//静态对象只存在一份，所有线程共享</span>
			pTLSThreadCache <span class="token operator">=</span> tcPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//cout &lt;&lt; std::this_thread::get_id() &lt;&lt; " : " &lt;&lt; pTLSThreadCache &lt;&lt; endl;</span>
		<span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="12_2_377">
     </a>
     1.2 细节2
    </h3>
    <p>
     调用释放内存函数的时候，我们不仅传了地址，还传了一个size表示释放内存块有多大。不想传这个大小，但是下面还得用这个大小，用来判断释放的内存是否小于256KB通过ThreadCache去还，还是大于32Page小于等于128Page还给PageCache，还是大于128Page直接还给堆，怎么办？
    </p>
    <p>
     其实我们可以在给Span一个成员_objsize，记录当前Span内切好的内存块对象有多大，如果一个Span中做了切分所有小内存块大小都是固定大小。还有直接找PageCache和找堆要的，虽然Span内不做切分，但是我们也给记着。这样我们就知道通过释放内存块的地址，转变成页号，在找到对应的Span，拿到_objsize就知道这个内存块大小了。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//Common.hpp</span>

<span class="token comment">//Span管理一个跨度的大块内存</span>

<span class="token comment">//管理以页为单位的大快内存</span>
<span class="token keyword">struct</span> <span class="token class-name">Span</span>
<span class="token punctuation">{<!-- --></span>
	PAGE_ID _pageid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//管理一大块连续内存块的起始页的页号</span>
	size_t _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//管理几页</span>

	Span<span class="token operator">*</span> _prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//带头双向循环链表前指针</span>
	Span<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//带头双向循环链表后指针</span>

	size_t _objsize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录切分成一个个小内存块的大小</span>

	size_t _usecount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录Span对象中自由链表挂的内存块对象使用数量</span>
	<span class="token keyword">void</span><span class="token operator">*</span> _freelist <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//自由链表挂的是Span对象一块大连续内存块按照桶位置大小切分的一块块小的内存块</span>

	<span class="token keyword">bool</span> _isuse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//当前Span是否被使用</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     当CentralCache从PageCache拿到一个Span，然后要做切分，这个时候我们需要处理一下对应Span的_objsize。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//CentralCache.hpp</span>

<span class="token comment">// 获取一个非空的span</span>
Span<span class="token operator">*</span> <span class="token class-name">CentralCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetOneSpan</span><span class="token punctuation">(</span>Spanlist<span class="token operator">&amp;</span> list<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//遍历对应桶中是否有span或者span中是否有内存对象</span>
	Span<span class="token operator">*</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-&gt;</span>_freelist<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> it<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			it <span class="token operator">=</span> it<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//当Central Cache对应桶下面没有span，那就往下一层Page Cache找，但是首先要先把对应桶锁释放</span>
	<span class="token comment">//如果再来一个线程是申请内存但是没有内存锁住也没问题，但是如果这个线程是来还内存的呢？</span>
	<span class="token comment">//锁住那不就还不了了，因此往下走之前先把桶锁释放</span>
	list<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//走到这里说明该桶中并没有span或者span中没有内存对象,Central Cache那就找到下一层Page Cache要一个span</span>
	<span class="token comment">//Page Cache 是一个按桶下标映射的哈希桶，第i号桶表示这个桶下面的span管理的都是i页page</span>
	<span class="token comment">//central找page要，关注的是要的span是管理k页的span，然后就去k号桶去要</span>
	<span class="token comment">//PageCache的锁是一把整锁，虽然也可以是桶锁但是消耗性能</span>
	<span class="token comment">//当PageCache对应桶没有span就往下面桶继续找，就涉及多个桶加锁解锁，</span>
	<span class="token comment">//因此我们在最外面直接把PageCache锁住，只加锁解锁一次即可</span>

	<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span><span class="token class-name">SizeClass</span><span class="token double-colon punctuation">::</span><span class="token function">NumMovePage</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//在CentralCache中的span是已经被使用的span</span>
	span<span class="token operator">-&gt;</span>_isuse <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//span被使用</span>
	span<span class="token operator">-&gt;</span>_objsize <span class="token operator">=</span> size<span class="token punctuation">;</span><span class="token comment">//切分成一个个小内存块的大小</span>
	<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



	<span class="token comment">//从PageCache拿上来的span是每一个线程独享的，因此切片时不需要加锁</span>

	<span class="token comment">//把从PageCache拿回的span切分成size大小的一个个内存块挂在自由链表，最后再把span挂在对应的桶中</span>

	<span class="token comment">//根据页号找到span管理的一大块内存的起始地址</span>
	<span class="token comment">//地址用char* 方便下面地址++</span>
	<span class="token keyword">char</span><span class="token operator">*</span> start <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//计算这块内存有多大</span>
	size_t bytes <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
	<span class="token comment">//结尾地址</span>
	<span class="token keyword">char</span><span class="token operator">*</span> end <span class="token operator">=</span> start <span class="token operator">+</span> bytes<span class="token punctuation">;</span>

	<span class="token comment">//使用尾插法将大内存变成大小为size的一快快小内存挂在自由链表上</span>
    span<span class="token operator">-&gt;</span>_freelist <span class="token operator">=</span> start<span class="token punctuation">;</span>
	start <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> tail <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_freelist<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>
		tail <span class="token operator">=</span> start<span class="token punctuation">;</span>
		start <span class="token operator">+=</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//自由链表最后为nullptr</span>
	<span class="token function">NextObj</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

	<span class="token comment">//切好span以后，需要把span挂到桶里面去的时候，再加锁</span>
	list<span class="token punctuation">.</span>_mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//再把span挂在对应桶</span>
	list<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> span<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     直接从PageCache和堆要的我们拿到之后也要记录对应Span的_objsize
    </p>
    <pre><code class="prism language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token comment">//大于256KB/8KB=13page 小于等于128page 找PageCache要</span>
	<span class="token comment">//大于128page找堆要</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//找PageCache或者堆要都是以页为单位对齐</span>
		size_t alignnum <span class="token operator">=</span> <span class="token class-name">SizeClass</span><span class="token double-colon punctuation">::</span><span class="token function">RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//在PageCache那个桶</span>
		size_t kpage <span class="token operator">=</span> alignnum <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>

		<span class="token comment">//在PageCache内部处理找是否找堆要</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>kpage<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//这里也不需要记录这个span已经被使用,因为还得时候合并的这个span相邻页的span看是否在使用</span>
		<span class="token comment">//虽然这里Span不切分成一个个小内存,但是为了方便释放内存的时候不传大小,也需要把内存大小记录</span>
		span<span class="token operator">-&gt;</span>_objsize <span class="token operator">=</span> alignnum<span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//得到地址返回</span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>

	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token comment">//小于256KB通过三层缓存要</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//通过TLS 每个线程无锁的获取自己的专属的ThreadCache对象</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pTLSThreadCache <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//pTLSThreadCache = new ThreadCache;</span>
			<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>ThreadCache<span class="token operator">&gt;</span> tcPool<span class="token punctuation">;</span><span class="token comment">//静态对象,每个线程进来都用的是自己内部第一次创建的那一个</span>
			pTLSThreadCache <span class="token operator">=</span> tcPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//cout &lt;&lt; std::this_thread::get_id() &lt;&lt; " : " &lt;&lt; pTLSThreadCache &lt;&lt; endl;</span>
		<span class="token keyword">return</span> pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这样还得时候，直接通过Span就知道这个内存块的大小了。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//static void ConcurrentFree(void* ptr,size_t size)</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ConcurrentFree</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

	<span class="token comment">//释放内存的时候我们除了传地址还需要传内存块大小是多少,</span>
	<span class="token comment">//但是现在我们不想传这个大小了,但是下面我们还必须要用这大小,如何解决?</span>
	<span class="token comment">//申请的内存都是从Span拿的,我们可以给Span增加一个记录切分小内存块大小的成员</span>
	<span class="token comment">//这样通过地址,拿到Span,就知道还的内存块大小是多少</span>

	<span class="token comment">//根据地址找转换为对应的页号,通过页号找到对应的span,在找到对应内存大小</span>
	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t size <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_objsize<span class="token punctuation">;</span>

	<span class="token comment">//大于32page小于等于128page直接还给PageCache,</span>
	<span class="token comment">//大于128page直接还给堆</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> MAX_BYTES<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_pageMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span>pTLSThreadCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pTLSThreadCache<span class="token operator">-&gt;</span><span class="token function">Deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="13_3_556">
     </a>
     1.3 细节3
    </h3>
    <p>
     STL容器是线程不安全的，多线程在并发用unordered_map的时候会有线程不安全的问题，在PageCache中对unordered_map写之前我们加锁了，但是在读unordered_map我们并没有加锁。比如从CentralCache还内存块给对应的Span，我们先通过内存块的地址找到页号，在通过页号找到对应Span。还有在释放内存的时候我们页需要知道这个内存块的大小，也是通过内存的地址找到页号在找到对应Span。都调用了下面的函数。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 获取从对象到span的映射</span>
Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     因此在读之前也要加锁，如果在调用这个函数之前加锁，在调用解锁之后解锁，那就需要在多个地方写加锁解锁。因此我们直接在这个函数里面加锁，这里我们用一个RAII风格的锁，构造时加锁，析构时解锁。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">// 获取从对象到span的映射</span>
Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//STL容器是线程不安全的,多个地方会访问unordered_map</span>
	std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>_pageMtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> ret <span class="token operator">=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> _idSpanMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> ret<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="2_597">
     </a>
     2.复杂情况下的调试技巧
    </h2>
    <p>
     代码多，可能有不小心写错的地方，这个时候在按照以往F11一步一步去走就太慢了。这里我们有几种方法。
    </p>
    <ol>
     <li>
      <strong>
       测试验证 + 条件断点
      </strong>
     </li>
    </ol>
    <p>
     比如下面一段代码，向ThreadCache一次挂一批内存块。如果这里有不对的地方。
     <br/>
     就写个测试验证然后在写一个if条件判断，if里面随便写一句就行，然后在这里打个断点。如果一次没有挂这里多，就会在if里面停下来。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//一次挂一批</span>
<span class="token keyword">void</span> <span class="token function">PushRange</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> end<span class="token punctuation">,</span>size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">NextObj</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">=</span> _freelist<span class="token punctuation">;</span>
	_freelist <span class="token operator">=</span> start<span class="token punctuation">;</span>
	_size <span class="token operator">+=</span> n<span class="token punctuation">;</span>

	<span class="token comment">//void* cur = start;</span>
	<span class="token comment">//size_t j = 0;</span>
	<span class="token comment">//while (cur)</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	cur = NextObj(cur);</span>
	<span class="token comment">//	++j;</span>
	<span class="token comment">//}</span>

	<span class="token comment">//if (j != n)</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	int x = 0;</span>
	<span class="token comment">//}</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="2">
     <li>
      <strong>
       在调试哪里把调用栈帧打开（看是谁调的这个函数）
      </strong>
     </li>
     <li>
      <strong>
       然后把监视打开
      </strong>
     </li>
     <li>
      <strong>
       如果程序疑似死循环，可以点击中断程序，程序会正在运行的地方停下来
      </strong>
     </li>
    </ol>
    <h2>
     <a id="3__632">
     </a>
     3. 性能分析
    </h2>
    <p>
     你怎么知道当前项目性能怎么样，是哪里造成性能不好的原因？VS点击下面就行性能分析，你会发现当前项目甚至不如malloc和free快。慢的原因就是由于在读写unordered_map的时候一直在加锁解锁导致性能低下。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/db85ae13e4e246009dca14d3a4999dcf.png"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/11f7ff78bacb4e0f974816202c4efc74.png"/>
    </p>
    <p>
     可以用下面这段代码测一测。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//Benchmark.hpp</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"ConcurrentAlloc.h"</span></span>

<span class="token comment">// ntimes 一轮申请和释放内存的次数</span>
<span class="token comment">// rounds 轮次</span>
<span class="token keyword">void</span> <span class="token function">BenchmarkMalloc</span><span class="token punctuation">(</span>size_t ntimes<span class="token punctuation">,</span> size_t nworks<span class="token punctuation">,</span> size_t rounds<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">vthread</span><span class="token punctuation">(</span>nworks<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> malloc_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> free_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nworks<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		vthread<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> k<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
			v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>ntimes<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//v.push_back(malloc(16));</span>
					v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8192</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">free</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				malloc_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span>
				free_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vthread<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次malloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次free %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> free_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发malloc&amp;free %u次，总计花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> nworks <span class="token operator">*</span> rounds <span class="token operator">*</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> free_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 单轮次申请释放次数 线程数 轮次</span>
<span class="token keyword">void</span> <span class="token function">BenchmarkConcurrentMalloc</span><span class="token punctuation">(</span>size_t ntimes<span class="token punctuation">,</span> size_t nworks<span class="token punctuation">,</span> size_t rounds<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">vthread</span><span class="token punctuation">(</span>nworks<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> malloc_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> free_costtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> nworks<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		vthread<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
			v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>ntimes<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rounds<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//v.push_back(ConcurrentAlloc(16));</span>
					v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">ConcurrentAlloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8192</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ntimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">ConcurrentFree</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				malloc_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end1 <span class="token operator">-</span> begin1<span class="token punctuation">)</span><span class="token punctuation">;</span>
				free_costtime <span class="token operator">+=</span> <span class="token punctuation">(</span>end2 <span class="token operator">-</span> begin2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vthread<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次concurrent alloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发执行%u轮次，每轮次concurrent dealloc %u次: 花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> rounds<span class="token punctuation">,</span> ntimes<span class="token punctuation">,</span> free_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u个线程并发concurrent alloc&amp;dealloc %u次，总计花费：%u ms\n"</span><span class="token punctuation">,</span>
		nworks<span class="token punctuation">,</span> nworks <span class="token operator">*</span> rounds <span class="token operator">*</span> ntimes<span class="token punctuation">,</span> malloc_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> free_costtime<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t n <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=========================================================="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">BenchmarkConcurrentMalloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token function">BenchmarkMalloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=========================================================="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     即使你把unordered_map换成map也不行。它们读写都必须加锁。比如一个线程在读的时候，另一个线程去写了。读还是老位置，如果是对map写可能会旋转，对unordered_map写可能扩容，都会导致原有位置改变。但是读还是读的老位置，就有了问题，因此必须加锁。
    </p>
    <p>
     这里我们参考Google开源tcmalloc换个数据结构，使用
     <a href="https://blog.csdn.net/ShuShengTuM/article/details/145523616?spm=1001.2014.3001.5506">
      基数树（Radix Tree）
     </a>
     ，它是一种整数到整数(地址) 的映射多叉搜索树。每层节点其实都是一个指针数组。每层指针数组大小按照有几个比特位的取值范围划分看一层数组有多大。最后一层叶子节点存对应的指针。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e2489f87d5974b5ca94de8cc2430993c.png">
      <br/>
      由于空间是提前开好的，读写都不会去动这个结构。写是在PageCache是加过锁的，读的时候就是在释放的时候去读，在读这个Span的时候，这个Span早在拿它的时候就写过了。
      <strong>
       读写分离了
      </strong>
      ，所有就减少了读写并发的问题，也就少了很多加锁解锁。性能自然就提高了。
     </img>
    </p>
    <p>
     tcmalloc写了三种基数树，一层基数树，二层基数树，三层基数树，其中一、二层基数树适用于32位下，三层基数树适用于64位下。
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fcd2b6c18e464d31842e1d91c5425202.png"/>
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//PageMap.h</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Common.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"ObjectPool.h"</span></span>

<span class="token comment">// 性能优化</span>
<span class="token comment">// 不管是用unordered_map还是用map保存页号与Span指针的映射关系,效率都太低了</span>
<span class="token comment">// 原因在于,对unordered_map还是map进行读写的时候都要进行加锁解锁导致效率低</span>
<span class="token comment">// 但是读写是必须要进行加锁的,当在对map进行写的时候可能会进行旋转,</span>
<span class="token comment">// 对unordered_map进行写的时候可能会有扩容</span>
<span class="token comment">// 考虑这样一个问题,当一个线程在读的时候,它读的时候位置结构可没变(位置没变)</span>
<span class="token comment">// 但是另一个线程去写了导致这个结构旋转/扩容,导致位置改变,进而导致原先读的位置改变了,所以造成了问题</span>
<span class="token comment">// 因此不管对这个结构读还是写都必须加锁,所以效率会低</span>

<span class="token comment">// 如何解决?</span>

<span class="token comment">// 这里可以使用基数树,基数树其实也是一个整数到整数(指针)的映射关系的多叉搜索树结构</span>
<span class="token comment">// 每层其实都是一个指针数组,每层数组下标代表对应分层比特位取值的范围大小,只有最后一层叶子节点才会存对应的指针</span>

<span class="token comment">// 假设key值等于0x840FF, 其二进制按照6bit一簇可以写成，000010 -000100 -000011 -111111，</span>
<span class="token comment">// 从左到右的index值分别为2, 4，3, 63。那么根据key值0x840FF找到value的过程就只需要4步：</span>
<span class="token comment">// 第一步，在最上层的节点A中找到index为2的slot，其slot[2]指针指向第二层节点中的节点B。</span>
<span class="token comment">// 第二步，在节点B中找到index为4的slot，其slot[4]指针指向第三层节点中的节点C。</span>
<span class="token comment">// 第三步，在节点C中找到index为3的slot，其slot[3]指针指向第三层节点中的节点D。</span>
<span class="token comment">// 第四步，在节点D中找到index为63的slot，其slot[63]指针指向叶子节点item E。</span>

<span class="token comment">// 由于这个结构是计算开辟好的,并且增删查改都会不改变这个结构</span>
<span class="token comment">// 写的时候,PageCache是整体加锁的没什么问题</span>
<span class="token comment">// 有两个地方会读,都是释放内存块的时候会去读,将地址转成页号在转成对应的Span*</span>
<span class="token comment">// 要注意的时候,读的时候是释放,而写的时候是Span切分的时候,在读之前就已经写过了</span>
<span class="token comment">// 因此读写是分离的!! 所以读根本不用加锁,因此使用基数树这个结构保存页号与Span*映射关系更好!</span>


<span class="token comment">// 一页8kb</span>
<span class="token comment">// 2^32/2^8 = 2^19</span>
<span class="token comment">// 2^64/2^8 = 2^51</span>

<span class="token comment">// Single-level array,一层基数树</span>
<span class="token comment">// 一层基数树结构适用于32位,</span>
<span class="token comment">// BITS 表示存储页号需要多少位</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap1</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span><span class="token comment">// 2^19位,数组里面存的是Span指针,所以指针数组大小 2^19 * 4 = 2 ^ 21 = 2M</span>
	<span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> array_<span class="token punctuation">;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span>

	<span class="token comment">//explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) {<!-- --></span>
	<span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//array_ = reinterpret_cast&lt;void**&gt;((*allocator)(sizeof(void*) &lt;&lt; BITS));</span>
		size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">;</span><span class="token comment">//数组大小</span>
		size_t alignSize <span class="token operator">=</span> <span class="token class-name">SizeClass</span><span class="token double-colon punctuation">::</span><span class="token function">_RoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按页(1页8KB)对齐</span>
		array_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">SystemAlloc</span><span class="token punctuation">(</span>alignSize <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SystemAlloc按照页申请</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>array_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// Return the current value for KEY.  Returns NULL if not yet set,</span>
	<span class="token comment">// or if k is out of range.</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//取</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> array_<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// REQUIRES "k" is in range "[0,2^BITS-1]".</span>
	<span class="token comment">// REQUIRES "k" has been ensured before.</span>
	<span class="token comment">//</span>
	<span class="token comment">// Sets the value 'v' for key 'k'.</span>
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//放</span>
		array_<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Two-level radix tree,两层基数树</span>
<span class="token comment">// 也适合32位</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span> <span class="token comment">//2^31/2^8=2^19,BITS=19</span>
<span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap2</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">// Put 32 entries in the root and (2^BITS)/32 entries in each leaf.</span>
	<span class="token comment">//第一层</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_BITS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//19位的前5个比特位</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ROOT_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> ROOT_BITS<span class="token punctuation">;</span><span class="token comment">//第一层数组指针大小 2^5=32</span>

	<span class="token comment">//第二层</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> ROOT_BITS<span class="token punctuation">;</span><span class="token comment">//19位剩下的14个比特位</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span><span class="token comment">//第二层数组指针大小 2^14=16384</span>

	<span class="token comment">// Leaf node</span>
	<span class="token keyword">struct</span> <span class="token class-name">Leaf</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	Leaf<span class="token operator">*</span> root_<span class="token punctuation">[</span>ROOT_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// Pointers to 32 child nodes</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Memory allocator</span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span>

	<span class="token comment">//explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {<!-- --></span>
	<span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//allocator_ = allocator;</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>root_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">ASSERT</span><span class="token punctuation">(</span>i1 <span class="token operator">&lt;</span> ROOT_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">;</span>

			<span class="token comment">// Check for overflow</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> ROOT_LENGTH<span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

			<span class="token comment">// Make 2nd level node if necessary</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//Leaf* leaf = reinterpret_cast&lt;Leaf*&gt;((*allocator_)(sizeof(Leaf)));</span>
				<span class="token comment">//if (leaf == NULL) return false;</span>
				<span class="token keyword">static</span> ObjectPool<span class="token operator">&lt;</span>Leaf<span class="token operator">&gt;</span>	leafPool<span class="token punctuation">;</span>
				Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> <span class="token punctuation">(</span>Leaf<span class="token operator">*</span><span class="token punctuation">)</span>leafPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				root_<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> leaf<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Advance key past whatever is covered by this leaf node</span>
			key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// Allocate enough to keep track of all possible pages</span>
		<span class="token function">Ensure</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Three-level radix tree,3层基数树</span>
<span class="token comment">// 适合64位</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> BITS<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">TCMalloc_PageMap3</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">// How many bits should we consume at each interior level</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_BITS <span class="token operator">=</span> <span class="token punctuation">(</span>BITS <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Round-up</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> INTERIOR_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INTERIOR_BITS<span class="token punctuation">;</span>

	<span class="token comment">// How many bits should we consume at leaf level</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_BITS <span class="token operator">=</span> BITS <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> INTERIOR_BITS<span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> LEAF_LENGTH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>

	<span class="token comment">// Interior node</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> ptrs<span class="token punctuation">[</span>INTERIOR_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// Leaf node</span>
	<span class="token keyword">struct</span> <span class="token class-name">Leaf</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> values<span class="token punctuation">[</span>LEAF_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	Node<span class="token operator">*</span> root_<span class="token punctuation">;</span>                          <span class="token comment">// Root of radix tree</span>
	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Memory allocator</span>

	Node<span class="token operator">*</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Node<span class="token operator">*</span> result <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">memset</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">typedef</span> uintptr_t Number<span class="token punctuation">;</span>

	<span class="token keyword">explicit</span> <span class="token function">TCMalloc_PageMap3</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>allocator<span class="token punctuation">)</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		allocator_ <span class="token operator">=</span> allocator<span class="token punctuation">;</span>
		root_ <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span>Number k<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span>
			root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Number k<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">ASSERT</span><span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> BITS <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> k <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">const</span> Number i3 <span class="token operator">=</span> k <span class="token operator">&amp;</span> <span class="token punctuation">(</span>LEAF_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>values<span class="token punctuation">[</span>i3<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">bool</span> <span class="token function">Ensure</span><span class="token punctuation">(</span>Number start<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Number key <span class="token operator">=</span> start<span class="token punctuation">;</span> key <span class="token operator">&lt;=</span> start <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">const</span> Number i1 <span class="token operator">=</span> key <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>LEAF_BITS <span class="token operator">+</span> INTERIOR_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">const</span> Number i2 <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INTERIOR_LENGTH <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Check for overflow</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&gt;=</span> INTERIOR_LENGTH <span class="token operator">||</span> i2 <span class="token operator">&gt;=</span> INTERIOR_LENGTH<span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

			<span class="token comment">// Make 2nd level node if necessary</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				Node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token function">NewNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Make leaf node if necessary</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				Leaf<span class="token operator">*</span> leaf <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Leaf<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>allocator_<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>leaf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>leaf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>leaf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				root_<span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token operator">-&gt;</span>ptrs<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>leaf<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Advance key past whatever is covered by this leaf node</span>
			key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">&gt;&gt;</span> LEAF_BITS<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> LEAF_BITS<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">PreallocateMoreMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     然后我们把使用unordered_map的地方换成基数树。
    </p>
    <pre><code class="prism language-cpp"><span class="token comment">//PageCache.h</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Common.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"ObjectPool.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"PageMap.h"</span></span>


<span class="token comment">//所有线程共享一个PageCache</span>
<span class="token keyword">class</span> <span class="token class-name">PageCache</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> PageCache<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_sInst<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//从PageCache第k号桶中获取一个span对象</span>
	Span<span class="token operator">*</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">// 获取从对象到span的映射</span>
	Span<span class="token operator">*</span> <span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 释放空闲span回到Pagecache，并合并相邻的span</span>
	<span class="token keyword">void</span> <span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">PageCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
	PageCache<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PageCache<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

	<span class="token keyword">static</span> PageCache _sInst<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	Spanlist _spanlists<span class="token punctuation">[</span>NPAGES<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;//记录页号和span一一对应关系</span>
	<span class="token comment">// </span>
	<span class="token comment">//性能优化,使用一层的基数树</span>
	TCMalloc_PageMap1<span class="token operator">&lt;</span><span class="token number">32</span> <span class="token operator">-</span> PAGE_SHIFT<span class="token operator">&gt;</span> _idSpanMap<span class="token punctuation">;</span>
	ObjectPool<span class="token operator">&lt;</span>Span<span class="token operator">&gt;</span> _spanPool<span class="token punctuation">;</span> <span class="token comment">//申请Span的地方都用定长内存池申请,不用new</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>mutex _pageMtx<span class="token punctuation">;</span> <span class="token comment">//整个锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <pre><code class="prism language-cpp"><span class="token comment">//PageCache.cpp</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"PageCache.h"</span></span>

PageCache PageCache<span class="token double-colon punctuation">::</span>_sInst<span class="token punctuation">;</span>


<span class="token comment">//从PageCache第k号桶中获取一个span对象</span>
Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">NewSpan</span><span class="token punctuation">(</span>size_t k<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//assert(k &gt; 0 &amp;&amp; k &lt; NPAGES);</span>

	<span class="token function">assert</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//大于 128page找堆要</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//申请一个span对象管理这块内存,释放内存的时候要对应的span</span>
		<span class="token comment">//Span* span = new Span;</span>
		Span<span class="token operator">*</span> span <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>
		<span class="token comment">//_idSpanMap[span-&gt;_pageid] = span;</span>
		_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> span<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//这里加锁递归会有死锁问题，除非用递归互斥锁，还有在外面调用这个函数之前加锁</span>

	<span class="token comment">// 先检查第k个桶里面有没有span</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_spanlists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Span<span class="token operator">*</span> Kspan <span class="token operator">=</span> _spanlists<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


		<span class="token comment">//将Kspan给CentralCache之前,先将页号和span对应关系记录</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Kspan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//_idSpanMap[Kspan-&gt;_pageid + i] = Kspan;</span>
			_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Kspan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> i<span class="token punctuation">,</span> Kspan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//将管理k页的span给Central Cache</span>
		<span class="token keyword">return</span> Kspan<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//走到这里第k个桶没有span，那就继续往下面的桶找</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPAGES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_spanlists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//将一个管理更多页的span，变成两个span，一个管理k页，一个管理i-k页</span>
			Span<span class="token operator">*</span> Ispan <span class="token operator">=</span> _spanlists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PopFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//Span* Kspan = new Span;</span>
			Span<span class="token operator">*</span> Kspan <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			Kspan<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> Ispan<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">;</span>
			Kspan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> k<span class="token punctuation">;</span>

			Ispan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+=</span> k<span class="token punctuation">;</span>
			Ispan<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> k<span class="token punctuation">;</span>

			<span class="token comment">//将Ispan挂在对应大小的桶</span>
			_spanlists<span class="token punctuation">[</span>Ispan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>Ispan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//记录挂在PageCache中还未被使用的Ispan的页号和span对应关系</span>
			<span class="token comment">//这里仅需记录这个span的首页和尾页与Ispan的对应关系即可,</span>
			<span class="token comment">//不像返回给CentralCache的Kspan的需要把这个Kspan管理的每一页都和Kspan建立映射关系</span>
			<span class="token comment">//因为合并仅需知道每个Ispan的首页和尾页就可以找到Ispan,而返回给CentralCache的Kspan,</span>
			<span class="token comment">//首先需要将Kspan切成一块块小内存才行才能再给ThreadCache用,</span>
			<span class="token comment">//当小内存回来/8kb可能是Kspan管理的其中某一页,才能知道该页对应span</span>
			<span class="token comment">//_idSpanMap[Ispan-&gt;_pageid] = Ispan;</span>
			<span class="token comment">//_idSpanMap[Ispan-&gt;_pageid + Ispan-&gt;_n - 1] = Ispan;</span>
			_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Ispan<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">,</span> Ispan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Ispan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> Ispan<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> Ispan<span class="token punctuation">)</span><span class="token punctuation">;</span>


			<span class="token comment">//将Kspan给CentralCache之前,先将页号和span对应关系记录</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Kspan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//_idSpanMap[Kspan-&gt;_pageid + i] = Kspan;</span>
				_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>Kspan<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> i<span class="token punctuation">,</span> Kspan<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">//将管理k页的span给Central Cache</span>
			<span class="token keyword">return</span> Kspan<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//走到这里说明，后面的位置都没有大页的span</span>
	<span class="token comment">//那就去找堆申请一个128page的span</span>
	<span class="token comment">//Span* bigSpan = new Span;</span>
	Span<span class="token operator">*</span> bigSpan <span class="token operator">=</span> _spanPool<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">SystemAlloc</span><span class="token punctuation">(</span>NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bigSpan<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> <span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>ptr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
	bigSpan<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">//span挂在对应桶下</span>
	_spanlists<span class="token punctuation">[</span>bigSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>bigSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//重复上述过程寻找k号桶的span，一定还回一个span</span>
	<span class="token keyword">return</span> <span class="token function">NewSpan</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 获取从对象到span的映射</span>
Span<span class="token operator">*</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">MapObjectToSpan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	PAGE_ID id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PAGE_ID<span class="token punctuation">)</span>obj <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//STL容器是线程不安全的,多个地方会访问unordered_map</span>
	<span class="token comment">//std::unique_lock&lt;std::mutex&gt; lock(_pageMtx);</span>
	<span class="token comment">//auto ret = _idSpanMap.find(id);</span>
	<span class="token comment">//if (ret != _idSpanMap.end())</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	return ret-&gt;second;</span>
	<span class="token comment">//}</span>
	<span class="token comment">//else</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	assert(false);</span>
	<span class="token comment">//	return nullptr;</span>
	<span class="token comment">//}</span>
	Span<span class="token operator">*</span> span <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> span<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 释放空闲span回到Pagecache，并合并相邻的span</span>
<span class="token keyword">void</span> <span class="token class-name">PageCache</span><span class="token double-colon punctuation">::</span><span class="token function">ReleaseSpanToPageCache</span><span class="token punctuation">(</span>Span<span class="token operator">*</span> span<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//大于 128page直接还给堆</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">SystemFree</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete span;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token comment">// 如何知道相邻的span是否能合并?</span>
	<span class="token comment">// 通过自己的页号找到相邻的span看是否能合并,如果该页的span在PageCache说明该span还没有被使用,可以合并</span>
	<span class="token comment">// 如果在CentralCache说明该span正在被使用,不能合并</span>

	<span class="token comment">// 如何知道一个span是否被使用? 是用span中的usecount是否等于0吗? 不能!!</span>
	<span class="token comment">// 这里有一个空档时间,当thread1线程通过TLS找到自己threadcache申请内存块,但是没有,</span>
	<span class="token comment">// 就去找CentralCache,但是CentralCache对应桶下也没有,那就只能去找PageCache了</span>
	<span class="token comment">// PageCache返回给CentralCache一个span,这个span的usecount初始可是0,</span>
	<span class="token comment">// CentralCache拿到后对span这一大块内存切成一块块小内存</span>
	<span class="token comment">// 在挂到对应桶下,但是这时候thread2,要合并这个span,那就有问题了,thread1正准备从这span拿一批量</span>
	<span class="token comment">// 但是还没有拿到,这个span的usecount可还是0,只有拿走了usecount才会++</span>
	<span class="token comment">// thread2把这个span和自己span合并了,那就造成线程安全的问题!!</span>

	<span class="token comment">// 因此需要给span对象加一个isuse成员记录这个span是否被使用</span>


	<span class="token comment">// 如何通过页号找到相邻的页? 还是得用unordered_map记录页号合span对应关系</span>
	<span class="token comment">// 但是目前的unordered_map只记录了给CentralCache已经被使用的span的页号和span对应关系</span>
	<span class="token comment">// 并没有记录在PageCache的span的页号和span对应关系</span>
	<span class="token comment">// 因此需要把在PageCache的span的页号和span对应关系也要记录在unordered_map中</span>


	<span class="token comment">//先走前面相邻的span是否能合并,能合并就一直合</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		PAGE_ID prevId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token comment">//auto ret = _idSpanMap.find(prevId);</span>
		<span class="token comment"> 前面的页号没有，不合并了(堆申请内存已经到了起始地址)</span>
		<span class="token comment">//if (ret == _idSpanMap.end())</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	break;</span>
		<span class="token comment">//}</span>

		<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prevId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//Span* prevSpan = ret-&gt;second;</span>
		
		Span<span class="token operator">*</span> prevSpan <span class="token operator">=</span> ret<span class="token punctuation">;</span>
		<span class="token comment">// 前面相邻页的span在使用，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_isuse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 合并出超过128页的span没办法挂在桶下，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>prevSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 用span合并prevSpan</span>
		span<span class="token operator">-&gt;</span>_pageid <span class="token operator">=</span> prevSpan<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">;</span>
		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>

		<span class="token comment">// 将pevSpan从对应的桶中删除</span>
		_spanlists<span class="token punctuation">[</span>prevSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete prevSpan;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>prevSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 这里可能有疑问,那遗留unordered_map中被合并的对应页和prevSpan之间一对一的关系难道不删除吗?</span>
		<span class="token comment">// 因为prevSpan已经被删除了,在去通过已有页去找span那就是野指针了! 但其实并不用删除.</span>
		<span class="token comment">// 首先被合并的页已经被span管理起来了,合并结束之后会被挂在对应桶下,并且记录该span首页和尾页与span的对应关系.</span>
		<span class="token comment">// 当CentralCache要的时候,在把span切分成两个span,返回给CentralCache的Kspan每页都和Kspan重新进行映射</span>
		<span class="token comment">// 留在PageCache的Ispan的首页和尾页也会和Ispan重新映射</span>
		<span class="token comment">// 这样的话,以前被合并,遗留下来的页又和新得span建立了映射关系,就不会有通过页找span会有野指针的问题</span>

	<span class="token punctuation">}</span>

	<span class="token comment">//找后面相邻的span合并</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		PAGE_ID nextId <span class="token operator">=</span> span<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>
		<span class="token comment">//auto ret = _idSpanMap.find(nextId);</span>
		<span class="token comment"> 后面的页号没有，不合并了(堆申请内存已经到了结尾地址)</span>
		<span class="token comment">//if (ret == _idSpanMap.end())</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	break;</span>
		<span class="token comment">//}</span>

		<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>Span<span class="token operator">*</span><span class="token punctuation">)</span>_idSpanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nextId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//Span* nextSpan = ret-&gt;second;</span>
		Span<span class="token operator">*</span> nextSpan <span class="token operator">=</span> ret<span class="token punctuation">;</span>
		<span class="token comment">// 后面相邻页的span在使用，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_isuse <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 合并出超过128页的span没办法挂在桶下，不合并了</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nextSpan<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">&gt;</span> NPAGES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		span<span class="token operator">-&gt;</span>_n <span class="token operator">+=</span> nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span>

		_spanlists<span class="token punctuation">[</span>nextSpan<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Erase</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delete nextSpan;</span>
		_spanPool<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>nextSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//合并好的span挂在对应桶下</span>
	_spanlists<span class="token punctuation">[</span>span<span class="token operator">-&gt;</span>_n<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	span<span class="token operator">-&gt;</span>_isuse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token comment">//重新映射在PageCace的Span的首页和尾页与Span映射关系</span>
	<span class="token comment">/*_idSpanMap[span-&gt;_pageid] = span;
	_idSpanMap[span-&gt;_pageid + span-&gt;_n - 1] = span;*/</span>
	_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid<span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
	_idSpanMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>span<span class="token operator">-&gt;</span>_pageid <span class="token operator">+</span> span<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> span<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     至此关于高并发内存池所有东西都结束了。细节很多需要好好琢磨，这个项目知识把tcmalloc核心的东西拿出来了，还有很多没有实现，我们主要就是学习它的核心。对这个项目更多知识感兴趣的可以去读
     <a href="https://gitee.com/mirrors/tcmalloc" rel="nofollow">
      tcmalloc源码
     </a>
    </p>
    <h2>
     <a id="4__1349">
     </a>
     4. 扩展学习及当前项目实现的不足
    </h2>
    <p>
     实际中我们测试了，当前实现的并发内存池比malloc/free是更加⾼效的，那么我们能否替换到系统调用malloc呢？实际上是可以的。
    </p>
    <ul>
     <li>
      不同平台替换方式不同。 基于unix的系统上的glibc，使用了weak alias的方式替换。具体来说是因为这些入口函数都被定义成了weak symbols，再加上gcc支持 alias attribute，所以替换就变成了这种通用形式：
     </li>
    </ul>
    <p>
     void* malloc(size_t size) THROW attribute__ ((alias (tc_malloc)))
     <br/>
     因此所有malloc的调用都跳转到了tc_malloc的实现
    </p>
    <p>
     具体参考这里：
     <a href="https://blog.csdn.net/BingoAmI/article/details/78683906">
      GCC attribute 之weak,alias属性
     </a>
    </p>
    <p>
     有些平台不支持这样的东西，需要使⽤hook的钩子技术来做。
     <br/>
     关于hook请看这里：
     <a href="https://www.cnblogs.com/feng9exe/p/6015910.html" rel="nofollow">
      hook
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f66696768745f702f:61727469636c652f64657461696c732f313435393334383039" class_="artid" style="display:none">
 </p>
</div>


