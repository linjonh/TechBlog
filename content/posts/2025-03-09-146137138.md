---
layout: post
title: "Android-Retrofit-RxJava-OkHttp-网络请求高效封装方案"
date: 2025-03-09 19:43:31 +0800
description: "Retrofit + RxJava + OkHttp 是 Android 开发中常用的网络请求库组合。Retrofit 是一个类型安全的 HTTP 客户端，RxJava 是一个响应式编程库，OkHttp 是一个高效的 HTTP 客户端。允许在运行时动态修改 Retrofit 和 OkHttp 的配置，例如 Base URL、超时时间、拦截器等。将网络请求与 Activity/Fragment 的生命周期绑定，避免内存泄漏。通过 OkHttp 的缓存拦截器实现本地缓存，减少网络请求。Token 自动管理。"
keywords: "Android Retrofit + RxJava + OkHttp 网络请求高效封装方案"
categories: ['未分类']
tags: ['Rxjava', 'Retrofit', 'Okhttp']
artid: "146137138"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146137138
    alt: "Android-Retrofit-RxJava-OkHttp-网络请求高效封装方案"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146137138
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146137138
cover: https://bing.ee123.net/img/rand?artid=146137138
image: https://bing.ee123.net/img/rand?artid=146137138
img: https://bing.ee123.net/img/rand?artid=146137138
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android Retrofit + RxJava + OkHttp 网络请求高效封装方案
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     Retrofit + RxJava + OkHttp 是 Android 开发中常用的网络请求库组合。Retrofit 是一个类型安全的 HTTP 客户端，RxJava 是一个响应式编程库，OkHttp 是一个高效的 HTTP 客户端。
    </p>
    <p>
     Retrofit + RxJava + OkHttp 的组合可以提供以下功能：
     <br/>
     职责清晰
    </p>
    <p>
     <strong>
      RetrofitClient 负责 Retrofit 和 OkHttp 的初始化。
      <br/>
      ApiServiceHelper 负责动态创建 API 服务实例。
      <br/>
      NetworkHelper 负责发起网络请求和处理结果
     </strong>
     。
     <br/>
     1. 动态配置 Retrofit 和 OkHttp
     <br/>
     允许在运行时动态修改 Retrofit 和 OkHttp 的配置，例如 Base URL、超时时间、拦截器等。
    </p>
    <ol start="2">
     <li>
      <p>
       统一错误处理
       <br/>
       增强错误处理的灵活性，支持自定义错误处理器。
      </p>
     </li>
     <li>
      <p>
       支持多环境切换
       <br/>
       通过配置文件或 Build Variants 动态切换测试环境和生产环境。
      </p>
     </li>
     <li>
      <p>
       添加缓存机制
       <br/>
       通过 OkHttp 的缓存拦截器实现本地缓存，减少网络请求。
      </p>
     </li>
     <li>
      <p>
       Token 自动管理
       <br/>
       通过拦截器自动添加 Token 并处理 Token 过期。
      </p>
     </li>
     <li>
      <p>
       支持文件上传/下载
       <br/>
       扩展 API 服务接口，支持文件操作。
      </p>
     </li>
     <li>
      <p>
       日志优化
       <br/>
       根据不同的 Build 类型（Debug/Release）动态调整日志级别。
      </p>
     </li>
     <li>
      <p>
       生命周期绑定
       <br/>
       将网络请求与 Activity/Fragment 的生命周期绑定，避免内存泄漏。
      </p>
     </li>
    </ol>
    <p>
     代码如下：
     <br/>
     <strong>
      RetrofitClient
     </strong>
     ：支持动态配置
    </p>
    <pre><code>import okhttp3.Cache;
import okhttp3.OkHttpClient;
import okhttp3.logging.HttpLoggingInterceptor;
import retrofit2.Retrofit;
import retrofit2.adapter.rxjava3.RxJava3CallAdapterFactory;
import retrofit2.converter.gson.GsonConverterFactory;
import java.io.File;
import java.util.concurrent.TimeUnit;

public class RetrofitClient {
    private static Retrofit retrofit;
    private static OkHttpClient okHttpClient;

    private RetrofitClient() {
        // 私有构造函数，防止外部实例化
    }

    public static Retrofit getRetrofit() {
        if (retrofit == null) {
            synchronized (RetrofitClient.class) {
                if (retrofit == null) {
                    retrofit = new Retrofit.Builder()
                            .baseUrl("https://api.example.com/") // 默认 Base URL
                            .client(getOkHttpClient())
                            .addConverterFactory(GsonConverterFactory.create())
                            .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
                            .build();
                }
            }
        }
        return retrofit;
    }

    public static OkHttpClient getOkHttpClient() {
        if (okHttpClient == null) {
            synchronized (RetrofitClient.class) {
                if (okHttpClient == null) {
                    OkHttpClient.Builder builder = new OkHttpClient.Builder()
                            .connectTimeout(10, TimeUnit.SECONDS)
                            .readTimeout(10, TimeUnit.SECONDS)
                            .writeTimeout(10, TimeUnit.SECONDS);

                    // 添加缓存（10MB）
                    File cacheDir = new File(System.getProperty("java.io.tmpdir"), "http-cache");
                    builder.cache(new Cache(cacheDir, 10 * 1024 * 1024));

                    // 添加日志拦截器（仅在 Debug 模式下启用）
                    if (BuildConfig.DEBUG) {
                        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
                        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
                        builder.addInterceptor(logging);
                    }

                    okHttpClient = builder.build();
                }
            }
        }
        return okHttpClient;
    }

    /**
     * 动态修改 Base URL
     */
    public static void setBaseUrl(String baseUrl) {
        retrofit = new Retrofit.Builder()
                .baseUrl(baseUrl)
                .client(getOkHttpClient())
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
                .build();
    }

    /**
     * 动态修改 OkHttp 配置
     */
    public static void setOkHttpClient(OkHttpClient client) {
        okHttpClient = client;
        retrofit = new Retrofit.Builder()
                .baseUrl(retrofit.baseUrl().toString())
                .client(okHttpClient)
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
                .build();
    }
}
</code></pre>
    <p>
     <strong>
      NetworkHelper：支持自定义错误处理器
     </strong>
    </p>
    <pre><code>import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.schedulers.Schedulers;
import io.reactivex.rxjava3.disposables.Disposable;

public class NetworkHelper {
    /**
     * 发起网络请求
     *
     * @param single         RxJava 的 Single 对象
     * @param successHandler 成功回调
     * @param errorHandler   失败回调
     * @return Disposable 对象，用于取消订阅
     */
    public static &lt;T&gt; Disposable request(Single&lt;T&gt; single, OnSuccess&lt;T&gt; successHandler, OnError errorHandler) {
        return single.subscribeOn(Schedulers.io()) // 在 IO 线程执行网络请求
                .observeOn(AndroidSchedulers.mainThread()) // 在主线程处理结果
                .subscribe(
                        successHandler::onSuccess, // 成功回调
                        throwable -&gt; errorHandler.onError(handleError(throwable)) // 失败回调
                );
    }

    /**
     * 统一处理错误
     */
    private static String handleError(Throwable throwable) {
        if (throwable instanceof IOException) {
            return "网络连接失败，请检查网络设置";
        } else if (throwable instanceof HttpException) {
            return "服务器错误，请稍后重试";
        } else {
            return "未知错误：" + throwable.getMessage();
        }
    }

    // 成功回调接口
    public interface OnSuccess&lt;T&gt; {
        void onSuccess(T result);
    }

    // 失败回调接口
    public interface OnError {
        void onError(String errorMessage);
    }
}
</code></pre>
    <p>
     <strong>
      ApiServiceHelper
     </strong>
     ：
    </p>
    <pre><code>import java.lang.reflect.Proxy;

public class ApiServiceHelper {
    /**
     * 创建 API 服务实例
     *
     * @param serviceClass API 服务接口类
     * @return API 服务实例
     */
    public static &lt;T&gt; T createService(Class&lt;T&gt; serviceClass) {
        return (T) Proxy.newProxyInstance(
                serviceClass.getClassLoader(),
                new Class&lt;?&gt;[]{serviceClass},
                (proxy, method, args) -&gt; {
                    // 通过 Retrofit 创建真正的 API 服务实例
                    T service = RetrofitClient.getRetrofit().create(serviceClass);
                    // 调用方法并返回结果
                    return method.invoke(service, args);
                });
    }
}
</code></pre>
    <p>
     <strong>
      ApiResponse:统一封装响应基类
     </strong>
    </p>
    <pre><code>public class ApiResponse&lt;T&gt; {
    private int code; // 状态码
    private String message; // 消息
    private T data; // 数据

    // 无参构造函数
    public ApiResponse() {}

    // 全参构造函数
    public ApiResponse(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }

    // Getter 和 Setter 方法
    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    // toString 方法
    @Override
    public String toString() {
        return "ApiResponse{" +
                "code=" + code +
                ", message='" + message + '\'' +
                ", data=" + data +
                '}';
    }
}
</code></pre>
    <p>
     <strong>
      User.java类
     </strong>
    </p>
    <pre><code>public class User {
    private int id;
    private String name;
    private String email;

    // 无参构造函数
    public User() {}

    // 全参构造函数
    public User(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    // Getter 和 Setter 方法
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    // toString 方法
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
</code></pre>
    <p>
     <strong>
      ApiService服务类
     </strong>
    </p>
    <pre><code>import io.reactivex.rxjava3.core.Single;
import okhttp3.MultipartBody;
import okhttp3.ResponseBody;
import retrofit2.http.*;

public interface ApiService {
    // 获取用户信息
    @GET("users/{username}")
    Single&lt;User&gt; getUser(@Path("username") String username);

    // 搜索用户
    @GET("users/search")
    Single&lt;List&lt;User&gt;&gt; searchUsers(@Query("query") String query);

    // 创建用户
    @POST("users")
    Single&lt;User&gt; createUser(@Body User user);

    // 文件上传
    @Multipart
    @POST("upload")
    Single&lt;ApiResponse&lt;String&gt;&gt; uploadFile(@Part MultipartBody.Part file);

    // 文件下载
    @Streaming
    @GET("files/{filename}")
    Single&lt;ResponseBody&gt; downloadFile(@Path("filename") String filename);
}
</code></pre>
    <p>
     <strong>
      在业务层调用
     </strong>
    </p>
    <pre><code>public class MainActivity extends AppCompatActivity {
    private Disposable disposable; // 用于保存 Disposable 对象

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 创建 API 服务实例
        ApiService apiService = ApiServiceHelper.createService(ApiService.class);

        // 发起网络请求
        disposable = NetworkHelper.request(
                apiService.getUser("john_doe"),
                user -&gt; {
                    // 处理成功结果
                    Log.d("User", user.toString());
                },
                errorMessage -&gt; {
                    // 处理错误
                    Log.e("Error", errorMessage);
                }
        );
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 取消网络请求，避免内存泄漏
        if (disposable != null &amp;&amp; !disposable.isDisposed()) {
            disposable.dispose();
        }
    }
}
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f74616e6777656967756f30333035313938372f:61727469636c652f64657461696c732f313436313337313338" class_="artid" style="display:none">
 </p>
</div>


