---
layout: post
title: "C特殊类设计"
date: 2025-03-10 14:32:48 +0800
description: "使用C++语言设计一些特殊的类"
keywords: "C++特殊类设计"
categories: ['未分类']
tags: ['C']
artid: "146153649"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146153649
    alt: "C特殊类设计"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146153649
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146153649
cover: https://bing.ee123.net/img/rand?artid=146153649
image: https://bing.ee123.net/img/rand?artid=146153649
img: https://bing.ee123.net/img/rand?artid=146153649
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++特殊类设计
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <blockquote>
     <hr id="hr-toc" name="tableOfContents"/>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h2 id="%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB" name="%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB">
     <a id="_7">
     </a>
     一、设计一个
     <span style="color:#fe2c24">
      <strong>
       不能被拷贝
      </strong>
     </span>
     的类
    </h2>
    <blockquote>
     <p>
      拷贝只会放生在两个场景中：拷贝构造函数以及赋值运算符重载，因此想要让一个类禁止拷贝，只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。
      <br/>
      C++98 将拷贝构造函数与赋值运算符重载只声明不定义，并且将其访问权限设置为私有即可
     </p>
     <pre><code class="language-cpp">class CopyBan
{
	// ...
private:
	CopyBan(const CopyBan&amp;);
	CopyBan&amp; operator=(const CopyBan&amp;);
	//...
};</code></pre>
     <ul>
      <li>
       设置成私有：如果只声明没有设置成private，用户自己如果在类外定义了，就可以不能禁止拷贝了
      </li>
      <li>
       只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不写反而还简单，而且如果定义了就不会防止成员函数内部拷贝了
      </li>
     </ul>
     <p>
      C++11 扩展delete的用法，delete除了释放new申请的资源外，如果在默认成员函数后跟上=delete，表示让编译器删除掉该默认成员函数
     </p>
     <pre><code class="language-cpp">//class CopyBan
//{
//	// ...
//	CopyBan(const CopyBan&amp;) = delete;
//	CopyBan&amp; operator=(const CopyBan&amp;) = delete;
//	//...
//};

class CopyBan
{
private:
    int* data;  // 假设我们有一个指向动态分配内存的指针

public:
    CopyBan(int value) : data(new int(value)) {}  // 构造函数
    ~CopyBan() { delete data; }  // 析构函数，释放内存

    CopyBan(const CopyBan&amp;) = delete;  // 禁止拷贝构造函数
    CopyBan&amp; operator=(const CopyBan&amp;) = delete;  // 禁止拷贝赋值

    // 提供移动构造函数和移动赋值运算符
    CopyBan(CopyBan&amp;&amp; other) noexcept : data(other.data) {
        other.data = nullptr;  // 释放原对象的资源
    }

    CopyBan&amp; operator=(CopyBan&amp;&amp; other) noexcept {
        if (this != &amp;other) {
            delete data;  // 释放当前对象的资源
            data = other.data;
            other.data = nullptr;  // 清空原对象的指针
        }
        return *this;
    }

    void printData() const { std::cout &lt;&lt; *data &lt;&lt; std::endl; }
};

int main() {
    CopyBan obj1(10);
    // CopyBan obj2 = obj1;  // 错误：拷贝构造函数被删除
    CopyBan obj3(20);
    // obj3 = obj1;  // 错误：拷贝赋值运算符被删除

    CopyBan obj4 = std::move(obj1);  // 移动构造，合法
    obj3 = std::move(obj4);  // 移动赋值，合法

    obj3.printData();  // 输出 10

    return 0;
}
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h2 id="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" name="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB">
     二、设计一个
     <span style="color:#fe2c24">
      只能在堆上创建对象
     </span>
     的类
    </h2>
    <blockquote>
     <p>
      <strong>
       实现方式：
      </strong>
     </p>
     <ol>
      <li>
       <p>
        <strong>
         私有构造函数
        </strong>
        ：
       </p>
       <ul>
        <li>
         <code>
          HeapOnly()
         </code>
         是私有的，意味着外部代码无法直接通过
         <code>
          HeapOnly obj;
         </code>
         创建对象。这样做的目的是防止类的对象在栈上被创建，从而只能通过
         <code>
          CreateObject()
         </code>
         方法在堆上动态分配内存。
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         禁止拷贝构造
        </strong>
        ：
       </p>
       <ul>
        <li>
         在 C++98 中，你可以通过声明拷贝构造函数但不实现它来禁止拷贝构造。这样，编译器将无法生成该类的拷贝构造函数，也就无法拷贝对象。
        </li>
        <li>
         在 C++11 中，可以通过
         <code>
          HeapOnly(const HeapOnly&amp;) = delete;
         </code>
         来显式删除拷贝构造函数。这样编译器会拒绝任何拷贝构造的尝试。
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         静态工厂方法
        </strong>
        ：
       </p>
       <ul>
        <li>
         <code>
          CreateObject()
         </code>
         是一个静态成员函数，用于在堆上动态创建
         <code>
          HeapOnly
         </code>
         对象。它返回指向新分配内存的指针，这保证了对象只能通过该方法创建，而不能直接通过构造函数创建。
        </li>
       </ul>
      </li>
     </ol>
     <pre><code class="language-cpp">#include &lt;iostream&gt;

class HeapOnly
{
public:
    static HeapOnly* CreateObject()
    {
        return new HeapOnly;
    }

private:
    HeapOnly() {}

    // 禁止拷贝构造函数
    HeapOnly(const HeapOnly&amp;) = delete;
};

int main()
{
    // 只能通过 CreateObject 来创建对象
    HeapOnly* obj = HeapOnly::CreateObject();

    // 不能通过拷贝构造来创建对象，会编译错误
    // HeapOnly obj2 = *obj;  // 编译错误：拷贝构造函数被删除

    delete obj;  // 手动释放堆上分配的内存
    return 0;
}
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h2 id="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB" name="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB">
     三、设计一个
     <span style="color:#fe2c24">
      只能在栈上创建对象
     </span>
     的类
    </h2>
    <blockquote>
     <p>
      同上将构造函数私有化，然后设计静态方法创建对象返回即可
     </p>
     <ol>
      <li>
       <p>
        <strong>
         静态工厂方法
         <code>
          CreateObj
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <code>
          CreateObj()
         </code>
         方法是静态的，它创建并返回一个
         <code>
          StackOnly
         </code>
         类型的对象。通过返回一个栈对象，它保证了对象只能在栈上创建。注意，这种方式仅适用于栈对象的创建。
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         禁用
         <code>
          operator new
         </code>
         和
         <code>
          operator delete
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         <code>
          void* operator new(size_t size) = delete;
         </code>
         禁用
         <code>
          new
         </code>
         操作符。这意味着无法使用
         <code>
          new
         </code>
         在堆上创建
         <code>
          StackOnly
         </code>
         对象。任何尝试
         <code>
          new StackOnly()
         </code>
         的代码都会导致编译错误。
        </li>
        <li>
         <code>
          void operator delete(void* p) = delete;
         </code>
         禁用
         <code>
          delete
         </code>
         操作符，进一步确保无法删除通过
         <code>
          new
         </code>
         创建的
         <code>
          StackOnly
         </code>
         对象，因为
         <code>
          delete
         </code>
         操作符被禁用。
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         私有化构造函数
        </strong>
        ：
       </p>
       <ul>
        <li>
         构造函数
         <code>
          StackOnly()
         </code>
         是私有的，因此外部无法直接创建
         <code>
          StackOnly
         </code>
         对象。它只能通过静态方法
         <code>
          CreateObj()
         </code>
         来创建，保证了对象的创建逻辑。
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         私有成员
         <code>
          _a
         </code>
        </strong>
        ：
       </p>
       <ul>
        <li>
         这是一个简单的私有成员变量
         <code>
          _a
         </code>
         ，用于演示该类的内部状态，实际上并不会影响禁用堆分配的行为。
        </li>
       </ul>
      </li>
     </ol>
     <pre><code class="language-cpp">class StackOnly
{
public:
    // 静态工厂方法，返回栈上的对象
    static StackOnly CreateObj()
    {
        return StackOnly();
    }

    // 禁用 operator new 和 operator delete，防止堆分配
    void* operator new(size_t size) = delete;
    void operator delete(void* p) = delete;

private:
    // 私有构造函数，防止外部直接创建对象
    StackOnly() : _a(0) {}

private:
    int _a; // 内部状态
};
</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h2 id="%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB" name="%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB">
     四、设计一个
     <span style="color:#fe2c24">
      不能被继承
     </span>
     的类
    </h2>
    <blockquote>
     <p>
      C++98方式
     </p>
     <pre><code class="language-cpp">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承
class NonInherit
{
public:
	static NonInherit GetInstance()
	{
		return NonInherit();
	}
private:
	NonInherit()
	{}
};</code></pre>
     <p>
      C++11方法
      <br/>
      final关键字，final修饰类，表示该类不能被继承。
     </p>
     <pre><code class="language-cpp">class A final
{
    // ....
};</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h2 id="%E4%BA%94%E3%80%81%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)" name="%E4%BA%94%E3%80%81%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1(%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)">
     五、请设计一个类，
     <span style="color:#fe2c24">
      只能创建一个对象(单例模式)
     </span>
    </h2>
    <blockquote>
     <p>
      <strong>
       设计模式：
      </strong>
      <br/>
      <strong>
       设计模式（Design Pattern）
      </strong>
      是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的是为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。
      <br/>
      <strong>
       单例模式
      </strong>
      ：一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。
     </p>
     <p>
      单例模式有两种实现模式：
     </p>
     <h3 id="%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F" name="%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F">
      饿汉模式
     </h3>
     <p>
      程序启动时就创建一个唯一的实例对象，不管以后是否会使用
     </p>
     <pre><code class="language-cpp">// 饿汉模式
// 优点：简单
// 缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。
class Singleton
{
public:
	static Singleton* GetInstance()
	{
		return &amp;m_instance;
	}
private:
	// 构造函数私有
	Singleton() {};
	// C++98 防拷贝
	Singleton(Singleton const&amp;);
	Singleton&amp; operator=(Singleton const&amp;);
	// or
	// C++11
	Singleton(Singleton const&amp;) = delete;
	Singleton&amp; operator=(Singleton const&amp;) = delete;
	static Singleton m_instance;
};
Singleton Singleton::m_instance; // 在程序入口之前就完成单例对象的初始化</code></pre>
     <p>
      如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避免资源竞争，提高响应速度更好
     </p>
     <h3 id="%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F" name="%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F">
      懒汉模式
     </h3>
     <p>
      如果单例对象构造十分耗时或者占用很多资源，比如加载插件， 初始化网络连接，读取文件等等，如果该对象程序运行时不会用到，在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好
     </p>
     <pre><code class="language-cpp">// 懒汉
// 优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控
制。
// 缺点：复杂
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std;
class Singleton
{
public:
	static Singleton* GetInstance() {
		// 注意这里一定要使用Double-Check的方式加锁，才能保证效率和线程安全
		if (nullptr == m_pInstance) {
			m_mtx.lock();
			if (nullptr == m_pInstance) {
				m_pInstance = new Singleton();
			}
			m_mtx.unlock();
		}
		return m_pInstance;
	}
	// 实现一个内嵌垃圾回收类
	class CGarbo {
	public:
		~CGarbo() {
			if (Singleton::m_pInstance)
				delete Singleton::m_pInstance;
		}
	};
	// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象
	static CGarbo Garbo;
private:
	// 构造函数私有
	Singleton() {};
	// 防拷贝
	Singleton(Singleton const&amp;);
	Singleton&amp; operator=(Singleton const&amp;);
	static Singleton* m_pInstance; // 单例对象指针
	static mutex m_mtx; //互斥锁
};
Singleton* Singleton::m_pInstance = nullptr;
Singleton::CGarbo Garbo;
mutex Singleton::m_mtx;
int main()
{
	thread t1([] {cout &lt;&lt; &amp;Singleton::GetInstance() &lt;&lt; endl; });
	thread t2([] {cout &lt;&lt; &amp;Singleton::GetInstance() &lt;&lt; endl; });
	t1.join();
	t2.join();
	cout &lt;&lt; &amp;Singleton::GetInstance() &lt;&lt; endl;
	cout &lt;&lt; &amp;Singleton::GetInstance() &lt;&lt; endl;
	return 0;
}</code></pre>
     <p>
     </p>
    </blockquote>
    <hr/>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f37323530313630322f:61727469636c652f64657461696c732f313436313533363439" class_="artid" style="display:none">
 </p>
</div>


