---
layout: post
title: "AtCoder-Beginner-Contest-397ABCDE"
date: 2025-03-16 21:24:25 +0800
description: "前后缀分解，倒序遍历设立一个数组suffix，suffix[i]为[ i : n ]中A的不同整数数量。字符串 io 是没问题，无需改变的。那么删除这些没问题的后剩下都是要在前后插入的字符了，统计一下剩下字符串长度即可。且在d确定的情况下上式单调递增，可用二分判断在d确定下y是否存在。在此问题的约束条件下，可以证明通过插入适当数量的字符、 S 就能满足条件。当把 A 在一个位置分割成两个非空（连续）子数组时，求这两个子数组中不同整数的计数之和的最大值。如果这个整数对，输出这样一个整数对（x，y）。"
keywords: "AtCoder Beginner Contest 397（ABCDE）"
categories: ['Atcoder']
tags: ['算法', '数据结构', 'C']
artid: "146301051"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146301051
    alt: "AtCoder-Beginner-Contest-397ABCDE"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146301051
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146301051
cover: https://bing.ee123.net/img/rand?artid=146301051
image: https://bing.ee123.net/img/rand?artid=146301051
img: https://bing.ee123.net/img/rand?artid=146301051
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     AtCoder Beginner Contest 397（ABCDE）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="Problem%20-%20C%20-%20Codeforces%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B" name="Problem%20-%20C%20-%20Codeforces%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B">
     <a href="https://atcoder.jp/contests/abc397/tasks/abc397_a" rel="nofollow" title="A - Thermometer ">
      A - Thermometer
     </a>
    </h2>
    <h3 id="%E7%BF%BB%E8%AF%91%EF%BC%9A" name="%E7%BF%BB%E8%AF%91%EF%BC%9A">
     翻译：
    </h3>
    <blockquote>
     <p>
      高桥测量了自己的体温，发现它是
      <img alt="X^0C" class="mathcode" src="https://latex.csdn.net/eq?X%5E0C">
       。
      </img>
     </p>
     <p>
      体温分为以下几种：
     </p>
     <ul>
      <li>
       高于或等于
       <img alt="38.0^0C" class="mathcode" src="https://latex.csdn.net/eq?38.0%5E0C">
        ："高烧"
       </img>
      </li>
      <li>
       高于或等于
       <img alt="37.5^0C" class="mathcode" src="https://latex.csdn.net/eq?37.5%5E0C">
        和低于
        <img alt="38.0^0C" class="mathcode" src="https://latex.csdn.net/eq?38.0%5E0C">
         ："发烧"
        </img>
       </img>
      </li>
      <li>
       低于
       <img alt="37.5^0C" class="mathcode" src="https://latex.csdn.net/eq?37.5%5E0C">
        ："正常"
       </img>
      </li>
     </ul>
     <p>
      高桥的体温属于哪种分类？请根据输出部分以整数形式给出答案。
     </p>
    </blockquote>
    <h3 id="%E6%80%9D%E8%B7%AF%EF%BC%9A" name="%E6%80%9D%E8%B7%AF%EF%BC%9A">
     思路：
    </h3>
    <blockquote>
     <p>
      先判断&gt;=38.0再判断&lt;37.5,都不对输出发烧。可以写快点。
     </p>
    </blockquote>
    <h3 id="%E5%AE%9E%E7%8E%B0%EF%BC%9A" name="%E5%AE%9E%E7%8E%B0%EF%BC%9A">
     实现：
    </h3>
    <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
const int MX = 1e5+10;

void solve(){
    double n;cin&gt;&gt;n;
    if (n&gt;=38){
        cout&lt;&lt;"1\n";
    }else if (n&lt;37.5){
        cout&lt;&lt;"3\n";
    }else{
        cout&lt;&lt;"2\n";
    }
}

int main(){
    // 关闭输入输出流同步
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    // 不使用科学计数法
    // cout&lt;&lt;fixed;
    // 中间填保留几位小数，不填默认
    // cout.precision();
    solve();
    return 0;
}</code></pre>
    <h2 id="" name="">
     <br/>
     <br/>
     <a href="https://atcoder.jp/contests/abc397/tasks/abc397_b" rel="nofollow" title="B - Ticket Gate Log">
      B - Ticket Gate Log
     </a>
    </h2>
    <h3 id="%C2%A0%E7%BF%BB%E8%AF%91%EF%BC%9A" name="%C2%A0%E7%BF%BB%E8%AF%91%EF%BC%9A">
     翻译：
    </h3>
    <blockquote>
     <p>
      高桥汇总了检票口的使用记录。但是，他不小心删除了一些进出站记录。他正试图恢复被删除的记录。
     </p>
     <p>
      给你一个由 i 和 o 组成的字符串 S。我们想在 S 的任意位置插入 0 个或多个字符，这样得到的字符串就能满足以下条件：
     </p>
     <ul>
      <li>
       它的长度是偶数，每个奇数（第 1、第 3......个）字符都是 i，而每个偶数（第 2、第 4......个）字符都是 o。
      </li>
     </ul>
     <p>
      求需要插入的最少字符数。在此问题的约束条件下，可以证明通过插入适当数量的字符、 S 就能满足条件。
     </p>
    </blockquote>
    <h3 id="%E6%80%9D%E8%B7%AF%EF%BC%9A" name="%E6%80%9D%E8%B7%AF%EF%BC%9A">
     思路：
    </h3>
    <blockquote>
     <p>
      字符串 io 是没问题，无需改变的。那么删除这些没问题的后剩下都是要在前后插入的字符了，统计一下剩下字符串长度即可。
     </p>
    </blockquote>
    <h3 id="%E5%AE%9E%E7%8E%B0%EF%BC%9A" name="%E5%AE%9E%E7%8E%B0%EF%BC%9A">
     实现：
    </h3>
    <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
const int MX = 1e5+10;

void solve(){
    string s;cin&gt;&gt;s;
    int cnt = 0;
    for (int i=1;i&lt;s.size();i++){
        if (s[i]=='o' &amp;&amp; s[i-1]=='i') cnt++;
    }
    int n = s.size();
    cout&lt;&lt;n-2*cnt&lt;&lt;"\n";
}

int main(){
    // 关闭输入输出流同步
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    // 不使用科学计数法
    // cout&lt;&lt;fixed;
    // 中间填保留几位小数，不填默认
    // cout.precision();
    solve();
    return 0;
}</code></pre>
    <h2 id="" name="">
     <br/>
     <br/>
     <a href="https://atcoder.jp/contests/abc397/tasks/abc397_c" rel="nofollow" title="C - Variety Split Easy ">
      C - Variety Split Easy
     </a>
    </h2>
    <h3 id="%C2%A0%E7%BF%BB%E8%AF%91%EF%BC%9A" name="%C2%A0%E7%BF%BB%E8%AF%91%EF%BC%9A">
     翻译：
    </h3>
    <blockquote>
     <p>
      给你一个长度为 N 的整数序列：
      <img alt="A=(A_1,A_2,...,A_N)" class="mathcode" src="https://latex.csdn.net/eq?A%3D%28A_1%2CA_2%2C...%2CA_N%29">
       。
      </img>
     </p>
     <p>
      当把 A 在一个位置分割成两个非空（连续）子数组时，求这两个子数组中不同整数的计数之和的最大值。
     </p>
     <p>
      更具体地说，对于整数 i，求以下两个值的最大和，使得 1≤i≤N-1：
      <img alt="(A_1,A_2,...,A_i)" class="mathcode" src="https://latex.csdn.net/eq?%28A_1%2CA_2%2C...%2CA_i%29">
       中不同整数的数量，和
       <img alt="(A_{i+1},A_{i+2},...,A_N)" class="mathcode" src="https://latex.csdn.net/eq?%28A_%7Bi&amp;plus;1%7D%2CA_%7Bi&amp;plus;2%7D%2C...%2CA_N%29">
        中不同整数的数量。
       </img>
      </img>
     </p>
    </blockquote>
    <h3 id="%E6%80%9D%E8%B7%AF%EF%BC%9A" name="%E6%80%9D%E8%B7%AF%EF%BC%9A">
     思路：
    </h3>
    <blockquote>
     <p>
      前后缀分解，倒序遍历设立一个数组suffix，suffix[i]为[ i : n ]中A的不同整数数量。之后正序遍历求出以每个为分割点得到的和，比较下。
     </p>
    </blockquote>
    <h3 id="%E5%AE%9E%E7%8E%B0%EF%BC%9A" name="%E5%AE%9E%E7%8E%B0%EF%BC%9A">
     实现：
    </h3>
    <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
const int MX = 3e5+10;
int vis[MX];
void solve(){
    int n;
    cin&gt;&gt;n;
    vector&lt;int&gt; a(n+1);
    for (int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];
    vector&lt;int&gt; suffix(n+1);
    memset(vis,0,sizeof(vis));
    for (int cnt=0,i=n;i&gt;=1;--i){
        vis[a[i]]++;
        if (vis[a[i]]==1) cnt++;
        suffix[i] = cnt;
    }
    int maxx = 0;
    memset(vis,0,sizeof(vis));
    for (int cnt=0,i=1;i&lt;n;i++){
        vis[a[i]]++;
        if (vis[a[i]]==1) cnt++;
        maxx = max(maxx,cnt+suffix[i+1]);
    }
    cout&lt;&lt;maxx&lt;&lt;"\n";
}

int main(){
    // 关闭输入输出流同步
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    // 不使用科学计数法
    // cout&lt;&lt;fixed;
    // 中间填保留几位小数，不填默认
    // cout.precision();
    solve();
    return 0;
}</code></pre>
    <p>
    </p>
    <h2 id="https%3A%2F%2Fcodeforces.com%2Fcontest%2F2063%2Fproblem%2FC" name="https%3A%2F%2Fcodeforces.com%2Fcontest%2F2063%2Fproblem%2FC" style="background-color:transparent">
     <a href="https://atcoder.jp/contests/abc397/tasks/abc397_d" rel="nofollow" title="D - Cubes">
      D - Cubes
     </a>
    </h2>
    <h3 id="%C2%A0%E7%BF%BB%E8%AF%91%EF%BC%9A" name="%C2%A0%E7%BF%BB%E8%AF%91%EF%BC%9A">
     翻译：
    </h3>
    <blockquote>
     <p>
      你被给予一个正整数N。决定是否存在一个正整数对（x，y）使得
      <img alt="X^3-y^3=N" class="mathcode" src="https://latex.csdn.net/eq?X%5E3-y%5E3%3DN"/>
      。如果这个整数对，输出这样一个整数对（x，y）。
     </p>
    </blockquote>
    <h3 id="%E6%80%9D%E8%B7%AF%EF%BC%9A" name="%E6%80%9D%E8%B7%AF%EF%BC%9A">
     思路：
    </h3>
    <blockquote>
     <p>
      <img alt="N=x^3-y^3 \leq (y+1)^3-y^3=3y^2+3y+1" class="mathcode" src="https://latex.csdn.net/eq?N%3Dx%5E3-y%5E3%20%5Cleq%20%28y&amp;plus;1%29%5E3-y%5E3%3D3y%5E2&amp;plus;3y&amp;plus;1"/>
      如果y存在,可得y至少都为
      <img alt="y&lt;\sqrt\frac{N}{3}" class="mathcode" src="https://latex.csdn.net/eq?y%3C%5Csqrt%5Cfrac%7BN%7D%7B3%7D"/>
      。而直接遍历明显不行。
     </p>
     <p>
      令d=x-y， 由
      <img alt="N=x^3-y^3=(x-y)(x^2+xy+y^2)\geq (x-y)(x-y)^2=d^3" class="mathcode" src="https://latex.csdn.net/eq?N%3Dx%5E3-y%5E3%3D%28x-y%29%28x%5E2&amp;plus;xy&amp;plus;y%5E2%29%5Cgeq%20%28x-y%29%28x-y%29%5E2%3Dd%5E3"/>
      可得
      <img alt="d\leq \sqrt[3]N" class="mathcode" src="https://latex.csdn.net/eq?d%5Cleq%20%5Csqrt%5B3%5DN"/>
      。那么如果(x,y)存在，则满足
      <img alt="(d+y)^3-y^3=N=&gt;d^3+3d^2y+3dy^2=N=&gt;d^2+3dy+3y^2=\frac{N}{d}" class="mathcode" src="https://latex.csdn.net/eq?%28d&amp;plus;y%29%5E3-y%5E3%3DN%3D%3Ed%5E3&amp;plus;3d%5E2y&amp;plus;3dy%5E2%3DN%3D%3Ed%5E2&amp;plus;3dy&amp;plus;3y%5E2%3D%5Cfrac%7BN%7D%7Bd%7D"/>
      。（注意求幂使用pow返回的是浮点型存在精度问题）。且在d确定的情况下上式单调递增，可用二分判断在d确定下y是否存在。
     </p>
     <p>
      结论：先遍历d区间
      <img alt="[1,\sqrt\frac{N}{3})" class="mathcode" src="https://latex.csdn.net/eq?%5B1%2C%5Csqrt%5Cfrac%7BN%7D%7B3%7D%29"/>
      ，在内部二分搜索y是否有y满足
      <img alt="d^2+3dy+3y^2=\frac{N}{d}" class="mathcode" src="https://latex.csdn.net/eq?d%5E2&amp;plus;3dy&amp;plus;3y%5E2%3D%5Cfrac%7BN%7D%7Bd%7D"/>
      。即可。时间复杂度为
      <img alt="O(\sqrt[3]NlogN)" class="mathcode" src="https://latex.csdn.net/eq?O%28%5Csqrt%5B3%5DNlogN%29"/>
      。注意在此题中要注意整型越界问题。（纯纯数学题）
     </p>
    </blockquote>
    <h3 id="%E5%AE%9E%E7%8E%B0%EF%BC%9A" name="%E5%AE%9E%E7%8E%B0%EF%BC%9A" style="background-color:transparent">
     实现：
    </h3>
    <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
void solve(){
    ll n;cin&gt;&gt;n;
    for (ll d=1;d*d*d&lt;=n;d++){
        if (n%d!=0) continue;
        ll l = 0,r = 900000010;
        while (l+1!=r){
            ll mid = (l+r)/2;
            if (d*d+3*d*mid+3*mid*mid&gt;=n/d){
                r = mid;
            }else{
                l = mid;
            }
        }
        if (d*d+3*d*r+3*r*r==n/d){
            cout&lt;&lt;r+d&lt;&lt;" "&lt;&lt;r&lt;&lt;"\n";
            return;
        }
    }
    cout&lt;&lt;-1&lt;&lt;"\n";
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    solve();
}</code></pre>
    <p>
    </p>
    <h2>
     <a href="https://atcoder.jp/contests/abc397/tasks/abc397_e" rel="nofollow" title="E - Path Decomposition of a Tree">
      E - Path Decomposition of a Tree
     </a>
    </h2>
    <h3>
     翻译：
    </h3>
    <blockquote>
     <p>
      给你一颗有NK个点的树。点的编号为
      <img alt="1,2,...,NK" class="mathcode" src="https://latex.csdn.net/eq?1%2C2%2C...%2CNK"/>
      ，并且第 i 条边
      <img alt="(i=1,2,...,NK-1)" class="mathcode" src="https://latex.csdn.net/eq?%28i%3D1%2C2%2C...%2CNK-1%29"/>
      连接点
      <img alt="u_i" class="mathcode" src="https://latex.csdn.net/eq?u_i"/>
      和
      <img alt="v_i" class="mathcode" src="https://latex.csdn.net/eq?v_i"/>
      。
     </p>
     <p>
      确定这棵树是否可以分解成 N 条路径，每条路径的长度为 K。更确切地说，确定是否存在满足以下条件的 N×K 矩阵 P：
     </p>
     <ul>
      <li>
       <img alt="P_{1,1},...,P_{1,K},P_{2,1},...,P_{N,K}" class="mathcode" src="https://latex.csdn.net/eq?P_%7B1%2C1%7D%2C...%2CP_%7B1%2CK%7D%2CP_%7B2%2C1%7D%2C...%2CP_%7BN%2CK%7D"/>
       是一个由
       <img alt="1,2,...,NK" class="mathcode" src="https://latex.csdn.net/eq?1%2C2%2C...%2CNK"/>
       组成的排列。
      </li>
      <li>
       对于每个i=1,2,...,N和j=1,2,...,K-1它们间有边连接着点
       <img alt="P_{i,j},P_{i,j+1}" class="mathcode" src="https://latex.csdn.net/eq?P_%7Bi%2Cj%7D%2CP_%7Bi%2Cj&amp;plus;1%7D"/>
       。
      </li>
     </ul>
    </blockquote>
    <h3>
     思路：
    </h3>
    <blockquote>
     <p>
      对于一个有NK个节点的树（以1为根节点），要求得到N个互不干扰大小为K的子树。
     </p>
     <p>
      如果一个子树的大小为k（当前树的根节点也算上）且子节点数量 &lt;= 2。那么这颗子树为可用路径，删除它。
     </p>
     <p>
      如果子树大小 &gt;k 或 子节点数量 &gt;=3 或 子树大小 &lt;k 且 子节点数量 &gt;=2。那么答案就只能为No。对于上面子树的情况可以画图辅助思考下。
     </p>
    </blockquote>
    <h3>
     实现：
    </h3>
    <pre><code class="hljs">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MX = 2e5+10;
int n,k;
vector&lt;vector&lt;int&gt;&gt; tree(MX);
int f = 1;
// 属于当前点的子树大小
int dfs(int now,int fa){
    int res = 1,cnt = 0;
    for (int&amp; i:tree[now]){
        if (i==fa) continue;
        int tree_size = dfs(i,now);
        res += tree_size;
        if (tree_size) cnt++;
    }
    if (res&gt;k || cnt&gt;=3 || res&lt;k &amp;&amp; cnt&gt;=2){
        f = 0;
    }
    if (res==k &amp;&amp; cnt&lt;=2){
        res = 0;
    }
    return res;
}
void solve(){
    cin&gt;&gt;n&gt;&gt;k;
    for (int x,y,i=1;i&lt;n*k;i++){
        cin&gt;&gt;x&gt;&gt;y;
        tree[x].push_back(y);
        tree[y].push_back(x);
    }
    dfs(1,1);
    if (f){
        cout&lt;&lt;"Yes\n";
    }else{
        cout&lt;&lt;"No\n";
    }
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    solve();
}</code></pre>
    <p>
    </p>
    <blockquote>
     <p>
      有建议可以评论，我会积极改进qwq。
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f36383238363138302f:61727469636c652f64657461696c732f313436333031303531" class_="artid" style="display:none">
 </p>
</div>


