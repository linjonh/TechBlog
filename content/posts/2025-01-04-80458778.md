---
layout: post
title: "北京理工大学Python语言程序设计____笔记整理"
date: 2025-01-04 18:55:55 +0800
description: "# 这门课程是我最强烈推荐的python入门课程之一。原因有三：其一，其更加关注编程的思想，极具有启"
keywords: "python语言程序设计"
categories: ['Python']
tags: ['无标签']
artid: "80458778"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=80458778
    alt: "北京理工大学Python语言程序设计____笔记整理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=80458778
featuredImagePreview: https://bing.ee123.net/img/rand?artid=80458778
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     北京理工大学：《Python语言程序设计》____笔记整理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <em>
      # 这门课程是我最强烈推荐的python入门课程之一。原因有三：其一，其更加关注编程的思想，极具有启发性；其二，”小“但系统，可扩展性强；其三，有配套线上练习和测试。
     </em>
    </p>
    <p>
     <em>
      # 本文将每次更新一个章节，直到课程结束。
     </em>
    </p>
    <p>
     <em>
      # 本文从5.28--6.7日，历时11天，基本更新完毕，后面还有两张不属于python基础，后续将以demo的方式进行详细讲解。
     </em>
    </p>
    <p>
    </p>
    <h3>
    </h3>
    <h2>
     第一章：程序设计基本方法
    </h2>
    <h3>
     计算机与程序设计
    </h3>
    <pre class="has"><code>计算机是根据指令操作数据的设备
计算机发展参照摩尔定律，表现为指数形式</code></pre>
    <h3>
     编译和解释
    </h3>
    <pre><code>计算机执行源程序两种方式：编译和解释
编译：将源代码一次性转换成目标代码的过程。执行编译过程的程序叫编译器<em>(compiler)</em>。
解释：将原代码逐条转换成目标代码同时逐条运行的过程。执行解释过程的程序叫解释器<em>(interpreter)</em>。
静态语言：使用编译执行的编程语言<em>(C/C++,java)</em>
脚本语言：使用解释执行的编程语言<em>(Python,JavaScript，PHP)</em></code></pre>
    <h3>
     程序的基本写法
    </h3>
    <pre><code>IPO：
<span style="color:#0086b3;">input</span>输入:文件输入、控制台输入、交互输入、内部参数输入等。
process处理(主要逻辑)：算法（灵魂）
<span style="color:#0086b3;">output</span>输出：控制台、文件、网络、操作系统内部变量等输出。</code></pre>
    <h3>
     计算机编程
    </h3>
    <p>
     能够训练思维：
    </p>
    <pre class="has"><code>编程体现一种抽象交互、自动化执行的思维方式
计算思维：区分逻辑思维和实证思维的第三种思维模式。</code></pre>
    <h3>
     计算机编程
    </h3>
    <p>
     python环境配置
    </p>
    <pre class="has"><code>略</code></pre>
    <h3>
     实例1 --温度转换
    </h3>
    <pre><code>题目本身简单，但学会这种思维，其他常见的<span style="color:#dd1144;">"转换"</span>问题解决方法同理。</code></pre>
    <h3>
     Python程序语法元素分析
    </h3>
    <p>
     程序的格式框架
    </p>
    <pre><code><strong>python</strong>中用<span style="color:#dd1144;">"缩进"</span>表达程序的语法框架，表达代码间包含关系的唯一手段
注释：用于提高代码可读性的辅助文字，不被执行。</code></pre>
    <p>
     命名与保留字
    </p>
    <pre><code>变量：用来保存和表示数据的占位符号，变量采用标识符（名字）来表示。
命名：数字字母下划线。
<span style="color:#dd1144;">"注意"</span>：大小写敏感，数字不能放开头，不与保留字同。
python中共有<span style="color:#008080;">33</span>个保留字，查询方法：
```
<strong>import</strong> keyword
print(keyword.kwlist)
```</code></pre>
    <p>
     数据类型
    </p>
    <pre><code>字符串：由<span style="color:#008080;">0</span>个或多个字符组成的<span style="color:#dd1144;">"有序"</span>字符序列。# 有序--&gt;可以索引、切片
整数：数学中的整数
浮点数：数学中的实数，带有小数点部分
列表：由<span style="color:#008080;">0</span>个或多个数据组成的<span style="color:#dd1144;">"有序"</span>序列</code></pre>
    <p>
     语句与函数
    </p>
    <pre class="has"><code>赋值语句
分支语句
函数</code></pre>
    <p>
     Python程序的输入输出
    </p>
    <pre><code><strong>input</strong>（）控制台输入
<strong>print</strong>（）控制台输出，格式化
注：这两兄弟，在控制台显示的时候，一个添加引号形成字符串，一个将字符串自动去掉引号。
补充：<span style="color:#dd1144;">"eval()"</span>去掉参数最外侧引号并执行余下语句的函数</code></pre>
    <p>
     温度转换代码分析
    </p>
    <pre class="has"><code>略</code></pre>
    <h2>
     第二章 Python基本图形绘制
    </h2>
    <h3>
     2.1 深入理解Python语言
    </h3>
    <h4>
     2.1.1计算机技术的演进
    </h4>
    <pre><code><span style="color:#008080;">1946</span><span style="color:#008080;">-1981</span>：计算机系统结构时代（<span style="color:#008080;">35</span>年）：
<span style="color:#008080;">1981</span><span style="color:#008080;">-2008</span>：网络和视窗时代（<span style="color:#008080;">27</span>年）
<span style="color:#008080;">2008</span><span style="color:#008080;">-2016</span>：复杂信息系统时代（<span style="color:#008080;">8</span>年）
<span style="color:#008080;">2016</span>-    ：人工智能时代

计算能力问题--&gt;交互问题--&gt;数据问题--&gt;人类的问题</code></pre>
    <h4>
     2.1.2编程语言的多样初心
    </h4>
    <pre><code><strong>C</strong>:    性能
Java：跨平台
<strong>C</strong>++： 大规模程序
VB：  桌面应用
Python：计算时代演进的选择</code></pre>
    <h4>
     Python语言的特点
    </h4>
    <pre class="has"><code>通用语言
脚本语言
开源、跨平台、多模型语言</code></pre>
    <hr/>
    <pre><code>C/C++：python归python ，c归c
Java：针对特定开发和岗位需求
HTML<span style="color:#009926;">/CSS/</span>JS：不可替代的前端技术，全栈能力
其他语言： R<span style="color:#009926;">/Go/</span>Matlab等，特定领域</code></pre>
    <hr/>
    <pre class="has"><code>工具决定思维：关注工具变革的力量！</code></pre>
    <h4>
     超级语言的诞生
    </h4>
    <pre><code>机器语言 <em>--&gt; 代码直接执行，与CPU有关</em>
汇编语言 <em>--&gt; 助记符，汇编器，与CPU有关</em>
高级语言 <em>--&gt; 编译器，与CPU无关</em>
超级语言 <em>--&gt; 整合已有程序，庞大计算生态</em></code></pre>
    <hr/>
    <p>
     == python是唯一的超级语言！ ==
    </p>
    <h3>
     2.2 实例2：Python蟒蛇绘制
    </h3>
    <p>
     == import turtle == 导入海归绘图库
    </p>
    <p>
     "举一反三："
    </p>
    <pre><code>Python蟒蛇绘制问题是各类图形绘制问题的代表
<em>--圆形绘制、五角星绘制、国旗绘制、机器猫绘制...</em></code></pre>
    <h3>
     2.3 模块1：turtle库的调用
    </h3>
    <h4>
     2.3.1 turtle库基本介绍
    </h4>
    <pre><code>--注：turtle库是turtle绘图体系的python实现
--<span style="color:#008080;">1969</span>年诞生，是python标准库之一，入门级图形绘制函数库
--Python计算生态 = 标准库 + 第三方库
-库Library、包Package、模快Module，统称模块</code></pre>
    <h4>
     2.3.2 turtle绘图窗体布局
    </h4>
    <pre> </pre>
    <hr/>
    <pre><code>turltle.<span style="color:#0086b3;">setup</span>(<span style="color:#0086b3;">width</span>, <span style="color:#0086b3;">height</span>, startx, starty)
--注：<span style="color:#008080;">4</span>个参数后两个可选，不选则默认在窗口的正中间，<span style="color:#0086b3;">setup</span>（）不是必须的</code></pre>
    <h4>
     2.3.3 turtle空间坐标体系
    </h4>
    <pre><code>--<span style="color:#008080;">1</span>)绝对坐标：和数学中的坐标系（象限）知识相同
--turtle.goto(x,y)

--<span style="color:#008080;">2</span>)海龟坐标：后退&lt;--&gt;前进；左侧&lt;--&gt;右侧

--<span style="color:#008080;">3</span>)空间坐标体系：turtle.bk(d),turtle.fd(d),burtle.circle(r,angle)</code></pre>
    <h4>
     2.3.4 turtle角度坐标体系
    </h4>
    <pre><code>--<span style="color:#008080;">1</span>)绝对角度：<span style="color:#008080;">0</span>/<span style="color:#008080;">360</span>,<span style="color:#008080;">90</span>/-<span style="color:#008080;">270</span>,<span style="color:#008080;">180</span>/-<span style="color:#008080;">180</span>,<span style="color:#008080;">270</span>/-<span style="color:#008080;">90</span>
--turtle.seth(angle)<span style="color:#990073;">:</span>改变海龟行进方向，angle为绝对度数，只改变方向不前进。

--<span style="color:#008080;">2</span>)海龟角度：turtle.left(angle),turtle.right(angle)</code></pre>
    <h4>
     2.3.5 RGB色彩体系
    </h4>
    <pre><code>--RGB指 红 蓝 绿 组合
--RGB整数值，小数值
--turtle.colormode(mode),默认小数值</code></pre>
    <h3>
     2.4 turtle程序语法元素分析
    </h3>
    <h4>
     2.4.1 库引用和 import
    </h4>
    <pre><code>import turtle
turtle. 格式：<span style="color:#000080;">&lt;a&gt;</span>.<span style="color:#000080;">&lt;b&gt;</span>()
<span style="color:#000080;">&lt;库名&gt;</span>.<span style="color:#000080;">&lt;函数名&gt;</span>(<span style="color:#000080;">&lt;函数参数&gt;</span>)
或 <span style="color:#000080;">&lt;库别名&gt;</span>.<span style="color:#000080;">&lt;函数名&gt;</span>(<span style="color:#000080;">&lt;函数参数&gt;</span>)</code></pre>
    <h4>
     2.4.2 画笔控制函数
    </h4>
    <pre><code><strong>penup</strong>(),<strong>pendown</strong>(),<strong>pensize</strong>(),<strong>pencolor</strong>()
别名：<strong>pu</strong>(),<strong>pd</strong>()
<strong>pensize</strong>(width) <strong>--</strong>&gt; 别名：<strong>width</strong>(width)
<strong>pencolor</strong>(color) 颜色字符串、<strong>rgb</strong>值(三个小数值，或 一个元组小数值)</code></pre>
    <h4>
     2.4.3 运动控制函数
    </h4>
    <pre><code>fd(),circle(r,extent=None)
--<span style="color:#990073;">r:</span>默认圆心在海龟左侧r距离的位置
--extent：绘制角度，默认是<span style="color:#008080;">360</span>度整圆</code></pre>
    <h4>
     2.4.4 方向控制函数
    </h4>
    <pre><code><strong>turtle</strong>.setheading(angle) 别名： <strong>seth</strong>(angle)
<strong>turtle</strong>.left(),<strong>turtle</strong>.right()</code></pre>
    <h2>
     第三章 基本数据类型
    </h2>
    <h3>
     3.1 数字类型及操作
    </h3>
    <pre><code>--<span style="color:#008080;">3.1</span>.<span style="color:#008080;">1</span>整数类型：与数学中概念一致，+|-均可，无范围限制
--pow(x,y)函数
--3.1.2 4种进制表示形式：
十进制，二进制(0b,0B开头)，八进制(0o,0O开头)，十六进制(0x,0X)

--3.1.3浮点数类型：浮点数范围和小数精度都存在限制，但常规计算可以忽略
浮点数间运算存在不确定尾数，发生在10E-16左右，不是bug
-- round(x,d):对x四舍五入，d是小数截取位数。用于浮点数间运算及比较。
-- 浮点数采用科学计数法表示&lt;a&gt;e&lt;b&gt;

--3.1.4复数类型：Z.real获得实部，Z.imag获得虚部

--3.1.5数值运算操作符：类型间可以混合运算，生成结果为“最宽”类型。

--数值运算函数：
-- abs(x) 绝对值
-- divmod(x,y) =&gt; 同时输出商和余数
-- pow(x,y[,z]) =&gt; 幂余，(x**y)%z
-- round(x[,d]) =&gt; 四舍五入，d小数位数，默认为0
-- max()最大值
-- min()最小值
-- int(x) 
-- float()
-- complex(x)</code></pre>
    <h3>
     3.2 实例3：天天向上的力量
    </h3>
    <pre><code>略

- GRIT，坚毅，对长期目标的持续激情及持久耐力
- GRIT是获得成功最重要的因素之一，牢记天天向上的力量</code></pre>
    <h3>
     3.3 字符串类型及操作
    </h3>
    <h4>
     3.3.1 字符串类型的表示
    </h4>
    <pre><code>-- 单引号，双引号；三引号
-- 索引 [M]
-- 切片 [M,N,K]
-- 转义字符：\b回退，\n换行，\r回车（光标移到本行行首）</code></pre>
    <h4>
     3.3.2 字符串操作符
    </h4>
    <pre><code>-- + 字符串拼接
-- * 复制n次字符串
-- <strong>in</strong></code></pre>
    <h4>
     3.3.3 字符串处理函数
    </h4>
    <pre><code>-- len(x)  
-- str(x) 任意类型所对应的字符串形式
-- hex(x)或oct(x) 整数x的十六进制或八进制小写形式字符串
-- chr(u) u为Unicode编码，返回其对应的字符
-- ord(x) x为字符，返回其对应的Unicode编码</code></pre>
    <h4>
     3.3.4 字符串处理方法
    </h4>
    <pre><code>-- S.lower()或S.upper() 返回字符串副本，全部字符小写/大写
-- S.split(sep=None) 返回一个列表，由str根据sep被分隔部分组成
-- S.count(sub) 返回子字符串sub在str中出现的次数
-- S.replace(old,new)
-- S.center(width[,fillchar])
-- S.strip(chars)从str中去掉在其左侧和右侧chars中列出的字符。
-- S.join(iter) 在iter变量除最后元素外每个元素增加一个S。例如：<span style="color:#dd1144;">','</span>.join(<span style="color:#dd1144;">"12345"</span>)  <em>#主要用于字符串分割</em></code></pre>
    <h4>
     3.3.5 字符串类型的格式化
    </h4>
    <pre><code>"{<!-- --><span style="color:#000080;">&lt;参数序号&gt;</span>:<span style="color:#000080;">&lt;格式控制标记&gt;</span>}"

：<span style="color:#000080;">&lt;填充&gt;</span><span style="color:#000080;">&lt;对齐&gt;</span><span style="color:#000080;">&lt;宽度&gt;</span><span style="color:#000080;">&lt;,&gt;</span><span style="color:#000080;">&lt;.精度&gt;</span><span style="color:#000080;">&lt;类型&gt;</span></code></pre>
    <h3>
     3.4 模块2：time库的使用
    </h3>
    <h4>
     3.4.1 time库的基本介绍
    </h4>
    <pre><code>时间获取：<strong>time</strong>() <strong>ctime</strong>() <strong>gmtime</strong>()
时间格式化： <strong>strftime</strong>() <strong>strptime</strong>()
程序计时：<strong>sleep</strong>(),<strong>perf_counter</strong>()</code></pre>
    <h4>
     3.4.2 时间获取
    </h4>
    <pre><code><strong>.time() 获取当前时间戳，即计算计算机内部时间值，浮点数。</strong>

<strong>.ctime()获取当前时间并以易读方式表示，返回字符串</strong>

<strong>.gmtime()获取当前时间，表示为计算机可处理的时间格式</strong></code></pre>
    <h4>
     3.4.3 时间格式化
    </h4>
    <pre><code>.strftime(tpl,ts) : tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量
t = time.gmtime()
time.strftime(<span style="color:#dd1144;">"%Y-%m-%d %H:%M:%S"</span>, t)
</code></pre>
    <pre><code>

t = time.gmtime()
time.strftime(<span style="color:#dd1144;">"%Y-%m-%d %H:%M:%S"</span>, t)

timeStr = <span style="color:#dd1144;">"2018-01-26 12:55:20"</span>
time.strptime(timeStr,<span style="color:#dd1144;">"%Y-%m-%d %H:%M:%S"</span>)</code></pre>
    <h4>
     3.4.4 程序计时应用
    </h4>
    <pre><code>start = <span style="color:#0086b3;">time</span>.perf_counter()
<strong>end</strong> = <span style="color:#0086b3;">time</span>.perf_counter()
<strong>end</strong> - start

<span style="color:#0086b3;">sleep</span>(s) s拟休眠时间，单位是秒，可以是浮点数</code></pre>
    <h3>
     3.5 实例4：文本进度条
    </h3>
    <pre><code>这里理解一个重要的系统概念:刷新
本质：用后打印的字符串覆盖之前的字符串。不能换行(<strong>end</strong>=)，要能回退\r</code></pre>
    <pre><code><em># TextProBarV3.py</em>
<strong>import</strong> time
scale = <span style="color:#008080;">50</span>
print(<span style="color:#dd1144;">"执行开始"</span>)
start = time.perf_counter()
<strong>for</strong> i <strong>in</strong> range(scale + <span style="color:#008080;">1</span>):
    a = <span style="color:#dd1144;">"*"</span> * i 
    b = <span style="color:#dd1144;">"."</span> * (scale - i)
    c = (i / scale) * <span style="color:#008080;">100</span>
    dur = time.perf_counter() - start
    print(<span style="color:#dd1144;">"\r{:^3.0f}%[{}-&gt;{}]{:.2f}s"</span>.format(c, a, b, dur), end=<span style="color:#dd1144;">""</span>)
    time.sleep(<span style="color:#008080;">0.1</span>)
print(<span style="color:#dd1144;">"\n"</span> + <span style="color:#dd1144;">"执行结束"</span>.center(scale // <span style="color:#008080;">2</span>, <span style="color:#dd1144;">"-"</span>))</code></pre>
    <h2>
     第四章 程序的控制结构
    </h2>
    <h3>
     4.1 程序的分支结构
    </h3>
    <pre class="has"><code>“程序的控制结构”：顺序结构、分支结构、循环结构</code></pre>
    <hr/>
    <h4>
     4.1.1 单分支结构
    </h4>
    <pre><code>语法： if <span style="color:#000080;">&lt;条件&gt;</span>:
         <span style="color:#000080;">&lt;语句块&gt;</span></code></pre>
    <h4>
     4.1.2 二分支结构
    </h4>
    <pre><code>语法： if &lt;条件&gt;:
         &lt;语句块<span style="color:#008080;">1</span>&gt;
<span style="color:#990073;">        else:</span>
         &lt;语句块<span style="color:#008080;">2</span>&gt;
         
紧凑形式：适用于简单表达式的二分支结构
&lt;表达式<span style="color:#008080;">1</span>&gt; if &lt;条件&gt; else &lt;表达式<span style="color:#008080;">2</span>&gt;</code></pre>
    <h4>
     4.1.3 多分支结构
    </h4>
    <pre><code>语法：if &lt;条件<span style="color:#008080;">1</span>&gt;:
         &lt;语句块<span style="color:#008080;">1</span>&gt;
      elif &lt;条件<span style="color:#008080;">2</span>&gt;：
          &lt;语句<span style="color:#008080;">2</span>&gt;
          ...
<span style="color:#990073;">        else:</span>
         &lt;语句块N&gt;</code></pre>
    <p>
     <em>
      注： 注意多条件之间的包含关系，注意变量取值范围的覆盖。 通俗点： 多分支结构中，如果一个分支判断条件通过后，会执行对应的语句块，之后结束分支程序。即使，后续的elif条件也满足，也不会执行对应的语句块.所以这里其实也有一个顺序关系。
     </em>
    </p>
    <h4>
     4.1.4 条件判断及组合
    </h4>
    <pre><code>--条件判断操作符：&lt;,&lt;=,&gt;=,&gt;,==,!=

--条件组合三个保留字：<strong>and</strong>,<strong>or</strong>,<strong>not</strong></code></pre>
    <h4>
     4.1.5 程序的异常处理
    </h4>
    <pre><code><strong>try</strong>:
    &lt;语句块<span style="color:#008080;">1</span>&gt;
except <strong>[&lt;异常类型&gt;]</strong>：
    &lt;语句块<span style="color:#008080;">2</span>&gt;
注：标注异常类型后，仅响应该异常，异常类型名字等同于变量。</code></pre>
    <hr/>
    <pre><code>高级使用：
<span style="color:#990073;">
try:</span>
    &lt;语句块<span style="color:#008080;">1</span>&gt;
<span style="color:#990073;">except:</span>
    &lt;语句块<span style="color:#008080;">2</span>&gt;
<span style="color:#990073;">else:</span>           <strong># 不发生异常的时候执行(奖励)</strong>
    &lt;语句块<span style="color:#008080;">3</span>&gt;
<span style="color:#990073;">finally:</span>        <strong># 一定会执行</strong>
    &lt;语句块<span style="color:#008080;">4</span>&gt;</code></pre>
    <h3>
     4.2 实例5：身体质量指数BMI
    </h3>
    <pre><code>BMI = 体重<em>(Kg)</em>/身高^<span style="color:#008080;">2</span><em>(m^2)</em>
略</code></pre>
    <hr/>
    <pre class="has"><code>注：阅读代码的时候，快速的方法是：先搞懂分支的范围关系，再深入看每个分支在做什么。而不是从上到下的顺序结构。</code></pre>
    <h3>
     4.3 程序的循环结构
    </h3>
    <p>
     ###4.3.1 遍历循环
    </p>
    <pre><code>for &lt;循环变量&gt; in &lt;遍历结构&gt;:
    &lt;语句块&gt;
--从遍历结构中逐一提取元素，放在循环变量中。
--完整遍历所有元素后结束
--每次循环，所获得元素放入循环变量，并执行一次语句块

应用：计数循环、字符串遍历循环、列表遍历循环、文件遍历循环、等等</code></pre>
    <h4>
     4.3.2 无限循环
    </h4>
    <pre><code>while <span style="color:#000080;">&lt;条件&gt;</span>:
    <span style="color:#000080;">&lt;语句块&gt;</span></code></pre>
    <h4>
     4.3.3 循环控制保留字
    </h4>
    <pre><code>-<strong>break</strong> 跳出并结束当前循环，执行循环后的语句

-<strong>continue</strong> 结束当次循环，继续执行后续次数循环

--<strong>break</strong>和<strong>continue</strong>可以与<strong>for</strong>和<strong>while</strong>循环搭配使用。</code></pre>
    <h4>
     4.3.4 循环的高级用法
    </h4>
    <pre><code>循环中增加else:       
            &lt;语句块2&gt;

--当循环没有被<strong>break</strong>语句退出时，执行<strong>else</strong>语句块
--<strong>else</strong>语句块作为“正常”完成循环的奖励
--这里<strong>else</strong>的用法与异常处理中<strong>else</strong>用法相似</code></pre>
    <h3>
     4.4 模块3：random库的使用
    </h3>
    <h4>
     4.4.1 random 标准库之一
    </h4>
    <pre><code>--伪随机数：采用梅森旋转算法生成的(伪)随机序列中元素
--random库主要用于生成随机数</code></pre>
    <h4>
     4.4.2 基本随机函数
    </h4>
    <pre><code>seed(a=None) --初始化给定的随机数种子，默认为当前系统时间
--random.seed(<span style="color:#008080;">10</span>)  <em># 产生种子10对应的序列</em>
--这个在实战中用的比较多，“确定”的伪随机数便于对程序进行复现。

random()
--生成一个[<span style="color:#008080;">0</span>.<span style="color:#008080;">0</span>，<span style="color:#008080;">1.0</span>)之间的随机小数
--random.random()</code></pre>
    <h4>
     4.4.3 扩展随机数函数
    </h4>
    <pre><code><strong>&gt;</strong>1. randint(a,b) 生成[a,b]之间的整数
<strong>
&gt;</strong>2. randrange(m,n[,k]) 生成一个[m,n)之间以k为步长的随机整数
<strong>
&gt;</strong>3. getrandbits(k) 生成一个k比特长的随机整数
<strong>
&gt;</strong>4. uniform(a,b) 生成一个[a,b]之间的随机小数
<strong>
&gt;</strong>5. choice(seq) 从序列seq中随机选择一个元素
<strong>
&gt;</strong>6. shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列</code></pre>
    <h3>
     4.5 实例6：圆周率的计算
    </h3>
    <h4>
     4.5.1 蒙特卡洛方法
    </h4>
    <pre><code><strong>from</strong> random <strong>import</strong> random
<strong>from</strong> time <strong>import</strong> perf_counter
DARTS = <span style="color:#008080;">1000</span> * <span style="color:#008080;">1000</span>
hits = <span style="color:#008080;">0.0</span>
start = perf_counter()
<strong>for</strong> i <strong>in</strong> range(<span style="color:#008080;">1</span>, DARTS+<span style="color:#008080;">1</span>):
    x, y = random(), random()
    dist = pow(x ** <span style="color:#008080;">2</span> + y ** <span style="color:#008080;">2</span>, <span style="color:#008080;">0.5</span>)
    <strong>if</strong> dist &lt;= <span style="color:#008080;">1.0</span>:
        hits += <span style="color:#008080;">1</span>
pi = <span style="color:#008080;">4</span> * (hits / DARTS)
print(<span style="color:#dd1144;">"圆周率是：{}"</span>.format(pi))
print(<span style="color:#dd1144;">"运行时间是：{:.5f}s"</span>.format(perf_counter() - start))</code></pre>
    <h3>
     第五章：函数的定义与使用
    </h3>
    <h4>
     5.1.1 函数的理解和定义
    </h4>
    <pre><code>函数是一段具有特定功能、可重用的语句组
降低编程难度 和 代码复用

def <span style="color:#000080;">&lt;函数名&gt;</span>(<span style="color:#000080;">&lt;参数(0个或多个)&gt;</span>)：
    <span style="color:#000080;">&lt;函数体&gt;</span>
    return <span style="color:#000080;">&lt;返回值&gt;</span>

不调用不会被执行</code></pre>
    <h4>
     5.1.2 函数的使用及调用过程
    </h4>
    <pre><code>调用是运行函数代码的方式
-调用时给出实际参数，替代定义中的形式参数
-函数调用得到返回值</code></pre>
    <h4>
     5.1.3 函数的参数传递
    </h4>
    <pre><code>-- 参数的个数：<span style="color:#008080;">0</span>，<span style="color:#008080;">1</span>，或多个。但是必须保留括号

-- 可变数量参数，既不确定参数总数量

-- 传递参数两种方式：位置参数，名称传递</code></pre>
    <h4>
     5.1.4 函数的返回值
    </h4>
    <pre><code>-- <strong>return</strong> 保留字用来传递返回值
-- 可以传，可以不传，可以传递<span style="color:#008080;">0</span>个，也可以传多个</code></pre>
    <h4>
     5.1.5 局部变量和全局变量
    </h4>
    <pre><code>-- (一般函数外部是全局变量，函数内部的变量是局部变量)

规则一：局部变量和全局变量是不同变量
--局部变量是函数内部的占位符，与全局变量可能重名但不同
--函数运算结束后，局部变量被释放
--可以用 global保留字在函数内部使用全局变量
(这里还分可变类型和不可变类型)

规则二：局部变量为组合数据类型且未创建，等同于全局变量

使用规则：
-基本数据类型，无论是否重名，局部变量与全局变量不同
-可以通过global保留字在函数内部声明全局变量
-组合数据类型，如果局部变量未真实创建，则是全局变量</code></pre>
    <h4>
     5.1.6 lambda函数
    </h4>
    <pre><code>无名，保留字，函数名是返回结果

&lt;函数名&gt; = lambda &lt;参数&gt;:&lt;表达式&gt;

--主要作用  特定函数或方法  的参数
-- 固定使用方式，逐步积累掌握
-- 一般情况，用<strong>def</strong>定义普通函数，慎用<strong>lambda</strong></code></pre>
    <h3>
     5.2 七段数码管 绘制
    </h3>
    <h4>
     5.2.1 基本思路
    </h4>
    <pre><code>--<span style="color:#008080;">1</span>. 绘制单个数字对应的数码管
--<span style="color:#008080;">2</span>. 获得一串数字，绘制对应的数码管
--<span style="color:#008080;">3</span>. 获得当前系统时间，绘制对应的数码管</code></pre>
    <ul>
     <li>
      <p>
       分析单个数码管：
      </p>
      <ul>
       <li>
        七段数码管由7个基本线条组成
       </li>
       <li>
        七段数码管可以有固定顺序(抽象出一条可以首尾相连且不重不漏的路径)
       </li>
       <li>
        不同数字显示不同的线条(通过pu，pd控制)
       </li>
      </ul>
     </li>
     <li>
      <p>
       获取一段数字，绘制多个数码管：
      </p>
      <ul>
       <li>
        每绘制完一个数字，向右移动一段距离，准备下一个数字的绘制
       </li>
      </ul>
     </li>
     <li>
      <p>
       获取当前系统时间：
      </p>
      <ul>
       <li>
        time库
       </li>
       <li>
        增加年月日标记： write 方法
       </li>
       <li>
        年月日颜色不同标记
       </li>
       <li>
        线条之间适当小间隔，提高颜值
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     5.2.2 理解思维方法
    </h4>
    <ul>
     <li>
      模块化思维：确定模块接口，封装功能
     </li>
     <li>
      规则化思维：抽象过程为规则，计算机自动执行
     </li>
     <li>
      化繁为简：将大功能变为小功能，分而治之(松耦合，紧耦合)
     </li>
    </ul>
    <h4>
     5.2.3 举一反三
    </h4>
    <ul>
     <li>
      绘制带小数点的七段数码管
     </li>
     <li>
      带刷新的时间倒计时效果
     </li>
     <li>
      绘制高级的数码管(多段)
     </li>
    </ul>
    <h3>
     5.3 代码复用与函数递归
    </h3>
    <h4>
     5.3.1 代码复用与模块化设计
    </h4>
    <ul>
     <li>
      代码复用：把代码当成资源进行抽象
     </li>
     <li>
      代码复用：|函数|和|对象|是代码复用的两种主要形式
      <ul>
       <li>
        函数：(将代码命名)：在代码层面建立了初步抽象
       </li>
       <li>
        对象：(属性和方法):在函数基础上再次组织进行抽象
       </li>
      </ul>
     </li>
     <li>
      模块化设计：分而治之
     </li>
     <li>
      模块化设计：紧耦合、松耦合
     </li>
    </ul>
    <h4>
     5.3.2 函数递归的理解
    </h4>
    <ul>
     <li>
      定义：函数定义中调用函数自身的方式
     </li>
     <li>
      两个关键特征：
      <ul>
       <li>
        链条：计算过程存在递归链条
       </li>
       <li>
        基例：存在一个或多个不需要再次递归的基例
       </li>
      </ul>
     </li>
     <li>
      类似数学归纳法：递归是数学归纳法思维的编程体现
     </li>
    </ul>
    <h4>
     5.3.3 函数递归的调用过程
    </h4>
    <ul>
     <li>
      递归的实现：函数+分支语句
      <ul>
       <li>
        递归本身是一个函数，需要函数定义方式的描述
       </li>
       <li>
        函数内部，采用分支语句对输入参数进行判断
       </li>
       <li>
        基例和链条，分别编写对应的代码
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     5.3.4 函数递归实例解析
    </h4>
    <ul>
     <li>
      字符串反转
     </li>
     <li>
      斐波那契数列
     </li>
     <li>
      汉诺塔 PS：学会找到基例和链条
     </li>
    </ul>
    <h3>
     5.4 模块：PyInstaller库的使用
    </h3>
    <h4>
     5.4.1 概述
    </h4>
    <ul>
     <li>
      将.py源码转换成无需源代码的可执行文件
     </li>
     <li>
      在命令窗口输入后回车可以查看对应的方法参数帮助
     </li>
     <li>
      要配置Path，关闭后再开cmd窗口
     </li>
    </ul>
    <h3>
     实例8：科赫雪花小包裹
    </h3>
    <pre class="has"><code>PS：分形几何，自然界常见</code></pre>
    <ul>
     <li>
      基本方法：
      <ul>
       <li>
        递归思想：函数+分支
       </li>
       <li>
        递归链条：线段的组合
       </li>
       <li>
        递归基例：初识线段
       </li>
      </ul>
     </li>
     <li>
      运用 PyInstaller库
     </li>
     <li>
      举一反三
      <ul>
       <li>
        修改分形几何绘制阶数
       </li>
       <li>
        修改科赫曲线的基本定义及旋转角度
       </li>
       <li>
        修改绘制科赫雪花的基础框架图形
       </li>
      </ul>
     </li>
     <li>
      分形几何扩展：
      <ul>
       <li>
        康托尔集、谢尔宾斯基三角、门格海绵...
       </li>
       <li>
        龙形曲线、空间填充曲线、科赫曲线...
       </li>
       <li>
        函数递归的深入应用...
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
     第六章 组合数据类型
    </p>
    <h4>
     6.1 集合类型及操作
    </h4>
    <ul>
     <li>
      6.1.1 集合类型定义
      <ul>
       <li>
        与数学中概念一致
       </li>
       <li>
        集合元素之间无序，每个元素之间唯一，不存在相同元素
       </li>
       <li>
        集合元素不可更改，不能是可变数据类型(为什么？集合定义：元素唯一不重复)
       </li>
       <li>
        集合建立用{}表示，元素逗号分隔
       </li>
       <li>
        建立集合用{}或set()
       </li>
       <li>
        建立空集合必须是set()：因为Python中字典类型使用更多，所以{}给了建立空字典
       </li>
      </ul>
     </li>
     <li>
      6.1.2 集合间操作
      <ul>
       <li>
        S | T 并
       </li>
       <li>
        S - T 差
       </li>
       <li>
        S &amp; T 交
       </li>
       <li>
        S ^ T 补 PS：上述四种操作均返回一个新集合
       </li>
       <li>
        S &lt;= T 或 S &lt; T : 返回True/False，判断S和T的子集关系
       </li>
       <li>
        S &gt;= T 或 S &gt; T : 返回True/False，判断S和T的包含关系
       </li>
       <li>
        S|=T 更新集合S，包括在集合S和T中的所有元素
       </li>
       <li>
        S-=T 更新集合S，包括在集合S但不在集合T中的元素
       </li>
       <li>
        S&amp;=T 更新集合S，包括同时在集合S和T中的元素
       </li>
       <li>
        S^=T 更新集合S，包括集合S和T中的非相同元素
       </li>
       <li>
        操作函数或操作方法：
        <ul>
         <li>
          S.add(x) 如果X不在集合S中，将X增加到S
         </li>
         <li>
          S.discard(x) 移除S中的元素X，如果x不在S中，不报错
         </li>
         <li>
          S.remove(x) 移除S中元素X，如果x不在S中，产生KeyError异常
         </li>
         <li>
          S.clear() 移除S中所有元素
         </li>
         <li>
          S.pop() 随机返回S的一个元素，更新S，若S为[空]产生KeyError异常
         </li>
         <li>
          S.copy() 返回集合S的一个副本
         </li>
         <li>
          len(S)
         </li>
         <li>
          x in S
         </li>
         <li>
          x not in S
         </li>
         <li>
          set(x) 其他变量转变为集合类型
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      6.1.3 集合类型应用场景
      <ul>
       <li>
        包含关系比较
       </li>
       <li>
        数据去重
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     6.2 序列类型及操作
    </h4>
    <ul>
     <li>
      <p>
       6.2.1 定义
      </p>
      <ul>
       <li>
        序列是具有先后关系的一组元素
        <ul>
         <li>
          序列是一维元素向量，元素类型可以不同
         </li>
         <li>
          元素间由序号引导，通过下标访问序列的特定元素
         </li>
        </ul>
       </li>
       <li>
        序列是一个基类类型
        <ul>
         <li>
          字符串、元组、列表
         </li>
        </ul>
       </li>
       <li>
        序号：反向递减，正向递增
       </li>
      </ul>
     </li>
     <li>
      <p>
       6.2.2 函数和方法
      </p>
      <ul>
       <li>
        通用操作符(6个)
        <ul>
         <li>
          in
         </li>
         <li>
          not in
         </li>
         <li>
          "+" ：拼接
         </li>
         <li>
          "*" : 复制
         </li>
         <li>
          s[i] : 索引
         </li>
         <li>
          s[i:j:k] : 切片
         </li>
        </ul>
       </li>
       <li>
        函数和方法(5个)
        <ul>
         <li>
          len(s)
         </li>
         <li>
          min(s)
         </li>
         <li>
          max(s)
         </li>
         <li>
          s.index(x[,i,j])
         </li>
         <li>
          s.count(x)
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       6.2.3 元组类型及操作
      </p>
      <ul>
       <li>
        元组是序列类型的一种扩展
        <ul>
         <li>
          不可修改
         </li>
         <li>
          ()或tuple()创建，元素间逗号分隔
         </li>
         <li>
          可以使用或不用()
         </li>
         <li>
          特殊：单个元组，元素后面要加逗号
         </li>
        </ul>
       </li>
       <li>
        元组继承序列类型全部通用操作符
        <ul>
         <li>
          创建后不可修改，所以没有特殊操作
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       6.2.4 列表类型及操作
      </p>
      <ul>
       <li>
        序列类型的一种扩展
        <ul>
         <li>
          创建后可以随意被修改
         </li>
         <li>
          []或list()创建，元素间逗号分隔
         </li>
         <li>
          列表中各元素类型可以不同，无长度限制
         </li>
        </ul>
       </li>
       <li>
        定义:方括号[]真正创建一个列表，赋值仅传递引用（贴标签）
       </li>
       <li>
        函数和方法
        <ul>
         <li>
          ls[i] = x 修改
         </li>
         <li>
          ls[i:j:k] = lt lt替换ls切片后所对应元素子列表
         </li>
         <li>
          del ls[i] 删除第i个元素
         </li>
         <li>
          del ls[i:j:k]
         </li>
         <li>
          ls += lt 更新列表ls，将lt元素增加到ls中。这里有个特殊点提一下：这里的操作不会重新开辟内存空间，本质上相当于ls.extend(lt)。
         </li>
         <li>
          ls *= n 更新列表ls，重复n次
         </li>
         <li>
          ls.append(x) 列表后面追加x
         </li>
         <li>
          ls.clear() 删除所有元素
         </li>
         <li>
          ls.copy() 生成一个新列表，赋值ls中所有元素
         </li>
         <li>
          ls.insert(i,x) 索引i的位置插入元素x
         </li>
         <li>
          ls.pop(i) 取出索引为i对应的元素并将它从列表中删除，默认i=-1
         </li>
         <li>
          ls.remove(x) 列表中出现的第一个x元素删除
         </li>
         <li>
          ls.reverse() 列表中元素反转
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       6.2.5 序列类型应用场景
      </p>
      <ul>
       <li>
        元素遍历：ls、tp
       </li>
       <li>
        数据保护：tp
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     6.3 实例9：基本统计值计算
    </h4>
    <ul>
     <li>
      6.3.1 基本统计值计算 ——问题分析
      <ul>
       <li>
        总个数、求和、平均值、方差、中位数……
       </li>
       <li>
        len()
       </li>
       <li>
        for in 求和
       </li>
       <li>
        均值：求和/总个数
       </li>
       <li>
        方差： pow()函数
       </li>
       <li>
        中位数：排序，然后……
       </li>
      </ul>
     </li>
     <li>
      6.3.2 实例讲解
      <ul>
       <li>
        略
       </li>
      </ul>
     </li>
     <li>
      6.3.3 举一反三
      <ul>
       <li>
        获取数据，控制台获取，多参数
       </li>
       <li>
        函数：模块化设计
       </li>
       <li>
        利用BIF函数
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     6.4 字典类型及操作
    </h4>
    <ul>
     <li>
      <p>
       6.4.1 定义
      </p>
      <ul>
       <li>
        理解"映射",key:value对
       </li>
       <li>
        list、tuple、str等序列类型是由python内部默认由0...N整数作为数据的默认索引
       </li>
       <li>
        映射类型则由用户为数据定义索引
       </li>
       <li>
        键(key)是数据索引的扩展
       </li>
       <li>
        字典是键值对的集合，键值对之间无序
       </li>
       <li>
        采用{}和dict()创建，键值对用冒号表示
       </li>
       <li>
        []用来向字典变量中索引或增加元素
       </li>
      </ul>
     </li>
     <li>
      <p>
       函数和方法
      </p>
      <ul>
       <li>
        del d[k] 删除键k对应的键值对
       </li>
       <li>
        k in d[k] 判断键是否在字典中
       </li>
       <li>
        d.keys() 返回字典中所有键的信息，类似集合形式
       </li>
       <li>
        d.values() 返回字典中所有值的信息，类似集合形式
       </li>
       <li>
        d.items() 返回字典中所有键值对的信息，类似集合形式，键值对是以元组形式
       </li>
       <li>
        d.get(k,&lt;default&gt;) 键k存在，返回对应的值，否则返回&lt;default&gt;值
       </li>
       <li>
        d.pop(k,&lt;default&gt;) 键k存在，取出对应的值，否则返回&lt;default&gt;值
       </li>
       <li>
        d.popitem() 随机从字典中取出一个键值对，以元组形式返回
       </li>
       <li>
        d.clear() 删除所有键值对
       </li>
       <li>
        len(d) 返回字典中键值对的个数
       </li>
      </ul>
     </li>
     <li>
      <p>
       应用场景
      </p>
      <ul>
       <li>
        统计数据出现的次数，数据是键，次数是值
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     6.5 模块5：jieba库的使用
    </h4>
    <ul>
     <li>
      6.5.1 jieba库是优秀的中文分词第三方库
      <ul>
       <li>
        pip安装
       </li>
       <li>
        原理：依靠中文词库，通过汉字之间的关联概率判断，用户可以自定义添加特殊的分词词组，运用于特地的领域
       </li>
       <li>
        三种分词模式
        <ul>
         <li>
          精确模式：精确分开，不存在冗余单词
         </li>
         <li>
          全模式：所有可能词语扫描出来，有冗余
         </li>
         <li>
          搜索引擎模式：精确模式基础上，对长词进行再次切分
         </li>
        </ul>
       </li>
       <li>
        常用函数：
        <ul>
         <li>
          jieba.lcut(s) 精确模式
         </li>
         <li>
          jieba.lcut(s,cut_all=True) 全模式
         </li>
         <li>
          jieba.lcut_for_search(s) 搜索引擎模式，返回列表类型的分词结果，存冗余
         </li>
         <li>
          jieba.add_word(w) 向分词添加新词
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     6.6 实例10：文本词频统计
    </h4>
    <pre class="has"><code>略</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     第七章 文件和数据格式化
    </h3>
    <h4>
     7.1 文件的使用
    </h4>
    <ul>
     <li>
      <p>
       7.1.1 文件的类型
      </p>
      <ul>
       <li>
        文件是数据的抽象和集合
        <ul>
         <li>
          文件是存储在辅助存储器上的[数据序列]
         </li>
         <li>
          文件是数据存储的一种形式
         </li>
         <li>
          文件展现形态：文本文件和二进制文件
         </li>
        </ul>
       </li>
       <li>
        文本文件 VS 二进制文件
        <ul>
         <li>
          文本文件和二进制文件只是文件的展示方法
         </li>
         <li>
          本质上：所有文件都是二进制形式存储
         </li>
         <li>
          形式上，所有文件采用两种方式展示
         </li>
        </ul>
       </li>
       <li>
        文本文件：
        <ul>
         <li>
          由单一特定编码组成的文件，如UTF-8编码
         </li>
         <li>
          由于存在编码，也被看成是存储着的长字符串
         </li>
         <li>
          例如：.txt ， .py文件等
         </li>
        </ul>
       </li>
       <li>
        二进制文件：
        <ul>
         <li>
          直接由比特0、1组成，没有统一字符编码
         </li>
         <li>
          一般存在二进制0，1的组织结构，即文件格式
         </li>
         <li>
          例如：png、avi等
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       7.1.2 文件打开和关闭
      </p>
      <ul>
       <li>
        文件处理的步骤：打开——操作——关闭
       </li>
      </ul>
     </li>
    </ul>
    <p>
     文件的存储状态文件的占用状态a = opne( , )a.close()文件的存储状态文件的占用状态
    </p>
    <ul>
     <li>
      <ul>
       <li>
        <p>
         读文件：3种方法 VS 写文件： 3种方法 -文件的打开： &lt;变量名&gt; = open(&lt;文件名&gt;，&lt;打开模式&gt;)
        </p>
        <p>
         变量名：文件句柄
        </p>
        <p>
         文件名：文件路径和名称(源文件同目录可省略)
        </p>
        <p>
         打开模式：文本or二进制；读or写
        </p>
        <p>
         补充：windows下，文件目录之间用\，这个和python冲突，解决方式两种：\\，或者用/ .
        </p>
        <p>
         打开模式：
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th style="border-color:#dfe2e5;">
        文件打开模式
       </th>
       <th style="border-color:#dfe2e5;">
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="border-color:#dfe2e5;">
        "r"
       </td>
       <td style="border-color:#dfe2e5;">
        只读模式，默认值，若文件不存在，返回FileNotFoundError
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        "w"
       </td>
       <td style="border-color:#dfe2e5;">
        覆盖写模式，文件不存在则创建，存在则完全覆盖
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        "x"
       </td>
       <td style="border-color:#dfe2e5;">
        创建写模式，文件不存在则创建，存在则返回FileExistsError
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        "a"
       </td>
       <td style="border-color:#dfe2e5;">
        追加写模式，文件不存在则创建，存在则在文件最后追加内容
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        "b"
       </td>
       <td style="border-color:#dfe2e5;">
        二进制文件模式
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        "t"
       </td>
       <td style="border-color:#dfe2e5;">
        文本文件模式，默认值
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        "+"
       </td>
       <td style="border-color:#dfe2e5;">
        与r/w/x/a一同使用，在原功能基础上增加同时读写功能
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code>文件关闭：变量名.<span style="color:#0086b3;">close</span>()</code></pre>
    <ul>
     <li>
      <p>
       7.1.3 文件内容的读取
      </p>
      <table>
       <thead>
        <tr>
         <th style="border-color:#dfe2e5;">
          操作方法
         </th>
         <th style="border-color:#dfe2e5;">
          描述
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-color:#dfe2e5;">
          &lt;f&gt;.read(size=-1)
         </td>
         <td style="border-color:#dfe2e5;">
          读入全部内容，如果给出参数，读入前size长度
         </td>
        </tr>
        <tr>
         <td style="border-color:#dfe2e5;">
          &lt;f&gt;.readline(size=-1)
         </td>
         <td style="border-color:#dfe2e5;">
          读入一行内容，如果给出参数，读入该行前size长度，每读取一行指针移动到下一行的行首。
         </td>
        </tr>
        <tr>
         <td style="border-color:#dfe2e5;">
          &lt;f&gt;.readlines(hint=-1)
         </td>
         <td style="border-color:#dfe2e5;">
          读入文件所有行，以每行为元素形成列表。如果给出参数，读入前hint行。
         </td>
        </tr>
       </tbody>
      </table>
     </li>
     <li>
      <ul>
       <li>
        文件的全文本操作
        <ul>
         <li>
          遍历全文本：方法一：一次读入read，统一处理
         </li>
         <li>
          遍历全文本：方法二：按数量读入，逐步处理
         </li>
        </ul>
        <pre><code>fo = open(filename,<span style="color:#dd1144;">"r"</span>)
txt = fo.read(<span style="color:#008080;">2</span>)
<strong>while</strong> txt != <span style="color:#dd1144;">""</span>:
    <em># 对txt进行处理</em>
    txt = fo.read(<span style="color:#008080;">2</span>)
fo.close()
</code></pre>
       </li>
       <li>
        文件的逐行操作
        <ul>
         <li>
          逐行遍历文件：方法一:一次读入，分行处理。缺点：对于大文件读取速度慢
         </li>
        </ul>
        <pre><code>fo = open(filename,<span style="color:#dd1144;">"r"</span>)
<strong>for</strong> line <strong>in</strong> fo.readlines():
    print(line)
fo.close()
</code></pre>
        <ul>
         <li>
          逐行遍历文件：方法二:分行读入，逐行处理。优点：大文件处理速度块
         </li>
        </ul>
        <pre><code>fo = open(filename,<span style="color:#dd1144;">"r"</span>)
<strong>for</strong> line <strong>in</strong> fo: <em># 通过迭代器访问</em>
    print(line)
fo.close()
</code></pre>
       </li>
      </ul>
     </li>
    </ul>
    <ul>
     <li>
      7.1.4 数据的文件写入
     </li>
    </ul>
    <table>
     <thead>
      <tr>
       <th style="border-color:#dfe2e5;">
        操作方法
       </th>
       <th style="border-color:#dfe2e5;">
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td style="border-color:#dfe2e5;">
        &lt;f&gt;.write(s)
       </td>
       <td style="border-color:#dfe2e5;">
        向文件写入一个字符串或字节流
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        &lt;f&gt;.writelines(lines)
       </td>
       <td style="border-color:#dfe2e5;">
        将一个元素全为字符串的列表写入文件
       </td>
      </tr>
      <tr>
       <td style="border-color:#dfe2e5;">
        &lt;f&gt;.seek(offset)
       </td>
       <td style="border-color:#dfe2e5;">
        改变当前文件操作指针的位置，offset含义如下：0 - 文件开头；1 - 当前位置；2 - 文件结尾
       </td>
      </tr>
     </tbody>
    </table>
    <pre><code>fo = open(<span style="color:#dd1144;">"output.txt"</span>, <span style="color:#dd1144;">"w+"</span>)
ls = [<span style="color:#dd1144;">"中国"</span>, <span style="color:#dd1144;">"法国"</span>, <span style="color:#dd1144;">"美国"</span>]
fo.writelines(ls)
fo.seek(<span style="color:#008080;">0</span>)  <em># 否则，没有结果输出</em>
<strong>for</strong> line <strong>in</strong> fo:
    print(line)
fo.close()
</code></pre>
    <h4>
     7.2 实例11：自动化轨迹绘制
    </h4>
    <ul>
     <li>
      <p>
       7.2.1 问题分析
      </p>
      <ul>
       <li>
        需求：根据脚本来绘制图形？
       </li>
       <li>
        不是写代码而是写数据绘制轨迹
       </li>
       <li>
        数据脚本是自动化最重要的第一步
       </li>
      </ul>
     </li>
     <li>
      <p>
       7.2.2 实例讲解
      </p>
      <ul>
       <li>
        基本思路：
        <ul>
         <li>
          步骤1：定义数据文件格式(接口)：个性化
         </li>
         <li>
          步骤2：编写程序，根据文件接口解析参数绘制图形
         </li>
         <li>
          步骤3：编制数据文件
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       7.2.3 举一反三
      </p>
      <ul>
       <li>
        理解方法思维
        <ul>
         <li>
          自动化思维：数据和功能分离，数据驱动的自动运行
         </li>
         <li>
          接口化设计：格式化设计接口，清晰明了
         </li>
         <li>
          二维数据应用：应用维度组织数据，二维数据最常用
         </li>
        </ul>
       </li>
       <li>
        应用问题扩展：
        <ul>
         <li>
          扩展接口设计，增加更多控制接口
         </li>
         <li>
          扩展功能设计,增加弧形等更多功能
         </li>
         <li>
          扩展应用需求，发展自动轨迹绘制到动画绘制
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       7.3 一维数据的格式化和处理
      </p>
      <ul>
       <li>
        <p>
         7.3.1 数据组织的维度：组织形式
        </p>
        <ul>
         <li>
          一维数据：
          <ul>
           <li>
            由对等关系的有序或无序数据构成，采用线性方式组织
           </li>
           <li>
            对应列表、数组和集合等概念
           </li>
          </ul>
         </li>
         <li>
          二维数据：
          <ul>
           <li>
            由多个一维数据构成，是一维数据的组合形式
           </li>
           <li>
            表格是典型的二维数据，其中，表头是二维数据的一部分
           </li>
          </ul>
         </li>
         <li>
          多维数据
          <ul>
           <li>
            由一维或二维数据在新维度上扩展形成
           </li>
           <li>
            比如，加入时间维度
           </li>
          </ul>
         </li>
         <li>
          高维数据
          <ul>
           <li>
            仅利用组基本的二元关系展示数据间的复杂结构
           </li>
           <li>
            比如，字典嵌套
           </li>
          </ul>
         </li>
         <li>
          数据的操作周期：
          <ul>
           <li>
            存储&lt;-&gt;表示&lt;-&gt;操作
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         一维数据的表示
        </p>
        <ul>
         <li>
          如果数据间有序：列表，for遍历
         </li>
         <li>
          如果数据间无序：集合，for遍历
         </li>
        </ul>
       </li>
       <li>
        <p>
         一维数据的存储
        </p>
        <ul>
         <li>
          存储方式一：空格分隔
          <ul>
           <li>
            使用一个或多个空格分隔进行存储，不换行
           </li>
           <li>
            缺点：数据中不能存在空格
           </li>
          </ul>
         </li>
         <li>
          存储方式二：逗号分隔
          <ul>
           <li>
            使用英文半角逗号分隔数据进行存储，不换行
           </li>
           <li>
            缺点：数据中不能有英文逗号
           </li>
          </ul>
         </li>
         <li>
          存储方式三：其他方式，特殊字符
          <ul>
           <li>
            使用其他符号或符号组合分隔，建议采用特殊符号
           </li>
           <li>
            缺点：需要根据数据特点定义，通用性较差
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <p>
         一维数据的处理
        </p>
        <ul>
         <li>
          将存储的数据读入程序
          <ul>
           <li>
            split方法
           </li>
          </ul>
         </li>
         <li>
          将程序表示的数据写入文件
          <ul>
           <li>
            join(ls) 方法
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       7.4 二维数据的格式化和处理
      </p>
      <ul>
       <li>
        7.4.1 二维数据的表示
        <ul>
         <li>
          list类型：二维列表
          <ul>
           <li>
            使用两层for遍历
           </li>
           <li>
            外层列表中每个元素可以对应一行，也可以对应一列
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        7.4.2 CSV格式与二维数据存储
        <ul>
         <li>
          注：CSV：Comma-Separated Values
         </li>
         <li>
          国际通用的一二维数据存储格式，后缀：.csv
         </li>
         <li>
          每行一个一维数据，采用逗号分隔，无空行
         </li>
         <li>
          Excel可读入输出，一般编辑软件都可以产生
         </li>
         <li>
          如果某个元素缺失，逗号仍要保留
         </li>
         <li>
          二维数据的表头可以作为数据存储，也可以另行存储
         </li>
         <li>
          逗号为英文半角逗号，逗号与数据之间无额外空格
         </li>
        </ul>
       </li>
       <li>
        7.4.3 二维数据的存储
        <ul>
         <li>
          按行、列存储都可以
         </li>
         <li>
          一般习惯：ls[row][column],先行后列
         </li>
         <li>
          根据一般习惯，按行存
         </li>
        </ul>
       </li>
       <li>
        7.4.4 二维数据的处理
        <ul>
         <li>
          读入处理：
          <pre><code>fo = open(filename)
ls = []
<strong>for</strong> line <strong>in</strong> fo:
  line = line.replace(<span style="color:#dd1144;">"\n"</span>, <span style="color:#dd1144;">""</span>)
  ls.append(line.split(<span style="color:#dd1144;">","</span>))
fo.close()
</code></pre>
         </li>
         <li>
          写入处理：
          <pre><code>ls = [[], [], []]  <em># 二维列表</em>
f = open(fname, <span style="color:#dd1144;">"w"</span>)
<strong>for</strong> item <strong>in</strong> ls:
    f.write(<span style="color:#dd1144;">","</span>.join(item) + <span style="color:#dd1144;">"\n"</span>)
f.close()
</code></pre>
         </li>
         <li>
          二维数据的逐一处理
          <ul>
           <li>
            采用二层循环
           </li>
          </ul>
          <pre><code>ls = [[], [], []]  <em>#二维列表</em>
<strong>for</strong> row <strong>in</strong> ls:
  <strong>for</strong> cloumn <strong>in</strong> row:
      print(ls[row][column])
</code></pre>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
      </p>
      - 7.5 模块6：wordcloud库的使用
      <br/>
      <br/>
      <br/>
      略，后续会补充一篇文章，全面的解析各个case
      <br/>
      <br/>
      <br/>
      - 7.6 实例12：政府工作报告词云
      <br/>
     </li>
    </ul>
    <p>
    </p>
    <ul>
     <li>
      略
     </li>
    </ul>
    <ul>
     <li>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <h4>
     第八章 程序设计方法学
    </h4>
    <ul>
     <li>
      <p>
       8.1 实例13：体育竞技分析
      </p>
      <ul>
       <li>
        8.1.1 问题分析
        <ul>
         <li>
          需求：毫厘是多少？如何科学分析体育竞技比赛？
         </li>
         <li>
          输入：球员水平
         </li>
         <li>
          输出：可预测的比赛成绩
         </li>
        </ul>
       </li>
       <li>
        8.1.2 模拟N场比赛
        <ul>
         <li>
          计算思维：抽象+自动化
         </li>
         <li>
          模拟：抽象比赛过程+自动化执行N场比赛
         </li>
         <li>
          当N越大，比赛结果分析会越科学
         </li>
        </ul>
       </li>
       <li>
        8.1.3 比赛规则
        <ul>
         <li>
          双人击球比赛：A&amp;B，回合制，5局3胜
         </li>
         <li>
          开始一方先发球，直至判分，接下来胜者发球
         </li>
         <li>
          球员只能在发球局得分，15分胜一局
         </li>
        </ul>
       </li>
       <li>
        8.1.4 自顶向下(设计)和自底向上(执行)
        <ul>
         <li>
          从总到分，分解大问题到计算机能解决的一个个小问题
         </li>
         <li>
          解决复杂问题的有效方法
         </li>
         <li>
          分单元测试，逐步组装，按照自顶向下相反的路径操作，直至系统各部分以组装的思路都经过测试和验证
         </li>
         <li>
          逐步组建复杂系统的有效测试方法
         </li>
        </ul>
       </li>
       <li>
        8.1.5 实例讲解
        <ul>
         <li>
          程序总体框架及步骤
          <ul>
           <li>
            1.&gt; 打印介绍信息
           </li>
           <li>
            2.&gt; 获得程序运行参数：proA，proB，n
           </li>
           <li>
            3.&gt; 利用球员A和B的能力值，模拟n局比赛
           </li>
           <li>
            4.&gt; 输出球员A和B获胜比赛的场次及概率
           </li>
          </ul>
         </li>
         <li>
          第一阶段：printInfo(),getInputs(),simNGames(),printSummary()
         </li>
         <li>
          第二阶段：步骤三模拟N局比赛——再次分解
          <ul>
           <li>
            simOneGame()
           </li>
          </ul>
         </li>
         <li>
          第三阶段：根据分数判断局的结束
          <ul>
           <li>
            gameOver()
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        8.1.6 举一反三
        <ul>
         <li>
          理解自顶向下和自底向上
          <ul>
           <li>
            自顶向下设计：分而治之
           </li>
           <li>
            自底向上执行：模块化集成
           </li>
           <li>
            自顶向下是“系统”思维的简化
           </li>
          </ul>
         </li>
         <li>
          应用问题的扩展
          <ul>
           <li>
            扩展比赛参数，增加对更多能力对比情况的判断
           </li>
           <li>
            扩展比赛设计，增加对真实比赛结果的预测
           </li>
           <li>
            扩展分析逻辑，方向推理，用胜率推算能力
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       8.2 Python程序设计思维
      </p>
      <ul>
       <li>
        8.2.1 计算思维与程序设计
        <ul>
         <li>
          第三种人类思维特征：
          <ul>
           <li>
            逻辑思维：推理和演绎，数学为代表
           </li>
           <li>
            实证思维：实验和验证，物理为代表
           </li>
           <li>
            计算思维：设计和构造，计算机为代表，汉诺塔递归
           </li>
          </ul>
         </li>
         <li>
          计算思维(Computational Thinking)：抽象和自动化
          <ul>
           <li>
            抽象问题的计算过程，利用计算机自动化求解
           </li>
           <li>
            计算思维是基于计算机的思维，工具决定使用方法
           </li>
           <li>
            比如：求和；PI的计算；汉诺塔；天气预报；量化分析交易
           </li>
           <li>
            计算思维基于计算机强大的算力和海量数据
           </li>
           <li>
            抽象计算过程，关注设计和构造，而非因果
           </li>
           <li>
            以计算机程序设计为实现的主要手段
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        8.2.2 计算生态与Python语言
        <ul>
         <li>
          1983，Richard Stallman启动GNU项目
         </li>
         <li>
          1989，GNU通用许可协议诞生
         </li>
         <li>
          1991，Linus Torvalds发布了Linux内核
         </li>
         <li>
          1998，网景浏览器开源，产生了Mozilla
         </li>
         <li>
          1983大教堂模式--&gt;1991，集市模式
         </li>
         <li>
          开源思想深入演化和发展，形成了计算生态
         </li>
         <li>
          竞争发展、相互依存、迅速更迭
         </li>
         <li>
          API != 生态
          <ul>
           <li>
            API：应用程序编写接口，是设计出来的
           </li>
           <li>
            生态：是野蛮生长而竞争淘汰的产物
           </li>
          </ul>
         </li>
         <li>
          计算生态的价值
         </li>
         <li>
          计算生态的应用
          <ul>
           <li>
            编程的起点不是算法而是系统
           </li>
           <li>
            编程的目标是为了快速解决问题
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        8.2.3 用户体验与软件产品
        <ul>
         <li>
          编程只是手段，不是目的，为人类服务是目的
         </li>
         <li>
          提高用户体验的方法
          <ul>
           <li>
            |进度展示(应用场景)|
            <ul>
             <li>
              程序需要计算时间，产生等待
             </li>
             <li>
              若干步骤，需要提示用户并增加进度显示
             </li>
             <li>
              程序存在大量次数循环
             </li>
            </ul>
           </li>
           <li>
            |异常处理(应用场景)|
            <ul>
             <li>
              对用户输入的合规性进行检查
             </li>
             <li>
              读写文件，对结果进行判断
             </li>
             <li>
              当输入输出时，对运算结果进行判断，需要异常处理
             </li>
            </ul>
           </li>
           <li>
            |其他方法(应用场景)|
            <ul>
             <li>
              打印输出：特定位置，输出程序运行的过程信息
             </li>
             <li>
              日志文件：对程序异常和用户使用记录进行定期记录
             </li>
             <li>
              帮助信息，给用户多种方式提供帮助信息
             </li>
            </ul>
           </li>
          </ul>
         </li>
         <li>
          软件程序 ==&gt;&gt; 软件产品：用户体验是关键环节
         </li>
        </ul>
       </li>
       <li>
        8.2.4 基本的程序设计模式
        <ul>
         <li>
          从IPO开始
          <ul>
           <li>
            确定计算部分及功能边界
           </li>
           <li>
            编写程序：将计算求解的设计变成现实
           </li>
           <li>
            调试：确保按照正常逻辑能够正确执行
           </li>
          </ul>
         </li>
         <li>
          自顶向下设计
         </li>
         <li>
          模块化设计
          <ul>
           <li>
            封装，主程序，子程序，分而治之
           </li>
           <li>
            松耦合、紧耦合
           </li>
          </ul>
         </li>
         <li>
          配置化设计
          <ul>
           <li>
            程序引擎 + 配置文件
           </li>
           <li>
            程序执行和配置分离，将可选参数配置化
           </li>
           <li>
            将程序开发变成配置文件编写，扩展功能而不修改程序
           </li>
           <li>
            关键在于接口设计，清晰明了，灵活可扩展
           </li>
          </ul>
         </li>
         <li>
          应用开发的四个步骤：
          <ul>
           <li>
            1.产品定义：功能(需求) + 商业模式
           </li>
           <li>
            2.系统架构：关注数据流+模块化+体系架构
           </li>
           <li>
            3.设计与实现：结合系统架构、结合可扩展性、灵活性等进行设计优化
           </li>
           <li>
            4.用户体验：从用户角度思考应用效果
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       8.3 Python第三方库安装
      </p>
      <ul>
       <li>
        8.3.1 Python世界
        <ul>
         <li>
          <a href="https://pypi.org/" rel="nofollow">
           https://pypi.org/
          </a>
         </li>
         <li>
          PyPI：Python Package Index
         </li>
         <li>
          PSF维护的展示全球Python计算生态的主站
         </li>
         <li>
          学会检索并利用PyPI，关键词检索
         </li>
        </ul>
       </li>
       <li>
        8.3.2 第三方库的pip安装方法
        <ul>
         <li>
          Win+r =&gt;输入cmd回车，进入cmd，pip -h，可以常看常用命令及介绍
         </li>
        </ul>
       </li>
       <li>
        8.3.3 第三方库的集成安装方法
        <ul>
         <li>
          Anaconda —— 数据计算
         </li>
        </ul>
       </li>
       <li>
        8.3.4 第三方库的文件安装方法
        <ul>
         <li>
          某些第三方库pip下载后，需要编译再安装
         </li>
         <li>
          直接下载编译后的安装，推荐一个个人博客：
          <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" rel="nofollow">
           http://www.lfd.uci.edu/~gohlke/pythonlibs/
          </a>
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       8.4 模快7：os库的基本使用
      </p>
      <blockquote>
       <p>
        os库是标准库，包含几百个函数，常用路径操作、进程管理、环境参数等几类
       </p>
      </blockquote>
      <ul>
       <li>
        <p>
         8.4.1 路径操作：os.path子库，处理文件路径及信息
        </p>
        <ul>
         <li>
          import os.path as op
         </li>
         <li>
         </li>
        </ul>
        <table>
         <thead>
          <tr>
           <th style="border-color:#dfe2e5;">
            函数
           </th>
           <th style="border-color:#dfe2e5;">
            描述
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.abspath(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回path在当前系统中的绝对路径
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.normpath(path)
           </td>
           <td style="border-color:#dfe2e5;">
            归一化，统一用\\分隔路径
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.relpath(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回相对路径
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.dirname(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回Path中目录名称
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.basename(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回path中最后的文件名称
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.join(path,*paths)
           </td>
           <td style="border-color:#dfe2e5;">
            组合path，返回路径字符串
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.exists(path)
           </td>
           <td style="border-color:#dfe2e5;">
            判断path对应文件目录是否存在，返回bool
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.isfile(path)
           </td>
           <td style="border-color:#dfe2e5;">
            判断path所对应是否为已存在的文件，返回bool
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.isdir(path)
           </td>
           <td style="border-color:#dfe2e5;">
            判断path所对应是否为已存在的文件，返回bool
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.getatime(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回path对应文件或目录上一次的访问时间
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.getmtime(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回path对应文件或目录最近一次的修改时间
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.getctime(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回path对应文件或目录的创建时间
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.path.getsize(path)
           </td>
           <td style="border-color:#dfe2e5;">
            返回path对应文件的大小，以字节为单位
           </td>
          </tr>
         </tbody>
        </table>
       </li>
       <li>
        <p>
         8.4.2 进程管理：启动系统中其他程序
        </p>
        <ul>
         <li>
          os.system(command)
         </li>
         <li>
          执行程序或命令command
         </li>
         <li>
          在windows系统中，返回值为cmd的调用返回信息
         </li>
         <li>
          eg1: os.system("C:\\windows\\System32\\calc.exe")
         </li>
         <li>
          eg2: os.system(C:\\windows\\System32\\mspaint.exe D:\\pycode\\grwordcloud.png")
         </li>
        </ul>
       </li>
       <li>
        <p>
         8.4.3 环境参数：获得系统软硬件信息等环境参数
        </p>
        <table>
         <thead>
          <tr>
           <th style="border-color:#dfe2e5;">
            函数
           </th>
           <th style="border-color:#dfe2e5;">
            描述
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.chdir(path)
           </td>
           <td style="border-color:#dfe2e5;">
            修改当前程序操作的路径
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.getcwd()
           </td>
           <td style="border-color:#dfe2e5;">
            返回程序的当前路径
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.getlogin()
           </td>
           <td style="border-color:#dfe2e5;">
            获得当前系统登陆用户名
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.cpu_count()
           </td>
           <td style="border-color:#dfe2e5;">
            获得当前系统的CPU数量
           </td>
          </tr>
          <tr>
           <td style="border-color:#dfe2e5;">
            os.urandom(n)
           </td>
           <td style="border-color:#dfe2e5;">
            获得n个字节长度的随机字符串，通常用于加解密运算
           </td>
          </tr>
         </tbody>
        </table>
       </li>
      </ul>
     </li>
     <li>
      <p>
       8.5 实例14：第三方库自动安装脚本
      </p>
      <ul>
       <li>
        8.5.1 问题分析：第三方库自动安装脚本
       </li>
       <li>
        8.5.2 优秀的第三方库 (PyPI搜，略)
       </li>
       <li>
        8.5.3 举一反三：自动化脚本+
        <ul>
         <li>
          编写各类自动化运行程序的脚本，调用已有程序
         </li>
         <li>
          扩展应用：安装更多的第三方库，增加配置文件
         </li>
         <li>
          扩展异常检测：捕获更多异常类型，程序更稳定友好
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f44656661756c7454657374:2f61727469636c652f64657461696c732f3830343538373738" class_="artid" style="display:none">
 </p>
</div>


