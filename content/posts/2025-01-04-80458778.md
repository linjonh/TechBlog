---
arturl_encode: "68747470733a2f2f:626c6f672e6373646e2e6e65742f44656661756c7454657374:2f61727469636c652f64657461696c732f3830343538373738"
layout: post
title: "北京理工大学Python语言程序设计____笔记整理"
date: 2025-01-04 18:55:55 +0800
description: "# 这门课程是我最强烈推荐的python入门课程之一。原因有三：其一，其更加关注编程的思想，极具有启"
keywords: "python语言程序设计"
categories: ['Python']
tags: ['无标签']
artid: "80458778"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=80458778
    alt: "北京理工大学Python语言程序设计____笔记整理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=80458778
featuredImagePreview: https://bing.ee123.net/img/rand?artid=80458778
---

# 北京理工大学：《Python语言程序设计》\_\_\_\_笔记整理

*# 这门课程是我最强烈推荐的python入门课程之一。原因有三：其一，其更加关注编程的思想，极具有启发性；其二，”小“但系统，可扩展性强；其三，有配套线上练习和测试。*

*# 本文将每次更新一个章节，直到课程结束。*

*# 本文从5.28--6.7日，历时11天，基本更新完毕，后面还有两张不属于python基础，后续将以demo的方式进行详细讲解。*

### 

## 第一章：程序设计基本方法

### 计算机与程序设计

```
计算机是根据指令操作数据的设备
计算机发展参照摩尔定律，表现为指数形式
```

### 编译和解释

```
计算机执行源程序两种方式：编译和解释
编译：将源代码一次性转换成目标代码的过程。执行编译过程的程序叫编译器(compiler)。
解释：将原代码逐条转换成目标代码同时逐条运行的过程。执行解释过程的程序叫解释器(interpreter)。
静态语言：使用编译执行的编程语言(C/C++,java)
脚本语言：使用解释执行的编程语言(Python,JavaScript，PHP)
```

### 程序的基本写法

```
IPO：
input输入:文件输入、控制台输入、交互输入、内部参数输入等。
process处理(主要逻辑)：算法（灵魂）
output输出：控制台、文件、网络、操作系统内部变量等输出。
```

### 计算机编程

能够训练思维：

```
编程体现一种抽象交互、自动化执行的思维方式
计算思维：区分逻辑思维和实证思维的第三种思维模式。
```

### 计算机编程

python环境配置

```
略
```

### 实例1 --温度转换

```
题目本身简单，但学会这种思维，其他常见的"转换"问题解决方法同理。
```

### Python程序语法元素分析

程序的格式框架

```
python中用"缩进"表达程序的语法框架，表达代码间包含关系的唯一手段
注释：用于提高代码可读性的辅助文字，不被执行。
```

命名与保留字

```
变量：用来保存和表示数据的占位符号，变量采用标识符（名字）来表示。
命名：数字字母下划线。
"注意"：大小写敏感，数字不能放开头，不与保留字同。
python中共有33个保留字，查询方法：
```
import keyword
print(keyword.kwlist)
```
```

数据类型

```
字符串：由0个或多个字符组成的"有序"字符序列。# 有序-->可以索引、切片
整数：数学中的整数
浮点数：数学中的实数，带有小数点部分
列表：由0个或多个数据组成的"有序"序列
```

语句与函数

```
赋值语句
分支语句
函数
```

Python程序的输入输出

```
input（）控制台输入
print（）控制台输出，格式化
注：这两兄弟，在控制台显示的时候，一个添加引号形成字符串，一个将字符串自动去掉引号。
补充："eval()"去掉参数最外侧引号并执行余下语句的函数
```

温度转换代码分析

```
略
```

## 第二章 Python基本图形绘制

### 2.1 深入理解Python语言

#### 2.1.1计算机技术的演进

```
1946-1981：计算机系统结构时代（35年）：
1981-2008：网络和视窗时代（27年）
2008-2016：复杂信息系统时代（8年）
2016-    ：人工智能时代

计算能力问题-->交互问题-->数据问题-->人类的问题
```

#### 2.1.2编程语言的多样初心

```
C:    性能
Java：跨平台
C++： 大规模程序
VB：  桌面应用
Python：计算时代演进的选择
```

#### Python语言的特点

```
通用语言
脚本语言
开源、跨平台、多模型语言
```

---

```
C/C++：python归python ，c归c
Java：针对特定开发和岗位需求
HTML/CSS/JS：不可替代的前端技术，全栈能力
其他语言： R/Go/Matlab等，特定领域
```

---

```
工具决定思维：关注工具变革的力量！
```

#### 超级语言的诞生

```
机器语言 --> 代码直接执行，与CPU有关
汇编语言 --> 助记符，汇编器，与CPU有关
高级语言 --> 编译器，与CPU无关
超级语言 --> 整合已有程序，庞大计算生态
```

---

== python是唯一的超级语言！ ==

### 2.2 实例2：Python蟒蛇绘制

== import turtle == 导入海归绘图库

"举一反三："

```
Python蟒蛇绘制问题是各类图形绘制问题的代表
--圆形绘制、五角星绘制、国旗绘制、机器猫绘制...
```

### 2.3 模块1：turtle库的调用

#### 2.3.1 turtle库基本介绍

```
--注：turtle库是turtle绘图体系的python实现
--1969年诞生，是python标准库之一，入门级图形绘制函数库
--Python计算生态 = 标准库 + 第三方库
-库Library、包Package、模快Module，统称模块
```

#### 2.3.2 turtle绘图窗体布局

```
 
```

---

```
turltle.setup(width, height, startx, starty)
--注：4个参数后两个可选，不选则默认在窗口的正中间，setup（）不是必须的
```

#### 2.3.3 turtle空间坐标体系

```
--1)绝对坐标：和数学中的坐标系（象限）知识相同
--turtle.goto(x,y)

--2)海龟坐标：后退<-->前进；左侧<-->右侧

--3)空间坐标体系：turtle.bk(d),turtle.fd(d),burtle.circle(r,angle)
```

#### 2.3.4 turtle角度坐标体系

```
--1)绝对角度：0/360,90/-270,180/-180,270/-90
--turtle.seth(angle):改变海龟行进方向，angle为绝对度数，只改变方向不前进。

--2)海龟角度：turtle.left(angle),turtle.right(angle)
```

#### 2.3.5 RGB色彩体系

```
--RGB指 红 蓝 绿 组合
--RGB整数值，小数值
--turtle.colormode(mode),默认小数值
```

### 2.4 turtle程序语法元素分析

#### 2.4.1 库引用和 import

```
import turtle
turtle. 格式：<a>.<b>()
<库名>.<函数名>(<函数参数>)
或 <库别名>.<函数名>(<函数参数>)
```

#### 2.4.2 画笔控制函数

```
penup(),pendown(),pensize(),pencolor()
别名：pu(),pd()
pensize(width) --> 别名：width(width)
pencolor(color) 颜色字符串、rgb值(三个小数值，或 一个元组小数值)
```

#### 2.4.3 运动控制函数

```
fd(),circle(r,extent=None)
--r:默认圆心在海龟左侧r距离的位置
--extent：绘制角度，默认是360度整圆
```

#### 2.4.4 方向控制函数

```
turtle.setheading(angle) 别名： seth(angle)
turtle.left(),turtle.right()
```

## 第三章 基本数据类型

### 3.1 数字类型及操作

```
--3.1.1整数类型：与数学中概念一致，+|-均可，无范围限制
--pow(x,y)函数
--3.1.2 4种进制表示形式：
十进制，二进制(0b,0B开头)，八进制(0o,0O开头)，十六进制(0x,0X)

--3.1.3浮点数类型：浮点数范围和小数精度都存在限制，但常规计算可以忽略
浮点数间运算存在不确定尾数，发生在10E-16左右，不是bug
-- round(x,d):对x四舍五入，d是小数截取位数。用于浮点数间运算及比较。
-- 浮点数采用科学计数法表示<a>e<b>

--3.1.4复数类型：Z.real获得实部，Z.imag获得虚部

--3.1.5数值运算操作符：类型间可以混合运算，生成结果为“最宽”类型。

--数值运算函数：
-- abs(x) 绝对值
-- divmod(x,y) => 同时输出商和余数
-- pow(x,y[,z]) => 幂余，(x**y)%z
-- round(x[,d]) => 四舍五入，d小数位数，默认为0
-- max()最大值
-- min()最小值
-- int(x) 
-- float()
-- complex(x)
```

### 3.2 实例3：天天向上的力量

```
略

- GRIT，坚毅，对长期目标的持续激情及持久耐力
- GRIT是获得成功最重要的因素之一，牢记天天向上的力量
```

### 3.3 字符串类型及操作

#### 3.3.1 字符串类型的表示

```
-- 单引号，双引号；三引号
-- 索引 [M]
-- 切片 [M,N,K]
-- 转义字符：\b回退，\n换行，\r回车（光标移到本行行首）
```

#### 3.3.2 字符串操作符

```
-- + 字符串拼接
-- * 复制n次字符串
-- in
```

#### 3.3.3 字符串处理函数

```
-- len(x)  
-- str(x) 任意类型所对应的字符串形式
-- hex(x)或oct(x) 整数x的十六进制或八进制小写形式字符串
-- chr(u) u为Unicode编码，返回其对应的字符
-- ord(x) x为字符，返回其对应的Unicode编码
```

#### 3.3.4 字符串处理方法

```
-- S.lower()或S.upper() 返回字符串副本，全部字符小写/大写
-- S.split(sep=None) 返回一个列表，由str根据sep被分隔部分组成
-- S.count(sub) 返回子字符串sub在str中出现的次数
-- S.replace(old,new)
-- S.center(width[,fillchar])
-- S.strip(chars)从str中去掉在其左侧和右侧chars中列出的字符。
-- S.join(iter) 在iter变量除最后元素外每个元素增加一个S。例如：','.join("12345")  #主要用于字符串分割
```

#### 3.3.5 字符串类型的格式化

```
"{<参数序号>:<格式控制标记>}"

：<填充><对齐><宽度><,><.精度><类型>
```

### 3.4 模块2：time库的使用

#### 3.4.1 time库的基本介绍

```
时间获取：time() ctime() gmtime()
时间格式化： strftime() strptime()
程序计时：sleep(),perf_counter()
```

#### 3.4.2 时间获取

```
.time() 获取当前时间戳，即计算计算机内部时间值，浮点数。

.ctime()获取当前时间并以易读方式表示，返回字符串

.gmtime()获取当前时间，表示为计算机可处理的时间格式
```

#### 3.4.3 时间格式化

```
.strftime(tpl,ts) : tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量
t = time.gmtime()
time.strftime("%Y-%m-%d %H:%M:%S", t)

```

```


t = time.gmtime()
time.strftime("%Y-%m-%d %H:%M:%S", t)

timeStr = "2018-01-26 12:55:20"
time.strptime(timeStr,"%Y-%m-%d %H:%M:%S")
```

#### 3.4.4 程序计时应用

```
start = time.perf_counter()
end = time.perf_counter()
end - start

sleep(s) s拟休眠时间，单位是秒，可以是浮点数
```

### 3.5 实例4：文本进度条

```
这里理解一个重要的系统概念:刷新
本质：用后打印的字符串覆盖之前的字符串。不能换行(end=)，要能回退\r
```

```
# TextProBarV3.py
import time
scale = 50
print("执行开始")
start = time.perf_counter()
for i in range(scale + 1):
    a = "*" * i 
    b = "." * (scale - i)
    c = (i / scale) * 100
    dur = time.perf_counter() - start
    print("\r{:^3.0f}%[{}->{}]{:.2f}s".format(c, a, b, dur), end="")
    time.sleep(0.1)
print("\n" + "执行结束".center(scale // 2, "-"))
```

## 第四章 程序的控制结构

### 4.1 程序的分支结构

```
“程序的控制结构”：顺序结构、分支结构、循环结构
```

---

#### 4.1.1 单分支结构

```
语法： if <条件>:
         <语句块>
```

#### 4.1.2 二分支结构

```
语法： if <条件>:
         <语句块1>
        else:
         <语句块2>
         
紧凑形式：适用于简单表达式的二分支结构
<表达式1> if <条件> else <表达式2>
```

#### 4.1.3 多分支结构

```
语法：if <条件1>:
         <语句块1>
      elif <条件2>：
          <语句2>
          ...
        else:
         <语句块N>
```

*注： 注意多条件之间的包含关系，注意变量取值范围的覆盖。 通俗点： 多分支结构中，如果一个分支判断条件通过后，会执行对应的语句块，之后结束分支程序。即使，后续的elif条件也满足，也不会执行对应的语句块.所以这里其实也有一个顺序关系。*

#### 4.1.4 条件判断及组合

```
--条件判断操作符：<,<=,>=,>,==,!=

--条件组合三个保留字：and,or,not
```

#### 4.1.5 程序的异常处理

```
try:
    <语句块1>
except [<异常类型>]：
    <语句块2>
注：标注异常类型后，仅响应该异常，异常类型名字等同于变量。
```

---

```
高级使用：

try:
    <语句块1>
except:
    <语句块2>
else:           # 不发生异常的时候执行(奖励)
    <语句块3>
finally:        # 一定会执行
    <语句块4>
```

### 4.2 实例5：身体质量指数BMI

```
BMI = 体重(Kg)/身高^2(m^2)
略
```

---

```
注：阅读代码的时候，快速的方法是：先搞懂分支的范围关系，再深入看每个分支在做什么。而不是从上到下的顺序结构。
```

### 4.3 程序的循环结构

###4.3.1 遍历循环

```
for <循环变量> in <遍历结构>:
    <语句块>
--从遍历结构中逐一提取元素，放在循环变量中。
--完整遍历所有元素后结束
--每次循环，所获得元素放入循环变量，并执行一次语句块

应用：计数循环、字符串遍历循环、列表遍历循环、文件遍历循环、等等
```

#### 4.3.2 无限循环

```
while <条件>:
    <语句块>
```

#### 4.3.3 循环控制保留字

```
-break 跳出并结束当前循环，执行循环后的语句

-continue 结束当次循环，继续执行后续次数循环

--break和continue可以与for和while循环搭配使用。
```

#### 4.3.4 循环的高级用法

```
循环中增加else:       
            <语句块2>

--当循环没有被break语句退出时，执行else语句块
--else语句块作为“正常”完成循环的奖励
--这里else的用法与异常处理中else用法相似
```

### 4.4 模块3：random库的使用

#### 4.4.1 random 标准库之一

```
--伪随机数：采用梅森旋转算法生成的(伪)随机序列中元素
--random库主要用于生成随机数
```

#### 4.4.2 基本随机函数

```
seed(a=None) --初始化给定的随机数种子，默认为当前系统时间
--random.seed(10)  # 产生种子10对应的序列
--这个在实战中用的比较多，“确定”的伪随机数便于对程序进行复现。

random()
--生成一个[0.0，1.0)之间的随机小数
--random.random()
```

#### 4.4.3 扩展随机数函数

```
>1. randint(a,b) 生成[a,b]之间的整数

>2. randrange(m,n[,k]) 生成一个[m,n)之间以k为步长的随机整数

>3. getrandbits(k) 生成一个k比特长的随机整数

>4. uniform(a,b) 生成一个[a,b]之间的随机小数

>5. choice(seq) 从序列seq中随机选择一个元素

>6. shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列
```

### 4.5 实例6：圆周率的计算

#### 4.5.1 蒙特卡洛方法

```
from random import random
from time import perf_counter
DARTS = 1000 * 1000
hits = 0.0
start = perf_counter()
for i in range(1, DARTS+1):
    x, y = random(), random()
    dist = pow(x ** 2 + y ** 2, 0.5)
    if dist <= 1.0:
        hits += 1
pi = 4 * (hits / DARTS)
print("圆周率是：{}".format(pi))
print("运行时间是：{:.5f}s".format(perf_counter() - start))
```

### 第五章：函数的定义与使用

#### 5.1.1 函数的理解和定义

```
函数是一段具有特定功能、可重用的语句组
降低编程难度 和 代码复用

def <函数名>(<参数(0个或多个)>)：
    <函数体>
    return <返回值>

不调用不会被执行
```

#### 5.1.2 函数的使用及调用过程

```
调用是运行函数代码的方式
-调用时给出实际参数，替代定义中的形式参数
-函数调用得到返回值
```

#### 5.1.3 函数的参数传递

```
-- 参数的个数：0，1，或多个。但是必须保留括号

-- 可变数量参数，既不确定参数总数量

-- 传递参数两种方式：位置参数，名称传递
```

#### 5.1.4 函数的返回值

```
-- return 保留字用来传递返回值
-- 可以传，可以不传，可以传递0个，也可以传多个
```

#### 5.1.5 局部变量和全局变量

```
-- (一般函数外部是全局变量，函数内部的变量是局部变量)

规则一：局部变量和全局变量是不同变量
--局部变量是函数内部的占位符，与全局变量可能重名但不同
--函数运算结束后，局部变量被释放
--可以用 global保留字在函数内部使用全局变量
(这里还分可变类型和不可变类型)

规则二：局部变量为组合数据类型且未创建，等同于全局变量

使用规则：
-基本数据类型，无论是否重名，局部变量与全局变量不同
-可以通过global保留字在函数内部声明全局变量
-组合数据类型，如果局部变量未真实创建，则是全局变量
```

#### 5.1.6 lambda函数

```
无名，保留字，函数名是返回结果

<函数名> = lambda <参数>:<表达式>

--主要作用  特定函数或方法  的参数
-- 固定使用方式，逐步积累掌握
-- 一般情况，用def定义普通函数，慎用lambda
```

### 5.2 七段数码管 绘制

#### 5.2.1 基本思路

```
--1. 绘制单个数字对应的数码管
--2. 获得一串数字，绘制对应的数码管
--3. 获得当前系统时间，绘制对应的数码管
```

* 分析单个数码管：

  + 七段数码管由7个基本线条组成
  + 七段数码管可以有固定顺序(抽象出一条可以首尾相连且不重不漏的路径)
  + 不同数字显示不同的线条(通过pu，pd控制)
* 获取一段数字，绘制多个数码管：

  + 每绘制完一个数字，向右移动一段距离，准备下一个数字的绘制
* 获取当前系统时间：

  + time库
  + 增加年月日标记： write 方法
  + 年月日颜色不同标记
  + 线条之间适当小间隔，提高颜值

#### 5.2.2 理解思维方法

* 模块化思维：确定模块接口，封装功能
* 规则化思维：抽象过程为规则，计算机自动执行
* 化繁为简：将大功能变为小功能，分而治之(松耦合，紧耦合)

#### 5.2.3 举一反三

* 绘制带小数点的七段数码管
* 带刷新的时间倒计时效果
* 绘制高级的数码管(多段)

### 5.3 代码复用与函数递归

#### 5.3.1 代码复用与模块化设计

* 代码复用：把代码当成资源进行抽象
* 代码复用：|函数|和|对象|是代码复用的两种主要形式
  + 函数：(将代码命名)：在代码层面建立了初步抽象
  + 对象：(属性和方法):在函数基础上再次组织进行抽象
* 模块化设计：分而治之
* 模块化设计：紧耦合、松耦合

#### 5.3.2 函数递归的理解

* 定义：函数定义中调用函数自身的方式
* 两个关键特征：
  + 链条：计算过程存在递归链条
  + 基例：存在一个或多个不需要再次递归的基例
* 类似数学归纳法：递归是数学归纳法思维的编程体现

#### 5.3.3 函数递归的调用过程

* 递归的实现：函数+分支语句
  + 递归本身是一个函数，需要函数定义方式的描述
  + 函数内部，采用分支语句对输入参数进行判断
  + 基例和链条，分别编写对应的代码

#### 5.3.4 函数递归实例解析

* 字符串反转
* 斐波那契数列
* 汉诺塔 PS：学会找到基例和链条

### 5.4 模块：PyInstaller库的使用

#### 5.4.1 概述

* 将.py源码转换成无需源代码的可执行文件
* 在命令窗口输入后回车可以查看对应的方法参数帮助
* 要配置Path，关闭后再开cmd窗口

### 实例8：科赫雪花小包裹

```
PS：分形几何，自然界常见
```

* 基本方法：
  + 递归思想：函数+分支
  + 递归链条：线段的组合
  + 递归基例：初识线段
* 运用 PyInstaller库
* 举一反三
  + 修改分形几何绘制阶数
  + 修改科赫曲线的基本定义及旋转角度
  + 修改绘制科赫雪花的基础框架图形
* 分形几何扩展：
  + 康托尔集、谢尔宾斯基三角、门格海绵...
  + 龙形曲线、空间填充曲线、科赫曲线...
  + 函数递归的深入应用...

第六章 组合数据类型

#### 6.1 集合类型及操作

* 6.1.1 集合类型定义
  + 与数学中概念一致
  + 集合元素之间无序，每个元素之间唯一，不存在相同元素
  + 集合元素不可更改，不能是可变数据类型(为什么？集合定义：元素唯一不重复)
  + 集合建立用{}表示，元素逗号分隔
  + 建立集合用{}或set()
  + 建立空集合必须是set()：因为Python中字典类型使用更多，所以{}给了建立空字典
* 6.1.2 集合间操作
  + S | T 并
  + S - T 差
  + S & T 交
  + S ^ T 补 PS：上述四种操作均返回一个新集合
  + S <= T 或 S < T : 返回True/False，判断S和T的子集关系
  + S >= T 或 S > T : 返回True/False，判断S和T的包含关系
  + S|=T 更新集合S，包括在集合S和T中的所有元素
  + S-=T 更新集合S，包括在集合S但不在集合T中的元素
  + S&=T 更新集合S，包括同时在集合S和T中的元素
  + S^=T 更新集合S，包括集合S和T中的非相同元素
  + 操作函数或操作方法：
    - S.add(x) 如果X不在集合S中，将X增加到S
    - S.discard(x) 移除S中的元素X，如果x不在S中，不报错
    - S.remove(x) 移除S中元素X，如果x不在S中，产生KeyError异常
    - S.clear() 移除S中所有元素
    - S.pop() 随机返回S的一个元素，更新S，若S为[空]产生KeyError异常
    - S.copy() 返回集合S的一个副本
    - len(S)
    - x in S
    - x not in S
    - set(x) 其他变量转变为集合类型
* 6.1.3 集合类型应用场景
  + 包含关系比较
  + 数据去重

#### 6.2 序列类型及操作

* 6.2.1 定义

  + 序列是具有先后关系的一组元素
    - 序列是一维元素向量，元素类型可以不同
    - 元素间由序号引导，通过下标访问序列的特定元素
  + 序列是一个基类类型
    - 字符串、元组、列表
  + 序号：反向递减，正向递增
* 6.2.2 函数和方法

  + 通用操作符(6个)
    - in
    - not in
    - "+" ：拼接
    - "\*" : 复制
    - s[i] : 索引
    - s[i:j:k] : 切片
  + 函数和方法(5个)
    - len(s)
    - min(s)
    - max(s)
    - s.index(x[,i,j])
    - s.count(x)
* 6.2.3 元组类型及操作

  + 元组是序列类型的一种扩展
    - 不可修改
    - ()或tuple()创建，元素间逗号分隔
    - 可以使用或不用()
    - 特殊：单个元组，元素后面要加逗号
  + 元组继承序列类型全部通用操作符
    - 创建后不可修改，所以没有特殊操作
* 6.2.4 列表类型及操作

  + 序列类型的一种扩展
    - 创建后可以随意被修改
    - []或list()创建，元素间逗号分隔
    - 列表中各元素类型可以不同，无长度限制
  + 定义:方括号[]真正创建一个列表，赋值仅传递引用（贴标签）
  + 函数和方法
    - ls[i] = x 修改
    - ls[i:j:k] = lt lt替换ls切片后所对应元素子列表
    - del ls[i] 删除第i个元素
    - del ls[i:j:k]
    - ls += lt 更新列表ls，将lt元素增加到ls中。这里有个特殊点提一下：这里的操作不会重新开辟内存空间，本质上相当于ls.extend(lt)。
    - ls \*= n 更新列表ls，重复n次
    - ls.append(x) 列表后面追加x
    - ls.clear() 删除所有元素
    - ls.copy() 生成一个新列表，赋值ls中所有元素
    - ls.insert(i,x) 索引i的位置插入元素x
    - ls.pop(i) 取出索引为i对应的元素并将它从列表中删除，默认i=-1
    - ls.remove(x) 列表中出现的第一个x元素删除
    - ls.reverse() 列表中元素反转
* 6.2.5 序列类型应用场景

  + 元素遍历：ls、tp
  + 数据保护：tp

#### 6.3 实例9：基本统计值计算

* 6.3.1 基本统计值计算 ——问题分析
  + 总个数、求和、平均值、方差、中位数……
  + len()
  + for in 求和
  + 均值：求和/总个数
  + 方差： pow()函数
  + 中位数：排序，然后……
* 6.3.2 实例讲解
  + 略
* 6.3.3 举一反三
  + 获取数据，控制台获取，多参数
  + 函数：模块化设计
  + 利用BIF函数

#### 6.4 字典类型及操作

* 6.4.1 定义

  + 理解"映射",key:value对
  + list、tuple、str等序列类型是由python内部默认由0...N整数作为数据的默认索引
  + 映射类型则由用户为数据定义索引
  + 键(key)是数据索引的扩展
  + 字典是键值对的集合，键值对之间无序
  + 采用{}和dict()创建，键值对用冒号表示
  + []用来向字典变量中索引或增加元素
* 函数和方法

  + del d[k] 删除键k对应的键值对
  + k in d[k] 判断键是否在字典中
  + d.keys() 返回字典中所有键的信息，类似集合形式
  + d.values() 返回字典中所有值的信息，类似集合形式
  + d.items() 返回字典中所有键值对的信息，类似集合形式，键值对是以元组形式
  + d.get(k,<default>) 键k存在，返回对应的值，否则返回<default>值
  + d.pop(k,<default>) 键k存在，取出对应的值，否则返回<default>值
  + d.popitem() 随机从字典中取出一个键值对，以元组形式返回
  + d.clear() 删除所有键值对
  + len(d) 返回字典中键值对的个数
* 应用场景

  + 统计数据出现的次数，数据是键，次数是值

#### 6.5 模块5：jieba库的使用

* 6.5.1 jieba库是优秀的中文分词第三方库
  + pip安装
  + 原理：依靠中文词库，通过汉字之间的关联概率判断，用户可以自定义添加特殊的分词词组，运用于特地的领域
  + 三种分词模式
    - 精确模式：精确分开，不存在冗余单词
    - 全模式：所有可能词语扫描出来，有冗余
    - 搜索引擎模式：精确模式基础上，对长词进行再次切分
  + 常用函数：
    - jieba.lcut(s) 精确模式
    - jieba.lcut(s,cut\_all=True) 全模式
    - jieba.lcut\_for\_search(s) 搜索引擎模式，返回列表类型的分词结果，存冗余
    - jieba.add\_word(w) 向分词添加新词

#### 6.6 实例10：文本词频统计

```
略
```

### 第七章 文件和数据格式化

#### 7.1 文件的使用

* 7.1.1 文件的类型

  + 文件是数据的抽象和集合
    - 文件是存储在辅助存储器上的[数据序列]
    - 文件是数据存储的一种形式
    - 文件展现形态：文本文件和二进制文件
  + 文本文件 VS 二进制文件
    - 文本文件和二进制文件只是文件的展示方法
    - 本质上：所有文件都是二进制形式存储
    - 形式上，所有文件采用两种方式展示
  + 文本文件：
    - 由单一特定编码组成的文件，如UTF-8编码
    - 由于存在编码，也被看成是存储着的长字符串
    - 例如：.txt ， .py文件等
  + 二进制文件：
    - 直接由比特0、1组成，没有统一字符编码
    - 一般存在二进制0，1的组织结构，即文件格式
    - 例如：png、avi等
* 7.1.2 文件打开和关闭

  + 文件处理的步骤：打开——操作——关闭

文件的存储状态文件的占用状态a = opne( , )a.close()文件的存储状态文件的占用状态

* + 读文件：3种方法 VS 写文件： 3种方法 -文件的打开： <变量名> = open(<文件名>，<打开模式>)

    变量名：文件句柄

    文件名：文件路径和名称(源文件同目录可省略)

    打开模式：文本or二进制；读or写

    补充：windows下，文件目录之间用\，这个和python冲突，解决方式两种：\\，或者用/ .

    打开模式：

| 文件打开模式 | 描述 |
| --- | --- |
| "r" | 只读模式，默认值，若文件不存在，返回FileNotFoundError |
| "w" | 覆盖写模式，文件不存在则创建，存在则完全覆盖 |
| "x" | 创建写模式，文件不存在则创建，存在则返回FileExistsError |
| "a" | 追加写模式，文件不存在则创建，存在则在文件最后追加内容 |
| "b" | 二进制文件模式 |
| "t" | 文本文件模式，默认值 |
| "+" | 与r/w/x/a一同使用，在原功能基础上增加同时读写功能 |

```
文件关闭：变量名.close()
```

* 7.1.3 文件内容的读取

  | 操作方法 | 描述 |
  | --- | --- |
  | <f>.read(size=-1) | 读入全部内容，如果给出参数，读入前size长度 |
  | <f>.readline(size=-1) | 读入一行内容，如果给出参数，读入该行前size长度，每读取一行指针移动到下一行的行首。 |
  | <f>.readlines(hint=-1) | 读入文件所有行，以每行为元素形成列表。如果给出参数，读入前hint行。 |
* + 文件的全文本操作
    - 遍历全文本：方法一：一次读入read，统一处理
    - 遍历全文本：方法二：按数量读入，逐步处理

    ```
    fo = open(filename,"r")
    txt = fo.read(2)
    while txt != "":
        # 对txt进行处理
        txt = fo.read(2)
    fo.close()

    ```
  + 文件的逐行操作
    - 逐行遍历文件：方法一:一次读入，分行处理。缺点：对于大文件读取速度慢

    ```
    fo = open(filename,"r")
    for line in fo.readlines():
        print(line)
    fo.close()

    ```

    - 逐行遍历文件：方法二:分行读入，逐行处理。优点：大文件处理速度块

    ```
    fo = open(filename,"r")
    for line in fo: # 通过迭代器访问
        print(line)
    fo.close()

    ```

* 7.1.4 数据的文件写入

| 操作方法 | 描述 |
| --- | --- |
| <f>.write(s) | 向文件写入一个字符串或字节流 |
| <f>.writelines(lines) | 将一个元素全为字符串的列表写入文件 |
| <f>.seek(offset) | 改变当前文件操作指针的位置，offset含义如下：0 - 文件开头；1 - 当前位置；2 - 文件结尾 |

```
fo = open("output.txt", "w+")
ls = ["中国", "法国", "美国"]
fo.writelines(ls)
fo.seek(0)  # 否则，没有结果输出
for line in fo:
    print(line)
fo.close()

```

#### 7.2 实例11：自动化轨迹绘制

* 7.2.1 问题分析

  + 需求：根据脚本来绘制图形？
  + 不是写代码而是写数据绘制轨迹
  + 数据脚本是自动化最重要的第一步
* 7.2.2 实例讲解

  + 基本思路：
    - 步骤1：定义数据文件格式(接口)：个性化
    - 步骤2：编写程序，根据文件接口解析参数绘制图形
    - 步骤3：编制数据文件
* 7.2.3 举一反三

  + 理解方法思维
    - 自动化思维：数据和功能分离，数据驱动的自动运行
    - 接口化设计：格式化设计接口，清晰明了
    - 二维数据应用：应用维度组织数据，二维数据最常用
  + 应用问题扩展：
    - 扩展接口设计，增加更多控制接口
    - 扩展功能设计,增加弧形等更多功能
    - 扩展应用需求，发展自动轨迹绘制到动画绘制
* 7.3 一维数据的格式化和处理

  + 7.3.1 数据组织的维度：组织形式

    - 一维数据：
      * 由对等关系的有序或无序数据构成，采用线性方式组织
      * 对应列表、数组和集合等概念
    - 二维数据：
      * 由多个一维数据构成，是一维数据的组合形式
      * 表格是典型的二维数据，其中，表头是二维数据的一部分
    - 多维数据
      * 由一维或二维数据在新维度上扩展形成
      * 比如，加入时间维度
    - 高维数据
      * 仅利用组基本的二元关系展示数据间的复杂结构
      * 比如，字典嵌套
    - 数据的操作周期：
      * 存储<->表示<->操作
  + 一维数据的表示

    - 如果数据间有序：列表，for遍历
    - 如果数据间无序：集合，for遍历
  + 一维数据的存储

    - 存储方式一：空格分隔
      * 使用一个或多个空格分隔进行存储，不换行
      * 缺点：数据中不能存在空格
    - 存储方式二：逗号分隔
      * 使用英文半角逗号分隔数据进行存储，不换行
      * 缺点：数据中不能有英文逗号
    - 存储方式三：其他方式，特殊字符
      * 使用其他符号或符号组合分隔，建议采用特殊符号
      * 缺点：需要根据数据特点定义，通用性较差
  + 一维数据的处理

    - 将存储的数据读入程序
      * split方法
    - 将程序表示的数据写入文件
      * join(ls) 方法
* 7.4 二维数据的格式化和处理

  + 7.4.1 二维数据的表示
    - list类型：二维列表
      * 使用两层for遍历
      * 外层列表中每个元素可以对应一行，也可以对应一列
  + 7.4.2 CSV格式与二维数据存储
    - 注：CSV：Comma-Separated Values
    - 国际通用的一二维数据存储格式，后缀：.csv
    - 每行一个一维数据，采用逗号分隔，无空行
    - Excel可读入输出，一般编辑软件都可以产生
    - 如果某个元素缺失，逗号仍要保留
    - 二维数据的表头可以作为数据存储，也可以另行存储
    - 逗号为英文半角逗号，逗号与数据之间无额外空格
  + 7.4.3 二维数据的存储
    - 按行、列存储都可以
    - 一般习惯：ls[row][column],先行后列
    - 根据一般习惯，按行存
  + 7.4.4 二维数据的处理
    - 读入处理：

      ```
      fo = open(filename)
      ls = []
      for line in fo:
        line = line.replace("\n", "")
        ls.append(line.split(","))
      fo.close()

      ```
    - 写入处理：

      ```
      ls = [[], [], []]  # 二维列表
      f = open(fname, "w")
      for item in ls:
          f.write(",".join(item) + "\n")
      f.close()

      ```
    - 二维数据的逐一处理
      * 采用二层循环

      ```
      ls = [[], [], []]  #二维列表
      for row in ls:
        for cloumn in row:
            print(ls[row][column])

      ```
* - 7.5 模块6：wordcloud库的使用
    
    
    
  略，后续会补充一篇文章，全面的解析各个case
    
    
    
  - 7.6 实例12：政府工作报告词云

* 略



#### 第八章 程序设计方法学

* 8.1 实例13：体育竞技分析

  + 8.1.1 问题分析
    - 需求：毫厘是多少？如何科学分析体育竞技比赛？
    - 输入：球员水平
    - 输出：可预测的比赛成绩
  + 8.1.2 模拟N场比赛
    - 计算思维：抽象+自动化
    - 模拟：抽象比赛过程+自动化执行N场比赛
    - 当N越大，比赛结果分析会越科学
  + 8.1.3 比赛规则
    - 双人击球比赛：A&B，回合制，5局3胜
    - 开始一方先发球，直至判分，接下来胜者发球
    - 球员只能在发球局得分，15分胜一局
  + 8.1.4 自顶向下(设计)和自底向上(执行)
    - 从总到分，分解大问题到计算机能解决的一个个小问题
    - 解决复杂问题的有效方法
    - 分单元测试，逐步组装，按照自顶向下相反的路径操作，直至系统各部分以组装的思路都经过测试和验证
    - 逐步组建复杂系统的有效测试方法
  + 8.1.5 实例讲解
    - 程序总体框架及步骤
      * 1.> 打印介绍信息
      * 2.> 获得程序运行参数：proA，proB，n
      * 3.> 利用球员A和B的能力值，模拟n局比赛
      * 4.> 输出球员A和B获胜比赛的场次及概率
    - 第一阶段：printInfo(),getInputs(),simNGames(),printSummary()
    - 第二阶段：步骤三模拟N局比赛——再次分解
      * simOneGame()
    - 第三阶段：根据分数判断局的结束
      * gameOver()
  + 8.1.6 举一反三
    - 理解自顶向下和自底向上
      * 自顶向下设计：分而治之
      * 自底向上执行：模块化集成
      * 自顶向下是“系统”思维的简化
    - 应用问题的扩展
      * 扩展比赛参数，增加对更多能力对比情况的判断
      * 扩展比赛设计，增加对真实比赛结果的预测
      * 扩展分析逻辑，方向推理，用胜率推算能力
* 8.2 Python程序设计思维

  + 8.2.1 计算思维与程序设计
    - 第三种人类思维特征：
      * 逻辑思维：推理和演绎，数学为代表
      * 实证思维：实验和验证，物理为代表
      * 计算思维：设计和构造，计算机为代表，汉诺塔递归
    - 计算思维(Computational Thinking)：抽象和自动化
      * 抽象问题的计算过程，利用计算机自动化求解
      * 计算思维是基于计算机的思维，工具决定使用方法
      * 比如：求和；PI的计算；汉诺塔；天气预报；量化分析交易
      * 计算思维基于计算机强大的算力和海量数据
      * 抽象计算过程，关注设计和构造，而非因果
      * 以计算机程序设计为实现的主要手段
  + 8.2.2 计算生态与Python语言
    - 1983，Richard Stallman启动GNU项目
    - 1989，GNU通用许可协议诞生
    - 1991，Linus Torvalds发布了Linux内核
    - 1998，网景浏览器开源，产生了Mozilla
    - 1983大教堂模式-->1991，集市模式
    - 开源思想深入演化和发展，形成了计算生态
    - 竞争发展、相互依存、迅速更迭
    - API != 生态
      * API：应用程序编写接口，是设计出来的
      * 生态：是野蛮生长而竞争淘汰的产物
    - 计算生态的价值
    - 计算生态的应用
      * 编程的起点不是算法而是系统
      * 编程的目标是为了快速解决问题
  + 8.2.3 用户体验与软件产品
    - 编程只是手段，不是目的，为人类服务是目的
    - 提高用户体验的方法
      * |进度展示(应用场景)|
        + 程序需要计算时间，产生等待
        + 若干步骤，需要提示用户并增加进度显示
        + 程序存在大量次数循环
      * |异常处理(应用场景)|
        + 对用户输入的合规性进行检查
        + 读写文件，对结果进行判断
        + 当输入输出时，对运算结果进行判断，需要异常处理
      * |其他方法(应用场景)|
        + 打印输出：特定位置，输出程序运行的过程信息
        + 日志文件：对程序异常和用户使用记录进行定期记录
        + 帮助信息，给用户多种方式提供帮助信息
    - 软件程序 ==>> 软件产品：用户体验是关键环节
  + 8.2.4 基本的程序设计模式
    - 从IPO开始
      * 确定计算部分及功能边界
      * 编写程序：将计算求解的设计变成现实
      * 调试：确保按照正常逻辑能够正确执行
    - 自顶向下设计
    - 模块化设计
      * 封装，主程序，子程序，分而治之
      * 松耦合、紧耦合
    - 配置化设计
      * 程序引擎 + 配置文件
      * 程序执行和配置分离，将可选参数配置化
      * 将程序开发变成配置文件编写，扩展功能而不修改程序
      * 关键在于接口设计，清晰明了，灵活可扩展
    - 应用开发的四个步骤：
      * 1.产品定义：功能(需求) + 商业模式
      * 2.系统架构：关注数据流+模块化+体系架构
      * 3.设计与实现：结合系统架构、结合可扩展性、灵活性等进行设计优化
      * 4.用户体验：从用户角度思考应用效果
* 8.3 Python第三方库安装

  + 8.3.1 Python世界
    - <https://pypi.org/>
    - PyPI：Python Package Index
    - PSF维护的展示全球Python计算生态的主站
    - 学会检索并利用PyPI，关键词检索
  + 8.3.2 第三方库的pip安装方法
    - Win+r =>输入cmd回车，进入cmd，pip -h，可以常看常用命令及介绍
  + 8.3.3 第三方库的集成安装方法
    - Anaconda —— 数据计算
  + 8.3.4 第三方库的文件安装方法
    - 某些第三方库pip下载后，需要编译再安装
    - 直接下载编译后的安装，推荐一个个人博客：
      <http://www.lfd.uci.edu/~gohlke/pythonlibs/>
* 8.4 模快7：os库的基本使用

  > os库是标准库，包含几百个函数，常用路径操作、进程管理、环境参数等几类

  + 8.4.1 路径操作：os.path子库，处理文件路径及信息

    - import os.path as op

    | 函数 | 描述 |
    | --- | --- |
    | os.path.abspath(path) | 返回path在当前系统中的绝对路径 |
    | os.path.normpath(path) | 归一化，统一用\\分隔路径 |
    | os.path.relpath(path) | 返回相对路径 |
    | os.path.dirname(path) | 返回Path中目录名称 |
    | os.path.basename(path) | 返回path中最后的文件名称 |
    | os.path.join(path,\*paths) | 组合path，返回路径字符串 |
    | os.path.exists(path) | 判断path对应文件目录是否存在，返回bool |
    | os.path.isfile(path) | 判断path所对应是否为已存在的文件，返回bool |
    | os.path.isdir(path) | 判断path所对应是否为已存在的文件，返回bool |
    | os.path.getatime(path) | 返回path对应文件或目录上一次的访问时间 |
    | os.path.getmtime(path) | 返回path对应文件或目录最近一次的修改时间 |
    | os.path.getctime(path) | 返回path对应文件或目录的创建时间 |
    | os.path.getsize(path) | 返回path对应文件的大小，以字节为单位 |
  + 8.4.2 进程管理：启动系统中其他程序

    - os.system(command)
    - 执行程序或命令command
    - 在windows系统中，返回值为cmd的调用返回信息
    - eg1: os.system("C:\\windows\\System32\\calc.exe")
    - eg2: os.system(C:\\windows\\System32\\mspaint.exe D:\\pycode\\grwordcloud.png")
  + 8.4.3 环境参数：获得系统软硬件信息等环境参数

    | 函数 | 描述 |
    | --- | --- |
    | os.chdir(path) | 修改当前程序操作的路径 |
    | os.getcwd() | 返回程序的当前路径 |
    | os.getlogin() | 获得当前系统登陆用户名 |
    | os.cpu\_count() | 获得当前系统的CPU数量 |
    | os.urandom(n) | 获得n个字节长度的随机字符串，通常用于加解密运算 |
* 8.5 实例14：第三方库自动安装脚本

  + 8.5.1 问题分析：第三方库自动安装脚本
  + 8.5.2 优秀的第三方库 (PyPI搜，略)
  + 8.5.3 举一反三：自动化脚本+
    - 编写各类自动化运行程序的脚本，调用已有程序
    - 扩展应用：安装更多的第三方库，增加配置文件
    - 扩展异常检测：捕获更多异常类型，程序更稳定友好