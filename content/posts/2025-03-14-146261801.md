---
layout: post
title: "C语言学习笔记-进阶16编译和连接"
date: 2025-03-14 17:21:49 +0800
description: "在ANSI C的任何⼀种实现中，存在两个不同的环境。第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。第2种是执行环境，它用于实际执行代码。"
keywords: "C语言学习笔记-进阶（16）编译和连接"
categories: ['未分类']
tags: ['笔记', '学习']
artid: "146261801"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146261801
    alt: "C语言学习笔记-进阶16编译和连接"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146261801
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146261801
cover: https://bing.ee123.net/img/rand?artid=146261801
image: https://bing.ee123.net/img/rand?artid=146261801
img: https://bing.ee123.net/img/rand?artid=146261801
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言学习笔记-进阶（16）编译和连接
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1. 翻译环境和运行环境
    </h2>
    <p>
     <span style="color:#1f2329">
      在ANSI C的任何⼀种实现中，存在两个不同的环境。
     </span>
    </p>
    <p>
     <span style="color:#646a73">
      第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
     </span>
    </p>
    <p>
     <span style="color:#646a73">
      第2种是执行环境，它用于实际执行代码。
     </span>
    </p>
    <p>
     <img alt="" height="1144" src="https://i-blog.csdnimg.cn/direct/703ca2bfb62c4aacb6ebd42b150a3b41.png" width="2864"/>
    </p>
    <h2>
     2. 翻译环境：预编译+编译+汇编+链接
    </h2>
    <p>
     <span style="color:#1f2329">
      那翻译环境是怎么将源代码转换为可执行的机器指令的呢？这里我们就得展开开讲解一下翻译环境所做的事情。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      其实翻译环境是由
      <strong>
       编译
      </strong>
      和
      <strong>
       链接
      </strong>
      两个大的过程组成的，而
      <strong>
       编译
      </strong>
      又可以分解成：预处理（有些书也叫预编译）、编译、汇编三个过程。
     </span>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#1f2329">
      一个C语言的项目中可能有多个
     </span>
     <span style="color:#1f2329">
      .c 文
     </span>
     <span style="color:#1f2329">
      件一起构建，那多个
     </span>
     <span style="color:#1f2329">
      .c 文
     </span>
     <span style="color:#1f2329">
      件如何生成可执行程序呢？
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      多个.c文件单独经过编译出编译处理⽣产对应的目标文件。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      注：在Windows环境下的⽬标⽂件的后缀是 .obj
     </span>
     <span style="color:#1f2329">
      ，Linux环境下⽬标⽂件的后缀是
     </span>
     <span style="color:#1f2329">
      .o
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      多个目标文件和链接库一起经过链接器处理生成最终的可执行程序。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      链接库是指运行时库(它是支持程序运行的基本函数集合)或者第三方库。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      如果再把编译器展开成3个过程，那就变成了下面的过程：
     </span>
    </p>
    <p>
     <img alt="" height="1243" src="https://i-blog.csdnimg.cn/direct/568b35809f6046588a45ff6c4c953cb7.png" width="1861"/>
    </p>
    <h3>
     2.1 预处理（预编译）
    </h3>
    <p>
     <span style="color:#1f2329">
      在预处理阶段，源文件和头文件会被处理成为.i为后缀的文件。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      在
     </span>
     <span style="color:#1f2329">
      gcc
     </span>
     <span style="color:#1f2329">
      环境下想观察⼀下，对
     </span>
     <span style="color:#1f2329">
      test.c 文
     </span>
     <span style="color:#1f2329">
      件预处理后的.i文件，命令如下：
     </span>
    </p>
    <pre><code class="language-cpp">gcc -E test.c -o test.i</code></pre>
    <p>
     <span style="color:#1f2329">
      预处理阶段主要处理那些源文件中#开始的预编译指令。比如：#include,#define，处理的规则如下：
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      将所有的 #define
     </span>
     <span style="color:#1f2329">
      删除，并展开所有的宏定义。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      处理所有的条件编译指令，如： #if
     </span>
     <span style="color:#1f2329">
      、
     </span>
     <span style="color:#1f2329">
      #ifdef
     </span>
     <span style="color:#1f2329">
      、
     </span>
     <span style="color:#1f2329">
      #elif
     </span>
     <span style="color:#1f2329">
      、
     </span>
     <span style="color:#1f2329">
      #else
     </span>
     <span style="color:#1f2329">
      、
     </span>
     <span style="color:#1f2329">
      #endif
     </span>
     <span style="color:#1f2329">
      。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      处理#include 预编译指令，将包含的头⽂件的内容插⼊到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的头⽂件也可能包含其他⽂件。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      删除所有的注释
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      添加行号和文件名标识，方便后续编译器生成调试信息等。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      •
     </span>
     <span style="color:#1f2329">
      或保留所有的#pragma的编译器指令，编译器后续会使用。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      经过预处理后的.i文件中不再包含宏定义，因为宏已经被展开。并且包含的头文件都被插入到.i文件 中。所以当我们无法知道宏定义或者头文件是否包含正确的时候，可以查看预处理后的.i文件来确认。
     </span>
    </p>
    <h3>
     <span style="color:#1f2329">
      2.2 编译
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      编译过程就是将预处理后的⽂件进⾏⼀系列的：词法分析、语法分析、语义分析及优化，⽣成相应的汇编代码文件。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      编译过程的命令如下：
     </span>
    </p>
    <pre><code class="language-cpp">gcc -S test.i -o test.s</code></pre>
    <p>
     <span style="color:#1f2329">
      对下面代码进行编译的时候，会怎么做呢？假设有下面的代码
     </span>
    </p>
    <pre><code class="language-cpp">array[index] = (index+4)*(2+6);</code></pre>
    <h4>
     <span style="color:#1f2329">
      2.2.1 词法分析
     </span>
    </h4>
    <p>
     <span style="color:#1f2329">
      将源代码程序被输入扫描器，扫描器的任务就是简单的进行词法分析，把代码中的字符分割成一系列的记号（关键字、标识符、字面量、特殊字符等）。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      上面程序进行词法分析后得到了16个记号：
     </span>
    </p>
    <p>
     <img alt="" height="1314" src="https://i-blog.csdnimg.cn/direct/d5e1bfd2db204dc890c9b8790cbd64fc.png" width="897"/>
    </p>
    <h4>
     <span style="color:#1f2329">
      2.2.2 语法分析
     </span>
    </h4>
    <p>
     <span style="color:#1f2329">
      接下来
      <strong>
       语法分析器
      </strong>
      ，将对扫描产生的记号进行语法分析，从而产生语法树。这些语法树是以表达式为节点的树。
     </span>
    </p>
    <p>
     <img alt="" height="963" src="https://i-blog.csdnimg.cn/direct/eeb7968e747b4adc8c3be768057d6ea1.png" width="1671"/>
    </p>
    <h4>
     <span style="color:#1f2329">
      2.2.3 语义分析
     </span>
    </h4>
    <p>
     <span style="color:#1f2329">
      由语义分析器来完成语义分析，即对表达式的语法层面分析。编译器所能做的分析是语义的静态分
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      析。静态语义分析通常包括声明和类型的匹配，类型的转换等。这个阶段会报告错误的语法信息。
     </span>
    </p>
    <p>
     <img alt="" height="953" src="https://i-blog.csdnimg.cn/direct/d1e867d5d8cf4722993ce11d2d855fb1.png" width="1639"/>
    </p>
    <h3>
     <span style="color:#1f2329">
      2.3 汇编
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      汇编器是将汇编代码转转变成机器可执行的指令，每一个汇编语句几乎都对应一条机器指令。就是根据汇编指令和机器指令的对照表一一的进行翻译，也不做指令优化。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      汇编的命令如下：
     </span>
    </p>
    <pre><code class="language-cpp">gcc -c test.s -o test.o</code></pre>
    <h3>
     <span style="color:#1f2329">
      2.4 链接
     </span>
    </h3>
    <p>
     <span style="color:#1f2329">
      链接是一个复杂的过程，链接的时候需要把一堆文件链接在一起才生成可执行程序。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      链接过程主要包括：地址和空间分配，符号决议和重定位等这些步骤。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      链接解决的是⼀个项目中多文件、多模块之间互相调⽤的问题。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      比如：
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      在一个C的项目中有2个.c文件（
     </span>
     <span style="color:#1f2329">
      test.c
     </span>
     <span style="color:#1f2329">
      和
     </span>
     <span style="color:#1f2329">
      add.c
     </span>
     <span style="color:#1f2329">
      ），代码如下：
     </span>
    </p>
    <p>
     <img alt="" height="1095" src="https://i-blog.csdnimg.cn/direct/61688461c7f64f298aacf2b2cc91f2f8.png" width="2419"/>
    </p>
    <p>
     test.c
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
//test.c
//声明外部函数
extern int Add(int x, int y);
//声明外部的全局变量
extern int g_val;
int main()
{
 int a = 10;
 int b = 20;
 int sum = Add(a, b);
 printf("%d\n", sum);
 return 0;
}</code></pre>
    <p>
     add.c
    </p>
    <pre><code class="language-cpp">int g_val = 2022;
int Add(int x, int y)
{
 return x+y;
}</code></pre>
    <p>
     <span style="color:#1f2329">
      我们已经知道，每个源文件都是单独经过编译器处理生成对应的目标文件。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      test.c
     </span>
     <span style="color:#1f2329">
      经过编译器处理生成
     </span>
     <span style="color:#1f2329">
      test.o
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      add.c
     </span>
     <span style="color:#1f2329">
      经过编译器处理生成
     </span>
     <span style="color:#1f2329">
      add.o
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      我们在
     </span>
     <span style="color:#1f2329">
      test.c
     </span>
     <span style="color:#1f2329">
      的文件中使用了
     </span>
     <span style="color:#1f2329">
      add.c 文
     </span>
     <span style="color:#1f2329">
      件中的
     </span>
     <span style="color:#1f2329">
      Add
     </span>
     <span style="color:#1f2329">
      函数和
     </span>
     <span style="color:#1f2329">
      g_val
     </span>
     <span style="color:#1f2329">
      变量。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      我们在
     </span>
     <span style="color:#1f2329">
      test.c 文
     </span>
     <span style="color:#1f2329">
      件中每一次使用
     </span>
     <span style="color:#1f2329">
      Add
     </span>
     <span style="color:#1f2329">
      函数和
     </span>
     <span style="color:#1f2329">
      g_val
     </span>
     <span style="color:#1f2329">
      的时候必须确切的知道
     </span>
     <span style="color:#1f2329">
      Add
     </span>
     <span style="color:#1f2329">
      和
     </span>
     <span style="color:#1f2329">
      g_val
     </span>
     <span style="color:#1f2329">
      的地 址，但是由于每个文件是单独编译的，在编译器编译 test.c
     </span>
     <span style="color:#1f2329">
      的时候并不知道
     </span>
     <span style="color:#1f2329">
      Add
     </span>
     <span style="color:#1f2329">
      函数和
     </span>
     <span style="color:#1f2329">
      g_val 变量的地址，所以暂时把调用 Add
     </span>
     <span style="color:#1f2329">
      的指令的目标地址和
     </span>
     <span style="color:#1f2329">
      g_val
     </span>
     <span style="color:#1f2329">
      的地址搁置。等待最后链接的时候由链接器根据引用的符号 Add
     </span>
     <span style="color:#1f2329">
      在其他模块中查找
     </span>
     <span style="color:#1f2329">
      Add
     </span>
     <span style="color:#1f2329">
      函数的地址，然后将
     </span>
     <span style="color:#1f2329">
      test.c
     </span>
     <span style="color:#1f2329">
      中所有引用到 Add 的指令重新修正，让他们的目标地址为真正的
     </span>
     <span style="color:#1f2329">
      Add
     </span>
     <span style="color:#1f2329">
      函数的地址，对于全局变量
     </span>
     <span style="color:#1f2329">
      g_val
     </span>
     <span style="color:#1f2329">
      也是类似的方法来修正地址。这个地址修正的过程也被叫做：重定位。
     </span>
    </p>
    <p>
     <span style="color:#1f2329">
      前面我们非常简洁的讲解了⼀个C的程序是如何编译和链接，到最终生成可执行程序的过程，其实很多内部的细节无法展开讲解。比如：目标文件的格式elf，链接底层实现中的空间与地址分配，符号解析和重定位等，如果你有兴趣，可以看《程序的自我修养》一书来详细了解。
     </span>
    </p>
    <h2>
     <span style="color:#1f2329">
      3. 运行环境
     </span>
    </h2>
    <p>
     <span style="color:#1456f0">
      1.
     </span>
     <span style="color:#1f2329">
      程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      2.
     </span>
     <span style="color:#1f2329">
      程序的执行便开始。接着便调用main函数。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      3.
     </span>
     <span style="color:#1f2329">
      开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执⾏过程一直保留他们的值。
     </span>
    </p>
    <p>
     <span style="color:#1456f0">
      4.
     </span>
     <span style="color:#1f2329">
      终止程序。正常终止main函数；也有可能是意外终止。
     </span>
    </p>
    <div>
    </div>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393930373430332f:61727469636c652f64657461696c732f313436323631383031" class_="artid" style="display:none">
 </p>
</div>


