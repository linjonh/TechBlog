---
layout: post
title: "软考-架构3.3模式分解-事务并发-封锁协议"
date: 2025-03-12 11:11:01 +0800
description: "模式分解-事务并发-封锁协议"
keywords: "【软考-架构】3.3、模式分解-事务并发-封锁协议"
categories: ['软考系统架构师']
tags: ['架构']
artid: "146199691"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146199691
    alt: "软考-架构3.3模式分解-事务并发-封锁协议"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146199691
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146199691
cover: https://bing.ee123.net/img/rand?artid=146199691
image: https://bing.ee123.net/img/rand?artid=146199691
img: https://bing.ee123.net/img/rand?artid=146199691
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【软考-架构】3.3、模式分解-事务并发-封锁协议
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <blockquote>
     <p>
      ✨资料&amp;文章更新✨
      <br/>
      GitHub地址：
      <a href="https://github.com/tyronczt/system_architect">
       https://github.com/tyronczt/system_architect
      </a>
     </p>
    </blockquote>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_4">
     </a>
     模式分解（难点）
    </h2>
    <p>
     <strong>
      保持函数依赖分解
     </strong>
     ：分解出来的多个关系模式，保持原来的依赖集不变。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/6918d2fcd2467a6412516e182d173fc9.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/fb44643448a07acb80e3959fabcfde2a.png"/>
    </p>
    <h2>
     <a id="_11">
     </a>
     无损分解
    </h2>
    <p>
     <strong>
      无损分解
     </strong>
     ：分解后的关系模式能够还原出原关系模式，就是无损分解，不能还原就是有损。
    </p>
    <p>
     当分解为两个关系模式，可以通过以下定理判断是否无损分解：
    </p>
    <p>
     <strong>
      定理
     </strong>
     ：如果R的分解为p={R1，R2}，F为R所满足的函数依赖集合，分解p具有无损连接性的充分必要条件是R1 ∩ R2-&gt;（R1-R2）或者R1 ∩ R2-&gt;（R2-R1）
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/78bde27828ed95e9a833e4d25d000c44.png"/>
    </p>
    <h2>
     <a id="_20">
     </a>
     💯考试真题
    </h2>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/2e128353bf129cb51d7c74ee6462f112.png"/>
    </p>
    <p>
     <strong>
      候选关键字分析
     </strong>
    </p>
    <p>
     <strong>
      候选关键字的求法：
      <strong>
       根据依赖集，找出从未在
      </strong>
      右边
     </strong>
     出现过的属性，必然是候选键之一，以该属性为基础，根据依赖集依次扩展，看能否遍历所有属性，将无法遍历的加入候选键中。
    </p>
    <ul>
     <li>
      属性集 U={A,B,C,D,E}，函数依赖集 F={B→A,D→A,A→E,AC→B}。
     </li>
     <li>
      <strong>
       候选键需满足
      </strong>
      ：能推导出所有属性且极小。
      <ul>
       <li>
        CD 是候选键：
       </li>
      </ul>
     </li>
     <li>
      CD→D→A→E，且 AC→B（通过 C∈CD 和 A∈D+）。
      <ul>
       <li>
        其他组合（如 BC、AC）无法推导出所有属性。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       结论
      </strong>
      ：候选关键字为 A（选项 A：CD）。
     </li>
    </ul>
    <p>
     <strong>
      无损性判断
     </strong>
    </p>
    <p>
     公式：R1 ∩ R2-&gt;（R1-R2）或者R1 ∩ R2-&gt;（R2-R1）
    </p>
    <p>
     R1 ∩ R2 = C ; R1-R2 = ABE ; R2-R1 = D；
    </p>
    <p>
     C → ABE &amp; C → D 都不成立，所以为有损分解；
    </p>
    <p>
     <strong>
      函数依赖
     </strong>
    </p>
    <p>
     原依赖 D→A 无法在 R1 或 R2 中保留（因 D 仅在 R2，而 A 不在 R2），依赖未完全保持。
    </p>
    <p>
     <strong>
      最终答案
     </strong>
    </p>
    <ul>
     <li>
      候选关键字：
      <strong>
       A. CD
      </strong>
     </li>
     <li>
      分解性质：
      <strong>
       D. 不具有无损连接性，也不保持函数依赖
      </strong>
     </li>
    </ul>
    <h2>
     <a id="_51">
     </a>
     并发控制
    </h2>
    <p>
     原子性、一致性、隔离性、持续性。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/7172497a8382f8f2fc08caf5337f026e.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/6c0fe8d9de8a08abea13a8ab3d1e0828.png"/>
    </p>
    <h2>
     <a id="_58">
     </a>
     封锁协议
    </h2>
    <p>
     <strong>
      X锁是排它锁（写锁）
     </strong>
     。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。
    </p>
    <p>
     <strong>
      S锁是共享锁（读锁）
     </strong>
     。若事务T对数据对象A加上S锁，则只允许T读取A，但不能修改A，其他事务只能再对A加S锁（也即能读不能修改），直到T释放A上的S锁。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/9ab74feb1ea3d09e1f6724e1e78704b6.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/dfa499a73a81bdfc131f0d0fd00386b0.png"/>
    </p>
    <h2>
     <a id="_67">
     </a>
     💯考试真题
    </h2>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/0ee3698f82e6e157a426e8d28e0a7ce9.png"/>
    </p>
    <h3>
     <a id="_70">
     </a>
     第一题
    </h3>
    <p>
     <strong>
      答案：C
     </strong>
    </p>
    <h3>
     <a id="_73">
     </a>
     第二题
    </h3>
    <p>
     排他锁（X锁）是独占锁，禁止其他所有锁；共享锁（S锁）允许其他共享锁，但禁止排他锁。
    </p>
    <p>
     <strong>
      答案：D、C
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f7469616e3333303732362f:61727469636c652f64657461696c732f313436313939363931" class_="artid" style="display:none">
 </p>
</div>


