---
layout: post
title: "顺序表与链表续"
date: 2025-03-07 23:56:57 +0800
description: "本文承接上文，对链表的要点进行提炼。前文提到顺序表适合需要且数据量固定的场景，而链表适合需要且数据量动态变化的场景。链表的引入弥补了顺序表在动态性和操作效率上的不足，是线性表的重要实现方式之一。"
keywords: "顺序表与链表·续"
categories: ['数据结构']
tags: ['链表', '数据结构']
artid: "146105705"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146105705
    alt: "顺序表与链表续"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146105705
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146105705
cover: https://bing.ee123.net/img/rand?artid=146105705
image: https://bing.ee123.net/img/rand?artid=146105705
img: https://bing.ee123.net/img/rand?artid=146105705
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     顺序表与链表·续
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     引言
    </h2>
    <p>
     本文承接上文（
     <a href="https://blog.csdn.net/2301_78696090/article/details/146104389" title="顺序表与链表-CSDN博客">
      顺序表与链表-CSDN博客
     </a>
     ），开始对链表的要点提炼。前文提到顺序表适合需要
     <strong>
      频繁随机访问
     </strong>
     且数据量固定的场景，而链表适合需要
     <strong>
      频繁插入和删除
     </strong>
     且数据量动态变化的场景。链表的引入弥补了顺序表在动态性和操作效率上的不足，是线性表的重要实现方式之一。
    </p>
    <h2>
     链表
    </h2>
    <h3>
     概念
    </h3>
    <div>
     <span style="color:#777777">
      链表是一种
     </span>
     <span style="color:#777777">
      <strong>
       物理存储结构上非连续
      </strong>
     </span>
     <span style="color:#777777">
      、非顺序的存储结构，数据元素的
     </span>
     <span style="color:#777777">
      <strong>
       逻辑顺序
      </strong>
     </span>
     <span style="color:#777777">
      是通过链表
     </span>
    </div>
    <div>
     <span style="color:#777777">
      中的
     </span>
     <span style="color:#777777">
      <strong>
       指针链接
      </strong>
     </span>
     <span style="color:#777777">
      实现的 。
     </span>
    </div>
    <div>
    </div>
    <div>
     <div class="img-center">
      <figure class="image">
       <img alt="" height="118" src="https://i-blog.csdnimg.cn/direct/b20b1cc2410e4078a916528dc2a60f1a.png" width="838">
        <figcaption>
         链表结构
        </figcaption>
       </img>
      </figure>
     </div>
    </div>
    <div>
    </div>
    <div>
     容易发现链表结构在逻辑上连续，但物理上不一定连续，一般链表的节点从堆上申请的，每次申请的空间是否连续是不确定的。
    </div>
    <div>
    </div>
    <h3>
     分类
    </h3>
    <p>
     链表的分类可以根据以下维度进行：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        单向或双向
       </strong>
       ：决定节点的指针数量和遍历方向。
      </p>
     </li>
     <li>
      <p>
       <strong>
        带头或不带头
       </strong>
       ：决定是否有额外的头节点简化操作。
      </p>
     </li>
     <li>
      <p>
       <strong>
        循环或不循环
       </strong>
       ：决定链表是否形成环。
      </p>
     </li>
    </ol>
    <p>
     通过组合这些维度，可以设计出适合不同场景的链表结构。例如：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        带头单向循环链表
       </strong>
       ：适合实现队列。
      </p>
     </li>
     <li>
      <p>
       <strong>
        带头双向循环链表
       </strong>
       ：适合需要双向遍历且操作简化的场景。
      </p>
     </li>
    </ul>
    <p>
     而我们常遇到的主要是不带头单向非循环链表和带头双向循环链表（以下图例分别对应这两种链表）
    </p>
    <div class="img-center">
     <figure class="image">
      <img alt="" height="65" src="https://i-blog.csdnimg.cn/direct/ab4a45e66a6547febdd8356b12095615.png" width="453">
       <figcaption>
        不带头单向非循环链表
       </figcaption>
      </img>
     </figure>
    </div>
    <div class="img-center">
     <figure class="image">
      <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/eea15150a7d94fafbb8d2ac7b25077d4.png" width="802">
       <figcaption>
        带头双向循环链表
       </figcaption>
      </img>
     </figure>
    </div>
    <p>
    </p>
    <p>
    </p>
    <h3 style="background-color:transparent">
     实现
    </h3>
    <p>
     <span style="color:#38d8f0">
      无头单向非循环链表的简单实现
     </span>
    </p>
    <pre><code class="language-cpp">//"slist.h"
#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

typedef int SLTDateType;

typedef struct SListNode
{
	SLTDateType data;
	struct SListNode* next;
}SListNode;

// 动态申请一个节点
SListNode* BuySListNode(SLTDateType x) 
{
	SListNode* newnode = (SListNode*)malloc(sizeof(SListNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		exit(-1);
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	return newnode;
}

// 单链表打印
void SListPrint(SListNode* plist)
{
	SListNode* cur = plist;
	while (cur != NULL)
	{
		printf("%d-&gt;", cur-&gt;data);
		cur = cur-&gt;next;
	}
	printf("NULL\n");
}

// 单链表尾插
void SListPushBack(SListNode** pplist, SLTDateType x)
{
	SListNode* newnode = BuySListNode(x);

	if (*pplist == NULL) {
		*pplist = newnode;
	}
	else
	{
		SListNode* tail = *pplist;
		while (tail-&gt;next!=NULL)
		{
			tail = tail-&gt;next;
		}
		tail-&gt;next = newnode;
		
	}

}
// 单链表的头插
void SListPushFront(SListNode** pplist, SLTDateType x)
{
	SListNode* newnode = BuySListNode(x);
	newnode-&gt;next = *pplist;
	*pplist = newnode;

}


// 单链表的尾删
void SListPopBack(SListNode** pplist)
{
	assert(pplist);
	assert(*pplist);

	//一个节点
	if ((*pplist)-&gt;next == NULL) {
		free(*pplist);
		*pplist = NULL;
	}

	//多个节点
	SListNode* tail = *pplist;
	while (tail-&gt;next-&gt;next!=NULL)
	{
		tail = tail-&gt;next;
	}
	free(tail-&gt;next);
	tail-&gt;next = NULL;

}
void SListPopFront(SListNode** pplist) {
	// 防御性检查：拦截非法输入
	if (pplist == NULL) {
		fprintf(stderr, "Error: Invalid pointer in SListPopFront\n");
		return;
	}

	// 业务逻辑检查：空链表直接返回
	if (*pplist == NULL) {
		return;
	}

	SListNode* tmp = *pplist;
	*pplist = tmp-&gt;next;
	free(tmp);
}

// 单链表查找
SListNode* SListFind(SListNode* plist, SLTDateType x)
{
	SListNode* cur = plist;
	while (cur) {
		if (cur-&gt;data == x) {
			return cur;
		}
		cur = cur-&gt;next;
	}
	return NULL;
}
// 单链表在pos位置之后插入x
// 分析思考为什么不在pos位置之前插入？  

// 因为没有前置指针
// 若要在 pos 之前插入，必须从头节点开始遍历链表找到 pos 的前驱节点，时间复杂度为 O(n)
void SListInsertAfter(SListNode* pos, SLTDateType x)
{
	if (pos == NULL) return;
	SListNode* newNode = BuySListNode(x);
	newNode-&gt;next = pos-&gt;next;
	pos-&gt;next = newNode;
}
// 单链表删除pos位置之后的值
// 分析思考为什么不删除pos位置？ 

//删除 pos 节点需要知道其前驱节点，而单链表无法直接获取前驱节点
// 必须从头遍历链表，时间复杂度为O(n)，删除 pos 之后的节点只需修改 pos-&gt;next，时间复杂度为O(1)。

void SListEraseAfter(SListNode* pos)
{
	if (pos == NULL || pos-&gt;next == NULL) return;
	SListNode* tmp = pos-&gt;next;
	pos-&gt;next = tmp-&gt;next;
	free(tmp);
}

// 在pos的前面插入
void SLTInsert(SListNode** pphead, SListNode* pos, SLTDateType x)
{
	assert(pphead);
	assert(pos);
	assert(*pphead);
	if (*pphead == pos) SListPushFront(pphead,x);
	else
	{
		SListNode* prev = *pphead;
		while (prev-&gt;next!=pos)
		{
			prev = prev-&gt;next;
		}
		SListNode* newnode=BuySListNode(x);
		prev-&gt;next = newnode;
		newnode-&gt;next = pos;

	}
}

// 删除pos位置
void SLTErase(SListNode** pphead, SListNode* pos)
{
	assert(pphead);
	assert(*pphead);
	assert(pos);

	if (*pphead == pos)
	{
		// 头删
		SListPopFront(pphead);
	}
	else
	{
		SListNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}

void SLTDestroy(SListNode** pphead)
{
	assert(pphead);
	SListNode* cur = *pphead;
	while (cur) {
		SListNode* tmp = cur;
		cur = cur-&gt;next;
		free(tmp);
	}
	*pphead = NULL;
}</code></pre>
    <h4 style="background-color:transparent">
     关键点说明
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        二级指针的使用
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         修改头指针时（如插入/删除头节点），需通过二级指针
         <code>
          pplist
         </code>
         修改一级指针
         <code>
          *pplist
         </code>
         。
        </p>
       </li>
       <li>
        <p>
         示例：
         <code>
          SListPushFront
         </code>
         和
         <code>
          SListPopFront
         </code>
         直接修改头指针。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        边界条件处理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         空链表、单节点链表、尾节点/头节点操作需特殊处理。
        </p>
       </li>
       <li>
        <p>
         例如
         <code>
          SListPopBack
         </code>
         中需处理链表只有一个节点的情况。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        时间复杂度
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         头插/头删：O(1)/O(1)
        </p>
       </li>
       <li>
        <p>
         尾插/尾删：O(n)/O(n)
        </p>
       </li>
       <li>
        <p>
         插入/删除指定位置：平均 O(n)/O(n)（需遍历找到位置）
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        内存管理
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         每次
         <code>
          malloc
         </code>
         后需检查内存分配是否成功。
        </p>
       </li>
       <li>
        <p>
         删除节点后需及时
         <code>
          free
         </code>
         防止内存泄漏。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     若需要频繁在任意位置前插入或删除，最好使用
     <strong>
      双向链表
     </strong>
     ，它可以通过前驱指针直接操作，时间复杂度为 O(1)/O(1)。
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="468" src="https://i-blog.csdnimg.cn/direct/1de05e5091784857b6eff2827202573a.png" width="696"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37383639363039302f:61727469636c652f64657461696c732f313436313035373035" class_="artid" style="display:none">
 </p>
</div>


