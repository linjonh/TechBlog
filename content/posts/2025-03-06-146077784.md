---
layout: post
title: "非常重要的动态内存错误和柔性数组1"
date: 2025-03-06 19:34:08 +0800
description: "因此，GetMemory 返回的指针指向一个无效的内存区域，导致 Test 函数中的 printf 操作会引发未定义行为（表现通常是打印乱码或程序崩溃）。承接上次的动态内存的分享，我想想还是把具体的易错点分享一下，再跟大家分享四道非常经典的笔试题，以后找工作会发现，很多题就是这四道题的原型。这个后面两篇文章会讲。在 Test 函数中，str 被初始化为 NULL，但通过 GetMemory 赋值后，它指向了一个无效的内存地址。程序分配了内存但没有释放，导致内存被持续占用，最终可能导致系统内存耗尽。"
keywords: "非常重要的动态内存错误和柔性数组1"
categories: ['编程语言', 'C']
tags: ['算法', '柔性数组', 'C', 'C']
artid: "146077784"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146077784
    alt: "非常重要的动态内存错误和柔性数组1"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146077784
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146077784
cover: https://bing.ee123.net/img/rand?artid=146077784
image: https://bing.ee123.net/img/rand?artid=146077784
img: https://bing.ee123.net/img/rand?artid=146077784
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     非常重要的动态内存错误和柔性数组1
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     hello，everyone！
    </p>
    <p>
     承接上次的动态内存的分享，我想想还是把具体的易错点分享一下，再跟大家分享四道非常经典的笔试题，以后找工作会发现，很多题就是这四道题的原型。
    </p>
    <p>
     话不多说开始
    </p>
    <h2>
     <strong>
      <span style="color:#fe2c24">
       1. 内存泄漏
      </span>
     </strong>
    </h2>
    <p>
     程序分配了内存但没有释放，导致内存被持续占用，最终可能导致系统内存耗尽。
    </p>
    <p>
     原因: 忘记调用 free或 delete释放内存。
    </p>
    <p>
     <strong>
      <span style="color:#ff9900">
       忘记释放不再使用的动态开辟的空间会造成内存泄漏。 切记： 动态开辟的空间一定要释放，并且正确释放 。
      </span>
     </strong>
    </p>
    <pre><code class="language-cs">void memoryLeak() {
    int *ptr = (int*)malloc(sizeof(int));
    // 忘记释放内存
}</code></pre>
    <h2>
     <span style="color:#fe2c24">
      <strong>
       2. 野指针
      </strong>
     </span>
    </h2>
    <p>
     描指针指向的内存已经被释放，但指针仍然被使用。
    </p>
    <p>
     原因: 在释放内存后继续使用指针，或返回局部变量的指针。
    </p>
    <pre><code class="language-cs">int* danglingPointer() {
    int *ptr = (int*)malloc(sizeof(int));
    free(ptr);
    return ptr; // ptr 现在是野指针
}</code></pre>
    <h2>
     <strong>
      <span style="color:#fe2c24">
       3. 双重释放
      </span>
     </strong>
    </h2>
    <p>
     对同一块内存多次调用 free 或 delete。
    </p>
    <p>
     原因: 释放已经释放过的内存。
    </p>
    <pre><code class="language-cs">void doubleFree() {
    int *ptr = (int*)malloc(sizeof(int));
    free(ptr);
    free(ptr); // 双重释放
}</code></pre>
    <h2>
     <span style="color:#fe2c24">
      <strong>
       4. 内存越界
      </strong>
     </span>
    </h2>
    <p>
     访问了分配内存之外的区域，可能导致数据损坏或程序崩溃。
    </p>
    <p>
     原因: 数组越界、指针操作超出分配的内存范围。
    </p>
    <pre><code class="language-cs">void bufferOverflow() {
    int *ptr = (int*)malloc(5 * sizeof(int));
    ptr[5] = 10; // 越界访问
}</code></pre>
    <h2>
     <strong>
      <span style="color:#fe2c24">
       5. 无效指针解引用
      </span>
     </strong>
    </h2>
    <p>
     <span style="color:#0d0016">
      解引用无效的指针（如空指针或未分配内存的指针）。
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      原因: 指针未正确初始化或已被释放。
     </span>
    </p>
    <pre><code class="language-cs">void invalidDereference() {
    int *ptr = NULL;
    *ptr = 10; // 解引用空指针
}</code></pre>
    <p>
     <span style="color:#ff9900">
      6.忘记检查分配是否成功
     </span>
    </p>
    <p>
     未检查内存分配是否成功，可能导致后续操作出错。
    </p>
    <p>
     原因: 假设 malloc 或 new 总是成功。
    </p>
    <pre><code class="language-cs">void noCheckAllocation() {
    int *ptr = (int*)malloc(1000000000 * sizeof(int));
    *ptr = 10; // 如果分配失败，ptr 为 NULL
}</code></pre>
    <p>
    </p>
    <p>
     好了，我们接下来就来看一下这四道题。看一下这些代码
     <span style="color:#a2e043">
      错误在哪里，运行能得到什么结果
     </span>
    </p>
    <h2 style="background-color:transparent">
     <span style="color:#4da8ee">
      test1
     </span>
    </h2>
    <pre><code class="language-cs">void GetMemory(char *p)
{
 p = (char *)malloc(100);
}
void Test(void)
{
 char *str = NULL;
 GetMemory(str);
 strcpy(str, "hello world");
 printf(str);
}</code></pre>
    <p>
     这个代码严谨一点的话有三个问题：
    </p>
    <p>
     1.函数参数传递2.内存泄漏3.未检查内存分配是否成功。
    </p>
    <p>
     先来看第一个GetMemory 函数的参数 p 是一个指针，但它是按值传递的。即使 p 在函数内部被修改为指向新分配的内存，
     <span style="color:#fe2c24">
      调用方的 str 并不会被更新，仍然为 NULL。
     </span>
     <br/>
     因此，Test 函数中的 str 仍然是 NULL，导致 strcpy 和 printf 操作是未定义行为。GetMemory 函数中分配的内存没有被释放，导致内存泄漏。另外malloc 可能会失败并返回 NULL，但代码没有检查分配是否成功。
    </p>
    <p>
     那怎么改呢？
    </p>
    <p>
     利用二级指针就可以。
    </p>
    <pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void GetMemory(char **p) {
    *p = (char *)malloc(100);
    if (*p == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
}

void Test(void) {
    char *str = NULL;
    GetMemory(&amp;str); // 传递 str 的地址
    strcpy(str, "hello world");
    printf("%s\n", str);
    free(str); // 释放内存
}

int main() {
    Test();
    return 0;
}</code></pre>
    <h2 style="background-color:transparent">
     <strong>
      <span style="color:#4da8ee">
       test2
      </span>
     </strong>
    </h2>
    <pre><code class="language-cs">char *GetMemory(void) 
{ 
char p[] = "hello world"; 
return p; 
} 
void Test(void) 
{ 
char *str = NULL; 
str = GetMemory(); 
printf(str); 
} </code></pre>
    <p>
     这段代码的问题是
     <span style="color:#fe2c24">
      返回局部变量的指针和未初始化指针。
     </span>
    </p>
    <p>
     在 GetMemory 函数中，p 是一个局部数组，它的内存位于栈上。当函数返回时，栈帧会被销毁，p 的内存不再有效。
     <br/>
     因此，GetMemory 返回的指针指向一个无效的内存区域，导致 Test 函数中的 printf 操作会引发未定义行为（表现通常是打印乱码或程序崩溃）。
    </p>
    <p>
     在 Test 函数中，str 被初始化为 NULL，但通过 GetMemory 赋值后，它指向了一个无效的内存地址。
    </p>
    <p>
     <strong>
      <span style="color:#ff9900">
       这里的改变我们可以将局部变量声明为 static，使其生命周期延长到程序结束。这个后面两篇文章会讲。为什么static能延长生命周期。
      </span>
     </strong>
    </p>
    <p>
     这里粘贴一下，满足一下大家的好奇心。
    </p>
    <pre><code class="language-cs">#include &lt;stdio.h&gt;

char* GetMemory(void) {
    static char p[] = "hello world"; 
    return p;
}

void Test(void) {
    char *str = NULL;
    str = GetMemory(); 
    printf("%s\n", str);
}

int main() {
    Test();
    return 0;
}</code></pre>
    <p>
     好了，感谢阅读，剩下的我们下一篇文章讲，希望大家好好理解这两道题。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f6368656e797568616f323032342f:61727469636c652f64657461696c732f313436303737373834" class_="artid" style="display:none">
 </p>
</div>


