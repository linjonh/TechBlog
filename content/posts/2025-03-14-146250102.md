---
layout: post
title: "拦截网页中的-Fetch-和-XMLHttpRequest-请求方式方法"
date: 2025-03-14 10:02:39 +0800
description: "拦截网页中的 Fetch 和 XMLHttpRequest 请求，并捕获它们的响应体内容。通过这种方式，你可以在控制台中查看这些请求的响应数据，或者进一步处理这些数据（例如发送到后台或存储起来）。"
keywords: "拦截网页中的 Fetch 和 XMLHttpRequest 请求方式方法"
categories: ['Html']
tags: ['开发语言', '前端', 'Javascript']
artid: "146250102"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146250102
    alt: "拦截网页中的-Fetch-和-XMLHttpRequest-请求方式方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146250102
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146250102
cover: https://bing.ee123.net/img/rand?artid=146250102
image: https://bing.ee123.net/img/rand?artid=146250102
img: https://bing.ee123.net/img/rand?artid=146250102
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     拦截网页中的 Fetch 和 XMLHttpRequest 请求方式方法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <img alt="" height="1394" src="https://i-blog.csdnimg.cn/direct/73863f6f574a446ea541d672a50a18bc.png" width="2238"/>
    </p>
    <p>
     拦截网页中的
     <strong>
      Fetch
     </strong>
     和
     <strong>
      XMLHttpRequest
     </strong>
     请求，并捕获它们的响应体内容。通过这种方式，你可以在控制台中查看这些请求的响应数据，或者进一步处理这些数据（例如发送到后台或存储起来）。
    </p>
    <p>
     以下是代码的逐行解释：
    </p>
    <hr/>
    <h4>
     <a id="1__6">
     </a>
     <strong>
      1. 整体结构
     </strong>
    </h4>
    <pre><code class="language-javascript">(function() {
  // 代码逻辑
})();
</code></pre>
    <p>
     这是一个
     <strong>
      立即执行函数表达式 (IIFE)
     </strong>
     ，用于创建一个独立的作用域，避免变量污染全局环境。
    </p>
    <hr/>
    <h4>
     <a id="2__Fetch__16">
     </a>
     <strong>
      2. 拦截 Fetch 请求
     </strong>
    </h4>
    <pre><code class="language-javascript">var originalFetch = window.fetch;
window.fetch = function() {
  return originalFetch.apply(this, arguments).then(response =&gt; {
    response.clone().text().then(body =&gt; {
      console.log("1024小神 Fetched body:", body);
      // 这里可以处理响应体内容，比如发送给后台或者存储起来
    });
    return response;
  });
};
</code></pre>
    <h5>
     <a id="_30">
     </a>
     解释：
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        保存原始的 Fetch 方法
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">var originalFetch = window.fetch;
</code></pre>
      <p>
       将浏览器原生的
       <code>
        fetch
       </code>
       方法保存到
       <code>
        originalFetch
       </code>
       变量中，以便后续调用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        重写 Fetch 方法
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">window.fetch = function() {
  return originalFetch.apply(this, arguments).then(response =&gt; {
    // 拦截逻辑
  });
};
</code></pre>
      <p>
       重写
       <code>
        window.fetch
       </code>
       方法，使其在每次调用时执行自定义逻辑。
      </p>
     </li>
     <li>
      <p>
       <strong>
        克隆响应并读取响应体
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">response.clone().text().then(body =&gt; {
  console.log("1024小神 Fetched body:", body);
});
</code></pre>
      <ul>
       <li>
        <code>
         response.clone()
        </code>
        ：克隆响应对象，因为响应体只能读取一次。
       </li>
       <li>
        <code>
         response.text()
        </code>
        ：将响应体解析为文本。
       </li>
       <li>
        <code>
         console.log
        </code>
        ：将响应体内容打印到控制台。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        返回原始响应
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">return response;
</code></pre>
      <p>
       确保原始的
       <code>
        fetch
       </code>
       调用不受影响，返回原始的响应对象。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="3__XMLHttpRequest__65">
     </a>
     <strong>
      3. 拦截 XMLHttpRequest 请求
     </strong>
    </h4>
    <pre><code class="language-javascript">var originalXHROpen = XMLHttpRequest.prototype.open;
XMLHttpRequest.prototype.open = function() {
  this.addEventListener("load", function() {
    console.log("1024小神 response:", this.responseText);
    // 这里可以处理响应体内容，比如发送给后台或者存储起来
  });
  originalXHROpen.apply(this, arguments);
};
</code></pre>
    <h5>
     <a id="_77">
     </a>
     解释：
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        保存原始的 XMLHttpRequest.open 方法
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">var originalXHROpen = XMLHttpRequest.prototype.open;
</code></pre>
      <p>
       将浏览器原生的
       <code>
        XMLHttpRequest.prototype.open
       </code>
       方法保存到
       <code>
        originalXHROpen
       </code>
       变量中，以便后续调用。
      </p>
     </li>
     <li>
      <p>
       <strong>
        重写 XMLHttpRequest.open 方法
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">XMLHttpRequest.prototype.open = function() {
  // 拦截逻辑
  originalXHROpen.apply(this, arguments);
};
</code></pre>
      <p>
       重写
       <code>
        XMLHttpRequest.prototype.open
       </code>
       方法，使其在每次调用时执行自定义逻辑。
      </p>
     </li>
     <li>
      <p>
       <strong>
        监听请求完成事件
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">this.addEventListener("load", function() {
  console.log("1024小神 response:", this.responseText);
});
</code></pre>
      <ul>
       <li>
        当请求完成时（
        <code>
         load
        </code>
        事件触发），打印响应体内容（
        <code>
         this.responseText
        </code>
        ）到控制台。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        调用原始的 open 方法
       </strong>
       ：
      </p>
      <pre><code class="language-javascript">originalXHROpen.apply(this, arguments);
</code></pre>
      <p>
       确保原始的
       <code>
        open
       </code>
       方法逻辑不受影响。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="4__109">
     </a>
     <strong>
      4. 代码的作用
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        Fetch 拦截
       </strong>
       ：
      </p>
      <ul>
       <li>
        每次调用
        <code>
         fetch
        </code>
        时，捕获响应体内容并打印到控制台。
       </li>
       <li>
        你可以进一步处理响应体内容，例如发送到后台或存储起来。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        XMLHttpRequest 拦截
       </strong>
       ：
      </p>
      <ul>
       <li>
        每次调用
        <code>
         XMLHttpRequest
        </code>
        时，捕获响应体内容并打印到控制台。
       </li>
       <li>
        同样可以进一步处理响应体内容。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="5__120">
     </a>
     <strong>
      5. 示例输出
     </strong>
    </h4>
    <p>
     假设页面中有一个 Fetch 请求和一个 XMLHttpRequest 请求：
    </p>
    <ul>
     <li>
      Fetch 请求的响应体是
      <code>
       { "name": "1024小神" }
      </code>
      。
     </li>
     <li>
      XMLHttpRequest 请求的响应体是
      <code>
       Hello, World!
      </code>
      。
     </li>
    </ul>
    <p>
     控制台输出：
    </p>
    <pre><code>1024小神 Fetched body: { "name": "1024小神" }
1024小神 response: Hello, World!
</code></pre>
    <hr/>
    <h4>
     <a id="6__133">
     </a>
     <strong>
      6. 注意事项
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       CORS 限制
      </strong>
      ：
      <ul>
       <li>
        如果目标网站启用了 CORS 保护，可能无法直接访问响应体。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       性能影响
      </strong>
      ：
      <ul>
       <li>
        拦截所有请求可能会影响页面性能，建议按需过滤。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       响应体类型
      </strong>
      ：
      <ul>
       <li>
        <code>
         response.text()
        </code>
        适用于文本类型的响应体。如果是 JSON 或二进制数据，可以使用
        <code>
         response.json()
        </code>
        或
        <code>
         response.blob()
        </code>
        。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_143">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     这段代码通过重写
     <code>
      fetch
     </code>
     和
     <code>
      XMLHttpRequest
     </code>
     方法，实现了对网页请求的拦截和响应体内容的捕获。你可以在此基础上扩展功能，例如将捕获的数据发送到后台或存储起来。
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343738363533302f:61727469636c652f64657461696c732f313436323530313032" class_="artid" style="display:none">
 </p>
</div>


