---
layout: post
title: "L33.LeetCode笔记循环队列数组解法"
date: 2025-03-06 09:04:07 +0800
description: "队列不为空时,删除元素:当front==k时,再插入元素时front++,之后处理越界的front,使其等于0,则,front==(front+1)%(k+1)队列未满时,插入元素:当rear==k时,再插入元素时rear++,之后处理越界的rear,使其等于0,则,rear==(rear+1)%(k+1)要访问循环队列的头和尾,需要两个指针front(头指针)和rear(尾指针),初始状态下,链表为空时,front和rear都指向同一个节点。// 返回 true。// 返回 true。"
keywords: "L33.【LeetCode笔记】循环队列(数组解法)"
categories: ['Leetcode']
tags: ['队列', '算法', '笔记', '数据结构', '开发语言', 'Leetcode', 'C']
artid: "144618465"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=144618465
    alt: "L33.LeetCode笔记循环队列数组解法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=144618465
featuredImagePreview: https://bing.ee123.net/img/rand?artid=144618465
cover: https://bing.ee123.net/img/rand?artid=144618465
image: https://bing.ee123.net/img/rand?artid=144618465
img: https://bing.ee123.net/img/rand?artid=144618465
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     L33.【LeetCode笔记】循环队列(数组解法)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      目录
     </strong>
    </p>
    <p style="margin-left:0px">
     <a href="#1.%E9%A2%98%E7%9B%AE" rel="nofollow">
      1.题目
     </a>
    </p>
    <p style="margin-left:0px">
     <a href="#2.%E5%88%86%E6%9E%90" rel="nofollow">
      2.分析
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%E6%96%B9%E6%B3%951%3A%E9%93%BE%E8%A1%A8" rel="nofollow">
      方法1:链表
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%A8%A1%E6%8B%9F" rel="nofollow">
      尝试使用单向循环链表模拟
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9" rel="nofollow">
      插入节点
     </a>
    </p>
    <p style="margin-left:160px">
     <a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%951%3A%E5%BC%80%E8%BE%9F%28k%2B1%29%E4%B8%AA%E8%8A%82%E7%82%B9" rel="nofollow">
      解决方法1:开辟(k+1)个节点
     </a>
    </p>
    <p style="margin-left:160px">
     <a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952%3A%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8Fsize%E8%AE%B0%E5%BD%95%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">
      解决方法2:使用变量size记录队列元素个数
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E8%8E%B7%E5%8F%96%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">
      获取队尾元素
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E" rel="nofollow">
      其他函数的实现说明
     </a>
    </p>
    <p style="margin-left:120px">
    </p>
    <p style="margin-left:40px">
     <a href="#%E6%96%B9%E6%B3%952%3A%E6%95%B0%E7%BB%84" rel="nofollow">
      方法2:数组
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E9%87%8D%E8%A6%81%E7%82%B9%3A%E6%8C%87%E9%92%88%E8%B6%8A%E7%95%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">
      重要点:指针越界的解决方法
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E6%96%B9%E6%B3%951%3A%E5%8D%95%E7%8B%AC%E5%88%A4%E6%96%AD" rel="nofollow">
      方法1:单独判断
     </a>
    </p>
    <p style="margin-left:120px">
     <a href="#%E6%96%B9%E6%B3%952%3A%E5%8F%96%E6%A8%A1" rel="nofollow">
      方法2:取模
     </a>
    </p>
    <p style="margin-left:0px">
     <a href="#3.%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E7%9A%84%E9%80%90%E6%AD%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">
      3.数组代码的逐步实现
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%E6%96%B9%E6%B3%951%3A%E8%B6%8A%E7%95%8C%E6%97%B6%E5%8D%95%E7%8B%AC%E5%88%A4%E6%96%AD" rel="nofollow">
      方法1:越界时单独判断
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%8F%90%E4%BA%A4%E7%BB%93%E6%9E%9C" rel="nofollow">
      提交结果
     </a>
    </p>
    <p style="margin-left:40px">
     <a href="#%E6%96%B9%E6%B3%952%3A%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%8F%96%E6%A8%A1" rel="nofollow">
      方法2:每次都取模
     </a>
    </p>
    <p style="margin-left:80px">
     <a href="#%E6%8F%90%E4%BA%A4%E7%BB%93%E6%9E%9C" rel="nofollow">
      提交结果
     </a>
    </p>
    <hr/>
    <h2>
     1.题目
    </h2>
    <p>
     <a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/" rel="nofollow" title="https://leetcode.cn/problems/design-circular-queue/">
      https://leetcode.cn/problems/design-circular-queue/
     </a>
    </p>
    <blockquote>
     <p>
      设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
     </p>
     <p>
      循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
     </p>
     <p>
      你的实现应该支持如下操作：
     </p>
     <ul>
      <li>
       <code>
        MyCircularQueue(k)
       </code>
       : 构造器，设置队列长度为 k 。
      </li>
      <li>
       <code>
        Front
       </code>
       : 从队首获取元素。如果队列为空，返回 -1 。
      </li>
      <li>
       <code>
        Rear
       </code>
       : 获取队尾元素。如果队列为空，返回 -1 。
      </li>
      <li>
       <code>
        enQueue(value)
       </code>
       : 向循环队列插入一个元素。如果成功插入则返回真。
      </li>
      <li>
       <code>
        deQueue()
       </code>
       : 从循环队列中删除一个元素。如果成功删除则返回真。
      </li>
      <li>
       <code>
        isEmpty()
       </code>
       : 检查循环队列是否为空。
      </li>
      <li>
       <code>
        isFull()
       </code>
       : 检查循环队列是否已满。
      </li>
     </ul>
     <p>
     </p>
     <p>
      <strong>
       示例：
      </strong>
     </p>
     <pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4</pre>
     <p>
     </p>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       所有的值都在 0 至 1000 的范围内；
      </li>
      <li>
       操作数将在 1 至 1000 的范围内；
      </li>
      <li>
       请不要使用内置的队列库。
      </li>
     </ul>
    </blockquote>
    <h2>
     2.分析
    </h2>
    <h3>
     方法1:链表
    </h3>
    <p>
     看到本题,很容易想到用链表解
    </p>
    <h4>
     尝试使用单向循环链表模拟
    </h4>
    <p>
     例如k==3,很容易想到开辟三个空节点
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/44d037b51f6441d988420caf7633e32b.png"/>
    </p>
    <p>
     要访问循环队列的头和尾,需要两个指针front(头指针)和rear(尾指针),初始状态下,链表为空时,front和rear都指向同一个节点
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/134505c2ccbd48539749c6bb665427a8.png"/>
    </p>
    <p>
     现检测链表的功能是否能正常执行
    </p>
    <p>
     插入节点
    </p>
    <p>
     每插入一个元素,按队列"先进先出"原则,应该rear++,如下图:
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/6500c35944224180b09c1d691e45e20b.png"/>
    </p>
    <p>
     当队列满时,如下图:
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/db98602956444a59b749e1a8039c887e.png"/>
    </p>
    <p style="text-align:center">
     <span style="color:#fe2c24">
      <strong>
       发现问题:队列为空或满时,front和rear都指向同一个节点,无法区分
      </strong>
     </span>
    </p>
    <p>
     解决方法1:开辟(k+1)个节点
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7da23910cc90464eb6e089fcec946863.png"/>
    </p>
    <p>
     增加一个节点后,当队列满时,rear-&gt;next==front;当队列为空时,rear==front
    </p>
    <p>
     解决方法2:使用变量size记录队列元素个数
    </p>
    <p>
     当队列为空时,size==0;当队列满时,size==k.以此来区分两种情况
    </p>
    <p>
     获取队尾元素
    </p>
    <p>
     无论开辟(k+1)个节点还是使用变量size记录队列元素个数,rear都指向尾节点的下一个节点,需要找尾(时间复杂度为
     <img class="mathcode" src="https://latex.csdn.net/eq?O%28N%29">
      ,较消耗时间),或者另外使用一个rear_prev变量来记录rear指向节点的前一个节点,或者使用双向链表
     </img>
    </p>
    <p>
     其他函数的实现说明
    </p>
    <p>
     从队首获取元素:返回front指向的节点的值即可
    </p>
    <p>
     删除一个元素:front++
    </p>
    <h3>
     方法2:数组
    </h3>
    <p>
     讲讲和链表的不同点:
    </p>
    <p>
     重要点:指针越界的解决方法
    </p>
    <p>
     1.无论开辟(k+1)个节点还是使用变量size记录队列元素个数,front和rear都有
     <span style="color:#fe2c24">
      <strong>
       越界
      </strong>
     </span>
     的可能性
    </p>
    <p>
     以开辟(k+1)个节点举例:
    </p>
    <p>
     例如下图,再插入一个元素,如果rear++,则会越界
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/118bd6df474a41a7ae79121df9acf8da.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/901ff92d2b0849fbb7ae3c63ec63b009.png"/>
    </p>
    <p>
     例如下图,再删除一个元素,如果front++,则会越界
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/7af43694568e4da4aa64e8281f86dd01.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/948a4c705b584715b4d77ca603bba7f8.png"/>
    </p>
    <p>
     2.获取队尾元素时,可能出现rear越界访问的情况
    </p>
    <p>
     当队列不为空时,直接访问return obj-&gt;arr[obj-&gt;rear-1];可能访问到obj-&gt;arr[-1]的位置,可以单独判断或者对rear取模
    </p>
    <p>
     方法1:单独判断
    </p>
    <p>
     如果rear+1越界,则rear=0;如果front+1越界,则front=0;
    </p>
    <p>
     方法2:取模
    </p>
    <p>
     队列未满时,插入元素:当rear==k时,再插入元素时rear++,之后处理越界的rear,使其等于0,则,rear==(rear+1)%(k+1)
    </p>
    <p>
     队列不为空时,删除元素:当front==k时,再插入元素时front++,之后处理越界的front,使其等于0,则,front==(front+1)%(k+1)
    </p>
    <p>
     队列不为空时,访问队尾元素:例如rear==0,要访问到rear==k的位置,即arr[(rear-1+k+1)%(k+1)==arr[(rear+k)%(k+1)
    </p>
    <p>
     判断队列是否已满,如果满了,例如rear==k,要使rear的下一个为front==0,即判断(rear+1)%(k+1)==front
    </p>
    <h2>
     3.数组代码的逐步实现
    </h2>
    <p>
     读题可知:如果用数组来模拟循环队列,那么结构体成员变量应该有4个
    </p>
    <blockquote>
     <p>
      1.指向数组的指针a,类型为int*
     </p>
     <p>
      2.队首和队尾各需要一个变量来访问:front和rear,类型都为int,充当数组a的下标
     </p>
     <p>
      3.队列的长度k,类型为int
     </p>
    </blockquote>
    <p>
     显然应该用malloc在堆区上开辟空间,接收的指针为结构体指针,否则函数返回后,栈区空间会被销毁
    </p>
    <p>
     之后初始化结构体的成员变量
    </p>
    <h3>
     方法1:越界时单独判断
    </h3>
    <pre><code class="language-cpp">typedef struct 
{
    int* arr;
    int front;
    int rear;
    int k;
} MyCircularQueue;


MyCircularQueue* myCircularQueueCreate(int k) 
{
    MyCircularQueue* obj=(MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    obj-&gt;arr=(int*)malloc(sizeof(int)*(k+1));
    obj-&gt;front=obj-&gt;rear=0;
    obj-&gt;k=k;
    return obj;
}

bool myCircularQueueIsFull(MyCircularQueue* obj);//先声明
bool myCircularQueueIsEmpty(MyCircularQueue* obj);//先声明
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) 
{
    if (myCircularQueueIsFull(obj))
        return false;
    if (obj-&gt;rear!=obj-&gt;k)
        obj-&gt;arr[obj-&gt;rear++]=value;
    else
        obj-&gt;rear=0;
        obj-&gt;arr[obj-&gt;k]=value;
    
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) 
{
    if (myCircularQueueIsEmpty(obj))
        return false;
    if (obj-&gt;front!=obj-&gt;k)
        obj-&gt;front++;
    else
        obj-&gt;front=0;
    return true;

}

int myCircularQueueFront(MyCircularQueue* obj) 
{
    if (myCircularQueueIsEmpty(obj))
        return -1;
    return obj-&gt;arr[obj-&gt;front];
}

int myCircularQueueRear(MyCircularQueue* obj) 
{
    if (myCircularQueueIsEmpty(obj))
        return -1;
    if (obj-&gt;rear)//rear!=0
        return obj-&gt;arr[obj-&gt;rear-1];
    //rear==0
    return obj-&gt;arr[obj-&gt;k];
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) 
{
    return obj-&gt;front==obj-&gt;rear;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) 
{
    int rear_copy=obj-&gt;rear;
    if (rear_copy+1==obj-&gt;front)
        return true;
    else if (rear_copy==obj-&gt;k &amp;&amp; obj-&gt;front==0)
        return true;
    else
        return false;
}

void myCircularQueueFree(MyCircularQueue* obj) 
{
    free(obj-&gt;arr);
    free(obj);
}</code></pre>
    <p>
     代码还可以精简些,例如
    </p>
    <pre><code class="language-cpp">bool myCircularQueueIsFull(MyCircularQueue* obj) 
{
    return (obj-&gt;rear+1==obj-&gt;front) || (obj-&gt;rear==obj-&gt;k &amp;&amp; obj-&gt;front==0);
}
</code></pre>
    <h4>
     提交结果
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/d6fdd69b1acd445eb3fb110d899e0757.png"/>
    </p>
    <h3>
     方法2:每次都取模
    </h3>
    <p>
     <span style="color:#fe2c24">
      <strong>
       <span style="background-color:#fef2f0">
        ★注意:rear++或者front++后一定要取模!
       </span>
      </strong>
     </span>
    </p>
    <pre><code class="language-cpp">typedef struct 
{
    int* arr;
    int front;
    int rear;
    int k;
} MyCircularQueue;


MyCircularQueue* myCircularQueueCreate(int k) 
{
    MyCircularQueue* obj=(MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    obj-&gt;arr=(int*)malloc(sizeof(int)*(k+1));
    obj-&gt;front=obj-&gt;rear=0;
    obj-&gt;k=k;
    return obj;
}

bool myCircularQueueIsFull(MyCircularQueue* obj);//先声明
bool myCircularQueueIsEmpty(MyCircularQueue* obj);//先声明
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) 
{
    if (myCircularQueueIsFull(obj))
        return false;
    obj-&gt;arr[obj-&gt;rear++]=value;
    obj-&gt;rear%=obj-&gt;k+1;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) 
{
    if (myCircularQueueIsEmpty(obj))
        return false;
    obj-&gt;front++;
    obj-&gt;front%=(obj-&gt;k+1);
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) 
{
    if (myCircularQueueIsEmpty(obj))
        return -1;
    return obj-&gt;arr[obj-&gt;front];
}

int myCircularQueueRear(MyCircularQueue* obj) 
{
    if (myCircularQueueIsEmpty(obj))
        return -1;
    return obj-&gt;arr[(obj-&gt;rear-1+obj-&gt;k+1)%(obj-&gt;k+1)];
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) 
{
    return obj-&gt;front==obj-&gt;rear;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) 
{
    return (obj-&gt;rear+1)%(obj-&gt;k+1)==obj-&gt;front;
}

void myCircularQueueFree(MyCircularQueue* obj) 
{
    free(obj-&gt;arr);
    free(obj);
}</code></pre>
    <h4>
     提交结果
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/1ee755f08a03499b98242ebea95511e4.png"/>
    </p>
    <p>
     注:有关本题的链表解法参见下一篇
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38353832383631312f:61727469636c652f64657461696c732f313434363138343635" class_="artid" style="display:none">
 </p>
</div>


