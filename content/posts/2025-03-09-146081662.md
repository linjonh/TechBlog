---
layout: post
title: "MySQL中IN关键字与EXIST关键字的比较"
date: 2025-03-09 18:00:00 +0800
description: "答：当 id 无 NULL 值且唯一时，两者功能一致。另外，第二句中的子查询使用 SELECT 1（最佳实践，无需实际列值）。通常情况下（id是主键，tableA 和 tableB 数据量较大，id 字段有索引。），第二句效率更高。，生成一个临时结果集（如。在上述流程中，子查询。是否在临时结果集中。"
keywords: "mysql exist"
categories: ['计算机面经']
tags: ['数据库', 'Mysql', 'Android']
artid: "146081662"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146081662
    alt: "MySQL中IN关键字与EXIST关键字的比较"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146081662
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146081662
cover: https://bing.ee123.net/img/rand?artid=146081662
image: https://bing.ee123.net/img/rand?artid=146081662
img: https://bing.ee123.net/img/rand?artid=146081662
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     MySQL中IN关键字与EXIST关键字的比较
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <br/>
    问题：
    <br/>
    首先说明下面两句MYSQL语句实现的功能是否一样，接着比较它们的执行效率：
    <p>
    </p>
    <pre><code class="prism language-mysql">SELECT * from tableA where tableA.id in (select id from tableB)
</code></pre>
    <pre><code class="prism language-mysql">SELECT * FROM tableA 
WHERE EXISTS (SELECT 1 FROM tableB WHERE tableA.id = tableB.id);
</code></pre>
    <p>
     答：当 id 无 NULL 值且唯一时，两者功能一致。另外，第二句中的子查询使用 SELECT 1（最佳实践，无需实际列值）。通常情况下（id是主键，tableA 和 tableB 数据量较大，id 字段有索引。），第二句效率更高。
    </p>
    <hr/>
    <h4>
     <a id="_15">
     </a>
     <strong>
      功能等价性分析
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        场景
       </th>
       <th>
        <code>
         IN
        </code>
        的行为
       </th>
       <th>
        <code>
         EXISTS
        </code>
        的行为
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         子查询无
         <code>
          NULL
         </code>
         值
        </strong>
       </td>
       <td>
        等价
       </td>
       <td>
        等价
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         子查询含
         <code>
          NULL
         </code>
         值
        </strong>
       </td>
       <td>
        <code>
         tableA.id IN (1, NULL)
        </code>
        等价于
        <code>
         tableA.id=1 OR tableA.id=NULL
        </code>
        ，最终只有
        <code>
         id=1
        </code>
        的行匹配
       </td>
       <td>
        <code>
         EXISTS
        </code>
        只要子查询有匹配（即使含
        <code>
         NULL
        </code>
        ）就会返回
        <code>
         TRUE
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      结论
     </strong>
     ：
    </p>
    <ul>
     <li>
      当
      <code>
       tableB.id
      </code>
      <strong>
       无
       <code>
        NULL
       </code>
       值且唯一
      </strong>
      时，两者功能一致。
     </li>
     <li>
      当
      <code>
       tableB.id
      </code>
      含
      <code>
       NULL
      </code>
      或重复值时，结果可能不同。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_28">
     </a>
     <strong>
      执行计划分析
     </strong>
     ：
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        方法
       </th>
       <th>
        优化策略
       </th>
       <th>
        适用场景
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         <code>
          IN
         </code>
         子查询
        </strong>
       </td>
       <td>
        MySQL 可能将子查询物化为临时表，再通过
        <code>
         JOIN
        </code>
        或半连接优化。
       </td>
       <td>
        子查询结果集较小时效率高。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         <code>
          EXISTS
         </code>
        </strong>
       </td>
       <td>
        对
        <code>
         tableA
        </code>
        的每一行触发一次关联子查询，利用索引快速定位。
       </td>
       <td>
        <code>
         tableA
        </code>
        较小且
        <code>
         tableB.id
        </code>
        有索引时效率高。
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <a id="1_EXISTS__34">
     </a>
     <strong>
      1.
      <code>
       EXISTS
      </code>
      的工作原理
     </strong>
    </h4>
    <p>
     <code>
      EXISTS
     </code>
     是一种
     <strong>
      关联子查询
     </strong>
     （Correlated Subquery），其核心逻辑是：
     <br/>
     <strong>
      对于外层查询（
      <code>
       tableA
      </code>
      ）的每一行，触发一次内层子查询（
      <code>
       tableB
      </code>
      ）的检查
     </strong>
     。
     <br/>
     具体流程如下：
    </p>
    <h5>
     <a id="_39">
     </a>
     <strong>
      步骤拆解
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        遍历外层表（
        <code>
         tableA
        </code>
        ）
       </strong>
       ：
       <br/>
       逐行读取
       <code>
        tableA
       </code>
       的数据，取当前行的
       <code>
        id
       </code>
       值（例如
       <code>
        id=100
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        执行子查询（
        <code>
         tableB
        </code>
        ）
       </strong>
       ：
       <br/>
       将外层
       <code>
        tableA.id=100
       </code>
       传入子查询，检查
       <code>
        tableB
       </code>
       中是否存在匹配的
       <code>
        id
       </code>
       ：
      </p>
      <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> tableB <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">-- 当前外层行的 id 值</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        判断结果
       </strong>
       ：
      </p>
      <ul>
       <li>
        若子查询返回至少一行结果 →
        <code>
         EXISTS
        </code>
        为
        <code>
         TRUE
        </code>
        → 保留当前外层行。
       </li>
       <li>
        若子查询无结果 →
        <code>
         EXISTS
        </code>
        为
        <code>
         FALSE
        </code>
        → 丢弃当前外层行。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        循环处理
       </strong>
       ：
       <br/>
       重复上述过程，直到
       <code>
        tableA
       </code>
       所有行处理完毕。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="2__58">
     </a>
     <strong>
      2. 为什么需要“利用索引快速定位”？
     </strong>
    </h4>
    <p>
     在上述流程中，子查询
     <code>
      SELECT 1 FROM tableB WHERE id=100
     </code>
     需要快速判断
     <code>
      id=100
     </code>
     是否存在。
     <br/>
     若
     <code>
      tableB.id
     </code>
     <strong>
      没有索引
     </strong>
     ：
    </p>
    <ul>
     <li>
      数据库需对
      <code>
       tableB
      </code>
      进行全表扫描 → 时间复杂度为 O(N)，性能极差（尤其当
      <code>
       tableB
      </code>
      数据量大时）。
     </li>
    </ul>
    <p>
     若
     <code>
      tableB.id
     </code>
     <strong>
      有索引
     </strong>
     （如主键索引或普通索引）：
    </p>
    <ul>
     <li>
      数据库通过索引（如 B+Tree）直接定位到
      <code>
       id=100
      </code>
      → 时间复杂度为 O(logN)，效率极高。
     </li>
    </ul>
    <h5>
     <a id="_66">
     </a>
     <strong>
      索引作用示例
     </strong>
     ：
    </h5>
    <ul>
     <li>
      假设
      <code>
       tableB
      </code>
      有 100 万行数据：
      <ul>
       <li>
        无索引：每次子查询需扫描 100 万行 → 总成本：1,000,000（外层行数） × 1,000,000（内层扫描） → 不可接受。
       </li>
       <li>
        有索引：每次子查询仅需 3~4 次磁盘 I/O（B+Tree 高度） → 总成本：1,000,000（外层行数） × 4（索引查询） → 高效。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="3__IN__73">
     </a>
     <strong>
      3. 与
      <code>
       IN
      </code>
      子查询的对比
     </strong>
    </h4>
    <h5>
     <a id="IN__74">
     </a>
     <strong>
      <code>
       IN
      </code>
      的工作方式
     </strong>
     ：
    </h5>
    <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tableA <span class="token keyword">WHERE</span> id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> tableB<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <ol>
     <li>
      <p>
       <strong>
        执行子查询
       </strong>
       ：
       <br/>
       先执行
       <code>
        SELECT id FROM tableB
       </code>
       ，生成一个临时结果集（如
       <code>
        [1, 2, 3]
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        遍历外层表（
        <code>
         tableA
        </code>
        ）
       </strong>
       ：
       <br/>
       逐行检查
       <code>
        tableA.id
       </code>
       是否在临时结果集中。
      </p>
     </li>
    </ol>
    <h5>
     <a id="_84">
     </a>
     <strong>
      关键差异
     </strong>
     ：
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        <code>
         EXISTS
        </code>
       </th>
       <th>
        <code>
         IN
        </code>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         子查询执行次数
        </strong>
       </td>
       <td>
        外层表行数（N次）
       </td>
       <td>
        1次
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         临时表物化
        </strong>
       </td>
       <td>
        无需物化
       </td>
       <td>
        需要物化子查询结果到临时表
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         索引依赖
        </strong>
       </td>
       <td>
        依赖内层表（
        <code>
         tableB
        </code>
        ）的索引
       </td>
       <td>
        依赖外层表（
        <code>
         tableA
        </code>
        ）的索引
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         NULL 值处理
        </strong>
       </td>
       <td>
        不受子查询中 NULL 影响
       </td>
       <td>
        <code>
         IN
        </code>
        遇到 NULL 可能导致结果异常
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="4__94">
     </a>
     <strong>
      4. 性能优化核心
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         EXISTS
        </code>
        高效的核心条件
       </strong>
       ：
      </p>
      <ul>
       <li>
        内层表（
        <code>
         tableB
        </code>
        ）的关联字段（
        <code>
         id
        </code>
        ）必须有索引。
       </li>
       <li>
        外层表（
        <code>
         tableA
        </code>
        ）的数据量不宜过大（否则逐行触发子查询的总成本仍可能较高）。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         IN
        </code>
        高效的核心条件
       </strong>
       ：
      </p>
      <ul>
       <li>
        子查询结果集较小，且外层表（
        <code>
         tableA
        </code>
        ）的
        <code>
         id
        </code>
        字段有索引。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="5__104">
     </a>
     <strong>
      5. 实际案例验证
     </strong>
    </h4>
    <h5>
     <a id="_105">
     </a>
     <strong>
      场景
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <code>
       tableA
      </code>
      ：10,000 行，
      <code>
       id
      </code>
      无索引
     </li>
     <li>
      <code>
       tableB
      </code>
      ：1,000,000 行，
      <code>
       id
      </code>
      有唯一索引
     </li>
    </ul>
    <h5>
     <a id="_109">
     </a>
     <strong>
      执行计划分析
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         EXISTS
        </code>
        查询
       </strong>
       ：
      </p>
      <ul>
       <li>
        对
        <code>
         tableA
        </code>
        的 10,000 行逐行触发子查询。
       </li>
       <li>
        每次子查询通过索引在
        <code>
         tableB
        </code>
        中快速定位 → 总成本 ≈ 10,000 × 4 I/O = 40,000 I/O。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         IN
        </code>
        查询
       </strong>
       ：
      </p>
      <ul>
       <li>
        先执行
        <code>
         SELECT id FROM tableB
        </code>
        ，生成 1,000,000 行的临时表。
       </li>
       <li>
        对
        <code>
         tableA
        </code>
        的 10,000 行逐行在临时表中搜索 → 总成本 ≈ 1,000,000（物化） + 10,000 × 1,000,000（全扫描） → 性能灾难。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="_118">
     </a>
     <strong>
      结果
     </strong>
     ：
    </h5>
    <ul>
     <li>
      <strong>
       <code>
        EXISTS
       </code>
       明显优于
       <code>
        IN
       </code>
      </strong>
      ，尤其在子查询结果集大且内层表有索引时。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="6__123">
     </a>
     <strong>
      6. 总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       <code>
        EXISTS
       </code>
       的本质
      </strong>
      ：通过外层表驱动循环 + 内层索引快速定位，避免全表扫描。
     </li>
     <li>
      <strong>
       何时选择
       <code>
        EXISTS
       </code>
      </strong>
      ：
      <ul>
       <li>
        内层表（子查询表）的关联字段有索引。
       </li>
       <li>
        外层表数据量适中，或内层表数据量远大于外层表。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       验证方法
      </strong>
      ：
      <pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tableA 
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> tableB <span class="token keyword">WHERE</span> tableA<span class="token punctuation">.</span>id <span class="token operator">=</span> tableB<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      检查执行计划中是否出现
      <strong>
       <code>
        Using index
       </code>
      </strong>
      （表示索引生效）。
     </li>
    </ul>
    <h5>
     <a id="_135">
     </a>
     <strong>
      效率总结
     </strong>
     ：
    </h5>
    <ol>
     <li>
      <strong>
       <code>
        EXISTS
       </code>
       通常更高效
      </strong>
      ：
      <ul>
       <li>
        避免物化临时表。
       </li>
       <li>
        通过索引快速判断是否存在匹配。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       <code>
        IN
       </code>
       可能更高效的情况
      </strong>
      ：
      <ul>
       <li>
        子查询结果集非常小且无索引。
       </li>
       <li>
        优化器将
        <code>
         IN
        </code>
        转换为
        <code>
         JOIN
        </code>
        并应用哈希/排序优化。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="5__145">
     </a>
     <strong>
      5. 最终建议
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       优先使用
       <code>
        EXISTS
       </code>
      </strong>
      ：语义更清晰，且通常性能更优。
     </li>
     <li>
      <strong>
       强制功能一致性
      </strong>
      ：若需严格匹配
      <code>
       IN
      </code>
      的行为（处理
      <code>
       NULL
      </code>
      ），可添加过滤条件：
      <pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tableA 
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> tableB 
  <span class="token keyword">WHERE</span> tableA<span class="token punctuation">.</span>id <span class="token operator">=</span> tableB<span class="token punctuation">.</span>id 
  <span class="token operator">AND</span> tableB<span class="token punctuation">.</span>id <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>  <span class="token comment">-- 显式排除 NULL 值</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34363836363334392f:61727469636c652f64657461696c732f313436303831363632" class_="artid" style="display:none">
 </p>
</div>


