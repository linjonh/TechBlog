---
layout: post
title: "2.3-滑动窗口专题最大连续1的个数-IIILeetCode-1004"
date: 2025-03-14 19:48:06 +0800
description: "通过滑动窗口算法高效解决了问题，逻辑清晰且时间复杂度最优。关键在于实时更新最大值和精确控制窗口收缩条件，避免遗漏可能的解。"
keywords: "2.3 滑动窗口专题：最大连续1的个数 III（LeetCode 1004）"
categories: ['每日练习']
tags: ['算法', '数据结构', 'Leetcode', 'C']
artid: "146265840"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146265840
    alt: "2.3-滑动窗口专题最大连续1的个数-IIILeetCode-1004"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146265840
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146265840
cover: https://bing.ee123.net/img/rand?artid=146265840
image: https://bing.ee123.net/img/rand?artid=146265840
img: https://bing.ee123.net/img/rand?artid=146265840
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     2.3 滑动窗口专题：最大连续1的个数 III（LeetCode 1004）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     1. ​
     <strong>
      题目链接
     </strong>
    </h5>
    <p>
     <a class="has-card" href="https://leetcode.cn/problems/max-consecutive-ones-iii/" rel="nofollow" title="1004. 最大连续1的个数 III - 力扣（LeetCode）">
      <span class="link-card-box" contenteditable="false">
       <span class="link-title">
        1004. 最大连续1的个数 III - 力扣（LeetCode）
       </span>
       <span class="link-link">
        <img class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7">
         https://leetcode.cn/problems/max-consecutive-ones-iii/
        </img>
       </span>
      </span>
     </a>
    </p>
    <hr/>
    <h5>
     2. ​
     <strong>
      题目描述
     </strong>
    </h5>
    <p>
     给定一个二进制数组
     <code>
      nums
     </code>
     和一个整数
     <code>
      k
     </code>
     ，允许将最多
     <code>
      k
     </code>
     个 0 翻转为 1，求翻转后最长的连续 1 的子数组长度。
     <br/>
     <strong>
      示例
     </strong>
     ：
     <br/>
     输入：
     <code>
      nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
     </code>
     <br/>
     输出：
     <code>
      6
     </code>
     （最长子数组为
     <code>
      [1,1,1,0,0,1,1,1,1]
     </code>
     ，翻转两个0后连续1的长度为6）
    </p>
    <hr/>
    <h5>
     3. ​
     <strong>
      算法思路
     </strong>
    </h5>
    <p>
     采用
     <strong>
      滑动窗口（双指针）​
     </strong>
     算法：
    </p>
    <ol>
     <li>
      ​
      <strong>
       窗口定义
      </strong>
      ：维护
      <code>
       left
      </code>
      和
      <code>
       right
      </code>
      指针，表示当前窗口范围。
     </li>
     <li>
      ​
      <strong>
       统计0的数量
      </strong>
      ：窗口内允许的0的数量不超过
      <code>
       k
      </code>
      。
     </li>
     <li>
      ​
      <strong>
       窗口扩展
      </strong>
      ：右指针
      <code>
       right
      </code>
      不断右移，遇到0时增加计数。
     </li>
     <li>
      ​
      <strong>
       窗口收缩
      </strong>
      ：当0的数量超过
      <code>
       k
      </code>
      时，左指针
      <code>
       left
      </code>
      右移，直到0的数量合法。
     </li>
    </ol>
    <hr/>
    <h5>
     4. ​
     <strong>
      代码实现分析
     </strong>
    </h5>
    <pre><code class="language-cpp">class Solution
{
public:
    int longestOnes(vector&lt;int&gt;&amp; nums, int k)
    {
        int n = nums.size();
        if (k &gt;= n) return n; // 边界条件

        int left = 0, right = 0;
        int zeroCount = 0, maxLen = 0, curLen = 0;
        // 进窗口
        for (right = 0; right &lt; n ; right++)
        {
            if (nums[right] == 0) zeroCount++;
            // 出窗口
            while (zeroCount &gt; k)
            {
                
                if (nums[left++] == 0) zeroCount--;
            }
            // 最长字串更新
            maxLen = max(right - left + 1, maxLen);
        }
        return maxLen;
    }
};</code></pre>
    <p>
     <strong>
      关键点解析
     </strong>
     ：
    </p>
    <ol>
     <li>
      ​
      <strong>
       边界处理
      </strong>
      ：
      <code>
       k &gt;= n
      </code>
      时直接返回数组长度，因为可以翻转所有0。
     </li>
     <li>
      ​
      <strong>
       滑动窗口逻辑
      </strong>
      ：
      <ul>
       <li>
        ​
        <strong>
         右指针扩展
        </strong>
        ：每次移动右指针并统计0的数量。
       </li>
       <li>
        ​
        <strong>
         左指针收缩
        </strong>
        ：当0的数量超过
        <code>
         k
        </code>
        时，左指针右移，直到窗口合法。
       </li>
      </ul>
     </li>
     <li>
      ​
      <strong>
       时间复杂度
      </strong>
      ：O(n)，每个元素最多被访问两次（左、右指针各一次）。
     </li>
    </ol>
    <hr/>
    <h5>
     4. ​
     <strong>
      总结
     </strong>
    </h5>
    <p>
     该代码通过滑动窗口算法高效解决了问题，逻辑清晰且时间复杂度最优。关键在于
     <strong>
      实时更新最大值
     </strong>
     和
     <strong>
      精确控制窗口收缩条件
     </strong>
     ，避免遗漏可能的解。
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         对比维度
        </strong>
       </th>
       <th>
        ​
        <strong>
         暴力枚举法
        </strong>
       </th>
       <th>
        ​
        <strong>
         滑动窗口法
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        ​
        <strong>
         核心思想
        </strong>
       </td>
       <td>
        遍历所有可能的子数组，检查是否可以通过翻转最多
        <code>
         k
        </code>
        个 0 变成全 1 的子数组。
       </td>
       <td>
        维护一个动态窗口，窗口内最多允许
        <code>
         k
        </code>
        个 0，通过调整左右指针高效寻找最长子数组。
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         时间复杂度
        </strong>
       </td>
       <td>
        O(n²)（双重循环枚举所有子数组起点和终点，每个子数组统计0的时间为 O(1)*）。
       </td>
       <td>
        O(n)（每个元素仅被左右指针访问一次，总操作次数为 2n）。
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         空间复杂度
        </strong>
       </td>
       <td>
        O(1)（无需额外存储结构）。
       </td>
       <td>
        O(1)（仅需常数变量记录0的数量和指针位置）。
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         实现方式
        </strong>
       </td>
       <td>
        1. 双重循环枚举所有子数组起点
        <code>
         i
        </code>
        和终点
        <code>
         j
        </code>
        。
        <br/>
        2. 对每个子数组
        <code>
         [i, j]
        </code>
        ，统计其中 0 的数量是否 ≤
        <code>
         k
        </code>
        。
       </td>
       <td>
        1. 右指针
        <code>
         right
        </code>
        不断右移，统计窗口内 0 的数量。
        <br/>
        2. 若 0 的数量超过
        <code>
         k
        </code>
        ，左指针
        <code>
         left
        </code>
        右移直到合法。
        <br/>
        3. 实时更新最大窗口长度。
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        数据规模极小（如 n ≤ 100）。
       </td>
       <td>
        数据规模大（如 n ≥ 1e4），需高效处理连续子数组问题。
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         优点
        </strong>
       </td>
       <td>
        实现简单，逻辑直观，适合验证算法正确性。
       </td>
       <td>
        时间复杂度最优，避免冗余计算，适用于高频或大规模数据场景。
       </td>
      </tr>
      <tr>
       <td>
        ​
        <strong>
         缺点
        </strong>
       </td>
       <td>
        数据规模大时性能极差（例如 n=1e4 时需 1e8 次操作）。
       </td>
       <td>
        需合理控制窗口收缩逻辑，对边界条件处理要求较高（如
        <code>
         k=0
        </code>
        或全为 0 的数组）。
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f73687569627578696e676161612f:61727469636c652f64657461696c732f313436323635383430" class_="artid" style="display:none">
 </p>
</div>


