---
layout: post
title: "Linux驱动开发进阶-文件系统"
date: 2025-03-16 21:23:57 +08:00
description: "Linux驱动开发进阶 - 文件系统"
keywords: "Linux驱动开发进阶 - 文件系统"
categories: ['嵌入式Linux驱动']
tags: ['驱动开发', '文件系统', 'Linux']
artid: "146301696"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146301696
    alt: "Linux驱动开发进阶-文件系统"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146301696
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146301696
cover: https://bing.ee123.net/img/rand?artid=146301696
image: https://bing.ee123.net/img/rand?artid=146301696
img: https://bing.ee123.net/img/rand?artid=146301696
---

# Linux驱动开发进阶 - 文件系统
## 1、前言
1. 学习参考书籍：[李文山的《Linux驱动开发进阶》](https://gitee.com/li-shan-asked/linux-advanced-development-code)
2. 本文是为了学习上述书籍时，不能囫囵吞枣，才写的。等实际遇到问题了，我也只会去回看原书籍。所以本文不太具备教学功能。
## 2、学习目标
在Linux中，文件系统可以分为两大类：虚拟文件系统（如sysfs、procfs、devtmpfs）和实际物理存储设备的文件系统（如ext2、ext3、ext4、vfat、fat32）。那Linux如何管理这些文件系统呢？同时本文将在最后编写一个虚拟的文件系统驱动程序。
## 3、VFS虚拟文件系统
Linux内核的设计哲学非常注重抽象和模块化，这种设计使得系统更加灵活、可扩展且易于维护。Linux为了管理各种类型的文件系统（sysfs、procfs、ext2、ext3、ext4、fat32、…），抽象出了
VFS（Virtual File System Switch，虚拟文件系统切换层）。
![画板](https://i-blog.csdnimg.cn/img\_convert/ef906d64ec6e3bc2f6a34063fb620e6c.jpeg#pic\_center)
一个功能的诞生肯定是为了解决实际问题，那VFS虚拟文件系统的诞生也是为了管理众多不同的文件系统。在Linux的VFS虚拟文件系统中，有四个核心对象是理解和实现文件系统的关键，分别是：超级块（Super
Block）、索引节点（Inode）、目录项（Dentry）和文件对象（File）。
### 3.1、超级块（Super Block）
在Linux文件系统中，许多文件系统本身就存在显示的超级块，如ext2、ext3、ext4。它们在分区的第一个块（或前几个块）中存储了超级块。超级块包含了文件系统的元数据，如总块数、总Inode数、块大小、文件系统状态等。
但不是所有的文件系统都显示存在超级块，如Windows下常用的文件系统，如ntfs、fat32等，它们有自己的结构来存储文件系统的元数据和管理信息，这些结构在功能上类似于超级块，但名称和具体实现不同。
在Linux下，无论该文件系统是否存在超级块，挂载时必须初始化超级块数据结构。
struct super\_block {
struct list\_head s\_list; /\* Keep this first \*/
dev\_t s\_dev; /\* search index; \_not\_ kdev\_t \*/
unsigned char s\_blocksize\_bits;
unsigned long s\_blocksize;
loff\_t s\_maxbytes; /\* Max file size \*/
struct file\_system\_type \*s\_type;
const struct super\_operations \*s\_op;
const struct dquot\_operations \*dq\_op;
const struct quotactl\_ops \*s\_qcop;
const struct export\_operations \*s\_export\_op;
unsigned long s\_flags;
unsigned long s\_iflags; /\* internal SB\_I\_\* flags \*/
unsigned long s\_magic;
struct dentry \*s\_root;
struct rw\_semaphore s\_umount;
int s\_count;
atomic\_t s\_active;
#ifdef CONFIG\_SECURITY
void \*s\_security;
#endif
const struct xattr\_handler \*\*s\_xattr;
#ifdef CONFIG\_FS\_ENCRYPTION
const struct fscrypt\_operations \*s\_cop;
#ifdef \_\_GENKSYMS\_\_
/\*
\* Android ABI CRC preservation due to commit 391cceee6d43 ("fscrypt:
\* stop using keyrings subsystem for fscrypt\_master\_key") changing this
\* type. Size is the same, this is a private field.
\*/
struct key \*s\_master\_keys; /\* master crypto keys in use \*/
#else
struct fscrypt\_keyring \*s\_master\_keys; /\* master crypto keys in use \*/
#endif
#endif
#ifdef CONFIG\_FS\_VERITY
const struct fsverity\_operations \*s\_vop;
#endif
#ifdef CONFIG\_UNICODE
struct unicode\_map \*s\_encoding;
\_\_u16 s\_encoding\_flags;
#endif
struct hlist\_bl\_head s\_roots; /\* alternate root dentries for NFS \*/
struct list\_head s\_mounts; /\* list of mounts; \_not\_ for fs use \*/
struct block\_device \*s\_bdev;
struct backing\_dev\_info \*s\_bdi;
struct mtd\_info \*s\_mtd;
struct hlist\_node s\_instances;
unsigned int s\_quota\_types; /\* Bitmask of supported quota types \*/
struct quota\_info s\_dquot; /\* Diskquota specific options \*/
struct sb\_writers s\_writers;
/\*
\* Keep s\_fs\_info, s\_time\_gran, s\_fsnotify\_mask, and
\* s\_fsnotify\_marks together for cache efficiency. They are frequently
\* accessed and rarely modified.
\*/
void \*s\_fs\_info; /\* Filesystem private info \*/
/\* Granularity of c/m/atime in ns (cannot be worse than a second) \*/
u32 s\_time\_gran;
/\* Time limits for c/m/atime in seconds \*/
time64\_t s\_time\_min;
time64\_t s\_time\_max;
#ifdef CONFIG\_FSNOTIFY
\_\_u32 s\_fsnotify\_mask;
struct fsnotify\_mark\_connector \_\_rcu \*s\_fsnotify\_marks;
#endif
char s\_id[32]; /\* Informational name \*/
uuid\_t s\_uuid; /\* UUID \*/
unsigned int s\_max\_links;
fmode\_t s\_mode;
/\*
\* The next field is for VFS \*only\*. No filesystems have any business
\* even looking at it. You had been warned.
\*/
struct mutex s\_vfs\_rename\_mutex; /\* Kludge \*/
/\*
\* Filesystem subtype. If non-empty the filesystem type field
\* in /proc/mounts will be "type.subtype"
\*/
const char \*s\_subtype;
const struct dentry\_operations \*s\_d\_op; /\* default d\_op for dentries \*/
/\*
\* Saved pool identifier for cleancache (-1 means none)
\*/
int cleancache\_poolid;
struct shrinker s\_shrink; /\* per-sb shrinker handle \*/
/\* Number of inodes with nlink == 0 but still referenced \*/
atomic\_long\_t s\_remove\_count;
/\* Pending fsnotify inode refs \*/
atomic\_long\_t s\_fsnotify\_inode\_refs;
/\* Being remounted read-only \*/
int s\_readonly\_remount;
/\* per-sb errseq\_t for reporting writeback errors via syncfs \*/
errseq\_t s\_wb\_err;
/\* AIO completions deferred from interrupt context \*/
struct workqueue\_struct \*s\_dio\_done\_wq;
struct hlist\_head s\_pins;
/\*
\* Owning user namespace and default context in which to
\* interpret filesystem uids, gids, quotas, device nodes,
\* xattrs and security labels.
\*/
struct user\_namespace \*s\_user\_ns;
/\*
\* The list\_lru structure is essentially just a pointer to a table
\* of per-node lru lists, each of which has its own spinlock.
\* There is no need to put them into separate cachelines.
\*/
struct list\_lru s\_dentry\_lru;
struct list\_lru s\_inode\_lru;
struct rcu\_head rcu;
struct work\_struct destroy\_work;
struct mutex s\_sync\_lock; /\* sync serialisation lock \*/
/\*
\* Indicates how deep in a filesystem stack this SB is
\*/
int s\_stack\_depth;
/\* s\_inode\_list\_lock protects s\_inodes \*/
spinlock\_t s\_inode\_list\_lock \_\_\_\_cacheline\_aligned\_in\_smp;
struct list\_head s\_inodes; /\* all inodes \*/
spinlock\_t s\_inode\_wblist\_lock;
struct list\_head s\_inodes\_wb; /\* writeback inodes \*/
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
ANDROID\_KABI\_RESERVE(3);
ANDROID\_KABI\_RESERVE(4);
} \_\_randomize\_layout;
\* `s\_list`：链表结构体，包含prev和next指针，用来连接前驱和后继节点
\* `s\_dev`：块设备标识符，例如/dev/sda、/dev/nvme
\* `s\_blocksize\_bits`：块大小占用的位数，例如块大小为4096则该值为12
\* `s\_blocksize`：数据块大小，单位为字节
\* `s\_maxbytes`：文件的最大长度，单位字节
\* `s\_type`：文件系统类型
\* `s\_op`：超级块操作方法，指向具体的文件系统
\* `dp\_op`：和s\_op一样，但用于特定操作方法
\* `s\_qcop`：和s\_op一样，但用于配置磁盘的特定的操作方法
\* `s\_flags`：文件系统是否安装标志
\* `s\_magic`：文件系统魔数，每个文件系统都有各自的魔数
\* `s\_root`：文件系统的根目录文件
\* `s\_umount`：用于文件系统对文件进行读写同步
\* `s\_count`：超级块的使用计数
\* `s\_active`：超级块的引用计数
\* `s\_security`：用于安全的私有指针
\* `s\_d\_op`：dentry操作方法集合
其中超级块的操作函数结构体struct super\_operations内容如下：
struct super\_operations {
struct inode \*(\*alloc\_inode)(struct super\_block \*sb);
void (\*destroy\_inode)(struct inode \*);
void (\*free\_inode)(struct inode \*);
void (\*dirty\_inode) (struct inode \*, int flags);
int (\*write\_inode) (struct inode \*, struct writeback\_control \*wbc);
int (\*drop\_inode) (struct inode \*);
void (\*evict\_inode) (struct inode \*);
void (\*put\_super) (struct super\_block \*);
int (\*sync\_fs)(struct super\_block \*sb, int wait);
int (\*freeze\_super) (struct super\_block \*);
int (\*freeze\_fs) (struct super\_block \*);
int (\*thaw\_super) (struct super\_block \*);
int (\*unfreeze\_fs) (struct super\_block \*);
int (\*statfs) (struct dentry \*, struct kstatfs \*);
int (\*remount\_fs) (struct super\_block \*, int \*, char \*);
void (\*umount\_begin) (struct super\_block \*);
int (\*show\_options)(struct seq\_file \*, struct dentry \*);
int (\*show\_devname)(struct seq\_file \*, struct dentry \*);
int (\*show\_path)(struct seq\_file \*, struct dentry \*);
int (\*show\_stats)(struct seq\_file \*, struct dentry \*);
#ifdef CONFIG\_QUOTA
ssize\_t (\*quota\_read)(struct super\_block \*, int, char \*, size\_t, loff\_t);
ssize\_t (\*quota\_write)(struct super\_block \*, int, const char \*, size\_t, loff\_t);
struct dquot \*\*(\*get\_dquots)(struct inode \*);
#endif
int (\*bdev\_try\_to\_free\_page)(struct super\_block\*, struct page\*, gfp\_t);
long (\*nr\_cached\_objects)(struct super\_block \*,
struct shrink\_control \*);
long (\*free\_cached\_objects)(struct super\_block \*,
struct shrink\_control \*);
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
ANDROID\_KABI\_RESERVE(3);
ANDROID\_KABI\_RESERVE(4);
};
这些操作方法不用全部实现，下面对部分成员进行说明：
\* `alloc\_inode`：分配一个inode
\* `destroy\_inode`：释放一个硬盘上的inode
\* `free\_inode`：释放内存中的inode
\* `dirty\_inode`：用于将“脏”块标记的方法
\* `write\_inode`：写入数据到inode中
\* `drop\_inode`：当最后一个用户释放inode时调用该函数
\* `put\_super`：释放超级块，卸载文件系统时调用此函数
\* `sync\_fs`：同步文件系统，当有“脏页”时，更新数据
\* `statfs`：查看文件系统信息，例如魔数、文件名最长多少、页大小
### 3.2、dentry
dentry翻译过来叫“目录项”。在上面的struct super\_block结构体里有一个成员s\_root就是struct dentry类型：
struct dentry {
/\* RCU lookup touched fields \*/
unsigned int d\_flags; /\* protected by d\_lock \*/
seqcount\_spinlock\_t d\_seq; /\* per dentry seqlock \*/
struct hlist\_bl\_node d\_hash; /\* lookup hash list \*/
struct dentry \*d\_parent; /\* parent directory \*/
struct qstr d\_name;
struct inode \*d\_inode; /\* Where the name belongs to - NULL is
\* negative \*/
unsigned char d\_iname[DNAME\_INLINE\_LEN]; /\* small names \*/
/\* Ref lookup also touches following \*/
struct lockref d\_lockref; /\* per-dentry lock and refcount \*/
const struct dentry\_operations \*d\_op;
struct super\_block \*d\_sb; /\* The root of the dentry tree \*/
unsigned long d\_time; /\* used by d\_revalidate \*/
void \*d\_fsdata; /\* fs-specific data \*/
union {
struct list\_head d\_lru; /\* LRU list \*/
wait\_queue\_head\_t \*d\_wait; /\* in-lookup ones only \*/
};
struct list\_head d\_child; /\* child of parent list \*/
struct list\_head d\_subdirs; /\* our children \*/
/\*
\* d\_alias and d\_rcu can share memory
\*/
union {
struct hlist\_node d\_alias; /\* inode alias list \*/
struct hlist\_bl\_node d\_in\_lookup\_hash; /\* only for in-lookup ones \*/
struct rcu\_head d\_rcu;
} d\_u;
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
} \_\_randomize\_layout;
\* `d\_flags`：目录项标志
\* `d\_hash`：哈希表表项链表
\* `d\_parent`：父目录
\* `d\_name`：目录名称
\* `d\_inode`：指向目录或文件的inode
\* `d\_iname`：短文件名，当文件名小于DNAME\_INLINE\_LEN时，文件名存储在数组中
\* `d\_op`：目录项操作方法集合
\* `d\_sb`：指向该目录项的超级块指针
\* `d\_child`：同级目录链表
\* `d\_subdirs`：子目录项链表
对于某些文件系统（如
ext2/ext3/ext4、XFS等），它们在磁盘上有一个物理的超级块。dentry并不存在于磁盘中，它是vfs虚拟文件系统抽象出来的一个对象，它只存在于内存中。目录项是文件系统中用于将文件名与inode号关联起来的数据结构，作用是快速定位文件路径，减少路径解析的时间。
![画板](https://i-blog.csdnimg.cn/img\_convert/2e58bf8e82742588b81eb308de4bacf8.jpeg#pic\_center)
struct dentry中的d\_op操作方法集合如下：
struct dentry\_operations {
int (\*d\_revalidate)(struct dentry \*, unsigned int);
int (\*d\_weak\_revalidate)(struct dentry \*, unsigned int);
int (\*d\_hash)(const struct dentry \*, struct qstr \*);
int (\*d\_compare)(const struct dentry \*,
unsigned int, const char \*, const struct qstr \*);
int (\*d\_delete)(const struct dentry \*);
int (\*d\_init)(struct dentry \*);
void (\*d\_release)(struct dentry \*);
void (\*d\_prune)(struct dentry \*);
void (\*d\_iput)(struct dentry \*, struct inode \*);
char \*(\*d\_dname)(struct dentry \*, char \*, int);
struct vfsmount \*(\*d\_automount)(struct path \*);
int (\*d\_manage)(const struct path \*, bool);
struct dentry \*(\*d\_real)(struct dentry \*, const struct inode \*);
void (\*d\_canonical\_path)(const struct path \*, struct path \*);
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
ANDROID\_KABI\_RESERVE(3);
ANDROID\_KABI\_RESERVE(4);
} \_\_\_\_cacheline\_aligned;
\* d\_revalidate：使一个目录项重新生效
\* d\_hash：生成一个哈希值，用于VFS向哈希表中加入一个目录项
\* d\_compare：比较两个目录项名称
\* d\_delete：删除目录项
\* d\_init：初始化目录项
\* d\_release：释放目录项
\* d\_iput：当目录项的inode为NULL时，此时会调用该函数
\* d\_dname：设置目录项名称
上面有例举到，在struct dentry中有一个成员是d\_inode，这里d\_inode就是我们将要介绍的第三个核心对象。
### 3.3、inode
inode描述了磁盘上的文件信息，将所有文件的索引拿出来组成一个表，即inode表（inode
table）。下图展示inode和dentry的关系（图片来自作者李文山的《Linux驱动开发进阶》）：
![](https://i-blog.csdnimg.cn/img\_convert/0a645569862ff279e69ca33332f8bf90.png#pic\_center)
当文件系统需要访问一个文件时，以下步骤会发生：
1. 路径解析：
\* 从根目录开始，逐级解析路径中的每个目录项，找到目标文件的 dentry。
\* 每个目录项在目录文件中存储了文件名和对应的 inode 号。
2. 找到 inode：
\* 通过 dentry 的 `d\_inode` 字段，找到与该文件名关联的 inode 对象。
\* 如果 inode 对象尚未加载到内存中，文件系统会从磁盘读取对应的 inode 数据，并将其加载到内存中的 VFS inode 结构中。
3. 访问文件数据：
\* 通过 inode 中的数据块指针，找到文件数据在磁盘上的实际存储位置。
\* 文件系统通过这些数据块指针读取或写入文件的实际数据。
我们通过struct inode来看看inode存储了什么：
struct inode {
umode\_t i\_mode;
unsigned short i\_opflags;
kuid\_t i\_uid;
kgid\_t i\_gid;
unsigned int i\_flags;
#ifdef CONFIG\_FS\_POSIX\_ACL
struct posix\_acl \*i\_acl;
struct posix\_acl \*i\_default\_acl;
#endif
const struct inode\_operations \*i\_op;
struct super\_block \*i\_sb;
struct address\_space \*i\_mapping;
#ifdef CONFIG\_SECURITY
void \*i\_security;
#endif
/\* Stat data, not accessed from path walking \*/
unsigned long i\_ino;
/\*
\* Filesystems may only read i\_nlink directly. They shall use the
\* following functions for modification:
\*
\* (set|clear|inc|drop)\_nlink
\* inode\_(inc|dec)\_link\_count
\*/
union {
const unsigned int i\_nlink;
unsigned int \_\_i\_nlink;
};
dev\_t i\_rdev;
loff\_t i\_size;
struct timespec64 i\_atime;
struct timespec64 i\_mtime;
struct timespec64 i\_ctime;
spinlock\_t i\_lock; /\* i\_blocks, i\_bytes, maybe i\_size \*/
unsigned short i\_bytes;
u8 i\_blkbits;
u8 i\_write\_hint;
blkcnt\_t i\_blocks;
#ifdef \_\_NEED\_I\_SIZE\_ORDERED
seqcount\_t i\_size\_seqcount;
#endif
/\* Misc \*/
unsigned long i\_state;
struct rw\_semaphore i\_rwsem;
unsigned long dirtied\_when; /\* jiffies of first dirtying \*/
unsigned long dirtied\_time\_when;
struct hlist\_node i\_hash;
struct list\_head i\_io\_list; /\* backing dev IO list \*/
#ifdef CONFIG\_CGROUP\_WRITEBACK
struct bdi\_writeback \*i\_wb; /\* the associated cgroup wb \*/
/\* foreign inode detection, see wbc\_detach\_inode() \*/
int i\_wb\_frn\_winner;
u16 i\_wb\_frn\_avg\_time;
u16 i\_wb\_frn\_history;
#endif
struct list\_head i\_lru; /\* inode LRU list \*/
struct list\_head i\_sb\_list;
struct list\_head i\_wb\_list; /\* backing dev writeback list \*/
union {
struct hlist\_head i\_dentry;
struct rcu\_head i\_rcu;
};
atomic64\_t i\_version;
atomic64\_t i\_sequence; /\* see futex \*/
atomic\_t i\_count;
atomic\_t i\_dio\_count;
atomic\_t i\_writecount;
#if defined(CONFIG\_IMA) || defined(CONFIG\_FILE\_LOCKING)
atomic\_t i\_readcount; /\* struct files open RO \*/
#endif
union {
const struct file\_operations \*i\_fop; /\* former ->i\_op->default\_file\_ops \*/
void (\*free\_inode)(struct inode \*);
};
struct file\_lock\_context \*i\_flctx;
struct address\_space i\_data;
struct list\_head i\_devices;
union {
struct pipe\_inode\_info \*i\_pipe;
struct block\_device \*i\_bdev;
struct cdev \*i\_cdev;
char \*i\_link;
unsigned i\_dir\_seq;
};
\_\_u32 i\_generation;
#ifdef CONFIG\_FSNOTIFY
\_\_u32 i\_fsnotify\_mask; /\* all events this inode cares about \*/
struct fsnotify\_mark\_connector \_\_rcu \*i\_fsnotify\_marks;
#endif
#ifdef CONFIG\_FS\_ENCRYPTION
struct fscrypt\_info \*i\_crypt\_info;
#endif
#ifdef CONFIG\_FS\_VERITY
struct fsverity\_info \*i\_verity\_info;
#endif
void \*i\_private; /\* fs or device private pointer \*/
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
} \_\_randomize\_layout;
\* `i\_mode`：文件的访问权限
\* `i\_op`：inode操作函数集合
\* `i\_sb`：超级块指针，指向文件系统的超级块
\* `i\_mapping`：地址映射描述
\* `i\_nlink`：硬连接数目
\* `i\_rdev`：设备号，在Linux中，所有的设备即是文件
\* `i\_size`：文件大小，单位字节
\* `i\_atime`：最后访问时间
\* `i\_mtime`：最后修改时间
\* `i\_ctime`：最后改变时间
\* `i\_blkbits`：块大小表示位数，例如块为4096字节时，此时值为12
\* `i\_blocks`：文件所占用的block数量
\* `i\_hash`：哈希表
\* `i\_dentry`：目录项链表
\* `i\_fop`：文件操作方法集合
\* `i\_data`：设备数据地址映射
\* `i\_devices`：块设备链表
\* `i\_pipe`：管道文件
\* `i\_cdev`：字符设备文件
\* `i\_link`：连接文件
\* `i\_private`：私有指针，一般用来存放数据块的首地址
其中成员i\_op为inode的操作集合：
struct inode\_operations {
struct dentry \* (\*lookup) (struct inode \*,struct dentry \*, unsigned int);
const char \* (\*get\_link) (struct dentry \*, struct inode \*, struct delayed\_call \*);
int (\*permission) (struct inode \*, int);
struct posix\_acl \* (\*get\_acl)(struct inode \*, int);
int (\*readlink) (struct dentry \*, char \_\_user \*,int);
int (\*create) (struct inode \*,struct dentry \*, umode\_t, bool);
int (\*link) (struct dentry \*,struct inode \*,struct dentry \*);
int (\*unlink) (struct inode \*,struct dentry \*);
int (\*symlink) (struct inode \*,struct dentry \*,const char \*);
int (\*mkdir) (struct inode \*,struct dentry \*,umode\_t);
int (\*rmdir) (struct inode \*,struct dentry \*);
int (\*mknod) (struct inode \*,struct dentry \*,umode\_t,dev\_t);
int (\*rename) (struct inode \*, struct dentry \*,
struct inode \*, struct dentry \*, unsigned int);
int (\*setattr) (struct dentry \*, struct iattr \*);
int (\*getattr) (const struct path \*, struct kstat \*, u32, unsigned int);
ssize\_t (\*listxattr) (struct dentry \*, char \*, size\_t);
int (\*fiemap)(struct inode \*, struct fiemap\_extent\_info \*, u64 start,
u64 len);
int (\*update\_time)(struct inode \*, struct timespec64 \*, int);
int (\*atomic\_open)(struct inode \*, struct dentry \*,
struct file \*, unsigned open\_flag,
umode\_t create\_mode);
int (\*tmpfile) (struct inode \*, struct dentry \*, umode\_t);
int (\*set\_acl)(struct inode \*, struct posix\_acl \*, int);
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
ANDROID\_KABI\_RESERVE(3);
ANDROID\_KABI\_RESERVE(4);
} \_\_\_\_cacheline\_aligned;
\* `lookup`：在dentry下查找inode
\* `create`：在dentry下创建一个inode
\* `link`：为一个indoe创建一个inode
\* `unlink`：删除一个连接文件
\* `mkdir`：在dentry下创建一个目录inode
\* `rmdir`：在dentry下删除一个inode
\* `mknod`：创建设备节点
\* `update\_time`：更新文件时间
### 3.4、file
file对象是与进程相关的文件描述符的内核表示。它是文件系统和进程之间交互的核心数据结构之一。file对象是Linux内核中用于表示打开文件的结构体。当进程通过系统调用（如
open()）打开文件时，内核会创建一个file对象，并将其添加到进程的文件描述符表中。当进程通过系统调用（如
close()）关闭文件时，内核会释放对应的file对象。file结构体如下：
struct file {
union {
struct llist\_node fu\_llist;
struct rcu\_head fu\_rcuhead;
} f\_u;
struct path f\_path;
struct inode \*f\_inode; /\* cached value \*/
const struct file\_operations \*f\_op;
/\*
\* Protects f\_ep\_links, f\_flags.
\* Must not be taken from IRQ context.
\*/
spinlock\_t f\_lock;
enum rw\_hint f\_write\_hint;
atomic\_long\_t f\_count;
unsigned int f\_flags;
fmode\_t f\_mode;
struct mutex f\_pos\_lock;
loff\_t f\_pos;
struct fown\_struct f\_owner;
const struct cred \*f\_cred;
struct file\_ra\_state f\_ra;
u64 f\_version;
#ifdef CONFIG\_SECURITY
void \*f\_security;
#endif
/\* needed for tty driver, and maybe others \*/
void \*private\_data;
#ifdef CONFIG\_EPOLL
/\* Used by fs/eventpoll.c to link all the hooks to this file \*/
struct list\_head f\_ep\_links;
struct list\_head f\_tfile\_llink;
#endif /\* #ifdef CONFIG\_EPOLL \*/
struct address\_space \*f\_mapping;
errseq\_t f\_wb\_err;
errseq\_t f\_sb\_err; /\* for syncfs \*/
ANDROID\_KABI\_RESERVE(1);
ANDROID\_KABI\_RESERVE(2);
ANDROID\_OEM\_DATA(1);
} \_\_randomize\_layout
\_\_attribute\_\_((aligned(4))); /\* lest something weird decides that 2 is OK \*/
\* `f\_path`：文件路径，包含了dentry和vfsmout
\* `f\_inode`：执行inode指针
\* `f\_op`：文件操作方法集合
\* `f\_count`：文件对象使用计数
\* `f\_flags`：文件被打开时指定的标志，例如O\_RDONLY，O\_WRONLY
\* `f\_mode`：文件读写权限
\* `f\_pos`：文件当前的偏移量，即当前读写的位置相对于文件开始地址的偏移
\* `f\_owner`：文件所有者
\* `private\_data`：私有数据指针，较为常用
\* `f\_mapping`：文件的页缓冲映射地址
## 4、文件系统的挂载
当一个磁盘上的分区被挂载时，此时Linux内核会扫描该磁盘上对应的分区的所有索引节点(inode)，然后创建struct
mount结构体和dentry对象，并将所有的超级块信息保存在struct
superblock结构体中，并将所有的inode信息以链表的形式保存在struct inode结构体中，整个过程就建立了从struct
mount到inode之间的关系。
## 5、文件系统的注册
内核维护一个全局链表 file\_systems，用于存储所有已注册的文件系统类型。每个文件系统类型通过 file\_system\_type
结构体注册到这个链表中。
### 5.1、文件系统的注册过程
#### 5.1.2、定义文件系统类型
文件系统开发者需要定义一个 `file\_system\_type` 结构体实例，并实现必要的操作函数（如挂载和卸载函数）。
static struct file\_system\_type myfs\_type = {
.owner = THIS\_MODULE,
.name = "myfs",
.mount = myfs\_mount,
.kill\_sb = myfs\_kill\_sb,
.fs\_flags = FS\_REQUIRES\_DEV,
};
#### 5.1.3、注册文件系统
使用 `register\_filesystem()` 函数将文件系统类型注册到内核中。这通常在文件系统模块加载时完成。
static int \_\_init myfs\_init(void) {
return register\_filesystem(&myfs\_type);
}
int register\_filesystem(struct file\_system\_type \* fs)
{
int res = 0;
struct file\_system\_type \*\* p;
if (fs->parameters &&
!fs\_validate\_description(fs->name, fs->parameters))
return -EINVAL;
BUG\_ON(strchr(fs->name, '.'));
if (fs->next)
return -EBUSY;
write\_lock(&file\_systems\_lock);
p = find\_filesystem(fs->name, strlen(fs->name));
if (\*p)
res = -EBUSY;
else
\*p = fs;
write\_unlock(&file\_systems\_lock);
return res;
}
#### 5.1.4、注销文件系统
使用 `unregister\_filesystem()` 函数将文件系统从内核中注销。这通常在文件系统模块卸载时完成。
static void \_\_exit myfs\_exit(void) {
unregister\_filesystem(&myfs\_type);
}
int unregister\_filesystem(struct file\_system\_type \* fs)
{
struct file\_system\_type \*\* tmp;
write\_lock(&file\_systems\_lock);
tmp = &file\_systems;
while (\*tmp) {
if (fs == \*tmp) {
\*tmp = fs->next;
fs->next = NULL;
write\_unlock(&file\_systems\_lock);
synchronize\_rcu();
return 0;
}
tmp = &(\*tmp)->next;
}
write\_unlock(&file\_systems\_lock);
return -EINVAL;
}
### 5.2、文件系统的挂载与注册的关系
\* 挂载前的注册：在文件系统被挂载之前，它必须先注册到内核中。只有注册过的文件系统类型才能被挂载。
\* 挂载时的识别：当用户尝试挂载一个文件系统时（如通过 `mount` 命令），内核会遍历 `file\_systems` 链表，查找匹配的文件系统类型。
\* 动态加载：某些文件系统（如通过模块加载的文件系统）可以在运行时动态注册和注销。例如，`ntfs` 文件系统可以通过加载 `ntfs.ko` 模块动态注册。
## 6、实现一个虚拟文件系统
注：程序源码一样来自李文山的《Linux驱动开发进阶》：
但上述源码是基于6.1的kernel，我实验的环境是5.x的kernel，部分接口函数会不一样。所以下面展示的源码是略有修改的。
### 6.1、定义文件系统结构
一般需要自定义开发文件系统时，可能才需要编写文件系统驱动程序。下图是本次要实现的虚拟文件系统结构（图片来自作者李文山的《Linux驱动开发进阶》）：
![图片来自作者李文山的《Linux驱动开发进阶》](https://i-blog.csdnimg.cn/img\_convert/80bed0c68de937e6bf015b559a1499cf.png#pic\_center)
### 6.2、完整的驱动程序
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#define MEMFS\_INVALID 0xFFFFFFFF
#define MEMFS\_FILE\_NAME\_MAX 16
#define MEMFS\_INODE\_MAX 128
#define MEMFS\_BLK\_MAX 128
#define MEMFS\_FILE\_SIZE\_MAX 1024
struct memfs\_sb {
uint32\_t blk\_size\_bit; // 块大小占用的位数
uint32\_t block\_size; // 数据块大小
uint32\_t magic; // 文件系统魔数
uint32\_t private; //
};
struct memfs\_inode {
char file\_name[MEMFS\_FILE\_NAME\_MAX]; // 文件名称
uint32\_t mode; // 记录文件或者文件夹的读写权限
uint32\_t idx; // 记录文件或者文件夹在inode bitmap的索引节点号
uint32\_t child; // 记录当前文件夹下的目录或者文件的第一个(=MEMFS\_INVALID: no child)
uint32\_t brother; // 记录当前文件或目录的同级目录或者文件(=MEMFS\_INVALID: no brother)
uint32\_t file\_size; //
uint32\_t data; // =MEMFS\_INVALID: dir 0~127: file
};
struct memfs\_block {
char data[1024];
};
struct memfs\_sb g\_mf\_sb = {
.blk\_size\_bit = 10,
.block\_size = 1024,
.magic = 0x20221001,
};
char g\_inode\_bitmap[16]={0}; // 128bit空间的一个inode bitmap, 每个bit都是一个开关量，标记着inode池中对应的inode是否已使用
char g\_block\_bitmap[16]={0}; // 128bit空间的一个block bitmap
static struct memfs\_inode \*g\_mf\_inode; // 指向inode池
static struct memfs\_block \*g\_mf\_block; // 指向block池
static struct inode\_operations memfs\_inode\_ops;
void set\_bitmap(char \*bitmap, uint32\_t index)
{
\*(bitmap + (index>>3)) |= (1<< (index%8));
}
void reset\_bitmap(char \*bitmap, uint32\_t index)
{
\*(bitmap + (index>>3)) &= ~(1<< (index%8));
}
uint32\_t get\_idle\_index(char \*bitmap)
{
uint8\_t tmp;
for(int i = 0; i < 16; i++) // 循环检查16个字节
{
if(bitmap[i] != 0xFF) // 如果该字节(8个bit)存在空闲bit
{
tmp = bitmap[i];
for(int j = 0; j<8; j++) // 逐位检查8个bit
{
if((tmp & 0x1) == 0) // 找到空闲bit
{
set\_bitmap(bitmap, i\*8 + j); // 设置改bit为非空闲
return i\*8 + j; // 返回下标
}
else
{
tmp >>= 1;
}
}
}
}
return MEMFS\_INVALID;
}
void put\_used\_index(char \*bitmap, uint32\_t index)
{
reset\_bitmap(bitmap, index);
}
int memfs\_alloc\_mem(void)
{
/\* 分配inode池，大小5120bytes \*/
g\_mf\_inode = kzalloc(5120, GFP\_KERNEL);
if(!g\_mf\_inode)
return -1;
/\* 分配block池，大小128KB \*/
g\_mf\_block = kzalloc(128\*1024, GFP\_KERNEL);
if(!g\_mf\_block)
return -1;
/\* 初始化inode的brother和child属性 \*/
for(int i = 0; i < MEMFS\_INODE\_MAX; i++)
{
g\_mf\_inode[i].brother = MEMFS\_INVALID;
g\_mf\_inode[i].child = MEMFS\_INVALID;
}
return 0;
}
void memfs\_free\_mem(void)
{
kfree(g\_mf\_inode);
kfree(g\_mf\_block);
}
static int memfs\_readdir(struct file \*filp, struct dir\_context \*ctx)
{
struct memfs\_inode \*mf\_inode, \*child\_inode;
if (ctx->pos)
return 0;
mf\_inode = &g\_mf\_inode[filp->f\_path.dentry->d\_inode->i\_ino];
if (!S\_ISDIR(mf\_inode->mode))
{
return -ENOTDIR;
}
if(mf\_inode->child != MEMFS\_INVALID)
{
child\_inode = &g\_mf\_inode[mf\_inode->child];
}
else
{
return 0;
}
while(child\_inode->idx != MEMFS\_INVALID)
{
if (!dir\_emit(ctx, child\_inode->file\_name, MEMFS\_FILE\_NAME\_MAX, child\_inode->idx, DT\_UNKNOWN))
{
return 0;
}
ctx->pos += sizeof(struct memfs\_inode);
if(child\_inode->brother != MEMFS\_INVALID)
child\_inode = &g\_mf\_inode[child\_inode->brother];
else
break;
}
return 0;
}
ssize\_t memfs\_read\_file(struct file \* filp, char \_\_user \* buf, size\_t len, loff\_t \*ppos)
{
struct memfs\_inode \*inode;
char \*buffer;
inode = &g\_mf\_inode[filp->f\_path.dentry->d\_inode->i\_ino]; // 获取实际要操作的inode
if (\*ppos >= inode->file\_size)
return 0;
buffer = (char\*)&g\_mf\_block[inode->data]; // 获取block池中对应位置的首地址
buffer += \*ppos; //
len = min((size\_t)(inode->file\_size - \*ppos), len);
if (copy\_to\_user(buf, buffer, len)) // 拷贝到用户态
{
return -EFAULT;
}
\*ppos += len; // 更新偏移
return len;
}
ssize\_t memfs\_write\_file(struct file \*filp, const char \_\_user \*buf, size\_t len, loff\_t \*ppos)
{
struct memfs\_inode \*inode;
char \*buffer;
inode = &g\_mf\_inode[filp->f\_path.dentry->d\_inode->i\_ino]; // 获取实际要操作的inode
if (\*ppos + len > MEMFS\_FILE\_SIZE\_MAX )
return 0;
buffer = (char\*)&g\_mf\_block[inode->data]; // 获取block池中对应位置的首地址
buffer += \*ppos; //
if (copy\_from\_user(buffer, buf, len))
{
return -EFAULT;
}
\*ppos += len; // 更新偏移
inode->file\_size = \*ppos; // 更新文件大小
return len;
}
const struct file\_operations memfs\_file\_operations = {
.read = memfs\_read\_file,
.write = memfs\_write\_file,
};
const struct file\_operations memfs\_dir\_operations = {
.owner = THIS\_MODULE,
.iterate\_shared = memfs\_readdir,
};
//dir: 当前目录的inode
//dentry：要创建的文件的dentry
//mode：要创建的文件的mode
static int memfs\_do\_create(struct inode \*dir, struct dentry \*dentry, umode\_t mode)
{
struct inode \*inode;
struct super\_block \*sb;
struct memfs\_inode \*mf\_inode, \*p\_mf\_inode, \*tmp\_mf\_inode;
uint32\_t idx\_inode;
/\* 获取sb指针 \*/
sb = dir->i\_sb;
/\* 判断是否是目录和常规文件，如果不是，返回错误 \*/
if (!S\_ISDIR(mode) && !S\_ISREG(mode))
{
return -EINVAL;
}
if (strlen(dentry->d\_name.name) > MEMFS\_FILE\_NAME\_MAX)
{
return -ENAMETOOLONG;
}
inode = new\_inode(sb);
if (!inode)
{
return -ENOMEM;
}
/\* 初始化现在要创建的inode的sb \*/
idx\_inode = get\_idle\_index(g\_inode\_bitmap); // 获取一个空闲的inode，用于保存当前创建的目录或者文件的inode信息
if (idx\_inode == MEMFS\_INVALID)
{
return -ENOSPC;
}
inode->i\_sb = sb;
inode->i\_op = &memfs\_inode\_ops; // 初始化当前的inode的ops
inode->i\_atime = inode->i\_mtime = inode->i\_ctime = current\_time(inode); // 初始化创建时间和修改时间为当前时间
inode->i\_ino = idx\_inode;
mf\_inode = &g\_mf\_inode[idx\_inode]; //
mf\_inode->idx = idx\_inode; //
mf\_inode->mode = mode;
/\* 接下来都是inode的初始化 \*/
if (S\_ISDIR(mode)) // 如果创建的是一个文件，则分配一个block，如果是一个目录则不用分配block
{
mf\_inode->data = MEMFS\_INVALID;
inode->i\_fop = &memfs\_dir\_operations;
}
else if (S\_ISREG(mode))
{
mf\_inode->child = MEMFS\_INVALID;
mf\_inode->file\_size = 0;
inode->i\_fop = &memfs\_file\_operations;
mf\_inode->data = get\_idle\_index(g\_block\_bitmap);
if(mf\_inode->data == MEMFS\_INVALID)
{
return -ENOSPC;
}
}
p\_mf\_inode = &g\_mf\_inode[dir->i\_ino]; // 获取当前新创建的父目录节点
if(p\_mf\_inode->child == MEMFS\_INVALID) // 当前目录为空目录
{
p\_mf\_inode->child = mf\_inode->idx; // 父目录节点的child直接指向现在要创建的inode
}
else // 非空目录，找到最后一个child
{
tmp\_mf\_inode = &g\_mf\_inode[p\_mf\_inode->child]; // 第一个child
while(tmp\_mf\_inode->brother != MEMFS\_INVALID)
{
tmp\_mf\_inode = &g\_mf\_inode[tmp\_mf\_inode->brother]; // 找到父目录最后一个child
}
tmp\_mf\_inode->brother = mf\_inode->idx; // 最后一个child，并设置brother
}
strcpy(mf\_inode->file\_name, dentry->d\_name.name); // 初始化内核的dentry名称
inode\_init\_owner(inode, dir, mode); // 添加inode到dir中
d\_add(dentry, inode); // 绑定内核dentry与inode
return 0;
}
static int memfs\_inode\_mkdir(struct inode \*dir, struct dentry \*direntry, umode\_t mode)
{
return memfs\_do\_create(dir, direntry, S\_IFDIR | mode);
}
static int memfs\_inode\_create(struct inode \*dir, struct dentry \*direntry, umode\_t mode,
bool excl)
{
return memfs\_do\_create(dir, direntry, mode);
}
//parent\_inode: 父目录节点
//find\_dentry: 要查找的dentry
static struct dentry \*memfs\_inode\_lookup(struct inode \*parent\_inode, struct dentry \*find\_dentry, unsigned int flags)
{
return NULL;
}
//删除空目录
//dentry: 待删除空目录的dentry
int memfs\_inode\_rmdir(struct inode \*dir, struct dentry \*dentry)
{
uint32\_t index = dentry->d\_inode->i\_ino; // 待删除的空目录的inode下标
struct memfs\_inode \*p\_mf\_inode, \*child\_mf\_inode, \*tmp\_mf\_inode;
if(g\_mf\_inode[index].child != MEMFS\_INVALID) // 如果是非空目录，返回错误
return -ENOTEMPTY;
p\_mf\_inode = &g\_mf\_inode[dir->i\_ino]; // 获取当前目录inode
child\_mf\_inode = &g\_mf\_inode[p\_mf\_inode->child]; // 获取父目录inode的第一个child
put\_used\_index(g\_inode\_bitmap, index);
if(p\_mf\_inode->child == index) // 如果要删除的空目录是父目录的第一个child
{
if(child\_mf\_inode->brother == MEMFS\_INVALID) // 如果当前node没有brother了
p\_mf\_inode->child = MEMFS\_INVALID; // 那么父目录inode也不会有child
else
p\_mf\_inode->child = child\_mf\_inode->brother; // 否则父目录inode指向当前inode的brother
}
else // 如果要删除的空目录不是父目录的第一个child
{
while(child\_mf\_inode->idx != MEMFS\_INVALID)
{
if(child\_mf\_inode->brother != MEMFS\_INVALID)
{
tmp\_mf\_inode = child\_mf\_inode;
child\_mf\_inode = &g\_mf\_inode[child\_mf\_inode->brother]; // 获取brother
if(child\_mf\_inode->idx == index) // 找到待删除的空目录了
{
if(child\_mf\_inode->brother != MEMFS\_INVALID)
tmp\_mf\_inode->brother = child\_mf\_inode->brother; // 在链表关系中，移除了待删除的这个空目录
else
tmp\_mf\_inode->brother = MEMFS\_INVALID;
break;
}
}
}
}
g\_mf\_inode[index].idx = MEMFS\_INVALID;
g\_mf\_inode[index].brother = MEMFS\_INVALID;
return simple\_unlink(dir, dentry);
}
//删除文件操作
int memfs\_inode\_unlink(struct inode \*dir, struct dentry \*dentry)
{
uint32\_t index = dentry->d\_inode->i\_ino;
struct memfs\_inode \*p\_mf\_inode, \*child\_mf\_inode, \*tmp\_mf\_inode;
p\_mf\_inode = &g\_mf\_inode[dir->i\_ino];
//获取第一个child
child\_mf\_inode = &g\_mf\_inode[p\_mf\_inode->child];
put\_used\_index(g\_inode\_bitmap, index);
put\_used\_index(g\_block\_bitmap, g\_mf\_inode[index].data);
if(p\_mf\_inode->child == index) {
if(child\_mf\_inode->brother == MEMFS\_INVALID)
p\_mf\_inode->child = MEMFS\_INVALID;
else
p\_mf\_inode->child = child\_mf\_inode->brother;
}
else {
while(child\_mf\_inode->idx != MEMFS\_INVALID) {
if(child\_mf\_inode->brother != MEMFS\_INVALID) {
tmp\_mf\_inode = child\_mf\_inode;
child\_mf\_inode = &g\_mf\_inode[child\_mf\_inode->brother];
if(child\_mf\_inode->idx == index) {
if(child\_mf\_inode->brother != MEMFS\_INVALID)
tmp\_mf\_inode->brother = child\_mf\_inode->brother;
else
tmp\_mf\_inode->brother = MEMFS\_INVALID;
break;
}
}
}
}
g\_mf\_inode[index].idx = MEMFS\_INVALID;
g\_mf\_inode[index].brother = MEMFS\_INVALID;
return simple\_unlink(dir, dentry);
}
static struct inode\_operations memfs\_inode\_ops = {
.create = memfs\_inode\_create, // 在dentry下创建一个inode
.lookup = memfs\_inode\_lookup, // 在dentry下查找inode
.mkdir = memfs\_inode\_mkdir, // 在dentry下创建一个目录inode
.rmdir = memfs\_inode\_rmdir, // 在dentry下删除一个inode
.unlink = memfs\_inode\_unlink, // 删除文件
};
/\* 每挂载一个块设备，都需要初始化相应的超级块，
\* 该函数就是初始化超级块。
\*/
static int memfs\_demo\_fill\_super(struct super\_block \*sb, void \*data, int silent)
{
struct inode \*root\_inode;
int mode = S\_IFDIR | 0755;
root\_inode = new\_inode(sb); // 新建inode，用于保存根节点
root\_inode->i\_ino = 0; // 设置根节点的编号为0
root\_inode->i\_mode = mode; // 初始化根节点权限
root\_inode->i\_sb = sb; // 设置根节点的超级块
root\_inode->i\_op = &memfs\_inode\_ops; // 设置根节点的节点操作集合
root\_inode->i\_fop = &memfs\_dir\_operations; // 设置根节点目录操作集合
root\_inode->i\_atime = root\_inode->i\_mtime = root\_inode->i\_ctime = current\_time(root\_inode); //设置根节点的创建修改时间为当前时间
/\* 初始化inode池中的第0个inode，第0个inode就是根节点 \*/
strcpy(g\_mf\_inode[0].file\_name, "memfs");
g\_mf\_inode[0].mode = mode;
g\_mf\_inode[0].idx = 0;
g\_mf\_inode[0].child = MEMFS\_INVALID;
g\_mf\_inode[0].brother = MEMFS\_INVALID;
set\_bitmap(g\_inode\_bitmap, g\_mf\_inode[0].idx); // 置inode bitmap的第0位为1
root\_inode->i\_private = &g\_mf\_inode[0]; // 将根节点保存到root\_inode的私有数据中
/\* 初始化磁盘的描述信息(super block) \*/
sb->s\_root = d\_make\_root(root\_inode); // 设置上面分配的inode为根目录
sb->s\_magic = g\_mf\_sb.magic; // 文件系统魔数
sb->s\_blocksize\_bits = g\_mf\_sb.blk\_size\_bit; // 页大小所占的位数为12
sb->s\_blocksize = g\_mf\_sb.blk\_size\_bit; // 页大小为1024Bytes
return 0;
}
static struct dentry \*memfs\_demo\_mount(struct file\_system\_type \*fs\_type, int flags, const char \*dev\_name, void \*data)
{
return mount\_nodev(fs\_type, flags, data, memfs\_demo\_fill\_super);
}
static void memfs\_kill\_sb(struct super\_block \*sb)
{
kill\_anon\_super(sb);
}
/\* 文件系统类型 \*/
static struct file\_system\_type memfs\_type = {
.owner = THIS\_MODULE,
.name = "memfs", // 文件系统名字
.mount = memfs\_demo\_mount, // 挂载文件系统时，所执行的函数
.kill\_sb = memfs\_kill\_sb, // 卸载文件系统时，所执行的函数
};
static int \_\_init memfs\_demo\_init(void)
{
/\* 分配inode池和block池 \*/
if(memfs\_alloc\_mem())
{
printk(KERN\_ERR "alloc memory failed\n");
return -ENOMEM;
}
/\* 注册文件系统 \*/
return register\_filesystem(&memfs\_type);
}
static void \_\_exit memfs\_demo\_exit(void)
{
/\* 释放inode池和block池 \*/
memfs\_free\_mem();
/\* 卸载文件系统 \*/
unregister\_filesystem(&memfs\_type);
}
module\_init(memfs\_demo\_init);
module\_exit(memfs\_demo\_exit);
MODULE\_LICENSE("GPL");
MODULE\_AUTHOR("1477153217@qq.com");
MODULE\_DESCRIPTION("memory fs demo");
MODULE\_ALIAS("fs:memfs");
MODULE\_IMPORT\_NS(VFS\_internal\_I\_am\_really\_a\_filesystem\_and\_am\_NOT\_a\_driver);
Makefile如下：
KERN\_DIR = /home/cohen/sdk/docker/rk356x-sdk/kernel/
all:
make -C $(KERN\_DIR) M=$(PWD) modules
clean:
make -C $(KERN\_DIR) M=$(PWD) clean
rm -f modules.order
obj-m += my\_memfs.o
ccflags-y += -std=gnu99
### 6.3、测试
1. 将编译好的驱动程序拷贝到板卡，安装驱动：
insmod my\_memfs.ko
此时，已经将一个名为memfs的虚拟文件系统注册进了内核。
2. 挂载文件系统：
# -t 表示文件系统的类型
# none 表示没有IO设备
# /mnt 为挂载点
mount -t memfs none /mnt
3. 进入/mnt，创建文件：
![](https://i-blog.csdnimg.cn/img\_convert/50cf8729368c2b7e83cd47db0d9f18a9.png#pic\_center)
4. 创建目录：
![](https://i-blog.csdnimg.cn/img\_convert/587fbaed3945e8799734932e91a7eccc.png#pic\_center)
5. 删除空目录：
![](https://i-blog.csdnimg.cn/img\_convert/12a58a8ed21e1126b395c8b156913929.png#pic\_center)
6. 删除文件：
![](https://i-blog.csdnimg.cn/img\_convert/717d30c50c693f40dd833ec31d6cb0f9.png#pic\_center)