---
layout: post
title: "蓝桥备赛13-链表和-list上"
date: 2025-03-08 15:09:09 +0800
description: "链表 : 用  链式存储  实现的线性表   "
keywords: "蓝桥备赛（13）- 链表和 list（上）"
categories: ['手撕代码']
tags: ['链表', '算法', '数据结构', '开发语言', 'List', 'C']
artid: "146110680"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146110680
    alt: "蓝桥备赛13-链表和-list上"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146110680
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146110680
cover: https://bing.ee123.net/img/rand?artid=146110680
image: https://bing.ee123.net/img/rand?artid=146110680
img: https://bing.ee123.net/img/rand?artid=146110680
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥备赛（13）- 链表和 list（上）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h2 id="%E4%B8%80%E3%80%81%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%9A" name="%E4%B8%80%E3%80%81%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%9A" style="background-color:transparent">
     一、模拟题：
    </h2>
    <p>
     在开始之前：先来看一道提升题 --&gt;
     <strong>
      <span style="background-color:#ffd900">
       The Blocks Problem
      </span>
     </strong>
    </p>
    <p>
     <a href="https://www.luogu.com.cn/problem/UVA101" rel="nofollow" title="UVA101 The Blocks Problem - 洛谷">
      UVA101 The Blocks Problem - 洛谷
     </a>
    </p>
    <p class="img-center">
     <img alt="" height="924" src="https://i-blog.csdnimg.cn/direct/86501ff3c83a47bda60f78071bbf1726.png" width="1126"/>
    </p>
    <p class="img-center">
     <img alt="" height="3919" src="https://i-blog.csdnimg.cn/direct/e617281a6e96402b93138fb993f24403.png" width="1000"/>
    </p>
    <blockquote>
     <p>
      这道题本质上是一道模拟题 ， 模拟题目所需要的流程；
     </p>
     <p>
      1） 看到题目我们首先就会想到 ， 用4 个 if 语句 ， 对这4个指令进行 匹配 ， 然后执行
     </p>
     <p>
      2 ） 但是 ， 其实只有两种操作 ， 分别是
      <span style="color:#fe2c24">
       <strong>
        归位 和 移动
       </strong>
      </span>
     </p>
     <p class="img-center">
      <img alt="" height="266" src="https://i-blog.csdnimg.cn/direct/4f85a18d80eb4ff2a499b72788f7f7e8.png" width="450"/>
     </p>
    </blockquote>
    <pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
typedef pair&lt;int,int&gt; PII;

const int N = 30;
vector&lt;int&gt; p[N];
int n;

PII find(int x)
{
	for (int i = 0; i &lt; n; i++)
	{
		for (int j = 0; j &lt; p[i].size(); j++)
		{
			if (p[i][j] == x)
			{
				return { i,j };
			}
		}
	}
}

//归位
void clean(int x, int y)
{
	//把[x , y ] 上方的木块归位
	for (int j = y + 1; j &lt; p[x].size(); j++)
	{
		int t = p[x][j];
		p[t].push_back(t);
	}
	p[x].resize(y + 1);
}

//移动
void move(int x1, int y1, int x2)
{
	//把 [ x1 , y1 ] 以及以上的木块放在x2上
	for (int j = y1; j &lt; p[x1].size(); j++)
	{
		p[x2].push_back(p[x1][j]);
	}
	p[x1].resize(y1);
}
int main()
{
	cin &gt;&gt; n;

	//初始化
	for (int i = 0; i &lt; n; i++)
	{
		p[i].push_back(i);
	}

	string op1, op2;
	int a, b;

	while (cin &gt;&gt; op1 &gt;&gt; a &gt;&gt; op2 &gt;&gt; b)
	{
		//查找 a 和 b 的位置
		PII pa = find(a);
		int x1 = pa.first, y1 = pa.second;
		PII pb = find(b);
		int x2 = pb.first, y2 = pb.second;

		//执行
		if (x1 == x2)continue; // 操作不合法

		if (op1 == "move")//把 a 上方归位
		{
			clean(x1, y1);
		}
		if (op2 == "onto") //把 b 上方归位
		{
			clean(x2, y2);
		}
		//移动
		move(x1, y1, x2);
	}
	//打印
	for (int i = 0; i &lt; n; i++)
	{
		cout &lt;&lt; i &lt;&lt; ":";
		for (int j = 0; j &lt; p[i].size(); j++)
		{
			cout &lt;&lt; " " &lt;&lt; p[i][j];
		}
		cout &lt;&lt; endl;
	}
	return 0;
}</code></pre>
    <p>
    </p>
    <blockquote>
     <p>
      这道题是洛谷从UVa这个外国的OJ平台收录的题目 ，
     </p>
     <p class="img-center">
      <img alt="" height="286" src="https://i-blog.csdnimg.cn/direct/ee06437f7eb84ef1b9448214ac1d5b31.png" width="450"/>
     </p>
     <p>
      在提交的答案的时候回显示需要到UVa 里去提交 ；
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="1565" src="https://i-blog.csdnimg.cn/direct/744db462d6774c31ac3fd1ad15f2da48.png" width="550"/>
    </p>
    <p>
     在Vitrual Judge 平台显示这个，就表示AC了
    </p>
    <p>
     <a href="https://vjudge.net/problem" rel="nofollow" title="Problems - Virtual Judge">
      Problems - Virtual Judge
     </a>
    </p>
    <p class="img-center">
     <img alt="" height="562" src="https://i-blog.csdnimg.cn/direct/8320e21cbadd4390b329aff85c1dcf7f.png" width="1292"/>
    </p>
    <p>
    </p>
    <h2 id="%E4%BA%8C%20%E3%80%81%20%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5" name="%E4%BA%8C%20%E3%80%81%20%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5">
     二 、 链表的概念
    </h2>
    <h3 id="1.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" name="1.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89" style="background-color:transparent">
     1.1 链表的定义
    </h3>
    <blockquote>
     <p>
      链表 : 用
      <span style="color:#fe2c24">
       <strong>
        链式存储
       </strong>
      </span>
      实现的
      <span style="color:#fe2c24">
       <strong>
        线性表
       </strong>
      </span>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="550" src="https://i-blog.csdnimg.cn/direct/36ade4532fc14e9690b42550d4b2779b.png" width="1007"/>
    </p>
    <h3 id="1.2%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" name="1.2%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">
     1.2 链表的分类
    </h3>
    <p>
     把各种类型的链表排列组合 ，
     <strong>
      <span style="background-color:#ffd900">
       总共有 8 种不同链表的结构
      </span>
     </strong>
     ：
     <br/>
    </p>
    <p class="img-center">
     <img alt="" height="758" src="https://i-blog.csdnimg.cn/direct/cd6d318c3c62487aa272efce0303eec4.png" width="1551"/>
    </p>
    <p class="img-center">
     <img alt="" height="358" src="https://i-blog.csdnimg.cn/direct/5c01ba40c40f427bba650787f42709ad.png" width="634"/>
    </p>
    <p>
    </p>
    <p>
     虽然链表种类较多 ， 我们只需要掌握
     <strong>
      <span style="background-color:#ffd900">
       单向链表 ， 双向链表 和循环链表
      </span>
     </strong>
     即可 。
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" style="background-color:transparent">
     三、链表的模拟实现
    </h2>
    <h3 id="3.1%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="3.1%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     3.1 单链表的模拟实现
    </h3>
    <h4 id="3.1.1%C2%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" name="3.1.1%C2%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">
     3.1.1 实现方式
    </h4>
    <blockquote>
     <p>
      1）
      <span style="color:#fe2c24">
       <strong>
        动态实现 ： 通过 new 申请结点 ，然后通过 delete 释放结点
       </strong>
      </span>
      。 这种实现方式最能体现链表的特性 ， 代码也很清晰
      <strong>
       <span style="background-color:#ffd900">
        。 但是频繁的调用 new 和 delete 会有很大的时间开销。
       </span>
      </strong>
     </p>
     <p>
      2）
      <span style="color:#fe2c24">
       <strong>
        静态实现  ：
       </strong>
      </span>
      <strong>
       <span style="background-color:#ffd900">
        利用两个数组配合模拟链表 。（
        <span style="color:#fe2c24">
         重点
        </span>
        ）
       </span>
      </strong>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="455" src="https://i-blog.csdnimg.cn/direct/c61775a598334461857dafa411ad7bc8.png" width="1551"/>
    </p>
    <p class="img-center">
     <img alt="" height="369" src="https://i-blog.csdnimg.cn/direct/dca667f4ecca4fcb89cf5b83f86a25d0.png" width="1250"/>
    </p>
    <p>
     可能还是不怎么理解这里，那么我们看一下下面的题目：还原一下逻辑结构
    </p>
    <p class="img-center">
     <img alt="" height="325" src="https://i-blog.csdnimg.cn/direct/ccd5aecfa69a41e6a3951a02a5a28d7a.png" width="1189"/>
    </p>
    <p class="img-center">
     <img alt="" height="139" src="https://i-blog.csdnimg.cn/direct/34035a4d4ebf47eab55bccf083e580e6.png" width="1313"/>
    </p>
    <p>
    </p>
    <h4 id="3.1.2%C2%A0%E5%AE%9A%E4%B9%89" name="3.1.2%C2%A0%E5%AE%9A%E4%B9%89">
     3.1.2 定义
    </h4>
    <blockquote>
     <p>
      1）
      <strong>
       <span style="background-color:#ffd900">
        两个足够大的数组 ， 一个用来存储数据 ， 一个用来存下一个结点的位置
       </span>
      </strong>
     </p>
     <p>
      2）变量 h ，充当头指针 ， 来表示头结点的位置
     </p>
     <p>
      3 ） 变量 id , 为新插入结点的位置
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="481" src="https://i-blog.csdnimg.cn/direct/c09eafcc7ab547759b59fb3afa47a91f.png" width="1388"/>
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

const int N = 1e5 + 10;

//创建数组
int e[N] , ne[N] , h , id;
 
int main()
{
		
	return 0;
}</code></pre>
    <h4 id="" name="">
    </h4>
    <h4 id="3.1.3%20%E5%A4%B4%E6%8F%92" name="3.1.3%20%E5%A4%B4%E6%8F%92">
     3.1.3 头插
    </h4>
    <blockquote>
     <p>
      在链表的
      <span style="color:#fe2c24">
       <strong>
        头部插入一个元素
       </strong>
      </span>
     </p>
     <p>
      <strong>
       <span style="color:#0d0016">
        ----&gt; 放在有效数据的前面 ， 即哨兵位的后面
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#0d0016">
        时间复杂度：O（1）
       </span>
      </strong>
     </p>
    </blockquote>
    <pre><code class="hljs"> //头插
 void push_front(int x)
 {
 	//把x 放在 e[N]中 
 	id++;
 	e[id] = x;
 	
 	//修改指针
	 //1.新结点指向下一个结点的位置
	 ne[id] = ne[h];
	 //2.头结点指向新结点
	 ne[h] = id; 
 	
 }</code></pre>
    <p>
    </p>
    <h4 id="3.1.4%20%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8" name="3.1.4%20%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8">
     3.1.4 遍历链表
    </h4>
    <blockquote>
     <p>
      <strong>
       <span style="color:#0d0016">
        时间复杂度：O（n）
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#0d0016">
        通过指针 ， 访问链表中的所有元素
       </span>
      </strong>
     </p>
    </blockquote>
    <pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std; 

const int N = 1e5 + 10;

//创建数组
int e[N] , ne[N] , h , id;
 
 
 //头插
 void push_front(int x)
 {
 	//把x 放在 e[N]中 
 	id++;
 	e[id] = x;
 	
 	//修改指针
	 //1.新结点指向下一个结点的位置
	 ne[id] = ne[h];
	 //2.头结点指向新结点
	 ne[h] = id; 
 	
 }

//遍历链表
void print()
{
	//从第一个有效结点开始遍历 
	int i = ne[h];
	//遇到空指针结束 
	while(i != 0)
	{
		cout &lt;&lt; e[i] &lt;&lt; " ";
		//i 不断向后移动 
		i = ne[i];	
	}	
	cout &lt;&lt; endl &lt;&lt; endl;
} 
  
int main()
{
	 push_front(1);
	 push_front(2);
	 push_front(3);
	 push_front(4);
	 //4 3 2 1
	 print();
	return 0;
}</code></pre>
    <h4 id="" name="">
    </h4>
    <h4 id="3.1.5%20%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE" name="3.1.5%20%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE">
     3.1.5 按值查找
    </h4>
    <blockquote>
     <p>
      查询链表中是否存在元素x , 如果存在 ， 返回下标 ， 不存在 ， 返回0 或者 -1
     </p>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        方法一：遍历整个链表
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        时间复杂度：O（n)
       </span>
      </strong>
     </p>
    </blockquote>
    <pre><code class="hljs">//方法一：遍历整个链表 
int find(int x)
{
	for(int i = ne[h] ; i ; i= ne[i])
	{
		if(e[i] == x)
			return i;
	}
	return 0;
 } </code></pre>
    <p>
    </p>
    <blockquote>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        方法二：标记数组法
       </span>
      </strong>
     </p>
     <p>
      时间复杂度：O（1）
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="1077" src="https://i-blog.csdnimg.cn/direct/0384ed4436954d3ea69628f3f4caf79c.png" width="1340"/>
    </p>
    <p class="img-center">
     <img alt="" height="332" src="https://i-blog.csdnimg.cn/direct/4e50e9da561c4415a8d73e479dbf7a15.png" width="550"/>
    </p>
    <p class="img-center">
     <img alt="" height="521" src="https://i-blog.csdnimg.cn/direct/34eb8712c56d46458fc5a77e4e0fdb29.png" width="550"/>
    </p>
    <p>
    </p>
    <h4 id="3.1.6%20%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" name="3.1.6%20%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">
     3.1.6 在任意位置之后插入元素
    </h4>
    <blockquote>
     <p>
      在
      <span style="color:#fe2c24">
       <strong>
        存储位置之后
       </strong>
      </span>
      插入数据 ， 插入新的元素 x
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        时间复杂度：O（1）
       </strong>
      </span>
     </p>
     <p>
      1) id++ , 标记新结点的位置 ；同时存储新结点的位置
     </p>
     <p>
      2）修改新结点的指针域 ， 让其指向 p 的下一个位置
     </p>
     <p>
      3）最后让 p 指向 新结点
     </p>
    </blockquote>
    <pre><code class="hljs"> //在任意位置之后插入元素
 void insert(int p , int x) //这里 p 是位置
 {
 	id++;
 	e[id] = x;
 	ne[id]  = ne[p];
 	ne[p] = id;
  } 
  </code></pre>
    <p>
    </p>
    <h4 id="3.1.7%20%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E5%85%83%E7%B4%A0" name="3.1.7%20%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E5%85%83%E7%B4%A0">
     3.1.7 删除任意位置之后的元素
    </h4>
    <blockquote>
     <p>
      删除存储位置 p 之后的元素
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        时间复杂度为O（1）
       </strong>
      </span>
     </p>
     <p>
      1） 直接让 p 指向下一个元素的下一个元素即可
     </p>
     <p>
      ne[p]  = ne[ne[p]]
     </p>
    </blockquote>
    <pre><code class="language-cpp">// 删除任意位置之后的元素
void erase(int p)
{
	if(ne[p])
	{
		mp[e[ne[p]]] = 0;//将p后面的元素从 mp 中删除 
		ne[p] = ne[ne[p]];//指向下一个元素的下一个元素 
	}
 } </code></pre>
    <p>
    </p>
    <h4 id="3.1.8%20%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98" name="3.1.8%20%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98">
     3.1.8 遗留问题
    </h4>
    <blockquote>
     <p>
      单链表为什么不实现尾插 、 尾删 、 删除任意位置元素等操作？
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        1） 能实现 ， 但是没必要 ， 因为时间复杂度是O（N）级别的 ， 竞赛中不怎么用
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        2）使用数据结构是为了方便我们解决问题的 ， 而不是添堵的
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <h4 id="2.1.9%20%E6%89%80%E6%9C%89%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" name="2.1.9%20%E6%89%80%E6%9C%89%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">
     2.1.9 所有测试代码
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std; 

const int N = 1e5 + 10;

//创建数组
int e[N] , ne[N] , h , id;
 int mp[N];
 
 
 //头插
 void push_front(int x)
 {
 	//把x 放在 e[N]中 
 	id++;
 	e[id] = x;
 	mp[x] = id;//标记x 存储的为位置 
 	
 	//修改指针
	 //1.新结点指向下一个结点的位置
	 ne[id] = ne[h];
	 //2.头结点指向新结点
	 ne[h] = id; 
 	
 }

//遍历链表
void print()
{
	//从第一个有效结点开始遍历 
	int i = ne[h];
	//遇到空指针结束 
	while(i != 0)
	{
		cout &lt;&lt; e[i] &lt;&lt; " ";
		//i 不断向后移动 
		i = ne[i];	
	}	
	cout &lt;&lt; endl &lt;&lt; endl;
} 

//按值查找
//方法一：遍历整个链表 
int find(int x)
{
//	for(int i = ne[h] ; i ; i= ne[i])
//	{
//		if(e[i] == x)
//			return i;
//	}
//	return 0;

	return mp[x];
 } 
 
 //在任意位置之后插入元素
 void insert(int p , int x) //这里 p 是位置
 {
 	id++;
 	e[id] = x;
 	ne[id]  = ne[p];
 	ne[p] = id;
  } 
  
// 删除任意位置之后的元素
void erase(int p)
{
	if(ne[p])
	{
		mp[e[ne[p]]] = 0;//将p后面的元素从 mp 中删除 
		ne[p] = ne[ne[p]];//指向下一个元素的下一个元素 
	}
 } 
  
int main()
{
	 push_front(1);
	 push_front(2);
	 push_front(3);
	 push_front(4);
	 //4 3 2 1
	 print();
	
//	cout &lt;&lt; find(4) &lt;&lt; endl;
//	cout &lt;&lt; find(2) &lt;&lt; endl;
//	cout &lt;&lt; find(99) &lt;&lt; endl;

	insert(1,10);
	print();
	//4 3 2 1 10
	insert(4,99);
	print();
	//4 99 3 10 2 1 
	return 0;
}</code></pre>
    <p>
    </p>
    <h3 id="3.2%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" name="3.2%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">
     3.2 双向链表的模拟实现
    </h3>
    <h4 id="3.2.1%C2%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" name="3.2.1%C2%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">
     3.2.1 实现方式
    </h4>
    <blockquote>
     <p>
      依旧采用静态实现的方式 。
     </p>
     <p>
      <strong>
       <span style="color:#0d0016">
        双向链表无非就是在单链表的基础上加上一个
        <span style="background-color:#ffd900">
         指向前驱的指针
        </span>
        ，
       </span>
       <span style="color:#fe2c24">
        那就再来一个数组 充当前驱的指针域即可 。
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <h4 id="3.2.2%C2%A0%E5%AE%9A%E4%B9%89" name="3.2.2%C2%A0%E5%AE%9A%E4%B9%89">
     3.2.2 定义
    </h4>
    <p class="img-center">
     <img alt="" height="567" src="https://i-blog.csdnimg.cn/direct/11d433bef88e4f87a47422129ab7bb93.png" width="1289"/>
    </p>
    <pre><code class="language-cpp">const int N = 1e5 + 10;
int id;
int h; // 头结点
int pre[N] , ne[N] , e[N];//前后指针域 数据域 
int mp[N];


int main()
{
	
	return 0;
}</code></pre>
    <h4 id="" name="">
    </h4>
    <h4 id="3.2.3%20%E5%A4%B4%E6%8F%92" name="3.2.3%20%E5%A4%B4%E6%8F%92">
     3.2.3 头插
    </h4>
    <blockquote>
     <p>
      <span style="color:#fe2c24">
       <strong>
        时间复杂度为 O（1）
       </strong>
      </span>
     </p>
     <p>
      1） id++ , 标记新结点存储位置 ； 把 新的元素存储起来 : e[id[ = x
     </p>
     <p>
      2) 修改新结点的前驱指针 ， 让其指向哨兵位：pre[id] = h
     </p>
     <p>
      3) 修改新结点的后继指针 ， 让其指向哨兵位的下一个位置 : ne[id] = ne[h]
     </p>
     <p>
      4) 修改 y 结点的前驱指针 ， 让其指向新的结点：pre[ne[h]] = id
     </p>
     <p>
      5) 修改哨兵位的后继指针 ， 让其指向新的结点：ne[h] = id
     </p>
     <p class="img-center">
      <img alt="" height="393" src="https://i-blog.csdnimg.cn/direct/9894b0414a524810b0c6007b1e72cf2f.png" width="450"/>
     </p>
    </blockquote>
    <pre><code class="language-cpp">//头插
void push_front(int x)
{
	id++;
	e[id] = x;
	mp[x] = id; // 存一下x这个元素的位置 
	
	pre[id] = h;
	ne[id] = ne[h];
	pre[ne[h]] = id;
	ne[h] = id;
} </code></pre>
    <p>
    </p>
    <h4 id="3.2.4%20%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8" name="3.2.4%20%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8">
     3.2.4 遍历链表
    </h4>
    <blockquote>
     <p>
      同单链表的遍历方式一样
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        时间复杂度：O（N）
       </span>
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-cpp">//遍历链表
void print()
{
	for(int i = ne[h] ; i ; i = ne[i])
	{
		cout &lt;&lt; e[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
 } </code></pre>
    <p>
    </p>
    <h4 id="3.2.5%20%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE" name="3.2.5%20%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE" style="background-color:transparent">
     3.2.5 按值查找
    </h4>
    <blockquote>
     <p>
      <strong>
       <span style="color:#fe2c24">
        时间复杂度：O（1）
       </span>
      </strong>
     </p>
    </blockquote>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

const int N = 1e5 + 10;
int id;
int h; // 头结点
int pre[N] , ne[N] , e[N];//前后指针域 数据域 
int mp[N];

//头插
void push_front(int x)
{
	id++;
	e[id] = x;
	mp[x] = id; // 存一下x这个元素的位置 
	
	pre[id] = h;
	ne[id] = ne[h];
	pre[ne[h]] = id;
	ne[h] = id;
}

//遍历链表
void print()
{
	for(int i = ne[h] ; i ; i = ne[i])
	{
		cout &lt;&lt; e[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
 } 
 
 //按值查找
 int find(int x)
 {
 	return mp[x];
 }
  
int main()
{
	push_front(1);
	push_front(2);
	push_front(3);
	push_front(4);
	//4 3 2 1
	print();
	
	cout &lt;&lt; find(3) &lt;&lt; endl;
	cout &lt;&lt; find(0) &lt;&lt; endl;
	cout &lt;&lt; find(1) &lt;&lt; endl; 
	return 0;
}</code></pre>
    <p>
    </p>
    <h4 id="3.2.6%20%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" name="3.2.6%20%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">
     3.2.6 在任意位置之后插入元素
    </h4>
    <blockquote>
     <p>
      <strong>
       <span style="color:#fe2c24">
        时间复杂度：O（1）
       </span>
      </strong>
     </p>
     <p>
      与头插操作类似 ， 只是是在 存储位置 p 之后插入元素
     </p>
     <p class="img-center">
      <img alt="" height="360" src="https://i-blog.csdnimg.cn/direct/35a72f37ac3647fcb84322029e46ba71.png" width="450"/>
     </p>
    </blockquote>
    <pre><code class="language-cpp"> 
 //在任意位置之后插入元素
 void push_back(int p ,int x)
 {
 	id++;
 	e[id] = x;
 	mp[x] = id;
 	
 	//先左指向p , 右指向 p 的后继 
 	pre[id] = p;
 	ne[id] = ne[p];
 	//再让p 的后继的左指针指向id 
 	//p的右指针指向 id 
 	pre[ne[p]] = id;
 	ne[p] = id;
  } </code></pre>
    <p>
    </p>
    <h4 id="3.2.7%20%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" name="3.2.7%20%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">
     3.2.7 在任意位置之前插入元素
    </h4>
    <blockquote>
     <p>
      <strong>
       <span style="color:#fe2c24">
        时间复杂度：O（1）
       </span>
      </strong>
     </p>
     <p class="img-center">
      <img alt="" height="214" src="https://i-blog.csdnimg.cn/direct/2a294d2166f84a9e86b878176424fb42.png" width="450"/>
     </p>
    </blockquote>
    <pre><code class="language-cpp">//在任意位置之前插入元素
void push_front(int p,int x)
{
	id++;
	e[id] = x;
	mp[x] = id;
	
	pre[id] = pre[p];
	ne[id] = p;
	ne[pre[p]] = id;
	pre[p] = id;
}</code></pre>
    <p>
    </p>
    <h4 id="3.2.8%20%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0" name="3.2.8%20%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0">
     3.2.8 删除任意位置的元素
    </h4>
    <blockquote>
     <p>
      <strong>
       <span style="color:#fe2c24">
        时间复杂度：O（1）
       </span>
      </strong>
     </p>
     <p class="img-center">
      <img alt="" height="396" src="https://i-blog.csdnimg.cn/direct/d269e90b6201493c90de5a4c6ee51634.png" width="450"/>
     </p>
    </blockquote>
    <pre><code class="language-cpp">//删除任意位置的元素 
int rease(int p)
{
	mp[e[p]] = 0;//从标记这里删除
	
	ne[pre[p]] = ne[p];
	pre[ne[p]] = pre[p]; 
}</code></pre>
    <p>
    </p>
    <h4 id="2.1.9%20%E6%89%80%E6%9C%89%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" name="2.1.9%20%E6%89%80%E6%9C%89%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">
     2.1.9 所有测试代码
    </h4>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

const int N = 1e5 + 10;
int id;
int h; // 头结点
int pre[N] , ne[N] , e[N];//前后指针域 数据域 
int mp[N];

//头插
void push_front(int x)
{
	id++;
	e[id] = x;
	mp[x] = id; // 存一下x这个元素的位置 
	
	pre[id] = h;
	ne[id] = ne[h];
	pre[ne[h]] = id;
	ne[h] = id;
}

//遍历链表
void print()
{
	for(int i = ne[h] ; i ; i = ne[i])
	{
		cout &lt;&lt; e[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
 } 
 
 //按值查找
 int find(int x)
 {
 	return mp[x];
 }
 
 //在任意位置之后插入元素
 void insert_back(int p ,int x)
 {
 	id++;
 	e[id] = x;
 	mp[x] = id;
 	
 	//先左指向p , 右指向 p 的后继 
 	pre[id] = p;
 	ne[id] = ne[p];
 	//再让p 的后继的左指针指向id 
 	//p的右指针指向 id 
 	pre[ne[p]] = id;
 	ne[p] = id;
  } 
  
//在任意位置之前插入元素
void insert_front(int p,int x)
{
	id++;
	e[id] = x;
	mp[x] = id;
	
	pre[id] = pre[p];
	ne[id] = p;
	ne[pre[p]] = id;
	pre[p] = id;
}

//删除任意位置的元素 
int erase(int p)
{
	mp[e[p]] = 0;//从标记这里删除
	
	ne[pre[p]] = ne[p];
	pre[ne[p]] = pre[p]; 
}
 
int main()
{
	push_front(1);
	push_front(2);
	push_front(3);
	push_front(4);
	//4 3 2 1
	print();
	
	cout &lt;&lt; find(3) &lt;&lt; endl;
	cout &lt;&lt; find(0) &lt;&lt; endl;
	cout &lt;&lt; find(1) &lt;&lt; endl; 
	
	insert_back(2,5);
	//4 3 2 5 1
	print();
	insert_back(0,99);
	//99 4 3 2 5 1 
	print();
	
	insert_front(4,55);
	//99 55 4 3 2 5 1
	print();
	
	erase(4);
	print();
	return 0;
}</code></pre>
    <h3 id="" name="" style="background-color:transparent">
    </h3>
    <h3 id="3.3%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" name="3.3%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent">
     3.3 循环链表的实现
    </h3>
    <blockquote>
     <p>
      回看之前实现的带头单向链表 。
     </p>
     <p>
      定义 0 表示空指针 ， 其实哨兵位就在 0 的位置 ， 所有的结构正好成环。
     </p>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        循环聊表就是再原有的基础上 ， 让最后一个元素指向表头即可 。
       </span>
      </strong>
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6b686a6a6a67642f:61727469636c652f64657461696c732f313436313130363830" class_="artid" style="display:none">
 </p>
</div>


