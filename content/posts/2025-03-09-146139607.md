---
layout: post
title: "跟着-Lua-5.1-官方参考文档学习-Lua-12"
date: 2025-03-09 21:58:56 +0800
description: "标准库- IO、OS、完整的 Lua 语法"
keywords: "跟着 Lua 5.1 官方参考文档学习 Lua (12)"
categories: ['Lua']
tags: ['Lua']
artid: "146139607"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146139607
    alt: "跟着-Lua-5.1-官方参考文档学习-Lua-12"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146139607
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146139607
cover: https://bing.ee123.net/img/rand?artid=146139607
image: https://bing.ee123.net/img/rand?artid=146139607
img: https://bing.ee123.net/img/rand?artid=146139607
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     跟着 Lua 5.1 官方参考文档学习 Lua (12)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h3>
     <a id="57__Input_and_Output_Facilities_2">
     </a>
     5.7 – Input and Output Facilities
    </h3>
    <p>
     <strong>
      The I/O library provides two different styles for file manipulation. The first one uses implicit file descriptors; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file descriptors.
     </strong>
    </p>
    <p>
     <strong>
      When using implicit file descriptors, all operations are supplied by table
      <code>
       io
      </code>
      . When using explicit file descriptors, the operation
      <a href="https://www.lua.org/manual/5.1/manual.html#pdf-io.open" rel="nofollow">
       <code>
        io.open
       </code>
      </a>
      returns a file descriptor and then all operations are supplied as methods of the file descriptor.
     </strong>
    </p>
    <p>
     The table
     <code>
      io
     </code>
     also provides three predefined file descriptors with their usual meanings from C:
     <code>
      io.stdin
     </code>
     ,
     <code>
      io.stdout
     </code>
     , and
     <code>
      io.stderr
     </code>
     . The I/O library never closes these files.
    </p>
    <p>
     Unless otherwise stated, all I/O functions return
     <strong>
      nil
     </strong>
     on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from
     <strong>
      nil
     </strong>
     on success.
    </p>
    <h4>
     <a id="_12">
     </a>
     补充内容
    </h4>
    <p>
     <strong>
      21.1 The Simple I/O Model
     </strong>
    </p>
    <p>
     The simple model does all of its operations on two current files. The library initializes the current input file as the process standard input (
     <em>
      stdin
     </em>
     ) and the current output file as the process standard output (
     <em>
      stdout
     </em>
     ). Therefore, when we execute something like
     <em>
      io.read()
     </em>
     , we read a line from the standard input. We can change these current files with the
     <em>
      io.input
     </em>
     and
     <em>
      io.output
     </em>
     functions. A call like
     <em>
      io.input(filename)
     </em>
     opens the given file in read mode and sets it as the current input file. From this point on, all input will come from this file, until another call to
     <em>
      io.input
     </em>
     ;
     <em>
      io.output
     </em>
     does a similar job for output. In case of error, both functions raise the error. If you want to handle errors directly, you must use
     <em>
      io.open
     </em>
     , from the complete model.
    </p>
    <p>
     As write is simpler than read, we will look at it first. The
     <em>
      io.write
     </em>
     function simply gets an arbitrary number of string arguments and writes them to the current output file. Numbers are converted to strings following the usual conversion rules; for full control over this conversion, you should use the
     <br/>
     <em>
      string.format
     </em>
     function:
    </p>
    <pre><code>&gt; io.write("sin (3) = ", math.sin(3), "\n")
--&gt; sin (3) = 0.14112000805987
&gt; io.write(string.format("sin (3) = %.4f\n", math.sin(3)))
--&gt; sin (3) = 0.1411
</code></pre>
    <p>
     Avoid code like
     <em>
      io.write(a…b…c)
     </em>
     ; the call
     <em>
      io.write(a,b,c)
     </em>
     accomplishes the same effect with fewer resources, as it avoids the concatenations.
     <br/>
     As a rule, you should use print for quick-and-dirty programs, or for debugging, and write when you need full control over your output:
    </p>
    <pre><code>&gt; print("hello", "Lua"); print("Hi")
--&gt; hello Lua
--&gt; Hi
&gt; io.write("hello", "Lua"); io.write("Hi", "\n")
--&gt; helloLuaHi
</code></pre>
    <p>
     Unlike
     <em>
      print
     </em>
     ,
     <em>
      write
     </em>
     adds no extra characters to the output, such as tabs or newlines. Moreover,
     <em>
      write
     </em>
     uses the current output file, whereas
     <em>
      print
     </em>
     always uses the standard output. Finally,
     <em>
      print
     </em>
     automatically applies tostring to its arguments, so it can also show tables, functions, and nil.
    </p>
    <p>
     The
     <em>
      io.read
     </em>
     function reads strings from the current input file. Its arguments control what is read:
    </p>
    <pre><code>“*all” reads the whole file
“*line” reads the next line
“*number” reads a number
num reads a string with up to num characters
</code></pre>
    <p>
     The call *io.read("
     <em>
      all")
     </em>
     reads the whole current input file, starting at its current position. If we are at the end of the file, or if the file is empty, the call returns an empty string
    </p>
    <p>
     Because Lua handles long strings efficiently, a simple technique for writing filters in Lua is to read the whole file into a string, do the processing to the string (typically with
     <em>
      gsub
     </em>
     ), and then write the string to the output:
    </p>
    <pre><code>t = io.read("*all") -- read the whole file
t = string.gsub(t, ...) -- do the job
io.write(t) -- write the file  
</code></pre>
    <p>
     The call
     <em>
      io.read(“*line”)
     </em>
     returns the next line from the current input file, without the newline character. When we reach the end of file, the call returns nil (as there is no next line to return). This pattern is the default for read.
    </p>
    <p>
     Usually, I use this pattern only when the algorithm naturally handles the file line by line; otherwise, I favor reading the whole file at once, with *
     <em>
      all
     </em>
     , or in blocks, as we will see later.
    </p>
    <p>
     As a simple example of the use of this pattern, the following program copies
     <br/>
     its current input to the current output, numbering each line:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">for</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> math<span class="token punctuation">.</span>huge <span class="token keyword">do</span>
    <span class="token keyword">local</span> line <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> line <span class="token operator">==</span> <span class="token keyword">nil</span> <span class="token keyword">then</span> <span class="token keyword">break</span> <span class="token keyword">end</span>
    io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%6d "</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">,</span> line<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

</code></pre>
    <p>
     However, to iterate on a whole file line by line, we do better to use the
     <em>
      io.lines
     </em>
     iterator. For instance, we can write a complete program to sort the lines of a file as follows:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> lines <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token comment">-- read the lines in table ’lines’</span>
<span class="token keyword">for</span> line <span class="token keyword">in</span> io<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">do</span> lines<span class="token punctuation">[</span><span class="token operator">#</span>lines <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> line <span class="token keyword">end</span>
<span class="token comment">-- sort</span>
table<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span>
<span class="token comment">-- write all the lines</span>
<span class="token keyword">for</span> _<span class="token punctuation">,</span> l <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span> <span class="token keyword">do</span> io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span> <span class="token keyword">end</span>
</code></pre>
    <p>
     Besides the basic read patterns, you can call read with a number
     <em>
      n
     </em>
     as an argument: in this case, read tries to read
     <em>
      n
     </em>
     characters from the input file. If it cannot read any character (end of file), read returns nil; otherwise, it returns a string with at most
     <em>
      n
     </em>
     characters.
    </p>
    <p>
     As an example of this read pattern, the following program is an efficient way (in Lua, of course) to copy a file from stdin to stdout:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token keyword">do</span>
    <span class="token keyword">local</span> block <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">^</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token comment">-- buffer size is 8K</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> block <span class="token keyword">then</span> <span class="token keyword">break</span> <span class="token keyword">end</span>
    io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span>
<span class="token keyword">end</span>
</code></pre>
    <p>
     As a special case,
     <em>
      io.read(0)
     </em>
     works as a test for end of file: it returns an empty string if there is more to be read or nil otherwise.
    </p>
    <p>
     <strong>
      21.2 The Complete I/O Model
     </strong>
    </p>
    <p>
     For more control over I/O, you can use the complete model. A central concept in this model is the
     <em>
      <strong>
       file handle
      </strong>
     </em>
     , which is equivalent to streams (
     <em>
      FILE
     </em>
     *) in C: itrepresents an open file with a current position.
    </p>
    <p>
     To open a file, you use the
     <em>
      io.open
     </em>
     function, which mimics the
     <em>
      fopen
     </em>
     function in C. It takes as arguments the name of the file to open plus a
     <em>
      mode
     </em>
     string. This mode string may contain an ‘r’ for reading, a ‘w’ for writing (which also erases any previous content of the file), or an ‘a’ for appending, plus an optional ‘b’ to open binary files. The open function returns a new handle for the file. In case of error, open returns nil, plus an error message and an error number:
    </p>
    <pre><code class="prism language-lua"><span class="token function">print</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"non-existent-file"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">--&gt; nil non-existent-file: No such file or directory 2</span>
<span class="token function">print</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/etc/passwd"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">--&gt; nil /etc/passwd: Permission denied 13</span>
</code></pre>
    <p>
     The interpretation of the error numbers is system dependent.
    </p>
    <p>
     A typical idiom to check for errors is
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> f <span class="token operator">=</span> <span class="token function">assert</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     If the
     <em>
      open
     </em>
     fails, the error message goes as the second argument to
     <em>
      assert
     </em>
     , which then shows the message. After you open a file, you can read from it or write to it with the methods
     <em>
      read/write
     </em>
     . They are similar to the
     <em>
      read/write
     </em>
     functions, but you call them as methods on the file handle, using the colon syntax. For instance, to open a file and read it all, you can use a chunk like this:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> f <span class="token operator">=</span> <span class="token function">assert</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> t <span class="token operator">=</span> f<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"*all"</span><span class="token punctuation">)</span>
f<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     The I/O library offers handles for the three predefined C streams:
     <em>
      io.stdin
     </em>
     ,
     <em>
      io.stdout
     </em>
     , and
     <em>
      io.stderr
     </em>
     . So, you can send a message directly to the error stream with a code like this:
    </p>
    <pre><code class="prism language-lua">io<span class="token punctuation">.</span>stderr<span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
</code></pre>
    <p>
     We can mix the complete model with the simple model. We get the current input file handle by calling
     <em>
      io.input()
     </em>
     , without arguments. We set this handle with the call
     <em>
      io.input(handle)
     </em>
     . (Similar calls are also valid for
     <em>
      io.output
     </em>
     .) For instance, if you want to change the current input file temporarily, you can write something like this:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> temp <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- save current file</span>
io<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token string">"newinput"</span><span class="token punctuation">)</span> <span class="token comment">-- open a new current file</span>
<span class="token comment">-- &lt;do something with new input&gt;</span>
io<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- close current file</span>
io<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token comment">-- restore previous current file</span>
</code></pre>
    <p>
     <strong>
      A small performance trick
     </strong>
    </p>
    <p>
     Usually, in Lua, it is faster to read a file as a whole than to read it line by line. However, sometimes we must face a big file (say, tens or hundreds megabytes) for which it is not reasonable to read it all at once. If you want to handle such big files with maximum performance, the fastest way is to read them in reasonably large chunks (e.g., 8 Kbytes each). To avoid the problem of breaking lines in the
     <br/>
     middle, you simply ask to read a chunk plus a line:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> lines<span class="token punctuation">,</span> rest <span class="token operator">=</span> f<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span>BUFSIZE<span class="token punctuation">,</span> <span class="token string">"*line"</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     The variable
     <em>
      rest
     </em>
     will get the rest of any line broken by the chunk. We then concatenate the chunk and this rest of line. This way, the resulting chunk will always break at line boundaries.
    </p>
    <p>
     The example in Listing 21.1 uses this technique to implement
     <em>
      wc
     </em>
     , a program that counts the number of characters, words, and lines in a file.
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> BUFSIZE <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">^</span> <span class="token number">13</span>     <span class="token comment">-- 8K</span>
<span class="token keyword">local</span> f <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">-- open input file</span>
<span class="token keyword">local</span> cc<span class="token punctuation">,</span> lc<span class="token punctuation">,</span> wc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">-- char, line, and word counts</span>
<span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token keyword">do</span>
    <span class="token keyword">local</span> lines<span class="token punctuation">,</span> rest <span class="token operator">=</span> f<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span>BUFSIZE<span class="token punctuation">,</span> <span class="token string">"*line"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> lines <span class="token keyword">then</span> <span class="token keyword">break</span> <span class="token keyword">end</span>
    <span class="token keyword">if</span> rest <span class="token keyword">then</span> lines <span class="token operator">=</span> lines <span class="token operator">..</span> rest <span class="token operator">..</span> <span class="token string">"\n"</span> <span class="token keyword">end</span>
    cc <span class="token operator">=</span> cc <span class="token operator">+</span> <span class="token operator">#</span>lines
    <span class="token comment">-- count words in the chunk</span>
    <span class="token keyword">local</span> _<span class="token punctuation">,</span> t <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> <span class="token string">"%S+"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
    wc <span class="token operator">=</span> wc <span class="token operator">+</span> t
    <span class="token comment">-- count newlines in the chunk</span>
    _<span class="token punctuation">,</span> t <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
    lc <span class="token operator">=</span> lc <span class="token operator">+</span> t
<span class="token keyword">end</span>
<span class="token function">print</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span> wc<span class="token punctuation">,</span> cc<span class="token punctuation">)</span>
</code></pre>
    <p>
     <strong>
      Binary files
     </strong>
    </p>
    <p>
     The simple-model functions
     <em>
      io.input
     </em>
     and
     <em>
      io.output
     </em>
     always open a file in text mode (the default). In Unix, there is no difference between binary files and text files. But in some systems, notably Windows, binary files must be opened with a special flag. To handle such binary files, you must use io.open, with the letter ‘
     <em>
      b
     </em>
     ’ in the mode string.
    </p>
    <p>
     Binary data in Lua are handled similarly to text. A string in Lua may contain any bytes, and almost all functions in the libraries can handle arbitrary bytes. You can even do pattern matching over binary data, as long as the pattern does not contain a zero byte. If you want to match this byte in the subject, you can use the class
     <em>
      %z
     </em>
     instead.
    </p>
    <p>
     Typically, you read binary data either with the *
     <em>
      all
     </em>
     pattern, that reads the whole file, or with the pattern
     <em>
      n
     </em>
     , that reads
     <em>
      n
     </em>
     bytes. As a simple example, the following program converts a text file from DOS format to Unix format (that is, it translates sequences of carriage return–newlines to newlines). It does not use the standard I/O files (stdin–stdout), because these files are open in text mode. Instead, it assumes that the names of the input file and the output file are given as arguments to the program:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> inp <span class="token operator">=</span> <span class="token function">assert</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> out <span class="token operator">=</span> <span class="token function">assert</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> data <span class="token operator">=</span> inp<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"*all"</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">"\r\n"</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
out<span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token function">assert</span><span class="token punctuation">(</span>out<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
    <p>
     As another example, the following program prints all strings found in a binary file:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">local</span> f <span class="token operator">=</span> <span class="token function">assert</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> data <span class="token operator">=</span> f<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"*all"</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> validchars <span class="token operator">=</span> <span class="token string">"[%w%p%s]"</span>
<span class="token keyword">local</span> pattern <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">rep</span><span class="token punctuation">(</span>validchars<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">..</span> <span class="token string">"+%z"</span>
<span class="token keyword">for</span> w <span class="token keyword">in</span> string<span class="token punctuation">.</span><span class="token function">gmatch</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
<span class="token keyword">end</span>
</code></pre>
    <p>
     The program assumes that a string is any zero-terminated sequence of six or more valid characters, where a valid character is any character accepted by the pattern
     <em>
      validchars
     </em>
     . In our example, this pattern comprises the alphanumeric, the punctuation, and the space characters. We use
     <em>
      string.rep
     </em>
     and concatenation to create a pattern that captures all sequences of six or more
     <em>
      validchars
     </em>
     . The %z at the end of the pattern matches the byte zero at the end of a string.
    </p>
    <p>
     As a last example, the following program makes a dump of a binary file:
    </p>
    <pre><code class="prism language-lua">vlocal f <span class="token operator">=</span> <span class="token function">assert</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">local</span> block <span class="token operator">=</span> <span class="token number">16</span>
<span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token keyword">do</span>
    <span class="token keyword">local</span> bytes <span class="token operator">=</span> f<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> bytes <span class="token keyword">then</span> <span class="token keyword">break</span> <span class="token keyword">end</span>
    <span class="token keyword">for</span> _<span class="token punctuation">,</span> b <span class="token keyword">in</span> <span class="token function">pairs</span> <span class="token punctuation">{<!-- --></span> string<span class="token punctuation">.</span><span class="token function">byte</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">do</span>
        io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span>
    io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">rep</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> block <span class="token operator">-</span> string<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

</code></pre>
    <p>
     Again, the first program argument is the input file name; the output goes to the standard output. The program reads the file in chunks of 16 bytes. For each chunk, it writes the hexadecimal representation of each byte, and then it writes the chunk as text, changing control characters to dots. (Note the use of the idiom
     <em>
      {string.byte(bytes,1,-1)}
     </em>
     to create a table with all bytes of the string bytes.)
    </p>
    <p>
     <strong>
      21.3 Other Operations on Files
     </strong>
    </p>
    <p>
     The
     <em>
      tmpfile
     </em>
     function returns a handle for a temporary file, open in read/write mode. This file is automatically removed (deleted) when your program ends.
    </p>
    <p>
     The
     <em>
      flush
     </em>
     function executes all pending writes to a file. Like the write function, you can call it as a function,
     <em>
      io.flush()
     </em>
     , to flush the current output file; or as a method,
     <em>
      f:flush()
     </em>
     , to flush a particular file
     <em>
      f
     </em>
     .
    </p>
    <p>
     The
     <em>
      seek
     </em>
     function can both get and set the current position of a file. Its general form is
     <em>
      f:seek(whence,offset)
     </em>
     . The
     <em>
      whence
     </em>
     parameter is a string that specifies how to interpret the offset. Its valid values are “set”, when
     <em>
      offsets
     </em>
     are interpreted from the beginning of the file; “cur”, when
     <em>
      offsets
     </em>
     are interpreted from the current position of the file; and “end”, when
     <em>
      offsets
     </em>
     are interpreted from the end of the file. Independently of the value of whence, the call returns the final current position of the file, measured in bytes from the beginning of the file.
    </p>
    <p>
     The default value for
     <em>
      whence
     </em>
     is “cur” and for
     <em>
      offset
     </em>
     is zero. Therefore, the call
     <em>
      file:seek()
     </em>
     returns the current file position, without changing it; the call
     <em>
      file:seek(“set”)
     </em>
     resets the position to the beginning of the file (and returns zero); and the call
     <em>
      file:seek(“end”)
     </em>
     sets the position to the end of the file and returns its size. The following function gets the file size without changing its current position:
    </p>
    <pre><code class="prism language-lua"><span class="token keyword">function</span> <span class="token function">fsize</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
    <span class="token keyword">local</span> current <span class="token operator">=</span> file<span class="token punctuation">:</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">-- get current position</span>
    <span class="token keyword">local</span> size <span class="token operator">=</span> file<span class="token punctuation">:</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span> <span class="token comment">-- get file size</span>
    file<span class="token punctuation">:</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token string">"set"</span><span class="token punctuation">,</span> current<span class="token punctuation">)</span>     <span class="token comment">-- restore position</span>
    <span class="token keyword">return</span> size
<span class="token keyword">end</span>
</code></pre>
    <p>
     All these functions return nil plus an error message in case of error.
    </p>
    <hr/>
    <h4>
     <a id="ioinput_file_252">
     </a>
     <code>
      io.input ([file])
     </code>
    </h4>
    <p>
     When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.
    </p>
    <p>
     In case of errors this function raises the error, instead of returning an error code.
    </p>
    <h4>
     <a id="ioread__258">
     </a>
     <code>
      io.read (···)
     </code>
    </h4>
    <p>
     Equivalent to
     <code>
      io.input():read
     </code>
     .
    </p>
    <h4>
     <a id="iowrite__262">
     </a>
     <code>
      io.write (···)
     </code>
    </h4>
    <p>
     Equivalent to
     <code>
      io.output():write
     </code>
     .
    </p>
    <h4>
     <a id="iooutput_file_266">
     </a>
     <code>
      io.output ([file])
     </code>
    </h4>
    <p>
     Similar to
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-io.input" rel="nofollow">
      <code>
       io.input
      </code>
     </a>
     , but operates over the default output file.
    </p>
    <h4>
     <a id="iolines_filename_270">
     </a>
     <code>
      io.lines ([filename])
     </code>
    </h4>
    <p>
     Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction
    </p>
    <pre><code>     for line in io.lines(filename) do body end
</code></pre>
    <p>
     will iterate over all lines of the file. When the iterator function detects the end of file, it returns
     <strong>
      nil
     </strong>
     (to finish the loop) and automatically closes the file.
    </p>
    <p>
     The call
     <code>
      io.lines()
     </code>
     (with no file name) is equivalent to
     <code>
      io.input():lines()
     </code>
     ; that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.
    </p>
    <h4>
     <a id="ioflush__282">
     </a>
     <code>
      io.flush ()
     </code>
    </h4>
    <p>
     Equivalent to
     <code>
      file:flush
     </code>
     over the default output file.
    </p>
    <h4>
     <a id="ioclose_file_286">
     </a>
     <code>
      io.close ([file])
     </code>
    </h4>
    <p>
     Equivalent to
     <code>
      file:close()
     </code>
     . Without a
     <code>
      file
     </code>
     , closes the default output file.
    </p>
    <h4>
     <a id="ioopen_filename__mode_290">
     </a>
     <code>
      io.open (filename [, mode])
     </code>
    </h4>
    <p>
     This function opens a file, in the mode specified in the string
     <code>
      mode
     </code>
     . It returns a new file handle, or, in case of errors,
     <strong>
      nil
     </strong>
     plus an error message.
    </p>
    <p>
     The
     <code>
      mode
     </code>
     string can be any of the following:
    </p>
    <ul>
     <li>
      <strong>
       “r”:
      </strong>
      read mode (the default);
     </li>
     <li>
      <strong>
       “w”:
      </strong>
      write mode;
     </li>
     <li>
      <strong>
       “a”:
      </strong>
      append mode;
     </li>
     <li>
      <strong>
       “r+”:
      </strong>
      update mode, all previous data is preserved;
     </li>
     <li>
      <strong>
       “w+”:
      </strong>
      update mode, all previous data is erased;
     </li>
     <li>
      <strong>
       “a+”:
      </strong>
      append update mode, previous data is preserved, writing is only allowed at the end of file.
     </li>
    </ul>
    <p>
     The
     <code>
      mode
     </code>
     string can also have a ‘
     <code>
      b
     </code>
     ’ at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function
     <code>
      fopen
     </code>
     .
    </p>
    <h4>
     <a id="iopopen_prog__mode_305">
     </a>
     <code>
      io.popen (prog [, mode])
     </code>
    </h4>
    <p>
     Starts program
     <code>
      prog
     </code>
     in a separated process and returns a file handle that you can use to read data from this program (if
     <code>
      mode
     </code>
     is
     <code>
      "r"
     </code>
     , the default) or to write data to this program (if
     <code>
      mode
     </code>
     is
     <code>
      "w"
     </code>
     ).
    </p>
    <p>
     This function is system dependent and is not available on all platforms.
    </p>
    <h4>
     <a id="iotmpfile__311">
     </a>
     <code>
      io.tmpfile ()
     </code>
    </h4>
    <p>
     Returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.
    </p>
    <h4>
     <a id="iotype_ob_315">
     </a>
     <code>
      io.type (ob)
     </code>
    </h4>
    <p>
     Checks whether
     <code>
      obj
     </code>
     is a valid file handle. Returns the string
     <code>
      "file"
     </code>
     if
     <code>
      obj
     </code>
     is an open file handle,
     <code>
      "closed file"
     </code>
     if
     <code>
      obj
     </code>
     is a closed file handle, or
     <strong>
      nil
     </strong>
     if
     <code>
      obj
     </code>
     is not a file handle.
    </p>
    <h4>
     <a id="fileread__319">
     </a>
     <code>
      file:read (···)
     </code>
    </h4>
    <p>
     Reads the file
     <code>
      file
     </code>
     , according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or
     <strong>
      nil
     </strong>
     if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line (see below).
    </p>
    <p>
     The available formats are
    </p>
    <ul>
     <li>
      <strong>
       “*n”:
      </strong>
      reads a number; this is the only format that returns a number instead of a string.
     </li>
     <li>
      <strong>
       “*a”:
      </strong>
      reads the whole file, starting at the current position. On end of file, it returns the empty string.
     </li>
     <li>
      <strong>
       “*l”:
      </strong>
      reads the next line (skipping the end of line), returning
      <strong>
       nil
      </strong>
      on end of file. This is the default format.
     </li>
     <li>
      *
      <strong>
       number*:
      </strong>
      reads a string with up to this number of characters, returning
      <strong>
       nil
      </strong>
      on end of file. If number is zero, it reads nothing and returns an empty string, or
      <strong>
       nil
      </strong>
      on end of file.
     </li>
    </ul>
    <h4>
     <a id="filelines__330">
     </a>
     <code>
      file:lines ()
     </code>
    </h4>
    <p>
     Returns an iterator function that, each time it is called, returns a new line from the file. Therefore, the construction
    </p>
    <pre><code>     for line in file:lines() do body end
</code></pre>
    <p>
     will iterate over all lines of the file. (Unlike
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-io.lines" rel="nofollow">
      <code>
       io.lines
      </code>
     </a>
     , this function does not close the file when the loop ends.)
    </p>
    <h4>
     <a id="filewrite__340">
     </a>
     <code>
      file:write (···)
     </code>
    </h4>
    <p>
     Writes the value of each of its arguments to the
     <code>
      file
     </code>
     . The arguments must be strings or numbers. To write other values, use
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-tostring" rel="nofollow">
      <code>
       tostring
      </code>
     </a>
     or
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-string.format" rel="nofollow">
      <code>
       string.format
      </code>
     </a>
     before
     <code>
      write
     </code>
     .
    </p>
    <h4>
     <a id="fileflush__344">
     </a>
     <code>
      file:flush ()
     </code>
    </h4>
    <p>
     Saves any written data to
     <code>
      file
     </code>
     .
    </p>
    <h4>
     <a id="fileseek_whence__offset_348">
     </a>
     <code>
      file:seek ([whence] [, offset])
     </code>
    </h4>
    <p>
     Sets and gets the file position, measured from the beginning of the file, to the position given by
     <code>
      offset
     </code>
     plus a base specified by the string
     <code>
      whence
     </code>
     , as follows:
    </p>
    <ul>
     <li>
      <strong>
       “set”:
      </strong>
      base is position 0 (beginning of the file);
     </li>
     <li>
      <strong>
       “cur”:
      </strong>
      base is current position;
     </li>
     <li>
      <strong>
       “end”:
      </strong>
      base is end of file;
     </li>
    </ul>
    <p>
     In case of success, function
     <code>
      seek
     </code>
     returns the final file position, measured in bytes from the beginning of the file. If this function fails, it returns
     <strong>
      nil
     </strong>
     , plus a string describing the error.
    </p>
    <p>
     The default value for
     <code>
      whence
     </code>
     is
     <code>
      "cur"
     </code>
     , and for
     <code>
      offset
     </code>
     is 0. Therefore, the call
     <code>
      file:seek()
     </code>
     returns the current file position, without changing it; the call
     <code>
      file:seek("set")
     </code>
     sets the position to the beginning of the file (and returns 0); and the call
     <code>
      file:seek("end")
     </code>
     sets the position to the end of the file, and returns its size.
    </p>
    <h4>
     <a id="filesetvbuf_mode__size_360">
     </a>
     <code>
      file:setvbuf (mode [, size])
     </code>
    </h4>
    <p>
     Sets the buffering mode for an output file. There are three available modes:
    </p>
    <ul>
     <li>
      <strong>
       “no”:
      </strong>
      no buffering; the result of any output operation appears immediately.
     </li>
     <li>
      <strong>
       “full”:
      </strong>
      full buffering; output operation is performed only when the buffer is full (or when you explicitly
      <code>
       flush
      </code>
      the file (see
      <a href="https://www.lua.org/manual/5.1/manual.html#pdf-io.flush" rel="nofollow">
       <code>
        io.flush
       </code>
      </a>
      )).
     </li>
     <li>
      <strong>
       “line”:
      </strong>
      line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).
     </li>
    </ul>
    <p>
     For the last two cases,
     <code>
      size
     </code>
     specifies the size of the buffer, in bytes. The default is an appropriate size.
    </p>
    <h4>
     <a id="fileclose__370">
     </a>
     <code>
      file:close ()
     </code>
    </h4>
    <p>
     Closes
     <code>
      file
     </code>
     . Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.
    </p>
    <h3>
     <a id="58__Operating_System_Facilities_374">
     </a>
     5.8 – Operating System Facilities
    </h3>
    <p>
     This library is implemented through table
     <code>
      os
     </code>
     .
    </p>
    <h4>
     <a id="osclock__378">
     </a>
     <code>
      os.clock ()
     </code>
    </h4>
    <p>
     Returns an approximation of the amount in seconds of CPU time used by the program.
    </p>
    <h4>
     <a id="osdate_format__time_382">
     </a>
     <code>
      os.date ([format [, time]])
     </code>
    </h4>
    <p>
     Returns a string or a table containing date and time, formatted according to the given string
     <code>
      format
     </code>
     .
    </p>
    <p>
     If the
     <code>
      time
     </code>
     argument is present, this is the time to be formatted (see the
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-os.time" rel="nofollow">
      <code>
       os.time
      </code>
     </a>
     function for a description of this value). Otherwise,
     <code>
      date
     </code>
     formats the current time.
    </p>
    <p>
     If
     <code>
      format
     </code>
     starts with ‘
     <code>
      !
     </code>
     ’, then the date is formatted in Coordinated Universal Time. After this optional character, if
     <code>
      format
     </code>
     is the string “
     <code>
      *t
     </code>
     ”, then
     <code>
      date
     </code>
     returns a table with the following fields:
     <code>
      year
     </code>
     (four digits),
     <code>
      month
     </code>
     (1–12),
     <code>
      day
     </code>
     (1–31),
     <code>
      hour
     </code>
     (0–23),
     <code>
      min
     </code>
     (0–59),
     <code>
      sec
     </code>
     (0–61),
     <code>
      wday
     </code>
     (weekday, Sunday is 1),
     <code>
      yday
     </code>
     (day of the year), and
     <code>
      isdst
     </code>
     (daylight saving flag, a boolean).
    </p>
    <p>
     If
     <code>
      format
     </code>
     is not “
     <code>
      *t
     </code>
     ”, then
     <code>
      date
     </code>
     returns the date as a string, formatted according to the same rules as the C function
     <code>
      strftime
     </code>
     .
    </p>
    <p>
     When called without arguments,
     <code>
      date
     </code>
     returns a reasonable date and time representation that depends on the host system and on the current locale (that is,
     <code>
      os.date()
     </code>
     is equivalent to
     <code>
      os.date("%c")
     </code>
     ).
    </p>
    <h4>
     <a id="osdifftime_t2_t1_394">
     </a>
     <code>
      os.difftime (t2, t1)
     </code>
    </h4>
    <p>
     Returns the number of seconds from time
     <code>
      t1
     </code>
     to time
     <code>
      t2
     </code>
     . In POSIX, Windows, and some other systems, this value is exactly
     <code>
      t2
     </code>
     <em>
      -
     </em>
     <code>
      t1
     </code>
     .
    </p>
    <h4>
     <a id="osexecute_command_398">
     </a>
     <code>
      os.execute ([command])
     </code>
    </h4>
    <p>
     This function is equivalent to the C function
     <code>
      system
     </code>
     . It passes
     <code>
      command
     </code>
     to be executed by an operating system shell. It returns a status code, which is system-dependent. If
     <code>
      command
     </code>
     is absent, then it returns nonzero if a shell is available and zero otherwise.
    </p>
    <h4>
     <a id="osexit_code_402">
     </a>
     <code>
      os.exit ([code])
     </code>
    </h4>
    <p>
     Calls the C function
     <code>
      exit
     </code>
     , with an optional
     <code>
      code
     </code>
     , to terminate the host program. The default value for
     <code>
      code
     </code>
     is the success code.
    </p>
    <h4>
     <a id="osgetenv_varname_406">
     </a>
     <code>
      os.getenv (varname)
     </code>
    </h4>
    <p>
     Returns the value of the process environment variable
     <code>
      varname
     </code>
     , or
     <strong>
      nil
     </strong>
     if the variable is not defined.
    </p>
    <h4>
     <a id="osremove_filename_410">
     </a>
     <code>
      os.remove (filename)
     </code>
    </h4>
    <p>
     Deletes the file or directory with the given name. Directories must be empty to be removed. If this function fails, it returns
     <strong>
      nil
     </strong>
     , plus a string describing the error.
    </p>
    <h4>
     <a id="osrename_oldname_newname_414">
     </a>
     <code>
      os.rename (oldname, newname)
     </code>
    </h4>
    <p>
     Renames file or directory named
     <code>
      oldname
     </code>
     to
     <code>
      newname
     </code>
     . If this function fails, it returns
     <strong>
      nil
     </strong>
     , plus a string describing the error.
    </p>
    <h4>
     <a id="ossetlocale_locale__category_418">
     </a>
     <code>
      os.setlocale (locale [, category])
     </code>
    </h4>
    <p>
     Sets the current locale of the program.
     <code>
      locale
     </code>
     is a string specifying a locale;
     <code>
      category
     </code>
     is an optional string describing which category to change:
     <code>
      "all"
     </code>
     ,
     <code>
      "collate"
     </code>
     ,
     <code>
      "ctype"
     </code>
     ,
     <code>
      "monetary"
     </code>
     ,
     <code>
      "numeric"
     </code>
     , or
     <code>
      "time"
     </code>
     ; the default category is
     <code>
      "all"
     </code>
     . The function returns the name of the new locale, or
     <strong>
      nil
     </strong>
     if the request cannot be honored.
    </p>
    <p>
     If
     <code>
      locale
     </code>
     is the empty string, the current locale is set to an implementation-defined native locale. If
     <code>
      locale
     </code>
     is the string “
     <code>
      C
     </code>
     ”, the current locale is set to the standard C locale.
    </p>
    <p>
     When called with
     <strong>
      nil
     </strong>
     as the first argument, this function only returns the name of the current locale for the given category.
    </p>
    <h4>
     <a id="ostime_table_426">
     </a>
     <code>
      os.time ([table])
     </code>
    </h4>
    <p>
     Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields
     <code>
      year
     </code>
     ,
     <code>
      month
     </code>
     , and
     <code>
      day
     </code>
     , and may have fields
     <code>
      hour
     </code>
     ,
     <code>
      min
     </code>
     ,
     <code>
      sec
     </code>
     , and
     <code>
      isdst
     </code>
     (for a description of these fields, see the
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-os.date" rel="nofollow">
      <code>
       os.date
      </code>
     </a>
     function).
    </p>
    <p>
     The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the “epoch”). In other systems, the meaning is not specified, and the number returned by
     <code>
      time
     </code>
     can be used only as an argument to
     <code>
      date
     </code>
     and
     <code>
      difftime
     </code>
     .
    </p>
    <h4>
     <a id="ostmpname__432">
     </a>
     <code>
      os.tmpname ()
     </code>
    </h4>
    <p>
     Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.
    </p>
    <p>
     On some systems (POSIX), this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).
    </p>
    <p>
     When possible, you may prefer to use
     <a href="https://www.lua.org/manual/5.1/manual.html#pdf-io.tmpfile" rel="nofollow">
      <code>
       io.tmpfile
      </code>
     </a>
     , which automatically removes the file when the program ends.
    </p>
    <h3>
     <a id="59__The_Debug_Library_440">
     </a>
     5.9 – The Debug Library
    </h3>
    <p>
     This library provides the functionality of the debug interface to Lua programs. You should exert care when using this library. The functions provided here should be used exclusively for debugging and similar tasks, such as profiling. Please resist the temptation to use them as a usual programming tool: they can be very slow. Moreover, several of these functions violate some assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside or that userdata metatables cannot be changed by Lua code) and therefore can compromise otherwise secure code.
    </p>
    <p>
     All functions in this library are provided inside the
     <code>
      debug
     </code>
     table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.
    </p>
    <p>
     略
    </p>
    <h2>
     <a id="6__Lua_Standalone_448">
     </a>
     6 – Lua Stand-alone
    </h2>
    <p>
     略
    </p>
    <h2>
     <a id="7__Incompatibilities_with_the_Previous_Version_452">
     </a>
     7 – Incompatibilities with the Previous Version
    </h2>
    <p>
     略
    </p>
    <h2>
     <a id="8__The_Complete_Syntax_of_Lua_456">
     </a>
     8 – The Complete Syntax of Lua
    </h2>
    <p>
     Here is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.)
    </p>
    <pre><code>	chunk ::= {stat [`;´]} [laststat [`;´]]

	block ::= chunk

	stat ::=  varlist `=´ explist | 
		 functioncall | 
		 do block end | 
		 while exp do block end | 
		 repeat block until exp | 
		 if exp then block {elseif exp then block} [else block] end | 
		 for Name `=´ exp `,´ exp [`,´ exp] do block end | 
		 for namelist in explist do block end | 
		 function funcname funcbody | 
		 local function Name funcbody | 
		 local namelist [`=´ explist] 

	laststat ::= return [explist] | break

	funcname ::= Name {`.´ Name} [`:´ Name]

	varlist ::= var {`,´ var}

	var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name 

	namelist ::= Name {`,´ Name}

	explist ::= {exp `,´} exp

	exp ::=  nil | false | true | Number | String | `...´ | function | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | `(´ exp `)´

	functioncall ::=  prefixexp args | prefixexp `:´ Name args 

	args ::=  `(´ [explist] `)´ | tableconstructor | String 

	function ::= function funcbody

	funcbody ::= `(´ [parlist] `)´ block end

	parlist ::= namelist [`,´ `...´] | `...´

	tableconstructor ::= `{´ [fieldlist] `}´

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp

	fieldsep ::= `,´ | `;´

	binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | 
		 `&lt;´ | `&lt;=´ | `&gt;´ | `&gt;=´ | `==´ | `~=´ | 
		 and | or

	unop ::= `-´ | not | `#´
</code></pre>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f776f6179323030382f:61727469636c652f64657461696c732f313436313339363037" class_="artid" style="display:none">
 </p>
</div>


