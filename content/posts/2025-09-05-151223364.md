---
layout: post
title: "nestjs-ç¼“å­˜é…ç½®åŠé˜²æŠ–æ‹¦æˆªå™¨"
date: 2025-09-05T15:11:51+0800
description: "4ã€ç¼–å†™å…¨å±€æ‹¦æˆªå™¨ï¼Œä¾èµ–æ³¨å…¥ç¼“å­˜serviceï¼Œåœ¨æ‹¦æˆªå™¨ä¸­æ¯æ¬¡è¿›å…¥çš„æ—¶å€™ä»ç¼“å­˜ä¸­è¯»å–ï¼Œå¦‚æœä»åœ¨ï¼Œåˆ™æŠ›å¼‚å¸¸ï¼Œå¦åˆ™å­˜å‚¨åœ¨ç¼“å­˜ä¸­ã€‚éœ€è¦åšé˜²æŠ–çš„æ§åˆ¶å™¨ä¸Šæ·»åŠ å…ƒæ•°æ®. @Debounce(æ ‡è¯†ï¼Œè¿‡æœŸæ—¶é—´-æ¯«ç§’)3ã€ç¼–å†™æ·»åŠ å…ƒæ•°æ®æ–¹æ³•ï¼Œä¸ºåé¢é˜²æŠ–æ‹¦æˆªå™¨æ˜¯å¦éœ€è¦æ‹¦æˆªåšå‡†å¤‡ã€‚3ã€ç¼–å†™æ·»åŠ å…ƒæ•°æ®æ–¹æ³•ï¼Œåé¢é˜²æŠ–æ‹¦æˆªå™¨æ˜¯å¦éœ€è¦æ‹¦æˆªåšå‡†å¤‡ã€‚2ã€é…ç½®ç¼“å­˜æœåŠ¡ï¼Œä»¥ä¾¿äºä¾èµ–æ³¨å…¥ã€‚2ã€é…ç½®ç¼“å­˜æœåŠ¡ï¼Œä»¥ä¾¿äºä¾èµ–æ³¨å…¥ã€‚1ã€ç¼–å†™å…¨å±€æ‹¦æˆªå™¨ï¼Œ5ã€å°†æ‹¦æˆªå™¨å…¨å±€å¼•å…¥ã€‚"
keywords: "nestjs ç¼“å­˜é…ç½®åŠé˜²æŠ–æ‹¦æˆªå™¨"
categories: ['æœªåˆ†ç±»']
tags: ['é˜²æŠ–', 'ç¼“å­˜', 'Nestjs']
artid: "151223364"
arturl: "https://blog.csdn.net/qq_37061571/article/details/151223364"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151223364
    alt: "nestjs-ç¼“å­˜é…ç½®åŠé˜²æŠ–æ‹¦æˆªå™¨"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151223364
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151223364
cover: https://bing.ee123.net/img/rand?artid=151223364
image: https://bing.ee123.net/img/rand?artid=151223364
img: https://bing.ee123.net/img/rand?artid=151223364
---



# nestjs ç¼“å­˜é…ç½®åŠé˜²æŠ–æ‹¦æˆªå™¨

> 1ã€ç¼–å†™å…¨å±€æ‹¦æˆªå™¨ï¼Œ
>
> 2ã€é…ç½®ç¼“å­˜æœåŠ¡ï¼Œä»¥ä¾¿äºä¾èµ–æ³¨å…¥
>
> 3ã€ç¼–å†™æ·»åŠ å…ƒæ•°æ®æ–¹æ³•ï¼Œåé¢é˜²æŠ–æ‹¦æˆªå™¨æ˜¯å¦éœ€è¦æ‹¦æˆªåšå‡†å¤‡
>
> 4ã€ç¼–å†™å…¨å±€æ‹¦æˆªå™¨ï¼Œä¾èµ–æ³¨å…¥ç¼“å­˜serviceï¼Œåœ¨æ‹¦æˆªå™¨ä¸­æ¯æ¬¡è¿›å…¥çš„æ—¶å€™ä»ç¼“å­˜ä¸­è¯»å–ï¼Œå¦‚æœä»åœ¨ï¼Œåˆ™æŠ›å¼‚å¸¸ï¼Œå¦åˆ™å­˜å‚¨åœ¨ç¼“å­˜ä¸­
>
> 5ã€å°†æ‹¦æˆªå™¨å…¨å±€å¼•å…¥

1ã€ä¸‹è½½å®‰è£…

```

pnpm i keyv @keyv/redis cache-manager cacheable
```

2ã€é…ç½®ç¼“å­˜æœåŠ¡ï¼Œä»¥ä¾¿äºä¾èµ–æ³¨å…¥

```

providers: [
    {
        provide: 'CACHE_MANAGER',
        inject: [ConfigService],
        useFactory: (configService: ConfigService) => {
            return createCache({
                nonBlocking: true,
                stores: [
                    // å†…å­˜ä¸­å­˜å‚¨
                    new Keyv({
                        store: new CacheableMemory({ ttl: 60000, lruSize: 5000 }),
                        namespace:'',
                    }),
                    // redisä¸­å­˜å‚¨
                    new Keyv({
                        store: new KeyvRedis(configService.get('redis.url')),
                        namespace: ''
                    })
                ]
            })
        }
    }
]
exports: [
    'CACHE_MANAGER'
],
```

> å®Œæ•´å…¨å±€é…ç½®
>
> ```
>
> import { Global, Module } from '@nestjs/common';
> import { ConfigModule, ConfigService } from '@nestjs/config';
> import { HttpModule } from '@nestjs/axios';
> import { TypeOrmModule, TypeOrmModuleOptions } from '@nestjs/typeorm';
> import configuration from '../../config/index';
> import { JwtModule } from '@nestjs/jwt';
> import { APP_FILTER, APP_GUARD, APP_INTERCEPTOR } from '@nestjs/core';
> import { JwtGuard } from 'src/utils/jwt/jwt-guard';
> import { JwtStrategy } from 'src/utils/jwt/jwt-strategy';
> import { WinstonService } from 'src/utils/logger/winston-service';
> import { CatchLoggerFilter } from 'src/utils/logger/catch-logger-filter';
> import { ResponseLoggerInterceptor } from 'src/utils/logger/response-logger-interceptor';
> import { RedisModule } from '@nestjs-modules/ioredis';
> import { RequirePermissionGuard } from 'src/utils/premission/require-premission.guard';
> import { DebounceInterceptor } from 'src/utils/debounce/debounce.interceptor';
> import { Keyv } from 'keyv';
> import KeyvRedis from '@keyv/redis'
> import { createCache } from 'cache-manager';
> import { CacheableMemory } from 'cacheable'
>
> @Global()
> @Module({
>     imports: [
>         ConfigModule.forRoot({
>             isGlobal: true,
>             load: [configuration],
>         }),
>         TypeOrmModule.forRootAsync({
>             name: "default",
>             inject: [ConfigService],
>             useFactory: (configService: ConfigService) => {
>                 return {
>                     type: 'mysql',
>                     ...configService.get('db.mysql'),
>                     timezone: '+08:00',
>                     // logger: 'advanced-console',
>                     entities: [__dirname + '/../**/*.entity.{js,ts}'],
>                 } as TypeOrmModuleOptions;
>             },
>         }),
>         // TypeOrmModule.forRootAsync({
>         //     name: "oracle",
>         //     inject: [ConfigService],
>         //     useFactory: async (configService: ConfigService) => {
>         //         return {
>         //             type: 'oracle',
>         //             ...configService.get('db.oracle'),
>         //             // logger: 'advanced-console',
>         //             timezone: '+08:00',
>         //             entities: [__dirname + '/../**/*.entity.{js,ts}'],
>         //         } as TypeOrmModuleOptions;
>         //     },
>         // }),
>         HttpModule.registerAsync({
>             inject: [ConfigService],
>             useFactory: async (configService: ConfigService) => {
>                 return {
>                     timeout: configService.get('http.timeout'),
>                     maxRedirects: configService.get('http.maxRedirects'),
>                 };
>             },
>         }),
>         RedisModule.forRootAsync({
>             inject: [ConfigService],
>             useFactory: (configService: ConfigService) => {
>                 return {
>                     type: "single",
>                     url: configService.get('redis.url'),
>                 };
>             },
>         }),
>         JwtModule.registerAsync({
>             inject: [ConfigService],
>             global: true,
>             useFactory: (configService: ConfigService) => {
>                 return {
>                     secret: configService.get('jwt.secretkey'),
>                     // signOptions: { expiresIn: configService.get('jwt.expiresin') },
>                 };
>             },
>         }),
>     ],
>     providers: [
>         JwtStrategy,
>         {
>             provide: APP_GUARD,
>             useFactory: (configService: ConfigService) => {
>                 return new JwtGuard(configService);
>             },
>             inject: [ConfigService],
>         },
>         {
>             provide: APP_GUARD,
>             useClass: RequirePermissionGuard
>         },
>         {
>             provide: WinstonService,
>             inject: [ConfigService],
>             useFactory: (configService: ConfigService) => {
>                 return new WinstonService(configService);
>             }
>         },
>         {
>             provide: APP_FILTER,
>             useClass: CatchLoggerFilter
>         },
>         {
>             provide: APP_INTERCEPTOR,
>             useClass: ResponseLoggerInterceptor
>         },
>         {
>             provide: APP_INTERCEPTOR,
>             useClass: DebounceInterceptor
>         },
>         {
>             provide: 'CACHE_MANAGER',
>             inject: [ConfigService],
>             useFactory: (configService: ConfigService) => {
>                 return createCache({
>                     nonBlocking: true,
>                     stores: [
>                         // å†…å­˜ä¸­å­˜å‚¨
>                         new Keyv({
>                             store: new CacheableMemory({ ttl: 60000, lruSize: 5000 }),
>                             namespace:'',
>                         }),
>                         // redisä¸­å­˜å‚¨
>                         new Keyv({
>                             store: new KeyvRedis(configService.get('redis.url')),
>                             namespace: ''
>                         })
>                     ]
>                 })
>             }
>         },
>     ],
>     exports: [
>         WinstonService,
>         HttpModule,
>         'CACHE_MANAGER'
>     ],
> })
> export class ShareModule { }
>
> ```

3ã€ç¼–å†™æ·»åŠ å…ƒæ•°æ®æ–¹æ³•ï¼Œä¸ºåé¢é˜²æŠ–æ‹¦æˆªå™¨æ˜¯å¦éœ€è¦æ‹¦æˆªåšå‡†å¤‡

```

import { SetMetadata } from '@nestjs/common';
export const Debounce = (keyPattern: string, ttl: number = 5) => SetMetadata('debounce', { keyPattern, ttl });

```

4ã€ç¼–å†™é˜²æŠ–æ‹¦æˆªå™¨

```

import { CallHandler, ExecutionContext, HttpException, Inject, Injectable, NestInterceptor } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { Observable } from "rxjs";
import type { Cache } from 'cache-manager'
import { CacheEnum } from "../base-enum";
@Injectable()
export class DebounceInterceptor implements NestInterceptor {
    constructor(
        private reflector: Reflector,
        @Inject('CACHE_MANAGER') private cache: Cache,
    ) {

    }
    async intercept(context: ExecutionContext, next: CallHandler<any>): Promise<Observable<any>> {
        // åˆ¤æ–­æ˜¯å¦æœ‰å…ƒæ•°æ®
        const debounce = this.reflector.getAllAndOverride('debounce', [
            context.getClass(),
            context.getHandler()
        ]);
        // å¦‚æœæ²¡æœ‰ è¯´æ˜ä¸éœ€è¦æ§åˆ¶
        if (!debounce) {
            return next.handle();
        }

        const { keyPattern, ttl } = debounce;

        const request = context.switchToHttp().getRequest();

        const cacheKey = CacheEnum.DEBOUNCE_KEY + this.resolveKey(keyPattern, request);

        const isBlocked = await this.cache.get(cacheKey);

        if (isBlocked) {
            throw new HttpException('æ“ä½œè¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•', 429);
        }
        const data = await this.cache.set(cacheKey, true, ttl);
        return next.handle();
    }

    private resolveKey(pattern: string, request: any): string {
        return pattern.replace(/\{(\w+)\}/g, (match, paramName) => {
            // ä¼˜å…ˆä» paramsã€bodyã€queryã€user ä¸­æŸ¥æ‰¾
            const sources = [request.params, request.user, request.body, request.query];
            for (const src of sources) {
                if (src && src[paramName] !== undefined) {
                    return src[paramName];
                }
            }

            // æ”¯æŒ user.id ç­‰
            if (paramName.includes('.')) {
                const parts = paramName.split('.');
                let val = request;
                for (const part of parts) {
                    val = val?.[part];
                }
                return val || 'unknown';
            }

            return 'unknown';
        });
    }
}
```

5ã€å…¨å±€å¼•å…¥

```

providers: [
    {
        provide: APP_INTERCEPTOR,
        useClass: DebounceInterceptor
    },
]
```

6ã€ä½¿ç”¨

> Â éœ€è¦åšé˜²æŠ–çš„æ§åˆ¶å™¨ä¸Šæ·»åŠ å…ƒæ•°æ®. @Debounce(æ ‡è¯†ï¼Œè¿‡æœŸæ—¶é—´-æ¯«ç§’)
>
> ```
>
> @Put("/update")
> @Debounce('userUpdate:{userId}', 5000)
> update(@Body() body: UpdateUserDto) {
>     return this.userService.updateUser(body.userId, body)
> }
> ```

---------------------------------------------------------------------------------------------------------------------------------

æ—¢ç„¶è‡ªå·±å®šä¹‰äº†ç¼“å­˜æœåŠ¡ï¼Œé‚£ä¹ˆå…¨å±€æ³¨å†Œä¹Ÿå†™ä¸€ä¸ªå¥½äº†ï¼Œä½†æ˜¯ä¸å»ºè®®å…¨å±€åŒ–å“ˆ

> åŸºäºä¸Šé¢å…¨å±€æ³¨å†Œçš„"CACHE_MANAGER_INSTANCE" serviceï¼Œå†å†™ä¸€ä¸ªæ‹¦æˆªå™¨ï¼Œæ‹¦æˆªå™¨ä¸­åªå¤„ç†getè¯·æ±‚ï¼ŒåŒæ ·çš„åŸç†ï¼Œå¦‚æœæ˜¯getè¯·æ±‚çš„è¯ ï¼Œä»å…ƒæ•°æ®ä¸­å–å€¼ï¼Œå…ˆå»ç¼“å­˜ä¸­æŸ¥æ‰¾ï¼Œå­˜åœ¨ç›´æ¥è¿”å›ï¼Œä¸å­˜åœ¨èµ°è‡ªå·±çš„æ–¹æ³•ï¼Œå®Œäº‹å„¿åå†åƒç¼“å­˜ä¸­ä¿å­˜ä¸€ä»½
>
> ```
>
> import {
>     CallHandler,
>     ExecutionContext,
>     Inject,
>     Injectable,
>     NestInterceptor,
> } from '@nestjs/common';
> import { Observable, of } from 'rxjs';
> import { tap } from 'rxjs/operators';
> import { CACHE_KEY_METADATA, CACHE_TTL_METADATA, CacheKey, CacheTTL } from '@nestjs/cache-manager';
> import type { Cache } from 'cache-manager';
>
> @Injectable()
> export class HttpCacheInterceptor implements NestInterceptor {
>     constructor(
>         @Inject("CACHE_MANAGER_INSTANCE") private readonly cacheManager: Cache,
>     ) { }
>
>     async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
>         const request = context.switchToHttp().getRequest();
>         if (request.method !== 'GET') return next.handle();
>
>         const key = this.getCacheKey(context);
>         const ttl = this.getTTL(context);
>
>         const cached = await this.cacheManager.get(key);
>         if (cached) return of(cached);
>
>         return next.handle().pipe(
>             tap((response) => {
>                 this.cacheManager.set(key, response, ttl);
>             }),
>         );
>     }
>
>     private getCacheKey(context: ExecutionContext): string {
>         const key = Reflect.getMetadata(CACHE_KEY_METADATA, context.getHandler());
>         const request = context.switchToHttp().getRequest();
>         return key || `${request.method}_${request.url}`;
>     }
>
>     private getTTL(context: ExecutionContext): number {
>         const ttl = Reflect.getMetadata(CACHE_TTL_METADATA, context.getHandler());
>         return ttl || 60;
>     }
> }
> ```
>
> ç„¶åå…¨å±€åŒ–å°±å¯ä»¥å•¦
>
> ```
>
> {
>     provide: APP_INTERCEPTOR,
>     useClass: HttpCacheInterceptor
> }
> ```
>
> ä½¿ç”¨
>
> ```
>
> /**
> * 
> * å› ä¸ºå…¨å±€æ‹¦æˆªå™¨ä¸­å–çš„æ˜¯ import { CACHE_KEY_METADATA, CACHE_TTL_METADATA } from '@nestjs/cache-manager';
> * æ‰€ä»¥è¿™é‡Œç›´æ¥ä½¿ç”¨åŸæœ‰çš„å°±å¥½äº† CacheKey å’Œ CacheTTL
> */
> @Get("/list")
> @CacheTTL(10000)    //ä¸æŒ‡å®šçš„è¯å–å…¨å±€é»˜è®¤æ˜¯æ—¶é—´
> @CacheKey('list')   //ä¸æŒ‡å®šçš„è¯å–è·¯ç”±ç±»å‹+è·¯å¾„åœ°å€
> @RequirePermission(['system:user:query'])
> findList(@Query() query: ListUserDto) {
>     return this.userService.paginateUser(query)
> }
> ```

> å•ä¸ªæ–¹æ³•ä½¿ç”¨æ‰‹åŠ¨å†™å…¥ä¸€ä¸‹å°±å¥½äº†
>
> ```
>
> // ğŸ” å…ˆæŸ¥ç¼“å­˜
> const cached = await this.cacheManager.get(â€˜è‡ªå·±å®šä¹‰ä¸ªkeyâ€™);
> if (cached) {
>     console.log(`ğŸ¯ ç¼“å­˜å‘½ä¸­: ${cacheKey}`);
>     return cached;
> }
>
> // ğŸš€ æŸ¥è¯¢æ•°æ®åº“ï¼ˆæ¨¡æ‹Ÿï¼‰
> const result = await this.queryFromDatabase(query);
>
> // ğŸ’¾ å†™å…¥ç¼“å­˜ï¼Œæ¯«ç§’ä¸ºå•ä½
> await this.cacheManager.set(cacheKey, result, 10000);
>
> return result;
> ```



