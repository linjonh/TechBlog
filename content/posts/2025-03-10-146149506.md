---
layout: post
title: "涨薪技术Kubernetesk8s之Ingress"
date: 2025-03-10 11:48:56 +0800
description: "在使用普通的Service时，集群中每个节点的kube-proxy在监听到Service和Endpoints的变化时，会动态的修改相关的iptables的转发规则。然而伴随着Pod的销毁和重生，Pod的IP等信息不断地在改变，此时使用K8S提供的Service机制可以解决这一问题，Service通过标签选定指定的Pod作为后端服务，并监听这些Pod的变化。每当有新服务加入，都需要对该服务的配置进行修改、升级，在服务数量逐渐变多后，该配置项目会变得越来越大，手工修改的风险也会逐渐增高。"
keywords: "涨薪技术|Kubernetes(k8s)之Ingress"
categories: ['未分类']
tags: ['容器', '单元测试', '功能测试', '云原生', 'Kubernetes']
artid: "146149506"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146149506
    alt: "涨薪技术Kubernetesk8s之Ingress"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146149506
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146149506
cover: https://bing.ee123.net/img/rand?artid=146149506
image: https://bing.ee123.net/img/rand?artid=146149506
img: https://bing.ee123.net/img/rand?artid=146149506
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     涨薪技术|Kubernetes(k8s)之Ingress
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <strong>
      01Ingress介绍
     </strong>
    </h3>
    <p>
     Kubernetes暴露服务的方式目前只有三种：LoadBlancer Service、NodePort Service、Ingress;本节主要介绍ingress。
    </p>
    <p>
     ingress简单的说就是一个代理过程，可以根据配置转发请求到指定的服务上。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="459" src="https://i-blog.csdnimg.cn/img_convert/64e11c61ba039475102286353f5549bc.jpeg" width="1080"/>
    </p>
    <p>
     通俗来讲，ingress和之前提到的Service、Deployment，也是一个k8s的资源类型，ingress用于实现用域名的方式访问k8s内部应用。
    </p>
    <p>
     Ingress为Kubernetes集群中的服务提供了入口，可以提供负载均衡、SSL终止和基于名称的虚拟主机，在生产环境中常用的Ingress有Treafik、Nginx、HAProxy、Istio等。
    </p>
    <p>
     在Kubernetesv 1.1版中添加的Ingress用于从集群外部到集群内部Service的HTTP和HTTPS路由，流量从Internet到Ingress再到Services最后到Pod上，通常情况下，Ingress部署在所有的Node节点上。
    </p>
    <p>
     Ingress可以配置提供服务外部访问的URL、负载均衡、终止SSL，并提供基于域名的虚拟主机。但Ingress不会暴露任意端口或协议。
    </p>
    <p>
     由于K8S集群拥有强大的副本控制能力，Pod随时可能从一个节点上被驱逐到另一个节点上，或者直接销毁再来一个新的。
    </p>
    <p>
     然而伴随着Pod的销毁和重生，Pod的IP等信息不断地在改变，此时使用K8S提供的Service机制可以解决这一问题，Service通过标签选定指定的Pod作为后端服务，并监听这些Pod的变化。
    </p>
    <p>
     在对外暴露服务时，使用Service的NodePort是一个方法
    </p>
    <p>
     问题1-如何管理端口
    </p>
    <p>
     当需要对外暴露的服务量比较多的时候，端口管理的问题变会暴露出来。
    </p>
    <p>
     此时的一个处理方案是使用一个代理服务（例如nginx）根据请求信息将请求转发到不同的服务器上。
    </p>
    <p>
     问题2-如何管理转发配置
    </p>
    <p>
     每当有新服务加入，都需要对该服务的配置进行修改、升级，在服务数量逐渐变多后，该配置项目会变得越来越大，手工修改的风险也会逐渐增高。
    </p>
    <p>
     那么需要一个工具来简化这一过程，希望可以通过简单的配置动态生成代理中复杂的配置，最好还可以顺手重新加载配置文件。
    </p>
    <p>
     K8S刚好也提供了此类型资源。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="234" src="https://i-blog.csdnimg.cn/img_convert/720545f7ab934eb366195a0d92d10cd8.png" width="713"/>
    </p>
    <p>
     Ingress 工作原理
    </p>
    <p>
     （1）ingress-controller通过和 kubernetes APIServer 交互，动态的去感知集群中ingress规则变化，
    </p>
    <p>
     （2）然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置。
    </p>
    <p>
     （3）再写到nginx-ingress-controller的pod里，这个ingress-controller的pod里运行着一个Nginx服务，控制器会把生成的 nginx配置写入 /etc/nginx.conf文件中。
    </p>
    <p>
     （4）然后reload一下使配置生效。以此达到域名区分配置和动态更新的作用。
    </p>
    <p>
     在使用普通的Service时，集群中每个节点的kube-proxy在监听到Service和Endpoints的变化时，会动态的修改相关的iptables的转发规则。客户端在访问时通过iptables设置的规则进行路由转发达到访问服务的目的。
    </p>
    <p>
     而Ingress则跳过了kube-proxy这一层，通过Ingress Controller中的代理配置进行路由转发达到访问目标服务的目的。实际上可以把IngressController看做一个拥有默认处理后端的代理，根据Ingress资源的配置动态修改代理的配置文件，以实现按照规则转发请求的功能。
    </p>
    <p>
    </p>
    <h3>
     <strong>
      02Ingress环境准备
     </strong>
    </h3>
    <p>
     下面ingress-nginx为类来部署ingress-controller，具体的部署步骤如下：
    </p>
    <pre><code>#创建一个目录，目录名可以随便起，这里命令为ingress-controller</code><code>[root@master ~]# mkdir ingress-controller</code><code>#下载mandatory.yaml和service-nodeport.yaml两个文件</code><code>#这里下载了现成的，所以就直接拷贝进去即可</code><code>#拷贝进去后，需要注意的是修改mandatory.yaml文件的镜像路径，具体如下：</code><code>#将原来的内容修改为以下内容，这个是国内的镜像地址</code><code>image: shichao01/nginx-ingress-controller:0.30.0</code><code>#再运行以下命令进行部署</code><code>[root@master ingress-controller]# kubectl apply -f ./</code><code>#部署完成后可以查看部署的结果</code><code>[root@master ingress-controller]# kubectl get pod -n ingress-nginx</code><code>NAME READY STATUS RESTARTS AGE</code><code>nginx-ingress-controller-75bd94bd9d-lhn2g 1/1 Running 0 131m</code><code>#再使用以下命令来查看ingress-nginx暴露的端口</code><code>[root@master ingress-controller]# kubectl get svc -n ingress-nginx</code><code>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S)</code><code>AGE</code><code>ingress-nginx NodePort 10.96.163.204 &lt;none&gt;</code><code>80:30223/TCP,443:32552/TCP 132m</code></pre>
    <p>
     下面构建一个deployment和一个service的清单，内容如下:
    </p>
    <pre><code>apiVersion: apps/v1</code><code>kind: Deployment</code><code>metadata:</code><code>name: ingress-nginx</code><code>namespace: test-ingress</code><code>spec:</code><code>strategy:</code><code>type: Recreate</code><code>replicas: 3</code><code>selector:</code><code>matchLabels:</code><code>app: ingress-nginx</code><code>template:</code><code>metadata:</code><code>labels:</code><code>app: ingress-nginx</code><code>spec:</code><code>containers:</code><code>- name: ingress-nginx</code><code>image: nginx</code><code>ports:</code><code>- containerPort: 80</code><code>---</code><code>apiVersion: v1</code><code>kind: Service</code><code>metadata:</code><code>name: web-nginx</code><code>namespace: test-ingress</code><code>spec:</code><code>selector:</code><code>app: ingress-nginx</code><code>ports:</code><code>- protocol: TCP</code><code>port: 80</code><code>targetPort: 80</code><code>type: NodePort</code></pre>
    <p>
     再执行下面的命令进行部署
    </p>
    <pre><code>[root@master ~]# kubectl apply -f ingress-nginx-test.yaml</code></pre>
    <p>
    </p>
    <h3>
     <strong>
      03HTTP代理
     </strong>
    </h3>
    <p>
     实现请求暴露到http端口下，先需要配置ingress的规则，配置文件内容如下：
    </p>
    <pre><code># ingress规则中，要指定需要绑定暴露的svc名称</code><code>apiVersion: extensions/v1beta1</code><code>kind: Ingress</code><code>metadata:</code><code>name: ingress-http</code><code>namespace: test-ingress</code><code>spec:</code><code>rules: #定义路由规则</code><code>- host: nginx.chuansinfo.com # 主机名，只能是域名，修改为项目域名，但如果主机无法</code><code>解析到这个HOST，就会跳转到nginx主页，这样就会报404的错误，如果当报404错误时，就可以将这个选项</code><code>设置为空</code><code>http:</code><code>paths:</code><code>- path: /</code><code>backend:</code><code>serviceName: web-nginx # 后台部署的 Service Name</code><code>servicePort: 80 # 后台部署的 Service Port</code></pre>
    <p>
     使用以下命令来部署ingress-http.yaml文件
    </p>
    <pre><code>[root@master ~]# kubectl apply -f ingress-http.yaml</code></pre>
    <p>
     使用以下命令来查看刚创建的ingress-http​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get ing ingress-http -n test-ingress</code><code>Warning: extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in</code><code>v1.22+; use networking.k8s.io/v1 Ingress</code><code>NAME CLASS HOSTS ADDRESS PORTS AGE</code><code>ingress-http &lt;none&gt; nginx.chuansinfo.com 10.96.149.201 80 3m15s</code></pre>
    <p>
     使用下面命令可以看到详细情况​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl describe ing ingress-http -n test-ingress</code><code>Warning: extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in</code><code>v1.22+; use networking.k8s.io/v1 Ingress</code><code>Name: ingress-http</code><code>Namespace: ingress-nginx</code><code>Address: 10.96.149.201</code><code>Default backend: default-http-backend:80 (&lt;error: endpoints "default-httpbackend"</code><code>not found&gt;)</code><code>Rules:</code><code>Host Path Backends</code><code>---- ---- --------</code><code>nginx.chuansinfo.com</code><code>/ web-nginx:80</code><code>10.244.104.12:80,10.244.166.142:80,10.244.166.143:80)</code><code>Annotations: &lt;none&gt;</code><code>Events:</code><code>Type Reason Age From Message</code><code>---- ------ ---- ---- -------</code><code>Normal CREATE 5m4s nginx-ingress-controller Ingress ingress-nginx/ingresshttp</code><code>Normal UPDATE 4m42s nginx-ingress-controller Ingress ingress-nginx/ingresshttp</code></pre>
    <p>
     再输入http://192.168.158.100:32451进行访问即可，192.168.158.100是master节点的IP地址.
    </p>
    <p>
    </p>
    <h3>
     <strong>
      04HTTPS代理
     </strong>
    </h3>
    <p>
     1.生成自签名证书​​​​​​​
    </p>
    <pre><code>[root@master ~]# openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -</code><code>keyout tls.key -out tls.crt -subj</code><code>"/CN=tomcat.test.com/ST=Chuansinfo/L=Chuansinfo/O=devops/OU=unicorn"</code><code>-req是证书请求的子命令</code><code>-newkey rsa:2048 -keyout tls.key -newkey是与-key互斥的</code><code>-newkey是指在生成证书请求或者自签名证书的时候自动生成密钥，</code><code>-nodes 表示私钥不加密</code><code>-out 指定生成的证书请求或者自签名证书名称</code><code>-days 365 证书有效期</code><code>若执行自动输入，可使用-subj选项：</code><code>-subj——证书相关的用户信息(subject的缩写)</code><code>[root@master ~]# ls</code><code>always.yaml ingress-http.yaml never.yaml</code><code>quota-mem-cpu-pod.yaml</code><code>anaconda-ks.cfg ingress-nginx-test.yaml nginx-tomcat.yaml</code><code>quota-mem-cpu.yaml</code><code>calico.yaml ingress-tomcat-test.yaml onfailure.yaml</code><code>quota-pod.yaml</code><code>cpu-defaults-pod2.yaml memory-constraints-pod-2.yaml pod-hook-exec.yaml</code><code>service-clusterip.yaml</code><code>cpu-defaults-pod3.yaml memory-constraints-pod-3.yaml pod-nodeaffinitypreferred.</code><code>yaml service-nodeport.yaml</code><code>cpu-defaults-pod.yaml memory-constraints-pod-4.yaml pod-nodeaffinityrequired.</code><code>yaml service.yaml</code><code>cpu-default.yaml memory-constraints-pod.yaml pod-nodename.yaml</code><code>test-deployment.yaml</code><code>dashboard.yaml memory-constraints.yaml pod-nodeselector.yaml</code><code>test.txt</code><code>deployment-rolling.yaml memory-defaults-pod-2.yaml pod-podaffinityrequired.</code><code>yaml tls.crt</code><code>deployment.yaml memory-defaults-pod-3.yaml pod-podaffinitytarget.</code><code>yaml tls.key</code></pre>
    <p>
     2.将证书导入k8s的secret中，这里要指定namespace，否则ingress controller找不到证书​​​​​​​​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl create secret tls tls-secret --key=tls.key --cert</code><code>tls.crt -n dev</code><code>secret/tls-secret created</code></pre>
    <p>
     创建成功后可以使用下面的命令查看secret的相关信息
    </p>
    <pre><code>[root@master ~]# kubectl describe secret tls-secret</code></pre>
    <p>
     3、再创建个ingress资源文件指定使用https,文件名为tomcat-ingress.yaml
    </p>
    <p>
     主要就是添加了tls相关，域名还是不变的以及一个注解，并且引用了前面打入的证书​​​​​​​
    </p>
    <pre><code>apiVersion: networking.k8s.io/v1</code><code>kind: Ingress</code><code>metadata:</code><code>name: ingress-https</code><code>namespace: dev</code><code>annotations:</code><code>nginx.ingress.kubernetes.io/rewrite-target: /</code><code>spec:</code><code>ingressClassName: nginx</code><code>rules:</code><code>- host:</code><code>http:</code><code>paths:</code><code>- path: /</code><code>pathType: Prefix</code><code>backend:</code><code>service:</code><code>name: tomcat-service</code><code>port:</code><code>number: 8080</code><code>tls:</code><code>- hosts:</code><code>- tomcat.test.com</code><code>secretName: tls-secret</code></pre>
    <p>
     输入https://tomcat.test.com:30725进行访问
    </p>
    <p>
     需要注意的是端口要换成443对应的30725端口
    </p>
    <p>
     至此，有关K8S的知识就分享到这里，希望大家能把这些技术掌握好，在工作上会有很大的帮助和提升，落了之前的内容可以查阅往期文章，需要同步电子资料或者技术支持可以文末加微。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36303838393235342f:61727469636c652f64657461696c732f313436313439353036" class_="artid" style="display:none">
 </p>
</div>


