---
layout: post
title: "RabbitMQ常见面试题及解析"
date: 2025-03-16 12:12:23 +0800
description: "RabbitMQ是一个开源的消息队列系统，它实现了高级消息队列协议（AMQP）。它允许不同的应用程序之间进行异步通信，通过将消息发送到队列中，让消费者从队列中获取消息并进行处理，从而实现解耦、异步和削峰填谷等功能。"
keywords: "RabbitMQ常见面试题及解析"
categories: ['面试']
tags: ['面试', 'Rabbitmq']
artid: "146293165"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293165
    alt: "RabbitMQ常见面试题及解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293165
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293165
cover: https://bing.ee123.net/img/rand?artid=146293165
image: https://bing.ee123.net/img/rand?artid=146293165
img: https://bing.ee123.net/img/rand?artid=146293165
---

# RabbitMQ常见面试题及解析

#### 1、什么是RabbitMQ？

RabbitMQ是一个开源的消息队列系统，它实现了高级消息队列协议（AMQP）。它允许不同的应用程序之间进行异步通信，通过将消息发送到队列中，让消费者从队列中获取消息并进行处理，从而实现解耦、异步和削峰填谷等功能。

#### 2、核心组件与流程

**Producer：**发送消息的应用。

**Exchange：**接收消息并路由到队列（类型：Direct，Fanout，Topic，Headers）

**Queue：**存储消息的缓冲区

**Binding：**定义Exchange和Queue的规则

**Consumer：**从队列消费消息的应用

#### 3、RabbitMQ中的交换器（Exchange）有哪些类型？

**直连交换器（Direct Exchange）：**消息会被路由到与交换器绑定的队列中，路由键（Routing Key）完全匹配的队列**
（精确匹配Routing Key）**。

**扇出交换器（Fanout Exchange）：**将消息广播到所有与该交换器绑定的队列中，忽略路由键** （广播到所有绑定队列，忽略路由键）**。

**主题交换器（Topic
Exchange）：**消息会根据路由键和绑定键的模式匹配规则，被路由到对应的队列中。路由键和绑定键都是由点分隔的字符串，其中可以包含通配符**
（通配符匹配Routing Key( * 单词，# 多词 )）**。

**头交换器（Headers
Exchange）：**根据消息的头部属性来路由消息，而不是根据路由键。在绑定队列到交换器时，可以指定一些头部属性和值，当消息的头部属性与绑定的属性匹配时，消息就会被路由到该队列**
（通过消息头键值对匹配，忽略Routing Key）**。

#### 4、消息是如何在RabbitMQ中流转的？

生产者将消息发送到交换器，交换器根据路由键和自身的类型，决定将消息路由到哪些队列中，然后消息被存储在队列中。消费者从队列中获取消息进行处理。

#### 5、讲讲RabbitMQ的持久化机制

RabbitMQ可以将队列、交换器和消息都进行持久化。通过将相关信息存储到磁盘上，当RabbitMQ服务器重启后，这些持久化的对象和消息仍然可以被恢复，从而保证消息不会丢失。要使消息持久化，需要将消息的deliveryMode设置为2。对于队列和交换器，在声明时指定持久化参数即可。

#### 6、在分布式系统中，RabbitMQ有什么作用？

用于分布式系统中的异步通信，各个微服务之间可以通过消息队列进行解耦，提高系统的可扩展性和灵活性。例如，一个电商系统中，下单服务可以将订单消息发送到消息队列，让库存服务、物流服务等异步地处理订单相关的业务，而不需要下单服务等待所有其他服务都处理完成，从而提高系统的响应速度和吞吐量。

#### 7、RabbitMQ如何实现削峰填谷？

当系统面临高并发请求时，请求可以被快速地放入消息队列中，而消费者可以按照自己的处理能力从队列中慢慢获取消息进行处理，这样就可以避免系统因为瞬间的高并发而崩溃，起到了削峰的作用。同时，当请求量较低时，消费者也可以继续处理队列中积压的消息，实现填谷，使系统的负载更加均衡。

#### 8、RabbitMQ集群有哪些模式？

**普通集群模式：**集群中的节点之间会相互通信，共享队列的元数据信息，但消息只会存储在其中一个节点上。当消费者从其他节点上获取消息时，需要从存储消息的节点上拉取，可能会产生一定的网络开销。**
（节点间同步队列的元数据，但消息不冗余）**

**镜像集群模式：**消息会在多个节点上进行镜像存储，每个节点上都会有完整的消息副本。这样可以提高系统的高可用性，当一个节点出现故障时，其他节点可以继续提供服务，不会导致消息丢失。但这种模式会占用更多的存储空间和网络带宽。**
（消息跨节点复制，实现高可用（配置策略 ha-mode=all））**

#### 9、如何避免消息丢失？

##### **9.1生产者端**

**确认机制（Confirm）：**生产者将信道设置为确认模式，一旦消息被Broker接收，Broker会发送确认信号给生产者。如果生产者在一定时间内没有收到确认信号，可以认为消息发送失败，进行相应的处理，如重新发送消息。

**事务机制：**生产者可以通过开启事务来确保消息的可靠发送。在事务中，生产者发送消息后，如果提交事务成功，那么消息一定被Broker接收；如果提交事务失败，可以回滚事务并重发消息。不过，事务机制会严重影响性能，一般不建议在高并发场景下使用。

##### **9.2消息持久化**

**队列持久化：**在声明队列时，将队列设置为持久化。这样，即使RabbitMQ服务器重启，队列也不会丢失。

**消息持久化：**将消息的 deliveryMode 属性设置为2，表示消息持久化。消息会被写入磁盘，而不仅仅是内存中，从而在服务器重启或故障时能够恢复。

##### **9.3消费者端**

**关闭自动确认：**消费者在接收消息时，不使用自动确认机制，而是手动确认消息。只有当消费者成功处理完消息后，才向
Broker发送确认信号。如果消费者在处理消息过程中出现故障，没有发送确认信号，那么RabbitMQ会认为消息没有被成功处理，会将消息重新投递给其他消费者或在当前消费者恢复后再次投递。

**合理处理异常：**消费者在处理消息的过程中，要对可能出现的异常进行捕获和处理，避免因为异常导致消息处理中断而没有进行确认。如果消息处理失败，可以根据具体情况将消息放入死信队列，以便后续进行分析和处理。

##### **9.4集群与镜像队列**

**使用集群：**部署RabbitMQ集群，将消息分布在多个节点上，避免单个节点故障导致消息丢失。

**镜像队列：**采用镜像队列模式，将消息在多个节点上进行镜像备份。这样，当某个节点出现故障时，其他节点上的镜像队列可以继续提供服务，确保消息的高可用性。

##### 9.5简述版

**生产者端：**开启Confirm模式（异步确认消息到达Broker）。

**Broker端：**消息持久化——交换器持久化、队列持久化、消息持久化（Exchange、Queue、Message的 durable=true）

**消费者端：**关闭自动Ack，处理完成后手动Ack。

#### 10、消息确认机制（Ack）

**自动Ack：**消息发送后立即确认，易丢失。

**手动Ack：**处理完成后显式确认，失败可重试或转入死信队列。

#### 11、死信队列（DLX）的作用

处理无法被消费的消息（原因：消息被拒绝、TTL过期、队列满）。可用于重试或异常监控。

#### 12、如何实现延迟队列？

方案1：消息TTL + 死信队列（消息过期后转发到DLX）

  * 设置队列的TTL（Time to Live）：为队列中的消息设置过期时间，即 TTL。当消息在队列中停留的时间超过 TTL 指定的时间后，消息会变为 “死信”。
  * 配置死信交换器（Dead - Letter Exchange）：创建一个死信交换器，并将需要实现延迟队列功能的队列与该死信交换器绑定。当消息变为死信后，会被发送到死信交换器，然后再由死信交换器将消息路由到真正用于消费的队列中，消费者从这个队列中获取消息进行处理，从而实现了延迟队列的效果。

方案2：插件 rabbitmq + delayed + message + exchange(更灵活)

#### 13、消息顺序性保证

RabbitMQ 不保证全局顺序。若需顺序消费，可单队列单消费者，或业务层排序。

#### 14、提高吞吐量的方法

  * 调整 Channel的Qos（prefetchCount 控制未Ack消息数）
  * 批量发布消息，启用 Publisher Confirms
  * 权衡持久化（磁盘 I/O影响性能）

#### 15、消息堆积处理

  * 增加消费者或线程数
  * 监控并设置队列最大长度（x-max-length）
  * 临时扩容或降级非关键业务

#### 16、如何保证消息幂等性？

唯一ID + 业务层去重（如 Redis 记录已处理 ID）

#### 17、监控与管理工具

  * 内置 Web UI（Management Plugin）
  * Prometheus + Grafana 监控指标（队列长度、消息速率等）

#### 18、RabbitMQ 与 Kafka 对比

RabbitMQ：低延迟、灵活路由、适合事务性消息。

Kafka：高吞吐、分区顺序性、适合日志流和大数据场景。



