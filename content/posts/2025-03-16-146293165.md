---
layout: post
title: "RabbitMQ常见面试题及解析"
date: 2025-03-16 12:12:23 +0800
description: "RabbitMQ是一个开源的消息队列系统，它实现了高级消息队列协议（AMQP）。它允许不同的应用程序之间进行异步通信，通过将消息发送到队列中，让消费者从队列中获取消息并进行处理，从而实现解耦、异步和削峰填谷等功能。"
keywords: "RabbitMQ常见面试题及解析"
categories: ['面试']
tags: ['面试', 'Rabbitmq']
artid: "146293165"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293165
    alt: "RabbitMQ常见面试题及解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293165
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293165
cover: https://bing.ee123.net/img/rand?artid=146293165
image: https://bing.ee123.net/img/rand?artid=146293165
img: https://bing.ee123.net/img/rand?artid=146293165
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ常见面试题及解析
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h4>
     <a id="1RabbitMQ_0">
     </a>
     1、什么是RabbitMQ？
    </h4>
    <p>
     RabbitMQ是一个开源的消息队列系统，它实现了高级消息队列协议（AMQP）。它允许不同的应用程序之间进行异步通信，通过将消息发送到队列中，让消费者从队列中获取消息并进行处理，从而实现解耦、异步和削峰填谷等功能。
    </p>
    <h4>
     <a id="2_4">
     </a>
     2、核心组件与流程
    </h4>
    <p>
     **Producer：**发送消息的应用。
    </p>
    <p>
     **Exchange：**接收消息并路由到队列（类型：Direct，Fanout，Topic，Headers）
    </p>
    <p>
     **Queue：**存储消息的缓冲区
    </p>
    <p>
     **Binding：**定义Exchange和Queue的规则
    </p>
    <p>
     **Consumer：**从队列消费消息的应用
    </p>
    <h4>
     <a id="3RabbitMQExchange_16">
     </a>
     3、RabbitMQ中的交换器（Exchange）有哪些类型？
    </h4>
    <p>
     <strong>
      直连交换器（Direct Exchange）：
      <strong>
       消息会被路由到与交换器绑定的队列中，路由键（Routing Key）完全匹配的队列
      </strong>
      （精确匹配Routing Key）
     </strong>
     。
    </p>
    <p>
     <strong>
      扇出交换器（Fanout Exchange）：
      <strong>
       将消息广播到所有与该交换器绑定的队列中，忽略路由键
      </strong>
      （广播到所有绑定队列，忽略路由键）
     </strong>
     。
    </p>
    <p>
     <strong>
      主题交换器（Topic Exchange）：
      <strong>
       消息会根据路由键和绑定键的模式匹配规则，被路由到对应的队列中。路由键和绑定键都是由点分隔的字符串，其中可以包含通配符
      </strong>
      （通配符匹配Routing Key( * 单词，# 多词 )）
     </strong>
     。
    </p>
    <p>
     <strong>
      头交换器（Headers Exchange）：
      <strong>
       根据消息的头部属性来路由消息，而不是根据路由键。在绑定队列到交换器时，可以指定一些头部属性和值，当消息的头部属性与绑定的属性匹配时，消息就会被路由到该队列
      </strong>
      （通过消息头键值对匹配，忽略Routing Key）
     </strong>
     。
    </p>
    <h4>
     <a id="4RabbitMQ_26">
     </a>
     4、消息是如何在RabbitMQ中流转的？
    </h4>
    <p>
     生产者将消息发送到交换器，交换器根据路由键和自身的类型，决定将消息路由到哪些队列中，然后消息被存储在队列中。消费者从队列中获取消息进行处理。
    </p>
    <h4>
     <a id="5RabbitMQ_30">
     </a>
     5、讲讲RabbitMQ的持久化机制
    </h4>
    <p>
     RabbitMQ可以将队列、交换器和消息都进行持久化。通过将相关信息存储到磁盘上，当RabbitMQ服务器重启后，这些持久化的对象和消息仍然可以被恢复，从而保证消息不会丢失。要使消息持久化，需要将消息的deliveryMode设置为2。对于队列和交换器，在声明时指定持久化参数即可。
    </p>
    <h4>
     <a id="6RabbitMQ_34">
     </a>
     6、在分布式系统中，RabbitMQ有什么作用？
    </h4>
    <p>
     用于分布式系统中的异步通信，各个微服务之间可以通过消息队列进行解耦，提高系统的可扩展性和灵活性。例如，一个电商系统中，下单服务可以将订单消息发送到消息队列，让库存服务、物流服务等异步地处理订单相关的业务，而不需要下单服务等待所有其他服务都处理完成，从而提高系统的响应速度和吞吐量。
    </p>
    <h4>
     <a id="7RabbitMQ_38">
     </a>
     7、RabbitMQ如何实现削峰填谷？
    </h4>
    <p>
     当系统面临高并发请求时，请求可以被快速地放入消息队列中，而消费者可以按照自己的处理能力从队列中慢慢获取消息进行处理，这样就可以避免系统因为瞬间的高并发而崩溃，起到了削峰的作用。同时，当请求量较低时，消费者也可以继续处理队列中积压的消息，实现填谷，使系统的负载更加均衡。
    </p>
    <h4>
     <a id="8RabbitMQ_42">
     </a>
     8、RabbitMQ集群有哪些模式？
    </h4>
    <p>
     <strong>
      普通集群模式：
      <strong>
       集群中的节点之间会相互通信，共享队列的元数据信息，但消息只会存储在其中一个节点上。当消费者从其他节点上获取消息时，需要从存储消息的节点上拉取，可能会产生一定的网络开销。
      </strong>
      （节点间同步队列的元数据，但消息不冗余）
     </strong>
    </p>
    <p>
     <strong>
      镜像集群模式：
      <strong>
       消息会在多个节点上进行镜像存储，每个节点上都会有完整的消息副本。这样可以提高系统的高可用性，当一个节点出现故障时，其他节点可以继续提供服务，不会导致消息丢失。但这种模式会占用更多的存储空间和网络带宽。
      </strong>
      （消息跨节点复制，实现高可用（配置策略 ha-mode=all））
     </strong>
    </p>
    <h4>
     <a id="9_48">
     </a>
     9、如何避免消息丢失？
    </h4>
    <h5>
     <a id="91_50">
     </a>
     <strong>
      9.1生产者端
     </strong>
    </h5>
    <p>
     **确认机制（Confirm）：**生产者将信道设置为确认模式，一旦消息被Broker接收，Broker会发送确认信号给生产者。如果生产者在一定时间内没有收到确认信号，可以认为消息发送失败，进行相应的处理，如重新发送消息。
    </p>
    <p>
     **事务机制：**生产者可以通过开启事务来确保消息的可靠发送。在事务中，生产者发送消息后，如果提交事务成功，那么消息一定被Broker接收；如果提交事务失败，可以回滚事务并重发消息。不过，事务机制会严重影响性能，一般不建议在高并发场景下使用。
    </p>
    <h5>
     <a id="92_56">
     </a>
     <strong>
      9.2消息持久化
     </strong>
    </h5>
    <p>
     **队列持久化：**在声明队列时，将队列设置为持久化。这样，即使RabbitMQ服务器重启，队列也不会丢失。
    </p>
    <p>
     **消息持久化：**将消息的 deliveryMode 属性设置为2，表示消息持久化。消息会被写入磁盘，而不仅仅是内存中，从而在服务器重启或故障时能够恢复。
    </p>
    <h5>
     <a id="93_62">
     </a>
     <strong>
      9.3消费者端
     </strong>
    </h5>
    <p>
     **关闭自动确认：**消费者在接收消息时，不使用自动确认机制，而是手动确认消息。只有当消费者成功处理完消息后，才向 Broker发送确认信号。如果消费者在处理消息过程中出现故障，没有发送确认信号，那么RabbitMQ会认为消息没有被成功处理，会将消息重新投递给其他消费者或在当前消费者恢复后再次投递。
    </p>
    <p>
     **合理处理异常：**消费者在处理消息的过程中，要对可能出现的异常进行捕获和处理，避免因为异常导致消息处理中断而没有进行确认。如果消息处理失败，可以根据具体情况将消息放入死信队列，以便后续进行分析和处理。
    </p>
    <h5>
     <a id="94_68">
     </a>
     <strong>
      9.4集群与镜像队列
     </strong>
    </h5>
    <p>
     **使用集群：**部署RabbitMQ集群，将消息分布在多个节点上，避免单个节点故障导致消息丢失。
    </p>
    <p>
     **镜像队列：**采用镜像队列模式，将消息在多个节点上进行镜像备份。这样，当某个节点出现故障时，其他节点上的镜像队列可以继续提供服务，确保消息的高可用性。
    </p>
    <h5>
     <a id="95_74">
     </a>
     9.5简述版
    </h5>
    <p>
     **生产者端：**开启Confirm模式（异步确认消息到达Broker）。
    </p>
    <p>
     **Broker端：**消息持久化——交换器持久化、队列持久化、消息持久化（Exchange、Queue、Message的 durable=true）
    </p>
    <p>
     **消费者端：**关闭自动Ack，处理完成后手动Ack。
    </p>
    <h4>
     <a id="10Ack_82">
     </a>
     10、消息确认机制（Ack）
    </h4>
    <p>
     **自动Ack：**消息发送后立即确认，易丢失。
    </p>
    <p>
     **手动Ack：**处理完成后显式确认，失败可重试或转入死信队列。
    </p>
    <h4>
     <a id="11DLX_88">
     </a>
     11、死信队列（DLX）的作用
    </h4>
    <p>
     处理无法被消费的消息（原因：消息被拒绝、TTL过期、队列满）。可用于重试或异常监控。
    </p>
    <h4>
     <a id="12_92">
     </a>
     12、如何实现延迟队列？
    </h4>
    <p>
     方案1：消息TTL + 死信队列（消息过期后转发到DLX）
    </p>
    <ul>
     <li>
      设置队列的TTL（Time to Live）：为队列中的消息设置过期时间，即 TTL。当消息在队列中停留的时间超过 TTL 指定的时间后，消息会变为 “死信”。
     </li>
     <li>
      配置死信交换器（Dead - Letter Exchange）：创建一个死信交换器，并将需要实现延迟队列功能的队列与该死信交换器绑定。当消息变为死信后，会被发送到死信交换器，然后再由死信交换器将消息路由到真正用于消费的队列中，消费者从这个队列中获取消息进行处理，从而实现了延迟队列的效果。
     </li>
    </ul>
    <p>
     方案2：插件 rabbitmq + delayed + message + exchange(更灵活)
    </p>
    <h4>
     <a id="13_101">
     </a>
     13、消息顺序性保证
    </h4>
    <p>
     RabbitMQ 不保证全局顺序。若需顺序消费，可单队列单消费者，或业务层排序。
    </p>
    <h4>
     <a id="14_105">
     </a>
     14、提高吞吐量的方法
    </h4>
    <ul>
     <li>
      调整 Channel的Qos（prefetchCount 控制未Ack消息数）
     </li>
     <li>
      批量发布消息，启用 Publisher Confirms
     </li>
     <li>
      权衡持久化（磁盘 I/O影响性能）
     </li>
    </ul>
    <h4>
     <a id="15_111">
     </a>
     15、消息堆积处理
    </h4>
    <ul>
     <li>
      增加消费者或线程数
     </li>
     <li>
      监控并设置队列最大长度（x-max-length）
     </li>
     <li>
      临时扩容或降级非关键业务
     </li>
    </ul>
    <h4>
     <a id="16_117">
     </a>
     16、如何保证消息幂等性？
    </h4>
    <p>
     唯一ID + 业务层去重（如 Redis 记录已处理 ID）
    </p>
    <h4>
     <a id="17_121">
     </a>
     17、监控与管理工具
    </h4>
    <ul>
     <li>
      内置 Web UI（Management Plugin）
     </li>
     <li>
      Prometheus + Grafana 监控指标（队列长度、消息速率等）
     </li>
    </ul>
    <h4>
     <a id="18RabbitMQ__Kafka__126">
     </a>
     18、RabbitMQ 与 Kafka 对比
    </h4>
    <p>
     RabbitMQ：低延迟、灵活路由、适合事务性消息。
    </p>
    <p>
     Kafka：高吞吐、分区顺序性、适合日志流和大数据场景。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6368695f3636362f:61727469636c652f64657461696c732f313436323933313635" class_="artid" style="display:none">
 </p>
</div>


