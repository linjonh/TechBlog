---
layout: post
title: "蓝桥杯走迷宫BFS算法"
date: 2025-03-09 01:22:53 +0800
description: "G 的每个格子要么是道路，要么是障碍物（道路用 11表示，障碍物用 0 表示）。已知迷宫的入口位置为 (x1​,y1​)，出口位置为 (x2​,y2​)。问从入口走到出口，最少要走多少个格子。接下来输入一个 𝑁×𝑀N×M 的矩阵。若 Gi,j​=1 表示其为道路，否则表示其为障碍物。最后一行输入四个整数 𝑥1,𝑦1,𝑥2,𝑦2表示入口的位置和出口的位置。输入第 11 行包含两个正整数 N,M，分别表示迷宫的大小。输出仅一行，包含一个整数表示答案。若无法从入口到出口，则输出 −1；"
keywords: "蓝桥杯—走迷宫(BFS算法)"
categories: ['算法竞赛题目超详细解析']
tags: ['蓝桥杯', '算法', '深度优先', '广度优先', '宽度优先', 'C']
artid: "146126076"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146126076
    alt: "蓝桥杯走迷宫BFS算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146126076
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146126076
cover: https://bing.ee123.net/img/rand?artid=146126076
image: https://bing.ee123.net/img/rand?artid=146126076
img: https://bing.ee123.net/img/rand?artid=146126076
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥杯—走迷宫(BFS算法)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="题目描述">
     题目描述
    </h2>
    <p>
     给定一个N×M 的网格迷宫 G。G 的每个格子要么是道路，要么是障碍物（道路用 11表示，障碍物用 0 表示）。
    </p>
    <p>
     已知迷宫的入口位置为 (x1​,y1​)，出口位置为 (x2​,y2​)。问从入口走到出口，最少要走多少个格子。
    </p>
    <h4 id="输入描述">
     输入描述
    </h4>
    <p>
     输入第 11 行包含两个正整数 N,M，分别表示迷宫的大小。
    </p>
    <p>
     接下来输入一个 𝑁×𝑀N×M 的矩阵。若 Gi,j​=1 表示其为道路，否则表示其为障碍物。
    </p>
    <p>
     最后一行输入四个整数 𝑥1,𝑦1,𝑥2,𝑦2表示入口的位置和出口的位置。
    </p>
    <p>
     1≤N,M≤102，0≤Gi,j​≤1，1≤x1​,x2​≤N，1≤y1​,y2​≤M。
    </p>
    <h4 id="输出描述">
     输出描述
    </h4>
    <p>
     输出仅一行，包含一个整数表示答案。
    </p>
    <p>
     若无法从入口到出口，则输出 −1；
    </p>
    <h4 id="输入输出样例">
     输入输出样例
    </h4>
    <h5 id="示例-1">
     示例 1
    </h5>
    <blockquote>
     <p>
      输入
     </p>
    </blockquote>
    <pre><code>5 5 
1 0 1 1 0
1 1 0 1 1 
0 1 0 1 1
1 1 1 1 1
1 0 0 0 1
1 1 5 5 
</code></pre>
    <p>
    </p>
    <blockquote>
     <p>
      输出
     </p>
    </blockquote>
    <pre><code>8
</code></pre>
    <p>
    </p>
    <h4 id="运行限制">
     运行限制
    </h4>
    <ul>
     <li>
      最大运行时间：1s
     </li>
     <li>
      最大运行内存: 128M
     </li>
    </ul>
    <h3>
     代码为：
    </h3>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define  x first
#define  y second
using namespace std;
typedef pair&lt;int,int&gt; PII;
const int N=1e2+10;
int n,m;
int x2,y2;//出口的位置
int g[N][N];//存储地图
int dist[N][N];//每个点到起点的距离 
queue&lt;PII&gt; q;//存坐标
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};

int bfs(int x1,int y1)
{
  memset(dist,-1,sizeof dist);//初始都为-1
  q.push({x1,y1});
  dist[x1][y1]=0;

  while(!q.empty()){
    auto Top=q.front();//取出对头
    q.pop();//弹出对头

    for(int i=0;i&lt;4;i++)
    {
    int a=Top.x+dx[i];
    int b=Top.y+dy[i];//入口的位置的下一个位置
    if(a&lt;0||a&gt;n||b&lt;0||b&gt;m) continue;//越界
    if(g[a][b]!=1) continue;//不是道路
   if(dist[a][b]&gt;1) continue;
    q.push({a,b});

    dist[a][b]=dist[Top.x][Top.y]+1;

    if(a==x2&amp;&amp;b==y2) return dist[x2][y2];

    }
  }
 return -1;
}

int main()
{
  ios::sync_with_stdio(false);
  cin.tie(0);
  int x1,y1;//入口的位置
  cin&gt;&gt;n&gt;&gt;m;
  for(int i=1;i&lt;=n;i++)
  {
    for(int j=1;j&lt;=m;j++)
    cin&gt;&gt;g[i][j];
  }
  cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
  int res=bfs(x1,y1);
  cout&lt;&lt;res&lt;&lt;'\n';
  return 0;
}</code></pre>
    <h3>
     优化后的代码（运行时间1ms）：
    </h3>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define  x first
#define  y second
using namespace std;
typedef pair&lt;int,int&gt; PII;
const int N=1e2+10;
int n,m;
int x2,y2;//出口的位置
int g[N][N];//存储地图
int dist[N][N];//每个点到起点的距离 
queue&lt;PII&gt; q;//存坐标
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};

int bfs(int x1,int y1)
{
  memset(dist,-1,sizeof dist);//初始都为-1
  q.push({x1,y1});
  dist[x1][y1]=0;

  while(!q.empty()){
    auto Top=q.front();//取出对头
    q.pop();//弹出对头

    for(int i=0;i&lt;4;i++)
    {
    int a=Top.x+dx[i];
    int b=Top.y+dy[i];//入口的位置的下一个位置
    if(a&lt;0||a&gt;n||b&lt;0||b&gt;m) continue;//越界
    if(g[a][b]!=1) continue;//不是道路
   if(dist[a][b]&gt;1) continue;
    q.push({a,b});

    dist[a][b]=dist[Top.x][Top.y]+1;

    if(a==x2&amp;&amp;b==y2) return dist[a][b];

    }
  }
 return -1;
}

int main()
{
  ios::sync_with_stdio(false);
  cin.tie(0);
  int x1,y1;//入口的位置
  cin&gt;&gt;n&gt;&gt;m;
  for(int i=1;i&lt;=n;i++)
  {
    for(int j=1;j&lt;=m;j++)
    cin&gt;&gt;g[i][j];
  }
  cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
  int res=bfs(x1,y1);
  cout&lt;&lt;res&lt;&lt;'\n';
  return 0;
}</code></pre>
    <p>
     <img alt="" height="136" src="https://i-blog.csdnimg.cn/direct/dd6db4b7e5174fbf9803f8277f08bec9.png" width="1186"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37393732343339342f:61727469636c652f64657461696c732f313436313236303736" class_="artid" style="display:none">
 </p>
</div>


