---
layout: post
title: "Qt程序基于共享内存读写CodeSys的变量"
date: 2025-03-15 14:37:05 +0800
description: "但是，在实际的项目中，要到使用到的结构体往往是多种类型的结构体互相嵌套的结果。假如我们和PLC的通讯只是简单的一个结构体，结构体中都是一些POD（Plain Old Data），那可以直接和PLC程序编写人员协商沟通好，让他把结构的定义代码发给你，你再根据ST代码写出结构体的C++代码。要想将Application的结构体数据直接导出，貌似是不行的，但是可以先把结构体数据复制到一个Library工程，然后导出m4文件，最后利用python脚本翻译（处理）成我们需要的代码。"
keywords: "Qt程序基于共享内存读写CodeSys的变量"
categories: ['Qt', 'Codesys']
tags: ['数据库', 'Qt', 'Java']
artid: "146276791"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146276791
    alt: "Qt程序基于共享内存读写CodeSys的变量"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146276791
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146276791
cover: https://bing.ee123.net/img/rand?artid=146276791
image: https://bing.ee123.net/img/rand?artid=146276791
img: https://bing.ee123.net/img/rand?artid=146276791
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Qt程序基于共享内存读写CodeSys的变量
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="1_1">
     </a>
     1.背景
    </h2>
    <p>
     在文章
     <a href="https://blog.csdn.net/joyopirate/article/details/146253498">
      【基于RTTR在C++中实现结构体数据的多层级动态读写】
     </a>
     中，我们实现了通过字符串读写结构体中的变量。那么接下来我们开始与CodeSys来进行交互。
     <br/>
     由于我们是基于共享内存来通讯的，那么我们需要对共享的内存定义一个数据结构，也就是一个结构体。
     <br/>
     假如我们和PLC的通讯只是简单的一个结构体，结构体中都是一些POD（Plain Old Data），那可以直接和PLC程序编写人员协商沟通好，让他把结构的定义代码发给你，你再根据ST代码写出结构体的C++代码。
     <br/>
     但是，在实际的项目中，要到使用到的结构体往往是多种类型的结构体互相嵌套的结果。不仅结构体多、数据多，而且还存在数组、嵌套的方式，单纯靠手工来拷贝ST代码-》转C++代码必定是繁琐且容易出错的。因此，必须得搞一套稳定可靠的导出导入机制。
     <br/>
     这里我选择通过利用CodeSys的机制+python脚本来实现
    </p>
    <h2>
     <a id="2CodeSysC_8">
     </a>
     2.结构体从CodeSys导出后导入到C++
    </h2>
    <p>
     要想将Application的结构体数据直接导出，貌似是不行的，但是可以先把结构体数据复制到一个Library工程，然后导出m4文件，最后利用python脚本翻译（处理）成我们需要的代码。
    </p>
    <h3>
     <a id="21CodeSys_10">
     </a>
     2.1.将结构体从CodeSys中导出
    </h3>
    <p>
     我这里有一个Application工程，里面定义了若干结构体
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/75a6e442751b474f8fd7fb2cbe4bd605.png"/>
    </p>
    <p>
     假如想将其导出，那么可以新建一个Library工程，然后将结构体复制过去（直接在左侧的树状列表中选择、复制，而不是直接复制代码）。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b3847c4b535842d89516f75d59a20e06.png">
      <br/>
      然后选择 编译–》生成运行时系统文件
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/83163eec897a4ee1bbfc30a4fd9204b5.png">
       <br/>
       然后勾选M4接口文件
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1d3e1b78e1164a2c99b6db940a21ed71.png">
        <br/>
        然后点击确定、生成M4文件。
        <br/>
        如此，便完成了结构体的导出。
       </img>
      </img>
     </img>
    </p>
    <h3>
     <a id="22m4c_23">
     </a>
     2.2.将结构体从m4文件提取翻译成c++格式
    </h3>
    <p>
     其实打开M4文件看一下，可以发现，导出数据已经是c语言格式的结构体了，基本都可以拿来直接用了，但是由于后面要和RTTR结合使用，必须还得清洗处理一下。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3fc90a180ed64c5e9b7b563c7e930ea9.png">
      M4文件的清洗处理我们需要用到clang（LLVM）库。
      <br/>
      我们是在python中使用clang，因此我们需要在python中安装此工具包，我安装的是20.1.0：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f3ec2e9b72ee4fb491d939624389f15f.png">
       但是在python中安装了还不行，还得去官网将依赖的库及程序文件下载下来
       <br/>
       <a href="https://github.com/llvm/llvm-project/releases">
        【llvm github】
       </a>
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/909a14bab7964843b057f61985e316eb.png">
        下载之后，解压到某个路径下即可，不用安装
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/c0ccb4f05bdd4a74afd0045f03daa88b.png">
         <br/>
         然后就可以使用脚本了，这是我的脚本
         <br/>
         在脚本中指定好M4文件所在路径、中间文件保存路径、最终文件保存路径，运行即可
        </img>
       </img>
      </img>
     </img>
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> sys
<span class="token keyword">import</span> clang<span class="token punctuation">.</span>cindex
<span class="token keyword">from</span> clang<span class="token punctuation">.</span>cindex <span class="token keyword">import</span> CursorKind<span class="token punctuation">,</span> TypeKind<span class="token punctuation">,</span> Config
<span class="token keyword">import</span> os

<span class="token comment"># 前面提到的clang压缩包的解压的路径，根据自己的路径指定</span>
Config<span class="token punctuation">.</span>set_library_path<span class="token punctuation">(</span><span class="token string">"D:/Qt/clang+llvm-20.1.0-x86_64-pc-windows-msvc/bin"</span><span class="token punctuation">)</span>

<span class="token comment"># M4文件位置</span>
m4FilePath <span class="token operator">=</span> <span class="token string">r'C:/Users/Administrator/Desktop/stateTest/StructOutputItf.m4'</span>
<span class="token comment"># 中间文件位置</span>
middleFilePath <span class="token operator">=</span> <span class="token string">"./output/tmpFile.h"</span>
<span class="token comment"># 处理后的文件位置</span>
outputFilePath <span class="token operator">=</span> <span class="token string">"./output/memorydefine.h"</span>


<span class="token keyword">def</span> <span class="token function">convert_c_struct_to_cpp</span><span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token punctuation">:</span>
    index <span class="token operator">=</span> clang<span class="token punctuation">.</span>cindex<span class="token punctuation">.</span>Index<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># tu = index.parse(input_file, args=['-std=c++11'])</span>

    <span class="token comment"># Windows特定参数</span>
    args <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token string">'-finput-charset=UTF-8'</span><span class="token punctuation">,</span>
        <span class="token string">'-std=c++11'</span><span class="token punctuation">,</span>
        <span class="token string">'-x'</span><span class="token punctuation">,</span> <span class="token string">'c++'</span><span class="token punctuation">,</span>  <span class="token comment"># 强制按C++模式解析</span>
        <span class="token comment"># r'-IC:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include',  # MSVC头文件路径</span>
        <span class="token comment"># r'-IC:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt',  # Windows SDK路径,</span>
        <span class="token string">r'-IC:\Program Files\CODESYS 3.5.19.60\CODESYS\CODESYS Control SL Extension Package\4.10.0.0\ExtensionSDK\include'</span><span class="token punctuation">,</span>
        <span class="token comment"># Windows SDK路径,</span>
        <span class="token comment"># r'-ID:\Qt5.15\5.15.2\msvc2019_64\include\QtCore',</span>
    <span class="token punctuation">]</span>
    tu <span class="token operator">=</span> index<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> args<span class="token operator">=</span>args<span class="token punctuation">)</span>

    struct_defs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">analyze_typedef</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>kind <span class="token operator">==</span> CursorKind<span class="token punctuation">.</span>TYPEDEF_DECL<span class="token punctuation">:</span>
            canonical_type <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>get_canonical<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># print("--", canonical_type.spelling)</span>
            <span class="token comment"># if canonical_type.spelling.startswith("tag"):</span>
            <span class="token comment">#     print("--", canonical_type.spelling)</span>

            <span class="token keyword">if</span> canonical_type<span class="token punctuation">.</span>kind <span class="token operator">==</span> TypeKind<span class="token punctuation">.</span>RECORD<span class="token punctuation">:</span>
                struct_decl <span class="token operator">=</span> canonical_type<span class="token punctuation">.</span>get_declaration<span class="token punctuation">(</span><span class="token punctuation">)</span>
                struct_defs<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
                    <span class="token string">'new_name'</span><span class="token punctuation">:</span> node<span class="token punctuation">.</span>spelling<span class="token punctuation">,</span>
                    <span class="token string">'members'</span><span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">(</span>get_struct_members<span class="token punctuation">(</span>struct_decl<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_struct_members</span><span class="token punctuation">(</span>struct_decl<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> child <span class="token keyword">in</span> struct_decl<span class="token punctuation">.</span>get_children<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> child<span class="token punctuation">.</span>kind <span class="token operator">==</span> CursorKind<span class="token punctuation">.</span>FIELD_DECL<span class="token punctuation">:</span>
                <span class="token comment"># print("type:", child.type.spelling, child.type.get_array_size(), child.type.get_canonical().spelling)</span>
                child_type <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>spelling
                child_name <span class="token operator">=</span> child<span class="token punctuation">.</span>spelling
                <span class="token keyword">if</span> child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>get_array_size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># 数组需要特殊处理</span>
                    prefix <span class="token operator">=</span> child_type<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                    child_type <span class="token operator">=</span> prefix
                    child_name <span class="token operator">+=</span> child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>spelling<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
                    <span class="token comment"># print("----", child_type, child_name)</span>

                <span class="token keyword">if</span> child_type <span class="token operator">==</span> <span class="token string">'int'</span> <span class="token keyword">or</span> child_type <span class="token operator">==</span> <span class="token string">'int *'</span><span class="token punctuation">:</span>
                    child_type <span class="token operator">=</span> <span class="token string">'没定义_自己处理'</span>

                <span class="token keyword">yield</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token string">'type'</span><span class="token punctuation">:</span> child_type<span class="token punctuation">,</span>
                    <span class="token string">'name'</span><span class="token punctuation">:</span> child_name
                <span class="token punctuation">}</span>

    <span class="token keyword">def</span> <span class="token function">generate_cpp_struct</span><span class="token punctuation">(</span>def_info<span class="token punctuation">)</span><span class="token punctuation">:</span>
        lines <span class="token operator">=</span> <span class="token punctuation">[</span>
            <span class="token string-interpolation"><span class="token string">f"struct </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>def_info<span class="token punctuation">[</span><span class="token string">'new_name'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>
            <span class="token string">"{"</span>
        <span class="token punctuation">]</span>
        <span class="token keyword">for</span> member <span class="token keyword">in</span> def_info<span class="token punctuation">[</span><span class="token string">'members'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"    </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>member<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>member<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">;"</span></span><span class="token punctuation">)</span>
        lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"};\n"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>lines<span class="token punctuation">)</span>

    <span class="token comment"># AST遍历</span>
    <span class="token keyword">for</span> node <span class="token keyword">in</span> tu<span class="token punctuation">.</span>cursor<span class="token punctuation">.</span>get_children<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        analyze_typedef<span class="token punctuation">(</span>node<span class="token punctuation">)</span>

    <span class="token comment"># 生成纯净CPP代码</span>
    output_content <span class="token operator">=</span> <span class="token triple-quoted-string string">"""#ifndef MEMORYDEFINE_H
#define MEMORYDEFINE_H
#include "CmpStd.h"
// ST语言的数据类型所占用的字节数：https://blog.csdn.net/u013186651/article/details/135324625
// 默认string类型的字节为：80 + 1
// 转换之后，假如出现了 int ，那么这个类型应该就是没有被正确识别，需要手动替换处理

// 有很多系统的第三方的库结构是没办法导出，因此需要自己在PLC系统中测量，然后自行用数组类型替换
// 替换的目的是内存对齐
// SMC_POS_REF --&gt;48 Byte
// MC_KIN_REF_SM3 --&gt; 8 Byte
// Kin_ArticulatedRobot_6DOF --&gt; 760 Byte

"""</span>
    output_content <span class="token operator">+=</span> <span class="token string">'\r\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>generate_cpp_struct<span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">for</span> d <span class="token keyword">in</span> struct_defs<span class="token punctuation">]</span><span class="token punctuation">)</span>

    output_content <span class="token operator">+=</span> <span class="token string">'\r\n#endif // MEMORYDEFINE_H'</span>

    <span class="token comment"># 写入文件</span>
    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>output_file<span class="token punctuation">)</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>output_file<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>output_content<span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    source_code <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
    #include "CmpStd.h"
    
    // 系统未定义或者M4文件没有导出的类型，然后又通过PLC程序知道其长度
    struct SMC_POS_REF{int8_t data[48];};
    struct MC_KIN_REF_SM3{int8_t data[8];};
    struct Kin_ArticulatedRobot_6DOF{int8_t data[760];};
    
    """</span>

    <span class="token comment"># 读取m4文件内容</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>m4FilePath<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> m4File<span class="token punctuation">:</span>
        content <span class="token operator">=</span> m4File<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 找到开始和结束标记的位置</span>
    start_marker <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
#ifdef __cplusplus
extern "C" {
#endif
"""</span>
    end_marker <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
#ifdef __cplusplus
}
#endif
"""</span>
    start_index <span class="token operator">=</span> content<span class="token punctuation">.</span>find<span class="token punctuation">(</span>start_marker<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span>start_marker<span class="token punctuation">)</span>
    end_index <span class="token operator">=</span> content<span class="token punctuation">.</span>find<span class="token punctuation">(</span>end_marker<span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> end_index<span class="token punctuation">)</span>
    <span class="token comment"># 检查是否找到了开始和结束标记</span>
    <span class="token keyword">if</span> start_index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">and</span> end_index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token comment"># 截取标记之间的内容</span>
        extracted_content <span class="token operator">=</span> content<span class="token punctuation">[</span>start_index<span class="token punctuation">:</span>end_index<span class="token punctuation">]</span>

        source_code <span class="token operator">+=</span> extracted_content

        <span class="token comment"># 创建一个临时文件</span>
        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>middleFilePath<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> middleFile<span class="token punctuation">:</span>
            <span class="token comment"># 将源代码字符串写入文件</span>
            middleFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>source_code<span class="token punctuation">)</span>
            <span class="token comment"># 确保内容被写入磁盘</span>
            middleFile<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始转换"</span><span class="token punctuation">)</span>
        convert_c_struct_to_cpp<span class="token punctuation">(</span>middleFilePath<span class="token punctuation">,</span> outputFilePath<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"操作完成-----》"</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"m4文件内容有误，无法提取"</span><span class="token punctuation">)</span>

</code></pre>
    <p>
     脚本的一些注意事项已经在代码中注释了，就不另外说明了。
     <br/>
     运行完脚本，就可以得到了符合我们需求的c++格式的代码文件了
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/33a8ce55b2764321af5f1304f3b07791.png">
      脚本先将M4文件中的主要内容提取出来，然后添加一个头文件保存为一个中间文件。此时这个中间文件的结构体的定义还是c风格的。
      <br/>
      然后将此中间文件交给clang解析，将结构体的内容分析出来，然后再将结构体的名称由原来的带tag的替换成没有带tag的。最后将所有结构体的内容保存成一个cpp风格的h文件。
      <br/>
      需要注意的是，生成的头文件中有很多不必要的信息，自己手动删除即可。
     </img>
    </p>
    <h2>
     <a id="3RTTR_203">
     </a>
     3.添加RTTR注册信息
    </h2>
    <p>
     从我们前一篇文章可以知道，要使用RTTR的功能，必须要对每一个结构体进行注册处理。我们结构体这么多，一个个手动写代码，不现实。我们还是用脚本来自动处理吧，这个脚本输入的是前面脚本生成的头文件：
    </p>
    <pre><code class="prism language-python"><span class="token keyword">import</span> sys
<span class="token keyword">import</span> clang<span class="token punctuation">.</span>cindex
<span class="token keyword">from</span> clang<span class="token punctuation">.</span>cindex <span class="token keyword">import</span> CursorKind

clang<span class="token punctuation">.</span>cindex<span class="token punctuation">.</span>Config<span class="token punctuation">.</span>set_library_path<span class="token punctuation">(</span><span class="token string">"D:/Qt/clang+llvm-20.1.0-x86_64-pc-windows-msvc/bin"</span><span class="token punctuation">)</span>

srcFilePath <span class="token operator">=</span> <span class="token string">"./output/memorydefine.h"</span>
dstFilePath <span class="token operator">=</span> <span class="token string">"./output/memorydefine.cpp"</span>

<span class="token keyword">def</span> <span class="token function">get_struct_members</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">:</span>
    members <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> child <span class="token keyword">in</span> cursor<span class="token punctuation">.</span>get_children<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> child<span class="token punctuation">.</span>kind <span class="token operator">==</span> CursorKind<span class="token punctuation">.</span>FIELD_DECL<span class="token punctuation">:</span>
            member_type <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>spelling
            <span class="token comment"># 处理数组类型（保留方括号）</span>
            <span class="token keyword">if</span> child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>get_array_size<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                array_size <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>get_array_size<span class="token punctuation">(</span><span class="token punctuation">)</span>
                member_type <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>child<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">.</span>element_type<span class="token punctuation">.</span>spelling<span class="token punctuation">}</span></span><span class="token string">[</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>array_size<span class="token punctuation">}</span></span><span class="token string">]"</span></span>
            members<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>spelling<span class="token punctuation">,</span> member_type<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> members


<span class="token keyword">def</span> <span class="token function">generate_rttr_code</span><span class="token punctuation">(</span>structs_map<span class="token punctuation">)</span><span class="token punctuation">:</span>
    code <span class="token operator">=</span> <span class="token string">"RTTR_REGISTRATION\n{\n"</span>
    <span class="token keyword">for</span> struct_name<span class="token punctuation">,</span> members <span class="token keyword">in</span> structs_map<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        code <span class="token operator">+=</span> <span class="token string-interpolation"><span class="token string">f"    registration::class_&lt;</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>struct_name<span class="token punctuation">}</span></span><span class="token string">&gt;(\"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>struct_name<span class="token punctuation">}</span></span><span class="token string">\")\n"</span></span>
        <span class="token keyword">for</span> member_name<span class="token punctuation">,</span> _ <span class="token keyword">in</span> members<span class="token punctuation">:</span>
            code <span class="token operator">+=</span> <span class="token string-interpolation"><span class="token string">f"    .property(\"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>member_name<span class="token punctuation">}</span></span><span class="token string">\", &amp;</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>struct_name<span class="token punctuation">}</span></span><span class="token string">::</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>member_name<span class="token punctuation">}</span></span><span class="token string">)(policy::prop::as_reference_wrapper)\n"</span></span>
        code <span class="token operator">+=</span> <span class="token string">"    ;\n\n"</span>
    code <span class="token operator">+=</span> <span class="token string">"}"</span>
    <span class="token keyword">return</span> code


<span class="token keyword">def</span> <span class="token function">analyze_header</span><span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    index <span class="token operator">=</span> clang<span class="token punctuation">.</span>cindex<span class="token punctuation">.</span>Index<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># Windows特定参数</span>
    args <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token string">'-std=c++11'</span><span class="token punctuation">,</span>
        <span class="token string">'-x'</span><span class="token punctuation">,</span> <span class="token string">'c++'</span><span class="token punctuation">,</span>  <span class="token comment"># 强制按C++模式解析</span>
        <span class="token comment"># r'-IC:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include',  # MSVC头文件路径</span>
        <span class="token comment"># r'-IC:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt',  # Windows SDK路径,</span>
        <span class="token string">r'-IC:\Program Files\CODESYS 3.5.19.60\CODESYS\CODESYS Control SL Extension Package\4.10.0.0\ExtensionSDK\include'</span><span class="token punctuation">,</span>
        <span class="token string">r'-ID:\Qt5.15\5.15.2\msvc2019_64\include\QtCore'</span>
    <span class="token punctuation">]</span>
    tu <span class="token operator">=</span> index<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>file_path<span class="token punctuation">,</span> args<span class="token operator">=</span>args<span class="token punctuation">)</span>

    structs <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">def</span> <span class="token function">visit_node</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> cursor<span class="token punctuation">.</span>kind <span class="token operator">==</span> CursorKind<span class="token punctuation">.</span>STRUCT_DECL <span class="token keyword">and</span> cursor<span class="token punctuation">.</span>is_definition<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            struct_name <span class="token operator">=</span> cursor<span class="token punctuation">.</span>spelling
            <span class="token keyword">if</span> struct_name <span class="token keyword">and</span> <span class="token keyword">not</span> struct_name<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 忽略匿名结构体</span>
                structs<span class="token punctuation">[</span>struct_name<span class="token punctuation">]</span> <span class="token operator">=</span> get_struct_members<span class="token punctuation">(</span>cursor<span class="token punctuation">)</span>
        <span class="token keyword">for</span> child <span class="token keyword">in</span> cursor<span class="token punctuation">.</span>get_children<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            visit_node<span class="token punctuation">(</span>child<span class="token punctuation">)</span>

    visit_node<span class="token punctuation">(</span>tu<span class="token punctuation">.</span>cursor<span class="token punctuation">)</span>
    <span class="token keyword">return</span> generate_rttr_code<span class="token punctuation">(</span>structs<span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token comment"># print(analyze_header("MyStruct.h"))</span>
    <span class="token comment"># print(analyze_header("E:\zhongyong\zyQt\Robot\CommunicationTest\communication\sharedMemory\memorydefine.h"))</span>

    fileContent <span class="token operator">=</span> <span class="token triple-quoted-string string">"""#include "memorydefine.h"
    
#include &lt;rttr/registration&gt;
#include &lt;rttr/type&gt;
#include &lt;vector&gt;

using namespace rttr; 
"""</span>
    fileContent <span class="token operator">+=</span> analyze_header<span class="token punctuation">(</span>srcFilePath<span class="token punctuation">)</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>dstFilePath<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span>

</code></pre>
    <p>
     处理完之后，我们就得到了RTTR注册的代码
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/5075e46f49034d8eac1330e0ab5ceed8.png">
      这个处理后生成的代码，就保存成cpp文件。只要将前面生成的h文件一起加到我们自己的工程，我们就可以对PLC放在共享内存上的结构体全知全晓了。
     </img>
    </p>
    <h2>
     <a id="4PLC_289">
     </a>
     4.读取PLC变量值
    </h2>
    <p>
     读取变量直接将结构体指针指向约定好的那一块共享内存，然后读即可。
     <br/>
     可以选择直接用变量名读，也可以通过RTTR的字符串属性来读，选择你喜欢的方式就好。
    </p>
    <h2>
     <a id="5PLC_293">
     </a>
     5.更改PLC变量值
    </h2>
    <p>
     这个稍微复杂一些。
     <br/>
     首先，在我们已经在
     <a href="https://blog.csdn.net/joyopirate/article/details/146253498">
      【基于RTTR在C++中实现结构体数据的多层级动态读写】
     </a>
     中实现了获取某个子成员地址相对于主数据的地址的偏移，而经过测试、CodeSys上的数据结构及结构体的对齐策略是与Qt这边是一致的。
     <br/>
     因此，我们完全可以将要写的变量的值+类型+地址的偏移发送给PLC，PLC收到之后，按照偏移来对变量赋值
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/989d3e64a8414868901f70299e3be774.png"/>
     要实现这个功能，得灵活使用结构体、指针和共用体。
     <br/>
     更加具体的代码就不详述了。
    </p>
    <hr/>
    <p>
     参考：
     <br/>
     <a href="https://blog.csdn.net/joyopirate/article/details/146253498">
      【基于RTTR在C++中实现结构体数据的多层级动态读写】
     </a>
     <br/>
     <a href="https://blog.csdn.net/m0_37846617/article/details/106237740">
      【共享内存 - C#与CoDeSys通讯】
     </a>
     <br/>
     <a href="https://zhuanlan.zhihu.com/p/663843824" rel="nofollow">
      【clang 在 Windows 下的安装教学】
     </a>
     <br/>
     <a href="https://blog.csdn.net/u013186651/article/details/135324625">
      【CodeSys平台ST语言编程】
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f6a6f796f7069726174652f:61727469636c652f64657461696c732f313436323736373931" class_="artid" style="display:none">
 </p>
</div>


