---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34353735323534312f:61727469636c652f64657461696c732f313436303633393537"
layout: post
title: "三维重建Proc-GS使用3DGS的程序性城市建筑生成"
date: 2025-03-11 11:25:07 +08:00
description: "Proc-GS建模是第一个能够使用3DGS实现过程建模的管道。Proc-GS框架包括两个阶段： (1) 资产获取阶段 ，指导3DGS遵循预定义的布局来约束它的优化。例如，当使用3DGS建模时，首先生成它的过程代码，或者手动或使用现成的分割模型。此代码用于为建筑的每个基本资产初始化一组高斯分布。然后根据程序代码对这些特定资产的高斯进行组装，并使用渲染损失对组装的高斯进行整体进行优化，如图3。重复的基本资产将同步更新；为了捕捉几何中各种细微变化，我们还学习了每个资产的方差代码。(2) 资产组装阶段 ，我们使"
keywords: "【三维重建】Proc-GS：使用3DGS的程序性城市建筑生成"
categories: ['未分类']
tags: ['高斯泼溅', '视觉大模型', '城市生成', '三维重建', 'Nerf', 'Aigc', '3D']
artid: "146063957"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146063957
    alt: "三维重建Proc-GS使用3DGS的程序性城市建筑生成"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146063957
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146063957
cover: https://bing.ee123.net/img/rand?artid=146063957
image: https://bing.ee123.net/img/rand?artid=146063957
img: https://bing.ee123.net/img/rand?artid=146063957
---

# 【三维重建】Proc-GS：使用3DGS的程序性城市建筑生成

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1326b28c7407493fbc30de6ddc333b29.gif#pic_center)

---

`标题：《Proc-GS: Procedural Building Generation for City Assembly with 3D Gaussians》`
  
`项目：https://city-super.github.io/procgs/`
  
`来源：香港中文大学；上海人工智能实验室 等`

---

## 摘要

**建筑是城市的主要组成部分，通常以门窗等重复的元素为特色**
。

**传统建模**
（又叫过程化三维资产构建）本质是通过脚本对资产的组合进行建模，而且创建是劳动密集型的，需要专门的技能来开发设计规则，生成的建筑物模型不够真实。过程化建模相关的软件有很多，例如：

* 地形生成：World Machine
* 城市生成：CityEngine、SceneCity
* 植物生成：SpeedTree、Terragen
* 材质生成：Substance
* 特效生成：Houdini
* 体素生成：VoxelFarm
* Blender发布的Geometry Node

效果如下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/192b53b5cb17487d832d884bc220e1a0.png)

* 测绘/GIS行业：CityEngine （现属于ESRI），根据矢量数据（如建筑物底面和道路中心线）快速生成城市三维模型：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3674cb5f342e464e927bef6254f938cd.png)

**高斯泼溅（Gaussian Splatting）建模**
是一种基于点云的渲染技术，通过高斯分布模拟光散射，适合实时渲染和大规模场景，并具有真实的场景还原精度，但不生成传统意义上的三维模型(mesh格式)。且模型难以编辑

**Proc-GS建模**
是第一个能够使用3DGS实现过程建模的管道。

Proc-GS框架包括两个阶段： (1)
**资产获取阶段**
，指导3DGS遵循预定义的布局来约束它的优化。例如，当使用3DGS建模时，首先生成它的过程代码，或者手动或使用现成的分割模型。
**此代码用于为建筑的每个基本资产初始化一组高斯分布。然后根据程序代码对这些特定资产的高斯进行组装，并使用渲染损失对组装的高斯进行整体进行优化**
，如图3。重复的基本资产将同步更新；为了捕捉几何中各种细微变化，我们还学习了每个资产的方差代码。(2)
**资产组装阶段**
，我们使用程序代码来操作基础资产，生成具有不同几何结构和逼真外观的建筑。新创建的架构可以与Houdini软件集成，允许可伸缩的场景组合与直观的控制。

**通过利用shared foundational assets, 显著减少了模型的大小，实现了对建筑组装的精确控制**
。为了展示Proc-GS的能力， 从City Sample中创建了
**MatrixBuilding数据集，包含了17个标志性建筑的多视图图像和程序代码**
。我们的Proc-GS方法通过组合来自不同建筑的资产，实现了灵活的几何编辑和创建新的结构，允许用户生成巨大的、定制的虚拟城市。我们还将Proc-GS迁移到现实世界的建筑中，并支持从实际结构转换为虚拟资产，支持可扩展的、逼真的城市生成，有利于游戏、自动驾驶和具体化的人工智能等。

## 一、 程序代码定义 (Procedural Code Definition)

程序建模被广泛用于游戏场景中的构建生成，如UE5 中的城市样本，通过利用建筑的结构化性质和重复性资产。建筑被分层分解为不同

l
e
v
e
l
level





l

e

v

e

l
，相同的

l
e
v
e
l
level





l

e

v

e

l
可能会重复，如图2中的

l
e
v
e
l
2
、
3
和
5
level 2、3和5





l

e

v

e

l

2

、

3

和

5
。每个

l
e
v
e
l
level





l

e

v

e

l
都由基本资产组成，如window、corner和piller，其中都有相同的资产在level中重复出现，如

l
e
v
e
l
1
level1





l

e

v

e

l

1
中的CE和W1。因此
，建筑可以由
**程序代码字符串**
(procedural code string)和
**一组基本资产**
来表示，其中基本资产是由艺术家手工制作。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b48d711e7bd94702b1ed2ab3b719fe62.png)

本文提出了一种从多视图图像中提取基础资产的替代方法。为了简化问题，我们首先假设提供了GroudTruth的程序代码。我们创建了基于CitySample中的17栋建筑的矩阵建筑数据集，人工制作的模拟来自纽约、芝加哥和旧金山等城市的建筑风格。
**每个场景包括密集的多视图图像，GroudTruth的像机位姿，和GroudTruth的程序代码**
。框架可以在合成世界上运行，并且对于现实世界的场景也很实用。我们发现了
**一种从真实场景中获得过程代码的有效方法**
：
**首先训练2D-GS [20]来获得几何上精确的点云和网格。随后使用
[CVPR 2022:Finding good configurations of planar primitives in unorganized point clouds]
方法自动估计建筑立面。对于每个面，渲染一个直接面向建筑立面的图像，并在二维图像上标注过程代码。然后将二维过程代码投影到网格上，得到三维过程代码**
。

## 二、资产获取 （Asset Acquisition）

我们的目标是在3D-GS 的训练过程中自动提取这些3D基础资产。为了实现这一点，我们
**假设程序代码是可用的，无论是来自MatrixBuilding数据集的GroudTruth代码，还是来自真实场景的估计代码**
。

每个
**基础资产的属性**
：

* 资产边界框的大小

  （
  x
  e
  ,
  y
  e
  ,
  z
  e
  ）
  （x\_e, y\_e, z\_e）





  （


  x









  e

  ​


  ,




  y









  e

  ​


  ,




  z









  e

  ​


  ）
  ；
* 局部坐标中的轴位置

  （
  x
  c
  ,
  y
  c
  ,
  z
  c
  ）
  （x\_c, y\_c, z\_c）





  （


  x









  c

  ​


  ,




  y









  c

  ​


  ,




  z









  c

  ​


  ）
  ；
* 世界坐标系中 ，

  K
  K





  K
  个实例的变换集合：{



  [
  R
  1
  ,
  T
  1
  ,
  S
  1
  ]
  、
  [
  R
  2
  ,
  T
  2
  ,
  S
  2
  ]
  ,
  .
  .
  .
  ,
  [
  R
  K
  ,
  T
  K
  ,
  S
  K
  ]
  [R\_1,T\_1,S\_1]、[R\_2,T\_2,S\_2],...,[R\_K,T\_K,S\_K]





  [


  R









  1

  ​


  ,




  T









  1

  ​


  ,




  S









  1

  ​


  ]

  、

  [


  R









  2

  ​


  ,




  T









  2

  ​


  ,




  S









  2

  ​


  ]

  ,



  ...

  ,



  [


  R









  K

  ​


  ,




  T









  K

  ​


  ,




  S









  K

  ​


  ]
  }，其中

  T
  ∈
  R
  3
  ×
  1
  T∈R^{3×1}





  T



  ∈






  R










  3

  ×

  1
  为平移向量，

  R
  ∈
  R
  3
  ×
  3
  R∈R^{3×3}





  R



  ∈






  R










  3

  ×

  3
  为旋转矩阵，

  S
  ∈
  R
  3
  ×
  1
  S∈R^{3×1}





  S



  ∈






  R










  3

  ×

  1
  是比例因子。

**高斯初始化**
。在世界坐标系的原点处，初始化每个基础资产的枢轴，（枢轴是资产自己的局部坐标系的原点）：第

i
i





i
个基本资产的边界框表示为

（
x
m
i
n
i
,
y
m
i
n
i
,
z
m
i
n
i
,
x
m
a
x
i
,
y
m
a
x
i
,
z
m
a
x
i
）
（x^i \_{min}, y\_{min}^i, z\_{min}^i, x^i\_{max}, y\_{max}^i, z\_{max}^i）





（


x










min





i

​


,




y










min





i

​


,




z










min





i

​


,




x










ma

x





i

​


,




y










ma

x





i

​


,




z










ma

x





i

​


）
, 其中

x
m
i
n
i
=
x
c
i
−
x
e
i
2
x^i \_{min} = x^i \_c−\frac {x^i \_e}{2}






x










min





i

​




=






x









c





i

​




−

















2













x









e





i

​


​

，

x
m
a
x
i
=
x
c
i
+
x
e
i
2
x^i \_{max} = x^i \_c+\frac {x^i \_e}{2}






x










ma

x





i

​




=






x









c





i

​




+

















2













x









e





i

​


​

。合成场景和真实世界场景的操作有细微的差别。

合成场景中，每个由M个基本资产组成的建筑，初始化

N
N





N
个点。对于第

i
i





i
项资产，

N
i
N^i






N









i
点在其边界框内随机初始化，
**由资产的边界框体积与所有资产的总体积的比值决定**
，如公式4:

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/55b125ebe9364c51858c902a4b8859a6.png)

**方差资产**
：不同场景的基本资产实例化，在外观和几何形状上都会有微小的差异，
**因此我们为第

i
i





i
个基础资产的每个实例化初始化一个方差资产**
。对于第j个实例化，我们首先在第i个基资产的边界框内随机初始化

N
i
N^i






N









i
点。然后，我们更新了该方差资产中三维高斯分布的中心

µ
µ





µ
、旋转

R
R





R
和尺度

S
S





S
，如公式5。

对于真实场景，给定具有

K
K





K
个实例的第

i
i





i
个基本资产，我们应用变换映射其边界框，获得所有K个实例的边界框。对于每个实例化，我们过滤其边界框内的SfM点，以进行方差初始化。然后使用第i个基本资产的逆转换将这些点云转换回世界坐标原点并连接起来。最后，我们将生成的点云均匀降采样K因子，以初始化第i个基本资产。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5df1a57d675242c3a68552d7512c0b01.png)

**用程序代码渲染**
。图3(1)说明了渲染方式。首先根据程序代码组装基本资产。第

i
i





i
个基本资产具有一组三维高斯

A
i
A\_i






A









i

​

和变换{



[
R
1
i
,
T
1
i
,
S
1
i
]
,
[
R
2
i
,
T
2
i
,
S
2
i
]
,
…
,
[
R
j
i
,
T
j
i
,
S
j
i
]
,
.
.
.
,
[
R
K
i
,
T
K
i
,
S
K
i
]
[R\_1^i,T\_1^i,S\_1^i ],[R\_2^i,T\_2^i,S\_2^i ],…,[R\_j^i,T\_j^i,S\_j^i ],...,[R\_K^i,T\_K^i,S\_K^i ]





[


R









1





i

​


,




T









1





i

​


,




S









1





i

​


]

,



[


R









2





i

​


,




T









2





i

​


,




S









2





i

​


]

,



…



,



[


R









j





i

​


,




T









j





i

​


,




S









j





i

​


]

,



...

,



[


R









K





i

​


,




T









K





i

​


,




S









K





i

​


]
}。
**对于第

i
i





i
个基本资产的第

j
j





j
个实例高斯，除中心

µ
µ





µ
、旋转

R
R





R
和刻度

S
S





S
外，三维高斯性质保持不变，其更新为**
：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/80e03b52fdac418bbab5354bfc5c3167.png)

根据程序代码实例化所有的基础资产，并添加方差资产。然后，整个建筑的三维高斯分布被输入光栅化器来渲染图像，由训练视图监督。优化过程中，来自重复实例的梯度被反向传播到共享的基础资产和各自的方差资产，从而细化高斯参数。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e7718989de324ddca9bc6493fe813f8b.png)

**高斯的Bbox自适应控制**
。3DGS的内部排序可能是混乱的，虽然有好的渲染结果，但基本资产的边界会出现无序，使后续的编辑和生成变得复杂（图6）。为了解决这个问题，我们除了致密化和修剪外，还使用
**Adaptive Clamp operation involves 操作**
来增强原始3DGS（图4）。对于每个基本资产，操作包括：
**(1)Clamp Scale**
：使用稍大一点的“软”边界框，以避免过度clamping。如果一个高斯超过了软盒的边界，它的尺度就会减半。
**(2)Clamp Position**
：将超过边界框的高斯的中心拉回其边缘。基础资产和方差资产每100次迭代执行一次，以保持有序的边界并促进有效的提取和操作。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4852ad5225b54447872582ce56f6c4b3.png)

## 三、资产组装（Asset Assembly）

从多视图图像中提取基本资产后，我们可以操作过程代码来生成新的建筑。组装过程由一个 building generator 和一个city layout generator组成。

**建筑生成器**
。为了进行建筑生成，我们首先分析了原始建筑中每层内和楼层之间的基础资产的排列模式，并
**通过GPT-4o 将它们转换为常规的程序代码，并在提示中提供了几个示例**
。实例过程见图10。在常规程序代码中，指定了楼层内部和楼层之间可重复和可伸缩的组合。具体地说，（）中的组合被设计为可重复的元素，而标记有∗的资产则可扩展，以适应建筑的大小。随后，我们可以根据程序代码和指定的建筑尺寸（例如，长度、宽度和高度）来放置资产，以生成具有不同安排和尺寸的新建筑。值得注意的是，在构建生成过程中，每个基本资产都被随机分配了一个相应的方差资产，以增强多样性和真实性。此外，我们还可以从不同建筑来源提取的基础资产中创建新建筑。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d8bee06bc353435fb16055400f42ac84.png)

**城市布局生成器**
。对于城市生成，用户首先选择城市地图的边界点（紫色边界）和主要道路的端点（绿线），如图3 (2)所示。随后，我们根据主要道路将城市划分为几个相互连接的街区，每个街区被随机分配给区域特征（如建筑规模的分布）。然后，我们生成垂直的二级道路，并根据预定义的规则确定建筑位置、拓扑结构和尺寸。最后，我们在道路上随机放置装饰元素，如路灯、垃圾桶和邮箱，这些也由3D-GS收集。

## 四、实验

**数据集**
。CitySample[1]的建筑数据集，包括17栋建筑的密集多视图图像及其相应的GroundTruth程序代码。按照MatrixCity 禁用运动模糊，并在渲染过程中使用了抗锯齿，以实现尽可能高的图像质量。
附录a提供了每个建筑的细节和摄像机捕捉轨迹。我们还在无人机捕获的三个真实场景上做了方法验证。

**细节**
。3D-GS是我们的主要基线，都经过30k的迭代训练，稠密化到15k；合成数据初始化的高斯数

N
=
10
k
N=10k





N



=





10

k
，如公式4。3DGS初始化与由随机初始化的基本资产组装的建筑。
**软边界框超出边界框20厘米**
；

λ
S
S
I
M
λ\_{SSIM}






λ










SS

I

M

​

=0.2;在单个RTX 3090 GPU上训练。

**指标**
。新视图合成采用：
**PSNR，SSIM [43]和LPIPS**
；还报告了
**高斯模型的数量**
来评估模型的紧致性。这些指标在所有场景中取平均值，以进行定量比较。对于城市生成，按照EG3D [6]和CityDreamer的
**深度误差（DE）和相机误差（CE），以评估3D场景的几何形状和一致性**
。对于DE，我们利用预先训练的模型[36]来估计渲染图像的深度图，并计算归一化估计深度和渲染深度之间的 ℓ2距离。对于CE，我们首先使用半球采样的相机位姿渲染图像，然后使用COLMAP [37]估计这些位姿。摄像机误差计算为估计值和的真实pose之间的尺度不变 ℓ2损失。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5fd4417628fc4d9e888bc53f29e3929d.png)

> --------------------------------------------------------------------------------------------真实数据结果--------------------------------------------------------------------------------------

**对于合成数据，Proc-GS实现了较好的新视图合成质量，同时显著减少模型大小的4倍**
，证明了我们的方法的有效性。
**对于真实世界的场景**
，由于其复杂的外观、几何形状和缺乏地面真实的程序代码，优化变得更具挑战性，需要更多的高斯分布的方差资产。虽然压缩率低于合成情况，但与3D-GS相比，我们的模型仍然保持着更小的尺寸。更重要的是，我们获得了灵活的控制能力，而精度仅略有下降，这在定性结果中几乎不明显（图5）

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cf63779a73a74d9eb81eec00995c3134.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f26c4cc09434442ca7b012bb13a76e50.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a70a375ee1ee4c70b5a9e355e5613d29.png)
  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6727c014186a4d81a1cd663f41c9e817.gif#pic_center)