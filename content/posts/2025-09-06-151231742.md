---
layout: post
title: "MySQL-高级篇-分片规则与管理监控"
date: 2025-09-06T14:49:44+0800
description: "本文详细介绍 MyCat 的 9 种分片规则（范围、取模等，含配置与适用场景），还阐述 MyCat 原理、管理端口与常用命令，以及 MyCat-eye 的安装、访问、配置和监控功能，助力高效管理分布式数据库。"
keywords: "【MySQL | 高级篇 分片规则与管理监控】"
categories: ['Mysql']
tags: ['分片规则', 'Spring', 'Mysql', 'Mycat', 'Java', 'Idea', 'Ee']
artid: "151231742"
arturl: "https://blog.csdn.net/chan12345678910/article/details/151231742"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151231742
    alt: "MySQL-高级篇-分片规则与管理监控"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151231742
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151231742
cover: https://bing.ee123.net/img/rand?artid=151231742
image: https://bing.ee123.net/img/rand?artid=151231742
img: https://bing.ee123.net/img/rand?artid=151231742
---



# 【MySQL | 高级篇 分片规则与管理监控】



**摘要：**本文详细介绍 **MyCat 的 9 种分片规则**（范围、取模等，含配置与适用场景），还阐述 **MyCat 原理、管理端口与常用命令**，以及 **MyCat-eye** 的安装、访问、配置和**监控功能**，助力高效管理分布式数据库。

![](https://i-blog.csdnimg.cn/direct/602c06ee696a4ce6ba0f5622c5434729.png)

![](https://i-blog.csdnimg.cn/direct/a07603b9431449bc84f093ad764cddfe.gif)

**思维导图**

![](https://i-blog.csdnimg.cn/direct/d434cadb436a4d2a9cf4daafa07934cf.png)

## 1. 分片规则

### 1.1 范围分片

**1). 介绍**

根据指定的字段及其**配置的范围**与**数据节点的对应情况**，来决定该数据属于哪一个分片。

![](https://i-blog.csdnimg.cn/direct/a93a220d68164367900eb39ae53f880d.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/e0e1c9367a5e48ed8f1e04af89078f5a.png)

**rule.xml分片规则配置：**

```

<tableRule name="auto-sharding-long">
 <rule>
 <columns>id</columns>
 <algorithm>rang-long</algorithm>
 </rule>
</tableRule>
<function name="rang-long" class="io.mycat.route.function.AutoPartitionByLong">
 <property name="mapFile">autopartition-long.txt</property>
 <property name="defaultNode">0</property>
</function>
```

**分片规则配置属性含义：**

![](https://i-blog.csdnimg.cn/direct/2878e2e149954a32a80afac3ebfb5ace.png)

在rule.xml中配置分片规则时，关联了一个映射配置文件 autopartition-long.txt，该配置文 件的配置如下：

```

# range start-end ,data node index
# K=1000,M=10000.
0-500M=0
500M-1000M=1
1000M-1500M=2

```

**autopartition-long.txt 含义：**

0-500 万之间的值，存储在 0 号数据节点 (数据节点的索引从 0 开始)；500 万 - 1000 万之间的数据存储在 1 号数据节点；1000 万 - 1500 万的数据节点存储在 2 号节点；

该分片规则，主要是针对于**数字类型的字段适用**。

### 1.2 取模分片

**1). 介绍**

根据指定的字段值与节点数量进行求模运算，根据运算结果，来决定该数据属于哪一个分片。

**![](https://i-blog.csdnimg.cn/direct/320a7f84105146e9b01e2592ae4bf5a2.png)**

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/77dca3b3f21f463f9d65d34d58cb31a2.png)

**rule.xml分片规则配置：**

```

<tableRule name="mod-long">
 <rule>
 <columns>id</columns>
 <algorithm>mod-long</algorithm>
 </rule>
</tableRule>
<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
 <property name="count">3</property>
</function>

```

分片规则属性说明如下：

| 属性 | 描述 |
| --- | --- |
| **columns** | 标识将要分片的表字段 |
| **algorithm** | 指定分片函数与 function 的对应关系 |
| **class** | 指定该分片算法对应的类 |
| **count** | 数据节点的数量 |

该分片规则，主要是针对于**数字类型的字段**适用。

### 1.3 一致性 hash 分片

**1). 介绍**

所谓一致性哈希，**相同的哈希因子计算值**总是被划分到**相同的分区表中**，不会因为分区节点的增加而改变原来数据的分区位置，有效的解决了分布式数据的拓容问题。

![](https://i-blog.csdnimg.cn/direct/c58a40fa3a9c468980ee1e923c1a37c2.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/e2065763c6b543309ea7021615b739be.png)

**rule.xml分片规则配置：**

```

<tableRule name="mod-long">
 <rule>
 <columns>id</columns>
 <algorithm>mod-long</algorithm>
 </rule>
</tableRule>
<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
 <property name="count">3</property>
</function>

```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| seed | 创建 murmur_hash 对象的种子，默认 0 |
| count | 要分片的数据库节点数量，必须指定，否则没法分片 |
| virtualBucketTimes | 一个实际的数据库节点被映射为这么多虚拟节点，默认是 160 倍，也就是虚拟节点数是物理节点数的 160 倍；virtualBucketTimes*count 就是虚拟结点数量； |
| weightMapFile | 节点的权重，没有指定权重的节点默认是 1。以 properties 文件的格式填写，以从 0 开始到 count-1 的整数值也就是节点索引为 key，以节点权重值为值。所有权重值必须是正整数，否则以 1 代替 |
| bucketMapPath | 用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的 murmur hash 值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 |

### 1.4 枚举分片

**1). 介绍**

通过**在配置文件中配置可能的枚举值**，指定数据分布到不同数据节点上，本规则适用于**按照省份、性别、状态拆分数据**等业务 。

![](https://i-blog.csdnimg.cn/direct/8842de65451441e5876bd37c1ac4cb46.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/38238ff675824d42a61d3aaa4c20166f.png)

**rule.xml分片规则配置：**

```

<tableRule name="sharding-by-intfile">
 <rule>
 <columns>sharding_id</columns>
 <algorithm>hash-int</algorithm>
 </rule>
</tableRule>
<!-- 自己增加 tableRule -->
<tableRule name="sharding-by-intfile-enumstatus">
 <rule>
 <columns>status</columns>
 <algorithm>hash-int</algorithm>
 </rule>
</tableRule>
<function name="hash-int" class="io.mycat.route.function.PartitionByFileMap">
 <property name="defaultNode">2</property>
 <property name="mapFile">partition-hash-int.txt</property>
</function>

```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| mapFile | 对应的外部配置文件 |
| type | 默认值为 0；0 表示 Integer，1 表示 String |
| defaultNode | 默认节点；小于 0 标识不设置默认节点，大于等于 0 代表设置默认节点；默认节点的作用：枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点；如果没有默认值，碰到不识别的则报错 。 |

### 1.5 应用指定算法

**1). 介绍**

运行阶段由应用自主决定路由到那个分片，直接根据**字符子串** **(必须是数字)** 计算分片号。

![](https://i-blog.csdnimg.cn/direct/f82004eae2c84c9eb952699f83bedbed.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/b633baddda9d48618deba9d7a2d40e5f.png)

**rule.xml分片规则配置：**

```

<tableRule name="sharding-by-substring">
 <rule>
 <columns>id</columns>
 <algorithm>sharding-by-substring</algorithm>
 </rule>
</tableRule>
<function name="sharding-by-substring" 
class="io.mycat.route.function.PartitionDirectBySubString">
 <property name="startIndex">0</property> <!-- zero-based -->
 <property name="size">2</property>
 <property name="partitionCount">3</property>
 <property name="defaultPartition">0</property>
</function>
```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| startIndex | 字符子串起始索引 |
| size | 字符长度 |
| partitionCount | 分区 (分片) 数量 |
| defaultPartition | 默认分片 (在分片数量定义时，字符标示的分片编号不在分片数量内时，使用默认分片) |

**示例说明：**

id=05-100000002，在此配置中代表根据 id 中**从 startIndex=0 开始，截取 size=2 位数字**即 05，05 就是获取的分区，**如果没找到对应的分片则默认分配到 defaultPartition** 。

### **1.6 固定分片 hash 算法**

**1). 介绍**

该算法类似于十进制的**求模**运算，但是为**二进制的操作**

![](https://i-blog.csdnimg.cn/direct/3060381cd3b84a61a6a5d83ea60ffaa9.png)

> * 分片字段必须为数字类型。
> * 可以均匀分配，也可以非均匀分配。
> * 如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/2a299ca497214f409ea43946c7bbfc67.png)

**rule.xml分片规则配置：**

```

<tableRule name="sharding-by-long-hash">
 <rule>
 <columns>id</columns>
 <algorithm>sharding-by-long-hash</algorithm>
 </rule>
</tableRule>
<!-- 分片总长度为1024，count与length数组长度必须一致； -->
<function name="sharding-by-long-hash" 
class="io.mycat.route.function.PartitionByLong">
 <property name="partitionCount">2,1</property>
 <property name="partitionLength">256,512</property>
</function>

```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段名 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| partitionCount | 分片个数列表 |
| partitionLength | 分片范围列表 |

### 1.7 字符串 hash 解析算法

**1). 介绍**

截取字符串中的**指定位置的子字符串**，**进行 hash 算法**，算出分片。

![](https://i-blog.csdnimg.cn/direct/7c0804ebddb2480186bd6b7f11e78193.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/608fd56f078949cd8402c499d406addc.png)

**rule.xml分片规则配置：**

```

<tableRule name="sharding-by-stringhash">
 <rule>
 <columns>name</columns>
 <algorithm>sharding-by-stringhash</algorithm>
 </rule>
</tableRule>
<function name="sharding-by-stringhash" 
class="io.mycat.route.function.PartitionByString">
 <property name="partitionLength">512</property> <!-- zero-based -->
 <property name="partitionCount">2</property>
 <property name="hashSlice">0:2</property>
</function>

```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| partitionLength | hash 求模基数；length*count=1024 (出于性能考虑) |
| partitionCount | 分区数 |
| hashSlice | hash 运算位，根据子字符串的 hash 运算；0 代表 str.length ()，-1 代表 str.length ()-1，大于 0 只代表数字自身；可以理解为 substring ( start , end )，start 为 0 则只表示 0 |

### 1.8 按天分片算法

**1). 介绍**

按照**日期及对应的时间周期**来分片。

![](https://i-blog.csdnimg.cn/direct/427c31a11ca3444b903d102ba0716078.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/1a95c723420042ba9504a4700ea46c49.png)

**rule.xml分片规则配置：**

```

<tableRule name="sharding-by-date">
 <rule>
 <columns>create_time</columns>
 <algorithm>sharding-by-date</algorithm>
 </rule>
</tableRule>
<function name="sharding-by-date" 
class="io.mycat.route.function.PartitionByDate">
 <property name="dateFormat">yyyy-MM-dd</property>
 <property name="sBeginDate">2022-01-01</property>
 <property name="sEndDate">2022-01-30</property>
 <property name="sPartionDay">10</property>
</function>
<!--
 从开始时间开始，每10天为一个分片，到达结束时间之后，会重复开始分片插入
 配置表的 dataNode 的分片，必须和分片规则数量一致，例如 2022-01-01 到 2022-12-31 ，每
10天一个分片，一共需要37个分片。
 -->

```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| dateFormat | 日期格式 |
| sBeginDate | 开始日期 |
| sEndDate | 结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入 |
| sPartionDay | 分区天数，默认值 10，从开始日期算起，每个 10 天一个分区 |

### 1.9 自然月分片

**1). 介绍**

使用场景为按照月份来分片, **每个自然月**为一个分片。

![](https://i-blog.csdnimg.cn/direct/e8ed6efe62da40b7bbd36a9cc987bd94.png)

**2). 配置**

![](https://i-blog.csdnimg.cn/direct/d7989c45e1dd4745a2b96260ee3ddd22.png)

**rule.xml分片规则配置：**

```

<tableRule name="sharding-by-month">
 <rule>
 <columns>create_time</columns>
 <algorithm>partbymonth</algorithm>
 </rule>
</tableRule>
 
<function name="partbymonth" class="io.mycat.route.function.PartitionByMonth">
 <property name="dateFormat">yyyy-MM-dd</property>
 <property name="sBeginDate">2022-01-01</property>
 <property name="sEndDate">2022-03-31</property>
</function>
<!-- 
 从开始时间开始，一个月为一个分片，到达结束时间之后，会重复开始分片插入
 配置表的 dataNode 的分片，必须和分片规则数量一致，例如 2022-01-01 到 2022-12-31 ，一
共需要12个分片。
-->

```

**分片规则属性含义：**

| 属性 | 描述 |
| --- | --- |
| columns | 标识将要分片的表字段 |
| algorithm | 指定分片函数与 function 的对应关系 |
| class | 指定该分片算法对应的类 |
| dateFormat | 日期格式 |
| sBeginDate | 开始日期 |
| sEndDate | 结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入 |

## 2 MyCat 管理及监控

### 2.1 MyCat 原理

### 

> 在 MyCat 中，当执行一条 SQL 语句时，MyCat 需要进行 SQL 解析、分片分析、路由分析、读写分离分析等操作，最终经过一系列的分析决定将当前的 SQL 语句到底路由到那几个（或哪个）节点数据库，数据库将数据执行完毕后，如果有返回的结果，则将结果返回给 MyCat，最终还需要在 MyCat 中进行结果合并、聚合处理、排序处理、分页处理等操作，最终再将结果返回客户端。
>
> 而在 MyCat 的使用过程中，MyCat 官方也提供了一个管理监控平台 MyCat-Web（MyCat-eye）。Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等，为优化 SQL 提供依据。

#### 

### 2.2 MyCat 管理

Mycat 默认开通 2 个端口，可以在 server.xml 中进行修改：

* **8066：数据访问端口**，即进行 DML 和 DDL 操作；
* **9066：数据库管理端口**，即 mycat 服务管理控制功能，用于管理 mycat 的整个集群状态。

#### 

**连接 MyCat 的管理控制台**

**执行如下指令连接：**

```

mysql -h 192.168.200.210 -p 9066 -uroot -p123456
```

**常用管理命令**

| 命令 | 含义 |
| --- | --- |
| show @@help | 查看 Mycat 管理工具帮助文档 |
| show @@version | 查看 Mycat 的版本 |
| reload @@config | 重新加载 Mycat 的配置文件 |
| show @@datasource | 查看 Mycat 的数据源信息 |
| show @@datanode | 查看 MyCat 现有的分片节点信息 |
| show @@threadpool | 查看 Mycat 的线程池信息 |
| show @@sql | 查看执行的 SQL |
| show @@sql.sum | 查看执行的 SQL 统计 |

#### 

### 2.3 MyCat-eye

#### 2.3.1 介绍

Mycat-web（Mycat-eye）是对 mycat-server 提供监控服务，功能不局限于对 mycat-server 使用。它通过 JDBC 连接对 Mycat、Mysql 监控，监控远程服务器（目前仅限于 linux 系统）的 cpu、内存、网络、磁盘。Mycat-eye 运行过程中需要依赖 zookeeper，因此需要先安装 zookeeper。

#### 

#### 2.3.2 安装

1. zookeeper 安装；

2. Mycat-eye 安装。

具体的安装步骤省略。

#### 

#### 2.3.3 访问

在浏览器中输入如下地址访问 Mycat-eye 管理界面：

```

http://192.168.200.210:8082/mycat
```

![](https://i-blog.csdnimg.cn/direct/c299d7a9321042de8f397b00df29932f.png)

#### 3.6.3.4 配置

**1. 开启MyCat的实时统计功能(server.xml)：**

```

<property name="useSqlStat">1</property> <!-- 1为开启实时统计、0为关闭 -->
```

**在 Mycat 监控界面配置服务地址**：

![](https://i-blog.csdnimg.cn/direct/e4d02069f36448a880ef01291914b08d.png)

#### 2.3.5 测试

配置好之后，通过 MyCat 执行一系列增删改查操作，等待一段时间后，打开 mycat-eye 的管理界面，可查看以下监控数据：

**1.性能监控**：包括 Mycat 流量分析、连接分析、活动线程分析、缓冲队列分析、TPS 分析等。

![](https://i-blog.csdnimg.cn/direct/130a4f4edb954017ad8aa8a2e95d71af.png)

**2.物理节点**：查看 Mycat 关联的各个数据库物理节点的状态信息，包括最后活动时间等。

![](https://i-blog.csdnimg.cn/direct/e49abd2925334948b8b912a6d8c1021e.png)

**3.SQL 统计**：统计指定时间段内Mycat 执行的 SQL 情况，包括 SQL 执行时间分布、读次数等。

![](https://i-blog.csdnimg.cn/direct/1f936ef99b3c4649b6f95ffb5d2f710b.png)

**4.SQL 表分析**：查看不同表（如 tb_app、tb_datepart、tb_longhash 等）的 SQL 操作情况。

![](https://i-blog.csdnimg.cn/direct/69f511ee93d6496ba6488f88c367b1e0.png)

**5.SQL 监控**：展示具体 SQL 语句的执行详情，包括 SQL 内容、耗时（ms）、执行时间等。

![](https://i-blog.csdnimg.cn/direct/cc5db933a99c4fc98ed4fefd5a151a05.png)

**6.高频 SQL**：统计指定时间段内执行频率较高的 SQL，包括 SQL 内容、平均耗时、最大耗时等。

![](https://i-blog.csdnimg.cn/direct/8a7bb5b85d524dda9fc886766e84bc31.png)

---

**大功告成！**



