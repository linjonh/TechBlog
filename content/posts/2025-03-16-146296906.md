---
layout: post
title: "RabbitMQ事务机制限流负载均衡"
date: 2025-03-16 16:33:19 +0800
description: "RabbitMQ可靠性：事务机制、限流、负载均衡"
keywords: "【RabbitMQ】事务机制、限流、负载均衡"
categories: ['Rabbitmq']
tags: ['限流', '负载均衡', '分布式', 'Rabbitmq']
artid: "146296906"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146296906
    alt: "RabbitMQ事务机制限流负载均衡"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146296906
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146296906
cover: https://bing.ee123.net/img/rand?artid=146296906
image: https://bing.ee123.net/img/rand?artid=146296906
img: https://bing.ee123.net/img/rand?artid=146296906
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【RabbitMQ】事务机制、限流、负载均衡
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h4 style="background-color:transparent">
     RabbitMQ的事务机制
    </h4>
    <p>
     RabbitMQ的事务机制用于确保消息在生产、传输和消费过程中的可靠性。通过事务机制，可以确保消息在出现异常时不会丢失或重复消费。
    </p>
    <h5 style="background-color:transparent">
     事务机制的操作
    </h5>
    <p>
     在RabbitMQ中，事务机制的操作包括以下三个步骤：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        开启事务
       </strong>
       ：
       <code>
        channel.txSelect()
       </code>
       <br/>
       开启事务模式，告知RabbitMQ接下来的操作需要事务控制。
      </p>
     </li>
     <li>
      <p>
       <strong>
        提交事务
       </strong>
       ：
       <code>
        channel.txCommit()
       </code>
       <br/>
       提交事务，确认所有消息成功发布或处理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        回滚事务
       </strong>
       ：
       <code>
        channel.txRollback()
       </code>
       <br/>
       发生异常时回滚事务，撤销所有未提交的操作。
      </p>
     </li>
    </ol>
    <hr/>
    <h4 style="background-color:transparent">
     事务机制的优缺点
    </h4>
    <p>
     <strong>
      优点：
     </strong>
    </p>
    <ul>
     <li>
      可靠性高，确保消息不会丢失。
     </li>
    </ul>
    <p>
     <strong>
      缺点：
     </strong>
    </p>
    <ul>
     <li>
      性能较低，每条消息都要等待事务提交或回滚，严重影响吞吐量。
     </li>
     <li>
      较少用于高并发场景，更多使用
      <strong>
       Confirm机制
      </strong>
      来替代事务机制。
     </li>
    </ul>
    <hr/>
    <h4 style="background-color:transparent">
     Spring Boot中使用RabbitMQ事务
    </h4>
    <h5 style="background-color:transparent">
     1. 引入依赖
    </h5>
    <p>
     在
     <code>
      pom.xml
     </code>
     中添加RabbitMQ依赖：
    </p>
    <pre><code class="hljs">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
    <p>
     2. 配置文件（application.yml）
    </p>
    <pre><code class="hljs">spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
</code></pre>
    <h5 style="background-color:transparent">
     3. 生产者代码
    </h5>
    <p>
     在生产者中使用事务控制：
    </p>
    <pre><code class="language-java">package com.example.rabbitmq.producer;

import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.core.RabbitTemplate.TransactionCallback;
import org.springframework.amqp.rabbit.transaction.RabbitTransactionManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.Transactional;

@Configuration
public class RabbitMQConfig {

    @Bean
    public RabbitTransactionManager rabbitTransactionManager(ConnectionFactory connectionFactory) {
        return new RabbitTransactionManager(connectionFactory);
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setChannelTransacted(true);  // 开启事务
        return template;
    }
}
</code></pre>
    <p>
     4. 生产消息
    </p>
    <pre><code class="language-java">package com.example.rabbitmq.producer;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MessageProducer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Transactional  // 事务注解
    public void sendMessage(String exchange, String routingKey, String message) {
        try {
            rabbitTemplate.convertAndSend(exchange, routingKey, message);
            System.out.println("消息发送成功：" + message);
        } catch (Exception e) {
            System.err.println("消息发送失败：" + e.getMessage());
            throw e;  // 触发事务回滚
        }
    }
}
</code></pre>
    <p>
     5. 消费者代码
    </p>
    <pre><code class="language-java">package com.example.rabbitmq.consumer;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class MessageConsumer {

    @Transactional  // 事务注解
    @RabbitListener(queues = "test-queue")
    public void receiveMessage(String message) {
        System.out.println("接收到消息：" + message);
        if ("error".equals(message)) {
            throw new RuntimeException("消费失败，触发事务回滚");
        }
    }
}
</code></pre>
    <h4>
     RabbitMQ的限流和负载均衡
    </h4>
    <p>
     在RabbitMQ中，
     <strong>
      限流
     </strong>
     和
     <strong>
      负载均衡
     </strong>
     是确保系统在高并发和大流量场景下稳定运行的关键机制。以下是这两个机制的详细介绍：
    </p>
    <hr/>
    <h5 style="background-color:transparent">
     一、限流（流量控制）
    </h5>
    <p>
     RabbitMQ中的限流机制通过**Qos（Quality of Service）**来实现。
     <br/>
     核心方法是：
    </p>
    <ul>
     <li>
      <strong>
       basicQos(int prefetchCount)
      </strong>
      ：用于限制消费者每次拉取的消息数量。
     </li>
     <li>
      <strong>
       prefetchCount
      </strong>
      ：
      <ul>
       <li>
        1：消费者一次只接收一条消息，处理完后才继续接收下一条。
       </li>
       <li>
        n：消费者可以同时处理n条消息。
       </li>
       <li>
        0：没有限制（默认）。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      作用
     </strong>
     ：
    </p>
    <ol>
     <li>
      防止消费者压力过大导致消息堆积。
     </li>
     <li>
      保证消费者逐条确认，避免消息丢失。
     </li>
    </ol>
    <hr/>
    <h5 style="background-color:transparent">
     二、负载均衡
    </h5>
    <p>
     RabbitMQ的负载均衡是通过
     <strong>
      轮询分发
     </strong>
     和
     <strong>
      公平分发
     </strong>
     来实现的：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        轮询分发（Round-Robin）
       </strong>
      </p>
      <ul>
       <li>
        默认模式。
       </li>
       <li>
        消息均匀地分配给每个消费者。
       </li>
       <li>
        缺点：无法考虑消费者的消费能力差异，导致性能不均衡。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        公平分发（Fair Dispatch）
       </strong>
      </p>
      <ul>
       <li>
        结合
        <strong>
         Qos
        </strong>
        机制实现。
       </li>
       <li>
        通过设置
        <code>
         prefetchCount=1
        </code>
        ，使消费者处理完消息后才继续获取下一条，保证消息不会被堆积在性能较差的消费者上。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     三、Spring Boot中实现限流和负载均衡
    </h4>
    <h4 style="background-color:transparent">
     配置文件方式（application.yml）
    </h4>
    <p>
     我们可以直接在配置文件中进行消费者并发数、预取数量（限流）等配置：
    </p>
    <h5 style="background-color:transparent">
     示例配置文件（application.yml）
    </h5>
    <pre><code class="language-java">spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    listener:
      simple:
        concurrency: 5            # 最小并发消费者数量
        max-concurrency: 10       # 最大并发消费者数量
        prefetch: 1               # 每个消费者每次只接收1条消息（限流）
        acknowledge-mode: manual  # 手动确认消息
</code></pre>
    <p>
     二、生产者代码
    </p>
    <pre><code class="language-java">package com.example.rabbitmq.producer;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MessageProducer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendMessage(String message) {
        rabbitTemplate.convertAndSend("test-queue", message);
        System.out.println("消息发送：" + message);
    }

    public void sendBatchMessages() {
        for (int i = 1; i &lt;= 20; i++) {
            sendMessage("Message " + i);
        }
    }
}
</code></pre>
    <p>
     三、消费者代码
    </p>
    <pre><code class="language-java">package com.example.rabbitmq.consumer;

import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

@Service
public class MessageConsumer {

    @RabbitListener(queues = "test-queue")
    public void receiveMessage(String message, Channel channel) throws Exception {
        try {
            System.out.println(Thread.currentThread().getName() + " 接收到消息：" + message);
            Thread.sleep(1000); // 模拟耗时操作
            channel.basicAck(channel.getNextPublishSeqNo(), false); // 手动确认
        } catch (Exception e) {
            channel.basicNack(channel.getNextPublishSeqNo(), false, true); // 失败重新入队
            System.err.println("消费失败：" + message);
        }
    }
}
</code></pre>
    <hr/>
    <h4 style="background-color:transparent">
     四、配置解读
    </h4>
    <p>
     在配置文件中，我们通过以下几个参数来控制限流和负载均衡：
    </p>
    <ol>
     <li>
      <strong>
       concurrency
      </strong>
      ：最小并发消费者数量。
     </li>
     <li>
      <strong>
       max-concurrency
      </strong>
      ：最大并发消费者数量，动态调整消费者数量。
     </li>
     <li>
      <strong>
       prefetch
      </strong>
      ：每次拉取的消息数量（限流）。
     </li>
     <li>
      <strong>
       acknowledge-mode
      </strong>
      ：手动确认消息消费成功，防止消息丢失。
     </li>
    </ol>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f796963616e323538302f:61727469636c652f64657461696c732f313436323936393036" class_="artid" style="display:none">
 </p>
</div>


