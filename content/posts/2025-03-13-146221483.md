---
layout: post
title: "软考数据结构四重奏软件工程师的线性树图矩阵算法精要"
date: 2025-03-13 08:46:33 +0800
description: "软件设计师考试的数据结构模块涵盖**数组、链表、栈、队列、树、图等基础结构及其操作，重点考察查找（二分）、排序（快排、归并）算法，以及树/图的遍历（DFS、BFS）。要求掌握算法复杂度分析**，理解哈希、堆等结构的应用场景，强调通过合理选择数据结构优化程序性能，解决实际工程中的存储管理与计算效率问题，为系统设计奠定核心逻辑基础。"
keywords: "软考数据结构四重奏：软件工程师的线性、树、图、矩阵算法精要"
categories: ['软件设计师']
tags: ['算法', '数据结构']
artid: "146221483"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146221483
    alt: "软考数据结构四重奏软件工程师的线性树图矩阵算法精要"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146221483
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146221483
cover: https://bing.ee123.net/img/rand?artid=146221483
image: https://bing.ee123.net/img/rand?artid=146221483
img: https://bing.ee123.net/img/rand?artid=146221483
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     软考数据结构四重奏：软件工程师的线性、树、图、矩阵算法精要
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     简介
    </p>
    <blockquote>
     <p>
      软件设计师考试的数据结构模块涵盖**数组、链表、栈、队列、树、图
      <strong>
       等基础结构及其操作，重点考察
      </strong>
      查找（二分）、排序（快排、归并）算法，以及树/图的遍历（DFS、BFS）
      <strong>
       。要求掌握算法
      </strong>
      复杂度分析**，理解
      <strong>
       哈希、堆
      </strong>
      等结构的应用场景，强调通过合理选择数据结构优化程序性能，解决实际工程中的存储管理与计算效率问题，为系统设计奠定核心逻辑基础。
     </p>
    </blockquote>
    <h2>
     <a id="Tn_5">
     </a>
     一、时间复杂度（Tn）
    </h2>
    <ol>
     <li>
      时间复杂度为算法中基本操作重复的次数（简称为频度），在计算时只要大致计算出相应的数量级就可以的。
      <ol>
       <li>
        例如：O(1),O(2^2)等
       </li>
      </ol>
     </li>
     <li>
      高阶项排序（低到高）：
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/222c56d441299be6ef38a6b95d493b96.png"/>
    </p>
    <ol start="3">
     <li>
      计算规则：
      <ol>
       <li>
        加法规则：多项相加，保留最高项，并将系数化为1
        <ol>
         <li>
          例
         </li>
         <li>
          T(n)=2n
          <sup>
           3+n
          </sup>
          2+1
          <ol>
           <li>
            结果等于n^3
           </li>
          </ol>
         </li>
        </ol>
       </li>
       <li>
        乘法规则，多项相乘都保留，并将系数化为1
        <ol>
         <li>
          例：
         </li>
         <li>
          T(n)=n
          <sup>
           3*n
          </sup>
          3
         </li>
         <li>
          T(n)=n^6
         </li>
        </ol>
       </li>
       <li>
        加法乘法混合规则：小括号先算再乘法后加法
        <ol>
         <li>
          例
         </li>
         <li>
          T(n)=(2+n
          <sup>
           3)*(3+n
          </sup>
          1)
         </li>
         <li>
          T(n)=n^4
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      例题：
     </li>
    </ol>
    <pre><code class="prism language-java">结果为：log2n
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// O(1)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   log2n <span class="token operator">+</span><span class="token number">2</span>
        i<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// log2n +1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

结果为 <span class="token class-name">O</span>（n）
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        a<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
<span class="token punctuation">}</span>
</code></pre>
    <h2>
     <a id="_48">
     </a>
     二、空间复杂度
    </h2>
    <ol>
     <li>
      看定义的空间
      <ol>
       <li>
        例：
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token comment">// 空间复杂度为：O(1)</span>

<span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 空间复杂度为：O(n)</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ins <span class="token operator">=</span> nwe <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

</code></pre>
    <ol>
     <li>
      注意：非递归空间复杂度一般只到
      <ol>
       <li>
        O(1)
       </li>
       <li>
        O(n)
       </li>
       <li>
        O(n^2)
       </li>
      </ol>
     </li>
    </ol>
    <h2>
     <a id="_67">
     </a>
     三、渐进符号
    </h2>
    <ol>
     <li>
      渐进上界（O）：大于等于复杂度
     </li>
     <li>
      渐进下界（Ω）：小于等于复杂度
     </li>
     <li>
      渐进紧致界（）：需要同时满足渐进上界和渐进下界
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c059a15ccfe4f2db9db1eea240e5377b.png"/>
    </p>
    <ol start="4">
     <li>
      例题：
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/8237ddce54ce9123141f1fc67cc61e1f.png"/>
    </p>
    <h2>
     <a id="_78">
     </a>
     四、递归式展开式的时间、空间复杂度
    </h2>
    <ol>
     <li>
      公式：
      <ol>
       <li>
        递归的次数*每次递归的时间复杂度(每次递归的时间复杂度不变的情况)
       </li>
      </ol>
     </li>
     <li>
      例题
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token comment">// 阶乘1：</span>
时间为：<span class="token class-name">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token class-name">O</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">O</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
空间<span class="token operator">:</span>因为没有新的变量产生，所以为<span class="token class-name">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>  
    <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 阶乘2</span>
时间为：<span class="token class-name">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token class-name">O</span><span class="token punctuation">(</span>log2n<span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">O</span><span class="token punctuation">(</span>log2n<span class="token punctuation">)</span>
空间<span class="token operator">:</span>因为没有新的变量产生，所以为<span class="token class-name">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>  
    <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 阶乘3</span>
<span class="token comment">//技巧：等差数列求和</span>
    公式：<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span>
时间为：<span class="token class-name">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token class-name">O</span><span class="token punctuation">(</span>n<span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">O</span><span class="token punctuation">(</span>n<span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span>
空间<span class="token operator">:</span>因为没有新的变量产生，所以为<span class="token class-name">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 次数为：n+(n-1)+(n-2)+.....+2+1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
    <h2>
     <a id="_116">
     </a>
     五、递归主方法
    </h2>
    <p>
     公式
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/bc46e1099b6f3c3c5de1174715e63688.png"/>
    </p>
    <p>
     题目：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/8e781fa51be974bafbefb9d3000c0d4c.png"/>
    </p>
    <p>
     解析：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/9fbe0276a18f5968e684d5365d831f04.png"/>
    </p>
    <h2>
     <a id="_131">
     </a>
     六、线性结构
    </h2>
    <ol>
     <li>
      特点：
      <ol>
       <li>
        元素之间呈现一种线性关系
        <ol>
         <li>
          例：一个接一个排列
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     <a id="_136">
     </a>
     线性表
    </h4>
    <ol>
     <li>
      采用
      <strong>
       顺序存储和链式存储
      </strong>
     </li>
     <li>
      主要的基本操作：
      <strong>
       插入、删除、查找
      </strong>
     </li>
     <li>
      是n（n&gt;=0）个元素的有限序列
     </li>
     <li>
      非空线性表特点：
      <ol>
       <li>
        有第一个元素
       </li>
       <li>
        有最后一个元素
       </li>
       <li>
        除第一个元素外，序列中的每个元素均有一个
        <strong>
         直接前驱
        </strong>
       </li>
       <li>
        除最后一个元素外，序列中的每个元素均有一个
        <strong>
         直接后继
        </strong>
       </li>
      </ol>
     </li>
     <li>
      注意：如果n为1是，元素可为第一和最后，没有前驱和后继
     </li>
    </ol>
    <h5>
     <a id="_147">
     </a>
     顺序存储
    </h5>
    <ol>
     <li>
      线性表中的顺序存储是指
      <ol>
       <li>
        用一组地址连续的存储单元依次存储线性表的中元素
       </li>
       <li>
        <strong>
         使得逻辑上相邻的元素物理位置也相邻
        </strong>
       </li>
      </ol>
     </li>
     <li>
      优点：可以随机存取表中的元素
     </li>
     <li>
      缺点：插入和删除都需要移动元素
     </li>
     <li>
      插入新元素需要移动的元素个数期望值：
      <ol>
       <li>
        <strong>
         n/2
        </strong>
       </li>
      </ol>
     </li>
     <li>
      删除元素需要移动元素的个数期望值：
      <ol>
       <li>
        (
        <strong>
         n-1)/2
        </strong>
       </li>
      </ol>
     </li>
     <li>
      <strong>
       插入元素代码案例
      </strong>
      <ol>
       <li>
        时间复杂度：
        <ol>
         <li>
          最优：O(1)
         </li>
         <li>
          最差:O(n)
         </li>
         <li>
          平均O()
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">TestList</span>  testList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        testList<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        testList<span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        testList<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        testList<span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">TestList</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">static</span>  <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        list <span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        n<span class="token operator">=</span><span class="token class-name">N</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     *
     * @param add 插入位置
     * @param num 插入数据
     */</span>
    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>add<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> add<span class="token operator">&gt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">&gt;=</span>add<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>list<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        list<span class="token punctuation">[</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre>
    <ol start="7">
     <li>
      <strong>
       删除元素代码案例
      </strong>
      <ol>
       <li>
        时间复杂度
        <ol>
         <li>
          最优：O(1)
         </li>
         <li>
          最差：O（n）
         </li>
         <li>
          平均：O（n）
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"> <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>add<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> add <span class="token operator">&gt;</span>n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span>add<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        n<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <ol start="8">
     <li>
      <strong>
       查找元素代码案例
      </strong>
      <ol>
       <li>
        时间复杂度：
        <ol>
         <li>
          最好：O(1)
         </li>
         <li>
          最坏：O(1)
         </li>
         <li>
          平均：O(1)
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java">  <span class="token keyword">void</span> <span class="token function">getItem</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"查询到的数据为："</span><span class="token operator">+</span>list<span class="token punctuation">[</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
    <h5>
     <a id="_240">
     </a>
     链式结构
    </h5>
    <ol>
     <li>
      通过指针链接起来的结点来存储数据元素，
     </li>
     <li>
      结点结构：
      <ol>
       <li>
        数据域+指针域
       </li>
      </ol>
     </li>
     <li>
      存储的元素地址不要求连续，因此，存储元素的同时必须存储元素之间的逻辑关系。
     </li>
     <li>
      若结点中只有一个指针域，则称为线性链表（单链表）
     </li>
     <li>
      <strong>
       结点类：
      </strong>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> num <span class="token punctuation">;</span>
    <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>

</code></pre>
    <ol start="6">
     <li>
      <strong>
       不带头结点的链式存储代码示例
      </strong>
      ：
      <ol>
       <li>
        结点从1开始算
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoHeadLineList</span> <span class="token punctuation">{<!-- --></span>


    <span class="token class-name">Node</span> list<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

        <span class="token class-name">Node</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token operator">=</span> node1<span class="token punctuation">;</span>
        node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>
        node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node3<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化并打印</span>
        <span class="token class-name">NoHeadLineList</span>  noHeadLineList<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NoHeadLineList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        noHeadLineList<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> noHeadLineList<span class="token punctuation">.</span>list<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>num<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <ol start="7">
     <li>
      不带头结点的链式存储代码示例：
      <ol>
       <li>
        结点从0开始
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeadLineList</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Node</span> list<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> n1<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> n2<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> n3<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span>
        n1<span class="token punctuation">.</span>next<span class="token operator">=</span> n2<span class="token punctuation">;</span>
        n2<span class="token punctuation">.</span>next<span class="token operator">=</span>n3<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">HeadLineList</span> headLineList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeadLineList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        headLineList<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> headLineList<span class="token punctuation">.</span>list<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre>
    <ol start="8">
     <li>
      带头结点插入数据：
      <ol>
       <li>
        时间复杂度：
        <ol>
         <li>
          最好：O(1)
         </li>
         <li>
          最坏：O(n)
         </li>
         <li>
          平均：O(n)
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> add <span class="token punctuation">,</span><span class="token class-name">Node</span> noe<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            index<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 先将前一个结点的地址放入要插入的结点中</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">// 再把地址替换成新结点</span>

    <span class="token punctuation">}</span>
</code></pre>
    <ol start="9">
     <li>
      不带头结点的插入数据
      <ol>
       <li>
        时间复杂度：
        <ol>
         <li>
          最好：O(1)
         </li>
         <li>
          最坏：O(n)
         </li>
         <li>
          平均：O(n)
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java">  <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> add <span class="token punctuation">,</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//插入第一个结点时，直接修改</span>
            node<span class="token punctuation">.</span>next<span class="token operator">=</span>list<span class="token punctuation">;</span>
            list <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            index<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
    <ol start="10">
     <li>
      删除带头结点的数据
      <ol>
       <li>
        时间复杂度：
        <ol>
         <li>
          最好：O(1)
         </li>
         <li>
          最坏：O(n)
         </li>
         <li>
          平均：O(n)
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c9736df1309117c866b99bc7fd7bb3d7.png"/>
    </p>
    <pre><code class="prism language-java">  <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> index <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            index<span class="token operator">++</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Node</span> s <span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre>
    <ol start="11">
     <li>
      删除不带头结点的数据
      <ol>
       <li>
        需要添加特殊判断
        <ol>
         <li>
          直接将List指向下一个结点就可以了
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>add<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            list<span class="token operator">=</span>list<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">&lt;</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>p<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            index<span class="token operator">++</span><span class="token punctuation">;</span>
            p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Node</span> s <span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre>
    <ol start="12">
     <li>
      查询带头结点的数据
      <ol>
       <li>
        时间复杂度：
        <ol>
         <li>
          最好：O(1)
         </li>
         <li>
          最坏：O(n)
         </li>
         <li>
          平均：O(n)
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token class-name">Node</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> index<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token class-name">Node</span> p <span class="token operator">=</span> list<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span>add<span class="token operator">&amp;&amp;</span>p<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <ol start="13">
     <li>
      循环单链表
      <ol>
       <li>
        在尾节点的地址中存储首结点的地址
        <ol>
         <li>
          注意：当在尾结点插入元素时需要：
          <ol>
           <li>
            现在插入元素中存储首节点的地址，再在尾结点中存储插入元素的地址。
           </li>
          </ol>
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/96fa9c8f2f8063cf9c6989fbcdf40443.png"/>
    </p>
    <h5>
     <a id="_446">
     </a>
     双链表（了解）
    </h5>
    <h5>
     <a id="_447">
     </a>
     顺序栈
    </h5>
    <p>
     <strong>
      栈常用于函数的递归实现
     </strong>
    </p>
    <ol>
     <li>
      定义：栈只能通过它的一端来实现数据存储和检索的一种
      <strong>
       线性数据结构
      </strong>
     </li>
     <li>
      <strong>
       先进后出原则
      </strong>
     </li>
     <li>
      名词解释：
      <ol>
       <li>
        栈顶：Top
       </li>
       <li>
        栈底：Bottom
       </li>
      </ol>
     </li>
     <li>
      栈的基本运算
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/d59f123b6afd5848ae4759422be01a99.png"/>
    </p>
    <h5>
     <a id="_459">
     </a>
     链栈
    </h5>
    <ol>
     <li>
      定义：用链表作用存储结构的栈
     </li>
     <li>
      链表的头指针就是栈顶指针
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/0d932ed5b9fb7c4fb518409ca9cefaef.png"/>
    </p>
    <p>
     例题：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/bf605e03c507fd089784102319575ea9.png"/>
    </p>
    <p>
     解答：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a9edcf27f4bbab23cbec283432c590e0.png"/>
    </p>
    <h5>
     <a id="_473">
     </a>
     顺序队列
    </h5>
    <ol>
     <li>
      定义：
      <ol>
       <li>
        队列是先进先出的线性表。
       </li>
       <li>
        它只允许在表的一端插入元素（队尾插入），在表的另一端删除元素（队头删除）。
       </li>
      </ol>
     </li>
     <li>
      顺序队列由于队列中的删除和插入在两端进行，所以需要
      <strong>
       设置队头指针和队尾指针
      </strong>
     </li>
     <li>
      队列的基本运算
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token comment">// 初始化队列</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> alist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> before<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//队头</span>
    <span class="token keyword">int</span> after <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//队尾</span>
<span class="token comment">// 判断空</span>
    before <span class="token operator">==</span>after <span class="token comment">// true为空，</span>
<span class="token comment">// 入队</span>
    alist<span class="token punctuation">[</span>after<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>
    after<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token comment">//出队</span>
    before<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token comment">//读队头元素</span>
    alist<span class="token punctuation">[</span>before<span class="token punctuation">]</span>
</code></pre>
    <h5>
     <a id="_496">
     </a>
     循环队列
    </h5>
    <ol>
     <li>
      优点：
      <ol>
       <li>
        <strong>
         出队和入队都不需要移动队列中的其他元素
        </strong>
       </li>
      </ol>
     </li>
     <li>
      假设队列中有6个元素，队尾值已经为5个，还想要插入数据时，并且不产生越界（删除数据也是类似方法）：
      <ol>
       <li>
        修改公式：（队尾+1）/6
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a39977c1d71c7356df3ff3b4af3ee2af.png"/>
    </p>
    <ol start="3">
     <li>
      例题：
      <ol>
       <li>
        技巧：代入法或
       </li>
       <li>
        从公式内移动队头结点
       </li>
       <li>
        +M防止下溢出（负）
       </li>
       <li>
        %M防止上一出（正）
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/0fb6c91225ee9fd95632f44ec483543d.png"/>
    </p>
    <h5>
     <a id="_514">
     </a>
     链式队列
    </h5>
    <ol>
     <li>
      链式队列
      <strong>
       具有首节点和尾结点，
      </strong>
     </li>
     <li>
      链式队列在
      <strong>
       插入和删除元素时，不需要遍历整个队列链表
      </strong>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/d86e8b0fa678bcb5976c902a90ae7721.png"/>
    </p>
    <h5>
     <a id="_520">
     </a>
     栈和队列混合题目
    </h5>
    <ol>
     <li>
      <strong>
       两个栈可以模拟出一个队列
      </strong>
     </li>
     <li>
      入队序列和出队序列关系为1：1
      <ol>
       <li>
        例如：入队为abc,出队为abc
       </li>
      </ol>
     </li>
     <li>
      入栈序列和出栈序列关系为：1:n(n&gt;=1)
      <ol>
       <li>
        例如：
        <strong>
         出栈和出栈的排序方式可以有多种
        </strong>
       </li>
      </ol>
     </li>
     <li>
      例题：
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/05f23ae8411fffa0af18ca7f9ec6622c.png"/>
    </p>
    <h5>
     <a id="_532">
     </a>
     串
    </h5>
    <ol>
     <li>
      定义：是仅由
      <strong>
       字符构成的有限序列
      </strong>
      ，是一种
      <strong>
       线性表
      </strong>
      。
     </li>
     <li>
      形式：
      <ol>
       <li>
        String str=“abcd”；
       </li>
      </ol>
     </li>
     <li>
      扩展知识：
      <ol>
       <li>
        ASCII：
        <ol>
         <li>
          0为48
         </li>
         <li>
          A为65
         </li>
         <li>
          a为97
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      基本概念
     </li>
     <li>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/7730dd5657a665a37161038a6afc8bc6.png"/>
    </p>
    <ol start="6">
     <li>
      字符串的子串需要是
      <strong>
       连续
      </strong>
      的
      <ol>
       <li>
        例 字符串"abc",则子串只有：
        <ol>
         <li>
          a
         </li>
         <li>
          b
         </li>
         <li>
          c
         </li>
         <li>
          ab
         </li>
         <li>
          bc
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <h5>
     <a id="__554">
     </a>
     串的匹配模式_朴素模式匹配
    </h5>
    <ol>
     <li>
      时间复杂度：
      <ol>
       <li>
        最好：O(m) 次数：m次
       </li>
       <li>
        最坏:O(m*n) 次数：（n-m+1）*n
       </li>
       <li>
        平均：O(m+n) 次数：1/2 *(n+m)
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/0ce2af8526b57b900b0b8f19a0cda33e.png"/>
    </p>
    <h5>
     <a id="_Next_562">
     </a>
     串_Next数组值
    </h5>
    <ol>
     <li>
      串的前缀：包含第一个字符且不包含最后一个字符的子串
      <ol>
       <li>
        例：字符串为：abc
        <ol>
         <li>
          前缀可为：a;b;ab
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      串的后缀：包含最后一个字符且不包含最后一个字符的子串
      <ol>
       <li>
        例如：字符串：abc
        <ol>
         <li>
          后缀有：b;c;bc
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      记：第i个元素的next值等于：
      <ol>
       <li>
        <strong>
         从1~i-1串中最长相等前后缀长度+1
        </strong>
       </li>
       <li>
        例题：字符串中：abcd求d的next值：
        <ol>
         <li>
          过程：当长度为1时，前缀为a,后缀为：c，不相等
         </li>
         <li>
          长度为2时：前缀为：ab,后缀为：bc，不相等
         </li>
         <li>
          长度1和长度2都为0，所以0+1=1
         </li>
         <li>
          d的next值为：1
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      记住：n
      <strong>
       ext[1]=0;next[2]=1
      </strong>
     </li>
    </ol>
    <h5>
     <a id="KMP_578">
     </a>
     KMP算法（了解）
    </h5>
    <h2>
     <a id="_579">
     </a>
     一维数组和二维数组地址计算
    </h2>
    <p>
     注意：
     <strong>
      当在二维数组中i和j相同时，按行存储和按列存储都是一样的。
     </strong>
    </p>
    <p>
     <strong>
      arr[a][b]:a为行，b为列
     </strong>
    </p>
    <hr/>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/d0a835e739f781cc534d6099cd278895.png"/>
    </p>
    <ul>
     <li>
      题目1：
      <ul>
       <li>
        技巧1：直接背公式
       </li>
       <li>
        技巧2：可以举简单的二维数组推出结果
       </li>
      </ul>
     </li>
     <li>
      <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c27b9dd80e33ebf062064ccb33b59dc0.png"/>
     </li>
     <li>
      题目2：
      <ul>
       <li>
        结论：
        <strong>
         二维数组在j和i都相同时，不关是按列存储还是按行存储，存储的位置同时相同的（偏移量相同）。
        </strong>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/1e1fc355e269e3a3cd70e4836c180925.png"/>
    </p>
    <h2>
     <a id="_603">
     </a>
     七、矩阵
    </h2>
    <h4>
     <a id="_606">
     </a>
     对称矩阵
    </h4>
    <p>
     对称矩阵：
    </p>
    <p>
     三个区域 ：
    </p>
    <p>
     i=j &gt;&gt;&gt;&gt;主对称线
    </p>
    <p>
     i&gt;j&gt;&gt;&gt;&gt;&gt;下三角区
    </p>
    <p>
     i&gt;&gt;&gt;&gt;上三角区
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/1d6da43e56db356c444647894a829d1e.png"/>
    </p>
    <ol>
     <li>
      考点：
      <strong>
       将对称矩阵数据压缩，并用按行优先存储。
      </strong>
     </li>
     <li>
      需要存储个数公式：((1+n)*n)/2
      <ol>
       <li>
        例：存存储一个a[3][3]数组
        <ol>
         <li>
          解：(1+3)
          <em>
           3/2=4
          </em>
          3/2=6
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      对称矩阵转换为一维数组存储位置公式(
      <strong>
       下标为0的情况
      </strong>
      )：
      <br/>
      1.
      <strong>
       当i&gt;=j时：a(i,j)=i(i+1)/2+j+1
      </strong>
      <br/>
      2.
      <strong>
       当i&lt;=j时，a(i,j)=j(j+1)/2+i+1
      </strong>
     </li>
     <li>
      对称矩阵转换为一维数组存储位置公式(
      <strong>
       下标为1的情况
      </strong>
      )：
      <br/>
      1.
      <strong>
       当i&gt;=j时：a(i,j)=i(i-1)/2+j
      </strong>
      <br/>
      2.
      <strong>
       当i&lt;=j时，a(i,j)=j(j-1)/2+i
      </strong>
     </li>
     <li>
      注意点：做题是看要求的是上三角还是下上三角
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/7209e774180420995b89cabb3e3cdd8e.png"/>
    </p>
    <ol start="6">
     <li>
      例题:
      <ol>
       <li>
        技巧：
        <strong>
         如果做到此题忘记了公式的话，可以采用代入法：
        </strong>
        <ol>
         <li>
          结果：A
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/8399bdb8ca4fae4fd175f42bc784295b.png"/>
    </p>
    <h4>
     <a id="_641">
     </a>
     对三角矩阵
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/532b01ba16174af4371dde344c7b4c70.png"/>
    </p>
    <ol>
     <li>
      <p>
       <strong>
        位置推导（下标为0）：
       </strong>
      </p>
      <ol>
       <li>
        假设A[3,3]在一位数组中存储位置为：10
        <ol>
         <li>
          10的由来分为两步：
         </li>
         <li>
          第一步：求出3[3,3]之前的元素个数：公式为：i*3-1(减一是因为第一行只有两个元素)
         </li>
         <li>
          第二步：求第几个，看j和i，通过j-i可以得到距离为（-1,0,1），所以把每个数+2，则可得到第几个公式：j-i+2
         </li>
         <li>
          两步合并：i*3-1+j-i+2
         </li>
         <li>
          化简：2i+j+1&gt;&gt;&gt;&gt;&gt;&gt;2*3+3+1=10
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      <p>
       公式
      </p>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/2330c930ba4c0f9e8091f554562cff97.png"/>
    </p>
    <h4>
     <a id="_658">
     </a>
     稀疏矩阵
    </h4>
    <ol>
     <li>
      记：稀疏矩阵的三元组表的顺序存储结构称为：
      <strong>
       三元组顺序表
      </strong>
      ，常用的三元组表的链式存储结构是
      <strong>
       十字链表。
      </strong>
     </li>
     <li>
      **记：****三元顺序表和十字链表**是对稀疏矩阵进行压缩存储的方式。
     </li>
     <li>
      **三元组顺序表（图右边）**存储稀疏矩阵
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/46d8dd163b0398264e965acf0e73e765.png"/>
    </p>
    <ol start="4">
     <li>
      **十字链表（图右边）**存储稀疏矩阵
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/4dfb67142e865d111c262f7897f845e5.png"/>
    </p>
    <h2>
     <a id="_669">
     </a>
     八、树
    </h2>
    <h4>
     <a id="_670">
     </a>
     定义
    </h4>
    <ol>
     <li>
      树结构是
      <strong>
       非线性结构
      </strong>
     </li>
     <li>
      该结构中的一个元素可以有两个或两个以上的直接后续元素（
      <strong>
       一对多
      </strong>
      ）
     </li>
     <li>
      数是n（n&gt;=0）个结点的有限集合，当n为0时，称为空树。
     </li>
     <li>
      在任一非空树中，有且仅有一个称为根结点。
     </li>
     <li>
      树的定义是
      <strong>
       递归
      </strong>
      的，它表明了树本身的固有特性，也就是一棵树有若干颗子树构成，而子树又由更小的子树构成。
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a9792f4cdf73ef63611505d9b31dd91f.png"/>
    </p>
    <h4>
     <a id="1_679">
     </a>
     树的性质1
    </h4>
    <ol>
     <li>
      树中的结点总数=树中所有结点的度数之和+1（加1表示加上根结点）
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/013ab132414bc50568a9d3d85a4ede4d.png"/>
    </p>
    <ol start="2">
     <li>
      例题：
      <ol>
       <li>
        树中的结点总数为：
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/2e9cef691aa2f64bccc216a2e4ca9852.png"/>
    </p>
    <h4>
     <a id="2_691">
     </a>
     树的性质2
    </h4>
    <ol>
     <li>
      度为m的树中第i层上最多有m^(i-1)个结点（i&gt;=1）
     </li>
     <li>
      例：
      <ol>
       <li>
        根结点：1个
       </li>
       <li>
        第二层：3个
       </li>
       <li>
        第三层：9个
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/7252c96ae63d10b02605664480d89028.png"/>
    </p>
    <h4>
     <a id="3_700">
     </a>
     树的性质3
    </h4>
    <ol>
     <li>
      高度为h的m次树最多有（m^h-1）/(m-1)个结点
      <ol>
       <li>
        公式是通过等比数列推导出来的
       </li>
      </ol>
     </li>
     <li>
      例题：
      <ol>
       <li>
        h为3，m为3，求结点：
       </li>
       <li>
        解：(3^3-1)/3-1=26/2=13
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/b90dece8de55912f97943d1065c3673c.png"/>
    </p>
    <h4>
     <a id="4_709">
     </a>
     <strong>
      树的性质4
     </strong>
    </h4>
    <ol>
     <li>
      知道n个结点和为m的数，求
      <strong>
       树的高度h
      </strong>
     </li>
     <li>
      对性质3的公式变形
     </li>
    </ol>
    <p>
     $ n=m^h-1/m-1 $
    </p>
    <p>
     变形：
    </p>
    <p>
     n(m-1)=m^h-1
    </p>
    <p>
     n(m-1)+1=m^h
    </p>
    <p>
     h=logm (n(m-1)+1)
    </p>
    <p>
     注意：当求出h出现小数点后，需要进行向上取整。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/81db17da9322f6b039ed153e574bd09c.png"/>
    </p>
    <h4>
     <a id="_731">
     </a>
     例题
    </h4>
    <pre><code>1. 解释：
    1. 叶子结点（终端结点）：指数为0的节点，它之下没有节点
    2. 
</code></pre>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/92a885e091ed01af3c263727e407dcc6.png"/>
    </p>
    <h4>
     <a id="_738">
     </a>
     二叉树
    </h4>
    <ol>
     <li>
      定义：
      <ol>
       <li>
        是n（i大于等于0）个节点的有限集合
       </li>
       <li>
        n为0时，是一个空树
       </li>
       <li>
        当n≠0时，一个根节点及两颗不同相交的且分别称为左右子树的二叉树组成
       </li>
       <li>
        二叉树具
        <strong>
         有递归性质
        </strong>
       </li>
      </ol>
     </li>
     <li>
      树和二叉树的区别
      <ol>
       <li>
        二叉树严格区分结点是左子树还是右子树
       </li>
       <li>
        树不区分，称为子树即可。
       </li>
       <li>
        二叉树中，结点的最大度为
        <strong>
         2
        </strong>
       </li>
       <li>
        树不限制结点的度数
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="画板" src="https://i-blog.csdnimg.cn/img_convert/ef4e8a50daab1c326323d670b272f3e6.jpeg"/>
    </p>
    <ol start="3">
     <li>
      二叉树的性质：
      <ol>
       <li>
        <strong>
         第i层（i≥）上最多有2^(i-1)个结点
        </strong>
        <ol>
         <li>
          例 第二层：2^(2-1)=2
         </li>
        </ol>
       </li>
       <li>
        高度为h的二叉树共有结点：2^h-1
        <ol>
         <li>
          共2层的二叉树：2*2-1=3
         </li>
        </ol>
       </li>
       <li>
        对于任一二叉树，度数为0的结点树=度为2的结点树+1（n0=n2+1）
        <ol>
         <li>
          共2层的二叉树：n0=1+1=2
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/47f45304345169218cd07328d50ae2a2.png"/>
    </p>
    <h4>
     <a id="_764">
     </a>
     满足二叉树
    </h4>
    <ol>
     <li>
      高度为k的二叉树有2^k-1个结点
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/68eeae33596373625dedc49e85256d6e.png"/>
    </p>
    <p>
     例题：
    </p>
    <p>
     求满二叉树7个结点，求高度：
    </p>
    <p>
     Log2 (7+1)=3
    </p>
    <h4>
     <a id="_775">
     </a>
     完全二叉树
    </h4>
    <ol>
     <li>
      <strong>
       高度为h，除了h层的，其余结点都是满的，且结点从左到右依次存储，不能留空。
      </strong>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/0cfd88ed8fa54deccb7e7277de798641.png"/>
    </p>
    <p>
     例题：
    </p>
    <p>
     求完全二叉树6个结点，求高度：
    </p>
    <p>
     解：（log2 6 ）+1=2+1=3
    </p>
    <h4>
     <a id="_786">
     </a>
     单支树
    </h4>
    <p>
     除了叶子结点，其余结点度为1
    </p>
    <h4>
     <a id="_791">
     </a>
     二叉树的存储结构
    </h4>
    <h5>
     <a id="_792">
     </a>
     顺序存储
    </h5>
    <ol>
     <li>
      使用数组存储
     </li>
     <li>
      定义：顺序存储是有一组地址连续的存储存二叉树的结点
     </li>
     <li>
      假设编号为i
      <ol>
       <li>
        i=1，为根结点
       </li>
       <li>
        2i≤n ：i为左编号，关系式不成立时，没有左孩子
       </li>
       <li>
        2i+1小于等于n：i为右结点，关系式不成立时，没有右孩子
       </li>
      </ol>
     </li>
     <li>
      <strong>
       完全二叉树采用顺序存储结构高效且节约空间。
      </strong>
     </li>
     <li>
      一般的二叉树，不宜使用顺序结构。
     </li>
     <li>
      最坏情况下，高度为k且只有k个节点的二叉树（单支树）需要(2^k)-1个存储单元。
      <ol>
       <li>
        例：
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="画板" src="https://i-blog.csdnimg.cn/img_convert/f13d91b6bfcf595cff96a91bf0a09625.jpeg"/>
    </p>
    <p>
     存储单位为：(2^2)-1=3
    </p>
    <p>
     <strong>
      记
     </strong>
    </p>
    <p>
     <strong>
      题1：
     </strong>
    </p>
    <p>
     <strong>
      求3个结点的二叉树有多少个形态====》5
     </strong>
    </p>
    <p>
     <strong>
      求4个结点的二叉树有多少个形态====》14
     </strong>
    </p>
    <p>
     **求5个结点的二叉树有多少个形态====》42 **
    </p>
    <p>
     <strong>
      题2
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/f84e60c28c52987f3f31de5f350dc69a.png"/>
    </p>
    <h5>
     <a id="_826">
     </a>
     链式存储
    </h5>
    <ol>
     <li>
      结点中包含了有数据雅元素、左子树的根、右子树的更，及双重信息。
     </li>
     <li>
      <strong>
       考点1
      </strong>
      <ol>
       <li>
        <strong>
         一个双链表中，有多少个空指针域。
        </strong>
        <ol>
         <li>
          解：二叉树中有n个结点，有（n-1）个分支，分支就是有效指针域，一个结点有2个指针
          <ol>
           <li>
            公式：2n-(n-1)=
            <strong>
             n+1
            </strong>
           </li>
          </ol>
         </li>
        </ol>
       </li>
      </ol>
     </li>
     <li>
      <strong>
       考点2
      </strong>
      <ol>
       <li>
        <strong>
         一个三链表中，有多少个空指针域。
        </strong>
        <ol>
         <li>
          公式：n+2
         </li>
        </ol>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/5034ab0b9f652150e49f9a4008674048.png"/>
    </p>
    <h4>
     <a id="_840">
     </a>
     二叉树的遍历算法
    </h4>
    <h6>
     <a id="_841">
     </a>
     先序遍历
    </h6>
    <p>
     根左右
    </p>
    <h6>
     <a id="_844">
     </a>
     中序遍历
    </h6>
    <p>
     左根右
    </p>
    <h6>
     <a id="_847">
     </a>
     后序遍历
    </h6>
    <p>
     左右根
    </p>
    <h6>
     <a id="_850">
     </a>
     层次遍历
    </h6>
    <p>
     从第1层，先上后先，先左后右
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/b2880ad9f3a3f6f4b5947ed1822c665e.png"/>
    </p>
    <hr/>
    <hr/>
    <h4>
     <a id="_861">
     </a>
     根据遍历构造二叉树
    </h4>
    <ol>
     <li>
      步骤：先有中序，中序+其他可以找出根结点，从而推出整个二叉树
     </li>
     <li>
      组合有：
      <ol>
       <li>
        中+先
       </li>
       <li>
        中+后
       </li>
       <li>
        中+层
       </li>
      </ol>
     </li>
     <li>
      注意点：
      <strong>
       其他两个序列推不出中序
      </strong>
     </li>
    </ol>
    <h4>
     <a id="_869">
     </a>
     平衡二叉树
    </h4>
    <ol>
     <li>
      定义：二叉树的任意一个结点的左右子树高度只差的绝对值
      <strong>
       不超过1
      </strong>
     </li>
     <li>
      <strong>
       满二叉树包含完全二叉树，完全二叉树包含平衡树
      </strong>
     </li>
    </ol>
    <h4>
     <a id="_873">
     </a>
     二叉排序树（二叉查找树）
    </h4>
    <ol>
     <li>
      特点（根据结点的关键字）：
      <ol>
       <li>
        <strong>
         大于左子树
        </strong>
        所有结点的关键字
       </li>
       <li>
        <strong>
         小于右子树
        </strong>
        所有结点的关键字
       </li>
       <li>
        左右子树也是一颗二叉排序树
       </li>
      </ol>
     </li>
     <li>
      <strong>
       中序遍历
      </strong>
      得到的序列也是有序序列
     </li>
     <li>
      例：
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/946d1673b72a160dcaff8654e24332eb.png"/>
    </p>
    <h4>
     <a id="_883">
     </a>
    </h4>
    <ol start="4">
     <li>
      二叉排序树的构造
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/c286809967519ec1d4b54dfffe7b4ac6.png"/>
    </p>
    <ol start="5">
     <li>
      二叉排序树，进行查找时，效率最差的
      <strong>
       单支树
      </strong>
     </li>
     <li>
      二叉排序树，
      <strong>
       从左到右排序，同层次的结点，其关键字呈现有序排序特点
      </strong>
      <ol>
       <li>
        <strong>
         例：
        </strong>
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/5053e7c673bfe6c32743878b0a00e13f.png"/>
    </p>
    <h4>
     <a id="_894">
     </a>
     最优二叉树（哈夫曼树）
    </h4>
    <ol>
     <li>
      定义：它是一类带权路径长队最短的树
     </li>
     <li>
      <strong>
       最优二叉树,只有N0和N2，
      </strong>
     </li>
     <li>
      <strong>
       总结点数为：2n-1
      </strong>
     </li>
     <li>
      树的带权路径长度=树中所有叶子结点的带权路径长度之和
      <ol>
       <li>
        公式：
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/430846632be669dc2d9d00512739ebeb.png"/>
    </p>
    <pre><code>2. n为带权结点树目，Wr为叶子节点的权值，Lr为叶子结点到根的路径长度
</code></pre>
    <p>
     例：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a7ab221dda3cb769c52de10c6e1c0f95.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/3146e273419716ab215875baaca6a3ff.png"/>
    </p>
    <h4>
     <a id="_913">
     </a>
     最优二叉树的构造方法
    </h4>
    <ol>
     <li>
      大概步骤：
      <ol>
       <li>
        根据题目给的n个权值 如：{1,2,3,4,}
       </li>
       <li>
        转成n颗二叉树的集合(其中的每个元素都是一颗树) F={1,2,3,4,}
       </li>
       <li>
        选中最小的两个作为左、右子树，构造出一颗新的树
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/04644982274593d44fe806cc7f43b9c1.png"/>
    </p>
    <pre><code>4. 删除F中使用的二叉树并新增数F={4,3,4}
5. 重复c,d步骤，当F中只剩下一颗树，就是最优了
</code></pre>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/70b271dfb37d9582f76512dba303b722.png"/>
    </p>
    <ol start="2">
     <li>
      注意：
      <strong>
       在构造左右子树并没有明确规定位置，但是WPL是唯一的。
      </strong>
     </li>
    </ol>
    <h4>
     <a id="_928">
     </a>
     软考构造最优二叉树的注意事项☆☆☆☆☆☆☆
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/545e2e2b9c961ee44c7f56d16d080f68.png"/>
    </p>
    <p>
     案例一：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/b9f39f65b27669f5c6e076fbaf3d2b8c.png"/>
    </p>
    <p>
     案例二：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a83cfb8dde64c54aab5405e898203956.png"/>
    </p>
    <h4>
     <a id="_939">
     </a>
     等长编码
    </h4>
    <p>
     每个字符编制相同的长度的二进制编码
    </p>
    <p>
     <strong>
      考点一例题：
     </strong>
    </p>
    <p>
     告诉英文字符为26个字符，求需要多少个二进制表示？
    </p>
    <p>
     解：2^n&gt;=26
    </p>
    <p>
     n=5
    </p>
    <h4>
     <a id="_950">
     </a>
     哈夫曼编码
    </h4>
    <p>
     考点一：给一串字符并相应权重，求出最优二叉树，在通过标0/1，求出每个字符的编码
    </p>
    <p>
     例：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/4c58bd4ff070f0154cacc981db7296e1.png"/>
    </p>
    <h4>
     <a id="_957">
     </a>
     哈夫曼编码压缩比：
    </h4>
    <p>
     求一串字符，通过等长编码和哈夫曼编码分别求出需要空间，并算出使用哈夫曼编码可以节省多少空间。
    </p>
    <p>
     例：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/e10ba80b93c4ebcfa02ced87a224db34.png"/>
    </p>
    <h4>
     <a id="_964">
     </a>
     线索二叉树（了解）
    </h4>
    <p>
     特点：在结点存储的信息中作一些改变
    </p>
    <h4>
     <a id="_967">
     </a>
     二叉树的关系引入
    </h4>
    <p>
     满二叉树包含完全二叉树
    </p>
    <p>
     完全二叉树包含平衡二叉树
    </p>
    <p>
     平衡二叉树
    </p>
    <p>
     排序二叉树
    </p>
    <p>
     最优二叉树
    </p>
    <p>
     线索二叉树
    </p>
    <h4>
     <a id="_980">
     </a>
     二叉树考点知识
    </h4>
    <ol>
     <li>
      用n个权值构造一颗最优二叉树，该树的结点为：
      <strong>
       2n-1
      </strong>
     </li>
     <li>
      霍夫曼编码是基于
      <strong>
       贪心
      </strong>
      策略
     </li>
     <li>
      哈夫曼树中的结点一定为
      <strong>
       奇数
      </strong>
     </li>
     <li>
      任意一颗二叉树都是一颗
      <strong>
       线索二叉树
      </strong>
     </li>
    </ol>
    <h2>
     <a id="_986">
     </a>
     十、图
    </h2>
    <ol>
     <li>
      定义：
      <ol>
       <li>
        图G是集合V和E构成的二元组，记 ：G=（V,E）
       </li>
       <li>
        V是图中顶点的非空有限集合，E是图中边的有限集合
       </li>
       <li>
        图中，元素用顶点表示，元素之间的关系用边表示
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     <a id="_992">
     </a>
     有向图
    </h4>
    <p>
     每条边都是有方向的
    </p>
    <p>
     用&lt;v1,v1&gt;表示，v1表示弧尾，v2表示弧头
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/900366ddc169b4a11f48b99377605267.png"/>
    </p>
    <p>
     注意：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/3f4bd2bd4bd06c5d122d07eadc3b4a7e.png"/>
    </p>
    <h4>
     <a id="_1003">
     </a>
     无向图
    </h4>
    <p>
     每条边都是没有方向的
    </p>
    <p>
     用（v1,v1）表示
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/30a8d11541ac550d6e1b6a7089658b6b.png"/>
    </p>
    <p>
     注意：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/e48f14de8179db7fdd265083ef5669e2.png"/>
    </p>
    <h4>
     <a id="_1014">
     </a>
     完全图
    </h4>
    <h6>
     <a id="__1015">
     </a>
     无 向完全图
    </h6>
    <ol>
     <li>
      若有N个顶点
      <ol>
       <li>
        每个顶点和其他n-1个顶点都有边
       </li>
       <li>
        有(n(n-1))/2条边
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/81510e0672b85d5fff5b7f8976e19339.png"/>
    </p>
    <h6>
     <a id="_1022">
     </a>
     有向完全图
    </h6>
    <ol>
     <li>
      有n个顶点：
      <ol>
       <li>
        需要n（n-1）条边，
       </li>
      </ol>
     </li>
    </ol>
    <p>
     例：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/414e38acc00987e4699390b2cfca2a6d.png"/>
    </p>
    <h4>
     <a id="_1030">
     </a>
     顶点的度
    </h4>
    <ol>
     <li>
      无向图：顶点的度指关联该顶点的边的树目
     </li>
     <li>
      有向图：分为出度（指向其他顶点）和入度（其他顶点指向自己）
     </li>
     <li>
      有向图的每一个顶点的总度数为：出度+入度
     </li>
     <li>
      重点：
      <strong>
       有向完全图和无向完全图的度数都是2e(e为边数)
      </strong>
      <ol>
       <li>
        <strong>
         边数e=总度数/2
        </strong>
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     <a id="_1037">
     </a>
     图的路径
    </h4>
    <ol>
     <li>
      路径的长度为：弧的树目
     </li>
     <li>
      例题:
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/a8540c7d470e1aa4f404d88a87a7ca40.png"/>
    </p>
    <ol start="3">
     <li>
      <strong>
       起点和终点相同称为回路或环
      </strong>
     </li>
    </ol>
    <h4>
     <a id="_1045">
     </a>
     连通图
    </h4>
    <ol>
     <li>
      定义：
      <strong>
       无向图中任意两个顶点都是连通的。
      </strong>
     </li>
     <li>
      边数
      <ol>
       <li>
        最少：n-1
       </li>
       <li>
        最多：n(n-1)/2
       </li>
      </ol>
     </li>
     <li>
      例题：
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/ac1dacfc0dcb453a33ac86427976bfdb.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/7de1209acc175da7cb8ef503c9e1d087.png"/>
    </p>
    <h4>
     <a id="_1058">
     </a>
     强连通图
    </h4>
    <ol>
     <li>
      定义：
      <strong>
       在有向图中，从Vi到Vj和从Vj到Vi都是有路径的
      </strong>
     </li>
     <li>
      边数：
      <ol>
       <li>
        最少：n
       </li>
       <li>
        最多：n（n-1）
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     <a id="_1064">
     </a>
     图的存储结构
    </h4>
    <p>
     两种表示法：
    </p>
    <p>
     邻接矩阵
    </p>
    <p>
     邻接表
    </p>
    <h5>
     <a id="_1071">
     </a>
     邻接矩阵
    </h5>
    <ol>
     <li>
      无向表
      <ol>
       <li>
        的邻接矩阵都是
        <strong>
         对称
        </strong>
        的。
       </li>
       <li>
        看某个顶点Vi的度，直接看对应行的非0个数
       </li>
       <li>
        2e=非0个数
       </li>
      </ol>
     </li>
     <li>
      有向表：
      <ol>
       <li>
        出度看行的1个数
       </li>
       <li>
        入度看列的1个数
       </li>
       <li>
        总度=出度+入度
       </li>
       <li>
        边数e=非0个数
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/afb951bec8bc3533e93afb0a8f3e4aea.png"/>
    </p>
    <h5>
     <a id="_1086">
     </a>
     邻接表
    </h5>
    <ol>
     <li>
      定义：指的是为图的每个顶点建立一个单链表，
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/729ee038968171f072500552cea753bc.png"/>
    </p>
    <h4>
     <a id="_1093">
     </a>
     稠密图和稀疏图
    </h4>
    <ol>
     <li>
      稠密图：边尽可能的多，顶点与顶点间都有两条边，
     </li>
     <li>
      <strong>
       稠密图存储邻接矩阵
      </strong>
      <ol>
       <li>
        例：完全图
       </li>
      </ol>
     </li>
     <li>
      稀疏图：边少
     </li>
     <li>
      <strong>
       稀疏图存邻接表
      </strong>
     </li>
    </ol>
    <h4>
     <a id="_1100">
     </a>
     考点记录
    </h4>
    <p>
     有向图在邻接矩阵非0个数为：e
    </p>
    <p>
     无向图在邻接矩阵的非0个数为2e
    </p>
    <h4>
     <a id="_1105">
     </a>
     扩展—网
    </h4>
    <ol>
     <li>
      定义：网是在图的基础上，在图的每条边都增加了一个权值
     </li>
     <li>
      网在邻接矩阵中把0替换成了∞
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/b93e273fce17e2cf0563b0722c4142f9.png"/>
    </p>
    <h4>
     <a id="_1111">
     </a>
     图的遍历
    </h4>
    <ol>
     <li>
      定义：指从某顶点出发，沿着某条搜索路径对图中所有顶点进行访问且指访问依次的过程。
     </li>
     <li>
      为了避免对顶点重复访问，在图的遍历过程中必须记下每个访问过的顶点。
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/1c18139efb17dc0873e21de1d21e8476.png"/>
    </p>
    <h4>
     <a id="DFS_1117">
     </a>
     深度优先搜索(DFS)
    </h4>
    <ol>
     <li>
      实现思想：
      <strong>
       递归
      </strong>
     </li>
     <li>
      遍历特点：第一次沿着一条路走到底，没有路时在回溯当上顶点走其他分支
     </li>
     <li>
      <strong>
       遍历过程
      </strong>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/24252f9636c0d5e9648df15b7491ce9c.png"/>
    </p>
    <ol start="4">
     <li>
      时间复杂度
      <ol>
       <li>
        使用邻接矩阵表示：T平均=O(n^2)
       </li>
       <li>
        使用邻接表表示：T平均=O(e+n)
       </li>
      </ol>
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/82032426c599b4fa3e2d7407741866b8.png"/>
    </p>
    <h4>
     <a id="BFS_1130">
     </a>
     广度优先搜索（BFS）
    </h4>
    <ol>
     <li>
      实现思想：
      <strong>
       队列
      </strong>
     </li>
     <li>
      特点：先访问完一个顶点的所有邻接点，后再访问其他
     </li>
     <li>
      遍历步骤：
     </li>
    </ol>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/5d8cb094064ab387920d893dc2fe7585.png"/>
    </p>
    <ol start="4">
     <li>
      时间复杂度
      <ol>
       <li>
        使用邻接矩阵表示：T平均=O(n^2)
       </li>
       <li>
        使用邻接表表示：T平均=O(e+n)
       </li>
      </ol>
     </li>
    </ol>
    <h4>
     <a id="_1141">
     </a>
     拓扑排序
    </h4>
    <ol>
     <li>
      AOV网是一个
      <strong>
       有向无环图
      </strong>
     </li>
     <li>
      排序步骤：
      <ol>
       <li>
        选择入库为0的顶点并输出
       </li>
       <li>
        删除该顶点及顶点的所有边
       </li>
       <li>
        重复以上步骤，知道图中不存在入度为0的顶点
       </li>
      </ol>
     </li>
    </ol>
    <p>
     例：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/6cc496a6f514ae19aee377523de2dabc.png"/>
    </p>
    <p>
     考题一：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/3ff2584fb1d5bba96ac34825b17faa67.png"/>
    </p>
    <p>
     考题二：
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/img_convert/8f45a45225be52508292aa25d16f9a7d.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34353739333734352f:61727469636c652f64657461696c732f313436323231343833" class_="artid" style="display:none">
 </p>
</div>


