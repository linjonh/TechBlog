---
layout: post
title: "缓存使用的具体场景有哪些缓存的一致性问题如何解决缓存使用常见问题有哪些"
date: 2025-03-14 22:12:40 +0800
description: "【代码】缓存使用的具体场景有哪些？缓存的一致性问题如何解决？缓存使用常见问题有哪些？"
keywords: "缓存使用的具体场景有哪些？缓存的一致性问题如何解决？缓存使用常见问题有哪些？"
categories: ['未分类']
tags: ['缓存']
artid: "146268341"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268341
    alt: "缓存使用的具体场景有哪些缓存的一致性问题如何解决缓存使用常见问题有哪些"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268341
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268341
cover: https://bing.ee123.net/img/rand?artid=146268341
image: https://bing.ee123.net/img/rand?artid=146268341
img: https://bing.ee123.net/img/rand?artid=146268341
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     缓存使用的具体场景有哪些？缓存的一致性问题如何解决？缓存使用常见问题有哪些？
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <hr/>
    <h4>
     <a id="_2">
     </a>
     缓存使用场景、一致性及常见问题解析
    </h4>
    <hr/>
    <h5>
     <a id="_6">
     </a>
     <strong>
      一、缓存的核心使用场景
     </strong>
    </h5>
    <h6>
     <a id="1__8">
     </a>
     <strong>
      1. 高频读、低频写场景
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       典型场景
      </strong>
      ：商品详情页、新闻资讯、用户基本信息。
     </li>
     <li>
      <strong>
       特点
      </strong>
      ：数据更新频率低，但访问量极高。
     </li>
     <li>
      <strong>
       策略
      </strong>
      ：
      <ul>
       <li>
        <strong>
         Cache-Aside（旁路缓存）
        </strong>
        ：优先读缓存，未命中时查数据库并回填。
       </li>
       <li>
        <strong>
         TTL（过期时间）
        </strong>
        ：设置合理过期时间（如5分钟），平衡数据新鲜度与缓存命中率。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      示例
     </strong>
     ：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">getProduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Product</span> product <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>product <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        product <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT * FROM product WHERE id = ?"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> product<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缓存5分钟</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> product<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h6>
     <a id="2__27">
     </a>
     <strong>
      2. 热点数据加速
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       典型场景
      </strong>
      ：微博热搜、秒杀活动倒计时、直播在线人数。
     </li>
     <li>
      <strong>
       特点
      </strong>
      ：短时间内流量突增，需快速响应。
     </li>
     <li>
      <strong>
       策略
      </strong>
      ：
      <ul>
       <li>
        <strong>
         本地缓存 + 分布式缓存
        </strong>
        ：如Guava Cache + Redis，减少网络开销。
       </li>
       <li>
        <strong>
         Key分片
        </strong>
        ：将热点Key分散到多个节点（如
        <code>
         hot:item:123
        </code>
        →
        <code>
         hot:item:123_{shardId}
        </code>
        ）。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="3__34">
     </a>
     <strong>
      3. 复杂计算缓存
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       典型场景
      </strong>
      ：排行榜、聚合统计结果（如用户总积分）。
     </li>
     <li>
      <strong>
       特点
      </strong>
      ：计算成本高，结果可复用。
     </li>
     <li>
      <strong>
       策略
      </strong>
      ：
      <ul>
       <li>
        <strong>
         预计算+定时更新
        </strong>
        ：定时任务生成结果并缓存。
       </li>
       <li>
        <strong>
         Write-Through（直写）
        </strong>
        ：数据变更时同步更新缓存。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="4__41">
     </a>
     <strong>
      4. 会话与状态管理
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       典型场景
      </strong>
      ：用户登录状态、购物车信息。
     </li>
     <li>
      <strong>
       特点
      </strong>
      ：临时性数据，读写频繁。
     </li>
     <li>
      <strong>
       策略
      </strong>
      ：
      <ul>
       <li>
        <strong>
         Redis Session存储
        </strong>
        ：集中管理会话，支持分布式扩展。
       </li>
       <li>
        <strong>
         TTL自动清理
        </strong>
        ：设置会话过期时间（如30分钟）。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_50">
     </a>
     <strong>
      二、缓存一致性问题及解决方案
     </strong>
    </h5>
    <h6>
     <a id="1__52">
     </a>
     <strong>
      1. 一致性问题的根源
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       数据源多副本
      </strong>
      ：缓存与数据库存在两份数据。
     </li>
     <li>
      <strong>
       并发操作
      </strong>
      ：多线程/多节点同时修改数据。
     </li>
     <li>
      <strong>
       网络延迟
      </strong>
      ：缓存与数据库更新不同步。
     </li>
    </ul>
    <h6>
     <a id="2__57">
     </a>
     <strong>
      2. 典型场景与解决方案
     </strong>
    </h6>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         场景
        </strong>
       </th>
       <th>
        <strong>
         问题描述
        </strong>
       </th>
       <th>
        <strong>
         解决方案
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         先更新数据库，后删缓存
        </strong>
       </td>
       <td>
        删除缓存失败，后续请求读到旧数据。
       </td>
       <td>
        <strong>
         延迟双删
        </strong>
        ：更新数据库 → 删除缓存 → 延迟几百毫秒再删一次。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         先删缓存，后更新数据库
        </strong>
       </td>
       <td>
        删缓存后、更新数据库前，其他请求可能读到旧值并回填缓存。
       </td>
       <td>
        <strong>
         异步重试
        </strong>
        ：删除缓存后，通过消息队列确保数据库更新成功，否则重试删除操作。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         并发写导致覆盖
        </strong>
       </td>
       <td>
        多个线程同时更新同一数据，缓存与数据库不一致。
       </td>
       <td>
        <strong>
         分布式锁
        </strong>
        ：更新时加锁（如Redis SETNX），串行化操作。
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      示例：延迟双删伪代码
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateProduct</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1. 更新数据库</span>
    db<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>product<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 删除缓存</span>
    cache<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. 延迟再次删除（应对并发场景）</span>
    executor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> cache<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h6>
     <a id="3__76">
     </a>
     <strong>
      3. 最终一致性方案
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       Binlog监听
      </strong>
      ：通过Canal监听数据库变更，异步更新缓存。
     </li>
     <li>
      <strong>
       消息队列
      </strong>
      ：数据库变更后发送MQ消息，消费者更新缓存。
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_82">
     </a>
     <strong>
      三、缓存常见问题与应对策略
     </strong>
    </h5>
    <h6>
     <a id="1_Cache_Penetration_84">
     </a>
     <strong>
      1. 缓存穿透（Cache Penetration）
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：大量请求查询不存在的数据（如无效ID），绕过缓存直接访问数据库。
     </li>
     <li>
      <strong>
       解决
      </strong>
      ：
      <ul>
       <li>
        <strong>
         布隆过滤器（Bloom Filter）
        </strong>
        ：预存所有合法Key，拦截非法请求。
       </li>
       <li>
        <strong>
         缓存空值
        </strong>
        ：对不存在的数据缓存
        <code>
         NULL
        </code>
        并设置短TTL（如30秒）。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      示例
     </strong>
     ：
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">getProduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Product</span> product <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>product <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> product<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 布隆过滤器检查</span>
        product <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT * FROM product WHERE id = ?"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>product <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> product<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缓存空值</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> product<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h6>
     <a id="2_Cache_Avalanche_109">
     </a>
     <strong>
      2. 缓存雪崩（Cache Avalanche）
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：大量缓存同时失效，请求直接冲击数据库。
     </li>
     <li>
      <strong>
       解决
      </strong>
      ：
      <ul>
       <li>
        <strong>
         随机过期时间
        </strong>
        ：在基础TTL上增加随机值（如
        <code>
         TTL + random(0, 300)
        </code>
        ）。
       </li>
       <li>
        <strong>
         热点数据永不过期
        </strong>
        ：后台定时异步更新缓存。
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="3_Cache_Breakdown_115">
     </a>
     <strong>
      3. 缓存击穿（Cache Breakdown）
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：热点Key过期瞬间，大量并发请求直达数据库。
     </li>
     <li>
      <strong>
       解决
      </strong>
      ：
      <ul>
       <li>
        <strong>
         互斥锁（Mutex Lock）
        </strong>
        ：第一个请求重建缓存时加锁，其他请求等待。
       </li>
       <li>
        <strong>
         逻辑过期
        </strong>
        ：缓存Value包含逻辑过期时间，异步刷新。
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <strong>
      示例：互斥锁实现
     </strong>
    </p>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">getProduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Product</span> product <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>product <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Lock</span> lock <span class="token operator">=</span> redisLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取分布式锁</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            product <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 双重检查</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>product <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                product <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT * FROM product WHERE id = ?"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> product<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            redisLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> product<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <h6>
     <a id="4_Hot_Key__141">
     </a>
     <strong>
      4. 数据漂移（Hot Key 不均）
     </strong>
    </h6>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：某个节点缓存过多热点Key，导致负载不均。
     </li>
     <li>
      <strong>
       解决
      </strong>
      ：
      <ul>
       <li>
        <strong>
         本地缓存
        </strong>
        ：在应用层缓存热点数据，减少访问分布式缓存。
       </li>
       <li>
        <strong>
         Key分片
        </strong>
        ：将热点Key分散到多个节点（如
        <code>
         product:123
        </code>
        →
        <code>
         product:123_{shardId}
        </code>
        ）。
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     <a id="_149">
     </a>
     <strong>
      四、缓存策略选择
     </strong>
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         策略
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
       <th>
        <strong>
         优点
        </strong>
       </th>
       <th>
        <strong>
         缺点
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         Cache-Aside
        </strong>
       </td>
       <td>
        通用场景，需强一致性控制
       </td>
       <td>
        灵活，缓存与数据库解耦
       </td>
       <td>
        需处理一致性问题
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Read-Through
        </strong>
       </td>
       <td>
        缓存作为主要数据源
       </td>
       <td>
        简化代码，自动加载数据
       </td>
       <td>
        缓存层需支持加载逻辑
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Write-Through
        </strong>
       </td>
       <td>
        写操作频繁且需强一致性
       </td>
       <td>
        数据更新实时同步
       </td>
       <td>
        写延迟较高
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Write-Behind
        </strong>
       </td>
       <td>
        高吞吐写场景（如日志记录）
       </td>
       <td>
        写性能高，批量更新数据库
       </td>
       <td>
        数据可能丢失（未持久化前宕机）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_159">
     </a>
     <strong>
      🐮🐎
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       使用场景
      </strong>
      ：缓存适用于读多写少、热点数据、复杂计算等场景，显著提升系统性能。
     </li>
     <li>
      <strong>
       一致性问题
      </strong>
      ：通过延迟双删、异步消息、分布式锁等方案平衡性能与一致性。
     </li>
     <li>
      <strong>
       常见问题
      </strong>
      ：穿透、雪崩、击穿需针对性设计防御策略（布隆过滤器、随机TTL、互斥锁）。
      <br/>
      合理选择缓存策略，结合监控与动态调优，可最大化缓存收益并规避潜在风险。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/917a41b0f4a848e5ae51f4b3887c1d5c.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323530385f39303538303439322f:61727469636c652f64657461696c732f313436323638333431" class_="artid" style="display:none">
 </p>
</div>


