---
layout: post
title: "Leetcode-刷题记录-06-矩阵"
date: 2025-03-09 22:52:12 +0800
description: "本系列为笔者的 Leetcode 刷题记录，顺序为 Hot 100 题官方顺序，根据标签命名，记录笔者总结的做题思路，附部分代码解释和疑问解答。"
keywords: "Leetcode 刷题记录 06 —— 矩阵"
categories: ['未分类']
tags: ['算法', '笔记', '矩阵', '哈希算法', 'Leetcode', 'C']
artid: "146140221"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146140221
    alt: "Leetcode-刷题记录-06-矩阵"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146140221
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146140221
cover: https://bing.ee123.net/img/rand?artid=146140221
image: https://bing.ee123.net/img/rand?artid=146140221
img: https://bing.ee123.net/img/rand?artid=146140221
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Leetcode 刷题记录 06 —— 矩阵
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     本系列为笔者的
     <a href="https://so.csdn.net/so/search?q=Leetcode%20%E5%88%B7%E9%A2%98&amp;spm=1001.2101.3001.7020" title="Leetcode 刷题">
      Leetcode 刷题
     </a>
     记录，顺序为 Hot 100 题官方顺序，根据标签命名，记录笔者总结的做题思路，附部分代码解释和疑问解答。
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h4 id="01%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6" name="01%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6">
     01 矩阵置零
    </h4>
    <p>
     <img alt="" height="38" src="https://i-blog.csdnimg.cn/direct/564c443e83e143809f639b5eeefbd705.png" width="867"/>
    </p>
    <p>
     <img alt="" height="664" src="https://i-blog.csdnimg.cn/direct/031d00a6bbe146d5b44dd36d085f471e.png" width="881"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A0%87%E8%AE%B0%E6%95%B0%E7%BB%84">
     方法一：标记数组
    </h5>
    <p>
     时间复杂度
     <code>
      O(mn)
     </code>
     ，空间复杂度
     <code>
      O(m + n)
     </code>
    </p>
    <ul>
     <li>
      <p>
       建立两个数组
       <code>
        row(m)
       </code>
       和
       <code>
        col(n)
       </code>
       ，存储
       <code>
        matrix
       </code>
       中行和列的含零情况
      </p>
     </li>
     <li>
      <p>
       遍历数组，判断行或列含零，执行
       <code>
        matrix[i][j] = 0
       </code>
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector&lt;int&gt; row(m), col(n);

        for(int i=0; i&lt;m; ++i){
            for(int j=0; j&lt;n; ++j){
                if(!matrix[i][j]){
                    row[i] = true;
                    col[j] = true;
                }
            }
        }

        for(int i=0; i&lt;m; ++i){
            for(int j=0; j&lt;n; ++j){
                if(row[i] || col[j]){
                    matrix[i][j] = 0;
                }
            }
        }
    }
};</code></pre>
    <p>
     ①
     <code>
      vector&lt;int&gt; row(m), col(n);
     </code>
     这俩数组没有初始化啥的吗，它们声明时的默认元素值是多少？
    </p>
    <p>
     使用
     <code>
      vector&lt;int&gt; row(m)
     </code>
     这样的语句声明一个
     <code>
      vector
     </code>
     并指定大小时，
     <code>
      vector
     </code>
     会自动初始化为指定大小的元素，且每个元素默认初始化为零。
    </p>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%A0%87%E8%AE%B0%E5%8F%98%E9%87%8F" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%A0%87%E8%AE%B0%E5%8F%98%E9%87%8F">
     方法二：两个标记变量
    </h5>
    <p>
     时间复杂度
     <code>
      O(mn)
     </code>
     ，空间复杂度
     <code>
      O(1)
     </code>
    </p>
    <ul>
     <li>
      <p>
       建立两个标记
       <code>
        flag_col0
       </code>
       和
       <code>
        flag_row0
       </code>
       ，存储
       <code>
        matrix
       </code>
       中除第零行和第零列的含零情况
      </p>
     </li>
     <li>
      <p>
       遍历数组，判断
       <code>
        !matrix[i][0] || !matrix[0][j]
       </code>
       ，执行
       <code>
        matrix[i][j] = 0
       </code>
      </p>
     </li>
     <li>
      <p>
       第零行和第零列单独更新
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int m = matrix.size(); //一共m行
        int n = matrix[0].size(); //一共n列
        int flag_col0 = false, flag_row0 = false;

        for(int i=0; i&lt;m; ++i){
            if(!matrix[i][0]) flag_col0 = true;
        }
        for(int j=0; j&lt;n; ++j){
            if(!matrix[0][j]) flag_row0 = true;
        }

        //处理大部分元素
        for(int i=1; i&lt;m; ++i){
            for(int j=1; j&lt;n; ++j){
                if(!matrix[i][j]){
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        for(int i=1; i&lt;m; ++i){
            for(int j=1; j&lt;n; ++j){
                if(!matrix[i][0] || !matrix[0][j]) {
                    matrix[i][j] = 0;
                }
            }
        }

        //处理第零行、第零列元素
        if(flag_col0){
            for(int i=0; i&lt;m; ++i){
                matrix[i][0] = 0;
            }
        }
        if(flag_row0){
            for(int j=0; j&lt;n; ++j){
                matrix[0][j] = 0;
            }
        }
    }
};</code></pre>
    <h4 id="02%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5" name="02%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">
     02 螺旋矩阵
    </h4>
    <p>
     <img alt="" height="46" src="https://i-blog.csdnimg.cn/direct/2a6590655d0146b38234f95c9d92a114.png" width="863"/>
    </p>
    <p>
     <img alt="" height="435" src="https://i-blog.csdnimg.cn/direct/3f80deca66d94c66aa44a1e079c6e6a6.png" width="870"/>
    </p>
    <p>
     <img alt="" height="440" src="https://i-blog.csdnimg.cn/direct/09b1f85a644f42a0b06ee983ec4bb1e8.png" width="872"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A8%A1%E6%8B%9F" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A8%A1%E6%8B%9F">
     方法一：模拟
    </h5>
    <p>
     时间复杂度
     <code>
      O(mn)
     </code>
     ，空间复杂度
     <code>
      O(mn)
     </code>
    </p>
    <ul>
     <li>
      <p>
       建立二维数组
       <code>
        visited(rows, vector&lt;bool&gt;(columns)
       </code>
       ，存储矩阵元素的访问情况
      </p>
     </li>
     <li>
      <p>
       遍历矩阵，判断
       <code>
        nextRow
       </code>
       和
       <code>
        nextColumn
       </code>
       是否越过边界
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">class Solution {
public:
    static constexpr int dirs[4][2] = {<!-- -->{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //向右、下、左、上

    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) return {};

        int rows = matrix.size(), columns = matrix[0].size(), total = rows * columns;
        vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(columns)); //标记
        vector&lt;int&gt; order(total); //答案

        int row = 0, column = 0, dirIndex = 0;
        for(int i=0; i&lt;total; i++){
            order[i] = matrix[row][column]; //更新答案
            visited[row][column] = true; //更新标记
            
            int nextRow = row + dirs[dirIndex][0];
            int nextColumn = column + dirs[dirIndex][1];
            if(nextRow &gt;= rows || nextRow &lt; 0 || nextColumn &gt;= columns || nextColumn &lt; 0 || visited[nextRow][nextColumn]){
                dirIndex = (dirIndex + 1) % 4;
            }
            row += dirs[dirIndex][0];
            column += dirs[dirIndex][1];
        }
        return order;
    }
};</code></pre>
    <p>
     ①
     <code>
      static
     </code>
     意味着变量在程序的生命周期内只会被分配一次，并且在所有对该数组的函数调用中共享同一存储空间。
    </p>
    <p>
     ②
     <code>
      constexpr
     </code>
     用于指定变量值在编译时就确定下来，它提示编译器尽量进行优化。
    </p>
    <p>
     ③
     <code>
      {
      <!-- -->
      {0, 1}, {1, 0}, {0, -1}, {-1, 0}}
     </code>
     每一对元素代表在二维平面上一个方向的坐标变换：
    </p>
    <ul>
     <li>
      <p>
       <code>
        {0, 1}
       </code>
       ：代表向右移动 —— 行不变，列加一
      </p>
     </li>
     <li>
      <p>
       <code>
        {1, 0}
       </code>
       ：代表向下移动 —— 行加一，列不变
      </p>
     </li>
     <li>
      <p>
       <code>
        {0, -1}
       </code>
       ：代表向左移动 —— 行不变，列减一
      </p>
     </li>
     <li>
      <p>
       <code>
        {-1, 0}
       </code>
       ：代表向上移动 —— 行减一，列不变
      </p>
     </li>
    </ul>
    <p>
     ④
     <code>
      vector&lt;bool&gt;(columns)
     </code>
     创建一个布尔向量，大小为
     <code>
      columns
     </code>
     ，其中每个元素默认初始化为
     <code>
      false
     </code>
     。
    </p>
    <p>
     ⑤
     <code>
      vector&lt;vector&lt;bool&gt;&gt;(rows, ...)
     </code>
     表示创建一个这样的布尔向量的向量，其长度为
     <code>
      rows
     </code>
     ，即每一行都是一个布尔向量，且每列都是初始化为
     <code>
      false
     </code>
     。
    </p>
    <p>
     ⑥
     <code>
      spiral
     </code>
     螺旋形的
     <code>
      constexpr
     </code>
     常量表达式
    </p>
    <p>
     ⑦ 在什么样的情况下
     <code>
      if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn])
     </code>
     中的
     <code>
      nextRow &lt; 0
     </code>
     成立？
    </p>
    <p>
     由于初始位置是
     <code>
      (0, 0)
     </code>
     且遍历顺序是顺时针螺旋，因此
     <code>
      nextRow &lt; 0
     </code>
     通常在当前方向反转尝试向上之前使用过的路径上被访问时发生。
    </p>
    <p>
     ⑧ 将代码中涉及
     <code>
      nextRow
     </code>
     和
     <code>
      nextColumn
     </code>
     部分的片段改为如下片段如何？
    </p>
    <pre><code class="language-cpp">if((column == (columns - 1)) || (row == (rows - 1)) || (column == 0) || matrix[row + dirs[dirIndex][0]][column + dirs[dirIndex][1]]){
	dirIndex = (dirIndex + 1) % 4;
}</code></pre>
    <p>
     <code>
      matrix[row + dirs[dirIndex][0]][column + dirs[dirIndex][1]]
     </code>
     ：这种方式不仅增加了代码复杂度，并且可能由于超出
     <code>
      matrix
     </code>
     的边界而导致访问无效内存，出现内存错误。
    </p>
    <pre><code class="language-cpp">if (column == columns || row == rows || column == -1 || row == -1 ||
row + dirs[dirIndex][0] &lt; 0 || row + dirs[dirIndex][0] &gt;= rows ||
column + dirs[dirIndex][1] &lt; 0 || column + dirs[dirIndex][1] &gt;= columns || 
visited[row + dirs[dirIndex][0]][column + dirs[dirIndex][1]]) {
dirIndex = (dirIndex + 1) % 4;
}</code></pre>
    <p>
     <code>
      row + dirs[dirIndex][0] &lt; 0
     </code>
     ：检查向当前方向移动后，新的行索引是否小于0。这会保持我们不越过上边界。
    </p>
    <p>
     <code>
      row + dirs[dirIndex][0] &gt;= rows
     </code>
     ：检查向当前方向移动后，新的行索引是否大于或等于总行数。这会确保我们不越过下边界。
    </p>
    <p>
     <code>
      column + dirs[dirIndex][1] &lt; 0
     </code>
     ：检查向当前方向移动后，新的列索引是否小于0。这会确保我们不越过左边界。
    </p>
    <p>
     <code>
      column + dirs[dirIndex][1] &gt;= columns
     </code>
     ：检查向当前方向移动后，新的列索引是否大于或等于总列数。这会确保我们不越过右边界。
    </p>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%8C%89%E5%B1%82%E6%A8%A1%E6%8B%9F" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%8C%89%E5%B1%82%E6%A8%A1%E6%8B%9F">
     方法二：按层模拟
    </h5>
    <p>
     时间复杂度
     <code>
      O(mn)
     </code>
     ，空间复杂度
     <code>
      O(1)
     </code>
    </p>
    <p>
     <img alt="" height="368" src="https://i-blog.csdnimg.cn/direct/9262c23fe44845d6aef47642d1a29ac2.png" width="854"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0) return {};

        vector&lt;int&gt; order;
        int rows = matrix.size(), columns = matrix[0].size();
        int left = 0, right = columns-1, top = 0, bottom = rows-1;
        
        //主打一个遍历
        while(left&lt;=right &amp;&amp; top&lt;=bottom){
            for(int column=left; column&lt;=right; ++column) {
                order.push_back(matrix[top][column]);
            }
            for(int row=top+1; row&lt;=bottom; ++row) {
                order.push_back(matrix[row][right]);
            }
            if(left&lt;right &amp;&amp; top&lt;bottom){
                for(int column=right-1; column&gt;=left+1; --column) {
                order.push_back(matrix[bottom][column]);
                }
                for(int row=bottom; row&gt;=top+1; --row) {
                    order.push_back(matrix[row][left]);
                }
            }
            top++;
            left++;
            right--;
            bottom--;
        }
        return order;
    }
};</code></pre>
    <p>
     ① 为什么还要第二次判断
     <code>
      if(left&lt;right &amp;&amp; top&lt;bottom)
     </code>
     呢？
    </p>
    <p>
     在只有一行或者一列剩下时，第二次顺时针迭代会导致重复元素被添加到结果中。例如，当只剩下一行时，上面的第二次和第三次迭代（从右向左）会和已经处理的行产生重复。比如：
    </p>
    <ul>
     <li>
      <p>
       单行（例如，
       <code>
        [[1, 2, 3]]
       </code>
       ）
      </p>
     </li>
     <li>
      <p>
       单列（例如，
       <code>
        [[1], [2], [3]]
       </code>
       ）
      </p>
     </li>
    </ul>
    <h4 id="03%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F" name="03%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">
     03 旋转图像
    </h4>
    <p>
     <img alt="" height="91" src="https://i-blog.csdnimg.cn/direct/f9b300b77c7e4893bcaeea497b826a5c.png" width="830"/>
    </p>
    <p>
     <img alt="" height="362" src="https://i-blog.csdnimg.cn/direct/c6a60202cecc4717867e919a50891ff8.png" width="881"/>
    </p>
    <p>
     <img alt="" height="377" src="https://i-blog.csdnimg.cn/direct/d6dbabb2c39649b2977d5e85a805a451.png" width="878"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BE%85%E5%8A%A9%E6%95%B0%E7%BB%84" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BE%85%E5%8A%A9%E6%95%B0%E7%BB%84">
     方法一：辅助数组
    </h5>
    <p>
     时间复杂度
     <code>
      O(n^2)
     </code>
     ，空间复杂度
     <code>
      O(n^2)
     </code>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        auto matrix_new = matrix;
        
        int n = matrix.size();
        for(int i=0; i&lt;n; ++i){
            for(int j=0, j&lt;n; ++j){
                matrix_new[j][n-1-i] = matrix[i][j];
            }
        }
        return matrix_new;
    }
};</code></pre>
    <p>
     <code>
      auto matrix_new = matrix;
     </code>
     这行代码的作用是复制
     <code>
      matrix
     </code>
     变量的值到一个新的变量
     <code>
      matrix_new
     </code>
     中，
     <code>
      matrix_new
     </code>
     的类型与
     <code>
      matrix
     </code>
     一致。
    </p>
    <p>
     对于大多数与标准库相关的容器（如
     <code>
      std::vector
     </code>
     ），这会创建
     <code>
      matrix
     </code>
     的一个浅拷贝，整体上是深拷贝其内容，而不是仅仅复制指针（如果它是一个复杂数据结构）。
    </p>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8E%9F%E5%9C%B0%E6%97%8B%E8%BD%AC">
     方法二：原地旋转
    </h5>
    <p>
     时间复杂度
     <code>
      O(n^2)
     </code>
     ，空间复杂度
     <code>
      O(1)
     </code>
    </p>
    <p>
     <img alt="" height="388" src="https://i-blog.csdnimg.cn/direct/f835ff428e474c2abf1b14a38a936080.png" width="1146"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();

        for(int x=0; x&lt;n/2; ++x){
            for(int y=0; y&lt;(n+1)/2; ++y){
                int flag = matrix[x][y];
                matrix[x][y] = matrix[n-1-y][x];
                matrix[n-1-y][x] = matrix[n-1-x][n-1-y];
                matrix[n-1-x][n-1-y] = matrix[y][n-1-x];
                matrix[y][n-1-x] = flag;
            }
        }
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E7%94%A8%E7%BF%BB%E8%BD%AC%E4%BB%A3%E6%9B%BF%E6%97%8B%E8%BD%AC" name="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E7%94%A8%E7%BF%BB%E8%BD%AC%E4%BB%A3%E6%9B%BF%E6%97%8B%E8%BD%AC">
     方法三：用翻转代替旋转
    </h5>
    <p>
     时间复杂度
     <code>
      O(n^2)
     </code>
     ，空间复杂度
     <code>
      O(1)
     </code>
    </p>
    <p>
     <img alt="" height="95" src="https://i-blog.csdnimg.cn/direct/e3a3d41eb06a4f02907af69767af0de9.png" width="873"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();

        for(int x=0; x&lt;n/2; ++x){
            for(int y=0; y&lt;n; ++y){
                swap(matrix[x][y], matrix[n-1-x][y]);
            }
        }

        for(int x=0; x&lt;n; ++x){
            for(int y=0; y&lt;x; ++y){
                swap(matrix[x][y], matrix[y][x]);
            }
        }
    }
};</code></pre>
    <h4 id="04%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20%E2%85%A1" name="04%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20%E2%85%A1">
     04 搜索二维矩阵 Ⅱ
    </h4>
    <p>
     <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/ee8051787487479d8cc52c65fe1d5fb2.png" width="879"/>
    </p>
    <p>
     <img alt="" height="657" src="https://i-blog.csdnimg.cn/direct/c4e0aac56ee44df9922c62f7c24d95e6.png" width="871"/>
    </p>
    <p>
     <img alt="" height="661" src="https://i-blog.csdnimg.cn/direct/fb727f3a1c8a4e87bd27b58ebe277221.png" width="878"/>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%9F%A5%E6%89%BE" name="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%9F%A5%E6%89%BE">
     方法一：直接查找
    </h5>
    <p>
     时间复杂度
     <code>
      O(mn)
     </code>
     ，空间复杂度
     <code>
      O(1)
     </code>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        for(const auto&amp; row: matrix){
            for(int element: row){
                if(element == target) return true;
            }
        }
        return false;
    }
};</code></pre>
    <h5 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BA%8C%E5%88%86%E6%B3%95" name="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BA%8C%E5%88%86%E6%B3%95">
     方法二：二分法
    </h5>
    <p>
     时间复杂度
     <code>
      O(mlogn)
     </code>
     ，空间复杂度
     <code>
      O(1)
     </code>
    </p>
    <pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        for(const auto&amp; row: matrix){
            auto it = lower_bound(row.begin(), row.end(), target);
            if(it != row.end() &amp;&amp; *it == target) return true;
        }
        return false;
    }
};</code></pre>
    <p>
     <code>
      lower_bound
     </code>
     是一个标准库函数，位于
     <code>
      &lt;algorithm&gt;
     </code>
     头文件中，用于在一个已排序的范围内查找目标值的位置。
     <code>
      lower_bound
     </code>
     返回一个迭代器，指向范围内第一个
     <strong>
      不小于
     </strong>
     目标值的元素的位置，如果所有的元素都小于目标值，它将返回指向末尾的迭代器。
    </p>
    <p>
     注意：使用
     <code>
      lower_bound
     </code>
     的前提是
     <code>
      row
     </code>
     必须是排序好的，否则结果是不确定的。
    </p>
    <h5 id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9AZ%E5%AD%97%E5%BD%A2%E6%9F%A5%E6%89%BE" name="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9AZ%E5%AD%97%E5%BD%A2%E6%9F%A5%E6%89%BE">
     方法三：Z字形查找
    </h5>
    <pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int x = 0, y = n-1;
        while(x &lt; m &amp;&amp; y &gt;=0){
            if(matrix[x][y] == target) return true;
            else if(matrix[x][y] &gt; target) y--;
            else x++;
        }
        return false;
    }
};</code></pre>
    <blockquote>
     <p>
      文章部分代码来源于力扣（LeetCode）
     </p>
    </blockquote>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6c616e676f5f4c472f:61727469636c652f64657461696c732f313436313430323231" class_="artid" style="display:none">
 </p>
</div>


