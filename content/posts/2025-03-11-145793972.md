---
layout: post
title: "-爬取动态数据,爬取持久化数据"
date: 2025-03-11 18:05:51 +0800
description: "这篇教程，我们学会了如何将爬取的数据保存到JSONCSV和SQLite数据库中。对于爬虫项目来说，数据存储是一个非常重要的环节，而SQLite提供了一个轻量级的本地数据库，非常适合小型项目的数据持久化需求。"
keywords: " 爬取动态数据，爬取持久化数据"
categories: ['Playwright']
tags: ['集成测试', '测试工具', '单元测试']
artid: "145793972"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145793972
    alt: "-爬取动态数据,爬取持久化数据"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145793972
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145793972
cover: https://bing.ee123.net/img/rand?artid=145793972
image: https://bing.ee123.net/img/rand?artid=145793972
img: https://bing.ee123.net/img/rand?artid=145793972
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     爬取动态数据，爬取持久化数据
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     1. 动态内容与静态内容的区别
    </h2>
    <p>
     动态内容通常指通过
     <code>
      JavaScript
     </code>
     渲染或异步加载的数据。静态内容则是页面加载时直接可见的内容，通常通过
     <code>
      HTML
     </code>
     直接获取。很多现代网站都使用
     <code>
      JavaScript
     </code>
     动态渲染页面内容（例如
     <code>
      AJAX
     </code>
     请求）。
    </p>
    <p>
     头条网站的热榜内容是动态加载的，页面最初只展示一个固定的热榜，而点击“换一换”按钮后，新的热榜内容会通过
     <code>
      JavaScript
     </code>
     异步加载。爬虫需要等待页面加载或等待某个元素（例如热榜内容）出现，才能获取这些数据。
    </p>
    <h2>
     2. 实现步骤
    </h2>
    <p>
     我们将按照以下步骤完成爬取任务：
    </p>
    <ul>
     <li>
      <p>
       • 打开今日头条网站并定位到热榜区域。
      </p>
     </li>
     <li>
      <p>
       • 等待并抓取初始热榜内容。
      </p>
     </li>
     <li>
      <p>
       • 点击“换一换”按钮，刷新热榜内容。
      </p>
     </li>
     <li>
      <p>
       • 等待新内容加载并输出新的热榜数据。
      </p>
     </li>
    </ul>
    <h2>
     3. 代码实现
    </h2>
    <h3>
     3.1 步骤 1：创建
     <code>
      Playwright
     </code>
     脚本
    </h3>
    <p>
     首先，确保你已安装
     <code>
      Playwright
     </code>
     ：
    </p>
    <pre><code>npm install playwright</code></pre>
    <p>
     然后，创建一个
     <code>
      crawler.js
     </code>
     文件，并将以下代码添加到该文件中：
    </p>
    <pre><code class="language-TypeScript">const { chromium } = require('playwright');

(async () =&gt; {
  const browser = await chromium.launch({ headless: true });  // 启动浏览器
  const page = await browser.newPage();  // 新建一个页面

  // 打开今日头条网站
  await page.goto('https://toutiao.com');  

  // 等待热榜区域加载完成
  await page.waitForSelector('.home-hotboard');  // 热榜区域的容器（CSS 选择器）

  // 获取初始的热榜内容
  let hotList = await page.$$eval('.home-hotboard .news-title', items =&gt;
    items.map(item =&gt; item.textContent.trim())  // 获取每个热榜项的文本内容
  );

  console.log('初始热榜内容：');
  console.log(hotList);

  // 点击“换一换”按钮
  const changeButton = await page.$('.refresh');  // 找到“换一换”按钮
  if (changeButton) {
    await changeButton.click();  // 点击按钮刷新热榜
  }

  // 等待新的热榜内容加载完成
  await page.waitForSelector('.home-hotboard');  // 等待热榜区域重新加载

  // 获取刷新后的热榜内容
  hotList = await page.$$eval('.home-hotboard .news-title', items =&gt;
    items.map(item =&gt; item.textContent.trim())  // 获取新热榜项的文本内容
  );

  console.log('刷新后的热榜内容：');
  console.log(hotList);

  await browser.close();  // 关闭浏览器
})();</code></pre>
    <h3>
     3.2 步骤 2：代码解析
    </h3>
    <h4>
     启动浏览器和打开页面
    </h4>
    <pre><code class="language-TypeScript">const browser = await chromium.launch({ headless: true });  // 启动浏览器
const page = await browser.newPage();  // 新建一个页面
await page.goto('https://toutiao.com');  // 打开今日头条网站</code></pre>
    <p>
     这里我们启动了一个无头模式的
     <code>
      Chromium
     </code>
     浏览器并访问了头条网站。
    </p>
    <h4>
     等待热榜加载完成
    </h4>
    <pre><code class="language-TypeScript">await page.waitForSelector('.home-hotboard');  // 等待热榜区域加载完成</code></pre>
    <p>
     我们使用
     <code>
      waitForSelector
     </code>
     等待页面中的 热榜 区域（通过
     <code>
      CSS
     </code>
     选择器
     <code>
      .home-hotboard
     </code>
     ）加载完成。
    </p>
    <h4>
     获取初始热榜内容
    </h4>
    <pre><code class="language-TypeScript">  hotList = await page.$$eval('.home-hotboard .news-title', items =&gt;
  items.map(item =&gt; item.textContent.trim())  // 获取每个热榜项的文本内容
);
console.log('初始热榜内容：');
console.log(hotList);</code></pre>
    <p>
     使用
     <code>
      $$eval
     </code>
     方法，我们选择了热榜区域内的所有
     <code>
      .news-title
     </code>
     元素，并输出它们的文本内容（即热榜的标题）。
    </p>
    <h4>
     点击“换一换”按钮并等待新内容加载
    </h4>
    <pre><code class="language-TypeScript">const changeButton = await page.$('.refresh');  // 找到“换一换”按钮
if (changeButton) {
  await changeButton.click();  // 点击按钮刷新热榜
}

await page.waitForSelector('.home-hotboard');  // 等待热榜区域重新加载</code></pre>
    <h4>
     获取刷新后的热榜内容
    </h4>
    <pre><code class="language-TypeScript">  hotList = await page.$$eval('.home-hotboard .news-title', items =&gt;
  items.map(item =&gt; item.textContent.trim())  // 获取新热榜项的文本内容
);
console.log('刷新后的热榜内容：');
console.log(hotList);</code></pre>
    <p>
     再次使用
     <code>
      $$eval
     </code>
     方法获取刷新后的热榜项内容，并将其输出到控制台。
    </p>
    <h4>
     关闭浏览器
    </h4>
    <pre><code>await browser.close();  // 关闭浏览器</code></pre>
    <h3>
     3.3 步骤 3：代码运行
    </h3>
    <p>
     在终端中运行以下命令来执行脚本：
    </p>
    <pre><code>node crawler.js</code></pre>
    <p>
     运行后，脚本会打印出 初始热榜内容 和 刷新后的热榜内容。
    </p>
    <p>
    </p>
    <h2>
     梳理
    </h2>
    <p>
     通过本教程，你学会了如何使用
     <code>
      Playwright
     </code>
     爬取动态加载的内容。在实际项目中，很多网站的数据都依赖于
     <code>
      JavaScript
     </code>
     动态渲染和异步加载，掌握如何处理这些动态内容，对于编写有效的爬虫非常重要。
    </p>
    <h2>
     4. 数据存储的需求
    </h2>
    <p>
     在爬取数据后，通常会有以下几种存储方式：
    </p>
    <ul>
     <li>
      <p>
       •
       <code>
        JSON
       </code>
       格式：适合存储结构化的数据，并且便于与其他系统交换。
      </p>
     </li>
     <li>
      <p>
       •
       <code>
        CSV
       </code>
       格式：适用于存储表格数据，常用于数据分析和处理。
      </p>
     </li>
     <li>
      <p>
       •
       <code>
        SQLite
       </code>
       数据库：适用于需要长期存储、查询的数据，适合小型的本地数据库需求。
       <br/>
       我们将依次展示如何将爬取的数据保存为
       <code>
        JSON
       </code>
       、
       <code>
        CSV
       </code>
       文件，并将其插入
       <code>
        SQLite
       </code>
       数据库中。
      </p>
     </li>
    </ul>
    <h2>
     5. 完整代码实现
    </h2>
    <h3>
     5.1 环境准备
    </h3>
    <p>
     首先，我们从 头条热榜 爬取数据，并将其分别保存为
     <code>
      JSON
     </code>
     、
     <code>
      CSV
     </code>
     和
     <code>
      SQLite
     </code>
     。首先确保你已经安装了
     <code>
      Playwright
     </code>
     ：
    </p>
    <pre><code>npm install playwright</code></pre>
    <p>
     并且安装了
     <code>
      json2csv
     </code>
     的
     <code>
      Node.js
     </code>
     库：
    </p>
    <pre><code>npm install json2csv</code></pre>
    <p>
     并且安装了
     <code>
      SQLite
     </code>
     的
     <code>
      Node.js
     </code>
     库：
    </p>
    <pre><code>npm install sqlite3</code></pre>
    <p>
     还可以通过以下命令确认是否正确按照
    </p>
    <pre><code>npm list json2csv</code></pre>
    <h3>
     5.2 完整代码
    </h3>
    <pre><code class="language-TypeScript">const { chromium } = require('playwright');
const fs = require('fs');
const { Parser } = require('json2csv');
const sqlite3 = require('sqlite3').verbose();

// 设置最大循环次数，避免无限点击
const MAX_CLICKS = 5;

(async () =&gt; {
  const browser = await chromium.launch({ headless: false });  // 启动浏览器
  const page = await browser.newPage();  // 新建一个页面

  // 打开今日头条网站
  await page.goto('https://toutiao.com');  

  // 等待热榜区域加载完成
  await page.waitForSelector('.home-hotboard');  // 热榜区域的容器（CSS 选择器）

  // 用来记录已经爬取的热榜内容，避免重复
  let allHotList = new Set();

  // 点击“换一换”按钮并获取新的热榜内容
  for (let i = 0; i &lt; MAX_CLICKS; i++) {
    // 获取热榜内容
    let hotList = await page.$$eval('.home-hotboard .news-title', items =&gt;
      items.map(item =&gt; item.textContent.trim())  // 获取每个热榜项的文本内容
    );

    console.log(`第 ${i + 1} 次刷新后的热榜内容：`);
    console.log(hotList);

    // 去重：将本次内容添加到 Set 中，自动去重
    hotList.forEach(item =&gt; allHotList.add(item));

    // 点击“换一换”按钮
    const changeButton = await page.$('.refresh');  // 找到“换一换”按钮
    if (changeButton) {
      await changeButton.click();  // 点击按钮刷新热榜
    }

    // 等待新的热榜内容加载完成
    await page.waitForSelector('.home-hotboard');  // 等待热榜区域重新加载
  }

  // 将去重后的热榜内容转为数组
  allHotList = Array.from(allHotList);

  // 保存到 JSON 文件
  saveToJson(allHotList);

  // 保存到 CSV 文件
  saveToCsv(allHotList);

  // 保存到 SQLite 数据库
  saveToSQLite(allHotList);

  await browser.close();  // 关闭浏览器

})();

// 保存为 JSON 文件
function saveToJson(data) {
  const filePath = './hotlist.json';
  fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');
  console.log(`数据已保存到 ${filePath}`);
}

// 保存为 CSV 文件
function saveToCsv(data) {
  if (data.length === 0) {
    console.log('数据为空，无法保存为 CSV 文件');
    return;
  }

  const filePath = './hotlist.csv';

  // 定义 CSV 文件的字段（列名）
  const fields = ['title'];  // 这里只需要定义一个字段名称，假设每个项是字符串

  const csvParser = new Parser({ fields });

  // 转换数据为 CSV 格式
  const csv = csvParser.parse(data.map(item =&gt; ({ title: item })));  // 将数据转换为对象数组

  // 保存为 CSV 文件
  fs.writeFileSync(filePath, csv, 'utf-8');
  console.log(`数据已保存到 ${filePath}`);
}

// 保存到 SQLite 数据库
function saveToSQLite(data) {
  const db = new sqlite3.Database('./hotlist.db', sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, (err) =&gt; {
    if (err) {
      console.error('数据库打开失败', err);
    } else {
      console.log('数据库打开成功');
    }
  });

  // 创建热榜表（如果不存在的话）
  db.run(`CREATE TABLE IF NOT EXISTS hotlist (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT UNIQUE,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
  )`, (err) =&gt; {
    if (err) {
      console.error('创建表失败', err);
    } else {
      console.log('热榜表已创建或已存在');
    }
  });

  // 插入数据，确保不重复
  const stmt = db.prepare('INSERT OR IGNORE INTO hotlist (title, timestamp) VALUES (?, ?)');
  const currentTimestamp = new Date().toISOString(); // 获取当前时间戳，ISO 格式

  data.forEach((item) =&gt; {
    stmt.run(item, currentTimestamp, (err) =&gt; {
      if (err) {
        console.error('插入数据失败', err);
      } else {
        console.log('插入数据成功', item);
      }
    });
  });
  stmt.finalize();  // 完成插入操作

  // 查询并打印保存的内容
  db.all('SELECT * FROM hotlist', (err, rows) =&gt; {
    if (err) {
      console.error('查询出错:', err);
    } else {
      console.log('从数据库查询到的热榜数据：');
      rows.forEach(row =&gt; {
        console.log(`${row.id}: ${row.title} (时间: ${row.timestamp})`);
      });
    }
  });

  // 关闭数据库连接
  db.close((err) =&gt; {
    if (err) {
      console.error('关闭数据库失败', err);
    } else {
      console.log('数据库连接已关闭');
    }
  });
}</code></pre>
    <h3>
     5.3 代码解析
    </h3>
    <h4>
     爬取头条热榜内容
    </h4>
    <p>
     以上代码使用了之前
     <code>
      Playwright
     </code>
     爬取页面上的热榜内容方法。先等待热榜区域加载完成，然后通过
     <code>
      $eval
     </code>
     获取每个热榜项的文本内容。
    </p>
    <h4>
     保存数据为
     <code>
      json
     </code>
     文件
    </h4>
    <p>
     我们创建了一个名为
     <code>
      saveToJso
     </code>
     n 的函数，将爬取的热榜数据保存为
     <code>
      JSON
     </code>
     格式。我们使用
     <code>
      Node.js
     </code>
     的
     <code>
      fs.writeFileSync
     </code>
     方法将数据写入
     <code>
      hotlist.json
     </code>
     文件。
    </p>
    <h4>
     保存数据为
     <code>
      csv
     </code>
     文件
    </h4>
    <p>
     我们创建了
     <code>
      saveToCsv
     </code>
     函数，将热榜数据保存为
     <code>
      CSV
     </code>
     格式。使用了
     <code>
      json2csv
     </code>
     库，将数据转换为
     <code>
      CSV
     </code>
     格式并保存为
     <code>
      hotlist.csv
     </code>
     文件。
    </p>
    <h4>
     保存数据到
     <code>
      SQLite
     </code>
     数据库
    </h4>
    <p>
     我们创建了
     <code>
      saveToSQLite
     </code>
     函数，将爬取的热榜数据保存到
     <code>
      SQLite
     </code>
     数据库。我们首先使用
     <code>
      sqlite3
     </code>
     库创建数据库文件（如果不存在则创建），然后创建一个名为
     <code>
      hotlist
     </code>
     的表，并将热榜内容插入到该表中。最后，我们查询并打印了数据库中存储的内容。
    </p>
    <h3>
     5.4 代码运行
    </h3>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="1098" src="https://i-blog.csdnimg.cn/img_convert/39cfefed0fe95aab4b0097e9afcfff0b.jpeg" width="359"/>
    </p>
    <p>
     保存输出内容如下
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="图片" height="759" src="https://i-blog.csdnimg.cn/img_convert/498c61cc12176917ab4d67a4062a27ef.jpeg" width="570"/>
    </p>
    <h2>
     总结
    </h2>
    <p>
     这篇教程，我们学会了如何将爬取的数据保存到
     <code>
      JSON
     </code>
     、
     <code>
      CSV
     </code>
     和
     <code>
      SQLite
     </code>
     数据库中。对于爬虫项目来说，数据存储是一个非常重要的环节，而
     <code>
      SQLite
     </code>
     提供了一个轻量级的本地数据库，非常适合小型项目的数据持久化需求。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34363238313531382f:61727469636c652f64657461696c732f313435373933393732" class_="artid" style="display:none">
 </p>
</div>


