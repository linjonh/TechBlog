---
layout: post
title: "算法随笔_73-跳跃游戏"
date: 2025-03-13 11:48:57 +0800
description: "跳跃游戏，动态规划"
keywords: "算法随笔_73: 跳跃游戏"
categories: ['未分类']
tags: ['算法', '数据结构', 'Python']
artid: "146211738"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146211738
    alt: "算法随笔_73-跳跃游戏"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146211738
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146211738
cover: https://bing.ee123.net/img/rand?artid=146211738
image: https://bing.ee123.net/img/rand?artid=146211738
img: https://bing.ee123.net/img/rand?artid=146211738
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     算法随笔_73: 跳跃游戏
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     上一篇:
     <a href="https://blog.csdn.net/m0_70494097/article/details/146201451" title="算法随笔_72: 最大子数组和-CSDN博客">
      算法随笔_72: 最大子数组和-CSDN博客
     </a>
    </p>
    <p>
     =====
    </p>
    <p>
     题目描述如下:
    </p>
    <p>
     给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
    </p>
    <p>
     判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
    </p>
    <p>
     示例 1：
    </p>
    <p>
     输入：nums = [2,3,1,1,4]
     <br/>
     输出：true
     <br/>
     解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
    </p>
    <p>
     =====
    </p>
    <p>
     算法思路:
    </p>
    <p>
     某个元素 i 能否到达最后一个元素，取决于在元素i 的最大长度范围内是否有可到达最后一个元素的元素j。从中我们可以发现如下的递推关系:
    </p>
    <p>
     我们设res数组，res[i]表示元素 i 是否能到达最后一个元素，其值为true或false。那么
    </p>
    <p>
     res[i] = res[i+1]
     <strong>
      or
     </strong>
     res[i+2]
     <strong>
      or
     </strong>
     ...... res[i+nums[i]]
    </p>
    <p>
     此公式表示只要有一个为真，res[i]即为真。如果都为假，res[i]为假。
    </p>
    <p>
     但如果我们依次判断nums[i]范围内的元素 i+1，i+2等等，效率较为低下。我们可以通过以下方式解决:
    </p>
    <p>
     我们从右往左遍历原数组，并维护一个离元素0最近的索引 j，它的res[j]为真，我们设其为near。near的初始值为n-1。
    </p>
    <p>
     当遍历到元素 i 时，如果nums[i]的最大长度范围包括了near，那res[i]就为真，否则为假。
    </p>
    <p>
     实际编写代码时，可以完全不需要res数组，只需要维护near变量即可。遍历完成后，如果near等于0，说明能够到达，否则不能到达。
    </p>
    <p>
     时间复杂度O(n)，下面是Python代码实现:
    </p>
    <pre><code class="hljs">class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        n=len(nums)
        near=n-1
        for i in range(n-2,-1,-1):
            if nums[i]+i&gt;= near:
                near=i
        res=True if near==0 else False
        return res</code></pre>
    <p>
     关键词: 动态规划
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37303439343039372f:61727469636c652f64657461696c732f313436323131373338" class_="artid" style="display:none">
 </p>
</div>


