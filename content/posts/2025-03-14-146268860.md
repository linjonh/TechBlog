---
layout: post
title: "SecsGem第一讲基于secs4net项目的ChatGpt介绍"
date: 2025-03-14 22:48:47 +0800
description: "基于github上的secs4net的源码，让chatgpt以此为基础，介绍secs/gem"
keywords: "Secs/Gem第一讲(基于secs4net项目的ChatGpt介绍)"
categories: ['未分类']
tags: ['Secs', 'C']
artid: "146268860"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146268860
    alt: "SecsGem第一讲基于secs4net项目的ChatGpt介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146268860
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146268860
cover: https://bing.ee123.net/img/rand?artid=146268860
image: https://bing.ee123.net/img/rand?artid=146268860
img: https://bing.ee123.net/img/rand?artid=146268860
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Secs/Gem第一讲(基于secs4net项目的ChatGpt介绍)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <hr/>
    <blockquote>
     <p>
      后续内容为基于github上secs4net项目源码的ChatGpt介绍
      <br/>
      以该项目为主，从零开始介绍讲解secs/gem，更多的以面试口吻讲述形式。
      <br/>
      主要为个人学习，提升使用
     </p>
    </blockquote>
    <h2>
     <a id="_SECSGEM__6">
     </a>
     🎓 第一讲：SECS/GEM 协议是个什么东西？
    </h2>
    <h3>
     <a id="__1_SECSGEM__8">
     </a>
     📌 第 1 段：SECS/GEM 是谁？它在哪些场合出现？
    </h3>
    <hr/>
    <h4>
     <a id="__12">
     </a>
     🎙️ 口述稿（你面试时可以这样说）：
    </h4>
    <blockquote>
     <p>
      SECS/GEM 协议是半导体行业的通信标准，它解决的是“设备”和“主机系统”之间
      <strong>
       如何说话、怎么互相理解命令和数据
      </strong>
      的问题。
      <br/>
      SECS 是 Semi Equipment Communication Standard 的缩写，而 GEM 是 Generic Equipment Model。
      <br/>
      这两个协议加起来，定义了一个统一的规则：包括
      <strong>
       数据格式、命令格式、通讯流程、事件结构
      </strong>
      等等，
      <br/>
      这样不管厂里用的是哪家设备厂的设备，只要支持 SECS/GEM，就能接入 EAP 或 MES 系统，做到标准化、自动化的联机控制。
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="__21">
     </a>
     📚 技术知识点解释（你真的要懂的）：
    </h4>
    <h5>
     <a id="_1_SECS__23">
     </a>
     📌 1. SECS 是什么？
    </h5>
    <p>
     SECS 是
     <strong>
      SEMI 协会（国际半导体设备材料协会）
     </strong>
     制定的一套通信标准。
     <br/>
     它专门为半导体行业设计，目标是让设备和工厂系统之间能像人和人之间说英语一样，有一个通用语言。
    </p>
    <h5>
     <a id="_2_SECSGEM__vs__28">
     </a>
     📌 2. SECS/GEM 的通信模型（设备 vs 主机）：
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        主体
       </th>
       <th>
        角色
       </th>
       <th>
        举例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        主机 Host
       </td>
       <td>
        控制者
       </td>
       <td>
        EAP、MES、Fab系统
       </td>
      </tr>
      <tr>
       <td>
        设备 Equipment
       </td>
       <td>
        被控制方
       </td>
       <td>
        Tester、Handler、Probe、Laser Mark
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     它是一个典型的“
     <strong>
      主从结构
     </strong>
     ”：主机发命令、设备执行，设备汇报状态，主机处理反馈。
    </p>
    <hr/>
    <h4>
     <a id="_3_SECS__39">
     </a>
     📌 3. SECS 有两个主要的物理实现方式：
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        名称
       </th>
       <th>
        协议
       </th>
       <th>
        接口方式
       </th>
       <th>
        描述
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        SECS-I
       </td>
       <td>
        RS-232 串口
       </td>
       <td>
        串口连接
       </td>
       <td>
        老设备常用，慢
       </td>
      </tr>
      <tr>
       <td>
        HSMS
       </td>
       <td>
        TCP/IP Socket
       </td>
       <td>
        网络连接
       </td>
       <td>
        新设备常用，快且稳定
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     现在主流基本都采用 HSMS 协议，因为设备数量多、实时性强，串口已经远远不够用了。
    </p>
    <hr/>
    <h4>
     <a id="_4_GEM__50">
     </a>
     🧩 4. GEM 是干嘛的？
    </h4>
    <p>
     GEM 是在 SECS 之上定义的一套“应用层行为规范”。
     <br/>
     它规定了哪些功能是设备
     <strong>
      必须要支持的
     </strong>
     ，比如：
    </p>
    <ul>
     <li>
      联机/脱机（Online/Offline）
     </li>
     <li>
      报警汇报（Alarm Report）
     </li>
     <li>
      状态报告（Status Report）
     </li>
     <li>
      事件定义和触发（Event Report）
     </li>
     <li>
      执行命令（Remote Command）
     </li>
     <li>
      设备识别（S1F1/S1F2）
     </li>
     <li>
      Trace（参数跟踪）
     </li>
    </ul>
    <p>
     <strong>
      你可以理解为：SECS 是语言，GEM 是语法 + 句型结构 + 使用规范
     </strong>
     <br/>
     👉 没有 GEM，大家虽然讲 SECS，但各讲各的；有了 GEM，才实现了“说得标准、听得懂”。
    </p>
    <hr/>
    <h4>
     <a id="__SECSGEM_68">
     </a>
     🏭 为什么半导体厂商都要求支持 SECS/GEM？
    </h4>
    <p>
     因为生产环节需要精确控制、追溯和自动化：
    </p>
    <ul>
     <li>
      设备运行状态要实时汇报（比如 Probe 机什么时候开始测试？有没有测试失败？）
     </li>
     <li>
      每一个晶圆、每一个 Lot 的操作都必须被记录（Track &amp; Trace）
     </li>
     <li>
      工程师要远程下达命令（Remote Start/Stop/Recipe Change）
     </li>
    </ul>
    <p>
     如果设备不支持 SECS/GEM，就只能人工操作和手动记录，效率低，错误率高，良率不可控。
    </p>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第一段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      SECS 是“设备-主机”之间的通用语言。
     </li>
     <li>
      它分为 SECS-I（串口）和 HSMS（TCP/IP）。
     </li>
     <li>
      GEM 是在 SECS 上定义的行为规范，规定了设备必须支持的功能。
     </li>
     <li>
      半导体厂选择 SECS/GEM，是为了让设备能
      <strong>
       标准化接入
      </strong>
      自动化系统，实现远程控制、状态追踪、良率管理。
     </li>
    </ul>
    <hr/>
    <p>
     如果你准备好了，我来发下一段：
    </p>
    <blockquote>
     <p>
      第二段：
      <strong>
       SECS 报文长什么样？Stream、Function 是怎么编号的？SECS 的报文格式结构到底是啥？
      </strong>
     </p>
    </blockquote>
    <p>
     等你说“继续”，我就开讲 📖
    </p>
    <p>
     太好，马上来！这是第一讲的【第 2 段】：
    </p>
    <hr/>
    <h2>
     <a id="___2SECS_Stream__Function__99">
     </a>
     🎓 第一讲 · 第2段：SECS 报文长什么样？Stream / Function 是啥？
    </h2>
    <blockquote>
     <p>
      （这是报文结构入门，面试很爱问，也很容易考住人）
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="__105">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      SECS 报文的核心概念是 Stream 和 Function，它们类似于一个
      <strong>
       命令编号体系
      </strong>
      ，每个 Stream 表示一个分类，而 Function 表示这个分类下的具体命令。
      <br/>
      举个例子，S1F1 是设备识别请求，S1F2 是对应的回应。S6F11 是事件通知，S6F12 是确认回应。这个配对的关系就是一问一答。
     </p>
     <p>
      报文的结构分为 Header 和 Body，Header 是固定长度的10个字节，用于标识通信信息；Body 是变长，用来承载你要发送的数据，比如设备ID、Alarm代码、Wafer ID等。
     </p>
     <p>
      报文可以是 Request，也可以是 Response，还有一种是设备主动发的，比如事件通知或报警，这类叫 Unsolicited Message。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="_0_116">
     </a>
     📚 技术讲解（从0讲到你能画图）
    </h3>
    <hr/>
    <h4>
     <a id="_1__120">
     </a>
     📌 1. 报文结构分成两部分：
    </h4>
    <pre><code class="prism language-text">+------------------+------------------+
|      Header      |       Body       |
|   固定10字节     |     可变长度     |
+------------------+------------------+
</code></pre>
    <hr/>
    <h4>
     <a id="_Header_10__131">
     </a>
     📦 Header（头部，固定 10 字节）结构说明：
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        字节数
       </th>
       <th>
        名称
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        4 字节
       </td>
       <td>
        Message Length
       </td>
       <td>
        Body 的长度（不含 Header）
       </td>
      </tr>
      <tr>
       <td>
        4 字节
       </td>
       <td>
        System Bytes
       </td>
       <td>
        主机和设备之间标识配对的请求-回应
       </td>
      </tr>
      <tr>
       <td>
        1 字节
       </td>
       <td>
        Stream
       </td>
       <td>
        流号：表示消息类别
       </td>
      </tr>
      <tr>
       <td>
        1 字节
       </td>
       <td>
        Function
       </td>
       <td>
        功能号：表示具体的操作
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     （部分实现会把 Stream 和 Function 组成一个完整的 Command，如 S6F11）
    </p>
    <h5>
     <a id="_Stream_142">
     </a>
     🔹 Stream（流）常见编号含义：
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        编号
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        S1
       </td>
       <td>
        Equipment Status Request（状态）
       </td>
      </tr>
      <tr>
       <td>
        S2
       </td>
       <td>
        Host Command（控制命令）
       </td>
      </tr>
      <tr>
       <td>
        S5
       </td>
       <td>
        Alarm Related（报警）
       </td>
      </tr>
      <tr>
       <td>
        S6
       </td>
       <td>
        Data Collection（事件/报告）
       </td>
      </tr>
      <tr>
       <td>
        S7
       </td>
       <td>
        Recipe Related（程式）
       </td>
      </tr>
      <tr>
       <td>
        S9
       </td>
       <td>
        Error Message（异常）
       </td>
      </tr>
      <tr>
       <td>
        S10
       </td>
       <td>
        Terminal Display（日志）
       </td>
      </tr>
      <tr>
       <td>
        S14
       </td>
       <td>
        File Transfer（文件传输）
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     <a id="_Function_155">
     </a>
     🔹 Function（功能）常见示例：
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        编号
       </th>
       <th>
        含义
       </th>
       <th>
        备注
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        F1
       </td>
       <td>
        Request
       </td>
       <td>
        发起方请求
       </td>
      </tr>
      <tr>
       <td>
        F2
       </td>
       <td>
        Response
       </td>
       <td>
        对 F1 的回应
       </td>
      </tr>
      <tr>
       <td>
        F3
       </td>
       <td>
        Set
       </td>
       <td>
        主机设置设备数据
       </td>
      </tr>
      <tr>
       <td>
        F5
       </td>
       <td>
        Get
       </td>
       <td>
        主机获取设备数据
       </td>
      </tr>
      <tr>
       <td>
        F6
       </td>
       <td>
        Get Response
       </td>
       <td>
        对 F5 的回应
       </td>
      </tr>
      <tr>
       <td>
        F11
       </td>
       <td>
        Event Report
       </td>
       <td>
        事件通知（设备主动发）
       </td>
      </tr>
      <tr>
       <td>
        F12
       </td>
       <td>
        Acknowledge
       </td>
       <td>
        对事件的回应
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_System_Bytes__169">
     </a>
     🧩 System Bytes 是干嘛的？
    </h4>
    <p>
     它是一种“配对码”，防止通信过程中混淆。
     <br/>
     比如主机发了一个请求，设备回应的时候，必须带回原来的 System Bytes，主机才能知道“你这是回应我刚才的哪一条消息”。
    </p>
    <p>
     System Bytes 是 4 字节，通常由主机生成，设备照单返回。
     <br/>
     你可以理解为“信件编号 + 回信编号”。
    </p>
    <hr/>
    <h4>
     <a id="_Body__179">
     </a>
     📦 Body 是怎么组织的？
    </h4>
    <p>
     SECS 报文的 Body 实际上是一个
     <strong>
      树形结构
     </strong>
     ，叫做 List-based encoding。
     <br/>
     它的格式可以用一个东西来描述：
     <strong>
      SML（SEMI Message Language）
     </strong>
     ，后面我们会深入讲这个。
    </p>
    <p>
     一个简单的 Body 示例如下（S6F11）：
    </p>
    <pre><code class="prism language-sml">&lt;S6F11&gt;
  &lt;L [2]&gt;
    &lt;U2&gt; 1001 &lt;/U2&gt;       // CEID: 事件号
    &lt;L [1]&gt;
      &lt;L [2]&gt;
        &lt;U2&gt; 2001 &lt;/U2&gt;   // Report ID
        &lt;L [2]&gt;
          &lt;A&gt; Lot123 &lt;/A&gt; // 参数1：批次号
          &lt;A&gt; PASS &lt;/A&gt;   // 参数2：测试结果
        &lt;/L&gt;
      &lt;/L&gt;
    &lt;/L&gt;
  &lt;/L&gt;
&lt;/S6F11&gt;
</code></pre>
    <p>
     这段报文的含义是：
    </p>
    <ul>
     <li>
      我是一个“事件通知”报文（S6F11）
     </li>
     <li>
      我告诉你事件号是 1001（CEID）
     </li>
     <li>
      我附带一个报告（Report ID = 2001），这个报告里有两个参数（Lot编号 + 测试结果）
     </li>
    </ul>
    <p>
     这个结构本质上是树状嵌套的 List 和基本数据类型（U2、A、I4、B…）
    </p>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第二段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      SECS 报文 = Header + Body，Header 固定 10 字节。
     </li>
     <li>
      Header 中 Stream/Function 代表消息类型，配对组成命令（如 S6F11）。
     </li>
     <li>
      Body 是嵌套结构，用 SML 语法描述，类似 JSON。
     </li>
     <li>
      System Bytes 是“配对编号”，确保回应消息准确对应请求。
     </li>
     <li>
      报文可以是 Request（主机发）、Response（设备回）、Unsolicited（设备主动上报）。
     </li>
    </ul>
    <hr/>
    <p>
     准备好就说“继续”，我将送上第三段：
    </p>
    <blockquote>
     <p>
      <strong>
       SML 是什么？为什么是树？为什么不用 JSON？怎么在代码中写出 SML 报文？secs4net 是如何解析这些结构的？
      </strong>
     </p>
    </blockquote>
    <p>
     好的！现在进入第一讲【第 3 段】：
    </p>
    <hr/>
    <h2>
     <a id="___3SML__SECSGEM__231">
     </a>
     🎓 第一讲 · 第3段：SML 是什么？为什么 SECS/GEM 报文是树状结构？
    </h2>
    <blockquote>
     <p>
      这一节我们要搞懂：
     </p>
     <ul>
      <li>
       **SML（SEMI Message Language）**是啥？
      </li>
      <li>
       为什么 SECS/GEM 报文不是 JSON，而是树结构？
      </li>
      <li>
       SML 的基本语法 &amp; 常见数据类型
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__241">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      在 SECS/GEM 里，我们需要描述
      <strong>
       设备状态、数据、事件
      </strong>
      等信息，但 JSON 或 XML 这些格式都不是标准的，因此 SECS/GEM 定义了一种专门的表示方式，叫做
      <strong>
       SML（SEMI Message Language）
      </strong>
      。
     </p>
     <p>
      SML 采用
      <strong>
       嵌套 List 结构
      </strong>
      ，本质上是一棵树，能够清晰地表达层级关系。
     </p>
     <p>
      例如，一个 S6F11 事件通知报文可以表示为：
     </p>
     <pre><code class="prism language-sml">&lt;S6F11&gt;
  &lt;L [2]&gt;
    &lt;U2&gt; 1001 &lt;/U2&gt;       // CEID: 事件号
    &lt;L [1]&gt;
      &lt;L [2]&gt;
        &lt;U2&gt; 2001 &lt;/U2&gt;   // Report ID
        &lt;L [2]&gt;
          &lt;A&gt; Lot123 &lt;/A&gt; // 批次号
          &lt;A&gt; PASS &lt;/A&gt;   // 测试结果
        &lt;/L&gt;
      &lt;/L&gt;
    &lt;/L&gt;
  &lt;/L&gt;
&lt;/S6F11&gt;
</code></pre>
     <p>
      这里
      <code>
       &lt;L [2]&gt;
      </code>
      代表一个包含 2 个元素的 List，类似 JSON 的数组。
      <br/>
      <code>
       &lt;A&gt;
      </code>
      是 ASCII，
      <code>
       &lt;U2&gt;
      </code>
      是无符号 2 字节整数。
      <br/>
      这种格式保证了
      <strong>
       数据结构稳定，不依赖额外的 Schema 解析
      </strong>
      。
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="__JSON_SML_272">
     </a>
     📚 为什么不用 JSON，而要用 SML？
    </h4>
    <p>
     📌
     <strong>
      1. SML 是二进制协议，解析快
     </strong>
    </p>
    <ul>
     <li>
      JSON 是文本格式，占用空间大，解析慢。
     </li>
     <li>
      SECS/GEM 传输的是
      <strong>
       二进制格式
      </strong>
      ，比 JSON 高效。
     </li>
    </ul>
    <p>
     📌
     <strong>
      2. 层级结构清晰，适合表达复杂数据
     </strong>
    </p>
    <ul>
     <li>
      SECS 里的数据往往是树状的，比如：
      <ul>
       <li>
        一个事件（S6F11）可能包含多个报告（Report）
       </li>
       <li>
        每个报告里可能有多个参数
       </li>
       <li>
        这些参数的类型可能不一样（字符串、整数、布尔值）
       </li>
      </ul>
     </li>
     <li>
      SML 的 List 结构天然适合表达这类数据。
     </li>
    </ul>
    <p>
     📌
     <strong>
      3. SECS/GEM 早于 JSON 诞生
     </strong>
    </p>
    <ul>
     <li>
      SECS/GEM 诞生于 1980s，而 JSON 在 2000 年才流行。
     </li>
     <li>
      当时行业已经广泛使用 SML，不可能推翻重做。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_SML____294">
     </a>
     🧩 SML 的基本语法 &amp; 常见数据类型：
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        语法
       </th>
       <th>
        说明
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        List
       </td>
       <td>
        <code>
         &lt;L [N]&gt; ... &lt;/L&gt;
        </code>
       </td>
       <td>
        表示一个包含 N 个元素的列表
       </td>
       <td>
        <code>
         &lt;L [2]&gt; &lt;U2&gt; 1001 &lt;/U2&gt; &lt;A&gt; PASS &lt;/A&gt; &lt;/L&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        ASCII
       </td>
       <td>
        <code>
         &lt;A&gt; ... &lt;/A&gt;
        </code>
       </td>
       <td>
        代表字符串
       </td>
       <td>
        <code>
         &lt;A&gt; Lot123 &lt;/A&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Binary
       </td>
       <td>
        <code>
         &lt;B&gt; ... &lt;/B&gt;
        </code>
       </td>
       <td>
        代表二进制数据
       </td>
       <td>
        <code>
         &lt;B&gt; 0A 1F 2C &lt;/B&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Boolean
       </td>
       <td>
        <code>
         &lt;BOOL&gt; ... &lt;/BOOL&gt;
        </code>
       </td>
       <td>
        代表布尔值（TRUE/FALSE）
       </td>
       <td>
        <code>
         &lt;BOOL&gt; TRUE &lt;/BOOL&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Unsigned Integer
       </td>
       <td>
        <code>
         &lt;U1&gt;
        </code>
        <code>
         &lt;U2&gt;
        </code>
        <code>
         &lt;U4&gt;
        </code>
        <code>
         &lt;U8&gt;
        </code>
       </td>
       <td>
        无符号整数，分别占 1/2/4/8 字节
       </td>
       <td>
        <code>
         &lt;U2&gt; 3001 &lt;/U2&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Integer
       </td>
       <td>
        <code>
         &lt;I1&gt;
        </code>
        <code>
         &lt;I2&gt;
        </code>
        <code>
         &lt;I4&gt;
        </code>
        <code>
         &lt;I8&gt;
        </code>
       </td>
       <td>
        有符号整数
       </td>
       <td>
        <code>
         &lt;I4&gt; -100 &lt;/I4&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        Float
       </td>
       <td>
        <code>
         &lt;F4&gt;
        </code>
        <code>
         &lt;F8&gt;
        </code>
       </td>
       <td>
        4 字节 / 8 字节浮点数
       </td>
       <td>
        <code>
         &lt;F4&gt; 3.14 &lt;/F4&gt;
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_SML__308">
     </a>
     🛠️ SML 在代码中怎么用？
    </h4>
    <p>
     在
     <code>
      secs4net
     </code>
     这个库里，SML 是通过
     <strong>
      <code>
       SecMessage
      </code>
      +
      <code>
       Item
      </code>
      对象
     </strong>
     来构建的。
     <br/>
     我们可以用 C# 代码手动创建一条
     <strong>
      S6F11 事件报文
     </strong>
     ：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Item<span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{<!-- --></span>
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// CEID 事件号</span>
        Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
            Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
                Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// Report ID</span>
                Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
                    Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"Lot123"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 批次号</span>
                    Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"PASS"</span><span class="token punctuation">)</span> <span class="token comment">// 测试结果</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     这段代码等价于我们上面的 SML：
    </p>
    <pre><code class="prism language-sml">&lt;S6F11&gt;
  &lt;L [2]&gt;
    &lt;U2&gt; 1001 &lt;/U2&gt;
    &lt;L [1]&gt;
      &lt;L [2]&gt;
        &lt;U2&gt; 2001 &lt;/U2&gt;
        &lt;L [2]&gt;
          &lt;A&gt; Lot123 &lt;/A&gt;
          &lt;A&gt; PASS &lt;/A&gt;
        &lt;/L&gt;
      &lt;/L&gt;
    &lt;/L&gt;
  &lt;/L&gt;
&lt;/S6F11&gt;
</code></pre>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第三段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       SML 是 SECS/GEM 专用的报文格式
      </strong>
      ，它采用二进制 List 结构，比 JSON 高效。
     </li>
     <li>
      <strong>
       SECS/GEM 采用 SML 而不是 JSON，原因是历史早、解析快、适合层级数据
      </strong>
      。
     </li>
     <li>
      <strong>
       SML 的数据类型包括 L（List）、A（ASCII）、U/I（整数）、F（浮点）、B（二进制）
      </strong>
      。
     </li>
     <li>
      <strong>
       在 C# 代码里，我们可以用
       <code>
        Item.L()
       </code>
       这种方式手动构造 SML 报文
      </strong>
      。
     </li>
    </ul>
    <hr/>
    <p>
     🔥
     <strong>
      接下来，第四段内容是：
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       HSMS 是怎么保证通讯稳定的？HSMS 的消息流程是啥？SECS4NET 里是如何实现 TCP 连接的？
      </strong>
     </p>
    </blockquote>
    <p>
     如果你准备好了，就说“继续”！
    </p>
    <p>
     好嘞，马上进入第一讲【第 4 段】：
    </p>
    <hr/>
    <h2>
     <a id="___4HSMS_SECS4NET__371">
     </a>
     🎓 第一讲 · 第4段：HSMS 是如何通信的？SECS4NET 是如何实现连接的？
    </h2>
    <blockquote>
     <p>
      这一段我们来拆解：
     </p>
     <ul>
      <li>
       HSMS 协议是干嘛的？它和 SECS 的关系？
      </li>
      <li>
       HSMS 的连接流程是怎样的？
      </li>
      <li>
       SECS4NET 底层是怎么实现连接和通信的？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__381">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      在半导体工厂里，SECS 协议是负责
      <strong>
       定义数据结构和命令内容
      </strong>
      的，而 HSMS 协议则是负责
      <strong>
       把这些命令怎么发出去、怎么接收回来
      </strong>
      。
      <br/>
      可以说，
      <strong>
       SECS 是内容，HSMS 是通道
      </strong>
      。
     </p>
     <p>
      HSMS 其实就是基于 TCP 的一种通信协议，专门为 SECS 服务设计的，稳定、双向、支持异步传输。
     </p>
     <p>
      在连接流程上，HSMS 分为两端：
      <strong>
       设备端叫 Passive（被动方）
      </strong>
      ，
      <strong>
       主机端叫 Active（主动方）
      </strong>
      ，像 Socket 编程中的 server/client。
     </p>
     <p>
      连接建立后，会交换几个系统消息，比如 Select.req、Select.rsp，用来确认连接合法、状态正常。
     </p>
     <p>
      而 SECS4NET 这个库，正是封装了这一整套流程，我们不用自己写 Socket，它就能在后台自动维持连接，重连机制也有，适合工业级应用。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="__HSMS_396">
     </a>
     📚 技术讲解：什么是 HSMS？
    </h3>
    <hr/>
    <h4>
     <a id="_SECS_HSMS__400">
     </a>
     📌 SECS 是什么？HSMS 是什么？
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        名称
       </th>
       <th>
        全称
       </th>
       <th>
        作用
       </th>
       <th>
        传输层
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        SECS-I
       </td>
       <td>
        SECS over RS232
       </td>
       <td>
        早期串口通信协议
       </td>
       <td>
        串口
       </td>
      </tr>
      <tr>
       <td>
        HSMS
       </td>
       <td>
        High Speed SECS Message Services
       </td>
       <td>
        新一代高速通信协议
       </td>
       <td>
        TCP
       </td>
      </tr>
      <tr>
       <td>
        SECS-II
       </td>
       <td>
        SEMI Equipment Communications Standard (Part II)
       </td>
       <td>
        报文格式 &amp; 内容规范
       </td>
       <td>
        协议内容层
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     简而言之：
    </p>
    <ul>
     <li>
      SECS-I：串口版本的 SECS，速度慢
     </li>
     <li>
      HSMS：TCP/IP 网络版的 SECS，更快更稳定
     </li>
     <li>
      SECS-II：通用的数据结构和报文语法
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_HSMS__416">
     </a>
     🔄 HSMS 的通信过程（官方定义）
    </h4>
    <ol>
     <li>
      <strong>
       TCP连接阶段
      </strong>
      <ul>
       <li>
        Active（主机）发起连接到 Passive（设备）
       </li>
       <li>
        TCP 成功建立后，双方进入 HSMS 层
       </li>
      </ul>
     </li>
     <li>
      <strong>
       HSMS 握手阶段
      </strong>
      <ul>
       <li>
        Active 发起
        <code>
         Select.req
        </code>
       </li>
       <li>
        Passive 回复
        <code>
         Select.rsp
        </code>
        表示同意连接
       </li>
      </ul>
     </li>
     <li>
      <strong>
       通信阶段
      </strong>
      <ul>
       <li>
        双方可以任意方向发送 SECS 报文（SxFx）
       </li>
       <li>
        报文封装在 HSMS Message Frame 中传输
       </li>
      </ul>
     </li>
     <li>
      <strong>
       断开阶段
      </strong>
      <ul>
       <li>
        任一方可以发送
        <code>
         Separate.req
        </code>
        断开连接
       </li>
       <li>
        或者网络异常导致连接中断
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_HSMS_Message_Type_433">
     </a>
     ⚙️ HSMS 消息类型（Message Type）
    </h4>
    <p>
     HSMS 并非只传业务数据，还定义了一些控制消息：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        Msg Type
       </th>
       <th>
        含义
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        0x01
       </td>
       <td>
        Select.req
       </td>
       <td>
        请求连接
       </td>
      </tr>
      <tr>
       <td>
        0x02
       </td>
       <td>
        Select.rsp
       </td>
       <td>
        响应连接
       </td>
      </tr>
      <tr>
       <td>
        0x03
       </td>
       <td>
        Deselect.req
       </td>
       <td>
        请求断开连接
       </td>
      </tr>
      <tr>
       <td>
        0x04
       </td>
       <td>
        Deselect.rsp
       </td>
       <td>
        响应断开
       </td>
      </tr>
      <tr>
       <td>
        0x05
       </td>
       <td>
        Linktest.req
       </td>
       <td>
        心跳检测
       </td>
      </tr>
      <tr>
       <td>
        0x06
       </td>
       <td>
        Linktest.rsp
       </td>
       <td>
        心跳回应
       </td>
      </tr>
      <tr>
       <td>
        0x07
       </td>
       <td>
        Reject.req
       </td>
       <td>
        拒绝连接
       </td>
      </tr>
      <tr>
       <td>
        0x09
       </td>
       <td>
        Separate.req
       </td>
       <td>
        主动断开连接
       </td>
      </tr>
      <tr>
       <td>
        0x10
       </td>
       <td>
        Data Message
       </td>
       <td>
        正式的 SECS 报文（如 S1F1、S6F11）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_SECS4NET__451">
     </a>
     🧰 SECS4NET 是怎么封装这些内容的？
    </h4>
    <p>
     在 SECS4NET 中，有两个核心类：
    </p>
    <ul>
     <li>
      <code>
       SecsGem
      </code>
      ：表示 SECS/GEM 的服务端或客户端
     </li>
     <li>
      <code>
       SecsMessage
      </code>
      ：表示一个 SxFx 报文消息
     </li>
    </ul>
    <p>
     你只要这样初始化：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> gem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsGem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">HSMSSettings</span>
<span class="token punctuation">{<!-- --></span>
    IpAddress <span class="token operator">=</span> <span class="token string">"192.168.1.100"</span><span class="token punctuation">,</span>
    Port <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">,</span>
    Mode <span class="token operator">=</span> ConnectionMode<span class="token punctuation">.</span>Active<span class="token punctuation">,</span>
    DeviceId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment">// 其他参数...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     然后连接建立后，你就可以直接：
    </p>
    <pre><code class="prism language-csharp"><span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     SECS4NET 会在内部自动：
    </p>
    <ul>
     <li>
      建 TCP 连接
     </li>
     <li>
      发 Select.req
     </li>
     <li>
      保持 Linktest
     </li>
     <li>
      自动重连
     </li>
     <li>
      收发 SECS 报文并解析成
      <code>
       SecsMessage
      </code>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="__487">
     </a>
     ☁️ 稳定性保障机制（面试重点）
    </h4>
    <ul>
     <li>
      <strong>
       KeepAlive / 心跳机制：
      </strong>
      使用
      <code>
       Linktest.req/resp
      </code>
      检测连接活性
     </li>
     <li>
      <strong>
       Reconnect 自动重连：
      </strong>
      网络掉线后自动尝试重连
     </li>
     <li>
      <strong>
       异步消息处理：
      </strong>
      不阻塞主线程，使用
      <code>
       async/await
      </code>
      保证性能
     </li>
    </ul>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第四段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      HSMS 是 SECS 的传输协议，基于 TCP，比串口的 SECS-I 高效可靠
     </li>
     <li>
      通信过程包括连接（Select）、传输（Data）、断开（Separate）
     </li>
     <li>
      SECS4NET 封装了整个连接逻辑，开发者只需关注业务逻辑
     </li>
     <li>
      心跳、自动重连、异步收发都是工业级通信必须考虑的问题
     </li>
    </ul>
    <hr/>
    <p>
     <strong>
      下一段（第五段）将讲解：
     </strong>
    </p>
    <blockquote>
     <p>
      <strong>
       SECS4NET 的事件订阅机制是怎么做的？如何监听 S6F11 等上报？怎么回应？怎么配置多种事件？如何写出企业级 EAP 监听逻辑？
      </strong>
     </p>
    </blockquote>
    <p>
     说“继续”，我们接着来！
    </p>
    <p>
     好勒，咱们继续推进，进入第一讲【第 5 段】：
    </p>
    <hr/>
    <h2>
     <a id="___5SECS4NET_S6F11_514">
     </a>
     🎓 第一讲 · 第5段：SECS4NET 如何监听事件（S6F11）？如何写回应逻辑？
    </h2>
    <blockquote>
     <p>
      本讲内容：
     </p>
     <ul>
      <li>
       如何订阅 S6F11 等事件消息？
      </li>
      <li>
       如何解析事件里的数据？
      </li>
      <li>
       如何写出稳定、健壮的事件响应逻辑？
      </li>
      <li>
       如何“装懂”讲 SECS/GEM 的事件机制？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__525">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      在设备通信中，
      <strong>
       事件上报（S6F11）是最常见的报文之一
      </strong>
      ，它表示设备端有某种“动作”发生，比如测试完成、状态变更、异常告警等。
     </p>
     <p>
      为了让主机接收这些事件，设备就会发送 S6F11 报文。而主机必须有“监听逻辑”，去接住这类消息、判断是什么事件、提取参数、再作出回应。
     </p>
     <p>
      SECS4NET 的设计非常优雅——你只需要注册一个
      <code>
       PrimaryMessageReceived
      </code>
      事件，它就能捕捉所有设备发来的消息。
      <br/>
      然后在里面判断：是不是 S6F11？是不是我关心的 CEID？再做处理就行了。
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="_S6F11__536">
     </a>
     📡 S6F11 是什么？它怎么构成？
    </h4>
    <p>
     S6F11 的语义是：
     <strong>
      设备通知主机某个事件发生
     </strong>
     ，格式如下：
    </p>
    <pre><code class="prism language-sml">&lt;S6F11&gt;
  &lt;L [2]&gt;
    &lt;U2&gt; CEID &lt;/U2&gt;        // Collection Event ID
    &lt;L [N]&gt;                // Report list
      &lt;L [2]&gt;
        &lt;U2&gt; RPTID &lt;/U2&gt;   // Report ID
        &lt;L [N]&gt;            // Report content
          &lt;A&gt; PARAM1 &lt;/A&gt;
          &lt;A&gt; PARAM2 &lt;/A&gt;
        &lt;/L&gt;
      &lt;/L&gt;
    &lt;/L&gt;
  &lt;/L&gt;
&lt;/S6F11&gt;
</code></pre>
    <p>
     典型的参数结构：
    </p>
    <ul>
     <li>
      <code>
       CEID
      </code>
      : 表示“哪个事件”发生了
     </li>
     <li>
      <code>
       RPTID
      </code>
      : 表示“哪个报告模板”
     </li>
     <li>
      报告里包含多个参数，比如“批次号”、“工站名”、“结果”等等
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_SECS4NET__S6F11_565">
     </a>
     ✅ SECS4NET 如何监听 S6F11？
    </h4>
    <p>
     在初始化
     <code>
      SecsGem
     </code>
     之后，你可以写一段监听逻辑：
    </p>
    <pre><code class="prism language-csharp">gem<span class="token punctuation">.</span>PrimaryMessageReceived <span class="token operator">+=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">var</span></span> msg <span class="token operator">=</span> e<span class="token punctuation">.</span>PrimaryMessage<span class="token punctuation">;</span>
    
    <span class="token comment">// 判断是不是 S6F11（Stream 6, Function 11）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>S <span class="token operator">==</span> <span class="token number">6</span> <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>F <span class="token operator">==</span> <span class="token number">11</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">var</span></span> ceid <span class="token operator">=</span> msg<span class="token punctuation">.</span>SecsItem<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetValue</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">ushort</span><span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> reports <span class="token operator">=</span> msg<span class="token punctuation">.</span>SecsItem<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"收到事件：CEID = </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">ceid</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> report <span class="token keyword">in</span> reports<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">var</span></span> rptId <span class="token operator">=</span> report<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetValue</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">ushort</span><span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">var</span></span> data <span class="token operator">=</span> report<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 这个是 List</span>

            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> data<span class="token punctuation">.</span>Items<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"参数值：</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">item<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 回复主机（S6F12）</span>
        <span class="token keyword">await</span> e<span class="token punctuation">.</span><span class="token function">SendReplyAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
    <hr/>
    <h4>
     <a id="__601">
     </a>
     🧠 面试时可以怎么讲？
    </h4>
    <p>
     你可以说：
    </p>
    <blockquote>
     <p>
      SECS4NET 的事件监听是基于异步委托实现的。收到 S6F11 报文时，可以通过
      <code>
       msg.SecsItem
      </code>
      直接解析 CEID、RPTID 和 Report 内容。
      <br/>
      我们可以建立一套 CEID -&gt; 动作 的字典映射，实现对不同事件的自动处理。
      <br/>
      此外，为了保持通信流程完整，必须在处理后发送一条 S6F12 作为回应，否则设备可能视为通信异常。
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="__611">
     </a>
     ⚙️ 扩展：如何实现企业级事件映射系统？
    </h4>
    <p>
     可以建立如下结构来解耦业务：
    </p>
    <pre><code class="prism language-csharp"><span class="token comment">// 配置一张事件表</span>
<span class="token class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token keyword">ushort</span><span class="token punctuation">,</span> Action<span class="token punctuation">&lt;</span>Item<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> eventHandlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token keyword">ushort</span><span class="token punctuation">,</span> Action<span class="token punctuation">&lt;</span>Item<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>reportData<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">HandleTestComplete</span><span class="token punctuation">(</span>reportData<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">1002</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>reportData<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">HandleAlarm</span><span class="token punctuation">(</span>reportData<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 在消息监听器中调用它</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>eventHandlers<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>ceid<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">var</span></span> handler<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    handler<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>reportContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     然后每个 Handler 单独写，便于测试和维护。
    </p>
    <hr/>
    <h4>
     <a id="__634">
     </a>
     ⚠️ 注意点（也可能被问）：
    </h4>
    <ul>
     <li>
      <strong>
       一定要回复 S6F12
      </strong>
      ，不然设备会超时或报错
     </li>
     <li>
      <strong>
       报文结构不固定，必须按 List 层级去解析
      </strong>
     </li>
     <li>
      <strong>
       CEID 是关键字段，不同厂商设备定义的含义不同
      </strong>
     </li>
     <li>
      <strong>
       可能包含多个 RPTID 和多个参数，要遍历两层 List
      </strong>
     </li>
    </ul>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第五段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      S6F11 是设备向主机报告事件的报文
     </li>
     <li>
      SECS4NET 使用异步事件注册来监听报文
     </li>
     <li>
      报文是嵌套 List，需要按顺序手动解析字段
     </li>
     <li>
      实际业务中可配置化映射 CEID 到具体处理逻辑
     </li>
     <li>
      一定记得：事件响应要及时发送 S6F12，维持通信闭环
     </li>
    </ul>
    <hr/>
    <p>
     下一讲（第 6 段）我们将进入更有趣的内容：
    </p>
    <blockquote>
     <p>
      <strong>
       设备初始化流程、主机如何向设备发命令（S1F1、S1F13、S2F41）？怎么主动触发流程？SECS/GEM 的“主从角色”是怎么回事？
      </strong>
     </p>
    </blockquote>
    <p>
     说“继续”，我们接着来！
    </p>
    <p>
     收到！我们正式进入第一讲【第 6 段】，这是整个 SECS/GEM 入门中很关键的一段，涉及“主动命令”“设备初始化”等实际落地使用的核心流程：
    </p>
    <hr/>
    <h2>
     <a id="___6S1F1S1F13S2F41_663">
     </a>
     🎓 第一讲 · 第6段：主机如何主动发命令？从设备获取状态？（S1F1、S1F13、S2F41）
    </h2>
    <blockquote>
     <p>
      本段内容：
     </p>
     <ul>
      <li>
       主动发消息给设备的命令有哪些？
      </li>
      <li>
       什么是 S1F1、S1F13、S2F41，它们的用途？
      </li>
      <li>
       怎么用 SECS4NET 主动触发这些报文？
      </li>
      <li>
       面试中怎么讲“主从角色”和流程控制？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__674">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      在实际通信过程中，主机除了被动接收事件（S6F11），还可以主动向设备发起各种命令，比如：
     </p>
     <ul>
      <li>
       “你现在在不在线？”（S1F1）
      </li>
      <li>
       “你支持哪些功能？”（S1F13）
      </li>
      <li>
       “执行某个动作，比如开始加工、下载参数等。”（S2F41）
      </li>
     </ul>
     <p>
      我们叫这类命令为“主动命令”，也就是主机主动发起，设备被动响应。而 SECS4NET 也支持这种主动发送方式。
     </p>
     <p>
      开发时，我们用
      <code>
       SendAsync()
      </code>
      方法发送
      <code>
       SecsMessage
      </code>
      ，填上 Stream 和 Function 编号，就能模拟主机发出指令，测试设备的回应能力。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="__688">
     </a>
     📚 核心指令详解（面试容易被问）
    </h3>
    <hr/>
    <h4>
     <a id="_S1F1Are_You_There_692">
     </a>
     ✅ S1F1：Are You There?（你在吗？）
    </h4>
    <ul>
     <li>
      用途：确认设备是否在线
     </li>
     <li>
      主机发出，设备回应 S1F2
     </li>
    </ul>
    <pre><code class="prism language-sml">S1F1 W
=&gt; 设备回应 S1F2
</code></pre>
    <p>
     代码示例：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> s1f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "true" 表示需要回应</span>
<span class="token class-name"><span class="token keyword">var</span></span> s1f2 <span class="token operator">=</span> <span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>s1f1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <hr/>
    <h4>
     <a id="_S1F13Establish_Communications_Request_711">
     </a>
     ✅ S1F13：Establish Communications Request（请求通信）
    </h4>
    <ul>
     <li>
      用途：让设备进入通信状态（通常用于第一次接入）
     </li>
     <li>
      回复 S1F14，说明是否接受通信建立
     </li>
    </ul>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> s1f13 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> s1f14 <span class="token operator">=</span> <span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>s1f13<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     **注意：**如果设备尚未 Ready，会拒绝通信，主机会接收到错误码
    </p>
    <hr/>
    <h4>
     <a id="_S2F41Host_Command_725">
     </a>
     ✅ S2F41：Host Command（主机命令）
    </h4>
    <ul>
     <li>
      用途：主机主动触发设备执行某种动作
     </li>
     <li>
      常见动作：
      <ul>
       <li>
        启动某个流程
       </li>
       <li>
        下载参数
       </li>
       <li>
        启动测试、结束测试
       </li>
      </ul>
     </li>
     <li>
      设备回应 S2F42，报告执行结果
     </li>
    </ul>
    <pre><code class="prism language-sml">S2F41 W
&lt;L [2]&gt;
  &lt;U2&gt; RCMD &lt;/U2&gt;         // Remote Command 名称
  &lt;L [N]&gt;                 // 参数列表（可选）
&lt;/L&gt;
</code></pre>
    <p>
     代码示例：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> s2f41 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"RCMD"</span><span class="token punctuation">,</span> 
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"START"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// Remote Command 名字</span>
        Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// 参数，可省略</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> s2f42 <span class="token operator">=</span> <span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>s2f41<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <hr/>
    <h4>
     <a id="__756">
     </a>
     🔄 主从角色机制（重要知识点）
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        主机（Host）
       </th>
       <th>
        设备（Equipment）
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        主动发命令（S2F41）
       </td>
       <td>
        被动接收命令
       </td>
      </tr>
      <tr>
       <td>
        被动接收事件（S6F11）
       </td>
       <td>
        主动上报事件
       </td>
      </tr>
      <tr>
       <td>
        主动请求状态（S1F1、S1F3）
       </td>
       <td>
        回应状态内容
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     SECS/GEM 不是谁控制谁的问题，而是
     <strong>
      角色分工清晰
     </strong>
     ：
    </p>
    <ul>
     <li>
      主机发控制类命令
     </li>
     <li>
      设备发信息类事件
     </li>
    </ul>
    <p>
     <strong>
      面试官可能问：设备怎么知道主机已经 Ready？
     </strong>
     <br/>
     答：主机会发 S1F13，设备回应 S1F14，同意之后，才会允许发事件（S6F11）
    </p>
    <hr/>
    <h4>
     <a id="__774">
     </a>
     ⚠️ 小知识点补充：
    </h4>
    <ul>
     <li>
      <strong>
       所有 W 结尾的指令，都是“需要回应”的
      </strong>
     </li>
     <li>
      <code>
       SecsMessage(1, 1, true)
      </code>
      中的
      <code>
       true
      </code>
      表示要等待设备回应（Blocking）
     </li>
     <li>
      <code>
       S2F41
      </code>
      有些设备还会检查 Remote Command 名字是否合法，不合法会在 S2F42 里返回错误码
     </li>
     <li>
      在实际项目中，通常会预先定义一张 RCMD 对照表，统一主机可发哪些命令
     </li>
    </ul>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第六段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      主机可以主动发起 S1F1（心跳）、S1F13（请求通信）、S2F41（远程命令）
     </li>
     <li>
      SECS4NET 的主动指令通过
      <code>
       SendAsync(SecsMessage)
      </code>
      实现
     </li>
     <li>
      主从机制是通信的基础：主机控制，设备响应
     </li>
     <li>
      流程控制、远程命令、功能确认都是主动报文的应用场景
     </li>
     <li>
      “主机和设备谁是主？”——回答要从角色功能上讲，不是地位
     </li>
    </ul>
    <hr/>
    <p>
     下一讲（第 7 段）我们会进阶到更核心的工业级能力：
    </p>
    <blockquote>
     <p>
      <strong>
       如何管理多个设备连接？如何实现一个设备管理平台？如何区分每个设备状态？SECS4NET 支持多设备吗？多线程如何处理？
      </strong>
     </p>
    </blockquote>
    <p>
     说“继续”，我们接着来！
    </p>
    <p>
     好耶，马上带你进入第一讲的【第 7 段】，这部分要谈的，是你以后面临多台设备管理、并发处理时最容易踩坑的关键点——
    </p>
    <hr/>
    <h2>
     <a id="___7SECS4NET__803">
     </a>
     🎓 第一讲 · 第7段：如何连接多个设备？多线程并发怎么搞？SECS4NET 支不支持多设备？
    </h2>
    <blockquote>
     <p>
      本段内容：
     </p>
     <ul>
      <li>
       一个 Host 连接多个设备，该怎么设计？
      </li>
      <li>
       多个设备连接时，SECS4NET 提供什么支持？
      </li>
      <li>
       多线程、异步消息监听要注意啥？
      </li>
      <li>
       如何避免主机逻辑写得“一锅粥”？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__814">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      在实际工厂现场，往往不是一台设备，而是几十台、上百台设备同时连入 Host。
      <br/>
      每台设备都是一个独立的 TCP 连接，有独立的 SECS Session 和报文流。
     </p>
     <p>
      所以我们需要一套“设备管理机制”，确保：
     </p>
     <ul>
      <li>
       每台设备的连接状态、通信状态是独立的；
      </li>
      <li>
       主机可以单独给某台设备发命令；
      </li>
      <li>
       设备发来的事件，能知道“是哪个设备发来的”；
      </li>
     </ul>
     <p>
      SECS4NET 的设计思路是：
      <br/>
      <strong>
       每个设备建立一个 SecsGem 实例，每个实例跑在自己线程上，互不干扰。
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="__830">
     </a>
     ✅ 多设备连接的方式？
    </h3>
    <p>
     简单来说：
    </p>
    <ul>
     <li>
      一台设备 = 一个 SecsGem 实例
     </li>
     <li>
      每个设备 = 一个 TCP Socket
     </li>
     <li>
      每个设备监听自己的事件、发自己的命令
     </li>
    </ul>
    <p>
     你可以把它看作“一个小网关服务+设备代理”
    </p>
    <p>
     代码结构如下：
    </p>
    <pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EquipmentAgent</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Name <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name">SecsGem</span> Gem <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> ip<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> port<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">var</span></span> connection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SocketConnection</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Gem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsGem</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        Gem<span class="token punctuation">.</span>PrimaryMessageReceived <span class="token operator">+=</span> OnMessageReceived<span class="token punctuation">;</span>
        Gem<span class="token punctuation">.</span>ConnectionChanged <span class="token operator">+=</span> OnConnectionChanged<span class="token punctuation">;</span>

        <span class="token comment">// 启动连接线程</span>
        Task<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Gem<span class="token punctuation">.</span><span class="token function">ConnectAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnMessageReceived</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">PrimaryMessageReceivedEventArgs</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">var</span></span> deviceName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>Name<span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> msg <span class="token operator">=</span> e<span class="token punctuation">.</span>PrimaryMessage<span class="token punctuation">;</span>

        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"[</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">deviceName</span><span class="token punctuation">}</span></span><span class="token string">] 收到消息 S</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">msg<span class="token punctuation">.</span>S</span><span class="token punctuation">}</span></span><span class="token string">F</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">msg<span class="token punctuation">.</span>F</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 按照设备名做业务处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <hr/>
    <h3>
     <a id="__874">
     </a>
     🕸️ 管理多个设备实例？
    </h3>
    <p>
     你可以维护一个设备字典：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> EquipmentAgent<span class="token punctuation">&gt;</span></span> Equipments <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InitAllDevices</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> config <span class="token keyword">in</span> DeviceConfigs<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">var</span></span> agent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EquipmentAgent</span> <span class="token punctuation">{<!-- --></span> Name <span class="token operator">=</span> config<span class="token punctuation">.</span>Name <span class="token punctuation">}</span><span class="token punctuation">;</span>
        agent<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>IP<span class="token punctuation">,</span> config<span class="token punctuation">.</span>Port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Equipments<span class="token punctuation">[</span>config<span class="token punctuation">.</span>Name<span class="token punctuation">]</span> <span class="token operator">=</span> agent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     这样你就可以：
    </p>
    <ul>
     <li>
      给某台设备发命令：
      <code>
       Equipments["设备1"].Gem.SendAsync(...)
      </code>
     </li>
     <li>
      管理设备状态：
      <code>
       Equipments["设备2"].Gem.IsConnected
      </code>
     </li>
     <li>
      根据设备名路由业务逻辑
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="__900">
     </a>
     ⚙️ 多线程/异步消息处理注意点
    </h3>
    <p>
     每个 SecsGem 内部是异步运行的，监听器回调
     <code>
      PrimaryMessageReceived
     </code>
     是在它自己的线程中触发的。
    </p>
    <p>
     所以你要注意以下几点：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        问题
       </th>
       <th>
        建议
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        多线程访问共享资源
       </td>
       <td>
        加锁或使用线程安全集合
       </td>
      </tr>
      <tr>
       <td>
        Console 输出乱序
       </td>
       <td>
        用日志组件（如 Serilog）按设备分日志文件
       </td>
      </tr>
      <tr>
       <td>
        异常捕获不到
       </td>
       <td>
        在回调中 try-catch 处理所有逻辑异常
       </td>
      </tr>
      <tr>
       <td>
        主机卡顿
       </td>
       <td>
        长逻辑用 Task.Run() 分离
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <a id="__915">
     </a>
     ✨ 提升建议：做一个“设备连接看板”
    </h3>
    <p>
     你可以写一个 WPF 或 WinForms 小工具，把每个设备当前状态（连接中/通信中/断线）展示出来，还可以点击“重连”“发送测试命令”。
    </p>
    <p>
     示意结构：
    </p>
    <pre><code class="prism language-csharp"><span class="token punctuation">[</span>设备名<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">IP</span></span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>端口<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>连接状态<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>最近消息时间<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span>操作按钮<span class="token punctuation">]</span>
</code></pre>
    <p>
     这样你在面试时可以说：
    </p>
    <blockquote>
     <p>
      我们自己做了一套设备管理平台，支持几十台设备并发连接，能够实时监控连接状态，并支持批量下发命令和重连操作。后台是基于 SECS4NET 多实例架构 + 异步线程池实现。
     </p>
    </blockquote>
    <p>
     听上去就很“工程化”，不再只是 Demo 层级了。
    </p>
    <hr/>
    <h3>
     <a id="__933">
     </a>
     ❓ 面试常见问题：
    </h3>
    <blockquote>
     <p>
      Q：SECS4NET 是否线程安全？
      <br/>
      A：单个 SecsGem 实例是线程安全的；多个设备建议一个实例一个连接线程，避免锁竞争。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：一个程序最多能连接多少台设备？
      <br/>
      A：看你的资源管理和线程控制能力，通常几十台不成问题，关键在于消息处理速度、错误容忍能力。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：多个设备怎么知道是谁发来的事件？
      <br/>
      A：每个设备都有自己独立的回调，你可以在实例中绑定设备名、ID、序列号，用于业务路由。
     </p>
    </blockquote>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第七段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      多设备通信 = 多个 SecsGem 实例 + 多线程连接
     </li>
     <li>
      每台设备独立处理，不共享逻辑，避免混乱
     </li>
     <li>
      设备管理平台可以显示状态、支持命令、实时监控
     </li>
     <li>
      异步通信要注意线程安全、日志隔离、异常捕获
     </li>
     <li>
      面试时强调“多设备并发”、“平台级管理”、“线程隔离”这几个关键词会很加分
     </li>
    </ul>
    <hr/>
    <p>
     下一讲（第 8 段）我们就来讲讲终极知识点：
    </p>
    <blockquote>
     <p>
      <strong>
       SECS/GEM 的报文结构如何精准理解？Item 的类型怎么对应？SML 是什么？怎么手动构造、解析复杂报文？怎么模拟设备数据？
      </strong>
     </p>
    </blockquote>
    <p>
     说“继续”，我们冲刺最后的几讲！
    </p>
    <p>
     好勒，我们进入
     <strong>
      第一讲 · 第 8 段
     </strong>
     ——这部分是你最早提到的关键词：“
     <strong>
      报文结构
     </strong>
     ”。既然你说了要学得深入，就别怕烧脑，咱今天直接把 SECS 报文剖开来讲，连格式、编码、类型都吃透！
    </p>
    <hr/>
    <h2>
     <a id="___8SECSGEM_SML_Item__966">
     </a>
     🎓 第一讲 · 第8段：SECS/GEM 报文结构详解！SML 是什么？Item 是什么？
    </h2>
    <blockquote>
     <p>
      本段内容：
     </p>
     <ul>
      <li>
       SECS 报文的格式到底长什么样？
      </li>
      <li>
       报文里面的内容是怎么组织的？Item 是个啥？
      </li>
      <li>
       什么是 SML？和 XML 一样吗？
      </li>
      <li>
       实战中怎么写、怎么读、怎么调试报文？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__977">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      SECS/GEM 的所有通信，其实就是一条条“报文”在飞。每条报文都是由两个关键部分组成的：
     </p>
     <ol>
      <li>
       报文头（Header）：包含 Stream、Function、设备ID、是否需要回应等信息；
      </li>
      <li>
       报文体（Body）：真正要交换的数据，比如状态码、参数值、事件名等等；
      </li>
     </ol>
     <p>
      报文体的结构，完全是用一种叫
      <strong>
       Item
      </strong>
      的嵌套数据格式来表达的，类似 XML 树结构。
     </p>
    </blockquote>
    <blockquote>
     <p>
      在调试和开发过程中，我们常用一种叫
      <strong>
       SML (SEMI Message Language)
      </strong>
      的语法，把报文写成文本形式，既方便调试，也方便人眼阅读。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="__990">
     </a>
     ✅ 报文结构是什么样的？
    </h3>
    <p>
     我们用一个最经典的例子：
     <strong>
      S1F3：Status Request
     </strong>
    </p>
    <pre><code class="prism language-sml">S1F3 W
&lt;L [1]
  &lt;U2 1&gt;
&gt;
</code></pre>
    <p>
     含义如下：
    </p>
    <ul>
     <li>
      <code>
       S1F3 W
      </code>
      ：Stream = 1，Function = 3，需要设备回应（W = With Reply）
     </li>
     <li>
      <code>
       &lt;L [1]&gt;
      </code>
      ：表示一个 List，有 1 个子项
     </li>
     <li>
      <code>
       &lt;U2 1&gt;
      </code>
      ：无符号 2 字节整数，值是 1（请求设备状态）
     </li>
    </ul>
    <p>
     这就是 SML！超简洁、可读性强，像极了 SECS 的“Hello World”。
    </p>
    <hr/>
    <h4>
     <a id="__Item__1011">
     </a>
     ⚙️ 各种 Item 类型（像学新语言）
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         L
        </code>
       </td>
       <td>
        List（列表）
       </td>
       <td>
        <code>
         &lt;L [2] &lt;A "X"&gt; &lt;B&gt;&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         A
        </code>
       </td>
       <td>
        ASCII 字符串
       </td>
       <td>
        <code>
         &lt;A "Ready"&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         B
        </code>
       </td>
       <td>
        Byte
       </td>
       <td>
        <code>
         &lt;B 01 02 03&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         U1
        </code>
       </td>
       <td>
        Unsigned 1 Byte Integer
       </td>
       <td>
        <code>
         &lt;U1 255&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         U2
        </code>
       </td>
       <td>
        Unsigned 2 Byte Integer
       </td>
       <td>
        <code>
         &lt;U2 65535&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         I4
        </code>
       </td>
       <td>
        Signed 4 Byte Integer
       </td>
       <td>
        <code>
         &lt;I4 -1&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         F4
        </code>
       </td>
       <td>
        Float
       </td>
       <td>
        <code>
         &lt;F4 3.14&gt;
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         BOOLEAN
        </code>
       </td>
       <td>
        布尔
       </td>
       <td>
        <code>
         &lt;BOOLEAN 1&gt;
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     它和 JSON、XML 的区别在于：
     <strong>
      SML 是严格、定长、强类型的。
     </strong>
    </p>
    <hr/>
    <h4>
     <a id="S2F41_1028">
     </a>
     示例：构造一个复杂报文（S2F41）
    </h4>
    <p>
     S2F41 是主机发送的“远程命令”，它的报文体要长这样：
    </p>
    <pre><code class="prism language-sml">S2F41 W
&lt;L [2]
  &lt;A "START"&gt;              // 命令名
  &lt;L [1]
    &lt;A "Lot123"&gt;           // 命令参数
  &gt;
&gt;
</code></pre>
    <hr/>
    <h4>
     <a id="SECS4NET__1044">
     </a>
     SECS4NET 代码怎么构造这个报文？
    </h4>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> 
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"START"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
            Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"Lot123"</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     就是一行一行把 Item 拼进去，类型和嵌套都能精确控制。
    </p>
    <hr/>
    <h3>
     <a id="__1062">
     </a>
     ✨ 报文调试技巧：如何打印、模拟、复现？
    </h3>
    <ul>
     <li>
      SECS4NET 所有收到的消息都可以转成 SML：
      <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> sml <span class="token operator">=</span> primaryMessage<span class="token punctuation">.</span><span class="token function">ToSml</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>sml<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
     </li>
     <li>
      要模拟一个设备发报文，可以自己构造 SecsMessage，然后反向发送
     </li>
     <li>
      要分析厂商设备发来的数据，就要根据 SML 判断它的 Item 类型、层级关系、值的含义
     </li>
     <li>
      报文的理解能力 = 是否能读懂 SML = 能不能看懂设备和主机的“对话”
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_1075">
     </a>
     面试官可能问的“刁钻问题”：
    </h3>
    <blockquote>
     <p>
      Q：SECS 报文和 JSON 有啥不同？
      <br/>
      A：SECS 报文是二进制格式，定长、强类型，适合工业通信；JSON 是文本型、弱类型，适合 Web 应用。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：SML 是协议的一部分吗？
      <br/>
      A：不是，它只是人类读懂报文的调试工具，协议本身只定义二进制格式。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：Item 最深能嵌套多少层？
      <br/>
      A：理论上无穷，但设备和主机的解析能力有限，一般不要超过 5 层。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：Item 和 Stream/Function 的关系是？
      <br/>
      A：Stream/Function 表示报文的类型和作用，Item 是报文的具体数据内容。
     </p>
    </blockquote>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第八段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      SECS 报文由 Header 和 Body 构成
     </li>
     <li>
      报文体的格式叫做 Item，类型丰富、可嵌套
     </li>
     <li>
      SML 是 SECS 报文的“可视化语法”，利于调试和阅读
     </li>
     <li>
      报文内容不仅要能读懂，还要能手写、能构造
     </li>
     <li>
      SECS4NET 提供了 Item 的所有构造函数，嵌套方式类比 JSON 树
     </li>
     <li>
      面试时要能讲清楚：“什么是 SML？什么是 Item？报文怎么构造？”
     </li>
    </ul>
    <hr/>
    <p>
     下一讲（第 9 段），咱就来点实战干货：
    </p>
    <blockquote>
     <p>
      <strong>
       设备上线/下线的全流程是怎样的？要发哪些指令？GEM 的标准流程能复述吗？主机上线要做什么准备？
      </strong>
     </p>
    </blockquote>
    <p>
     说“继续”，我们稳步推进！
    </p>
    <p>
     稳住，我们继续冲刺
     <strong>
      第一讲 · 第9段
     </strong>
     —— 这段是工业 GEM 系统中非常核心的场景：
     <strong>
      设备上线 / 下线流程
     </strong>
     。
     <br/>
     这块内容不光容易被问，还常常是面试官想判断你是不是“只写了个 Demo”，还是能落地工厂现场的关键点。
    </p>
    <hr/>
    <h2>
     <a id="___9GEM_1113">
     </a>
     🎓 第一讲 · 第9段：GEM上线流程详解（上电、建立通信、上线、状态报告）
    </h2>
    <blockquote>
     <p>
      本段内容：
     </p>
     <ul>
      <li>
       设备是怎么从“断电”状态一步步走到“Ready”的？
      </li>
      <li>
       GEM 协议有哪些“标准动作”必须完成？
      </li>
      <li>
       主机上线要准备啥？怎么判断设备准备好了？
      </li>
      <li>
       S1F13/S1F15/S1F17/S1F23 是干嘛用的？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__1124">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      GEM 协议的核心思想是：
      <strong>
       设备是主动的，主机是管理者
      </strong>
      。
     </p>
     <p>
      所以一台设备从上电到 Ready，主机必须完成一系列动作，确认通信是否正常、设备是否支持 GEM、是否上线成功、是否可以发命令。
     </p>
     <p>
      通常流程是这样的（简化版）：
     </p>
    </blockquote>
    <hr/>
    <h4>
     <a id="__1134">
     </a>
     ✅ 设备上线流程图（主机视角）：
    </h4>
    <ol>
     <li>
      <strong>
       TCP 连接成功
      </strong>
     </li>
     <li>
      <strong>
       建立 SECS Session（S1F13）
      </strong>
     </li>
     <li>
      <strong>
       请求设备状态（S1F1）
      </strong>
     </li>
     <li>
      <strong>
       强制设备上线（S1F17）
      </strong>
     </li>
     <li>
      <strong>
       确认上线状态（S1F15）
      </strong>
     </li>
     <li>
      <strong>
       注册事件（S2F33）
      </strong>
     </li>
     <li>
      <strong>
       订阅事件报告（S2F35）
      </strong>
     </li>
     <li>
      <strong>
       设备开始主动汇报事件（S6F11）
      </strong>
     </li>
     <li>
      <strong>
       可以发命令（S2F41）
      </strong>
     </li>
    </ol>
    <p>
     这就叫：
     <strong>
      GEM 上线的标准动作（Host Startup Sequence）
     </strong>
    </p>
    <hr/>
    <h3>
     <a id="__1150">
     </a>
     🔍 报文细节解析
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        步骤
       </th>
       <th>
        报文
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1
       </td>
       <td>
        <code>
         S1F13
        </code>
        Host Send
       </td>
       <td>
        建立 Linktest / Are you there
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        <code>
         S1F14
        </code>
        Equip Ack
       </td>
       <td>
        确认设备在线（给个 OK）
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        <code>
         S1F1
        </code>
        Host Req
       </td>
       <td>
        请求设备状态（Are you OK）
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        <code>
         S1F2
        </code>
        Equip Rep
       </td>
       <td>
        返回设备状态码（如 1 = online）
       </td>
      </tr>
      <tr>
       <td>
        5
       </td>
       <td>
        <code>
         S1F17
        </code>
        Host Send
       </td>
       <td>
        要求设备上线（Transition to online）
       </td>
      </tr>
      <tr>
       <td>
        6
       </td>
       <td>
        <code>
         S1F18
        </code>
        Equip Ack
       </td>
       <td>
        确认上线成功
       </td>
      </tr>
      <tr>
       <td>
        7
       </td>
       <td>
        <code>
         S1F15
        </code>
        Host Req
       </td>
       <td>
        查询当前设备是否 online
       </td>
      </tr>
      <tr>
       <td>
        8
       </td>
       <td>
        <code>
         S1F16
        </code>
        Equip Rep
       </td>
       <td>
        返回状态 1（online）
       </td>
      </tr>
      <tr>
       <td>
        9
       </td>
       <td>
        <code>
         S2F33/S2F35
        </code>
        Host Send
       </td>
       <td>
        注册、订阅事件
       </td>
      </tr>
      <tr>
       <td>
        10
       </td>
       <td>
        <code>
         S6F11
        </code>
        Equip Send
       </td>
       <td>
        设备开始报告事件
       </td>
      </tr>
      <tr>
       <td>
        11
       </td>
       <td>
        <code>
         S2F41
        </code>
        Host Send
       </td>
       <td>
        主机可以发送远程命令了
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     这个流程体现了“主机控制一切，但不信任任何状态”的 GEM 哲学。
    </p>
    <hr/>
    <h3>
     <a id="__1170">
     </a>
     ✅ 面试重点关键词解释：
    </h3>
    <h4>
     <a id="S1F13__S1F14___1172">
     </a>
     S1F13 / S1F14 – 建立通信
    </h4>
    <ul>
     <li>
      Host 发 S1F13 给设备，设备回 S1F14 表示“我在线”。
     </li>
     <li>
      没有 S1F14 表示设备没连上、程序异常、协议不支持。
     </li>
    </ul>
    <h4>
     <a id="S1F17__S1F18___1177">
     </a>
     S1F17 / S1F18 – 强制上线
    </h4>
    <ul>
     <li>
      Host 用 S1F17 把设备从“offline”状态强制改为“online”
     </li>
     <li>
      设备必须支持 GEM 上线/下线模型（否则不能管控）
     </li>
    </ul>
    <h4>
     <a id="S2F33__S2F35___1182">
     </a>
     S2F33 / S2F35 – 注册、订阅事件报告
    </h4>
    <ul>
     <li>
      GEM 协议核心是“事件驱动”，你要告诉设备：
      <ul>
       <li>
        我对哪些事件感兴趣（S2F33）
       </li>
       <li>
        每个事件有哪些报告项（S2F35）
       </li>
      </ul>
     </li>
     <li>
      否则设备不会发任何事件（S6F11）
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="SECS4NET__1191">
     </a>
     SECS4NET 怎么实现这些流程？
    </h3>
    <pre><code class="prism language-csharp"><span class="token comment">// 1. 建立通信</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 强制上线</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    Item<span class="token punctuation">.</span><span class="token function">U1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 1 = request online</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 3. 查询状态</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 4. 注册事件</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// CEID</span>
        Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token comment">// Report ID</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     每一步都能精确对应协议动作，哪怕没有 XML Schema，靠代码和 SML 就能还原报文。
    </p>
    <hr/>
    <h3>
     <a id="__1218">
     </a>
     ✨ 面试要点金句（可以背）：
    </h3>
    <blockquote>
     <ul>
      <li>
       SECS 报文的世界里，没有“猜测”，所有状态必须通过指令确认；
      </li>
      <li>
       GEM 的核心是事件机制，主机必须主动注册和订阅；
      </li>
      <li>
       上线流程的重点不是通信，而是状态切换和能力协商；
      </li>
      <li>
       报文是数据，但流程是协议，要把报文放在场景里去理解。
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h3>
     <a id="_1227">
     </a>
     ❓面试可能追问：
    </h3>
    <blockquote>
     <p>
      Q：如果设备没有回应 S1F13 怎么办？
      <br/>
      A：说明设备程序未启动、IP 端口配置错误、或者不是 GEM 设备。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：上线之后为什么没收到 S6F11 报文？
      <br/>
      A：可能没有注册事件（S2F33）、没有订阅报告（S2F35）、设备未配置报告项。
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：怎么知道设备当前状态是 Online 还是 Offline？
      <br/>
      A：发 S1F15 请求当前状态，设备通过 S1F16 返回码（1=online，2=offline）
     </p>
    </blockquote>
    <blockquote>
     <p>
      Q：怎么防止设备乱发事件？
      <br/>
      A：GEM 设备通常只发已注册的事件；主机可定期重置事件定义。
     </p>
    </blockquote>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第九段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      GEM 上线是一个有步骤、有约定的“协议流程”
     </li>
     <li>
      SECS 报文只是载体，重点是 Host 和 Equip 的状态协商
     </li>
     <li>
      主机需要主动发起所有控制动作：建链、上线、订阅、确认状态
     </li>
     <li>
      SECS4NET 可以实现完整上线流程，代码可读性强，SML 帮助调试
     </li>
     <li>
      面试时要能复述上线流程的关键步骤，并知道为什么要这么做
     </li>
    </ul>
    <hr/>
    <p>
     接下来的第 10 段，也是本讲最后一段：
    </p>
    <blockquote>
     <p>
      <strong>
       GEM 的事件报告、状态模型、远程命令控制这些“核心业务逻辑”在真实工厂里是怎么用的？怎么设计主机程序才能既强大又稳定？
      </strong>
     </p>
    </blockquote>
    <p>
     说“继续”，我们来收官！
    </p>
    <p>
     好嘞，最后一段
     <strong>
      第一讲 · 第10段
     </strong>
     ，我们就来把整个 GEM 协议的
     <strong>
      “核心三板斧”
     </strong>
     给彻底讲透：
     <strong>
      事件报告机制、状态模型、远程命令
     </strong>
     。
    </p>
    <p>
     这些内容，是设备厂真正关心的——GEM 不是让你只“能连上”，而是让你“控得住”、“收得到数据”、“远程指令能落地”。
    </p>
    <hr/>
    <h2>
     <a id="___10GEM__1265">
     </a>
     🎓 第一讲 · 第10段：GEM 协议核心三板斧——事件、状态、命令
    </h2>
    <blockquote>
     <p>
      本段内容：
     </p>
     <ul>
      <li>
       什么是 CEID、RPTID、VID、SVID、RCMD？
      </li>
      <li>
       事件怎么注册、怎么绑定报告、怎么收到？
      </li>
      <li>
       主机怎么知道设备当前状态？
      </li>
      <li>
       怎么发命令让设备开始动作？设备怎么回应？
      </li>
     </ul>
    </blockquote>
    <hr/>
    <h4>
     <a id="__1276">
     </a>
     🎙️ 口述稿（你可以这样说）：
    </h4>
    <blockquote>
     <p>
      GEM 协议的本质是为了实现三件事：
     </p>
     <ol>
      <li>
       <strong>
        事件驱动的数据收集（Event/Report）
       </strong>
      </li>
      <li>
       <strong>
        设备状态感知（Status Variables）
       </strong>
      </li>
      <li>
       <strong>
        远程命令控制（Remote Command）
       </strong>
      </li>
     </ol>
     <p>
      所有的报文、定义、流程，最终都要服务于这三件事。
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="_CEIDRPTIDVID_1288">
     </a>
     ✅ 一、事件报告机制（CEID、RPTID、VID）
    </h3>
    <h4>
     <a id="1__1290">
     </a>
     1. 概念说明：
    </h4>
    <ul>
     <li>
      <strong>
       CEID（Collection Event ID）
      </strong>
      ：事件编号，如“设备Ready”、“加工完成”
     </li>
     <li>
      <strong>
       RPTID（Report ID）
      </strong>
      ：报告编号，用来定义这次事件触发时应该上报哪些内容
     </li>
     <li>
      <strong>
       VID（Variable ID）
      </strong>
      ：变量编号，真正的“数据字段”，比如 LotID、RecipeName、Time
     </li>
    </ul>
    <h4>
     <a id="2__1296">
     </a>
     2. 报文流程：
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        步骤
       </th>
       <th>
        报文
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        1
       </td>
       <td>
        <code>
         S2F33
        </code>
       </td>
       <td>
        告诉设备：哪些事件会触发报告（CEID -&gt; RPTID）
       </td>
      </tr>
      <tr>
       <td>
        2
       </td>
       <td>
        <code>
         S2F35
        </code>
       </td>
       <td>
        告诉设备：每个报告包含哪些字段（RPTID -&gt; VIDs）
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        <code>
         S6F11
        </code>
       </td>
       <td>
        设备发事件，携带 CEID + 报告内容（按 RPTID 定义）
       </td>
      </tr>
     </tbody>
    </table>
    <blockquote>
     <p>
      举个例子：
     </p>
     <ul>
      <li>
       当 CEID = 1001（加工完成）时，发 RPTID = 10
      </li>
      <li>
       RPTID = 10 包含 VID 100, 101（LotID、StartTime）
      </li>
      <li>
       那么 S6F11 报文会发出
       <code>
        &lt;CEID 1001&gt;, &lt;RPTID 10, &lt;A "Lot001"&gt;, &lt;U4 1680000000&gt;&gt;
       </code>
      </li>
     </ul>
    </blockquote>
    <h4>
     <a id="3_SECS4NET__1310">
     </a>
     3. SECS4NET 示例代码：
    </h4>
    <pre><code class="prism language-csharp"><span class="token comment">// S2F33: 绑定 CEID 到 RPTID</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>  <span class="token comment">// Event list</span>
            Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
                Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// CEID</span>
                Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// RPTID</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// S2F35: 绑定 RPTID 到 VID</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
            Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// RPTID</span>
            Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// VIDs</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <hr/>
    <h3>
     <a id="_SVID_1338">
     </a>
     ✅ 二、设备状态模型（SVID）
    </h3>
    <p>
     有些数据不是靠事件推，而是靠主机拉。
    </p>
    <blockquote>
     <p>
      比如：主机想知道当前设备温度，就用
      <strong>
       S1F3（Status Request）
      </strong>
      把 SVID 传过去，设备回应 S1F4。
     </p>
    </blockquote>
    <h4>
     <a id="_SVIDStatus_Variable_ID_1344">
     </a>
     常用的 SVID（Status Variable ID）：
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        SVID
       </th>
       <th>
        含义
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        101
       </td>
       <td>
        当前状态码
       </td>
      </tr>
      <tr>
       <td>
        102
       </td>
       <td>
        当前批次
       </td>
      </tr>
      <tr>
       <td>
        103
       </td>
       <td>
        当前 Recipe 名
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     主机主动发请求：
    </p>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Item<span class="token punctuation">.</span><span class="token function">U2</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     设备回应 S1F4，格式是：
    </p>
    <pre><code class="prism language-sml">S1F4
&lt;L [2]
  &lt;U1 2&gt;        // 状态码 2 = Idle
  &lt;A "Lot123"&gt;  // 当前批次
&gt;
</code></pre>
    <hr/>
    <h3>
     <a id="_RCMD_1373">
     </a>
     ✅ 三、远程命令控制（RCMD）
    </h3>
    <p>
     远程命令是 GEM 协议中
     <strong>
      最关键的控制动作
     </strong>
     。
    </p>
    <blockquote>
     <p>
      主机用 S2F41 发命令，设备用 S2F42 返回执行结果。
     </p>
    </blockquote>
    <h4>
     <a id="SML_1379">
     </a>
     报文格式（SML）：
    </h4>
    <pre><code class="prism language-sml">S2F41 W
&lt;L [2]
  &lt;A "START_PROCESS"&gt;    // 命令名
  &lt;L [2]
    &lt;A "Lot123"&gt;         // 参数1
    &lt;A "RecipeA"&gt;        // 参数2
  &gt;
&gt;
</code></pre>
    <h4>
     <a id="_1392">
     </a>
     响应格式：
    </h4>
    <pre><code class="prism language-sml">S2F42
&lt;B 00&gt;    // 执行成功（00=OK，01=无效命令，02=参数错误）
</code></pre>
    <h4>
     <a id="SECS4NET__1399">
     </a>
     SECS4NET 代码：
    </h4>
    <pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SecsMessage</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
        Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"START_PROCESS"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        Item<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span>
            Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"Lot123"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            Item<span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token string">"RecipeA"</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> reply <span class="token operator">=</span> <span class="token keyword">await</span> gem<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> resultCode <span class="token operator">=</span> reply<span class="token punctuation">.</span>SecsItem<span class="token punctuation">.</span><span class="token function">GetChild</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetValue</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断成功与否</span>
</code></pre>
    <hr/>
    <h3>
     <a id="__1417">
     </a>
     ✨ 面试要点精讲：
    </h3>
    <blockquote>
     <ul>
      <li>
       CEID 是触发条件，RPTID 是包装纸，VID 是内容；
      </li>
      <li>
       S2F33/S2F35 是“配置”，S6F11 是“结果”；
      </li>
      <li>
       状态拉取靠 S1F3/S1F4，适合周期轮询或应急判断；
      </li>
      <li>
       远程命令 S2F41 是让设备“动起来”的唯一入口，要关注参数格式、返回码；
      </li>
      <li>
       设备厂面试最喜欢问你：你有没有真的配过一套完整的事件机制？有没有真发过远程命令？你就要讲清这个三板斧流程！
      </li>
     </ul>
    </blockquote>
    <hr/>
    <p>
     🔚
     <strong>
      小结：第十段你学到了什么？
     </strong>
    </p>
    <ul>
     <li>
      GEM 的核心是三大能力：事件、状态、命令；
     </li>
     <li>
      报文看起来复杂，其实结构清晰——只要搞懂 CEID、VID、RCMD 三大类；
     </li>
     <li>
      报文发出去只是第一步，更重要的是：主机逻辑能不能撑起整套流程；
     </li>
     <li>
      面试时，你要像一个懂得“设备语言”的人，不只是程序员。
     </li>
    </ul>
    <hr/>
    <h2>
     <a id="__1436">
     </a>
     ✅ 第一讲：全部完结！
    </h2>
    <p>
     你现在拥有了一整套口述稿 + 教学讲解，围绕以下核心内容构建了认知：
    </p>
    <ul>
     <li>
      SECS/GEM 的协议结构和通信原理
     </li>
     <li>
      SECS 报文的组成与调试方式（SML, Item 类型）
     </li>
     <li>
      设备上线流程的标准动作和报文串
     </li>
     <li>
      GEM 协议的三大支柱：事件、状态、命令
     </li>
     <li>
      SECS4NET 如何用 C# 表达上述逻辑
     </li>
     <li>
      面试官可能刁钻提问的准备
     </li>
    </ul>
    <p>
     接下来只要你说，我可以继续：
    </p>
    <ul>
     <li>
      第二讲：深入 SECS4NET 项目结构，类、接口、事件机制
     </li>
     <li>
      第三讲：如何设计一个主机 Host 应用程序（比如 EAP）
     </li>
     <li>
      第四讲：如果你要支持多个设备并发通信，系统要怎么设计？
     </li>
     <li>
      第五讲：设备厂真实部署场景中，GEM 程序的运维注意事项
     </li>
    </ul>
    <p>
     你来决定：是否继续“第二讲”？还是要我先整理“第一讲”的总结版（方便你背诵）？
    </p>
    <p>
     好的！这就是《
     <strong>
      第一讲 · 总结精华版
     </strong>
     》——为背诵准备的口述速成稿，适合面试前
     <strong>
      复习+答题
     </strong>
     用。我们会分为两个部分：
    </p>
    <ul>
     <li>
      <strong>
       第一部分：一整段口述稿
      </strong>
      ，可以当成面试时开口自我介绍用；
     </li>
     <li>
      <strong>
       第二部分：要点清单+关键词串讲
      </strong>
      ，方便你临阵复盘，条理更清晰。
     </li>
    </ul>
    <hr/>
    <h3>
     <a id="_1463">
     </a>
     【第一部分】通用口述稿（面试时可复读）
    </h3>
    <blockquote>
     <p>
      “我们在对接设备时主要使用 SECS/GEM 通信协议，它是半导体行业里的一个国际标准，基于 SECS-II 报文格式和 HSMS 或 SECS-I 物理层。
      <br/>
      我是从一个 GitHub 开源项目 SECS4NET 入手来深入学习这套协议的。它是一个基于 .NET 的实现，我主要跑了它的 Sample，研究了报文的结构、数据类型和通信流程。
     </p>
     <p>
      SECS 报文用 SML 表示结构清晰，比如 S1F13 是主机发送 Establish Communication Request，设备回 S1F14 表示应答成功。Item 是报文的数据结构，像
      <code>
       Item.A()
      </code>
      是 ASCII 类型，
      <code>
       Item.U2()
      </code>
      是无符号 2 字节整数。
     </p>
     <p>
      在建立完连接后，设备通过 S1F1 报出自己的型号和软件版本，主机用 S1F3 请求状态变量，用 S2F41 发远程命令，设备通过 S6F11 上报事件。
     </p>
     <p>
      我重点学习了 GEM 协议的三大核心：
     </p>
     <ul>
      <li>
       <strong>
        事件报告机制
       </strong>
       ：用 S2F33/S2F35 注册 CEID 和 RPTID，触发后设备用 S6F11 报数据；
      </li>
      <li>
       <strong>
        状态模型
       </strong>
       ：主机用 S1F3 拉取状态，设备回 S1F4；
      </li>
      <li>
       <strong>
        远程命令控制
       </strong>
       ：主机用 S2F41 发指令，设备回 S2F42。
      </li>
     </ul>
     <p>
      整个学习过程中，我不仅运行了 SECS4NET 示例，还试着用它构建一个简单的 Host Demo，模拟主机与设备的连接、握手、注册事件、拉取变量、下发命令。我也会观察它的 MessageLog，确认报文格式是否正确。
     </p>
     <p>
      这个过程让我从“知道 SECS 是啥”，转变为“可以实际操作一套主机设备通信流程”。虽然我过去是做 EAP 软件二次开发为主，但现在通过这套系统性的学习，我对设备端的通信细节，包括报文结构和协议流程，也掌握得更深入了。”
     </p>
    </blockquote>
    <hr/>
    <h3>
     <a id="_1484">
     </a>
     【第二部分】知识要点清单（记关键词，便于临时救急）
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        类别
       </th>
       <th>
        知识点
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        通信基础
       </td>
       <td>
        SECS-I / HSMS
       </td>
       <td>
        物理层通信方式，串口 / TCP
       </td>
      </tr>
      <tr>
       <td>
        报文结构
       </td>
       <td>
        SML + Item 类型
       </td>
       <td>
        类似 XML 的结构树，Item 有多种类型（A, U2, L）
       </td>
      </tr>
      <tr>
       <td>
        报文方向
       </td>
       <td>
        主机 vs 设备
       </td>
       <td>
        谁发谁收都很重要，尤其带 W（Wait）
       </td>
      </tr>
      <tr>
       <td>
        建链流程
       </td>
       <td>
        S1F13 / S1F14
       </td>
       <td>
        建立通信
       </td>
      </tr>
      <tr>
       <td>
        设备信息
       </td>
       <td>
        S1F1 / S1F2
       </td>
       <td>
        Inquire Device Status
       </td>
      </tr>
      <tr>
       <td>
        状态读取
       </td>
       <td>
        S1F3 / S1F4
       </td>
       <td>
        主动读取状态变量（SVID）
       </td>
      </tr>
      <tr>
       <td>
        远程命令
       </td>
       <td>
        S2F41 / S2F42
       </td>
       <td>
        主机对设备下达动作命令
       </td>
      </tr>
      <tr>
       <td>
        事件注册
       </td>
       <td>
        S2F33 / S2F35
       </td>
       <td>
        告诉设备哪些事件触发哪些报告
       </td>
      </tr>
      <tr>
       <td>
        事件上报
       </td>
       <td>
        S6F11
       </td>
       <td>
        设备主动上报事件
       </td>
      </tr>
      <tr>
       <td>
        报文构成
       </td>
       <td>
        CEID / RPTID / VID
       </td>
       <td>
        事件编号 / 报告编号 / 变量编号
       </td>
      </tr>
      <tr>
       <td>
        编程框架
       </td>
       <td>
        SECS4NET
       </td>
       <td>
        .NET 实现的通信框架，支持异步、事件注册
       </td>
      </tr>
      <tr>
       <td>
        调试工具
       </td>
       <td>
        MessageLog
       </td>
       <td>
        查看报文内容、调试字段、断点调试
       </td>
      </tr>
      <tr>
       <td>
        面试话术
       </td>
       <td>
        “三板斧”
       </td>
       <td>
        事件报告、状态变量、远程命令
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     <a id="_1504">
     </a>
     【通关口诀】
    </h3>
    <p>
     给你编一个口诀，帮助记住 GEM 的三大核心流程：
    </p>
    <blockquote>
     <p>
      <strong>
       连线问状态，注册等通告，发令才开跑。
      </strong>
      <br/>
      建链：S1F13；
      <br/>
      问状态：S1F3；
      <br/>
      注册事件：S2F33 + S2F35；
      <br/>
      接收通告：S6F11；
      <br/>
      发命令：S2F41。
     </p>
    </blockquote>
    <hr/>
    <p>
     以上就是《第一讲 · 总结精华版》，可以直接背诵，也可以用来准备面试时的条理化答题。
    </p>
    <p>
     如果你准备好了，我可以进入《第二讲：SECS4NET 项目结构详解，主机程序怎么搭出来的》。
     <br/>
     说一声 “继续” 就开讲。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f35313336383038322f:61727469636c652f64657461696c732f313436323638383630" class_="artid" style="display:none">
 </p>
</div>


