---
layout: post
title: "python函数装饰器"
date: 2025-01-08 08:00:00 +0800
description: "参考文献：【1】Python 函数装饰器 | 菜鸟教程_python装饰器函数"
keywords: "python装饰器函数"
categories: ['自动化测试']
tags: ['Python']
artid: "123988572"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=123988572
    alt: "python函数装饰器"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=123988572
featuredImagePreview: https://bing.ee123.net/img/rand?artid=123988572
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     python函数装饰器
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     1.1 python装饰器
    </h3>
    <p>
     装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短。
    </p>
    <p>
     python的装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。简单的说装饰器就是一个用来返回函数的函数。
    </p>
    <h3>
     1.2 python装饰器应用场景
    </h3>
    <p>
     比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。
    </p>
    <p>
    </p>
    <h3>
     1.3 装饰器语法糖
    </h3>
    <p>
     python提供了@符号作为装饰器的语法糖，使我们更方便的应用装饰函数。但使用语法糖要求装饰函数必须return一个函数对象。因此我们将上面的func函数使用内嵌函数包裹并return。
    </p>
    <h4>
     1.3.1 函数装饰器
    </h4>
    <p>
     （1）不带参数装饰器，不带参数函数
    </p>
    <pre><code class="language-python">def use_logging(func):
  def _deco():
    print("%s is running" % func.__name__)
    func()
  return _deco
@use_logging
def bar():
  print('i am bar')
if __name__ == '__main__':
    bar()</code></pre>
    <p>
     装饰器相当于执行了装饰函数use_loggin后又返回被装饰函数bar,因此bar()被调用的时候相当于执行了两个函数。等价于use_logging(bar)()。
    </p>
    <p>
     执行结果：
    </p>
    <p>
     bar is running
     <br/>
     i am ba
    </p>
    <p>
     （2）不带参数装饰器，带参数函数
    </p>
    <pre><code class="language-python">def use_logging(func):
  def _deco(a, b):
    print("%s is running" % func.__name__)
    func(a, b)
  return _deco
@use_logging
def bar(a, b):
  print('i am bar:%s'%(a+b))
if __name__ == '__main__':
    bar(1, 2)</code></pre>
    <p>
     参数需要传入两个参数并计算值，因此我们需要对内层函数进行改动传入我们的两个参数a和b，等价于use_logging(bar)(1,2)
    </p>
    <p>
     输出结果：
    </p>
    <p>
     bar is running
     <br/>
     i am bar:3
    </p>
    <p>
     （3）不带参数装饰器，带不定参数函数
    </p>
    <pre><code class="language-python">def use_logging(func):
  def _deco(*args, **kwargs):
    print("%s is running" % func.__name__)
    func(*args, **kwargs)
  return _deco
@use_logging
def bar(a, b):
  print('i am bar:%s'%(a+b))
@use_logging
def foo(a, b, c):
  print('i am bar:%s'%(a+b+c))
if __name__ == '__main__':
    bar(1, 2)
    foo(1, 2, 3)</code></pre>
    <p>
     输出结果：
    </p>
    <p>
     bar is running
     <br/>
     i am bar:3
     <br/>
     foo is running
     <br/>
     i am bar:6
    </p>
    <p>
     （4）带参数装饰器，带参数函数
    </p>
    <pre><code class="language-python">def use_logging(level):
  def _deco(func):
    def __deco(*args, **kwargs):
      if level == "warn":
        print "%s is running" % func.__name__
      return func(*args, **kwargs)
    return __deco
  return _deco
@use_logging(level="warn")
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)</code></pre>
    <p>
     等价于use_logging(level="warn")(bar)(1,3)
    </p>
    <p>
     （5）使用functools.wraps
    </p>
    <p>
     使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表
    </p>
    <pre><code class="language-python">def use_logging(func):
  def _deco(*args,**kwargs):
    print("%s is running" % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()</code></pre>
    <p>
     输出结果：
    </p>
    <p>
     <code>
      #bar is running
     </code>
    </p>
    <p>
     <code>
      #i am bar
     </code>
    </p>
    <p>
     <code>
      #_deco
     </code>
    </p>
    <p>
     函数名变为_deco而不是bar，即装饰器装饰完之后，我们被装饰的函数的名字会变成装饰器函数。
    </p>
    <p>
     增加
     <code>
      @functools.wraps(f)
     </code>
     , 可以保持当前装饰器去装饰的函数的
     <code>
      __name__
     </code>
     的值不变
    </p>
    <pre><code class="language-python">import functools
def use_logging(func):
  @functools.wraps(func)
  def _deco(*args,**kwargs):
    print("%s is running" % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()</code></pre>
    <h4>
     1.3.2 类装饰器
    </h4>
    <pre><code class="language-python">class loging(object):
  def __init__(self,level="warn"):
    self.level = level
  def __call__(self,func):
    @functools.wraps(func)
    def _deco(*args, **kwargs):
      if self.level == "warn":
        self.notify(func)
      return func(*args, **kwargs)
    return _deco
  def notify(self,func):
    # logit只打日志，不做别的
    print "%s is running" % func.__name__
@loging(level="warn")#执行__call__方法
def bar(a,b):
  print('i</code></pre>
    <p>
     继承类装饰器
    </p>
    <pre><code class="language-python">class email_loging(Loging):
  '''
  一个loging的实现版本，可以在函数调用时发送email给管理员
  '''
  def __init__(self, email='admin@myproject.com', *args, **kwargs):
    self.email = email
    super(email_loging, self).__init__(*args, **kwargs)
  def notify(self,func):
    # 发送一封email到self.email
    print "%s is running" % func.__name__
    print "sending email to %s" %self.email
@email_loging(level="warn")
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)</code></pre>
    <p>
     参考文献：
    </p>
    <p>
     【1】
     <a href="https://www.runoob.com/w3cnote/python-func-decorators.html" rel="nofollow" title="Python 函数装饰器 | 菜鸟教程">
      Python 函数装饰器 | 菜鸟教程
     </a>
    </p>
    <p>
     【2】
     <a href="https://www.zhihu.com/question/26930016/answer/1047233982" rel="nofollow" title="如何理解Python装饰器？ - 知乎">
      如何理解Python装饰器？ - 知乎
     </a>
    </p>
    <p>
     【3】
     <a href="https://www.cnblogs.com/arvin-feng/p/11108799.html" rel="nofollow" title="Python装饰器用法实例总结 - arvin_feng - 博客园">
      Python装饰器用法实例总结 - arvin_feng - 博客园
     </a>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f6b656e6a69616e7169313634372f:61727469636c652f64657461696c732f313233393838353732" class_="artid" style="display:none">
 </p>
</div>


