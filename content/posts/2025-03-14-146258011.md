---
layout: post
title: "涨薪技术Kubernetesk8s之Pod生命周期下"
date: 2025-03-14 15:08:57 +0800
description: "上次推文我们学习了Pod生命周期（上）知识：相位、创建与终止、初始化容器，今天继续分享完余下的3个知识：钩子函数、容器探测、重启策略。钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。k8s在主容器的启动之后和停止之前提供了两个钩子函数.post start：容器创建之后执行，如果失败了会重启容器;pre stop：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作;钩子处理器支持使用下面定义动作：1)Exec命令：在容器内执行一次命令。"
keywords: "涨薪技术|Kubernetes(k8s)之Pod生命周期(下)"
categories: ['未分类']
tags: ['容器', '单元测试', '功能测试', '云原生', 'Kubernetes']
artid: "146258011"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146258011
    alt: "涨薪技术Kubernetesk8s之Pod生命周期下"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146258011
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146258011
cover: https://bing.ee123.net/img/rand?artid=146258011
image: https://bing.ee123.net/img/rand?artid=146258011
img: https://bing.ee123.net/img/rand?artid=146258011
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     涨薪技术|Kubernetes(k8s)之Pod生命周期(下)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     上次推文我们学习了Pod生命周期（上）知识：相位、创建与终止、初始化容器，今天继续分享完余下的3个知识：钩子函数、容器探测、重启策略。
    </p>
    <h3>
     <strong>
      01钩子函数
     </strong>
    </h3>
    <p>
     钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。
    </p>
    <p>
     k8s在主容器的启动之后和停止之前提供了两个钩子函数.
    </p>
    <ul>
     <li>
      <p>
       post start：容器创建之后执行，如果失败了会重启容器;
      </p>
     </li>
     <li>
      <p>
       pre stop：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作;
      </p>
     </li>
    </ul>
    <p>
     钩子处理器支持使用下面
     <strong>
      三种方式
     </strong>
     定义动作：
    </p>
    <p>
     1)Exec命令：在容器内执行一次命令
    </p>
    <pre><code>......</code><code>lifecycle:</code><code>postStart:</code><code>exec:</code><code>command:</code><code>- cat</code><code>- /tmp/healthy</code><code>......</code></pre>
    <p>
     2)TCPSocket：在当前容器尝试访问指定的socket
    </p>
    <pre><code>......</code><code>lifecycle:</code><code>postStart:</code><code>tcpSocket:</code></pre>
    <p>
     3)HttpGet：在当前容器中向某url发起http请求
    </p>
    <pre><code>......</code><code>lifecycle:</code><code>postStart:</code><code>httpGet:</code><code>path: #uri地址</code><code>port:</code><code>host:</code><code>scheme: HTTP #支持的协议，http或者https</code><code>......</code></pre>
    <p>
     下面演示钩子函数的使用
    </p>
    <p>
     创建pod-hook-exec.yaml文件，内容如下：​​​​​​​
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>name: pod-hook-exec</code><code>namespace: dev</code><code>spec:</code><code>containers:</code><code>- name: main-container</code><code>image: nginx:1.17.1</code><code>ports:</code><code>- name: nginx-port</code><code>containerPort: 80</code><code>lifecycle:</code><code>postStart:</code><code>exec: #在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</code><code>command: ["/bin/sh","-c","echo postStart... &gt;</code><code>/usr/share/nginx/html/index.html"]</code><code>preStop: #在容器停止之前停止nginx服务</code><code>exec:</code><code>command: ["/usr/sbin/nginx","-s","quit"]</code></pre>
    <p>
     使用配置文件​​​​​​​
    </p>
    <pre><code>[root@master ~]# vim pod-hook-exec.yaml</code><code>[root@master ~]# kubectl create -f pod-hook-exec.yaml</code><code>pod/pod-hook-exec created</code><code>[root@master ~]# kubectl get pod pod-hook-exec -n test -o wide</code><code>NAME READY STATUS RESTARTS AGE IP NODE</code><code>NOMINATED NODE READINESS GATES</code><code>pod-hook-exec 1/1 Running 0 34s 10.244.104.24 node2</code><code>&lt;none&gt; &lt;none&gt;</code><code>[root@master ~]# curl 10.244.104.24:80</code><code>postStart...</code></pre>
    <p>
    </p>
    <h3>
     <strong>
      02容器探测
     </strong>
    </h3>
    <p>
     容器探测用于检测容器中的应用实例是否能正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么K8S就会把该问题实例“摘除”，不承担业务流量，k8s提供了两种探针来实现容器探测，分别是：
    </p>
    <ul>
     <li>
      <p>
       livenessprobes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器;
      </p>
     </li>
     <li>
      <p>
       readinessprobes：就绪性探针，用于检测应用实例当前是否可以接受请求，如果不能，k8s不会转发流量;
      </p>
     </li>
    </ul>
    <p>
     即livenessProbe决定是否重启容器，readinesProbe决定是否将请求转发给容器。
    </p>
    <ul>
     <li>
      <p>
       startupProbe：使用启动探针来了解应用容器何时启动，如果配置了这个类探针，就可以控制容器在启动成功后再进行存活性liveness和就绪态readiness的检查，确保存活、就绪探针不会影响应用的启动。
      </p>
     </li>
    </ul>
    <h4>
     <strong>
      探针参数
     </strong>
    </h4>
    <p>
     探针有很多配置参数，可以使用这些参数精确地控制启动、存活和就绪检测的行为。
    </p>
    <p>
     --initialDelaySeconds：容器启动后要等待多少秒后才启动存活、就绪和启动探针， 默认是 0 秒，最小值是 0；
    </p>
    <p>
     --periodSeconds：执行探测的时间间隔（单位是秒），默认是 10 秒，最小值是 1；
    </p>
    <p>
     --timeoutSeconds：探测的超时后等待多少秒，默认值是 1 秒，最小值是 1；
    </p>
    <p>
     --successThreshold：连续探测成功多少次才被认定为执行成功，默认值是 1，存活和启动探测的这个值必须是 1，最小值是1；
    </p>
    <p>
     --failureThreshold：连续探测失败多少次才被认定为执行失败。对于存活探测而言，失败就意味着重新启动容器。对就绪探测而言，失败意味着 Pod 会被打上未就绪的标签，默认值是 3，最小值是 1；
    </p>
    <p>
     上面两种探针目前均支持三种探测方式：
    </p>
    <p>
     1)Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常​​​​​​​
    </p>
    <pre><code>......</code><code>livenessProbe:</code><code>exec:</code><code>command:</code><code>- cat</code><code>- /tmp/healthy</code><code>......</code></pre>
    <p>
     创建文件exec-liveness.yaml​​​​​​​
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>labels:</code><code>app: liveness</code><code>name: liveness-exec</code><code>namespace: probe</code><code>spec:</code><code>containers:</code><code>- name: tomcat</code><code>image: tomcat:latest</code><code>args:</code><code>- /bin/sh</code><code>- -c</code><code>- touch /tmp/liveness-pod; sleep 30; rm -f /tmp/liveness-pod; sleep 100</code><code>livenessProbe:</code><code>exec:</code><code>command:</code><code>- cat</code><code>- /tmp/liveness-pod</code><code>initialDelaySeconds: 5</code><code>periodSeconds: 5</code></pre>
    <p>
     在配置文件中，periodSeconds 字段指定了 kubelet 每 5 秒执行一次存活探测。initialDelaySeconds指定 kubelet 在执行第一次探测前应该等待 5 秒。kubelet 在容器内执行命令 cat /tmp/liveness 来进行探测， 如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的，如果这个命令返回非0值，kubelet 会杀死这个容器并重新启动它在容器启动时，将执行如下命令：
    </p>
    <pre><code>/bin/sh -c "touch /tmp/liveness; sleep 30; rm -f /tmp/liveness; sleep 300"</code></pre>
    <p>
     容器生命的前 30 秒，/tmp/liveness 文件是存在的，即在容器启动后的 30 秒内，执行命令 cat/tmp/liveness 会返回成功，30 秒之后文件被删除，再次执行命令 cat /tmp/liveness 时就会返回失败，kubectl则会对容器进行重启操作。
    </p>
    <p>
     创建Pod
    </p>
    <pre><code>[root@master ~]# kubectl apply -f exec-liveness.yaml</code></pre>
    <p>
     30秒内查看pod的状态
    </p>
    <pre><code>[root@master ~]# kubectl describe pod liveness-exec -n test</code></pre>
    <p>
     输出结果显示pod创建成功​​​​​​​
    </p>
    <pre><code>Events:</code><code>Type Reason Age From Message</code><code>---- ------ ---- ---- -------</code><code>Normal Scheduled 9s Successfully assigned test/livenessexec</code><code>to node2</code><code>Normal Pulling 8s kubelet, node2 Pulling image "nginx:latest"</code><code>Normal Pulled 4s kubelet, node2 Successfully pulled image</code><code>"nginx:latest" in 3.344637979s</code><code>Normal Created 4s kubelet, node2 Created container nginx</code><code>Normal Started 4s kubelet, node2 Started container nginx</code></pre>
    <p>
     等到35秒再次查看pod的状态，显示liveness探测失败，Container nginx failed liveness probe, willbe restarted\n Container nginx failed liveness probe, will be restarted，容器被重启。​​​​​​​
    </p>
    <pre><code>Events:</code><code>Type Reason Age From Message</code><code>---- ------ ---- ---- -------</code><code>Normal Scheduled 2m41s Successfully assigned</code><code>test/liveness-exec to node2</code><code>Normal Pulled 2m37s kubelet, node2 Successfully pulled</code><code>image "nginx:latest" in 3.344637979s</code><code>Normal Pulled 81s kubelet, node2 Successfully pulled</code><code>image "nginx:latest" in 3.13232767s</code><code>Warning Unhealthy 39s (x6 over 2m4s) kubelet, node2 Liveness probe failed:</code><code>cat: /tmp/liveness-pod: No such file or directory</code><code>Normal Killing 39s (x2 over 114s) kubelet, node2 Container nginx failed</code><code>liveness probe, will be restarted</code><code>Normal Pulling 9s (x3 over 2m41s) kubelet, node2 Pulling image</code><code>"nginx:latest"</code><code>Normal Created 5s (x3 over 2m37s) kubelet, node2 Created container</code><code>nginx</code><code>Normal Started 5s (x3 over 2m37s) kubelet, node2 Started container</code><code>nginx</code><code>Normal Pulled 5s kubelet, node2 Successfully pulled</code><code>image "nginx:latest" in 3.870334984s</code></pre>
    <p>
     此时查看pod状态，显示容器重启次数增加了1​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get pod liveness-exec -n test</code><code>NAME READY STATUS RESTARTS AGE</code><code>liveness-exec 1/1 Running 2 3m27s</code></pre>
    <p>
     TCPSocket：将会尝试访问同一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常​​​​​​​
    </p>
    <pre><code>......</code><code>livenessProbe:</code><code>tcpSocket:</code><code>port: 8080</code><code>......</code></pre>
    <p>
     创建http-liveness.yaml​​​​​​​
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>labels:</code><code>app: liveness</code><code>name: liveness-http</code><code>namespace: test</code><code>spec:</code><code>containers:</code><code>- name: nginx</code><code>image: nginx:latest</code><code>livenessProbe:</code><code>httpGet:</code><code>path: /test</code><code>port: 80</code><code>scheme: HTTP</code><code>httpHeaders:</code><code>- name: Accept</code><code>value: application/json</code><code>initialDelaySeconds: 5</code><code>periodSeconds: 5</code></pre>
    <p>
     在配置文件中，periodSeconds 指定了 kubelet 应该每 5 秒执行一次存活探测，initialDelaySeconds指定 kubelet 在容器启动后等待 5 秒再开始探测。kubelet 会向容器内运行的服务（host-默认为pod的ip，port为80）发送一个HTTP GET 请求来执行探测， 如果服务器上 "/" 路径下的处理程序返回成功，则 kubelet 认为容器是健康存活的，如果处理程序返回失败，则 kubelet 会杀死这个容器并将其重启
    </p>
    <p>
     判断标准：返回大于或等于 200 并且小于 400 的任何代码都标示成功，其它返回代码都标示失败;
    </p>
    <p>
     创建pod​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl apply -f http-liveness.yaml</code><code>pod/liveness-http created</code></pre>
    <p>
     此时，kubelet访问的探测地址为http://podid:80/abc，因容器内nginx服务不存在该路径地址，则会返回404状态码，查看pod状态显示健康检查失败，Liveness probe failed: HTTP probe failed with  statuscode: 404，kubelet 会杀死容器并再次重新启动容器。​​​​​​​
    </p>
    <pre><code>Events:</code><code>Type Reason Age From Message</code><code>---- ------ ---- ---- -------</code><code>Normal Scheduled 14m Successfully assigned</code><code>test/liveness-http to master</code><code>Normal Pulled 11m kubelet, master Successfully pulled</code><code>image "nginx:latest" in 2m17.669916167s</code><code>Normal Pulled 11m kubelet, master Successfully pulled</code><code>image "nginx:latest" in 3.366871547s</code><code>Normal Created 11m (x3 over 11m) kubelet, master Created container</code><code>nginx</code><code>Normal Pulled 11m kubelet, master Successfully pulled</code><code>image "nginx:latest" in 3.539110367s</code><code>Normal Started 11m (x3 over 11m) kubelet, master Started container</code><code>nginx</code><code>Normal Killing 10m (x3 over 11m) kubelet, master Container nginx</code><code>failed liveness probe, will be restarted</code><code>Normal Pulling 10m (x4 over 14m) kubelet, master Pulling image</code><code>"nginx:latest"</code><code>Warning Unhealthy 9m9s (x18 over 11m) kubelet, master Liveness probe</code><code>failed: HTTP probe failed with statuscode: 404</code><code>Warning BackOff 4m3s (x28 over 10m) kubelet, master Back-off restarting</code><code>failed container</code></pre>
    <p>
     HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常。​​​​​​​
    </p>
    <pre><code>......</code><code>lifecycle:</code><code>postStart:</code><code>httpGet:</code><code>path: #uri地址</code><code>port:</code><code>host:</code><code>scheme: HTTP #支持的协议，http或者https</code><code>......</code></pre>
    <p>
     TCP 检测的配置和 HTTP 检测方式相近，只需要配置端口即可。如果能建立连接，这个容器就被看作是健康的，脚本片断如下：
    </p>
    <pre><code>containers:</code><code>- name: nginx</code><code>image: nginx:latest</code><code>readinessProbe:</code><code>tcpSocket:</code><code>port: 8080</code><code>initialDelaySeconds: 5</code><code>periodSeconds: 10</code><code>livenessProbe:</code><code>tcpSocket:</code><code>port: 8080</code><code>initialDelaySeconds: 15</code><code>periodSeconds: 20</code></pre>
    <p>
    </p>
    <h3>
     <strong>
      03重启策略
     </strong>
    </h3>
    <p>
     重启策略：Pod在遇到故障之后重启的动作
    </p>
    <ul>
     <li>
      <p>
       1. Always：当容器终止退出后，总是重启容器，默认策略
      </p>
     </li>
     <li>
      <p>
       2. OnFailure：当容器异常退出（退出状态码非0）时，重启容器
      </p>
     </li>
     <li>
      <p>
       3. Never：当容器终止退出，从不重启容器。
      </p>
     </li>
    </ul>
    <p>
     （注意：k8s中不支持重启Pod资源，只有删除重建，重建）
    </p>
    <p>
     重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长为10s，20s，40s，80s，160s，300s，300s是最大延迟时长;
    </p>
    <p>
     重启策略设置建议：
    </p>
    <p>
     因为重启策略默认的就是Always，这也是合理的，因此在一般情况下，重启策略不需要设置，这里仅仅是作为知识点拿出来展示一下，在实际使用中，在大多数情况下都不需要进行重启策略配置。
    </p>
    <h4>
     <strong>
      1)Always
     </strong>
     ​​​​​​​
    </h4>
    <pre><code>[root@master test]# vim always.yaml</code><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>name: always-restart</code><code>namespace: test</code><code>spec:</code><code>containers:</code><code>- name: busybox</code><code>image: busybox</code><code>args:</code><code>- /bin/sh</code><code>- -c</code><code>- sleep 30; exit 3</code></pre>
    <p>
     创建pod
    </p>
    <pre><code>[root@master ~]# kubectl apply -f always.yaml</code></pre>
    <p>
     查看pod重启情况​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get pods -n test</code><code>NAME READY STATUS RESTARTS AGE</code><code>always-restart 0/1 Error 1 107s</code><code>[root@master ~]# kubectl describe pods always-restart -n test</code><code>Events:</code><code>Type Reason Age From Message</code><code>---- ------ ---- ---- -------</code><code>Normal Scheduled 4m6s Successfully assigned</code><code>test/always-restart to master</code><code>Normal Pulled 3m28s kubelet, master Successfully pulled</code><code>image "busybox" in 36.172410045s</code><code>Normal Pulled 2m54s kubelet, master Successfully pulled</code><code>image "busybox" in 3.248301356s</code><code>Normal Pulled 2m10s kubelet, master Successfully pulled</code><code>image "busybox" in 3.068738872s</code><code>Normal Created 73s (x4 over 3m28s) kubelet, master Created container</code><code>busybox</code><code>Normal Started 73s (x4 over 3m28s) kubelet, master Started container</code><code>busybox</code><code>Normal Pulled 73s kubelet, master Successfully pulled</code><code>image "busybox" in 3.686230207s</code><code>Warning BackOff 15s (x6 over 2m23s) kubelet, master Back-off restarting</code><code>failed container</code><code>Normal Pulling 1s (x5 over 4m4s) kubelet, master Pulling image</code><code>"busybox"</code></pre>
    <h4>
     <strong>
      2)never
     </strong>
     ​​​​​​​
    </h4>
    <pre><code>[root@master test]# vim never.yaml</code><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>name: never-always</code><code>namespace: test</code><code>spec:</code><code>containers:</code><code>- name: busybox</code><code>image: busybox</code><code>args:</code><code>- /bin/sh</code><code>- -c</code><code>- sleep 30; exit 3</code><code>restartPolicy: Never</code></pre>
    <p>
     创建pod​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl apply -f never.yaml</code><code>pod/never-restart created</code></pre>
    <p>
     查看pod重启情况​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get pod never-restart -n test</code><code>NAME READY STATUS RESTARTS AGE</code><code>never-restart 0/1 Error 0 73s</code></pre>
    <h4>
     <strong>
      3）onfailure
     </strong>
    </h4>
    <p>
     终止退出容器，并且是非零状态的退出​​​​​​​
    </p>
    <pre><code>[root@master test]# vim onfailure.yaml</code><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>name: onfailure1-restart</code><code>namespace: test</code><code>spec:</code><code>containers:</code><code>- name: busybox</code><code>image: busybox</code><code>args:</code><code>- /bin/sh</code><code>- -c</code><code>- sleep 20; exit 3</code><code>restartPolicy: OnFailure</code></pre>
    <p>
     创建pod​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl apply -f onfailure.yaml</code><code>pod/onfailure1-restart created</code></pre>
    <p>
     查看pod的状态​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get pod onfailure1-restart -n test</code><code>NAME READY STATUS RESTARTS AGE</code><code>onfailure1-restart 1/1 Running 2 74s</code></pre>
    <p>
     将退出状态改为0​​​​​​​
    </p>
    <pre><code>apiVersion: v1</code><code>kind: Pod</code><code>metadata:</code><code>name: onfailure1-restart</code><code>namespace: test</code><code>spec:</code><code>containers:</code><code>- name: busybox</code><code>image: busybox</code><code>args:</code><code>- /bin/sh</code><code>- -c</code><code>- sleep 20; exit 0</code><code>restartPolicy: OnFailure</code></pre>
    <p>
     创建pod​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl apply -f onfailure.yaml</code><code>pod/onfailure1-restart created</code></pre>
    <p>
     查看 pod状态​​​​​​​
    </p>
    <pre><code>[root@master ~]# kubectl get pod onfailure1-restart -n test</code><code>NAME READY STATUS RESTARTS AGE</code><code>onfailure1-restart 0/1 Completed 0 74s</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36303838393235342f:61727469636c652f64657461696c732f313436323538303131" class_="artid" style="display:none">
 </p>
</div>


