---
layout: post
title: "FlutterRust-Android,-IOS移动端适配通用流程及依赖库处理Openssl,-Curl等"
date: 2025-03-11 17:42:55 +0800
description: "在Flutter项目中调用rust的代码，简要概括整个逻辑，就是要把rust实现的那些函数方法**第一步先编译成对应架构对应平台的可执行文件，第二步按照对应平台的链接方式，把可执行文件链接到Flutter项目中去，第三步使用ffi方式去完成调用，调用可执行文件中的某个方法。本文会详细介绍整个流程并且给出依赖库的处理、文件的压缩、遇到的报错记录等。"
keywords: "flutter rust 开发android"
categories: ['未分类']
tags: ['Rust', 'Ios', 'Flutter', 'Android']
artid: "143908825"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=143908825
    alt: "FlutterRust-Android,-IOS移动端适配通用流程及依赖库处理Openssl,-Curl等"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=143908825
featuredImagePreview: https://bing.ee123.net/img/rand?artid=143908825
cover: https://bing.ee123.net/img/rand?artid=143908825
image: https://bing.ee123.net/img/rand?artid=143908825
img: https://bing.ee123.net/img/rand?artid=143908825
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Flutter+Rust Android, IOS移动端适配通用流程及依赖库处理（Openssl, Curl等）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_1">
     </a>
     引言
    </h2>
    <p>
     由于工作需求，需要在基于Flutter的移动端项目中使用到Rust实现的方法，整个适配过程比较曲折，而且由于Rust项目中有依赖Openssl等c库，涉及到一些报错，解决时走了很多弯路，所以记录下来希望能对大家起到帮助。
    </p>
    <p>
     本文首先梳理整个适配流程，从环境安装到项目配置、运行调用等，然后介绍我在实际操作中遇到的一些问题。
    </p>
    <ul>
     <li>
      如果需要引入的Rust项目比较简单，则阅读第一部分（一般流程）后基本就可以完成正常调用了；
     </li>
     <li>
      如果像我一样，Rust项目中涉及到Openssl或者其他依赖库，编译不成功或者调用不成功，在第二部分中我记录了遇到的报错情况和解决方法可以参考。
     </li>
    </ul>
    <h2>
     <a id="1__9">
     </a>
     1 一般流程
    </h2>
    <p>
     在Flutter项目中调用rust的代码，简要概括整个逻辑，就是要把rust实现的那些函数方法
     <strong>
      第一步先编译成对应架构对应平台的可执行文件
     </strong>
     ，第二步按照对应平台的链接方式，
     <strong>
      把可执行文件链接到Flutter项目中
     </strong>
     去，第三步
     <strong>
      使用ffi方式去完成调用
     </strong>
     ，调用可执行文件中的某个方法。如：
    </p>
    <ul>
     <li>
      Android平台需要把rust编译成支持arm64-v8a、x86_64、armabi-v7a架构的.so动态文件；
     </li>
     <li>
      IOS平台需要把rust编译成对应arm64或者x86架构的.a静态文件，或者同时支持两种架构的.a文件，以支持在真机或者在模拟器上的导入和使用。
     </li>
    </ul>
    <p>
     这部分会详细介绍这几个步骤。
    </p>
    <h3>
     <a id="11_windows_15">
     </a>
     1.1 基础环境配置（以windows环境为例）
    </h3>
    <h4>
     <a id="111_Rust_16">
     </a>
     1.1.1 Rust环境
    </h4>
    <p>
     下载地址：
     <a href="https://rustup.rs/" rel="nofollow">
      https://rustup.rs/
     </a>
     ，windows系统点击rustup-init.exe，mac系统按照提示安装。
     <br/>
     注意：这一步如果没安装过Visual Studio需要安装。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/33d813d401514d56ba8daecb410e29ce.png#pic_center">
      <br/>
      安装好后，打开命令行输入cargo --version检查是否安装成功：
     </img>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/6eb7bb6a816341d8b7f3799d3f726e27.png#pic_center">
      <br/>
      如果提示”不是内部或外部命令，也不是可运行程序“，请检查安装，检查环境变量的Path中是否存在cargo/bin，如下：
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fbd804fdd8864e59be758117c7481bfb.jpeg#pic_center"/>
     </img>
    </p>
    <h4>
     <a id="112_Rust_25">
     </a>
     1.1.2 Rust项目配置
    </h4>
    <p>
     在Cargo.toml中添加如下配置：
    </p>
    <pre><code class="prism language-rust"><span class="token punctuation">[</span>lib<span class="token punctuation">]</span>
<span class="token keyword">crate</span><span class="token operator">-</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"staticlib"</span><span class="token punctuation">,</span> <span class="token string">"cdylib"</span><span class="token punctuation">]</span>

<span class="token punctuation">[</span>build<span class="token operator">-</span>dependencies<span class="token punctuation">]</span>
flutter_rust_bridge_codegen <span class="token operator">=</span> <span class="token string">"=1.82.6"</span>
</code></pre>
    <ul>
     <li>
      crate-type：表示编译出的文件格式，staticlib为静态文件，cdylib为动态文件，一般前者用于ios，后者用于安卓。
     </li>
     <li>
      flutter_rust_bridge_codegen：用于自动生成ffi文件。
     </li>
    </ul>
    <h4>
     <a id="113_Android_38">
     </a>
     1.1.3 Android额外配置
    </h4>
    <p>
     一、安装LLVM
    </p>
    <ul>
     <li>
      运行命令：
      <code>
       winget install -e --id LLVM.LLVM
      </code>
     </li>
    </ul>
    <p>
     二、Android ndk安装
    </p>
    <ol>
     <li>
      通过Android Studio的SDK Manager安装NDK 23.1.7779620 ， 注意NDK必须为23版本，否则会报错：
     </li>
    </ol>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/34b7bc0ea5fe4175909f09a957aad6d0.png#pic_center"/>
    </p>
    <ol start="2">
     <li>
      安装cargo ndk：
      <br/>
      运行命令：
      <code>
       cargo install cargo-ndk
      </code>
     </li>
    </ol>
    <h3>
     <a id="12_Androidso_51">
     </a>
     1.2 Android编译.so动态文件
    </h3>
    <p>
     Android端做完以上准备以后，
     <strong>
      来到重点：将你的rust项目编译成适用于android三种架构的.so结尾的动态库
     </strong>
     ，以供app调用。
    </p>
    <ol>
     <li>
      <p>
       添加cargo的android编译工具：
       <br/>
       依次在命令行输入以下命令
      </p>
      <pre><code>rustup target add aarch64-linux-android
rustup target add armv7-linux-androideabi
rustup target add x86_64-linux-android
rustup target add i686-linux-android
</code></pre>
     </li>
     <li>
      <p>
       配置gradle.properties和local.properties：
       <br/>
       在
       <strong>
        android/gradle.properties
       </strong>
       中将ANDROID_NDK路径改为本地安装的路径
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/b1d08ef4d1b041e2bb633b990d522e26.jpeg#pic_center">
        <br/>
        在 android/local.properties 中加入NDK路径：
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ba282674d62e481c887652ec4bf75ae4.jpeg#pic_center">
         <br/>
         build.gradle添加配置（参考rust官方文档：
         <a href="https://trdthg.github.io/flutter_rust_bindgen_book_zh/" rel="nofollow">
          https://trdthg.github.io/flutter_rust_bindgen_book_zh/
         </a>
         ）
        </img>
       </img>
      </p>
      <pre><code>[
        new Tuple2('Debug', ''),
        new Tuple2('Profile', '--release'),
        new Tuple2('Release', '--release')
].each {
    def taskPostfix = it.first
    def profileMode = it.second
    tasks.whenTaskAdded { task -&gt;
        if (task.name == "javaPreCompile$taskPostfix") {
            task.dependsOn "cargoBuild$taskPostfix"
        }
    }
    tasks.register("cargoBuild$taskPostfix", Exec) {
        // Until https://github.com/bbqsrc/cargo-ndk/pull/13 is merged,
        // this workaround is necessary.

        def ndk_command = """cargo ndk \
            -t armeabi-v7a -t arm64-v8a -t x86_64 \
            -o ../android/app/src/main/jniLibs build $profileMode"""

        workingDir "../../rust"
        environment "ANDROID_NDK_HOME", "$ANDROID_NDK"
        if (org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem.isWindows()) {
            commandLine 'cmd', '/C', ndk_command
        } else {
            commandLine 'sh', '-c', ndk_command
        }
    }
}
</code></pre>
     </li>
    </ol>
    <p>
     添加完以后，运行app，运行过程中即会进行编译的步骤，将rust代码编译为.so的动态文件，在rust文件夹内对应的输出部分，或者在刚刚定义的：
    </p>
    <pre><code> def ndk_command = """cargo ndk \
	            -t armeabi-v7a -t arm64-v8a -t x86_64 \
	            -o ../android/app/src/main/jniLibs build $profileMode"""
</code></pre>
    <p>
     即android/app/src/main/jinLibs中能够找到。
    </p>
    <h3>
     <a id="13_IOSa_108">
     </a>
     1.3 IOS编译.a静态文件
    </h3>
    <p>
     ios这边使用命令：
    </p>
    <pre><code class="prism language-rust">cargo lipo <span class="token operator">-</span><span class="token operator">-</span>release
</code></pre>
    <p>
     去生成一个universal的通用文件（适用于ios模拟器和真机架构），会在你的rust目录里面找到一个.a结尾的静态文件。如果有一些dylib相关的报错，则可以先将Cargo.toml中的配置：
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">crate</span><span class="token operator">-</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"staticlib"</span><span class="token punctuation">,</span> <span class="token string">"cdylib"</span><span class="token punctuation">]</span>
</code></pre>
    <p>
     改为
    </p>
    <pre><code class="prism language-rust"><span class="token keyword">crate</span><span class="token operator">-</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"staticlib"</span><span class="token punctuation">]</span>
</code></pre>
    <p>
     即只编译静态库。
    </p>
    <h3>
     <a id="14_Flutter_124">
     </a>
     1.4 可执行文件链接到Flutter项目
    </h3>
    <ul>
     <li>
      Android端在编译得到三个架构下的.so文件以后，如果rust代码没有任何改动，在build.gradle中加入的编译指令就不需要了，不然每次运行app的时候都会重新编译rust代码。
     </li>
     <li>
      ios端是需要添加一些xcode配置，以便每次运行时能够被找到并且链接到app中。
     </li>
    </ul>
    <h4>
     <a id="141_Android_129">
     </a>
     1.4.1 Android配置
    </h4>
    <p>
     安卓这边在执行build.gradle的编译指令时会将输入自动copy到jinLibs的对应架构的位置。无需做额外配置。
     <br/>
     <img alt="可执行文件在安卓配置中的位置" src="https://i-blog.csdnimg.cn/direct/4436c7f64426417c96febb8c6e3fa52e.png"/>
    </p>
    <h4>
     <a id="142_IOS_132">
     </a>
     1.4.2 IOS配置
    </h4>
    <p>
     ios这边需要在xcode中进行配置，在xcode中打开项目，在Build Phases -&gt; Link Binary With Libraries中添加.a文件，这一步
     <strong>
      可以事先把.a文件复制到ios目录下
     </strong>
     ，因为在实际链接以后，我在运行项目并且调用时时常产生找不到的情况。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/4bd654b058ae4db18c2eab0817ec66de.png"/>
     <br/>
     另外图片中链接了多个.a文件，这个是对依赖库的一个处理，较为简单的rust项目可以忽略，只链接刚刚编译出来的.a文件即可。
    </p>
    <h3>
     <a id="15__136">
     </a>
     1.5 运行和调用
    </h3>
    <p>
     启动app以后，调用rust方法，就需要用到ffi的方式。
     <br/>
     在flutter的pubspec.yaml中添加配置：
    </p>
    <pre><code class="prism language-dart">dependencies<span class="token punctuation">:</span>
	ffi<span class="token punctuation">:</span> <span class="token number">2.1</span><span class="token number">.3</span>
	flutter_rust_bridge<span class="token punctuation">:</span> <span class="token number">1.82</span><span class="token number">.6</span>		# 用于自动生成ffi，如果采用手写方式则不需要
</code></pre>
    <p>
     注意如果采用自动生成方式，flutter_rust_bridge的版本号要和rust项目中的Cargo.toml中的对应。
    </p>
    <h4>
     <a id="151_FFI_146">
     </a>
     1.5.1 FFI方式
    </h4>
    <p>
     一、自动生成ffi
     <br/>
     在flutter项目目录下运行：
    </p>
    <pre><code class="prism language-dart">flutter_rust_bridge_codegen <span class="token operator">-</span>r rust<span class="token operator">/</span>src<span class="token operator">/</span>api<span class="token punctuation">.</span>rs <span class="token operator">-</span>d lib<span class="token operator">/</span>ffi<span class="token operator">/</span>rust_ffi<span class="token operator">/</span>rust_ffi<span class="token punctuation">.</span>dart <span class="token operator">-</span>c ios<span class="token operator">/</span><span class="token class-name">Runner</span><span class="token operator">/</span>bridge_generated<span class="token punctuation">.</span>h
</code></pre>
    <p>
     记得把-r后面的路径改为自己rust项目的入口文件的路径，-d后面的路径为生成的dart ffi文件的路径，最后-c后面是生成c语言的头文件，这个也需要配置到ios的项目中去，里面列出了rust 库导出的符号，这样可以使xcode在编译项目时不会把这些符号去除。
     <br/>
     在我的项目场景中是手写ffi的形式，没有使用到这个头文件，且运行中也没有产生问题，所以关于头文件的配置可以参考这一篇博客：
     <br/>
     <a href="https://juejin.cn/post/7176077601746714681?searchId=2024030718150489847D6C64B6A7AA5D5B#heading-17" rel="nofollow">
      Flutter和Rust如何优雅的交互
     </a>
    </p>
    <p>
     二、调用
    </p>
    <pre><code class="prism language-dart"><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'dart:ffi'</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string-literal"><span class="token string">'dart:io'</span></span><span class="token punctuation">;</span>

<span class="token comment">/// 用于读取并返回链接到项目中的可执行文件</span>
<span class="token keyword">class</span> <span class="token class-name">NativeFFI</span> <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">NativeFFI</span><span class="token punctuation">.</span><span class="token function">_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">static</span> <span class="token class-name">DynamicLibrary</span><span class="token operator">?</span> _dyLib<span class="token punctuation">;</span>

  <span class="token keyword">static</span> <span class="token class-name">DynamicLibrary</span> <span class="token keyword">get</span> dyLib <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_dyLib <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> _dyLib<span class="token operator">!</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> base <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'rust'</span></span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Platform</span><span class="token punctuation">.</span>isIOS<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      _dyLib <span class="token operator">=</span> <span class="token class-name">DynamicLibrary</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Platform</span><span class="token punctuation">.</span>isAndroid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      _dyLib <span class="token operator">=</span> <span class="token class-name">DynamicLibrary</span><span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'lib</span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">base</span></span><span class="token string">.so'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">throw</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'DynamicLibrary initialization failed'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> _dyLib<span class="token operator">!</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <pre><code class="prism language-dart"><span class="token keyword">class</span> <span class="token class-name">NativeFun</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> _ffi <span class="token operator">=</span> <span class="token class-name">RustFfiImpl</span><span class="token punctuation">(</span><span class="token class-name">NativeFFI</span><span class="token punctuation">.</span>dyLib<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// RustFfiImpl为第一步中由flutter_rust_bridge生成的ffi</span>

  <span class="token keyword">static</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span>int<span class="token punctuation">&gt;</span></span> <span class="token function">add</span><span class="token punctuation">(</span>int left<span class="token punctuation">,</span> int right<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{<!-- --></span>
    int sum <span class="token operator">=</span> <span class="token keyword">await</span> _ffi<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>left<span class="token punctuation">:</span> left<span class="token punctuation">,</span> right<span class="token punctuation">:</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     在需要调用rust方法的地方，调用：
    </p>
    <pre><code class="prism language-dart"><span class="token keyword">final</span> sum <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token class-name">NativeFun</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     将会输出3，表明成功调用了rust。到这一步为止可以认为整个流程成功。
     <br/>
     如果是手写的ffi，即不用flutter_rust_bridge去生成RustFfiImpl，则把这一部分替换成写好的ffi即可。
    </p>
    <h2>
     <a id="2__204">
     </a>
     2 依赖库处理
    </h2>
    <p>
     由于我这边实际情况下要引入的rust项目要复杂一些，rust编写的函数中涉及到openssl等库，所以实际调用的时候会报错找不到method，最后发现是依赖库没有和rust一起编译成二进制可执行文件。
     <br/>
     尝试了两种方法：
    </p>
    <ul>
     <li>
      在Cargo.toml中添加依赖库，企图一起编译成一个.so或者.a文件，但是最终失败了。
     </li>
     <li>
      将依赖库的.so或者.a文件和rust编译的文件一起链接到项目中，最后成功，步骤和1.4中的步骤相同。
     </li>
    </ul>
    <h3>
     <a id="21_Openssl_210">
     </a>
     2.1 Openssl库的处理
    </h3>
    <p>
     Openssl库，可以clone源文件自行编译成.so或者.a文件（比较麻烦一些），也可以在github去找编译好的现成的文件。
     <br/>
     安卓这边提供一个网址：
     <a href="https://builds.viaduck.org/prebuilts/openssl/3.1.5/" rel="nofollow">
      下载地址
     </a>
     安卓三个架构均要下载。
    </p>
    <h4>
     <a id="211_Android_213">
     </a>
     2.1.1 Android
    </h4>
    <p>
     在安卓中，将libcrypto.so，libssl.so和之前编译好的librust.so放置在一个位置，即jinLibs下对应架构的文件夹里
    </p>
    <h4>
     <a id="212_IOS_215">
     </a>
     2.1.2 IOS
    </h4>
    <p>
     ios这边可以从github中去找现成的编译项目，这边需要注意的是，.a文件需要使用fat文件，即支持i386和arm64两种架构的通用文件。
     <br/>
     采用1.4中的方法在xcode中进行链接。
    </p>
    <p>
     我这边需要链接这些：
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bb0b64a9e9fb4af38606a562a92e40d1.png"/>
    </p>
    <ul>
     <li>
      <p>
       报错1：链接以后还是会报一个flate2找不到的错误，解决方法是在Cargo.toml中添加这个库，在编译rust的时候编译进去：
      </p>
      <pre><code class="prism language-rust"><span class="token punctuation">[</span>dependencies<span class="token punctuation">]</span>
flate2 <span class="token operator">=</span> <span class="token string">"1.0"</span>
</code></pre>
     </li>
     <li>
      <p>
       报错2：运行中遇到zlib的报错，解决方法是在rust项目的根目录新建一个build.rs文件，写如下内容：
      </p>
      <pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Link zlib when build.</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"cargo:rustc-link-lib=static=z"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
       这样去辅助找到这个zlib库。
      </p>
     </li>
    </ul>
    <h2>
     <a id="3__239">
     </a>
     3 编译文件压缩
    </h2>
    <p>
     在实际应用场景，链接这些可执行文件以后，打包出的安装包大小会增大，所以需要降低编译文件的大小来缩小安装包大小。需要在Cargo.toml中添加如下配置：
    </p>
    <pre><code class="prism language-rust"><span class="token punctuation">[</span>profile<span class="token punctuation">.</span>release<span class="token punctuation">]</span>
lto <span class="token operator">=</span> <span class="token boolean">true</span>
opt<span class="token operator">-</span>level <span class="token operator">=</span> <span class="token char">'z'</span>
strip <span class="token operator">=</span> <span class="token boolean">true</span>
codegen<span class="token operator">-</span>units <span class="token operator">=</span> <span class="token number">1</span>
</code></pre>
    <p>
     这样的话release模式生成的.so和.a文件会有一定程度的压缩。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f4c696e6e6562756c612f:61727469636c652f64657461696c732f313433393038383235" class_="artid" style="display:none">
 </p>
</div>


