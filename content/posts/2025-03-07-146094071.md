---
layout: post
title: "Java-三路快排"
date: 2025-03-07 13:51:37 +0800
description: "数组中存在大量重复元素（如日志数据、用户行为数据）。不移动，因为交换后的新元素需要再次检查）。高效处理重复元素，避免传统快排的重复递归。通过一次遍历，将元素分配到正确区域。需要稳定排序但允许非稳定实现的情况。）是快速排序的优化版本，特别适用于。（大于区域）递归排序，中间区域。，从而减少不必要的递归和交换。"
keywords: "Java 三路快排"
categories: ['Java']
tags: ['Java']
artid: "146094071"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146094071
    alt: "Java-三路快排"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146094071
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146094071
cover: https://bing.ee123.net/img/rand?artid=146094071
image: https://bing.ee123.net/img/rand?artid=146094071
img: https://bing.ee123.net/img/rand?artid=146094071
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Java 三路快排
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     三路快速排序（
     <strong>
      3-Way QuickSort
     </strong>
     ）是快速排序的优化版本，特别适用于
     <strong>
      处理包含大量重复元素的数组
     </strong>
     。其核心思想是将数组划分为三个区域：
     <strong>
      小于基准值
     </strong>
     、
     <strong>
      等于基准值
     </strong>
     和
     <strong>
      大于基准值
     </strong>
     ，从而减少不必要的递归和交换
    </p>
    <h4>
     <strong>
      三路快排原理
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        分区逻辑
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         使用三个指针
         <code>
          lt
         </code>
         （less than）、
         <code>
          current
         </code>
         （当前遍历位置）、
         <code>
          gt
         </code>
         （greater than）将数组划分为三部分：
        </p>
        <ul>
         <li>
          <p>
           <code>
            [low, lt-1]
           </code>
           ：
           <strong>
            小于
           </strong>
           基准值的元素
          </p>
         </li>
         <li>
          <p>
           <code>
            [lt, gt]
           </code>
           ：
           <strong>
            等于
           </strong>
           基准值的元素
          </p>
         </li>
         <li>
          <p>
           <code>
            [gt+1, high]
           </code>
           ：
           <strong>
            大于
           </strong>
           基准值的元素
          </p>
         </li>
        </ul>
       </li>
       <li>
        <p>
         通过一次遍历，将元素分配到正确区域。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        时间复杂度
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <strong>
          平均
         </strong>
         ：
         <code>
          O(n log n)
         </code>
        </p>
       </li>
       <li>
        <p>
         <strong>
          最坏
         </strong>
         （大量重复元素时）：
         <code>
          O(n)
         </code>
         （优于传统快排的
         <code>
          O(n²)
         </code>
         ）
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <strong>
      Java 实现代码
     </strong>
    </h4>
    <pre><code class="language-java">public class ThreeWayQuickSort {

    public static void sort(int[] arr) {
        if (arr == null || arr.length &lt;= 1) return;
        threeWayQuickSort(arr, 0, arr.length - 1);
    }

    private static void threeWayQuickSort(int[] arr, int low, int high) {
        if (low &gt;= high) return;

        // 选择基准值（这里选第一个元素）
        int pivot = arr[low];
        int lt = low;      // 小于 pivot 的右边界
        int gt = high;     // 大于 pivot 的左边界
        int current = low; // 当前遍历指针

        while (current &lt;= gt) {
            if (arr[current] &lt; pivot) {
                swap(arr, lt, current);
                lt++;
                current++;
            } else if (arr[current] &gt; pivot) {
                swap(arr, current, gt);
                gt--;
            } else {
                current++;
            }
        }

        // 递归处理小于和大于区域
        threeWayQuickSort(arr, low, lt - 1);
        threeWayQuickSort(arr, gt + 1, high);
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
        sort(arr);
        System.out.println(Arrays.toString(arr)); 
        // 输出: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
    }
}</code></pre>
    <h4>
     <strong>
      关键步骤解析
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        初始化指针
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          lt
         </code>
         指向数组起始位置（
         <code>
          low
         </code>
         ），
         <code>
          gt
         </code>
         指向数组末尾（
         <code>
          high
         </code>
         ），
         <code>
          current
         </code>
         从
         <code>
          low
         </code>
         开始遍历。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        遍历与交换
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         如果
         <code>
          arr[current] &lt; pivot
         </code>
         ：将
         <code>
          current
         </code>
         与
         <code>
          lt
         </code>
         处的元素交换，
         <code>
          lt
         </code>
         和
         <code>
          current
         </code>
         均右移。
        </p>
       </li>
       <li>
        <p>
         如果
         <code>
          arr[current] &gt; pivot
         </code>
         ：将
         <code>
          current
         </code>
         与
         <code>
          gt
         </code>
         处的元素交换，
         <code>
          gt
         </code>
         左移（
         <code>
          current
         </code>
         不移动，因为交换后的新元素需要再次检查）。
        </p>
       </li>
       <li>
        <p>
         如果
         <code>
          arr[current] == pivot
         </code>
         ：直接移动
         <code>
          current
         </code>
         指针。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        递归处理子数组
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         对
         <code>
          [low, lt-1]
         </code>
         （小于区域）和
         <code>
          [gt+1, high]
         </code>
         （大于区域）递归排序，中间区域
         <code>
          [lt, gt]
         </code>
         已经有序。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      示例流程
     </strong>
    </h4>
    <p>
     假设初始数组为
     <code>
      [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
     </code>
     ，基准值
     <code>
      pivot=3
     </code>
     ：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        第一次分区后
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         小于区域：
         <code>
          [1, 1, 2]
         </code>
        </p>
       </li>
       <li>
        <p>
         等于区域：
         <code>
          [3, 3]
         </code>
        </p>
       </li>
       <li>
        <p>
         大于区域：
         <code>
          [4, 5, 9, 6, 5, 5]
         </code>
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       递归排序小于区域
       <code>
        [1, 1, 2]
       </code>
       和大于区域
       <code>
        [4, 5, 9, 6, 5, 5]
       </code>
       。
      </p>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      优势与适用场景
     </strong>
    </h4>
    <ul>
     <li>
      <p>
       <strong>
        优势
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         高效处理重复元素，避免传统快排的重复递归。
        </p>
       </li>
       <li>
        <p>
         减少元素交换次数。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        适用场景
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         数组中存在大量重复元素（如日志数据、用户行为数据）。
        </p>
       </li>
       <li>
        <p>
         需要稳定排序但允许非稳定实现的情况。
        </p>
       </li>
      </ul>
     </li>
    </ul>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f34303435333937322f:61727469636c652f64657461696c732f313436303934303731" class_="artid" style="display:none">
 </p>
</div>


