---
layout: post
title: "SpringMVC响应页面及不同类型的数据,"
date: 2025-03-13 20:29:19 +0800
description: "控制器（Controller）处理完客户端请求后，生成的并返回给客户端的结果就是响应，响应的结果可以是静态页面，数据，HTML片段等。"
keywords: "SpringMVC响应页面及不同类型的数据，"
categories: ['Springmvc']
tags: ['前端', 'Javascript', 'Java']
artid: "146199389"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146199389
    alt: "SpringMVC响应页面及不同类型的数据,"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146199389
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146199389
cover: https://bing.ee123.net/img/rand?artid=146199389
image: https://bing.ee123.net/img/rand?artid=146199389
img: https://bing.ee123.net/img/rand?artid=146199389
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringMVC响应页面及不同类型的数据，
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     控制器（Controller）处理完客户端请求后，生成的并返回给客户端的结果就是响应，响应的结果可以是静态页面，数据，HTML片段等。
    </p>
    <h2 id="%E5%93%8D%E5%BA%94%E9%A1%B5%E9%9D%A2" name="%E5%93%8D%E5%BA%94%E9%A1%B5%E9%9D%A2">
     响应页面
    </h2>
    <p>
     在springmvc中，跳转页面非常简单，只需返回一个字符串即可。
    </p>
    <pre><code class="language-java">    //响应页面，跳转页面
    @RequestMapping("/toJumpPage")
    public String toJumpPage(){
        System.out.println("跳转页面");
        return "page.jsp";
    }</code></pre>
    <p>
     打开浏览器输入：localhost:8080/toJumpPage，自动跳转到page.jsp。
    </p>
    <p>
     <img alt="" height="331" src="https://i-blog.csdnimg.cn/direct/3a1c5dd1b93a48c0b7ba5502056f6d15.png" width="1025"/>
    </p>
    <p>
    </p>
    <h2 id="%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE" name="%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE">
     响应数据
    </h2>
    <h3 id="%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE" name="%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE">
     文本数据
    </h3>
    <p>
     响应文本数据，需要加上@RequestBody注解
    </p>
    <pre><code class="language-java">    //响应文本数据
    @RequestMapping("/toText")
    @ResponseBody
    public String toText(){
        System.out.println("返回纯文本数据");
        return "response text";
    }</code></pre>
    <p>
     <img alt="" height="221" src="https://i-blog.csdnimg.cn/direct/1b4016d0f1494fd79fc224289e7bb3d2.png" width="870"/>
    </p>
    <h3 id="%E5%93%8D%E5%BA%94POJO%E5%AF%B9%E8%B1%A1%C2%A0" name="%E5%93%8D%E5%BA%94POJO%E5%AF%B9%E8%B1%A1%C2%A0">
     响应POJO对象
    </h3>
    <p>
     响应POJO对象，只需要修改方法返回值为POJO，同时也要添加上@ResponseBody注解：
    </p>
    <pre><code class="language-java">    @RequestMapping("/toJsonPOJO")
    @ResponseBody
    public User toJsonPOJO(){
        System.out.println("返回json对象数据");
        User user = new User();
        user.setName("springmvc");
        user.setAge(12);
        return user;
    }</code></pre>
    <p>
     <img alt="" height="185" src="https://i-blog.csdnimg.cn/direct/7753ae3b87d84c55878f2346dc1a36da.png" width="725"/>
    </p>
    <p>
     返回集合对象也是如此：
    </p>
    <pre><code class="language-java">    @RequestMapping("/toJsonPOJOList")
    @ResponseBody
    public List&lt;User&gt; toJsonPOJOList(){
        System.out.println("返回json对象数据集合");
        User user = new User();
        user.setName("spring");
        user.setAge(126);
        User user1 = new User();
        user1.setName("mvcspring");
        user1.setAge(99);
        List&lt;User&gt; list = new ArrayList&lt;&gt;();
        list.add(user);
        list.add(user1);
        return list;
    }</code></pre>
    <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
     <img alt="" height="301" src="https://i-blog.csdnimg.cn/direct/7004d937243b493f9afeb2374842e3d2.png" width="818"/>
    </h3>
    <p>
    </p>
    <h2 id="%E5%93%8D%E5%BA%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" name="%E5%93%8D%E5%BA%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" style="background-color:transparent">
     响应生命周期
    </h2>
    <blockquote>
     <ol>
      <li>
       请求接收：DispatcherServlet接收HTTP请求
      </li>
      <li>
       处理器映射：HandlerMapping找到对应的Controller方法
      </li>
      <li>
       方法执行：执行控制器逻辑并生成响应数据
      </li>
      <li>
       视图解析：ViewResolver解析逻辑视图名
      </li>
      <li>
       数据转换：HttpMessageConverter处理数据序列化
      </li>
      <li>
       响应返回：通过ServletResponse输出最终结果
      </li>
     </ol>
    </blockquote>
    <h2 id="%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%C2%A0" name="%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%C2%A0">
     视图解析器
    </h2>
    <p>
     视图解析器（ViewResolver）是 Spring MVC 的核心组件之一，负责将控制器返回的逻辑视图名称（如 "home"）转换为具体的物理视图资源（如 JSP、HTML 模板等）。其核心职责包括：
    </p>
    <blockquote>
     <ul>
      <li>
       路径映射：将逻辑视图名映射到实际文件路径（如 /WEB-INF/views/home.jsp）
      </li>
      <li>
       模板引擎支持：适配不同的视图技术（JSP、Thymeleaf、FreeMarker 等）
      </li>
      <li>
       视图优先级管理：支持多个视图解析器共存时的优先级控制
      </li>
      <li>
       安全性增强：防止直接暴露服务器文件路径
      </li>
     </ul>
    </blockquote>
    <pre><code class="language-java">@Configuration

public class WebConfig implements WebMvcConfigurer {
    @Bean
    public ViewResolver viewResolver() {
        //InternalResourceViewResolver是Spring MVC提供的一个视图解析器实现，它用于解析JSP文件作为视图。
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");  //设置视图文件的前缀路径
        resolver.setSuffix(".jsp");             //设置了视图文件的后缀
        return resolver;
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343338363739392f:61727469636c652f64657461696c732f313436313939333839" class_="artid" style="display:none">
 </p>
</div>


