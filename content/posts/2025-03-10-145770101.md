---
layout: post
title: "boostbeast-websocket-实例-"
date: 2025-03-10 13:19:59 +0800
description: "环境：ubuntu。"
keywords: "boost::beast websocket 实例 "
categories: ['杂项']
tags: ['Websocket', 'Boost']
artid: "145770101"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145770101
    alt: "boostbeast-websocket-实例-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145770101
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145770101
cover: https://bing.ee123.net/img/rand?artid=145770101
image: https://bing.ee123.net/img/rand?artid=145770101
img: https://bing.ee123.net/img/rand?artid=145770101
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     boost::beast websocket 实例
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     环境：ubuntu
    </p>
    <h2>
     1. 安装boost
    </h2>
    <pre><code class="language-bash">sudo apt install -y libboost-all-dev</code></pre>
    <h2>
     2. Server端
    </h2>
    <pre><code class="language-cpp">#include &lt;boost/asio.hpp&gt;
#include &lt;boost/beast.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

namespace beast = boost::beast; // 从 Boost.Beast 中导入命名空间
namespace websocket = beast::websocket;
namespace net = boost::asio;
using tcp = boost::asio::ip::tcp;

class WebSocketServer {
public:
    WebSocketServer(net::io_context&amp; ioc, short port)
        : acceptor_(ioc, tcp::endpoint(tcp::v4(), port)), socket_(ioc) {}

    void start() {
        accept();
    }

private:
    void accept() {
        acceptor_.async_accept(socket_,
            [this](beast::error_code ec) {
                if (!ec) {
                    std::cout &lt;&lt; "New connection established!" &lt;&lt; std::endl;
                    handleWebSocket(std::move(socket_));
                }
                // 继续接收下一个连接
                accept();
            });
    }

    void handleWebSocket(tcp::socket socket) {
        try {
            // 创建 WebSocket 流并进行握手
            websocket::stream&lt;tcp::socket&gt; ws(std::move(socket));
            ws.accept();

            std::cout &lt;&lt; "WebSocket handshake completed." &lt;&lt; std::endl;

            beast::flat_buffer buffer;
            while (true) {
                // 读取消息
                ws.read(buffer);
                std::string message = beast::buffers_to_string(buffer.data());
                std::cout &lt;&lt; "Received: " &lt;&lt; message &lt;&lt; std::endl;

                // 回显消息
                ws.write(net::buffer(message));

                // 清空缓冲区，准备接收下一条消息
                buffer.clear();
            }
        } catch (std::exception&amp; e) {
            std::cerr &lt;&lt; "WebSocket Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }

    tcp::acceptor acceptor_;
    tcp::socket socket_;
};

int main() {
    try {
        net::io_context ioc;

        short port = 8080; // 服务器端口
        WebSocketServer server(ioc, port);

        std::cout &lt;&lt; "WebSocket server listening on port " &lt;&lt; port &lt;&lt; "..." &lt;&lt; std::endl;

        // 启动服务器
        server.start();

        // 运行 IO 上下文
        ioc.run();
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; "Server Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
    <h4>
     <strong>
      代码解析
     </strong>
     ：
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         WebSocketServer
        </code>
        类
       </strong>
       ：
      </p>
      <ul>
       <li>
        在构造函数中，设置服务器的监听端口（
        <code>
         tcp::acceptor
        </code>
        ）。
       </li>
       <li>
        <code>
         start
        </code>
        方法启动
        <code>
         accept()
        </code>
        以异步接受新的连接。
       </li>
       <li>
        每个连接的 WebSocket 流通过
        <code>
         websocket::stream&lt;tcp::socket&gt;
        </code>
        来处理。
       </li>
       <li>
        在
        <code>
         handleWebSocket
        </code>
        中，读取客户端发送的消息，回显给客户端。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         main
        </code>
        函数
       </strong>
       ：
      </p>
      <ul>
       <li>
        创建
        <code>
         net::io_context
        </code>
        对象，该对象是 Boost.Asio 的核心，用于管理异步操作。
       </li>
       <li>
        创建并启动 WebSocket 服务器，监听端口
        <code>
         8080
        </code>
        。
       </li>
       <li>
        调用
        <code>
         ioc.run()
        </code>
        来启动 IO 服务的事件循环，保持服务器运行。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <strong>
      运行效果
     </strong>
     ：
    </h4>
    <ul>
     <li>
      <p>
       服务器会监听
       <code>
        8080
       </code>
       端口。
      </p>
     </li>
     <li>
      <p>
       当客户端连接时，服务器接收客户端发送的消息并回显。
      </p>
      <p>
       例如，当客户端发送消息
       <code>
        "Hello from client 0"
       </code>
       时，服务器会接收到该消息并回传
       <code>
        "Hello from client 0"
       </code>
       。
      </p>
     </li>
    </ul>
    <h2>
     3. Client 端
    </h2>
    <pre><code class="language-cpp">#include &lt;boost/asio.hpp&gt;
#include &lt;boost/beast.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

namespace beast = boost::beast; // 从 Boost.Beast 中导入命名空间
namespace websocket = beast::websocket;
namespace net = boost::asio;
using tcp = boost::asio::ip::tcp;

class WebSocketClient {
public:
    WebSocketClient(net::io_context&amp; ioc, const std::string&amp; host, const std::string&amp; port)
        : resolver_(ioc), ws_(ioc) {
        try {
            // 解析域名
            auto const results = resolver_.resolve(host, port);

            // 连接到 WebSocket 服务器
            net::connect(ws_.next_layer(), results.begin(), results.end());

            // 执行 WebSocket 握手
            ws_.handshake(host, "/");

            std::cout &lt;&lt; "Connected to " &lt;&lt; host &lt;&lt; ":" &lt;&lt; port &lt;&lt; std::endl;
        } catch (std::exception&amp; e) {
            std::cerr &lt;&lt; "WebSocket Connection Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }

    void sendMessage(const std::string&amp; message) {
        try {
            ws_.write(net::buffer(message));
            std::cout &lt;&lt; "Sent: " &lt;&lt; message &lt;&lt; std::endl;

            beast::flat_buffer buffer;
            ws_.read(buffer);
            std::cout &lt;&lt; "Received: " &lt;&lt; beast::buffers_to_string(buffer.data()) &lt;&lt; std::endl;
        } catch (std::exception&amp; e) {
            std::cerr &lt;&lt; "WebSocket Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }

private:
    tcp::resolver resolver_;
    websocket::stream&lt;tcp::socket&gt; ws_;
};

// 启动多个 WebSocket 客户端
void startClients(int num_clients, const std::string&amp; host, const std::string&amp; port) {
    net::io_context ioc;
    std::vector&lt;std::thread&gt; threads;

    for (int i = 0; i &lt; num_clients; ++i) {
        threads.emplace_back([&amp;, i] {
            WebSocketClient client(ioc, host, port);
            client.sendMessage("Hello from client " + std::to_string(i));
        });
    }

    for (auto&amp; t : threads) {
        t.join();
    }
}

int main() {
    std::string host = "127.0.0.1";           // WebSocket 服务器地址
    std::string port = "8080";                  // WebSocket 服务器端口
    int num_clients = 5;                      // 需要并发的 WebSocket 连接数

    startClients(num_clients, host, port);

    return 0;
}
</code></pre>
    <h4>
     <strong>
      关键点
     </strong>
    </h4>
    <ul>
     <li>
      使用
      <code>
       boost::asio::io_context
      </code>
      管理异步操作。
     </li>
     <li>
      每个 WebSocket 连接由一个独立线程维护。
     </li>
     <li>
      连接后发送消息并接收响应。
     </li>
    </ul>
    <h4>
     <strong>
      代码解析
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        <code>
         WebSocketClient
        </code>
        类
       </strong>
       ：
      </p>
      <ul>
       <li>
        解析服务器地址并连接 (
        <code>
         resolver_.resolve
        </code>
        和
        <code>
         net::connect
        </code>
        )。
       </li>
       <li>
        进行 WebSocket 握手 (
        <code>
         ws_.handshake
        </code>
        )。
       </li>
       <li>
        发送消息 (
        <code>
         ws_.write
        </code>
        ) 并读取服务器响应 (
        <code>
         ws_.read
        </code>
        )。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         startClients
        </code>
        函数
       </strong>
       ：
      </p>
      <ul>
       <li>
        通过
        <code>
         std::vector&lt;std::thread&gt;
        </code>
        创建多个线程，每个线程都运行一个 WebSocket 客户端实例。
       </li>
       <li>
        每个客户端连接到服务器后，发送
        <code>
         Hello from client N
        </code>
        消息并等待响应。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        <code>
         main
        </code>
        函数
       </strong>
       ：
      </p>
      <ul>
       <li>
        指定 WebSocket 服务器（默认使用
        <code>
         echo.websocket.org
        </code>
        进行回显测试）。
       </li>
       <li>
        启动 5 个并发 WebSocket 连接。
       </li>
      </ul>
     </li>
    </ol>
    <h2>
     4. 编译
    </h2>
    <pre><code class="language-bash">g++ server.cpp -o server
g++ client.cpp -o client
</code></pre>
    <p>
    </p>
    <h2>
     5. 运行
    </h2>
    <p>
     <img alt="" height="330" src="https://i-blog.csdnimg.cn/direct/052ff9e7eca8482cb87acbce56e68c43.png" width="389"/>
    </p>
    <p>
     <img alt="" height="241" src="https://i-blog.csdnimg.cn/direct/2f0919be4a3649468fe36ee08f3c8d44.png" width="527"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f796574796f6e676a696e2f:61727469636c652f64657461696c732f313435373730313031" class_="artid" style="display:none">
 </p>
</div>


