---
layout: post
title: "贪心算法-"
date: 2025-03-09 21:53:43 +0800
description: "28道经典贪心算法讲解， 分析"
keywords: "贪心算法--"
categories: ['算法']
tags: ['贪心算法', '算法']
artid: "145952007"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145952007
    alt: "贪心算法-"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145952007
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145952007
cover: https://bing.ee123.net/img/rand?artid=145952007
image: https://bing.ee123.net/img/rand?artid=145952007
img: https://bing.ee123.net/img/rand?artid=145952007
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     贪心算法--
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
    </p>
    <h3>
     1.柠檬水找零
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/lemonade-change/submissions/604773067" rel="nofollow" title="860. 柠檬水找零 - 力扣（LeetCode）">
      860. 柠檬水找零 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) {
        // 贪心算法， 优先花出大面额bill， 尽可能保护小面额bill
        int five = 0, ten = 0;// 不同bill数量
        for(int bill : bills)
        {
            if(bill == 5) five++;
            else if(bill == 10)
            {
                ten++;
                if(five &lt;= 0) return false;
                else five--;
            }
            else // bill == 20
            {
                if(five &gt;= 1 &amp;&amp; ten &gt;= 1) five--, ten--;// 贪心
                else if(five &gt;= 3) five -= 3;
                else return false;
            }
        }
        return true;
    }
};</code></pre>
    <h4>
     交换论证法 证明：
    </h4>
    <p>
     <img alt="" height="502" src="https://i-blog.csdnimg.cn/direct/ecc50924d399405e81ebfc932fe6a013.png" width="1035"/>
    </p>
    <p>
    </p>
    <h3>
     2.将数组和减半的最少操作次数
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/submissions/604783594" rel="nofollow" title="2208. 将数组和减半的最少操作次数 - 力扣（LeetCode）">
      2208. 将数组和减半的最少操作次数 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int halveArray(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        double sum = 0.0;
        priority_queue&lt;double&gt; q;
        for(int&amp; e : nums)
        {
            sum += e;
            q.push(e);
        }
        double target = sum/2.0;
        while(target &gt; 0)
        {
            ans++;
            double top = q.top(); q.pop();
            target -= top / 2;
            q.push(top / 2);
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <p>
     交换论证法 证明：
    </p>
    <p>
     <img alt="" height="451" src="https://i-blog.csdnimg.cn/direct/81b80a54b9cd43faa4a1ceb49d7d35c5.png" width="730"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h3>
     3.最大数
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/largest-number/submissions/604790032" rel="nofollow" title="179. 最大数 - 力扣（LeetCode）">
      179. 最大数 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     key：
    </p>
    <p>
     此问题中比较两个字符串大小：return a + b &gt; b + a， 而不是直接return  a &gt; b;
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) {
        vector&lt;string&gt; strs;
        for(int num:nums)
        {
            strs.push_back(to_string(num));
        }
        sort(strs.begin(), strs.end(), [](string a, string b){
            return a + b &gt; b + a;// key：不要直接使用内置的字典排序(return a &gt; b)
        });

        string ans;
        for(string str:strs) ans += str;
        if(ans[0] == '0') return "0";
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     4.摆动序列
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/wiggle-subsequence" rel="nofollow" title="376. 摆动序列 - 力扣（LeetCode）">
      376. 摆动序列 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     tips:
    </p>
    <p>
     本题也可以使用动态规划解决， 时间复杂度O（n^2)
    </p>
    <p>
     若使用贪心算法解决此问题，时间复杂度为O（n）
    </p>
    <p>
     本题中如何实现贪心？
    </p>
    <p>
     画出折线图， 选出所有极值即可。极值个数即为最长摆动序列长度
    </p>
    <p>
     证明贪心正确性：反证法或交换论证法
    </p>
    <p>
     code1:
    </p>
    <pre><code>class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        
        auto it = unique(nums.begin(), nums.end());
        nums.erase(it, nums.end());
        if(nums.size() &lt;= 2) return nums.size();
        int flag;// flag == 0表示摆动序列第一个为大值，1为小值
        flag = nums[0] &gt; nums[1] ? 0 : 1;
        int ans = 1;// 第一个一定参与
        for(int i = 1; i &lt; nums.size(); i++)
        {
            if(flag == 0)// 找极小值
            {
                if(nums[i] &lt; nums[i-1]) continue;
                else 
                {
                    ans++;
                    flag = !flag;
                }
            }
            else// 找极大值
            {
                if(nums[i] &gt; nums[i-1]) continue;
                else// nums[i-1]就是极大值
                {
                    ans++;
                    flag = !flag;
                }
            }
        }
        ans++; // 最后一个一定也为最长子序列
        return ans;
    }
};</code></pre>
    <p>
     code2:
    </p>
    <pre><code>class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        // 求 波峰个数 + 波谷个数即可
        auto it = unique(nums.begin(), nums.end());
        nums.erase(it, nums.end());
        if(nums.size() &lt;= 2) return nums.size();
        int ans = 2;// nums首尾都是波峰/波谷
        for(int i = 1; i &lt; nums.size() - 1; i++)// 判断除首尾的中间部分是否为波峰/波谷
        {
            if((nums[i] - nums[i-1]) * (nums[i] - nums[i+1]) &gt; 0)// nums[i]是波峰/波谷
            {
                ans++;
            }
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     5.最长递增子序列
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/longest-increasing-subsequence" rel="nofollow" title="300. 最长递增子序列 - 力扣（LeetCode）">
      300. 最长递增子序列 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心思路：
    </p>
    <p>
     只关心长度为x的递增子序列的
     <strong>
      最后元素的 最小值
     </strong>
    </p>
    <p>
     <img alt="" height="561" src="https://i-blog.csdnimg.cn/direct/3064cd914d524c76b9afe6a343186309.png" width="980"/>
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        // arr[i]:长度为i+1的严格递增子序列的最小末尾值
        vector&lt;int&gt; arr;
        arr.push_back(nums[0]);
        for(int i = 1; i &lt; nums.size(); i++)
        {
            if (nums[i] &gt; arr.back()) 
            {
                arr.push_back(nums[i]);
                continue;
            }
            // 找arr中第一个 &gt;= nums[i] 的元素，替换为nums[i]
            int left = 0, right = arr.size()-1;
            for(; left &lt; right; )
            {
                int mid = (left + right) / 2;
                if(arr[mid] &gt;= nums[i]) right = mid;
                else left = mid + 1;
            }
            arr[left] = nums[i];
        }
        return arr.size();
    }
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     6.递增的三元子序列
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/increasing-triplet-subsequence/submissions/605311652" rel="nofollow" title="334. 递增的三元子序列 - 力扣（LeetCode）">
      334. 递增的三元子序列 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) {
        // 和300.最长递增子序列 类似， 不过此题更简单
        // arr[i]表示i+1长度的递增子序列中最小的结尾数
        vector&lt;int&gt; arr;
        arr.push_back(nums[0]);
        for(int i = 1; i &lt; nums.size(); i++)
        {
            if(nums[i] &gt; arr.back())
            {
                arr.push_back(nums[i]);
                if(arr.size() &gt;= 3) return true;
                continue;
            }
            else
            {
                // 在arr中二分查找第一个&gt;=nums[i]的数， 替换为nums[i]
                int left = 0, right = arr.size() - 1;
                while(left &lt; right)
                {
                    int mid = (left + right) &gt;&gt; 1;
                    if(arr[mid] &gt;= nums[i]) right = mid;
                    else left = mid + 1;
                }
                arr[left] = nums[i];
            }
        }
        return false;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     7.最长连续递增序列
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/submissions/605314839" rel="nofollow" title="674. 最长连续递增序列 - 力扣（LeetCode）">
      674. 最长连续递增序列 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     这是道简单题， 没什么好说的
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {
        // 贪心 + 双指针
        int ans = 1;
        for(int i = 0; i &lt; nums.size(); i++)
        {
            int j = i + 1;
            while(j &lt; nums.size() &amp;&amp; nums[j] &gt; nums[j-1]) j++;
            ans = max(ans, j - i);
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     8.买卖股票的最佳时机
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock" rel="nofollow" title="121. 买卖股票的最佳时机 - 力扣（LeetCode）">
      121. 买卖股票的最佳时机 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     由暴力枚举做优化， 用minn标记之前股票最低价位作为买入点
    </p>
    <p>
     贪心正确性：
    </p>
    <p>
     一定正确， 因为其由暴力枚举优化而来， 暴力枚举一定正确， 则贪心也一定正确
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        // 暴力枚举 -&gt; 贪心
        int minn = prices[0];
        int ans = 0;
        for(int i = 1; i &lt; prices.size(); i++)
        {
            int profit = prices[i] - minn &gt; 0 ? prices[i] - minn : 0;
            ans = max(ans, profit);
            minn = min(minn, prices[i]);
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     9.买卖股票的最佳时机II
    </h3>
    <p>
     link：
     <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii" rel="nofollow" title="122. 买卖股票的最佳时机 II - 力扣（LeetCode）">
      122. 买卖股票的最佳时机 II - 力扣（LeetCode）
     </a>
    </p>
    <p>
     与I不同的是， 此问题可以进行无数次交易
    </p>
    <p>
     任意相邻两天， 只要能获得正收益， 就进行交易
    </p>
    <p>
     code1：拆分交易
    </p>
    <p>
     将交易都拆分为一天的交易，任意相邻两天， 只要能获得正收益， 就进行交易（一次买卖）
    </p>
    <p>
    </p>
    <pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        // 拆分交易
        int ans = 0;
        int preVal = prices[0];
        for(int i = 1; i &lt; prices.size(); i++)
        {
            ans += max(prices[i] - preVal, 0);
            preVal = prices[i];
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <p>
     code2 :双指针
    </p>
    <p>
     低点买入， 高点卖出
    </p>
    <pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        // 双指针，低点买入，高点卖出
        // 双指针适合用来寻找连续的，具有某种性质的区间
        int n = prices.size();
        int ans = 0;
        for(int i = 0; i &lt; n; i++)
        {
            int j = i; 
            while(j + 1 &lt; n &amp;&amp; prices[j] &lt; prices[j + 1]) j++;
            ans += prices[j] - prices[i];
            i = j;// 不用手动给i置为最低点
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     9.k次取反后最大化的数组和
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations" rel="nofollow" title="1005. K 次取反后最大化的数组和 - 力扣（LeetCode）">
      1005. K 次取反后最大化的数组和 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     tip:
    </p>
    <p>
     注意STL中最小堆的定义方法， 使用模板方法指明大堆/小堆：
    </p>
    <pre><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq(nums.begin(), nums.end());// 小堆</code></pre>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) {
        // 贪心：每次都取最小值进行取反
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq(nums.begin(), nums.end());// 小堆
        while(k--)
        {
            int top = pq.top();
            pq.pop();
            pq.push(-top);
        }
        int ans = 0;
        while(pq.size())
        {
            ans += pq.top(); pq.pop();
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     10.按身高排序
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/sort-the-people" rel="nofollow" title="2418. 按身高排序 - 力扣（LeetCode）">
      2418. 按身高排序 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     tip:
    </p>
    <p>
     本题并不是贪心算法题， 只是一道普通排序题，为下一道题做铺垫
    </p>
    <h4>
     code1：绑定排序
    </h4>
    <p>
     将heights与names绑定在一起， 按照heights排序
    </p>
    <pre><code>class Solution {
public:
    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) {
        vector&lt;tuple&lt;int, string&gt;&gt; hn;
        for(int i = 0; i &lt; names.size(); i++)
        {
            hn.push_back({heights[i], names[i]});
        }
        sort(hn.begin(), hn.end(), [](tuple&lt;int, string&gt;&amp; hn1, tuple&lt;int, string&gt;&amp; hn2)
        {return get&lt;0&gt;(hn1) &gt; get&lt;0&gt;(hn2);}// 手动实现greater
        );

        vector&lt;string&gt; ans;
        for(tuple&lt;int, string&gt; e:hn)
        {
            ans.push_back(get&lt;1&gt;(e));
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h4>
     code2（非常实用）：对下标排序
    </h4>
    <p>
     新建数组indexs从0到heights.size()-1,对应heights下标，再根据heights对indexs排序
    </p>
    <pre><code>class Solution {
public:
    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) {
        // 下标排序
        vector&lt;int&gt; indexs;
        for(int i = 0; i &lt; names.size(); i++)
        {
            indexs.push_back(i);
        }
        sort(indexs.begin(), indexs.end(), [&amp;heights](int i, int j){
            return heights[i] &gt; heights[j];
        });

        vector&lt;string&gt; ans;
        for(int i:indexs)
        {
            ans.push_back(names[i]);
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     11.优势洗牌
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/advantage-shuffle" rel="nofollow" title="870. 优势洗牌 - 力扣（LeetCode）">
      870. 优势洗牌 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     key:
    </p>
    <p>
     用最小的 大于nums2[i]的nums1元素来匹配nums[i]
     <br/>
     剩下的nums1元素用来匹配剩下的nums2元素，每次用最小的nums1匹配最大的nums2
    </p>
    <p>
     可以使用交换论证法来证明贪心策略正确性
    </p>
    <p>
     <img alt="" height="665" src="https://i-blog.csdnimg.cn/direct/55cf18b37ea54a069804159ae9cbebcc.png" width="1486"/>
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        // 田忌赛马
        // 用最小的 大于nums2[i]的nums1元素来匹配nums[i]
        // 剩下的nums1元素用来匹配剩下的nums2元素，每次用最小的nums1匹配最大的nums2
        int n = nums1.size();
        vector&lt;int&gt; indexs2;// nums2的下标映射
        for(int i = 0; i &lt; nums2.size(); i++)
        {
            indexs2.push_back(i);
        }
        sort(nums1.begin(), nums1.end());
        sort(indexs2.begin(), indexs2.end(), [&amp;nums2](int i, int j){
            return nums2[i] &lt; nums2[j];
        });// 用index2代替nums2排序 
        // 双指针
        vector&lt;int&gt; tmp(n, 0);
        for(int left = 0, right = n - 1, p1 = 0; left &lt;= right; p1++)
        {
            if(nums1[p1] &gt; nums2[indexs2[left]])
            {
                tmp[left++] = nums1[p1];
            }
            else 
            {
                tmp[right--] = nums1[p1];
            }
        }
        // 恢复排序
        vector&lt;int&gt; ans(n, 0);
        for(int i = 0; i &lt; n; i++)
        {
            ans[indexs2[i]] = tmp[i];
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     12.最长回文串
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/longest-palindrome" rel="nofollow" title="409. 最长回文串 - 力扣（LeetCode）">
      409. 最长回文串 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     这是道简答题，不多说明
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int longestPalindrome(string s) {
        int hash[256];
        memset(hash, 0, sizeof hash);
        for(char ch:s)
        {
            hash[ch]++;
        }
        int arr[2] = {0};
        for(int e : hash)
        {
            arr[0] += e/2 * 2;
            arr[1] += e%2;
        }
        int ans = arr[0] + (arr[1] ? 1 : 0);
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     13.增减字符串匹配
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/di-string-match" rel="nofollow" title="942. 增减字符串匹配 - 力扣（LeetCode）">
      942. 增减字符串匹配 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心策略：每次I选最小， 每次D选最大
    </p>
    <p>
     证明贪心策略正确性：归纳法
    </p>
    <p>
     当s[i] = ‘I'时， ans[i]选择当前最小值，则之后所有ans都比ans[i]大，这种情况一定满足题意
    </p>
    <p>
     同理可证s[i] = ‘D'，ans[i]选当前最大值， 则之后所有ans都比ans[i]小， 这种情况一定满足题意
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    vector&lt;int&gt; diStringMatch(string s) {
        // 贪心， 每次I选最小， 每次D选最大
        int n = s.size();
        int minn = 0, maxx = n;
        vector&lt;int&gt; ans(n + 1, 0);
        for(int i = 0; i &lt; n; i++)
        {
            ans[i] = s[i] == 'I' ? minn++ : maxx--;
        }
        ans[n] = minn;//此时minn = maxx
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     14.分发饼干
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/assign-cookies" rel="nofollow" title="455. 分发饼干 - 力扣（LeetCode）">
      455. 分发饼干 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     其实就是田忌赛马， 相当于询问田忌赛马最多胜利的场数
    </p>
    <p>
     贪心策略：优先先满足最小胃口孩子的需求(用最小的满足其胃口的饼干)
    </p>
    <p>
     贪心策略正确性证明见本文第11题“优势洗牌”（交换论证法）
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        // 贪心策略：优先先满足最小胃口孩子的需求(用最小的满足其胃口的饼干),类似田忌赛马
        int ans = 0;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());     
        for(int ps = 0, pg = 0; ps &lt; s.size() &amp;&amp; pg &lt; g.size(); ps++)
        {
            printf("s[ps] = %d, g[pg] = %d\n", s[ps], g[pg]);
            if(s[ps] &gt;= g[pg])
            {
                ans++;
                pg++;
            }
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     15.最优除法
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/optimal-division" rel="nofollow" title="553. 最优除法 - 力扣（LeetCode）">
      553. 最优除法 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心策略：让nums[0]为分子，其他均为分母即可
     <br/>
     key:nums[0]比为分子，nums[1]必为分母
    </p>
    <p>
     由于nums[i] &gt;2，易得贪心策略一定为最优解
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    string optimalDivision(vector&lt;int&gt;&amp; nums) {
        // 贪心策略：让nums[0]为分子，其他均为分母即可
        // key:nums[0]比为分子，nums[1]必为分母
        if(nums.size() == 1) return to_string(nums[0]);
        if(nums.size() == 2) return to_string(nums[0]) + '/' + to_string(nums[1]);
        string ans;
        ans += to_string(nums[0]) + "/(" + to_string(nums[1]);
        for(int i = 2; i &lt; nums.size(); i++)
        {
            ans += '/' + to_string(nums[i]);
        }
        ans += ')';
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     16.跳跃游戏II
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/jump-game-ii" rel="nofollow" title="45. 跳跃游戏 II - 力扣（LeetCode）">
      45. 跳跃游戏 II - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心策略：选择能跳的最远的点作为下一个点（选择i + nums[i]最大的i点）
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        // 贪心策略：选择能跳的最远的点作为下一个点（选择i + nums[i]最大的i点）
        int ans = 0;
        int cur = 0;
        int n = nums.size();
        while(cur &lt; nums.size()-1)
        {// 题目保证可以到达终点则nums[cur] ！= 0
            if(nums[cur] == 0)
            {
                printf("error, nums[cur] == 0\n");
                return -1;
            }
            int nextStep = cur + 1, farest = cur + nums[cur];
            
            if(farest &gt;= n - 1) return ans + 1;
            for(int i = cur + 1; i &lt;= cur + nums[cur]; i++)
            {
                if(i + nums.at(i) &gt; farest)
                {
                    nextStep = i;
                    farest = i + nums.at(i);
                }
            }
            cur = nextStep;
            ans++;
        }
        return ans;
    }
};</code></pre>
    <h3>
     17.跳跃游戏
    </h3>
    <p>
     link：
     <a href="https://leetcode.cn/problems/jump-game" rel="nofollow" title="55. 跳跃游戏 - 力扣（LeetCode）">
      55. 跳跃游戏 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     与跳跃游戏II类似，不多解释
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        // 贪心策略：每次选择能跳的最远的点为下一个点（选令i+nums[i]最大的i最为下一个点
        // 下一个点的nums[i]为0则return false
        int left = 0, right = 0;// 下一个点的选取区间
        int nextStep = 0, farest = 0 + nums[0];
        int cur = 0;
        while(cur &lt; nums.size() - 1)
        {
            if(nums[cur] == 0) return false;
            left = cur + 1;
            right = cur + nums[cur];
            if(right &gt;= nums.size()-1) return true;
            nextStep = cur + 1;
            for(int i = left; i &lt;= right; i++)
            {
                if(i + nums[i] &gt; farest)
                {
                    farest = i + nums[i];
                    nextStep = i;
                }
            }
            cur = nextStep;
        }
        return true;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     18.加油站
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/gas-station" rel="nofollow" title="134. 加油站 - 力扣（LeetCode）">
      134. 加油站 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     本题贪心方案不是很明显，值得仔细分析
    </p>
    <p>
     贪心策略：
    </p>
    <p>
     每次只从diff[i] &gt;= 0的位置开始，若遇到不能递达的站点j，则更新i为j（[i, j]内所有站点都不满足条件）
    </p>
    <p>
     diff[i] = gas[i] - cost[i]
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        // 暴力枚举 -&gt; 贪心（改变i更新逻辑）
        vector&lt;int&gt; diff;
        for(int i = 0; i &lt; gas.size(); i++)
        {
            diff.push_back(gas[i]-cost[i]);
        }
        for(int i = 0; i &lt; diff.size(); i++)
        {
            if(diff[i] &lt; 0) continue;
            int sum = 0;
            for(int cur = i; cur &lt; i + diff.size(); cur++)
            {
                sum += diff[cur % diff.size()];
                if(sum &lt; 0)
                {
                    i = cur;// key:改变i的更新逻辑
                    break;
                }
            }
            if(sum &gt;= 0) return i;
        }
        return -1;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     19.单调递增的数字
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/monotone-increasing-digits" rel="nofollow" title="738. 单调递增的数字 - 力扣（LeetCode）">
      738. 单调递增的数字 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心策略：若n合法，直接返回n； 若n不合法，返回最大位-1，后接多个9(此策略有暴力枚举优化而来)
    </p>
    <p>
     贪心原理正确性：如果n本身不满足条件，为了保持递增性， 最后一个递增元素一定要减1， 在此情况下将其后所有元素置为9，既满足递增条件，又保证是最大值。即为最优解。
    </p>
    <p>
     也可以使用反证法证明贪心策略正确性，自行证明比答案大的数不满足递增条件即可
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        // 贪心策略：若n合法，直接返回n； 若n不合法，返回最大位-1，后接多个9(此策略有暴力枚举优化而来)
        // 如果n本身不满足条件，为了保持递增性， 最后一个递增元素一定要减1， 在此情况下将其后所有元素置为9，即为最优解
        if(n &lt;= 9) return n;
        string sn = to_string(n);
        
        bool valied = true;
        int end = 0;// 最后一个递增元素的下标
        for(int i = 0; i &lt; sn.size() - 1; i++)
        {
            if(sn[i] &gt; sn[i + 1]) 
            {
                valied = false;
                end = i;
                break;
            }
        }
        if(valied) return n;
        string ans = sn.substr(0, end) + func(sn.substr(end, string::npos));
        return monotoneIncreasingDigits(stoi(ans));// 防止s[i-1] &gt; s[i]
    }

    string func(string str)
    {
        string ret = to_string(str[0] - '0' - 1);
        for(int i = 1; i &lt; str.size(); i++)
        {
            ret += "9";
        }
        return ret;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     20.坏了的计算器
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/broken-calculator" rel="nofollow" title="991. 坏了的计算器 - 力扣（LeetCode）">
      991. 坏了的计算器 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     key:正难则反，交换startValue与target ，/ - 改为 * +
    </p>
    <p>
     贪心策略：能除就除
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int brokenCalc(int startValue, int target) {
        // 正难则反，转化为target-&gt;startValue， 只能/2 或 +1
        swap(startValue, target);
        int ans = 0;
        while(startValue != target)
        {
            if(startValue % 2 == 1) 
            {
                startValue += 1;
            }
            else
            {
                if(startValue &gt; target) startValue /= 2;
                else startValue += 1;
            }
            ans++;
        }
        
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     21.合并区间
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/merge-intervals" rel="nofollow" title="56. 合并区间 - 力扣（LeetCode）">
      56. 合并区间 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心策略：每次选择最小start最小的区间
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        // 贪心策略：每次选择最小start最小的区间
        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; vc1, vector&lt;int&gt;&amp; vc2){
            return vc1[0] &lt; vc2[0];
        });
        vector&lt;vector&lt;int&gt;&gt; ans;
        int left = intervals[0][0], right = intervals[0][1];
        for(int i = 1; i &lt; intervals.size(); i++)
        {
            int start = intervals[i][0], end = intervals[i][1];
            if(start &lt;= right)
            {
                right = max(right, end);
            }
            else
            {
                ans.push_back({left, right});
                left = start, right = end;
            }
        }
        ans.push_back({left, right});
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     22.无重叠区间
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/non-overlapping-intervals" rel="nofollow" title="435. 无重叠区间 - 力扣（LeetCode）">
      435. 无重叠区间 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     正难则反：求使得区间互不重叠的区间的最大数量
    </p>
    <p>
     贪心策略：优先选择终点最小的区间
    </p>
    <p>
     tips：
    </p>
    <p>
     一般来讲，区间问题中，既可以左端点排序，也可右端点排序。本题也是如此，只不过本题中使用右端点排序更加直观，容易理解
    </p>
    <p>
     若本题使用左端点排序，则在每次重叠时选择end最小的区间即可
    </p>
    <p>
     区间问题常用贪心算法
    </p>
    <h4>
     code（右端点排序）
    </h4>
    <pre><code>class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        // 正难则反：求使得区间互不重叠的区间的最大数量
        // 贪心策略：优先选择终点最小的区间
        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; vc1, vector&lt;int&gt;&amp; vc2){
            return vc1[1] &lt; vc2[1];
        });
        int left = intervals[0][0], right = intervals[0][1];
        int maxx = 1;
        for(int i = 1; i &lt; intervals.size(); i++)
        {
            if(intervals[i][0] &gt;= right) 
            {
                maxx++;
                right = intervals[i][1];
            }
            else continue;
        }
        return intervals.size() - maxx;
    }
};</code></pre>
    <p>
    </p>
    <h4>
     code2-左端点排序
    </h4>
    <p>
     每次重叠时选择end最小的区间
    </p>
    <p>
     本解法直接求需要删去的区间的个数
    </p>
    <pre><code>class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        // 左端点排序
        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; vc1, vector&lt;int&gt;&amp; vc2){
            return vc1[0] &lt; vc2[0];
        });
        // 删除区间
        int right = intervals[0][1];
        int ans = 0;
        for(int i = 1; i &lt; intervals.size(); i++)
        {
            if(intervals[i][0] &lt; right)// 重叠
            {
                ans++;
                right = min(right, intervals[i][1]);
            }
            else right = intervals[i][1];
        }
        return ans;
    }
};</code></pre>
    <h3>
     23.用最少数量的箭引爆气球
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons" rel="nofollow" title="452. 用最少数量的箭引爆气球 - 力扣（LeetCode）">
      452. 用最少数量的箭引爆气球 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     与上题类似，与重叠区间有关
    </p>
    <p>
     贪心策略：左端点排序，顺序遍历
    </p>
    <p>
     与前组有重叠则更新交集，不重叠就射箭全部戳破，并更新交集
    </p>
    <p>
     code
    </p>
    <pre><code>class Solution {
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) {
        // 贪心策略：左端点排序，顺序遍历
        // 与前组有重叠则更新交集，不重叠就射箭全部戳破，并更新交集
        sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; vc1, vector&lt;int&gt;&amp; vc2){
            return vc1[0] &lt; vc2[0];
        });
        int right = points[0][1];
        int ans = 0;
        for(int i = 1; i &lt; points.size(); i++)
        {
            if(points[i][0] &gt; right)// 不重叠
            {
                ans++;
                right = points[i][1];
            }
            else right = min(right, points[i][1]);
        }
        return ans + 1;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     24.整数替换
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/integer-replacement" rel="nofollow" title="397. 整数替换 - 力扣（LeetCode）">
      397. 整数替换 - 力扣（LeetCode）
     </a>
    </p>
    <h4>
     code1--dfs模拟
    </h4>
    <pre><code>class Solution {
public:
    unordered_map&lt;int, int&gt; hash;
    int integerReplacement(int n) {
        // 直接模拟（dfs 记忆化搜索）
        return dfs(n);
    }

    int dfs(long long n)
    {
        if(hash.count(n)) return hash[n];
        int ret;
        if(n == 1)
        {
            hash[1] = 1;
            ret = 0;
        }
        else if(n % 2 == 0)
        {
            ret =  (1 + dfs(n / 2));
        }
        else
        {
            ret =  1 + min(dfs(n + 1), dfs(n - 1));
        }
        hash[n] = ret;
        return ret;
    }
};</code></pre>
    <h4 style="background-color:transparent">
     code2--贪心
    </h4>
    <p>
     以二进制视角看待n
    </p>
    <pre><code>class Solution {
public:
    int integerReplacement(int n) {
        int ans = 0;
        long long cur = n;
        while(cur != 1)
        {
            if(cur % 2 == 0) cur /= 2;
            else
            {
                if(cur == 3) cur-=1;
                else if(cur % 4 == 1) cur -= 1;
                else cur += 1;
            }
            ans++;
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <p>
    </p>
    <h3>
     25.俄罗斯套娃信封问题
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/russian-doll-envelopes" rel="nofollow" title="354. 俄罗斯套娃信封问题 - 力扣（LeetCode）">
      354. 俄罗斯套娃信封问题 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     左端点排序+贪心+二分
    </p>
    <p>
     排序后求右端点的最长递增子序列即可
    </p>
    <p>
     tips：
    </p>
    <p>
     排序时，若左端点相同， 则按照右端点降序排序，这样可以保证最长递增子序列不出现同左端点的元素
    </p>
    <p>
     本题也可以用动态规划代替贪心+二分部分，虽然这样会超市（时间复杂度O(N)， 但动态规划是一种应用更加广泛，也更简单易懂的算法。但是为了降低时间复杂度，本题解使用贪心算法解决本问题
    </p>
    <p>
    </p>
    <p>
     code
    </p>
    <pre><code class="hljs">class Solution {
public:
    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; evs) {
        // 转化为最长递增子序列即可（左端点排序 + 重写排序）
        sort(evs.begin(), evs.end(), [](vector&lt;int&gt;&amp; vc1, vector&lt;int&gt;&amp; vc2){
            if(vc1[0] != vc2[0]) return vc1[0] &lt; vc2[0];
            else return vc1[1] &gt; vc2[1];
        }); // 重写排序，令左端点相同的元素们按照右端点降序，保证最长递增子序列中，同左端点的元素只出现一次

        // 寻找右端点最长递增子序列（贪心方法）
        vector&lt;int&gt; vc(1, -1);// vc[i]表示长度为i的最长递增子序列的最小结尾值
        for(vector&lt;int&gt; ev :evs)
        {
            int val = ev[1];
            if(val &gt; vc.back())
            {
                vc.push_back(val);
                continue;
            }
            // vc 是升序的, 二分查找第一个大于等于val的元素下标
            int left = 1, right = vc.size() - 1;
            for(; left &lt; right; )
            {
                int mid = (left + right) &gt;&gt; 1;
                if(vc[mid] &gt;= val) right = mid;
                else left = mid + 1;
            }
            vc[left] = val;
        }
        // chech
        for(int e:vc)
        {
            printf("%d ", e);
        }
        return vc.size() - 1;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     26.可被三整除的最大和
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three" rel="nofollow" title="1262. 可被三整除的最大和 - 力扣（LeetCode）">
      1262. 可被三整除的最大和 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     tip:
    </p>
    <p>
     因为本题mod3，3比较小，所以可以使用贪心+分情况讨论。
    </p>
    <p>
     但是但是如果将3换为更大的数，贪心时的分类讨论会特别麻烦，此时我们就应该使用多状态动态规划
    </p>
    <p>
     本题code可以稍微优化：可以先将两个mod3==1与两个mod3==2的最小的数求出，避免不同情况重复求共同值
    </p>
    <p>
     code
    </p>
    <pre><code class="hljs">class Solution {
public:
    int maxSumDivThree(vector&lt;int&gt;&amp; nums) {
        // 正难则反：先求nums的sum，再分类讨论如何舍去较小元素使能sum被三整除
        // 因为本题是mod3，3比较小，所以可以使用分类讨论+贪心，但是如果将3换为更大的数，贪心时的分类讨论会特别麻烦，此时我们就应该使用多状态动态规划
        sort(nums.begin(), nums.end());
        const int INF = 0x3f3f3f3f;
        int ans;

        int sum = 0;
        for(int num:nums) sum += num;
        if(sum % 3 == 0) return sum;
        else if(sum % 3 == 1) 
        {
            // 情况一：去除最小的mod3 == 1的元素
            int a = INF;
            for(int num:nums)
            {
                if(num % 3 == 1)
                {
                    a = num;
                    break;
                }
            }
            // 情况二：去除最小的两个mod3 == 2的元素
            vector&lt;int&gt; b;
            for(int num:nums)
            {
                if(num % 3 == 2)
                {
                    b.push_back(num);
                    if(b.size() &gt;= 2) break;
                }
            }
            int sub = a; if(b.size() &gt;= 2) sub = min(sub, b[0] + b[1]);
            ans = sum - sub;
        }   
        else // sum % 3 == 2
        {
            // 情况一：减去两个mod3 == 1的最小元素
            vector&lt;int&gt; a;
            for(int num:nums)
            {
                if(num % 3 == 1)
                {
                    a.push_back(num);
                    if(a.size() &gt;= 2) break;
                }
            }
            // 情况二：减去最小的mod3 == 2的元素
            int b = INF;
            for(int num:nums)
            {
                if(num % 3 == 2) 
                {
                    b = num;
                    break;
                }
            }
            int sub = b; if(a.size() &gt;= 2) sub = min(sub, a[0] + a[1]);
            ans = sum - sub;
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     27.距离相等的条形码
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/distant-barcodes" rel="nofollow" title="1054. 距离相等的条形码 - 力扣（LeetCode）">
      1054. 距离相等的条形码 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     贪心+模拟
    </p>
    <p>
    </p>
    <h4>
     code1
    </h4>
    <p>
     key：只要保证所有元素都不和其前一个元素重复即可
    </p>
    <p>
     每次选择剩余的相同数量最大的且不与前一个元素重复的num
    </p>
    <pre><code class="hljs">class Solution {
public:
    static bool cmp(pair&lt;int, int&gt;&amp; pr1, pair&lt;int, int&gt;&amp; pr2)
    {
        return pr1.first &lt; pr2.first;
    }

    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt;&amp; bs) {
        // 贪心+模拟
        // key：只要保证所有元素都不和其前一个元素重复即可
        unordered_map&lt;int, int&gt; num_cnt;
        vector&lt;int&gt; ans;
        for(int b:bs)
        {
            num_cnt[b]++;
        }
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; pq(cmp);
        for(auto [num, cnt]:num_cnt)
        {
            pq.push({cnt, num});
        }
        // 开始模拟
        pair&lt;int, int&gt; prePair = pq.top(); pq.pop();
        ans.push_back(prePair.second);
        prePair.first--;
        while(pq.size())
        {
            pair&lt;int, int&gt; pr = pq.top(); pq.pop();
            ans.push_back(pr.second);
            pr.first--;
            if(prePair.first &gt; 0)pq.push(prePair);
            prePair = pr;
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h4>
     code2
    </h4>
    <p>
     先摆放在偶数下标位置， 后摆放再奇数下标位置。
    </p>
    <p>
     只要保证cnt最多的num先摆放即可，剩下的数的摆放顺序无所谓(但是相同的数要连续顺序摆放）
    </p>
    <pre><code class="hljs">class Solution {
public:
    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt;&amp; bs) {
        // 贪心+模拟 （code2分割法
        unordered_map&lt;int, int&gt; num_cnt;
        int maxCnt = 0;
        int mostNum = 0;
        for(int b:bs) 
        {
            if(++num_cnt[b] &gt; maxCnt)
            {
                maxCnt = num_cnt[b];
                mostNum = b;
            }
        }
        printf("maxCnt = %d, mostNum = %d\n", maxCnt, mostNum);
        // 模拟
        vector&lt;int&gt; ans(bs.size(), 0);
        for(int i = 0; i &lt; maxCnt; i++)
        {
            ans[i*2] = mostNum;
        }
        num_cnt.erase(mostNum);
        int idx = maxCnt * 2;
        for(auto&amp; [num, cnt]:num_cnt)
        {
            for(int i = 0; i &lt; cnt; i++)
            {
                if(idx &gt;= ans.size()) idx = 1;
                ans[idx] = num;
                idx += 2;
            }
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
    <h3>
     28.重构字符串
    </h3>
    <p>
     link:
     <a href="https://leetcode.cn/problems/reorganize-string" rel="nofollow" title="767. 重构字符串 - 力扣（LeetCode）">
      767. 重构字符串 - 力扣（LeetCode）
     </a>
    </p>
    <p>
     与上题“距离相等的条形码"相同，只不过参数从vector&lt;int&gt;改为了string
    </p>
    <p>
     判断特殊情况， 之后直接复用上题代码即可
    </p>
    <p>
     code
    </p>
    <pre><code class="hljs">class Solution {
public:
    string reorganizeString(string s) {
        //  同1054.距离相等的条形码
        int sz = s.size();
        unordered_map&lt;char, int&gt; ch_cnt;
        int maxCnt = 0;
        char mostChar = 0;
        for(char ch:s) 
        {
            if(++ch_cnt[ch] &gt; maxCnt)
            {
                maxCnt = ch_cnt[ch];
                mostChar = ch;
            }
        }
        if(maxCnt &gt; (sz + 1) / 2) return "";
        vector&lt;int&gt; vc(s.begin(), s.end());
        vector&lt;int&gt; ret = rearrangeBarcodes(vc);
        string ans;
        for(char ch:ret)
        {
            ans += ch;
        }
        return ans;
    }

    static bool cmp(pair&lt;int, int&gt;&amp; pr1, pair&lt;int, int&gt;&amp; pr2)
    {
        return pr1.first &lt; pr2.first;
    }

    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt;&amp; bs) {
        // 贪心+模拟
        // key：只要保证所有元素都不和其前一个元素重复即可
        unordered_map&lt;int, int&gt; num_cnt;
        vector&lt;int&gt; ans;
        for(int b:bs)
        {
            num_cnt[b]++;
        }
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; pq(cmp);
        for(auto [num, cnt]:num_cnt)
        {
            pq.push({cnt, num});
        }
        // 开始模拟
        pair&lt;int, int&gt; prePair = pq.top(); pq.pop();
        ans.push_back(prePair.second);
        prePair.first--;
        while(pq.size())
        {
            pair&lt;int, int&gt; pr = pq.top(); pq.pop();
            ans.push_back(pr.second);
            pr.first--;
            if(prePair.first &gt; 0)pq.push(prePair);
            prePair = pr;
        }
        return ans;
    }
};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f67:2e6373646e2e6e65742f6c695f7065697869616e73616e672f:61727469636c652f64657461696c732f313435393532303037" class_="artid" style="display:none">
 </p>
</div>


