---
layout: post
title: "RabbitMQ-7种工作模式详解及应用场景复习版,原生代码实现版"
date: 2025-03-05 19:56:36 +0800
description: "2. Work Queue（工作队列）1. 常量类为了方便管理和维护 RabbitMQ 的连接信息，我们创建一个常量类 ，用于存储连接所需的主机地址、端口、虚拟主机、用户名、密码以及队列名称。2. 生产者生产者类的主要职责是创建与 RabbitMQ 的连接，声明队列，并向队列中发送 10 条消息。以下是具体的代码实现：代码解释：消费者类的主要功能是创建与 RabbitMQ 的连接，声明队列，并从队列中消费消息。我们创建两个消费者类来模拟多个消费者竞争消费消"
keywords: "RabbitMQ 7种工作模式详解及应用场景（复习版,原生代码实现版）"
categories: ['Rabbitmq']
tags: ['分布式', 'Rabbitmq']
artid: "146050982"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146050982
    alt: "RabbitMQ-7种工作模式详解及应用场景复习版,原生代码实现版"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146050982
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146050982
cover: https://bing.ee123.net/img/rand?artid=146050982
image: https://bing.ee123.net/img/rand?artid=146050982
img: https://bing.ee123.net/img/rand?artid=146050982
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     RabbitMQ 7种工作模式详解及应用场景（复习版,原生代码实现版）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 id="%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87%F0%9F%8E%87">
     🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇
    </h2>
    <h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%20%C2%A0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%8A%B6%E6%80%81%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">
     ⭐ RabbitMQ ⭐
    </h2>
    <h2>
     🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇
    </h2>
    <hr/>
    <h2>
     前言
    </h2>
    <blockquote>
     <p>
      <a href="https://blog.csdn.net/Y_1215/article/details/142690057?spm=1001.2014.3001.5502" title="RabbitMQ 7种工作模式详解及应用场景_rabbitmq 广播模式应用场景-CSDN博客">
       RabbitMQ 7种工作模式详解及应用场景_rabbitmq 广播模式应用场景-CSDN博客
      </a>
     </p>
     <p>
      之前简单介绍了RabbitMQ的七种工作模式，但是没有具体的代码实现。
      <br/>
      这里复习的时候，把代码实现补上。
     </p>
    </blockquote>
    <hr/>
    <h2>
     RabbitMQ 7种工作模式
    </h2>
    <blockquote>
     <p>
      RabbitMQ 是一个广泛使用的开源消息代理和队列服务器，支持多种消息传递模式。以下是RabbitMQ提供的7种主要的工作模式及其应用场景的详细介绍。
     </p>
    </blockquote>
    <hr/>
    <h2>
     1. Simple（简单模式）
    </h2>
    <blockquote>
     <p>
      <img alt="" height="321" src="https://i-blog.csdnimg.cn/direct/0f54257b21eb4ac1a1def36437c14523.png" width="575"/>
     </p>
     <p>
      <strong>
       角色
      </strong>
      ：
     </p>
     <ul>
      <li>
       <strong>
        P (Producer)
       </strong>
       : 生产者，负责发送消息。
      </li>
      <li>
       <strong>
        C (Consumer)
       </strong>
       : 消费者，负责接收消息。
      </li>
      <li>
       <strong>
        Queue (消息队列)
       </strong>
       : 类似于邮箱，可以缓存消息；生产者向其中投递消息，消费者从中取出消息。
      </li>
     </ul>
     <p>
      <strong>
       特点
      </strong>
      ：一个生产者，一个消费者，消息只能被消费一次。也称为点对点 (Point-to-Point) 模式。
     </p>
     <p>
      <strong>
       适用场景
      </strong>
      ：消息只能被单个消费者处理的情况。
     </p>
    </blockquote>
    <hr/>
    <h3>
     生产者
    </h3>
    <pre><code class="language-java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //2. 设置参数
        factory.setHost("110.41.51.65");//ip 默认值localhost
        factory.setPort(15673); //默认值5672
        factory.setVirtualHost("bite");//虚拟机名称, 默认 /
        factory.setUsername("study");//用户名,默认guest
        factory.setPassword("study");//密码, 默认guest

        //3. 创建连接Connection
        Connection connection = factory.newConnection();
        //4. 创建channel通道
        Channel channel = connection.createChannel();

        //5. 声明队列
        /*
         queueDeclare(String queue, boolean durable, boolean exclusive, 
         boolean autoDelete, Map&lt;String, Object&gt; arguments)
         1.queue: 队列名称
         2.durable: 是否持久化, 当mq重启之后, 消息还在
         3.exclusive:
          * 是否独占, 只能有一个消费者监听队列
          * 当Connection关闭时, 是否删除队列
         4.autoDelete: 是否自动删除, 当没有Consumer时, 自动删除掉
         5.arguments: 一些参数
         */
        //如果没有一个hello这样的一个队列, 会自动创建, 如果有, 则不创建
        channel.queueDeclare("hello", true, false, false, null);

        //6. 通过channel发送消息到队列中
        /*
         basicPublish(String exchange, String routingKey, AMQP.BasicProperties 
         props, byte[] body)
         1. exchange: 交换机名称, 简单模式下, 交换机会使用默认的""
         2.routingKey: 路由名称, routingKey = 队列名称
         3.props: 配置信息
         4.body: 发送消息的数据
         */
        String msg = "Hello World";
        //使用的是内置交换机. 使用内置交换机时, routingKey要和队列名称一样, 才可以路由
        //到对应的队列上去
        channel.basicPublish("", "hello", null, msg.getBytes());

        //7.释放资源
        System.out.println(msg + "消息发送成功");
        channel.close();
        connection.close();
    }
}</code></pre>
    <blockquote>
     <p>
     </p>
     <ol>
      <li>
       <strong>
        创建连接工厂并设置参数
       </strong>
       ：首先创建
       <code>
        ConnectionFactory
       </code>
       对象，它是与 RabbitMQ 建立连接的工厂类。通过设置
       <code>
        host
       </code>
       、
       <code>
        port
       </code>
       、
       <code>
        virtualHost
       </code>
       、
       <code>
        username
       </code>
       和
       <code>
        password
       </code>
       等参数，指定要连接的 RabbitMQ 服务器的地址、端口、虚拟机、用户名和密码。这里连接的是
       <code>
        110.41.51.65:15673
       </code>
       ，使用
       <code>
        bite
       </code>
       虚拟机，用户名和密码都是
       <code>
        study
       </code>
       。
      </li>
      <li>
       <strong>
        创建连接和通道
       </strong>
       ：利用
       <code>
        ConnectionFactory
       </code>
       创建
       <code>
        Connection
       </code>
       连接对象，再通过连接创建
       <code>
        Channel
       </code>
       通道。通道是进行消息读写操作的载体，通过它来执行各种 RabbitMQ 的操作。
      </li>
      <li>
       <strong>
        声明队列
       </strong>
       ：调用
       <code>
        channel.queueDeclare
       </code>
       方法声明一个队列。这里声明了名为
       <code>
        hello
       </code>
       的队列，设置为持久化（
       <code>
        durable = true
       </code>
       ），这样在 RabbitMQ 重启后队列依然存在；不独占（
       <code>
        exclusive = false
       </code>
       ），允许多个消费者监听；不自动删除（
       <code>
        autoDelete = false
       </code>
       ），即使没有消费者时队列也不会被删除。
      </li>
      <li>
       <strong>
        发送消息
       </strong>
       ：使用
       <code>
        channel.basicPublish
       </code>
       方法向队列发送消息。在简单模式下，使用默认交换机（
       <code>
        exchange = ""
       </code>
       ），
       <code>
        routingKey
       </code>
       设置为队列名称
       <code>
        hello
       </code>
       ，消息内容为
       <code>
        "Hello World"
       </code>
       ，并将其转换为字节数组发送。
      </li>
      <li>
       <strong>
        释放资源
       </strong>
       ：消息发送完成后，关闭
       <code>
        channel
       </code>
       和
       <code>
        connection
       </code>
       ，释放与 RabbitMQ 服务器的连接资源。
      </li>
     </ol>
    </blockquote>
    <h3>
     消费者
    </h3>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

public class RabbitmqConsumer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //2. 设置参数
        factory.setHost("110.41.51.65");//ip 默认值localhost
        factory.setPort(15673); //默认值5672
        factory.setVirtualHost("bite");//虚拟机名称, 默认 /
        factory.setUsername("study");//用户名,默认guest
        factory.setPassword("study");//密码, 默认guest

        //3. 创建连接Connection
        Connection connection = factory.newConnection();
        //4. 创建channel通道
        Channel channel = connection.createChannel();

        //5. 声明队列
        /*
         queueDeclare(String queue, boolean durable, boolean exclusive, 
         boolean autoDelete, Map&lt;String, Object&gt; arguments)
         1.queue: 队列名称
         2.durable: 是否持久化, 当mq重启之后, 消息还在
         3.exclusive:
          * 是否独占, 只能有一个消费者监听队列
          * 当Connection关闭时, 是否删除队列
         4.autoDelete: 是否自动删除, 当没有Consumer时, 自动删除掉
         5.arguments: 一些参数
         */
        //如果没有一个hello这样的一个队列, 会自动创建, 如果有, 则不创建
        channel.queueDeclare("hello", true, false, false, null);

        //6. 接收消息, 并消费
        /*
         basicConsume(String queue, boolean autoAck, Consumer callback)
         参数:
         1. queue: 队列名称
         2. autoAck: 是否自动确认, 消费者收到消息之后,自动和MQ确认
         3. callback: 回调对象
         */
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            /*
             回调方法, 当收到消息后, 会自动执行该方法
             1. consumerTag: 标识
             2. envelope: 获取一些信息, 交换机, 路由key
             3. properties:配置信息
             4. body:数据
             */
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
            AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume("hello", true, consumer);

        //等待回调函数执行完毕之后, 关闭资源
        TimeUnit.SECONDS.sleep(5);
        //7. 释放资源 消费者相当于是一个监听程序, 不需要关闭资源
        //顺序不可改变
        // channel.close();
        // connection.close();
    }
}
</code></pre>
    <blockquote>
     <ol>
      <li>
       <strong>
        连接设置与队列声明
       </strong>
       ：与生产者类似，先创建连接工厂并设置参数，建立连接和通道，然后声明
       <code>
        hello
       </code>
       队列，保证消费者与生产者操作的是同一个队列。
      </li>
      <li>
       <strong>
        接收并消费消息
       </strong>
       ：通过
       <code>
        channel.basicConsume
       </code>
       方法接收消息。创建一个
       <code>
        DefaultConsumer
       </code>
       回调对象，重写
       <code>
        handleDelivery
       </code>
       方法，当消费者接收到消息时，该方法会自动执行，将接收到的消息字节数组转换为字符串并打印输出。这里设置
       <code>
        autoAck = true
       </code>
       ，表示消费者收到消息后自动向 RabbitMQ 确认，这样 RabbitMQ 就会认为消息已被成功处理并从队列中移除。
      </li>
      <li>
       <strong>
        资源处理
       </strong>
       ：消费者通常作为一个监听程序持续运行，这里使用
       <code>
        TimeUnit.SECONDS.sleep(5)
       </code>
       让程序等待 5 秒，模拟回调函数执行的过程，之后如果需要关闭资源，可以按照
       <code>
        channel.close()
       </code>
       和
       <code>
        connection.close()
       </code>
       的顺序关闭，但一般情况下消费者不会轻易关闭连接，而是持续监听队列获取消息。
      </li>
     </ol>
    </blockquote>
    <hr/>
    <h2>
     2. Work Queue（工作队列）
    </h2>
    <blockquote>
     <p>
      <img alt="" height="353" src="https://i-blog.csdnimg.cn/direct/f49a477b9a82484dabca7e7127c0f64c.png" width="419"/>
     </p>
     <p>
      <strong>
       角色
      </strong>
      ：
     </p>
     <ul>
      <li>
       <strong>
        P (Producer)
       </strong>
       : 生产者。
      </li>
      <li>
       <strong>
        C1, C2 (Consumers)
       </strong>
       : 多个消费者。
      </li>
      <li>
       <strong>
        Queue (消息队列)
       </strong>
       : 用于缓存消息。
      </li>
     </ul>
     <p>
     </p>
     <p>
      <strong>
       特点
      </strong>
      ：一个生产者，多个消费者。在多个消息的情况下，Work Queue 会将消息分派给不同的消费者，每个消费者都会接收到不同的消息。
     </p>
     <p>
     </p>
     <p>
      <strong>
       适用场景
      </strong>
      ：集群环境中做异步处理。例如，12306 短信通知服务，订单成功后，订单消息会被发送到 RabbitMQ，短信服务从 RabbitMQ 中获取订单信息，并发送通知信息。
     </p>
     <p>
      <img alt="" height="367" src="https://i-blog.csdnimg.cn/direct/bfd08dc4c8434ee6adaad501ea164a6e.png" width="774"/>
     </p>
     <p>
     </p>
    </blockquote>
    <hr/>
    <h3>
     1. 常量类
    </h3>
    <p>
     为了方便管理和维护 RabbitMQ 的连接信息，我们创建一个常量类
     <code>
      Constants
     </code>
     ，用于存储连接所需的主机地址、端口、虚拟主机、用户名、密码以及队列名称。
    </p>
    <pre><code class="language-java">public class Constants {
    public static final String HOST = "110.41.51.65";
    public static final Integer PORT = 15673;
    public static final String VIRTUAL_HOST = "bite";
    public static final String USER_NAME = "study";
    public static final String PASSWORD = "study";
    public static final String WORK_QUEUE_NAME = "work_queues";
}
</code></pre>
    <h3>
     2. 生产者
    </h3>
    <p>
     生产者类的主要职责是创建与 RabbitMQ 的连接，声明队列，并向队列中发送 10 条消息。以下是具体的代码实现：
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import constant.Constants;

public class WorkRabbitProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 声明队列
        // 如果队列不存在，会自动创建；如果存在，则不创建
        channel.queueDeclare(Constants.WORK_QUEUE_NAME, true, false, false, null);

        // 5. 发送 10 条消息
        for (int i = 0; i &lt; 10; i++) {
            String msg = "Hello World" + i;
            // 向队列中发送消息
            channel.basicPublish("", Constants.WORK_QUEUE_NAME, null, msg.getBytes());
        }

        // 6. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     代码解释：
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        连接工厂和连接创建
       </strong>
       ：使用
       <code>
        ConnectionFactory
       </code>
       创建连接工厂，并设置连接所需的参数，如主机地址、端口、虚拟主机、用户名和密码。然后通过
       <code>
        factory.newConnection()
       </code>
       方法创建连接。
      </li>
      <li>
       <strong>
        通道创建
       </strong>
       ：在连接的基础上，使用
       <code>
        connection.createChannel()
       </code>
       方法创建通道，通道是进行消息读写操作的主要对象。
      </li>
      <li>
       <strong>
        队列声明
       </strong>
       ：使用
       <code>
        channel.queueDeclare
       </code>
       方法声明队列，设置队列的持久化、独占性和自动删除等属性。
      </li>
      <li>
       <strong>
        消息发送
       </strong>
       ：通过
       <code>
        for
       </code>
       循环发送 10 条消息，使用
       <code>
        channel.basicPublish
       </code>
       方法将消息发送到指定的队列中。
      </li>
      <li>
       <strong>
        资源释放
       </strong>
       ：消息发送完成后，关闭通道和连接，释放资源。
      </li>
     </ul>
    </blockquote>
    <h3>
     3. 消费者
    </h3>
    <p>
     消费者类的主要功能是创建与 RabbitMQ 的连接，声明队列，并从队列中消费消息。我们创建两个消费者类来模拟多个消费者竞争消费消息的场景。
    </p>
    <p>
     <code>
      WorkRabbitmqConsumer1
     </code>
     类
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class WorkRabbitmqConsumer1 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 声明队列
        // 如果队列不存在，会自动创建；如果存在，则不创建
        channel.queueDeclare(Constants.WORK_QUEUE_NAME, true, false, false, null);

        // 5. 定义消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("WorkRabbitmqConsumer1 接收到消息: " + new String(body));
            }
        };

        // 6. 开始消费消息
        channel.basicConsume(Constants.WORK_QUEUE_NAME, true, consumer);
    }
}
</code></pre>
    <p>
     <span style="color:#ed7976">
      <strong>
       <code>
        WorkRabbitmqConsumer2
       </code>
       类与 1一样，这里就不多赘述
      </strong>
     </span>
    </p>
    <p>
     代码解释：
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        连接和通道创建
       </strong>
       ：与生产者类类似，创建连接工厂、连接和通道。
      </li>
      <li>
       <strong>
        队列声明
       </strong>
       ：确保消费者使用的队列与生产者声明的队列一致。
      </li>
      <li>
       <strong>
        消费者定义
       </strong>
       ：创建
       <code>
        DefaultConsumer
       </code>
       对象，并重写
       <code>
        handleDelivery
       </code>
       方法，该方法在接收到消息时会被自动调用，用于处理接收到的消息。
      </li>
      <li>
       <strong>
        消息消费
       </strong>
       ：使用
       <code>
        channel.basicConsume
       </code>
       方法开始消费队列中的消息，设置自动确认模式。
      </li>
     </ul>
    </blockquote>
    <p>
     运行步骤：
    </p>
    <blockquote>
     <ol>
      <li>
       先启动两个消费者程序
       <code>
        WorkRabbitmqConsumer1
       </code>
       和
       <code>
        WorkRabbitmqConsumer2
       </code>
       。
      </li>
      <li>
       再启动生产者程序
       <code>
        WorkRabbitProducer
       </code>
       。
      </li>
     </ol>
    </blockquote>
    <p>
     结果分析：
    </p>
    <blockquote>
     <p>
      由于工作队列模式采用轮询的方式将消息分发给多个消费者，因此两个消费者会交替消费生产者发送的 10 条消息。通常情况下，
      <code>
       WorkRabbitmqConsumer1
      </code>
      会消费到消息
      <code>
       Hello World0
      </code>
      、
      <code>
       Hello World2
      </code>
      、
      <code>
       Hello World4
      </code>
      、
      <code>
       Hello World6
      </code>
      、
      <code>
       Hello World8
      </code>
      ，而
      <code>
       WorkRabbitmqConsumer2
      </code>
      会消费到消息
      <code>
       Hello World1
      </code>
      、
      <code>
       Hello World3
      </code>
      、
      <code>
       Hello World5
      </code>
      、
      <code>
       Hello World7
      </code>
      、
      <code>
       Hello World9
      </code>
      。这体现了多个消费者竞争消费消息的特点，提高了系统的处理能力和效率。
     </p>
    </blockquote>
    <hr/>
    <h2>
     3. Publish/Subscribe（发布/订阅）
    </h2>
    <blockquote>
     <p>
      <img alt="" height="425" src="https://i-blog.csdnimg.cn/direct/9f6034d61fbd476ca803d0ef734e3f35.png" width="490"/>
     </p>
     <p>
     </p>
     <p>
      <strong>
       角色
      </strong>
      ：
     </p>
     <p>
      <strong>
       特点
      </strong>
      ：生产者将消息发送到 Ex
     </p>
     <ul>
      <li>
       <strong>
        P (Producer)
       </strong>
       : 生产者。
      </li>
      <li>
       <strong>
        X (Exchange, 交换机)
       </strong>
       : 负责将消息按一定规则路由到一个或多个队列。
      </li>
      <li>
       <strong>
        C1, C2 (Consumers)
       </strong>
       : 多个消费者。
      </li>
      <li>
       <strong>
        Queue (消息队列)
       </strong>
       : 用于缓存消息。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      概念介绍
     </strong>
    </p>
    <p>
     <strong>
      Exchange
     </strong>
     : 交换机 (X).
    </p>
    <blockquote>
     <p>
      作⽤: ⽣产者将消息发送到Exchange, 由交换机将消息按⼀定规则路由到⼀个或多个队列中(上图中⽣产 者将消息投递到队列中, 实际上这个在RabbitMQ中不会发⽣. )
     </p>
     <p>
      RabbitMQ交换机有四种类型: fanout,direct, topic, headers, 不同类型有着不同的路由策略.
     </p>
     <p>
      AMQP协 议⾥还有另外两种类型, System和⾃定义, 此处不再描述.
     </p>
     <ol>
      <li>
       Fanout:⼴播，将消息交给所有绑定到交换机的队列(Publish/Subscribe模式)
      </li>
      <li>
       Direct:定向，把消息交给符合指定routing key的队列(Routing模式)
      </li>
      <li>
       Topic:通配符，把消息交给符合routing pattern(路由模式)的队列(Topics模式)
      </li>
      <li>
       headers类型的交换器不依赖于路由键的匹配规则来路由消息, ⽽是根据发送的消息内容中的
      </li>
     </ol>
     <p>
      headers属性进⾏匹配. headers类型的交换器性能会很差,⽽且也不实⽤,基本上不会看到它的存在.
     </p>
     <p>
      Exchange(交换机）只负责转发消息, 不具备存储消息的能⼒, 因此如果没有任何队 Exchange绑定，或者没有符合路由规则的队列，那么消息就会丢失
     </p>
     <p>
      RoutingKey: 路由键.⽣产者将消息发给交换器时, 指定的⼀个字符串, ⽤来告诉交换机应该如何处理这个消息.
     </p>
     <p>
      Binding Key:绑定. RabbitMQ中通过Binding(绑定)将交换器与队列关联起来, 在绑定的时候⼀般会指 定⼀个Binding Key, 这样RabbitMQ就知道如何正确地将消息路由到队列了.
     </p>
     <p>
      change，由交换机将消息广播到所有绑定的队列。每个消费者都会接收到相同的消息。
     </p>
    </blockquote>
    <p>
     ⽐如下图: 如果在发送消息时, 设置了RoutingKey 为orange, 消息就会路由到Q1
    </p>
    <p>
     <img alt="" height="513" src="https://i-blog.csdnimg.cn/direct/7b04b11242c245df99ceea004eeb6fe4.png" width="1200"/>
    </p>
    <blockquote>
     <p>
      当消息的Routing key与队列绑定的Bindingkey相匹配时，消息才会被路由到这个队列.
     </p>
     <p>
      BindingKey其实也属于路由键中的⼀种, 官⽅解释为:the routingkey to use for the binding.
     </p>
     <p>
      可以翻译为:在绑定的时候使⽤的路由键. ⼤多数时候,包括官⽅⽂档和RabbitMQJava API 中都把
     </p>
     <p>
      BindingKey和RoutingKey看作RoutingKey, 为了避免混淆,可以这么理解:
     </p>
     <p>
      1. 在使⽤绑定的时候,需要的路由键是BindingKey.
     </p>
     <p>
      2. 在发送消息的时候,需要的路由键是RoutingKey
     </p>
    </blockquote>
    <p>
     <strong>
      适用场景
     </strong>
     ：消息需要被多个消费者同时接收的场景。例如，中国气象局发布天气预报的消息，新浪、百度、搜狐等门户网站通过队列绑定到该交换机，自动获取气象局推送的气象数据。
    </p>
    <hr/>
    <h3>
     1. 常量类
    </h3>
    <p>
    </p>
    <p>
     首先，我们定义一些常量，用于存储 RabbitMQ 连接信息以及交换器和队列的名称。这些常量可以方便地在生产者和消费者代码中复用。
    </p>
    <pre><code class="language-java">public class Constants {
    public static final String HOST = "110.41.51.65";
    public static final Integer PORT = 15673;
    public static final String VIRTUAL_HOST = "bite";
    public static final String USER_NAME = "study";
    public static final String PASSWORD = "study";
    public static final String FANOUT_EXCHANGE_NAME = "test_fanout";
    public static final String FANOUT_QUEUE_NAME1 = "fanout_queue1";
    public static final String FANOUT_QUEUE_NAME2 = "fanout_queue2";
}
</code></pre>
    <h3>
     2. 生产者
    </h3>
    <p>
     生产者的主要任务是创建与 RabbitMQ 的连接，声明扇形交换器、队列，并将队列与交换器绑定，最后发送消息。以下是详细的生产者代码：
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import constant.Constants;

public class FanoutRabbitProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 创建交换机
        channel.exchangeDeclare(Constants.FANOUT_EXCHANGE_NAME,
                BuiltinExchangeType.FANOUT, true, false, false, null);

        // 5. 声明队列
        channel.queueDeclare(Constants.FANOUT_QUEUE_NAME1, true, false, false, null);
        channel.queueDeclare(Constants.FANOUT_QUEUE_NAME2, true, false, false, null);

        // 6. 绑定队列和交换机
        channel.queueBind(Constants.FANOUT_QUEUE_NAME1, Constants.FANOUT_EXCHANGE_NAME, "");
        channel.queueBind(Constants.FANOUT_QUEUE_NAME2, Constants.FANOUT_EXCHANGE_NAME, "");

        // 7. 发送消息
        String msg = "hello fanout";
        channel.basicPublish(Constants.FANOUT_EXCHANGE_NAME, "", null, msg.getBytes());

        // 8. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     代码解释：
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        连接设置
       </strong>
       ：使用
       <code>
        ConnectionFactory
       </code>
       创建连接工厂，并设置 RabbitMQ 服务器的主机地址、端口、虚拟主机、用户名和密码。然后通过
       <code>
        factory.newConnection()
       </code>
       创建连接。
      </li>
      <li>
       <strong>
        通道创建
       </strong>
       ：通过
       <code>
        connection.createChannel()
       </code>
       创建通道，通道是进行消息操作的载体。
      </li>
      <li>
       <strong>
        交换器声明
       </strong>
       ：使用
       <code>
        channel.exchangeDeclare
       </code>
       方法声明一个扇形交换器，设置交换器名称为
       <code>
        test_fanout
       </code>
       ，类型为
       <code>
        FANOUT
       </code>
       ，并设置为持久化（
       <code>
        durable = true
       </code>
       ），不自动删除（
       <code>
        autoDelete = false
       </code>
       ），不是内部使用（
       <code>
        internal = false
       </code>
       ）。
      </li>
      <li>
       <strong>
        队列声明
       </strong>
       ：使用
       <code>
        channel.queueDeclare
       </code>
       方法声明两个队列
       <code>
        fanout_queue1
       </code>
       和
       <code>
        fanout_queue2
       </code>
       ，设置为持久化，不独占，不自动删除。
      </li>
      <li>
       <strong>
        绑定操作
       </strong>
       ：使用
       <code>
        channel.queueBind
       </code>
       方法将两个队列分别与扇形交换器绑定，由于是扇形交换器，路由键设置为空字符串（
       <code>
        ""
       </code>
       ），表示广播消息。
      </li>
      <li>
       <strong>
        消息发送
       </strong>
       ：使用
       <code>
        channel.basicPublish
       </code>
       方法发送消息，指定交换器名称，路由键为空字符串，消息内容为
       <code>
        hello fanout
       </code>
       。
      </li>
      <li>
       <strong>
        资源释放
       </strong>
       ：发送完消息后，关闭通道和连接，释放资源。
      </li>
     </ul>
    </blockquote>
    <h3>
     3. 消费者
    </h3>
    <p>
     消费者的主要任务是创建与 RabbitMQ 的连接，接收并处理从队列中获取的消息。由于交换器和队列的绑定关系及声明已经在生产者代码中完成，消费者代码中不需要重复这些操作。以下是两个消费者的代码示例：
    </p>
    <p>
     消费者 1
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class FanoutRabbitmqConsumer1 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.FANOUT_QUEUE_NAME1, true, consumer);
    }
}
</code></pre>
    <p>
     消费者 2
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class FanoutRabbitmqConsumer2 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.FANOUT_QUEUE_NAME2, true, consumer);
    }
}
</code></pre>
    <blockquote>
     <p>
      代码解释：
     </p>
     <ul>
      <li>
       <strong>
        连接和通道创建
       </strong>
       ：与生产者类似，创建连接工厂、连接和通道。
      </li>
      <li>
       <strong>
        消息消费
       </strong>
       ：创建
       <code>
        DefaultConsumer
       </code>
       对象，并重写
       <code>
        handleDelivery
       </code>
       方法，该方法在接收到消息时会被调用，用于处理接收到的消息。然后使用
       <code>
        channel.basicConsume
       </code>
       方法开始消费指定队列（
       <code>
        fanout_queue1
       </code>
       或
       <code>
        fanout_queue2
       </code>
       ）中的消息，设置自动确认模式（
       <code>
        autoAck = true
       </code>
       ）。
      </li>
     </ul>
     <p>
      4. 运行结果
     </p>
     <p>
      当我们先启动两个消费者，再启动生产者时，生产者发送的消息
      <code>
       hello fanout
      </code>
      会被广播到两个队列中，两个消费者都会接收到消息并打印出相应的内容。这体现了扇形交换器模式的广播特性，即消息会被发送到所有与之绑定的队列，实现了消息的多播功能。
     </p>
    </blockquote>
    <p>
     通过以上代码和步骤，我们成功实现了 RabbitMQ 的扇形交换器模式，并且可以观察到消息广播的效果。在实际应用中，扇形交换器模式适用于需要将消息同时发送给多个消费者的场景，如日志记录、通知系统等。
    </p>
    <hr/>
    <h2>
     4. Routing（路由模式）
    </h2>
    <blockquote>
     <p>
      <img alt="" height="350" src="https://i-blog.csdnimg.cn/direct/c19b4256bbe14d7a9136456cf8773b16.png" width="408"/>
     </p>
     <p>
      <strong>
       角色
      </strong>
      ：
     </p>
     <ul>
      <li>
       <strong>
        P (Producer)
       </strong>
       : 生产者。
      </li>
      <li>
       <strong>
        X (Exchange, 交换机)
       </strong>
       : 根据 RoutingKey 的规则将消息路由到对应的队列。
      </li>
      <li>
       <strong>
        C1, C2 (Consumers)
       </strong>
       : 多个消费者。
      </li>
      <li>
       <strong>
        Queue (消息队列)
       </strong>
       : 用于缓存消息。
      </li>
     </ul>
     <p>
      <strong>
       特点
      </strong>
      ：交换机根据 RoutingKey 将消息筛选后发给对应的消费者队列。
     </p>
     <p>
      <strong>
       适用场景
      </strong>
      ：需要根据特定规则分发消息的场景。例如，系统打印日志，日志等级分为 error, warning, info, debug，可以通过这种模式将不同的日志发送到不同的队列，最终输出到不同的文件。
     </p>
    </blockquote>
    <h3>
     1. 常量类
    </h3>
    <p>
     定义一些常量，用于存储 RabbitMQ 连接信息以及直连交换器和队列的名称。
    </p>
    <pre><code class="language-java">public class Constants {
    public static final String HOST = "110.41.51.65";
    public static final Integer PORT = 15673;
    public static final String VIRTUAL_HOST = "bite";
    public static final String USER_NAME = "study";
    public static final String PASSWORD = "study";
    public static final String DIRECT_EXCHANGE_NAME = "test_direct";
    public static final String DIRECT_QUEUE_NAME1 = "direct_queue1";
    public static final String DIRECT_QUEUE_NAME2 = "direct_queue2";
}
</code></pre>
    <h3>
     2. 生产者
    </h3>
    <p>
     生产者的主要任务是创建与 RabbitMQ 的连接，声明直连交换器和队列，将队列与交换器通过不同的路由键进行绑定，最后根据不同的路由键发送消息。
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import constant.Constants;

public class DirectRabbitProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 创建直连交换器
        // 注意：原代码此处使用BuiltinExchangeType.FANOUT有误，应改为BuiltinExchangeType.DIRECT
        channel.exchangeDeclare(Constants.DIRECT_EXCHANGE_NAME, 
                BuiltinExchangeType.DIRECT, true, false, false, null);

        // 5. 声明队列
        channel.queueDeclare(Constants.DIRECT_QUEUE_NAME1, true, false, false, null);
        channel.queueDeclare(Constants.DIRECT_QUEUE_NAME2, true, false, false, null);

        // 6. 绑定队列和交换器
        // 队列1绑定到路由键 "orange"
        channel.queueBind(Constants.DIRECT_QUEUE_NAME1, Constants.DIRECT_EXCHANGE_NAME, "orange");
        // 队列2绑定到路由键 "black" 和 "green"
        channel.queueBind(Constants.DIRECT_QUEUE_NAME2, Constants.DIRECT_EXCHANGE_NAME, "black");
        channel.queueBind(Constants.DIRECT_QUEUE_NAME2, Constants.DIRECT_EXCHANGE_NAME, "green");

        // 7. 发送消息
        String msg = "hello direct, I am orange";
        channel.basicPublish(Constants.DIRECT_EXCHANGE_NAME, "orange", null, msg.getBytes());

        String msg_black = "hello direct, I am black";
        channel.basicPublish(Constants.DIRECT_EXCHANGE_NAME, "black", null, msg_black.getBytes());

        String msg_green = "hello direct, I am green";
        channel.basicPublish(Constants.DIRECT_EXCHANGE_NAME, "green", null, msg_green.getBytes());

        // 8. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     代码解释：
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        连接设置
       </strong>
       ：使用
       <code>
        ConnectionFactory
       </code>
       创建连接工厂，并设置 RabbitMQ 服务器的主机地址、端口、虚拟主机、用户名和密码，然后创建连接和通道。
      </li>
      <li>
       <strong>
        交换器声明
       </strong>
       ：使用
       <code>
        channel.exchangeDeclare
       </code>
       方法声明一个直连交换器，指定交换器名称、类型为
       <code>
        DIRECT
       </code>
       ，并设置为持久化。
      </li>
      <li>
       <strong>
        队列声明
       </strong>
       ：使用
       <code>
        channel.queueDeclare
       </code>
       方法声明两个队列，同样设置为持久化。
      </li>
      <li>
       <strong>
        绑定操作
       </strong>
       ：使用
       <code>
        channel.queueBind
       </code>
       方法将队列 1 绑定到路由键
       <code>
        "orange"
       </code>
       ，队列 2 绑定到路由键
       <code>
        "black"
       </code>
       和
       <code>
        "green"
       </code>
       。
      </li>
      <li>
       <strong>
        消息发送
       </strong>
       ：使用
       <code>
        channel.basicPublish
       </code>
       方法根据不同的路由键发送不同的消息。
      </li>
      <li>
       <strong>
        资源释放
       </strong>
       ：发送完消息后，关闭通道和连接。
      </li>
     </ul>
    </blockquote>
    <h3>
     3. 消费者
    </h3>
    <p>
     消费者的主要任务是创建与 RabbitMQ 的连接，从指定的队列中接收并处理消息。
    </p>
    <p>
     消费者 1：
     <code>
      DirectRabbitmqConsumer1
     </code>
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class DirectRabbitmqConsumer1 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.DIRECT_QUEUE_NAME1, true, consumer);
    }
}
</code></pre>
    <p>
     消费者 2：
     <code>
      DirectRabbitmqConsumer2
     </code>
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class DirectRabbitmqConsumer2 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.DIRECT_QUEUE_NAME2, true, consumer);
    }
}
</code></pre>
    <blockquote>
     <p>
      代码解释：
     </p>
     <ul>
      <li>
       <strong>
        连接和通道创建
       </strong>
       ：与生产者类似，创建连接工厂、连接和通道。
      </li>
      <li>
       <strong>
        消息消费
       </strong>
       ：创建
       <code>
        DefaultConsumer
       </code>
       对象，并重写
       <code>
        handleDelivery
       </code>
       方法用于处理接收到的消息。使用
       <code>
        channel.basicConsume
       </code>
       方法从指定队列中消费消息，设置自动确认模式。
      </li>
     </ul>
     <p>
      4. 运行结果及分析
     </p>
     <p>
      运行步骤：
     </p>
     <ol>
      <li>
       先运行生产者程序，生产者会根据不同的路由键将消息发送到相应的队列。
      </li>
      <li>
       再运行两个消费者程序，消费者会从各自绑定的队列中获取消息。
      </li>
     </ol>
     <p>
      结果分析：
     </p>
     <ul>
      <li>
       <code>
        DirectRabbitmqConsumer1
       </code>
       会接收到路由键为
       <code>
        "orange"
       </code>
       的消息，即
       <code>
        "hello direct, I am orange"
       </code>
       。
      </li>
      <li>
       <code>
        DirectRabbitmqConsumer2
       </code>
       会接收到路由键为
       <code>
        "black"
       </code>
       和
       <code>
        "green"
       </code>
       的消息，即
       <code>
        "hello direct, I am black"
       </code>
       和
       <code>
        "hello direct, I am green"
       </code>
       。
      </li>
     </ul>
     <p>
      通过这种方式，我们可以看到直连交换器模式根据路由键精确分发消息的特性，不同的队列可以根据绑定的路由键接收不同的消息，实现了消息的定向分发。
     </p>
    </blockquote>
    <hr/>
    <h2>
     5. Topics（通配符模式）
    </h2>
    <blockquote>
     <p>
      <img alt="" height="437" src="https://i-blog.csdnimg.cn/direct/9f9b706a8ddd40009a0b588709888995.png" width="556"/>
     </p>
     <p>
      <strong>
       角色
      </strong>
      ：
     </p>
     <ul>
      <li>
       <strong>
        P (Producer)
       </strong>
       : 生产者。
      </li>
      <li>
       <strong>
        X (Exchange, 交换机)
       </strong>
       : 根据 RoutingKey 的通配符匹配规则将消息路由到对应的队列。
      </li>
      <li>
       <strong>
        C1, C2 (Consumers)
       </strong>
       : 多个消费者。
      </li>
      <li>
       <strong>
        Queue (消息队列)
       </strong>
       : 用于缓存消息。
      </li>
     </ul>
     <p>
      <strong>
       特点
      </strong>
      ：类似于 Routing 模式，但使用通配符来定义 RoutingKey 的模式，使得匹配更加灵活。
     </p>
     <p>
      <strong>
       适用场景
      </strong>
      ：需要灵活匹配和过滤消息的场景。
     </p>
     <p>
      <strong>
       示例图
      </strong>
      ：展示交换机根据通配符匹配规则将消息路由到不同的队列。
     </p>
    </blockquote>
    <h3>
     1. 常量类
    </h3>
    <p>
     定义一些常量，用于存储 RabbitMQ 连接信息以及主题交换器和队列的名称。
    </p>
    <pre><code class="language-java">public class Constants {
    public static final String HOST = "110.41.51.65";
    public static final Integer PORT = 15673;
    public static final String VIRTUAL_HOST = "bite";
    public static final String USER_NAME = "study";
    public static final String PASSWORD = "study";
    public static final String TOPIC_EXCHANGE_NAME = "test_topic";
    public static final String TOPIC_QUEUE_NAME1 = "topic_queue1";
    public static final String TOPIC_QUEUE_NAME2 = "topic_queue2";
}
</code></pre>
    <h3>
     2. 生产者
    </h3>
    <p>
     生产者的主要任务是创建与 RabbitMQ 的连接，声明主题交换器和队列，将队列与交换器通过不同的主题模式进行绑定，最后根据不同的主题发送消息。
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import constant.Constants;

public class TopicRabbitProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 创建主题交换器
        channel.exchangeDeclare(Constants.TOPIC_EXCHANGE_NAME, 
                BuiltinExchangeType.TOPIC, true, false, false, null);

        // 5. 声明队列
        channel.queueDeclare(Constants.TOPIC_QUEUE_NAME1, true, false, false, null);
        channel.queueDeclare(Constants.TOPIC_QUEUE_NAME2, true, false, false, null);

        // 6. 绑定队列和交换器
        // 队列 1 绑定 *.error，仅接收 error 信息
        channel.queueBind(Constants.TOPIC_QUEUE_NAME1, Constants.TOPIC_EXCHANGE_NAME, "*.error");
        // 队列 2 绑定 #.info 和 *.error，接收 info 和 error 信息
        channel.queueBind(Constants.TOPIC_QUEUE_NAME2, Constants.TOPIC_EXCHANGE_NAME, "#.info");
        channel.queueBind(Constants.TOPIC_QUEUE_NAME2, Constants.TOPIC_EXCHANGE_NAME, "*.error");

        // 7. 发送消息
        String msg = "hello topic, I'm order.error";
        channel.basicPublish(Constants.TOPIC_EXCHANGE_NAME, "order.error", null, msg.getBytes());

        String msg_black = "hello topic, I'm order.pay.info";
        channel.basicPublish(Constants.TOPIC_EXCHANGE_NAME, "order.pay.info", null, msg_black.getBytes());

        String msg_green = "hello topic, I'm pay.error";
        channel.basicPublish(Constants.TOPIC_EXCHANGE_NAME, "pay.error", null, msg_green.getBytes());

        // 8. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     代码解释：
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        连接设置
       </strong>
       ：使用
       <code>
        ConnectionFactory
       </code>
       创建连接工厂，并设置 RabbitMQ 服务器的主机地址、端口、虚拟主机、用户名和密码，然后创建连接和通道。
      </li>
      <li>
       <strong>
        交换器声明
       </strong>
       ：使用
       <code>
        channel.exchangeDeclare
       </code>
       方法声明一个主题交换器，指定交换器名称、类型为
       <code>
        TOPIC
       </code>
       ，并设置为持久化。
      </li>
      <li>
       <strong>
        队列声明
       </strong>
       ：使用
       <code>
        channel.queueDeclare
       </code>
       方法声明两个队列，同样设置为持久化。
      </li>
      <li>
       <strong>
        绑定操作
       </strong>
       ：使用
       <code>
        channel.queueBind
       </code>
       方法将队列 1 绑定到主题模式
       <code>
        "*.error"
       </code>
       ，队列 2 绑定到主题模式
       <code>
        "#.info"
       </code>
       和
       <code>
        "*.error"
       </code>
       。其中，
       <code>
        *
       </code>
       表示匹配一个单词，
       <code>
        #
       </code>
       表示匹配零个或多个单词。
      </li>
      <li>
       <strong>
        消息发送
       </strong>
       ：使用
       <code>
        channel.basicPublish
       </code>
       方法根据不同的主题发送不同的消息。
      </li>
      <li>
       <strong>
        资源释放
       </strong>
       ：发送完消息后，关闭通道和连接。
      </li>
     </ul>
    </blockquote>
    <h3>
     3. 消费者代码
    </h3>
    <p>
     消费者的主要任务是创建与 RabbitMQ 的连接，从指定的队列中接收并处理消息。
    </p>
    <p>
     消费者 1：
     <code>
      TopicRabbitmqConsumer1
     </code>
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class TopicRabbitmqConsumer1 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.TOPIC_QUEUE_NAME1, true, consumer);
    }
}
</code></pre>
    <p>
     消费者 2：
     <code>
      TopicRabbitmqConsumer2
     </code>
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class TopicRabbitmqConsumer2 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.TOPIC_QUEUE_NAME2, true, consumer);
    }
}
</code></pre>
    <blockquote>
     <p>
      代码解释：
     </p>
     <ul>
      <li>
       <strong>
        连接和通道创建
       </strong>
       ：与生产者类似，创建连接工厂、连接和通道。
      </li>
      <li>
       <strong>
        消息消费
       </strong>
       ：创建
       <code>
        DefaultConsumer
       </code>
       对象，并重写
       <code>
        handleDelivery
       </code>
       方法用于处理接收到的消息。使用
       <code>
        channel.basicConsume
       </code>
       方法从指定队列中消费消息，设置自动确认模式。
      </li>
     </ul>
     <p>
      4. 运行结果及分析
     </p>
     <p>
      运行步骤：
     </p>
     <ol>
      <li>
       先运行生产者程序，生产者会根据不同的主题将消息发送到主题交换器。
      </li>
      <li>
       再运行两个消费者程序，消费者会从各自绑定的队列中获取消息。
      </li>
     </ol>
     <p>
      结果分析：
     </p>
     <ul>
      <li>
       <code>
        TopicRabbitmqConsumer1
       </code>
       会接收到主题匹配
       <code>
        "*.error"
       </code>
       的消息，即
       <code>
        "hello topic, I'm order.error"
       </code>
       和
       <code>
        "hello topic, I'm pay.error"
       </code>
       。
      </li>
      <li>
       <code>
        TopicRabbitmqConsumer2
       </code>
       会接收到主题匹配
       <code>
        "#.info"
       </code>
       和
       <code>
        "*.error"
       </code>
       的消息，即
       <code>
        "hello topic, I'm order.pay.info"
       </code>
       、
       <code>
        "hello topic, I'm order.error"
       </code>
       和
       <code>
        "hello topic, I'm pay.error"
       </code>
       。
      </li>
     </ul>
     <p>
      通过这种方式，我们可以看到主题交换器模式根据主题模式灵活分发消息的特性，不同的队列可以根据绑定的主题模式接收不同的消息，实现了消息的灵活订阅和分发。
     </p>
    </blockquote>
    <hr/>
    <h2>
     6. RPC (Remote Procedure Call, 远程过程调用)
    </h2>
    <blockquote>
     <p>
      <img alt="" height="441" src="https://i-blog.csdnimg.cn/direct/f8ba8329a71348dc87cdb6f661e8c746.png" width="1200">
       <strong>
        角色
       </strong>
       ：
      </img>
     </p>
     <ul>
      <li>
       <strong>
        客户端 (Client)
       </strong>
       : 发送请求消息并等待响应。
      </li>
      <li>
       <strong>
        服务端 (Server)
       </strong>
       : 接收请求消息并发送响应消息。
      </li>
     </ul>
     <p>
      <img alt="" height="302" src="https://i-blog.csdnimg.cn/direct/3357580eb72646669e2199961d0cc762.png" width="1042"/>
     </p>
     <p>
      <strong>
       特点
      </strong>
      ：客户端发送消息到指定的队列，并设置 replyTo 字段指定回调队列。服务端处理请求并发送响应消息到回调队列。客户端在回调队列上等待响应消息，并检查 correlationId 属性以确保它是所期望的响应。
     </p>
     <p>
     </p>
     <p>
      <strong>
       适用场景
      </strong>
      ：需要实现远程调用的过程，例如微服务间的通信。
     </p>
    </blockquote>
    <h3>
     1. 常量
    </h3>
    <p>
     首先，我们定义一些常量，用于存储 RabbitMQ 连接信息以及主题交换器和队列的名称。
    </p>
    <pre><code class="language-java">public class Constants {
    public static final String HOST = "110.41.51.65";
    public static final Integer PORT = 15673;
    public static final String VIRTUAL_HOST = "bite";
    public static final String USER_NAME = "study";
    public static final String PASSWORD = "study";
    public static final String TOPIC_EXCHANGE_NAME = "test_topic";
    public static final String TOPIC_QUEUE_NAME1 = "topic_queue1";
    public static final String TOPIC_QUEUE_NAME2 = "topic_queue2";
}
</code></pre>
    <h3>
     2. 生产者
    </h3>
    <p>
     生产者的主要任务是创建与 RabbitMQ 的连接，声明主题交换器和队列，将队列与交换器通过不同的主题模式进行绑定，最后根据不同的主题发送消息。
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import constant.Constants;

public class TopicRabbitProducer {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 创建主题交换器
        channel.exchangeDeclare(Constants.TOPIC_EXCHANGE_NAME, 
                BuiltinExchangeType.TOPIC, true, false, false, null);

        // 5. 声明队列
        channel.queueDeclare(Constants.TOPIC_QUEUE_NAME1, true, false, false, null);
        channel.queueDeclare(Constants.TOPIC_QUEUE_NAME2, true, false, false, null);

        // 6. 绑定队列和交换器
        // 队列 1 绑定 *.error，仅接收 error 信息
        channel.queueBind(Constants.TOPIC_QUEUE_NAME1, Constants.TOPIC_EXCHANGE_NAME, "*.error");
        // 队列 2 绑定 #.info 和 *.error，接收 info 和 error 信息
        channel.queueBind(Constants.TOPIC_QUEUE_NAME2, Constants.TOPIC_EXCHANGE_NAME, "#.info");
        channel.queueBind(Constants.TOPIC_QUEUE_NAME2, Constants.TOPIC_EXCHANGE_NAME, "*.error");

        // 7. 发送消息
        String msg = "hello topic, I'm order.error";
        channel.basicPublish(Constants.TOPIC_EXCHANGE_NAME, "order.error", null, msg.getBytes());

        String msg_black = "hello topic, I'm order.pay.info";
        channel.basicPublish(Constants.TOPIC_EXCHANGE_NAME, "order.pay.info", null, msg_black.getBytes());

        String msg_green = "hello topic, I'm pay.error";
        channel.basicPublish(Constants.TOPIC_EXCHANGE_NAME, "pay.error", null, msg_green.getBytes());

        // 8. 释放资源
        channel.close();
        connection.close();
    }
}
</code></pre>
    <p>
     代码解释：
    </p>
    <blockquote>
     <ul>
      <li>
       <strong>
        连接设置
       </strong>
       ：使用
       <code>
        ConnectionFactory
       </code>
       创建连接工厂，并设置 RabbitMQ 服务器的主机地址、端口、虚拟主机、用户名和密码，然后创建连接和通道。
      </li>
      <li>
       <strong>
        交换器声明
       </strong>
       ：使用
       <code>
        channel.exchangeDeclare
       </code>
       方法声明一个主题交换器，指定交换器名称、类型为
       <code>
        TOPIC
       </code>
       ，并设置为持久化。
      </li>
      <li>
       <strong>
        队列声明
       </strong>
       ：使用
       <code>
        channel.queueDeclare
       </code>
       方法声明两个队列，同样设置为持久化。
      </li>
      <li>
       <strong>
        绑定操作
       </strong>
       ：使用
       <code>
        channel.queueBind
       </code>
       方法将队列 1 绑定到主题模式
       <code>
        "*.error"
       </code>
       ，队列 2 绑定到主题模式
       <code>
        "#.info"
       </code>
       和
       <code>
        "*.error"
       </code>
       。其中，
       <code>
        *
       </code>
       表示匹配一个单词，
       <code>
        #
       </code>
       表示匹配零个或多个单词。
      </li>
      <li>
       <strong>
        消息发送
       </strong>
       ：使用
       <code>
        channel.basicPublish
       </code>
       方法根据不同的主题发送不同的消息。
      </li>
      <li>
       <strong>
        资源释放
       </strong>
       ：发送完消息后，关闭通道和连接。
      </li>
     </ul>
    </blockquote>
    <h3>
     3. 消费者
    </h3>
    <p>
     消费者的主要任务是创建与 RabbitMQ 的连接，从指定的队列中接收并处理消息。
    </p>
    <p>
     消费者 1：
     <code>
      TopicRabbitmqConsumer1
     </code>
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class TopicRabbitmqConsumer1 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.TOPIC_QUEUE_NAME1, true, consumer);
    }
}
</code></pre>
    <p>
     消费者 2：
     <code>
      TopicRabbitmqConsumer2
     </code>
    </p>
    <pre><code class="language-java">import com.rabbitmq.client.*;
import constant.Constants;
import java.io.IOException;

public class TopicRabbitmqConsumer2 {
    public static void main(String[] args) throws Exception {
        // 1. 创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 设置连接参数
        factory.setHost(Constants.HOST);
        factory.setPort(Constants.PORT);
        factory.setVirtualHost(Constants.VIRTUAL_HOST);
        factory.setUsername(Constants.USER_NAME);
        factory.setPassword(Constants.PASSWORD);

        // 2. 创建连接
        Connection connection = factory.newConnection();
        // 3. 创建通道
        Channel channel = connection.createChannel();

        // 4. 接收并消费消息
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println("接收到消息: " + new String(body));
            }
        };
        channel.basicConsume(Constants.TOPIC_QUEUE_NAME2, true, consumer);
    }
}
</code></pre>
    <blockquote>
     <p>
      代码解释：
     </p>
     <ul>
      <li>
       <strong>
        连接和通道创建
       </strong>
       ：与生产者类似，创建连接工厂、连接和通道。
      </li>
      <li>
       <strong>
        消息消费
       </strong>
       ：创建
       <code>
        DefaultConsumer
       </code>
       对象，并重写
       <code>
        handleDelivery
       </code>
       方法用于处理接收到的消息。使用
       <code>
        channel.basicConsume
       </code>
       方法从指定队列中消费消息，设置自动确认模式。
      </li>
     </ul>
     <p>
      4. 运行结果及分析
     </p>
     <p>
      运行步骤：
     </p>
     <ol>
      <li>
       先运行生产者程序，生产者会根据不同的主题将消息发送到主题交换器。
      </li>
      <li>
       再运行两个消费者程序，消费者会从各自绑定的队列中获取消息。
      </li>
     </ol>
     <p>
      结果分析：
     </p>
     <ul>
      <li>
       <code>
        TopicRabbitmqConsumer1
       </code>
       会接收到主题匹配
       <code>
        "*.error"
       </code>
       的消息，即
       <code>
        "hello topic, I'm order.error"
       </code>
       和
       <code>
        "hello topic, I'm pay.error"
       </code>
       。
      </li>
      <li>
       <code>
        TopicRabbitmqConsumer2
       </code>
       会接收到主题匹配
       <code>
        "#.info"
       </code>
       和
       <code>
        "*.error"
       </code>
       的消息，即
       <code>
        "hello topic, I'm order.pay.info"
       </code>
       、
       <code>
        "hello topic, I'm order.error"
       </code>
       和
       <code>
        "hello topic, I'm pay.error"
       </code>
       。
      </li>
     </ul>
     <p>
      通过这种方式，我们可以看到主题交换器模式根据主题模式灵活分发消息的特性，不同的队列可以根据绑定的主题模式接收不同的消息，实现了消息的灵活订阅和分发。
     </p>
    </blockquote>
    <hr/>
    <h2 style="background-color:transparent">
     7. Publisher Confirms（发布确认）
    </h2>
    <blockquote>
     <p>
      <strong>
       角色
      </strong>
      ：
     </p>
     <ul>
      <li>
       <strong>
        P (Producer)
       </strong>
       : 生产者。
      </li>
      <li>
       <strong>
        RabbitMQ Server
       </strong>
       : 消息服务器.
      </li>
     </ul>
     <p>
     </p>
     <p>
      <strong>
       特点
      </strong>
      ：生产者将 Channel 设置为 confirm 模式，发布的每一条消息都会获得一个唯一的 ID。当消息被 RabbitMQ 服务器接收并处理后，服务器会异步地向生产者发送一个确认 (ACK)，表明消息已经送达。
     </p>
     <p>
     </p>
     <p>
      <strong>
       适用场景
      </strong>
      ：对数据安全性要求较高的场景，例如金融交易、订单处理。
     </p>
     <p>
     </p>
     <p>
      <img alt="" height="358" src="https://i-blog.csdnimg.cn/direct/1d99f9905cb247d68a9a33f42b4baff5.png" width="1089"/>
     </p>
    </blockquote>
    <h3>
     1. 常量类
    </h3>
    <p>
     首先，我们需要定义一些常量，包括 RabbitMQ 的连接信息和队列名称，以及要发送的消息数量。假设我们已经有一个
     <code>
      Constants
     </code>
     类来存储 RabbitMQ 的连接信息。
    </p>
    <pre><code class="language-java">import constant.Constants;
import java.io.IOException;
import java.util.Collections;
import java.util.SortedSet;
import java.util.TreeSet;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConfirmListener;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class PublisherConfirms {
    private static final int MESSAGE_COUNT = 500;
    private static final String PUBLISHER_CONFIRMS_QUEUE_NAME1 = "publisher_confirms_queue1";
    private static final String PUBLISHER_CONFIRMS_QUEUE_NAME2 = "publisher_confirms_queue2";
    private static final String PUBLISHER_CONFIRMS_QUEUE_NAME3 = "publisher_confirms_queue3";

    // 创建 RabbitMQ 连接
    static Connection createConnection() throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(Constants.HOST); // ip 默认值 localhost
        factory.setPort(Constants.PORT); // 默认值 5672
        factory.setVirtualHost(Constants.VIRTUAL_HOST); // 虚拟机名称, 默认 /
        factory.setUsername(Constants.USER_NAME); // ⽤⼾名, 默认 guest
        factory.setPassword(Constants.PASSWORD); // 密码, 默认 guest
        return factory.newConnection();
    }

    public static void main(String[] args) throws Exception {
        publishMessagesIndividually();
        publishMessagesInBatch();
        handlePublishConfirmsAsynchronously();
    }
</code></pre>
    <h3 style="background-color:transparent">
     2. 单独确认模式（Individual Confirms）
    </h3>
    <p>
     在单独确认模式下，生产者每发送一条消息后，会等待 Broker 的确认信号，只有在收到确认后才会继续发送下一条消息。这种模式的优点是简单直观，但性能较低，因为每次发送消息都需要等待确认，会引入额外的延迟。
    </p>
    <pre><code class="language-java">    static void publishMessagesIndividually() throws Exception {
        try (Connection connection = createConnection()) {
            // 创建 channel
            Channel ch = connection.createChannel();
            // 开启信道确认模式
            ch.confirmSelect();
            // 声明队列
            ch.queueDeclare(PUBLISHER_CONFIRMS_QUEUE_NAME1, true, false, true, null);

            long start = System.currentTimeMillis();
            // 循环发送消息
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String body = "消息" + i;
                // 发布消息
                ch.basicPublish("", PUBLISHER_CONFIRMS_QUEUE_NAME1, null, body.getBytes());
                // 等待确认消息。只要消息被确认，这个方法就会返回
                // 如果超时过期, 则抛出 TimeoutException。如果任何消息被 nack(丢失）, waitForConfirmsOrDie 将抛出 IOException。
                ch.waitForConfirmsOrDie(5_000);
            }
            long end = System.currentTimeMillis();
            System.out.format("Published %d messages individually in %d ms%n", MESSAGE_COUNT, end - start);
        }
    }
</code></pre>
    <h3 style="background-color:transparent">
     3. 批量确认模式（Batch Confirms）
    </h3>
    <p>
     批量确认模式是将多条消息作为一个批次发送，然后等待整个批次的消息都被确认。这种模式的性能比单独确认模式要好，因为减少了等待确认的次数，但如果其中一条消息失败，需要重新发送整个批次的消息。
    </p>
    <pre><code class="language-java">    static void publishMessagesInBatch() throws Exception {
        try (Connection connection = createConnection()) {
            // 创建信道
            Channel ch = connection.createChannel();
            // 信道设置为 confirm 模式
            ch.confirmSelect();
            // 声明队列
            ch.queueDeclare(PUBLISHER_CONFIRMS_QUEUE_NAME2, true, false, true, null);

            int batchSize = 100;
            int outstandingMessageCount = 0;
            long start = System.currentTimeMillis();

            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String body = "消息" + i;
                // 发送消息
                ch.basicPublish("", PUBLISHER_CONFIRMS_QUEUE_NAME2, null, body.getBytes());
                outstandingMessageCount++;
                // 批量确认消息
                if (outstandingMessageCount == batchSize) {
                    ch.waitForConfirmsOrDie(5_000);
                    outstandingMessageCount = 0;
                }
            }
            // 消息发送完，还有未确认的消息，进行确认
            if (outstandingMessageCount &gt; 0) {
                ch.waitForConfirmsOrDie(5_000);
            }
            long end = System.currentTimeMillis();
            System.out.format("Published %d messages in batch in %d ms%n", MESSAGE_COUNT, end - start);
        }
    }
</code></pre>
    <h3>
     4. 异步确认模式（Asynchronous Confirms）
    </h3>
    <p>
     异步确认模式是在发送消息的同时，通过注册一个确认监听器来处理 Broker 的确认信号。这种模式的性能最高，因为生产者可以在发送消息后继续发送其他消息，而不需要等待确认，确认信号会在后台异步处理。
    </p>
    <pre><code class="language-java">    static void handlePublishConfirmsAsynchronously() throws Exception {
        try (Connection connection = createConnection()) {
            Channel ch = connection.createChannel();
            ch.queueDeclare(PUBLISHER_CONFIRMS_QUEUE_NAME3, false, false, true, null);
            ch.confirmSelect();

            // 有序集合，元素按照自然顺序进行排序，存储未 confirm 消息序号
            SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;&gt;());

            ch.addConfirmListener(new ConfirmListener() {
                @Override
                public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                    // multiple 批量
                    // confirmSet.headSet(n) 方法返回当前集合中小于 n 的集合
                    if (multiple) {
                        // 批量确认：将集合中小于等于当前序号 deliveryTag 元素的集合清除，表示这批序号的消息都已经被 ack 了
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        // 单条确认：将当前的 deliveryTag 从集合中移除
                        confirmSet.remove(deliveryTag);
                    }
                }

                @Override
                public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                    System.err.format("deliveryTag: %d, multiple: %b%n", deliveryTag, multiple);
                    if (multiple) {
                        // 批量确认：将集合中小于等于当前序号 deliveryTag 元素的集合清除，表示这批序号的消息都已经被 ack 了
                        confirmSet.headSet(deliveryTag + 1).clear();
                    } else {
                        // 单条确认：将当前的 deliveryTag 从集合中移除
                        confirmSet.remove(deliveryTag);
                    }
                    // 如果处理失败，这里需要添加处理消息重发的场景。此处代码省略
                }
            });

            // 循环发送消息
            long start = System.currentTimeMillis();
            for (int i = 0; i &lt; MESSAGE_COUNT; i++) {
                String message = "消息" + i;
                // 得到下次发送消息的序号，从 1 开始
                long nextPublishSeqNo = ch.getNextPublishSeqNo();
                ch.basicPublish("", PUBLISHER_CONFIRMS_QUEUE_NAME3, null, message.getBytes());
                // 将序号存入集合中
                confirmSet.add(nextPublishSeqNo);
            }

            // 消息确认完毕
            while (!confirmSet.isEmpty()) {
                Thread.sleep(10);
            }
            long end = System.currentTimeMillis();
            System.out.format("Published %d messages and handled confirms asynchronously in %d ms%n", MESSAGE_COUNT, end - start);
        }
    }
}
</code></pre>
    <h3>
     5. 性能对比
    </h3>
    <p>
     消息数越多，异步确认的优势越明显。以下是不同消息数量下三种策略的性能对比：
    </p>
    <h4>
     200 条消息的结果对比
    </h4>
    <pre><code>Published 200 messages individually in 6931 ms
Published 200 messages in batch in 137 ms
Published 200 messages and handled confirms asynchronously in 73 ms
</code></pre>
    <h4>
     500 条消息结果对比
    </h4>
    <pre><code>Published 500 messages individually in 15805 ms
Published 500 messages in batch in 246 ms
Published 500 messages and handled confirms asynchronously in 107 ms
</code></pre>
    <blockquote>
     <ul>
      <li>
       从上述结果可以看出，
       <strong>
        单独确认模式
       </strong>
       的性能最差，因为它需要为每条消息等待确认，引入了大量的延迟。
      </li>
      <li>
       <strong>
        批量确认模式
       </strong>
       通过减少等待确认的次数，提高了性能。
      </li>
      <li>
       而
       <strong>
        异步确认模式
       </strong>
       则进一步优化了性能，因为它允许生产者在发送消息的同时继续处理其他任务，确认信号在后台异步处理。
      </li>
     </ul>
     <p>
      因此，
      <strong>
       在需要高吞吐量的场景中，建议使用异步确认模式。
      </strong>
     </p>
    </blockquote>
    <hr/>
    <h2>
     总结
    </h2>
    <h4>
     <img alt="" height="254" src="https://i-blog.csdnimg.cn/direct/d6912cc95a344f0eb6a83a7df572ddf4.png" width="839"/>
    </h4>
    <p>
     <strong>
      <span style="color:#956fe7">
       画了这么久的饼终于实现了哈哈哈，不过现在大部分都用 springboot 封装的来实现了。以前肯定还有很多坑，以后会慢慢补全的，感谢阅览！！
      </span>
     </strong>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f595f313231352f:61727469636c652f64657461696c732f313436303530393832" class_="artid" style="display:none">
 </p>
</div>


