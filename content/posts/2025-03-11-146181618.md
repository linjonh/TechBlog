---
layout: post
title: "shell脚本基础"
date: 2025-03-11 16:25:21 +0800
description: "while [ \"$1\" = \"go\" ]    while [ \"1\" = \"1\"]（直接执行）  while [ \"$1\" = \"start\" ] (有动作的执行)\"$a\" -lt \"0\" ] && echo yes || echo no yes（条件反选）脚本练习：脚本后写一个文件名称，如果存在输出文件的类型，如果不存在则输出文件不存在。3.用命令的执行结果充当变量的值（反引号提取执行的结果）-a/-e 文件是否存在 -L 软连接 -r 读权限。||在命令执行后如果命令有报错会执行符号后的动作。"
keywords: "shell脚本基础"
categories: ['未分类']
tags: ['运维', '服务器', 'Linux']
artid: "146181618"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146181618
    alt: "shell脚本基础"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146181618
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146181618
cover: https://bing.ee123.net/img/rand?artid=146181618
image: https://bing.ee123.net/img/rand?artid=146181618
img: https://bing.ee123.net/img/rand?artid=146181618
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     shell脚本基础
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     1.shell条件测试
    </h3>
    <h4>
     1.1命令执行结果判定
    </h4>
    <p>
     &amp;&amp;在命令执行后如果没有任何报错时会执行符号后面的动作
    </p>
    <p>
     ||在命令执行后如果命令有报错会执行符号后的动作
    </p>
    <pre>ping -c1 -w1 $* &amp;&gt; /dev/null &amp;&amp; {
  echo -e "$* is up"
}||{
  echo -e "$* is done"
}</pre>
    <p>
     对命令执行结果的判定
    </p>
    <p>
     脚本练习：检查用户是否存在，如果不存在就创建它，并且将密码设置为用户名
    </p>
    <pre>id $1 &amp;&gt; /dev/null &amp;&amp;{
  echo $1 is exist
}||{
  echo $1 is not exist
  useradd $1
  echo $1 | passwd --stdin $1 &amp;&gt; /dev/null &amp;&amp; echo $1 is created
}</pre>
    <h4>
     1.2条件判定方法
    </h4>
    <p>
     脚本后的字符个数为
     <strong>
      $#
     </strong>
    </p>
    <p>
     test = [],扩展的表达式要用[[ ]]括起来
    </p>
    <p>
     [root@node ~]# [[ $a =~ 1|2 ]] &amp;&amp; echo yes || echo no
    </p>
    <p>
     判断a是不是在0-10之间
    </p>
    <p>
     [root@node ~]# (($a&lt;10&amp;&amp;$a&gt;0)) &amp;&amp; echo yes || echo no
    </p>
    <p>
     (( ))只适用于整数
    </p>
    <h4>
     1.3文件判断表达式
    </h4>
    <p>
     -a/-e 文件是否存在 -L 软连接 -r 读权限
    </p>
    <p>
     -b 扩展设备 -d 目录 -w 写权限
    </p>
    <p>
     -c 字符设备 -f 普通目录 -x执行权限
    </p>
    <p>
     -s 大s套接字小s文件大小不为零
    </p>
    <p>
     -u 设置了特殊权限的suid
    </p>
    <p>
     [root@node ~]# [ -e "/mnt/file" ]&amp;&amp; echo yes || echo no
    </p>
    <p>
     脚本练习：脚本后写一个文件名称，如果存在输出文件的类型，如果不存在则输出文件不存在
    </p>
    <pre>[ -e "$1" ] || {
  echo $1 is not exist
  exit
}
[ -L "$1" ] &amp;&amp;{
  echo $1 is link file
}
[ -f "$1" ] &amp;&amp;{
  echo $1 is common file
  exit
}
[ -d "$1" ] &amp;&amp;{
  echo $1 is dir file
}
​</pre>
    <h4>
     1.4字符串测试表达式
    </h4>
    <p>
     [root@node ~]# [ -z "$c" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     [root@node ~]# [ -n "$c" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     -n 判定是否不为空
    </p>
    <p>
     -z 判定是否为空
    </p>
    <p>
     = ！=
    </p>
    <p>
     测试字符串
    </p>
    <h4>
     1.5整数测试表达式
    </h4>
    <p>
     -eq ==或= -ge &gt;=
    </p>
    <p>
     -ne != -le &lt;=
    </p>
    <p>
     -gt &gt; -lt &lt;
    </p>
    <p>
     [root@node ~]# [ "$a" -lt "1" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     [root@node ~]# [ "$a" -gt "1" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     [root@node ~]# [ "$a" -ge "1" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     [root@node ~]# [ "$a" -le "1" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     [root@node ~]# [ "$a" -eq "1" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     [root@node ~]# [ "$a" -ne "1" ] &amp;&amp; echo yes || echo no
    </p>
    <p>
     man test(查看帮助)
    </p>
    <h4>
     1.6判定中的逻辑操作符
    </h4>
    <p>
     [root@node ~]# [[ "$a" -gt 0 ]]&amp;&amp;[[ "$a" -lt "10" ]] &amp;&amp; echo yes || echo no yes
    </p>
    <p>
     [root@node ~]# (( "$a"&gt;0 &amp;&amp; "$a"&lt;10 )) &amp;&amp; echo yes || echo no yes
    </p>
    <p>
     [root@node ~]# [ "$a" -gt 0 -a "$a" -lt "10" ] &amp;&amp; echo yes || echo no yes
    </p>
    <p>
     [root@node ~]# test "$a" -gt 0 -a "$a" -lt "10" &amp;&amp; echo yes || echo no yes
    </p>
    <p>
     [root@node ~]# [ ! "$a" -lt "0" ] &amp;&amp; echo yes || echo no yes（条件反选）
    </p>
    <h3>
     2.shell脚本中的运行流程控制
    </h3>
    <h4>
     1.1if判定语句
    </h4>
    <p>
     脚本默认的程序执行方式是自上而下的
    </p>
    <p>
     <strong>
      if单分支结构
     </strong>
    </p>
    <pre>if [ "$USER" = "root" ]
then
  echo supper user
fi</pre>
    <p>
     <strong>
      if双分支结构
     </strong>
    </p>
    <pre>if [ "$1" = "root" ]
then
  echo supper user
elif [ -z "$1" ]
then
  echo pleas input username
else
  echo unknow error
fi</pre>
    <p>
     <strong>
      练习
     </strong>
     ：if脚本代码
    </p>
    <pre>read -p "please input username: " USERNAME
read -p "what do you want [D]elete or [C]create:" ACTION
​
if [[ -z "$USERNAME" ]]
then
  echo error: please input username
  exit
elif [[ ! "$USER" = "root" ]]
then
  echo  "error: please run $0 with root"
elif [[ "$ACTION" =~ d|D  ]]
then
​
   if id $USERNAME &amp;&gt; /dev/null
   then
     userdel -r $USERNAME
     echo $USERNAME is deleted
   else
     echo $USERNAME is not exist 
   fi
​
elif [[ "$ACTION" =~ C|c ]]
then
​
   if id $USERNAME &amp;&gt; /dev/null
   then
     echo $USERNAME is exist
   else
    read -p "please input password:" PASS
    useradd $USERNAME
    echo $PASS | passwd --stdin $USERNAME &amp;&gt; /dev/null
   fi
​
else
  echo "error: please input C|D for action!!"
fi
​</pre>
    <h4>
     2.2shell脚本中的选择判断（case语句）
    </h4>
    <p>
     用if做判断选择执行效率低，则需要使用case语句
    </p>
    <pre>case $1 in
    linux|Linux|LINUX)           一个“）”是一个按钮
    echo zee
    ;;
    zee)
    echo linux
    ;;
    *) 其他和*都匹配
    echo error
esac
​</pre>
    <p>
     case可以解决恰巧在最后，执行效率会比较低的问题
    </p>
    <ul>
     <li>
      <p>
       case $1 in
      </p>
     </li>
     <li>
      <p>
       echo liux
      </p>
     </li>
     <li>
      <p>
       case $1 in
      </p>
     </li>
     <li>
      <p>
       echo zee
      </p>
     </li>
    </ul>
    <ul>
     <li>
      <p>
       '[' linux = linux ']'
      </p>
     </li>
     <li>
      <p>
       echo zee
      </p>
     </li>
     <li>
      <p>
       '[' zee = linux ']'
      </p>
     </li>
     <li>
      <p>
       '[' zee = zee ']'
      </p>
     </li>
     <li>
      <p>
       echo linux
      </p>
     </li>
    </ul>
    <h4>
     2.3脚本中的循环语句
    </h4>
    <h5>
     2.3.1无条件for循环
    </h5>
    <p>
     1.罗列变量的写法
    </p>
    <pre>for USERNAME in test1 test2 test3
do
  echo $USERNAME
done</pre>
    <p>
     2.连续选择的写法
    </p>
    <pre>for USERNAME in {1..10}
do
  echo $USERNAME
done
​</pre>
    <p>
     3.用命令的执行结果充当变量的值（反引号提取执行的结果）
    </p>
    <p>
     一次执行一个
    </p>
    <pre>for USERNAME in `ls /root`
do
  echo $USERNAME
done
​</pre>
    <p>
     4.用seq
    </p>
    <pre>for USERNAME in `seq 1 2 10`
do
  echo $USERNAME
done</pre>
    <p>
     5.用运算的方式
    </p>
    <pre>for ((USERNAME=1;USERNAME&lt;=10;USERNAME++))
do
  echo $USERNAME
done</pre>
    <h5>
     2.3.2有条件的循环while
    </h5>
    <p>
     条件成立
    </p>
    <pre>while [ "$1" = "go" ]    while [ "1" = "1"]（直接执行）  while [ "$1" = "start" ] (有动作的执行)
do
  for N in {1..10}
  do
      echo $N
  done
done</pre>
    <p>
     条件不成立用until
    </p>
    <pre>until [ "$1" = "go" ]
do
  for N in {1..10}
  do
      echo $N
  done
done</pre>
    <p>
     示例
    </p>
    <pre>while [ "$1" = "go" ]
do
  clear （清空屏幕）
  ls -l /root
  sleep 1 （等1秒）
done</pre>
    <p>
     <strong>
      练习
     </strong>
     ：1分10秒倒计时
    </p>
    <p>
     echo -ne （不换行 \生效）
    </p>
    <p>
     [ -a ]并且
    </p>
    <pre>SEC=10
MIN=1
SECS=$[ $MIN*60+$SEC]
for ((;SECS&gt;0;SECS--))
do
    sec=$[$SECS%60]
    min=$[$SECS/60]
    echo -ne "after $min:$sec is end"
    echo -ne "\r"
    sleep 1
done</pre>
    <h4>
     2.4循环中的控制器
    </h4>
    <p>
     1.exit
    </p>
    <pre>for n in {1..10}
do
  if [ "$n" -eq "4" ]
  then
    echo luck
    exit （退出脚本）
  fi
  echo $n
done</pre>
    <p>
     2.break
    </p>
    <pre>for n in {1..10}
do
  if [ "$n" -eq "4" ]
  then
    echo luck
    break（退出循环）
  fi
  echo $n
done</pre>
    <p>
     3.continue
    </p>
    <pre>for n in {1..10}
do
  if [ "$n" -eq "4" ]
  then
    echo luck
    continue（下面放弃掉，提前进入下一次循环）
  fi
  echo $n
done</pre>
    <p>
     4.return
    </p>
    <pre>FOR()
{
for n in {1..10}
do
  if [ "$n" -eq "4" ]
  then
    echo luck
    return（退出函数
  fi
  echo $n
done
}
FOR</pre>
    <h4>
     2.5自动应答
    </h4>
    <p>
     如果我们想要依照问题的内容回答问题需要借助软件expect（一种环境）
    </p>
    <p>
     [root@node mnt]# dnf install expect -y 下载软件
    </p>
    <p>
     [root@node mnt]# vim answer.exp
    </p>
    <pre>#!/usr/bin/expect
spawn /mnt/ask.sh #spawn监控ask.sh
expect {
    "name" { send "zee\r";exp_continue }
    "old" { send "18\r";exp_continue }
    "subject" { send "linux\r";exp_continue }
    "happy" { send "happy\r" }
}
expect eof  #应答完毕后退出
interact #保留当前的绘画环境</pre>
    <p>
     [root@node mnt]# expect answer.exp
    </p>
    <p>
     <strong>
      shell版本
     </strong>
    </p>
    <pre>#!/bin/bash
/usr/bin/expect &lt;&lt;EOF
spawn /mnt/ask.sh    将spawn写入expect执行
expect {
    "name" { send "zee\r";exp_continue }
    "old" { send "18\r";exp_continue }
    "subject" { send "linux\r";exp_continue }
    "happy" { send "happy\r" }
}
expect eof
EOF</pre>
    <p>
     函数的调用
    </p>
    <pre>AUTO_ANSWER()
{
/usr/bin/expect &lt;&lt;EOF
spawn /mnt/ask.sh    将spawn写入expect执行
expect {
    "name" { send "$1\r";exp_continue }
    "old" { send "$2\r";exp_continue }
    "subject" { send "$3\r";exp_continue }
    "happy" { send "$4\r" }
}
expect eof
EOF
}
AUTO_ANSWER zee 18 linux happy</pre>
    <h3>
    </h3>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37373332313739342f:61727469636c652f64657461696c732f313436313831363138" class_="artid" style="display:none">
 </p>
</div>


