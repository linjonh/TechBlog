---
layout: post
title: "Android-Native-之-文件系统挂载"
date: 2025-03-07 20:58:13 +0800
description: "众所周知，init进程为android系统的第一个进程，也是native世界的开端，要想让整个android世界能够稳定的运行，文件系统的创建和初始化是必不可少的，这个过程需要在android世界的前面。Init进程的通过FirstStageMount::Create()来拿到一个fsm对象，然后依次调用fsm的DoCreateDevices和DoFirstStageMount来初始化挂载文件系统。"
keywords: "Android Native 之 文件系统挂载"
categories: ['Android']
tags: ['Android']
artid: "146104979"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146104979
    alt: "Android-Native-之-文件系统挂载"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146104979
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146104979
cover: https://bing.ee123.net/img/rand?artid=146104979
image: https://bing.ee123.net/img/rand?artid=146104979
img: https://bing.ee123.net/img/rand?artid=146104979
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android Native 之 文件系统挂载
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、文件系统挂载流程概述
    </h2>
    <h2>
     二、文件系统挂载流程细节
    </h2>
    <h3>
     1、Init启动阶段
    </h3>
    <p>
     众所周知，init进程为android系统的第一个进程，也是native世界的开端，要想让整个android世界能够稳定的运行，文件系统的创建和初始化是必不可少的，这个过程需要在android世界的前面。
    </p>
    <pre><code class="language-cpp">//aosp/system/core/init/first_stage_init.cpp
int FirstStageMain(int argc, char** argv) {
    LOG(INFO) &lt;&lt; "init first stage started!";
    //.....
    bool created_devices = false;
    if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) {
        if (!IsRecoveryMode()) {
            //第一步：创建设备
            created_devices = DoCreateDevices();
            if (!created_devices) {
                LOG(ERROR) &lt;&lt; "Failed to create device nodes early";
            }
        }
        StartConsole(cmdline);
    }
    //......
    //第二步：挂载设备
    if (!DoFirstStageMount(!created_devices)) {
        LOG(FATAL) &lt;&lt; "Failed to mount required partitions early ...";
    }
    //.....
}
//aosp/system/core/init/first_stage_mount.cpp
// Public functions公共函数
// Creates devices and logical partitions from storage devices
bool DoCreateDevices() {
    auto fsm = FirstStageMount::Create();
    if (!fsm.ok()) {
        LOG(ERROR) &lt;&lt; "Failed to create FirstStageMount: " &lt;&lt; fsm.error();
        return false;
    }
    //来创建设备/即初始化磁盘逻辑分区
    return (*fsm)-&gt;DoCreateDevices();
}
// Mounts partitions specified by fstab in device tree.
bool DoFirstStageMount(bool create_devices) {
    // Skips first stage mount if we're in recovery mode.
    if (IsRecoveryMode()) {
        LOG(INFO) &lt;&lt; "First stage mount skipped (recovery mode)";
        return true;
    }
    auto fsm = FirstStageMount::Create();
    if (!fsm.ok()) {
        LOG(ERROR) &lt;&lt; "Failed to create FirstStageMount " &lt;&lt; fsm.error();
        return false;
    }
    if (create_devices) {
        if (!(*fsm)-&gt;DoCreateDevices()) return false;
    }
    //来进行文件系统的挂载
    return (*fsm)-&gt;DoFirstStageMount();
}
//void SetInitAvbVersionInRecovery() 第三个public函数，看起来是和recovery有关系的

</code></pre>
    <p>
     Init进程的通过FirstStageMount::Create()来拿到一个fsm对象，然后依次调用fsm的DoCreateDevices和DoFirstStageMount来初始化挂载文件系统。
    </p>
    <h4>
     1.1 FirstStageMount::Create读取fstab配置表
    </h4>
    <p>
     此步骤主要是读取fstab分区配置表，具体实现逻辑其实移交给了fs_mgr
    </p>
    <pre><code class="language-cpp">//aosp/system/core/init/first_stage_mount.cpp
using android::fs_mgr::ReadDefaultFstab;
using android::fs_mgr::ReadFstabFromDt;
Result&lt;std::unique_ptr&lt;FirstStageMount&gt;&gt; FirstStageMount::Create() {
    //读取fstab配置表，此表配置了各个目录支持的文件系统相关配置
    auto fstab = ReadFirstStageFstab();
    if (!fstab.ok()) {
        return fstab.error();
    }
    return std::make_unique&lt;FirstStageMountVBootV2&gt;(std::move(*fstab));
}
static Result&lt;Fstab&gt; ReadFirstStageFstab() {
    Fstab fstab;
    //从DT里面获取，DT好像跟内核有关系，没有具体研究
    if (!ReadFstabFromDt(&amp;fstab)) {
        //读取默认的fstab配置表
        if (ReadDefaultFstab(&amp;fstab)) {
            fstab.erase(std::remove_if(fstab.begin(), fstab.end(),
                                       [](const auto&amp; entry) { return !entry.fs_mgr_flags.first_stage_mount; }),
                        fstab.end());
        } else {
            return Error() &lt;&lt; "failed to read default fstab for first stage mount";
        }
    }
    return fstab;
}</code></pre>
    <p>
     fs_mgr被编译成为静态库lib_fs_mgr，这部分逻辑其实就是读取fstab.ini配置文件并进行解析：
    </p>
    <pre><code class="language-cpp">//aosp/system/core/fs_mgr/fs_mgr_fstab.cpp
// Loads the fstab file and combines with fstab entries passed in from device tree.
bool ReadDefaultFstab(Fstab* fstab) {
    fstab-&gt;clear();
    ReadFstabFromDt(fstab, false /* verbose */);
    std::string default_fstab_path;
    // Use different fstab paths for normal boot and recovery boot, respectively
    if ((access("/sbin/recovery", F_OK) == 0) || (access("/system/bin/recovery", F_OK) == 0)) {
        //recovery模式下读取/etc/recovery.fstab
        default_fstab_path = "/etc/recovery.fstab";
    } else { //正常模式下读取类似于/odm/etc/fstab.
        default_fstab_path = GetFstabPath();
    }
    Fstab default_fstab;
    if (!default_fstab_path.empty() &amp;&amp; ReadFstabFromFile(default_fstab_path, &amp;default_fstab)) {
        for (auto&amp;&amp; entry : default_fstab) {
            fstab-&gt;emplace_back(std::move(entry));
        }
    } else {
        LINFO &lt;&lt; __FUNCTION__ &lt;&lt; "(): failed to find device default fstab";
    }

    return !fstab-&gt;empty();
}
// Return the path to the fstab file.  There may be multiple fstab files; the
// one that is returned will be the first that exists of fstab.&lt;fstab_suffix&gt;,
// fstab.&lt;hardware&gt;, and fstab.&lt;hardware.platform&gt;.  The fstab is searched for
// in /odm/etc/ and /vendor/etc/, as well as in the locations where it may be in
// the first stage ramdisk during early boot.  Previously, the first stage
// ramdisk's copy of the fstab had to be located in the root directory, but now
// the system/etc directory is supported too and is the preferred location.
std::string GetFstabPath() {
    for (const char* prop : {"fstab_suffix", "hardware", "hardware.platform"}) {
        std::string suffix;

        if (!fs_mgr_get_boot_config(prop, &amp;suffix)) continue;

        for (const char* prefix : {// late-boot/post-boot locations
                                   "/odm/etc/fstab.", "/vendor/etc/fstab.",
                                   // early boot locations
                                   "/system/etc/fstab.", "/first_stage_ramdisk/system/etc/fstab.",
                                   "/fstab.", "/first_stage_ramdisk/fstab."}) {
            std::string fstab_path = prefix + suffix;
            if (access(fstab_path.c_str(), F_OK) == 0) {
                return fstab_path;
            }
        }
    }
    return "";
}</code></pre>
    <p>
     如下Android 14的手机的开机日志，在init阶段来读取fstab配置表的打印：这里的dt没有配置fstab，默认路径没有任何打印，但是可以了解到libfs_mgr的入口
    </p>
    <p>
     <img alt="" height="146" src="https://i-blog.csdnimg.cn/direct/402f58c8506a47f39a51bc0e5c7d53fb.png" width="983"/>
    </p>
    <h4>
     1.2 fstab文件是什么样子的？
    </h4>
    <p>
     android系统的文件系统相关参数定义被统一放在fstab.in里面，从上面的流程可以了解到fs_mgr会去读取fstab.*文件，并根据此文件配置的内容去逐一挂载所有的分区，那么它到底长什么样子的呢？
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       首先cat /vendor/etc/fstab.mtxxxx内容如下：
      </span>
     </strong>
    </p>
    <pre><code class="language-bash">D50:/vendor/etc # cat fsta
fstab.enableswap  fstab.mt6765      fstab.mt8768
D50:/vendor/etc # cat fstab.mt6765
# 1 "vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6765"
# 1 "&lt;built-in&gt;" 1
# 1 "&lt;built-in&gt;" 3
# 341 "&lt;built-in&gt;" 3
# 1 "&lt;command line&gt;" 1
# 1 "&lt;built-in&gt;" 2
# 1 "vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6765" 2
# 145 "vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6765"
system /system ext4 ro wait,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkey,slotselect
system_ext /system_ext ext4 ro wait,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkey,slotselect

vendor /vendor ext4 ro wait,avb,logical,first_stage_mount,slotselect


product /product ext4 ro wait,avb,logical,first_stage_mount,slotselect
# 170 "vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6765"
/dev/block/by-name/md_udc /metadata ext4 noatime,nosuid,nodev,discard wait,check,formattable,first_stage_mount

/dev/block/by-name/userdata /data f2fs noatime,nosuid,nodev,discard,noflush_merge,reserve_root=134217,resgid=1065,inlinecrypt latemount,wait,check,quota,reservedsize=128M,formattable,resize,,checkpoint=fs,fileencryption=aes-256-xts:aes-256-cts:v2,keydirectory=/metadata/vold/metadata_encryption

/dev/block/by-name/protect1 /mnt/vendor/protect_f ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable
/dev/block/by-name/protect2 /mnt/vendor/protect_s ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable
/dev/block/by-name/nvdata /mnt/vendor/nvdata ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable
/dev/block/by-name/nvcfg /mnt/vendor/nvcfg ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable

/dev/block/by-name/persist /mnt/vendor/persist ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable

/devices/platform/externdevice* auto auto defaults voldmanaged=sdcard1:auto,encryptable=userdata

/devices/platform/mt_usb* auto vfat defaults voldmanaged=usbotg:auto

/dev/block/by-name/frp /persistent emmc defaults defaults

/dev/block/by-name/nvram /nvram emmc defaults defaults
/dev/block/by-name/proinfo /proinfo emmc defaults defaults
/dev/block/by-name/lk /bootloader emmc defaults defaults
/dev/block/by-name/lk2 /bootloader2 emmc defaults defaults
/dev/block/by-name/para /misc emmc defaults defaults

/dev/block/by-name/boot /boot emmc defaults first_stage_mount,nofail,slotselect
# 210 "vendor/mediatek/proprietary/hardware/fstab/mt6765/fstab.in.mt6765"
/dev/block/by-name/vbmeta_vendor /vbmeta_vendor emmc defaults first_stage_mount,nofail,slotselect
/dev/block/by-name/vbmeta_system /vbmeta_system emmc defaults first_stage_mount,nofail,slotselect,avb=vbmeta

/dev/block/by-name/logo /logo emmc defaults defaults
/dev/block/by-name/expdb /expdb emmc defaults defaults
/dev/block/by-name/seccfg /seccfg emmc defaults defaults

/dev/block/by-name/tee1 /tee1 emmc defaults defaults
/dev/block/by-name/tee2 /tee2 emmc defaults defaults

/dev/block/by-name/scp1 /scp1 emmc defaults defaults
/dev/block/by-name/scp2 /scp2 emmc defaults defaults

/dev/block/by-name/sspm_1 /sspm_1 emmc defaults defaults
/dev/block/by-name/sspm_2 /sspm_2 emmc defaults defaults

/dev/block/by-name/md1img /md1img emmc defaults defaults
/dev/block/by-name/md1dsp /md1dsp emmc defaults defaults
/dev/block/by-name/md1arm7 /md1arm7 emmc defaults defaults
/dev/block/by-name/md3img /md3img emmc defaults defaults

/dev/block/by-name/gz1 /gz1 emmc defaults defaults
/dev/block/by-name/gz2 /gz2 emmc defaults defaults

/dev/block/by-name/spmfw /spmfw emmc defaults defaults

/dev/block/by-name/boot_para /boot_para emmc defaults defaults
/dev/block/by-name/odmdtbo /odmdtbo emmc defaults defaults
/dev/block/by-name/dtbo /dtbo emmc defaults defaults

/dev/block/by-name/vbmeta /vbmeta emmc defaults defaults
D50:/vendor/etc #</code></pre>
    <p>
     如上格式，此文件可以解析如下三部分
    </p>
    <p>
     <img alt="" height="499" src="https://i-blog.csdnimg.cn/direct/259b2d1891ec4407b3caa4c38b0e4d10.png" width="1325"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       那么我们在源代码是如何配置的呢？MTK可以参考如下逻辑，后文详细解读各大配置参数
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="761" src="https://i-blog.csdnimg.cn/direct/40c1a9dac569496d8ed9545f6490f0aa.png" width="1037"/>
    </p>
    <h4>
     1.3 FirstStageMount::DoCreateDevices
    </h4>
    <pre><code class="language-cpp">//aosp/system/core/init/first_stage_mount.cpp
bool FirstStageMount::DoCreateDevices() {
    if (!InitDevices()) return false;
    // Mount /metadata before creating logical partitions, since we need to
    // know whether a snapshot merge is in progress.
    auto metadata_partition = std::find_if(fstab_.begin(), fstab_.end(), [](const auto&amp; entry) {
        //从fstab配置表中寻找/metadata分区的信息，此分区很重要存储了一些元数据和秘钥相关的东西
        return entry.mount_point == "/metadata";
    });
    if (metadata_partition != fstab_.end()) {
        //首先需要挂载/metadata分区，因为它太重要了
        if (MountPartition(metadata_partition, true /* erase_same_mounts */)) {
            // Copies DSU AVB keys from the ramdisk to /metadata.
            // Must be done before the following TrySwitchSystemAsRoot().
            // Otherwise, ramdisk will be inaccessible after switching root.
            //它为什么重要，就是因为拷贝AVB Key到这个目录，详细的待后续研究
            CopyDsuAvbKeys();
        }
    }
    //创建逻辑分区
    if (!CreateLogicalPartitions()) return false;
    return true;
}</code></pre>
    <p>
     <strong>
      <span style="color:#fe2c24">
       流程1：如上逻辑首先挂载了/metadata分区，为什么要先挂载它？
      </span>
     </strong>
    </p>
    <p>
     <img alt="" height="271" src="https://i-blog.csdnimg.cn/direct/79922ec8115943319077d408b76577e8.png" width="1292"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       流程2：/metadata分区挂载流程对应日志：注意这里调用了metadata_partition函数传递了参数，所以只挂载了一个分区
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="331" src="https://i-blog.csdnimg.cn/direct/1c3b1ebfba2843a6b7e9402921e41df9.png" width="1087"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       流程3：创建逻辑分区，那么何为逻辑分区？从下面日志来看个人理解它类似与PC的C盘来区别于其他磁盘，因此这里的逻辑分区通常为system/vendor几个目录
      </strong>
     </span>
    </p>
    <p>
     <img alt="" height="389" src="https://i-blog.csdnimg.cn/direct/09cd1fab9465481e919316b86be7a48e.png" width="1149"/>
    </p>
    <p>
     如上日志对应逻辑代码如下：
    </p>
    <p>
     <img alt="" height="428" src="https://i-blog.csdnimg.cn/direct/ce5d65a07588406683fabf8a3943ee92.png" width="679"/>
    </p>
    <h4>
     1.4 FirstStageMount::DoFirstStageMount
    </h4>
    <pre><code class="language-cpp">//aosp/system/core/init/first_stage_mount.cpp
bool FirstStageMount::DoFirstStageMount() {
    if (!IsDmLinearEnabled() &amp;&amp; fstab_.empty()) {
        // Nothing to mount.
        LOG(INFO) &lt;&lt; "First stage mount skipped (missing/incompatible/empty fstab in device tree)";
        return true;
    }
    //挂载分区
    if (!MountPartitions()) return false;    
    return true;
}</code></pre>
    <p>
     这里的主要流程还是去调用MountPartitions()去挂载分区，注意这里不像metadata哪里传递了参数，因此这里是根据fstab表去挂载所有其他分区，代码如下：
    </p>
    <p>
     <img alt="" height="920" src="https://i-blog.csdnimg.cn/direct/a88eca833b204ecda66e5ace7b858e5a.png" width="829"/>
    </p>
    <p>
     <img alt="" height="823" src="https://i-blog.csdnimg.cn/direct/10aae2d662234e5789e73b9631635571.png" width="1696"/>
    </p>
    <h3>
     2、fstab文件参数解读
    </h3>
    <p>
    </p>
    <h3>
     3、mount_all挂载分区
    </h3>
    <p>
     <img alt="" height="759" src="https://i-blog.csdnimg.cn/direct/e2e08f93a8b041c9bf920a45caab4a18.png" width="1212"/>
    </p>
    <p>
     如上的一份开机日志，包括我在fs_mgr里面加的一些日志，可以看出来文件系统的挂载其实是init.rc里面触发执行mount_all命令。
    </p>
    <p>
     <img alt="" height="489" src="https://i-blog.csdnimg.cn/direct/e11512568a924a3995026e2a71c20abc.png" width="548"/>
    </p>
    <h4>
     3.1 init解析mount_all语句
    </h4>
    <blockquote>
     <p>
      mount_all /vendor/etc/fstab.mt6765 --early
     </p>
    </blockquote>
    <p>
     <img alt="" height="175" src="https://i-blog.csdnimg.cn/direct/13e368649a3e4b9384c77bf43723a8cc.png" width="748"/>
    </p>
    <p>
     init进程将/vendor/etc/fstab.mtxxxx文件传递到mount_all命令，在映射表就对应init进程的do_mount_all函数：
    </p>
    <p>
     <img alt="" height="955" src="https://i-blog.csdnimg.cn/direct/454c6853cc0e4c2ba2bddef80fae9cb7.png" width="769"/>
    </p>
    <h4>
     3.2 fs_mgr挂载所有分区
    </h4>
    <p>
     init进程最后在do_mount_all里面通过调用了libfs_mgr库里面的fs_mgr_mount_all函数来实现所有分区的挂载，如下逻辑：
    </p>
    <pre><code class="language-cpp">// When multiple fstab records share the same mount_point, it will try to mount each
// one in turn, and ignore any duplicates after a first successful mount.
// Returns -1 on error, and  FS_MGR_MNTALL_* otherwise.
MountAllResult fs_mgr_mount_all(Fstab* fstab, int mount_mode) {
    int encryptable = FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE;
    int error_count = 0;
    CheckpointManager checkpoint_manager;
    AvbUniquePtr avb_handle(nullptr);
    bool wiped = false;
    LINFO &lt;&lt; "---------SHEN:fs_mgr fs_mgr_mount_all A";
    bool userdata_mounted = false;
    if (fstab-&gt;empty()) {
        return {FS_MGR_MNTALL_FAIL, userdata_mounted};
    }
    //步骤一：遍历fstab所有分区，依次进行挂载
    for (int i = 0; i &lt; static_cast&lt;int&gt;(fstab-&gt;size()); i++) {
        auto&amp; current_entry = (*fstab)[i];
        LINFO &lt;&lt; "---------SHEN:fs_mgr fs_mgr_mount_all for fs_type = " &lt;&lt; current_entry.fs_type;
        LINFO &lt;&lt; "---------SHEN:fs_mgr fs_mgr_mount_all for path = " &lt;&lt; current_entry.mount_point;
        LINFO &lt;&lt; "---------SHEN:fs_mgr fs_mgr_mount_all for logical = " &lt;&lt; current_entry.fs_mgr_flags.logical;
        //步骤二：过滤那些条件下不应该被挂载
        //条件一：如果文件系统应该在第一阶段挂载，但不可格式化或挂载点已经被挂载，那么就跳过该文件系统的挂载操作。然而，如果文件系统是可格式化的，且挂载点尚未被挂载，那么允许在这个阶段挂载该文件系统。
        if (current_entry.fs_mgr_flags.first_stage_mount &amp;&amp;
            (!current_entry.fs_mgr_flags.formattable ||
             IsMountPointMounted(current_entry.mount_point))) {
            continue;
        }
        //条件二：过滤那些由 vold 管理、仅用于恢复模式、不符合当前挂载模式的文件系统条目
        if (current_entry.fs_mgr_flags.vold_managed || current_entry.fs_mgr_flags.recovery_only ||
            ((mount_mode == MOUNT_MODE_LATE) &amp;&amp; !current_entry.fs_mgr_flags.late_mount) ||
            ((mount_mode == MOUNT_MODE_EARLY) &amp;&amp; current_entry.fs_mgr_flags.late_mount)) {
            continue;
        }
        //条件三：过滤那些交换分区（swap）以及特定原始分区（如 emmc、mtd）的文件系统条目
        if (current_entry.fs_type == "swap" || current_entry.fs_type == "emmc" ||
            current_entry.fs_type == "mtd") {
            continue;
        }
        //条件四：过滤根目录/和/system目录，因为之前已经挂载过了
        // Skip mounting the root partition, as it will already have been mounted.
        if (current_entry.mount_point == "/" || current_entry.mount_point == "/system") {
            LINFO &lt;&lt; "---------SHEN:fs_mgr_mount_all for system";
            if ((current_entry.flags &amp; MS_RDONLY) != 0) {
                fs_mgr_set_blk_ro(current_entry.blk_device);
            }
            continue;
        }
        //条件五：过滤/data目录，此目录貌似需要特殊处理
        if (mount_mode == MOUNT_MODE_ONLY_USERDATA &amp;&amp; current_entry.mount_point != "/data") {
            LINFO &lt;&lt; "---------SHEN:fs_mgr_mount_all for data";
            continue;
        }
        //条件六：针对ext文件系统，尝试将文件系统标签转换成对应的块设备，如果转换失败输出日志并跳过此分区
        // Translate LABEL= file system labels into block devices.
        if (is_extfs(current_entry.fs_type)) {
            if (!TranslateExtLabels(&amp;current_entry)) {
                LERROR &lt;&lt; "Could not translate label to block device";
                continue;
            }
        }
        //条件七：针对逻辑分区的文件系统条目，尝试设置逻辑分区。如果设置逻辑分区失败输出错误日志并跳过此分区
        if (current_entry.fs_mgr_flags.logical) {
            if (!fs_mgr_update_logical_partition(&amp;current_entry)) {
                LERROR &lt;&lt; "Could not set up logical partition, skipping!";
                continue;
            }
        }
        //步骤三：针对data分区进行包装，是否需要进行一些特殊处理
        LINFO &lt;&lt; "---------SHEN:fs_mgr fs_mgr_mount_all for WrapUserdataIfNeeded";
        WrapUserdataIfNeeded(&amp;current_entry);

        if (!checkpoint_manager.Update(&amp;current_entry)) {
            continue;
        }

        if (current_entry.fs_mgr_flags.wait &amp;&amp; !WaitForFile(current_entry.blk_device, 20s)) {
            LERROR &lt;&lt; "Skipping '" &lt;&lt; current_entry.blk_device &lt;&lt; "' during mount_all";
            continue;
        }
        //步骤四：负责处理在Android系统中进行引导验证（AVB）所需的逻辑，包括打开 AvbHandle、设置 AVB hashtree，以及处理特定情况下的错误情况并跳过文件系统条目的挂载
        if (current_entry.fs_mgr_flags.avb) {
            if (!avb_handle) {
                avb_handle = AvbHandle::Open();
                if (!avb_handle) {
                    LERROR &lt;&lt; "Failed to open AvbHandle";
                    set_type_property(encryptable);
                    return {FS_MGR_MNTALL_FAIL, userdata_mounted};
                }
            }
            if (avb_handle-&gt;SetUpAvbHashtree(&amp;current_entry, true /* wait_for_verity_dev */) ==
                AvbHashtreeResult::kFail) {
                LERROR &lt;&lt; "Failed to set up AVB on partition: " &lt;&lt; current_entry.mount_point
                       &lt;&lt; ", skipping!";
                // Skips mounting the device.
                continue;
            }
        } else if (!current_entry.avb_keys.empty()) {
            if (AvbHandle::SetUpStandaloneAvbHashtree(&amp;current_entry) == AvbHashtreeResult::kFail) {
                LERROR &lt;&lt; "Failed to set up AVB on standalone partition: "
                       &lt;&lt; current_entry.mount_point &lt;&lt; ", skipping!";
                // Skips mounting the device.
                continue;
            }
        }
        int last_idx_inspected;
        int top_idx = i;
        int attempted_idx = -1;
        //步骤五：通过mount_with_alternatives函数尝试进行分区挂载
        LINFO &lt;&lt; "---------SHEN:fs_mgr fs_mgr_mount_all for mount_with_alternatives";
        bool mret = mount_with_alternatives(*fstab, i, &amp;last_idx_inspected, &amp;attempted_idx);
        auto&amp; attempted_entry = (*fstab)[attempted_idx];
        i = last_idx_inspected;
        int mount_errno = errno;
        // Handle success and deal with encryptability.
        if (mret) {
            //挂载成功的一些处理，例如handle_encryptable，并处理状态保存在status变量中
            int status = handle_encryptable(attempted_entry);
            if (status == FS_MGR_MNTALL_FAIL) {
                // Fatal error - no point continuing.
                return {status, userdata_mounted};
            }
            if (status != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) {
                if (encryptable != FS_MGR_MNTALL_DEV_NOT_ENCRYPTABLE) {
                    // Log and continue
                    LERROR &lt;&lt; "Only one encryptable/encrypted partition supported";
                }
                encryptable = status;
                if (status == FS_MGR_MNTALL_DEV_NEEDS_METADATA_ENCRYPTION) {
                    if (!call_vdc({"cryptfs", "encryptFstab", attempted_entry.blk_device,
                                   attempted_entry.mount_point, wiped ? "true" : "false",
                                   attempted_entry.fs_type, attempted_entry.zoned_device},
                                  nullptr)) {
                        LERROR &lt;&lt; "Encryption failed";
                        set_type_property(encryptable);
                        return {FS_MGR_MNTALL_FAIL, userdata_mounted};
                    }
                }
            }
            //如果当前分区是data分区，设置userdata_mounted标记
            if (current_entry.mount_point == "/data") {
                userdata_mounted = true;
            }
            // Success!  Go get the next one.
            continue;    //步骤六：当前分区挂载成功，继续挂载下一个分区
        }
        //步骤七：当前分区挂载失败，检查当前分区是否被擦除
        // Mounting failed, understand why and retry.
        wiped = partition_wiped(current_entry.blk_device.c_str());
        LINFO &lt;&lt; "---------SHEN: fs_mgr fs_mgr_mount_all for partition_wiped wiped = " &lt;&lt; wiped;
        if (mount_errno != EBUSY &amp;&amp; mount_errno != EACCES &amp;&amp;
            current_entry.fs_mgr_flags.formattable &amp;&amp; wiped) {
            //挂载失败原因不是EBUSY和EACCES且已经被擦除，输出相关日志
            // current_entry and attempted_entry point at the same partition, but sometimes
            // at two different lines in the fstab.  Use current_entry for formatting
            // as that is the preferred one.
            LERROR &lt;&lt; __FUNCTION__ &lt;&lt; "(): " &lt;&lt; realpath(current_entry.blk_device)
                   &lt;&lt; " is wiped and " &lt;&lt; current_entry.mount_point &lt;&lt; " " &lt;&lt; current_entry.fs_type
                   &lt;&lt; " is formattable. Format it.";
            //回滚当前分区让其恢复挂载之前的状态
            checkpoint_manager.Revert(&amp;current_entry);
            //如果/data分区挂载失败后尝试对该分区进行元数据加密处理以确保数据的安全性
            // EncryptInplace will be used when vdc gives an error or needs to format partitions
            // other than /data
            if (should_use_metadata_encryption(current_entry) &amp;&amp;
                current_entry.mount_point == "/data") {
                // vdc-&gt;Format requires "ro.crypto.type" to set an encryption flag
                encryptable = FS_MGR_MNTALL_DEV_IS_METADATA_ENCRYPTED;
                set_type_property(encryptable);
                if (!call_vdc({"cryptfs", "encryptFstab", current_entry.blk_device,
                               current_entry.mount_point, "true" /* shouldFormat */,
                               current_entry.fs_type, current_entry.zoned_device},
                              nullptr)) {
                    //加密处理失败打印日志Encryption failed
                    LERROR &lt;&lt; "Encryption failed";
                } else {
                    //加密处理成功设置userdata_mounted标记
                    userdata_mounted = true;
                    continue;
                }
            }
            //对挂载失败的分区进行格式化操作
            if (fs_mgr_do_format(current_entry) == 0) {
                // Let's replay the mount actions.
                i = top_idx - 1;
                continue;
            } else {
                LERROR &lt;&lt; __FUNCTION__ &lt;&lt; "(): Format failed. "
                       &lt;&lt; "Suggest recovery...";
                encryptable = FS_MGR_MNTALL_DEV_NEEDS_RECOVERY;
                continue;
            }
        }
        //步骤八：当前分支挂载失败，检查是否需要元数据加密挂载操作，并处理相关逻辑
        // mount(2) returned an error, handle the encryptable/formattable case.
        if (mount_errno != EBUSY &amp;&amp; mount_errno != EACCES &amp;&amp;
            should_use_metadata_encryption(attempted_entry)) {
            //注意：调用call_vdc去处理加密相关逻辑，后面cryptfs为参数的传递
            if (!call_vdc({"cryptfs", "mountFstab", attempted_entry.blk_device,
                           attempted_entry.mount_point, attempted_entry.zoned_device},
                          nullptr)) {
                ++error_count;
            } else if (current_entry.mount_point == "/data") {
                userdata_mounted = true;
            }
            encryptable = FS_MGR_MNTALL_DEV_IS_METADATA_ENCRYPTED;
            continue;
        } else {
            //打印相关状态
            // fs_options might be null so we cannot use PERROR &lt;&lt; directly.
            // Use StringPrintf to output "(null)" instead.
            if (attempted_entry.fs_mgr_flags.no_fail) {
                PERROR &lt;&lt; android::base::StringPrintf(
                        "Ignoring failure to mount an un-encryptable or wiped "
                        "partition on %s at %s options: %s",
                        attempted_entry.blk_device.c_str(), attempted_entry.mount_point.c_str(),
                        attempted_entry.fs_options.c_str());
            } else {
                PERROR &lt;&lt; android::base::StringPrintf(
                        "Failed to mount an un-encryptable or wiped partition "
                        "on %s at %s options: %s",
                        attempted_entry.blk_device.c_str(), attempted_entry.mount_point.c_str(),
                        attempted_entry.fs_options.c_str());
                ++error_count;
            }
            continue;
        }
    }
    //步骤九：结束循环，所有分区挂载完毕，接下来统计挂载情况，并设置data分区挂载状态
    set_type_property(encryptable);
#if ALLOW_ADBD_DISABLE_VERITY == 1  // "userdebug" build
    fs_mgr_overlayfs_mount_all(fstab);
#endif
    if (error_count) {
        return {FS_MGR_MNTALL_FAIL, userdata_mounted};
    } else {
        return {encryptable, userdata_mounted};
    }
}
</code></pre>
    <p>
     逻辑总结，根据fstab表的内容进行遍历，依次执行如下流程：
    </p>
    <ul>
     <li>
      过滤那些条件下不应该被挂载
     </li>
     <li>
      针对data分区进行包装，是否需要进行一些特殊处理：WrapUserdataIfNeeded
     </li>
     <li>
      如果设置avb标记进行avb相关逻辑处理
     </li>
     <li>
      尝试进行文件分区挂载：mount_with_alternatives
     </li>
     <li>
      挂载成功处理加密相关信息和状态处理，针对data分区还设置了设置userdata_mounted标记
     </li>
     <li>
      挂载失败依次进行：分区擦除并回滚、should_use_metadata_encryption、格式化操作
     </li>
    </ul>
    <h4>
     3.3 fs_mgr挂载单个分区
    </h4>
    <p>
     从上流程可以了解到单个分区的挂载是在mount_with_alternatives函数中
    </p>
    <p>
     <img alt="" height="973" src="https://i-blog.csdnimg.cn/direct/3d452491d020456498c67fc1a8cec53b.png" width="782"/>
    </p>
    <p>
     总结如上主要有两步流程：
    </p>
    <ul>
     <li>
      挂载前的准备：prepare_fs_for_mount
     </li>
     <li>
      系统调用进行挂载：__moun
     </li>
    </ul>
    <p>
     <img alt="" height="872" src="https://i-blog.csdnimg.cn/direct/babd3d94ef5d435fb4bb90547ef3b817.png" width="727"/>
    </p>
    <p>
     总结如上代码逻辑，主要做了如下几个步骤：
    </p>
    <ul>
     <li>
      tune_quota：Enable/disable quota support on the filesystem if needed
     </li>
     <li>
      resize_fs：重置文件系统
     </li>
     <li>
      check_fs：校验文件系统
     </li>
     <li>
      tune_reserved_size：ext4支持
     </li>
     <li>
      tune_encrypt：ext4支持
     </li>
     <li>
      tune_verity：ext4支持
     </li>
     <li>
      tune_casefold：ext4支持
     </li>
     <li>
      tune_metadata_csum：ext4支持
     </li>
    </ul>
    <h4 style="background-color:transparent">
     3.4 分区挂载日志
    </h4>
    <pre><code class="language-bash">&lt;14&gt;[   11.515218] .(5)[1:init]init 33: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all A
&lt;14&gt;[   11.516457] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.517766] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /system
&lt;14&gt;[   11.519041] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   11.520281] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.521550] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /system_ext
&lt;14&gt;[   11.522861] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   11.524077] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.525326] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vendor
&lt;14&gt;[   11.526673] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   11.527949] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.529239] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /product
&lt;14&gt;[   11.530528] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   11.531760] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.533077] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /metadata
&lt;14&gt;[   11.534389] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.536745] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = f2fs
&lt;14&gt;[   11.538089] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /data
&lt;14&gt;[   11.539374] .(5)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.541676] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.542940] .(5)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/protect_f
&lt;14&gt;[   11.544436] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.545676] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for WrapUserdataIfNeeded
&lt;14&gt;[   11.547055] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives
&lt;14&gt;[   11.623443] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives mret = 1
&lt;14&gt;[   11.624868] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.626170] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/protect_s
&lt;14&gt;[   11.627563] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.628780] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for WrapUserdataIfNeeded
&lt;14&gt;[   11.630131] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives
&lt;14&gt;[   11.693155] .(7)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives mret = 1
&lt;14&gt;[   11.694582] .(7)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.696030] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/nvdata
&lt;14&gt;[   11.697997] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.700405] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for WrapUserdataIfNeeded
&lt;14&gt;[   11.702587] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives
&lt;14&gt;[   11.773010] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives mret = 1
&lt;14&gt;[   11.774436] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.775706] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/nvcfg
&lt;14&gt;[   11.777046] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.778245] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for WrapUserdataIfNeeded
&lt;14&gt;[   11.779582] .(4)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives
&lt;14&gt;[   11.835132] .(7)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives mret = 1
&lt;14&gt;[   11.836687] .(7)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   11.837919] .(7)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/persist
&lt;14&gt;[   11.839307] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.840518] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for WrapUserdataIfNeeded
&lt;14&gt;[   11.841861] .(7)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives
&lt;14&gt;[   11.897315] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives mret = 1
&lt;14&gt;[   11.898752] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = auto
&lt;14&gt;[   11.899991] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = auto
&lt;14&gt;[   11.901200] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.902406] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = vfat
&lt;14&gt;[   11.903644] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = auto
&lt;14&gt;[   11.904852] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.906104] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.908371] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /persistent
&lt;14&gt;[   11.910676] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.912738] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.914768] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /nvram
&lt;14&gt;[   11.916830] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.918470] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.922484] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /proinfo
&lt;14&gt;[   11.924922] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.926869] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.928552] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /bootloader
&lt;14&gt;[   11.931108] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.933713] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.937656] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /bootloader2
&lt;14&gt;[   11.941517] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.942729] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.943967] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /misc
&lt;14&gt;[   11.945187] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.946446] .(6)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.948461] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /boot
&lt;14&gt;[   11.951288] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.953273] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.955305] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vbmeta_vendor
&lt;14&gt;[   11.957444] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.959329] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.961991] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vbmeta_system
&lt;14&gt;[   11.963430] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.964690] .(6)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.966531] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /logo
&lt;14&gt;[   11.968387] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.969737] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.971823] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /expdb
&lt;14&gt;[   11.973192] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.982458] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.984425] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /seccfg
&lt;14&gt;[   11.986724] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.989795] .(1)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.991434] .(1)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /tee1
&lt;14&gt;[   11.992957] .(1)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   11.994911] .(1)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   11.996592] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /tee2
&lt;14&gt;[   11.998148] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.000267] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.001958] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /scp1
&lt;14&gt;[   12.003772] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.005304] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.007251] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /scp2
&lt;14&gt;[   12.008835] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.010783] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.012133] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /sspm_1
&lt;14&gt;[   12.013507] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.015231] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.016797] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /sspm_2
&lt;14&gt;[   12.018340] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.019957] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.021931] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md1img
&lt;14&gt;[   12.024265] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.025921] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.028173] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md1dsp
&lt;14&gt;[   12.029981] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.032213] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.034292] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md1arm7
&lt;14&gt;[   12.036184] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.037924] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.040041] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md3img
&lt;14&gt;[   12.042368] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.044674] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.048219] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /gz1
&lt;14&gt;[   12.051118] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.055860] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.058138] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /gz2
&lt;14&gt;[   12.060322] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.060337] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.060378] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /spmfw
&lt;14&gt;[   12.060393] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.060407] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.060421] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /boot_para
&lt;14&gt;[   12.060435] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.060448] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.060460] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /odmdtbo
&lt;14&gt;[   12.060474] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.060487] .(2)[1:init]init 6: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.060510] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /dtbo
&lt;14&gt;[   12.060525] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.060538] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   12.060550] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vbmeta
&lt;14&gt;[   12.060564] .(2)[1:init]init 25: [11506][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.553435] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all A
&lt;14&gt;[   12.554922] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   12.557855] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /system
&lt;14&gt;[   12.559154] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   12.560377] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   12.561625] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /system_ext
&lt;14&gt;[   12.562931] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   12.564192] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   12.565454] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vendor
&lt;14&gt;[   12.566956] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   12.568203] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   12.569500] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /product
&lt;14&gt;[   12.570827] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 1
&lt;14&gt;[   12.572061] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   12.573302] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /metadata
&lt;14&gt;[   12.574566] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.576993] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = f2fs
&lt;14&gt;[   12.578236] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /data
&lt;14&gt;[   12.579488] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   12.580712] .(7)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for WrapUserdataIfNeeded
&lt;14&gt;[   12.626130] .(7)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives
&lt;14&gt;[   12.641696] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for mount_with_alternatives mret = 0
&lt;14&gt;[   12.643123] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for partition_wiped str = /dev/block/by-name/userdata
&lt;14&gt;[   12.645275] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for partition_wiped wiped = 0
&lt;14&gt;[   13.026412] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   13.027664] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/protect_f
&lt;14&gt;[   13.029079] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.030315] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   13.031604] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/protect_s
&lt;14&gt;[   13.032999] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.034207] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   13.035447] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/nvdata
&lt;14&gt;[   13.036874] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.038082] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   13.039323] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/nvcfg
&lt;14&gt;[   13.040672] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.041879] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = ext4
&lt;14&gt;[   13.043139] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /mnt/vendor/persist
&lt;14&gt;[   13.044501] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.045759] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = auto
&lt;14&gt;[   13.047009] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = auto
&lt;14&gt;[   13.048210] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.049406] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = vfat
&lt;14&gt;[   13.050635] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = auto
&lt;14&gt;[   13.051833] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.053029] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.054288] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /persistent
&lt;14&gt;[   13.055675] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.056884] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.058124] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /nvram
&lt;14&gt;[   13.059354] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.060561] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.061812] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /proinfo
&lt;14&gt;[   13.063091] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.064299] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.065632] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /bootloader
&lt;14&gt;[   13.066909] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.068106] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.069336] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /bootloader2
&lt;14&gt;[   13.070620] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.071816] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.073044] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /misc
&lt;14&gt;[   13.074252] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.075448] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.076740] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /boot
&lt;14&gt;[   13.077971] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.079203] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.080445] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vbmeta_vendor
&lt;14&gt;[   13.081762] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.082969] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.084210] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vbmeta_system
&lt;14&gt;[   13.085556] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.086765] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.088023] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /logo
&lt;14&gt;[   13.089232] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.090428] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.091656] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /expdb
&lt;14&gt;[   13.092876] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.094079] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.095334] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /seccfg
&lt;14&gt;[   13.096620] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.097818] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.099065] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /tee1
&lt;14&gt;[   13.100285] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.101492] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.102731] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /tee2
&lt;14&gt;[   13.103950] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.105156] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.106432] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /scp1
&lt;14&gt;[   13.107653] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.108859] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.110113] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /scp2
&lt;14&gt;[   13.111331] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.112555] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.113783] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /sspm_1
&lt;14&gt;[   13.115014] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.116293] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.117523] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /sspm_2
&lt;14&gt;[   13.118754] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.119950] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.121196] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md1img
&lt;14&gt;[   13.122438] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.123645] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.124884] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md1dsp
&lt;14&gt;[   13.126154] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.127370] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.128637] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md1arm7
&lt;14&gt;[   13.129891] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.131098] .(5)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.132354] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /md3img
&lt;14&gt;[   13.133585] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.134781] .(5)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.136329] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /gz1
&lt;14&gt;[   13.137540] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.138732] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.139955] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /gz2
&lt;14&gt;[   13.141147] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.142337] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.143662] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /spmfw
&lt;14&gt;[   13.144916] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.146183] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.147420] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /boot_para
&lt;14&gt;[   13.148687] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.149888] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.151122] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /odmdtbo
&lt;14&gt;[   13.152368] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.153570] .(1)[1:init]init 25: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.154815] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /dtbo
&lt;14&gt;[   13.156039] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0
&lt;14&gt;[   13.157231] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for fs_type = emmc
&lt;14&gt;[   13.158454] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for path = /vbmeta
&lt;14&gt;[   13.159678] .(1)[1:init]init 6: [12545][0][libfs_mgr] ---------SHEN:fs_mgr_mount_all for logical = 0</code></pre>
    <p>
     此过程中实际挂载的分区并不多：
    </p>
    <blockquote>
     <p>
      &lt;14&gt;[   11.672359] .(0)[1:init]init 6: [11637][0][libfs_mgr] ---------SHEN:fs_mgr fs_mgr_mount_all for path = /mnt/vendor/protect_f
     </p>
     <p>
      &lt;14&gt;[   11.758712] .(5)[1:init]init 26: [11637][0][libfs_mgr] ---------SHEN:fs_mgr fs_mgr_mount_all for path = /mnt/vendor/protect_s
     </p>
     <p>
      &lt;14&gt;[   11.832189] .(5)[1:init]init 6: [11637][0][libfs_mgr] ---------SHEN:fs_mgr fs_mgr_mount_all for path = /mnt/vendor/nvdata
     </p>
     <p>
      &lt;14&gt;[   11.912498] .(4)[1:init]init 6: [11637][0][libfs_mgr] ---------SHEN:fs_mgr fs_mgr_mount_all for path = /mnt/vendor/nvcfg
     </p>
     <p>
      &lt;14&gt;[   11.981377] .(7)[1:init]init 6: [11637][0][libfs_mgr] ---------SHEN:fs_mgr fs_mgr_mount_all for path = /mnt/vendor/persist
     </p>
    </blockquote>
    <p>
     <img alt="" height="771" src="https://i-blog.csdnimg.cn/direct/dfd0c28c396341d59a75d4e438889490.png" width="1684"/>
    </p>
    <p>
    </p>
    <h3>
     4、/data分区加解密
    </h3>
    <p>
     <img alt="" height="873" src="https://i-blog.csdnimg.cn/direct/471882e5567948b4b4ba972ae182950f.png" width="1576"/>
    </p>
    <p>
     从上面的日志来看，/data目录的挂载并没有在libfs_mgr里面完成，看起来后面移交给了vold进程
    </p>
    <p>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32373637323130312f:61727469636c652f64657461696c732f313436313034393739" class_="artid" style="display:none">
 </p>
</div>


