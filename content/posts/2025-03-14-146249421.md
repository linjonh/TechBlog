---
layout: post
title: "SpringBoot-集成logback日志链路追踪"
date: 2025-03-14 09:38:21 +0800
description: "用途：每一次链路，线程维度，添加最终的链路 ID traceId.MDC(Mapped Diagnostic Context) 诊断上下文映射，是@Slf4j提供的一个支持动态打印日志信息的工具。/*** 日志拦截器*/@Override//可以考虑让客户端传入链路ID，但需保证一定的复杂度唯一性；如果没使用默认UUID自动生成if (!returntrue;@Override// 请求处理完成后,清除MDC中的traceId,以免造成内存泄漏/**"
keywords: "SpringBoot 集成logback日志链路追踪"
categories: ['未分类']
tags: ['后端', 'Spring', 'Spring', 'Java', 'Boot']
artid: "146249421"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146249421
    alt: "SpringBoot-集成logback日志链路追踪"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146249421
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146249421
cover: https://bing.ee123.net/img/rand?artid=146249421
image: https://bing.ee123.net/img/rand?artid=146249421
img: https://bing.ee123.net/img/rand?artid=146249421
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringBoot 集成logback日志链路追踪
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     项目场景
    </h3>
    <p>
     有时候一个业务调用链场景，很长，调了各种各样的方法，看日志的时候，各个接口的日志穿插，确实让人头大。
    </p>
    <p>
     为了解决这个痛点，就使用了 TraceId，根据 TraceId 关键字进入服务器查询日志中是否有这个 TraceId, 这样就把同一次的业务调用链上的日志串起来了。
    </p>
    <p>
    </p>
    <h3>
     实现步骤
    </h3>
    <h4>
     1、pom.xml 依赖
    </h4>
    <pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--lombok配置--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.16.10&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
    <h4>
     2、整合 logback，打印日志，logback-spring.xml (简单配置下)
    </h4>
    <p>
     关键代码：
     <code>
      [traceId:%X{traceId}]
     </code>
     , traceId 是通过拦截器里
     <code>
      MDC.put(traceId, tid)
     </code>
     添加
    </p>
    <pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration debug="false"&gt;
    &lt;!--日志存储路径--&gt;
    &lt;property name="log" value="D:/test/log" /&gt;
    &lt;!-- 控制台输出 --&gt;
    &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt;
            &lt;!--输出格式化--&gt;
            &lt;pattern&gt;[traceId:%X{traceId}]  %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;!-- 按天生成日志文件 --&gt;
    &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
        &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
            &lt;!--日志文件名--&gt;
            &lt;FileNamePattern&gt;${log}/%d{yyyy-MM-dd}.log&lt;/FileNamePattern&gt;
            &lt;!--保留天数--&gt;
            &lt;MaxHistory&gt;30&lt;/MaxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt;
            &lt;pattern&gt;[traceId:%X{traceId}]  %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
        &lt;!--日志文件最大的大小--&gt;
        &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;
            &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;
        &lt;/triggeringPolicy&gt;
    &lt;/appender&gt;

    &lt;!-- 日志输出级别 --&gt;
    &lt;root level="INFO"&gt;
        &lt;appender-ref ref="console" /&gt;
        &lt;appender-ref ref="file" /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
    <h4>
     3、application.yml
    </h4>
    <pre><code class="language-XML">server:
  port: 8826
logging:
  config: classpath:logback-spring.xml
</code></pre>
    <h4>
     4、自定义日志拦截器 LogInterceptor.java
    </h4>
    <p>
     用途：每一次链路，线程维度，添加最终的链路 ID traceId.
    </p>
    <p>
     MDC(Mapped Diagnostic Context) 诊断上下文映射，是
     <code>
      @Slf4j
     </code>
     提供的一个支持动态打印日志信息的工具。
    </p>
    <pre><code class="language-java">import org.slf4j.MDC;
import org.springframework.lang.Nullable;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

/**
 * 日志拦截器
 */
publicclass LogInterceptor implements HandlerInterceptor {

    privatestaticfinal String traceId = "traceId";

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String tid = UUID.randomUUID().toString().replace("-", "");
        //可以考虑让客户端传入链路ID，但需保证一定的复杂度唯一性；如果没使用默认UUID自动生成
        if (!StringUtils.isEmpty(request.getHeader("traceId"))){
            tid=request.getHeader("traceId");
        }
        MDC.put(traceId, tid);
        returntrue;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
                                @Nullable Exception ex) {
        // 请求处理完成后,清除MDC中的traceId,以免造成内存泄漏
        MDC.remove(traceId);
    }

}
</code></pre>
    <h4>
     5、WebConfigurerAdapter.java 添加拦截器
    </h4>
    <blockquote>
     <span style="color:#4f4f4f">
      其实这个拦截的部分改为使用自定义注解 + AOP 也是很灵活的。
     </span>
    </blockquote>
    <pre><code class="language-java">import javax.annotation.Resource;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;


@Configuration
publicclass WebConfigurerAdapter extends WebMvcConfigurationSupport {
    @Resource
private LogInterceptor logInterceptor;

@Override
public void addInterceptors(InterceptorRegistry registry) {
  registry.addInterceptor(logInterceptor);
//可以具体制定哪些需要拦截，哪些不拦截，其实也可以使用自定义注解更灵活完成
//                .addPathPatterns("/**")
//                .excludePathPatterns("/testxx.html");
 }
}
</code></pre>
    <h4>
     6、测试接口
    </h4>
    <pre><code class="language-java">import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
@Api(tags = "测试接口")
@RequestMapping("/test")
@Slf4j
publicclass TestController {


@RequestMapping(value = "/log", method = RequestMethod.GET)
@ApiOperation(value = "测试日志")
public String sign() {
  log.info("这是一行info日志");
  log.error("这是一行error日志");
return"success";
 }
}
</code></pre>
    <p>
    </p>
    <h3>
     异步场景
    </h3>
    <p>
     使用线程的场景，写一个异步线程，加入这个调用里面。再次执行看开效果，我们会发现显然子线程丢失了 traceId。
    </p>
    <p>
     所以我们需要针对子线程使用情形，做调整，思路：将父线程的 traceId 传递下去给子线程即可。
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="148" src="https://i-blog.csdnimg.cn/direct/bad50e07d03848eaa1eeb29dcbf79d4b.png" width="1027"/>
    </p>
    <h4>
     1、ThreadMdcUtil.java
    </h4>
    <pre><code class="language-java">import org.slf4j.MDC;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.Callable;

/**
 * @Author: JCccc
 * @Date: 2022-5-30 11:14
 * @Description:
 */
publicfinalclass ThreadMdcUtil {
    privatestaticfinal String traceId = "traceId";

    // 获取唯一性标识
    public static String generateTraceId() {
        return UUID.randomUUID().toString().replace("-", "");
    }

    public static void setTraceIdIfAbsent() {
        if (MDC.get(traceId) == null) {
            MDC.put(traceId, generateTraceId());
        }
    }

    /**
     * 用于父线程向线程池中提交任务时，将自身MDC中的数据复制给子线程
     *
     * @param callable
     * @param context
     * @param &lt;T&gt;
     * @return
     */
    publicstatic &lt;T&gt; Callable&lt;T&gt; wrap(final Callable&lt;T&gt; callable, final Map&lt;String, String&gt; context) {
        return () -&gt; {
            if (context == null) {
                MDC.clear();
            } else {
                MDC.setContextMap(context);
            }
            setTraceIdIfAbsent();
            try {
                return callable.call();
            } finally {
                MDC.clear();
            }
        };
    }

    /**
     * 用于父线程向线程池中提交任务时，将自身MDC中的数据复制给子线程
     *
     * @param runnable
     * @param context
     * @return
     */
    public static Runnable wrap(final Runnable runnable, final Map&lt;String, String&gt; context) {
        return () -&gt; {
            if (context == null) {
                MDC.clear();
            } else {
                MDC.setContextMap(context);
            }
            setTraceIdIfAbsent();
            try {
                runnable.run();
            } finally {
                MDC.clear();
            }
        };
    }
}
</code></pre>
    <h4>
     2、MyThreadPoolTaskExecutor.java 是我们自己写的，重写了一些方法
    </h4>
    <pre><code class="language-java">import org.slf4j.MDC;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Callable;
import java.util.concurrent.Future;

publicfinalclass MyThreadPoolTaskExecutor  extends ThreadPoolTaskExecutor  {
    public MyThreadPoolTaskExecutor() {
        super();
    }
    
    @Override
    public void execute(Runnable task) {
        super.execute(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));
    }


    @Override
    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        returnsuper.submit(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));
    }

    @Override
    public Future&lt;?&gt; submit(Runnable task) {
        returnsuper.submit(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));
    }
}
</code></pre>
    <h4>
     3、ThreadPoolConfig.java 定义线程池，交给 Spring 管理
    </h4>
    <pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

import java.util.concurrent.Executor;

@EnableAsync
@Configuration
publicclass ThreadPoolConfig {
    /**
     * 声明一个线程池
     */
    @Bean("taskExecutor")
    public Executor taskExecutor() {
        MyThreadPoolTaskExecutor executor = new MyThreadPoolTaskExecutor();
        //核心线程数5：线程池创建时候初始化的线程数
        executor.setCorePoolSize(5);
        //最大线程数5：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程
        executor.setMaxPoolSize(5);
        //缓冲队列500：用来缓冲执行任务的队列
        executor.setQueueCapacity(500);
        //允许线程的空闲时间60秒：当超过了核心线程出之外的线程在空闲时间到达之后会被销毁
        executor.setKeepAliveSeconds(60);
        //线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池
        executor.setThreadNamePrefix("taskExecutor-");
        executor.initialize();
        return executor;
    }
}
</code></pre>
    <h4>
     4、Service
    </h4>
    <pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

/**
 * 测试Service
 */
@Service("testService")
@Slf4j
publicclass TestService {

/**
  * 异步操作测试
  */
@Async("taskExecutor")
public void asyncTest() {
try {
   log.info("模拟异步开始......");
   Thread.sleep(3000);
   log.info("模拟异步结束......");
  } catch (InterruptedException e) {
   log.error("异步操作出错:"+e);
  }

 }

}
</code></pre>
    <h4>
     5、测试接口
    </h4>
    <pre><code class="language-java">import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
@Api(tags = "测试接口")
@RequestMapping("/test")
@Slf4j
publicclass TestController {

@Resource
private TestService testService;

@RequestMapping(value = "/log", method = RequestMethod.GET)
@ApiOperation(value = "测试日志")
public String sign() {
  log.info("这是一行info日志");
  log.error("这是一行error日志");

//异步操作测试
  testService.asyncTest();
return"success";
 }
}
</code></pre>
    <p>
     结果：
    </p>
    <p>
     <img alt="" height="126" src="https://i-blog.csdnimg.cn/direct/9e90e3514d224e92b6dac60f56a9a881.png" width="1021"/>
    </p>
    <p>
     我们可以看到，子线程的日志也被串起来了。
    </p>
    <h3>
     定时任务
    </h3>
    <p>
     如果使用了定时任务
     <code>
      @Scheduled
     </code>
     , 这时候执行定时任务，不会走上面的拦截器逻辑，所以定时任务需要单独创建个 AOP 切面。
    </p>
    <h4>
     1、创建个定时任务线程池
    </h4>
    <pre><code class="language-java">import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;

import java.util.concurrent.Executors;

/**
 * 定时任务线程池
 */
@EnableScheduling
@Configuration
publicclass SeheduleConfig implements SchedulingConfigurer{
@Override
public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
  taskRegistrar.setScheduler(Executors.newScheduledThreadPool(5));
 }
}
</code></pre>
    <h4>
     2、创建 AOP 切面
    </h4>
    <pre><code class="language-java">import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.MDC;
import org.springframework.context.annotation.Configuration;

import java.util.UUID;

@Aspect   //定义一个切面
@Configuration
publicclass SeheduleTaskAspect {

    // 定义定时任务切点Pointcut
    @Pointcut("@annotation(org.springframework.scheduling.annotation.Scheduled)")
    public void seheduleTask() {
    }

    @Around("seheduleTask()")
    public void doAround(ProceedingJoinPoint joinPoint) throws Throwable {
try {
   String traceId = UUID.randomUUID().toString().replace("-", "");
   //用于日志链路追踪，logback配置:%X{traceId}
   MDC.put("traceId", traceId);
   //执行定时任务方法
         joinPoint.proceed();
  } finally {
   //请求处理完成后，清除MDC中的traceId，以免造成内存泄漏
   MDC.remove("traceId");
  }
    }

}
</code></pre>
    <h4>
     3、创建定时任务测试
    </h4>
    <pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.Date;

@Service
publicclass SeheduleTasks {

private Logger logger = LoggerFactory.getLogger(SeheduleTasks.class);

/**
  * 1分钟执行一次
  */
@Scheduled(cron = "0 0/1 * * * ?")
public void testTask() {
  logger.info("执行定时任务&gt;"+new Date());
 }

}
</code></pre>
    <h3>
     总结
    </h3>
    <p>
     服务启动的时候 traceId 是空的，这是正常的，因为还没到拦截器这一层。
    </p>
    <h4>
     API 说明
    </h4>
    <ul>
     <li>
      <p>
       <code>
        clear()
       </code>
       =&gt; 移除所有 MDC
      </p>
     </li>
     <li>
      <p>
       <code>
        get (String key)
       </code>
       =&gt; 获取当前线程 MDC 中指定 key 的值
      </p>
     </li>
     <li>
      <p>
       <code>
        getContext()
       </code>
       =&gt; 获取当前线程 MDC 的 MDC
      </p>
     </li>
     <li>
      <p>
       <code>
        put(String key, Object o)
       </code>
       =&gt; 往当前线程的 MDC 中存入指定的键值对
      </p>
     </li>
     <li>
      <p>
       <code>
        remove(String key)
       </code>
       =&gt; 删除当前线程 MDC 中指定的键值对
      </p>
     </li>
    </ul>
    <h3>
    </h3>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f5758465f5369722f:61727469636c652f64657461696c732f313436323439343231" class_="artid" style="display:none">
 </p>
</div>


