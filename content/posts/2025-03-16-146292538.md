---
layout: post
title: "Unity网络同步框架-Nakama研究四"
date: 2025-03-16 12:11:02 +08:00
description: "关于Nakama服务器代码扩展和其他"
keywords: "【Unity网络同步框架 - Nakama研究(四)】"
categories: ['Unity']
tags: ['网络', '游戏', 'Unity']
artid: "146292538"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146292538
    alt: "Unity网络同步框架-Nakama研究四"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146292538
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146292538
cover: https://bing.ee123.net/img/rand?artid=146292538
image: https://bing.ee123.net/img/rand?artid=146292538
img: https://bing.ee123.net/img/rand?artid=146292538
---

# 【Unity网络同步框架 - Nakama研究(四)】
【Unity网络同步框架 - Nakama研究(四)】
>
> 关于`Nakama`的源码问题，`Nakama`的源码官方是不建议修改的，不建议重构以添加新的功能，推荐使用嵌入式运行库，也就是使用`lua`,`go`和`typescript`进行扩展。
### 分析
1. 扩展使用的语言中`Go`作为源码语言，能进行断点调试，而且性能高效，适合原生的服务端用户书写。相对应的，`ts`和`lua`就更加适合比如`cocos creator`或者使用`lua`进行`Unity`开发的人员书写，各有对应，遗憾的是目前官方对这两种语言都不支持断点调试，![反馈](https://i-blog.csdnimg.cn/direct/722c6c7e02ad416c81a4b35764e021cc.jpeg#pic\_center)
2. 官方的案例中使用了`ts`进行扩展（在`PiratePanic`中能看到），在此之前，我们需要做一些工作，就是让`Nakama`能够识别你的扩展目录，在服务器的`Docker`配置中，![扩展](https://i-blog.csdnimg.cn/direct/15ce828b8e6e45d4805721415eceecb4.png#pic\_center)这一行就是你指定你的扩展的文件所存放的位置，比如我放两个`lua`文件`ltest.lua`和`main.lua`进去，`Nakama`会自动读取对应位置的文件信息，然后打印出来![载入lua](https://i-blog.csdnimg.cn/direct/e97b98ce5c6043e185f74c5c69c8946c.png#pic\_center)，载入的顺序是按照你的文件名来排序的，日志里面也显示了你在里面注册了哪些`rpc`方法，你也能在客户端直接调用。
### 创建权威比赛
\* 权威比赛的一个关键点就是房间内没人也依旧会存在，而且可以自定义房间内的比赛逻辑，包括如何开始如何结束等等。逻辑也很简单，就是那几个关键的函数方法：`match\_join`,`match\_leave`,`match\_loop`(主要是这三个)，下面是我写着测试的代码：`main.lua`和`ltest.lua`
local nk = require("nakama")
nk.logger\_info("Lua模块进入------")
-- 创建比赛
local state = {
label = "比赛一"
}
local match\_id = nk.match\_create("ltest", state)
local state\_2 = {
label = "比赛二"
}
local match\_id\_2 = nk.match\_create("ltest", state\_2)
local state\_3 = {
label = "比赛三"
}
local match\_id\_3 = nk.match\_create("ltest", state\_3)
------------------------------------
function healthcheck\_rpc(content, payload)
nk.logger\_info("Healthcheck RPC called")
return nk.json\_encode({["success"] = true})
end
function getmatchlist\_rpc(content, payload)
-- 列出当前所有比赛
local limit = 10
local authoritative = false
local label = nil
local min\_size = 1
local max\_size = 10
local matches = nk.match\_list(limit, authoritative, label, min\_size, max\_size)
-- 构建返回的 JSON 结构
local matchList = {}
for \_, m in ipairs(matches) do
table.insert(matchList, {
match\_id = m.match\_id,
size = m.size,
max\_size = m.max\_size,
authoritative = m.is\_authoritative
})
end
-- 返回 JSON 结构
return nk.json\_encode({ matches = matchList })
end
nk.register\_rpc(healthcheck\_rpc, "healthcheck\_lua")
nk.register\_rpc(getmatchlist\_rpc, "getmatchlist\_lua")
local M = {}
local nk = require("nakama")
function M.match\_init(context, setupstate)
local gamestate = {
presences = {},
name = "",
min\_size = 1,
max\_size = 10,
is\_authoritative = false,
label = setupstate.label
}
-- 设置 tick 率
local tickrate = 30
-- 设置比赛标签
local label = gamestate.label or ""
nk.logger\_warn("match\_init")
return gamestate, tickrate, label
end
function M.match\_join\_attempt(context, dispatcher, tick, state, presence, metadata)
local acceptuser = true
nk.logger\_warn("match\_join\_attempt")
return state, acceptuser
end
function M.match\_join(context, dispatcher, tick, state, presences)
nk.logger\_warn("match\_join")
-- 先添加新玩家到状态
for \_, presence in ipairs(presences) do
state.presences[presence.session\_id] = presence
end
-- 发送玩家加入通知
for \_, presence in ipairs(presences) do
-- 构造加入消息
local join\_message = {
op = 10, -- 新操作码表示玩家加入
type = "PLAYER\_JOINED",
timestamp = os.time(),
data = {
user = {
id = presence.user\_id,
name = presence.username
},
session = presence.session\_id
}
}
-- 构建收件人列表（排除自己）
local recipients = {}
for \_, p in pairs(state.presences) do
if p.session\_id ~= presence.session\_id then
table.insert(recipients, p)
end
end
-- 发送加入广播
if #recipients > 0 then
dispatcher.broadcast\_message(10, nk.json\_encode(join\_message), recipients)
nk.logger\_info(string.format("Player %s(%s) joined the match",
presence.user\_id, presence.username))
end
-- 给新玩家发送现有玩家列表
local existing\_players = {}
for \_, p in pairs(state.presences) do
if p.session\_id ~= presence.session\_id then
table.insert(existing\_players, {
user\_id = p.user\_id,
username = p.username,
session\_id = p.session\_id
})
end
end
if #existing\_players > 0 then
local existing\_msg = {
op = 11,
type = "EXISTING\_PLAYERS",
data = existing\_players
}
dispatcher.broadcast\_message(11, nk.json\_encode(existing\_msg), { presence })
end
end
-- 原有存储数据逻辑（保持兼容）
for \_, presence in pairs(state.presences) do
local storageObjectId = {
{ collection = "test", key = "key1", user\_id = presence.user\_id }
}
local storageObject = nk.storage\_read(storageObjectId)
if storageObject then
local message = {
op = 99,
data = storageObject
}
-- 使用新通知系统
dispatcher.broadcast\_message(99, nk.json\_encode(message))
else
nk.logger\_warn("storageObject为空,查询的user id为" .. presence.user\_id)
end
end
return state
end
-- presences表示离开的人数
function M.match\_leave(context, dispatcher, tick, state, presences)
-- 遍历所有离开的玩家
for \_, presence in ipairs(presences) do
-- 构造离开消息
local leave\_message = {
UserId = presence.user\_id,
UserName = presence.username,
SessionId = presence.session\_id,
Reason = "player\_left"
}
-- 构建收件人列表（排除离开的玩家）
local recipients = {}
for \_, p in pairs(state.presences) do
if p.session\_id ~= presence.session\_id then
table.insert(recipients, p)
end
end
-- 发送离开通知（使用op\_code 6表示玩家离开）
if #recipients > 0 then
dispatcher.broadcast\_message(6, nk.json\_encode(leave\_message), recipients)
nk.logger\_info(string.format("Player %s(%s) left the match",
presence.user\_id, presence.username))
end
-- 从状态中移除玩家
state.presences[presence.session\_id] = nil
end
return state
end
-- 处理比赛人员交互操作
function M.match\_loop(context, dispatcher, tick, state, messages)
if(messages ~= nil) then
for \_, m in ipairs(messages) do
local recipients = {}
for \_, p in pairs(state.presences) do
if p.user\_id ~= m.sender.user\_id then
table.insert(recipients, p)
end
end
if #recipients > 0 then
if(m ~= nil and m.op\_code ~= nil) then
dispatcher.broadcast\_message(m.op\_code, m.data, recipients)
end
end
end
end
return state
end
-- 用于在服务器关闭时，优雅地处理比赛状态，确保比赛能够正确结束并通知客户端
function M.match\_terminate(context, dispatcher, tick, state, grace\_seconds)
local message = "Server shutting down in " .. grace\_seconds .. " seconds"
dispatcher.broadcast\_message(2, message)
return nil
end
-- 用于在用户正式加入比赛之前，提前预留位置或进行一些预处理
function M.match\_signal(context, dispatcher, tick, state, data)
return state, "signal received: " .. data
end
return M
对了，还有一点麻烦的是，`vscode`里面没有代码提示，可以搞个前人写好的库，我找了下，在`github`上能找到[地址](https://github.com/KittySkin/Nakama-
Intellisense-Module-for-Lua)，能补充一下缺失的提示框（但是错误提示依旧没有）
### 控制台使用
\* 控制台如果你想要其他的图形化的比如`Grafana `啥的，也能自己搭建，不过目前我看这个控制大多数都能满足，包括查看用户，查看聊天信息，查看比赛（房间）信息，然后主动调用接口，还是挺方便的，这个没什么好讲的![控制台](https://i-blog.csdnimg.cn/direct/0fe2b1a25ab84b92a33a95c479ff7c4c.png#pic\_center)
>
> 结语，`Nakama`相关的一些使用就到这，再深的讲就是一些服务器的布置，负载均衡，集群啥的了（集群需要`Nakama`的企业版），`Nakama`本身自带的一些功能比如排行榜，好友群组，连接`facebook`,`x`啥的我都没试。再深入研究要等下次有机会了