---
layout: post
title: "spring-boot3-kafka集群搭建到使用"
date: 2025-03-14 15:46:52 +0800
description: "spring boot3 kafka集群搭建到使用"
keywords: "spring boot3 kafka集群搭建到使用"
categories: ['Spring', 'Boot']
tags: ['后端', 'Spring', 'Kafka', 'Boot']
artid: "146257293"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146257293
    alt: "spring-boot3-kafka集群搭建到使用"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146257293
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146257293
cover: https://bing.ee123.net/img/rand?artid=146257293
image: https://bing.ee123.net/img/rand?artid=146257293
img: https://bing.ee123.net/img/rand?artid=146257293
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     spring boot3 kafka集群搭建到使用
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     首先自行安装docker，通过docker容器安装kafka
     <br/>
     CentOS 系统
     <a class="link-info" href="https://blog.csdn.net/weixin_43453621/article/details/146254452" title="docker安装地址">
      docker安装地址
     </a>
    </p>
    <h4>
     1.pom.xml和application.properties或者application.yml文件配置
    </h4>
    <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
    <pre><code class="language-java">spring:
  kafka:
    bootstrap-servers: [fafka地址1,fafka地址2,....]
#    producer序列化设置
    producer:
      #key序列化设置，设置成json对象
#      key-serializer: org.springframework.kafka.support.serializer.JsonSerializer
#    val序列化设置，设置成json对象
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
</code></pre>
    <hr/>
    <h4>
     2.博主安装了kafka ui插件，就直接创建主题了
    </h4>
    <p>
     当前一个集群，因为博主只搭建了一台服务器，也可以称为一个节点
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/27e02c7bc1e744fc9106c584282d62d7.png"/>
    </p>
    <p>
     创建主题
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/bd20f06bc85e41f1b53b4ee4076f1f80.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/direct/43f08260b73f42749b1bf333aaab6240.png"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       没有安装
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       kafka ui
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       ，就再main那里启动项目时创建
      </strong>
     </span>
    </p>
    <pre><code class="language-javascript">package com.atguigu.boot3_08_kafka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.TopicBuilder;

@EnableKafka //扫描kafka注解,开启基于注解的模式
@SpringBootApplication
public class Boot308KafkaApplication {

    public static void main(String[] args) {
        SpringApplication.run(Boot308KafkaApplication.class, args);
        TopicBuilder.name("my-new-topic")//主题
                .partitions(3)//分区
                .replicas(2)//副本
                .build();
    }

}
</code></pre>
    <p>
     副本就是备份，有几节点就可以创建几个副本，副本数量一般采取
     <strong>
      <span style="color:#fe2c24">
       分区数量-1，只有一个节点就N分区1副本
      </span>
     </strong>
    </p>
    <hr/>
    <h4>
     3.在main 加上这个注解@EnableKafka
    </h4>
    <pre><code class="language-java">package com.atguigu.boot3_08_kafka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.kafka.annotation.EnableKafka;

@EnableKafka //扫描kafka注解,开启基于注解的模式
@SpringBootApplication
public class Boot308KafkaApplication {

    public static void main(String[] args) {
        SpringApplication.run(Boot308KafkaApplication.class, args);

    }

}
</code></pre>
    <hr/>
    <h4>
     4.生产者发送消息
    </h4>
    <pre><code class="language-java">package com.atguigu.boot3_08_kafka.controller;

import com.atguigu.boot3_08_kafka.entity.Person;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class KafkaController {

    @Autowired
    private KafkaTemplate kafkaTemplate;

    @GetMapping("/jjj") 
    public String hello() {
        kafkaTemplate.send("tach", 0,"hello","急急急132");//send("主题", 分区号,"key","val")
        return "ok";
    }

    @GetMapping("/odj")
    public String odj() {
        kafkaTemplate.send("tach", 0,"hello",new Person(1L,"odj",19));//对象json需要序列化，可用配置文件配置，也可以在对象中序列化对象
        return "OK";
    }
}
</code></pre>
    <hr/>
    <h4>
     5.消费者监听消息
    </h4>
    <pre><code class="language-java">package com.atguigu.boot3_08_kafka.listener;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.annotation.PartitionOffset;
import org.springframework.kafka.annotation.TopicPartition;
import org.springframework.stereotype.Component;

@Component
public class MykafkaListener {

    /**
     * 默认的监听是从最后一个消息开始拿，也就是只会拿新消息，不会拿历史的
     * @KafkaListener(topics = "主题",groupId = "用户组")
     * ConsumerRecord 消费者从 Kafka 获取消息的各种元数据和实际的消息
     * @param record
     */
    @KafkaListener(topics = "tach",groupId = "teach")
    public void listen(ConsumerRecord&lt;?, ?&gt; record) {
        Object key = record.key();
        Object val = record.value();
        System.out.println("收到值key:"+key+"收到值val:"+val);
    }

    /**
     *  想要到历史的消息或者全部消息，只能设置偏移量
     *  @KafkaListener(groupId = "用户组" ,topicPartitions = {设置分区,设置偏移量})
     *  @TopicPartition(topic = "主题" ,partitionOffsets 设置偏移量)
     *  @PartitionOffset(partition = "哪个分区", initialOffset = "从第几个偏移量开始")
     *
     * @param record
     */
    @KafkaListener(groupId = "teach" ,topicPartitions = {
            @TopicPartition(topic = "tach" ,partitionOffsets = {
                    @PartitionOffset(partition = "0", initialOffset = "0")
            })
    })
    public void listens(ConsumerRecord&lt;?, ?&gt; record) {
        Object key = record.key();
        Object val = record.value();
        System.out.println("收到值key:"+key+"收到值val:"+val);
    }
}
</code></pre>
    <p>
     <strong>
      最后查看结果
     </strong>
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/aeb8dc213e414ec5a30d8481e116518b.png"/>
    </p>
    <hr/>
    <p>
     <span style="color:#fe2c24">
      <strong>
       最后补充一个小知识
      </strong>
     </span>
    </p>
    <p>
     groupId = "用户组"
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       组里的成员是竞争模式
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       用户组和用户组之间是发布/订阅模式
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       由zookeeper分配管理
      </strong>
     </span>
    </p>
    <p>
     <span style="color:null">
      <strong>
       好了可以和面试官吹牛逼了
      </strong>
     </span>
    </p>
    <hr/>
    <p>
     <span style="color:#fe2c24">
      <strong>
       课外话
      </strong>
     </span>
    </p>
    <p>
     如果是传对象json需要序列化，创建对象时序列化，
     <span style="color:#fe2c24">
      <strong>
       不推荐
      </strong>
     </span>
     太原始
     <span style="color:#fe2c24">
      <strong>
       重要是很占资源
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       因为开始我们都配置好了，有对象就会自动序列化
      </strong>
     </span>
    </p>
    <pre><code class="language-java">package com.atguigu.boot3_08_kafka.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;


@AllArgsConstructor
@NoArgsConstructor
@Data
public class Person implements Serializable {//不推荐implements Serializable 
    private Long id;
    private String name;
    private Integer age;
}
</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333435333632312f:61727469636c652f64657461696c732f313436323537323933" class_="artid" style="display:none">
 </p>
</div>


