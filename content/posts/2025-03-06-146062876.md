---
layout: post
title: "Spring编写单元测试的工具介绍JUnitMockitoAssertJ"
date: 2025-03-06 10:59:36 +0800
description: "在Spring应用程序中，想要通过代码走查做好测试左移，单元测试是确保代码质量和功能正确性的关键。除了我们常用的外，本次介绍一下其他常见的单元测试工具:来提高我们做白盒测试的效率。"
keywords: "Spring编写单元测试的工具介绍：JUnit、Mockito、AssertJ"
categories: ['Java']
tags: ['单元测试', 'Spring', 'Junit']
artid: "146062876"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146062876
    alt: "Spring编写单元测试的工具介绍JUnitMockitoAssertJ"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146062876
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146062876
cover: https://bing.ee123.net/img/rand?artid=146062876
image: https://bing.ee123.net/img/rand?artid=146062876
img: https://bing.ee123.net/img/rand?artid=146062876
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Spring编写单元测试的工具介绍：JUnit、Mockito、AssertJ
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3 id="w-e-element-450">
     <strong>
      背景：
     </strong>
    </h3>
    <p id="w-e-element-452">
     在Spring应用程序中，想要通过代码走查做好测试左移，单元测试是确保代码质量和功能正确性的关键。除了我们常用的
     <strong>
      TestNG
     </strong>
     外，本次介绍一下其他常见的单元测试工具:
     <strong>
      JUnit、Mockito、AssertJ，
     </strong>
     来提高我们做白盒测试的效率。
    </p>
    <h3 id="w-e-element-459">
     一、引入依赖
    </h3>
    <p id="w-e-element-461">
     在Maven项目中，我们通过添加以下依赖来引入使用
    </p>
    <h4 id="w-e-element-463">
     1、
     <strong>
      JUnit
     </strong>
    </h4>
    <p id="w-e-element-466">
     JUnit是最常用的Java单元测试框架之一，它提供了丰富的API来编写和组织测试用例。
    </p>
    <pre id="w-e-element-468"><code id="w-e-element-469">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.9.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
    <h4 id="w-e-element-471">
     2、
     <strong>
      Mockito
     </strong>
    </h4>
    <p id="w-e-element-474">
     Mockito允许我们创建模拟对象，并定义它们在测试中的行为。例如，我们可以模拟静态方法、构造函数或私有方法。可以用于模拟各个外部接口或者属性方法的数据。
    </p>
    <pre id="w-e-element-476"><code id="w-e-element-477">&lt;dependency&gt;
    &lt;groupId&gt;org.mockito&lt;/groupId&gt;
    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
    &lt;version&gt;4.8.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
    <h4 id="w-e-element-479">
     3、
     <strong>
      AssertJ
     </strong>
    </h4>
    <p id="w-e-element-482">
     AssertJ提供了丰富的断言方法，使得断言更加简洁和易读。它支持链式断言和软断言，使得测试代码更加清晰。
    </p>
    <pre id="w-e-element-484"><code id="w-e-element-485">&lt;dependency&gt;
    &lt;groupId&gt;org.assertj&lt;/groupId&gt;
    &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;
    &lt;version&gt;3.24.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
    <h3 id="w-e-element-487">
     二、常见模拟用法
    </h3>
    <h4 id="w-e-element-489">
     1.
     <strong>
      静态类
     </strong>
    </h4>
    <p id="w-e-element-492">
     使用MockedStatic @Cleanup注解自动close。
    </p>
    <pre id="w-e-element-494"><code id="w-e-element-495">@cleanup Mockedstatic&lt;URLDecoder&gt; urlDecoderMockedstatic =
                        Mockito.mockstatic(URLDecoder.class);
                urlDecoderMockedstatic.when(()-&gt;URLDecoder.decode(
                        Mockito.any(),Mockito.anystring())).
                        thenReturn(JsoNutil.toJsonstr(depositTradeResp));

</code></pre>
    <h4 id="w-e-element-497">
     2.
     <strong>
      工具类
     </strong>
    </h4>
    <p id="w-e-element-500">
     使用mockConstruction
    </p>
    <pre id="w-e-element-502"><code id="w-e-element-503">Mockito.mockConstruction(AesUtil.class, (util, context) -&gt; {
    Mockito.when(util.decryptMsg(Mockito.anyString())).thenReturn(true);
});

</code></pre>
    <h4 id="w-e-element-505">
     3.
     <strong>
      私有方法
     </strong>
    </h4>
    <p id="w-e-element-508">
     使用反射机制
    </p>
    <pre id="w-e-element-510"><code id="w-e-element-511">Method checkCouponByQuery = createGoOrderService.getClass().getDeclaredMethod("checkCouponByQuery", List.class, List.class, List.class);
checkCouponByQuery.setAccessible(true);

try {
    checkCouponByQuery.invoke(createGoOrderService, addedXPlusOrderInfoList, usableCoupon, checkCouponResultList);
} catch (Exception e) {
    logger.info("异常信息:{}", e.getMessage());
}

</code></pre>
    <h4 id="w-e-element-513">
     4.
     <strong>
      局部模拟
     </strong>
    </h4>
    <pre id="w-e-element-516"><code id="w-e-element-517"> ReflectUtil.setFieldValue(changeOrderService, "changeInfoMapper", changeInfoMapperOne);
BDDMockito.when(changeInfoMapperOne.getSubSegOrderList()).thenReturn(Arrays.asList("sdsd", "sds"));

</code></pre>
    <h3 id="w-e-element-519">
     三、单测类的实现
    </h3>
    <p id="w-e-element-521">
     下面这个基类为Spring Boot应用程序的测试提供了一个基础框架，包括测试环境的配置、测试数据的加载、以及测试过程中所需的工具和资源的管理。这有助于确保测试的一致性、可重复性和可靠性。其中loadJsonParam 方法允许测试类从类路径下的文件中加载JSON数据，这在测试需要发送JSON请求的API时很有用。init 方法在每个测试方法之前初始化 MockMvc 对象，这是测试Spring MVC应用程序的关键步骤。after 方法可以用来执行测试后的清理工作。最后，getMockMvc 和 getParamJsonStr 方法提供了对 MockMvc 对象和JSON参数字符串的访问，以便在测试中使用。
    </p>
    <pre id="w-e-element-523"><code id="w-e-element-524">package com.csair.ecs;

import java.io.BufferedReader;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import org.junit.After;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

@RunWith(SpringRunner.class)
@WebAppConfiguration
@SpringBootTest(classes = GroupNeedServiceApplication.class)
@ActiveProfiles("test")
public class BaseTest {

    public static final String UTF_8 = "UTF-8";

    @Autowired
    private WebApplicationContext webAppConfiguration;

    private MockMvc mockMvc;

    private String paramJsonStr;

    public void loadJsonParam(String classPathJsonFileName) {
        StringBuilder sb = new StringBuilder(300);
        try (BufferedInputStream inputStream = new BufferedInputStream(
                Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathJsonFileName));
             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, UTF_8))) {
            String temp;
            while ((temp = reader.readLine())!= null) {
                sb.append(temp);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        this.paramJsonStr = sb.toString();
    }

    // 在每个测试方法执行之前，初始化MockMvc对象。
    @Before
    public void init() {
        mockMvc = MockMvcBuilders.webAppContextSetup(webAppConfiguration).build();
    }

    // 在每个测试方法执行之后，可以执行清理工作。
    @After
    public void after() {
    }

    // 提供获取MockMvc对象的方法，以便在测试中使用。
    public MockMvc getMockMvc() {
        return mockMvc;
    }

    // 提供获取JSON参数字符串的方法，以便在测试中使用。
    public String getParamJsonStr() {
        return paramJsonStr;
    }
}

</code></pre>
    <h3 id="w-e-element-526">
     四、测试类实现
    </h3>
    <p id="w-e-element-528">
     下面这个测试类通过继承 BaseTest 类，利用已经配置好的测试环境和工具。每个测试方法都设计来覆盖特定的功能点，确保服务在各种输入下都能正确执行。使用 Lombok 的 @Slf4j 注解简化了日志记录的配置，使得测试代码更加简洁。
    </p>
    <pre id="w-e-element-530"><code id="w-e-element-531">@Slf4j
public class SystemParamsConfigServiceImplTest extends BaseTest {

    @Autowired
    private SystemParamsConfigService systemParamsConfigService;

    @Test
    public void testSelectParamsPageList() {
        // Test case 1
        SystemParamsConfigReq req1 = new SystemParamsConfigReq();
        req1.getPage().setPageNo(1);
        req1.getPage().setPageSize(5);
        ResponseBase&lt;PageData&lt;SystemParamsConfig&gt;&gt; responseBase1 = systemParamsConfigService.selectParamsPageList(req1);
        log.info("结果：{}", JSONUtil.parseObj(responseBase1));

        // Test case 2
        SystemParamsConfigReq req2 = new SystemParamsConfigReq();
        req2.getPage().setPageNo(1);
        req2.getPage().setPageSize(5);
        req2.setParamKey("dd");
        ResponseBase&lt;PageData&lt;SystemParamsConfig&gt;&gt; responseBase2 = systemParamsConfigService.selectParamsPageList(req2);
        log.info("结果：{}", JSONUtil.parseObj(responseBase2));

        // Test case 3
        SystemParamsConfigReq req3 = new SystemParamsConfigReq();
        req3.getPage().setPageNo(1);
        req3.getPage().setPageSize(5);
        req3.setRemark("d");
        ResponseBase&lt;PageData&lt;SystemParamsConfig&gt;&gt; responseBase3 = systemParamsConfigService.selectParamsPageList(req3);
        log.info("结果：{}", JSONUtil.parseObj(responseBase3));
    }

    @Test
    public void testGetByParamKey() {
        ResponseBase&lt;SystemParamsConfig&gt; responseBase = systemParamsConfigService.getByParamKey("aa");
        log.info("结果：{}", JSONUtil.parseObj(responseBase));
    }

    @Test
    public void testInsertParamConfig() {
        SystemParamsConfig paramsConfig = new SystemParamsConfig();
        paramsConfig.setParamKey(RandomUtil.randomNumbers(6));
        paramsConfig.setParamValue("测试一下");
        paramsConfig.setOperator("wangjiansheng9");
        paramsConfig.setRemark("备注一下");

        // Test case 1
        ResponseBase&lt;Integer&gt; responseBase1 = systemParamsConfigService.insertParamConfig(paramsConfig);
        log.info("结果：{}", JSONUtil.parseObj(responseBase1));
        setParamKey(paramsConfig.getParamKey());

        // Test case 2
        paramsConfig.setParamKey("ferferfrefrefrefer");
        ResponseBase&lt;Integer&gt; responseBase2 = systemParamsConfigService.insertParamConfig(paramsConfig);
        log.info("结果：{}", JSONUtil.parseObj(responseBase2));
    }
}

</code></pre>
    <h3 id="w-e-element-533">
     五、IDEA查看覆盖率
    </h3>
    <p id="w-e-element-535">
     在IntelliJ IDEA中，鼠标右键选中某个单元测试类或包，选择 更多运行/调试 - 使用覆盖率 - 使用覆盖率运行。﻿﻿
    </p>
    <p id="w-e-element-541">
     <strong>
      覆盖率
     </strong>
    </p>
    <p id="w-e-element-543">
     等待单元测试运行结束，会在IDEA右侧弹出覆盖率面板。在代码中查看具体覆盖情况。
    </p>
    <p id="w-e-element-449">
     ﻿
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="" height="316" src="https://i-blog.csdnimg.cn/img_convert/32867af3067fb0282b33de98ac950c9d.png" width="751"/>
    </p>
    <p>
     ﻿﻿
    </p>
    <p id="w-e-element-549">
     ﻿
    </p>
    <p id="w-e-element-551">
     ﻿
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34323333333236312f:61727469636c652f64657461696c732f313436303632383736" class_="artid" style="display:none">
 </p>
</div>


