---
layout: post
title: "Vue-3-vs-Vue-2深入解析从性能优化到源码层面的进化"
date: 2025-03-15 14:55:09 +0800
description: "领域Vue 2Vue 3响应式系统ProxyDiff 算法优化全量遍历VNodePatchFlag进行静态标记组件更新优化重新渲染整个组件仅更新变更部分构建工具Webpack热更新重新编译整个 bundle模块级 HMR，速度提升数倍代码组织TypeScript 支持限制类型推导完全支持Vue 3 带来了显著的性能优化、构建工具的改进，以及更灵活的开发体验。"
keywords: "Vue 3 vs Vue 2：深入解析从性能优化到源码层面的进化"
categories: ['未分类']
tags: ['性能优化', '前端', 'Vue']
artid: "146279433"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146279433
    alt: "Vue-3-vs-Vue-2深入解析从性能优化到源码层面的进化"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146279433
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146279433
cover: https://bing.ee123.net/img/rand?artid=146279433
image: https://bing.ee123.net/img/rand?artid=146279433
img: https://bing.ee123.net/img/rand?artid=146279433
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Vue 3 vs Vue 2：深入解析从性能优化到源码层面的进化
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     Vue.js 是当今前端开发中最受欢迎的框架之一。随着 Vue 3 的发布，它在性能优化、开发体验、响应式系统、构建工具和热更新等多个方面都带来了巨大提升。本文将深入剖析 Vue 3 的进化，包括其
     <strong>
      源码实现
     </strong>
     方面的优化，如
     <strong>
      diff算法、静态标记、编译优化
     </strong>
     ，以及 Vue 3 在热更新、构建工具上的改进。
    </p>
    <h3>
     <a id="1__2">
     </a>
     1. 性能提升：底层优化的革命
    </h3>
    <h4>
     <a id="11__ObjectdefineProperty__Proxy_4">
     </a>
     1.1 响应式系统的改进：从
     <code>
      Object.defineProperty
     </code>
     到 Proxy
    </h4>
    <p>
     Vue 2 的响应式系统基于
     <code>
      Object.defineProperty
     </code>
     ，它为每个属性单独设置 getter 和 setter。虽然能够满足基本需求，但它在以下方面存在性能瓶颈：
    </p>
    <ul>
     <li>
      <strong>
       无法监听新增/删除的属性
      </strong>
      ：Vue 2 需要通过
      <code>
       Vue.set()
      </code>
      和
      <code>
       Vue.delete()
      </code>
      来显式处理对象的属性变动，给开发者带来了额外的复杂性。
     </li>
     <li>
      <strong>
       数组变更检测成本高
      </strong>
      ：Vue 2 在处理数组时，需要特殊的处理方法（如
      <code>
       push
      </code>
      、
      <code>
       splice
      </code>
      ）来检测数组变动，且无法直接监听数组的长度变化。
     </li>
     <li>
      <strong>
       深层嵌套对象的性能问题
      </strong>
      ：Vue 2 需要递归地为每个属性创建 getter/setter，这对于复杂的嵌套对象来说，性能开销较大。
     </li>
    </ul>
    <p>
     Vue 3 改用了
     <strong>
      Proxy
     </strong>
     进行响应式代理，主要带来了以下优势：
    </p>
    <ul>
     <li>
      <strong>
       代理整个对象，而不是每个属性
      </strong>
      ，避免了 Vue 2 递归遍历的开销。
     </li>
     <li>
      <strong>
       支持新增/删除属性的自动检测
      </strong>
      ，无需
      <code>
       Vue.set()
      </code>
      。
     </li>
     <li>
      <strong>
       更好的数组检测机制
      </strong>
      ，可以监听数组长度变化。
     </li>
     <li>
      <strong>
       性能优化
      </strong>
      ，尤其在大量数据和深层对象的情况下，Proxy 无需递归遍历多层嵌套对象，更加高效。
     </li>
    </ul>
    <h5>
     <a id="Vue_3__19">
     </a>
     Vue 3 响应式系统示例：
    </h5>
    <pre><code class="prism language-javascript"><span class="token comment">// Vue 3 的 Proxy 实现</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 视图自动更新</span>

</code></pre>
    <p>
     <strong>
      性能对比
     </strong>
     ：
    </p>
    <ul>
     <li>
      <strong>
       Vue2
      </strong>
      ：对于每个属性，Vue 2 会分别创建 getter 和 setter，尤其在嵌套对象中，性能较差。
     </li>
     <li>
      <strong>
       Vue3
      </strong>
      ：通过 Proxy 直接代理整个对象，性能显著提升，尤其在大型应用中，避免了 Vue 2 中递归属性的性能瓶颈。
     </li>
    </ul>
    <h4>
     <a id="12_Lazy_Evaluation__Shallow_Reactive_36">
     </a>
     1.2 响应式系统中的异步优化：Lazy Evaluation 和 Shallow Reactive
    </h4>
    <p>
     Vue 3 引入了
     <strong>
      LazyEvaluation
     </strong>
     和
     <strong>
      ShallowReactive
     </strong>
     机制，进一步提升了响应式性能。通过
     <strong>
      ShallowReactive
     </strong>
     ，Vue 3 仅将对象的第一层进行响应式处理，避免了嵌套对象的自动深度响应式化，从而减少不必要的性能开销。
    </p>
    <pre><code class="prism language-javascript">
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">nested</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Shallow reactive：只将对象的第一层属性转换为响应式</span>
<span class="token keyword">const</span> shallowState <span class="token operator">=</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">nested</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
    <h3>
     <a id="2_Diff__DOM__48">
     </a>
     2. Diff 算法优化：更快的虚拟 DOM 更新
    </h3>
    <p>
     Vue 2 采用的
     <strong>
      diff算法
     </strong>
     主要基于
     <code>
      snabbdom
     </code>
     进行虚拟 DOM 的对比和更新，而 Vue 3 进行了优化，使其更加高效。
    </p>
    <h4>
     <a id="21_Vue_2__52">
     </a>
     2.1 Vue 2 的问题
    </h4>
    <p>
     在 Vue 2 中，每次组件更新时，都会重新遍历整个
     <code>
      VNode
     </code>
     树，并比较新旧
     <code>
      VNode
     </code>
     ，即使部分
     <code>
      VNode
     </code>
     结构是静态的，也无法跳过。特别是当组件中包含多个静态节点时，Vue 2 会重新计算这些静态节点，浪费了大量的计算资源。
    </p>
    <h4>
     <a id="22_Vue_3__PatchFlags_56">
     </a>
     2.2 Vue 3 的优化：静态标记与 PatchFlags
    </h4>
    <p>
     Vue 3 通过
     <strong>
      静态标记
     </strong>
     ，在编译阶段给
     <code>
      VNode
     </code>
     添加
     <strong>
      PatchFlag
     </strong>
     ，从而让 Vue 3 在
     <code>
      patch
     </code>
     过程中能够跳过不变的节点，仅更新变化的部分。这种优化带来了以下提升：
    </p>
    <ul>
     <li>
      <strong>
       减少无用的比较
      </strong>
      ，提升渲染速度。
     </li>
     <li>
      <strong>
       提升静态节点的复用
      </strong>
      ，减少虚拟 DOM 的计算量。
     </li>
     <li>
      <strong>
       优化子组件的更新方式
      </strong>
      ，只更新必要部分。
     </li>
    </ul>
    <h5>
     <a id="PatchFlag__64">
     </a>
     PatchFlag 示例：
    </h5>
    <pre><code class="prism language-javascript"><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'app'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'静态文本'</span><span class="token punctuation">,</span> <span class="token literal-property property">patchFlag</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 静态文本节点</span>
    <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> state<span class="token punctuation">.</span>message<span class="token punctuation">,</span> <span class="token literal-property property">patchFlag</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>  <span class="token comment">// 动态文本节点</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
    <p>
     在这个示例中，
     <code>
      p
     </code>
     标签的
     <code>
      VNode
     </code>
     被标记为静态节点，Vue 3 会跳过对
     <code>
      p
     </code>
     的更新，直接复用它，而对于
     <code>
      span
     </code>
     ，Vue 会对比
     <code>
      state.message
     </code>
     ，只更新该部分内容。
    </p>
    <h4>
     <a id="23__80">
     </a>
     2.3 为什么这能提升性能？
    </h4>
    <p>
     Vue 3 通过静态标记和
     <code>
      patchFlag
     </code>
     ，能够在更新时跳过静态节点，仅对发生变化的节点进行更新。与 Vue 2 的逐层对比不同，Vue 3 可以避免不必要的 diff 运算，显著提高了渲染性能。
    </p>
    <h4>
     <a id="24__DOM_Patch__84">
     </a>
     2.4 虚拟 DOM Patch 过程中的优化
    </h4>
    <p>
     Vue 3 对虚拟 DOM 的 Patch 过程进行了细化优化：
    </p>
    <ul>
     <li>
      <strong>
       静态节点复用
      </strong>
      ：如果某个节点内容不变，Vue 3 会复用它，而不是重新创建和插入该节点。
     </li>
     <li>
      <strong>
       组件更新优化
      </strong>
      ：Vue 3 会跳过不必要的子组件更新，尤其是当组件没有任何依赖或状态变动时。
     </li>
    </ul>
    <h3>
     <a id="3_Composition_API_91">
     </a>
     3. Composition API：更灵活的逻辑组织
    </h3>
    <p>
     Vue 3 引入了
     <strong>
      CompositionAPI
     </strong>
     ，相较于 Vue 2 的 Options API，提供了更好的代码组织能力。
    </p>
    <pre><code class="prism language-javascript"><span class="token comment">// Vue 3 Composition API 示例</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> count<span class="token punctuation">,</span> increment <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre>
    <p>
     <strong>
      优化点：
     </strong>
    </p>
    <ul>
     <li>
      <strong>
       更好地拆分逻辑
      </strong>
      ：通过
      <code>
       setup()
      </code>
      函数，Vue 3 允许将组件逻辑拆分为多个功能模块，避免了 Vue 2 中复杂的 mixins 逻辑。
     </li>
     <li>
      <strong>
       提高代码复用性
      </strong>
      ：Composition API 让开发者可以更轻松地提取和复用逻辑。
     </li>
    </ul>
    <h3>
     <a id="4__113">
     </a>
     4. 更强大的组件特性
    </h3>
    <h4>
     <a id="41_Teleport_115">
     </a>
     4.1 Teleport：动态插入组件
    </h4>
    <p>
     Vue 3 的
     <code>
      Teleport
     </code>
     组件允许内容渲染到 DOM 的其他部分，非常适用于模态框、工具提示等。
    </p>
    <pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>teleport</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>body<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>modal<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个模态框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>teleport</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

</code></pre>
    <h4>
     <a id="42_Suspense_128">
     </a>
     4.2 Suspense：更好的异步组件支持
    </h4>
    <p>
     支持异步组件加载时的错误处理和加载状态展示。
    </p>
    <pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Suspense</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#default</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AsyncComponent</span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#fallback</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>加载中...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Suspense</span><span class="token punctuation">&gt;</span></span>

</code></pre>
    <h3>
     <a id="5_Vite__Rollup_144">
     </a>
     5. 构建工具和热更新优化：Vite 与 Rollup
    </h3>
    <p>
     Vue 3 强烈推荐使用
     <strong>
      Vite
     </strong>
     作为开发工具。相比传统的 Webpack，Vite 在开发模式下采用了原生
     <strong>
      ESM
     </strong>
     ，并且只在文件发生变化时才进行增量编译，而不是预先打包整个项目。Vite 的主要优势在于：
    </p>
    <ul>
     <li>
      <strong>
       基于ESM的按需加载
      </strong>
      ：避免了 Webpack 的预打包问题。
     </li>
     <li>
      <strong>
       热更新更快
      </strong>
      ：仅编译受影响的模块，且响应时间显著缩短。
     </li>
     <li>
      <strong>
       支持HTTP2
      </strong>
      ：HTTP2 可以让多个模块并行加载，从而提高构建速度。
     </li>
    </ul>
    <h4>
     <a id="51__Vite__152">
     </a>
     5.1 为什么 Vite 的热更新更快？
    </h4>
    <ol>
     <li>
      <strong>
       原生ESM依赖
      </strong>
      ：Vite 使用原生的 ES 模块，能够利用浏览器对模块的原生支持。文件修改后，仅重新编译和加载修改的模块，而不是整个项目。
     </li>
     <li>
      <strong>
       模块级别的HMR
      </strong>
      ：Vite 热更新仅重新加载变更的模块，避免了 Webpack 每次都重新编译整个 bundle 的高开销。
     </li>
     <li>
      <strong>
       支持HTTP2
      </strong>
      ：通过 HTTP2 的多路复用，多个文件可以并行加载，减少了加载时间。
     </li>
    </ol>
    <h4>
     <a id="52_Rollup__158">
     </a>
     5.2 Rollup 的生产构建优化
    </h4>
    <p>
     在生产环境中，Vite 使用
     <strong>
      Rollup
     </strong>
     来进行构建，Rollup 的
     <strong>
      tree-shaking
     </strong>
     功能能够高效地去除未使用的代码，确保生成的生产包尽可能小。此外，Rollup 对
     <strong>
      ES模块
     </strong>
     有更好的支持，这使得其在构建生产环境代码时更高效。
    </p>
    <h3>
     <a id="6_TypeScript__162">
     </a>
     6. TypeScript 支持
    </h3>
    <p>
     Vue 3 的核心 API 完全使用
     <strong>
      TypeScript
     </strong>
     编写，并提供了良好的类型推导。通过 TypeScript，开发者可以在开发过程中获得更强的类型检查、代码补全和自动推导，极大地提高了代码的可靠性。
    </p>
    <pre><code class="prism language-typescript">
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
    <h3>
     <a id="7__173">
     </a>
     7. 总结
    </h3>
    <h4>
     <a id="Vue_3__Vue_2__175">
     </a>
     Vue 3 相较于 Vue 2 的核心优化点：
    </h4>
    <table>
     <thead>
      <tr>
       <th align="left">
        领域
       </th>
       <th align="left">
        Vue 2
       </th>
       <th align="left">
        Vue 3
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td align="left">
        响应式系统
       </td>
       <td align="left">
        <code>
         Object.defineProperty
        </code>
       </td>
       <td align="left">
        <code>
         Proxy
        </code>
       </td>
      </tr>
      <tr>
       <td align="left">
        Diff 算法优化
       </td>
       <td align="left">
        全量遍历
        <code>
         VNode
        </code>
       </td>
       <td align="left">
        <code>
         PatchFlag
        </code>
        进行静态标记
       </td>
      </tr>
      <tr>
       <td align="left">
        组件更新优化
       </td>
       <td align="left">
        重新渲染整个组件
       </td>
       <td align="left">
        仅更新变更部分
       </td>
      </tr>
      <tr>
       <td align="left">
        构建工具
       </td>
       <td align="left">
        Webpack
       </td>
       <td align="left">
        Vite + Rollup
       </td>
      </tr>
      <tr>
       <td align="left">
        热更新
       </td>
       <td align="left">
        重新编译整个 bundle
       </td>
       <td align="left">
        模块级 HMR，速度提升数倍
       </td>
      </tr>
      <tr>
       <td align="left">
        代码组织
       </td>
       <td align="left">
        Options API
       </td>
       <td align="left">
        Composition API
       </td>
      </tr>
      <tr>
       <td align="left">
        TypeScript 支持
       </td>
       <td align="left">
        限制类型推导
       </td>
       <td align="left">
        完全支持
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     Vue 3 带来了显著的性能优化、构建工具的改进，以及更灵活的开发体验。对于新项目，Vue 3 无疑是更好的选择，而对于已有 Vue 2 项目，也值得考虑迁移到 Vue 3 以享受这些优化带来的优势。
    </p>
    <p>
     <strong>
      技术交流沟通欢迎➕V：yinzhixiaxue
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e637364:6e2e6e65742f7a636d617274696e323031343231343238332f:61727469636c652f64657461696c732f313436323739343333" class_="artid" style="display:none">
 </p>
</div>


