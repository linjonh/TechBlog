---
layout: post
title: "iOS-ijkplayer-音视频同步"
date: 2023-05-18 16:59:06 +0800
description: "http://www.jianshu.com/p/daf0a61cc1e03.3 音视频渲染及同步3"
keywords: "ios ijkplayer 播放mp3"
categories: ['Ios']
tags: ['无标签']
artid: "72820816"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=72820816
    alt: "iOS-ijkplayer-音视频同步"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=72820816
featuredImagePreview: https://bing.ee123.net/img/rand?artid=72820816
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     iOS ijkplayer 音视频同步
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     http://www.jianshu.com/p/daf0a61cc1e0
     <br/>
    </p>
    <p>
    </p>
    <h5 style="line-height:1.7; color:rgb(47,47,47); margin:0px 0px 15px; font-size:20px">
     3.3 音视频渲染及同步
    </h5>
    <h6 style="line-height:1.7; color:rgb(47,47,47); margin:0px 0px 15px; font-size:18px">
     3.3.1 音频输出
    </h6>
    <p>
    </p>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     ijkplayer中Android平台使用OpenSL ES或AudioTrack输出音频，iOS平台使用AudioQueue输出音频。
    </p>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     audio output节点，在
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      ffp_prepare_async_l
     </code>
     方法中被创建：
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent"><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">ffp</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span> = ffpipeline_open_audio_output(ffp-&gt;</span>pipeline, ffp);</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      ffpipeline_open_audio_output
     </code>
     方法实际上调用的是IJKFF_Pipeline对象的函数指针
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      func_open_audio_utput
     </code>
     ，该函数指针在初始化中的
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      ijkmp_ios_create
     </code>
     方法中被赋值，最后指向的是
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      func_open_audio_output
     </code>
    </p>
    <pre><code class="language-cpp"><code class="cpp" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent"><span class="hljs-function" style=""><span class="hljs-keyword" style="color:rgb(133,153,0)">static</span> SDL_Aout *<span class="hljs-title" style="color:rgb(38,139,210)">func_open_audio_output</span><span class="hljs-params" style="">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span>
</span>{
    <span class="hljs-keyword" style="color:rgb(133,153,0)">return</span> SDL_AoutIos_CreateForAudioUnit();
}</code></code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      SDL_AoutIos_CreateForAudioUnit
     </code>
     定义如下，主要完成的是创建SDL_Aout对象
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">SDL_Aout *SDL_AoutIos_CreateForAudioUnit()
{
    SDL_Aout *aout = SDL_Aout_CreateInternal(sizeof(SDL_Aout_Opaque));
    <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (!aout)
        return NULL;

    <span class="hljs-comment" style="color:rgb(147,161,161)">// SDL_Aout_Opaque *opaque = aout-&gt;opaque;</span>

    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>free_l = aout_free_l;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>open_audio  = aout_open_audio;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>pause_audio = aout_pause_audio;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>flush_audio = aout_flush_audio;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>close_audio = aout_close_audio;

    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>func_set_playback_rate = aout_set_playback_rate;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>func_set_playback_volume = aout_set_playback_volume;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>func_get_latency_seconds = auout_get_latency_seconds;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">aout</span>-&gt;</span>func_get_audio_persecond_callbacks = aout_get_persecond_callbacks;
    return aout;
}</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     回到ffplay.c中，如果发现待播放的文件中含有音频，那么在调用
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      stream_component_open
     </code>
     打开解码器时，该方法里面也调用
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      audio_open
     </code>
     打开了audio output设备。
    </p>
    <pre class="hljs clean" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="clean" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">static int audio_open(FFPlayer *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params)
{
    FFPlayer *ffp = opaque;
    VideoState *is = ffp-&gt;is;
    SDL_AudioSpec wanted_spec, spec;
    ......
    wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);
    wanted_spec.channels = wanted_nb_channels;
    wanted_spec.freq = wanted_sample_rate;
    wanted_spec.format = AUDIO_S16SYS;
    wanted_spec.silence = <span class="hljs-number" style="color:rgb(42,161,152)">0</span>;
    wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="hljs-number" style="color:rgb(42,161,152)">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AoutGetAudioPerSecondCallBacks(ffp-&gt;aout)));
    wanted_spec.callback = sdl_audio_callback;
    wanted_spec.userdata = opaque;
    while (SDL_AoutOpenAudio(ffp-&gt;aout, &amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number" style="color:rgb(42,161,152)">0</span>) {
        .....
    }
    ......
    return spec.size;
}</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     在
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      audio_open
     </code>
     中配置了音频输出的相关参数
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      SDL_AudioSpec
     </code>
     ，并通过
    </p>
    <pre class="hljs rust" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="rust" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent"><span class="hljs-keyword" style="color:rgb(133,153,0)">int</span> SDL_AoutOpenAudio(SDL_Aout *aout, <span class="hljs-keyword" style="color:rgb(133,153,0)">const</span> SDL_AudioSpec *desired, SDL_AudioSpec *obtained)
{
    <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (aout &amp;&amp; desired &amp;&amp; aout-&gt;open_audio)
        <span class="hljs-keyword" style="color:rgb(133,153,0)">return</span> aout-&gt;open_audio(aout, desired, obtained);

    <span class="hljs-keyword" style="color:rgb(133,153,0)">return</span> -<span class="hljs-number" style="color:rgb(42,161,152)">1</span>;
}</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     设置给了Audio Output, iOS平台上即为AudioQueue。
    </p>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     AudioQueue模块在工作过程中，通过不断的callback来获取pcm数据进行播放。
    </p>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     有关AudioQueue的具体内容此处不再介绍。
    </p>
    <h6 style="line-height:1.7; color:rgb(47,47,47); margin:0px 0px 15px; font-size:18px">
     3.3.2 视频渲染
    </h6>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     iOS平台上采用OpenGL渲染解码后的YUV图像，渲染线程为
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_refresh_thread
     </code>
     ，最后渲染图像的方法为
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_image_display2
     </code>
     ，定义如下：
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">static void video_image_display2(FFPlayer *ffp)
{
    V<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">ideoState</span> *<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span> = ffp-&gt;</span><span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>;
    Frame *vp;
    Frame *sp = NULL;

    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">vp</span> = frame_queue_peek_last(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq);
    ......

    SDL_V<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">outDisplayYUVOverlay</span>(ffp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">vout</span>, vp-&gt;</span>bmp);
    ......
}</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     从代码实现上可以看出，该线程的主要工作为：
    </p>
    <ol style="margin-top:0px; margin-bottom:20px; word-break:break-word; padding:0px; margin-left:22px; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <li style="line-height:30px; margin-bottom:10px">
      调用
      <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
       frame_queue_peek_last
      </code>
      从pictq中读取当前需要显示视频帧
     </li>
     <li style="line-height:30px; margin-bottom:10px">
      <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; overflow:visible">
       调用
       <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
        SDL_VoutDisplayYUVOverlay
       </code>
       进行绘制
      </p>
      <pre class="hljs rust" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="rust" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent"> <span class="hljs-keyword" style="color:rgb(133,153,0)">int</span> SDL_VoutDisplayYUVOverlay(SDL_Vout *vout, SDL_VoutOverlay     *overlay)
 {
       <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (vout &amp;&amp; overlay &amp;&amp; vout-&gt;display_overlay)
           <span class="hljs-keyword" style="color:rgb(133,153,0)">return</span> vout-&gt;display_overlay(vout, overlay);

     <span class="hljs-keyword" style="color:rgb(133,153,0)">return</span> -<span class="hljs-number" style="color:rgb(42,161,152)">1</span>;
 }</code></pre>
      <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; overflow:visible">
       display_overlay函数指针在前面初始化流程有介绍过，它在
      </p>
      <pre class="hljs pf" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="pf" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent"> SDL_V<span class="hljs-keyword" style="color:rgb(133,153,0)">out</span> *SDL_V<span class="hljs-keyword" style="color:rgb(133,153,0)">out</span>Ios_CreateForGLES2()</code></pre>
      <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; overflow:visible">
       方法中被赋值为
       <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
        vout_display_overlay
       </code>
       ，该方法就是调用OpengGL绘制图像。
      </p>
     </li>
    </ol>
    <h6 style="line-height:1.7; color:rgb(47,47,47); margin:0px 0px 15px; font-size:18px">
     3.4.3 音视频同步
    </h6>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     对于播放器来说，音视频同步是一个关键点，同时也是一个难点，同步效果的好坏，直接决定着播放器的质量。通常音视频同步的解决方案就是选择一个参考时钟，播放时读取音视频帧上的时间戳，同时参考当前时钟参考时钟上的时间来安排播放。如下图所示：
    </p>
    <div class="image-package" style="padding-bottom:25px; width:700px; margin-left:-40px; text-align:center; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/5ef6c12ba9768ac028344f29a08e0f2d.webp?x-image-process=image/format,png" style="border:0px; vertical-align:middle; max-width:100%; height:auto">
      <br style=""/>
      <div class="image-caption" style="min-width:20%; max-width:80%; min-height:22px; display:inline-block; padding:10px; margin:0px auto; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(217,217,217); font-size:14px; color:rgb(150,150,150); line-height:1.7">
       音视频同步示意图.png
      </div>
     </img>
    </div>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     如果音视频帧的播放时间大于当前参考时钟上的时间，则不急于播放该帧，直到参考时钟达到该帧的时间戳；如果音视频帧的时间戳小于当前参考时钟上的时间，则需要“尽快”播放该帧或丢弃，以便播放进度追上参考时钟。
    </p>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     参考时钟的选择也有多种方式：
    </p>
    <ul style="margin-top:0px; margin-bottom:20px; padding:0px; word-break:break-word; margin-left:22px; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <li style="line-height:30px; margin-bottom:10px">
      选取视频时间戳作为参考时钟源
     </li>
     <li style="line-height:30px; margin-bottom:10px">
      选取音频时间戳作为参考时钟源
     </li>
     <li style="line-height:30px; margin-bottom:10px">
      选取外部时间作为参考时钟源
     </li>
    </ul>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     考虑人对视频、和音频的敏感度，在存在音频的情况下，优先选择音频作为主时钟源。
    </p>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     ijkplayer在默认情况下也是使用音频作为参考时钟源，处理同步的过程主要在视频渲染
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_refresh_thread
     </code>
     的线程中：
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">static int video_refresh_thread(void *arg)
{
    FFPlayer *ffp = arg;
    V<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">ideoState</span> *<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span> = ffp-&gt;</span><span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>;
    double remaining_time = <span class="hljs-number" style="color:rgb(42,161,152)">0.0</span>;
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">while</span> (!<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>abort_request) {
        <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (remaining_time &gt; <span class="hljs-number" style="color:rgb(42,161,152)">0.0</span>)
            av_usleep((int)(int64_t)(remaining_time * <span class="hljs-number" style="color:rgb(42,161,152)">1000000.0</span>));
        remaining_time = REFRESH_RATE;
        <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">show_mode</span> != SHOW_MODE_NONE &amp;&amp; (!<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">paused</span> || <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>force_refresh))
            video_refresh(ffp, &amp;remaining_time);
    }

    return <span class="hljs-number" style="color:rgb(42,161,152)">0</span>;
}</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     从上述实现可以看出，该方法中主要循环做两件事情：
    </p>
    <ol style="margin-top:0px; margin-bottom:20px; word-break:break-word; padding:0px; margin-left:22px; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <li style="line-height:30px; margin-bottom:10px">
      休眠等待，
      <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
       remaining_time
      </code>
      的计算在
      <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
       video_refresh
      </code>
      中
     </li>
     <li style="line-height:30px; margin-bottom:10px">
      调用
      <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
       video_refresh
      </code>
      方法，刷新视频帧
     </li>
    </ol>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     可见同步的重点是在
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_refresh
     </code>
     中，下面着重分析该方法：
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">   <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">lastvp</span> = frame_queue_peek_last(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq);
   <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">vp</span> = frame_queue_peek(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq);
    ......
   <span class="hljs-comment" style="color:rgb(147,161,161)">/* compute nominal last_duration */</span>
   last_duration = vp_duration(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>, lastvp, vp);
   delay = compute_target_delay(ffp, last_duration, <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>);</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     lastvp是上一帧，vp是当前帧，last_duration则是根据当前帧和上一帧的pts，计算出来上一帧的显示时间，经过
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      compute_target_delay
     </code>
     方法，计算出显示当前帧需要等待的时间。
    </p>
    <pre class="hljs maxima" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="maxima" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">static double compute_target_delay(FFPlayer *ffp, double <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span>, VideoState *<span class="hljs-built_in" style="color:rgb(38,139,210)">is</span>)
{
    double sync_threshold, <span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span> = <span class="hljs-number" style="color:rgb(42,161,152)">0</span>;

    <span class="hljs-comment" style="color:rgb(147,161,161)">/* update delay to follow master synchronisation source */</span>
    <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (get_master_sync_type(<span class="hljs-built_in" style="color:rgb(38,139,210)">is</span>) != AV_SYNC_VIDEO_MASTER) {
        <span class="hljs-comment" style="color:rgb(147,161,161)">/* if video is slave, we try to correct big delays by
           duplicating or deleting a frame */</span>
        <span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span> = get_clock(&amp;<span class="hljs-built_in" style="color:rgb(38,139,210)">is</span>-&gt;vidclk) - get_master_clock(<span class="hljs-built_in" style="color:rgb(38,139,210)">is</span>);

        <span class="hljs-comment" style="color:rgb(147,161,161)">/* skip or repeat frame. We take into account the
           delay to compute the threshold. I still don't know
           if it is the best guess */</span>
        sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span>));
        <span class="hljs-comment" style="color:rgb(147,161,161)">/* -- by bbcallen: replace is-&gt;max_frame_duration with AV_NOSYNC_THRESHOLD */</span>
        <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (!isnan(<span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span>) &amp;&amp; fabs(<span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span>) &lt; AV_NOSYNC_THRESHOLD) {
            <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (<span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span> &lt;= -sync_threshold)
                <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span> = FFMAX(<span class="hljs-number" style="color:rgb(42,161,152)">0</span>, <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span> + <span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span>);
            <span class="hljs-keyword" style="color:rgb(133,153,0)">else</span> <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (<span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span> &gt;= sync_threshold &amp;&amp; <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span> &gt; AV_SYNC_FRAMEDUP_THRESHOLD)
                <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span> = <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span> + <span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span>;
            <span class="hljs-keyword" style="color:rgb(133,153,0)">else</span> <span class="hljs-keyword" style="color:rgb(133,153,0)">if</span> (<span class="hljs-built_in" style="color:rgb(38,139,210)">diff</span> &gt;= sync_threshold)
                <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span> = <span class="hljs-number" style="color:rgb(42,161,152)">2</span> * <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span>;
        }
    }

     .....

    <span class="hljs-built_in" style="color:rgb(38,139,210)">return</span> <span class="hljs-built_in" style="color:rgb(38,139,210)">delay</span>;
}</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     在
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      compute_target_delay
     </code>
     方法中，如果发现当前主时钟源不是video，则计算当前视频时钟与主时钟的差值：
    </p>
    <ul style="margin-top:0px; margin-bottom:20px; padding:0px; word-break:break-word; margin-left:22px; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <li style="line-height:30px; margin-bottom:10px">
      如果当前视频帧落后于主时钟源，则需要减小下一帧画面的等待时间；
     </li>
     <li style="line-height:30px; margin-bottom:10px">
      如果视频帧超前，并且该帧的显示时间大于显示更新门槛，则显示下一帧的时间为超前的时间差加上上一帧的显示时间
     </li>
     <li style="line-height:30px; margin-bottom:10px">
      如果视频帧超前，并且上一帧的显示时间小于显示更新门槛，则采取加倍延时的策略。
     </li>
    </ul>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     回到
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_refresh
     </code>
     中
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">  <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span>= av_gettime_relative()/<span class="hljs-number" style="color:rgb(42,161,152)">1000000.0</span>;
  <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (isnan(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">frame_timer</span>) || <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span> &lt; <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>frame_timer)
     <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">is</span>-&gt;</span>frame_timer = <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span>;
  <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (<span class="hljs-built_in" style="color:rgb(38,139,210)">time</span> &lt; <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>frame_timer + delay) {
     *<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">remaining_time</span> = FFMIN(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>frame_timer + delay - <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span>, *remaining_time);
     goto display;
  }</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      frame_timer
     </code>
     实际上就是上一帧的播放时间，而
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      frame_timer + delay
     </code>
     实际上就是当前这一帧的播放时间，如果系统时间还没有到当前这一帧的播放时间，直接跳转至display，而此时
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      is-&gt;force_refresh
     </code>
     变量为0，不显示当前帧，进入
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_refresh_thread
     </code>
     中下一次循环，并睡眠等待。
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">  <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">is</span>-&gt;</span>frame_timer += delay;
  <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (delay &gt; 0 &amp;&amp; <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span> - <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>frame_timer &gt; AV_SYNC_THRESHOLD_MAX)
      <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">is</span>-&gt;</span>frame_timer = <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span>;

  SDL_L<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">ockMutex</span>(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq.mutex);
  <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (!isnan(vp-&gt;</span>pts))
         <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">update_video_pts</span>(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>, vp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">pts</span>, vp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">pos</span>, vp-&gt;</span>serial);
  SDL_U<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">nlockMutex</span>(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq.mutex);

  <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (frame_queue_nb_remaining(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq) &gt; <span class="hljs-number" style="color:rgb(42,161,152)">1</span>) {
       F<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">rame</span> *nextvp = frame_queue_peek_next(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq);
       duration = vp_duration(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>, vp, nextvp);
       <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span>(!<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">step</span> &amp;&amp; (ffp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">framedrop</span> &gt; 0 || (ffp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">framedrop</span> &amp;&amp; get_master_sync_type(<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; <span class="hljs-built_in" style="color:rgb(38,139,210)">time</span> &gt; <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>frame_timer + duration) {
           <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">frame_queue_next</span>(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq);
           goto retry;
       }
  }</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     如果当前这一帧的播放时间已经过了，并且其和当前系统时间的差值超过了
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      AV_SYNC_THRESHOLD_MAX
     </code>
     ，则将当前这一帧的播放时间改为系统时间，并在后续判断是否需要丢帧，其目的是为后面帧的播放时间重新调整frame_timer，如果缓冲区中有更多的数据，并且当前的时间已经大于当前帧的持续显示时间，则丢弃当前帧，尝试显示下一帧。
    </p>
    <pre class="hljs xl" style="overflow:auto; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:13px; padding:15px; margin-top:0px; margin-bottom:20px; line-height:1.42857; word-break:break-word; word-wrap:normal; color:rgb(101,123,131); border:1px solid rgb(204,204,204); background:rgb(246,246,246)"><code class="xl" style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; padding:0px; border:none; background-color:transparent">{
   <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">frame_queue_next</span>(&amp;<span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq);
   <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">is</span>-&gt;</span>force_refresh = <span class="hljs-number" style="color:rgb(42,161,152)">1</span>;

   SDL_L<span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">ockMutex</span>(ffp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">is</span>-&gt;</span>play_mutex);

    ......

display:
    <span class="hljs-comment" style="color:rgb(147,161,161)">/* display picture */</span>
    <span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">if</span> (!ffp-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">display_disable</span> &amp;&amp; <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">force_refresh</span> &amp;&amp; <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span><span class="hljs-function" style=""><span class="hljs-title" style="color:rgb(38,139,210)">show_mode</span> == SHOW_MODE_VIDEO &amp;&amp; <span class="hljs-keyword" style="color:rgb(133,153,0)">is</span>-&gt;</span>pictq.rindex_shown)
        video_display2(ffp);</code></pre>
    <p style="margin-top:0px; margin-bottom:25px; word-break:break-word; color:rgb(47,47,47); font-size:16px; line-height:27.2px">
     否则进入正常显示当前帧的流程，调用
     <code style="font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; color:rgb(101,123,131); padding:2px 4px; border:none; white-space:pre-wrap; background-color:rgb(246,246,246)">
      video_display2
     </code>
     开始渲染。
    </p>
    <br/>
   </div>
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f6a656666617364:2f61727469636c652f64657461696c732f3732383230383136" class_="artid" style="display:none">
 </p>
</div>


