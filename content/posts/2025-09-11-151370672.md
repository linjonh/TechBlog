---
layout: post
title: "设计模式从游戏角度开始了解设计模式-抽象工厂模式"
date: 2025-09-11T11:38:51+0800
description: "本文介绍了抽象工厂设计模式，通过游戏装备系统的案例展示了其实现方式。文章首先将抽象工厂与普通工厂模式进行对比，指出抽象工厂适用于多维度产品变种场景。随后以C++代码示例详细演示了装备基类、具体产品、抽象工厂和具体工厂的实现过程，并总结了四大要素。文章列举了抽象工厂的典型应用场景，包括GUI框架、游戏引擎文件系统、UI主题切换和跨平台网络库等。最后分析了模式的优缺点，强调其多维定制化能力但伴随复杂性增加的特点，并指出抽象工厂产品通常需要协同工作。"
keywords: "【设计模式】从游戏角度开始了解设计模式 --- 抽象工厂模式"
categories: ['未分类']
tags: ['设计模式', '游戏', 'C']
artid: "151370672"
arturl: "https://blog.csdn.net/JLX_1/article/details/151370672"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151370672
    alt: "设计模式从游戏角度开始了解设计模式-抽象工厂模式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151370672
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151370672
cover: https://bing.ee123.net/img/rand?artid=151370672
image: https://bing.ee123.net/img/rand?artid=151370672
img: https://bing.ee123.net/img/rand?artid=151370672
---



# 【设计模式】从游戏角度开始了解设计模式 --- 抽象工厂模式



![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9092e364114c4414bfc84b591d980a99.png)

永远记住，你的存在是有意义的， 

你很重要， 

你是被爱着的， 

而且你为这个世界带来了无可取代的东西。 

-- 麦克西 《男孩、鼹鼠、狐狸和马》--

---

## 抽象工厂模式

今天我们一起来探究抽象工厂模式，这是对工厂模式的进阶实现。通常我们将工厂模式与抽象工厂模式比作一维数组与二维数组。

工厂模式我们可以创建出一种类别的实例，而如果我们此时这种类别存在若干个变种，这时就可以通过抽象工厂模式进行创建。

比如现在正在制作一块魔幻rpg类型游戏，每个角色都有武器与防具两种装备。武器存在大剑，法杖，拳套等，防具有护盾，魔法书，披风等。对于这个背景，就有两个维度。为了实现这个功能可以如下设计：

```cpp
#include<iostream>

using namespace std;
//装备基类
class Weapon {
public:
	virtual void use() = 0;
};
//防具基类
class Armour {
public:
	virtual void equip() = 0;
};

//大剑
class Sword : public Weapon{
public:
	void use() {
		cout << "use sword" << endl;
	}
};
//法杖
class Staff : public Weapon {
public:
	void use() {
		cout << "use staff" << endl;
	}
};

//护盾
class Shield : public Armour {
public:
	void equip() override {
		cout << "equip shield" << endl;
	}
};
//斗篷
class Cloak : public Armour {
public:
	void equip() {
		cout << "equip cloak" << endl;
	}
};

//角色装备工厂
class EquipmentFactory {
public:
	virtual Weapon* createWeapon() = 0;
	virtual Armour* createArmour() = 0;
};

class WarriorFactory : public EquipmentFactory {
public:
	Weapon* createWeapon() override{
		return new Sword();
	}

	Armour* createArmour() override {
		return new Shield();
	}

};

class MageFactory : public EquipmentFactory {
public:
	Weapon* createWeapon() override {
		return new Staff();
	}

	Armour* createArmour() override {
		return new Cloak();
	}
};



class Character {
public:
	Character(EquipmentFactory* factory) :_factory(factory),
											weapon(nullptr),
											armour(nullptr) {}
	//角色展现出来的装备特性
	void equip() {
		weapon = _factory->createWeapon();
		armour = _factory->createArmour();

		//调用装备使用方法
		weapon->use();
		armour->equip();
	}

private:
	EquipmentFactory* _factory;
	Weapon* weapon = nullptr;
	Armour* armour = nullptr;
};



int main() {
	//创建战士
	EquipmentFactory* warriorFactory = new WarriorFactory();
	Character warrior(warriorFactory);
	warrior.equip();

	EquipmentFactory* mageFactory = new MageFactory();
	Character mage(mageFactory);
	mage.equip();

	return 0;

}

```

根据这个例子，我们可以总结一下抽象工厂的要素：

1. 抽象产品：如weapon与Armour基类，约定了具体产品的接口声明，限制他们必须具有的功能
2. 具体产品：如sword，staff ，shield类，这是实际发挥作用的产品，是最终被抽象工厂实例化的对象
3. 抽象工厂：负责声明一组接口，来创建抽象产品。
4. 具体工厂：具体工厂负责实例化具体产品。

抽象工厂模式通常在以下场景中使用：

1. 跨平台GUI框架：qt， GTK+，wxWidgets对平台的不同组件进行封装
2. 游戏引擎文件系统：不同操作系统上的文件操作api是不同的，当针对不同平台进行导出发布时，游戏引擎底层帮助我们完成了对不同平台文件读写的屏蔽与兼容。文件系统内部的writer与Reader读写器，就可以通过抽象工厂创建
3. 游戏界面风格主题：针对不同主题实现不同UI组件的灵活切换。当版本更新或者活动上线时，可能需要对已有的界面组件在功能保持不变的情况下，对配色布局进行替换。这就需要我们通过抽象层来讲它与客户端代码解耦。
4. 跨平台网络库：游戏引擎需要对不同系统的网络接口提供抽象与兼容。

再来看抽象工厂的优缺点

* 优点：**更多维度的可定制化**，可以针对不同的产品变种提供具体的创建逻辑。
* 缺点：更多的类，代码更多，抽象和理解的过程更加复杂。
* 抽象工厂下的产品通常是协同工作的！



