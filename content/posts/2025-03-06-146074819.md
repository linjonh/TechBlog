---
layout: post
title: "数据结构拓展详解reallocC"
date: 2025-03-06 17:11:47 +0800
description: "在C++中，realloc 是C标准库提供的一个内存管理函数，用于动态调整已分配内存块的大小。"
keywords: "数据结构拓展：详解realloc(C++)"
categories: ['数据结构']
tags: ['顺序表', '链表', '线性表', '数据结构', 'C', 'C']
artid: "146074819"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146074819
    alt: "数据结构拓展详解reallocC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146074819
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146074819
cover: https://bing.ee123.net/img/rand?artid=146074819
image: https://bing.ee123.net/img/rand?artid=146074819
img: https://bing.ee123.net/img/rand?artid=146074819
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构拓展：详解realloc(C++)
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     前言
    </h2>
    <p>
     在C++中，
     <code>
      realloc
     </code>
     是C标准库提供的一个内存管理函数，用于
     <strong>
      动态调整已分配内存块的大小
     </strong>
     。尽管C++更推荐使用
     <code>
      new
     </code>
     /
     <code>
      delete
     </code>
     或智能指针，但在某些场景（如与C代码交互或底层内存操作）中仍可能用到
     <code>
      realloc
     </code>
     。以下是详细分析：
    </p>
    <h4>
     <strong>
      一、
      <code>
       realloc
      </code>
      的核心行为
     </strong>
    </h4>
    <pre><code class="language-cpp">void* realloc(void* ptr, size_t new_size);</code></pre>
    <ul>
     <li>
      <strong>
       功能
      </strong>
      ：调整
      <code>
       ptr
      </code>
      指向的内存块大小（原内存块由
      <code>
       malloc
      </code>
      /
      <code>
       calloc
      </code>
      /
      <code>
       realloc
      </code>
      分配）。
     </li>
     <li>
      <strong>
       返回值
      </strong>
      ：
      <ul>
       <li>
        成功：返回指向新内存块的指针（可能与原指针不同）。
       </li>
       <li>
        失败：返回
        <code>
         NULL
        </code>
        ，
        <strong>
         原内存块保持不变
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       底层逻辑
      </strong>
      ：
      <ol>
       <li>
        若
        <code>
         new_size
        </code>
        为0且
        <code>
         ptr
        </code>
        非空：等价于
        <code>
         free(ptr)
        </code>
        ，返回
        <code>
         NULL
        </code>
        。
       </li>
       <li>
        若
        <code>
         ptr
        </code>
        为
        <code>
         NULL
        </code>
        ：等价于
        <code>
         malloc(new_size)
        </code>
        。
       </li>
       <li>
        若当前内存块后有空闲空间：直接扩展内存，原数据保留。
       </li>
       <li>
        若空间不足：分配新内存块 → 复制原数据 → 释放旧内存块。
       </li>
      </ol>
     </li>
    </ul>
    <h4>
     <strong>
      二、
      <code>
       realloc
      </code>
      在C++中的风险
     </strong>
    </h4>
    <h5>
     <strong>
      1. 不适用于非POD类型
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       问题
      </strong>
      ：
      <code>
       realloc
      </code>
      <strong>
       不会调用构造函数或析构函数
      </strong>
      ，可能导致对象生命周期管理错误。
     </li>
    </ul>
    <pre><code class="language-cpp">struct NonPOD {
    int* ptr;
    NonPOD() { ptr = new int(42); }    // 构造函数分配内存
    ~NonPOD() { delete ptr; }          // 析构函数释放内存
};

NonPOD* arr = (NonPOD*)malloc(10 * sizeof(NonPOD));
// 错误！构造函数未被调用
arr = (NonPOD*)realloc(arr, 20 * sizeof(NonPOD)); 
// 若内存地址改变，旧内存被释放，但析构函数未执行 → 内存泄漏</code></pre>
    <p>
    </p>
    <h5>
     <strong>
      2. 返回值处理不当导致内存泄漏
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       错误示例
      </strong>
      ：
     </li>
    </ul>
    <pre><code class="language-cpp">int* ptr = (int*)malloc(100);
ptr = (int*)realloc(ptr, 200);  // 若 realloc 失败，ptr 被设为 NULL，原内存泄漏！</code></pre>
    <p>
     <strong>
      正确做法
     </strong>
     ：使用临时变量保存结果。
    </p>
    <pre><code class="language-cpp">int* tmp = (int*)realloc(ptr, 200);
if (tmp) {
    ptr = tmp;  // 成功后再赋值
} else {
    // 处理失败，原 ptr 仍有效
}</code></pre>
    <p>
    </p>
    <h4>
     <strong>
      三、C++中的替代方案
     </strong>
    </h4>
    <h5>
     <strong>
      1. 使用
      <code>
       new
      </code>
      /
      <code>
       delete
      </code>
      和手动复制
     </strong>
    </h5>
    <pre><code class="language-cpp">int* old_arr = new int[10];
int* new_arr = new int[20];
std::copy(old_arr, old_arr + 10, new_arr);
delete[] old_arr;  // 正确释放旧内存</code></pre>
    <h5>
     <strong>
      2. 使用
      <code>
       std::vector
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <strong>
       推荐方案
      </strong>
      ：自动处理内存分配、复制和释放。
     </li>
    </ul>
    <pre><code class="language-cpp">std::vector&lt;int&gt; vec(10);
vec.resize(20);  // 自动重新分配内存并复制数据</code></pre>
    <p>
    </p>
    <h5>
     <strong>
      3. 智能指针 +
      <code>
       realloc
      </code>
      替代方案
     </strong>
    </h5>
    <ul>
     <li>
      若必须使用
      <code>
       realloc
      </code>
      ，可结合
      <code>
       unique_ptr
      </code>
      自定义删除器：
     </li>
    </ul>
    <pre><code class="language-cpp">auto deleter = [](int* ptr) { free(ptr); };
std::unique_ptr&lt;int[], decltype(deleter)&gt; ptr((int*)malloc(100), deleter);
// 调整大小
int* tmp = (int*)realloc(ptr.get(), 200);
if (tmp) {
    ptr.release();  // 解除原有指针管理
    ptr.reset(tmp); // 接管新指针
}</code></pre>
    <p>
     <strong>
      四、
      <code>
       realloc
      </code>
      的适用场景
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         场景
        </strong>
       </th>
       <th>
        <strong>
         是否推荐
        </strong>
       </th>
       <th>
        <strong>
         原因
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        处理POD类型（如基本类型）
       </td>
       <td>
        谨慎使用
       </td>
       <td>
        需手动管理内存，但无构造/析构函数风险
       </td>
      </tr>
      <tr>
       <td>
        非POD类型（类对象）
       </td>
       <td>
        禁止使用
       </td>
       <td>
        破坏对象生命周期，导致未定义行为
       </td>
      </tr>
      <tr>
       <td>
        高性能动态数组
       </td>
       <td>
        有限使用
       </td>
       <td>
        可能比
        <code>
         new
        </code>
        + 复制更快，但需确保内存连续且类型简单
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     <strong>
      五、
      <code>
       realloc
      </code>
      的优缺点
     </strong>
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         优点
        </strong>
       </th>
       <th>
        <strong>
         缺点
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        可能原地扩展内存，减少复制开销
       </td>
       <td>
        不适用于C++对象（无法处理构造/析构）
       </td>
      </tr>
      <tr>
       <td>
        语法简洁
       </td>
       <td>
        返回值处理不当易导致内存泄漏
       </td>
      </tr>
      <tr>
       <td>
        兼容C代码
       </td>
       <td>
        内存分配失败需手动回退
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        需显式类型转换（C++中强制要求）
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     <strong>
      六、总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       在C++中尽量避免直接使用
       <code>
        realloc
       </code>
      </strong>
      ，优先选择
      <code>
       std::vector
      </code>
      、
      <code>
       std::unique_ptr
      </code>
      或手动
      <code>
       new
      </code>
      /
      <code>
       delete
      </code>
      。
     </li>
     <li>
      <strong>
       若必须使用
      </strong>
      ：
      <ol>
       <li>
        仅用于POD类型（如基本类型、结构体无构造/析构函数）。
       </li>
       <li>
        严格检查返回值，避免内存泄漏。
       </li>
       <li>
        考虑与智能指针结合，增强安全性。
       </li>
      </ol>
     </li>
    </ul>
    <h2>
     扩展：代码(初阶)
    </h2>
    <h3>
     SeqList.h
    </h3>
    <pre><code class="language-cpp">#pragma once

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

//定义动态顺序表结构

typedef int SLDataType;

struct SeqList {
	int* arr;
	int capacity;
	int size;
};

typedef struct SeqList SL;

//初始化

void SLInit(SL* ps);

//销毁

void SLDestory(SL* ps);

//插入数据

void SLPushBack(SL* ps, SLDataType x);

void SLPushFront(SL* ps, SLDataType x);

</code></pre>
    <h3>
     Test.cpp
    </h3>
    <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS  1
#pragma warning(disable:6031)

#include"SeqList.h"

void SLTest01() {
	SL s;
	SLInit(&amp;s);
}

int main() {
	SLTest01();
	return 0;
}</code></pre>
    <h3>
     SeqList.cpp
    </h3>
    <pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS  1
#pragma warning(disable:6031)

#include"SeqList.h"

//初始化

void SLInit(SL* ps) {
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}

//销毁

void SLDestory(SL* ps) {
	if (ps-&gt;arr != NULL) {
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}

//插入数据

void SLPushBack(SL* ps, SLDataType x) {
	//判断空间是否充足

	if (ps-&gt;size == ps-&gt;capacity) {
		//增容
		ps-&gt;arr=realloc
	}

	ps-&gt;arr[ps-&gt;size] = x;
	ps-&gt;size++;
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303530383539382f:61727469636c652f64657461696c732f313436303734383139" class_="artid" style="display:none">
 </p>
</div>


