---
layout: post
title: "每日八股Golang篇四GMP"
date: 2025-03-12 02:21:35 +0800
description: "根据 csview 整理 golang GMP 部分的八股文。"
keywords: "【每日八股】Golang篇（四）：GMP"
categories: ['Golang']
tags: ['开发语言', '后端', 'Golang']
artid: "146193680"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146193680
    alt: "每日八股Golang篇四GMP"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146193680
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146193680
cover: https://bing.ee123.net/img/rand?artid=146193680
image: https://bing.ee123.net/img/rand?artid=146193680
img: https://bing.ee123.net/img/rand?artid=146193680
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【每日八股】Golang篇（四）：GMP
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="GMP__1">
     </a>
     GMP 模型？
    </h2>
    <h3>
     <a id="GGoroutine_2">
     </a>
     G：Goroutine
    </h3>
    <p>
     G 是 golang 中 goroutine 的缩写。goroutine，也称作协程，它的行为类似于 OS 当中的一个进程控制块，不过协程是完全运行在用户态的，不需要与内核态交互。一个 goroutine 通过结构体 g 进行管理，g 中存放着 goroutine 运行时的栈信息，CPU 一些寄存器的值以及要执行的函数指令。
     <code>
      sched
     </code>
     字段的类型是
     <code>
      gobuf
     </code>
     ，它保存着 goroutine 的上下文。goroutine 在切换的时候，不依赖 OS 提供上下文保存，而是直接将上下文保存在了 gobuf 这个结构当中：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
  stack       stack   		<span class="token comment">// 描述真实的栈内存，包括上下界</span>

  m              <span class="token operator">*</span>m     	<span class="token comment">// 当前的 m</span>
  sched          gobuf   	<span class="token comment">// goroutine 切换时，用于保存 g 的上下文      </span>
  param          unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 用于传递参数，睡眠时其他 goroutine 可以设置 param，唤醒时该goroutine可以获取</span>
  atomicstatus   <span class="token builtin">uint32</span>
  stackLock      <span class="token builtin">uint32</span> 
  goid           <span class="token builtin">int64</span>  	<span class="token comment">// goroutine 的 ID</span>
  waitsince      <span class="token builtin">int64</span> 		<span class="token comment">// g 被阻塞的大体时间</span>
  lockedm        <span class="token operator">*</span>m     	<span class="token comment">// G 被锁定只在这个 m 上运行</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     <code>
      gobuf
     </code>
     类型保存了当前栈的指针、计数器以及 g 本身，此处对 g 的指针进行保存的目的是为了能够快速访问到 goroutine 中的信息。gobuf 的结构如下：
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> gobuf <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	sp   <span class="token builtin">uintptr</span>
    pc   <span class="token builtin">uintptr</span>
    g    guintptr
    ctxt unsafe<span class="token punctuation">.</span>Pointer
    ret  sys<span class="token punctuation">.</span>Uintreg
    lr   <span class="token builtin">uintptr</span>
    bp   <span class="token builtin">uintptr</span> <span class="token comment">// for goEXPERIMENT=framepointer</span>
<span class="token punctuation">}</span>
</code></pre>
    <h3>
     <a id="MMachine_31">
     </a>
     M：Machine
    </h3>
    <p>
     M 代表的是操作系统的主线程，是对内核级线程的封装，其运行的数量对应着运行机器上真实的 CPU 数。一个 M 直接关联一个 OS 的内核线程，用于执行 G。M 会优先从关联的 P 的本地队列中直接获取待执行的 G。M 保存了其自身要使用的栈信息、当前正在 M 上执行的 G 的信息，以及与之绑定的 P 的信息。
    </p>
    <p>
     在 M 的结构定义中，
     <code>
      curg
     </code>
     代表结构体 M 当前绑定的结构体 G。
     <code>
      g0
     </code>
     是带有调度栈的 goroutine，普通的 goroutine 的栈是在堆上分配的可增长的栈，但
     <code>
      g0
     </code>
     的栈式 M 对应的线程的栈。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> m <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    g0      <span class="token operator">*</span>g     				<span class="token comment">// 带有调度栈的goroutine</span>

    gsignal       <span class="token operator">*</span>g         	<span class="token comment">// 处理信号的goroutine</span>
    tls           <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span> 	<span class="token comment">// thread-local storage</span>
    mstartfn      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    curg          <span class="token operator">*</span>g       		<span class="token comment">// 当前运行的goroutine</span>
    caughtsig     guintptr 
    p             puintptr 		<span class="token comment">// 关联p和执行的go代码</span>
    nextp         puintptr
    id            <span class="token builtin">int32</span>
    mallocing     <span class="token builtin">int32</span> 		<span class="token comment">// 状态</span>

    spinning      <span class="token builtin">bool</span> 			<span class="token comment">// m是否out of work</span>
    blocked       <span class="token builtin">bool</span> 			<span class="token comment">// m是否被阻塞</span>
    inwb          <span class="token builtin">bool</span> 			<span class="token comment">// m是否在执行写屏蔽</span>

    printlock     <span class="token builtin">int8</span>
    incgo         <span class="token builtin">bool</span>
    fastrand      <span class="token builtin">uint32</span>
    ncgocall      <span class="token builtin">uint64</span>      	<span class="token comment">// cgo调用的总数</span>
    ncgo          <span class="token builtin">int32</span>       	<span class="token comment">// 当前cgo调用的数目</span>
    park          note
    alllink       <span class="token operator">*</span>m 			<span class="token comment">// 用于链接allm</span>
    schedlink     muintptr
    mcache        <span class="token operator">*</span>mcache 		<span class="token comment">// 当前m的内存缓存</span>
    lockedg       <span class="token operator">*</span>g 			<span class="token comment">// 锁定g在当前m上执行，而不会切换到其他m</span>
    createstack   <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span> 	<span class="token comment">// thread创建的栈</span>
<span class="token punctuation">}</span>

</code></pre>
    <h3>
     <a id="PProcessor_68">
     </a>
     P：Processor
    </h3>
    <p>
     Processor 代表了 M 所需的上下文环境，代表着 M 运行 G 所需要的资源。P 是处理用户级代码逻辑的处理器，可以将其视作一个局部调度器，使得 go 的代码可以在线程上运行。当 P 有任务时，需要创建或唤醒一个系统线程来执行其队列当中的任务，所以 P 和 M 是互相绑定的（回忆一下，M 对应的是 golang 代码所运行机器的操作系统的线程，而 P 是 M 运行所需要的上下文，因此二者必然是相互绑定的）。
    </p>
    <p>
     P 可以根据实际情况去开启协程工作，它包含了运行 goroutine 的资源，如果线程像运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。
    </p>
    <pre><code class="prism language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    lock mutex

    id          <span class="token builtin">int32</span>
    status      <span class="token builtin">uint32</span> 		<span class="token comment">// 状态，可以为pidle/prunning/...</span>
    link        puintptr
    schedtick   <span class="token builtin">uint32</span>     <span class="token comment">// 每调度一次加1</span>
    syscalltick <span class="token builtin">uint32</span>     <span class="token comment">// 每一次系统调用加1</span>
    sysmontick  sysmontick 
    m           muintptr   <span class="token comment">// 回链到关联的m</span>
    mcache      <span class="token operator">*</span>mcache
    racectx     <span class="token builtin">uintptr</span>

    goidcache    <span class="token builtin">uint64</span> 	<span class="token comment">// goroutine的ID的缓存</span>
    goidcacheend <span class="token builtin">uint64</span>

    <span class="token comment">// 可运行的goroutine的队列</span>
    runqhead <span class="token builtin">uint32</span>
    runqtail <span class="token builtin">uint32</span>
    runq     <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span>guintptr

    runnext guintptr 		<span class="token comment">// 下一个运行的g</span>

    sudogcache <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>sudog
    sudogbuf   <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token operator">*</span>sudog

    palloc persistentAlloc <span class="token comment">// per-P to avoid mutex</span>

    pad <span class="token punctuation">[</span>sys<span class="token punctuation">.</span>CacheLineSize<span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>

</code></pre>
    <h2>
     <a id="GMP__106">
     </a>
     GMP 的调度流程？
    </h2>
    <p>
     <img alt="请添加图片描述" src="https://i-blog.csdnimg.cn/direct/ed31460e01d743efa1c936fd72c53931.jpeg#pic_center"/>
    </p>
    <ul>
     <li>
      每个 P 有一个局部队列，局部队列保存待执行的 goroutine，当 M 绑定的 P 的局部队列已满时，goroutine 会被追加到全局队列当中；
     </li>
     <li>
      每个 P 和一个 M 绑定，M 是真正执行 P 中 goroutine 的实体，M 会从其绑定的 P 的局部队列取 G 来执行；
     </li>
     <li>
      当 M 所绑定的 P 为空时，会从全局队列取 G，当全局队列中无 G 时，M 会从其它 P 队列中偷取 G 来执行，这种从其它 P 截获 G 来提前执行的行为称作 work stealing；
     </li>
     <li>
      当 G 因系统调用阻塞时会阻塞 M，此时 P 和 M 解绑，并寻找新的理想的 M，若没有理想的 M 则会新创建一个 M【goroutine 中的系统调用会阻塞承载它的进程，此时与进程（M）绑定的资源及 goroutine 队列（一并打包为 P）会寻找一个新的线程（M）或是新建一个线程（M）来绑定】；
     </li>
     <li>
      当 G 因 channel 或其他 network I/O 阻塞时，不会阻塞 M，M 会寻找其它可运行的 G 并执行；当阻塞的 G 恢复后，会重新进入其对应的 P 队列等待执行【goroutine 中的 channel 或 network I/O 不会阻塞线程（M），goroutine 自身陷入阻塞态，而 M 继续执行 P 中其它 G。当阻塞的 G 就绪后，重新插入 P 队列】。
     </li>
    </ul>
    <h2>
     <a id="P__M__114">
     </a>
     P 和 M 的个数？
    </h2>
    <p>
     P：由启动时环境变量
     <code>
      $GOMAXPROCS
     </code>
     或
     <code>
      runtime
     </code>
     的
     <code>
      GOMAXPROCS()
     </code>
     方法决定。这意味着程序在执行的任意时刻都只有
     <code>
      $GOMAXPROCS
     </code>
     个 goroutine 在同时运行【当然，等待被调度执行的 goroutine 可能跟多，它们都在 P 的队列中等待】；
    </p>
    <p>
     M：
    </p>
    <ul>
     <li>
      Golang 本身的限制：Golang 程序启动时，会设置 M 的最大数量，默认是 10000，但是内核很难支持这么多的线程同时运行。不过这条限制本身可以忽略；
     </li>
     <li>
      runtime/debug 中的 SetMaxThreads 设置 M 的最大数量；
     </li>
     <li>
      一个 M 阻塞后，会创建新的 M。
     </li>
    </ul>
    <p>
     M 与 P 的数量没有绝对关系，如果一个 M 阻塞，其承载的 P 就会创建一个新的 M，所以，即使 P 的默认数量为 1，也可能对应多个 M。
    </p>
    <h2>
     <a id="P__M__124">
     </a>
     P 和 M 何时创建？
    </h2>
    <ul>
     <li>
      P：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P；
     </li>
     <li>
      M：当没有足够的 M 来关联 P 时，M 会创建。比如当前时刻所有 M 都阻塞了，而 P 中还有很多就绪的任务，此时就会去寻找空闲的 M，如果没有空闲的 M，就创建新的 M。
     </li>
    </ul>
    <h2>
     <a id="goroutine__128">
     </a>
     goroutine 创建流程？
    </h2>
    <p>
     调用
     <code>
      go func()
     </code>
     时，golang 会调用
     <code>
      runtime.newproc
     </code>
     来创建一个 goroutine，这个 goroutine 会新建一个自己的栈空间，同时在 G 的
     <code>
      sched
     </code>
     （用于维护 goroutine 上下文的字段）中维护栈地址及程序计数器这些上下文信息。
    </p>
    <p>
     创建好的 goroutine 会被放到其所对应内核线程 M 所绑定的上下文 P 的
     <code>
      run_queue
     </code>
     当中，等待调度器决定何时取出这个 goroutine 并执行，通常的调度顺序是按时间顺序来调度，即
     <code>
      rune_queue
     </code>
     是一个先进先出的队列。
    </p>
    <h2>
     <a id="goroutine__133">
     </a>
     goroutine 何时被挂起？
    </h2>
    <ul>
     <li>
      waitReasonChanReceiveNilChan：对未初始化的 channel 进行读操作；
     </li>
     <li>
      waitReasonChanSendNilChan：对未初始化的 channel 进行写操作；
     </li>
     <li>
      在 main goroutine 发生 panic 时，会触发；
     </li>
     <li>
      在调用关键字 select 时会触发；
     </li>
     <li>
      在调用关键字 select 时，若一个 case 都没有，会直接触发；
     </li>
     <li>
      在 channel 进行读操作，会触发；
     </li>
     <li>
      在 channel 进行写操作，会触发；
     </li>
     <li>
      sleep 行为，会触发；
     </li>
     <li>
      IO 阻塞等待时，例如：网络请求等；
     </li>
     <li>
      在垃圾回收时，主要场景是 GC 标记终止和标记阶段时触发；
     </li>
     <li>
      GC 清扫阶段中的结束行为，会触发；
     </li>
     <li>
      信号量处理结束时，会触发；
     </li>
    </ul>
    <h2>
     <a id="_goroutine_147">
     </a>
     同时开启了一万个 goroutine，应该如何调度？
    </h2>
    <p>
     一万个 G 会按照 P 的设定个数，尽可能地平摊到每个 P 的
     <code>
      run_queue
     </code>
     当中。如果
     <code>
      run_queue
     </code>
     都满了，那么剩余的 G 会分配到 GMP 的全局队列上。完成将 G 分配到 P 的队列之后，便开始 GMP 模型的调度策略：
    </p>
    <ul>
     <li>
      <strong>
       本地队列轮转
      </strong>
      ：每一个 P 维护着一个包含 G 的队列
      <code>
       run_queue
      </code>
      ，也称本地队列，不考虑 G 进入系统调用或 I/O 的情况下，P 会周期性地将 G 调度到 M 中执行，执行一小段时间后（即并发），保存上下文并将这个 G 追加到队尾，再从对头取一个 G 调度。
     </li>
     <li>
      <strong>
       系统调用
      </strong>
      ：P 的个数默认等于 CPU 的核数，每个 M 必须持有一个 P 才能执行 G，一般 M 的个数会略大于 P，多出的 M 会在 G 产生系统调用时发挥作用。当 G 即将进入系统调用时，对应的 M 陷入系统调用而被阻塞，这将会使 M 释放 P，进而某个空闲的 M1 将获取 P，继续执行 P 队列剩下的 G。
     </li>
     <li>
      <strong>
       工作量窃取
      </strong>
      ：多个 P 的本地队列中维护的 G 的个数可能是不均衡的，当某个 P 已经执行完其队列中的 G 时，会去全局队列查找 G；如果全局队列也没有新的 G，而其它的某个 P 的本地队列还有很多 G 待运行，此时空闲的 P 会从其它 P 中偷一些 G 来执行，一般每次偷取一半。
     </li>
    </ul>
    <h2>
     <a id="goroutine__153">
     </a>
     goroutine 内存泄漏和处理？
    </h2>
    <p>
     <strong>
      原因
     </strong>
     ：
     <br/>
     goroutine 又称作协程，它是轻量级线程，由于 goroutine 完全运行在用户态，需要维护 goroutine 运行的上下文信息。因此，如果一个程序持续不断地产生新的 goroutine，且不结束已经创建的 goroutine 并复用这部分内存，就会产生内存泄露现象。产生内存泄露的原因大致分为以下三种：
    </p>
    <ul>
     <li>
      goroutine 内正在进行 channel/mutex 读写操作，但由于逻辑产生了问题，某些情况下 goroutine 被一直阻塞；
     </li>
     <li>
      goroutine 业务逻辑进入 dead loop，资源一直无法释放；
     </li>
     <li>
      goroutine 内的业务逻辑长时间等待，而此时又有不断新增的 goroutine 进入等待。
     </li>
    </ul>
    <p>
     <strong>
      解决办法
     </strong>
     ：
    </p>
    <ul>
     <li>
      使用 channel：使用 channel 接收业务完成的通知；业务执行阻塞超过设定的时间（可以通过 select 和
      <code>
       time.After()
      </code>
      来实现），就触发超时退出；
     </li>
     <li>
      使用 pprof 排查；
     </li>
    </ul>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f436f666665656d616b657238382f:61727469636c652f64657461696c732f313436313933363830" class_="artid" style="display:none">
 </p>
</div>


