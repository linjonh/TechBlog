---
layout: post
title: "网络编程-服务器多路复用IO-和-TCP并发模型"
date: 2025-03-07 21:03:25 +0800
description: "每次调用需要从用户态复制整个fd_set到内核态，时间复杂度O(n)限制（通常1024），超出会导致未定义行为。可以从客户端读取数据，也可以自身从键盘输入。"
keywords: "网络编程-----服务器（多路复用IO 和 TCP并发模型）"
categories: ['未分类']
tags: ['网络', '服务器', 'Tcp']
artid: "146104603"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146104603
    alt: "网络编程-服务器多路复用IO-和-TCP并发模型"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146104603
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146104603
cover: https://bing.ee123.net/img/rand?artid=146104603
image: https://bing.ee123.net/img/rand?artid=146104603
img: https://bing.ee123.net/img/rand?artid=146104603
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     网络编程-----服务器（多路复用IO 和 TCP并发模型）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     一、单循环服务器模型
    </h2>
    <h5>
     1. 核心特征
    </h5>
    <pre><code>while(1)
			{
				newfd = accept();
					recv();
				close(newfd);
			}
</code></pre>
    <h5>
     2. 典型应用场景
    </h5>
    <ul>
     <li>
      HTTP短连接服务（早期Apache）
     </li>
     <li>
      CGI快速处理
     </li>
     <li>
      简单测试服务器
     </li>
    </ul>
    <h5>
     3. 综合代码
    </h5>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;port&gt; &lt;ip&gt;\n",argv[0]);
		return -1;
	}
	

	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(atoi(argv[1]));
	seraddr.sin_addr.s_addr = inet_addr(argv[2]);
	printf("fd = %d\n",fd);
    //2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	printf("connect success!\n");

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}


	while (1)
	{
		//4.accept
		int connfd = accept(fd,NULL,NULL);

		if (connfd &lt; 0)
		{
			perror("accept fail");
			return -1;
		}

		printf("----client --- connectted\n");

		char buf[1024];
		char sbuf[1024];
		while (1)
		{
			recv(connfd,buf,sizeof(buf),0);
			printf("c: %s\n",buf);

			if (strncmp(buf,"quit",4) == 0)
			{
				close(connfd);
				break;
			}
			sprintf(sbuf,"server + %s\n",buf);
			send(connfd,sbuf,strlen(sbuf)+1,0);
		}
	}
	close(fd);

	return 0;
}
</code></pre>
    <h5>
     4. 优缺点分析
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        实现简单
       </td>
       <td>
        无法处理并发请求
       </td>
      </tr>
      <tr>
       <td>
        无资源竞争问题
       </td>
       <td>
        长连接会阻塞后续请求
       </td>
      </tr>
      <tr>
       <td>
        适合低负载场景
       </td>
       <td>
        吞吐量低（QPS &lt; 100）
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h2>
     二、多进程并发模型
    </h2>
    <h5>
     1. 核心实现
    </h5>
    <pre><code>while(1) {
    int newfd = accept(listen_fd, ...);
    pid_t pid = fork();
    
    if (pid == 0) {  // 子进程
        close(listen_fd);
        handle_connection(newfd);
        close(newfd);
        exit(0);
    } else if (pid &gt; 0) {  // 父进程
        close(newfd);
        waitpid(-1, NULL, WNOHANG);  // 非阻塞回收
    }
}
</code></pre>
    <h5>
     2. 进程管理优化
    </h5>
    <pre><code>// 使用信号处理避免僵尸进程
signal(SIGCHLD, SIG_IGN);  // 忽略子进程结束信号

// 或使用waitpid循环
while (waitpid(-1, NULL, WNOHANG) &gt; 0);
</code></pre>
    <h5>
     3. 典型应用
    </h5>
    <ul>
     <li>
      传统Apache的prefork模式
     </li>
     <li>
      FTP服务器
     </li>
     <li>
      数据库连接池
     </li>
    </ul>
    <h5>
     4. 资源消耗对比
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        资源类型
       </th>
       <th>
        进程创建开销
       </th>
       <th>
        示例系统调用
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        内存
       </td>
       <td>
        需要复制整个PCB
       </td>
       <td>
        fork()
       </td>
      </tr>
      <tr>
       <td>
        CPU
       </td>
       <td>
        上下文切换成本高
       </td>
       <td>
        schedule()
       </td>
      </tr>
      <tr>
       <td>
        文件描述符
       </td>
       <td>
        需要显式关闭继承的fd
       </td>
       <td>
        close()
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     5. 优缺点分析
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        可以完成多个进程的实时交互
       </td>
       <td>
        回收资源不方便
       </td>
      </tr>
      <tr>
       <td>
        信息的完整性可以保证。
       </td>
       <td>
        每次fork 占用系统资源多
       </td>
      </tr>
      <tr>
       <td>
        适合低负载场景
       </td>
       <td>
        可能出现僵尸进程
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     6. 综合代码
    </h4>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;

void handler(int signo)
{
	wait(NULL);
}


int init_server(const char *ip,unsigned short port)
{
	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(port);
	seraddr.sin_addr.s_addr = inet_addr(ip);

	//2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}
	return fd;
}


int client_handler(int connfd)
{
	char buf[1024];
	char sbuf[1024];
	int ret = 0;

	while (1)
	{
		ret = recv(connfd,buf,sizeof(buf),0);
		if (ret &lt; 0)
		{
			perror("client_handler recv fail");
			ret = -1;
		}
		printf("c: %s\n",buf);

		if (strncmp(buf,"quit",4) == 0)
		{
			close(connfd);
			ret = 1;
			break;
		}
		sprintf(sbuf,"server + %s\n",buf);
		ret = send(connfd,sbuf,strlen(sbuf)+1,0);
		if (ret &lt; 0)
		{
			perror("client_handler send fail");
			ret = -1;
		}
	}

	return ret;
	
}


int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;ip&gt; &lt;port&gt;\n",argv[0]);
		return -1;
	}
	
	signal(SIGCHLD,handler);

	int fd = init_server(argv[1],atoi(argv[2]));
	if (fd &lt; 0)
	{
		printf("init_server fail\n");
		return -1;
	}

	while (1)
	{
		//4.accept
		int connfd = accept(fd,NULL,NULL);

		if (connfd &lt; 0)
		{
			perror("accept fail");
			return -1;
		}

		pid_t pid = fork();
		if (pid &lt; 0)
		{
			perror("fork fail");
			return -1;
		}
		if (pid == 0)
		{

			int ret = 0;
			if ((ret = client_handler(connfd)) &lt; 0)
			{
				printf("client_handler fail");
				return -1;
			}
			if (ret == 1)
			{
				printf("child exit...\n");
				exit(EXIT_SUCCESS);
			}
 
		}
	}
	close(fd);

	return 0;
}
</code></pre>
    <h2>
     三、多线程并发模型
    </h2>
    <h5>
     1. 核心实现（POSIX线程）
    </h5>
    <pre><code>while(1) {
    int newfd = accept(listen_fd, ...);
    pthread_t tid;
    pthread_create(&amp;tid, NULL, thread_handler, (void*)newfd);
    pthread_detach(tid);  // 分离线程自动回收
}

void* thread_handler(void* arg) {
    int fd = (int)arg;
    // 处理请求
    close(fd);
    return NULL;
}
</code></pre>
    <h5>
     2. 线程安全控制
    </h5>
    <pre><code>// 使用互斥锁保护共享资源
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void safe_write(int fd, const char* data) {
    pthread_mutex_lock(&amp;lock);
    write(fd, data, strlen(data));
    pthread_mutex_unlock(&amp;lock);
}
</code></pre>
    <h5>
     3. 典型应用
    </h5>
    <ul>
     <li>
      Java Tomcat
     </li>
     <li>
      IIS应用池
     </li>
     <li>
      实时通信服务器
     </li>
    </ul>
    <h5>
     4. 性能指标对比
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        指标
       </th>
       <th>
        进程模型
       </th>
       <th>
        线程模型
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        创建速度
       </td>
       <td>
        慢（10-100ms）
       </td>
       <td>
        快（0.1-1ms）
       </td>
      </tr>
      <tr>
       <td>
        上下文切换成本
       </td>
       <td>
        高（切换页表等）
       </td>
       <td>
        低（共享地址空间）
       </td>
      </tr>
      <tr>
       <td>
        内存占用
       </td>
       <td>
        高（独立资源）
       </td>
       <td>
        低（共享资源）
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     5. 优缺点分析
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        可以完成多个进程的实时交互
       </td>
       <td>
        线程共享进程资源
       </td>
      </tr>
      <tr>
       <td>
        创建速度快，调度快
       </td>
       <td>
        稳定性 较差
       </td>
      </tr>
      <tr>
       <td>
        适合低负载场景
       </td>
       <td>
        安全性 较差
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     6. 综合代码
    </h4>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;errno.h&gt;

int init_server(const char *ip,unsigned short port)
{
	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(port);
	seraddr.sin_addr.s_addr = inet_addr(ip);

	//2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}
	return fd;
}


void* client_handler(void *arg)
{
	int connfd = *(int *)arg;
	char buf[1024];
	char sbuf[1024];
	long int ret = 0;
	

	while (1)
	{
		ret = recv(connfd,buf,sizeof(buf),0);
		if (ret &lt; 0)
		{
			perror("client_handler recv fail");
			ret = -1;
		}
		printf("c: %s\n",buf);

		if (strncmp(buf,"quit",4) == 0)
		{
			close(connfd);
			ret = 1;
			break;
		}
		sprintf(sbuf,"server + %s\n",buf);
		ret = send(connfd,sbuf,strlen(sbuf)+1,0);
		if (ret &lt; 0)
		{
			perror("client_handler send fail");
			ret = -1;
		}
	}

	return (void*)ret;
	
}


int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;ip&gt; &lt;port&gt;\n",argv[0]);
		return -1;
	}
	

	int fd = init_server(argv[1],atoi(argv[2]));
	if (fd &lt; 0)
	{
		printf("init_server fail\n");
		return -1;
	}

	while (1)
	{
		//4.accept
		int connfd = accept(fd,NULL,NULL);

		if (connfd &lt; 0)
		{
			perror("accept fail");
			return -1;
		}
		
		pthread_t tid;

		int ret = pthread_create(&amp;tid,NULL,client_handler,&amp;connfd);
		if(ret != 0)
		{
			errno = ret;
			perror("pthread_create fail");
			return -1;
		}
		pthread_detach(tid);//设置分离属性,由系统回收资源
	}
	close(fd);
	return 0;
}
</code></pre>
    <hr/>
    <h2>
     四、并发的服务器模型 ---更高程度上的并发
    </h2>
    <h3>
     <code>
      （一）fcntl
     </code>
     函数与 I/O 模型详解
    </h3>
    <h5>
     1. 函数原型
    </h5>
    <pre><code>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int fcntl(int fd, int cmd, ... /* arg */ );
</code></pre>
    <h5>
     2. 主要操作类型
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        命令
       </th>
       <th>
        功能描述
       </th>
       <th>
        参数要求
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         F_DUPFD
        </code>
       </td>
       <td>
        复制文件描述符
       </td>
       <td>
        指定最小可用fd值
       </td>
      </tr>
      <tr>
       <td>
        <code>
         F_GETFD/F_SETFD
        </code>
       </td>
       <td>
        获取/设置文件描述符标志
       </td>
       <td>
        标志值
       </td>
      </tr>
      <tr>
       <td>
        <code>
         F_GETFL/F_SETFL
        </code>
       </td>
       <td>
        获取/设置文件状态标志
       </td>
       <td>
        新标志值
       </td>
      </tr>
      <tr>
       <td>
        <code>
         F_GETOWN/F_SETOWN
        </code>
       </td>
       <td>
        获取/设置异步I/O所有权
       </td>
       <td>
        进程ID或组ID
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     （二）非阻塞I/O设置示例
    </h3>
    <h5>
     1. 设置流程
    </h5>
    <pre><code class="language-cpp">int flag = fcntl(connfd,F_GETFL,0);
		flag = flag | O_NONBLOCK;
		fcntl(connfd,F_SETFL,flag);</code></pre>
    <h5>
     2. 行为变化对比
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        操作
       </th>
       <th>
        阻塞模式
       </th>
       <th>
        非阻塞模式
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         read()
        </code>
       </td>
       <td>
        阻塞直到数据到达
       </td>
       <td>
        立即返回，无数据时返回
        <code>
         EAGAIN
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         write()
        </code>
       </td>
       <td>
        阻塞直到缓冲区空间可用
       </td>
       <td>
        立即返回，空间不足返回
        <code>
         EAGAIN
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         accept()
        </code>
       </td>
       <td>
        阻塞直到有新连接
       </td>
       <td>
        立即返回，无连接时返回
        <code>
         EAGAIN
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h3>
     （三）I/O 模型对比
    </h3>
    <h5>
     1. 阻塞I/O模型
    </h5>
    <h5>
     <img alt="" height="467" src="https://i-blog.csdnimg.cn/direct/64b3bc8940ca4e018b88544d75534347.png" width="865"/>
    </h5>
    <h5>
     2. 非阻塞I/O模型
    </h5>
    <p>
     <img alt="" height="488" src="https://i-blog.csdnimg.cn/direct/06601d20b8f54ede9ba250780e8c57dc.png" width="865"/>
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;fcntl.h&gt;
int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;port&gt; &lt;ip&gt;\n",argv[0]);
		return -1;
	}
	

	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(atoi(argv[1]));
	seraddr.sin_addr.s_addr = inet_addr(argv[2]);
	printf("fd = %d\n",fd);
    //2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	printf("connect success!\n");

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}


	while (1)
	{
		//4.accept
		int connfd = accept(fd,NULL,NULL);

		if (connfd &lt; 0)
		{
			perror("accept fail");
			return -1;
		}

		printf("----client --- connectted\n");

		char buf[1024];
		char sbuf[1024];
	
		int flag = fcntl(connfd,F_GETFL,0);
		flag = flag | O_NONBLOCK;
		fcntl(connfd,F_SETFL,flag);
		
		while (1)
		{
			recv(connfd,buf,sizeof(buf),0);
			printf("c: %s\n",buf);

			if (strncmp(buf,"quit",4) == 0)
			{
				close(connfd);
				break;
			}
			sprintf(sbuf,"server + %s\n",buf);
			send(connfd,sbuf,strlen(sbuf)+1,0);
		}
	}
	close(fd);

	return 0;
}
</code></pre>
    <h3>
     （四）信号驱动 I/O 详解
    </h3>
    <p>
     <img alt="" height="546" src="https://i-blog.csdnimg.cn/direct/8ef457aeeb9d4ad388c6ffca52e84119.png" width="865"/>
    </p>
    <h5>
     1. 设置异步标志
    </h5>
    <pre><code>// 获取当前文件状态标志
int flags = fcntl(fd, F_GETFL);
if (flags == -1) {
    perror("fcntl F_GETFL");
    exit(EXIT_FAILURE);
}

// 添加异步I/O标志
if (fcntl(fd, F_SETFL, flags | O_ASYNC) == -1) {
    perror("fcntl F_SETFL");
    exit(EXIT_FAILURE);
}
</code></pre>
    <h5>
     2. 指定信号接收者
    </h5>
    <pre><code>// 设置当前进程为信号接收者
if (fcntl(fd, F_SETOWN, getpid()) == -1) {
    perror("fcntl F_SETOWN");
    exit(EXIT_FAILURE);
}
</code></pre>
    <h5>
     3. 注册信号处理函数
    </h5>
    <pre><code>// 更安全的sigaction替代signal
struct sigaction sa;
sa.sa_flags = SA_RESTART;
sa.sa_handler = sigio_handler;
sigemptyset(&amp;sa.sa_mask);

if (sigaction(SIGIO, &amp;sa, NULL) == -1) {
    perror("sigaction");
    exit(EXIT_FAILURE);
}
</code></pre>
    <h5>
     4. 基本处理逻辑
    </h5>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;

int g_fd;

void handler(int signo)
{
	char buf[1024];
	read(g_fd,buf,sizeof(buf));

	if (strncmp(buf,"quit",4) == 0)
		return;
	printf("buf = %s\n",buf);

}

int main(int argc, const char *argv[])
{
	if (mkfifo(argv[1],0666) &lt; 0 &amp;&amp; errno != EEXIST)
	{
		perror("mkfifo fail");
		return -1;
	}

	printf("mkfifo success\n");

	int fd = open(argv[1], O_RDONLY);
	if (fd &lt; 0)
	{
		perror("open fail");
		return -1;
	}

	g_fd = fd;
	int flag = fcntl(fd,F_GETFL,0);
	flag = flag | O_ASYNC;//设置为异步通信
	fcntl(fd,F_SETFL,flag);

	fcntl(fd,F_SETOWN,getpid());//所有者
	signal(SIGIO,handler);

	int i = 0;
	while (1)
	{
		printf("i = %d\n",i);
		sleep(1);
		++i;
	}

	close(fd);
	return 0;
}
</code></pre>
    <hr/>
    <h5>
     5.核心局限性分析
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        问题类型
       </th>
       <th>
        具体表现
       </th>
       <th>
        解决思路
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        信号合并
       </td>
       <td>
        快速连续信号可能被合并
       </td>
       <td>
        使用实时信号（SIGRTMIN+）
       </td>
      </tr>
      <tr>
       <td>
        多fd区分困难
       </td>
       <td>
        无法直接判断哪个fd触发信号
       </td>
       <td>
        每个fd绑定不同信号（不现实）
       </td>
      </tr>
      <tr>
       <td>
        异步安全限制
       </td>
       <td>
        信号处理函数中操作受限
       </td>
       <td>
        仅设置标志，主循环处理
       </td>
      </tr>
      <tr>
       <td>
        性能瓶颈
       </td>
       <td>
        高频率信号导致CPU占用高
       </td>
       <td>
        配合epoll使用
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     <code>
      （五）select
     </code>
     函数详解
    </h3>
    <p>
     <img alt="" height="471" src="https://i-blog.csdnimg.cn/direct/d51372d9420f40f4bda7e1c6d099df66.png" width="865"/>
    </p>
    <h4>
     一、函数原型与参数解析
    </h4>
    <pre><code>#include &lt;sys/select.h&gt;

int select(int nfds, 
           fd_set *readfds, 
           fd_set *writefds,
           fd_set *exceptfds, 
           struct timeval *timeout);
</code></pre>
    <h5>
     参数说明
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        参数
       </th>
       <th>
        类型
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         nfds
        </code>
       </td>
       <td>
        <code>
         int
        </code>
       </td>
       <td>
        监控的文件描述符最大值 +1（优化内核检查范围）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         readfds
        </code>
       </td>
       <td>
        <code>
         fd_set*
        </code>
       </td>
       <td>
        监控可读事件的描述符集合（可NULL）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         writefds
        </code>
       </td>
       <td>
        <code>
         fd_set*
        </code>
       </td>
       <td>
        监控可写事件的描述符集合（可NULL）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         exceptfds
        </code>
       </td>
       <td>
        <code>
         fd_set*
        </code>
       </td>
       <td>
        监控异常事件的描述符集合（可NULL）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         timeout
        </code>
       </td>
       <td>
        <code>
         timeval*
        </code>
       </td>
       <td>
        超时时间：&lt;br&gt;• NULL：阻塞等待&lt;br&gt;• 0：立即返回&lt;br&gt;• 正数：定时等待
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     返回值
    </h5>
    <ul>
     <li>
      <strong>
       成功
      </strong>
      ：返回就绪的文件描述符总数（可能为0）
     </li>
     <li>
      <strong>
       失败
      </strong>
      ：返回-1并设置
      <code>
       errno
      </code>
     </li>
     <li>
      <strong>
       超时
      </strong>
      ：返回0
     </li>
    </ul>
    <hr/>
    <h4>
     二、核心操作宏
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        宏
       </th>
       <th>
        功能
       </th>
       <th>
        示例
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         FD_ZERO
        </code>
       </td>
       <td>
        清空描述符集合
       </td>
       <td>
        <code>
         FD_ZERO(&amp;read_fds);
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         FD_SET
        </code>
       </td>
       <td>
        添加描述符到集合
       </td>
       <td>
        <code>
         FD_SET(sockfd, &amp;read_fds);
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         FD_CLR
        </code>
       </td>
       <td>
        从集合中移除描述符
       </td>
       <td>
        <code>
         FD_CLR(sockfd, &amp;read_fds);
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         FD_ISSET
        </code>
       </td>
       <td>
        检测描述符是否在集合中
       </td>
       <td>
        <code>
         if(FD_ISSET(sockfd, &amp;read_fds))
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     三、典型使用流程
    </h4>
    <h5>
     1. 初始化描述符集合
    </h5>
    <pre><code>fd_set read_fds;
FD_ZERO(&amp;read_fds);
FD_SET(listen_fd, &amp;read_fds);
int max_fd = listen_fd;
</code></pre>
    <h5>
     2. 等待事件就绪
    </h5>
    <pre><code>struct timeval tv = {5, 0}; // 5秒超时
fd_set tmp_fds = read_fds;

int ready = select(max_fd + 1, &amp;tmp_fds, NULL, NULL, &amp;tv);
if (ready == -1) {
    if (errno == EINTR) continue; // 处理信号中断
    perror("select error");
    break;
} else if (ready == 0) {
    printf("Timeout\n");
    continue;
}
</code></pre>
    <h5>
     3. 处理就绪事件
    </h5>
    <pre><code>for (int fd = 0; fd &lt;= max_fd; fd++) {
    if (FD_ISSET(fd, &amp;tmp_fds)) {
        if (fd == listen_fd) {
            // 处理新连接
            int new_fd = accept(listen_fd, ...);
            FD_SET(new_fd, &amp;read_fds);
            max_fd = (new_fd &gt; max_fd) ? new_fd : max_fd;
        } else {
            // 处理客户端数据
            ssize_t n = read(fd, ...);
            if (n &lt;= 0) {
                close(fd);
                FD_CLR(fd, &amp;read_fds);
            }
        }
    }
}
</code></pre>
    <hr/>
    <h4>
     四、关键注意事项
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        集合重用问题
       </strong>
       <br/>
       select返回后，集合会被修改为就绪的fd集合，每次调用前必须重新初始化：
      </p>
      <pre><code>fd_set tmp_fds = read_fds; // 使用临时集合
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        超时时间重置
       </strong>
       <br/>
       <code>
        timeout
       </code>
       参数会被修改为剩余时间，循环调用时需要重新设置：
      </p>
      <pre><code>struct timeval tv = {5, 0};
while(1) {
    select(..., &amp;tv);
    tv.tv_sec = 5; // 必须重置
}
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        最大fd限制
       </strong>
       <br/>
       受
       <code>
        FD_SETSIZE
       </code>
       限制（通常1024），超出会导致未定义行为
      </p>
     </li>
     <li>
      <p>
       <strong>
        性能问题
       </strong>
       <br/>
       每次调用需要从用户态复制整个fd_set到内核态，时间复杂度O(n)
      </p>
     </li>
    </ol>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
int main(int argc, const char *argv[])
{
	if (mkfifo(argv[1],0666) &lt; 0 &amp;&amp; errno != EEXIST)
	{
		perror("mkfifo fail");
		return -1;
	}

	printf("mkfifo success\n");

	int fd = open(argv[1], O_RDONLY);
	if (fd &lt; 0)
	{
		perror("open fail");
		return -1;
	}
	char buf[1024] = {0};

	//1.建表
	fd_set readfds;
	FD_ZERO(&amp;readfds);

	//2.添加要关心的fd
	FD_SET(0,&amp;readfds);
	FD_SET(fd,&amp;readfds);

	//3.select函数监控
	fd_set backfds;
		
		struct timeval tv = {5,0};
	while(1)
	{
		backfds = readfds;//每次循环回来拿到的都是最原始数据
		int nfds = fd + 1;//因为另一个是0,所以最大也就是ｆｄ
		int ret = select(nfds,&amp;backfds,NULL,NULL,&amp;tv);
		if(ret &lt; 0)
		{
			perror("select fail");
			return -1;
		}
		if(ret &gt; 0)
		{
			for(int i = 0;i &lt; nfds;i++)//也可以是1024,但没必要 
			{
				if(FD_ISSET(i,&amp;backfds))
				{
					if(i == 0)
					{
						fgets(buf,sizeof(buf),stdin);
						if (strncmp(buf,"quit",4) == 0)
							break;
						printf("buf = %s\n",buf);
					}else if(i == fd)
					{
						read(fd,buf,sizeof(buf));
						if (strncmp(buf,"quit",4) == 0)
							break;
						printf("buf = %s\n",buf);
					}
				}
			}
		}
	}
	
	close(fd);
	return 0;
}
</code></pre>
    <p>
     可以从客户端读取数据，也可以自身从键盘输入
    </p>
    <h3>
     <img alt="" height="315" src="https://i-blog.csdnimg.cn/direct/8966cb34f18744f6a1d92c67e4053871.png" width="865"/>
    </h3>
    <p>
     tcp多客户端连接到服务器
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/select.h&gt;

int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;port&gt; &lt;ip&gt;\n",argv[0]);
		return -1;
	}


	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(atoi(argv[1]));
	seraddr.sin_addr.s_addr = inet_addr(argv[2]);
	printf("fd = %d\n",fd);
	//2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	printf("connect success!\n");

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}


	//1.准备表 
	fd_set readfds;
	FD_ZERO(&amp;readfds);

	//2.添加要监控的fd
	FD_SET(fd,&amp;readfds);
	int connfd = 0;

	fd_set backfds;
	int i = 0;
	int nfds = fd + 1;
	while (1)
	{
		backfds = readfds;
		int ret = select(nfds,&amp;backfds,NULL,NULL,NULL);

		if (ret &lt; 0)
		{
			perror("select fail");
			return -1;
		}

		if (ret &gt; 0)
		{
			for (i = 0; i &lt; nfds; ++i)
			{

				if (FD_ISSET(i,&amp;backfds))
				{
					if (i == fd)
					{
						//4.accept
						connfd = accept(fd,NULL,NULL);

						if (connfd &lt; 0)
						{
							perror("accept fail");
							return -1;
						}

						FD_SET(connfd,&amp;readfds);
						nfds = nfds &gt; connfd + 1 ? nfds:connfd + 1;
					}else 
					{
						char buf[1024];
						char sbuf[1024];
						recv(i,buf,sizeof(buf),0);
						printf("c: %s\n",buf);

						if (strncmp(buf,"quit",4) == 0)
						{	
							close(i);
							FD_CLR(i,&amp;readfds); 
						}
						sprintf(sbuf,"server + %s\n",buf);
						send(i,sbuf,strlen(sbuf)+1,0);

					}
				}
			}
		}

	}
	close(fd);

	return 0;
}
</code></pre>
    <h3>
     并发模型对比
    </h3>
    <table>
     <thead>
      <tr>
       <th>
        模型
       </th>
       <th>
        实现方式
       </th>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        多进程
       </td>
       <td>
        <code>
         fork()
        </code>
       </td>
       <td>
        隔离性好
       </td>
       <td>
        资源消耗大
       </td>
      </tr>
      <tr>
       <td>
        多线程
       </td>
       <td>
        <code>
         pthread_create()
        </code>
       </td>
       <td>
        资源共享高效
       </td>
       <td>
        同步复杂度高
       </td>
      </tr>
      <tr>
       <td>
        I/O多路复用
       </td>
       <td>
        <code>
         select/poll/epoll
        </code>
       </td>
       <td>
        高并发低开销
       </td>
       <td>
        编程复杂度较高
       </td>
      </tr>
      <tr>
       <td>
        信号驱动
       </td>
       <td>
        <code>
         SIGIO
        </code>
        +
        <code>
         fcntl
        </code>
       </td>
       <td>
        实时性好
       </td>
       <td>
        信号处理复杂
       </td>
      </tr>
      <tr>
       <td>
        异步I/O
       </td>
       <td>
        <code>
         aio_*
        </code>
        系列函数
       </td>
       <td>
        真正的异步操作
       </td>
       <td>
        系统支持不统一
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <h3>
     <code>
      （六）epoll
     </code>
    </h3>
    <p>
     <img alt="" height="388" src="https://i-blog.csdnimg.cn/direct/ec2ae769f26241598eb4b60a29932db5.png" width="865"/>
    </p>
    <hr/>
    <h4>
     一、核心函数解析
    </h4>
    <h5>
     1.
     <strong>
      <code>
       epoll_create
      </code>
      ：创建 epoll 实例
     </strong>
    </h5>
    <pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size);
</code></pre>
    <ul>
     <li>
      <strong>
       参数
      </strong>
      ：
      <ul>
       <li>
        <code>
         size
        </code>
        ：内核初始分配数据结构的建议值（Linux 2.6.8+ 后忽略，但需 &gt; 0）
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回值
      </strong>
      ：
      <ul>
       <li>
        成功：epoll 文件描述符 (
        <code>
         epfd
        </code>
        )
       </li>
       <li>
        失败：-1，设置
        <code>
         errno
        </code>
       </li>
      </ul>
     </li>
     <li>
      <strong>
       注意
      </strong>
      ：
      <ul>
       <li>
        需手动调用
        <code>
         close(epfd)
        </code>
        释放资源
       </li>
       <li>
        典型用法：
        <code>
         epoll_create1(0)
        </code>
        （更推荐，支持
        <code>
         EPOLL_CLOEXEC
        </code>
        标志）
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h5>
     2.
     <strong>
      <code>
       epoll_ctl
      </code>
      ：管理监控列表
     </strong>
    </h5>
    <pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre>
    <ul>
     <li>
      <p>
       <strong>
        操作类型
       </strong>
       (
       <code>
        op
       </code>
       )：
      </p>
      <table>
       <thead>
        <tr>
         <th>
          操作
         </th>
         <th>
          说明
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          <code>
           EPOLL_CTL_ADD
          </code>
         </td>
         <td>
          添加 fd 到监控列表（重复添加报
          <code>
           EEXIST
          </code>
          错误）
         </td>
        </tr>
        <tr>
         <td>
          <code>
           EPOLL_CTL_MOD
          </code>
         </td>
         <td>
          修改已注册 fd 的事件（未注册的 fd 报
          <code>
           ENOENT
          </code>
          错误）
         </td>
        </tr>
        <tr>
         <td>
          <code>
           EPOLL_CTL_DEL
          </code>
         </td>
         <td>
          从监控列表删除 fd（内核会忽略 event 参数）
         </td>
        </tr>
       </tbody>
      </table>
     </li>
     <li>
      <p>
       <strong>
        事件结构
       </strong>
       ：
      </p>
      <pre><code>struct epoll_event {
    uint32_t     events;  // 监控的事件类型（位掩码）
    epoll_data_t data;    // 用户数据（可携带 fd、指针等）
};

typedef union epoll_data {
    void    *ptr;
    int      fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
</code></pre>
     </li>
    </ul>
    <hr/>
    <h5>
     3.
     <strong>
      <code>
       epoll_wait
      </code>
      ：等待事件就绪
     </strong>
    </h5>
    <pre><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
</code></pre>
    <ul>
     <li>
      <strong>
       参数
      </strong>
      ：
      <ul>
       <li>
        <code>
         events
        </code>
        ：输出参数，存储就绪事件数组
       </li>
       <li>
        <code>
         maxevents
        </code>
        ：最多返回的事件数量（需 ≤ 数组长度）
       </li>
       <li>
        <code>
         timeout
        </code>
        ：超时时间（ms），-1 表示阻塞，0 表示立即返回
       </li>
      </ul>
     </li>
     <li>
      <strong>
       返回值
      </strong>
      ：
      <ul>
       <li>
        成功：就绪事件数量
       </li>
       <li>
        超时：0
       </li>
       <li>
        错误：-1，设置
        <code>
         errno
        </code>
       </li>
      </ul>
     </li>
    </ul>
    <hr/>
    <h4>
     二、事件类型与触发模式
    </h4>
    <h5>
     1.
     <strong>
      基础事件类型
     </strong>
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        事件类型
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         EPOLLIN
        </code>
       </td>
       <td>
        数据可读（包括对端关闭）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         EPOLLOUT
        </code>
       </td>
       <td>
        数据可写（注意：可能触发虚假就绪）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         EPOLLRDHUP
        </code>
       </td>
       <td>
        对端关闭连接或关闭写方向（需内核 ≥ 2.6.17）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         EPOLLPRI
        </code>
       </td>
       <td>
        紧急数据可读（如 TCP 带外数据）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         EPOLLERR
        </code>
       </td>
       <td>
        错误条件（自动监控，无需手动设置）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         EPOLLHUP
        </code>
       </td>
       <td>
        挂起（如管道对端关闭，自动监控）
       </td>
      </tr>
     </tbody>
    </table>
    <h5>
     2.
     <strong>
      高级控制标志
     </strong>
    </h5>
    <table>
     <thead>
      <tr>
       <th>
        标志
       </th>
       <th>
        说明
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         EPOLLET
        </code>
       </td>
       <td>
        边沿触发模式（默认水平触发 LT）
       </td>
      </tr>
      <tr>
       <td>
        <code>
         EPOLLONESHOT
        </code>
       </td>
       <td>
        单次触发，事件处理后需用
        <code>
         EPOLL_CTL_MOD
        </code>
        重新激活
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     三、触发模式对比
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        特性
       </th>
       <th>
        水平触发 (LT)
       </th>
       <th>
        边沿触发 (ET)
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         触发条件
        </strong>
       </td>
       <td>
        只要缓冲区有数据/空间就会触发
       </td>
       <td>
        仅在缓冲区状态变化时触发一次
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数据读取
        </strong>
       </td>
       <td>
        可部分读取，下次仍会触发
       </td>
       <td>
        必须一次性读取到
        <code>
         EAGAIN
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         性能
        </strong>
       </td>
       <td>
        适合低频大块数据
       </td>
       <td>
        适合高频高并发场景
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         实现复杂度
        </strong>
       </td>
       <td>
        简单
       </td>
       <td>
        需配合非阻塞 I/O 和循环读写
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         适用场景
        </strong>
       </td>
       <td>
        简单交互、文件传输
       </td>
       <td>
        实时通信、高并发服务器
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     实例：
    </h4>
    <p>
     基于
     <code>
      epoll
     </code>
     的简单 TCP 服务器，可以同时处理多个客户端连接
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;sys/epoll.h&gt;

// 将文件描述符添加到 epoll 实例中
int add_fd(int epfd,int fd)
{
	struct epoll_event ev;
	ev.events = EPOLLIN;// 监听可读事件
	ev.data.fd = fd;// 设置文件描述符


	if(epoll_ctl(epfd,EPOLL_CTL_ADD,fd,&amp;ev) &lt; 0)
	{
		perror("epoll_ctl fail");
		return -1;
	}
	return 0;
}
// 从 epoll 实例中删除文件描述符
int del_fd(int epfd,int fd)
{
	struct epoll_event ev;
	ev.events = EPOLLIN;
	ev.data.fd = fd;

	if(epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;ev) &lt; 0)
	{
		perror("epoll_ctl fail");
		return -1;
	}
	return 0;
}


int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;port&gt; &lt;ip&gt;\n",argv[0]);
		return -1;
	}


	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(atoi(argv[1]));
	seraddr.sin_addr.s_addr = inet_addr(argv[2]);
	//2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	printf("connect success!\n");

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}


	//1.准备表 
	int epfd = epoll_create(2);
	if(epfd &lt; 0)
	{
		perror("epoll_create fail");
		return -1;
	}

	//2.添加要监控的fd
	add_fd(epfd,fd); // 添加监听 socket 到 epoll
	int connfd = 0;

	struct epoll_event result[1024];// 保存 epoll_wait 返回的事件
	int maxevents = 1024;//指定 epoll_wait 函数最多可以返回的事件数量。
	int ret = 0;
	int i = 0;

	int tm = 3000;//3s
	while (1)
	{// 等待 epoll 事件
		ret = epoll_wait(epfd,result,maxevents,tm);

		if (ret &lt; 0)
		{
			perror("epoll_wait fail");
			return -1;
		}else if (ret == 0) {
			printf("epoll_wait timeout\n");//处理超时
		}else if(ret &gt; 0)
		{
			for (i = 0; i &lt; ret; ++i)
			{
				// 如果是监听 socket 有事件，说明有新连接
				if (result[i].data.fd == fd)//作用为监听的fd
				{
					//4.accept
					connfd = accept(fd,NULL,NULL);

					if (connfd &lt; 0)
					{
						perror("accept fail");
						return -1;
					}
					// 将新连接的 socket 添加到 epoll
					add_fd(epfd,connfd);
				}else //通信的fd
				{
					// 处理客户端数据
					connfd = result[i].data.fd;//取触发事件的文件描述符
					char buf[1024];
					char sbuf[1024];
					recv(connfd,buf,sizeof(buf),0);
					printf("c: %s\n",buf);

					if (strncmp(buf,"quit",4) == 0)
					{	
						del_fd(epfd,connfd);
						close(connfd);
						continue;
					}
					sprintf(sbuf,"server + %s\n",buf);
					send(connfd,sbuf,strlen(sbuf)+1,0);
				}
			}
		}

	}
	close(fd);

	return 0;
}
</code></pre>
    <p>
     基于 epoll 的简单 TCP 服务器，可以同时处理多个客户端连接（边沿触发模式）
    </p>
    <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;	       /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
#include &lt;arpa/inet.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

// 将文件描述符添加到 epoll 实例中
int add_fd(int epfd,int fd)
{
	struct epoll_event ev;
	ev.events = EPOLLIN|EPOLLET;// 监听可读事件，并使用边缘触发模式
	ev.data.fd = fd;// 设置文件描述符


	if(epoll_ctl(epfd,EPOLL_CTL_ADD,fd,&amp;ev) &lt; 0)
	{
		perror("epoll_ctl fail");
		return -1;
	}
	return 0;
}
// 从 epoll 实例中删除文件描述符
int del_fd(int epfd,int fd)
{
	struct epoll_event ev;
	ev.events = EPOLLIN;
	ev.data.fd = fd;

	if(epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;ev) &lt; 0)
	{
		perror("epoll_ctl fail");
		return -1;
	}
	return 0;
}
// 设置文件描述符为非阻塞模式
void set_nonblock(int fd)
{
	int flag = fcntl(fd,F_GETFL,0);// 获取当前文件状态标志
	flag = flag|O_NONBLOCK;// 设置非阻塞标志
	fcntl(fd,F_SETFL,flag);// 更新文件状态标志
}

int main(int argc, const char *argv[])
{
	if (argc != 3)
	{
		printf("Usage: %s &lt;port&gt; &lt;ip&gt;\n",argv[0]);
		return -1;
	}


	//1.socket 创建通信一端 
	int fd = socket(AF_INET,SOCK_STREAM,0);

	if (fd &lt; 0)
	{
		perror("socket fail\n");
		return -1;
	}

	struct sockaddr_in seraddr;
	bzero(&amp;seraddr,sizeof(seraddr));

	seraddr.sin_family = AF_INET;
	seraddr.sin_port = htons(atoi(argv[1]));
	seraddr.sin_addr.s_addr = inet_addr(argv[2]);
	//2.bind -- 绑定服务器端的地址信息 
	if (bind(fd,(const struct sockaddr*)&amp;seraddr,sizeof(seraddr)) &lt; 0)
	{
		perror("connect fail");
		return -1;
	}

	printf("connect success!\n");

	//3.listen -- 设置监听 
	if (listen(fd,5) &lt; 0)
	{
		perror("listen fail");
		return -1;
	}


	//1.准备表 
	int epfd = epoll_create(2);
	if(epfd &lt; 0)
	{
		perror("epoll_create fail");
		return -1;
	}

	//2.添加要监控的fd
// 添加监听 socket 到 epoll，并设置为非阻塞模式
	add_fd(epfd,fd); 
	set_nonblock(fd);

	int connfd = 0;

	struct epoll_event result[1024];// 保存 epoll_wait 返回的事件
	int maxevents = 1024;//指定 epoll_wait 函数最多可以返回的事件数量。
	int ret = 0;
	int i = 0;

	int tm = 3000;//3s
	while (1)
	{// 等待 epoll 事件
		ret = epoll_wait(epfd,result,maxevents,tm);

		if (ret &lt; 0)
		{
			perror("epoll_wait fail");
			return -1;
		}else if (ret == 0) {
			printf("epoll_wait timeout\n");//处理超时
		}else if(ret &gt; 0)
		{
			for (i = 0; i &lt; ret; ++i)
			{
				// 如果是监听 socket 有事件，说明有新连接
				if (result[i].data.fd == fd)//作用为监听的fd
				{
					//4.accept
					connfd = accept(fd,NULL,NULL);

					if (connfd &lt; 0)
					{
						perror("accept fail");
						return -1;
					}
					set_nonblock(connfd);// 设置新连接为非阻塞模式
					// 将新连接的 socket 添加到 epoll
					add_fd(epfd,connfd);
				}else //通信的fd
				{
					// 处理客户端数据
					connfd = result[i].data.fd;//取触发事件的文件描述符
					char buf[1024];
					char sbuf[1024];

					while(1)
					{
						ret = recv(connfd,buf,1,0);
						printf("c: %s\n",buf);

						if(ret &lt; 0)
						{
							if(errno == EWOULDBLOCK||errno == EAGAIN)
								break;// 非阻塞模式下，没有更多数据可读
						}
						if (strncmp(buf,"quit",4) == 0)
						{	
							del_fd(epfd,connfd);
							close(connfd);
							continue;
						}
						sprintf(sbuf,"server + %s\n",buf);
						send(connfd,sbuf,strlen(sbuf)+1,0);
					}
				}
			}
		}

	}
	close(fd);

	return 0;
}
</code></pre>
    <p>
    </p>
    <h3>
     （七）select、poll、epoll 的比较
    </h3>
    <p>
     <strong>
      select 的缺点：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       select 监听文件描述符最大个数为 1024。
      </p>
     </li>
     <li>
      <p>
       select 监听的文件描述符集合在用户层，需要应用层和内核层互相传递数据。
      </p>
     </li>
     <li>
      <p>
       select 需要循环遍历一次才能找到产生的事件。
      </p>
     </li>
     <li>
      <p>
       select 只能工作在水平触发模式（低速模式），无法工作在边沿触发模式（高速模式）。
      </p>
     </li>
    </ol>
    <p>
     <strong>
      poll 的缺点：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       poll 监听文件描述符不受上限限制。
      </p>
     </li>
     <li>
      <p>
       poll 监听的文件描述符集合在用户层，需要内核层向用户层传递数据。
      </p>
     </li>
     <li>
      <p>
       poll 需要循环遍历一次才能找到产生的事件。
      </p>
     </li>
     <li>
      <p>
       poll 只能工作在水平触发模式（低速模式），无法工作在边沿触发模式（高速模式）。
      </p>
     </li>
    </ol>
    <p>
     <strong>
      epoll 的优点：
     </strong>
    </p>
    <ol>
     <li>
      <p>
       epoll 创建内核事件表，不受到文件描述符上限限制。
      </p>
     </li>
     <li>
      <p>
       epoll 监听的事件表在内核中，直接在内核中监测事件效率高。
      </p>
     </li>
     <li>
      <p>
       epoll 会直接获得产生事件的文件描述符的信息，而不需要遍历检测。
      </p>
     </li>
     <li>
      <p>
       epoll 既能工作在水平触发模式，也能工作在边沿触发模式。
      </p>
     </li>
    </ol>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343338323937302f:61727469636c652f64657461696c732f313436313034363033" class_="artid" style="display:none">
 </p>
</div>


