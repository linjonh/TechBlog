---
layout: post
title: "算法与数据结构最长回文子串"
date: 2025-03-08 14:32:38 +0800
description: "这个题可以用中心扩展法。遍历每个可能的中心点，然后向两边扩展，记录最长的回文子串。这样可以覆盖所有可能的奇数长度和偶数长度的回文情况。首先可以写一个扩展函数，返回值的类型为pair<int,int>。若left和right在字符串s的范围内且s[left] == s[right]则扩展一位(left--,right++)。最后返回满足条件的子串的范围。这个是用来求两种情况：子串长度为1，子串长度为2。若比end-start的长度长，则更新start和end的值。"
keywords: "算法与数据结构（最长回文子串）"
categories: ['未分类']
tags: ['数据结构']
artid: "146114748"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146114748
    alt: "算法与数据结构最长回文子串"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146114748
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146114748
cover: https://bing.ee123.net/img/rand?artid=146114748
image: https://bing.ee123.net/img/rand?artid=146114748
img: https://bing.ee123.net/img/rand?artid=146114748
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     算法与数据结构（最长回文子串）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     题目
    </h2>
    <p>
     <img alt="" height="671" src="https://i-blog.csdnimg.cn/direct/b4196050ee5646b6b0d669ee6103dd83.png" width="899"/>
    </p>
    <h2>
     思路
    </h2>
    <p>
     这个题可以用中心扩展法。遍历每个可能的中心点，然后向两边扩展，记录最长的回文子串。这样可以覆盖所有可能的奇数长度和偶数长度的回文情况。
    </p>
    <p>
     首先可以写一个扩展函数，返回值的类型为pair&lt;int,int&gt;。
    </p>
    <p>
     若left和right在字符串s的范围内且s[left] == s[right]则扩展一位(left--,right++)。
    </p>
    <p>
     最后返回满足条件的子串的范围。
    </p>
    <pre><code class="language-cpp">auto [left1,right1] = expand(s,i,i);
auto [left2,right2] = expand(s,i,i+1);</code></pre>
    <p>
     这个是用来求两种情况：子串长度为1，子串长度为2。
    </p>
    <p>
     若比end-start的长度长，则更新start和end的值。
    </p>
    <pre><code class="language-cpp">return s.substr(start,end-start+1);</code></pre>
    <p>
     这个函数是用来求s字符串从位置start开始，长度为end-start+1的子串。
    </p>
    <h2>
     代码
    </h2>
    <pre><code class="language-cpp">class Solution {
public:
    pair&lt;int,int&gt; expand(string s, int left, int right)
    {
        //从中间向两边扩展
        while(left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])
        {
            left--;
            right++;
        }
        return {left+1,right-1};
    }
    string longestPalindrome(string s) 
    {
        int start=0,end=0;
        for(int i=0; i&lt;s.size();i++)
        {
            auto [left1,right1] = expand(s,i,i);
            auto [left2,right2] = expand(s,i,i+1);
            if(right1 - left1 &gt; end - start)
            {
                start = left1;
                end = right1;
            }
            if(right2 - left2 &gt; end - start)
            {
                start = left2;
                end = right2;
            }
        }
        return s.substr(start,end-start+1);
    }
};</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f615f6a35382f:61727469636c652f64657461696c732f313436313134373438" class_="artid" style="display:none">
 </p>
</div>


