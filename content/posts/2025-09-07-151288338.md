---
layout: post
title: "SpringMVC-入门详解-MVC-思想附核心流程"
date: 2025-09-07T15:06:52+0800
description: "SpringMVC 入门指南：MVC思想与核心流程 SpringMVC是Java EE表述层开发的首选框架，基于MVC设计模式，实现了请求处理、业务逻辑和视图展示的分离。文章首先解释了MVC思想，将软件分为Model（处理业务和数据）、View（用户界面）和Controller（请求调度）三大组件。通过用户登录示例展示了MVC的工作流程。 作为Spring家族的一员，SpringMVC提供了完整的表述层解决方案，替代传统Servlet开发，支持RESTful接口、文件上传等功能。其核心特点是： 与Sprin"
keywords: "SpringMVC 入门详解： MVC 思想（附核心流程）"
categories: ['未分类']
tags: ['后端', 'Mvc', 'Java']
artid: "151288338"
arturl: "https://blog.csdn.net/m0_60277481/article/details/151288338"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=151288338
    alt: "SpringMVC-入门详解-MVC-思想附核心流程"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=151288338
featuredImagePreview: https://bing.ee123.net/img/rand?artid=151288338
cover: https://bing.ee123.net/img/rand?artid=151288338
image: https://bing.ee123.net/img/rand?artid=151288338
img: https://bing.ee123.net/img/rand?artid=151288338
---



# SpringMVC 入门详解： MVC 思想（附核心流程）



## SpringMVC 入门详解： MVC 思想（附核心流程）

在 Java 后端开发中，“表述层”（也就是和前端交互的部分）是项目的 “门面”—— 用户的请求要靠它接收，处理结果要靠它返回。而 **SpringMVC** 就是目前 Java EE 表述层开发的 “首选方案”，几乎所有中大型 Java 项目都会用到它。

这篇文章从基础的 MVC 思想讲起，带你搞懂 SpringMVC 是什么、它的核心逻辑，最后再用一个简单案例上手实战，新手也能轻松理解。

### 一、先搞懂 MVC：软件架构的 “分工思维”

在学 SpringMVC 之前，得先明白它的 “源头”——MVC 思想。MVC 不是技术，而是一种 “分工合作” 的软件设计思路，目的是让代码职责更清晰、更好维护。

#### 1. 什么是 MVC？

MVC 是 **Model（模型）、View（视图）、Controller（控制器）** 的缩写，它把软件分成 3 个部分，每个部分负责不同的工作：

* 「视图」负责 “展示”：给用户看的页面（比如 HTML、JSP）；
* 「控制器」负责 “调度”：接收用户请求，安排谁来处理；
* 「模型」负责 “干活”：处理业务逻辑、操作数据（比如计算价格、查数据库）。

简单说：MVC 就是让 “展示、调度、干活” 分开，避免代码全堆在一起（比如早期 JSP 里又写 HTML 又写 Java 代码，乱得没法维护）。

#### 2. MVC 的 3 个核心角色（职责要分清）

##### （1）Model（模型层）：“干活的人”

对应工程里的 **JavaBean**，专门处理数据和业务逻辑，分两类：

* **实体类 Bean**：存数据的 “容器”，比如 User（存用户名、密码）、Order（存订单号、金额），字段和数据库表字段对应；
* **业务处理 Bean**：干具体活的，比如 UserService（处理用户登录、注册逻辑）、OrderDao（操作订单数据的增删改查）。

##### （2）View（视图层）：“展示的窗口”

对应工程里的 **HTML、JSP、Vue 页面** 等，负责和用户交互：

* 接收用户输入（比如表单填写）；
* 展示处理结果（比如页面显示用户信息、订单列表）。

##### （3）Controller（控制层）：“调度的管家”

对应工程里的 **Servlet**（早期）或 SpringMVC 的 @Controller 类，负责 “承上启下”：

* 接收用户从 View 发来的请求（比如点击 “登录” 按钮）；
* 调用 Model 层处理请求（比如让 UserService 验证账号密码）；
* 把处理结果交给 View 展示（比如登录成功跳首页，失败提示错误）。

#### 3. MVC 工作流程（通俗版）

用 “用户登录” 举个例子，一步一步看 MVC 怎么协作：

1. 用户在登录页面（View）输入账号密码，点击 “登录”；
2. 请求被 Controller（比如 LoginController）接收；
3. Controller 调用 Model 层的 UserService，让它验证账号密码；
4. UserService 调用 UserDao 查数据库，确认账号密码是否正确，返回结果给 Controller；
5. Controller 拿到结果：如果正确，让 View 跳转到首页；如果错误，让 View 显示 “账号密码错误”；
6. View 把最终结果展示给用户。

### 二、SpringMVC 是什么：Spring 家族的 “表述层专家”

了解了 MVC，再看 SpringMVC 就简单了 —— 它是 Spring 家族专门为 “表述层” 设计的框架，是 MVC 思想的 “落地实现”，而且和 Spring 无缝整合（不用额外写一堆配置）。

#### 1. SpringMVC 的定义

SpringMVC 是 Spring 的子项目，为 Java EE 表述层提供**全套解决方案**：

* 解决 “接收请求、处理请求、返回响应” 的全流程问题；
* 替代早期的 Servlet（不用每个请求写一个 Servlet，代码量锐减）；
* 支持 RESTful 接口、文件上传下载、拦截器、异常统一处理等常用功能。

#### 2. 三层架构中的 SpringMVC（定位要明确）

我们常说的 “三层架构”（表述层、业务逻辑层、数据访问层），SpringMVC 就是 “表述层” 的核心：

| 三层架构 | 职责 | 对应技术 / 组件 |
| --- | --- | --- |
| 表述层（展示层） | 接收请求、返回响应 | SpringMVC、HTML、Vue |
| 业务逻辑层 | 处理核心业务（比如订单计算） | Spring Service（@Service） |
| 数据访问层 | 操作数据库（增删改查） | MyBatis、Spring Data JPA |

简单说：用户的请求先到 SpringMVC（表述层），再传给 Service（业务层），最后到 Dao（数据层）；处理结果反向返回，最终由 SpringMVC 响应给用户。

### 三、SpringMVC 的核心特点：为什么大家都选它？

SpringMVC 能成为主流，靠的是它 “好用、灵活、能扛住大项目” 的特点，每一个都戳中开发者的痛点：

#### 1. Spring 家族原生产品：无缝整合

和 Spring IOC 容器（管理 Bean 的核心）天生兼容，不用额外做整合配置。比如在 SpringMVC 的 @Controller 里，直接用 @Autowired 注入 Spring 的 @Service Bean，开箱即用：

```java
@Controller // SpringMVC 控制器
public class UserController {
    // 直接注入 Spring 业务层 Bean，不用额外配置
    @Autowired
    private UserService userService;
}

```

#### 2. 前端控制器：DispatcherServlet（“调度中心”）

这是 SpringMVC 的 “核心大脑”，所有用户请求都先经过它，再由它统一分配给其他组件处理。不用像早期 Servlet 那样，每个请求写一个 XXXServlet（比如登录写 LoginServlet，注册写 RegisterServlet），代码量大大减少。

简单理解：DispatcherServlet 就像公司的 “前台”，所有访客（请求）先找前台，前台再告诉 TA 该找哪个部门（组件）处理。

#### 3. 功能全覆盖：不用找第三方

表述层需要的功能，SpringMVC 基本都自带，不用额外引入其他框架：

* 路由映射：@RequestMapping 注解轻松配置请求路径；
* 参数绑定：自动把请求参数（比如表单数据）转成 Java 对象；
* 视图解析：自动找到要渲染的页面（JSP/HTML）；
* 异常处理：@ControllerAdvice 统一处理所有控制器的异常；
* 文件上传：MultipartFile 轻松处理文件上传。

#### 4. 代码简洁：注解驱动开发

用注解替代传统 XML 配置，几行代码就能写一个接口。比如下面这个控制器，不用写任何 XML，就能处理 /user/login 请求：

```java
@Controller
public class UserController {
    // 配置请求路径：/user/login，处理 POST 请求
    @PostMapping("/user/login")
    // 请求参数自动绑定到 User 对象
    public String login(User user) {
        // 调用业务层处理登录
        boolean success = userService.login(user);
        // 登录成功跳首页，失败跳登录页
        return success ? "index" : "login";
    }
}

```

#### 5. 性能优秀：适合大型项目

内部组件化程度高，可插拔（比如不想用默认的视图解析器，自己配一个就行），而且基于原生 Servlet 开发，性能损耗小，能扛住超大型互联网项目的并发（比如电商平台的订单接口）。

### 四、SpringMVC 核心工作流程（请求 “走流程” 的全过程）

前面说的 DispatcherServlet 是核心，那一个请求从进来，到 SpringMVC 处理完返回，具体走了哪些步骤？

1. **用户发请求**：比如在浏览器输入 http://localhost:8080/user/login，请求先到 Tomcat 服务器，再传给 SpringMVC 的 DispatcherServlet；
2. **DispatcherServlet 找 “路由表”**：它会问「处理器映射器（HandlerMapping）」：“/user/login 这个路径对应哪个 Controller？”，处理器映射器返回对应的 Controller 信息（比如 UserController 的 login 方法）；
3. **DispatcherServlet 找 “执行者”**：它再问「处理器适配器（HandlerAdapter）」：“怎么调用这个 Controller 的 login 方法？”，处理器适配器会按照 SpringMVC 的规则，准备好调用参数；
4. **调用 Controller 处理请求**：处理器适配器调用 UserController 的 login 方法，Controller 会调用 UserService 处理业务逻辑（比如查数据库验证账号）；
5. **返回处理结果**：Controller 处理完，返回一个 ModelAndView 对象（包含 “数据” 和 “要展示的页面”，比如数据是用户信息，页面是 index.jsp）；
6. **DispatcherServlet 找 “页面解析器”**：它把 ModelAndView 传给「视图解析器（ViewResolver）」，视图解析器找到实际的页面路径（比如把 index 解析成 /WEB-INF/views/index.jsp）；
7. **渲染视图**：视图解析器把页面和数据结合，生成最终的 HTML 页面；
8. **响应给用户**：DispatcherServlet 把 HTML 页面返回给浏览器，用户看到首页。

简单画个流程图，更直观：

```
用户请求 → DispatcherServlet → 处理器映射器 → 处理器适配器 → Controller → ModelAndView → 视图解析器 → 渲染视图 → 响应用户

```

### 五、总结：SpringMVC 的核心价值

SpringMVC 之所以成为 Java 表述层的 “王者”，核心在于它解决了开发者的实际痛点：

* 「解耦」：把请求接收、业务处理、视图展示分开，代码更易维护；
* 「简洁」：注解驱动开发，几行代码就能写一个接口，不用堆 XML；
* 「整合」：和 Spring 无缝对接，不用额外做兼容；
* 「全能」：从参数绑定到异常处理，从文件上传到 RESTful 接口，功能全满足；
* 「能扛」：性能优秀，支持大型项目高并发。

如果你是 Java 后端开发者，SpringMVC 是必须掌握的核心框架 —— 它不仅是面试高频考点，更是实际工作中每天都会用到的 “工具”。后续可以深入学习它的拦截器、异常统一处理、RESTful 风格优化等高级功能，让接口设计更专业。



