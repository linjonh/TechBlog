---
layout: post
title: "Linux线程控制"
date: 2025-03-16 21:42:23 +0800
description: "这里的“轻量级进程”通常指的是用户态线程（User-Level Thread），即由用户程序和库函数管理的线程，而不是由内核直接管理的线程。之前使用的pthread_self得到的这个数实际上是一个地址，在虚拟地址空间上的一个地址，通过这个地址，可以找到关于这个线程的基本信息，包括线程ID，线程栈，寄存器属性等。打印出来的tid是通过pthread库中有函数pthread_self得到的，它返回一个pthread_t类型的变量，指代的是调用pthread_self函数的线程的\"ID\"。"
keywords: "Linux线程控制"
categories: ['未分类']
tags: ['Linux', 'Jvm']
artid: "146301042"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146301042
    alt: "Linux线程控制"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146301042
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146301042
cover: https://bing.ee123.net/img/rand?artid=146301042
image: https://bing.ee123.net/img/rand?artid=146301042
img: https://bing.ee123.net/img/rand?artid=146301042
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Linux线程控制
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     1.POSIX线程库
    </h2>
    <p>
     与线程有关的函数构成了一个完整系列，绝大多数函数的名字都是以"phread_"打头的
    </p>
    <p>
     要使用这些函数库，要通过引入同文件&lt;pthread.h&gt;
    </p>
    <p>
     链接这些线程函数时要使用编译器命令的"-lpthread"选项
    </p>
    <h3>
     创建线程
    </h3>
    <blockquote>
     <p>
      #include &lt;pthread.h&gt;
      <br/>
      int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         pthread_t *thread
        </code>
       </strong>
       ：指向线程标识符的指针，线程创建成功后，线程标识符会被存储在这个位置。线程标识符在当前进程范围内是唯一的，用于后续对线程的操作，如等待线程结束等。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         const pthread_attr_t *attr
        </code>
       </strong>
       ：指向线程属性结构的指针。线程属性结构可以设置线程的一些特性，如线程的分离状态、堆栈大小、优先级等。如果传入
       <code>
        NULL
       </code>
       ，则使用默认属性创建线程。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         void *(*start_routine)(void*)
        </code>
       </strong>
       ：指定线程启动时要执行的函数，即线程的入口函数。这个函数必须接受一个
       <code>
        void*
       </code>
       类型的参数，并返回一个
       <code>
        void*
       </code>
       类型的值。线程创建后，会自动调用这个函数，并将
       <code>
        arg
       </code>
       参数传递给它。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         void *arg
        </code>
       </strong>
       ：传递给线程入口函数的参数。如果线程入口函数需要接收多个参数，可以通过将这些参数打包成一个结构体，然后将结构体的指针传递给线程入口函数。
      </p>
     </li>
    </ul>
    <div>
     <span style="color:#646a73">
      传统的⼀些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指⽰错误
     </span>
    </div>
    <div>
    </div>
    <div>
     <strong>
      <span style="color:#646a73">
       代码示例
      </span>
     </strong>
    </div>
    <div>
     <pre><code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
void *rout(void *arg) {
    int i;
    for( ; ; ) {
        printf("I'am thread 1\n");
        sleep(1);
    }
}
int main( void )
{
    pthread_t tid;
    int ret;
    if ( (ret=pthread_create(&amp;tid, NULL, rout, NULL)) != 0 ) {
        fprintf(stderr, "pthread_create : %s\n", strerror(ret));
        exit(EXIT_FAILURE);
    }
    int i;
    for(; ; ) {
        printf("I'am main thread\n");
        sleep(1);
    }   
}</code></pre>
     <p>
      <img alt="" height="372" src="https://i-blog.csdnimg.cn/direct/fc7a7a48725d422d8766650f2a3925a3.png" width="744"/>
     </p>
    </div>
    <p>
    </p>
    <p>
    </p>
    <h3>
     获取线程ID
    </h3>
    <blockquote>
     <p>
      #include &lt;pthread.h&gt;
      <br/>
      pthread_t pthread_self(void);
     </p>
    </blockquote>
    <p>
     打印出来的tid是通过pthread库中有函数pthread_self得到的，它返回一个pthread_t类型的变量，指代的是调用pthread_self函数的线程的"ID"。
    </p>
    <p>
     这个ID是pthread库给每个线程定义的进程内唯一标识，是pthread库维持的。由于每个进程有自己的独立的内存空间，所以这个ID的作用域是进程级而非系统级(内核不认识)。
    </p>
    <p>
     pthread库也是通过内核提供的系统调用(如clone)来创建线程的，而内核会为每个线程创建系统全局唯一的ID来唯一标识这个线程。
    </p>
    <blockquote>
     <p>
      clone函数
     </p>
     <p>
      #include &lt;sched.h&gt;
      <br/>
      int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);
     </p>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       <p>
        <strong>
         <code>
          pthread_self
         </code>
         返回的
         <code>
          pthread_t
         </code>
         ID
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          由 pthread 库分配，作用域是
          <strong>
           进程级
          </strong>
          。
         </p>
        </li>
        <li>
         <p>
          用于 pthread 库内部管理和用户程序中的线程操作。
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        <strong>
         内核分配的线程 PID
        </strong>
        ：
       </p>
       <ul>
        <li>
         <p>
          由内核分配，作用域是
          <strong>
           系统级
          </strong>
          。
         </p>
        </li>
        <li>
         <p>
          用于内核调度和资源管理。
         </p>
        </li>
       </ul>
      </li>
     </ul>
     <p>
      在实际开发中，根据需求选择合适的 ID。例如：
     </p>
     <ul>
      <li>
       <p>
        如果需要在 pthread 库中操作线程（如等待线程结束），使用
        <code>
         pthread_t
        </code>
        ID。
       </p>
      </li>
      <li>
       <p>
        如果需要与内核交互（如在日志中记录线程的唯一标识），使用线程的 PID。
       </p>
      </li>
     </ul>
     <p>
     </p>
    </blockquote>
    <p>
     <img alt="" height="214" src="https://i-blog.csdnimg.cn/direct/93e86e6459c64f21bcc7d1dc6c7c4d5c.png" width="592">
     </img>
    </p>
    <p>
     LWP得到的是真正的线程ID。之前使用的pthread_self得到的这个数实际上是一个地址，在虚拟地址空间上的一个地址，通过这个地址，可以找到关于这个线程的基本信息，包括线程ID，线程栈，寄存器属性等。
    </p>
    <p>
    </p>
    <div>
     <span style="color:#1f2329">
      在
     </span>
     <span style="color:#1f2329">
      ps -aL
     </span>
     <span style="color:#1f2329">
      得到的线程ID，有⼀个线程ID和进程ID相同，这个线程就是主线程，主线程的栈在虚拟
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      地址空间的栈上，⽽其他线程的栈在是在共享区（堆栈之间），因为pthread系列函数都是pthread库
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      提供给我们的。⽽pthread库是在共享区的。所以除了主线程之外的其他线程的栈都在共享区。
     </span>
    </div>
    <p>
    </p>
    <h3>
     线程等待
    </h3>
    <blockquote>
     <p>
      #include &lt;pthread.h&gt;
      <br/>
      int pthread_join(pthread_t thread, void **retval);
     </p>
    </blockquote>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         pthread_t thread
        </code>
       </strong>
       ：要等待的线程的标识符。这个标识符是通过
       <code>
        pthread_create
       </code>
       函数创建线程时获得的。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         void **retval
        </code>
       </strong>
       ：一个指向
       <code>
        void
       </code>
       指针的指针，用于存储线程的返回值。如果不需要获取线程的返回值，这个参数可以设置为
       <code>
        NULL
       </code>
       。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="341" src="https://i-blog.csdnimg.cn/direct/5b969f84ee0d4cb5934ea35cfba17681.png" width="1026"/>
    </p>
    <p>
     <strong>
      补充
     </strong>
    </p>
    <blockquote>
     <p>
      图片中的内容讨论了Linux系统中线程和进程的概念，具体内容如下：
     </p>
     <p>
      <strong>
       1. **Linux提供的系统调用**：
      </strong>
      <br/>
      - 图片中提到Linux系统只提供创建轻量级进程的系统调用。这里的“轻量级进程”通常指的是用户态线程（User-Level Thread），即由用户程序和库函数管理的线程，而不是由内核直接管理的线程。
     </p>
     <p>
      <strong>
       2. **Linux中的线程概念**：
      </strong>
      <br/>
      - 图片中指出，在Linux系统中，实际上并不存在真正意义上的线程。这是因为Linux使用轻量级进程来模拟线程的行为。轻量级进程是一种用户态线程，它由用户程序和库函数（如pthread库）管理，而不是由内核直接管理。
      <br/>
      - 在Linux中，所有的线程都是通过克隆（clone）系统调用来创建的，这些线程在内核中被视为轻量级进程。轻量级进程共享同一个进程的地址空间和其他资源，但每个轻量级进程都有自己的栈和线程控制块（Thread Control Block, TCB）。
     </p>
     <p>
      <strong>
       3. **操作系统中的进程和线程**：
      </strong>
      <br/>
      - 图片中提到，在操作系统（OS）中，只有轻量级进程，所谓的模拟线程是我们的说法。这意味着在Linux中，线程是通过轻量级进程来模拟实现的，而这些轻量级进程在内核中被视为独立的进程实体。
      <br/>
      - 这种模拟线程的方法允许用户程序以线程的方式进行编程，同时利用轻量级进程的高效性和灵活性。
     </p>
     <p>
      总结来说，图片中的内容强调了Linux系统中线程是通过轻量级进程来模拟实现的，而这些轻量级进程在内核中被视为独立的进程实体。这种方法允许用户程序以线程的方式进行编程，同时利用轻量级进程的高效性和灵活性。
     </p>
    </blockquote>
    <p>
     <img alt="" height="175" src="https://i-blog.csdnimg.cn/direct/54bcee8308584065b35218f56393617b.png" width="401"/>
    </p>
    <p>
    </p>
    <p>
     <strong>
      代码示例
     </strong>
    </p>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

int flag = 100;

void showtid(pthread_t &amp;tid)
{
    printf("tid: 0x%lx\n", tid);
}

std::string FormatId(const pthread_t &amp;tid)
{
    char id[64];
    snprintf(id, sizeof(id), "0x%lx", tid);
    return id;
}
// code done, result ok
// code done, result not ok
// code no finish
void *routine(void *args)
{
    std::string name = static_cast&lt;const char *&gt;(args);
    pthread_t tid = pthread_self();
    int cnt = 5;
    while (cnt)
    {
        std::cout &lt;&lt; "我是一个新线程: 我的名字是: " &lt;&lt; name &lt;&lt; " 我的Id是: " &lt;&lt; FormatId(tid) &lt;&lt; std::endl;
        sleep(1);
        cnt--;
        flag++;
    }
    return (void*)123;// 暂时：线程退出的时候的退出码
}

int main()
{
    pthread_t tid;
    int n = pthread_create(&amp;tid, nullptr, routine, (void *)"thread-1");

    showtid(tid);

    int cnt = 5;
    while (cnt)
    {
        std::cout &lt;&lt; "我是main线程: 我的名字是: main thread" &lt;&lt; " 我的Id是: " 
            &lt;&lt; FormatId(pthread_self()) &lt;&lt; ", flag: " &lt;&lt; flag &lt;&lt; std::endl;
        sleep(1);
        cnt--;
    }

    void *ret = nullptr; // ret也是一个变量！！也有空间哦！

    // 等待的目标线程，如果异常了，整个进程都退出了，包括main线程，所以，join异常，没有意义，看也看不到！
    // jion都是基于：线程健康跑完的情况，不需要处理异常信号，异常信号，是进程要处理的话题！！！
    pthread_join(tid, &amp;ret); // 为什么在join的时候，没有见到异常相关的字段呢？？

    std::cout &lt;&lt; "ret is : " &lt;&lt; (long long int)ret &lt;&lt; std::endl;

    return 0;
}</code></pre>
    <p>
     <img alt="" height="945" src="https://i-blog.csdnimg.cn/direct/621593aaa43c4437a175914292adbcd5.png" width="667"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="1137" src="https://i-blog.csdnimg.cn/direct/e8d3d5cece0e46f8baa239e121740490.png" width="704"/>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="457" src="https://i-blog.csdnimg.cn/direct/2fcb2db654204992a77f2443fe9d2b9f.png" width="684">
     </img>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303337383130372f:61727469636c652f64657461696c732f313436333031303432" class_="artid" style="display:none">
 </p>
</div>


