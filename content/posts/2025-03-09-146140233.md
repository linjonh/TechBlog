---
arturl_encode: "68747470733a2f:2f626c6f672e6373646e2e6e65742f4368656e374368616e2f:61727469636c652f64657461696c732f313436313430323333"
layout: post
title: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—27-å‰ç«¯éŸ³è§†é¢‘å¤„ç†"
date: 2025-03-09 22:32:32 +08:00
description: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ä¹‹æ—…ç¬¬äºŒåä¸ƒç«™"
keywords: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ27ï¼‰--å‰ç«¯éŸ³è§†é¢‘å¤„ç†"
categories: ['å‰ç«¯å·¥ç¨‹åŒ–ä¸æ¡†æ¶']
tags: ['éŸ³è§†é¢‘', 'çŠ¶æ€æ¨¡å¼', 'å‰ç«¯']
artid: "146140233"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146140233
    alt: "å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—27-å‰ç«¯éŸ³è§†é¢‘å¤„ç†"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146140233
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146140233
cover: https://bing.ee123.net/img/rand?artid=146140233
image: https://bing.ee123.net/img/rand?artid=146140233
img: https://bing.ee123.net/img/rand?artid=146140233
---

# å·¥ç¨‹åŒ–ä¸æ¡†æ¶ç³»åˆ—ï¼ˆ27ï¼‰--å‰ç«¯éŸ³è§†é¢‘å¤„ç†

## å‰ç«¯éŸ³è§†é¢‘å¤„ç† ğŸ¥

### å¼•è¨€

å‰ç«¯éŸ³è§†é¢‘å¤„ç†æ˜¯ç°ä»£Webåº”ç”¨ä¸­çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæ¶‰åŠéŸ³é¢‘æ’­æ”¾ã€è§†é¢‘å¤„ç†ã€æµåª’ä½“ä¼ è¾“ç­‰å¤šä¸ªæ–¹é¢ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å‰ç«¯éŸ³è§†é¢‘å¤„ç†çš„å…³é”®æŠ€æœ¯å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºé«˜è´¨é‡çš„å¤šåª’ä½“åº”ç”¨ã€‚

### éŸ³è§†é¢‘æŠ€æœ¯æ¦‚è¿°

å‰ç«¯éŸ³è§†é¢‘å¤„ç†ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹æŠ€æœ¯æ–¹å‘ï¼š

* **éŸ³é¢‘å¤„ç†**
  ï¼šéŸ³é¢‘æ’­æ”¾ã€å½•åˆ¶ã€åˆ†æ
* **è§†é¢‘å¤„ç†**
  ï¼šè§†é¢‘æ’­æ”¾ã€å½•åˆ¶ã€ç¼–è¾‘
* **æµåª’ä½“**
  ï¼šå®æ—¶éŸ³è§†é¢‘ã€ç›´æ’­æ¨æµ
* **WebRTC**
  ï¼šç‚¹å¯¹ç‚¹é€šä¿¡
* **åª’ä½“æ ¼å¼**
  ï¼šç¼–è§£ç ã€è½¬æ¢

### éŸ³é¢‘å¤„ç†å®ç°

#### éŸ³é¢‘æ’­æ”¾å™¨

```typescript
// éŸ³é¢‘æ’­æ”¾å™¨ç±»
class AudioPlayer {
    private audio: HTMLAudioElement;
    private audioContext: AudioContext;
    private source: MediaElementAudioSourceNode;
    private analyser: AnalyserNode;
    private gainNode: GainNode;
    private equalizer: EqualizerNode;
    
    constructor() {
        this.audio = new Audio();
        this.audioContext = new AudioContext();
        
        // åˆ›å»ºéŸ³é¢‘æº
        this.source = this.audioContext.createMediaElementSource(this.audio);
        
        // åˆ›å»ºåˆ†æå™¨
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 2048;
        
        // åˆ›å»ºéŸ³é‡æ§åˆ¶
        this.gainNode = this.audioContext.createGain();
        
        // åˆ›å»ºå‡è¡¡å™¨
        this.equalizer = new EqualizerNode(this.audioContext);
        
        // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
        this.source
            .connect(this.analyser)
            .connect(this.equalizer.input)
            .connect(this.gainNode)
            .connect(this.audioContext.destination);
        
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        this.initializeEventListeners();
    }
    
    // åŠ è½½éŸ³é¢‘
    loadAudio(url: string): Promise<void> {
        return new Promise((resolve, reject) => {
            this.audio.src = url;
            this.audio.load();
            
            this.audio.oncanplaythrough = () => resolve();
            this.audio.onerror = () => reject(new Error('Failed to load audio'));
        });
    }
    
    // æ’­æ”¾
    play(): Promise<void> {
        return this.audio.play();
    }
    
    // æš‚åœ
    pause(): void {
        this.audio.pause();
    }
    
    // è·³è½¬åˆ°æŒ‡å®šæ—¶é—´
    seek(time: number): void {
        this.audio.currentTime = time;
    }
    
    // è®¾ç½®éŸ³é‡
    setVolume(volume: number): void {
        this.gainNode.gain.value = Math.max(0, Math.min(1, volume));
    }
    
    // è®¾ç½®å‡è¡¡å™¨
    setEqualizerBand(frequency: number, gain: number): void {
        this.equalizer.setBand(frequency, gain);
    }
    
    // è·å–é¢‘è°±æ•°æ®
    getSpectrumData(): Uint8Array {
        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteFrequencyData(dataArray);
        return dataArray;
    }
    
    // è·å–æ³¢å½¢æ•°æ®
    getWaveformData(): Uint8Array {
        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteTimeDomainData(dataArray);
        return dataArray;
    }
    
    // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
    private initializeEventListeners(): void {
        // æ’­æ”¾çŠ¶æ€å˜åŒ–
        this.audio.addEventListener('play', () => {
            this.audioContext.resume();
        });
        
        // éŸ³é¢‘ç»“æŸ
        this.audio.addEventListener('ended', () => {
            // å¤„ç†æ’­æ”¾ç»“æŸ
        });
        
        // éŸ³é¢‘é”™è¯¯
        this.audio.addEventListener('error', (e) => {
            console.error('Audio error:', e);
        });
    }
}

// å‡è¡¡å™¨èŠ‚ç‚¹ç±»
class EqualizerNode {
    private context: AudioContext;
    private bands: BiquadFilterNode[];
    private _input: GainNode;
    private _output: GainNode;
    
    constructor(context: AudioContext) {
        this.context = context;
        this.bands = [];
        
        // åˆ›å»ºè¾“å…¥è¾“å‡ºèŠ‚ç‚¹
        this._input = context.createGain();
        this._output = context.createGain();
        
        // åˆ›å»ºå‡è¡¡å™¨é¢‘æ®µ
        this.createBands();
        
        // è¿æ¥é¢‘æ®µ
        this.connectBands();
    }
    
    // è·å–è¾“å…¥èŠ‚ç‚¹
    get input(): AudioNode {
        return this._input;
    }
    
    // è·å–è¾“å‡ºèŠ‚ç‚¹
    get output(): AudioNode {
        return this._output;
    }
    
    // è®¾ç½®é¢‘æ®µå¢ç›Š
    setBand(frequency: number, gain: number): void {
        const band = this.bands.find(b => 
            Math.abs(b.frequency.value - frequency) < 1
        );
        
        if (band) {
            band.gain.value = gain;
        }
    }
    
    // åˆ›å»ºå‡è¡¡å™¨é¢‘æ®µ
    private createBands(): void {
        const frequencies = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000];
        
        frequencies.forEach(freq => {
            const filter = this.context.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.value = freq;
            filter.Q.value = 1;
            filter.gain.value = 0;
            
            this.bands.push(filter);
        });
    }
    
    // è¿æ¥é¢‘æ®µ
    private connectBands(): void {
        this.bands.reduce((prev, curr) => {
            prev.connect(curr);
            return curr;
        }, this._input);
        
        this.bands[this.bands.length - 1].connect(this._output);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const player = new AudioPlayer();

// åŠ è½½å¹¶æ’­æ”¾éŸ³é¢‘
async function playAudio(url: string) {
    try {
        await player.loadAudio(url);
        await player.play();
        
        // è®¾ç½®éŸ³é‡
        player.setVolume(0.8);
        
        // è®¾ç½®å‡è¡¡å™¨
        player.setEqualizerBand(60, 3); // å¢å¼ºä½é¢‘
        player.setEqualizerBand(12000, 2); // å¢å¼ºé«˜é¢‘
        
        // å®æ—¶æ›´æ–°é¢‘è°±æ˜¾ç¤º
        function updateSpectrum() {
            const spectrumData = player.getSpectrumData();
            // ä½¿ç”¨é¢‘è°±æ•°æ®ç»˜åˆ¶å¯è§†åŒ–æ•ˆæœ
            requestAnimationFrame(updateSpectrum);
        }
        
        updateSpectrum();
        
    } catch (error) {
        console.error('Failed to play audio:', error);
    }
}

```

#### éŸ³é¢‘å½•åˆ¶å™¨

```typescript
// éŸ³é¢‘å½•åˆ¶å™¨ç±»
class AudioRecorder {
    private stream: MediaStream | null;
    private mediaRecorder: MediaRecorder | null;
    private audioChunks: Blob[];
    private isRecording: boolean;
    
    constructor() {
        this.stream = null;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.isRecording = false;
    }
    
    // è¯·æ±‚éº¦å…‹é£æƒé™
    async requestPermission(): Promise<void> {
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({
                audio: true
            });
        } catch (error) {
            throw new Error('Failed to get microphone permission');
        }
    }
    
    // å¼€å§‹å½•åˆ¶
    startRecording(): void {
        if (!this.stream) {
            throw new Error('No audio stream available');
        }
        
        this.audioChunks = [];
        this.mediaRecorder = new MediaRecorder(this.stream);
        
        this.mediaRecorder.addEventListener('dataavailable', (event) => {
            if (event.data.size > 0) {
                this.audioChunks.push(event.data);
            }
        });
        
        this.mediaRecorder.start();
        this.isRecording = true;
    }
    
    // åœæ­¢å½•åˆ¶
    stopRecording(): Promise<Blob> {
        return new Promise((resolve, reject) => {
            if (!this.mediaRecorder || !this.isRecording) {
                reject(new Error('Not recording'));
                return;
            }
            
            this.mediaRecorder.addEventListener('stop', () => {
                const audioBlob = new Blob(this.audioChunks, {
                    type: 'audio/webm'
                });
                resolve(audioBlob);
            });
            
            this.mediaRecorder.stop();
            this.isRecording = false;
        });
    }
    
    // æš‚åœå½•åˆ¶
    pauseRecording(): void {
        if (this.mediaRecorder && this.isRecording) {
            this.mediaRecorder.pause();
        }
    }
    
    // æ¢å¤å½•åˆ¶
    resumeRecording(): void {
        if (this.mediaRecorder && this.isRecording) {
            this.mediaRecorder.resume();
        }
    }
    
    // é‡Šæ”¾èµ„æº
    dispose(): void {
        if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
        }
        
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.isRecording = false;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const recorder = new AudioRecorder();

async function startRecording() {
    try {
        // è¯·æ±‚éº¦å…‹é£æƒé™
        await recorder.requestPermission();
        
        // å¼€å§‹å½•åˆ¶
        recorder.startRecording();
        
        // 5ç§’ååœæ­¢å½•åˆ¶
        setTimeout(async () => {
            const audioBlob = await recorder.stopRecording();
            
            // åˆ›å»ºéŸ³é¢‘URL
            const audioUrl = URL.createObjectURL(audioBlob);
            
            // åˆ›å»ºéŸ³é¢‘å…ƒç´ æ’­æ”¾å½•éŸ³
            const audio = new Audio(audioUrl);
            audio.play();
            
            // æ¸…ç†èµ„æº
            recorder.dispose();
            
        }, 5000);
        
    } catch (error) {
        console.error('Recording failed:', error);
    }
}

```

### è§†é¢‘å¤„ç†å®ç°

#### è§†é¢‘æ’­æ”¾å™¨

```typescript
// è§†é¢‘æ’­æ”¾å™¨ç±»
class VideoPlayer {
    private video: HTMLVideoElement;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private isPlaying: boolean;
    
    constructor(
        videoElement: HTMLVideoElement,
        canvas: HTMLCanvasElement
    ) {
        this.video = videoElement;
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d')!;
        this.isPlaying = false;
        
        this.initializePlayer();
    }
    
    // åˆå§‹åŒ–æ’­æ”¾å™¨
    private initializePlayer(): void {
        // è®¾ç½®ç”»å¸ƒå°ºå¯¸
        this.canvas.width = this.video.clientWidth;
        this.canvas.height = this.video.clientHeight;
        
        // ç›‘å¬è§†é¢‘äº‹ä»¶
        this.video.addEventListener('play', () => {
            this.isPlaying = true;
            this.render();
        });
        
        this.video.addEventListener('pause', () => {
            this.isPlaying = false;
        });
        
        this.video.addEventListener('ended', () => {
            this.isPlaying = false;
        });
    }
    
    // åŠ è½½è§†é¢‘
    loadVideo(url: string): Promise<void> {
        return new Promise((resolve, reject) => {
            this.video.src = url;
            this.video.load();
            
            this.video.oncanplaythrough = () => resolve();
            this.video.onerror = () => reject(new Error('Failed to load video'));
        });
    }
    
    // æ’­æ”¾
    play(): Promise<void> {
        return this.video.play();
    }
    
    // æš‚åœ
    pause(): void {
        this.video.pause();
    }
    
    // è·³è½¬åˆ°æŒ‡å®šæ—¶é—´
    seek(time: number): void {
        this.video.currentTime = time;
    }
    
    // è®¾ç½®æ’­æ”¾é€Ÿåº¦
    setPlaybackRate(rate: number): void {
        this.video.playbackRate = rate;
    }
    
    // åº”ç”¨æ»¤é•œæ•ˆæœ
    applyFilter(filter: VideoFilter): void {
        this.ctx.filter = filter.toString();
    }
    
    // æ¸²æŸ“è§†é¢‘å¸§
    private render(): void {
        if (!this.isPlaying) return;
        
        // ç»˜åˆ¶è§†é¢‘å¸§
        this.ctx.drawImage(
            this.video,
            0,
            0,
            this.canvas.width,
            this.canvas.height
        );
        
        // ç»§ç»­æ¸²æŸ“ä¸‹ä¸€å¸§
        requestAnimationFrame(() => this.render());
    }
    
    // æˆªå–å½“å‰å¸§
    captureFrame(): string {
        return this.canvas.toDataURL('image/png');
    }
    
    // å¯¼å‡ºè§†é¢‘ç‰‡æ®µ
    async exportClip(
        startTime: number,
        endTime: number
    ): Promise<Blob> {
        const stream = this.canvas.captureStream();
        const recorder = new MediaRecorder(stream);
        const chunks: Blob[] = [];
        
        recorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
                chunks.push(e.data);
            }
        };
        
        return new Promise((resolve, reject) => {
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                resolve(blob);
            };
            
            // å¼€å§‹å½•åˆ¶
            this.video.currentTime = startTime;
            recorder.start();
            
            // åˆ°è¾¾ç»“æŸæ—¶é—´ååœæ­¢
            const checkTime = () => {
                if (this.video.currentTime >= endTime) {
                    recorder.stop();
                    this.pause();
                } else {
                    requestAnimationFrame(checkTime);
                }
            };
            
            this.play().then(checkTime);
        });
    }
}

// è§†é¢‘æ»¤é•œç±»
class VideoFilter {
    private filters: Map<string, number>;
    
    constructor() {
        this.filters = new Map();
    }
    
    // è®¾ç½®äº®åº¦
    setBrightness(value: number): void {
        this.filters.set('brightness', value);
    }
    
    // è®¾ç½®å¯¹æ¯”åº¦
    setContrast(value: number): void {
        this.filters.set('contrast', value);
    }
    
    // è®¾ç½®é¥±å’Œåº¦
    setSaturation(value: number): void {
        this.filters.set('saturate', value);
    }
    
    // è®¾ç½®è‰²ç›¸
    setHue(value: number): void {
        this.filters.set('hue-rotate', value);
    }
    
    // è®¾ç½®æ¨¡ç³Š
    setBlur(value: number): void {
        this.filters.set('blur', value);
    }
    
    // è½¬æ¢ä¸ºCSSæ»¤é•œå­—ç¬¦ä¸²
    toString(): string {
        return Array.from(this.filters.entries())
            .map(([key, value]) => `${key}(${value}${this.getUnit(key)})`)
            .join(' ');
    }
    
    // è·å–æ»¤é•œå•ä½
    private getUnit(filter: string): string {
        switch (filter) {
            case 'blur':
                return 'px';
            case 'hue-rotate':
                return 'deg';
            default:
                return '%';
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const video = document.getElementById('video') as HTMLVideoElement;
const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const player = new VideoPlayer(video, canvas);

// åŠ è½½å¹¶æ’­æ”¾è§†é¢‘
async function playVideo(url: string) {
    try {
        await player.loadVideo(url);
        await player.play();
        
        // åº”ç”¨æ»¤é•œæ•ˆæœ
        const filter = new VideoFilter();
        filter.setBrightness(110);
        filter.setContrast(120);
        filter.setSaturation(130);
        
        player.applyFilter(filter);
        
        // æˆªå–å½“å‰å¸§
        setTimeout(() => {
            const frameData = player.captureFrame();
            const img = new Image();
            img.src = frameData;
            document.body.appendChild(img);
        }, 3000);
        
        // å¯¼å‡ºè§†é¢‘ç‰‡æ®µ
        setTimeout(async () => {
            const clip = await player.exportClip(5, 10);
            const url = URL.createObjectURL(clip);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'clip.webm';
            a.click();
        }, 5000);
        
    } catch (error) {
        console.error('Failed to play video:', error);
    }
}

```

### æµåª’ä½“å¤„ç†

#### WebRTCå®ç°

```typescript
// WebRTCè¿æ¥ç®¡ç†å™¨
class WebRTCManager {
    private peerConnection: RTCPeerConnection;
    private localStream: MediaStream | null;
    private remoteStream: MediaStream | null;
    private dataChannel: RTCDataChannel | null;
    
    constructor() {
        this.peerConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        });
        
        this.localStream = null;
        this.remoteStream = null;
        this.dataChannel = null;
        
        this.initializeConnection();
    }
    
    // åˆå§‹åŒ–è¿æ¥
    private initializeConnection(): void {
        // ç›‘å¬ICEå€™é€‰
        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                // å‘é€ICEå€™é€‰åˆ°è¿œç«¯
                this.sendSignalingMessage({
                    type: 'candidate',
                    candidate: event.candidate
                });
            }
        };
        
        // ç›‘å¬è¿œç«¯æµ
        this.peerConnection.ontrack = (event) => {
            this.remoteStream = event.streams[0];
            // è§¦å‘è¿œç«¯æµæ›´æ–°äº‹ä»¶
            this.onRemoteStreamUpdate(this.remoteStream);
        };
        
        // åˆ›å»ºæ•°æ®é€šé“
        this.dataChannel = this.peerConnection.createDataChannel('messageChannel');
        
        // ç›‘å¬æ•°æ®é€šé“äº‹ä»¶
        this.dataChannel.onmessage = (event) => {
            this.onDataChannelMessage(event.data);
        };
    }
    
    // è·å–æœ¬åœ°åª’ä½“æµ
    async getLocalStream(
        constraints: MediaStreamConstraints
    ): Promise<MediaStream> {
        try {
            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // æ·»åŠ æœ¬åœ°æµåˆ°è¿æ¥
            this.localStream.getTracks().forEach(track => {
                if (this.localStream) {
                    this.peerConnection.addTrack(track, this.localStream);
                }
            });
            
            return this.localStream;
            
        } catch (error) {
            throw new Error('Failed to get local stream');
        }
    }
    
    // åˆ›å»ºè¿æ¥è¯·æ±‚
    async createOffer(): Promise<RTCSessionDescriptionInit> {
        try {
            const offer = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(offer);
            return offer;
            
        } catch (error) {
            throw new Error('Failed to create offer');
        }
    }
    
    // åˆ›å»ºè¿æ¥åº”ç­”
    async createAnswer(): Promise<RTCSessionDescriptionInit> {
        try {
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);
            return answer;
            
        } catch (error) {
            throw new Error('Failed to create answer');
        }
    }
    
    // å¤„ç†è¿œç«¯æè¿°
    async handleRemoteDescription(
        description: RTCSessionDescriptionInit
    ): Promise<void> {
        try {
            await this.peerConnection.setRemoteDescription(
                new RTCSessionDescription(description)
            );
            
            if (description.type === 'offer') {
                const answer = await this.createAnswer();
                // å‘é€åº”ç­”åˆ°è¿œç«¯
                this.sendSignalingMessage({
                    type: 'answer',
                    answer
                });
            }
            
        } catch (error) {
            throw new Error('Failed to handle remote description');
        }
    }
    
    // å¤„ç†ICEå€™é€‰
    async handleCandidate(candidate: RTCIceCandidate): Promise<void> {
        try {
            await this.peerConnection.addIceCandidate(candidate);
        } catch (error) {
            throw new Error('Failed to handle ICE candidate');
        }
    }
    
    // å‘é€æ¶ˆæ¯
    sendMessage(message: string): void {
        if (this.dataChannel && this.dataChannel.readyState === 'open') {
            this.dataChannel.send(message);
        }
    }
    
    // å…³é—­è¿æ¥
    close(): void {
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => track.stop());
        }
        
        if (this.dataChannel) {
            this.dataChannel.close();
        }
        
        this.peerConnection.close();
    }
    
    // å‘é€ä¿¡ä»¤æ¶ˆæ¯ï¼ˆéœ€è¦å®ç°ï¼‰
    private sendSignalingMessage(message: any): void {
        // é€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨å‘é€æ¶ˆæ¯
    }
    
    // è¿œç«¯æµæ›´æ–°å›è°ƒï¼ˆéœ€è¦å®ç°ï¼‰
    private onRemoteStreamUpdate(stream: MediaStream): void {
        // å¤„ç†è¿œç«¯æµæ›´æ–°
    }
    
    // æ•°æ®é€šé“æ¶ˆæ¯å›è°ƒï¼ˆéœ€è¦å®ç°ï¼‰
    private onDataChannelMessage(message: string): void {
        // å¤„ç†æ•°æ®é€šé“æ¶ˆæ¯
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const rtcManager = new WebRTCManager();

// å¼€å§‹è§†é¢‘é€šè¯
async function startVideoCall() {
    try {
        // è·å–æœ¬åœ°åª’ä½“æµ
        const localStream = await rtcManager.getLocalStream({
            video: true,
            audio: true
        });
        
        // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘
        const localVideo = document.getElementById('localVideo') as HTMLVideoElement;
        localVideo.srcObject = localStream;
        
        // åˆ›å»ºè¿æ¥è¯·æ±‚
        const offer = await rtcManager.createOffer();
        
        // å‘é€offeråˆ°è¿œç«¯ï¼ˆé€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨ï¼‰
        // ...
        
    } catch (error) {
        console.error('Video call failed:', error);
    }
}

// å¤„ç†è¿œç«¯æ¶ˆæ¯
function handleRemoteMessage(message: any) {
    switch (message.type) {
        case 'offer':
            rtcManager.handleRemoteDescription(message.offer);
            break;
            
        case 'answer':
            rtcManager.handleRemoteDescription(message.answer);
            break;
            
        case 'candidate':
            rtcManager.handleCandidate(message.candidate);
            break;
    }
}

```

### æœ€ä½³å®è·µä¸å»ºè®®

1. **æ€§èƒ½ä¼˜åŒ–**

   * ä½¿ç”¨é€‚å½“çš„ç¼–è§£ç æ ¼å¼
   * å®ç°é¢„åŠ è½½å’Œç¼“å†²
   * ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
   * æ§åˆ¶å†…å­˜ä½¿ç”¨
2. **ç”¨æˆ·ä½“éªŒ**

   * æµç•…çš„æ’­æ”¾ä½“éªŒ
   * åˆé€‚çš„ç¼“å†²ç­–ç•¥
   * æ¸…æ™°çš„é”™è¯¯æç¤º
   * å‹å¥½çš„æ§åˆ¶ç•Œé¢
3. **å…¼å®¹æ€§å¤„ç†**

   * æ”¯æŒå¤šç§æ ¼å¼
   * ä¼˜é›…é™çº§æ–¹æ¡ˆ
   * è·¨æµè§ˆå™¨å…¼å®¹
   * ç§»åŠ¨ç«¯é€‚é…
4. **å®‰å…¨æ€§è€ƒè™‘**

   * å†…å®¹åŠ å¯†
   * æƒé™æ§åˆ¶
   * é˜²ç›—é“¾æªæ–½
   * æ•°æ®ä¿æŠ¤

### æ€»ç»“

å‰ç«¯éŸ³è§†é¢‘å¤„ç†éœ€è¦è€ƒè™‘ä»¥ä¸‹æ–¹é¢ï¼š

1. é€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ–¹æ¡ˆ
2. ä¼˜åŒ–æ’­æ”¾æ€§èƒ½
3. æä¾›è‰¯å¥½ä½“éªŒ
4. ä¿è¯å®‰å…¨å¯é 
5. å¤„ç†å…¼å®¹æ€§

é€šè¿‡åˆç†çš„æŠ€æœ¯é€‰å‹å’Œä¼˜åŒ–æªæ–½ï¼Œå¯ä»¥æ„å»ºå‡ºé«˜è´¨é‡çš„éŸ³è§†é¢‘åº”ç”¨ã€‚

### å­¦ä¹ èµ„æº

1. Web Audio APIæ–‡æ¡£
2. Media Source ExtensionsæŒ‡å—
3. WebRTCå¼€å‘æ•™ç¨‹
4. éŸ³è§†é¢‘ç¼–è§£ç çŸ¥è¯†
5. æµåª’ä½“åè®®è§„èŒƒ

---

å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµæ”¶è—ï¼Œä¹ŸæœŸå¾…åœ¨è¯„è®ºåŒºçœ‹åˆ°ä½ çš„æƒ³æ³•å’Œå»ºè®®ï¼ğŸ‘‡

***ç»ˆèº«å­¦ä¹ ï¼Œå…±åŒæˆé•¿ã€‚***

å’±ä»¬ä¸‹ä¸€æœŸè§

ğŸ’»