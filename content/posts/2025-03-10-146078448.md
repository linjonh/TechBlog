---
layout: post
title: "JS内置对象3分钟掌握Symbol"
date: 2025-03-10 20:01:27 +0800
description: "​可枚举性检查：仅遍历 enumerable: true 的属性（通过 Object.defineProperty 或直接赋值定义的属性默认可枚举）常用的内置对象，只是简单的说一下，最想说的还是Symbol，面试问道的频率高。​仅遍历字符串键：for…in ​只处理属性名为字符串的键，忽略 Symbol 键。作用于对象时，symbol的键不会隐式的转为字符串，避免命名冲突。每个symbol的值都是唯一的，即使他们的描述也相同，如下。​继承属性：从原型链继承的可枚举属性。​自身属性：对象直接定义的属性。"
keywords: "JS—内置对象：3分钟掌握Symbol"
categories: ['Web']
tags: ['开发语言', 'Symbol', 'Javascript', 'Forin']
artid: "146078448"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146078448
    alt: "JS内置对象3分钟掌握Symbol"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146078448
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146078448
cover: https://bing.ee123.net/img/rand?artid=146078448
image: https://bing.ee123.net/img/rand?artid=146078448
img: https://bing.ee123.net/img/rand?artid=146078448
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JS—内置对象：3分钟掌握Symbol
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      个人博客：
      <a href="http://haichenyi.com" rel="nofollow">
       haichenyi.com
      </a>
      。感谢关注
     </strong>
    </p>
    <p>
     <span id="c1">
     </span>
    </p>
    <h3>
     <a id="1__4">
     </a>
     1. 目录
    </h3>
    <ul>
     <li>
      <a href="#c1" rel="nofollow">
       1–目录
      </a>
     </li>
     <li>
      <a href="#c2" rel="nofollow">
       2–内置对象
      </a>
     </li>
     <li>
      <a href="#c3" rel="nofollow">
       3–Symbol
      </a>
     </li>
     <li>
      <a href="#c4" rel="nofollow">
       4–Symbol的常见用法与问题
      </a>
     </li>
    </ul>
    <p>
     <span id="c2">
     </span>
    </p>
    <h3>
     <a id="2__11">
     </a>
     2. 内置对象
    </h3>
    <p>
     常用的内置对象，只是简单的说一下，最想说的还是Symbol，面试问道的频率高。比方说：
    </p>
    <pre><code>//Object	所有对象的基类，提供属性/方法如 create(), keys(), assign()
//Function	函数构造器，所有函数实例的原型对象
//Array	数组对象，提供 push(), map(), filter() 等方法
const obj = new Object();
const arr = new Array(1, 2, 3);

//Math用于进行常见的数学运算
Math.random()//用于生成一个随机数，
Math.floor()//用于向下取整，
Math.sqrt()//用于开平方等。

//Date用于处理日期和时间
new Date()//可以创建一个表示当前日期和时间的对象

//String用于处理字符串
charAt()//用于获取特定位置的字符，
concat()//用于连接两个或多个字符串，
indexOf()//用于查找特定字符串的位置等。

//Map	ES6 键值对集合，支持任意类型键
//Set	ES6 唯一值集合
//WeakMap	键为弱引用的 Map，防止内存泄漏
//WeakSet	值为弱引用的 Set
const map = new Map();
map.set("key", "value");
const set = new Set([1, 2, 3]);

//Error	通用错误基类，如 new Error("message")
//TypeError	类型错误（如调用不存在的方法）
//SyntaxError	语法错误（如 JSON 解析失败）
//ReferenceError	引用错误（如访问未声明变量）
try {
  throw new TypeError("类型错误");
} catch (e) {
  console.error(e);
}
//JSON	JSON 解析工具，提供 parse(), stringify()
const json = JSON.stringify({ name: "Alice" });

//RegExp	正则表达式对象，如 new RegExp("\\d+", "g")
//Promise	ES6 异步操作对象，支持链式调用 .then()/.catch()
//Proxy	ES6 代理对象，用于拦截对象操作（如 get/set）
//Reflect	ES6 反射工具，提供对象操作的静态方法
const regex = new RegExp("\\d+", "g");
const promise = new Promise((resolve) =&gt; resolve("OK"));
</code></pre>
    <p>
     <span id="c3">
     </span>
    </p>
    <h3>
     <a id="3_Symbol_61">
     </a>
     3. Symbol
    </h3>
    <p>
     Symbol是ES6中引入的基本数据类型。用来创建
     <strong>
      唯一的
     </strong>
     ，
     <strong>
      不可变
     </strong>
     的值。通常用于对象属性的key。
    </p>
    <h4>
     <a id="_63">
     </a>
     唯一性
    </h4>
    <p>
     每个symbol的值都是唯一的，即使他们的描述也相同，如下
    </p>
    <pre><code>let sym1 = Symbol("name");
let sym2 = Symbol("name");
console.log(sym1 === sym2); // false
</code></pre>
    <p>
     <img alt="唯一性" src="https://i-blog.csdnimg.cn/direct/8fb13839d2b247a399c850b3035346e5.png"/>
    </p>
    <h4>
     <a id="_71">
     </a>
     不可变
    </h4>
    <p>
     Symbol 一旦创建，无法修改其值或描述
    </p>
    <pre><code>// 创建带描述的 Symbol
const sym = Symbol("original description");
console.log(sym.description); // "original description"
// 尝试修改描述
sym.description = "new description"; // 静默失败，无报错但无效
console.log(sym.description); // 仍输出 "original description"
// 甚至尝试强制修改（严格模式会报错）
Object.defineProperty(sym, 'description', { value: "hacked" }); // 抛出 TypeError
</code></pre>
    <p>
     <img alt="不可变" src="https://i-blog.csdnimg.cn/direct/fcf40aec25924080b623490c718d19b0.png"/>
    </p>
    <h4>
     <a id="_84">
     </a>
     非字符串键
    </h4>
    <p>
     作用于对象时，symbol的键不会隐式的转为字符串，避免命名冲突。
    </p>
    <pre><code>//键是Symbol("id")这个对象。并不是字符串
const obj = {
  [Symbol("id")]: 123  // 唯一的键
};
</code></pre>
    <h4>
     <a id="_92">
     </a>
     不可枚举性
    </h4>
    <p>
     symbol属性默认不会出现在for…in、Object.keys() 或 JSON.stringify() 中
    </p>
    <pre><code>//定义obj1，其中定义了两个属性，一个普通属性，一个symbol属性
let obj1 = {name:"zhangsan",[Symbol('id')]:"001"}
JSON.stringify(obj1) //{"name":"zhangsan"}
Object.keys(obj1)//['name']
</code></pre>
    <p>
     <img alt="不可枚举性" src="https://i-blog.csdnimg.cn/direct/327c5ceadfc242dbaad6c21851898f5f.png">
      <br/>
      <span id="c4">
      </span>
     </img>
    </p>
    <h3>
     <a id="4_Symbol_102">
     </a>
     4. Symbol的常见用法与问题
    </h3>
    <h4>
     <a id="symbol_103">
     </a>
     常见获取symbol的方法
    </h4>
    <pre><code>//创建
const symId1 = Symbol("id")
//通过全局注册表去获取Symbol
const symId2 = Symbol.for("id")
const symId3 = Symbol.for("id")
console.log(symId1 === symId2) //false
console.log(symId2 === symId3) //true
//前面都说了唯一性了，为啥这里会打印true呢？
//因为，你通过Symbol.for方式去获取symbol对象，原理是它优先从全局注册表中查找以key为描述的symbol对象
//如果没有查找到就创建一个symbol对象返回，如果查找到了，就把查找到的symbol对象返回。
</code></pre>
    <p>
     <img alt="获取symbol的方式" src="https://i-blog.csdnimg.cn/direct/a6639d671ca543c5bc0108603f819695.png"/>
    </p>
    <h4>
     <a id="_117">
     </a>
     常见用法
    </h4>
    <ol>
     <li>
      ​避免属性名冲突。解决对象属性名可能被覆盖的问题：
     </li>
    </ol>
    <pre><code>const user = {
  id: 1,
  name: "Alice",
  [Symbol("internal_id")]: "X-123" // 隐藏的内部属性
};
</code></pre>
    <ol start="2">
     <li>
      定义类的私有成员。模拟私有属性（通过闭包和 Symbol）：
     </li>
    </ol>
    <pre><code>const _counter = Symbol("counter");
class MyClass {
  constructor() {
    this[_counter] = 0; // "私有"属性
  }
  increment() {
    this[_counter]++;
  }
}
</code></pre>
    <ol start="3">
     <li>
      定义常量。确保常量的唯一性：
     </li>
    </ol>
    <pre><code>const LOG_LEVEL = {
  DEBUG: Symbol("debug"),
  INFO: Symbol("info"),
  ERROR: Symbol("error")
};
</code></pre>
    <h4>
     <a id="_146">
     </a>
     常见问题
    </h4>
    <ol>
     <li>
      for…in,Object.keys方法无法获取到symbol，那么，要怎么获取symbol呢？
     </li>
    </ol>
    <pre><code>const obj = {
  [Symbol("id")]: 123,
  name: "Alice"
};
obj[Symbol("sex")] = "男"
//获取symbol对象
Object.getOwnPropertySymbols(obj);//[Symbol(id), Symbol(sex)]
//获取所有的key
Reflect.ownKeys(obj)//['name', Symbol(id), Symbol(sex)]
</code></pre>
    <p>
     <img alt="获取symbol" src="https://i-blog.csdnimg.cn/direct/040b22c621484c0f96a87d68b4ebc2ff.png">
      <br/>
      2. Symbol.iterator 的作用
      <br/>
      当一个对象实现了Symbol.iterator迭代器，则该对象可以用for…of遍历。比方说我们的内置对象Array
     </img>
    </p>
    <pre><code>const arr = [10, 20, 30];
const iterator = arr[Symbol.iterator](); // 获取迭代器
console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { done: true }
</code></pre>
    <p>
     <img alt="array打印" src="https://i-blog.csdnimg.cn/direct/7a3149325d464908afcce6429d4c7be4.png">
      <br/>
      <img alt="array的迭代器" src="https://i-blog.csdnimg.cn/direct/5e6adbaa8d4b44e69f7997b9715be2ed.png">
       <br/>
       3. for…in和for…of
      </img>
     </img>
    </p>
    <pre><code>let arr1 = ["1","2",Symbol("id"),"3"]
for (const key in arr1) {
//这里输出0，1，2，3
//然后通过key去获取值。
 console.log(key); 
}

let arr1 = ["1","2",Symbol("id"),"3"]
for (const value of arr1) {
//这里输出值
 console.log(value); 
}
</code></pre>
    <p>
     <img alt="遍历获取" src="https://i-blog.csdnimg.cn/direct/e1a42be6cf314c5c8ac1015861a27d27.png">
      <br/>
      for…in 是 JavaScript 中用于遍历对象
      <strong>
       可枚举的字符串键属性
      </strong>
      的语法，其底层机制如下：
      <br/>
      a. ​遍历范围
      <br/>
      ​自身属性：对象直接定义的属性。
      <br/>
      ​继承属性：从原型链继承的可枚举属性。
      <br/>
      b. ​遍历规则
      <br/>
      ​仅遍历字符串键：for…in ​只处理属性名为字符串的键，忽略 Symbol 键。
      <br/>
      ​可枚举性检查：仅遍历 enumerable: true 的属性（通过 Object.defineProperty 或直接赋值定义的属性默认可枚举）
     </img>
    </p>
    <pre><code>let obj = {}
obj.name = "zhangsan"
obj[Symbol("sex")] = "男"
let func = ()=&gt;{
}
obj[func] = "李四"
//这里方法之所以能遍历，是因为这里的方法被存储为了字符串
//再回过头去看前面说的  非字符串键
Object.keys(obj)  //['name', '()=&gt;{\n}']
</code></pre>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/f600e83feb49420ebec3c884d6d41c97.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f32373633343739372f:61727469636c652f64657461696c732f313436303738343438" class_="artid" style="display:none">
 </p>
</div>


