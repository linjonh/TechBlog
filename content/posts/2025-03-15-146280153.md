---
layout: post
title: "不像人做的题十四届蓝桥杯省赛真题解析上A,B,C,D题解析"
date: 2025-03-15 17:52:08 +0800
description: "有235个这样的合法子序列。"
keywords: "不像人做的题————十四届蓝桥杯省赛真题解析（上）A，B，C，D题解析"
categories: ['蓝桥冲刺营']
tags: ['蓝桥杯', '深度优先', 'C']
artid: "146280153"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146280153
    alt: "不像人做的题十四届蓝桥杯省赛真题解析上A,B,C,D题解析"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146280153
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146280153
cover: https://bing.ee123.net/img/rand?artid=146280153
image: https://bing.ee123.net/img/rand?artid=146280153
img: https://bing.ee123.net/img/rand?artid=146280153
---

# 不像人做的题————十四届蓝桥杯省赛真题解析（上）A，B，C，D题解析

### 题目A：日期统计

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a3cb9e3e0c814cf990f401b342d7f68d.png)  
**思路分析：**  
**本题的题目比较繁琐，我们采用暴力加DFS剪枝的方式去做，我们在DFS中按照8位日期的每一个位的要求进行初步剪枝找出所有的八位子串，但是还是会存在19月的情况，为此还需要在CHECK函数中进一步剪枝，使得月份天数都符合条件**  
**作者题解：**

    
    
    #include<iostream>
    using namespace std;
    int a[105], ans;
    bool vis[20240000];
    bool check(int date)//进一步剪枝，判断日期是否合法
    {
    	if (vis[date])return false;
    	vis[date] = 1;//标记是否访问过
    	int mm = date / 100 % 100;//取出月份判断是否合法
    	int dd = date % 100;//取出天数判断是否合法
    	if (mm < 1 || mm > 12)return false;//月份小于1大于12都不合法
    	if (mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm == 8 || mm == 10 || mm == 12)
    	{
    		if (1 <= dd && dd <= 31)return true;//大月如果是31天表示合法
    	}
    	else if (mm == 2)
    	{
    		if (1 <= dd && dd <= 28)return true;//如果是2月不超过28天表示合法
    	}
    	else if (1 <= dd && dd <= 30)return true;//不是2月也不是大月不超过30天表示合法
    	else return false;
    }
    
    void dfs(int x, int pos, int date)
    {
    	if (x == 100)return;
    	if (pos == 8)
    	{
    		if (check(date))++ans;
    		return;
    	}
    	if (pos == 0 && a[x] == 2 ||
    		pos == 1 && a[x] == 0 ||
    		pos == 2 && a[x] == 2 ||
    		pos == 3 && a[x] == 3 ||//剪枝，前四位必须是2023
    		pos == 4 && (0 <= a[x] && a[x] <= 1) || //剪枝，月份第一位不可能超过1
    		pos == 5 && (0 <= a[x] && a[x] <= 9) ||
    		pos == 6 && (0 <= a[x] && a[x] <= 3) ||//日期的第一位不可能超过3
    		pos == 7 && (0 <= a[x] && a[x] <= 9))
    		dfs(x + 1, pos + 1, date * 10 + a[x]);
    	dfs(x + 1, pos, date);//合法才继续往后搜索
    }
    int main()
    {
    	ios::sync_with_stdio,cin.tie(0), cout.tie(0);
    	for (int i = 0; i < 100; i++)cin >> a[i];
    	dfs(0, 0, 0);
    	cout << ans;
    	return 0;
    }
    

**运行结果：**  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/460a9b2bd4d04cbf9079791f452a01b4.png#pic_center)  
有235个这样的合法子序列

### 题目B：01串的熵

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d93c6f26578c47309d595e554bd09b80.png)  
**思路分析：**  
这道题我们不要被它的定义吓唬住，仔细分析我们设串中的1的个数为u,串长为N，则v的个数为N-u，我们可以得到如下图的递推公式：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4a16c05891d04581ac1fd1a3c93c32b7.jpeg)  
**然后就是由于题中给出的是浮点数，我们要考率精度的问题，误差在给定的范围内即可认为是同一个浮点数，给定的数有几位小数，我们的精度就设为10的几次方**

**作者题解：**

    
    
    #include<iostream>
    using namespace std;
    using db = long double;
    const int N = 23333333;//定义字符串长度
    const db ans = 11625907.5798, eps = 1e-4;//由于题目中的数据是四位小数，所以我们要定义一个误差精度eps，在误差内表示是同一个数
    int main()
    {
    	for (int v = 0; v <= N / 2; ++v)
    	{
    		int u = N - v;
    		db res = -1.0 * u * u / N * log2(1.0 * u / N) - 1.0 * v * v / N * log2(1.0 * v / N);
    		if (fabs(res - ans) < eps)
    		{
    			cout << v;
    			return 0;
    		}
    	}
    	return 0;
    }
    

**运行结果：**  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7e19d91de7c64278bb33554bb46235ff.png)

### 题目C：冶炼金属

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ee292fc88ce24a6b8509ce1137f62afc.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/edb9c54972ab4085b87ef3f67aac70d3.png)  
**思路分析：**  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/22020b35cfb742e8b15cefd98f95b228.png#pic_center)  
**如图所示，我们通过数轴的方式分析，Ai/Vmin=Bi，那么我们如果要找Vmin那么Vmin逐渐增大，对应的Bi会逐渐变小，也就是说，Vmin左侧的Bi应该都比Vmin的Bi大，同理，Vmax右侧的Bi应该都比Vmax的Bi小，所以我们使用两次二分法，二分答案，以Bi的值作为检验函数，就可以求出最大和最小的V**  
**作者题解：**

    
    
    #include<iostream>
    using namespace std;
    const int MAX_N = 1e4 + 1;
    int N, A[MAX_N], B[MAX_N];
    int V_min,V_max;
    bool check_min(int V)
    {
    	for (int i = 1; i <= N; ++i)
    		if (A[i] / V > B[i])return false;//查找最小值时都应该比bi小
    	return true;
    }
    
    bool check_max(int V)
    {
    	for (int i = 1; i <= N; ++i)
    		if (A[i] / V < B[i])return false;//查找最大值时都应该比bi小
    	return true;
    }
    int main()
    {
    	ios::sync_with_stdio, cin.tie(0), cout.tie(0);
    	cin >> N;
    	for (int i = 1; i <= N; i++)cin >> A[i] >> B[i];
    	int L = 1, R = 1e9;
    	while (L <= R)
    	{
    		int mid = L + R >> 1;
    		if (check_min(mid))
    		{
    			V_min = mid;
    			R = mid - 1;//查找最小值缩右边界
    		}
    		else L = mid + 1;
    	}
    
    	 L = 1, R = 1e9;
    	while (L <= R)
    	{
    		int mid = L + R >> 1;
    		if (check_max(mid))
    		{
    			V_max = mid;
    			L = mid + 1;//查找最大值缩左边界
    		}
    		else R = mid - 1;
    	}
    	cout << V_min << " " << V_max << endl;
    	return 0;
    }
    

**运行结果：**  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7f8487861d7845e2ba5c8a83eb0788c9.png#pic_center)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/afe772de348445dd8091f548ed587b14.png)

### 题目D：飞机降落

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/34c07dad7b8e45d58769a5480af81db1.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/029b8cd58eed485a8320ac0bfdfc4183.png)  
**思路分析：**  
**这道题如果我们直接采用全排列可能会超时，所以我们还是采用DFS剪枝的策略，核心思想在于该架飞机的到达时间加上盘旋时间大于此前所有飞机的降落时间时才可以安全降落，我们采用一个used数组来维护飞机是否可以安全降落，最后递归的出口如果X==N即所有飞机完成降落我们就输出YES**  
**作者题解：**

    
    
    #include<iostream>
    using namespace std;
    const int MAX_N = 11;
    int N, T[MAX_N], D[MAX_N], L[MAX_N];
    bool used[MAX_N], have_answer;//use标志飞机是否安全降落
    void dfs(int x, int tim) //tim表示此前所有飞机降落所需的单位时间
    {
    	if (have_answer)return;
    	if (x == N)
    	{
    		have_answer = 1;
    		return;//存在解则退出搜索
    	}
    	for (int i = 1; i <= N; i++)
    	{
    		if (!used[i] && tim <= T[i] + D[i])
    		{
    			used[i] = 1;
    			dfs(x + 1, max(T[i], tim) + L[i]);//如果此前所有的飞机的降落时间小于下一架飞机的最早降落时间可以等一等
    			if (have_answer)return;
    			else used[i] = 0;//回溯
    		}
    	}
    }
    
    void solve()
    {
    	have_answer = 0;
    	cin >> N;
    	for (int i = 1; i <= N; ++i)
    	{
    		cin >> T[i] >> D[i] >> L[i];
    		used[i] = 0;
    	}
    	dfs(0, 0);
    	if (have_answer)cout << "YES\n";
    	else cout << "NO\n";
    }
    int main()
    {
    	ios::sync_with_stdio, cin.tie(0), cout.tie(0);
    	int t;
    	cin >> t;
    	while (t--)
    		solve();
    	return 0;
    }
    

**运行结果：**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3c21af2d8b9f4b5db4eed252d7a7bd74.png)  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bbe043fdf7764a2ea05812cc5131b739.png)  
**下期预告：E，F，G题解析**



