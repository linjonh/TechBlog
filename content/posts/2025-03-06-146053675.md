---
layout: post
title: "蓝桥备赛11-数据结构算法与STL"
date: 2025-03-06 20:33:04 +0800
description: "1. 信息学竞赛中，C++ 通常设定 1 到 2 秒的时间限制，要控制运行次数在 10^7 ⾄ 10^8 之间。2. 空间限制在128MB 或 256MB ，可以开⼀个3 x 10 ^7 大小的int  类型数组，或者5000x5000大小的⼆维数组，⼀般情况下都是够⽤的。"
keywords: "蓝桥备赛（11）- 数据结构、算法与STL"
categories: ['手撕代码']
tags: ['算法', '数据结构', '开发语言', 'C']
artid: "146053675"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146053675
    alt: "蓝桥备赛11-数据结构算法与STL"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146053675
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146053675
cover: https://bing.ee123.net/img/rand?artid=146053675
image: https://bing.ee123.net/img/rand?artid=146053675
img: https://bing.ee123.net/img/rand?artid=146053675
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     蓝桥备赛（11）- 数据结构、算法与STL
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2 style="background-color:transparent">
     一、数据结构
    </h2>
    <h3 style="background-color:transparent">
     1.1 什么是数据结构？
    </h3>
    <blockquote>
     <div>
      <strong>
       <span style="color:#1f2329">
        在计算机科学中，数据结构是一种
        <span style="background-color:#ffd900">
         数据组织、管理和存储的格式
        </span>
        。它是相互之间存在
       </span>
       <span style="color:#fe2c24">
        一种
       </span>
      </strong>
     </div>
     <div>
      <strong>
       <span style="color:#fe2c24">
        或多种特定关系的数据元素的集合
       </span>
       <span style="color:#1f2329">
        。
       </span>
      </strong>
     </div>
     <div>
     </div>
     <div>
      <strong>
       <span style="color:#1f2329">
        ---&gt;  通俗点，数据结构就是数据的组织形式 ， 研究数据是用什么方式存储在存储在g'v计算机中的
       </span>
      </strong>
     </div>
    </blockquote>
    <h3>
     1.2 为什么会有数据结构？
    </h3>
    <blockquote>
     <p>
      1） 随着计算机的
      <span style="color:#1f2329">
       发展和应用范围的拓展，计算机需要处理的数据量越来越大，数据类型越来越多，
       <strong>
        <span style="background-color:#ffd900">
         数据之间的关系也越来越复杂
        </span>
       </strong>
       。
      </span>
     </p>
     <div>
     </div>
     <div>
      <span style="color:#1f2329">
       2）这就要求⼈们对计算机加工处理的数据进行系列的研究，即研究数据的特性、数据之间存在的关系，以及如何有效的组织、管理存储数据，
      </span>
      <span style="color:#fe2c24">
       <strong>
        从而提高计算机处理数据的效率。
       </strong>
      </span>
      <span style="color:#1f2329">
      </span>
     </div>
    </blockquote>
    <p>
    </p>
    <h3>
     1.3 数据结构的三要素
    </h3>
    <p class="img-center">
     <img alt="" height="1053" src="https://i-blog.csdnimg.cn/direct/5fade3d1f6f54d87bf93b2f2738da08d.png" width="1551"/>
    </p>
    <h4 style="background-color:transparent">
     1.3.1 逻辑结构
    </h4>
    <p>
     <span style="color:#0d0016">
      <strong>
       数据结构：数据中各元素之间的逻辑关系
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      <strong>
       他
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       只关心数据中各个元素之间的关系
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       ， 并
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       不关心
      </strong>
     </span>
     <span style="color:#0d0016">
      <strong>
       数据在内存中存储的
      </strong>
     </span>
    </p>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       1）集合：
      </span>
     </strong>
     <strong>
      <span style="background-color:#ffd900">
       所有数据只是放在一个集合中 ， 彼此之间再
       <span style="color:#fe2c24">
        没有
       </span>
       其他联系
      </span>
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="278" src="https://i-blog.csdnimg.cn/direct/061eaf9e75f5485ab40f2d59606bc7d8.png" width="450"/>
    </p>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       2）线性结构：数据之间只存在一对一的关系
      </span>
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/1c0abdc0351f4f30bb4097616f684049.png" width="828"/>
    </p>
    <h4>
     <span style="background-color:#ffd900">
      <strong>
       3）树：数据之间是一对多的关系
      </strong>
     </span>
    </h4>
    <p class="img-center">
     <img alt="" height="304" src="https://i-blog.csdnimg.cn/direct/0cea73e6989849ff85659499771c7c9f.png" width="450"/>
    </p>
    <p>
     <strong>
      <span style="background-color:#ffd900">
       4）图结构：数据之间存在多对多的关系
      </span>
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="342" src="https://i-blog.csdnimg.cn/direct/7498a02bcb64434ca6b98a7d78faef75.png" width="450"/>
    </p>
    <p>
    </p>
    <h4>
     1.3.2 存储结构
    </h4>
    <blockquote>
     <p>
      存储结构又称 物理结构 ， 但是存储二字 更能理解 ，后续我们统称为数据结构。
     </p>
     <p>
      存储结构 顾名思义 ， 就是如何把数据在计算机中存储。
     </p>
     <p>
     </p>
     <p>
      <span style="color:#fe2c24">
       <strong>
        1） 顺序存储：
       </strong>
      </span>
      <strong>
       <span style="color:#0d0016">
        把逻辑上相邻的元素存储在  物理上也相邻的存储单元中  ---&gt; 数组（逻辑、物理上都是连续的）
       </span>
      </strong>
     </p>
     <p>
      <strong>
       <span style="color:#fe2c24">
        2）链式存储：
       </span>
       <span style="color:#0d0016">
        逻辑上两个元素相邻 ， 但是物理结构上不一定相邻
       </span>
      </strong>
      <strong>
       <span style="color:#0d0016">
       </span>
      </strong>
     </p>
    </blockquote>
    <p>
    </p>
    <h4>
     1.3.3 数据的运算
    </h4>
    <p>
     数据的运算，（针对数据的各种操作） ，
     <strong>
      包括
      <span style="color:#fe2c24">
       数据结构的实现 ， 以及基于数据结构上的各种操作。
      </span>
     </strong>
    </p>
    <p>
     <strong>
      <span style="color:#fe2c24">
       ---&gt;   意思是 ， 我们已经知道
      </span>
      了一堆数据中  各个元素之间的关系 ， 也知道这堆数据应该在内存中如何存储 。
     </strong>
    </p>
    <p>
     <strong>
      ----&gt; 那么接下来就是写代码 ， 完成我们的需求
     </strong>
    </p>
    <p class="img-center">
     <img alt="" height="535" src="https://i-blog.csdnimg.cn/direct/9d30c10228ae41b49540fa48f70ae627.png" width="1286"/>
    </p>
    <p>
    </p>
    <h2>
     二、算法
    </h2>
    <h3>
     2.1 什么是算法？
    </h3>
    <p class="img-center">
     <img alt="" height="186" src="https://i-blog.csdnimg.cn/direct/e50b7127607b416ba883f542c6b38293.png" width="1594"/>
    </p>
    <blockquote>
     <p>
      <strong>
       <span style="background-color:#ffd900">
        简单来说 ---&gt;
        <span style="color:#fe2c24">
         算法就是一系列的步骤
        </span>
        ， 用来将输入数据转化为输出结果（用来解决问题）
       </span>
      </strong>
     </p>
    </blockquote>
    <p class="img-center">
     <img alt="" height="281" src="https://i-blog.csdnimg.cn/direct/114486f27f2a4bd59718314bc1ea44b0.png" width="1498"/>
    </p>
    <p>
    </p>
    <h3>
     2.2 算法好坏的度量
    </h3>
    <div>
     <span style="color:#1f2329">
      算法设计好后，根据算法的设计原理，只要问题规模确定，算法中
     </span>
     <span style="color:#fe2c24">
      <strong>
       基本语句执行次数 和 需求资源个数
      </strong>
     </span>
     <span style="color:#1f2329">
      基本也就确定了。
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      比如求
     </span>
     <span style="color:#1f2329">
      1 + 2 + 3 + ... + (
     </span>
     <span style="color:#1f2329">
      <em>
       n
      </em>
     </span>
     <span style="color:#1f2329">
      − 1) +
     </span>
     <span style="color:#1f2329">
      <em>
       n
      </em>
     </span>
     <span style="color:#1f2329">
      ，可以设计三种算法：
     </span>
    </div>
    <div>
    </div>
    <blockquote>
     <div>
      算法A ： 需要 开辟大小为N 的空间
     </div>
    </blockquote>
    <pre><code class="hljs">const int N = 1e5 + 10;
int a[N];
int sum(int n)
{
 // 先把 1 ~ n 存起来
 for(int i = 1; i &lt;= n; i++)
 {
     a[i] = i;
 }
 
 // 循环逐个数字相加
 int ret = 0;
 for(int i = 1; i &lt;= n; i++)
 {
     ret += a[i];
 }
 return ret;
}</code></pre>
    <blockquote>
     <p>
      算法B：不需要开辟空间 ， 直接求和；
     </p>
    </blockquote>
    <pre><code class="hljs">int sum(int n)
{
 // 循环逐个数字相加
 int ret = 0;
 for (int i = 1; i &lt;= n; i++) 
 {
     ret += i;
 }
 return ret;
}</code></pre>
    <p>
     <strong>
      算法执行所需资源的个数与问题的规模 n 有关 。因此可以根据算法执行过程中对空间的消耗来衡量算法的好坏 ， 这就是
      <span style="color:#fe2c24">
       空间复杂度 。
      </span>
     </strong>
    </p>
    <blockquote>
     <p>
      算法C：需要循环 n 次 ， ret += n 语句会执行 n 次 ， 而且随着问题规模的增长 ， 执行次数也会增长 。
     </p>
    </blockquote>
    <pre><code class="hljs">int sum(int n)
{
 int ret = 0;
 // 循环逐个数字相加
 for (int i = 1; i &lt;= n; i++) 
 {
     ret += i;
 }
 return ret;
}</code></pre>
    <blockquote>
     <p>
      算法D ： 不管问题规模 n 为多少 ， ( 1 + n ) * n / 2 语句只会执行1次。
     </p>
    </blockquote>
    <pre><code class="hljs">int sum(int n)
{
 // 利⽤求和公式
 return (1 + n) * n / 2;
}</code></pre>
    <p>
     算法中基本语句总的执行次数与问题规模 n 有关 。因此可以根据算法执行过程中 ，
     <strong>
      <span style="background-color:#ffd900">
       所有语句被执行的次数之和来衡量算法的好坏
      </span>
     </strong>
     ，
     <span style="color:#fe2c24">
      <strong>
       这就是时间复杂度
      </strong>
     </span>
     。
    </p>
    <p>
     综上所述 ，
     <strong>
      <span style="background-color:#ffd900">
       时间和空间的消耗情况
      </span>
     </strong>
     就是我们
     <span style="color:#fe2c24">
      <strong>
       度量一个算法好坏的标准
      </strong>
     </span>
     ， 也就是时间复杂度和空间复杂度 。
    </p>
    <h3>
    </h3>
    <h3>
     2.3 时间复杂度
    </h3>
    <p>
     在计算机中 ， 算法的时间复杂度是一个函数式
     <strong>
      T（N）
     </strong>
     ，
     <span style="color:#fe2c24">
      <strong>
       他定量描述了该算法的运行时间
      </strong>
     </span>
     。这个T（N）函数式
     <strong>
      <span style="background-color:#ffd900">
       计算了程序中语句的执行次数 。
      </span>
     </strong>
    </p>
    <blockquote>
     <p>
      计算一下 fun 中++count 语句总共执行了多少次 。
     </p>
    </blockquote>
    <pre><code class="hljs">void fun(int N) 
{ 
 int count = 0; 
 for(int i = 0; i &lt; N; i++) 
 { 
     for(int j = 0; j &lt; N; j++) 
     { 
         ++count; // 执⾏次数是 n*n，也就是 n^2
     } 
 } 
 for(int k = 0; k &lt; 2 * N; k++) 
 {
     ++count; // 执⾏次数是 2*n
 } 
 
 int M = 10; 
 while(M--) 
 { 
     ++count; // 执⾏次数 10
 } 
}</code></pre>
    <p class="img-center">
     <img alt="" height="1087" src="https://i-blog.csdnimg.cn/direct/6f8e32a22b404d12bcc6437e8c92eded.png" width="1853"/>
    </p>
    <p>
    </p>
    <h4>
     2.3.1 大O表示法
    </h4>
    <blockquote>
     <div>
      <span style="color:#1f2329">
       因此，在计算时间复杂度的时候，一
      </span>
      <span style="color:#0d0016">
       <strong>
        般会把中对结果影响不大的项忽略掉
       </strong>
      </span>
      <span style="color:#1f2329">
       ，这种表示时间复杂度的方式称
      </span>
      <span style="color:#fe2c24">
       <strong>
        为大 O 渐进时间复杂度 - 粗略的估计方式
       </strong>
      </span>
      <span style="color:#1f2329">
       ，
       <strong>
        只看影响时间开销最大的⼀项。
       </strong>
      </span>
     </div>
    </blockquote>
    <p class="img-center">
     <img alt="" height="451" src="https://i-blog.csdnimg.cn/direct/739cf7b1bc634ce8bf27ac14f7faf9b3.png" width="1011"/>
    </p>
    <p class="img-center">
     <img alt="" height="178" src="https://i-blog.csdnimg.cn/direct/54e0ccb88fd34da4af8f9aad968ff3ef.png" width="1430"/>
    </p>
    <p class="img-center">
     <img alt="" height="337" src="https://i-blog.csdnimg.cn/direct/bbc00280f98040aaa7bc18401af5c2cf.png" width="952"/>
    </p>
    <p class="img-center">
     <img alt="" height="343" src="https://i-blog.csdnimg.cn/direct/6e31fb533f2a4dff8ac2ab994607954b.png" width="1513"/>
    </p>
    <p>
    </p>
    <h4>
     2.3.2 最优、平均和最差时间复杂度
    </h4>
    <blockquote>
     <div>
      <span style="color:#1f2329">
       案例：在
      </span>
      <span style="color:#1f2329">
       <em>
        n
       </em>
      </span>
      <span style="color:#1f2329">
       个整形元素数组中，检测
      </span>
      <span style="color:#1f2329">
       <em>
        x
       </em>
      </span>
      <span style="color:#1f2329">
       是否存在，若存在返回其在数组中的下标，否则返回
      </span>
      <span style="color:#1f2329">
       −1
      </span>
      <span style="color:#1f2329">
       。
      </span>
     </div>
    </blockquote>
    <pre><code class="hljs">int find (int a[], int n, int x)
{
 for (int i = 0; i &lt; n; i++)
 {
     if (a[i] == x) 
     return i;
 }
     return -1;
}</code></pre>
    <p class="img-center">
     <img alt="" height="416" src="https://i-blog.csdnimg.cn/direct/a723ad7d94774c5196cd1c01c8ff58a4.png" width="1504"/>
    </p>
    <div>
     <span style="color:#1f2329">
      1） 在查找过程中，
     </span>
     <span style="color:#1f2329">
      <em>
       x
      </em>
      与数组中元素依次比较，
     </span>
     <span style="color:#fe2c24">
      <strong>
       因此总的比较次数就是该算法的时间复杂度。
      </strong>
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      ---&gt;   若待查找元素
     </span>
     <span style="color:#1f2329">
      <em>
       x
      </em>
     </span>
     <span style="color:#1f2329">
      为
     </span>
     <span style="color:#1f2329">
      21
     </span>
     <span style="color:#1f2329">
      ，只需要比较
     </span>
     <span style="color:#1f2329">
      1
     </span>
     <span style="color:#1f2329">
      次，为算法的
      <strong>
       最优(好)情况
      </strong>
      。
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      ---&gt;   若带查找元素
     </span>
     <span style="color:#1f2329">
      <em>
       x
      </em>
     </span>
     <span style="color:#1f2329">
      为
     </span>
     <span style="color:#1f2329">
      17 ，或者是不存在的元素，需要比较
      <em>
       n
      </em>
      次，为算法的
      <strong>
       最坏(差)情况
      </strong>
      。
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      ---&gt;   所有情况的比较 次数之和，除以总情况，为
      <strong>
       算法的平均情况。
      </strong>
     </span>
    </div>
    <div>
    </div>
    <div>
     <p class="img-center">
      <img alt="" height="527" src="https://i-blog.csdnimg.cn/direct/907d191e2aca446dbc29d07d30946090.png" width="1289"/>
     </p>
     <blockquote>
      <div>
       <span style="color:#1f2329">
        无论是在竞赛还是工程中，算法的时间复杂度⼀般为最差情况。
       </span>
       <span style="color:#fe2c24">
        <strong>
         因为最差情况是人对⼀件事情所能承受的底线
        </strong>
       </span>
       <span style="color:#1f2329">
        ，
        <strong>
         <span style="background-color:#ffd900">
          因此
         </span>
         <em>
          <span style="background-color:#ffd900">
           find
          </span>
         </em>
        </strong>
       </span>
       <strong>
        <span style="color:#1f2329">
         <span style="background-color:#ffd900">
          算法的时间复杂度为
         </span>
        </span>
        <span style="color:#1f2329">
         <em>
          <span style="background-color:#ffd900">
           O
          </span>
         </em>
        </span>
        <span style="color:#1f2329">
         <span style="background-color:#ffd900">
          (
         </span>
        </span>
        <span style="color:#1f2329">
         <em>
          <span style="background-color:#ffd900">
           n
          </span>
         </em>
        </span>
       </strong>
       <span style="color:#1f2329">
        <strong>
         <span style="background-color:#ffd900">
          )
         </span>
        </strong>
       </span>
       <span style="color:#1f2329">
        。
       </span>
      </div>
     </blockquote>
    </div>
    <p>
    </p>
    <h4>
     2.3.3 时间复杂度计算案例
    </h4>
    <p>
     案例一：
    </p>
    <p class="img-center">
     <img alt="" height="371" src="https://i-blog.csdnimg.cn/direct/bd094f30dec845d99af16747827bc7c2.png" width="450"/>
    </p>
    <p>
     案例二：
    </p>
    <p class="img-center">
     <img alt="" height="297" src="https://i-blog.csdnimg.cn/direct/ae638bc781ed478db2d69c7fd6ea3b79.png" width="450"/>
    </p>
    <blockquote>
     <div>
      <span style="color:#646a73">
       基本语句
      </span>
      <span style="color:#646a73">
       ++count
      </span>
      <span style="color:#646a73">
       关于问题规模
      </span>
      <span style="color:#1f2329">
       <em>
        n
       </em>
      </span>
      <span style="color:#646a73">
       总执行次数的数学表达式为:
      </span>
      <span style="color:#1f2329">
       <em>
        f
       </em>
      </span>
      <span style="color:#1f2329">
       (
      </span>
      <span style="color:#1f2329">
       <em>
        n
       </em>
      </span>
      <span style="color:#1f2329">
       ) = 1000
      </span>
      <span style="color:#646a73">
       ；
      </span>
     </div>
     <div>
      <span style="color:#646a73">
       不论
      </span>
      <span style="color:#1f2329">
       <em>
        n
       </em>
      </span>
      <span style="color:#646a73">
       如何变化，
      </span>
      <span style="color:#646a73">
       ++count 总的执行次数都是
      </span>
      <span style="color:#1f2329">
       1000
      </span>
      <span style="color:#646a73">
       ，
       <strong>
        <span style="background-color:#ffd900">
         故时间复杂度为：
        </span>
       </strong>
      </span>
      <strong>
       <span style="color:#1f2329">
        <em>
         <span style="background-color:#ffd900">
          O
         </span>
        </em>
       </span>
       <span style="color:#1f2329">
        <span style="background-color:#ffd900">
         (1)
        </span>
       </span>
       <span style="color:#646a73">
        <span style="background-color:#ffd900">
         。
        </span>
       </span>
      </strong>
     </div>
    </blockquote>
    <p>
     案例三：
    </p>
    <pre><code class="hljs">void func3(int m, int n)
{
     for (int i = 0; i &lt; m; i++)
     {
     printf("hello\n");
     }
 
     for (int i = 0; i &lt; n; i++)
     {
     printf("hello\n");
     }
}</code></pre>
    <blockquote>
     <div>
      <span style="color:#0d0016">
       <strong>
        基本语句 printf("") 总的执行次数为
        <em>
         f
        </em>
        (
        <em>
         m
        </em>
        ,
        <em>
         n
        </em>
        ) =
        <em>
         m
        </em>
        +
        <em>
         n
        </em>
        ；
       </strong>
      </span>
     </div>
     <div>
      <span style="color:#646a73">
       m 和 n 的变化都是影响基本语句执行次数，
      </span>
      <span style="color:#fe2c24">
       <strong>
        即m  和 n 都是问题规模，
       </strong>
      </span>
      <span style="color:#646a73">
       故时间复杂度为
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       <em>
        O
       </em>
      </span>
      <span style="color:#1f2329">
       (
      </span>
      <span style="color:#1f2329">
       <em>
        m
       </em>
      </span>
      <span style="color:#1f2329">
       +
      </span>
      <span style="color:#1f2329">
       <em>
        n
       </em>
      </span>
      <span style="color:#1f2329">
       )
      </span>
      <span style="color:#646a73">
       ，
      </span>
      <span style="color:#fe2c24">
       <strong>
        或者也可以表示为
        <em>
         O
        </em>
        (
        <em>
         max（m,n))
        </em>
        。
       </strong>
      </span>
     </div>
    </blockquote>
    <p>
     案例四：
    </p>
    <p class="img-center">
     <img alt="" height="297" src="https://i-blog.csdnimg.cn/direct/c2df428457464f9bb3f6c0a9173a2d7e.png" width="450"/>
    </p>
    <blockquote>
     <p>
      <span style="color:#0d0016">
       <strong>
        基本语句 printf("") 总的执行次数为
        <em>
         f
        </em>
        (
        <em>
         m
        </em>
        ,
        <em>
         n
        </em>
        ) =
        <em>
         m x
        </em>
        <em>
         n
        </em>
        ；
       </strong>
      </span>
     </p>
     <div>
      <span style="color:#646a73">
       m 和 n 的变化都是影响基本语句执行次数，
      </span>
      <span style="color:#fe2c24">
       <strong>
        即m  和 n 都是问题规模，
       </strong>
      </span>
      <span style="color:#646a73">
       故时间复杂度为
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       <em>
        O
       </em>
      </span>
      <span style="color:#1f2329">
       (
      </span>
      <span style="color:#1f2329">
       <em>
        m x
       </em>
      </span>
      <span style="color:#1f2329">
      </span>
      <span style="color:#1f2329">
       <em>
        n
       </em>
      </span>
      <span style="color:#1f2329">
       )
      </span>
     </div>
    </blockquote>
    <p>
     案例5：
    </p>
    <pre><code class="hljs">void func5(int n)
{
     int cnt = 1;
     while (cnt &lt; n)
     {
     cnt *= 2;
     }
}</code></pre>
    <p class="img-center">
     <img alt="" height="388" src="https://i-blog.csdnimg.cn/direct/122a66fa56484190b93b8696cf99d7d1.png" width="1030"/>
    </p>
    <p>
     案例六：
    </p>
    <p class="img-center">
     <img alt="" height="250" src="https://i-blog.csdnimg.cn/direct/74f344283d6449d1a3d1d809dafe619a.png" width="450"/>
    </p>
    <div>
     <strong>
      <span style="color:#1f2329">
       <span style="background-color:#ffd900">
        递归算法时间复杂度求解方式为，单次递归时间 × 总的递归次数。
       </span>
      </span>
     </strong>
    </div>
    <div>
    </div>
    <blockquote>
     <div>
      <span style="color:#646a73">
       注意，这里只是简易的估算方式。递归算法的时间复杂度严谨的计算方法是
      </span>
      <span style="color:#0d0016">
       <strong>
        利用主定理
       </strong>
      </span>
      <span style="color:#646a73">
       (Master Theorem)来求得递归算法的时间复杂度
      </span>
      <span style="color:#1f2329">
       。
      </span>
     </div>
     <div>
      <span style="color:#1f2329">
       O( n )
      </span>
     </div>
    </blockquote>
    <p>
    </p>
    <h3>
     2.4 空间复杂度
    </h3>
    <blockquote>
     <div>
      <span style="color:#1f2329">
       在算法竞赛中，空间复杂度就是整个程序在解决这个问题时，
      </span>
      <span style="color:#fe2c24">
       <strong>
        ⼀共使用了多少空间。相比较于时间复杂度，空间复杂度就没那么受关注，因为多数情况下题目所给的内存限制是非常宽裕的。
       </strong>
      </span>
      <span style="color:#1f2329">
       但是，这并不表明可以肆无忌惮的使用空间，一旦超出给定的限制，程序也是不会通过的。 - MLE
      </span>
     </div>
    </blockquote>
    <p>
     案例一：冒泡排序
    </p>
    <pre><code class="hljs">#include &lt;iostream&gt;
using namespace std;

const int N = 20;
int arr[N];

int main()
 {
	int n = 0;
	cin &gt;&gt; n;
	int i = 0;
 	//输入 
	 for(i=0; i &lt; n; i++)
	 	cin &gt;&gt; arr[i];
	 //排序
	 for(i = 0; i &lt; n-1; i++)
	 {
		 int j = 0;
		 for(j = 0; j &lt;= n-1-i; j++)
		 {
			if(arr[j] &lt; arr[j+1])
			 {
				 int tmp = arr[j];
				 arr[j] = arr[j+1];
				 arr[j+1] = tmp; 
			 }
		 }
	 } 
	 //输出
	for(i=0; i &lt; n; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
 	return 0;
 }</code></pre>
    <p class="img-center">
     <img alt="" height="163" src="https://i-blog.csdnimg.cn/direct/35b0becde220424ba278ce9cfc5ce749.png" width="801"/>
    </p>
    <p>
     案例二：递归求阶乘
    </p>
    <p class="img-center">
     <img alt="" height="529" src="https://i-blog.csdnimg.cn/direct/a165230b3bd7499085ee57efeba0d230.png" width="850"/>
    </p>
    <p>
    </p>
    <h3>
     2.5 常见复杂度的增长对比
    </h3>
    <p class="img-center">
     <img alt="" height="732" src="https://i-blog.csdnimg.cn/direct/40338c5ea15f4aaf8c7762d54805f855.png" width="1619"/>
    </p>
    <p class="img-center">
     <img alt="" height="922" src="https://i-blog.csdnimg.cn/direct/78fcfdc2d18e46b6a72f27b36f8e47da.png" width="1572"/>
    </p>
    <p class="img-center">
     <img alt="" height="191" src="https://i-blog.csdnimg.cn/direct/3e049b6e1616441aa0ec5be38071472f.png" width="1464"/>
    </p>
    <p>
    </p>
    <h3 style="background-color:transparent">
     2.6 算法中的时间和空间限制
    </h3>
    <blockquote>
     <div>
      <span style="color:#0d0016">
       <strong>
        1. 信息学竞赛中，C++ 通常设定 1 到 2 秒的时间限制，运行次数在 10^7 ⾄ 10^8 之间。
       </strong>
      </span>
     </div>
     <div>
     </div>
     <div>
      <strong>
       <span style="color:#0d0016">
        2.空间限制在128MB 或 256MB ，可以开⼀个3 x 10 ^7 大小的int  类型数组，或者5000x5000大小的二维数组，⼀般情况下都是够⽤的。
       </span>
      </strong>
     </div>
    </blockquote>
    <div>
     <strong>
      <span style="color:#1f2329">
       <span style="background-color:#ffd900">
        各种数据量下，可选用的算法的时间复杂度：
       </span>
      </span>
     </strong>
    </div>
    <div>
     <p class="img-center">
      <img alt="" height="866" src="https://i-blog.csdnimg.cn/direct/b09ca35f206643589db4bdd699820492.png" width="1688"/>
     </p>
    </div>
    <h2>
     三、STL
    </h2>
    <h3>
     3.1 C++标准库
    </h3>
    <div>
     <span style="color:#1f2329">
      1） C++标准是C++编程语言的规范，由国际标准化组织（ISO）制定。C++标准的发展历程可以追溯到 1998年，当时ISO/IEC 14882:1998标准被发布，这是第⼀个C++标准，常被称为C++98。随后，C++标准经历了多次更新和修订，包括C++03（2003年）、C++11（2011年）、C++14（2014年）、C++17（2017年）以及 C++20。
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      2）最新的C++标准是C++23，于2023年发布，引入了许多新特性，
     </span>
     <span style="color:#fe2c24">
      <strong>
       但目前完整的编译器较少。
      </strong>
     </span>
     <span style="color:#1f2329">
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      3）每⼀个版本的 C++ 标准不仅规定了 C++ 的语法、语言特性，还规定了⼀套 C++ 内置库的实现规范，这个库便是 C++ 标准库。C++ 标准库中包含大量常用代码的实现，如输入输出、基本数据结构、内存管理、多线程支持等。
     </span>
    </div>
    <div>
    </div>
    <div>
     <span style="color:#1f2329">
      4）
      <strong>
       <span style="background-color:#ffd900">
        我们可以这样简单的理解，C++ 给我们提供了一大堆的代码，这些代码里面包含特别多已经实现好的
       </span>
      </strong>
     </span>
     <span style="color:#1f2329">
      <strong>
       <span style="background-color:#ffd900">
        数据结构 和 算法
       </span>
      </strong>
      。
     </span>
     <span style="color:#fe2c24">
      <strong>
       因此，在做题的时候，如果涉及的数据结构和算法 C++ 标准库已经帮我们实现好
      </strong>
     </span>
     <span style="color:#fe2c24">
      <strong>
       了，那么就可以直接使用，避免重复造轮子
      </strong>
     </span>
     <span style="color:#1f2329">
      。
     </span>
     <span style="color:#0d0016">
      <strong>
       --- sort / min / max / swap
      </strong>
     </span>
    </div>
    <div>
    </div>
    <blockquote>
     <div>
      <span style="color:#0d0016">
       <strong>
        1） 造轮子指的是重复发明已有的算法，或者重复编写现成优化过的代码。
       </strong>
      </span>
     </div>
     <div>
      <span style="color:#0d0016">
       <strong>
        2）造轮子通常耗时好力，同时效果还没有别人好。但若是为了学习或者练习，造轮子则是必要的。
       </strong>
      </span>
     </div>
    </blockquote>
    <div>
     <span style="color:#1f2329">
      因此，学好 C++ 标准库能极大的提高编程效率。
     </span>
    </div>
    <p>
    </p>
    <h3>
     3.2 什么是STL？
    </h3>
    <div>
     <span style="color:#1f2329">
      <strong>
       <span style="background-color:#ffd900">
        STL 即标准模板库（Standard Template Library）
       </span>
      </strong>
      ，是 C++ 标准库的一部分，
     </span>
     <span style="color:#fe2c24">
      <strong>
       里面包含了⼀些模板化的通过用的数据结构和算法
      </strong>
     </span>
     <span style="color:#1f2329">
      。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      NOI 和 ICPC 赛事都支持 STL 库的使用，当然，
     </span>
     <span style="color:#fe2c24">
      <strong>
       蓝桥杯也是支持的
      </strong>
     </span>
     <span style="color:#1f2329">
      。因此，⼀定要学习 STL 的使用，
     </span>
     <span style="color:#0d0016">
      <strong>
       能够极大的提高编写代码的效率。
      </strong>
     </span>
    </div>
    <p>
    </p>
    <h3 style="background-color:transparent">
     3.3 怎么学习STL？
    </h3>
    <div>
     <span style="color:#fe2c24">
      <strong>
       模范使用！！！
      </strong>
     </span>
     <span style="color:#1f2329">
      STL 的实现涉及比较⾼深的 C++ 知识，
     </span>
     <span style="color:#0d0016">
      <strong>
       比如类、模板、容器适配器等
      </strong>
     </span>
     <span style="color:#1f2329">
      。如果想 搞清楚背后的原理，就必须要学会这些知识。但是这些知识在竞赛中是用不到的，如果深究，会浪费
     </span>
    </div>
    <div>
     <span style="color:#1f2329">
      大量无用的时间。
      <strong>
       <span style="background-color:#ffd900">
        因此，目前先把重点放在如何使用上
       </span>
      </strong>
      。
     </span>
    </div>
   </div>
  </div>
 </article>
 <p alt="6874747073:3a2f2f626c6f672e6373646e2e6e65742f6b686a6a6a67642f:61727469636c652f64657461696c732f313436303533363735" class_="artid" style="display:none">
 </p>
</div>


