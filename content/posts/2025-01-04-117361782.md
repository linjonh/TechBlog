---
layout: post
title: 一文看懂Java内存模型JMM
date: 2025-01-04 09:07:12 +0800
categories: ['Jvm']
tags: ['新星计划', '原力计划', 'Jvm', 'Java', 'Jmm']
image:
    path: https://img-blog.csdnimg.cn/20210528143337584.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2MxNTE1ODAzMjMxOQ&#61;&#61;,size_16,color_FFFFFF,t_70#pic_center,width&#61;&#39;40%25&#39;
    alt: 一文看懂Java内存模型JMM
artid: 117361782
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=117361782
featuredImagePreview: https://bing.ee123.net/img/rand?artid=117361782
---
<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     一文看懂Java内存模型（JMM）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atelier-sulphurpool-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <div class="toc">
     <h4>
      文章目录
     </h4>
     <ul>
      <li>
       <ul>
        <li>
         <a href="#Java_1" rel="nofollow">
          Java内存模型介绍
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#_2" rel="nofollow">
            总览图
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#Java_3" rel="nofollow">
              Java内存模型图
             </a>
            </li>
            <li>
             <a href="#_6" rel="nofollow">
              线程、主内存、工作内存关系图
             </a>
            </li>
            <li>
             <a href="#CPU_10" rel="nofollow">
              CPU缓存架构图
             </a>
            </li>
            <li>
             <a href="#Java_12" rel="nofollow">
              Java内存模型与硬件内存架构的关系
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#Java_15" rel="nofollow">
            什么是Java内存模型
           </a>
          </li>
          <li>
           <a href="#Java_21" rel="nofollow">
            Java内存模型的意义
           </a>
          </li>
          <li>
           <a href="#Java_31" rel="nofollow">
            Java内存模型规范
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#Java_43" rel="nofollow">
          Java内存模型的主要结构
         </a>
        </li>
        <li>
         <ul>
          <li>
           <a href="#1Program_Counter_Register_66" rel="nofollow">
            1、程序计数器（Program Counter Register）
           </a>
          </li>
          <li>
           <a href="#2Java_Java_Virtual_Machine_Stacks_82" rel="nofollow">
            2、Java 虚拟机栈（Java Virtual Machine Stacks）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#Stack_Frame_93" rel="nofollow">
              栈帧（Stack Frame）
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#3Native_Method_Stacks_109" rel="nofollow">
            3、本地方法栈（Native Method Stacks）
           </a>
          </li>
          <li>
           <a href="#4Heap_116" rel="nofollow">
            4、堆（Heap）
           </a>
          </li>
          <li>
           <a href="#4Method_Area_127" rel="nofollow">
            4、方法区（Method Area）
           </a>
          </li>
          <li>
           <ul>
            <li>
             <a href="#Runtime_Constant_Pool_145" rel="nofollow">
              运行时常量池（Runtime Constant Pool）
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a href="#5Direct_Memory_157" rel="nofollow">
            5、直接内存（Direct Memory）
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#JMM_164" rel="nofollow">
          JMM与八大原子操作
         </a>
        </li>
        <li>
         <a href="#Java_194" rel="nofollow">
          Java内存的访问方式
         </a>
        </li>
        <li>
         <a href="#Java_213" rel="nofollow">
          Java内存加载和使用对象
         </a>
        </li>
        <li>
         <a href="#Java_215" rel="nofollow">
          Java内存垃圾回收
         </a>
        </li>
        <li>
         <a href="#_217" rel="nofollow">
          字节码执行引擎
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </div>
    <p>
    </p>
    <h3>
     <a id="Java_1">
     </a>
     Java内存模型介绍
    </h3>
    <h4>
     <a id="_2">
     </a>
     总览图
    </h4>
    <h5>
     <a id="Java_3">
     </a>
     Java内存模型图
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/694735b84541fc987528710401c11f37.png#pic_center"/>
    </p>
    <h5>
     <a id="_6">
     </a>
     线程、主内存、工作内存关系图
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/fb7334ea7e8b482f210ce73b920202a6.png"/>
    </p>
    <h5>
     <a id="CPU_10">
     </a>
     CPU缓存架构图
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/968248a6a77c2975b001ea02e5c13fd7.png"/>
    </p>
    <h5>
     <a id="Java_12">
     </a>
     Java内存模型与硬件内存架构的关系
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/9e7b48f5fbf959772f5acf96d0978786.png"/>
    </p>
    <h4>
     <a id="Java_15">
     </a>
     什么是Java内存模型
    </h4>
    <p>
     所谓内存模型就是对特定的内存或者高速缓存进行读写访问的过程抽象描述和约定，不同架构下的物理机或者操作系统拥有不一样的内存模型，而
     <strong>
      Java虚拟机
     </strong>
     是一个实现了跨平台的虚拟系统。
    </p>
    <p>
     首先它不是对物理内存的规范，而是在Java虚拟机基础上进行的规范从而实现平台一致性，以达到Java程序能够**“一次编译，到处运行”**的目标。
    </p>
    <h4>
     <a id="Java_21">
     </a>
     Java内存模型的意义
    </h4>
    <p>
     在多核系统中，处理器一般有一层或者多层的缓存，这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足许多内存操作）来提高CPU性能。缓存能够大大提升性能，但是它们也带来了许多挑战。每个处理器的缓存都是私有的，而它们又共享同一内存，当有多个处理器的操作涉及同一块内存区域的时候，他们的缓存可能会因为运算而导致不一致，在这种情况下，同步回内存的数据以谁的为准呢？这就是缓存一致性问题。
    </p>
    <p>
     编译器在编译的时候，允许重排序指令以优化运行速度。CPU在执行指令的时候，为了使处理器内部运算单元能被充分利用，也可以对指令进行乱序执行。
    </p>
    <p>
     在编译器和CPU进行重排序的时候，要遵循“as-if-serial”原则，也就是要保证程序
     <strong>
      单线程
     </strong>
     执行的时候，重排序之后程序的运行结果必须和重排序前程序的运行结果一致。这里注意“as-if-serial”原则只保证单线程的执行结果不变，不保证多线程执行的结果不变。那么如何保证多线程程序的正确运行？显然需要某种协议来限定多线程执行时要满足的规则。
    </p>
    <p>
     为了解决
     <strong>
      缓存一致性
     </strong>
     和
     <strong>
      cpu指令重排序
     </strong>
     的问题，同时屏蔽不同机器下CPU架构不一致的问题,于是java就定义了一种协议，这个协议就是
     <strong>
      Java内存模型
     </strong>
     (JMM)。
    </p>
    <h4>
     <a id="Java_31">
     </a>
     Java内存模型规范
    </h4>
    <p>
     在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。
    </p>
    <p>
     官方提供的关于Java内存模型和线程规范是JSR-133规范，由JSR-133专家组开发。
    </p>
    <p>
     <a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf" rel="nofollow">
      JSR-133中文版下载
     </a>
    </p>
    <p>
     JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。
    </p>
    <p>
     需要注意的是java内存模型仅仅是定义了一个规范，不同的JVM它的实现可能不尽相同，本文所介绍的以
     <strong>
      Hotspot虚拟机
     </strong>
     （它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机）为准。
    </p>
    <h3>
     <a id="Java_43">
     </a>
     Java内存模型的主要结构
    </h3>
    <p>
     java虚拟机的结构主要分为四大块：类加载子系统、垃圾回收器、运行时数据区、字节码加载子系统。
    </p>
    <p>
     关于类加载子系统的原理可以参考这篇：
     <a href="https://blog.csdn.net/c15158032319/article/details/117262629">
      Java对象的生命周期
     </a>
    </p>
    <p>
     Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，这便是运行时数据区的结构，也可以看作为java内存模型的主要结构，其中又分为线程共享区和线程私有区。
    </p>
    <ul>
     <li>
      <p>
       线程私有
      </p>
      <ul>
       <li>
        程序计数器
       </li>
       <li>
        虚拟机栈
       </li>
       <li>
        本地方法栈
       </li>
      </ul>
     </li>
     <li>
      <p>
       线程共享
      </p>
      <ul>
       <li>
        堆
       </li>
       <li>
        元空间（以前叫方法区）
       </li>
      </ul>
      <p>
       如下图所示：
       <br/>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/d8a1de95c5a2e764e6516ebbaa495f22.png#pic_center"/>
      </p>
     </li>
    </ul>
    <h4>
     <a id="1Program_Counter_Register_66">
     </a>
     1、程序计数器（Program Counter Register）
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/925ddf3c7e71c90d7a1fd74def50ad81.png#pic_center"/>
    </p>
    <p>
     ​ 首先程序计数器是线程私有的，同时也是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    </p>
    <p>
     ​ 由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。
    </p>
    <p>
     ​ 如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。
    </p>
    <p>
     总结主要有两个作用：
    </p>
    <ul>
     <li>
      字节码解释器通过改变程序计数器依次读取指令，实现代码的流程控制，如：顺序执行、选择、循环、异常处理
     </li>
     <li>
      多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了
     </li>
    </ul>
    <h4>
     <a id="2Java_Java_Virtual_Machine_Stacks_82">
     </a>
     2、Java 虚拟机栈（Java Virtual Machine Stacks）
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/2117473f0223ff3778fbd3c4c1f1b26d.png#pic_center"/>
    </p>
    <p>
     ​ 与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
    </p>
    <p>
     ​ 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
    </p>
    <p>
     ​ 在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。
    </p>
    <h5>
     <a id="Stack_Frame_93">
     </a>
     栈帧（Stack Frame）
    </h5>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/ce4893ec8828589c435a09b100fcbf21.png#pic_center"/>
    </p>
    <ul>
     <li>
      <p>
       栈帧是方法运行的基本结构，一个栈帧即对应一个方法。
      </p>
     </li>
     <li>
      <p>
       正在执行的方法称为
       <strong>
        当前活动栈帧
       </strong>
      </p>
     </li>
     <li>
      <p>
       在执行引擎运行时，所有指令都只能针对
       <strong>
        当前活动栈帧
       </strong>
       操作
      </p>
     </li>
     <li>
      <p>
       压栈过多会产生StackOverflowError异常，表示请求的栈溢出，导致线程可用内存耗尽，通常出现于递归方法深度过大或者死递归情况，默认分配的内存大小为1M，可以使用-Xss 参数配置栈空间大小。
      </p>
     </li>
     <li>
      <p>
       虚拟机栈通过压/出栈，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，则跳转到另一个栈帧上。
      </p>
     </li>
     <li>
      <p>
       在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。
      </p>
     </li>
    </ul>
    <p>
     关于栈帧的详细原理请参考
     <a href="https://blog.csdn.net/c15158032319/article/details/117623402">
      Java代码的执行原理
     </a>
    </p>
    <h4>
     <a id="3Native_Method_Stacks_109">
     </a>
     3、本地方法栈（Native Method Stacks）
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/66da27d454c1234f22ad4c3d5ff5089e.png#pic_center"/>
    </p>
    <p>
     ​ 本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。
    </p>
    <h4>
     <a id="4Heap_116">
     </a>
     4、堆（Heap）
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/b09c3fd7dc44f4e3624475aa44ba4b5f.png"/>
    </p>
    <p>
     ​ Java 堆通常是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
    </p>
    <p>
     ​ Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都不会改变存放内容，进一步划分的目的是为了更好更快地分配和回收内存。
    </p>
    <p>
     ​ 根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 配置参数控制）。如果在堆中没有完成实例分配内存，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。
    </p>
    <h4>
     <a id="4Method_Area_127">
     </a>
     4、方法区（Method Area）
    </h4>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/4df84fd149686c2c81ee376c89e1c515.png#pic_center"/>
    </p>
    <p>
     ​ 方法区也叫永久代(Permanent Generation Space)，在JDK8以后，又被称为元空间（Metaspace)。
    </p>
    <p>
     ​ 方法区与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，在JDK8以后，已经放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。
    </p>
    <p>
     ​ Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。
    </p>
    <p>
     ​ 在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。
    </p>
    <p>
     堆大小配置不会影响元空间大小，因为Metaspace是一个堆外数据区。为了限制Metaspace大小，我们可以使用以下方式配置：
    </p>
    <ul>
     <li>
      -XX：MetaspaceSize和-XX：MaxMetaspaceSize设置最小和最大元空间大小
     </li>
     <li>
      在Java 8之前，-XX：PermSize和-XX：MaxPermSize设置最小和最大PermGen大小
     </li>
    </ul>
    <h5>
     <a id="Runtime_Constant_Pool_145">
     </a>
     运行时常量池（Runtime Constant Pool）
    </h5>
    <p>
     <strong>
      运行时常量池
     </strong>
     是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。
    </p>
    <p>
     **JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**所以，准确来讲，
     <strong>
      运行时常量池
     </strong>
     又只能说逻辑上是属于方法区的。
    </p>
    <p>
     ​ Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
    </p>
    <p>
     ​ 运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。
    </p>
    <p>
     ​ 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再从方法区（元空间）申请到内存时会抛出OutOfMemoryError 异常。
    </p>
    <h4>
     <a id="5Direct_Memory_157">
     </a>
     5、直接内存（Direct Memory）
    </h4>
    <p>
     ​ 直接内存(也就是本地内存)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是要使用Java内存模型则必须和直接内存打交道，同时这部分内存也被频繁地使用，也可能导致OutOfMemoryError 异常出现。
    </p>
    <p>
     ​ 在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。
    </p>
    <p>
     ​ 我们可以使用 -XX:MaxDirectMemorySize 设置最大直接内存。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。
    </p>
    <h3>
     <a id="JMM_164">
     </a>
     JMM与八大原子操作
    </h3>
    <p>
     关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。
    </p>
    <p>
     <strong>
      八大原子操作：
     </strong>
    </p>
    <ul>
     <li>
      lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
     </li>
     <li>
      unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
     </li>
     <li>
      read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
     </li>
     <li>
      load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
     </li>
     <li>
      use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
     </li>
     <li>
      assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
     </li>
     <li>
      store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
     </li>
     <li>
      write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
      <br/>
      如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/7dd02918f8e1c472b9b3bbf06a6914d8.png"/>
    </p>
    <p>
     <strong>
      同时Java内存模型还规定了在执行上述八种原子操作时必须满足如下规则：
     </strong>
    </p>
    <ul>
     <li>
      不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
     </li>
     <li>
      不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
     </li>
     <li>
      不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
     </li>
     <li>
      一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。
     </li>
     <li>
      一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
     </li>
     <li>
      如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。
     </li>
     <li>
      如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
     </li>
     <li>
      对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。
     </li>
    </ul>
    <p>
     由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定）
    </p>
    <h3>
     <a id="Java_194">
     </a>
     Java内存的访问方式
    </h3>
    <p>
     逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？
    </p>
    <p>
     在Java 语言中，对象访问是如何进行的？对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：
    </p>
    <p>
     Object obj = new Object();
    </p>
    <p>
     假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。
    </p>
    <p>
     由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有以下两种：
    </p>
    <ul>
     <li>
      <strong>
       句柄
      </strong>
      ：使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/3e84eae82b6344b04d05f1a2bd07a50c.png#pic_center"/>
    </p>
    <ul>
     <li>
      <strong>
       直接指针
      </strong>
      ：使用直接指针的方式，引用中存储的就是对象的地址。这也是Hotspot虚拟机采用的方式。
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/blog_migrate/102c82ac5232b61b59df2da7597813eb.png#pic_center"/>
    </p>
    <h3>
     <a id="Java_213">
     </a>
     Java内存加载和使用对象
    </h3>
    <p>
     请参考
     <a href="https://blog.csdn.net/c15158032319/article/details/117262629">
      Java对象的生命周期
     </a>
    </p>
    <h3>
     <a id="Java_215">
     </a>
     Java内存垃圾回收
    </h3>
    <p>
     请参考
     <a href="https://blog.csdn.net/c15158032319/article/details/117450062">
      JVM垃圾回收机制深入解析
     </a>
    </p>
    <h3>
     <a id="_217">
     </a>
     字节码执行引擎
    </h3>
    <p>
     请参考
     <a href="https://blog.csdn.net/c15158032319/article/details/117623402">
      Java代码的执行原理
     </a>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
</div>


