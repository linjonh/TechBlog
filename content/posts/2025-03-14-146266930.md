---
layout: post
title: "JVM的各种细节"
date: 2025-03-14 20:39:15 +08:00
description: "内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。"
keywords: "JVM的各种细节"
categories: ['未分类']
tags: ['Jvm']
artid: "146266930"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146266930
    alt: "JVM的各种细节"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146266930
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146266930
cover: https://bing.ee123.net/img/rand?artid=146266930
image: https://bing.ee123.net/img/rand?artid=146266930
img: https://bing.ee123.net/img/rand?artid=146266930
---

# JVM的各种细节
### (1)\*\*JVM 核心结构（必须知道）\*\*
1. \*\*类加载器\*\*
\* 负责将`.class`()文件加载到内存中，供 JVM 使用。
2. \*\*方法区\*\*
\* 存储类元数据（类名、字段、方法）、常量池、静态变量等。
\* \*\*JDK 8+\*\* ：由元空间（Metaspace）替代，使用本地内存。
3. \*\*Java 堆\*\*
\* 所有线程共享的内存区域，存放对象实例和数组。
\* 分代管理（新生代、老年代），通过垃圾回收自动清理。
4. \*\*Java 栈\*\*
\* 线程私有内存，存储方法调用的栈帧（局部变量、操作数栈、动态链接）。
\* \*\*常见异常\*\* ：栈溢出（StackOverflowError）。
5. \*\*直接内存\*\*
\* 非堆内存，直接使用系统物理内存（如 NIO 缓冲区）。
### (2)JVM中的垃圾回收机制
###### \*\*新生代回收（复制算法）\*\*
\* \*\*策略\*\* ：将内存划分为两个大小相等的区域（Eden 区 + 2 个 幸存者区）。
\* 流程：
1. 对象优先分配到 Eden 区，当 Eden 区满时触发 新生代垃圾回收。
2. 存活对象被复制到其中一个 幸存者区，清空 Eden 和另一个 幸存者区。
3. 后续 GC 中，存活对象在 From(烦) 区和 To(tu) 区之间复制，直到达到默认临界值（如 15 次）后进入老年代。
###### \*\*老年代回收（标记 - 整理算法）\*\*
\* \*\*策略\*\* ：当老年代内存不足时触发 Full GC。
\* 流程：
1. 标记所有存活对象。
2. 将存活对象向一端移动，清理边界外的内存。
3. 若回收后仍无足够空间，抛出内存溢出错误`。
### (3)垃圾回收机制是什么
JVM 通过分代策略和不同引用类型的处理，高效管理内存。理解新生代与老年代的回收差异，以及引用类型对对象生命周期的影响，是优化 Java 程序性能的关键。
\* \*\*强引用\*\* ：默认引用，对象必须被显式释放才会被回收。
\* \*\*软引用\*\* ：内存不足时触发回收（适用于缓存场景）。
\* \*\*弱引用\*\* ：GC 时立即回收（如 ThreadLocal 的 Entry）。
\* \*\*虚引用\*\* ：仅用于跟踪对象是否被回收，无法通过虚引用获取对象。
### (4). 垃圾回收算法\*\*
###### \*\*标记 - 清除算法\*\*
\* \*\*步骤\*\* ：标记存活对象 → 清除未标记对象。
\* \*\*缺点\*\* ：产生内存碎片，影响后续分配效率。
###### \*\*复制算法\*\*
\* \*\*步骤\*\* ：将存活对象复制到另一块空间 → 清空原空间。
\* \*\*适用场景\*\* ：新生代（对象存活率低）。
\* \*\*优点\*\* ：无内存碎片，速度快；\*\*缺点\*\* ：需双倍内存。
###### \*\*标记 - 整理算法\*\*
\* \*\*步骤\*\* ：标记存活对象 → 将存活对象向一端移动 → 清除边界外的内存。
\* \*\*适用场景\*\* ：老年代（对象存活率高）。
\* \*\*优点\*\* ：减少内存碎片。
### (5)什么是内存溢出？什么是内存泄露？
内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。
内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽
略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。
### (6)\*\*JVM 性能调优核心参数（精简版）\*\*
###### \*\*1\. 堆内存配置\*\*
\* \*\*`-Xmx`\*\* ：设置堆内存最大限制（如`-Xmx8g`）。 \*\*关键作用\*\* ：避免因内存不足导致 OOM。
###### \*\*2\. 新生代参数\*\*
\* \*\*`-XX:NewSize`\*\* ：初始新生代大小（建议与`-XX:MaxNewSize`一致）。
\* \*\*`-XX:NewRatio`\*\* ：新生代与老年代内存比例（默认 2，即新生代占 1/3）。
\* -XX:SurvivorRatio`\*\*：Eden 区与单个 幸存者区的比例（默认 8）。
###### \*\*3\. 垃圾回收器选择\*\*
\*\*区域\*\*| \*\*参数\*\*| \*\*适用场景\*\*
---|---|---
\*\*年轻代\*\*| `-XX:+UseParNewGC`| 多线程，低延迟
\*\*老年代\*\*| `-XX:+UseConcMarkSweepGC`| 并发回收，适合 Web 应用
### （7)接口中新增了什么属性
1、默认方法 Java8允许接口中包含具体实现的方法体，该方法是默认方法，它需要使用默认关键字修饰 2、静态方法
Java8中允许接口中定义静态方法，使用静态关键字修饰