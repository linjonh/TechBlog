---
layout: post
title: "JVM的各种细节"
date: 2025-03-14 20:39:15 +0800
description: "内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。"
keywords: "JVM的各种细节"
categories: ['未分类']
tags: ['Jvm']
artid: "146266930"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146266930
    alt: "JVM的各种细节"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146266930
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146266930
cover: https://bing.ee123.net/img/rand?artid=146266930
image: https://bing.ee123.net/img/rand?artid=146266930
img: https://bing.ee123.net/img/rand?artid=146266930
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM的各种细节
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     (1)
     <strong>
      JVM 核心结构（必须知道）
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        类加载器
       </strong>
      </p>
      <ul>
       <li>
        <p>
         负责将
         <code>
          .class
         </code>
         ()文件加载到内存中，供 JVM 使用。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        方法区
       </strong>
      </p>
      <ul>
       <li>
        <p>
         存储类元数据（类名、字段、方法）、常量池、静态变量等。
        </p>
       </li>
       <li>
        <p>
         <strong>
          JDK 8+
         </strong>
         ：由元空间（Metaspace）替代，使用本地内存。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Java 堆
       </strong>
      </p>
      <ul>
       <li>
        <p>
         所有线程共享的内存区域，存放对象实例和数组。
        </p>
       </li>
       <li>
        <p>
         分代管理（新生代、老年代），通过垃圾回收自动清理。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        Java 栈
       </strong>
      </p>
      <ul>
       <li>
        <p>
         线程私有内存，存储方法调用的栈帧（局部变量、操作数栈、动态链接）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          常见异常
         </strong>
         ：栈溢出（StackOverflowError）。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        直接内存
       </strong>
      </p>
      <ul>
       <li>
        <p>
         非堆内存，直接使用系统物理内存（如 NIO 缓冲区）。
        </p>
       </li>
      </ul>
      <h3>
       (2)JVM中的垃圾回收机制
      </h3>
      <h6>
       <strong>
        新生代回收（复制算法）
       </strong>
      </h6>
      <ul>
       <li>
        <p>
         <strong>
          策略
         </strong>
         ：将内存划分为两个大小相等的区域（Eden 区 + 2 个 幸存者区）。
        </p>
       </li>
       <li>
        <p>
         流程：
        </p>
        <ol>
         <li>
          <p>
           对象优先分配到 Eden 区，当 Eden 区满时触发 新生代垃圾回收。
          </p>
         </li>
         <li>
          <p>
           存活对象被复制到其中一个 幸存者区，清空 Eden 和另一个 幸存者区。
          </p>
         </li>
         <li>
          <p>
           后续 GC 中，存活对象在 From(烦) 区和 To(tu) 区之间复制，直到达到默认临界值（如 15 次）后进入老年代。
          </p>
         </li>
        </ol>
       </li>
      </ul>
      <h6>
       <strong>
        老年代回收（标记 - 整理算法）
       </strong>
      </h6>
      <ul>
       <li>
        <p>
         <strong>
          策略
         </strong>
         ：当老年代内存不足时触发 Full GC。
        </p>
       </li>
       <li>
        <p>
         流程：
        </p>
        <ol>
         <li>
          <p>
           标记所有存活对象。
          </p>
         </li>
         <li>
          <p>
           将存活对象向一端移动，清理边界外的内存。
          </p>
         </li>
         <li>
          <p>
           若回收后仍无足够空间，抛出内存溢出错误`。
          </p>
         </li>
        </ol>
        <h3>
         (3)垃圾回收机制是什么
        </h3>
       </li>
      </ul>
      <p>
       JVM 通过分代策略和不同引用类型的处理，高效管理内存。理解新生代与老年代的回收差异，以及引用类型对对象生命周期的影响，是优化 Java 程序性能的关键。
      </p>
      <ul>
       <li>
        <p>
         <strong>
          强引用
         </strong>
         ：默认引用，对象必须被显式释放才会被回收。
        </p>
       </li>
       <li>
        <p>
         <strong>
          软引用
         </strong>
         ：内存不足时触发回收（适用于缓存场景）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          弱引用
         </strong>
         ：GC 时立即回收（如 ThreadLocal 的 Entry）。
        </p>
       </li>
       <li>
        <p>
         <strong>
          虚引用
         </strong>
         ：仅用于跟踪对象是否被回收，无法通过虚引用获取对象。
        </p>
        <h3>
         (4). 垃圾回收算法**
        </h3>
        <h6>
         <strong>
          标记 - 清除算法
         </strong>
        </h6>
        <ul>
         <li>
          <p>
           <strong>
            步骤
           </strong>
           ：标记存活对象 → 清除未标记对象。
          </p>
         </li>
         <li>
          <p>
           <strong>
            缺点
           </strong>
           ：产生内存碎片，影响后续分配效率。
          </p>
         </li>
        </ul>
        <h6>
         <strong>
          复制算法
         </strong>
        </h6>
        <ul>
         <li>
          <p>
           <strong>
            步骤
           </strong>
           ：将存活对象复制到另一块空间 → 清空原空间。
          </p>
         </li>
         <li>
          <p>
           <strong>
            适用场景
           </strong>
           ：新生代（对象存活率低）。
          </p>
         </li>
         <li>
          <p>
           <strong>
            优点
           </strong>
           ：无内存碎片，速度快；
           <strong>
            缺点
           </strong>
           ：需双倍内存。
          </p>
         </li>
        </ul>
        <h6>
         <strong>
          标记 - 整理算法
         </strong>
        </h6>
        <ul>
         <li>
          <p>
           <strong>
            步骤
           </strong>
           ：标记存活对象 → 将存活对象向一端移动 → 清除边界外的内存。
          </p>
         </li>
         <li>
          <p>
           <strong>
            适用场景
           </strong>
           ：老年代（对象存活率高）。
          </p>
         </li>
         <li>
          <p>
           <strong>
            优点
           </strong>
           ：减少内存碎片。
          </p>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
    <h3>
     (5)什么是内存溢出？什么是内存泄露？
    </h3>
    <p>
     内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。
    </p>
    <p>
     内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽
    </p>
    <p>
     略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。
    </p>
    <h3>
     (6)
     <strong>
      JVM 性能调优核心参数（精简版）
     </strong>
    </h3>
    <h6>
     <strong>
      1. 堆内存配置
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         -Xmx
        </code>
       </strong>
       ：设置堆内存最大限制（如
       <code>
        -Xmx8g
       </code>
       ）。
       <strong>
        关键作用
       </strong>
       ：避免因内存不足导致 OOM。
      </p>
     </li>
    </ul>
    <h6>
     <strong>
      2. 新生代参数
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         -XX:NewSize
        </code>
       </strong>
       ：初始新生代大小（建议与
       <code>
        -XX:MaxNewSize
       </code>
       一致）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         -XX:NewRatio
        </code>
       </strong>
       ：新生代与老年代内存比例（默认 2，即新生代占 1/3）。
      </p>
     </li>
     <li>
      <p>
       -XX:SurvivorRatio`**：Eden 区与单个 幸存者区的比例（默认 8）。
      </p>
     </li>
    </ul>
    <h6>
     <strong>
      3. 垃圾回收器选择
     </strong>
    </h6>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         区域
        </strong>
       </th>
       <th>
        <strong>
         参数
        </strong>
       </th>
       <th>
        <strong>
         适用场景
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         年轻代
        </strong>
       </td>
       <td>
        <code>
         -XX:+UseParNewGC
        </code>
       </td>
       <td>
        多线程，低延迟
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         老年代
        </strong>
       </td>
       <td>
        <code>
         -XX:+UseConcMarkSweepGC
        </code>
       </td>
       <td>
        并发回收，适合 Web 应用
       </td>
      </tr>
     </tbody>
    </table>
    <h3>
     （7)接口中新增了什么属性
    </h3>
    <p>
     1、默认方法 Java8允许接口中包含具体实现的方法体，该方法是默认方法，它需要使用默认关键字修饰 2、静态方法 Java8中允许接口中定义静态方法，使用静态关键字修饰
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f6b616e67323530302f:61727469636c652f64657461696c732f313436323636393330" class_="artid" style="display:none">
 </p>
</div>


