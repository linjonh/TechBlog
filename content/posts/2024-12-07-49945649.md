---
layout: post
title: "嵌入式core-dump调试方法"
date: 2024-12-07 15:06:41 +0800
description: "一、为什么使用coredump  有的时候写的程序总会遇到各种异常或者bug导致退出中止，但是程序却"
keywords: "嵌入式芯片dump机制"
categories: ['问题排查']
tags: ['Linux']
artid: "49945649"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=49945649
    alt: "嵌入式core-dump调试方法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=49945649
featuredImagePreview: https://bing.ee123.net/img/rand?artid=49945649
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     嵌入式core dump调试方法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <strong>
      一、为什么使用coredump
     </strong>
    </p>
    <p>
     有的时候写的程序总会遇到各种异常或者bug导致退出中止，但是程序却没有打印出可供参考的log信息，这时候就可以利用code文件进行分析。一般情况下，code文件会记录程序运行的内存，寄存器，堆栈指针等信息，想要使用code文件分析，就需要在linux系统中设置一下。
    </p>
    <p>
     <strong>
      二、嵌入式下coredump生成设置
     </strong>
    </p>
    <p>
     1.一般linux系统下默认是不会生成core dump文件的（毕竟生成的文件还是蛮大的），通过ulimit –a （如下图所示）可以查看能生成的code文件的大小，一般是0。可以通过“ulimit –c 参数（blocks）”或者“ulimit –c unlimited”设置，建议用后者。
    </p>
    <p>
     <a href="https://img-blog.csdn.net/20151120113305706" rel="nofollow">
      <img alt="image" height="153" src="https://i-blog.csdnimg.cn/blog_migrate/c732f67d898723971c38f2ec6b5bd5e5.png" width="272"/>
     </a>
     <a href="https://img-blog.csdn.net/20151120113306575" rel="nofollow">
      <img alt="image" height="151" src="https://i-blog.csdnimg.cn/blog_migrate/7ed33953c24ea2f889bcff991f839c56.png" width="291"/>
     </a>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     2.设置core dump文件的输出位置，一般默认是当前目录，可以通过“echo “1” &gt; /proc/sys/kernel/core_uses_pid ”使core文件加上pid号，也可以用“echo ”core保存目录/core-%e-%p-%t“ &gt; /proc/sys/kernel/core_pattern ” 设置。
    </p>
    <p>
     以下是参数表：ps：用到的也就那么几个
    </p>
    <p>
     %p – insert pid into filename 添加pid
    </p>
    <p>
     %u – insert current uid into filename 添加当前uid
    </p>
    <p>
     %g – insert current gid into filename 添加当前gid
    </p>
    <p>
     %s – insert signal that caused the coredump into the filename 添加导致产生core的信号
    </p>
    <p>
     %t – insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
    </p>
    <p>
     %h – insert hostname where the coredump happened into filename 添加主机名
    </p>
    <p>
     %e – insert coreddumping executable name into filename 添加命令名
    </p>
    <p>
     3.运行程序，等停止退出后将生成的core文件，通过挂载u盘或者网络的方式拷贝到pc机Linux系统下，并和生成的可执行程序放在一个目录下。
    </p>
    <p>
     ps：重启有可能会将上面的设置清除，最好运行前查看一番。
    </p>
    <p>
     <strong>
      三、pc机Linux下分析core文件
     </strong>
    </p>
    <p>
     1.先确定自己用的嵌入式处理器架构是ARM或者MIPS，选择相应的调试工具，下面以MIPS为例。mips-linux-gdb [exec file] [core file]
    </p>
    <p>
     2.进入gdb以后需要运行info sharedlibrary来查看是否已经将需要的库导入，否则有可能查找位置时显示的是“？？”。
    </p>
    <p>
     <a href="https://img-blog.csdn.net/20151120113308647" rel="nofollow">
      <img alt="image" height="141" src="https://i-blog.csdnimg.cn/blog_migrate/9991991b5d388ed9e796e39341cc284b.png" width="244"/>
     </a>
     <a href="https://img-blog.csdn.net/20151120113309470" rel="nofollow">
      <img alt="image" height="59" src="https://i-blog.csdnimg.cn/blog_migrate/69f8bdb780386c0e07a965303e7dec94.png" width="244"/>
     </a>
    </p>
    <p>
     3.导入所需要的库，通过set solib-absolute-prefix 或者set solib-search-path 设置符号文件的位置。solib-absolute-prefix设置的是被搜索文件路径的前缀，solib-search-path设置的是被搜索文件的路径，solib-search-path可以有多个路径，中间按用:隔开， solib-absolute-prefix的值只能有一个。但一般常用solib-search-path 。
    </p>
    <p>
     首先通过find或者其他方法找到所需要的库，“（gdb）solib-search-path 库路径：库路径”
    </p>
    <p>
     <a href="https://img-blog.csdn.net/20151120113310209" rel="nofollow">
      <img alt="image" height="239" src="https://i-blog.csdnimg.cn/blog_migrate/730a09fb1185c2c32888c7baadf270e1.png" width="244"/>
     </a>
     <a href="https://img-blog.csdn.net/20151120122141980" rel="nofollow">
      <img alt="image" height="236" src="https://i-blog.csdnimg.cn/blog_migrate/d8dfe8d02d05deef4b964e57690b89be.png" width="304"/>
     </a>
    </p>
    <p>
     4.最后通过bt命令查找到位置，基本就能确定程序死在哪个文件哪个函数了。可以通过“（gdb）l *地址”（如：（gdb）l *0x76b693dc）查看那个位置的函数，不过还是建议用source insight查看方便。
    </p>
    <p>
     <strong>
      5.最后补充一个查看库文件结构的命令
     </strong>
    </p>
    <p>
    </p>
    <p>
     Linux下动态库查看方法：nm -D lib.so
    </p>
    <p>
     Linux下静态库查看方法：ar -t lib.a
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f53756e736574736561:2f61727469636c652f64657461696c732f3439393435363439" class_="artid" style="display:none">
 </p>
</div>


