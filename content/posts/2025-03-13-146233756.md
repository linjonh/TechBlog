---
layout: post
title: "C复试笔记三"
date: 2025-03-13 20:36:13 +0800
description: "友元函数和友元类、解引用和后置++、数组指针、new对象要显示调用析构函数、前置++、后置++和短路"
keywords: "C++复试笔记（三）"
categories: ['未分类']
tags: ['笔记', 'Java', 'C']
artid: "146233756"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146233756
    alt: "C复试笔记三"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146233756
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146233756
cover: https://bing.ee123.net/img/rand?artid=146233756
image: https://bing.ee123.net/img/rand?artid=146233756
img: https://bing.ee123.net/img/rand?artid=146233756
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++复试笔记（三）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     1.友元函数和友元类
    </h3>
    <h4>
     1.1友元函数
    </h4>
    <p>
     友元函数的经典实例是重载 "&lt;&lt;" 和 "&gt;&gt;" ,
     <span style="color:#777777">
      去重载operator&lt;&lt;
     </span>
     <span style="color:#777777">
      ，然后发现没办法将
     </span>
     <span style="color:#777777">
      operator&lt;&lt;
     </span>
     <span style="color:#777777">
      重载成成员函数。
     </span>
     <span style="color:#777777">
      <strong>
       因为
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       cout
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       的
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       输出流对象和隐含的
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       this
      </strong>
     </span>
     <span style="color:#777777">
      <strong>
       指针在抢占第一个参数的位置
      </strong>
     </span>
     <span style="color:#777777">
      。
     </span>
     <span style="color:#777777">
      this
     </span>
     <span style="color:#777777">
      指针默认是第一个参数也就是左操作 数了。但是实际使用中cout
     </span>
     <span style="color:#777777">
      需要是第一个形参对象，才能正常使用。所以要将
     </span>
     <span style="color:#777777">
      operator&lt;&lt;
     </span>
     <span style="color:#777777">
      重载成 全局函数。但又会导致类外没办法访问成员，此时就需要友元来解决。operator&gt;&gt;
     </span>
     <span style="color:#777777">
      同理。
     </span>
    </p>
    <p>
    </p>
    <div>
     <span style="color:#777777">
      <strong>
       友元函数
      </strong>
     </span>
     <span style="color:#777777">
      可以
     </span>
     <span style="color:#777777">
      <strong>
       直接访问
      </strong>
     </span>
     <span style="color:#777777">
      类的
     </span>
     <span style="color:#777777">
      <strong>
       私有
      </strong>
     </span>
     <span style="color:#777777">
      成员，它是
     </span>
     <span style="color:#777777">
      <strong>
       定义在类外部
      </strong>
     </span>
     <span style="color:#777777">
      的
     </span>
     <span style="color:#777777">
      <strong>
       普通函数
      </strong>
     </span>
     <span style="color:#777777">
      ，不属于任何类，但需要在
     </span>
    </div>
    <div>
     <span style="color:#777777">
      类的内部声明，声明时需要加
     </span>
     <span style="color:#777777">
      <strong>
       friend
      </strong>
     </span>
     <span style="color:#777777">
      关键字。
     </span>
    </div>
    <div>
     <pre><code class="language-cpp">class Date
{
     friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);
     friend istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d);
public:
     Date(int year = 1900, int month = 1, int day = 1)
         : _year(year)
         , _month(month)
         , _day(day)
         {}
private:
     int _year;
     int _month;
     int _day;
};
ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)
{
     _cout &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
     return _cout; 
}
istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d)
{
     _cin &gt;&gt; d._year;
     _cin &gt;&gt; d._month;
     _cin &gt;&gt; d._day;
     return _cin;
}
int main()
{
     Date d;
     cin &gt;&gt; d;
     cout &lt;&lt; d &lt;&lt; endl;
     return 0;
}</code></pre>
     <p>
      说明：
     </p>
     <ul>
      <li>
       <span style="color:#777777">
        <strong>
         友元函数
        </strong>
       </span>
       <span style="color:#777777">
        可访问类的私有和保护成员，但
       </span>
       <span style="color:#777777">
        <strong>
         不是类的成员函数
        </strong>
       </span>
      </li>
      <li>
       <span style="color:#777777">
        友元函数
       </span>
       <span style="color:#777777">
        <strong>
         不能用
        </strong>
       </span>
       <span style="color:#777777">
        <strong>
         const
        </strong>
       </span>
       <span style="color:#777777">
        <strong>
         修饰
        </strong>
       </span>
      </li>
      <li>
       <span style="color:#777777">
        <strong>
         友元函数
        </strong>
       </span>
       <span style="color:#777777">
        可以在类定义的任何地方声明，
       </span>
       <span style="color:#777777">
        <strong>
         不受类访问限定符限制
        </strong>
       </span>
      </li>
      <li>
       <span style="color:#777777">
        一个函数可以是多个类的友元函数
       </span>
      </li>
      <li>
       <span style="color:#777777">
        友元函数的调用与普通函数的调用原理相同
       </span>
      </li>
     </ul>
     <h4>
      1.2友元类
     </h4>
    </div>
    <ul>
     <li>
      <span style="color:#777777">
       友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。
      </span>
     </li>
     <li>
      <span style="color:#777777">
       友元关系是单向的，不具有交换性。
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#777777">
      比如上述
     </span>
     <span style="color:#777777">
      Time
     </span>
     <span style="color:#777777">
      类和
     </span>
     <span style="color:#777777">
      Date
     </span>
     <span style="color:#777777">
      类，在
     </span>
     <span style="color:#777777">
      Time
     </span>
     <span style="color:#777777">
      类中声明
     </span>
     <span style="color:#777777">
      Date
     </span>
     <span style="color:#777777">
      类为其友元类，那么可以在
     </span>
     <span style="color:#777777">
      Date
     </span>
     <span style="color:#777777">
      类中直接
     </span>
    </p>
    <p>
     <span style="color:#777777">
      访问
     </span>
     <span style="color:#777777">
      Time
     </span>
     <span style="color:#777777">
      类的私有成员变量，但想在
     </span>
     <span style="color:#777777">
      Time
     </span>
     <span style="color:#777777">
      类中访问
     </span>
     <span style="color:#777777">
      Date
     </span>
     <span style="color:#777777">
      类中私有的成员变量则不行。
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#777777">
       友元关系不能传递
      </span>
     </li>
    </ul>
    <p>
     <span style="color:#777777">
      如果
     </span>
     <span style="color:#777777">
      C
     </span>
     <span style="color:#777777">
      是
     </span>
     <span style="color:#777777">
      B
     </span>
     <span style="color:#777777">
      的友元，
     </span>
     <span style="color:#777777">
      B
     </span>
     <span style="color:#777777">
      是
     </span>
     <span style="color:#777777">
      A
     </span>
     <span style="color:#777777">
      的友元，则不能说明
     </span>
     <span style="color:#777777">
      C
     </span>
     <span style="color:#777777">
      时
     </span>
     <span style="color:#777777">
      A
     </span>
     <span style="color:#777777">
      的友元。
     </span>
    </p>
    <ul>
     <li>
      <span style="color:#777777">
       友元关系不能继承。
      </span>
     </li>
    </ul>
    <pre><code class="language-cpp">class Time
{
   friend class Date;   // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类
中的私有成员变量
public:
 Time(int hour = 0, int minute = 0, int second = 0)
 : _hour(hour)
 , _minute(minute)
 , _second(second)
 {}
   
private:
   int _hour;
   int _minute;
   int _second;
};
class Date
{
public:
   Date(int year = 1900, int month = 1, int day = 1)
       : _year(year)
       , _month(month)
       , _day(day)
   {}
   
   void SetTimeOfDate(int hour, int minute, int second)
   {
       // 直接访问时间类私有的成员变量
       _t._hour = hour;
       _t._minute = minute;
       _t._second = second;
   }
   
private:
   int _year;
   int _month;
   int _day;
   Time _t;
};</code></pre>
    <p>
    </p>
    <h3>
     2.解引用和后置++
    </h3>
    <pre><code class="language-cpp">int main()
{
	int a[10] = { 0,1,-2,3,-4,5,-6,7,-8,9 }, * p = a + 1;
	cout &lt;&lt; *p++ &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     <img alt="" height="235" src="https://i-blog.csdnimg.cn/direct/10c55bd95ea840a1a22000596d329371.png" width="885"/>
    </p>
    <ol>
     <li>
      <p>
       然后，定义了一个指向整型的指针
       <code>
        p
       </code>
       并将其初始化为
       <code>
        a + 1
       </code>
       。这里，
       <code>
        a
       </code>
       是数组名，也可以作为指向数组第一个元素的指针使用。所以，
       <code>
        a + 1
       </code>
       就是指向数组第二个元素的指针（即指向值为
       <code>
        1
       </code>
       的那个元素）。
      </p>
     </li>
     <li>
      <p>
       <code>
        cout &lt;&lt; *p++ &lt;&lt; endl;
       </code>
       这行代码执行了以下操作：
      </p>
      <ul>
       <li>
        <code>
         *p
        </code>
        ：首先解引用指针
        <code>
         p
        </code>
        ，得到它当前指向的值，这里是
        <code>
         1
        </code>
        。
       </li>
       <li>
        <code>
         p++
        </code>
        ：然后，执行
        <code>
         p
        </code>
        的自增操作，使
        <code>
         p
        </code>
        指向下一个元素。但是需要注意的是，根据C++运算符优先级，
        <code>
         p++
        </code>
        在此上下文中是在
        <code>
         *p
        </code>
        获取值之后才进行的，这意味着这次自增不会影响本次解引用的结果。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     因此，最终输出的是
     <code>
      1
     </code>
     ，这是
     <code>
      p
     </code>
     初始指向位置的值。在输出之后，
     <code>
      p
     </code>
     将会指向数组中的下一个元      素
     <code>
      -2
     </code>
     ，但这个变化不影响已经输出的结果。
    </p>
    <p>
    </p>
    <h3>
     3.数组指针
    </h3>
    <pre><code class="language-cpp">int main()
{

	int a[][3] = { 1,-2,3,-4,5,-6 }, (*p)[3] = a + 1;
	cout &lt;&lt; **p &lt;&lt; endl;
	return 0;
}</code></pre>
    <p>
     <img alt="" height="238" src="https://i-blog.csdnimg.cn/direct/09d7d840a2f5413cb606b063dd2b2582.png" width="945"/>
    </p>
    <ul>
     <li>
      <code>
       (*p)[3] = a + 1;
      </code>
     </li>
    </ul>
    <p>
     <strong>
      首先要明确的是，p是一个指针，因为加上了（）。
     </strong>
     这里定义了一个指针
     <code>
      p
     </code>
     ，它指向一个包含3个整数的数组。
     <code>
      a + 1
     </code>
     指向数组
     <code>
      a
     </code>
     的第二行（即
     <code>
      a[1]
     </code>
     ），因此
     <code>
      p
     </code>
     直接指向了
     <code>
      a
     </code>
     的第二行。
    </p>
    <p>
    </p>
    <h3>
     4.new对象要显示调用析构函数
    </h3>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class Person {
private:
	int age;
public:
	string name;
	Person(int a, string n = "Hqu") {
		age = a;
		name = n;
		cout &lt;&lt; "constructing..." &lt;&lt; n &lt;&lt; endl;
	}
	~Person() {
		cout &lt;&lt; name &lt;&lt; "being destructed!" &lt;&lt; endl;
	}

};
int main() {
	Person* p1 = new Person(19, "BUAA");
	Person p2(50, "dong");
	return 0;
}</code></pre>
    <p>
     <img alt="" height="330" src="https://i-blog.csdnimg.cn/direct/9502ef38a2af4dc8ab855169af9f5da1.png" width="981">
      当你使用
      <code>
       new
      </code>
      来分配内存时，需要显式地使用
      <code>
       delete
      </code>
      来释放这块内存，否则析构函数不会被调用，导致可能的内存泄漏。
     </img>
    </p>
    <p>
     而普通构造函数，在程序结束后会自动调用析构函数。
    </p>
    <h3>
     5.前置++、后置++和短路
    </h3>
    <pre><code class="language-cpp">int main()
{
	int i = 1, j = 0;
	if (--i &amp;&amp; j++)
	//if(j++ &amp;&amp; --i)
		cout &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; endl;
	else
		cout &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; endl;

	return 0;
}
</code></pre>
    <p>
     <img alt="" height="318" src="https://i-blog.csdnimg.cn/direct/2925667abfc44276942f21c89a874aa7.png" width="772"/>
    </p>
    <p>
     关键在于理解
     <code>
      if (--i &amp;&amp; j++)
     </code>
     这一行。这里使用了逻辑与（
     <code>
      &amp;&amp;
     </code>
     ）运算符，它具有短路特性。具体来说，当且仅当左侧表达式为真（非零）时，才会计算右侧表达式。在这个例子中：
    </p>
    <ol>
     <li>
      <code>
       --i
      </code>
      ：首先执行，将
      <code>
       i
      </code>
      从1减到0。此时
      <code>
       --i
      </code>
      的结果是0。
     </li>
     <li>
      因为
      <code>
       --i
      </code>
      的结果是0（即假），根据
      <code>
       &amp;&amp;
      </code>
      运算符的短路特性，程序不会计算
      <code>
       &amp;&amp;
      </code>
      后面的
      <code>
       j++
      </code>
      部分，因为无论
      <code>
       j++
      </code>
      的结果是什么，整个表达式的最终结果都已经是假了（只要
      <code>
       &amp;&amp;
      </code>
      左边的操作数为假，整个表达式就为假）。
     </li>
    </ol>
    <p>
     因此，在这个特定情况下，尽管
     <code>
      if
     </code>
     语句的条件判断导致执行了
     <code>
      else
     </code>
     分支，但由于
     <code>
      j++
     </code>
     并未被执行（由于短路），
     <code>
      j
     </code>
     的值并不会增加。所以，输出结果仍然是：0，0
    </p>
    <pre><code class="language-cpp">int main()
{
	int i = 1, j = 0;
	//if (--i &amp;&amp; j++)
	if(j++ &amp;&amp; --i)
		cout &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; endl;
	else
		cout &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; endl;

	return 0;
}
</code></pre>
    <p>
     <img alt="" height="280" src="https://i-blog.csdnimg.cn/direct/b88710a18a1e481bad9c5ac691044c53.png" width="752"/>
    </p>
    <p>
    </p>
    <p>
     调整了条件判断的顺序，现在逻辑表达式是
     <code>
      if(j++ &amp;&amp; --i)
     </code>
     。这个变化很重要，因为它影响了短路求值的行为和操作符的执行情况。
    </p>
    <ol>
     <li>
      首先定义两个整数变量
      <code>
       i
      </code>
      和
      <code>
       j
      </code>
      ，并分别初始化为
      <code>
       1
      </code>
      和
      <code>
       0
      </code>
      。
     </li>
     <li>
      在
      <code>
       if
      </code>
      语句中，首先计算
      <code>
       j++
      </code>
      。这里需要注意的是，
      <code>
       j++
      </code>
      是后置递增操作，意味着它会先使用
      <code>
       j
      </code>
      的当前值（这里是
      <code>
       0
      </code>
      ）进行逻辑与运算，然后再将
      <code>
       j
      </code>
      增加1。
     </li>
     <li>
      因为
      <code>
       j++
      </code>
      使用的是
      <code>
       j
      </code>
      的原始值
      <code>
       0
      </code>
      ，所以
      <code>
       j++ &amp;&amp; --i
      </code>
      这个表达式的左部分已经是
      <code>
       false
      </code>
      （即0）。根据逻辑与运算的短路特性，一旦确定左边为假，则不会评估右边的表达式。因此，
      <code>
       --i
      </code>
      不会被执行。
     </li>
     <li>
      尽管
      <code>
       --i
      </code>
      没有被执行，但由于
      <code>
       j++
      </code>
      的存在，
      <code>
       j
      </code>
      的值会在这一行结束后增加到
      <code>
       1
      </code>
      。
     </li>
    </ol>
    <p>
     因此，程序将会输出
     <code>
      i
     </code>
     和
     <code>
      j
     </code>
     的值，其中
     <code>
      i
     </code>
     保持不变，因为
     <code>
      --i
     </code>
     没有被执行；而
     <code>
      j
     </code>
     则由于
     <code>
      j++
     </code>
     而从
     <code>
      0
     </code>
     变成了
     <code>
      1
     </code>
     。最终输出结果将是：1，1
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f44323436303539363432312f:61727469636c652f64657461696c732f313436323333373536" class_="artid" style="display:none">
 </p>
</div>


