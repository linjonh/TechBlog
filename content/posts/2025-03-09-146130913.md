---
layout: post
title: "JVM类加载器面试题及原理"
date: 2025-03-09 13:10:45 +0800
description: "介绍类加载器的种类、双亲委派模型、类装载的执行过程原理及相关面试题"
keywords: "JVM类加载器面试题及原理"
categories: ['未分类']
tags: ['Jvm']
artid: "146130913"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146130913
    alt: "JVM类加载器面试题及原理"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146130913
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146130913
cover: https://bing.ee123.net/img/rand?artid=146130913
image: https://bing.ee123.net/img/rand?artid=146130913
img: https://bing.ee123.net/img/rand?artid=146130913
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     JVM类加载器面试题及原理
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     JVM只会运行二进制文件，
     <strong>
      类加载器
     </strong>
     的作用就是
     <strong>
      将字节码文件加载到JVM中
     </strong>
     ，从而让Java程序能够启动起来。
    </p>
    <h2>
     <a id="1__1">
     </a>
     1. 类加载器的种类
    </h2>
    <ul>
     <li>
      <strong>
       启动类加载器
      </strong>
      （BootStrap ClassLoader）：加载JAVA_HOME/jre/lib目录下的库
     </li>
     <li>
      <strong>
       扩展类加载器
      </strong>
      （ExtClassLoader）：主要加载JAVA_HOME/jre/lib/ext目录中的类
     </li>
     <li>
      <strong>
       应用类加载器
      </strong>
      （AppClassLoader）：用于加载classPath下的类
     </li>
     <li>
      自定义类加载器（CustomizeClassLoader）：自定义类继承ClassLoader，实现自定义类加载规则。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/e74374ed60f24a9299791344f37f2227.png"/>
     </li>
    </ul>
    <h2>
     <a id="2__8">
     </a>
     2. 双亲委派模型
    </h2>
    <h3>
     <a id="21__9">
     </a>
     2.1 原理
    </h3>
    <p>
     加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类
    </p>
    <ul>
     <li>
      student类在应用类加载器，向上委托，但lib和ext目录都没有student，所以向下由含有student类的子加载器（应用类加载器）加载student类
     </li>
     <li>
      string类在应用类加载器，向上委托，lib目录下有，于是加载string类然后返回给应用类加载器让它直接使用
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2d37bc014b0d431c8604be350eac462c.png"/>
     </li>
    </ul>
    <h3>
     <a id="22__15">
     </a>
     2.2 使用场景
    </h3>
    <p>
     JVM为什么采用双亲委派机制？
    </p>
    <ol>
     <li>
      通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性
     </li>
     <li>
      为了安全，保证类库API不会被修改
      <br/>
      ex：
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>long</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">Stringll</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"demo info"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
    <p>
     此时执行main函数，会出现异常，在类java.lang.String 中找不到 main 方法
    </p>
    <pre><code class="prism language-terminal">错误：在类 java.Lang.string 中找不到 main 方法，请将 main 方法定义为：
public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展
javafx.application.Application
</code></pre>
    <p>
     报错原因：由于是双亲委派的机制，javalang.String的在启动类加载器得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。（所以这就是为什么类名不能是关键字的根本原因）
    </p>
    <h2>
     <a id="3__36">
     </a>
     3. 类装载的执行过程
    </h2>
    <ul>
     <li>
      类从加载到虚拟机中开始，直到卸载 止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。
     </li>
     <li>
      其中，验证、准备和解析这三个部分统称为连接（linking）
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/2f3baa5cf30f49b4a4e6f844ffa300f0.png"/>
     </li>
    </ul>
    <h3>
     <a id="31__41">
     </a>
     3.1 加载阶段
    </h3>
    <p>
     <strong>
      查找和导入class文件
     </strong>
    </p>
    <ul>
     <li>
      通过类的全名，获取类的二进制数据流。
     </li>
     <li>
      解析类的二进制数据流为方法区内的数据结构（Java类模型）
     </li>
     <li>
      创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/9e379c6a6e8f403c9e58bdbc4009d824.png"/>
     </li>
    </ul>
    <h3>
     <a id="32__48">
     </a>
     3.2 连接阶段
    </h3>
    <h4>
     <a id="321__49">
     </a>
     3.2.1 验证阶段
    </h4>
    <p>
     <strong>
      保证加载类的准确性
     </strong>
     <br/>
     验证类是否符合JVM规范，安全性检查
    </p>
    <ul>
     <li>
      格式检查，如：文件格式是否错误、语法是否错误、字节码是否合规(1)(2)(3)
      <ol>
       <li>
        文件格式验证
       </li>
       <li>
        元数据验证
       </li>
       <li>
        字节码验证
       </li>
      </ol>
     </li>
     <li>
      Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查它们是否存在(4)
      <br/>
      4. 符号引用验证
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/77ccfe8a067a4b1ebda738cb1508b2c2.png"/>
     </li>
    </ul>
    <h4>
     <a id="322__60">
     </a>
     3.2.2 准备阶段
    </h4>
    <p>
     <strong>
      内类变量分配内存并设置类变量初始值
     </strong>
    </p>
    <ol>
     <li>
      static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成
     </li>
     <li>
      static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成
     </li>
     <li>
      static变量是final的引用类型，那么赋值也会在初始化阶段完成
     </li>
    </ol>
    <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">//(1)</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>   <span class="token comment">//(2)</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> d <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>   <span class="token comment">//(2)</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span>  <span class="token comment">//(3)</span>
｝
</code></pre>
    <h4>
     <a id="323__73">
     </a>
     3.2.3 解析阶段
    </h4>
    <p>
     把类中的
     <strong>
      符号引用
     </strong>
     转换为
     <strong>
      直接引用
     </strong>
     <br/>
     比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法
    </p>
    <ul>
     <li>
      符号引用：代#的是符号引用，符号引用可能也引用其他符号引用或直接引用类
     </li>
     <li>
      直接引用：找到符号指的类与方法去执行
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/51e4f7a7f5534155b07023ae566937ff.png"/>
     </li>
    </ul>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/1c2b8871c3e34c8fb5fd9346aa78bf4a.png"/>
    </p>
    <h3>
     <a id="33__82">
     </a>
     3.3 初始化阶段
    </h3>
    <p>
     <strong>
      对类的静态变量，静态代码块执行初始化操作
     </strong>
    </p>
    <ul>
     <li>
      如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
     </li>
     <li>
      如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。
     </li>
    </ul>
    <pre><code class="prism language-java"><span class="token comment">//Animal是Cat父类</span>
<span class="token comment">//子类初始化，如果父类还没初始化，会引发父类先初始化</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span>println（<span class="token class-name">Cat</span><span class="token punctuation">.</span>sex）；
<span class="token comment">//子类访问父类静态变量，只触发父类初始化</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h3>
     <a id="34__93">
     </a>
     3.4 使用阶段
    </h3>
    <p>
     <strong>
      JVM 开始从入口方法开始执行用户的程序代码
     </strong>
    </p>
    <ul>
     <li>
      调用静态类成员信息（比如：静态字段、静态方法）
     </li>
     <li>
      使用new关键字为其创建对象实例
     </li>
    </ul>
    <h3>
     <a id="35__97">
     </a>
     3.5 卸载阶段
    </h3>
    <p>
     <strong>
      当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。
     </strong>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330335f38313035393631362f:61727469636c652f64657461696c732f313436313330393133" class_="artid" style="display:none">
 </p>
</div>


