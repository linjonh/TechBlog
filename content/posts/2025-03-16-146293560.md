---
layout: post
title: "C特性智能指针"
date: 2025-03-16 23:23:14 +0800
description: "对于定义的局部变量，当作用域结束之后，就会自动回收，这没有什么问题。当时用new delete的时候，如果new了一个变量，但却没有delete，这会造成内存泄露。特别是当大型项目，会使用多个指针指向同一块内存区域的时候，什么时候释放这块指针所指向的内存区域就成了一个问题。智能指针就是解决这个问题的办法，他的思想就是当你定义了一个智能指针，可以像普通指针一样使用*⃣️来获取里面的内容，当用其他的智能指针再次指向这块区域的时候，会有一个计数器。"
keywords: "C++特性——智能指针"
categories: ['八股']
tags: ['C']
artid: "146293560"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293560
    alt: "C特性智能指针"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293560
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293560
cover: https://bing.ee123.net/img/rand?artid=146293560
image: https://bing.ee123.net/img/rand?artid=146293560
img: https://bing.ee123.net/img/rand?artid=146293560
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++特性——智能指针
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     为什么需要智能指针
    </h2>
    <p>
     对于定义的局部变量，当作用域结束之后，就会自动回收，这没有什么问题。
     <br/>
     当时用new delete的时候，就是动态分配对象的时候，如果new了一个变量，但却没有delete，这会造成内存泄露。
     <br/>
     特别是当大型项目，会使用多个指针指向同一块内存区域的时候，什么时候释放这块指针所指向的内存区域就成了一个问题。
     <br/>
     智能指针就是解决这个问题的办法，他的思想就是当你定义了一个智能指针，可以像普通指针一样使用*⃣️来获取里面的内容，当用其他的智能指针再次指向这块区域的时候，会有一个计数器。当所有的智能指针都被标记为不再使用的时候，这个计数器清零，这块指针所指向的内存也就被释放。
    </p>
    <p>
     <strong>
      什么是动态分配的对象
     </strong>
     ？ 是指在程序运行时（而非编译时）在堆（heap）内存中分配的对象。
    </p>
    <h2>
     <a id="_8">
     </a>
     注意
    </h2>
    <p>
     在使用智能指针的时候，一定要避免使用delete，可能会引发未定义的行为，就让系统自己处理。
     <br/>
     unique_ptr性能很好，不支持复制，唯一控制权；shared_ptr支持多个指针指向同一块内存并计数，资源消耗大。
     <br/>
     任何时候都推荐使用unique_ptr，而shared_ptr当多个函数
    </p>
    <h2>
     <a id="shared_ptr_12">
     </a>
     shared_ptr
    </h2>
    <p>
     引入
     <code>
      #include &lt;memory&gt;
     </code>
     <br/>
     用法:
     <code>
      shared _ptr&lt;T&gt; p = make_shared&lt;T&gt;()
     </code>
     或者大括号的初始方法
     <code>
      shared_ptr&lt;T&gt; p {fp, close_file}
     </code>
     <br/>
     例如
     <code>
      shared _ptr&lt;int&gt; p = make_shared&lt;int&gt;(100)
     </code>
     的意思就是定义了一个指向存储内容为100的动态内存的共享指针p。此时
     <code>
      p.use_count()
     </code>
     引用计数为1。
     <br/>
     当定义其他的共享指针p1=p时，表示p1也指向了int类型的100的这块内存，同理如果是对象，不会再构造一次，因为指向的是同一块东西。此时再使用
     <code>
      p.use_count()
     </code>
     或者
     <code>
      p1.use_count()
     </code>
     得到的计数结果都是2。
     <br/>
     当
     <code>
      p.reset()
     </code>
     就表示重置p指向的内容，此时引用计数会减1，当
     <code>
      p1.reset()
     </code>
     p1也重置之后，引用计数为0，这块内存被释放。
    </p>
    <h3>
     <a id="_18">
     </a>
     额外补充
    </h3>
    <ol>
     <li>
      <code>
       p.reset()
      </code>
      这个用法还可以在括号里
      <code>
       p.reset(new int)
      </code>
      代表指向一个新的int内存，旧的int内存减1
     </li>
     <li>
      在新定义一个共享指针的时候，是可以对它的释放功能自定义的，可以自定义为其他的功能，例如下图将释放功能自定义为文件关闭函数。当引用计数为0的时候，就可以自动关闭文件。
      <br/>
      <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/093e321356e341449c94b1104f1c9986.png"/>
     </li>
     <li>
      别名
      <code>
       shared_ptr&lt;example_class&gt; p1 {p, &amp;(p-&gt;bar)}
      </code>
      p1是p的别名
     </li>
    </ol>
    <h2>
     <a id="unique_ptr_24">
     </a>
     unique_ptr
    </h2>
    <p>
     引入
     <code>
      #include &lt;memory&gt;
     </code>
     <br/>
     用法：
     <code>
      unique_ptr&lt;int&gt; p = make_unique&lt;int&gt;(100)
     </code>
     <br/>
     unique_ptr就不存在复制这样的功能，p独享这一块资源，不能和别的指针共享。
     <br/>
     当作用域结束之后，unique_ptr指向的资源就会释放，即使它是用的new delete来创建的。
     <br/>
     可以使用
     <code>
      p.get()
     </code>
     获取裸指针。
     <br/>
     同样的，可以使用
     <code>
      p.reset()
     </code>
     来重置unique_ptr使其指向nullptr。也可以
     <code>
      p.reset(new class)
     </code>
     来让这个unique_ptr指向一个新的类。
     <br/>
     可以使用
     <code>
      p.release()
     </code>
     来释放p对这块资源的控制权，会返回一个裸指针。unique_ptr中是没有复制这么一说的，也就不存“=”的赋值。但是可以传递：通过
     <code>
      unique&lt;exapmle_class&gt; p1 (p.release())
     </code>
     或者是利用move,即
     <code>
      unique_ptr&lt;example_class&gt; p1(p.move())
     </code>
     <br/>
     unnique_ptr可以自定义分配函数和自定义释放函数，eg:
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bd0681832d994013b1ffbcf68ecd679e.png"/>
    </p>
    <p>
     <strong>
      unique_ptr的函数绑定是在编译时就绑定了，这个函数成为了unique_ptr实例的一部分，而shared_ptr则是运行时绑定。
     </strong>
    </p>
    <h3>
     <a id="unique_ptr_37">
     </a>
     在函数之间的unique_ptr传递
    </h3>
    <p>
     指针在函数之间的传递难免不会发生复制，例如实参作为输入进入函数之后，函数可能会复制一份进入函数体。
     <br/>
     解决办法：
    </p>
    <ol>
     <li>
      函数的形参是一个unique_ptr的引用
     </li>
     <li>
      只传递所指向的资源例如传入*p，接收也是一个int&amp; p。
     </li>
     <li>
      利用p.get()或者是move()，这样会传递一个裸指针到函数里去。
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f:626c6f672e6373646e2e6e65742f6879645f617368656c792f:61727469636c652f64657461696c732f313436323933353630" class_="artid" style="display:none">
 </p>
</div>


