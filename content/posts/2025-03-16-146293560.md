---
layout: post
title: "C特性智能指针"
date: 2025-03-16 23:23:14 +0800
description: "对于定义的局部变量，当作用域结束之后，就会自动回收，这没有什么问题。当时用new delete的时候，如果new了一个变量，但却没有delete，这会造成内存泄露。特别是当大型项目，会使用多个指针指向同一块内存区域的时候，什么时候释放这块指针所指向的内存区域就成了一个问题。智能指针就是解决这个问题的办法，他的思想就是当你定义了一个智能指针，可以像普通指针一样使用*⃣️来获取里面的内容，当用其他的智能指针再次指向这块区域的时候，会有一个计数器。"
keywords: "C++特性——智能指针"
categories: ['八股']
tags: ['C']
artid: "146293560"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146293560
    alt: "C特性智能指针"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146293560
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146293560
cover: https://bing.ee123.net/img/rand?artid=146293560
image: https://bing.ee123.net/img/rand?artid=146293560
img: https://bing.ee123.net/img/rand?artid=146293560
---

# C++特性——智能指针

## 为什么需要智能指针

对于定义的局部变量，当作用域结束之后，就会自动回收，这没有什么问题。  
当时用new delete的时候，就是动态分配对象的时候，如果new了一个变量，但却没有delete，这会造成内存泄露。  
特别是当大型项目，会使用多个指针指向同一块内存区域的时候，什么时候释放这块指针所指向的内存区域就成了一个问题。  
智能指针就是解决这个问题的办法，他的思想就是当你定义了一个智能指针，可以像普通指针一样使用*⃣️来获取里面的内容，当用其他的智能指针再次指向这块区域的时候，会有一个计数器。当所有的智能指针都被标记为不再使用的时候，这个计数器清零，这块指针所指向的内存也就被释放。

**什么是动态分配的对象** ？ 是指在程序运行时（而非编译时）在堆（heap）内存中分配的对象。

## 注意

在使用智能指针的时候，一定要避免使用delete，可能会引发未定义的行为，就让系统自己处理。  
unique_ptr性能很好，不支持复制，唯一控制权；shared_ptr支持多个指针指向同一块内存并计数，资源消耗大。  
任何时候都推荐使用unique_ptr，而shared_ptr当多个函数

## shared_ptr

引入`#include <memory>`  
用法:`shared _ptr<T> p = make_shared<T>()`或者大括号的初始方法`shared_ptr<T> p {fp,
close_file}`  
例如`shared _ptr<int> p =
make_shared<int>(100)`的意思就是定义了一个指向存储内容为100的动态内存的共享指针p。此时`p.use_count()`
引用计数为1。  
当定义其他的共享指针p1=p时，表示p1也指向了int类型的100的这块内存，同理如果是对象，不会再构造一次，因为指向的是同一块东西。此时再使用`p.use_count()`或者`p1.use_count()`得到的计数结果都是2。  
当`p.reset()`就表示重置p指向的内容，此时引用计数会减1，当`p1.reset()`p1也重置之后，引用计数为0，这块内存被释放。

### 额外补充

  1. `p.reset()`这个用法还可以在括号里`p.reset(new int)`代表指向一个新的int内存，旧的int内存减1
  2. 在新定义一个共享指针的时候，是可以对它的释放功能自定义的，可以自定义为其他的功能，例如下图将释放功能自定义为文件关闭函数。当引用计数为0的时候，就可以自动关闭文件。  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/093e321356e341449c94b1104f1c9986.png)

  3. 别名 `shared_ptr<example_class> p1 {p, &(p->bar)}` p1是p的别名

## unique_ptr

引入`#include <memory>`  
用法：`unique_ptr<int> p = make_unique<int>(100)`  
unique_ptr就不存在复制这样的功能，p独享这一块资源，不能和别的指针共享。  
当作用域结束之后，unique_ptr指向的资源就会释放，即使它是用的new delete来创建的。  
可以使用`p.get()`获取裸指针。  
同样的，可以使用`p.reset()`来重置unique_ptr使其指向nullptr。也可以`p.reset(new
class)`来让这个unique_ptr指向一个新的类。  
可以使用`p.release()`来释放p对这块资源的控制权，会返回一个裸指针。unique_ptr中是没有复制这么一说的，也就不存“=”的赋值。但是可以传递：通过`unique<exapmle_class>
p1 (p.release())`或者是利用move,即`unique_ptr<example_class> p1(p.move())`  
unnique_ptr可以自定义分配函数和自定义释放函数，eg:  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bd0681832d994013b1ffbcf68ecd679e.png)

**unique_ptr的函数绑定是在编译时就绑定了，这个函数成为了unique_ptr实例的一部分，而shared_ptr则是运行时绑定。**

### 在函数之间的unique_ptr传递

指针在函数之间的传递难免不会发生复制，例如实参作为输入进入函数之后，函数可能会复制一份进入函数体。  
解决办法：

  1. 函数的形参是一个unique_ptr的引用
  2. 只传递所指向的资源例如传入*p，接收也是一个int& p。
  3. 利用p.get()或者是move()，这样会传递一个裸指针到函数里去。



