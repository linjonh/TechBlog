---
layout: post
title: "命令行参数和环境变量Linux操作系统"
date: 2025-03-15 11:51:34 +0800
description: "记录当前用户的家目录bash的cwd是会跟着用户的工作路径的变化而变化的。"
keywords: "命令行参数和环境变量【Linux操作系统】"
categories: ['Linux']
tags: ['Linux']
artid: "146275834"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146275834
    alt: "命令行参数和环境变量Linux操作系统"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146275834
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146275834
cover: https://bing.ee123.net/img/rand?artid=146275834
image: https://bing.ee123.net/img/rand?artid=146275834
img: https://bing.ee123.net/img/rand?artid=146275834
---

# 命令行参数和环境变量【Linux操作系统】

## 命令行参数

命令行参数就是main函数的参数，有两个  
①argc：int类型，表示argv的元素个数  
②argv：char*类型的数组，存储字符串

### 命令行参数有什么用呢？

例  
![请添加图片描述](https://i-blog.csdnimg.cn/direct/af1c289dc7d24a4d8770cfc72bccd544.jpeg)

由上图得：  
执行这个程序（code）的命令行中以空格分隔的字符串就会传入argv中进行存储

这样可以干什么呢？  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aaf1a875c64b4a75b02a102c90c80000.jpeg#pic_center)

所以可以在main函数里面直接根据argv接收到的内容，来分情况进行一些处理

**我们常用的Linux指令的选项的功能，就是使用这样的方式进行实现的**  
![请添加图片描述](https://i-blog.csdnimg.cn/direct/16236bc11d7f46e9872cf0207ddb2012.jpeg)

* * *

### main函数的参数是谁传递的?

子进程可以继承父进程的数据  
所以我们写得程序运行时，也能继承shell（bash）解析出来的argc和argv

进程再以参数的形式传给main函数  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/49782302af744ae6bb24012abccadcf5.png#pic_center)

* * *

## 环境变量

环境变量  
一般是指在操作系统中用来指定操作系统运行环境的一些参数  
`通常通过shell传递给所有进程`

**shell自己的环境变量是从操作系统的配置文件里面读取出来的**  
shell再把读取出来的信息分析之后，再放入shell内部的全局的指针数组中

我们在命令行上执行的命令`都是shell的子进程`，绝大部分都是shell创建的子进程使用进程替换，搞出来的

**父进程的环境变量表可以被子进程继承**  
并且可以把它作为参数传给main函数  
也就是下图的env

* * *

### 环境变量的作用

环境变量的作用有很多，主要是看它里面存储了什么数据  
环境变量因为是变量，所以可以存储任意全局数据，这些数据就可以被一些进程（或者全部进程）看到

如:  
我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有`相关环境变量中记录了动态库的路径`帮助编译器进行查找。

环境变量在系统当中通常具有全局特性

* * *

### 简单介绍一下常见的环境变量

#### 环境变量HOME：

作用：`记录当前用户的家目录`  
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/36d9931dc88a47639dec284292107135.png#pic_center)  
bash的cwd是会跟着用户的工作路径的变化而变化的

* * *

#### 环境变量PWD

记录当前用户的工作路径（`用户的工作路径就是bash的cwd`）

pwd其实是从自己这个进程的PCB中读取cwd进行打印的  
![请添加图片描述](https://i-blog.csdnimg.cn/direct/de0b6ca97157465f8834ffd5ef613883.jpeg)

* * *

#### 环境变量USER

记录当前登陆的用户是谁

**我们可以通过这个环境变量和getenv函数，在进程中确定是谁在使用这个进程**

就可以使用条件判断，分类讨论  
例  
![请添加图片描述](https://i-blog.csdnimg.cn/direct/e3a255be27a6483db6c234b1a8db89a4.jpeg)  
上面这个代码形成的进程，就只有用户who能正常使用  
其他用户，那片是root用户都不能正常使用

* * *

#### 环境变量OLDPWD

记录用户最近的上一次所处的工作路径

这也是命令`cd -`的实现依据

* * *

#### 环境变量相关指令和函数

函数：`getenv`  
头文件：`stdlib.h`  
参数：环境变量名  
返回值类型：char*  
作用：获取对应环境变量的值

* * *

函数：`putenv`  
头文件：`stdlib.h`  
参数：char*env（字符串），环境变量及其值

作用：更改环境变量或者把一个自定义的环境变量，加入自己的环境变量表

**putenv加入环境变量之前，进程自己的环境变量表和父进程的环境表是同一张，是从父进程那里继承来的**

putenv加入环境变量之后，会触发写时拷贝进程自己的环境变量表就是只属于自己和自己创建子进程的了，因为`写时拷贝`

* * *

查询所有的环境变量的指令：env

* * *

指令：`set`  
查询所有的本地变量和环境变量

* * *

指令：`export`  
export 本地变量名：`可以把本地变量变成环境变量`

export 变量名=值：`可以直接把这个变量定义成环境变量`

* * *

指令：`unset`  
语法：unset 环境变量名  
删除一个环境变量

* * *

全局变量：`environ`  
是C语言默认就有的一个全局变量，可以用来获取环境变量  
[注意：使用前必须先使用extern声明这个变量，不然编译不能通过]

类型：char**  
[=指向env数组的起始地址（注意不是指向env数组，因为它不是数组指针），这样它解引用就可以直接拿到环境变量==]

* * *

### 本地变量

本地变量是给bash进程内部使用的

可以直接在命令行中定义变量，此时这个变量就是bash的本地变量

Linux中定义变量的方式统一是：`变量名=值`

* * *

**OS为用户启动bash进程之后** ，`在内存中`  
①bash会读取配置文件之后搞出env环境变量表，用来所有存储环境变量  
②读取启动子进程的命令（字符串），生成argv命令行参数表  
③根据自己的需要，生成一张本地变量表，用来存储所有本地变量

**所以本地变量变成环境变量**  
只需要把这个本地变量从本地变量表中删除，再放进环境变量表中就可以了

* * *

**因为bash等shell中可以定义变量，也可以识别for，while等语法**  
所以shell也衍生出一门语言，也就是`shell脚本`

* * *

### 环境变量于本地变量的区别

环境变量能被子进程继承

bash的子进程再使用fork创建的子进程也能继承到bash的环境变量  
它再继续使用fork再创建，还能继承

所以环境变量能被bash和以bash为源头衍生出的所有进程继承  
`所以环境变量具有全局属性`

本地变量不能被子进程继承，只能在shell进程内部使用

* * *

### 环境变量为什么要具有全局属性？

①`因为环境变量本质是系统的配置信息`  
配置信息要生效，就必须是所有进程都遵守配置信息  
**但是进程遵守的前提是，进程能看到配置信息**

所以环境变量必须具有全局属性，能让所以进程都能“看见”

②`进程之间具有独立性，但是有时候也需要信息交互`  
环境变量就是一种交互的方式  
父进程可以通过环境变量，把一些信息传递给子进程[`一般是只读数据`]



