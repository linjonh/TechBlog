---
layout: post
title: "Windows控制台函数控制台输出函数WriteConsoleA"
date: 2025-03-09 20:37:52 +0800
description: "WriteConsoleA 是一个 Windows API 函数，用来把文字写到控制台屏幕上。就像你在 C++ 用 std::cout 输出东西，但它是直接跟 Windows 的控制台打交道。把它想象成一个“送信员”：你给它一堆信（文字）和一个地址（屏幕的钥匙），它就帮你把信送到屏幕上。它是 ReadConsoleA 的反向操作：ReadConsoleA 是收信，WriteConsoleA 是送信。"
keywords: "Windows控制台函数：控制台输出函数WriteConsoleA（）"
categories: ['控制台函数', 'Windows', 'Api']
tags: ['开发语言', 'Windows', 'C', 'C']
artid: "146138142"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146138142
    alt: "Windows控制台函数控制台输出函数WriteConsoleA"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146138142
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146138142
cover: https://bing.ee123.net/img/rand?artid=146138142
image: https://bing.ee123.net/img/rand?artid=146138142
img: https://bing.ee123.net/img/rand?artid=146138142
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Windows控制台函数：控制台输出函数WriteConsoleA（）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <h3 name="%E4%BB%80%E4%B9%88%E6%98%AF%20WriteConsoleA%EF%BC%9F">
     什么是 WriteConsoleA？
    </h3>
    <p>
     WriteConsoleA 是一个 Windows API 函数，用来把文字写到控制台屏幕上。就像你在 C++ 用 std::cout 输出东西，但它是直接跟 Windows 的控制台打交道。
    </p>
    <p>
     把它想象成一个“送信员”：
    </p>
    <ul>
     <li>
      <p>
       你给它一堆信（文字）和一个地址（屏幕的钥匙），它就帮你把信送到屏幕上。
      </p>
     </li>
     <li>
      <p>
       它是 ReadConsoleA 的反向操作：ReadConsoleA 是收信，WriteConsoleA 是送信。
      </p>
     </li>
    </ul>
    <h3 id="%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D" name="%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D">
     函数签名
    </h3>
    <p>
     它的完整定义是：
    </p>
    <pre><code class="language-cpp">BOOL WriteConsoleA(
    HANDLE hConsoleOutput,         // 屏幕的“钥匙”
    const VOID* lpBuffer,          // 要送的“信”
    DWORD nNumberOfCharsToWrite,   // 信有多少字符
    LPDWORD lpNumberOfCharsWritten,// 记录实际送了多少
    LPVOID lpReserved              // 不用，写 NULL
);</code></pre>
    <p>
     看起来有点像 ReadConsoleA，对吧？我一个个拆开讲。
    </p>
    <h3 id="%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3" name="%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3">
     参数详解
    </h3>
    <p>
     1. HANDLE hConsoleOutput - 屏幕的“钥匙”
    </p>
    <ul>
     <li>
      <p>
       这是什么：你用 GetStdHandle(STD_OUTPUT_HANDLE) 拿到的屏幕句柄。
      </p>
     </li>
     <li>
      <p>
       作用：告诉 WriteConsoleA：“我要往屏幕上送东西。”
      </p>
     </li>
     <li>
      <p>
       怎么用：
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">HANDLE screen = GetStdHandle(STD_OUTPUT_HANDLE);</code></pre>
    <ul>
     <li>
      <p>
       就像你告诉送信员：“用这个钥匙打开屏幕的信箱。”
      </p>
     </li>
    </ul>
    <p>
     2. const VOID* lpBuffer - 要送的“信”
    </p>
    <ul>
     <li>
      <p>
       这是什么：你要输出的文字，通常是一个 const char* 字符串。
      </p>
     </li>
     <li>
      <p>
       作用：这是送信员要送出去的内容。
      </p>
     </li>
     <li>
      <p>
       怎么用：
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">const char* message = "Hello";</code></pre>
    <ul>
     <li>
      <p>
       想象这是你要寄出去的信，内容是“Hello”。VOID* 表示它可以是任何类型，但我们用 char 就够了。
      </p>
     </li>
    </ul>
    <p>
     3. DWORD nNumberOfCharsToWrite - 信有多少字符
    </p>
    <ul>
     <li>
      <p>
       这是什么：一个数字，告诉函数“信里有多少字符要送”。
      </p>
     </li>
     <li>
      <p>
       作用：让送信员知道要送多长一段文字。
      </p>
     </li>
     <li>
      <p>
       怎么用：
      </p>
      <ul>
       <li>
        <p>
         如果 message 是“Hello”，就写 5（或者用 strlen(message)）。
        </p>
       </li>
       <li>
        <p>
         比如：
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <pre><code class="language-cpp">DWORD length = strlen(message); // 5</code></pre>
    <ul>
     <li>
      <p>
       这就像告诉送信员：“这封信有 5 个字，别漏了。”
      </p>
     </li>
    </ul>
    <p>
     4. LPDWORD lpNumberOfCharsWritten - 记录实际送了多少
    </p>
    <ul>
     <li>
      <p>
       这是什么：一个变量的地址，函数会把“实际送出去多少字符”写在这里。
      </p>
     </li>
     <li>
      <p>
       作用：告诉你送信员成功送了多少。
      </p>
     </li>
     <li>
      <p>
       怎么用：
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">DWORD how_many_written; // 定义一个变量</code></pre>
    <p>
     然后传地址：
    </p>
    <pre><code class="language-cpp">&amp;how_many_written</code></pre>
    <ul>
     <li>
      <p>
       跟 ReadConsoleA 的 lpNumberOfCharsRead 一样，送信员会记下：“我送了 5 个字符。”
      </p>
     </li>
    </ul>
    <p>
    </p>
    <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%A0%E5%9C%B0%E5%9D%80%E7%BB%99%20lpNumberOfCharsWritten%EF%BC%9F" name="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%A0%E5%9C%B0%E5%9D%80%E7%BB%99%20lpNumberOfCharsWritten%EF%BC%9F">
     为什么传地址给 lpNumberOfCharsWritten？
    </h4>
    <p>
     跟 ReadConsoleA 的 lpNumberOfCharsRead 一样：
    </p>
    <ul>
     <li>
      <p>
       函数需要修改 how_many_written，告诉你实际写了多少字符。
      </p>
     </li>
     <li>
      <p>
       传地址（&amp;how_many_written）让函数直接改这个变量。
      </p>
     </li>
     <li>
      <p>
       如果不传地址，函数改不了外面的值。
      </p>
     </li>
    </ul>
    <p>
    </p>
    <p>
     5. LPVOID lpReserved - 不用，写 NULL
    </p>
    <ul>
     <li>
      <p>
       这是什么：一个预留参数，微软留着以后可能用。
      </p>
     </li>
     <li>
      <p>
       作用：现在没用。
      </p>
     </li>
     <li>
      <p>
       怎么用：
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">NULL</code></pre>
    <ul>
     <li>
      <p>
       就像告诉送信员：“没啥特别要求，正常送就行。”
      </p>
     </li>
    </ul>
    <p id="%E8%BF%94%E5%9B%9E%E5%80%BC" name="%E8%BF%94%E5%9B%9E%E5%80%BC">
     <strong>
      返回值
     </strong>
    </p>
    <ul>
     <li>
      <p>
       返回 BOOL（TRUE 或 FALSE）：
      </p>
      <ul>
       <li>
        <p>
         TRUE：送信成功。
        </p>
       </li>
       <li>
        <p>
         FALSE：出错了（比如屏幕钥匙坏了）。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3 id="%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90" name="%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">
     一个最简单的例子
    </h3>
    <p>
     我们写个程序，在屏幕上显示“Hello”：
    </p>
    <pre><code class="language-cpp">#include &lt;windows.h&gt;
#include &lt;cstring&gt;

int main() {
    // 1. 拿到屏幕钥匙
    HANDLE screen = GetStdHandle(STD_OUTPUT_HANDLE);
    if (screen == INVALID_HANDLE_VALUE) {
        return 1; // 钥匙坏了，退出
    }

    // 2. 准备信和计数器
    const char* message = "Hello";    // 要送的信
    DWORD how_many_written;           // 记录送了多少

    // 3. 发送信（写到屏幕）
    WriteConsoleA(screen, message, strlen(message), &amp;how_many_written, NULL);

    return 0;
}</code></pre>
    <p>
     运行过程：
    </p>
    <ol>
     <li>
      <p>
       拿到钥匙：GetStdHandle(STD_OUTPUT_HANDLE) 给你屏幕的钥匙。
      </p>
     </li>
     <li>
      <p>
       准备信：
      </p>
      <ul>
       <li>
        <p>
         message 是“Hello”，长度是 5。
        </p>
       </li>
       <li>
        <p>
         how_many_written 是计数器。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       送信：
      </p>
      <ul>
       <li>
        <p>
         WriteConsoleA 把“Hello”送到屏幕上。
        </p>
       </li>
       <li>
        <p>
         how_many_written 变成 5，表示送了 5 个字符。
        </p>
       </li>
      </ul>
     </li>
    </ol>
    <p>
     运行结果：屏幕上显示“Hello”。
    </p>
    <h3 id="%E8%B7%9F%20ReadConsoleA%20%E5%AF%B9%E6%AF%94" name="%E8%B7%9F%20ReadConsoleA%20%E5%AF%B9%E6%AF%94">
     跟 ReadConsoleA 对比
    </h3>
    <table>
     <tbody>
      <tr>
       <th>
        <p>
         参数
        </p>
       </th>
       <th>
        <p>
         ReadConsoleA
        </p>
       </th>
       <th>
        <p>
         WriteConsoleA
        </p>
       </th>
      </tr>
      <tr>
       <td>
        <p>
         第一个
        </p>
       </td>
       <td>
        <p>
         键盘钥匙（输入）
        </p>
       </td>
       <td>
        <p>
         屏幕钥匙（输出）
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         第二个
        </p>
       </td>
       <td>
        <p>
         箱子（收信）
        </p>
       </td>
       <td>
        <p>
         信（送信）
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         第三个
        </p>
       </td>
       <td>
        <p>
         最多收多少字符
        </p>
       </td>
       <td>
        <p>
         要送多少字符
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         第四个
        </p>
       </td>
       <td>
        <p>
         记录实际收了多少（地址）
        </p>
       </td>
       <td>
        <p>
         记录实际送了多少（地址）
        </p>
       </td>
      </tr>
      <tr>
       <td>
        <p>
         第五个
        </p>
       </td>
       <td>
        <p>
         控制选项（NULL）
        </p>
       </td>
       <td>
        <p>
         预留（NULL）
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <ul>
     <li>
      <p>
       ReadConsoleA 是从键盘“收”东西到程序里。
      </p>
     </li>
     <li>
      <p>
       WriteConsoleA 是从程序“送”东西到屏幕上。
      </p>
     </li>
    </ul>
    <h3 id="%E5%86%8D%E8%AF%95%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BE%8B%E5%AD%90" name="%E5%86%8D%E8%AF%95%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BE%8B%E5%AD%90">
     再试一个有趣的例子
    </h3>
    <p>
     我们结合 SetConsoleCursorPosition，在不同位置写文字：
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">#include &lt;windows.h&gt;
#include &lt;cstring&gt;

int main() {
    HANDLE screen = GetStdHandle(STD_OUTPUT_HANDLE);
    if (screen == INVALID_HANDLE_VALUE) {
        return 1;
    }

    DWORD how_many_written;
    COORD pos;

    // 在 (5, 2) 写 "Hi"
    pos.X = 5; pos.Y = 2;
    SetConsoleCursorPosition(screen, pos);
    const char* msg1 = "Hi";
    WriteConsoleA(screen, msg1, strlen(msg1), &amp;how_many_written, NULL);

    // 在 (10, 5) 写 "There"
    pos.X = 10; pos.Y = 5;
    SetConsoleCursorPosition(screen, pos);
    const char* msg2 = "There";
    WriteConsoleA(screen, msg2, strlen(msg2), &amp;how_many_written, NULL);

    return 0;
}</code></pre>
    <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%A0%E5%9C%B0%E5%9D%80%E7%BB%99%20lpNumberOfCharsWritten%EF%BC%9F" name="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%A0%E5%9C%B0%E5%9D%80%E7%BB%99%20lpNumberOfCharsWritten%EF%BC%9F" style="background-color:transparent">
    </h4>
    <h3 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" name="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">
     注意事项
    </h3>
    <ol>
     <li>
      <p>
       字符数：
      </p>
      <ul>
       <li>
        <p>
         nNumberOfCharsToWrite 必须匹配 lpBuffer 的长度，不然可能出错。
        </p>
       </li>
       <li>
        <p>
         用 strlen 确保准确。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       换行：
      </p>
      <ul>
       <li>
        <p>
         如果想换行，得在字符串里加 \n，比如 "Hello\n"。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       检查返回值：
      </p>
     </li>
    </ol>
    <pre><code class="language-cpp">if (!WriteConsoleA(screen, message, strlen(message), &amp;how_many_written, NULL)) {
    return 1; // 出错了
}</code></pre>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38383034373637322f:61727469636c652f64657461696c732f313436313338313432" class_="artid" style="display:none">
 </p>
</div>


