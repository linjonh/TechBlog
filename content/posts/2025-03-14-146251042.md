---
layout: post
title: "游戏引擎学习第157天"
date: 2025-03-14 10:28:49 +0800
description: "在这个系统中，我们的目标是让内存分配能够控制在一个预设的上限内。具体来说，当进行资源（例如位图）加载时，系统会根据当前资源需求分配内存。我们会给内存分配设置一个上限，比如我们为资产存储设置了1GB的上限。当内存使用达到这个上限时，系统需要释放一些已经分配的内存空间，腾出足够的空间来继续加载新的资源。这个方案的核心理念并不复杂，基本上就是设置一个上限，并确保内存使用不超过该上限。实现上需要处理如何释放内存以便为新的资源腾出空间。"
keywords: "游戏引擎学习第157天"
categories: ['游戏引擎学习']
tags: ['游戏引擎', '学习']
artid: "146251042"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146251042
    alt: "游戏引擎学习第157天"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146251042
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146251042
cover: https://bing.ee123.net/img/rand?artid=146251042
image: https://bing.ee123.net/img/rand?artid=146251042
img: https://bing.ee123.net/img/rand?artid=146251042
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     游戏引擎学习第157天
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h2>
     <a id="_0">
     </a>
     今天的计划
    </h2>
    <p>
     目标是完整制作一款游戏，从头到尾的开发过程完全展示。过程中没有使用任何游戏引擎或库，目的是展示一个全面的游戏开发过程，包括每一个细节，从最基础的像素开始，直到最终的视觉效果。在整个过程中，涵盖了每一个小细节，确保每一部分都得到处理。
    </p>
    <p>
     目前，已经到达了一个关键的阶段，我们需要面对一个被认为是“硬核”的内存管理问题。尽管在这个系列的其他地方，也曾偶尔提到过内存管理，通常我们强调的是：内存管理不需要过多关注。对于大多数人来说，他们认为如果不使用垃圾回收机制（如在垃圾回收语言中），编程将变得非常困难，或者他们认为不使用这种机制会显著影响性能。很多人都有这些预设的想法，觉得如果没有这种抽象的内存管理机制，开发工作将变得复杂且难以掌控。
    </p>
    <p>
     然而，到目前为止，我们的开发过程中展示的情况证明了这一点——其实我们完全不需要过多担心内存管理。大部分时间，我们可以把内存管理问题简单化，把它看作一个简单的栈结构，写一次之后，基本上就可以不再考虑它了。虽然偶尔可能会遇到需要注意内存管理的情况，但总体而言，内存管理并不会成为一个长期需要关注的问题。
    </p>
    <p>
     但现在，我们正面临着一个不同的情形，这个阶段的内存管理问题相比之前的要更为复杂，值得我们深入讨论。这是目前我们需要关注的地方，也是我们接下来要解决的主要问题之一。
    </p>
    <h2>
     <a id="_9">
     </a>
     我们的资源内存管理问题无法通过垃圾回收器解决
    </h2>
    <p>
     需要记住的一点是，这个问题特别重要，而且实际上是不能通过垃圾回收语言来解决的。因此，这个问题是真正需要认真思考的，不管你选择如何建模你的内存。如果你真的关心如何正确处理这些问题，就必须思考内存管理。无论是自己管理内存，还是依赖垃圾回收，问题的核心不在于记得去释放资源或进行垃圾回收，而在于如何在有限的存储空间内做出最优的使用，这实际上是一个缓存问题。
    </p>
    <p>
     今天我们要做的，就是讨论这个问题。我不确定今天会进行多少编程工作，但主要目的是通过黑板讲解，给大家提供一个关于这个问题的概览，解释为什么它非常困难，列举几种可能的解决方法，或者说你可能会选择根本不去解决这个问题，这也是一种选择。接着，我们将决定解决这个问题的第一步该是什么，或者说如何开始着手处理它。
    </p>
    <h2>
     <a id="_14">
     </a>
     资源内存管理（黑板）
    </h2>
    <p>
     今天我们要讨论的问题是资源内存管理。
    </p>
    <p>
     首先，很多人对内存管理的讨论总是非常激烈，尤其是关于Java和C#之间的争论，大家总是围绕内存管理展开激烈的辩论。有些人认为，指针管理太难了，不能编程，完全不愿意去面对这些问题。甚至有人说，垃圾回收机制本身就是一种认知负担。对于这种观点，其实最好的做法就是让那些人带着他们的“认知负担”离开，不用和这些人争论。
    </p>
    <p>
     但是，如果你真心对这个话题感兴趣，想要深入了解内存管理的真正含义，下面是一种比较好的思考方式。这种方式帮助你理解内存管理的基本问题，并且能够更好地解决相关问题。
    </p>
    <h2>
     <a id="_21">
     </a>
     一个好的内存管理思路
    </h2>
    <p>
     在内存管理中，有几个关键点需要关注，首先是内存的
     <strong>
      数量
     </strong>
     。我们需要关心内存的大小，因为有时内存的限制会成为一个约束条件。无论人们如何试图忽视这一点，内存不足的问题总是会不断出现。过去，PC有足够的内存，但游戏主机的内存有限。随着时间的推移，虽然一些游戏主机开始具备足够的内存，手机的内存却变得越来越紧张。即便手机的内存逐渐增加，其他设备如智能手表的内存仍然非常有限。无论技术如何进步，我们总会遇到内存不足的情况，所以我们必须始终关注内存的使用量。
    </p>
    <p>
     第二个关注点是
     <strong>
      时间
     </strong>
     ，即内存管理的时机。什么时候需要哪部分内存，以及什么时候释放它，这涉及到如何在代码中跟踪和管理内存的使用。这与垃圾回收机制密切相关。在一些内存管理语言中，垃圾回收机制的核心就是帮助我们追踪何时需要内存，什么时候不再需要内存，进而帮助释放不再使用的内存。然而，垃圾回收并不会直接减少内存的使用，它只是帮助自动化地找出哪些内存可以被释放，而我们不需要自己去编写代码进行释放。
    </p>
    <p>
     垃圾回收的工作原理其实就是通过遍历程序的内存图，检查哪些内存块仍在使用，哪些内存块不再需要，并自动释放这些不再需要的内存。其本质上是在代替开发者自己去判断内存是否还需要使用，而通过自动化的方式来进行内存管理。垃圾回收的一个关键挑战是如何高效地进行这个“图遍历”操作，因为每次进行遍历都会消耗大量的计算资源，尤其是在程序复杂时，搜索范围越大，开销就越高。为了提高效率，通常采取一些优化措施，比如仅在内存变化较大的情况下进行检查，或者将检查操作分配到不同的线程中去执行。
    </p>
    <p>
     不过，对于我们目前的项目来说，垃圾回收并不是一个必要的技术。到目前为止，我们的内存管理问题主要是通过简单的栈结构来解决的。我们并没有遇到过需要垃圾回收来优化内存使用的情况。我们在编程时只是按需将数据推入栈中，代码的执行也不需要额外的内存管理操作。对于当前的情况，垃圾回收其实会引入不必要的额外开销，因为我们并不需要进行频繁的内存检查。
    </p>
    <p>
     当然，在某些特殊的情况下，垃圾回收可能会派上用场。例如，在一些具有复杂结构的程序中，或者是当程序删除某个对象时，可能需要判断与其相关的其他对象是否也应被删除。在一些游戏中，可能会遇到这种情况，比如当一个实体被删除时，是否需要删除与之相关的其他实体。垃圾回收在这些情况下提供了一种通用的解决方案，它可以帮助开发者自动检测哪些对象不再需要，而不需要开发者手动去编写代码来管理这些关系。
    </p>
    <p>
     总之，垃圾回收的主要作用是替代开发者去处理内存的回收问题，尤其是在程序结构复杂时，但对于我们当前的项目而言，垃圾回收的功能并不必要。
    </p>
    <h2>
     <a id="_34">
     </a>
     我们所需的内存大于我们拥有的内存。我们有一个虚拟内存问题。
    </h2>
    <p>
     在处理资产内存管理时，垃圾回收机制并没有帮助，因为这里的问题与垃圾回收无关。主要的问题是
     <strong>
      内存的容量
     </strong>
     ，即我们需要的内存超过了系统的实际内存容量。假设我们有三TB的游戏资产，但我们只有4GB的RAM，这时就面临了内存不足的问题。所有这些资产都在使用中，没有任何一个是多余的、可以被垃圾回收的，我们需要所有的资产数据，只是无法一次性加载到内存中。因此，根本的问题是
     <strong>
      缓存问题
     </strong>
     。
    </p>
    <p>
     如果所有资产都可以完全加载到内存中，问题就解决了。此时，内存容量和资产大小相等，内存管理系统就能高效地加载需要的资产到内存中，而不需要担心垃圾回收。系统会按照需求顺序加载所需资产，并且加载过程是后台进行的，用户不需要等待加载过程。
    </p>
    <p>
     然而，当资产的数量超出了内存容量时，问题就变成了
     <strong>
      虚拟内存问题
     </strong>
     。内存只能存储部分资产数据，需要选择哪些资产载入内存并定期淘汰不再需要的资产。具体来说，当内存已经满了，我们需要
     <strong>
      驱逐
     </strong>
     当前内存中的部分资产，腾出空间加载其他资产。等到这些被驱逐的资产再次需要时，它们会重新加载到内存中。
    </p>
    <p>
     这里，垃圾回收并不能解决问题，因为它并不处理这种内存交换或加载的问题。垃圾回收解决的是对象是否仍然被引用的问题，但在这种场景下，我们需要的是根据时间和需求选择性加载资产。因此，这实际上是一个虚拟内存问题，而不是内存垃圾回收的问题。
    </p>
    <p>
     我们的目标是始终拥有所有资产的引用，但我们不需要将所有资产都常驻内存。只有那些当前需要，或者在接下来的短时间内需要使用的资产才会被保留在内存中。对于那些可能在很久以后才会使用的资产，完全不需要在此时占用内存。
    </p>
    <p>
     总结来说，垃圾回收无法解决内存管理中的这一问题，因为它无法处理虚拟内存和缓存管理的问题。我们需要通过选择性加载和驱逐资产来管理内存，而不是依赖垃圾回收机制。
    </p>
    <h2>
     <a id="_47">
     </a>
     栈和垃圾回收不能帮助我们解决这个问题
    </h2>
    <p>
     在讨论内存管理时，
     <strong>
      垃圾回收
     </strong>
     和
     <strong>
      栈
     </strong>
     都无法有效解决我们面临的问题，主要是由于
     <strong>
      内存碎片化
     </strong>
     的问题。具体来说，如果系统有4GB的内存并且正在使用这些内存，我们可能会面临以下几种情况：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        垃圾回收的局限性
       </strong>
       ：如果我们有多个资产（例如资产A、B、C等）存储在内存中，垃圾回收机制通常需要明确指示哪些资产不再需要，从而释放这些资产的内存。然而，垃圾回收机制本身并不能自动判断哪些内存区域应该释放，因此我们仍然需要手动进行内存释放操作。这种操作的成本和复杂性会增加。
      </p>
     </li>
     <li>
      <p>
       <strong>
        栈的局限性
       </strong>
       ：栈机制同样存在类似的问题。当栈中有多个元素（例如A、B、C、D等）时，栈会按顺序分配和释放内存。当我们释放一个元素时，栈的内存并不一定会被完全填满，而是留下空洞。如果后续的元素大小不同，可能无法填补这些空洞，这就是
       <strong>
        内存碎片化
       </strong>
       。如果栈中释放的内存空间大小与新的内存需求不匹配，就会产生碎片，这导致内存利用效率降低。
      </p>
     </li>
     <li>
      <p>
       <strong>
        内存碎片化的影响
       </strong>
       ：内存碎片化是一个严重的问题，尤其是在内存有限的情况下。如果有4GB内存，随着内存的分配和释放，内存空间会逐渐变得零散。这样，即使系统表面上看似有足够的内存，但实际上，因为内存中存在许多无法利用的小碎片，整体有效内存会减少。这种碎片化问题会逐渐导致内存的有效利用率降低，从而使得系统无法满足新的内存需求，甚至可能导致内存不足。
      </p>
     </li>
     <li>
      <p>
       <strong>
        无法解决的问题
       </strong>
       ：垃圾回收和栈管理都无法解决内存碎片化的问题。即使是垃圾回收，它仅仅是通过查找未使用的内存并释放它，但它并没有能力有效地解决碎片化。栈机制虽然可以通过先进后出方式管理内存，但一旦内存中出现碎片，它也无能为力。
      </p>
     </li>
    </ol>
    <p>
     因此，解决内存碎片化问题的关键在于底层的内存分配器。一个好的内存分配器能够在内存管理中有效地处理碎片化问题，尽量避免留下无法利用的空洞。垃圾回收和栈管理可以在内存管理的基础上进行，但如果没有有效的底层内存分配机制，依旧无法解决碎片化带来的问题。
    </p>
    <p>
     综上所述，垃圾回收和栈机制并不能直接帮助解决内存碎片化的问题，需要在更底层的内存管理上进行改进。
    </p>
    <h2>
     <a id="_62">
     </a>
     如果所有的资源大小都相同的世界……
    </h2>
    <p>
     在一个理想的世界中，如果所有的资产大小都相同，那么内存管理将变得非常简单而高效。如果内存池中的所有资产都具有相同的大小，比如每个资产占用相同的内存空间，我们可以非常容易地管理它们。
    </p>
    <p>
     假设内存池中存储了多个相同大小的资产，例如：A、B、C、D、E等。假如我们需要加载一个新的资产F，并且F的大小与现有资产相同，那么我们可以简单地检查哪个资产是最久未使用的（即在最多的帧中未被访问）。我们可以将这个最旧的资产剔除，并将新的资产F插入到它的位置。
    </p>
    <p>
     这种方式下，不会出现碎片化问题，因为每个资产都占用相同的内存空间，不会留下任何无法利用的空隙。因此，无论内存空间有多大，例如4GB，只要每个资产大小固定（例如256MB），我们就可以确定内存中总是存储固定数量的资产。假设每个资产是256MB，那么总共可以存储16个资产，每次加载新资产时，我们都会移除最久未使用的资产，替换为新的资产。这样，内存始终被充分利用，不会浪费。
    </p>
    <p>
     这也是为什么固定大小的内存分配器非常优秀的原因。任何可以转化为固定大小分配问题的场景都非常理想，因为这种方式能够完美地管理内存，不会产生碎片，操作非常简单直接。类似的做法在内存管理中已有实践，例如使用**空闲列表（free list）**来管理固定大小的内存块。当我们释放一个内存块时，系统会将其回收到空闲列表中，以便之后重新使用。这是一种经典的固定大小分配器方法，简单且高效。
    </p>
    <p>
     总之，在所有资产大小相同的情况下，内存管理变得非常简单，内存利用率最大化，且没有碎片化问题。固定大小的内存分配器正是这种理想管理的解决方案。
    </p>
    <h2>
     <a id="_73">
     </a>
     在我们的情况下，资源大小并不相同，但我们可以找到绕过的办法
    </h2>
    <p>
     我们面临的问题是如何处理不相同大小的资产。为了应对这个问题，实际上有两种可能的解决方案。首先，考虑将这个问题转化为固定大小的内存分配问题。这是我们可以选择的一种方式。
    </p>
    <p>
     例如，假设我们决定将所有精灵的大小都固定为256x256像素。这样，所有位图的大小都相同，加载时可以轻松地将新位图放入已经释放的位置，因为每个精灵的大小是固定的，释放一个精灵时需要的内存空间和加载新精灵所需要的空间是完全一致的。这是一个相对直接和有效的方案。
    </p>
    <p>
     然而，这种做法的缺点在于，它无法准确地表示我们实际需要的内容。强制要求所有位图大小相同并不合理，因为一些位图可能比256x256大，而一些则比它小，这样就会浪费内存空间。例如，如果有些位图仅需要较小的空间，那么强制它们与较大的位图占用相同的内存区域，必然会造成内存浪费。因此，固定大小的分配方法在处理不同大小的资产时并不是最优选择。
    </p>
    <p>
     另一种解决方案是将资产进行瓦片化处理。假设我们有一个英雄角色，而不是将其表示为一个固定大小的位图，我们可以将它分割成多个小的瓦片。例如，如果英雄角色的尺寸是512x512像素，那么可以将其拆分为多个256x256像素的小瓦片。这种方式能够避免强制所有位图大小相同的问题，虽然它依然可能带来一些浪费。
    </p>
    <p>
     然而，这种方式的缺点是，如果原始资产的尺寸不是瓦片大小的整数倍，就会产生额外的空间浪费。比如，假设英雄角色的尺寸是270x283像素，那么就无法完美地适应瓦片化方式，可能会有一些空余的空间被浪费掉，因为这些空间无法被完整填充。这种方式尽管能够更灵活地处理不同大小的资产，但仍然存在一些空间浪费的情况。
    </p>
    <p>
     总的来说，处理不等大小的资产时，我们面临两种主要的选择：一种是将资产大小固定，从而简化内存管理；另一种是采用瓦片化策略，以适应不同尺寸的资产，虽然这种方法同样会存在一定的内存浪费。
    </p>
    <h2>
     <a id="Megatexture_86">
     </a>
     我们可以有一个大的精灵图集，当需要时分页加载块（类似于Megatexture）
    </h2>
    <p>
     为了应对不同大小资产的问题，我们可以考虑几种方法来减轻其中的空间浪费。例如，我们可以把整个游戏当作一个巨大的精灵图集（sprite sheet），并且所有的精灵都自动地打包进这个图集里，而不是手动处理。然后，这个图集可以按瓦片进行分割。每次需要加载一个精灵时，我们只需确定这个精灵对应的瓦片，并加载这些瓦片。这些瓦片通常是固定大小的，这样可以避免不必要的浪费，这个方法与“智能虚拟纹理”（smart virtual textures）非常相似，类似于“大纹理”方案。
    </p>
    <p>
     这种方法确实有一定的优点，因此不应该轻易忽视。然而，也有一些问题需要考虑，最主要的挑战是如何处理
     <strong>
      mipmap
     </strong>
     。对于这种方案，mipmap处理起来会非常复杂，尤其是我们不希望在此讨论过多的细节。但可以说，mipmap在这种情况下会变得非常难以管理，因为这种打包方式可能会导致纹理的细节变化变得不可预见。
    </p>
    <p>
     不过，如果是2D游戏，我们可能能够规避这些问题。在2D游戏中，通常可以提前知道每个mipmap层次的内容，并且不需要执行三线性过滤（trilinear filtering），也没有复杂的角度变化。这样，采用这种方案是可行的，至少在许多2D游戏中是适用的。
    </p>
    <p>
     通过这种方式，我们并没有完全解决资产大小不同的问题。虽然我们能够将整个精灵图集的资产统一成相同的大小（例如，瓦片化处理），但依然存在资产本身大小不同的情况。比如，如果一个资产是512x512像素，它就会占用四个瓦片，而另一个资产如果只有256x256像素，它则只占用一个瓦片。这样，即使每个精灵图集的大小是统一的，资产本身仍然是变动的。
    </p>
    <p>
     此外，虽然图集页表（page table）中的瓦片大小是统一的，但不同大小的资产仍然需要不同数量的索引。例如，512x512像素的资产需要四个索引，而256x256像素的资产只需要一个索引。虽然我们可以选择不对这些瓦片进行分页处理，将瓦片索引表（asset tile list）在启动时加载到内存中，并保持在内存中，这样就不需要频繁地访问磁盘，整个过程的开销可能会变得更小。这个瓦片索引表可能相对较小，例如10MB左右，只需加载一次，之后只需按需加载瓦片数据。
    </p>
    <p>
     总的来说，这个方法看起来是一种可行的解决方案，尤其在某些情况下，它可能比其他方法更有效。尽管我们可能需要继续考虑更多的优化方案，但目前这种方法似乎是一个较为直接且有潜力的选择。
    </p>
    <h2>
     <a id="_99">
     </a>
     另一种选择：一个可变分配器。它可以进行内存碎片整理或合并连续的空闲空间。我们因为教育原因选择了这种方式
    </h2>
    <p>
     另一种选择是使用常规的内存分配器，即支持可变大小分配器。这种方法允许在内存中分配不同大小的资源。在这种情况下，我们可以分配内存块来存储资源或资产。例如，如果我们有4GB的内存池，首先可以为资产a、b、c分配空间。当我们需要为其他资产分配空间时，我们可能会遇到碎片化问题。如果我们释放了资产b，内存中的这个空间就变得无法使用，因为它可能太小，无法放置任何新的资产。
    </p>
    <p>
     为了应对这个问题，有两种选择。首先，可以进行内存压缩。当某个资产（如资产c）被释放后，我们可以将其他资产移到这个空闲空间中，减少碎片化的影响。这样，释放的空间就能重新被有效利用。第二种方法是采用标准的可变大小分配器机制，也就是在释放内存时进行合并。当释放一个资源后，我们记录下空闲空间的大小，并将这些空间合并起来。例如，释放了资产c后，c的空间和资产b之前的空闲空间合并成一个更大的空闲区域，这样就能提供更多可用内存。
    </p>
    <p>
     在实现过程中，实际上我们可以选择开发一个这样的可变大小内存分配器。虽然这种方法可能不是处理资产管理的最佳方式，但它有很大的教育意义。通过手动构建一个这样的分配器，可以帮助理解内存管理的底层机制，因为这实际上是像
     <code>
      malloc
     </code>
     和
     <code>
      free
     </code>
     这样的函数背后所做的事情。在垃圾回收语言中，垃圾回收器背后也需要一个类似的内存分配系统，来高效地管理内存的分配和释放，否则垃圾回收器就会效率低下，无法有效地回收内存。
    </p>
    <p>
     因此，即使这可能不是最优化的资产管理方法，从教育角度来看，开发一个这样的内存分配器是一个值得尝试的过程。通过亲自实现和调试这个系统，可以更深入地理解内存分配和碎片化问题的解决方法，也能学到如何优化内存管理。这对构建高效的资产管理系统是非常有帮助的。
    </p>
    <h2>
     <a id="_108">
     </a>
     可变分配器概述
    </h2>
    <p>
     在这个系统中，我们的目标是让内存分配能够控制在一个预设的上限内。具体来说，当进行资源（例如位图）加载时，系统会根据当前资源需求分配内存。我们会给内存分配设置一个上限，比如我们为资产存储设置了1GB的上限。当内存使用达到这个上限时，系统需要释放一些已经分配的内存空间，腾出足够的空间来继续加载新的资源。
    </p>
    <p>
     这个方案的核心理念并不复杂，基本上就是设置一个上限，并确保内存使用不超过该上限。实现上需要处理如何释放内存以便为新的资源腾出空间。要做到这一点，需要仔细检查现有的内存结构，查看是否有足够的空闲空间来容纳新资源，或者是否应该将其放置在其他位置。虽然从概念上看，这种做法并不复杂，但在实现时需要非常精确的操作，因此代码会变得比较复杂，涉及到如何高效地管理和安排内存空间。
    </p>
    <p>
     这种内存分配的方法有时被视为一种“黑魔法”。因为没有固定的标准方法来解决所有内存分配问题。不同的方案往往是根据特定工作负载进行调优的。开发者通常会根据特定需求，选择合适的分配策略。例如，有些分配器像
     <code>
      dlmalloc
     </code>
     就是为特定工作负载设计的，经过优化可以减少内存浪费，并且在查找合适空间时不会花费太多时间。
    </p>
    <p>
     整体而言，内存分配器的设计并没有一个“放之四海而皆准”的标准。很多时候，开发者会根据特定的应用场景，选择合适的内存管理策略。在游戏开发中，内存分配器的调优通常会侧重于如何高效地利用内存，避免浪费，并保证系统能快速找到合适的内存空间来存储新的资源。
    </p>
    <h2>
     <a id="_117">
     </a>
     故意让内存耗尽
    </h2>
    <p>
     在这个系统中，目标是让内存分配系统能够在达到特定限制时进行适当的处理。为了测试系统是否会在内存达到上限时崩溃，首先进行了一些小规模的内存分配操作，例如分配了1MB或2MB的内存。然后，通过对系统的操作，观察是否会触发内存不足的情况。最终的目的是模拟当内存达到限制时的行为。
    </p>
    <p>
     在模拟过程中，当进行某些操作时（例如旋转角色，或者加载特定资产），内存使用量迅速达到预定限制。系统会在达到这个硬性上限时“崩溃”或无法加载更多的资源，这是我们想要实现的行为。通过这种方式，能够明确在内存达到极限时，系统会如何反应，为后续的内存管理和资源清理提供依据。
    </p>
    <p>
     在这个过程中，偶尔会出现一些不必要的元素，比如粒子系统，虽然它带来了一些幽默效果，但并不影响系统的核心操作。接下来，重点是让资产系统的内存管理更加灵活和高效，确保在内存接近上限时，能够正确判断何时释放内存并保持足够的头部空间。
    </p>
    <p>
     系统的内存分配是在一个特定的内存区域内进行的，而这个区域必须能够处理各种大小的资产。当内存接近上限时，系统需要能够判断是否需要释放内存，并且释放的数量需要足够确保后续操作不会因为内存不足而中断。因此，接下来需要考虑如何根据实际需求来释放内存，并确保内存释放的策略能有效支持系统的运行。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/bc658c67d63349bdb1542db5a583c44f.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/ed01fb0f77af48a8a7b6eda91908e4ef.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/40e3c4a915f74a3e96db2dfc646d0b73.png#pic_center"/>
    </p>
    <h2>
     <a id="_loaded_bitmap__loaded_sound_asset_slots_132">
     </a>
     重构 loaded_bitmap 和 loaded_sound，将资源数据移入 asset_slots
    </h2>
    <p>
     我们正在思考如何优化资产槽（asset slots）的存储方式，以减少内存使用和提升访问效率。目前，每个资产槽存储着一些基础信息，比如状态变量（32位）、指向实际数据的指针等，总体大小大约为12字节。然而，这种方式引入了一定的间接访问成本，因此考虑是否可以直接将
     <code>
      loaded_bitmap
     </code>
     和
     <code>
      loaded_sound
     </code>
     结构体嵌入到资产槽中，而不是使用指针指向外部存储。
    </p>
    <h4>
     <a id="_135">
     </a>
     <strong>
      优化思路
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        去掉 Pitch 字段(要改的太多先不优化)
       </strong>
      </p>
      <ul>
       <li>
        <code>
         loaded_bitmap
        </code>
        结构体目前存储了
        <code>
         width
        </code>
        、
        <code>
         height
        </code>
        和
        <code>
         pitch
        </code>
        （行间距）。我们设想
        <code>
         pitch
        </code>
        是否可以直接通过
        <code>
         width
        </code>
        计算得出，而不必额外存储。
       </li>
       <li>
        计算
        <code>
         pitch
        </code>
        的方式可以封装成一个
        <code>
         GetPitch()
        </code>
        函数，在访问时动态计算，而不是存储它。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        调整数据类型，减少内存占用
       </strong>
      </p>
      <ul>
       <li>
        <code>
         width
        </code>
        和
        <code>
         height
        </code>
        目前是 32 位的整数（int32），但实际游戏中不会有 20 亿像素宽的贴图，因此可以将它们缩小到 16 位（uint16），减少空间占用。
       </li>
       <li>
        16 位的
        <code>
         width
        </code>
        和
        <code>
         height
        </code>
        能表示最大 65535×65535 的图像，远远超过需求，且大部分贴图不会超过 4096×4096。
       </li>
       <li>
        这样
        <code>
         loaded_bitmap
        </code>
        结构体的存储空间减少了 8 字节（两个 32 位字段变成 16 位字段）。
        <br/>
        <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/fc0490400ce54825975f6d8cecea48d4.png#pic_center"/>
       </li>
      </ul>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/0caf190ffbc24c729dc2a15fc0284441.png#pic_center"/>
      </p>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/3e5203664dff43e29aa9b15a54673189.png#pic_center"/>
      </p>
      <p>
       <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/693a554f993f47549082ef2772b32b2e.png#pic_center"/>
      </p>
     </li>
     <li>
      <p>
       <strong>
        调整
        <code>
         loaded_sound
        </code>
        结构体
       </strong>
      </p>
      <ul>
       <li>
        <code>
         sample_count
        </code>
        目前是 32 位整数，可以缩小到 24 位，因为不会有 20 亿个采样点的音频数据。
       </li>
       <li>
        <code>
         channel_count
        </code>
        目前是 32 位整数，但实际音频通道数一般在 1-8 之间，因此可以用 4 位存储即可。
       </li>
       <li>
        可以将
        <code>
         sample_count
        </code>
        和
        <code>
         channel_count
        </code>
        合并到一个 32 位整数中，减少整体占用。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        移除指针，直接嵌入数据
       </strong>
      </p>
      <ul>
       <li>
        目前
        <code>
         loaded_bitmap
        </code>
        和
        <code>
         loaded_sound
        </code>
        结构体分别使用指针指向外部存储的具体数据。如果能将它们直接存储在资产槽内，就能省去存储指针的额外开销，并避免额外的动态内存分配。
       </li>
       <li>
        这样做的前提是资产大小是固定或可预测的，否则会导致存储空间浪费或存取不便。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        优化
        <code>
         asset_state
        </code>
        的存储
       </strong>
      </p>
      <ul>
       <li>
        <code>
         asset_state
        </code>
        目前是 32 位整数，可能可以缩小，或者与其他字段一起打包存储，以减少结构体内存填充（padding）带来的浪费。
       </li>
       <li>
        但
        <code>
         asset_state
        </code>
        需要进行原子写操作（atomic write），所以不能简单地改为更小的位宽。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_166">
     </a>
     <strong>
      最终优化目标
     </strong>
    </h4>
    <ul>
     <li>
      通过上述调整，使
      <code>
       loaded_bitmap
      </code>
      和
      <code>
       loaded_sound
      </code>
      结构体尽量缩小，并直接嵌入到
      <code>
       asset_slot
      </code>
      结构体中。
     </li>
     <li>
      预计
      <code>
       loaded_bitmap
      </code>
      结构体可缩小到
      <strong>
       16 字节
      </strong>
      （去掉
      <code>
       pitch
      </code>
      、调整
      <code>
       width
      </code>
      和
      <code>
       height
      </code>
      为
      <code>
       uint16
      </code>
      ）。
     </li>
     <li>
      <code>
       loaded_sound
      </code>
      结构体如果缩小到
      <strong>
       12 字节
      </strong>
      ，可以进一步优化，使
      <code>
       asset_slot
      </code>
      整体大小保持一致，节省存储空间。
     </li>
    </ul>
    <p>
     通过这些优化，资产槽的数据访问将更加高效，减少动态分配，提高 CPU 缓存命中率，并降低存储开销。
    </p>
    <h2>
     <a id="_asset_slots_173">
     </a>
     将资源数据移入 asset_slots
    </h2>
    <p>
     我们现在要做的是将
     <code>
      loaded_bitmap
     </code>
     和
     <code>
      loaded_sound
     </code>
     直接存储在
     <code>
      asset_slot
     </code>
     结构体中，而不再通过指针引用外部数据。这样可以减少动态内存分配的开销，提高访问效率，并让
     <code>
      asset_state
     </code>
     成为唯一决定资源是否可用的条件。
    </p>
    <h4>
     <a id="_176">
     </a>
     <strong>
      具体优化步骤
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        移除指针，直接存储数据
       </strong>
      </p>
      <ul>
       <li>
        之前，
        <code>
         asset_slot
        </code>
        结构体使用指针指向
        <code>
         loaded_bitmap
        </code>
        和
        <code>
         loaded_sound
        </code>
        ，而这些数据实际上可以直接存放在
        <code>
         asset_slot
        </code>
        内部。
       </li>
       <li>
        现在的优化方式是不再为这些数据分配额外的结构体，而是直接在
        <code>
         asset_slot
        </code>
        内存储
        <code>
         loaded_bitmap
        </code>
        和
        <code>
         loaded_sound
        </code>
        ，这样可以减少
        <code>
         push_struct
        </code>
        的调用，并避免额外的内存分配。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        调整数据访问方式
       </strong>
      </p>
      <ul>
       <li>
        由于
        <code>
         loaded_bitmap
        </code>
        和
        <code>
         loaded_sound
        </code>
        现在已经是
        <code>
         asset_slot
        </code>
        的成员，访问它们时不需要再使用指针，而是直接访问
        <code>
         asset_slot
        </code>
        内部数据。
       </li>
       <li>
        例如，在使用
        <code>
         bitmap
        </code>
        时，不再需要通过
        <code>
         asset-&gt;loaded_bitmap
        </code>
        访问，而是直接从
        <code>
         slot.bitmap
        </code>
        获取数据。
       </li>
       <li>
        代码中的
        <code>
         slot
        </code>
        变量存储了当前
        <code>
         asset_slot
        </code>
        ，后续所有的资源访问都可以通过
        <code>
         slot
        </code>
        来完成，而不需要再进行间接寻址。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        删除冗余的动态内存分配
       </strong>
      </p>
      <ul>
       <li>
        之前，在
        <code>
         push_struct
        </code>
        时，会为
        <code>
         loaded_bitmap
        </code>
        或
        <code>
         loaded_sound
        </code>
        分配空间，现在不再需要这样做，而是直接在
        <code>
         asset_slot
        </code>
        结构体中操作已有的内存。
       </li>
       <li>
        例如，原先代码在加载音频时，需要先分配
        <code>
         loaded_sound
        </code>
        结构体，再分配具体的音频数据，而现在
        <code>
         loaded_sound
        </code>
        直接存在
        <code>
         asset_slot
        </code>
        内部，因此只需要直接操作
        <code>
         slot.sound
        </code>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        更新代码逻辑
       </strong>
      </p>
      <ul>
       <li>
        在
        <code>
         asset_slot
        </code>
        结构体中，我们可以用
        <code>
         slot.bitmap
        </code>
        和
        <code>
         slot.sound
        </code>
        直接替代之前的指针引用，从而减少不必要的间接访问。
       </li>
       <li>
        例如，之前
        <code>
         bitmap
        </code>
        需要先通过
        <code>
         loaded_bitmap
        </code>
        结构体获取，现在可以直接通过
        <code>
         slot.bitmap
        </code>
        访问：
        <pre><code class="prism language-cpp">bitmap <span class="token operator">=</span> <span class="token operator">&amp;</span>slot<span class="token punctuation">.</span>bitmap<span class="token punctuation">;</span>
</code></pre>
       </li>
       <li>
        这样，在代码中所有需要
        <code>
         bitmap
        </code>
        的地方，都可以直接使用
        <code>
         slot.bitmap
        </code>
        ，不需要再去访问
        <code>
         loaded_bitmap
        </code>
        指针。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        检测优化后的资源加载情况
       </strong>
      </p>
      <ul>
       <li>
        在测试过程中，我们通过播放音乐来检查资源加载是否正常。如果某些优化导致音频加载失败，就需要回溯检查代码修改。
       </li>
       <li>
        发现一个问题：优化后，当音乐资源被加载时，会导致内存分配超出预设的
        <code>
         arena
        </code>
        大小，导致程序崩溃。
       </li>
       <li>
        解决方案是将
        <code>
         arena
        </code>
        允许的内存大小调整为
        <code>
         3MB
        </code>
        ，以确保音频资源能够正确加载。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_203">
     </a>
     <strong>
      优化后的效果
     </strong>
    </h4>
    <ul>
     <li>
      资源
      <code>
       bitmap
      </code>
      和
      <code>
       sound
      </code>
      直接存储在
      <code>
       asset_slot
      </code>
      结构体中，消除了指针引用和
      <code>
       push_struct
      </code>
      调用，减少了动态内存分配。
     </li>
     <li>
      访问资源时，代码更加简洁，不需要通过指针进行间接访问，而是直接从
      <code>
       slot
      </code>
      获取数据，提高访问效率。
     </li>
     <li>
      代码逻辑变得更加清晰，所有资源加载和访问都可以通过
      <code>
       asset_slot
      </code>
      直接完成，减少了额外的内存管理逻辑。
     </li>
     <li>
      通过调整
      <code>
       arena
      </code>
      大小，确保了优化后音频资源依然可以正常加载，避免了因内存限制导致的崩溃。
     </li>
    </ul>
    <p>
     整体来看，这次优化成功减少了不必要的内存分配，提高了资源访问效率，并且使代码更加清晰易读。
     <br/>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/8b71cc3e45694a16801ed665e46f7a27.png#pic_center"/>
    </p>
    <p>
     <img alt="在这里插入图片描述" src="https://i-blog.csdnimg.cn/direct/150b53ce1bbc41549e85c45d1f1dca34.png#pic_center"/>
    </p>
    <h2>
     <a id="_215">
     </a>
     提前确定何时会达到内存限制
    </h2>
    <p>
     我们现在需要找到一种方法，在资源加载之前提前判断是否会达到加载限制。这比想象中更复杂，因此需要引入一个相对高级的机制来解决问题。
    </p>
    <h4>
     <a id="_218">
     </a>
     <strong>
      问题分析
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        资源加载的限制
       </strong>
      </p>
      <ul>
       <li>
        目前，资源（如
        <code>
         bitmap
        </code>
        和
        <code>
         sound
        </code>
        ）的加载受到
        <code>
         arena
        </code>
        大小的限制，一旦超过设定的内存阈值，就会导致内存不足的情况。
       </li>
       <li>
        我们需要在加载资源之前，提前知道是否有足够的内存可用，并在必要时执行清理操作。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        现有问题
       </strong>
      </p>
      <ul>
       <li>
        现在的加载机制并不会主动检查是否有足够的空间，而是直接尝试加载资源，导致某些情况下会触发
        <code>
         arena
        </code>
        内存溢出。
       </li>
       <li>
        资源管理系统缺少一个智能的回收机制，当
        <code>
         arena
        </code>
        空间不足时，它应该自动释放部分旧资源，为新资源腾出空间。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_227">
     </a>
     <strong>
      解决方案概述
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        内存占用预测
       </strong>
      </p>
      <ul>
       <li>
        在加载新资源之前，我们需要能够准确预测该资源的大小，并检查当前可用的内存是否足够。
       </li>
       <li>
        例如，如果一个资源需要
        <code>
         1MB
        </code>
        空间，而当前
        <code>
         arena
        </code>
        仅剩
        <code>
         512KB
        </code>
        ，我们就需要提前释放
        <code>
         512KB
        </code>
        或更多的空间。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        智能释放机制
       </strong>
      </p>
      <ul>
       <li>
        当
        <code>
         arena
        </code>
        没有足够的空间时，需要主动回收一部分已加载但未使用的资源。
       </li>
       <li>
        释放策略可以是：
        <ul>
         <li>
          <strong>
           LRU（Least Recently Used，最近最少使用）
          </strong>
          ：优先释放最久未使用的资源。
         </li>
         <li>
          <strong>
           优先级机制
          </strong>
          ：根据资源的重要性决定是否释放，例如UI资源可能比背景音乐更重要。
         </li>
         <li>
          <strong>
           大小匹配
          </strong>
          ：释放足够大小的资源，而不是无差别地释放资源。
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        动态调整
        <code>
         arena
        </code>
        分配
       </strong>
      </p>
      <ul>
       <li>
        目前
        <code>
         arena
        </code>
        的大小是固定的，但可以考虑在必要时扩展或动态调整，以适应更大的资源需求。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_242">
     </a>
     <strong>
      下一步计划
     </strong>
    </h4>
    <ul>
     <li>
      设计一个智能的资源管理系统，使其能够在加载资源之前预测是否有足够空间，并在需要时自动释放旧资源。
     </li>
     <li>
      具体实现可能涉及一个
      <strong>
       资源管理队列
      </strong>
      或
      <strong>
       哈希表
      </strong>
      ，用来跟踪每个资源的
      <strong>
       使用情况、大小和优先级
      </strong>
      。
     </li>
     <li>
      明天将具体实现这一逻辑，并测试其在实际加载场景下的表现。
     </li>
    </ul>
    <h2>
     <a id="_LoadBitmap__248">
     </a>
     我们不能在调用 LoadBitmap 时释放资源来腾出空间
    </h2>
    <p>
     我们目前面临一个关键问题：在调用
     <code>
      load_bitmap
     </code>
     时，我们
     <strong>
      不能直接释放资源
     </strong>
     ，否则可能会导致资源在
     <strong>
      使用过程中被意外移除
     </strong>
     ，从而引发渲染错误或崩溃。
    </p>
    <hr/>
    <h4>
     <a id="_253">
     </a>
     <strong>
      问题分析
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        资源加载的位置
       </strong>
      </p>
      <ul>
       <li>
        <code>
         load_bitmap
        </code>
        是在
        <code>
         push_bitmap
        </code>
        内部调用的，而
        <code>
         push_bitmap
        </code>
        本身是在
        <code>
         game_update_and_render
        </code>
        过程中被调用的。
       </li>
       <li>
        这意味着
        <code>
         load_bitmap
        </code>
        发生时，游戏逻辑已经在
        <strong>
         本帧内多次调用
         <code>
          push_bitmap
         </code>
        </strong>
        ，并将多个
        <code>
         bitmap
        </code>
        资源加入了渲染队列。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        潜在的资源冲突
       </strong>
      </p>
      <ul>
       <li>
        <code>
         push_bitmap
        </code>
        的工作流程是：
        <ol>
         <li>
          <strong>
           检查
           <code>
            bitmap
           </code>
           是否已加载
          </strong>
          ，如果已加载，直接使用；
         </li>
         <li>
          <strong>
           如果未加载
          </strong>
          ，调用
          <code>
           load_bitmap
          </code>
          进行加载，并将其加入渲染队列。
         </li>
        </ol>
       </li>
       <li>
        <strong>
         问题
        </strong>
        ：如果
        <code>
         load_bitmap
        </code>
        触发了资源清理，而这个被清理的资源已经在当前帧的渲染队列中，就会导致渲染系统引用无效资源，最终导致渲染错误或崩溃。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_266">
     </a>
     <strong>
      解决方案探讨
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        避免在当前帧清理资源
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         不能在
         <code>
          load_bitmap
         </code>
         直接清理资源
        </strong>
        ，否则可能会释放
        <strong>
         本帧正在使用的资源
        </strong>
        。
       </li>
       <li>
        需要延迟资源释放到
        <strong>
         下一帧
        </strong>
        ，确保
        <strong>
         当前帧中所有渲染任务完成后
        </strong>
        ，再执行清理。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        引入资源管理机制
       </strong>
      </p>
      <ul>
       <li>
        可以在
        <code>
         game_update_and_render
        </code>
        结束时执行一次
        <strong>
         资源管理逻辑
        </strong>
        ：
        <ol>
         <li>
          <strong>
           标记需要释放的资源
          </strong>
          ，但不在当前帧立即释放；
         </li>
         <li>
          <strong>
           下一帧开始时
          </strong>
          ，检查已标记的资源，如果它们在上一帧未被使用，则释放它们。
         </li>
        </ol>
       </li>
       <li>
        这种方式避免了当前帧的资源冲突，同时确保不浪费内存。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        使用锁机制？
       </strong>
      </p>
      <ul>
       <li>
        一种方式是使用**锁（Locking）**来确保资源不会在渲染过程中被释放。
       </li>
       <li>
        但锁的引入会导致
        <strong>
         同步问题
        </strong>
        ，可能影响性能，甚至引发死锁。
       </li>
       <li>
        <strong>
         更好的方式
        </strong>
        是使用延迟回收，而不是依赖锁。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_284">
     </a>
     <strong>
      下一步计划
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       实现延迟资源释放机制
      </strong>
      ，确保资源不会在
      <strong>
       当前帧
      </strong>
      被释放，而是在
      <strong>
       下一帧
      </strong>
      进行处理。
     </li>
     <li>
      <strong>
       优化内存管理策略
      </strong>
      ，在每帧结束时执行资源检查和清理，避免不必要的内存占用。
     </li>
     <li>
      <strong>
       测试并优化渲染流程
      </strong>
      ，确保资源管理机制不会影响游戏的
      <strong>
       渲染效率
      </strong>
      或
      <strong>
       稳定性
      </strong>
      。
     </li>
    </ul>
    <h2>
     <a id="a_LoadBitmap_b_289">
     </a>
     我们可以在帧之间标记位图为已释放。有两种选择：a）推迟 LoadBitmap 调用直到帧结束，b）保持一定的空闲空间以确保总是可以加载
    </h2>
    <p>
     目前，我们需要确保
     <strong>
      在适当的时间点释放
      <code>
       bitmap
      </code>
      资源
     </strong>
     ，以避免在错误的时机释放资源，从而导致渲染错误或崩溃。为此，我们提出了两种可能的解决方案。
    </p>
    <hr/>
    <h4>
     <a id="_1_294">
     </a>
     <strong>
      方案 1：预留固定的自由空间
     </strong>
    </h4>
    <ol>
     <li>
      在总可用内存（假设为 4GB）中，
      <strong>
       预留一部分固定的空闲空间
      </strong>
      ，例如 16MB。
     </li>
     <li>
      <strong>
       每一帧
      </strong>
      ：
      <ul>
       <li>
        在新的资源加载请求到来时，优先
        <strong>
         使用这 16MB 的预留空间
        </strong>
        来加载资源，而不立即释放现有资源。
       </li>
       <li>
        允许在这 16MB 空间中进行写入，确保不会直接影响当前已使用的资源。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       帧结束时
      </strong>
      ：
      <ul>
       <li>
        计算当前使用的额外空间，
        <strong>
         释放一部分旧资源
        </strong>
        ，确保下帧开始时仍然有 16MB 可用空间。
       </li>
       <li>
        这样，每一帧都可以立刻开始加载新的资源，而不会在中途清理掉正在被使用的资源。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_2_bitmap__305">
     </a>
     <strong>
      方案 2：推迟
      <code>
       bitmap
      </code>
      任务到帧末
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       在
       <code>
        load_bitmap
       </code>
       被调用时，不立即执行加载，而是先记录
      </strong>
      所有需要加载的资源，将它们加入
      <strong>
       待加载列表
      </strong>
      。
     </li>
     <li>
      <strong>
       在帧末
      </strong>
      ，统一处理这些资源：
      <ul>
       <li>
        执行所有
        <code>
         bitmap
        </code>
        资源的加载任务；
       </li>
       <li>
        确保在
        <strong>
         合适的时机
        </strong>
        释放旧资源，而不会影响当前帧的渲染。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_313">
     </a>
     <strong>
      比较两种方案
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        方案
       </th>
       <th>
        优点
       </th>
       <th>
        缺点
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         方案 1（预留自由空间）
        </strong>
       </td>
       <td>
        1. 允许立即开始加载资源，提高加载效率。
        <br/>
        2. 资源管理较为灵活，不需要等到帧末再加载。
       </td>
       <td>
        1. 需要合理规划预留空间，避免浪费内存。
        <br/>
        2. 如果新资源超出预留空间，仍然可能导致溢出问题。
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         方案 2（推迟加载任务）
        </strong>
       </td>
       <td>
        1. 统一在帧末进行管理，避免资源冲突。
        <br/>
        2. 逻辑更加清晰，避免不必要的内存浪费。
       </td>
       <td>
        1. 资源加载的时机较晚，可能导致
        <strong>
         短暂的资源缺失
        </strong>
        （例如在下一帧中仍未加载完成）。
       </td>
      </tr>
     </tbody>
    </table>
    <hr/>
    <h4>
     <a id="_321">
     </a>
     <strong>
      选择方案
     </strong>
    </h4>
    <ul>
     <li>
      方案 1 更适合
      <strong>
       实时性要求较高
      </strong>
      的场景，例如在高帧率游戏中，我们希望新资源尽快加载。
     </li>
     <li>
      方案 2 更适合
      <strong>
       资源管理要求严格
      </strong>
      的情况，能够更清晰地控制何时释放和加载资源，减少潜在的内存溢出风险。
     </li>
    </ul>
    <p>
     目前的考虑倾向于
     <strong>
      方案 1（预留固定空间）
     </strong>
     ，因为这样可以
     <strong>
      立即启动加载任务
     </strong>
     ，并利用当前帧的剩余时间完成加载，有助于
     <strong>
      减少资源缺失
     </strong>
     的情况。
    </p>
    <p>
     不过，
     <strong>
      预加载机制
     </strong>
     （提前加载未来可能需要的资源）依然是一个值得考虑的优化点，可能可以与方案 1 结合使用，以提升整体性能。
    </p>
    <h2>
     <a id="_329">
     </a>
     正式宣布：资源现在是句柄
    </h2>
    <p>
     目前，资产（assets）已经被设计为
     <strong>
      句柄（handles）
     </strong>
     ，并且从引入
     <code>
      asset_slot
     </code>
     机制开始，它们就已经是句柄了，而不是刚刚才变成句柄。这种设计的核心目的是
     <strong>
      让游戏代码始终可以引用一个资产，而不需要关心它是否真正存在
     </strong>
     。
    </p>
    <h4>
     <a id="_332">
     </a>
     <strong>
      为什么资产必须是句柄？
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        游戏代码不需要管理资源的生命周期
       </strong>
      </p>
      <ul>
       <li>
        通过
        <code>
         asset_slot
        </code>
        机制，游戏代码可以随时引用一个资产，而不需要手动检查它是否已被加载或释放。
       </li>
       <li>
        这样可以
        <strong>
         避免资源管理的复杂性
        </strong>
        ，减少因为错误的生命周期管理导致的崩溃或未定义行为。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        解耦资源管理与游戏逻辑
       </strong>
      </p>
      <ul>
       <li>
        游戏代码只需要关注
        <strong>
         如何使用资源
        </strong>
        ，而不需要关心
        <strong>
         资源何时被分配或释放
        </strong>
        。
       </li>
       <li>
        资源系统可以独立管理
        <strong>
         加载、释放、缓存
        </strong>
        等操作，而不会影响游戏逻辑。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        避免所有权（ownership）问题
       </strong>
      </p>
      <ul>
       <li>
        传统的直接指针（raw pointer）或资源引用容易导致悬空指针、重复释放等问题，而句柄则避免了这个问题。
       </li>
       <li>
        只要
        <code>
         asset_slot
        </code>
        机制存在，
        <strong>
         句柄始终有效
        </strong>
        ，哪怕资源暂时未被加载，也不会导致程序崩溃。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_345">
     </a>
     <strong>
      现有机制的优势
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       安全性提升
      </strong>
      ：句柄不会直接指向资源内存，而是通过
      <code>
       asset_slot
      </code>
      进行管理，避免非法访问。
     </li>
     <li>
      <strong>
       灵活性增强
      </strong>
      ：资源可以随时被替换、卸载，而不影响游戏逻辑。
     </li>
     <li>
      <strong>
       降低游戏逻辑的复杂度
      </strong>
      ：开发者不需要手动管理资源加载、释放等细节，只需要使用句柄访问资源。
     </li>
    </ul>
    <h4>
     <a id="_350">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     当前的
     <code>
      asset_slot
     </code>
     机制确保了
     <strong>
      游戏逻辑和资源管理的完全解耦
     </strong>
     ，使得游戏代码可以
     <strong>
      专注于如何使用资源，而不必关心资源的生命周期
     </strong>
     。这种设计从一开始就是基于**句柄（handles）**的方式实现的，而不是现在才变成句柄。
    </p>
    <h2>
     <a id="_353">
     </a>
     是否有好处使用二级缓存来存储压缩和未压缩的资源？
    </h2>
    <p>
     是否应该使用
     <strong>
      两级缓存
     </strong>
     （存储压缩和未压缩的资源）取决于具体的
     <strong>
      平台
     </strong>
     和
     <strong>
      硬件环境
     </strong>
     。
    </p>
    <h4>
     <a id="_356">
     </a>
     <strong>
      可能的影响因素
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        PC 平台是否需要？
       </strong>
      </p>
      <ul>
       <li>
        由于
        <strong>
         PC 拥有大量内存
        </strong>
        ，通常可以直接存储未压缩资源，避免额外的解压缩开销。
       </li>
       <li>
        <strong>
         硬盘（特别是 SSD）速度极快
        </strong>
        ，直接从磁盘读取未压缩资源可能比先加载压缩数据再解压更高效。
       </li>
       <li>
        因此，在 PC 上使用两级缓存的
        <strong>
         必要性较低
        </strong>
        ，未压缩资源可能已经足够。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        主机或移动设备的适用性
       </strong>
      </p>
      <ul>
       <li>
        在
        <strong>
         受限的存储或内存环境下（如游戏主机或移动设备）
        </strong>
        ，两级缓存可能更有意义。
       </li>
       <li>
        例如，存储受限的情况下，可以
        <strong>
         先缓存压缩资源
        </strong>
        ，然后
        <strong>
         在需要时解压并存入未压缩缓存
        </strong>
        ，以减少 IO 压力。
       </li>
       <li>
        但是否值得这样做仍然取决于
        <strong>
         具体的存储读取速度和 CPU 解压缩能力
        </strong>
        。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        测试决定最终方案
       </strong>
      </p>
      <ul>
       <li>
        <strong>
         是否使用两级缓存需要实际测试
        </strong>
        ，因为不同游戏、不同硬件的表现会有较大差异。
       </li>
       <li>
        如果测试发现
        <strong>
         直接加载未压缩资源已经足够快
        </strong>
        ，那么增加压缩缓存可能反而是一种
        <strong>
         不必要的复杂化
        </strong>
        。
       </li>
       <li>
        另一方面，如果测试显示
        <strong>
         存储压缩资源可以明显提升加载效率
        </strong>
        ，那么两级缓存的设计可能是值得的。
       </li>
      </ul>
     </li>
    </ol>
    <h4>
     <a id="_372">
     </a>
     <strong>
      结论
     </strong>
    </h4>
    <p>
     目前来看，
     <strong>
      在 PC 平台上，直接使用未压缩资源可能是最佳方案
     </strong>
     ，因为内存充足且硬盘速度足够快。而在
     <strong>
      存储受限或 IO 受限的设备上（如主机、移动设备）
     </strong>
     ，使用两级缓存（压缩 + 未压缩）可能会有所帮助，但仍需具体测试来决定其实际价值。
    </p>
    <h2>
     <a id="_malloc__free_375">
     </a>
     是否有性能原因不使用 malloc 和 free？
    </h2>
    <p>
     <strong>
      是否存在性能上的理由不使用
      <code>
       malloc
      </code>
      和
      <code>
       free
      </code>
      ？
     </strong>
    </p>
    <h4>
     <a id="_malloc__free__378">
     </a>
     <strong>
      可以直接使用
      <code>
       malloc
      </code>
      和
      <code>
       free
      </code>
      吗？
     </strong>
    </h4>
    <p>
     <strong>
      可以
     </strong>
     。如果不考虑自定义内存管理方案，
     <strong>
      直接调用
      <code>
       malloc
      </code>
      和
      <code>
       free
      </code>
      也是可行的
     </strong>
     。甚至如果不想依赖 C 运行时库，还可以
     <strong>
      直接调用操作系统提供的内存管理函数
     </strong>
     ，比如：
    </p>
    <ul>
     <li>
      <strong>
       Windows
      </strong>
      ：
      <code>
       HeapAlloc
      </code>
      /
      <code>
       HeapFree
      </code>
     </li>
     <li>
      <strong>
       Linux/macOS
      </strong>
      ：
      <code>
       malloc
      </code>
      /
      <code>
       free
      </code>
      （通常底层调用
      <code>
       mmap
      </code>
      或
      <code>
       sbrk
      </code>
      ）
     </li>
    </ul>
    <p>
     这些 API 都可以用于内存分配，
     <strong>
      在当前场景下完全可行
     </strong>
     。
    </p>
    <h4>
     <a id="_385">
     </a>
     <strong>
      当前场景是否需要高效的内存管理？
     </strong>
    </h4>
    <ul>
     <li>
      在
      <strong>
       当前代码逻辑
      </strong>
      中，
      <strong>
       每帧可能只会进行 16 次左右的内存分配
      </strong>
      （用于管理资源加载、移动等）。
     </li>
     <li>
      这个分配次数
      <strong>
       相对较少
      </strong>
      ，因此
      <strong>
       不需要极致的分配效率
      </strong>
      。
     </li>
     <li>
      在这种情况下，即使直接调用
      <code>
       malloc
      </code>
      /
      <code>
       free
      </code>
      ，
      <strong>
       性能开销也是可以接受的
      </strong>
      。
     </li>
    </ul>
    <h4>
     <a id="_390">
     </a>
     <strong>
      是否有必要使用自定义分配器？
     </strong>
    </h4>
    <p>
     如果目标是
     <strong>
      深入研究内存管理问题
     </strong>
     ，那么可以考虑
     <strong>
      自定义分配器
     </strong>
     ，例如：
    </p>
    <ul>
     <li>
      <strong>
       使用内存池
      </strong>
      ：适用于
      <strong>
       频繁分配和释放的对象
      </strong>
      ，避免
      <code>
       malloc/free
      </code>
      频繁调用带来的碎片化。
     </li>
     <li>
      <strong>
       使用区域分配（Arena Allocator）
      </strong>
      ：适用于
      <strong>
       大量临时对象
      </strong>
      ，批量分配并在适当时机统一释放，提高效率。
     </li>
    </ul>
    <p>
     但在当前场景下，
     <strong>
      并不需要额外优化
     </strong>
     ，直接调用
     <code>
      malloc
     </code>
     /
     <code>
      free
     </code>
     或
     <code>
      HeapAlloc
     </code>
     /
     <code>
      HeapFree
     </code>
     <strong>
      完全可以满足需求
     </strong>
     。
    </p>
    <h4>
     <a id="_VirtualAlloc_397">
     </a>
     <strong>
      是否应该避免
      <code>
       VirtualAlloc
      </code>
      ？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       <code>
        VirtualAlloc
       </code>
       （Windows）或
       <code>
        mmap
       </code>
       （Linux/macOS）是更底层的内存管理方式
      </strong>
      ，直接向操作系统申请大块内存。
     </li>
     <li>
      <strong>
       它们的开销更高
      </strong>
      ，适用于
      <strong>
       管理大块内存（如 GB 级分配）
      </strong>
      ，但不适合频繁的小对象分配。
     </li>
     <li>
      因此，在
      <strong>
       当前资源管理的场景下
      </strong>
      ，
      <strong>
       不推荐使用
       <code>
        VirtualAlloc
       </code>
      </strong>
      ，而是直接使用
      <code>
       malloc
      </code>
      /
      <code>
       HeapAlloc
      </code>
      之类的更轻量的分配方式。
     </li>
    </ul>
    <h4>
     <a id="_402">
     </a>
     <strong>
      结论
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       如果不考虑优化，直接使用
       <code>
        malloc
       </code>
       /
       <code>
        free
       </code>
       是可以接受的
      </strong>
      ，对性能影响不大。
     </li>
     <li>
      <strong>
       如果要避免依赖 C 运行时库
      </strong>
      ，可以使用操作系统提供的
      <code>
       HeapAlloc
      </code>
      /
      <code>
       HeapFree
      </code>
      等 API。
     </li>
     <li>
      <strong>
       不需要额外优化分配器
      </strong>
      ，因为当前的分配次数不高，
      <strong>
       优化收益不大
      </strong>
      。
     </li>
     <li>
      <strong>
       不建议使用
       <code>
        VirtualAlloc
       </code>
       之类的 API
      </strong>
      ，因为它的调用开销较大，适用于大块内存管理，而不是小对象的频繁分配。
     </li>
    </ul>
    <p>
     因此，在
     <strong>
      当前场景下，直接使用
      <code>
       malloc
      </code>
      /
      <code>
       free
      </code>
      也是合理的选择
     </strong>
     。
    </p>
    <h2>
     <a id="_410">
     </a>
     是否有技术术语描述内存空闲保证算法？
    </h2>
    <p>
     是否存在特定的技术术语来描述
     <strong>
      内存清理保障算法
     </strong>
     ？
    </p>
    <p>
     如果讨论的是
     <strong>
      前面提到的两种方法
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       将释放操作延迟到帧结束
      </strong>
     </li>
     <li>
      <strong>
       预留一定的空闲空间以确保任务可以立即启动
      </strong>
     </li>
    </ol>
    <p>
     那么，目前
     <strong>
      没有特定的技术术语
     </strong>
     专门用于描述这两种策略。在常见的计算机图形学、游戏开发或系统编程中，并没有明确的行业标准术语来命名这些方法。
    </p>
    <p>
     不过，这两种方法在内存管理领域可以归类为以下技术概念：
    </p>
    <h4>
     <a id="1_Deferred_Freeing_421">
     </a>
     <strong>
      1. 延迟释放（Deferred Freeing）
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       概念
      </strong>
      ：推迟对象或资源的释放，而不是立即回收内存，以避免影响当前帧的执行。
     </li>
     <li>
      <strong>
       应用场景
      </strong>
      ：
      <ul>
       <li>
        在游戏引擎中，常用于
        <strong>
         减少资源争用
        </strong>
        ，避免在
        <strong>
         渲染过程中释放仍在使用的纹理或模型
        </strong>
        。
       </li>
       <li>
        适用于
        <strong>
         多线程环境
        </strong>
        ，确保内存释放不会影响其他线程的执行。
       </li>
       <li>
        典型实现方式是使用
        <strong>
         双缓冲（Double Buffering）
         <strong>
          或
         </strong>
         引用计数（Reference Counting）
        </strong>
        。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="2_Reserved_Free_Space_428">
     </a>
     <strong>
      2. 预留空闲空间（Reserved Free Space）
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       概念
      </strong>
      ：预留一定大小的内存空间，以保证新任务可以立即分配所需的资源，而不会触发强制回收。
     </li>
     <li>
      <strong>
       应用场景
      </strong>
      ：
      <ul>
       <li>
        常用于
        <strong>
         实时系统
        </strong>
        或
        <strong>
         游戏引擎
        </strong>
        ，确保关键任务不会因内存分配问题而被阻塞。
       </li>
       <li>
        适用于
        <strong>
         资源加载系统
        </strong>
        ，如
        <strong>
         纹理流式加载（Texture Streaming）
        </strong>
        ，可以提前分配缓冲区以确保新的纹理可以顺利加载。
       </li>
       <li>
        在操作系统层面，这种策略类似于
        <strong>
         内存分页（Memory Paging）
        </strong>
        ，操作系统会预留一定数量的空闲页框，以提高分配效率。
       </li>
      </ul>
     </li>
    </ul>
    <h4>
     <a id="_435">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <p>
     虽然没有
     <strong>
      专门的术语
     </strong>
     来描述这两种方法，但可以将它们理解为：
    </p>
    <ul>
     <li>
      <strong>
       “延迟释放”
      </strong>
      （Deferred Freeing）：推迟内存释放，避免影响当前帧执行。
     </li>
     <li>
      <strong>
       “预留空闲空间”
      </strong>
      （Reserved Free Space）：保留一定的内存容量，确保任务可以立即执行。
     </li>
    </ul>
    <p>
     这两种方法在
     <strong>
      游戏引擎
     </strong>
     、
     <strong>
      计算机图形学
     </strong>
     和
     <strong>
      操作系统
     </strong>
     中都有应用，但并没有一个单一的技术术语来概括它们。
    </p>
    <h2>
     <a id="_new__delete__442">
     </a>
     能否谈一下 new / delete 实际上做了什么以及何时使用它们？
    </h2>
    <h4>
     <a id="C__new__delete__443">
     </a>
     <strong>
      C++ 中
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      的作用及使用场景
     </strong>
    </h4>
    <p>
     在 C++ 中，
     <code>
      new
     </code>
     和
     <code>
      delete
     </code>
     主要用于
     <strong>
      动态内存分配
     </strong>
     和
     <strong>
      对象的构造与析构
     </strong>
     ，但在特定的代码风格中，它们可能完全不需要。例如，在某些手写内存管理的情况下，我们可以
     <strong>
      完全避免使用
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
     </strong>
     ，而是直接使用 C 语言的
     <code>
      malloc
     </code>
     和
     <code>
      free
     </code>
     ，甚至自定义分配器来管理内存。
    </p>
    <h4>
     <a id="C__447">
     </a>
     <strong>
      C++ 语法中的内存管理流程
     </strong>
    </h4>
    <p>
     可以将动态内存管理分为以下
     <strong>
      四个步骤
     </strong>
     ：
    </p>
    <ol>
     <li>
      <strong>
       分配内存
      </strong>
      （Allocation）
      <ul>
       <li>
        向系统请求一块适当大小的内存。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       初始化内存
      </strong>
      （Initialization）
      <ul>
       <li>
        将该内存初始化为特定的数据结构或对象。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       反初始化
      </strong>
      （Deinitialization）
      <ul>
       <li>
        在释放前，执行必要的清理操作（如关闭文件、释放资源等）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       释放内存
      </strong>
      （Deallocation）
      <ul>
       <li>
        归还内存，使其可被其他代码复用。
       </li>
      </ul>
     </li>
    </ol>
    <p>
     在
     <strong>
      C 语言
     </strong>
     中：
    </p>
    <ul>
     <li>
      <strong>
       步骤 1 &amp; 4
      </strong>
      由
      <code>
       malloc
      </code>
      和
      <code>
       free
      </code>
      处理。
     </li>
     <li>
      <strong>
       步骤 2 &amp; 3
      </strong>
      需要程序员手动完成。
     </li>
    </ul>
    <p>
     在
     <strong>
      C++ 语言
     </strong>
     中：
    </p>
    <ul>
     <li>
      <code>
       new
      </code>
      负责
      <strong>
       步骤 1 &amp; 2
      </strong>
      （分配 + 初始化）。
     </li>
     <li>
      <code>
       delete
      </code>
      负责
      <strong>
       步骤 3 &amp; 4
      </strong>
      （反初始化 + 释放）。
     </li>
    </ul>
    <h4>
     <a id="C__466">
     </a>
     <strong>
      C 语言方式（手动管理）
     </strong>
    </h4>
    <pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{<!-- --></span>
    FILE<span class="token operator">*</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 1. 分配内存</span>
Foo<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 初始化内存</span>
a<span class="token operator">-&gt;</span>bar <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 3. 使用后，手动反初始化</span>
<span class="token function">fclose</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 4. 释放内存</span>
<span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
     在 C 语言中，我们必须手动执行所有四个步骤。如果程序员忘记执行
     <strong>
      步骤 3
     </strong>
     （如
     <code>
      fclose
     </code>
     ），那么就会出现
     <strong>
      资源泄漏
     </strong>
     。
    </p>
    <hr/>
    <h4>
     <a id="C__new__delete_488">
     </a>
     <strong>
      C++ 方式（使用
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      ）
     </strong>
    </h4>
    <pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{<!-- --></span>
    FILE<span class="token operator">*</span> bar<span class="token punctuation">;</span>
    
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 构造函数</span>
        bar <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 析构函数</span>
        <span class="token function">fclose</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 1 &amp; 2. `new` 负责分配 + 初始化</span>
Foo<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span>

<span class="token comment">// 3 &amp; 4. `delete` 负责反初始化 + 释放</span>
<span class="token keyword">delete</span> a<span class="token punctuation">;</span>
</code></pre>
    <p>
     在 C++ 代码中：
    </p>
    <ul>
     <li>
      <code>
       new Foo
      </code>
      触发
      <strong>
       构造函数
      </strong>
      （
      <code>
       Foo()
      </code>
      ），自动完成
      <code>
       fopen
      </code>
      资源初始化。
     </li>
     <li>
      <code>
       delete a
      </code>
      触发
      <strong>
       析构函数
      </strong>
      （
      <code>
       ~Foo()
      </code>
      ），自动调用
      <code>
       fclose
      </code>
      释放资源。
     </li>
    </ul>
    <h4>
     <a id="new__delete__512">
     </a>
     <strong>
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      的引入
     </strong>
    </h4>
    <p>
     <code>
      new
     </code>
     和
     <code>
      delete
     </code>
     主要是为了解决
     <strong>
      C 语言中步骤 2 &amp; 3 需要手动执行
     </strong>
     的问题，让初始化和反初始化的逻辑能够
     <strong>
      绑定到类的生命周期
     </strong>
     。
    </p>
    <p>
     在 C++ 之前，C 语言的
     <code>
      malloc
     </code>
     和
     <code>
      free
     </code>
     只关注
     <strong>
      内存管理
     </strong>
     ，但不会自动调用
     <strong>
      构造函数
     </strong>
     和
     <strong>
      析构函数
     </strong>
     ，而 C++ 引入
     <code>
      new
     </code>
     和
     <code>
      delete
     </code>
     后：
    </p>
    <ul>
     <li>
      <code>
       new
      </code>
      =
      <code>
       malloc
      </code>
      + 构造函数调用
     </li>
     <li>
      <code>
       delete
      </code>
      = 析构函数调用 +
      <code>
       free
      </code>
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_new__delete_521">
     </a>
     <strong>
      什么时候必须使用
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      ？
     </strong>
    </h4>
    <p>
     在某些情况下，
     <code>
      new
     </code>
     和
     <code>
      delete
     </code>
     是
     <strong>
      必须的
     </strong>
     ：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        使用虚函数（Virtual Functions）
       </strong>
      </p>
      <ul>
       <li>
        如果类中有虚函数，编译器会自动插入
        <strong>
         虚函数表（VTable）指针
        </strong>
        ，它需要在对象初始化时进行设置，而
        <code>
         malloc
        </code>
        无法处理这一点。
       </li>
       <li>
        <code>
         new
        </code>
        可以确保
        <strong>
         虚函数表正确初始化
        </strong>
        ，如果使用
        <code>
         malloc
        </code>
        ，虚函数调用可能会失败。
       </li>
      </ul>
      <pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Base<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>  <span class="token comment">// 正常</span>
</code></pre>
     </li>
     <li>
      <p>
       <strong>
        使用继承（Inheritance）
       </strong>
      </p>
      <ul>
       <li>
        当一个类继承自基类，并且基类有
        <strong>
         非默认构造函数
        </strong>
        或
        <strong>
         虚函数
        </strong>
        时，
        <code>
         new
        </code>
        需要正确调用构造函数，以确保基类和子类都被正确初始化。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        使用 C++ 标准库（STL）容器
       </strong>
      </p>
      <ul>
       <li>
        C++ 容器（如
        <code>
         std::vector
        </code>
        、
        <code>
         std::map
        </code>
        ）内部依赖
        <code>
         new
        </code>
        和
        <code>
         delete
        </code>
        来管理内存。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_new__delete__543">
     </a>
     <strong>
      避免使用
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      的方法
     </strong>
    </h4>
    <p>
     在某些情况下，我们可以完全避免使用
     <code>
      new
     </code>
     和
     <code>
      delete
     </code>
     ，而是使用更安全的方式进行内存管理：
    </p>
    <ol>
     <li>
      <p>
       <strong>
        使用智能指针
       </strong>
       （
       <code>
        std::unique_ptr
       </code>
       /
       <code>
        std::shared_ptr
       </code>
       ）
      </p>
      <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      <ul>
       <li>
        这样就不需要手动调用
        <code>
         delete
        </code>
        了，智能指针会在对象超出作用域时自动释放资源。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        使用局部对象
       </strong>
       （避免动态分配）
      </p>
      <pre><code class="prism language-cpp">Foo a<span class="token punctuation">;</span>  <span class="token comment">// 直接在栈上分配</span>
</code></pre>
      <ul>
       <li>
        这样可以避免
        <code>
         new
        </code>
        和
        <code>
         delete
        </code>
        ，程序员无需手动管理内存。
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        使用
        <code>
         placement new
        </code>
       </strong>
       （手动控制初始化）
      </p>
      <pre><code class="prism language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Foo<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> Foo<span class="token punctuation">;</span>
</code></pre>
      <ul>
       <li>
        这种方式可以避免
        <code>
         malloc
        </code>
        ，在固定的内存区域上直接构造对象，适用于高效的内存管理场景。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_new__delete__568">
     </a>
     <strong>
      为什么
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      被认为是糟糕的设计？
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       不直观
      </strong>
      ：
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      将内存分配与构造、释放与析构绑定在一起，导致开发者难以精确控制内存管理。
     </li>
     <li>
      <strong>
       容易导致内存泄漏
      </strong>
      ：如果忘记
      <code>
       delete
      </code>
      ，就会造成内存泄漏，而
      <code>
       std::unique_ptr
      </code>
      更安全。
     </li>
     <li>
      <strong>
       额外的性能开销
      </strong>
      ：与
      <code>
       malloc/free
      </code>
      相比，
      <code>
       new/delete
      </code>
      需要额外的开销来支持 C++ 运行时特性，如构造、析构、虚函数表初始化等。
     </li>
     <li>
      <strong>
       不灵活
      </strong>
      ：
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      强制让对象
      <strong>
       使用堆分配
      </strong>
      ，而有时
      <strong>
       栈分配
      </strong>
      或
      <strong>
       自定义分配器
      </strong>
      会更高效。
     </li>
    </ul>
    <hr/>
    <h4>
     <a id="_576">
     </a>
     <strong>
      总结
     </strong>
    </h4>
    <ul>
     <li>
      <strong>
       C 语言
      </strong>
      只提供
      <code>
       malloc
      </code>
      和
      <code>
       free
      </code>
      ，不关心对象的构造和析构。
     </li>
     <li>
      <strong>
       C++
      </strong>
      通过
      <code>
       new
      </code>
      和
      <code>
       delete
      </code>
      自动调用构造函数和析构函数，让对象生命周期管理更加一致。
     </li>
     <li>
      <strong>
       在现代 C++ 中，
       <code>
        new
       </code>
       和
       <code>
        delete
       </code>
       已经逐渐被
       <code>
        std::unique_ptr
       </code>
       和
       <code>
        std::make_unique
       </code>
       取代
      </strong>
      ，手动调用
      <code>
       new
      </code>
      /
      <code>
       delete
      </code>
      被认为是糟糕的实践。
     </li>
     <li>
      在
      <strong>
       性能敏感型应用
      </strong>
      （如游戏引擎），我们可以
      <strong>
       完全避免
       <code>
        new
       </code>
       和
       <code>
        delete
       </code>
       ，使用自定义内存池或
       <code>
        placement new
       </code>
      </strong>
      来优化内存管理。
     </li>
    </ul>
    <h2>
     <a id="_582">
     </a>
     能否简要评论一下将问题重新定义为资源打包的问题的可行性？将声音分成固定大小的块，将位图切成固定大小的瓦片，使所有瓦片都保持合理大小。将相关资源分组，使它们一起加载。类似这样的想法
    </h2>
    <p>
     我们可以将问题重新定义为资产打包的问题，即将声音拆分为固定大小的块，将贴图划分为固定大小的图块，使所有的图块都能保持合理的大小，并将相关的资产归类在一起，以便于加载时可以一起加载。这样的策略类似于MegaTexture技术，本质上是将所有的资产打包到一个巨大的位图中，然后将其拆分成固定大小的图块进行访问。
    </p>
    <p>
     在这种方法下，资产需要以可变长度的图块存储，但这可能是可以接受的，因为我们可以将所有这些数据加载到内存中，并以类似于资产标签的方式进行访问。这种方法不仅适用于图形资源，也同样适用于声音资源。
    </p>
    <p>
     对于声音处理，我们可以创建一个巨大的声音数据文件，并将其拆分为固定大小的块。例如，可以选择每个块包含64,000个采样点，或者更常见的是将其拆分为256KB的块，以确保所有的数据块大小统一，从而方便进行内存管理和加载策略优化。通过这种方式，我们能够实现对资源的高效管理，并提高加载速度。
    </p>
    <h2>
     <a id="_589">
     </a>
     使用智能指针和垃圾回收之间是否有真正的“哲学”差异？还是智能指针仅仅是实现垃圾回收的一种方式？
    </h2>
    <p>
     智能指针和垃圾回收之间是有差别的。首先，需要明确“智能指针”的定义。在 C++ 中，智能指针通常指的是自动管理内存释放的指针，比如
     <code>
      auto_ptr
     </code>
     。这类指针会在离开作用域时自动释放所指向的内存。但这与垃圾回收不同，因为垃圾回收通常涉及引用计数，而智能指针中的
     <code>
      auto_ptr
     </code>
     并不完全等同于引用计数机制。
    </p>
    <p>
     如果我们将智能指针定义为包含引用计数的指针，那么它确实可以看作是实现垃圾回收的一种方式。引用计数会随着指针的使用而增加，当指向的对象不再被引用时，引用计数为零，内存就会被释放。然而，这种实现与完整的垃圾回收系统不同，后者通常能做更多的优化。垃圾回收器可以了解对象的使用模式，从而进行更高效的内存管理，而引用计数只能基于每个对象的引用次数进行管理，无法像垃圾回收器那样全面了解对象之间的关系。
    </p>
    <p>
     从哲学角度来说，垃圾回收和引用计数指针确实有一定相似性，都是为了避免内存泄漏，但它们在处理内存管理的方式上有不同。引用计数的智能指针在一些情况下会遇到“循环引用”问题，即两个对象互相引用，却不再被外部引用，这样它们永远不会被释放，导致内存泄漏。虽然一些垃圾回收算法可以检测到这种情况，并能够清理这些互相引用的对象，但引用计数的智能指针无法处理这种“循环引用”问题。
    </p>
    <p>
     因此，垃圾回收通常是一种更强大的内存管理方式，比引用计数的智能指针更能应对复杂的内存管理需求。
    </p>
    <h2>
     <a id="_RAII__598">
     </a>
     那 RAII 呢？
    </h2>
    <p>
     “资源获取即初始化”（RAII）是一种现代编程的思想，它强调对象在构造时必须获取其所需的资源，并确保在对象销毁时释放这些资源。RAII的基本理念是：对象在构造过程中就应该完成资源的获取，并且该对象的生命周期内它所依赖的资源都应该处于有效状态。通过这种方式，资源的释放（即清理）应该在对象的析构函数中自动完成。
    </p>
    <p>
     具体来说，RAII要求对象在构造函数中初始化所有必要的资源。例如，如果一个对象需要两个文件句柄，那么对象的构造函数应该确保这两个文件句柄都成功地获取。如果其中任何一个文件句柄获取失败，则应该抛出异常，并且保证已经获取的资源会在异常抛出时被释放。
    </p>
    <p>
     RAII的一个典型例子就是，如果一个对象依赖两个文件句柄，且这两个句柄是必须在对象创建时初始化成功的，RAII确保在构造函数中两个文件句柄要么都成功获得，要么都不获取。如果其中一个获取失败，RAII会确保已经成功获取的资源会被正确释放，这样就不会出现资源泄露。
    </p>
    <p>
     在RAII中，资源的管理与对象的生命周期紧密绑定。即，资源的获取和释放是对称的，在构造时获取资源，在析构时释放资源。RAII使得资源管理变得简单，避免了部分资源获取失败时的资源泄漏问题。
    </p>
    <p>
     然而，RAII也有其缺点。首先，它并不适用于所有的场景，特别是在复杂的错误处理和资源清理的情况下。RAII的设计通常只考虑了资源的获取和释放，但当出现错误时，错误处理的复杂性往往被简化甚至忽略。在某些场合，错误处理不仅仅是“回滚”到之前的状态，而是可能需要采取更复杂的恢复操作。RAII强制要求错误处理为对称的，而很多实际情况下，错误恢复是需要灵活处理的。
    </p>
    <p>
     此外，RAII导致代码的可扩展性和灵活性变差，因为它强制要求所有资源的获取和释放都必须在一个对象的构造和析构中进行，这使得程序设计变得较为死板。即使在一些情况下我们希望对多个资源进行批量处理，RAII也让这变得困难，因为它要求资源逐一处理，无法做到像批量处理那样的优化。
    </p>
    <p>
     总的来说，尽管RAII能够简化资源管理，减少内存泄漏和资源泄漏的风险，但它的严格对称设计使得灵活性大打折扣，特别是在复杂的错误处理和资源管理场景中。因此，虽然RAII在某些场景下有效，但它并不是一种推荐的普遍解决方案。
    </p>
    <h2>
     <a id="_613">
     </a>
     震动效果资源呢？
    </h2>
    <p>
     关于振动效果资产的讨论，提到可能不需要任何振动效果资产。振动效果通常是通过硬件（如控制器、触觉设备等）实现的，而不是通过传统的“资产”或“资源”管理。这意味着在开发过程中，振动效果更多的是与硬件交互相关，而不是通过加载、存储或管理特定的文件或数据。
    </p>
    <p>
     在某些情况下，振动效果可能由游戏引擎直接控制，或者通过API调用来实现，而不是依赖于具体的振动效果资产。因此，振动效果通常不是传统意义上的资源文件或资产，它们更多的是由程序在运行时根据游戏状态和用户交互动态产生的反馈。
    </p>
    <p>
     因此，不需要像其他图形、音频或模型资源一样单独处理振动效果资产。振动通常会直接由设备驱动程序或游戏引擎在必要时通过硬件接口来触发，而不会存在一个独立的、需要管理和加载的振动资产文件。
    </p>
    <h2>
     <a id="Megatexture__621">
     </a>
     Megatexture 和纹理图集有什么区别？
    </h2>
    <p>
     关于“Mega Texture”和“Texture Atlas”的讨论，实际上它们是类似的概念，但也存在一些区别。
    </p>
    <p>
     <strong>
      Texture Atlas
     </strong>
     是将多个不同的纹理（例如，角色、环境、物体等）组合成一个大纹理图集的技术。这种方法通过在一个大的纹理上排列多个小的纹理，来优化渲染性能，减少纹理切换的次数。在渲染时，使用纹理坐标来定位每个小纹理的具体位置。纹理图集的核心目的是提高渲染效率，尤其是在需要大量纹理时。
    </p>
    <p>
     而
     <strong>
      Mega Texture
     </strong>
     则是一个更为复杂的概念，除了像纹理图集一样包含多个纹理之外，还涉及如何在大型环境中处理这些纹理的细节。Mega Texture 不仅仅是将多个小纹理拼接成一个大图，它还包括如何根据玩家的视角和环境来动态加载不同部分的纹理，通常与地形和大规模的游戏环境有关。因此，Mega Texture 涉及到更多的技术细节，例如纹理坐标的处理、动态加载和分配、以及如何在不同的视距下选择适当的纹理。
    </p>
    <p>
     总结来说，
     <strong>
      Mega Texture
     </strong>
     是一个比
     <strong>
      Texture Atlas
     </strong>
     更复杂和更全面的技术，虽然它们的核心思想都是将多个纹理合并成一个大纹理图，但 Mega Texture 还包括了如何优化和动态管理这些纹理以适应游戏的不同需求。
    </p>
    <h2>
     <a id="_C_vtables_630">
     </a>
     你反对在 C 语言中使用显式虚表（vtables）吗？
    </h2>
    <p>
     关于
     <strong>
      虚函数表（Vtable）
     </strong>
     的使用，提出了一个观点，即
     <strong>
      C++ 中隐式的虚函数表并不总是有用的
     </strong>
     ，并且如果 C++ 能提供更好的工具来处理虚函数表的显式创建和管理，会更有帮助。具体来说，
     <strong>
      虚函数表
     </strong>
     是 C++ 中用于支持多态的一个机制，通常由编译器隐式管理。在传统的 C++ 编程中，虚函数表是由编译器自动生成并隐藏的，但这样做的方式往往让开发者难以灵活操作或控制它们。
    </p>
    <p>
     <strong>
      问题
     </strong>
     在于，虽然虚函数表的自动生成简化了编程，但并没有给开发者足够的工具去
     <strong>
      显式控制虚函数表
     </strong>
     ，比如可以自定义虚函数表的结构和管理方式。如果 C++ 提供了类似的工具，开发者就能够更好地定制和优化虚函数表的使用。
    </p>
    <p>
     <strong>
      理想的情况
     </strong>
     是，C++ 在设计时能给开发者一些更好的工具，允许他们更方便地创建和操作虚函数表，而不是让这一过程完全由编译器隐式管理。举个例子，某些语言或库（如某些游戏引擎或工具）允许开发者显式地创建和操作虚函数表，从而能够精确地控制多态行为和性能。这种显式控制虚函数表的能力，可以在某些高性能或特定需求的场景中变得尤为重要。
    </p>
    <p>
     总结来说，隐式虚函数表虽然简化了很多编程工作，但在很多情况下，它并不提供足够的灵活性。如果 C++ 提供了更便捷的工具来显式操作虚函数表，将极大地提高开发者的控制力和代码的可优化性。
    </p>
    <h2>
     <a id="_16MB__639">
     </a>
     是否值得以每次屏幕上能够显示的最大像素量来考虑资源分配？（例如，使用你提到的 16MB 安全缓冲区）。你是否会调整资源加载以根据相机的距离加载分辨率不同的资源，并假设只有固定数量的东西可以“物理地”占据高分辨率空间，依此类推适用于中低分辨率？
    </h2>
    <p>
     关于
     <strong>
      资产加载与分配
     </strong>
     ，这种策略是基于
     <strong>
      屏幕上可以显示的最大像素量
     </strong>
     来优化的。例如，设置一个
     <strong>
      16MB的安全缓冲区
     </strong>
     ，并根据摄像头与物体的距离来调整加载的资源分辨率。这种做法假设在任何时刻，屏幕上能够占用的高分辨率空间是有限的，因此可以根据远近调整资源的加载。例如，远离摄像头的物体使用较低分辨率的资产，而靠近摄像头的物体使用较高分辨率的资产。
    </p>
    <p>
     这种做法在一些游戏引擎中得到了应用，特别是
     <strong>
      动态调整纹理分辨率
     </strong>
     的场景。这种方法确保了资源的合理分配，能够根据视距来加载不同分辨率的资产，从而避免在内存中加载不必要的高分辨率资源，优化性能。
    </p>
    <p>
     然而，对于一些
     <strong>
      固定视角的游戏
     </strong>
     （如传统的2D游戏），并不需要如此复杂的分辨率调整。比如一些经典的2D游戏，如《塞尔达传说》，通常保持固定的视距，几乎没有进行过多的缩放或视角调整。因此，这类游戏不需要动态加载不同分辨率的资源，资源通常在一个固定分辨率下即可满足需求。
    </p>
    <p>
     对于需要
     <strong>
      动态缩放
     </strong>
     的游戏，比如那些需要频繁变更视距或缩放视角的3D游戏，使用
     <strong>
      MIP贴图
     </strong>
     等技术来提供不同分辨率的资源是非常有必要的。这样，可以根据玩家视角的变化动态加载合适分辨率的资源，从而提高性能和视觉效果。
    </p>
    <p>
     总的来说，如果游戏有大量的缩放需求，采用这种基于视距调整资源分辨率的方案非常有效，能够确保内存的高效利用，并提升游戏性能。如果游戏不涉及视距的频繁变化，那么这种方案则不需要实现。
    </p>
    <h2>
     <a id="_650">
     </a>
     我没看到的是将小的相关资源分组在一起，以便它们适应一个分配单元。
    </h2>
    <p>
     在这种资源分配策略中，
     <strong>
      将小的相关资产组合在一起
     </strong>
     以便它们能够适配一个分配单元是关键。这种方式的做法是将所有的
     <strong>
      精灵图像（sprites）
      <strong>
       打包到一个
      </strong>
      巨大的位图（bitmap）
      <strong>
       中。这样做的目的是为了
      </strong>
      紧密地组织这些资产
     </strong>
     ，使得它们在加载时能够尽量减少开销。
    </p>
    <p>
     当需要调度这些资源时，系统会尽量
     <strong>
      以最紧凑的方式进行加载
     </strong>
     ，即从这个大位图中提取出需要的部分。这样就能有效地减少内存的碎片化和加载的延迟，因为系统只需要一次性加载整个位图，而不是单独加载每个小资产。
    </p>
    <p>
     这种方法的优点在于
     <strong>
      减少了多次内存访问的开销
     </strong>
     ，通过批量加载资源，可以提高效率。它通常应用于需要大量小资源的场景，尤其是在图形处理方面，比如2D游戏中。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c:6f672e6373646e2e6e65742f544d313639353634383136342f:61727469636c652f64657461696c732f313436323531303432" class_="artid" style="display:none">
 </p>
</div>


