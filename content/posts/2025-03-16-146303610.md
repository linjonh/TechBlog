---
layout: post
title: "五大基础算法递归算法"
date: 2025-03-16 23:13:08 +0800
description: "是一种通过函数调用自身来解决问题的算法思想。它将问题分解为规模更小的子问题，直到子问题可以直接解决，然后逐步合并子问题的解，最终得到原问题的解。"
keywords: "五大基础算法——递归算法"
categories: ['数据结构与算法分析']
tags: ['算法']
artid: "146303610"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146303610
    alt: "五大基础算法递归算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146303610
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146303610
cover: https://bing.ee123.net/img/rand?artid=146303610
image: https://bing.ee123.net/img/rand?artid=146303610
img: https://bing.ee123.net/img/rand?artid=146303610
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     五大基础算法——递归算法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
     <strong>
      递归算法
     </strong>
     是一种通过函数调用自身来解决问题的算法思想。它将问题分解为规模更小的子问题，直到子问题可以直接解决，然后逐步合并子问题的解，最终得到原问题的解。以下是递归算法的核心概念、适用场景、实现方法及经典例题：
    </p>
    <hr/>
    <h4>
     <a id="_4">
     </a>
     <strong>
      一、核心概念
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       递归定义
      </strong>
      <ul>
       <li>
        问题可以分解为规模更小的同类子问题。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       基线条件（Base Case）
      </strong>
      <ul>
       <li>
        递归终止的条件，通常是问题规模最小的情况。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       递归条件（Recursive Case）
      </strong>
      <ul>
       <li>
        将问题分解为更小的子问题，并调用自身解决。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       递归栈
      </strong>
      <ul>
       <li>
        递归调用会使用栈来保存每一层的状态，可能导致栈溢出。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_16">
     </a>
     <strong>
      二、适用场景
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       数学问题
      </strong>
      <ul>
       <li>
        如阶乘、斐波那契数列、汉诺塔问题等。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       数据结构操作
      </strong>
      <ul>
       <li>
        如树的遍历、图的搜索、链表的操作等。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       分治算法
      </strong>
      <ul>
       <li>
        如归并排序、快速排序等。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       组合问题
      </strong>
      <ul>
       <li>
        如全排列、子集生成等。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_28">
     </a>
     <strong>
      三、实现步骤
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       定义递归函数
      </strong>
      <ul>
       <li>
        明确函数的输入、输出和功能。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       确定基线条件
      </strong>
      <ul>
       <li>
        找到问题的最小规模，直接返回结果。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       分解问题
      </strong>
      <ul>
       <li>
        将问题分解为更小的子问题，调用自身解决。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       合并结果
      </strong>
      <ul>
       <li>
        将子问题的解合并为原问题的解。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_40">
     </a>
     <strong>
      四、经典例题与代码
     </strong>
    </h4>
    <h5>
     <a id="1__41">
     </a>
     1. 阶乘计算
    </h5>
    <p>
     <strong>
      问题描述
     </strong>
     ：计算n的阶乘（n!）。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 基线条件</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 递归条件</span>

<span class="token comment"># 示例</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>factorial<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 120</span>
</code></pre>
    <h5>
     <a id="2__53">
     </a>
     2. 斐波那契数列
    </h5>
    <p>
     <strong>
      问题描述
     </strong>
     ：计算第n个斐波那契数。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># 基线条件</span>
        <span class="token keyword">return</span> n
    <span class="token keyword">return</span> fibonacci<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fibonacci<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 递归条件</span>

<span class="token comment"># 示例</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 8</span>
</code></pre>
    <h5>
     <a id="3__65">
     </a>
     3. 汉诺塔问题
    </h5>
    <p>
     <strong>
      问题描述
     </strong>
     ：将n个盘子从A柱移动到C柱，借助B柱，且每次只能移动一个盘子，大盘子不能放在小盘子上。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> source<span class="token punctuation">,</span> target<span class="token punctuation">,</span> auxiliary<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># 基线条件</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Move disk 1 from </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>source<span class="token punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>target<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        hanoi<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> auxiliary<span class="token punctuation">,</span> target<span class="token punctuation">)</span>  <span class="token comment"># 将n-1个盘子从A移动到B</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Move disk </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>n<span class="token punctuation">}</span></span><span class="token string"> from </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>source<span class="token punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>target<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        hanoi<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> auxiliary<span class="token punctuation">,</span> target<span class="token punctuation">,</span> source<span class="token punctuation">)</span>  <span class="token comment"># 将n-1个盘子从B移动到C</span>

<span class="token comment"># 示例</span>
hanoi<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span>
</code></pre>
    <h5>
     <a id="4__80">
     </a>
     4. 二叉树遍历
    </h5>
    <p>
     <strong>
      问题描述
     </strong>
     ：递归实现二叉树的前序遍历。
    </p>
    <pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right

<span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>  <span class="token comment"># 基线条件</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+</span> preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

<span class="token comment"># 示例</span>
root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 [1, 2, 3]</span>
</code></pre>
    <hr/>
    <h4>
     <a id="_101">
     </a>
     <strong>
      五、递归算法的优缺点
     </strong>
    </h4>
    <h5>
     <a id="_102">
     </a>
     <strong>
      优点
     </strong>
    </h5>
    <ol>
     <li>
      <strong>
       代码简洁
      </strong>
      <ul>
       <li>
        递归代码通常比迭代代码更简洁易懂。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       问题分解清晰
      </strong>
      <ul>
       <li>
        递归天然适合分治思想，问题分解直观。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       适合树和图结构
      </strong>
      <ul>
       <li>
        递归非常适合处理树和图的遍历问题。
       </li>
      </ul>
     </li>
    </ol>
    <h5>
     <a id="_110">
     </a>
     <strong>
      缺点
     </strong>
    </h5>
    <ol>
     <li>
      <strong>
       栈溢出风险
      </strong>
      <ul>
       <li>
        递归深度过大时，可能导致栈溢出。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       效率较低
      </strong>
      <ul>
       <li>
        递归调用有额外开销，且可能重复计算（如斐波那契数列）。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       难以调试
      </strong>
      <ul>
       <li>
        递归调用层次较深时，调试困难。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_120">
     </a>
     <strong>
      六、优化递归算法
     </strong>
    </h4>
    <ol>
     <li>
      <strong>
       尾递归优化
      </strong>
      <ul>
       <li>
        将递归调用放在函数最后，编译器可以优化为迭代。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       记忆化（Memoization）
      </strong>
      <ul>
       <li>
        缓存已计算的子问题结果，避免重复计算。
       </li>
      </ul>
     </li>
     <li>
      <strong>
       迭代替代递归
      </strong>
      <ul>
       <li>
        使用栈或循环结构实现递归逻辑。
       </li>
      </ul>
     </li>
    </ol>
    <hr/>
    <h4>
     <a id="_130">
     </a>
     <strong>
      七、适用问题特征
     </strong>
    </h4>
    <ul>
     <li>
      问题可以分解为同类子问题。
     </li>
     <li>
      子问题的解可以合并为原问题的解。
     </li>
     <li>
      常见问题包括：数学问题、树和图遍历、分治算法等。
     </li>
    </ul>
    <p>
     递归算法是一种强大的工具，适合解决分治和回溯类问题。在实际应用中，需注意递归深度和效率问题，必要时进行优化或改用迭代实现。
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f38303231353238352f:61727469636c652f64657461696c732f313436333033363130" class_="artid" style="display:none">
 </p>
</div>


