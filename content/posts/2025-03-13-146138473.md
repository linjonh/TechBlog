---
layout: post
title: "C-stdlist超详细指南基础实践手搓list"
date: 2025-03-13 22:01:18 +0800
description: "list关键接口的学习"
keywords: "C++ std::list超详细指南：基础实践（手搓list）"
categories: ['C']
tags: ['算法', '数据结构', '开发语言', '学习', 'C']
artid: "146138473"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146138473
    alt: "C-stdlist超详细指南基础实践手搓list"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146138473
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146138473
cover: https://bing.ee123.net/img/rand?artid=146138473
image: https://bing.ee123.net/img/rand?artid=146138473
img: https://bing.ee123.net/img/rand?artid=146138473
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C++ std::list超详细指南：基础实践（手搓list）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h2 id="%E4%B8%80.%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7" name="%E4%B8%80.%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7" style="background-color:transparent">
     一.核心特性
    </h2>
    <hr/>
    <h3 id="1.%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84" name="1.%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84">
     <strong>
      1.双向循环链表结构
     </strong>
    </h3>
    <p>
     每个节点包含前驱和后继指针
    </p>
    <p>
     <img alt="" height="467" src="https://i-blog.csdnimg.cn/direct/fa0428da8a154eb685e4e5ec937c0215.png" width="747"/>
    </p>
    <h3 id="2.%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%9A%23include%20%3Clist%3E" name="2.%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%9A%23include%20%3Clist%3E">
     <strong>
      2.头文件
     </strong>
     ：
     <code>
      #include &lt;list&gt;
     </code>
    </h3>
    <h3 id="3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" name="3.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">
     <strong>
      3.时间复杂度
     </strong>
    </h3>
    <p>
     任意位置插入/删除：O(1)
    </p>
    <p>
     随机访问：O(n)
    </p>
    <p>
     排序：O(n log n)
    </p>
    <h3 id="4.%E5%86%85%E5%AD%98%E7%89%B9%E6%80%A7" name="4.%E5%86%85%E5%AD%98%E7%89%B9%E6%80%A7">
     <strong>
      4.内存特性
     </strong>
    </h3>
    <p>
     非连续内存存储
    </p>
    <p>
     每个元素需要额外存储两个指针（前驱+后继）
    </p>
    <p>
     内存占用 ≈ sizeof(T)
     <em>
      2 + 2
     </em>
     指针大小
    </p>
    <blockquote>
     <h2 id="%E4%BA%8C.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" name="%E4%BA%8C.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">
      二.构造函数
     </h2>
     <hr/>
     <p>
      <img alt="" height="260" src="https://i-blog.csdnimg.cn/direct/a94db4fcbef04b459c40036d6056c1ca.png" width="716"/>
     </p>
     <pre><code class="language-cpp">int main()
{
	list&lt;T&gt; lst1;            // 空链表
    list&lt;T&gt; lst2(n);         // n个默认初始化元素
    list&lt;T&gt; lst3(n, value);  // n个value副本
    list&lt;T&gt; lst4(begin, end);// 迭代器范围构造
    list&lt;T&gt; lst5(init_list); // 初始化列表 C++11
    list&lt;T&gt; lst6(lst4);      // 拷贝构造
}</code></pre>
    </blockquote>
    <h2 id="%C2%A0%E4%B8%89.list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8" name="%C2%A0%E4%B8%89.list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8" style="background-color:transparent">
     三.list iterator的使用
    </h2>
    <hr/>
    <blockquote>
     <h3 id="1.%E5%AD%A6%E4%B9%A0list%20iterator%E4%B9%8B%E5%89%8D%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93iterator%E7%9A%84%E5%8C%BA%E5%88%86" name="1.%E5%AD%A6%E4%B9%A0list%20iterator%E4%B9%8B%E5%89%8D%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93iterator%E7%9A%84%E5%8C%BA%E5%88%86" style="background-color:transparent">
      <strong>
       <span style="color:#fe2c24">
        1.学习list iterator
       </span>
       <span style="color:#fe2c24">
        之前我们要知道iterator的区分
       </span>
      </strong>
     </h3>
     <p>
      <strong>
       功能上区分：
      </strong>
     </p>
     <table border="1" cellpadding="1" cellspacing="1" style="width:700px">
      <tbody>
       <tr>
        <td>
         <strong>
          iterator
         </strong>
        </td>
        <td>
         <strong>
          普通迭代器
         </strong>
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          reverse_iterator
         </strong>
        </td>
        <td>
         <strong>
          反向迭代器
         </strong>
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          const_iterator
         </strong>
        </td>
        <td>
         <strong>
          只读迭代器
         </strong>
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          const_reverse_iterator
         </strong>
        </td>
        <td>
         <strong>
          只读反向迭代器
         </strong>
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      <strong>
       性质上区分：
      </strong>
     </p>
     <table border="1" cellpadding="1" cellspacing="1" style="width:700px">
      <tbody>
       <tr>
        <td>
         <strong>
          名称
         </strong>
        </td>
        <td>
         <strong>
          代表容器
         </strong>
        </td>
        <td>
         <strong>
          支持操作
         </strong>
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          单向迭代器（ForwardIterator）
         </strong>
        </td>
        <td>
         <strong>
          Forward_list(单链表)，unordered_map
         </strong>
        </td>
        <td>
         <strong>
          ++
         </strong>
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          双向迭代器（BidirectionalIterator）
         </strong>
        </td>
        <td>
         <strong>
          list(链表)，map，set
         </strong>
        </td>
        <td>
         <strong>
          ++/--
         </strong>
        </td>
       </tr>
       <tr>
        <td>
         <strong>
          随机迭代器（RandomAccessIterator）
         </strong>
        </td>
        <td>
         <strong>
          vector，string，deque
         </strong>
        </td>
        <td>
         <strong>
          ++/--/+/-
         </strong>
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      <strong>
       <span style="color:#fe2c24">
        通过底层结构决定可以实现哪些算法
       </span>
      </strong>
     </p>
     <p>
      <strong>
       比如算法库里的sort要求使用
       <span style="color:#fe2c24">
        随机迭代器，
       </span>
       <span style="color:#0d0016">
        list就无法使用这个算法
       </span>
      </strong>
     </p>
     <p>
      <img alt="" height="124" src="https://i-blog.csdnimg.cn/direct/8836cbc0db4f4947b58ad4ded4fe2bd4.png" width="1599"/>
     </p>
     <p>
      <img alt="" height="500" src="https://i-blog.csdnimg.cn/direct/dd8d3e20be434380940b12a9bdd98df8.png" width="1126"/>
     </p>
     <p>
      <strong>
       对于算法库里的reverse和find可以正常使用
      </strong>
     </p>
     <p>
      <img alt="" height="132" src="https://i-blog.csdnimg.cn/direct/e19252c99ea544f492ae6671bc9746b2.png" width="1617"/>
     </p>
     <p>
      <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/a7b3ea209a5b4dc0be9c97d78fbaebd9.png" width="1614"/>
     </p>
     <p>
      可以得知，功能是向上兼容得
     </p>
     <h3 id="%E2%80%8B%E7%BC%96%E8%BE%91" name="%E2%80%8B%E7%BC%96%E8%BE%91">
      <img alt="" height="129" src="https://i-blog.csdnimg.cn/direct/ea64c865824d48a9b6176dc00c8873ae.png" width="704"/>
     </h3>
    </blockquote>
    <p>
     <span style="color:#fe2c24">
      <strong>
       此处，大家可暂时将迭代器理解成一个指针，该指针指向list中的某个节点
      </strong>
     </span>
    </p>
    <blockquote>
     <h3 id="%C2%A02.begin()%2Bend()%C2%A0" name="%C2%A02.begin()%2Bend()%C2%A0" style="background-color:transparent">
      2.begin()+end()
     </h3>
     <p>
      返回第一个元素的迭代器+返回最后一个元素下一个位置的迭代器
     </p>
     <p>
      <img alt="" height="305" src="https://i-blog.csdnimg.cn/direct/4c26740a23d0433891212782f7ec27ff.png" width="1187"/>
     </p>
    </blockquote>
    <blockquote>
     <h3 id="3.%20rbegin()%2Brend()%C2%A0" name="3.%20rbegin()%2Brend()%C2%A0" style="background-color:transparent">
      3.rbegin()+rend()
     </h3>
     <p>
      返回第一个元素的reverse_iterator,即end位置，返回最后一个元素下一个位置的reverse_iterator,即begin位置
     </p>
     <p>
      <img alt="" height="295" src="https://i-blog.csdnimg.cn/direct/3fadbe5e99b44548a26d17e68cdbf3f2.png" width="1182"/>
     </p>
     <p>
      <img alt="" height="663" src="https://i-blog.csdnimg.cn/direct/e71f2e78ae334d9a808a45da66276aa9.png" width="696"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);

	auto it = lt.rbegin();
	while (it != lt.rend())
	{
		cout &lt;&lt; *it &lt;&lt; " ";  //4 3 2 1
		++it;
	}
	cout &lt;&lt; endl;</code></pre>
    </blockquote>
    <ul>
     <li>
      <strong>
       begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动
      </strong>
     </li>
     <li>
      <strong>
       rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动
      </strong>
     </li>
    </ul>
    <h2 id="%C2%A0%E5%9B%9B.list%E5%85%B3%E9%94%AE%E6%8E%A5%E5%8F%A3" name="%C2%A0%E5%9B%9B.list%E5%85%B3%E9%94%AE%E6%8E%A5%E5%8F%A3">
     四.list关键接口
    </h2>
    <hr/>
    <blockquote>
     <h3 id="1.empty()" name="1.empty()">
      1.empty()
     </h3>
     <p>
      检测list是否为空，是返回true，否则返回false
     </p>
     <p>
      <img alt="" height="169" src="https://i-blog.csdnimg.cn/direct/4a4f6b5973d3408dbff9f175a978eba2.png" width="1604"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	cout&lt;&lt;lt.empty()&lt;&lt;endl;   //1
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	cout &lt;&lt; lt.empty();    //0</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="2.%20size()" name="2.%20size()">
      2. size()
     </h3>
     <p>
      返回list中有效节点的个数
     </p>
     <p>
      <img alt="" height="172" src="https://i-blog.csdnimg.cn/direct/40cef15237394586b5e28c58d38cd098.png" width="1609"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	cout&lt;&lt;lt.size()&lt;&lt;endl;   //0
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	cout &lt;&lt; lt.size();    //4</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="3.front()" name="3.front()">
      3.front()
     </h3>
     <p>
      返回list的第一个节点中值的引用
     </p>
     <p>
      <img alt="" height="60" src="https://i-blog.csdnimg.cn/direct/bbcf68b1db4c49efb516c6a52c98a0f6.png" width="729"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	cout &lt;&lt; lt.front();    //1</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="4.%20back()" name="4.%20back()">
      4. back()
     </h3>
     <p>
      返回list的最后一个节点中值的引用
     </p>
     <p>
      <img alt="" height="143" src="https://i-blog.csdnimg.cn/direct/c499433a8509466b911aa1feae86414b.png" width="1620"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	cout &lt;&lt; lt.back();    //4</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="5.push_front()" name="5.push_front()">
      5.push_front()
     </h3>
     <p>
      在list首元素前插入值为val的元素
     </p>
     <p>
      <img alt="" height="200" src="https://i-blog.csdnimg.cn/direct/80e305e18f98413c92abc752624a01ef.png" width="1618"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.push_front(5);    //5 1 2 3 4</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="6.%C2%A0pop_front()" name="6.%C2%A0pop_front()">
      6. pop_front()
     </h3>
     <p>
      删除list中第一个元素
     </p>
     <p>
      <img alt="" height="46" src="https://i-blog.csdnimg.cn/direct/9547f32c026c419b8450b9e13798ce1a.png" width="697"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.pop_front();    //2 3 4</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="%C2%A07.push_back()" name="%C2%A07.push_back()">
      7.push_back()
     </h3>
     <p>
      在list尾部插入值为val的元素
     </p>
     <p>
      <img alt="" height="84" src="https://i-blog.csdnimg.cn/direct/1004a9878cf44a31a60f019d74ba7cc9.png" width="670"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.push_back(5);    //1 2 3 4 5</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="8.%20pop_back()" name="8.%20pop_back()">
      8. pop_back()
     </h3>
     <p>
      删除list中最后一个元素
     </p>
     <p>
      <img alt="" height="108" src="https://i-blog.csdnimg.cn/direct/5f9887ba74b94d2293412d329ea3f215.png" width="1612"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.pop_back();    //1 2 3 </code></pre>
    </blockquote>
    <blockquote>
     <h3 id="9.insert%20()" name="9.insert%20()">
      9.insert ()
     </h3>
     <p>
      在list position 位置中插入值为val的元素
     </p>
     <p>
      <img alt="" height="352" src="https://i-blog.csdnimg.cn/direct/abbc8dc169b64abe9663891afde52a79.png" width="1615"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	std::list&lt;int&gt;::iterator it;
	it=lt.begin();
	int k = 3;

	while (k--)
	{
		++it;
	}
	lt.insert(it, 30); 1 2 3 30 4</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="10.erase()" name="10.erase()">
      10.erase()
     </h3>
     <p>
      删除list position位置的元素
     </p>
     <p>
      <img alt="" height="203" src="https://i-blog.csdnimg.cn/direct/a3c6b8d3961f42ca878b35878379480b.png" width="1604"/>
     </p>
     <pre><code class="language-cpp">	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	std::list&lt;int&gt;::iterator it;
	it=lt.begin();
	int k = 2;

	while (k--)
	{
		++it;
	}
	lt.erase(it);  //1 2 4</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="11.swap()" name="11.swap()">
      11.swap()
     </h3>
     <p>
      交换两个list中的元素
     </p>
     <p>
      <img alt="" height="101" src="https://i-blog.csdnimg.cn/direct/f345e272bed64bf4955b0c2c262f742a.png" width="1606"/>
     </p>
     <pre><code class="language-cpp">	std::list&lt;int&gt; first(3, 100);   // 100 100 100
	std::list&lt;int&gt; second(5, 200);  // 200 200 200 200 200

	first.swap(second);   // 200 200 200 200 200</code></pre>
    </blockquote>
    <blockquote>
     <h3 id="12.clear()" name="12.clear()">
      12.clear()
     </h3>
     <p>
      清空list中的有效元素
     </p>
     <p>
      <img alt="" height="166" src="https://i-blog.csdnimg.cn/direct/c733f938653a4ad7b11ab3683a326fb0.png" width="1623"/>
     </p>
     <pre><code class="language-cpp">	std::list&lt;int&gt; mylist;

	mylist.push_back(1101);   //1101
	mylist.clear();
	mylist.push_back(2202);   //2202
	return 0;</code></pre>
    </blockquote>
    <h2 id="%E4%BA%94.list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" name="%E4%BA%94.list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88">
     五.list的迭代器失效
    </h2>
    <hr/>
    <p>
     前面说过，此处大家可将迭代器
     <span style="color:#fe2c24">
      <strong>
       暂时理解成类似于指针
      </strong>
     </span>
     ，迭代器失效即迭代器所指向的节点的无效，即该节点被删除了。因为list的底层结构为带头结点的双向循环链表，因此在list中进行
     <strong>
      <span style="color:#fe2c24">
       插入时是不会导致list的迭代器失效的
      </span>
     </strong>
     ，
     <span style="color:#fe2c24">
      <strong>
       只有在删除时才会失效
      </strong>
     </span>
     ，并且失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响
    </p>
    <pre><code class="language-cpp">void TestListIterator1() {
    int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
    list&lt;int&gt; l(array, array + sizeof(array) / sizeof(array[0]));
    auto it = l.begin();
    while (it != l.end()) {
        // erase()函数执行后，it所指向的节点已被删除，因此it无效，在下一次使用it时，必须先给其赋值
        l.erase(it);
        ++it;
    }
}
// 改正 
void TestListIterator() {
    int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
    list&lt;int&gt; l(array, array + sizeof(array) / sizeof(array[0]));
    auto it = l.begin();
    while (it != l.end()) {
        l.erase(it++); // it = l.erase(it);
    }
}</code></pre>
    <h2 id="%E5%85%AD.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0list" name="%E5%85%AD.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0list">
     六.模拟实现list
    </h2>
    <hr/>
    <h3 id="1.List.h%C2%A0" name="1.List.h%C2%A0">
     1.List.h
    </h3>
    <pre><code class="language-cpp">#pragma once  // 防止头文件重复包含
#include&lt;assert.h&gt;  // 断言检查

// 实现双向链表及相关迭代器
class bit
{
    // 链表节点结构体模板
    template&lt;class T&gt;
    struct list_node
    {
        T _data;         // 节点存储的数据
        list_node&lt;T&gt;* _next; // 后继指针
        list_node&lt;T&gt;* _prev; // 前驱指针

        // 节点构造函数（默认构造空对象）
        list_node(const T&amp; data = T())
            :_data(data)
            , _next(nullptr)
            , _prev(nullptr)
        {
        }
    };

    // 链表迭代器结构体模板（支持普通/const迭代器）
    template&lt;class T, class Ref, class Ptr&gt;
    struct list_iterator
    {
        typedef list_node&lt;T&gt; Node;     // 节点类型重命名
        typedef list_iterator&lt;T, Ref, Ptr&gt; self; // 迭代器自身类型

        Node* _node;  // 迭代器当前指向的节点

        list_iterator(Node* node) :_node(node) 
        {}

        // 解引用操作符（返回数据引用）
        Ref operator*() 
        { 
            return _node-&gt;_data; 
        }

        // 成员访问操作符（返回数据指针）
        // 使得 it-&gt;member 等价于 (&amp;it-&gt;)_data-&gt;member
        Ptr operator-&gt;() 
        { 
            return &amp;_node-&gt;_data; 
        }

        // 前置++（移动到下一节点）
        self&amp; operator++() {
            _node = _node-&gt;_next;
            return *this;
        }

        // 前置--（移动到前一节点）
        self&amp; operator--() {
            _node = _node-&gt;_prev;
            return *this;
        }

        // 后置++（需要返回临时对象）
        self operator++(int) {
            self tmp(*this);
            _node = _node-&gt;_next;
            return tmp;
        }

        // 后置--（同上）
        self operator--(int) {
            self tmp(*this);
            _node = _node-&gt;_prev;
            return tmp;
        }

        // 比较操作符重载
        bool operator!=(const self&amp; s) const 
        { 
            return _node != s._node; 
        }
        bool operator==(const self&amp; s) const 
        { 
            return _node == s._node; 
        }
    };

    // 链表类模板
    template &lt;class T&gt;
    class list
    {
        typedef list_node&lt;T&gt; Node; // 节点类型简写
    public:
        /*typedef list_iterator&lt;T&gt; iterator;
          typedef list_const_iterator&lt;T&gt; const_iterator;*/  //两个代码相似度太高，所以通过增加模板参数实现

        // 迭代器类型定义（通过模板参数实现const重载）
        typedef list_iterator&lt;T, T&amp;, T*&gt; iterator;          // 普通迭代器
        typedef list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator; // const迭代器

        // 获取起始迭代器（指向第一个有效节点）
        iterator begin() 
        { 
            return _head-&gt;_next; 
        }

        // 获取结束迭代器（哨兵节点）
        iterator end() 
        { 
            return _head; 
        }

        // const版本迭代器
        const_iterator begin() const 
        { 
            return _head-&gt;_next; 
        }
        const_iterator end() const 
        { 
            return _head; 
        }

        // 初始化哨兵节点（构建空链表）
        void empty_init() {
            _head = new Node;       // 申请头节点
            _head-&gt;_next = _head;   // 初始状态自环
            _head-&gt;_prev = _head;
            _size = 0;              // 大小置零
        }

        // 默认构造函数
        list() 
        { 
            empty_init(); 
        }

        // 初始化列表构造（支持花括号初始化）
        list(std::initializer_list&lt;T&gt; il) {
            empty_init();
            for (auto&amp; e : il) {   // 遍历列表插入元素
                push_back(e);
            }
        }

        // 拷贝构造函数（深拷贝）
        list(const list&lt;T&gt;&amp; lt) {
            empty_init();
            for (auto&amp; e : lt) {   // 遍历插入每个元素
                push_back(e);
            }
        }

        // 赋值运算符（拷贝交换惯用法）
        list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt) {
            swap(lt); // 交换资源
            return *this;
        }

        // 析构函数（清理节点）
        ~list() {
            clear();        // 删除所有数据节点
            delete _head;   // 释放哨兵节点
            _head = nullptr;
        }

        // 清空链表（保留哨兵节点）
        void clear() {
            auto it = begin();
            while (it != end()) {   // 逐个删除节点
                it = erase(it);
            }
        }

        // 交换两个链表内容
        void swap(list&lt;T&gt;&amp; lt) {
            std::swap(_head, lt._head); // 交换头指针
            std::swap(_size, lt._size);  // 交换大小
        }

        // 尾插（复用insert实现）
        void push_back(const T&amp; x) 
        { 
            //Node* newnode = new Node(x);
            //Node* tail = _head-&gt;_prev;
            //tail-&gt;_next = newnode;
            //newnode-&gt;_prev = tail;
            //newnode-&gt;_next = _head;
            //_head-&gt;prev = newnode;  
            insert(end(), x); //直接调用insert
        }

        // 头插
        void push_front(const T&amp; x) 
        { 
            insert(begin(), x); 
        }

        // 在pos位置前插入新节点
        iterator insert(iterator pos, const T&amp; x) {
            Node* cur = pos._node;  // 当前节点
            Node* prev = cur-&gt;_prev; // 前驱节点
            Node* newnode = new Node(x); // 创建新节点

            // 调整指针链接
            newnode-&gt;_next = cur;
            cur-&gt;_prev = newnode;
            newnode-&gt;_prev = prev;
            prev-&gt;_next = newnode;

            ++_size;        // 更新大小
            return newnode; // 返回新节点位置
        }

        // 尾删
        void pop_back() 
        { 
            erase(--end()); 
        }

        // 头删
        void pop_front() 
        { 
            erase(begin()); 
        }

        // 删除pos位置节点（注意：原代码此处返回类型应为iterator）
        iterator erase(iterator pos) {
            assert(pos != end()); // 不能删除哨兵节点

            Node* prev = pos._node-&gt;_prev; // 前驱节点
            Node* next = pos._node-&gt;_next; // 后继节点

            // 调整链接关系
            prev-&gt;_next = next;
            next-&gt;_prev = prev;

            delete pos._node; // 释放节点
            --_size;          // 更新大小

            return next; // 返回下一位置的迭代器
        }

        // 获取元素数量
        size_t size() const 
        { 
            return _size; 
        }

        // 判断是否为空
        bool empty() const 
        { 
            return _size == 0; 
        }

    private:
        Node* _head;    // 哨兵头节点
        size_t _size;   // 元素个数
    };
};

// 打印容器内容（泛型模板）
template&lt;class Container&gt;
void print_container(const Container&amp; con) {
    // 使用const迭代器遍历（保证内容不被修改）
    // const iterator -&gt; 迭代器本身不能修改
    // const_iterator -&gt; 指向内容不能修改
    typename Container::const_iterator it = con.begin(); // typename指明依赖类型
    //auto it = con.begin();或者使用auto
    while (it != con.end()) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
        ++it;
    }
    std::cout &lt;&lt; std::endl;

    // 范围for遍历（C++11特性）
    for (auto e : con) {
        std::cout &lt;&lt; e &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}</code></pre>
    <h3 id="2.test.cpp" name="2.test.cpp">
     2.test.cpp
    </h3>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
#include&lt;algorithm&gt;

using namespace std;
#include"list.h"

void test_list1()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);

	list&lt;int&gt;::iterator it = lt.begin();
	while (it != lt.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	/*it = lt.begin();
	lt.erase(it + 3);*/

	// 不支持，要求随机迭代器
	//sort(lt.begin(), lt.end());

	string s("dadawdfadsa");
	cout &lt;&lt; s &lt;&lt; endl;
	sort(s.begin(), s.end());
	cout &lt;&lt; s &lt;&lt; endl;
}
void test_list3()
{
	list&lt;int&gt; lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	lt.push_back(5);
	lt.push_back(6);

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	auto it = lt.begin();
	int k = 3;
	while (k--)
	{
		++it;
	}

	lt.insert(it, 30);

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	int x = 0;
	cin &gt;&gt; x;
	it = find(lt.begin(), lt.end(), x);
	if (it != lt.end())
	{
		lt.erase(it);
	}

	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}
void test_list4()
{
	// 直接构造
	list&lt;int&gt; lt0({ 1,2,3,4,5,6 });
	// 隐式类型转换
	list&lt;int&gt; lt1 = { 1,2,3,4,5,6,7,8 };
	const list&lt;int&gt;&amp; lt3 = { 1,2,3,4,5,6,7,8 };

	print_container(lt1);
}



int main()
{
	//test_list3();
	//test_list4();
	test_list1();

}
</code></pre>
    <h2 id="%C2%A0%E4%B8%83.list%E4%B8%8Evector%E7%9A%84%E5%AF%B9%E6%AF%94" name="%C2%A0%E4%B8%83.list%E4%B8%8Evector%E7%9A%84%E5%AF%B9%E6%AF%94">
     七.list与vector的对比
    </h2>
    <table border="1" cellpadding="1" cellspacing="1" style="width:700px">
     <tbody>
      <tr>
       <td style="width:131px">
       </td>
       <td style="width:342px">
        vector
       </td>
       <td style="width:225px">
        list
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        底 层 结 构
       </td>
       <td style="width:342px">
        动态顺序表，一段连续空间
       </td>
       <td style="width:225px">
        带头结点的双向循环链表
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        随 机 访 问
       </td>
       <td style="width:342px">
        支持随机访问，访问某个元素效率O(1)
       </td>
       <td style="width:225px">
        不支持随机访问，访问某个元素效率O(N)
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        插 入 和 删 除
       </td>
       <td style="width:342px">
        任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)，插入时有可能需要增容，增容：开辟新空间，拷贝元素，释放旧空间，导致效率更
        <br/>
        低
       </td>
       <td style="width:225px">
        任意位置插入和删除效率高，不需要搬移元素，时间复杂度为O(1)
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        空 间 利 用 率
       </td>
       <td style="width:342px">
        底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高
       </td>
       <td style="width:225px">
        底层节点动态开辟，小节点容易造成内存碎片，空间利用率低，缓存利用率低
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        迭 代 器
       </td>
       <td style="width:342px">
        原生态指针
       </td>
       <td style="width:225px">
        对原生态指针(节点指针)进行封装
        <br/>
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        迭 代 器 失 效
       </td>
       <td style="width:342px">
        在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，致使原来迭代器失效，删除时，当前迭代器需要重新赋值否则会失效
       </td>
       <td style="width:225px">
        插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响
       </td>
      </tr>
      <tr>
       <td style="width:131px">
        使 用 场 景
       </td>
       <td style="width:342px">
        需要高效存储，支持随机访问，不关心插入删除效率
       </td>
       <td style="width:225px">
        大量插入和删除操作，不关心随机访问
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     学到C++11时需要补充一些新的接口。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f61313539323236363037332f:61727469636c652f64657461696c732f313436313338343733" class_="artid" style="display:none">
 </p>
</div>


