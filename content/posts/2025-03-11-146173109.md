---
layout: post
title: "数据结构之线性表"
date: 2025-03-11 11:08:23 +0800
description: "线性表是数据结构中最基础且常用的一种结构，它是由一组具有相同类型的元素组成的有序序列。线性表可以通过顺序存储或链式存储来实现。本文将重点介绍顺序存储的线性表，并通过C语言代码来展示其基本操作。data：指向存储元素的数组。size：当前线性表的大小（即元素个数）。capacity：线性表的最大容量。int *data;// 存储元素的数组int size;// 当前大小// 最大容量} List;顺序存储的线性表是一种简单且高效的数据结构，适用于元素数量相对固定且需要频繁访问的场景。"
keywords: "数据结构之线性表"
categories: ['未分类']
tags: ['数据结构']
artid: "146173109"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146173109
    alt: "数据结构之线性表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146173109
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146173109
cover: https://bing.ee123.net/img/rand?artid=146173109
image: https://bing.ee123.net/img/rand?artid=146173109
img: https://bing.ee123.net/img/rand?artid=146173109
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     数据结构之线性表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <h3 name="1%20%E7%AE%80%E4%BB%8B">
     1 简介
    </h3>
    <p>
     线性表是数据结构中最基础且常用的一种结构，它是由一组具有相同类型的元素组成的有序序列。线性表可以通过顺序存储或链式存储来实现。本文将重点介绍顺序存储的线性表，并通过C语言代码来展示其基本操作。
    </p>
    <h3 id="2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" name="2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">
     2 线性表的基本概念
    </h3>
    <p>
     线性表是一种线性结构，元素之间存在一对一的关系。线性表的基本操作包括：
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/da794776238647ffabf9237b5fc5d4fe.png"/>
    </p>
    <h3 id="3%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%A0" name="3%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%A0">
     3 顺序存储的线性表
    </h3>
    <p>
     顺序存储的线性表是通过数组来实现的。数组中的元素在内存中是连续存储的，因此可以通过下标直接访问元素，具有较高的访问效率。然而，顺序存储的线性表在插入和删除操作时，需要移动大量元素，时间复杂度较高。
    </p>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/e020ab99d9864149bede61e42181acee.png"/>
    </p>
    <h4 id="3.1%C2%A0%E5%AE%9A%E4%B9%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84" name="3.1%C2%A0%E5%AE%9A%E4%B9%89%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84">
     3.1 定义线性表结构
    </h4>
    <p>
     我们首先定义一个线性表的结构体，包含以下成员：
    </p>
    <ul>
     <li>
      <p>
       <code>
        data
       </code>
       ：指向存储元素的数组。
      </p>
     </li>
     <li>
      <p>
       <code>
        size
       </code>
       ：当前线性表的大小（即元素个数）。
      </p>
     </li>
     <li>
      <p>
       <code>
        capacity
       </code>
       ：线性表的最大容量。
      </p>
     </li>
    </ul>
    <pre><code class="language-cpp">typedef struct
{
    int *data;      // 存储元素的数组
    int size;       // 当前大小
    int capacity;   // 最大容量
} List;</code></pre>
    <h4 id="3.2%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E6%80%A7%E8%A1%A8" name="3.2%C2%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E6%80%A7%E8%A1%A8">
     3.2 初始化线性表
    </h4>
    <p>
     在初始化线性表时，我们需要为其分配一块连续的内存空间，并设置初始容量和大小。
    </p>
    <pre><code class="language-cpp">void init(List *l)
{
    l-&gt;capacity = MAX;  // 初始容量
    l-&gt;size = 0;        // 初始大小为0
    l-&gt;data = malloc(sizeof(int) * l-&gt;capacity);  // 分配内存
}</code></pre>
    <h4 id="3.3%20%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" name="3.3%20%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">
     3.3 插入元素
    </h4>
    <p>
     插入元素时，需要考虑线性表是否已满。如果已满，则需要先进行扩容操作。插入元素的时间复杂度为O(n)，因为可能需要移动大量元素。
    </p>
    <pre><code class="language-cpp">void insert(List *l, int index, int e)
{
    // 扩容
    if (l-&gt;size == l-&gt;capacity)
    {
        incr(l);
    }
    if (index == l-&gt;size)
        add(l, e);
    if (index &lt; l-&gt;size)
    {
        for (int i = l-&gt;size - 1; i &gt;= index; i--)
        {
            l-&gt;data[i + 1] = l-&gt;data[i];
        }
        l-&gt;data[index] = e;
        l-&gt;size++;
    }
}</code></pre>
    <h4 id="3.4%20%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0" name="3.4%20%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">
     3.4 删除元素
    </h4>
    <p>
     删除元素时，同样需要移动元素以填补删除后的空缺。删除操作的时间复杂度也是O(n)。
    </p>
    <pre><code class="language-cpp">int del(List *l, int index)
{
    for (int i = index; i &lt; l-&gt;size; i++)
    {
        l-&gt;data[i] = l-&gt;data[i + 1];
    }
    l-&gt;size--;
}</code></pre>
    <h4 id="3.5%20%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0" name="3.5%20%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">
     3.5 查找元素
    </h4>
    <p>
     查找操作可以通过遍历数组来实现。如果找到目标元素，则返回其索引；否则返回-1。查找操作的时间复杂度为O(n)。
    </p>
    <pre><code class="language-cpp">int find(List *l, int val)
{
    int index = -1;
    for (int i = 0; i &lt; l-&gt;size; i++)
    {
        if (l-&gt;data[i] == val)
        {
            index = i;
            break;
        }
    }
    return index;
}</code></pre>
    <h4 id="3.6%20%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C" name="3.6%20%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C">
     3.6 扩容操作
    </h4>
    <p>
     当线性表的容量不足时，我们需要对其进行扩容。常见的扩容策略有：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        倍增
       </strong>
       ：每次扩容时将容量翻倍。
      </p>
     </li>
     <li>
      <p>
       <strong>
        固定增量
       </strong>
       ：每次扩容时增加固定的容量。
      </p>
     </li>
    </ul>
    <p>
     在本文中，我们采用倍增策略进行扩容。
    </p>
    <pre><code class="language-cpp">void incr(List *l)
{
    if (l-&gt;size &lt; l-&gt;capacity) return;
    int incr = l-&gt;capacity &lt;&lt; 1;  // 容量翻倍
    l-&gt;capacity += incr;
    l-&gt;data = realloc(l-&gt;data, sizeof(int) * l-&gt;capacity);  // 重新分配内存
}</code></pre>
    <h4 id="3.7%20%E6%89%93%E5%8D%B0%E7%BA%BF%E6%80%A7%E8%A1%A8" name="3.7%20%E6%89%93%E5%8D%B0%E7%BA%BF%E6%80%A7%E8%A1%A8">
     3.7 打印线性表
    </h4>
    <p>
     为了方便调试和查看线性表的状态，我们可以实现一个打印函数，输出线性表中的所有元素及其容量和大小。
    </p>
    <pre><code class="language-cpp">int show(List *l)
{
    printf("--------------------\n");
    printf("数据:");
    for (int i = 0; i &lt; l-&gt;size; i++)
    {
        printf("%d,", l-&gt;data[i]);
    }
    printf("\n容量:%d,大小:%d\n", l-&gt;capacity, l-&gt;size);
}</code></pre>
    <h3 id="4%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8" name="4%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8">
     4 线性表的应用
    </h3>
    <p>
     顺序存储的线性表在实际应用中有广泛的用途，例如：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        数组
       </strong>
       ：数组本身就是一种顺序存储的线性表。
      </p>
     </li>
     <li>
      <p>
       <strong>
        栈和队列
       </strong>
       ：栈和队列可以通过顺序存储的线性表来实现。
      </p>
     </li>
     <li>
      <p>
       <strong>
        动态数组
       </strong>
       ：通过动态扩容，顺序存储的线性表可以实现动态数组的功能。
      </p>
     </li>
    </ul>
    <h3 id="5%20%E6%80%BB%E7%BB%93%C2%A0" name="5%20%E6%80%BB%E7%BB%93%C2%A0" style="background-color:transparent">
     5 总结
    </h3>
    <p>
     顺序存储的线性表是一种简单且高效的数据结构，适用于元素数量相对固定且需要频繁访问的场景。然而，由于其插入和删除操作的时间复杂度较高，因此在需要频繁插入和删除的场景下，链式存储的线性表可能更为合适。
    </p>
    <p>
     通过本文的代码示例，我们可以清晰地看到顺序存储线性表的基本操作及其实现细节。希望本文能帮助你更好地理解线性表的概念及其应用。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343039313237362f:61727469636c652f64657461696c732f313436313733313039" class_="artid" style="display:none">
 </p>
</div>


