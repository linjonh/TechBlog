---
layout: post
title: "webpack介绍"
date: 2025-03-11 22:43:49 +0800
description: "使用。"
keywords: "webpack介绍"
categories: ['工程化']
tags: ['前端', 'Webpack', 'Node']
artid: "145044529"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=145044529
    alt: "webpack介绍"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=145044529
featuredImagePreview: https://bing.ee123.net/img/rand?artid=145044529
cover: https://bing.ee123.net/img/rand?artid=145044529
image: https://bing.ee123.net/img/rand?artid=145044529
img: https://bing.ee123.net/img/rand?artid=145044529
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     webpack介绍
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     entry与output
    </h2>
    <p>
     入口是 Webpack 开始构建依赖图的起点，Webpack 会从入口文件开始，递归地分析项目的依赖图。输出指定 Webpack 打包后的文件存放位置和文件名。
    </p>
    <pre><code class="language-javascript">const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
};
</code></pre>
    <p>
     依赖图如下所示 ：
    </p>
    <p>
     <img alt="" height="534" src="https://i-blog.csdnimg.cn/direct/d87c2e61271f45bd858163ba67f73905.png" width="601"/>
    </p>
    <h2>
     loader
    </h2>
    <p>
     Webpack 支持使用
     <a href="https://webpack.js.org/concepts/loaders" rel="nofollow" title="loader">
      loader
     </a>
     对文件进行预处理。这允许你bundle JavaScript 之外的任何静态资源。
    </p>
    <h3>
     css-loader与style-loader
    </h3>
    <p>
     <strong>
      <code>
       css-loader
      </code>
     </strong>
     是 Webpack 中的一个加载器（loader），它允许你在 JavaScript 中直接导入 CSS 文件，并将这些 CSS 文件打包到最终的 bundle 中。这种方式与传统的通过
     <code>
      &lt;link&gt;
     </code>
     标签在 HTML 中引入 CSS 文件的方式不同。
    </p>
    <p>
     实验结构如下：
    </p>
    <p>
     <img alt="" height="397" src="https://i-blog.csdnimg.cn/direct/cc8a8507b52845cb9cefdee1eed79396.png" width="442"/>
    </p>
    <p>
     如果只是单纯的在index.js中引入style.css：
    </p>
    <pre><code class="language-css">#header {
  color: blue;
}

.button {
  background-color: yellow;
}
</code></pre>
    <pre><code class="language-javascript">import _ from "lodash";
import "./style.css";

document.getElementById("button1").addEventListener("click", function () {
  const el = document.getElementById("header");
  el.innerHTML = "Hey i have updated the code !";

  const listItems = ["Apple", "orange", "Banana"];
  const ul = document.getElementById("shoppingList");
  _.forEach(listItems, function (item) {
    const tempEl = document.createElement("li");
    tempEl.innerHTML = item;
    ul.appendChild(tempEl);
  });
});
</code></pre>
    <p>
     会报错如下：
    </p>
    <p>
     <img alt="" height="254" src="https://i-blog.csdnimg.cn/direct/e4a3f6319b1a477f9ca1834e3df25baa.png" width="1200"/>
    </p>
    <p>
     首先下载npm install --save-dev css-loader style-loader，并且在webpack.config.js中进行配置:
    </p>
    <pre><code class="language-javascript">const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ["css-loader"， "style-loader"],
      },
    ],
  },
};
</code></pre>
    <p>
     <strong>
      <code>
       module
      </code>
     </strong>
     是一个关键配置项，用于定义
     <strong>
      如何处理项目中不同类型的模块
     </strong>
     （如 JavaScript、CSS、图片、字体等），其中rules可以设置多种资源的loader，test匹配文件名，use调用对应loader。
    </p>
    <p>
     为了匹配文件名使用正则表达式，其中
     <code>
      /
     </code>
     正表示则表达式的开始和结束符号，
     <code>
      \.
     </code>
     表示匹配字符
     <code>
      .
     </code>
     （因为
     <code>
      .
     </code>
     在正则中有特殊含义，所以需要用
     <code>
      \
     </code>
     转义），css表示匹配字符串
     <code>
      css，
     </code>
     <code>
      $
     </code>
     表示匹配字符串的结尾。）
    </p>
    <p>
     成功bundle如下：
    </p>
    <p>
     <img alt="" height="368" src="https://i-blog.csdnimg.cn/direct/c2f0650a141c422dbe7bd90f3d97a162.png" width="1200"/>
    </p>
    <p>
     webpack会隐式插入：
    </p>
    <p>
     <img alt="" height="203" src="https://i-blog.csdnimg.cn/direct/234626daed6548fa8ed5a4a7f041589a.png" width="731"/>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       但以上内容还存在问题
      </strong>
     </span>
    </p>
    <p>
     我们接着引入clearButton.js与clearButton.css，如下：
    </p>
    <pre><code class="language-javascript">import "./clearButton.css";

const el = document.createElement("button");
el.innerHTML = "Clear";
el.classList.add("button");
el.onclick = function () {
  alert("Clear clicked");
};

document.body.appendChild(el);
</code></pre>
    <pre><code class="language-css">.button {
  background-color: red;
}
</code></pre>
    <p>
     index.js与index.html如下：
    </p>
    <pre><code class="language-javascript">import _ from "lodash";
import "./style.css";
import "./clearButton";

document.getElementById("button1").addEventListener("click", function () {
  console.log("-----------");
  const el = document.getElementById("header");
  el.innerHTML = "Hey i have updated the code !";

  const listItems = ["Apple", "orange", "Banana"];
  const ul = document.getElementById("shoppingList");
  _.forEach(listItems, function (item) {
    const tempEl = document.createElement("li");
    tempEl.innerHTML = item;
    ul.appendChild(tempEl);
  });
});
</code></pre>
    <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1 id="header"&gt;Hey this is my first webpack application !!&lt;/h1&gt;
    &lt;ul id="shoppingList"&gt;&lt;/ul&gt;
    &lt;button id="button1" class="button"&gt;Click me&lt;/button&gt;
  &lt;/body&gt;
  &lt;script src="/dist/bundle.js"&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
    <p>
     会存在以下问题
    </p>
    <p>
     <img alt="" height="343" src="https://i-blog.csdnimg.cn/direct/d1376629c4054772a9956f780ac56ac8.png" width="1200">
      <img alt="" height="234" src="https://i-blog.csdnimg.cn/direct/787e725745e94a49a322d440c1b61aa7.png" width="936"/>
     </img>
    </p>
    <p>
     <span style="color:#fe2c24">
      <strong>
       后面.button覆盖了前面的 ！
      </strong>
     </span>
    </p>
    <p>
     <span style="color:#0d0016">
      要解决这个问题修改webpack.config.js,
     </span>
     在
     <code>
      css-loader
     </code>
     中启用了
     <code>
      modules: true
     </code>
     ，这会将 CSS 文件中的类名局部化。
     <span style="color:#0d0016">
      如下：
     </span>
    </p>
    <pre><code class="language-javascript">const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: "style-loader" },
          { loader: "css-loader", options: { modules: true } },
        ],
      },
    ],
  },
};
</code></pre>
    <p>
     如此类名将会发生变化
    </p>
    <p>
     <img alt="" height="309" src="https://i-blog.csdnimg.cn/direct/130d50858f944aa080fe7a8ef6363f91.png" width="831">
      但是这样仍然存在问题——直接import "xxx".css将会找不到类名。
     </img>
    </p>
    <p>
     需要用 这种方式导入css，
    </p>
    <pre><code class="language-javascript">import { button } from "./index.css";
</code></pre>
    <pre><code class="language-javascript">import { button } from "./clearButton.css";
</code></pre>
    <p>
     并且以此种方式对元素进行添加。
    </p>
    <pre><code class="language-javascript">btn1.classList.add([button]);
</code></pre>
    <pre><code class="language-javascript">el.classList.add([button]);
</code></pre>
    <p>
     另外，还能将css类名定义为全局类名，
     <span style="color:#fe2c24">
      <strong>
       保持其原有的名称
      </strong>
     </span>
     。
    </p>
    <pre><code class="language-css">:global(.button) {
  background: yellow;
}
</code></pre>
    <h3>
     img-loader
    </h3>
    <p>
     webpack.config.js中设置如下，在 Webpack 中，
     <code>
      type: "asset/resource"
     </code>
     是一种用于处理静态资源（如图片、字体等）的配置方式。如下所示：
    </p>
    <p>
     <img alt="" height="387" src="https://i-blog.csdnimg.cn/direct/88535a8607084e999a7c2f8da0b8f6a8.png" width="1163"/>
    </p>
    <pre><code class="language-javascript">const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
    assetModuleFilename: "images/[hash][ext]",
    clean: true,
  },
  module: {
    rules: [
      {
        test: /\.(css)$/,
        use: [
          { loader: "style-loader" },
          { loader: "css-loader", options: { modules: true } },
        ],
      },
      {
        test: /.(png|jpeg|gif|svg)$/,
        type: "asset/resource",
      },
    ],
  },
};
</code></pre>
    <p>
     图片生成如下：
    </p>
    <p>
     <img alt="" height="135" src="https://i-blog.csdnimg.cn/direct/11f52cb99aa04d5fbb8eaaf0b87eb9ca.png" width="447"/>
    </p>
    <p>
     在代码中，导入这些文件时会返回文件的 URL。
    </p>
    <pre><code class="language-javascript">import logo from "./assets/webpack_logo.png";
</code></pre>
    <pre><code class="language-javascript">logoEl.src = logo;
</code></pre>
    <p>
     <img alt="" height="384" src="https://i-blog.csdnimg.cn/direct/9b78a79c1c3c4dffbddf79171a5a6a96.png" width="862"/>
    </p>
    <h4>
     补充：
    </h4>
    <h5>
     <code>
      1.assetModuleFilename
     </code>
     ：资源文件输出路径
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       <br/>
       全局定义通过资源模块（Asset Modules）处理的文件（如图片、字体、视频等）的输出路径和文件名格式。
      </p>
     </li>
     <li>
      <p>
       <strong>
        配置位置
       </strong>
       <br/>
       位于
       <code>
        output
       </code>
       配置对象中。
      </p>
     </li>
     <li>
      <h5>
       <strong>
        路径格式说明
       </strong>
      </h5>
      <ul>
       <li>
        <p>
         <code>
          [hash]
         </code>
         : 文件内容的哈希值（避免缓存问题）
        </p>
       </li>
       <li>
        <p>
         <code>
          [ext]
         </code>
         : 原始文件扩展名（如
         <code>
          .png
         </code>
         ）
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     <code>
      <font face="-apple-system, SF UI Text, Arial, PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, sans-serif, SimHei, SimSun">
       2.
      </font>
      clean
     </code>
     ：清理输出目录
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       <br/>
       在每次构建前自动清理
       <code>
        output.path
       </code>
       目录（默认是
       <code>
        dist
       </code>
       ），删除旧文件，避免残留文件干扰。
      </p>
     </li>
     <li>
      <p>
       <strong>
        配置位置
       </strong>
       <br/>
       直接作为顶级配置项。
      </p>
     </li>
    </ul>
    <h3>
     font-loader
    </h3>
    <p>
     webpack.config.js配置如下：
    </p>
    <pre><code class="language-javascript">const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
    assetModuleFilename: "images/[hash][ext]",
    clean: true,
  },
  module: {
    rules: [
      {
        test: /\.(css)$/,
        use: [
          { loader: "style-loader" },
          { loader: "css-loader", options: { modules: true } },
        ],
      },
      {
        test: /.(png|jpeg|gif|svg)$/,
        type: "asset/resource",
      },
      {
        test: /.(ttf|woff|woff2)$/,
        type: "asset/resource",
      },
    ],
  },
};
</code></pre>
    <p>
     其中字体文件可以放置于asset/font目录下
    </p>
    <p>
     <img alt="" height="102" src="https://i-blog.csdnimg.cn/direct/ec8655e3de604f1ab43244b2819770c0.png" width="421"/>
    </p>
    <p>
     引入字体文件
    </p>
    <pre><code class="language-javascript">import "./assets/fonts/Redressed-Regular.ttf";
</code></pre>
    <p>
     这样就可以使用该字体了
    </p>
    <pre><code class="language-css">.header {
  text-decoration: underline;
  color: blue;
  font-family: 'Redressed', cursive;
}</code></pre>
    <blockquote>
     <p>
      其余loader可在官网查看！
     </p>
    </blockquote>
    <h2>
     plugin
    </h2>
    <h3>
     multiple entry
    </h3>
    <p>
     在 Webpack 中，多入口允许你定义多个入口文件，Webpack 会分别处理这些入口，并为每个入口生成独立的打包文件。
    </p>
    <pre><code class="language-javascript">module.exports = {
  entry: {
    index: "./src/index.js",
    product: "./src/products.js",
  },
  output: {
    filename: "[name].bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
}</code></pre>
    <h5>
     1.
     <strong>
      多入口 (
      <code>
       entry
      </code>
      对象)
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        作用
       </strong>
       ：允许将代码拆分为多个独立的入口文件，每个入口生成一个独立的依赖关系图和打包结果。
      </p>
     </li>
     <li>
      <p>
       <strong>
        适用场景
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         多页面应用（MPA）：每个页面有独立的入口和资源。
        </p>
       </li>
       <li>
        <p>
         按功能拆分代码：如管理后台和用户端分离。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h5>
     2.
     <strong>
      输出占位符
      <code>
       [name]
      </code>
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       <strong>
        动态替换
       </strong>
       ：
       <code>
        [name]
       </code>
       会被替换为入口对象的键名（如
       <code>
        index
       </code>
       和
       <code>
        product
       </code>
       ）。
      </p>
     </li>
     <li>
      <p>
       <strong>
        生成的文件
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         <code>
          dist/index.bundle.js
         </code>
        </p>
       </li>
       <li>
        <p>
         <code>
          dist/product.bundle.js
         </code>
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="" height="91" src="https://i-blog.csdnimg.cn/direct/c964b5de864946a1a34e0996d797412e.png" width="505"/>
    </p>
    <p>
     有问题：现在还需再html中手动链接bundle.js：
    </p>
    <p>
     <img alt="" height="36" src="https://i-blog.csdnimg.cn/direct/171307665d8647a192f32df43794e571.png" width="703"/>
    </p>
    <p>
     <img alt="" height="50" src="https://i-blog.csdnimg.cn/direct/addd213385c245d6b6ae9ad298d1f555.png" width="751"/>
    </p>
    <h3>
     Plugin有什么作用
    </h3>
    <p>
     增强webpack
    </p>
    <p>
     <img alt="" height="554" src="https://i-blog.csdnimg.cn/direct/930397650a9d4f7b8977cc8e23b5c845.png" width="1558"/>
    </p>
    <h3>
     HTML WebpackPlugin
    </h3>
    <p>
     <code>
      HtmlWebpackPlugin
     </code>
     是 Webpack 生态中一个核心插件，用于
     <strong>
      自动化生成 HTML 文件
     </strong>
     并
     <strong>
      自动注入打包后的 JavaScript/CSS 资源路径
     </strong>
     。
    </p>
    <h4>
     <strong>
      核心功能
     </strong>
    </h4>
    <ol>
     <li>
      <p>
       <strong>
        自动生成 HTML 文件
       </strong>
       <br/>
       基于模板（或默认模板）生成 HTML，自动插入
       <code>
        &lt;script&gt;
       </code>
       和
       <code>
        &lt;link&gt;
       </code>
       标签。
      </p>
     </li>
     <li>
      <p>
       <strong>
        多入口适配
       </strong>
       <br/>
       为每个入口生成独立的 HTML 文件，并精准注入对应的资源。
      </p>
     </li>
     <li>
      <p>
       <strong>
        资源路径管理
       </strong>
       <br/>
       自动处理带哈希的文件名（如
       <code>
        bundle.[contenthash].js
       </code>
       ），避免缓存问题。
      </p>
     </li>
     <li>
      <p>
       <strong>
        HTML 优化
       </strong>
       <br/>
       支持压缩 HTML、移除注释、排序属性等优化操作。
      </p>
     </li>
    </ol>
    <h4>
     <strong>
      基础用法
     </strong>
    </h4>
    <p>
     先下载插件
    </p>
    <pre><code class="language-javascript">npm install --save-dev html-webpack-plugin</code></pre>
    <p>
     引入插件
    </p>
    <pre><code class="language-javascript">const htmlWebpackPlugin = require("html-webpack-plugin");
</code></pre>
    <h4>
    </h4>
    <h4>
     基本配置
    </h4>
    <pre><code class="language-javascript">const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  plugins: [
    new HtmlWebpackPlugin()
  ]
};</code></pre>
    <h4>
     高级配置
    </h4>
    <p>
     多页面应用
    </p>
    <pre><code class="language-javascript">module.exports = {
  entry: {
    index: './src/index.js',
    product: './src/product.js'
  },
  plugins: [
    // 首页
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
      chunks: ['index']  // 只注入 index 入口的 JS
    }),
    // 商品页
    new HtmlWebpackPlugin({
      template: './src/product.html',
      filename: 'product.html',
      chunks: ['product']  // 只注入 product 入口的 JS
    })
  ]
};</code></pre>
    <ul>
     <li>
      <strong>
       template
      </strong>
      : 用于
      <strong>
       指定生成 HTML 文件的模板
      </strong>
     </li>
     <li>
      <strong>
       chunks
      </strong>
      : 用于
      <strong>
       控制哪些 chunk 会被注入到生成的 HTML 文件中
      </strong>
      。
     </li>
     <li>
      <strong>
       filename
      </strong>
      : 指定
      <strong>
       生成的
      </strong>
      HTML 文件名。
     </li>
    </ul>
    <p>
     产物如下所示：
    </p>
    <p>
     <img alt="" height="172" src="https://i-blog.csdnimg.cn/direct/64ec3c4c454e4007b3a3c29ab0547d93.png" width="451"/>
    </p>
    <p>
     这样还存在问题：
    </p>
    <p>
     <img alt="" height="50" src="https://i-blog.csdnimg.cn/direct/f83515b46ca7443aa61d33462d4d2129.png" width="800"/>
     <img alt="" height="46" src="https://i-blog.csdnimg.cn/direct/2c27f5a2cc954f1799d0ccb1e3c55075.png" width="565"/>
    </p>
    <p>
     css和其他资源文件都不在生成的dist中。 我们当然可以手动的移动这些文件到dist目录下，但是我们也可以配
     <span style="color:#0d0016">
      置
     </span>
     <span style="color:#fe2c24">
      <strong>
       服务器热更新
      </strong>
     </span>
     。
    </p>
    <p>
     首先安装
    </p>
    <pre><code class="language-javascript">npm i --save-dev webpack-dev-server</code></pre>
    <p>
     进行配置
    </p>
    <pre><code class="language-javascript">const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
    // 确保资源文件路径正确（可选）
    assetModuleFilename: "assets/[hash][ext][query]",
  },
  module: {
    rules: [
      // 处理 CSS 文件
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"], // 顺序从右到左执行
      },
      // 处理图片、字体等资源文件
      {
        test: /\.(png|jpg|jpeg|gif|svg|woff|woff2|eot|ttf|otf)$/,
        type: "asset/resource", // Webpack 5+ 原生资源模块
        // 或使用 file-loader（Webpack 4）
        // use: "file-loader",
      },
    ],
  },
  // 配置开发服务器（热更新）
  devServer: {
    static: {
      directory: path.join(__dirname, "dist"), // 服务 dist 目录
    },
    hot: true, // 启用热更新
    open: true, // 自动打开浏览器
  },
};</code></pre>
    <p>
     在node脚本中进行配置
    </p>
    <pre><code class="language-javascript">  "scripts": {
    "build": "webpack --config webpack.config.js --mode development",
    "dev": "webpack serve --mode development --open"
  },</code></pre>
    <h2>
     代码拆分
    </h2>
    <h3>
     1.
     <strong>
      提取公共代码（SplitChunksPlugin）
     </strong>
    </h3>
    <pre><code class="language-javascript">module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all', // 提取所有类型的 chunk（包括异步和同步）
      minSize: 20000, // 文件大于 20KB 才提取
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/, // 提取 node_modules 中的代码
          name: 'vendors', // 输出文件名
          priority: 10 // 优先级
        },
        default: {
          minChunks: 2, // 至少被引用 2 次才提取
          name: 'common',
          priority: 5
        }
      }
    }
  }
};</code></pre>
    <p>
     <strong>
      生成的文件
     </strong>
     ：
    </p>
    <p>
     <img alt="" height="210" src="https://i-blog.csdnimg.cn/direct/2904d224d7d1418fb5fd0438e2ee539e.png" width="912"/>
    </p>
    <h3>
     2.
     <strong>
      动态导入（Dynamic Imports）
     </strong>
    </h3>
    <p>
     使用
     <code>
      import()
     </code>
     语法动态加载模块，Webpack 会自动将其拆分为单独的 chunk，它不会在初始加载时立即请求模块，而是延迟到实际需要时才加载。其饭返回一个promise：
    </p>
    <pre><code class="language-javascript">// 动态加载模块
button.addEventListener('click', () =&gt; {
  import('./module.js').then(module =&gt; {
    module.default();
  });
});</code></pre>
    <p>
     <strong>
      生成的文件
     </strong>
     ：
     <img alt="" height="184" src="https://i-blog.csdnimg.cn/direct/a3a53c46f4594272b82b90899a7c351b.png" width="998"/>
    </p>
    <p>
     <strong>
      自定义 chunk 名称
     </strong>
     ：
     <br/>
     使用
     <code>
      webpackChunkName
     </code>
     注释：
    </p>
    <pre><code class="language-javascript">import(/* webpackChunkName: "my-chunk" */ './module.js');</code></pre>
    <p>
     这段代码是
     <strong>
      Webpack 的动态导入语法
     </strong>
     ，结合了
     <strong>
      魔法注释（Magic Comments）
     </strong>
     ，用于实现
     <strong>
      代码拆分（Code Splitting）
     </strong>
     。它的核心作用是将
     <code>
      module.js
     </code>
     文件单独打包成一个独立的代码块（chunk），并赋予其一个自定义名称
     <code>
      my-chunk
     </code>
     。
    </p>
    <p>
     <strong>
      魔法注释：
     </strong>
    </p>
    <p>
     <img alt="" height="301" src="https://i-blog.csdnimg.cn/direct/304fe952c01b450191796a3c56e1906a.png" width="1062"/>
    </p>
    <p>
     <strong>
      应用场景 ：
     </strong>
    </p>
    <p>
     在用户交互时加载特定组件：
    </p>
    <pre><code class="language-javascript">button.addEventListener('click', () =&gt; {
  import('./Modal.js').then(module =&gt; {
    const Modal = module.default;
    Modal.show();
  });
});</code></pre>
    <p>
     路由懒加载：
     <br/>
     在单页面应用（SPA）中，按需加载路由组件：
    </p>
    <pre><code class="language-javascript">const Home = () =&gt; import(/* webpackChunkName: "home" */ './Home.vue');
const About = () =&gt; import(/* webpackChunkName: "about" */ './About.vue');</code></pre>
    <h2>
     为bundle添加hash
    </h2>
    <p>
     在 Webpack 中，为打包后的文件（如 JavaScript、CSS、图片等）添加
     <strong>
      哈希值（Hash）
     </strong>
     是一种常见的优化策略。
    </p>
    <h3>
     <strong>
      1. 哈希类型
     </strong>
    </h3>
    <p>
     Webpack 支持以下几种哈希类型：
    </p>
    <p>
     <img alt="" height="296" src="https://i-blog.csdnimg.cn/direct/628c4195f56c428f91ecab23496868cc.png" width="1051"/>
    </p>
    <h3>
     <strong>
      2. 配置哈希文件名
     </strong>
    </h3>
    <p>
     在
     <code>
      webpack.config.js
     </code>
     中，通过
     <code>
      output.filename
     </code>
     和
     <code>
      output.chunkFilename
     </code>
     配置哈希文件名。
    </p>
    <p>
    </p>
    <pre><code class="language-javascript">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: '[name].[contenthash].js', // 入口文件使用 contenthash
    chunkFilename: '[name].[contenthash].js', // 动态导入的 chunk 使用 contenthash
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.(png|jpg|jpeg|gif|svg)$/,
        type: 'asset/resource',
        generator: {
          filename: 'assets/[name].[contenthash][ext]', // 图片文件使用 contenthash
        },
      },
    ],
  },
};</code></pre>
    <h3>
     <strong>
      3. 生成的文件结构
     </strong>
    </h3>
    <p>
     <img alt="" height="162" src="https://i-blog.csdnimg.cn/direct/661f4c8cf1f542c5b576e8695cb16977.png" width="666"/>
    </p>
    <h3>
     <strong>
      4. 哈希值的稳定性
     </strong>
    </h3>
    <ul>
     <li>
      <p>
       <strong>
        <code>
         [hash]
        </code>
       </strong>
       ：每次构建都会变化，即使文件内容没有变化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         [chunkhash]
        </code>
       </strong>
       ：只有 chunk 内容变化时才会变化。
      </p>
     </li>
     <li>
      <p>
       <strong>
        <code>
         [contenthash]
        </code>
       </strong>
       ：只有文件内容变化时才会变化。
      </p>
     </li>
    </ul>
    <p>
     推荐使用
     <code>
      [contenthash]
     </code>
     ，因为它更精确地反映了文件内容的变化。
    </p>
    <h2>
     从js中提取css
    </h2>
    <p>
     将CSS从JavaScript中提取出来并单独作为CSS文件，可以对浏览器加载HTML带来以下好处：
    </p>
    <ul>
     <li>
      <p>
       <strong>
        缓存和性能改善
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         当HTML、CSS和JavaScript分离时，浏览器可以缓存CSS文件，从而在访问其他页面时减少加载时间，提高性能。
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <strong>
        渲染速度提升
       </strong>
       ：
      </p>
      <ul>
       <li>
        <p>
         CSS文件是渲染阻塞资源，浏览器必须下载并解析CSS后才能渲染页面。
        </p>
       </li>
       <li>
        <p>
         通过提取关键CSS（critical CSS）并内联到HTML头部，可以减少初始渲染时间，特别是在网络条件较差的情况下
         <a href="https://web.dev/articles/extract-critical-css" rel="nofollow" title="3">
          3
         </a>
         。
        </p>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <strong>
      1. 核心思路
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        提取 CSS
       </strong>
       ：将 CSS 从 JavaScript 中分离，生成独立的
       <code>
        .css
       </code>
       文件。
      </p>
     </li>
     <li>
      <p>
       <strong>
        自动注入
       </strong>
       ：在 HTML 中自动插入
       <code>
        &lt;link&gt;
       </code>
       标签引用生成的 CSS 文件。
      </p>
     </li>
    </ol>
    <h3>
     <strong>
      2. 安装依赖
     </strong>
    </h3>
    <pre>npm install --save-dev mini-css-extract-plugin html-webpack-plugin</pre>
    <h3>
     <strong>
      3. 配置 Webpack
     </strong>
    </h3>
    <p>
     在
     <code>
      webpack.config.js
     </code>
     中配置以下内容：
    </p>
    <pre><code class="language-javascript">const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.[contenthash].js',
    path: path.resolve(__dirname, 'dist'),
    clean: true, // 自动清理 dist 目录
  },
  module: {
    rules: [
      // 处理 CSS 文件
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader, // 提取 CSS 到独立文件
          'css-loader', // 解析 CSS 语法
        ],
      },
      // 处理图片、字体等资源文件（可选）
      {
        test: /\.(png|jpg|jpeg|gif|svg|woff|woff2|eot|ttf|otf)$/,
        type: 'asset/resource', // Webpack 5+ 原生资源模块
        generator: {
          filename: 'assets/[name].[contenthash][ext]', // 资源文件输出路径
        },
      },
    ],
  },
  plugins: [
    // 提取 CSS 到独立文件
    new MiniCssExtractPlugin({
      filename: 'styles.[contenthash].css', // 输出的 CSS 文件名（带哈希）
    }),
    // 自动生成 HTML 并注入 CSS/JS
    new HtmlWebpackPlugin({
      template: './src/index.html', // HTML 模板文件
    }),
  ],
};</code></pre>
    <h3>
     <strong>
      4. 项目结构示例
     </strong>
    </h3>
    <p>
     <img alt="" height="152" src="https://i-blog.csdnimg.cn/direct/5301fcc48d294c26bd70abd6de514ca8.png" width="426"/>
    </p>
    <h5>
     <strong>
      <code>
       src/index.js
      </code>
     </strong>
    </h5>
    <pre><code class="language-javascript">import './styles.css'; // 导入 CSS 文件</code></pre>
    <h5>
     <strong>
      <code>
       src/styles.css
      </code>
     </strong>
    </h5>
    <pre><code class="language-css">body {
  background: #f0f0f0;
  font-family: Arial;
}</code></pre>
    <h5>
     <strong>
      <code>
       src/index.html
      </code>
     </strong>
    </h5>
    <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;My App&lt;/title&gt;
    &lt;!-- 不需要手动写 &lt;link&gt;，HtmlWebpackPlugin 会自动注入 --&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
    <h3>
     <strong>
      5. 构建结果
     </strong>
    </h3>
    <p>
     运行
     <code>
      npm run build
     </code>
     后，生成的
     <code>
      dist
     </code>
     目录如下：
    </p>
    <p>
     <img alt="" height="150" src="https://i-blog.csdnimg.cn/direct/6e1785d7cd44473080067bf39c7e14ff.png" width="858"/>
    </p>
    <h5>
     <strong>
      生成的
      <code>
       dist/index.html：
      </code>
     </strong>
    </h5>
    <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;My App&lt;/title&gt;
    &lt;link href="styles.5a6b7c8d.css" rel="stylesheet"&gt; &lt;!-- 自动注入 CSS --&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="bundle.3f9a8b7e.js"&gt;&lt;/script&gt; &lt;!-- 自动注入 JS --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
    <h2>
     Shimming
    </h2>
    <p>
     <strong>
      Webpack Shimming
     </strong>
     是一种在 Webpack 中处理全局依赖或模块兼容性问题的技术。它的核心作用是为代码提供缺失的依赖项，或者修改模块的行为，使其能够在 Webpack 构建的环境中正常运行。
    </p>
    <h3>
     <strong>
      为什么需要 Shimming？
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        处理全局变量
       </strong>
       ：某些库依赖全局变量（如
       <code>
        jQuery
       </code>
       的
       <code>
        $
       </code>
       ），但 Webpack 默认不会将这些变量暴露给模块。
      </p>
     </li>
     <li>
      <p>
       <strong>
        兼容旧代码
       </strong>
       ：一些老旧的库可能不符合模块化规范（如 CommonJS、ES Module），需要手动处理。
      </p>
     </li>
     <li>
      <p>
       <strong>
        提供缺失的依赖
       </strong>
       ：某些模块可能依赖特定的全局变量或模块，但这些依赖在 Webpack 中不存在。
      </p>
     </li>
    </ol>
    <h3>
     <strong>
      Shimming 的实现方式
     </strong>
    </h3>
    <p>
     Webpack 提供了多种方式来实现 Shimming：
    </p>
    <h4>
     <strong>
      1. 使用
      <code>
       ProvidePlugin
      </code>
     </strong>
    </h4>
    <p>
     <code>
      ProvidePlugin
     </code>
     是 Webpack 内置的插件，用于自动加载模块，并将其注入到每个模块中。
    </p>
    <p>
     <strong>
      示例：自动加载 jQuery
     </strong>
    </p>
    <p>
     假设项目中使用了
     <code>
      jQuery
     </code>
     ，但不想在每个模块中手动
     <code>
      import $ from 'jquery'
     </code>
     ，可以通过
     <code>
      ProvidePlugin
     </code>
     自动注入
     <code>
      $
     </code>
     和
     <code>
      jQuery
     </code>
     。
    </p>
    <pre><code class="language-javascript">const webpack = require('webpack');

module.exports = {
  plugins: [
    new webpack.ProvidePlugin({
      $: 'jquery', // 当模块中使用 $ 时，自动加载 jquery
      jQuery: 'jquery', // 当模块中使用 jQuery 时，自动加载 jquery
    }),
  ],
};</code></pre>
    <p>
     <strong>
      效果
     </strong>
    </p>
    <ul>
     <li>
      <p>
       在任何模块中使用
       <code>
        $
       </code>
       或
       <code>
        jQuery
       </code>
       时，Webpack 会自动引入
       <code>
        jquery
       </code>
       模块。
      </p>
     </li>
     <li>
      <p>
       例如：
      </p>
     </li>
    </ul>
    <pre><code class="language-javascript">// 不需要手动 import $ from 'jquery';
$(document).ready(() =&gt; {
  console.log('jQuery is ready!');
});</code></pre>
    <h4>
     <strong>
      2.使用
      <code>
       externals
      </code>
     </strong>
    </h4>
    <p>
     <code>
      externals
     </code>
     是 Webpack 的一个配置选项，用于将某些依赖项排除在打包之外。它的核心作用是告诉 Webpack：“这些依赖项不需要打包到最终的输出文件中，因为它们已经在运行环境中存在了。”
    </p>
    <h5>
     <strong>
      1) 使用 CDN 加载库
     </strong>
    </h5>
    <p>
     <strong>
      在 HTML 中引入 jQuery
     </strong>
    </p>
    <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;My App&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
    <p>
     <strong>
      在 Webpack 中配置
      <code>
       externals
      </code>
     </strong>
    </p>
    <pre><code class="language-javascript">module.exports = {
  externals: {
    jquery: 'jQuery', // 将 jquery 映射为全局变量 jQuery
  },
};</code></pre>
    <p>
     <strong>
      在代码中使用 jQuery
     </strong>
    </p>
    <pre><code class="language-javascript">import $ from 'jquery'; // 从全局变量中获取 jQuery

$(document).ready(() =&gt; {
  console.log('jQuery is ready!');
});</code></pre>
    <h6>
     <strong>
      效果
     </strong>
    </h6>
    <ul>
     <li>
      <p>
       Webpack 不会将
       <code>
        jQuery
       </code>
       打包到
       <code>
        bundle.js
       </code>
       中。
      </p>
     </li>
     <li>
      <p>
       代码中通过
       <code>
        import $ from 'jquery'
       </code>
       获取全局变量
       <code>
        jQuery
       </code>
       。
      </p>
     </li>
    </ul>
    <h5>
     <strong>
      2) 排除第三方库
     </strong>
    </h5>
    <pre><code class="language-javascript">module.exports = {
  externals: {
    react: 'React', // 排除 React
    'react-dom': 'ReactDOM', // 排除 ReactDOM
    lodash: '_', // 排除 Lodash
  },
};</code></pre>
    <h4>
     <strong>
      3.
     </strong>
     resolve.alias
    </h4>
    <p>
     <code>
      resolve.alias
     </code>
     是 Webpack 的一个配置选项，用于为模块路径
     <span style="color:#fe2c24">
      <strong>
       创建别名（Alias）
      </strong>
     </span>
     。它的核心作用是简化模块的导入路径，避免在代码中编写冗长的相对路径，同时也可以解决模块路径冲突的问题。
    </p>
    <p>
     <strong>
      基本配置
     </strong>
    </p>
    <p>
     在
     <code>
      webpack.config.js
     </code>
     中配置
     <code>
      resolve.alias
     </code>
     ：
    </p>
    <pre><code class="language-javascript">const path = require('path');

module.exports = {
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'), // 将 @ 映射为 src 目录
      components: path.resolve(__dirname, 'src/components'), // 将 components 映射为 src/components 目录
    },
  },
};</code></pre>
    <h5>
     <strong>
      效果
     </strong>
    </h5>
    <ul>
     <li>
      <p>
       在代码中可以使用别名代替完整路径：
      </p>
     </li>
    </ul>
    <pre><code class="language-javascript">import MyComponent from '@/components/MyComponent'; // 相当于 src/components/MyComponent
import Button from 'components/Button'; // 相当于 src/components/Button</code></pre>
    <p>
     <strong>
      常见使用场景
     </strong>
    </p>
    <p>
     <strong>
      1. 简化路径
     </strong>
    </p>
    <p>
     将常用的目录映射为简短的别名：
    </p>
    <pre><code class="language-javascript">resolve: {
  alias: {
    '@': path.resolve(__dirname, 'src'),
    components: path.resolve(__dirname, 'src/components'),
    utils: path.resolve(__dirname, 'src/utils'),
  },
}</code></pre>
    <h5>
     <strong>
      2. 解决模块冲突
     </strong>
    </h5>
    <p>
     如果项目中安装了多个版本的库（如
     <code>
      lodash
     </code>
     和
     <code>
      lodash-es
     </code>
     ），可以通过别名指定使用哪个版本：
    </p>
    <pre><code class="language-javascript">resolve: {
  alias: {
    lodash: path.resolve(__dirname, 'node_modules/lodash-es'), // 强制使用 lodash-es
  },
}</code></pre>
    <h5>
     <strong>
      3. 替换模块
     </strong>
    </h5>
    <p>
     如果某个模块需要替换为自定义实现，可以通过别名指定：
    </p>
    <pre><code class="language-javascript">resolve: {
  alias: {
    'original-module': path.resolve(__dirname, 'src/custom-module'), // 替换为自定义模块
  },
}</code></pre>
    <p>
     <strong>
      结合 TypeScript 使用
     </strong>
    </p>
    <p>
     如果项目使用 TypeScript，需要在
     <code>
      tsconfig.json
     </code>
     中配置路径映射，以确保 TypeScript 能够正确解析别名。
    </p>
    <h5>
     <strong>
      <code>
       tsconfig.json
      </code>
      配置
     </strong>
    </h5>
    <pre><code class="language-javascript">{
  "compilerOptions": {
    "baseUrl": ".", // 基础路径
    "paths": {
      "@/*": ["src/*"], // 将 @ 映射为 src 目录
      "components/*": ["src/components/*"] // 将 components 映射为 src/components 目录
    }
  }
}</code></pre>
    <h5>
     <strong>
      Webpack 配置
     </strong>
    </h5>
    <pre><code class="language-javascript">{
  "compilerOptions": {
    "baseUrl": ".", // 基础路径
    "paths": {
      "@/*": ["src/*"], // 将 @ 映射为 src 目录
      "components/*": ["src/components/*"] // 将 components 映射为 src/components 目录
    }
  }
}</code></pre>
    <h2>
     Tree shaking
    </h2>
    <p>
     <strong>
      Tree shaking（摇树优化）
     </strong>
     是前端构建工具（如 Webpack、Rollup）中的一种优化技术，用于在打包时
     <strong>
      移除未被使用的代码（Dead Code）
     </strong>
     ，比如不用。它的名字来源于“摇晃一棵树，让枯叶（无用代码）落下”的比喻。
    </p>
    <p>
    </p>
    <h3>
     <strong>
      Tree shaking 生效的条件
     </strong>
    </h3>
    <p>
     <img alt="" height="523" src="https://i-blog.csdnimg.cn/direct/a9aec3b8961e41cfa4a9d7c39b98e48e.png" width="993"/>
    </p>
    <h3>
     配置方式
    </h3>
    <p>
     <strong>
      1. 配置生产模式
     </strong>
    </p>
    <pre><code class="language-javascript">// webpack.config.js
module.exports = {
  mode: 'production', // 生产模式自动启用 Tree shaking 和代码压缩
};</code></pre>
    <h5>
     <strong>
      2. 标记无副作用的模块
     </strong>
    </h5>
    <p>
     在
     <code>
      package.json
     </code>
     中声明：
    </p>
    <pre><code class="language-javascript">{
  "sideEffects": false // 所有文件均无副作用（默认值）
}</code></pre>
    <h3>
     <strong>
      Tree shaking 的局限性
     </strong>
    </h3>
    <ol>
     <li>
      <p>
       <strong>
        动态导入无法优化
       </strong>
       <br/>
       动态导入（如
       <code>
        import('module')
       </code>
       ）的代码可能无法被静态分析。
      </p>
     </li>
     <li>
      <p>
       <strong>
        第三方库的兼容性
       </strong>
       <br/>
       未使用 ES6 模块的库（如 Lodash）需配合插件（如
       <code>
        babel-plugin-lodash
       </code>
       ）或按需引入。
      </p>
     </li>
     <li>
      <p>
       <strong>
        副作用代码需手动标记
       </strong>
       <br/>
       未正确标记副作用的代码可能被误删，导致运行时错误。
      </p>
     </li>
    </ol>
    <h2>
     Production vs Development Build
    </h2>
    <p>
     <img alt="" height="594" src="https://i-blog.csdnimg.cn/direct/a249994aa87a4509ab8dca0292162cc3.png" width="815"/>
    </p>
    <h2>
     webpack配置文件拆分
    </h2>
    <p>
     在大型项目中，Webpack 配置文件可能会变得非常复杂和冗长。为了提升可维护性和灵活性，通常会将 Webpack 配置文件拆分为多个文件，分别用于不同的环境（如开发环境、生产环境）。
    </p>
    <h3>
     <strong>
      <code>
       webpack-merge
      </code>
     </strong>
     ：用于合并多个配置文件。
    </h3>
    <h5>
     <strong>
      <code>
       webpack.common.js
      </code>
      （公共配置）
     </strong>
    </h5>
    <pre><code class="language-javascript">const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, '../dist'),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.(png|jpg|jpeg|gif|svg)$/,
        type: 'asset/resource',
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
    }),
  ],
};</code></pre>
    <h5>
     <strong>
      <code>
       webpack.dev.js
      </code>
      （开发环境配置）
     </strong>
    </h5>
    <pre><code class="language-javascript">const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  mode: 'development',
  devtool: 'inline-source-map',
  devServer: {
    static: './dist',
    hot: true,
  },
});</code></pre>
    <h5>
     <strong>
      <code>
       webpack.prod.js
      </code>
      （生产环境配置）
     </strong>
    </h5>
    <pre><code class="language-javascript">const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  mode: 'production',
  devtool: 'source-map',
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
});</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34333036333339382f:61727469636c652f64657461696c732f313435303434353239" class_="artid" style="display:none">
 </p>
</div>


