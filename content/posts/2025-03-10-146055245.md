---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38373131363531312f:61727469636c652f64657461696c732f313436303535323435"
layout: post
title: "类和对象中"
date: 2025-03-10 18:56:17 +0800
description: "更加细致了解，学习类和对象"
keywords: "类和对象(中)"
categories: ['C']
tags: ['数据结构', '开发语言', 'C', 'C']
artid: "146055245"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146055245
    alt: "类和对象中"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146055245
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146055245
cover: https://bing.ee123.net/img/rand?artid=146055245
image: https://bing.ee123.net/img/rand?artid=146055245
img: https://bing.ee123.net/img/rand?artid=146055245
---

# 类和对象(中)

### 1.类的6个默认成员函数

> 如果一个类中什么成员都没有，简称为空类。空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。默认成员函数：用户没有显式实现，编译器会生成的成员函数称为默认成员函数
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dd98db0e50494a88a97fa236070c2e0b.png)

### 2.构造函数

> 概念：构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，以保证每个数据成员都有一个合适的初始值，并且
> **在对象整个生命周期内只调用一次**
> 。需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象，而是
> **初始化对象**
> 。
>   
> 特点：
>
> 1. 函数名与类名相同。
> 2. 无返回值。
> 3. 对象实例化时编译器自动调用对应的构造函数。
> 4. 构造函数可以重载。
> 5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造 函数，一旦用户显式定义编译器将不再生成。
>      
>    6.C++把类型分成
>    **内置类型**
>    (基本类型)和
>    **自定义类型**
>    。内置类型就是语言提供的数据类型，如：int/char…，自定义类型就是我们使用class/struct/union等自己定义的类型，
>    **编译器生成默认的构造函数只会对自定类型成员调用的它的默认成员函数**
>      
>    7.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。
>      
>    **注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。**
>      
>    **调用顺序：**
>      
>    **全局对象先于局部对象进行构造，局部对象按照出现的顺序进行构造，无论是否为static**

### 2.1构造函数类型

> 若已存在带缺省值的构造函数，新增无参构造函数会构成函数重载，无参调用存在歧义。
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dedb1f50e958400187e47fb125194984.png)
>   
> 可能依赖成员默认初始化
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dfec30d7fbdc4bc0b3d128615fa44cc0.png)
>
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9c514d95b5d24b079b54ccd9ed2629f1.png)

> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/40bceb2b279b48ad9c97fa08f4f7b7eb.png)

> 结论：一般情况下构造函数都要自己写，什么情况下可以不用自己写？
>   
> a.内置类型成员都有缺省值，且初始化符合我们要求
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f0b3be818d2e4830899c27bd9bae5b3d.png)

> b.全是自定义类型的构造，且这些类型都定义默认构造
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/87d260f94afb4edc8da74e55d0f03094.png)

### 3.析构函数

> 概念：特殊的成员函数，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而
> **对象在销毁时会自动调用析构函数，完成对象中资源的清理工作**
> 。
>   
> 特点：
>
> 1. 析构函数名是在类名前加上字符 ~。
> 2. 无参数无返回值类型。
> 3. **一个类只能有一个析构函数**
>    。若未显式定义，系统会自动生成默认的析构函数。注意：析构函数不能重载
> 4. **对象生命周期结束时，C++编译系统系统自动调用析构函数**
>      
>    5.内置类型成员不做处理，自定义类型成员会去调用他的析构函数
>
> > 总结：
> >   
> > 1.一般情况下，
> > **有动态申请资源，就需要显示写析构函数释放资源**
> > ，如Stack类。
> >   
> > 2.
> > **没有动态申请的资源，不需要写析构**
> > ，如Data类
> >   
> > 3.
> > **需要释放资源的成员都是自定义类型不需要析构**
> > ，如用栈实现队列

> **调用顺序：
>   
> 与构造函数相反，从最后派生的类开始调用，逐步向上调用到基类，局部对象按照出现的顺序从后往前调用，最后是全局变量，只需注意static改变对象的生存作用域之后，会放在局部对象之后进行析构。**

### 4.拷贝构造函数

> 为了创建一个与已存在对象一样的新对象并在此基础上进行操作，引入该函数。
>   
> 概念：
> **只有单个形参**
> ，该形参是对
> **本类类型对象的引用(一般常用const修饰)**
> ，在用
> **已存在的类类型对象创建新对象时由编译器自动调用**
> 。
>   
> 特点：
>
> 1. 拷贝构造函数是
>    **构造函数**
>    的一个
>    **重载形式**
> 2. 拷贝构造函数的
>    **参数只有一个**
>    且
>    **必须是类类型对象的引用**
>    ，使用
>    **传值方式编译器直接报错**
>    ，因为会引发无穷递归调用。
>      
>    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bb1436ff56244c67b514c3572880c66b.png)
>      
>    行为机制，
>    **实参复制到形参，需调用拷贝构造函数**
>    ，于是触发无穷递归，每次递归建立新的函数栈帧，直到栈空间耗尽。
>      
>    正确方式如下，以Date类为例
>      
>    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4886ad9b89dc4aa197474145c11e1fbe.png)
> 3. 拷贝构造函数典型调用场景：
>      
>    a.使用已存在对象创建新对象
>      
>    b.函数参数类型为类类型对象
>      
>    c.函数返回值类型为类类型对象
>      
>    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/61304beaca73425d9ab40a7bd289530a.png)
>      
>    这里以Date类为例感受拷贝构造函数的调用场景，同时注意为了提高程序效率，
>    **一般对象传参时，尽量使用引用类型，返回时根据实际场景，能用引用尽量使用引用**
>    。

### 5.运算符重载

> C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数,
>   
> 也具
> **有其返回值类型**
> ，
> **函数名字以及参数列表**
> ，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。
>   
> 函数原型：返回值类型 operator操作符(参数列表)
>   
> 注意：
>   
> 1.不能通过连接其他符号来创建新的操作符：比如operator@ ，要重载有意义的
>   
> 2.重载操作符必须有一个类类型参数
>   
> 3.用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不能改变其含义
>   
> 4.作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this

5. **.*
   :: sizeof ?: .以上5个运算符不能重载*
   \*

> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d14469c810834ebea546f36545047ea7.png)
>   
> 以<号为例，bool operator<(const Date&x)实际上是bool operator<(Data\*this,const Date&x),调用函数时可以直接(d1<d2),但
> **从汇编指令看调用过程中其实直接call运算符重载的地址，两种方式都可以写，但前者更简单。**
>   
> 注意若把运算符重载函数定义在
> **全局**
> 的就需要
> **成员变量是公有的**

### 5.1前置++后置++重载

> 前置++和后置++都是一元运算符(仅作用于一个操作数的运算符)，为了让前置++与后置++形成能正确重载，C++规定：后置++重载时多增加一个int类型的参数，但调用函数时该参数不用传递，编译器自动传递
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5b348364ab3e48db953b51ca156e521c.png)
>   
> 注意：后置++是先使用后+1，因此需要返回+1之前的旧值，故需在实现时需要先将this保存一份，然后给this+1。 而temp是临时对象，因此只能以值的方式返回，不能返回引用
>   
> 前置–和后置–原理相同。

### 5.2流插入和流提取运算符重载

> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/10dddbfec8ca48029125c0009318a4a2.png)

> 流插入写成成员函数
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aa9ccb0acd9c492fbedb30e55b2ea908.png)

> 因为Date对象默认占用第一个参数，作为this指针也就是左操作数，写出来是d1 << cout; // d1.operator<<(cout); 不符合使用习惯。

> 流插入定义在全局
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1754d1c4e38d4348b1b258dbe5c24dcf.png)
>   
> out是cout的别名，出来函数作用域不会销毁，可以传引用返回，方便连续流插入操作。
>   
> 定义在全局中时可以定义公有的成员函数来访问私有成员，注意是只读而不能更改数据，或者使用友元函数。友元函数只要定义在类中就可以访问其私有成员。
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8b8d19e3aec74713a11182298e8b32bc.png)
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7f82f3c06b924aa380f990b50a2acafe.png)
>   
> 需要注意判断输入日期的有效性。
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fe777a6ba7e44b44a0ca4180740f1232.png)
>   
> 连续流插入和流提取都是从左到右的顺序，第一次调用完后返回传引用返回cout和cin的别名，往右依次调用重载函数，和C语言中连续赋值和运算的顺序相反。

### 6.赋值运算符重载

> 格式：
>   
> 1.
> **参数类型**
> ：const T&，传递引用可以提高传参效率
>   
> 2.
> **返回值类型**
> ：T&，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值
>   
> 3.
> **检测是否自己给自己赋值**
> ，涉及到动态资源管理时需加入检查
>   
> 4.
> **返回\*this**
> ：要复合连续赋值的含义
>   
> 特征：
>   
> 1.赋值运算符
> **只能重载成类的成员函数不能重载成全局函数**
>   
> 原因：赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现一个全局的赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载冲突了，故赋值运算符重载只能是类的成员函数。
>   
> 2.用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。
>   
> **默认生成赋值重载跟拷贝构造行为一样
>   
> a.内置类型成员：直接赋值，浅拷贝
>   
> b.自定义类型成员会调用他的赋值重载**
>   
> 3.区分：
>   
> **运算符重载函数：已经存在的两个对象之间复制拷贝
>   
> 构造函数：用一个以及存在的对象初始化另一个对象**

> 需注意：
>   
> 如果类中未涉及到资源管理，赋值运算符是否实现都可以；一旦涉及到资源管理则必须要实现。(与拷贝构造函数相同)
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38a4b8fa3376460e8629fe6cbafd59d1.png)

### 7.const成员

> **将const修饰的“成员函数”称之为const成员函数**
> ，const修饰类成员函数，
> **实际修饰该成员函数隐含的this指针**
> ，表明在该成员函数中
> **不能对类的任何成员进行修改**
> 。
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/caa67768df8f4b99af30ebc2183db1af.png)
>   
> 从下图可发现几个问题
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2c1b438331b04ee9ae4174238a114abb.png)
>   
> **1.const对象不能调用非const成员函数**
> 。const对象状态不可修改，这样会造成权限放大的问题。
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3518d3e4f4b340759cd1e94501d8204a.png)
>   
> **2.非const成员可以调用const成员函数**
> 。const成员函数不会修改对象的成员变量，这样是权限缩小没问题。
>   
> 再来一张图来简单感受一下权限问题
>   
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ba68a313579e42fa8af4c204787ea5b0.png)

> **总结：
>   
> 只要成员内部不修改成员变量，都应该加const，这样const对象和普通对象都可以调用。权限可以缩小和转移，不能放大。**

### 8.取地址及const取地址操作符重载

> 意义：
> **控制对象获取行为**
>   
> **一般情况：使用编译器生成的默认取地址的重载，直接返回的this指针**
> (即对象的内存地址)。
>   
> **const版本的意义**
> ：
>   
> 1.保证常量性，防止通过指针修改对象内容
>   
> 2.权限控制：const成员函数内部只能调用其他const成员函数
>   
> **需要手动重载的场景**
> ：
>   
> 1.隐藏真实地址。安全敏感场景下避免外部直接操作内存对象
>   
> 2.一些附加功能的拓展
>   
> 3.返回特定内容：比如内部某个子成员地址