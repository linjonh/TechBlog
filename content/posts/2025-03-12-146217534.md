---
layout: post
title: "Docker基础入门一"
date: 2025-03-12 23:10:23 +0800
description: "可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统运行时利用沙箱机制形成隔离容器，各个应用互不干扰启动、移除都可以通过一行命令完成，方便快捷数据卷是一个虚拟目录，指向宿主机文件系统中的某个目录。其作用是将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。"
keywords: "Docker基础入门（一）"
categories: ['Linux']
tags: ['运维', '容器', 'Docker']
artid: "146217534"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146217534
    alt: "Docker基础入门一"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146217534
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146217534
cover: https://bing.ee123.net/img/rand?artid=146217534
image: https://bing.ee123.net/img/rand?artid=146217534
img: https://bing.ee123.net/img/rand?artid=146217534
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Docker基础入门（一）
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h3>
     <a id="Docker_0">
     </a>
     初识Docker
    </h3>
    <h4>
     <a id="Docker_2">
     </a>
     什么是Docker
    </h4>
    <p>
     Docker是一个快速交付应用、运行应用的技术：
    </p>
    <ol>
     <li>
      可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统
     </li>
     <li>
      运行时利用沙箱机制形成
      <strong>
       隔离容器
      </strong>
      ，各个应用互不干扰
     </li>
     <li>
      启动、移除都可以通过一行命令完成，方便快捷
     </li>
    </ol>
    <h5>
     <a id="_10">
     </a>
     应用部署的环境问题
    </h5>
    <p>
     大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题
    </p>
    <ul>
     <li>
      依赖关系复杂，容易出现兼容性问题
     </li>
     <li>
      开发、测试、生产环境有差异
     </li>
    </ul>
    <p>
     <img alt="image-20230417003210805" src="https://i-blog.csdnimg.cn/img_convert/01f1b9bbb29f993a6b34448dd14856fe.png"/>
    </p>
    <p>
     例如一个项目中，部署时需要依赖于
     <code>
      node.js
     </code>
     、
     <code>
      Redis
     </code>
     、
     <code>
      RabbitMQ
     </code>
     、
     <code>
      MySQL
     </code>
     等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。
    </p>
    <h5>
     <a id="Docker_21">
     </a>
     Docker解决依赖兼容问题
    </h5>
    <p>
     Docker为了解决依赖的兼容问题的，采用了两个手段：
    </p>
    <ul>
     <li>
      <p>
       将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包
      </p>
     </li>
     <li>
      <p>
       将每个应用放到一个隔离
       <strong>
        容器
       </strong>
       去运行，避免互相干扰
      </p>
     </li>
    </ul>
    <p>
     <img alt="image-20230417003354608" src="https://i-blog.csdnimg.cn/img_convert/ffb64085ff20c40d5de1ec6b4eb5cad5.png"/>
    </p>
    <p>
     这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再在操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。
    </p>
    <p>
     虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？
    </p>
    <h5>
     <a id="Docker_35">
     </a>
     Docker解决操作系统环境差异
    </h5>
    <p>
     要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：
    </p>
    <p>
     <img alt="image-20230417003702318" src="https://i-blog.csdnimg.cn/img_convert/745d691a13da4e73e8f9951a388fb29e.png"/>
    </p>
    <p>
     结构包括：
    </p>
    <ul>
     <li>
      计算机硬件：例如CPU、内存、磁盘等
     </li>
     <li>
      系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以
      <strong>
       与计算机硬件交互
      </strong>
      ，对外提供
      <strong>
       内核指令
      </strong>
      ，用于操作计算机硬件。
     </li>
     <li>
      系统应用：将内核指令封装为函数，以便程序员调用，用户程序基于系统函数库实现功能。
     </li>
    </ul>
    <p>
     应用于计算机交互的流程如下：
    </p>
    <p>
     1）应用调用操作系统应用（函数库），实现各种功能
    </p>
    <p>
     2）系统函数库是对内核指令集的封装，会调用内核指令
    </p>
    <p>
     3）内核指令操作计算机硬件
    </p>
    <p>
     <code>
      Ubuntu
     </code>
     和
     <code>
      CentOS
     </code>
     都是基于Linux内核，无非是系统应用不同，提供的函数库有差异，此时，如果将一个
     <code>
      Ubuntu
     </code>
     版本的
     <code>
      MySQL
     </code>
     应用安装到
     <code>
      CentOS
     </code>
     系统，
     <code>
      MySQL
     </code>
     在调用
     <code>
      Ubuntu
     </code>
     函数库时，会发现找不到或者不匹配，就会报错了：
    </p>
    <p>
     <img alt="image-20230417003922992" src="https://i-blog.csdnimg.cn/img_convert/c839128f0a5a3f5bb89cebce5b4418de.png"/>
    </p>
    <p>
     Docker如何解决大型项目依赖关系复杂，不同组件
     <strong>
      依赖的兼容性问题
     </strong>
     ？
    </p>
    <ul>
     <li>
      Docker允许开发中将应用、依赖、函数库、配置一起
      <strong>
       打包
      </strong>
      ，形成可移植镜像
     </li>
     <li>
      Docker应用运行在容器中，使用沙箱机制，相互
      <strong>
       隔离
      </strong>
     </li>
    </ul>
    <p>
     Docker如何解决开发、测试、生产
     <strong>
      环境的差异问题
     </strong>
     ？
    </p>
    <ul>
     <li>
      Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包
     </li>
     <li>
      Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行
     </li>
    </ul>
    <p>
     <img alt="image-20230417004605198" src="https://i-blog.csdnimg.cn/img_convert/320b237856e4f604896fd2967f069d01.png"/>
    </p>
    <h5>
     <a id="Docker_71">
     </a>
     Docker与虚拟机的区别
    </h5>
    <p>
     Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。两者有什么差异呢？
    </p>
    <p>
     <strong>
      虚拟机
     </strong>
     （virtual machine）是在操作系统中
     <strong>
      模拟硬件设备
     </strong>
     ，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。而
     <strong>
      Docker
     </strong>
     仅仅是
     <strong>
      封装函数库
     </strong>
     ，并没有模拟完整的操作系统。
    </p>
    <p>
     <img alt="image-20230417011701180" src="https://i-blog.csdnimg.cn/img_convert/d40846bdb823b5de467cb6980af6a758.png"/>
    </p>
    <p>
     <img alt="image-20230417011730625" src="https://i-blog.csdnimg.cn/img_convert/75a1ab6273ea759c9d48595f854576c3.png"/>
    </p>
    <p>
     Docker和虚拟机的差异总结：
    </p>
    <ul>
     <li>
      <p>
       docker是一个
       <strong>
        系统进程
       </strong>
       ；虚拟机是在操作系统中的
       <strong>
        操作系统
       </strong>
      </p>
     </li>
     <li>
      <p>
       docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般。
      </p>
     </li>
    </ul>
    <h4>
     <a id="Docker_87">
     </a>
     Docker架构
    </h4>
    <h5>
     <a id="_89">
     </a>
     镜像和容器
    </h5>
    <p>
     Docker中有几个重要的概念：
    </p>
    <p>
     **镜像（**Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。
    </p>
    <p>
     <strong>
      容器（
      <strong>
       Container）：镜像中的
      </strong>
      应用程序运行后形成的进程
     </strong>
     就是容器，只是Docker会给容器做隔离，对外不可见。
    </p>
    <p>
     一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的
     <strong>
      文件
     </strong>
     。只有运行时，才会加载到内存，形成进程。
    </p>
    <p>
     <strong>
      镜像
     </strong>
     ，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的
     <strong>
      文件包
     </strong>
     ，这个文件包是
     <strong>
      只读
     </strong>
     的；
    </p>
    <p>
     <strong>
      容器
     </strong>
     ，就是将这些文件中编写的程序、函数加载到内存中运行，形成进程，只不过要隔离起来。因此
     <strong>
      一个镜像可以启动多次，形成多个容器进程
     </strong>
     。
    </p>
    <p>
     <img alt="image-20230417012159113" src="https://i-blog.csdnimg.cn/img_convert/c43bd6c3c3b4a359fa27f2b5fdf63fb3.png"/>
    </p>
    <p>
     例如你下载了一个QQ，如果我们将QQ在磁盘上的运行
     <strong>
      文件
     </strong>
     及其运行的操作系统依赖打包，形成QQ镜像。然后你就可以启动多次，双开、甚至三开。
    </p>
    <h5>
     <a id="DockerHub_107">
     </a>
     DockerHub
    </h5>
    <p>
     开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。
    </p>
    <ul>
     <li>
      DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。
     </li>
     <li>
      国内也有类似于DockerHub 的公开服务，比如
      <a href="https://c.163yun.com/hub" rel="nofollow">
       网易云镜像服务
      </a>
      、
      <a href="https://cr.console.aliyun.com/" rel="nofollow">
       阿里云镜像库
      </a>
      等。
     </li>
    </ul>
    <p>
     我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像。
    </p>
    <h5>
     <a id="Docker_116">
     </a>
     Docker架构
    </h5>
    <p>
     我们要使用Docker来操作镜像、容器，就必须要安装Docker。
    </p>
    <p>
     Docker是一个
     <strong>
      CS架构
     </strong>
     的程序，由两部分组成：
    </p>
    <ul>
     <li>
      <p>
       服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等
      </p>
     </li>
     <li>
      <p>
       客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。
      </p>
     </li>
    </ul>
    <p>
     <img alt="image-20230417012710083" src="https://i-blog.csdnimg.cn/img_convert/534c6f7fc064b1edd913156fe1a57450.png"/>
    </p>
    <h3>
     <a id="Docker_128">
     </a>
     使用Docker
    </h3>
    <h4>
     <a id="_130">
     </a>
     镜像相关命令
    </h4>
    <p>
     首先来看下镜像的名称组成：
    </p>
    <ul>
     <li>
      镜像名称一般分两部分组成：[repository]:[tag]。
     </li>
     <li>
      在没有指定tag时，默认是latest，代表最新版本的镜像
     </li>
    </ul>
    <p>
     <img alt="image-20230417222011354" src="https://i-blog.csdnimg.cn/img_convert/55a0e6085dcc1e1e5576879b0f9a0f64.png"/>
    </p>
    <p>
     这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。
    </p>
    <p>
     常见的镜像操作命令：
    </p>
    <pre><code class="prism language-powershell">docker images	<span class="token comment">#查看镜像</span>
docker rmi 		<span class="token comment">#删除镜像</span>
docker pull		<span class="token comment">#拉取</span>
docker push		<span class="token comment">#推送</span>
docker save 	<span class="token comment">#保存到文件</span>
docker load		<span class="token comment">#从文件加载</span>
</code></pre>
    <p>
     命令具体的参数可以使用
     <code>
      --help
     </code>
     查看。
    </p>
    <p>
     <img alt="image-20230417222046661" src="https://i-blog.csdnimg.cn/img_convert/6ad362bf2f5fe045e07e901b6796e595.png"/>
    </p>
    <h6>
     <a id="_156">
     </a>
     案例
    </h6>
    <p>
     从DockerHub中拉取一个nginx镜像并查看
    </p>
    <p>
     1）首先去镜像仓库搜索nginx镜像，比如
     <a href="https://hub.docker.com/" rel="nofollow">
      DockerHub
     </a>
     :
    </p>
    <p>
     <img alt="image-20230418220950978" src="https://i-blog.csdnimg.cn/img_convert/aff71dd51e4476b5aa44c72721661e49.png"/>
    </p>
    <p>
     2）根据查看到的镜像名称，通过命令：
     <code>
      docker pull nginx
     </code>
     ，拉取自己需要的镜像
    </p>
    <p>
     3）通过命令：
     <code>
      docker images
     </code>
     查看拉取到的镜像
    </p>
    <p>
     <img alt="image-20230418233303753" src="https://i-blog.csdnimg.cn/img_convert/9d629736855ea4809dc09bb408f47b41.png"/>
    </p>
    <p>
     利用
     <code>
      docker save
     </code>
     将nginx镜像导出磁盘，然后再通过
     <code>
      load
     </code>
     加载回来
    </p>
    <p>
     1）利用
     <code>
      docker xx --help
     </code>
     命令查看
     <code>
      docker save
     </code>
     和
     <code>
      docker load
     </code>
     的语法
    </p>
    <p>
     <img alt="image-20230418233533311" src="https://i-blog.csdnimg.cn/img_convert/d259663ea9acc9bce61d7edefc58f5bd.png"/>
    </p>
    <p>
     可以看到命令的格式为：
    </p>
    <pre><code class="prism language-shell"><span class="token comment">#docker save格式</span>
<span class="token function">docker</span> save <span class="token parameter variable">-o</span> <span class="token punctuation">[</span>保存的目标文件名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>

<span class="token comment">#docker load格式</span>
<span class="token function">docker</span> load <span class="token parameter variable">-i</span> <span class="token punctuation">[</span>加载的目标文件名称<span class="token punctuation">]</span>
</code></pre>
    <p>
     2）使用docker save导出镜像到磁盘
    </p>
    <p>
     运行命令：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> save <span class="token parameter variable">-o</span> nginx.tar nginx:latest
</code></pre>
    <p>
     <img alt="image-20230418233809012" src="https://i-blog.csdnimg.cn/img_convert/aa2813b84c5002f9d8a2b77188d04f9d.png"/>
    </p>
    <p>
     3）使用docker load加载镜像
    </p>
    <p>
     先删除本地的nginx镜像：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> rmi nginx:latest
</code></pre>
    <p>
     <img alt="image-20230418233938292" src="https://i-blog.csdnimg.cn/img_convert/191eea097bbbb4c5dc12a2a2c08063ab.png"/>
    </p>
    <p>
     然后运行命令，加载本地文件：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> load <span class="token parameter variable">-i</span> nginx.tar
</code></pre>
    <p>
     <img alt="image-20230418234126270" src="https://i-blog.csdnimg.cn/img_convert/c51bd3b593f5b82af040aaff3ff0b0c3.png"/>
    </p>
    <h4>
     <a id="_214">
     </a>
     容器相关命令
    </h4>
    <p>
     <img alt="image-20230418212831049" src="https://i-blog.csdnimg.cn/img_convert/55a5d32d291937a70d6727ab4a6a75e7.png"/>
    </p>
    <p>
     其中：
    </p>
    <ul>
     <li>
      <p>
       <code>
        docker run
       </code>
       ：创建并运行一个容器，处于运行状态
      </p>
      <ul>
       <li>
        常见参数：
        <ul>
         <li>
          <code>
           --name
          </code>
          ：指定容器名称
         </li>
         <li>
          <code>
           -p
          </code>
          ：指定端口映射
         </li>
         <li>
          <code>
           -d
          </code>
          ：让容器后台运行
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        docker pause
       </code>
       ：让一个运行的容器暂停
      </p>
     </li>
     <li>
      <p>
       <code>
        docker unpause
       </code>
       ：让一个容器从暂停状态恢复运行
      </p>
     </li>
     <li>
      <p>
       <code>
        docker stop
       </code>
       ：停止一个运行的容器
      </p>
     </li>
     <li>
      <p>
       <code>
        docker start
       </code>
       ：让一个停止的容器再次运行
      </p>
     </li>
     <li>
      <p>
       <code>
        docker rm
       </code>
       ：删除一个容器
      </p>
      <ul>
       <li>
        <p>
         <strong>
          不能删除运行中的容器，除非添加 -f 参数强制删除
         </strong>
        </p>
       </li>
       <li>
        <p>
         容器状态：
        </p>
        <ul>
         <li>
          运行：进程正常运行
         </li>
         <li>
          暂停：进程暂停，CPU不再运行，并不释放内存
         </li>
         <li>
          停止：进程终止，回收进程占用的内存、CPU等资源
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        docker logs
       </code>
       ：查看容器日志
      </p>
      <ul>
       <li>
        添加
        <code>
         -f
        </code>
        参数可以持续查看日志
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        docker ps
       </code>
       ：查看容器状态
      </p>
      <ul>
       <li>
        添加
        <code>
         -a
        </code>
        参数查看所有状态的容器
       </li>
      </ul>
     </li>
     <li>
      <p>
       <code>
        docker exec -it [容器名] [要执行的命令]
       </code>
      </p>
      <ul>
       <li>
        <code>
         exec
        </code>
        命令可以进入容器修改文件，PS：但是在容器内修改文件是
        <strong>
         不推荐
        </strong>
        的
       </li>
      </ul>
     </li>
    </ul>
    <h6>
     <a id="_248">
     </a>
     案例
    </h6>
    <p>
     创建并运行nginx容器的命令：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
</code></pre>
    <p>
     <img alt="image-20230419230008978" src="https://i-blog.csdnimg.cn/img_convert/b7bab92c94665f68054a7de27782b484.png"/>
    </p>
    <p>
     这里的
     <code>
      -p
     </code>
     参数，是将容器端口映射到宿主机端口。
    </p>
    <p>
     默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。
    </p>
    <p>
     现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：
    </p>
    <p>
     <img alt="image-20230419230108126" src="https://i-blog.csdnimg.cn/img_convert/528ec4963a178fabc37eaf72ca2e4438.png"/>
    </p>
    <h6>
     <a id="_266">
     </a>
     案例
    </h6>
    <p>
     进入Nginx容器，修改HTML文件内容，添加“Hello World!”
    </p>
    <p>
     1）进入我们刚刚创建的nginx容器的命令为：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> myniginx <span class="token function">bash</span>
</code></pre>
    <p>
     命令解读：
    </p>
    <ul>
     <li>
      <p>
       <code>
        docker exec
       </code>
       ：进入容器内部，执行一个命令
      </p>
     </li>
     <li>
      <p>
       <code>
        -it
       </code>
       : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互
      </p>
     </li>
     <li>
      <p>
       myniginx：要进入的容器的名称
      </p>
     </li>
     <li>
      <p>
       <code>
        bash
       </code>
       ：进入容器后执行的命令，bash是一个linux终端交互命令
      </p>
     </li>
    </ul>
    <p>
     2）进入nginx的HTML所在目录 /usr/share/nginx/html
    </p>
    <pre><code class="prism language-shell"><span class="token builtin class-name">cd</span> /usr/share/nginx/html
</code></pre>
    <p>
     容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样，nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件：
    </p>
    <p>
     <img alt="image-20230419231540211" src="https://i-blog.csdnimg.cn/img_convert/6e4fd213224c030914f81d04d5318d89.png"/>
    </p>
    <p>
     3）修改index.html的内容
    </p>
    <p>
     <strong>
      容器内没有vi命令
     </strong>
     ，无法直接修改，我们用下面的命令来修改：
    </p>
    <pre><code class="prism language-shell"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">'s#Welcome to nginx#Hello Wolrd!#g'</span> <span class="token parameter variable">-e</span> <span class="token string">'s#&lt;head&gt;#&lt;head&gt;&lt;meta charset="utf-8"&gt;#g'</span> index.html
</code></pre>
    <p>
     <img alt="image-20230419231651835" src="https://i-blog.csdnimg.cn/img_convert/607e735d5fc2ab784cb6d6b2f594b249.png"/>
    </p>
    <h4>
     <a id="volume_306">
     </a>
     数据卷(volume)
    </h4>
    <h5>
     <a id="_308">
     </a>
     容器与数据耦合的问题
    </h5>
    <p>
     在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。这就是因为容器与数据（容器内文件）耦合带来的后果。
    </p>
    <p>
     <img alt="image-20230419231924499" src="https://i-blog.csdnimg.cn/img_convert/71df8231b4de3dffab42e1783da896e6.png"/>
    </p>
    <p>
     要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。
    </p>
    <h5>
     <a id="_316">
     </a>
     什么是数据卷？
    </h5>
    <p>
     数据卷是一个
     <strong>
      虚拟目录
     </strong>
     ，指向宿主机文件系统中的某个目录。其作用是将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全
    </p>
    <p>
     <img alt="image-20230419232058611" src="https://i-blog.csdnimg.cn/img_convert/d681bfb4b0be7980e923016975f277e2.png"/>
    </p>
    <p>
     一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了
    </p>
    <h5>
     <a id="_324">
     </a>
     数据卷操作命令
    </h5>
    <p>
     数据卷操作的基本语法如下：
    </p>
    <pre><code class="prism language-shell"><span class="token function">docker</span> volume <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span>
</code></pre>
    <p>
     <code>
      docker volume
     </code>
     命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：
    </p>
    <ul>
     <li>
      <code>
       create
      </code>
      创建一个volume
     </li>
     <li>
      <code>
       inspect
      </code>
      显示一个或多个volume的信息
     </li>
     <li>
      <code>
       ls
      </code>
      列出所有的volume
     </li>
     <li>
      <code>
       prune
      </code>
      删除未使用的volume
     </li>
     <li>
      <code>
       rm
      </code>
      删除一个或多个指定的volume
     </li>
    </ul>
    <h6>
     <a id="_340">
     </a>
     案例
    </h6>
    <p>
     创建一个数据卷，并查看数据卷在宿主机的目录位置
    </p>
    <p>
     ① 创建数据卷
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> volume create html
</code></pre>
    <p>
     ② 查看所有数据
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> volume <span class="token function">ls</span>
</code></pre>
    <p>
     <img alt="image-20230419233237068" src="https://i-blog.csdnimg.cn/img_convert/4b65eb72edfcdd49e785a51043fe593d.png"/>
    </p>
    <p>
     ③ 查看数据卷详细信息卷
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> volume inspect html
</code></pre>
    <p>
     可以看到，我们创建的html这个数据卷关联的宿主机目录为
     <code>
      /var/lib/docker/volumes/html/_data
     </code>
     目录。
    </p>
    <p>
     <img alt="image-20230419233331232" src="https://i-blog.csdnimg.cn/img_convert/5df4b0f6799fb4dbcdd417270d3efeba.png"/>
    </p>
    <p>
     ④删除数据卷
    </p>
    <pre><code class="prism language-shell"><span class="token function">docker</span> volume prune		<span class="token comment">#删除未使用的数据卷</span>
<span class="token function">docker</span> volume <span class="token function">rm</span> 数据卷名称		<span class="token comment">#删除指定数据卷</span>
</code></pre>
    <h5>
     <a id="_375">
     </a>
     挂载数据卷
    </h5>
    <p>
     我们在创建容器时，可以通过
     <code>
      -v
     </code>
     参数来挂载一个数据卷到某个容器内目录，命令格式如下：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span> <span class="token parameter variable">-v</span> <span class="token punctuation">[</span>数据卷名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>目录<span class="token punctuation">]</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
例：
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> mynginx <span class="token parameter variable">-v</span> html:/root/html <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
</code></pre>
    <p>
     这里的
     <code>
      -v
     </code>
     就是挂载数据卷的命令：
    </p>
    <ul>
     <li>
      <code>
       -v html:/root/html
      </code>
      ：把html数据卷挂载到容器内的/root/html这个目录中，如果容器运行时
      <strong>
       volume不存在，会自动被创建出来
      </strong>
     </li>
    </ul>
    <h6>
     <a id="_389">
     </a>
     案例
    </h6>
    <p>
     创建一个nginx容器，修改容器内的html目录内的index.html内容
    </p>
    <p>
     <strong>
      分析
     </strong>
     ：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置
     <code>
      /usr/share/nginx/html
     </code>
     ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。
    </p>
    <p>
     <strong>
      提示
     </strong>
     ：运行容器时使用 -v 参数挂载数据卷
    </p>
    <p>
     步骤：
    </p>
    <p>
     ① 创建容器并挂载数据卷到容器内的HTML目录
    </p>
    <pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mn <span class="token parameter variable">-v</span> html:/usr/share/nginx/html <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx

<span class="token comment"># 查看html数据卷的位置</span>
<span class="token function">docker</span> volume inspect html
</code></pre>
    <p>
     <img alt="image-20240109210828430" src="https://i-blog.csdnimg.cn/img_convert/85a9391ee6802fee788a0ddbd111cf2e.png"/>
    </p>
    <p>
     ② 进入html数据卷所在位置，并修改HTML内容
    </p>
    <pre><code class="prism language-sh"><span class="token comment"># 进入该目录</span>
<span class="token builtin class-name">cd</span> /var/lib/docker/volumes/html/_data
<span class="token comment"># 修改文件</span>
<span class="token function">vi</span> index.html
</code></pre>
    <p>
     **注意：**我在Windows下的Ubuntu中不能直接进入到
     <code>
      /var/lib/docker/volumes/html/_data
     </code>
     这个目录
    </p>
    <p>
     <img alt="image-20240109210134122" src="https://i-blog.csdnimg.cn/img_convert/ff8d7e97e760b64cdc8b9c786b1ca6d2.png"/>
    </p>
    <p>
     根据网上的办法执行以下指令进入到vm内部：
    </p>
    <pre><code class="prism language-sh"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span> <span class="token parameter variable">--pid</span><span class="token operator">=</span>host debian nsenter <span class="token parameter variable">-t</span> <span class="token number">1</span> <span class="token parameter variable">-m</span> <span class="token parameter variable">-u</span> <span class="token parameter variable">-n</span> <span class="token parameter variable">-i</span> <span class="token function">sh</span>
</code></pre>
    <ul>
     <li>
      –privileged : 表示允许该容器访问宿主机中的各种设备
     </li>
     <li>
      –pid=host : 表示允许容器共享宿主机的进程命名空间（namespace），许容器看到宿主机中的各种进程
     </li>
     <li>
      nsenter : 是一个小工具 ns=namespace、enter=进入
     </li>
     <li>
      nsenter -t 1 -m -u -n -i sh
      <ul>
       <li>
        -t 1: 表示要进入哪个pid，1表示整个操作系统的主进程id
       </li>
       <li>
        -m: 进入mount namespace，挂载点
       </li>
       <li>
        -u: 进入UTS namespace
       </li>
       <li>
        -n: 进入network namespace，网络
       </li>
       <li>
        -i: 进入IPC namespace，进程间通信
       </li>
       <li>
        sh: 表示运行/bin/sh
       </li>
      </ul>
     </li>
    </ul>
    <p>
     <img alt="image-20240109210557980" src="https://i-blog.csdnimg.cn/img_convert/0add309b988e2317f79ba12bf3f27dec.png"/>
    </p>
    <p>
     <img alt="image-20240109211435230" src="https://i-blog.csdnimg.cn/img_convert/ff7580212debbef32aac0099b8643b14.png"/>
    </p>
    <p>
     <img alt="image-20240109213412925" src="https://i-blog.csdnimg.cn/img_convert/7f1b2ea5279d6fa5be68c3bb77756426.png"/>
    </p>
    <p>
     <img alt="image-20240109211517150" src="https://i-blog.csdnimg.cn/img_convert/df967ff743da41c1e5f42a0d38b95aa2.png"/>
    </p>
    <h5>
     <a id="_448">
     </a>
     挂载目录
    </h5>
    <p>
     【案例】创建并运行一个MySQL容器，将宿主机目录直接挂载到容器
    </p>
    <ul>
     <li>
      -v[宿主机目录]:[容器内目录]
     </li>
     <li>
      -v[宿主机文件]:[容器内文件]
     </li>
    </ul>
    <ol>
     <li>
      <p>
       导入
       <code>
        mysql
       </code>
       镜像
      </p>
     </li>
     <li>
      <p>
       创建目录
       <code>
        /tmp/mysql/data
       </code>
      </p>
     </li>
     <li>
      <p>
       创建目录
       <code>
        /tmp/mysql/conf
       </code>
       ，
       <code>
        hmy.cnf
       </code>
       文件上传到
       <code>
        /tmp/mysql/conf
       </code>
      </p>
     </li>
     <li>
      <p>
       去DockerHub查阅资料，创建并运行MySQL容器，要求：
      </p>
     </li>
    </ol>
    <p>
     ​ ①挂载
     <code>
      /tmp/mysql/data
     </code>
     到mysql容器内数据存储目录
    </p>
    <p>
     ​ ②挂载
     <code>
      /tmp/mysql/conf/hmy.cnf
     </code>
     到mysql容器的配置文件
    </p>
    <p>
     ​ ③设置MySQL密码
    </p>
    <pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mysql <span class="token punctuation">\</span>
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token punctuation">\</span>
<span class="token parameter variable">-p</span> <span class="token number">3307</span>:3306 <span class="token punctuation">\</span>
<span class="token parameter variable">-d</span> <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /tmp/mysql/conf:/etc/mysql/conf.d <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /tmp/mysql/data:/var/lib/mysql <span class="token punctuation">\</span>
mysql:latest
</code></pre>
    <p>
     <img alt="image-20240110111810047" src="https://i-blog.csdnimg.cn/img_convert/d2ebfb89d73622d522ee936782f96340.png"/>
    </p>
    <h5>
     <a id="_481">
     </a>
     数据卷挂载与目录直接挂载的区别
    </h5>
    <ul>
     <li>
      <p>
       数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找
      </p>
     </li>
     <li>
      <p>
       目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看
      </p>
     </li>
    </ul>
    <h3>
     <a id="Dockerfile_487">
     </a>
     Dockerfile自定义镜像
    </h3>
    <h4>
     <a id="_489">
     </a>
     镜像结构
    </h4>
    <p>
     镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。
    </p>
    <p>
     镜像是分层结构，每一层称为一个Layer
    </p>
    <ul>
     <li>
      <strong>
       BaseImage层
      </strong>
      ：包含基本的系统函数库、环境变量、文件系统；
     </li>
     <li>
      <strong>
       Entrypoint
      </strong>
      ：入口，是镜像中应用启动的命令；
     </li>
     <li>
      其它：在BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置。
     </li>
    </ul>
    <p>
     <img alt="image-20240110120144256" src="https://i-blog.csdnimg.cn/img_convert/5724a088d2bf148b13e4de2e689a8f1d.png"/>
    </p>
    <h4>
     <a id="Dockerfile_501">
     </a>
     Dockerfile
    </h4>
    <p>
     <strong>
      Dockerfile
     </strong>
     就是一个文本文件，其中包含一个个的
     <strong>
      指令(Instruction)
     </strong>
     ，用指令来说明要执行什么操作以此来构建镜像。每一个指令都会形成一层Layer。常用指令：
    </p>
    <table>
     <thead>
      <tr>
       <th>
        <strong>
         指令
        </strong>
       </th>
       <th>
        <strong>
         说明
        </strong>
       </th>
       <th>
        <strong>
         示例
        </strong>
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        FROM
       </td>
       <td>
        指定基础镜像
       </td>
       <td>
        FROM centos:6
       </td>
      </tr>
      <tr>
       <td>
        ENV
       </td>
       <td>
        设置环境变量
       </td>
       <td>
        ENV key value
       </td>
      </tr>
      <tr>
       <td>
        COPY
       </td>
       <td>
        拷贝本地文件到镜像的指定目录
       </td>
       <td>
        COPY ./mysql-5.7.rpm /tmp
       </td>
      </tr>
      <tr>
       <td>
        RUN
       </td>
       <td>
        执行Linux的shell命令，一般是安装过程的命令
       </td>
       <td>
        RUN yum install gcc
       </td>
      </tr>
      <tr>
       <td>
        EXPOSE
       </td>
       <td>
        指定容器运行时监听的端口，是给镜像使用者看的
       </td>
       <td>
        EXPOSE 8080
       </td>
      </tr>
      <tr>
       <td>
        ENTRYPOINT
       </td>
       <td>
        镜像中应用的启动命令，容器运行时调用
       </td>
       <td>
        ENTRYPOINT java -jar xx.jar
       </td>
      </tr>
     </tbody>
    </table>
    <p>
     更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder
    </p>
    <p>
     注意：
    </p>
    <ul>
     <li>
      <p>
       Dockerfile的本质是一个文件，通过指令描述镜像的构建过程；
      </p>
     </li>
     <li>
      <p>
       Dockerfile第一行必须是FROM，从一个基础镜像来构建;
      </p>
     </li>
     <li>
      <p>
       基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine。
      </p>
     </li>
    </ul>
    <h4>
     <a id="Java_524">
     </a>
     构建Java项目
    </h4>
    <h5>
     <a id="_526">
     </a>
     基本步骤
    </h5>
    <ol>
     <li>
      <p>
       新建一个空文件夹
       <code>
        docker-demo
       </code>
       ，并将
       <code>
        docker-demo.jar
       </code>
       、
       <code>
        jdk8.tar.gz
       </code>
       和
       <code>
        Dockerfile
       </code>
       拷贝到该目录下。
       <code>
        Dockerfile
       </code>
       文件内容：
      </p>
      <pre><code class="prism language-shell"><span class="token comment"># 指定基础镜像</span>
FROM ubuntu:16.04
<span class="token comment"># 配置环境变量，JDK的安装目录</span>
ENV <span class="token assign-left variable">JAVA_DIR</span><span class="token operator">=</span>/usr/local
  
<span class="token comment"># 拷贝jdk</span>
COPY ./jdk8.tar.gz <span class="token variable">$JAVA_DIR</span>/
  
<span class="token comment"># 安装JDK</span>
RUN <span class="token builtin class-name">cd</span> <span class="token variable">$JAVA_DIR</span> <span class="token punctuation">\</span>
 <span class="token operator">&amp;&amp;</span> <span class="token function">tar</span> <span class="token parameter variable">-xf</span> ./jdk8.tar.gz <span class="token punctuation">\</span>
 <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> ./jdk1.8.0_144 ./java8
  
<span class="token comment"># 配置环境变量</span>
ENV <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span><span class="token variable">$JAVA_DIR</span>/java8
ENV <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin

<span class="token comment">#########################以上步骤都是在安装jdk############################</span>

<span class="token comment">#Java项目包</span>
COPY ./docker-demo.jar /tmp/app.jar
<span class="token comment"># 暴露端口</span>
EXPOSE <span class="token number">8090</span>
<span class="token comment"># 入口，java项目的启动命令</span>
ENTRYPOINT <span class="token function">java</span> <span class="token parameter variable">-jar</span> /tmp/app.jar
</code></pre>
     </li>
     <li>
      <p>
       运行命令：
      </p>
     </li>
    </ol>
    <pre><code class="prism language-shell"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> javaweb:1.0 <span class="token builtin class-name">.</span>
</code></pre>
    <h5>
     <a id="openjdk8alpine_564">
     </a>
     基于openjdk:8-alpine
    </h5>
    <p>
     基于openjdk:8-alpine镜像，将一个Java项目构建为镜像
    </p>
    <p>
     实现思路如下：
    </p>
    <ol>
     <li>
      <p>
       新建一个空的目录，然后在目录中新建一个文件，命名为
       <code>
        Dockerfile
       </code>
      </p>
     </li>
     <li>
      <p>
       拷贝
       <code>
        docker-demo.jar
       </code>
       到这个目录中
      </p>
     </li>
     <li>
      <p>
       编写
       <code>
        Dockerfile
       </code>
       文件：
      </p>
      <pre><code class="prism language-dockerfile"># 指定基础镜像
FROM openjdk:8-alpine

# 将docker-demo.jar拷贝到镜像中
COPY ./docker-demo.jar /tmp/app.jar

# 暴露端口
EXPOSS 8090
# 入口，Java项目的启动命令
ENTRYPOINT java -jar /tmp/app.jar
</code></pre>
     </li>
     <li>
      <p>
       使用
       <code>
        docker build
       </code>
       命令构建镜像
      </p>
      <p>
       <img alt="image-20240111204536437" src="https://i-blog.csdnimg.cn/img_convert/e52b081a44ac665d381e186f70a6cb8d.png"/>
      </p>
     </li>
     <li>
      <p>
       使用
       <code>
        docker run
       </code>
       创建容器并运行
      </p>
      <p>
       <img alt="image-20240111204742870" src="https://i-blog.csdnimg.cn/img_convert/c665aacd32240c24d5466a6a3cb9f2da.png"/>
      </p>
     </li>
     <li>
      <p>
       访问成功
      </p>
      <p>
       <img alt="image-20240111204801886" src="https://i-blog.csdnimg.cn/img_convert/db30a65d0cff6bf5a96535ddf419c223.png"/>
      </p>
     </li>
    </ol>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f672e:6373646e2e6e65742f77656978696e5f34343332303432392f:61727469636c652f64657461696c732f313436323137353334" class_="artid" style="display:none">
 </p>
</div>


