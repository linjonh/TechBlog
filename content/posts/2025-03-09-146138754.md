---
layout: post
title: "unordered_set-的常用函数"
date: 2025-03-09 21:06:04 +0800
description: "在 C++ 的标准库中，是基于哈希表实现的哈希集合。下面介绍这种语言里哈希集合的常用函数。"
keywords: "unordered_set 的常用函数"
categories: ['未分类']
tags: ['算法', '数据结构', '哈希算法']
artid: "146138754"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146138754
    alt: "unordered_set-的常用函数"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146138754
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146138754
cover: https://bing.ee123.net/img/rand?artid=146138754
image: https://bing.ee123.net/img/rand?artid=146138754
img: https://bing.ee123.net/img/rand?artid=146138754
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     unordered_set 的常用函数
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
    </p>
    <p>
     在 C++ 的标准库中，
     <code>
      std::unordered_set
     </code>
     是基于哈希表实现的哈希集合。下面介绍这种语言里哈希集合的常用函数。
    </p>
    <h4>
     C++
     <code>
      std::unordered_set
     </code>
    </h4>
    <h5>
     1. 元素操作
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        insert
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：向哈希集合中插入元素。如果元素已经存在，则不会重复插入。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset;
    uset.insert(1);
    uset.insert(2);
    for (auto num : uset) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        erase
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：从哈希集合中移除指定元素。可以通过元素值或者迭代器来指定要移除的元素。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset = {1, 2, 3};
    uset.erase(2);
    for (auto num : uset) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        find
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：查找指定元素。如果找到，返回指向该元素的迭代器；如果未找到，返回
        <code>
         end()
        </code>
        迭代器。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset = {1, 2, 3};
    auto it = uset.find(2);
    if (it != uset.end()) {
        std::cout &lt;&lt; "Found: " &lt;&lt; *it &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Not found" &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        count
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：统计指定元素在哈希集合中的数量。由于哈希集合中元素唯一，返回值要么是 0（元素不存在），要么是 1（元素存在）。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset = {1, 2, 3};
    std::cout &lt;&lt; "Count of 2: " &lt;&lt; uset.count(2) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <h5>
     2. 容量相关
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        empty
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：检查哈希集合是否为空。如果为空，返回
        <code>
         true
        </code>
        ；否则返回
        <code>
         false
        </code>
        。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset;
    std::cout &lt;&lt; "Is empty: " &lt;&lt; (uset.empty() ? "Yes" : "No") &lt;&lt; std::endl;
    uset.insert(1);
    std::cout &lt;&lt; "Is empty: " &lt;&lt; (uset.empty() ? "Yes" : "No") &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        size
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：返回哈希集合中元素的数量。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset = {1, 2, 3};
    std::cout &lt;&lt; "Size: " &lt;&lt; uset.size() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        max_size
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：返回哈希集合所能容纳的最大元素数量，这取决于系统和库的实现。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset;
    std::cout &lt;&lt; "Max size: " &lt;&lt; uset.max_size() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <h5>
     3. 迭代器相关
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        begin
       </code>
       和
       <code>
        end
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：
        <code>
         begin()
        </code>
        返回指向哈希集合首元素的迭代器，
        <code>
         end()
        </code>
        返回指向哈希集合尾后位置的迭代器，可用于遍历哈希集合。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset = {1, 2, 3};
    for (auto it = uset.begin(); it != uset.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        cbegin
       </code>
       和
       <code>
        cend
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：与
        <code>
         begin()
        </code>
        和
        <code>
         end()
        </code>
        类似，但返回的是常量迭代器，不能用于修改元素。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    const std::unordered_set&lt;int&gt; uset = {1, 2, 3};
    for (auto it = uset.cbegin(); it != uset.cend(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    return 0;
}</code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     在 C++ 中，标准库提供了基于哈希表实现的容器
     <code>
      std::unordered_map
     </code>
     （存储键值对）和
     <code>
      std::unordered_set
     </code>
     （存储单一元素），下面详细介绍它们除了前面提到之外的常见函数和用法。
    </p>
    <h4>
     <code>
      std::unordered_map
     </code>
    </h4>
    <h5>
     元素操作类
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        emplace
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：原位构造元素并插入到
        <code>
         unordered_map
        </code>
        中。与
        <code>
         insert
        </code>
        不同，
        <code>
         emplace
        </code>
        可以直接使用构造函数的参数来构造元素，避免了临时对象的创建和拷贝。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap;
    umap.emplace(1, "one");
    for (const auto&amp; pair : umap) {
        std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        emplace_hint
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：与
        <code>
         emplace
        </code>
        类似，但可以提供一个迭代器作为插入位置的提示，帮助提高插入效率。不过，这只是一个提示，插入位置不一定就是该迭代器所指的位置。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap = {<!-- -->{1, "one"}, {2, "two"}};
    auto hint = umap.begin();
    umap.emplace_hint(hint, 3, "three");
    for (const auto&amp; pair : umap) {
        std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        extract
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：从
        <code>
         unordered_map
        </code>
        中提取一个元素，将其从容器中移除，但保留其资源，可用于后续的插入操作。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap = {<!-- -->{1, "one"}, {2, "two"}};
    auto node = umap.extract(1);
    if (node) {
        node.key() = 3;
        umap.insert(std::move(node));
    }
    for (const auto&amp; pair : umap) {
        std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
    <h5>
     容量相关类
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        reserve
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：为
        <code>
         unordered_map
        </code>
        预留一定数量的桶（bucket），避免在插入元素时频繁进行哈希表的扩容操作，从而提高插入效率。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap;
    umap.reserve(100);
    for (int i = 0; i &lt; 50; ++i) {
        umap[i] = std::to_string(i);
    }
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        rehash
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：设置
        <code>
         unordered_map
        </code>
        的桶数量。如果指定的桶数量小于当前元素数量，可能会导致哈希表重新哈希以适应新的桶数量。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap = {<!-- -->{1, "one"}, {2, "two"}};
    umap.rehash(10);
    return 0;
}
</code></pre>
    <h5>
     哈希策略相关类
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        load_factor
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：返回
        <code>
         unordered_map
        </code>
        当前的负载因子，即元素数量与桶数量的比值。负载因子过高可能会导致哈希冲突增加，影响性能。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap = {<!-- -->{1, "one"}, {2, "two"}};
    std::cout &lt;&lt; "Load factor: " &lt;&lt; umap.load_factor() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        max_load_factor
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：可以设置或获取
        <code>
         unordered_map
        </code>
        的最大负载因子。当负载因子超过最大负载因子时，哈希表会自动进行扩容。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main() {
    std::unordered_map&lt;int, std::string&gt; umap;
    umap.max_load_factor(0.5);
    std::cout &lt;&lt; "Max load factor: " &lt;&lt; umap.max_load_factor() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <h4>
     <code>
      std::unordered_set
     </code>
    </h4>
    <p>
    </p>
    <p>
     <code>
      std::unordered_set
     </code>
     的很多函数和用法与
     <code>
      std::unordered_map
     </code>
     类似，以下是一些额外的特点和示例：
    </p>
    <h5>
     元素操作类
    </h5>
    <p>
    </p>
    <ul>
     <li>
      <strong>
       <code>
        emplace
       </code>
       和
       <code>
        emplace_hint
       </code>
      </strong>
      <ul>
       <li>
        <strong>
         功能
        </strong>
        ：与
        <code>
         unordered_map
        </code>
        中的
        <code>
         emplace
        </code>
        和
        <code>
         emplace_hint
        </code>
        类似，用于原位构造元素并插入到
        <code>
         unordered_set
        </code>
        中。
       </li>
       <li>
        <strong>
         示例代码
        </strong>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <p>
    </p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; uset;
    uset.emplace(1);
    auto hint = uset.begin();
    uset.emplace_hint(hint, 2);
    for (const auto&amp; num : uset) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>
    <h5>
     容量和哈希策略相关类
    </h5>
    <p>
    </p>
    <p>
     <code>
      unordered_set
     </code>
     同样支持
     <code>
      reserve
     </code>
     、
     <code>
      rehash
     </code>
     、
     <code>
      load_factor
     </code>
     和
     <code>
      max_load_factor
     </code>
     等函数，用法与
     <code>
      unordered_map
     </code>
     一致，用于管理容量和哈希策略。
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343032373836302f:61727469636c652f64657461696c732f313436313338373534" class_="artid" style="display:none">
 </p>
</div>


