---
layout: post
title: "android-进程间通信"
date: 2024-03-05 15:24:41 +0800
description: "本文探讨了Android中几种进程间通信方式，如管道、信号、信号量、共享内存、消息队列、socket"
keywords: "android进程间通信"
categories: ['Framework', 'Android']
tags: ['Android']
artid: "136344114"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=136344114
    alt: "android-进程间通信"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=136344114
featuredImagePreview: https://bing.ee123.net/img/rand?artid=136344114
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     android 进程间通信
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p id="main-toc">
     <strong>
      android 进程间通信
     </strong>
    </p>
    <p id="android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;">
     <a href="#android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">
      android进程间通信的几种方式
     </a>
    </p>
    <p id="%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%90%84%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:0px;">
     <a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%90%84%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">
      进程间通信各方式的优缺点
     </a>
    </p>
    <p id="%C2%A0binder%E4%BC%98%E5%8A%BF%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;">
     <a href="#%C2%A0binder%E4%BC%98%E5%8A%BF%E8%AF%B4%E6%98%8E" rel="nofollow">
      binder优势说明
     </a>
    </p>
    <p id="Binder%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;">
     <a href="#Binder%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86" rel="nofollow">
      Binder运行的机制原理
     </a>
    </p>
    <hr id="hr-toc"/>
    <p>
    </p>
    <h2 id="android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">
     android进程间通信的几种方式
    </h2>
    <p>
     <strong>
      管道
     </strong>
    </p>
    <p>
     管道是单向的，管道一端连接着进程的输出，进程把数据放入管道，另一端连接进程的输入，进程从管道获取数据。实现数据通信。
    </p>
    <p>
     <strong>
      信号
     </strong>
    </p>
    <p>
     信号类似于通知，进程通过sigaction注册接收的信号，执行响应函数。
    </p>
    <p>
     <strong>
      信号量+共享内存
     </strong>
    </p>
    <p>
     信号量类似一个计数器，用来控制多个进程对共享资源的访问， 会有一个&gt;0的初始值，每当有进程申请使用信号量，信号量就会-1，当减到0的时候，其他进程想要访问，就必须等待，当进程执行完工作后，会释放信号量，进行+1操作。
    </p>
    <p>
     共享内存是一段物理内存，可以供给不同的进程访问。但是多个进程共享同一块区域，就会造成同时修改的问题，所以需要其他的机制来同步对共享空间的访问，如信号量。
    </p>
    <p>
     <strong>
      消息队列
     </strong>
    </p>
    <p>
     消息队列是一个消息的链表，存放在内核中并由消息队列标识符标识。比如说handler。
    </p>
    <p>
     <strong>
      socket
     </strong>
    </p>
    <p>
     socket是将应用层数据从一个进程拷贝到另一个进程。zygote进程就是通过LocalSocket接收启动应用进程的通知。
    </p>
    <p>
     <strong>
      binder
     </strong>
    </p>
    <p>
     binder更多的用在system_server进程与上层APP层的IPC交互。Intent、ContentpProvier、Messager、Broadcast、AIDL等都是基于Binder机制完成的跨进程通信。
    </p>
    <h2 id="%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%90%84%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">
     进程间通信各方式的优缺点
    </h2>
    <p>
     管道：缓存区大小比较有限，一般为4k，只能传输无格式字节流。拷贝2次；
    </p>
    <p>
     信号：不适用信息交换，更适用于进程中断控制。比如非法内存访问，杀死某个进程等。单向。
    </p>
    <p>
     信号量：常作为锁机制。
    </p>
    <p>
     共享内存：无需复制，可直接修改，速度快，同步问题需要同步工具解决。
    </p>
    <p>
     消息队列：信息复制2次，额外的cpu小号，不适合频繁或信息量大的通信；拷贝2次；
    </p>
    <p>
     socket：作为更通用的接口，传输效率低；拷贝2次；
    </p>
    <p>
     binder:拷贝一次，但是身份标记有内核中添加，无法被篡改，因此更安全。c/s架构，稳定性好
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px;">
     <tbody>
      <tr>
       <td>
        IPC方式
       </td>
       <td>
        性能（拷贝次数）
       </td>
      </tr>
      <tr>
       <td>
        管道
       </td>
       <td>
        2
       </td>
      </tr>
      <tr>
       <td>
        信号
       </td>
       <td>
        2
       </td>
      </tr>
      <tr>
       <td>
        信号量+共享内存
       </td>
       <td>
        0
       </td>
      </tr>
      <tr>
       <td>
        消息队列
       </td>
       <td>
        2
       </td>
      </tr>
      <tr>
       <td>
        socket
       </td>
       <td>
        2
       </td>
      </tr>
      <tr>
       <td>
        binder
       </td>
       <td>
        1
       </td>
      </tr>
     </tbody>
    </table>
    <h2 id="%C2%A0binder%E4%BC%98%E5%8A%BF%E8%AF%B4%E6%98%8E">
     binder优势说明
    </h2>
    <p>
     <strong>
      1. 性能方面
     </strong>
    </p>
    <p>
     拷贝数据需要花时间,Binder只需拷贝一次，共享内存无需拷贝，其他的需要拷贝两次。
    </p>
    <p>
     从速度上来说，Binder仅次于共享内存，优于Socket，消息队列，管道，信号，信号量等。
    </p>
    <p>
     <strong>
      2. 特点方面
     </strong>
    </p>
    <p>
     Binder：
    </p>
    <p>
     基于C/S 架构，易用性高。
    </p>
    <p>
     共享内存：
    </p>
    <p>
     多个进程共享同一块内存区域，必然需要某种同步机制。
    </p>
    <p>
     使用麻烦，容易出现数据不同步，死锁等问题。
    </p>
    <p>
     Socket：
    </p>
    <p>
     socket作为一款通用接口，其传输效率低，开销大。
    </p>
    <p>
     主要用在跨网络的进程间通信和本机上进程间的低速通信。
    </p>
    <p>
     <strong>
      3. 安全性方面
     </strong>
    </p>
    <p>
     Binder：
    </p>
    <p>
     (安全性高) 为每个APP分配不同UID，通过UID鉴别进程身份。
    </p>
    <p>
     即支持实名Binder，又支持匿名Binder。
    </p>
    <p>
     传统IPC：
    </p>
    <p>
     (不安全) 完全依赖上层协议，只能由用户在数据包中填入UID/PID。
    </p>
    <p>
     访问接入点是开放的，任何程序都可以与其建立连接。
    </p>
    <table border="1" cellpadding="1" cellspacing="1" style="width:500px;">
     <tbody>
      <tr>
       <td>
        优势
       </td>
       <td>
        描述
       </td>
      </tr>
      <tr>
       <td>
        性能
       </td>
       <td>
        拷贝一次，仅次于共享内存
       </td>
      </tr>
      <tr>
       <td>
        稳定性
       </td>
       <td>
        基于C/S架构，职责明确，架构清晰
       </td>
      </tr>
      <tr>
       <td>
        安全性
       </td>
       <td>
        为每个APP分配UID，进程的UID就是进程身份的重要标志，无法被篡改
       </td>
      </tr>
     </tbody>
    </table>
    <h2 id="Binder%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86">
     Binder运行的机制原理
    </h2>
    <p>
     模块具有独立功能的程序，它可以单独被编译，但是不能独立运行，它在运行时被链接到内核作为内核的一部分运行。这样Android系统就可以通过动态添加一个内核模块运行在内核空间。这就是动态内核可加载模块（Loadable Kernel Module, LKM）。
    </p>
    <p>
     这个运行在内核空间，负责用户进程通过binder实现通信的内核模块就叫Binder驱动（Binder Driver）。
    </p>
    <p>
     1、binder驱动在内核空间创建一个数据接收缓存区，和接收进程用户空间地址建立内存映射关系。
    </p>
    <p>
     2、继续在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系。
    </p>
    <p>
     3、发送方进程将数据拷贝到内核中的内核缓存区，通过映射关系，相当于把数据发送到了接收进程用户空间。这样就相当于完成了一次进程间的通信。
    </p>
    <p>
     <img alt="" height="464" src="https://i-blog.csdnimg.cn/blog_migrate/3636ee7edc9ccd17919ead504121a146.png" width="642">
      <br/>
     </img>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a:2f2f626c6f672e6373646e2e6e65742f616e6875696c65652f:61727469636c652f64657461696c732f313336333434313134" class_="artid" style="display:none">
 </p>
</div>


