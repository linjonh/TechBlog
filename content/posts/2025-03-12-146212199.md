---
layout: post
title: "SpringMVC"
date: 2025-03-12 19:05:36 +0800
description: "1.过滤器:要实现Filter接口,在doFilter方法中写过滤操作,用chain.doFilter方法放行请求传递给下一个过滤器或目标资源,要写@WebFilter注解2.拦截器:自定义拦截器实现HandlerInterceptor接口,重写三个方法,配置拦截器实现WebMvcConfigurer(),重写addInterceptors()方法,传入自定义的拦截器1.自定义注解​。"
keywords: "SpringMVC"
categories: ['未分类']
tags: ['Spring', 'Java', 'Boot']
artid: "146212199"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146212199
    alt: "SpringMVC"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146212199
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146212199
cover: https://bing.ee123.net/img/rand?artid=146212199
image: https://bing.ee123.net/img/rand?artid=146212199
img: https://bing.ee123.net/img/rand?artid=146212199
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     SpringMVC
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <table>
     <thead>
      <tr>
       <th>
        组件
       </th>
       <th>
        作用
       </th>
       <th>
        在 Spring MVC 中的对应部分
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         Model（模型）
        </strong>
       </td>
       <td>
        负责数据处理、业务逻辑
       </td>
       <td>
        Service 层 + DAO 层（数据库交互）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         View（视图）
        </strong>
       </td>
       <td>
        负责页面显示
       </td>
       <td>
        <code>
         HTML
        </code>
        、
        <code>
         JSP
        </code>
        、
        <code>
         Thymeleaf
        </code>
        、
        <code>
         JSON
        </code>
        （REST API）
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         Controller（控制器）
        </strong>
       </td>
       <td>
        负责处理用户请求
       </td>
       <td>
        <code>
         @Controller
        </code>
        或
        <code>
         @RestController
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <h2>
     SpringMVC
    </h2>
    <h3>
     1.请求处理
    </h3>
    <h4>
     1.@RequestMapping
    </h4>
    <p>
     作用:将HTTP请求映射到特定的类或方法上,帮助开发者灵活地定义处理HTTP请求的路径和行为
    </p>
    <pre><code class="language-java">@RestController
@RequestMapping("/api")
public class MyController {
​
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, world!";
    }
}
​</code></pre>
    <h5>
     请求限定属性:
    </h5>
    <h6>
     1.method:
    </h6>
    <p>
     指定支持的HTTP请求方法(GET,POST)等
    </p>
    <h6>
     2.headers:
    </h6>
    <p>
     限制请求头必须包含请求头或请求头的值
    </p>
    <pre><code class="language-java">@RequestMapping(value = "/test", headers = "Content-Type=application/json")
public String handleWithHeader() {
    return "Handled request with application/json header";
}
限定请求头包含Content-Type=application/json
</code></pre>
    <h6>
     3.params:
    </h6>
    <p>
     限定请求参数
    </p>
    <p>
    </p>
    <h4>
     2.@RequestBody
    </h4>
    <p>
     是Spring框架中的一个注解，用于将HTTP请求的请求体映射到Java对象中。这个注解通常用于接收客户端发送的JSON或XML数据
    </p>
    <pre><code class="language-java">@PostMapping("/example")
public ResponseEntity&lt;String&gt; processRequest(@RequestBody MyRequestBody myRequestBody) {
    // 处理从请求体中获取的数据
    return ResponseEntity.ok("数据处理成功！");
}
@RequestBody注解会自动将请求体中的JSON数据转换成MyRequestBody对象</code></pre>
    <h4>
     3.@RequestParam
    </h4>
    <p>
     @RequestParam 是 Spring 框架中的一个注解，用于将 HTTP 请求中的参数绑定到控制器方法的参数上。它是处理 GET 或 POST 请求中请求参数的一种常用方式
    </p>
    <pre><code class="language-java">@RequestMapping("/handle02")
    public String handle02(@RequestParam("username") String name, @RequestParam("password") String pwd){
        System.out.println("username = " + name);
        System.out.println("password = " + pwd);
        return "ok";
    }通过注解获取同名参数并返回</code></pre>
    <h5>
     请求限定属性:
    </h5>
    <h6>
     1.value:
    </h6>
    <p>
     就是默认值,填参数名称
    </p>
    <h6>
     2.required
    </h6>
    <p>
     默认值是
     <span style="background-color:#fe2c24">
      true
     </span>
     若填写required = false则是声明参数可以不存在
    </p>
    <h6>
     3.defaultValue:
    </h6>
    <p>
     添加参数的默认值,
     <span style="color:#ffd900">
      同样也意味着可以不传参数
     </span>
    </p>
    <h4>
     4.@RequestHeader
    </h4>
    <p>
     @RequestHeader 是 Spring 框架中的一个注解，用于将 HTTP 请求头中的参数绑定到控制器方法的参数上。从而让我们可以获取请求头的值
    </p>
    <p>
     请求限定属性和上面的一样
    </p>
    <h5>
     5.@CookieValue:
    </h5>
    <p>
     获取特定Cookie值
    </p>
    <h4>
     使用POJO级联封装请求参数
    </h4>
    <p>
     工作原理:
    </p>
    <p>
     SpringMVC 会自动从请求参数（如 URL 查询参数
     <code>
      ?name=Wanyan&amp;age=25
     </code>
     或表单提交的数据）中提取值。
    </p>
    <p>
     如果请求中的参数名称与 POJO 的属性名称一致，SpringMVC 会将这些值绑定到对象的对应属性上。
    </p>
    <pre><code class="language-java">写一个POJO类Person 定义属性
@Data//主要依赖Setter和toString方法
public class Person {
    private String username;
    private String password;
    private String cellphone;
    private boolean agreement;
    private String grade;
    private Address address;
    private String[] hobby;
    private String sex;
​
    @Data
    public static
    class Address {
        private String province;
        private String city;
        private String area;
    }
}
@RequestMapping("/handle06")
    public String handle06(Person person){
        System.out.println(person);
        return "ok";
    }</code></pre>
    <h4>
     使用@RequestBody封装数据
    </h4>
    <h5>
     1.确保前端发送JSON数据
    </h5>
    <pre><code class="language-java">{
    "name": "Wanyan",
    "age": 25
}</code></pre>
    <h5>
     2.创建对应的java类(POJO)
    </h5>
    <pre>   </pre>
    <pre><code class="language-java"> @RequestMapping("/handle07")
    public String handle07(@RequestBody Person person){//将Http请求的参数映射到pojo实体类中
        System.out.println(person);
        return "ok";
    }</code></pre>
    <p>
     @RequestBody主要是用来应对复杂场景,接受客户端发送的JSON格式的请求数据
    </p>
    <h4>
     使用HttpEntity封装原始请求
    </h4>
    <pre><code class="language-java">@RestController
@RequestMapping("/example")
public class ExampleController {
​
    @PostMapping("/process")
    public ResponseEntity&lt;String&gt; processRequest(HttpEntity&lt;String&gt; httpEntity) {
        // 获取请求头
        HttpHeaders headers = httpEntity.getHeaders();
        System.out.println("Headers: " + headers);
​
        // 获取请求体
        String body = httpEntity.getBody();
        System.out.println("Body: " + body);
​
        return ResponseEntity.ok("Request processed successfully!");
    }
}</code></pre>
    <h3>
     2.响应处理
    </h3>
    <h4>
     1.返回Json数据
    </h4>
    <pre><code class="language-java">@RestController
@RequestMapping("/example")
public class ExampleController {
​
    @GetMapping("/person")
    public Person getPerson() {
        Person person = new Person();
        person.setName("Wanyan");
        person.setAge(25);
        return person; // 自动转换为 JSON
    }
}</code></pre>
    <h4>
     2.文件下载
    </h4>
    <pre><code class="language-java">@RequestMapping("/download")
    public ResponseEntity&lt;InputStreamResource&gt; download() throws Exception {
        FileInputStream fileInputStream = new FileInputStream("C:\\Users\\chinaliao\\Documents\\微信图片_20240813134707.jpg");
        byte[] bytes = fileInputStream.readAllBytes();
​
        //1.文件名中文会乱码,解决:
        String encode = URLEncoder.encode("haaj.jpg","UTF-8");
//       2.文件太大会oom(内存溢出)
​
        InputStreamResource resource = new InputStreamResource(fileInputStream);
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .contentLength(fileInputStream.available())
                // 告诉浏览器, 下载的文件名
                .header("Content-Disposition", "attachment;filename=haaj.jpg")
                .body(resource);
    }</code></pre>
    <p>
    </p>
    <h3>
     RESTful案例
    </h3>
    <h4>
     CRUD操作(增删改查)
    </h4>
    <blockquote>
     <p>
      1.创建操作数据库的DAO接口
     </p>
     <p>
      2.实现DAO接口,执行查询,插入,更新和删除等方法
     </p>
     <p>
      3.创建Service层,调用DAO层完成数据库操作,可以整合多个DAO
     </p>
     <p>
      4.创建Controler层,接受用户请求,调用Service层完成具体业务,与前端交互
     </p>
     <hr/>
     <p>
      分层的好处
     </p>
     <p>
      1.DAO:将数据库操作集中在这一层,可以避免在控制层中编写复杂的擦汗寻SQL与疾病,保持代码的清晰性
     </p>
     <p>
      2.Service:业务逻辑和数据访问分离,便于业务逻辑的独立开发和测试
     </p>
     <p>
      3.Controller:接受响应,验证等操作,增强了模块化
     </p>
     <p>
      4.总结:分层操作实现了松耦合,代码复用,拓展性强等优点
     </p>
     <p>
     </p>
    </blockquote>
    <h3>
     拦截器
    </h3>
    <h4>
     1.拦截器的工作流程
    </h4>
    <p>
     拦截器通过实现 Spring 的
     <code>
      HandlerInterceptor
     </code>
     接口，并覆盖以下三个方法来实现：
    </p>
    <ol>
     <li>
      <p>
       <code>
        preHandle()
       </code>
       ：在目标方法执行之前进行处理。如果返回
       <code>
        false
       </code>
       ，请求将被拦截，不会继续往后执行。
      </p>
     </li>
     <li>
      <p>
       <code>
        postHandle()
       </code>
       ：在目标方法执行后，但在渲染视图之前执行，用于操作返回数据。
      </p>
     </li>
     <li>
      <p>
       <code>
        afterCompletion()
       </code>
       ：在完成整个请求后执行（包括视图的渲染），可以进行清理工作等。
      </p>
     </li>
    </ol>
    <p>
     <code>
      preHandle()
     </code>
     <strong>
      按注册顺序执行
     </strong>
    </p>
    <p>
     <code>
      postHandle()
     </code>
     和
     <code>
      afterCompletion()
     </code>
     <strong>
      按注册顺序的反向执行
     </strong>
    </p>
    <p>
     <code>
      preHandle()
     </code>
     <strong>
      返回
      <code>
       false
      </code>
      ，后续拦截器和 Controller 不执行
     </strong>
    </p>
    <p>
     <code>
      afterCompletion()
     </code>
     <strong>
      总会执行（即使
      <code>
       preHandle()
      </code>
      返回
      <code>
       false
      </code>
      ）
     </strong>
    </p>
    <p>
     <code>
      order()
     </code>
     <strong>
      可以调整拦截器的优先级
     </strong>
    </p>
    <h4>
     2.多拦截器的执行顺序
    </h4>
    <h6>
     正常执行
    </h6>
    <p>
     <img alt="" height="417" src="https://i-blog.csdnimg.cn/direct/b9d7439db4df4871a8796cb5903b941a.png" width="2135"/>
    </p>
    <h6>
     拦截器的preHandler()返回false
    </h6>
    <p>
     <img alt="" height="711" src="https://i-blog.csdnimg.cn/direct/7b5ec1452c0e4aa9ab0b51c65c9282fc.png" width="1429"/>
    </p>
    <h4>
     3.拦截器和过滤器的区别
    </h4>
    <h5>
     1.定义方式:
    </h5>
    <p>
     1.过滤器:
    </p>
    <p>
     要实现Filter接口,在doFilter方法中写过滤操作,用chain.doFilter方法放行请求传递给下一个过滤器或目标资源,要写@WebFilter注解
    </p>
    <p>
     2.拦截器:
    </p>
    <p>
     自定义拦截器实现HandlerInterceptor接口,重写三个方法,配置拦截器实现WebMvcConfigurer(),重写addInterceptors()方法,传入自定义的拦截器
    </p>
    <h5>
     2.执行时机不同
    </h5>
    <p>
     过滤器：在请求进入容器后、到达Servlet之前执行；响应时在Servlet处理完后执行。
    </p>
    <p>
     拦截器：在请求进入框架的控制器之前、之后或渲染视图前后执行，控制更贴近业务逻辑。
    </p>
    <h3>
     异常处理
    </h3>
    <h4>
     1.局部异常处理
    </h4>
    <p>
     <strong>
      <code>
       @ExceptionHandler
      </code>
      （局部异常处理）
     </strong>
    </p>
    <p>
     通常声明在Controller内部
    </p>
    <pre><code class="language-java">import org.springframework.web.bind.annotation.*;
​
@RestController
@RequestMapping("/test")
public class TestController {
​
    @GetMapping("/exception")
    public String exceptionTest() {
        if (true) {
            throw new IllegalArgumentException("参数错误");
        }
        return "正常返回";
    }
​
    @ExceptionHandler(IllegalArgumentException.class)
    public String handleIllegalArgumentException(IllegalArgumentException e) {
        return "捕获到异常：" + e.getMessage();
    }
}</code></pre>
    <h4>
     2.全局异常处理
    </h4>
    <p>
     <code>
      @ControllerAdvice
     </code>
     +
     <code>
      @ExceptionHandler
     </code>
     对项目的所有Handler生效
    </p>
    <pre><code class="language-java">import org.springframework.web.bind.annotation.*;
​
@RestControllerAdvice
public class GlobalExceptionHandler {
​
    @ExceptionHandler(IllegalArgumentException.class)
    public String handleIllegalArgumentException(IllegalArgumentException e) {
        return "【全局】参数错误：" + e.getMessage();
    }
​
    @ExceptionHandler(Exception.class)
    public String handleException(Exception e) {
        return "【全局】服务器异常：" + e.getMessage();
    }
}</code></pre>
    <p>
     为了让异常信息统一,我们定义一个Common类来返回异常信息
    </p>
    <pre><code class="language-java">@Data
public class R&lt;T&gt; {
    private Integer code;
    private String msg;
    private T data;
    public static&lt;T&gt; R&lt;T&gt; ok(T data){
        R r = new R&lt;&gt;();
        r.setCode(200);
        r.setMsg("ok");
        r.setData(data);
        return r;
    }
    public static R ok(){
        R r = new R&lt;&gt;();
        r.setCode(200);
        r.setMsg("ok");
        return r;
    }
    public static&lt;T&gt; R&lt;T&gt; error(Integer code,String msg,Object data){
        R r = new R&lt;&gt;();
        r.setCode(code);
        r.setMsg(msg);
        r.setData(data);
        return r;
    }</code></pre>
    <p>
     把异常处理的返回值变成R就可以返回
    </p>
    <p>
    </p>
    <h3>
     SpringMVC - 数据校验
    </h3>
    <ol>
     <li>
      <p>
       导入校验包
      </p>
     </li>
     <li>
      <p>
       编写校验注解
      </p>
     </li>
     <li>
      <p>
       使用 @Valid 告诉SpringMVC进行校验
      </p>
     </li>
     <li>
      <p>
       编写一个全局异常处理器来处理校验异常
      </p>
     </li>
    </ol>
    <p>
     前端发来的数据,通常不能完全相信,要通过spring-boot-starter-validation中的约束注解来验证字符串或者集合
    </p>
    <p>
     <code>
      @NotNull
     </code>
     : 用于校验字段是否为空(只有null)
    </p>
    <p>
     ✅
     <code>
      "John"
     </code>
     （通过） ❌
     <code>
      null
     </code>
     （不通过） ✅
     <code>
      ""
     </code>
     （通过）
    </p>
    <p>
     <code>
      @NotEmpty
     </code>
     : 既用于校验字段是否为空,也检查长度是否大于零
    </p>
    <p>
     ✅
     <code>
      "John"
     </code>
     （通过） ❌
     <code>
      null
     </code>
     （不通过） ❌
     <code>
      ""
     </code>
     （不通过） ✅
     <code>
      " "
     </code>
     （通过，因为长度大于 0）
    </p>
    <p>
     <code>
      @NotBlank
     </code>
     :仅适用于字符串类型,会把空格去掉在判断是否为空
    </p>
    <p>
     ✅
     <code>
      "John"
     </code>
     （通过） ❌
     <code>
      null
     </code>
     （不通过） ❌
     <code>
      ""
     </code>
     （不通过） ❌
     <code>
      " "
     </code>
     （不通过，因为去掉空格后为空）
    </p>
    <h4>
     <strong>
      1. 数值约束
     </strong>
    </h4>
    <table>
     <thead>
      <tr>
       <th>
        约束注解
       </th>
       <th>
        作用
       </th>
       <th>
        适用类型
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <code>
         @Positive
        </code>
       </td>
       <td>
        必须为正数（
        <code>
         &gt;0
        </code>
        ）
       </td>
       <td>
        <code>
         int
        </code>
        、
        <code>
         long
        </code>
        、
        <code>
         double
        </code>
        、
        <code>
         BigDecimal
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @PositiveOrZero
        </code>
       </td>
       <td>
        必须为正数或零（
        <code>
         &gt;=0
        </code>
        ）
       </td>
       <td>
        同上
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @Negative
        </code>
       </td>
       <td>
        必须为负数（
        <code>
         &lt;0
        </code>
        ）
       </td>
       <td>
        同上
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @NegativeOrZero
        </code>
       </td>
       <td>
        必须为负数或零（
        <code>
         &lt;=0
        </code>
        ）
       </td>
       <td>
        同上
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @Min(value)
        </code>
       </td>
       <td>
        必须
        <strong>
         ≥
         <code>
          value
         </code>
        </strong>
       </td>
       <td>
        数字类型
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @Max(value)
        </code>
       </td>
       <td>
        必须
        <strong>
         ≤
         <code>
          value
         </code>
        </strong>
       </td>
       <td>
        数字类型
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @DecimalMin(value, inclusive = true/false)
        </code>
       </td>
       <td>
        必须
        <strong>
         大于等于/大于
         <code>
          value
         </code>
        </strong>
       </td>
       <td>
        <code>
         BigDecimal
        </code>
        、
        <code>
         double
        </code>
        、
        <code>
         float
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @DecimalMax(value, inclusive = true/false)
        </code>
       </td>
       <td>
        必须
        <strong>
         小于等于/小于
         <code>
          value
         </code>
        </strong>
       </td>
       <td>
        同上
       </td>
      </tr>
      <tr>
       <td>
        <code>
         @Digits(integer, fraction)
        </code>
       </td>
       <td>
        限制整数和小数的位数
       </td>
       <td>
        <code>
         BigDecimal
        </code>
        、
        <code>
         double
        </code>
        、
        <code>
         float
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <thead>
      <tr>
       <th>
        约束类别
       </th>
       <th>
        主要注解
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <strong>
         通用
        </strong>
       </td>
       <td>
        <code>
         @NotNull
        </code>
        、
        <code>
         @NotEmpty
        </code>
        、
        <code>
         @NotBlank
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         数值
        </strong>
       </td>
       <td>
        <code>
         @Min
        </code>
        、
        <code>
         @Max
        </code>
        、
        <code>
         @Positive
        </code>
        、
        <code>
         @Negative
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         字符串
        </strong>
       </td>
       <td>
        <code>
         @Size
        </code>
        、
        <code>
         @Pattern
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         日期时间
        </strong>
       </td>
       <td>
        <code>
         @Past
        </code>
        、
        <code>
         @Future
        </code>
       </td>
      </tr>
      <tr>
       <td>
        <strong>
         特殊格式
        </strong>
       </td>
       <td>
        <code>
         @Email
        </code>
        、
        <code>
         @UUID
        </code>
       </td>
      </tr>
     </tbody>
    </table>
    <h4>
     2.自定义校验器
    </h4>
    <pre><code class="language-java">1.自定义注解
    import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;
​
@Documented
@Constraint(validatedBy = {MyCustomValidator.class}) // 指定校验器
@Target({ElementType.FIELD, ElementType.METHOD}) // 作用范围：字段或方法
@Retention(RetentionPolicy.RUNTIME) // 运行时生效
public @interface MyCustomConstraint {
    String message() default "字段不符合要求"; // 自定义错误消息
    Class&lt;?&gt;[] groups() default {}; // 分组校验
    Class&lt;? extends Payload&gt;[] payload() default {}; // 负载信息
}
2. 实现ContraintValidator接口
    import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
​
public class MyCustomValidator implements ConstraintValidator&lt;MyCustomConstraint, String&gt; {
    
    @Override
    public void initialize(MyCustomConstraint constraintAnnotation) {
        // 初始化逻辑（通常不需要）
    }
​
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // 这里自定义校验逻辑，比如判断字符串是否只包含字母
        return value != null &amp;&amp; value.matches("^[a-zA-Z]+$");
    }
}
3. 创建实体类在要校验的数据上写自定义注解
4.在Controller中使用 @Valid 或 @Validated 触发校验。
5.在全局异常中统一处理    </code></pre>
    <p>
    </p>
    <h3>
     接口文档
    </h3>
    <h4>
     1.定义
    </h4>
    <p>
     <strong>
      接口文档
     </strong>
     （API 文档）是用于描述
     <strong>
      系统提供的接口
     </strong>
     的详细说明文档。它主要用于前后端或系统之间的对接，确保不同团队可以正确理解和调用接口。
    </p>
    <h4>
     2.使用Swagger自动生成API文档
    </h4>
    <p>
     1.添加依赖
    </p>
    <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
    &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;  &lt;!-- 适用于 Spring Boot 3.x --&gt;
&lt;/dependency&gt;</code></pre>
    <p>
     2.编写controller类
    </p>
    <pre><code class="language-java">import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.*;
​
@RestController
@RquestMapping("/user")
@Tag(name = "用户管理", description = "用户相关接口") // 分组名称
public class UserController {
​
    @PostMapping("/create")
    @Operation(summary = "创建用户", description = "用于创建新用户")
    public String createUser(@RequestBody UserDTO userDTO) {
        return "用户创建成功：" + userDTO.getUsername();
    }
​
    @GetMapping("/{userId}")
    @Operation(summary = "查询用户", description = "根据用户ID查询用户信息")
    public String getUser(@PathVariable int userId) {
        return "用户：" + userId;
    }
}</code></pre>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430325f38363537373136322f:61727469636c652f64657461696c732f313436323132313939" class_="artid" style="display:none">
 </p>
</div>


