---
layout: post
title: "redis五种数据类型和编码方式"
date: 2025-03-09 11:06:20 +0800
description: "JavaStringJavaHashMapJavaListJavaSetmemberscoreRedis 底层在实现上述数据结构的时候，会在源码层面，针对上述实现进行特定优化，来达到节省时间/节省空间的效果RedisO1hash。"
keywords: "【redis】五种数据类型和编码方式"
categories: ['Redis']
tags: ['缓存', '数据库', 'Redis']
artid: "146129016"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146129016
    alt: "redis五种数据类型和编码方式"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146129016
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146129016
cover: https://bing.ee123.net/img/rand?artid=146129016
image: https://bing.ee123.net/img/rand?artid=146129016
img: https://bing.ee123.net/img/rand?artid=146129016
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【redis】五种数据类型和编码方式
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-light" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <p>
    </p>
    <p>
    </p>
    <h2>
     <a id="_2">
     </a>
     五种数据类型
    </h2>
    <p>
     <img alt="image.png" src="https://i-blog.csdnimg.cn/img_convert/04dc50a6eebf65b6bb923010b6380a58.png"/>
    </p>
    <ul>
     <li>
      字符串：
      <code>
       Java
      </code>
      中的
      <code>
       String
      </code>
     </li>
     <li>
      哈希：
      <code>
       Java
      </code>
      中的
      <code>
       HashMap
      </code>
     </li>
     <li>
      列表：
      <code>
       Java
      </code>
      中的
      <code>
       List
      </code>
     </li>
     <li>
      集合：
      <code>
       Java
      </code>
      中的
      <code>
       Set
      </code>
     </li>
     <li>
      有序集合：除了存
      <code>
       member
      </code>
      之外，还有权重
      <code>
       score
      </code>
      （权重、分数）
     </li>
    </ul>
    <p>
     Redis 底层在实现上述数据结构的时候，会在源码层面，针对上述实现进行特定优化，来达到节省时间/节省空间的效果
    </p>
    <ul>
     <li>
      内部具体实现的数据结构还会有变化
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       <code>
        Redis
       </code>
       向你承诺，现在我有个 hash 表，你进行查询、插入、删除操作，都保证时间复杂度是
       <span class="katex--inline">
        <span class="katex">
         <span class="katex-mathml">
          O 
          
         
           ( 
          
         
           1 
          
         
           ) 
          
         
        
          O(1)
         </span>
         <span class="katex-html">
          <span class="base">
           <span class="strut" style="height: 1em; vertical-align: -0.25em;">
           </span>
           <span class="mord mathnormal" style="margin-right: 0.0278em;">
            O
           </span>
           <span class="mopen">
            (
           </span>
           <span class="mord">
            1
           </span>
           <span class="mclose">
            )
           </span>
          </span>
         </span>
        </span>
       </span>
      </li>
      <li>
       但是，这个背后的实现，不一定就是一个标准的
       <code>
        hash
       </code>
       表，可能在特定的场景下，使用别的数据结构实现，但是仍然保证时间复杂度符合承诺
      </li>
     </ul>
    </blockquote>
    <h2>
     <a id="_23">
     </a>
     编码方式
    </h2>
    <ul>
     <li>
      <strong>
       数据结构
      </strong>
      ：Redis 承诺给你的，也可以理解成
      <strong>
       数据类型
      </strong>
     </li>
     <li>
      <strong>
       编码方式
      </strong>
      ：Redis 内部底层的实现
      <br/>
      同一个
      <strong>
       数据类型
      </strong>
      ，背后可能的编码实现方式是不同的，会根据特定场景优化
     </li>
    </ul>
    <h3>
     <a id="string_29">
     </a>
     string
    </h3>
    <ul>
     <li>
      <code>
       string
      </code>
      ：
      <code>
       Redis
      </code>
      会自动适应，程序员在使用
      <code>
       Redis
      </code>
      的时候一般感知不到
      <ul>
       <li>
        <code>
         raw
        </code>
        ：最基本的字符串。底层就是持有
        <code>
         byte
        </code>
        数组
       </li>
       <li>
        <code>
         int
        </code>
        ：
        <code>
         Redis
        </code>
        通常也可以用来实现“
        <strong>
         计数
        </strong>
        ”这样的功能（帖子的点赞数，评论数…）。当
        <code>
         value
        </code>
        就是一个整数的时候，此时可能
        <code>
         Redis
        </code>
        直接使用
        <code>
         int
        </code>
        来保存
       </li>
       <li>
        <code>
         embstr
        </code>
        ：针对短字符串进行的特殊优化
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="hash_35">
     </a>
     hash
    </h3>
    <ul>
     <li>
      <code>
       hash
      </code>
      <ul>
       <li>
        <code>
         hashtable
        </code>
        ：最基本的哈希表（这里是
        <code>
         Redis
        </code>
        内部的哈希表的实现，和
        <code>
         Java
        </code>
        标准库中的
        <code>
         HashTable
        </code>
        不一样）
       </li>
       <li>
        <code>
         ziplist
        </code>
        ：压缩列表，针对一些特殊的场景下，将数据进一步压缩，从而减少空间（在哈希表里面的元素较少的时候，可能就优化成
        <code>
         ziplist
        </code>
        了）
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <p>
      [!quote] 为什么要压缩？为什么是元素少的时候才压缩？
     </p>
     <ul>
      <li>
       <code>
        Redis
       </code>
       上有很多
       <code>
        key
       </code>
       ，可能某些
       <code>
        key
       </code>
       的
       <code>
        value
       </code>
       是
       <code>
        hash
       </code>
       。此时，如果
       <code>
        key
       </code>
       特别多，对应的
       <code>
        hash
       </code>
       也特别多，但是每个
       <code>
        hash
       </code>
       又不大的情况下，就尽量去压缩，压缩之后就可以让整体占用的内存更小了
      </li>
      <li>
       压缩是一种优化措施，但在大量数据的情况下，压缩和解压会增加额外的计算开销。元素较多时，
       <code>
        Redis
       </code>
       通常会自动将存储方式从
       <code>
        ziplist
       </code>
       转为
       <code>
        hashtable
       </code>
       等更高效的存储方式，以避免在大量数据操作时发生性能瓶颈。
      </li>
     </ul>
    </blockquote>
    <h3>
     <a id="list_45">
     </a>
     list
    </h3>
    <ul>
     <li>
      <code>
       list
      </code>
      <ul>
       <li>
        <code>
         linkedlist
        </code>
        ：链表：非常方便从中间位置查找删除
       </li>
       <li>
        <code>
         ziplist
        </code>
        ：压缩列表（和
        <code>
         hash
        </code>
        里面的一样）
       </li>
      </ul>
     </li>
    </ul>
    <blockquote>
     <ul>
      <li>
       从
       <code>
        Redis 3.2
       </code>
       开始，引入了新的实现方式：
       <code>
        quicklist
       </code>
       。其同时兼顾了
       <code>
        linkedlist
       </code>
       和
       <code>
        ziplist
       </code>
       的优点。
      </li>
      <li>
       <code>
        quicklist
       </code>
       就是一个链表，每个元素又是一个
       <code>
        ziplist
       </code>
      </li>
     </ul>
    </blockquote>
    <h3>
     <a id="set_54">
     </a>
     set
    </h3>
    <ul>
     <li>
      <code>
       set
      </code>
      <ul>
       <li>
        <code>
         hashtable
        </code>
       </li>
       <li>
        <code>
         intset
        </code>
        ：集合中存的都是整数，就会被优化成
        <code>
         intset
        </code>
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="zset_61">
     </a>
     zset
    </h3>
    <ul>
     <li>
      <code>
       zset
      </code>
      <ul>
       <li>
        <code>
         skiplist
        </code>
        ：
        <strong>
         跳表
        </strong>
        ，其也是链表，只是不同于普通的链表。每个节点上有多个指针域，巧妙地搭配这些指针域的指向，就可以做到从跳表上查询元素的复杂度是
        <span class="katex--inline">
         <span class="katex">
          <span class="katex-mathml">
           O 
           
          
            ( 
           
          
            l 
           
          
            o 
           
          
            g 
           
          
            N 
           
          
            ) 
           
          
         
           O(logN)
          </span>
          <span class="katex-html">
           <span class="base">
            <span class="strut" style="height: 1em; vertical-align: -0.25em;">
            </span>
            <span class="mord mathnormal" style="margin-right: 0.0278em;">
             O
            </span>
            <span class="mopen">
             (
            </span>
            <span class="mord mathnormal" style="margin-right: 0.0197em;">
             l
            </span>
            <span class="mord mathnormal">
             o
            </span>
            <span class="mord mathnormal" style="margin-right: 0.0359em;">
             g
            </span>
            <span class="mord mathnormal" style="margin-right: 0.109em;">
             N
            </span>
            <span class="mclose">
             )
            </span>
           </span>
          </span>
         </span>
        </span>
        （类似于平衡二叉搜索树（如 AVL 树、红黑树））
       </li>
       <li>
        <code>
         ziplist
        </code>
        ：
       </li>
      </ul>
     </li>
    </ul>
    <h3>
     <a id="_68">
     </a>
     查询内部编码
    </h3>
    <p>
     <strong>
      语法：
     </strong>
    </p>
    <pre><code class="prism language-redis">object encoding 
</code></pre>
    <p>
     <img alt="image.png|348" src="https://i-blog.csdnimg.cn/img_convert/5494be5d069148c76ce970a70b885dd8.png"/>
    </p>
    <p>
     <code>
      Redis
     </code>
     会自动根据当前的事迹情况选择内部的编码方式，自动适应。那我们是否要记住，什么时候使用什么编码方式呢？
    </p>
    <ul>
     <li>
      只记思想，不记数字！
     </li>
    </ul>
    <blockquote>
     <p>
      网上的说法：如果字符串长度小于
      <em>
       39
      </em>
      字节，使用
      <code>
       embstr
      </code>
      ，超过
      <em>
       39
      </em>
      字节，使用
      <code>
       raw
      </code>
     </p>
     <ul>
      <li>
       记数字，没有任何意义
      </li>
      <li>
       数字都是可配置的
      </li>
      <li>
       数字是怎么来的？需要考证清楚
      </li>
      <li>
       相比于知道数字，更重要的是知道数字是怎么得到的，就可以根据所处的实际场景，重新得到这样的数字
      </li>
     </ul>
    </blockquote>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470:733a2f2f626c6f672e6373646e2e6e65742f5965656561722f:61727469636c652f64657461696c732f313436313239303136" class_="artid" style="display:none">
 </p>
</div>


