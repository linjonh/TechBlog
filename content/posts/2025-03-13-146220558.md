---
layout: post
title: "第三百七十五节-JavaFX教程-JavaFX表视图"
date: 2025-03-13 04:58:49 +0800
description: "第三百七十五节 JavaFX教程 - JavaFX表视图"
keywords: "第三百七十五节 JavaFX教程 - JavaFX表视图"
categories: ['Java']
tags: ['算法', '服务器', '数据结构', '数据库', '前端', 'Javascript', 'Java']
artid: "146220558"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146220558
    alt: "第三百七十五节-JavaFX教程-JavaFX表视图"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146220558
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146220558
cover: https://bing.ee123.net/img/rand?artid=146220558
image: https://bing.ee123.net/img/rand?artid=146220558
img: https://bing.ee123.net/img/rand?artid=146220558
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     第三百七十五节 JavaFX教程 - JavaFX表视图
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     JavaFX教程 - JavaFX表视图
    </h3>
    <p>
    </p>
    <p>
     我们可以使用来自
     <code>
      JavaFX API
     </code>
     的
     <code>
      TableView
     </code>
     ，
     <code>
      TableColumn
     </code>
     和
     <code>
      TableCell
     </code>
     类以表格形式表示数据。
    </p>
    <p>
     通过实现数据模型和应用单元工厂来填充表中的数据。
    </p>
    <p>
     表类可以按列排序数据，并在必要时调整列大小。
    </p>
    <h3 id="Creating_a_Table">
     创建表
    </h3>
    <p>
     表控件是通过实例化
     <code>
      TableView
     </code>
     类创建的。
    </p>
    <pre><code>TableView table = new TableView();
table.setEditable(true);
</code></pre>
    <p>
     然后使用
     <code>
      TableColumn
     </code>
     类创建三个列。
     <code>
      TableView
     </code>
     类的
     <code>
      getColumns
     </code>
     方法将创建的列添加到表中。
    </p>
    <pre><code>TableColumn firstNameCol = new TableColumn("First Name");
TableColumn lastNameCol = new TableColumn("Last Name");
TableColumn emailCol = new TableColumn("Email");
        
table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
</code></pre>
    <p>
     我们可以通过调用
     <code>
      setVisible
     </code>
     方法隐藏列。
    </p>
    <pre><code>aColumn.setVisible(false).
</code></pre>
    <p>
     以下代码创建一个表。
    </p>
    <pre><code>import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class Main extends Application {
  public static void main(String[] args) {
    launch(args);
  }
  @Override
  public void start(Stage primaryStage) {
    TableView table = new TableView();
    table.setEditable(true);

    TableColumn firstNameCol = new TableColumn("First Name");
    TableColumn lastNameCol = new TableColumn("Last Name");
    TableColumn emailCol = new TableColumn("Email");
            
    table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
    emailCol.setVisible(false);

    StackPane root = new StackPane();
    root.getChildren().add(table);
    primaryStage.setScene(new Scene(root, 200, 250));
    primaryStage.show();
  }
}
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="288" src="https://i-blog.csdnimg.cn/img_convert/3e7f52e0db4c3f26876241152eeecd16.png" width="216"/>
    </p>
    <h3 id="Nested_Header">
     嵌套标头
    </h3>
    <p>
     使用
     <code>
      JavaFX
     </code>
     表视图，我们可以轻松创建嵌套列。
    </p>
    <p>
     假设我们要将两个子列添加到地址列。
    </p>
    <pre><code>TableColumn cityCol = new TableColumn("City");
TableColumn stateCol = new TableColumn("State");
</code></pre>
    <p>
     然后我们将新创建的列添加到地址列。
    </p>
    <pre><code>addressCol.getColumns().addAll(cityCol, stateCol);
</code></pre>
    <p>
     完整的源代码
    </p>
    <pre><code>import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class Main extends Application {
  public static void main(String[] args) {
    launch(args);
  }
  @Override
  public void start(Stage primaryStage) {
    TableView table = new TableView();
    table.setEditable(true);

    TableColumn firstNameCol = new TableColumn("First Name");
    TableColumn lastNameCol = new TableColumn("Last Name");
    TableColumn addressCol = new TableColumn("Email");
            
    table.getColumns().addAll(firstNameCol, lastNameCol, addressCol);

    TableColumn cityCol = new TableColumn("City");
    TableColumn stateCol = new TableColumn("State");

    addressCol.getColumns().addAll(cityCol, stateCol);
    
    StackPane root = new StackPane();
    root.getChildren().add(table);
    primaryStage.setScene(new Scene(root, 200, 250));
    primaryStage.show();
  }
}
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="288" src="https://i-blog.csdnimg.cn/img_convert/8f690973d4285fcd9e5570aad14a76d9.png" width="354"/>
    </p>
    <h3 id="Add_New_Rows">
     添加新行
    </h3>
    <p>
     以下代码显示如何向表视图中添加数据。 创建
     <code>
      JavaFX JavaBean
     </code>
     以保存单个行的值。 表中的每一行代表一个名字为姓氏的人。
     <code>
      JavaFX JavaBean
     </code>
     称为
     <code>
      Person
     </code>
     ，它有两个字段，名字和姓氏。
     <code>
      Person
     </code>
     为这两个值提供了可绑定的属性。
    </p>
    <p>
     在
     <code>
      UI
     </code>
     逻辑中，它使用
     <code>
      ObservableList
     </code>
     来保存表视图的值。
     <code>
      ObservableList
     </code>
     中的每个元素都是一个
     <code>
      Person
     </code>
     对象。
    </p>
    <p>
     在按钮事件处理程序中，它创建一个新的具有硬编码的名字和姓氏的人，然后添加到
     <code>
      ObservableList
     </code>
     。
    </p>
    <pre><code>import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class Main extends Application {
 
    private final TableView&lt;Person&gt; table = new TableView&lt;&gt;();
    private final ObservableList&lt;Person&gt; data =
            FXCollections.observableArrayList(new Person("A", "B"));
    final HBox hb = new HBox();
 
    public static void main(String[] args) {
        launch(args);
    }
 
    @Override
    public void start(Stage stage) {
        Scene scene = new Scene(new Group());
        stage.setWidth(450);
        stage.setHeight(550);
 
 
        TableColumn firstNameCol = new TableColumn("First Name");
        firstNameCol.setMinWidth(100);
        firstNameCol.setCellValueFactory(
                new PropertyValueFactory&lt;&gt;("firstName"));
 
        TableColumn lastNameCol = new TableColumn("Last Name");
        lastNameCol.setMinWidth(100);
        lastNameCol.setCellValueFactory(
                new PropertyValueFactory&lt;&gt;("lastName"));
 
        table.setItems(data);
        table.getColumns().addAll(firstNameCol, lastNameCol);
 
        final Button addButton = new Button("Add");
        addButton.setOnAction((ActionEvent e) -&gt; {
            data.add(new Person("Z","X"));
         });
 
        hb.getChildren().addAll(addButton);
        hb.setSpacing(3);
 
        final VBox vbox = new VBox();
        vbox.setSpacing(5);
        vbox.setPadding(new Insets(10, 0, 0, 10));
        vbox.getChildren().addAll(table, hb);
 
        ((Group) scene.getRoot()).getChildren().addAll(vbox);
 
        stage.setScene(scene);
        stage.show();
    }
 
    public static class Person {
 
        private final SimpleStringProperty firstName;
        private final SimpleStringProperty lastName;
 
        private Person(String fName, String lName) {
            this.firstName = new SimpleStringProperty(fName);
            this.lastName = new SimpleStringProperty(lName);
        }
 
        public String getFirstName() {
            return firstName.get();
        }
 
        public void setFirstName(String fName) {
            firstName.set(fName);
        }
 
        public String getLastName() {
            return lastName.get();
        }
 
        public void setLastName(String fName) {
            lastName.set(fName);
        }
    }
} 
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="495" src="https://i-blog.csdnimg.cn/img_convert/68d74bfd014eb704fb556fa8e13e31e1.png" width="280"/>
    </p>
    <h3 id="TableView_Columns_Sort">
     <code>
      TableView
     </code>
     列排序
    </h3>
    <p>
     <code>
      TableView
     </code>
     类具有列的内置排序功能。
    </p>
    <p>
     我们可以通过点击列标题对数据进行排序。第一次单击启用升序排序，第二次点击使得排序顺序降序，第三个点击禁用排序。
    </p>
    <p>
     默认情况下，不应用排序。
    </p>
    <p>
     我们可以排序多个列，并在排序操作中指定每个列的优先级。
    </p>
    <p>
     要对多个列进行排序，请在按住
     <code>
      Shift
     </code>
     键的同时单击列标题。
    </p>
    <p>
     我们可以使用
     <code>
      setSortType
     </code>
     方法设置排序首选项我们可以指定升序或降序类型。
    </p>
    <p>
     以下代码设置排序的降序类型
    </p>
    <pre><code>aColumn.setSortType(TableColumn.SortType.DESCENDING);
</code></pre>
    <p>
     我们可以通过从
     <code>
      TableView.sortOrder observable
     </code>
     列表中添加和删除
     <code>
      TableColumn
     </code>
     实例来指定要排序的列。
    </p>
    <p>
     <code>
      TableView.sortOrder observable
     </code>
     列中的列的顺序表示排序优先级。 列表中零索引的项目的优先级高于列表中的第一个项目。
    </p>
    <p>
     要禁止对列进行排序，请调用该列上的
     <code>
      setSortable(false)
     </code>
     方法。
    </p>
    <pre><code>import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class Main extends Application {
 
    private final TableView&lt;Person&gt; table = new TableView&lt;&gt;();
    private final ObservableList&lt;Person&gt; data =
            FXCollections.observableArrayList(new Person("A", "B"),
                new Person("D", "E"));

 
    public static void main(String[] args) {
        launch(args);
    }
 
    @Override
    public void start(Stage stage) {
        Scene scene = new Scene(new Group());
        stage.setWidth(450);
        stage.setHeight(550);
 
 
        TableColumn firstNameCol = new TableColumn("First Name");
        firstNameCol.setMinWidth(100);
        firstNameCol.setCellValueFactory(
                new PropertyValueFactory&lt;&gt;("firstName"));
 
        TableColumn lastNameCol = new TableColumn("Last Name");
        lastNameCol.setMinWidth(100);
        lastNameCol.setCellValueFactory(
                new PropertyValueFactory&lt;&gt;("lastName"));
 
        table.setItems(data);
        table.getColumns().addAll(firstNameCol, lastNameCol);
 
        firstNameCol.setSortType(TableColumn.SortType.DESCENDING);
        lastNameCol.setSortable(false);
 
        final VBox vbox = new VBox();
        vbox.setSpacing(5);
        vbox.setPadding(new Insets(10, 0, 0, 10));
        vbox.getChildren().addAll(table);
 
        ((Group) scene.getRoot()).getChildren().addAll(vbox);
 
        stage.setScene(scene);
        stage.show();
    }
 
    public static class Person {
 
        private final SimpleStringProperty firstName;
        private final SimpleStringProperty lastName;
 
        private Person(String fName, String lName) {
            this.firstName = new SimpleStringProperty(fName);
            this.lastName = new SimpleStringProperty(lName);
        }
 
        public String getFirstName() {
            return firstName.get();
        }
 
        public void setFirstName(String fName) {
            firstName.set(fName);
        }
 
        public String getLastName() {
            return lastName.get();
        }
 
        public void setLastName(String fName) {
            lastName.set(fName);
        }
    }
} 
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="462" src="https://i-blog.csdnimg.cn/img_convert/21e4fa70b9ea9f082a183d9469342275.png" width="287"/>
    </p>
    <h3 id="Editing_Data_in_the_Table">
     编辑表中的数据
    </h3>
    <p>
     我们可以在表视图中编辑数据。通过调用
     <code>
      setEditable
     </code>
     方法，我们可以启用表内容的编辑。
    </p>
    <p>
     <code>
      setCellFactory
     </code>
     方法安装在
     <code>
      TextFieldTableCell
     </code>
     类中定义的文本字段为每个表单元格。
    </p>
    <p>
     <code>
      setOnEditCommit
     </code>
     方法更新表单元格，并且数据绑定需要考虑设置数据回到
     <code>
      JavaFX JavaBean
     </code>
     ，它用作表视图的下划线数据模型。
    </p>
    <pre><code>import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.CellEditEvent;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.cell.TextFieldTableCell;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class Main extends Application {
 
    private final TableView&lt;Person&gt; table = new TableView&lt;&gt;();
    private final ObservableList&lt;Person&gt; data =
            FXCollections.observableArrayList(
            new Person("A", "B"),
            new Person("C", "D"));
    public static void main(String[] args) {
        launch(args);
    }
 
    @Override
    public void start(Stage stage) {
        Scene scene = new Scene(new Group());
        stage.setWidth(450);
        stage.setHeight(550);
 
        table.setEditable(true);
 
        TableColumn&lt;Person, String&gt; firstNameCol = 
            new TableColumn&lt;&gt;("First Name");
        firstNameCol.setMinWidth(100);
        firstNameCol.setCellValueFactory(
            new PropertyValueFactory&lt;&gt;("firstName"));
        
        firstNameCol.setCellFactory(TextFieldTableCell.&lt;Person&gt;forTableColumn());
        firstNameCol.setOnEditCommit(
            (CellEditEvent&lt;Person, String&gt; t) -&gt; {
                ((Person) t.getTableView().getItems().get(
                        t.getTablePosition().getRow())
                        ).setFirstName(t.getNewValue());
        });
 
 
        TableColumn&lt;Person, String&gt; lastNameCol = 
            new TableColumn&lt;&gt;("Last Name");
        lastNameCol.setMinWidth(100);
        lastNameCol.setCellValueFactory(
            new PropertyValueFactory&lt;&gt;("lastName"));
       lastNameCol.setCellFactory(TextFieldTableCell.&lt;Person&gt;forTableColumn());
       lastNameCol.setOnEditCommit(
            (CellEditEvent&lt;Person, String&gt; t) -&gt; {
                ((Person) t.getTableView().getItems().get(
                        t.getTablePosition().getRow())
                        ).setLastName(t.getNewValue());
        });
        table.setItems(data);
        table.getColumns().addAll(firstNameCol, lastNameCol);
 
        final VBox vbox = new VBox();
        vbox.setSpacing(5);
        vbox.setPadding(new Insets(10, 0, 0, 10));
        vbox.getChildren().addAll( table);
 
        ((Group) scene.getRoot()).getChildren().addAll(vbox);
 
        stage.setScene(scene);
        stage.show();
    }
 
    public static class Person {
        private final SimpleStringProperty firstName;
        private final SimpleStringProperty lastName;
 
        private Person(String fName, String lName) {
            this.firstName = new SimpleStringProperty(fName);
            this.lastName = new SimpleStringProperty(lName);
        }
 
        public String getFirstName() {
            return firstName.get();
        }
 
        public void setFirstName(String fName) {
            firstName.set(fName);
        }
 
        public String getLastName() {
            return lastName.get();
        }
 
        public void setLastName(String fName) {
            lastName.set(fName);
        }
    }
}
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="467" src="https://i-blog.csdnimg.cn/img_convert/787c3821996f50b4562c554f5e5d0241.png" width="286"/>
    </p>
    <h3 id="Table_Edit_Commit_Event">
     表编辑提交事件
    </h3>
    <p>
     当运行上面的代码并双击编辑单元格，我们必须按
     <code>
      Enter
     </code>
     键提交编辑。 如果我们只是双击并键入一些值，并单击单元格外，
     <code>
      commit
     </code>
     事件不会运行，旧的值将被填充。
    </p>
    <p>
     我们可以重新定义焦点更改上的
     <code>
      commit
     </code>
     事件。
    </p>
    <pre><code>/*
 * Copyright (c) 2008, 2014, Oracle and/or its affiliates.
 * All rights reserved. Use is subject to license terms.
 *
 * This file is available and licensed under the following license:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  - Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *  - Neither the name of Oracle nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.CellEditEvent;
import javafx.scene.control.TableView;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.util.Callback;

public class Main extends Application {

  private final TableView&lt;Person&gt; table = new TableView&lt;&gt;();
  private final ObservableList&lt;Person&gt; data = FXCollections
      .observableArrayList(new Person("A", "B"), new Person("C", "D"));

  public static void main(String[] args) {
    launch(args);
  }

  @Override
  public void start(Stage stage) {
    Callback&lt;TableColumn&lt;Person, String&gt;, TableCell&lt;Person, String&gt;&gt; cellFactory = (
        TableColumn&lt;Person, String&gt; p) -&gt; new EditingCell();

    Scene scene = new Scene(new Group());
    stage.setWidth(450);
    stage.setHeight(550);

    table.setEditable(true);

    TableColumn&lt;Person, String&gt; firstNameCol = new TableColumn&lt;&gt;("First Name");
    firstNameCol.setMinWidth(100);
    firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;("firstName"));
    firstNameCol.setCellFactory(cellFactory);

    firstNameCol.setOnEditCommit((CellEditEvent&lt;Person, String&gt; t) -&gt; {
      ((Person) t.getTableView().getItems().get(t.getTablePosition().getRow()))
          .setFirstName(t.getNewValue());
    });

    TableColumn&lt;Person, String&gt; lastNameCol = new TableColumn&lt;&gt;("Last Name");
    lastNameCol.setMinWidth(100);
    lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;("lastName"));

    table.setItems(data);
    table.getColumns().addAll(firstNameCol, lastNameCol);

    final VBox vbox = new VBox();
    vbox.setSpacing(5);
    vbox.setPadding(new Insets(10, 0, 0, 10));
    vbox.getChildren().addAll(table);

    ((Group) scene.getRoot()).getChildren().addAll(vbox);

    stage.setScene(scene);
    stage.show();
  }

  class EditingCell extends TableCell&lt;Person, String&gt; {

    private TextField textField;

    public EditingCell() {
    }

    @Override
    public void startEdit() {
      if (!isEmpty()) {
        super.startEdit();
        createTextField();
        setText(null);
        setGraphic(textField);
        textField.selectAll();
      }
    }

    @Override
    public void cancelEdit() {
      super.cancelEdit();

      setText((String) getItem());
      setGraphic(null);
    }

    @Override
    public void updateItem(String item, boolean empty) {
      super.updateItem(item, empty);

      if (empty) {
        setText(null);
        setGraphic(null);
      } else {
        if (isEditing()) {
          if (textField != null) {
            textField.setText(getString());
          }
          setText(null);
          setGraphic(textField);
        } else {
          setText(getString());
          setGraphic(null);
        }
      }
    }

    private void createTextField() {
      textField = new TextField(getString());
      textField.setMinWidth(this.getWidth() - this.getGraphicTextGap() * 2);
      textField.focusedProperty()
          .addListener(
              (ObservableValue&lt;? extends Boolean&gt; arg0, Boolean arg1,
                  Boolean arg2) -&gt; {
                if (!arg2) {
                  commitEdit(textField.getText());
                }
              });
    }

    private String getString() {
      return getItem() == null ? "" : getItem().toString();
    }
  }

  public static class Person {
    private final SimpleStringProperty firstName;
    private final SimpleStringProperty lastName;

    private Person(String fName, String lName) {
      this.firstName = new SimpleStringProperty(fName);
      this.lastName = new SimpleStringProperty(lName);
    }

    public String getFirstName() {
      return firstName.get();
    }

    public void setFirstName(String fName) {
      firstName.set(fName);
    }

    public String getLastName() {
      return lastName.get();
    }

    public void setLastName(String fName) {
      lastName.set(fName);
    }
  }
}
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="460" src="https://i-blog.csdnimg.cn/img_convert/0ff0db0371254dcee6dbf5dbe8fbc56f.png" width="286"/>
    </p>
    <h3 id="Adding_Maps_of_Data_to_the_Table">
     将数据映射添加到表中
    </h3>
    <p>
     我们可以使用
     <code>
      MapValueFactory
     </code>
     类将
     <code>
      Map
     </code>
     数据添加到表中。
    </p>
    <pre><code>/*
 * Copyright (c) 2008, 2014, Oracle and/or its affiliates.
 * All rights reserved. Use is subject to license terms.
 *
 * This file is available and licensed under the following license:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  - Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the distribution.
 *  - Neither the name of Oracle nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import java.util.HashMap;
import java.util.Map;
import javafx.application.Application;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.MapValueFactory;
import javafx.scene.control.cell.TextFieldTableCell;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.util.Callback;
import javafx.util.StringConverter;
 
public class Main extends Application {
 
    public static final String Column1MapKey = "A";
    public static final String Column2MapKey = "B";
 
    public static void main(String[] args) {
        launch(args);
    }
 
    @Override
    public void start(Stage stage) {
        Scene scene = new Scene(new Group());
        stage.setTitle("Table View Sample");
        stage.setWidth(300);
        stage.setHeight(500);
        
        final Label label = new Label("Student IDs");
        label.setFont(new Font("Arial", 20));
 
        TableColumn&lt;Map, String&gt; firstDataColumn = new TableColumn&lt;&gt;("Class A");
        TableColumn&lt;Map, String&gt; secondDataColumn = new TableColumn&lt;&gt;("Class B");
 
        firstDataColumn.setCellValueFactory(new MapValueFactory(Column1MapKey));
        firstDataColumn.setMinWidth(130);
        secondDataColumn.setCellValueFactory(new MapValueFactory(Column2MapKey));
        secondDataColumn.setMinWidth(130);
 
        TableView tableView = new TableView&lt;&gt;(generateDataInMap());
 
        tableView.setEditable(true);
        tableView.getSelectionModel().setCellSelectionEnabled(true);
        tableView.getColumns().setAll(firstDataColumn, secondDataColumn);
        Callback&lt;TableColumn&lt;Map, String&gt;, TableCell&lt;Map, String&gt;&gt;
            cellFactoryForMap = (TableColumn&lt;Map, String&gt; p) -&gt; 
                new TextFieldTableCell(new StringConverter() {
                    @Override
                        public String toString(Object t) {
                        return t.toString();
                    }
                    @Override
                    public Object fromString(String string) {
                        return string;
                    }
            });
        firstDataColumn.setCellFactory(cellFactoryForMap);
        secondDataColumn.setCellFactory(cellFactoryForMap);
 
        final VBox vbox = new VBox();
 
        vbox.setSpacing(5);
        vbox.setPadding(new Insets(10, 0, 0, 10));
        vbox.getChildren().addAll(label, tableView);
 
        ((Group) scene.getRoot()).getChildren().addAll(vbox);
 
        stage.setScene(scene);
 
        stage.show();
    }
 
    private ObservableList&lt;Map&gt; generateDataInMap() {
        int max = 10;
        ObservableList&lt;Map&gt; allData = FXCollections.observableArrayList();
        for (int i = 1; i &lt; max; i++) {
            Map&lt;String, String&gt; dataRow = new HashMap&lt;&gt;();
 
            String value1 = "A" + i;
            String value2 = "B" + i;
 
            dataRow.put(Column1MapKey, value1);
            dataRow.put(Column2MapKey, value2);
 
            allData.add(dataRow);
        }
        return allData;
    }
}
</code></pre>
    <p>
     上面的代码生成以下结果。
    </p>
    <p>
    </p>
    <p class="img-center">
     <img alt="null" height="501" src="https://i-blog.csdnimg.cn/img_convert/469272c3bd4765db146b7f8a0e9eee2e.png" width="300"/>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37383737323934322f:61727469636c652f64657461696c732f313436323230353538" class_="artid" style="display:none">
 </p>
</div>


