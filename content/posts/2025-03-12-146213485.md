---
layout: post
title: "Android-dumpsys-SufaceFlinger"
date: 2025-03-12 19:58:52 +0800
description: "Android dumpsys SufaceFlinger"
keywords: "Android dumpsys SufaceFlinger"
categories: ['Android']
tags: ['Android']
artid: "146213485"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146213485
    alt: "Android-dumpsys-SufaceFlinger"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146213485
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146213485
cover: https://bing.ee123.net/img/rand?artid=146213485
image: https://bing.ee123.net/img/rand?artid=146213485
img: https://bing.ee123.net/img/rand?artid=146213485
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Android dumpsys SufaceFlinger
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     Android dumpsys SufaceFlinger
    </p>
    <p>
    </p>
    <h3>
     SurfaceFlinger::dumpAllLocked
    </h3>
    <pre><code class="language-cpp">@rameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
SurfaceFlinger::doDump    
    SurfaceFlinger::dumpAllLocked
        result.append("Build configuration:");
        colorizer.reset(result);
        appendSfConfigString(result);
        result.append("\n");
    
        result.append("\nDisplay identification data:\n");
        dumpDisplayIdentificationData(result);
    
        result.append("\nWide-Color information:\n");
        dumpWideColorInfo(result);
    
        colorizer.bold(result);
        result.append("Sync configuration: ");
        colorizer.reset(result);
        result.append(SyncFeatures::getInstance().toString());
        result.append("\n\n");
    
        colorizer.bold(result);
        result.append("Scheduler:\n");
        colorizer.reset(result);
        dumpVSync(result);
        result.append("\n");
    
        dumpStaticScreenStats(result);
        result.append("\n");
    
        StringAppendF(&amp;result, "Total missed frame count: %u\n", mFrameMissedCount.load());
        StringAppendF(&amp;result, "HWC missed frame count: %u\n", mHwcFrameMissedCount.load());
        StringAppendF(&amp;result, "GPU missed frame count: %u\n\n", mGpuFrameMissedCount.load());
    
        dumpBufferingStats(result);
        
        colorizer.bold(result);
        StringAppendF(&amp;result, "Visible layers (count = %zu)\n", mNumLayers.load());
        StringAppendF(&amp;result, "GraphicBufferProducers: %zu, max %zu\n", mGraphicBufferProducerList.size(), mMaxGraphicBufferProducerListSize);
        colorizer.reset(result);
        mDrawingState.traverseInZOrder([&amp;](Layer* layer) {
            auto* compositionState = layer-&gt;getCompositionState();
            if (!compositionState || !compositionState-&gt;isVisible) return;
            android::base::StringAppendF(&amp;result, "* Layer %p (%s)\n", layer, layer-&gt;getDebugName() ? layer-&gt;getDebugName()  : "&lt;unknown&gt;");
@frameworks/native/services/surfaceflinger/CompositionEngine/src/LayerFECompositionState.cpp
            compositionState-&gt;dump(result);
                dumpVal(out, "isSecure", isSecure);
                dumpVal(out, "geomUsesSourceCrop", geomUsesSourceCrop);
                dumpVal(out, "geomBufferUsesDisplayInverseTransform", geomBufferUsesDisplayInverseTransform);
                dumpVal(out, "geomLayerTransform", geomLayerTransform);
                out.append("\n      ");
                dumpVal(out, "geomBufferSize", geomBufferSize);
                dumpVal(out, "geomContentCrop", geomContentCrop);
                dumpVal(out, "geomCrop", geomCrop);
                dumpVal(out, "geomBufferTransform", geomBufferTransform);
                out.append("\n      ");
                dumpVal(out, "transparentRegionHint", transparentRegionHint);
                out.append("      ");
                dumpVal(out, "geomLayerBounds", geomLayerBounds);
                out.append("      ");
                dumpVal(out, "shadowRadius", shadowRadius);
                out.append("\n      ");
                dumpVal(out, "blend", toString(blendMode), blendMode);
                dumpVal(out, "alpha", alpha);
                dumpVal(out, "backgroundBlurRadius", backgroundBlurRadius);
                if (stretchEffect.hasEffect()) {
                    dumpVal(out, "stretchEffect", stretchEffect);
                }        
                dumpVal(out, "composition type", toString(compositionType), compositionType);
                out.append("\n      buffer: ");
                dumpVal(out, "slot", bufferSlot);
                dumpVal(out, "buffer", buffer.get());
                out.append("\n      ");
                dumpVal(out, "sideband stream", sidebandStream.get());
                out.append("\n      ");
                dumpVal(out, "color", color);
                out.append("\n      ");
                dumpVal(out, "isOpaque", isOpaque);
                dumpVal(out, "hasProtectedContent", hasProtectedContent);
                dumpVal(out, "isColorspaceAgnostic", isColorspaceAgnostic);
                dumpVal(out, "dataspace", toString(dataspace), dataspace);
                dumpVal(out, "hdr metadata types", hdrMetadata.validTypes);
                dumpVal(out, "colorTransform", colorTransform);        
        });
        StringAppendF(&amp;result, "Displays (%zu entries)\n", mDisplays.size());   
        for (const auto&amp; [token, display] : mDisplays) {     
@frameworks/native/services/surfaceflinger/DisplayDevice.cpp    
            display-&gt;dump(result);        //看下面的 DisplayDevice::dump
    
        result.append("SurfaceFlinger global state:\n");
@frameworks/native/libs/renderengine/skia/SkiaGLRenderEngine.cpp    
        getRenderEngine().dump(result);
            StringAppendF(&amp;result, "\n ------------RE-----------------\n");
            StringAppendF(&amp;result, "EGL implementation : %s\n", extensions.getEGLVersion());
            StringAppendF(&amp;result, "%s\n", extensions.getEGLExtensions());
            StringAppendF(&amp;result, "GLES: %s, %s, %s\n", extensions.getVendor(), extensions.getRenderer(),
                          extensions.getVersion());
            StringAppendF(&amp;result, "%s\n", extensions.getExtensions());
            StringAppendF(&amp;result, "RenderEngine supports protected context: %d\n",
                          supportsProtectedContent());
            StringAppendF(&amp;result, "RenderEngine is in protected context: %d\n", mInProtectedContext);
            StringAppendF(&amp;result, "RenderEngine shaders cached since last dump/primeCache: %d\n",
                          mSkSLCacheMonitor.shadersCachedSinceLastCall());
            StringAppendF(&amp;result, "Skia CPU Caches: ");
            cpuReporter.logTotals(result);
@frameworks/native/libs/renderengine/skia/debug/SkiaMemoryReporter.cpp        
                StringAppendF(&amp;log, " %.0f bytes, %.2f %s (%.2f %s is purgeable)\n", mTotalSize.value, total.value, total.units, purgeable.value, purgeable.units);        
            cpuReporter.logOutput(result);   
                for (const auto&amp; resourceCategory : mResourceMap) {                   
                    const char* entry = (traceValue.count &gt; 1) ? "entries" : "entry";
                    StringAppendF(&amp;log, "  %s: %.2f %s (%d %s)\n", categoryItem-&gt;first.c_str(),  traceValue.value, traceValue.units, traceValue.count, entry);
            SkiaMemoryReporter gpuReporter(gpuResourceMap, true);
            mGrContext-&gt;dumpMemoryStatistics(&amp;gpuReporter);
            StringAppendF(&amp;result, "Skia's GPU Caches: ");
            gpuReporter.logTotals(result);
            gpuReporter.logOutput(result);
            StringAppendF(&amp;result, "Skia's Wrapped Objects:\n");
            gpuReporter.logOutput(result, true);
    
            StringAppendF(&amp;result, "RenderEngine tracked buffers: %zu\n",
                          mGraphicBufferExternalRefs.size());
            StringAppendF(&amp;result, "Dumping buffer ids...\n");
            for (const auto&amp; [id, refCounts] : mGraphicBufferExternalRefs) {
                StringAppendF(&amp;result, "- 0x%" PRIx64 " - %d refs \n", id, refCounts);
            }
            StringAppendF(&amp;result, "RenderEngine AHB/BackendTexture cache size: %zu\n",
                          mTextureCache.size());
            StringAppendF(&amp;result, "Dumping buffer ids...\n");
            // TODO(178539829): It would be nice to know which layer these are coming from and what
            // the texture sizes are.
            for (const auto&amp; [id, unused] : mTextureCache) {
                StringAppendF(&amp;result, "- 0x%" PRIx64 "\n", id);
            }
            StringAppendF(&amp;result, "\n");    
            
            SkiaMemoryReporter gpuProtectedReporter(gpuResourceMap, true);
            if (mProtectedGrContext) {
                mProtectedGrContext-&gt;dumpMemoryStatistics(&amp;gpuProtectedReporter);
            }
            StringAppendF(&amp;result, "Skia's GPU Protected Caches: ");
            gpuProtectedReporter.logTotals(result);
            gpuProtectedReporter.logOutput(result);
            StringAppendF(&amp;result, "Skia's Protected Wrapped Objects:\n");
            gpuProtectedReporter.logOutput(result, true);
    
            StringAppendF(&amp;result, "\n");
            StringAppendF(&amp;result, "RenderEngine runtime effects: %zu\n", mRuntimeEffects.size());
            for (const auto&amp; [linearEffect, unused] : mRuntimeEffects) {
                StringAppendF(&amp;result, "- inputDataspace: %s\n",
                              dataspaceDetails(
                                      static_cast&lt;android_dataspace&gt;(linearEffect.inputDataspace))
                                      .c_str());
                StringAppendF(&amp;result, "- outputDataspace: %s\n",
                              dataspaceDetails(
                                      static_cast&lt;android_dataspace&gt;(linearEffect.outputDataspace))
                                      .c_str());
                StringAppendF(&amp;result, "undoPremultipliedAlpha: %s\n",
                              linearEffect.undoPremultipliedAlpha ? "true" : "false");
            }        
            
        result.append("ClientCache state:\n");
        ClientCache::getInstance().dump(result);
        DebugEGLImageTracker::getInstance()-&gt;dump(result);
    
        if (const auto display = getDefaultDisplayDeviceLocked()) {
            display-&gt;getCompositionDisplay()-&gt;getState().undefinedRegion.dump(result,
                                                                              "undefinedRegion");
            StringAppendF(&amp;result, "  orientation=%s, isPoweredOn=%d\n",
                          toCString(display-&gt;getOrientation()), display-&gt;isPoweredOn());
        }
        StringAppendF(&amp;result,
                      "  transaction-flags         : %08x\n"
                      "  gpu_to_cpu_unsupported    : %d\n",
                      mTransactionFlags.load(), !mGpuToCpuSupported);
    
        if (const auto display = getDefaultDisplayDeviceLocked()) {
            std::string fps, xDpi, yDpi;
            if (const auto activeMode = display-&gt;getActiveMode()) {
                fps = to_string(activeMode-&gt;getFps());
                xDpi = base::StringPrintf("%.2f", activeMode-&gt;getDpiX());
                yDpi = base::StringPrintf("%.2f", activeMode-&gt;getDpiY());
            } else {
                fps = "unknown";
                xDpi = "unknown";
                yDpi = "unknown";
            }
            StringAppendF(&amp;result,
                          "  refresh-rate              : %s\n"
                          "  x-dpi                     : %s\n"
                          "  y-dpi                     : %s\n",
                          fps.c_str(), xDpi.c_str(), yDpi.c_str());
        }
    
        StringAppendF(&amp;result, "  transaction time: %f us\n", inTransactionDuration / 1000.0);    
@frameworks/native/services/surfaceflinger/SurfaceTracing.cpp
        mTracing.dump(result);
            base::StringAppendF(&amp;result, "Tracing state: %s\n", mEnabled ? "enabled" : "disabled");    
            
        for (const auto&amp; [token, display] : mDisplays) {
            StringAppendF(&amp;result, "Display %s (%s) HWC layers:\n", to_string(*displayId).c_str(),
                          (isDisplayActiveLocked(display) ? "active" : "inactive"));
@frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp                      
            Layer::miniDumpHeader(result);
                result.append(kDumpTableRowLength, '-');
                result.append("\n");
                result.append(" Layer name\n");
                result.append("           Z | ");
                result.append(" Window Type | ");
                result.append(" Comp Type | ");
                result.append(" Transform | ");
                result.append("  Disp Frame (LTRB) | ");
                result.append("         Source Crop (LTRB) | ");
                result.append("    Frame Rate (Explicit) (Seamlessness) [Focused]\n");
                result.append(kDumpTableRowLength, '-');
                result.append("\n");        
            
            const DisplayDevice&amp; ref = *display;
            mCurrentState.traverseInZOrder([&amp;](Layer* layer) { layer-&gt;miniDump(result, ref); });
                StringAppendF(&amp;result, " %s\n", name.c_str());
            
                const State&amp; layerState(getDrawingState());
                const auto&amp; outputLayerState = outputLayer-&gt;getState();
            
                if (layerState.zOrderRelativeOf != nullptr || mDrawingParent != nullptr) {
                    StringAppendF(&amp;result, "  rel %6d | ", layerState.z);
                } else {
                    StringAppendF(&amp;result, "  %10d | ", layerState.z);
                }
                StringAppendF(&amp;result, "  %10d | ", mWindowType);
                StringAppendF(&amp;result, "%10s | ", toString(getCompositionType(display)).c_str());
                StringAppendF(&amp;result, "%10s | ", toString(outputLayerState.bufferTransform).c_str());
                const Rect&amp; frame = outputLayerState.displayFrame;
                StringAppendF(&amp;result, "%4d %4d %4d %4d | ", frame.left, frame.top, frame.right, frame.bottom);
                const FloatRect&amp; crop = outputLayerState.sourceCrop;
                StringAppendF(&amp;result, "%6.1f %6.1f %6.1f %6.1f | ", crop.left, crop.top, crop.right,
                              crop.bottom);
                const auto frameRate = getFrameRateForLayerTree();
                if (frameRate.rate.isValid() || frameRate.type != FrameRateCompatibility::Default) {
                    StringAppendF(&amp;result, "%s %15s %17s", to_string(frameRate.rate).c_str(),
                                  frameRateCompatibilityString(frameRate.type).c_str(),
                                  toString(frameRate.seamlessness).c_str());
                } else {
                    result.append(41, ' ');
                }
            
                const auto focused = isLayerFocusedBasedOnPriority(getFrameRateSelectionPriority());
                StringAppendF(&amp;result, "    [%s]\n", focused ? "*" : " ");
            
                result.append(kDumpTableRowLength, '-'); 
        plannerArgs.add(String16("--layers"));
        dumpPlannerInfo(plannerArgs, result);
            for (const auto&amp; [token, display] : mDisplays) {     
@frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp                      
                compositionDisplay-&gt;dumpPlannerInfo(args, result);
                    base::StringAppendF(&amp;out, "Planner is disabled\n");    
        result.append("h/w composer state:\n");
        colorizer.reset(result);
        bool hwcDisabled = mDebugDisableHWC || mDebugRegion;
        StringAppendF(&amp;result, "  h/w composer %s\n", hwcDisabled ? "disabled" : "enabled");      
@hardware/rockchip/hwcomposer/drmhwc2/drmhwctwo.cpp
        getHwComposer().dump(result);  //看下面的DrmHwcTwo::Dump
        
        const GraphicBufferAllocator&amp; alloc(GraphicBufferAllocator::get());
@frameworks/native/libs/ui/GraphicBufferAllocator.cpp    
        alloc.dump(result);
            result.append("GraphicBufferAllocator buffers:\n");
            const size_t count = list.size();
            StringAppendF(&amp;result, "%10s | %11s | %18s | %s | %8s | %10s | %s\n", "Handle", "Size",
                          "W (Stride) x H", "Layers", "Format", "Usage", "Requestor");
            for (size_t i = 0; i &lt; count; i++) {
                const alloc_rec_t&amp; rec(list.valueAt(i));
                std::string sizeStr = (rec.size)
                        ? base::StringPrintf("%7.2f KiB", static_cast&lt;double&gt;(rec.size) / 1024.0)
                        : "unknown";
                StringAppendF(&amp;result, "%10p | %11s | %4u (%4u) x %4u | %6u | %8X | 0x%8" PRIx64 " | %s\n",
                              list.keyAt(i), sizeStr.c_str(), rec.width, rec.stride, rec.height,
                              rec.layerCount, rec.format, rec.usage, rec.requestorName.c_str());
                total += rec.size;
            }
            StringAppendF(&amp;result, "Total allocated by GraphicBufferAllocator (estimate): %.2f KB\n",
                          static_cast&lt;double&gt;(total) / 1024.0); 
@frameworks/native/libs/ui/Gralloc4.cpp
            result.append(mAllocator-&gt;dumpDebugInfo(less));           
                return mMapper.dumpBuffers(less);
                    stream &lt;&lt; "Imported gralloc buffers:\n";
                    for (const auto&amp; bufferDump : bufferDumps) {
                        uint64_t allocationSize = 0;
                        status_t err = bufferDumpHelper(bufferDump, &amp;stream, &amp;allocationSize, less);          
                           status_t error = metadataDumpHelper(bufferDump, StandardMetadataType::BUFFER_ID, gralloc4::decodeBufferId, &amp;bufferId);      
                            *outDump &lt;&lt; "+ name:" &lt;&lt; name &lt;&lt; ", id:" &lt;&lt; bufferId &lt;&lt; ", size:" &lt;&lt; allocationSizeKiB
                                     &lt;&lt; "KiB, w/h:" &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; ", usage: 0x" &lt;&lt; std::hex &lt;&lt; usage
                                     &lt;&lt; std::dec &lt;&lt; ", req fmt:" &lt;&lt; static_cast&lt;int32_t&gt;(pixelFormatRequested)
                                     &lt;&lt; ", fourcc/mod:" &lt;&lt; pixelFormatFourCC &lt;&lt; "/" &lt;&lt; pixelFormatModifier
                                     &lt;&lt; ", dataspace: 0x" &lt;&lt; std::hex &lt;&lt; static_cast&lt;uint32_t&gt;(dataspace) &lt;&lt; std::dec
                                     &lt;&lt; ", compressed: ";      
                             for (const auto&amp; planeLayout : planeLayouts) {   
                                 *outDump &lt;&lt; "\tplanes: ";       
                                 *outDump &lt;&lt; " w/h:" &lt;&lt; planeLayout.widthInSamples &lt;&lt; "x" &lt;&lt; planeLayout.heightInSamples
                                         &lt;&lt; ", stride:" &lt;&lt; planeLayout.strideInBytes
                                         &lt;&lt; " bytes, size:" &lt;&lt; planeLayout.totalSizeInBytes;
                    stream &lt;&lt; "Total imported by gralloc: " &lt;&lt; totalAllocationSizeKiB &lt;&lt; "KiB\n";    
                    
@frameworks/native/services/surfaceflinger/TimeStats/TimeStats.cpp
        result.append(mTimeStats-&gt;miniDump()); 
            std::string result = "TimeStats miniDump:\n";
            std::lock_guard&lt;std::mutex&gt; lock(mMutex);
            android::base::StringAppendF(&amp;result, "Number of layers currently being tracked is %zu\n",
                                         mTimeStatsTracker.size());
            android::base::StringAppendF(&amp;result, "Number of layers in the stats pool is %zu\n",
                                         mTimeStats.stats.size());       
                                         
    LayersTraceFileProto traceFileProto = SurfaceTracing::createLayersTraceFileProto();                                                                                       
    dumpDisplayProto(*layersTrace);
        displayProto-&gt;set_layer_stack(display-&gt;getLayerStack());
    result.append(LayerProtoParser::layerTreeToString(layerTree));
        for (const LayerProtoParser::Layer* layer : layerTree.topLevelLayers) {
@frameworks/native/services/surfaceflinger/layerproto/LayerProtoParser.cpp            
            result.append(layerToString(layer));
                result.append(layer-&gt;to_string());
                    StringAppendF(&amp;result, "+ %s (%s) uid=%d\n", type.c_str(), name.c_str(), ownerUid);
                    result.append(transparentRegion.to_string("TransparentRegion").c_str());
                    result.append(visibleRegion.to_string("VisibleRegion").c_str());
                    result.append(damageRegion.to_string("SurfaceDamageRegion").c_str());
                
                    StringAppendF(&amp;result, "      layerStack=%4d, z=%9d, pos=(%g,%g), size=(%4d,%4d), ", layerStack,
                                  z, static_cast&lt;double&gt;(position.x), static_cast&lt;double&gt;(position.y), size.x,
                                  size.y);
                
                    StringAppendF(&amp;result, "crop=%s, ", crop.to_string().c_str());
                    StringAppendF(&amp;result, "cornerRadius=%f, ", cornerRadius);
                    StringAppendF(&amp;result, "isProtected=%1d, ", isProtected);
                    StringAppendF(&amp;result, "isTrustedOverlay=%1d, ", isTrustedOverlay);
                    StringAppendF(&amp;result, "isOpaque=%1d, invalidate=%1d, ", isOpaque, invalidate);
                    StringAppendF(&amp;result, "dataspace=%s, ", dataspace.c_str());
                    StringAppendF(&amp;result, "defaultPixelFormat=%s, ", pixelFormat.c_str());
                    StringAppendF(&amp;result, "backgroundBlurRadius=%1d, ", backgroundBlurRadius);
                    StringAppendF(&amp;result, "color=(%.3f,%.3f,%.3f,%.3f), flags=0x%08x, ",
                                  static_cast&lt;double&gt;(color.r), static_cast&lt;double&gt;(color.g),
                                  static_cast&lt;double&gt;(color.b), static_cast&lt;double&gt;(color.a), flags);
                    StringAppendF(&amp;result, "tr=%s", transform.to_string().c_str());
                    result.append("\n");
                    StringAppendF(&amp;result, "      parent=%s\n", parent == nullptr ? "none" : parent-&gt;name.c_str());
                    StringAppendF(&amp;result, "      zOrderRelativeOf=%s\n",
                                  zOrderRelativeOf == nullptr ? "none" : zOrderRelativeOf-&gt;name.c_str());
                    StringAppendF(&amp;result, "      activeBuffer=%s,", activeBuffer.to_string().c_str());
                    StringAppendF(&amp;result, " tr=%s", bufferTransform.to_string().c_str());
                    StringAppendF(&amp;result, " queued-frames=%d, mRefreshPending=%d,", queuedFrames, refreshPending);
                    StringAppendF(&amp;result, " metadata={");
                    bool first = true;
                    for (const auto&amp; entry : metadata.mMap) {
                        if (!first) result.append(", ");
                        first = false;
                        result.append(metadata.itemToString(entry.first, ":"));
                    }
                    result.append("},");
                    StringAppendF(&amp;result, " cornerRadiusCrop=%s, ", cornerRadiusCrop.to_string().c_str());
                    StringAppendF(&amp;result, " shadowRadius=%.3f, ", shadowRadius);                
    dumpOffscreenLayers(result);     
        result.append("Offscreen Layers:\n");               
        for (Layer* offscreenLayer : mOffscreenLayers) {
@frameworks/native/services/surfaceflinger/Layer.cpp            
            layer-&gt;dumpCallingUidPid(result);
                StringAppendF(&amp;result, "Layer %s (%s) callingPid:%d callingUid:%d ownerUid:%d\n", getName().c_str(), getType(), mCallingPid, mCallingUid, mOwnerUid);
            </code></pre>
    <p>
    </p>
    <h3>
     DisplayDevice::dump
    </h3>
    <pre><code class="language-cpp">@frameworks/native/services/surfaceflinger/DisplayDevice.cpp
DisplayDevice::dump
    StringAppendF(&amp;result, "+ %s\n", getDebugName().c_str());        //+ DisplayDevice{0, internal, primary, "Internal display"}
    StringAppendF(&amp;result, "   powerMode=%s (%d)\n", to_string(mPowerMode).c_str(),
                  static_cast&lt;int32_t&gt;(mPowerMode));
    const auto activeMode = getActiveMode();
    StringAppendF(&amp;result, "   activeMode=%s\n",
                  activeMode ? to_string(*activeMode).c_str() : "none");
    result.append("   supportedModes=\n");

@frameworks/native/services/surfaceflinger/CompositionEngine/src/Display.cpp
    getCompositionDisplay()-&gt;dump(result);  //Display::dump
        StringAppendF(&amp;out, "   Composition Display State: [\"%s\"]", getName().c_str());
        out.append("\n   ");
        dumpVal(out, "isVirtual", mIsVirtual);
        dumpVal(out, "DisplayId", to_string(mId));
        out.append("\n");
@frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp
        Output::dumpBase(out);   //Output::dumpBase
@frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayer.h        
            dumpState(out);
@frameworks/native/services/surfaceflinger/CompositionEngine/src/OutputCompositionState.cpp
                mState.dump(out);
                    out.append("   ");
                    dumpVal(out, "isEnabled", isEnabled);
                    dumpVal(out, "isSecure", isSecure);
                
                    dumpVal(out, "usesClientComposition", usesClientComposition);
                    dumpVal(out, "usesDeviceComposition", usesDeviceComposition);
                    dumpVal(out, "flipClientTarget", flipClientTarget);
                    dumpVal(out, "reusedClientComposition", reusedClientComposition);
                
                    dumpVal(out, "layerStack", layerStackId);
                    dumpVal(out, "layerStackInternal", layerStackInternal);
                
                    out.append("\n   ");
                
                    dumpVal(out, "transform", transform);
                
                    out.append("\n   ");
                    dumpVal(out, "layerStackSpace", to_string(layerStackSpace));
                    out.append("\n   ");
                    dumpVal(out, "framebufferSpace", to_string(framebufferSpace));
                    out.append("\n   ");
                    dumpVal(out, "orientedDisplaySpace", to_string(orientedDisplaySpace));
                    out.append("\n   ");
                    dumpVal(out, "displaySpace", to_string(displaySpace));
                    out.append("\n   ");
                    dumpVal(out, "needsFiltering", needsFiltering);
                    dumpVal(out, "colorMode", toString(colorMode), colorMode);
                    dumpVal(out, "renderIntent", toString(renderIntent), renderIntent);
                    dumpVal(out, "dataspace", toString(dataspace), dataspace);
                    dumpVal(out, "colorTransformMatrix", colorTransformMatrix);
                    dumpVal(out, "target dataspace", toString(targetDataspace), targetDataspace);
@frameworks/native/services/surfaceflinger/CompositionEngine/src/DisplayColorProfile.cpp                            
                mDisplayColorProfile-&gt;dump(out);
                    out.append("   Composition Display Color State:");
                    out.append("\n   HWC Support: ");
                    dumpVal(out, "wideColorGamut", hasWideColorGamut());
                    dumpVal(out, "hdr10plus", hasHDR10PlusSupport());
                    dumpVal(out, "hdr10", hasHDR10Support());
                    dumpVal(out, "hlg", hasHLGSupport());
                    dumpVal(out, "dv", hasDolbyVisionSupport());
                    dumpVal(out, "metadata", getSupportedPerFrameMetadata()); 
@frameworks/native/services/surfaceflinger/CompositionEngine/src/RenderSurface.cpp
@frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
                mRenderSurface-&gt;dump(out);
                    out.append("   Composition RenderSurface State:");
                    out.append("\n   ");
                    dumpVal(out, "size", mSize);
                    StringAppendF(&amp;out, "ANativeWindow=%p (format %d) ", mNativeWindow.get(),
                                  ANativeWindow_getFormat(mNativeWindow.get()));
                    dumpVal(out, "flips", mPageFlipCount);
                    out.append("\n");
@frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp      //物理屏幕              
                    mDisplaySurface-&gt;dumpAsString(surfaceDump);
                        result.appendFormat("  FramebufferSurface: dataspace: %s(%d)\n",  dataspaceDetails(static_cast&lt;android_dataspace&gt;(mDataSpace)).c_str(), mDataSpace);
@frameworks/native/libs/gui/ConsumerBase.cpp                        
                        ConsumerBase::dumpLocked(result, "   ");
                            result.appendFormat("%smAbandoned=%d\n", prefix, int(mAbandoned));
@frameworks/native/libs/gui/BufferQueueConsumer.cpp                            
                            mConsumer-&gt;dumpState(String8(prefix), &amp;consumerState);
@frameworks/native/libs/gui/BufferQueueCore.cpp
                                mCore-&gt;dumpState(prefix, outResult);   
                                    outResult-&gt;appendFormat("%s- BufferQueue ", prefix.string());
                                    outResult-&gt;appendFormat("mMaxAcquiredBufferCount=%d mMaxDequeuedBufferCount=%d\n",
                                                            mMaxAcquiredBufferCount, mMaxDequeuedBufferCount);
                                    outResult-&gt;appendFormat("%s  mDequeueBufferCannotBlock=%d mAsyncMode=%d\n", prefix.string(),
                                                            mDequeueBufferCannotBlock, mAsyncMode);
                                    outResult-&gt;appendFormat("%s  mQueueBufferCanDrop=%d mLegacyBufferDrop=%d\n", prefix.string(),
                                                            mQueueBufferCanDrop, mLegacyBufferDrop);
                                    outResult-&gt;appendFormat("%s  default-size=[%dx%d] default-format=%d ", prefix.string(),
                                                            mDefaultWidth, mDefaultHeight, mDefaultBufferFormat);
                                    outResult-&gt;appendFormat("%s  transform-hint=%02x frame-counter=%" PRIu64 "\n", prefix.string(),
                                                            mTransformHint, mFrameCounter);
                                    outResult-&gt;appendFormat("%s  mTransformHintInUse=%02x mAutoPrerotation=%d\n", prefix.string(),
                                                            mTransformHintInUse, mAutoPrerotation);                                
                                    outResult-&gt;appendFormat("%sFIFO(%zu):\n", prefix.string(), mQueue.size());                                
                                    outResult-&gt;appendFormat("%s(mConsumerName=%s, ", prefix.string(), mConsumerName.string());                                
                                    outResult-&gt;appendFormat("mConnectedApi=%d, mConsumerUsageBits=%" PRIu64 ", ", mConnectedApi,
                                                            mConsumerUsageBits);                                
                                    String8 producerProcName = String8("\?\?\?");
                                    String8 consumerProcName = String8("\?\?\?");
                                    int32_t pid = getpid();
                                    getProcessName(mConnectedPid, producerProcName);
                                    getProcessName(pid, consumerProcName);
                                    outResult-&gt;appendFormat("mId=%" PRIx64 ", producer=[%d:%s], consumer=[%d:%s])\n", mUniqueId,
                                                            mConnectedPid, producerProcName.string(), pid,
                                                            consumerProcName.string());
                                    Fifo::const_iterator current(mQueue.begin());
                                    while (current != mQueue.end()) {
                                        double timestamp = current-&gt;mTimestamp / 1e9;
                                        outResult-&gt;appendFormat("%s  %02d:%p ", prefix.string(), current-&gt;mSlot,
                                                                current-&gt;mGraphicBuffer.get());
                                        outResult-&gt;appendFormat("crop=[%d,%d,%d,%d] ", current-&gt;mCrop.left, current-&gt;mCrop.top,
                                                                current-&gt;mCrop.right, current-&gt;mCrop.bottom);
                                        outResult-&gt;appendFormat("xform=0x%02x time=%.4f scale=%s\n", current-&gt;mTransform, timestamp,
                                                                BufferItem::scalingModeName(current-&gt;mScalingMode));
                                        ++current;
                                    }                                
                                    outResult-&gt;appendFormat("%sSlots:\n", prefix.string());
                                    for (int s : mActiveBuffers) {
                                        const sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[s].mGraphicBuffer);
                                        // A dequeued buffer might be null if it's still being allocated
                                        if (buffer.get()) {
                                            outResult-&gt;appendFormat("%s %s[%02d:%p] ", prefix.string(),
                                                                    (mSlots[s].mBufferState.isAcquired()) ? "&gt;" : " ", s,
                                                                    buffer.get());
                                            outResult-&gt;appendFormat("state=%-8s %p frame=%" PRIu64, mSlots[s].mBufferState.string(),
                                                                    buffer-&gt;handle, mSlots[s].mFrameNumber);
                                            outResult-&gt;appendFormat(" [%4ux%4u:%4u,%3X]\n", buffer-&gt;width, buffer-&gt;height,
                                                                    buffer-&gt;stride, buffer-&gt;format);
                                        } else {
                                            outResult-&gt;appendFormat("%s  [%02d:%p] ", prefix.string(), s, buffer.get());
                                            outResult-&gt;appendFormat("state=%-8s frame=%" PRIu64 "\n",
                                                                    mSlots[s].mBufferState.string(), mSlots[s].mFrameNumber);
                                        }
                                    }
                                    for (int s : mFreeBuffers) {
                                        const sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[s].mGraphicBuffer);
                                        outResult-&gt;appendFormat("%s  [%02d:%p] ", prefix.string(), s, buffer.get());
                                        outResult-&gt;appendFormat("state=%-8s %p frame=%" PRIu64, mSlots[s].mBufferState.string(),
                                                                buffer-&gt;handle, mSlots[s].mFrameNumber);
                                        outResult-&gt;appendFormat(" [%4ux%4u:%4u,%3X]\n", buffer-&gt;width, buffer-&gt;height,
                                                                buffer-&gt;stride, buffer-&gt;format);
                                    }                                                                                   
@frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp   //虚拟屏幕，两者二选一
                    mDisplaySurface-&gt;dumpAsString(surfaceDump)
                        {}
@rameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp
            android::base::StringAppendF(&amp;out, "\n   %zu Layers\n", getOutputLayerCount());
            for (const auto* outputLayer : getOutputLayersOrderedByZ()) {
@frameworks/native/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp
                outputLayer-&gt;dump(out);
                    StringAppendF(&amp;out, "  - Output Layer %p(%s)\n", this, getLayerFE().getDebugName());
@frameworks/native/services/surfaceflinger/CompositionEngine/src/OutputLayerCompositionState.cpp                    
                    dumpState(out);
                        out.append("      ");
                        dumpVal(out, "visibleRegion", visibleRegion);
                        out.append("      ");
                        dumpVal(out, "visibleNonTransparentRegion", visibleNonTransparentRegion);
                        out.append("      ");
                        dumpVal(out, "coveredRegion", coveredRegion);
                        out.append("      ");
                        dumpVal(out, "output visibleRegion", outputSpaceVisibleRegion);
                        out.append("      ");
                        dumpVal(out, "shadowRegion", shadowRegion);
                        out.append("      ");
                        dumpVal(out, "forceClientComposition", forceClientComposition);
                        dumpVal(out, "clearClientTarget", clearClientTarget);
                        dumpVal(out, "displayFrame", displayFrame);
                        dumpVal(out, "sourceCrop", sourceCrop);
                        dumpVal(out, "bufferTransform", toString(bufferTransform), bufferTransform);
                        dumpVal(out, "dataspace", toString(dataspace), dataspace);
                        dumpVal(out, "override buffer", overrideInfo.buffer.get());
                        dumpVal(out, "override acquire fence", overrideInfo.acquireFence.get());
                        dumpVal(out, "override display frame", overrideInfo.displayFrame);
                        dumpVal(out, "override dataspace", toString(overrideInfo.dataspace), overrideInfo.dataspace);
                        dumpVal(out, "override display space", to_string(overrideInfo.displaySpace));
                        std::string damageRegionString;
                        overrideInfo.damageRegion.dump(damageRegionString, "");
                        dumpVal(out, "override damage region", damageRegionString);
                        std::string visibleRegionString;
                        overrideInfo.visibleRegion.dump(visibleRegionString, "");
                        dumpVal(out, "override visible region", visibleRegionString);
                        dumpVal(out, "override peekThroughLayer", overrideInfo.peekThroughLayer);
                        dumpVal(out, "override disableBackgroundBlur", overrideInfo.disableBackgroundBlur);
                    
                        if (hwc) {
                            dumpHwc(*hwc, out);
                                out.append("\n      hwc: ");
                                if (hwc.hwcLayer == nullptr) {
                                    out.append("No layer ");
                                } else {
                                    dumpHex(out, "layer", hwc.hwcLayer-&gt;getId());
                                }
                                dumpVal(out, "composition", toString(hwc.hwcCompositionType), hwc.hwcCompositionType);
@frameworks/native/services/surfaceflinger/Scheduler/RefreshRateConfigs.cpp
    mRefreshRateConfigs-&gt;dump(result);
        base::StringAppendF(&amp;result, "DesiredDisplayModeSpecs (DisplayManager): %s\n\n",
                            mDisplayManagerPolicy.toString().c_str());
        scheduler::RefreshRateConfigs::Policy currentPolicy = *getCurrentPolicyLocked();
        if (mOverridePolicy &amp;&amp; currentPolicy != mDisplayManagerPolicy) {
            base::StringAppendF(&amp;result, "DesiredDisplayModeSpecs (Override): %s\n\n",
                                currentPolicy.toString().c_str());
        }
    
        auto mode = mCurrentRefreshRate-&gt;mode;
        base::StringAppendF(&amp;result, "Current mode: %s\n", mCurrentRefreshRate-&gt;toString().c_str());
    
        result.append("Refresh rates:\n");
        for (const auto&amp; [id, refreshRate] : mRefreshRates) {
            mode = refreshRate-&gt;mode;
            base::StringAppendF(&amp;result, "\t%s\n", refreshRate-&gt;toString().c_str());
        }
    
        base::StringAppendF(&amp;result, "Supports Frame Rate Override: %s\n",
                            mSupportsFrameRateOverride ? "yes" : "no");
        base::StringAppendF(&amp;result, "Idle timer: (%s) %s\n",
                            mConfig.supportKernelIdleTimer ? "kernel" : "platform",
                            mIdleTimer ? mIdleTimer-&gt;dump().c_str() : "off");    </code></pre>
    <p>
    </p>
    <h3>
     DrmHwcTwo::Dump
    </h3>
    <pre><code class="language-cpp">@hardware/rockchip/hwcomposer/drmhwc2/drmhwctwo.cpp
DrmHwcTwo::Dump
    output.appendFormat("-- HWC2 Version %s by bin.li@rock-chips.com --\n",acVersion);
    for(auto &amp;map_disp: displays_){
@hardware/rockchip/hwcomposer/drmhwc2/drmhwctwo.cpp        
        if((map_disp.second.DumpDisplayInfo(output)) &lt; 0)
            output.appendFormat(" DisplayId=%" PRIu64 ", Connector %u, Type = %s-%u, Connector state = %s\n",handle_,
                                    connector_-&gt;id(),
                                    isVirtual() ? "Virtual" : drm_-&gt;connector_type_str(connector_-&gt;type()),
                                    connector_-&gt;type_id(),
                                    connector_-&gt;state() == DRM_MODE_CONNECTED ? "DRM_MODE_CONNECTED" : "DRM_MODE_DISCONNECTED"); 
            output.appendFormat("  NumHwLayers=%zu, activeModeId=%u, %s%c%.2f, colorMode = %d, bStandardSwitchResolution=%d\n",      
            output.append(
                          "------+-----+-----------+-----------+--------------------+-------------+------------+--------------------------------+------------------------+------------+--------+------------\n"
                          "  id  |  z  |  sf-type  |  hwc-type |       handle       |  transform  |    blnd    |     source crop (l,t,r,b)      |          frame         | dataspace  |  mFps  | name       \n"
                          "------+-----+-----------+-----------+--------------------+-------------+------------+--------------------------------+------------------------+------------+--------+------------\n");  
                          
          for (uint32_t z_order = 0; z_order &lt;= layers_.size(); z_order++) {
            for (auto &amp;map_layer : layers_) {
              HwcLayer &amp;layer = map_layer.second;
              if(layer.z_order() == z_order){
@hardware/rockchip/hwcomposer/drmhwc2/drmhwctwo.cpp                  
                layer.DumpLayerInfo(output);
                    output.appendFormat( " %04" PRIu32 " | %03" PRIu32 " | %9s | %9s | %-18.18" PRIxPTR " |"
                                           " %-11.11s | %-10.10s |%7.1f,%7.1f,%7.1f,%7.1f |%5d,%5d,%5d,%5d |"
                                           " %10x | %5.1f  | %s | 0x%" PRIx64 "\n",
                                        id_,
                                        mCurrentState.z_order_,                
                break;
              }
            }
          }       
            output.append("------+-----+-----------+-----------+--------------------+-------------+------------+--------------------------------+------------------------+------------+--------+------------\n");
            output.append("DrmHwcLayer Dump:\n");     
            for(auto &amp;drmHwcLayer : drm_hwc_layers_)
                drmHwcLayer.DumpInfo(output);     
@hardware/rockchip/hwcomposer/drmhwc2/rockchip/common/drmlayer.cpp                
                    out.appendFormat( "DrmHwcLayer[%4u] Buffer[w/h/s/bs/format]=[%4d,%4d,%4d,%4d,%4d] Fourcc=%c%c%c%c Transform=%-8.8s(0x%x) Blend[a=%d]=%-8.8s "
                                    "source_crop[l,t,r,b]=[%5.0f,%5.0f,%5.0f,%5.0f] display_frame[l,t,r,b]=[%4d,%4d,%4d,%4d],skip=%d,afbcd=%d hdr=%d\n",
                                   uId_,iWidth_,iHeight_,iStride_,iByteStride_,iFormat_,uFourccFormat_,uFourccFormat_&gt;&gt;8,uFourccFormat_&gt;&gt;16,uFourccFormat_&gt;&gt;24,                </code></pre>
    <p>
    </p>
    <p>
    </p>
    <p>
     @rameworks/native/services/surfaceflinger/SurfaceFlinger.cpp SurfaceFlinger::doDump SurfaceFlinger::dumpAllLocked result.append("Build configuration:"); colorizer.reset(result); appendSfConfigString(result); result.append("\n"); result.append("\nDisplay identification data:\n"); dumpDisplayIdentificationData(result); result.append("\nWide-Color information:\n"); dumpWideColorInfo(result); colorizer.bold(result); result.append("Sync configuration: "); colorizer.reset(result); result.append(SyncFeatures::getInstance().toString()); result.append("\n\n"); colorizer.bold(result); result.append("Scheduler:\n"); colorizer.reset(result); dumpVSync(result); result.append("\n"); dumpStaticScreenStats(result); result.append("\n"); StringAppendF(&amp;result, "Total missed frame count: %u\n", mFrameMissedCount.load()); StringAppendF(&amp;result, "HWC missed frame count: %u\n", mHwcFrameMissedCount.load()); StringAppendF(&amp;result, "GPU missed frame count: %u\n\n", mGpuFrameMissedCount.load()); dumpBufferingStats(result); colorizer.bold(result); StringAppendF(&amp;result, "Visible layers (count = %zu)\n", mNumLayers.load()); StringAppendF(&amp;result, "GraphicBufferProducers: %zu, max %zu\n", mGraphicBufferProducerList.size(), mMaxGraphicBufferProducerListSize); colorizer.reset(result); mDrawingState.traverseInZOrder([&amp;](Layer* layer) { auto* compositionState = layer-&gt;getCompositionState(); if (!compositionState || !compositionState-&gt;isVisible) return; android::base::StringAppendF(&amp;result, "* Layer %p (%s)\n", layer, layer-&gt;getDebugName() ? layer-&gt;getDebugName() : "&lt;unknown&gt;"); @frameworks/native/services/surfaceflinger/CompositionEngine/src/LayerFECompositionState.cpp compositionState-&gt;dump(result); dumpVal(out, "isSecure", isSecure); dumpVal(out, "geomUsesSourceCrop", geomUsesSourceCrop); dumpVal(out, "geomBufferUsesDisplayInverseTransform", geomBufferUsesDisplayInverseTransform); dumpVal(out, "geomLayerTransform", geomLayerTransform); out.append("\n "); dumpVal(out, "geomBufferSize", geomBufferSize); dumpVal(out, "geomContentCrop", geomContentCrop); dumpVal(out, "geomCrop", geomCrop); dumpVal(out, "geomBufferTransform", geomBufferTransform); out.append("\n "); dumpVal(out, "transparentRegionHint", transparentRegionHint); out.append(" "); dumpVal(out, "geomLayerBounds", geomLayerBounds); out.append(" "); dumpVal(out, "shadowRadius", shadowRadius); out.append("\n "); dumpVal(out, "blend", toString(blendMode), blendMode); dumpVal(out, "alpha", alpha); dumpVal(out, "backgroundBlurRadius", backgroundBlurRadius); if (stretchEffect.hasEffect()) { dumpVal(out, "stretchEffect", stretchEffect); } dumpVal(out, "composition type", toString(compositionType), compositionType); out.append("\n buffer: "); dumpVal(out, "slot", bufferSlot); dumpVal(out, "buffer", buffer.get()); out.append("\n "); dumpVal(out, "sideband stream", sidebandStream.get()); out.append("\n "); dumpVal(out, "color", color); out.append("\n "); dumpVal(out, "isOpaque", isOpaque); dumpVal(out, "hasProtectedContent", hasProtectedContent); dumpVal(out, "isColorspaceAgnostic", isColorspaceAgnostic); dumpVal(out, "dataspace", toString(dataspace), dataspace); dumpVal(out, "hdr metadata types", hdrMetadata.validTypes); dumpVal(out, "colorTransform", colorTransform); }); StringAppendF(&amp;result, "Displays (%zu entries)\n", mDisplays.size()); for (const auto&amp; [token, display] : mDisplays) { @frameworks/native/services/surfaceflinger/DisplayDevice.cpp display-&gt;dump(result); //看下面的 DisplayDevice::dump result.append("SurfaceFlinger global state:\n"); @frameworks/native/libs/renderengine/skia/SkiaGLRenderEngine.cpp getRenderEngine().dump(result); StringAppendF(&amp;result, "\n ------------RE-----------------\n"); StringAppendF(&amp;result, "EGL implementation : %s\n", extensions.getEGLVersion()); StringAppendF(&amp;result, "%s\n", extensions.getEGLExtensions()); StringAppendF(&amp;result, "GLES: %s, %s, %s\n", extensions.getVendor(), extensions.getRenderer(), extensions.getVersion()); StringAppendF(&amp;result, "%s\n", extensions.getExtensions()); StringAppendF(&amp;result, "RenderEngine supports protected context: %d\n", supportsProtectedContent()); StringAppendF(&amp;result, "RenderEngine is in protected context: %d\n", mInProtectedContext); StringAppendF(&amp;result, "RenderEngine shaders cached since last dump/primeCache: %d\n", mSkSLCacheMonitor.shadersCachedSinceLastCall()); StringAppendF(&amp;result, "Skia CPU Caches: "); cpuReporter.logTotals(result); @frameworks/native/libs/renderengine/skia/debug/SkiaMemoryReporter.cpp StringAppendF(&amp;log, " %.0f bytes, %.2f %s (%.2f %s is purgeable)\n", mTotalSize.value, total.value, total.units, purgeable.value, purgeable.units); cpuReporter.logOutput(result); for (const auto&amp; resourceCategory : mResourceMap) { const char* entry = (traceValue.count &gt; 1) ? "entries" : "entry"; StringAppendF(&amp;log, " %s: %.2f %s (%d %s)\n", categoryItem-&gt;first.c_str(), traceValue.value, traceValue.units, traceValue.count, entry); SkiaMemoryReporter gpuReporter(gpuResourceMap, true); mGrContext-&gt;dumpMemoryStatistics(&amp;gpuReporter); StringAppendF(&amp;result, "Skia's GPU Caches: "); gpuReporter.logTotals(result); gpuReporter.logOutput(result); StringAppendF(&amp;result, "Skia's Wrapped Objects:\n"); gpuReporter.logOutput(result, true); StringAppendF(&amp;result, "RenderEngine tracked buffers: %zu\n", mGraphicBufferExternalRefs.size()); StringAppendF(&amp;result, "Dumping buffer ids...\n"); for (const auto&amp; [id, refCounts] : mGraphicBufferExternalRefs) { StringAppendF(&amp;result, "- 0x%" PRIx64 " - %d refs \n", id, refCounts); } StringAppendF(&amp;result, "RenderEngine AHB/BackendTexture cache size: %zu\n", mTextureCache.size()); StringAppendF(&amp;result, "Dumping buffer ids...\n"); // TODO(178539829): It would be nice to know which layer these are coming from and what // the texture sizes are. for (const auto&amp; [id, unused] : mTextureCache) { StringAppendF(&amp;result, "- 0x%" PRIx64 "\n", id); } StringAppendF(&amp;result, "\n"); SkiaMemoryReporter gpuProtectedReporter(gpuResourceMap, true); if (mProtectedGrContext) { mProtectedGrContext-&gt;dumpMemoryStatistics(&amp;gpuProtectedReporter); } StringAppendF(&amp;result, "Skia's GPU Protected Caches: "); gpuProtectedReporter.logTotals(result); gpuProtectedReporter.logOutput(result); StringAppendF(&amp;result, "Skia's Protected Wrapped Objects:\n"); gpuProtectedReporter.logOutput(result, true); StringAppendF(&amp;result, "\n"); StringAppendF(&amp;result, "RenderEngine runtime effects: %zu\n", mRuntimeEffects.size()); for (const auto&amp; [linearEffect, unused] : mRuntimeEffects) { StringAppendF(&amp;result, "- inputDataspace: %s\n", dataspaceDetails( static_cast&lt;android_dataspace&gt;(linearEffect.inputDataspace)) .c_str()); StringAppendF(&amp;result, "- outputDataspace: %s\n", dataspaceDetails( static_cast&lt;android_dataspace&gt;(linearEffect.outputDataspace)) .c_str()); StringAppendF(&amp;result, "undoPremultipliedAlpha: %s\n", linearEffect.undoPremultipliedAlpha ? "true" : "false"); } result.append("ClientCache state:\n"); ClientCache::getInstance().dump(result); DebugEGLImageTracker::getInstance()-&gt;dump(result); if (const auto display = getDefaultDisplayDeviceLocked()) { display-&gt;getCompositionDisplay()-&gt;getState().undefinedRegion.dump(result, "undefinedRegion"); StringAppendF(&amp;result, " orientation=%s, isPoweredOn=%d\n", toCString(display-&gt;getOrientation()), display-&gt;isPoweredOn()); } StringAppendF(&amp;result, " transaction-flags : %08x\n" " gpu_to_cpu_unsupported : %d\n", mTransactionFlags.load(), !mGpuToCpuSupported); if (const auto display = getDefaultDisplayDeviceLocked()) { std::string fps, xDpi, yDpi; if (const auto activeMode = display-&gt;getActiveMode()) { fps = to_string(activeMode-&gt;getFps()); xDpi = base::StringPrintf("%.2f", activeMode-&gt;getDpiX()); yDpi = base::StringPrintf("%.2f", activeMode-&gt;getDpiY()); } else { fps = "unknown"; xDpi = "unknown"; yDpi = "unknown"; } StringAppendF(&amp;result, " refresh-rate : %s\n" " x-dpi : %s\n" " y-dpi : %s\n", fps.c_str(), xDpi.c_str(), yDpi.c_str()); } StringAppendF(&amp;result, " transaction time: %f us\n", inTransactionDuration / 1000.0); @frameworks/native/services/surfaceflinger/SurfaceTracing.cpp mTracing.dump(result); base::StringAppendF(&amp;result, "Tracing state: %s\n", mEnabled ? "enabled" : "disabled"); for (const auto&amp; [token, display] : mDisplays) { StringAppendF(&amp;result, "Display %s (%s) HWC layers:\n", to_string(*displayId).c_str(), (isDisplayActiveLocked(display) ? "active" : "inactive")); @frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp Layer::miniDumpHeader(result); result.append(kDumpTableRowLength, '-'); result.append("\n"); result.append(" Layer name\n"); result.append(" Z | "); result.append(" Window Type | "); result.append(" Comp Type | "); result.append(" Transform | "); result.append(" Disp Frame (LTRB) | "); result.append(" Source Crop (LTRB) | "); result.append(" Frame Rate (Explicit) (Seamlessness) [Focused]\n"); result.append(kDumpTableRowLength, '-'); result.append("\n"); const DisplayDevice&amp; ref = *display; mCurrentState.traverseInZOrder([&amp;](Layer* layer) { layer-&gt;miniDump(result, ref); }); StringAppendF(&amp;result, " %s\n", name.c_str()); const State&amp; layerState(getDrawingState()); const auto&amp; outputLayerState = outputLayer-&gt;getState(); if (layerState.zOrderRelativeOf != nullptr || mDrawingParent != nullptr) { StringAppendF(&amp;result, " rel %6d | ", layerState.z); } else { StringAppendF(&amp;result, " %10d | ", layerState.z); } StringAppendF(&amp;result, " %10d | ", mWindowType); StringAppendF(&amp;result, "%10s | ", toString(getCompositionType(display)).c_str()); StringAppendF(&amp;result, "%10s | ", toString(outputLayerState.bufferTransform).c_str()); const Rect&amp; frame = outputLayerState.displayFrame; StringAppendF(&amp;result, "%4d %4d %4d %4d | ", frame.left, frame.top, frame.right, frame.bottom); const FloatRect&amp; crop = outputLayerState.sourceCrop; StringAppendF(&amp;result, "%6.1f %6.1f %6.1f %6.1f | ", crop.left, crop.top, crop.right, crop.bottom); const auto frameRate = getFrameRateForLayerTree(); if (frameRate.rate.isValid() || frameRate.type != FrameRateCompatibility::Default) { StringAppendF(&amp;result, "%s %15s %17s", to_string(frameRate.rate).c_str(), frameRateCompatibilityString(frameRate.type).c_str(), toString(frameRate.seamlessness).c_str()); } else { result.append(41, ' '); } const auto focused = isLayerFocusedBasedOnPriority(getFrameRateSelectionPriority()); StringAppendF(&amp;result, " [%s]\n", focused ? "*" : " "); result.append(kDumpTableRowLength, '-'); plannerArgs.add(String16("--layers")); dumpPlannerInfo(plannerArgs, result); for (const auto&amp; [token, display] : mDisplays) { @frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp compositionDisplay-&gt;dumpPlannerInfo(args, result); base::StringAppendF(&amp;out, "Planner is disabled\n"); result.append("h/w composer state:\n"); colorizer.reset(result); bool hwcDisabled = mDebugDisableHWC || mDebugRegion; StringAppendF(&amp;result, " h/w composer %s\n", hwcDisabled ? "disabled" : "enabled"); @hardware/rockchip/hwcomposer/drmhwc2/drmhwctwo.cpp getHwComposer().dump(result); //看下面的DrmHwcTwo::Dump const GraphicBufferAllocator&amp; alloc(GraphicBufferAllocator::get()); @frameworks/native/libs/ui/GraphicBufferAllocator.cpp alloc.dump(result); result.append("GraphicBufferAllocator buffers:\n"); const size_t count = list.size(); StringAppendF(&amp;result, "%10s | %11s | %18s | %s | %8s | %10s | %s\n", "Handle", "Size", "W (Stride) x H", "Layers", "Format", "Usage", "Requestor"); for (size_t i = 0; i &lt; count; i++) { const alloc_rec_t&amp; rec(list.valueAt(i)); std::string sizeStr = (rec.size) ? base::StringPrintf("%7.2f KiB", static_cast&lt;double&gt;(rec.size) / 1024.0) : "unknown"; StringAppendF(&amp;result, "%10p | %11s | %4u (%4u) x %4u | %6u | %8X | 0x%8" PRIx64 " | %s\n", list.keyAt(i), sizeStr.c_str(), rec.width, rec.stride, rec.height, rec.layerCount, rec.format, rec.usage, rec.requestorName.c_str()); total += rec.size; } StringAppendF(&amp;result, "Total allocated by GraphicBufferAllocator (estimate): %.2f KB\n", static_cast&lt;double&gt;(total) / 1024.0); @frameworks/native/libs/ui/Gralloc4.cpp result.append(mAllocator-&gt;dumpDebugInfo(less)); return mMapper.dumpBuffers(less); stream &lt;&lt; "Imported gralloc buffers:\n"; for (const auto&amp; bufferDump : bufferDumps) { uint64_t allocationSize = 0; status_t err = bufferDumpHelper(bufferDump, &amp;stream, &amp;allocationSize, less); status_t error = metadataDumpHelper(bufferDump, StandardMetadataType::BUFFER_ID, gralloc4::decodeBufferId, &amp;bufferId); *outDump &lt;&lt; "+ name:" &lt;&lt; name &lt;&lt; ", id:" &lt;&lt; bufferId &lt;&lt; ", size:" &lt;&lt; allocationSizeKiB &lt;&lt; "KiB, w/h:" &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; ", usage: 0x" &lt;&lt; std::hex &lt;&lt; usage &lt;&lt; std::dec &lt;&lt; ", req fmt:" &lt;&lt; static_cast&lt;int32_t&gt;(pixelFormatRequested) &lt;&lt; ", fourcc/mod:" &lt;&lt; pixelFormatFourCC &lt;&lt; "/" &lt;&lt; pixelFormatModifier &lt;&lt; ", dataspace: 0x" &lt;&lt; std::hex &lt;&lt; static_cast&lt;uint32_t&gt;(dataspace) &lt;&lt; std::dec &lt;&lt; ", compressed: "; for (const auto&amp; planeLayout : planeLayouts) { *outDump &lt;&lt; "\tplanes: "; *outDump &lt;&lt; " w/h:" &lt;&lt; planeLayout.widthInSamples &lt;&lt; "x" &lt;&lt; planeLayout.heightInSamples &lt;&lt; ", stride:" &lt;&lt; planeLayout.strideInBytes &lt;&lt; " bytes, size:" &lt;&lt; planeLayout.totalSizeInBytes; stream &lt;&lt; "Total imported by gralloc: " &lt;&lt; totalAllocationSizeKiB &lt;&lt; "KiB\n"; @frameworks/native/services/surfaceflinger/TimeStats/TimeStats.cpp result.append(mTimeStats-&gt;miniDump()); std::string result = "TimeStats miniDump:\n"; std::lock_guard&lt;std::mutex&gt; lock(mMutex); android::base::StringAppendF(&amp;result, "Number of layers currently being tracked is %zu\n", mTimeStatsTracker.size()); android::base::StringAppendF(&amp;result, "Number of layers in the stats pool is %zu\n", mTimeStats.stats.size()); LayersTraceFileProto traceFileProto = SurfaceTracing::createLayersTraceFileProto(); dumpDisplayProto(*layersTrace); displayProto-&gt;set_layer_stack(display-&gt;getLayerStack()); result.append(LayerProtoParser::layerTreeToString(layerTree)); for (const LayerProtoParser::Layer* layer : layerTree.topLevelLayers) { @frameworks/native/services/surfaceflinger/layerproto/LayerProtoParser.cpp result.append(layerToString(layer)); result.append(layer-&gt;to_string()); StringAppendF(&amp;result, "+ %s (%s) uid=%d\n", type.c_str(), name.c_str(), ownerUid); result.append(transparentRegion.to_string("TransparentRegion").c_str()); result.append(visibleRegion.to_string("VisibleRegion").c_str()); result.append(damageRegion.to_string("SurfaceDamageRegion").c_str()); StringAppendF(&amp;result, " layerStack=%4d, z=%9d, pos=(%g,%g), size=(%4d,%4d), ", layerStack, z, static_cast&lt;double&gt;(position.x), static_cast&lt;double&gt;(position.y), size.x, size.y); StringAppendF(&amp;result, "crop=%s, ", crop.to_string().c_str()); StringAppendF(&amp;result, "cornerRadius=%f, ", cornerRadius); StringAppendF(&amp;result, "isProtected=%1d, ", isProtected); StringAppendF(&amp;result, "isTrustedOverlay=%1d, ", isTrustedOverlay); StringAppendF(&amp;result, "isOpaque=%1d, invalidate=%1d, ", isOpaque, invalidate); StringAppendF(&amp;result, "dataspace=%s, ", dataspace.c_str()); StringAppendF(&amp;result, "defaultPixelFormat=%s, ", pixelFormat.c_str()); StringAppendF(&amp;result, "backgroundBlurRadius=%1d, ", backgroundBlurRadius); StringAppendF(&amp;result, "color=(%.3f,%.3f,%.3f,%.3f), flags=0x%08x, ", static_cast&lt;double&gt;(color.r), static_cast&lt;double&gt;(color.g), static_cast&lt;double&gt;(color.b), static_cast&lt;double&gt;(color.a), flags); StringAppendF(&amp;result, "tr=%s", transform.to_string().c_str()); result.append("\n"); StringAppendF(&amp;result, " parent=%s\n", parent == nullptr ? "none" : parent-&gt;name.c_str()); StringAppendF(&amp;result, " zOrderRelativeOf=%s\n", zOrderRelativeOf == nullptr ? "none" : zOrderRelativeOf-&gt;name.c_str()); StringAppendF(&amp;result, " activeBuffer=%s,", activeBuffer.to_string().c_str()); StringAppendF(&amp;result, " tr=%s", bufferTransform.to_string().c_str()); StringAppendF(&amp;result, " queued-frames=%d, mRefreshPending=%d,", queuedFrames, refreshPending); StringAppendF(&amp;result, " metadata={"); bool first = true; for (const auto&amp; entry : metadata.mMap) { if (!first) result.append(", "); first = false; result.append(metadata.itemToString(entry.first, ":")); } result.append("},"); StringAppendF(&amp;result, " cornerRadiusCrop=%s, ", cornerRadiusCrop.to_string().c_str()); StringAppendF(&amp;result, " shadowRadius=%.3f, ", shadowRadius); dumpOffscreenLayers(result); result.append("Offscreen Layers:\n"); for (Layer* offscreenLayer : mOffscreenLayers) { @frameworks/native/services/surfaceflinger/Layer.cpp layer-&gt;dumpCallingUidPid(result); StringAppendF(&amp;result, "Layer %s (%s) callingPid:%d callingUid:%d ownerUid:%d\n", getName().c_str(), getType(), mCallingPid, mCallingUid, mOwnerUid);
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f77656e77616e6738382f:61727469636c652f64657461696c732f313436323133343835" class_="artid" style="display:none">
 </p>
</div>


