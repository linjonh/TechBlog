---
layout: post
title: "9.贪心算法"
date: 2025-03-15 08:30:25 +0800
description: "这种题⽬的解决⽅式⼀般就是按照区间的左端点或者是右端点排序，然后在排序之后的区间上，根据 题⽬要求，制定出相应的贪⼼策略，进⽽得到最优解。⼀般是假设⼀种排序⽅式，并且制定贪⼼策略， 当没有明显的反例时，就可以尝试去写代码。2.交换这两个元素，对前面和后面确定好顺序的序列的结果不造成影响。2.交换这两个元素，对前面和后面确定好顺序的序列的结果不造成影响。舍弃的想法很大胆，也很有风险，但通过证明，就可以表示通过。证明： 按照左端点排序，互相重叠的区间是连续的。按照左端点排序，互相重叠的区间是连续的。"
keywords: "9.贪心算法"
categories: ['未分类']
tags: ['贪心算法', '算法']
artid: "146139262"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146139262
    alt: "9.贪心算法"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146139262
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146139262
cover: https://bing.ee123.net/img/rand?artid=146139262
image: https://bing.ee123.net/img/rand?artid=146139262
img: https://bing.ee123.net/img/rand?artid=146139262
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     9.贪心算法
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h2>
     简单贪心
    </h2>
    <h3>
     1.
     <a href="https://www.luogu.com.cn/problem/P10452" rel="nofollow" title="P10452 货仓选址 - 洛谷">
      P10452 货仓选址 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="590" src="https://i-blog.csdnimg.cn/direct/18385f1696d64cc88bd1d79169e5fe7a.png" width="831"/>
    </p>
    <p>
     <img alt="" height="364" src="https://i-blog.csdnimg.cn/direct/d9577111b0c346b692276c8890b31f7d.png" width="953">
      <img alt="" height="378" src="https://i-blog.csdnimg.cn/direct/62d64985b9584673b38e2f5a9e0da24d.png" width="961">
       <img alt="" height="632" src="https://i-blog.csdnimg.cn/direct/1c344a59239b4e47be922cee3433d54b.png" width="958"/>
      </img>
     </img>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

typedef long long LL;
const int N = 1e5+10;
LL a[N];
LL n;

int main()
{
	cin&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)cin&gt;&gt;a[i];
	sort(a+1,a+1+n);//排序 
	LL sum = 0;
	//for(int i = 1;i &lt;= n;i++)
	//{
	//	sum+=(abs(a[i]-a[(1+n)/2]));
	//}
	
	for(int i = 1;i &lt;= n/2;i++)
	{
		sum += abs(a[i]-a[n+1-i]);
	}
	cout&lt;&lt;sum&lt;&lt;endl;
	return 0;
 } </code></pre>
    <h3>
     2.
     <a href="https://www.luogu.com.cn/problem/P1115" rel="nofollow" title="P1115 最大子段和 - 洛谷">
      P1115 最大子段和 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="620" src="https://i-blog.csdnimg.cn/direct/b1ea5a618e1d4cf0915721d1cb99c1d7.png" width="761"/>
    </p>
    <p>
     <img alt="" height="389" src="https://i-blog.csdnimg.cn/direct/84ec4f72cbed4cd3b59680798d0fd3c5.png" width="1241"/>
    </p>
    <p>
     <img alt="" height="838" src="https://i-blog.csdnimg.cn/direct/610ca05c994d40f3bf907f13c085ee32.png" width="1222"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

typedef long long LL;

const int N = 2e5+10;
LL a[N];
LL n;

int main()
{
	cin&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)cin&gt;&gt;a[i];
	
	LL sum = 0;LL ret = -1e5;
	for(int i = 1;i &lt;= n;i++)
	{
		sum+=a[i];
		ret = max(sum,ret);
		if(sum &lt; 0)sum = 0;
	 } 
	 cout&lt;&lt;ret&lt;&lt;endl;
	 return 0;
 } </code></pre>
    <blockquote>
     <p>
      舍弃的想法很大胆，也很有风险，但通过证明，就可以表示通过
     </p>
    </blockquote>
    <h3>
     3.
     <a href="https://www.luogu.com.cn/problem/P1094" rel="nofollow" title="P1094 [NOIP 2007 普及组] 纪念品分组 - 洛谷">
      P1094 [NOIP 2007 普及组] 纪念品分组 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="890" src="https://i-blog.csdnimg.cn/direct/8905fb4d37184cf695c1dd289b204e9b.png" width="746"/>
    </p>
    <p>
     <img alt="" height="545" src="https://i-blog.csdnimg.cn/direct/11a9ff2fd9304ae7a0491ef2e2d9fd4c.png" width="1386"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int w,n;
const int N = 3e4+10;
int a[N];

int main()
{
	cin&gt;&gt;w&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)cin&gt;&gt;a[i];
	//排序
	 sort(a+1,a+1+n);
	 int l = 1,r = n,ret = 0;
	 while(l &lt;= r)
	 {
	 	//最小和最大相加小于w，符合 ，同时异位 
	 	if(a[l]+a[r]&lt;=w)l++,r--;
	 	//l待定。r-- 
		 else
	 	{
	 		r--;
		 }
		 ret++;
	 }
	 cout&lt;&lt;ret&lt;&lt;endl;
	 return 0;
	
}</code></pre>
    <h3>
     4.
     <a href="https://www.luogu.com.cn/problem/P1056" rel="nofollow" title="P1056 [NOIP 2008 普及组] 排座椅 - 洛谷">
      P1056 [NOIP 2008 普及组] 排座椅 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="1307" src="https://i-blog.csdnimg.cn/direct/1c67a2361f434dd887f4d34d657b0ec9.png" width="700"/>
    </p>
    <p>
     <img alt="" height="676" src="https://i-blog.csdnimg.cn/direct/99c7e9ec52aa4ddcaf19d4504508eb70.png" width="1371"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int m, n, k, l, d;
const int N = 1010;

struct  node
{
	int index;//存行列的下标
	int cnt;//存取该行或者该列能隔开多少对同学
}row[N],col[N];

//按照cnt从大到小排列
bool cmp1(node&amp; x, node&amp; y)
{
	return x.cnt &gt; y.cnt;
}
//按照下标从小到大排列
bool cmp2(node&amp; x, node&amp; y)
{
	return x.index &lt; y.index;
}

int main()
{
	cin &gt;&gt; m &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; d;
	//初始化数组，赋值index
	for (int i = 1; i &lt;= m; i++)row[i].index = i;
	for (int i = 1; i &lt;= n; i++)col[i].index = i;
	//计算cnt
	while (d--)
	{
		int x, y, p, q; cin &gt;&gt; x &gt;&gt; y &gt;&gt; p &gt;&gt; q;
		if (x == p)col[min(y, q)].cnt++;
		else
			row[min(x, p)].cnt++;
	}
	//通过cnt把大的排在前面--&gt;cmp1
	sort(row + 1, row + 1 + m, cmp1);
	sort(col + 1, col + 1 + n, cmp1);
	//把前k或者l大的按照下表从小到大进行排列
	sort(row + 1, row + 1 + k, cmp2);
	sort(col + 1, col + 1 + l, cmp2);
	//输出
	//行
	for (int i = 1; i &lt;= k; i++)
	{
		cout &lt;&lt; row[i].index &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	//列
	for (int i = 1; i &lt;= l; i++)
	{
		cout &lt;&lt; col[i].index &lt;&lt; " ";
	}
	return 0;
}</code></pre>
    <blockquote>
     <p>
      1.把每一行和每一列可以隔开的同学记录到cnt中
     </p>
     <p>
      2.按照cnt从大到小进行排列
     </p>
     <p>
      3.按照index对前k或者l个进行从小到大的排列
     </p>
     <p>
      4.输出前k 或 l的index下标
     </p>
    </blockquote>
    <h3>
     4.
     <a href="https://ac.nowcoder.com/acm/problem/200190" rel="nofollow" title="矩阵消除游戏">
      矩阵消除游戏
     </a>
    </h3>
    <p>
     <img alt="" height="673" src="https://i-blog.csdnimg.cn/direct/d426e53df4ac49edba94c037be24a0f0.png" width="927"/>
    </p>
    <p>
     <img alt="" height="552" src="https://i-blog.csdnimg.cn/direct/02d00df7852a44b5b62ce3b9a4f6d5d7.png" width="1092"/>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;

int calc(int x)
{
	int ret = 0;
	while (x)
	{
		x = x &amp; (x - 1);
		ret++;
	}
	return ret;
}

bool cmp(int x, int y)
{
	return x &gt; y;
}

int n, m,k;
const int N = 100;
int a[N][N];
int col[N];

int main()
{
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	for (int i = 0; i &lt; n; i++)
	{
		for (int j = 0; j &lt; m; j++)
		{
			cin &gt;&gt; a[i][j];
		}
	}
	int sum = 0, ret = 0;
	//暴力枚举所有的第一行
	for (int st = 0; st &lt; (1 &lt;&lt; n); st++)
	{
		sum = 0;
		int num_1 = calc(st);
		//超过就不要了
		if (num_1 &gt; k)continue;

		memset(col, 0, sizeof(col));
		for (int i = 0; i &lt; n; i++)
		{
			//加上当前行的数字
			for (int j = 0; j &lt; m; j++)
			{
				if (((st &gt;&gt; i) &amp; 1) == 1)
				{
					sum += a[i][j];
				}
				else
				{
					col[j] += a[i][j];
				}
			}
		}
		//对列进行从大到小排序，取前k - num_1个
		int remain = k - num_1;
		sort(col, col + m, cmp);
		for (int i = 0; i &lt; remain; i++)sum += col[i];
		ret = max(ret, sum);
	}
	cout &lt;&lt; ret &lt;&lt; endl;
	return 0;
}
</code></pre>
    <h2>
     推公式
    </h2>
    <blockquote>
     <p>
      1.在确定好的顺序序列中，拿出相邻的两个元素
      <br/>
      2.交换这两个元素，对前面和后面确定好顺序的序列的结果不造成影响
      <br/>
      3.根据这两个原色交换前后的结果推导出排序的规
     </p>
    </blockquote>
    <h2>
     <img alt="" height="131" src="https://i-blog.csdnimg.cn/direct/93474d588f8247b3a8da5b275b519e71.png" width="693"/>
    </h2>
    <h3>
     1.
     <a href="https://www.luogu.com.cn/problem/P1012" rel="nofollow" title="P1012 [NOIP 1998 提高组] 拼数 - 洛谷">
      P1012 [NOIP 1998 提高组] 拼数 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="616" src="https://i-blog.csdnimg.cn/direct/e36791b6956147f4a222f4427fd41762.png" width="733"/>
    </p>
    <p>
     <img alt="" height="684" src="https://i-blog.csdnimg.cn/direct/115785a629fa4f19a3054407323da4f5.png" width="1406"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;

#include&lt;algorithm&gt;
using namespace std;

int n;
const int N = 25;
string st[N];

bool cmp(string&amp; x, string&amp; y)
{
	return x + y &gt; y + x;
}

int main()
{
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++)
		cin &gt;&gt; st[i];

	sort(st, st+n, cmp);
	for (int i = 0; i &lt; n; i++)
		cout &lt;&lt; st[i];
	return 0;
}</code></pre>
    <blockquote>
     <p>
      比较方法：两两元素相拼，
     </p>
    </blockquote>
    <h3>
     2.
     <a href="https://www.luogu.com.cn/problem/P2878" rel="nofollow" title="P2878 [USACO07JAN] Protecting the Flowers S - 洛谷">
      P2878 [USACO07JAN] Protecting the Flowers S - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/ea357cc5bfb14e13b0a5544619fe6c60.png" width="699"/>
    </p>
    <p>
    </p>
    <p>
     <img alt="" height="875" src="https://i-blog.csdnimg.cn/direct/01a941c73bc54b98aa6bd6a006cbabb0.png" width="1472"/>
    </p>
    <blockquote>
     <p>
      很震惊！！
     </p>
     <blockquote>
      <p>
       1.在确定好的顺序序列中，拿出相邻的两个元素
       <br/>
       2.交换这两个元素，对前面和后面确定好顺序的序列的结果不造成影响
       <br/>
       3.根据这两个原色交换前后的结果推导出排序的
      </p>
     </blockquote>
    </blockquote>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

typedef long long LL;

LL n;
const int N = 1e5+10;
struct node
{
	LL t;//时间
	LL d;//吃草速度 
}a[N]; 

bool cmp(node&amp; x,node&amp;y)
{
	return x.t*y.d &lt; x.d*y.t;
}

int main()
{
	cin&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)
	{
		cin&gt;&gt;a[i].t&gt;&gt;a[i].d;
	}
	sort(a+1,a+n+1,cmp);
	LL ret = 0,t = 0;
	for(int i = 1;i &lt;= n;i++)
	{
		ret += a[i].d*t;
		t += 2*a[i].t;
	}
	cout&lt;&lt;ret&lt;&lt;endl;
 } </code></pre>
    <h3>
     3.
     <a href="https://www.luogu.com.cn/problem/P1842" rel="nofollow" title="P1842 [USACO05NOV] 奶牛玩杂技 - 洛谷">
      P1842 [USACO05NOV] 奶牛玩杂技 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="819" src="https://i-blog.csdnimg.cn/direct/ec09fa2e19274a59a7b5bd922cfcfbdb.png" width="703"/>
    </p>
    <p>
     <img alt="" height="552" src="https://i-blog.csdnimg.cn/direct/5e68e15cb616424fbce964aea9a1535c.png" width="1086"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 5e4+10;
int n;

struct node
{
	LL w;
	LL s;	
}a[N];
//推公式得到，把max中较小的放在前面，会让总体压力值变得较小 
bool cmp(node&amp;x,node&amp;y)
{
	return max(-x.s,x.w-y.s) &lt; max(-y.s,y.w-x.s);
}

int main()
{
	cin&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)
	{
		cin&gt;&gt;a[i].w&gt;&gt;a[i].s;
	}
	sort(a+1,a+1+n,cmp);
	
	LL w = 0;
	LL ret = -1e5;
	for(int i = 1;i &lt;= n;i++)
	{
		ret = max(ret,w - a[i].s);
		w+=a[i].w;
	}
	cout&lt;&lt;ret&lt;&lt;endl;
	return 0;
	
 } </code></pre>
    <blockquote>
     <p>
      <img alt="" height="98" src="https://i-blog.csdnimg.cn/direct/dd58a3f4b5eb4b9b815f765f5f90491f.png" width="703"/>
     </p>
    </blockquote>
    <h2>
     哈夫曼树
    </h2>
    <p>
     <img alt="" height="609" src="https://i-blog.csdnimg.cn/direct/48b1ab419a7f47aeb92624ca98e5043f.png" width="710"/>
    </p>
    <p>
     <img alt="" height="253" src="https://i-blog.csdnimg.cn/direct/8a847741a1304f95ba3c9aeee5e20f1f.png" width="815"/>
    </p>
    <h3 style="background-color:transparent">
     1.
     <a href="https://www.luogu.com.cn/problem/P1090" rel="nofollow" title="P1090 [NOIP 2004 提高组] 合并果子 - 洛谷">
      P1090 [NOIP 2004 提高组] 合并果子 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="697" src="https://i-blog.csdnimg.cn/direct/3fd310cb5a2e494694aa4f27bebb8758.png" width="714"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;

typedef long long LL; 

priority_queue&lt;LL,vector&lt;LL&gt;,greater&lt;LL&gt;&gt;heap;

LL n;
int main()
{
	cin&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)
	{
		LL x;cin&gt;&gt;x;
		heap.push(x);
	}
	LL sum = 0;
	while(heap.size()&gt;1)
	{
		LL x = heap.top();heap.pop();
		LL y = heap.top();heap.pop();
		sum+=(x+y);
		heap.push(x+y);
	 } 
	 cout&lt;&lt;sum&lt;&lt;endl;
}</code></pre>
    <h2>
     区间问题
    </h2>
    <blockquote>
     <p>
      这种题⽬的解决⽅式⼀般就是按照区间的左端点或者是右端点排序，然后在排序之后的区间上，根据 题⽬要求，制定出相应的贪⼼策略，进⽽得到最优解。
     </p>
     <p>
     </p>
     <p>
      具体是根据左端点还是右端点排序？升序还是降序？⼀般是假设⼀种排序⽅式，并且制定贪⼼策略， 当没有明显的反例时，就可以尝试去写代码。
     </p>
    </blockquote>
    <h3>
     1.
     <a href="https://www.luogu.com.cn/problem/P1803" rel="nofollow" title="P1803 凌乱的yyy / 线段覆盖 - 洛谷">
      P1803 凌乱的yyy / 线段覆盖 - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="769" src="https://i-blog.csdnimg.cn/direct/ca99cda5ee094ba7ad950180197804f6.png" width="723"/>
    </p>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1e6+10;
int n;
struct node
{
	int s;
	int e;
}a[N];

bool cmp(node&amp;x,node&amp;y)
{
	return x.s &lt; y.s;
 } 

int main()
{
	cin&gt;&gt;n;
	for(int i = 1;i &lt;= n;i++)
	{
		cin&gt;&gt;a[i].s;
		cin&gt;&gt;a[i].e;
	}
	
	sort(a+1,a+1+n,cmp);//按照起点开始由小到大的顺序排列
	int ret = 1;
	int r = a[1].e;
	for(int i = 2;i &lt;= n;i++)
	{
		int right = a[i].e,left = a[i].s;
		if(left &lt; r)//重叠了，不能参加,如果重叠的右端比前面那一个还小，那就贪，覆盖前面哪一个 
		{
			r = min(r,right);
		}
		else
		{
			ret++;//没有重叠，可以参加
			r = right;//更新较小的r 
		 } 
	}
	cout&lt;&lt;ret&lt;&lt;endl;
	return 0;
	 
} </code></pre>
    <p>
    </p>
    <p>
     <img alt="" height="480" src="https://i-blog.csdnimg.cn/direct/235672a00fdc4cd8aa13289b04b1370e.png" width="886"/>
    </p>
    <h3>
     2.
     <a href="https://www.luogu.com.cn/problem/UVA1193" rel="nofollow" title="UVA1193 Radar Installation - 洛谷">
      UVA1193 Radar Installation - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="817" src="https://i-blog.csdnimg.cn/direct/e21c58de7ff44d9e980a374a022e54d3.png" width="710"/>
    </p>
    <p>
     <img alt="" height="734" src="https://i-blog.csdnimg.cn/direct/e9789485ff93444aba739e26df7eebaf.png" width="1356"/>
    </p>
    <blockquote>
     <p>
      按照左端点排序，互相重叠的区间是连续的
     </p>
    </blockquote>
    <blockquote>
     <p>
      二维问题转化成一维问题
     </p>
    </blockquote>
    <blockquote>
     <p>
      证明： 按照左端点排序，互相重叠的区间是连续的
     </p>
     <p>
      <img alt="" height="609" src="https://i-blog.csdnimg.cn/direct/99fb6170889342baac750d6a40e9315e.png" width="1417"/>
     </p>
    </blockquote>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;

const int N = 1e3+10;

int n,d;
struct node
{
	double l;
	double r;
}a[N];

bool cmp(node&amp;x,node&amp;y)
{
	return x.l &lt; y.l;
}
int main()
{
	int cnt = 1;
	while(cin&gt;&gt;n&gt;&gt;d&amp;&amp;(n&amp;&amp;d))
	{
		int flag = 1;
		for(int i = 1;i &lt;=		 n;i++)
		{
			int x,y;cin&gt;&gt;x&gt;&gt;y;
			if(y &gt; d)flag = -1;
			//把二维映射到一维上去
			double l =  sqrt(d*d - y*y);
			a[i].l = x - l;
			a[i].r = x + l;
		}
		sort(a+1,a+1+n,cmp);
	int ret = 1;
	int r = a[1].r; 
	cout&lt;&lt;"Case "&lt;&lt;cnt&lt;&lt;": ";
	cnt++; 
	for(int i = 2;i &lt;= n;i++)
	{
		int left = a[i].l,right = a[i].r;
		if(left&lt;=r)//等于也可以扫到 
		{
			//扫描通过
			r =  min(r,right);
		}else
		{
			ret++;
			r = right;
		}
	}
	
	cout&lt;&lt;ret&lt;&lt;endl;
}
	return 0;
 } </code></pre>
    <p>
    </p>
    <h3>
     3.
     <a href="https://www.luogu.com.cn/problem/P2887" rel="nofollow" title="P2887 [USACO07NOV] Sunscreen G - 洛谷">
      P2887 [USACO07NOV] Sunscreen G - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="576" src="https://i-blog.csdnimg.cn/direct/7461ba6a7b524e7a81290fd3e21f87ae.png" width="1485"/>
     <img alt="" height="826" src="https://i-blog.csdnimg.cn/direct/34da355813d6480d95cf4ecb2d122e4d.png" width="1511"/>
    </p>
    <h4>
     <img alt="" height="457" src="https://i-blog.csdnimg.cn/direct/96c86daa1ea24e60a32148734eca4d06.png" width="1481"/>
    </h4>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt; 
using namespace std;

const int N = 3e3+10;

int n,l;
struct node
{
	int l;//表示奶牛耐受的最小值//防晒霜的防晒值 
	int r;//奶牛耐受的最大值// 防晒霜的数量 
}a[N],b[N]; 

bool cmp(node&amp;x,node&amp;y)
{
	return x.l &gt; y.l;
}
int main()
{
	cin&gt;&gt;n&gt;&gt;l;
	for(int i = 1;i &lt;= n;i++)
	{
		cin&gt;&gt;a[i].l&gt;&gt;a[i].r;//输入奶牛耐受值 
	}
	for(int i = 1;i &lt;= l;i++)
	{
		cin&gt;&gt;b[i].l&gt;&gt;b[i].r;//输入防晒霜的防晒值和数量 
	}
	//按照奶牛奶牛左端从大到小进行排序
	sort(a+1,a+1+n,cmp);
	//按照防晒霜防晒值从大到小进行排序
	sort(b+1,b+1+l,cmp);
	int ret = 0;
	for(int i = 1;i &lt;= n;i++)
	{
		//选择一种防晒霜
		for(int j = 1;j &lt;= l;j++)	
		{
			if(b[j].r == 0)continue;
			if(b[j].l&lt;=a[i].r&amp;&amp;b[j].l&gt;=a[i].l)
			{
				//符合条件，ret++,数量-- 
				ret++;
				b[j].r--;
				break;//选完一个就直接除去，免得后面的都没了 
			}
		}
	} 
	cout&lt;&lt;ret&lt;&lt;endl;
	return 0; 
}</code></pre>
    <p>
    </p>
    <h3>
     4.
     <a href="https://www.luogu.com.cn/problem/P2859" rel="nofollow" title="P2859 [USACO06FEB] Stall Reservations S - 洛谷">
      P2859 [USACO06FEB] Stall Reservations S - 洛谷
     </a>
    </h3>
    <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int N = 5e4 + 10;
int n;
struct node
{
	int l;//牛牛的开始//该牛棚的结束时间 
	int r;//牛牛的结束 //该牛棚的编号 
	int num;//这只牛的编号 

	bool operator&lt;(const node&amp; y)const
	{
		return l &gt; y.l;//创建小根堆 
	}
}a[N];
bool cmp(node&amp; x, node&amp; y)
{
	return x.l &lt; y.l;
}
int res[N];//记录每只牛进入的牛棚顺序 
priority_queue&lt;node&gt; heap;//建议一个关于牛棚结束时间的小根堆，找出当前技术时间最早的，拉出来 
int main()
{
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; a[i].l &gt;&gt; a[i].r;
		a[i].num = i;
	}
	//按照左端点从小到大排列
	sort(a + 1, a + 1 + n, cmp);
	int ret = 1;//记录牛棚状态
	heap.push({ a[1].r,1 });
	res[a[1].num] = 1; //一号牛进一号棚 
	for (int i = 2; i &lt;= n; i++)
	{
		int l = a[i].l, r = a[i].r;
		int ete = heap.top().l;
		int num_peng = heap.top().r;
		if (ete &gt;= l)//如果最短结束时间都&gt;这只牛的开始的起始时间，那么就必须新开一个牛棚 
		{
			ret++;
			heap.push({ r,ret });
			res[a[i].num] = ret;
		}
		else//可以拿下 
		{
			heap.pop();//结束不要了 
			heap.push({ r,num_peng });//把这只牛推入彭中 
			res[a[i].num] = num_peng;
		}
	}
	cout &lt;&lt; ret &lt;&lt; endl;
	for (int i = 1; i &lt;= n; i++)cout &lt;&lt; res[i] &lt;&lt; endl;
}</code></pre>
    <h3>
     <a href="https://www.luogu.com.cn/problem/P2859" rel="nofollow" title="P2859 [USACO06FEB] Stall Reservations S - 洛谷">
      P2859 [USACO06FEB] Stall Reservations S - 洛谷
     </a>
    </h3>
    <p>
     <img alt="" height="583" src="https://i-blog.csdnimg.cn/direct/3b49c566c48e43ebbd1bb3e840c7e961.png" width="1278"/>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="687474:70733a2f2f626c6f672e6373646e2e6e65742f57475f31372f:61727469636c652f64657461696c732f313436313339323632" class_="artid" style="display:none">
 </p>
</div>


