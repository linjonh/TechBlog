---
layout: post
title: "uniappv3开发小程序拖拽排序功能"
date: 2025-03-13 08:47:56 +0800
description: "注意: 拖动后再给原数组赋值时需加上nextTick函数,如需多行多列拖动只需再次基础上加部分逻辑即可。排序前(左图) => 排序时(右图)"
keywords: "uniapp+v3开发小程序拖拽排序功能"
categories: ['未分类']
tags: ['App']
artid: "146208402"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146208402
    alt: "uniappv3开发小程序拖拽排序功能"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146208402
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146208402
cover: https://bing.ee123.net/img/rand?artid=146208402
image: https://bing.ee123.net/img/rand?artid=146208402
img: https://bing.ee123.net/img/rand?artid=146208402
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     uniapp+v3开发小程序拖拽排序功能
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h5>
     项目需求:需要根据用户喜好手动排序(这里只需要上下排序)
    </h5>
    <p>
     排序前(左图) =&gt; 排序时(右图)
    </p>
    <p style="text-align:center">
     <img alt="" height="536" src="https://i-blog.csdnimg.cn/direct/e4b159f870964b0db6f69c1f00f81a4f.jpeg" width="285">
      <img alt="" height="545" src="https://i-blog.csdnimg.cn/direct/60704b25c6214ed98bdc0e95d5c4fffc.jpeg" width="286"/>
     </img>
    </p>
    <div class="video">
     <iframe allowfullscreen="true" data-mediaembed="csdn" frameborder="0" id="lLLBNudg-1741826866618" src="https://live.csdn.net/v/embed/468506" style="width:100%;height:100%;">
     </iframe>
     <p>
      拖动演示
     </p>
    </div>
    <h5>
     思路:
    </h5>
    <h6>
     1.创建一个拖动的元素,当拖动元素与其他元素触碰时更换位置重排列表
    </h6>
    <h6>
     2.长按元素记录起点位置与下标,并将目标元素赋值与拖动元素
    </h6>
    <h6>
     3.移动时处理触碰逻辑
    </h6>
    <h6>
     4.松手时清空拖动元素
    </h6>
    <h6>
     5.全部代码如下
    </h6>
    <h6>
     1.getPos方法获取每个元素的位置top/left,便于交互后重新排列的元素定位
    </h6>
    <h6>
     2.getIntersectRow方法根据拖动元素的top及bottom判断与那个元素相交,可能不止一个,取相交部分最多一个
    </h6>
    <pre><code class="language-javascript">&lt;template&gt;
	&lt;view class="realTime"&gt;
		&lt;uni-nav-bar dark left-icon="left" left-text="" @clickLeft="prePage" :fixed="true" shadow
			background-color="#3B45FF" status-bar title="实时参数" /&gt;
		&lt;view class="wrap boxSize" @touchmove="moveHandle" @touchend="endHandle"&gt;
			&lt;view class="paramsIt boxSize" @longpress="e =&gt; startHandle(e, index, item)" :class="{'sortIt': isSort}"
				:style="{'top':item.top + 'px', 'left': item.left + 'px'}" v-for="(item,index) in paramsList"
				:key="item.key"&gt;
				&lt;view class="left"&gt;
					&lt;image v-if="isSort" src="@/static/svg/sort.svg" mode=""&gt;&lt;/image&gt;
					&lt;view class="name"&gt;{<!-- -->{item.key}}&lt;/view&gt;
				&lt;/view&gt;
				&lt;view class="val" v-if="!isSort"&gt;{<!-- -->{`${item.val}${item.unit}`}}&lt;/view&gt;
			&lt;/view&gt;
			&lt;view class="paramsIt boxSize sortIt active" v-if="activeItem"
				:style="{'top':activeItem.top + 'px', 'left': activeItem.left + 'px'}"&gt;
				&lt;view class="left"&gt;
					&lt;image src="@/static/svg/sort.svg" mode=""&gt;&lt;/image&gt;
					&lt;view class="name"&gt;{<!-- -->{activeItem.key}}&lt;/view&gt;
				&lt;/view&gt;
			&lt;/view&gt;
		&lt;/view&gt;
		&lt;view class="btnBox boxSize"&gt;
			&lt;button type="default" style="color:#ffffff;backgroundColor:#3B45FF;borderColor:#1AAD19" class="btn"
				@tap="sortHandle"&gt;{<!-- -->{isSort ? '确认' : '参数排序'}}&lt;/button&gt;
		&lt;/view&gt;
	&lt;/view&gt;
&lt;/template&gt;

&lt;script setup&gt;
	import {
		getCurrentInstance,
		nextTick,
		reactive,
		toRefs
	} from 'vue'
	import {
		prePage,
		goPage
	} from '@/utils/util'
	import {
		request
	} from '@/utils/api'
	import {
		onLoad
	} from "@dcloudio/uni-app"

	onLoad(config =&gt; {
		openFunction(config)
	})

	let state = reactive({
		routeParams: {},
		isSort: false,
		activeIdx: null,
		activeItem: null,
		copyItem: null,
		itemHeight: 65,
		positionList: [],
		startY: '',
		paramsList: []
	})
	let {
		isSort,
		activeIdx,
		positionList,
		paramsList,
		activeItem
	} = toRefs(state)

	let pageInstance = getCurrentInstance()

	let openFunction = (config) =&gt; {
		state.routeParams = JSON.parse(JSON.stringify(config))
		getParams()
	}

	//获取所有参数
	let getParams = async () =&gt; {
		let res = await request('device/FieldOrder/current_data/', 'GET', {
			pond_id: state.routeParams.pond_id,
			user_id: JSON.parse(uni.getStorageSync('userInfo')).id
		})
		if (res) {
			state.paramsList = JSON.parse(JSON.stringify(res.data))
		}
	}

	//获取所有元素的定位信息
	let getPos = () =&gt; {
		let query = uni.createSelectorQuery(pageInstance.proxy)
		query.selectAll('.paramsIt').boundingClientRect().exec(res =&gt; {
			let arr = []
			res[0].forEach((it, idx) =&gt; {
				let obj = {}
				obj.top = (it.top - 88) + 12 * idx
				obj.left = it.left
				arr.push(obj)
			})
			state.positionList = JSON.parse(JSON.stringify(arr))
			state.paramsList.forEach((it, idx) =&gt; {
				it.top = state.positionList[idx].top
				it.left = state.positionList[idx].left
			})
		})
	}

	//开始排序
	let sortHandle = async () =&gt; {
		if (!state.isSort) {
			getPos()
			state.isSort = true
			return
		}
		
		let paramsList = state.paramsList.map(it =&gt; ({
			key: it.key,
			val: it.val,
			unit: it.unit,
			status: it.status
		}))

		let res = await request('device/FieldOrder/', 'POST', {
			pond_id: state.routeParams.pond_id,
			user_id: JSON.parse(uni.getStorageSync('userInfo')).id,
			result: paramsList
		})

		if (res) {
			uni.showToast({
				icon: 'none',
				title: '操作成功!'
			})
			state.isSort = false
			getParams()
		}
	}

	//按下
	let startHandle = (e, index, item) =&gt; {
		if (!state.isSort) return
		state.activeIdx = index
		state.activeItem = JSON.parse(JSON.stringify(item))
		state.startY = e.touches[0].clientY
	}

	//移动
	let moveHandle = (e, index) =&gt; {
		if (!state.activeItem) return

		//元素跟随鼠标移动
		let diffY = e.touches[0].clientY - state.startY
		state.activeItem.top = state.activeItem.top + diffY
		state.startY = e.touches[0].clientY

		//判断交叉元素
		let dragTop = state.activeItem.top
		let dragBtm = dragTop + state.itemHeight
		let intersectRow = getIntersectRow(dragTop, dragBtm)
		if (!intersectRow) return
		let intersectIdx = state.positionList.findIndex(i =&gt; i.top == intersectRow.top)

		//其他元素变换位置
		let copyParams = [...state.paramsList]
		if (intersectIdx !== state.activeIdx) {
			copyParams.splice(state.activeIdx, 1)
			copyParams.splice(intersectIdx, 0, state.paramsList[state.activeIdx])
			copyParams.forEach((it, idx) =&gt; {
				it.top = state.positionList[idx].top
				it.left = state.positionList[idx].left
			})
			state.activeIdx = intersectIdx
			nextTick(() =&gt; {
				state.paramsList = [...copyParams]
			})
		}
	}

	//抬起
	let endHandle = (e, index) =&gt; {
		state.activeIdx = null
		state.activeItem = null
	}

	//交叉元素
	let getIntersectRow = (dragTop, dragBtm) =&gt; {
		let filter = state.positionList.filter(it =&gt; {
			let acmeFlag = it.top &lt; dragTop &amp;&amp; (it.top + state.itemHeight) &gt; dragTop
			let lowFlag = it.top &lt; dragBtm &amp;&amp; (it.top + state.itemHeight) &gt; dragBtm
			return acmeFlag || lowFlag
		})
		//取最近一个
		let midY = dragTop + state.itemHeight / 2
		filter.forEach(i =&gt; i.diffY = Math.abs((i.top + state.itemHeight / 2) - midY))
		filter.sort((a, b) =&gt; a.diffY - b.diffY)
		return filter[0] || null
	}
&lt;/script&gt;

&lt;style lang="scss" scoped&gt;
	.realTime {
		width: 100%;
		height: 100%;

		.wrap {
			width: 100%;
			height: calc(100% - 160px);
			padding: 12px 18px;
			overflow-y: auto;
			border-radius: 8px;
			position: relative;

			.paramsIt {
				position: relative;
				width: 100%;
				height: 65px;
				padding: 0 20px;
				display: flex;
				align-items: center;
				justify-content: space-between;
				background-color: #fff;
				transition: all 0.3s ease; // 添加过渡效果

				.left {
					display: flex;
					align-items: center;

					image {
						width: 24px;
						height: 24px;
						margin-right: 10px;
					}

					.name {
						font-family: PingFang SC;
						font-size: 18px;
						font-weight: 500;
						line-height: normal;
						letter-spacing: 0px;
						font-variation-settings: "opsz" auto;
						/* 正文色/正文色 */
						color: #1A1A1A;
					}
				}

				.val {
					font-family: PingFang SC;
					font-size: 18px;
					font-weight: normal;
					line-height: normal;
					text-align: right;
					letter-spacing: 0px;
					font-variation-settings: "opsz" auto;
					/* 字体/次要文字 */
					color: #909399;
				}
			}

			.sortIt {
				position: absolute;
				width: calc(100% - 36px);
				border-radius: 8px;
				margin-bottom: 12px;
			}

			.active {
				box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
				/* 添加阴影 */
				opacity: 0.8;
				/* 降低透明度 */
				// 确保拖拽元素在最上层
				z-index: 2;
				// 拖拽元素禁用过渡
				transition: none !important;
			}
		}

		.btnBox {
			width: 100%;
			padding: 0 18px;
			display: flex;
			align-items: center;
			justify-content: space-between;

			.btn {
				width: 100%;
			}
		}
	}
&lt;/style&gt;</code></pre>
    <p>
     <span style="color:#fe2c24">
      注意: 拖动后再给原数组赋值时需加上nextTick函数,如需多行多列拖动只需再次基础上加部分逻辑即可
     </span>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f36303634383636382f:61727469636c652f64657461696c732f313436323038343032" class_="artid" style="display:none">
 </p>
</div>


