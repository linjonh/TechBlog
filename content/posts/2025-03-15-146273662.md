---
arturl_encode: "68747470733a2f2f626c6f:672e6373646e2e6e65742f79696e68657a68616e7368656e2f:61727469636c652f64657461696c732f313436323733363632"
layout: post
title: "rust-的Clone"
date: 2025-03-15 07:42:27 +0800
description: "编程语言中一个核心特质（trait）， 定义了类型如何安全、明确地创建其值的深拷贝（deep copy）。如果要想Item类的变量赋值后所有权继续有效，就需要Item类实现clone()。报错的意思是变量a的所有权已经被移动到b，所以println！下面用实例来演示Clone的作用，先看一下如下的代码，注意此代码编译不过。方案一：手动为Item类实现trait Clone。"
keywords: "rust 的Clone"
categories: ['未分类']
tags: ['开发语言', 'Rust']
artid: "146273662"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146273662
    alt: "rust-的Clone"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146273662
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146273662
cover: https://bing.ee123.net/img/rand?artid=146273662
image: https://bing.ee123.net/img/rand?artid=146273662
img: https://bing.ee123.net/img/rand?artid=146273662
---

# rust 的Clone

`Clone`
是
[Rust](https://so.csdn.net/so/search?q=Rust&spm=1001.2101.3001.7020 "Rust")
编程语言中一个核心特质（trait）， 定义了类型如何安全、明确地创建其值的深拷贝（deep copy）。

下面用实例来演示Clone的作用，先看一下如下的代码，注意此代码编译不过。

```rust
#[derive(Debug)]
struct Item{
    value: i32,
}

fn main() {
    let a = Item{value:7};
    let b = a;
    println!("value a {:?}, value b {:?}", a, b);
}
```

编译报错：

> cargo run
>   
>   
> error[E0382]: borrow of moved value: `a`
>   
> --> src/main.rs:10:44
>   
> |
>   
> 8  |     let a = Item{value:7};
>   
> |         - move occurs because `a` has type `Item`, which does not implement the `Copy` trait
>   
> 9  |     let b = a;
>   
> |             - value moved here
>   
> 10 |     println!("value a {:?}, value b {:?}", a, b);
>   
> |                                            ^ value borrowed here after move
>   
> |
>   
> note: if `Item` implemented `Clone`, you could clone the value
>   
> --> src/main.rs:3:1
>   
> |
>   
> 3  | struct Item{
>   
> | ^^^^^^^^^^^ consider implementing `Clone` for this type
>   
> ...
>   
> 9  |     let b = a;
>   
> |             - you could clone this value
>   
> = note: this error originates in the macro `$crate::format\_args\_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
>
> For more information about this error, try `rustc --explain E0382`.

报错的意思是变量a的所有权已经被移动到b，所以println！无法再使用a。

如果要想Item类的变量赋值后所有权继续有效，就需要Item类实现clone()。

方案一：手动为Item类实现trait Clone

```rust
#[derive(Debug)]
struct Item{
    value: i32,
}

impl Clone for Item{
    fn clone(&self) -> Self{
        Item { value: self.value, }
    }
}

fn main() {
    let a = Item{value:7};
    let b = a.clone();
    println!("value a {:?}, value b {:?}", a, b);
}
```

编译运行：

> Running `target\debug\greeting.exe`
>   
> value a Item { value: 7 }, value b Item { value: 7 }

方案二：

使用
**属性（Attribute）**

```rust
#[derive(Debug, Clone)]
struct Item{
    value: i32,
}


fn main() {
    let a = Item{value:7};
    let b = a.clone();
    println!("value a {:?}, value b {:?}", a, b);
}
```

编译运行

> Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
>   
> Running `target\debug\greeting.exe`
>   
> value a Item { value: 7 }, value b Item { value: 7 }