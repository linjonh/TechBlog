---
layout: post
title: "2024年我的Serverless实战大前端趋势之Serverless从入门到天黑,前端开发还会吃香吗"
date: 2024-12-02 09:44:21 +0800
description: "开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】大厂面试问深度，小厂面"
keywords: "前端 serverless"
categories: ['程序员']
tags: ['前端', '云原生', 'Serverless']
artid: "138517214"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=138517214
    alt: "2024年我的Serverless实战大前端趋势之Serverless从入门到天黑,前端开发还会吃香吗"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=138517214
featuredImagePreview: https://bing.ee123.net/img/rand?artid=138517214
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     2024年我的Serverless实战——大前端趋势之Serverless从入门到天黑，前端开发还会吃香吗
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="markdown_views prism-atom-one-dark" id="content_views">
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
     <path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);">
     </path>
    </svg>
    <h5>
     <a id="_0">
     </a>
     最后
    </h5>
    <hr/>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618166371">
       开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
      </a>
     </strong>
    </p>
    <p>
     大厂面试问深度，小厂面试问广度，如果有同学想进大厂深造一定要有一个方向精通的惊艳到面试官，还要平时遇到问题后思考一下问题的本质，找方法解决是一个方面，看到问题本质是另一个方面。还有大家一定要有目标，我在很久之前就想着以后一定要去大厂，然后默默努力，每天看一些大佬们的文章，总是觉得只有再学深入一点才有机会，所以才有恒心一直学下去。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/95478655fa0a05157d91109abf49b34e.png"/>
    </p>
    <p>
     BaaS（Backend as a Service，后端即服务）是指我们不再编写或管理所有服务端组件，可以使用领域通用的远程组件（而不是进程内的库）来提供服务。理解BaaS，需要搞清楚它与PaaS的区别。
    </p>
    <p>
     首先BaaS并非PaaS，它们的区别在于：PaaS需要参与应用的生命周期管理，BaaS则仅仅提供应用依赖的第三方服务。典型的PaaS平台需要提供手段让开发者部署和配置应用，例如自动将应用部署到Tomcat容器中，并管理应用的生命周期。BaaS不包含这些内容，BaaS只以API的方式提供应用依赖的后端服务，例如数据库和对象存储。BaaS可以是公共云服务商提供的，也可以是第三方厂商提供的。其次从功能上讲，BaaS可以看作PaaS的一个子集，即提供第三方依赖组件的部分。
    </p>
    <p>
     BaaS服务还允许我们依赖其他人已经实现的应用逻辑。对于这点，认证就是一个很好的例子。很多应用都要自己编写实现注册、登录、密码管理等逻辑的代码，而对于不同的应用这些代码往往大同小异。完全可以把这些重复性的工作提取出来，再做成外部服务，而这正是Auth0和Amazon Cognito等产品的目标。它们能实现全面的认证和用户管理，开发团队再也不用自己编写或者管理实现这些功能的代码。
    </p>
    <h4>
     <a id="Serverless_27">
     </a>
     Serverless计算如何工作？
    </h4>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/b3f7296bed188868269ccc9b76faaa43.png"/>
    </p>
    <p>
     <strong>
      同步调用
     </strong>
     的特性是，客户端期待服务端立即返回计算结果。请求到达函数计算时，会立即分配执行环境执行函数。
    </p>
    <p>
     以 API 网关为例，API 网关同步触发函数计算，客户端会一直等待服务端的执行结果，如果执行过程中遇到错误， 函数计算会将错误直接返回，而不会对错误进行重试。这种情况下，需要客户端添加重试机制来做错误处理。
    </p>
    <p>
     <strong>
      异步调用
     </strong>
     的特性是，客户端不急于立即知道函数结果，函数计算将请求丢入队列中即可返回成功，而不会等待到函数调用结束。
    </p>
    <p>
     函数计算会逐渐消费队列中的请求，分配执行环境，执行函数。如果执行过程中遇到错误，函数计算会对错误的请求进行重试，对函数错误重试三次，系统错误会以指数退避方式无限重试，直至成功。
    </p>
    <p>
     异步调用适用于数据的处理，比如 OSS 触发器触发函数处理音视频，日志触发器触发函数清洗日志，都是对延时不敏感，又需要尽可能保证任务执行成功的场景。如果用户需要了解失败的请求并对请求做自定义处理，可以使用 Destination 功能。函数计算是 Serverless 的，这不是说无服务器，而是开发者无需关心服务器，函数计算会为开发者分配实例执行函数。
    </p>
    <h4>
     <a id="Serverless_55">
     </a>
     Serverless使用场景
    </h4>
    <p>
     <strong>
      <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/342c5d7f39e04013625c7219001ad2a5.png"/>
     </strong>
    </p>
    <p>
     <strong>
      发送通知
     </strong>
    </p>
    <p>
     诸如 PUSH Notification、邮件通知接口、短信，这一类服务来说，他们都需要基础设施来搭建。并且，他们对实时性的要求相对没有那么高。即使在时间上晚来几秒钟，用户还是能接受的。在我们所见到的短信发送的例子里，一般都会假设用户能在 60 秒内收到短信。因此，在这种时间 1s 的误差，用户也不会恼火的。
    </p>
    <p>
     <strong>
      轻量级 API
     </strong>
    </p>
    <p>
     Serverless 特别适合于，轻量级快速变化地 API。其实，我一直没有想到一个合适的例子。在我的假想里，一个 AutoSuggest 的 API 可能就是这样的 API，但是这种 API 在有些时候，往往会伴随着相当复杂的业务。于是，便想举一个 Featrue Toggle 的例子，尽管有一些不合适。但是，可能是最有价值的部分。
    </p>
    <p>
     <strong>
      物联网
     </strong>
    </p>
    <p>
     当我们谈及物联网的时候，我们会讨论事件触发、传输协议、海量数据（数据存储、数据分析）。而有了 Serverless，那么再多的数据，处理起来也是相当容易的一件事。对于一个物联网应用的服务端来说，系统需要收集来自各个地方的数据，并创建一个个 pipeline 来处理、过滤、转换这些数据，并将数据存储到数据库中。对于硬件开发人员来说，对接不同的硬件，本身就是一种挑战。而直接使用诸如 AWS IoT 这样国，可以在某种程度上，帮助我们更好地开发出写服务端连接的应用。
    </p>
    <p>
     <strong>
      数据统计分析等
     </strong>
    </p>
    <p>
     数据统计本身只需要很少的计算量，但是生成图表，则可以定期生成。在接收数据的时候，我们不需要考虑任何延时带来的问题。50~200 ms 的延时，并不会对我们的系统造成什么影响。
    </p>
    <h4>
     <a id="Serverless_95">
     </a>
     Serverless优缺点
    </h4>
    <p>
     <strong>
      优点
     </strong>
    </p>
    <p>
     1. 更快的上市时间我们可以更快地将应用程序推向市场，因为OPS变得更加简单，并且将帮助开发人员专注于他们的开发。 OPS团队无需编写可以处理扩展或担心底层基础架构的代码。此外，团队可以在第三方集成的帮助下更快地构建应用程序，例如OAuth，Twitter和Maps等API服务。
    </p>
    <p>
     2.高度可扩展性每家公司都希望他们的应用程序能够更好地运行，零停机时间，并且随着流量的增加而快速，轻松地扩展，但是通过单一的应用程序开发，它可能变得非常困难。随着应用程序负载的增加，Ops团队必须在扩展底层基础架构时保持警惕。由于交通量的增加，停机时间浪费了大量的时间和金钱。但无服务器计算具有高度可扩展性，可以在几秒钟内对应用程序进行缩放和缩放。
    </p>
    <p>
     3.低成本在无服务器计算中，开发人员仅在功能运行时付费，与IaaS和PaaS不同，IaaS和PaaS为每台服务器24/7收费。这对于拥有庞大的应用程序，API或微服务设置的公司来说非常有用，这些应用程序，API或微服务目前全天候运行并且100％的时间使用资源，无论是否需要。但是对于无服务器，我们可以按需执行功能并共享资源，而不是全天候运行应用程序，因此我们可以大大减少空闲时间，并使应用程序运行得更快。
    </p>
    <p>
     4.延迟和地理定位。改进应用程序的可扩展性取决于三个因素：用户数量，用户位置和网络延迟。在当今世界，应用程序拥有全球受众，这可能会增加延迟。但是无服务器平台可以大大减轻延迟的危险。使用无服务器时，实例化容器以在每个事件调用时运行函数，并且可以在用户的​​地理区域附近创建此容器，这将自动提高应用程序的性能。
    </p>
    <p>
     <strong>
      缺点
     </strong>
    </p>
    <p>
     1.复杂性增加我们使用应用程序越精细，它就越复杂。每个函数的代码可能会变得更简单，但整个应用程序将变得更加复杂。比如说，我们将应用程序分解为10个不同的微服务。我们必须管理10个不同的应用程序，而在单个应用程序中，它只是一个必须管理的应用程序。
    </p>
    <p>
     2.缺乏工具支持 假设我们将单片应用程序分解为50种不同的功能。仍然有各种各样的流程和工具来管理，记录，监视和部署整体应用程序。由于无服务器是市场上的新产品，因此监控或记录运行几秒钟的应用程序是有限的并且具有挑战性，但是随着时间的推移，将会有许多有效的方法来实现这一点。
    </p>
    <p>
     3. 与体系结构的复杂性很难决定函数的粒度，并且评估，实现和测试以检查我们的首选项是耗时的。
    </p>
    <p>
     4. 管理太多功能会很麻烦，同时忽略粒度会导致我们设置迷你巨石。
    </p>
    <p>
     5.实施中的缺点无服务器的最大挑战是集成测试难。
    </p>
    <h4>
     <a id="_143">
     </a>
     小白操作指南
    </h4>
    <p>
     <strong>
      安装
     </strong>
    </p>
    <p>
     Serverless是
     <a href="" rel="nofollow">
      Node.js
     </a>
     CLI工具，因此您要做的第一件事是在计算机上安装Node.js。
    </p>
    <blockquote>
     <p>
      注意：无服务器在Node v6或更高版本上运行。
     </p>
    </blockquote>
    <blockquote>
     <p>
      打开一个终端，然后键入
      <code>
       npm install -g serverless
      </code>
      以安装Serverless。
     </p>
    </blockquote>
    <p>
     安装过程完成后，您可以通过在终端中运行以下命令来验证是否成功安装了Serverless：
    </p>
    <blockquote>
     <p>
      serverless
     </p>
    </blockquote>
    <p>
     要查看已安装的无服务器版本：
    </p>
    <p>
     serverless --version
    </p>
    <p>
     <strong>
      测试
     </strong>
    </p>
    <p>
     将业务逻辑与FaaS Provider分开
    </p>
    <p>
     class Users { constructor(db, mailer) { this.db = db; this.mailer = mailer; } save(email, callback) { const user = { email: email, created_at: Date.now(), }; this.db.saveUser(user, function (err) { if (err) { callback(err); } else { this.mailer.sendWelcomeEmail(email); callback(); } }); } } module.exports = Users;
    </p>
    <p>
     const db = require(‘db’).connect(); const mailer = require(‘mailer’); const Users = require(‘users’); let users = new Users(db, mailer); module.exports.saveUser = (event, context, callback) =&gt; { users.save(event.email, callback); };
    </p>
    <p>
     现在，以上类将业务逻辑分开。此外，负责设置依赖关系，注入依赖关系，调用业务逻辑功能以及与AWS Lambda交互的代码位于其自己的文件中，该文件的更改频率较低。这样，业务逻辑就不依赖于提供程序，更易于重用和测试。
    </p>
    <p>
     此外，此代码不需要运行任何外部服务。取而代之的是真正的
     <code>
      db
     </code>
     和
     <code>
      mailer
     </code>
     服务，我们可以通过模拟考试，并断言，如果
     <code>
      saveUser
     </code>
     和
     <code>
      sendWelcomeEmail
     </code>
     被调用适当的参数。
    </p>
    <p>
     可以很容易地编写单元测试以涵盖上述课程。可以通过调用
     <code>
      serverless invoke
     </code>
     带有夹具电子邮件地址的功能（）来添加集成测试，检查用户是否确实保存到数据库中，并检查是否收到了电子邮件以查看是否一切正常。
    </p>
    <p>
     <strong>
      部署
     </strong>
    </p>
    <p>
     使用无服务器框架进行部署：
    </p>
    <p>
     serverless deploy
    </p>
    <p>
     无服务器框架将所有语法
     <code>
      serverless.yml
     </code>
     转换为单个AWS CloudFormation模板。通过依靠CloudFormation进行部署，无服务器框架的用户可以获得CloudFormation的安全性和可靠性。
    </p>
    <blockquote>
     <ul>
      <li>
       AWS CloudFormation模板是从中创建的
       <code>
        serverless.yml
       </code>
       。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       如果尚未创建堆栈，则创建该堆栈时除了S3存储桶（S3存储桶）外，将不存储任何资源，S3存储桶将存储您的功能代码的zip文件。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       如果您使用本地构建的ECR映像，则会为您的服务创建专用的ECR存储库。
       <code>
        docker login
       </code>
       如果需要，您还将通过登录到该存储库。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       然后，您的功能代码将打包为zip文件。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       如果您使用本地构建的ECR图像，则将它们构建并上传到ECR。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       无服务器获取前一次部署的所有文件的哈希（如果有），并将其与本地文件的哈希进行比较。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       如果所有文件哈希都相同，则Serverless会终止部署过程。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       您的功能代码的Zip文件已上传到您的代码S3存储桶。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       任何IAM角色，功能，事件和资源都会添加到AWS CloudFormation模板中。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       CloudFormation堆栈已使用新的CloudFormation模板进行了更新。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       每个部署都会为服务中的每个功能发布一个新版本。
      </li>
     </ul>
    </blockquote>
    <p>
     部署功能
    </p>
    <p>
     serverless deploy function --function myFunction
    </p>
    <p>
     部署程序包
    </p>
    <p>
     serverless deploy --package path-to-package
    </p>
    <blockquote>
     <ul>
      <li>
       该
       <code>
        --package
       </code>
       标志的参数是先前由Serverless（带有
       <code>
        serverless package
       </code>
       ）打包的目录。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       部署过程绕过了软件包步骤，并使用现有的软件包来部署和更新CloudFormation堆栈。
      </li>
     </ul>
    </blockquote>
    <h4>
     <a id="_295">
     </a>
     工作流程
    </h4>
    <p>
     <strong>
      开发流程
     </strong>
    </p>
    <blockquote>
     <ol>
      <li>
       编写你的函数
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <ol start="2">
      <li>
       <code>
        serverless deploy
       </code>
       仅在
       <code>
        serverless.yml
       </code>
       对CI / CD系统进行更改时使用。有关为无服务器应用程序设置CI / CD的更多信息，请阅读
       <a href="" rel="nofollow">
        本文
       </a>
       。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <ol start="3">
      <li>
       在使用
       <code>
        serverless deploy function -f myFunction
       </code>
       特定的AWS Lambda函数时，可用于快速部署更改。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <ol start="4">
      <li>
       用于
       <code>
        serverless invoke -f myFunction -l
       </code>
       在AWS上测试您的AWS Lambda函数。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <ol start="5">
      <li>
       在控制台中打开一个单独的选项卡，然后通过进入流日志
       <code>
        serverless logs -f myFunction -t
       </code>
       。
      </li>
     </ol>
    </blockquote>
    <blockquote>
     <ol start="6">
      <li>
       编写测试以在本地运行。
      </li>
     </ol>
    </blockquote>
    <p>
     <strong>
      使用阶段
     </strong>
    </p>
    <blockquote>
     <ul>
      <li>
       至少要使用
       <code>
        dev
       </code>
       and
       <code>
        production
       </code>
       阶段。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       将不同的AWS账户用于阶段。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       在较大的团队中，每个成员应使用一个单独的AWS账户和自己的开发阶段。
      </li>
     </ul>
    </blockquote>
    <p>
     <strong>
      较大的项目
     </strong>
    </p>
    <blockquote>
     <ul>
      <li>
       将您的应用程序/项目分解为多个无服务器服务。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       围绕数据模型或工作流对无服务器服务进行建模。
      </li>
     </ul>
    </blockquote>
    <blockquote>
     <ul>
      <li>
       将无服务器服务中的功能和资源保持在最低限度。
      </li>
     </ul>
    </blockquote>
    <h5>
     <a id="_341">
     </a>
     总结一下
    </h5>
    <p>
     面试前要精心做好准备，简历上写的知识点和原理都需要准备好，项目上多想想难点和亮点，这是面试时能和别人不一样的地方。
    </p>
    <p>
     还有就是表现出自己的谦虚好学，以及对于未来持续进阶的规划，企业招人更偏爱稳定的人。
    </p>
    <p>
     万事开头难，但是程序员这一条路坚持几年后发展空间还是非常大的，一切重在坚持。
    </p>
    <p>
     <strong>
      <a href="https://bbs.csdn.net/topics/618166371">
       开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
      </a>
     </strong>
    </p>
    <p>
     为了帮助大家更好更高效的准备面试，特别整理了《前端工程师面试手册》电子稿文件。
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/60cb7c1b74474d7e5a5546cc285d7586.png"/>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/8bb05c431555e98a9a843fe5fa668b9d.png"/>
    </p>
    <p>
     <strong>
      前端面试题汇总
     </strong>
    </p>
    <p>
     <img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/0e3e725c2b52c0d80cc380a18efe5fd9.png"/>
    </p>
   </div>
   <link href="../../assets/css/markdown_views-a5d25dd831.css" rel="stylesheet"/>
   <link href="../../assets/css/style-e504d6a974.css" rel="stylesheet"/>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323430315f38343433343038362f:61727469636c652f64657461696c732f313338353137323134" class_="artid" style="display:none">
 </p>
</div>


