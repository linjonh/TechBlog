---
layout: post
title: "MySQL事务概念如何回滚基本特性MySQL事务隔离性具体怎么实现的"
date: 2025-03-07 12:37:21 +0800
description: "A1：这里并不是真的没执行，事务中的若干个SQL必然是要一条一条执行的，事务能够保证，当执行到某一条的时候如果出现问题了（程序崩溃，系统崩溃，网络断开，主机掉电了...），数据库就能够自动的把前面SQL操作的影响，给恢复回去，看起来就好像一条SQL都没执行的样子。日常开发中，有很操作，不是通过一个SQL就能完成的，往往需要多个SQL配合完成，当执行多个SQL操作的时候，如果中间出现了特殊的情况（程序崩溃，系统崩溃，网络断开，主机掉电了...），就可能会出现前面SQL执行成功，后面的SQL执行失败了。"
keywords: "【MySQL】事务|概念|如何回滚|基本特性|MySQL事务隔离性具体怎么实现的"
categories: ['未分类']
tags: ['数据库', 'Mysql']
artid: "146082709"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146082709
    alt: "MySQL事务概念如何回滚基本特性MySQL事务隔离性具体怎么实现的"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146082709
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146082709
cover: https://bing.ee123.net/img/rand?artid=146082709
image: https://bing.ee123.net/img/rand?artid=146082709
img: https://bing.ee123.net/img/rand?artid=146082709
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【MySQL】事务|概念|如何回滚|基本特性|MySQL事务隔离性具体怎么实现的
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="./../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="./../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <h3>
     1.为啥引入
    </h3>
    <p>
     <strong>
      多个SQL配合，出现特殊情况，前面执行了，后面没执行
     </strong>
    </p>
    <p>
     日常开发中，有很操作，不是通过一个SQL就能完成的，往往需要多个SQL配合完成，当执行多个SQL操作的时候，如果中间出现了特殊的情况（程序崩溃，系统崩溃，网络断开，主机掉电了...），就可能会出现前面SQL执行成功，后面的SQL执行失败了
    </p>
    <p>
     <strong>
      举例（具体场景）：
     </strong>
    </p>
    <p>
     库存表（id，count）
    </p>
    <p>
     订单表（orderId，userId，goodId...）
    </p>
    <p>
     进行下单操作，触发库表数据-1 &amp;&amp; 订单表新增记录
    </p>
    <p>
     经常会涉及到通过多个SQL配合，完成某个操作的
    </p>
    <p>
     这个时候就需要使用到事务，来确保上述的操作，是可靠的，完整的
    </p>
    <hr/>
    <h3 id="2.%E6%98%AF%E5%95%A5" name="2.%E6%98%AF%E5%95%A5">
     2.是啥
    </h3>
    <p>
     <strong>
      事务
     </strong>
     ，就是把多个操作，打包成一个整体，就能够保证，这个整体要么都执行成功，要么就一个都不执行，有效避免部分执行，部分未执行，产生的一些”中间状态引起的问题“
    </p>
    <blockquote>
     <p>
      <strong>
       原子性
      </strong>
      ：把多个操作，打包成一个整体
     </p>
    </blockquote>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       Q1
      </span>
     </span>
     ：什么叫”一个都不执行“的理解
    </p>
    <p>
     A1：这里并不是真的没执行，事务中的若干个SQL必然是要一条一条执行的，事务能够保证，当执行到某一条的时候如果出现问题了（程序崩溃，系统崩溃，网络断开，主机掉电了...），数据库就能够自动的把前面SQL操作的影响，给恢复回去，看起来就好像一条SQL都没执行的样子
    </p>
    <p>
     其实这里翻新的操作，成为”
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       回滚
      </span>
     </span>
     “
    </p>
    <p>
     <strong>
      数据库事务的原子性，核心就是通过”回滚“机制来保证的
     </strong>
    </p>
    <hr/>
    <h3 id="3.%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89" name="3.%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89">
     3.如何回滚（日志）
    </h3>
    <p>
     为了实现回滚机制，数据库会在执行事务的时候，记录
     <strong>
      日志
     </strong>
     ，数据库的日志是写入到
     <strong>
      硬盘的文件
     </strong>
     中
    </p>
    <p>
     当事务最终都执行完毕，中间没有差错，这些记录的内容就可以不要了
    </p>
    <p>
     但是如果执行事务的过程中，
     <strong>
      出现了问题，MySQL就可以根据日志中记录的内容，来进行
     </strong>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       恢复操作
      </span>
     </span>
    </p>
    <p>
     1）之前进行了新增操作，就把数据删掉
    </p>
    <p>
     2）之前进行了删除操作，就把数据新增上来
    </p>
    <p>
     3）之前进行了修改操作，就把数据改回去
    </p>
    <p>
     4）之前是查询操作，不影响，不需要任何恢复行为
    </p>
    <p>
     只要数据库处于正常工作状态，就能够始终保证事务前面进行的操作被正确回滚（关系型数据库一般都能够支持这一点）
    </p>
    <p>
     eg：
    </p>
    <p>
     程序崩溃/网络断开：程序崩溃，但数据库是正常的，就直接进行回滚操作即可
    </p>
    <p>
     系统崩溃/主机掉电了：这种情况MySQL服务器也挂了，那么无法立即回滚，过一段时间程序员把环境进行恢复的时候，数据库能重新启动的时候，就能够发现上次有个事务出问题了，按照前面记录的日志内容进行回滚
    </p>
    <hr/>
    <h3 id="%F0%9F%94%A54.%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7" name="%F0%9F%94%A54.%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">
     <a href="https://blog.csdn.net/qq_73017178/article/details/146036644?spm=1001.2014.3001.5501#t7" title="🔥">
      🔥
     </a>
     4.面试题：谈谈事务的基本特性
    </h3>
    <h4 id="%EF%BC%881%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7" name="%EF%BC%881%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7">
     （1）原子性
    </h4>
    <p>
     有回滚机制，能够触发还原
    </p>
    <h4 id="%EF%BC%882%EF%BC%89%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E6%94%B6%E5%85%A5%E5%92%8C%E6%94%AF%E5%87%BA%E7%9B%B8%E5%8C%B9%E9%85%8D%EF%BC%89" name="%EF%BC%882%EF%BC%89%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E6%94%B6%E5%85%A5%E5%92%8C%E6%94%AF%E5%87%BA%E7%9B%B8%E5%8C%B9%E9%85%8D%EF%BC%89">
     （2）一致性（收入和支出相匹配）
    </h4>
    <p>
     执行事务之前，和执行事务完毕之后，数据是一致的（不会出现这种”对不上“的情况）
    </p>
    <p>
     也是和回滚有关的，一旦触发回滚了，回滚回去的数据得是对的；如果顺利执行，没有触发回滚，数据也是符合要求的
    </p>
    <p>
     这个特性其实是对：
     <strong>
      ”数据正确“的承诺
     </strong>
    </p>
    <h4 id="%EF%BC%883%EF%BC%89%E6%8C%81%E4%B9%85%E6%80%A7" name="%EF%BC%883%EF%BC%89%E6%8C%81%E4%B9%85%E6%80%A7">
     （3）持久性
    </h4>
    <p>
     执行事务对数据库产生的修改，就会在
     <strong>
      硬盘上持久保存
     </strong>
     ，重启后仍然存在
    </p>
    <p>
     但凡见到“
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       持久性
      </span>
     </span>
     ”就要联想到一件事：把
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       数据存储在硬盘上
      </span>
     </span>
    </p>
    <p>
     此处的持久，程序重启/主机重启。数据仍然能存在，但是如果存储在内存中，就不是持久的，内存中的数据会随着程序重启/主机重启而消息
    </p>
    <p>
     <strong>
      Q1
     </strong>
     ：数据不丢失和持久性一样吗
    </p>
    <p>
     不丢失 = 持久性 + 一致性
    </p>
    <h4 id="%F0%9F%94%A5%EF%BC%884%EF%BC%89%E9%9A%94%E7%A6%BB%E6%80%A7" name="%F0%9F%94%A5%EF%BC%884%EF%BC%89%E9%9A%94%E7%A6%BB%E6%80%A7">
     🔥（4）
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       隔离性
      </span>
     </span>
    </h4>
    <p>
     <strong>
      1）为何会有这个特性
     </strong>
    </p>
    <p>
     如果多个客户端正好把
     <strong>
      事务赶到一块
     </strong>
     了，就需要数据库服务器都能给出处理，更糟糕的是，如果这多个事务都尝试操作同一个表，情况就会更复杂（并发处理的，这样速度比一个一个处理速度快）
    </p>
    <p>
     <strong>
      2）如果一起同时处理，可能出现的问题
     </strong>
    </p>
    <h5 id="%E8%84%8F%E8%AF%BB%E9%97%AE%E9%A2%98" name="%E8%84%8F%E8%AF%BB%E9%97%AE%E9%A2%98">
     <strong>
      <span style="color:#be191c">
       <span style="background-color:#fef2f0">
        脏读问题
       </span>
      </span>
     </strong>
    </h5>
    <h6 id="%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" name="%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
     是什么？
    </h6>
    <p>
     数据库中，如果有事务A和事务B，事务A针对某个表做出了一些修改，在事务A提交之前（也就是commit告诉数据库服务器，事务完毕之前），事务B就对这里的数据进行了读取，最终就可能出现A后续操作又把上述数据进行了修改，导致最终B读到的数据和A提交的数据，是不同的
    </p>
    <p>
     <strong>
      即事务B读到的是一个“临时数据”（也就是脏数据），临时数据可能会随时被修改掉
     </strong>
    </p>
    <h6 id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F" name="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F">
     如何解决？
    </h6>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       针对"写操作“加锁
      </span>
     </span>
     ，A这边写的时候，B不能读，A写完了，B才能读
    </p>
    <p>
     未加锁之前：执行A的同时，也能执行B（同时执行）
    </p>
    <p>
     加锁后：执行A的过程中，B就不能执行了，要等待
    </p>
    <p>
     这就相当于
     <strong>
      降低了”并发能力“
     </strong>
     ，也就会降低数据库服务器的处理效率，
     <strong>
      提高了”隔离性“，也提高了数据的准确性
     </strong>
    </p>
    <h5 id="%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98" name="%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98">
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       不可重复读问题
      </span>
     </span>
    </h5>
    <h6 id="%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" name="%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
     是什么？
    </h6>
    <p>
     存在三个事务.ABC.
    </p>
    <p>
     事务A针对数据进行修改，提交；
    </p>
    <p>
     接下来事务B进行读取数据（事务B这里的多个sql都要进行读操作）;
    </p>
    <p>
     在执行B的过程中又有一个事务C，又针对数据进行了修改
    </p>
    <p>
     就会使B里面的不同读操作，读出来的结果不一样.
    </p>
    <h6 id="%E5%9B%BE%E8%A7%A3%E2%80%8B%E7%BC%96%E8%BE%91" name="%E5%9B%BE%E8%A7%A3%E2%80%8B%E7%BC%96%E8%BE%91">
     图解
     <img alt="" height="436" src="https://i-blog.csdnimg.cn/direct/0d33a4db5c8b41e4b016c786e4f1fb23.png" width="851"/>
    </h6>
    <p>
     开始读的数据和结束读的数据，存在差异
    </p>
    <h6 id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F" name="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F">
     如何解决？
    </h6>
    <p>
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       引入读加锁
      </span>
     </span>
     ，就会使“并发程度”又进一步降低，效率也随之降低“隔离性”又进一步提高，数据的准确性也会提高.这个时候，ABC都不能并发了.
    </p>
    <h5 id="%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98" name="%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98">
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       幻读问题
      </span>
     </span>
    </h5>
    <h6 id="%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" name="%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
     是什么？
    </h6>
    <p>
     事务A先修改并提交数据，事务B进行读数据.此时事务C，没有修改B读的数据，但是给对应的表进行了新增数据/删除数据等操作..导致事务B中，读到的数据集不同（已有的数据内容是一致的，数都是据的条数增加/减少）
    </p>
    <p>
     可以视为是“不可重复读”的特殊情况
    </p>
    <blockquote>
     <p>
      简单理解：读的数据内容不变，但是数据量多了
     </p>
     <p>
      而不可重复读：读的数据内容变了
     </p>
    </blockquote>
    <h6 id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F" name="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F">
     如何解决？
    </h6>
    <p>
     解决幻读的方式，“
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       串行化
      </span>
     </span>
     ”使所有的事务都严格的按照“一个接一个”的方式执行.完全没有并发了.此时执行效率是最低的，隔离性也是最高的，数据也是最准确的.
    </p>
    <p>
     <strong>
      小结：
     </strong>
    </p>
    <blockquote>
     <p>
      &lt;1&gt; 脏读：事务B读到了事务A中未提交的临时数据（脏数据） =&gt; 写加锁
     </p>
     <p>
      &lt;2&gt; 不可重复读：事务B读的过程中，又有事务C对刚才事务A提交的数据进行了修改，使事务B内部不同的读操作读到的结果不同  =&gt;读加锁
     </p>
     <p>
      &lt;3&gt; 幻读：和不可重复读类似，事务B读的过程中，事务C没有修改数据内容，而是修改了”结果集“，导致B内不同的读操作读到的结果集合不同 =&gt; 串行化
     </p>
    </blockquote>
    <p>
     解决上述问题过程中，要想让数据更准确，就需要牺牲一部分的并发/效率
    </p>
    <p>
     <strong>
      <span style="color:null">
       <span style="background-color:null">
        3）
       </span>
      </span>
      MySQL事务隔离性具体怎么实现的
     </strong>
    </p>
    <p>
     MySQL给程序员提供了
     <span style="color:#be191c">
      <span style="background-color:#fef2f0">
       四个隔离级别
      </span>
     </span>
     ，可以在MySQL中配置文件中进行设置
    </p>
    <blockquote>
     <p>
      &lt;1&gt;
      <strong>
       read uncommitted
      </strong>
      ：允许读取其他事务未提交的数据
     </p>
     <p>
      -&gt; 脏读 + 不可重复读 + 幻读  （并发程度最高，隔离性最低）
     </p>
     <p>
      &lt;2&gt;
      <strong>
       read committed
      </strong>
      ：只能读取其他事务提交后的数据
     </p>
     <p>
      -&gt; 解决了脏读，存在不可重复读+幻读 （并发程度低，隔离性提高）
     </p>
     <p>
      &lt;3&gt;
      <strong>
       repeatable read
      </strong>
      ：针对读操作和写操作都加锁了
     </p>
     <p>
      -&gt; 解决了脏读 + 不可重复读，存在幻读 （并发程度又低，隔离性又提高）
     </p>
     <p>
      &lt;4&gt;
      <strong>
       串行化（serializable)
      </strong>
      ：所有的事务都是串行执行的
     </p>
     <p>
      -&gt; 解决了脏读 + 不可重复读 + 幻读 （并发基本没有，隔离性最高）
     </p>
    </blockquote>
    <p>
     修改MySQL的配置文件，使MySQL服务器处于某个隔离级别中来运行
    </p>
    <p>
     eg：
    </p>
    <p>
     做一个和钱有关的系统，可以设置成串行化
    </p>
    <p>
     做一个短视频点赞系统，就可以设置成读未提交，追求最大的效率
    </p>
    <p>
    </p>
   </div>
  </div>
  <div class="blog-extension-box" id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px">
  </div>
 </article>
 <p alt="68747470733a2f2f62:6c6f672e6373646e2e6e65742f71715f37333031373137382f:61727469636c652f64657461696c732f313436303832373039" class_="artid" style="display:none">
 </p>
</div>


