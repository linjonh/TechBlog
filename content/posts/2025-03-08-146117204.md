---
layout: post
title: "C语言_数据结构总结5顺序栈"
date: 2025-03-08 16:02:21 +0800
description: "前言：是只允许在一端进行插入或删除操作的线性表。：允许进行插入或删除的那一端：固定的，不允许进行插入或删除的那一端后进先出：1. 顺序存储（顺序栈）  2. 链式存储（链式栈）在顺序栈的基本操作中，决定是传入一级指针还是只传入栈的变量，主要取决于操作是否需要修改栈的内部状态。当操作需要修改栈的内部状态，比如改变栈顶指针 top 的值或者修改栈中存储的数据时，就需要传入一级指针。"
keywords: "C语言_数据结构总结5：顺序栈"
categories: ['C']
tags: ['算法', '数据结构', '开发语言', 'Visualstudio', 'Visual', 'Studio', 'C']
artid: "146117204"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146117204
    alt: "C语言_数据结构总结5顺序栈"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146117204
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146117204
cover: https://bing.ee123.net/img/rand?artid=146117204
image: https://bing.ee123.net/img/rand?artid=146117204
img: https://bing.ee123.net/img/rand?artid=146117204
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     C语言_数据结构总结5：顺序栈
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <p>
     <span style="color:#f3f3f4">
      <strong>
       <span style="background-color:#ed7976">
        纯C语言代码，不涉及C++
       </span>
      </strong>
     </span>
    </p>
    <p>
     想了解
     <strong>
      <span style="color:null">
       链式栈
      </span>
     </strong>
     的实现，欢迎查看这篇文章：
     <a href="https://blog.csdn.net/2301_76781059/article/details/146117873?spm=1001.2014.3001.5501" title="C语言_数据结构总结6：链式栈-CSDN博客">
      C语言_数据结构总结6：链式栈-CSDN博客
     </a>
    </p>
    <p>
     <strong>
      这里分享插入一下个人觉得很有用的习惯：
     </strong>
    </p>
    <p>
     1. 就是遇到代码哪里不理解的，你就问豆包，C知道，Kimi等等AI工具，比如在这栈中你不能理解为什么有时候要传一级指针有时候又不用，你就询问AI“在进栈操作中是否可以不传入指针变量，而是直接传入结构体变量”；
    </p>
    <p>
     2. 还有就是自己的代码报错了，又或是自己觉得自己的代码存在某种问题，而自己又不能解决时，你就直接复制自己的代码问AI，让AI对以下代码进行点评，并返回改善后的代码。
    </p>
    <h3>
     前言
    </h3>
    <p>
     <strong>
      栈
     </strong>
     ：是只允许在一端进行插入或删除操作的线性表。
     <br/>
     <strong>
      栈顶
     </strong>
     ：允许进行插入或删除的那一端
     <br/>
     <strong>
      栈底
     </strong>
     ：固定的，不允许进行插入或删除的那一端
     <br/>
     <strong>
      栈的特性
     </strong>
     ：
     <span style="color:null">
      <strong>
       <span style="background-color:#ffd900">
        后进先出
       </span>
      </strong>
     </span>
     <br/>
     <strong>
      存储方式
     </strong>
     ：1. 顺序存储（顺序栈）  2. 链式存储（链式栈）
    </p>
    <p>
     在顺序栈的基本操作中，决定是传入一级指针还是只传入栈的变量，
     <span style="color:null">
      <span style="background-color:null">
       <strong>
        主要取决于操作是否需要修改栈的内部状态
       </strong>
       。
      </span>
     </span>
     <br/>
     <span style="color:#4da8ee">
      <strong>
       1. 需要传入一级指针的情况
      </strong>
     </span>
     <br/>
     当操作需要修改栈的内部状态，比如改变栈顶指针 top 的值或者修改栈中存储的数据时，就需要传入一级指针。
     <br/>
     这是因为在 C 语言里，函数参数传递是值传递，若直接传入栈的变量，函数内部对该变量的修改不会影响到原变量。
     <br/>
     而通过传入指针，函数可以直接访问和修改原变量所指向的内存。
    </p>
    <p>
     <strong>
      <span style="color:#4da8ee">
       2. 只需要传入栈的变量的情况
      </span>
     </strong>
     <br/>
     当操作不需要修改栈的内部状态，仅仅是读取栈的信息时，就可以只传入栈的变量。
    </p>
    <p>
     以下是顺序栈实现
     <br/>
     它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针top指示当前的栈顶元素的位置
    </p>
    <h4>
     0. 结构单元
    </h4>
    <p>
     #define MaxSize 50
     <br/>
     typedef int ElemType;
     <br/>
     typedef struct SqStack {
     <!-- -->
     <br/>
     ElemType data[MaxSize];  //存放栈中元素
     <br/>
     int top;  //栈顶指针
     <br/>
     }SqStack;
    </p>
    <p>
     <span style="color:#f3f3f4">
      <strong>
       <span style="background-color:#be191c">
        ！注意
       </span>
      </strong>
     </span>
     ：栈顶指针top,它不是实际意义上的指针变量，进行存放指针变量。这里说它是指针，意思是说，它指示了当前栈顶元素的位置，在第pos个位置。
    </p>
    <h4>
     1. 初始化
    </h4>
    <pre><code class="language-cs">void InitSeqStack(SqStack* s) {
	s-&gt;top = -1;  //初始化栈顶的位置
}</code></pre>
    <p>
     这里设置初始栈顶指针s.top = -1,
     <br/>
     栈空条件是s.top = -1;栈满条件是s.top = MaxSize - 1
     <br/>
     则进栈时指针s.top+1,再将元素加入栈顶；出栈时先取出栈顶元素，后指针s.top - 1
    </p>
    <p>
     但如果设置初始栈顶指针s.top = 0,
     <br/>
     栈空条件是s.top = 0;栈满条件是s.top = MaxSize
     <br/>
     则进栈时将元素加入栈顶,再指针s.top+1；出栈时先指针s.top - 1，后取出栈顶元素
    </p>
    <h4>
     2. 判空
    </h4>
    <pre><code class="language-cs">int SqStackEmpty(SqStack s) {
	return s.top == -1;
}</code></pre>
    <h4>
     <strong>
      3. 判满
     </strong>
    </h4>
    <pre><code class="language-cs">int SqStackFull(SqStack s) {
	return s.top == MaxSize - 1;
}</code></pre>
    <h4>
     4. 入栈
    </h4>
    <p>
     即：将元素加入到栈顶
    </p>
    <pre><code class="language-cs">int push(SqStack* s, ElemType value) {
	// 1. 判满
	if (SqStackFull(*s))
	{
		printf("栈满，无法入栈!\n");
		return -2;
	}
	// 2. 指针top + 1，再将值加入到栈顶
	s-&gt;top++;
	s-&gt;data[s-&gt;top] = value;
	return 0;  //入栈成功
}</code></pre>
    <h4>
     5. 出栈
    </h4>
    <pre><code class="language-cs">int pop(SqStack* s, ElemType* value) {
	//1. 判空
	if (SqStackEmpty(*s))
	{
		printf("栈空，无法有元素出栈!\n");
		return -1;
	}
	//2. 先取出栈顶元素，再指针top - 1
	*value = s-&gt;data[s-&gt;top];
	s-&gt;top--;
	return 0;  //出栈成功
}</code></pre>
    <h4>
     6. 获取栈顶元素
    </h4>
    <pre><code class="language-cs">int getTop(SqStack s,ElemType *value) {
	//1. 判空
	if (SqStackEmpty(s))
	{
		printf("栈空，无法有元素出栈!\n");
		return -1;
	}
	//2. 获取栈顶元素
	*value = s.data[s.top];
	return 0;  
}</code></pre>
    <h4>
     7. 打印栈中元素
    </h4>
    <pre><code class="language-cs">void printSqStack(SqStack s) {
	if (SqStackEmpty(s))
	{
		printf("栈空!\n");
		return;  //提前结束该函数
	}
	printf("栈中的元素（从栈底到栈顶）为: ");
	for (int i = 0; i &lt;= s.top; i++) {
		printf("%d ", s.data[i]);
	}
	printf("\n");
}</code></pre>
    <h4>
     8. 销毁
    </h4>
    <pre><code class="language-cs">void destroySqStack(SqStack* s) {
	// 由于顺序栈使用的是静态数组，不需要显式释放内存
	// 只需要将栈顶指针置为 -1 表示栈为空
	s-&gt;top = -1;
}</code></pre>
    <h4>
     9. 测试
    </h4>
    <pre><code class="language-cs">int main() {
	SqStack s;
	InitSeqStack(&amp;s);

	// 测试入栈操作
	push(&amp;s, 11);
	push(&amp;s, 22);
	push(&amp;s, 33);
	printSqStack(s);  // 栈中的元素（从栈底到栈顶）为: 11 22 33

	// 获取栈顶元素
	ElemType value;
	if (getTop(s,&amp;value) == 0)
	{
		printf("当前栈顶元素为：%d\n", value); // 当前栈顶元素为：33
	}

	//测试出栈操作
	if (pop(&amp;s,&amp;value) == 0)
	{
		printf("出栈的元素为：%d\n", value);  // 出栈的元素为：33
	}
	printSqStack(s);  // 栈中的元素（从栈底到栈顶）为: 11 22

	//销毁栈
	destroySqStack(&amp;s);
	printSqStack(s);  // 栈空!

	return 0;
}</code></pre>
    <h4>
     10. 完整代码
    </h4>
    <pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
/*
	栈：是只允许在一端进行插入或删除操作的线性表。
	栈顶：允许进行插入或删除的那一端
	栈底：固定的，不允许进行插入或删除的那一端
	栈的特性：后进先出
	存储方式：1. 顺序存储（顺序栈）  2. 链式存储（链式栈）
*/

/*
    在顺序栈的基本操作中，决定是传入一级指针还是只传入栈的变量，主要取决于操作是否需要修改栈的内部状态。
	1. 需要传入一级指针的情况
	当操作需要修改栈的内部状态，比如改变栈顶指针 top 的值或者修改栈中存储的数据时，就需要传入一级指针。
	这是因为在 C 语言里，函数参数传递是值传递，若直接传入栈的变量，函数内部对该变量的修改不会影响到原变量。
	而通过传入指针，函数可以直接访问和修改原变量所指向的内存。

	2. 只需要传入栈的变量的情况
	当操作不需要修改栈的内部状态，仅仅是读取栈的信息时，就可以只传入栈的变量。

*/

/*
   以下是顺序栈实现
   它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针top指示当前的栈顶元素的位置
*/


#define MaxSize 50
typedef int ElemType;
typedef struct SqStack {
	ElemType data[MaxSize];  //存放栈中元素
	int top;  //栈顶指针（注意，它不是实际意义上的指针变量，进行存放指针变量。这里说它是指针，意思是说，它指示了当前栈顶元素的位置，在第pos个位置。
}SqStack;

// 操作1——初始化
void InitSeqStack(SqStack* s) {
	s-&gt;top = -1;  //初始化栈顶的位置
}

/*
    这里设置初始栈顶指针s.top = -1,
	栈空条件是s.top = -1;栈满条件是s.top = MaxSize - 1
	则进栈时指针s.top+1,再将元素加入栈顶；出栈时先取出栈顶元素，后指针s.top - 1
	
	但如果设置初始栈顶指针s.top = 0,
	栈空条件是s.top = 0;栈满条件是s.top = MaxSize
	则进栈时将元素加入栈顶,再指针s.top+1；出栈时先指针s.top - 1，后取出栈顶元素	
*/

// 操作2——判空
int SqStackEmpty(SqStack s) {
	return s.top == -1;
}

// 操作3——判满
int SqStackFull(SqStack s) {
	return s.top == MaxSize - 1;
}

// 操作4——入栈,将元素加到栈顶
int push(SqStack* s, ElemType value) {
	// 1. 判满
	if (SqStackFull(*s))
	{
		printf("栈满，无法入栈!\n");
		return -2;
	}
	// 2. 指针top + 1，再将值加入到栈顶
	s-&gt;top++;
	s-&gt;data[s-&gt;top] = value;
	return 0;  //入栈成功
}

// 操作5——出栈
int pop(SqStack* s, ElemType* value) {
	//1. 判空
	if (SqStackEmpty(*s))
	{
		printf("栈空，无法有元素出栈!\n");
		return -1;
	}
	//2. 先取出栈顶元素，再指针top - 1
	*value = s-&gt;data[s-&gt;top];
	s-&gt;top--;
	return 0;  //出栈成功
}

// 操作6——获取栈顶元素
int getTop(SqStack s,ElemType *value) {
	//1. 判空
	if (SqStackEmpty(s))
	{
		printf("栈空，无法有元素出栈!\n");
		return -1;
	}
	//2. 获取栈顶元素
	*value = s.data[s.top];
	return 0;  
}

// 操作7——打印栈中元素
void printSqStack(SqStack s) {
	if (SqStackEmpty(s))
	{
		printf("栈空!\n");
		return;  //提前结束该函数
	}
	printf("栈中的元素（从栈底到栈顶）为: ");
	for (int i = 0; i &lt;= s.top; i++) {
		printf("%d ", s.data[i]);
	}
	printf("\n");
}

// 操作8——销毁栈
void destroySqStack(SqStack* s) {
	// 由于顺序栈使用的是静态数组，不需要显式释放内存
	// 只需要将栈顶指针置为 -1 表示栈为空
	s-&gt;top = -1;
}

int main() {
	SqStack s;
	InitSeqStack(&amp;s);

	// 测试入栈操作
	push(&amp;s, 11);
	push(&amp;s, 22);
	push(&amp;s, 33);
	printSqStack(s);  // 栈中的元素（从栈底到栈顶）为: 11 22 33

	// 获取栈顶元素
	ElemType value;
	if (getTop(s,&amp;value) == 0)
	{
		printf("当前栈顶元素为：%d\n", value); // 当前栈顶元素为：33
	}

	//测试出栈操作
	if (pop(&amp;s,&amp;value) == 0)
	{
		printf("出栈的元素为：%d\n", value);  // 出栈的元素为：33
	}
	printSqStack(s);  // 栈中的元素（从栈底到栈顶）为: 11 22

	//销毁栈
	destroySqStack(&amp;s);
	printSqStack(s);  // 栈空!

	return 0;
}</code></pre>
    <h4>
     11. 运行截图
    </h4>
    <p style="text-align:center">
     <img alt="" src="https://i-blog.csdnimg.cn/direct/d6dccae8387f413cbdcafe38ca515ed3.png"/>
    </p>
    <p>
    </p>
    <p>
     <span style="color:#be191c">
      <strong>
       本人菜鸟一只，文章如有出错处，欢迎评论区指正！
      </strong>
     </span>
    </p>
    <p>
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330315f37363738313035392f:61727469636c652f64657461696c732f313436313137323034" class_="artid" style="display:none">
 </p>
</div>


