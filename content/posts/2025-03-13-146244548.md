---
layout: post
title: "Django系列教程7路由配置URLConf"
date: 2025-03-13 23:06:55 +0800
description: "Django的项目文件夹和每个应用(app)目录下都有urls.py文件，它们构成了Django的路由配置系统(URLconf)。服务器收到用户请求后，会根据用户请求的url地址和urls.py里配置的url-视图映射关系，去调用执行相应的视图函数或视图类，最后由视图返回给客户端数据。一个优美的URL不仅层次分明、逻辑清晰，而且便于搜索引擎收录。一个糟糕的URL不仅可读性差，而且易造成程序冲突。本章小编我将给大家详细介绍下如何在Django项目开发中进行路由配置。"
keywords: "Django系列教程（7）——路由配置URLConf"
categories: ['Django']
tags: ['Django']
artid: "146244548"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146244548
    alt: "Django系列教程7路由配置URLConf"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146244548
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146244548
cover: https://bing.ee123.net/img/rand?artid=146244548
image: https://bing.ee123.net/img/rand?artid=146244548
img: https://bing.ee123.net/img/rand?artid=146244548
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     Django系列教程（7）——路由配置URLConf
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <hr id="hr-toc" name="tableOfContents"/>
    <p>
    </p>
    <p>
     Django的项目文件夹和每个应用(app)目录下都有
     <code>
      urls.py
     </code>
     文件，它们构成了Django的路由配置系统(URLconf)。服务器收到用户请求后，会根据用户请求的url地址和urls.py里配置的url-视图映射关系，去调用执行相应的视图函数或视图类，最后由视图返回给客户端数据。
    </p>
    <p>
     一个优美的URL不仅层次分明、逻辑清晰，而且便于搜索引擎收录。一个糟糕的URL不仅可读性差，而且易造成程序冲突。本章小编我将给大家详细介绍下如何在Django项目开发中进行路由配置。
    </p>
    <h3 id="urlconf是如何工作的" name="urlconf是如何工作的">
     URLconf是如何工作的?
    </h3>
    <p>
     假如我们有一个
     <code>
      blog
     </code>
     的博客应用，你需要编写两个视图函数，一个用于展示文章列表，一个用于展示文章详情，你的
     <code>
      urls.py
     </code>
     和
     <code>
      views.py
     </code>
     正常情况下应如下所示：
    </p>
    <pre><code># blog/urls.py
from django.urls import path
from . import views
 
urlpatterns = [
    path('blog/', views.index),
    path('blog/articles/&lt;int:id&gt;/', views.article_detail),
]
 
# blog/views.py
def index(request):
    # 展示所有文章
   
def article_detail(request, id):
    # 展示某篇具体文章
</code></pre>
    <p>
     那么上面这段代码是如何工作的呢？
    </p>
    <ul>
     <li>
      当用户在浏览器输入
      <code>
       /blog/
      </code>
      时，URL收到请求后会调用视图
      <code>
       views.py
      </code>
      里的
      <code>
       index
      </code>
      方法，展示所有文章
     </li>
     <li>
      当用户在浏览器输入
      <code>
       /blog/article/&lt;int:id&gt;/
      </code>
      时，URL不仅调用了
      <code>
       views.py
      </code>
      里的
      <code>
       article_detail
      </code>
      方法，而且还把参数文章id通过
      <code>
       &lt;&gt;
      </code>
      括号的形式传递给了视图。int这里代表只传递整数，传递的参数名字是id。
     </li>
    </ul>
    <p>
     在上述代码中，我们通过
     <code>
      urlpatterns
     </code>
     列表的url-视图映射关系列表起了决定性作用，起到了任务调度的作用。
    </p>
    <p>
     注意：注意当你配置URL时，别忘了把你的应用(blog)的urls加入到项目的URL配置里(mysite/urls.py), 如下图所示:
    </p>
    <pre><code>from django.urls import include, path

urlpatterns = [
    path('', include('blog.urls')),
    ...
]
</code></pre>
    <h3 id="path和re_path方法" name="path和re_path方法">
     path和re_path方法
    </h3>
    <p>
     写个URL很简单，但如何通过URL把参数传递给给视图view是个技术活。Django提供了两种设计URL的方法:
     <code>
      path
     </code>
     和
     <code>
      re_path
     </code>
     ，它们均支持向视图函数或类传递参数。
     <code>
      path
     </code>
     是正常参数传递，
     <code>
      re_path
     </code>
     是采用正则表达式regex匹配。
     <code>
      path
     </code>
     和
     <code>
      re_path
     </code>
     传递参数方式如下:
    </p>
    <ul>
     <li>
      <p>
       <code>
        path
       </code>
       方法：采用双尖括号
       <code>
        &lt;变量类型:变量名&gt;
       </code>
       或
       <code>
        &lt;变量名&gt;
       </code>
       传递，例如
       <code>
        &lt;int:id&gt;
       </code>
       ,
       <code>
        &lt;slug:slug&gt;
       </code>
       或
       <code>
        &lt;username&gt;
       </code>
       。
      </p>
     </li>
     <li>
      <p>
       <code>
        re_path
       </code>
       方法: 采用命名组
       <code>
        (?P&lt;变量名&gt;表达式)
       </code>
       的方式传递参数。
      </p>
     </li>
    </ul>
    <p>
     下例中，我们分别以
     <code>
      path
     </code>
     和
     <code>
      re_path
     </code>
     定以了两个urls，它们是等效的，把文章的id(整数类型)传递给了视图。
     <code>
      re_path
     </code>
     里引号前面的小写r表示引号里为正则表达式,
     <code>
      ^
     </code>
     代表开头，
     <code>
      $
     </code>
     代表以结尾，
     <code>
      \d+
     </code>
     代表正整数。
    </p>
    <pre><code># blog/urls.py
from django.urls import path, re_path
from . import views
 
urlpatterns = [
    path('blog/articles/&lt;int:id&gt;/', views.article_detail, name = 'article_detail'),
    re_path(r'^blog/articles/(?P&lt;id&gt;\d+)/$', views.article_detail, name='article_detail'),
]
 
# blog/views.py
def article_detail(request, id):
    # 展示某篇文章
</code></pre>
    <p>
     在使用
     <code>
      path
     </code>
     和
     <code>
      re_path
     </code>
     方法设计urls需注意：
    </p>
    <ul>
     <li>
      url中的参数名要用尖括号，而不是圆括号；
     </li>
     <li>
      匹配模式的最开头不需要添加斜杠
      <code>
       /
      </code>
      ，但建议以斜杠结尾;
     </li>
     <li>
      使用
      <code>
       re_path
      </code>
      时不一定总是以
      <code>
       $
      </code>
      结尾，有时不能加。比如下例中把
      <code>
       blog.urls
      </code>
      通过
      <code>
       re_path
      </code>
      加入到项目urls中时就不能以
      <code>
       $
      </code>
      结尾，因为这里的
      <code>
       blog/
      </code>
      并不是完整的url，只是一个开头而已。
     </li>
    </ul>
    <pre><code>from django.urls import include, re_path

urlpatterns = [
    re_path(r'^blog/', include('blog.urls')),
    ...
]
</code></pre>
    <h3 id="更多url配置示例" name="更多url配置示例">
     更多URL配置示例
    </h3>
    <p>
     <code>
      path
     </code>
     支持匹配的数据类型只有
     <code>
      str
     </code>
     ,
     <code>
      int
     </code>
     ,
     <code>
      slug
     </code>
     ,
     <code>
      uuid
     </code>
     四种。一般来说
     <code>
      re_path
     </code>
     更强大，但写起来更复杂一些，我们来看看更多案例。
    </p>
    <pre><code># 示例一，PATH
from django.urls import path
from . import views

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/&lt;int:year&gt;/', views.year_archive),
    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive),
    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/', views.article_detail),
]

# 示例二：RE_PATH，与上例等同
from django.urls import path, re_path
from . import views

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive),
    re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$', views.month_archive),
    re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/(?P&lt;slug&gt;[\w-]+)/$', views.article_detail),
]

</code></pre>
    <p>
     同样以博客为例，如果你希望设计不同的urls分别对应负责增删改查操作的视图函数或类，你可以按如下设计：
    </p>
    <pre><code># blog/urls.py
from django.urls import path, re_path
from . import views

# app_name = 'blog' # 命名空间，后面会用到。
urlpatterns = [
    path('blog/articles/', views.article_list, name = 'article_list'),
    path('blog/articles/create/', views.article_create, name = 'article_create'),
    path('blog/articles/&lt;int:id&gt;/', views.article_detail, name = 'article_detail'),
    path('blog/articles/&lt;int:id&gt;/update/', views.article_update, name = 'article_update'),
    path('blog/articles/&lt;int:id&gt;/delete/', views.article_update, name = 'article_delete'),
]

</code></pre>
    <h3 id="url的命名及reverse方法" name="url的命名及reverse方法">
     URL的命名及reverse()方法
    </h3>
    <p>
     你注意到没？在上述博客示例中，我们中还给每个URL取了一个名字，比如
     <code>
      article_list
     </code>
     和
     <code>
      article_create
     </code>
     。这个名字大有用处，相当于给每个URL取了个全局变量的名字。它可以让你能够在Django的任意处，尤其是模板内显式地引用它。假设你需要在模板中通过链接指向一篇具体文章，下面那种方式更好？
    </p>
    <h4 id="使用命名url" name="使用命名url">
     使用命名URL
    </h4>
    <pre><code>{% for article in articles %}
    &lt;a href="{% url 'article_detail' article.id %}"&gt;{<!-- -->{ article.title }}&lt;/a&gt;
{% endfor %}
</code></pre>
    <p>
     <code>
      url
     </code>
     是个模板标签，其作用是对命名的url进行方向解析，动态生成链接。
    </p>
    <p>
     注意：命名的url里有几个参数，使用
     <code>
      url
     </code>
     模板标签反向生成动态链接时，就需要向它传递几个参数。比如我们的命名url
     <code>
      article_detail
     </code>
     里有整数型
     <code>
      id
     </code>
     这个参数，我们在模板中还需要传递
     <code>
      article.id
     </code>
     。
    </p>
    <h4 id="硬编码url---不建议" name="硬编码url---不建议">
     硬编码URL - 不建议
    </h4>
    <pre><code>{% for article in articles %}
    &lt;a href="blog/articles/{<!-- -->{ article.id }}"&gt;{<!-- -->{ article.title }}&lt;/a&gt;
{% endfor %}
</code></pre>
    <p>
     如果你还没意识到方法1的好处，那么想想吧，假设老板让你把全部模板链接由blog/articles/id改为blog/article/id, 那种方法更快？更改所有html文件里的链接，还是只改URL配置里的一个字母?
    </p>
    <p>
     那么问题来了。假设不同的app（比如news和blog)里都有
     <code>
      article_detail
     </code>
     这个命名URL, 我们怎么避免解析冲突呢？ 这时我们只需要在
     <code>
      blog/urls.py
     </code>
     加上
     <code>
      app_name='blog'
     </code>
     这个命名空间即可，然后在模板中以
     <code>
      blog:article_detail
     </code>
     使用即可。
    </p>
    <pre><code>{% for article in articles %}
    &lt;a href="{% url 'blog:article_detail' article.id %}"&gt;{<!-- -->{ article.title }}&lt;/a&gt;
{% endfor %}
</code></pre>
    <p>
     可惜的是命名的URL一般只在模板里使用，不能直接在视图里使用。如果我们有了命名的URL，我们如何把它转化成常规的URL在视图里使用呢？
    </p>
    <p>
     Django提供的
     <code>
      reverse()
     </code>
     方法很容易实现这点。它在视图中可以对命名urls进行反向解析，生成动态链接。
    </p>
    <pre><code>from django.urls import reverse

# output blog/articles/id
reverse('blog:article_detail', args=[id]) 
</code></pre>
    <h3 id="url指向基于类的视图view" name="url指向基于类的视图view">
     URL指向基于类的视图(View)
    </h3>
    <p>
     目前
     <code>
      path
     </code>
     和
     <code>
      re_path
     </code>
     都只能指向视图view里的一个函数或方法，而不能直接指向一个基于类的视图(Class based view)。Django提供了一个额外
     <code>
      as_view()
     </code>
     方法，可以将一个类伪装成方法。这点在当你使用Django自带的类视图或自定义的类视图时非常重要。
    </p>
    <p>
     具体使用方式如下:
    </p>
    <pre><code># blog/urls.py
from django.urls import path, re_path
from . import views
 
urlpatterns = [
    # path('blog/articles/', views.article_list, name = 'article_list'),
    path('blog/articles/', views.ArticleList.as_view(), name='article_list'),
]
 
# View (in blog/views.py)
from django.views.generic import ListView
from .views import Article
 
class ArticleList(ListView):
    queryset = Article.objects.filter(date__lte=timezone.now()).order_by('date')[:5]
    context_object_name = 'article_list‘
    template_name = 'blog/article_list.html'
</code></pre>
    <p>
     如果你对基于类的视图还比较困惑，没有关系，我们后面会做详细介绍。
    </p>
    <h3 id="通过url传递额外的参数" name="通过url传递额外的参数">
     通过URL传递额外的参数
    </h3>
    <p>
     在你配置URL时，你还可以通过字典的形式传递额外的参数给视图, 而不用把这个参数写在链接里。如下面案例所示:
    </p>
    <pre><code># blog/urls.py
from django.urls import path, re_path
from . import views
 
urlpatterns = [
    path('', views.ArticleList.as_view(), name='article_list', {'blog_id': 3}),
]
</code></pre>
    <h3 id="小结" name="小结">
     小结
    </h3>
    <p>
     本章我们讲解了如何使用
     <code>
      path
     </code>
     和
     <code>
      re_path
     </code>
     方法进行url配置，并详细介绍了什么命名的urls以及如何使用
     <code>
      url
     </code>
     模板标签和
     <code>
      reverse
     </code>
     方法对命名urls进行反向解析。下篇文章中我们将正式介绍视图的编写，欢迎阅读。
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f:2f626c6f672e6373646e2e6e65742f68656c75646f6974312f:61727469636c652f64657461696c732f313436323434353438" class_="artid" style="display:none">
 </p>
</div>


