---
arturl_encode: "68747470733a2f2f62:6c6f672e6373646e2e6e65742f6d305f37343639363235372f:61727469636c652f64657461696c732f313436323136333032"
layout: post
title: "洞悉C内存结构解锁深层优化潜力"
date: 2025-03-12 22:09:11 +08:00
description: "静态局部变量：延长了变量的生命周期，使其在整个程序执行过程中都存在，但是它的作用域依旧保持局部特性。静态全局变量：减少了变量的作用域至单个文件内，并防止了外部文件的直接访问。静态函数：确保函数只在定义它的文件内可用，增强了代码模块化程度和封装性。通过合理使用static关键字，开发者可以更好地组织代码结构，减少不必要的命名冲突，同时提高代码的安全性和可维护性。需要注意的是，在C++中，static还有另外一层含义，即用于类成员变量和成员函数，这超出了本文讨论的范围。但在面向对象编程中，static。"
keywords: "洞悉C++内存结构：解锁深层优化潜力"
categories: ['C']
tags: ['笔记', 'Vim', 'C', 'C']
artid: "146216302"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146216302
    alt: "洞悉C内存结构解锁深层优化潜力"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146216302
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146216302
cover: https://bing.ee123.net/img/rand?artid=146216302
image: https://bing.ee123.net/img/rand?artid=146216302
img: https://bing.ee123.net/img/rand?artid=146216302
---

# 洞悉C++内存结构：解锁深层优化潜力

---

## 内存布局

64位系统，理论空间达到16EB（2^64）,但是受硬件限制，并不会达到这么多；

以32位系统为例，一个进程在执行时，能够访问的空间是
**虚拟地址空间**
。理论上为2^32，即4G，有1G左右的空间是内核态，剩下的3G左右的空间是用户态。从高地址到低地址可以分为五个区域：

### 栈区

* 栈区：操作系统控制，由高地址向低地址生长，编译器做了优化，显示地址时栈区和其他区域保持一致的方向。

  ###### 栈区的特性

  栈区由编译器自动管理，这意味着当一个函数被调用时，系统会自动为该函数分配一块栈空间来存放其参数、返回地址以及局部变量等信息。一旦函数执行完毕，这块栈空间会被自动释放，以便于后续函数调用使用。

  ###### 存储内容

  1. **函数参数**
     ：每当一个函数被调用时，它的参数值会被压入栈中。这些参数通常是按从右向左的顺序入栈的，这是因为在大多数C语言编译器中，参数传递遵循这样的规则，这样可以方便地处理可变数量的参数。
  2. **局部变量**
     ：函数内部定义的所有局部变量都会被分配在栈上。局部变量的生命周期与它们所在的函数调用周期相同。一旦函数执行结束，局部变量所占用的栈空间将被回收。
  3. **函数返回地址**
     ：当一个函数被调用时，当前指令指针（即下一条应执行指令的地址）也会被保存到栈中，以确保函数执行完成后能够正确地返回到调用点继续执行。
  4. **寄存器状态**
     ：为了保持函数调用过程中CPU寄存器的状态一致性，有时需要将某些寄存器的值保存到栈中。这通常发生在函数需要修改寄存器但又希望在返回前恢复原始值的情况下。
  5. **其他临时数据**
     ：除了上述内容外，栈还可能用于存放一些临时性的中间计算结果或辅助数据结构，如递归调用中的上下文信息等。

  ###### 生长方向

  栈区的生长方向是从高地址向低地址扩展，这意味着栈顶的位置是逐渐减小的。这种设计有助于快速分配和释放栈空间，因为它只需要移动栈顶指针即可完成操作。

  ###### **内存限制**

  每个进程的栈大小是有限制的，具体数值取决于操作系统和编译选项。例如，在Windows平台上，默认的栈大小可能是1MB或2MB，而在Linux环境下，这个值可能会有所不同。如果应用程序需要更多的栈空间，可以通过调整编译器选项或者运行时配置来进行修改。

  总之，栈区是程序执行期间动态变化的一个重要区域，对于维持程序逻辑的正常运作至关重要。了解栈的工作原理可以帮助开发者更好地优化代码性能，避免诸如栈溢出等问题的发生。同时，合理利用栈的特点，比如高效的内存分配速度，也可以提升程序的整体效率。

### 堆区

* 堆区：程序员分配，由低地址向高地址生长，堆区与栈区没有明确的界限。

  堆区（Heap）是程序内存分区中的另一个关键部分，主要用于动态内存分配。与栈区不同，堆区由程序员负责管理，包括内存的申请和释放。以下是关于堆区的详细说明：

  ###### 堆区的特点

  + **动态分配**
    ：堆区允许程序在运行时根据需要动态地请求一定大小的内存块。这种灵活性使得堆非常适合用于那些大小在编译时无法确定的数据结构，如大型数组、链表或者树等复杂数据结构。
  + **手动管理**
    ：由于堆区的内存分配和释放不由编译器自动处理，而是由程序员通过显式的调用（如C语言中的
    `malloc()`
    、
    `calloc()`
    、
    `realloc()`
    以及
    `free()`
    函数，或C++中的
    `new`
    和
    `delete`
    操作符）来完成，因此更容易出现内存泄漏问题。
  + **生长方向**
    ：堆是从低地址向高地址增长的，这与栈区相反。这意味着随着更多的内存被分配给堆，堆顶的位置会逐渐向上移动。
  + **不连续性**
    ：堆并不是一块连续的内存区域；它通常是由操作系统维护的一个空闲内存链表组成。当程序请求内存时，系统会遍历这个链表寻找合适的空闲块，并将其分配出去。如果找到的块比所需的大，多余的部分会被重新插入到空闲链表中。

  ###### 存储内容

  堆区可以存储任何类型的数据，但主要是那些在编译期无法确定其确切大小或生存周期的对象。例如：

  + 动态创建的对象实例。
  + 需要跨函数调用边界共享的数据。
  + 大型数据结构，比如数组、链表等，这些结构的大小可能在编译时未知或变化不定。

  ###### 分配效率

  相比栈区，堆区的分配效率较低，因为它涉及到更复杂的内存管理机制，包括搜索可用空间、更新内存映射等操作。此外，频繁地分配和释放堆内存还可能导致内存碎片化，降低系统的整体性能。

  ###### 内存回收

  如果没有正确地释放堆区内存，那么即使不再使用的内存也不会被回收，从而导致内存泄漏。长期运行的应用程序如果不妥善管理堆内存，可能会耗尽系统资源，影响其他进程的正常运作。现代编程语言如Java和C#提供了垃圾收集器（Garbage Collector），能够自动追踪并回收不再使用的堆内存，减少了人为错误的可能性。

  ###### 实际应用示例

  下面是一个简单的例子展示了如何在C++中使用堆来动态分配内存：

  ```cpp
  #include <iostream>
  ​
  int main() {
      // 使用 new 在堆上分配一个整数
      int* pInt = new int(10);
      std::cout << "Value: " << *pInt << std::endl;
  ​
      // 释放堆上的内存
      delete pInt;
  ​
      return 0;
  }
  ```

  在这个例子中，我们首先使用
  `new`
  关键字为一个整数分配了堆内存，并初始化为值10。之后，我们通过
  `delete`
  操作符释放了这块内存，防止内存泄漏的发生。

  综上所述，堆区提供了一种灵活但需谨慎管理的内存分配方式，对于构建复杂且动态变化的应用程序至关重要。理解堆的工作原理有助于编写更加健壮和高效的代码。

### 全局/静态区

* 全局/静态区：读写段（数据段），存放全局变量、静态变量。

  全局静态区，也常被称为静态区或全局区，在C和C++中用于存储程序的全局变量和静态变量。这个区域可以进一步分为已初始化的数据段（.data）和未初始化的数据段（.bss）。下面详细解释一下全局静态区的特点及其内容。

  ###### 已初始化数据段（.data）

  + **存放内容**
    ：已初始化的全局变量和静态变量被放置在这一段。这些变量在程序启动时就会被赋予初始值，并且在整个程序运行期间都保持有效。
  + **生命周期**
    ：从程序开始执行直到程序结束，这些变量始终存在，它们的生命周期贯穿整个程序的运行过程。
  + **作用域**
    ：根据定义的位置和是否有
    `static`
    关键字修饰，决定其作用域是全局还是局部于文件内部。

  ###### 未初始化数据段（.bss）

  + **存放内容**
    ：未初始化的全局变量和静态变量被放在.bss段。这里的“未初始化”实际上指的是那些程序员没有显式初始化的变量，编译器会自动将这些变量初始化为零（对于数值类型）或者空指针（对于指针类型）。
  + **内存占用**
    ：由于.bss段中的变量默认都是零初始化的，因此该段并不实际包含任何数据，而是仅保留了描述这些变量所需的空间大小的信息。

  ###### 静态变量

  无论是全局静态变量还是函数内部的静态局部变量，都被存放在全局静态区内。静态局部变量具有以下特点：

  1. 它们只会在第一次进入函数时进行初始化，并且在整个程序运行期间一直存在，即使控制流离开了定义它的函数也不会被销毁。
  2. 如果没有明确地给静态局部变量赋初值，则它会被自动初始化为0或NULL（取决于变量类型）。

  ###### 全局变量

  + **可见性与链接性**
    ：如果一个全局变量前加上了
    `static`
    关键字，则它的链接属性变为内部链接，即只能在定义它的源文件内访问；如果没有
    `static`
    关键字，则默认为外部链接，允许其他源文件通过
    `extern`
    声明来访问该变量。

  ###### 示例代码

  ```cpp
  #include <iostream>
  ​
  int globalVar = 10; // 存储在.data段
  static int staticGlobalVar = 20; // 存储在.data段，但仅在当前文件内可见
  ​
  void func() {
      static int staticLocalVar = 30; // 存储在.data段，仅在func函数内可见，且生命周期覆盖整个程序运行期
      std::cout << "Static Local Var: " << staticLocalVar << std::endl;
  }
  ​
  int main() {
      extern int globalVar; // 引用已定义的全局变量
      static int staticLocalInMain = 40; // 同样存储在.data段，仅在main函数内可见
  ​
      std::cout << "Global Var: " << globalVar << std::endl;
      std::cout << "Static Global Var: " << staticGlobalVar << std::endl;
      func();
      return 0;
  }
  ```

  在这个例子中，
  `globalVar`
  和
  `staticGlobalVar`
  被存储在
  `.data`
  段，而未初始化的静态局部变量如
  `staticLocalVar`
  和
  `staticLocalInMain`
  在首次调用时会被初始化为0或指定的初始值。所有这些变量都将存在于全局静态区内，直到程序结束。

  总结来说，全局静态区提供了持久化的存储空间，使得变量可以在程序的不同部分之间共享数据，并且通过
  `static`
  关键字可以有效地控制变量的作用域和链接属性。这对于模块化编程和封装设计非常有用。

##### static 的作用范围

`static`
关键字在C和C++语言中有多种作用，主要体现在变量和函数的存储期、作用域以及链接性上。下面将详细解释
`static`
关键字的不同用法及其影响。

###### 1. 局部静态变量

当
`static`
用于修饰函数内部的局部变量时，该变量就变成了静态局部变量。这意味着：

* **存储位置**
  ：静态局部变量被分配在全局数据区而不是栈区。
* **初始化**
  ：即使没有显式地给它赋初值，编译器也会将其初始化为0。
* **生命周期**
  ：从程序开始到结束，即使控制流离开了定义它的函数，静态局部变量也不会被销毁。
* **作用域**
  ：尽管其生命周期贯穿整个程序运行期间，但它的作用域仍然是局部的，只能在其定义所在的函数体内访问。

```cpp
void fn_static(void) {
    static int n = 10; // 静态局部变量
    printf("static n=%d\n", n);
    n++;
}
```

###### 2. 全局静态变量

对于全局变量，加上
`static`
后，变量的作用范围仅限于定义它的源文件内：

* **存储位置**
  ：仍然位于全局数据区。
* **初始化**
  ：如果没有显式初始化，则默认值为0。
* **作用域与链接性**
  ：静态全局变量具有内部链接属性，即只能在定义它的文件中使用。其他文件不能通过
  `extern`
  声明来访问这个变量。

```
static int globalVar = 5; // 静态全局变量，只能在当前文件中访问
```

###### 3. 静态函数

`static`
同样可以用来限定函数的作用范围：

* **链接性**
  ：静态函数具有内部链接属性，意味着它只能在定义它的源文件内部调用，无法被其他文件引用。
* **作用域**
  ：虽然名为“静态”，但它并不改变函数的作用域，只是限制了函数的可见性和可访问性。

```
static void privateFunction() { // 静态函数，只能在当前文件中调用
    // 函数体
}
```

###### 总结

* **静态局部变量**
  ：延长了变量的生命周期，使其在整个程序执行过程中都存在，但是它的作用域依旧保持局部特性。
* **静态全局变量**
  ：减少了变量的作用域至单个文件内，并防止了外部文件的直接访问。
* **静态函数**
  ：确保函数只在定义它的文件内可用，增强了代码模块化程度和封装性。

通过合理使用
`static`
关键字，开发者可以更好地组织代码结构，减少不必要的命名冲突，同时提高代码的安全性和可维护性。需要注意的是，在C++中，
`static`
还有另外一层含义，即用于类成员变量和成员函数，这超出了本文讨论的范围。但在面向对象编程中，
`static`
也可以用来表示类级别的属性或行为，而非实例级别的。

### 文字常量区

* 文字常量区：只读段，存放程序中直接使用的常量，如const char \* p = "hello"; hello这个内容就存在文字常量区。

  在C++中，文字常量区（也称为字符串常量区或只读数据区）是一个特殊的内存区域，专门用于存储程序中的字符串常量。这个区域的特性对于理解和正确使用C++至关重要，因为它涉及到内存管理、变量作用域和生命周期等关键概念。下面详细探讨C++中的文字常量区。

  ###### 文字常量区的特点

  1. **只读性**
     ：文字常量区的数据是只读的。任何试图修改该区域内数据的行为都将导致未定义行为，通常会导致程序崩溃或者异常终止。例如，尝试通过指针修改一个字符串常量的内容是不允许的。
  2. **生命周期**
     ：文字常量区的数据在整个程序执行过程中都是有效的。它们与程序代码一起加载到内存，并且直到程序结束才会被释放。
  3. **共享性**
     ：如果程序中有多个地方使用相同的字符串常量，编译器可能会优化并让所有引用指向同一个内存地址上的字符串，从而节省内存空间。
  4. **存储位置**
     ：根据不同的实现细节，文字常量可能被放置在静态存储区或代码段（text segment）中。这取决于具体的编译器和操作系统环境。

  ###### 使用示例

  考虑以下简单的C++例子：

  ```cpp
  char *str1 = "Hello, World!";
  const char *str2 = "Hello, World!";
  char str3[] = "Hello, World!";
  ```

  在这段代码中，
  `"Hello, World!"`
  是一个字符串常量。对于
  `str1`
  来说，它实际上是指向文字常量区的一个指针；而对于
  `str2`
  ，尽管它是用
  `const`
  修饰的，其本质与
  `str1`
  相同，即指向文字常量区。而
  `str3`
  则是在栈上创建了一个数组，并将字符串常量（字符常量先被存出到了文字常量区）复制到了这个数组中。因此，直接修改
  `str3`
  中的字符是合法的，但是尝试修改
  `str1`
  或
  `str2`
  所指向的内容会导致错误。

  ###### 内存管理

  由于文字常量区的数据是由编译器生成并在程序启动时加载的，所以不需要显式的分配或释放操作。程序员无需担心这部分内存的管理问题，只需要确保不尝试去改变文字常量区的内容即可。

  ###### 注意事项

  + 在C++中，为了强调字符串常量不应被修改，建议使用
    `const char *`
    而不是
    `char *`
    来声明指向字符串常量的指针。
  + 如果需要可变的字符串副本，应该使用如
    `new[]`
    或者栈上的字符数组来创建一个新的字符串实例。

  ###### 结论

  理解文字常量区的工作原理有助于编写更高效、安全的C++程序。通过正确地利用这一特性，可以避免不必要的内存复制，同时也能确保程序的健壮性。记住，不要试图修改文字常量区的内容，这是保障程序稳定性的基本原则之一。

  此外，在C++中，随着C++11标准引入了
  `constexpr`
  关键字，允许编译时常量表达式，进一步增强了对常量的支持，但这并不直接影响文字常量区的本质特性。不过，合理使用这些新特性可以帮助开发者写出更加高效的代码。

### 程序代码区

* 程序代码区：只读段，存放函数体的二进制代码。

  在C++程序中，代码区（也称为文本段或.text段）是内存布局的一部分，专门用于存储程序的机器指令。这个区域是只读的，这意味着一旦加载到内存中，就不能对其进行修改。这种设计主要是为了防止程序意外地修改其自身的指令集，从而提高程序的安全性和稳定性。

  ###### 代码区的特点

  1. **只读性**
     ：由于代码区包含的是程序执行的指令集，因此它是只读的，以防止程序运行时意外修改这些指令。
  2. **共享性**
     ：对于频繁被执行的程序部分，比如库函数，它们的代码可以被多个进程共享，这样可以节省内存资源。这在多任务操作系统中尤为重要，因为多个应用程序可能同时使用相同的库函数。
  3. **固定大小**
     ：代码区的大小通常是在编译时确定的，并且不会在程序运行期间改变。
  4. **生命周期**
     ：从程序开始加载到内存直到程序结束，代码区一直存在。

  ###### 代码区与链接过程的关系

  当一个C++程序被编译成可执行文件时，它会经历预处理、编译、汇编和链接四个主要步骤。在这个过程中，源代码首先被转换为汇编语言，然后转化为机器码，最后通过链接器将各个目标文件和所需的库链接在一起形成最终的可执行文件。代码区就是由这些机器指令组成的，它们被加载到内存的特定位置以便CPU执行。

  ###### 示例

  考虑以下简单的C++程序：

  ```cpp
  #include <iostream>
  ​
  int main() {
      std::cout << "Hello, World!" << std::endl;
      return 0;
  }
  ```

  这段代码经过编译后会被转换成一系列的机器指令，并存放在代码区内。当程序运行时，操作系统会加载这些指令到内存中的代码区，CPU则按照顺序执行这些指令来完成程序的功能。

  ###### 安全性和优化

  由于代码区是只读的，这不仅提高了安全性，还允许编译器和运行时系统进行某些优化。例如，如果两个不同的进程需要执行相同的代码片段，操作系统可以安排这两个进程共享同一份代码副本，而不是各自拥有一份副本，这样就减少了内存占用并提高了效率。

  此外，现代编译器还可以对代码区内的指令进行优化，比如指令重排序、循环展开等，以进一步提升程序性能。然而，这类优化必须确保程序的行为符合原始源代码的规定。

  总结来说，代码区是C++程序的重要组成部分，负责存放程序的所有指令。了解代码区的工作原理有助于更好地理解程序的内存布局和执行流程，以及如何编写高效的C++代码。

![image-20240306170314449](https://i-blog.csdnimg.cn/img_convert/82b5a25a6c8de112f5f85d412e7acd87.png)

![image-20240306162513492](https://i-blog.csdnimg.cn/img_convert/c45bb29b591bb10570c4345a41cfab8d.png)