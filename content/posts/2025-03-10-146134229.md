---
layout: post
title: "数据结构链表"
date: 2025-03-10 22:30:28 +0800
description: "链表只是一种工具，\\(￣︶￣*\\)) 以此为始，开启成神之路喽。算法的核心并不依赖于数学，而是基于明确的步骤与逻辑去解决问题，这才是关键。"
keywords: "【数据结构】链表"
categories: ['算法']
tags: ['链表', '算法', '数据结构', 'Java', 'C']
artid: "146134229"
image:
    path: https://api.vvhan.com/api/bing?rand=sj&artid=146134229
    alt: "数据结构链表"
render_with_liquid: false
featuredImage: https://bing.ee123.net/img/rand?artid=146134229
featuredImagePreview: https://bing.ee123.net/img/rand?artid=146134229
cover: https://bing.ee123.net/img/rand?artid=146134229
image: https://bing.ee123.net/img/rand?artid=146134229
img: https://bing.ee123.net/img/rand?artid=146134229
---

<div class="blog-content-box">
 <div class="article-header-box">
  <div class="article-header">
   <div class="article-title-box">
    <h1 class="title-article" id="articleContentId">
     【数据结构】链表
    </h1>
   </div>
  </div>
 </div>
 <article class="baidu_pl">
  <div class="article_content clearfix" id="article_content">
   <link href="../../assets/css/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
   <link href="../../assets/css/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
   <div class="htmledit_views" id="content_views">
    <h3>
     <strong>
      引言：
     </strong>
    </h3>
    <h4>
     <strong>
      什么是链表？？
     </strong>
    </h4>
    <p>
     简单来说，链表就是通过指针串联起来的线性结构，每个节点由两部分构成，值域与指针域。指针域内存放的是下一个节点的内存地址。
    </p>
    <p>
     <img alt="" height="176" src="https://i-blog.csdnimg.cn/direct/52c46261eee4452bbbfa013460a7cf46.png" width="683"/>
    </p>
    <h4>
     <strong>
      链表的储存方式
     </strong>
    </h4>
    <p>
     大家都知道，数组在内存中的空间是连续的。但是链表不是，链表通过，每个指针的指针域，链接每个节点在内存中的位置。
    </p>
    <div>
     <p>
      <img alt="" height="237" src="https://i-blog.csdnimg.cn/direct/a55a6650d37e477195a0789e4eda57fa.png" width="357">
       ​
      </img>
     </p>
    </div>
    <h4>
     <strong>
      链表的种类
     </strong>
    </h4>
    <h5>
     单链表
    </h5>
    <p>
     以上说的就是单链表！
    </p>
    <h5>
     双链表
    </h5>
    <p>
     单链表中，每个节点只存放一个数据域与一个指针域(内部存放下一个节点的位置)。
    </p>
    <p>
     而双链表中，每一个节点存放一个数据域与两个指针域，一个指针域存放的是上一个节点的地址，另一个指针域存放的是下一个节点的地址，这样，就能同时向两侧进行查询。
    </p>
    <div>
     <p>
      <img alt="" height="144" src="https://i-blog.csdnimg.cn/direct/217abe51058741c1896d1e6c88b26fba.png" width="581">
       ​
      </img>
     </p>
    </div>
    <h5>
     循环链表
    </h5>
    <p>
     简单解释就是，单链表形成了环。
    </p>
    <div>
     <p>
      <img alt="" height="282" src="https://i-blog.csdnimg.cn/direct/08c95a9b286e44608012cc0a9bcf059d.png" width="297">
       ​
      </img>
     </p>
    </div>
    <h4>
     <strong>
      链表的定义
     </strong>
    </h4>
    <h5>
     单链表的定义
    </h5>
    <div>
     <pre><code class="language-cpp">struct ListNode{
    int val;
    ListNode* next;
    ListNode():val(0),next(nullptr){};
    ListNode(int x):val(x),next(nullptr){};
};</code></pre>
    </div>
    <h5>
     初始化
    </h5>
    <div>
     <pre><code class="language-cpp">ListNode* cur1 = new ListNode(2);
ListNode* cur2 = new ListNode();
cur2-&gt;val = 2; // (*cur2).val = 2;</code></pre>
    </div>
    <h5>
     双链表的定义
    </h5>
    <div>
     <pre><code class="language-cpp">// 定义双向链表节点结构体
struct ListNode {
    int val;
    ListNode* prev;  // 指向前一个节点的指针
    ListNode* next;  // 指向后一个节点的指针
    ListNode() : val(0), prev(nullptr), next(nullptr) {}
    ListNode(int x) : val(x), prev(nullptr), next(nullptr) {}
};</code></pre>
    </div>
    <h4>
     C++中，是如何运用该链表的！！！
    </h4>
    <p>
     其实这才是重点！哈哈STL库！我最喜欢用了！接下来，就好好的说一下stl！
    </p>
    <p>
     &lt;list&gt;是C++标准模板库中的一个序列容器。可以不用向&lt;vector&gt;一样，在创建时指定大小。
    </p>
    <p>
     <strong>
      优点
     </strong>
     是删除、插入为O(1)，
     <strong>
      缺点
     </strong>
     是查找速度是O(N)
    </p>
    <p>
     以下是简单的
     <strong>
      增删改查
     </strong>
     的运用。
    </p>
    <div>
     <pre><code class="language-cpp">#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
int main(){
    list&lt;int&gt; l;
    // 增
    l.push_back(2);
    l.push_front(1);
    
    // 查
    for(int i:l) cout&lt;&lt;i;cout&lt;&lt;endl;
    for(auto it= l.begin(); it!=l.end(); ++it) cout&lt;&lt;*it&lt;&lt;endl;

    // 改 - 遍历的时候修改
    
    // 删
    // 结合这迭代器删
    auto it = find(l.begin(),l.end(),3);
    if(it!=l.end()) l.erase(it); // 必须要判断一下
    for(auto it= l.begin(); it!=l.end(); ++it) {
        if(*it==3)
          l.erase(it); // 当然也能这样删除一下
    }
    // 引入remove删，直接删除所有
    l.remove(3);
    // 头删、尾删
    l.pop_front();
    l.pop_back();
    return 0;
}</code></pre>
    </div>
    <p>
     好吧，当我写完之后，发现我又不是那么喜欢它了！(┬┬﹏┬┬)，好像也不是那么好用。相比于&lt;vector&gt;。
    </p>
    <h3>
     大纲
    </h3>
    <p>
     1、
     <a class="link-info" href="https://leetcode.cn/problems/remove-linked-list-elements/description/" rel="nofollow" title="移除链表元素">
      移除链表元素
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E8%8A%82%E7%82%B9%C2%A0head%C2%A0%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%C2%A0val%C2%A0%EF%BC%8C%E8%AF%B7%E4%BD%A0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%C2%A0Node.val%20%3D%3D%20val%C2%A0%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%C2%A0%E6%96%B0%E7%9A%84%E5%A4%B4%E8%8A%82%E7%82%B9%C2%A0%E3%80%82" title="解析">
      解析
     </a>
     ）-设置一个头节点
    </p>
    <p>
     2、
     <a href="https://leetcode.cn/problems/design-linked-list/" rel="nofollow" title=" 设计链表">
      设计链表
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%7D%3B-,%E4%BA%8C%E3%80%81%C2%A0%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8,-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9" title="解析">
      解析
     </a>
     ）-基操
    </p>
    <p>
     3、
     <a href="https://leetcode.cn/problems/reverse-linked-list/" rel="nofollow" title="反转链表">
      反转链表
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=*/-,%E4%B8%89%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8,-%E7%BB%99%E4%BD%A0%E5%8D%95" title="解析">
      解析
     </a>
     ）-临时节点的优雅运用
    </p>
    <p>
     4、
     <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" rel="nofollow" title="两两交换链表中的节点">
      两两交换链表中的节点
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%7D%3B-,%E5%9B%9B%E3%80%81%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9,-%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA" title="解析">
      解析
     </a>
     ）-优雅运用临时节点
    </p>
    <p>
     5、
     <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" rel="nofollow" title="删除链表的倒数第 N 个结点">
      删除链表的倒数第 N 个结点
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%7D%3B-,%E4%BA%94%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9,-%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA" title="解析">
      解析
     </a>
     ）-双指针用法
    </p>
    <p>
     6、
     <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" rel="nofollow" title="链表相交">
      链表相交
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%7D%3B-,%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4,-%E7%BB%99%E4%BD%A0%E4%B8%A4" title="解析">
      解析
     </a>
     ）-数学思维，列公式
    </p>
    <p>
     7、
     <a href="https://leetcode.cn/problems/linked-list-cycle-ii/" rel="nofollow" title="环形链表 II">
      环形链表 II
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%7D%3B-,%E4%B8%83%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II,-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA" title="解析">
      解析
     </a>
     ）-数学思维，Floyed判圈(龟兔赛跑)，初步洞悉算法
    </p>
    <p>
     8、
     <a class="link-info" href="https://www.lanqiao.cn/problems/2219/learning/?page=1&amp;first_category_id=1&amp;second_category_id=3&amp;tags=%E9%93%BE%E8%A1%A8&amp;tag_relation=union" rel="nofollow" title="左移右移">
      左移右移
     </a>
     -（
     <a href="https://blog.csdn.net/2302_80067378/article/details/146134229?sharetype=blogdetail&amp;sharerId=146134229&amp;sharerefer=PC&amp;sharesource=2302_80067378&amp;spm=1011.2480.3001.8118#:~:text=%7D%3B-,%E5%85%AB%E3%80%81%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB,-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" title="解析">
      解析
     </a>
     ）-蓝桥真题，运用struct与数组，跳出链条问题
    </p>
    <p>
     ( •̀ ω •́ )✧
     <a href="https://blog.csdn.net/2302_80067378/article/details/145763039?spm=1001.2014.3001.5501#:~:text=%E7%9C%9F%E9%A2%98%E7%BB%83%E4%B9%A0%EF%BC%89-,%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87%EF%BC%9A,-1%E3%80%81%E6%9E%9A%E4%B8%BE" title="点击这里">
      点击这里
     </a>
     ，继续学习其他模块吧！
    </p>
    <h3>
     题目
    </h3>
    <h5>
     ​​​​​​一、
     <a class="link-info" href="https://leetcode.cn/problems/remove-linked-list-elements/description/" rel="nofollow" title="移除链表元素">
      移除链表元素
     </a>
    </h5>
    <blockquote>
     <p>
      给你一个链表的头节点
      <code>
       head
      </code>
      和一个整数
      <code>
       val
      </code>
      ，请你删除链表中所有满足
      <code>
       Node.val == val
      </code>
      的节点，并返回
      <strong>
       新的头节点
      </strong>
      。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/bc4550fec08a4f490b1973d49700a881.jpeg" width="782">
        ​
       </img>
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6
<strong>输出：</strong>[1,2,3,4,5]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = [], val = 1
<strong>输出：</strong>[]
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = [7,7,7,7], val = 7
<strong>输出：</strong>[]
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       列表中的节点数目在范围
       <code>
        [0, 104]
       </code>
       内
      </li>
      <li>
       <code>
        1 &lt;= Node.val &lt;= 50
       </code>
      </li>
      <li>
       <code>
        0 &lt;= val &lt;= 50
       </code>
      </li>
     </ul>
    </blockquote>
    <div>
     <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
// 设置一个虚拟节点，可以事半功倍
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 整理一个虚拟头节点
        ListNode* curHead = new ListNode(-1);
        curHead-&gt;next = head;
        ListNode* cur = curHead;
        while(cur-&gt;next!=nullptr){
            if(cur-&gt;next-&gt;val==val) cur-&gt;next=cur-&gt;next-&gt;next;
            else cur=cur-&gt;next;
        } 
        return curHead-&gt;next;
    }
};</code></pre>
    </div>
    <h5>
     二、
     <a href="https://leetcode.cn/problems/design-linked-list/" rel="nofollow" title=" 设计链表">
      设计链表
     </a>
    </h5>
    <blockquote>
     <p>
      你可以选择使用单链表或者双链表，设计并实现自己的链表。
     </p>
     <p>
      单链表中的节点应该具备两个属性：
      <code>
       val
      </code>
      和
      <code>
       next
      </code>
      。
      <code>
       val
      </code>
      是当前节点的值，
      <code>
       next
      </code>
      是指向下一个节点的指针/引用。
     </p>
     <p>
      如果是双向链表，则还需要属性
      <code>
       prev
      </code>
      以指示链表中的上一个节点。假设链表中的所有节点下标从
      <strong>
       0
      </strong>
      开始。
     </p>
     <p>
      实现
      <code>
       MyLinkedList
      </code>
      类：
     </p>
     <ul>
      <li>
       <code>
        MyLinkedList()
       </code>
       初始化
       <code>
        MyLinkedList
       </code>
       对象。
      </li>
      <li>
       <code>
        int get(int index)
       </code>
       获取链表中下标为
       <code>
        index
       </code>
       的节点的值。如果下标无效，则返回
       <code>
        -1
       </code>
       。
      </li>
      <li>
       <code>
        void addAtHead(int val)
       </code>
       将一个值为
       <code>
        val
       </code>
       的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
      </li>
      <li>
       <code>
        void addAtTail(int val)
       </code>
       将一个值为
       <code>
        val
       </code>
       的节点追加到链表中作为链表的最后一个元素。
      </li>
      <li>
       <code>
        void addAtIndex(int index, int val)
       </code>
       将一个值为
       <code>
        val
       </code>
       的节点插入到链表中下标为
       <code>
        index
       </code>
       的节点之前。如果
       <code>
        index
       </code>
       等于链表的长度，那么该节点会被追加到链表的末尾。如果
       <code>
        index
       </code>
       比长度更大，该节点将
       <strong>
        不会插入
       </strong>
       到链表中。
      </li>
      <li>
       <code>
        void deleteAtIndex(int index)
       </code>
       如果下标有效，则删除链表中下标为
       <code>
        index
       </code>
       的节点。
      </li>
     </ul>
     <p>
     </p>
     <p>
      <strong>
       示例：
      </strong>
     </p>
     <pre><strong>输入</strong>
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
<strong>输出</strong>
[null, null, null, null, 2, null, 3]

<strong>解释</strong>
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3
myLinkedList.get(1);              // 返回 3
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       <code>
        0 &lt;= index, val &lt;= 1000
       </code>
      </li>
      <li>
       请不要使用内置的 LinkedList 库。
      </li>
      <li>
       调用
       <code>
        get
       </code>
       、
       <code>
        addAtHead
       </code>
       、
       <code>
        addAtTail
       </code>
       、
       <code>
        addAtIndex
       </code>
       和
       <code>
        deleteAtIndex
       </code>
       的次数不超过
       <code>
        2000
       </code>
       。
      </li>
     </ul>
    </blockquote>
    <div>
     <pre><code class="language-cpp">class MyLinkedList { // 创建一个链表，真为链表
public:
    struct LinkedList{ // 创建节点
        int val;
        LinkedList* next;
        LinkedList():val(0),next(nullptr){}
        LinkedList(int x): val(x),next(nullptr){}
        LinkedList(int x,LinkedList* next): val(x),next(next){}
    };

    MyLinkedList() { // 初始化用的
        _dummyHead = new LinkedList(0); // 首元节点
        size = 0;
    }

    int get(int index) {
        if(index&gt;=size){
            return -1;
        }
        LinkedList* _dummyCur = _dummyHead;
        while(index--){
            _dummyCur = _dummyCur-&gt;next;
        }
        return _dummyCur-&gt;next-&gt;val;
    }

    void addAtHead(int val) {
        LinkedList* cur = new LinkedList(val); // 创建临时节点
        cur-&gt;next = _dummyHead-&gt;next;
        _dummyHead-&gt;next = cur;
        size++;
    }

    void addAtTail(int val) {
        LinkedList* cur = new LinkedList(val); // 创建临时节点
        LinkedList* _dummyCur = _dummyHead;
        while(_dummyCur-&gt;next != nullptr){
            _dummyCur=_dummyCur-&gt;next;
        }
        _dummyCur-&gt;next = cur;
        size++;
    }

    void addAtIndex(int index, int val) {
        if(index&gt;=size){ // 如果，长度与index相等的情况下
            if(index==size) addAtTail(val);
            return;
        }

        LinkedList* cur = new LinkedList(val); // 创建临时节点
        LinkedList* _dummyCur = _dummyHead;

        while(index--){ // 换位置
            _dummyCur=_dummyCur-&gt;next;
        }

        // 插
        cur-&gt;next = _dummyCur-&gt;next;
        _dummyCur-&gt;next = cur;

        size++;
    }

    void deleteAtIndex(int index) {
        if(index&gt;=size) return;  // 无效
        LinkedList* _dummyCur = _dummyHead;
        while(index--){
            _dummyCur=_dummyCur-&gt;next;
        }
        _dummyCur-&gt;next= _dummyCur-&gt;next-&gt;next; // 直接跳过

        size--;
    }
private: // 创建本函数中，宏观上需要的东西
    int size;
    LinkedList* _dummyHead;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj-&gt;get(index);
 * obj-&gt;addAtHead(val);
 * obj-&gt;addAtTail(val);
 * obj-&gt;addAtIndex(index,val);
 * obj-&gt;deleteAtIndex(index);
 */</code></pre>
    </div>
    <h5>
     三、
     <a href="https://leetcode.cn/problems/reverse-linked-list/" rel="nofollow" title="反转链表">
      反转链表
     </a>
    </h5>
    <blockquote>
     <p>
      给你单链表的头节点
      <code>
       head
      </code>
      ，请你反转链表，并返回反转后的链表。
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/c1745ef10fecde95b93ac8005ab3df54.jpeg" width="542">
        ​
       </img>
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/ced0e0b62614b8e14eaa0ae6a23ea64d.jpeg" width="182">
        ​
       </img>
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       链表中节点的数目范围是
       <code>
        [0, 5000]
       </code>
      </li>
      <li>
       <code>
        -5000 &lt;= Node.val &lt;= 5000
       </code>
      </li>
     </ul>
     <p>
      <strong>
       进阶：
      </strong>
      链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
     </p>
    </blockquote>
    <div>
     <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
// 其实就是临时节点的运用
public:
    ListNode* reverseList(ListNode* head) { // 其实挺简单的，但是为啥我就想这么久呢
        ListNode* cur = head;
        ListNode* temp1 = nullptr;
        ListNode* temp2 = nullptr;
        while(cur!=nullptr){
            temp1 = cur-&gt;next;
            cur-&gt;next = temp2;
            temp2 = cur;
            cur = temp1;
        }
        return temp2;
    }
};</code></pre>
    </div>
    <h5>
     四、
     <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" rel="nofollow" title="两两交换链表中的节点">
      两两交换链表中的节点
     </a>
    </h5>
    <blockquote>
     <p>
      给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <div>
      <p>
       <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/15c09be84dac8c242f6e2357c8150b2d.jpeg" width="422">
        ​
       </img>
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1,2,3,4]
<strong>输出：</strong>[2,1,4,3]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = [1]
<strong>输出：</strong>[1]
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       链表中节点的数目在范围
       <code>
        [0, 100]
       </code>
       内
      </li>
      <li>
       <code>
        0 &lt;= Node.val &lt;= 100
       </code>
      </li>
     </ul>
    </blockquote>
    <div>
     <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) { // 建立几个临时变量存储
        // 这两步，是基操
        ListNode* dummyCur = new ListNode(0);
        dummyCur-&gt;next = head;

        ListNode* cur = dummyCur;
        ListNode* temp1 = nullptr;
        ListNode* temp2 = nullptr;
        while(cur-&gt;next!=nullptr&amp;&amp;cur-&gt;next-&gt;next!=nullptr){
            temp1 = cur-&gt;next;
            temp2 = cur-&gt;next-&gt;next;
            temp1-&gt;next = temp2-&gt;next;
            temp2-&gt;next = temp1;
            cur-&gt;next = temp2;
            cur = temp1;
        }
        
        return dummyCur-&gt;next;
    }
};</code></pre>
    </div>
    <h5>
     五、
     <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" rel="nofollow" title="删除链表的倒数第 N 个结点">
      删除链表的倒数第 N 个结点
     </a>
    </h5>
    <blockquote>
     <p>
      给你一个链表，删除链表的倒数第
      <code>
       n
      </code>
      <em>
      </em>
      个结点，并且返回链表的头结点。
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="222" src="https://i-blog.csdnimg.cn/img_convert/2822aafe01bfb3055948ea4211d75c50.jpeg" width="542"/>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1,2,3,4,5], n = 2
<strong>输出：</strong>[1,2,3,5]
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = [1], n = 1
<strong>输出：</strong>[]
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <pre><strong>输入：</strong>head = [1,2], n = 1
<strong>输出：</strong>[1]
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       链表中结点的数目为
       <code>
        sz
       </code>
      </li>
      <li>
       <code>
        1 &lt;= sz &lt;= 30
       </code>
      </li>
      <li>
       <code>
        0 &lt;= Node.val &lt;= 100
       </code>
      </li>
      <li>
       <code>
        1 &lt;= n &lt;= sz
       </code>
      </li>
     </ul>
     <p>
      <strong>
       进阶：
      </strong>
      你能尝试使用一趟扫描实现吗？
     </p>
    </blockquote>
    <div>
     <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
// 简单运用双指针法
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) { // 要想一趟实现，双指针法
        ListNode* dummyHead = new ListNode(0);
        dummyHead-&gt;next = head;
        ListNode* cur = dummyHead;
        ListNode* left = dummyHead;
        n  = n+1;
        while(n--) cur = cur-&gt;next;
        while(cur!=nullptr){
            left = left-&gt;next;
            cur = cur-&gt;next;
        }
        left-&gt;next = left-&gt;next-&gt;next;
        return dummyHead-&gt;next;   
    }
};</code></pre>
    </div>
    <h5>
     六、
     <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" rel="nofollow" title="链表相交">
      链表相交
     </a>
    </h5>
    <blockquote>
     <p>
      给你两个单链表的头节点
      <code>
       headA
      </code>
      和
      <code>
       headB
      </code>
      ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回
      <code>
       null
      </code>
      。
     </p>
     <p>
      图示两个链表在节点
      <code>
       c1
      </code>
      开始相交
      <strong>
       ：
      </strong>
     </p>
     <div>
      <p>
       <a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" rel="nofollow">
        <img alt="" height="241" src="https://i-blog.csdnimg.cn/img_convert/8c26b29b1a810248cb43ed62cf7cc589.png" width="742"/>
       </a>
       ​
      </p>
     </div>
     <p>
      题目数据
      <strong>
       保证
      </strong>
      整个链式结构中不存在环。
     </p>
     <p>
      <strong>
       注意
      </strong>
      ，函数返回结果后，链表必须
      <strong>
       保持其原始结构
      </strong>
      。
     </p>
     <p>
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <div>
      <p>
       <a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" rel="nofollow">
        <img alt="" height="241" src="https://i-blog.csdnimg.cn/img_convert/2b73613fb325d7f9f29375618172a13a.png" width="742"/>
       </a>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
<strong>输出：</strong>Intersected at '8'
<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <div>
      <p>
       <a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" rel="nofollow">
        <img alt="" height="241" src="https://i-blog.csdnimg.cn/img_convert/3a3e53558eb52f9e594177930dee4501.png" width="622"/>
       </a>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>输出：</strong>Intersected at '2'
<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <div>
      <p>
       <a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" rel="nofollow">
        <img alt="" height="241" src="https://i-blog.csdnimg.cn/img_convert/3201eb98e824de99f082a2b2769dfd54.png" width="382"/>
       </a>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>输出：</strong>null
<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       <code>
        listA
       </code>
       中节点数目为
       <code>
        m
       </code>
      </li>
      <li>
       <code>
        listB
       </code>
       中节点数目为
       <code>
        n
       </code>
      </li>
      <li>
       <code>
        0 &lt;= m, n &lt;= 3 * 104
       </code>
      </li>
      <li>
       <code>
        1 &lt;= Node.val &lt;= 105
       </code>
      </li>
      <li>
       <code>
        0 &lt;= skipA &lt;= m
       </code>
      </li>
      <li>
       <code>
        0 &lt;= skipB &lt;= n
       </code>
      </li>
      <li>
       如果
       <code>
        listA
       </code>
       和
       <code>
        listB
       </code>
       没有交点，
       <code>
        intersectVal
       </code>
       为
       <code>
        0
       </code>
      </li>
      <li>
       如果
       <code>
        listA
       </code>
       和
       <code>
        listB
       </code>
       有交点，
       <code>
        intersectVal == listA[skipA + 1] == listB[skipB + 1]
       </code>
      </li>
     </ul>
    </blockquote>
    <div>
     <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 // 这压根就是一道数学题，一道数学思想
 // 还有指针变换时，地址会改变的细节(┬┬﹏┬┬)
 /*
    大概意思就是，
    一个指针走了 a+c+b的长度
    另一个指针，走了 b+c+a 的长度
    最后一定会相交
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 其实这个应该也挺好写的
            ListNode* a = headA; ListNode* b = headB;
        while(headA!=headB){ // a与b一直在改变
            headA = headA!=nullptr ? headA-&gt;next : b;
            headB = headB!=nullptr ? headB-&gt;next : a;
        }
        return headA; 
    }
};</code></pre>
    </div>
    <h5>
     七、
     <a href="https://leetcode.cn/problems/linked-list-cycle-ii/" rel="nofollow" title="环形链表 II">
      环形链表 II
     </a>
    </h5>
    <blockquote>
     <p>
      给定一个链表的头节点
      <code>
       head
      </code>
      ，返回链表开始入环的第一个节点。
      <em>
       如果链表无环，则返回
       <code>
        null
       </code>
       。
      </em>
     </p>
     <p>
      如果链表中有某个节点，可以通过连续跟踪
      <code>
       next
      </code>
      指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数
      <code>
       pos
      </code>
      来表示链表尾连接到链表中的位置（
      <strong>
       索引从 0 开始
      </strong>
      ）。如果
      <code>
       pos
      </code>
      是
      <code>
       -1
      </code>
      ，则在该链表中没有环。
      <strong>
       注意：
       <code>
        pos
       </code>
       不作为参数进行传递
      </strong>
      ，仅仅是为了标识链表的实际情况。
     </p>
     <p>
      <strong>
       不允许修改
      </strong>
      链表。
     </p>
     <p>
      <strong>
       示例 1：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="171" src="https://i-blog.csdnimg.cn/img_convert/e67b66a4c1565619869a386f5da114c9.png" width="531"/>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>返回索引为 1 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre>
     <p>
      <strong>
       示例 2：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="105" src="https://i-blog.csdnimg.cn/img_convert/44fc0e720f366c87f9de8c9077297311.png" width="201"/>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>返回索引为 0 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre>
     <p>
      <strong>
       示例 3：
      </strong>
     </p>
     <p>
     </p>
     <div>
      <p>
       <img alt="" height="65" src="https://i-blog.csdnimg.cn/img_convert/924a59fdcbf37f61046686501c227dbe.png" width="65"/>
       ​
      </p>
     </div>
     <pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>返回 null
<strong>解释：</strong>链表中没有环。
</pre>
     <p>
      <strong>
       提示：
      </strong>
     </p>
     <ul>
      <li>
       链表中节点的数目范围在范围
       <code>
        [0, 104]
       </code>
       内
      </li>
      <li>
       <code>
        -105 &lt;= Node.val &lt;= 105
       </code>
      </li>
      <li>
       <code>
        pos
       </code>
       的值为
       <code>
        -1
       </code>
       或者链表中的一个有效索引
      </li>
     </ul>
     <p>
      <strong>
       进阶：
      </strong>
      你是否可以使用
      <code>
       O(1)
      </code>
      空间解决此题？
     </p>
    </blockquote>
    <div>
     <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    // 涉及数学思想，数学的推理过程--&gt;Floyd 判圈算法（也称为龟兔赛跑算法）,如果搜的化，直接问数学思想
    // 当然，本题也能用哈希方式解决
public:
    ListNode *detectCycle(ListNode *head) {
        // 涉及快慢指针
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if(fast==slow) break;
        }
        if(fast==nullptr||fast-&gt;next==nullptr) return nullptr;
        ListNode* ptr = head;
        while(ptr!=slow){
            ptr=ptr-&gt;next;
            slow=slow-&gt;next;
        }
        return ptr;
    }
};</code></pre>
    </div>
    <p>
     八、
    </p>
    <p>
     1. 左移右移
    </p>
    <blockquote>
     <p id="问题描述">
      <strong>
       问题描述
      </strong>
     </p>
     <p>
      小蓝有一个长度为 NN 的数组, 初始时从左到右依次是 1,2,3,…N1,2,3,…N 。
     </p>
     <p>
      之后小蓝对这个数组进行了 MM 次操作, 每次操作可能是以下 2 种之一:
     </p>
     <ol>
      <li>
       <p>
        左移 xx, 即把 xx 移动到最左边。
       </p>
      </li>
      <li>
       <p>
        右移 xx, 即把 xx 移动到最右边。
       </p>
      </li>
     </ol>
     <p>
      请你回答经过 MM 次操作之后, 数组从左到右每个数是多少?
     </p>
     <p id="输入格式">
      <strong>
       输入格式
      </strong>
     </p>
     <p>
      第一行包含 2 个整数, NN 和 MM 。
     </p>
     <p>
      以下 MM 行每行一个操作, 其中 “L xx "表示左移 x,"Rxx,"Rx "表示右移 xx 。
     </p>
     <p id="输出格式">
      <strong>
       输出格式
      </strong>
     </p>
     <p>
      输出 NN 个数, 代表操作后的数组。
     </p>
     <p id="样例输入">
      样例输入
     </p>
     <p id="样例输出">
      样例输出
     </p>
     <div>
      <pre><code>2 3 4 5 1
</code></pre>
     </div>
     <p id="样例说明">
      样例说明
     </p>
     <p>
      样例中的数组变化如下:
     </p>
     <p>
      [1,2,3,4,5]→[3,1,2,4,5]→[2,3,1,4,5]→[2,3,4,5,1][1,2,3,4,5]→[3,1,2,4,5]→[2,3,1,4,5]→[2,3,4,5,1]
     </p>
     <p id="评测用例规模与约定">
      评测用例规模与约定
     </p>
     <p>
      对于 50%50% 的评测用例, 1≤N,M≤100001≤N,M≤10000.
     </p>
     <p>
      对于 100%100% 的评测用例, 1≤N,M≤200000,1≤x≤N1≤N,M≤200000,1≤x≤N.
     </p>
     <p id="运行限制">
      运行限制
     </p>
     <ul>
      <li>
       最大运行时间：3s
      </li>
      <li>
       最大运行内存: 512M
      </li>
     </ul>
    </blockquote>
    <pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    // 涉及数学思想，数学的推理过程--&gt;Floyd 判圈算法（也称为龟兔赛跑算法）,如果搜的化，直接问数学思想
    // 当然，本题也能用哈希方式解决
public:
    ListNode *detectCycle(ListNode *head) {
        // 涉及快慢指针
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if(fast==slow) break;
        }
        if(fast==nullptr||fast-&gt;next==nullptr) return nullptr;
        ListNode* ptr = head;
        while(ptr!=slow){
            ptr=ptr-&gt;next;
            slow=slow-&gt;next;
        }
        return ptr;
    }
};</code></pre>
    <h5>
     八、
     <a class="link-info" href="https://www.lanqiao.cn/problems/2219/learning/?page=1&amp;first_category_id=1&amp;second_category_id=3&amp;tags=%E9%93%BE%E8%A1%A8&amp;tag_relation=union" rel="nofollow" title="左移右移">
      左移右移
     </a>
    </h5>
    <blockquote>
     <p id="问题描述">
      <strong>
       问题描述
      </strong>
     </p>
     <p>
      小蓝有一个长度为 NN 的数组, 初始时从左到右依次是 1,2,3,…N1,2,3,…N 。
     </p>
     <p>
      之后小蓝对这个数组进行了 MM 次操作, 每次操作可能是以下 2 种之一:
     </p>
     <ol>
      <li>
       <p>
        左移 xx, 即把 xx 移动到最左边。
       </p>
      </li>
      <li>
       <p>
        右移 xx, 即把 xx 移动到最右边。
       </p>
      </li>
     </ol>
     <p>
      请你回答经过 MM 次操作之后, 数组从左到右每个数是多少?
     </p>
     <p id="输入格式">
      <strong>
       输入格式
      </strong>
     </p>
     <p>
      第一行包含 2 个整数, NN 和 MM 。
     </p>
     <p>
      以下 MM 行每行一个操作, 其中 “L xx "表示左移 x,"Rxx,"Rx "表示右移 xx 。
     </p>
     <p id="输出格式">
      <strong>
       输出格式
      </strong>
     </p>
     <p>
      输出 NN 个数, 代表操作后的数组。
     </p>
     <p id="样例输入">
      <strong>
       样例输入
      </strong>
     </p>
     <pre><code>5 3
L 3
L 2
R 1
</code></pre>
     <p>
     </p>
     <p id="样例输出">
      <strong>
       样例输出
      </strong>
     </p>
     <pre><code>2 3 4 5 1
</code></pre>
     <p>
     </p>
     <p id="样例说明">
      <strong>
       样例说明
      </strong>
     </p>
     <p>
      <strong>
       样例中的数组变化如下:
      </strong>
     </p>
     <p>
      [1,2,3,4,5]→[3,1,2,4,5]→[2,3,1,4,5]→[2,3,4,5,1][1,2,3,4,5]→[3,1,2,4,5]→[2,3,1,4,5]→[2,3,4,5,1]
     </p>
     <p id="评测用例规模与约定">
      <strong>
       评测用例规模与约定
      </strong>
     </p>
     <p>
      对于 50%50% 的评测用例, 1≤N,M≤100001≤N,M≤10000.
     </p>
     <p>
      对于 100%100% 的评测用例, 1≤N,M≤200000,1≤x≤N1≤N,M≤200000,1≤x≤N.
     </p>
     <p id="运行限制">
      <strong>
       运行限制
      </strong>
     </p>
     <ul>
      <li>
       最大运行时间：3s
      </li>
      <li>
       最大运行内存: 512M
      </li>
     </ul>
    </blockquote>
    <h6>
     Java版
    </h6>
    <pre><code class="language-cpp">import java.util.Scanner;

public class ArrayManipulation {
    public static void main(String[] args) {
        // 创建 Scanner 对象用于从标准输入读取数据
        Scanner scanner = new Scanner(System.in);
        // 读取数组的长度 n 和操作的次数 m
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        // 定义操作结构体数组，这里用两个数组来模拟结构体的功能
        // 一个数组存储操作的方向（字符 'L' 或 'R'）
        char[] directions = new char[m];
        // 一个数组存储操作对应的数字
        int[] numbers = new int[m];

        // 读取 m 次操作，将操作方向和对应的数字分别存储到相应数组中
        for (int i = 0; i &lt; m; i++) {
            directions[i] = scanner.next().charAt(0);
            numbers[i] = scanner.nextInt();
        }

        // 标记数组，用于标记某个数字是否已经被处理过
        boolean[] flag = new boolean[n + 1];
        // 结果数组，用于存储最终操作后的数组元素
        int[] res = new int[n];

        // 左指针，用于从结果数组的左边开始填充元素
        int st = 0;
        // 右指针，用于从结果数组的右边开始填充元素
        int en = n - 1;

        // 逆向遍历操作数组，这样可以确保最后一次操作的元素优先被处理
        // 因为最后一次操作对元素位置的影响是最终有效的
        for (int i = m - 1; i &gt;= 0; i--) {
            int num = numbers[i];
            // 如果该数字已经被处理过，跳过本次操作
            if (flag[num]) {
                continue;
            }
            // 如果操作方向是 'L'，表示左移操作
            if (directions[i] == 'L') {
                // 将该数字放到结果数组的左边，然后左指针右移一位
                res[st++] = num;
            } else {
                // 如果操作方向是 'R'，表示右移操作
                // 将该数字放到结果数组的右边，然后右指针左移一位
                res[en--] = num;
            }
            // 标记该数字已经被处理过
            flag[num] = true;
        }

        // 遍历从 1 到 n 的所有数字，将未被操作过的数字按顺序添加到结果数组中
        for (int i = 1; i &lt;= n; i++) {
            if (!flag[i]) {
                res[st++] = i;
            }
        }

        // 输出结果数组，元素之间用空格分隔，最后一个元素后面不跟空格
        for (int i = 0; i &lt; n - 1; i++) {
            System.out.print(res[i] + " ");
        }
        System.out.print(res[n - 1]);

        // 关闭 Scanner 对象，释放资源
        scanner.close();
    }
}</code></pre>
    <h6>
     C++版：
    </h6>
    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// 且看，本题是如何绕开权重，思考问题的(┬┬﹏┬┬)，受教了
// 将每一步操作，存起来，后续满满释放的
const int N = 1e6+5;
// 全局变量自带初始化
struct Op{
    char c;
    int num;
}op[N];
bool flag[N]; // 表示是否标记过
int res[N]; // 存放结果
int main(){
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0; i&lt;m; ++i){ // 存放
        cin&gt;&gt;op[i].c&gt;&gt;op[i].num;
    }
    int st=0,en=n-1;
    for(int i=m-1; i&gt;=0; --i){ // 逆向思维，破解权重问题
        if(flag[op[i].num]) continue;
        if(op[i].c=='L') res[st++]=op[i].num;
        else res[en--]=op[i].num;
        flag[op[i].num] = true; // 表示已经遍历过
    }
    for(int i=1; i&lt;=n; ++i){
        if(!flag[i]) res[st++]=i;
    }
    for(int i=0; i&lt;n-1; ++i){
        cout&lt;&lt;res[i]&lt;&lt;" ";
    }
    cout&lt;&lt;res[n-1];

    return 0;
}</code></pre>
    <p>
    </p>
    <h3>
     知识点
    </h3>
    <h5>
     一、什么是算法 ::
     <a class="link-info" href="https://www.zhihu.com/question/55136787/answer/3456894699" rel="nofollow" title="基础认知">
      基础认知
     </a>
     ::
    </h5>
    <ul>
     <li>
      <strong>
       算法是一组明确的指令
      </strong>
      ，用于完成任务，无论是否涉及数学。（如食谱、整理文件）
     </li>
     <li>
      算法的核心并不依赖于数学，而是基于明确的步骤与逻辑去解决问题，这才是关键。
     </li>
     <li>
      数学更多的只是起到优化算法的作用。
     </li>
    </ul>
    <p>
    </p>
    <hr/>
    <p>
     <strong>
      借鉴博客：
     </strong>
    </p>
    <p>
     1、
     <a class="link-info" href="https://blog.csdn.net/qq_36831816/article/details/100664508" title="什么是链表？（图解）">
      什么是链表？（图解）
     </a>
    </p>
    <p>
     2、
     <a class="link-info" href="https://blog.csdn.net/Edward_Asia/article/details/120876314" title="【数据结构】链表(单链表实现+详解+原码)">
      【数据结构】链表(单链表实现+详解+原码)
     </a>
    </p>
    <p>
     3、
     <a class="link-info" href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B" rel="nofollow" title="链表理论基础">
      链表理论基础
     </a>
    </p>
    <p>
     4、
     <a class="link-info" href="https://www.runoob.com/cplusplus/cpp-libs-list.html" rel="nofollow" title="C++ 容器类 &lt;list&gt;">
      C++ 容器类 &lt;list&gt;
     </a>
    </p>
    <p>
     5、
     <a class="link-info" href="https://www.zhihu.com/question/55136787/answer/3456894699" rel="nofollow" title="什么是算法">
      什么是算法
     </a>
    </p>
    <hr/>
    <p>
     ( •̀ ω •́ )✧
     <a href="https://blog.csdn.net/2302_80067378/article/details/145763039?spm=1001.2014.3001.5501#:~:text=%E7%9C%9F%E9%A2%98%E7%BB%83%E4%B9%A0%EF%BC%89-,%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87%EF%BC%9A,-1%E3%80%81%E6%9E%9A%E4%B8%BE" title="点击这里">
      点击这里
     </a>
     ，继续学习其他模块吧！
    </p>
   </div>
  </div>
 </article>
 <p alt="68747470733a2f2f626c6f:672e6373646e2e6e65742f323330325f38303036373337382f:61727469636c652f64657461696c732f313436313334323239" class_="artid" style="display:none">
 </p>
</div>


